{
  "metadata": {
    "timestamp": 1736566538055,
    "page": 82,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uber-go/goleak",
      "stars": 4634,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.044921875,
          "content": "vendor/\n/bin\n/lint.log\n/cover.out\n/cover.html\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.673828125,
          "content": "output:\n  # Make output more digestible with quickfix in vim/emacs/etc.\n  sort-results: true\n  print-issued-lines: false\n\nlinters:\n  enable:\n    - gofumpt\n    - nolintlint\n    - revive\n\nlinters-settings:\n  govet:\n    # These govet checks are disabled by default, but they're useful.\n    enable:\n      - niliness\n      - reflectvaluecompare\n      - sortslice\n      - unusedwrite\n  errcheck:\n    exclude-functions:\n      - fmt.Fprintf\n\nissues:\n  # Print all issues reported by all linters.\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\n  # Don't ignore some of the issues that golangci-lint considers okay.\n  # This includes documenting all exported entities.\n  exclude-use-default: false\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.3046875,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## [1.3.0]\n### Fixed\n- Built-in ignores now match function names more accurately.\n  They will no longer ignore stacks because of file names\n  that look similar to function names. (#112)\n### Added\n- Add an `IgnoreAnyFunction` option to ignore stack traces\n  that have the provided function anywhere in the stack. (#113)\n- Ignore `testing.runFuzzing` and `testing.runFuzzTests` alongside\n  other already-ignored test functions (`testing.RunTests`, etc). (#105)\n### Changed\n- Miscellaneous CI-related fixes. (#103, #108, #114)\n\n[1.3.0]: https://github.com/uber-go/goleak/compare/v1.2.1...v1.3.0\n\n## [1.2.1]\n### Changed\n- Drop golang/x/lint dependency.\n\n[1.2.1]: https://github.com/uber-go/goleak/compare/v1.2.0...v1.2.1\n\n## [1.2.0]\n### Added\n- Add Cleanup option that can be used for registering cleanup callbacks. (#78)\n\n### Changed\n- Mark VerifyNone as a test helper. (#75)\n\nThanks to @tallclair for their contribution to this release.\n\n[1.2.0]: https://github.com/uber-go/goleak/compare/v1.1.12...v1.2.0\n\n## [1.1.12]\n### Fixed\n- Fixed logic for ignoring trace related goroutines on Go versions 1.16 and above.\n\n[1.1.12]: https://github.com/uber-go/goleak/compare/v1.1.11...v1.1.12\n\n## [1.1.11]\n### Fixed\n- Documentation fix on how to test.\n- Update dependency on stretchr/testify to v1.7.0. (#59)\n- Update dependency on golang.org/x/tools to address CVE-2020-14040. (#62)\n\n[1.1.11]: https://github.com/uber-go/goleak/compare/v1.1.10...v1.1.11\n\n## [1.1.10]\n### Added\n- [#49]: Add option to ignore current goroutines, which checks for any additional leaks and allows for incremental adoption of goleak in larger projects.\n\nThanks to @denis-tingajkin for their contributions to this release.\n\n[#49]: https://github.com/uber-go/goleak/pull/49\n[1.1.10]: https://github.com/uber-go/goleak/compare/v1.0.0...v1.1.10\n\n## [1.0.0]\n### Changed\n- Migrate to Go modules.\n\n### Fixed\n- Ignore trace related goroutines that cause false positives with -trace.\n\n[1.0.0]: https://github.com/uber-go/goleak/compare/v0.10.0...v1.0.0\n\n## [0.10.0]\n- Initial release.\n\n[0.10.0]: https://github.com/uber-go/goleak/compare/v0.10.0...HEAD\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2018 Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.78125,
          "content": "# Directory containing the Makefile.\nPROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))\n\nexport GOBIN = $(PROJECT_ROOT)/bin\nexport PATH := $(GOBIN):$(PATH)\n\nGO_FILES = $(shell find . \\\n\t   -path '*/.*' -prune -o \\\n\t   '(' -type f -a -name '*.go' ')' -print)\n\n# Additional test flags.\nTEST_FLAGS ?=\n\n.PHONY: all\nall: lint build test\n\n.PHONY: lint\nlint: golangci-lint tidy-lint\n\n.PHONY: build\nbuild:\n\tgo build ./...\n\n.PHONY: test\ntest:\n\tgo test -v -race ./...\n\tgo test -v -trace=/dev/null .\n\n.PHONY: cover\ncover:\n\tgo test -race -coverprofile=cover.out -coverpkg=./... ./...\n\tgo tool cover -html=cover.out -o cover.html\n\n.PHONY: golangci-lint\ngolangci-lint:\n\tgolangci-lint run\n\n.PHONY: tidy\ntidy:\n\tgo mod tidy\n\n.PHONY: tidy-lint\ntidy-lint:\n\tgo mod tidy\n\tgit diff --exit-code -- go.mod go.sum\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.705078125,
          "content": "# goleak [![GoDoc][doc-img]][doc] [![Build Status][ci-img]][ci] [![Coverage Status][cov-img]][cov]\n\nGoroutine leak detector to help avoid Goroutine leaks.\n\n## Installation\n\nYou can use `go get` to get the latest version:\n\n`go get -u go.uber.org/goleak`\n\n`goleak` also supports semver releases.\n\nNote that go-leak only [supports][release] the two most recent minor versions of Go.\n\n## Quick Start\n\nTo verify that there are no unexpected goroutines running at the end of a test:\n\n```go\nfunc TestA(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\t// test logic here.\n}\n```\n\nInstead of checking for leaks at the end of every test, `goleak` can also be run\nat the end of every test package by creating a `TestMain` function for your\npackage:\n\n```go\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n```\n\n### Note\n\nFor tests that use [t.Parallel](https://pkg.go.dev/testing#T.Parallel), `goleak` does\nnot know how to distinguish a leaky goroutine from tests that have not finished running.\n\n\n```go\nfunc TestA(t *testing.T) {\n\ttt := struct{\n\t\tname  \t string\n\t\tinput \t SomeType\n\t\texpected string\n\t}{\n\t\t// ...\n\t}\n\n\tfor _, t := range tt {\n\t\tt.Run(t.name, func(t *testing.T) {\n\t\t\tt.Parallel() // <- goleak gets confused here!\n\n\t\t\t// ...\n\t\t}\n\t}\n}\n```\nFor such cases you should also defer to using `goleak.VerifyTestMain` as shown above.\n\n## Determine Source of Package Leaks\n\nWhen verifying leaks using `TestMain`, the leak test is only run once after all tests\nhave been run. This is typically enough to ensure there's no goroutines leaked from\ntests, but when there are leaks, it's hard to determine which test is causing them.\n\nYou can use the following bash script to determine the source of the failing test:\n\n```sh\n# Create a test binary which will be used to run each test individually\n$ go test -c -o tests\n\n# Run each test individually, printing \".\" for successful tests, or the test name\n# for failing tests.\n$ for test in $(go test -list . | grep -E \"^(Test|Example)\"); do ./tests -test.run \"^$test\\$\" &>/dev/null && echo -n \".\" || echo -e \"\\n$test failed\"; done\n```\n\nThis will only print names of failing tests which can be investigated individually. E.g.,\n\n```\n.....\nTestLeakyTest failed\n.......\n```\n\n## Stability\n\ngoleak is v1 and follows [SemVer](http://semver.org/) strictly.\n\nNo breaking changes will be made to exported APIs before 2.0.\n\n[doc-img]: https://pkg.go.dev/badge/go.uber.org/goleak.svg\n[doc]: https://pkg.go.dev/go.uber.org/goleak\n[ci-img]: https://github.com/uber-go/goleak/actions/workflows/ci.yml/badge.svg\n[ci]: https://github.com/uber-go/goleak/actions/workflows/ci.yml\n[cov-img]: https://codecov.io/gh/uber-go/goleak/branch/master/graph/badge.svg\n[cov]: https://codecov.io/gh/uber-go/goleak\n[release]: https://go.dev/doc/devel/release#policy\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.185546875,
          "content": "// Copyright (c) 2018 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package goleak is a Goroutine leak detector.\npackage goleak // import \"go.uber.org/goleak\"\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3251953125,
          "content": "module go.uber.org/goleak\n\ngo 1.20\n\nrequire github.com/stretchr/testify v1.8.0\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/kr/pretty v0.1.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.7998046875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0 h1:pSgiaMZlXftHpm5L7V1+rVB+AZJydKsMxsQBIJw4PKk=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "leaks.go",
          "type": "blob",
          "size": 3.3349609375,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"go.uber.org/goleak/internal/stack\"\n)\n\n// TestingT is the minimal subset of testing.TB that we use.\ntype TestingT interface {\n\tError(...interface{})\n}\n\n// filterStacks will filter any stacks excluded by the given opts.\n// filterStacks modifies the passed in stacks slice.\nfunc filterStacks(stacks []stack.Stack, skipID int, opts *opts) []stack.Stack {\n\tfiltered := stacks[:0]\n\tfor _, stack := range stacks {\n\t\t// Always skip the running goroutine.\n\t\tif stack.ID() == skipID {\n\t\t\tcontinue\n\t\t}\n\t\t// Run any default or user-specified filters.\n\t\tif opts.filter(stack) {\n\t\t\tcontinue\n\t\t}\n\t\tfiltered = append(filtered, stack)\n\t}\n\treturn filtered\n}\n\n// Find looks for extra goroutines, and returns a descriptive error if\n// any are found.\nfunc Find(options ...Option) error {\n\tcur := stack.Current().ID()\n\n\topts := buildOpts(options...)\n\tif opts.cleanup != nil {\n\t\treturn errors.New(\"Cleanup can only be passed to VerifyNone or VerifyTestMain\")\n\t}\n\tif opts.runOnFailure {\n\t\treturn errors.New(\"RunOnFailure can only be passed to VerifyTestMain\")\n\t}\n\tvar stacks []stack.Stack\n\tretry := true\n\tfor i := 0; retry; i++ {\n\t\tstacks = filterStacks(stack.All(), cur, opts)\n\n\t\tif len(stacks) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tretry = opts.retry(i)\n\t}\n\n\treturn fmt.Errorf(\"found unexpected goroutines:\\n%s\", stacks)\n}\n\ntype testHelper interface {\n\tHelper()\n}\n\n// VerifyNone marks the given TestingT as failed if any extra goroutines are\n// found by Find. This is a helper method to make it easier to integrate in\n// tests by doing:\n//\n//\tdefer VerifyNone(t)\n//\n// VerifyNone is currently incompatible with t.Parallel because it cannot\n// associate specific goroutines with specific tests. Thus, non-leaking\n// goroutines from other tests running in parallel could fail this check.\n// If you need to run tests in parallel, use [VerifyTestMain] instead,\n// which will verify that no leaking goroutines exist after ALL tests finish.\nfunc VerifyNone(t TestingT, options ...Option) {\n\topts := buildOpts(options...)\n\tvar cleanup func(int)\n\tcleanup, opts.cleanup = opts.cleanup, nil\n\n\tif h, ok := t.(testHelper); ok {\n\t\t// Mark this function as a test helper, if available.\n\t\th.Helper()\n\t}\n\n\tif err := Find(opts); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif cleanup != nil {\n\t\tcleanup(0)\n\t}\n}\n"
        },
        {
          "name": "leaks_test.go",
          "type": "blob",
          "size": 5.1279296875,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// Ensure that testingT is a subset of testing.TB.\nvar _ = TestingT(testing.TB(nil))\n\n// testOptions passes a shorter max sleep time, used so tests don't wait\n// ~1 second in cases where we expect Find to error out.\nfunc testOptions() Option {\n\treturn maxSleep(time.Millisecond)\n}\n\nfunc TestFind(t *testing.T) {\n\tt.Run(\"Should find no leaks by default\", func(t *testing.T) {\n\t\trequire.NoError(t, Find())\n\t})\n\n\tt.Run(\"Find leaks with leaked goroutine\", func(t *testing.T) {\n\t\tbg := startBlockedG()\n\t\terr := Find(testOptions())\n\t\trequire.Error(t, err, \"Should find leaks with leaked goroutine\")\n\t\tassert.ErrorContains(t, err, \"blockedG\")\n\t\tassert.ErrorContains(t, err, \"created by go.uber.org/goleak.startBlockedG\")\n\n\t\t// Once we unblock the goroutine, we shouldn't have leaks.\n\t\tbg.unblock()\n\t\trequire.NoError(t, Find(), \"Should find no leaks by default\")\n\t})\n\n\tt.Run(\"Find can't take in Cleanup option\", func(t *testing.T) {\n\t\terr := Find(Cleanup(func(int) { assert.Fail(t, \"this should not be called\") }))\n\t\trequire.Error(t, err, \"Should exit with invalid option\")\n\t})\n}\n\nfunc TestFindRetry(t *testing.T) {\n\t// for i := 0; i < 10; i++ {\n\tbg := startBlockedG()\n\trequire.Error(t, Find(testOptions()), \"Should find leaks with leaked goroutine\")\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond)\n\t\tbg.unblock()\n\t}()\n\trequire.NoError(t, Find(), \"Find should retry while background goroutine ends\")\n}\n\ntype fakeT struct {\n\terrors []string\n}\n\nfunc (ft *fakeT) Error(args ...interface{}) {\n\tft.errors = append(ft.errors, fmt.Sprint(args...))\n}\n\nfunc TestVerifyNone(t *testing.T) {\n\tt.Run(\"VerifyNone finds leaks\", func(t *testing.T) {\n\t\tft := &fakeT{}\n\t\tVerifyNone(ft)\n\t\trequire.Empty(t, ft.errors, \"Expect no errors from VerifyNone\")\n\n\t\tbg := startBlockedG()\n\t\tVerifyNone(ft, testOptions())\n\t\trequire.NotEmpty(t, ft.errors, \"Expect errors from VerifyNone on leaked goroutine\")\n\t\tbg.unblock()\n\t})\n\n\tt.Run(\"cleanup registered callback should be called\", func(t *testing.T) {\n\t\tft := &fakeT{}\n\t\tcleanupCalled := false\n\t\tVerifyNone(ft, Cleanup(func(c int) {\n\t\t\tassert.Equal(t, 0, c)\n\t\t\tcleanupCalled = true\n\t\t}))\n\t\trequire.True(t, cleanupCalled, \"expect cleanup registered callback to be called\")\n\t})\n}\n\nfunc TestIgnoreCurrent(t *testing.T) {\n\tt.Run(\"Should ignore current\", func(t *testing.T) {\n\t\tdefer VerifyNone(t)\n\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\t<-done\n\t\t}()\n\n\t\t// We expect the above goroutine to be ignored.\n\t\tVerifyNone(t, IgnoreCurrent())\n\t\tclose(done)\n\t})\n\n\tt.Run(\"Should detect new leaks\", func(t *testing.T) {\n\t\tdefer VerifyNone(t)\n\n\t\t// There are no leaks currently.\n\t\tVerifyNone(t)\n\n\t\tdone1 := make(chan struct{})\n\t\tdone2 := make(chan struct{})\n\n\t\tgo func() {\n\t\t\t<-done1\n\t\t}()\n\n\t\terr := Find()\n\t\trequire.Error(t, err, \"Expected to find background goroutine as leak\")\n\n\t\topt := IgnoreCurrent()\n\t\tVerifyNone(t, opt)\n\n\t\t// A second goroutine started after IgnoreCurrent is a leak\n\t\tgo func() {\n\t\t\t<-done2\n\t\t}()\n\n\t\terr = Find(opt)\n\t\trequire.Error(t, err, \"Expect second goroutine to be flagged as a leak\")\n\n\t\tclose(done1)\n\t\tclose(done2)\n\t})\n\n\tt.Run(\"Should not ignore false positive\", func(t *testing.T) {\n\t\tdefer VerifyNone(t)\n\n\t\tconst goroutinesCount = 5\n\t\tvar wg sync.WaitGroup\n\t\tdone := make(chan struct{})\n\n\t\t// Spawn few goroutines before checking leaks\n\t\tfor i := 0; i < goroutinesCount; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\t<-done\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t}\n\n\t\t// Store all goroutines\n\t\toption := IgnoreCurrent()\n\n\t\t// Free goroutines\n\t\tclose(done)\n\t\twg.Wait()\n\n\t\t// We expect the below goroutines to be founded.\n\t\tfor i := 0; i < goroutinesCount; i++ {\n\t\t\tch := make(chan struct{})\n\n\t\t\tgo func() {\n\t\t\t\t<-ch\n\t\t\t}()\n\n\t\t\trequire.Error(t, Find(option), \"Expect spawned goroutine to be flagged as a leak\")\n\n\t\t\t// Free spawned goroutine\n\t\t\tclose(ch)\n\n\t\t\t// Make sure that there are no leaks\n\t\t\tVerifyNone(t)\n\t\t}\n\t})\n}\n\nfunc TestVerifyParallel(t *testing.T) {\n\tt.Run(\"parallel\", func(t *testing.T) {\n\t\tt.Parallel()\n\t})\n\n\tt.Run(\"serial\", func(t *testing.T) {\n\t\tVerifyNone(t)\n\t})\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 6.38671875,
          "content": "// Copyright (c) 2017-2023 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"go.uber.org/goleak/internal/stack\"\n)\n\n// Option lets users specify custom verifications.\ntype Option interface {\n\tapply(*opts)\n}\n\n// We retry up to 20 times if we can't find the goroutine that\n// we are looking for. In between each attempt, we will sleep for\n// a short while to let any running goroutines complete.\nconst _defaultRetries = 20\n\ntype opts struct {\n\tfilters      []func(stack.Stack) bool\n\tmaxRetries   int\n\tmaxSleep     time.Duration\n\tcleanup      func(int)\n\trunOnFailure bool\n}\n\n// implement apply so that opts struct itself can be used as\n// an Option.\nfunc (o *opts) apply(opts *opts) {\n\topts.filters = o.filters\n\topts.maxRetries = o.maxRetries\n\topts.maxSleep = o.maxSleep\n\topts.cleanup = o.cleanup\n\topts.runOnFailure = o.runOnFailure\n}\n\n// optionFunc lets us easily write options without a custom type.\ntype optionFunc func(*opts)\n\nfunc (f optionFunc) apply(opts *opts) { f(opts) }\n\n// IgnoreTopFunction ignores any goroutines where the specified function\n// is at the top of the stack. The function name should be fully qualified,\n// e.g., go.uber.org/goleak.IgnoreTopFunction\nfunc IgnoreTopFunction(f string) Option {\n\treturn addFilter(func(s stack.Stack) bool {\n\t\treturn s.FirstFunction() == f\n\t})\n}\n\n// IgnoreAnyFunction ignores goroutines where the specified function\n// is present anywhere in the stack.\n//\n// The function name must be fully qualified, e.g.,\n//\n//\tgo.uber.org/goleak.IgnoreAnyFunction\n//\n// For methods, the fully qualified form looks like:\n//\n//\tgo.uber.org/goleak.(*MyType).MyMethod\nfunc IgnoreAnyFunction(f string) Option {\n\treturn addFilter(func(s stack.Stack) bool {\n\t\treturn s.HasFunction(f)\n\t})\n}\n\n// Cleanup sets up a cleanup function that will be executed at the\n// end of the leak check.\n// When passed to [VerifyTestMain], the exit code passed to cleanupFunc\n// will be set to the exit code of TestMain.\n// When passed to [VerifyNone], the exit code will be set to 0.\n// This cannot be passed to [Find].\nfunc Cleanup(cleanupFunc func(exitCode int)) Option {\n\treturn optionFunc(func(opts *opts) {\n\t\topts.cleanup = cleanupFunc\n\t})\n}\n\n// IgnoreCurrent records all current goroutines when the option is created, and ignores\n// them in any future Find/Verify calls.\nfunc IgnoreCurrent() Option {\n\texcludeIDSet := map[int]bool{}\n\tfor _, s := range stack.All() {\n\t\texcludeIDSet[s.ID()] = true\n\t}\n\treturn addFilter(func(s stack.Stack) bool {\n\t\treturn excludeIDSet[s.ID()]\n\t})\n}\n\n// RunOnFailure makes goleak look for leaking goroutines upon test failures.\n// By default goleak only looks for leaking goroutines when tests succeed.\nfunc RunOnFailure() Option {\n\treturn optionFunc(func(opts *opts) {\n\t\topts.runOnFailure = true\n\t})\n}\n\nfunc maxSleep(d time.Duration) Option {\n\treturn optionFunc(func(opts *opts) {\n\t\topts.maxSleep = d\n\t})\n}\n\nfunc addFilter(f func(stack.Stack) bool) Option {\n\treturn optionFunc(func(opts *opts) {\n\t\topts.filters = append(opts.filters, f)\n\t})\n}\n\nfunc buildOpts(options ...Option) *opts {\n\topts := &opts{\n\t\tmaxRetries: _defaultRetries,\n\t\tmaxSleep:   100 * time.Millisecond,\n\t}\n\topts.filters = append(opts.filters,\n\t\tisTestStack,\n\t\tisSyscallStack,\n\t\tisStdLibStack,\n\t\tisTraceStack,\n\t)\n\tfor _, option := range options {\n\t\toption.apply(opts)\n\t}\n\treturn opts\n}\n\nfunc (o *opts) filter(s stack.Stack) bool {\n\tfor _, filter := range o.filters {\n\t\tif filter(s) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (o *opts) retry(i int) bool {\n\tif i >= o.maxRetries {\n\t\treturn false\n\t}\n\n\td := time.Duration(int(time.Microsecond) << uint(i))\n\tif d > o.maxSleep {\n\t\td = o.maxSleep\n\t}\n\ttime.Sleep(d)\n\treturn true\n}\n\n// isTestStack is a default filter installed to automatically skip goroutines\n// that the testing package runs while the user's tests are running.\nfunc isTestStack(s stack.Stack) bool {\n\t// Until go1.7, the main goroutine ran RunTests, which started\n\t// the test in a separate goroutine and waited for that test goroutine\n\t// to end by waiting on a channel.\n\t// Since go1.7, a separate goroutine is started to wait for signals.\n\t// T.Parallel is for parallel tests, which are blocked until all serial\n\t// tests have run with T.Parallel at the top of the stack.\n\t// testing.runFuzzTests is for fuzz testing, it's blocked until the test\n\t// function with all seed corpus have run.\n\t// testing.runFuzzing is for fuzz testing, it's blocked until a failing\n\t// input is found.\n\tswitch s.FirstFunction() {\n\tcase \"testing.RunTests\", \"testing.(*T).Run\", \"testing.(*T).Parallel\", \"testing.runFuzzing\", \"testing.runFuzzTests\":\n\t\t// In pre1.7 and post-1.7, background goroutines started by the testing\n\t\t// package are blocked waiting on a channel.\n\t\treturn strings.HasPrefix(s.State(), \"chan receive\")\n\t}\n\treturn false\n}\n\nfunc isSyscallStack(s stack.Stack) bool {\n\t// Typically runs in the background when code uses CGo:\n\t// https://github.com/golang/go/issues/16714\n\treturn s.HasFunction(\"runtime.goexit\") && strings.HasPrefix(s.State(), \"syscall\")\n}\n\nfunc isStdLibStack(s stack.Stack) bool {\n\t// Importing os/signal starts a background goroutine.\n\t// The name of the function at the top has changed between versions.\n\tif f := s.FirstFunction(); f == \"os/signal.signal_recv\" || f == \"os/signal.loop\" {\n\t\treturn true\n\t}\n\n\t// Using signal.Notify will start a runtime goroutine.\n\treturn s.HasFunction(\"runtime.ensureSigM\")\n}\n\nfunc isTraceStack(s stack.Stack) bool {\n\treturn s.HasFunction(\"runtime.ReadTrace\")\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 3.3720703125,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/goleak/internal/stack\"\n)\n\nfunc TestOptionsFilters(t *testing.T) {\n\topts := buildOpts()\n\tcur := stack.Current()\n\tall := getStableAll(t, cur)\n\n\t// At least one of these should be the same as current, the others should be filtered out.\n\tfor _, s := range all {\n\t\tif s.ID() == cur.ID() {\n\t\t\trequire.False(t, opts.filter(s), \"Current test running function should not be filtered\")\n\t\t} else {\n\t\t\trequire.True(t, opts.filter(s), \"Default goroutines should be filtered: %v\", s)\n\t\t}\n\t}\n\n\tdefer startBlockedG().unblock()\n\n\t// Now the filters should find something that doesn't match a filter.\n\tcountUnfiltered := func() int {\n\t\tvar unmatched int\n\t\tfor _, s := range stack.All() {\n\t\t\tif s.ID() == cur.ID() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !opts.filter(s) {\n\t\t\t\tunmatched++\n\t\t\t}\n\t\t}\n\t\treturn unmatched\n\t}\n\trequire.Equal(t, 1, countUnfiltered(), \"Expected blockedG goroutine to not match any filter\")\n\n\t// If we add an extra filter to ignore blockTill, it shouldn't match.\n\topts = buildOpts(IgnoreTopFunction(\"go.uber.org/goleak.(*blockedG).block\"))\n\trequire.Zero(t, countUnfiltered(), \"blockedG should be filtered out. running: %v\", stack.All())\n\n\t// If we ignore startBlockedG, that should not ignore the blockedG goroutine\n\t// because startBlockedG should be the \"created by\" function in the stack.\n\topts = buildOpts(IgnoreAnyFunction(\"go.uber.org/goleak.startBlockedG\"))\n\trequire.Equal(t, 1, countUnfiltered(),\n\t\t\"startBlockedG should not be filtered out. running: %v\", stack.All())\n}\n\nfunc TestOptionsIgnoreAnyFunction(t *testing.T) {\n\tcur := stack.Current()\n\topts := buildOpts(IgnoreAnyFunction(\"go.uber.org/goleak.(*blockedG).run\"))\n\n\tfor _, s := range stack.All() {\n\t\tif s.ID() == cur.ID() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif opts.filter(s) {\n\t\t\tcontinue\n\t\t}\n\n\t\tt.Errorf(\"Unexpected goroutine: %v\", s)\n\t}\n}\n\nfunc TestOptionsRetry(t *testing.T) {\n\topts := buildOpts()\n\topts.maxRetries = 50 // initial attempt + 50 retries = 11\n\topts.maxSleep = time.Millisecond\n\n\tfor i := 0; i < 50; i++ {\n\t\tassert.True(t, opts.retry(i), \"Attempt %v/51 should allow retrying\", i)\n\t}\n\tassert.False(t, opts.retry(51), \"Attempt 51/51 should not allow retrying\")\n\tassert.False(t, opts.retry(52), \"Attempt 52/51 should not allow retrying\")\n}\n"
        },
        {
          "name": "signal_test.go",
          "type": "blob",
          "size": 1.76953125,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak_test\n\n// Importing the os/signal package causes a goroutine to be started.\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestNoLeaks(t *testing.T) {\n\t// Just importing the package can cause leaks.\n\trequire.NoError(t, goleak.Find(), \"Found leaks caused by signal import\")\n\n\t// Register some signal handlers and ensure there's no leaks.\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt)\n\trequire.NoError(t, goleak.Find(), \"Found leaks caused by signal.Notify\")\n\n\t// Restore all registered signals.\n\tsignal.Reset(os.Interrupt)\n\trequire.NoError(t, goleak.Find(), \"Found leaks caused after signal.Reset\")\n}\n"
        },
        {
          "name": "testmain.go",
          "type": "blob",
          "size": 2.5009765625,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// Variables for stubbing in unit tests.\nvar (\n\t_osExit             = os.Exit\n\t_osStderr io.Writer = os.Stderr\n)\n\n// TestingM is the minimal subset of testing.M that we use.\ntype TestingM interface {\n\tRun() int\n}\n\n// VerifyTestMain can be used in a TestMain function for package tests to\n// verify that there were no goroutine leaks.\n// To use it, your TestMain function should look like:\n//\n//\tfunc TestMain(m *testing.M) {\n//\t  goleak.VerifyTestMain(m)\n//\t}\n//\n// See https://pkg.go.dev/testing#hdr-Main for more details.\n//\n// This will run all tests as per normal, and if they were successful, look\n// for any goroutine leaks and fail the tests if any leaks were found.\nfunc VerifyTestMain(m TestingM, options ...Option) {\n\texitCode := m.Run()\n\topts := buildOpts(options...)\n\n\tvar cleanup func(int)\n\tcleanup, opts.cleanup = opts.cleanup, nil\n\tif cleanup == nil {\n\t\tcleanup = _osExit\n\t}\n\tdefer func() { cleanup(exitCode) }()\n\n\tvar (\n\t\trun      bool\n\t\terrorMsg string\n\t)\n\n\tif !opts.runOnFailure && exitCode == 0 {\n\t\terrorMsg = \"goleak: Errors on successful test run:%v\\n\"\n\t\trun = true\n\t} else if opts.runOnFailure {\n\t\terrorMsg = \"goleak: Errors on unsuccessful test run: %v\\n\"\n\t\trun = true\n\t}\n\n\tif run {\n\t\tif err := Find(opts); err != nil {\n\t\t\tfmt.Fprintf(_osStderr, errorMsg, err)\n\t\t\t// rewrite exitCode if test passed and is set to 0.\n\t\t\tif exitCode == 0 {\n\t\t\t\texitCode = 1\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testmain_test.go",
          "type": "blob",
          "size": 2.8779296875,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tclearOSStubs()\n}\n\nfunc clearOSStubs() {\n\t// We don't want to use the real os.Exit or os.Stderr so nil them out.\n\t// Tests MUST set them explicitly if they rely on them.\n\t_osExit = nil\n\t_osStderr = nil\n}\n\ntype dummyTestMain int\n\nfunc (d dummyTestMain) Run() int {\n\treturn int(d)\n}\n\nfunc osStubs() (chan int, chan string) {\n\texitCode := make(chan int, 1)\n\tstderr := make(chan string, 1)\n\n\tbuf := &bytes.Buffer{}\n\t_osStderr = buf\n\t_osExit = func(code int) {\n\t\texitCode <- code\n\t\tstderr <- buf.String()\n\t\tbuf.Reset()\n\t}\n\treturn exitCode, stderr\n}\n\nfunc TestVerifyTestMain(t *testing.T) {\n\tdefer clearOSStubs()\n\texitCode, stderr := osStubs()\n\n\tblocked := startBlockedG()\n\tVerifyTestMain(dummyTestMain(7))\n\tassert.Equal(t, 7, <-exitCode, \"Exit code should not be modified\")\n\tassert.NotContains(t, <-stderr, \"goleak: Errors\", \"Ignore leaks on unsuccessful runs\")\n\n\tVerifyTestMain(dummyTestMain(7), RunOnFailure())\n\tassert.Equal(t, 7, <-exitCode, \"Exit code should not be modified\")\n\tassert.Contains(t, <-stderr, \"goleak: Errors\", \"Find leaks on unsuccessful runs with RunOnFailure specified\")\n\n\tVerifyTestMain(dummyTestMain(0))\n\tassert.Equal(t, 1, <-exitCode, \"Expect error due to leaks on successful runs\")\n\tassert.Contains(t, <-stderr, \"goleak: Errors\", \"Find leaks on successful runs\")\n\n\tblocked.unblock()\n\tVerifyTestMain(dummyTestMain(0))\n\tassert.Equal(t, 0, <-exitCode, \"Expect no errors without leaks\")\n\tassert.NotContains(t, <-stderr, \"goleak: Errors\", \"No errors on successful run without leaks\")\n\n\tcleanupCalled := false\n\tcleanupExitcode := 0\n\tVerifyTestMain(dummyTestMain(3), Cleanup(func(ec int) {\n\t\tcleanupCalled = true\n\t\tcleanupExitcode = ec\n\t}))\n\tassert.True(t, cleanupCalled)\n\tassert.Equal(t, 3, cleanupExitcode)\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 2.3798828125,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage goleak\n\nimport (\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"go.uber.org/goleak/internal/stack\"\n)\n\ntype blockedG struct {\n\tstarted chan struct{}\n\twait    chan struct{}\n}\n\nfunc startBlockedG() *blockedG {\n\tbg := &blockedG{\n\t\tstarted: make(chan struct{}),\n\t\twait:    make(chan struct{}),\n\t}\n\tgo bg.run()\n\t<-bg.started\n\treturn bg\n}\n\nfunc (bg *blockedG) run() {\n\tclose(bg.started)\n\tbg.block()\n}\n\nfunc (bg *blockedG) block() {\n\t<-bg.wait\n}\n\nfunc (bg *blockedG) unblock() {\n\tclose(bg.wait)\n}\n\nfunc getStableAll(t *testing.T, cur stack.Stack) []stack.Stack {\n\tall := stack.All()\n\n\t// There may be running goroutines that were just scheduled or finishing up\n\t// from previous tests, so reduce flakiness by waiting till no other goroutines\n\t// are runnable or running except the current goroutine.\n\tfor retry := 0; true; retry++ {\n\t\tif !isBackgroundRunning(cur, all) {\n\t\t\tbreak\n\t\t}\n\n\t\tif retry >= 100 {\n\t\t\tt.Fatalf(\"background goroutines are possibly running, %v\", all)\n\t\t}\n\n\t\truntime.Gosched()\n\t\tall = stack.All()\n\t}\n\n\treturn all\n}\n\n// Note: This is the same logic as in internal/stacks/stacks_test.go\nfunc isBackgroundRunning(cur stack.Stack, stacks []stack.Stack) bool {\n\tfor _, s := range stacks {\n\t\tif cur.ID() == s.ID() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.Contains(s.State(), \"run\") {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        }
      ]
    }
  ]
}