{
  "metadata": {
    "timestamp": 1736566829825,
    "page": 398,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mvdan/gofumpt",
      "stars": 3411,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0791015625,
          "content": "# To prevent CRLF breakages on Windows for fragile files, like testdata.\n* -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 7.607421875,
          "content": "# Changelog\n\n## [v0.7.0] - 2024-08-16\n\nThis release is based on Go 1.23.0's gofmt, and requires Go 1.22 or later.\n\nThe following changes are included:\n\n* Group `internal/...` imported packages as standard library - #307\n\n## [v0.6.0] - 2024-01-28\n\nThis release is based on Go 1.21's gofmt, and requires Go 1.20 or later.\n\nThe following changes are included:\n\n* Support `go` version strings from newer go.mod files - [#280]\n* Consider simple error checks even if they use the `=` operator - [#271]\n* Ignore `//line` directives to avoid panics - [#288]\n\n## [v0.5.0] - 2023-04-09\n\nThis release is based on Go 1.20's gofmt, and requires Go 1.19 or later.\n\nThe biggest change in this release is that we now vendor copies of the packages\n`go/format`, `go/printer`, and `go/doc/comment` on top of `cmd/gofmt` itself.\nThis allows for each gofumpt release to format code in exactly the same way\nno matter what Go version is used to build it, as Go versions can change those\nthree packages in ways that alter formatting behavior.\n\nThis vendoring adds a small amount of duplication when using the\n`mvdan.cc/gofumpt/format` library, but it's the only way to make gofumpt\nversions consistent in their behavior and formatting, just like gofmt.\n\nThe jump to Go 1.20's `go/printer` should also bring a small performance\nimprovement, as we contributed patches to make printing about 25% faster:\n\n* https://go.dev/cl/412555\n* https://go.dev/cl/412557\n* https://go.dev/cl/424924\n\nThe following changes are included as well:\n\n* Skip `testdata` dirs by default like we already do for `vendor` - [#260]\n* Avoid inserting newlines incorrectly in some func signatures - [#235]\n* Avoid joining some comments with the previous line - [#256]\n* Fix `gofumpt -version` for release archives - [#253]\n\n## [v0.4.0] - 2022-09-27\n\nThis release is based on Go 1.19's gofmt, and requires Go 1.18 or later.\nWe recommend building gofumpt with Go 1.19 for the best formatting results.\n\nThe jump from Go 1.18 brings diffing in pure Go, removing the need to exec `diff`,\nand a small parsing speed-up thanks to `go/parser.SkipObjectResolution`.\n\nThe following formatting fixes are included as well:\n\n* Allow grouping declarations with comments - [#212]\n* Properly measure the length of case clauses - [#217]\n* Fix a few crashes found by Go's native fuzzing\n\n## [v0.3.1] - 2022-03-21\n\nThis bugfix release resolves a number of issues:\n\n* Avoid \"too many open files\" error regression introduced by [v0.3.0] - [#208]\n* Use the `go.mod` relative to each Go file when deriving flag defaults - [#211]\n* Remove unintentional debug prints when directly formatting files\n\n## [v0.3.0] - 2022-02-22\n\nThis is gofumpt's third major release, based on Go 1.18's gofmt.\nThe jump from Go 1.17's gofmt should bring a noticeable speed-up,\nas the tool can now format many files concurrently.\nOn an 8-core laptop, formatting a large codebase is 4x as fast.\n\nThe following [formatting rules](https://github.com/mvdan/gofumpt#Added-rules) are added:\n\n* Functions should separate `) {` where the indentation helps readability\n* Field lists should not have leading or trailing empty lines\n\nThe following changes are included as well:\n\n* Generated files are now fully formatted when given as explicit arguments\n* Prepare for Go 1.18's module workspaces, which could cause errors\n* Import paths sharing a prefix with the current module path are no longer\n  grouped with standard library imports\n* `format.Options` gains a `ModulePath` field per the last bullet point\n\n## [v0.2.1] - 2021-12-12\n\nThis bugfix release resolves a number of issues:\n\n* Add deprecated flags `-s` and `-r` once again, now giving useful errors\n* Avoid a panic with certain function declaration styles\n* Don't group interface members of different kinds\n* Account for leading comments in composite literals\n\n## [v0.2.0] - 2021-11-10\n\nThis is gofumpt's second major release, based on Go 1.17's gofmt.\nThe jump from Go 1.15's gofmt should bring a mild speed-up,\nas walking directories with `filepath.WalkDir` uses fewer syscalls.\n\ngofumports is now removed, after being deprecated in [v0.1.0].\nIts main purpose was IDE integration; it is now recommended to use gopls,\nwhich in turn implements goimports and supports gofumpt natively.\nIDEs which don't integrate with gopls (such as GoLand) implement goimports too,\nso it is safe to use gofumpt as their \"format on save\" command.\nSee the [installation instructions](https://github.com/mvdan/gofumpt#Installation)\nfor more details.\n\nThe following [formatting rules](https://github.com/mvdan/gofumpt#Added-rules) are added:\n\n* Composite literals should not have leading or trailing empty lines\n* No empty lines following an assignment operator\n* Functions using an empty line for readability should use a `) {` line instead\n* Remove unnecessary empty lines from interfaces\n\nFinally, the following changes are made to the gofumpt tool:\n\n* Initial support for Go 1.18's type parameters is added\n* The `-r` flag is removed in favor of `gofmt -r`\n* The `-s` flag is removed as it is always enabled\n* Vendor directories are skipped unless given as explicit arguments\n* The added rules are not applied to generated Go files\n* The `format` Go API now also applies the `gofmt -s` simplification\n* Add support for `//gofumpt:diagnose` comments\n\n## [v0.1.1] - 2021-03-11\n\nThis bugfix release backports fixes for a few issues:\n\n* Keep leading empty lines in func bodies if they help readability\n* Avoid breaking comment alignment on empty field lists\n* Add support for `//go-sumtype:` directives\n\n## [v0.1.0] - 2021-01-05\n\nThis is gofumpt's first release, based on Go 1.15.x. It solidifies the features\nwhich have worked well for over a year.\n\nThis release will be the last to include `gofumports`, the fork of `goimports`\nwhich applies `gofumpt`'s rules on top of updating the Go import lines. Users\nwho were relying on `goimports` in their editors or IDEs to apply both `gofumpt`\nand `goimports` in a single step should switch to gopls, the official Go\nlanguage server. It is supported by many popular editors such as VS Code and\nVim, and already bundles gofumpt support. Instructions are available [in the\nREADME](https://github.com/mvdan/gofumpt).\n\n`gofumports` also added maintenance work and potential confusion to end users.\nIn the future, there will only be one way to use `gofumpt` from the command\nline. We also have a [Go API](https://pkg.go.dev/mvdan.cc/gofumpt/format) for\nthose building programs with gofumpt.\n\nFinally, this release adds the `-version` flag, to print the tool's own version.\nThe flag will work for \"master\" builds too.\n\n[v0.7.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.7.0\n\n[v0.6.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.6.0\n[#271]: https://github.com/mvdan/gofumpt/issues/271\n[#280]: https://github.com/mvdan/gofumpt/issues/280\n[#288]: https://github.com/mvdan/gofumpt/issues/288\n\n[v0.5.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.5.0\n[#235]: https://github.com/mvdan/gofumpt/issues/235\n[#253]: https://github.com/mvdan/gofumpt/issues/253\n[#256]: https://github.com/mvdan/gofumpt/issues/256\n[#260]: https://github.com/mvdan/gofumpt/issues/260\n\n[v0.4.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.4.0\n[#212]: https://github.com/mvdan/gofumpt/issues/212\n[#217]: https://github.com/mvdan/gofumpt/issues/217\n\n[v0.3.1]: https://github.com/mvdan/gofumpt/releases/tag/v0.3.1\n[#208]: https://github.com/mvdan/gofumpt/issues/208\n[#211]: https://github.com/mvdan/gofumpt/pull/211\n\n[v0.3.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.3.0\n[v0.2.1]: https://github.com/mvdan/gofumpt/releases/tag/v0.2.1\n[v0.2.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.2.0\n[v0.1.1]: https://github.com/mvdan/gofumpt/releases/tag/v0.1.1\n[v0.1.0]: https://github.com/mvdan/gofumpt/releases/tag/v0.1.0\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.453125,
          "content": "Copyright (c) 2019, Daniel Martí. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of the copyright holder nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "LICENSE.google",
          "type": "blob",
          "size": 1.4443359375,
          "content": "Copyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.0712890625,
          "content": "# gofumpt\n\n[![Go Reference](https://pkg.go.dev/badge/mvdan.cc/gofumpt/format.svg)](https://pkg.go.dev/mvdan.cc/gofumpt/format)\n\n\tgo install mvdan.cc/gofumpt@latest\n\nEnforce a stricter format than `gofmt`, while being backwards compatible.\nThat is, `gofumpt` is happy with a subset of the formats that `gofmt` is happy with.\n\nThe tool is a fork of `gofmt` as of Go 1.23.0, and requires Go 1.22 or later.\nIt can be used as a drop-in replacement to format your Go code,\nand running `gofmt` after `gofumpt` should produce no changes.\nFor example:\n\n\tgofumpt -l -w .\n\nSome of the Go source files in this repository belong to the Go project.\nThe project includes copies of `go/printer` and `go/doc/comment` as of Go 1.23.0\nto ensure consistent formatting independent of what Go version is being used.\nThe [added formatting rules](#Added-rules) are implemented in the `format` package.\n\n`vendor` and `testdata` directories are skipped unless given as explicit arguments.\nSimilarly, the added rules do not apply to generated Go files unless they are\ngiven as explicit arguments.\n\nFinally, note that the `-r` rewrite flag is removed in favor of `gofmt -r`,\nand the `-s` flag is hidden as it is always enabled.\n\n### Added rules\n\n**No empty lines following an assignment operator**\n\n<details><summary><i>Example</i></summary>\n\n```go\nfunc foo() {\n    foo :=\n        \"bar\"\n}\n```\n\n```go\nfunc foo() {\n\tfoo := \"bar\"\n}\n```\n\n</details>\n\n**No empty lines around function bodies**\n\n<details><summary><i>Example</i></summary>\n\n```go\nfunc foo() {\n\n\tprintln(\"bar\")\n\n}\n```\n\n```go\nfunc foo() {\n\tprintln(\"bar\")\n}\n```\n\n</details>\n\n**Functions should separate `) {` where the indentation helps readability**\n\n<details><summary><i>Example</i></summary>\n\n```go\nfunc foo(s string,\n\ti int) {\n\tprintln(\"bar\")\n}\n\n// With an empty line it's slightly better, but still not great.\nfunc bar(s string,\n\ti int) {\n\n\tprintln(\"bar\")\n}\n```\n\n```go\nfunc foo(s string,\n\ti int,\n) {\n\tprintln(\"bar\")\n}\n\n// With an empty line it's slightly better, but still not great.\nfunc bar(s string,\n\ti int,\n) {\n\tprintln(\"bar\")\n}\n```\n\n</details>\n\n**No empty lines around a lone statement (or comment) in a block**\n\n<details><summary><i>Example</i></summary>\n\n```go\nif err != nil {\n\n\treturn err\n}\n```\n\n```go\nif err != nil {\n\treturn err\n}\n```\n\n</details>\n\n**No empty lines before a simple error check**\n\n<details><summary><i>Example</i></summary>\n\n```go\nfoo, err := processFoo()\n\nif err != nil {\n\treturn err\n}\n```\n\n```go\nfoo, err := processFoo()\nif err != nil {\n\treturn err\n}\n```\n\n</details>\n\n**Composite literals should use newlines consistently**\n\n<details><summary><i>Example</i></summary>\n\n```go\n// A newline before or after an element requires newlines for the opening and\n// closing braces.\nvar ints = []int{1, 2,\n\t3, 4}\n\n// A newline between consecutive elements requires a newline between all\n// elements.\nvar matrix = [][]int{\n\t{1},\n\t{2}, {\n\t\t3,\n\t},\n}\n```\n\n```go\nvar ints = []int{\n\t1, 2,\n\t3, 4,\n}\n\nvar matrix = [][]int{\n\t{1},\n\t{2},\n\t{\n\t\t3,\n\t},\n}\n```\n\n</details>\n\n**Empty field lists should use a single line**\n\n<details><summary><i>Example</i></summary>\n\n```go\nvar V interface {\n} = 3\n\ntype T struct {\n}\n\nfunc F(\n)\n```\n\n```go\nvar V interface{} = 3\n\ntype T struct{}\n\nfunc F()\n```\n\n</details>\n\n**`std` imports must be in a separate group at the top**\n\n<details><summary><i>Example</i></summary>\n\n```go\nimport (\n\t\"foo.com/bar\"\n\n\t\"io\"\n\n\t\"io/ioutil\"\n)\n```\n\n```go\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"foo.com/bar\"\n)\n```\n\n</details>\n\n**Short case clauses should take a single line**\n\n<details><summary><i>Example</i></summary>\n\n```go\nswitch c {\ncase 'a', 'b',\n\t'c', 'd':\n}\n```\n\n```go\nswitch c {\ncase 'a', 'b', 'c', 'd':\n}\n```\n\n</details>\n\n**Multiline top-level declarations must be separated by empty lines**\n\n<details><summary><i>Example</i></summary>\n\n```go\nfunc foo() {\n\tprintln(\"multiline foo\")\n}\nfunc bar() {\n\tprintln(\"multiline bar\")\n}\n```\n\n```go\nfunc foo() {\n\tprintln(\"multiline foo\")\n}\n\nfunc bar() {\n\tprintln(\"multiline bar\")\n}\n```\n\n</details>\n\n**Single var declarations should not be grouped with parentheses**\n\n<details><summary><i>Example</i></summary>\n\n```go\nvar (\n\tfoo = \"bar\"\n)\n```\n\n```go\nvar foo = \"bar\"\n```\n\n</details>\n\n**Contiguous top-level declarations should be grouped together**\n\n<details><summary><i>Example</i></summary>\n\n```go\nvar nicer = \"x\"\nvar with = \"y\"\nvar alignment = \"z\"\n```\n\n```go\nvar (\n\tnicer     = \"x\"\n\twith      = \"y\"\n\talignment = \"z\"\n)\n```\n\n</details>\n\n**Simple var-declaration statements should use short assignments**\n\n<details><summary><i>Example</i></summary>\n\n```go\nvar s = \"somestring\"\n```\n\n```go\ns := \"somestring\"\n```\n\n</details>\n\n**The `-s` code simplification flag is enabled by default**\n\n<details><summary><i>Example</i></summary>\n\n```go\nvar _ = [][]int{[]int{1}}\n```\n\n```go\nvar _ = [][]int{{1}}\n```\n\n</details>\n\n**Octal integer literals should use the `0o` prefix on modules using Go 1.13 and later**\n\n<details><summary><i>Example</i></summary>\n\n```go\nconst perm = 0755\n```\n\n```go\nconst perm = 0o755\n```\n\n</details>\n\n**Comments which aren't Go directives should start with a whitespace**\n\n<details><summary><i>Example</i></summary>\n\n```go\n//go:noinline\n\n//Foo is awesome.\nfunc Foo() {}\n```\n\n```go\n//go:noinline\n\n// Foo is awesome.\nfunc Foo() {}\n```\n\n</details>\n\n**Composite literals should not have leading or trailing empty lines**\n\n<details><summary><i>Example</i></summary>\n\n```go\nvar _ = []string{\n\n\t\"foo\",\n\n}\n\nvar _ = map[string]string{\n\n\t\"foo\": \"bar\",\n\n}\n```\n\n```go\nvar _ = []string{\n\t\"foo\",\n}\n\nvar _ = map[string]string{\n\t\"foo\": \"bar\",\n}\n```\n\n</details>\n\n**Field lists should not have leading or trailing empty lines**\n\n<details><summary><i>Example</i></summary>\n\n```go\ntype Person interface {\n\n\tName() string\n\n\tAge() int\n\n}\n\ntype ZeroFields struct {\n\n\t// No fields are needed here.\n\n}\n```\n\n```go\ntype Person interface {\n\tName() string\n\n\tAge() int\n}\n\ntype ZeroFields struct {\n\t// No fields are needed here.\n}\n```\n\n</details>\n\n#### Extra rules behind `-extra`\n\n**Adjacent parameters with the same type should be grouped together**\n\n<details><summary><i>Example</i></summary>\n\n```go\nfunc Foo(bar string, baz string) {}\n```\n\n```go\nfunc Foo(bar, baz string) {}\n```\n\n</details>\n\n### Installation\n\n`gofumpt` is a replacement for `gofmt`, so you can simply `go install` it as\ndescribed at the top of this README and use it.\n\nWhen using an IDE or editor with Go integration based on `gopls`,\nit's best to configure the editor to use the `gofumpt` support built into `gopls`.\n\nThe instructions below show how to set up `gofumpt` for some of the\nmajor editors out there.\n\n#### Visual Studio Code\n\nEnable the language server following [the official docs](https://github.com/golang/vscode-go#readme),\nand then enable gopls's `gofumpt` option. Note that VS Code will complain about\nthe `gopls` settings, but they will still work.\n\n```json\n\"go.useLanguageServer\": true,\n\"gopls\": {\n\t\"formatting.gofumpt\": true,\n},\n```\n\n#### GoLand\n\nGoLand doesn't use `gopls` so it should be configured to use `gofumpt` directly.\nOnce `gofumpt` is installed, follow the steps below:\n\n- Open **Settings** (File > Settings)\n- Open the **Tools** section\n- Find the *File Watchers* sub-section\n- Click on the `+` on the right side to add a new file watcher\n- Choose *Custom Template*\n\nWhen a window asks for settings, you can enter the following:\n\n* File Types: Select all .go files\n* Scope: Project Files\n* Program: Select your `gofumpt` executable\n* Arguments: `-w $FilePath$`\n* Output path to refresh: `$FilePath$`\n* Working directory: `$ProjectFileDir$`\n* Environment variables: `GOROOT=$GOROOT$;GOPATH=$GOPATH$;PATH=$GoBinDirs$`\n\nTo avoid unnecessary runs, you should disable all checkboxes in the *Advanced* section.\n\n#### Vim\n\nThe configuration depends on the plugin you are using: [vim-go](https://github.com/fatih/vim-go)\nor [govim](https://github.com/govim/govim).\n\n##### vim-go\n\nTo configure `gopls` to use `gofumpt`:\n\n```vim\nlet g:go_fmt_command=\"gopls\"\nlet g:go_gopls_gofumpt=1\n```\n\n##### govim\n\nTo configure `gopls` to use `gofumpt`:\n\n```vim\ncall govim#config#Set(\"Gofumpt\", 1)\n```\n\n#### Neovim\n\nWhen using [`lspconfig`](https://github.com/neovim/nvim-lspconfig), pass the `gofumpt` setting to `gopls`:\n\n```lua\nrequire('lspconfig').gopls.setup({\n    settings = {\n        gopls = {\n            gofumpt = true\n        }\n    }\n})\n```\n\n#### Emacs\n\nFor [lsp-mode](https://emacs-lsp.github.io/lsp-mode/) users on version 8.0.0 or higher:\n\n```elisp\n(setq lsp-go-use-gofumpt t)\n```\n\nFor users of `lsp-mode` before `8.0.0`:\n\n```elisp\n(lsp-register-custom-settings\n '((\"gopls.gofumpt\" t)))\n```\n\nFor [eglot](https://github.com/joaotavora/eglot) users:\n\n```elisp\n(setq-default eglot-workspace-configuration\n '((:gopls . ((gofumpt . t)))))\n```\n\n#### Helix\n\nWhen using the `gopls` language server, modify the Go settings in `~/.config/helix/languages.toml`:\n\n```toml\n[language-server.gopls.config]\n\"formatting.gofumpt\" = true\n```\n\n#### Sublime Text\n\nWith ST4, install the Sublime Text LSP extension according to [the documentation](https://github.com/sublimelsp/LSP),\nand enable `gopls`'s `gofumpt` option in the LSP package settings,\nincluding setting `lsp_format_on_save` to `true`.\n\n```json\n\"lsp_format_on_save\": true,\n\"clients\":\n{\n\t\"gopls\":\n\t{\n\t\t\"enabled\": true,\n\t\t\"initializationOptions\": {\n\t\t\t\"gofumpt\": true,\n\t\t}\n\t}\n}\n```\n\n### Roadmap\n\nThis tool is a place to experiment. In the long term, the features that work\nwell might be proposed for `gofmt` itself.\n\nThe tool is also compatible with `gofmt` and is aimed to be stable, so you can\nrely on it for your code as long as you pin a version of it.\n\n### Frequently Asked Questions\n\n> Why attempt to replace `gofmt` instead of building on top of it?\n\nOur design is to build on top of `gofmt`, and we'll never add rules which\ndisagree with its formatting. So we extend `gofmt` rather than compete with it.\n\nThe tool is a modified copy of `gofmt`, for the purpose of allowing its use as a\ndrop-in replacement in editors and scripts.\n\n> Why are my module imports being grouped with standard library imports?\n\nAny import paths that don't start with a domain name like `foo.com` are\neffectively [reserved by the Go toolchain](https://github.com/golang/go/issues/32819).\nThird party modules should either start with a domain name,\neven a local one like `foo.local`, or use [a reserved path prefix](https://github.com/golang/go/issues/37641).\n\nFor backwards compatibility with modules set up before these rules were clear,\n`gofumpt` will treat any import path sharing a prefix with the current module\npath as third party. For example, if the current module is `mycorp/mod1`, then\nall import paths in `mycorp/...` will be considered third party.\n\n> How can I use `gofumpt` if I already use `goimports` to replace `gofmt`?\n\nMost editors have replaced the `goimports` program with the same functionality\nprovided by a language server like `gopls`. This mechanism is significantly\nfaster and more powerful, since the language server has more information that is\nkept up to date, necessary to add missing imports.\n\nAs such, the general recommendation is to let your editor fix your imports -\neither via `gopls`, such as VSCode or vim-go, or via their own custom\nimplementation, such as GoLand. Then follow the install instructions above to\nenable the use of `gofumpt` instead of `gofmt`.\n\nIf you want to avoid integrating with `gopls`, and are OK with the overhead of\ncalling `goimports` from scratch on each save, you should be able to call both\ntools; for example, `goimports file.go && gofumpt file.go`.\n\n### Contributing\n\nIssues and pull requests are welcome! Please open an issue to discuss a feature\nbefore sending a pull request.\n\nWe also use the `#gofumpt` channel over at the\n[Gophers Slack](https://invite.slack.golangbridge.org/) to chat.\n\nWhen reporting a formatting bug, insert a `//gofumpt:diagnose` comment.\nThe comment will be rewritten to include useful debugging information.\nFor instance:\n\n```\n$ cat f.go\npackage p\n\n//gofumpt:diagnose\n$ gofumpt f.go\npackage p\n\n//gofumpt:diagnose v0.1.1-0.20211103104632-bdfa3b02e50a -lang=go1.16\n```\n\n### License\n\nNote that much of the code is copied from Go's `gofmt` command. You can tell\nwhich files originate from the Go repository from their copyright headers. Their\nlicense file is `LICENSE.google`.\n\n`gofumpt`'s original source files are also under the 3-clause BSD license, with\nthe separate file `LICENSE`.\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1884765625,
          "content": "// Copyright (c) 2023, Daniel Martí <mvdan@mvdan.cc>\n// See LICENSE for licensing information\n\n// gofumpt enforces a stricter format than gofmt, while being backwards compatible.\npackage main\n"
        },
        {
          "name": "format",
          "type": "tree",
          "content": null
        },
        {
          "name": "gen_govendor.go",
          "type": "blob",
          "size": 1.890625,
          "content": "// Copyright (c) 2019, Daniel Martí <mvdan@mvdan.cc>\n// See LICENSE for licensing information\n\n//go:build ignore\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nvar (\n\tmodulePath = \"mvdan.cc/gofumpt\"\n\tvendorDir  = filepath.Join(\"internal\", \"govendor\")\n)\n\n// All the packages which affect the formatting behavior.\nvar toVendor = []string{\n\t\"go/format\",\n\t\"go/printer\",\n\t\"go/doc/comment\",\n\t\"internal/diff\",\n}\n\nfunc main() {\n\tcatch(os.RemoveAll(vendorDir))\n\n\tcatch(os.MkdirAll(vendorDir, 0o777))\n\tout, err := exec.Command(\"go\", \"env\", \"GOVERSION\").Output()\n\tcatch(err)\n\tcatch(os.WriteFile(filepath.Join(vendorDir, \"version.txt\"), out, 0o666))\n\n\toldnew := []string{\n\t\t\"//go:generate\", \"//disabled go:generate\",\n\t}\n\tfor _, pkgPath := range toVendor {\n\t\toldnew = append(oldnew, pkgPath, path.Join(modulePath, vendorDir, pkgPath))\n\t}\n\treplacer := strings.NewReplacer(oldnew...)\n\n\tlistArgs := append([]string{\"list\", \"-json\"}, toVendor...)\n\tout, err = exec.Command(\"go\", listArgs...).Output()\n\tcatch(err)\n\n\ttype Package struct {\n\t\tDir        string\n\t\tImportPath string\n\t\tGoFiles    []string\n\t}\n\tdec := json.NewDecoder(bytes.NewReader(out))\n\tfor {\n\t\tvar pkg Package\n\t\terr := dec.Decode(&pkg)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tcatch(err)\n\n\t\t// Otherwise we can't import it.\n\t\tdstPkg := strings.TrimPrefix(pkg.ImportPath, \"internal/\")\n\n\t\tdstDir := filepath.Join(vendorDir, filepath.FromSlash(dstPkg))\n\t\tcatch(os.MkdirAll(dstDir, 0o777))\n\t\t// TODO: if the packages start using build tags like GOOS or GOARCH,\n\t\t// we will need to vendor IgnoredGoFiles as well.\n\t\tfor _, goFile := range pkg.GoFiles {\n\t\t\tsrcBytes, err := os.ReadFile(filepath.Join(pkg.Dir, goFile))\n\t\t\tcatch(err)\n\n\t\t\tsrc := replacer.Replace(string(srcBytes))\n\n\t\t\tdst := filepath.Join(dstDir, goFile)\n\t\t\tcatch(os.WriteFile(dst, []byte(src), 0o666))\n\t\t}\n\t}\n}\n\nfunc catch(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.390625,
          "content": "module mvdan.cc/gofumpt\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/go-quicktest/qt v1.101.0\n\tgithub.com/rogpeppe/go-internal v1.13.2-0.20241226121412-a5dc8ff20d0a\n\tgolang.org/x/mod v0.21.0\n\tgolang.org/x/sync v0.8.0\n\tgolang.org/x/sys v0.26.0\n\tgolang.org/x/tools v0.26.0\n)\n\nrequire (\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.7607421875,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/go-quicktest/qt v1.101.0 h1:O1K29Txy5P2OK0dGo59b7b0LR6wKfIhttaAhHUyn7eI=\ngithub.com/go-quicktest/qt v1.101.0/go.mod h1:14Bz/f7NwaXPtdYEgzsx46kqSxVwTbzVZsDC26tQJow=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/rogpeppe/go-internal v1.13.2-0.20241226121412-a5dc8ff20d0a h1:w3tdWGKbLGBPtR/8/oO74W6hmz0qE5q0z9aqSAewaaM=\ngithub.com/rogpeppe/go-internal v1.13.2-0.20241226121412-a5dc8ff20d0a/go.mod h1:S8kfXMp+yh77OxPD4fdM6YUknrZpQxLhvxzS4gDHENY=\ngolang.org/x/mod v0.21.0 h1:vvrHzRwRfVKSiLrG+d4FMl/Qi4ukBCE6kZlTUkDYRT0=\ngolang.org/x/mod v0.21.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=\ngolang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=\ngolang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/tools v0.26.0 h1:v/60pFQmzmT9ExmjDv2gGIfi3OqfKoEP6I5+umXlbnQ=\ngolang.org/x/tools v0.26.0/go.mod h1:TPVVj70c7JJ3WCazhD8OdXcZg/og+b9+tH/KxylGwH0=\n"
        },
        {
          "name": "gofmt.go",
          "type": "blob",
          "size": 17.26171875,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/scanner\"\n\t\"go/token\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"golang.org/x/sync/semaphore\"\n\n\tgformat \"mvdan.cc/gofumpt/format\"\n\t\"mvdan.cc/gofumpt/internal/govendor/diff\"\n\t\"mvdan.cc/gofumpt/internal/govendor/go/printer\"\n\tgversion \"mvdan.cc/gofumpt/internal/version\"\n)\n\n//go:generate go run gen_govendor.go\n//go:generate go run . -w internal/govendor\n\nvar (\n\t// main operation modes\n\tlist      = flag.Bool(\"l\", false, \"\")\n\twrite     = flag.Bool(\"w\", false, \"\")\n\tdoDiff    = flag.Bool(\"d\", false, \"\")\n\tallErrors = flag.Bool(\"e\", false, \"\")\n\n\t// debugging\n\tcpuprofile = flag.String(\"cpuprofile\", \"\", \"\")\n\n\t// gofumpt's own flags\n\tlangVersion = flag.String(\"lang\", \"\", \"\")\n\tmodulePath  = flag.String(\"modpath\", \"\", \"\")\n\textraRules  = flag.Bool(\"extra\", false, \"\")\n\tshowVersion = flag.Bool(\"version\", false, \"\")\n\n\t// DEPRECATED\n\trewriteRule = flag.String(\"r\", \"\", \"\")\n\tsimplifyAST = flag.Bool(\"s\", false, \"\")\n)\n\nvar version = \"\"\n\n// Keep these in sync with go/format/format.go.\nconst (\n\ttabWidth    = 8\n\tprinterMode = printer.UseSpaces | printer.TabIndent | printerNormalizeNumbers\n\n\t// printerNormalizeNumbers means to canonicalize number literal prefixes\n\t// and exponents while printing. See https://golang.org/doc/go1.13#gofmt.\n\t//\n\t// This value is defined in go/printer specifically for go/format and cmd/gofmt.\n\tprinterNormalizeNumbers = 1 << 30\n)\n\n// fdSem guards the number of concurrently-open file descriptors.\n//\n// For now, this is arbitrarily set to 200, based on the observation that many\n// platforms default to a kernel limit of 256. Ideally, perhaps we should derive\n// it from rlimit on platforms that support that system call.\n//\n// File descriptors opened from outside of this package are not tracked,\n// so this limit may be approximate.\nvar fdSem = make(chan bool, 200)\n\nvar (\n\tfileSet    = token.NewFileSet() // per process FileSet\n\tparserMode parser.Mode\n)\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, `usage: gofumpt [flags] [path ...]\n\t-version  show version and exit\n\n\t-d        display diffs instead of rewriting files\n\t-e        report all errors (not just the first 10 on different lines)\n\t-l        list files whose formatting differs from gofumpt's\n\t-w        write result to (source) file instead of stdout\n\t-extra    enable extra rules which should be vetted by a human\n\n\t-lang       str    target Go version in the form \"go1.X\" (default from go.mod)\n\t-modpath    str    Go module path containing the source file (default from go.mod)\n`)\n}\n\nfunc initParserMode() {\n\tparserMode = parser.ParseComments | parser.SkipObjectResolution\n\tif *allErrors {\n\t\tparserMode |= parser.AllErrors\n\t}\n}\n\nfunc isGoFile(f fs.DirEntry) bool {\n\t// ignore non-Go files\n\tname := f.Name()\n\treturn !strings.HasPrefix(name, \".\") && strings.HasSuffix(name, \".go\") && !f.IsDir()\n}\n\nvar rxCodeGenerated = regexp.MustCompile(`^// Code generated .* DO NOT EDIT\\.$`)\n\nfunc isGenerated(file *ast.File) bool {\n\tfor _, cg := range file.Comments {\n\t\tif cg.Pos() > file.Package {\n\t\t\treturn false\n\t\t}\n\t\tfor _, line := range cg.List {\n\t\t\tif rxCodeGenerated.MatchString(line.Text) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// A sequencer performs concurrent tasks that may write output, but emits that\n// output in a deterministic order.\ntype sequencer struct {\n\tmaxWeight int64\n\tsem       *semaphore.Weighted   // weighted by input bytes (an approximate proxy for memory overhead)\n\tprev      <-chan *reporterState // 1-buffered\n}\n\n// newSequencer returns a sequencer that allows concurrent tasks up to maxWeight\n// and writes tasks' output to out and err.\nfunc newSequencer(maxWeight int64, out, err io.Writer) *sequencer {\n\tsem := semaphore.NewWeighted(maxWeight)\n\tprev := make(chan *reporterState, 1)\n\tprev <- &reporterState{out: out, err: err}\n\treturn &sequencer{\n\t\tmaxWeight: maxWeight,\n\t\tsem:       sem,\n\t\tprev:      prev,\n\t}\n}\n\n// exclusive is a weight that can be passed to a sequencer to cause\n// a task to be executed without any other concurrent tasks.\nconst exclusive = -1\n\n// Add blocks until the sequencer has enough weight to spare, then adds f as a\n// task to be executed concurrently.\n//\n// If the weight is either negative or larger than the sequencer's maximum\n// weight, Add blocks until all other tasks have completed, then the task\n// executes exclusively (blocking all other calls to Add until it completes).\n//\n// f may run concurrently in a goroutine, but its output to the passed-in\n// reporter will be sequential relative to the other tasks in the sequencer.\n//\n// If f invokes a method on the reporter, execution of that method may block\n// until the previous task has finished. (To maximize concurrency, f should\n// avoid invoking the reporter until it has finished any parallelizable work.)\n//\n// If f returns a non-nil error, that error will be reported after f's output\n// (if any) and will cause a nonzero final exit code.\nfunc (s *sequencer) Add(weight int64, f func(*reporter) error) {\n\tif weight < 0 || weight > s.maxWeight {\n\t\tweight = s.maxWeight\n\t}\n\tif err := s.sem.Acquire(context.TODO(), weight); err != nil {\n\t\t// Change the task from \"execute f\" to \"report err\".\n\t\tweight = 0\n\t\tf = func(*reporter) error { return err }\n\t}\n\n\tr := &reporter{prev: s.prev}\n\tnext := make(chan *reporterState, 1)\n\ts.prev = next\n\n\t// Start f in parallel: it can run until it invokes a method on r, at which\n\t// point it will block until the previous task releases the output state.\n\tgo func() {\n\t\tif err := f(r); err != nil {\n\t\t\tr.Report(err)\n\t\t}\n\t\tnext <- r.getState() // Release the next task.\n\t\ts.sem.Release(weight)\n\t}()\n}\n\n// AddReport prints an error to s after the output of any previously-added\n// tasks, causing the final exit code to be nonzero.\nfunc (s *sequencer) AddReport(err error) {\n\ts.Add(0, func(*reporter) error { return err })\n}\n\n// GetExitCode waits for all previously-added tasks to complete, then returns an\n// exit code for the sequence suitable for passing to os.Exit.\nfunc (s *sequencer) GetExitCode() int {\n\tc := make(chan int, 1)\n\ts.Add(0, func(r *reporter) error {\n\t\tc <- r.ExitCode()\n\t\treturn nil\n\t})\n\treturn <-c\n}\n\n// A reporter reports output, warnings, and errors.\ntype reporter struct {\n\tprev  <-chan *reporterState\n\tstate *reporterState\n}\n\n// reporterState carries the state of a reporter instance.\n//\n// Only one reporter at a time may have access to a reporterState.\ntype reporterState struct {\n\tout, err io.Writer\n\texitCode int\n}\n\n// getState blocks until any prior reporters are finished with the reporter\n// state, then returns the state for manipulation.\nfunc (r *reporter) getState() *reporterState {\n\tif r.state == nil {\n\t\tr.state = <-r.prev\n\t}\n\treturn r.state\n}\n\n// Warnf emits a warning message to the reporter's error stream,\n// without changing its exit code.\nfunc (r *reporter) Warnf(format string, args ...any) {\n\tfmt.Fprintf(r.getState().err, format, args...)\n}\n\n// Write emits a slice to the reporter's output stream.\n//\n// Any error is returned to the caller, and does not otherwise affect the\n// reporter's exit code.\nfunc (r *reporter) Write(p []byte) (int, error) {\n\treturn r.getState().out.Write(p)\n}\n\n// Report emits a non-nil error to the reporter's error stream,\n// changing its exit code to a nonzero value.\nfunc (r *reporter) Report(err error) {\n\tif err == nil {\n\t\tpanic(\"Report with nil error\")\n\t}\n\tst := r.getState()\n\tscanner.PrintError(st.err, err)\n\tst.exitCode = 2\n}\n\nfunc (r *reporter) ExitCode() int {\n\treturn r.getState().exitCode\n}\n\n// If info == nil, we are formatting stdin instead of a file.\n// If in == nil, the source is the contents of the file with the given filename.\nfunc processFile(filename string, info fs.FileInfo, in io.Reader, r *reporter, explicit bool) error {\n\tsrc, err := readFile(filename, info, in)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfileSet := token.NewFileSet()\n\tfragmentOk := false\n\tif info == nil {\n\t\t// If we are formatting stdin, we accept a program fragment in lieu of a\n\t\t// complete source file.\n\t\tfragmentOk = true\n\t}\n\tfile, sourceAdj, indentAdj, err := parse(fileSet, filename, src, fragmentOk)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tast.SortImports(fileSet, file)\n\n\t// Apply gofumpt's changes before we print the code in gofumpt's format.\n\n\t// If either -lang or -modpath aren't set, fetch them from go.mod.\n\tlang := *langVersion\n\tmodpath := *modulePath\n\tif lang == \"\" || modpath == \"\" {\n\t\tdir := filepath.Dir(filename)\n\t\tmod, ok := moduleCacheByDir.Load(dir)\n\t\tif ok && mod != nil {\n\t\t\tmod := mod.(*module)\n\t\t\tif mod.Go == \"\" {\n\t\t\t\t// If the go directive is missing, go 1.16 is assumed.\n\t\t\t\t// https://go.dev/ref/mod#go-mod-file-go\n\t\t\t\tmod.Go = \"1.16\"\n\t\t\t}\n\t\t\tif lang == \"\" {\n\t\t\t\tlang = \"go\" + mod.Go\n\t\t\t}\n\t\t\tif modpath == \"\" {\n\t\t\t\tmodpath = mod.Module.Path\n\t\t\t}\n\t\t}\n\t}\n\n\t// We always apply the gofumpt formatting rules to explicit files, including stdin.\n\t// Otherwise, we don't apply them on generated files.\n\t// We also skip walking vendor directories entirely, but that happens elsewhere.\n\tif explicit || !isGenerated(file) {\n\t\tgformat.File(fileSet, file, gformat.Options{\n\t\t\tLangVersion: lang,\n\t\t\tModulePath:  modpath,\n\t\t\tExtraRules:  *extraRules,\n\t\t})\n\t}\n\n\tres, err := format(fileSet, file, sourceAdj, indentAdj, src, printer.Config{Mode: printerMode, Tabwidth: tabWidth})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !bytes.Equal(src, res) {\n\t\t// formatting has changed\n\t\tif *list {\n\t\t\tfmt.Fprintln(r, filename)\n\t\t}\n\t\tif *write {\n\t\t\tif info == nil {\n\t\t\t\tpanic(\"-w should not have been allowed with stdin\")\n\t\t\t}\n\t\t\t// make a temporary backup before overwriting original\n\t\t\tperm := info.Mode().Perm()\n\t\t\tbakname, err := backupFile(filename+\".\", src, perm)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfdSem <- true\n\t\t\terr = os.WriteFile(filename, res, perm)\n\t\t\t<-fdSem\n\t\t\tif err != nil {\n\t\t\t\tos.Rename(bakname, filename)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr = os.Remove(bakname)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif *doDiff {\n\t\t\tnewName := filepath.ToSlash(filename)\n\t\t\toldName := newName + \".orig\"\n\t\t\tr.Write(diff.Diff(oldName, src, newName, res))\n\t\t}\n\t}\n\n\tif !*list && !*write && !*doDiff {\n\t\t_, err = r.Write(res)\n\t}\n\n\treturn err\n}\n\n// readFile reads the contents of filename, described by info.\n// If in is non-nil, readFile reads directly from it.\n// Otherwise, readFile opens and reads the file itself,\n// with the number of concurrently-open files limited by fdSem.\nfunc readFile(filename string, info fs.FileInfo, in io.Reader) ([]byte, error) {\n\tif in == nil {\n\t\tfdSem <- true\n\t\tvar err error\n\t\tf, err := os.Open(filename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tin = f\n\t\tdefer func() {\n\t\t\tf.Close()\n\t\t\t<-fdSem\n\t\t}()\n\t}\n\n\t// Compute the file's size and read its contents with minimal allocations.\n\t//\n\t// If we have the FileInfo from filepath.WalkDir, use it to make\n\t// a buffer of the right size and avoid ReadAll's reallocations.\n\t//\n\t// If the size is unknown (or bogus, or overflows an int), fall back to\n\t// a size-independent ReadAll.\n\tsize := -1\n\tif info != nil && info.Mode().IsRegular() && int64(int(info.Size())) == info.Size() {\n\t\tsize = int(info.Size())\n\t}\n\tif size+1 <= 0 {\n\t\t// The file is not known to be regular, so we don't have a reliable size for it.\n\t\tvar err error\n\t\tsrc, err := io.ReadAll(in)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn src, nil\n\t}\n\n\t// We try to read size+1 bytes so that we can detect modifications: if we\n\t// read more than size bytes, then the file was modified concurrently.\n\t// (If that happens, we could, say, append to src to finish the read, or\n\t// proceed with a truncated buffer — but the fact that it changed at all\n\t// indicates a possible race with someone editing the file, so we prefer to\n\t// stop to avoid corrupting it.)\n\tsrc := make([]byte, size+1)\n\tn, err := io.ReadFull(in, src)\n\tswitch err {\n\tcase nil, io.EOF, io.ErrUnexpectedEOF:\n\t\t// io.ReadFull returns io.EOF (for an empty file) or io.ErrUnexpectedEOF\n\t\t// (for a non-empty file) if the file was changed unexpectedly. Continue\n\t\t// with comparing file sizes in those cases.\n\tdefault:\n\t\treturn nil, err\n\t}\n\tif n < size {\n\t\treturn nil, fmt.Errorf(\"error: size of %s changed during reading (from %d to %d bytes)\", filename, size, n)\n\t} else if n > size {\n\t\treturn nil, fmt.Errorf(\"error: size of %s changed during reading (from %d to >=%d bytes)\", filename, size, len(src))\n\t}\n\treturn src[:n], nil\n}\n\nfunc main() {\n\t// Arbitrarily limit in-flight work to 2MiB times the number of threads.\n\t//\n\t// The actual overhead for the parse tree and output will depend on the\n\t// specifics of the file, but this at least keeps the footprint of the process\n\t// roughly proportional to GOMAXPROCS.\n\tmaxWeight := (2 << 20) * int64(runtime.GOMAXPROCS(0))\n\ts := newSequencer(maxWeight, os.Stdout, os.Stderr)\n\n\t// call gofmtMain in a separate function\n\t// so that it can use defer and have them\n\t// run before the exit.\n\tgofmtMain(s)\n\tos.Exit(s.GetExitCode())\n}\n\nfunc gofmtMain(s *sequencer) {\n\t// Ensure our parsed files never start with base 1,\n\t// to ensure that using token.NoPos+1 will panic.\n\tfileSet.AddFile(\"gofumpt_base.go\", 1, 10)\n\n\tflag.Usage = usage\n\tflag.Parse()\n\n\tif *simplifyAST {\n\t\tfmt.Fprintf(os.Stderr, \"warning: -s is deprecated as it is always enabled\\n\")\n\t}\n\tif *rewriteRule != \"\" {\n\t\tfmt.Fprintf(os.Stderr, `the rewrite flag is no longer available; use \"gofmt -r\" instead`+\"\\n\")\n\t\tos.Exit(2)\n\t}\n\n\t// Print the gofumpt version if the user asks for it.\n\tif *showVersion {\n\t\tfmt.Println(gversion.String(version))\n\t\treturn\n\t}\n\n\tif *cpuprofile != \"\" {\n\t\tfdSem <- true\n\t\tf, err := os.Create(*cpuprofile)\n\t\tif err != nil {\n\t\t\ts.AddReport(fmt.Errorf(\"creating cpu profile: %s\", err))\n\t\t\treturn\n\t\t}\n\t\tdefer func() {\n\t\t\tf.Close()\n\t\t\t<-fdSem\n\t\t}()\n\t\tpprof.StartCPUProfile(f)\n\t\tdefer pprof.StopCPUProfile()\n\t}\n\n\tinitParserMode()\n\n\targs := flag.Args()\n\tif len(args) == 0 {\n\t\tif *write {\n\t\t\ts.AddReport(fmt.Errorf(\"error: cannot use -w with standard input\"))\n\t\t\treturn\n\t\t}\n\t\ts.Add(0, func(r *reporter) error {\n\t\t\t// TODO: test explicit==true\n\t\t\treturn processFile(\"<standard input>\", nil, os.Stdin, r, true)\n\t\t})\n\t\treturn\n\t}\n\n\tfor _, arg := range args {\n\t\tswitch info, err := os.Stat(arg); {\n\t\tcase err != nil:\n\t\t\ts.AddReport(err)\n\t\tcase !info.IsDir():\n\t\t\t// Non-directory arguments are always formatted.\n\t\t\targ := arg\n\t\t\ts.Add(fileWeight(arg, info), func(r *reporter) error {\n\t\t\t\treturn processFile(arg, info, nil, r, true)\n\t\t\t})\n\t\tdefault:\n\t\t\t// Directories are walked, ignoring non-Go files.\n\t\t\terr := filepath.WalkDir(arg, func(path string, f fs.DirEntry, err error) error {\n\t\t\t\t// vendor and testdata directories are skipped,\n\t\t\t\t// unless they are explicitly passed as an argument.\n\t\t\t\tbase := filepath.Base(path)\n\t\t\t\tif path != arg && (base == \"vendor\" || base == \"testdata\") {\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t}\n\n\t\t\t\tif err != nil || !isGoFile(f) {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tinfo, err := f.Info()\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.AddReport(err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\ts.Add(fileWeight(path, info), func(r *reporter) error {\n\t\t\t\t\treturn processFile(path, info, nil, r, false)\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\ts.AddReport(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype module struct {\n\tGo     string\n\tModule struct {\n\t\tPath string\n\t}\n}\n\nfunc loadModuleInfo(dir string) any {\n\tcmd := exec.Command(\"go\", \"mod\", \"edit\", \"-json\")\n\tcmd.Dir = dir\n\n\t// Spawning \"go mod edit\" will open files by design,\n\t// such as the named pipe to obtain stdout.\n\t// TODO(mvdan): if we run into \"too many open files\" errors again in the\n\t// future, we probably need to turn fdSem into a weighted semaphore so this\n\t// operation can acquire a weight larger than 1.\n\tfdSem <- true\n\tout, err := cmd.Output()\n\tdefer func() { <-fdSem }()\n\n\tif err != nil || len(out) == 0 {\n\t\treturn nil\n\t}\n\tmod := new(module)\n\tif err := json.Unmarshal(out, mod); err != nil {\n\t\treturn nil\n\t}\n\treturn mod\n}\n\n// Written to by fileWeight, read from fileWeight and processFile.\n// A present but nil value means that loading the module info failed.\n// Note that we don't require the keys to be absolute directories,\n// so duplicates are possible. The same can happen with symlinks.\nvar moduleCacheByDir sync.Map // map[dirString]*module\n\nfunc fileWeight(path string, info fs.FileInfo) int64 {\n\tdir := filepath.Dir(path)\n\tif _, ok := moduleCacheByDir.Load(dir); !ok {\n\t\tmoduleCacheByDir.Store(dir, loadModuleInfo(dir))\n\t}\n\tif info == nil {\n\t\treturn exclusive\n\t}\n\tif info.Mode().Type() == fs.ModeSymlink {\n\t\tvar err error\n\t\tinfo, err = os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn exclusive\n\t\t}\n\t}\n\tif !info.Mode().IsRegular() {\n\t\t// For non-regular files, FileInfo.Size is system-dependent and thus not a\n\t\t// reliable indicator of weight.\n\t\treturn exclusive\n\t}\n\treturn info.Size()\n}\n\nconst chmodSupported = runtime.GOOS != \"windows\"\n\n// backupFile writes data to a new file named filename<number> with permissions perm,\n// with <number randomly chosen such that the file name is unique. backupFile returns\n// the chosen file name.\nfunc backupFile(filename string, data []byte, perm fs.FileMode) (string, error) {\n\tfdSem <- true\n\tdefer func() { <-fdSem }()\n\n\t// create backup file\n\tf, err := os.CreateTemp(filepath.Dir(filename), filepath.Base(filename))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tbakname := f.Name()\n\tif chmodSupported {\n\t\terr = f.Chmod(perm)\n\t\tif err != nil {\n\t\t\tf.Close()\n\t\t\tos.Remove(bakname)\n\t\t\treturn bakname, err\n\t\t}\n\t}\n\n\t// write data to backup file\n\t_, err = f.Write(data)\n\tif err1 := f.Close(); err == nil {\n\t\terr = err1\n\t}\n\n\treturn bakname, err\n}\n"
        },
        {
          "name": "internal.go",
          "type": "blob",
          "size": 5.080078125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// TODO(gri): This file and the file src/go/format/internal.go are\n// the same (but for this comment and the package name). Do not modify\n// one without the other. Determine if we can factor out functionality\n// in a public API. See also #11844 for context.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"strings\"\n\n\t\"mvdan.cc/gofumpt/internal/govendor/go/printer\"\n)\n\n// parse parses src, which was read from the named file,\n// as a Go source file, declaration, or statement list.\nfunc parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n\tfile *ast.File,\n\tsourceAdj func(src []byte, indent int) []byte,\n\tindentAdj int,\n\terr error,\n) {\n\t// Try as whole source file.\n\tfile, err = parser.ParseFile(fset, filename, src, parserMode)\n\t// If there's no error, return. If the error is that the source file didn't begin with a\n\t// package line and source fragments are ok, fall through to\n\t// try as a source fragment. Stop and return on any other error.\n\tif err == nil || !fragmentOk || !strings.Contains(err.Error(), \"expected 'package'\") {\n\t\treturn\n\t}\n\n\t// If this is a declaration list, make it a source file\n\t// by inserting a package clause.\n\t// Insert using a ';', not a newline, so that the line numbers\n\t// in psrc match the ones in src.\n\tpsrc := append([]byte(\"package p;\"), src...)\n\tfile, err = parser.ParseFile(fset, filename, psrc, parserMode)\n\tif err == nil {\n\t\tsourceAdj = func(src []byte, indent int) []byte {\n\t\t\t// Remove the package clause.\n\t\t\t// Gofmt has turned the ';' into a '\\n'.\n\t\t\tsrc = src[indent+len(\"package p\\n\"):]\n\t\t\treturn bytes.TrimSpace(src)\n\t\t}\n\t\treturn\n\t}\n\t// If the error is that the source file didn't begin with a\n\t// declaration, fall through to try as a statement list.\n\t// Stop and return on any other error.\n\tif !strings.Contains(err.Error(), \"expected declaration\") {\n\t\treturn\n\t}\n\n\t// If this is a statement list, make it a source file\n\t// by inserting a package clause and turning the list\n\t// into a function body. This handles expressions too.\n\t// Insert using a ';', not a newline, so that the line numbers\n\t// in fsrc match the ones in src. Add an extra '\\n' before the '}'\n\t// to make sure comments are flushed before the '}'.\n\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '\\n', '\\n', '}')\n\tfile, err = parser.ParseFile(fset, filename, fsrc, parserMode)\n\tif err == nil {\n\t\tsourceAdj = func(src []byte, indent int) []byte {\n\t\t\t// Cap adjusted indent to zero.\n\t\t\tif indent < 0 {\n\t\t\t\tindent = 0\n\t\t\t}\n\t\t\t// Remove the wrapping.\n\t\t\t// Gofmt has turned the \"; \" into a \"\\n\\n\".\n\t\t\t// There will be two non-blank lines with indent, hence 2*indent.\n\t\t\tsrc = src[2*indent+len(\"package p\\n\\nfunc _() {\"):]\n\t\t\t// Remove only the \"}\\n\" suffix: remaining whitespaces will be trimmed anyway\n\t\t\tsrc = src[:len(src)-len(\"}\\n\")]\n\t\t\treturn bytes.TrimSpace(src)\n\t\t}\n\t\t// Gofmt has also indented the function body one level.\n\t\t// Adjust that with indentAdj.\n\t\tindentAdj = -1\n\t}\n\n\t// Succeeded, or out of options.\n\treturn\n}\n\n// format formats the given package file originally obtained from src\n// and adjusts the result based on the original source via sourceAdj\n// and indentAdj.\nfunc format(\n\tfset *token.FileSet,\n\tfile *ast.File,\n\tsourceAdj func(src []byte, indent int) []byte,\n\tindentAdj int,\n\tsrc []byte,\n\tcfg printer.Config,\n) ([]byte, error) {\n\tif sourceAdj == nil {\n\t\t// Complete source file.\n\t\tvar buf bytes.Buffer\n\t\terr := cfg.Fprint(&buf, fset, file)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn buf.Bytes(), nil\n\t}\n\n\t// Partial source file.\n\t// Determine and prepend leading space.\n\ti, j := 0, 0\n\tfor j < len(src) && isSpace(src[j]) {\n\t\tif src[j] == '\\n' {\n\t\t\ti = j + 1 // byte offset of last line in leading space\n\t\t}\n\t\tj++\n\t}\n\tvar res []byte\n\tres = append(res, src[:i]...)\n\n\t// Determine and prepend indentation of first code line.\n\t// Spaces are ignored unless there are no tabs,\n\t// in which case spaces count as one tab.\n\tindent := 0\n\thasSpace := false\n\tfor _, b := range src[i:j] {\n\t\tswitch b {\n\t\tcase ' ':\n\t\t\thasSpace = true\n\t\tcase '\\t':\n\t\t\tindent++\n\t\t}\n\t}\n\tif indent == 0 && hasSpace {\n\t\tindent = 1\n\t}\n\tfor i := 0; i < indent; i++ {\n\t\tres = append(res, '\\t')\n\t}\n\n\t// Format the source.\n\t// Write it without any leading and trailing space.\n\tcfg.Indent = indent + indentAdj\n\tvar buf bytes.Buffer\n\terr := cfg.Fprint(&buf, fset, file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tout := sourceAdj(buf.Bytes(), cfg.Indent)\n\n\t// If the adjusted output is empty, the source\n\t// was empty but (possibly) for white space.\n\t// The result is the incoming source.\n\tif len(out) == 0 {\n\t\treturn src, nil\n\t}\n\n\t// Otherwise, append output to leading space.\n\tres = append(res, out...)\n\n\t// Determine and append trailing space.\n\ti = len(src)\n\tfor i > 0 && isSpace(src[i-1]) {\n\t\ti--\n\t}\n\treturn append(res, src[i:]...), nil\n}\n\n// isSpace reports whether the byte is a space character.\n// isSpace defines a space as being among the following bytes: ' ', '\\t', '\\n' and '\\r'.\nfunc isSpace(b byte) bool {\n\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 1.1806640625,
          "content": "// Copyright (c) 2019, Daniel Martí <mvdan@mvdan.cc>\n// See LICENSE for licensing information\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"flag\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/go-quicktest/qt\"\n\n\t\"github.com/rogpeppe/go-internal/gotooltest\"\n\t\"github.com/rogpeppe/go-internal/testscript\"\n)\n\nfunc TestMain(m *testing.M) {\n\ttestscript.Main(m, map[string]func(){\n\t\t\"gofumpt\": main,\n\t})\n}\n\nvar update = flag.Bool(\"u\", false, \"update testscript output files\")\n\nfunc TestScript(t *testing.T) {\n\tt.Parallel()\n\n\tvar goEnv struct {\n\t\tGOCACHE    string\n\t\tGOMODCACHE string\n\t\tGOMOD      string\n\t}\n\tout, err := exec.Command(\"go\", \"env\", \"-json\").CombinedOutput()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := json.Unmarshal(out, &goEnv); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := testscript.Params{\n\t\tDir:                 filepath.Join(\"testdata\", \"script\"),\n\t\tUpdateScripts:       *update,\n\t\tRequireExplicitExec: true,\n\t\tSetup: func(env *testscript.Env) error {\n\t\t\tenv.Setenv(\"GOCACHE\", goEnv.GOCACHE)\n\t\t\tenv.Setenv(\"GOMODCACHE\", goEnv.GOMODCACHE)\n\t\t\tenv.Setenv(\"GOMOD_DIR\", filepath.Dir(goEnv.GOMOD))\n\t\t\treturn nil\n\t\t},\n\t}\n\terr = gotooltest.Setup(&p)\n\tqt.Assert(t, qt.IsNil(err))\n\ttestscript.Run(t, p)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "ulimit_linux_test.go",
          "type": "blob",
          "size": 2.6240234375,
          "content": "// Copyright (c) 2019, Daniel Martí <mvdan@mvdan.cc>\n// See LICENSE for licensing information\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/go-quicktest/qt\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc init() {\n\t// Here rather than in TestMain, to reuse the unix build tag.\n\tif limit := os.Getenv(\"TEST_WITH_FILE_LIMIT\"); limit != \"\" {\n\t\tn, err := strconv.ParseUint(limit, 10, 64)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\trlimit := unix.Rlimit{Cur: n, Max: n}\n\t\tif err := unix.Setrlimit(unix.RLIMIT_NOFILE, &rlimit); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tmain()\n\t}\n}\n\nfunc TestWithLowOpenFileLimit(t *testing.T) {\n\t// Safe to run in parallel, as we only change the limit for child processes.\n\tt.Parallel()\n\n\ttempDir := t.TempDir()\n\ttestBinary, err := os.Executable()\n\tqt.Assert(t, qt.IsNil(err))\n\n\tconst (\n\t\t// Enough directories to run into the ulimit.\n\t\t// Enough number of files in total to run into the ulimit.\n\t\tnumberDirs        = 500\n\t\tnumberFilesPerDir = 20\n\t\tnumberFilesTotal  = numberDirs * numberFilesPerDir\n\t)\n\tt.Logf(\"writing %d tiny Go files\", numberFilesTotal)\n\tvar allGoFiles []string\n\tfor i := 0; i < numberDirs; i++ {\n\t\t// Prefix \"p\", so the package name is a valid identifier.\n\t\t// Add one go.mod file per directory as well,\n\t\t// which will help catch data races when loading module info.\n\t\tdirName := fmt.Sprintf(\"p%03d\", i)\n\t\tdirPath := filepath.Join(tempDir, dirName)\n\t\terr := os.MkdirAll(dirPath, 0o777)\n\t\tqt.Assert(t, qt.IsNil(err))\n\n\t\terr = os.WriteFile(filepath.Join(dirPath, \"go.mod\"),\n\t\t\t[]byte(fmt.Sprintf(\"module %s\\n\\ngo 1.16\", dirName)), 0o666)\n\t\tqt.Assert(t, qt.IsNil(err))\n\n\t\tfor j := 0; j < numberFilesPerDir; j++ {\n\t\t\tfilePath := filepath.Join(dirPath, fmt.Sprintf(\"%03d.go\", j))\n\t\t\terr := os.WriteFile(filePath,\n\t\t\t\t// Extra newlines so that \"-l\" prints all paths.\n\t\t\t\t[]byte(fmt.Sprintf(\"package %s\\n\\n\\n\", dirName)), 0o666)\n\t\t\tqt.Assert(t, qt.IsNil(err))\n\t\t\tallGoFiles = append(allGoFiles, filePath)\n\t\t}\n\t}\n\tif len(allGoFiles) != numberFilesTotal {\n\t\tpanic(\"allGoFiles doesn't have the expected number of files?\")\n\t}\n\trunGofmt := func(paths ...string) {\n\t\tt.Logf(\"running with %d paths\", len(paths))\n\t\tcmd := exec.Command(testBinary, append([]string{\"-l\"}, paths...)...)\n\t\t// 256 is a relatively common low limit, e.g. on Mac.\n\t\tcmd.Env = append(os.Environ(), \"TEST_WITH_FILE_LIMIT=256\")\n\t\tout, err := cmd.Output()\n\t\tvar stderr []byte\n\t\tif err, _ := err.(*exec.ExitError); err != nil {\n\t\t\tstderr = err.Stderr\n\t\t}\n\t\tqt.Assert(t, qt.IsNil(err), qt.Commentf(\"stderr:\\n%s\", stderr))\n\t\tqt.Assert(t, qt.Equals(bytes.Count(out, []byte(\"\\n\")), len(allGoFiles)))\n\t}\n\trunGofmt(tempDir)\n\trunGofmt(allGoFiles...)\n}\n"
        }
      ]
    }
  ]
}