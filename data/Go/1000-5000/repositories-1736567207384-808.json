{
  "metadata": {
    "timestamp": 1736567207384,
    "page": 808,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "charmbracelet/pop",
      "stars": 2441,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "*.gif\n*.pdf\ndist\ncompletions\nmanpages\n"
        },
        {
          "name": ".golangci-soft.yml",
          "type": "blob",
          "size": 0.6796875,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    # - dupl\n    - exhaustive\n    # - exhaustivestruct\n    - goconst\n    - godot\n    - godox\n    - gomnd\n    - gomoddirectives\n    - goprintffuncname\n    - ifshort\n    # - lll\n    - misspell\n    - nakedret\n    - nestif\n    - noctx\n    - nolintlint\n    - prealloc\n    - wrapcheck\n\n  # disable default linters, they are already enabled in .golangci.yml\n  disable:\n    - deadcode\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - structcheck\n    - typecheck\n    - unused\n    - varcheck\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3798828125,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - exportloopref\n    - goimports\n    - gosec\n    - nilerr\n    - predeclared\n    - revive\n    - rowserrcheck\n    - sqlclosecheck\n    - tparallel\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.45703125,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema-pro.json\n\nincludes:\n  - from_url:\n      url: charmbracelet/meta/main/goreleaser-full.yaml\n\nvariables:\n  main: \".\"\n  binary_name: pop\n  description: \"Send emails from your terminal. üì¨\"\n  github_url: \"https://github.com/charmbracelet/pop\"\n  maintainer: \"Maas Lalani <maas@charm.sh>\"\n  brew_commit_author_name: \"Maas Lalani\"\n  brew_commit_author_email: \"maas@charm.sh\"\n  aur_project_name: charm-pop\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.2705078125,
          "content": "# Contributing\n\nContributions are welcome!\n\nPlease submit a pull request for minor changes and submit issues for major changes for discussions.\n\n### Testing\n\nPlease test the following when submitting a change:\n\n1. Sending an email with the TUI\n2. Sending an email with the CLI\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.091796875,
          "content": "FROM gcr.io/distroless/static\nCOPY pop /usr/local/bin/pop\nENTRYPOINT [ \"/usr/local/bin/pop\" ]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "MIT License\n\nCopyright (c) 2023 Charmbracelet, Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6484375,
          "content": "# Pop\n\n<p>\n  <img src=\"https://stuff.charm.sh/pop/pop-logo.png\" width=\"400\" />\n  <br />\n  <a href=\"https://github.com/charmbracelet/pop/releases\"><img src=\"https://img.shields.io/github/release/charmbracelet/pop.svg\" alt=\"Latest Release\"></a>\n  <a href=\"https://pkg.go.dev/github.com/charmbracelet/pop?tab=doc\"><img src=\"https://godoc.org/github.com/golang/gddo?status.svg\" alt=\"Go Docs\"></a>\n  <a href=\"https://github.com/charmbracelet/pop/actions\"><img src=\"https://github.com/charmbracelet/vhs/workflows/build/badge.svg\" alt=\"Build Status\"></a>\n</p>\n\nSend emails from your terminal.\n\n<img width=\"500\" src=\"https://vhs.charm.sh/vhs-5Dyv3pvzB2YwtUSr72LqSz.gif\" alt=\"pop mail text-based client\">\n\n## Text-based User Interface\n\nLaunch the TUI\n\n```bash\npop\n```\n\n## Command Line Interface\n\n```bash\npop < message.md \\\n    --from \"me@example.com\" \\\n    --to \"you@example.com\" \\\n    --subject \"Hello, world!\" \\\n    --attach invoice.pdf\n```\n\n<img width=\"500\" src=\"https://vhs.charm.sh/vhs-5Cr6Gt1YVBjxGr9zdS85AO.gif\" alt=\"pop mail command line client\">\n\n---\n\n<img width=\"600\" src=\"https://stuff.charm.sh/pop/resend-x-charm.png\" alt=\"Resend and Charm logos\">\n\nTo use `pop`, you will need a `RESEND_API_KEY` or configure an\n[`SMTP`](#smtp-configuration) host.\n\nYou can grab one from: https://resend.com/api-keys.\n\n### Resend Configuration\n\nTo use the resend delivery method, set the `RESEND_API_KEY` environment\nvariable.\n\n```bash\nexport RESEND_API_KEY=$(pass RESEND_API_KEY)\n```\n\n\n### SMTP Configuration\n\nTo configure `pop` to use `SMTP`, you can set the following environment\nvariables.\n\n```bash\nexport POP_SMTP_HOST=smtp.gmail.com\nexport POP_SMTP_PORT=587\nexport POP_SMTP_USERNAME=pop@charm.sh\nexport POP_SMTP_PASSWORD=hunter2\n```\n\n### Environment\n\nTo avoid typing your `From: ` email address, you can also set the `POP_FROM`\nenvironment to pre-fill the field anytime you launch `pop`.\n\n```bash\nexport POP_FROM=pop@charm.sh\nexport POP_SIGNATURE=\"Sent with [Pop](https://github.com/charmbracelet/pop)!\"\n```\n> **Note**:\n> If you wish to use a resend account without a custom domain, you can use\n> `onboarding@resend.dev` to send emails.\n\n## Installation\n\nUse a package manager:\n\n```bash\n# macOS or Linux\nbrew install pop\n\n# Nix\nnix-env -iA nixpkgs.pop\n\n# Arch (btw)\nyay -S charm-pop-bin\n```\n\nInstall with Go:\n\n```sh\ngo install github.com/charmbracelet/pop@latest\n```\n\nOr download a binary from the [releases](https://github.com/charmbracelet/pop/releases).\n\n## Examples\n\nPop can be combined with other tools to create powerful email pipelines, such as:\n\n- [`charmbracelet/mods`](https://github.com/charmbracelet/mods)\n- [`charmbracelet/gum`](https://github.com/charmbracelet/gum)\n- [`maaslalani/invoice`](https://github.com/maaslalani/invoice)\n\n### Mods\n\nUse [`mods`](https://github.com/charmbracelet/mods) with `pop` to write an email body with AI:\n\n> **Note**:\n> Use the `--preview` flag to preview the email and make changes before sending.\n\n```bash\npop <<< \"$(mods -f 'Explain why CLIs are awesome')\" \\\n    --subject \"The command line is the best\" \\\n    --preview\n```\n\n<img width=\"600\" src=\"https://vhs.charm.sh/vhs-1O3zo8Nsi2kPVW3vOBw4WH.gif\" alt=\"Generate email with mods and send email with pop.\">\n\n- [`charmbracelet/mods`](https://github.com/charmbracelet/mods)\n\n### Gum\n\nUse [`gum`](https://github.com/charmbracelet/gum) with `pop` to choose an email to send to and from:\n\n```bash\npop --from $(gum choose \"vt52@charm.sh\" \"vt78@charm.sh\" \"vt100@charm.sh\")\n    --to $(gum filter < contacts.txt)\n```\n\n<img width=\"600\" src=\"https://vhs.charm.sh/vhs-Et9ooHB6L1XVWDL9U1TfI.gif\" alt=\"Select contact information with gum and send email with pop.\">\n\n- [`charmbracelet/gum`](https://github.com/charmbracelet/gum)\n\n### Invoice\n\nUse [`invoice`](https://github.com/maaslalani/invoice) with `pop` to generate and send invoices entirely from the command line.\n\n```bash\nFILENAME=invoice.pdf\ninvoice generate --item \"Rubber Ducky\" --rate 25 --quantity 2 --output $FILENAME\npop --attach $FILENAME --body \"See attached invoice.\"\n```\n\n<img width=\"600\" src=\"https://vhs.charm.sh/vhs-4TRyv82BBDKOutgWdvyshr.gif\" alt=\"Generate invoice with invoice and attach file and send email with pop.\">\n\n- [`maaslalani/invoice`](https://github.com/maaslalani/invoice)\n\n## Feedback\n\nWe‚Äôd love to hear your thoughts on this project. Feel free to drop us a note!\n\n- [Twitter](https://twitter.com/charmcli)\n- [The Fediverse](https://mastodon.social/@charmcli)\n- [Discord](https://charm.sh/chat)\n\n## License\n\n[MIT](https://github.com/charmbracelet/pop/blob/main/LICENSE)\n\n---\n\nPart of [Charm](https://charm.sh).\n\n<a href=\"https://charm.sh/\">\n  <img\n    alt=\"The Charm logo\"\n    width=\"400\"\n    src=\"https://stuff.charm.sh/charm-badge.jpg\"\n  />\n</a>\n\nCharm ÁÉ≠Áà±ÂºÄÊ∫ê ‚Ä¢ Charm loves open source\n"
        },
        {
          "name": "attachments.go",
          "type": "blob",
          "size": 0.8310546875,
          "content": "package main\n\nimport (\n\t\"io\"\n\t\"path/filepath\"\n\n\t\"github.com/charmbracelet/bubbles/list\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n)\n\ntype attachment string\n\nfunc (a attachment) FilterValue() string {\n\treturn string(a)\n}\n\ntype attachmentDelegate struct {\n\tfocused bool\n}\n\nfunc (d attachmentDelegate) Height() int {\n\treturn 1\n}\n\nfunc (d attachmentDelegate) Spacing() int {\n\treturn 0\n}\n\nfunc (d attachmentDelegate) Render(w io.Writer, m list.Model, index int, item list.Item) {\n\tpath := filepath.Base(item.(attachment).FilterValue())\n\tstyle := textStyle\n\tif m.Index() == index && d.focused {\n\t\tstyle = activeTextStyle\n\t}\n\n\tif m.Index() == index {\n\t\t_, _ = w.Write([]byte(style.Render(\"‚Ä¢ \" + path)))\n\t} else {\n\t\t_, _ = w.Write([]byte(style.Render(\"  \" + path)))\n\t}\n}\n\nfunc (d attachmentDelegate) Update(_ tea.Msg, _ *list.Model) tea.Cmd {\n\treturn nil\n}\n"
        },
        {
          "name": "email.go",
          "type": "blob",
          "size": 4.888671875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/resendlabs/resend-go\"\n\tmail \"github.com/xhit/go-simple-mail/v2\"\n\t\"github.com/yuin/goldmark\"\n\t\"github.com/yuin/goldmark/extension\"\n\trenderer \"github.com/yuin/goldmark/renderer/html\"\n)\n\n// ToSeparator is the separator used to split the To, Cc, and Bcc fields.\nconst ToSeparator = \",\"\n\n// sendEmailSuccessMsg is the tea.Msg handled by Bubble Tea when the email has\n// been sent successfully.\ntype sendEmailSuccessMsg struct{}\n\n// sendEmailFailureMsg is the tea.Msg handled by Bubble Tea when the email has\n// failed to send.\ntype sendEmailFailureMsg error\n\n// sendEmailCmd returns a tea.Cmd that sends the email.\nfunc (m Model) sendEmailCmd() tea.Cmd {\n\treturn func() tea.Msg {\n\t\tattachments := make([]string, len(m.Attachments.Items()))\n\t\tfor i, a := range m.Attachments.Items() {\n\t\t\tattachments[i] = a.FilterValue()\n\t\t}\n\t\tvar err error\n\t\tto := strings.Split(m.To.Value(), ToSeparator)\n\t\tcc := strings.Split(m.Cc.Value(), ToSeparator)\n\t\tbcc := strings.Split(m.Bcc.Value(), ToSeparator)\n\t\tswitch m.DeliveryMethod {\n\t\tcase SMTP:\n\t\t\terr = sendSMTPEmail(to, cc, bcc, m.From.Value(), m.Subject.Value(), m.Body.Value(), attachments)\n\t\tcase Resend:\n\t\t\terr = sendResendEmail(to, cc, bcc, m.From.Value(), m.Subject.Value(), m.Body.Value(), attachments)\n\t\tdefault:\n\t\t\terr = errors.New(\"[ERROR]: unknown delivery method\")\n\t\t}\n\t\tif err != nil {\n\t\t\tpath, storeErr := saveTmp(m.Body.Value())\n\t\t\tif storeErr == nil {\n\t\t\t\terr = fmt.Errorf(\"%w\\nEmail saved to: %s\", err, path)\n\t\t\t}\n\t\t\treturn sendEmailFailureMsg(err)\n\t\t}\n\t\treturn sendEmailSuccessMsg{}\n\t}\n}\n\nconst gmailSuffix = \"@gmail.com\"\nconst gmailSMTPHost = \"smtp.gmail.com\"\nconst gmailSMTPPort = 587\n\nfunc sendSMTPEmail(to, cc, bcc []string, from, subject, body string, attachments []string) error {\n\tserver := mail.NewSMTPClient()\n\n\tvar err error\n\tserver.Username = smtpUsername\n\tserver.Password = smtpPassword\n\tserver.Host = smtpHost\n\tserver.Port = smtpPort\n\n\t// Set defaults for gmail.\n\tif strings.HasSuffix(server.Username, gmailSuffix) {\n\t\tif server.Port == 0 {\n\t\t\tserver.Port = gmailSMTPPort\n\t\t}\n\t\tif server.Host == \"\" {\n\t\t\tserver.Host = gmailSMTPHost\n\t\t}\n\t}\n\n\tswitch strings.ToLower(smtpEncryption) {\n\tcase \"ssl\":\n\t\tserver.Encryption = mail.EncryptionSSLTLS\n\tcase \"none\":\n\t\tserver.Encryption = mail.EncryptionNone\n\tdefault:\n\t\tserver.Encryption = mail.EncryptionSTARTTLS\n\t}\n\n\tserver.KeepAlive = false\n\tserver.ConnectTimeout = 10 * time.Second\n\tserver.SendTimeout = 10 * time.Second\n\tserver.TLSConfig = &tls.Config{\n\t\tInsecureSkipVerify: smtpInsecureSkipVerify, //nolint:gosec\n\t\tServerName:         server.Host,\n\t}\n\n\tsmtpClient, err := server.Connect()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\temail := mail.NewMSG()\n\temail.SetFrom(from).\n\t\tAddTo(to...).\n\t\tAddCc(cc...).\n\t\tAddBcc(bcc...).\n\t\tSetSubject(subject)\n\n\thtml := bytes.NewBufferString(\"\")\n\tconvertErr := goldmark.Convert([]byte(body), html)\n\n\tif convertErr != nil {\n\t\temail.SetBody(mail.TextPlain, body)\n\t} else {\n\t\temail.SetBody(mail.TextHTML, html.String())\n\t}\n\n\tfor _, a := range attachments {\n\t\temail.Attach(&mail.File{\n\t\t\tFilePath: a,\n\t\t\tName:     filepath.Base(a),\n\t\t})\n\t}\n\n\treturn email.Send(smtpClient)\n}\n\nfunc sendResendEmail(to, _, _ []string, from, subject, body string, attachments []string) error {\n\tclient := resend.NewClient(resendAPIKey)\n\n\thtml := bytes.NewBufferString(\"\")\n\t// If the conversion fails, we'll simply send the plain-text body.\n\tif unsafe {\n\t\tmarkdown := goldmark.New(\n\t\t\tgoldmark.WithRendererOptions(\n\t\t\t\trenderer.WithUnsafe(),\n\t\t\t),\n\t\t\tgoldmark.WithExtensions(\n\t\t\t\textension.Strikethrough,\n\t\t\t\textension.Table,\n\t\t\t\textension.Linkify,\n\t\t\t),\n\t\t)\n\t\t_ = markdown.Convert([]byte(body), html)\n\t} else {\n\t\t_ = goldmark.Convert([]byte(body), html)\n\t}\n\n\trequest := &resend.SendEmailRequest{\n\t\tFrom:        from,\n\t\tTo:          to,\n\t\tSubject:     subject,\n\t\tCc:          cc,\n\t\tBcc:         bcc,\n\t\tHtml:        html.String(),\n\t\tText:        body,\n\t\tAttachments: makeAttachments(attachments),\n\t}\n\n\t_, err := client.Emails.Send(request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc makeAttachments(paths []string) []resend.Attachment {\n\tif len(paths) == 0 {\n\t\treturn nil\n\t}\n\n\tattachments := make([]resend.Attachment, len(paths))\n\tfor i, a := range paths {\n\t\tf, err := os.ReadFile(a)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tattachments[i] = resend.Attachment{\n\t\t\tContent:  string(f),\n\t\t\tFilename: filepath.Base(a),\n\t\t}\n\t}\n\n\treturn attachments\n}\n\n// saveTmp is a helper function that stores a string in a temporary file.\n// It returns the path of the file created.\nfunc saveTmp(s string) (string, error) {\n\tf, err := os.CreateTemp(\"\", fmt.Sprintf(\"pop-%s-*.txt\", time.Now().Format(\"2006-01-02\")))\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"creating temp file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(s)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error writing to %s: %w\", f.Name(), err)\n\t}\n\n\treturn f.Name(), nil\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.66796875,
          "content": "module github.com/charmbracelet/pop\n\ngo 1.21\n\ntoolchain go1.21.7\n\nrequire (\n\tgithub.com/charmbracelet/bubbles v0.20.0\n\tgithub.com/charmbracelet/bubbletea v1.2.4\n\tgithub.com/charmbracelet/lipgloss v1.0.0\n\tgithub.com/charmbracelet/x/exp/ordered v0.1.0\n\tgithub.com/muesli/mango-cobra v1.2.0\n\tgithub.com/muesli/roff v0.1.0\n\tgithub.com/resendlabs/resend-go v1.7.0\n\tgithub.com/spf13/cobra v1.8.1\n\tgithub.com/xhit/go-simple-mail/v2 v2.16.0\n\tgithub.com/yuin/goldmark v1.7.8\n)\n\nrequire (\n\tgithub.com/atotto/clipboard v0.1.4 // indirect\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/charmbracelet/x/ansi v0.4.5 // indirect\n\tgithub.com/charmbracelet/x/term v0.2.1 // indirect\n\tgithub.com/dustin/go-humanize v1.0.1 // indirect\n\tgithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect\n\tgithub.com/go-test/deep v1.1.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-localereader v0.0.1 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.16 // indirect\n\tgithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/muesli/mango v0.2.0 // indirect\n\tgithub.com/muesli/mango-pflag v0.1.0 // indirect\n\tgithub.com/muesli/termenv v0.15.2 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgithub.com/sahilm/fuzzy v0.1.1 // indirect\n\tgithub.com/spf13/pflag v1.0.5 // indirect\n\tgithub.com/toorop/go-dkim v0.0.0-20240103092955-90b7d1423f92 // indirect\n\tgolang.org/x/sync v0.9.0 // indirect\n\tgolang.org/x/sys v0.27.0 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.6240234375,
          "content": "github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=\ngithub.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=\ngithub.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=\ngithub.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/charmbracelet/bubbles v0.20.0 h1:jSZu6qD8cRQ6k9OMfR1WlM+ruM8fkPWkHvQWD9LIutE=\ngithub.com/charmbracelet/bubbles v0.20.0/go.mod h1:39slydyswPy+uVOHZ5x/GjwVAFkCsV8IIVy+4MhzwwU=\ngithub.com/charmbracelet/bubbletea v1.2.4 h1:KN8aCViA0eps9SCOThb2/XPIlea3ANJLUkv3KnQRNCE=\ngithub.com/charmbracelet/bubbletea v1.2.4/go.mod h1:Qr6fVQw+wX7JkWWkVyXYk/ZUQ92a6XNekLXa3rR18MM=\ngithub.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=\ngithub.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=\ngithub.com/charmbracelet/x/ansi v0.4.5 h1:LqK4vwBNaXw2AyGIICa5/29Sbdq58GbGdFngSexTdRM=\ngithub.com/charmbracelet/x/ansi v0.4.5/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=\ngithub.com/charmbracelet/x/exp/ordered v0.1.0 h1:55/qLwjIh0gL0Vni+QAWk7T/qRVP6sBf+2agPBgnOFE=\ngithub.com/charmbracelet/x/exp/ordered v0.1.0/go.mod h1:5UHwmG+is5THxMyCJHNPCn2/ecI07aKNrW+LcResjJ8=\ngithub.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=\ngithub.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=\ngithub.com/go-test/deep v1.1.0 h1:WOcxcdHcvdgThNXjw0t76K42FXTU7HpNQWHpA2HHNlg=\ngithub.com/go-test/deep v1.1.0/go.mod h1:5C2ZWiW0ErCdrYzpqxLbTX7MG14M9iiw8DgHncVwcsE=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=\ngithub.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/muesli/mango v0.2.0 h1:iNNc0c5VLQ6fsMgAqGQofByNUBH2Q2nEbD6TaI+5yyQ=\ngithub.com/muesli/mango v0.2.0/go.mod h1:5XFpbC8jY5UUv89YQciiXNlbi+iJgt29VDC5xbzrLL4=\ngithub.com/muesli/mango-cobra v1.2.0 h1:DQvjzAM0PMZr85Iv9LIMaYISpTOliMEg+uMFtNbYvWg=\ngithub.com/muesli/mango-cobra v1.2.0/go.mod h1:vMJL54QytZAJhCT13LPVDfkvCUJ5/4jNUKF/8NC2UjA=\ngithub.com/muesli/mango-pflag v0.1.0 h1:UADqbYgpUyRoBja3g6LUL+3LErjpsOwaC9ywvBWe7Sg=\ngithub.com/muesli/mango-pflag v0.1.0/go.mod h1:YEQomTxaCUp8PrbhFh10UfbhbQrM/xJ4i2PB8VTLLW0=\ngithub.com/muesli/roff v0.1.0 h1:YD0lalCotmYuF5HhZliKWlIx7IEhiXeSfq7hNjFqGF8=\ngithub.com/muesli/roff v0.1.0/go.mod h1:pjAHQM9hdUUwm/krAfrLGgJkXJ+YuhtsfZ42kieB2Ig=\ngithub.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=\ngithub.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/resendlabs/resend-go v1.7.0 h1:DycOqSXtw2q7aB+Nt9DDJUDtaYcrNPGn1t5RFposas0=\ngithub.com/resendlabs/resend-go v1.7.0/go.mod h1:yip1STH7Bqfm4fD0So5HgyNbt5taG5Cplc4xXxETyLI=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/sahilm/fuzzy v0.1.1 h1:ceu5RHF8DGgoi+/dR5PsECjCDH1BE3Fnmpo7aVXOdRA=\ngithub.com/sahilm/fuzzy v0.1.1/go.mod h1:VFvziUEIMCrT6A6tw2RFIXPXXmzXbOsSHF0DOI8ZK9Y=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/testify v1.8.2 h1:+h33VjcLVPDHtOdpUCuF+7gSuG3yGIftsP1YvFihtJ8=\ngithub.com/stretchr/testify v1.8.2/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/toorop/go-dkim v0.0.0-20201103131630-e1cd1a0a5208/go.mod h1:BzWtXXrXzZUvMacR0oF/fbDDgUPO8L36tDMmRAf14ns=\ngithub.com/toorop/go-dkim v0.0.0-20240103092955-90b7d1423f92 h1:flbMkdl6HxQkLs6DDhH1UkcnFpNBOu70391STjMS0O4=\ngithub.com/toorop/go-dkim v0.0.0-20240103092955-90b7d1423f92/go.mod h1:BzWtXXrXzZUvMacR0oF/fbDDgUPO8L36tDMmRAf14ns=\ngithub.com/xhit/go-simple-mail/v2 v2.16.0 h1:ouGy/Ww4kuaqu2E2UrDw7SvLaziWTB60ICLkIkNVccA=\ngithub.com/xhit/go-simple-mail/v2 v2.16.0/go.mod h1:b7P5ygho6SYE+VIqpxA6QkYfv4teeyG4MKqB3utRu98=\ngithub.com/yuin/goldmark v1.7.8 h1:iERMLn0/QJeHFhxSt3p6PeN9mGnvIKSpG9YYorDMnic=\ngithub.com/yuin/goldmark v1.7.8/go.mod h1:uzxRWxtg69N339t3louHJ7+O03ezfj6PlliRlaOzY1E=\ngolang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "keymap.go",
          "type": "blob",
          "size": 2.482421875,
          "content": "package main\n\nimport \"github.com/charmbracelet/bubbles/key\"\n\n// KeyMap represents the key bindings for the application.\ntype KeyMap struct {\n\tNextInput key.Binding\n\tPrevInput key.Binding\n\tSend      key.Binding\n\tAttach    key.Binding\n\tUnattach  key.Binding\n\tBack      key.Binding\n\tQuit      key.Binding\n}\n\n// DefaultKeybinds returns the default key bindings for the application.\nfunc DefaultKeybinds() KeyMap {\n\treturn KeyMap{\n\t\tNextInput: key.NewBinding(\n\t\t\tkey.WithKeys(\"tab\"),\n\t\t\tkey.WithHelp(\"tab\", \"next\"),\n\t\t),\n\t\tPrevInput: key.NewBinding(\n\t\t\tkey.WithKeys(\"shift+tab\"),\n\t\t),\n\t\tSend: key.NewBinding(\n\t\t\tkey.WithKeys(\"ctrl+d\", \"enter\"),\n\t\t\tkey.WithHelp(\"enter\", \"send\"),\n\t\t\tkey.WithDisabled(),\n\t\t),\n\t\tAttach: key.NewBinding(\n\t\t\tkey.WithKeys(\"enter\"),\n\t\t\tkey.WithHelp(\"enter\", \"attach file\"),\n\t\t\tkey.WithDisabled(),\n\t\t),\n\t\tUnattach: key.NewBinding(\n\t\t\tkey.WithKeys(\"x\"),\n\t\t\tkey.WithHelp(\"x\", \"remove\"),\n\t\t\tkey.WithDisabled(),\n\t\t),\n\t\tBack: key.NewBinding(\n\t\t\tkey.WithKeys(\"esc\"),\n\t\t\tkey.WithHelp(\"esc\", \"back\"),\n\t\t\tkey.WithDisabled(),\n\t\t),\n\t\tQuit: key.NewBinding(\n\t\t\tkey.WithKeys(\"ctrl+c\"),\n\t\t\tkey.WithHelp(\"ctrl+c\", \"quit\"),\n\t\t),\n\t}\n}\n\n// ShortHelp returns the key bindings for the short help screen.\nfunc (k KeyMap) ShortHelp() []key.Binding {\n\treturn []key.Binding{\n\t\tk.NextInput,\n\t\tk.Quit,\n\t\tk.Attach,\n\t\tk.Unattach,\n\t\tk.Send,\n\t}\n}\n\n// FullHelp returns the key bindings for the full help screen.\nfunc (k KeyMap) FullHelp() [][]key.Binding {\n\treturn [][]key.Binding{\n\t\t{k.NextInput, k.Send, k.Attach, k.Unattach, k.Quit},\n\t}\n}\n\nfunc (m *Model) updateKeymap() {\n\tm.keymap.Attach.SetEnabled(m.state == editingAttachments)\n\tm.keymap.Send.SetEnabled(m.canSend() && m.state == hoveringSendButton)\n\tm.keymap.Unattach.SetEnabled(m.state == editingAttachments && len(m.Attachments.Items()) > 0)\n\tm.keymap.Back.SetEnabled(m.state == pickingFile)\n\n\tm.filepicker.KeyMap.Up.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.Down.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.Back.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.Select.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.Open.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.PageUp.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.PageDown.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.GoToTop.SetEnabled(m.state == pickingFile)\n\tm.filepicker.KeyMap.GoToLast.SetEnabled(m.state == pickingFile)\n}\n\nfunc (m Model) canSend() bool {\n\treturn m.From.Value() != \"\" && m.To.Value() != \"\" && m.Subject.Value() != \"\" && m.Body.Value() != \"\"\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 8.7822265625,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\tmcobra \"github.com/muesli/mango-cobra\"\n\t\"github.com/muesli/roff\"\n\t\"github.com/resendlabs/resend-go\"\n\t\"github.com/spf13/cobra\"\n)\n\n// PopUnsafeHTML is the environment variable that enables unsafe HTML in the\n// email body.\nconst PopUnsafeHTML = \"POP_UNSAFE_HTML\"\n\n// ResendAPIKey is the environment variable that enables Resend as a delivery\n// method and uses it to send the email.\nconst ResendAPIKey = \"RESEND_API_KEY\" //nolint:gosec\n\n// PopFrom is the environment variable that sets the default \"from\" address.\nconst PopFrom = \"POP_FROM\"\n\n// PopSignature is the environment variable that sets the default signature.\nconst PopSignature = \"POP_SIGNATURE\"\n\n// PopSMTPHost is the host for the SMTP server if the user is using the SMTP delivery method.\nconst PopSMTPHost = \"POP_SMTP_HOST\"\n\n// PopSMTPPort is the port for the SMTP server if the user is using the SMTP delivery method.\nconst PopSMTPPort = \"POP_SMTP_PORT\"\n\n// PopSMTPUsername is the username for the SMTP server if the user is using the SMTP delivery method.\nconst PopSMTPUsername = \"POP_SMTP_USERNAME\"\n\n// PopSMTPPassword is the password for the SMTP server if the user is using the SMTP delivery method.\nconst PopSMTPPassword = \"POP_SMTP_PASSWORD\" //nolint:gosec\n\n// PopSMTPEncryption is the encryption type for the SMTP server if the user is using the SMTP delivery method.\nconst PopSMTPEncryption = \"POP_SMTP_ENCRYPTION\" //nolint:gosec\n\n// PopSMTPInsecureSkipVerify is whether or not to skip TLS verification for the\n// SMTP server if the user is using the SMTP delivery method.\nconst PopSMTPInsecureSkipVerify = \"POP_SMTP_INSECURE_SKIP_VERIFY\"\n\nvar (\n\tfrom                   string\n\tto                     []string\n\tcc                     []string\n\tbcc                    []string\n\tsubject                string\n\tbody                   string\n\tattachments            []string\n\tpreview                bool\n\tunsafe                 bool\n\tsignature              string\n\tsmtpHost               string\n\tsmtpPort               int\n\tsmtpUsername           string\n\tsmtpPassword           string\n\tsmtpEncryption         string\n\tsmtpInsecureSkipVerify bool\n\tresendAPIKey           string\n)\n\nvar rootCmd = &cobra.Command{\n\tUse:   \"pop\",\n\tShort: \"Send emails from your terminal\",\n\tLong:  `Pop is a tool for sending emails from your terminal.`,\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\tvar deliveryMethod DeliveryMethod\n\t\tswitch {\n\t\tcase resendAPIKey != \"\" && smtpUsername != \"\" && smtpPassword != \"\":\n\t\t\tdeliveryMethod = Unknown\n\t\tcase resendAPIKey != \"\":\n\t\t\tdeliveryMethod = Resend\n\t\tcase smtpUsername != \"\" && smtpPassword != \"\":\n\t\t\tdeliveryMethod = SMTP\n\t\t\tif from == \"\" {\n\t\t\t\tfrom = smtpUsername\n\t\t\t}\n\t\t}\n\n\t\tswitch deliveryMethod {\n\t\tcase None:\n\t\t\tfmt.Printf(\"\\n  %s %s %s\\n\\n\", errorHeaderStyle.String(), inlineCodeStyle.Render(ResendAPIKey), \"environment variable is required.\")\n\t\t\tfmt.Printf(\"  %s %s\\n\\n\", commentStyle.Render(\"You can grab one at\"), linkStyle.Render(\"https://resend.com/api-keys\"))\n\t\t\tcmd.SilenceUsage = true\n\t\t\tcmd.SilenceErrors = true\n\t\t\treturn errors.New(\"missing required environment variable\")\n\t\tcase Unknown:\n\t\t\tfmt.Printf(\"\\n  %s Unknown delivery method.\\n\", errorHeaderStyle.String())\n\t\t\tfmt.Printf(\"\\n  You have set both %s and %s delivery methods.\", inlineCodeStyle.Render(ResendAPIKey), inlineCodeStyle.Render(\"POP_SMPT_*\"))\n\t\t\tfmt.Printf(\"\\n  Set only one of these environment variables.\\n\\n\")\n\t\t\tcmd.SilenceUsage = true\n\t\t\tcmd.SilenceErrors = true\n\t\t\treturn errors.New(\"unknown delivery method\")\n\t\t}\n\n\t\tif hasStdin() {\n\t\t\tb, err := io.ReadAll(os.Stdin)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tbody = string(b)\n\t\t}\n\n\t\tif signature != \"\" {\n\t\t\tbody += \"\\n\\n\" + signature\n\t\t}\n\n\t\tif len(to) > 0 && from != \"\" && subject != \"\" && body != \"\" && !preview {\n\t\t\tvar err error\n\t\t\tswitch deliveryMethod {\n\t\t\tcase SMTP:\n\t\t\t\terr = sendSMTPEmail(to, cc, bcc, from, subject, body, attachments)\n\t\t\tcase Resend:\n\t\t\t\terr = sendResendEmail(to, cc, bcc, from, subject, body, attachments)\n\t\t\tdefault:\n\t\t\t\terr = fmt.Errorf(\"unknown delivery method\")\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Println(errorStyle.Render(err.Error()))\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfmt.Print(emailSummary(to, subject))\n\t\t\treturn nil\n\t\t}\n\n\t\tp := tea.NewProgram(NewModel(resend.SendEmailRequest{\n\t\t\tFrom:        from,\n\t\t\tTo:          to,\n\t\t\tBcc:         bcc,\n\t\t\tCc:          cc,\n\t\t\tSubject:     subject,\n\t\t\tText:        body,\n\t\t\tAttachments: makeAttachments(attachments),\n\t\t}, deliveryMethod))\n\n\t\tm, err := p.Run()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmm := m.(Model)\n\t\tif !mm.abort {\n\t\t\tfmt.Print(emailSummary(strings.Split(mm.To.Value(), ToSeparator), mm.Subject.Value()))\n\t\t}\n\t\treturn nil\n\t},\n}\n\n// hasStdin returns whether there is data in stdin.\nfunc hasStdin() bool {\n\tstat, err := os.Stdin.Stat()\n\treturn err == nil && (stat.Mode()&os.ModeCharDevice) == 0\n}\n\nvar (\n\t// Version stores the build version of VHS at the time of package through\n\t// -ldflags.\n\t//\n\t// go build -ldflags \"-s -w -X=main.Version=$(VERSION)\"\n\tVersion string\n\n\t// CommitSHA stores the git commit SHA at the time of package through -ldflags.\n\tCommitSHA string\n)\n\n// ManCmd is the cobra command for the manual.\nvar ManCmd = &cobra.Command{\n\tUse:    \"man\",\n\tShort:  \"Generate man page\",\n\tLong:   `To generate the man page`,\n\tArgs:   cobra.NoArgs,\n\tHidden: true,\n\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\tpage, err := mcobra.NewManPage(1, rootCmd) // .\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpage = page.WithSection(\"Copyright\", \"¬© 2023 Charmbracelet, Inc.\\n\"+\"Released under MIT License.\")\n\t\tfmt.Println(page.Build(roff.NewDocument()))\n\t\treturn nil\n\t},\n}\n\nfunc init() {\n\trootCmd.AddCommand(ManCmd)\n\n\trootCmd.Flags().StringSliceVar(&bcc, \"bcc\", []string{}, \"BCC recipients\")\n\trootCmd.Flags().StringSliceVar(&cc, \"cc\", []string{}, \"CC recipients\")\n\trootCmd.Flags().StringSliceVarP(&attachments, \"attach\", \"a\", []string{}, \"Email's attachments\")\n\trootCmd.Flags().StringSliceVarP(&to, \"to\", \"t\", []string{}, \"Recipients\")\n\trootCmd.Flags().StringVarP(&body, \"body\", \"b\", \"\", \"Email's contents\")\n\tenvFrom := os.Getenv(PopFrom)\n\trootCmd.Flags().StringVarP(&from, \"from\", \"f\", envFrom, \"Email's sender\"+commentStyle.Render(\"($\"+PopFrom+\")\"))\n\trootCmd.Flags().StringVarP(&subject, \"subject\", \"s\", \"\", \"Email's subject\")\n\trootCmd.Flags().BoolVar(&preview, \"preview\", false, \"Whether to preview the email before sending\")\n\tenvUnsafe := os.Getenv(PopUnsafeHTML) == \"true\"\n\trootCmd.Flags().BoolVarP(&unsafe, \"unsafe\", \"u\", envUnsafe, \"Whether to allow unsafe HTML in the email body, also enable some extra markdown features (Experimental)\")\n\tenvSignature := os.Getenv(PopSignature)\n\trootCmd.Flags().StringVarP(&signature, \"signature\", \"x\", envSignature, \"Signature to display at the end of the email.\"+commentStyle.Render(\"($\"+PopSignature+\")\"))\n\tenvSMTPHost := os.Getenv(PopSMTPHost)\n\trootCmd.Flags().StringVarP(&smtpHost, \"smtp.host\", \"H\", envSMTPHost, \"Host of the SMTP server\"+commentStyle.Render(\"($\"+PopSMTPHost+\")\"))\n\tenvSMTPPort, _ := strconv.Atoi(os.Getenv(PopSMTPPort))\n\tif envSMTPPort == 0 {\n\t\tenvSMTPPort = 587\n\t}\n\trootCmd.Flags().IntVarP(&smtpPort, \"smtp.port\", \"P\", envSMTPPort, \"Port of the SMTP server\"+commentStyle.Render(\"($\"+PopSMTPPort+\")\"))\n\tenvSMTPUsername := os.Getenv(PopSMTPUsername)\n\trootCmd.Flags().StringVarP(&smtpUsername, \"smtp.username\", \"U\", envSMTPUsername, \"Username of the SMTP server\"+commentStyle.Render(\"($\"+PopSMTPUsername+\")\"))\n\tenvSMTPPassword := os.Getenv(PopSMTPPassword)\n\trootCmd.Flags().StringVarP(&smtpPassword, \"smtp.password\", \"p\", envSMTPPassword, \"Password of the SMTP server\"+commentStyle.Render(\"($\"+PopSMTPPassword+\")\"))\n\tenvSMTPEncryption := os.Getenv(PopSMTPEncryption)\n\trootCmd.Flags().StringVarP(&smtpEncryption, \"smtp.encryption\", \"e\", envSMTPEncryption, \"Encryption type of the SMTP server (starttls, ssl, or none)\"+commentStyle.Render(\"($\"+PopSMTPEncryption+\")\"))\n\tenvInsecureSkipVerify := os.Getenv(PopSMTPInsecureSkipVerify) == \"true\"\n\trootCmd.Flags().BoolVarP(&smtpInsecureSkipVerify, \"smtp.insecure\", \"i\", envInsecureSkipVerify, \"Skip TLS verification with SMTP server\"+commentStyle.Render(\"($\"+PopSMTPInsecureSkipVerify+\")\"))\n\tenvResendAPIKey := os.Getenv(ResendAPIKey)\n\trootCmd.Flags().StringVarP(&resendAPIKey, \"resend.key\", \"r\", envResendAPIKey, \"API key for the Resend.com\"+commentStyle.Render(\"($\"+ResendAPIKey+\")\"))\n\n\trootCmd.CompletionOptions.HiddenDefaultCmd = true\n\n\tif len(CommitSHA) >= 7 { //nolint:gomnd\n\t\tvt := rootCmd.VersionTemplate()\n\t\trootCmd.SetVersionTemplate(vt[:len(vt)-1] + \" (\" + CommitSHA[0:7] + \")\\n\")\n\t}\n\tif Version == \"\" {\n\t\tif info, ok := debug.ReadBuildInfo(); ok && info.Main.Sum != \"\" {\n\t\t\tVersion = info.Main.Version\n\t\t} else {\n\t\t\tVersion = \"unknown (built from source)\"\n\t\t}\n\t}\n\trootCmd.Version = Version\n}\n\nfunc main() {\n\terr := rootCmd.Execute()\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n}\n"
        },
        {
          "name": "model.go",
          "type": "blob",
          "size": 11.7998046875,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/filepicker\"\n\t\"github.com/charmbracelet/bubbles/help\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/list\"\n\t\"github.com/charmbracelet/bubbles/spinner\"\n\t\"github.com/charmbracelet/bubbles/textarea\"\n\t\"github.com/charmbracelet/bubbles/textinput\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/x/exp/ordered\"\n\t\"github.com/resendlabs/resend-go\"\n)\n\n// State is the current state of the application.\ntype State int\n\nconst (\n\teditingFrom State = iota\n\teditingTo\n\teditingCc\n\teditingBcc\n\teditingSubject\n\teditingBody\n\teditingAttachments\n\thoveringSendButton\n\tpickingFile\n\tsendingEmail\n)\n\n// DeliveryMethod is the method of delivery for the email.\ntype DeliveryMethod int\n\nconst (\n\t// None is the default delivery method.\n\tNone DeliveryMethod = iota\n\t// Resend uses https://resend.com to send an email.\n\tResend\n\t// SMTP uses an SMTP server to send an email.\n\tSMTP\n\t// Unknown is set when the user has not chosen a single delivery method.\n\t// i.e. multiple delivery methods are set.\n\tUnknown\n)\n\n// Model is Pop's application model.\ntype Model struct {\n\t// state represents the current state of the application.\n\tstate State\n\n\t// DeliveryMethod is whether we are using DeliveryMethod or Resend.\n\tDeliveryMethod DeliveryMethod\n\n\t// From represents the sender's email address.\n\tFrom textinput.Model\n\t// To represents the recipient's email address.\n\t// This can be a comma-separated list of addresses.\n\tTo textinput.Model\n\t// Subject represents the email's subject.\n\tSubject textinput.Model\n\t// Body represents the email's body.\n\t// This can be written in markdown and will be converted to HTML.\n\tBody textarea.Model\n\t// Attachments represents the email's attachments.\n\t// This is a list of file paths which are picked with a filepicker.\n\tAttachments list.Model\n\n\tshowCc bool\n\tCc     textinput.Model\n\tBcc    textinput.Model\n\n\t// filepicker is used to pick file attachments.\n\tfilepicker     filepicker.Model\n\tloadingSpinner spinner.Model\n\thelp           help.Model\n\tkeymap         KeyMap\n\tquitting       bool\n\tabort          bool\n\terr            error\n}\n\n// NewModel returns a new model for the application.\nfunc NewModel(defaults resend.SendEmailRequest, deliveryMethod DeliveryMethod) Model {\n\tfrom := textinput.New()\n\tfrom.Prompt = \"From \"\n\tfrom.Placeholder = \"me@example.com\"\n\tfrom.PromptStyle = labelStyle.Copy()\n\tfrom.PromptStyle = labelStyle\n\tfrom.TextStyle = textStyle\n\tfrom.Cursor.Style = cursorStyle\n\tfrom.PlaceholderStyle = placeholderStyle\n\tfrom.SetValue(defaults.From)\n\n\tto := textinput.New()\n\tto.Prompt = \"To \"\n\tto.PromptStyle = labelStyle.Copy()\n\tto.Cursor.Style = cursorStyle\n\tto.PlaceholderStyle = placeholderStyle\n\tto.TextStyle = textStyle\n\tto.Placeholder = \"you@example.com\"\n\tto.SetValue(strings.Join(defaults.To, ToSeparator))\n\n\tcc := textinput.New()\n\tcc.Prompt = \"Cc \"\n\tcc.PromptStyle = labelStyle.Copy()\n\tcc.Cursor.Style = cursorStyle\n\tcc.PlaceholderStyle = placeholderStyle\n\tcc.TextStyle = textStyle\n\tcc.Placeholder = \"cc@example.com\"\n\tcc.SetValue(strings.Join(defaults.Cc, ToSeparator))\n\n\tbcc := textinput.New()\n\tbcc.Prompt = \"Bcc \"\n\tbcc.PromptStyle = labelStyle.Copy()\n\tbcc.Cursor.Style = cursorStyle\n\tbcc.PlaceholderStyle = placeholderStyle\n\tbcc.TextStyle = textStyle\n\tbcc.Placeholder = \"bcc@example.com\"\n\tbcc.SetValue(strings.Join(defaults.Bcc, ToSeparator))\n\n\tsubject := textinput.New()\n\tsubject.Prompt = \"Subject \"\n\tsubject.PromptStyle = labelStyle.Copy()\n\tsubject.Cursor.Style = cursorStyle\n\tsubject.PlaceholderStyle = placeholderStyle\n\tsubject.TextStyle = textStyle\n\tsubject.Placeholder = \"Hello!\"\n\tsubject.SetValue(defaults.Subject)\n\n\tbody := textarea.New()\n\tbody.Placeholder = \"# Email\"\n\tbody.ShowLineNumbers = false\n\tbody.FocusedStyle.CursorLine = activeTextStyle\n\tbody.FocusedStyle.Prompt = activeLabelStyle\n\tbody.FocusedStyle.Text = activeTextStyle\n\tbody.FocusedStyle.Placeholder = placeholderStyle\n\tbody.BlurredStyle.CursorLine = textStyle\n\tbody.BlurredStyle.Prompt = labelStyle\n\tbody.BlurredStyle.Text = textStyle\n\tbody.BlurredStyle.Placeholder = placeholderStyle\n\tbody.Cursor.Style = cursorStyle\n\tbody.CharLimit = 4000\n\tbody.SetValue(defaults.Text)\n\n\t// Adjust for signature (if none, this is a no-op)\n\tbody.CursorUp()\n\tbody.CursorUp()\n\n\tbody.Blur()\n\n\t// Decide which input to focus.\n\tvar state State\n\tswitch {\n\tcase defaults.From == \"\":\n\t\tstate = editingFrom\n\tcase len(defaults.To) == 0:\n\t\tstate = editingTo\n\tcase defaults.Subject == \"\":\n\t\tstate = editingSubject\n\tcase defaults.Text == \"\":\n\t\tstate = editingBody\n\t}\n\n\tattachments := list.New([]list.Item{}, attachmentDelegate{}, 0, 3)\n\tattachments.DisableQuitKeybindings()\n\tattachments.SetShowTitle(true)\n\tattachments.Title = \"Attachments\"\n\tattachments.Styles.Title = labelStyle\n\tattachments.Styles.TitleBar = labelStyle\n\tattachments.Styles.NoItems = placeholderStyle\n\tattachments.SetShowHelp(false)\n\tattachments.SetShowStatusBar(false)\n\tattachments.SetStatusBarItemName(\"attachment\", \"attachments\")\n\tattachments.SetShowPagination(false)\n\n\tfor _, a := range defaults.Attachments {\n\t\tattachments.InsertItem(0, attachment(a.Filename))\n\t}\n\n\tpicker := filepicker.New()\n\tpicker.CurrentDirectory, _ = os.UserHomeDir()\n\n\tloadingSpinner := spinner.New()\n\tloadingSpinner.Style = activeLabelStyle\n\tloadingSpinner.Spinner = spinner.Dot\n\n\tm := Model{\n\t\tstate:          state,\n\t\tFrom:           from,\n\t\tTo:             to,\n\t\tshowCc:         len(cc.Value()) > 0 || len(bcc.Value()) > 0,\n\t\tCc:             cc,\n\t\tBcc:            bcc,\n\t\tSubject:        subject,\n\t\tBody:           body,\n\t\tAttachments:    attachments,\n\t\tfilepicker:     picker,\n\t\thelp:           help.New(),\n\t\tkeymap:         DefaultKeybinds(),\n\t\tloadingSpinner: loadingSpinner,\n\t\tDeliveryMethod: deliveryMethod,\n\t}\n\n\tm.focusActiveInput()\n\n\treturn m\n}\n\n// Init initializes the model.\nfunc (m Model) Init() tea.Cmd {\n\treturn tea.Batch(\n\t\tm.From.Cursor.BlinkCmd(),\n\t)\n}\n\ntype clearErrMsg struct{}\n\nfunc clearErrAfter(d time.Duration) tea.Cmd {\n\treturn tea.Tick(d, func(t time.Time) tea.Msg {\n\t\treturn clearErrMsg{}\n\t})\n}\n\n// Update is the update loop for the model.\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase sendEmailSuccessMsg:\n\t\tm.quitting = true\n\t\treturn m, tea.Quit\n\tcase sendEmailFailureMsg:\n\t\tm.blurInputs()\n\t\tm.state = editingFrom\n\t\tm.focusActiveInput()\n\t\tm.err = msg\n\t\treturn m, clearErrAfter(10 * time.Second)\n\tcase clearErrMsg:\n\t\tm.err = nil\n\tcase tea.KeyMsg:\n\t\tswitch {\n\t\tcase key.Matches(msg, m.keymap.NextInput):\n\t\t\tm.blurInputs()\n\t\t\tswitch m.state {\n\t\t\tcase editingFrom:\n\t\t\t\tm.state = editingTo\n\t\t\t\tm.To.Focus()\n\t\t\tcase editingTo:\n\t\t\t\tif m.showCc {\n\t\t\t\t\tm.state = editingCc\n\t\t\t\t} else {\n\t\t\t\t\tm.state = editingSubject\n\t\t\t\t}\n\t\t\tcase editingCc:\n\t\t\t\tm.state = editingBcc\n\t\t\tcase editingBcc:\n\t\t\t\tm.state = editingSubject\n\t\t\tcase editingSubject:\n\t\t\t\tm.state = editingBody\n\t\t\tcase editingBody:\n\t\t\t\tm.state = editingAttachments\n\t\t\tcase editingAttachments:\n\t\t\t\tm.state = hoveringSendButton\n\t\t\tcase hoveringSendButton:\n\t\t\t\tm.state = editingFrom\n\t\t\t}\n\t\t\tm.focusActiveInput()\n\n\t\tcase key.Matches(msg, m.keymap.PrevInput):\n\t\t\tm.blurInputs()\n\t\t\tswitch m.state {\n\t\t\tcase editingFrom:\n\t\t\t\tm.state = hoveringSendButton\n\t\t\tcase editingTo:\n\t\t\t\tm.state = editingFrom\n\t\t\tcase editingCc:\n\t\t\t\tm.state = editingTo\n\t\t\tcase editingBcc:\n\t\t\t\tm.state = editingCc\n\t\t\tcase editingSubject:\n\t\t\t\tif m.showCc {\n\t\t\t\t\tm.state = editingBcc\n\t\t\t\t} else {\n\t\t\t\t\tm.state = editingTo\n\t\t\t\t}\n\t\t\tcase editingBody:\n\t\t\t\tm.state = editingSubject\n\t\t\tcase editingAttachments:\n\t\t\t\tm.state = editingBody\n\t\t\tcase hoveringSendButton:\n\t\t\t\tm.state = editingAttachments\n\t\t\t}\n\t\t\tm.focusActiveInput()\n\n\t\tcase key.Matches(msg, m.keymap.Back):\n\t\t\tm.state = editingAttachments\n\t\t\tm.updateKeymap()\n\t\t\treturn m, nil\n\t\tcase key.Matches(msg, m.keymap.Send):\n\t\t\tm.state = sendingEmail\n\t\t\treturn m, tea.Batch(\n\t\t\t\tm.loadingSpinner.Tick,\n\t\t\t\tm.sendEmailCmd(),\n\t\t\t)\n\t\tcase key.Matches(msg, m.keymap.Attach):\n\t\t\tm.state = pickingFile\n\t\t\treturn m, m.filepicker.Init()\n\t\tcase key.Matches(msg, m.keymap.Unattach):\n\t\t\tm.Attachments.RemoveItem(m.Attachments.Index())\n\t\t\tm.Attachments.SetHeight(ordered.Max(len(m.Attachments.Items()), 1) + 2)\n\t\tcase key.Matches(msg, m.keymap.Quit):\n\t\t\tm.quitting = true\n\t\t\tm.abort = true\n\t\t\treturn m, tea.Quit\n\t\t}\n\t}\n\n\tm.updateKeymap()\n\n\tvar cmds []tea.Cmd\n\tvar cmd tea.Cmd\n\tm.From, cmd = m.From.Update(msg)\n\tcmds = append(cmds, cmd)\n\tm.To, cmd = m.To.Update(msg)\n\tcmds = append(cmds, cmd)\n\tif m.showCc {\n\t\tm.Cc, cmd = m.Cc.Update(msg)\n\t\tcmds = append(cmds, cmd)\n\t\tm.Bcc, cmd = m.Bcc.Update(msg)\n\t\tcmds = append(cmds, cmd)\n\t}\n\tm.Subject, cmd = m.Subject.Update(msg)\n\tcmds = append(cmds, cmd)\n\tm.Body, cmd = m.Body.Update(msg)\n\tcmds = append(cmds, cmd)\n\tm.filepicker, cmd = m.filepicker.Update(msg)\n\tcmds = append(cmds, cmd)\n\n\tswitch m.state {\n\tcase pickingFile:\n\t\tif didSelect, path := m.filepicker.DidSelectFile(msg); didSelect {\n\t\t\tm.Attachments.InsertItem(0, attachment(path))\n\t\t\tm.Attachments.SetHeight(len(m.Attachments.Items()) + 2)\n\t\t\tm.state = editingAttachments\n\t\t\tm.updateKeymap()\n\t\t}\n\tcase editingAttachments:\n\t\tm.Attachments, cmd = m.Attachments.Update(msg)\n\t\tcmds = append(cmds, cmd)\n\tcase sendingEmail:\n\t\tm.loadingSpinner, cmd = m.loadingSpinner.Update(msg)\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\tm.help, cmd = m.help.Update(msg)\n\tcmds = append(cmds, cmd)\n\n\treturn m, tea.Batch(cmds...)\n}\n\nfunc (m *Model) blurInputs() {\n\tm.From.Blur()\n\tm.To.Blur()\n\tm.Subject.Blur()\n\tm.Body.Blur()\n\tif m.showCc {\n\t\tm.Cc.Blur()\n\t\tm.Bcc.Blur()\n\t}\n\tm.From.PromptStyle = labelStyle\n\tm.To.PromptStyle = labelStyle\n\tif m.showCc {\n\t\tm.Cc.PromptStyle = labelStyle\n\t\tm.Cc.TextStyle = textStyle\n\t\tm.Bcc.PromptStyle = labelStyle\n\t\tm.Bcc.TextStyle = textStyle\n\t}\n\tm.Subject.PromptStyle = labelStyle\n\tm.From.TextStyle = textStyle\n\tm.To.TextStyle = textStyle\n\tm.Subject.TextStyle = textStyle\n\tm.Attachments.Styles.Title = labelStyle\n\tm.Attachments.SetDelegate(attachmentDelegate{false})\n}\n\nfunc (m *Model) focusActiveInput() {\n\tswitch m.state {\n\tcase editingFrom:\n\t\tm.From.PromptStyle = activeLabelStyle\n\t\tm.From.TextStyle = activeTextStyle\n\t\tm.From.Focus()\n\t\tm.From.CursorEnd()\n\tcase editingTo:\n\t\tm.To.PromptStyle = activeLabelStyle\n\t\tm.To.TextStyle = activeTextStyle\n\t\tm.To.Focus()\n\t\tm.To.CursorEnd()\n\tcase editingCc:\n\t\tm.Cc.PromptStyle = activeLabelStyle\n\t\tm.Cc.TextStyle = activeTextStyle\n\t\tm.Cc.Focus()\n\t\tm.Cc.CursorEnd()\n\tcase editingBcc:\n\t\tm.Bcc.PromptStyle = activeLabelStyle\n\t\tm.Bcc.TextStyle = activeTextStyle\n\t\tm.Bcc.Focus()\n\t\tm.Bcc.CursorEnd()\n\tcase editingSubject:\n\t\tm.Subject.PromptStyle = activeLabelStyle\n\t\tm.Subject.TextStyle = activeTextStyle\n\t\tm.Subject.Focus()\n\t\tm.Subject.CursorEnd()\n\tcase editingBody:\n\t\tm.Body.Focus()\n\t\tm.Body.CursorEnd()\n\tcase editingAttachments:\n\t\tm.Attachments.Styles.Title = activeLabelStyle\n\t\tm.Attachments.SetDelegate(attachmentDelegate{true})\n\t}\n}\n\n// View displays the application.\nfunc (m Model) View() string {\n\tif m.quitting {\n\t\treturn \"\"\n\t}\n\n\tswitch m.state {\n\tcase pickingFile:\n\t\treturn \"\\n\" + activeLabelStyle.Render(\"Attachments\") + \" \" + commentStyle.Render(m.filepicker.CurrentDirectory) +\n\t\t\t\"\\n\\n\" + m.filepicker.View()\n\tcase sendingEmail:\n\t\treturn \"\\n \" + m.loadingSpinner.View() + \"Sending email\"\n\t}\n\n\tvar s strings.Builder\n\n\ts.WriteString(m.From.View())\n\ts.WriteString(\"\\n\")\n\ts.WriteString(m.To.View())\n\ts.WriteString(\"\\n\")\n\tif m.showCc {\n\t\ts.WriteString(m.Cc.View())\n\t\ts.WriteString(\"\\n\")\n\t\ts.WriteString(m.Bcc.View())\n\t\ts.WriteString(\"\\n\")\n\t}\n\ts.WriteString(m.Subject.View())\n\ts.WriteString(\"\\n\\n\")\n\ts.WriteString(m.Body.View())\n\ts.WriteString(\"\\n\\n\")\n\ts.WriteString(m.Attachments.View())\n\ts.WriteString(\"\\n\")\n\tif m.state == hoveringSendButton && m.canSend() {\n\t\ts.WriteString(sendButtonActiveStyle.Render(\"Send\"))\n\t} else if m.state == hoveringSendButton {\n\t\ts.WriteString(sendButtonInactiveStyle.Render(\"Send\"))\n\t} else {\n\t\ts.WriteString(sendButtonStyle.Render(\"Send\"))\n\t}\n\ts.WriteString(\"\\n\\n\")\n\ts.WriteString(m.help.View(m.keymap))\n\n\tif m.err != nil {\n\t\ts.WriteString(\"\\n\\n\")\n\t\ts.WriteString(errorStyle.Render(m.err.Error()))\n\t}\n\n\treturn paddedStyle.Render(s.String())\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 2.0810546875,
          "content": "package main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\nconst accentColor = lipgloss.Color(\"99\")\nconst yellowColor = lipgloss.Color(\"#ECFD66\")\nconst whiteColor = lipgloss.Color(\"255\")\nconst grayColor = lipgloss.Color(\"241\")\nconst darkGrayColor = lipgloss.Color(\"236\")\nconst lightGrayColor = lipgloss.Color(\"247\")\n\nvar (\n\tactiveTextStyle = lipgloss.NewStyle().Foreground(whiteColor)\n\ttextStyle       = lipgloss.NewStyle().Foreground(lightGrayColor)\n\n\tactiveLabelStyle = lipgloss.NewStyle().Foreground(accentColor)\n\tlabelStyle       = lipgloss.NewStyle().Foreground(grayColor)\n\n\tplaceholderStyle = lipgloss.NewStyle().Foreground(darkGrayColor)\n\tcursorStyle      = lipgloss.NewStyle().Foreground(whiteColor)\n\n\tpaddedStyle = lipgloss.NewStyle().Padding(1)\n\n\terrorHeaderStyle = lipgloss.NewStyle().Foreground(lipgloss.Color(\"#F1F1F1\")).Background(lipgloss.Color(\"#FF5F87\")).Bold(true).Padding(0, 1).SetString(\"ERROR\")\n\terrorStyle       = lipgloss.NewStyle().Foreground(lipgloss.Color(\"#FF5F87\"))\n\tcommentStyle     = lipgloss.NewStyle().Foreground(lipgloss.Color(\"#757575\")).PaddingLeft(1)\n\n\tsendButtonActiveStyle   = lipgloss.NewStyle().Background(accentColor).Foreground(yellowColor).Padding(0, 2)\n\tsendButtonInactiveStyle = lipgloss.NewStyle().Background(darkGrayColor).Foreground(lightGrayColor).Padding(0, 2)\n\tsendButtonStyle         = lipgloss.NewStyle().Background(darkGrayColor).Foreground(grayColor).Padding(0, 2)\n\n\tinlineCodeStyle = lipgloss.NewStyle().Foreground(lipgloss.Color(\"#FF5F87\")).Background(lipgloss.Color(\"#3A3A3A\")).Padding(0, 1)\n\tlinkStyle       = lipgloss.NewStyle().Foreground(lipgloss.Color(\"#00AF87\")).Underline(true)\n)\n\n// emailSummary returns a summary of the email that was sent. It is used when\n// the user has sent an email successfully.\nfunc emailSummary(to []string, subject string) string {\n\tvar s strings.Builder\n\ts.WriteString(\"\\n  Email \")\n\ts.WriteString(activeTextStyle.Render(\"\\\"\" + subject + \"\\\"\"))\n\ts.WriteString(\" sent to \")\n\tfor i, t := range to {\n\t\tif i > 0 {\n\t\t\ts.WriteString(\", \")\n\t\t}\n\t\ts.WriteString(linkStyle.Render(t))\n\t}\n\ts.WriteString(\"\\n\\n\")\n\n\treturn s.String()\n}\n"
        }
      ]
    }
  ]
}