{
  "metadata": {
    "timestamp": 1736566595610,
    "page": 148,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Masterminds/sprig",
      "stars": 4343,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "vendor/\n/.glide\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 13.8203125,
          "content": "# Changelog\n\n## Release 3.3.0 (2024-08-29)\n\n### Added\n\n- #400: added sha512sum function (thanks @itzik-elayev)\n\n### Changed\n\n- #407: Removed duplicate documentation (functions were documentated in 2 places)\n- #290: Corrected copy/paster oops in math documentation (thanks @zzhu41)\n- #369: Corrected template reference in docs (thanks @chey)\n- #375: Added link to URL documenation (thanks @carlpett)\n- #406: Updated the mergo dependency which had a breaking change (which was accounted for)\n- #376: Fixed documentation error (thanks @jheyduk)\n- #404: Updated dependency tree\n- #391: Fixed misspelling (thanks @chrishalbert)\n- #405: Updated Go versions used in testing\n\n## Release 3.2.3 (2022-11-29)\n\n### Changed\n\n- Updated docs (thanks @book987 @aJetHorn @neelayu @pellizzetti @apricote @SaigyoujiYuyuko233 @AlekSi)\n- #348: Updated huandu/xstrings which fixed a snake case bug (thanks @yxxhero)\n- #353: Updated masterminds/semver which included bug fixes\n- #354: Updated golang.org/x/crypto which included bug fixes\n\n## Release 3.2.2 (2021-02-04)\n\nThis is a re-release of 3.2.1 to satisfy something with the Go module system.\n\n## Release 3.2.1 (2021-02-04)\n\n### Changed\n\n- Upgraded `Masterminds/goutils` to `v1.1.1`. see the [Security Advisory](https://github.com/Masterminds/goutils/security/advisories/GHSA-xg2h-wx96-xgxr)\n\n## Release 3.2.0 (2020-12-14)\n\n### Added\n\n- #211: Added randInt function (thanks @kochurovro)\n- #223: Added fromJson and mustFromJson functions (thanks @mholt)\n- #242: Added a bcrypt function (thanks @robbiet480)\n- #253: Added randBytes function (thanks @MikaelSmith)\n- #254: Added dig function for dicts (thanks @nyarly)\n- #257: Added regexQuoteMeta for quoting regex metadata (thanks @rheaton)\n- #261: Added filepath functions osBase, osDir, osExt, osClean, osIsAbs (thanks @zugl)\n- #268: Added and and all functions for testing conditions (thanks @phuslu)\n- #181: Added float64 arithmetic addf, add1f, subf, divf, mulf, maxf, and minf\n  (thanks @andrewmostello)\n- #265: Added chunk function to split array into smaller arrays (thanks @karelbilek)\n- #270: Extend certificate functions to handle non-RSA keys + add support for\n  ed25519 keys (thanks @misberner)\n\n### Changed\n\n- Removed testing and support for Go 1.12. ed25519 support requires Go 1.13 or newer\n- Using semver 3.1.1 and mergo 0.3.11\n\n### Fixed\n\n- #249: Fix htmlDateInZone example (thanks @spawnia)\n\nNOTE: The dependency github.com/imdario/mergo reverted the breaking change in\n0.3.9 via 0.3.10 release.\n\n## Release 3.1.0 (2020-04-16)\n\nNOTE: The dependency github.com/imdario/mergo made a behavior change in 0.3.9\nthat impacts sprig functionality. Do not use sprig with a version newer than 0.3.8.\n\n### Added\n\n- #225: Added support for generating htpasswd hash (thanks @rustycl0ck)\n- #224: Added duration filter (thanks @frebib)\n- #205: Added `seq` function (thanks @thadc23)\n\n### Changed\n\n- #203: Unlambda functions with correct signature (thanks @muesli)\n- #236: Updated the license formatting for GitHub display purposes\n- #238: Updated package dependency versions. Note, mergo not updated to 0.3.9\n        as it causes a breaking change for sprig. That issue is tracked at\n        https://github.com/imdario/mergo/issues/139\n\n### Fixed\n\n- #229: Fix `seq` example in docs (thanks @kalmant)\n\n## Release 3.0.2 (2019-12-13)\n\n### Fixed\n\n- #220: Updating to semver v3.0.3 to fix issue with <= ranges\n- #218: fix typo elyptical->elliptic in ecdsa key description (thanks @laverya)\n\n## Release 3.0.1 (2019-12-08)\n\n### Fixed\n\n- #212: Updated semver fixing broken constraint checking with ^0.0\n\n## Release 3.0.0 (2019-10-02)\n\n### Added\n\n- #187: Added durationRound function (thanks @yjp20)\n- #189: Added numerous template functions that return errors rather than panic (thanks @nrvnrvn)\n- #193: Added toRawJson support (thanks @Dean-Coakley)\n- #197: Added get support to dicts (thanks @Dean-Coakley)\n\n### Changed\n\n- #186: Moving dependency management to Go modules\n- #186: Updated semver to v3. This has changes in the way ^ is handled\n- #194: Updated documentation on merging and how it copies. Added example using deepCopy\n- #196: trunc now supports negative values (thanks @Dean-Coakley)\n\n## Release 2.22.0 (2019-10-02)\n\n### Added\n\n- #173: Added getHostByName function to resolve dns names to ips (thanks @fcgravalos)\n- #195: Added deepCopy function for use with dicts\n\n### Changed\n\n- Updated merge and mergeOverwrite documentation to explain copying and how to\n  use deepCopy with it\n\n## Release 2.21.0 (2019-09-18)\n\n### Added\n\n- #122: Added encryptAES/decryptAES functions (thanks @n0madic)\n- #128: Added toDecimal support (thanks @Dean-Coakley)\n- #169: Added list contcat (thanks @astorath)\n- #174: Added deepEqual function (thanks @bonifaido)\n- #170: Added url parse and join functions (thanks @astorath)\n\n### Changed\n\n- #171: Updated glide config for Google UUID to v1 and to add ranges to semver and testify\n\n### Fixed\n\n- #172: Fix semver wildcard example (thanks @piepmatz)\n- #175: Fix dateInZone doc example (thanks @s3than)\n\n## Release 2.20.0 (2019-06-18)\n\n### Added\n\n- #164: Adding function to get unix epoch for a time (@mattfarina)\n- #166: Adding tests for date_in_zone (@mattfarina)\n\n### Changed\n\n- #144: Fix function comments based on best practices from Effective Go (@CodeLingoTeam)\n- #150: Handles pointer type for time.Time in \"htmlDate\" (@mapreal19)\n- #161, #157, #160,  #153, #158, #156,  #155,  #159, #152 documentation updates (@badeadan)\n\n### Fixed\n\n## Release 2.19.0 (2019-03-02)\n\nIMPORTANT: This release reverts a change from 2.18.0\n\nIn the previous release (2.18), we prematurely merged a partial change to the crypto functions that led to creating two sets of crypto functions (I blame @technosophos -- since that's me). This release rolls back that change, and does what was originally intended: It alters the existing crypto functions to use secure random.\n\nWe debated whether this classifies as a change worthy of major revision, but given the proximity to the last release, we have decided that treating 2.18 as a faulty release is the correct course of action. We apologize for any inconvenience.\n\n### Changed\n\n- Fix substr panic 35fb796 (Alexey igrychev)\n- Remove extra period 1eb7729 (Matthew Lorimor)\n- Make random string functions use crypto by default 6ceff26 (Matthew Lorimor)\n- README edits/fixes/suggestions 08fe136 (Lauri Apple)\n\n\n## Release 2.18.0 (2019-02-12)\n\n### Added\n\n- Added mergeOverwrite function\n- cryptographic functions that use secure random (see fe1de12)\n\n### Changed\n\n- Improve documentation of regexMatch function, resolves #139 90b89ce (Jan Tagscherer)\n- Handle has for nil list 9c10885 (Daniel Cohen)\n- Document behaviour of mergeOverwrite fe0dbe9 (Lukas Rieder)\n- doc: adds missing documentation. 4b871e6 (Fernandez Ludovic)\n- Replace outdated goutils imports 01893d2 (Matthew Lorimor)\n- Surface crypto secure random strings from goutils fe1de12 (Matthew Lorimor)\n- Handle untyped nil values as paramters to string functions 2b2ec8f (Morten Torkildsen)\n\n### Fixed\n\n- Fix dict merge issue and provide mergeOverwrite .dst .src1 to overwrite from src -> dst 4c59c12 (Lukas Rieder)\n- Fix substr var names and comments d581f80 (Dean Coakley)\n- Fix substr documentation 2737203 (Dean Coakley)\n\n## Release 2.17.1 (2019-01-03)\n\n### Fixed\n\nThe 2.17.0 release did not have a version pinned for xstrings, which caused compilation failures when xstrings < 1.2 was used. This adds the correct version string to glide.yaml.\n\n## Release 2.17.0 (2019-01-03)\n\n### Added\n\n- adds alder32sum function and test 6908fc2 (marshallford)\n- Added kebabcase function ca331a1 (Ilyes512)\n\n### Changed\n\n- Update goutils to 1.1.0 4e1125d (Matt Butcher)\n\n### Fixed\n\n- Fix 'has' documentation e3f2a85 (dean-coakley)\n- docs(dict): fix typo in pick example dc424f9 (Dustin Specker)\n- fixes spelling errors... not sure how that happened 4cf188a (marshallford)\n\n## Release 2.16.0 (2018-08-13)\n\n### Added\n\n- add splitn function fccb0b0 (Helgi Þorbjörnsson)\n- Add slice func df28ca7 (gongdo)\n- Generate serial number a3bdffd (Cody Coons)\n- Extract values of dict with values function df39312 (Lawrence Jones)\n\n### Changed\n\n- Modify panic message for list.slice ae38335 (gongdo)\n- Minor improvement in code quality - Removed an unreachable piece of code at defaults.go#L26:6 - Resolve formatting issues. 5834241 (Abhishek Kashyap)\n- Remove duplicated documentation 1d97af1 (Matthew Fisher)\n- Test on go 1.11 49df809 (Helgi Þormar Þorbjörnsson)\n\n### Fixed\n\n- Fix file permissions c5f40b5 (gongdo)\n- Fix example for buildCustomCert 7779e0d (Tin Lam)\n\n## Release 2.15.0 (2018-04-02)\n\n### Added\n\n- #68 and #69: Add json helpers to docs (thanks @arunvelsriram)\n- #66: Add ternary function (thanks @binoculars)\n- #67: Allow keys function to take multiple dicts (thanks @binoculars)\n- #89: Added sha1sum to crypto function (thanks @benkeil)\n- #81: Allow customizing Root CA that used by genSignedCert (thanks @chenzhiwei)\n- #92: Add travis testing for go 1.10\n- #93: Adding appveyor config for windows testing\n\n### Changed\n\n- #90: Updating to more recent dependencies\n- #73: replace satori/go.uuid with google/uuid (thanks @petterw)\n\n### Fixed\n\n- #76: Fixed documentation typos (thanks @Thiht)\n- Fixed rounding issue on the `ago` function. Note, the removes support for Go 1.8 and older\n\n## Release 2.14.1 (2017-12-01)\n\n### Fixed\n\n- #60: Fix typo in function name documentation (thanks @neil-ca-moore)\n- #61: Removing line with {{ due to blocking github pages genertion\n- #64: Update the list functions to handle int, string, and other slices for compatibility\n\n## Release 2.14.0 (2017-10-06)\n\nThis new version of Sprig adds a set of functions for generating and working with SSL certificates.\n\n- `genCA` generates an SSL Certificate Authority\n- `genSelfSignedCert` generates an SSL self-signed certificate\n- `genSignedCert` generates an SSL certificate and key based on a given CA\n\n## Release 2.13.0 (2017-09-18)\n\nThis release adds new functions, including:\n\n- `regexMatch`, `regexFindAll`, `regexFind`, `regexReplaceAll`, `regexReplaceAllLiteral`, and `regexSplit` to work with regular expressions\n- `floor`, `ceil`, and `round` math functions\n- `toDate` converts a string to a date\n- `nindent` is just like `indent` but also prepends a new line\n- `ago` returns the time from `time.Now`\n\n### Added\n\n- #40: Added basic regex functionality (thanks @alanquillin)\n- #41: Added ceil floor and round functions (thanks @alanquillin)\n- #48: Added toDate function (thanks @andreynering)\n- #50: Added nindent function (thanks @binoculars)\n- #46: Added ago function (thanks @slayer)\n\n### Changed\n\n- #51: Updated godocs to include new string functions (thanks @curtisallen)\n- #49: Added ability to merge multiple dicts (thanks @binoculars)\n\n## Release 2.12.0 (2017-05-17)\n\n- `snakecase`, `camelcase`, and `shuffle` are three new string functions\n- `fail` allows you to bail out of a template render when conditions are not met\n\n## Release 2.11.0 (2017-05-02)\n\n- Added `toJson` and `toPrettyJson`\n- Added `merge`\n- Refactored documentation\n\n## Release 2.10.0 (2017-03-15)\n\n- Added `semver` and `semverCompare` for Semantic Versions\n- `list` replaces `tuple`\n- Fixed issue with `join`\n- Added `first`, `last`, `initial`, `rest`, `prepend`, `append`, `toString`, `toStrings`, `sortAlpha`, `reverse`, `coalesce`, `pluck`, `pick`, `compact`, `keys`, `omit`, `uniq`, `has`, `without`\n\n## Release 2.9.0 (2017-02-23)\n\n- Added `splitList` to split a list\n- Added crypto functions of `genPrivateKey` and `derivePassword`\n\n## Release 2.8.0 (2016-12-21)\n\n- Added access to several path functions (`base`, `dir`, `clean`, `ext`, and `abs`)\n- Added functions for _mutating_ dictionaries (`set`, `unset`, `hasKey`)\n\n## Release 2.7.0 (2016-12-01)\n\n- Added `sha256sum` to generate a hash of an input\n- Added functions to convert a numeric or string to `int`, `int64`, `float64`\n\n## Release 2.6.0 (2016-10-03)\n\n- Added a `uuidv4` template function for generating UUIDs inside of a template.\n\n## Release 2.5.0 (2016-08-19)\n\n- New `trimSuffix`, `trimPrefix`, `hasSuffix`, and `hasPrefix` functions\n- New aliases have been added for a few functions that didn't follow the naming conventions (`trimAll` and `abbrevBoth`)\n- `trimall` and `abbrevboth` (notice the case) are deprecated and will be removed in 3.0.0\n\n## Release 2.4.0 (2016-08-16)\n\n- Adds two functions: `until` and `untilStep`\n\n## Release 2.3.0 (2016-06-21)\n\n- cat: Concatenate strings with whitespace separators.\n- replace: Replace parts of a string: `replace \" \" \"-\" \"Me First\"` renders \"Me-First\"\n- plural: Format plurals: `len \"foo\" | plural \"one foo\" \"many foos\"` renders \"many foos\"\n- indent: Indent blocks of text in a way that is sensitive to \"\\n\" characters.\n\n## Release 2.2.0 (2016-04-21)\n\n- Added a `genPrivateKey` function (Thanks @bacongobbler)\n\n## Release 2.1.0 (2016-03-30)\n\n- `default` now prints the default value when it does not receive a value down the pipeline. It is much safer now to do `{{.Foo | default \"bar\"}}`.\n- Added accessors for \"hermetic\" functions. These return only functions that, when given the same input, produce the same output.\n\n## Release 2.0.0 (2016-03-29)\n\nBecause we switched from `int` to `int64` as the return value for all integer math functions, the library's major version number has been incremented.\n\n- `min` complements `max` (formerly `biggest`)\n- `empty` indicates that a value is the empty value for its type\n- `tuple` creates a tuple inside of a template: `{{$t := tuple \"a\", \"b\" \"c\"}}`\n- `dict` creates a dictionary inside of a template `{{$d := dict \"key1\" \"val1\" \"key2\" \"val2\"}}`\n- Date formatters have been added for HTML dates (as used in `date` input fields)\n- Integer math functions can convert from a number of types, including `string` (via `strconv.ParseInt`).\n\n## Release 1.2.0 (2016-02-01)\n\n- Added quote and squote\n- Added b32enc and b32dec\n- add now takes varargs\n- biggest now takes varargs\n\n## Release 1.1.0 (2015-12-29)\n\n- Added #4: Added contains function. strings.Contains, but with the arguments\n  switched to simplify common pipelines. (thanks krancour)\n- Added Travis-CI testing support\n\n## Release 1.0.0 (2015-12-23)\n\n- Initial release\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (C) 2013-2020 Masterminds\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1748046875,
          "content": ".PHONY: test\ntest:\n\t@echo \"==> Running tests\"\n\tGO111MODULE=on go test -v\n\n.PHONY: test-cover\ntest-cover:\n\t@echo \"==> Running Tests with coverage\"\n\tGO111MODULE=on go test -cover .\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.8388671875,
          "content": "# Sprig: Template functions for Go templates\n\n[![GoDoc](https://img.shields.io/static/v1?label=godoc&message=reference&color=blue)](https://pkg.go.dev/github.com/Masterminds/sprig/v3)\n[![Go Report Card](https://goreportcard.com/badge/github.com/Masterminds/sprig)](https://goreportcard.com/report/github.com/Masterminds/sprig)\n[![Stability: Sustained](https://masterminds.github.io/stability/sustained.svg)](https://masterminds.github.io/stability/sustained.html)\n[![](https://github.com/Masterminds/sprig/workflows/Tests/badge.svg)](https://github.com/Masterminds/sprig/actions)\n\nThe Go language comes with a [built-in template\nlanguage](http://golang.org/pkg/text/template/), but not\nvery many template functions. Sprig is a library that provides more than 100 commonly\nused template functions.\n\nIt is inspired by the template functions found in\n[Twig](http://twig.sensiolabs.org/documentation) and in various\nJavaScript libraries, such as [underscore.js](http://underscorejs.org/).\n\n## IMPORTANT NOTES\n\nSprig leverages [mergo](https://github.com/imdario/mergo) to handle merges. In\nits v0.3.9 release, there was a behavior change that impacts merging template\nfunctions in sprig. It is currently recommended to use v0.3.10 or later of that package.\nUsing v0.3.9 will cause sprig tests to fail.\n\n## Package Versions\n\nThere are two active major versions of the `sprig` package.\n\n* v3 is currently stable release series on the `master` branch. The Go API should\n  remain compatible with v2, the current stable version. Behavior change behind\n  some functions is the reason for the new major version.\n* v2 is the previous stable release series. It has been more than three years since\n  the initial release of v2. You can read the documentation and see the code\n  on the [release-2](https://github.com/Masterminds/sprig/tree/release-2) branch.\n  Bug fixes to this major version will continue for some time.\n\n## Usage\n\n**Template developers**: Please use Sprig's [function documentation](http://masterminds.github.io/sprig/) for\ndetailed instructions and code snippets for the >100 template functions available.\n\n**Go developers**: If you'd like to include Sprig as a library in your program,\nour API documentation is available [at GoDoc.org](http://godoc.org/github.com/Masterminds/sprig).\n\nFor standard usage, read on.\n\n### Load the Sprig library\n\nTo load the Sprig `FuncMap`:\n\n```go\n\nimport (\n  \"github.com/Masterminds/sprig/v3\"\n  \"html/template\"\n)\n\n// This example illustrates that the FuncMap *must* be set before the\n// templates themselves are loaded.\ntpl := template.Must(\n  template.New(\"base\").Funcs(sprig.FuncMap()).ParseGlob(\"*.html\")\n)\n\n\n```\n\n### Calling the functions inside of templates\n\nBy convention, all functions are lowercase. This seems to follow the Go\nidiom for template functions (as opposed to template methods, which are\nTitleCase). For example, this:\n\n```\n{{ \"hello!\" | upper | repeat 5 }}\n```\n\nproduces this:\n\n```\nHELLO!HELLO!HELLO!HELLO!HELLO!\n```\n\n## Principles Driving Our Function Selection\n\nWe followed these principles to decide which functions to add and how to implement them:\n\n- Use template functions to build layout. The following\n  types of operations are within the domain of template functions:\n  - Formatting\n  - Layout\n  - Simple type conversions\n  - Utilities that assist in handling common formatting and layout needs (e.g. arithmetic)\n- Template functions should not return errors unless there is no way to print\n  a sensible value. For example, converting a string to an integer should not\n  produce an error if conversion fails. Instead, it should display a default\n  value.\n- Simple math is necessary for grid layouts, pagers, and so on. Complex math\n  (anything other than arithmetic) should be done outside of templates.\n- Template functions only deal with the data passed into them. They never retrieve\n  data from a source.\n- Finally, do not override core Go template functions.\n"
        },
        {
          "name": "crypto.go",
          "type": "blob",
          "size": 16.7607421875,
          "content": "package sprig\n\nimport (\n\t\"bytes\"\n\t\"crypto\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/dsa\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/asn1\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash/adler32\"\n\t\"io\"\n\t\"math/big\"\n\t\"net\"\n\t\"time\"\n\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n\tbcrypt_lib \"golang.org/x/crypto/bcrypt\"\n\t\"golang.org/x/crypto/scrypt\"\n)\n\nfunc sha512sum(input string) string {\n\thash := sha512.Sum512([]byte(input))\n\treturn hex.EncodeToString(hash[:])\n}\n\nfunc sha256sum(input string) string {\n\thash := sha256.Sum256([]byte(input))\n\treturn hex.EncodeToString(hash[:])\n}\n\nfunc sha1sum(input string) string {\n\thash := sha1.Sum([]byte(input))\n\treturn hex.EncodeToString(hash[:])\n}\n\nfunc adler32sum(input string) string {\n\thash := adler32.Checksum([]byte(input))\n\treturn fmt.Sprintf(\"%d\", hash)\n}\n\nfunc bcrypt(input string) string {\n\thash, err := bcrypt_lib.GenerateFromPassword([]byte(input), bcrypt_lib.DefaultCost)\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"failed to encrypt string with bcrypt: %s\", err)\n\t}\n\n\treturn string(hash)\n}\n\nfunc hashSha(password string) string {\n\ts := sha1.New()\n\ts.Write([]byte(password))\n\tpasswordSum := []byte(s.Sum(nil))\n\treturn base64.StdEncoding.EncodeToString(passwordSum)\n}\n\n// HashAlgorithm enum for hashing algorithms\ntype HashAlgorithm string\n\nconst (\n\t// HashBCrypt bcrypt - recommended\n\tHashBCrypt = \"bcrypt\"\n\tHashSHA    = \"sha\"\n)\n\nfunc htpasswd(username string, password string, hashAlgorithm HashAlgorithm) string {\n\tif strings.Contains(username, \":\") {\n\t\treturn fmt.Sprintf(\"invalid username: %s\", username)\n\t}\n\tswitch hashAlgorithm {\n\tcase HashSHA:\n\t\treturn fmt.Sprintf(\"%s:{SHA}%s\", username, hashSha(password))\n\tdefault:\n\t\treturn fmt.Sprintf(\"%s:%s\", username, bcrypt(password))\n\t}\n}\n\nfunc randBytes(count int) (string, error) {\n\tbuf := make([]byte, count)\n\tif _, err := rand.Read(buf); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.StdEncoding.EncodeToString(buf), nil\n}\n\n// uuidv4 provides a safe and secure UUID v4 implementation\nfunc uuidv4() string {\n\treturn uuid.New().String()\n}\n\nvar masterPasswordSeed = \"com.lyndir.masterpassword\"\n\nvar passwordTypeTemplates = map[string][][]byte{\n\t\"maximum\": {[]byte(\"anoxxxxxxxxxxxxxxxxx\"), []byte(\"axxxxxxxxxxxxxxxxxno\")},\n\t\"long\": {[]byte(\"CvcvnoCvcvCvcv\"), []byte(\"CvcvCvcvnoCvcv\"), []byte(\"CvcvCvcvCvcvno\"), []byte(\"CvccnoCvcvCvcv\"), []byte(\"CvccCvcvnoCvcv\"),\n\t\t[]byte(\"CvccCvcvCvcvno\"), []byte(\"CvcvnoCvccCvcv\"), []byte(\"CvcvCvccnoCvcv\"), []byte(\"CvcvCvccCvcvno\"), []byte(\"CvcvnoCvcvCvcc\"),\n\t\t[]byte(\"CvcvCvcvnoCvcc\"), []byte(\"CvcvCvcvCvccno\"), []byte(\"CvccnoCvccCvcv\"), []byte(\"CvccCvccnoCvcv\"), []byte(\"CvccCvccCvcvno\"),\n\t\t[]byte(\"CvcvnoCvccCvcc\"), []byte(\"CvcvCvccnoCvcc\"), []byte(\"CvcvCvccCvccno\"), []byte(\"CvccnoCvcvCvcc\"), []byte(\"CvccCvcvnoCvcc\"),\n\t\t[]byte(\"CvccCvcvCvccno\")},\n\t\"medium\": {[]byte(\"CvcnoCvc\"), []byte(\"CvcCvcno\")},\n\t\"short\":  {[]byte(\"Cvcn\")},\n\t\"basic\":  {[]byte(\"aaanaaan\"), []byte(\"aannaaan\"), []byte(\"aaannaaa\")},\n\t\"pin\":    {[]byte(\"nnnn\")},\n}\n\nvar templateCharacters = map[byte]string{\n\t'V': \"AEIOU\",\n\t'C': \"BCDFGHJKLMNPQRSTVWXYZ\",\n\t'v': \"aeiou\",\n\t'c': \"bcdfghjklmnpqrstvwxyz\",\n\t'A': \"AEIOUBCDFGHJKLMNPQRSTVWXYZ\",\n\t'a': \"AEIOUaeiouBCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\",\n\t'n': \"0123456789\",\n\t'o': \"@&%?,=[]_:-+*$#!'^~;()/.\",\n\t'x': \"AEIOUaeiouBCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz0123456789!@#$%^&*()\",\n}\n\nfunc derivePassword(counter uint32, passwordType, password, user, site string) string {\n\tvar templates = passwordTypeTemplates[passwordType]\n\tif templates == nil {\n\t\treturn fmt.Sprintf(\"cannot find password template %s\", passwordType)\n\t}\n\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(masterPasswordSeed)\n\tbinary.Write(&buffer, binary.BigEndian, uint32(len(user)))\n\tbuffer.WriteString(user)\n\n\tsalt := buffer.Bytes()\n\tkey, err := scrypt.Key([]byte(password), salt, 32768, 8, 2, 64)\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"failed to derive password: %s\", err)\n\t}\n\n\tbuffer.Truncate(len(masterPasswordSeed))\n\tbinary.Write(&buffer, binary.BigEndian, uint32(len(site)))\n\tbuffer.WriteString(site)\n\tbinary.Write(&buffer, binary.BigEndian, counter)\n\n\tvar hmacv = hmac.New(sha256.New, key)\n\thmacv.Write(buffer.Bytes())\n\tvar seed = hmacv.Sum(nil)\n\tvar temp = templates[int(seed[0])%len(templates)]\n\n\tbuffer.Truncate(0)\n\tfor i, element := range temp {\n\t\tpassChars := templateCharacters[element]\n\t\tpassChar := passChars[int(seed[i+1])%len(passChars)]\n\t\tbuffer.WriteByte(passChar)\n\t}\n\n\treturn buffer.String()\n}\n\nfunc generatePrivateKey(typ string) string {\n\tvar priv interface{}\n\tvar err error\n\tswitch typ {\n\tcase \"\", \"rsa\":\n\t\t// good enough for government work\n\t\tpriv, err = rsa.GenerateKey(rand.Reader, 4096)\n\tcase \"dsa\":\n\t\tkey := new(dsa.PrivateKey)\n\t\t// again, good enough for government work\n\t\tif err = dsa.GenerateParameters(&key.Parameters, rand.Reader, dsa.L2048N256); err != nil {\n\t\t\treturn fmt.Sprintf(\"failed to generate dsa params: %s\", err)\n\t\t}\n\t\terr = dsa.GenerateKey(key, rand.Reader)\n\t\tpriv = key\n\tcase \"ecdsa\":\n\t\t// again, good enough for government work\n\t\tpriv, err = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tcase \"ed25519\":\n\t\t_, priv, err = ed25519.GenerateKey(rand.Reader)\n\tdefault:\n\t\treturn \"Unknown type \" + typ\n\t}\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"failed to generate private key: %s\", err)\n\t}\n\n\treturn string(pem.EncodeToMemory(pemBlockForKey(priv)))\n}\n\n// DSAKeyFormat stores the format for DSA keys.\n// Used by pemBlockForKey\ntype DSAKeyFormat struct {\n\tVersion       int\n\tP, Q, G, Y, X *big.Int\n}\n\nfunc pemBlockForKey(priv interface{}) *pem.Block {\n\tswitch k := priv.(type) {\n\tcase *rsa.PrivateKey:\n\t\treturn &pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(k)}\n\tcase *dsa.PrivateKey:\n\t\tval := DSAKeyFormat{\n\t\t\tP: k.P, Q: k.Q, G: k.G,\n\t\t\tY: k.Y, X: k.X,\n\t\t}\n\t\tbytes, _ := asn1.Marshal(val)\n\t\treturn &pem.Block{Type: \"DSA PRIVATE KEY\", Bytes: bytes}\n\tcase *ecdsa.PrivateKey:\n\t\tb, _ := x509.MarshalECPrivateKey(k)\n\t\treturn &pem.Block{Type: \"EC PRIVATE KEY\", Bytes: b}\n\tdefault:\n\t\t// attempt PKCS#8 format for all other keys\n\t\tb, err := x509.MarshalPKCS8PrivateKey(k)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &pem.Block{Type: \"PRIVATE KEY\", Bytes: b}\n\t}\n}\n\nfunc parsePrivateKeyPEM(pemBlock string) (crypto.PrivateKey, error) {\n\tblock, _ := pem.Decode([]byte(pemBlock))\n\tif block == nil {\n\t\treturn nil, errors.New(\"no PEM data in input\")\n\t}\n\n\tif block.Type == \"PRIVATE KEY\" {\n\t\tpriv, err := x509.ParsePKCS8PrivateKey(block.Bytes)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"decoding PEM as PKCS#8: %s\", err)\n\t\t}\n\t\treturn priv, nil\n\t} else if !strings.HasSuffix(block.Type, \" PRIVATE KEY\") {\n\t\treturn nil, fmt.Errorf(\"no private key data in PEM block of type %s\", block.Type)\n\t}\n\n\tswitch block.Type[:len(block.Type)-12] { // strip \" PRIVATE KEY\"\n\tcase \"RSA\":\n\t\tpriv, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing RSA private key from PEM: %s\", err)\n\t\t}\n\t\treturn priv, nil\n\tcase \"EC\":\n\t\tpriv, err := x509.ParseECPrivateKey(block.Bytes)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing EC private key from PEM: %s\", err)\n\t\t}\n\t\treturn priv, nil\n\tcase \"DSA\":\n\t\tvar k DSAKeyFormat\n\t\t_, err := asn1.Unmarshal(block.Bytes, &k)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing DSA private key from PEM: %s\", err)\n\t\t}\n\t\tpriv := &dsa.PrivateKey{\n\t\t\tPublicKey: dsa.PublicKey{\n\t\t\t\tParameters: dsa.Parameters{\n\t\t\t\t\tP: k.P, Q: k.Q, G: k.G,\n\t\t\t\t},\n\t\t\t\tY: k.Y,\n\t\t\t},\n\t\t\tX: k.X,\n\t\t}\n\t\treturn priv, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"invalid private key type %s\", block.Type)\n\t}\n}\n\nfunc getPublicKey(priv crypto.PrivateKey) (crypto.PublicKey, error) {\n\tswitch k := priv.(type) {\n\tcase interface{ Public() crypto.PublicKey }:\n\t\treturn k.Public(), nil\n\tcase *dsa.PrivateKey:\n\t\treturn &k.PublicKey, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unable to get public key for type %T\", priv)\n\t}\n}\n\ntype certificate struct {\n\tCert string\n\tKey  string\n}\n\nfunc buildCustomCertificate(b64cert string, b64key string) (certificate, error) {\n\tcrt := certificate{}\n\n\tcert, err := base64.StdEncoding.DecodeString(b64cert)\n\tif err != nil {\n\t\treturn crt, errors.New(\"unable to decode base64 certificate\")\n\t}\n\n\tkey, err := base64.StdEncoding.DecodeString(b64key)\n\tif err != nil {\n\t\treturn crt, errors.New(\"unable to decode base64 private key\")\n\t}\n\n\tdecodedCert, _ := pem.Decode(cert)\n\tif decodedCert == nil {\n\t\treturn crt, errors.New(\"unable to decode certificate\")\n\t}\n\t_, err = x509.ParseCertificate(decodedCert.Bytes)\n\tif err != nil {\n\t\treturn crt, fmt.Errorf(\n\t\t\t\"error parsing certificate: decodedCert.Bytes: %s\",\n\t\t\terr,\n\t\t)\n\t}\n\n\t_, err = parsePrivateKeyPEM(string(key))\n\tif err != nil {\n\t\treturn crt, fmt.Errorf(\n\t\t\t\"error parsing private key: %s\",\n\t\t\terr,\n\t\t)\n\t}\n\n\tcrt.Cert = string(cert)\n\tcrt.Key = string(key)\n\n\treturn crt, nil\n}\n\nfunc generateCertificateAuthority(\n\tcn string,\n\tdaysValid int,\n) (certificate, error) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn certificate{}, fmt.Errorf(\"error generating rsa key: %s\", err)\n\t}\n\n\treturn generateCertificateAuthorityWithKeyInternal(cn, daysValid, priv)\n}\n\nfunc generateCertificateAuthorityWithPEMKey(\n\tcn string,\n\tdaysValid int,\n\tprivPEM string,\n) (certificate, error) {\n\tpriv, err := parsePrivateKeyPEM(privPEM)\n\tif err != nil {\n\t\treturn certificate{}, fmt.Errorf(\"parsing private key: %s\", err)\n\t}\n\treturn generateCertificateAuthorityWithKeyInternal(cn, daysValid, priv)\n}\n\nfunc generateCertificateAuthorityWithKeyInternal(\n\tcn string,\n\tdaysValid int,\n\tpriv crypto.PrivateKey,\n) (certificate, error) {\n\tca := certificate{}\n\n\ttemplate, err := getBaseCertTemplate(cn, nil, nil, daysValid)\n\tif err != nil {\n\t\treturn ca, err\n\t}\n\t// Override KeyUsage and IsCA\n\ttemplate.KeyUsage = x509.KeyUsageKeyEncipherment |\n\t\tx509.KeyUsageDigitalSignature |\n\t\tx509.KeyUsageCertSign\n\ttemplate.IsCA = true\n\n\tca.Cert, ca.Key, err = getCertAndKey(template, priv, template, priv)\n\n\treturn ca, err\n}\n\nfunc generateSelfSignedCertificate(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n) (certificate, error) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn certificate{}, fmt.Errorf(\"error generating rsa key: %s\", err)\n\t}\n\treturn generateSelfSignedCertificateWithKeyInternal(cn, ips, alternateDNS, daysValid, priv)\n}\n\nfunc generateSelfSignedCertificateWithPEMKey(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n\tprivPEM string,\n) (certificate, error) {\n\tpriv, err := parsePrivateKeyPEM(privPEM)\n\tif err != nil {\n\t\treturn certificate{}, fmt.Errorf(\"parsing private key: %s\", err)\n\t}\n\treturn generateSelfSignedCertificateWithKeyInternal(cn, ips, alternateDNS, daysValid, priv)\n}\n\nfunc generateSelfSignedCertificateWithKeyInternal(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n\tpriv crypto.PrivateKey,\n) (certificate, error) {\n\tcert := certificate{}\n\n\ttemplate, err := getBaseCertTemplate(cn, ips, alternateDNS, daysValid)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\n\tcert.Cert, cert.Key, err = getCertAndKey(template, priv, template, priv)\n\n\treturn cert, err\n}\n\nfunc generateSignedCertificate(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n\tca certificate,\n) (certificate, error) {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn certificate{}, fmt.Errorf(\"error generating rsa key: %s\", err)\n\t}\n\treturn generateSignedCertificateWithKeyInternal(cn, ips, alternateDNS, daysValid, ca, priv)\n}\n\nfunc generateSignedCertificateWithPEMKey(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n\tca certificate,\n\tprivPEM string,\n) (certificate, error) {\n\tpriv, err := parsePrivateKeyPEM(privPEM)\n\tif err != nil {\n\t\treturn certificate{}, fmt.Errorf(\"parsing private key: %s\", err)\n\t}\n\treturn generateSignedCertificateWithKeyInternal(cn, ips, alternateDNS, daysValid, ca, priv)\n}\n\nfunc generateSignedCertificateWithKeyInternal(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n\tca certificate,\n\tpriv crypto.PrivateKey,\n) (certificate, error) {\n\tcert := certificate{}\n\n\tdecodedSignerCert, _ := pem.Decode([]byte(ca.Cert))\n\tif decodedSignerCert == nil {\n\t\treturn cert, errors.New(\"unable to decode certificate\")\n\t}\n\tsignerCert, err := x509.ParseCertificate(decodedSignerCert.Bytes)\n\tif err != nil {\n\t\treturn cert, fmt.Errorf(\n\t\t\t\"error parsing certificate: decodedSignerCert.Bytes: %s\",\n\t\t\terr,\n\t\t)\n\t}\n\tsignerKey, err := parsePrivateKeyPEM(ca.Key)\n\tif err != nil {\n\t\treturn cert, fmt.Errorf(\n\t\t\t\"error parsing private key: %s\",\n\t\t\terr,\n\t\t)\n\t}\n\n\ttemplate, err := getBaseCertTemplate(cn, ips, alternateDNS, daysValid)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\n\tcert.Cert, cert.Key, err = getCertAndKey(\n\t\ttemplate,\n\t\tpriv,\n\t\tsignerCert,\n\t\tsignerKey,\n\t)\n\n\treturn cert, err\n}\n\nfunc getCertAndKey(\n\ttemplate *x509.Certificate,\n\tsigneeKey crypto.PrivateKey,\n\tparent *x509.Certificate,\n\tsigningKey crypto.PrivateKey,\n) (string, string, error) {\n\tsigneePubKey, err := getPublicKey(signeeKey)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"error retrieving public key from signee key: %s\", err)\n\t}\n\tderBytes, err := x509.CreateCertificate(\n\t\trand.Reader,\n\t\ttemplate,\n\t\tparent,\n\t\tsigneePubKey,\n\t\tsigningKey,\n\t)\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"error creating certificate: %s\", err)\n\t}\n\n\tcertBuffer := bytes.Buffer{}\n\tif err := pem.Encode(\n\t\t&certBuffer,\n\t\t&pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes},\n\t); err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"error pem-encoding certificate: %s\", err)\n\t}\n\n\tkeyBuffer := bytes.Buffer{}\n\tif err := pem.Encode(\n\t\t&keyBuffer,\n\t\tpemBlockForKey(signeeKey),\n\t); err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"error pem-encoding key: %s\", err)\n\t}\n\n\treturn certBuffer.String(), keyBuffer.String(), nil\n}\n\nfunc getBaseCertTemplate(\n\tcn string,\n\tips []interface{},\n\talternateDNS []interface{},\n\tdaysValid int,\n) (*x509.Certificate, error) {\n\tipAddresses, err := getNetIPs(ips)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdnsNames, err := getAlternateDNSStrs(alternateDNS)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tserialNumberUpperBound := new(big.Int).Lsh(big.NewInt(1), 128)\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberUpperBound)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tCommonName: cn,\n\t\t},\n\t\tIPAddresses: ipAddresses,\n\t\tDNSNames:    dnsNames,\n\t\tNotBefore:   time.Now(),\n\t\tNotAfter:    time.Now().Add(time.Hour * 24 * time.Duration(daysValid)),\n\t\tKeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageServerAuth,\n\t\t\tx509.ExtKeyUsageClientAuth,\n\t\t},\n\t\tBasicConstraintsValid: true,\n\t}, nil\n}\n\nfunc getNetIPs(ips []interface{}) ([]net.IP, error) {\n\tif ips == nil {\n\t\treturn []net.IP{}, nil\n\t}\n\tvar ipStr string\n\tvar ok bool\n\tvar netIP net.IP\n\tnetIPs := make([]net.IP, len(ips))\n\tfor i, ip := range ips {\n\t\tipStr, ok = ip.(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"error parsing ip: %v is not a string\", ip)\n\t\t}\n\t\tnetIP = net.ParseIP(ipStr)\n\t\tif netIP == nil {\n\t\t\treturn nil, fmt.Errorf(\"error parsing ip: %s\", ipStr)\n\t\t}\n\t\tnetIPs[i] = netIP\n\t}\n\treturn netIPs, nil\n}\n\nfunc getAlternateDNSStrs(alternateDNS []interface{}) ([]string, error) {\n\tif alternateDNS == nil {\n\t\treturn []string{}, nil\n\t}\n\tvar dnsStr string\n\tvar ok bool\n\talternateDNSStrs := make([]string, len(alternateDNS))\n\tfor i, dns := range alternateDNS {\n\t\tdnsStr, ok = dns.(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\"error processing alternate dns name: %v is not a string\",\n\t\t\t\tdns,\n\t\t\t)\n\t\t}\n\t\talternateDNSStrs[i] = dnsStr\n\t}\n\treturn alternateDNSStrs, nil\n}\n\nfunc encryptAES(password string, plaintext string) (string, error) {\n\tif plaintext == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tkey := make([]byte, 32)\n\tcopy(key, []byte(password))\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcontent := []byte(plaintext)\n\tblockSize := block.BlockSize()\n\tpadding := blockSize - len(content)%blockSize\n\tpadtext := bytes.Repeat([]byte{byte(padding)}, padding)\n\tcontent = append(content, padtext...)\n\n\tciphertext := make([]byte, aes.BlockSize+len(content))\n\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tmode := cipher.NewCBCEncrypter(block, iv)\n\tmode.CryptBlocks(ciphertext[aes.BlockSize:], content)\n\n\treturn base64.StdEncoding.EncodeToString(ciphertext), nil\n}\n\nfunc decryptAES(password string, crypt64 string) (string, error) {\n\tif crypt64 == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tkey := make([]byte, 32)\n\tcopy(key, []byte(password))\n\n\tcrypt, err := base64.StdEncoding.DecodeString(crypt64)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tiv := crypt[:aes.BlockSize]\n\tcrypt = crypt[aes.BlockSize:]\n\tdecrypted := make([]byte, len(crypt))\n\tmode := cipher.NewCBCDecrypter(block, iv)\n\tmode.CryptBlocks(decrypted, crypt)\n\n\treturn string(decrypted[:len(decrypted)-int(decrypted[len(decrypted)-1])]), nil\n}\n"
        },
        {
          "name": "crypto_test.go",
          "type": "blob",
          "size": 10.9287109375,
          "content": "package sprig\n\nimport (\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\tbcrypt_lib \"golang.org/x/crypto/bcrypt\"\n)\n\nconst (\n\tbeginCertificate = \"-----BEGIN CERTIFICATE-----\"\n\tendCertificate   = \"-----END CERTIFICATE-----\"\n)\n\nvar (\n\t// fastCertKeyAlgos is the list of private key algorithms that are supported for certificate use, and\n\t// are fast to generate.\n\tfastCertKeyAlgos = []string{\n\t\t\"ecdsa\",\n\t\t\"ed25519\",\n\t}\n)\n\nfunc TestSha512Sum(t *testing.T) {\n\ttpl := `{{\"abc\" | sha512sum}}`\n\tif err := runt(tpl, \"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSha256Sum(t *testing.T) {\n\ttpl := `{{\"abc\" | sha256sum}}`\n\tif err := runt(tpl, \"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSha1Sum(t *testing.T) {\n\ttpl := `{{\"abc\" | sha1sum}}`\n\tif err := runt(tpl, \"a9993e364706816aba3e25717850c26c9cd0d89d\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAdler32Sum(t *testing.T) {\n\ttpl := `{{\"abc\" | adler32sum}}`\n\tif err := runt(tpl, \"38600999\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestBcrypt(t *testing.T) {\n\tout, err := runRaw(`{{\"abc\" | bcrypt}}`, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif bcrypt_lib.CompareHashAndPassword([]byte(out), []byte(\"abc\")) != nil {\n\t\tt.Error(\"Generated hash is not the equivalent for password:\", \"abc\")\n\t}\n}\n\ntype HtpasswdCred struct {\n\tUsername      string\n\tPassword      string\n\tHashAlgorithm HashAlgorithm\n\tValid         bool\n}\n\nfunc TestHtpasswd(t *testing.T) {\n\texpectations := []HtpasswdCred{\n\t\t{Username: \"myUser\", Password: \"myPassword\", HashAlgorithm: HashBCrypt, Valid: true},\n\t\t{Username: \"special'o79Cv_*qFe,)<user\", Password: \"special<j7+3p#6-.Jx2U:m8G;kGypassword\", HashAlgorithm: HashBCrypt, Valid: true},\n\t\t{Username: \"wrongus:er\", Password: \"doesn'tmatter\", HashAlgorithm: HashBCrypt, Valid: false}, // ':' isn't allowed in the username - https://tools.ietf.org/html/rfc2617#page-6\n\t\t{Username: \"mySahUser\", Password: \"myShaPassword\", HashAlgorithm: HashSHA, Valid: true},\n\t\t{Username: \"myDefaultUser\", Password: \"defaulthashpass\", Valid: true},\n\t}\n\n\tfor _, credential := range expectations {\n\t\tout, err := runRaw(`{{htpasswd .Username .Password .HashAlgorithm}}`, credential)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tresult := strings.Split(out, \":\")\n\t\tif 0 != strings.Compare(credential.Username, result[0]) && credential.Valid {\n\t\t\tt.Error(\"Generated username did not match for:\", credential.Username)\n\t\t}\n\t\tswitch credential.HashAlgorithm {\n\t\tcase HashSHA:\n\t\t\tif strings.TrimPrefix(result[1], \"{SHA}\") != hashSha(credential.Password) {\n\t\t\t\tt.Error(\"Generated hash is not the equivalent for password:\", credential.Password)\n\t\t\t}\n\t\tdefault:\n\t\t\tif bcrypt_lib.CompareHashAndPassword([]byte(result[1]), []byte(credential.Password)) != nil && credential.Valid {\n\t\t\t\tt.Error(\"Generated hash is not the equivalent for password:\", credential.Password)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDerivePassword(t *testing.T) {\n\texpectations := map[string]string{\n\t\t`{{derivePassword 1 \"long\" \"password\" \"user\" \"example.com\"}}`:    \"ZedaFaxcZaso9*\",\n\t\t`{{derivePassword 2 \"long\" \"password\" \"user\" \"example.com\"}}`:    \"Fovi2@JifpTupx\",\n\t\t`{{derivePassword 1 \"maximum\" \"password\" \"user\" \"example.com\"}}`: \"pf4zS1LjCg&LjhsZ7T2~\",\n\t\t`{{derivePassword 1 \"medium\" \"password\" \"user\" \"example.com\"}}`:  \"ZedJuz8$\",\n\t\t`{{derivePassword 1 \"basic\" \"password\" \"user\" \"example.com\"}}`:   \"pIS54PLs\",\n\t\t`{{derivePassword 1 \"short\" \"password\" \"user\" \"example.com\"}}`:   \"Zed5\",\n\t\t`{{derivePassword 1 \"pin\" \"password\" \"user\" \"example.com\"}}`:     \"6685\",\n\t}\n\n\tfor tpl, result := range expectations {\n\t\tout, err := runRaw(tpl, nil)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif 0 != strings.Compare(out, result) {\n\t\t\tt.Error(\"Generated password does not match for\", tpl)\n\t\t}\n\t}\n}\n\n// NOTE(bacongobbler): this test is really _slow_ because of how long it takes to compute\n// and generate a new crypto key.\nfunc TestGenPrivateKey(t *testing.T) {\n\t// test that calling by default generates an RSA private key\n\ttpl := `{{genPrivateKey \"\"}}`\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !strings.Contains(out, \"RSA PRIVATE KEY\") {\n\t\tt.Error(\"Expected RSA PRIVATE KEY\")\n\t}\n\t// test all acceptable arguments\n\ttpl = `{{genPrivateKey \"rsa\"}}`\n\tout, err = runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !strings.Contains(out, \"RSA PRIVATE KEY\") {\n\t\tt.Error(\"Expected RSA PRIVATE KEY\")\n\t}\n\ttpl = `{{genPrivateKey \"dsa\"}}`\n\tout, err = runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !strings.Contains(out, \"DSA PRIVATE KEY\") {\n\t\tt.Error(\"Expected DSA PRIVATE KEY\")\n\t}\n\ttpl = `{{genPrivateKey \"ecdsa\"}}`\n\tout, err = runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !strings.Contains(out, \"EC PRIVATE KEY\") {\n\t\tt.Error(\"Expected EC PRIVATE KEY\")\n\t}\n\ttpl = `{{genPrivateKey \"ed25519\"}}`\n\tout, err = runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !strings.Contains(out, \"PRIVATE KEY\") {\n\t\tt.Error(\"Expected PRIVATE KEY\")\n\t}\n\t// test bad\n\ttpl = `{{genPrivateKey \"bad\"}}`\n\tout, err = runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif out != \"Unknown type bad\" {\n\t\tt.Error(\"Expected type 'bad' to be an unknown crypto algorithm\")\n\t}\n\t// ensure that we can base64 encode the string\n\ttpl = `{{genPrivateKey \"rsa\" | b64enc}}`\n\t_, err = runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestRandBytes(t *testing.T) {\n\ttpl := `{{randBytes 12}}`\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tbytes, err := base64.StdEncoding.DecodeString(out)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif len(bytes) != 12 {\n\t\tt.Error(\"Expected 12 base64-encoded bytes\")\n\t}\n\n\tout2, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif out == out2 {\n\t\tt.Error(\"Expected subsequent randBytes to be different\")\n\t}\n}\n\nfunc TestUUIDGeneration(t *testing.T) {\n\ttpl := `{{uuidv4}}`\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif len(out) != 36 {\n\t\tt.Error(\"Expected UUID of length 36\")\n\t}\n\n\tout2, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif out == out2 {\n\t\tt.Error(\"Expected subsequent UUID generations to be different\")\n\t}\n}\n\nfunc TestBuildCustomCert(t *testing.T) {\n\tca, _ := generateCertificateAuthority(\"example.com\", 365)\n\ttpl := fmt.Sprintf(\n\t\t`{{- $ca := buildCustomCert \"%s\" \"%s\"}}\n{{- $ca.Cert }}`,\n\t\tbase64.StdEncoding.EncodeToString([]byte(ca.Cert)),\n\t\tbase64.StdEncoding.EncodeToString([]byte(ca.Key)),\n\t)\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl2 := fmt.Sprintf(\n\t\t`{{- $ca := buildCustomCert \"%s\" \"%s\"}}\n{{- $ca.Cert }}`,\n\t\tbase64.StdEncoding.EncodeToString([]byte(\"fail\")),\n\t\tbase64.StdEncoding.EncodeToString([]byte(ca.Key)),\n\t)\n\tout2, _ := runRaw(tpl2, nil)\n\n\tassert.Equal(t, out, ca.Cert)\n\tassert.NotEqual(t, out2, ca.Cert)\n}\n\nfunc TestGenCA(t *testing.T) {\n\ttestGenCA(t, nil)\n}\n\nfunc TestGenCAWithKey(t *testing.T) {\n\tfor _, keyAlgo := range fastCertKeyAlgos {\n\t\tt.Run(keyAlgo, func(t *testing.T) {\n\t\t\ttestGenCA(t, &keyAlgo)\n\t\t})\n\t}\n}\n\nfunc testGenCA(t *testing.T, keyAlgo *string) {\n\tconst cn = \"foo-ca\"\n\n\tvar genCAExpr string\n\tif keyAlgo == nil {\n\t\tgenCAExpr = \"genCA\"\n\t} else {\n\t\tgenCAExpr = fmt.Sprintf(`genPrivateKey \"%s\" | genCAWithKey`, *keyAlgo)\n\t}\n\n\ttpl := fmt.Sprintf(\n\t\t`{{- $ca := %s \"%s\" 365 }}\n{{ $ca.Cert }}\n`,\n\t\tgenCAExpr,\n\t\tcn,\n\t)\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tassert.Contains(t, out, beginCertificate)\n\tassert.Contains(t, out, endCertificate)\n\n\tdecodedCert, _ := pem.Decode([]byte(out))\n\tassert.Nil(t, err)\n\tcert, err := x509.ParseCertificate(decodedCert.Bytes)\n\tassert.Nil(t, err)\n\n\tassert.Equal(t, cn, cert.Subject.CommonName)\n\tassert.True(t, cert.IsCA)\n}\n\nfunc TestGenSelfSignedCert(t *testing.T) {\n\ttestGenSelfSignedCert(t, nil)\n}\n\nfunc TestGenSelfSignedCertWithKey(t *testing.T) {\n\tfor _, keyAlgo := range fastCertKeyAlgos {\n\t\tt.Run(keyAlgo, func(t *testing.T) {\n\t\t\ttestGenSelfSignedCert(t, &keyAlgo)\n\t\t})\n\t}\n}\n\nfunc testGenSelfSignedCert(t *testing.T, keyAlgo *string) {\n\tconst (\n\t\tcn   = \"foo.com\"\n\t\tip1  = \"10.0.0.1\"\n\t\tip2  = \"10.0.0.2\"\n\t\tdns1 = \"bar.com\"\n\t\tdns2 = \"bat.com\"\n\t)\n\n\tvar genSelfSignedCertExpr string\n\tif keyAlgo == nil {\n\t\tgenSelfSignedCertExpr = \"genSelfSignedCert\"\n\t} else {\n\t\tgenSelfSignedCertExpr = fmt.Sprintf(`genPrivateKey \"%s\" | genSelfSignedCertWithKey`, *keyAlgo)\n\t}\n\n\ttpl := fmt.Sprintf(\n\t\t`{{- $cert := %s \"%s\" (list \"%s\" \"%s\") (list \"%s\" \"%s\") 365 }}\n{{ $cert.Cert }}`,\n\t\tgenSelfSignedCertExpr,\n\t\tcn,\n\t\tip1,\n\t\tip2,\n\t\tdns1,\n\t\tdns2,\n\t)\n\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tassert.Contains(t, out, beginCertificate)\n\tassert.Contains(t, out, endCertificate)\n\n\tdecodedCert, _ := pem.Decode([]byte(out))\n\tassert.Nil(t, err)\n\tcert, err := x509.ParseCertificate(decodedCert.Bytes)\n\tassert.Nil(t, err)\n\n\tassert.Equal(t, cn, cert.Subject.CommonName)\n\tassert.Equal(t, 1, cert.SerialNumber.Sign())\n\tassert.Equal(t, 2, len(cert.IPAddresses))\n\tassert.Equal(t, ip1, cert.IPAddresses[0].String())\n\tassert.Equal(t, ip2, cert.IPAddresses[1].String())\n\tassert.Contains(t, cert.DNSNames, dns1)\n\tassert.Contains(t, cert.DNSNames, dns2)\n\tassert.False(t, cert.IsCA)\n}\n\nfunc TestGenSignedCert(t *testing.T) {\n\ttestGenSignedCert(t, nil, nil)\n}\n\nfunc TestGenSignedCertWithKey(t *testing.T) {\n\tfor _, caKeyAlgo := range fastCertKeyAlgos {\n\t\tfor _, certKeyAlgo := range fastCertKeyAlgos {\n\t\t\tt.Run(fmt.Sprintf(\"%s-%s\", caKeyAlgo, certKeyAlgo), func(t *testing.T) {\n\t\t\t\ttestGenSignedCert(t, &caKeyAlgo, &certKeyAlgo)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc testGenSignedCert(t *testing.T, caKeyAlgo, certKeyAlgo *string) {\n\tconst (\n\t\tcn   = \"foo.com\"\n\t\tip1  = \"10.0.0.1\"\n\t\tip2  = \"10.0.0.2\"\n\t\tdns1 = \"bar.com\"\n\t\tdns2 = \"bat.com\"\n\t)\n\n\tvar genCAExpr, genSignedCertExpr string\n\tif caKeyAlgo == nil {\n\t\tgenCAExpr = \"genCA\"\n\t} else {\n\t\tgenCAExpr = fmt.Sprintf(`genPrivateKey \"%s\" | genCAWithKey`, *caKeyAlgo)\n\t}\n\tif certKeyAlgo == nil {\n\t\tgenSignedCertExpr = \"genSignedCert\"\n\t} else {\n\t\tgenSignedCertExpr = fmt.Sprintf(`genPrivateKey \"%s\" | genSignedCertWithKey`, *certKeyAlgo)\n\t}\n\n\ttpl := fmt.Sprintf(\n\t\t`{{- $ca := %s \"foo\" 365 }}\n{{- $cert := %s \"%s\" (list \"%s\" \"%s\") (list \"%s\" \"%s\") 365 $ca }}\n{{ $cert.Cert }}\n`,\n\t\tgenCAExpr,\n\t\tgenSignedCertExpr,\n\t\tcn,\n\t\tip1,\n\t\tip2,\n\t\tdns1,\n\t\tdns2,\n\t)\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tassert.Contains(t, out, beginCertificate)\n\tassert.Contains(t, out, endCertificate)\n\n\tdecodedCert, _ := pem.Decode([]byte(out))\n\tassert.Nil(t, err)\n\tcert, err := x509.ParseCertificate(decodedCert.Bytes)\n\tassert.Nil(t, err)\n\n\tassert.Equal(t, cn, cert.Subject.CommonName)\n\tassert.Equal(t, 1, cert.SerialNumber.Sign())\n\tassert.Equal(t, 2, len(cert.IPAddresses))\n\tassert.Equal(t, ip1, cert.IPAddresses[0].String())\n\tassert.Equal(t, ip2, cert.IPAddresses[1].String())\n\tassert.Contains(t, cert.DNSNames, dns1)\n\tassert.Contains(t, cert.DNSNames, dns2)\n\tassert.False(t, cert.IsCA)\n}\n\nfunc TestEncryptDecryptAES(t *testing.T) {\n\ttpl := `{{\"plaintext\" | encryptAES \"secretkey\" | decryptAES \"secretkey\"}}`\n\tif err := runt(tpl, \"plaintext\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "date.go",
          "type": "blob",
          "size": 3.0439453125,
          "content": "package sprig\n\nimport (\n\t\"strconv\"\n\t\"time\"\n)\n\n// Given a format and a date, format the date string.\n//\n// Date can be a `time.Time` or an `int, int32, int64`.\n// In the later case, it is treated as seconds since UNIX\n// epoch.\nfunc date(fmt string, date interface{}) string {\n\treturn dateInZone(fmt, date, \"Local\")\n}\n\nfunc htmlDate(date interface{}) string {\n\treturn dateInZone(\"2006-01-02\", date, \"Local\")\n}\n\nfunc htmlDateInZone(date interface{}, zone string) string {\n\treturn dateInZone(\"2006-01-02\", date, zone)\n}\n\nfunc dateInZone(fmt string, date interface{}, zone string) string {\n\tvar t time.Time\n\tswitch date := date.(type) {\n\tdefault:\n\t\tt = time.Now()\n\tcase time.Time:\n\t\tt = date\n\tcase *time.Time:\n\t\tt = *date\n\tcase int64:\n\t\tt = time.Unix(date, 0)\n\tcase int:\n\t\tt = time.Unix(int64(date), 0)\n\tcase int32:\n\t\tt = time.Unix(int64(date), 0)\n\t}\n\n\tloc, err := time.LoadLocation(zone)\n\tif err != nil {\n\t\tloc, _ = time.LoadLocation(\"UTC\")\n\t}\n\n\treturn t.In(loc).Format(fmt)\n}\n\nfunc dateModify(fmt string, date time.Time) time.Time {\n\td, err := time.ParseDuration(fmt)\n\tif err != nil {\n\t\treturn date\n\t}\n\treturn date.Add(d)\n}\n\nfunc mustDateModify(fmt string, date time.Time) (time.Time, error) {\n\td, err := time.ParseDuration(fmt)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\treturn date.Add(d), nil\n}\n\nfunc dateAgo(date interface{}) string {\n\tvar t time.Time\n\n\tswitch date := date.(type) {\n\tdefault:\n\t\tt = time.Now()\n\tcase time.Time:\n\t\tt = date\n\tcase int64:\n\t\tt = time.Unix(date, 0)\n\tcase int:\n\t\tt = time.Unix(int64(date), 0)\n\t}\n\t// Drop resolution to seconds\n\tduration := time.Since(t).Round(time.Second)\n\treturn duration.String()\n}\n\nfunc duration(sec interface{}) string {\n\tvar n int64\n\tswitch value := sec.(type) {\n\tdefault:\n\t\tn = 0\n\tcase string:\n\t\tn, _ = strconv.ParseInt(value, 10, 64)\n\tcase int64:\n\t\tn = value\n\t}\n\treturn (time.Duration(n) * time.Second).String()\n}\n\nfunc durationRound(duration interface{}) string {\n\tvar d time.Duration\n\tswitch duration := duration.(type) {\n\tdefault:\n\t\td = 0\n\tcase string:\n\t\td, _ = time.ParseDuration(duration)\n\tcase int64:\n\t\td = time.Duration(duration)\n\tcase time.Time:\n\t\td = time.Since(duration)\n\t}\n\n\tu := uint64(d)\n\tneg := d < 0\n\tif neg {\n\t\tu = -u\n\t}\n\n\tvar (\n\t\tyear   = uint64(time.Hour) * 24 * 365\n\t\tmonth  = uint64(time.Hour) * 24 * 30\n\t\tday    = uint64(time.Hour) * 24\n\t\thour   = uint64(time.Hour)\n\t\tminute = uint64(time.Minute)\n\t\tsecond = uint64(time.Second)\n\t)\n\tswitch {\n\tcase u > year:\n\t\treturn strconv.FormatUint(u/year, 10) + \"y\"\n\tcase u > month:\n\t\treturn strconv.FormatUint(u/month, 10) + \"mo\"\n\tcase u > day:\n\t\treturn strconv.FormatUint(u/day, 10) + \"d\"\n\tcase u > hour:\n\t\treturn strconv.FormatUint(u/hour, 10) + \"h\"\n\tcase u > minute:\n\t\treturn strconv.FormatUint(u/minute, 10) + \"m\"\n\tcase u > second:\n\t\treturn strconv.FormatUint(u/second, 10) + \"s\"\n\t}\n\treturn \"0s\"\n}\n\nfunc toDate(fmt, str string) time.Time {\n\tt, _ := time.ParseInLocation(fmt, str, time.Local)\n\treturn t\n}\n\nfunc mustToDate(fmt, str string) (time.Time, error) {\n\treturn time.ParseInLocation(fmt, str, time.Local)\n}\n\nfunc unixEpoch(date time.Time) string {\n\treturn strconv.FormatInt(date.Unix(), 10)\n}\n"
        },
        {
          "name": "date_test.go",
          "type": "blob",
          "size": 3.2841796875,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestHtmlDate(t *testing.T) {\n\tt.Skip()\n\ttpl := `{{ htmlDate 0}}`\n\tif err := runt(tpl, \"1970-01-01\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAgo(t *testing.T) {\n\ttpl := \"{{ ago .Time }}\"\n\tif err := runtv(tpl, \"2m5s\", map[string]interface{}{\"Time\": time.Now().Add(-125 * time.Second)}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif err := runtv(tpl, \"2h34m17s\", map[string]interface{}{\"Time\": time.Now().Add(-(2*3600 + 34*60 + 17) * time.Second)}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif err := runtv(tpl, \"-5s\", map[string]interface{}{\"Time\": time.Now().Add(5 * time.Second)}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestToDate(t *testing.T) {\n\ttpl := `{{toDate \"2006-01-02\" \"2017-12-31\" | date \"02/01/2006\"}}`\n\tif err := runt(tpl, \"31/12/2017\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestUnixEpoch(t *testing.T) {\n\ttm, err := time.Parse(\"02 Jan 06 15:04:05 MST\", \"13 Jun 19 20:39:39 GMT\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl := `{{unixEpoch .Time}}`\n\n\tif err = runtv(tpl, \"1560458379\", map[string]interface{}{\"Time\": tm}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDateInZone(t *testing.T) {\n\ttm, err := time.Parse(\"02 Jan 06 15:04:05 MST\", \"13 Jun 19 20:39:39 GMT\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl := `{{ date_in_zone \"02 Jan 06 15:04 -0700\" .Time \"UTC\" }}`\n\n\t// Test time.Time input\n\tif err = runtv(tpl, \"13 Jun 19 20:39 +0000\", map[string]interface{}{\"Time\": tm}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Test pointer to time.Time input\n\tif err = runtv(tpl, \"13 Jun 19 20:39 +0000\", map[string]interface{}{\"Time\": &tm}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Test no time input. This should be close enough to time.Now() we can test\n\tloc, _ := time.LoadLocation(\"UTC\")\n\tif err = runtv(tpl, time.Now().In(loc).Format(\"02 Jan 06 15:04 -0700\"), map[string]interface{}{\"Time\": \"\"}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Test unix timestamp as int64\n\tif err = runtv(tpl, \"13 Jun 19 20:39 +0000\", map[string]interface{}{\"Time\": int64(1560458379)}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Test unix timestamp as int32\n\tif err = runtv(tpl, \"13 Jun 19 20:39 +0000\", map[string]interface{}{\"Time\": int32(1560458379)}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Test unix timestamp as int\n\tif err = runtv(tpl, \"13 Jun 19 20:39 +0000\", map[string]interface{}{\"Time\": int(1560458379)}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Test case of invalid timezone\n\ttpl = `{{ date_in_zone \"02 Jan 06 15:04 -0700\" .Time \"foobar\" }}`\n\tif err = runtv(tpl, \"13 Jun 19 20:39 +0000\", map[string]interface{}{\"Time\": tm}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDuration(t *testing.T) {\n\ttpl := \"{{ duration .Secs }}\"\n\tif err := runtv(tpl, \"1m1s\", map[string]interface{}{\"Secs\": \"61\"}); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := runtv(tpl, \"1h0m0s\", map[string]interface{}{\"Secs\": \"3600\"}); err != nil {\n\t\tt.Error(err)\n\t}\n\t// 1d2h3m4s but go is opinionated\n\tif err := runtv(tpl, \"26h3m4s\", map[string]interface{}{\"Secs\": \"93784\"}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDurationRound(t *testing.T) {\n\ttpl := \"{{ durationRound .Time }}\"\n\tif err := runtv(tpl, \"2h\", map[string]interface{}{\"Time\": \"2h5s\"}); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := runtv(tpl, \"1d\", map[string]interface{}{\"Time\": \"24h5s\"}); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := runtv(tpl, \"3mo\", map[string]interface{}{\"Time\": \"2400h5s\"}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "defaults.go",
          "type": "blob",
          "size": 3.7705078125,
          "content": "package sprig\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc init() {\n\trand.Seed(time.Now().UnixNano())\n}\n\n// dfault checks whether `given` is set, and returns default if not set.\n//\n// This returns `d` if `given` appears not to be set, and `given` otherwise.\n//\n// For numeric types 0 is unset.\n// For strings, maps, arrays, and slices, len() = 0 is considered unset.\n// For bool, false is unset.\n// Structs are never considered unset.\n//\n// For everything else, including pointers, a nil value is unset.\nfunc dfault(d interface{}, given ...interface{}) interface{} {\n\n\tif empty(given) || empty(given[0]) {\n\t\treturn d\n\t}\n\treturn given[0]\n}\n\n// empty returns true if the given value has the zero value for its type.\nfunc empty(given interface{}) bool {\n\tg := reflect.ValueOf(given)\n\tif !g.IsValid() {\n\t\treturn true\n\t}\n\n\t// Basically adapted from text/template.isTrue\n\tswitch g.Kind() {\n\tdefault:\n\t\treturn g.IsNil()\n\tcase reflect.Array, reflect.Slice, reflect.Map, reflect.String:\n\t\treturn g.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !g.Bool()\n\tcase reflect.Complex64, reflect.Complex128:\n\t\treturn g.Complex() == 0\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn g.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn g.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn g.Float() == 0\n\tcase reflect.Struct:\n\t\treturn false\n\t}\n}\n\n// coalesce returns the first non-empty value.\nfunc coalesce(v ...interface{}) interface{} {\n\tfor _, val := range v {\n\t\tif !empty(val) {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn nil\n}\n\n// all returns true if empty(x) is false for all values x in the list.\n// If the list is empty, return true.\nfunc all(v ...interface{}) bool {\n\tfor _, val := range v {\n\t\tif empty(val) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// any returns true if empty(x) is false for any x in the list.\n// If the list is empty, return false.\nfunc any(v ...interface{}) bool {\n\tfor _, val := range v {\n\t\tif !empty(val) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// fromJson decodes JSON into a structured value, ignoring errors.\nfunc fromJson(v string) interface{} {\n\toutput, _ := mustFromJson(v)\n\treturn output\n}\n\n// mustFromJson decodes JSON into a structured value, returning errors.\nfunc mustFromJson(v string) (interface{}, error) {\n\tvar output interface{}\n\terr := json.Unmarshal([]byte(v), &output)\n\treturn output, err\n}\n\n// toJson encodes an item into a JSON string\nfunc toJson(v interface{}) string {\n\toutput, _ := json.Marshal(v)\n\treturn string(output)\n}\n\nfunc mustToJson(v interface{}) (string, error) {\n\toutput, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(output), nil\n}\n\n// toPrettyJson encodes an item into a pretty (indented) JSON string\nfunc toPrettyJson(v interface{}) string {\n\toutput, _ := json.MarshalIndent(v, \"\", \"  \")\n\treturn string(output)\n}\n\nfunc mustToPrettyJson(v interface{}) (string, error) {\n\toutput, err := json.MarshalIndent(v, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(output), nil\n}\n\n// toRawJson encodes an item into a JSON string with no escaping of HTML characters.\nfunc toRawJson(v interface{}) string {\n\toutput, err := mustToRawJson(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn string(output)\n}\n\n// mustToRawJson encodes an item into a JSON string with no escaping of HTML characters.\nfunc mustToRawJson(v interface{}) (string, error) {\n\tbuf := new(bytes.Buffer)\n\tenc := json.NewEncoder(buf)\n\tenc.SetEscapeHTML(false)\n\terr := enc.Encode(&v)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn strings.TrimSuffix(buf.String(), \"\\n\"), nil\n}\n\n// ternary returns the first value if the last value is true, otherwise returns the second value.\nfunc ternary(vt interface{}, vf interface{}, v bool) interface{} {\n\tif v {\n\t\treturn vt\n\t}\n\n\treturn vf\n}\n"
        },
        {
          "name": "defaults_test.go",
          "type": "blob",
          "size": 5.0478515625,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDefault(t *testing.T) {\n\ttpl := `{{\"\" | default \"foo\"}}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{default \"foo\" 234}}`\n\tif err := runt(tpl, \"234\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{default \"foo\" 2.34}}`\n\tif err := runt(tpl, \"2.34\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ .Nothing | default \"123\" }}`\n\tif err := runt(tpl, \"123\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ default \"123\" }}`\n\tif err := runt(tpl, \"123\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestEmpty(t *testing.T) {\n\ttpl := `{{if empty 1}}1{{else}}0{{end}}`\n\tif err := runt(tpl, \"0\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{if empty 0}}1{{else}}0{{end}}`\n\tif err := runt(tpl, \"1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{if empty \"\"}}1{{else}}0{{end}}`\n\tif err := runt(tpl, \"1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{if empty 0.0}}1{{else}}0{{end}}`\n\tif err := runt(tpl, \"1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{if empty false}}1{{else}}0{{end}}`\n\tif err := runt(tpl, \"1\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdict := map[string]interface{}{\"top\": map[string]interface{}{}}\n\ttpl = `{{if empty .top.NoSuchThing}}1{{else}}0{{end}}`\n\tif err := runtv(tpl, \"1\", dict); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{if empty .bottom.NoSuchThing}}1{{else}}0{{end}}`\n\tif err := runtv(tpl, \"1\", dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestCoalesce(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ coalesce 1 }}`:                            \"1\",\n\t\t`{{ coalesce \"\" 0 nil 2 }}`:                   \"2\",\n\t\t`{{ $two := 2 }}{{ coalesce \"\" 0 nil $two }}`: \"2\",\n\t\t`{{ $two := 2 }}{{ coalesce \"\" $two 0 0 0 }}`: \"2\",\n\t\t`{{ $two := 2 }}{{ coalesce \"\" $two 3 4 5 }}`: \"2\",\n\t\t`{{ coalesce }}`:                              \"<no value>\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n\n\tdict := map[string]interface{}{\"top\": map[string]interface{}{}}\n\ttpl := `{{ coalesce .top.NoSuchThing .bottom .bottom.dollar \"airplane\"}}`\n\tif err := runtv(tpl, \"airplane\", dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAll(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ all 1 }}`:                            \"true\",\n\t\t`{{ all \"\" 0 nil 2 }}`:                   \"false\",\n\t\t`{{ $two := 2 }}{{ all \"\" 0 nil $two }}`: \"false\",\n\t\t`{{ $two := 2 }}{{ all \"\" $two 0 0 0 }}`: \"false\",\n\t\t`{{ $two := 2 }}{{ all \"\" $two 3 4 5 }}`: \"false\",\n\t\t`{{ all }}`:                              \"true\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n\n\tdict := map[string]interface{}{\"top\": map[string]interface{}{}}\n\ttpl := `{{ all .top.NoSuchThing .bottom .bottom.dollar \"airplane\"}}`\n\tif err := runtv(tpl, \"false\", dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAny(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ any 1 }}`:                              \"true\",\n\t\t`{{ any \"\" 0 nil 2 }}`:                     \"true\",\n\t\t`{{ $two := 2 }}{{ any \"\" 0 nil $two }}`:   \"true\",\n\t\t`{{ $two := 2 }}{{ any \"\" $two 3 4 5 }}`:   \"true\",\n\t\t`{{ $zero := 0 }}{{ any \"\" $zero 0 0 0 }}`: \"false\",\n\t\t`{{ any }}`: \"false\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n\n\tdict := map[string]interface{}{\"top\": map[string]interface{}{}}\n\ttpl := `{{ any .top.NoSuchThing .bottom .bottom.dollar \"airplane\"}}`\n\tif err := runtv(tpl, \"true\", dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestFromJson(t *testing.T) {\n\tdict := map[string]interface{}{\"Input\": `{\"foo\": 55}`}\n\n\ttpl := `{{.Input | fromJson}}`\n\texpected := `map[foo:55]`\n\tif err := runtv(tpl, expected, dict); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{(.Input | fromJson).foo}}`\n\texpected = `55`\n\tif err := runtv(tpl, expected, dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestToJson(t *testing.T) {\n\tdict := map[string]interface{}{\"Top\": map[string]interface{}{\"bool\": true, \"string\": \"test\", \"number\": 42}}\n\n\ttpl := `{{.Top | toJson}}`\n\texpected := `{\"bool\":true,\"number\":42,\"string\":\"test\"}`\n\tif err := runtv(tpl, expected, dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestToPrettyJson(t *testing.T) {\n\tdict := map[string]interface{}{\"Top\": map[string]interface{}{\"bool\": true, \"string\": \"test\", \"number\": 42}}\n\ttpl := `{{.Top | toPrettyJson}}`\n\texpected := `{\n  \"bool\": true,\n  \"number\": 42,\n  \"string\": \"test\"\n}`\n\tif err := runtv(tpl, expected, dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestToRawJson(t *testing.T) {\n\tdict := map[string]interface{}{\"Top\": map[string]interface{}{\"bool\": true, \"string\": \"test\", \"number\": 42, \"html\": \"<HEAD>\"}}\n\ttpl := `{{.Top | toRawJson}}`\n\texpected := `{\"bool\":true,\"html\":\"<HEAD>\",\"number\":42,\"string\":\"test\"}`\n\n\tif err := runtv(tpl, expected, dict); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTernary(t *testing.T) {\n\ttpl := `{{true | ternary \"foo\" \"bar\"}}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ternary \"foo\" \"bar\" true}}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{false | ternary \"foo\" \"bar\"}}`\n\tif err := runt(tpl, \"bar\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ternary \"foo\" \"bar\" false}}`\n\tif err := runt(tpl, \"bar\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "dict.go",
          "type": "blob",
          "size": 3.5146484375,
          "content": "package sprig\n\nimport (\n\t\"dario.cat/mergo\"\n\t\"github.com/mitchellh/copystructure\"\n)\n\nfunc get(d map[string]interface{}, key string) interface{} {\n\tif val, ok := d[key]; ok {\n\t\treturn val\n\t}\n\treturn \"\"\n}\n\nfunc set(d map[string]interface{}, key string, value interface{}) map[string]interface{} {\n\td[key] = value\n\treturn d\n}\n\nfunc unset(d map[string]interface{}, key string) map[string]interface{} {\n\tdelete(d, key)\n\treturn d\n}\n\nfunc hasKey(d map[string]interface{}, key string) bool {\n\t_, ok := d[key]\n\treturn ok\n}\n\nfunc pluck(key string, d ...map[string]interface{}) []interface{} {\n\tres := []interface{}{}\n\tfor _, dict := range d {\n\t\tif val, ok := dict[key]; ok {\n\t\t\tres = append(res, val)\n\t\t}\n\t}\n\treturn res\n}\n\nfunc keys(dicts ...map[string]interface{}) []string {\n\tk := []string{}\n\tfor _, dict := range dicts {\n\t\tfor key := range dict {\n\t\t\tk = append(k, key)\n\t\t}\n\t}\n\treturn k\n}\n\nfunc pick(dict map[string]interface{}, keys ...string) map[string]interface{} {\n\tres := map[string]interface{}{}\n\tfor _, k := range keys {\n\t\tif v, ok := dict[k]; ok {\n\t\t\tres[k] = v\n\t\t}\n\t}\n\treturn res\n}\n\nfunc omit(dict map[string]interface{}, keys ...string) map[string]interface{} {\n\tres := map[string]interface{}{}\n\n\tomit := make(map[string]bool, len(keys))\n\tfor _, k := range keys {\n\t\tomit[k] = true\n\t}\n\n\tfor k, v := range dict {\n\t\tif _, ok := omit[k]; !ok {\n\t\t\tres[k] = v\n\t\t}\n\t}\n\treturn res\n}\n\nfunc dict(v ...interface{}) map[string]interface{} {\n\tdict := map[string]interface{}{}\n\tlenv := len(v)\n\tfor i := 0; i < lenv; i += 2 {\n\t\tkey := strval(v[i])\n\t\tif i+1 >= lenv {\n\t\t\tdict[key] = \"\"\n\t\t\tcontinue\n\t\t}\n\t\tdict[key] = v[i+1]\n\t}\n\treturn dict\n}\n\nfunc merge(dst map[string]interface{}, srcs ...map[string]interface{}) interface{} {\n\tfor _, src := range srcs {\n\t\tif err := mergo.Merge(&dst, src); err != nil {\n\t\t\t// Swallow errors inside of a template.\n\t\t\treturn \"\"\n\t\t}\n\t}\n\treturn dst\n}\n\nfunc mustMerge(dst map[string]interface{}, srcs ...map[string]interface{}) (interface{}, error) {\n\tfor _, src := range srcs {\n\t\tif err := mergo.Merge(&dst, src); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn dst, nil\n}\n\nfunc mergeOverwrite(dst map[string]interface{}, srcs ...map[string]interface{}) interface{} {\n\tfor _, src := range srcs {\n\t\tif err := mergo.MergeWithOverwrite(&dst, src); err != nil {\n\t\t\t// Swallow errors inside of a template.\n\t\t\treturn \"\"\n\t\t}\n\t}\n\treturn dst\n}\n\nfunc mustMergeOverwrite(dst map[string]interface{}, srcs ...map[string]interface{}) (interface{}, error) {\n\tfor _, src := range srcs {\n\t\tif err := mergo.MergeWithOverwrite(&dst, src); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn dst, nil\n}\n\nfunc values(dict map[string]interface{}) []interface{} {\n\tvalues := []interface{}{}\n\tfor _, value := range dict {\n\t\tvalues = append(values, value)\n\t}\n\n\treturn values\n}\n\nfunc deepCopy(i interface{}) interface{} {\n\tc, err := mustDeepCopy(i)\n\tif err != nil {\n\t\tpanic(\"deepCopy error: \" + err.Error())\n\t}\n\n\treturn c\n}\n\nfunc mustDeepCopy(i interface{}) (interface{}, error) {\n\treturn copystructure.Copy(i)\n}\n\nfunc dig(ps ...interface{}) (interface{}, error) {\n\tif len(ps) < 3 {\n\t\tpanic(\"dig needs at least three arguments\")\n\t}\n\tdict := ps[len(ps)-1].(map[string]interface{})\n\tdef := ps[len(ps)-2]\n\tks := make([]string, len(ps)-2)\n\tfor i := 0; i < len(ks); i++ {\n\t\tks[i] = ps[i].(string)\n\t}\n\n\treturn digFromDict(dict, def, ks)\n}\n\nfunc digFromDict(dict map[string]interface{}, d interface{}, ks []string) (interface{}, error) {\n\tk, ns := ks[0], ks[1:len(ks)]\n\tstep, has := dict[k]\n\tif !has {\n\t\treturn d, nil\n\t}\n\tif len(ns) == 0 {\n\t\treturn step, nil\n\t}\n\treturn digFromDict(step.(map[string]interface{}), d, ns)\n}\n"
        },
        {
          "name": "dict_test.go",
          "type": "blob",
          "size": 7.900390625,
          "content": "package sprig\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDict(t *testing.T) {\n\ttpl := `{{$d := dict 1 2 \"three\" \"four\" 5}}{{range $k, $v := $d}}{{$k}}{{$v}}{{end}}`\n\tout, err := runRaw(tpl, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif len(out) != 12 {\n\t\tt.Errorf(\"Expected length 12, got %d\", len(out))\n\t}\n\t// dict does not guarantee ordering because it is backed by a map.\n\tif !strings.Contains(out, \"12\") {\n\t\tt.Error(\"Expected grouping 12\")\n\t}\n\tif !strings.Contains(out, \"threefour\") {\n\t\tt.Error(\"Expected grouping threefour\")\n\t}\n\tif !strings.Contains(out, \"5\") {\n\t\tt.Error(\"Expected 5\")\n\t}\n\ttpl = `{{$t := dict \"I\" \"shot\" \"the\" \"albatross\"}}{{$t.the}} {{$t.I}}`\n\tif err := runt(tpl, \"albatross shot\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestUnset(t *testing.T) {\n\ttpl := `{{- $d := dict \"one\" 1 \"two\" 222222 -}}\n\t{{- $_ := unset $d \"two\" -}}\n\t{{- range $k, $v := $d}}{{$k}}{{$v}}{{- end -}}\n\t`\n\n\texpect := \"one1\"\n\tif err := runt(tpl, expect); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestHasKey(t *testing.T) {\n\ttpl := `{{- $d := dict \"one\" 1 \"two\" 222222 -}}\n\t{{- if hasKey $d \"one\" -}}1{{- end -}}\n\t`\n\n\texpect := \"1\"\n\tif err := runt(tpl, expect); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestPluck(t *testing.T) {\n\ttpl := `\n\t{{- $d := dict \"one\" 1 \"two\" 222222 -}}\n\t{{- $d2 := dict \"one\" 1 \"two\" 33333 -}}\n\t{{- $d3 := dict \"one\" 1 -}}\n\t{{- $d4 := dict \"one\" 1 \"two\" 4444 -}}\n\t{{- pluck \"two\" $d $d2 $d3 $d4 -}}\n\t`\n\n\texpect := \"[222222 33333 4444]\"\n\tif err := runt(tpl, expect); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestKeys(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ dict \"foo\" 1 \"bar\" 2 | keys | sortAlpha }}`: \"[bar foo]\",\n\t\t`{{ dict | keys }}`:                             \"[]\",\n\t\t`{{ keys (dict \"foo\" 1) (dict \"bar\" 2) (dict \"bar\" 3) | uniq | sortAlpha }}`: \"[bar foo]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestPick(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ pick $d \"two\" | len -}}`:               \"1\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ pick $d \"two\" -}}`:                     \"map[two:222222]\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ pick $d \"one\" \"two\" | len -}}`:         \"2\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ pick $d \"one\" \"two\" \"three\" | len -}}`: \"2\",\n\t\t`{{- $d := dict }}{{ pick $d \"two\" | len -}}`:                                    \"0\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\nfunc TestOmit(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ omit $d \"one\" | len -}}`:         \"1\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ omit $d \"one\" -}}`:               \"map[two:222222]\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ omit $d \"one\" \"two\" | len -}}`:   \"0\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" 222222 }}{{ omit $d \"two\" \"three\" | len -}}`: \"1\",\n\t\t`{{- $d := dict }}{{ omit $d \"two\" | len -}}`:                              \"0\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"one\" 1 }}{{ get $d \"one\" -}}`:           \"1\",\n\t\t`{{- $d := dict \"one\" 1 \"two\" \"2\" }}{{ get $d \"two\" -}}`: \"2\",\n\t\t`{{- $d := dict }}{{ get $d \"two\" -}}`:                   \"\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestSet(t *testing.T) {\n\ttpl := `{{- $d := dict \"one\" 1 \"two\" 222222 -}}\n\t{{- $_ := set $d \"two\" 2 -}}\n\t{{- $_ := set $d \"three\" 3 -}}\n\t{{- if hasKey $d \"one\" -}}{{$d.one}}{{- end -}}\n\t{{- if hasKey $d \"two\" -}}{{$d.two}}{{- end -}}\n\t{{- if hasKey $d \"three\" -}}{{$d.three}}{{- end -}}\n\t`\n\n\texpect := \"123\"\n\tif err := runt(tpl, expect); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestMerge(t *testing.T) {\n\tdict := map[string]interface{}{\n\t\t\"src2\": map[string]interface{}{\n\t\t\t\"h\": 10,\n\t\t\t\"i\": \"i\",\n\t\t\t\"j\": \"j\",\n\t\t},\n\t\t\"src1\": map[string]interface{}{\n\t\t\t\"a\": 1,\n\t\t\t\"b\": 2,\n\t\t\t\"d\": map[string]interface{}{\n\t\t\t\t\"e\": \"four\",\n\t\t\t},\n\t\t\t\"g\": []int{6, 7},\n\t\t\t\"i\": \"aye\",\n\t\t\t\"j\": \"jay\",\n\t\t\t\"k\": map[string]interface{}{\n\t\t\t\t\"l\": false,\n\t\t\t},\n\t\t},\n\t\t\"dst\": map[string]interface{}{\n\t\t\t\"a\": \"one\",\n\t\t\t\"c\": 3,\n\t\t\t\"d\": map[string]interface{}{\n\t\t\t\t\"f\": 5,\n\t\t\t},\n\t\t\t\"g\": []int{8, 9},\n\t\t\t\"i\": \"eye\",\n\t\t\t\"k\": map[string]interface{}{\n\t\t\t\t\"l\": true,\n\t\t\t},\n\t\t},\n\t}\n\ttpl := `{{merge .dst .src1 .src2}}`\n\t_, err := runRaw(tpl, dict)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\texpected := map[string]interface{}{\n\t\t\"a\": \"one\", // key overridden\n\t\t\"b\": 2,     // merged from src1\n\t\t\"c\": 3,     // merged from dst\n\t\t\"d\": map[string]interface{}{ // deep merge\n\t\t\t\"e\": \"four\",\n\t\t\t\"f\": 5,\n\t\t},\n\t\t\"g\": []int{8, 9}, // overridden - arrays are not merged\n\t\t\"h\": 10,          // merged from src2\n\t\t\"i\": \"eye\",       // overridden twice\n\t\t\"j\": \"jay\",       // overridden and merged\n\t\t\"k\": map[string]interface{}{\n\t\t\t\"l\": true, // overridden\n\t\t},\n\t}\n\tassert.Equal(t, expected, dict[\"dst\"])\n}\n\nfunc TestMergeOverwrite(t *testing.T) {\n\tdict := map[string]interface{}{\n\t\t\"src2\": map[string]interface{}{\n\t\t\t\"h\": 10,\n\t\t\t\"i\": \"i\",\n\t\t\t\"j\": \"j\",\n\t\t},\n\t\t\"src1\": map[string]interface{}{\n\t\t\t\"a\": 1,\n\t\t\t\"b\": 2,\n\t\t\t\"d\": map[string]interface{}{\n\t\t\t\t\"e\": \"four\",\n\t\t\t},\n\t\t\t\"g\": []int{6, 7},\n\t\t\t\"i\": \"aye\",\n\t\t\t\"j\": \"jay\",\n\t\t\t\"k\": map[string]interface{}{\n\t\t\t\t\"l\": false,\n\t\t\t},\n\t\t},\n\t\t\"dst\": map[string]interface{}{\n\t\t\t\"a\": \"one\",\n\t\t\t\"c\": 3,\n\t\t\t\"d\": map[string]interface{}{\n\t\t\t\t\"f\": 5,\n\t\t\t},\n\t\t\t\"g\": []int{8, 9},\n\t\t\t\"i\": \"eye\",\n\t\t\t\"k\": map[string]interface{}{\n\t\t\t\t\"l\": true,\n\t\t\t},\n\t\t},\n\t}\n\ttpl := `{{mergeOverwrite .dst .src1 .src2}}`\n\t_, err := runRaw(tpl, dict)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\texpected := map[string]interface{}{\n\t\t\"a\": 1, // key overwritten from src1\n\t\t\"b\": 2, // merged from src1\n\t\t\"c\": 3, // merged from dst\n\t\t\"d\": map[string]interface{}{ // deep merge\n\t\t\t\"e\": \"four\",\n\t\t\t\"f\": 5,\n\t\t},\n\t\t\"g\": []int{6, 7}, // overwritten src1 wins\n\t\t\"h\": 10,          // merged from src2\n\t\t\"i\": \"i\",         // overwritten twice src2 wins\n\t\t\"j\": \"j\",         // overwritten twice src2 wins\n\t\t\"k\": map[string]interface{}{ // deep merge\n\t\t\t\"l\": false, // overwritten src1 wins\n\t\t},\n\t}\n\tassert.Equal(t, expected, dict[\"dst\"])\n}\n\nfunc TestValues(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"a\" 1 \"b\" 2 }}{{ values $d | sortAlpha | join \",\" }}`:       \"1,2\",\n\t\t`{{- $d := dict \"a\" \"first\" \"b\" 2 }}{{ values $d | sortAlpha | join \",\" }}`: \"2,first\",\n\t}\n\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestDeepCopy(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"a\" 1 \"b\" 2 | deepCopy }}{{ values $d | sortAlpha | join \",\" }}`: \"1,2\",\n\t\t`{{- $d := dict \"a\" 1 \"b\" 2 | deepCopy }}{{ keys $d | sortAlpha | join \",\" }}`:   \"a,b\",\n\t\t`{{- $one := dict \"foo\" (dict \"bar\" \"baz\") \"qux\" true -}}{{ deepCopy $one }}`:    \"map[foo:map[bar:baz] qux:true]\",\n\t}\n\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestMustDeepCopy(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"a\" 1 \"b\" 2 | mustDeepCopy }}{{ values $d | sortAlpha | join \",\" }}`: \"1,2\",\n\t\t`{{- $d := dict \"a\" 1 \"b\" 2 | mustDeepCopy }}{{ keys $d | sortAlpha | join \",\" }}`:   \"a,b\",\n\t\t`{{- $one := dict \"foo\" (dict \"bar\" \"baz\") \"qux\" true -}}{{ mustDeepCopy $one }}`:    \"map[foo:map[bar:baz] qux:true]\",\n\t}\n\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestDig(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{- $d := dict \"a\" (dict \"b\" (dict \"c\" 1)) }}{{ dig \"a\" \"b\" \"c\" \"\" $d }}`:  \"1\",\n\t\t`{{- $d := dict \"a\" (dict \"b\" (dict \"c\" 1)) }}{{ dig \"a\" \"b\" \"z\" \"2\" $d }}`: \"2\",\n\t\t`{{ dict \"a\" 1 | dig \"a\" \"\" }}`:                                             \"1\",\n\t\t`{{ dict \"a\" 1 | dig \"z\" \"2\" }}`:                                            \"2\",\n\t}\n\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.654296875,
          "content": "/*\nPackage sprig provides template functions for Go.\n\nThis package contains a number of utility functions for working with data\ninside of Go `html/template` and `text/template` files.\n\nTo add these functions, use the `template.Funcs()` method:\n\n\tt := template.New(\"foo\").Funcs(sprig.FuncMap())\n\nNote that you should add the function map before you parse any template files.\n\n\tIn several cases, Sprig reverses the order of arguments from the way they\n\tappear in the standard library. This is to make it easier to pipe\n\targuments into functions.\n\nSee http://masterminds.github.io/sprig/ for more detailed documentation on each of the available functions.\n*/\npackage sprig\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.513671875,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"text/template\"\n)\n\nfunc Example() {\n\t// Set up variables and template.\n\tvars := map[string]interface{}{\"Name\": \"  John Jacob Jingleheimer Schmidt \"}\n\ttpl := `Hello {{.Name | trim | lower}}`\n\n\t// Get the Sprig function map.\n\tfmap := TxtFuncMap()\n\tt := template.Must(template.New(\"test\").Funcs(fmap).Parse(tpl))\n\n\terr := t.Execute(os.Stdout, vars)\n\tif err != nil {\n\t\tfmt.Printf(\"Error during template execution: %s\", err)\n\t\treturn\n\t}\n\t// Output:\n\t// Hello john jacob jingleheimer schmidt\n}\n"
        },
        {
          "name": "flow_control_test.go",
          "type": "blob",
          "size": 0.2724609375,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFail(t *testing.T) {\n\tconst msg = \"This is an error!\"\n\ttpl := fmt.Sprintf(`{{fail \"%s\"}}`, msg)\n\t_, err := runRaw(tpl, nil)\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), msg)\n}\n"
        },
        {
          "name": "functions.go",
          "type": "blob",
          "size": 11.1259765625,
          "content": "package sprig\n\nimport (\n\t\"errors\"\n\t\"html/template\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\tttemplate \"text/template\"\n\t\"time\"\n\n\tutil \"github.com/Masterminds/goutils\"\n\t\"github.com/huandu/xstrings\"\n\t\"github.com/shopspring/decimal\"\n)\n\n// FuncMap produces the function map.\n//\n// Use this to pass the functions into the template engine:\n//\n//\ttpl := template.New(\"foo\").Funcs(sprig.FuncMap()))\nfunc FuncMap() template.FuncMap {\n\treturn HtmlFuncMap()\n}\n\n// HermeticTxtFuncMap returns a 'text/template'.FuncMap with only repeatable functions.\nfunc HermeticTxtFuncMap() ttemplate.FuncMap {\n\tr := TxtFuncMap()\n\tfor _, name := range nonhermeticFunctions {\n\t\tdelete(r, name)\n\t}\n\treturn r\n}\n\n// HermeticHtmlFuncMap returns an 'html/template'.Funcmap with only repeatable functions.\nfunc HermeticHtmlFuncMap() template.FuncMap {\n\tr := HtmlFuncMap()\n\tfor _, name := range nonhermeticFunctions {\n\t\tdelete(r, name)\n\t}\n\treturn r\n}\n\n// TxtFuncMap returns a 'text/template'.FuncMap\nfunc TxtFuncMap() ttemplate.FuncMap {\n\treturn ttemplate.FuncMap(GenericFuncMap())\n}\n\n// HtmlFuncMap returns an 'html/template'.Funcmap\nfunc HtmlFuncMap() template.FuncMap {\n\treturn template.FuncMap(GenericFuncMap())\n}\n\n// GenericFuncMap returns a copy of the basic function map as a map[string]interface{}.\nfunc GenericFuncMap() map[string]interface{} {\n\tgfm := make(map[string]interface{}, len(genericMap))\n\tfor k, v := range genericMap {\n\t\tgfm[k] = v\n\t}\n\treturn gfm\n}\n\n// These functions are not guaranteed to evaluate to the same result for given input, because they\n// refer to the environment or global state.\nvar nonhermeticFunctions = []string{\n\t// Date functions\n\t\"date\",\n\t\"date_in_zone\",\n\t\"date_modify\",\n\t\"now\",\n\t\"htmlDate\",\n\t\"htmlDateInZone\",\n\t\"dateInZone\",\n\t\"dateModify\",\n\n\t// Strings\n\t\"randAlphaNum\",\n\t\"randAlpha\",\n\t\"randAscii\",\n\t\"randNumeric\",\n\t\"randBytes\",\n\t\"uuidv4\",\n\n\t// OS\n\t\"env\",\n\t\"expandenv\",\n\n\t// Network\n\t\"getHostByName\",\n}\n\nvar genericMap = map[string]interface{}{\n\t\"hello\": func() string { return \"Hello!\" },\n\n\t// Date functions\n\t\"ago\":              dateAgo,\n\t\"date\":             date,\n\t\"date_in_zone\":     dateInZone,\n\t\"date_modify\":      dateModify,\n\t\"dateInZone\":       dateInZone,\n\t\"dateModify\":       dateModify,\n\t\"duration\":         duration,\n\t\"durationRound\":    durationRound,\n\t\"htmlDate\":         htmlDate,\n\t\"htmlDateInZone\":   htmlDateInZone,\n\t\"must_date_modify\": mustDateModify,\n\t\"mustDateModify\":   mustDateModify,\n\t\"mustToDate\":       mustToDate,\n\t\"now\":              time.Now,\n\t\"toDate\":           toDate,\n\t\"unixEpoch\":        unixEpoch,\n\n\t// Strings\n\t\"abbrev\":     abbrev,\n\t\"abbrevboth\": abbrevboth,\n\t\"trunc\":      trunc,\n\t\"trim\":       strings.TrimSpace,\n\t\"upper\":      strings.ToUpper,\n\t\"lower\":      strings.ToLower,\n\t\"title\":      strings.Title,\n\t\"untitle\":    untitle,\n\t\"substr\":     substring,\n\t// Switch order so that \"foo\" | repeat 5\n\t\"repeat\": func(count int, str string) string { return strings.Repeat(str, count) },\n\t// Deprecated: Use trimAll.\n\t\"trimall\": func(a, b string) string { return strings.Trim(b, a) },\n\t// Switch order so that \"$foo\" | trimall \"$\"\n\t\"trimAll\":      func(a, b string) string { return strings.Trim(b, a) },\n\t\"trimSuffix\":   func(a, b string) string { return strings.TrimSuffix(b, a) },\n\t\"trimPrefix\":   func(a, b string) string { return strings.TrimPrefix(b, a) },\n\t\"nospace\":      util.DeleteWhiteSpace,\n\t\"initials\":     initials,\n\t\"randAlphaNum\": randAlphaNumeric,\n\t\"randAlpha\":    randAlpha,\n\t\"randAscii\":    randAscii,\n\t\"randNumeric\":  randNumeric,\n\t\"swapcase\":     util.SwapCase,\n\t\"shuffle\":      xstrings.Shuffle,\n\t\"snakecase\":    xstrings.ToSnakeCase,\n\t// camelcase used to call xstrings.ToCamelCase, but that function had a breaking change in version\n\t// 1.5 that moved it from upper camel case to lower camel case. This is a breaking change for sprig.\n\t// A new xstrings.ToPascalCase function was added that provided upper camel case.\n\t\"camelcase\": xstrings.ToPascalCase,\n\t\"kebabcase\": xstrings.ToKebabCase,\n\t\"wrap\":      func(l int, s string) string { return util.Wrap(s, l) },\n\t\"wrapWith\":  func(l int, sep, str string) string { return util.WrapCustom(str, l, sep, true) },\n\t// Switch order so that \"foobar\" | contains \"foo\"\n\t\"contains\":   func(substr string, str string) bool { return strings.Contains(str, substr) },\n\t\"hasPrefix\":  func(substr string, str string) bool { return strings.HasPrefix(str, substr) },\n\t\"hasSuffix\":  func(substr string, str string) bool { return strings.HasSuffix(str, substr) },\n\t\"quote\":      quote,\n\t\"squote\":     squote,\n\t\"cat\":        cat,\n\t\"indent\":     indent,\n\t\"nindent\":    nindent,\n\t\"replace\":    replace,\n\t\"plural\":     plural,\n\t\"sha1sum\":    sha1sum,\n\t\"sha256sum\":  sha256sum,\n\t\"sha512sum\":  sha512sum,\n\t\"adler32sum\": adler32sum,\n\t\"toString\":   strval,\n\n\t// Wrap Atoi to stop errors.\n\t\"atoi\":      func(a string) int { i, _ := strconv.Atoi(a); return i },\n\t\"int64\":     toInt64,\n\t\"int\":       toInt,\n\t\"float64\":   toFloat64,\n\t\"seq\":       seq,\n\t\"toDecimal\": toDecimal,\n\n\t//\"gt\": func(a, b int) bool {return a > b},\n\t//\"gte\": func(a, b int) bool {return a >= b},\n\t//\"lt\": func(a, b int) bool {return a < b},\n\t//\"lte\": func(a, b int) bool {return a <= b},\n\n\t// split \"/\" foo/bar returns map[int]string{0: foo, 1: bar}\n\t\"split\":     split,\n\t\"splitList\": func(sep, orig string) []string { return strings.Split(orig, sep) },\n\t// splitn \"/\" foo/bar/fuu returns map[int]string{0: foo, 1: bar/fuu}\n\t\"splitn\":    splitn,\n\t\"toStrings\": strslice,\n\n\t\"until\":     until,\n\t\"untilStep\": untilStep,\n\n\t// VERY basic arithmetic.\n\t\"add1\": func(i interface{}) int64 { return toInt64(i) + 1 },\n\t\"add\": func(i ...interface{}) int64 {\n\t\tvar a int64 = 0\n\t\tfor _, b := range i {\n\t\t\ta += toInt64(b)\n\t\t}\n\t\treturn a\n\t},\n\t\"sub\": func(a, b interface{}) int64 { return toInt64(a) - toInt64(b) },\n\t\"div\": func(a, b interface{}) int64 { return toInt64(a) / toInt64(b) },\n\t\"mod\": func(a, b interface{}) int64 { return toInt64(a) % toInt64(b) },\n\t\"mul\": func(a interface{}, v ...interface{}) int64 {\n\t\tval := toInt64(a)\n\t\tfor _, b := range v {\n\t\t\tval = val * toInt64(b)\n\t\t}\n\t\treturn val\n\t},\n\t\"randInt\": func(min, max int) int { return rand.Intn(max-min) + min },\n\t\"add1f\": func(i interface{}) float64 {\n\t\treturn execDecimalOp(i, []interface{}{1}, func(d1, d2 decimal.Decimal) decimal.Decimal { return d1.Add(d2) })\n\t},\n\t\"addf\": func(i ...interface{}) float64 {\n\t\ta := interface{}(float64(0))\n\t\treturn execDecimalOp(a, i, func(d1, d2 decimal.Decimal) decimal.Decimal { return d1.Add(d2) })\n\t},\n\t\"subf\": func(a interface{}, v ...interface{}) float64 {\n\t\treturn execDecimalOp(a, v, func(d1, d2 decimal.Decimal) decimal.Decimal { return d1.Sub(d2) })\n\t},\n\t\"divf\": func(a interface{}, v ...interface{}) float64 {\n\t\treturn execDecimalOp(a, v, func(d1, d2 decimal.Decimal) decimal.Decimal { return d1.Div(d2) })\n\t},\n\t\"mulf\": func(a interface{}, v ...interface{}) float64 {\n\t\treturn execDecimalOp(a, v, func(d1, d2 decimal.Decimal) decimal.Decimal { return d1.Mul(d2) })\n\t},\n\t\"biggest\": max,\n\t\"max\":     max,\n\t\"min\":     min,\n\t\"maxf\":    maxf,\n\t\"minf\":    minf,\n\t\"ceil\":    ceil,\n\t\"floor\":   floor,\n\t\"round\":   round,\n\n\t// string slices. Note that we reverse the order b/c that's better\n\t// for template processing.\n\t\"join\":      join,\n\t\"sortAlpha\": sortAlpha,\n\n\t// Defaults\n\t\"default\":          dfault,\n\t\"empty\":            empty,\n\t\"coalesce\":         coalesce,\n\t\"all\":              all,\n\t\"any\":              any,\n\t\"compact\":          compact,\n\t\"mustCompact\":      mustCompact,\n\t\"fromJson\":         fromJson,\n\t\"toJson\":           toJson,\n\t\"toPrettyJson\":     toPrettyJson,\n\t\"toRawJson\":        toRawJson,\n\t\"mustFromJson\":     mustFromJson,\n\t\"mustToJson\":       mustToJson,\n\t\"mustToPrettyJson\": mustToPrettyJson,\n\t\"mustToRawJson\":    mustToRawJson,\n\t\"ternary\":          ternary,\n\t\"deepCopy\":         deepCopy,\n\t\"mustDeepCopy\":     mustDeepCopy,\n\n\t// Reflection\n\t\"typeOf\":     typeOf,\n\t\"typeIs\":     typeIs,\n\t\"typeIsLike\": typeIsLike,\n\t\"kindOf\":     kindOf,\n\t\"kindIs\":     kindIs,\n\t\"deepEqual\":  reflect.DeepEqual,\n\n\t// OS:\n\t\"env\":       os.Getenv,\n\t\"expandenv\": os.ExpandEnv,\n\n\t// Network:\n\t\"getHostByName\": getHostByName,\n\n\t// Paths:\n\t\"base\":  path.Base,\n\t\"dir\":   path.Dir,\n\t\"clean\": path.Clean,\n\t\"ext\":   path.Ext,\n\t\"isAbs\": path.IsAbs,\n\n\t// Filepaths:\n\t\"osBase\":  filepath.Base,\n\t\"osClean\": filepath.Clean,\n\t\"osDir\":   filepath.Dir,\n\t\"osExt\":   filepath.Ext,\n\t\"osIsAbs\": filepath.IsAbs,\n\n\t// Encoding:\n\t\"b64enc\": base64encode,\n\t\"b64dec\": base64decode,\n\t\"b32enc\": base32encode,\n\t\"b32dec\": base32decode,\n\n\t// Data Structures:\n\t\"tuple\":              list, // FIXME: with the addition of append/prepend these are no longer immutable.\n\t\"list\":               list,\n\t\"dict\":               dict,\n\t\"get\":                get,\n\t\"set\":                set,\n\t\"unset\":              unset,\n\t\"hasKey\":             hasKey,\n\t\"pluck\":              pluck,\n\t\"keys\":               keys,\n\t\"pick\":               pick,\n\t\"omit\":               omit,\n\t\"merge\":              merge,\n\t\"mergeOverwrite\":     mergeOverwrite,\n\t\"mustMerge\":          mustMerge,\n\t\"mustMergeOverwrite\": mustMergeOverwrite,\n\t\"values\":             values,\n\n\t\"append\": push, \"push\": push,\n\t\"mustAppend\": mustPush, \"mustPush\": mustPush,\n\t\"prepend\":     prepend,\n\t\"mustPrepend\": mustPrepend,\n\t\"first\":       first,\n\t\"mustFirst\":   mustFirst,\n\t\"rest\":        rest,\n\t\"mustRest\":    mustRest,\n\t\"last\":        last,\n\t\"mustLast\":    mustLast,\n\t\"initial\":     initial,\n\t\"mustInitial\": mustInitial,\n\t\"reverse\":     reverse,\n\t\"mustReverse\": mustReverse,\n\t\"uniq\":        uniq,\n\t\"mustUniq\":    mustUniq,\n\t\"without\":     without,\n\t\"mustWithout\": mustWithout,\n\t\"has\":         has,\n\t\"mustHas\":     mustHas,\n\t\"slice\":       slice,\n\t\"mustSlice\":   mustSlice,\n\t\"concat\":      concat,\n\t\"dig\":         dig,\n\t\"chunk\":       chunk,\n\t\"mustChunk\":   mustChunk,\n\n\t// Crypto:\n\t\"bcrypt\":                   bcrypt,\n\t\"htpasswd\":                 htpasswd,\n\t\"genPrivateKey\":            generatePrivateKey,\n\t\"derivePassword\":           derivePassword,\n\t\"buildCustomCert\":          buildCustomCertificate,\n\t\"genCA\":                    generateCertificateAuthority,\n\t\"genCAWithKey\":             generateCertificateAuthorityWithPEMKey,\n\t\"genSelfSignedCert\":        generateSelfSignedCertificate,\n\t\"genSelfSignedCertWithKey\": generateSelfSignedCertificateWithPEMKey,\n\t\"genSignedCert\":            generateSignedCertificate,\n\t\"genSignedCertWithKey\":     generateSignedCertificateWithPEMKey,\n\t\"encryptAES\":               encryptAES,\n\t\"decryptAES\":               decryptAES,\n\t\"randBytes\":                randBytes,\n\n\t// UUIDs:\n\t\"uuidv4\": uuidv4,\n\n\t// SemVer:\n\t\"semver\":        semver,\n\t\"semverCompare\": semverCompare,\n\n\t// Flow Control:\n\t\"fail\": func(msg string) (string, error) { return \"\", errors.New(msg) },\n\n\t// Regex\n\t\"regexMatch\":                 regexMatch,\n\t\"mustRegexMatch\":             mustRegexMatch,\n\t\"regexFindAll\":               regexFindAll,\n\t\"mustRegexFindAll\":           mustRegexFindAll,\n\t\"regexFind\":                  regexFind,\n\t\"mustRegexFind\":              mustRegexFind,\n\t\"regexReplaceAll\":            regexReplaceAll,\n\t\"mustRegexReplaceAll\":        mustRegexReplaceAll,\n\t\"regexReplaceAllLiteral\":     regexReplaceAllLiteral,\n\t\"mustRegexReplaceAllLiteral\": mustRegexReplaceAllLiteral,\n\t\"regexSplit\":                 regexSplit,\n\t\"mustRegexSplit\":             mustRegexSplit,\n\t\"regexQuoteMeta\":             regexQuoteMeta,\n\n\t// URLs:\n\t\"urlParse\": urlParse,\n\t\"urlJoin\":  urlJoin,\n}\n"
        },
        {
          "name": "functions_linux_test.go",
          "type": "blob",
          "size": 0.611328125,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOsBase(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osBase \"foo/bar\" }}`, \"bar\"))\n}\n\nfunc TestOsDir(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osDir \"foo/bar/baz\" }}`, \"foo/bar\"))\n}\n\nfunc TestOsIsAbs(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osIsAbs \"/foo\" }}`, \"true\"))\n\tassert.NoError(t, runt(`{{ osIsAbs \"foo\" }}`, \"false\"))\n}\n\nfunc TestOsClean(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osClean \"/foo/../foo/../bar\" }}`, \"/bar\"))\n}\n\nfunc TestOsExt(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osExt \"/foo/bar/baz.txt\" }}`, \".txt\"))\n}\n"
        },
        {
          "name": "functions_test.go",
          "type": "blob",
          "size": 3.5888671875,
          "content": "package sprig\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"testing\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEnv(t *testing.T) {\n\tos.Setenv(\"FOO\", \"bar\")\n\ttpl := `{{env \"FOO\"}}`\n\tif err := runt(tpl, \"bar\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestExpandEnv(t *testing.T) {\n\tos.Setenv(\"FOO\", \"bar\")\n\ttpl := `{{expandenv \"Hello $FOO\"}}`\n\tif err := runt(tpl, \"Hello bar\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestBase(t *testing.T) {\n\tassert.NoError(t, runt(`{{ base \"foo/bar\" }}`, \"bar\"))\n}\n\nfunc TestDir(t *testing.T) {\n\tassert.NoError(t, runt(`{{ dir \"foo/bar/baz\" }}`, \"foo/bar\"))\n}\n\nfunc TestIsAbs(t *testing.T) {\n\tassert.NoError(t, runt(`{{ isAbs \"/foo\" }}`, \"true\"))\n\tassert.NoError(t, runt(`{{ isAbs \"foo\" }}`, \"false\"))\n}\n\nfunc TestClean(t *testing.T) {\n\tassert.NoError(t, runt(`{{ clean \"/foo/../foo/../bar\" }}`, \"/bar\"))\n}\n\nfunc TestExt(t *testing.T) {\n\tassert.NoError(t, runt(`{{ ext \"/foo/bar/baz.txt\" }}`, \".txt\"))\n}\n\nfunc TestSnakeCase(t *testing.T) {\n\tassert.NoError(t, runt(`{{ snakecase \"FirstName\" }}`, \"first_name\"))\n\tassert.NoError(t, runt(`{{ snakecase \"HTTPServer\" }}`, \"http_server\"))\n\tassert.NoError(t, runt(`{{ snakecase \"NoHTTPS\" }}`, \"no_https\"))\n\tassert.NoError(t, runt(`{{ snakecase \"GO_PATH\" }}`, \"go_path\"))\n\tassert.NoError(t, runt(`{{ snakecase \"GO PATH\" }}`, \"go_path\"))\n\tassert.NoError(t, runt(`{{ snakecase \"GO-PATH\" }}`, \"go_path\"))\n}\n\nfunc TestCamelCase(t *testing.T) {\n\tassert.NoError(t, runt(`{{ camelcase \"http_server\" }}`, \"HttpServer\"))\n\tassert.NoError(t, runt(`{{ camelcase \"_camel_case\" }}`, \"_CamelCase\"))\n\tassert.NoError(t, runt(`{{ camelcase \"no_https\" }}`, \"NoHttps\"))\n\tassert.NoError(t, runt(`{{ camelcase \"_complex__case_\" }}`, \"_Complex_Case_\"))\n\tassert.NoError(t, runt(`{{ camelcase \"all\" }}`, \"All\"))\n}\n\nfunc TestKebabCase(t *testing.T) {\n\tassert.NoError(t, runt(`{{ kebabcase \"FirstName\" }}`, \"first-name\"))\n\tassert.NoError(t, runt(`{{ kebabcase \"HTTPServer\" }}`, \"http-server\"))\n\tassert.NoError(t, runt(`{{ kebabcase \"NoHTTPS\" }}`, \"no-https\"))\n\tassert.NoError(t, runt(`{{ kebabcase \"GO_PATH\" }}`, \"go-path\"))\n\tassert.NoError(t, runt(`{{ kebabcase \"GO PATH\" }}`, \"go-path\"))\n\tassert.NoError(t, runt(`{{ kebabcase \"GO-PATH\" }}`, \"go-path\"))\n}\n\nfunc TestShuffle(t *testing.T) {\n\tdefer rand.Seed(time.Now().UnixNano())\n\trand.Seed(1)\n\t// Because we're using a random number generator, we need these to go in\n\t// a predictable sequence:\n\tassert.NoError(t, runt(`{{ shuffle \"Hello World\" }}`, \"rldo HWlloe\"))\n}\n\nfunc TestRegex(t *testing.T) {\n\tassert.NoError(t, runt(`{{ regexQuoteMeta \"1.2.3\" }}`, \"1\\\\.2\\\\.3\"))\n\tassert.NoError(t, runt(`{{ regexQuoteMeta \"pretzel\" }}`, \"pretzel\"))\n}\n\n// runt runs a template and checks that the output exactly matches the expected string.\nfunc runt(tpl, expect string) error {\n\treturn runtv(tpl, expect, map[string]string{})\n}\n\n// runtv takes a template, and expected return, and values for substitution.\n//\n// It runs the template and verifies that the output is an exact match.\nfunc runtv(tpl, expect string, vars interface{}) error {\n\tfmap := TxtFuncMap()\n\tt := template.Must(template.New(\"test\").Funcs(fmap).Parse(tpl))\n\tvar b bytes.Buffer\n\terr := t.Execute(&b, vars)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif expect != b.String() {\n\t\treturn fmt.Errorf(\"Expected '%s', got '%s'\", expect, b.String())\n\t}\n\treturn nil\n}\n\n// runRaw runs a template with the given variables and returns the result.\nfunc runRaw(tpl string, vars interface{}) (string, error) {\n\tfmap := TxtFuncMap()\n\tt := template.Must(template.New(\"test\").Funcs(fmap).Parse(tpl))\n\tvar b bytes.Buffer\n\terr := t.Execute(&b, vars)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn b.String(), nil\n}\n"
        },
        {
          "name": "functions_windows_test.go",
          "type": "blob",
          "size": 0.64453125,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOsBase(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osBase \"C:\\\\foo\\\\bar\" }}`, \"bar\"))\n}\n\nfunc TestOsDir(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osDir \"C:\\\\foo\\\\bar\\\\baz\" }}`, \"C:\\\\foo\\\\bar\"))\n}\n\nfunc TestOsIsAbs(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osIsAbs \"C:\\\\foo\" }}`, \"true\"))\n\tassert.NoError(t, runt(`{{ osIsAbs \"foo\" }}`, \"false\"))\n}\n\nfunc TestOsClean(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osClean \"C:\\\\foo\\\\..\\\\foo\\\\..\\\\bar\" }}`, \"C:\\\\bar\"))\n}\n\nfunc TestOsExt(t *testing.T) {\n\tassert.NoError(t, runt(`{{ osExt \"C:\\\\foo\\\\bar\\\\baz.txt\" }}`, \".txt\"))\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.63671875,
          "content": "module github.com/Masterminds/sprig/v3\n\ngo 1.21\n\nrequire (\n\tdario.cat/mergo v1.0.1\n\tgithub.com/Masterminds/goutils v1.1.1\n\tgithub.com/Masterminds/semver/v3 v3.3.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/huandu/xstrings v1.5.0\n\tgithub.com/mitchellh/copystructure v1.2.0\n\tgithub.com/shopspring/decimal v1.4.0\n\tgithub.com/spf13/cast v1.7.0\n\tgithub.com/stretchr/testify v1.5.1\n\tgolang.org/x/crypto v0.26.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/mitchellh/reflectwalk v1.0.2 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v2 v2.3.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.75,
          "content": "dario.cat/mergo v1.0.1 h1:Ra4+bf83h2ztPIQYNP99R6m+Y7KfnARDfID+a+vLl4s=\ndario.cat/mergo v1.0.1/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ngithub.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\ngithub.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver/v3 v3.3.0 h1:B8LGeaivUe71a5qox1ICM/JLl0NqZSW5CHyL+hmvYS0=\ngithub.com/Masterminds/semver/v3 v3.3.0/go.mod h1:4V+yj/TJE1HU9XfppCwVMZq3I84lprf4nC11bSS5beM=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/huandu/xstrings v1.5.0 h1:2ag3IFq9ZDANvthTwTiqSSZLjDc+BedvHPAp5tJy2TI=\ngithub.com/huandu/xstrings v1.5.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=\ngithub.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=\ngithub.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=\ngithub.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=\ngithub.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=\ngithub.com/spf13/cast v1.7.0 h1:ntdiHjuueXFgm5nzDRdOS4yfT43P5Fnud6DH50rz/7w=\ngithub.com/spf13/cast v1.7.0/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngolang.org/x/crypto v0.26.0 h1:RrRspgV4mU+YwB4FYnuBoKsUapNIL5cohGAmSH3azsw=\ngolang.org/x/crypto v0.26.0/go.mod h1:GY7jblb9wI+FOo5y8/S2oY4zWP07AkOJ4+jxCqdqn54=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "issue_188_test.go",
          "type": "blob",
          "size": 1.2373046875,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n)\n\nfunc TestIssue188(t *testing.T) {\n\ttests := map[string]string{\n\n\t\t// This first test shows two merges and the merge is NOT A DEEP COPY MERGE.\n\t\t// The first merge puts $one on to $target. When the second merge of $two\n\t\t// on to $target the nested dict brought over from $one is changed on\n\t\t// $one as well as $target.\n\t\t`{{- $target := dict -}}\n\t\t\t{{- $one := dict \"foo\" (dict \"bar\" \"baz\") \"qux\" true -}}\n\t\t\t{{- $two := dict \"foo\" (dict \"bar\" \"baz2\") \"qux\" false -}}\n\t\t\t{{- mergeOverwrite $target $one | toString | trunc 0 }}{{ $__ := mergeOverwrite $target $two }}{{ $one }}`: \"map[foo:map[bar:baz2] qux:true]\",\n\n\t\t// This test uses deepCopy on $one to create a deep copy and then merge\n\t\t// that. In this case the merge of $two on to $target does not affect\n\t\t// $one because a deep copy was used for that merge.\n\t\t`{{- $target := dict -}}\n\t\t\t{{- $one := dict \"foo\" (dict \"bar\" \"baz\") \"qux\" true -}}\n\t\t\t{{- $two := dict \"foo\" (dict \"bar\" \"baz2\") \"qux\" false -}}\n\t\t\t{{- deepCopy $one | mergeOverwrite $target | toString | trunc 0 }}{{ $__ := mergeOverwrite $target $two }}{{ $one }}`: \"map[foo:map[bar:baz] qux:true]\",\n\t}\n\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "list.go",
          "type": "blob",
          "size": 8.8310546875,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n)\n\n// Reflection is used in these functions so that slices and arrays of strings,\n// ints, and other types not implementing []interface{} can be worked with.\n// For example, this is useful if you need to work on the output of regexs.\n\nfunc list(v ...interface{}) []interface{} {\n\treturn v\n}\n\nfunc push(list interface{}, v interface{}) []interface{} {\n\tl, err := mustPush(list, v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustPush(list interface{}, v interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tnl := make([]interface{}, l)\n\t\tfor i := 0; i < l; i++ {\n\t\t\tnl[i] = l2.Index(i).Interface()\n\t\t}\n\n\t\treturn append(nl, v), nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot push on type %s\", tp)\n\t}\n}\n\nfunc prepend(list interface{}, v interface{}) []interface{} {\n\tl, err := mustPrepend(list, v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustPrepend(list interface{}, v interface{}) ([]interface{}, error) {\n\t//return append([]interface{}{v}, list...)\n\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tnl := make([]interface{}, l)\n\t\tfor i := 0; i < l; i++ {\n\t\t\tnl[i] = l2.Index(i).Interface()\n\t\t}\n\n\t\treturn append([]interface{}{v}, nl...), nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot prepend on type %s\", tp)\n\t}\n}\n\nfunc chunk(size int, list interface{}) [][]interface{} {\n\tl, err := mustChunk(size, list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustChunk(size int, list interface{}) ([][]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\n\t\tcs := int(math.Floor(float64(l-1)/float64(size)) + 1)\n\t\tnl := make([][]interface{}, cs)\n\n\t\tfor i := 0; i < cs; i++ {\n\t\t\tclen := size\n\t\t\tif i == cs-1 {\n\t\t\t\tclen = int(math.Floor(math.Mod(float64(l), float64(size))))\n\t\t\t\tif clen == 0 {\n\t\t\t\t\tclen = size\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnl[i] = make([]interface{}, clen)\n\n\t\t\tfor j := 0; j < clen; j++ {\n\t\t\t\tix := i*size + j\n\t\t\t\tnl[i][j] = l2.Index(ix).Interface()\n\t\t\t}\n\t\t}\n\n\t\treturn nl, nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot chunk type %s\", tp)\n\t}\n}\n\nfunc last(list interface{}) interface{} {\n\tl, err := mustLast(list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustLast(list interface{}) (interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tif l == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn l2.Index(l - 1).Interface(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find last on type %s\", tp)\n\t}\n}\n\nfunc first(list interface{}) interface{} {\n\tl, err := mustFirst(list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustFirst(list interface{}) (interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tif l == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn l2.Index(0).Interface(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find first on type %s\", tp)\n\t}\n}\n\nfunc rest(list interface{}) []interface{} {\n\tl, err := mustRest(list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustRest(list interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tif l == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tnl := make([]interface{}, l-1)\n\t\tfor i := 1; i < l; i++ {\n\t\t\tnl[i-1] = l2.Index(i).Interface()\n\t\t}\n\n\t\treturn nl, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find rest on type %s\", tp)\n\t}\n}\n\nfunc initial(list interface{}) []interface{} {\n\tl, err := mustInitial(list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustInitial(list interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tif l == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tnl := make([]interface{}, l-1)\n\t\tfor i := 0; i < l-1; i++ {\n\t\t\tnl[i] = l2.Index(i).Interface()\n\t\t}\n\n\t\treturn nl, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find initial on type %s\", tp)\n\t}\n}\n\nfunc sortAlpha(list interface{}) []string {\n\tk := reflect.Indirect(reflect.ValueOf(list)).Kind()\n\tswitch k {\n\tcase reflect.Slice, reflect.Array:\n\t\ta := strslice(list)\n\t\ts := sort.StringSlice(a)\n\t\ts.Sort()\n\t\treturn s\n\t}\n\treturn []string{strval(list)}\n}\n\nfunc reverse(v interface{}) []interface{} {\n\tl, err := mustReverse(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustReverse(v interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(v).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(v)\n\n\t\tl := l2.Len()\n\t\t// We do not sort in place because the incoming array should not be altered.\n\t\tnl := make([]interface{}, l)\n\t\tfor i := 0; i < l; i++ {\n\t\t\tnl[l-i-1] = l2.Index(i).Interface()\n\t\t}\n\n\t\treturn nl, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find reverse on type %s\", tp)\n\t}\n}\n\nfunc compact(list interface{}) []interface{} {\n\tl, err := mustCompact(list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustCompact(list interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tnl := []interface{}{}\n\t\tvar item interface{}\n\t\tfor i := 0; i < l; i++ {\n\t\t\titem = l2.Index(i).Interface()\n\t\t\tif !empty(item) {\n\t\t\t\tnl = append(nl, item)\n\t\t\t}\n\t\t}\n\n\t\treturn nl, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot compact on type %s\", tp)\n\t}\n}\n\nfunc uniq(list interface{}) []interface{} {\n\tl, err := mustUniq(list)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustUniq(list interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tdest := []interface{}{}\n\t\tvar item interface{}\n\t\tfor i := 0; i < l; i++ {\n\t\t\titem = l2.Index(i).Interface()\n\t\t\tif !inList(dest, item) {\n\t\t\t\tdest = append(dest, item)\n\t\t\t}\n\t\t}\n\n\t\treturn dest, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find uniq on type %s\", tp)\n\t}\n}\n\nfunc inList(haystack []interface{}, needle interface{}) bool {\n\tfor _, h := range haystack {\n\t\tif reflect.DeepEqual(needle, h) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc without(list interface{}, omit ...interface{}) []interface{} {\n\tl, err := mustWithout(list, omit...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustWithout(list interface{}, omit ...interface{}) ([]interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tres := []interface{}{}\n\t\tvar item interface{}\n\t\tfor i := 0; i < l; i++ {\n\t\t\titem = l2.Index(i).Interface()\n\t\t\tif !inList(omit, item) {\n\t\t\t\tres = append(res, item)\n\t\t\t}\n\t\t}\n\n\t\treturn res, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Cannot find without on type %s\", tp)\n\t}\n}\n\nfunc has(needle interface{}, haystack interface{}) bool {\n\tl, err := mustHas(needle, haystack)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustHas(needle interface{}, haystack interface{}) (bool, error) {\n\tif haystack == nil {\n\t\treturn false, nil\n\t}\n\ttp := reflect.TypeOf(haystack).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(haystack)\n\t\tvar item interface{}\n\t\tl := l2.Len()\n\t\tfor i := 0; i < l; i++ {\n\t\t\titem = l2.Index(i).Interface()\n\t\t\tif reflect.DeepEqual(needle, item) {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\n\t\treturn false, nil\n\tdefault:\n\t\treturn false, fmt.Errorf(\"Cannot find has on type %s\", tp)\n\t}\n}\n\n// $list := [1, 2, 3, 4, 5]\n// slice $list     -> list[0:5] = list[:]\n// slice $list 0 3 -> list[0:3] = list[:3]\n// slice $list 3 5 -> list[3:5]\n// slice $list 3   -> list[3:5] = list[3:]\nfunc slice(list interface{}, indices ...interface{}) interface{} {\n\tl, err := mustSlice(list, indices...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn l\n}\n\nfunc mustSlice(list interface{}, indices ...interface{}) (interface{}, error) {\n\ttp := reflect.TypeOf(list).Kind()\n\tswitch tp {\n\tcase reflect.Slice, reflect.Array:\n\t\tl2 := reflect.ValueOf(list)\n\n\t\tl := l2.Len()\n\t\tif l == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tvar start, end int\n\t\tif len(indices) > 0 {\n\t\t\tstart = toInt(indices[0])\n\t\t}\n\t\tif len(indices) < 2 {\n\t\t\tend = l\n\t\t} else {\n\t\t\tend = toInt(indices[1])\n\t\t}\n\n\t\treturn l2.Slice(start, end).Interface(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"list should be type of slice or array but %s\", tp)\n\t}\n}\n\nfunc concat(lists ...interface{}) interface{} {\n\tvar res []interface{}\n\tfor _, list := range lists {\n\t\ttp := reflect.TypeOf(list).Kind()\n\t\tswitch tp {\n\t\tcase reflect.Slice, reflect.Array:\n\t\t\tl2 := reflect.ValueOf(list)\n\t\t\tfor i := 0; i < l2.Len(); i++ {\n\t\t\t\tres = append(res, l2.Index(i).Interface())\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"Cannot concat type %s as list\", tp))\n\t\t}\n\t}\n\treturn res\n}\n"
        },
        {
          "name": "list_test.go",
          "type": "blob",
          "size": 12.8759765625,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTuple(t *testing.T) {\n\ttpl := `{{$t := tuple 1 \"a\" \"foo\"}}{{index $t 2}}{{index $t 0 }}{{index $t 1}}`\n\tif err := runt(tpl, \"foo1a\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestList(t *testing.T) {\n\ttpl := `{{$t := list 1 \"a\" \"foo\"}}{{index $t 2}}{{index $t 0 }}{{index $t 1}}`\n\tif err := runt(tpl, \"foo1a\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestPush(t *testing.T) {\n\t// Named `append` in the function map\n\ttests := map[string]string{\n\t\t`{{ $t := tuple 1 2 3  }}{{ append $t 4 | len }}`:                             \"4\",\n\t\t`{{ $t := tuple 1 2 3 4  }}{{ append $t 5 | join \"-\" }}`:                      \"1-2-3-4-5\",\n\t\t`{{ $t := regexSplit \"/\" \"foo/bar/baz\" -1 }}{{ append $t \"qux\" | join \"-\" }}`: \"foo-bar-baz-qux\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustPush(t *testing.T) {\n\t// Named `append` in the function map\n\ttests := map[string]string{\n\t\t`{{ $t := tuple 1 2 3  }}{{ mustAppend $t 4 | len }}`:                           \"4\",\n\t\t`{{ $t := tuple 1 2 3 4  }}{{ mustAppend $t 5 | join \"-\" }}`:                    \"1-2-3-4-5\",\n\t\t`{{ $t := regexSplit \"/\" \"foo/bar/baz\" -1 }}{{ mustPush $t \"qux\" | join \"-\" }}`: \"foo-bar-baz-qux\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestChunk(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ tuple 1 2 3 4 5 6 7 | chunk 3 | len }}`:                                 \"3\",\n\t\t`{{ tuple | chunk 3 | len }}`:                                               \"0\",\n\t\t`{{ range ( tuple 1 2 3 4 5 6 7 8 9 | chunk 3 ) }}{{. | join \"-\"}}|{{end}}`: \"1-2-3|4-5-6|7-8-9|\",\n\t\t`{{ range ( tuple 1 2 3 4 5 6 7 8 | chunk 3 ) }}{{. | join \"-\"}}|{{end}}`:   \"1-2-3|4-5-6|7-8|\",\n\t\t`{{ range ( tuple 1 2 | chunk 3 ) }}{{. | join \"-\"}}|{{end}}`:               \"1-2|\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustChunk(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ tuple 1 2 3 4 5 6 7 | mustChunk 3 | len }}`:                                 \"3\",\n\t\t`{{ tuple | mustChunk 3 | len }}`:                                               \"0\",\n\t\t`{{ range ( tuple 1 2 3 4 5 6 7 8 9 | mustChunk 3 ) }}{{. | join \"-\"}}|{{end}}`: \"1-2-3|4-5-6|7-8-9|\",\n\t\t`{{ range ( tuple 1 2 3 4 5 6 7 8 | mustChunk 3 ) }}{{. | join \"-\"}}|{{end}}`:   \"1-2-3|4-5-6|7-8|\",\n\t\t`{{ range ( tuple 1 2 | mustChunk 3 ) }}{{. | join \"-\"}}|{{end}}`:               \"1-2|\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestPrepend(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ $t := tuple 1 2 3  }}{{ prepend $t 0 | len }}`:                             \"4\",\n\t\t`{{ $t := tuple 1 2 3 4  }}{{ prepend $t 0 | join \"-\" }}`:                      \"0-1-2-3-4\",\n\t\t`{{ $t := regexSplit \"/\" \"foo/bar/baz\" -1 }}{{ prepend $t \"qux\" | join \"-\" }}`: \"qux-foo-bar-baz\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustPrepend(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ $t := tuple 1 2 3  }}{{ mustPrepend $t 0 | len }}`:                             \"4\",\n\t\t`{{ $t := tuple 1 2 3 4  }}{{ mustPrepend $t 0 | join \"-\" }}`:                      \"0-1-2-3-4\",\n\t\t`{{ $t := regexSplit \"/\" \"foo/bar/baz\" -1 }}{{ mustPrepend $t \"qux\" | join \"-\" }}`: \"qux-foo-bar-baz\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestFirst(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | first }}`:                          \"1\",\n\t\t`{{ list | first }}`:                                \"<no value>\",\n\t\t`{{ regexSplit \"/src/\" \"foo/src/bar\" -1 | first }}`: \"foo\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustFirst(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | mustFirst }}`:                          \"1\",\n\t\t`{{ list | mustFirst }}`:                                \"<no value>\",\n\t\t`{{ regexSplit \"/src/\" \"foo/src/bar\" -1 | mustFirst }}`: \"foo\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestLast(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | last }}`:                          \"3\",\n\t\t`{{ list | last }}`:                                \"<no value>\",\n\t\t`{{ regexSplit \"/src/\" \"foo/src/bar\" -1 | last }}`: \"bar\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustLast(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | mustLast }}`:                          \"3\",\n\t\t`{{ list | mustLast }}`:                                \"<no value>\",\n\t\t`{{ regexSplit \"/src/\" \"foo/src/bar\" -1 | mustLast }}`: \"bar\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestInitial(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | initial | len }}`:                \"2\",\n\t\t`{{ list 1 2 3 | initial | last }}`:               \"2\",\n\t\t`{{ list 1 2 3 | initial | first }}`:              \"1\",\n\t\t`{{ list | initial }}`:                            \"[]\",\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | initial }}`: \"[foo bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustInitial(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | mustInitial | len }}`:                \"2\",\n\t\t`{{ list 1 2 3 | mustInitial | last }}`:               \"2\",\n\t\t`{{ list 1 2 3 | mustInitial | first }}`:              \"1\",\n\t\t`{{ list | mustInitial }}`:                            \"[]\",\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | mustInitial }}`: \"[foo bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestRest(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | rest | len }}`:                \"2\",\n\t\t`{{ list 1 2 3 | rest | last }}`:               \"3\",\n\t\t`{{ list 1 2 3 | rest | first }}`:              \"2\",\n\t\t`{{ list | rest }}`:                            \"[]\",\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | rest }}`: \"[bar baz]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustRest(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | mustRest | len }}`:                \"2\",\n\t\t`{{ list 1 2 3 | mustRest | last }}`:               \"3\",\n\t\t`{{ list 1 2 3 | mustRest | first }}`:              \"2\",\n\t\t`{{ list | mustRest }}`:                            \"[]\",\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | mustRest }}`: \"[bar baz]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestReverse(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | reverse | first }}`:              \"3\",\n\t\t`{{ list 1 2 3 | reverse | rest | first }}`:       \"2\",\n\t\t`{{ list 1 2 3 | reverse | last }}`:               \"1\",\n\t\t`{{ list 1 2 3 4 | reverse }}`:                    \"[4 3 2 1]\",\n\t\t`{{ list 1 | reverse }}`:                          \"[1]\",\n\t\t`{{ list | reverse }}`:                            \"[]\",\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | reverse }}`: \"[baz bar foo]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustReverse(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | mustReverse | first }}`:              \"3\",\n\t\t`{{ list 1 2 3 | mustReverse | rest | first }}`:       \"2\",\n\t\t`{{ list 1 2 3 | mustReverse | last }}`:               \"1\",\n\t\t`{{ list 1 2 3 4 | mustReverse }}`:                    \"[4 3 2 1]\",\n\t\t`{{ list 1 | mustReverse }}`:                          \"[1]\",\n\t\t`{{ list | mustReverse }}`:                            \"[]\",\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | mustReverse }}`: \"[baz bar foo]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestCompact(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 0 \"\" \"hello\" | compact }}`:          `[1 hello]`,\n\t\t`{{ list \"\" \"\" | compact }}`:                   `[]`,\n\t\t`{{ list | compact }}`:                         `[]`,\n\t\t`{{ regexSplit \"/\" \"foo//bar\" -1 | compact }}`: \"[foo bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustCompact(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 0 \"\" \"hello\" | mustCompact }}`:          `[1 hello]`,\n\t\t`{{ list \"\" \"\" | mustCompact }}`:                   `[]`,\n\t\t`{{ list | mustCompact }}`:                         `[]`,\n\t\t`{{ regexSplit \"/\" \"foo//bar\" -1 | mustCompact }}`: \"[foo bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestUniq(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 4 | uniq }}`:                    `[1 2 3 4]`,\n\t\t`{{ list \"a\" \"b\" \"c\" \"d\" | uniq }}`:            `[a b c d]`,\n\t\t`{{ list 1 1 1 1 2 2 2 2 | uniq }}`:            `[1 2]`,\n\t\t`{{ list \"foo\" 1 1 1 1 \"foo\" \"foo\" | uniq }}`:  `[foo 1]`,\n\t\t`{{ list | uniq }}`:                            `[]`,\n\t\t`{{ regexSplit \"/\" \"foo/foo/bar\" -1 | uniq }}`: \"[foo bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustUniq(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 4 | mustUniq }}`:                    `[1 2 3 4]`,\n\t\t`{{ list \"a\" \"b\" \"c\" \"d\" | mustUniq }}`:            `[a b c d]`,\n\t\t`{{ list 1 1 1 1 2 2 2 2 | mustUniq }}`:            `[1 2]`,\n\t\t`{{ list \"foo\" 1 1 1 1 \"foo\" \"foo\" | mustUniq }}`:  `[foo 1]`,\n\t\t`{{ list | mustUniq }}`:                            `[]`,\n\t\t`{{ regexSplit \"/\" \"foo/foo/bar\" -1 | mustUniq }}`: \"[foo bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestWithout(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ without (list 1 2 3 4) 1 }}`:                         `[2 3 4]`,\n\t\t`{{ without (list \"a\" \"b\" \"c\" \"d\") \"a\" }}`:               `[b c d]`,\n\t\t`{{ without (list 1 1 1 1 2) 1 }}`:                       `[2]`,\n\t\t`{{ without (list) 1 }}`:                                 `[]`,\n\t\t`{{ without (list 1 2 3) }}`:                             `[1 2 3]`,\n\t\t`{{ without list }}`:                                     `[]`,\n\t\t`{{ without (regexSplit \"/\" \"foo/bar/baz\" -1 ) \"foo\" }}`: \"[bar baz]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustWithout(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ mustWithout (list 1 2 3 4) 1 }}`:                         `[2 3 4]`,\n\t\t`{{ mustWithout (list \"a\" \"b\" \"c\" \"d\") \"a\" }}`:               `[b c d]`,\n\t\t`{{ mustWithout (list 1 1 1 1 2) 1 }}`:                       `[2]`,\n\t\t`{{ mustWithout (list) 1 }}`:                                 `[]`,\n\t\t`{{ mustWithout (list 1 2 3) }}`:                             `[1 2 3]`,\n\t\t`{{ mustWithout list }}`:                                     `[]`,\n\t\t`{{ mustWithout (regexSplit \"/\" \"foo/bar/baz\" -1 ) \"foo\" }}`: \"[bar baz]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestHas(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | has 1 }}`:                          `true`,\n\t\t`{{ list 1 2 3 | has 4 }}`:                          `false`,\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | has \"bar\" }}`: `true`,\n\t\t`{{ has \"bar\" nil }}`:                               `false`,\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustHas(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ list 1 2 3 | mustHas 1 }}`:                          `true`,\n\t\t`{{ list 1 2 3 | mustHas 4 }}`:                          `false`,\n\t\t`{{ regexSplit \"/\" \"foo/bar/baz\" -1 | mustHas \"bar\" }}`: `true`,\n\t\t`{{ mustHas \"bar\" nil }}`:                               `false`,\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestSlice(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ slice (list 1 2 3) }}`:                          \"[1 2 3]\",\n\t\t`{{ slice (list 1 2 3) 0 1 }}`:                      \"[1]\",\n\t\t`{{ slice (list 1 2 3) 1 3 }}`:                      \"[2 3]\",\n\t\t`{{ slice (list 1 2 3) 1 }}`:                        \"[2 3]\",\n\t\t`{{ slice (regexSplit \"/\" \"foo/bar/baz\" -1) 1 2 }}`: \"[bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestMustSlice(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ mustSlice (list 1 2 3) }}`:                          \"[1 2 3]\",\n\t\t`{{ mustSlice (list 1 2 3) 0 1 }}`:                      \"[1]\",\n\t\t`{{ mustSlice (list 1 2 3) 1 3 }}`:                      \"[2 3]\",\n\t\t`{{ mustSlice (list 1 2 3) 1 }}`:                        \"[2 3]\",\n\t\t`{{ mustSlice (regexSplit \"/\" \"foo/bar/baz\" -1) 1 2 }}`: \"[bar]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestConcat(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ concat (list 1 2 3) }}`:                                   \"[1 2 3]\",\n\t\t`{{ concat (list 1 2 3) (list 4 5) }}`:                        \"[1 2 3 4 5]\",\n\t\t`{{ concat (list 1 2 3) (list 4 5) (list) }}`:                 \"[1 2 3 4 5]\",\n\t\t`{{ concat (list 1 2 3) (list 4 5) (list nil) }}`:             \"[1 2 3 4 5 <nil>]\",\n\t\t`{{ concat (list 1 2 3) (list 4 5) (list ( list \"foo\" ) ) }}`: \"[1 2 3 4 5 [foo]]\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n"
        },
        {
          "name": "network.go",
          "type": "blob",
          "size": 0.208984375,
          "content": "package sprig\n\nimport (\n\t\"math/rand\"\n\t\"net\"\n)\n\nfunc getHostByName(name string) string {\n\taddrs, _ := net.LookupHost(name)\n\t//TODO: add error handing when release v3 comes out\n\treturn addrs[rand.Intn(len(addrs))]\n}\n"
        },
        {
          "name": "network_test.go",
          "type": "blob",
          "size": 0.279296875,
          "content": "package sprig\n\nimport (\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetHostByName(t *testing.T) {\n\ttpl := `{{\"www.google.com\" | getHostByName}}`\n\n\tresolvedIP, _ := runRaw(tpl, nil)\n\n\tip := net.ParseIP(resolvedIP)\n\tassert.NotNil(t, ip)\n\tassert.NotEmpty(t, ip)\n}\n"
        },
        {
          "name": "numeric.go",
          "type": "blob",
          "size": 3.2978515625,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/spf13/cast\"\n\t\"github.com/shopspring/decimal\"\n)\n\n// toFloat64 converts 64-bit floats\nfunc toFloat64(v interface{}) float64 {\n\treturn cast.ToFloat64(v)\n}\n\nfunc toInt(v interface{}) int {\n\treturn cast.ToInt(v)\n}\n\n// toInt64 converts integer types to 64-bit integers\nfunc toInt64(v interface{}) int64 {\n\treturn cast.ToInt64(v)\n}\n\nfunc max(a interface{}, i ...interface{}) int64 {\n\taa := toInt64(a)\n\tfor _, b := range i {\n\t\tbb := toInt64(b)\n\t\tif bb > aa {\n\t\t\taa = bb\n\t\t}\n\t}\n\treturn aa\n}\n\nfunc maxf(a interface{}, i ...interface{}) float64 {\n\taa := toFloat64(a)\n\tfor _, b := range i {\n\t\tbb := toFloat64(b)\n\t\taa = math.Max(aa, bb)\n\t}\n\treturn aa\n}\n\nfunc min(a interface{}, i ...interface{}) int64 {\n\taa := toInt64(a)\n\tfor _, b := range i {\n\t\tbb := toInt64(b)\n\t\tif bb < aa {\n\t\t\taa = bb\n\t\t}\n\t}\n\treturn aa\n}\n\nfunc minf(a interface{}, i ...interface{}) float64 {\n\taa := toFloat64(a)\n\tfor _, b := range i {\n\t\tbb := toFloat64(b)\n\t\taa = math.Min(aa, bb)\n\t}\n\treturn aa\n}\n\nfunc until(count int) []int {\n\tstep := 1\n\tif count < 0 {\n\t\tstep = -1\n\t}\n\treturn untilStep(0, count, step)\n}\n\nfunc untilStep(start, stop, step int) []int {\n\tv := []int{}\n\n\tif stop < start {\n\t\tif step >= 0 {\n\t\t\treturn v\n\t\t}\n\t\tfor i := start; i > stop; i += step {\n\t\t\tv = append(v, i)\n\t\t}\n\t\treturn v\n\t}\n\n\tif step <= 0 {\n\t\treturn v\n\t}\n\tfor i := start; i < stop; i += step {\n\t\tv = append(v, i)\n\t}\n\treturn v\n}\n\nfunc floor(a interface{}) float64 {\n\taa := toFloat64(a)\n\treturn math.Floor(aa)\n}\n\nfunc ceil(a interface{}) float64 {\n\taa := toFloat64(a)\n\treturn math.Ceil(aa)\n}\n\nfunc round(a interface{}, p int, rOpt ...float64) float64 {\n\troundOn := .5\n\tif len(rOpt) > 0 {\n\t\troundOn = rOpt[0]\n\t}\n\tval := toFloat64(a)\n\tplaces := toFloat64(p)\n\n\tvar round float64\n\tpow := math.Pow(10, places)\n\tdigit := pow * val\n\t_, div := math.Modf(digit)\n\tif div >= roundOn {\n\t\tround = math.Ceil(digit)\n\t} else {\n\t\tround = math.Floor(digit)\n\t}\n\treturn round / pow\n}\n\n// converts unix octal to decimal\nfunc toDecimal(v interface{}) int64 {\n\tresult, err := strconv.ParseInt(fmt.Sprint(v), 8, 64)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn result\n}\n\nfunc seq(params ...int) string {\n\tincrement := 1\n\tswitch len(params) {\n\tcase 0:\n\t\treturn \"\"\n\tcase 1:\n\t\tstart := 1\n\t\tend := params[0]\n\t\tif end < start {\n\t\t\tincrement = -1\n\t\t}\n\t\treturn intArrayToString(untilStep(start, end+increment, increment), \" \")\n\tcase 3:\n\t\tstart := params[0]\n\t\tend := params[2]\n\t\tstep := params[1]\n\t\tif end < start {\n\t\t\tincrement = -1\n\t\t\tif step > 0 {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t}\n\t\treturn intArrayToString(untilStep(start, end+increment, step), \" \")\n\tcase 2:\n\t\tstart := params[0]\n\t\tend := params[1]\n\t\tstep := 1\n\t\tif end < start {\n\t\t\tstep = -1\n\t\t}\n\t\treturn intArrayToString(untilStep(start, end+step, step), \" \")\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc intArrayToString(slice []int, delimeter string) string {\n\treturn strings.Trim(strings.Join(strings.Fields(fmt.Sprint(slice)), delimeter), \"[]\")\n}\n\n// performs a float and subsequent decimal.Decimal conversion on inputs,\n// and iterates through a and b executing the mathmetical operation f\nfunc execDecimalOp(a interface{}, b []interface{}, f func(d1, d2 decimal.Decimal) decimal.Decimal) float64 {\n\tprt := decimal.NewFromFloat(toFloat64(a))\n\tfor _, x := range b {\n\t\tdx := decimal.NewFromFloat(toFloat64(x))\n\t\tprt = f(prt, dx)\n\t}\n\trslt, _ := prt.Float64()\n\treturn rslt\n}\n"
        },
        {
          "name": "numeric_test.go",
          "type": "blob",
          "size": 7.197265625,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestUntil(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{range $i, $e := until 5}}{{$i}}{{$e}}{{end}}`:   \"0011223344\",\n\t\t`{{range $i, $e := until -5}}{{$i}}{{$e}} {{end}}`: \"00 1-1 2-2 3-3 4-4 \",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\nfunc TestUntilStep(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{range $i, $e := untilStep 0 5 1}}{{$i}}{{$e}}{{end}}`:     \"0011223344\",\n\t\t`{{range $i, $e := untilStep 3 6 1}}{{$i}}{{$e}}{{end}}`:     \"031425\",\n\t\t`{{range $i, $e := untilStep 0 -10 -2}}{{$i}}{{$e}} {{end}}`: \"00 1-2 2-4 3-6 4-8 \",\n\t\t`{{range $i, $e := untilStep 3 0 1}}{{$i}}{{$e}}{{end}}`:     \"\",\n\t\t`{{range $i, $e := untilStep 3 99 0}}{{$i}}{{$e}}{{end}}`:    \"\",\n\t\t`{{range $i, $e := untilStep 3 99 -1}}{{$i}}{{$e}}{{end}}`:   \"\",\n\t\t`{{range $i, $e := untilStep 3 0 0}}{{$i}}{{$e}}{{end}}`:     \"\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\n}\nfunc TestBiggest(t *testing.T) {\n\ttpl := `{{ biggest 1 2 3 345 5 6 7}}`\n\tif err := runt(tpl, `345`); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ max 345}}`\n\tif err := runt(tpl, `345`); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestMaxf(t *testing.T) {\n\ttpl := `{{ maxf 1 2 3 345.7 5 6 7}}`\n\tif err := runt(tpl, `345.7`); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ max 345 }}`\n\tif err := runt(tpl, `345`); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestMin(t *testing.T) {\n\ttpl := `{{ min 1 2 3 345 5 6 7}}`\n\tif err := runt(tpl, `1`); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ min 345}}`\n\tif err := runt(tpl, `345`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestMinf(t *testing.T) {\n\ttpl := `{{ minf 1.4 2 3 345.6 5 6 7}}`\n\tif err := runt(tpl, `1.4`); err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttpl = `{{ minf 345 }}`\n\tif err := runt(tpl, `345`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestToFloat64(t *testing.T) {\n\ttarget := float64(102)\n\tif target != toFloat64(int8(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toFloat64(int(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toFloat64(int32(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toFloat64(int16(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toFloat64(int64(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toFloat64(\"102\") {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif 0 != toFloat64(\"frankie\") {\n\t\tt.Errorf(\"Expected 0\")\n\t}\n\tif target != toFloat64(uint16(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toFloat64(uint64(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif 102.1234 != toFloat64(float64(102.1234)) {\n\t\tt.Errorf(\"Expected 102.1234\")\n\t}\n\tif 1 != toFloat64(true) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n}\nfunc TestToInt64(t *testing.T) {\n\ttarget := int64(102)\n\tif target != toInt64(int8(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(int(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(int32(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(int16(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(int64(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(\"102\") {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif 0 != toInt64(\"frankie\") {\n\t\tt.Errorf(\"Expected 0\")\n\t}\n\tif target != toInt64(uint16(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(uint64(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt64(float64(102.1234)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif 1 != toInt64(true) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n}\n\nfunc TestToInt(t *testing.T) {\n\ttarget := int(102)\n\tif target != toInt(int8(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(int(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(int32(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(int16(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(int64(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(\"102\") {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif 0 != toInt(\"frankie\") {\n\t\tt.Errorf(\"Expected 0\")\n\t}\n\tif target != toInt(uint16(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(uint64(102)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif target != toInt(float64(102.1234)) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n\tif 1 != toInt(true) {\n\t\tt.Errorf(\"Expected 102\")\n\t}\n}\n\nfunc TestToDecimal(t *testing.T) {\n\ttests := map[interface{}]int64{\n\t\t\"777\": 511,\n\t\t777:   511,\n\t\t770:   504,\n\t\t755:   493,\n\t}\n\n\tfor input, expectedResult := range tests {\n\t\tresult := toDecimal(input)\n\t\tif result != expectedResult {\n\t\t\tt.Errorf(\"Expected %v but got %v\", expectedResult, result)\n\t\t}\n\t}\n}\n\nfunc TestAdd1(t *testing.T) {\n\ttpl := `{{ 3 | add1 }}`\n\tif err := runt(tpl, `4`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAdd1f(t *testing.T) {\n\ttpl := `{{ 3.4 | add1f }}`\n\tif err := runt(tpl, `4.4`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAdd(t *testing.T) {\n\ttpl := `{{ 3 | add 1 2}}`\n\tif err := runt(tpl, `6`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestAddf(t *testing.T) {\n\ttpl := `{{ 3 | addf 1.5 2.2}}`\n\tif err := runt(tpl, `6.7`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDiv(t *testing.T) {\n\ttpl := `{{ 4 | div 5 }}`\n\tif err := runt(tpl, `1`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestDivf(t *testing.T) {\n\ttpl := `{{ 2 | divf 5 4 }}`\n\tif err := runt(tpl, `0.625`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestMul(t *testing.T) {\n\ttpl := `{{ 1 | mul \"2\" 3 \"4\"}}`\n\tif err := runt(tpl, `24`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestMulf(t *testing.T) {\n\ttpl := `{{ 1.2 | mulf \"2.4\" 10 \"4\"}}`\n\tif err := runt(tpl, `115.2`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSub(t *testing.T) {\n\ttpl := `{{ 3 | sub 14 }}`\n\tif err := runt(tpl, `11`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSubf(t *testing.T) {\n\ttpl := `{{ 3 | subf 4.5 1 }}`\n\tif err := runt(tpl, `0.5`); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestCeil(t *testing.T) {\n\tassert.Equal(t, 123.0, ceil(123))\n\tassert.Equal(t, 123.0, ceil(\"123\"))\n\tassert.Equal(t, 124.0, ceil(123.01))\n\tassert.Equal(t, 124.0, ceil(\"123.01\"))\n}\n\nfunc TestFloor(t *testing.T) {\n\tassert.Equal(t, 123.0, floor(123))\n\tassert.Equal(t, 123.0, floor(\"123\"))\n\tassert.Equal(t, 123.0, floor(123.9999))\n\tassert.Equal(t, 123.0, floor(\"123.9999\"))\n}\n\nfunc TestRound(t *testing.T) {\n\tassert.Equal(t, 123.556, round(123.5555, 3))\n\tassert.Equal(t, 123.556, round(\"123.55555\", 3))\n\tassert.Equal(t, 124.0, round(123.500001, 0))\n\tassert.Equal(t, 123.0, round(123.49999999, 0))\n\tassert.Equal(t, 123.23, round(123.2329999, 2, .3))\n\tassert.Equal(t, 123.24, round(123.233, 2, .3))\n}\n\nfunc TestRandomInt(t *testing.T) {\n\tvar tests = []struct {\n\t\tmin int\n\t\tmax int\n\t}{\n\t\t{10, 11},\n\t\t{10, 13},\n\t\t{0, 1},\n\t\t{5, 50},\n\t}\n\tfor _, v := range tests {\n\t\tx, _ := runRaw(fmt.Sprintf(`{{ randInt %d %d }}`, v.min, v.max), nil)\n\t\tr, err := strconv.Atoi(x)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, func(min, max, r int) bool {\n\t\t\treturn r >= v.min && r < v.max\n\t\t}(v.min, v.max, r))\n\t}\n}\n\nfunc TestSeq(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{seq 0 1 3}}`:   \"0 1 2 3\",\n\t\t`{{seq 0 3 10}}`:  \"0 3 6 9\",\n\t\t`{{seq 3 3 2}}`:   \"\",\n\t\t`{{seq 3 -3 2}}`:  \"3\",\n\t\t`{{seq}}`:         \"\",\n\t\t`{{seq 0 4}}`:     \"0 1 2 3 4\",\n\t\t`{{seq 5}}`:       \"1 2 3 4 5\",\n\t\t`{{seq -5}}`:      \"1 0 -1 -2 -3 -4 -5\",\n\t\t`{{seq 0}}`:       \"1 0\",\n\t\t`{{seq 0 1 2 3}}`: \"\",\n\t\t`{{seq 0 -4}}`:    \"0 -1 -2 -3 -4\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tif err := runt(tpl, expect); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "reflect.go",
          "type": "blob",
          "size": 0.53515625,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// typeIs returns true if the src is the type named in target.\nfunc typeIs(target string, src interface{}) bool {\n\treturn target == typeOf(src)\n}\n\nfunc typeIsLike(target string, src interface{}) bool {\n\tt := typeOf(src)\n\treturn target == t || \"*\"+target == t\n}\n\nfunc typeOf(src interface{}) string {\n\treturn fmt.Sprintf(\"%T\", src)\n}\n\nfunc kindIs(target string, src interface{}) bool {\n\treturn target == kindOf(src)\n}\n\nfunc kindOf(src interface{}) string {\n\treturn reflect.ValueOf(src).Kind().String()\n}\n"
        },
        {
          "name": "reflect_test.go",
          "type": "blob",
          "size": 1.3759765625,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n)\n\ntype fixtureTO struct {\n\tName, Value string\n}\n\nfunc TestTypeOf(t *testing.T) {\n\tf := &fixtureTO{\"hello\", \"world\"}\n\ttpl := `{{typeOf .}}`\n\tif err := runtv(tpl, \"*sprig.fixtureTO\", f); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestKindOf(t *testing.T) {\n\ttpl := `{{kindOf .}}`\n\n\tf := fixtureTO{\"hello\", \"world\"}\n\tif err := runtv(tpl, \"struct\", f); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tf2 := []string{\"hello\"}\n\tif err := runtv(tpl, \"slice\", f2); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tvar f3 *fixtureTO\n\tif err := runtv(tpl, \"ptr\", f3); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTypeIs(t *testing.T) {\n\tf := &fixtureTO{\"hello\", \"world\"}\n\ttpl := `{{if typeIs \"*sprig.fixtureTO\" .}}t{{else}}f{{end}}`\n\tif err := runtv(tpl, \"t\", f); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tf2 := \"hello\"\n\tif err := runtv(tpl, \"f\", f2); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestTypeIsLike(t *testing.T) {\n\tf := \"foo\"\n\ttpl := `{{if typeIsLike \"string\" .}}t{{else}}f{{end}}`\n\tif err := runtv(tpl, \"t\", f); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Now make a pointer. Should still match.\n\tf2 := &f\n\tif err := runtv(tpl, \"t\", f2); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestKindIs(t *testing.T) {\n\tf := &fixtureTO{\"hello\", \"world\"}\n\ttpl := `{{if kindIs \"ptr\" .}}t{{else}}f{{end}}`\n\tif err := runtv(tpl, \"t\", f); err != nil {\n\t\tt.Error(err)\n\t}\n\tf2 := \"hello\"\n\tif err := runtv(tpl, \"f\", f2); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "regex.go",
          "type": "blob",
          "size": 1.837890625,
          "content": "package sprig\n\nimport (\n\t\"regexp\"\n)\n\nfunc regexMatch(regex string, s string) bool {\n\tmatch, _ := regexp.MatchString(regex, s)\n\treturn match\n}\n\nfunc mustRegexMatch(regex string, s string) (bool, error) {\n\treturn regexp.MatchString(regex, s)\n}\n\nfunc regexFindAll(regex string, s string, n int) []string {\n\tr := regexp.MustCompile(regex)\n\treturn r.FindAllString(s, n)\n}\n\nfunc mustRegexFindAll(regex string, s string, n int) ([]string, error) {\n\tr, err := regexp.Compile(regex)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\treturn r.FindAllString(s, n), nil\n}\n\nfunc regexFind(regex string, s string) string {\n\tr := regexp.MustCompile(regex)\n\treturn r.FindString(s)\n}\n\nfunc mustRegexFind(regex string, s string) (string, error) {\n\tr, err := regexp.Compile(regex)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn r.FindString(s), nil\n}\n\nfunc regexReplaceAll(regex string, s string, repl string) string {\n\tr := regexp.MustCompile(regex)\n\treturn r.ReplaceAllString(s, repl)\n}\n\nfunc mustRegexReplaceAll(regex string, s string, repl string) (string, error) {\n\tr, err := regexp.Compile(regex)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn r.ReplaceAllString(s, repl), nil\n}\n\nfunc regexReplaceAllLiteral(regex string, s string, repl string) string {\n\tr := regexp.MustCompile(regex)\n\treturn r.ReplaceAllLiteralString(s, repl)\n}\n\nfunc mustRegexReplaceAllLiteral(regex string, s string, repl string) (string, error) {\n\tr, err := regexp.Compile(regex)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn r.ReplaceAllLiteralString(s, repl), nil\n}\n\nfunc regexSplit(regex string, s string, n int) []string {\n\tr := regexp.MustCompile(regex)\n\treturn r.Split(s, n)\n}\n\nfunc mustRegexSplit(regex string, s string, n int) ([]string, error) {\n\tr, err := regexp.Compile(regex)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\treturn r.Split(s, n), nil\n}\n\nfunc regexQuoteMeta(s string) string {\n\treturn regexp.QuoteMeta(s)\n}\n"
        },
        {
          "name": "regex_test.go",
          "type": "blob",
          "size": 5.490234375,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRegexMatch(t *testing.T) {\n\tregex := \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n\n\tassert.True(t, regexMatch(regex, \"test@acme.com\"))\n\tassert.True(t, regexMatch(regex, \"Test@Acme.Com\"))\n\tassert.False(t, regexMatch(regex, \"test\"))\n\tassert.False(t, regexMatch(regex, \"test.com\"))\n\tassert.False(t, regexMatch(regex, \"test@acme\"))\n}\n\nfunc TestMustRegexMatch(t *testing.T) {\n\tregex := \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n\n\to, err := mustRegexMatch(regex, \"test@acme.com\")\n\tassert.True(t, o)\n\tassert.Nil(t, err)\n\n\to, err = mustRegexMatch(regex, \"Test@Acme.Com\")\n\tassert.True(t, o)\n\tassert.Nil(t, err)\n\n\to, err = mustRegexMatch(regex, \"test\")\n\tassert.False(t, o)\n\tassert.Nil(t, err)\n\n\to, err = mustRegexMatch(regex, \"test.com\")\n\tassert.False(t, o)\n\tassert.Nil(t, err)\n\n\to, err = mustRegexMatch(regex, \"test@acme\")\n\tassert.False(t, o)\n\tassert.Nil(t, err)\n}\n\nfunc TestRegexFindAll(t *testing.T) {\n\tregex := \"a{2}\"\n\tassert.Equal(t, 1, len(regexFindAll(regex, \"aa\", -1)))\n\tassert.Equal(t, 1, len(regexFindAll(regex, \"aaaaaaaa\", 1)))\n\tassert.Equal(t, 2, len(regexFindAll(regex, \"aaaa\", -1)))\n\tassert.Equal(t, 0, len(regexFindAll(regex, \"none\", -1)))\n}\n\nfunc TestMustRegexFindAll(t *testing.T) {\n\ttype args struct {\n\t\tregex, s string\n\t\tn        int\n\t}\n\tcases := []struct {\n\t\texpected int\n\t\targs     args\n\t}{\n\t\t{1, args{\"a{2}\", \"aa\", -1}},\n\t\t{1, args{\"a{2}\", \"aaaaaaaa\", 1}},\n\t\t{2, args{\"a{2}\", \"aaaa\", -1}},\n\t\t{0, args{\"a{2}\", \"none\", -1}},\n\t}\n\n\tfor _, c := range cases {\n\t\tres, err := mustRegexFindAll(c.args.regex, c.args.s, c.args.n)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"regexFindAll test case %v failed with err %s\", c, err)\n\t\t}\n\t\tassert.Equal(t, c.expected, len(res), \"case %#v\", c.args)\n\t}\n}\n\nfunc TestRegexFindl(t *testing.T) {\n\tregex := \"fo.?\"\n\tassert.Equal(t, \"foo\", regexFind(regex, \"foorbar\"))\n\tassert.Equal(t, \"foo\", regexFind(regex, \"foo foe fome\"))\n\tassert.Equal(t, \"\", regexFind(regex, \"none\"))\n}\n\nfunc TestMustRegexFindl(t *testing.T) {\n\ttype args struct{ regex, s string }\n\tcases := []struct {\n\t\texpected string\n\t\targs     args\n\t}{\n\t\t{\"foo\", args{\"fo.?\", \"foorbar\"}},\n\t\t{\"foo\", args{\"fo.?\", \"foo foe fome\"}},\n\t\t{\"\", args{\"fo.?\", \"none\"}},\n\t}\n\n\tfor _, c := range cases {\n\t\tres, err := mustRegexFind(c.args.regex, c.args.s)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"regexFind test case %v failed with err %s\", c, err)\n\t\t}\n\t\tassert.Equal(t, c.expected, res, \"case %#v\", c.args)\n\t}\n}\n\nfunc TestRegexReplaceAll(t *testing.T) {\n\tregex := \"a(x*)b\"\n\tassert.Equal(t, \"-T-T-\", regexReplaceAll(regex, \"-ab-axxb-\", \"T\"))\n\tassert.Equal(t, \"--xx-\", regexReplaceAll(regex, \"-ab-axxb-\", \"$1\"))\n\tassert.Equal(t, \"---\", regexReplaceAll(regex, \"-ab-axxb-\", \"$1W\"))\n\tassert.Equal(t, \"-W-xxW-\", regexReplaceAll(regex, \"-ab-axxb-\", \"${1}W\"))\n}\n\nfunc TestMustRegexReplaceAll(t *testing.T) {\n\ttype args struct{ regex, s, repl string }\n\tcases := []struct {\n\t\texpected string\n\t\targs     args\n\t}{\n\t\t{\"-T-T-\", args{\"a(x*)b\", \"-ab-axxb-\", \"T\"}},\n\t\t{\"--xx-\", args{\"a(x*)b\", \"-ab-axxb-\", \"$1\"}},\n\t\t{\"---\", args{\"a(x*)b\", \"-ab-axxb-\", \"$1W\"}},\n\t\t{\"-W-xxW-\", args{\"a(x*)b\", \"-ab-axxb-\", \"${1}W\"}},\n\t}\n\n\tfor _, c := range cases {\n\t\tres, err := mustRegexReplaceAll(c.args.regex, c.args.s, c.args.repl)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"regexReplaceAll test case %v failed with err %s\", c, err)\n\t\t}\n\t\tassert.Equal(t, c.expected, res, \"case %#v\", c.args)\n\t}\n}\n\nfunc TestRegexReplaceAllLiteral(t *testing.T) {\n\tregex := \"a(x*)b\"\n\tassert.Equal(t, \"-T-T-\", regexReplaceAllLiteral(regex, \"-ab-axxb-\", \"T\"))\n\tassert.Equal(t, \"-$1-$1-\", regexReplaceAllLiteral(regex, \"-ab-axxb-\", \"$1\"))\n\tassert.Equal(t, \"-${1}-${1}-\", regexReplaceAllLiteral(regex, \"-ab-axxb-\", \"${1}\"))\n}\n\nfunc TestMustRegexReplaceAllLiteral(t *testing.T) {\n\ttype args struct{ regex, s, repl string }\n\tcases := []struct {\n\t\texpected string\n\t\targs     args\n\t}{\n\t\t{\"-T-T-\", args{\"a(x*)b\", \"-ab-axxb-\", \"T\"}},\n\t\t{\"-$1-$1-\", args{\"a(x*)b\", \"-ab-axxb-\", \"$1\"}},\n\t\t{\"-${1}-${1}-\", args{\"a(x*)b\", \"-ab-axxb-\", \"${1}\"}},\n\t}\n\n\tfor _, c := range cases {\n\t\tres, err := mustRegexReplaceAllLiteral(c.args.regex, c.args.s, c.args.repl)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"regexReplaceAllLiteral test case %v failed with err %s\", c, err)\n\t\t}\n\t\tassert.Equal(t, c.expected, res, \"case %#v\", c.args)\n\t}\n}\n\nfunc TestRegexSplit(t *testing.T) {\n\tregex := \"a\"\n\tassert.Equal(t, 4, len(regexSplit(regex, \"banana\", -1)))\n\tassert.Equal(t, 0, len(regexSplit(regex, \"banana\", 0)))\n\tassert.Equal(t, 1, len(regexSplit(regex, \"banana\", 1)))\n\tassert.Equal(t, 2, len(regexSplit(regex, \"banana\", 2)))\n\n\tregex = \"z+\"\n\tassert.Equal(t, 2, len(regexSplit(regex, \"pizza\", -1)))\n\tassert.Equal(t, 0, len(regexSplit(regex, \"pizza\", 0)))\n\tassert.Equal(t, 1, len(regexSplit(regex, \"pizza\", 1)))\n\tassert.Equal(t, 2, len(regexSplit(regex, \"pizza\", 2)))\n}\n\nfunc TestMustRegexSplit(t *testing.T) {\n\ttype args struct {\n\t\tregex, s string\n\t\tn        int\n\t}\n\tcases := []struct {\n\t\texpected int\n\t\targs     args\n\t}{\n\t\t{4, args{\"a\", \"banana\", -1}},\n\t\t{0, args{\"a\", \"banana\", 0}},\n\t\t{1, args{\"a\", \"banana\", 1}},\n\t\t{2, args{\"a\", \"banana\", 2}},\n\t\t{2, args{\"z+\", \"pizza\", -1}},\n\t\t{0, args{\"z+\", \"pizza\", 0}},\n\t\t{1, args{\"z+\", \"pizza\", 1}},\n\t\t{2, args{\"z+\", \"pizza\", 2}},\n\t}\n\n\tfor _, c := range cases {\n\t\tres, err := mustRegexSplit(c.args.regex, c.args.s, c.args.n)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"regexSplit test case %v failed with err %s\", c, err)\n\t\t}\n\t\tassert.Equal(t, c.expected, len(res), \"case %#v\", c.args)\n\t}\n}\n\nfunc TestRegexQuoteMeta(t *testing.T) {\n\tassert.Equal(t, \"1\\\\.2\\\\.3\", regexQuoteMeta(\"1.2.3\"))\n\tassert.Equal(t, \"pretzel\", regexQuoteMeta(\"pretzel\"))\n}\n"
        },
        {
          "name": "semver.go",
          "type": "blob",
          "size": 0.3916015625,
          "content": "package sprig\n\nimport (\n\tsv2 \"github.com/Masterminds/semver/v3\"\n)\n\nfunc semverCompare(constraint, version string) (bool, error) {\n\tc, err := sv2.NewConstraint(constraint)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tv, err := sv2.NewVersion(version)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn c.Check(v), nil\n}\n\nfunc semver(version string) (*sv2.Version, error) {\n\treturn sv2.NewVersion(version)\n}\n"
        },
        {
          "name": "semver_test.go",
          "type": "blob",
          "size": 0.85546875,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSemverCompare(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ semverCompare \"1.2.3\" \"1.2.3\" }}`:  `true`,\n\t\t`{{ semverCompare \"^1.2.0\" \"1.2.3\" }}`: `true`,\n\t\t`{{ semverCompare \"^1.2.0\" \"2.2.3\" }}`: `false`,\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n\nfunc TestSemver(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ $s := semver \"1.2.3-beta.1+c0ff33\" }}{{ $s.Prerelease }}`: \"beta.1\",\n\t\t`{{ $s := semver \"1.2.3-beta.1+c0ff33\" }}{{ $s.Major}}`:       \"1\",\n\t\t`{{ semver \"1.2.3\" | (semver \"1.2.3\").Compare }}`:             `0`,\n\t\t`{{ semver \"1.2.3\" | (semver \"1.3.3\").Compare }}`:             `1`,\n\t\t`{{ semver \"1.4.3\" | (semver \"1.2.3\").Compare }}`:             `-1`,\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\n"
        },
        {
          "name": "strings.go",
          "type": "blob",
          "size": 4.54296875,
          "content": "package sprig\n\nimport (\n\t\"encoding/base32\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\n\tutil \"github.com/Masterminds/goutils\"\n)\n\nfunc base64encode(v string) string {\n\treturn base64.StdEncoding.EncodeToString([]byte(v))\n}\n\nfunc base64decode(v string) string {\n\tdata, err := base64.StdEncoding.DecodeString(v)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn string(data)\n}\n\nfunc base32encode(v string) string {\n\treturn base32.StdEncoding.EncodeToString([]byte(v))\n}\n\nfunc base32decode(v string) string {\n\tdata, err := base32.StdEncoding.DecodeString(v)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn string(data)\n}\n\nfunc abbrev(width int, s string) string {\n\tif width < 4 {\n\t\treturn s\n\t}\n\tr, _ := util.Abbreviate(s, width)\n\treturn r\n}\n\nfunc abbrevboth(left, right int, s string) string {\n\tif right < 4 || left > 0 && right < 7 {\n\t\treturn s\n\t}\n\tr, _ := util.AbbreviateFull(s, left, right)\n\treturn r\n}\nfunc initials(s string) string {\n\t// Wrap this just to eliminate the var args, which templates don't do well.\n\treturn util.Initials(s)\n}\n\nfunc randAlphaNumeric(count int) string {\n\t// It is not possible, it appears, to actually generate an error here.\n\tr, _ := util.CryptoRandomAlphaNumeric(count)\n\treturn r\n}\n\nfunc randAlpha(count int) string {\n\tr, _ := util.CryptoRandomAlphabetic(count)\n\treturn r\n}\n\nfunc randAscii(count int) string {\n\tr, _ := util.CryptoRandomAscii(count)\n\treturn r\n}\n\nfunc randNumeric(count int) string {\n\tr, _ := util.CryptoRandomNumeric(count)\n\treturn r\n}\n\nfunc untitle(str string) string {\n\treturn util.Uncapitalize(str)\n}\n\nfunc quote(str ...interface{}) string {\n\tout := make([]string, 0, len(str))\n\tfor _, s := range str {\n\t\tif s != nil {\n\t\t\tout = append(out, fmt.Sprintf(\"%q\", strval(s)))\n\t\t}\n\t}\n\treturn strings.Join(out, \" \")\n}\n\nfunc squote(str ...interface{}) string {\n\tout := make([]string, 0, len(str))\n\tfor _, s := range str {\n\t\tif s != nil {\n\t\t\tout = append(out, fmt.Sprintf(\"'%v'\", s))\n\t\t}\n\t}\n\treturn strings.Join(out, \" \")\n}\n\nfunc cat(v ...interface{}) string {\n\tv = removeNilElements(v)\n\tr := strings.TrimSpace(strings.Repeat(\"%v \", len(v)))\n\treturn fmt.Sprintf(r, v...)\n}\n\nfunc indent(spaces int, v string) string {\n\tpad := strings.Repeat(\" \", spaces)\n\treturn pad + strings.Replace(v, \"\\n\", \"\\n\"+pad, -1)\n}\n\nfunc nindent(spaces int, v string) string {\n\treturn \"\\n\" + indent(spaces, v)\n}\n\nfunc replace(old, new, src string) string {\n\treturn strings.Replace(src, old, new, -1)\n}\n\nfunc plural(one, many string, count int) string {\n\tif count == 1 {\n\t\treturn one\n\t}\n\treturn many\n}\n\nfunc strslice(v interface{}) []string {\n\tswitch v := v.(type) {\n\tcase []string:\n\t\treturn v\n\tcase []interface{}:\n\t\tb := make([]string, 0, len(v))\n\t\tfor _, s := range v {\n\t\t\tif s != nil {\n\t\t\t\tb = append(b, strval(s))\n\t\t\t}\n\t\t}\n\t\treturn b\n\tdefault:\n\t\tval := reflect.ValueOf(v)\n\t\tswitch val.Kind() {\n\t\tcase reflect.Array, reflect.Slice:\n\t\t\tl := val.Len()\n\t\t\tb := make([]string, 0, l)\n\t\t\tfor i := 0; i < l; i++ {\n\t\t\t\tvalue := val.Index(i).Interface()\n\t\t\t\tif value != nil {\n\t\t\t\t\tb = append(b, strval(value))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b\n\t\tdefault:\n\t\t\tif v == nil {\n\t\t\t\treturn []string{}\n\t\t\t}\n\n\t\t\treturn []string{strval(v)}\n\t\t}\n\t}\n}\n\nfunc removeNilElements(v []interface{}) []interface{} {\n\tnewSlice := make([]interface{}, 0, len(v))\n\tfor _, i := range v {\n\t\tif i != nil {\n\t\t\tnewSlice = append(newSlice, i)\n\t\t}\n\t}\n\treturn newSlice\n}\n\nfunc strval(v interface{}) string {\n\tswitch v := v.(type) {\n\tcase string:\n\t\treturn v\n\tcase []byte:\n\t\treturn string(v)\n\tcase error:\n\t\treturn v.Error()\n\tcase fmt.Stringer:\n\t\treturn v.String()\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n}\n\nfunc trunc(c int, s string) string {\n\tif c < 0 && len(s)+c > 0 {\n\t\treturn s[len(s)+c:]\n\t}\n\tif c >= 0 && len(s) > c {\n\t\treturn s[:c]\n\t}\n\treturn s\n}\n\nfunc join(sep string, v interface{}) string {\n\treturn strings.Join(strslice(v), sep)\n}\n\nfunc split(sep, orig string) map[string]string {\n\tparts := strings.Split(orig, sep)\n\tres := make(map[string]string, len(parts))\n\tfor i, v := range parts {\n\t\tres[\"_\"+strconv.Itoa(i)] = v\n\t}\n\treturn res\n}\n\nfunc splitn(sep string, n int, orig string) map[string]string {\n\tparts := strings.SplitN(orig, sep, n)\n\tres := make(map[string]string, len(parts))\n\tfor i, v := range parts {\n\t\tres[\"_\"+strconv.Itoa(i)] = v\n\t}\n\treturn res\n}\n\n// substring creates a substring of the given string.\n//\n// If start is < 0, this calls string[:end].\n//\n// If start is >= 0 and end < 0 or end bigger than s length, this calls string[start:]\n//\n// Otherwise, this calls string[start, end].\nfunc substring(start, end int, s string) string {\n\tif start < 0 {\n\t\treturn s[:end]\n\t}\n\tif end < 0 || end > len(s) {\n\t\treturn s[start:]\n\t}\n\treturn s[start:end]\n}\n"
        },
        {
          "name": "strings_test.go",
          "type": "blob",
          "size": 7.3994140625,
          "content": "package sprig\n\nimport (\n\t\"encoding/base32\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"testing\"\n\t\"unicode/utf8\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubstr(t *testing.T) {\n\ttpl := `{{\"fooo\" | substr 0 3 }}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSubstr_shorterString(t *testing.T) {\n\ttpl := `{{\"foo\" | substr 0 10 }}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTrunc(t *testing.T) {\n\ttpl := `{{ \"foooooo\" | trunc 3 }}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ \"baaaaaar\" | trunc -3 }}`\n\tif err := runt(tpl, \"aar\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ \"baaaaaar\" | trunc -999 }}`\n\tif err := runt(tpl, \"baaaaaar\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ \"baaaaaz\" | trunc 0 }}`\n\tif err := runt(tpl, \"\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestQuote(t *testing.T) {\n\ttpl := `{{quote \"a\" \"b\" \"c\"}}`\n\tif err := runt(tpl, `\"a\" \"b\" \"c\"`); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{quote \"\\\"a\\\"\" \"b\" \"c\"}}`\n\tif err := runt(tpl, `\"\\\"a\\\"\" \"b\" \"c\"`); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{quote 1 2 3 }}`\n\tif err := runt(tpl, `\"1\" \"2\" \"3\"`); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ .value | quote }}`\n\tvalues := map[string]interface{}{\"value\": nil}\n\tif err := runtv(tpl, ``, values); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestSquote(t *testing.T) {\n\ttpl := `{{squote \"a\" \"b\" \"c\"}}`\n\tif err := runt(tpl, `'a' 'b' 'c'`); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{squote 1 2 3 }}`\n\tif err := runt(tpl, `'1' '2' '3'`); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ .value | squote }}`\n\tvalues := map[string]interface{}{\"value\": nil}\n\tif err := runtv(tpl, ``, values); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestContains(t *testing.T) {\n\t// Mainly, we're just verifying the paramater order swap.\n\ttests := []string{\n\t\t`{{if contains \"cat\" \"fair catch\"}}1{{end}}`,\n\t\t`{{if hasPrefix \"cat\" \"catch\"}}1{{end}}`,\n\t\t`{{if hasSuffix \"cat\" \"ducat\"}}1{{end}}`,\n\t}\n\tfor _, tt := range tests {\n\t\tif err := runt(tt, \"1\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestTrim(t *testing.T) {\n\ttests := []string{\n\t\t`{{trim \"   5.00   \"}}`,\n\t\t`{{trimAll \"$\" \"$5.00$\"}}`,\n\t\t`{{trimPrefix \"$\" \"$5.00\"}}`,\n\t\t`{{trimSuffix \"$\" \"5.00$\"}}`,\n\t}\n\tfor _, tt := range tests {\n\t\tif err := runt(tt, \"5.00\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\nfunc TestSplit(t *testing.T) {\n\ttpl := `{{$v := \"foo$bar$baz\" | split \"$\"}}{{$v._0}}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSplitn(t *testing.T) {\n\ttpl := `{{$v := \"foo$bar$baz\" | splitn \"$\" 2}}{{$v._0}}`\n\tif err := runt(tpl, \"foo\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestToString(t *testing.T) {\n\ttpl := `{{ toString 1 | kindOf }}`\n\tassert.NoError(t, runt(tpl, \"string\"))\n}\n\nfunc TestToStrings(t *testing.T) {\n\ttpl := `{{ $s := list 1 2 3 | toStrings }}{{ index $s 1 | kindOf }}`\n\tassert.NoError(t, runt(tpl, \"string\"))\n\ttpl = `{{ list 1 .value 2 | toStrings }}`\n\tvalues := map[string]interface{}{\"value\": nil}\n\tif err := runtv(tpl, `[1 2]`, values); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestJoin(t *testing.T) {\n\tassert.NoError(t, runt(`{{ tuple \"a\" \"b\" \"c\" | join \"-\" }}`, \"a-b-c\"))\n\tassert.NoError(t, runt(`{{ tuple 1 2 3 | join \"-\" }}`, \"1-2-3\"))\n\tassert.NoError(t, runtv(`{{ join \"-\" .V }}`, \"a-b-c\", map[string]interface{}{\"V\": []string{\"a\", \"b\", \"c\"}}))\n\tassert.NoError(t, runtv(`{{ join \"-\" .V }}`, \"abc\", map[string]interface{}{\"V\": \"abc\"}))\n\tassert.NoError(t, runtv(`{{ join \"-\" .V }}`, \"1-2-3\", map[string]interface{}{\"V\": []int{1, 2, 3}}))\n\tassert.NoError(t, runtv(`{{ join \"-\" .value }}`, \"1-2\", map[string]interface{}{\"value\": []interface{}{\"1\", nil, \"2\"}}))\n}\n\nfunc TestSortAlpha(t *testing.T) {\n\t// Named `append` in the function map\n\ttests := map[string]string{\n\t\t`{{ list \"c\" \"a\" \"b\" | sortAlpha | join \"\" }}`: \"abc\",\n\t\t`{{ list 2 1 4 3 | sortAlpha | join \"\" }}`:     \"1234\",\n\t}\n\tfor tpl, expect := range tests {\n\t\tassert.NoError(t, runt(tpl, expect))\n\t}\n}\nfunc TestBase64EncodeDecode(t *testing.T) {\n\tmagicWord := \"coffee\"\n\texpect := base64.StdEncoding.EncodeToString([]byte(magicWord))\n\n\tif expect == magicWord {\n\t\tt.Fatal(\"Encoder doesn't work.\")\n\t}\n\n\ttpl := `{{b64enc \"coffee\"}}`\n\tif err := runt(tpl, expect); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = fmt.Sprintf(\"{{b64dec %q}}\", expect)\n\tif err := runt(tpl, magicWord); err != nil {\n\t\tt.Error(err)\n\t}\n}\nfunc TestBase32EncodeDecode(t *testing.T) {\n\tmagicWord := \"coffee\"\n\texpect := base32.StdEncoding.EncodeToString([]byte(magicWord))\n\n\tif expect == magicWord {\n\t\tt.Fatal(\"Encoder doesn't work.\")\n\t}\n\n\ttpl := `{{b32enc \"coffee\"}}`\n\tif err := runt(tpl, expect); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = fmt.Sprintf(\"{{b32dec %q}}\", expect)\n\tif err := runt(tpl, magicWord); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestGoutils(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{abbrev 5 \"hello world\"}}`:           \"he...\",\n\t\t`{{abbrevboth 5 10 \"1234 5678 9123\"}}`: \"...5678...\",\n\t\t`{{nospace \"h e l l o \"}}`:             \"hello\",\n\t\t`{{untitle \"First Try\"}}`:              \"first try\", //https://youtu.be/44-RsrF_V_w\n\t\t`{{initials \"First Try\"}}`:             \"FT\",\n\t\t`{{wrap 5 \"Hello World\"}}`:             \"Hello\\nWorld\",\n\t\t`{{wrapWith 5 \"\\t\" \"Hello World\"}}`:    \"Hello\\tWorld\",\n\t}\n\tfor k, v := range tests {\n\t\tt.Log(k)\n\t\tif err := runt(k, v); err != nil {\n\t\t\tt.Errorf(\"Error on tpl %q: %s\", k, err)\n\t\t}\n\t}\n}\n\nfunc TestRandomString(t *testing.T) {\n\t// Random strings are now using Masterminds/goutils's cryptographically secure random string functions\n\t// by default. Consequently, these tests now have no predictable character sequence. No checks for exact\n\t// string output are necessary.\n\n\t// {{randAlphaNum 5}} should yield five random characters\n\tif x, _ := runRaw(`{{randAlphaNum 5}}`, nil); utf8.RuneCountInString(x) != 5 {\n\t\tt.Errorf(\"String should be 5 characters; string was %v characters\", utf8.RuneCountInString(x))\n\t}\n\n\t// {{randAlpha 5}} should yield five random characters\n\tif x, _ := runRaw(`{{randAlpha 5}}`, nil); utf8.RuneCountInString(x) != 5 {\n\t\tt.Errorf(\"String should be 5 characters; string was %v characters\", utf8.RuneCountInString(x))\n\t}\n\n\t// {{randAscii 5}} should yield five random characters\n\tif x, _ := runRaw(`{{randAscii 5}}`, nil); utf8.RuneCountInString(x) != 5 {\n\t\tt.Errorf(\"String should be 5 characters; string was %v characters\", utf8.RuneCountInString(x))\n\t}\n\n\t// {{randNumeric 5}} should yield five random characters\n\tif x, _ := runRaw(`{{randNumeric 5}}`, nil); utf8.RuneCountInString(x) != 5 {\n\t\tt.Errorf(\"String should be 5 characters; string was %v characters\", utf8.RuneCountInString(x))\n\t}\n}\n\nfunc TestCat(t *testing.T) {\n\ttpl := `{{$b := \"b\"}}{{\"c\" | cat \"a\" $b}}`\n\tif err := runt(tpl, \"a b c\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{ .value | cat \"a\" \"b\"}}`\n\tvalues := map[string]interface{}{\"value\": nil}\n\tif err := runtv(tpl, \"a b\", values); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestIndent(t *testing.T) {\n\ttpl := `{{indent 4 \"a\\nb\\nc\"}}`\n\tif err := runt(tpl, \"    a\\n    b\\n    c\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestNindent(t *testing.T) {\n\ttpl := `{{nindent 4 \"a\\nb\\nc\"}}`\n\tif err := runt(tpl, \"\\n    a\\n    b\\n    c\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestReplace(t *testing.T) {\n\ttpl := `{{\"I Am Henry VIII\" | replace \" \" \"-\"}}`\n\tif err := runt(tpl, \"I-Am-Henry-VIII\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestPlural(t *testing.T) {\n\ttpl := `{{$num := len \"two\"}}{{$num}} {{$num | plural \"1 char\" \"chars\"}}`\n\tif err := runt(tpl, \"3 chars\"); err != nil {\n\t\tt.Error(err)\n\t}\n\ttpl = `{{len \"t\" | plural \"cheese\" \"%d chars\"}}`\n\tif err := runt(tpl, \"cheese\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "url.go",
          "type": "blob",
          "size": 1.619140625,
          "content": "package sprig\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"reflect\"\n)\n\nfunc dictGetOrEmpty(dict map[string]interface{}, key string) string {\n\tvalue, ok := dict[key]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\ttp := reflect.TypeOf(value).Kind()\n\tif tp != reflect.String {\n\t\tpanic(fmt.Sprintf(\"unable to parse %s key, must be of type string, but %s found\", key, tp.String()))\n\t}\n\treturn reflect.ValueOf(value).String()\n}\n\n// parses given URL to return dict object\nfunc urlParse(v string) map[string]interface{} {\n\tdict := map[string]interface{}{}\n\tparsedURL, err := url.Parse(v)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"unable to parse url: %s\", err))\n\t}\n\tdict[\"scheme\"] = parsedURL.Scheme\n\tdict[\"host\"] = parsedURL.Host\n\tdict[\"hostname\"] = parsedURL.Hostname()\n\tdict[\"path\"] = parsedURL.Path\n\tdict[\"query\"] = parsedURL.RawQuery\n\tdict[\"opaque\"] = parsedURL.Opaque\n\tdict[\"fragment\"] = parsedURL.Fragment\n\tif parsedURL.User != nil {\n\t\tdict[\"userinfo\"] = parsedURL.User.String()\n\t} else {\n\t\tdict[\"userinfo\"] = \"\"\n\t}\n\n\treturn dict\n}\n\n// join given dict to URL string\nfunc urlJoin(d map[string]interface{}) string {\n\tresURL := url.URL{\n\t\tScheme:   dictGetOrEmpty(d, \"scheme\"),\n\t\tHost:     dictGetOrEmpty(d, \"host\"),\n\t\tPath:     dictGetOrEmpty(d, \"path\"),\n\t\tRawQuery: dictGetOrEmpty(d, \"query\"),\n\t\tOpaque:   dictGetOrEmpty(d, \"opaque\"),\n\t\tFragment: dictGetOrEmpty(d, \"fragment\"),\n\t}\n\tuserinfo := dictGetOrEmpty(d, \"userinfo\")\n\tvar user *url.Userinfo\n\tif userinfo != \"\" {\n\t\ttempURL, err := url.Parse(fmt.Sprintf(\"proto://%s@host\", userinfo))\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"unable to parse userinfo in dict: %s\", err))\n\t\t}\n\t\tuser = tempURL.User\n\t}\n\n\tresURL.User = user\n\treturn resURL.String()\n}\n"
        },
        {
          "name": "url_test.go",
          "type": "blob",
          "size": 2.0302734375,
          "content": "package sprig\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar urlTests = map[string]map[string]interface{}{\n\t\"proto://auth@host:80/path?query#fragment\": {\n\t\t\"fragment\": \"fragment\",\n\t\t\"host\":     \"host:80\",\n\t\t\"hostname\": \"host\",\n\t\t\"opaque\":   \"\",\n\t\t\"path\":     \"/path\",\n\t\t\"query\":    \"query\",\n\t\t\"scheme\":   \"proto\",\n\t\t\"userinfo\": \"auth\",\n\t},\n\t\"proto://host:80/path\": {\n\t\t\"fragment\": \"\",\n\t\t\"host\":     \"host:80\",\n\t\t\"hostname\": \"host\",\n\t\t\"opaque\":   \"\",\n\t\t\"path\":     \"/path\",\n\t\t\"query\":    \"\",\n\t\t\"scheme\":   \"proto\",\n\t\t\"userinfo\": \"\",\n\t},\n\t\"something\": {\n\t\t\"fragment\": \"\",\n\t\t\"host\":     \"\",\n\t\t\"hostname\": \"\",\n\t\t\"opaque\":   \"\",\n\t\t\"path\":     \"something\",\n\t\t\"query\":    \"\",\n\t\t\"scheme\":   \"\",\n\t\t\"userinfo\": \"\",\n\t},\n\t\"proto://user:passwor%20d@host:80/path\": {\n\t\t\"fragment\": \"\",\n\t\t\"host\":     \"host:80\",\n\t\t\"hostname\": \"host\",\n\t\t\"opaque\":   \"\",\n\t\t\"path\":     \"/path\",\n\t\t\"query\":    \"\",\n\t\t\"scheme\":   \"proto\",\n\t\t\"userinfo\": \"user:passwor%20d\",\n\t},\n\t\"proto://host:80/pa%20th?key=val%20ue\": {\n\t\t\"fragment\": \"\",\n\t\t\"host\":     \"host:80\",\n\t\t\"hostname\": \"host\",\n\t\t\"opaque\":   \"\",\n\t\t\"path\":     \"/pa th\",\n\t\t\"query\":    \"key=val%20ue\",\n\t\t\"scheme\":   \"proto\",\n\t\t\"userinfo\": \"\",\n\t},\n}\n\nfunc TestUrlParse(t *testing.T) {\n\t// testing that function is exported and working properly\n\tassert.NoError(t, runt(\n\t\t`{{ index ( urlParse \"proto://auth@host:80/path?query#fragment\" ) \"host\" }}`,\n\t\t\"host:80\"))\n\n\t// testing scenarios\n\tfor url, expected := range urlTests {\n\t\tassert.EqualValues(t, expected, urlParse(url))\n\t}\n}\n\nfunc TestUrlJoin(t *testing.T) {\n\ttests := map[string]string{\n\t\t`{{ urlJoin (dict \"fragment\" \"fragment\" \"host\" \"host:80\" \"path\" \"/path\" \"query\" \"query\" \"scheme\" \"proto\") }}`:       \"proto://host:80/path?query#fragment\",\n\t\t`{{ urlJoin (dict \"fragment\" \"fragment\" \"host\" \"host:80\" \"path\" \"/path\" \"scheme\" \"proto\" \"userinfo\" \"ASDJKJSD\") }}`: \"proto://ASDJKJSD@host:80/path#fragment\",\n\t}\n\tfor tpl, expected := range tests {\n\t\tassert.NoError(t, runt(tpl, expected))\n\t}\n\n\tfor expected, urlMap := range urlTests {\n\t\tassert.EqualValues(t, expected, urlJoin(urlMap))\n\t}\n\n}\n"
        }
      ]
    }
  ]
}