{
  "metadata": {
    "timestamp": 1736566525645,
    "page": 69,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "graph-gophers/graphql-go",
      "stars": 4668,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.10546875,
          "content": "/.idea\n/.vscode\n/internal/validation/testdata/graphql-js\n/internal/validation/testdata/node_modules\n/vendor\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.4658203125,
          "content": "run:\n  timeout: 5m\n\nlinters-settings:\n  gofmt:\n    simplify: true\n  govet:\n    check-shadowing: true\n    enable-all: true\n    disable:\n      - fieldalignment\n      - deepequalerrors # remove later\n\nlinters:\n  disable-all: true\n  enable:\n    - gofmt\n    - gosimple\n    - govet\n    - ineffassign\n    - exportloopref\n    - staticcheck\n    - unconvert\n    - unused\n    - misspell\n    - goimports\n\nissues:\n  exclude-rules:\n    - linters:\n      - unused\n      path: \"graphql_test.go\""
        },
        {
          "name": ".semaphore",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.8837890625,
          "content": "CHANGELOG\n\n[v1.5.0](https://github.com/graph-gophers/graphql-go/releases/tag/v1.5.0) Release v1.5.0\n* [FEATURE] Add specifiedBy directive in #532\n* [IMPROVEMENT] In this release we improve validation for primitive values, directives, repeat directives, #515, #516, #525, #527\n* [IMPROVEMENT] Fix minor unreachable code caused by t.Fatalf #530\n* [BUG] Fix __type queries sometimes not returning data in #540\n* [BUG] Allow deprecated directive on arguments by @pavelnikolov in #541\n* [DOCS] Add array input example #536\n\n\n[v1.4.0](https://github.com/graph-gophers/graphql-go/releases/tag/v1.4.0) Release v1.4.0\n* [FEATURE] Add basic first step for Apollo Federation. This does NOT include full subgraph specification. This PR adds support only for `_service` schema level field. This library is long way from supporting the full sub-graph spec and we do not plan to implement that any time soon.\n\n\n[v1.3.0](https://github.com/graph-gophers/graphql-go/releases/tag/v1.3.0) Release v1.3.0\n* [FEATURE] Support custom panic handler #468\n* [FEATURE] Support interfaces implementing interfaces #471\n* [BUG] Support parsing nanoseconds time properly #486\n* [BUG] Fix a bug in maxDepth fragment spread logic #492\n\n\n[v1.2.0](https://github.com/graph-gophers/graphql-go/releases/tag/v1.2.0) Release v1.2.0\n* [DOCS] Added examples of how to add JSON map as input scalar type. The goal of this change was to improve documentation #467\n\n\n[v1.1.0](https://github.com/graph-gophers/graphql-go/releases/tag/v1.1.0) Release v1.1.0\n* [FEATURE] Add types package #437\n* [FEATURE] Expose `packer.Unmarshaler` as `decode.Unmarshaler` to the public #450\n* [FEATURE] Add location fields to type definitions #454 \n* [FEATURE] `errors.Errorf` preserves original error similar to `fmt.Errorf` #456\n* [BUGFIX] Fix duplicated __typename in response (fixes #369) #443\n\n\n[v1.0.0](https://github.com/graph-gophers/graphql-go/releases/tag/v1.0.0) Initial release\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 2.916015625,
          "content": "## Community Code of Conduct\n\n### Contributor Code of Conduct\n\nAs contributors and maintainers of this project, and in the interest of fostering\nan open and welcoming community, we pledge to respect all people who contribute\nthrough reporting issues, posting feature requests, updating documentation,\nsubmitting pull requests or patches, and other activities.\n\nWe are committed to making participation in the GraphQL Go community a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.\n\n## Scope \n\nThis code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. \nBy adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect\nof managing this project. \nProject maintainers who do not follow or enforce the Code of\nConduct may be permanently removed from the project team.\n\n## Reporting \n\nFor incidents occurring in the Graph Gophers community, contact @pavelnikolov in [the Gophers Slack](https://gophers.slack.com/) or alternatively you can contact  me [at] pavelnikolov [dot] net. You can expect a response within few business days.\n\n## Enforcement \n\nThe Graph Gophers maintainers enforce code of conduct issues for the graphql-go project as well other projects under the graph-gophers github organization.\n\nWe try to resolve incidents without punishment, but may remove people from the project at our discretion.\n\n## Acknowledgements\n\nThis Code of Conduct is adapted from the Contributor Covenant\n(http://contributor-covenant.org), version 2.0 available at\nhttp://contributor-covenant.org/version/2/0/code_of_conduct/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.8193359375,
          "content": "## Contributing \n\n- With issues:\n  - Use the search tool before opening a new issue.\n  - Please provide source code and commit sha if you found a bug.\n  - Review existing issues and provide feedback or react to them.\n\n- With pull requests:\n  - Open your pull request against `master`\n  - Your pull request should have no more than two commits, if not you should squash them.\n  - It should pass all tests in the available continuous integrations systems such as TravisCI.\n  - You should add/modify tests to cover your proposed code changes.\n  - If your pull request contains a new feature, please document it well:\n    * Consider adding Go executable examples\n    * Comment all new exported types if outside of the `internal` package\n    * (optional) Mention it in the README\n    * Add a comment in the CHANGELOG.md explaining your feature\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2646484375,
          "content": "Copyright (c) 2016 Richard Musiol. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3046875,
          "content": "# graphql-go [![Sourcegraph](https://sourcegraph.com/github.com/graph-gophers/graphql-go/-/badge.svg)](https://sourcegraph.com/github.com/graph-gophers/graphql-go?badge) [![Build Status](https://graph-gophers.semaphoreci.com/badges/graphql-go/branches/master.svg?style=shields)](https://graph-gophers.semaphoreci.com/projects/graphql-go) [![Go Report](https://goreportcard.com/badge/github.com/graph-gophers/graphql-go)](https://goreportcard.com/report/github.com/graph-gophers/graphql-go) [![GoDoc](https://godoc.org/github.com/graph-gophers/graphql-go?status.svg)](https://godoc.org/github.com/graph-gophers/graphql-go)\n\n<p align=\"center\"><img src=\"docs/img/logo.png\" width=\"300\"></p>\n\nThe goal of this project is to provide full support of the [October 2021 GraphQL specification](https://spec.graphql.org/October2021/) with a set of idiomatic, easy to use Go packages.\n\nWhile still under development (`internal` APIs are almost certainly subject to change), this library is safe for production use.\n\n## Features\n\n- minimal API\n- support for `context.Context`\n- support for the `OpenTelemetry` and `OpenTracing` standards\n- schema type-checking against resolvers\n- resolvers are matched to the schema based on method sets (can resolve a GraphQL schema with a Go interface or Go struct).\n- handles panics in resolvers\n- parallel execution of resolvers\n- subscriptions\n  - [sample WS transport](https://github.com/graph-gophers/graphql-transport-ws)\n- directive visitors on fields (the API is subject to change in future versions)\n\n## (Some) Documentation [![GoDoc](https://godoc.org/github.com/graph-gophers/graphql-go?status.svg)](https://godoc.org/github.com/graph-gophers/graphql-go)\n\n### Getting started\n\nIn order to run a simple GraphQL server locally create a `main.go` file with the following content:\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\tgraphql \"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/relay\"\n)\n\ntype query struct{}\n\nfunc (query) Hello() string { return \"Hello, world!\" }\n\nfunc main() {\n\ts := `\n        type Query {\n                hello: String!\n        }\n    `\n\tschema := graphql.MustParseSchema(s, &query{})\n\thttp.Handle(\"/query\", &relay.Handler{Schema: schema})\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\n```\nThen run the file with `go run main.go`. To test:\n\t    \n```sh\ncurl -XPOST -d '{\"query\": \"{ hello }\"}' localhost:8080/query\n```\nFor more realistic usecases check our [examples section](https://github.com/graph-gophers/graphql-go/wiki/Examples).\n\n### Resolvers\n\nA resolver must have one method or field for each field of the GraphQL type it resolves. The method or field name has to be [exported](https://golang.org/ref/spec#Exported_identifiers) and match the schema's field's name in a non-case-sensitive way.\nYou can use struct fields as resolvers by using `SchemaOpt: UseFieldResolvers()`. For example,\n```\nopts := []graphql.SchemaOpt{graphql.UseFieldResolvers()}\nschema := graphql.MustParseSchema(s, &query{}, opts...)\n```   \n\nWhen using `UseFieldResolvers` schema option, a struct field will be used *only* when:\n- there is no method for a struct field\n- a struct field does not implement an interface method\n- a struct field does not have arguments\n\nThe method has up to two arguments:\n\n- Optional `context.Context` argument.\n- Mandatory `*struct { ... }` argument if the corresponding GraphQL field has arguments. The names of the struct fields have to be [exported](https://golang.org/ref/spec#Exported_identifiers) and have to match the names of the GraphQL arguments in a non-case-sensitive way.\n\nThe method has up to two results:\n\n- The GraphQL field's value as determined by the resolver.\n- Optional `error` result.\n\nExample for a simple resolver method:\n\n```go\nfunc (r *helloWorldResolver) Hello() string {\n\treturn \"Hello world!\"\n}\n```\n\nThe following signature is also allowed:\n\n```go\nfunc (r *helloWorldResolver) Hello(ctx context.Context) (string, error) {\n\treturn \"Hello world!\", nil\n}\n```\n\n### Separate resolvers for different operations\n> **NOTE**: This feature is not in the stable release yet. In order to use it you need to run `go get github.com/graph-gophers/graphql-go@master` and in your `go.mod` file you will have something like:\n>  ```\n>  v1.5.1-0.20230216224648-5aa631d05992\n>  ```\n> It is expected to be released in `v1.6.0` soon.\n\nThe GraphQL specification allows for fields with the same name defined in different query types. For example, the schema below is a valid schema definition:\n```graphql\nschema {\n  query: Query\n  mutation: Mutation\n}\n\ntype Query {\n  hello: String!\n}\n\ntype Mutation {\n  hello: String!\n}\n```\nThe above schema would result in name collision if we use a single resolver struct because fields from both operations correspond to methods in the root resolver (the same Go struct). In order to resolve this issue, the library allows resolvers for query, mutation and subscription operations to be separated using the `Query`, `Mutation` and `Subscription` methods of the root resolver. These special methods are optional and if defined return the resolver for each opeartion. For example, the following is a resolver corresponding to the schema definition above. Note that there is a field named `hello` in both the query and the mutation definitions:\n\n```go\ntype RootResolver struct{}\ntype QueryResolver struct{}\ntype MutationResolver struct{}\n\nfunc(r *RootResolver) Query() *QueryResolver {\n  return &QueryResolver{}\n}\n\nfunc(r *RootResolver) Mutation() *MutationResolver {\n  return &MutationResolver{}\n}\n\nfunc (*QueryResolver) Hello() string {\n\treturn \"Hello query!\"\n}\n\nfunc (*MutationResolver) Hello() string {\n\treturn \"Hello mutation!\"\n}\n\nschema := graphql.MustParseSchema(sdl, &RootResolver{}, nil)\n...\n```\n\n### Schema Options\n\n- `UseStringDescriptions()` enables the usage of double quoted and triple quoted. When this is not enabled, comments are parsed as descriptions instead.\n- `UseFieldResolvers()` specifies whether to use struct field resolvers.\n- `MaxDepth(n int)` specifies the maximum field nesting depth in a query. The default is 0 which disables max depth checking.\n- `MaxParallelism(n int)` specifies the maximum number of resolvers per request allowed to run in parallel. The default is 10.\n- `Tracer(tracer trace.Tracer)` is used to trace queries and fields. It defaults to `noop.Tracer`.\n- `Logger(logger log.Logger)` is used to log panics during query execution. It defaults to `exec.DefaultLogger`.\n- `PanicHandler(panicHandler errors.PanicHandler)` is used to transform panics into errors during query execution. It defaults to `errors.DefaultPanicHandler`.\n- `DisableIntrospection()` disables introspection queries.\n- `DirectiveVisitors()` adds directive visitor implementations to the schema. See examples/directives/authorization for an example.\n\n### Custom Errors\n\nErrors returned by resolvers can include custom extensions by implementing the `ResolverError` interface:\n\n```go\ntype ResolverError interface {\n\terror\n\tExtensions() map[string]interface{}\n}\n```\n\nExample of a simple custom error:\n\n```go\ntype droidNotFoundError struct {\n\tCode    string `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc (e droidNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"error [%s]: %s\", e.Code, e.Message)\n}\n\nfunc (e droidNotFoundError) Extensions() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"code\":    e.Code,\n\t\t\"message\": e.Message,\n\t}\n}\n```\n\nWhich could produce a GraphQL error such as:\n\n```go\n{\n  \"errors\": [\n    {\n      \"message\": \"error [NotFound]: This is not the droid you are looking for\",\n      \"path\": [\n        \"droid\"\n      ],\n      \"extensions\": {\n        \"code\": \"NotFound\",\n        \"message\": \"This is not the droid you are looking for\"\n      }\n    }\n  ],\n  \"data\": null\n}\n```\n\n### Tracing\n\nBy default the library uses `noop.Tracer`. If you want to change that you can use the OpenTelemetry or the OpenTracing implementations, respectively:\n\n```go\n// OpenTelemetry tracer\npackage main\n\nimport (\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n\totelgraphql \"github.com/graph-gophers/graphql-go/trace/otel\"\n\t\"github.com/graph-gophers/graphql-go/trace/tracer\"\n)\n// ...\n_, err := graphql.ParseSchema(starwars.Schema, nil, graphql.Tracer(otelgraphql.DefaultTracer()))\n// ...\n```\nAlternatively you can pass an existing trace.Tracer instance:\n```go\ntr := otel.Tracer(\"example\")\n_, err = graphql.ParseSchema(starwars.Schema, nil, graphql.Tracer(&otelgraphql.Tracer{Tracer: tr}))\n```\n\n\n```go\n// OpenTracing tracer\npackage main\n\nimport (\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n\t\"github.com/graph-gophers/graphql-go/trace/opentracing\"\n\t\"github.com/graph-gophers/graphql-go/trace/tracer\"\n)\n// ...\n_, err := graphql.ParseSchema(starwars.Schema, nil, graphql.Tracer(opentracing.Tracer{}))\n\n// ...\n```\n\nIf you need to implement a custom tracer the library would accept any tracer which implements the interface below:\n```go\ntype Tracer interface {\n    TraceQuery(ctx context.Context, queryString string, operationName string, variables map[string]interface{}, varTypes map[string]*introspection.Type) (context.Context, func([]*errors.QueryError))\n    TraceField(ctx context.Context, label, typeName, fieldName string, trivial bool, args map[string]interface{}) (context.Context, func(*errors.QueryError))\n    TraceValidation(context.Context) func([]*errors.QueryError)\n}\n```\n\n\n### [Examples](https://github.com/graph-gophers/graphql-go/wiki/Examples)\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.72265625,
          "content": "# Security Policy\n\n## Supported Versions\n\nWe always try to maintain the library secure and suggest our users to upgrade to the latest stable version. We realize that sometimes this is not possible.\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 1.x     | :white_check_mark: |\n| < 1.0   | :x:                |\n\n## MaxDepth\nIf you are using the `graphql.MaxDepth` schema option, make sure that you upgrade to version v1.3.0 or higher due to a bug causing security vulnerability in earlier versions.\n\n## Reporting a Vulnerability\n\nIf you find a security vulnerability with this library, please, DO NOT submit a pull request right away. Please, report the issue to @pavelnikolov in the Gophers Slack in a private message.\n"
        },
        {
          "name": "ast",
          "type": "tree",
          "content": null
        },
        {
          "name": "decode",
          "type": "tree",
          "content": null
        },
        {
          "name": "directives",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_custom_err_test.go",
          "type": "blob",
          "size": 2.3974609375,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n)\n\ntype product struct {\n\tID   graphql.ID\n\tName string\n}\n\ntype custErrResolver struct {\n\tproducts map[graphql.ID]*product\n}\n\nfunc (r *custErrResolver) Product(ctx context.Context, args struct{ ID graphql.ID }) (*productResolver, error) {\n\tif p := r.products[args.ID]; p != nil {\n\t\treturn &productResolver{p: p}, nil\n\t}\n\ttraceID := \"your-trace-id-here\" // get trace ID from ctx\n\treturn nil, &productNotFoundError{Code: \"NotFound\", Message: \"Product not found\", TraceID: traceID}\n}\n\ntype productResolver struct {\n\tp *product\n}\n\nfunc (r *productResolver) ID() graphql.ID {\n\treturn r.p.ID\n}\n\nfunc (r *productResolver) Name() string {\n\treturn r.p.Name\n}\n\ntype productNotFoundError struct {\n\tCode    string `json:\"code\"`\n\tMessage string `json:\"message\"`\n\tTraceID string `json:\"traceId\"`\n}\n\nfunc (e productNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"error [%s]: %s.\", e.Code, e.Message)\n}\n\n// Extensions provides additional error context according to the spec https://spec.graphql.org/October2021/#sel-GAPHRPZCAACCBx6b.\nfunc (e productNotFoundError) Extensions() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"code\":    e.Code,\n\t\t\"message\": e.Message,\n\t\t\"traceId\": e.TraceID,\n\t}\n}\n\n// Example_customErrors demonstrates the use of custom errors and error extensions.\nfunc Example_customErrors() {\n\tvar products = []*product{\n\t\t{ID: \"1000\", Name: \"Product1\"},\n\t\t{ID: \"1001\", Name: \"Product2\"},\n\t}\n\tresolver := &custErrResolver{\n\t\tproducts: map[graphql.ID]*product{},\n\t}\n\tfor _, p := range products {\n\t\tresolver.products[p.ID] = p\n\t}\n\ts := `\n\tschema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\tproduct(id: ID!): Product!\n\t}\n\n\ttype Product {\n\t\tid: ID!\n\t\tname: String!\n\t}\n\t`\n\tschema := graphql.MustParseSchema(s, resolver)\n\n\tquery := `\n\t  query {\n\t\tproduct(id: \"1007\") {\n\t\t\tid\n\t\t\tname\n\t\t}\n\t  }\n\t`\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {\n\t//   \"errors\": [\n\t//     {\n\t//       \"message\": \"error [NotFound]: Product not found.\",\n\t//       \"path\": [\n\t//         \"product\"\n\t//       ],\n\t//       \"extensions\": {\n\t//         \"code\": \"NotFound\",\n\t//         \"message\": \"Product not found\",\n\t//         \"traceId\": \"your-trace-id-here\"\n\t//       }\n\t//     }\n\t//   ],\n\t//   \"data\": null\n\t// }\n}\n"
        },
        {
          "name": "example_directives_test.go",
          "type": "blob",
          "size": 3.0556640625,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/directives\"\n)\n\ntype roleKey string\n\nconst RoleKey = roleKey(\"role\")\n\ntype HasRoleDirective struct {\n\tRole string\n}\n\nfunc (h *HasRoleDirective) ImplementsDirective() string {\n\treturn \"hasRole\"\n}\n\nfunc (h *HasRoleDirective) Validate(ctx context.Context, _ interface{}) error {\n\tif ctx.Value(RoleKey) != h.Role {\n\t\treturn fmt.Errorf(\"access denied, role %q required\", h.Role)\n\t}\n\treturn nil\n}\n\n// NullableDirective\ntype WithNullableArgumentDirective struct {\n\tANullableArgument *string\n}\n\nfunc (_ *WithNullableArgumentDirective) Validate(_ context.Context, _ interface{}) error {\n\treturn nil\n}\n\nfunc (_ *WithNullableArgumentDirective) ImplementsDirective() string {\n\treturn \"withNullableArgument\"\n}\n\ntype UpperDirective struct{}\n\nfunc (d *UpperDirective) ImplementsDirective() string {\n\treturn \"upper\"\n}\n\nfunc (d *UpperDirective) Resolve(ctx context.Context, args interface{}, next directives.Resolver) (interface{}, error) {\n\tout, err := next.Resolve(ctx, args)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\n\ts, ok := out.(string)\n\tif !ok {\n\t\treturn out, nil\n\t}\n\n\treturn strings.ToUpper(s), nil\n}\n\ntype authResolver struct{}\n\nfunc (*authResolver) Greet(ctx context.Context, args struct{ Name string }) string {\n\treturn fmt.Sprintf(\"Hello, %s!\", args.Name)\n}\nfunc (*authResolver) NullableDirective() string {\n\treturn \"nullableDirective\"\n}\n\n// ExampleDirectives demonstrates the use of the Directives schema option.\nfunc ExampleDirectives() {\n\ts := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\tdirective @hasRole(role: String!) on FIELD_DEFINITION\n\t\tdirective @upper on FIELD_DEFINITION\n\t\tdirective @withNullableArgument(aNullableArgument: String) on FIELD_DEFINITION\n\n\t\ttype Query {\n\t\t\tgreet(name: String!): String! @hasRole(role: \"admin\") @upper\n\t\t\tnullableDirective: String! @withNullableArgument()\n\t\t}\n\t`\n\topts := []graphql.SchemaOpt{\n\t\tgraphql.Directives(&HasRoleDirective{}, &UpperDirective{}, &WithNullableArgumentDirective{}),\n\t\t// other options go here\n\t}\n\tschema := graphql.MustParseSchema(s, &authResolver{}, opts...)\n\tquery := `\n\t\tquery {\n\t\t\tgreet(name: \"GraphQL\")\n\t\t}\n\t`\n\tcases := []struct {\n\t\tname string\n\t\tctx  context.Context\n\t}{\n\t\t{\n\t\t\tname: \"Unauthorized\",\n\t\t\tctx:  context.Background(),\n\t\t},\n\t\t{\n\t\t\tname: \"Admin user\",\n\t\t\tctx:  context.WithValue(context.Background(), RoleKey, \"admin\"),\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tfmt.Println(c.name, \"result:\")\n\t\tres := schema.Exec(c.ctx, query, \"\", nil)\n\t\tenc := json.NewEncoder(os.Stdout)\n\t\tenc.SetIndent(\"\", \"  \")\n\t\terr := enc.Encode(res)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\t// output:\n\t// Unauthorized result:\n\t// {\n\t//   \"errors\": [\n\t//     {\n\t//       \"message\": \"access denied, role \\\"admin\\\" required\",\n\t//       \"locations\": [\n\t//         {\n\t//           \"line\": 11,\n\t//           \"column\": 4\n\t//         }\n\t//       ],\n\t//       \"path\": [\n\t//         \"greet\"\n\t//       ]\n\t//     }\n\t//   ],\n\t//   \"data\": null\n\t// }\n\t// Admin user result:\n\t// {\n\t//   \"data\": {\n\t//     \"greet\": \"HELLO, GRAPHQL!\"\n\t//   }\n\t// }\n}\n"
        },
        {
          "name": "example_input_array_test.go",
          "type": "blob",
          "size": 1.4345703125,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"os\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n)\n\ntype query struct{}\n\ntype IntTuple struct {\n\tA int32\n\tB int32\n}\n\nfunc (*query) Reversed(args struct{ Values []string }) []string {\n\tresult := make([]string, len(args.Values))\n\n\tfor i, value := range args.Values {\n\t\tfor _, v := range value {\n\t\t\tresult[i] = string(v) + result[i]\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (*query) Sums(args struct{ Values []IntTuple }) []int32 {\n\tresult := make([]int32, len(args.Values))\n\n\tfor i, value := range args.Values {\n\t\tresult[i] = value.A + value.B\n\t}\n\treturn result\n}\n\n// Example_inputArray shows a simple GraphQL schema which defines a custom input type.\n// Then it executes a query against it passing array arguments.\nfunc Example_inputArray() {\n\ts := `\n\t  input IntTuple {\n\t    a: Int!\n\t    b: Int!\n\t  }\n\t\n\t  type Query {\n\t    reversed(values: [String!]!): [String!]!\n\t    sums(values: [IntTuple!]!): [Int!]!\n\t  }\n\t`\n\tschema := graphql.MustParseSchema(s, &query{})\n\n\tquery := `\n\t  query{\n\t    reversed(values:[\"hello\", \"hi\"])\n\t    sums(values:[{a:2,b:3},{a:-10,b:-1}])\n\t  }\n\t`\n\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {\n\t//   \"data\": {\n\t//     \"reversed\": [\n\t//       \"olleh\",\n\t//       \"ih\"\n\t//     ],\n\t//     \"sums\": [\n\t//       5,\n\t//       -11\n\t//     ]\n\t//   }\n\t// }\n}\n"
        },
        {
          "name": "example_nullbool_test.go",
          "type": "blob",
          "size": 1.1845703125,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n)\n\ntype mutnb struct{}\n\nfunc (*mutnb) Toggle(args struct{ Enabled graphql.NullBool }) string {\n\tif !args.Enabled.Set {\n\t\treturn \"input value was not provided\"\n\t} else if args.Enabled.Value == nil {\n\t\treturn \"enabled is 'null'\"\n\t}\n\treturn fmt.Sprintf(\"enabled '%v'\", *args.Enabled.Value)\n}\n\n// ExampleNullBool demonstrates how to use nullable Bool type when it is necessary to differentiate between nil and not set.\nfunc ExampleNullBool() {\n\tconst s = `\n\t\tschema {\n\t\t\tquery: Query\n\t\t\tmutation: Mutation\n\t\t}\n\t\ttype Query{}\n\t\ttype Mutation{\n\t\t\ttoggle(enabled: Boolean): String!\n\t\t}\n\t`\n\tschema := graphql.MustParseSchema(s, &mutnb{})\n\n\tconst query = `mutation{\n\t\ttoggle1: toggle()\n\t\ttoggle2: toggle(enabled: null)\n\t\ttoggle3: toggle(enabled: true)\n\t}`\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {\n\t//   \"data\": {\n\t//     \"toggle1\": \"input value was not provided\",\n\t//     \"toggle2\": \"enabled is 'null'\",\n\t//     \"toggle3\": \"enabled 'true'\"\n\t//   }\n\t// }\n}\n"
        },
        {
          "name": "example_scalar_map_test.go",
          "type": "blob",
          "size": 1.1416015625,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n)\n\ntype Map map[string]interface{}\n\nfunc (Map) ImplementsGraphQLType(name string) bool {\n\treturn name == \"Map\"\n}\n\nfunc (m *Map) UnmarshalGraphQL(input interface{}) error {\n\tval, ok := input.(map[string]interface{})\n\tif !ok {\n\t\treturn fmt.Errorf(\"wrong type\")\n\t}\n\t*m = val\n\treturn nil\n}\n\ntype Args struct {\n\tName string\n\tData Map\n}\n\ntype mutation struct{}\n\nfunc (*mutation) Hello(args Args) string {\n\tfmt.Println(args)\n\treturn \"Args accepted!\"\n}\n\nfunc Example_customScalarMap() {\n\ts := `\n\t\tscalar Map\n\t\n\t\ttype Query {}\n\t\t\n\t\ttype Mutation {\n\t\t\thello(\n\t\t\t\tname: String!\n\t\t\t\tdata: Map!\n\t\t\t): String!\n\t\t}\n\t`\n\tschema := graphql.MustParseSchema(s, &mutation{})\n\n\tquery := `\n\t  mutation {\n\t\thello(name: \"GraphQL\", data: {\n\t\t\tnum: 5,\n\t\t\tcode: \"example\"\n\t\t})\n\t  }\n\t`\n\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {GraphQL map[code:example num:5]}\n\t// {\n\t//   \"data\": {\n\t//     \"hello\": \"Args accepted!\"\n\t//   }\n\t// }\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.9150390625,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n)\n\ntype exampleResolver struct{}\n\nfunc (*exampleResolver) Greet(ctx context.Context, args struct{ Name string }) string {\n\treturn fmt.Sprintf(\"Hello, %s!\", args.Name)\n}\n\n// Example demonstrates how to parse a GraphQL schema and execute a query against it.\nfunc Example() {\n\ts := `\n\t  schema {\n\t    query: Query\n\t  }\n\t  \n\t  type Query {\n\t    greet(name: String!): String!\n\t  }\n\t`\n\topts := []graphql.SchemaOpt{\n\t\t// schema options go here\n\t}\n\tschema := graphql.MustParseSchema(s, &exampleResolver{}, opts...)\n\tquery := `\n\t\tquery {\n\t\t\tgreet(name: \"GraphQL\")\n\t\t}\n\t`\n\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {\n\t//   \"data\": {\n\t//     \"greet\": \"Hello, GraphQL!\"\n\t//   }\n\t// }\n}\n"
        },
        {
          "name": "example_time_test.go",
          "type": "blob",
          "size": 0.6259765625,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n)\n\ntype tquery struct{}\n\nfunc (*tquery) CurrentTime() graphql.Time {\n\treturn graphql.Time{Time: time.Date(2023, 2, 6, 12, 3, 22, 0, time.UTC)}\n}\n\nfunc ExampleTime() {\n\tconst s = `\n\t\tscalar Time\n\n\t\ttype Query {\n\t\t\tcurrentTime: Time!\n\t\t}\n\t`\n\tschema := graphql.MustParseSchema(s, &tquery{})\n\n\tconst query = \"{ currentTime }\"\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\terr := json.NewEncoder(os.Stdout).Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {\"data\":{\"currentTime\":\"2023-02-06T12:03:22Z\"}}\n}\n"
        },
        {
          "name": "examples_test.go",
          "type": "blob",
          "size": 9.2734375,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"text/template\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n)\n\ntype Resolver struct {\n\tpost *Post\n}\n\nfunc (r *Resolver) Post() *Post {\n\treturn r.post\n}\n\ntype Post struct {\n\tid    graphql.ID\n\ttitle string\n}\n\nfunc (p *Post) ID() graphql.ID {\n\treturn p.id\n}\n\nfunc (p *Post) Title() string {\n\treturn p.title\n}\n\nfunc ExampleID() {\n\tschemaString := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tpost: Post!\n\t\t}\n\n\t\ttype Post {\n\t\t\tid: ID!\n\t\t\ttitle: String!\n\t\t}\n\t`\n\n\tresolver := &Resolver{\n\t\tpost: &Post{\n\t\t\tid:    graphql.ID(\"5\"),\n\t\t\ttitle: \"title\",\n\t\t},\n\t}\n\n\tschema := graphql.MustParseSchema(schemaString, resolver)\n\n\tquery := `\n\t\tquery {\n\t\t\tpost {\n\t\t\t\tid\n\t\t\t\ttitle\n\t\t\t}\n\t\t}\n\t`\n\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// output:\n\t// {\n\t//   \"data\": {\n\t//     \"post\": {\n\t//       \"id\": \"5\",\n\t//       \"title\": \"title\"\n\t//     }\n\t//   }\n\t// }\n}\n\nfunc ExampleMaxDepth() {\n\tschema := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.MaxDepth(3))\n\n\t// this query has a depth of 4\n\tquery := `\n\t  query {\n\t    hero(episode:EMPIRE) { # level 1\n\t      name                 # level 2\n\t      friends { \n\t        name               # level 3\n\t        friends { \n\t          id               # level 4 - this would exceed the max depth\n\t        }\n\t      }\n\t    }\n\t  }`\n\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// output:\n\t// {\n\t//   \"errors\": [\n\t//     {\n\t//       \"message\": \"Field \\\"id\\\" has depth 4 that exceeds max depth 3\",\n\t//       \"locations\": [\n\t//         {\n\t//           \"line\": 8,\n\t//           \"column\": 12\n\t//         }\n\t//       ]\n\t//     }\n\t//   ]\n\t// }\n}\n\nfunc ExampleMaxQueryLength() {\n\tschema := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.MaxQueryLength(50))\n\n\t// this query has a length of 53\n\tquery := `{\n\t  hero(episode:EMPIRE) {\n\t    id\n\t    name\n\t  }\n\t}`\n\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// output:\n\t// {\n\t//   \"errors\": [\n\t//     {\n\t//       \"message\": \"query length 53 exceeds the maximum allowed query length of 50 bytes\"\n\t//     }\n\t//   ]\n\t// }\n}\n\nfunc ExampleRestrictIntrospection() {\n\tallowKey := struct{}{}\n\t// only allow introspection if the function below returns true\n\tfilter := func(ctx context.Context) bool {\n\t\tallow, found := ctx.Value(allowKey).(bool)\n\t\treturn found && allow\n\t}\n\tschema := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.RestrictIntrospection(filter))\n\n\tquery := `{\n\t\t__type(name: \"Episode\") {\n\t\t\tenumValues {\n\t\t\t\tname\n\t\t\t}\n\t\t}\n\t}`\n\n\tcases := []struct {\n\t\tname string\n\t\tctx  context.Context\n\t}{\n\t\t{\n\t\t\tname: \"Empty context\",\n\t\t\tctx:  context.Background(),\n\t\t},\n\t\t{\n\t\t\tname: \"Introspection forbidden\",\n\t\t\tctx:  context.WithValue(context.Background(), allowKey, false),\n\t\t},\n\t\t{\n\t\t\tname: \"Introspection allowed\",\n\t\t\tctx:  context.WithValue(context.Background(), allowKey, true),\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tfmt.Println(c.name, \"result:\")\n\t\tres := schema.Exec(c.ctx, query, \"\", nil)\n\n\t\tenc := json.NewEncoder(os.Stdout)\n\t\tenc.SetIndent(\"\", \"  \")\n\t\terr := enc.Encode(res)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\t// output:\n\t// Empty context result:\n\t// {\n\t//   \"data\": {}\n\t// }\n\t// Introspection forbidden result:\n\t// {\n\t//   \"data\": {}\n\t// }\n\t// Introspection allowed result:\n\t// {\n\t//   \"data\": {\n\t//     \"__type\": {\n\t//       \"enumValues\": [\n\t//         {\n\t//           \"name\": \"NEWHOPE\"\n\t//         },\n\t//         {\n\t//           \"name\": \"EMPIRE\"\n\t//         },\n\t//         {\n\t//           \"name\": \"JEDI\"\n\t//         }\n\t//       ]\n\t//     }\n\t//   }\n\t// }\n}\n\nfunc ExampleSchema_AST() {\n\tschema := graphql.MustParseSchema(starwars.Schema, nil)\n\tast := schema.AST()\n\n\tfor _, e := range ast.Enums {\n\t\tfmt.Printf(\"Enum %q has the following options:\\n\", e.Name)\n\t\tfor _, o := range e.EnumValuesDefinition {\n\t\t\tfmt.Printf(\"  - %s\\n\", o.EnumValue)\n\t\t}\n\t}\n\t// output:\n\t// Enum \"Episode\" has the following options:\n\t//   - NEWHOPE\n\t//   - EMPIRE\n\t//   - JEDI\n\t// Enum \"LengthUnit\" has the following options:\n\t//   - METER\n\t//   - FOOT\n}\n\nfunc ExampleSchema_AST_generateEnum() {\n\ts := `\n\t\ttype Query {\n\t\t\tcurrentSeason: Season!\n\t\t}\n\n\t\t\"\"\"\n\t\tSeason represents a season of the year.\n\t\t\"\"\"\n\t\tenum Season {\n\t\t\tSPRING\n\t\t\tSUMMER\n\t\t\tAUTUMN\n\t\t\tWINTER\n\t\t}\n\t`\n\n\tgocode := `\n{{ $enum := . }}\n// {{ $enum.Desc }}\ntype {{ $enum.Name }} int\n\nconst (\n\t{{ range $i, $e :=  $enum.EnumValuesDefinition }}{{ if ne $i 0 }}{{ printf \"\\n\\t\" }}{{ end }}\n\t\t{{- $e.EnumValue | toVar }}{{ if eq $i 0 }} {{ $enum.Name }} = iota{{ end }}\n\t{{- end }}\n)\n\nvar {{ $enum.Name | toLower }}Items = [...]string{\n{{- range $i, $e :=  $enum.EnumValuesDefinition }}{{ if ne $i 0 }}{{ printf \", \" }}{{ end }}\n\t{{- $e.EnumValue | quote }}\n{{- end -}}\n}\n\nfunc (s {{ $enum.Name }}) String() string { return {{ $enum.Name | toLower }}Items[s] }\n\nfunc (s *{{ $enum.Name }}) Deserialize(str string) {\n\tvar found bool\n\tfor i, v := range {{ $enum.Name | toLower }}Items {\n\t\tif v == str {\n\t\t\tfound = true\n\t\t\t(*s) = {{ $enum.Name }}(i)\n\t\t}\n\t}\n\tif !found {\n\t\tpanic(\"invalid value for enum {{ $enum.Name }}: \" + str)\n\t}\n}\n\nfunc ({{ $enum.Name }}) ImplementsGraphQLType(name string) bool {\n\treturn name == {{ $enum.Name | quote }}\n}\n\nfunc (s *{{ $enum.Name }}) UnmarshalGraphQL(input interface{}) error {\n\tvar err error\n\tswitch input := input.(type) {\n\tcase string:\n\t\ts.Deserialize(input)\n\tdefault:\n\t\terr = fmt.Errorf(\"wrong type for {{ $enum.Name }}: %T\", input)\n\t}\n\treturn err\n}\n`\n\n\tfuncs := template.FuncMap{\n\t\t\"quote\": func(s string) string {\n\t\t\treturn `\"` + s + `\"`\n\t\t},\n\t\t\"toLower\": strings.ToLower,\n\t\t\"toVar\": func(s string) string {\n\t\t\tif len(s) == 0 {\n\t\t\t\treturn s\n\t\t\t}\n\t\t\treturn strings.ToUpper(s[:1]) + strings.ToLower(s[1:])\n\t\t},\n\t}\n\n\ttpl, err := template.New(\"enum\").Funcs(funcs).Parse(gocode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\topts := []graphql.SchemaOpt{\n\t\tgraphql.UseStringDescriptions(),\n\t}\n\tschema := graphql.MustParseSchema(s, nil, opts...)\n\tast := schema.AST()\n\tseasons := ast.Enums[0]\n\n\terr = tpl.Execute(os.Stdout, seasons)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// output:\n\t// // Season represents a season of the year.\n\t// type Season int\n\t//\n\t// const (\n\t//\tSpring Season = iota\n\t//\tSummer\n\t//\tAutumn\n\t//\tWinter\n\t// )\n\t//\n\t// var seasonItems = [...]string{\"SPRING\", \"SUMMER\", \"AUTUMN\", \"WINTER\"}\n\t//\n\t// func (s Season) String() string { return seasonItems[s] }\n\t//\n\t// func (s *Season) Deserialize(str string) {\n\t// \tvar found bool\n\t// \tfor i, v := range seasonItems {\n\t// \t\tif v == str {\n\t// \t\t\tfound = true\n\t// \t\t\t(*s) = Season(i)\n\t// \t\t}\n\t// \t}\n\t// \tif !found {\n\t// \t\tpanic(\"invalid value for enum Season: \" + str)\n\t// \t}\n\t// }\n\t//\n\t// func (Season) ImplementsGraphQLType(name string) bool {\n\t// \treturn name == \"Season\"\n\t// }\n\t//\n\t// func (s *Season) UnmarshalGraphQL(input interface{}) error {\n\t// \tvar err error\n\t// \tswitch input := input.(type) {\n\t// \tcase string:\n\t// \t\ts.Deserialize(input)\n\t// \tdefault:\n\t// \t\terr = fmt.Errorf(\"wrong type for Season: %T\", input)\n\t// \t}\n\t// \treturn err\n\t// }\n}\n\nfunc ExampleUseStringDescriptions() {\n\ts := `\n\tschema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\tpost(id: Int!): Post\n\t}\n\n\t\"\"\"\n\tPost represents a blog post.\n\t\"\"\"\n\ttype Post {\n\t\t\"Unique identifier of the post.\"\n\t\tid: ID!\n\n\t\t# The title field has no description.\n\t\ttitle: String!\n\n\t\t\"\"\"\n\t\tTags of the post.\n\t\t\"\"\"\n\t\t# tags can be empty\n\t\ttags: [String!]!\n\t}\n\t`\n\n\topts := []graphql.SchemaOpt{\n\t\tgraphql.UseStringDescriptions(),\n\t}\n\tschema := graphql.MustParseSchema(s, nil, opts...)\n\tast := schema.AST()\n\n\tpost := ast.Objects[1]\n\tfmt.Printf(\"Field descriptions of the %q type:\\n\", post.TypeName())\n\tfor _, f := range post.Fields {\n\t\tfmt.Printf(\"  field: %q, description: %q\\n\", f.Name, f.Desc)\n\t}\n\t// output:\n\t// Field descriptions of the \"Post\" type:\n\t//   field: \"id\", description: \"Unique identifier of the post.\"\n\t//   field: \"title\", description: \"\"\n\t//   field: \"tags\", description: \"Tags of the post.\"\n}\n\n// ExampleFieldTag demonstrates the use of the graphql field tag.\nfunc Example_resolverFieldTag() {\n\ttype resolver struct {\n\t\tHello           string\n\t\tHelloUnderscore string `graphql:\"_hello\"`\n\t\tHelloLower      string `graphql:\"hello\"`\n\t\tHelloTitle      string `graphql:\"Hello\"`\n\t\tHelloUpper      string `graphql:\"HELLO\"`\n\t}\n\n\tsdl := `\n\ttype Query {\n\t\t_hello: String!\n\t\thello: String!\n\t\tHello: String!\n\t\tHELLO: String!\n\t}`\n\n\tr := &resolver{\n\t\tHello:           \"This field is not used during query execution!\",\n\t\tHelloLower:      \"Hello, graphql!\",\n\t\tHelloTitle:      \"Hello, GraphQL!\",\n\t\tHelloUnderscore: \"Hello, _!\",\n\t\tHelloUpper:      \"Hello, GRAPHQL!\",\n\t}\n\n\tquery := `\n\t{\n\t\t_hello\n\t\thello\n\t\tHello\n\t\tHELLO\n\t}\n\t`\n\n\tschema := graphql.MustParseSchema(sdl, r, graphql.UseFieldResolvers())\n\tres := schema.Exec(context.Background(), query, \"\", nil)\n\n\tenc := json.NewEncoder(os.Stdout)\n\tenc.SetIndent(\"\", \"  \")\n\terr := enc.Encode(res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// output:\n\t// {\n\t//   \"data\": {\n\t//     \"_hello\": \"Hello, _!\",\n\t//     \"hello\": \"Hello, graphql!\",\n\t//     \"Hello\": \"Hello, GraphQL!\",\n\t//     \"HELLO\": \"Hello, GRAPHQL!\"\n\t//   }\n\t// }\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1787109375,
          "content": "module github.com/graph-gophers/graphql-go\n\ngo 1.16\n\nrequire (\n\tgithub.com/opentracing/opentracing-go v1.2.0\n\tgo.opentelemetry.io/otel v1.6.3\n\tgo.opentelemetry.io/otel/trace v1.6.3\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.193359375,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.2.3 h1:2DntVwHkVopvECVRSlL5PSo9eG+cAkDCuckLubN+rq0=\ngithub.com/go-logr/logr v1.2.3/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/google/go-cmp v0.5.7 h1:81/ik6ipDQS2aGcBfIN5dHDB36BwrStyeAQquSYCV4o=\ngithub.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=\ngithub.com/opentracing/opentracing-go v1.2.0 h1:uEJPy/1a5RIPAJ0Ov+OIO8OxWu77jEv+1B0VhjKrZUs=\ngithub.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.1 h1:5TQK59W5E3v0r2duFAb7P95B6hEeOyEnHRa8MjYSMTY=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngo.opentelemetry.io/otel v1.6.3 h1:FLOfo8f9JzFVFVyU+MSRJc2HdEAXQgm7pIv2uFKRSZE=\ngo.opentelemetry.io/otel v1.6.3/go.mod h1:7BgNga5fNlF/iZjG06hM3yofffp0ofKCDwSXx1GC4dI=\ngo.opentelemetry.io/otel/trace v1.6.3 h1:IqN4L+5b0mPNjdXIiZ90Ni4Bl5BRkDQywePLWemd9bc=\ngo.opentelemetry.io/otel/trace v1.6.3/go.mod h1:GNJQusJlUgZl9/TQBPKU/Y/ty+0iVB5fjhKeJGZPGFs=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gqltesting",
          "type": "tree",
          "content": null
        },
        {
          "name": "graphql.go",
          "type": "blob",
          "size": 13.576171875,
          "content": "package graphql\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go/ast\"\n\t\"github.com/graph-gophers/graphql-go/directives\"\n\t\"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/internal/common\"\n\t\"github.com/graph-gophers/graphql-go/internal/exec\"\n\t\"github.com/graph-gophers/graphql-go/internal/exec/resolvable\"\n\t\"github.com/graph-gophers/graphql-go/internal/exec/selected\"\n\t\"github.com/graph-gophers/graphql-go/internal/query\"\n\t\"github.com/graph-gophers/graphql-go/internal/schema\"\n\t\"github.com/graph-gophers/graphql-go/internal/validation\"\n\t\"github.com/graph-gophers/graphql-go/introspection\"\n\t\"github.com/graph-gophers/graphql-go/log\"\n\t\"github.com/graph-gophers/graphql-go/trace/noop\"\n\t\"github.com/graph-gophers/graphql-go/trace/tracer\"\n)\n\n// ParseSchema parses a GraphQL schema and attaches the given root resolver. It returns an error if\n// the Go type signature of the resolvers does not match the schema. If nil is passed as the\n// resolver, then the schema can not be executed, but it may be inspected (e.g. with [Schema.ToJSON] or [Schema.AST]).\nfunc ParseSchema(schemaString string, resolver interface{}, opts ...SchemaOpt) (*Schema, error) {\n\ts := &Schema{\n\t\tschema:         schema.New(),\n\t\tmaxParallelism: 10,\n\t\ttracer:         noop.Tracer{},\n\t\tlogger:         &log.DefaultLogger{},\n\t\tpanicHandler:   &errors.DefaultPanicHandler{},\n\t}\n\tfor _, opt := range opts {\n\t\topt(s)\n\t}\n\n\tif s.validationTracer == nil {\n\t\tif t, ok := s.tracer.(tracer.ValidationTracer); ok {\n\t\t\ts.validationTracer = t\n\t\t} else {\n\t\t\ts.validationTracer = &validationBridgingTracer{tracer: tracer.LegacyNoopValidationTracer{}} //nolint:staticcheck\n\t\t}\n\t}\n\n\tif err := schema.Parse(s.schema, schemaString, s.useStringDescriptions); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.validateSchema(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tr, err := resolvable.ApplyResolver(s.schema, resolver, s.directives, s.useFieldResolvers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.res = r\n\n\treturn s, nil\n}\n\n// MustParseSchema calls ParseSchema and panics on error.\nfunc MustParseSchema(schemaString string, resolver interface{}, opts ...SchemaOpt) *Schema {\n\ts, err := ParseSchema(schemaString, resolver, opts...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn s\n}\n\n// Schema represents a GraphQL schema with an optional resolver.\ntype Schema struct {\n\tschema *ast.Schema\n\tres    *resolvable.Schema\n\n\tallowIntrospection       func(ctx context.Context) bool\n\tdirectives               []directives.Directive\n\tmaxQueryLength           int\n\tmaxDepth                 int\n\tmaxParallelism           int\n\ttracer                   tracer.Tracer\n\tvalidationTracer         tracer.ValidationTracer\n\tlogger                   log.Logger\n\tpanicHandler             errors.PanicHandler\n\tuseStringDescriptions    bool\n\tsubscribeResolverTimeout time.Duration\n\tuseFieldResolvers        bool\n}\n\n// AST returns the abstract syntax tree of the GraphQL schema definition.\n// It in turn can be used by other tools such as validators or generators.\nfunc (s *Schema) AST() *ast.Schema {\n\treturn s.schema\n}\n\n// ASTSchema returns the abstract syntax tree of the GraphQL schema definition.\n//\n// Deprecated: use [Schema.AST] instead.\nfunc (s *Schema) ASTSchema() *ast.Schema {\n\treturn s.schema\n}\n\n// SchemaOpt is an option to pass to [ParseSchema] or [MustParseSchema].\ntype SchemaOpt func(*Schema)\n\n// UseStringDescriptions enables the usage of double quoted and triple quoted\n// strings as descriptions as per the [June 2018 spec]. When this is not enabled,\n// comments are parsed as descriptions instead.\n//\n// [June 2018 spec]: https://facebook.github.io/graphql/June2018/\nfunc UseStringDescriptions() SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.useStringDescriptions = true\n\t}\n}\n\n// UseFieldResolvers specifies whether to use struct fields as resolvers.\nfunc UseFieldResolvers() SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.useFieldResolvers = true\n\t}\n}\n\n// MaxDepth specifies the maximum field nesting depth in a query. The default is 0 which disables max depth checking.\nfunc MaxDepth(n int) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.maxDepth = n\n\t}\n}\n\n// MaxParallelism specifies the maximum number of resolvers per request allowed to run in parallel. The default is 10.\nfunc MaxParallelism(n int) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.maxParallelism = n\n\t}\n}\n\n// MaxQueryLength specifies the maximum allowed query length in bytes. The default is 0 which disables max length checking.\nfunc MaxQueryLength(n int) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.maxQueryLength = n\n\t}\n}\n\n// Tracer is used to trace queries and fields. It defaults to [noop.Tracer].\nfunc Tracer(t tracer.Tracer) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.tracer = t\n\t}\n}\n\n// ValidationTracer is used to trace validation errors. It defaults to [tracer.LegacyNoopValidationTracer].\n// Deprecated: context is needed to support tracing correctly. Use a tracer which implements [tracer.ValidationTracer].\nfunc ValidationTracer(tracer tracer.LegacyValidationTracer) SchemaOpt { //nolint:staticcheck\n\treturn func(s *Schema) {\n\t\ts.validationTracer = &validationBridgingTracer{tracer: tracer}\n\t}\n}\n\n// Logger is used to log panics during query execution. It defaults to [log.DefaultLogger].\nfunc Logger(logger log.Logger) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.logger = logger\n\t}\n}\n\n// PanicHandler is used to customize the panic errors during query execution.\n// It defaults to [errors.DefaultPanicHandler].\nfunc PanicHandler(panicHandler errors.PanicHandler) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.panicHandler = panicHandler\n\t}\n}\n\n// RestrictIntrospection accepts a filter func. If this function returns false the introspection is disabled, otherwise it is enabled.\n// If this option is not provided the introspection is enabled by default. This option is useful for allowing introspection only to admin users, for example:\n//\n//\tfilter := func(ctx context.Context) bool {\n//\t\tu, ok := user.FromContext(ctx)\n//\t\treturn ok && u.IsAdmin()\n//\t}\n//\n// Do not use it together with [DisableIntrospection], otherwise the option added last takes precedence.\nfunc RestrictIntrospection(fn func(ctx context.Context) bool) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.allowIntrospection = fn\n\t}\n}\n\n// DisableIntrospection disables introspection queries. This function is left for backwards compatibility reasons and is just a shorthand for:\n//\n//\tfilter := func(context.Context) bool {\n//\t   return false\n//\t}\n//\tgraphql.RestrictIntrospection(filter)\n//\n// Deprecated: use [RestrictIntrospection] filter instead. Do not use it together with [RestrictIntrospection], otherwise the option added last takes precedence.\nfunc DisableIntrospection() SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.allowIntrospection = func(context.Context) bool { return false }\n\t}\n}\n\n// SubscribeResolverTimeout is an option to control the amount of time\n// we allow for a single subscribe message resolver to complete it's job\n// before it times out and returns an error to the subscriber.\nfunc SubscribeResolverTimeout(timeout time.Duration) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.subscribeResolverTimeout = timeout\n\t}\n}\n\n// Directives defines the implementation for each directive.\n// Per the GraphQL specification, each Field Directive in the schema must have an implementation here.\nfunc Directives(ds ...directives.Directive) SchemaOpt {\n\treturn func(s *Schema) {\n\t\ts.directives = ds\n\t}\n}\n\n// Response represents a typical response of a GraphQL server. It may be encoded to JSON directly or\n// it may be further processed to a custom response type, for example to include custom error data.\n// Errors are intentionally serialized first based on the advice in the [spec].\n//\n// [spec]: https://github.com/facebook/graphql/commit/7b40390d48680b15cb93e02d46ac5eb249689876#diff-757cea6edf0288677a9eea4cfc801d87R107\ntype Response struct {\n\tErrors     []*errors.QueryError   `json:\"errors,omitempty\"`\n\tData       json.RawMessage        `json:\"data,omitempty\"`\n\tExtensions map[string]interface{} `json:\"extensions,omitempty\"`\n}\n\n// Validate validates the given query with the schema.\nfunc (s *Schema) Validate(queryString string) []*errors.QueryError {\n\treturn s.ValidateWithVariables(queryString, nil)\n}\n\n// ValidateWithVariables validates the given query with the schema and the input variables.\nfunc (s *Schema) ValidateWithVariables(queryString string, variables map[string]interface{}) []*errors.QueryError {\n\tdoc, qErr := query.Parse(queryString)\n\tif qErr != nil {\n\t\treturn []*errors.QueryError{qErr}\n\t}\n\n\treturn validation.Validate(s.schema, doc, variables, s.maxDepth)\n}\n\n// Exec executes the given query with the schema's resolver. It panics if the schema was created\n// without a resolver. If the context get cancelled, no further resolvers will be called and a\n// the context error will be returned as soon as possible (not immediately).\nfunc (s *Schema) Exec(ctx context.Context, queryString string, operationName string, variables map[string]interface{}) *Response {\n\tif !s.res.QueryResolver.IsValid() {\n\t\tpanic(\"schema created without resolver, can not exec\")\n\t}\n\treturn s.exec(ctx, queryString, operationName, variables, s.res)\n}\n\nfunc (s *Schema) exec(ctx context.Context, queryString string, operationName string, variables map[string]interface{}, res *resolvable.Schema) *Response {\n\tif s.maxQueryLength > 0 && len(queryString) > s.maxQueryLength {\n\t\treturn &Response{Errors: []*errors.QueryError{errors.Errorf(\"query length %d exceeds the maximum allowed query length of %d bytes\", len(queryString), s.maxQueryLength)}}\n\t}\n\tdoc, qErr := query.Parse(queryString)\n\tif qErr != nil {\n\t\treturn &Response{Errors: []*errors.QueryError{qErr}}\n\t}\n\n\tvalidationFinish := s.validationTracer.TraceValidation(ctx)\n\terrs := validation.Validate(s.schema, doc, variables, s.maxDepth)\n\tvalidationFinish(errs)\n\tif len(errs) != 0 {\n\t\treturn &Response{Errors: errs}\n\t}\n\n\top, err := getOperation(doc, operationName)\n\tif err != nil {\n\t\treturn &Response{Errors: []*errors.QueryError{errors.Errorf(\"%s\", err)}}\n\t}\n\n\t// If the optional \"operationName\" POST parameter is not provided then\n\t// use the query's operation name for improved tracing.\n\tif operationName == \"\" {\n\t\toperationName = op.Name.Name\n\t}\n\n\t// Subscriptions are not valid in Exec. Use schema.Subscribe() instead.\n\tif op.Type == query.Subscription {\n\t\treturn &Response{Errors: []*errors.QueryError{{Message: \"graphql-ws protocol header is missing\"}}}\n\t}\n\tif op.Type == query.Mutation {\n\t\tif _, ok := s.schema.RootOperationTypes[\"mutation\"]; !ok {\n\t\t\treturn &Response{Errors: []*errors.QueryError{{Message: \"no mutations are offered by the schema\"}}}\n\t\t}\n\t}\n\n\t// Fill in variables with the defaults from the operation\n\tif variables == nil {\n\t\tvariables = make(map[string]interface{}, len(op.Vars))\n\t}\n\tfor _, v := range op.Vars {\n\t\tif _, ok := variables[v.Name.Name]; !ok && v.Default != nil {\n\t\t\tvariables[v.Name.Name] = v.Default.Deserialize(nil)\n\t\t}\n\t}\n\n\tr := &exec.Request{\n\t\tRequest: selected.Request{\n\t\t\tDoc:                doc,\n\t\t\tVars:               variables,\n\t\t\tSchema:             s.schema,\n\t\t\tAllowIntrospection: s.allowIntrospection == nil || s.allowIntrospection(ctx), // allow introspection by default, i.e. when allowIntrospection is nil\n\t\t},\n\t\tLimiter:      make(chan struct{}, s.maxParallelism),\n\t\tTracer:       s.tracer,\n\t\tLogger:       s.logger,\n\t\tPanicHandler: s.panicHandler,\n\t}\n\tvarTypes := make(map[string]*introspection.Type)\n\tfor _, v := range op.Vars {\n\t\tt, err := common.ResolveType(v.Type, s.schema.Resolve)\n\t\tif err != nil {\n\t\t\treturn &Response{Errors: []*errors.QueryError{err}}\n\t\t}\n\t\tvarTypes[v.Name.Name] = introspection.WrapType(t)\n\t}\n\ttraceCtx, finish := s.tracer.TraceQuery(ctx, queryString, operationName, variables, varTypes)\n\tdata, errs := r.Execute(traceCtx, res, op)\n\tfinish(errs)\n\n\treturn &Response{\n\t\tData:   data,\n\t\tErrors: errs,\n\t}\n}\n\nfunc (s *Schema) validateSchema() error {\n\t// https://graphql.github.io/graphql-spec/June2018/#sec-Root-Operation-Types\n\t// > The query root operation type must be provided and must be an Object type.\n\tif err := validateRootOp(s.schema, \"query\", true); err != nil {\n\t\treturn err\n\t}\n\t// > The mutation root operation type is optional; if it is not provided, the service does not support mutations.\n\t// > If it is provided, it must be an Object type.\n\tif err := validateRootOp(s.schema, \"mutation\", false); err != nil {\n\t\treturn err\n\t}\n\t// > Similarly, the subscription root operation type is also optional; if it is not provided, the service does not\n\t// > support subscriptions. If it is provided, it must be an Object type.\n\tif err := validateRootOp(s.schema, \"subscription\", false); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\ntype validationBridgingTracer struct {\n\ttracer tracer.LegacyValidationTracer //nolint:staticcheck\n}\n\nfunc (t *validationBridgingTracer) TraceValidation(context.Context) func([]*errors.QueryError) {\n\treturn t.tracer.TraceValidation()\n}\n\nfunc validateRootOp(s *ast.Schema, name string, mandatory bool) error {\n\tt, ok := s.RootOperationTypes[name]\n\tif !ok {\n\t\tif mandatory {\n\t\t\treturn fmt.Errorf(\"root operation %q must be defined\", name)\n\t\t}\n\t\treturn nil\n\t}\n\tif t.Kind() != \"OBJECT\" {\n\t\treturn fmt.Errorf(\"root operation %q must be an OBJECT\", name)\n\t}\n\treturn nil\n}\n\nfunc getOperation(document *ast.ExecutableDefinition, operationName string) (*ast.OperationDefinition, error) {\n\tif len(document.Operations) == 0 {\n\t\treturn nil, fmt.Errorf(\"no operations in query document\")\n\t}\n\n\tif operationName == \"\" {\n\t\tif len(document.Operations) > 1 {\n\t\t\treturn nil, fmt.Errorf(\"more than one operation in query document and no operation name given\")\n\t\t}\n\t\tfor _, op := range document.Operations {\n\t\t\treturn op, nil // return the one and only operation\n\t\t}\n\t}\n\n\top := document.Operations.Get(operationName)\n\tif op == nil {\n\t\treturn nil, fmt.Errorf(\"no operation with name %q\", operationName)\n\t}\n\treturn op, nil\n}\n"
        },
        {
          "name": "graphql_test.go",
          "type": "blob",
          "size": 106.87109375,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/directives\"\n\tgqlerrors \"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/example/social\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n\t\"github.com/graph-gophers/graphql-go/gqltesting\"\n\t\"github.com/graph-gophers/graphql-go/introspection\"\n\t\"github.com/graph-gophers/graphql-go/trace/tracer\"\n)\n\ntype helloWorldResolver1 struct{}\n\nfunc (r *helloWorldResolver1) Hello() string {\n\treturn \"Hello world!\"\n}\n\ntype helloWorldResolver2 struct{}\n\nfunc (r *helloWorldResolver2) Hello(ctx context.Context) (string, error) {\n\treturn \"Hello world!\", nil\n}\n\ntype helloSnakeResolver1 struct{}\n\nfunc (r *helloSnakeResolver1) HelloHTML() string {\n\treturn \"Hello snake!\"\n}\n\nfunc (r *helloSnakeResolver1) SayHello(args struct{ FullName string }) string {\n\treturn \"Hello \" + args.FullName + \"!\"\n}\n\ntype helloSnakeResolver2 struct{}\n\nfunc (r *helloSnakeResolver2) HelloHTML(ctx context.Context) (string, error) {\n\treturn \"Hello snake!\", nil\n}\n\nfunc (r *helloSnakeResolver2) SayHello(ctx context.Context, args struct{ FullName string }) (string, error) {\n\treturn \"Hello \" + args.FullName + \"!\", nil\n}\n\ntype structFieldResolver struct {\n\tHello string\n}\n\n// customInvalidDirective lacks any valid directive functions.\ntype customInvalidDirective struct {\n\tCustomAttribute *string\n}\n\nfunc (c customInvalidDirective) ImplementsDirective() string {\n\treturn \"customDirective\"\n}\n\ntype customDirectiveVisitor struct {\n\tCustomAttribute *string\n}\n\nfunc (v *customDirectiveVisitor) ImplementsDirective() string {\n\treturn \"customDirective\"\n}\n\nfunc (v *customDirectiveVisitor) Resolve(ctx context.Context, args interface{}, next directives.Resolver) (output interface{}, err error) {\n\toutput, err = next.Resolve(ctx, args)\n\tif err != nil {\n\t\treturn output, err\n\t}\n\n\tif v.CustomAttribute != nil {\n\t\treturn fmt.Sprintf(\"Directive (with arg '%s') modified result: %s\", *v.CustomAttribute, output.(string)), nil\n\t}\n\treturn fmt.Sprintf(\"Directive modified result: %s\", output.(string)), nil\n}\n\ntype cachedDirectiveVisitor struct {\n\tKey string\n}\n\nfunc (v *cachedDirectiveVisitor) ImplementsDirective() string {\n\treturn \"cached\"\n}\n\nfunc (v *cachedDirectiveVisitor) Resolve(context.Context, interface{}, directives.Resolver) (output interface{}, err error) {\n\t// Bypasses resolver, returns a \"cached\" value directly\n\treturn \"valueFromCache\", nil\n}\n\ntype cachedDirectiveResolver struct {\n\tt *testing.T\n}\n\nfunc (r *cachedDirectiveResolver) Hello(ctx context.Context, args struct{ FullName string }) string {\n\tr.t.Error(\"expected cached resolver to not be called, but it was\")\n\n\treturn \"\"\n}\n\ntype theNumberResolver struct {\n\tnumber int32\n}\n\nfunc (r *theNumberResolver) TheNumber() int32 {\n\treturn r.number\n}\n\nfunc (r *theNumberResolver) ChangeTheNumber(args struct{ NewNumber int32 }) *theNumberResolver {\n\tr.number = args.NewNumber\n\treturn r\n}\n\ntype timeResolver struct{}\n\nfunc (r *timeResolver) AddHour(args struct{ Time graphql.Time }) graphql.Time {\n\treturn graphql.Time{Time: args.Time.Add(time.Hour)}\n}\n\ntype echoResolver struct{}\n\nfunc (r *echoResolver) Echo(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nvar starwarsSchema = graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{})\n\ntype ResolverError interface {\n\terror\n\tExtensions() map[string]interface{}\n}\n\ntype resolverNotFoundError struct {\n\tCode    string `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc (e resolverNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"Error [%s]: %s\", e.Code, e.Message)\n}\n\nfunc (e resolverNotFoundError) Extensions() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"code\":    e.Code,\n\t\t\"message\": e.Message,\n\t}\n}\n\nvar (\n\tdroidNotFoundError = resolverNotFoundError{\n\t\tCode:    \"NotFound\",\n\t\tMessage: \"This is not the droid you are looking for\",\n\t}\n\terrQuote = errors.New(\"bleep bloop\")\n\n\tr2d2          = &droidResolver{name: \"R2-D2\"}\n\tc3po          = &droidResolver{name: \"C-3PO\"}\n\tnotFoundDroid = &droidResolver{err: droidNotFoundError}\n)\n\ntype findDroidsResolver struct{}\n\nfunc (r *findDroidsResolver) FindDroids(ctx context.Context) []*droidResolver {\n\treturn []*droidResolver{r2d2, notFoundDroid, c3po}\n}\n\nfunc (r *findDroidsResolver) FindNilDroids(ctx context.Context) *[]*droidResolver {\n\treturn &[]*droidResolver{r2d2, nil, c3po}\n}\n\ntype findDroidOrHumanResolver struct{}\n\nfunc (r *findDroidOrHumanResolver) FindHuman(ctx context.Context) (*string, error) {\n\thuman := \"human\"\n\treturn &human, nil\n}\n\nfunc (r *findDroidOrHumanResolver) FindDroid(ctx context.Context) (*droidResolver, error) {\n\treturn nil, notFoundDroid.err\n}\n\ntype droidResolver struct {\n\tname string\n\terr  error\n}\n\nfunc (d *droidResolver) Name() (string, error) {\n\tif d.err != nil {\n\t\treturn \"\", d.err\n\t}\n\treturn d.name, nil\n}\n\nfunc (d *droidResolver) Quotes() ([]string, error) {\n\tswitch d.name {\n\tcase r2d2.name:\n\t\treturn nil, errQuote\n\tcase c3po.name:\n\t\treturn []string{\"We're doomed!\", \"R2-D2, where are you?\"}, nil\n\t}\n\treturn nil, nil\n}\n\ntype discussPlanResolver struct{}\n\nfunc (r *discussPlanResolver) DismissVader(ctx context.Context) (string, error) {\n\treturn \"\", errors.New(\"I find your lack of faith disturbing\")\n}\n\nfunc TestHelloWorld(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &helloWorldResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &helloWorldResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestHelloWorldStructFieldResolver(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`,\n\t\t\t\t&structFieldResolver{Hello: \"Hello world!\"},\n\t\t\t\tgraphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype wrapDirective struct {\n\tPrefix string\n\tSuffix string\n}\n\nfunc (w *wrapDirective) ImplementsDirective() string {\n\treturn \"wrap\"\n}\n\nfunc (w *wrapDirective) Resolve(ctx context.Context, in interface{}, next directives.Resolver) (out interface{}, err error) {\n\tout, err = next.Resolve(ctx, in)\n\tif err != nil {\n\t\treturn out, err\n\t}\n\n\t// only alter output in case prefix or suffix are present\n\tif w.Prefix == \"\" && w.Suffix == \"\" {\n\t\treturn out, err\n\t}\n\n\t// only modify string outputs\n\tswitch val := out.(type) {\n\tcase string:\n\t\treturn w.Prefix + val + w.Suffix, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"expected string output, got %T\", val)\n\t}\n}\n\nfunc TestCustomDirective(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @customDirective on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String! @customDirective\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{},\n\t\t\t\tgraphql.Directives(&customDirectiveVisitor{})),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Directive modified result: Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @customDirective(\n\t\t\t\t\tcustomAttribute: String\n\t\t\t    ) on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String! @customDirective(customAttribute: \"hi\")\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{},\n\t\t\t\tgraphql.Directives(&customDirectiveVisitor{})),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Johnny\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Directive (with arg 'hi') modified result: Hello Johnny!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @cached(\n\t\t\t\t\tkey: String!\n\t\t\t    ) on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello(full_name: String!): String! @cached(key: \"notcheckedintest\")\n\t\t\t\t}\n\t\t\t`, &cachedDirectiveResolver{t: t},\n\t\t\t\tgraphql.Directives(&cachedDirectiveVisitor{})),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello(full_name: \"Full Name\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"valueFromCache\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @wrap(prefix: String!, suffix: String!) repeatable on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @wrap(prefix: \"[\", suffix: \"]\") @wrap(prefix: \"{\", suffix: \"}\")\n\t\t\t\t}`,\n\t\t\t\t&helloResolver{},\n\t\t\t\tgraphql.Directives(&wrapDirective{}),\n\t\t\t),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"{[Hello world!]}\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @wrap(prefix: String!, suffix: String!) on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @wrap(prefix: \"~*\", suffix: \"*~\") @deprecated(reason: \"Testing a custom directive together with @deprecated.\")\n\t\t\t\t}`,\n\t\t\t\t&helloResolver{},\n\t\t\t\tgraphql.Directives(&wrapDirective{}),\n\t\t\t),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello @skip(if: false)\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"~*Hello world!*~\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\t# this test ensures that directives without a Go visitor counterpart are allowed\n\t\t\t\tdirective @awesome on FIELD_DEFINITION\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @awesome\n\t\t\t\t}`,\n\t\t\t\t&helloResolver{},\n\t\t\t),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestCustomValidatingDirective(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @hasRole(role: String!) on FIELD_DEFINITION\n\t\t\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @hasRole(role: \"ADMIN\")\n\t\t\t\t}`,\n\t\t\t\t&helloResolver{},\n\t\t\t\tgraphql.Directives(&HasRoleDirective{}),\n\t\t\t),\n\t\t\tContext: context.WithValue(context.Background(), RoleKey, \"USER\"),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: \"null\",\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{Message: `access denied, role \"ADMIN\" required`, Locations: []gqlerrors.Location{{Line: 9, Column: 6}}, Path: []interface{}{\"hello\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @hasRole(role: String!) on FIELD_DEFINITION\n\t\t\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @hasRole(role: \"ADMIN\")\n\t\t\t\t}`,\n\t\t\t\t&helloResolver{},\n\t\t\t\tgraphql.Directives(&HasRoleDirective{}),\n\t\t\t),\n\t\t\tContext: context.WithValue(context.Background(), RoleKey, \"ADMIN\"),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(\n\t\t\t\t`directive @hasRole(role: String!) on FIELD_DEFINITION\n\n\t\t\t\t`+strings.ReplaceAll(\n\t\t\t\t\tsocial.Schema,\n\t\t\t\t\t\"role: Role!\",\n\t\t\t\t\t`role: Role! @hasRole(role: \"ADMIN\")`,\n\t\t\t\t),\n\t\t\t\t&social.Resolver{},\n\t\t\t\tgraphql.Directives(&HasRoleDirective{}),\n\t\t\t\tgraphql.UseFieldResolvers(),\n\t\t\t),\n\t\t\tContext: context.WithValue(context.Background(), RoleKey, \"ADMIN\"),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tuser(id: \"0x01\") {\n\t\t\t\t\t\trole\n\t\t\t\t\t\t... on User {\n\t\t\t\t\t\t\temail\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Person {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"user\": {\n\t\t\t\t\t\t\"role\": \"ADMIN\",\n\t\t\t\t\t\t\"email\": \"Albus@hogwarts.com\",\n\t\t\t\t\t\t\"name\": \"Albus Dumbledore\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(\n\t\t\t\t`directive @hasRole(role: String!) on FIELD_DEFINITION\n\n\t\t\t\t`+strings.ReplaceAll(\n\t\t\t\t\tstarwars.Schema,\n\t\t\t\t\t\"hero(episode: Episode = NEWHOPE): Character\",\n\t\t\t\t\t`hero(episode: Episode = NEWHOPE): Character @hasRole(role: \"REBELLION\")`,\n\t\t\t\t),\n\t\t\t\t&starwars.Resolver{},\n\t\t\t\tgraphql.Directives(&HasRoleDirective{}),\n\t\t\t),\n\t\t\tContext: context.WithValue(context.Background(), RoleKey, \"EMPIRE\"),\n\t\t\tQuery: `\n\t\t\t\tquery HeroesOfTheRebellion($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tid name\n\t\t\t\t\t\t... on Human { starships { id name } }\n\t\t\t\t\t\t... on Droid { primaryFunction }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables:      map[string]interface{}{\"episode\": \"NEWHOPE\"},\n\t\t\tExpectedResult: \"null\",\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{Message: `access denied, role \"REBELLION\" required`, Locations: []gqlerrors.Location{{Line: 10, Column: 3}}, Path: []interface{}{\"hero\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(\n\t\t\t\t`directive @hasRole(role: String!) on FIELD_DEFINITION\n\n\t\t\t\t`+strings.ReplaceAll(\n\t\t\t\t\tstarwars.Schema,\n\t\t\t\t\t\"starships: [Starship]\",\n\t\t\t\t\t`starships: [Starship] @hasRole(role: \"REBELLION\")`,\n\t\t\t\t),\n\t\t\t\t&starwars.Resolver{},\n\t\t\t\tgraphql.Directives(&HasRoleDirective{}),\n\t\t\t),\n\t\t\tContext: context.WithValue(context.Background(), RoleKey, \"EMPIRE\"),\n\t\t\tQuery: `\n\t\t\t\tquery HeroesOfTheRebellion($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tid name\n\t\t\t\t\t\t... on Human { starships { id name } }\n\t\t\t\t\t\t... on Droid { primaryFunction }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables:      map[string]interface{}{\"episode\": \"NEWHOPE\"},\n\t\t\tExpectedResult: \"null\",\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{Message: `access denied, role \"REBELLION\" required`, Locations: []gqlerrors.Location{{Line: 68, Column: 3}}, Path: []interface{}{\"hero\", \"starships\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(\n\t\t\t\t`directive @restrictImperialUnits on FIELD_DEFINITION\n\n\t\t\t\t`+strings.ReplaceAll(\n\t\t\t\t\tstarwars.Schema,\n\t\t\t\t\t\"height(unit: LengthUnit = METER): Float!\",\n\t\t\t\t\t`height(unit: LengthUnit = METER): Float! @restrictImperialUnits`,\n\t\t\t\t),\n\t\t\t\t&starwars.Resolver{},\n\t\t\t\tgraphql.Directives(&restrictImperialUnitsDirective{}),\n\t\t\t),\n\t\t\tContext: context.WithValue(context.Background(), RoleKey, \"REBELLION\"),\n\t\t\tQuery: `\n\t\t\t\tquery HeroesOfTheRebellion($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tid name\n\t\t\t\t\t\t... on Human { height(unit: FOOT) }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables:      map[string]interface{}{\"episode\": \"NEWHOPE\"},\n\t\t\tExpectedResult: \"null\",\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{Message: `rebels cannot request imperial units`, Locations: []gqlerrors.Location{{Line: 58, Column: 3}}, Path: []interface{}{\"hero\", \"height\"}},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype restrictImperialUnitsDirective struct{}\n\nfunc (d *restrictImperialUnitsDirective) ImplementsDirective() string {\n\treturn \"restrictImperialUnits\"\n}\n\nfunc (d *restrictImperialUnitsDirective) Validate(ctx context.Context, args interface{}) error {\n\tif ctx.Value(RoleKey) == \"EMPIRE\" {\n\t\treturn nil\n\t}\n\n\tv, ok := args.(struct {\n\t\tUnit string\n\t})\n\tif ok && v.Unit == \"FOOT\" {\n\t\treturn fmt.Errorf(\"rebels cannot request imperial units\")\n\t}\n\n\treturn nil\n}\n\nfunc TestCustomDirectiveStructFieldResolver(t *testing.T) {\n\tt.Parallel()\n\n\tschemaOpt := []graphql.SchemaOpt{\n\t\tgraphql.Directives(&customDirectiveVisitor{}),\n\t\tgraphql.UseFieldResolvers(),\n\t}\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @customDirective on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @customDirective\n\t\t\t\t}\n\t\t\t`, &structFieldResolver{Hello: \"Hello world!\"}, schemaOpt...),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Directive modified result: Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @customDirective(\n\t\t\t\t\tcustomAttribute: String\n\t\t\t    ) on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @customDirective(customAttribute: \"hi\")\n\t\t\t\t}\n\t\t\t`, &structFieldResolver{Hello: \"Hello world!\"}, schemaOpt...),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Directive (with arg 'hi') modified result: Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @wrap(prefix: String!, suffix: String!) repeatable on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @wrap(prefix: \"[\", suffix: \"]\") @wrap(prefix: \"{\", suffix: \"}\")\n\t\t\t\t}`,\n\t\t\t\t&structFieldResolver{Hello: \"Hello world!\"},\n\t\t\t\tgraphql.Directives(&wrapDirective{}),\n\t\t\t\tgraphql.UseFieldResolvers(),\n\t\t\t),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"{[Hello world!]}\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @wrap(prefix: String!, suffix: String!) on FIELD_DEFINITION\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String! @wrap(prefix: \"~*\", suffix: \"*~\") @deprecated(reason: \"Testing a custom directive together with @deprecated.\")\n\t\t\t\t}`,\n\t\t\t\t&structFieldResolver{Hello: \"Hello world!\"},\n\t\t\t\tgraphql.Directives(&wrapDirective{}),\n\t\t\t\tgraphql.UseFieldResolvers(),\n\t\t\t),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello @include(if: true)\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"~*Hello world!*~\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tdirective @customDirective on FIELD_DEFINITION | INPUT_FIELD_DEFINITION\n\t\t\t\tdirective @upper on ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE\n\t\t\t\tdirective @join on OBJECT | INTERFACE | UNION \n\t\t\t\tdirective @polite on FIELD | FRAGMENT_SPREAD\n\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsayHello(fullName: String! @upper): String! @customDirective\n\t\t\t\t}`,\n\t\t\t\t&helloSnakeResolver1{},\n\t\t\t\tgraphql.Directives(&customDirectiveVisitor{}),\n\t\t\t),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsayHello(fullName: \"friend\") @polite\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"sayHello\": \"Directive modified result: Hello friend!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestParseSchemaWithInvalidCustomDirectives(t *testing.T) {\n\tt.Parallel()\n\n\ttype args struct {\n\t\tDirectives []directives.Directive\n\t\tResolver   interface{}\n\t\tSchema     string\n\t}\n\n\ttype want struct {\n\t\tError string\n\t}\n\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\n\t\t\"Duplicate directive implementations\": {\n\t\t\tArgs: args{\n\t\t\t\tDirectives: []directives.Directive{&customDirectiveVisitor{}, &customInvalidDirective{}},\n\t\t\t\tResolver:   &helloSnakeResolver1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tdirective @customDirective on FIELD_DEFINITION\n\t\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello_html: String! @customDirective\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `multiple implementations registered for directive \"customDirective\". Implementation types *graphql_test.customDirectiveVisitor and *graphql_test.customInvalidDirective`},\n\t\t},\n\t\t\"Missing directive visitor function\": {\n\t\t\tArgs: args{\n\t\t\t\tDirectives: []directives.Directive{&customInvalidDirective{}},\n\t\t\t\tResolver:   &helloSnakeResolver1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tdirective @customDirective on FIELD_DEFINITION\n\t\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello_html: String! @customDirective\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `directive \"customDirective\" (implemented by *graphql_test.customInvalidDirective) does not implement a valid directive visitor function`},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, tt.Args.Resolver, graphql.Directives(tt.Args.Directives...))\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Logf(\"got:  %v\", err)\n\t\t\t\tt.Logf(\"want: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHelloSnake(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestHelloSnakeArguments(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Rob Pike\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Hello Rob Pike!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Rob Pike\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Hello Rob Pike!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestRootOperations_invalidSchema(t *testing.T) {\n\ttype args struct {\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Empty schema\": {\n\t\t\tWant: want{Error: `root operation \"query\" must be defined`},\n\t\t},\n\t\t\"Query declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Query\" not found`},\n\t\t},\n\t\t\"Query as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"query\" must be an OBJECT`},\n\t\t},\n\t\t\"Query with custom name, schema omitted\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\ttype QueryType {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"query\" must be defined`},\n\t\t},\n\t\t\"Mutation as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tmutation: String\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\tthing: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"mutation\" must be an OBJECT`},\n\t\t},\n\t\t\"Mutation declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tmutation: Mutation\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Mutation\" not found`},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, nil)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Logf(\"got:  %v\", err)\n\t\t\t\tt.Logf(\"want: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRootOperations_validSchema(t *testing.T) {\n\ttype resolver struct {\n\t\thelloSaidResolver\n\t\thelloWorldResolver1\n\t\ttheNumberResolver\n\t}\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\t// Query only, default name with `schema` omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query only, default name with `schema` present\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query only, custom name\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: QueryType\n\t\t\t\t}\n\t\t\t\ttype QueryType {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query+Mutation, default names with `schema` omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"changeTheNumber\": {\"theNumber\": 1}}`,\n\t\t},\n\t\t{\n\t\t\t// Query+Mutation, custom names\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: QueryType\n\t\t\t\t\tmutation: MutationType\n\t\t\t\t}\n\t\t\t\ttype QueryType {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype MutationType {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"changeTheNumber\": {\"theNumber\": 1}}`,\n\t\t},\n\t\t{\n\t\t\t// Mutation with custom name, schema omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype MutationType {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{Message: \"no mutations are offered by the schema\"}},\n\t\t},\n\t\t{\n\t\t\t// Explicit schema without mutation field\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{Message: \"no mutations are offered by the schema\"}},\n\t\t},\n\t})\n}\n\nfunc TestBasic(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tid\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"id\": \"2001\",\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testEmbeddedStructResolver struct{}\n\nfunc (*testEmbeddedStructResolver) Course() courseResolver {\n\treturn courseResolver{\n\t\tCourseMeta: CourseMeta{\n\t\t\tName:       \"Biology\",\n\t\t\tTimestamps: Timestamps{CreatedAt: \"yesterday\", UpdatedAt: \"today\"},\n\t\t},\n\t\tInstructor: Instructor{Name: \"Socrates\"},\n\t}\n}\n\ntype courseResolver struct {\n\tCourseMeta\n\tInstructor Instructor\n}\n\ntype CourseMeta struct {\n\tName string\n\tTimestamps\n}\n\ntype Instructor struct {\n\tName string\n}\n\ntype Timestamps struct {\n\tCreatedAt string\n\tUpdatedAt string\n}\n\nfunc TestEmbeddedStruct(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tcourse: Course!\n\t\t\t\t}\n\n\t\t\t\ttype Course {\n\t\t\t\t\tname: String!\n\t\t\t\t\tcreatedAt: String!\n\t\t\t\t\tupdatedAt: String!\n\t\t\t\t\tinstructor: Instructor!\n\t\t\t\t}\n\n\t\t\t\ttype Instructor {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &testEmbeddedStructResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tcourse{\n\t\t\t\t\t\tname\n\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\tinstructor {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"course\": {\n\t\t\t\t\t\t\"name\": \"Biology\",\n\t\t\t\t\t\t\"createdAt\": \"yesterday\",\n\t\t\t\t\t\t\"updatedAt\": \"today\",\n\t\t\t\t\t\t\"instructor\": {\n\t\t\t\t\t\t\t\"name\":\"Socrates\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testNilInterfaceResolver struct{}\n\nfunc (r *testNilInterfaceResolver) A() interface{ Z() int32 } {\n\treturn nil\n}\n\nfunc (r *testNilInterfaceResolver) B() (interface{ Z() int32 }, error) {\n\treturn nil, errors.New(\"x\")\n}\n\nfunc (r *testNilInterfaceResolver) C() (interface{ Z() int32 }, error) {\n\treturn nil, nil\n}\n\nfunc TestNilInterface(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ta: T\n\t\t\t\t\tb: T\n\t\t\t\t\tc: T\n\t\t\t\t}\n\n\t\t\t\ttype T {\n\t\t\t\t\tz: Int!\n\t\t\t\t}\n\t\t\t`, &testNilInterfaceResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta { z }\n\t\t\t\t\tb { z }\n\t\t\t\t\tc { z }\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": null,\n\t\t\t\t\t\"b\": null,\n\t\t\t\t\t\"c\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       \"x\",\n\t\t\t\t\tPath:          []interface{}{\"b\"},\n\t\t\t\t\tResolverError: errors.New(\"x\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorPropagationInLists(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid!]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 1, \"name\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findDroids\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 1, \"name\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid!]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Droid\"`,\n\t\t\t\t\tPath:    []interface{}{\"findNilDroids\", 1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tquotes: [String!]!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tquotes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findDroids\": [\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"quotes\": []\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"quotes\": [\n\t\t\t\t\t\t\t\t\"We're doomed!\",\n\t\t\t\t\t\t\t\t\"R2-D2, where are you?\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       errQuote.Error(),\n\t\t\t\t\tResolverError: errQuote,\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 0, \"quotes\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid!]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t\tquotes: [String!]!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tquotes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       errQuote.Error(),\n\t\t\t\t\tResolverError: errQuote,\n\t\t\t\t\tPath:          []interface{}{\"findNilDroids\", 0, \"quotes\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Droid\"`,\n\t\t\t\t\tPath:    []interface{}{\"findNilDroids\", 1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorWithExtensions(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tFindDroid: Droid!\n\t\t\t\t\tFindHuman: String\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tName: String!\n\t\t\t\t}\n\t\t\t`, &findDroidOrHumanResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tFindDroid {\n\t\t\t\t\t\tName\n\t\t\t\t\t}\n\t\t\t\t\tFindHuman\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"FindDroid\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorWithNoExtensions(t *testing.T) {\n\tt.Parallel()\n\n\terr := errors.New(\"I find your lack of faith disturbing\")\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tDismissVader: String!\n\t\t\t\t}\n\t\t\t`, &discussPlanResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tDismissVader\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       err.Error(),\n\t\t\t\t\tPath:          []interface{}{\"DismissVader\"},\n\t\t\t\t\tResolverError: err,\n\t\t\t\t\tExtensions:    nil,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestArguments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\theight\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\theight(unit: FOOT)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 5.6430448\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestAliases(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tempireHero: hero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\tjediHero: hero(episode: JEDI) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"empireHero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t},\n\t\t\t\t\t\"jediHero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tleftComparison: hero(episode: EMPIRE) {\n\t\t\t\t\t\t...comparisonFields\n\t\t\t\t\t\t...height\n\t\t\t\t\t}\n\t\t\t\t\trightComparison: hero(episode: JEDI) {\n\t\t\t\t\t\t...comparisonFields\n\t\t\t\t\t\t...height\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment comparisonFields on Character {\n\t\t\t\t\tname\n\t\t\t\t\tappearsIn\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment height on Human {\n\t\t\t\t\theight\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"leftComparison\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"appearsIn\": [\n\t\t\t\t\t\t\t\"NEWHOPE\",\n\t\t\t\t\t\t\t\"EMPIRE\",\n\t\t\t\t\t\t\t\"JEDI\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t},\n\t\t\t\t\t\"rightComparison\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"appearsIn\": [\n\t\t\t\t\t\t\t\"NEWHOPE\",\n\t\t\t\t\t\t\t\"EMPIRE\",\n\t\t\t\t\t\t\t\"JEDI\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tid\n\t\t\t\t\t\tmass\n\t\t\t\t\t\t...characterInfo\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfragment characterInfo on Character {\n\t\t\t\t\tname\n\t\t\t\t\t...on Droid {\n\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t}\n\t\t\t\t\t...on Human {\n\t\t\t\t\t\theight\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"id\": \"1000\",\n\t\t\t\t\t\t\"mass\": 77,\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestVariables(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroNameAndFriends($episode: Episode) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"JEDI\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroNameAndFriends($episode: Episode) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"EMPIRE\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\techo(value: String): String\n\t\t\t\t}\n\t\t\t`, &echoResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Echo($value:String = \"default\"){\n\t\t\t\t\techo(value:$value)\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"echo\": \"default\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestSkipDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withoutFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends @skip(if: $withoutFriends) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":        \"JEDI\",\n\t\t\t\t\"withoutFriends\": true,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withoutFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends @skip(if: $withoutFriends) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":        \"JEDI\",\n\t\t\t\t\"withoutFriends\": false,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestIncludeDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsFragment @include(if: $withFriends)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsFragment on Character {\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":     \"JEDI\",\n\t\t\t\t\"withFriends\": false,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsFragment @include(if: $withFriends)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsFragment on Character {\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":     \"JEDI\",\n\t\t\t\t\"withFriends\": true,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testDeprecatedDirectiveResolver struct{}\n\nfunc (r *testDeprecatedDirectiveResolver) A() int32 {\n\treturn 0\n}\n\nfunc (r *testDeprecatedDirectiveResolver) B() int32 {\n\treturn 0\n}\n\nfunc (r *testDeprecatedDirectiveResolver) C() int32 {\n\treturn 0\n}\n\nfunc TestDeprecatedDirective(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ta: Int!\n\t\t\t\t\tb: Int! @deprecated\n\t\t\t\t\tc: Int! @deprecated(reason: \"We don't like it\")\n\t\t\t\t}\n\t\t\t`, &testDeprecatedDirectiveResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Query\") {\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallFields: fields(includeDeprecated: true) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tisDeprecated\n\t\t\t\t\t\t\tdeprecationReason\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t{ \"name\": \"a\" }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"allFields\": [\n\t\t\t\t\t\t\t{ \"name\": \"a\", \"isDeprecated\": false, \"deprecationReason\": null },\n\t\t\t\t\t\t\t{ \"name\": \"b\", \"isDeprecated\": true, \"deprecationReason\": \"No longer supported\" },\n\t\t\t\t\t\t\t{ \"name\": \"c\", \"isDeprecated\": true, \"deprecationReason\": \"We don't like it\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t}\n\n\t\t\t\tenum Test {\n\t\t\t\t\tA\n\t\t\t\t\tB @deprecated\n\t\t\t\t\tC @deprecated(reason: \"We don't like it\")\n\t\t\t\t}\n\t\t\t`, &testDeprecatedDirectiveResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Test\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallEnumValues: enumValues(includeDeprecated: true) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tisDeprecated\n\t\t\t\t\t\t\tdeprecationReason\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\t\t{ \"name\": \"A\" }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"allEnumValues\": [\n\t\t\t\t\t\t\t{ \"name\": \"A\", \"isDeprecated\": false, \"deprecationReason\": null },\n\t\t\t\t\t\t\t{ \"name\": \"B\", \"isDeprecated\": true, \"deprecationReason\": \"No longer supported\" },\n\t\t\t\t\t\t\t{ \"name\": \"C\", \"isDeprecated\": true, \"deprecationReason\": \"We don't like it\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestSpecifiedByDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\tschema {\n\t\t\t\tquery: Query\n\t\t\t}\n\t\t\ttype Query {\n\t\t\t}\n\t\t\tscalar UUID @specifiedBy(\n\t\t\t\turl: \"https://tools.ietf.org/html/rfc4122\"\n\t\t\t)\n\t\t\t`, &struct{}{}),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\t__type(name: \"UUID\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tspecifiedByURL\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"name\": \"UUID\",\n\t\t\t\t\t\t\"specifiedByURL\": \"https://tools.ietf.org/html/rfc4122\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testBadEnumResolver struct{}\n\nfunc (r *testBadEnumResolver) Hero() *testBadEnumCharacterResolver {\n\treturn &testBadEnumCharacterResolver{}\n}\n\ntype testBadEnumCharacterResolver struct{}\n\nfunc (r *testBadEnumCharacterResolver) Name() string {\n\treturn \"Spock\"\n}\n\nfunc (r *testBadEnumCharacterResolver) AppearsIn() []string {\n\treturn []string{\"STAR_TREK\"}\n}\n\nfunc TestUnknownType(t *testing.T) {\n\tgqltesting.RunTest(t, &gqltesting.Test{\n\t\tSchema: starwarsSchema,\n\t\tQuery: `\n\t\t\tquery TypeInfo {\n\t\t\t\t__type(name: \"unknown-type\") {\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t}\n\t\t`,\n\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"__type\": null\n\t\t\t}\n\t\t`,\n\t})\n}\n\nfunc TestEnums(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t// Valid input enum supplied in query text\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid input enum supplied in query text\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: WRATH_OF_KHAN) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:   \"Argument \\\"episode\\\" has invalid value WRATH_OF_KHAN.\\nExpected type \\\"Episode\\\", found WRATH_OF_KHAN.\",\n\t\t\t\t\tLocations: []gqlerrors.Location{{Column: 20, Line: 3}},\n\t\t\t\t\tRule:      \"ArgumentsOfCorrectType\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Valid input enum supplied in variables\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\"episode\": \"JEDI\"},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid input enum supplied in variables\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\"episode\": \"FINAL_FRONTIER\"},\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:   \"Variable \\\"episode\\\" has invalid value FINAL_FRONTIER.\\nExpected type \\\"Episode\\\", found FINAL_FRONTIER.\",\n\t\t\t\t\tLocations: []gqlerrors.Location{{Column: 26, Line: 2}},\n\t\t\t\t\tRule:      \"VariablesOfCorrectType\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Valid enum value in response\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero {\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tappearsIn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"appearsIn\": [\"NEWHOPE\",\"EMPIRE\",\"JEDI\"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid enum value in response\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thero: Character\n\t\t\t\t}\n\n\t\t\t\tenum Episode {\n\t\t\t\t\tNEWHOPE\n\t\t\t\t\tEMPIRE\n\t\t\t\t\tJEDI\n\t\t\t\t}\n\n\t\t\t\ttype Character {\n\t\t\t\t\tname: String!\n\t\t\t\t\tappearsIn: [Episode!]!\n\t\t\t\t}\n\t\t\t`, &testBadEnumResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Hero {\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tappearsIn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\n\t\t\t\t\"hero\": null\n\t\t\t}`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: \"Invalid value STAR_TREK.\\nExpected type Episode, found STAR_TREK.\",\n\t\t\t\t\tPath:    []interface{}{\"hero\", \"appearsIn\", 0},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype testDeprecatedArgsResolver struct{}\n\nfunc (r *testDeprecatedArgsResolver) A(args struct{ B *string }) int32 {\n\treturn 0\n}\n\nfunc TestDeprecatedArgs(t *testing.T) {\n\tgraphql.MustParseSchema(`\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\t\ttype Query {\n\t\t\ta(b: String @deprecated): Int!\n\t\t}\n\t`, &testDeprecatedArgsResolver{})\n}\n\nfunc TestInlineFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"JEDI\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"primaryFunction\": \"Astromech\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"EMPIRE\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery CharacterSearch {\n\t\t\t\t\tsearch(text: \"C-3PO\") {\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery CharacterSearch {\n\t\t\t\t\thero {\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(social.Schema, &social.Resolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tadmin(id: \"0x01\") {\n\t\t\t\t\t\t... on User {\n\t\t\t\t\t\t\temail\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Person {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\"email\": \"Albus@hogwarts.com\",\n\t\t\t\t\t\t\"name\": \"Albus Dumbledore\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestTypeName(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsearch(text: \"an\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Starship {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Starship\",\n\t\t\t\t\t\t\t\"name\": \"TIE Advanced x1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\t...Droid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment Droid on Droid {\n\t\t\t\t\tname\n\t\t\t\t\t__typename\n\t\t\t\t}\n\t\t\t`,\n\t\t\tRawResponse:    true,\n\t\t\tExpectedResult: `{\"hero\":{\"__typename\":\"Droid\",\"name\":\"R2-D2\"}}`,\n\t\t},\n\t})\n}\n\nfunc TestConnections(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMQ==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMQ==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection(first: 1, after: \"Y3Vyc29yMQ==\") {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmoreFriends: hero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection(first: 1, after: \"Y3Vyc29yMg==\") {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"moreFriends\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestMutation(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\treviews(episode: JEDI) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"reviews\": []\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n\t\t\t\t\tcreateReview(episode: $ep, review: $review) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"ep\": \"JEDI\",\n\t\t\t\t\"review\": map[string]interface{}{\n\t\t\t\t\t\"stars\":      5,\n\t\t\t\t\t\"commentary\": \"This is a great movie!\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"createReview\": {\n\t\t\t\t\t\t\"stars\": 5,\n\t\t\t\t\t\t\"commentary\": \"This is a great movie!\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n\t\t\t\t\tcreateReview(episode: $ep, review: $review) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"ep\": \"EMPIRE\",\n\t\t\t\t\"review\": map[string]interface{}{\n\t\t\t\t\t\"stars\": float64(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"createReview\": {\n\t\t\t\t\t\t\"stars\": 4,\n\t\t\t\t\t\t\"commentary\": null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\treviews(episode: JEDI) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"reviews\": [{\n\t\t\t\t\t\t\"stars\": 5,\n\t\t\t\t\t\t\"commentary\": \"This is a great movie!\"\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestIntrospection(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\ttypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\"types\": [\n\t\t\t\t\t\t\t{ \"name\": \"Boolean\" },\n\t\t\t\t\t\t\t{ \"name\": \"Character\" },\n\t\t\t\t\t\t\t{ \"name\": \"Droid\" },\n\t\t\t\t\t\t\t{ \"name\": \"Episode\" },\n\t\t\t\t\t\t\t{ \"name\": \"Float\" },\n\t\t\t\t\t\t\t{ \"name\": \"FriendsConnection\" },\n\t\t\t\t\t\t\t{ \"name\": \"FriendsEdge\" },\n\t\t\t\t\t\t\t{ \"name\": \"Human\" },\n\t\t\t\t\t\t\t{ \"name\": \"ID\" },\n\t\t\t\t\t\t\t{ \"name\": \"Int\" },\n\t\t\t\t\t\t\t{ \"name\": \"LengthUnit\" },\n\t\t\t\t\t\t\t{ \"name\": \"Mutation\" },\n\t\t\t\t\t\t\t{ \"name\": \"PageInfo\" },\n\t\t\t\t\t\t\t{ \"name\": \"Query\" },\n\t\t\t\t\t\t\t{ \"name\": \"Review\" },\n\t\t\t\t\t\t\t{ \"name\": \"ReviewInput\" },\n\t\t\t\t\t\t\t{ \"name\": \"SearchResult\" },\n\t\t\t\t\t\t\t{ \"name\": \"Starship\" },\n\t\t\t\t\t\t\t{ \"name\": \"String\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Directive\" },\n\t\t\t\t\t\t\t{ \"name\": \"__DirectiveLocation\" },\n\t\t\t\t\t\t\t{ \"name\": \"__EnumValue\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Field\" },\n\t\t\t\t\t\t\t{ \"name\": \"__InputValue\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Schema\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Type\" },\n\t\t\t\t\t\t\t{ \"name\": \"__TypeKind\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tqueryType {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\"queryType\": {\n\t\t\t\t\t\t\t\"name\": \"Query\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta: __type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tb: __type(name: \"Character\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc: __type(name: \"SearchResult\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": {\n\t\t\t\t\t\t\"name\": \"Droid\",\n\t\t\t\t\t\t\"kind\": \"OBJECT\",\n\t\t\t\t\t\t\"interfaces\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Character\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"possibleTypes\": null\n\t\t\t\t\t},\n\t\t\t\t\t\"b\": {\n\t\t\t\t\t\t\"name\": \"Character\",\n\t\t\t\t\t\t\"kind\": \"INTERFACE\",\n\t\t\t\t\t\t\"interfaces\": null,\n\t\t\t\t\t\t\"possibleTypes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Human\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Droid\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"c\": {\n\t\t\t\t\t\t\"name\": \"SearchResult\",\n\t\t\t\t\t\t\"kind\": \"UNION\",\n\t\t\t\t\t\t\"interfaces\": null,\n\t\t\t\t\t\t\"possibleTypes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Human\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Droid\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Starship\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefaultValue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"name\": \"Droid\",\n\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"id\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"name\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"friends\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"LIST\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"friendsConnection\",\n\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\"name\": \"first\",\n\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Int\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"defaultValue\": null\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\"name\": \"after\",\n\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"ID\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"defaultValue\": null\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"appearsIn\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"primaryFunction\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": \"String\",\n\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Episode\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"NEWHOPE\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"EMPIRE\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"JEDI\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tdirectives {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tlocations\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\tofType {\n\t\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\t\"directives\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"deprecated\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Marks an element of a GraphQL schema as no longer supported.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD_DEFINITION\",\n\t\t\t\t\t\t\t\t\t\t\"ENUM_VALUE\",\n\t\t\t\t\t\t\t\t\t\t\"ARGUMENT_DEFINITION\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"reason\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Explains why this element was deprecated, usually also including a suggestion\\nfor how to access supported similar data. Formatted in\\n[Markdown](https://daringfireball.net/projects/markdown/).\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": null\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"include\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Directs the executor to include this field or fragment only when the ` + \"`\" + `if` + \"`\" + ` argument is true.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD\",\n\t\t\t\t\t\t\t\t\t\t\"FRAGMENT_SPREAD\",\n\t\t\t\t\t\t\t\t\t\t\"INLINE_FRAGMENT\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"if\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Included when true.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Boolean\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"skip\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Directs the executor to skip this field or fragment when the ` + \"`\" + `if` + \"`\" + ` argument is true.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD\",\n\t\t\t\t\t\t\t\t\t\t\"FRAGMENT_SPREAD\",\n\t\t\t\t\t\t\t\t\t\t\"INLINE_FRAGMENT\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"if\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Skipped when true.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Boolean\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"specifiedBy\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Provides a scalar specification URL for specifying the behavior of custom scalar types.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"SCALAR\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"url\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"The URL should point to a human-readable specification of the data format, serialization, and coercion rules.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"String\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nvar starwarsSchemaNoIntrospection = graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, []graphql.SchemaOpt{graphql.DisableIntrospection()}...)\n\nfunc TestIntrospectionDisableIntrospection(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\ttypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tqueryType {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta: __type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tb: __type(name: \"Character\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc: __type(name: \"SearchResult\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefaultValue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Episode\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tdirectives {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tlocations\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\tofType {\n\t\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsearch(text: \"an\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Starship {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Starship\",\n\t\t\t\t\t\t\t\"name\": \"TIE Advanced x1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestMutationOrder(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t\tmutation: Mutation\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): Query\n\t\t\t\t}\n\t\t\t`, &theNumberResolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tfirst: changeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t\tsecond: changeTheNumber(newNumber: 3) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t\tthird: changeTheNumber(newNumber: 2) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"first\": {\n\t\t\t\t\t\t\"theNumber\": 1\n\t\t\t\t\t},\n\t\t\t\t\t\"second\": {\n\t\t\t\t\t\t\"theNumber\": 3\n\t\t\t\t\t},\n\t\t\t\t\t\"third\": {\n\t\t\t\t\t\t\"theNumber\": 2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestTime(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\taddHour(time: Time = \"2001-02-03T04:05:06Z\"): Time!\n\t\t\t\t}\n\n\t\t\t\tscalar Time\n\t\t\t`, &timeResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery($t: Time!) {\n\t\t\t\t\ta: addHour(time: $t)\n\t\t\t\t\tb: addHour\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"t\": time.Date(2000, 2, 3, 4, 5, 6, 0, time.UTC),\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": \"2000-02-03T05:05:06Z\",\n\t\t\t\t\t\"b\": \"2001-02-03T05:05:06Z\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype resolverWithUnexportedMethod struct{}\n\nfunc (r *resolverWithUnexportedMethod) changeTheNumber(args struct{ NewNumber int32 }) int32 { //lint:ignore U1000 ingore this for now\n\treturn args.NewNumber\n}\n\nfunc TestUnexportedMethod(t *testing.T) {\n\tt.Parallel()\n\n\t_, err := graphql.ParseSchema(`\n\t\tschema {\n\t\t\tmutation: Mutation\n\t\t}\n\n\t\ttype Mutation {\n\t\t\tchangeTheNumber(newNumber: Int!): Int!\n\t\t}\n\t`, &resolverWithUnexportedMethod{})\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n}\n\ntype resolverWithUnexportedField struct{}\n\nfunc (r *resolverWithUnexportedField) ChangeTheNumber(args struct{ newNumber int32 }) int32 {\n\treturn args.newNumber\n}\n\nfunc TestUnexportedField(t *testing.T) {\n\tt.Parallel()\n\n\t_, err := graphql.ParseSchema(`\n\t\tschema {\n\t\t\tmutation: Mutation\n\t\t}\n\n\t\ttype Mutation {\n\t\t\tchangeTheNumber(newNumber: Int!): Int!\n\t\t}\n\t`, &resolverWithUnexportedField{})\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n}\n\ntype StringEnum string\n\nconst (\n\tEnumOption1 StringEnum = \"Option1\"\n\tEnumOption2 StringEnum = \"Option2\"\n)\n\ntype IntEnum int\n\nconst (\n\tIntEnum0 IntEnum = iota\n\tIntEnum1\n)\n\nfunc (e IntEnum) String() string {\n\tswitch int(e) {\n\tcase 0:\n\t\treturn \"Int0\"\n\tcase 1:\n\t\treturn \"Int1\"\n\tdefault:\n\t\treturn \"IntN\"\n\t}\n}\n\nfunc (IntEnum) ImplementsGraphQLType(name string) bool {\n\treturn name == \"IntEnum\"\n}\n\nfunc (e *IntEnum) UnmarshalGraphQL(input interface{}) error {\n\tif str, ok := input.(string); ok {\n\t\tswitch str {\n\t\tcase \"Int0\":\n\t\t\t*e = IntEnum(0)\n\t\tcase \"Int1\":\n\t\t\t*e = IntEnum(1)\n\t\tdefault:\n\t\t\t*e = IntEnum(-1)\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"wrong type for IntEnum: %T\", input)\n}\n\ntype inputResolver struct{}\n\nfunc (r *inputResolver) Int(args struct{ Value int32 }) int32 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Float(args struct{ Value float64 }) float64 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) String(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Boolean(args struct{ Value bool }) bool {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Nullable(args struct{ Value *int32 }) *int32 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) List(args struct{ Value []*struct{ V int32 } }) []int32 {\n\tl := make([]int32, len(args.Value))\n\tfor i, entry := range args.Value {\n\t\tl[i] = entry.V\n\t}\n\treturn l\n}\n\nfunc (r *inputResolver) NullableList(args struct{ Value *[]*struct{ V int32 } }) *[]*int32 {\n\tif args.Value == nil {\n\t\treturn nil\n\t}\n\tl := make([]*int32, len(*args.Value))\n\tfor i, entry := range *args.Value {\n\t\tif entry != nil {\n\t\t\tl[i] = &entry.V\n\t\t}\n\t}\n\treturn &l\n}\n\nfunc (r *inputResolver) StringEnumValue(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableStringEnumValue(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) StringEnum(args struct{ Value StringEnum }) StringEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableStringEnum(args struct{ Value *StringEnum }) *StringEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) IntEnumValue(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableIntEnumValue(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) IntEnum(args struct{ Value IntEnum }) IntEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableIntEnum(args struct{ Value *IntEnum }) *IntEnum {\n\treturn args.Value\n}\n\ntype recursive struct {\n\tNext *recursive\n}\n\nfunc (r *inputResolver) Recursive(args struct{ Value *recursive }) int32 {\n\tvar n int32\n\tv := args.Value\n\tfor v != nil {\n\t\tv = v.Next\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc (r *inputResolver) ID(args struct{ Value graphql.ID }) graphql.ID {\n\treturn args.Value\n}\n\nfunc TestInput(t *testing.T) {\n\tt.Parallel()\n\n\tcoercionSchema := graphql.MustParseSchema(`\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tint(value: Int!): Int!\n\t\t\tfloat(value: Float!): Float!\n\t\t\tstring(value: String!): String!\n\t\t\tboolean(value: Boolean!): Boolean!\n\t\t\tnullable(value: Int): Int\n\t\t\tlist(value: [Input!]!): [Int!]!\n\t\t\tnullableList(value: [Input]): [Int]\n\t\t\tstringEnumValue(value: StringEnum!): StringEnum!\n\t\t\tnullableStringEnumValue(value: StringEnum): StringEnum\n\t\t\tstringEnum(value: StringEnum!): StringEnum!\n\t\t\tnullableStringEnum(value: StringEnum): StringEnum\n\t\t\tintEnumValue(value: IntEnum!): IntEnum!\n\t\t\tnullableIntEnumValue(value: IntEnum): IntEnum\n\t\t\tintEnum(value: IntEnum!): IntEnum!\n\t\t\tnullableIntEnum(value: IntEnum): IntEnum\n\t\t\trecursive(value: RecursiveInput): Int!\n\t\t\tid(value: ID!): ID!\n\t\t}\n\n\t\tinput Input {\n\t\t\tv: Int!\n\t\t}\n\n\t\tinput RecursiveInput {\n\t\t\tnext: RecursiveInput\n\t\t}\n\n\t\tenum StringEnum {\n\t\t\tOption1\n\t\t\tOption2\n\t\t}\n\n\t\tenum IntEnum {\n\t\t\tInt0\n\t\t\tInt1\n\t\t}\n\t`, &inputResolver{})\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: coercionSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tint(value: 42)\n\t\t\t\t\tfloat1: float(value: 42)\n\t\t\t\t\tfloat2: float(value: 42.5)\n\t\t\t\t\tstring(value: \"foo\")\n\t\t\t\t\tboolean(value: true)\n\t\t\t\t\tnullable1: nullable(value: 42)\n\t\t\t\t\tnullable2: nullable(value: null)\n\t\t\t\t\tlist1: list(value: [{v: 41}, {v: 42}, {v: 43}])\n\t\t\t\t\tlist2: list(value: {v: 42})\n\t\t\t\t\tnullableList1: nullableList(value: [{v: 41}, null, {v: 43}])\n\t\t\t\t\tnullableList2: nullableList(value: null)\n\t\t\t\t\tstringEnumValue(value: Option1)\n\t\t\t\t\tnullableStringEnumValue1: nullableStringEnum(value: Option1)\n\t\t\t\t\tnullableStringEnumValue2: nullableStringEnum(value: null)\n\t\t\t\t\tstringEnum(value: Option2)\n\t\t\t\t\tnullableStringEnum1: nullableStringEnum(value: Option2)\n\t\t\t\t\tnullableStringEnum2: nullableStringEnum(value: null)\n\t\t\t\t\tintEnumValue(value: Int1)\n\t\t\t\t\tnullableIntEnumValue1: nullableIntEnumValue(value: Int1)\n\t\t\t\t\tnullableIntEnumValue2: nullableIntEnumValue(value: null)\n\t\t\t\t\tintEnum(value: Int1)\n\t\t\t\t\tnullableIntEnum1: nullableIntEnum(value: Int1)\n\t\t\t\t\tnullableIntEnum2: nullableIntEnum(value: null)\n\t\t\t\t\trecursive(value: {next: {next: {}}})\n\t\t\t\t\tintID: id(value: 1234)\n\t\t\t\t\tstrID: id(value: \"1234\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"int\": 42,\n\t\t\t\t\t\"float1\": 42,\n\t\t\t\t\t\"float2\": 42.5,\n\t\t\t\t\t\"string\": \"foo\",\n\t\t\t\t\t\"boolean\": true,\n\t\t\t\t\t\"nullable1\": 42,\n\t\t\t\t\t\"nullable2\": null,\n\t\t\t\t\t\"list1\": [41, 42, 43],\n\t\t\t\t\t\"list2\": [42],\n\t\t\t\t\t\"nullableList1\": [41, null, 43],\n\t\t\t\t\t\"nullableList2\": null,\n\t\t\t\t\t\"stringEnumValue\": \"Option1\",\n\t\t\t\t\t\"nullableStringEnumValue1\": \"Option1\",\n\t\t\t\t\t\"nullableStringEnumValue2\": null,\n\t\t\t\t\t\"stringEnum\": \"Option2\",\n\t\t\t\t\t\"nullableStringEnum1\": \"Option2\",\n\t\t\t\t\t\"nullableStringEnum2\": null,\n\t\t\t\t\t\"intEnumValue\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnumValue1\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnumValue2\": null,\n\t\t\t\t\t\"intEnum\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnum1\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnum2\": null,\n\t\t\t\t\t\"recursive\": 3,\n\t\t\t\t\t\"intID\": \"1234\",\n\t\t\t\t\t\"strID\": \"1234\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype inputArgumentsHello struct{}\n\ntype inputArgumentsScalarMismatch1 struct{}\n\ntype inputArgumentsScalarMismatch2 struct{}\n\ntype inputArgumentsObjectMismatch1 struct{}\n\ntype inputArgumentsObjectMismatch2 struct{}\n\ntype inputArgumentsObjectMismatch3 struct{}\n\ntype fieldNameMismatch struct{}\n\ntype helloInput struct {\n\tName string\n}\n\ntype helloOutput struct {\n\tName string\n}\n\nfunc (*fieldNameMismatch) Hello() helloOutput {\n\treturn helloOutput{}\n}\n\ntype helloInputMismatch struct {\n\tWorld string\n}\n\nfunc (r *inputArgumentsHello) Hello(args struct{ Input *helloInput }) string {\n\treturn \"Hello \" + args.Input.Name + \"!\"\n}\n\nfunc (r *inputArgumentsScalarMismatch1) Hello(name string) string {\n\treturn \"Hello \" + name + \"!\"\n}\n\nfunc (r *inputArgumentsScalarMismatch2) Hello(args struct{ World string }) string {\n\treturn \"Hello \" + args.World + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch1) Hello(in helloInput) string {\n\treturn \"Hello \" + in.Name + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch2) Hello(args struct{ Input *helloInputMismatch }) string {\n\treturn \"Hello \" + args.Input.World + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch3) Hello(args struct{ Input *struct{ Thing string } }) string {\n\treturn \"Hello \" + args.Input.Thing + \"!\"\n}\n\nfunc TestInputArguments_failSchemaParsing(t *testing.T) {\n\ttype args struct {\n\t\tResolver interface{}\n\t\tSchema   string\n\t\tOpts     []graphql.SchemaOpt\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Non-input type used with field arguments\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsHello{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": type of kind OBJECT can not be used as input\\n\\tused by (*graphql_test.inputArgumentsHello).Hello\"},\n\t\t},\n\t\t\"Missing Args Wrapper for scalar input\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsScalarMismatch1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(name: String): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"expected struct or pointer to struct, got string (hint: missing `args struct { ... }` wrapper for field arguments?)\\n\\tused by (*graphql_test.inputArgumentsScalarMismatch1).Hello\"},\n\t\t},\n\t\t\"Mismatching field name for scalar input\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsScalarMismatch2{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(name: String): String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"struct { World string } does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsScalarMismatch2).Hello\"},\n\t\t},\n\t\t\"Missing Args Wrapper for Input type\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"graphql_test.helloInput does not define field \\\"input\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch1).Hello\"},\n\t\t},\n\t\t\"Input struct missing field\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch2{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": *graphql_test.helloInputMismatch does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch2).Hello\"},\n\t\t},\n\t\t\"Inline Input struct missing field\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch3{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": *struct { Thing string } does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch3).Hello\"},\n\t\t},\n\t\t\"Struct field name inclusion\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &fieldNameMismatch{},\n\t\t\t\tOpts:     []graphql.SchemaOpt{graphql.UseFieldResolvers()},\n\t\t\t\tSchema: `\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(): HelloOutput!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloOutput {\n\t\t\t\t\t\tname: Int\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"string is not a pointer\\n\\tused by (graphql_test.helloOutput).Name\\n\\tused by (*graphql_test.fieldNameMismatch).Hello\"},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, tt.Args.Resolver, tt.Args.Opts...)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Log(\"Schema parsing error mismatch\")\n\t\t\t\tt.Logf(\"got: %s\", err)\n\t\t\t\tt.Logf(\"exp: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestComposedFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tcomposed: hero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsNames\n\t\t\t\t\t\t...friendsIds\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsNames on Character {\n\t\t\t\t\tname\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsIds on Character {\n\t\t\t\t\tname\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tid\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"composed\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"1002\",\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"1003\",\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"2000\",\n\t\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"2001\",\n\t\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nvar (\n\terrExample = fmt.Errorf(\"this is an error\")\n\n\tnilChildErrorString = `graphql: got nil for non-null \"Child\"`\n)\n\ntype childResolver struct{}\n\nfunc (r *childResolver) TriggerError() (string, error) {\n\treturn \"This will never be returned to the client\", errExample\n}\nfunc (r *childResolver) NoError() string {\n\treturn \"no error\"\n}\nfunc (r *childResolver) Child() *childResolver {\n\treturn &childResolver{}\n}\nfunc (r *childResolver) NilChild() *childResolver {\n\treturn nil\n}\n\nfunc TestErrorPropagation(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\ttriggerError\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       errExample.Error(),\n\t\t\t\t\tResolverError: errExample,\n\t\t\t\t\tPath:          []interface{}{\"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\ttriggerError\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       errExample.Error(),\n\t\t\t\t\tResolverError: errExample,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       errExample.Error(),\n\t\t\t\t\tResolverError: errExample,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": {\n\t\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\t\"child\": null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       errExample.Error(),\n\t\t\t\t\tResolverError: errExample,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\"child\": null\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tchild {\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"child\": {\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"child\", \"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMessage:       errExample.Error(),\n\t\t\t\t\tResolverError: errExample,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tchild {\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"child\": null\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype assertionResolver struct{}\n\nfunc (r *assertionResolver) ToHuman() (*struct{ Name string }, bool) {\n\treturn &struct{ Name string }{Name: \"Luke Skywalker\"}, true\n}\n\ntype assertionQueryResolver struct{}\n\nfunc (*assertionQueryResolver) Character() *assertionResolver {\n\treturn &assertionResolver{}\n}\n\ntype badAssertionResolver struct{}\n\nfunc (r *badAssertionResolver) ToHuman(ctx context.Context) (*struct{ Name string }, bool) {\n\treturn &struct{ Name string }{Name: \"Luke Skywalker\"}, true\n}\n\ntype badAssertionQueryResolver struct{}\n\nfunc (*badAssertionQueryResolver) Character() *badAssertionResolver {\n\treturn &badAssertionResolver{}\n}\n\nfunc TestTypeAssertions(t *testing.T) {\n\tassertionSchema := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tcharacter: Character!\n\t\t}\n\n\t\ttype Human {\n\t\t\tname: String!\n\t\t}\n\n\t\tunion Character = Human\n\t`\n\tquery := `\n\t\tquery {\n\t\t\tcharacter {\n\t\t\t\t... on Human {\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(assertionSchema, &assertionQueryResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery:  query,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"character\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestPanicTypeAssertionArguments(t *testing.T) {\n\tpanicMessage := `*graphql_test.badAssertionResolver does not resolve \"Character\": method \"ToHuman\" should't have any arguments\n\tused by (*graphql_test.badAssertionQueryResolver).Character`\n\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Fatal(\"expected schema parse to panic\")\n\t\t}\n\n\t\tif r.(error).Error() != panicMessage {\n\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\tt.Logf(\"want: %s\", panicMessage)\n\t\t\tt.Fail()\n\t\t}\n\t}()\n\n\tschema := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tcharacter: Character!\n\t\t}\n\n\t\ttype Human {\n\t\t\tname: String!\n\t\t}\n\n\t\tunion Character = Human\n\t`\n\tgraphql.MustParseSchema(schema, &badAssertionQueryResolver{}, graphql.UseFieldResolvers())\n}\n\ntype ambiguousResolver struct {\n\tName string // ambiguous\n\tUniversity\n}\n\ntype University struct {\n\tName string // ambiguous\n}\n\nfunc TestPanicAmbiguity(t *testing.T) {\n\tpanicMessage := `*graphql_test.ambiguousResolver does not resolve \"Query\": ambiguous field \"name\"`\n\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Fatal(\"expected schema parse to panic\")\n\t\t}\n\n\t\tif r.(error).Error() != panicMessage {\n\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\tt.Logf(\"want: %s\", panicMessage)\n\t\t\tt.Fail()\n\t\t}\n\t}()\n\n\tschema := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tname: String!\n\t\t\tuniversity: University!\n\t\t}\n\n\t\ttype University {\n\t\t\tname: String!\n\t\t}\n\t`\n\tgraphql.MustParseSchema(schema, &ambiguousResolver{}, graphql.UseFieldResolvers())\n}\n\nfunc TestSchema_Exec_without_resolver(t *testing.T) {\n\tt.Parallel()\n\n\ttype args struct {\n\t\tQuery  string\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tPanic interface{}\n\t}\n\ttestTable := []struct {\n\t\tName string\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t{\n\t\t\tName: \"schema_without_resolver_errors\",\n\t\t\tArgs: args{\n\t\t\t\tQuery: `\n\t\t\t\t\tquery {\n\t\t\t\t\t\thero {\n\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tfriends {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t\tSchema: starwars.Schema,\n\t\t\t},\n\t\t\tWant: want{Panic: \"schema created without resolver, can not exec\"},\n\t\t},\n\t}\n\n\tfor _, tt := range testTable {\n\t\tt.Run(tt.Name, func(t *testing.T) {\n\t\t\ts := graphql.MustParseSchema(tt.Args.Schema, nil)\n\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Fatal(\"expected query to panic\")\n\t\t\t\t}\n\t\t\t\tif r != tt.Want.Panic {\n\t\t\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\t\t\tt.Logf(\"want: %s\", tt.Want.Panic)\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}()\n\t\t\t_ = s.Exec(context.Background(), tt.Args.Query, \"\", map[string]interface{}{})\n\t\t})\n\t}\n}\n\ntype subscriptionsInExecResolver struct{}\n\nfunc (r *subscriptionsInExecResolver) AppUpdated() <-chan string {\n\treturn make(chan string)\n}\n\nfunc TestSubscriptions_In_Exec(t *testing.T) {\n\tr := &struct {\n\t\t*helloResolver\n\t\t*subscriptionsInExecResolver\n\t}{\n\t\thelloResolver:               &helloResolver{},\n\t\tsubscriptionsInExecResolver: &subscriptionsInExecResolver{},\n\t}\n\tgqltesting.RunTest(t, &gqltesting.Test{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {\n\t\t\t\thello: String!\n\t\t\t}\n\t\t\ttype Subscription {\n\t\t\t\tappUpdated : String!\n\t\t\t}\n\t\t`, r),\n\t\tQuery: `\n\t\t\tsubscription {\n\t\t\t\tappUpdated\n\t\t  \t}\n\t\t`,\n\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t{\n\t\t\t\tMessage: \"graphql-ws protocol header is missing\",\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype nilPointerReturnValue struct{}\n\nfunc (r *nilPointerReturnValue) Value() *string {\n\treturn nil\n}\n\ntype nilPointerReturnResolver struct{}\n\nfunc (r *nilPointerReturnResolver) PointerReturn() *nilPointerReturnValue {\n\treturn &nilPointerReturnValue{}\n}\n\nfunc TestPointerReturnForNonNull(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {\n\t\t\t\tpointerReturn: PointerReturnValue\n\t\t\t}\n\n\t\t\ttype PointerReturnValue {\n\t\t\t\tvalue: Hello!\n\t\t\t}\n\t\t\tenum Hello {\n\t\t\t\tWORLD\n\t\t\t}\n\t\t`, &nilPointerReturnResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tpointerReturn {\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"pointerReturn\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Hello\"`,\n\t\t\t\t\tPath:    []interface{}{\"pointerReturn\", \"value\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype nullableInput struct {\n\tString graphql.NullString\n\tInt    graphql.NullInt\n\tBool   graphql.NullBool\n\tTime   graphql.NullTime\n\tFloat  graphql.NullFloat\n}\n\ntype nullableResult struct {\n\tString string\n\tInt    string\n\tBool   string\n\tTime   string\n\tFloat  string\n}\n\ntype nullableResolver struct {\n}\n\nfunc (r *nullableResolver) TestNullables(args struct {\n\tInput *nullableInput\n}) nullableResult {\n\tvar res nullableResult\n\tif args.Input.String.Set {\n\t\tif args.Input.String.Value == nil {\n\t\t\tres.String = \"<nil>\"\n\t\t} else {\n\t\t\tres.String = *args.Input.String.Value\n\t\t}\n\t}\n\n\tif args.Input.Int.Set {\n\t\tif args.Input.Int.Value == nil {\n\t\t\tres.Int = \"<nil>\"\n\t\t} else {\n\t\t\tres.Int = fmt.Sprintf(\"%d\", *args.Input.Int.Value)\n\t\t}\n\t}\n\n\tif args.Input.Float.Set {\n\t\tif args.Input.Float.Value == nil {\n\t\t\tres.Float = \"<nil>\"\n\t\t} else {\n\t\t\tres.Float = fmt.Sprintf(\"%.2f\", *args.Input.Float.Value)\n\t\t}\n\t}\n\n\tif args.Input.Bool.Set {\n\t\tif args.Input.Bool.Value == nil {\n\t\t\tres.Bool = \"<nil>\"\n\t\t} else {\n\t\t\tres.Bool = fmt.Sprintf(\"%t\", *args.Input.Bool.Value)\n\t\t}\n\t}\n\n\tif args.Input.Time.Set {\n\t\tif args.Input.Time.Value == nil {\n\t\t\tres.Time = \"<nil>\"\n\t\t} else {\n\t\t\tres.Time = args.Input.Time.Value.Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc TestNullable(t *testing.T) {\n\tschema := `\n\tscalar Time\n\n\tinput MyInput {\n\t\tstring: String\n\t\tint: Int\n\t\tfloat: Float\n\t\tbool: Boolean\n\t\ttime: Time\n\t}\n\n\ttype Result {\n\t\tstring: String!\n\t\tint: String!\n\t\tfloat: String!\n\t\tbool: String!\n\t\ttime: String!\n\t}\n\n\ttype Query {\n\t\ttestNullables(input: MyInput): Result!\n\t}\n\t`\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {\n\t\t\t\t\t\tstring: \"test\"\n\t\t\t\t\t\tint: 1234\n\t\t\t\t\t\tfloat: 42.42\n\t\t\t\t\t\tbool: true\n\t\t\t\t\t\ttime: \"2021-01-02T15:04:05Z\"\n\t\t\t\t\t}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"test\",\n\t\t\t\t\t\t\"int\": \"1234\",\n\t\t\t\t\t\t\"float\": \"42.42\",\n\t\t\t\t\t\t\"bool\": \"true\",\n\t\t\t\t\t\t\"time\": \"2021-01-02T15:04:05Z\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {\n\t\t\t\t\t\tstring: null\n\t\t\t\t\t\tint: null\n\t\t\t\t\t\tfloat: null\n\t\t\t\t\t\tbool: null\n\t\t\t\t\t\ttime: null\n\t\t\t\t\t}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"<nil>\",\n\t\t\t\t\t\t\"int\": \"<nil>\",\n\t\t\t\t\t\t\"float\": \"<nil>\",\n\t\t\t\t\t\t\"bool\": \"<nil>\",\n\t\t\t\t\t\t\"time\": \"<nil>\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"\",\n\t\t\t\t\t\t\"int\": \"\",\n\t\t\t\t\t\t\"float\": \"\",\n\t\t\t\t\t\t\"bool\": \"\",\n\t\t\t\t\t\t\"time\": \"\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testTracer struct {\n\tmu      *sync.Mutex\n\tfields  []fieldTrace\n\tqueries []queryTrace\n}\n\ntype fieldTrace struct {\n\tlabel     string\n\ttypeName  string\n\tfieldName string\n\tisTrivial bool\n\targs      map[string]interface{}\n\terr       *gqlerrors.QueryError\n}\n\ntype queryTrace struct {\n\tdocument  string\n\topName    string\n\tvariables map[string]interface{}\n\tvarTypes  map[string]*introspection.Type\n\terrors    []*gqlerrors.QueryError\n}\n\nfunc (t *testTracer) TraceField(ctx context.Context, label, typeName, fieldName string, trivial bool, args map[string]interface{}) (context.Context, func(*gqlerrors.QueryError)) {\n\treturn ctx, func(qe *gqlerrors.QueryError) {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tft := fieldTrace{\n\t\t\tlabel:     label,\n\t\t\ttypeName:  typeName,\n\t\t\tfieldName: fieldName,\n\t\t\tisTrivial: trivial,\n\t\t\targs:      args,\n\t\t\terr:       qe,\n\t\t}\n\n\t\tt.fields = append(t.fields, ft)\n\t}\n}\n\nfunc (t *testTracer) TraceQuery(ctx context.Context, document string, opName string, vars map[string]interface{}, varTypes map[string]*introspection.Type) (context.Context, func([]*gqlerrors.QueryError)) {\n\treturn ctx, func(qe []*gqlerrors.QueryError) {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tqt := queryTrace{\n\t\t\tdocument:  document,\n\t\t\topName:    opName,\n\t\t\tvariables: vars,\n\t\t\tvarTypes:  varTypes,\n\t\t\terrors:    qe,\n\t\t}\n\n\t\tt.queries = append(t.queries, qt)\n\t}\n}\n\nvar _ tracer.Tracer = (*testTracer)(nil)\n\nfunc TestTracer(t *testing.T) {\n\tt.Parallel()\n\n\ttt := &testTracer{mu: &sync.Mutex{}}\n\n\tschema, err := graphql.ParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.Tracer(tt))\n\tif err != nil {\n\t\tt.Fatalf(\"graphql.ParseSchema: %s\", err)\n\t}\n\n\tctx := context.Background()\n\tdoc := `\n\tquery TestTracer($id: ID!) {\n\t\tHanSolo: human(id: $id) {\n\t\t\t__typename\n\t\t\tname\n\t\t}\n\t}\n\t`\n\topName := \"TestTracer\"\n\tvariables := map[string]interface{}{\n\t\t\"id\": \"1002\",\n\t}\n\n\t_ = schema.Exec(ctx, doc, opName, variables)\n\n\ttt.mu.Lock()\n\tdefer tt.mu.Unlock()\n\n\tif len(tt.queries) != 1 {\n\t\tt.Fatalf(\"expected one query trace, but got %d: %#v\", len(tt.queries), tt.queries)\n\t}\n\n\tqt := tt.queries[0]\n\tif qt.document != doc {\n\t\tt.Errorf(\"mismatched query trace document:\\nwant: %q\\ngot : %q\", doc, qt.document)\n\t}\n\tif qt.opName != opName {\n\t\tt.Errorf(\"mismated query trace operationName:\\nwant: %q\\ngot : %q\", opName, qt.opName)\n\t}\n\n\texpectedFieldTraces := []fieldTrace{\n\t\t{fieldName: \"human\", typeName: \"Query\"},\n\t\t{fieldName: \"__typename\", typeName: \"Human\"},\n\t\t{fieldName: \"name\", typeName: \"Human\"},\n\t}\n\n\tcheckFieldTraces(t, expectedFieldTraces, tt.fields)\n}\n\nfunc checkFieldTraces(t *testing.T, want, have []fieldTrace) {\n\tif len(want) != len(have) {\n\t\tt.Errorf(\"mismatched field traces: expected %d but got %d: %#v\", len(want), len(have), have)\n\t}\n\n\ttype comparison struct {\n\t\twant fieldTrace\n\t\thave fieldTrace\n\t}\n\n\tm := map[string]comparison{}\n\n\tfor _, ft := range want {\n\t\tm[ft.fieldName] = comparison{want: ft}\n\t}\n\n\tfor _, ft := range have {\n\t\tc := m[ft.fieldName]\n\t\tc.have = ft\n\t\tm[ft.fieldName] = c\n\t}\n\n\tfor _, c := range m {\n\t\tif err := stringsEqual(c.want.fieldName, c.have.fieldName); err != \"\" {\n\t\t\tt.Error(\"mismatched field name:\", err)\n\t\t}\n\t\tif err := stringsEqual(c.want.typeName, c.have.typeName); err != \"\" {\n\t\t\tt.Error(\"mismatched field parent type:\", err)\n\t\t}\n\t}\n}\n\nfunc stringsEqual(want, have string) string {\n\tif want != have {\n\t\treturn fmt.Sprintf(\"mismatched values:\\nwant: %q\\nhave: %q\", want, have)\n\t}\n\n\treturn \"\"\n}\n\ntype queryVarResolver struct{}\ntype filterArgs struct {\n\tRequired string\n\tOptional *string\n}\ntype filterSearchResults struct {\n\tMatch *string\n}\n\nfunc (r *queryVarResolver) Search(ctx context.Context, args *struct{ Filter filterArgs }) []filterSearchResults {\n\treturn []filterSearchResults{}\n}\n\nfunc TestQueryVariablesValidation(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\tinput SearchFilter {\n\t\t\t  \trequired: String!\n\t\t\t  \toptional: String\n\t\t\t}\n\n\t\t\ttype SearchResults {\n\t\t\t\tmatch: String\n\t\t\t}\n\n\t\t\ttype Query {\n\t\t\t\tsearch(filter: SearchFilter!): [SearchResults!]!\n\t\t\t}`, &queryVarResolver{}, graphql.UseFieldResolvers()),\n\t\tQuery: `\n        \t\tquery {\n        \t\t\tsearch(filter: {}) {\n        \t\t\t\tmatch\n        \t\t\t}\n        \t\t}`,\n\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\tMessage:   \"Argument \\\"filter\\\" has invalid value {}.\\nIn field \\\"required\\\": Expected \\\"String!\\\", found null.\",\n\t\t\tLocations: []gqlerrors.Location{{Line: 3, Column: 27}},\n\t\t\tRule:      \"ArgumentsOfCorrectType\",\n\t\t}},\n\t}, {\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\tinput SearchFilter {\n\t\t\t\trequired: String!\n\t\t\t\toptional: String\n\t\t\t}\n\n\t\t\ttype SearchResults {\n\t\t\t\tmatch: String\n\t\t\t}\n\n\t\t\ttype Query {\n\t\t\t\tsearch(filter: SearchFilter!): [SearchResults!]!\n\t\t\t}`, &queryVarResolver{}, graphql.UseFieldResolvers()),\n\t\tQuery: `\n\t\t\tquery q($filter: SearchFilter!) {\n\t\t\t\tsearch(filter: $filter) {\n\t\t\t\t\tmatch\n\t\t\t\t}\n\t\t\t}`,\n\t\tVariables: map[string]interface{}{\"filter\": map[string]interface{}{}},\n\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\tMessage:   \"Variable \\\"required\\\" has invalid value null.\\nExpected type \\\"String!\\\", found null.\",\n\t\t\tLocations: []gqlerrors.Location{{Line: 3, Column: 5}},\n\t\t\tRule:      \"VariablesOfCorrectType\",\n\t\t}},\n\t}})\n}\n\ntype interfaceImplementingInterfaceResolver struct{}\ntype interfaceImplementingInterfaceExample struct {\n\tA string\n\tB string\n\tC bool\n}\n\nfunc (r *interfaceImplementingInterfaceResolver) Hey() *interfaceImplementingInterfaceExample {\n\treturn &interfaceImplementingInterfaceExample{\n\t\tA: \"testing\",\n\t\tB: \"test\",\n\t\tC: true,\n\t}\n}\n\nfunc TestInterfaceImplementingInterface(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{{\n\t\tSchema: graphql.MustParseSchema(`\n        interface A {\n          a: String!\n        }\n        interface B implements A {\n          a: String!\n          b: String!\n        }\n        interface C implements B & A {\n          a: String!\n          b: String!\n          c: Boolean!\n        }\n        type ABC implements C {\n          a: String!\n          b: String!\n          c: Boolean!\n        }\n        type Query {\n          hey: ABC\n        }`, &interfaceImplementingInterfaceResolver{}, graphql.UseFieldResolvers(), graphql.UseFieldResolvers()),\n\t\tQuery: `query {hey { a b c }}`,\n\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hey\": {\n\t\t\t\t\t\t\"a\": \"testing\",\n\t\t\t\t\t\t\"b\": \"test\",\n\t\t\t\t\t\t\"c\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t}})\n}\n\nfunc TestCircularFragmentMaxDepth(t *testing.T) {\n\twithMaxDepth := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.MaxDepth(2))\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: withMaxDepth,\n\t\t\tQuery: `\n\t              query {\n\t                  ...X\n\t              }\n\n\t              fragment X on Query {\n\t                  ...Y\n\t              }\n\t              fragment Y on Query {\n\t                  ...X\n\t              }\n\t          `,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\t\tMessage: `Cannot spread fragment \"X\" within itself via \"Y\".`,\n\t\t\t\tRule:    \"NoFragmentCyclesRule\",\n\t\t\t\tLocations: []gqlerrors.Location{\n\t\t\t\t\t{Line: 7, Column: 20},\n\t\t\t\t\t{Line: 10, Column: 20},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t})\n}\n\nfunc TestMaxQueryLength(t *testing.T) {\n\twithMaxQueryLen := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.MaxQueryLength(75))\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: withMaxQueryLen,\n\t\t\t// Query length is 69 bytes\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\thero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"hero\":{\"name\":\"Luke Skywalker\"}}`,\n\t\t},\n\t\t{\n\t\t\tSchema: withMaxQueryLen,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: WRATH_OF_KHAN) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\t\tMessage: `query length 91 exceeds the maximum allowed query length of 75 bytes`,\n\t\t\t}},\n\t\t},\n\t})\n}\n\ntype RootResolver struct{}\ntype QueryResolver struct{}\ntype MutationResolver struct{}\ntype SubscriptionResolver struct {\n\terr      error\n\tupstream <-chan *helloEventResolver\n}\n\nfunc (r *RootResolver) Query() *QueryResolver {\n\treturn &QueryResolver{}\n}\n\nfunc (r *RootResolver) Mutation() *MutationResolver {\n\treturn &MutationResolver{}\n}\n\ntype helloEventResolver struct {\n\tmsg string\n\terr error\n}\n\nfunc (r *helloEventResolver) Msg() (string, error) {\n\treturn r.msg, r.err\n}\n\nfunc closedHelloEventUpstream(rr ...*helloEventResolver) <-chan *helloEventResolver {\n\tc := make(chan *helloEventResolver, len(rr))\n\tfor _, r := range rr {\n\t\tc <- r\n\t}\n\tclose(c)\n\treturn c\n}\n\nfunc (r *RootResolver) Subscription() *SubscriptionResolver {\n\treturn &SubscriptionResolver{\n\t\tupstream: closedHelloEventUpstream(\n\t\t\t&helloEventResolver{msg: \"Hello subscription!\"},\n\t\t\t&helloEventResolver{err: errors.New(\"resolver error\")},\n\t\t\t&helloEventResolver{msg: \"Hello again!\"},\n\t\t),\n\t}\n}\n\nfunc (qr *QueryResolver) Hello() string {\n\treturn \"Hello query!\"\n}\n\nfunc (mr *MutationResolver) Hello() string {\n\treturn \"Hello mutation!\"\n}\n\nfunc (sr *SubscriptionResolver) Hello(ctx context.Context) (chan *helloEventResolver, error) {\n\tif sr.err != nil {\n\t\treturn nil, sr.err\n\t}\n\n\tc := make(chan *helloEventResolver)\n\tgo func() {\n\t\tfor r := range sr.upstream {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tclose(c)\n\t\t\t\treturn\n\t\t\tcase c <- r:\n\t\t\t}\n\t\t}\n\t\tclose(c)\n\t}()\n\n\treturn c, nil\n}\n\ntype errRootResolver1 struct {\n\tRootResolver\n}\n\n// Query is invalid because it doesn't have a return value.\nfunc (*errRootResolver1) Query() {}\n\ntype errRootResolver2 struct {\n\tRootResolver\n}\n\n// Query is invalid because it has more than 1 return value\nfunc (*errRootResolver2) Query() (*QueryResolver, error) {\n\treturn nil, nil\n}\n\ntype errRootResolver3 struct {\n\tRootResolver\n}\n\n// Mutation is invalid because it returns nil\nfunc (*errRootResolver3) Mutation() *MutationResolver {\n\treturn nil\n}\n\ntype errRootResolver4 struct {\n\tRootResolver\n}\n\n// Query is invalid because it doesn't return a pointer.\nfunc (*errRootResolver4) Query() MutationResolver {\n\treturn MutationResolver{}\n}\n\ntype errRootResolver5 struct {\n\tRootResolver\n}\n\n// Query is invalid because it returns *[]int instead of a resolver.\nfunc (*errRootResolver5) Query() *[]int {\n\treturn &[]int{1, 2}\n}\n\ntype errRootResolver6 struct {\n\tRootResolver\n}\n\n// Mutation is invalid because it returns a map[string]int instead of a resolver.\nfunc (*errRootResolver6) Mutation() map[string]int {\n\treturn map[string]int{\"key\": 3}\n}\n\ntype errRootResolver7 struct {\n\tRootResolver\n}\n\n// Subscription is invalid because it returns an invalid resolver.\nfunc (*errRootResolver7) Subscription() interface{} {\n\ta := struct {\n\t\tName string\n\t}{Name: \"invalid\"}\n\treturn &a\n}\n\ntype errRootResolver8 struct {\n\tRootResolver\n}\n\n// Query is invalid because it accepts arguments.\nfunc (*errRootResolver8) Query(ctx context.Context) *QueryResolver {\n\treturn &QueryResolver{}\n}\n\n// TestSeparateResolvers ensures that a field with the same name is allowed in different operations\nfunc TestSeparateResolvers(t *testing.T) {\n\thelloEverywhere := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t\tmutation: Mutation\n\t\t\tsubscription: Subscription\n\t\t}\n\n\t\ttype Query {\n\t\t\thello: String!\n\t\t}\n\n\t\ttype Mutation {\n\t\t\thello: String!\n\t\t}\n\n\t\ttype Subscription {\n\t\t\thello: HelloEvent!\n\t\t}\n\n\t\ttype HelloEvent {\n\t\t\tmsg: String!\n\t\t}\n\t`\n\n\tseparateSchema := graphql.MustParseSchema(helloEverywhere, &RootResolver{})\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: separateSchema,\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello query!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: separateSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello mutation!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n\n\tgqltesting.RunSubscribes(t, []*gqltesting.TestSubscription{\n\t\t{\n\t\t\tName:   \"ok\",\n\t\t\tSchema: separateSchema,\n\t\t\tQuery: `\n\t\t\t\tsubscription {\n\t\t\t\t\thello {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"hello\": {\n\t\t\t\t\t\t\t\t\"msg\": \"Hello subscription!\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// null propagates all the way up because msg is non-null\n\t\t\t\t\tData:   json.RawMessage(`null`),\n\t\t\t\t\tErrors: []*gqlerrors.QueryError{gqlerrors.Errorf(\"%s\", errResolver)},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"hello\": {\n\t\t\t\t\t\t\t\t\"msg\": \"Hello again!\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\n\t// test errors with invalid resolvers\n\ttests := []struct {\n\t\tname     string\n\t\tresolver interface{}\n\t\topts     []graphql.SchemaOpt\n\t\twantErr  string\n\t}{\n\t\t{\n\t\t\tname:     \"query_method_has_no_return_val\",\n\t\t\tresolver: &errRootResolver1{},\n\t\t\twantErr:  \"method \\\"Query\\\" of *graphql_test.errRootResolver1 must have 1 return value, got 0\",\n\t\t},\n\t\t{\n\t\t\tname:     \"query_method_returns_too_many_vals\",\n\t\t\tresolver: &errRootResolver2{},\n\t\t\twantErr:  \"method \\\"Query\\\" of *graphql_test.errRootResolver2 must have 1 return value, got 2\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mutation_method_returns_nil\",\n\t\t\tresolver: &errRootResolver3{},\n\t\t\twantErr:  \"method \\\"Mutation\\\" of *graphql_test.errRootResolver3 must return a non-nil result, got <nil>\",\n\t\t},\n\t\t{\n\t\t\tname:     \"query_method_does_not_return_a_pointer\",\n\t\t\tresolver: &errRootResolver4{},\n\t\t\twantErr:  \"method \\\"Query\\\" of *graphql_test.errRootResolver4 must return an interface or a pointer, got graphql_test.MutationResolver\",\n\t\t},\n\t\t{\n\t\t\tname:     \"query_method_returns_invalid_resolver_type\",\n\t\t\tresolver: &errRootResolver5{},\n\t\t\twantErr:  \"*[]int does not resolve \\\"Query\\\": missing method for field \\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mutation_method_returns_invalid_resolver_type\",\n\t\t\tresolver: &errRootResolver6{},\n\t\t\twantErr:  \"method \\\"Mutation\\\" of *graphql_test.errRootResolver6 must return an interface or a pointer, got map[string]int\",\n\t\t},\n\t\t{\n\t\t\tname:     \"query_subscription_returns_invalid_resolver_type\",\n\t\t\tresolver: &errRootResolver7{},\n\t\t\twantErr:  \"*struct { Name string } does not resolve \\\"Subscription\\\": missing method for field \\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"mutation_method_returns_invalid_resolver_type\",\n\t\t\tresolver: &errRootResolver8{},\n\t\t\twantErr:  \"method \\\"Query\\\" of *graphql_test.errRootResolver8 must not accept any arguments, got 1\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, err := graphql.ParseSchema(helloEverywhere, tt.resolver, tt.opts...)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"want err: %q, got: <nil>\", tt.wantErr)\n\t\t\t}\n\t\t\tif err.Error() != tt.wantErr {\n\t\t\t\tt.Fatalf(\"want err: %q, got: %q\", tt.wantErr, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSchemaExtension(t *testing.T) {\n\tt.Parallel()\n\n\tsdl := `\n\tdirective @awesome on SCHEMA\n\n\tschema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\thello: String!\n\t}\n\t\n\textend schema @awesome\n\t`\n\tschema := graphql.MustParseSchema(sdl, &helloResolver{})\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: schema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n\n\tast := schema.AST()\n\tdirs := ast.SchemaDefinition.Directives\n\tif len(dirs) != 1 {\n\t\tt.Fatalf(\"expected 1 schema directive, got %d\", len(dirs))\n\t}\n\tname := dirs[0].Name.Name\n\tif name != \"awesome\" {\n\t\tt.Fatalf(`expected an \"awesome\" schema directive, got %q`, dirs[0].Name.Name)\n\t}\n}\n\nfunc TestGraphqlNames(t *testing.T) {\n\tt.Parallel()\n\n\tsdl1 := `\n\ttype Query {\n\t\thello: String!\n\t}\n\t`\n\ttype invalidResolver1 struct {\n\t\tField1 string `graphql:\"hello\"`\n\t\tField2 string `graphql:\"hello\"`\n\t}\n\n\twantErr := fmt.Errorf(`*graphql_test.invalidResolver1 does not resolve \"Query\": multiple fields have a graphql reflect tag \"hello\"`)\n\t_, err := graphql.ParseSchema(sdl1, &invalidResolver1{}, graphql.UseFieldResolvers())\n\tif err == nil || err.Error() != wantErr.Error() {\n\t\tt.Fatalf(\"want err %q, got %q\", wantErr, err)\n\t}\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\t_hello: String!\n\t\t\t\t\thello: String!\n\t\t\t\t\tHello: String!\n\t\t\t\t\tHELLO: String!\n\t\t\t\t}`,\n\t\t\t\tfunc() interface{} {\n\t\t\t\t\ttype helloTagResolver struct {\n\t\t\t\t\t\tHello           string\n\t\t\t\t\t\tHelloUnderscore string `graphql:\"_hello\"`\n\t\t\t\t\t\tHelloLower      string `graphql:\"hello\"`\n\t\t\t\t\t\tHelloTitle      string `graphql:\"Hello\"`\n\t\t\t\t\t\tHelloUpper      string `graphql:\"HELLO\"`\n\t\t\t\t\t}\n\t\t\t\t\treturn &helloTagResolver{\n\t\t\t\t\t\tHello:           \"This field will not be used during query execution!\",\n\t\t\t\t\t\tHelloLower:      \"Hello, graphql!\",\n\t\t\t\t\t\tHelloTitle:      \"Hello, GraphQL!\",\n\t\t\t\t\t\tHelloUnderscore: \"Hello, _!\",\n\t\t\t\t\t\tHelloUpper:      \"Hello, GRAPHQL!\",\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tgraphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t_hello\n\t\t\t\t\thello\n\t\t\t\t\tHello\n\t\t\t\t\tHELLO\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"_hello\": \"Hello, _!\",\n\t\t\t\t    \"hello\": \"Hello, graphql!\",\n\t\t\t\t    \"Hello\": \"Hello, GraphQL!\",\n\t\t\t\t    \"HELLO\": \"Hello, GRAPHQL!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc Test_fieldFunc(t *testing.T) {\n\tsdl := `\n\t\ttype Query {\n\t\t\thello(name: String!): String!\n\t\t}\n\t`\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(sdl,\n\t\t\t\tfunc() interface{} {\n\t\t\t\t\ttype helloTagResolver struct {\n\t\t\t\t\t\tHello func(args struct{ Name string }) string\n\t\t\t\t\t}\n\t\t\t\t\tfn := func(args struct{ Name string }) string {\n\t\t\t\t\t\treturn \"Hello, \" + args.Name + \"!\"\n\t\t\t\t\t}\n\t\t\t\t\treturn &helloTagResolver{\n\t\t\t\t\t\tHello: fn,\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tgraphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello(name: \"GraphQL\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t    \"hello\": \"Hello, GraphQL!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(sdl,\n\t\t\t\tfunc() interface{} {\n\t\t\t\t\ttype helloTagResolver struct {\n\t\t\t\t\t\tGreet func(ctx context.Context, args struct{ Name string }) (string, error) `graphql:\"hello\"`\n\t\t\t\t\t}\n\t\t\t\t\tfn := func(_ context.Context, args struct{ Name string }) (string, error) {\n\t\t\t\t\t\treturn \"Hello, \" + args.Name + \"!\", nil\n\t\t\t\t\t}\n\t\t\t\t\treturn &helloTagResolver{\n\t\t\t\t\t\tGreet: fn,\n\t\t\t\t\t}\n\t\t\t\t}(),\n\t\t\t\tgraphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello(name: \"GraphQL\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t    \"hello\": \"Hello, GraphQL!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "id.go",
          "type": "blob",
          "size": 0.568359375,
          "content": "package graphql\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n// ID represents GraphQL's \"ID\" scalar type. A custom type may be used instead.\ntype ID string\n\nfunc (ID) ImplementsGraphQLType(name string) bool {\n\treturn name == \"ID\"\n}\n\nfunc (id *ID) UnmarshalGraphQL(input interface{}) error {\n\tvar err error\n\tswitch input := input.(type) {\n\tcase string:\n\t\t*id = ID(input)\n\tcase int32:\n\t\t*id = ID(strconv.Itoa(int(input)))\n\tdefault:\n\t\terr = fmt.Errorf(\"wrong type for ID: %T\", input)\n\t}\n\treturn err\n}\n\nfunc (id ID) MarshalJSON() ([]byte, error) {\n\treturn strconv.AppendQuote(nil, string(id)), nil\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "introspection.go",
          "type": "blob",
          "size": 2.119140625,
          "content": "package graphql\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/graph-gophers/graphql-go/internal/exec/resolvable\"\n\t\"github.com/graph-gophers/graphql-go/introspection\"\n)\n\n// Inspect allows inspection of the given schema.\nfunc (s *Schema) Inspect() *introspection.Schema {\n\treturn introspection.WrapSchema(s.schema)\n}\n\n// ToJSON encodes the schema in a JSON format used by tools like Relay.\nfunc (s *Schema) ToJSON() ([]byte, error) {\n\tresult := s.exec(context.Background(), introspectionQuery, \"\", nil, &resolvable.Schema{\n\t\tMeta:   s.res.Meta,\n\t\tQuery:  &resolvable.Object{},\n\t\tSchema: *s.schema,\n\t})\n\tif len(result.Errors) != 0 {\n\t\tpanic(result.Errors[0])\n\t}\n\treturn json.MarshalIndent(result.Data, \"\", \"\\t\")\n}\n\nvar introspectionQuery = `\n  query {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`\n"
        },
        {
          "name": "introspection",
          "type": "tree",
          "content": null
        },
        {
          "name": "introspection_test.go",
          "type": "blob",
          "size": 1.9072265625,
          "content": "package graphql_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/example/social\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n)\n\nfunc TestSchema_ToJSON(t *testing.T) {\n\tt.Parallel()\n\n\ttype args struct {\n\t\tSchema *graphql.Schema\n\t}\n\ttype want struct {\n\t\tJSON []byte\n\t}\n\ttestTable := []struct {\n\t\tName string\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t{\n\t\t\tName: \"Social Schema\",\n\t\t\tArgs: args{Schema: graphql.MustParseSchema(social.Schema, &social.Resolver{}, graphql.UseFieldResolvers())},\n\t\t\tWant: want{JSON: mustReadFile(\"example/social/introspect.json\")},\n\t\t},\n\t\t{\n\t\t\tName: \"Star Wars Schema\",\n\t\t\tArgs: args{Schema: graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{})},\n\t\t\tWant: want{JSON: mustReadFile(\"example/starwars/introspect.json\")},\n\t\t},\n\t\t{\n\t\t\tName: \"Star Wars Schema without Resolver\",\n\t\t\tArgs: args{Schema: graphql.MustParseSchema(starwars.Schema, nil)},\n\t\t\tWant: want{JSON: mustReadFile(\"example/starwars/introspect.json\")},\n\t\t},\n\t}\n\n\tfor _, tt := range testTable {\n\t\tt.Run(tt.Name, func(t *testing.T) {\n\t\t\tj, err := tt.Args.Schema.ToJSON()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"invalid schema %s\", err.Error())\n\t\t\t}\n\n\t\t\t// Verify JSON to avoid red herring errors.\n\t\t\tgot, err := formatJSON(j)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"got: invalid JSON: %s\", err)\n\t\t\t}\n\t\t\twant, err := formatJSON(tt.Want.JSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"want: invalid JSON: %s\", err)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(got, want) {\n\t\t\t\tt.Logf(\"got:  %s\", got)\n\t\t\t\tt.Logf(\"want: %s\", want)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc formatJSON(data []byte) ([]byte, error) {\n\tvar v interface{}\n\tif err := json.Unmarshal(data, &v); err != nil {\n\t\treturn nil, err\n\t}\n\tformatted, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn formatted, nil\n}\n\nfunc mustReadFile(filename string) []byte {\n\tb, err := os.ReadFile(filename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "nullable_types.go",
          "type": "blob",
          "size": 3.8994140625,
          "content": "package graphql\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// NullID is an ID that can be null. Use it in input structs to\n// differentiate a value explicitly set to null from an omitted value.\n// When the value is defined (either null or a value) Set is true.\ntype NullID struct {\n\tValue *ID\n\tSet   bool\n}\n\nfunc (NullID) ImplementsGraphQLType(name string) bool {\n\treturn name == \"ID\"\n}\n\nfunc (s *NullID) UnmarshalGraphQL(input interface{}) error {\n\ts.Set = true\n\n\tif input == nil {\n\t\treturn nil\n\t}\n\n\ts.Value = new(ID)\n\treturn s.Value.UnmarshalGraphQL(input)\n}\n\nfunc (s *NullID) Nullable() {}\n\n// NullString is a string that can be null. Use it in input structs to\n// differentiate a value explicitly set to null from an omitted value.\n// When the value is defined (either null or a value) Set is true.\ntype NullString struct {\n\tValue *string\n\tSet   bool\n}\n\nfunc (NullString) ImplementsGraphQLType(name string) bool {\n\treturn name == \"String\"\n}\n\nfunc (s *NullString) UnmarshalGraphQL(input interface{}) error {\n\ts.Set = true\n\n\tif input == nil {\n\t\treturn nil\n\t}\n\n\tswitch v := input.(type) {\n\tcase string:\n\t\ts.Value = &v\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"wrong type for String: %T\", v)\n\t}\n}\n\nfunc (s *NullString) Nullable() {}\n\n// NullBool is a boolean that can be null. Use it in input structs to\n// differentiate a value explicitly set to null from an omitted value.\n// When the value is defined (either null or a value) Set is true.\ntype NullBool struct {\n\tValue *bool\n\tSet   bool\n}\n\nfunc (NullBool) ImplementsGraphQLType(name string) bool {\n\treturn name == \"Boolean\"\n}\n\nfunc (s *NullBool) UnmarshalGraphQL(input interface{}) error {\n\ts.Set = true\n\n\tif input == nil {\n\t\treturn nil\n\t}\n\n\tswitch v := input.(type) {\n\tcase bool:\n\t\ts.Value = &v\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"wrong type for Boolean: %T\", v)\n\t}\n}\n\nfunc (s *NullBool) Nullable() {}\n\n// NullInt is an int that can be null. Use it in input structs to\n// differentiate a value explicitly set to null from an omitted value.\n// When the value is defined (either null or a value) Set is true.\ntype NullInt struct {\n\tValue *int32\n\tSet   bool\n}\n\nfunc (NullInt) ImplementsGraphQLType(name string) bool {\n\treturn name == \"Int\"\n}\n\nfunc (s *NullInt) UnmarshalGraphQL(input interface{}) error {\n\ts.Set = true\n\n\tif input == nil {\n\t\treturn nil\n\t}\n\n\tswitch v := input.(type) {\n\tcase int32:\n\t\ts.Value = &v\n\t\treturn nil\n\tcase float64:\n\t\tcoerced := int32(v)\n\t\tif v < math.MinInt32 || v > math.MaxInt32 || float64(coerced) != v {\n\t\t\treturn fmt.Errorf(\"not a 32-bit integer\")\n\t\t}\n\t\ts.Value = &coerced\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"wrong type for Int: %T\", v)\n\t}\n}\n\nfunc (s *NullInt) Nullable() {}\n\n// NullFloat is a float that can be null. Use it in input structs to\n// differentiate a value explicitly set to null from an omitted value.\n// When the value is defined (either null or a value) Set is true.\ntype NullFloat struct {\n\tValue *float64\n\tSet   bool\n}\n\nfunc (NullFloat) ImplementsGraphQLType(name string) bool {\n\treturn name == \"Float\"\n}\n\nfunc (s *NullFloat) UnmarshalGraphQL(input interface{}) error {\n\ts.Set = true\n\n\tif input == nil {\n\t\treturn nil\n\t}\n\n\tswitch v := input.(type) {\n\tcase float64:\n\t\ts.Value = &v\n\t\treturn nil\n\tcase int32:\n\t\tcoerced := float64(v)\n\t\ts.Value = &coerced\n\t\treturn nil\n\tcase int:\n\t\tcoerced := float64(v)\n\t\ts.Value = &coerced\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"wrong type for Float: %T\", v)\n\t}\n}\n\nfunc (s *NullFloat) Nullable() {}\n\n// NullTime is a time value that can be null. Use it in input structs to\n// differentiate a value explicitly set to null from an omitted value.\n// When the value is defined (either null or a value) Set is true.\ntype NullTime struct {\n\tValue *Time\n\tSet   bool\n}\n\nfunc (NullTime) ImplementsGraphQLType(name string) bool {\n\treturn name == \"Time\"\n}\n\nfunc (s *NullTime) UnmarshalGraphQL(input interface{}) error {\n\ts.Set = true\n\n\tif input == nil {\n\t\treturn nil\n\t}\n\n\ts.Value = new(Time)\n\treturn s.Value.UnmarshalGraphQL(input)\n}\n\nfunc (s *NullTime) Nullable() {}\n"
        },
        {
          "name": "nullable_types_test.go",
          "type": "blob",
          "size": 5.5048828125,
          "content": "package graphql_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/decode\"\n)\n\nfunc TestNullID_ImplementsUnmarshaler(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\t// assert *NullID implements decode.Unmarshaler interface\n\tvar _ decode.Unmarshaler = (*graphql.NullID)(nil)\n}\n\nfunc TestNullID_UnmarshalGraphQL(t *testing.T) {\n\ttype args struct {\n\t\tinput interface{}\n\t}\n\n\tgood := graphql.ID(\"1234\")\n\tref := graphql.NullID{\n\t\tValue: &good,\n\t\tSet:   true,\n\t}\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\targs    args\n\t\t\twantErr string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"boolean\",\n\t\t\t\targs:    args{input: true},\n\t\t\t\twantErr: \"wrong type for ID: bool\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"int\",\n\t\t\t\targs:    args{input: 1},\n\t\t\t\twantErr: \"wrong type for ID: int\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgt := &graphql.NullID{}\n\t\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\t\tif err.Error() != tt.wantErr {\n\t\t\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v, want = %s\", err, tt.wantErr)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tt.Error(\"UnmarshalGraphQL() expected error not raised\")\n\t\t\t})\n\t\t}\n\t})\n\n\ttests := []struct {\n\t\tname   string\n\t\targs   args\n\t\twantEq graphql.NullID\n\t}{\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tinput: string(good),\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgt := new(graphql.NullID)\n\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif *gt.Value != *tt.wantEq.Value {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() got = %v, want = %v\", *gt.Value, *tt.wantEq.Value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNullInt_ImplementsUnmarshaler(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\t// assert *NullInt implements decode.Unmarshaler interface\n\tvar _ decode.Unmarshaler = (*graphql.NullInt)(nil)\n}\n\nfunc TestNullInt_UnmarshalGraphQL(t *testing.T) {\n\ttype args struct {\n\t\tinput interface{}\n\t}\n\n\ta := float64(math.MaxInt32 + 1)\n\tb := float64(math.MinInt32 - 1)\n\tc := 1234.6\n\tgood := int32(1234)\n\tref := graphql.NullInt{\n\t\tValue: &good,\n\t\tSet:   true,\n\t}\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\targs    args\n\t\t\twantErr string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"boolean\",\n\t\t\t\targs:    args{input: true},\n\t\t\t\twantErr: \"wrong type for Int: bool\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"int32 out of range (+)\",\n\t\t\t\targs: args{\n\t\t\t\t\tinput: a,\n\t\t\t\t},\n\t\t\t\twantErr: \"not a 32-bit integer\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"int32 out of range (-)\",\n\t\t\t\targs: args{\n\t\t\t\t\tinput: b,\n\t\t\t\t},\n\t\t\t\twantErr: \"not a 32-bit integer\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"non-integer\",\n\t\t\t\targs: args{\n\t\t\t\t\tinput: c,\n\t\t\t\t},\n\t\t\t\twantErr: \"not a 32-bit integer\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgt := &graphql.NullInt{}\n\t\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\t\tif err.Error() != tt.wantErr {\n\t\t\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v, want = %s\", err, tt.wantErr)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tt.Error(\"UnmarshalGraphQL() expected error not raised\")\n\t\t\t})\n\t\t}\n\t})\n\n\ttests := []struct {\n\t\tname   string\n\t\targs   args\n\t\twantEq graphql.NullInt\n\t}{\n\t\t{\n\t\t\tname: \"int32\",\n\t\t\targs: args{\n\t\t\t\tinput: good,\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t\t{\n\t\t\tname: \"float64\",\n\t\t\targs: args{\n\t\t\t\tinput: float64(good),\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgt := new(graphql.NullInt)\n\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif *gt.Value != *tt.wantEq.Value {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() got = %v, want = %v\", *gt.Value, *tt.wantEq.Value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNullFloat_ImplementsUnmarshaler(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\t// assert *NullFloat implements decode.Unmarshaler interface\n\tvar _ decode.Unmarshaler = (*graphql.NullFloat)(nil)\n}\n\nfunc TestNullFloat_UnmarshalGraphQL(t *testing.T) {\n\ttype args struct {\n\t\tinput interface{}\n\t}\n\n\tgood := float64(1234)\n\tref := graphql.NullFloat{\n\t\tValue: &good,\n\t\tSet:   true,\n\t}\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\targs    args\n\t\t\twantErr string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"boolean\",\n\t\t\t\targs:    args{input: true},\n\t\t\t\twantErr: \"wrong type for Float: bool\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgt := new(graphql.NullFloat)\n\t\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\t\tif err.Error() != tt.wantErr {\n\t\t\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v, want = %s\", err, tt.wantErr)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tt.Error(\"UnmarshalGraphQL() expected error not raised\")\n\t\t\t})\n\t\t}\n\t})\n\n\ttests := []struct {\n\t\tname   string\n\t\targs   args\n\t\twantEq graphql.NullFloat\n\t}{\n\t\t{\n\t\t\tname: \"int\",\n\t\t\targs: args{\n\t\t\t\tinput: int(good),\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t\t{\n\t\t\tname: \"int32\",\n\t\t\targs: args{\n\t\t\t\tinput: int32(good),\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t\t{\n\t\t\tname: \"float64\",\n\t\t\targs: args{\n\t\t\t\tinput: good,\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgt := new(graphql.NullFloat)\n\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif *gt.Value != *tt.wantEq.Value {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() got = %v, want = %v\", *gt.Value, *tt.wantEq.Value)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "relay",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "subscription_test.go",
          "type": "blob",
          "size": 12.1318359375,
          "content": "package graphql_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\tgraphql \"github.com/graph-gophers/graphql-go\"\n\tqerrors \"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/gqltesting\"\n)\n\ntype rootResolver struct {\n\t*helloResolver\n\t*helloSaidResolver\n\t*helloSaidNullableResolver\n}\n\ntype helloResolver struct{}\n\nfunc (r *helloResolver) Hello() string {\n\treturn \"Hello world!\"\n}\n\nvar errResolver = errors.New(\"resolver error\")\nvar resolverQueryErr = &qerrors.QueryError{Message: \"query\", ResolverError: errResolver}\n\ntype helloSaidResolver struct {\n\terr      error\n\tupstream <-chan *helloSaidEventResolver\n}\n\ntype helloSaidEventResolver struct {\n\tmsg string\n\terr error\n}\n\nfunc (r *helloSaidResolver) HelloSaid(ctx context.Context) (chan *helloSaidEventResolver, error) {\n\tif r.err != nil {\n\t\treturn nil, r.err\n\t}\n\n\tc := make(chan *helloSaidEventResolver)\n\tgo func() {\n\t\tfor r := range r.upstream {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tclose(c)\n\t\t\t\treturn\n\t\t\tcase c <- r:\n\t\t\t}\n\t\t}\n\t\tclose(c)\n\t}()\n\n\treturn c, nil\n}\n\nfunc (r *rootResolver) OtherField(ctx context.Context) <-chan int32 {\n\treturn make(chan int32)\n}\n\nfunc (r *helloSaidEventResolver) Msg() (string, error) {\n\treturn r.msg, r.err\n}\n\nfunc closedUpstream(rr ...*helloSaidEventResolver) <-chan *helloSaidEventResolver {\n\tc := make(chan *helloSaidEventResolver, len(rr))\n\tfor _, r := range rr {\n\t\tc <- r\n\t}\n\tclose(c)\n\treturn c\n}\n\ntype helloSaidNullableResolver struct {\n\terr      error\n\tupstream <-chan *helloSaidNullableEventResolver\n}\n\ntype helloSaidNullableEventResolver struct {\n\tmsg *string\n\terr error\n}\n\nfunc (r *helloSaidNullableResolver) HelloSaidNullable(ctx context.Context) (chan *helloSaidNullableEventResolver, error) {\n\tif r.err != nil {\n\t\treturn nil, r.err\n\t}\n\n\tc := make(chan *helloSaidNullableEventResolver)\n\tgo func() {\n\t\tfor r := range r.upstream {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tclose(c)\n\t\t\t\treturn\n\t\t\tcase c <- r:\n\t\t\t}\n\t\t}\n\t\tclose(c)\n\t}()\n\n\treturn c, nil\n}\n\nfunc (r *helloSaidNullableEventResolver) Msg() (*string, error) {\n\treturn r.msg, r.err\n}\n\nfunc closedUpstreamNullable(rr ...*helloSaidNullableEventResolver) <-chan *helloSaidNullableEventResolver {\n\tc := make(chan *helloSaidNullableEventResolver, len(rr))\n\tfor _, r := range rr {\n\t\tc <- r\n\t}\n\tclose(c)\n\treturn c\n}\n\nfunc TestSchemaSubscribe(t *testing.T) {\n\tgqltesting.RunSubscribes(t, []*gqltesting.TestSubscription{\n\t\t{\n\t\t\tName: \"ok\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{\n\t\t\t\thelloSaidResolver: &helloSaidResolver{\n\t\t\t\t\tupstream: closedUpstream(\n\t\t\t\t\t\t&helloSaidEventResolver{msg: \"Hello world!\"},\n\t\t\t\t\t\t&helloSaidEventResolver{err: errResolver},\n\t\t\t\t\t\t&helloSaidEventResolver{msg: \"Hello again!\"},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tQuery: `\n\t\t\t\tsubscription onHelloSaid {\n\t\t\t\t\thelloSaid {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"helloSaid\": {\n\t\t\t\t\t\t\t\t\"msg\": \"Hello world!\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\tnull\n\t\t\t\t\t`),\n\t\t\t\t\tErrors: []*qerrors.QueryError{qerrors.Errorf(\"%s\", errResolver)},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"helloSaid\": {\n\t\t\t\t\t\t\t\t\"msg\": \"Hello again!\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"parse_errors\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{}),\n\t\t\tQuery:  `invalid graphQL query`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tErrors: []*qerrors.QueryError{qerrors.Errorf(\"%s\", `syntax error: unexpected \"invalid\", expecting \"fragment\" (line 1, column 9)`)},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"subscribe_to_query_succeeds\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Hello {\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"subscription_resolver_can_error\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{\n\t\t\t\thelloSaidResolver: &helloSaidResolver{err: errResolver},\n\t\t\t}),\n\t\t\tQuery: `\n\t\t\t\tsubscription onHelloSaid {\n\t\t\t\t\thelloSaid {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\tnull\n\t\t\t\t\t`),\n\t\t\t\t\tErrors: []*qerrors.QueryError{qerrors.Errorf(\"%s\", errResolver)},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"subscription_resolver_can_error_optional_msg\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{\n\t\t\t\thelloSaidNullableResolver: &helloSaidNullableResolver{\n\t\t\t\t\tupstream: closedUpstreamNullable(\n\t\t\t\t\t\t&helloSaidNullableEventResolver{err: errResolver},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tQuery: `\n\t\t\t\tsubscription onHelloSaid {\n\t\t\t\t\thelloSaidNullable {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"helloSaidNullable\": {\n\t\t\t\t\t\t\t\t\"msg\": null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t\tErrors: []*qerrors.QueryError{qerrors.Errorf(\"%s\", errResolver)},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"subscription_resolver_can_error_optional_event\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{\n\t\t\t\thelloSaidNullableResolver: &helloSaidNullableResolver{err: errResolver},\n\t\t\t}),\n\t\t\tQuery: `\n\t\t\t\tsubscription onHelloSaid {\n\t\t\t\t\thelloSaidNullable {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"helloSaidNullable\": null\n\t\t\t\t\t\t}\n\t\t\t\t\t`),\n\t\t\t\t\tErrors: []*qerrors.QueryError{qerrors.Errorf(\"%s\", errResolver)},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"subscription_resolver_can_query_error\",\n\t\t\tSchema: graphql.MustParseSchema(schema, &rootResolver{\n\t\t\t\thelloSaidResolver: &helloSaidResolver{err: resolverQueryErr},\n\t\t\t}),\n\t\t\tQuery: `\n\t\t\t\tsubscription onHelloSaid {\n\t\t\t\t\thelloSaid {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`\n\t\t\t\t\t\tnull\n\t\t\t\t\t`),\n\t\t\t\t\tErrors: []*qerrors.QueryError{resolverQueryErr},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:   \"schema_without_resolver_errors\",\n\t\t\tSchema: graphql.MustParseSchema(schema, nil),\n\t\t\tQuery: `\n\t\t\t\tsubscription onHelloSaid {\n\t\t\t\t\thelloSaid {\n\t\t\t\t\t\tmsg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErr: errors.New(\"schema created without resolver, can not subscribe\"),\n\t\t},\n\t})\n}\n\nfunc TestRootOperations_invalidSubscriptionSchema(t *testing.T) {\n\ttype args struct {\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Subscription as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tsubscription: String\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\tthing: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"subscription\" must be an OBJECT`},\n\t\t},\n\t\t\"Subscription declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tsubscription: Subscription\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Subscription\" not found`},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, nil)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Logf(\"got:  %v\", err)\n\t\t\t\tt.Logf(\"want: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRootOperations_validSubscriptionSchema(t *testing.T) {\n\tgqltesting.RunSubscribes(t, []*gqltesting.TestSubscription{\n\t\t{\n\t\t\tName: \"Default name, schema omitted\",\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Subscription {\n\t\t\t\t\thelloSaid: HelloSaidEvent!\n\t\t\t\t}\n\t\t\t\ttype HelloSaidEvent {\n\t\t\t\t\tmsg: String!\n\t\t\t\t}\n\t\t\t`, &rootResolver{helloSaidResolver: &helloSaidResolver{upstream: closedUpstream(&helloSaidEventResolver{msg: \"Hello world!\"})}}),\n\t\t\tQuery: `subscription { helloSaid { msg } }`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`{\"helloSaid\": {\"msg\": \"Hello world!\"}}`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"Custom name, schema omitted\",\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype SubscriptionType {\n\t\t\t\t\thelloSaid: HelloSaidEvent!\n\t\t\t\t}\n\t\t\t\ttype HelloSaidEvent {\n\t\t\t\t\tmsg: String!\n\t\t\t\t}\n\t\t\t`, &rootResolver{}),\n\t\t\tQuery:       `subscription { helloSaid { msg } }`,\n\t\t\tExpectedErr: errors.New(\"no subscriptions are offered by the schema\"),\n\t\t},\n\t\t{\n\t\t\tName: \"Custom name, schema required\",\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tsubscription: SubscriptionType\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t\ttype SubscriptionType {\n\t\t\t\t\t\thelloSaid: HelloSaidEvent!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloSaidEvent {\n\t\t\t\t\t\tmsg: String!\n\t\t\t\t\t}\n\t\t\t`, &rootResolver{helloSaidResolver: &helloSaidResolver{upstream: closedUpstream(&helloSaidEventResolver{msg: \"Hello world!\"})}}),\n\t\t\tQuery: `subscription { helloSaid { msg } }`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tData: json.RawMessage(`{\"helloSaid\": {\"msg\": \"Hello world!\"}}`),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"Explicit schema without subscription field\",\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t\ttype Subscription {\n\t\t\t\t\t\thelloSaid: HelloSaidEvent!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloSaidEvent {\n\t\t\t\t\t\tmsg: String!\n\t\t\t\t\t}\n\t\t\t`, &rootResolver{helloSaidResolver: &helloSaidResolver{upstream: closedUpstream(&helloSaidEventResolver{msg: \"Hello world!\"})}}),\n\t\t\tQuery:       `subscription { helloSaid { msg } }`,\n\t\t\tExpectedErr: errors.New(\"no subscriptions are offered by the schema\"),\n\t\t},\n\t})\n}\n\nfunc TestError_multiple_subscription_fields(t *testing.T) {\n\tgqltesting.RunSubscribes(t, []*gqltesting.TestSubscription{\n\t\t{\n\t\t\tName: \"Explicit schema without subscription field\",\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tsubscription: Subscription\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t\ttype Subscription {\n\t\t\t\t\t\thelloSaid: HelloSaidEvent!\n\t\t\t\t\t\totherField: Int!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloSaidEvent {\n\t\t\t\t\t\tmsg: String!\n\t\t\t\t\t}\n\t\t\t`, &rootResolver{helloSaidResolver: &helloSaidResolver{upstream: closedUpstream(&helloSaidEventResolver{msg: \"Hello world!\"})}}),\n\t\t\tQuery: `subscription { helloSaid { msg } otherField }`,\n\t\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t\t{\n\t\t\t\t\tErrors: []*qerrors.QueryError{qerrors.Errorf(\"can subscribe to at most one subscription at a time\")},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nconst schema = `\n\tschema {\n\t\tsubscription: Subscription,\n\t\tquery: Query\n\t}\n\n\ttype Subscription {\n\t\thelloSaid: HelloSaidEvent!\n\t\thelloSaidNullable: HelloSaidEventNullable\n\t}\n\n\ttype HelloSaidEvent {\n\t\tmsg: String!\n\t}\n\n\ttype HelloSaidEventNullable {\n\t\tmsg: String\n\t}\n\n\ttype Query {\n\t\thello: String!\n\t}\n`\n\ntype subscriptionsCustomTimeout struct{}\n\ntype messageResolver struct{}\n\nfunc (r messageResolver) Msg() string {\n\ttime.Sleep(5 * time.Millisecond)\n\treturn \"failed!\"\n}\n\nfunc (r *subscriptionsCustomTimeout) OnTimeout() <-chan *messageResolver {\n\tc := make(chan *messageResolver)\n\tgo func() {\n\t\tc <- &messageResolver{}\n\t\tclose(c)\n\t}()\n\n\treturn c\n}\n\nfunc TestSchemaSubscribe_CustomResolverTimeout(t *testing.T) {\n\tgqltesting.RunSubscribe(t, &gqltesting.TestSubscription{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {}\n\t\t\ttype Subscription {\n\t\t\t\tonTimeout : Message!\n\t\t\t}\n\n\t\t\ttype Message {\n\t\t\t\tmsg: String!\n\t\t\t}\n\t\t`,\n\t\t\t&subscriptionsCustomTimeout{},\n\t\t\tgraphql.SubscribeResolverTimeout(1*time.Nanosecond)),\n\t\tQuery: `\n\t\t\tsubscription {\n\t\t\t\tonTimeout { msg }\n\t\t\t}\n\t\t`,\n\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t{Errors: []*qerrors.QueryError{{Message: \"context deadline exceeded\"}}},\n\t\t},\n\t})\n}\n\ntype subscriptionsPanicInResolver struct{}\n\nfunc (r *subscriptionsPanicInResolver) OnPanic() <-chan string {\n\tpanic(\"subscriptionsPanicInResolver\")\n}\n\nfunc TestSchemaSubscribe_PanicInResolver(t *testing.T) {\n\tr := &struct {\n\t\t*subscriptionsPanicInResolver\n\t}{\n\t\tsubscriptionsPanicInResolver: &subscriptionsPanicInResolver{},\n\t}\n\tgqltesting.RunSubscribe(t, &gqltesting.TestSubscription{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {}\n\t\t\ttype Subscription {\n\t\t\t\tonPanic : String!\n\t\t\t}\n\t\t`, r),\n\t\tQuery: `\n\t\t\tsubscription {\n\t\t\t\tonPanic\n\t\t\t}\n\t\t`,\n\t\tExpectedResults: []gqltesting.TestResponse{\n\t\t\t{Errors: []*qerrors.QueryError{{Message: \"panic occurred: subscriptionsPanicInResolver\"}}},\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "subscriptions.go",
          "type": "blob",
          "size": 3.2109375,
          "content": "package graphql\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\tqerrors \"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/internal/common\"\n\t\"github.com/graph-gophers/graphql-go/internal/exec\"\n\t\"github.com/graph-gophers/graphql-go/internal/exec/resolvable\"\n\t\"github.com/graph-gophers/graphql-go/internal/exec/selected\"\n\t\"github.com/graph-gophers/graphql-go/internal/query\"\n\t\"github.com/graph-gophers/graphql-go/internal/validation\"\n\t\"github.com/graph-gophers/graphql-go/introspection\"\n)\n\n// Subscribe returns a response channel for the given subscription with the schema's\n// resolver. It returns an error if the schema was created without a resolver.\n// If the context gets cancelled, the response channel will be closed and no\n// further resolvers will be called. The context error will be returned as soon\n// as possible (not immediately).\nfunc (s *Schema) Subscribe(ctx context.Context, queryString string, operationName string, variables map[string]interface{}) (<-chan interface{}, error) {\n\tif !s.res.SubscriptionResolver.IsValid() {\n\t\treturn nil, errors.New(\"schema created without resolver, can not subscribe\")\n\t}\n\tif _, ok := s.schema.RootOperationTypes[\"subscription\"]; !ok {\n\t\treturn nil, errors.New(\"no subscriptions are offered by the schema\")\n\t}\n\treturn s.subscribe(ctx, queryString, operationName, variables, s.res), nil\n}\n\nfunc (s *Schema) subscribe(ctx context.Context, queryString string, operationName string, variables map[string]interface{}, res *resolvable.Schema) <-chan interface{} {\n\tdoc, qErr := query.Parse(queryString)\n\tif qErr != nil {\n\t\treturn sendAndReturnClosed(&Response{Errors: []*qerrors.QueryError{qErr}})\n\t}\n\n\tvalidationFinish := s.validationTracer.TraceValidation(ctx)\n\terrs := validation.Validate(s.schema, doc, variables, s.maxDepth)\n\tvalidationFinish(errs)\n\tif len(errs) != 0 {\n\t\treturn sendAndReturnClosed(&Response{Errors: errs})\n\t}\n\n\top, err := getOperation(doc, operationName)\n\tif err != nil {\n\t\treturn sendAndReturnClosed(&Response{Errors: []*qerrors.QueryError{qerrors.Errorf(\"%s\", err)}})\n\t}\n\n\tr := &exec.Request{\n\t\tRequest: selected.Request{\n\t\t\tDoc:    doc,\n\t\t\tVars:   variables,\n\t\t\tSchema: s.schema,\n\t\t},\n\t\tLimiter:                  make(chan struct{}, s.maxParallelism),\n\t\tTracer:                   s.tracer,\n\t\tLogger:                   s.logger,\n\t\tPanicHandler:             s.panicHandler,\n\t\tSubscribeResolverTimeout: s.subscribeResolverTimeout,\n\t}\n\tvarTypes := make(map[string]*introspection.Type)\n\tfor _, v := range op.Vars {\n\t\tt, err := common.ResolveType(v.Type, s.schema.Resolve)\n\t\tif err != nil {\n\t\t\treturn sendAndReturnClosed(&Response{Errors: []*qerrors.QueryError{err}})\n\t\t}\n\t\tvarTypes[v.Name.Name] = introspection.WrapType(t)\n\t}\n\n\tif op.Type == query.Query || op.Type == query.Mutation {\n\t\tdata, errs := r.Execute(ctx, res, op)\n\t\treturn sendAndReturnClosed(&Response{Data: data, Errors: errs})\n\t}\n\n\tresponses := r.Subscribe(ctx, res, op)\n\tc := make(chan interface{})\n\tgo func() {\n\tLoop:\n\t\tfor resp := range responses {\n\t\t\tselect {\n\t\t\tcase c <- &Response{Data: resp.Data, Errors: resp.Errors}:\n\t\t\t\tcontinue\n\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak Loop\n\t\t\t}\n\t\t}\n\t\tclose(c)\n\t}()\n\n\treturn c\n}\n\nfunc sendAndReturnClosed(resp *Response) chan interface{} {\n\tc := make(chan interface{}, 1)\n\tc <- resp\n\tclose(c)\n\treturn c\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 1.4638671875,
          "content": "package graphql\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Time is a custom GraphQL type to represent an instant in time. It has to be added to a schema\n// via \"scalar Time\" since it is not a predeclared GraphQL type like \"ID\".\ntype Time struct {\n\ttime.Time\n}\n\n// ImplementsGraphQLType maps this custom Go type\n// to the graphql scalar type in the schema.\nfunc (Time) ImplementsGraphQLType(name string) bool {\n\treturn name == \"Time\"\n}\n\n// UnmarshalGraphQL is a custom unmarshaler for Time\n//\n// This function will be called whenever you use the\n// time scalar as an input\nfunc (t *Time) UnmarshalGraphQL(input interface{}) error {\n\tswitch input := input.(type) {\n\tcase time.Time:\n\t\tt.Time = input\n\t\treturn nil\n\tcase string:\n\t\tvar err error\n\t\tt.Time, err = time.Parse(time.RFC3339, input)\n\t\treturn err\n\tcase []byte:\n\t\tvar err error\n\t\tt.Time, err = time.Parse(time.RFC3339, string(input))\n\t\treturn err\n\tcase int32:\n\t\tt.Time = time.Unix(int64(input), 0)\n\t\treturn nil\n\tcase int64:\n\t\tif input >= 1e10 {\n\t\t\tsec := input / 1e9\n\t\t\tnsec := input - (sec * 1e9)\n\t\t\tt.Time = time.Unix(sec, nsec)\n\t\t} else {\n\t\t\tt.Time = time.Unix(input, 0)\n\t\t}\n\t\treturn nil\n\tcase float64:\n\t\tt.Time = time.Unix(int64(input), 0)\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"wrong type for Time: %T\", input)\n\t}\n}\n\n// MarshalJSON is a custom marshaler for Time\n//\n// This function will be called whenever you\n// query for fields that use the Time type\nfunc (t Time) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(t.Time)\n}\n"
        },
        {
          "name": "time_test.go",
          "type": "blob",
          "size": 3.2265625,
          "content": "package graphql_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\t\"github.com/graph-gophers/graphql-go/decode\"\n)\n\nfunc TestTime_ImplementsUnmarshaler(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\t// assert *Time implements decode.Unmarshaler interface\n\tvar _ decode.Unmarshaler = (*graphql.Time)(nil)\n}\n\nfunc TestTime_ImplementsGraphQLType(t *testing.T) {\n\tgt := &graphql.Time{}\n\n\tif gt.ImplementsGraphQLType(\"foobar\") {\n\t\tt.Error(\"Type *Time must not claim to implement GraphQL type 'foobar'\")\n\t}\n\n\tif !gt.ImplementsGraphQLType(\"Time\") {\n\t\tt.Error(\"Failed asserting *Time implements GraphQL type Time\")\n\t}\n}\n\nfunc TestTime_MarshalJSON(t *testing.T) {\n\tvar err error\n\tvar b1, b2 []byte\n\tref := time.Date(2021, time.April, 20, 12, 3, 23, 551476231, time.UTC)\n\n\tif b1, err = json.Marshal(ref); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif b2, err = json.Marshal(graphql.Time{Time: ref}); err != nil {\n\t\tt.Errorf(\"MarshalJSON() error = %v\", err)\n\t\treturn\n\t}\n\n\tif !bytes.Equal(b1, b2) {\n\t\tt.Errorf(\"MarshalJSON() got = %s, want = %s\", b2, b1)\n\t}\n}\n\nfunc TestTime_UnmarshalGraphQL(t *testing.T) {\n\ttype args struct {\n\t\tinput interface{}\n\t}\n\tref := time.Date(2021, time.April, 20, 12, 3, 23, 551476231, time.UTC)\n\trefZeroNano := time.Unix(ref.Unix(), 0)\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\targs    args\n\t\t\twantErr string\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"boolean\",\n\t\t\t\targs:    args{input: true},\n\t\t\t\twantErr: \"wrong type for Time: bool\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"invalid format\",\n\t\t\t\targs:    args{input: ref.Format(time.ANSIC)},\n\t\t\t\twantErr: `parsing time \"Tue Apr 20 12:03:23 2021\" as \"2006-01-02T15:04:05Z07:00\": cannot parse \"Tue Apr 20 12:03:23 2021\" as \"2006\"`,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgt := &graphql.Time{}\n\t\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\t\tif err.Error() != tt.wantErr {\n\t\t\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v, want = %s\", err, tt.wantErr)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tt.Error(\"UnmarshalGraphQL() expected error not raised\")\n\t\t\t})\n\t\t}\n\t})\n\n\ttests := []struct {\n\t\tname   string\n\t\targs   args\n\t\twantEq time.Time\n\t}{\n\t\t{\n\t\t\tname: \"time.Time\",\n\t\t\targs: args{\n\t\t\t\tinput: ref,\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\targs: args{\n\t\t\t\tinput: ref.Format(time.RFC3339),\n\t\t\t},\n\t\t\twantEq: refZeroNano,\n\t\t},\n\t\t{\n\t\t\tname: \"bytes\",\n\t\t\targs: args{\n\t\t\t\tinput: []byte(ref.Format(time.RFC3339)),\n\t\t\t},\n\t\t\twantEq: refZeroNano,\n\t\t},\n\t\t{\n\t\t\tname: \"int32\",\n\t\t\targs: args{\n\t\t\t\tinput: int32(ref.Unix()),\n\t\t\t},\n\t\t\twantEq: refZeroNano,\n\t\t},\n\t\t{\n\t\t\tname: \"int64\",\n\t\t\targs: args{\n\t\t\t\tinput: ref.Unix(),\n\t\t\t},\n\t\t\twantEq: refZeroNano,\n\t\t},\n\t\t{\n\t\t\tname: \"int64-nano\",\n\t\t\targs: args{\n\t\t\t\tinput: ref.UnixNano(),\n\t\t\t},\n\t\t\twantEq: ref,\n\t\t},\n\t\t{\n\t\t\tname: \"float64\",\n\t\t\targs: args{\n\t\t\t\tinput: float64(ref.Unix()),\n\t\t\t},\n\t\t\twantEq: refZeroNano,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgt := &graphql.Time{}\n\t\t\tif err := gt.UnmarshalGraphQL(tt.args.input); err != nil {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() error = %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !gt.Equal(tt.wantEq) {\n\t\t\t\tt.Errorf(\"UnmarshalGraphQL() got = %v, want = %v\", gt, tt.wantEq)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "trace",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}