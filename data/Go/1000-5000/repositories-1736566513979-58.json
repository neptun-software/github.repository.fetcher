{
  "metadata": {
    "timestamp": 1736566513979,
    "page": 58,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "slack-go/slack",
      "stars": 4710,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0244140625,
          "content": "*.test\n*~\n.idea/\n/vendor/"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.189453125,
          "content": "run:\n  timeout: 6m\n  issues-exit-code: 1\nlinters:\n  disable-all: true\n  enable:\n    - goimports\n    - govet\n    - interfacer\n    - misspell\n    - structcheck\n    - unconvert\nissues:\n  new: true\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.1162109375,
          "content": "# Contributing Guide\n\nWelcome! We are glad that you want to contribute to our project! ðŸ’–\n\nThere are a just a few small guidelines you ask everyone to follow to make things a bit smoother and more consistent.\n\n## Opening Pull Requests\n\n1. It's generally best to start by opening a new issue describing the bug or feature you're intending to fix. Even if you think it's relatively minor, it's helpful to know what people are working on. Mention in the initial issue that you are planning to work on that bug or feature so that it can be assigned to you.\n\n2. Follow the normal process of [forking](https://help.github.com/articles/fork-a-repo) the project, and set up a new branch to work in. It's important that each group of changes be done in separate branches in order to ensure that a pull request only includes the commits related to that bug or feature.\n\n3. Any significant changes should almost always be accompanied by tests. The project already has some test coverage, so look at some of the existing tests if you're unsure how to go about it.\n\n4. Run `make pr-prep` to format your code and check that it passes all tests and linters.\n\n5. Do your best to have [well-formed commit messages](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html) for each change. This provides consistency throughout the project, and ensures that commit messages are able to be formatted properly by various git tools. _Pull Request Titles_ should generally follow the [conventional commit](https://www.conventionalcommits.org/en/v1.0.0/) format to ease the release note process when cutting releases.\n\n6. Finally, push the commits to your fork and submit a [pull request](https://help.github.com/articles/creating-a-pull-request). NOTE: Please do not use force-push on PRs in this repo, as it makes it more difficult for reviewers to see what has changed since the last code review. We always perform \"squash and merge\" actions on PRs in this repo, so it doesn't matter how many commits your PR has, as they will end up being a single commit after merging. This is done to make a much cleaner `git log` history and helps to find regressions in the code using existing tools such as `git bisect`.\n\n## Code Comments\n\nEvery exported method needs to have code comments that follow [Go Doc Comments](https://go.dev/doc/comment). A typical method's comments will look like this:\n\n```go\n// PostMessage sends a message to a channel.\n//\n// Slack API docs: https://api.dev.slack.com/methods/chat.postMessage\nfunc (api *Client) PostMessage(ctx context.Context, input PostMesssageInput) (PostMesssageOutput, error) {\n...\n}\n```\n\nThe first line is the name of the method followed by a short description. This could also be a longer description if needed, but there is no need to repeat any details that are documented in Slack's documentation because users are expected to follow the documentation links to learn more.\n\nAfter the description comes a link to the Slack API documentation.\n\n## Other notes on code organization\n\nCurrently, everything is defined in the main `slack` package, with API methods group separate files by the [Slack API Method Groupings](https://api.dev.slack.com/methods).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2626953125,
          "content": "Copyright (c) 2015, Norberto Lopes\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.982421875,
          "content": ".PHONY: help deps fmt lint test test-race test-integration\n\nhelp:\n\t@echo \"\"\n\t@echo \"Welcome to slack-go/slack make.\"\n\t@echo \"The following commands are available:\"\n\t@echo \"\"\n\t@echo \"    make deps              : Fetch all dependencies\"\n\t@echo \"    make fmt               : Run go fmt to fix any formatting issues\"\n\t@echo \"    make lint              : Use go vet to check for linting issues\"\n\t@echo \"    make test              : Run all short tests\"\n\t@echo \"    make test-race         : Run all tests with race condition checking\"\n\t@echo \"    make test-integration  : Run all tests without limiting to short\"\n\t@echo \"\"\n\t@echo \"    make pr-prep           : Run this before making a PR to run fmt, lint and tests\"\n\t@echo \"\"\n\ndeps:\n\t@go mod tidy\n\nfmt:\n\t@go fmt .\n\nlint:\n\t@go vet .\n\ntest:\n\t@go test -v -count=1 -timeout 300s -short ./...\n\ntest-race:\n\t@go test -v -count=1 -timeout 300s -short -race ./...\n\ntest-integration:\n\t@go test -v -count=1 -timeout 600s ./...\n\npr-prep: fmt lint test-race test-integration\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.9619140625,
          "content": "Slack API in Go [![Go Reference](https://pkg.go.dev/badge/github.com/slack-go/slack.svg)](https://pkg.go.dev/github.com/slack-go/slack)\n===============\n\nThis is the original Slack library for Go created by Norberto Lopes, transferred to a GitHub organization.\n\nYou can also chat with us on the #slack-go, #slack-go-ja Slack channel on the Gophers Slack.\n\n![logo](logo.png \"icon\")\n\nThis library supports most if not all of the `api.slack.com` REST\ncalls, as well as the Real-Time Messaging protocol over websocket, in\na fully managed way.\n\n## Project Status\nThere is currently no major version released.\nTherefore, minor version releases may include backward incompatible changes.\n\nSee [Releases](https://github.com/slack-go/slack/releases) for more information about the changes.\n\n## Installing\n\n### *go get*\n\n    $ go get -u github.com/slack-go/slack\n\n## Example\n\n### Getting all groups\n\n```golang\nimport (\n\t\"fmt\"\n\n\t\"github.com/slack-go/slack\"\n)\n\nfunc main() {\n\tapi := slack.New(\"YOUR_TOKEN_HERE\")\n\t// If you set debugging, it will log all requests to the console\n\t// Useful when encountering issues\n\t// slack.New(\"YOUR_TOKEN_HERE\", slack.OptionDebug(true))\n\tgroups, err := api.GetUserGroups(slack.GetUserGroupsOptionIncludeUsers(false))\n\tif err != nil {\n\t\tfmt.Printf(\"%s\\n\", err)\n\t\treturn\n\t}\n\tfor _, group := range groups {\n\t\tfmt.Printf(\"ID: %s, Name: %s\\n\", group.ID, group.Name)\n\t}\n}\n```\n\n### Getting User Information\n\n```golang\nimport (\n    \"fmt\"\n\n    \"github.com/slack-go/slack\"\n)\n\nfunc main() {\n    api := slack.New(\"YOUR_TOKEN_HERE\")\n    user, err := api.GetUserInfo(\"U023BECGF\")\n    if err != nil {\n\t    fmt.Printf(\"%s\\n\", err)\n\t    return\n    }\n    fmt.Printf(\"ID: %s, Fullname: %s, Email: %s\\n\", user.ID, user.Profile.RealName, user.Profile.Email)\n}\n```\n\n## Minimal Socket Mode usage:\n\nSee https://github.com/slack-go/slack/blob/master/examples/socketmode/socketmode.go\n\n\n## Minimal RTM usage:\n\nAs mentioned in https://api.slack.com/rtm - for most applications, Socket Mode is a better way to communicate with Slack.\n\nSee https://github.com/slack-go/slack/blob/master/examples/websocket/websocket.go\n\n\n## Minimal EventsAPI usage:\n\nSee https://github.com/slack-go/slack/blob/master/examples/eventsapi/events.go\n\n## Socketmode Event Handler (Experimental)\n\nWhen using socket mode, dealing with an event can be pretty lengthy as it requires you to route the event to the right place.\n\nInstead, you can use `SocketmodeHandler` much like you use an HTTP handler to register which event you would like to listen to and what callback function will process that event when it occurs.\n\nSee [./examples/socketmode_handler/socketmode_handler.go](./examples/socketmode_handler/socketmode_handler.go)\n## Contributing\n\nYou are more than welcome to contribute to this project.  Fork and\nmake a Pull Request, or create an Issue if you see any problem.\n\nBefore making any Pull Request please run the following:\n\n```\nmake pr-prep\n```\n\nThis will check/update code formatting, linting and then run all tests\n\n## License\n\nBSD 2 Clause license\n"
        },
        {
          "name": "admin.go",
          "type": "blob",
          "size": 6.4814453125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc (api *Client) adminRequest(ctx context.Context, method string, teamName string, values url.Values) error {\n\tresp := &SlackResponse{}\n\terr := parseAdminResponse(ctx, api.httpclient, method, teamName, values, resp, api)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn resp.Err()\n}\n\n// DisableUser disabled a user account, given a user ID\nfunc (api *Client) DisableUser(teamName string, uid string) error {\n\treturn api.DisableUserContext(context.Background(), teamName, uid)\n}\n\n// DisableUserContext disabled a user account, given a user ID with a custom context\nfunc (api *Client) DisableUserContext(ctx context.Context, teamName string, uid string) error {\n\tvalues := url.Values{\n\t\t\"user\":       {uid},\n\t\t\"token\":      {api.token},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t}\n\n\tif err := api.adminRequest(ctx, \"setInactive\", teamName, values); err != nil {\n\t\treturn fmt.Errorf(\"failed to disable user with id '%s': %s\", uid, err)\n\t}\n\n\treturn nil\n}\n\n// InviteGuest invites a user to Slack as a single-channel guest\nfunc (api *Client) InviteGuest(teamName, channel, firstName, lastName, emailAddress string) error {\n\treturn api.InviteGuestContext(context.Background(), teamName, channel, firstName, lastName, emailAddress)\n}\n\n// InviteGuestContext invites a user to Slack as a single-channel guest with a custom context\nfunc (api *Client) InviteGuestContext(ctx context.Context, teamName, channel, firstName, lastName, emailAddress string) error {\n\tvalues := url.Values{\n\t\t\"email\":            {emailAddress},\n\t\t\"channels\":         {channel},\n\t\t\"first_name\":       {firstName},\n\t\t\"last_name\":        {lastName},\n\t\t\"ultra_restricted\": {\"1\"},\n\t\t\"token\":            {api.token},\n\t\t\"resend\":           {\"true\"},\n\t\t\"set_active\":       {\"true\"},\n\t\t\"_attempts\":        {\"1\"},\n\t}\n\n\terr := api.adminRequest(ctx, \"invite\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to invite single-channel guest: %s\", err)\n\t}\n\n\treturn nil\n}\n\n// InviteRestricted invites a user to Slack as a restricted account\nfunc (api *Client) InviteRestricted(teamName, channel, firstName, lastName, emailAddress string) error {\n\treturn api.InviteRestrictedContext(context.Background(), teamName, channel, firstName, lastName, emailAddress)\n}\n\n// InviteRestrictedContext invites a user to Slack as a restricted account with a custom context\nfunc (api *Client) InviteRestrictedContext(ctx context.Context, teamName, channel, firstName, lastName, emailAddress string) error {\n\tvalues := url.Values{\n\t\t\"email\":      {emailAddress},\n\t\t\"channels\":   {channel},\n\t\t\"first_name\": {firstName},\n\t\t\"last_name\":  {lastName},\n\t\t\"restricted\": {\"1\"},\n\t\t\"token\":      {api.token},\n\t\t\"resend\":     {\"true\"},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t}\n\n\terr := api.adminRequest(ctx, \"invite\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to restricted account: %s\", err)\n\t}\n\n\treturn nil\n}\n\n// InviteToTeam invites a user to a Slack team\nfunc (api *Client) InviteToTeam(teamName, firstName, lastName, emailAddress string) error {\n\treturn api.InviteToTeamContext(context.Background(), teamName, firstName, lastName, emailAddress)\n}\n\n// InviteToTeamContext invites a user to a Slack team with a custom context\nfunc (api *Client) InviteToTeamContext(ctx context.Context, teamName, firstName, lastName, emailAddress string) error {\n\tvalues := url.Values{\n\t\t\"email\":      {emailAddress},\n\t\t\"first_name\": {firstName},\n\t\t\"last_name\":  {lastName},\n\t\t\"token\":      {api.token},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t}\n\n\terr := api.adminRequest(ctx, \"invite\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to invite to team: %s\", err)\n\t}\n\n\treturn nil\n}\n\n// SetRegular enables the specified user\nfunc (api *Client) SetRegular(teamName, user string) error {\n\treturn api.SetRegularContext(context.Background(), teamName, user)\n}\n\n// SetRegularContext enables the specified user with a custom context\nfunc (api *Client) SetRegularContext(ctx context.Context, teamName, user string) error {\n\tvalues := url.Values{\n\t\t\"user\":       {user},\n\t\t\"token\":      {api.token},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t}\n\n\terr := api.adminRequest(ctx, \"setRegular\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to change the user (%s) to a regular user: %s\", user, err)\n\t}\n\n\treturn nil\n}\n\n// SendSSOBindingEmail sends an SSO binding email to the specified user\nfunc (api *Client) SendSSOBindingEmail(teamName, user string) error {\n\treturn api.SendSSOBindingEmailContext(context.Background(), teamName, user)\n}\n\n// SendSSOBindingEmailContext sends an SSO binding email to the specified user with a custom context\nfunc (api *Client) SendSSOBindingEmailContext(ctx context.Context, teamName, user string) error {\n\tvalues := url.Values{\n\t\t\"user\":       {user},\n\t\t\"token\":      {api.token},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t}\n\n\terr := api.adminRequest(ctx, \"sendSSOBind\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to send SSO binding email for user (%s): %s\", user, err)\n\t}\n\n\treturn nil\n}\n\n// SetUltraRestricted converts a user into a single-channel guest\nfunc (api *Client) SetUltraRestricted(teamName, uid, channel string) error {\n\treturn api.SetUltraRestrictedContext(context.Background(), teamName, uid, channel)\n}\n\n// SetUltraRestrictedContext converts a user into a single-channel guest with a custom context\nfunc (api *Client) SetUltraRestrictedContext(ctx context.Context, teamName, uid, channel string) error {\n\tvalues := url.Values{\n\t\t\"user\":       {uid},\n\t\t\"channel\":    {channel},\n\t\t\"token\":      {api.token},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t}\n\n\terr := api.adminRequest(ctx, \"setUltraRestricted\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to ultra-restrict account: %s\", err)\n\t}\n\n\treturn nil\n}\n\n// SetRestricted converts a user into a restricted account\nfunc (api *Client) SetRestricted(teamName, uid string, channelIds ...string) error {\n\treturn api.SetRestrictedContext(context.Background(), teamName, uid, channelIds...)\n}\n\n// SetRestrictedContext converts a user into a restricted account with a custom context\nfunc (api *Client) SetRestrictedContext(ctx context.Context, teamName, uid string, channelIds ...string) error {\n\tvalues := url.Values{\n\t\t\"user\":       {uid},\n\t\t\"token\":      {api.token},\n\t\t\"set_active\": {\"true\"},\n\t\t\"_attempts\":  {\"1\"},\n\t\t\"channels\":   {strings.Join(channelIds, \",\")},\n\t}\n\n\terr := api.adminRequest(ctx, \"setRestricted\", teamName, values)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to restrict account: %s\", err)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "apps.go",
          "type": "blob",
          "size": 2.291015625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\ntype listEventAuthorizationsResponse struct {\n\tSlackResponse\n\tAuthorizations []EventAuthorization `json:\"authorizations\"`\n}\n\ntype EventAuthorization struct {\n\tEnterpriseID        string `json:\"enterprise_id\"`\n\tTeamID              string `json:\"team_id\"`\n\tUserID              string `json:\"user_id\"`\n\tIsBot               bool   `json:\"is_bot\"`\n\tIsEnterpriseInstall bool   `json:\"is_enterprise_install\"`\n}\n\n// ListEventAuthorizations lists authed users and teams for the given event_context.\n// You must provide an app-level token to the client using OptionAppLevelToken.\n// For more details, see ListEventAuthorizationsContext documentation.\nfunc (api *Client) ListEventAuthorizations(eventContext string) ([]EventAuthorization, error) {\n\treturn api.ListEventAuthorizationsContext(context.Background(), eventContext)\n}\n\n// ListEventAuthorizationsContext lists authed users and teams for the given event_context with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.event.authorizations.list\nfunc (api *Client) ListEventAuthorizationsContext(ctx context.Context, eventContext string) ([]EventAuthorization, error) {\n\tresp := &listEventAuthorizationsResponse{}\n\n\trequest, _ := json.Marshal(map[string]string{\n\t\t\"event_context\": eventContext,\n\t})\n\n\terr := postJSON(ctx, api.httpclient, api.endpoint+\"apps.event.authorizations.list\", api.appLevelToken, request, &resp, api)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !resp.Ok {\n\t\treturn nil, resp.Err()\n\t}\n\n\treturn resp.Authorizations, nil\n}\n\n// UninstallApp uninstalls your app from a workspace.\n// For more details, see UninstallAppContext documentation.\nfunc (api *Client) UninstallApp(clientID, clientSecret string) error {\n\treturn api.UninstallAppContext(context.Background(), clientID, clientSecret)\n}\n\n// UninstallAppContext uninstalls your app from a workspace with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.uninstall\nfunc (api *Client) UninstallAppContext(ctx context.Context, clientID, clientSecret string) error {\n\tvalues := url.Values{\n\t\t\"client_id\":     {clientID},\n\t\t\"client_secret\": {clientSecret},\n\t}\n\n\tresponse := SlackResponse{}\n\n\terr := api.getMethod(ctx, \"apps.uninstall\", api.token, values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n"
        },
        {
          "name": "apps_test.go",
          "type": "blob",
          "size": 1.470703125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestListEventAuthorizations(t *testing.T) {\n\thttp.HandleFunc(\"/apps.event.authorizations.list\", testListEventAuthorizationsHandler)\n\tonce.Do(startServer)\n\n\tapi := New(\"\", OptionAppLevelToken(\"test-token\"), OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tauthorizations, err := api.ListEventAuthorizations(\"1-message-T012345678-DR12345678\")\n\n\tif err != nil {\n\t\tt.Errorf(\"Failed, but should have succeeded\")\n\t} else if len(authorizations) != 1 {\n\t\tt.Errorf(\"Didn't get 1 authorization\")\n\t} else if authorizations[0].UserID != \"U123456789\" {\n\t\tt.Errorf(\"User ID is wrong\")\n\t}\n}\n\nfunc testListEventAuthorizationsHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(listEventAuthorizationsResponse{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t\tAuthorizations: []EventAuthorization{\n\t\t\t{\n\t\t\t\tUserID: \"U123456789\",\n\t\t\t\tTeamID: \"T012345678\",\n\t\t\t},\n\t\t},\n\t})\n\tw.Write(response)\n}\n\nfunc TestUninstallApp(t *testing.T) {\n\thttp.HandleFunc(\"/apps.uninstall\", testUninstallAppHandler)\n\tonce.Do(startServer)\n\n\tapi := New(\"test-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\terr := api.UninstallApp(\"\", \"\")\n\n\tif err != nil {\n\t\tt.Errorf(\"Failed, but should have succeeded\")\n\t}\n}\n\nfunc testUninstallAppHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(SlackResponse{Ok: true})\n\tw.Write(response)\n}\n"
        },
        {
          "name": "assistant.go",
          "type": "blob",
          "size": 4.546875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\n// AssistantThreadSetStatusParameters are the parameters for AssistantThreadSetStatus\ntype AssistantThreadsSetStatusParameters struct {\n\tChannelID string `json:\"channel_id\"`\n\tStatus    string `json:\"status\"`\n\tThreadTS  string `json:\"thread_ts\"`\n}\n\n// AssistantThreadSetTitleParameters are the parameters for AssistantThreadSetTitle\ntype AssistantThreadsSetTitleParameters struct {\n\tChannelID string `json:\"channel_id\"`\n\tThreadTS  string `json:\"thread_ts\"`\n\tTitle     string `json:\"title\"`\n}\n\n// AssistantThreadSetSuggestedPromptsParameters are the parameters for AssistantThreadSetSuggestedPrompts\ntype AssistantThreadsSetSuggestedPromptsParameters struct {\n\tTitle     string                   `json:\"title\"`\n\tChannelID string                   `json:\"channel_id\"`\n\tThreadTS  string                   `json:\"thread_ts\"`\n\tPrompts   []AssistantThreadsPrompt `json:\"prompts\"`\n}\n\n// AssistantThreadPrompt is a suggested prompt for a thread\ntype AssistantThreadsPrompt struct {\n\tTitle   string `json:\"title\"`\n\tMessage string `json:\"message\"`\n}\n\n// AssistantThreadSetSuggestedPrompts sets the suggested prompts for a thread\nfunc (p *AssistantThreadsSetSuggestedPromptsParameters) AddPrompt(title, message string) {\n\tp.Prompts = append(p.Prompts, AssistantThreadsPrompt{\n\t\tTitle:   title,\n\t\tMessage: message,\n\t})\n}\n\n// SetAssistantThreadsSugesstedPrompts sets the suggested prompts for a thread\n// @see https://api.slack.com/methods/assistant.threads.setSuggestedPrompts\nfunc (api *Client) SetAssistantThreadsSuggestedPrompts(params AssistantThreadsSetSuggestedPromptsParameters) (err error) {\n\treturn api.SetAssistantThreadsSuggestedPromptsContext(context.Background(), params)\n}\n\n// SetAssistantThreadSuggestedPromptsContext sets the suggested prompts for a thread with a custom context\n// @see https://api.slack.com/methods/assistant.threads.setSuggestedPrompts\nfunc (api *Client) SetAssistantThreadsSuggestedPromptsContext(ctx context.Context, params AssistantThreadsSetSuggestedPromptsParameters) (err error) {\n\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tif params.ThreadTS != \"\" {\n\t\tvalues.Add(\"thread_ts\", params.ThreadTS)\n\t}\n\n\tvalues.Add(\"channel_id\", params.ChannelID)\n\n\t// Send Prompts as JSON\n\tprompts, err := json.Marshal(params.Prompts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalues.Add(\"prompts\", string(prompts))\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr = api.postMethod(ctx, \"assistant.threads.setSuggestedPrompts\", values, &response)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn response.Err()\n}\n\n// SetAssistantThreadStatus sets the status of a thread\n// @see https://api.slack.com/methods/assistant.threads.setStatus\nfunc (api *Client) SetAssistantThreadsStatus(params AssistantThreadsSetStatusParameters) (err error) {\n\treturn api.SetAssistantThreadsStatusContext(context.Background(), params)\n}\n\n// SetAssistantThreadStatusContext sets the status of a thread with a custom context\n// @see https://api.slack.com/methods/assistant.threads.setStatus\nfunc (api *Client) SetAssistantThreadsStatusContext(ctx context.Context, params AssistantThreadsSetStatusParameters) (err error) {\n\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tif params.ThreadTS != \"\" {\n\t\tvalues.Add(\"thread_ts\", params.ThreadTS)\n\t}\n\n\tvalues.Add(\"channel_id\", params.ChannelID)\n\n\t// Always send the status parameter, if empty, it will clear any existing status\n\tvalues.Add(\"status\", params.Status)\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr = api.postMethod(ctx, \"assistant.threads.setStatus\", values, &response)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn response.Err()\n}\n\n// SetAssistantThreadsTitle sets the title of a thread\n// @see https://api.slack.com/methods/assistant.threads.setTitle\nfunc (api *Client) SetAssistantThreadsTitle(params AssistantThreadsSetTitleParameters) (err error) {\n\treturn api.SetAssistantThreadsTitleContext(context.Background(), params)\n}\n\n// SetAssistantThreadsTitleContext sets the title of a thread with a custom context\n// @see https://api.slack.com/methods/assistant.threads.setTitle\nfunc (api *Client) SetAssistantThreadsTitleContext(ctx context.Context, params AssistantThreadsSetTitleParameters) (err error) {\n\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tif params.ChannelID != \"\" {\n\t\tvalues.Add(\"channel_id\", params.ChannelID)\n\t}\n\n\tif params.ThreadTS != \"\" {\n\t\tvalues.Add(\"thread_ts\", params.ThreadTS)\n\t}\n\n\tif params.Title != \"\" {\n\t\tvalues.Add(\"title\", params.Title)\n\t}\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr = api.postMethod(ctx, \"assistant.threads.setTitle\", values, &response)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn response.Err()\n\n}\n"
        },
        {
          "name": "assistant_test.go",
          "type": "blob",
          "size": 1.984375,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestAssistantThreadsSuggestedPrompts(t *testing.T) {\n\n\thttp.HandleFunc(\"/assistant.threads.setSuggestedPrompts\", okJSONHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := AssistantThreadsSetSuggestedPromptsParameters{\n\t\tChannelID: \"CXXXXXXXX\",\n\t\tThreadTS:  \"1234567890.123456\",\n\t}\n\n\tparams.AddPrompt(\"title1\", \"message1\")\n\tparams.AddPrompt(\"title2\", \"message2\")\n\n\terr := api.SetAssistantThreadsSuggestedPrompts(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n}\n\nfunc TestSetAssistantThreadsStatus(t *testing.T) {\n\n\thttp.HandleFunc(\"/assistant.threads.setStatus\", okJSONHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := AssistantThreadsSetStatusParameters{\n\t\tChannelID: \"CXXXXXXXX\",\n\t\tThreadTS:  \"1234567890.123456\",\n\t\tStatus:    \"updated status\",\n\t}\n\n\terr := api.SetAssistantThreadsStatus(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n}\n\nfunc assistantThreadsTitleHandler(rw http.ResponseWriter, r *http.Request) {\n\n\tchannelID := r.FormValue(\"channel_id\")\n\tthreadTS := r.FormValue(\"thread_ts\")\n\ttitle := r.FormValue(\"title\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif channelID != \"\" && threadTS != \"\" && title != \"\" {\n\n\t\tresp, _ := json.Marshal(&addBookmarkResponse{\n\t\t\tSlackResponse: SlackResponse{Ok: true},\n\t\t})\n\t\trw.Write(resp)\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n\n}\n\nfunc TestSetAssistantThreadsTitle(t *testing.T) {\n\n\thttp.HandleFunc(\"/assistant.threads.setTitle\", assistantThreadsTitleHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := AssistantThreadsSetTitleParameters{\n\t\tChannelID: \"CXXXXXXXX\",\n\t\tThreadTS:  \"1234567890.123456\",\n\t\tTitle:     \"updated title\",\n\t}\n\n\terr := api.SetAssistantThreadsTitle(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n}\n"
        },
        {
          "name": "attachments.go",
          "type": "blob",
          "size": 4.49609375,
          "content": "package slack\n\nimport \"encoding/json\"\n\n// AttachmentField contains information for an attachment field\n// An Attachment can contain multiple of these\ntype AttachmentField struct {\n\tTitle string `json:\"title\"`\n\tValue string `json:\"value\"`\n\tShort bool   `json:\"short\"`\n}\n\n// AttachmentAction is a button or menu to be included in the attachment. Required when\n// using message buttons or menus and otherwise not useful. A maximum of 5 actions may be\n// provided per attachment.\ntype AttachmentAction struct {\n\tName            string                        `json:\"name\"`                       // Required.\n\tText            string                        `json:\"text\"`                       // Required.\n\tStyle           string                        `json:\"style,omitempty\"`            // Optional. Allowed values: \"default\", \"primary\", \"danger\".\n\tType            ActionType                    `json:\"type\"`                       // Required. Must be set to \"button\" or \"select\".\n\tValue           string                        `json:\"value,omitempty\"`            // Optional.\n\tDataSource      string                        `json:\"data_source,omitempty\"`      // Optional.\n\tMinQueryLength  int                           `json:\"min_query_length,omitempty\"` // Optional. Default value is 1.\n\tOptions         []AttachmentActionOption      `json:\"options,omitempty\"`          // Optional. Maximum of 100 options can be provided in each menu.\n\tSelectedOptions []AttachmentActionOption      `json:\"selected_options,omitempty\"` // Optional. The first element of this array will be set as the pre-selected option for this menu.\n\tOptionGroups    []AttachmentActionOptionGroup `json:\"option_groups,omitempty\"`    // Optional.\n\tConfirm         *ConfirmationField            `json:\"confirm,omitempty\"`          // Optional.\n\tURL             string                        `json:\"url,omitempty\"`              // Optional.\n}\n\n// actionType returns the type of the action\nfunc (a AttachmentAction) actionType() ActionType {\n\treturn a.Type\n}\n\n// AttachmentActionOption the individual option to appear in action menu.\ntype AttachmentActionOption struct {\n\tText        string `json:\"text\"`                  // Required.\n\tValue       string `json:\"value\"`                 // Required.\n\tDescription string `json:\"description,omitempty\"` // Optional. Up to 30 characters.\n}\n\n// AttachmentActionOptionGroup is a semi-hierarchal way to list available options to appear in action menu.\ntype AttachmentActionOptionGroup struct {\n\tText    string                   `json:\"text\"`    // Required.\n\tOptions []AttachmentActionOption `json:\"options\"` // Required.\n}\n\n// AttachmentActionCallback is sent from Slack when a user clicks a button in an interactive message (aka AttachmentAction)\n// DEPRECATED: use InteractionCallback\ntype AttachmentActionCallback InteractionCallback\n\n// ConfirmationField are used to ask users to confirm actions\ntype ConfirmationField struct {\n\tTitle       string `json:\"title,omitempty\"`        // Optional.\n\tText        string `json:\"text\"`                   // Required.\n\tOkText      string `json:\"ok_text,omitempty\"`      // Optional. Defaults to \"Okay\"\n\tDismissText string `json:\"dismiss_text,omitempty\"` // Optional. Defaults to \"Cancel\"\n}\n\n// Attachment contains all the information for an attachment\ntype Attachment struct {\n\tColor    string `json:\"color,omitempty\"`\n\tFallback string `json:\"fallback,omitempty\"`\n\n\tCallbackID string `json:\"callback_id,omitempty\"`\n\tID         int    `json:\"id,omitempty\"`\n\n\tAuthorID      string `json:\"author_id,omitempty\"`\n\tAuthorName    string `json:\"author_name,omitempty\"`\n\tAuthorSubname string `json:\"author_subname,omitempty\"`\n\tAuthorLink    string `json:\"author_link,omitempty\"`\n\tAuthorIcon    string `json:\"author_icon,omitempty\"`\n\n\tTitle     string `json:\"title,omitempty\"`\n\tTitleLink string `json:\"title_link,omitempty\"`\n\tPretext   string `json:\"pretext,omitempty\"`\n\tText      string `json:\"text,omitempty\"`\n\n\tImageURL string `json:\"image_url,omitempty\"`\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\n\tServiceName string `json:\"service_name,omitempty\"`\n\tServiceIcon string `json:\"service_icon,omitempty\"`\n\tFromURL     string `json:\"from_url,omitempty\"`\n\tOriginalURL string `json:\"original_url,omitempty\"`\n\n\tFields     []AttachmentField  `json:\"fields,omitempty\"`\n\tActions    []AttachmentAction `json:\"actions,omitempty\"`\n\tMarkdownIn []string           `json:\"mrkdwn_in,omitempty\"`\n\n\tBlocks Blocks `json:\"blocks,omitempty\"`\n\n\tFooter     string `json:\"footer,omitempty\"`\n\tFooterIcon string `json:\"footer_icon,omitempty\"`\n\n\tTs json.Number `json:\"ts,omitempty\"`\n}\n"
        },
        {
          "name": "attachments_test.go",
          "type": "blob",
          "size": 1.6240234375,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/go-test/deep\"\n)\n\nfunc TestAttachment_UnmarshalMarshalJSON_WithBlocks(t *testing.T) {\n\n\toriginalAttachmentJson := `{\n    \"id\": 1,\n    \"blocks\": [\n      {\n        \"type\": \"section\",\n        \"block_id\": \"xxxx\",\n        \"text\": {\n          \"type\": \"mrkdwn\",\n          \"text\": \"Pick something:\",\n          \"verbatim\": true\n        },\n        \"accessory\": {\n          \"type\": \"static_select\",\n          \"action_id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n          \"placeholder\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Select one item\",\n            \"emoji\": true\n          },\n          \"options\": [\n            {\n              \"text\": {\n                \"type\": \"plain_text\",\n                \"text\": \"ghi\",\n                \"emoji\": true\n              },\n              \"value\": \"ghi\"\n            }\n          ]\n        }\n      }\n    ],\n    \"color\": \"#13A554\",\n    \"fallback\": \"[no preview available]\"\n  }`\n\n\tattachment := new(Attachment)\n\terr := json.Unmarshal([]byte(originalAttachmentJson), attachment)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error unmarshaling attachment with blocks, got: %v\", err)\n\t}\n\n\tactualAttachmentJson, err := json.Marshal(attachment)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar (\n\t\tactual   interface{}\n\t\texpected interface{}\n\t)\n\tif err = json.Unmarshal([]byte(originalAttachmentJson), &expected); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = json.Unmarshal(actualAttachmentJson, &actual); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := deep.Equal(actual, expected); diff != nil {\n\t\tt.Fatal(\"actual does not match expected\\n\", strings.Join(diff, \"\\n\"))\n\t}\n}\n"
        },
        {
          "name": "audit.go",
          "type": "blob",
          "size": 4.306640625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\ntype AuditLogResponse struct {\n\tEntries []AuditEntry `json:\"entries\"`\n\tSlackResponse\n}\n\ntype AuditEntry struct {\n\tID         string `json:\"id\"`\n\tDateCreate int    `json:\"date_create\"`\n\tAction     string `json:\"action\"`\n\tActor      struct {\n\t\tType string    `json:\"type\"`\n\t\tUser AuditUser `json:\"user\"`\n\t} `json:\"actor\"`\n\tEntity struct {\n\t\tType string `json:\"type\"`\n\t\t// Only one of the below will be completed, based on the value of Type a user, a channel, a file, an app, a workspace, or an enterprise\n\t\tUser       AuditUser       `json:\"user\"`\n\t\tChannel    AuditChannel    `json:\"channel\"`\n\t\tFile       AuditFile       `json:\"file\"`\n\t\tApp        AuditApp        `json:\"app\"`\n\t\tWorkspace  AuditWorkspace  `json:\"workspace\"`\n\t\tEnterprise AuditEnterprise `json:\"enterprise\"`\n\t} `json:\"entity\"`\n\tContext struct {\n\t\tLocation struct {\n\t\t\tType   string `json:\"type\"`\n\t\t\tID     string `json:\"id\"`\n\t\t\tName   string `json:\"name\"`\n\t\t\tDomain string `json:\"domain\"`\n\t\t} `json:\"location\"`\n\t\tUA        string `json:\"ua\"`\n\t\tIPAddress string `json:\"ip_address\"`\n\t} `json:\"context\"`\n\tDetails struct {\n\t\tNewValue      interface{} `json:\"new_value\"`\n\t\tPreviousValue interface{} `json:\"previous_value\"`\n\t\tMobileOnly    bool        `json:\"mobile_only\"`\n\t\tWebOnly       bool        `json:\"web_only\"`\n\t\tNonSSOOnly    bool        `json:\"non_sso_only\"`\n\t\tExportType    string      `json:\"export_type\"`\n\t\tExportStart   string      `json:\"export_start_ts\"`\n\t\tExportEnd     string      `json:\"export_end_ts\"`\n\t} `json:\"details\"`\n}\n\ntype AuditUser struct {\n\tID    string `json:\"id\"`\n\tName  string `json:\"name\"`\n\tEmail string `json:\"email\"`\n\tTeam  string `json:\"team\"`\n}\n\ntype AuditChannel struct {\n\tID          string `json:\"id\"`\n\tName        string `json:\"name\"`\n\tPrivacy     string `json:\"privacy\"`\n\tIsShared    bool   `json:\"is_shared\"`\n\tIsOrgShared bool   `json:\"is_org_shared\"`\n}\n\ntype AuditFile struct {\n\tID       string `json:\"id\"`\n\tName     string `json:\"name\"`\n\tFiletype string `json:\"filetype\"`\n\tTitle    string `json:\"title\"`\n}\n\ntype AuditApp struct {\n\tID                  string   `json:\"id\"`\n\tName                string   `json:\"name\"`\n\tIsDistributed       bool     `json:\"is_distributed\"`\n\tIsDirectoryApproved bool     `json:\"is_directory_approved\"`\n\tIsWorkflowApp       bool     `json:\"is_workflow_app\"`\n\tScopes              []string `json:\"scopes\"`\n}\n\ntype AuditWorkspace struct {\n\tID     string `json:\"id\"`\n\tName   string `json:\"name\"`\n\tDomain string `json:\"domain\"`\n}\n\ntype AuditEnterprise struct {\n\tID     string `json:\"id\"`\n\tName   string `json:\"name\"`\n\tDomain string `json:\"domain\"`\n}\n\n// AuditLogParameters contains all the parameters necessary (including the optional ones) for a GetAuditLogs() request\ntype AuditLogParameters struct {\n\tLimit  int\n\tCursor string\n\tLatest int\n\tOldest int\n\tAction string\n\tActor  string\n\tEntity string\n}\n\nfunc (api *Client) auditLogsRequest(ctx context.Context, path string, values url.Values) (*AuditLogResponse, error) {\n\tresponse := &AuditLogResponse{}\n\terr := api.getMethod(ctx, path, api.token, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n\n// GetAuditLogs retrieves a page of audit entires according to the parameters given\nfunc (api *Client) GetAuditLogs(params AuditLogParameters) (entries []AuditEntry, nextCursor string, err error) {\n\treturn api.GetAuditLogsContext(context.Background(), params)\n}\n\n// GetAuditLogsContext retrieves a page of audit entries according to the parameters given with a custom context\nfunc (api *Client) GetAuditLogsContext(ctx context.Context, params AuditLogParameters) (entries []AuditEntry, nextCursor string, err error) {\n\tvalues := url.Values{}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Oldest != 0 {\n\t\tvalues.Add(\"oldest\", strconv.Itoa(params.Oldest))\n\t}\n\tif params.Latest != 0 {\n\t\tvalues.Add(\"latest\", strconv.Itoa(params.Latest))\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Action != \"\" {\n\t\tvalues.Add(\"action\", params.Action)\n\t}\n\tif params.Actor != \"\" {\n\t\tvalues.Add(\"actor\", params.Actor)\n\t}\n\tif params.Entity != \"\" {\n\t\tvalues.Add(\"entity\", params.Entity)\n\t}\n\n\tresponse, err := api.auditLogsRequest(ctx, \"audit/v1/logs\", values)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\treturn response.Entries, response.ResponseMetadata.Cursor, response.Err()\n}\n"
        },
        {
          "name": "audit_test.go",
          "type": "blob",
          "size": 2.01171875,
          "content": "package slack\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc getAuditLogs(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\"entries\": [\n\t\t\t    {\n\t\t\t      \"id\": \"0123a45b-6c7d-8900-e12f-3456789gh0i1\",\n\t\t\t      \"date_create\": 1521214343,\n\t\t\t      \"action\": \"user_login\",\n\t\t\t      \"actor\": {\n\t\t\t        \"type\": \"user\",\n\t\t\t        \"user\": {\n\t\t\t          \"id\": \"W123AB456\",\n\t\t\t          \"name\": \"Charlie Parker\",\n\t\t\t          \"email\": \"bird@slack.com\"\n\t\t\t        }\n\t\t\t      },\n\t\t\t      \"entity\": {\n\t\t\t        \"type\": \"user\",\n\t\t\t        \"user\": {\n\t\t\t          \"id\": \"W123AB456\",\n\t\t\t          \"name\": \"Charlie Parker\",\n\t\t\t          \"email\": \"bird@slack.com\"\n\t\t\t        }\n\t\t\t      },\n\t\t\t      \"context\": {\n\t\t\t        \"location\": {\n\t\t\t          \"type\": \"enterprise\",\n\t\t\t          \"id\": \"E1701NCCA\",\n\t\t\t          \"name\": \"Birdland\",\n\t\t\t          \"domain\": \"birdland\"\n\t\t\t        },\n\t\t\t        \"ua\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\",\n\t\t\t        \"ip_address\": \"1.23.45.678\"\n\t\t\t      }\n\t\t\t    }\n\t\t\t  ]\n  }`)\n\trw.Write(response)\n}\n\nfunc TestGetAuditLogs(t *testing.T) {\n\thttp.HandleFunc(\"/audit/v1/logs\", getAuditLogs)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tevents, nextCursor, err := api.GetAuditLogs(AuditLogParameters{})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\tif len(events) != 1 {\n\t\tt.Fatal(\"Should have been 1 event\")\n\t}\n\n\t// test the first login\n\tevent1 := events[0]\n\n\tif event1.Action != \"user_login\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif event1.Entity.User.Email != \"bird@slack.com\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif event1.Context.Location.Domain != \"birdland\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif event1.DateCreate != 1521214343 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif event1.Context.IPAddress != \"1.23.45.678\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\n\tif nextCursor != \"\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 2.2431640625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\n// AuthRevokeResponse contains our Auth response from the auth.revoke endpoint\ntype AuthRevokeResponse struct {\n\tSlackResponse      // Contains the \"ok\", and \"Error\", if any\n\tRevoked       bool `json:\"revoked,omitempty\"`\n}\n\n// authRequest sends the actual request, and unmarshals the response\nfunc (api *Client) authRequest(ctx context.Context, path string, values url.Values) (*AuthRevokeResponse, error) {\n\tresponse := &AuthRevokeResponse{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// SendAuthRevoke will send a revocation for our token.\n// For more details, see SendAuthRevokeContext documentation.\nfunc (api *Client) SendAuthRevoke(token string) (*AuthRevokeResponse, error) {\n\treturn api.SendAuthRevokeContext(context.Background(), token)\n}\n\n// SendAuthRevokeContext will send a revocation request for our token to api.revoke with a custom context.\n// Slack API docs: https://api.slack.com/methods/auth.revoke\nfunc (api *Client) SendAuthRevokeContext(ctx context.Context, token string) (*AuthRevokeResponse, error) {\n\tif token == \"\" {\n\t\ttoken = api.token\n\t}\n\tvalues := url.Values{\n\t\t\"token\": {token},\n\t}\n\n\treturn api.authRequest(ctx, \"auth.revoke\", values)\n}\n\ntype listTeamsResponse struct {\n\tTeams []Team `json:\"teams\"`\n\tSlackResponse\n}\n\ntype ListTeamsParameters struct {\n\tLimit  int\n\tCursor string\n}\n\n// ListTeams returns all workspaces a token can access.\n// For more details, see ListTeamsContext documentation.\nfunc (api *Client) ListTeams(params ListTeamsParameters) ([]Team, string, error) {\n\treturn api.ListTeamsContext(context.Background(), params)\n}\n\n// ListTeamsContext returns all workspaces a token can access with a custom context.\n// Slack API docs: https://api.slack.com/methods/auth.teams.list\nfunc (api *Client) ListTeamsContext(ctx context.Context, params ListTeamsParameters) ([]Team, string, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\n\tresponse := &listTeamsResponse{}\n\terr := api.postMethod(ctx, \"auth.teams.list\", values, response)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn response.Teams, response.ResponseMetadata.Cursor, response.Err()\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 1.115234375,
          "content": "package slack\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc getTeamList(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\n    \"ok\": true,\n    \"teams\": [\n        {\n            \"name\": \"Shinichi's workspace\",\n            \"id\": \"T12345678\"\n        },\n        {\n            \"name\": \"Migi's workspace\",\n            \"id\": \"T12345679\"\n        }\n    ],\n    \"response_metadata\": {\n        \"next_cursor\": \"dXNlcl9pZDo5MTQyOTI5Mzkz\"\n    }\n}`)\n\trw.Write(response)\n}\n\nfunc TestListTeams(t *testing.T) {\n\thttp.HandleFunc(\"/auth.teams.list\", getTeamList)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tteams, cursor, err := api.ListTeams(ListTeamsParameters{})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\tassert.Len(t, teams, 2)\n\tassert.Equal(t, \"T12345678\", teams[0].ID)\n\tassert.Equal(t, \"Shinichi's workspace\", teams[0].Name)\n\n\tassert.Equal(t, \"T12345679\", teams[1].ID)\n\tassert.Equal(t, \"Migi's workspace\", teams[1].Name)\n\n\tassert.Equal(t, \"dXNlcl9pZDo5MTQyOTI5Mzkz\", cursor)\n}\n"
        },
        {
          "name": "block.go",
          "type": "blob",
          "size": 3.29296875,
          "content": "package slack\n\n// @NOTE: Blocks are in beta and subject to change.\n\n// More Information: https://api.slack.com/block-kit\n\n// MessageBlockType defines a named string type to define each block type\n// as a constant for use within the package.\ntype MessageBlockType string\n\nconst (\n\tMBTSection  MessageBlockType = \"section\"\n\tMBTDivider  MessageBlockType = \"divider\"\n\tMBTImage    MessageBlockType = \"image\"\n\tMBTAction   MessageBlockType = \"actions\"\n\tMBTContext  MessageBlockType = \"context\"\n\tMBTFile     MessageBlockType = \"file\"\n\tMBTInput    MessageBlockType = \"input\"\n\tMBTHeader   MessageBlockType = \"header\"\n\tMBTRichText MessageBlockType = \"rich_text\"\n\tMBTCall     MessageBlockType = \"call\"\n\tMBTVideo    MessageBlockType = \"video\"\n)\n\n// Block defines an interface all block types should implement\n// to ensure consistency between blocks.\ntype Block interface {\n\tBlockType() MessageBlockType\n}\n\n// Blocks is a convenience struct defined to allow dynamic unmarshalling of\n// the \"blocks\" value in Slack's JSON response, which varies depending on block type\ntype Blocks struct {\n\tBlockSet []Block `json:\"blocks,omitempty\"`\n}\n\n// BlockAction is the action callback sent when a block is interacted with\ntype BlockAction struct {\n\tActionID              string              `json:\"action_id\"`\n\tBlockID               string              `json:\"block_id\"`\n\tType                  ActionType          `json:\"type\"`\n\tText                  TextBlockObject     `json:\"text\"`\n\tValue                 string              `json:\"value\"`\n\tFiles                 []File              `json:\"files\"`\n\tActionTs              string              `json:\"action_ts\"`\n\tSelectedOption        OptionBlockObject   `json:\"selected_option\"`\n\tSelectedOptions       []OptionBlockObject `json:\"selected_options\"`\n\tSelectedUser          string              `json:\"selected_user\"`\n\tSelectedUsers         []string            `json:\"selected_users\"`\n\tSelectedChannel       string              `json:\"selected_channel\"`\n\tSelectedChannels      []string            `json:\"selected_channels\"`\n\tSelectedConversation  string              `json:\"selected_conversation\"`\n\tSelectedConversations []string            `json:\"selected_conversations\"`\n\tSelectedDate          string              `json:\"selected_date\"`\n\tSelectedTime          string              `json:\"selected_time\"`\n\tSelectedDateTime      int64               `json:\"selected_date_time\"`\n\tInitialOption         OptionBlockObject   `json:\"initial_option\"`\n\tInitialUser           string              `json:\"initial_user\"`\n\tInitialChannel        string              `json:\"initial_channel\"`\n\tInitialConversation   string              `json:\"initial_conversation\"`\n\tInitialDate           string              `json:\"initial_date\"`\n\tInitialTime           string              `json:\"initial_time\"`\n}\n\n// actionType returns the type of the action\nfunc (b BlockAction) actionType() ActionType {\n\treturn b.Type\n}\n\n// NewBlockMessage creates a new Message that contains one or more blocks to be displayed\nfunc NewBlockMessage(blocks ...Block) Message {\n\treturn Message{\n\t\tMsg: Msg{\n\t\t\tBlocks: Blocks{\n\t\t\t\tBlockSet: blocks,\n\t\t\t},\n\t\t},\n\t}\n}\n\n// AddBlockMessage appends a block to the end of the existing list of blocks\nfunc AddBlockMessage(message Message, newBlk Block) Message {\n\tmessage.Msg.Blocks.BlockSet = append(message.Msg.Blocks.BlockSet, newBlk)\n\treturn message\n}\n"
        },
        {
          "name": "block_action.go",
          "type": "blob",
          "size": 0.697265625,
          "content": "package slack\n\n// ActionBlock defines data that is used to hold interactive elements.\n//\n// More Information: https://api.slack.com/reference/messaging/blocks#actions\ntype ActionBlock struct {\n\tType     MessageBlockType `json:\"type\"`\n\tBlockID  string           `json:\"block_id,omitempty\"`\n\tElements *BlockElements   `json:\"elements\"`\n}\n\n// BlockType returns the type of the block\nfunc (s ActionBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewActionBlock returns a new instance of an Action Block\nfunc NewActionBlock(blockID string, elements ...BlockElement) *ActionBlock {\n\treturn &ActionBlock{\n\t\tType:    MBTAction,\n\t\tBlockID: blockID,\n\t\tElements: &BlockElements{\n\t\t\tElementSet: elements,\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "block_action_test.go",
          "type": "blob",
          "size": 0.4677734375,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewActionBlock(t *testing.T) {\n\n\tapproveBtnTxt := NewTextBlockObject(\"plain_text\", \"Approve\", false, false)\n\tapproveBtn := NewButtonBlockElement(\"\", \"click_me_123\", approveBtnTxt)\n\n\tactionBlock := NewActionBlock(\"test\", approveBtn)\n\tassert.Equal(t, string(actionBlock.Type), \"actions\")\n\tassert.Equal(t, actionBlock.BlockID, \"test\")\n\tassert.Equal(t, len(actionBlock.Elements.ElementSet), 1)\n\n}\n"
        },
        {
          "name": "block_call.go",
          "type": "blob",
          "size": 0.5791015625,
          "content": "package slack\n\n// CallBlock defines data that is used to display a call in slack.\n//\n// More Information: https://api.slack.com/apis/calls#post_to_channel\ntype CallBlock struct {\n\tType    MessageBlockType `json:\"type\"`\n\tBlockID string           `json:\"block_id,omitempty\"`\n\tCallID  string           `json:\"call_id\"`\n}\n\n// BlockType returns the type of the block\nfunc (s CallBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewFileBlock returns a new instance of a file block\nfunc NewCallBlock(callID string) *CallBlock {\n\treturn &CallBlock{\n\t\tType:   MBTCall,\n\t\tCallID: callID,\n\t}\n}\n"
        },
        {
          "name": "block_call_test.go",
          "type": "blob",
          "size": 0.244140625,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewCallBlock(t *testing.T) {\n\tcallBlock := NewCallBlock(\"ACallID\")\n\tassert.Equal(t, string(callBlock.Type), \"call\")\n\tassert.Equal(t, callBlock.CallID, \"ACallID\")\n}\n"
        },
        {
          "name": "block_context.go",
          "type": "blob",
          "size": 0.873046875,
          "content": "package slack\n\n// ContextBlock defines data that is used to display message context, which can\n// include both images and text.\n//\n// More Information: https://api.slack.com/reference/messaging/blocks#context\ntype ContextBlock struct {\n\tType            MessageBlockType `json:\"type\"`\n\tBlockID         string           `json:\"block_id,omitempty\"`\n\tContextElements ContextElements  `json:\"elements\"`\n}\n\n// BlockType returns the type of the block\nfunc (s ContextBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\ntype ContextElements struct {\n\tElements []MixedElement\n}\n\n// NewContextBlock returns a new instance of a context block\nfunc NewContextBlock(blockID string, mixedElements ...MixedElement) *ContextBlock {\n\telements := ContextElements{\n\t\tElements: mixedElements,\n\t}\n\treturn &ContextBlock{\n\t\tType:            MBTContext,\n\t\tBlockID:         blockID,\n\t\tContextElements: elements,\n\t}\n}\n"
        },
        {
          "name": "block_context_test.go",
          "type": "blob",
          "size": 0.6357421875,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewContextBlock(t *testing.T) {\n\n\tlocationPinImage := NewImageBlockElement(\"https://api.slack.com/img/blocks/bkb_template_images/tripAgentLocationMarker.png\", \"Location Pin Icon\")\n\ttextExample := NewTextBlockObject(\"plain_text\", \"Location: Central Business District\", true, false)\n\n\telements := []MixedElement{locationPinImage, textExample}\n\n\tcontextBlock := NewContextBlock(\"test\", elements...)\n\tassert.Equal(t, string(contextBlock.Type), \"context\")\n\tassert.Equal(t, contextBlock.BlockID, \"test\")\n\tassert.Equal(t, len(contextBlock.ContextElements.Elements), 2)\n\n}\n"
        },
        {
          "name": "block_conv.go",
          "type": "blob",
          "size": 11.33203125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype sumtype struct {\n\tTypeVal string `json:\"type\"`\n}\n\n// MarshalJSON implements the Marshaller interface for Blocks so that any JSON\n// marshalling is delegated and proper type determination can be made before marshal\nfunc (b Blocks) MarshalJSON() ([]byte, error) {\n\tbytes, err := json.Marshal(b.BlockSet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bytes, nil\n}\n\n// UnmarshalJSON implements the Unmarshaller interface for Blocks, so that any JSON\n// unmarshalling is delegated and proper type determination can be made before unmarshal\nfunc (b *Blocks) UnmarshalJSON(data []byte) error {\n\tvar raw []json.RawMessage\n\n\tif string(data) == \"{}\" {\n\t\treturn nil\n\t}\n\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar blocks Blocks\n\tfor _, r := range raw {\n\t\ts := sumtype{}\n\t\terr := json.Unmarshal(r, &s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar blockType string\n\t\tif s.TypeVal != \"\" {\n\t\t\tblockType = s.TypeVal\n\t\t}\n\n\t\tvar block Block\n\t\tswitch blockType {\n\t\tcase \"actions\":\n\t\t\tblock = &ActionBlock{}\n\t\tcase \"context\":\n\t\t\tblock = &ContextBlock{}\n\t\tcase \"divider\":\n\t\t\tblock = &DividerBlock{}\n\t\tcase \"file\":\n\t\t\tblock = &FileBlock{}\n\t\tcase \"header\":\n\t\t\tblock = &HeaderBlock{}\n\t\tcase \"image\":\n\t\t\tblock = &ImageBlock{}\n\t\tcase \"input\":\n\t\t\tblock = &InputBlock{}\n\t\tcase \"rich_text\":\n\t\t\tblock = &RichTextBlock{}\n\t\tcase \"rich_text_input\":\n\t\t\tblock = &RichTextBlock{}\n\t\tcase \"section\":\n\t\t\tblock = &SectionBlock{}\n\t\tcase \"call\":\n\t\t\tblock = &CallBlock{}\n\t\tcase \"video\":\n\t\t\tblock = &VideoBlock{}\n\t\tdefault:\n\t\t\tblock = &UnknownBlock{}\n\t\t}\n\n\t\terr = json.Unmarshal(r, block)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tblocks.BlockSet = append(blocks.BlockSet, block)\n\t}\n\n\t*b = blocks\n\treturn nil\n}\n\n// UnmarshalJSON implements the Unmarshaller interface for InputBlock, so that any JSON\n// unmarshalling is delegated and proper type determination can be made before unmarshal\nfunc (b *InputBlock) UnmarshalJSON(data []byte) error {\n\ttype alias InputBlock\n\ta := struct {\n\t\tElement json.RawMessage `json:\"element\"`\n\t\t*alias\n\t}{\n\t\talias: (*alias)(b),\n\t}\n\n\tif err := json.Unmarshal(data, &a); err != nil {\n\t\treturn err\n\t}\n\n\ts := sumtype{}\n\tif err := json.Unmarshal(a.Element, &s); err != nil {\n\t\treturn nil\n\t}\n\n\tvar e BlockElement\n\tswitch s.TypeVal {\n\tcase \"datepicker\":\n\t\te = &DatePickerBlockElement{}\n\tcase \"timepicker\":\n\t\te = &TimePickerBlockElement{}\n\tcase \"datetimepicker\":\n\t\te = &DateTimePickerBlockElement{}\n\tcase \"plain_text_input\":\n\t\te = &PlainTextInputBlockElement{}\n\tcase \"rich_text_input\":\n\t\te = &RichTextInputBlockElement{}\n\tcase \"email_text_input\":\n\t\te = &EmailTextInputBlockElement{}\n\tcase \"url_text_input\":\n\t\te = &URLTextInputBlockElement{}\n\tcase \"static_select\", \"external_select\", \"users_select\", \"conversations_select\", \"channels_select\":\n\t\te = &SelectBlockElement{}\n\tcase \"multi_static_select\", \"multi_external_select\", \"multi_users_select\", \"multi_conversations_select\", \"multi_channels_select\":\n\t\te = &MultiSelectBlockElement{}\n\tcase \"checkboxes\":\n\t\te = &CheckboxGroupsBlockElement{}\n\tcase \"overflow\":\n\t\te = &OverflowBlockElement{}\n\tcase \"radio_buttons\":\n\t\te = &RadioButtonsBlockElement{}\n\tcase \"number_input\":\n\t\te = &NumberInputBlockElement{}\n\tcase \"file_input\":\n\t\te = &FileInputBlockElement{}\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported block element type %v\", s.TypeVal)\n\t}\n\n\tif err := json.Unmarshal(a.Element, e); err != nil {\n\t\treturn err\n\t}\n\tb.Element = e\n\n\treturn nil\n}\n\n// MarshalJSON implements the Marshaller interface for BlockElements so that any JSON\n// marshalling is delegated and proper type determination can be made before marshal\nfunc (b *BlockElements) MarshalJSON() ([]byte, error) {\n\tbytes, err := json.Marshal(b.ElementSet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bytes, nil\n}\n\n// UnmarshalJSON implements the Unmarshaller interface for BlockElements, so that any JSON\n// unmarshalling is delegated and proper type determination can be made before unmarshal\nfunc (b *BlockElements) UnmarshalJSON(data []byte) error {\n\tvar raw []json.RawMessage\n\n\tif string(data) == \"{}\" {\n\t\treturn nil\n\t}\n\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar blockElements BlockElements\n\tfor _, r := range raw {\n\t\ts := sumtype{}\n\t\terr := json.Unmarshal(r, &s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar blockElementType string\n\t\tif s.TypeVal != \"\" {\n\t\t\tblockElementType = s.TypeVal\n\t\t}\n\n\t\tvar blockElement BlockElement\n\t\tswitch blockElementType {\n\t\tcase \"image\":\n\t\t\tblockElement = &ImageBlockElement{}\n\t\tcase \"button\":\n\t\t\tblockElement = &ButtonBlockElement{}\n\t\tcase \"overflow\":\n\t\t\tblockElement = &OverflowBlockElement{}\n\t\tcase \"datepicker\":\n\t\t\tblockElement = &DatePickerBlockElement{}\n\t\tcase \"timepicker\":\n\t\t\tblockElement = &TimePickerBlockElement{}\n\t\tcase \"datetimepicker\":\n\t\t\tblockElement = &DateTimePickerBlockElement{}\n\t\tcase \"plain_text_input\":\n\t\t\tblockElement = &PlainTextInputBlockElement{}\n\t\tcase \"rich_text_input\":\n\t\t\tblockElement = &RichTextInputBlockElement{}\n\t\tcase \"email_text_input\":\n\t\t\tblockElement = &EmailTextInputBlockElement{}\n\t\tcase \"url_text_input\":\n\t\t\tblockElement = &URLTextInputBlockElement{}\n\t\tcase \"checkboxes\":\n\t\t\tblockElement = &CheckboxGroupsBlockElement{}\n\t\tcase \"radio_buttons\":\n\t\t\tblockElement = &RadioButtonsBlockElement{}\n\t\tcase \"static_select\", \"external_select\", \"users_select\", \"conversations_select\", \"channels_select\":\n\t\t\tblockElement = &SelectBlockElement{}\n\t\tcase \"number_input\":\n\t\t\tblockElement = &NumberInputBlockElement{}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported block element type %v\", blockElementType)\n\t\t}\n\n\t\terr = json.Unmarshal(r, blockElement)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tblockElements.ElementSet = append(blockElements.ElementSet, blockElement)\n\t}\n\n\t*b = blockElements\n\treturn nil\n}\n\n// MarshalJSON implements the Marshaller interface for Accessory so that any JSON\n// marshalling is delegated and proper type determination can be made before marshal\nfunc (a *Accessory) MarshalJSON() ([]byte, error) {\n\tbytes, err := json.Marshal(toBlockElement(a))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bytes, nil\n}\n\n// UnmarshalJSON implements the Unmarshaller interface for Accessory, so that any JSON\n// unmarshalling is delegated and proper type determination can be made before unmarshal\n// Note: datetimepicker is not supported in Accessory\nfunc (a *Accessory) UnmarshalJSON(data []byte) error {\n\tvar r json.RawMessage\n\n\tif string(data) == \"{\\\"accessory\\\":null}\" {\n\t\treturn nil\n\t}\n\n\terr := json.Unmarshal(data, &r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts := sumtype{}\n\terr = json.Unmarshal(r, &s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar blockElementType string\n\tif s.TypeVal != \"\" {\n\t\tblockElementType = s.TypeVal\n\t}\n\n\tswitch blockElementType {\n\tcase \"image\":\n\t\telement, err := unmarshalBlockElement(r, &ImageBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.ImageElement = element.(*ImageBlockElement)\n\tcase \"button\":\n\t\telement, err := unmarshalBlockElement(r, &ButtonBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.ButtonElement = element.(*ButtonBlockElement)\n\tcase \"overflow\":\n\t\telement, err := unmarshalBlockElement(r, &OverflowBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.OverflowElement = element.(*OverflowBlockElement)\n\tcase \"datepicker\":\n\t\telement, err := unmarshalBlockElement(r, &DatePickerBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.DatePickerElement = element.(*DatePickerBlockElement)\n\tcase \"timepicker\":\n\t\telement, err := unmarshalBlockElement(r, &TimePickerBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.TimePickerElement = element.(*TimePickerBlockElement)\n\tcase \"plain_text_input\":\n\t\telement, err := unmarshalBlockElement(r, &PlainTextInputBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.PlainTextInputElement = element.(*PlainTextInputBlockElement)\n\tcase \"rich_text_input\":\n\t\telement, err := unmarshalBlockElement(r, &RichTextInputBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.RichTextInputElement = element.(*RichTextInputBlockElement)\n\tcase \"radio_buttons\":\n\t\telement, err := unmarshalBlockElement(r, &RadioButtonsBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.RadioButtonsElement = element.(*RadioButtonsBlockElement)\n\tcase \"static_select\", \"external_select\", \"users_select\", \"conversations_select\", \"channels_select\":\n\t\telement, err := unmarshalBlockElement(r, &SelectBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.SelectElement = element.(*SelectBlockElement)\n\tcase \"multi_static_select\", \"multi_external_select\", \"multi_users_select\", \"multi_conversations_select\", \"multi_channels_select\":\n\t\telement, err := unmarshalBlockElement(r, &MultiSelectBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.MultiSelectElement = element.(*MultiSelectBlockElement)\n\tcase \"checkboxes\":\n\t\telement, err := unmarshalBlockElement(r, &CheckboxGroupsBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.CheckboxGroupsBlockElement = element.(*CheckboxGroupsBlockElement)\n\tdefault:\n\t\telement, err := unmarshalBlockElement(r, &UnknownBlockElement{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.UnknownElement = element.(*UnknownBlockElement)\n\t}\n\n\treturn nil\n}\n\nfunc unmarshalBlockElement(r json.RawMessage, element BlockElement) (BlockElement, error) {\n\terr := json.Unmarshal(r, element)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn element, nil\n}\n\nfunc toBlockElement(element *Accessory) BlockElement {\n\tif element.ImageElement != nil {\n\t\treturn element.ImageElement\n\t}\n\tif element.ButtonElement != nil {\n\t\treturn element.ButtonElement\n\t}\n\tif element.OverflowElement != nil {\n\t\treturn element.OverflowElement\n\t}\n\tif element.DatePickerElement != nil {\n\t\treturn element.DatePickerElement\n\t}\n\tif element.TimePickerElement != nil {\n\t\treturn element.TimePickerElement\n\t}\n\tif element.PlainTextInputElement != nil {\n\t\treturn element.PlainTextInputElement\n\t}\n\tif element.RadioButtonsElement != nil {\n\t\treturn element.RadioButtonsElement\n\t}\n\tif element.CheckboxGroupsBlockElement != nil {\n\t\treturn element.CheckboxGroupsBlockElement\n\t}\n\tif element.SelectElement != nil {\n\t\treturn element.SelectElement\n\t}\n\tif element.MultiSelectElement != nil {\n\t\treturn element.MultiSelectElement\n\t}\n\n\treturn nil\n}\n\n// MarshalJSON implements the Marshaller interface for ContextElements so that any JSON\n// marshalling is delegated and proper type determination can be made before marshal\nfunc (e *ContextElements) MarshalJSON() ([]byte, error) {\n\tbytes, err := json.Marshal(e.Elements)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bytes, nil\n}\n\n// UnmarshalJSON implements the Unmarshaller interface for ContextElements, so that any JSON\n// unmarshalling is delegated and proper type determination can be made before unmarshal\nfunc (e *ContextElements) UnmarshalJSON(data []byte) error {\n\tvar raw []json.RawMessage\n\n\tif string(data) == \"{\\\"elements\\\":null}\" {\n\t\treturn nil\n\t}\n\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, r := range raw {\n\t\ts := sumtype{}\n\t\terr := json.Unmarshal(r, &s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar contextElementType string\n\t\tif s.TypeVal != \"\" {\n\t\t\tcontextElementType = s.TypeVal\n\t\t}\n\n\t\tswitch contextElementType {\n\t\tcase PlainTextType, MarkdownType:\n\t\t\telem, err := unmarshalBlockObject(r, &TextBlockObject{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\te.Elements = append(e.Elements, elem.(*TextBlockObject))\n\t\tcase \"image\":\n\t\t\telem, err := unmarshalBlockElement(r, &ImageBlockElement{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\te.Elements = append(e.Elements, elem.(*ImageBlockElement))\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported context element type %v\", contextElementType)\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "block_divider.go",
          "type": "blob",
          "size": 0.560546875,
          "content": "package slack\n\n// DividerBlock for displaying a divider line between blocks (similar to <hr> tag in html)\n//\n// More Information: https://api.slack.com/reference/messaging/blocks#divider\ntype DividerBlock struct {\n\tType    MessageBlockType `json:\"type\"`\n\tBlockID string           `json:\"block_id,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (s DividerBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewDividerBlock returns a new instance of a divider block\nfunc NewDividerBlock() *DividerBlock {\n\treturn &DividerBlock{\n\t\tType: MBTDivider,\n\t}\n\n}\n"
        },
        {
          "name": "block_divider_test.go",
          "type": "blob",
          "size": 0.20703125,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewDividerBlock(t *testing.T) {\n\n\tdividerBlock := NewDividerBlock()\n\tassert.Equal(t, string(dividerBlock.Type), \"divider\")\n\n}\n"
        },
        {
          "name": "block_element.go",
          "type": "blob",
          "size": 31.0576171875,
          "content": "package slack\n\n// https://api.slack.com/reference/messaging/block-elements\n\nconst (\n\tMETCheckboxGroups MessageElementType = \"checkboxes\"\n\tMETImage          MessageElementType = \"image\"\n\tMETButton         MessageElementType = \"button\"\n\tMETOverflow       MessageElementType = \"overflow\"\n\tMETDatepicker     MessageElementType = \"datepicker\"\n\tMETTimepicker     MessageElementType = \"timepicker\"\n\tMETDatetimepicker MessageElementType = \"datetimepicker\"\n\tMETPlainTextInput MessageElementType = \"plain_text_input\"\n\tMETRadioButtons   MessageElementType = \"radio_buttons\"\n\tMETRichTextInput  MessageElementType = \"rich_text_input\"\n\tMETEmailTextInput MessageElementType = \"email_text_input\"\n\tMETURLTextInput   MessageElementType = \"url_text_input\"\n\tMETNumber         MessageElementType = \"number_input\"\n\tMETFileInput      MessageElementType = \"file_input\"\n\n\tMixedElementImage MixedElementType = \"mixed_image\"\n\tMixedElementText  MixedElementType = \"mixed_text\"\n\n\tOptTypeStatic        string = \"static_select\"\n\tOptTypeExternal      string = \"external_select\"\n\tOptTypeUser          string = \"users_select\"\n\tOptTypeConversations string = \"conversations_select\"\n\tOptTypeChannels      string = \"channels_select\"\n\n\tMultiOptTypeStatic        string = \"multi_static_select\"\n\tMultiOptTypeExternal      string = \"multi_external_select\"\n\tMultiOptTypeUser          string = \"multi_users_select\"\n\tMultiOptTypeConversations string = \"multi_conversations_select\"\n\tMultiOptTypeChannels      string = \"multi_channels_select\"\n)\n\ntype MessageElementType string\ntype MixedElementType string\n\n// BlockElement defines an interface that all block element types should implement.\ntype BlockElement interface {\n\tElementType() MessageElementType\n}\n\ntype MixedElement interface {\n\tMixedElementType() MixedElementType\n}\n\ntype Accessory struct {\n\tImageElement               *ImageBlockElement\n\tButtonElement              *ButtonBlockElement\n\tOverflowElement            *OverflowBlockElement\n\tDatePickerElement          *DatePickerBlockElement\n\tTimePickerElement          *TimePickerBlockElement\n\tPlainTextInputElement      *PlainTextInputBlockElement\n\tRichTextInputElement       *RichTextInputBlockElement\n\tRadioButtonsElement        *RadioButtonsBlockElement\n\tSelectElement              *SelectBlockElement\n\tMultiSelectElement         *MultiSelectBlockElement\n\tCheckboxGroupsBlockElement *CheckboxGroupsBlockElement\n\tUnknownElement             *UnknownBlockElement\n}\n\n// NewAccessory returns a new Accessory for a given block element\nfunc NewAccessory(element BlockElement) *Accessory {\n\tswitch element.(type) {\n\tcase *ImageBlockElement:\n\t\treturn &Accessory{ImageElement: element.(*ImageBlockElement)}\n\tcase *ButtonBlockElement:\n\t\treturn &Accessory{ButtonElement: element.(*ButtonBlockElement)}\n\tcase *OverflowBlockElement:\n\t\treturn &Accessory{OverflowElement: element.(*OverflowBlockElement)}\n\tcase *DatePickerBlockElement:\n\t\treturn &Accessory{DatePickerElement: element.(*DatePickerBlockElement)}\n\tcase *TimePickerBlockElement:\n\t\treturn &Accessory{TimePickerElement: element.(*TimePickerBlockElement)}\n\tcase *PlainTextInputBlockElement:\n\t\treturn &Accessory{PlainTextInputElement: element.(*PlainTextInputBlockElement)}\n\tcase *RichTextInputBlockElement:\n\t\treturn &Accessory{RichTextInputElement: element.(*RichTextInputBlockElement)}\n\tcase *RadioButtonsBlockElement:\n\t\treturn &Accessory{RadioButtonsElement: element.(*RadioButtonsBlockElement)}\n\tcase *SelectBlockElement:\n\t\treturn &Accessory{SelectElement: element.(*SelectBlockElement)}\n\tcase *MultiSelectBlockElement:\n\t\treturn &Accessory{MultiSelectElement: element.(*MultiSelectBlockElement)}\n\tcase *CheckboxGroupsBlockElement:\n\t\treturn &Accessory{CheckboxGroupsBlockElement: element.(*CheckboxGroupsBlockElement)}\n\tdefault:\n\t\treturn &Accessory{UnknownElement: element.(*UnknownBlockElement)}\n\t}\n}\n\n// BlockElements is a convenience struct defined to allow dynamic unmarshalling of\n// the \"elements\" value in Slack's JSON response, which varies depending on BlockElement type\ntype BlockElements struct {\n\tElementSet []BlockElement `json:\"elements,omitempty\"`\n}\n\n// UnknownBlockElement any block element that this library does not directly support.\n// See the \"Rich Elements\" section at the following URL:\n// https://api.slack.com/changelog/2019-09-what-they-see-is-what-you-get-and-more-and-less\n// New block element types may be introduced by Slack at any time; this is a catch-all for any such block elements.\ntype UnknownBlockElement struct {\n\tType     MessageElementType `json:\"type\"`\n\tElements BlockElements\n}\n\n// ElementType returns the type of the Element\nfunc (s UnknownBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// ImageBlockElement An element to insert an image - this element can be used\n// in section and context blocks only. If you want a block with only an image\n// in it, you're looking for the image block.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#image\ntype ImageBlockElement struct {\n\tType     MessageElementType `json:\"type\"`\n\tImageURL string             `json:\"image_url\"`\n\tAltText  string             `json:\"alt_text\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s ImageBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\nfunc (s ImageBlockElement) MixedElementType() MixedElementType {\n\treturn MixedElementImage\n}\n\n// NewImageBlockElement returns a new instance of an image block element\nfunc NewImageBlockElement(imageURL, altText string) *ImageBlockElement {\n\treturn &ImageBlockElement{\n\t\tType:     METImage,\n\t\tImageURL: imageURL,\n\t\tAltText:  altText,\n\t}\n}\n\n// Style is a style of Button element\n// https://api.slack.com/reference/block-kit/block-elements#button__fields\ntype Style string\n\nconst (\n\tStyleDefault Style = \"\"\n\tStylePrimary Style = \"primary\"\n\tStyleDanger  Style = \"danger\"\n)\n\n// ButtonBlockElement defines an interactive element that inserts a button. The\n// button can be a trigger for anything from opening a simple link to starting\n// a complex workflow.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#button\ntype ButtonBlockElement struct {\n\tType     MessageElementType       `json:\"type,omitempty\"`\n\tText     *TextBlockObject         `json:\"text\"`\n\tActionID string                   `json:\"action_id,omitempty\"`\n\tURL      string                   `json:\"url,omitempty\"`\n\tValue    string                   `json:\"value,omitempty\"`\n\tConfirm  *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n\tStyle    Style                    `json:\"style,omitempty\"`\n}\n\n// ElementType returns the type of the element\nfunc (s ButtonBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// WithStyle adds styling to the button object and returns the modified ButtonBlockElement\nfunc (s *ButtonBlockElement) WithStyle(style Style) *ButtonBlockElement {\n\ts.Style = style\n\treturn s\n}\n\n// WithConfirm adds a confirmation dialogue to the button object and returns the modified ButtonBlockElement\nfunc (s *ButtonBlockElement) WithConfirm(confirm *ConfirmationBlockObject) *ButtonBlockElement {\n\ts.Confirm = confirm\n\treturn s\n}\n\n// WithURL adds a URL for the button to link to and returns the modified ButtonBlockElement\nfunc (s *ButtonBlockElement) WithURL(url string) *ButtonBlockElement {\n\ts.URL = url\n\treturn s\n}\n\n// NewButtonBlockElement returns an instance of a new button element to be used within a block\nfunc NewButtonBlockElement(actionID, value string, text *TextBlockObject) *ButtonBlockElement {\n\treturn &ButtonBlockElement{\n\t\tType:     METButton,\n\t\tActionID: actionID,\n\t\tText:     text,\n\t\tValue:    value,\n\t}\n}\n\n// OptionsResponse defines the response used for select block typahead.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#external_multi_select\ntype OptionsResponse struct {\n\tOptions []*OptionBlockObject `json:\"options,omitempty\"`\n}\n\n// OptionGroupsResponse defines the response used for select block typahead.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#external_multi_select\ntype OptionGroupsResponse struct {\n\tOptionGroups []*OptionGroupBlockObject `json:\"option_groups,omitempty\"`\n}\n\n// SelectBlockElement defines the simplest form of select menu, with a static list\n// of options passed in when defining the element.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#select\ntype SelectBlockElement struct {\n\tType                         string                    `json:\"type,omitempty\"`\n\tPlaceholder                  *TextBlockObject          `json:\"placeholder,omitempty\"`\n\tActionID                     string                    `json:\"action_id,omitempty\"`\n\tOptions                      []*OptionBlockObject      `json:\"options,omitempty\"`\n\tOptionGroups                 []*OptionGroupBlockObject `json:\"option_groups,omitempty\"`\n\tInitialOption                *OptionBlockObject        `json:\"initial_option,omitempty\"`\n\tInitialUser                  string                    `json:\"initial_user,omitempty\"`\n\tInitialConversation          string                    `json:\"initial_conversation,omitempty\"`\n\tInitialChannel               string                    `json:\"initial_channel,omitempty\"`\n\tDefaultToCurrentConversation bool                      `json:\"default_to_current_conversation,omitempty\"`\n\tResponseURLEnabled           bool                      `json:\"response_url_enabled,omitempty\"`\n\tFilter                       *SelectBlockElementFilter `json:\"filter,omitempty\"`\n\tMinQueryLength               *int                      `json:\"min_query_length,omitempty\"`\n\tConfirm                      *ConfirmationBlockObject  `json:\"confirm,omitempty\"`\n}\n\n// SelectBlockElementFilter allows to filter select element conversation options by type.\n//\n// More Information: https://api.slack.com/reference/block-kit/composition-objects#filter_conversations\ntype SelectBlockElementFilter struct {\n\tInclude                       []string `json:\"include,omitempty\"`\n\tExcludeExternalSharedChannels bool     `json:\"exclude_external_shared_channels,omitempty\"`\n\tExcludeBotUsers               bool     `json:\"exclude_bot_users,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s SelectBlockElement) ElementType() MessageElementType {\n\treturn MessageElementType(s.Type)\n}\n\n// NewOptionsSelectBlockElement returns a new instance of SelectBlockElement for use with\n// the Options object only.\nfunc NewOptionsSelectBlockElement(optType string, placeholder *TextBlockObject, actionID string, options ...*OptionBlockObject) *SelectBlockElement {\n\treturn &SelectBlockElement{\n\t\tType:        optType,\n\t\tPlaceholder: placeholder,\n\t\tActionID:    actionID,\n\t\tOptions:     options,\n\t}\n}\n\n// WithInitialOption sets the initial option for the select element\nfunc (s *SelectBlockElement) WithInitialOption(option *OptionBlockObject) *SelectBlockElement {\n\ts.InitialOption = option\n\treturn s\n}\n\n// WithInitialUser sets the initial user for the select element\nfunc (s *SelectBlockElement) WithInitialUser(user string) *SelectBlockElement {\n\ts.InitialUser = user\n\treturn s\n}\n\n// WithInitialConversation sets the initial conversation for the select element\nfunc (s *SelectBlockElement) WithInitialConversation(conversation string) *SelectBlockElement {\n\ts.InitialConversation = conversation\n\treturn s\n}\n\n// WithInitialChannel sets the initial channel for the select element\nfunc (s *SelectBlockElement) WithInitialChannel(channel string) *SelectBlockElement {\n\ts.InitialChannel = channel\n\treturn s\n}\n\n// WithConfirm adds a confirmation dialogue to the select element\nfunc (s *SelectBlockElement) WithConfirm(confirm *ConfirmationBlockObject) *SelectBlockElement {\n\ts.Confirm = confirm\n\treturn s\n}\n\n// NewOptionsGroupSelectBlockElement returns a new instance of SelectBlockElement for use with\n// the Options object only.\nfunc NewOptionsGroupSelectBlockElement(\n\toptType string,\n\tplaceholder *TextBlockObject,\n\tactionID string,\n\toptGroups ...*OptionGroupBlockObject,\n) *SelectBlockElement {\n\treturn &SelectBlockElement{\n\t\tType:         optType,\n\t\tPlaceholder:  placeholder,\n\t\tActionID:     actionID,\n\t\tOptionGroups: optGroups,\n\t}\n}\n\n// MultiSelectBlockElement defines a multiselect menu, with a static list\n// of options passed in when defining the element.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#multi_select\ntype MultiSelectBlockElement struct {\n\tType                 string                    `json:\"type,omitempty\"`\n\tPlaceholder          *TextBlockObject          `json:\"placeholder,omitempty\"`\n\tActionID             string                    `json:\"action_id,omitempty\"`\n\tOptions              []*OptionBlockObject      `json:\"options,omitempty\"`\n\tOptionGroups         []*OptionGroupBlockObject `json:\"option_groups,omitempty\"`\n\tInitialOptions       []*OptionBlockObject      `json:\"initial_options,omitempty\"`\n\tInitialUsers         []string                  `json:\"initial_users,omitempty\"`\n\tInitialConversations []string                  `json:\"initial_conversations,omitempty\"`\n\tInitialChannels      []string                  `json:\"initial_channels,omitempty\"`\n\tMinQueryLength       *int                      `json:\"min_query_length,omitempty\"`\n\tMaxSelectedItems     *int                      `json:\"max_selected_items,omitempty\"`\n\tConfirm              *ConfirmationBlockObject  `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s MultiSelectBlockElement) ElementType() MessageElementType {\n\treturn MessageElementType(s.Type)\n}\n\n// NewOptionsMultiSelectBlockElement returns a new instance of SelectBlockElement for use with\n// the Options object only.\nfunc NewOptionsMultiSelectBlockElement(optType string, placeholder *TextBlockObject, actionID string, options ...*OptionBlockObject) *MultiSelectBlockElement {\n\treturn &MultiSelectBlockElement{\n\t\tType:        optType,\n\t\tPlaceholder: placeholder,\n\t\tActionID:    actionID,\n\t\tOptions:     options,\n\t}\n}\n\n// WithInitialOptions sets the initial options for the multi-select element\nfunc (s *MultiSelectBlockElement) WithInitialOptions(options ...*OptionBlockObject) *MultiSelectBlockElement {\n\ts.InitialOptions = options\n\treturn s\n}\n\n// WithInitialUsers sets the initial users for the multi-select element\nfunc (s *MultiSelectBlockElement) WithInitialUsers(users ...string) *MultiSelectBlockElement {\n\ts.InitialUsers = users\n\treturn s\n}\n\n// WithInitialConversations sets the initial conversations for the multi-select element\nfunc (s *MultiSelectBlockElement) WithInitialConversations(conversations ...string) *MultiSelectBlockElement {\n\ts.InitialConversations = conversations\n\treturn s\n}\n\n// WithInitialChannels sets the initial channels for the multi-select element\nfunc (s *MultiSelectBlockElement) WithInitialChannels(channels ...string) *MultiSelectBlockElement {\n\ts.InitialChannels = channels\n\treturn s\n}\n\n// WithConfirm adds a confirmation dialogue to the multi-select element\nfunc (s *MultiSelectBlockElement) WithConfirm(confirm *ConfirmationBlockObject) *MultiSelectBlockElement {\n\ts.Confirm = confirm\n\treturn s\n}\n\n// WithMaxSelectedItems sets the maximum number of items that can be selected\nfunc (s *MultiSelectBlockElement) WithMaxSelectedItems(maxSelectedItems int) *MultiSelectBlockElement {\n\ts.MaxSelectedItems = &maxSelectedItems\n\treturn s\n}\n\n// WithMinQueryLength sets the minimum query length for the multi-select element\nfunc (s *MultiSelectBlockElement) WithMinQueryLength(minQueryLength int) *MultiSelectBlockElement {\n\ts.MinQueryLength = &minQueryLength\n\treturn s\n}\n\n// NewOptionsGroupMultiSelectBlockElement returns a new instance of MultiSelectBlockElement for use with\n// the Options object only.\nfunc NewOptionsGroupMultiSelectBlockElement(\n\toptType string,\n\tplaceholder *TextBlockObject,\n\tactionID string,\n\toptGroups ...*OptionGroupBlockObject,\n) *MultiSelectBlockElement {\n\treturn &MultiSelectBlockElement{\n\t\tType:         optType,\n\t\tPlaceholder:  placeholder,\n\t\tActionID:     actionID,\n\t\tOptionGroups: optGroups,\n\t}\n}\n\n// OverflowBlockElement defines the fields needed to use an overflow element.\n// And Overflow Element is like a cross between a button and a select menu -\n// when a user clicks on this overflow button, they will be presented with a\n// list of options to choose from.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#overflow\ntype OverflowBlockElement struct {\n\tType     MessageElementType       `json:\"type\"`\n\tActionID string                   `json:\"action_id,omitempty\"`\n\tOptions  []*OptionBlockObject     `json:\"options\"`\n\tConfirm  *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s OverflowBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewOverflowBlockElement returns an instance of a new Overflow Block Element\nfunc NewOverflowBlockElement(actionID string, options ...*OptionBlockObject) *OverflowBlockElement {\n\treturn &OverflowBlockElement{\n\t\tType:     METOverflow,\n\t\tActionID: actionID,\n\t\tOptions:  options,\n\t}\n}\n\n// WithConfirm adds a confirmation dialogue to the overflow element\nfunc (s *OverflowBlockElement) WithConfirm(confirm *ConfirmationBlockObject) *OverflowBlockElement {\n\ts.Confirm = confirm\n\treturn s\n}\n\n// DatePickerBlockElement defines an element which lets users easily select a\n// date from a calendar style UI. Date picker elements can be used inside of\n// section and actions blocks.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#datepicker\ntype DatePickerBlockElement struct {\n\tType        MessageElementType       `json:\"type\"`\n\tActionID    string                   `json:\"action_id,omitempty\"`\n\tPlaceholder *TextBlockObject         `json:\"placeholder,omitempty\"`\n\tInitialDate string                   `json:\"initial_date,omitempty\"`\n\tConfirm     *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s DatePickerBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewDatePickerBlockElement returns an instance of a date picker element\nfunc NewDatePickerBlockElement(actionID string) *DatePickerBlockElement {\n\treturn &DatePickerBlockElement{\n\t\tType:     METDatepicker,\n\t\tActionID: actionID,\n\t}\n}\n\n// TimePickerBlockElement defines an element which lets users easily select a\n// time from nice UI. Time picker elements can be used inside of\n// section and actions blocks.\n//\n// More Information: https://api.slack.com/reference/messaging/block-elements#timepicker\ntype TimePickerBlockElement struct {\n\tType        MessageElementType       `json:\"type\"`\n\tActionID    string                   `json:\"action_id,omitempty\"`\n\tPlaceholder *TextBlockObject         `json:\"placeholder,omitempty\"`\n\tInitialTime string                   `json:\"initial_time,omitempty\"`\n\tConfirm     *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s TimePickerBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewTimePickerBlockElement returns an instance of a date picker element\nfunc NewTimePickerBlockElement(actionID string) *TimePickerBlockElement {\n\treturn &TimePickerBlockElement{\n\t\tType:     METTimepicker,\n\t\tActionID: actionID,\n\t}\n}\n\n// DateTimePickerBlockElement defines an element that allows the selection of both\n// a date and a time of day formatted as a UNIX timestamp.\n// More Information: https://api.slack.com/reference/messaging/block-elements#datetimepicker\ntype DateTimePickerBlockElement struct {\n\tType            MessageElementType       `json:\"type\"`\n\tActionID        string                   `json:\"action_id,omitempty\"`\n\tInitialDateTime int64                    `json:\"initial_date_time,omitempty\"`\n\tConfirm         *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s DateTimePickerBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewDatePickerBlockElement returns an instance of a datetime picker element\nfunc NewDateTimePickerBlockElement(actionID string) *DateTimePickerBlockElement {\n\treturn &DateTimePickerBlockElement{\n\t\tType:     METDatetimepicker,\n\t\tActionID: actionID,\n\t}\n}\n\n// EmailTextInputBlockElement creates a field where a user can enter email\n// data.\n// email-text-input elements are currently only available in modals.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#email\ntype EmailTextInputBlockElement struct {\n\tType                 MessageElementType    `json:\"type\"`\n\tActionID             string                `json:\"action_id,omitempty\"`\n\tPlaceholder          *TextBlockObject      `json:\"placeholder,omitempty\"`\n\tInitialValue         string                `json:\"initial_value,omitempty\"`\n\tDispatchActionConfig *DispatchActionConfig `json:\"dispatch_action_config,omitempty\"`\n\tFocusOnLoad          bool                  `json:\"focus_on_load,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s EmailTextInputBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewEmailTextInputBlockElement returns an instance of a plain-text input\n// element\nfunc NewEmailTextInputBlockElement(placeholder *TextBlockObject, actionID string) *EmailTextInputBlockElement {\n\treturn &EmailTextInputBlockElement{\n\t\tType:        METEmailTextInput,\n\t\tActionID:    actionID,\n\t\tPlaceholder: placeholder,\n\t}\n}\n\n// URLTextInputBlockElement creates a field where a user can enter url data.\n//\n// url-text-input elements are currently only available in modals.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#url\ntype URLTextInputBlockElement struct {\n\tType                 MessageElementType    `json:\"type\"`\n\tActionID             string                `json:\"action_id,omitempty\"`\n\tPlaceholder          *TextBlockObject      `json:\"placeholder,omitempty\"`\n\tInitialValue         string                `json:\"initial_value,omitempty\"`\n\tDispatchActionConfig *DispatchActionConfig `json:\"dispatch_action_config,omitempty\"`\n\tFocusOnLoad          bool                  `json:\"focus_on_load,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s URLTextInputBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewURLTextInputBlockElement returns an instance of a plain-text input\n// element\nfunc NewURLTextInputBlockElement(placeholder *TextBlockObject, actionID string) *URLTextInputBlockElement {\n\treturn &URLTextInputBlockElement{\n\t\tType:        METURLTextInput,\n\t\tActionID:    actionID,\n\t\tPlaceholder: placeholder,\n\t}\n}\n\n// PlainTextInputBlockElement creates a field where a user can enter freeform\n// data.\n// Plain-text input elements are currently only available in modals.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#input\ntype PlainTextInputBlockElement struct {\n\tType                 MessageElementType    `json:\"type\"`\n\tActionID             string                `json:\"action_id,omitempty\"`\n\tPlaceholder          *TextBlockObject      `json:\"placeholder,omitempty\"`\n\tInitialValue         string                `json:\"initial_value,omitempty\"`\n\tMultiline            bool                  `json:\"multiline,omitempty\"`\n\tMinLength            int                   `json:\"min_length,omitempty\"`\n\tMaxLength            int                   `json:\"max_length,omitempty\"`\n\tDispatchActionConfig *DispatchActionConfig `json:\"dispatch_action_config,omitempty\"`\n}\n\ntype DispatchActionConfig struct {\n\tTriggerActionsOn []string `json:\"trigger_actions_on,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s PlainTextInputBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewPlainTextInputBlockElement returns an instance of a plain-text input\n// element\nfunc NewPlainTextInputBlockElement(placeholder *TextBlockObject, actionID string) *PlainTextInputBlockElement {\n\treturn &PlainTextInputBlockElement{\n\t\tType:        METPlainTextInput,\n\t\tActionID:    actionID,\n\t\tPlaceholder: placeholder,\n\t}\n}\n\n// WithInitialValue sets the initial value for the plain-text input element\nfunc (s *PlainTextInputBlockElement) WithInitialValue(initialValue string) *PlainTextInputBlockElement {\n\ts.InitialValue = initialValue\n\treturn s\n}\n\n// WithMinLength sets the minimum length for the plain-text input element\nfunc (s *PlainTextInputBlockElement) WithMinLength(minLength int) *PlainTextInputBlockElement {\n\ts.MinLength = minLength\n\treturn s\n}\n\n// WithMaxLength sets the maximum length for the plain-text input element\nfunc (s *PlainTextInputBlockElement) WithMaxLength(maxLength int) *PlainTextInputBlockElement {\n\ts.MaxLength = maxLength\n\treturn s\n}\n\n// WithMultiline sets the multiline property for the plain-text input element\nfunc (s *PlainTextInputBlockElement) WithMultiline(multiline bool) *PlainTextInputBlockElement {\n\ts.Multiline = multiline\n\treturn s\n}\n\n// WithDispatchActionConfig sets the dispatch action config for the plain-text input element\nfunc (s *PlainTextInputBlockElement) WithDispatchActionConfig(config *DispatchActionConfig) *PlainTextInputBlockElement {\n\ts.DispatchActionConfig = config\n\treturn s\n}\n\n// RichTextInputBlockElement creates a field where allows users to enter formatted text\n// in a WYSIWYG composer, offering the same messaging writing experience as in Slack\n// More Information: https://api.slack.com/reference/block-kit/block-elements#rich_text_input\ntype RichTextInputBlockElement struct {\n\tType                 MessageElementType    `json:\"type\"`\n\tActionID             string                `json:\"action_id,omitempty\"`\n\tPlaceholder          *TextBlockObject      `json:\"placeholder,omitempty\"`\n\tInitialValue         *RichTextBlock        `json:\"initial_value,omitempty\"`\n\tDispatchActionConfig *DispatchActionConfig `json:\"dispatch_action_config,omitempty\"`\n\tFocusOnLoad          bool                  `json:\"focus_on_load,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s RichTextInputBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewRichTextInputBlockElement returns an instance of a rich-text input element\nfunc NewRichTextInputBlockElement(placeholder *TextBlockObject, actionID string) *RichTextInputBlockElement {\n\treturn &RichTextInputBlockElement{\n\t\tType:        METRichTextInput,\n\t\tActionID:    actionID,\n\t\tPlaceholder: placeholder,\n\t}\n}\n\n// CheckboxGroupsBlockElement defines an element which allows users to choose\n// one or more items from a list of possible options.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#checkboxes\ntype CheckboxGroupsBlockElement struct {\n\tType           MessageElementType       `json:\"type\"`\n\tActionID       string                   `json:\"action_id,omitempty\"`\n\tOptions        []*OptionBlockObject     `json:\"options\"`\n\tInitialOptions []*OptionBlockObject     `json:\"initial_options,omitempty\"`\n\tConfirm        *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (c CheckboxGroupsBlockElement) ElementType() MessageElementType {\n\treturn c.Type\n}\n\n// NewCheckboxGroupsBlockElement returns an instance of a checkbox-group block element\nfunc NewCheckboxGroupsBlockElement(actionID string, options ...*OptionBlockObject) *CheckboxGroupsBlockElement {\n\treturn &CheckboxGroupsBlockElement{\n\t\tType:     METCheckboxGroups,\n\t\tActionID: actionID,\n\t\tOptions:  options,\n\t}\n}\n\n// RadioButtonsBlockElement defines an element which lets users choose one item\n// from a list of possible options.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#radio\ntype RadioButtonsBlockElement struct {\n\tType          MessageElementType       `json:\"type\"`\n\tActionID      string                   `json:\"action_id,omitempty\"`\n\tOptions       []*OptionBlockObject     `json:\"options\"`\n\tInitialOption *OptionBlockObject       `json:\"initial_option,omitempty\"`\n\tConfirm       *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s RadioButtonsBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewRadioButtonsBlockElement returns an instance of a radio buttons element.\nfunc NewRadioButtonsBlockElement(actionID string, options ...*OptionBlockObject) *RadioButtonsBlockElement {\n\treturn &RadioButtonsBlockElement{\n\t\tType:     METRadioButtons,\n\t\tActionID: actionID,\n\t\tOptions:  options,\n\t}\n}\n\n// NumberInputBlockElement creates a field where a user can enter number\n// data.\n// Number input elements are currently only available in modals.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#number\ntype NumberInputBlockElement struct {\n\tType                 MessageElementType    `json:\"type\"`\n\tIsDecimalAllowed     bool                  `json:\"is_decimal_allowed\"`\n\tActionID             string                `json:\"action_id,omitempty\"`\n\tPlaceholder          *TextBlockObject      `json:\"placeholder,omitempty\"`\n\tInitialValue         string                `json:\"initial_value,omitempty\"`\n\tMinValue             string                `json:\"min_value,omitempty\"`\n\tMaxValue             string                `json:\"max_value,omitempty\"`\n\tDispatchActionConfig *DispatchActionConfig `json:\"dispatch_action_config,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s NumberInputBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewNumberInputBlockElement returns an instance of a number input element\nfunc NewNumberInputBlockElement(placeholder *TextBlockObject, actionID string, isDecimalAllowed bool) *NumberInputBlockElement {\n\treturn &NumberInputBlockElement{\n\t\tType:             METNumber,\n\t\tActionID:         actionID,\n\t\tPlaceholder:      placeholder,\n\t\tIsDecimalAllowed: isDecimalAllowed,\n\t}\n}\n\n// WithInitialValue sets the initial value for the number input element\nfunc (s *NumberInputBlockElement) WithInitialValue(initialValue string) *NumberInputBlockElement {\n\ts.InitialValue = initialValue\n\treturn s\n}\n\n// WithMinValue sets the minimum value for the number input element\nfunc (s *NumberInputBlockElement) WithMinValue(minValue string) *NumberInputBlockElement {\n\ts.MinValue = minValue\n\treturn s\n}\n\n// WithMaxValue sets the maximum value for the number input element\nfunc (s *NumberInputBlockElement) WithMaxValue(maxValue string) *NumberInputBlockElement {\n\ts.MaxValue = maxValue\n\treturn s\n}\n\n// WithDispatchActionConfig sets the dispatch action config for the number input element\nfunc (s *NumberInputBlockElement) WithDispatchActionConfig(config *DispatchActionConfig) *NumberInputBlockElement {\n\ts.DispatchActionConfig = config\n\treturn s\n}\n\n// FileInputBlockElement creates a field where a user can upload a file.\n//\n// File input elements are currently only available in modals.\n//\n// More Information: https://api.slack.com/reference/block-kit/block-elements#file_input\ntype FileInputBlockElement struct {\n\tType      MessageElementType `json:\"type\"`\n\tActionID  string             `json:\"action_id,omitempty\"`\n\tFileTypes []string           `json:\"filetypes,omitempty\"`\n\tMaxFiles  int                `json:\"max_files,omitempty\"`\n}\n\n// ElementType returns the type of the Element\nfunc (s FileInputBlockElement) ElementType() MessageElementType {\n\treturn s.Type\n}\n\n// NewFileInputBlockElement returns an instance of a file input element\nfunc NewFileInputBlockElement(actionID string) *FileInputBlockElement {\n\treturn &FileInputBlockElement{\n\t\tType:     METFileInput,\n\t\tActionID: actionID,\n\t}\n}\n\n// WithFileTypes sets the file types that can be uploaded\nfunc (s *FileInputBlockElement) WithFileTypes(fileTypes ...string) *FileInputBlockElement {\n\ts.FileTypes = fileTypes\n\treturn s\n}\n\n// WithMaxFiles sets the maximum number of files that can be uploaded\nfunc (s *FileInputBlockElement) WithMaxFiles(maxFiles int) *FileInputBlockElement {\n\ts.MaxFiles = maxFiles\n\treturn s\n}\n"
        },
        {
          "name": "block_element_test.go",
          "type": "blob",
          "size": 9.5634765625,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewImageBlockElement(t *testing.T) {\n\n\timageElement := NewImageBlockElement(\"https://api.slack.com/img/blocks/bkb_template_images/tripAgentLocationMarker.png\", \"Location Pin Icon\")\n\n\tassert.Equal(t, string(imageElement.Type), \"image\")\n\tassert.Contains(t, imageElement.ImageURL, \"tripAgentLocationMarker\")\n\tassert.Equal(t, imageElement.AltText, \"Location Pin Icon\")\n\n}\n\nfunc TestNewButtonBlockElement(t *testing.T) {\n\n\tbtnTxt := NewTextBlockObject(\"plain_text\", \"Next 2 Results\", false, false)\n\tbtnElement := NewButtonBlockElement(\"test\", \"click_me_123\", btnTxt)\n\n\tassert.Equal(t, string(btnElement.Type), \"button\")\n\tassert.Equal(t, btnElement.ActionID, \"test\")\n\tassert.Equal(t, btnElement.Value, \"click_me_123\")\n\tassert.Equal(t, btnElement.Text.Text, \"Next 2 Results\")\n\n}\n\nfunc TestWithStyleForButtonElement(t *testing.T) {\n\n\t// these values are irrelevant in this test\n\tbtnTxt := NewTextBlockObject(\"plain_text\", \"Next 2 Results\", false, false)\n\tbtnElement := NewButtonBlockElement(\"test\", \"click_me_123\", btnTxt)\n\n\tbtnElement.WithStyle(StyleDefault)\n\tassert.Equal(t, btnElement.Style, Style(\"\"))\n\tbtnElement.WithStyle(StylePrimary)\n\tassert.Equal(t, btnElement.Style, Style(\"primary\"))\n\tbtnElement.WithStyle(StyleDanger)\n\tassert.Equal(t, btnElement.Style, Style(\"danger\"))\n\n}\n\nfunc TestWithURLForButtonElement(t *testing.T) {\n\n\tbtnTxt := NewTextBlockObject(\"plain_text\", \"Next 2 Results\", false, false)\n\tbtnElement := NewButtonBlockElement(\"test\", \"click_me_123\", btnTxt)\n\n\tbtnElement.WithURL(\"https://foo.bar\")\n\tassert.Equal(t, btnElement.URL, \"https://foo.bar\")\n\n}\n\nfunc TestNewOptionsSelectBlockElement(t *testing.T) {\n\n\ttestOptionText := NewTextBlockObject(\"plain_text\", \"Option One\", false, false)\n\ttestOption := NewOptionBlockObject(\"test\", testOptionText, nil)\n\n\toption := NewOptionsSelectBlockElement(\"static_select\", nil, \"test\", testOption)\n\tassert.Equal(t, option.Type, \"static_select\")\n\tassert.Equal(t, len(option.Options), 1)\n\tassert.Nil(t, option.OptionGroups)\n\n}\n\nfunc TestNewOptionsGroupSelectBlockElement(t *testing.T) {\n\n\ttestOptionText := NewTextBlockObject(\"plain_text\", \"Option One\", false, false)\n\ttestOption := NewOptionBlockObject(\"test\", testOptionText, nil)\n\ttestLabel := NewTextBlockObject(\"plain_text\", \"Test Label\", false, false)\n\ttestGroupOption := NewOptionGroupBlockElement(testLabel, testOption)\n\n\toptGroup := NewOptionsGroupSelectBlockElement(\"static_select\", nil, \"test\", testGroupOption)\n\n\tassert.Equal(t, optGroup.Type, \"static_select\")\n\tassert.Equal(t, optGroup.ActionID, \"test\")\n\tassert.Equal(t, len(optGroup.OptionGroups), 1)\n\n}\n\nfunc TestNewOptionsMultiSelectBlockElement(t *testing.T) {\n\n\ttestOptionText := NewTextBlockObject(\"plain_text\", \"Option One\", false, false)\n\ttestDescriptionText := NewTextBlockObject(\"plain_text\", \"Description One\", false, false)\n\ttestOption := NewOptionBlockObject(\"test\", testOptionText, testDescriptionText)\n\n\toption := NewOptionsMultiSelectBlockElement(\"static_select\", nil, \"test\", testOption)\n\tassert.Equal(t, option.Type, \"static_select\")\n\tassert.Equal(t, len(option.Options), 1)\n\tassert.Nil(t, option.OptionGroups)\n\n}\n\nfunc TestNewOptionsGroupMultiSelectBlockElement(t *testing.T) {\n\n\ttestOptionText := NewTextBlockObject(\"plain_text\", \"Option One\", false, false)\n\ttestOption := NewOptionBlockObject(\"test\", testOptionText, nil)\n\ttestLabel := NewTextBlockObject(\"plain_text\", \"Test Label\", false, false)\n\ttestGroupOption := NewOptionGroupBlockElement(testLabel, testOption)\n\n\toptGroup := NewOptionsGroupMultiSelectBlockElement(\"static_select\", nil, \"test\", testGroupOption)\n\n\tassert.Equal(t, optGroup.Type, \"static_select\")\n\tassert.Equal(t, optGroup.ActionID, \"test\")\n\tassert.Equal(t, len(optGroup.OptionGroups), 1)\n\n}\nfunc TestNewOverflowBlockElement(t *testing.T) {\n\n\t// Build Text Objects associated with each option\n\toverflowOptionTextOne := NewTextBlockObject(\"plain_text\", \"Option One\", false, false)\n\toverflowOptionTextTwo := NewTextBlockObject(\"plain_text\", \"Option Two\", false, false)\n\toverflowOptionTextThree := NewTextBlockObject(\"plain_text\", \"Option Three\", false, false)\n\n\t// Build each option, providing a value for the option\n\toverflowOptionOne := NewOptionBlockObject(\"value-0\", overflowOptionTextOne, nil)\n\toverflowOptionTwo := NewOptionBlockObject(\"value-1\", overflowOptionTextTwo, nil)\n\toverflowOptionThree := NewOptionBlockObject(\"value-2\", overflowOptionTextThree, nil)\n\n\t// Build overflow section\n\toverflowElement := NewOverflowBlockElement(\"test\", overflowOptionOne, overflowOptionTwo, overflowOptionThree)\n\n\tassert.Equal(t, string(overflowElement.Type), \"overflow\")\n\tassert.Equal(t, overflowElement.ActionID, \"test\")\n\tassert.Equal(t, len(overflowElement.Options), 3)\n\n}\n\nfunc TestNewDatePickerBlockElement(t *testing.T) {\n\n\tdatepickerElement := NewDatePickerBlockElement(\"test\")\n\n\tassert.Equal(t, string(datepickerElement.Type), \"datepicker\")\n\tassert.Equal(t, datepickerElement.ActionID, \"test\")\n\n}\n\nfunc TestNewTimePickerBlockElement(t *testing.T) {\n\ttimepickerElement := NewTimePickerBlockElement(\"test\")\n\tassert.Equal(t, string(timepickerElement.Type), \"timepicker\")\n\tassert.Equal(t, timepickerElement.ActionID, \"test\")\n}\n\nfunc TestNewDateTimePickerBlockElement(t *testing.T) {\n\tdatetimepickerElement := NewDateTimePickerBlockElement(\"test\")\n\tassert.Equal(t, string(datetimepickerElement.Type), \"datetimepicker\")\n\tassert.Equal(t, datetimepickerElement.ActionID, \"test\")\n}\n\nfunc TestNewPlainTextInputBlockElement(t *testing.T) {\n\n\tplainTextInputElement := NewPlainTextInputBlockElement(nil, \"test\")\n\n\tassert.Equal(t, string(plainTextInputElement.Type), \"plain_text_input\")\n\tassert.Equal(t, plainTextInputElement.ActionID, \"test\")\n\n}\n\nfunc TestNewRichTextInputBlockElement(t *testing.T) {\n\trichTextInputElement := NewRichTextInputBlockElement(nil, \"test\")\n\tassert.Equal(t, string(richTextInputElement.Type), \"rich_text_input\")\n\tassert.Equal(t, richTextInputElement.ActionID, \"test\")\n}\n\nfunc TestNewEmailTextInputBlockElement(t *testing.T) {\n\temailTextInputElement := NewEmailTextInputBlockElement(nil, \"example@example.com\")\n\n\tassert.Equal(t, string(emailTextInputElement.Type), \"email_text_input\")\n\tassert.Equal(t, emailTextInputElement.ActionID, \"example@example.com\")\n}\n\nfunc TestNewURLTextInputBlockElement(t *testing.T) {\n\turlTextInputElement := NewURLTextInputBlockElement(nil, \"www.example.com\")\n\n\tassert.Equal(t, string(urlTextInputElement.Type), \"url_text_input\")\n\tassert.Equal(t, urlTextInputElement.ActionID, \"www.example.com\")\n}\n\nfunc TestNewCheckboxGroupsBlockElement(t *testing.T) {\n\t// Build Text Objects associated with each option\n\tcheckBoxOptionTextOne := NewTextBlockObject(\"plain_text\", \"Check One\", false, false)\n\tcheckBoxOptionTextTwo := NewTextBlockObject(\"plain_text\", \"Check Two\", false, false)\n\tcheckBoxOptionTextThree := NewTextBlockObject(\"plain_text\", \"Check Three\", false, false)\n\n\tcheckBoxDescriptionTextOne := NewTextBlockObject(\"plain_text\", \"Description One\", false, false)\n\tcheckBoxDescriptionTextTwo := NewTextBlockObject(\"plain_text\", \"Description Two\", false, false)\n\tcheckBoxDescriptionTextThree := NewTextBlockObject(\"plain_text\", \"Description Three\", false, false)\n\n\t// Build each option, providing a value for the option\n\tcheckBoxOptionOne := NewOptionBlockObject(\"value-0\", checkBoxOptionTextOne, checkBoxDescriptionTextOne)\n\tcheckBoxOptionTwo := NewOptionBlockObject(\"value-1\", checkBoxOptionTextTwo, checkBoxDescriptionTextTwo)\n\tcheckBoxOptionThree := NewOptionBlockObject(\"value-2\", checkBoxOptionTextThree, checkBoxDescriptionTextThree)\n\n\t// Build checkbox-group element\n\tcheckBoxGroupElement := NewCheckboxGroupsBlockElement(\"test\", checkBoxOptionOne, checkBoxOptionTwo, checkBoxOptionThree)\n\n\tassert.Equal(t, string(checkBoxGroupElement.Type), \"checkboxes\")\n\tassert.Equal(t, checkBoxGroupElement.ActionID, \"test\")\n\tassert.Equal(t, len(checkBoxGroupElement.Options), 3)\n}\n\nfunc TestNewRadioButtonsBlockElement(t *testing.T) {\n\n\t// Build Text Objects associated with each option\n\tradioButtonsOptionTextOne := NewTextBlockObject(\"plain_text\", \"Option One\", false, false)\n\tradioButtonsOptionTextTwo := NewTextBlockObject(\"plain_text\", \"Option Two\", false, false)\n\tradioButtonsOptionTextThree := NewTextBlockObject(\"plain_text\", \"Option Three\", false, false)\n\n\t// Build each option, providing a value for the option\n\tradioButtonsOptionOne := NewOptionBlockObject(\"value-0\", radioButtonsOptionTextOne, nil)\n\tradioButtonsOptionTwo := NewOptionBlockObject(\"value-1\", radioButtonsOptionTextTwo, nil)\n\tradioButtonsOptionThree := NewOptionBlockObject(\"value-2\", radioButtonsOptionTextThree, nil)\n\n\t// Build radio button element\n\tradioButtonsElement := NewRadioButtonsBlockElement(\"test\", radioButtonsOptionOne, radioButtonsOptionTwo, radioButtonsOptionThree)\n\n\tassert.Equal(t, string(radioButtonsElement.Type), \"radio_buttons\")\n\tassert.Equal(t, radioButtonsElement.ActionID, \"test\")\n\tassert.Equal(t, len(radioButtonsElement.Options), 3)\n\n}\n\nfunc TestNewNumberInputBlockElement(t *testing.T) {\n\n\tnumberInputElement := NewNumberInputBlockElement(nil, \"test\", true)\n\n\tassert.Equal(t, string(numberInputElement.Type), \"number_input\")\n\tassert.Equal(t, numberInputElement.ActionID, \"test\")\n\tassert.Equal(t, numberInputElement.IsDecimalAllowed, true)\n\n}\n\nfunc TestNewFileInputBlockElement(t *testing.T) {\n\n\tfileInputElement := NewFileInputBlockElement(\"test\")\n\n\tassert.Equal(t, string(fileInputElement.Type), \"file_input\")\n\tassert.Equal(t, fileInputElement.ActionID, \"test\")\n\n\tfileInputElement.WithFileTypes(\"jpg\", \"png\")\n\tassert.Equal(t, len(fileInputElement.FileTypes), 2)\n\tassert.Contains(t, fileInputElement.FileTypes, \"jpg\")\n\tassert.Contains(t, fileInputElement.FileTypes, \"png\")\n\n\tfileInputElement.WithMaxFiles(10)\n\tassert.Equal(t, fileInputElement.MaxFiles, 10)\n}\n"
        },
        {
          "name": "block_file.go",
          "type": "blob",
          "size": 0.728515625,
          "content": "package slack\n\n// FileBlock defines data that is used to display a remote file.\n//\n// More Information: https://api.slack.com/reference/block-kit/blocks#file\ntype FileBlock struct {\n\tType       MessageBlockType `json:\"type\"`\n\tBlockID    string           `json:\"block_id,omitempty\"`\n\tExternalID string           `json:\"external_id\"`\n\tSource     string           `json:\"source\"`\n}\n\n// BlockType returns the type of the block\nfunc (s FileBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewFileBlock returns a new instance of a file block\nfunc NewFileBlock(blockID string, externalID string, source string) *FileBlock {\n\treturn &FileBlock{\n\t\tType:       MBTFile,\n\t\tBlockID:    blockID,\n\t\tExternalID: externalID,\n\t\tSource:     source,\n\t}\n}\n"
        },
        {
          "name": "block_file_test.go",
          "type": "blob",
          "size": 0.3603515625,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewFileBlock(t *testing.T) {\n\tfileBlock := NewFileBlock(\"test\", \"external_id\", \"source\")\n\tassert.Equal(t, string(fileBlock.Type), \"file\")\n\tassert.Equal(t, fileBlock.BlockID, \"test\")\n\tassert.Equal(t, fileBlock.ExternalID, \"external_id\")\n\tassert.Equal(t, fileBlock.Source, \"source\")\n}\n"
        },
        {
          "name": "block_header.go",
          "type": "blob",
          "size": 0.9599609375,
          "content": "package slack\n\n// HeaderBlock defines a new block of type header\n//\n// More Information: https://api.slack.com/reference/messaging/blocks#header\ntype HeaderBlock struct {\n\tType    MessageBlockType `json:\"type\"`\n\tText    *TextBlockObject `json:\"text,omitempty\"`\n\tBlockID string           `json:\"block_id,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (s HeaderBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// HeaderBlockOption allows configuration of options for a new header block\ntype HeaderBlockOption func(*HeaderBlock)\n\nfunc HeaderBlockOptionBlockID(blockID string) HeaderBlockOption {\n\treturn func(block *HeaderBlock) {\n\t\tblock.BlockID = blockID\n\t}\n}\n\n// NewHeaderBlock returns a new instance of a header block to be rendered\nfunc NewHeaderBlock(textObj *TextBlockObject, options ...HeaderBlockOption) *HeaderBlock {\n\tblock := HeaderBlock{\n\t\tType: MBTHeader,\n\t\tText: textObj,\n\t}\n\n\tfor _, option := range options {\n\t\toption(&block)\n\t}\n\n\treturn &block\n}\n"
        },
        {
          "name": "block_header_test.go",
          "type": "blob",
          "size": 0.5,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewHeaderBlock(t *testing.T) {\n\n\ttextInfo := NewTextBlockObject(\"plain_text\", \"This is quite the header\", false, false)\n\n\theaderBlock := NewHeaderBlock(textInfo, HeaderBlockOptionBlockID(\"test_block\"))\n\tassert.Equal(t, string(headerBlock.Type), \"header\")\n\tassert.Equal(t, headerBlock.BlockID, \"test_block\")\n\tassert.Equal(t, headerBlock.Text.Type, \"plain_text\")\n\tassert.Contains(t, headerBlock.Text.Text, \"quite the header\")\n}\n"
        },
        {
          "name": "block_image.go",
          "type": "blob",
          "size": 1.1982421875,
          "content": "package slack\n\n// ImageBlock defines data required to display an image as a block element\n//\n// More Information: https://api.slack.com/reference/messaging/blocks#image\ntype ImageBlock struct {\n\tType      MessageBlockType `json:\"type\"`\n\tImageURL  string           `json:\"image_url,omitempty\"`\n\tAltText   string           `json:\"alt_text\"`\n\tBlockID   string           `json:\"block_id,omitempty\"`\n\tTitle     *TextBlockObject `json:\"title,omitempty\"`\n\tSlackFile *SlackFileObject `json:\"slack_file,omitempty\"`\n}\n\n// SlackFileObject Defines an object containing Slack file information to be used in an\n// image block or image element.\n//\n// More Information: https://api.slack.com/reference/block-kit/composition-objects#slack_file\ntype SlackFileObject struct {\n\tID  string `json:\"id,omitempty\"`\n\tURL string `json:\"url,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (s ImageBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewImageBlock returns an instance of a new Image Block type\nfunc NewImageBlock(imageURL, altText, blockID string, title *TextBlockObject) *ImageBlock {\n\treturn &ImageBlock{\n\t\tType:     MBTImage,\n\t\tImageURL: imageURL,\n\t\tAltText:  altText,\n\t\tBlockID:  blockID,\n\t\tTitle:    title,\n\t}\n}\n"
        },
        {
          "name": "block_image_test.go",
          "type": "blob",
          "size": 0.5986328125,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewImageBlock(t *testing.T) {\n\n\timageText := NewTextBlockObject(\"plain_text\", \"Location\", false, false)\n\timageBlock := NewImageBlock(\"https://api.slack.com/img/blocks/bkb_template_images/tripAgentLocationMarker.png\", \"Marker\", \"test\", imageText)\n\n\tassert.Equal(t, string(imageBlock.Type), \"image\")\n\tassert.Equal(t, imageBlock.Title.Type, \"plain_text\")\n\tassert.Equal(t, imageBlock.BlockID, \"test\")\n\tassert.Contains(t, imageBlock.Title.Text, \"Location\")\n\tassert.Contains(t, imageBlock.ImageURL, \"tripAgentLocationMarker.png\")\n\n}\n"
        },
        {
          "name": "block_input.go",
          "type": "blob",
          "size": 1.296875,
          "content": "package slack\n\n// InputBlock defines data that is used to display user input fields.\n//\n// More Information: https://api.slack.com/reference/block-kit/blocks#input\ntype InputBlock struct {\n\tType           MessageBlockType `json:\"type\"`\n\tBlockID        string           `json:\"block_id,omitempty\"`\n\tLabel          *TextBlockObject `json:\"label\"`\n\tElement        BlockElement     `json:\"element\"`\n\tHint           *TextBlockObject `json:\"hint,omitempty\"`\n\tOptional       bool             `json:\"optional,omitempty\"`\n\tDispatchAction bool             `json:\"dispatch_action,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (s InputBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewInputBlock returns a new instance of an input block\nfunc NewInputBlock(blockID string, label, hint *TextBlockObject, element BlockElement) *InputBlock {\n\treturn &InputBlock{\n\t\tType:    MBTInput,\n\t\tBlockID: blockID,\n\t\tLabel:   label,\n\t\tElement: element,\n\t\tHint:    hint,\n\t}\n}\n\n// WithOptional sets the optional flag on the input block\nfunc (s *InputBlock) WithOptional(optional bool) *InputBlock {\n\ts.Optional = optional\n\treturn s\n}\n\n// WithDispatchAction sets the dispatch action flag on the input block\nfunc (s *InputBlock) WithDispatchAction(dispatchAction bool) *InputBlock {\n\ts.DispatchAction = dispatchAction\n\treturn s\n}\n"
        },
        {
          "name": "block_input_test.go",
          "type": "blob",
          "size": 0.529296875,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewInputBlock(t *testing.T) {\n\tlabel := NewTextBlockObject(\"plain_text\", \"label\", false, false)\n\telement := NewDatePickerBlockElement(\"action_id\")\n\thint := NewTextBlockObject(\"plain_text\", \"hint\", false, false)\n\tinputBlock := NewInputBlock(\"test\", label, hint, element)\n\tassert.Equal(t, string(inputBlock.Type), \"input\")\n\tassert.Equal(t, inputBlock.BlockID, \"test\")\n\tassert.Equal(t, inputBlock.Label, label)\n\tassert.Equal(t, inputBlock.Element, element)\n}\n"
        },
        {
          "name": "block_object.go",
          "type": "blob",
          "size": 7.529296875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\n// Block Objects are also known as Composition Objects\n//\n// For more information: https://api.slack.com/reference/messaging/composition-objects\n\n// BlockObject defines an interface that all block object types should\n// implement.\n// @TODO: Is this interface needed?\n\n// blockObject object types\nconst (\n\tMarkdownType  = \"mrkdwn\"\n\tPlainTextType = \"plain_text\"\n\t// The following objects don't actually have types and their corresponding\n\t// const values are just for internal use\n\tmotConfirmation = \"confirm\"\n\tmotOption       = \"option\"\n\tmotOptionGroup  = \"option_group\"\n)\n\ntype MessageObjectType string\n\ntype blockObject interface {\n\tvalidateType() MessageObjectType\n}\n\ntype BlockObjects struct {\n\tTextObjects         []*TextBlockObject\n\tConfirmationObjects []*ConfirmationBlockObject\n\tOptionObjects       []*OptionBlockObject\n\tOptionGroupObjects  []*OptionGroupBlockObject\n}\n\n// UnmarshalJSON implements the Unmarshaller interface for BlockObjects, so that any JSON\n// unmarshalling is delegated and proper type determination can be made before unmarshal\nfunc (b *BlockObjects) UnmarshalJSON(data []byte) error {\n\tvar raw []json.RawMessage\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, r := range raw {\n\t\tvar obj map[string]interface{}\n\t\terr := json.Unmarshal(r, &obj)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tblockObjectType := getBlockObjectType(obj)\n\n\t\tswitch blockObjectType {\n\t\tcase PlainTextType, MarkdownType:\n\t\t\tobject, err := unmarshalBlockObject(r, &TextBlockObject{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tb.TextObjects = append(b.TextObjects, object.(*TextBlockObject))\n\t\tcase motConfirmation:\n\t\t\tobject, err := unmarshalBlockObject(r, &ConfirmationBlockObject{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tb.ConfirmationObjects = append(b.ConfirmationObjects, object.(*ConfirmationBlockObject))\n\t\tcase motOption:\n\t\t\tobject, err := unmarshalBlockObject(r, &OptionBlockObject{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tb.OptionObjects = append(b.OptionObjects, object.(*OptionBlockObject))\n\t\tcase motOptionGroup:\n\t\t\tobject, err := unmarshalBlockObject(r, &OptionGroupBlockObject{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tb.OptionGroupObjects = append(b.OptionGroupObjects, object.(*OptionGroupBlockObject))\n\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Ideally would have a better way to identify the block objects for\n// type casting at time of unmarshalling, should be adapted if possible\n// to accomplish in a more reliable manner.\nfunc getBlockObjectType(obj map[string]interface{}) string {\n\tif t, ok := obj[\"type\"].(string); ok {\n\t\treturn t\n\t}\n\tif _, ok := obj[\"confirm\"].(string); ok {\n\t\treturn \"confirm\"\n\t}\n\tif _, ok := obj[\"options\"].(string); ok {\n\t\treturn \"option_group\"\n\t}\n\tif _, ok := obj[\"text\"].(string); ok {\n\t\tif _, ok := obj[\"value\"].(string); ok {\n\t\t\treturn \"option\"\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc unmarshalBlockObject(r json.RawMessage, object blockObject) (blockObject, error) {\n\terr := json.Unmarshal(r, object)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn object, nil\n}\n\n// TextBlockObject defines a text element object to be used with blocks\n//\n// More Information: https://api.slack.com/reference/messaging/composition-objects#text\ntype TextBlockObject struct {\n\tType     string `json:\"type\"`\n\tText     string `json:\"text\"`\n\tEmoji    bool   `json:\"emoji,omitempty\"`\n\tVerbatim bool   `json:\"verbatim,omitempty\"`\n}\n\n// validateType enforces block objects for element and block parameters\nfunc (s TextBlockObject) validateType() MessageObjectType {\n\treturn MessageObjectType(s.Type)\n}\n\n// validateType enforces block objects for element and block parameters\nfunc (s TextBlockObject) MixedElementType() MixedElementType {\n\treturn MixedElementText\n}\n\n// Validate checks if TextBlockObject has valid values\nfunc (s TextBlockObject) Validate() error {\n\tif s.Type != \"plain_text\" && s.Type != \"mrkdwn\" {\n\t\treturn errors.New(\"type must be either of plain_text or mrkdwn\")\n\t}\n\n\t// https://github.com/slack-go/slack/issues/881\n\tif s.Type == \"mrkdwn\" && s.Emoji {\n\t\treturn errors.New(\"emoji cannot be true in mrkdown\")\n\t}\n\n\t// https://api.slack.com/reference/block-kit/composition-objects#text__fields\n\tif len(s.Text) == 0 {\n\t\treturn errors.New(\"text must have a minimum length of 1\")\n\t}\n\n\t// https://api.slack.com/reference/block-kit/composition-objects#text__fields\n\tif len(s.Text) > 3000 {\n\t\treturn errors.New(\"text cannot be longer than 3000 characters\")\n\t}\n\n\treturn nil\n}\n\n// NewTextBlockObject returns an instance of a new Text Block Object\nfunc NewTextBlockObject(elementType, text string, emoji, verbatim bool) *TextBlockObject {\n\treturn &TextBlockObject{\n\t\tType:     elementType,\n\t\tText:     text,\n\t\tEmoji:    emoji,\n\t\tVerbatim: verbatim,\n\t}\n}\n\n// BlockType returns the type of the block\nfunc (t TextBlockObject) BlockType() MessageBlockType {\n\tif t.Type == \"mrkdwn\" {\n\t\treturn MarkdownType\n\t}\n\treturn PlainTextType\n}\n\n// ConfirmationBlockObject defines a dialog that provides a confirmation step to\n// any interactive element. This dialog will ask the user to confirm their action by\n// offering a confirm and deny buttons.\n//\n// More Information: https://api.slack.com/reference/messaging/composition-objects#confirm\ntype ConfirmationBlockObject struct {\n\tTitle   *TextBlockObject `json:\"title\"`\n\tText    *TextBlockObject `json:\"text\"`\n\tConfirm *TextBlockObject `json:\"confirm\"`\n\tDeny    *TextBlockObject `json:\"deny,omitempty\"`\n\tStyle   Style            `json:\"style,omitempty\"`\n}\n\n// validateType enforces block objects for element and block parameters\nfunc (s ConfirmationBlockObject) validateType() MessageObjectType {\n\treturn motConfirmation\n}\n\n// WithStyle add styling to confirmation object\nfunc (s *ConfirmationBlockObject) WithStyle(style Style) *ConfirmationBlockObject {\n\ts.Style = style\n\treturn s\n}\n\n// NewConfirmationBlockObject returns an instance of a new Confirmation Block Object\nfunc NewConfirmationBlockObject(title, text, confirm, deny *TextBlockObject) *ConfirmationBlockObject {\n\treturn &ConfirmationBlockObject{\n\t\tTitle:   title,\n\t\tText:    text,\n\t\tConfirm: confirm,\n\t\tDeny:    deny,\n\t}\n}\n\n// OptionBlockObject represents a single selectable item in a select menu\n//\n// More Information: https://api.slack.com/reference/messaging/composition-objects#option\ntype OptionBlockObject struct {\n\tText        *TextBlockObject `json:\"text\"`\n\tValue       string           `json:\"value\"`\n\tDescription *TextBlockObject `json:\"description,omitempty\"`\n\tURL         string           `json:\"url,omitempty\"`\n}\n\n// NewOptionBlockObject returns an instance of a new Option Block Element\nfunc NewOptionBlockObject(value string, text, description *TextBlockObject) *OptionBlockObject {\n\treturn &OptionBlockObject{\n\t\tText:        text,\n\t\tValue:       value,\n\t\tDescription: description,\n\t}\n}\n\n// validateType enforces block objects for element and block parameters\nfunc (s OptionBlockObject) validateType() MessageObjectType {\n\treturn motOption\n}\n\n// OptionGroupBlockObject Provides a way to group options in a select menu.\n//\n// More Information: https://api.slack.com/reference/messaging/composition-objects#option-group\ntype OptionGroupBlockObject struct {\n\tLabel   *TextBlockObject     `json:\"label,omitempty\"`\n\tOptions []*OptionBlockObject `json:\"options\"`\n}\n\n// validateType enforces block objects for element and block parameters\nfunc (s OptionGroupBlockObject) validateType() MessageObjectType {\n\treturn motOptionGroup\n}\n\n// NewOptionGroupBlockElement returns an instance of a new option group block element\nfunc NewOptionGroupBlockElement(label *TextBlockObject, options ...*OptionBlockObject) *OptionGroupBlockObject {\n\treturn &OptionGroupBlockObject{\n\t\tLabel:   label,\n\t\tOptions: options,\n\t}\n}\n"
        },
        {
          "name": "block_object_test.go",
          "type": "blob",
          "size": 4.1484375,
          "content": "package slack\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewImageBlockObject(t *testing.T) {\n\n\timageObject := NewImageBlockElement(\"https://api.slack.com/img/blocks/bkb_template_images/beagle.png\", \"Beagle\")\n\n\tassert.Equal(t, string(imageObject.Type), \"image\")\n\tassert.Equal(t, imageObject.AltText, \"Beagle\")\n\tassert.Contains(t, imageObject.ImageURL, \"beagle.png\")\n\n}\n\nfunc TestNewTextBlockObject(t *testing.T) {\n\n\ttextObject := NewTextBlockObject(\"plain_text\", \"test\", true, false)\n\n\tassert.Equal(t, textObject.Type, \"plain_text\")\n\tassert.Equal(t, textObject.Text, \"test\")\n\tassert.True(t, textObject.Emoji, \"Emoji property should be true\")\n\tassert.False(t, textObject.Verbatim, \"Verbatim should be false\")\n\n}\n\nfunc TestNewConfirmationBlockObject(t *testing.T) {\n\n\ttitleObj := NewTextBlockObject(\"plain_text\", \"testTitle\", false, false)\n\ttextObj := NewTextBlockObject(\"plain_text\", \"testText\", false, false)\n\tconfirmObj := NewTextBlockObject(\"plain_text\", \"testConfirm\", false, false)\n\n\tconfirmation := NewConfirmationBlockObject(titleObj, textObj, confirmObj, nil)\n\n\tassert.Equal(t, confirmation.Title.Text, \"testTitle\")\n\tassert.Equal(t, confirmation.Text.Text, \"testText\")\n\tassert.Equal(t, confirmation.Confirm.Text, \"testConfirm\")\n\tassert.Nil(t, confirmation.Deny, \"Deny should be nil\")\n\n}\n\nfunc TestWithStyleForConfirmation(t *testing.T) {\n\n\t// these values are irrelevant in this test\n\ttitleObj := NewTextBlockObject(\"plain_text\", \"testTitle\", false, false)\n\ttextObj := NewTextBlockObject(\"plain_text\", \"testText\", false, false)\n\tconfirmObj := NewTextBlockObject(\"plain_text\", \"testConfirm\", false, false)\n\tconfirmation := NewConfirmationBlockObject(titleObj, textObj, confirmObj, nil)\n\n\tconfirmation.WithStyle(StyleDefault)\n\tassert.Equal(t, confirmation.Style, Style(\"\"))\n\tconfirmation.WithStyle(StylePrimary)\n\tassert.Equal(t, confirmation.Style, Style(\"primary\"))\n\tconfirmation.WithStyle(StyleDanger)\n\tassert.Equal(t, confirmation.Style, Style(\"danger\"))\n\n}\n\nfunc TestNewOptionBlockObject(t *testing.T) {\n\n\tvalTextObj := NewTextBlockObject(\"plain_text\", \"testText\", false, false)\n\tvalDescriptionObj := NewTextBlockObject(\"plain_text\", \"testDescription\", false, false)\n\toptObj := NewOptionBlockObject(\"testOpt\", valTextObj, valDescriptionObj)\n\n\tassert.Equal(t, optObj.Text.Text, \"testText\")\n\tassert.Equal(t, optObj.Description.Text, \"testDescription\")\n\tassert.Equal(t, optObj.Value, \"testOpt\")\n\n}\n\nfunc TestNewOptionGroupBlockElement(t *testing.T) {\n\n\tlabelObj := NewTextBlockObject(\"plain_text\", \"testLabel\", false, false)\n\tvalTextObj := NewTextBlockObject(\"plain_text\", \"testText\", false, false)\n\toptObj := NewOptionBlockObject(\"testOpt\", valTextObj, nil)\n\n\toptGroup := NewOptionGroupBlockElement(labelObj, optObj)\n\n\tassert.Equal(t, optGroup.Label.Text, \"testLabel\")\n\tassert.Len(t, optGroup.Options, 1, \"Options should contain one element\")\n\n}\n\nfunc TestValidateTextBlockObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    TextBlockObject\n\t\texpected error\n\t}{\n\t\t{\n\t\t\tinput: TextBlockObject{\n\t\t\t\tType:     \"plain_text\",\n\t\t\t\tText:     \"testText\",\n\t\t\t\tEmoji:    false,\n\t\t\t\tVerbatim: false,\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tinput: TextBlockObject{\n\t\t\t\tType:     \"mrkdwn\",\n\t\t\t\tText:     \"testText\",\n\t\t\t\tEmoji:    false,\n\t\t\t\tVerbatim: false,\n\t\t\t},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tinput: TextBlockObject{\n\t\t\t\tType:     \"invalid\",\n\t\t\t\tText:     \"testText\",\n\t\t\t\tEmoji:    false,\n\t\t\t\tVerbatim: false,\n\t\t\t},\n\t\t\texpected: errors.New(\"type must be either of plain_text or mrkdwn\"),\n\t\t},\n\t\t{\n\t\t\tinput: TextBlockObject{\n\t\t\t\tType:     \"mrkdwn\",\n\t\t\t\tText:     \"testText\",\n\t\t\t\tEmoji:    true,\n\t\t\t\tVerbatim: false,\n\t\t\t},\n\t\t\texpected: errors.New(\"emoji cannot be true in mrkdown\"),\n\t\t},\n\t\t{\n\t\t\tinput: TextBlockObject{\n\t\t\t\tType:     \"mrkdwn\",\n\t\t\t\tText:     \"\",\n\t\t\t\tEmoji:    false,\n\t\t\t\tVerbatim: false,\n\t\t\t},\n\t\t\texpected: errors.New(\"text must have a minimum length of 1\"),\n\t\t},\n\t\t{\n\t\t\tinput: TextBlockObject{\n\t\t\t\tType:     \"mrkdwn\",\n\t\t\t\tText:     strings.Repeat(\"a\", 3001),\n\t\t\t\tEmoji:    false,\n\t\t\t\tVerbatim: false,\n\t\t\t},\n\t\t\texpected: errors.New(\"text cannot be longer than 3000 characters\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\terr := test.input.Validate()\n\t\tassert.Equal(t, err, test.expected)\n\t}\n}\n"
        },
        {
          "name": "block_rich_text.go",
          "type": "blob",
          "size": 14.455078125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n)\n\n// RichTextBlock defines a new block of type rich_text.\n// More Information: https://api.slack.com/changelog/2019-09-what-they-see-is-what-you-get-and-more-and-less\ntype RichTextBlock struct {\n\tType     MessageBlockType  `json:\"type\"`\n\tBlockID  string            `json:\"block_id,omitempty\"`\n\tElements []RichTextElement `json:\"elements\"`\n}\n\nfunc (b RichTextBlock) BlockType() MessageBlockType {\n\treturn b.Type\n}\n\nfunc (e *RichTextBlock) UnmarshalJSON(b []byte) error {\n\tvar raw struct {\n\t\tType        MessageBlockType  `json:\"type\"`\n\t\tBlockID     string            `json:\"block_id\"`\n\t\tRawElements []json.RawMessage `json:\"elements\"`\n\t}\n\tif string(b) == \"{}\" {\n\t\treturn nil\n\t}\n\tif err := json.Unmarshal(b, &raw); err != nil {\n\t\treturn err\n\t}\n\telems := make([]RichTextElement, 0, len(raw.RawElements))\n\tfor _, r := range raw.RawElements {\n\t\tvar s struct {\n\t\t\tType RichTextElementType `json:\"type\"`\n\t\t}\n\t\tif err := json.Unmarshal(r, &s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar elem RichTextElement\n\t\tswitch s.Type {\n\t\tcase RTESection:\n\t\t\telem = &RichTextSection{}\n\t\tcase RTEList:\n\t\t\telem = &RichTextList{}\n\t\tcase RTEQuote:\n\t\t\telem = &RichTextQuote{}\n\t\tcase RTEPreformatted:\n\t\t\telem = &RichTextPreformatted{}\n\t\tdefault:\n\t\t\telems = append(elems, &RichTextUnknown{\n\t\t\t\tType: s.Type,\n\t\t\t\tRaw:  string(r),\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tif err := json.Unmarshal(r, &elem); err != nil {\n\t\t\treturn err\n\t\t}\n\t\telems = append(elems, elem)\n\t}\n\t*e = RichTextBlock{\n\t\tType:     raw.Type,\n\t\tBlockID:  raw.BlockID,\n\t\tElements: elems,\n\t}\n\treturn nil\n}\n\n// NewRichTextBlock returns a new instance of RichText Block.\nfunc NewRichTextBlock(blockID string, elements ...RichTextElement) *RichTextBlock {\n\treturn &RichTextBlock{\n\t\tType:     MBTRichText,\n\t\tBlockID:  blockID,\n\t\tElements: elements,\n\t}\n}\n\ntype RichTextElementType string\n\ntype RichTextElement interface {\n\tRichTextElementType() RichTextElementType\n}\n\nconst (\n\tRTEList         RichTextElementType = \"rich_text_list\"\n\tRTEPreformatted RichTextElementType = \"rich_text_preformatted\"\n\tRTEQuote        RichTextElementType = \"rich_text_quote\"\n\tRTESection      RichTextElementType = \"rich_text_section\"\n\tRTEUnknown      RichTextElementType = \"rich_text_unknown\"\n)\n\ntype RichTextUnknown struct {\n\tType RichTextElementType\n\tRaw  string\n}\n\nfunc (u RichTextUnknown) RichTextElementType() RichTextElementType {\n\treturn u.Type\n}\n\ntype RichTextListElementType string\n\nconst (\n\tRTEListOrdered RichTextListElementType = \"ordered\"\n\tRTEListBullet  RichTextListElementType = \"bullet\"\n)\n\ntype RichTextList struct {\n\tType     RichTextElementType     `json:\"type\"`\n\tElements []RichTextElement       `json:\"elements\"`\n\tStyle    RichTextListElementType `json:\"style\"`\n\tIndent   int                     `json:\"indent\"`\n}\n\n// NewRichTextList returns a new rich text list element.\nfunc NewRichTextList(style RichTextListElementType, indent int, elements ...RichTextElement) *RichTextList {\n\treturn &RichTextList{\n\t\tType:     RTEList,\n\t\tElements: elements,\n\t\tStyle:    style,\n\t\tIndent:   indent,\n\t}\n}\n\n// ElementType returns the type of the Element\nfunc (s RichTextList) RichTextElementType() RichTextElementType {\n\treturn s.Type\n}\n\nfunc (e *RichTextList) UnmarshalJSON(b []byte) error {\n\tvar raw struct {\n\t\tRawElements []json.RawMessage       `json:\"elements\"`\n\t\tStyle       RichTextListElementType `json:\"style\"`\n\t\tIndent      int                     `json:\"indent\"`\n\t}\n\tif string(b) == \"{}\" {\n\t\treturn nil\n\t}\n\tif err := json.Unmarshal(b, &raw); err != nil {\n\t\treturn err\n\t}\n\telems := make([]RichTextElement, 0, len(raw.RawElements))\n\tfor _, r := range raw.RawElements {\n\t\tvar s struct {\n\t\t\tType RichTextElementType `json:\"type\"`\n\t\t}\n\t\tif err := json.Unmarshal(r, &s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar elem RichTextElement\n\t\tswitch s.Type {\n\t\tcase RTESection:\n\t\t\telem = &RichTextSection{}\n\t\tcase RTEList:\n\t\t\telem = &RichTextList{}\n\t\tcase RTEQuote:\n\t\t\telem = &RichTextQuote{}\n\t\tcase RTEPreformatted:\n\t\t\telem = &RichTextPreformatted{}\n\t\tdefault:\n\t\t\telems = append(elems, &RichTextUnknown{\n\t\t\t\tType: s.Type,\n\t\t\t\tRaw:  string(r),\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tif err := json.Unmarshal(r, elem); err != nil {\n\t\t\treturn err\n\t\t}\n\t\telems = append(elems, elem)\n\t}\n\t*e = RichTextList{\n\t\tType:     RTEList,\n\t\tElements: elems,\n\t\tStyle:    raw.Style,\n\t\tIndent:   raw.Indent,\n\t}\n\treturn nil\n}\n\ntype RichTextSection struct {\n\tType     RichTextElementType      `json:\"type\"`\n\tElements []RichTextSectionElement `json:\"elements\"`\n}\n\n// RichTextElementType returns the type of the Element\nfunc (s RichTextSection) RichTextElementType() RichTextElementType {\n\treturn s.Type\n}\n\nfunc (e *RichTextSection) UnmarshalJSON(b []byte) error {\n\tvar raw struct {\n\t\tRawElements []json.RawMessage `json:\"elements\"`\n\t}\n\tif string(b) == \"{}\" {\n\t\treturn nil\n\t}\n\tif err := json.Unmarshal(b, &raw); err != nil {\n\t\treturn err\n\t}\n\telems := make([]RichTextSectionElement, 0, len(raw.RawElements))\n\tfor _, r := range raw.RawElements {\n\t\tvar s struct {\n\t\t\tType RichTextSectionElementType `json:\"type\"`\n\t\t}\n\t\tif err := json.Unmarshal(r, &s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar elem RichTextSectionElement\n\t\tswitch s.Type {\n\t\tcase RTSEText:\n\t\t\telem = &RichTextSectionTextElement{}\n\t\tcase RTSEChannel:\n\t\t\telem = &RichTextSectionChannelElement{}\n\t\tcase RTSEUser:\n\t\t\telem = &RichTextSectionUserElement{}\n\t\tcase RTSEEmoji:\n\t\t\telem = &RichTextSectionEmojiElement{}\n\t\tcase RTSELink:\n\t\t\telem = &RichTextSectionLinkElement{}\n\t\tcase RTSETeam:\n\t\t\telem = &RichTextSectionTeamElement{}\n\t\tcase RTSEUserGroup:\n\t\t\telem = &RichTextSectionUserGroupElement{}\n\t\tcase RTSEDate:\n\t\t\telem = &RichTextSectionDateElement{}\n\t\tcase RTSEBroadcast:\n\t\t\telem = &RichTextSectionBroadcastElement{}\n\t\tcase RTSEColor:\n\t\t\telem = &RichTextSectionColorElement{}\n\t\tdefault:\n\t\t\telems = append(elems, &RichTextSectionUnknownElement{\n\t\t\t\tType: s.Type,\n\t\t\t\tRaw:  string(r),\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\tif err := json.Unmarshal(r, elem); err != nil {\n\t\t\treturn err\n\t\t}\n\t\telems = append(elems, elem)\n\t}\n\t*e = RichTextSection{\n\t\tType:     RTESection,\n\t\tElements: elems,\n\t}\n\treturn nil\n}\n\n// NewRichTextSectionBlockElement .\nfunc NewRichTextSection(elements ...RichTextSectionElement) *RichTextSection {\n\treturn &RichTextSection{\n\t\tType:     RTESection,\n\t\tElements: elements,\n\t}\n}\n\ntype RichTextSectionElementType string\n\nconst (\n\tRTSEBroadcast RichTextSectionElementType = \"broadcast\"\n\tRTSEChannel   RichTextSectionElementType = \"channel\"\n\tRTSEColor     RichTextSectionElementType = \"color\"\n\tRTSEDate      RichTextSectionElementType = \"date\"\n\tRTSEEmoji     RichTextSectionElementType = \"emoji\"\n\tRTSELink      RichTextSectionElementType = \"link\"\n\tRTSETeam      RichTextSectionElementType = \"team\"\n\tRTSEText      RichTextSectionElementType = \"text\"\n\tRTSEUser      RichTextSectionElementType = \"user\"\n\tRTSEUserGroup RichTextSectionElementType = \"usergroup\"\n\n\tRTSEUnknown RichTextSectionElementType = \"unknown\"\n)\n\ntype RichTextSectionElement interface {\n\tRichTextSectionElementType() RichTextSectionElementType\n}\n\ntype RichTextSectionTextStyle struct {\n\tBold   bool `json:\"bold,omitempty\"`\n\tItalic bool `json:\"italic,omitempty\"`\n\tStrike bool `json:\"strike,omitempty\"`\n\tCode   bool `json:\"code,omitempty\"`\n}\n\ntype RichTextSectionTextElement struct {\n\tType  RichTextSectionElementType `json:\"type\"`\n\tText  string                     `json:\"text\"`\n\tStyle *RichTextSectionTextStyle  `json:\"style,omitempty\"`\n}\n\nfunc (r RichTextSectionTextElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionTextElement(text string, style *RichTextSectionTextStyle) *RichTextSectionTextElement {\n\treturn &RichTextSectionTextElement{\n\t\tType:  RTSEText,\n\t\tText:  text,\n\t\tStyle: style,\n\t}\n}\n\ntype RichTextSectionChannelElement struct {\n\tType      RichTextSectionElementType `json:\"type\"`\n\tChannelID string                     `json:\"channel_id\"`\n\tStyle     *RichTextSectionTextStyle  `json:\"style,omitempty\"`\n}\n\nfunc (r RichTextSectionChannelElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionChannelElement(channelID string, style *RichTextSectionTextStyle) *RichTextSectionChannelElement {\n\treturn &RichTextSectionChannelElement{\n\t\tType:      RTSEText,\n\t\tChannelID: channelID,\n\t\tStyle:     style,\n\t}\n}\n\ntype RichTextSectionUserElement struct {\n\tType   RichTextSectionElementType `json:\"type\"`\n\tUserID string                     `json:\"user_id\"`\n\tStyle  *RichTextSectionTextStyle  `json:\"style,omitempty\"`\n}\n\nfunc (r RichTextSectionUserElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionUserElement(userID string, style *RichTextSectionTextStyle) *RichTextSectionUserElement {\n\treturn &RichTextSectionUserElement{\n\t\tType:   RTSEUser,\n\t\tUserID: userID,\n\t\tStyle:  style,\n\t}\n}\n\ntype RichTextSectionEmojiElement struct {\n\tType     RichTextSectionElementType `json:\"type\"`\n\tName     string                     `json:\"name\"`\n\tSkinTone int                        `json:\"skin_tone,omitempty\"`\n\tUnicode  string                     `json:\"unicode,omitempty\"`\n\tStyle    *RichTextSectionTextStyle  `json:\"style,omitempty\"`\n}\n\nfunc (r RichTextSectionEmojiElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionEmojiElement(name string, skinTone int, style *RichTextSectionTextStyle) *RichTextSectionEmojiElement {\n\treturn &RichTextSectionEmojiElement{\n\t\tType:     RTSEEmoji,\n\t\tName:     name,\n\t\tSkinTone: skinTone,\n\t\tStyle:    style,\n\t}\n}\n\ntype RichTextSectionLinkElement struct {\n\tType  RichTextSectionElementType `json:\"type\"`\n\tURL   string                     `json:\"url\"`\n\tText  string                     `json:\"text\"`\n\tStyle *RichTextSectionTextStyle  `json:\"style,omitempty\"`\n}\n\nfunc (r RichTextSectionLinkElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionLinkElement(url, text string, style *RichTextSectionTextStyle) *RichTextSectionLinkElement {\n\treturn &RichTextSectionLinkElement{\n\t\tType:  RTSELink,\n\t\tURL:   url,\n\t\tText:  text,\n\t\tStyle: style,\n\t}\n}\n\ntype RichTextSectionTeamElement struct {\n\tType   RichTextSectionElementType `json:\"type\"`\n\tTeamID string                     `json:\"team_id\"`\n\tStyle  *RichTextSectionTextStyle  `json:\"style,omitempty\"`\n}\n\nfunc (r RichTextSectionTeamElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionTeamElement(teamID string, style *RichTextSectionTextStyle) *RichTextSectionTeamElement {\n\treturn &RichTextSectionTeamElement{\n\t\tType:   RTSETeam,\n\t\tTeamID: teamID,\n\t\tStyle:  style,\n\t}\n}\n\ntype RichTextSectionUserGroupElement struct {\n\tType        RichTextSectionElementType `json:\"type\"`\n\tUsergroupID string                     `json:\"usergroup_id\"`\n}\n\nfunc (r RichTextSectionUserGroupElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionUserGroupElement(usergroupID string) *RichTextSectionUserGroupElement {\n\treturn &RichTextSectionUserGroupElement{\n\t\tType:        RTSEUserGroup,\n\t\tUsergroupID: usergroupID,\n\t}\n}\n\ntype RichTextSectionDateElement struct {\n\tType      RichTextSectionElementType `json:\"type\"`\n\tTimestamp JSONTime                   `json:\"timestamp\"`\n\tFormat    string                     `json:\"format\"`\n\tURL       *string                    `json:\"url,omitempty\"`\n\tFallback  *string                    `json:\"fallback,omitempty\"`\n}\n\nfunc (r RichTextSectionDateElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionDateElement(timestamp int64, format string, url *string, fallback *string) *RichTextSectionDateElement {\n\treturn &RichTextSectionDateElement{\n\t\tType:      RTSEDate,\n\t\tTimestamp: JSONTime(timestamp),\n\t\tFormat:    format,\n\t\tURL:       url,\n\t\tFallback:  fallback,\n\t}\n}\n\ntype RichTextSectionBroadcastElement struct {\n\tType  RichTextSectionElementType `json:\"type\"`\n\tRange string                     `json:\"range\"`\n}\n\nfunc (r RichTextSectionBroadcastElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionBroadcastElement(rangeStr string) *RichTextSectionBroadcastElement {\n\treturn &RichTextSectionBroadcastElement{\n\t\tType:  RTSEBroadcast,\n\t\tRange: rangeStr,\n\t}\n}\n\ntype RichTextSectionColorElement struct {\n\tType  RichTextSectionElementType `json:\"type\"`\n\tValue string                     `json:\"value\"`\n}\n\nfunc (r RichTextSectionColorElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\nfunc NewRichTextSectionColorElement(value string) *RichTextSectionColorElement {\n\treturn &RichTextSectionColorElement{\n\t\tType:  RTSEColor,\n\t\tValue: value,\n\t}\n}\n\ntype RichTextSectionUnknownElement struct {\n\tType RichTextSectionElementType `json:\"type\"`\n\tRaw  string\n}\n\nfunc (r RichTextSectionUnknownElement) RichTextSectionElementType() RichTextSectionElementType {\n\treturn r.Type\n}\n\n// RichTextQuote represents rich_text_quote element type.\ntype RichTextQuote RichTextSection\n\n// RichTextElementType returns the type of the Element\nfunc (s *RichTextQuote) RichTextElementType() RichTextElementType {\n\treturn s.Type\n}\n\nfunc (s *RichTextQuote) UnmarshalJSON(b []byte) error {\n\t// reusing the RichTextSection struct, as it's the same as RichTextQuote.\n\tvar rts RichTextSection\n\tif err := json.Unmarshal(b, &rts); err != nil {\n\t\treturn err\n\t}\n\t*s = RichTextQuote(rts)\n\ts.Type = RTEQuote\n\treturn nil\n}\n\n// RichTextPreformatted represents rich_text_quote element type.\ntype RichTextPreformatted struct {\n\tRichTextSection\n\tBorder int `json:\"border\"`\n}\n\n// RichTextElementType returns the type of the Element\nfunc (s *RichTextPreformatted) RichTextElementType() RichTextElementType {\n\treturn s.Type\n}\n\nfunc (s *RichTextPreformatted) UnmarshalJSON(b []byte) error {\n\tvar rts RichTextSection\n\tif err := json.Unmarshal(b, &rts); err != nil {\n\t\treturn err\n\t}\n\t// we define standalone fields because we need to unmarshal the border\n\t// field.  We can not directly unmarshal the data into\n\t// RichTextPreformatted because it will cause an infinite loop.  We also\n\t// can not define a struct with embedded RichTextSection and Border fields\n\t// because the json package will not unmarshal the data into the\n\t// standalone fields, once it sees UnmarshalJSON method on the embedded\n\t// struct.  The drawback is that we have to process the data twice, and\n\t// have to define a standalone struct with the same set of fields as the\n\t// original struct, which may become a maintenance burden (i.e. update the\n\t// fields in two places, should it ever change).\n\tvar standalone struct {\n\t\tBorder int `json:\"border\"`\n\t}\n\tif err := json.Unmarshal(b, &standalone); err != nil {\n\t\treturn err\n\t}\n\t*s = RichTextPreformatted{\n\t\tRichTextSection: rts,\n\t\tBorder:          standalone.Border,\n\t}\n\ts.Type = RTEPreformatted\n\treturn nil\n}\n"
        },
        {
          "name": "block_rich_text_test.go",
          "type": "blob",
          "size": 10.5751953125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/go-test/deep\"\n)\n\nconst (\n\tdummyPayload = `{\n  \"type\":\"rich_text\",\n  \"block_id\":\"FaYCD\",\n  \"elements\": [\n    {\n      \"type\":\"rich_text_section\",\n      \"elements\": [\n        {\n          \"type\":\"channel\",\n          \"channel_id\":\"C012345678\"\n        },\n        {\n          \"type\":\"text\",\n          \"text\":\"dummy_text\"\n        }\n      ]\n    }\n  ]\n}`\n\n\trichTextQuotePayload = `{\n\t\t\"type\": \"rich_text\",\n\t\t\"block_id\": \"G7G\",\n\t\t\"elements\": [\n\t\t\t{\n\t\t\t\t\"type\": \"rich_text_section\",\n\t\t\t\t\"elements\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"Holy moly\\n\\n\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"type\": \"rich_text_preformatted\",\n\t\t\t\t\"elements\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"Preformatted\\n\\n\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"border\": 2\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"type\": \"rich_text_quote\",\n\t\t\t\t\"elements\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"Quote\\n\\n\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"type\": \"rich_text_quote\",\n\t\t\t\t\"elements\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"Another quote\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"type\": \"rich_text_preformatted\",\n\t\t\t\t\"elements\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\"text\": \"Another preformatted\\n\\n\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"border\": 42\n\t\t\t}\n\t\t]\n\t}`\n)\n\nfunc TestRichTextBlock_UnmarshalJSON(t *testing.T) {\n\tcases := []struct {\n\t\traw      []byte\n\t\texpected RichTextBlock\n\t\terr      error\n\t}{\n\t\t{\n\t\t\t[]byte(`{\"elements\":[{\"type\":\"rich_text_unknown\"},{\"type\":\"rich_text_section\"},{\"type\":\"rich_text_list\"}]}`),\n\t\t\tRichTextBlock{\n\t\t\t\tElements: []RichTextElement{\n\t\t\t\t\t&RichTextUnknown{Type: RTEUnknown, Raw: `{\"type\":\"rich_text_unknown\"}`},\n\t\t\t\t\t&RichTextSection{Type: RTESection, Elements: []RichTextSectionElement{}},\n\t\t\t\t\t&RichTextList{Type: RTEList, Elements: []RichTextElement{}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"type\": \"rich_text\",\"block_id\":\"blk\",\"elements\":[]}`),\n\t\t\tRichTextBlock{\n\t\t\t\tType:     MBTRichText,\n\t\t\t\tBlockID:  \"blk\",\n\t\t\t\tElements: []RichTextElement{},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(dummyPayload),\n\t\t\tRichTextBlock{\n\t\t\t\tType:    MBTRichText,\n\t\t\t\tBlockID: \"FaYCD\",\n\t\t\t\tElements: []RichTextElement{\n\t\t\t\t\t&RichTextSection{\n\t\t\t\t\t\tType: RTESection,\n\t\t\t\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t\t\t\t&RichTextSectionChannelElement{Type: RTSEChannel, ChannelID: \"C012345678\"},\n\t\t\t\t\t\t\t&RichTextSectionTextElement{Type: RTSEText, Text: \"dummy_text\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(richTextQuotePayload),\n\t\t\tRichTextBlock{\n\t\t\t\tType:    MBTRichText,\n\t\t\t\tBlockID: \"G7G\",\n\t\t\t\tElements: []RichTextElement{\n\t\t\t\t\t&RichTextSection{Type: RTESection, Elements: []RichTextSectionElement{&RichTextSectionTextElement{Type: RTSEText, Text: \"Holy moly\\n\\n\"}}},\n\t\t\t\t\t&RichTextPreformatted{RichTextSection: RichTextSection{Type: RTEPreformatted, Elements: []RichTextSectionElement{&RichTextSectionTextElement{Type: RTSEText, Text: \"Preformatted\\n\\n\"}}}, Border: 2},\n\t\t\t\t\t&RichTextQuote{Type: RTEQuote, Elements: []RichTextSectionElement{&RichTextSectionTextElement{Type: RTSEText, Text: \"Quote\\n\\n\"}}},\n\t\t\t\t\t&RichTextQuote{Type: RTEQuote, Elements: []RichTextSectionElement{&RichTextSectionTextElement{Type: RTSEText, Text: \"Another quote\"}}},\n\t\t\t\t\t&RichTextPreformatted{RichTextSection: RichTextSection{Type: RTEPreformatted, Elements: []RichTextSectionElement{&RichTextSectionTextElement{Type: RTSEText, Text: \"Another preformatted\\n\\n\"}}}, Border: 42},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tvar actual RichTextBlock\n\t\terr := json.Unmarshal(tc.raw, &actual)\n\t\tif err != nil {\n\t\t\tif tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tt.Errorf(\"expected error is %v, but got %v\", tc.err, err)\n\t\t}\n\t\tif tc.err != nil {\n\t\t\tt.Errorf(\"expected to raise an error %v\", tc.err)\n\t\t}\n\t\tif diff := deep.Equal(actual, tc.expected); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t}\n}\n\nfunc TestRichTextSection_UnmarshalJSON(t *testing.T) {\n\tcases := []struct {\n\t\traw      []byte\n\t\texpected RichTextSection\n\t\terr      error\n\t}{\n\t\t{\n\t\t\t[]byte(`{\"elements\":[{\"type\":\"unknown\",\"value\":10},{\"type\":\"text\",\"text\":\"hi\"},{\"type\":\"date\",\"timestamp\":1636961629,\"format\":\"{date_short_pretty}\"},{\"type\":\"date\",\"timestamp\":1636961629,\"format\":\"{date_short_pretty}\",\"url\":\"https://example.com\",\"fallback\":\"default\"}]}`),\n\t\t\tRichTextSection{\n\t\t\t\tType: RTESection,\n\t\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t\t&RichTextSectionUnknownElement{Type: RTSEUnknown, Raw: `{\"type\":\"unknown\",\"value\":10}`},\n\t\t\t\t\t&RichTextSectionTextElement{Type: RTSEText, Text: \"hi\"},\n\t\t\t\t\t&RichTextSectionDateElement{Type: RTSEDate, Timestamp: JSONTime(1636961629), Format: \"{date_short_pretty}\"},\n\t\t\t\t\t&RichTextSectionDateElement{Type: RTSEDate, Timestamp: JSONTime(1636961629), Format: \"{date_short_pretty}\", URL: strp(\"https://example.com\"), Fallback: strp(\"default\")},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"type\": \"rich_text_section\",\"elements\":[]}`),\n\t\t\tRichTextSection{\n\t\t\t\tType:     RTESection,\n\t\t\t\tElements: []RichTextSectionElement{},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"type\": \"rich_text_section\",\"elements\":[{\"type\": \"emoji\",\"name\": \"+1\"}]}`),\n\t\t\tRichTextSection{\n\t\t\t\tType: RTESection,\n\t\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t\t&RichTextSectionEmojiElement{Type: RTSEEmoji, Name: \"+1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"type\": \"rich_text_section\",\"elements\":[{\"type\": \"emoji\",\"name\": \"+1\",\"unicode\": \"1f44d-1f3fb\",\"skin_tone\": 2}]}`),\n\t\t\tRichTextSection{\n\t\t\t\tType: RTESection,\n\t\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t\t&RichTextSectionEmojiElement{Type: RTSEEmoji, Name: \"+1\", Unicode: \"1f44d-1f3fb\", SkinTone: 2},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tvar actual RichTextSection\n\t\terr := json.Unmarshal(tc.raw, &actual)\n\t\tif err != nil {\n\t\t\tif tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tt.Errorf(\"expected error is %s, but got %s\", tc.err, err)\n\t\t}\n\t\tif tc.err != nil {\n\t\t\tt.Errorf(\"expected to raise an error %s\", tc.err)\n\t\t}\n\t\tif diff := deep.Equal(actual, tc.expected); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t}\n}\n\nfunc TestRichTextList_UnmarshalJSON(t *testing.T) {\n\tcases := []struct {\n\t\traw      []byte\n\t\texpected RichTextList\n\t\terr      error\n\t}{\n\t\t{\n\t\t\t[]byte(`{\"style\":\"ordered\",\"elements\":[{\"type\":\"rich_text_unknown\",\"value\":10},{\"type\":\"rich_text_section\",\"elements\":[{\"type\":\"text\",\"text\":\"hi\"}]}]}`),\n\t\t\tRichTextList{\n\t\t\t\tType:  RTEList,\n\t\t\t\tStyle: RTEListOrdered,\n\t\t\t\tElements: []RichTextElement{\n\t\t\t\t\t&RichTextUnknown{Type: RTEUnknown, Raw: `{\"type\":\"rich_text_unknown\",\"value\":10}`},\n\t\t\t\t\t&RichTextSection{\n\t\t\t\t\t\tType: RTESection,\n\t\t\t\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t\t\t\t&RichTextSectionTextElement{Type: RTSEText, Text: \"hi\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"style\":\"ordered\",\"elements\":[{\"type\":\"rich_text_list\",\"style\":\"bullet\",\"elements\":[{\"type\":\"rich_text_section\",\"elements\":[{\"type\":\"text\",\"text\":\"hi\"}]}]}]}`),\n\t\t\tRichTextList{\n\t\t\t\tType:  RTEList,\n\t\t\t\tStyle: RTEListOrdered,\n\t\t\t\tElements: []RichTextElement{\n\t\t\t\t\t&RichTextList{\n\t\t\t\t\t\tType:  RTEList,\n\t\t\t\t\t\tStyle: RTEListBullet,\n\t\t\t\t\t\tElements: []RichTextElement{\n\t\t\t\t\t\t\t&RichTextSection{\n\t\t\t\t\t\t\t\tType: RTESection,\n\t\t\t\t\t\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t\t\t\t\t\t&RichTextSectionTextElement{Type: RTSEText, Text: \"hi\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"type\": \"rich_text_list\",\"elements\":[]}`),\n\t\t\tRichTextList{\n\t\t\t\tType:     RTEList,\n\t\t\t\tElements: []RichTextElement{},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t[]byte(`{\"type\": \"rich_text_list\",\"elements\":[],\"indent\":2}`),\n\t\t\tRichTextList{\n\t\t\t\tType:     RTEList,\n\t\t\t\tIndent:   2,\n\t\t\t\tElements: []RichTextElement{},\n\t\t\t},\n\t\t\tnil,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tvar actual RichTextList\n\t\terr := json.Unmarshal(tc.raw, &actual)\n\t\tif err != nil {\n\t\t\tif tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tt.Errorf(\"expected error is %s, but got %s\", tc.err, err)\n\t\t}\n\t\tif tc.err != nil {\n\t\t\tt.Errorf(\"expected to raise an error %s\", tc.err)\n\t\t}\n\t\tif diff := deep.Equal(actual, tc.expected); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t}\n}\n\nfunc TestRichTextQuote_Marshal(t *testing.T) {\n\tt.Run(\"rich_text_section\", func(t *testing.T) {\n\t\tconst rawRSE = \"{\\\"type\\\":\\\"rich_text_section\\\",\\\"elements\\\":[{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"Some Text\\\"},{\\\"type\\\":\\\"emoji\\\",\\\"name\\\":\\\"+1\\\"},{\\\"type\\\":\\\"emoji\\\",\\\"name\\\":\\\"+1\\\",\\\"skin_tone\\\":2}]}\"\n\n\t\tvar got RichTextSection\n\t\tif err := json.Unmarshal([]byte(rawRSE), &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\twant := RichTextSection{\n\t\t\tType: RTESection,\n\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t&RichTextSectionTextElement{Type: RTSEText, Text: \"Some Text\"},\n\t\t\t\t&RichTextSectionEmojiElement{Type: RTSEEmoji, Name: \"+1\"},\n\t\t\t\t&RichTextSectionEmojiElement{Type: RTSEEmoji, Name: \"+1\", SkinTone: 2},\n\t\t\t},\n\t\t}\n\n\t\tif diff := deep.Equal(got, want); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t\tb, err := json.Marshal(got)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif diff := deep.Equal(string(b), rawRSE); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t})\n\tt.Run(\"rich_text_quote\", func(t *testing.T) {\n\t\tconst rawRTS = \"{\\\"type\\\":\\\"rich_text_quote\\\",\\\"elements\\\":[{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"Some text\\\"}]}\"\n\n\t\tvar got RichTextQuote\n\t\tif err := json.Unmarshal([]byte(rawRTS), &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\twant := RichTextQuote{\n\t\t\tType: RTEQuote,\n\t\t\tElements: []RichTextSectionElement{\n\t\t\t\t&RichTextSectionTextElement{Type: RTSEText, Text: \"Some text\"},\n\t\t\t},\n\t\t}\n\t\tif diff := deep.Equal(got, want); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t\tb, err := json.Marshal(got)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif diff := deep.Equal(string(b), rawRTS); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t})\n\tt.Run(\"rich_text_preformatted\", func(t *testing.T) {\n\t\tconst rawRTP = \"{\\\"type\\\":\\\"rich_text_preformatted\\\",\\\"elements\\\":[{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"Some other text\\\"}],\\\"border\\\":2}\"\n\t\twant := RichTextPreformatted{\n\t\t\tRichTextSection: RichTextSection{\n\t\t\t\tType:     RTEPreformatted,\n\t\t\t\tElements: []RichTextSectionElement{&RichTextSectionTextElement{Type: RTSEText, Text: \"Some other text\"}},\n\t\t\t},\n\t\t\tBorder: 2,\n\t\t}\n\t\tvar got RichTextPreformatted\n\t\tif err := json.Unmarshal([]byte(rawRTP), &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif diff := deep.Equal(got, want); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t\tb, err := json.Marshal(got)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif diff := deep.Equal(string(b), rawRTP); diff != nil {\n\t\t\tt.Errorf(\"actual value does not match expected one\\n%s\", diff)\n\t\t}\n\t})\n}\n\nfunc strp(in string) *string { return &in }\n"
        },
        {
          "name": "block_section.go",
          "type": "blob",
          "size": 1.54296875,
          "content": "package slack\n\n// SectionBlock defines a new block of type section\n//\n// More Information: https://api.slack.com/reference/messaging/blocks#section\ntype SectionBlock struct {\n\tType      MessageBlockType   `json:\"type\"`\n\tText      *TextBlockObject   `json:\"text,omitempty\"`\n\tBlockID   string             `json:\"block_id,omitempty\"`\n\tFields    []*TextBlockObject `json:\"fields,omitempty\"`\n\tAccessory *Accessory         `json:\"accessory,omitempty\"`\n\tExpand    bool               `json:\"expand,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (s SectionBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// SectionBlockOption allows configuration of options for a new section block\ntype SectionBlockOption func(*SectionBlock)\n\nfunc SectionBlockOptionBlockID(blockID string) SectionBlockOption {\n\treturn func(block *SectionBlock) {\n\t\tblock.BlockID = blockID\n\t}\n}\n\n// SectionBlockOptionExpand allows long text to be auto-expanded when displaying\n//\n// @see https://api.slack.com/reference/block-kit/blocks#section\nfunc SectionBlockOptionExpand(shouldExpand bool) SectionBlockOption {\n\treturn func(block *SectionBlock) {\n\t\tblock.Expand = shouldExpand\n\t}\n}\n\n// NewSectionBlock returns a new instance of a section block to be rendered\nfunc NewSectionBlock(textObj *TextBlockObject, fields []*TextBlockObject, accessory *Accessory, options ...SectionBlockOption) *SectionBlock {\n\tblock := SectionBlock{\n\t\tType:      MBTSection,\n\t\tText:      textObj,\n\t\tFields:    fields,\n\t\tAccessory: accessory,\n\t}\n\n\tfor _, option := range options {\n\t\toption(&block)\n\t}\n\n\treturn &block\n}\n"
        },
        {
          "name": "block_section_test.go",
          "type": "blob",
          "size": 1.5068359375,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewSectionBlock(t *testing.T) {\n\n\ttextInfo := NewTextBlockObject(\"mrkdwn\", \"*<fakeLink.toHotelPage.com|The Ritz-Carlton New Orleans>*\\nâ˜…â˜…â˜…â˜…â˜…\\n$340 per night\\nRated: 9.1 - Excellent\", false, false)\n\n\tsectionBlock := NewSectionBlock(textInfo, nil, nil, SectionBlockOptionBlockID(\"test_block\"))\n\tassert.Equal(t, string(sectionBlock.Type), \"section\")\n\tassert.Equal(t, sectionBlock.BlockID, \"test_block\")\n\tassert.Equal(t, len(sectionBlock.Fields), 0)\n\tassert.Nil(t, sectionBlock.Accessory)\n\tassert.Equal(t, sectionBlock.Text.Type, \"mrkdwn\")\n\tassert.Contains(t, sectionBlock.Text.Text, \"New Orleans\")\n\n}\n\nfunc TestNewBlockSectionContainsAddedTextBlockAndAccessory(t *testing.T) {\n\ttextBlockObject := NewTextBlockObject(\"mrkdwn\", \"You have a new test: *Hi there* :wave:\", true, false)\n\tconflictImage := NewImageBlockElement(\"https://api.slack.com/img/blocks/bkb_template_images/notificationsWarningIcon.png\", \"notifications warning icon\")\n\tsectionBlock := NewSectionBlock(textBlockObject, nil, NewAccessory(conflictImage))\n\n\tassert.Equal(t, sectionBlock.BlockType(), MBTSection)\n\tassert.Equal(t, len(sectionBlock.BlockID), 0)\n\ttextBlockInSection := sectionBlock.Text\n\tassert.Equal(t, textBlockInSection.Text, textBlockObject.Text)\n\tassert.Equal(t, textBlockInSection.Type, textBlockObject.Type)\n\tassert.True(t, textBlockInSection.Emoji)\n\tassert.False(t, textBlockInSection.Verbatim)\n\tassert.Equal(t, sectionBlock.Accessory.ImageElement, conflictImage)\n}\n"
        },
        {
          "name": "block_test.go",
          "type": "blob",
          "size": 0.2578125,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewBlockMessage(t *testing.T) {\n\n\tdividerBlock := NewDividerBlock()\n\tblockMessage := NewBlockMessage(dividerBlock)\n\n\tassert.Equal(t, len(blockMessage.Msg.Blocks.BlockSet), 1)\n\n}\n"
        },
        {
          "name": "block_unknown.go",
          "type": "blob",
          "size": 0.41796875,
          "content": "package slack\n\n// UnknownBlock represents a block type that is not yet known. This block type exists to prevent Slack from introducing\n// new and unknown block types that break this library.\ntype UnknownBlock struct {\n\tType    MessageBlockType `json:\"type\"`\n\tBlockID string           `json:\"block_id,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (b UnknownBlock) BlockType() MessageBlockType {\n\treturn b.Type\n}\n"
        },
        {
          "name": "block_video.go",
          "type": "blob",
          "size": 2.1396484375,
          "content": "package slack\n\n// VideoBlock defines data required to display a video as a block element\n//\n// More Information: https://api.slack.com/reference/block-kit/blocks#video\ntype VideoBlock struct {\n\tType            MessageBlockType `json:\"type\"`\n\tVideoURL        string           `json:\"video_url\"`\n\tThumbnailURL    string           `json:\"thumbnail_url\"`\n\tAltText         string           `json:\"alt_text\"`\n\tTitle           *TextBlockObject `json:\"title\"`\n\tBlockID         string           `json:\"block_id,omitempty\"`\n\tTitleURL        string           `json:\"title_url,omitempty\"`\n\tAuthorName      string           `json:\"author_name,omitempty\"`\n\tProviderName    string           `json:\"provider_name,omitempty\"`\n\tProviderIconURL string           `json:\"provider_icon_url,omitempty\"`\n\tDescription     *TextBlockObject `json:\"description,omitempty\"`\n}\n\n// BlockType returns the type of the block\nfunc (s VideoBlock) BlockType() MessageBlockType {\n\treturn s.Type\n}\n\n// NewVideoBlock returns an instance of a new Video Block type\nfunc NewVideoBlock(videoURL, thumbnailURL, altText, blockID string, title *TextBlockObject) *VideoBlock {\n\treturn &VideoBlock{\n\t\tType:         MBTVideo,\n\t\tVideoURL:     videoURL,\n\t\tThumbnailURL: thumbnailURL,\n\t\tAltText:      altText,\n\t\tBlockID:      blockID,\n\t\tTitle:        title,\n\t}\n}\n\n// WithAuthorName sets the author name for the VideoBlock\nfunc (s *VideoBlock) WithAuthorName(authorName string) *VideoBlock {\n\ts.AuthorName = authorName\n\treturn s\n}\n\n// WithTitleURL sets the title URL for the VideoBlock\nfunc (s *VideoBlock) WithTitleURL(titleURL string) *VideoBlock {\n\ts.TitleURL = titleURL\n\treturn s\n}\n\n// WithDescription sets the description for the VideoBlock\nfunc (s *VideoBlock) WithDescription(description *TextBlockObject) *VideoBlock {\n\ts.Description = description\n\treturn s\n}\n\n// WithProviderIconURL sets the provider icon URL for the VideoBlock\nfunc (s *VideoBlock) WithProviderIconURL(providerIconURL string) *VideoBlock {\n\ts.ProviderIconURL = providerIconURL\n\treturn s\n}\n\n// WithProviderName sets the provider name for the VideoBlock\nfunc (s *VideoBlock) WithProviderName(providerName string) *VideoBlock {\n\ts.ProviderName = providerName\n\treturn s\n}\n"
        },
        {
          "name": "block_video_test.go",
          "type": "blob",
          "size": 0.599609375,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewVideoBlock(t *testing.T) {\n\n\tvideoTitle := NewTextBlockObject(\"plain_text\", \"VideoTitle\", false, false)\n\tvideoBlock := NewVideoBlock(\n\t\t\"https://example.com/example.mp4\",\n\t\t\"https://example.com/thumbnail.png\",\n\t\t\"alternative text\", \"blockID\", videoTitle)\n\n\tassert.Equal(t, string(videoBlock.Type), \"video\")\n\tassert.Equal(t, videoBlock.Title.Type, \"plain_text\")\n\tassert.Equal(t, videoBlock.BlockID, \"blockID\")\n\tassert.Contains(t, videoBlock.Title.Text, \"VideoTitle\")\n\tassert.Contains(t, videoBlock.VideoURL, \"example.mp4\")\n\n}\n"
        },
        {
          "name": "bookmarks.go",
          "type": "blob",
          "size": 5.08984375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\ntype Bookmark struct {\n\tID        string   `json:\"id\"`\n\tChannelID string   `json:\"channel_id\"`\n\tTitle     string   `json:\"title\"`\n\tLink      string   `json:\"link\"`\n\tEmoji     string   `json:\"emoji\"`\n\tIconURL   string   `json:\"icon_url\"`\n\tType      string   `json:\"type\"`\n\tCreated   JSONTime `json:\"date_created\"`\n\tUpdated   JSONTime `json:\"date_updated\"`\n\tRank      string   `json:\"rank\"`\n\n\tLastUpdatedByUserID string `json:\"last_updated_by_user_id\"`\n\tLastUpdatedByTeamID string `json:\"last_updated_by_team_id\"`\n\n\tShortcutID string `json:\"shortcut_id\"`\n\tEntityID   string `json:\"entity_id\"`\n\tAppID      string `json:\"app_id\"`\n}\n\ntype AddBookmarkParameters struct {\n\tTitle    string // A required title for the bookmark\n\tType     string // A required type for the bookmark\n\tLink     string // URL required for type:link\n\tEmoji    string // An optional emoji\n\tEntityID string\n\tParentID string\n}\n\ntype EditBookmarkParameters struct {\n\tTitle *string // Change the title. Set to \"\" to clear\n\tEmoji *string // Change the emoji. Set to \"\" to clear\n\tLink  string  // Change the link\n}\n\ntype addBookmarkResponse struct {\n\tBookmark Bookmark `json:\"bookmark\"`\n\tSlackResponse\n}\n\ntype editBookmarkResponse struct {\n\tBookmark Bookmark `json:\"bookmark\"`\n\tSlackResponse\n}\n\ntype listBookmarksResponse struct {\n\tBookmarks []Bookmark `json:\"bookmarks\"`\n\tSlackResponse\n}\n\n// AddBookmark adds a bookmark in a channel.\n// For more details, see AddBookmarkContext documentation.\nfunc (api *Client) AddBookmark(channelID string, params AddBookmarkParameters) (Bookmark, error) {\n\treturn api.AddBookmarkContext(context.Background(), channelID, params)\n}\n\n// AddBookmarkContext adds a bookmark in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/bookmarks.add\nfunc (api *Client) AddBookmarkContext(ctx context.Context, channelID string, params AddBookmarkParameters) (Bookmark, error) {\n\tvalues := url.Values{\n\t\t\"channel_id\": {channelID},\n\t\t\"token\":      {api.token},\n\t\t\"title\":      {params.Title},\n\t\t\"type\":       {params.Type},\n\t}\n\tif params.Link != \"\" {\n\t\tvalues.Set(\"link\", params.Link)\n\t}\n\tif params.Emoji != \"\" {\n\t\tvalues.Set(\"emoji\", params.Emoji)\n\t}\n\tif params.EntityID != \"\" {\n\t\tvalues.Set(\"entity_id\", params.EntityID)\n\t}\n\tif params.ParentID != \"\" {\n\t\tvalues.Set(\"parent_id\", params.ParentID)\n\t}\n\n\tresponse := &addBookmarkResponse{}\n\tif err := api.postMethod(ctx, \"bookmarks.add\", values, response); err != nil {\n\t\treturn Bookmark{}, err\n\t}\n\n\treturn response.Bookmark, response.Err()\n}\n\n// RemoveBookmark removes a bookmark from a channel.\n// For more details, see RemoveBookmarkContext documentation.\nfunc (api *Client) RemoveBookmark(channelID, bookmarkID string) error {\n\treturn api.RemoveBookmarkContext(context.Background(), channelID, bookmarkID)\n}\n\n// RemoveBookmarkContext removes a bookmark from a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/bookmarks.remove\nfunc (api *Client) RemoveBookmarkContext(ctx context.Context, channelID, bookmarkID string) error {\n\tvalues := url.Values{\n\t\t\"channel_id\":  {channelID},\n\t\t\"token\":       {api.token},\n\t\t\"bookmark_id\": {bookmarkID},\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"bookmarks.remove\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// ListBookmarks returns all bookmarks for a channel.\n// For more details, see ListBookmarksContext documentation.\nfunc (api *Client) ListBookmarks(channelID string) ([]Bookmark, error) {\n\treturn api.ListBookmarksContext(context.Background(), channelID)\n}\n\n// ListBookmarksContext returns all bookmarks for a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/bookmarks.edit\nfunc (api *Client) ListBookmarksContext(ctx context.Context, channelID string) ([]Bookmark, error) {\n\tvalues := url.Values{\n\t\t\"channel_id\": {channelID},\n\t\t\"token\":      {api.token},\n\t}\n\n\tresponse := &listBookmarksResponse{}\n\terr := api.postMethod(ctx, \"bookmarks.list\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response.Bookmarks, response.Err()\n}\n\n// EditBookmark edits a bookmark in a channel.\n// For more details, see EditBookmarkContext documentation.\nfunc (api *Client) EditBookmark(channelID, bookmarkID string, params EditBookmarkParameters) (Bookmark, error) {\n\treturn api.EditBookmarkContext(context.Background(), channelID, bookmarkID, params)\n}\n\n// EditBookmarkContext edits a bookmark in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/bookmarks.edit\nfunc (api *Client) EditBookmarkContext(ctx context.Context, channelID, bookmarkID string, params EditBookmarkParameters) (Bookmark, error) {\n\tvalues := url.Values{\n\t\t\"channel_id\":  {channelID},\n\t\t\"token\":       {api.token},\n\t\t\"bookmark_id\": {bookmarkID},\n\t}\n\tif params.Link != \"\" {\n\t\tvalues.Set(\"link\", params.Link)\n\t}\n\tif params.Emoji != nil {\n\t\tvalues.Set(\"emoji\", *params.Emoji)\n\t}\n\tif params.Title != nil {\n\t\tvalues.Set(\"title\", *params.Title)\n\t}\n\n\tresponse := &editBookmarkResponse{}\n\tif err := api.postMethod(ctx, \"bookmarks.edit\", values, response); err != nil {\n\t\treturn Bookmark{}, err\n\t}\n\n\treturn response.Bookmark, response.Err()\n}\n"
        },
        {
          "name": "bookmarks_test.go",
          "type": "blob",
          "size": 6.607421875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc getTestBookmark(channelID, bookmarkID string) Bookmark {\n\treturn Bookmark{\n\t\tID:        bookmarkID,\n\t\tChannelID: channelID,\n\t\tTitle:     \"bookmark\",\n\t\tType:      \"link\",\n\t\tLink:      \"https://example.com\",\n\t\tIconURL:   \"https://example.com/icon.png\",\n\t}\n}\n\nfunc addBookmarkLinkHandler(rw http.ResponseWriter, r *http.Request) {\n\tchannelID := r.FormValue(\"channel_id\")\n\ttitle := r.FormValue(\"title\")\n\tbookmarkType := r.FormValue(\"type\")\n\tlink := r.FormValue(\"link\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif bookmarkType == \"link\" && link != \"\" && channelID != \"\" && title != \"\" {\n\t\tbookmark := getTestBookmark(channelID, \"Bk123RBZG8GZ\")\n\t\tbookmark.Title = title\n\t\tbookmark.Type = bookmarkType\n\t\tbookmark.Link = link\n\n\t\tresp, _ := json.Marshal(&addBookmarkResponse{\n\t\t\tSlackResponse: SlackResponse{Ok: true},\n\t\t\tBookmark:      bookmark})\n\t\trw.Write(resp)\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestAddBookmarkLink(t *testing.T) {\n\thttp.HandleFunc(\"/bookmarks.add\", addBookmarkLinkHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := AddBookmarkParameters{\n\t\tTitle: \"test\",\n\t\tType:  \"link\",\n\t\tLink:  \"https://example.com\",\n\t}\n\t_, err := api.AddBookmark(\"CXXXXXXXX\", params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc listBookmarksHandler(rw http.ResponseWriter, r *http.Request) {\n\tchannelID := r.FormValue(\"channel_id\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif channelID != \"\" {\n\t\tbookmarks := []Bookmark{\n\t\t\tgetTestBookmark(channelID, \"Bk001\"),\n\t\t\tgetTestBookmark(channelID, \"Bk002\"),\n\t\t\tgetTestBookmark(channelID, \"Bk003\"),\n\t\t\tgetTestBookmark(channelID, \"Bk004\"),\n\t\t}\n\n\t\tresp, _ := json.Marshal(&listBookmarksResponse{\n\t\t\tSlackResponse: SlackResponse{Ok: true},\n\t\t\tBookmarks:     bookmarks})\n\t\trw.Write(resp)\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestListBookmarks(t *testing.T) {\n\thttp.HandleFunc(\"/bookmarks.list\", listBookmarksHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tchannel := \"CXXXXXXXX\"\n\tbookmarks, err := api.ListBookmarks(channel)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n\tif !reflect.DeepEqual([]Bookmark{\n\t\tgetTestBookmark(channel, \"Bk001\"),\n\t\tgetTestBookmark(channel, \"Bk002\"),\n\t\tgetTestBookmark(channel, \"Bk003\"),\n\t\tgetTestBookmark(channel, \"Bk004\"),\n\t}, bookmarks) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc removeBookmarkHandler(bookmark *Bookmark) func(rw http.ResponseWriter, r *http.Request) {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tchannelID := r.FormValue(\"channel_id\")\n\t\tbookmarkID := r.FormValue(\"bookmark_id\")\n\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\t\tif channelID == bookmark.ChannelID && bookmarkID == bookmark.ID {\n\t\t\trw.Write([]byte(`{ \"ok\": true }`))\n\t\t} else {\n\t\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t\t}\n\t}\n}\n\nfunc TestRemoveBookmark(t *testing.T) {\n\tchannel := \"CXXXXXXXX\"\n\tbookmark := getTestBookmark(channel, \"BkXXXXX\")\n\thttp.HandleFunc(\"/bookmarks.remove\", removeBookmarkHandler(&bookmark))\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\terr := api.RemoveBookmark(channel, bookmark.ID)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc editBookmarkHandler(bookmarks []Bookmark) func(rw http.ResponseWriter, r *http.Request) {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tchannelID := r.FormValue(\"channel_id\")\n\t\tbookmarkID := r.FormValue(\"bookmark_id\")\n\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tif err := r.ParseForm(); err != nil {\n\t\t\thttpTestErrReply(rw, true, fmt.Sprintf(\"err parsing form: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tfor _, bookmark := range bookmarks {\n\t\t\tif bookmark.ID == bookmarkID && bookmark.ChannelID == channelID {\n\t\t\t\tif v := r.Form.Get(\"link\"); v != \"\" {\n\t\t\t\t\tbookmark.Link = v\n\t\t\t\t}\n\t\t\t\t// Emoji and title require special handling since empty string sets to null\n\t\t\t\tif _, ok := r.Form[\"emoji\"]; ok {\n\t\t\t\t\tbookmark.Emoji = r.Form.Get(\"emoji\")\n\t\t\t\t}\n\t\t\t\tif _, ok := r.Form[\"title\"]; ok {\n\t\t\t\t\tbookmark.Title = r.Form.Get(\"title\")\n\t\t\t\t}\n\t\t\t\tresp, _ := json.Marshal(&editBookmarkResponse{\n\t\t\t\t\tSlackResponse: SlackResponse{Ok: true},\n\t\t\t\t\tBookmark:      bookmark})\n\t\t\t\trw.Write(resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// Fail if the bookmark doesn't exist\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"not_found\" }`))\n\t}\n}\n\nfunc TestEditBookmark(t *testing.T) {\n\tchannel := \"CXXXXXXXX\"\n\tbookmarks := []Bookmark{\n\t\tgetTestBookmark(channel, \"Bk001\"),\n\t\tgetTestBookmark(channel, \"Bk002\"),\n\t\tgetTestBookmark(channel, \"Bk003\"),\n\t\tgetTestBookmark(channel, \"Bk004\"),\n\t}\n\thttp.HandleFunc(\"/bookmarks.edit\", editBookmarkHandler(bookmarks))\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tsmileEmoji := \":smile:\"\n\tempty := \"\"\n\ttitle := \"hello, world!\"\n\tchanges := []struct {\n\t\tID     string\n\t\tParams EditBookmarkParameters\n\t}{\n\t\t{ // add emoji\n\t\t\tID:     \"Bk001\",\n\t\t\tParams: EditBookmarkParameters{Emoji: &smileEmoji},\n\t\t},\n\t\t{ // delete emoji\n\t\t\tID:     \"Bk001\",\n\t\t\tParams: EditBookmarkParameters{Emoji: &empty},\n\t\t},\n\t\t{ // add title\n\t\t\tID:     \"Bk002\",\n\t\t\tParams: EditBookmarkParameters{Title: &title},\n\t\t},\n\t\t{ // delete title\n\t\t\tID:     \"Bk002\",\n\t\t\tParams: EditBookmarkParameters{Title: &empty},\n\t\t},\n\t\t{ // Change multiple fields at once\n\t\t\tID: \"Bk003\",\n\t\t\tParams: EditBookmarkParameters{\n\t\t\t\tTitle: &title,\n\t\t\t\tEmoji: &empty,\n\t\t\t\tLink:  \"https://example.com/changed\",\n\t\t\t},\n\t\t},\n\t\t{ // noop\n\t\t\tID: \"Bk004\",\n\t\t},\n\t}\n\n\tfor _, change := range changes {\n\t\tbookmark, err := api.EditBookmark(channel, change.ID, change.Params)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t\t}\n\t\tif change.ID != bookmark.ID {\n\t\t\tt.Fatalf(\"expected to modify bookmark with ID = %s, got %s\", change.ID, bookmark.ID)\n\t\t}\n\t\tif change.Params.Emoji != nil && bookmark.Emoji != *change.Params.Emoji {\n\t\t\tt.Fatalf(\"expected bookmark.Emoji = %s, got %s\", *change.Params.Emoji, bookmark.Emoji)\n\t\t}\n\t\tif change.Params.Title != nil && bookmark.Title != *change.Params.Title {\n\t\t\tt.Fatalf(\"expected bookmark.Title = %s, got %s\", *change.Params.Title, bookmark.Emoji)\n\t\t}\n\t\tif change.Params.Link != \"\" && change.Params.Link != bookmark.Link {\n\t\t\tt.Fatalf(\"expected bookmark.Link = %s, got %s\", change.Params.Link, bookmark.Link)\n\t\t}\n\t}\n\n\t// Cover the final case of trying to edit a bookmark which doesn't exist\n\tbookmark, err := api.EditBookmark(channel, \"BkMissing\", EditBookmarkParameters{})\n\tif err == nil {\n\t\tt.Fatalf(\"Expected not found error, but got bookmark %s\", bookmark.ID)\n\t}\n}\n"
        },
        {
          "name": "bots.go",
          "type": "blob",
          "size": 1.62109375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\n// Bot contains information about a bot\ntype Bot struct {\n\tID      string   `json:\"id\"`\n\tName    string   `json:\"name\"`\n\tDeleted bool     `json:\"deleted\"`\n\tUserID  string   `json:\"user_id\"`\n\tAppID   string   `json:\"app_id\"`\n\tUpdated JSONTime `json:\"updated\"`\n\tIcons   Icons    `json:\"icons\"`\n}\n\ntype botResponseFull struct {\n\tBot `json:\"bot,omitempty\"` // GetBotInfo\n\tSlackResponse\n}\n\nfunc (api *Client) botRequest(ctx context.Context, path string, values url.Values) (*botResponseFull, error) {\n\tresponse := &botResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := response.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\ntype GetBotInfoParameters struct {\n\tBot    string\n\tTeamID string\n}\n\n// GetBotInfo will retrieve the complete bot information.\n// For more details, see GetBotInfoContext documentation.\nfunc (api *Client) GetBotInfo(parameters GetBotInfoParameters) (*Bot, error) {\n\treturn api.GetBotInfoContext(context.Background(), parameters)\n}\n\n// GetBotInfoContext will retrieve the complete bot information using a custom context.\n// Slack API docs: https://api.slack.com/methods/bots.info\nfunc (api *Client) GetBotInfoContext(ctx context.Context, parameters GetBotInfoParameters) (*Bot, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tif parameters.Bot != \"\" {\n\t\tvalues.Add(\"bot\", parameters.Bot)\n\t}\n\n\tif parameters.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", parameters.TeamID)\n\t}\n\n\tresponse, err := api.botRequest(ctx, \"bots.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.Bot, nil\n}\n"
        },
        {
          "name": "bots_test.go",
          "type": "blob",
          "size": 1.5556640625,
          "content": "package slack\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc getBotInfo(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\"ok\": true, \"bot\": {\n\t\t\t\"id\":\"B02875YLA\",\n\t\t\t\"deleted\":false,\n\t\t\t\"name\":\"github\",\n\t\t\t\"updated\": 1449272004,\n\t\t\t\"app_id\":\"A161CLERW\",\n\t\t\t\"user_id\": \"U012ABCDEF\",\n\t\t\t\"icons\": {\n              \"image_36\":\"https:\\/\\/a.slack-edge.com\\/2fac\\/plugins\\/github\\/assets\\/service_36.png\",\n              \"image_48\":\"https:\\/\\/a.slack-edge.com\\/2fac\\/plugins\\/github\\/assets\\/service_48.png\",\n              \"image_72\":\"https:\\/\\/a.slack-edge.com\\/2fac\\/plugins\\/github\\/assets\\/service_72.png\"\n            }\n        }}`)\n\trw.Write(response)\n}\n\nfunc TestGetBotInfo(t *testing.T) {\n\thttp.HandleFunc(\"/bots.info\", getBotInfo)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tbot, err := api.GetBotInfo(GetBotInfoParameters{Bot: \"B02875YLA\"})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\tif bot.ID != \"B02875YLA\" {\n\t\tt.Fatal(\"Incorrect ID\")\n\t}\n\tif bot.Name != \"github\" {\n\t\tt.Fatal(\"Incorrect Name\")\n\t}\n\tif bot.Deleted {\n\t\tt.Fatal(\"Incorrect Deleted flag\")\n\t}\n\tif bot.AppID != \"A161CLERW\" {\n\t\tt.Fatal(\"Incorrect App ID\")\n\t}\n\tif bot.UserID != \"U012ABCDEF\" {\n\t\tt.Fatal(\"Incorrect User ID\")\n\t}\n\tif bot.Updated != 1449272004 {\n\t\tt.Fatal(\"Incorrect Updated\")\n\t}\n\tif len(bot.Icons.Image36) == 0 {\n\t\tt.Fatal(\"Missing Image36\")\n\t}\n\tif len(bot.Icons.Image48) == 0 {\n\t\tt.Fatal(\"Missing Image38\")\n\t}\n\tif len(bot.Icons.Image72) == 0 {\n\t\tt.Fatal(\"Missing Image72\")\n\t}\n}\n"
        },
        {
          "name": "calls.go",
          "type": "blob",
          "size": 6.4326171875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype Call struct {\n\tID                string            `json:\"id\"`\n\tTitle             string            `json:\"title\"`\n\tDateStart         JSONTime          `json:\"date_start\"`\n\tDateEnd           JSONTime          `json:\"date_end\"`\n\tExternalUniqueID  string            `json:\"external_unique_id\"`\n\tJoinURL           string            `json:\"join_url\"`\n\tDesktopAppJoinURL string            `json:\"desktop_app_join_url\"`\n\tExternalDisplayID string            `json:\"external_display_id\"`\n\tParticipants      []CallParticipant `json:\"users\"`\n\tChannels          []string          `json:\"channels\"`\n}\n\n// CallParticipant is a thin user representation which has a SlackID, ExternalID, or both.\n//\n// See: https://api.slack.com/apis/calls#users\ntype CallParticipant struct {\n\tSlackID     string `json:\"slack_id,omitempty\"`\n\tExternalID  string `json:\"external_id,omitempty\"`\n\tDisplayName string `json:\"display_name,omitempty\"`\n\tAvatarURL   string `json:\"avatar_url,omitempty\"`\n}\n\n// Valid checks if the CallUser has a is valid with a SlackID or ExternalID or both.\nfunc (u CallParticipant) Valid() bool {\n\treturn u.SlackID != \"\" || u.ExternalID != \"\"\n}\n\ntype AddCallParameters struct {\n\tJoinURL           string // Required\n\tExternalUniqueID  string // Required\n\tCreatedBy         string // Required if using a bot token\n\tTitle             string\n\tDesktopAppJoinURL string\n\tExternalDisplayID string\n\tDateStart         JSONTime\n\tParticipants      []CallParticipant\n}\n\ntype UpdateCallParameters struct {\n\tTitle             string\n\tDesktopAppJoinURL string\n\tJoinURL           string\n}\n\ntype EndCallParameters struct {\n\t// Duration is the duration of the call in seconds. Omitted if 0.\n\tDuration time.Duration\n}\n\ntype callResponse struct {\n\tCall Call `json:\"call\"`\n\tSlackResponse\n}\n\n// AddCall adds a new Call to the Slack API.\nfunc (api *Client) AddCall(params AddCallParameters) (Call, error) {\n\treturn api.AddCallContext(context.Background(), params)\n}\n\n// AddCallContext adds a new Call to the Slack API.\nfunc (api *Client) AddCallContext(ctx context.Context, params AddCallParameters) (Call, error) {\n\tvalues := url.Values{\n\t\t\"token\":              {api.token},\n\t\t\"join_url\":           {params.JoinURL},\n\t\t\"external_unique_id\": {params.ExternalUniqueID},\n\t}\n\tif params.CreatedBy != \"\" {\n\t\tvalues.Set(\"created_by\", params.CreatedBy)\n\t}\n\tif params.DateStart != 0 {\n\t\tvalues.Set(\"date_start\", strconv.FormatInt(int64(params.DateStart), 10))\n\t}\n\tif params.DesktopAppJoinURL != \"\" {\n\t\tvalues.Set(\"desktop_app_join_url\", params.DesktopAppJoinURL)\n\t}\n\tif params.ExternalDisplayID != \"\" {\n\t\tvalues.Set(\"external_display_id\", params.ExternalDisplayID)\n\t}\n\tif params.Title != \"\" {\n\t\tvalues.Set(\"title\", params.Title)\n\t}\n\tif len(params.Participants) > 0 {\n\t\tdata, err := json.Marshal(params.Participants)\n\t\tif err != nil {\n\t\t\treturn Call{}, err\n\t\t}\n\t\tvalues.Set(\"users\", string(data))\n\t}\n\n\tresponse := &callResponse{}\n\tif err := api.postMethod(ctx, \"calls.add\", values, response); err != nil {\n\t\treturn Call{}, err\n\t}\n\n\treturn response.Call, response.Err()\n}\n\n// GetCallInfo returns information about a Call.\nfunc (api *Client) GetCall(callID string) (Call, error) {\n\treturn api.GetCallContext(context.Background(), callID)\n}\n\n// GetCallInfoContext returns information about a Call.\nfunc (api *Client) GetCallContext(ctx context.Context, callID string) (Call, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"id\":    {callID},\n\t}\n\n\tresponse := &callResponse{}\n\tif err := api.postMethod(ctx, \"calls.info\", values, response); err != nil {\n\t\treturn Call{}, err\n\t}\n\treturn response.Call, response.Err()\n}\n\nfunc (api *Client) UpdateCall(callID string, params UpdateCallParameters) (Call, error) {\n\treturn api.UpdateCallContext(context.Background(), callID, params)\n}\n\n// UpdateCallContext updates a Call with the given parameters.\nfunc (api *Client) UpdateCallContext(ctx context.Context, callID string, params UpdateCallParameters) (Call, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"id\":    {callID},\n\t}\n\n\tif params.DesktopAppJoinURL != \"\" {\n\t\tvalues.Set(\"desktop_app_join_url\", params.DesktopAppJoinURL)\n\t}\n\tif params.JoinURL != \"\" {\n\t\tvalues.Set(\"join_url\", params.JoinURL)\n\t}\n\tif params.Title != \"\" {\n\t\tvalues.Set(\"title\", params.Title)\n\t}\n\n\tresponse := &callResponse{}\n\tif err := api.postMethod(ctx, \"calls.update\", values, response); err != nil {\n\t\treturn Call{}, err\n\t}\n\treturn response.Call, response.Err()\n}\n\n// EndCall ends a Call.\nfunc (api *Client) EndCall(callID string, params EndCallParameters) error {\n\treturn api.EndCallContext(context.Background(), callID, params)\n}\n\n// EndCallContext ends a Call.\nfunc (api *Client) EndCallContext(ctx context.Context, callID string, params EndCallParameters) error {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"id\":    {callID},\n\t}\n\n\tif params.Duration != 0 {\n\t\tvalues.Set(\"duration\", strconv.FormatInt(int64(params.Duration.Seconds()), 10))\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"calls.end\", values, response); err != nil {\n\t\treturn err\n\t}\n\treturn response.Err()\n}\n\n// CallAddParticipants adds users to a Call.\nfunc (api *Client) CallAddParticipants(callID string, participants []CallParticipant) error {\n\treturn api.CallAddParticipantsContext(context.Background(), callID, participants)\n}\n\n// CallAddParticipantsContext adds users to a Call.\nfunc (api *Client) CallAddParticipantsContext(ctx context.Context, callID string, participants []CallParticipant) error {\n\treturn api.setCallParticipants(ctx, \"calls.participants.add\", callID, participants)\n}\n\n// CallRemoveParticipants removes users from a Call.\nfunc (api *Client) CallRemoveParticipants(callID string, participants []CallParticipant) error {\n\treturn api.CallRemoveParticipantsContext(context.Background(), callID, participants)\n}\n\n// CallRemoveParticipantsContext removes users from a Call.\nfunc (api *Client) CallRemoveParticipantsContext(ctx context.Context, callID string, participants []CallParticipant) error {\n\treturn api.setCallParticipants(ctx, \"calls.participants.remove\", callID, participants)\n}\n\nfunc (api *Client) setCallParticipants(ctx context.Context, method, callID string, participants []CallParticipant) error {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"id\":    {callID},\n\t}\n\n\tdata, err := json.Marshal(participants)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvalues.Set(\"users\", string(data))\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, method, values, response); err != nil {\n\t\treturn err\n\t}\n\treturn response.Err()\n}\n"
        },
        {
          "name": "calls_test.go",
          "type": "blob",
          "size": 5.447265625,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc getTestCall(callID string) Call {\n\treturn Call{\n\t\tID:               callID,\n\t\tTitle:            \"test call\",\n\t\tJoinURL:          \"https://example.com/example\",\n\t\tExternalUniqueID: \"123\",\n\t}\n}\n\nfunc testClient(api string, f http.HandlerFunc) *Client {\n\thttp.HandleFunc(api, f)\n\tonce.Do(startServer)\n\treturn New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n}\n\nvar callTestId = 999\n\nfunc addCallHandler(t *testing.T) http.HandlerFunc {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tif err := r.ParseForm(); err != nil {\n\t\t\thttpTestErrReply(rw, true, fmt.Sprintf(\"err parsing form: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\tcall := Call{\n\t\t\tID:                fmt.Sprintf(\"R%d\", callTestId),\n\t\t\tTitle:             r.FormValue(\"title\"),\n\t\t\tJoinURL:           r.FormValue(\"join_url\"),\n\t\t\tExternalUniqueID:  r.FormValue(\"external_unique_id\"),\n\t\t\tExternalDisplayID: r.FormValue(\"external_display_id\"),\n\t\t\tDesktopAppJoinURL: r.FormValue(\"desktop_app_join_url\"),\n\t\t}\n\t\tcallTestId += 1\n\t\tjson.Unmarshal([]byte(r.FormValue(\"users\")), &call.Participants)\n\t\tif start := r.FormValue(\"date_start\"); start != \"\" {\n\t\t\tdateStart, err := strconv.ParseInt(start, 10, 64)\n\t\t\trequire.NoError(t, err)\n\t\t\tcall.DateStart = JSONTime(dateStart)\n\t\t}\n\t\tresp, _ := json.Marshal(callResponse{Call: call, SlackResponse: SlackResponse{Ok: true}})\n\t\trw.Write(resp)\n\t}\n}\n\nfunc TestAddCall(t *testing.T) {\n\tapi := testClient(\"/calls.add\", addCallHandler(t))\n\tparams := AddCallParameters{\n\t\tTitle:            \"test call\",\n\t\tJoinURL:          \"https://example.com/example\",\n\t\tExternalUniqueID: \"123\",\n\t}\n\tcall, err := api.AddCall(params)\n\trequire.NoError(t, err)\n\tassert.Equal(t, params.Title, call.Title)\n\tassert.Equal(t, params.JoinURL, call.JoinURL)\n\tassert.Equal(t, params.ExternalUniqueID, call.ExternalUniqueID)\n}\n\nfunc getCallHandler(calls []Call) func(rw http.ResponseWriter, r *http.Request) {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tcallID := r.FormValue(\"id\")\n\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfor _, call := range calls {\n\t\t\tif call.ID == callID {\n\t\t\t\tresp, _ := json.Marshal(callResponse{Call: call, SlackResponse: SlackResponse{Ok: true}})\n\t\t\t\trw.Write(resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// Fail if the call doesn't exist\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"not_found\" }`))\n\t}\n}\n\nfunc TestGetCall(t *testing.T) {\n\tcalls := []Call{\n\t\tgetTestCall(\"R1234567890\"),\n\t\tgetTestCall(\"R1234567891\"),\n\t}\n\thttp.HandleFunc(\"/calls.info\", getCallHandler(calls))\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tfor _, call := range calls {\n\t\tresp, err := api.GetCall(call.ID)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, call, resp)\n\t}\n\t// Test a call that doesn't exist\n\t_, err := api.GetCall(\"R1234567892\")\n\trequire.Error(t, err)\n}\n\nfunc updateCallHandler(calls []Call) func(rw http.ResponseWriter, r *http.Request) {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tcallID := r.FormValue(\"id\")\n\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tif err := r.ParseForm(); err != nil {\n\t\t\thttpTestErrReply(rw, true, fmt.Sprintf(\"err parsing form: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tfor _, call := range calls {\n\t\t\tif call.ID == callID {\n\t\t\t\tif title := r.FormValue(\"title\"); title != \"\" {\n\t\t\t\t\tcall.Title = title\n\t\t\t\t}\n\t\t\t\tif joinURL := r.FormValue(\"join_url\"); joinURL != \"\" {\n\t\t\t\t\tcall.JoinURL = joinURL\n\t\t\t\t}\n\t\t\t\tif desktopAppJoinURL := r.FormValue(\"desktop_app_join_url\"); desktopAppJoinURL != \"\" {\n\t\t\t\t\tcall.DesktopAppJoinURL = desktopAppJoinURL\n\t\t\t\t}\n\t\t\t\tresp, _ := json.Marshal(callResponse{Call: call, SlackResponse: SlackResponse{Ok: true}})\n\t\t\t\trw.Write(resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// Fail if the call doesn't exist\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"not_found\" }`))\n\t}\n}\n\nfunc TestUpdateCall(t *testing.T) {\n\tcalls := []Call{\n\t\tgetTestCall(\"R1234567890\"),\n\t\tgetTestCall(\"R1234567891\"),\n\t\tgetTestCall(\"R1234567892\"),\n\t\tgetTestCall(\"R1234567893\"),\n\t\tgetTestCall(\"R1234567894\"),\n\t}\n\thttp.HandleFunc(\"/calls.update\", updateCallHandler(calls))\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tchanges := []struct {\n\t\tcallID string\n\t\tparams UpdateCallParameters\n\t}{\n\t\t{\n\t\t\tcallID: \"R1234567890\",\n\t\t\tparams: UpdateCallParameters{Title: \"test\"},\n\t\t},\n\t\t{\n\t\t\tcallID: \"R1234567891\",\n\t\t\tparams: UpdateCallParameters{JoinURL: \"https://example.com/join\"},\n\t\t},\n\t\t{\n\t\t\tcallID: \"R1234567892\",\n\t\t\tparams: UpdateCallParameters{DesktopAppJoinURL: \"https://example.com/join\"},\n\t\t},\n\t\t{ // Change multiple fields at once\n\t\t\tcallID: \"R1234567893\",\n\t\t\tparams: UpdateCallParameters{\n\t\t\t\tTitle:   \"test\",\n\t\t\t\tJoinURL: \"https://example.com/join\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, change := range changes {\n\t\tcall, err := api.UpdateCall(change.callID, change.params)\n\t\trequire.NoError(t, err)\n\t\tif change.params.Title != \"\" && call.Title != change.params.Title {\n\t\t\tt.Fatalf(\"Expected title to be %s, got %s\", change.params.Title, call.Title)\n\t\t}\n\t\tif change.params.JoinURL != \"\" && call.JoinURL != change.params.JoinURL {\n\t\t\tt.Fatalf(\"Expected join_url to be %s, got %s\", change.params.JoinURL, call.JoinURL)\n\t\t}\n\t\tif change.params.DesktopAppJoinURL != \"\" && call.DesktopAppJoinURL != change.params.DesktopAppJoinURL {\n\t\t\tt.Fatalf(\"Expected desktop_app_join_url to be %s, got %s\", change.params.DesktopAppJoinURL, call.DesktopAppJoinURL)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "canvas.go",
          "type": "blob",
          "size": 7.314453125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\ntype CanvasDetails struct {\n\tCanvasID string `json:\"canvas_id\"`\n}\n\ntype DocumentContent struct {\n\tType     string `json:\"type\"`\n\tMarkdown string `json:\"markdown,omitempty\"`\n}\n\ntype CanvasChange struct {\n\tOperation       string          `json:\"operation\"`\n\tSectionID       string          `json:\"section_id,omitempty\"`\n\tDocumentContent DocumentContent `json:\"document_content\"`\n}\n\ntype EditCanvasParams struct {\n\tCanvasID string         `json:\"canvas_id\"`\n\tChanges  []CanvasChange `json:\"changes\"`\n}\n\ntype SetCanvasAccessParams struct {\n\tCanvasID    string   `json:\"canvas_id\"`\n\tAccessLevel string   `json:\"access_level\"`\n\tChannelIDs  []string `json:\"channel_ids,omitempty\"`\n\tUserIDs     []string `json:\"user_ids,omitempty\"`\n}\n\ntype DeleteCanvasAccessParams struct {\n\tCanvasID   string   `json:\"canvas_id\"`\n\tChannelIDs []string `json:\"channel_ids,omitempty\"`\n\tUserIDs    []string `json:\"user_ids,omitempty\"`\n}\n\ntype LookupCanvasSectionsCriteria struct {\n\tSectionTypes []string `json:\"section_types,omitempty\"`\n\tContainsText string   `json:\"contains_text,omitempty\"`\n}\n\ntype LookupCanvasSectionsParams struct {\n\tCanvasID string                       `json:\"canvas_id\"`\n\tCriteria LookupCanvasSectionsCriteria `json:\"criteria\"`\n}\n\ntype CanvasSection struct {\n\tID string `json:\"id\"`\n}\n\ntype LookupCanvasSectionsResponse struct {\n\tSlackResponse\n\tSections []CanvasSection `json:\"sections\"`\n}\n\n// CreateCanvas creates a new canvas.\n// For more details, see CreateCanvasContext documentation.\nfunc (api *Client) CreateCanvas(title string, documentContent DocumentContent) (string, error) {\n\treturn api.CreateCanvasContext(context.Background(), title, documentContent)\n}\n\n// CreateCanvasContext creates a new canvas with a custom context.\n// Slack API docs: https://api.slack.com/methods/canvases.create\nfunc (api *Client) CreateCanvasContext(ctx context.Context, title string, documentContent DocumentContent) (string, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif title != \"\" {\n\t\tvalues.Add(\"title\", title)\n\t}\n\tif documentContent.Type != \"\" {\n\t\tdocumentContentJSON, err := json.Marshal(documentContent)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tvalues.Add(\"document_content\", string(documentContentJSON))\n\t}\n\n\tresponse := struct {\n\t\tSlackResponse\n\t\tCanvasID string `json:\"canvas_id\"`\n\t}{}\n\n\terr := api.postMethod(ctx, \"canvases.create\", values, &response)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn response.CanvasID, response.Err()\n}\n\n// DeleteCanvas deletes an existing canvas.\n// For more details, see DeleteCanvasContext documentation.\nfunc (api *Client) DeleteCanvas(canvasID string) error {\n\treturn api.DeleteCanvasContext(context.Background(), canvasID)\n}\n\n// DeleteCanvasContext deletes an existing canvas with a custom context.\n// Slack API docs: https://api.slack.com/methods/canvases.delete\nfunc (api *Client) DeleteCanvasContext(ctx context.Context, canvasID string) error {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"canvas_id\": {canvasID},\n\t}\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"canvases.delete\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// EditCanvas edits an existing canvas.\n// For more details, see EditCanvasContext documentation.\nfunc (api *Client) EditCanvas(params EditCanvasParams) error {\n\treturn api.EditCanvasContext(context.Background(), params)\n}\n\n// EditCanvasContext edits an existing canvas with a custom context.\n// Slack API docs: https://api.slack.com/methods/canvases.edit\nfunc (api *Client) EditCanvasContext(ctx context.Context, params EditCanvasParams) error {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"canvas_id\": {params.CanvasID},\n\t}\n\n\tchangesJSON, err := json.Marshal(params.Changes)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvalues.Add(\"changes\", string(changesJSON))\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr = api.postMethod(ctx, \"canvases.edit\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// SetCanvasAccess sets the access level to a canvas for specified entities.\n// For more details, see SetCanvasAccessContext documentation.\nfunc (api *Client) SetCanvasAccess(params SetCanvasAccessParams) error {\n\treturn api.SetCanvasAccessContext(context.Background(), params)\n}\n\n// SetCanvasAccessContext sets the access level to a canvas for specified entities with a custom context.\n// Slack API docs: https://api.slack.com/methods/canvases.access.set\nfunc (api *Client) SetCanvasAccessContext(ctx context.Context, params SetCanvasAccessParams) error {\n\tvalues := url.Values{\n\t\t\"token\":        {api.token},\n\t\t\"canvas_id\":    {params.CanvasID},\n\t\t\"access_level\": {params.AccessLevel},\n\t}\n\tif len(params.ChannelIDs) > 0 {\n\t\tchannelIDsJSON, err := json.Marshal(params.ChannelIDs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalues.Add(\"channel_ids\", string(channelIDsJSON))\n\t}\n\tif len(params.UserIDs) > 0 {\n\t\tuserIDsJSON, err := json.Marshal(params.UserIDs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalues.Add(\"user_ids\", string(userIDsJSON))\n\t}\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"canvases.access.set\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// DeleteCanvasAccess removes access to a canvas for specified entities.\n// For more details, see DeleteCanvasAccessContext documentation.\nfunc (api *Client) DeleteCanvasAccess(params DeleteCanvasAccessParams) error {\n\treturn api.DeleteCanvasAccessContext(context.Background(), params)\n}\n\n// DeleteCanvasAccessContext removes access to a canvas for specified entities with a custom context.\n// Slack API docs: https://api.slack.com/methods/canvases.access.delete\nfunc (api *Client) DeleteCanvasAccessContext(ctx context.Context, params DeleteCanvasAccessParams) error {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"canvas_id\": {params.CanvasID},\n\t}\n\tif len(params.ChannelIDs) > 0 {\n\t\tchannelIDsJSON, err := json.Marshal(params.ChannelIDs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalues.Add(\"channel_ids\", string(channelIDsJSON))\n\t}\n\tif len(params.UserIDs) > 0 {\n\t\tuserIDsJSON, err := json.Marshal(params.UserIDs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalues.Add(\"user_ids\", string(userIDsJSON))\n\t}\n\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"canvases.access.delete\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// LookupCanvasSections finds sections matching the provided criteria.\n// For more details, see LookupCanvasSectionsContext documentation.\nfunc (api *Client) LookupCanvasSections(params LookupCanvasSectionsParams) ([]CanvasSection, error) {\n\treturn api.LookupCanvasSectionsContext(context.Background(), params)\n}\n\n// LookupCanvasSectionsContext finds sections matching the provided criteria with a custom context.\n// Slack API docs: https://api.slack.com/methods/canvases.sections.lookup\nfunc (api *Client) LookupCanvasSectionsContext(ctx context.Context, params LookupCanvasSectionsParams) ([]CanvasSection, error) {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"canvas_id\": {params.CanvasID},\n\t}\n\n\tcriteriaJSON, err := json.Marshal(params.Criteria)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvalues.Add(\"criteria\", string(criteriaJSON))\n\n\tresponse := LookupCanvasSectionsResponse{}\n\n\terr = api.postMethod(ctx, \"canvases.sections.lookup\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.Sections, response.Err()\n}\n"
        },
        {
          "name": "canvas_test.go",
          "type": "blob",
          "size": 5.134765625,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc createCanvasHandler(rw http.ResponseWriter, r *http.Request) {\n\ttitle := r.FormValue(\"title\")\n\tdocumentContent := r.FormValue(\"document_content\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif title != \"\" && documentContent != \"\" {\n\t\tresp, _ := json.Marshal(&struct {\n\t\t\tSlackResponse\n\t\t\tCanvasID string `json:\"canvas_id\"`\n\t\t}{\n\t\t\tSlackResponse: SlackResponse{Ok: true},\n\t\t\tCanvasID:      \"F1234ABCD\",\n\t\t})\n\t\trw.Write(resp)\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestCreateCanvas(t *testing.T) {\n\thttp.HandleFunc(\"/canvases.create\", createCanvasHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tdocumentContent := DocumentContent{\n\t\tType:     \"markdown\",\n\t\tMarkdown: \"Test Content\",\n\t}\n\n\tcanvasID, err := api.CreateCanvas(\"Test Canvas\", documentContent)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n\tif canvasID != \"F1234ABCD\" {\n\t\tt.Fatalf(\"Expected canvas ID to be F1234ABCD, got %s\", canvasID)\n\t}\n}\n\nfunc deleteCanvasHandler(rw http.ResponseWriter, r *http.Request) {\n\tcanvasID := r.FormValue(\"canvas_id\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif canvasID == \"F1234ABCD\" {\n\t\trw.Write([]byte(`{ \"ok\": true }`))\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestDeleteCanvas(t *testing.T) {\n\thttp.HandleFunc(\"/canvases.delete\", deleteCanvasHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\terr := api.DeleteCanvas(\"F1234ABCD\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc editCanvasHandler(rw http.ResponseWriter, r *http.Request) {\n\tcanvasID := r.FormValue(\"canvas_id\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif canvasID == \"F1234ABCD\" {\n\t\trw.Write([]byte(`{ \"ok\": true }`))\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestEditCanvas(t *testing.T) {\n\thttp.HandleFunc(\"/canvases.edit\", editCanvasHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := EditCanvasParams{\n\t\tCanvasID: \"F1234ABCD\",\n\t\tChanges: []CanvasChange{\n\t\t\t{\n\t\t\t\tOperation: \"update\",\n\t\t\t\tSectionID: \"S1234\",\n\t\t\t\tDocumentContent: DocumentContent{\n\t\t\t\t\tType:     \"markdown\",\n\t\t\t\t\tMarkdown: \"Updated Content\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := api.EditCanvas(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc setCanvasAccessHandler(rw http.ResponseWriter, r *http.Request) {\n\tcanvasID := r.FormValue(\"canvas_id\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif canvasID == \"F1234ABCD\" {\n\t\trw.Write([]byte(`{ \"ok\": true }`))\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestSetCanvasAccess(t *testing.T) {\n\thttp.HandleFunc(\"/canvases.access.set\", setCanvasAccessHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := SetCanvasAccessParams{\n\t\tCanvasID:    \"F1234ABCD\",\n\t\tAccessLevel: \"read\",\n\t\tChannelIDs:  []string{\"C1234ABCD\"},\n\t\tUserIDs:     []string{\"U1234ABCD\"},\n\t}\n\n\terr := api.SetCanvasAccess(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc deleteCanvasAccessHandler(rw http.ResponseWriter, r *http.Request) {\n\tcanvasID := r.FormValue(\"canvas_id\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif canvasID == \"F1234ABCD\" {\n\t\trw.Write([]byte(`{ \"ok\": true }`))\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestDeleteCanvasAccess(t *testing.T) {\n\thttp.HandleFunc(\"/canvases.access.delete\", deleteCanvasAccessHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := DeleteCanvasAccessParams{\n\t\tCanvasID:   \"F1234ABCD\",\n\t\tChannelIDs: []string{\"C1234ABCD\"},\n\t\tUserIDs:    []string{\"U1234ABCD\"},\n\t}\n\n\terr := api.DeleteCanvasAccess(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc lookupCanvasSectionsHandler(rw http.ResponseWriter, r *http.Request) {\n\tcanvasID := r.FormValue(\"canvas_id\")\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tif canvasID == \"F1234ABCD\" {\n\t\tsections := []CanvasSection{\n\t\t\t{ID: \"S1234\"},\n\t\t\t{ID: \"S5678\"},\n\t\t}\n\n\t\tresp, _ := json.Marshal(&LookupCanvasSectionsResponse{\n\t\t\tSlackResponse: SlackResponse{Ok: true},\n\t\t\tSections:      sections,\n\t\t})\n\t\trw.Write(resp)\n\t} else {\n\t\trw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t}\n}\n\nfunc TestLookupCanvasSections(t *testing.T) {\n\thttp.HandleFunc(\"/canvases.sections.lookup\", lookupCanvasSectionsHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := LookupCanvasSectionsParams{\n\t\tCanvasID: \"F1234ABCD\",\n\t\tCriteria: LookupCanvasSectionsCriteria{\n\t\t\tSectionTypes: []string{\"h1\", \"h2\"},\n\t\t\tContainsText: \"Test\",\n\t\t},\n\t}\n\n\tsections, err := api.LookupCanvasSections(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n\texpectedSections := []CanvasSection{\n\t\t{ID: \"S1234\"},\n\t\t{ID: \"S5678\"},\n\t}\n\n\tif !reflect.DeepEqual(expectedSections, sections) {\n\t\tt.Fatalf(\"Expected sections %v, got %v\", expectedSections, sections)\n\t}\n}\n"
        },
        {
          "name": "channels.go",
          "type": "blob",
          "size": 0.9697265625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\ntype channelResponseFull struct {\n\tChannel      Channel   `json:\"channel\"`\n\tChannels     []Channel `json:\"channels\"`\n\tPurpose      string    `json:\"purpose\"`\n\tTopic        string    `json:\"topic\"`\n\tNotInChannel bool      `json:\"not_in_channel\"`\n\tHistory\n\tSlackResponse\n\tMetadata ResponseMetadata `json:\"response_metadata\"`\n}\n\n// Channel contains information about the channel\ntype Channel struct {\n\tGroupConversation\n\tIsChannel  bool        `json:\"is_channel\"`\n\tIsGeneral  bool        `json:\"is_general\"`\n\tIsMember   bool        `json:\"is_member\"`\n\tLocale     string      `json:\"locale\"`\n\tProperties *Properties `json:\"properties\"`\n}\n\nfunc (api *Client) channelRequest(ctx context.Context, path string, values url.Values) (*channelResponseFull, error) {\n\tresponse := &channelResponseFull{}\n\terr := postForm(ctx, api.httpclient, api.endpoint+path, values, response, api)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n"
        },
        {
          "name": "chat.go",
          "type": "blob",
          "size": 29.5029296875,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\n\t\"github.com/slack-go/slack/slackutilsx\"\n)\n\nconst (\n\tDEFAULT_MESSAGE_USERNAME         = \"\"\n\tDEFAULT_MESSAGE_REPLY_BROADCAST  = false\n\tDEFAULT_MESSAGE_ASUSER           = false\n\tDEFAULT_MESSAGE_PARSE            = \"\"\n\tDEFAULT_MESSAGE_THREAD_TIMESTAMP = \"\"\n\tDEFAULT_MESSAGE_LINK_NAMES       = 0\n\tDEFAULT_MESSAGE_UNFURL_LINKS     = false\n\tDEFAULT_MESSAGE_UNFURL_MEDIA     = true\n\tDEFAULT_MESSAGE_ICON_URL         = \"\"\n\tDEFAULT_MESSAGE_ICON_EMOJI       = \"\"\n\tDEFAULT_MESSAGE_MARKDOWN         = true\n\tDEFAULT_MESSAGE_ESCAPE_TEXT      = true\n)\n\ntype chatResponseFull struct {\n\tChannel            string `json:\"channel\"`\n\tTimestamp          string `json:\"ts\"`                             // Regular message timestamp\n\tMessageTimeStamp   string `json:\"message_ts\"`                     // Ephemeral message timestamp\n\tScheduledMessageID string `json:\"scheduled_message_id,omitempty\"` // Scheduled message id\n\tText               string `json:\"text\"`\n\tSlackResponse\n}\n\n// getMessageTimestamp will inspect the `chatResponseFull` to return a timestamp value\n// in `chat.postMessage` its under `ts`\n// in `chat.postEphemeral` its under `message_ts`\nfunc (c chatResponseFull) getMessageTimestamp() string {\n\tif len(c.Timestamp) > 0 {\n\t\treturn c.Timestamp\n\t}\n\treturn c.MessageTimeStamp\n}\n\n// PostMessageParameters contains all the parameters necessary (including the optional ones) for a PostMessage() request\ntype PostMessageParameters struct {\n\tUsername        string `json:\"username\"`\n\tAsUser          bool   `json:\"as_user\"`\n\tParse           string `json:\"parse\"`\n\tThreadTimestamp string `json:\"thread_ts\"`\n\tReplyBroadcast  bool   `json:\"reply_broadcast\"`\n\tLinkNames       int    `json:\"link_names\"`\n\tUnfurlLinks     bool   `json:\"unfurl_links\"`\n\tUnfurlMedia     bool   `json:\"unfurl_media\"`\n\tIconURL         string `json:\"icon_url\"`\n\tIconEmoji       string `json:\"icon_emoji\"`\n\tMarkdown        bool   `json:\"mrkdwn,omitempty\"`\n\tEscapeText      bool   `json:\"escape_text\"`\n\n\t// chat.postEphemeral support\n\tChannel string `json:\"channel\"`\n\tUser    string `json:\"user\"`\n\n\t// chat metadata support\n\tMetaData SlackMetadata `json:\"metadata\"`\n}\n\n// NewPostMessageParameters provides an instance of PostMessageParameters with all the sane default values set\nfunc NewPostMessageParameters() PostMessageParameters {\n\treturn PostMessageParameters{\n\t\tUsername:        DEFAULT_MESSAGE_USERNAME,\n\t\tUser:            DEFAULT_MESSAGE_USERNAME,\n\t\tAsUser:          DEFAULT_MESSAGE_ASUSER,\n\t\tParse:           DEFAULT_MESSAGE_PARSE,\n\t\tThreadTimestamp: DEFAULT_MESSAGE_THREAD_TIMESTAMP,\n\t\tLinkNames:       DEFAULT_MESSAGE_LINK_NAMES,\n\t\tUnfurlLinks:     DEFAULT_MESSAGE_UNFURL_LINKS,\n\t\tUnfurlMedia:     DEFAULT_MESSAGE_UNFURL_MEDIA,\n\t\tIconURL:         DEFAULT_MESSAGE_ICON_URL,\n\t\tIconEmoji:       DEFAULT_MESSAGE_ICON_EMOJI,\n\t\tMarkdown:        DEFAULT_MESSAGE_MARKDOWN,\n\t\tEscapeText:      DEFAULT_MESSAGE_ESCAPE_TEXT,\n\t}\n}\n\n// DeleteMessage deletes a message in a channel.\n// For more details, see DeleteMessageContext documentation.\nfunc (api *Client) DeleteMessage(channel, messageTimestamp string) (string, string, error) {\n\treturn api.DeleteMessageContext(context.Background(), channel, messageTimestamp)\n}\n\n// DeleteMessageContext deletes a message in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.delete\nfunc (api *Client) DeleteMessageContext(ctx context.Context, channel, messageTimestamp string) (string, string, error) {\n\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n\t\tctx,\n\t\tchannel,\n\t\tMsgOptionDelete(messageTimestamp),\n\t)\n\treturn respChannel, respTimestamp, err\n}\n\n// ScheduleMessage sends a message to a channel.\n// Message is escaped by default according to https://api.slack.com/docs/formatting\n// Use http://davestevens.github.io/slack-message-builder/ to help crafting your message.\n// For more details, see ScheduleMessageContext documentation.\nfunc (api *Client) ScheduleMessage(channelID, postAt string, options ...MsgOption) (string, string, error) {\n\treturn api.ScheduleMessageContext(context.Background(), channelID, postAt, options...)\n}\n\n// ScheduleMessageContext sends a message to a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.scheduleMessage\nfunc (api *Client) ScheduleMessageContext(ctx context.Context, channelID, postAt string, options ...MsgOption) (string, string, error) {\n\trespChannel, scheduledMessageId, _, err := api.SendMessageContext(\n\t\tctx,\n\t\tchannelID,\n\t\tMsgOptionSchedule(postAt),\n\t\tMsgOptionCompose(options...),\n\t)\n\treturn respChannel, scheduledMessageId, err\n}\n\n// PostMessage sends a message to a channel.\n// Message is escaped by default according to https://api.slack.com/docs/formatting\n// Use http://davestevens.github.io/slack-message-builder/ to help crafting your message.\n// For more details, see PostMessageContext documentation.\nfunc (api *Client) PostMessage(channelID string, options ...MsgOption) (string, string, error) {\n\treturn api.PostMessageContext(context.Background(), channelID, options...)\n}\n\n// PostMessageContext sends a message to a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.postMessage\nfunc (api *Client) PostMessageContext(ctx context.Context, channelID string, options ...MsgOption) (string, string, error) {\n\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n\t\tctx,\n\t\tchannelID,\n\t\tMsgOptionPost(),\n\t\tMsgOptionCompose(options...),\n\t)\n\treturn respChannel, respTimestamp, err\n}\n\n// PostEphemeral sends an ephemeral message to a user in a channel.\n// Message is escaped by default according to https://api.slack.com/docs/formatting\n// Use http://davestevens.github.io/slack-message-builder/ to help crafting your message.\n// For more details, see PostEphemeralContext documentation.\nfunc (api *Client) PostEphemeral(channelID, userID string, options ...MsgOption) (string, error) {\n\treturn api.PostEphemeralContext(context.Background(), channelID, userID, options...)\n}\n\n// PostEphemeralContext sends an ephemeral message to a user in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.postEphemeral\nfunc (api *Client) PostEphemeralContext(ctx context.Context, channelID, userID string, options ...MsgOption) (timestamp string, err error) {\n\t_, timestamp, _, err = api.SendMessageContext(\n\t\tctx,\n\t\tchannelID,\n\t\tMsgOptionPostEphemeral(userID),\n\t\tMsgOptionCompose(options...),\n\t)\n\treturn timestamp, err\n}\n\n// UpdateMessage updates a message in a channel.\n// For more details, see UpdateMessageContext documentation.\nfunc (api *Client) UpdateMessage(channelID, timestamp string, options ...MsgOption) (string, string, string, error) {\n\treturn api.UpdateMessageContext(context.Background(), channelID, timestamp, options...)\n}\n\n// UpdateMessageContext updates a message in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.update\nfunc (api *Client) UpdateMessageContext(ctx context.Context, channelID, timestamp string, options ...MsgOption) (string, string, string, error) {\n\treturn api.SendMessageContext(\n\t\tctx,\n\t\tchannelID,\n\t\tMsgOptionUpdate(timestamp),\n\t\tMsgOptionCompose(options...),\n\t)\n}\n\n// UnfurlMessage unfurls a message in a channel.\n// For more details, see UnfurlMessageContext documentation.\nfunc (api *Client) UnfurlMessage(channelID, timestamp string, unfurls map[string]Attachment, options ...MsgOption) (string, string, string, error) {\n\treturn api.UnfurlMessageContext(context.Background(), channelID, timestamp, unfurls, options...)\n}\n\n// UnfurlMessageContext unfurls a message in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.unfurl\nfunc (api *Client) UnfurlMessageContext(ctx context.Context, channelID, timestamp string, unfurls map[string]Attachment, options ...MsgOption) (string, string, string, error) {\n\treturn api.SendMessageContext(ctx, channelID, MsgOptionUnfurl(timestamp, unfurls), MsgOptionCompose(options...))\n}\n\n// UnfurlMessageWithAuthURL sends an unfurl request containing an authentication URL.\n// For more details, see UnfurlMessageWithAuthURLContext documentation.\nfunc (api *Client) UnfurlMessageWithAuthURL(channelID, timestamp string, userAuthURL string, options ...MsgOption) (string, string, string, error) {\n\treturn api.UnfurlMessageWithAuthURLContext(context.Background(), channelID, timestamp, userAuthURL, options...)\n}\n\n// UnfurlMessageWithAuthURLContext sends an unfurl request containing an authentication URL with a custom context.\n// For more details see: https://api.slack.com/reference/messaging/link-unfurling#authenticated_unfurls\nfunc (api *Client) UnfurlMessageWithAuthURLContext(ctx context.Context, channelID, timestamp string, userAuthURL string, options ...MsgOption) (string, string, string, error) {\n\treturn api.SendMessageContext(ctx, channelID, MsgOptionUnfurlAuthURL(timestamp, userAuthURL), MsgOptionCompose(options...))\n}\n\n// SendMessage more flexible method for configuring messages.\n// For more details, see SendMessageContext documentation.\nfunc (api *Client) SendMessage(channel string, options ...MsgOption) (string, string, string, error) {\n\treturn api.SendMessageContext(context.Background(), channel, options...)\n}\n\n// SendMessageContext more flexible method for configuring messages with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.postMessage\nfunc (api *Client) SendMessageContext(ctx context.Context, channelID string, options ...MsgOption) (_channel string, _timestampOrScheduledMessageId string, _text string, err error) {\n\tvar (\n\t\treq      *http.Request\n\t\tparser   func(*chatResponseFull) responseParser\n\t\tresponse chatResponseFull\n\t)\n\n\tif req, parser, err = buildSender(api.endpoint, options...).BuildRequestContext(ctx, api.token, channelID); err != nil {\n\t\treturn \"\", \"\", \"\", err\n\t}\n\n\tif api.Debug() {\n\t\treqBody, err := io.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", \"\", err\n\t\t}\n\t\treq.Body = io.NopCloser(bytes.NewBuffer(reqBody))\n\t\tapi.Debugf(\"Sending request: %s\", redactToken(reqBody))\n\t}\n\n\tif err = doPost(ctx, api.httpclient, req, parser(&response), api); err != nil {\n\t\treturn \"\", \"\", \"\", err\n\t}\n\n\tif response.ScheduledMessageID != \"\" {\n\t\treturn response.Channel, response.ScheduledMessageID, response.Text, response.Err()\n\t} else {\n\t\treturn response.Channel, response.getMessageTimestamp(), response.Text, response.Err()\n\t}\n}\n\nfunc redactToken(b []byte) []byte {\n\t// See https://api.slack.com/authentication/token-types\n\t// and https://api.slack.com/authentication/rotation\n\tre, err := regexp.Compile(`(token=x[a-z.]+)-[0-9A-Za-z-]+`)\n\tif err != nil {\n\t\t// The regular expression above should never result in errors,\n\t\t// but just in case, do no harm.\n\t\treturn b\n\t}\n\t// Keep \"token=\" and the first element of the token, which identifies its type\n\t// (this could be useful for debugging, e.g. when using a wrong token).\n\treturn re.ReplaceAll(b, []byte(\"$1-REDACTED\"))\n}\n\n// UnsafeApplyMsgOptions utility function for debugging/testing chat requests.\n// NOTE: USE AT YOUR OWN RISK: No issues relating to the use of this function\n// will be supported by the library.\nfunc UnsafeApplyMsgOptions(token, channel, apiurl string, options ...MsgOption) (string, url.Values, error) {\n\tconfig, err := applyMsgOptions(token, channel, apiurl, options...)\n\treturn config.endpoint, config.values, err\n}\n\nfunc applyMsgOptions(token, channel, apiurl string, options ...MsgOption) (sendConfig, error) {\n\tconfig := sendConfig{\n\t\tapiurl:   apiurl,\n\t\tendpoint: apiurl + string(chatPostMessage),\n\t\tvalues: url.Values{\n\t\t\t\"token\":   {token},\n\t\t\t\"channel\": {channel},\n\t\t},\n\t}\n\n\tfor _, opt := range options {\n\t\tif err := opt(&config); err != nil {\n\t\t\treturn config, err\n\t\t}\n\t}\n\n\treturn config, nil\n}\n\nfunc buildSender(apiurl string, options ...MsgOption) sendConfig {\n\treturn sendConfig{\n\t\tapiurl:  apiurl,\n\t\toptions: options,\n\t}\n}\n\ntype sendMode string\n\nconst (\n\tchatUpdate          sendMode = \"chat.update\"\n\tchatPostMessage     sendMode = \"chat.postMessage\"\n\tchatScheduleMessage sendMode = \"chat.scheduleMessage\"\n\tchatDelete          sendMode = \"chat.delete\"\n\tchatPostEphemeral   sendMode = \"chat.postEphemeral\"\n\tchatResponse        sendMode = \"chat.responseURL\"\n\tchatMeMessage       sendMode = \"chat.meMessage\"\n\tchatUnfurl          sendMode = \"chat.unfurl\"\n)\n\ntype sendConfig struct {\n\tapiurl          string\n\toptions         []MsgOption\n\tmode            sendMode\n\tendpoint        string\n\tvalues          url.Values\n\tattachments     []Attachment\n\tmetadata        SlackMetadata\n\tblocks          Blocks\n\tresponseType    string\n\treplaceOriginal bool\n\tdeleteOriginal  bool\n}\n\nfunc (t sendConfig) BuildRequest(token, channelID string) (req *http.Request, _ func(*chatResponseFull) responseParser, err error) {\n\treturn t.BuildRequestContext(context.Background(), token, channelID)\n}\n\nfunc (t sendConfig) BuildRequestContext(ctx context.Context, token, channelID string) (req *http.Request, _ func(*chatResponseFull) responseParser, err error) {\n\tif t, err = applyMsgOptions(token, channelID, t.apiurl, t.options...); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tswitch t.mode {\n\tcase chatResponse:\n\t\treturn responseURLSender{\n\t\t\tendpoint:        t.endpoint,\n\t\t\tvalues:          t.values,\n\t\t\tattachments:     t.attachments,\n\t\t\tmetadata:        t.metadata,\n\t\t\tblocks:          t.blocks,\n\t\t\tresponseType:    t.responseType,\n\t\t\treplaceOriginal: t.replaceOriginal,\n\t\t\tdeleteOriginal:  t.deleteOriginal,\n\t\t}.BuildRequestContext(ctx)\n\tdefault:\n\t\treturn formSender{endpoint: t.endpoint, values: t.values}.BuildRequestContext(ctx)\n\t}\n}\n\ntype formSender struct {\n\tendpoint string\n\tvalues   url.Values\n}\n\nfunc (t formSender) BuildRequest() (*http.Request, func(*chatResponseFull) responseParser, error) {\n\treturn t.BuildRequestContext(context.Background())\n}\n\nfunc (t formSender) BuildRequestContext(ctx context.Context) (*http.Request, func(*chatResponseFull) responseParser, error) {\n\treq, err := formReq(ctx, t.endpoint, t.values)\n\treturn req, func(resp *chatResponseFull) responseParser {\n\t\treturn newJSONParser(resp)\n\t}, err\n}\n\ntype responseURLSender struct {\n\tendpoint        string\n\tvalues          url.Values\n\tattachments     []Attachment\n\tmetadata        SlackMetadata\n\tblocks          Blocks\n\tresponseType    string\n\treplaceOriginal bool\n\tdeleteOriginal  bool\n}\n\nfunc (t responseURLSender) BuildRequest() (*http.Request, func(*chatResponseFull) responseParser, error) {\n\treturn t.BuildRequestContext(context.Background())\n}\n\nfunc (t responseURLSender) BuildRequestContext(ctx context.Context) (*http.Request, func(*chatResponseFull) responseParser, error) {\n\treq, err := jsonReq(ctx, t.endpoint, Msg{\n\t\tText:            t.values.Get(\"text\"),\n\t\tTimestamp:       t.values.Get(\"ts\"),\n\t\tThreadTimestamp: t.values.Get(\"thread_ts\"),\n\t\tAttachments:     t.attachments,\n\t\tBlocks:          t.blocks,\n\t\tMetadata:        t.metadata,\n\t\tResponseType:    t.responseType,\n\t\tReplaceOriginal: t.replaceOriginal,\n\t\tDeleteOriginal:  t.deleteOriginal,\n\t})\n\treturn req, func(resp *chatResponseFull) responseParser {\n\t\treturn newContentTypeParser(resp)\n\t}, err\n}\n\n// MsgOption option provided when sending a message.\ntype MsgOption func(*sendConfig) error\n\n// MsgOptionSchedule schedules a messages.\nfunc MsgOptionSchedule(postAt string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatScheduleMessage)\n\t\tconfig.values.Add(\"post_at\", postAt)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionPost posts a messages, this is the default.\nfunc MsgOptionPost() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatPostMessage)\n\t\tconfig.values.Del(\"ts\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionPostEphemeral - posts an ephemeral message to the provided user.\nfunc MsgOptionPostEphemeral(userID string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatPostEphemeral)\n\t\tMsgOptionUser(userID)(config)\n\t\tconfig.values.Del(\"ts\")\n\n\t\treturn nil\n\t}\n}\n\n// MsgOptionMeMessage posts a \"me message\" type from the calling user\nfunc MsgOptionMeMessage() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatMeMessage)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionUpdate updates a message based on the timestamp.\nfunc MsgOptionUpdate(timestamp string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatUpdate)\n\t\tconfig.values.Add(\"ts\", timestamp)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionDelete deletes a message based on the timestamp.\nfunc MsgOptionDelete(timestamp string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatDelete)\n\t\tconfig.values.Add(\"ts\", timestamp)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionUnfurl unfurls a message based on the timestamp.\nfunc MsgOptionUnfurl(timestamp string, unfurls map[string]Attachment) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n\t\tconfig.values.Add(\"ts\", timestamp)\n\t\tunfurlsStr, err := json.Marshal(unfurls)\n\t\tif err == nil {\n\t\t\tconfig.values.Add(\"unfurls\", string(unfurlsStr))\n\t\t}\n\t\treturn err\n\t}\n}\n\n// MsgOptionUnfurlAuthURL unfurls a message using an auth url based on the timestamp.\nfunc MsgOptionUnfurlAuthURL(timestamp string, userAuthURL string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n\t\tconfig.values.Add(\"ts\", timestamp)\n\t\tconfig.values.Add(\"user_auth_url\", userAuthURL)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionUnfurlAuthRequired requests that the user installs the\n// Slack app for unfurling.\nfunc MsgOptionUnfurlAuthRequired(timestamp string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n\t\tconfig.values.Add(\"ts\", timestamp)\n\t\tconfig.values.Add(\"user_auth_required\", \"true\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionUnfurlAuthMessage attaches a message inviting the user to\n// authenticate.\nfunc MsgOptionUnfurlAuthMessage(timestamp string, msg string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n\t\tconfig.values.Add(\"ts\", timestamp)\n\t\tconfig.values.Add(\"user_auth_message\", msg)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionResponseURL supplies a url to use as the endpoint.\nfunc MsgOptionResponseURL(url string, responseType string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.mode = chatResponse\n\t\tconfig.endpoint = url\n\t\tconfig.responseType = responseType\n\t\tconfig.values.Del(\"ts\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionReplaceOriginal replaces original message with response url\nfunc MsgOptionReplaceOriginal(responseURL string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.mode = chatResponse\n\t\tconfig.endpoint = responseURL\n\t\tconfig.replaceOriginal = true\n\t\treturn nil\n\t}\n}\n\n// MsgOptionDeleteOriginal deletes original message with response url\nfunc MsgOptionDeleteOriginal(responseURL string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.mode = chatResponse\n\t\tconfig.endpoint = responseURL\n\t\tconfig.deleteOriginal = true\n\t\treturn nil\n\t}\n}\n\n// MsgOptionAsUser whether or not to send the message as the user.\nfunc MsgOptionAsUser(b bool) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tif b != DEFAULT_MESSAGE_ASUSER {\n\t\t\tconfig.values.Set(\"as_user\", \"true\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// MsgOptionUser set the user for the message.\nfunc MsgOptionUser(userID string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"user\", userID)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionUsername set the username for the message.\nfunc MsgOptionUsername(username string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"username\", username)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionText provide the text for the message, optionally escape the provided\n// text.\nfunc MsgOptionText(text string, escape bool) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tif escape {\n\t\t\ttext = slackutilsx.EscapeMessage(text)\n\t\t}\n\t\tconfig.values.Add(\"text\", text)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionAttachments provide attachments for the message.\nfunc MsgOptionAttachments(attachments ...Attachment) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tif attachments == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tconfig.attachments = attachments\n\n\t\t// FIXME: We are setting the attachments on the message twice: above for\n\t\t// the json version, and below for the html version.  The marshalled bytes\n\t\t// we put into config.values below don't work directly in the Msg version.\n\n\t\tattachmentBytes, err := json.Marshal(attachments)\n\t\tif err == nil {\n\t\t\tconfig.values.Set(\"attachments\", string(attachmentBytes))\n\t\t}\n\n\t\treturn err\n\t}\n}\n\n// MsgOptionBlocks sets blocks for the message\nfunc MsgOptionBlocks(blocks ...Block) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tif blocks == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tconfig.blocks.BlockSet = append(config.blocks.BlockSet, blocks...)\n\n\t\tblocks, err := json.Marshal(blocks)\n\t\tif err == nil {\n\t\t\tconfig.values.Set(\"blocks\", string(blocks))\n\t\t}\n\t\treturn err\n\t}\n}\n\n// MsgOptionEnableLinkUnfurl enables link unfurling\nfunc MsgOptionEnableLinkUnfurl() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"unfurl_links\", \"true\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionDisableLinkUnfurl disables link unfurling\nfunc MsgOptionDisableLinkUnfurl() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"unfurl_links\", \"false\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionDisableMediaUnfurl disables media unfurling.\nfunc MsgOptionDisableMediaUnfurl() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"unfurl_media\", \"false\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionDisableMarkdown disables markdown.\nfunc MsgOptionDisableMarkdown() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"mrkdwn\", \"false\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionTS sets the thread TS of the message to enable creating or replying to a thread\nfunc MsgOptionTS(ts string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"thread_ts\", ts)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionBroadcast sets reply_broadcast to true\nfunc MsgOptionBroadcast() MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"reply_broadcast\", \"true\")\n\t\treturn nil\n\t}\n}\n\n// MsgOptionCompose combines multiple options into a single option.\nfunc MsgOptionCompose(options ...MsgOption) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tfor _, opt := range options {\n\t\t\tif err := opt(config); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// MsgOptionParse set parse option.\nfunc MsgOptionParse(b bool) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tvar v string\n\t\tif b {\n\t\t\tv = \"full\"\n\t\t} else {\n\t\t\tv = \"none\"\n\t\t}\n\t\tconfig.values.Set(\"parse\", v)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionIconURL sets an icon URL\nfunc MsgOptionIconURL(iconURL string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"icon_url\", iconURL)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionIconEmoji sets an icon emoji\nfunc MsgOptionIconEmoji(iconEmoji string) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"icon_emoji\", iconEmoji)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionMetadata sets message metadata\nfunc MsgOptionMetadata(metadata SlackMetadata) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.metadata = metadata\n\t\tmeta, err := json.Marshal(metadata)\n\t\tif err == nil {\n\t\t\tconfig.values.Set(\"metadata\", string(meta))\n\t\t}\n\t\treturn err\n\t}\n}\n\n// MsgOptionLinkNames finds and links user groups. Does not support linking individual users\nfunc MsgOptionLinkNames(linkName bool) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.values.Set(\"link_names\", strconv.FormatBool(linkName))\n\t\treturn nil\n\t}\n}\n\n// UnsafeMsgOptionEndpoint deliver the message to the specified endpoint.\n// NOTE: USE AT YOUR OWN RISK: No issues relating to the use of this Option\n// will be supported by the library, it is subject to change without notice that\n// may result in compilation errors or runtime behaviour changes.\nfunc UnsafeMsgOptionEndpoint(endpoint string, update func(url.Values)) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tconfig.endpoint = endpoint\n\t\tupdate(config.values)\n\t\treturn nil\n\t}\n}\n\n// MsgOptionPostMessageParameters maintain backwards compatibility.\nfunc MsgOptionPostMessageParameters(params PostMessageParameters) MsgOption {\n\treturn func(config *sendConfig) error {\n\t\tif params.Username != DEFAULT_MESSAGE_USERNAME {\n\t\t\tconfig.values.Set(\"username\", params.Username)\n\t\t}\n\n\t\t// chat.postEphemeral support\n\t\tif params.User != DEFAULT_MESSAGE_USERNAME {\n\t\t\tconfig.values.Set(\"user\", params.User)\n\t\t}\n\n\t\t// never generates an error.\n\t\tMsgOptionAsUser(params.AsUser)(config)\n\n\t\tif params.Parse != DEFAULT_MESSAGE_PARSE {\n\t\t\tconfig.values.Set(\"parse\", params.Parse)\n\t\t}\n\t\tif params.LinkNames != DEFAULT_MESSAGE_LINK_NAMES {\n\t\t\tconfig.values.Set(\"link_names\", \"1\")\n\t\t}\n\n\t\tif params.UnfurlLinks != DEFAULT_MESSAGE_UNFURL_LINKS {\n\t\t\tconfig.values.Set(\"unfurl_links\", \"true\")\n\t\t}\n\n\t\t// I want to send a message with explicit `as_user` `true` and `unfurl_links` `false` in request.\n\t\t// Because setting `as_user` to `true` will change the default value for `unfurl_links` to `true` on Slack API side.\n\t\tif params.AsUser != DEFAULT_MESSAGE_ASUSER && params.UnfurlLinks == DEFAULT_MESSAGE_UNFURL_LINKS {\n\t\t\tconfig.values.Set(\"unfurl_links\", \"false\")\n\t\t}\n\t\tif params.UnfurlMedia != DEFAULT_MESSAGE_UNFURL_MEDIA {\n\t\t\tconfig.values.Set(\"unfurl_media\", \"false\")\n\t\t}\n\t\tif params.IconURL != DEFAULT_MESSAGE_ICON_URL {\n\t\t\tconfig.values.Set(\"icon_url\", params.IconURL)\n\t\t}\n\t\tif params.IconEmoji != DEFAULT_MESSAGE_ICON_EMOJI {\n\t\t\tconfig.values.Set(\"icon_emoji\", params.IconEmoji)\n\t\t}\n\t\tif params.Markdown != DEFAULT_MESSAGE_MARKDOWN {\n\t\t\tconfig.values.Set(\"mrkdwn\", \"false\")\n\t\t}\n\n\t\tif params.ThreadTimestamp != DEFAULT_MESSAGE_THREAD_TIMESTAMP {\n\t\t\tconfig.values.Set(\"thread_ts\", params.ThreadTimestamp)\n\t\t}\n\t\tif params.ReplyBroadcast != DEFAULT_MESSAGE_REPLY_BROADCAST {\n\t\t\tconfig.values.Set(\"reply_broadcast\", \"true\")\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// PermalinkParameters are the parameters required to get a permalink to a message.\ntype PermalinkParameters struct {\n\tChannel string\n\tTs      string\n}\n\n// GetPermalink returns the permalink for a message. It takes PermalinkParameters and returns a string containing the\n// permalink. It returns an error if unable to retrieve the permalink.\n// For more details, see GetPermalinkContext documentation.\nfunc (api *Client) GetPermalink(params *PermalinkParameters) (string, error) {\n\treturn api.GetPermalinkContext(context.Background(), params)\n}\n\n// GetPermalinkContext returns the permalink for a message using a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.getPermalink\nfunc (api *Client) GetPermalinkContext(ctx context.Context, params *PermalinkParameters) (string, error) {\n\tvalues := url.Values{\n\t\t\"channel\":    {params.Channel},\n\t\t\"message_ts\": {params.Ts},\n\t}\n\n\tresponse := struct {\n\t\tChannel   string `json:\"channel\"`\n\t\tPermalink string `json:\"permalink\"`\n\t\tSlackResponse\n\t}{}\n\terr := api.getMethod(ctx, \"chat.getPermalink\", api.token, values, &response)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn response.Permalink, response.Err()\n}\n\ntype GetScheduledMessagesParameters struct {\n\tChannel string\n\tTeamID  string\n\tCursor  string\n\tLatest  string\n\tLimit   int\n\tOldest  string\n}\n\n// GetScheduledMessages returns the list of scheduled messages based on params.\n// For more details, see GetScheduledMessagesContext documentation.\nfunc (api *Client) GetScheduledMessages(params *GetScheduledMessagesParameters) (channels []ScheduledMessage, nextCursor string, err error) {\n\treturn api.GetScheduledMessagesContext(context.Background(), params)\n}\n\n// GetScheduledMessagesContext returns the list of scheduled messages based on params with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.getScheduledMessages.list\nfunc (api *Client) GetScheduledMessagesContext(ctx context.Context, params *GetScheduledMessagesParameters) (channels []ScheduledMessage, nextCursor string, err error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.Channel != \"\" {\n\t\tvalues.Add(\"channel\", params.Channel)\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Latest != \"\" {\n\t\tvalues.Add(\"latest\", params.Latest)\n\t}\n\tif params.Oldest != \"\" {\n\t\tvalues.Add(\"oldest\", params.Oldest)\n\t}\n\tresponse := struct {\n\t\tMessages         []ScheduledMessage `json:\"scheduled_messages\"`\n\t\tResponseMetaData responseMetaData   `json:\"response_metadata\"`\n\t\tSlackResponse\n\t}{}\n\n\terr = api.postMethod(ctx, \"chat.scheduledMessages.list\", values, &response)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn response.Messages, response.ResponseMetaData.NextCursor, response.Err()\n}\n\ntype DeleteScheduledMessageParameters struct {\n\tChannel            string\n\tScheduledMessageID string\n\tAsUser             bool\n}\n\n// DeleteScheduledMessage deletes a pending scheduled message.\n// For more details, see DeleteScheduledMessageContext documentation.\nfunc (api *Client) DeleteScheduledMessage(params *DeleteScheduledMessageParameters) (bool, error) {\n\treturn api.DeleteScheduledMessageContext(context.Background(), params)\n}\n\n// DeleteScheduledMessageContext deletes a pending scheduled message with a custom context.\n// Slack API docs: https://api.slack.com/methods/chat.deleteScheduledMessage\nfunc (api *Client) DeleteScheduledMessageContext(ctx context.Context, params *DeleteScheduledMessageParameters) (bool, error) {\n\tvalues := url.Values{\n\t\t\"token\":                {api.token},\n\t\t\"channel\":              {params.Channel},\n\t\t\"scheduled_message_id\": {params.ScheduledMessageID},\n\t\t\"as_user\":              {strconv.FormatBool(params.AsUser)},\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"chat.deleteScheduledMessage\", values, &response)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn response.Ok, response.Err()\n}\n"
        },
        {
          "name": "chat_test.go",
          "type": "blob",
          "size": 10.361328125,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc postMessageInvalidChannelHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(chatResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: false, Error: \"channel_not_found\"},\n\t})\n\trw.Write(response)\n}\n\nfunc TestPostMessageInvalidChannel(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/chat.postMessage\", postMessageInvalidChannelHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, _, err := api.PostMessage(\"CXXXXXXXX\", MsgOptionText(\"hello\", false))\n\tif err == nil {\n\t\tt.Errorf(\"Expected error: channel_not_found; instead succeeded\")\n\t\treturn\n\t}\n\n\tif err.Error() != \"channel_not_found\" {\n\t\tt.Errorf(\"Expected error: channel_not_found; received: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc TestGetPermalink(t *testing.T) {\n\tchannel := \"C1H9RESGA\"\n\ttimeStamp := \"p135854651500008\"\n\n\thttp.HandleFunc(\"/chat.getPermalink\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tif got, want := r.Header.Get(\"Content-Type\"), \"application/x-www-form-urlencoded\"; got != want {\n\t\t\tt.Errorf(\"request uses unexpected content type: got %s, want %s\", got, want)\n\t\t}\n\n\t\tif got, want := r.URL.Query().Get(\"channel\"), channel; got != want {\n\t\t\tt.Errorf(\"request contains unexpected channel: got %s, want %s\", got, want)\n\t\t}\n\n\t\tif got, want := r.URL.Query().Get(\"message_ts\"), timeStamp; got != want {\n\t\t\tt.Errorf(\"request contains unexpected message timestamp: got %s, want %s\", got, want)\n\t\t}\n\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tresponse := []byte(\"{\\\"ok\\\": true, \\\"channel\\\": \\\"\" + channel + \"\\\", \\\"permalink\\\": \\\"https://ghostbusters.slack.com/archives/\" + channel + \"/\" + timeStamp + \"\\\"}\")\n\t\trw.Write(response)\n\t})\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tpp := PermalinkParameters{Channel: channel, Ts: timeStamp}\n\tpl, err := api.GetPermalink(&pp)\n\n\tif got, want := pl, \"https://ghostbusters.slack.com/archives/C1H9RESGA/p135854651500008\"; got != want {\n\t\tt.Errorf(\"unexpected permalink: got %s, want %s\", got, want)\n\t}\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error returned: %v\", err)\n\t}\n}\n\nfunc TestPostMessage(t *testing.T) {\n\ttype messageTest struct {\n\t\tendpoint string\n\t\topt      []MsgOption\n\t\texpected url.Values\n\t}\n\n\tblocks := []Block{NewContextBlock(\"context\", NewTextBlockObject(PlainTextType, \"hello\", false, false))}\n\tblockStr := `[{\"type\":\"context\",\"block_id\":\"context\",\"elements\":[{\"type\":\"plain_text\",\"text\":\"hello\"}]}]`\n\n\ttests := map[string]messageTest{\n\t\t\"OnlyBasicProperties\": {\n\t\t\tendpoint: \"/chat.postMessage\",\n\t\t\topt:      []MsgOption{},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\": []string{\"CXXX\"},\n\t\t\t\t\"token\":   []string{\"testing-token\"},\n\t\t\t},\n\t\t},\n\t\t\"Blocks\": {\n\t\t\tendpoint: \"/chat.postMessage\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionBlocks(blocks...),\n\t\t\t\tMsgOptionText(\"text\", false),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"blocks\":  []string{blockStr},\n\t\t\t\t\"channel\": []string{\"CXXX\"},\n\t\t\t\t\"text\":    []string{\"text\"},\n\t\t\t\t\"token\":   []string{\"testing-token\"},\n\t\t\t},\n\t\t},\n\t\t\"Attachment\": {\n\t\t\tendpoint: \"/chat.postMessage\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionAttachments(\n\t\t\t\t\tAttachment{\n\t\t\t\t\t\tBlocks: Blocks{BlockSet: blocks},\n\t\t\t\t\t}),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"attachments\": []string{`[{\"blocks\":` + blockStr + `}]`},\n\t\t\t\t\"channel\":     []string{\"CXXX\"},\n\t\t\t\t\"token\":       []string{\"testing-token\"},\n\t\t\t},\n\t\t},\n\t\t\"Metadata\": {\n\t\t\tendpoint: \"/chat.postMessage\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionMetadata(\n\t\t\t\t\tSlackMetadata{\n\t\t\t\t\t\tEventType: \"testing-event\",\n\t\t\t\t\t\tEventPayload: map[string]interface{}{\n\t\t\t\t\t\t\t\"id\":   13,\n\t\t\t\t\t\t\t\"name\": \"testing-name\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"metadata\": []string{`{\"event_type\":\"testing-event\",\"event_payload\":{\"id\":13,\"name\":\"testing-name\"}}`},\n\t\t\t\t\"channel\":  []string{\"CXXX\"},\n\t\t\t\t\"token\":    []string{\"testing-token\"},\n\t\t\t},\n\t\t},\n\t\t\"Unfurl\": {\n\t\t\tendpoint: \"/chat.unfurl\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionUnfurl(\"123\", map[string]Attachment{\"something\": {Text: \"attachment-test\"}}),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\": []string{\"CXXX\"},\n\t\t\t\t\"token\":   []string{\"testing-token\"},\n\t\t\t\t\"ts\":      []string{\"123\"},\n\t\t\t\t\"unfurls\": []string{`{\"something\":{\"text\":\"attachment-test\",\"blocks\":null}}`},\n\t\t\t},\n\t\t},\n\t\t\"UnfurlAuthURL\": {\n\t\t\tendpoint: \"/chat.unfurl\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionUnfurlAuthURL(\"123\", \"https://auth-url.com\"),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\":       []string{\"CXXX\"},\n\t\t\t\t\"token\":         []string{\"testing-token\"},\n\t\t\t\t\"ts\":            []string{\"123\"},\n\t\t\t\t\"user_auth_url\": []string{\"https://auth-url.com\"},\n\t\t\t},\n\t\t},\n\t\t\"UnfurlAuthRequired\": {\n\t\t\tendpoint: \"/chat.unfurl\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionUnfurlAuthRequired(\"123\"),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\":            []string{\"CXXX\"},\n\t\t\t\t\"token\":              []string{\"testing-token\"},\n\t\t\t\t\"ts\":                 []string{\"123\"},\n\t\t\t\t\"user_auth_required\": []string{\"true\"},\n\t\t\t},\n\t\t},\n\t\t\"UnfurlAuthMessage\": {\n\t\t\tendpoint: \"/chat.unfurl\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionUnfurlAuthMessage(\"123\", \"Please!\"),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\":           []string{\"CXXX\"},\n\t\t\t\t\"token\":             []string{\"testing-token\"},\n\t\t\t\t\"ts\":                []string{\"123\"},\n\t\t\t\t\"user_auth_message\": []string{\"Please!\"},\n\t\t\t},\n\t\t},\n\t\t\"LinkNames true\": {\n\t\t\tendpoint: \"/chat.postMessage\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionLinkNames(true),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\":    []string{\"CXXX\"},\n\t\t\t\t\"token\":      []string{\"testing-token\"},\n\t\t\t\t\"link_names\": []string{\"true\"},\n\t\t\t},\n\t\t},\n\t\t\"LinkNames false\": {\n\t\t\tendpoint: \"/chat.postMessage\",\n\t\t\topt: []MsgOption{\n\t\t\t\tMsgOptionLinkNames(false),\n\t\t\t},\n\t\t\texpected: url.Values{\n\t\t\t\t\"channel\":    []string{\"CXXX\"},\n\t\t\t\t\"token\":      []string{\"testing-token\"},\n\t\t\t\t\"link_names\": []string{\"false\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tonce.Do(startServer)\n\tapi := New(validToken, OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tfor name, test := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\thttp.DefaultServeMux = new(http.ServeMux)\n\t\t\thttp.HandleFunc(test.endpoint, func(rw http.ResponseWriter, r *http.Request) {\n\t\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tactual, err := url.ParseQuery(string(body))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(actual, test.expected) {\n\t\t\t\t\tt.Errorf(\"\\nexpected: %s\\n  actual: %s\", test.expected, actual)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t_, _, _ = api.PostMessage(\"CXXX\", test.opt...)\n\t\t})\n\t}\n}\n\nfunc TestPostMessageWithBlocksWhenMsgOptionResponseURLApplied(t *testing.T) {\n\texpectedBlocks := []Block{NewContextBlock(\"context\", NewTextBlockObject(PlainTextType, \"hello\", false, false))}\n\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/response-url\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg Msg\n\t\tif err := json.Unmarshal(body, &msg); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tactualBlocks := msg.Blocks.BlockSet\n\t\tif !reflect.DeepEqual(expectedBlocks, actualBlocks) {\n\t\t\tt.Errorf(\"expected: %#v, got: %#v\", expectedBlocks, actualBlocks)\n\t\t\treturn\n\t\t}\n\t})\n\n\tonce.Do(startServer)\n\tapi := New(validToken, OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tresponseURL := api.endpoint + \"response-url\"\n\n\t_, _, _ = api.PostMessage(\"CXXX\", MsgOptionBlocks(expectedBlocks...), MsgOptionText(\"text\", false), MsgOptionResponseURL(responseURL, ResponseTypeInChannel))\n}\n\nfunc TestPostMessageWhenMsgOptionReplaceOriginalApplied(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/response-url\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg Msg\n\t\tif err := json.Unmarshal(body, &msg); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif msg.ReplaceOriginal != true {\n\t\t\tt.Errorf(\"expected: true, got: %v\", msg.ReplaceOriginal)\n\t\t\treturn\n\t\t}\n\t})\n\n\tonce.Do(startServer)\n\tapi := New(validToken, OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tresponseURL := api.endpoint + \"response-url\"\n\n\t_, _, _ = api.PostMessage(\"CXXX\", MsgOptionText(\"text\", false), MsgOptionReplaceOriginal(responseURL))\n}\n\nfunc TestPostMessageWhenMsgOptionDeleteOriginalApplied(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/response-url\", func(rw http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tvar msg Msg\n\t\tif err := json.Unmarshal(body, &msg); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif msg.DeleteOriginal != true {\n\t\t\tt.Errorf(\"expected: true, got: %v\", msg.DeleteOriginal)\n\t\t\treturn\n\t\t}\n\t})\n\n\tonce.Do(startServer)\n\tapi := New(validToken, OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tresponseURL := api.endpoint + \"response-url\"\n\n\t_, _, _ = api.PostMessage(\"CXXX\", MsgOptionDeleteOriginal(responseURL))\n}\n\nfunc TestSendMessageContextRedactsTokenInDebugLog(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ttoken string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"regular token\",\n\t\t\ttoken: \"xtest-token-1234-abcd\",\n\t\t\twant:  \"xtest-REDACTED\",\n\t\t},\n\t\t{\n\t\t\tname:  \"refresh token\",\n\t\t\ttoken: \"xoxe.xtest-token-1234-abcd\",\n\t\t\twant:  \"xoxe.xtest-REDACTED\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tonce.Do(startServer)\n\t\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\t\topts := []Option{\n\t\t\t\tOptionAPIURL(\"http://\" + serverAddr + \"/\"),\n\t\t\t\tOptionLog(log.New(buf, \"\", log.Lshortfile)),\n\t\t\t\tOptionDebug(true),\n\t\t\t}\n\t\t\tapi := New(tt.token, opts...)\n\t\t\t// Why send the token in the message text too? To test that we're not\n\t\t\t// redacting substrings in the request which look like a token but aren't.\n\t\t\tapi.SendMessage(\"CXXX\", MsgOptionText(token, false))\n\t\t\ts := buf.String()\n\n\t\t\tre := regexp.MustCompile(`token=[\\w.-]*`)\n\t\t\twant := \"token=\" + tt.want\n\t\t\tif got := re.FindString(s); got != want {\n\t\t\t\tt.Errorf(\"Logged token in SendMessageContext(): got %q, want %q\", got, want)\n\t\t\t}\n\t\t\tre = regexp.MustCompile(`text=[\\w.-]*`)\n\t\t\twant = \"text=\" + token\n\t\t\tif got := re.FindString(s); got != want {\n\t\t\t\tt.Errorf(\"Logged text in SendMessageContext(): got %q, want %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "comment.go",
          "type": "blob",
          "size": 0.322265625,
          "content": "package slack\n\n// Comment contains all the information relative to a comment\ntype Comment struct {\n\tID        string   `json:\"id,omitempty\"`\n\tCreated   JSONTime `json:\"created,omitempty\"`\n\tTimestamp JSONTime `json:\"timestamp,omitempty\"`\n\tUser      string   `json:\"user,omitempty\"`\n\tComment   string   `json:\"comment,omitempty\"`\n}\n"
        },
        {
          "name": "conversation.go",
          "type": "blob",
          "size": 29.04296875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Conversation is the foundation for IM and BaseGroupConversation\ntype Conversation struct {\n\tID                 string   `json:\"id\"`\n\tCreated            JSONTime `json:\"created\"`\n\tIsOpen             bool     `json:\"is_open\"`\n\tLastRead           string   `json:\"last_read,omitempty\"`\n\tLatest             *Message `json:\"latest,omitempty\"`\n\tUnreadCount        int      `json:\"unread_count,omitempty\"`\n\tUnreadCountDisplay int      `json:\"unread_count_display,omitempty\"`\n\tIsGroup            bool     `json:\"is_group\"`\n\tIsShared           bool     `json:\"is_shared\"`\n\tIsIM               bool     `json:\"is_im\"`\n\tIsExtShared        bool     `json:\"is_ext_shared\"`\n\tIsOrgShared        bool     `json:\"is_org_shared\"`\n\tIsGlobalShared     bool     `json:\"is_global_shared\"`\n\tIsPendingExtShared bool     `json:\"is_pending_ext_shared\"`\n\tIsPrivate          bool     `json:\"is_private\"`\n\tIsReadOnly         bool     `json:\"is_read_only\"`\n\tIsMpIM             bool     `json:\"is_mpim\"`\n\tUnlinked           int      `json:\"unlinked\"`\n\tNameNormalized     string   `json:\"name_normalized\"`\n\tNumMembers         int      `json:\"num_members\"`\n\tPriority           float64  `json:\"priority\"`\n\tUser               string   `json:\"user\"`\n\tConnectedTeamIDs   []string `json:\"connected_team_ids,omitempty\"`\n\tSharedTeamIDs      []string `json:\"shared_team_ids,omitempty\"`\n\tInternalTeamIDs    []string `json:\"internal_team_ids,omitempty\"`\n\n\t// TODO support pending_shared\n\t// TODO support previous_names\n}\n\n// GroupConversation is the foundation for Group and Channel\ntype GroupConversation struct {\n\tConversation\n\tName       string   `json:\"name\"`\n\tCreator    string   `json:\"creator\"`\n\tIsArchived bool     `json:\"is_archived\"`\n\tMembers    []string `json:\"members\"`\n\tTopic      Topic    `json:\"topic\"`\n\tPurpose    Purpose  `json:\"purpose\"`\n}\n\n// Topic contains information about the topic\ntype Topic struct {\n\tValue   string   `json:\"value\"`\n\tCreator string   `json:\"creator\"`\n\tLastSet JSONTime `json:\"last_set\"`\n}\n\n// Purpose contains information about the purpose\ntype Purpose struct {\n\tValue   string   `json:\"value\"`\n\tCreator string   `json:\"creator\"`\n\tLastSet JSONTime `json:\"last_set\"`\n}\n\n// Properties contains the Canvas associated to the channel.\ntype Properties struct {\n\tCanvas Canvas `json:\"canvas\"`\n}\n\ntype Canvas struct {\n\tFileId       string `json:\"file_id\"`\n\tIsEmpty      bool   `json:\"is_empty\"`\n\tQuipThreadId string `json:\"quip_thread_id\"`\n}\n\ntype GetUsersInConversationParameters struct {\n\tChannelID string\n\tCursor    string\n\tLimit     int\n}\n\ntype GetConversationsForUserParameters struct {\n\tUserID          string\n\tCursor          string\n\tTypes           []string\n\tLimit           int\n\tExcludeArchived bool\n\tTeamID          string\n}\n\ntype responseMetaData struct {\n\tNextCursor string `json:\"next_cursor\"`\n}\n\n// GetUsersInConversation returns the list of users in a conversation.\n// For more details, see GetUsersInConversationContext documentation.\nfunc (api *Client) GetUsersInConversation(params *GetUsersInConversationParameters) ([]string, string, error) {\n\treturn api.GetUsersInConversationContext(context.Background(), params)\n}\n\n// GetUsersInConversationContext returns the list of users in a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.members\nfunc (api *Client) GetUsersInConversationContext(ctx context.Context, params *GetUsersInConversationParameters) ([]string, string, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {params.ChannelID},\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tresponse := struct {\n\t\tMembers          []string         `json:\"members\"`\n\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.members\", values, &response)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif err := response.Err(); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn response.Members, response.ResponseMetaData.NextCursor, nil\n}\n\n// GetConversationsForUser returns the list conversations for a given user.\n// For more details, see GetConversationsForUserContext documentation.\nfunc (api *Client) GetConversationsForUser(params *GetConversationsForUserParameters) (channels []Channel, nextCursor string, err error) {\n\treturn api.GetConversationsForUserContext(context.Background(), params)\n}\n\n// GetConversationsForUserContext returns the list conversations for a given user with a custom context\n// Slack API docs: https://api.slack.com/methods/users.conversations\nfunc (api *Client) GetConversationsForUserContext(ctx context.Context, params *GetConversationsForUserParameters) (channels []Channel, nextCursor string, err error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.UserID != \"\" {\n\t\tvalues.Add(\"user\", params.UserID)\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Types != nil {\n\t\tvalues.Add(\"types\", strings.Join(params.Types, \",\"))\n\t}\n\tif params.ExcludeArchived {\n\t\tvalues.Add(\"exclude_archived\", \"true\")\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\n\tresponse := struct {\n\t\tChannels         []Channel        `json:\"channels\"`\n\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n\t\tSlackResponse\n\t}{}\n\terr = api.postMethod(ctx, \"users.conversations\", values, &response)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn response.Channels, response.ResponseMetaData.NextCursor, response.Err()\n}\n\n// ArchiveConversation archives a conversation.\n// For more details, see ArchiveConversationContext documentation.\nfunc (api *Client) ArchiveConversation(channelID string) error {\n\treturn api.ArchiveConversationContext(context.Background(), channelID)\n}\n\n// ArchiveConversationContext archives a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.archive\nfunc (api *Client) ArchiveConversationContext(ctx context.Context, channelID string) error {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t}\n\n\tresponse := SlackResponse{}\n\terr := api.postMethod(ctx, \"conversations.archive\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// UnArchiveConversation reverses conversation archival.\n// For more details, see UnArchiveConversationContext documentation.\nfunc (api *Client) UnArchiveConversation(channelID string) error {\n\treturn api.UnArchiveConversationContext(context.Background(), channelID)\n}\n\n// UnArchiveConversationContext reverses conversation archival with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.unarchive\nfunc (api *Client) UnArchiveConversationContext(ctx context.Context, channelID string) error {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t}\n\tresponse := SlackResponse{}\n\terr := api.postMethod(ctx, \"conversations.unarchive\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// SetTopicOfConversation sets the topic for a conversation.\n// For more details, see SetTopicOfConversationContext documentation.\nfunc (api *Client) SetTopicOfConversation(channelID, topic string) (*Channel, error) {\n\treturn api.SetTopicOfConversationContext(context.Background(), channelID, topic)\n}\n\n// SetTopicOfConversationContext sets the topic for a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.setTopic\nfunc (api *Client) SetTopicOfConversationContext(ctx context.Context, channelID, topic string) (*Channel, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t\t\"topic\":   {topic},\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tChannel *Channel `json:\"channel\"`\n\t}{}\n\terr := api.postMethod(ctx, \"conversations.setTopic\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.Channel, response.Err()\n}\n\n// SetPurposeOfConversation sets the purpose for a conversation.\n// For more details, see SetPurposeOfConversationContext documentation.\nfunc (api *Client) SetPurposeOfConversation(channelID, purpose string) (*Channel, error) {\n\treturn api.SetPurposeOfConversationContext(context.Background(), channelID, purpose)\n}\n\n// SetPurposeOfConversationContext sets the purpose for a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.setPurpose\nfunc (api *Client) SetPurposeOfConversationContext(ctx context.Context, channelID, purpose string) (*Channel, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t\t\"purpose\": {purpose},\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tChannel *Channel `json:\"channel\"`\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.setPurpose\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.Channel, response.Err()\n}\n\n// RenameConversation renames a conversation.\n// For more details, see RenameConversationContext documentation.\nfunc (api *Client) RenameConversation(channelID, channelName string) (*Channel, error) {\n\treturn api.RenameConversationContext(context.Background(), channelID, channelName)\n}\n\n// RenameConversationContext renames a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.rename\nfunc (api *Client) RenameConversationContext(ctx context.Context, channelID, channelName string) (*Channel, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t\t\"name\":    {channelName},\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tChannel *Channel `json:\"channel\"`\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.rename\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.Channel, response.Err()\n}\n\n// InviteUsersToConversation invites users to a channel.\n// For more details, see InviteUsersToConversation documentation.\nfunc (api *Client) InviteUsersToConversation(channelID string, users ...string) (*Channel, error) {\n\treturn api.InviteUsersToConversationContext(context.Background(), channelID, users...)\n}\n\n// InviteUsersToConversationContext invites users to a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.invite\nfunc (api *Client) InviteUsersToConversationContext(ctx context.Context, channelID string, users ...string) (*Channel, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t\t\"users\":   {strings.Join(users, \",\")},\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tChannel *Channel `json:\"channel\"`\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.invite\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.Channel, response.Err()\n}\n\n// InviteSharedEmailsToConversation invites users to a shared channels by email.\n// For more details, see InviteSharedToConversationContext documentation.\nfunc (api *Client) InviteSharedEmailsToConversation(channelID string, emails ...string) (string, bool, error) {\n\treturn api.InviteSharedToConversationContext(context.Background(), InviteSharedToConversationParams{\n\t\tChannelID: channelID,\n\t\tEmails:    emails,\n\t})\n}\n\n// InviteSharedEmailsToConversationContext invites users to a shared channels by email using context.\n// For more details, see InviteSharedToConversationContext documentation.\nfunc (api *Client) InviteSharedEmailsToConversationContext(ctx context.Context, channelID string, emails ...string) (string, bool, error) {\n\treturn api.InviteSharedToConversationContext(ctx, InviteSharedToConversationParams{\n\t\tChannelID: channelID,\n\t\tEmails:    emails,\n\t})\n}\n\n// InviteSharedUserIDsToConversation invites users to a shared channels by user id.\n// For more details, see InviteSharedToConversationContext documentation.\nfunc (api *Client) InviteSharedUserIDsToConversation(channelID string, userIDs ...string) (string, bool, error) {\n\treturn api.InviteSharedToConversationContext(context.Background(), InviteSharedToConversationParams{\n\t\tChannelID: channelID,\n\t\tUserIDs:   userIDs,\n\t})\n}\n\n// InviteSharedUserIDsToConversationContext invites users to a shared channels by user id with context.\n// For more details, see InviteSharedToConversationContext documentation.\nfunc (api *Client) InviteSharedUserIDsToConversationContext(ctx context.Context, channelID string, userIDs ...string) (string, bool, error) {\n\treturn api.InviteSharedToConversationContext(ctx, InviteSharedToConversationParams{\n\t\tChannelID: channelID,\n\t\tUserIDs:   userIDs,\n\t})\n}\n\n// InviteSharedToConversationParams defines the parameters for the InviteSharedToConversation and InviteSharedToConversationContext functions.\ntype InviteSharedToConversationParams struct {\n\tChannelID       string\n\tEmails          []string\n\tUserIDs         []string\n\tExternalLimited *bool\n}\n\n// InviteSharedToConversation invites emails or userIDs to a channel.\n// For more details, see InviteSharedToConversationContext documentation.\nfunc (api *Client) InviteSharedToConversation(params InviteSharedToConversationParams) (string, bool, error) {\n\treturn api.InviteSharedToConversationContext(context.Background(), params)\n}\n\n// InviteSharedToConversationContext invites emails or userIDs to a channel with a custom context.\n// This is a helper function for InviteSharedEmailsToConversation and InviteSharedUserIDsToConversation.\n// It accepts either emails or userIDs, but not both.\n// Slack API docs: https://api.slack.com/methods/conversations.inviteShared\nfunc (api *Client) InviteSharedToConversationContext(ctx context.Context, params InviteSharedToConversationParams) (string, bool, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {params.ChannelID},\n\t}\n\tif len(params.Emails) > 0 {\n\t\tvalues.Add(\"emails\", strings.Join(params.Emails, \",\"))\n\t} else if len(params.UserIDs) > 0 {\n\t\tvalues.Add(\"user_ids\", strings.Join(params.UserIDs, \",\"))\n\t}\n\tif params.ExternalLimited != nil {\n\t\tvalues.Add(\"external_limited\", strconv.FormatBool(*params.ExternalLimited))\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tInviteID              string `json:\"invite_id\"`\n\t\tIsLegacySharedChannel bool   `json:\"is_legacy_shared_channel\"`\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.inviteShared\", values, &response)\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\n\treturn response.InviteID, response.IsLegacySharedChannel, response.Err()\n}\n\n// KickUserFromConversation removes a user from a conversation.\n// For more details, see KickUserFromConversationContext documentation.\nfunc (api *Client) KickUserFromConversation(channelID string, user string) error {\n\treturn api.KickUserFromConversationContext(context.Background(), channelID, user)\n}\n\n// KickUserFromConversationContext removes a user from a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.kick\nfunc (api *Client) KickUserFromConversationContext(ctx context.Context, channelID string, user string) error {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t\t\"user\":    {user},\n\t}\n\n\tresponse := SlackResponse{}\n\terr := api.postMethod(ctx, \"conversations.kick\", values, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// CloseConversation closes a direct message or multi-person direct message.\n// For more details, see CloseConversationContext documentation.\nfunc (api *Client) CloseConversation(channelID string) (noOp bool, alreadyClosed bool, err error) {\n\treturn api.CloseConversationContext(context.Background(), channelID)\n}\n\n// CloseConversationContext closes a direct message or multi-person direct message with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.close\nfunc (api *Client) CloseConversationContext(ctx context.Context, channelID string) (noOp bool, alreadyClosed bool, err error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tNoOp          bool `json:\"no_op\"`\n\t\tAlreadyClosed bool `json:\"already_closed\"`\n\t}{}\n\n\terr = api.postMethod(ctx, \"conversations.close\", values, &response)\n\tif err != nil {\n\t\treturn false, false, err\n\t}\n\n\treturn response.NoOp, response.AlreadyClosed, response.Err()\n}\n\ntype CreateConversationParams struct {\n\tChannelName string\n\tIsPrivate   bool\n\tTeamID      string\n}\n\n// CreateConversation initiates a public or private channel-based conversation.\n// For more details, see CreateConversationContext documentation.\nfunc (api *Client) CreateConversation(params CreateConversationParams) (*Channel, error) {\n\treturn api.CreateConversationContext(context.Background(), params)\n}\n\n// CreateConversationContext initiates a public or private channel-based conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.create\nfunc (api *Client) CreateConversationContext(ctx context.Context, params CreateConversationParams) (*Channel, error) {\n\tvalues := url.Values{\n\t\t\"token\":      {api.token},\n\t\t\"name\":       {params.ChannelName},\n\t\t\"is_private\": {strconv.FormatBool(params.IsPrivate)},\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Set(\"team_id\", params.TeamID)\n\t}\n\tresponse, err := api.channelRequest(ctx, \"conversations.create\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.Channel, nil\n}\n\n// GetConversationInfoInput Defines the parameters of a GetConversationInfo and GetConversationInfoContext function\ntype GetConversationInfoInput struct {\n\tChannelID         string\n\tIncludeLocale     bool\n\tIncludeNumMembers bool\n}\n\n// GetConversationInfo retrieves information about a conversation.\n// For more details, see GetConversationInfoContext documentation.\nfunc (api *Client) GetConversationInfo(input *GetConversationInfoInput) (*Channel, error) {\n\treturn api.GetConversationInfoContext(context.Background(), input)\n}\n\n// GetConversationInfoContext retrieves information about a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.info\nfunc (api *Client) GetConversationInfoContext(ctx context.Context, input *GetConversationInfoInput) (*Channel, error) {\n\tif input == nil {\n\t\treturn nil, errors.New(\"GetConversationInfoInput must not be nil\")\n\t}\n\n\tif input.ChannelID == \"\" {\n\t\treturn nil, errors.New(\"ChannelID must be defined\")\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":               {api.token},\n\t\t\"channel\":             {input.ChannelID},\n\t\t\"include_locale\":      {strconv.FormatBool(input.IncludeLocale)},\n\t\t\"include_num_members\": {strconv.FormatBool(input.IncludeNumMembers)},\n\t}\n\tresponse, err := api.channelRequest(ctx, \"conversations.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.Channel, response.Err()\n}\n\n// LeaveConversation leaves a conversation.\n// For more details, see LeaveConversationContext documentation.\nfunc (api *Client) LeaveConversation(channelID string) (bool, error) {\n\treturn api.LeaveConversationContext(context.Background(), channelID)\n}\n\n// LeaveConversationContext leaves a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.leave\nfunc (api *Client) LeaveConversationContext(ctx context.Context, channelID string) (bool, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channelID},\n\t}\n\n\tresponse, err := api.channelRequest(ctx, \"conversations.leave\", values)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn response.NotInChannel, err\n}\n\ntype GetConversationRepliesParameters struct {\n\tChannelID          string\n\tTimestamp          string\n\tCursor             string\n\tInclusive          bool\n\tLatest             string\n\tLimit              int\n\tOldest             string\n\tIncludeAllMetadata bool\n}\n\n// GetConversationReplies retrieves a thread of messages posted to a conversation.\n// For more details, see GetConversationRepliesContext documentation.\nfunc (api *Client) GetConversationReplies(params *GetConversationRepliesParameters) (msgs []Message, hasMore bool, nextCursor string, err error) {\n\treturn api.GetConversationRepliesContext(context.Background(), params)\n}\n\n// GetConversationRepliesContext retrieves a thread of messages posted to a conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.replies\nfunc (api *Client) GetConversationRepliesContext(ctx context.Context, params *GetConversationRepliesParameters) (msgs []Message, hasMore bool, nextCursor string, err error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {params.ChannelID},\n\t\t\"ts\":      {params.Timestamp},\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Latest != \"\" {\n\t\tvalues.Add(\"latest\", params.Latest)\n\t}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Oldest != \"\" {\n\t\tvalues.Add(\"oldest\", params.Oldest)\n\t}\n\tif params.Inclusive {\n\t\tvalues.Add(\"inclusive\", \"1\")\n\t} else {\n\t\tvalues.Add(\"inclusive\", \"0\")\n\t}\n\tif params.IncludeAllMetadata {\n\t\tvalues.Add(\"include_all_metadata\", \"1\")\n\t} else {\n\t\tvalues.Add(\"include_all_metadata\", \"0\")\n\t}\n\tresponse := struct {\n\t\tSlackResponse\n\t\tHasMore          bool `json:\"has_more\"`\n\t\tResponseMetaData struct {\n\t\t\tNextCursor string `json:\"next_cursor\"`\n\t\t} `json:\"response_metadata\"`\n\t\tMessages []Message `json:\"messages\"`\n\t}{}\n\n\terr = api.postMethod(ctx, \"conversations.replies\", values, &response)\n\tif err != nil {\n\t\treturn nil, false, \"\", err\n\t}\n\n\treturn response.Messages, response.HasMore, response.ResponseMetaData.NextCursor, response.Err()\n}\n\ntype GetConversationsParameters struct {\n\tCursor          string\n\tExcludeArchived bool\n\tLimit           int\n\tTypes           []string\n\tTeamID          string\n}\n\n// GetConversations returns the list of channels in a Slack team.\n// For more details, see GetConversationsContext documentation.\nfunc (api *Client) GetConversations(params *GetConversationsParameters) (channels []Channel, nextCursor string, err error) {\n\treturn api.GetConversationsContext(context.Background(), params)\n}\n\n// GetConversationsContext returns the list of channels in a Slack team with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.list\nfunc (api *Client) GetConversationsContext(ctx context.Context, params *GetConversationsParameters) (channels []Channel, nextCursor string, err error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Types != nil {\n\t\tvalues.Add(\"types\", strings.Join(params.Types, \",\"))\n\t}\n\tif params.ExcludeArchived {\n\t\tvalues.Add(\"exclude_archived\", strconv.FormatBool(params.ExcludeArchived))\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\n\tresponse := struct {\n\t\tChannels         []Channel        `json:\"channels\"`\n\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n\t\tSlackResponse\n\t}{}\n\n\terr = api.postMethod(ctx, \"conversations.list\", values, &response)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn response.Channels, response.ResponseMetaData.NextCursor, response.Err()\n}\n\ntype OpenConversationParameters struct {\n\tChannelID string\n\tReturnIM  bool\n\tUsers     []string\n}\n\n// OpenConversation opens or resumes a direct message or multi-person direct message.\n// For more details, see OpenConversationContext documentation.\nfunc (api *Client) OpenConversation(params *OpenConversationParameters) (*Channel, bool, bool, error) {\n\treturn api.OpenConversationContext(context.Background(), params)\n}\n\n// OpenConversationContext opens or resumes a direct message or multi-person direct message with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.open\nfunc (api *Client) OpenConversationContext(ctx context.Context, params *OpenConversationParameters) (*Channel, bool, bool, error) {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"return_im\": {strconv.FormatBool(params.ReturnIM)},\n\t}\n\tif params.ChannelID != \"\" {\n\t\tvalues.Add(\"channel\", params.ChannelID)\n\t}\n\tif params.Users != nil {\n\t\tvalues.Add(\"users\", strings.Join(params.Users, \",\"))\n\t}\n\tresponse := struct {\n\t\tChannel     *Channel `json:\"channel\"`\n\t\tNoOp        bool     `json:\"no_op\"`\n\t\tAlreadyOpen bool     `json:\"already_open\"`\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.open\", values, &response)\n\tif err != nil {\n\t\treturn nil, false, false, err\n\t}\n\n\treturn response.Channel, response.NoOp, response.AlreadyOpen, response.Err()\n}\n\n// JoinConversation joins an existing conversation.\n// For more details, see JoinConversationContext documentation.\nfunc (api *Client) JoinConversation(channelID string) (*Channel, string, []string, error) {\n\treturn api.JoinConversationContext(context.Background(), channelID)\n}\n\n// JoinConversationContext joins an existing conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.join\nfunc (api *Client) JoinConversationContext(ctx context.Context, channelID string) (*Channel, string, []string, error) {\n\tvalues := url.Values{\"token\": {api.token}, \"channel\": {channelID}}\n\tresponse := struct {\n\t\tChannel          *Channel `json:\"channel\"`\n\t\tWarning          string   `json:\"warning\"`\n\t\tResponseMetaData *struct {\n\t\t\tWarnings []string `json:\"warnings\"`\n\t\t} `json:\"response_metadata\"`\n\t\tSlackResponse\n\t}{}\n\n\terr := api.postMethod(ctx, \"conversations.join\", values, &response)\n\tif err != nil {\n\t\treturn nil, \"\", nil, err\n\t}\n\tif response.Err() != nil {\n\t\treturn nil, \"\", nil, response.Err()\n\t}\n\tvar warnings []string\n\tif response.ResponseMetaData != nil {\n\t\twarnings = response.ResponseMetaData.Warnings\n\t}\n\treturn response.Channel, response.Warning, warnings, nil\n}\n\ntype GetConversationHistoryParameters struct {\n\tChannelID          string\n\tCursor             string\n\tInclusive          bool\n\tLatest             string\n\tLimit              int\n\tOldest             string\n\tIncludeAllMetadata bool\n}\n\ntype GetConversationHistoryResponse struct {\n\tSlackResponse\n\tHasMore          bool   `json:\"has_more\"`\n\tPinCount         int    `json:\"pin_count\"`\n\tLatest           string `json:\"latest\"`\n\tResponseMetaData struct {\n\t\tNextCursor string `json:\"next_cursor\"`\n\t} `json:\"response_metadata\"`\n\tMessages []Message `json:\"messages\"`\n}\n\n// GetConversationHistory joins an existing conversation.\n// For more details, see GetConversationHistoryContext documentation.\nfunc (api *Client) GetConversationHistory(params *GetConversationHistoryParameters) (*GetConversationHistoryResponse, error) {\n\treturn api.GetConversationHistoryContext(context.Background(), params)\n}\n\n// GetConversationHistoryContext joins an existing conversation with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.history\nfunc (api *Client) GetConversationHistoryContext(ctx context.Context, params *GetConversationHistoryParameters) (*GetConversationHistoryResponse, error) {\n\tvalues := url.Values{\"token\": {api.token}, \"channel\": {params.ChannelID}}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\tif params.Inclusive {\n\t\tvalues.Add(\"inclusive\", \"1\")\n\t} else {\n\t\tvalues.Add(\"inclusive\", \"0\")\n\t}\n\tif params.Latest != \"\" {\n\t\tvalues.Add(\"latest\", params.Latest)\n\t}\n\tif params.Limit != 0 {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Oldest != \"\" {\n\t\tvalues.Add(\"oldest\", params.Oldest)\n\t}\n\tif params.IncludeAllMetadata {\n\t\tvalues.Add(\"include_all_metadata\", \"1\")\n\t} else {\n\t\tvalues.Add(\"include_all_metadata\", \"0\")\n\t}\n\n\tresponse := GetConversationHistoryResponse{}\n\n\terr := api.postMethod(ctx, \"conversations.history\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, response.Err()\n}\n\n// MarkConversation sets the read mark of a conversation to a specific point.\n// For more details, see MarkConversationContext documentation.\nfunc (api *Client) MarkConversation(channel, ts string) (err error) {\n\treturn api.MarkConversationContext(context.Background(), channel, ts)\n}\n\n// MarkConversationContext sets the read mark of a conversation to a specific point with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.mark\nfunc (api *Client) MarkConversationContext(ctx context.Context, channel, ts string) error {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"channel\": {channel},\n\t\t\"ts\":      {ts},\n\t}\n\n\tresponse := &SlackResponse{}\n\n\terr := api.postMethod(ctx, \"conversations.mark\", values, response)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn response.Err()\n}\n\n// CreateChannelCanvas creates a new canvas in a channel.\n// For more details, see CreateChannelCanvasContext documentation.\nfunc (api *Client) CreateChannelCanvas(channel string, documentContent DocumentContent) (string, error) {\n\treturn api.CreateChannelCanvasContext(context.Background(), channel, documentContent)\n}\n\n// CreateChannelCanvasContext creates a new canvas in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/conversations.canvases.create\nfunc (api *Client) CreateChannelCanvasContext(ctx context.Context, channel string, documentContent DocumentContent) (string, error) {\n\tvalues := url.Values{\n\t\t\"token\":      {api.token},\n\t\t\"channel_id\": {channel},\n\t}\n\tif documentContent.Type != \"\" {\n\t\tdocumentContentJSON, err := json.Marshal(documentContent)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tvalues.Add(\"document_content\", string(documentContentJSON))\n\t}\n\n\tresponse := struct {\n\t\tSlackResponse\n\t\tCanvasID string `json:\"canvas_id\"`\n\t}{}\n\terr := api.postMethod(ctx, \"conversations.canvases.create\", values, &response)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn response.CanvasID, response.Err()\n}\n"
        },
        {
          "name": "conversation_test.go",
          "type": "blob",
          "size": 21.2431640625,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Channel\nvar simpleChannel = `{\n    \"id\": \"C024BE91L\",\n    \"name\": \"fun\",\n    \"is_channel\": true,\n    \"created\": 1360782804,\n    \"creator\": \"U024BE7LH\",\n    \"is_archived\": false,\n    \"is_general\": false,\n    \"members\": [\n        \"U024BE7LH\"\n    ],\n    \"topic\": {\n        \"value\": \"Fun times\",\n        \"creator\": \"U024BE7LV\",\n        \"last_set\": 1369677212\n    },\n    \"purpose\": {\n        \"value\": \"This channel is for fun\",\n        \"creator\": \"U024BE7LH\",\n        \"last_set\": 1360782804\n    },\n    \"is_member\": true,\n    \"last_read\": \"1401383885.000061\",\n    \"unread_count\": 0,\n    \"unread_count_display\": 0\n}`\n\nfunc unmarshalChannel(j string) (*Channel, error) {\n\tchannel := &Channel{}\n\tif err := json.Unmarshal([]byte(j), &channel); err != nil {\n\t\treturn nil, err\n\t}\n\treturn channel, nil\n}\n\nfunc TestSimpleChannel(t *testing.T) {\n\tchannel, err := unmarshalChannel(simpleChannel)\n\tassert.Nil(t, err)\n\tassertSimpleChannel(t, channel)\n}\n\nfunc assertSimpleChannel(t *testing.T, channel *Channel) {\n\tassert.NotNil(t, channel)\n\tassert.Equal(t, \"C024BE91L\", channel.ID)\n\tassert.Equal(t, \"fun\", channel.Name)\n\tassert.Equal(t, true, channel.IsChannel)\n\tassert.Equal(t, JSONTime(1360782804), channel.Created)\n\tassert.Equal(t, \"U024BE7LH\", channel.Creator)\n\tassert.Equal(t, false, channel.IsArchived)\n\tassert.Equal(t, false, channel.IsGeneral)\n\tassert.Equal(t, true, channel.IsMember)\n\tassert.Equal(t, \"1401383885.000061\", channel.LastRead)\n\tassert.Equal(t, 0, channel.UnreadCount)\n\tassert.Equal(t, 0, channel.UnreadCountDisplay)\n}\n\nfunc TestCreateSimpleChannel(t *testing.T) {\n\tchannel := &Channel{}\n\tchannel.ID = \"C024BE91L\"\n\tchannel.Name = \"fun\"\n\tchannel.IsChannel = true\n\tchannel.Created = JSONTime(1360782804)\n\tchannel.Creator = \"U024BE7LH\"\n\tchannel.IsArchived = false\n\tchannel.IsGeneral = false\n\tchannel.IsMember = true\n\tchannel.LastRead = \"1401383885.000061\"\n\tchannel.UnreadCount = 0\n\tchannel.UnreadCountDisplay = 0\n\tassertSimpleChannel(t, channel)\n}\n\n// Group\nvar simpleGroup = `{\n    \"id\": \"G024BE91L\",\n    \"name\": \"secretplans\",\n    \"is_group\": true,\n    \"created\": 1360782804,\n    \"creator\": \"U024BE7LH\",\n    \"is_archived\": false,\n    \"members\": [\n        \"U024BE7LH\"\n    ],\n    \"topic\": {\n        \"value\": \"Secret plans on hold\",\n        \"creator\": \"U024BE7LV\",\n        \"last_set\": 1369677212\n    },\n    \"purpose\": {\n        \"value\": \"Discuss secret plans that no-one else should know\",\n        \"creator\": \"U024BE7LH\",\n        \"last_set\": 1360782804\n    },\n    \"last_read\": \"1401383885.000061\",\n    \"unread_count\": 0,\n    \"unread_count_display\": 0\n}`\n\nfunc unmarshalGroup(j string) (*Group, error) {\n\tgroup := &Group{}\n\tif err := json.Unmarshal([]byte(j), &group); err != nil {\n\t\treturn nil, err\n\t}\n\treturn group, nil\n}\n\nfunc TestSimpleGroup(t *testing.T) {\n\tgroup, err := unmarshalGroup(simpleGroup)\n\tassert.Nil(t, err)\n\tassertSimpleGroup(t, group)\n}\n\nfunc assertSimpleGroup(t *testing.T, group *Group) {\n\tassert.NotNil(t, group)\n\tassert.Equal(t, \"G024BE91L\", group.ID)\n\tassert.Equal(t, \"secretplans\", group.Name)\n\tassert.Equal(t, true, group.IsGroup)\n\tassert.Equal(t, JSONTime(1360782804), group.Created)\n\tassert.Equal(t, \"U024BE7LH\", group.Creator)\n\tassert.Equal(t, false, group.IsArchived)\n\tassert.Equal(t, \"1401383885.000061\", group.LastRead)\n\tassert.Equal(t, 0, group.UnreadCount)\n\tassert.Equal(t, 0, group.UnreadCountDisplay)\n}\n\nfunc TestCreateSimpleGroup(t *testing.T) {\n\tgroup := &Group{}\n\tgroup.ID = \"G024BE91L\"\n\tgroup.Name = \"secretplans\"\n\tgroup.IsGroup = true\n\tgroup.Created = JSONTime(1360782804)\n\tgroup.Creator = \"U024BE7LH\"\n\tgroup.IsArchived = false\n\tgroup.LastRead = \"1401383885.000061\"\n\tgroup.UnreadCount = 0\n\tgroup.UnreadCountDisplay = 0\n\tassertSimpleGroup(t, group)\n}\n\n// Channel with Canvas\nvar channelWithCanvas = `{\n    \"id\": \"C024BE91L\",\n    \"name\": \"fun\",\n    \"is_channel\": true,\n    \"created\": 1360782804,\n    \"creator\": \"U024BE7LH\",\n    \"is_archived\": false,\n    \"is_general\": false,\n    \"members\": [\n        \"U024BE7LH\"\n    ],\n    \"topic\": {\n        \"value\": \"Fun times\",\n        \"creator\": \"U024BE7LV\",\n        \"last_set\": 1369677212\n    },\n    \"purpose\": {\n        \"value\": \"This channel is for fun\",\n        \"creator\": \"U024BE7LH\",\n        \"last_set\": 1360782804\n    },\n    \"is_member\": true,\n    \"last_read\": \"1401383885.000061\",\n    \"unread_count\": 0,\n    \"unread_count_display\": 0,\n\t\"properties\": {\n        \"canvas\": {\n            \"file_id\": \"F05RQ01LJU0\",\n            \"is_empty\": true,\n            \"quip_thread_id\": \"XFB9AAlvIyJ\"\n        }\n    }\n}`\n\nfunc unmarshalChannelWithCanvas(j string) (*Channel, error) {\n\tchannel := &Channel{}\n\tif err := json.Unmarshal([]byte(j), &channel); err != nil {\n\t\treturn nil, err\n\t}\n\treturn channel, nil\n}\n\nfunc TestChannelWithCanvas(t *testing.T) {\n\tchannel, err := unmarshalChannelWithCanvas(channelWithCanvas)\n\tassert.Nil(t, err)\n\tassertChannelWithCanvas(t, channel)\n}\n\nfunc assertChannelWithCanvas(t *testing.T, channel *Channel) {\n\tassertSimpleChannel(t, channel)\n\tassert.Equal(t, \"F05RQ01LJU0\", channel.Properties.Canvas.FileId)\n\tassert.Equal(t, true, channel.Properties.Canvas.IsEmpty)\n\tassert.Equal(t, \"XFB9AAlvIyJ\", channel.Properties.Canvas.QuipThreadId)\n}\n\nfunc TestCreateChannelWithCanvas(t *testing.T) {\n\tchannel := &Channel{}\n\tchannel.ID = \"C024BE91L\"\n\tchannel.Name = \"fun\"\n\tchannel.IsChannel = true\n\tchannel.Created = JSONTime(1360782804)\n\tchannel.Creator = \"U024BE7LH\"\n\tchannel.IsArchived = false\n\tchannel.IsGeneral = false\n\tchannel.IsMember = true\n\tchannel.LastRead = \"1401383885.000061\"\n\tchannel.UnreadCount = 0\n\tchannel.UnreadCountDisplay = 0\n\tchannel.Properties = &Properties{\n\t\tCanvas: Canvas{\n\t\t\tFileId:       \"F05RQ01LJU0\",\n\t\t\tIsEmpty:      true,\n\t\t\tQuipThreadId: \"XFB9AAlvIyJ\",\n\t\t},\n\t}\n\tassertChannelWithCanvas(t, channel)\n}\n\n// IM\nvar simpleIM = `{\n    \"id\": \"D024BFF1M\",\n    \"is_im\": true,\n    \"user\": \"U024BE7LH\",\n    \"created\": 1360782804,\n    \"is_user_deleted\": false,\n    \"is_open\": true,\n    \"last_read\": \"1401383885.000061\",\n    \"unread_count\": 0,\n    \"unread_count_display\": 0\n}`\n\nfunc unmarshalIM(j string) (*IM, error) {\n\tim := &IM{}\n\tif err := json.Unmarshal([]byte(j), &im); err != nil {\n\t\treturn nil, err\n\t}\n\treturn im, nil\n}\n\nfunc TestSimpleIM(t *testing.T) {\n\tim, err := unmarshalIM(simpleIM)\n\tassert.Nil(t, err)\n\tassertSimpleIM(t, im)\n}\n\nfunc assertSimpleIM(t *testing.T, im *IM) {\n\tassert.NotNil(t, im)\n\tassert.Equal(t, \"D024BFF1M\", im.ID)\n\tassert.Equal(t, true, im.IsIM)\n\tassert.Equal(t, \"U024BE7LH\", im.User)\n\tassert.Equal(t, JSONTime(1360782804), im.Created)\n\tassert.Equal(t, false, im.IsUserDeleted)\n\tassert.Equal(t, true, im.IsOpen)\n\tassert.Equal(t, \"1401383885.000061\", im.LastRead)\n\tassert.Equal(t, 0, im.UnreadCount)\n\tassert.Equal(t, 0, im.UnreadCountDisplay)\n}\n\nfunc TestCreateSimpleIM(t *testing.T) {\n\tim := &IM{}\n\tim.ID = \"D024BFF1M\"\n\tim.IsIM = true\n\tim.User = \"U024BE7LH\"\n\tim.Created = JSONTime(1360782804)\n\tim.IsUserDeleted = false\n\tim.IsOpen = true\n\tim.LastRead = \"1401383885.000061\"\n\tim.UnreadCount = 0\n\tim.UnreadCountDisplay = 0\n\tassertSimpleIM(t, im)\n}\n\nfunc getTestMembers() []string {\n\treturn []string{\"test\"}\n}\n\nfunc getUsersInConversation(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tMembers          []string         `json:\"members\"`\n\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n\t}{\n\t\tSlackResponse:    SlackResponse{Ok: true},\n\t\tMembers:          getTestMembers(),\n\t\tResponseMetaData: responseMetaData{NextCursor: \"\"},\n\t})\n\trw.Write(response)\n}\n\nfunc TestGetUsersInConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.members\", getUsersInConversation)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := GetUsersInConversationParameters{\n\t\tChannelID: \"CXXXXXXXX\",\n\t}\n\n\texpectedMembers := getTestMembers()\n\n\tmembers, _, err := api.GetUsersInConversation(&params)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(expectedMembers, members) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc TestArchiveConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.archive\", okJSONHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.ArchiveConversation(\"CXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc TestUnArchiveConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.unarchive\", okJSONHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.UnArchiveConversation(\"CXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc getTestChannel() *Channel {\n\treturn &Channel{\n\t\tGroupConversation: GroupConversation{\n\t\t\tTopic: Topic{\n\t\t\t\tValue: \"response topic\",\n\t\t\t},\n\t\t\tPurpose: Purpose{\n\t\t\t\tValue: \"response purpose\",\n\t\t\t},\n\t\t}}\n}\n\nfunc okChannelJsonHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tChannel *Channel `json:\"channel\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t\tChannel:       getTestChannel(),\n\t})\n\trw.Write(response)\n}\n\nfunc okInviteSharedJsonHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tInviteID              string `json:\"invite_id\"`\n\t\tIsLegacySharedChannel bool   `json:\"is_legacy_shared_channel\"`\n\t}{\n\t\tSlackResponse:         SlackResponse{Ok: true},\n\t\tInviteID:              \"I01234567\",\n\t\tIsLegacySharedChannel: false,\n\t})\n\trw.Write(response)\n}\n\nfunc TestSetTopicOfConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.setTopic\", okChannelJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tinputChannel := getTestChannel()\n\tchannel, err := api.SetTopicOfConversation(\"CXXXXXXXX\", inputChannel.Topic.Value)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif channel.Topic.Value != inputChannel.Topic.Value {\n\t\tt.Fatalf(`topic = '%s', want '%s'`, channel.Topic.Value, inputChannel.Topic.Value)\n\t}\n}\n\nfunc TestSetPurposeOfConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.setPurpose\", okChannelJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tinputChannel := getTestChannel()\n\tchannel, err := api.SetPurposeOfConversation(\"CXXXXXXXX\", inputChannel.Purpose.Value)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif channel.Purpose.Value != inputChannel.Purpose.Value {\n\t\tt.Fatalf(`purpose = '%s', want '%s'`, channel.Purpose.Value, inputChannel.Purpose.Value)\n\t}\n}\n\nfunc TestRenameConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.rename\", okChannelJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tinputChannel := getTestChannel()\n\tchannel, err := api.RenameConversation(\"CXXXXXXXX\", inputChannel.Name)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif channel.Name != inputChannel.Name {\n\t\tt.Fatalf(`channelName = '%s', want '%s'`, channel.Name, inputChannel.Name)\n\t}\n}\n\nfunc TestInviteUsersToConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.invite\", okChannelJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tusers := []string{\"UXXXXXXX1\", \"UXXXXXXX2\"}\n\tchannel, err := api.InviteUsersToConversation(\"CXXXXXXXX\", users...)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif channel == nil {\n\t\tt.Error(\"channel should not be nil\")\n\t\treturn\n\t}\n}\n\nfunc TestInviteSharedToConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.inviteShared\", okInviteSharedJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tt.Run(\"user_ids\", func(t *testing.T) {\n\t\tuserIDs := []string{\"UXXXXXXX1\", \"UXXXXXXX2\"}\n\t\tinviteID, isLegacySharedChannel, err := api.InviteSharedUserIDsToConversation(\"CXXXXXXXX\", userIDs...)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif inviteID == \"\" {\n\t\t\tt.Error(\"invite id should have a value\")\n\t\t\treturn\n\t\t}\n\t\tif isLegacySharedChannel {\n\t\t\tt.Error(\"is legacy shared channel should be false\")\n\t\t}\n\t})\n\n\tt.Run(\"emails\", func(t *testing.T) {\n\t\temails := []string{\"nopcoder@slack.com\", \"nopcoder@example.com\"}\n\t\tinviteID, isLegacySharedChannel, err := api.InviteSharedEmailsToConversation(\"CXXXXXXXX\", emails...)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif inviteID == \"\" {\n\t\t\tt.Error(\"invite id should have a value\")\n\t\t\treturn\n\t\t}\n\t\tif isLegacySharedChannel {\n\t\t\tt.Error(\"is legacy shared channel should be false\")\n\t\t}\n\t})\n\n\tt.Run(\"external_limited\", func(t *testing.T) {\n\t\tuserIDs := []string{\"UXXXXXXX1\", \"UXXXXXXX2\"}\n\t\texternalLimited := true\n\t\tinviteID, isLegacySharedChannel, err := api.InviteSharedToConversation(InviteSharedToConversationParams{\n\t\t\tChannelID:       \"CXXXXXXXX\",\n\t\t\tUserIDs:         userIDs,\n\t\t\tExternalLimited: &externalLimited,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif inviteID == \"\" {\n\t\t\tt.Error(\"invite id should have a value\")\n\t\t\treturn\n\t\t}\n\t\tif isLegacySharedChannel {\n\t\t\tt.Error(\"is legacy shared channel should be false\")\n\t\t}\n\t})\n}\n\nfunc TestKickUserFromConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.kick\", okJSONHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.KickUserFromConversation(\"CXXXXXXXX\", \"UXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc closeConversationHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tNoOp          bool `json:\"no_op\"`\n\t\tAlreadyClosed bool `json:\"already_closed\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestCloseConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.close\", closeConversationHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, _, err := api.CloseConversation(\"CXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc TestCreateConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.create\", okChannelJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tchannel, err := api.CreateConversation(CreateConversationParams{ChannelName: \"CXXXXXXXX\"})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif channel == nil {\n\t\tt.Error(\"channel should not be nil\")\n\t\treturn\n\t}\n}\n\nfunc TestGetConversationInfo(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.info\", okChannelJsonHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tchannel, err := api.GetConversationInfo(&GetConversationInfoInput{\n\t\tChannelID: \"CXXXXXXXX\",\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif channel == nil {\n\t\tt.Error(\"channel should not be nil\")\n\t\treturn\n\t}\n\n\t// Nil Input Error\n\tapi = New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, err = api.GetConversationInfo(nil)\n\tif err == nil {\n\t\tt.Errorf(\"Unexpected pass where there should have been nil input error\")\n\t\treturn\n\t}\n\n\t// No Channel Error\n\tapi = New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, err = api.GetConversationInfo(&GetConversationInfoInput{})\n\tif err == nil {\n\t\tt.Errorf(\"Unexpected pass where there should have been missing channel error\")\n\t\treturn\n\t}\n}\n\nfunc leaveConversationHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tNotInChannel bool `json:\"not_in_channel\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestLeaveConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.leave\", leaveConversationHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, err := api.LeaveConversation(\"CXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc getConversationRepliesHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tHasMore          bool `json:\"has_more\"`\n\t\tResponseMetaData struct {\n\t\t\tNextCursor string `json:\"next_cursor\"`\n\t\t} `json:\"response_metadata\"`\n\t\tMessages []Message `json:\"messages\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t\tMessages:      []Message{}})\n\trw.Write(response)\n}\n\nfunc TestGetConversationReplies(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.replies\", getConversationRepliesHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := GetConversationRepliesParameters{\n\t\tChannelID: \"CXXXXXXXX\",\n\t\tTimestamp: \"1234567890.123456\",\n\t}\n\t_, _, _, err := api.GetConversationReplies(&params)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc getConversationsHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tResponseMetaData struct {\n\t\t\tNextCursor string `json:\"next_cursor\"`\n\t\t} `json:\"response_metadata\"`\n\t\tChannels []Channel `json:\"channels\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t\tChannels:      []Channel{}})\n\trw.Write(response)\n}\n\nfunc TestGetConversations(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.list\", getConversationsHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := GetConversationsParameters{}\n\t_, _, err := api.GetConversations(&params)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc openConversationHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tNoOp        bool     `json:\"no_op\"`\n\t\tAlreadyOpen bool     `json:\"already_open\"`\n\t\tChannel     *Channel `json:\"channel\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestOpenConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.open\", openConversationHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := OpenConversationParameters{ChannelID: \"CXXXXXXXX\"}\n\t_, _, _, err := api.OpenConversation(&params)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc joinConversationHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tChannel          *Channel `json:\"channel\"`\n\t\tWarning          string   `json:\"warning\"`\n\t\tResponseMetaData *struct {\n\t\t\tWarnings []string `json:\"warnings\"`\n\t\t} `json:\"response_metadata\"`\n\t\tSlackResponse\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestJoinConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.join\", joinConversationHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, _, _, err := api.JoinConversation(\"CXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc getConversationHistoryHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(GetConversationHistoryResponse{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestGetConversationHistory(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.history\", getConversationHistoryHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := GetConversationHistoryParameters{ChannelID: \"CXXXXXXXX\"}\n\t_, err := api.GetConversationHistory(&params)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc markConversationHandler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(GetConversationHistoryResponse{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\tw.Write(response)\n}\n\nfunc TestMarkConversation(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.mark\", markConversationHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.MarkConversation(\"CXXXXXXXX\", \"1401383885.000061\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc createChannelCanvasHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t\tCanvasID string `json:\"canvas_id\"`\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t\tCanvasID:      \"F05RQ01LJU0\",\n\t})\n\trw.Write(response)\n}\n\nfunc TestCreateChannelCanvas(t *testing.T) {\n\thttp.HandleFunc(\"/conversations.canvases.create\", createChannelCanvasHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tdocumentContent := DocumentContent{\n\t\tType:     \"markdown\",\n\t\tMarkdown: \"> channel canvas!\",\n\t}\n\n\tcanvasID, err := api.CreateChannelCanvas(\"C1234567890\", documentContent)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to create channel canvas: %v\", err)\n\t\treturn\n\t}\n\n\tassert.Equal(t, \"F05RQ01LJU0\", canvasID)\n}\n"
        },
        {
          "name": "dialog.go",
          "type": "blob",
          "size": 3.779296875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"strings\"\n)\n\n// InputType is the type of the dialog input type\ntype InputType string\n\nconst (\n\t// InputTypeText textfield input\n\tInputTypeText InputType = \"text\"\n\t// InputTypeTextArea textarea input\n\tInputTypeTextArea InputType = \"textarea\"\n\t// InputTypeSelect select menus input\n\tInputTypeSelect InputType = \"select\"\n)\n\n// DialogInput for dialogs input type text or menu\ntype DialogInput struct {\n\tType        InputType `json:\"type\"`\n\tLabel       string    `json:\"label\"`\n\tName        string    `json:\"name\"`\n\tPlaceholder string    `json:\"placeholder\"`\n\tOptional    bool      `json:\"optional\"`\n\tHint        string    `json:\"hint\"`\n}\n\n// DialogTrigger ...\ntype DialogTrigger struct {\n\tTriggerID string `json:\"trigger_id\"` //Required. Must respond within 3 seconds.\n\tDialog    Dialog `json:\"dialog\"`     //Required.\n}\n\n// Dialog as in Slack dialogs\n// https://api.slack.com/dialogs#option_element_attributes#top-level_dialog_attributes\ntype Dialog struct {\n\tTriggerID      string          `json:\"trigger_id\"`      // Required\n\tCallbackID     string          `json:\"callback_id\"`     // Required\n\tState          string          `json:\"state,omitempty\"` // Optional\n\tTitle          string          `json:\"title\"`\n\tSubmitLabel    string          `json:\"submit_label,omitempty\"`\n\tNotifyOnCancel bool            `json:\"notify_on_cancel\"`\n\tElements       []DialogElement `json:\"elements\"`\n}\n\n// DialogElement abstract type for dialogs.\ntype DialogElement interface{}\n\n// DialogCallback DEPRECATED use InteractionCallback\ntype DialogCallback InteractionCallback\n\n// DialogSubmissionCallback is sent from Slack when a user submits a form from within a dialog\ntype DialogSubmissionCallback struct {\n\t// NOTE: State is only used with the dialog_submission type.\n\t// You should use InteractionCallback.BlockActionsState for block_actions type.\n\tState      string            `json:\"-\"`\n\tSubmission map[string]string `json:\"submission\"`\n}\n\n// DialogOpenResponse response from `dialog.open`\ntype DialogOpenResponse struct {\n\tSlackResponse\n\tDialogResponseMetadata DialogResponseMetadata `json:\"response_metadata\"`\n}\n\n// DialogResponseMetadata lists the error messages\ntype DialogResponseMetadata struct {\n\tMessages []string `json:\"messages\"`\n}\n\n// DialogInputValidationError is an error when user inputs incorrect value to form from within a dialog\ntype DialogInputValidationError struct {\n\tName  string `json:\"name\"`\n\tError string `json:\"error\"`\n}\n\n// DialogInputValidationErrors lists the name of field and that error messages\ntype DialogInputValidationErrors struct {\n\tErrors []DialogInputValidationError `json:\"errors\"`\n}\n\n// OpenDialog opens a dialog window where the triggerID originated from.\n// EXPERIMENTAL: dialog functionality is currently experimental, api is not considered stable.\nfunc (api *Client) OpenDialog(triggerID string, dialog Dialog) (err error) {\n\treturn api.OpenDialogContext(context.Background(), triggerID, dialog)\n}\n\n// OpenDialogContext opens a dialog window where the triggerId originated from with a custom context\n// EXPERIMENTAL: dialog functionality is currently experimental, api is not considered stable.\nfunc (api *Client) OpenDialogContext(ctx context.Context, triggerID string, dialog Dialog) (err error) {\n\tif triggerID == \"\" {\n\t\treturn ErrParametersMissing\n\t}\n\n\treq := DialogTrigger{\n\t\tTriggerID: triggerID,\n\t\tDialog:    dialog,\n\t}\n\n\tencoded, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponse := &DialogOpenResponse{}\n\tendpoint := api.endpoint + \"dialog.open\"\n\tif err := postJSON(ctx, api.httpclient, endpoint, api.token, encoded, response, api); err != nil {\n\t\treturn err\n\t}\n\n\tif len(response.DialogResponseMetadata.Messages) > 0 {\n\t\tresponse.Ok = false\n\t\tresponse.Error += \"\\n\" + strings.Join(response.DialogResponseMetadata.Messages, \"\\n\")\n\t}\n\n\treturn response.Err()\n}\n"
        },
        {
          "name": "dialog_select.go",
          "type": "blob",
          "size": 4.1044921875,
          "content": "package slack\n\n// SelectDataSource types of select datasource\ntype SelectDataSource string\n\nconst (\n\t// DialogDataSourceStatic menu with static Options/OptionGroups\n\tDialogDataSourceStatic SelectDataSource = \"static\"\n\t// DialogDataSourceExternal dynamic datasource\n\tDialogDataSourceExternal SelectDataSource = \"external\"\n\t// DialogDataSourceConversations provides a list of conversations\n\tDialogDataSourceConversations SelectDataSource = \"conversations\"\n\t// DialogDataSourceChannels provides a list of channels\n\tDialogDataSourceChannels SelectDataSource = \"channels\"\n\t// DialogDataSourceUsers provides a list of users\n\tDialogDataSourceUsers SelectDataSource = \"users\"\n)\n\n// DialogInputSelect dialog support for select boxes.\ntype DialogInputSelect struct {\n\tDialogInput\n\tValue           string               `json:\"value,omitempty\"`            //Optional.\n\tDataSource      SelectDataSource     `json:\"data_source,omitempty\"`      //Optional. Allowed values: \"users\", \"channels\", \"conversations\", \"external\".\n\tSelectedOptions []DialogSelectOption `json:\"selected_options,omitempty\"` //Optional. May hold at most one element, for use with \"external\" only.\n\tOptions         []DialogSelectOption `json:\"options,omitempty\"`          //One of options or option_groups is required.\n\tOptionGroups    []DialogOptionGroup  `json:\"option_groups,omitempty\"`    //Provide up to 100 options.\n\tMinQueryLength  int                  `json:\"min_query_length,omitempty\"` //Optional. minimum characters before query is sent.\n\tHint            string               `json:\"hint,omitempty\"`             //Optional. Additional hint text.\n}\n\n// DialogSelectOption is an option for the user to select from the menu\ntype DialogSelectOption struct {\n\tLabel string `json:\"label\"`\n\tValue string `json:\"value\"`\n}\n\n// DialogOptionGroup is a collection of options for creating a segmented table\ntype DialogOptionGroup struct {\n\tLabel   string               `json:\"label\"`\n\tOptions []DialogSelectOption `json:\"options\"`\n}\n\n// NewStaticSelectDialogInput constructor for a `static` datasource menu input\nfunc NewStaticSelectDialogInput(name, label string, options []DialogSelectOption) *DialogInputSelect {\n\treturn &DialogInputSelect{\n\t\tDialogInput: DialogInput{\n\t\t\tType:     InputTypeSelect,\n\t\t\tName:     name,\n\t\t\tLabel:    label,\n\t\t\tOptional: true,\n\t\t},\n\t\tDataSource: DialogDataSourceStatic,\n\t\tOptions:    options,\n\t}\n}\n\n// NewExternalSelectDialogInput constructor for a `external` datasource menu input\nfunc NewExternalSelectDialogInput(name, label string, options []DialogSelectOption) *DialogInputSelect {\n\treturn &DialogInputSelect{\n\t\tDialogInput: DialogInput{\n\t\t\tType:     InputTypeSelect,\n\t\t\tName:     name,\n\t\t\tLabel:    label,\n\t\t\tOptional: true,\n\t\t},\n\t\tDataSource: DialogDataSourceExternal,\n\t\tOptions:    options,\n\t}\n}\n\n// NewGroupedSelectDialogInput creates grouped options select input for Dialogs.\nfunc NewGroupedSelectDialogInput(name, label string, options []DialogOptionGroup) *DialogInputSelect {\n\treturn &DialogInputSelect{\n\t\tDialogInput: DialogInput{\n\t\t\tType:  InputTypeSelect,\n\t\t\tName:  name,\n\t\t\tLabel: label,\n\t\t},\n\t\tDataSource:   DialogDataSourceStatic,\n\t\tOptionGroups: options}\n}\n\n// NewDialogOptionGroup creates a DialogOptionGroup from several select options\nfunc NewDialogOptionGroup(label string, options ...DialogSelectOption) DialogOptionGroup {\n\treturn DialogOptionGroup{\n\t\tLabel:   label,\n\t\tOptions: options,\n\t}\n}\n\n// NewConversationsSelect returns a `Conversations` select\nfunc NewConversationsSelect(name, label string) *DialogInputSelect {\n\treturn newPresetSelect(name, label, DialogDataSourceConversations)\n}\n\n// NewChannelsSelect returns a `Channels` select\nfunc NewChannelsSelect(name, label string) *DialogInputSelect {\n\treturn newPresetSelect(name, label, DialogDataSourceChannels)\n}\n\n// NewUsersSelect returns a `Users` select\nfunc NewUsersSelect(name, label string) *DialogInputSelect {\n\treturn newPresetSelect(name, label, DialogDataSourceUsers)\n}\n\nfunc newPresetSelect(name, label string, dataSourceType SelectDataSource) *DialogInputSelect {\n\treturn &DialogInputSelect{\n\t\tDialogInput: DialogInput{\n\t\t\tType:  InputTypeSelect,\n\t\t\tLabel: label,\n\t\t\tName:  name,\n\t\t},\n\t\tDataSource: dataSourceType,\n\t}\n}\n"
        },
        {
          "name": "dialog_select_test.go",
          "type": "blob",
          "size": 3.7275390625,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc selectOptionsFromArray(options ...string) []DialogSelectOption {\n\tselectOptions := make([]DialogSelectOption, len(options))\n\tfor idx, value := range options {\n\t\tselectOptions[idx] = DialogSelectOption{\n\t\t\tLabel: value,\n\t\t\tValue: value,\n\t\t}\n\t}\n\treturn selectOptions\n}\n\nfunc selectOptionsFromMap(options map[string]string) []DialogSelectOption {\n\tselectOptions := make([]DialogSelectOption, len(options))\n\tidx := 0\n\tvar option DialogSelectOption\n\tfor key, value := range options {\n\t\toption = DialogSelectOption{\n\t\t\tLabel: key,\n\t\t\tValue: value,\n\t\t}\n\t\tselectOptions[idx] = option\n\t\tidx++\n\t}\n\treturn selectOptions\n}\n\nfunc TestSelectOptionsFromArray(t *testing.T) {\n\toptions := []string{\"opt 1\"}\n\texpectedOptions := selectOptionsFromArray(options...)\n\tassert.Equal(t, len(options), len(expectedOptions))\n\n\tfirstOption := expectedOptions[0]\n\tassert.Equal(t, \"opt 1\", firstOption.Label)\n\tassert.Equal(t, \"opt 1\", firstOption.Value)\n}\n\nfunc TestOptionsFromMap(t *testing.T) {\n\toptions := make(map[string]string)\n\toptions[\"key\"] = \"myValue\"\n\n\tselectOptions := selectOptionsFromMap(options)\n\tassert.Equal(t, 1, len(selectOptions))\n\n\tfirstOption := selectOptions[0]\n\tassert.Equal(t, \"key\", firstOption.Label)\n\tassert.Equal(t, \"myValue\", firstOption.Value)\n}\n\nfunc TestStaticSelectFromArray(t *testing.T) {\n\tname := \"static select\"\n\tlabel := \"Static Select Label\"\n\texpectedOptions := selectOptionsFromArray(\"opt 1\", \"opt 2\", \"opt 3\")\n\n\tselectInput := NewStaticSelectDialogInput(name, label, expectedOptions)\n\tassert.Equal(t, name, selectInput.Name)\n\tassert.Equal(t, label, selectInput.Label)\n\tassert.Equal(t, expectedOptions, selectInput.Options)\n}\n\nfunc TestStaticSelectFromDictionary(t *testing.T) {\n\tname := \"static select\"\n\tlabel := \"Static Select Label\"\n\n\toptionsMap := make(map[string]string)\n\toptionsMap[\"option_1\"] = \"First\"\n\toptionsMap[\"option_2\"] = \"Second\"\n\toptionsMap[\"option_3\"] = \"Third\"\n\texpectedOptions := selectOptionsFromMap(optionsMap)\n\n\tselectInput := NewStaticSelectDialogInput(name, label, expectedOptions)\n\tassert.Equal(t, name, selectInput.Name)\n\tassert.Equal(t, label, selectInput.Label)\n\tassert.Equal(t, expectedOptions, selectInput.Options)\n}\n\nfunc TestNewDialogOptionGroup(t *testing.T) {\n\texpectedOptions := selectOptionsFromArray(\"option_1\", \"option_2\")\n\n\tlabel := \"GroupLabel\"\n\toptionGroup := NewDialogOptionGroup(label, expectedOptions...)\n\n\tassert.Equal(t, label, optionGroup.Label)\n\tassert.Equal(t, expectedOptions, optionGroup.Options)\n\n}\n\nfunc TestStaticGroupedSelect(t *testing.T) {\n\n\tgroupOpt1 := NewDialogOptionGroup(\"group1\", selectOptionsFromArray(\"G1_01\", \"G1_02\")...)\n\tgroupOpt2 := NewDialogOptionGroup(\"group2\", selectOptionsFromArray(\"G2_01\", \"G2_02\", \"G2_03\")...)\n\n\toptions := []DialogOptionGroup{groupOpt1, groupOpt2}\n\n\tgroupSelect := NewGroupedSelectDialogInput(\"groupSelect\", \"User Label\", options)\n\tassert.Equal(t, InputTypeSelect, groupSelect.Type)\n\tassert.Equal(t, \"groupSelect\", groupSelect.Name)\n\tassert.Equal(t, \"User Label\", groupSelect.Label)\n\tassert.Nil(t, groupSelect.Options)\n\tassert.NotNil(t, groupSelect.OptionGroups)\n\tassert.Equal(t, 2, len(groupSelect.OptionGroups))\n}\n\nfunc TestConversationSelect(t *testing.T) {\n\tconvoSelect := NewConversationsSelect(\"\", \"\")\n\tassert.Equal(t, InputTypeSelect, convoSelect.Type)\n\tassert.Equal(t, DialogDataSourceConversations, convoSelect.DataSource)\n}\n\nfunc TestChannelSelect(t *testing.T) {\n\tconvoSelect := NewChannelsSelect(\"\", \"\")\n\tassert.Equal(t, InputTypeSelect, convoSelect.Type)\n\tassert.Equal(t, DialogDataSourceChannels, convoSelect.DataSource)\n}\n\nfunc TestUserSelect(t *testing.T) {\n\tconvoSelect := NewUsersSelect(\"\", \"\")\n\tassert.Equal(t, InputTypeSelect, convoSelect.Type)\n\tassert.Equal(t, DialogDataSourceUsers, convoSelect.DataSource)\n}\n"
        },
        {
          "name": "dialog_test.go",
          "type": "blob",
          "size": 9.73828125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"net/http\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Dialogs\nvar simpleDialog = `{\n\t\"callback_id\":\"ryde-46e2b0\",\n\t\"title\":\"Request a Ride\",\n\t\"submit_label\":\"Request\",\n\t\"notify_on_cancel\":true\n}`\n\nvar simpleTextElement = `{\n\t\"label\": \"testing label\",\n\t\"name\": \"testing name\",\n\t\"type\": \"text\",\n\t\"placeholder\": \"testing placeholder\",\n\t\"optional\": true,\n\t\"value\": \"testing value\",\n\t\"max_length\": 1000,\n\t\"min_length\": 10,\n\t\"hint\": \"testing hint\",\n\t\"subtype\": \"email\"\n}`\n\nvar simpleSelectElement = `{\n\t\"label\": \"testing label\",\n\t\"name\": \"testing name\",\n\t\"type\": \"select\",\n\t\"placeholder\": \"testing placeholder\",\n\t\"optional\": true,\n\t\"value\": \"testing value\",\n\t\"data_source\": \"users\",\n\t\"selected_options\": [],\n\t\"options\": [{\"label\": \"option 1\", \"value\": \"1\"}],\n\t\"option_groups\": []\n}`\n\nfunc unmarshalDialog() (*Dialog, error) {\n\tdialog := &Dialog{}\n\t// Unmarshall the simple dialog json\n\tif err := json.Unmarshal([]byte(simpleDialog), &dialog); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Unmarshall and append the text element\n\ttextElement := &TextInputElement{}\n\tif err := json.Unmarshal([]byte(simpleTextElement), &textElement); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Unmarshall and append the select element\n\tselectElement := &DialogInputSelect{}\n\tif err := json.Unmarshal([]byte(simpleSelectElement), &selectElement); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdialog.Elements = []DialogElement{\n\t\ttextElement,\n\t\tselectElement,\n\t}\n\n\treturn dialog, nil\n}\n\nfunc TestSimpleDialog(t *testing.T) {\n\tdialog, err := unmarshalDialog()\n\tassert.Nil(t, err)\n\tassertSimpleDialog(t, dialog)\n}\n\nfunc TestCreateSimpleDialog(t *testing.T) {\n\tdialog := &Dialog{}\n\tdialog.CallbackID = \"ryde-46e2b0\"\n\tdialog.Title = \"Request a Ride\"\n\tdialog.SubmitLabel = \"Request\"\n\tdialog.NotifyOnCancel = true\n\n\ttextElement := &TextInputElement{}\n\ttextElement.Label = \"testing label\"\n\ttextElement.Name = \"testing name\"\n\ttextElement.Type = \"text\"\n\ttextElement.Placeholder = \"testing placeholder\"\n\ttextElement.Optional = true\n\ttextElement.Value = \"testing value\"\n\ttextElement.MaxLength = 1000\n\ttextElement.MinLength = 10\n\ttextElement.Hint = \"testing hint\"\n\ttextElement.Subtype = \"email\"\n\n\tselectElement := &DialogInputSelect{}\n\tselectElement.Label = \"testing label\"\n\tselectElement.Name = \"testing name\"\n\tselectElement.Type = \"select\"\n\tselectElement.Placeholder = \"testing placeholder\"\n\tselectElement.Optional = true\n\tselectElement.Value = \"testing value\"\n\tselectElement.DataSource = \"users\"\n\tselectElement.SelectedOptions = []DialogSelectOption{}\n\tselectElement.Options = []DialogSelectOption{\n\t\t{Label: \"option 1\", Value: \"1\"},\n\t}\n\tselectElement.OptionGroups = []DialogOptionGroup{}\n\n\tdialog.Elements = []DialogElement{\n\t\ttextElement,\n\t\tselectElement,\n\t}\n\n\tassertSimpleDialog(t, dialog)\n}\n\nfunc assertSimpleDialog(t *testing.T, dialog *Dialog) {\n\tassert.NotNil(t, dialog)\n\n\t// Test the main dialog fields\n\tassert.Equal(t, \"ryde-46e2b0\", dialog.CallbackID)\n\tassert.Equal(t, \"Request a Ride\", dialog.Title)\n\tassert.Equal(t, \"Request\", dialog.SubmitLabel)\n\tassert.Equal(t, true, dialog.NotifyOnCancel)\n\n\t// Test the text element is correctly parsed\n\ttextElement := dialog.Elements[0].(*TextInputElement)\n\tassert.Equal(t, \"testing label\", textElement.Label)\n\tassert.Equal(t, \"testing name\", textElement.Name)\n\tassert.Equal(t, InputTypeText, textElement.Type)\n\tassert.Equal(t, \"testing placeholder\", textElement.Placeholder)\n\tassert.Equal(t, true, textElement.Optional)\n\tassert.Equal(t, \"testing value\", textElement.Value)\n\tassert.Equal(t, 1000, textElement.MaxLength)\n\tassert.Equal(t, 10, textElement.MinLength)\n\tassert.Equal(t, \"testing hint\", textElement.Hint)\n\tassert.Equal(t, InputSubtypeEmail, textElement.Subtype)\n\n\t// Test the select element is correctly parsed\n\tselectElement := dialog.Elements[1].(*DialogInputSelect)\n\tassert.Equal(t, \"testing label\", selectElement.Label)\n\tassert.Equal(t, \"testing name\", selectElement.Name)\n\tassert.Equal(t, InputTypeSelect, selectElement.Type)\n\tassert.Equal(t, \"testing placeholder\", selectElement.Placeholder)\n\tassert.Equal(t, true, selectElement.Optional)\n\tassert.Equal(t, \"testing value\", selectElement.Value)\n\tassert.Equal(t, DialogDataSourceUsers, selectElement.DataSource)\n\tassert.Equal(t, []DialogSelectOption{}, selectElement.SelectedOptions)\n\tassert.Equal(t, \"option 1\", selectElement.Options[0].Label)\n\tassert.Equal(t, \"1\", selectElement.Options[0].Value)\n\tassert.Equal(t, 0, len(selectElement.OptionGroups))\n}\n\n// Callbacks\nvar simpleCallback = `{\n    \"type\": \"dialog_submission\",\n    \"submission\": {\n\t\"name\": \"Sigourney Dreamweaver\",\n\t\"email\": \"sigdre@example.com\",\n\t\"phone\": \"+1 800-555-1212\",\n\t\"meal\": \"burrito\",\n\t\"comment\": \"No sour cream please\",\n\t\"team_channel\": \"C0LFFBKPB\",\n\t\"who_should_sing\": \"U0MJRG1AL\"\n    },\n    \"callback_id\": \"employee_offsite_1138b\",\n    \"team\": {\n\t\"id\": \"T1ABCD2E12\",\n\t\"domain\": \"coverbands\"\n    },\n    \"user\": {\n\t\"id\": \"W12A3BCDEF\",\n\t\"name\": \"dreamweaver\"\n    },\n    \"channel\": {\n\t\"id\": \"C1AB2C3DE\",\n\t\"name\": \"coverthon-1999\"\n    },\n    \"action_ts\": \"936893340.702759\",\n    \"token\": \"M1AqUUw3FqayAbqNtsGMch72\",\n    \"response_url\": \"https://hooks.slack.com/app/T012AB0A1/123456789/JpmK0yzoZDeRiqfeduTBYXWQ\"\n}`\n\nfunc unmarshalCallback(j string) (*DialogCallback, error) {\n\tcallback := &DialogCallback{}\n\tif err := json.Unmarshal([]byte(j), &callback); err != nil {\n\t\treturn nil, err\n\t}\n\treturn callback, nil\n}\n\nfunc TestSimpleCallback(t *testing.T) {\n\tcallback, err := unmarshalCallback(simpleCallback)\n\tassert.Nil(t, err)\n\tassertSimpleCallback(t, callback)\n}\n\nfunc assertSimpleCallback(t *testing.T, callback *DialogCallback) {\n\tassert.NotNil(t, callback)\n\tassert.Equal(t, InteractionTypeDialogSubmission, callback.Type)\n\tassert.Equal(t, \"employee_offsite_1138b\", callback.CallbackID)\n\tassert.Equal(t, \"T1ABCD2E12\", callback.Team.ID)\n\tassert.Equal(t, \"coverbands\", callback.Team.Domain)\n\tassert.Equal(t, \"C1AB2C3DE\", callback.Channel.ID)\n\tassert.Equal(t, \"coverthon-1999\", callback.Channel.Name)\n\tassert.Equal(t, \"W12A3BCDEF\", callback.User.ID)\n\tassert.Equal(t, \"dreamweaver\", callback.User.Name)\n\tassert.Equal(t, \"936893340.702759\", callback.ActionTs)\n\tassert.Equal(t, \"M1AqUUw3FqayAbqNtsGMch72\", callback.Token)\n\tassert.Equal(t, \"https://hooks.slack.com/app/T012AB0A1/123456789/JpmK0yzoZDeRiqfeduTBYXWQ\", callback.ResponseURL)\n\tassert.Equal(t, \"Sigourney Dreamweaver\", callback.Submission[\"name\"])\n\tassert.Equal(t, \"sigdre@example.com\", callback.Submission[\"email\"])\n\tassert.Equal(t, \"+1 800-555-1212\", callback.Submission[\"phone\"])\n\tassert.Equal(t, \"burrito\", callback.Submission[\"meal\"])\n\tassert.Equal(t, \"No sour cream please\", callback.Submission[\"comment\"])\n\tassert.Equal(t, \"C0LFFBKPB\", callback.Submission[\"team_channel\"])\n\tassert.Equal(t, \"U0MJRG1AL\", callback.Submission[\"who_should_sing\"])\n}\n\n// Suggestion Callbacks\nvar simpleSuggestionCallback = `{\n  \"type\": \"dialog_suggestion\",\n  \"token\": \"W3VDvuzi2nRLsiaDOsmJranO\",\n  \"action_ts\": \"1528203589.238335\",\n  \"team\": {\n    \"id\": \"T24BK35ML\",\n    \"domain\": \"hooli-hq\"\n  },\n  \"user\": {\n    \"id\": \"U900MV5U7\",\n    \"name\": \"gbelson\"\n  },\n  \"channel\": {\n    \"id\": \"C012AB3CD\",\n    \"name\": \"triage-platform\"\n  },\n  \"name\": \"external_data\",\n  \"value\": \"test\",\n  \"callback_id\": \"bugs\"\n}`\n\nfunc unmarshalSuggestionCallback(j string) (*InteractionCallback, error) {\n\tcallback := &InteractionCallback{}\n\tif err := json.Unmarshal([]byte(j), &callback); err != nil {\n\t\treturn nil, err\n\t}\n\treturn callback, nil\n}\n\nfunc TestSimpleSuggestionCallback(t *testing.T) {\n\tcallback, err := unmarshalSuggestionCallback(simpleSuggestionCallback)\n\tassert.Nil(t, err)\n\tassertSimpleSuggestionCallback(t, callback)\n}\n\nfunc assertSimpleSuggestionCallback(t *testing.T, callback *InteractionCallback) {\n\tassert.NotNil(t, callback)\n\tassert.Equal(t, InteractionTypeDialogSuggestion, callback.Type)\n\tassert.Equal(t, \"W3VDvuzi2nRLsiaDOsmJranO\", callback.Token)\n\tassert.Equal(t, \"1528203589.238335\", callback.ActionTs)\n\tassert.Equal(t, \"T24BK35ML\", callback.Team.ID)\n\tassert.Equal(t, \"hooli-hq\", callback.Team.Domain)\n\tassert.Equal(t, \"U900MV5U7\", callback.User.ID)\n\tassert.Equal(t, \"gbelson\", callback.User.Name)\n\tassert.Equal(t, \"C012AB3CD\", callback.Channel.ID)\n\tassert.Equal(t, \"triage-platform\", callback.Channel.Name)\n\tassert.Equal(t, \"external_data\", callback.Name)\n\tassert.Equal(t, \"test\", callback.Value)\n\tassert.Equal(t, \"bugs\", callback.CallbackID)\n}\n\nfunc openDialogHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tSlackResponse\n\t}{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t})\n\trw.Write(response)\n}\n\nfunc TestOpenDialog(t *testing.T) {\n\thttp.HandleFunc(\"/dialog.open\", openDialogHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tdialog, err := unmarshalDialog()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\terr = api.OpenDialog(\"TXXXXXXXX\", *dialog)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\terr = api.OpenDialog(\"\", *dialog)\n\tif err == nil {\n\t\tt.Errorf(\"Did not error with empty trigger, %s\", err)\n\t\treturn\n\t}\n}\n\nconst (\n\ttriggerID      = \"trigger_xyz\"\n\tcallbackID     = \"callback_xyz\"\n\tnotifyOnCancel = false\n\ttitle          = \"Dialog_title\"\n\tsubmitLabel    = \"Send\"\n\ttoken          = \"xoxa-123-123-123-213\"\n)\n\nfunc _mocDialog() *Dialog {\n\ttriggerID := triggerID\n\tcallbackID := callbackID\n\tnotifyOnCancel := notifyOnCancel\n\ttitle := title\n\tsubmitLabel := submitLabel\n\n\treturn &Dialog{\n\t\tTriggerID:      triggerID,\n\t\tCallbackID:     callbackID,\n\t\tNotifyOnCancel: notifyOnCancel,\n\t\tTitle:          title,\n\t\tSubmitLabel:    submitLabel,\n\t}\n}\n\nfunc TestDialogCreate(t *testing.T) {\n\tdialog := _mocDialog()\n\tif dialog == nil {\n\t\tt.Errorf(\"Should be able to construct a dialog\")\n\t\tt.Fail()\n\t}\n}\n\nfunc ExampleDialog() {\n\tdialog := _mocDialog()\n\tfmt.Println(*dialog)\n\t// Output:\n\t// {trigger_xyz callback_xyz  Dialog_title Send false []}\n}\n"
        },
        {
          "name": "dialog_text.go",
          "type": "blob",
          "size": 1.5888671875,
          "content": "package slack\n\n// TextInputSubtype Accepts email, number, tel, or url. In some form factors, optimized input is provided for this subtype.\ntype TextInputSubtype string\n\n// TextInputOption handle to extra inputs options.\ntype TextInputOption func(*TextInputElement)\n\nconst (\n\t// InputSubtypeEmail email keyboard\n\tInputSubtypeEmail TextInputSubtype = \"email\"\n\t// InputSubtypeNumber numeric keyboard\n\tInputSubtypeNumber TextInputSubtype = \"number\"\n\t// InputSubtypeTel Phone keyboard\n\tInputSubtypeTel TextInputSubtype = \"tel\"\n\t// InputSubtypeURL Phone keyboard\n\tInputSubtypeURL TextInputSubtype = \"url\"\n)\n\n// TextInputElement subtype of DialogInput\n// https://api.slack.com/dialogs#option_element_attributes#text_element_attributes\ntype TextInputElement struct {\n\tDialogInput\n\tMaxLength int              `json:\"max_length,omitempty\"`\n\tMinLength int              `json:\"min_length,omitempty\"`\n\tHint      string           `json:\"hint,omitempty\"`\n\tSubtype   TextInputSubtype `json:\"subtype\"`\n\tValue     string           `json:\"value\"`\n}\n\n// NewTextInput constructor for a `text` input\nfunc NewTextInput(name, label, text string, options ...TextInputOption) *TextInputElement {\n\tt := &TextInputElement{\n\t\tDialogInput: DialogInput{\n\t\t\tType:  InputTypeText,\n\t\t\tName:  name,\n\t\t\tLabel: label,\n\t\t},\n\t\tValue: text,\n\t}\n\n\tfor _, opt := range options {\n\t\topt(t)\n\t}\n\n\treturn t\n}\n\n// NewTextAreaInput constructor for a `textarea` input\nfunc NewTextAreaInput(name, label, text string) *TextInputElement {\n\treturn &TextInputElement{\n\t\tDialogInput: DialogInput{\n\t\t\tType:  InputTypeTextArea,\n\t\t\tName:  name,\n\t\t\tLabel: label,\n\t\t},\n\t\tValue: text,\n\t}\n}\n"
        },
        {
          "name": "dialog_text_test.go",
          "type": "blob",
          "size": 0.7421875,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewTextInput(t *testing.T) {\n\tname := \"internalName\"\n\tlabel := \"Human Readable\"\n\tvalue := \"Pre filled text\"\n\ttextInput := NewTextInput(name, label, value)\n\tassert.Equal(t, InputTypeText, textInput.Type)\n\tassert.Equal(t, name, textInput.Name)\n\tassert.Equal(t, label, textInput.Label)\n\tassert.Equal(t, value, textInput.Value)\n}\n\nfunc TestNewTextAreaInput(t *testing.T) {\n\tname := \"internalName\"\n\tlabel := \"Human Readable\"\n\tvalue := \"Pre filled text\"\n\ttextInput := NewTextAreaInput(name, label, value)\n\tassert.Equal(t, InputTypeTextArea, textInput.Type)\n\tassert.Equal(t, name, textInput.Name)\n\tassert.Equal(t, label, textInput.Label)\n\tassert.Equal(t, value, textInput.Value)\n}\n"
        },
        {
          "name": "dnd.go",
          "type": "blob",
          "size": 4.7294921875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype SnoozeDebug struct {\n\tSnoozeEndDate string `json:\"snooze_end_date\"`\n}\n\ntype SnoozeInfo struct {\n\tSnoozeEnabled   bool        `json:\"snooze_enabled,omitempty\"`\n\tSnoozeEndTime   int         `json:\"snooze_endtime,omitempty\"`\n\tSnoozeRemaining int         `json:\"snooze_remaining,omitempty\"`\n\tSnoozeDebug     SnoozeDebug `json:\"snooze_debug,omitempty\"`\n}\n\ntype DNDStatus struct {\n\tEnabled            bool `json:\"dnd_enabled\"`\n\tNextStartTimestamp int  `json:\"next_dnd_start_ts\"`\n\tNextEndTimestamp   int  `json:\"next_dnd_end_ts\"`\n\tSnoozeInfo\n}\n\ntype dndResponseFull struct {\n\tDNDStatus\n\tSlackResponse\n}\n\ntype dndTeamInfoResponse struct {\n\tUsers map[string]DNDStatus `json:\"users\"`\n\tSlackResponse\n}\n\nfunc (api *Client) dndRequest(ctx context.Context, path string, values url.Values) (*dndResponseFull, error) {\n\tresponse := &dndResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// EndDND ends the user's scheduled Do Not Disturb session.\n// For more information see the EndDNDContext documentation.\nfunc (api *Client) EndDND() error {\n\treturn api.EndDNDContext(context.Background())\n}\n\n// EndDNDContext ends the user's scheduled Do Not Disturb session with a custom context.\n// Slack API docs: https://api.slack.com/methods/dnd.endDnd\nfunc (api *Client) EndDNDContext(ctx context.Context) error {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tresponse := &SlackResponse{}\n\n\tif err := api.postMethod(ctx, \"dnd.endDnd\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// EndSnooze ends the current user's snooze mode.\n// For more information see the EndSnoozeContext documentation.\nfunc (api *Client) EndSnooze() (*DNDStatus, error) {\n\treturn api.EndSnoozeContext(context.Background())\n}\n\n// EndSnoozeContext ends the current user's snooze mode with a custom context.\n// Slack API docs: https://api.slack.com/methods/dnd.endSnooze\nfunc (api *Client) EndSnoozeContext(ctx context.Context) (*DNDStatus, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tresponse, err := api.dndRequest(ctx, \"dnd.endSnooze\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.DNDStatus, nil\n}\n\n// GetDNDInfo provides information about a user's current Do Not Disturb settings.\n// For more information see the GetDNDInfoContext documentation.\nfunc (api *Client) GetDNDInfo(user *string) (*DNDStatus, error) {\n\treturn api.GetDNDInfoContext(context.Background(), user)\n}\n\n// GetDNDInfoContext provides information about a user's current Do Not Disturb settings with a custom context.\n// Slack API docs: https://api.slack.com/methods/dnd.info\nfunc (api *Client) GetDNDInfoContext(ctx context.Context, user *string) (*DNDStatus, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif user != nil {\n\t\tvalues.Set(\"user\", *user)\n\t}\n\n\tresponse, err := api.dndRequest(ctx, \"dnd.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.DNDStatus, nil\n}\n\n// GetDNDTeamInfo provides information about a user's current Do Not Disturb settings.\n// For more information see the GetDNDTeamInfoContext documentation.\nfunc (api *Client) GetDNDTeamInfo(users []string) (map[string]DNDStatus, error) {\n\treturn api.GetDNDTeamInfoContext(context.Background(), users)\n}\n\n// GetDNDTeamInfoContext provides information about a user's current Do Not Disturb settings with a custom context.\n// Slack API docs: https://api.slack.com/methods/dnd.teamInfo\nfunc (api *Client) GetDNDTeamInfoContext(ctx context.Context, users []string) (map[string]DNDStatus, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"users\": {strings.Join(users, \",\")},\n\t}\n\tresponse := &dndTeamInfoResponse{}\n\n\tif err := api.postMethod(ctx, \"dnd.teamInfo\", values, response); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response.Err() != nil {\n\t\treturn nil, response.Err()\n\t}\n\n\treturn response.Users, nil\n}\n\n// SetSnooze adjusts the snooze duration for a user's Do Not Disturb settings.\n// For more information see the SetSnoozeContext documentation.\nfunc (api *Client) SetSnooze(minutes int) (*DNDStatus, error) {\n\treturn api.SetSnoozeContext(context.Background(), minutes)\n}\n\n// SetSnoozeContext adjusts the snooze duration for a user's Do Not Disturb settings.\n// If a snooze session is not already active for the user, invoking this method will\n// begin one for the specified duration.\n// Slack API docs: https://api.slack.com/methods/dnd.setSnooze\nfunc (api *Client) SetSnoozeContext(ctx context.Context, minutes int) (*DNDStatus, error) {\n\tvalues := url.Values{\n\t\t\"token\":       {api.token},\n\t\t\"num_minutes\": {strconv.Itoa(minutes)},\n\t}\n\n\tresponse, err := api.dndRequest(ctx, \"dnd.setSnooze\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.DNDStatus, nil\n}\n"
        },
        {
          "name": "dnd_test.go",
          "type": "blob",
          "size": 4.3515625,
          "content": "package slack\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSlack_EndDND(t *testing.T) {\n\thttp.HandleFunc(\"/dnd.endDnd\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{ \"ok\": true }`))\n\t})\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.EndDND()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestSlack_EndSnooze(t *testing.T) {\n\thttp.HandleFunc(\"/dnd.endSnooze\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{ \"ok\": true,\n                          \"dnd_enabled\": true,\n                          \"next_dnd_start_ts\": 1450418400,\n                          \"next_dnd_end_ts\": 1450454400,\n                          \"snooze_enabled\": false }`))\n\t})\n\tstate := DNDStatus{\n\t\tEnabled:            true,\n\t\tNextStartTimestamp: 1450418400,\n\t\tNextEndTimestamp:   1450454400,\n\t\tSnoozeInfo:         SnoozeInfo{SnoozeEnabled: false},\n\t}\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tsnoozeState, err := api.EndSnooze()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\teq := reflect.DeepEqual(snoozeState, &state)\n\tif !eq {\n\t\tt.Errorf(\"got %v; want %v\", snoozeState, &state)\n\t}\n}\n\nfunc TestSlack_GetDNDInfo(t *testing.T) {\n\thttp.HandleFunc(\"/dnd.info\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\n            \"ok\": true,\n            \"dnd_enabled\": true,\n            \"next_dnd_start_ts\": 1450416600,\n            \"next_dnd_end_ts\": 1450452600,\n            \"snooze_enabled\": true,\n            \"snooze_endtime\": 1450416600,\n            \"snooze_remaining\": 1196\n        }`))\n\t})\n\tuserDNDInfo := DNDStatus{\n\t\tEnabled:            true,\n\t\tNextStartTimestamp: 1450416600,\n\t\tNextEndTimestamp:   1450452600,\n\t\tSnoozeInfo: SnoozeInfo{\n\t\t\tSnoozeEnabled:   true,\n\t\t\tSnoozeEndTime:   1450416600,\n\t\t\tSnoozeRemaining: 1196,\n\t\t},\n\t}\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tuserDNDInfoResponse, err := api.GetDNDInfo(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\teq := reflect.DeepEqual(userDNDInfoResponse, &userDNDInfo)\n\tif !eq {\n\t\tt.Errorf(\"got %v; want %v\", userDNDInfoResponse, &userDNDInfo)\n\t}\n}\n\nfunc TestSlack_GetDNDTeamInfo(t *testing.T) {\n\thttp.HandleFunc(\"/dnd.teamInfo\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\n            \"ok\": true,\n            \"users\": {\n                \"U023BECGF\": {\n                    \"dnd_enabled\": true,\n                    \"next_dnd_start_ts\": 1450387800,\n                    \"next_dnd_end_ts\": 1450423800\n                },\n                \"U058CJVAA\": {\n                    \"dnd_enabled\": false,\n                    \"next_dnd_start_ts\": 1,\n                    \"next_dnd_end_ts\": 1\n                }\n            }\n        }`))\n\t})\n\tusersDNDInfo := map[string]DNDStatus{\n\t\t\"U023BECGF\": {\n\t\t\tEnabled:            true,\n\t\t\tNextStartTimestamp: 1450387800,\n\t\t\tNextEndTimestamp:   1450423800,\n\t\t},\n\t\t\"U058CJVAA\": {\n\t\t\tEnabled:            false,\n\t\t\tNextStartTimestamp: 1,\n\t\t\tNextEndTimestamp:   1,\n\t\t},\n\t}\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tusersDNDInfoResponse, err := api.GetDNDTeamInfo(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\teq := reflect.DeepEqual(usersDNDInfoResponse, usersDNDInfo)\n\tif !eq {\n\t\tt.Errorf(\"got %v; want %v\", usersDNDInfoResponse, usersDNDInfo)\n\t}\n}\n\nfunc TestSlack_SetSnooze(t *testing.T) {\n\thttp.HandleFunc(\"/dnd.setSnooze\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\n            \"ok\": true,\n            \"dnd_enabled\": true,\n            \"snooze_endtime\": 1450373897,\n            \"snooze_remaining\": 60\n        }`))\n\t})\n\tsnooze := DNDStatus{\n\t\tEnabled: true,\n\t\tSnoozeInfo: SnoozeInfo{\n\t\t\tSnoozeEndTime:   1450373897,\n\t\t\tSnoozeRemaining: 60,\n\t\t},\n\t}\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tsnoozeResponse, err := api.SetSnooze(60)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\teq := reflect.DeepEqual(snoozeResponse, &snooze)\n\tif !eq {\n\t\tt.Errorf(\"got %v; want %v\", snoozeResponse, &snooze)\n\t}\n}\n"
        },
        {
          "name": "emoji.go",
          "type": "blob",
          "size": 0.8115234375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\ntype emojiResponseFull struct {\n\tEmoji map[string]string `json:\"emoji\"`\n\tSlackResponse\n}\n\n// GetEmoji retrieves all the emojis.\n// For more details see GetEmojiContext documentation.\nfunc (api *Client) GetEmoji() (map[string]string, error) {\n\treturn api.GetEmojiContext(context.Background())\n}\n\n// GetEmojiContext retrieves all the emojis with a custom context.\n// Slack API docs: https://api.slack.com/methods/emoji.list\nfunc (api *Client) GetEmojiContext(ctx context.Context) (map[string]string, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tresponse := &emojiResponseFull{}\n\n\terr := api.postMethod(ctx, \"emoji.list\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response.Err() != nil {\n\t\treturn nil, response.Err()\n\t}\n\n\treturn response.Emoji, nil\n}\n"
        },
        {
          "name": "emoji_test.go",
          "type": "blob",
          "size": 0.994140625,
          "content": "package slack\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc getEmojiHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\"ok\": true, \"emoji\": {\n\t\t\t\"bowtie\": \"https://my.slack.com/emoji/bowtie/46ec6f2bb0.png\",\n\t\t\t\"squirrel\": \"https://my.slack.com/emoji/squirrel/f35f40c0e0.png\",\n\t\t\t\"shipit\": \"alias:squirrel\"\n\t\t}}`)\n\trw.Write(response)\n}\n\nfunc TestGetEmoji(t *testing.T) {\n\thttp.HandleFunc(\"/emoji.list\", getEmojiHandler)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\temojisResponse := map[string]string{\n\t\t\"bowtie\":   \"https://my.slack.com/emoji/bowtie/46ec6f2bb0.png\",\n\t\t\"squirrel\": \"https://my.slack.com/emoji/squirrel/f35f40c0e0.png\",\n\t\t\"shipit\":   \"alias:squirrel\",\n\t}\n\n\temojis, err := api.GetEmoji()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\teq := reflect.DeepEqual(emojis, emojisResponse)\n\tif !eq {\n\t\tt.Errorf(\"got %v; want %v\", emojis, emojisResponse)\n\t}\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.8564453125,
          "content": "package slack\n\nimport \"github.com/slack-go/slack/internal/errorsx\"\n\n// Errors returned by various methods.\nconst (\n\tErrAlreadyDisconnected  = errorsx.String(\"Invalid call to Disconnect - Slack API is already disconnected\")\n\tErrRTMDisconnected      = errorsx.String(\"disconnect received while trying to connect\")\n\tErrRTMGoodbye           = errorsx.String(\"goodbye detected\")\n\tErrRTMDeadman           = errorsx.String(\"deadman switch triggered\")\n\tErrParametersMissing    = errorsx.String(\"received empty parameters\")\n\tErrBlockIDNotUnique     = errorsx.String(\"Block ID needs to be unique\")\n\tErrInvalidConfiguration = errorsx.String(\"invalid configuration\")\n\tErrMissingHeaders       = errorsx.String(\"missing headers\")\n\tErrExpiredTimestamp     = errorsx.String(\"timestamp is too old\")\n)\n\n// internal errors\nconst (\n\terrPaginationComplete = errorsx.String(\"pagination complete\")\n)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "files.go",
          "type": "blob",
          "size": 20.1875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\t// Add here the defaults in the site\n\tDEFAULT_FILES_USER        = \"\"\n\tDEFAULT_FILES_CHANNEL     = \"\"\n\tDEFAULT_FILES_TS_FROM     = 0\n\tDEFAULT_FILES_TS_TO       = -1\n\tDEFAULT_FILES_TYPES       = \"all\"\n\tDEFAULT_FILES_COUNT       = 100\n\tDEFAULT_FILES_PAGE        = 1\n\tDEFAULT_FILES_SHOW_HIDDEN = false\n)\n\n// File contains all the information for a file\ntype File struct {\n\tID        string   `json:\"id\"`\n\tCreated   JSONTime `json:\"created\"`\n\tTimestamp JSONTime `json:\"timestamp\"`\n\n\tName              string `json:\"name\"`\n\tTitle             string `json:\"title\"`\n\tMimetype          string `json:\"mimetype\"`\n\tImageExifRotation int    `json:\"image_exif_rotation\"`\n\tFiletype          string `json:\"filetype\"`\n\tPrettyType        string `json:\"pretty_type\"`\n\tUser              string `json:\"user\"`\n\n\tMode         string `json:\"mode\"`\n\tEditable     bool   `json:\"editable\"`\n\tIsExternal   bool   `json:\"is_external\"`\n\tExternalType string `json:\"external_type\"`\n\n\tSize int `json:\"size\"`\n\n\tURL                string `json:\"url\"`          // Deprecated - never set\n\tURLDownload        string `json:\"url_download\"` // Deprecated - never set\n\tURLPrivate         string `json:\"url_private\"`\n\tURLPrivateDownload string `json:\"url_private_download\"`\n\n\tOriginalH   int    `json:\"original_h\"`\n\tOriginalW   int    `json:\"original_w\"`\n\tThumb64     string `json:\"thumb_64\"`\n\tThumb80     string `json:\"thumb_80\"`\n\tThumb160    string `json:\"thumb_160\"`\n\tThumb360    string `json:\"thumb_360\"`\n\tThumb360Gif string `json:\"thumb_360_gif\"`\n\tThumb360W   int    `json:\"thumb_360_w\"`\n\tThumb360H   int    `json:\"thumb_360_h\"`\n\tThumb480    string `json:\"thumb_480\"`\n\tThumb480W   int    `json:\"thumb_480_w\"`\n\tThumb480H   int    `json:\"thumb_480_h\"`\n\tThumb720    string `json:\"thumb_720\"`\n\tThumb720W   int    `json:\"thumb_720_w\"`\n\tThumb720H   int    `json:\"thumb_720_h\"`\n\tThumb960    string `json:\"thumb_960\"`\n\tThumb960W   int    `json:\"thumb_960_w\"`\n\tThumb960H   int    `json:\"thumb_960_h\"`\n\tThumb1024   string `json:\"thumb_1024\"`\n\tThumb1024W  int    `json:\"thumb_1024_w\"`\n\tThumb1024H  int    `json:\"thumb_1024_h\"`\n\n\tPermalink       string `json:\"permalink\"`\n\tPermalinkPublic string `json:\"permalink_public\"`\n\n\tEditLink         string `json:\"edit_link\"`\n\tPreview          string `json:\"preview\"`\n\tPreviewHighlight string `json:\"preview_highlight\"`\n\tLines            int    `json:\"lines\"`\n\tLinesMore        int    `json:\"lines_more\"`\n\n\tIsPublic        bool     `json:\"is_public\"`\n\tPublicURLShared bool     `json:\"public_url_shared\"`\n\tChannels        []string `json:\"channels\"`\n\tGroups          []string `json:\"groups\"`\n\tIMs             []string `json:\"ims\"`\n\tInitialComment  Comment  `json:\"initial_comment\"`\n\tCommentsCount   int      `json:\"comments_count\"`\n\tNumStars        int      `json:\"num_stars\"`\n\tIsStarred       bool     `json:\"is_starred\"`\n\tShares          Share    `json:\"shares\"`\n}\n\ntype Share struct {\n\tPublic  map[string][]ShareFileInfo `json:\"public\"`\n\tPrivate map[string][]ShareFileInfo `json:\"private\"`\n}\n\ntype ShareFileInfo struct {\n\tReplyUsers      []string `json:\"reply_users\"`\n\tReplyUsersCount int      `json:\"reply_users_count\"`\n\tReplyCount      int      `json:\"reply_count\"`\n\tTs              string   `json:\"ts\"`\n\tThreadTs        string   `json:\"thread_ts\"`\n\tLatestReply     string   `json:\"latest_reply\"`\n\tChannelName     string   `json:\"channel_name\"`\n\tTeamID          string   `json:\"team_id\"`\n}\n\n// FileUploadParameters contains all the parameters necessary (including the optional ones) for an UploadFile() request.\n//\n// There are three ways to upload a file. You can either set Content if file is small, set Reader if file is large,\n// or provide a local file path in File to upload it from your filesystem.\n//\n// Note that when using the Reader option, you *must* specify the Filename, otherwise the Slack API isn't happy.\ntype FileUploadParameters struct {\n\tFile            string\n\tContent         string\n\tReader          io.Reader\n\tFiletype        string\n\tFilename        string\n\tTitle           string\n\tInitialComment  string\n\tChannels        []string\n\tThreadTimestamp string\n}\n\n// GetFilesParameters contains all the parameters necessary (including the optional ones) for a GetFiles() request\ntype GetFilesParameters struct {\n\tUser          string\n\tChannel       string\n\tTeamID        string\n\tTimestampFrom JSONTime\n\tTimestampTo   JSONTime\n\tTypes         string\n\tCount         int\n\tPage          int\n\tShowHidden    bool\n}\n\n// ListFilesParameters contains all the parameters necessary (including the optional ones) for a ListFiles() request\ntype ListFilesParameters struct {\n\tLimit   int\n\tUser    string\n\tChannel string\n\tTeamID  string\n\tTypes   string\n\tCursor  string\n}\n\ntype UploadFileV2Parameters struct {\n\tFile            string\n\tFileSize        int\n\tContent         string\n\tReader          io.Reader\n\tFilename        string\n\tTitle           string\n\tInitialComment  string\n\tChannel         string\n\tThreadTimestamp string\n\tAltTxt          string\n\tSnippetText     string\n}\n\ntype getUploadURLExternalParameters struct {\n\taltText     string\n\tfileSize    int\n\tfileName    string\n\tsnippetText string\n}\n\ntype getUploadURLExternalResponse struct {\n\tUploadURL string `json:\"upload_url\"`\n\tFileID    string `json:\"file_id\"`\n\tSlackResponse\n}\n\ntype uploadToURLParameters struct {\n\tUploadURL string\n\tReader    io.Reader\n\tFile      string\n\tContent   string\n\tFilename  string\n}\n\ntype FileSummary struct {\n\tID    string `json:\"id\"`\n\tTitle string `json:\"title\"`\n}\n\ntype completeUploadExternalParameters struct {\n\ttitle           string\n\tchannel         string\n\tinitialComment  string\n\tthreadTimestamp string\n}\n\ntype completeUploadExternalResponse struct {\n\tSlackResponse\n\tFiles []FileSummary `json:\"files\"`\n}\n\ntype fileResponseFull struct {\n\tFile     `json:\"file\"`\n\tPaging   `json:\"paging\"`\n\tComments []Comment        `json:\"comments\"`\n\tFiles    []File           `json:\"files\"`\n\tMetadata ResponseMetadata `json:\"response_metadata\"`\n\n\tSlackResponse\n}\n\n// NewGetFilesParameters provides an instance of GetFilesParameters with all the sane default values set\nfunc NewGetFilesParameters() GetFilesParameters {\n\treturn GetFilesParameters{\n\t\tUser:          DEFAULT_FILES_USER,\n\t\tChannel:       DEFAULT_FILES_CHANNEL,\n\t\tTimestampFrom: DEFAULT_FILES_TS_FROM,\n\t\tTimestampTo:   DEFAULT_FILES_TS_TO,\n\t\tTypes:         DEFAULT_FILES_TYPES,\n\t\tCount:         DEFAULT_FILES_COUNT,\n\t\tPage:          DEFAULT_FILES_PAGE,\n\t\tShowHidden:    DEFAULT_FILES_SHOW_HIDDEN,\n\t}\n}\n\nfunc (api *Client) fileRequest(ctx context.Context, path string, values url.Values) (*fileResponseFull, error) {\n\tresponse := &fileResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// GetFileInfo retrieves a file and related comments.\n// For more details, see GetFileInfoContext documentation.\nfunc (api *Client) GetFileInfo(fileID string, count, page int) (*File, []Comment, *Paging, error) {\n\treturn api.GetFileInfoContext(context.Background(), fileID, count, page)\n}\n\n// GetFileInfoContext retrieves a file and related comments with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.info\nfunc (api *Client) GetFileInfoContext(ctx context.Context, fileID string, count, page int) (*File, []Comment, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"file\":  {fileID},\n\t\t\"count\": {strconv.Itoa(count)},\n\t\t\"page\":  {strconv.Itoa(page)},\n\t}\n\n\tresponse, err := api.fileRequest(ctx, \"files.info\", values)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\treturn &response.File, response.Comments, &response.Paging, nil\n}\n\n// GetFile retrieves a given file from its private download URL.\nfunc (api *Client) GetFile(downloadURL string, writer io.Writer) error {\n\treturn api.GetFileContext(context.Background(), downloadURL, writer)\n}\n\n// GetFileContext retrieves a given file from its private download URL with a custom context.\n// For more details, see GetFile documentation.\nfunc (api *Client) GetFileContext(ctx context.Context, downloadURL string, writer io.Writer) error {\n\treturn downloadFile(ctx, api.httpclient, api.token, downloadURL, writer, api)\n}\n\n// GetFiles retrieves all files according to the parameters given.\n// For more details, see GetFilesContext documentation.\nfunc (api *Client) GetFiles(params GetFilesParameters) ([]File, *Paging, error) {\n\treturn api.GetFilesContext(context.Background(), params)\n}\n\n// GetFilesContext retrieves all files according to the parameters given with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.list\nfunc (api *Client) GetFilesContext(ctx context.Context, params GetFilesParameters) ([]File, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.User != DEFAULT_FILES_USER {\n\t\tvalues.Add(\"user\", params.User)\n\t}\n\tif params.Channel != DEFAULT_FILES_CHANNEL {\n\t\tvalues.Add(\"channel\", params.Channel)\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.TimestampFrom != DEFAULT_FILES_TS_FROM {\n\t\tvalues.Add(\"ts_from\", strconv.FormatInt(int64(params.TimestampFrom), 10))\n\t}\n\tif params.TimestampTo != DEFAULT_FILES_TS_TO {\n\t\tvalues.Add(\"ts_to\", strconv.FormatInt(int64(params.TimestampTo), 10))\n\t}\n\tif params.Types != DEFAULT_FILES_TYPES {\n\t\tvalues.Add(\"types\", params.Types)\n\t}\n\tif params.Count != DEFAULT_FILES_COUNT {\n\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n\t}\n\tif params.Page != DEFAULT_FILES_PAGE {\n\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n\t}\n\tif params.ShowHidden != DEFAULT_FILES_SHOW_HIDDEN {\n\t\tvalues.Add(\"show_files_hidden_by_limit\", strconv.FormatBool(params.ShowHidden))\n\t}\n\n\tresponse, err := api.fileRequest(ctx, \"files.list\", values)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn response.Files, &response.Paging, nil\n}\n\n// ListFiles retrieves all files according to the parameters given. Uses cursor based pagination.\n// For more details, see ListFilesContext documentation.\nfunc (api *Client) ListFiles(params ListFilesParameters) ([]File, *ListFilesParameters, error) {\n\treturn api.ListFilesContext(context.Background(), params)\n}\n\n// ListFilesContext retrieves all files according to the parameters given with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.list\nfunc (api *Client) ListFilesContext(ctx context.Context, params ListFilesParameters) ([]File, *ListFilesParameters, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tif params.User != DEFAULT_FILES_USER {\n\t\tvalues.Add(\"user\", params.User)\n\t}\n\tif params.Channel != DEFAULT_FILES_CHANNEL {\n\t\tvalues.Add(\"channel\", params.Channel)\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.Limit != DEFAULT_FILES_COUNT {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\n\tresponse, err := api.fileRequest(ctx, \"files.list\", values)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tparams.Cursor = response.Metadata.Cursor\n\n\treturn response.Files, &params, nil\n}\n\n// UploadFile uploads a file.\n//\n// Deprecated: Use [Client.UploadFileV2] instead. This will stop functioning on March 11, 2025.\n// For more details, see: https://api.slack.com/methods/files.upload#markdown\nfunc (api *Client) UploadFile(params FileUploadParameters) (file *File, err error) {\n\treturn api.UploadFileContext(context.Background(), params)\n}\n\n// UploadFileContext uploads a file and setting a custom context.\n//\n// Deprecated: Use [Client.UploadFileV2Context] instead. This will stop functioning on March 11, 2025.\n// For more details, see: https://api.slack.com/methods/files.upload#markdown\nfunc (api *Client) UploadFileContext(ctx context.Context, params FileUploadParameters) (file *File, err error) {\n\t// Test if user token is valid. This helps because client.Do doesn't like this for some reason. XXX: More\n\t// investigation needed, but for now this will do.\n\t_, err = api.AuthTestContext(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresponse := &fileResponseFull{}\n\tvalues := url.Values{}\n\tif params.Filetype != \"\" {\n\t\tvalues.Add(\"filetype\", params.Filetype)\n\t}\n\tif params.Filename != \"\" {\n\t\tvalues.Add(\"filename\", params.Filename)\n\t}\n\tif params.Title != \"\" {\n\t\tvalues.Add(\"title\", params.Title)\n\t}\n\tif params.InitialComment != \"\" {\n\t\tvalues.Add(\"initial_comment\", params.InitialComment)\n\t}\n\tif params.ThreadTimestamp != \"\" {\n\t\tvalues.Add(\"thread_ts\", params.ThreadTimestamp)\n\t}\n\tif len(params.Channels) != 0 {\n\t\tvalues.Add(\"channels\", strings.Join(params.Channels, \",\"))\n\t}\n\tif params.Content != \"\" {\n\t\tvalues.Add(\"content\", params.Content)\n\t\tvalues.Add(\"token\", api.token)\n\t\terr = api.postMethod(ctx, \"files.upload\", values, response)\n\t} else if params.File != \"\" {\n\t\terr = postLocalWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.upload\", params.File, \"file\", api.token, values, response, api)\n\t} else if params.Reader != nil {\n\t\tif params.Filename == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"files.upload: FileUploadParameters.Filename is mandatory when using FileUploadParameters.Reader\")\n\t\t}\n\t\terr = postWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.upload\", params.Filename, \"file\", api.token, values, params.Reader, response, api)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.File, response.Err()\n}\n\n// DeleteFileComment deletes a file's comment.\n// For more details, see DeleteFileCommentContext documentation.\nfunc (api *Client) DeleteFileComment(commentID, fileID string) error {\n\treturn api.DeleteFileCommentContext(context.Background(), fileID, commentID)\n}\n\n// DeleteFileCommentContext deletes a file's comment with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.comments.delete\nfunc (api *Client) DeleteFileCommentContext(ctx context.Context, fileID, commentID string) (err error) {\n\tif fileID == \"\" || commentID == \"\" {\n\t\treturn ErrParametersMissing\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"file\":  {fileID},\n\t\t\"id\":    {commentID},\n\t}\n\t_, err = api.fileRequest(ctx, \"files.comments.delete\", values)\n\treturn err\n}\n\n// DeleteFile deletes a file.\n// For more details, see DeleteFileContext documentation.\nfunc (api *Client) DeleteFile(fileID string) error {\n\treturn api.DeleteFileContext(context.Background(), fileID)\n}\n\n// DeleteFileContext deletes a file with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.delete\nfunc (api *Client) DeleteFileContext(ctx context.Context, fileID string) (err error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"file\":  {fileID},\n\t}\n\n\t_, err = api.fileRequest(ctx, \"files.delete\", values)\n\treturn err\n}\n\n// RevokeFilePublicURL disables public/external sharing for a file.\n// For more details, see RevokeFilePublicURLContext documentation.\nfunc (api *Client) RevokeFilePublicURL(fileID string) (*File, error) {\n\treturn api.RevokeFilePublicURLContext(context.Background(), fileID)\n}\n\n// RevokeFilePublicURLContext disables public/external sharing for a file with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.revokePublicURL\nfunc (api *Client) RevokeFilePublicURLContext(ctx context.Context, fileID string) (*File, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"file\":  {fileID},\n\t}\n\n\tresponse, err := api.fileRequest(ctx, \"files.revokePublicURL\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.File, nil\n}\n\n// ShareFilePublicURL enabled public/external sharing for a file.\n// For more details, see ShareFilePublicURLContext documentation.\nfunc (api *Client) ShareFilePublicURL(fileID string) (*File, []Comment, *Paging, error) {\n\treturn api.ShareFilePublicURLContext(context.Background(), fileID)\n}\n\n// ShareFilePublicURLContext enabled public/external sharing for a file with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.sharedPublicURL\nfunc (api *Client) ShareFilePublicURLContext(ctx context.Context, fileID string) (*File, []Comment, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"file\":  {fileID},\n\t}\n\n\tresponse, err := api.fileRequest(ctx, \"files.sharedPublicURL\", values)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\treturn &response.File, response.Comments, &response.Paging, nil\n}\n\n// getUploadURLExternal gets a URL and fileID from slack which can later be used to upload a file.\nfunc (api *Client) getUploadURLExternal(ctx context.Context, params getUploadURLExternalParameters) (*getUploadURLExternalResponse, error) {\n\tvalues := url.Values{\n\t\t\"token\":    {api.token},\n\t\t\"filename\": {params.fileName},\n\t\t\"length\":   {strconv.Itoa(params.fileSize)},\n\t}\n\tif params.altText != \"\" {\n\t\tvalues.Add(\"initial_comment\", params.altText)\n\t}\n\tif params.snippetText != \"\" {\n\t\tvalues.Add(\"thread_ts\", params.snippetText)\n\t}\n\tresponse := &getUploadURLExternalResponse{}\n\terr := api.postMethod(ctx, \"files.getUploadURLExternal\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// uploadToURL uploads the file to the provided URL using post method\nfunc (api *Client) uploadToURL(ctx context.Context, params uploadToURLParameters) (err error) {\n\tvalues := url.Values{}\n\tif params.Content != \"\" {\n\t\tcontentReader := strings.NewReader(params.Content)\n\t\terr = postWithMultipartResponse(ctx, api.httpclient, params.UploadURL, params.Filename, \"file\", api.token, values, contentReader, nil, api)\n\t} else if params.File != \"\" {\n\t\terr = postLocalWithMultipartResponse(ctx, api.httpclient, params.UploadURL, params.File, \"file\", api.token, values, nil, api)\n\t} else if params.Reader != nil {\n\t\terr = postWithMultipartResponse(ctx, api.httpclient, params.UploadURL, params.Filename, \"file\", api.token, values, params.Reader, nil, api)\n\t}\n\treturn err\n}\n\n// completeUploadExternal once files are uploaded, this completes the upload and shares it to the specified channel\nfunc (api *Client) completeUploadExternal(ctx context.Context, fileID string, params completeUploadExternalParameters) (file *completeUploadExternalResponse, err error) {\n\trequest := []FileSummary{{ID: fileID, Title: params.title}}\n\trequestBytes, err := json.Marshal(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"files\": {string(requestBytes)},\n\t}\n\n\tif params.channel != \"\" {\n\t\tvalues.Add(\"channel_id\", params.channel)\n\t}\n\tif params.initialComment != \"\" {\n\t\tvalues.Add(\"initial_comment\", params.initialComment)\n\t}\n\tif params.threadTimestamp != \"\" {\n\t\tvalues.Add(\"thread_ts\", params.threadTimestamp)\n\t}\n\tresponse := &completeUploadExternalResponse{}\n\terr = api.postMethod(ctx, \"files.completeUploadExternal\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif response.Err() != nil {\n\t\treturn nil, response.Err()\n\t}\n\treturn response, nil\n}\n\n// UploadFileV2 uploads file to a given slack channel using 3 steps.\n// For more details, see UploadFileV2Context documentation.\nfunc (api *Client) UploadFileV2(params UploadFileV2Parameters) (*FileSummary, error) {\n\treturn api.UploadFileV2Context(context.Background(), params)\n}\n\n// UploadFileV2Context uploads file to a given slack channel using 3 steps -\n//  1. Get an upload URL using files.getUploadURLExternal API\n//  2. Send the file as a post to the URL provided by slack\n//  3. Complete the upload and share it to the specified channel using files.completeUploadExternal\n//\n// Slack Docs: https://api.slack.com/messaging/files#uploading_files\nfunc (api *Client) UploadFileV2Context(ctx context.Context, params UploadFileV2Parameters) (file *FileSummary, err error) {\n\tif params.Filename == \"\" {\n\t\treturn nil, fmt.Errorf(\"file.upload.v2: filename cannot be empty\")\n\t}\n\tif params.FileSize == 0 {\n\t\treturn nil, fmt.Errorf(\"file.upload.v2: file size cannot be 0\")\n\t}\n\n\tu, err := api.getUploadURLExternal(ctx, getUploadURLExternalParameters{\n\t\taltText:     params.AltTxt,\n\t\tfileName:    params.Filename,\n\t\tfileSize:    params.FileSize,\n\t\tsnippetText: params.SnippetText,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = api.uploadToURL(ctx, uploadToURLParameters{\n\t\tUploadURL: u.UploadURL,\n\t\tReader:    params.Reader,\n\t\tFile:      params.File,\n\t\tContent:   params.Content,\n\t\tFilename:  params.Filename,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc, err := api.completeUploadExternal(ctx, u.FileID, completeUploadExternalParameters{\n\t\ttitle:           params.Title,\n\t\tchannel:         params.Channel,\n\t\tinitialComment:  params.InitialComment,\n\t\tthreadTimestamp: params.ThreadTimestamp,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(c.Files) != 1 {\n\t\treturn nil, fmt.Errorf(\"file.upload.v2: something went wrong; received %d files instead of 1\", len(c.Files))\n\t}\n\n\treturn &c.Files[0], nil\n}\n"
        },
        {
          "name": "files_test.go",
          "type": "blob",
          "size": 7.4482421875,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype fileCommentHandler struct {\n\tgotParams map[string]string\n}\n\nfunc newFileCommentHandler() *fileCommentHandler {\n\treturn &fileCommentHandler{\n\t\tgotParams: make(map[string]string),\n\t}\n}\n\nfunc (h *fileCommentHandler) accumulateFormValue(k string, r *http.Request) {\n\tif v := r.FormValue(k); v != \"\" {\n\t\th.gotParams[k] = v\n\t}\n}\n\nfunc (h *fileCommentHandler) handler(w http.ResponseWriter, r *http.Request) {\n\th.accumulateFormValue(\"token\", r)\n\th.accumulateFormValue(\"file\", r)\n\th.accumulateFormValue(\"id\", r)\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif h.gotParams[\"id\"] == \"trigger-error\" {\n\t\tw.Write([]byte(`{ \"ok\": false, \"error\": \"errored\" }`))\n\t} else {\n\t\tw.Write([]byte(`{ \"ok\": true }`))\n\t}\n}\n\ntype mockHTTPClient struct{}\n\nfunc (m *mockHTTPClient) Do(*http.Request) (*http.Response, error) {\n\treturn &http.Response{StatusCode: 200, Body: io.NopCloser(bytes.NewBufferString(`OK`))}, nil\n}\n\nfunc TestSlack_GetFile(t *testing.T) {\n\tapi := &Client{\n\t\tendpoint:   \"http://\" + serverAddr + \"/\",\n\t\ttoken:      \"testing-token\",\n\t\thttpclient: &mockHTTPClient{},\n\t}\n\n\ttests := []struct {\n\t\ttitle       string\n\t\tdownloadURL string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\ttitle:       \"Testing with valid file\",\n\t\t\tdownloadURL: \"https://files.slack.com/files-pri/T99999999-FGGGGGGGG/download/test.csv\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttitle:       \"Testing with invalid file (empty URL)\",\n\t\t\tdownloadURL: \"\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\terr := api.GetFile(test.downloadURL, &bytes.Buffer{})\n\n\t\tif !test.expectError && err != nil {\n\t\t\tlog.Fatalf(\"%s: Unexpected error: %s in test\", test.title, err)\n\t\t} else if test.expectError == true && err == nil {\n\t\t\tlog.Fatalf(\"Expected error but got none\")\n\t\t}\n\t}\n}\n\nfunc TestSlack_DeleteFileComment(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\ttitle       string\n\t\tbody        url.Values\n\t\twantParams  map[string]string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\ttitle: \"Testing with proper body\",\n\t\t\tbody: url.Values{\n\t\t\t\t\"file\": {\"file12345\"},\n\t\t\t\t\"id\":   {\"id12345\"},\n\t\t\t},\n\t\t\twantParams: map[string]string{\n\t\t\t\t\"token\": \"testing-token\",\n\t\t\t\t\"file\":  \"file12345\",\n\t\t\t\t\"id\":    \"id12345\",\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttitle: \"Testing with false body\",\n\t\t\tbody: url.Values{\n\t\t\t\t\"file\": {\"\"},\n\t\t\t\t\"id\":   {\"\"},\n\t\t\t},\n\t\t\twantParams:  map[string]string{},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\ttitle: \"Testing with error\",\n\t\t\tbody: url.Values{\n\t\t\t\t\"file\": {\"file12345\"},\n\t\t\t\t\"id\":   {\"trigger-error\"},\n\t\t\t},\n\t\t\twantParams: map[string]string{\n\t\t\t\t\"token\": \"testing-token\",\n\t\t\t\t\"file\":  \"file12345\",\n\t\t\t\t\"id\":    \"trigger-error\",\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tvar fch *fileCommentHandler\n\thttp.HandleFunc(\"/files.comments.delete\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfch.handler(w, r)\n\t})\n\n\tfor _, test := range tests {\n\t\tfch = newFileCommentHandler()\n\t\terr := api.DeleteFileComment(test.body[\"id\"][0], test.body[\"file\"][0])\n\n\t\tif !test.expectError && err != nil {\n\t\t\tlog.Fatalf(\"%s: Unexpected error: %s in test\", test.title, err)\n\t\t} else if test.expectError == true && err == nil {\n\t\t\tlog.Fatalf(\"Expected error but got none\")\n\t\t}\n\n\t\tif !reflect.DeepEqual(fch.gotParams, test.wantParams) {\n\t\t\tlog.Fatalf(\"%s: Got params [%#v]\\nBut received [%#v]\\n\", test.title, fch.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc authTestHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(authTestResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc uploadFileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(fileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestUploadFile(t *testing.T) {\n\thttp.HandleFunc(\"/auth.test\", authTestHandler)\n\thttp.HandleFunc(\"/files.upload\", uploadFileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := FileUploadParameters{\n\t\tFilename: \"test.txt\", Content: \"test content\",\n\t\tChannels: []string{\"CXXXXXXXX\"}}\n\tif _, err := api.UploadFile(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n\n\treader := bytes.NewBufferString(\"test reader\")\n\tparams = FileUploadParameters{\n\t\tFilename: \"test.txt\",\n\t\tReader:   reader,\n\t\tChannels: []string{\"CXXXXXXXX\"}}\n\tif _, err := api.UploadFile(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n\n\tlargeByt := make([]byte, 107374200)\n\treader = bytes.NewBuffer(largeByt)\n\tparams = FileUploadParameters{\n\t\tFilename: \"test.txt\", Reader: reader,\n\t\tChannels: []string{\"CXXXXXXXX\"}}\n\tif _, err := api.UploadFile(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestUploadFileWithoutFilename(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\treader := bytes.NewBufferString(\"test reader\")\n\tparams := FileUploadParameters{\n\t\tReader:   reader,\n\t\tChannels: []string{\"CXXXXXXXX\"}}\n\t_, err := api.UploadFile(params)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when omitting filename, instead got nil\")\n\t}\n\n\tif !strings.Contains(err.Error(), \".Filename is mandatory\") {\n\t\tt.Errorf(\"Error message should mention empty FileUploadParameters.Filename\")\n\t}\n}\n\nfunc uploadURLHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(getUploadURLExternalResponse{\n\t\tFileID:        \"RandomID\",\n\t\tUploadURL:     \"http://\" + serverAddr + \"/abc\",\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc urlFileUploadHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"text\")\n\trw.Write([]byte(\"Ok: 200, file uploaded\"))\n}\n\nfunc completeURLUpload(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(completeUploadExternalResponse{\n\t\tFiles: []FileSummary{\n\t\t\t{\n\t\t\t\tID:    \"RandomID\",\n\t\t\t\tTitle: \"\",\n\t\t\t},\n\t\t},\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestUploadFileV2(t *testing.T) {\n\thttp.HandleFunc(\"/files.getUploadURLExternal\", uploadURLHandler)\n\thttp.HandleFunc(\"/abc\", urlFileUploadHandler)\n\thttp.HandleFunc(\"/files.completeUploadExternal\", completeURLUpload)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tparams := UploadFileV2Parameters{\n\t\tFilename: \"test.txt\", Content: \"test content\", FileSize: 10,\n\t\tChannel: \"CXXXXXXXX\",\n\t}\n\tif _, err := api.UploadFileV2(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n\n\treader := bytes.NewBufferString(\"test reader\")\n\tparams = UploadFileV2Parameters{\n\t\tFilename: \"test.txt\",\n\t\tReader:   reader,\n\t\tFileSize: 10,\n\t\tChannel:  \"CXXXXXXXX\"}\n\tif _, err := api.UploadFileV2(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n\n\tlargeByt := make([]byte, 107374200)\n\treader = bytes.NewBuffer(largeByt)\n\tparams = UploadFileV2Parameters{\n\t\tFilename: \"test.txt\", Reader: reader, FileSize: len(largeByt),\n\t\tChannel: \"CXXXXXXXX\"}\n\tif _, err := api.UploadFileV2(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n\n\treader = bytes.NewBufferString(\"test no channel\")\n\tparams = UploadFileV2Parameters{\n\t\tFilename: \"test.txt\",\n\t\tReader:   reader,\n\t\tFileSize: 15}\n\tif _, err := api.UploadFileV2(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "function_execute.go",
          "type": "blob",
          "size": 2.6884765625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n)\n\ntype (\n\tFunctionCompleteSuccessRequest struct {\n\t\tFunctionExecutionID string            `json:\"function_execution_id\"`\n\t\tOutputs             map[string]string `json:\"outputs\"`\n\t}\n\n\tFunctionCompleteErrorRequest struct {\n\t\tFunctionExecutionID string `json:\"function_execution_id\"`\n\t\tError               string `json:\"error\"`\n\t}\n)\n\ntype FunctionCompleteSuccessRequestOption func(opt *FunctionCompleteSuccessRequest) error\n\nfunc FunctionCompleteSuccessRequestOptionOutput(outputs map[string]string) FunctionCompleteSuccessRequestOption {\n\treturn func(opt *FunctionCompleteSuccessRequest) error {\n\t\tif len(outputs) > 0 {\n\t\t\topt.Outputs = outputs\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// FunctionCompleteSuccess indicates function is completed\nfunc (api *Client) FunctionCompleteSuccess(functionExecutionId string, options ...FunctionCompleteSuccessRequestOption) error {\n\treturn api.FunctionCompleteSuccessContext(context.Background(), functionExecutionId, options...)\n}\n\n// FunctionCompleteSuccess indicates function is completed\nfunc (api *Client) FunctionCompleteSuccessContext(ctx context.Context, functionExecutionId string, options ...FunctionCompleteSuccessRequestOption) error {\n\t// More information: https://api.slack.com/methods/functions.completeSuccess\n\tr := &FunctionCompleteSuccessRequest{\n\t\tFunctionExecutionID: functionExecutionId,\n\t}\n\tfor _, option := range options {\n\t\toption(r)\n\t}\n\n\tendpoint := api.endpoint + \"functions.completeSuccess\"\n\tjsonData, err := json.Marshal(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := postJSON(ctx, api.httpclient, endpoint, api.token, jsonData, response, api); err != nil {\n\t\treturn err\n\t}\n\n\tif !response.Ok {\n\t\treturn response.Err()\n\t}\n\n\treturn nil\n}\n\n// FunctionCompleteError indicates function is completed with error\nfunc (api *Client) FunctionCompleteError(functionExecutionID string, errorMessage string) error {\n\treturn api.FunctionCompleteErrorContext(context.Background(), functionExecutionID, errorMessage)\n}\n\n// FunctionCompleteErrorContext indicates function is completed with error\nfunc (api *Client) FunctionCompleteErrorContext(ctx context.Context, functionExecutionID string, errorMessage string) error {\n\t// More information: https://api.slack.com/methods/functions.completeError\n\tr := FunctionCompleteErrorRequest{\n\t\tFunctionExecutionID: functionExecutionID,\n\t}\n\tr.Error = errorMessage\n\n\tendpoint := api.endpoint + \"functions.completeError\"\n\tjsonData, err := json.Marshal(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := postJSON(ctx, api.httpclient, endpoint, api.token, jsonData, response, api); err != nil {\n\t\treturn err\n\t}\n\n\tif !response.Ok {\n\t\treturn response.Err()\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "function_execute_test.go",
          "type": "blob",
          "size": 1.5927734375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc postHandler(t *testing.T) func(rw http.ResponseWriter, r *http.Request) {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tdefer r.Body.Close()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\n\t\tvar req FunctionCompleteSuccessRequest\n\t\terr = json.Unmarshal(body, &req)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn\n\t\t}\n\n\t\tswitch req.FunctionExecutionID {\n\t\tcase \"function-success\":\n\t\t\tpostSuccess(rw, r)\n\t\tcase \"function-failure\":\n\t\t\tpostFailure(rw, r)\n\t\t}\n\t}\n}\n\nfunc postSuccess(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\n    \"ok\": true\n\t}`)\n\trw.Write(response)\n}\n\nfunc postFailure(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\n\t\t\t\"ok\": false,\n\t\t\t\"error\": \"function_execution_not_found\"\n\t}`)\n\trw.Write(response)\n\trw.WriteHeader(500)\n}\n\nfunc TestFunctionComplete(t *testing.T) {\n\thttp.HandleFunc(\"/functions.completeSuccess\", postHandler(t))\n\n\tonce.Do(startServer)\n\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\terr := api.FunctionCompleteSuccess(\"function-success\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\terr = api.FunctionCompleteSuccess(\"function-failure\")\n\tif err == nil {\n\t\tt.Fail()\n\t}\n\n\terr = api.FunctionCompleteSuccessContext(context.Background(), \"function-success\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\terr = api.FunctionCompleteSuccessContext(context.Background(), \"function-failure\")\n\tif err == nil {\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.283203125,
          "content": "module github.com/slack-go/slack\n\ngo 1.16\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/go-test/deep v1.0.4\n\tgithub.com/google/go-cmp v0.5.7\n\tgithub.com/gorilla/websocket v1.4.2\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/stretchr/testify v1.2.2\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.2138671875,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-test/deep v1.0.4 h1:u2CU3YKy9I2pmu9pX0eq50wCgjfGIt539SqR7FbHiho=\ngithub.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\ngithub.com/google/go-cmp v0.5.7 h1:81/ik6ipDQS2aGcBfIN5dHDB36BwrStyeAQquSYCV4o=\ngithub.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=\ngithub.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "groups.go",
          "type": "blob",
          "size": 0.134765625,
          "content": "package slack\n\n// Group contains all the information for a group\ntype Group struct {\n\tGroupConversation\n\tIsGroup bool `json:\"is_group\"`\n}\n"
        },
        {
          "name": "history.go",
          "type": "blob",
          "size": 1.0625,
          "content": "package slack\n\nconst (\n\tDEFAULT_HISTORY_LATEST    = \"\"\n\tDEFAULT_HISTORY_OLDEST    = \"0\"\n\tDEFAULT_HISTORY_COUNT     = 100\n\tDEFAULT_HISTORY_INCLUSIVE = false\n\tDEFAULT_HISTORY_UNREADS   = false\n)\n\n// HistoryParameters contains all the necessary information to help in the retrieval of history for Channels/Groups/DMs\ntype HistoryParameters struct {\n\tLatest    string\n\tOldest    string\n\tCount     int\n\tInclusive bool\n\tUnreads   bool\n}\n\n// History contains message history information needed to navigate a Channel / Group / DM history\ntype History struct {\n\tLatest   string    `json:\"latest\"`\n\tMessages []Message `json:\"messages\"`\n\tHasMore  bool      `json:\"has_more\"`\n\tUnread   int       `json:\"unread_count_display\"`\n}\n\n// NewHistoryParameters provides an instance of HistoryParameters with all the sane default values set\nfunc NewHistoryParameters() HistoryParameters {\n\treturn HistoryParameters{\n\t\tLatest:    DEFAULT_HISTORY_LATEST,\n\t\tOldest:    DEFAULT_HISTORY_OLDEST,\n\t\tCount:     DEFAULT_HISTORY_COUNT,\n\t\tInclusive: DEFAULT_HISTORY_INCLUSIVE,\n\t\tUnreads:   DEFAULT_HISTORY_UNREADS,\n\t}\n}\n"
        },
        {
          "name": "im.go",
          "type": "blob",
          "size": 0.46875,
          "content": "package slack\n\ntype imChannel struct {\n\tID string `json:\"id\"`\n}\n\ntype imResponseFull struct {\n\tNoOp          bool      `json:\"no_op\"`\n\tAlreadyClosed bool      `json:\"already_closed\"`\n\tAlreadyOpen   bool      `json:\"already_open\"`\n\tChannel       imChannel `json:\"channel\"`\n\tIMs           []IM      `json:\"ims\"`\n\tHistory\n\tSlackResponse\n}\n\n// IM contains information related to the Direct Message channel\ntype IM struct {\n\tConversation\n\tIsUserDeleted bool `json:\"is_user_deleted\"`\n}\n"
        },
        {
          "name": "info.go",
          "type": "blob",
          "size": 29.7744140625,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype UserPrefsCarrier struct {\n\tSlackResponse\n\tUserPrefs *UserPrefs `json:\"prefs\"`\n}\n\n// UserPrefs carries a bunch of user settings including some unknown types\ntype UserPrefs struct {\n\tUserColors       string `json:\"user_colors,omitempty\"`\n\tColorNamesInList bool   `json:\"color_names_in_list,omitempty\"`\n\t// Keyboard UnknownType `json:\"keyboard\"`\n\tEmailAlerts                         string `json:\"email_alerts,omitempty\"`\n\tEmailAlertsSleepUntil               int    `json:\"email_alerts_sleep_until,omitempty\"`\n\tEmailTips                           bool   `json:\"email_tips,omitempty\"`\n\tEmailWeekly                         bool   `json:\"email_weekly,omitempty\"`\n\tEmailOffers                         bool   `json:\"email_offers,omitempty\"`\n\tEmailResearch                       bool   `json:\"email_research,omitempty\"`\n\tEmailDeveloper                      bool   `json:\"email_developer,omitempty\"`\n\tWelcomeMessageHidden                bool   `json:\"welcome_message_hidden,omitempty\"`\n\tSearchSort                          string `json:\"search_sort,omitempty\"`\n\tSearchFileSort                      string `json:\"search_file_sort,omitempty\"`\n\tSearchChannelSort                   string `json:\"search_channel_sort,omitempty\"`\n\tSearchPeopleSort                    string `json:\"search_people_sort,omitempty\"`\n\tExpandInlineImages                  bool   `json:\"expand_inline_images,omitempty\"`\n\tExpandInternalInlineImages          bool   `json:\"expand_internal_inline_images,omitempty\"`\n\tExpandSnippets                      bool   `json:\"expand_snippets,omitempty\"`\n\tPostsFormattingGuide                bool   `json:\"posts_formatting_guide,omitempty\"`\n\tSeenWelcome2                        bool   `json:\"seen_welcome_2,omitempty\"`\n\tSeenSSBPrompt                       bool   `json:\"seen_ssb_prompt,omitempty\"`\n\tSpacesNewXpBannerDismissed          bool   `json:\"spaces_new_xp_banner_dismissed,omitempty\"`\n\tSearchOnlyMyChannels                bool   `json:\"search_only_my_channels,omitempty\"`\n\tSearchOnlyCurrentTeam               bool   `json:\"search_only_current_team,omitempty\"`\n\tSearchHideMyChannels                bool   `json:\"search_hide_my_channels,omitempty\"`\n\tSearchOnlyShowOnline                bool   `json:\"search_only_show_online,omitempty\"`\n\tSearchHideDeactivatedUsers          bool   `json:\"search_hide_deactivated_users,omitempty\"`\n\tEmojiMode                           string `json:\"emoji_mode,omitempty\"`\n\tEmojiUse                            string `json:\"emoji_use,omitempty\"`\n\tHasInvited                          bool   `json:\"has_invited,omitempty\"`\n\tHasUploaded                         bool   `json:\"has_uploaded,omitempty\"`\n\tHasCreatedChannel                   bool   `json:\"has_created_channel,omitempty\"`\n\tHasSearched                         bool   `json:\"has_searched,omitempty\"`\n\tSearchExcludeChannels               string `json:\"search_exclude_channels,omitempty\"`\n\tMessagesTheme                       string `json:\"messages_theme,omitempty\"`\n\tWebappSpellcheck                    bool   `json:\"webapp_spellcheck,omitempty\"`\n\tNoJoinedOverlays                    bool   `json:\"no_joined_overlays,omitempty\"`\n\tNoCreatedOverlays                   bool   `json:\"no_created_overlays,omitempty\"`\n\tDropboxEnabled                      bool   `json:\"dropbox_enabled,omitempty\"`\n\tSeenDomainInviteReminder            bool   `json:\"seen_domain_invite_reminder,omitempty\"`\n\tSeenMemberInviteReminder            bool   `json:\"seen_member_invite_reminder,omitempty\"`\n\tMuteSounds                          bool   `json:\"mute_sounds,omitempty\"`\n\tArrowHistory                        bool   `json:\"arrow_history,omitempty\"`\n\tTabUIReturnSelects                  bool   `json:\"tab_ui_return_selects,omitempty\"`\n\tObeyInlineImgLimit                  bool   `json:\"obey_inline_img_limit,omitempty\"`\n\tRequireAt                           bool   `json:\"require_at,omitempty\"`\n\tSsbSpaceWindow                      string `json:\"ssb_space_window,omitempty\"`\n\tMacSsbBounce                        string `json:\"mac_ssb_bounce,omitempty\"`\n\tMacSsbBullet                        bool   `json:\"mac_ssb_bullet,omitempty\"`\n\tExpandNonMediaAttachments           bool   `json:\"expand_non_media_attachments,omitempty\"`\n\tShowTyping                          bool   `json:\"show_typing,omitempty\"`\n\tPagekeysHandled                     bool   `json:\"pagekeys_handled,omitempty\"`\n\tLastSnippetType                     string `json:\"last_snippet_type,omitempty\"`\n\tDisplayRealNamesOverride            int    `json:\"display_real_names_override,omitempty\"`\n\tDisplayDisplayNames                 bool   `json:\"display_display_names,omitempty\"`\n\tTime24                              bool   `json:\"time24,omitempty\"`\n\tEnterIsSpecialInTbt                 bool   `json:\"enter_is_special_in_tbt,omitempty\"`\n\tMsgInputSendBtn                     bool   `json:\"msg_input_send_btn,omitempty\"`\n\tMsgInputSendBtnAutoSet              bool   `json:\"msg_input_send_btn_auto_set,omitempty\"`\n\tMsgInputStickyComposer              bool   `json:\"msg_input_sticky_composer,omitempty\"`\n\tGraphicEmoticons                    bool   `json:\"graphic_emoticons,omitempty\"`\n\tConvertEmoticons                    bool   `json:\"convert_emoticons,omitempty\"`\n\tSsEmojis                            bool   `json:\"ss_emojis,omitempty\"`\n\tSeenOnboardingStart                 bool   `json:\"seen_onboarding_start,omitempty\"`\n\tOnboardingCancelled                 bool   `json:\"onboarding_cancelled,omitempty\"`\n\tSeenOnboardingSlackbotConversation  bool   `json:\"seen_onboarding_slackbot_conversation,omitempty\"`\n\tSeenOnboardingChannels              bool   `json:\"seen_onboarding_channels,omitempty\"`\n\tSeenOnboardingDirectMessages        bool   `json:\"seen_onboarding_direct_messages,omitempty\"`\n\tSeenOnboardingInvites               bool   `json:\"seen_onboarding_invites,omitempty\"`\n\tSeenOnboardingSearch                bool   `json:\"seen_onboarding_search,omitempty\"`\n\tSeenOnboardingRecentMentions        bool   `json:\"seen_onboarding_recent_mentions,omitempty\"`\n\tSeenOnboardingStarredItems          bool   `json:\"seen_onboarding_starred_items,omitempty\"`\n\tSeenOnboardingPrivateGroups         bool   `json:\"seen_onboarding_private_groups,omitempty\"`\n\tSeenOnboardingBanner                bool   `json:\"seen_onboarding_banner,omitempty\"`\n\tOnboardingSlackbotConversationStep  int    `json:\"onboarding_slackbot_conversation_step,omitempty\"`\n\tSetTzAutomatically                  bool   `json:\"set_tz_automatically,omitempty\"`\n\tSuppressLinkWarning                 bool   `json:\"suppress_link_warning,omitempty\"`\n\tDndEnabled                          bool   `json:\"dnd_enabled,omitempty\"`\n\tDndStartHour                        string `json:\"dnd_start_hour,omitempty\"`\n\tDndEndHour                          string `json:\"dnd_end_hour,omitempty\"`\n\tDndBeforeMonday                     string `json:\"dnd_before_monday,omitempty\"`\n\tDndAfterMonday                      string `json:\"dnd_after_monday,omitempty\"`\n\tDndEnabledMonday                    string `json:\"dnd_enabled_monday,omitempty\"`\n\tDndBeforeTuesday                    string `json:\"dnd_before_tuesday,omitempty\"`\n\tDndAfterTuesday                     string `json:\"dnd_after_tuesday,omitempty\"`\n\tDndEnabledTuesday                   string `json:\"dnd_enabled_tuesday,omitempty\"`\n\tDndBeforeWednesday                  string `json:\"dnd_before_wednesday,omitempty\"`\n\tDndAfterWednesday                   string `json:\"dnd_after_wednesday,omitempty\"`\n\tDndEnabledWednesday                 string `json:\"dnd_enabled_wednesday,omitempty\"`\n\tDndBeforeThursday                   string `json:\"dnd_before_thursday,omitempty\"`\n\tDndAfterThursday                    string `json:\"dnd_after_thursday,omitempty\"`\n\tDndEnabledThursday                  string `json:\"dnd_enabled_thursday,omitempty\"`\n\tDndBeforeFriday                     string `json:\"dnd_before_friday,omitempty\"`\n\tDndAfterFriday                      string `json:\"dnd_after_friday,omitempty\"`\n\tDndEnabledFriday                    string `json:\"dnd_enabled_friday,omitempty\"`\n\tDndBeforeSaturday                   string `json:\"dnd_before_saturday,omitempty\"`\n\tDndAfterSaturday                    string `json:\"dnd_after_saturday,omitempty\"`\n\tDndEnabledSaturday                  string `json:\"dnd_enabled_saturday,omitempty\"`\n\tDndBeforeSunday                     string `json:\"dnd_before_sunday,omitempty\"`\n\tDndAfterSunday                      string `json:\"dnd_after_sunday,omitempty\"`\n\tDndEnabledSunday                    string `json:\"dnd_enabled_sunday,omitempty\"`\n\tDndDays                             string `json:\"dnd_days,omitempty\"`\n\tDndCustomNewBadgeSeen               bool   `json:\"dnd_custom_new_badge_seen,omitempty\"`\n\tDndNotificationScheduleNewBadgeSeen bool   `json:\"dnd_notification_schedule_new_badge_seen,omitempty\"`\n\t// UnreadCollapsedChannels      unknownType                  `json:\"unread_collapsed_channels,omitempty\"`\n\tSidebarBehavior          string `json:\"sidebar_behavior,omitempty\"`\n\tChannelSort              string `json:\"channel_sort,omitempty\"`\n\tSeparatePrivateChannels  bool   `json:\"separate_private_channels,omitempty\"`\n\tSeparateSharedChannels   bool   `json:\"separate_shared_channels,omitempty\"`\n\tSidebarTheme             string `json:\"sidebar_theme,omitempty\"`\n\tSidebarThemeCustomValues string `json:\"sidebar_theme_custom_values,omitempty\"`\n\tNoInvitesWidgetInSidebar bool   `json:\"no_invites_widget_in_sidebar,omitempty\"`\n\tNoOmniboxInChannels      bool   `json:\"no_omnibox_in_channels,omitempty\"`\n\n\tKKeyOmniboxAutoHideCount       int    `json:\"k_key_omnibox_auto_hide_count,omitempty\"`\n\tShowSidebarQuickswitcherButton bool   `json:\"show_sidebar_quickswitcher_button,omitempty\"`\n\tEntOrgWideChannelsSidebar      bool   `json:\"ent_org_wide_channels_sidebar,omitempty\"`\n\tMarkMsgsReadImmediately        bool   `json:\"mark_msgs_read_immediately,omitempty\"`\n\tStartScrollAtOldest            bool   `json:\"start_scroll_at_oldest,omitempty\"`\n\tSnippetEditorWrapLongLines     bool   `json:\"snippet_editor_wrap_long_lines,omitempty\"`\n\tLsDisabled                     bool   `json:\"ls_disabled,omitempty\"`\n\tFKeySearch                     bool   `json:\"f_key_search,omitempty\"`\n\tKKeyOmnibox                    bool   `json:\"k_key_omnibox,omitempty\"`\n\tPromptedForEmailDisabling      bool   `json:\"prompted_for_email_disabling,omitempty\"`\n\tNoMacelectronBanner            bool   `json:\"no_macelectron_banner,omitempty\"`\n\tNoMacssb1Banner                bool   `json:\"no_macssb1_banner,omitempty\"`\n\tNoMacssb2Banner                bool   `json:\"no_macssb2_banner,omitempty\"`\n\tNoWinssb1Banner                bool   `json:\"no_winssb1_banner,omitempty\"`\n\tHideUserGroupInfoPane          bool   `json:\"hide_user_group_info_pane,omitempty\"`\n\tMentionsExcludeAtUserGroups    bool   `json:\"mentions_exclude_at_user_groups,omitempty\"`\n\tMentionsExcludeReactions       bool   `json:\"mentions_exclude_reactions,omitempty\"`\n\tPrivacyPolicySeen              bool   `json:\"privacy_policy_seen,omitempty\"`\n\tEnterpriseMigrationSeen        bool   `json:\"enterprise_migration_seen,omitempty\"`\n\tLastTosAcknowledged            string `json:\"last_tos_acknowledged,omitempty\"`\n\tSearchExcludeBots              bool   `json:\"search_exclude_bots,omitempty\"`\n\tLoadLato2                      bool   `json:\"load_lato_2,omitempty\"`\n\tFullerTimestamps               bool   `json:\"fuller_timestamps,omitempty\"`\n\tLastSeenAtChannelWarning       int    `json:\"last_seen_at_channel_warning,omitempty\"`\n\tEmojiAutocompleteBig           bool   `json:\"emoji_autocomplete_big,omitempty\"`\n\tTwoFactorAuthEnabled           bool   `json:\"two_factor_auth_enabled,omitempty\"`\n\t// TwoFactorType                         unknownType    `json:\"two_factor_type,omitempty\"`\n\t// TwoFactorBackupType                   unknownType    `json:\"two_factor_backup_type,omitempty\"`\n\tHideHexSwatch          bool   `json:\"hide_hex_swatch,omitempty\"`\n\tShowJumperScores       bool   `json:\"show_jumper_scores,omitempty\"`\n\tEnterpriseMdmCustomMsg string `json:\"enterprise_mdm_custom_msg,omitempty\"`\n\t// EnterpriseExcludedAppTeams                 unknownType    `json:\"enterprise_excluded_app_teams,omitempty\"`\n\tClientLogsPri             string `json:\"client_logs_pri,omitempty\"`\n\tFlannelServerPool         string `json:\"flannel_server_pool,omitempty\"`\n\tMentionsExcludeAtChannels bool   `json:\"mentions_exclude_at_channels,omitempty\"`\n\tConfirmClearAllUnreads    bool   `json:\"confirm_clear_all_unreads,omitempty\"`\n\tConfirmUserMarkedAway     bool   `json:\"confirm_user_marked_away,omitempty\"`\n\tBoxEnabled                bool   `json:\"box_enabled,omitempty\"`\n\tSeenSingleEmojiMsg        bool   `json:\"seen_single_emoji_msg,omitempty\"`\n\tConfirmShCallStart        bool   `json:\"confirm_sh_call_start,omitempty\"`\n\tPreferredSkinTone         string `json:\"preferred_skin_tone,omitempty\"`\n\tShowAllSkinTones          bool   `json:\"show_all_skin_tones,omitempty\"`\n\tWhatsNewRead              int    `json:\"whats_new_read,omitempty\"`\n\t// FrecencyJumper                           unknownType      `json:\"frecency_jumper,omitempty\"`\n\tFrecencyEntJumper                       string `json:\"frecency_ent_jumper,omitempty\"`\n\tFrecencyEntJumperBackup                 string `json:\"frecency_ent_jumper_backup,omitempty\"`\n\tJumbomoji                               bool   `json:\"jumbomoji,omitempty\"`\n\tNewxpSeenLastMessage                    int    `json:\"newxp_seen_last_message,omitempty\"`\n\tShowMemoryInstrument                    bool   `json:\"show_memory_instrument,omitempty\"`\n\tEnableUnreadView                        bool   `json:\"enable_unread_view,omitempty\"`\n\tSeenUnreadViewCoachmark                 bool   `json:\"seen_unread_view_coachmark,omitempty\"`\n\tEnableReactEmojiPicker                  bool   `json:\"enable_react_emoji_picker,omitempty\"`\n\tSeenCustomStatusBadge                   bool   `json:\"seen_custom_status_badge,omitempty\"`\n\tSeenCustomStatusCallout                 bool   `json:\"seen_custom_status_callout,omitempty\"`\n\tSeenCustomStatusExpirationBadge         bool   `json:\"seen_custom_status_expiration_badge,omitempty\"`\n\tUsedCustomStatusKbShortcut              bool   `json:\"used_custom_status_kb_shortcut,omitempty\"`\n\tSeenGuestAdminSlackbotAnnouncement      bool   `json:\"seen_guest_admin_slackbot_announcement,omitempty\"`\n\tSeenThreadsNotificationBanner           bool   `json:\"seen_threads_notification_banner,omitempty\"`\n\tSeenNameTaggingCoachmark                bool   `json:\"seen_name_tagging_coachmark,omitempty\"`\n\tAllUnreadsSortOrder                     string `json:\"all_unreads_sort_order,omitempty\"`\n\tLocale                                  string `json:\"locale,omitempty\"`\n\tSeenIntlChannelNamesCoachmark           bool   `json:\"seen_intl_channel_names_coachmark,omitempty\"`\n\tSeenP2LocaleChangeMessage               int    `json:\"seen_p2_locale_change_message,omitempty\"`\n\tSeenLocaleChangeMessage                 int    `json:\"seen_locale_change_message,omitempty\"`\n\tSeenJapaneseLocaleChangeMessage         bool   `json:\"seen_japanese_locale_change_message,omitempty\"`\n\tSeenSharedChannelsCoachmark             bool   `json:\"seen_shared_channels_coachmark,omitempty\"`\n\tSeenSharedChannelsOptInChangeMessage    bool   `json:\"seen_shared_channels_opt_in_change_message,omitempty\"`\n\tHasRecentlySharedaChannel               bool   `json:\"has_recently_shared_a_channel,omitempty\"`\n\tSeenChannelBrowserAdminCoachmark        bool   `json:\"seen_channel_browser_admin_coachmark,omitempty\"`\n\tSeenAdministrationMenu                  bool   `json:\"seen_administration_menu,omitempty\"`\n\tSeenDraftsSectionCoachmark              bool   `json:\"seen_drafts_section_coachmark,omitempty\"`\n\tSeenEmojiUpdateOverlayCoachmark         bool   `json:\"seen_emoji_update_overlay_coachmark,omitempty\"`\n\tSeenSonicDeluxeToast                    int    `json:\"seen_sonic_deluxe_toast,omitempty\"`\n\tSeenWysiwygDeluxeToast                  bool   `json:\"seen_wysiwyg_deluxe_toast,omitempty\"`\n\tSeenMarkdownPasteToast                  int    `json:\"seen_markdown_paste_toast,omitempty\"`\n\tSeenMarkdownPasteShortcut               int    `json:\"seen_markdown_paste_shortcut,omitempty\"`\n\tSeenIaEducation                         bool   `json:\"seen_ia_education,omitempty\"`\n\tPlainTextMode                           bool   `json:\"plain_text_mode,omitempty\"`\n\tShowSharedChannelsEducationBanner       bool   `json:\"show_shared_channels_education_banner,omitempty\"`\n\tAllowCallsToSetCurrentStatus            bool   `json:\"allow_calls_to_set_current_status,omitempty\"`\n\tInInteractiveMasMigrationFlow           bool   `json:\"in_interactive_mas_migration_flow,omitempty\"`\n\tSunsetInteractiveMessageViews           int    `json:\"sunset_interactive_message_views,omitempty\"`\n\tShdepPromoCodeSubmitted                 bool   `json:\"shdep_promo_code_submitted,omitempty\"`\n\tSeenShdepSlackbotMessage                bool   `json:\"seen_shdep_slackbot_message,omitempty\"`\n\tSeenCallsInteractiveCoachmark           bool   `json:\"seen_calls_interactive_coachmark,omitempty\"`\n\tAllowCmdTabIss                          bool   `json:\"allow_cmd_tab_iss,omitempty\"`\n\tSeenWorkflowBuilderDeluxeToast          bool   `json:\"seen_workflow_builder_deluxe_toast,omitempty\"`\n\tWorkflowBuilderIntroModalClickedThrough bool   `json:\"workflow_builder_intro_modal_clicked_through,omitempty\"`\n\t// WorkflowBuilderCoachmarks                    unknownType  `json:\"workflow_builder_coachmarks,omitempty\"`\n\tSeenGdriveCoachmark                            bool   `json:\"seen_gdrive_coachmark,omitempty\"`\n\tOverloadedMessageEnabled                       bool   `json:\"overloaded_message_enabled,omitempty\"`\n\tSeenHighlightsCoachmark                        bool   `json:\"seen_highlights_coachmark,omitempty\"`\n\tSeenHighlightsArrowsCoachmark                  bool   `json:\"seen_highlights_arrows_coachmark,omitempty\"`\n\tSeenHighlightsWarmWelcome                      bool   `json:\"seen_highlights_warm_welcome,omitempty\"`\n\tSeenNewSearchUi                                bool   `json:\"seen_new_search_ui,omitempty\"`\n\tSeenChannelSearch                              bool   `json:\"seen_channel_search,omitempty\"`\n\tSeenPeopleSearch                               bool   `json:\"seen_people_search,omitempty\"`\n\tSeenPeopleSearchCount                          int    `json:\"seen_people_search_count,omitempty\"`\n\tDismissedScrollSearchTooltipCount              int    `json:\"dismissed_scroll_search_tooltip_count,omitempty\"`\n\tLastDismissedScrollSearchTooltipTimestamp      int    `json:\"last_dismissed_scroll_search_tooltip_timestamp,omitempty\"`\n\tHasUsedQuickswitcherShortcut                   bool   `json:\"has_used_quickswitcher_shortcut,omitempty\"`\n\tSeenQuickswitcherShortcutTipCount              int    `json:\"seen_quickswitcher_shortcut_tip_count,omitempty\"`\n\tBrowsersDismissedChannelsLowResultsEducation   bool   `json:\"browsers_dismissed_channels_low_results_education,omitempty\"`\n\tBrowsersSeenInitialChannelsEducation           bool   `json:\"browsers_seen_initial_channels_education,omitempty\"`\n\tBrowsersDismissedPeopleLowResultsEducation     bool   `json:\"browsers_dismissed_people_low_results_education,omitempty\"`\n\tBrowsersSeenInitialPeopleEducation             bool   `json:\"browsers_seen_initial_people_education,omitempty\"`\n\tBrowsersDismissedUserGroupsLowResultsEducation bool   `json:\"browsers_dismissed_user_groups_low_results_education,omitempty\"`\n\tBrowsersSeenInitialUserGroupsEducation         bool   `json:\"browsers_seen_initial_user_groups_education,omitempty\"`\n\tBrowsersDismissedFilesLowResultsEducation      bool   `json:\"browsers_dismissed_files_low_results_education,omitempty\"`\n\tBrowsersSeenInitialFilesEducation              bool   `json:\"browsers_seen_initial_files_education,omitempty\"`\n\tA11yAnimations                                 bool   `json:\"a11y_animations,omitempty\"`\n\tSeenKeyboardShortcutsCoachmark                 bool   `json:\"seen_keyboard_shortcuts_coachmark,omitempty\"`\n\tNeedsInitialPasswordSet                        bool   `json:\"needs_initial_password_set,omitempty\"`\n\tLessonsEnabled                                 bool   `json:\"lessons_enabled,omitempty\"`\n\tTractorEnabled                                 bool   `json:\"tractor_enabled,omitempty\"`\n\tTractorExperimentGroup                         string `json:\"tractor_experiment_group,omitempty\"`\n\tOpenedSlackbotDm                               bool   `json:\"opened_slackbot_dm,omitempty\"`\n\tNewxpSuggestedChannels                         string `json:\"newxp_suggested_channels,omitempty\"`\n\tOnboardingComplete                             bool   `json:\"onboarding_complete,omitempty\"`\n\tWelcomePlaceState                              string `json:\"welcome_place_state,omitempty\"`\n\t// OnboardingRoleApps  unknownType `json:\"onboarding_role_apps,omitempty\"`\n\tHasReceivedThreadedMessage        bool   `json:\"has_received_threaded_message,omitempty\"`\n\tSendYourFirstMessageBannerEnabled bool   `json:\"send_your_first_message_banner_enabled,omitempty\"`\n\tWhocanseethisDmMpdmBadge          bool   `json:\"whocanseethis_dm_mpdm_badge,omitempty\"`\n\tHighlightWords                    string `json:\"highlight_words,omitempty\"`\n\tThreadsEverything                 bool   `json:\"threads_everything,omitempty\"`\n\tNoTextInNotifications             bool   `json:\"no_text_in_notifications,omitempty\"`\n\tPushShowPreview                   bool   `json:\"push_show_preview,omitempty\"`\n\tGrowlsEnabled                     bool   `json:\"growls_enabled,omitempty\"`\n\tAllChannelsLoud                   bool   `json:\"all_channels_loud,omitempty\"`\n\tPushDmAlert                       bool   `json:\"push_dm_alert,omitempty\"`\n\tPushMentionAlert                  bool   `json:\"push_mention_alert,omitempty\"`\n\tPushEverything                    bool   `json:\"push_everything,omitempty\"`\n\tPushIdleWait                      int    `json:\"push_idle_wait,omitempty\"`\n\tPushSound                         string `json:\"push_sound,omitempty\"`\n\tNewMsgSnd                         string `json:\"new_msg_snd,omitempty\"`\n\tPushLoudChannels                  string `json:\"push_loud_channels,omitempty\"`\n\tPushMentionChannels               string `json:\"push_mention_channels,omitempty\"`\n\tPushLoudChannelsSet               string `json:\"push_loud_channels_set,omitempty\"`\n\tLoudChannels                      string `json:\"loud_channels,omitempty\"`\n\tNeverChannels                     string `json:\"never_channels,omitempty\"`\n\tLoudChannelsSet                   string `json:\"loud_channels_set,omitempty\"`\n\tAtChannelSuppressedChannels       string `json:\"at_channel_suppressed_channels,omitempty\"`\n\tPushAtChannelSuppressedChannels   string `json:\"push_at_channel_suppressed_channels,omitempty\"`\n\tMutedChannels                     string `json:\"muted_channels,omitempty\"`\n\t// AllNotificationsPrefs                  unknownType `json:\"all_notifications_prefs,omitempty\"`\n\tGrowthMsgLimitApproachingCtaCount     int `json:\"growth_msg_limit_approaching_cta_count,omitempty\"`\n\tGrowthMsgLimitApproachingCtaTs        int `json:\"growth_msg_limit_approaching_cta_ts,omitempty\"`\n\tGrowthMsgLimitReachedCtaCount         int `json:\"growth_msg_limit_reached_cta_count,omitempty\"`\n\tGrowthMsgLimitReachedCtaLastTs        int `json:\"growth_msg_limit_reached_cta_last_ts,omitempty\"`\n\tGrowthMsgLimitLongReachedCtaCount     int `json:\"growth_msg_limit_long_reached_cta_count,omitempty\"`\n\tGrowthMsgLimitLongReachedCtaLastTs    int `json:\"growth_msg_limit_long_reached_cta_last_ts,omitempty\"`\n\tGrowthMsgLimitSixtyDayBannerCtaCount  int `json:\"growth_msg_limit_sixty_day_banner_cta_count,omitempty\"`\n\tGrowthMsgLimitSixtyDayBannerCtaLastTs int `json:\"growth_msg_limit_sixty_day_banner_cta_last_ts,omitempty\"`\n\t// GrowthAllBannersPrefs unknownType `json:\"growth_all_banners_prefs,omitempty\"`\n\tAnalyticsUpsellCoachmarkSeen bool `json:\"analytics_upsell_coachmark_seen,omitempty\"`\n\tSeenAppSpaceCoachmark        bool `json:\"seen_app_space_coachmark,omitempty\"`\n\tSeenAppSpaceTutorial         bool `json:\"seen_app_space_tutorial,omitempty\"`\n\tDismissedAppLauncherWelcome  bool `json:\"dismissed_app_launcher_welcome,omitempty\"`\n\tDismissedAppLauncherLimit    bool `json:\"dismissed_app_launcher_limit,omitempty\"`\n\tPurchaser                    bool `json:\"purchaser,omitempty\"`\n\tShowEntOnboarding            bool `json:\"show_ent_onboarding,omitempty\"`\n\tFoldersEnabled               bool `json:\"folders_enabled,omitempty\"`\n\t// FolderData unknownType `json:\"folder_data,omitempty\"`\n\tSeenCorporateExportAlert               bool   `json:\"seen_corporate_export_alert,omitempty\"`\n\tShowAutocompleteHelp                   int    `json:\"show_autocomplete_help,omitempty\"`\n\tDeprecationToastLastSeen               int    `json:\"deprecation_toast_last_seen,omitempty\"`\n\tDeprecationModalLastSeen               int    `json:\"deprecation_modal_last_seen,omitempty\"`\n\tIap1Lab                                int    `json:\"iap1_lab,omitempty\"`\n\tIaTopNavTheme                          string `json:\"ia_top_nav_theme,omitempty\"`\n\tIaPlatformActionsLab                   int    `json:\"ia_platform_actions_lab,omitempty\"`\n\tActivityView                           string `json:\"activity_view,omitempty\"`\n\tFailoverProxyCheckCompleted            int    `json:\"failover_proxy_check_completed,omitempty\"`\n\tEdgeUploadProxyCheckCompleted          int    `json:\"edge_upload_proxy_check_completed,omitempty\"`\n\tAppSubdomainCheckCompleted             int    `json:\"app_subdomain_check_completed,omitempty\"`\n\tAddAppsPromptDismissed                 bool   `json:\"add_apps_prompt_dismissed,omitempty\"`\n\tAddChannelPromptDismissed              bool   `json:\"add_channel_prompt_dismissed,omitempty\"`\n\tChannelSidebarHideInvite               bool   `json:\"channel_sidebar_hide_invite,omitempty\"`\n\tInProdSurveysEnabled                   bool   `json:\"in_prod_surveys_enabled,omitempty\"`\n\tDismissedInstalledAppDmSuggestions     string `json:\"dismissed_installed_app_dm_suggestions,omitempty\"`\n\tSeenContextualMessageShortcutsModal    bool   `json:\"seen_contextual_message_shortcuts_modal,omitempty\"`\n\tSeenMessageNavigationEducationalToast  bool   `json:\"seen_message_navigation_educational_toast,omitempty\"`\n\tContextualMessageShortcutsModalWasSeen bool   `json:\"contextual_message_shortcuts_modal_was_seen,omitempty\"`\n\tMessageNavigationToastWasSeen          bool   `json:\"message_navigation_toast_was_seen,omitempty\"`\n\tUpToBrowseKbShortcut                   bool   `json:\"up_to_browse_kb_shortcut,omitempty\"`\n\tChannelSections                        string `json:\"channel_sections,omitempty\"`\n\tTZ                                     string `json:\"tz,omitempty\"`\n}\n\nfunc (api *Client) GetUserPrefs() (*UserPrefsCarrier, error) {\n\treturn api.GetUserPrefsContext(context.Background())\n}\n\nfunc (api *Client) GetUserPrefsContext(ctx context.Context) (*UserPrefsCarrier, error) {\n\tresponse := UserPrefsCarrier{}\n\n\terr := api.getMethod(ctx, \"users.prefs.get\", api.token, url.Values{}, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, response.Err()\n}\n\nfunc (api *Client) MuteChat(channelID string) (*UserPrefsCarrier, error) {\n\tprefs, err := api.GetUserPrefs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchnls := strings.Split(prefs.UserPrefs.MutedChannels, \",\")\n\tfor _, chn := range chnls {\n\t\tif chn == channelID {\n\t\t\treturn nil, nil // noop\n\t\t}\n\t}\n\tnewChnls := prefs.UserPrefs.MutedChannels + \",\" + channelID\n\tvalues := url.Values{\"token\": {api.token}, \"muted_channels\": {newChnls}, \"reason\": {\"update-muted-channels\"}}\n\tresponse := UserPrefsCarrier{}\n\n\terr = api.postMethod(context.Background(), \"users.prefs.set\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, response.Err()\n}\n\nfunc (api *Client) UnMuteChat(channelID string) (*UserPrefsCarrier, error) {\n\tprefs, err := api.GetUserPrefs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchnls := strings.Split(prefs.UserPrefs.MutedChannels, \",\")\n\tnewChnls := make([]string, len(chnls)-1)\n\tfor i, chn := range chnls {\n\t\tif chn == channelID {\n\t\t\treturn nil, nil // noop\n\t\t}\n\t\tnewChnls[i] = chn\n\t}\n\tvalues := url.Values{\"token\": {api.token}, \"muted_channels\": {strings.Join(newChnls, \",\")}, \"reason\": {\"update-muted-channels\"}}\n\tresponse := UserPrefsCarrier{}\n\n\terr = api.postMethod(context.Background(), \"users.prefs.set\", values, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, response.Err()\n}\n\n// UserDetails contains user details coming in the initial response from StartRTM\ntype UserDetails struct {\n\tID             string    `json:\"id\"`\n\tName           string    `json:\"name\"`\n\tCreated        JSONTime  `json:\"created\"`\n\tManualPresence string    `json:\"manual_presence\"`\n\tPrefs          UserPrefs `json:\"prefs\"`\n}\n\n// JSONTime exists so that we can have a String method converting the date\ntype JSONTime int64\n\n// String converts the unix timestamp into a string\nfunc (t JSONTime) String() string {\n\ttm := t.Time()\n\treturn fmt.Sprintf(\"\\\"%s\\\"\", tm.Format(\"Mon Jan _2\"))\n}\n\n// Time returns a `time.Time` representation of this value.\nfunc (t JSONTime) Time() time.Time {\n\treturn time.Unix(int64(t), 0)\n}\n\n// UnmarshalJSON will unmarshal both string and int JSON values\nfunc (t *JSONTime) UnmarshalJSON(buf []byte) error {\n\ts := bytes.Trim(buf, `\"`)\n\n\tif bytes.EqualFold(s, []byte(\"null\")) {\n\t\t*t = JSONTime(0)\n\t\treturn nil\n\t}\n\n\tv, err := strconv.Atoi(string(s))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*t = JSONTime(int64(v))\n\treturn nil\n}\n\n// Team contains details about a team\ntype Team struct {\n\tID     string `json:\"id\"`\n\tName   string `json:\"name\"`\n\tDomain string `json:\"domain\"`\n}\n\n// Icons XXX: needs further investigation\ntype Icons struct {\n\tImage36 string `json:\"image_36,omitempty\"`\n\tImage48 string `json:\"image_48,omitempty\"`\n\tImage72 string `json:\"image_72,omitempty\"`\n}\n\n// Info contains various details about the authenticated user and team.\n// It is returned by StartRTM or included in the \"ConnectedEvent\" RTM event.\ntype Info struct {\n\tURL  string       `json:\"url,omitempty\"`\n\tUser *UserDetails `json:\"self,omitempty\"`\n\tTeam *Team        `json:\"team,omitempty\"`\n}\n\ntype infoResponseFull struct {\n\tInfo\n\tSlackResponse\n}\n\n// GetBotByID is deprecated and returns nil\nfunc (info Info) GetBotByID(botID string) *Bot {\n\treturn nil\n}\n\n// GetUserByID is deprecated and returns nil\nfunc (info Info) GetUserByID(userID string) *User {\n\treturn nil\n}\n\n// GetChannelByID is deprecated and returns nil\nfunc (info Info) GetChannelByID(channelID string) *Channel {\n\treturn nil\n}\n\n// GetGroupByID is deprecated and returns nil\nfunc (info Info) GetGroupByID(groupID string) *Group {\n\treturn nil\n}\n\n// GetIMByID is deprecated and returns nil\nfunc (info Info) GetIMByID(imID string) *IM {\n\treturn nil\n}\n"
        },
        {
          "name": "info_test.go",
          "type": "blob",
          "size": 0.7421875,
          "content": "package slack\n\nimport (\n\t\"testing\"\n)\n\nfunc TestJSONTime_UnmarshalJSON(t *testing.T) {\n\ttype args struct {\n\t\tbuf []byte\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantTr  JSONTime\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\t\"acceptable int64 timestamp\",\n\t\t\targs{[]byte(`1643435556`)},\n\t\t\tJSONTime(1643435556),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"acceptable string timestamp\",\n\t\t\targs{[]byte(`\"1643435556\"`)},\n\t\t\tJSONTime(1643435556),\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"null\",\n\t\t\targs{[]byte(`null`)},\n\t\t\tJSONTime(0),\n\t\t\tfalse,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tr JSONTime\n\t\t\tif err := tr.UnmarshalJSON(tt.args.buf); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"JSONTime.UnmarshalJSON() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "interactions.go",
          "type": "blob",
          "size": 7.5595703125,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n)\n\n// InteractionType type of interactions\ntype InteractionType string\n\n// ActionType type represents the type of action (attachment, block, etc.)\ntype ActionType string\n\n// action is an interface that should be implemented by all callback action types\ntype action interface {\n\tactionType() ActionType\n}\n\n// Types of interactions that can be received.\nconst (\n\tInteractionTypeDialogCancellation = InteractionType(\"dialog_cancellation\")\n\tInteractionTypeDialogSubmission   = InteractionType(\"dialog_submission\")\n\tInteractionTypeDialogSuggestion   = InteractionType(\"dialog_suggestion\")\n\tInteractionTypeInteractionMessage = InteractionType(\"interactive_message\")\n\tInteractionTypeMessageAction      = InteractionType(\"message_action\")\n\tInteractionTypeBlockActions       = InteractionType(\"block_actions\")\n\tInteractionTypeBlockSuggestion    = InteractionType(\"block_suggestion\")\n\tInteractionTypeViewSubmission     = InteractionType(\"view_submission\")\n\tInteractionTypeViewClosed         = InteractionType(\"view_closed\")\n\tInteractionTypeShortcut           = InteractionType(\"shortcut\")\n\tInteractionTypeWorkflowStepEdit   = InteractionType(\"workflow_step_edit\")\n)\n\n// InteractionCallback is sent from slack when a user interactions with a button or dialog.\ntype InteractionCallback struct {\n\tType                InteractionType         `json:\"type\"`\n\tToken               string                  `json:\"token\"`\n\tCallbackID          string                  `json:\"callback_id\"`\n\tResponseURL         string                  `json:\"response_url\"`\n\tTriggerID           string                  `json:\"trigger_id\"`\n\tActionTs            string                  `json:\"action_ts\"`\n\tTeam                Team                    `json:\"team\"`\n\tChannel             Channel                 `json:\"channel\"`\n\tUser                User                    `json:\"user\"`\n\tOriginalMessage     Message                 `json:\"original_message\"`\n\tMessage             Message                 `json:\"message\"`\n\tName                string                  `json:\"name\"`\n\tValue               string                  `json:\"value\"`\n\tMessageTs           string                  `json:\"message_ts\"`\n\tAttachmentID        string                  `json:\"attachment_id\"`\n\tActionCallback      ActionCallbacks         `json:\"actions\"`\n\tView                View                    `json:\"view\"`\n\tActionID            string                  `json:\"action_id\"`\n\tAPIAppID            string                  `json:\"api_app_id\"`\n\tBlockID             string                  `json:\"block_id\"`\n\tContainer           Container               `json:\"container\"`\n\tEnterprise          Enterprise              `json:\"enterprise\"`\n\tIsEnterpriseInstall bool                    `json:\"is_enterprise_install\"`\n\tWorkflowStep        InteractionWorkflowStep `json:\"workflow_step\"`\n\tDialogSubmissionCallback\n\tViewSubmissionCallback\n\tViewClosedCallback\n\n\t// FIXME(kanata2): just workaround for backward-compatibility.\n\t// See also https://github.com/slack-go/slack/issues/816\n\tRawState json.RawMessage `json:\"state,omitempty\"`\n\n\t// BlockActionState stands for the `state` field in block_actions type.\n\t// NOTE: InteractionCallback.State has a role for the state of dialog_submission type,\n\t// so we cannot use this field for backward-compatibility for now.\n\tBlockActionState *BlockActionStates `json:\"-\"`\n}\n\ntype BlockActionStates struct {\n\tValues map[string]map[string]BlockAction `json:\"values\"`\n}\n\nfunc (ic *InteractionCallback) MarshalJSON() ([]byte, error) {\n\ttype alias InteractionCallback\n\ttmp := alias(*ic)\n\tif tmp.Type == InteractionTypeBlockActions {\n\t\tif tmp.BlockActionState == nil {\n\t\t\ttmp.RawState = []byte(`{}`)\n\t\t} else {\n\t\t\tstate, err := json.Marshal(tmp.BlockActionState.Values)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ttmp.RawState = []byte(`{\"values\":` + string(state) + `}`)\n\t\t}\n\t} else if ic.Type == InteractionTypeDialogSubmission {\n\t\ttmp.RawState = []byte(tmp.State)\n\t}\n\t// Use pointer for go1.7\n\treturn json.Marshal(&tmp)\n}\n\nfunc (ic *InteractionCallback) UnmarshalJSON(b []byte) error {\n\ttype alias InteractionCallback\n\ttmp := struct {\n\t\tType InteractionType `json:\"type\"`\n\t\t*alias\n\t}{\n\t\talias: (*alias)(ic),\n\t}\n\tif err := json.Unmarshal(b, &tmp); err != nil {\n\t\treturn err\n\t}\n\t*ic = InteractionCallback(*tmp.alias)\n\tic.Type = tmp.Type\n\tif ic.Type == InteractionTypeBlockActions {\n\t\tif len(ic.RawState) > 0 {\n\t\t\terr := json.Unmarshal(ic.RawState, &ic.BlockActionState)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t} else if ic.Type == InteractionTypeDialogSubmission {\n\t\tic.State = string(ic.RawState)\n\t}\n\treturn nil\n}\n\ntype Container struct {\n\tType         string      `json:\"type\"`\n\tViewID       string      `json:\"view_id\"`\n\tMessageTs    string      `json:\"message_ts\"`\n\tThreadTs     string      `json:\"thread_ts,omitempty\"`\n\tAttachmentID json.Number `json:\"attachment_id\"`\n\tChannelID    string      `json:\"channel_id\"`\n\tIsEphemeral  bool        `json:\"is_ephemeral\"`\n\tIsAppUnfurl  bool        `json:\"is_app_unfurl\"`\n}\n\ntype Enterprise struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\ntype InteractionWorkflowStep struct {\n\tWorkflowStepEditID string                `json:\"workflow_step_edit_id,omitempty\"`\n\tWorkflowID         string                `json:\"workflow_id\"`\n\tStepID             string                `json:\"step_id\"`\n\tInputs             *WorkflowStepInputs   `json:\"inputs,omitempty\"`\n\tOutputs            *[]WorkflowStepOutput `json:\"outputs,omitempty\"`\n}\n\n// ActionCallback is a convenience struct defined to allow dynamic unmarshalling of\n// the \"actions\" value in Slack's JSON response, which varies depending on block type\ntype ActionCallbacks struct {\n\tAttachmentActions []*AttachmentAction\n\tBlockActions      []*BlockAction\n}\n\n// MarshalJSON implements the Marshaller interface in order to combine both\n// action callback types back into a single array, like how the api responds.\n// This makes Marshaling and Unmarshaling an InteractionCallback symmetrical\nfunc (a ActionCallbacks) MarshalJSON() ([]byte, error) {\n\tcount := 0\n\tlength := len(a.AttachmentActions) + len(a.BlockActions)\n\tbuffer := bytes.NewBufferString(\"[\")\n\n\tf := func(obj interface{}) error {\n\t\tjs, err := json.Marshal(obj)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = buffer.Write(js)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcount++\n\t\tif count < length {\n\t\t\t_, err = buffer.WriteString(\",\")\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor _, act := range a.AttachmentActions {\n\t\terr := f(act)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfor _, blk := range a.BlockActions {\n\t\terr := f(blk)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tbuffer.WriteString(\"]\")\n\treturn buffer.Bytes(), nil\n}\n\n// UnmarshalJSON implements the Marshaller interface in order to delegate\n// marshalling and allow for proper type assertion when decoding the response\nfunc (a *ActionCallbacks) UnmarshalJSON(data []byte) error {\n\tvar raw []json.RawMessage\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, r := range raw {\n\t\tvar obj map[string]interface{}\n\t\terr := json.Unmarshal(r, &obj)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, ok := obj[\"block_id\"].(string); ok {\n\t\t\taction, err := unmarshalAction(r, &BlockAction{})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ta.BlockActions = append(a.BlockActions, action.(*BlockAction))\n\t\t\tcontinue\n\t\t}\n\n\t\taction, err := unmarshalAction(r, &AttachmentAction{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ta.AttachmentActions = append(a.AttachmentActions, action.(*AttachmentAction))\n\t}\n\n\treturn nil\n}\n\nfunc unmarshalAction(r json.RawMessage, callbackAction action) (action, error) {\n\terr := json.Unmarshal(r, callbackAction)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn callbackAction, nil\n}\n"
        },
        {
          "name": "interactions_test.go",
          "type": "blob",
          "size": 14.029296875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst (\n\tdialogSubmissionCallback = `{\n\t\t\"type\": \"dialog_submission\",\n\t\t\"submission\": {\n\t\t\t\"name\": \"Sigourney Dreamweaver\",\n\t\t\t\"email\": \"sigdre@example.com\",\n\t\t\t\"phone\": \"+1 800-555-1212\",\n\t\t\t\"meal\": \"burrito\",\n\t\t\t\"comment\": \"No sour cream please\",\n\t\t\t\"team_channel\": \"C0LFFBKPB\",\n\t\t\t\"who_should_sing\": \"U0MJRG1AL\"\n\t\t},\n\t\t\"callback_id\": \"employee_offsite_1138b\",\n\t\t\"team\": {\n\t\t\t\"id\": \"T1ABCD2E12\",\n\t\t\t\"domain\": \"coverbands\"\n\t\t},\n\t\t\"user\": {\n\t\t\t\"id\": \"W12A3BCDEF\",\n\t\t\t\"name\": \"dreamweaver\"\n\t\t},\n\t\t\"channel\": {\n\t\t\t\"id\": \"C1AB2C3DE\",\n\t\t\t\"name\": \"coverthon-1999\"\n\t\t},\n\t\t\"action_ts\": \"936893340.702759\",\n\t\t\"token\": \"M1AqUUw3FqayAbqNtsGMch72\",\n\t\t\"response_url\": \"https://hooks.slack.com/app/T012AB0A1/123456789/JpmK0yzoZDeRiqfeduTBYXWQ\"\n\t}`\n\tactionCallback     = `{}`\n\tviewClosedCallback = `{\n\t\t\"type\": \"view_closed\",\n\t\t\"team\": {\n\t\t\t\"id\": \"T1ABCD2E12\",\n\t\t\t\"domain\": \"coverbands\"\n\t\t},\n\t\t\"user\": {\n\t\t\t\"id\": \"W12A3BCDEF\",\n\t\t\t\"name\": \"dreamweaver\"\n\t\t},\n\t\t\"view\": {\n\t\t\t\"type\": \"modal\",\n\t\t\t\"title\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"launch project\"\n\t\t\t},\n\t\t\t\"blocks\": [{\n\t\t\t\t\"type\": \"section\",\n\t\t\t\t\"text\": {\n\t\t\t\t  \"text\": \"*Sally* has requested you set the deadline for the Nano launch project\",\n\t\t\t\t  \"type\": \"mrkdwn\"\n\t\t\t\t},\n\t\t\t\t\"accessory\": {\n\t\t\t\t  \"type\": \"datepicker\",\n\t\t\t\t  \"action_id\": \"datepicker123\",\n\t\t\t\t  \"initial_date\": \"1990-04-28\",\n\t\t\t\t  \"placeholder\": {\n\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\"text\": \"Select a date\"\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"app_installed_team_id\": \"T1ABCD2E12\"\n\t\t},\n\t\t\"api_app_id\": \"A123ABC\",\n\t\t\"is_cleared\": false\n\t}`\n\tviewSubmissionCallback = `{\n\t\t\"type\": \"view_submission\",\n\t\t\"team\": {\n\t\t\t\"id\": \"T1ABCD2E12\",\n\t\t\t\"domain\": \"coverbands\"\n\t\t},\n\t\t\"user\": {\n\t\t\t\"id\": \"W12A3BCDEF\",\n\t\t\t\"name\": \"dreamweaver\"\n\t\t},\n\t\t\"channel\": {\n\t\t\t\"id\": \"C1AB2C3DE\",\n\t\t\t\"name\": \"coverthon-1999\"\n\t\t},\n\t\t\"view\": {\n\t\t\t\"type\": \"modal\",\n\t\t\t\"title\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"meal choice\"\n\t\t\t},\n\t\t\t\"blocks\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"input\",\n\t\t\t\t\t\"block_id\": \"multi-line\",\n\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"dietary restrictions\"\n\t\t\t\t\t},\n\t\t\t\t\t\"element\": {\n\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\"multiline\": true,\n\t\t\t\t\t\t\"action_id\": \"ml-value\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"input\",\n\t\t\t\t\t\"block_id\": \"target_channel\",\n\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Select a channel to post the result on\"\n\t\t\t\t\t},\n\t\t\t\t\t\"element\": {\n\t\t\t\t\t\t\"type\": \"conversations_select\",\n\t\t\t\t\t\t\"action_id\": \"target_select\",\n\t\t\t\t\t\t\"default_to_current_conversation\": true,\n\t\t\t\t\t\t\"response_url_enabled\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"state\": {\n\t\t\t\t\"values\": {\n\t\t\t\t\t\"multi-line\": {\n\t\t\t\t\t\t\"ml-value\": {\n\t\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\t\"value\": \"No onions\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"target_channel\": {\n\t\t\t\t\t\t\"target_select\": {\n\t\t\t\t\t\t\t\"type\": \"conversations_select\",\n\t\t\t\t\t\t\t\"value\": \"C1AB2C3DE\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"app_installed_team_id\": \"T1ABCD2E12\"\n\t\t},\n\t\t\"hash\": \"156663117.cd33ad1f\",\n\t\t\"response_urls\": [\n\t\t\t{\n\t\t\t\t\"block_id\": \"target_channel\",\n\t\t\t\t\"action_id\": \"target_select\",\n\t\t\t\t\"channel_id\": \"C1AB2C3DE\",\n\t\t\t\t\"response_url\": \"https:\\/\\/hooks.slack.com\\/app\\/ABC12312\\/1234567890\\/A100B100C100d100\"\n\t\t\t}\n\t\t]\n\t}`\n)\n\nfunc assertInteractionCallback(t *testing.T, callback InteractionCallback, encoded string) {\n\tvar decoded InteractionCallback\n\tassert.Nil(t, json.Unmarshal([]byte(encoded), &decoded))\n\tassert.Equal(t, decoded, callback)\n}\n\nfunc TestDialogCallback(t *testing.T) {\n\texpected := InteractionCallback{\n\t\tType:        InteractionTypeDialogSubmission,\n\t\tToken:       \"M1AqUUw3FqayAbqNtsGMch72\",\n\t\tCallbackID:  \"employee_offsite_1138b\",\n\t\tResponseURL: \"https://hooks.slack.com/app/T012AB0A1/123456789/JpmK0yzoZDeRiqfeduTBYXWQ\",\n\t\tActionTs:    \"936893340.702759\",\n\t\tTeam:        Team{ID: \"T1ABCD2E12\", Name: \"\", Domain: \"coverbands\"},\n\t\tChannel: Channel{\n\t\t\tGroupConversation: GroupConversation{\n\t\t\t\tConversation: Conversation{\n\t\t\t\t\tID: \"C1AB2C3DE\",\n\t\t\t\t},\n\t\t\t\tName: \"coverthon-1999\",\n\t\t\t},\n\t\t},\n\t\tUser: User{\n\t\t\tID:   \"W12A3BCDEF\",\n\t\t\tName: \"dreamweaver\",\n\t\t},\n\t\tDialogSubmissionCallback: DialogSubmissionCallback{\n\t\t\tSubmission: map[string]string{\n\t\t\t\t\"team_channel\":    \"C0LFFBKPB\",\n\t\t\t\t\"who_should_sing\": \"U0MJRG1AL\",\n\t\t\t\t\"name\":            \"Sigourney Dreamweaver\",\n\t\t\t\t\"email\":           \"sigdre@example.com\",\n\t\t\t\t\"phone\":           \"+1 800-555-1212\",\n\t\t\t\t\"meal\":            \"burrito\",\n\t\t\t\t\"comment\":         \"No sour cream please\",\n\t\t\t},\n\t\t},\n\t}\n\tassertInteractionCallback(t, expected, dialogSubmissionCallback)\n}\n\nfunc TestActionCallback(t *testing.T) {\n\tassertInteractionCallback(t, InteractionCallback{}, actionCallback)\n}\n\nfunc TestViewClosedck(t *testing.T) {\n\texpected := InteractionCallback{\n\t\tType: InteractionTypeViewClosed,\n\t\tTeam: Team{ID: \"T1ABCD2E12\", Name: \"\", Domain: \"coverbands\"},\n\t\tUser: User{\n\t\t\tID:   \"W12A3BCDEF\",\n\t\t\tName: \"dreamweaver\",\n\t\t},\n\t\tView: View{\n\t\t\tType:  VTModal,\n\t\t\tTitle: NewTextBlockObject(\"plain_text\", \"launch project\", false, false),\n\t\t\tBlocks: Blocks{\n\t\t\t\tBlockSet: []Block{\n\t\t\t\t\tNewSectionBlock(\n\t\t\t\t\t\tNewTextBlockObject(\"mrkdwn\", \"*Sally* has requested you set the deadline for the Nano launch project\", false, false),\n\t\t\t\t\t\tnil,\n\t\t\t\t\t\tNewAccessory(&DatePickerBlockElement{\n\t\t\t\t\t\t\tType:        METDatepicker,\n\t\t\t\t\t\t\tActionID:    \"datepicker123\",\n\t\t\t\t\t\t\tInitialDate: \"1990-04-28\",\n\t\t\t\t\t\t\tPlaceholder: NewTextBlockObject(\"plain_text\", \"Select a date\", false, false),\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t\tAppInstalledTeamID: \"T1ABCD2E12\",\n\t\t},\n\t\tAPIAppID: \"A123ABC\",\n\t}\n\tassertInteractionCallback(t, expected, viewClosedCallback)\n}\n\nfunc TestViewSubmissionCallback(t *testing.T) {\n\texpected := InteractionCallback{\n\t\tType: InteractionTypeViewSubmission,\n\t\tTeam: Team{ID: \"T1ABCD2E12\", Name: \"\", Domain: \"coverbands\"},\n\t\tChannel: Channel{\n\t\t\tGroupConversation: GroupConversation{\n\t\t\t\tConversation: Conversation{\n\t\t\t\t\tID: \"C1AB2C3DE\",\n\t\t\t\t},\n\t\t\t\tName: \"coverthon-1999\",\n\t\t\t},\n\t\t},\n\t\tUser: User{\n\t\t\tID:   \"W12A3BCDEF\",\n\t\t\tName: \"dreamweaver\",\n\t\t},\n\t\tView: View{\n\t\t\tType:  VTModal,\n\t\t\tTitle: NewTextBlockObject(\"plain_text\", \"meal choice\", false, false),\n\t\t\tBlocks: Blocks{\n\t\t\t\tBlockSet: []Block{\n\t\t\t\t\tNewInputBlock(\n\t\t\t\t\t\t\"multi-line\",\n\t\t\t\t\t\tNewTextBlockObject(\n\t\t\t\t\t\t\t\"plain_text\",\n\t\t\t\t\t\t\t\"dietary restrictions\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnil,\n\t\t\t\t\t\t&PlainTextInputBlockElement{\n\t\t\t\t\t\t\tType:      \"plain_text_input\",\n\t\t\t\t\t\t\tActionID:  \"ml-value\",\n\t\t\t\t\t\t\tMultiline: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t\tNewInputBlock(\n\t\t\t\t\t\t\"target_channel\",\n\t\t\t\t\t\tNewTextBlockObject(\n\t\t\t\t\t\t\t\"plain_text\",\n\t\t\t\t\t\t\t\"Select a channel to post the result on\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnil,\n\t\t\t\t\t\t&SelectBlockElement{\n\t\t\t\t\t\t\tType:                         \"conversations_select\",\n\t\t\t\t\t\t\tActionID:                     \"target_select\",\n\t\t\t\t\t\t\tDefaultToCurrentConversation: true,\n\t\t\t\t\t\t\tResponseURLEnabled:           true,\n\t\t\t\t\t\t},\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t\tState: &ViewState{\n\t\t\t\tValues: map[string]map[string]BlockAction{\n\t\t\t\t\t\"multi-line\": {\n\t\t\t\t\t\t\"ml-value\": {\n\t\t\t\t\t\t\tType:  \"plain_text_input\",\n\t\t\t\t\t\t\tValue: \"No onions\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"target_channel\": {\n\t\t\t\t\t\t\"target_select\": {\n\t\t\t\t\t\t\tType:  \"conversations_select\",\n\t\t\t\t\t\t\tValue: \"C1AB2C3DE\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAppInstalledTeamID: \"T1ABCD2E12\",\n\t\t},\n\t\tViewSubmissionCallback: ViewSubmissionCallback{\n\t\t\tHash: \"156663117.cd33ad1f\",\n\t\t\tResponseURLs: []ViewSubmissionCallbackResponseURL{\n\t\t\t\t{\n\t\t\t\t\tBlockID:     \"target_channel\",\n\t\t\t\t\tActionID:    \"target_select\",\n\t\t\t\t\tChannelID:   \"C1AB2C3DE\",\n\t\t\t\t\tResponseURL: \"https://hooks.slack.com/app/ABC12312/1234567890/A100B100C100d100\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tassertInteractionCallback(t, expected, viewSubmissionCallback)\n}\n\nfunc TestInteractionCallbackJSONMarshalAndUnmarshal(t *testing.T) {\n\tcb := &InteractionCallback{\n\t\tType:        InteractionTypeBlockActions,\n\t\tToken:       \"token\",\n\t\tCallbackID:  \"\",\n\t\tResponseURL: \"responseURL\",\n\t\tTriggerID:   \"triggerID\",\n\t\tActionTs:    \"actionTS\",\n\t\tTeam: Team{\n\t\t\tID:   \"teamid\",\n\t\t\tName: \"teamname\",\n\t\t},\n\t\tChannel: Channel{\n\t\t\tGroupConversation: GroupConversation{\n\t\t\t\tName:         \"channelname\",\n\t\t\t\tConversation: Conversation{ID: \"channelid\"},\n\t\t\t},\n\t\t},\n\t\tUser: User{\n\t\t\tID:      \"userid\",\n\t\t\tName:    \"username\",\n\t\t\tProfile: UserProfile{RealName: \"userrealname\"},\n\t\t},\n\t\tOriginalMessage: Message{\n\t\t\tMsg: Msg{\n\t\t\t\tText:      \"ogmsg text\",\n\t\t\t\tTimestamp: \"ogmsg ts\",\n\t\t\t},\n\t\t},\n\t\tMessage: Message{\n\t\t\tMsg: Msg{\n\t\t\t\tText:      \"text\",\n\t\t\t\tTimestamp: \"ts\",\n\t\t\t},\n\t\t},\n\t\tName:         \"name\",\n\t\tValue:        \"value\",\n\t\tMessageTs:    \"messageTs\",\n\t\tAttachmentID: \"attachmentID\",\n\t\tActionCallback: ActionCallbacks{\n\t\t\tAttachmentActions: []*AttachmentAction{\n\t\t\t\t{Value: \"value\"},\n\t\t\t\t{Value: \"value2\"},\n\t\t\t},\n\t\t\tBlockActions: []*BlockAction{\n\t\t\t\t{ActionID: \"id123\"},\n\t\t\t\t{ActionID: \"id456\"},\n\t\t\t},\n\t\t},\n\t\tView: View{\n\t\t\tType:  VTModal,\n\t\t\tTitle: NewTextBlockObject(\"plain_text\", \"title\", false, false),\n\t\t\tBlocks: Blocks{\n\t\t\t\tBlockSet: []Block{NewDividerBlock()},\n\t\t\t},\n\t\t},\n\t\tDialogSubmissionCallback: DialogSubmissionCallback{State: \"\"},\n\t\tRawState:                 json.RawMessage(`{}`),\n\t}\n\n\tcbJSONBytes, err := json.Marshal(cb)\n\tassert.NoError(t, err)\n\n\tjsonCB := new(InteractionCallback)\n\terr = json.Unmarshal(cbJSONBytes, jsonCB)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, cb.Type, jsonCB.Type)\n\tassert.Equal(t, cb.Token, jsonCB.Token)\n\tassert.Equal(t, cb.CallbackID, jsonCB.CallbackID)\n\tassert.Equal(t, cb.ResponseURL, jsonCB.ResponseURL)\n\tassert.Equal(t, cb.TriggerID, jsonCB.TriggerID)\n\tassert.Equal(t, cb.ActionTs, jsonCB.ActionTs)\n\tassert.Equal(t, cb.Team.ID, jsonCB.Team.ID)\n\tassert.Equal(t, cb.Team.Name, jsonCB.Team.Name)\n\tassert.Equal(t, cb.Channel.ID, jsonCB.Channel.ID)\n\tassert.Equal(t, cb.Channel.Name, jsonCB.Channel.Name)\n\tassert.Equal(t, cb.Channel.Created, jsonCB.Channel.Created)\n\tassert.Equal(t, cb.User.ID, jsonCB.User.ID)\n\tassert.Equal(t, cb.User.Name, jsonCB.User.Name)\n\tassert.Equal(t, cb.User.Profile.RealName, jsonCB.User.Profile.RealName)\n\tassert.Equal(t, cb.OriginalMessage.Text, jsonCB.OriginalMessage.Text)\n\tassert.Equal(t, cb.OriginalMessage.Timestamp,\n\t\tjsonCB.OriginalMessage.Timestamp)\n\tassert.Equal(t, cb.Message.Text, jsonCB.Message.Text)\n\tassert.Equal(t, cb.Message.Timestamp, jsonCB.Message.Timestamp)\n\tassert.Equal(t, cb.Name, jsonCB.Name)\n\tassert.Equal(t, cb.Value, jsonCB.Value)\n\tassert.Equal(t, cb.MessageTs, jsonCB.MessageTs)\n\tassert.Equal(t, cb.AttachmentID, jsonCB.AttachmentID)\n\tassert.Equal(t, len(cb.ActionCallback.AttachmentActions),\n\t\tlen(jsonCB.ActionCallback.AttachmentActions))\n\tassert.Equal(t, len(cb.ActionCallback.BlockActions),\n\t\tlen(jsonCB.ActionCallback.BlockActions))\n\tassert.Equal(t, cb.View.Type, jsonCB.View.Type)\n\tassert.Equal(t, cb.View.Title, jsonCB.View.Title)\n\tassert.Equal(t, cb.View.Blocks, jsonCB.View.Blocks)\n\tassert.Equal(t, cb.DialogSubmissionCallback.State,\n\t\tjsonCB.DialogSubmissionCallback.State)\n}\n\nfunc TestInteractionCallback_InteractionTypeBlockActions_Unmarshal(t *testing.T) {\n\traw := []byte(`{\n\t\t\"type\": \"block_actions\",\n\t\t\"actions\": [\n\t\t\t{\n\t\t\t\t\"type\": \"multi_conversations_select\",\n\t\t\t\t\"action_id\": \"multi_convos\",\n\t\t\t\t\"block_id\": \"test123\",\n\t\t\t\t\"selected_conversations\": [\"G12345\"]\n\t\t\t}\n\t\t],\n\t\t\"container\": {\n\t\t\t\"type\": \"view\",\n\t\t\t\"view_id\": \"V12345\"\n\t\t},\n\t\t\"state\": {\n\t\t\t\"values\": {\n\t\t\t\t\"section_block_id\": {\n\t\t\t\t\t\"multi_convos\": {\n\t\t\t\t\t\t\"type\": \"multi_conversations_select\",\n\t\t\t\t\t\t\"selected_conversations\": [\"G12345\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"other_block_id\": {\n\t\t\t\t\t\"other_action_id\": {\n\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\"value\": \"test123\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}`)\n\tvar cb InteractionCallback\n\tassert.NoError(t, json.Unmarshal(raw, &cb))\n\tassert.Equal(t, cb.State, \"\")\n\tassert.Equal(t,\n\t\tcb.BlockActionState.Values[\"section_block_id\"][\"multi_convos\"].actionType(),\n\t\tActionType(MultiOptTypeConversations))\n\tassert.Equal(t,\n\t\tcb.BlockActionState.Values[\"section_block_id\"][\"multi_convos\"].SelectedConversations,\n\t\t[]string{\"G12345\"})\n}\n\nfunc TestInteractionCallback_Container_Marshal_And_Unmarshal(t *testing.T) {\n\t// Contrived - you generally won't see all of the fields set in a single message\n\traw := []byte(\n\t\t`\n\t\t{\n\t\t\t\"container\": {\n\t\t\t\t\"type\": \"message\",\n\t\t\t\t\"view_id\": \"viewID\",\n\t\t\t\t\"message_ts\": \"messageTS\",\n\t\t\t\t\"attachment_id\": \"123\",\n\t\t\t\t\"channel_id\": \"channelID\",\n\t\t\t\t\"is_ephemeral\": false,\n\t\t\t\t\"is_app_unfurl\": false\n\t\t\t}\n\t\t}\n\t\t`)\n\n\texpected := &InteractionCallback{\n\t\tContainer: Container{\n\t\t\tType:         \"message\",\n\t\t\tViewID:       \"viewID\",\n\t\t\tMessageTs:    \"messageTS\",\n\t\t\tAttachmentID: \"123\",\n\t\t\tChannelID:    \"channelID\",\n\t\t\tIsEphemeral:  false,\n\t\t\tIsAppUnfurl:  false,\n\t\t},\n\t\tRawState: json.RawMessage(`{}`),\n\t}\n\n\tactual := new(InteractionCallback)\n\terr := json.Unmarshal(raw, actual)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected.Container, actual.Container)\n\n\texpectedJSON := []byte(`{\"type\":\"message\",\"view_id\":\"viewID\",\"message_ts\":\"messageTS\",\"attachment_id\":123,\"channel_id\":\"channelID\",\"is_ephemeral\":false,\"is_app_unfurl\":false}`)\n\tactualJSON, err := json.Marshal(actual.Container)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedJSON, actualJSON)\n}\n\nfunc TestInteractionCallback_In_Thread_Container_Marshal_And_Unmarshal(t *testing.T) {\n\t// Contrived - you generally won't see all of the fields set in a single message\n\traw := []byte(\n\t\t`\n\t\t{\n\t\t\t\"container\": {\n\t\t\t\t\"type\": \"message\",\n\t\t\t\t\"view_id\": \"viewID\",\n\t\t\t\t\"message_ts\": \"messageTS\",\n\t\t\t\t\"thread_ts\": \"threadTS\",\n\t\t\t\t\"attachment_id\": \"123\",\n\t\t\t\t\"channel_id\": \"channelID\",\n\t\t\t\t\"is_ephemeral\": false,\n\t\t\t\t\"is_app_unfurl\": false\n\t\t\t}\n\t\t}\n\t\t`)\n\n\texpected := &InteractionCallback{\n\t\tContainer: Container{\n\t\t\tType:         \"message\",\n\t\t\tViewID:       \"viewID\",\n\t\t\tMessageTs:    \"messageTS\",\n\t\t\tThreadTs:     \"threadTS\",\n\t\t\tAttachmentID: \"123\",\n\t\t\tChannelID:    \"channelID\",\n\t\t\tIsEphemeral:  false,\n\t\t\tIsAppUnfurl:  false,\n\t\t},\n\t\tRawState: json.RawMessage(`{}`),\n\t}\n\n\tactual := new(InteractionCallback)\n\terr := json.Unmarshal(raw, actual)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected.Container, actual.Container)\n\n\texpectedJSON := []byte(`{\"type\":\"message\",\"view_id\":\"viewID\",\"message_ts\":\"messageTS\",\"thread_ts\":\"threadTS\",\"attachment_id\":123,\"channel_id\":\"channelID\",\"is_ephemeral\":false,\"is_app_unfurl\":false}`)\n\tactualJSON, err := json.Marshal(actual.Container)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedJSON, actualJSON)\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "item.go",
          "type": "blob",
          "size": 2.212890625,
          "content": "package slack\n\nconst (\n\tTYPE_MESSAGE      = \"message\"\n\tTYPE_FILE         = \"file\"\n\tTYPE_FILE_COMMENT = \"file_comment\"\n\tTYPE_CHANNEL      = \"channel\"\n\tTYPE_IM           = \"im\"\n\tTYPE_GROUP        = \"group\"\n)\n\n// Item is any type of slack message - message, file, or file comment.\ntype Item struct {\n\tType      string   `json:\"type\"`\n\tChannel   string   `json:\"channel,omitempty\"`\n\tMessage   *Message `json:\"message,omitempty\"`\n\tFile      *File    `json:\"file,omitempty\"`\n\tComment   *Comment `json:\"comment,omitempty\"`\n\tTimestamp string   `json:\"ts,omitempty\"`\n}\n\n// NewMessageItem turns a message on a channel into a typed message struct.\nfunc NewMessageItem(ch string, m *Message) Item {\n\treturn Item{Type: TYPE_MESSAGE, Channel: ch, Message: m}\n}\n\n// NewFileItem turns a file into a typed file struct.\nfunc NewFileItem(f *File) Item {\n\treturn Item{Type: TYPE_FILE, File: f}\n}\n\n// NewFileCommentItem turns a file and comment into a typed file_comment struct.\nfunc NewFileCommentItem(f *File, c *Comment) Item {\n\treturn Item{Type: TYPE_FILE_COMMENT, File: f, Comment: c}\n}\n\n// NewChannelItem turns a channel id into a typed channel struct.\nfunc NewChannelItem(ch string) Item {\n\treturn Item{Type: TYPE_CHANNEL, Channel: ch}\n}\n\n// NewIMItem turns a channel id into a typed im struct.\nfunc NewIMItem(ch string) Item {\n\treturn Item{Type: TYPE_IM, Channel: ch}\n}\n\n// NewGroupItem turns a channel id into a typed group struct.\nfunc NewGroupItem(ch string) Item {\n\treturn Item{Type: TYPE_GROUP, Channel: ch}\n}\n\n// ItemRef is a reference to a message of any type. One of FileID,\n// CommentId, or the combination of ChannelId and Timestamp must be\n// specified.\ntype ItemRef struct {\n\tChannel   string `json:\"channel\"`\n\tTimestamp string `json:\"timestamp\"`\n\tFile      string `json:\"file\"`\n\tComment   string `json:\"file_comment\"`\n}\n\n// NewRefToMessage initializes a reference to to a message.\nfunc NewRefToMessage(channel, timestamp string) ItemRef {\n\treturn ItemRef{Channel: channel, Timestamp: timestamp}\n}\n\n// NewRefToFile initializes a reference to a file.\nfunc NewRefToFile(file string) ItemRef {\n\treturn ItemRef{File: file}\n}\n\n// NewRefToComment initializes a reference to a file comment.\nfunc NewRefToComment(comment string) ItemRef {\n\treturn ItemRef{Comment: comment}\n}\n"
        },
        {
          "name": "item_test.go",
          "type": "blob",
          "size": 3.0849609375,
          "content": "package slack\n\nimport \"testing\"\n\nfunc TestNewMessageItem(t *testing.T) {\n\tc := \"C1\"\n\tm := &Message{}\n\tmi := NewMessageItem(c, m)\n\tif mi.Type != TYPE_MESSAGE {\n\t\tt.Errorf(\"want Type %s, got %s\", mi.Type, TYPE_MESSAGE)\n\t}\n\tif mi.Channel != c {\n\t\tt.Errorf(\"got Channel %s, want %s\", mi.Channel, c)\n\t}\n\tif mi.Message != m {\n\t\tt.Errorf(\"got Message %v, want %v\", mi.Message, m)\n\t}\n}\n\nfunc TestNewFileItem(t *testing.T) {\n\tf := &File{}\n\tfi := NewFileItem(f)\n\tif fi.Type != TYPE_FILE {\n\t\tt.Errorf(\"got Type %s, want %s\", fi.Type, TYPE_FILE)\n\t}\n\tif fi.File != f {\n\t\tt.Errorf(\"got File %v, want %v\", fi.File, f)\n\t}\n}\n\nfunc TestNewFileCommentItem(t *testing.T) {\n\tf := &File{}\n\tc := &Comment{}\n\tfci := NewFileCommentItem(f, c)\n\tif fci.Type != TYPE_FILE_COMMENT {\n\t\tt.Errorf(\"got Type %s, want %s\", fci.Type, TYPE_FILE_COMMENT)\n\t}\n\tif fci.File != f {\n\t\tt.Errorf(\"got File %v, want %v\", fci.File, f)\n\t}\n\tif fci.Comment != c {\n\t\tt.Errorf(\"got Comment %v, want %v\", fci.Comment, c)\n\t}\n}\n\nfunc TestNewChannelItem(t *testing.T) {\n\tc := \"C1\"\n\tci := NewChannelItem(c)\n\tif ci.Type != TYPE_CHANNEL {\n\t\tt.Errorf(\"got Type %s, want %s\", ci.Type, TYPE_CHANNEL)\n\t}\n\tif ci.Channel != \"C1\" {\n\t\tt.Errorf(\"got Channel %v, want %v\", ci.Channel, \"C1\")\n\t}\n}\n\nfunc TestNewIMItem(t *testing.T) {\n\tc := \"D1\"\n\tci := NewIMItem(c)\n\tif ci.Type != TYPE_IM {\n\t\tt.Errorf(\"got Type %s, want %s\", ci.Type, TYPE_IM)\n\t}\n\tif ci.Channel != \"D1\" {\n\t\tt.Errorf(\"got Channel %v, want %v\", ci.Channel, \"D1\")\n\t}\n}\n\nfunc TestNewGroupItem(t *testing.T) {\n\tc := \"G1\"\n\tci := NewGroupItem(c)\n\tif ci.Type != TYPE_GROUP {\n\t\tt.Errorf(\"got Type %s, want %s\", ci.Type, TYPE_GROUP)\n\t}\n\tif ci.Channel != \"G1\" {\n\t\tt.Errorf(\"got Channel %v, want %v\", ci.Channel, \"G1\")\n\t}\n}\n\nfunc TestNewRefToMessage(t *testing.T) {\n\tref := NewRefToMessage(\"chan\", \"ts\")\n\tif got, want := ref.Channel, \"chan\"; got != want {\n\t\tt.Errorf(\"Channel got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.Timestamp, \"ts\"; got != want {\n\t\tt.Errorf(\"Timestamp got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.File, \"\"; got != want {\n\t\tt.Errorf(\"File got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.Comment, \"\"; got != want {\n\t\tt.Errorf(\"Comment got %s, want %s\", got, want)\n\t}\n}\n\nfunc TestNewRefToFile(t *testing.T) {\n\tref := NewRefToFile(\"file\")\n\tif got, want := ref.Channel, \"\"; got != want {\n\t\tt.Errorf(\"Channel got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.Timestamp, \"\"; got != want {\n\t\tt.Errorf(\"Timestamp got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.File, \"file\"; got != want {\n\t\tt.Errorf(\"File got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.Comment, \"\"; got != want {\n\t\tt.Errorf(\"Comment got %s, want %s\", got, want)\n\t}\n}\n\nfunc TestNewRefToComment(t *testing.T) {\n\tref := NewRefToComment(\"file_comment\")\n\tif got, want := ref.Channel, \"\"; got != want {\n\t\tt.Errorf(\"Channel got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.Timestamp, \"\"; got != want {\n\t\tt.Errorf(\"Timestamp got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.File, \"\"; got != want {\n\t\tt.Errorf(\"File got %s, want %s\", got, want)\n\t}\n\tif got, want := ref.Comment, \"file_comment\"; got != want {\n\t\tt.Errorf(\"Comment got %s, want %s\", got, want)\n\t}\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 1.3154296875,
          "content": "package slack\n\nimport (\n\t\"fmt\"\n)\n\n// logger is a logger interface compatible with both stdlib and some\n// 3rd party loggers.\ntype logger interface {\n\tOutput(int, string) error\n}\n\n// ilogger represents the internal logging api we use.\ntype ilogger interface {\n\tlogger\n\tPrint(...interface{})\n\tPrintf(string, ...interface{})\n\tPrintln(...interface{})\n}\n\ntype Debug interface {\n\tDebug() bool\n\n\t// Debugf print a formatted debug line.\n\tDebugf(format string, v ...interface{})\n\t// Debugln print a debug line.\n\tDebugln(v ...interface{})\n}\n\n// internalLog implements the additional methods used by our internal logging.\ntype internalLog struct {\n\tlogger\n}\n\n// Println replicates the behaviour of the standard logger.\nfunc (t internalLog) Println(v ...interface{}) {\n\tt.Output(2, fmt.Sprintln(v...))\n}\n\n// Printf replicates the behaviour of the standard logger.\nfunc (t internalLog) Printf(format string, v ...interface{}) {\n\tt.Output(2, fmt.Sprintf(format, v...))\n}\n\n// Print replicates the behaviour of the standard logger.\nfunc (t internalLog) Print(v ...interface{}) {\n\tt.Output(2, fmt.Sprint(v...))\n}\n\ntype discard struct{}\n\nfunc (t discard) Debug() bool {\n\treturn false\n}\n\n// Debugf print a formatted debug line.\nfunc (t discard) Debugf(format string, v ...interface{}) {}\n\n// Debugln print a debug line.\nfunc (t discard) Debugln(v ...interface{}) {}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 0.69140625,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLogging(t *testing.T) {\n\tbuf := bytes.NewBufferString(\"\")\n\tlogger := internalLog{logger: log.New(buf, \"\", 0|log.Lshortfile)}\n\tlogger.Println(\"test line 123\")\n\tassert.Equal(t, buf.String(), \"logger_test.go:14: test line 123\\n\")\n\tbuf.Truncate(0)\n\tlogger.Print(\"test line 123\")\n\tassert.Equal(t, buf.String(), \"logger_test.go:17: test line 123\\n\")\n\tbuf.Truncate(0)\n\tlogger.Printf(\"test line 123\\n\")\n\tassert.Equal(t, buf.String(), \"logger_test.go:20: test line 123\\n\")\n\tbuf.Truncate(0)\n\tlogger.Output(1, \"test line 123\\n\")\n\tassert.Equal(t, buf.String(), \"logger_test.go:23: test line 123\\n\")\n\tbuf.Truncate(0)\n}\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 51.2109375,
          "content": null
        },
        {
          "name": "manifests.go",
          "type": "blob",
          "size": 11.080078125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\n// Manifest is an application manifest schema\ntype Manifest struct {\n\tMetadata    ManifestMetadata `json:\"_metadata,omitempty\" yaml:\"_metadata,omitempty\"`\n\tDisplay     Display          `json:\"display_information\" yaml:\"display_information\"`\n\tSettings    Settings         `json:\"settings,omitempty\" yaml:\"settings,omitempty\"`\n\tFeatures    Features         `json:\"features,omitempty\" yaml:\"features,omitempty\"`\n\tOAuthConfig OAuthConfig      `json:\"oauth_config,omitempty\" yaml:\"oauth_config,omitempty\"`\n}\n\n// CreateManifest creates an app from an app manifest.\n// For more details, see CreateManifestContext documentation.\nfunc (api *Client) CreateManifest(manifest *Manifest, token string) (*ManifestResponse, error) {\n\treturn api.CreateManifestContext(context.Background(), manifest, token)\n}\n\n// CreateManifestContext creates an app from an app manifest with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.manifest.create\nfunc (api *Client) CreateManifestContext(ctx context.Context, manifest *Manifest, token string) (*ManifestResponse, error) {\n\tif token == \"\" {\n\t\ttoken = api.configToken\n\t}\n\n\tjsonBytes, err := json.Marshal(manifest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":    {token},\n\t\t\"manifest\": {string(jsonBytes)},\n\t}\n\n\tresponse := &ManifestResponse{}\n\terr = api.postMethod(ctx, \"apps.manifest.create\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// DeleteManifest permanently deletes an app created through app manifests.\n// For more details, see DeleteManifestContext documentation.\nfunc (api *Client) DeleteManifest(token string, appId string) (*SlackResponse, error) {\n\treturn api.DeleteManifestContext(context.Background(), token, appId)\n}\n\n// DeleteManifestContext permanently deletes an app created through app manifests with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.manifest.delete\nfunc (api *Client) DeleteManifestContext(ctx context.Context, token string, appId string) (*SlackResponse, error) {\n\tif token == \"\" {\n\t\ttoken = api.configToken\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":  {token},\n\t\t\"app_id\": {appId},\n\t}\n\n\tresponse := &SlackResponse{}\n\terr := api.postMethod(ctx, \"apps.manifest.delete\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// ExportManifest exports an app manifest from an existing app.\n// For more details, see ExportManifestContext documentation.\nfunc (api *Client) ExportManifest(token string, appId string) (*Manifest, error) {\n\treturn api.ExportManifestContext(context.Background(), token, appId)\n}\n\n// ExportManifestContext exports an app manifest from an existing app with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.manifest.export\nfunc (api *Client) ExportManifestContext(ctx context.Context, token string, appId string) (*Manifest, error) {\n\tif token == \"\" {\n\t\ttoken = api.configToken\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":  {token},\n\t\t\"app_id\": {appId},\n\t}\n\n\tresponse := &ExportManifestResponse{}\n\terr := api.postMethod(ctx, \"apps.manifest.export\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.Manifest, response.Err()\n}\n\n// UpdateManifest updates an app from an app manifest.\n// For more details, see UpdateManifestContext documentation.\nfunc (api *Client) UpdateManifest(manifest *Manifest, token string, appId string) (*UpdateManifestResponse, error) {\n\treturn api.UpdateManifestContext(context.Background(), manifest, token, appId)\n}\n\n// UpdateManifestContext updates an app from an app manifest with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.manifest.update\nfunc (api *Client) UpdateManifestContext(ctx context.Context, manifest *Manifest, token string, appId string) (*UpdateManifestResponse, error) {\n\tif token == \"\" {\n\t\ttoken = api.configToken\n\t}\n\n\tjsonBytes, err := json.Marshal(manifest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":    {token},\n\t\t\"app_id\":   {appId},\n\t\t\"manifest\": {string(jsonBytes)},\n\t}\n\n\tresponse := &UpdateManifestResponse{}\n\terr = api.postMethod(ctx, \"apps.manifest.update\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// ValidateManifest sends a request to apps.manifest.validate to validate your app manifest.\n// For more details, see ValidateManifestContext documentation.\nfunc (api *Client) ValidateManifest(manifest *Manifest, token string, appId string) (*ManifestResponse, error) {\n\treturn api.ValidateManifestContext(context.Background(), manifest, token, appId)\n}\n\n// ValidateManifestContext sends a request to apps.manifest.validate to validate your app manifest with a custom context.\n// Slack API docs: https://api.slack.com/methods/apps.manifest.validate\nfunc (api *Client) ValidateManifestContext(ctx context.Context, manifest *Manifest, token string, appId string) (*ManifestResponse, error) {\n\tif token == \"\" {\n\t\ttoken = api.configToken\n\t}\n\n\t// Marshal manifest into string\n\tjsonBytes, err := json.Marshal(manifest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":    {token},\n\t\t\"manifest\": {string(jsonBytes)},\n\t}\n\n\tif appId != \"\" {\n\t\tvalues.Add(\"app_id\", appId)\n\t}\n\n\tresponse := &ManifestResponse{}\n\terr = api.postMethod(ctx, \"apps.manifest.validate\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// ManifestMetadata is a group of settings that describe the manifest\ntype ManifestMetadata struct {\n\tMajorVersion int `json:\"major_version,omitempty\" yaml:\"major_version,omitempty\"`\n\tMinorVersion int `json:\"minor_version,omitempty\" yaml:\"minor_version,omitempty\"`\n}\n\n// Display is a group of settings that describe parts of an app's appearance within Slack\ntype Display struct {\n\tName            string `json:\"name\" yaml:\"name\"`\n\tDescription     string `json:\"description,omitempty\" yaml:\"description,omitempty\"`\n\tLongDescription string `json:\"long_description,omitempty\" yaml:\"long_description,omitempty\"`\n\tBackgroundColor string `json:\"background_color,omitempty\" yaml:\"background_color,omitempty\"`\n}\n\n// Settings is a group of settings corresponding to the Settings section of the app config pages.\ntype Settings struct {\n\tAllowedIPAddressRanges []string           `json:\"allowed_ip_address_ranges,omitempty\" yaml:\"allowed_ip_address_ranges,omitempty\"`\n\tEventSubscriptions     EventSubscriptions `json:\"event_subscriptions,omitempty\" yaml:\"event_subscriptions,omitempty\"`\n\tInteractivity          Interactivity      `json:\"interactivity,omitempty\" yaml:\"interactivity,omitempty\"`\n\tOrgDeployEnabled       bool               `json:\"org_deploy_enabled,omitempty\" yaml:\"org_deploy_enabled,omitempty\"`\n\tSocketModeEnabled      bool               `json:\"socket_mode_enabled,omitempty\" yaml:\"socket_mode_enabled,omitempty\"`\n}\n\n// EventSubscriptions is a group of settings that describe the Events API configuration\ntype EventSubscriptions struct {\n\tRequestUrl string   `json:\"request_url,omitempty\" yaml:\"request_url,omitempty\"`\n\tBotEvents  []string `json:\"bot_events,omitempty\" yaml:\"bot_events,omitempty\"`\n\tUserEvents []string `json:\"user_events,omitempty\" yaml:\"user_events,omitempty\"`\n}\n\n// Interactivity is a group of settings that describe the interactivity configuration\ntype Interactivity struct {\n\tIsEnabled             bool   `json:\"is_enabled\" yaml:\"is_enabled\"`\n\tRequestUrl            string `json:\"request_url,omitempty\" yaml:\"request_url,omitempty\"`\n\tMessageMenuOptionsUrl string `json:\"message_menu_options_url,omitempty\" yaml:\"message_menu_options_url,omitempty\"`\n}\n\n// Features is a group of settings corresponding to the Features section of the app config pages\ntype Features struct {\n\tAppHome       AppHome                `json:\"app_home,omitempty\" yaml:\"app_home,omitempty\"`\n\tBotUser       BotUser                `json:\"bot_user,omitempty\" yaml:\"bot_user,omitempty\"`\n\tShortcuts     []Shortcut             `json:\"shortcuts,omitempty\" yaml:\"shortcuts,omitempty\"`\n\tSlashCommands []ManifestSlashCommand `json:\"slash_commands,omitempty\" yaml:\"slash_commands,omitempty\"`\n\tWorkflowSteps []WorkflowStep         `json:\"workflow_steps,omitempty\" yaml:\"workflow_steps,omitempty\"`\n}\n\n// AppHome is a group of settings that describe the App Home configuration\ntype AppHome struct {\n\tHomeTabEnabled             bool `json:\"home_tab_enabled,omitempty\" yaml:\"home_tab_enabled,omitempty\"`\n\tMessagesTabEnabled         bool `json:\"messages_tab_enabled,omitempty\" yaml:\"messages_tab_enabled,omitempty\"`\n\tMessagesTabReadOnlyEnabled bool `json:\"messages_tab_read_only_enabled,omitempty\" yaml:\"messages_tab_read_only_enabled,omitempty\"`\n}\n\n// BotUser is a group of settings that describe bot user configuration\ntype BotUser struct {\n\tDisplayName  string `json:\"display_name\" yaml:\"display_name\"`\n\tAlwaysOnline bool   `json:\"always_online,omitempty\" yaml:\"always_online,omitempty\"`\n}\n\n// Shortcut is a group of settings that describes shortcut configuration\ntype Shortcut struct {\n\tName        string       `json:\"name\" yaml:\"name\"`\n\tCallbackID  string       `json:\"callback_id\" yaml:\"callback_id\"`\n\tDescription string       `json:\"description\" yaml:\"description\"`\n\tType        ShortcutType `json:\"type\" yaml:\"type\"`\n}\n\n// ShortcutType is a new string type for the available types of shortcuts\ntype ShortcutType string\n\nconst (\n\tMessageShortcut ShortcutType = \"message\"\n\tGlobalShortcut  ShortcutType = \"global\"\n)\n\n// ManifestSlashCommand is a group of settings that describes slash command configuration\ntype ManifestSlashCommand struct {\n\tCommand      string `json:\"command\" yaml:\"command\"`\n\tDescription  string `json:\"description\" yaml:\"description\"`\n\tShouldEscape bool   `json:\"should_escape,omitempty\" yaml:\"should_escape,omitempty\"`\n\tUrl          string `json:\"url,omitempty\" yaml:\"url,omitempty\"`\n\tUsageHint    string `json:\"usage_hint,omitempty\" yaml:\"usage_hint,omitempty\"`\n}\n\n// WorkflowStep is a group of settings that describes workflow steps configuration\ntype WorkflowStep struct {\n\tName       string `json:\"name\" yaml:\"name\"`\n\tCallbackID string `json:\"callback_id\" yaml:\"callback_id\"`\n}\n\n// OAuthConfig is a group of settings that describe OAuth configuration for the app\ntype OAuthConfig struct {\n\tRedirectUrls []string    `json:\"redirect_urls,omitempty\" yaml:\"redirect_urls,omitempty\"`\n\tScopes       OAuthScopes `json:\"scopes,omitempty\" yaml:\"scopes,omitempty\"`\n}\n\n// OAuthScopes is a group of settings that describe permission scopes configuration\ntype OAuthScopes struct {\n\tBot  []string `json:\"bot,omitempty\" yaml:\"bot,omitempty\"`\n\tUser []string `json:\"user,omitempty\" yaml:\"user,omitempty\"`\n}\n\n// ManifestResponse is the response returned by the API for apps.manifest.x endpoints\ntype ManifestResponse struct {\n\tErrors []ManifestValidationError `json:\"errors,omitempty\"`\n\tSlackResponse\n}\n\n// ManifestValidationError is an error message returned for invalid manifests\ntype ManifestValidationError struct {\n\tMessage string `json:\"message\"`\n\tPointer string `json:\"pointer\"`\n}\n\ntype ExportManifestResponse struct {\n\tManifest Manifest `json:\"manifest,omitempty\"`\n\tSlackResponse\n}\n\ntype UpdateManifestResponse struct {\n\tAppId              string `json:\"app_id,omitempty\"`\n\tPermissionsUpdated bool   `json:\"permissions_updated,omitempty\"`\n\tManifestResponse\n}\n"
        },
        {
          "name": "manifests_test.go",
          "type": "blob",
          "size": 3.6513671875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCreateManifest(t *testing.T) {\n\thttp.HandleFunc(\"/apps.manifest.create\", handleCreateManifest)\n\tonce.Do(startServer)\n\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tmanif := getTestManifest()\n\tresp, err := api.CreateManifest(&manif, \"token\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual(resp, getTestManifestResponse()) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc handleCreateManifest(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := json.Marshal(getTestManifestResponse())\n\trw.Write(response)\n}\n\nfunc TestDeleteManifest(t *testing.T) {\n\thttp.HandleFunc(\"/apps.manifest.delete\", handleDeleteManifest)\n\texpectedResponse := SlackResponse{Ok: true}\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tresp, err := api.DeleteManifest(\"token\", \"app id\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual(expectedResponse, *resp) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc handleDeleteManifest(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := json.Marshal(SlackResponse{Ok: true})\n\trw.Write(response)\n}\n\nfunc TestExportManifest(t *testing.T) {\n\thttp.HandleFunc(\"/apps.manifest.export\", handleExportManifest)\n\texpectedResponse := getTestManifest()\n\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tresp, err := api.ExportManifest(\"token\", \"app id\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual(expectedResponse, *resp) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc handleExportManifest(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := json.Marshal(ExportManifestResponse{Manifest: getTestManifest()})\n\trw.Write(response)\n}\n\nfunc TestUpdateManifest(t *testing.T) {\n\thttp.HandleFunc(\"/apps.manifest.update\", handleUpdateManifest)\n\texpectedResponse := UpdateManifestResponse{AppId: \"app id\"}\n\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tmanif := getTestManifest()\n\tresp, err := api.UpdateManifest(&manif, \"token\", \"app id\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual(expectedResponse, *resp) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc handleUpdateManifest(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := json.Marshal(UpdateManifestResponse{AppId: \"app id\"})\n\trw.Write(response)\n}\n\nfunc TestValidateManifest(t *testing.T) {\n\thttp.HandleFunc(\"/apps.manifest.validate\", handleValidateManifest)\n\texpectedResponse := ManifestResponse{SlackResponse: SlackResponse{Ok: true}}\n\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tmanif := getTestManifest()\n\tresp, err := api.ValidateManifest(&manif, \"token\", \"app id\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual(expectedResponse, *resp) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc handleValidateManifest(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := json.Marshal(ManifestResponse{SlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc getTestManifest() Manifest {\n\treturn Manifest{\n\t\tDisplay: Display{\n\t\t\tName:        \"test\",\n\t\t\tDescription: \"this is a test\",\n\t\t},\n\t}\n}\n\nfunc getTestManifestResponse() *ManifestResponse {\n\treturn &ManifestResponse{\n\t\tSlackResponse: SlackResponse{\n\t\t\tOk: true,\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "messageID.go",
          "type": "blob",
          "size": 0.59765625,
          "content": "package slack\n\nimport \"sync/atomic\"\n\n// IDGenerator provides an interface for generating integer ID values.\ntype IDGenerator interface {\n\tNext() int\n}\n\n// NewSafeID returns a new instance of an IDGenerator which is safe for\n// concurrent use by multiple goroutines.\nfunc NewSafeID(startID int) IDGenerator {\n\treturn &safeID{\n\t\tnextID: int64(startID),\n\t}\n}\n\ntype safeID struct {\n\tnextID int64\n}\n\n// make sure safeID implements the IDGenerator interface.\nvar _ IDGenerator = (*safeID)(nil)\n\n// Next implements IDGenerator.Next.\nfunc (s *safeID) Next() int {\n\tid := atomic.AddInt64(&s.nextID, 1)\n\n\treturn int(id)\n}\n"
        },
        {
          "name": "messageID_test.go",
          "type": "blob",
          "size": 0.7958984375,
          "content": "package slack\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNewSafeID(t *testing.T) {\n\tidgen := NewSafeID(1)\n\tid1 := idgen.Next()\n\tid2 := idgen.Next()\n\tif id1 == id2 {\n\t\tt.Fatalf(\"id1 and id2 are same: id1: %d, id2: %d\", id1, id2)\n\t}\n\n\tidgen = NewSafeID(100)\n\tid100 := idgen.Next()\n\tid101 := idgen.Next()\n\tif id2 == id100 {\n\t\tt.Fatalf(\"except id2 and id100 not same: id2: %d, id101: %d\", id2, id100)\n\t}\n\tif id100 == id101 {\n\t\tt.Fatalf(\"id1 and id2 are same: id100: %d, id101: %d\", id100, id101)\n\t}\n}\n\nvar id int\n\nfunc BenchmarkNewSafeID(b *testing.B) {\n\tb.ReportAllocs()\n\n\tidgen := NewSafeID(1)\n\tfor i := 0; i < b.N; i++ {\n\t\tid = idgen.Next()\n\t}\n}\n\nfunc BenchmarkNewSafeIDParallel(b *testing.B) {\n\tb.ReportAllocs()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tidgen := NewSafeID(1)\n\t\t\tid = idgen.Next()\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "messages.go",
          "type": "blob",
          "size": 10.2568359375,
          "content": "package slack\n\n// OutgoingMessage is used for the realtime API, and seems incomplete.\ntype OutgoingMessage struct {\n\tID int `json:\"id\"`\n\t// channel ID\n\tChannel         string   `json:\"channel,omitempty\"`\n\tText            string   `json:\"text,omitempty\"`\n\tType            string   `json:\"type,omitempty\"`\n\tThreadTimestamp string   `json:\"thread_ts,omitempty\"`\n\tThreadBroadcast bool     `json:\"reply_broadcast,omitempty\"`\n\tIDs             []string `json:\"ids,omitempty\"`\n}\n\n// Message is an auxiliary type to allow us to have a message containing sub messages\ntype Message struct {\n\tMsg\n\tSubMessage      *Msg `json:\"message,omitempty\"`\n\tPreviousMessage *Msg `json:\"previous_message,omitempty\"`\n}\n\n// Msg SubTypes (https://api.slack.com/events/message)\nconst (\n\tMsgSubTypeBotMessage                = \"bot_message\"                 // [Events API, RTM] A message was posted by an integration\n\tMsgSubTypeMeMessage                 = \"me_message\"                  // [Events API, RTM] A /me message was sent\n\tMsgSubTypeMessageChanged            = \"message_changed\"             // [Events API, RTM] A message was changed\n\tMsgSubTypeMessageDeleted            = \"message_deleted\"             // [Events API, RTM] A message was deleted\n\tMsgSubTypeMessageReplied            = \"message_replied\"             // [Events API, RTM] A message thread received a reply\n\tMsgSubTypeReplyBroadcast            = \"reply_broadcast\"             // @Deprecated (No longer served) A message thread's reply was broadcast to a channel\n\tMsgSubTypeThreadBroadcast           = \"thread_broadcast\"            // [Events API, RTM] A message thread's reply was broadcast to a channel\n\tMsgSubTypeChannelJoin               = \"channel_join\"                // [Events API, RTM] A member joined a channel\n\tMsgSubTypeChannelLeave              = \"channel_leave\"               // [Events API, RTM] A member left a channel\n\tMsgSubTypeChannelTopic              = \"channel_topic\"               // [Events API, RTM] A channel topic was updated\n\tMsgSubTypeChannelPurpose            = \"channel_purpose\"             // [Events API, RTM] A channel purpose was updated\n\tMsgSubTypeChannelName               = \"channel_name\"                // [Events API, RTM] A channel was renamed\n\tMsgSubTypeChannelArchive            = \"channel_archive\"             // [Events API, RTM] A channel was archived\n\tMsgSubTypeChannelUnarchive          = \"channel_unarchive\"           // [Events API, RTM] A channel was unarchived\n\tMsgSubTypeGroupJoin                 = \"group_join\"                  // [RTM] A member joined a group\n\tMsgSubTypeGroupLeave                = \"group_leave\"                 // [RTM] A member left a group\n\tMsgSubTypeGroupTopic                = \"group_topic\"                 // [RTM] A group topic was updated\n\tMsgSubTypeGroupPurpose              = \"group_purpose\"               // [RTM] A group purpose was updated\n\tMsgSubTypeGroupName                 = \"group_name\"                  // [RTM] A group was renamed\n\tMsgSubTypeGroupArchive              = \"group_archive\"               // [RTM] A group was archived\n\tMsgSubTypeGroupUnarchive            = \"group_unarchive\"             // [RTM] A group was unarchived\n\tMsgSubTypeFileShare                 = \"file_share\"                  // [Events API, RTM] A file was shared into a channel\n\tMsgSubTypeFileComment               = \"file_comment\"                // [RTM] A comment was added to a file\n\tMsgSubTypeGileMention               = \"file_mention\"                // [RTM] A file was mentioned in a channel\n\tMsgSubTypePinnedItem                = \"pinned_item\"                 // [RTM] An item was pinned in a channel\n\tMsgSubTypeUnpinnedItem              = \"unpinned_item\"               // [RTM] An item was unpinned from a channel\n\tMsgSubTypeEkmAccessDenied           = \"ekm_access_denied\"           // [Events API, RTM] Message content redacted due to Enterprise Key Management (EKM)\n\tMsgSubTypeChannelPostingPermissions = \"channel_posting_permissions\" // [Events API, RTM] The posting permissions for a channel changed\n)\n\n// Msg contains information about a slack message\ntype Msg struct {\n\t// Basic Message\n\tClientMsgID     string       `json:\"client_msg_id,omitempty\"`\n\tType            string       `json:\"type,omitempty\"`\n\tChannel         string       `json:\"channel,omitempty\"`\n\tUser            string       `json:\"user,omitempty\"`\n\tText            string       `json:\"text,omitempty\"`\n\tTimestamp       string       `json:\"ts,omitempty\"`\n\tThreadTimestamp string       `json:\"thread_ts,omitempty\"`\n\tIsStarred       bool         `json:\"is_starred,omitempty\"`\n\tPinnedTo        []string     `json:\"pinned_to,omitempty\"`\n\tAttachments     []Attachment `json:\"attachments,omitempty\"`\n\tEdited          *Edited      `json:\"edited,omitempty\"`\n\tLastRead        string       `json:\"last_read,omitempty\"`\n\tSubscribed      bool         `json:\"subscribed,omitempty\"`\n\tUnreadCount     int          `json:\"unread_count,omitempty\"`\n\n\t// Message Subtypes\n\tSubType string `json:\"subtype,omitempty\"`\n\n\t// Hidden Subtypes\n\tHidden           bool   `json:\"hidden,omitempty\"`     // message_changed, message_deleted, unpinned_item\n\tDeletedTimestamp string `json:\"deleted_ts,omitempty\"` // message_deleted\n\tEventTimestamp   string `json:\"event_ts,omitempty\"`\n\n\t// bot_message (https://api.slack.com/events/message/bot_message)\n\tBotID      string      `json:\"bot_id,omitempty\"`\n\tUsername   string      `json:\"username,omitempty\"`\n\tIcons      *Icon       `json:\"icons,omitempty\"`\n\tBotProfile *BotProfile `json:\"bot_profile,omitempty\"`\n\n\t// channel_join, group_join\n\tInviter string `json:\"inviter,omitempty\"`\n\n\t// channel_topic, group_topic\n\tTopic string `json:\"topic,omitempty\"`\n\n\t// channel_purpose, group_purpose\n\tPurpose string `json:\"purpose,omitempty\"`\n\n\t// channel_name, group_name\n\tName    string `json:\"name,omitempty\"`\n\tOldName string `json:\"old_name,omitempty\"`\n\n\t// channel_archive, group_archive\n\tMembers []string `json:\"members,omitempty\"`\n\n\t// channels.replies, groups.replies, im.replies, mpim.replies\n\tReplyCount   int      `json:\"reply_count,omitempty\"`\n\tReplyUsers   []string `json:\"reply_users,omitempty\"`\n\tReplies      []Reply  `json:\"replies,omitempty\"`\n\tParentUserId string   `json:\"parent_user_id,omitempty\"`\n\tLatestReply  string   `json:\"latest_reply,omitempty\"`\n\n\t// file_share, file_comment, file_mention\n\tFiles []File `json:\"files,omitempty\"`\n\n\t// file_share\n\tUpload bool `json:\"upload,omitempty\"`\n\n\t// file_comment\n\tComment *Comment `json:\"comment,omitempty\"`\n\n\t// pinned_item\n\tItemType string `json:\"item_type,omitempty\"`\n\n\t// https://api.slack.com/rtm\n\tReplyTo int    `json:\"reply_to,omitempty\"`\n\tTeam    string `json:\"team,omitempty\"`\n\n\t// reactions\n\tReactions []ItemReaction `json:\"reactions,omitempty\"`\n\n\t// slash commands and interactive messages\n\tResponseType    string `json:\"response_type,omitempty\"`\n\tReplaceOriginal bool   `json:\"replace_original\"`\n\tDeleteOriginal  bool   `json:\"delete_original\"`\n\n\t// metadata\n\tMetadata SlackMetadata `json:\"metadata,omitempty\"`\n\n\t// Block type Message\n\tBlocks Blocks `json:\"blocks,omitempty\"`\n\t// permalink\n\tPermalink string `json:\"permalink,omitempty\"`\n}\n\nconst (\n\t// ResponseTypeInChannel in channel response for slash commands.\n\tResponseTypeInChannel = \"in_channel\"\n\t// ResponseTypeEphemeral ephemeral response for slash commands.\n\tResponseTypeEphemeral = \"ephemeral\"\n)\n\n// ScheduledMessage contains information about a slack scheduled message\ntype ScheduledMessage struct {\n\tID          string `json:\"id\"`\n\tChannel     string `json:\"channel_id\"`\n\tPostAt      int    `json:\"post_at\"`\n\tDateCreated int    `json:\"date_created\"`\n\tText        string `json:\"text\"`\n}\n\n// Icon is used for bot messages\ntype Icon struct {\n\tIconURL   string `json:\"icon_url,omitempty\"`\n\tIconEmoji string `json:\"icon_emoji,omitempty\"`\n}\n\n// BotProfile contains information about a bot\ntype BotProfile struct {\n\tAppID   string `json:\"app_id,omitempty\"`\n\tDeleted bool   `json:\"deleted,omitempty\"`\n\tIcons   *Icons `json:\"icons,omitempty\"`\n\tID      string `json:\"id,omitempty\"`\n\tName    string `json:\"name,omitempty\"`\n\tTeamID  string `json:\"team_id,omitempty\"`\n\tUpdated int64  `json:\"updated,omitempty\"`\n}\n\n// Edited indicates that a message has been edited.\ntype Edited struct {\n\tUser      string `json:\"user,omitempty\"`\n\tTimestamp string `json:\"ts,omitempty\"`\n}\n\n// Reply contains information about a reply for a thread\ntype Reply struct {\n\tUser      string `json:\"user,omitempty\"`\n\tTimestamp string `json:\"ts,omitempty\"`\n}\n\n// Event contains the event type\ntype Event struct {\n\tType string `json:\"type,omitempty\"`\n}\n\n// Ping contains information about a Ping Event\ntype Ping struct {\n\tID        int    `json:\"id\"`\n\tType      string `json:\"type\"`\n\tTimestamp int64  `json:\"timestamp\"`\n}\n\n// Pong contains information about a Pong Event\ntype Pong struct {\n\tType      string `json:\"type\"`\n\tReplyTo   int    `json:\"reply_to\"`\n\tTimestamp int64  `json:\"timestamp\"`\n}\n\n// NewOutgoingMessage prepares an OutgoingMessage that the user can\n// use to send a message. Use this function to properly set the\n// messageID.\nfunc (rtm *RTM) NewOutgoingMessage(text string, channelID string, options ...RTMsgOption) *OutgoingMessage {\n\tid := rtm.idGen.Next()\n\tmsg := OutgoingMessage{\n\t\tID:      id,\n\t\tType:    \"message\",\n\t\tChannel: channelID,\n\t\tText:    text,\n\t}\n\tfor _, option := range options {\n\t\toption(&msg)\n\t}\n\treturn &msg\n}\n\n// NewSubscribeUserPresence prepares an OutgoingMessage that the user can\n// use to subscribe presence events for the specified users.\nfunc (rtm *RTM) NewSubscribeUserPresence(ids []string) *OutgoingMessage {\n\treturn &OutgoingMessage{\n\t\tType: \"presence_sub\",\n\t\tIDs:  ids,\n\t}\n}\n\n// NewTypingMessage prepares an OutgoingMessage that the user can\n// use to send as a typing indicator. Use this function to properly set the\n// messageID.\nfunc (rtm *RTM) NewTypingMessage(channelID string) *OutgoingMessage {\n\tid := rtm.idGen.Next()\n\treturn &OutgoingMessage{\n\t\tID:      id,\n\t\tType:    \"typing\",\n\t\tChannel: channelID,\n\t}\n}\n\n// RTMsgOption allows configuration of various options available for sending an RTM message\ntype RTMsgOption func(*OutgoingMessage)\n\n// RTMsgOptionTS sets thead timestamp of an outgoing message in order to respond to a thread\nfunc RTMsgOptionTS(threadTimestamp string) RTMsgOption {\n\treturn func(msg *OutgoingMessage) {\n\t\tmsg.ThreadTimestamp = threadTimestamp\n\t}\n}\n\n// RTMsgOptionBroadcast sets broadcast reply to channel to \"true\"\nfunc RTMsgOptionBroadcast() RTMsgOption {\n\treturn func(msg *OutgoingMessage) {\n\t\tmsg.ThreadBroadcast = true\n\t}\n}\n"
        },
        {
          "name": "messages_test.go",
          "type": "blob",
          "size": 28.9677734375,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar simpleMessage = `{\n    \"type\": \"message\",\n    \"channel\": \"C2147483705\",\n    \"user\": \"U2147483697\",\n    \"text\": \"Hello world\",\n    \"ts\": \"1355517523.000005\"\n}`\n\nfunc unmarshalMessage(j string) (*Message, error) {\n\tmessage := &Message{}\n\tif err := json.Unmarshal([]byte(j), &message); err != nil {\n\t\treturn nil, err\n\t}\n\treturn message, nil\n}\n\nfunc TestSimpleMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(simpleMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, \"C2147483705\", message.Channel)\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.Equal(t, \"Hello world\", message.Text)\n\tassert.Equal(t, \"1355517523.000005\", message.Timestamp)\n}\n\nvar starredMessage = `{\n    \"text\": \"is testing\",\n    \"type\": \"message\",\n    \"subtype\": \"me_message\",\n    \"user\": \"U2147483697\",\n    \"ts\": \"1433314126.000003\",\n    \"is_starred\": true\n}`\n\nfunc TestStarredMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(starredMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"is testing\", message.Text)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeMeMessage, message.SubType)\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.Equal(t, \"1433314126.000003\", message.Timestamp)\n\tassert.Equal(t, true, message.IsStarred)\n}\n\nvar editedMessage = `{\n    \"type\": \"message\",\n    \"user\": \"U2147483697\",\n    \"text\": \"hello edited\",\n    \"edited\": {\n        \"user\": \"U2147483697\",\n        \"ts\": \"1433314416.000000\"\n    },\n    \"ts\": \"1433314408.000004\"\n}`\n\nfunc TestEditedMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(editedMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.Equal(t, \"hello edited\", message.Text)\n\tassert.NotNil(t, message.Edited)\n\tassert.Equal(t, \"U2147483697\", message.Edited.User)\n\tassert.Equal(t, \"1433314416.000000\", message.Edited.Timestamp)\n\tassert.Equal(t, \"1433314408.000004\", message.Timestamp)\n}\n\nvar uploadedFile = `{\n    \"type\": \"message\",\n    \"subtype\": \"file_share\",\n    \"text\": \"<@U2147483697|tester> uploaded a file: <https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test.txt|test.txt> and commented: test comment here\",\n    \"files\": [{\n        \"id\": \"abc\",\n        \"created\": 1433314757,\n        \"timestamp\": 1433314757,\n        \"name\": \"test.txt\",\n        \"title\": \"test.txt\",\n        \"mimetype\": \"text\\/plain\",\n        \"filetype\": \"text\",\n        \"pretty_type\": \"Plain Text\",\n        \"user\": \"U2147483697\",\n        \"editable\": true,\n        \"size\": 5,\n        \"mode\": \"snippet\",\n        \"is_external\": false,\n        \"external_type\": \"\",\n        \"is_public\": true,\n        \"public_url_shared\": false,\n        \"url\": \"https:\\/\\/slack-files.com\\/files-pub\\/abc-def-ghi\\/test.txt\",\n        \"url_download\": \"https:\\/\\/slack-files.com\\/files-pub\\/abc-def-ghi\\/download\\/test.txt\",\n        \"url_private\": \"https:\\/\\/files.slack.com\\/files-pri\\/abc-def\\/test.txt\",\n        \"url_private_download\": \"https:\\/\\/files.slack.com\\/files-pri\\/abc-def\\/download\\/test.txt\",\n        \"permalink\": \"https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test.txt\",\n        \"permalink_public\": \"https:\\/\\/slack-files.com\\/abc-def-ghi\",\n        \"edit_link\": \"https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test.txt\\/edit\",\n        \"preview\": \"test\\n\",\n        \"preview_highlight\": \"<div class=\\\"sssh-code\\\"><div class=\\\"sssh-line\\\"><pre>test<\\/pre><\\/div>\\n<div class=\\\"sssh-line\\\"><pre><\\/pre><\\/div>\\n<\\/div>\",\n        \"lines\": 2,\n        \"lines_more\": 0,\n        \"channels\": [\n            \"C2147483705\"\n        ],\n        \"groups\": [],\n        \"ims\": [],\n        \"comments_count\": 1,\n        \"initial_comment\": {\n            \"id\": \"Fc066YLGKH\",\n            \"created\": 1433314757,\n            \"timestamp\": 1433314757,\n            \"user\": \"U2147483697\",\n            \"comment\": \"test comment here\"\n        }\n    }],\n    \"user\": \"U2147483697\",\n    \"upload\": true,\n    \"ts\": \"1433314757.000006\"\n}`\n\nfunc TestUploadedFile(t *testing.T) {\n\tmessage, err := unmarshalMessage(uploadedFile)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeFileShare, message.SubType)\n\tassert.Equal(t, \"<@U2147483697|tester> uploaded a file: <https://test.slack.com/files/tester/abc/test.txt|test.txt> and commented: test comment here\", message.Text)\n\t// TODO: Assert File\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.True(t, message.Upload)\n\tassert.Equal(t, \"1433314757.000006\", message.Timestamp)\n}\n\nvar testPost = `{\n    \"type\": \"message\",\n    \"subtype\": \"file_share\",\n    \"text\": \"<@U2147483697|tester> shared a file: <https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test_post|test post>\",\n    \"files\": [{\n        \"id\": \"abc\",\n        \"created\": 1433315398,\n        \"timestamp\": 1433315398,\n        \"name\": \"test_post\",\n        \"title\": \"test post\",\n        \"mimetype\": \"text\\/plain\",\n        \"filetype\": \"post\",\n        \"pretty_type\": \"Post\",\n        \"user\": \"U2147483697\",\n        \"editable\": true,\n        \"size\": 14,\n        \"mode\": \"post\",\n        \"is_external\": false,\n        \"external_type\": \"\",\n        \"is_public\": true,\n        \"public_url_shared\": false,\n        \"url\": \"https:\\/\\/slack-files.com\\/files-pub\\/abc-def-ghi\\/test_post\",\n        \"url_download\": \"https:\\/\\/slack-files.com\\/files-pub\\/abc-def-ghi\\/download\\/test_post\",\n        \"url_private\": \"https:\\/\\/files.slack.com\\/files-pri\\/abc-def\\/test_post\",\n        \"url_private_download\": \"https:\\/\\/files.slack.com\\/files-pri\\/abc-def\\/download\\/test_post\",\n        \"permalink\": \"https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test_post\",\n        \"permalink_public\": \"https:\\/\\/slack-files.com\\/abc-def-ghi\",\n        \"edit_link\": \"https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test_post\\/edit\",\n        \"preview\": \"test post body\",\n        \"channels\": [\n            \"C2147483705\"\n        ],\n        \"groups\": [],\n        \"ims\": [],\n        \"comments_count\": 1\n    }],\n    \"user\": \"U2147483697\",\n    \"upload\": false,\n    \"ts\": \"1433315416.000008\"\n}`\n\nfunc TestPost(t *testing.T) {\n\tmessage, err := unmarshalMessage(testPost)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeFileShare, message.SubType)\n\tassert.Equal(t, \"<@U2147483697|tester> shared a file: <https://test.slack.com/files/tester/abc/test_post|test post>\", message.Text)\n\t// TODO: Assert File\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.False(t, message.Upload)\n\tassert.Equal(t, \"1433315416.000008\", message.Timestamp)\n}\n\nvar testComment = `{\n    \"type\": \"message\",\n    \"subtype\": \"file_comment\",\n    \"text\": \"<@U2147483697|tester> commented on <@U2147483697|tester>'s file <https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test_post|test post>: another comment\",\n    \"files\": [{\n        \"id\": \"abc\",\n        \"created\": 1433315398,\n        \"timestamp\": 1433315398,\n        \"name\": \"test_post\",\n        \"title\": \"test post\",\n        \"mimetype\": \"text\\/plain\",\n        \"filetype\": \"post\",\n        \"pretty_type\": \"Post\",\n        \"user\": \"U2147483697\",\n        \"editable\": true,\n        \"size\": 14,\n        \"mode\": \"post\",\n        \"is_external\": false,\n        \"external_type\": \"\",\n        \"is_public\": true,\n        \"public_url_shared\": false,\n        \"url\": \"https:\\/\\/slack-files.com\\/files-pub\\/abc-def-ghi\\/test_post\",\n        \"url_download\": \"https:\\/\\/slack-files.com\\/files-pub\\/abc-def-ghi\\/download\\/test_post\",\n        \"url_private\": \"https:\\/\\/files.slack.com\\/files-pri\\/abc-def\\/test_post\",\n        \"url_private_download\": \"https:\\/\\/files.slack.com\\/files-pri\\/abc-def\\/download\\/test_post\",\n        \"permalink\": \"https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test_post\",\n        \"permalink_public\": \"https:\\/\\/slack-files.com\\/abc-def-ghi\",\n        \"edit_link\": \"https:\\/\\/test.slack.com\\/files\\/tester\\/abc\\/test_post\\/edit\",\n        \"preview\": \"test post body\",\n        \"channels\": [\n            \"C2147483705\"\n        ],\n        \"groups\": [],\n        \"ims\": [],\n        \"comments_count\": 2\n    }],\n    \"comment\": {\n        \"id\": \"xyz\",\n        \"created\": 1433316360,\n        \"timestamp\": 1433316360,\n        \"user\": \"U2147483697\",\n        \"comment\": \"another comment\"\n    },\n    \"ts\": \"1433316360.000009\"\n}`\n\nfunc TestComment(t *testing.T) {\n\tmessage, err := unmarshalMessage(testComment)\n\tfmt.Println(err)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeFileComment, message.SubType)\n\tassert.Equal(t, \"<@U2147483697|tester> commented on <@U2147483697|tester>'s file <https://test.slack.com/files/tester/abc/test_post|test post>: another comment\", message.Text)\n\t// TODO: Assert File\n\t// TODO: Assert Comment\n\tassert.Equal(t, \"1433316360.000009\", message.Timestamp)\n}\n\nvar botMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"bot_message\",\n    \"text\": \"Pushing is the answer\",\n    \"suppress_notification\": false,\n    \"bot_id\": \"BB12033\",\n    \"username\": \"github\",\n    \"icons\": {},\n    \"team\": \"T01A9CUMPQA\",\n    \"bot_profile\": {\n        \"id\": \"BB12033\",\n        \"deleted\": false,\n        \"name\": \"github\",\n        \"updated\": 1599574335,\n        \"app_id\": \"A6DB2SWUW\",\n        \"icons\": {\n            \"image_36\": \"https://slack-files2.s3-us-west-2.amazonaws.com/avatars/2017-10-24/261138718469_ada58732a18da119678d_36.png\",\n            \"image_48\": \"https://slack-files2.s3-us-west-2.amazonaws.com/avatars/2017-10-24/261138718469_ada58732a18da119678d_48.png\",\n            \"image_72\": \"https://slack-files2.s3-us-west-2.amazonaws.com/avatars/2017-10-24/261138718469_ada58732a18da119678d_72.png\"\n        },\n        \"team_id\": \"T01A9CUMPQA\"\n    },\n    \"blocks\": [],\n    \"channel\": \"C01AZ844Z32\",\n    \"event_ts\": \"1358877455.000010\",\n    \"ts\": \"1358877455.000010\"\n}`\n\nfunc TestBotMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(botMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeBotMessage, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"Pushing is the answer\", message.Text)\n\tassert.Equal(t, \"BB12033\", message.BotID)\n\tassert.Equal(t, \"github\", message.Username)\n\tassert.NotNil(t, message.Icons)\n\tassert.Empty(t, message.Icons.IconURL)\n\tassert.Empty(t, message.Icons.IconEmoji)\n\tassert.Equal(t, \"github\", message.BotProfile.Name)\n\tassert.Equal(t, \"BB12033\", message.BotProfile.ID)\n\tassert.Equal(t, false, message.BotProfile.Deleted)\n\tassert.Equal(t, int64(1599574335), message.BotProfile.Updated)\n\tassert.Equal(t, \"A6DB2SWUW\", message.BotProfile.AppID)\n\tassert.Equal(t, \"https://slack-files2.s3-us-west-2.amazonaws.com/avatars/2017-10-24/261138718469_ada58732a18da119678d_36.png\", message.BotProfile.Icons.Image36)\n\tassert.Equal(t, \"https://slack-files2.s3-us-west-2.amazonaws.com/avatars/2017-10-24/261138718469_ada58732a18da119678d_48.png\", message.BotProfile.Icons.Image48)\n\tassert.Equal(t, \"https://slack-files2.s3-us-west-2.amazonaws.com/avatars/2017-10-24/261138718469_ada58732a18da119678d_72.png\", message.BotProfile.Icons.Image72)\n\tassert.Equal(t, \"T01A9CUMPQA\", message.BotProfile.TeamID)\n\tassert.Equal(t, \"C01AZ844Z32\", message.Channel)\n\tassert.Equal(t, \"1358877455.000010\", message.EventTimestamp)\n}\n\nvar meMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"me_message\",\n    \"channel\": \"C2147483705\",\n    \"user\": \"U2147483697\",\n    \"text\": \"is doing that thing\",\n    \"ts\": \"1355517523.000005\"\n}`\n\nfunc TestMeMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(meMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeMeMessage, message.SubType)\n\tassert.Equal(t, \"C2147483705\", message.Channel)\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.Equal(t, \"is doing that thing\", message.Text)\n\tassert.Equal(t, \"1355517523.000005\", message.Timestamp)\n}\n\nvar messageChangedMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"message_changed\",\n    \"hidden\": true,\n    \"channel\": \"C2147483705\",\n    \"ts\": \"1358878755.000001\",\n    \"message\": {\n        \"type\": \"message\",\n        \"user\": \"U2147483697\",\n        \"text\": \"Hello, world!\",\n        \"ts\": \"1355517523.000005\",\n        \"edited\": {\n            \"user\": \"U2147483697\",\n            \"ts\": \"1358878755.000001\"\n        }\n    }\n}`\n\nfunc TestMessageChangedMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(messageChangedMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeMessageChanged, message.SubType)\n\tassert.True(t, message.Hidden)\n\tassert.Equal(t, \"C2147483705\", message.Channel)\n\tassert.NotNil(t, message.SubMessage)\n\tassert.Equal(t, \"message\", message.SubMessage.Type)\n\tassert.Equal(t, \"U2147483697\", message.SubMessage.User)\n\tassert.Equal(t, \"Hello, world!\", message.SubMessage.Text)\n\tassert.Equal(t, \"1355517523.000005\", message.SubMessage.Timestamp)\n\tassert.NotNil(t, message.SubMessage.Edited)\n\tassert.Equal(t, \"U2147483697\", message.SubMessage.Edited.User)\n\tassert.Equal(t, \"1358878755.000001\", message.SubMessage.Edited.Timestamp)\n\tassert.Equal(t, \"1358878755.000001\", message.Timestamp)\n}\n\nvar messageDeletedMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"message_deleted\",\n    \"hidden\": true,\n    \"channel\": \"C2147483705\",\n    \"ts\": \"1358878755.000001\",\n    \"deleted_ts\": \"1358878749.000002\"\n}`\n\nfunc TestMessageDeletedMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(messageDeletedMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeMessageDeleted, message.SubType)\n\tassert.True(t, message.Hidden)\n\tassert.Equal(t, \"C2147483705\", message.Channel)\n\tassert.Equal(t, \"1358878755.000001\", message.Timestamp)\n\tassert.Equal(t, \"1358878749.000002\", message.DeletedTimestamp)\n}\n\nvar channelJoinMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_join\",\n    \"ts\": \"1358877458.000011\",\n    \"user\": \"U2147483828\",\n    \"text\": \"<@U2147483828|cal> has joined the channel\"\n}`\n\nfunc TestChannelJoinMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelJoinMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelJoin, message.SubType)\n\tassert.Equal(t, \"1358877458.000011\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"<@U2147483828|cal> has joined the channel\", message.Text)\n}\n\nvar channelJoinInvitedMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_join\",\n    \"ts\": \"1358877458.000011\",\n    \"user\": \"U2147483828\",\n    \"text\": \"<@U2147483828|cal> has joined the channel\",\n\t\t\"inviter\": \"U2147483829\"\n}`\n\nfunc TestChannelJoinInvitedMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelJoinInvitedMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelJoin, message.SubType)\n\tassert.Equal(t, \"1358877458.000011\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"<@U2147483828|cal> has joined the channel\", message.Text)\n\tassert.Equal(t, \"U2147483829\", message.Inviter)\n}\n\nvar channelLeaveMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_leave\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"text\": \"<@U2147483828|cal> has left the channel\"\n}`\n\nfunc TestChannelLeaveMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelLeaveMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelLeave, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"<@U2147483828|cal> has left the channel\", message.Text)\n}\n\nvar channelTopicMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_topic\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"topic\": \"hello world\",\n    \"text\": \"<@U2147483828|cal> set the channel topic: hello world\"\n}`\n\nfunc TestChannelTopicMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelTopicMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelTopic, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"hello world\", message.Topic)\n\tassert.Equal(t, \"<@U2147483828|cal> set the channel topic: hello world\", message.Text)\n}\n\nvar channelPurposeMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_purpose\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"purpose\": \"whatever\",\n    \"text\": \"<@U2147483828|cal> set the channel purpose: whatever\"\n}`\n\nfunc TestChannelPurposeMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelPurposeMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelPurpose, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"whatever\", message.Purpose)\n\tassert.Equal(t, \"<@U2147483828|cal> set the channel purpose: whatever\", message.Text)\n}\n\nvar channelNameMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_name\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"old_name\": \"random\",\n    \"name\": \"watercooler\",\n    \"text\": \"<@U2147483828|cal> has renamed the channel from \\\"random\\\" to \\\"watercooler\\\"\"\n}`\n\nfunc TestChannelNameMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelNameMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelName, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"random\", message.OldName)\n\tassert.Equal(t, \"watercooler\", message.Name)\n\tassert.Equal(t, \"<@U2147483828|cal> has renamed the channel from \\\"random\\\" to \\\"watercooler\\\"\", message.Text)\n}\n\nvar channelArchiveMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_archive\",\n    \"ts\": \"1361482916.000003\",\n    \"text\": \"<U1234|@cal> archived the channel\",\n    \"user\": \"U1234\",\n    \"members\": [\"U1234\", \"U5678\"]\n}`\n\nfunc TestChannelArchiveMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelArchiveMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelArchive, message.SubType)\n\tassert.Equal(t, \"1361482916.000003\", message.Timestamp)\n\tassert.Equal(t, \"<U1234|@cal> archived the channel\", message.Text)\n\tassert.Equal(t, \"U1234\", message.User)\n\tassert.NotNil(t, message.Members)\n\tassert.Equal(t, 2, len(message.Members))\n}\n\nvar channelUnarchiveMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"channel_unarchive\",\n    \"ts\": \"1361482916.000003\",\n    \"text\": \"<U1234|@cal> un-archived the channel\",\n    \"user\": \"U1234\"\n}`\n\nfunc TestChannelUnarchiveMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelUnarchiveMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeChannelUnarchive, message.SubType)\n\tassert.Equal(t, \"1361482916.000003\", message.Timestamp)\n\tassert.Equal(t, \"<U1234|@cal> un-archived the channel\", message.Text)\n\tassert.Equal(t, \"U1234\", message.User)\n}\n\nvar channelRepliesParentMessage = `{\n    \"type\": \"message\",\n    \"user\": \"U1234\",\n    \"text\": \"test\",\n    \"thread_ts\": \"1493305433.915644\",\n    \"reply_count\": 2,\n    \"replies\": [\n        {\n            \"user\": \"U5678\",\n            \"ts\": \"1493305444.920992\"\n        },\n        {\n            \"user\": \"U9012\",\n            \"ts\": \"1493305894.133936\"\n        }\n    ],\n    \"subscribed\": true,\n    \"last_read\": \"1493305894.133936\",\n    \"unread_count\": 0,\n    \"ts\": \"1493305433.915644\"\n}`\n\nfunc TestChannelRepliesParentMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelRepliesParentMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, \"U1234\", message.User)\n\tassert.Equal(t, \"test\", message.Text)\n\tassert.Equal(t, \"1493305433.915644\", message.ThreadTimestamp)\n\tassert.Equal(t, 2, message.ReplyCount)\n\tassert.Equal(t, \"U5678\", message.Replies[0].User)\n\tassert.Equal(t, \"1493305444.920992\", message.Replies[0].Timestamp)\n\tassert.Equal(t, \"U9012\", message.Replies[1].User)\n\tassert.Equal(t, \"1493305894.133936\", message.Replies[1].Timestamp)\n\tassert.Equal(t, \"1493305433.915644\", message.Timestamp)\n}\n\nvar channelRepliesChildMessage = `{\n    \"type\": \"message\",\n    \"user\": \"U5678\",\n    \"text\": \"foo\",\n    \"thread_ts\": \"1493305433.915644\",\n    \"parent_user_id\": \"U1234\",\n    \"ts\": \"1493305444.920992\"\n}`\n\nfunc TestChannelRepliesChildMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(channelRepliesChildMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, \"U5678\", message.User)\n\tassert.Equal(t, \"foo\", message.Text)\n\tassert.Equal(t, \"1493305433.915644\", message.ThreadTimestamp)\n\tassert.Equal(t, \"U1234\", message.ParentUserId)\n\tassert.Equal(t, \"1493305444.920992\", message.Timestamp)\n}\n\nvar groupJoinMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_join\",\n    \"ts\": \"1358877458.000011\",\n    \"user\": \"U2147483828\",\n    \"text\": \"<@U2147483828|cal> has joined the group\"\n}`\n\nfunc TestGroupJoinMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupJoinMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupJoin, message.SubType)\n\tassert.Equal(t, \"1358877458.000011\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"<@U2147483828|cal> has joined the group\", message.Text)\n}\n\nvar groupJoinInvitedMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_join\",\n    \"ts\": \"1358877458.000011\",\n    \"user\": \"U2147483828\",\n    \"text\": \"<@U2147483828|cal> has joined the group\",\n\t\t\"inviter\": \"U2147483829\"\n}`\n\nfunc TestGroupJoinInvitedMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupJoinInvitedMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupJoin, message.SubType)\n\tassert.Equal(t, \"1358877458.000011\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"<@U2147483828|cal> has joined the group\", message.Text)\n\tassert.Equal(t, \"U2147483829\", message.Inviter)\n}\n\nvar groupLeaveMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_leave\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"text\": \"<@U2147483828|cal> has left the group\"\n}`\n\nfunc TestGroupLeaveMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupLeaveMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupLeave, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"<@U2147483828|cal> has left the group\", message.Text)\n}\n\nvar groupTopicMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_topic\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"topic\": \"hello world\",\n    \"text\": \"<@U2147483828|cal> set the group topic: hello world\"\n}`\n\nfunc TestGroupTopicMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupTopicMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupTopic, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"hello world\", message.Topic)\n\tassert.Equal(t, \"<@U2147483828|cal> set the group topic: hello world\", message.Text)\n}\n\nvar groupPurposeMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_purpose\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"purpose\": \"whatever\",\n    \"text\": \"<@U2147483828|cal> set the group purpose: whatever\"\n}`\n\nfunc TestGroupPurposeMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupPurposeMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupPurpose, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"whatever\", message.Purpose)\n\tassert.Equal(t, \"<@U2147483828|cal> set the group purpose: whatever\", message.Text)\n}\n\nvar groupNameMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_name\",\n    \"ts\": \"1358877455.000010\",\n    \"user\": \"U2147483828\",\n    \"old_name\": \"random\",\n    \"name\": \"watercooler\",\n    \"text\": \"<@U2147483828|cal> has renamed the group from \\\"random\\\" to \\\"watercooler\\\"\"\n}`\n\nfunc TestGroupNameMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupNameMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupName, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"U2147483828\", message.User)\n\tassert.Equal(t, \"random\", message.OldName)\n\tassert.Equal(t, \"watercooler\", message.Name)\n\tassert.Equal(t, \"<@U2147483828|cal> has renamed the group from \\\"random\\\" to \\\"watercooler\\\"\", message.Text)\n}\n\nvar groupArchiveMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_archive\",\n    \"ts\": \"1361482916.000003\",\n    \"text\": \"<U1234|@cal> archived the group\",\n    \"user\": \"U1234\",\n    \"members\": [\"U1234\", \"U5678\"]\n}`\n\nfunc TestGroupArchiveMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupArchiveMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupArchive, message.SubType)\n\tassert.Equal(t, \"1361482916.000003\", message.Timestamp)\n\tassert.Equal(t, \"<U1234|@cal> archived the group\", message.Text)\n\tassert.Equal(t, \"U1234\", message.User)\n\tassert.NotNil(t, message.Members)\n\tassert.Equal(t, 2, len(message.Members))\n}\n\nvar groupUnarchiveMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"group_unarchive\",\n    \"ts\": \"1361482916.000003\",\n    \"text\": \"<U1234|@cal> un-archived the group\",\n    \"user\": \"U1234\"\n}`\n\nfunc TestGroupUnarchiveMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(groupUnarchiveMessage)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeGroupUnarchive, message.SubType)\n\tassert.Equal(t, \"1361482916.000003\", message.Timestamp)\n\tassert.Equal(t, \"<U1234|@cal> un-archived the group\", message.Text)\n\tassert.Equal(t, \"U1234\", message.User)\n}\n\nvar fileShareMessage = `{\n    \"type\": \"message\",\n    \"subtype\": \"file_share\",\n    \"ts\": \"1358877455.000010\",\n    \"text\": \"<@cal> uploaded a file: <https:...7.png|7.png>\",\n    \"files\": [{\n        \"id\" : \"F2147483862\",\n        \"created\" : 1356032811,\n        \"timestamp\" : 1356032811,\n        \"name\" : \"file.htm\",\n        \"title\" : \"My HTML file\",\n        \"mimetype\" : \"text\\/plain\",\n        \"filetype\" : \"text\",\n        \"pretty_type\": \"Text\",\n        \"user\" : \"U2147483697\",\n        \"mode\" : \"hosted\",\n        \"editable\" : true,\n        \"is_external\": false,\n        \"external_type\": \"\",\n        \"size\" : 12345,\n        \"url\": \"https:\\/\\/slack-files.com\\/files-pub\\/T024BE7LD-F024BERPE-09acb6\\/1.png\",\n        \"url_download\": \"https:\\/\\/slack-files.com\\/files-pub\\/T024BE7LD-F024BERPE-09acb6\\/download\\/1.png\",\n        \"url_private\": \"https:\\/\\/slack.com\\/files-pri\\/T024BE7LD-F024BERPE\\/1.png\",\n        \"url_private_download\": \"https:\\/\\/slack.com\\/files-pri\\/T024BE7LD-F024BERPE\\/download\\/1.png\",\n        \"thumb_64\": \"https:\\/\\/slack-files.com\\/files-tmb\\/T024BE7LD-F024BERPE-c66246\\/1_64.png\",\n        \"thumb_80\": \"https:\\/\\/slack-files.com\\/files-tmb\\/T024BE7LD-F024BERPE-c66246\\/1_80.png\",\n        \"thumb_360\": \"https:\\/\\/slack-files.com\\/files-tmb\\/T024BE7LD-F024BERPE-c66246\\/1_360.png\",\n        \"thumb_360_gif\": \"https:\\/\\/slack-files.com\\/files-tmb\\/T024BE7LD-F024BERPE-c66246\\/1_360.gif\",\n        \"thumb_360_w\": 100,\n        \"thumb_360_h\": 100,\n        \"permalink\" : \"https:\\/\\/tinyspeck.slack.com\\/files\\/cal\\/F024BERPE\\/1.png\",\n        \"edit_link\" : \"https:\\/\\/tinyspeck.slack.com\\/files\\/cal\\/F024BERPE\\/1.png/edit\",\n        \"preview\" : \"&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\n&lt;meta charset='utf-8'&gt;\",\n        \"preview_highlight\" : \"&lt;div class=\\\"sssh-code\\\"&gt;&lt;div class=\\\"sssh-line\\\"&gt;&lt;pre&gt;&lt;!DOCTYPE html...\",\n        \"lines\" : 123,\n        \"lines_more\": 118,\n        \"is_public\": true,\n        \"public_url_shared\": false,\n        \"channels\": [\"C024BE7LT\"],\n        \"groups\": [\"G12345\"],\n        \"ims\": [\"D12345\"],\n        \"initial_comment\": {},\n        \"num_stars\": 7,\n        \"is_starred\": true\n    }],\n    \"user\": \"U2147483697\",\n    \"upload\": true\n}`\n\nfunc TestFileShareMessage(t *testing.T) {\n\tmessage, err := unmarshalMessage(fileShareMessage)\n\tfmt.Println(err)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, message)\n\tassert.Equal(t, \"message\", message.Type)\n\tassert.Equal(t, MsgSubTypeFileShare, message.SubType)\n\tassert.Equal(t, \"1358877455.000010\", message.Timestamp)\n\tassert.Equal(t, \"<@cal> uploaded a file: <https:...7.png|7.png>\", message.Text)\n\tassert.Equal(t, \"U2147483697\", message.User)\n\tassert.True(t, message.Upload)\n\tassert.NotNil(t, message.Files[0])\n}\n"
        },
        {
          "name": "metadata.go",
          "type": "blob",
          "size": 0.21484375,
          "content": "package slack\n\n// SlackMetadata https://api.slack.com/reference/metadata\ntype SlackMetadata struct {\n\tEventType    string                 `json:\"event_type\"`\n\tEventPayload map[string]interface{} `json:\"event_payload\"`\n}\n"
        },
        {
          "name": "misc.go",
          "type": "blob",
          "size": 8.80078125,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// SlackResponse handles parsing out errors from the web api.\ntype SlackResponse struct {\n\tOk               bool             `json:\"ok\"`\n\tError            string           `json:\"error\"`\n\tResponseMetadata ResponseMetadata `json:\"response_metadata\"`\n}\n\nfunc (t SlackResponse) Err() error {\n\tif t.Ok {\n\t\treturn nil\n\t}\n\n\t// handle pure text based responses like chat.post\n\t// which while they have a slack response in their data structure\n\t// it doesn't actually get set during parsing.\n\tif strings.TrimSpace(t.Error) == \"\" {\n\t\treturn nil\n\t}\n\n\treturn SlackErrorResponse{Err: t.Error, ResponseMetadata: t.ResponseMetadata}\n}\n\n// SlackErrorResponse brings along the metadata of errors returned by the Slack API.\ntype SlackErrorResponse struct {\n\tErr              string\n\tResponseMetadata ResponseMetadata\n}\n\nfunc (r SlackErrorResponse) Error() string { return r.Err }\n\n// RateLimitedError represents the rate limit response from slack\ntype RateLimitedError struct {\n\tRetryAfter time.Duration\n}\n\nfunc (e *RateLimitedError) Error() string {\n\treturn fmt.Sprintf(\"slack rate limit exceeded, retry after %s\", e.RetryAfter)\n}\n\nfunc (e *RateLimitedError) Retryable() bool {\n\treturn true\n}\n\nfunc fileUploadReq(ctx context.Context, path string, r io.Reader) (*http.Request, error) {\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, path, r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn req, nil\n}\n\nfunc downloadFile(ctx context.Context, client httpClient, token string, downloadURL string, writer io.Writer, d Debug) error {\n\tif downloadURL == \"\" {\n\t\treturn fmt.Errorf(\"received empty download URL\")\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, downloadURL, &bytes.Buffer{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar bearer = \"Bearer \" + token\n\treq.Header.Add(\"Authorization\", bearer)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\terr = checkStatusCode(resp, d)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(writer, resp.Body)\n\n\treturn err\n}\n\nfunc formReq(ctx context.Context, endpoint string, values url.Values) (req *http.Request, err error) {\n\tif req, err = http.NewRequestWithContext(ctx, http.MethodPost, endpoint, strings.NewReader(values.Encode())); err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treturn req, nil\n}\n\nfunc jsonReq(ctx context.Context, endpoint string, body interface{}) (req *http.Request, err error) {\n\tbuffer := bytes.NewBuffer([]byte{})\n\tif err = json.NewEncoder(buffer).Encode(body); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif req, err = http.NewRequestWithContext(ctx, http.MethodPost, endpoint, buffer); err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\treturn req, nil\n}\n\nfunc parseResponseBody(body io.ReadCloser, intf interface{}, d Debug) error {\n\tresponse, err := io.ReadAll(body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.Debug() {\n\t\td.Debugln(\"parseResponseBody\", string(response))\n\t}\n\n\treturn json.Unmarshal(response, intf)\n}\n\nfunc postLocalWithMultipartResponse(ctx context.Context, client httpClient, method, fpath, fieldname, token string, values url.Values, intf interface{}, d Debug) error {\n\tfullpath, err := filepath.Abs(fpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfile, err := os.Open(fullpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treturn postWithMultipartResponse(ctx, client, method, filepath.Base(fpath), fieldname, token, values, file, intf, d)\n}\n\nfunc postWithMultipartResponse(ctx context.Context, client httpClient, path, name, fieldname, token string, values url.Values, r io.Reader, intf interface{}, d Debug) error {\n\tpipeReader, pipeWriter := io.Pipe()\n\twr := multipart.NewWriter(pipeWriter)\n\n\terrc := make(chan error)\n\tgo func() {\n\t\tdefer pipeWriter.Close()\n\t\tdefer wr.Close()\n\t\terr := createFormFields(wr, values)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\treturn\n\t\t}\n\t\tioWriter, err := wr.CreateFormFile(fieldname, name)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\treturn\n\t\t}\n\t\t_, err = io.Copy(ioWriter, r)\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t\treturn\n\t\t}\n\t\tif err = wr.Close(); err != nil {\n\t\t\terrc <- err\n\t\t\treturn\n\t\t}\n\t}()\n\n\treq, err := fileUploadReq(ctx, path, pipeReader)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Add(\"Content-Type\", wr.FormDataContentType())\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\tresp, err := client.Do(req)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\terr = checkStatusCode(resp, d)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tselect {\n\tcase err = <-errc:\n\t\treturn err\n\tdefault:\n\t\treturn newJSONParser(intf)(resp)\n\t}\n}\n\nfunc createFormFields(mw *multipart.Writer, values url.Values) error {\n\tfor key, value := range values {\n\t\twriter, err := mw.CreateFormField(key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = writer.Write([]byte(value[0]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc doPost(ctx context.Context, client httpClient, req *http.Request, parser responseParser, d Debug) error {\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\terr = checkStatusCode(resp, d)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn parser(resp)\n}\n\n// post JSON.\nfunc postJSON(ctx context.Context, client httpClient, endpoint, token string, json []byte, intf interface{}, d Debug) error {\n\treqBody := bytes.NewBuffer(json)\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, reqBody)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\n\treturn doPost(ctx, client, req, newJSONParser(intf), d)\n}\n\n// post a url encoded form.\nfunc postForm(ctx context.Context, client httpClient, endpoint string, values url.Values, intf interface{}, d Debug) error {\n\treqBody := strings.NewReader(values.Encode())\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, reqBody)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treturn doPost(ctx, client, req, newJSONParser(intf), d)\n}\n\nfunc getResource(ctx context.Context, client httpClient, endpoint, token string, values url.Values, intf interface{}, d Debug) error {\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\n\treq.URL.RawQuery = values.Encode()\n\n\treturn doPost(ctx, client, req, newJSONParser(intf), d)\n}\n\nfunc parseAdminResponse(ctx context.Context, client httpClient, method string, teamName string, values url.Values, intf interface{}, d Debug) error {\n\tendpoint := fmt.Sprintf(WEBAPIURLFormat, teamName, method, time.Now().Unix())\n\treturn postForm(ctx, client, endpoint, values, intf, d)\n}\n\nfunc logResponse(resp *http.Response, d Debug) error {\n\tif d.Debug() {\n\t\ttext, err := httputil.DumpResponse(resp, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td.Debugln(string(text))\n\t}\n\n\treturn nil\n}\n\nfunc okJSONHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(SlackResponse{\n\t\tOk: true,\n\t})\n\trw.Write(response)\n}\n\n// timerReset safely reset a timer, see time.Timer.Reset for details.\nfunc timerReset(t *time.Timer, d time.Duration) {\n\tif !t.Stop() {\n\t\t<-t.C\n\t}\n\tt.Reset(d)\n}\n\nfunc checkStatusCode(resp *http.Response, d Debug) error {\n\tif resp.StatusCode == http.StatusTooManyRequests {\n\t\tretry, err := strconv.ParseInt(resp.Header.Get(\"Retry-After\"), 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn &RateLimitedError{time.Duration(retry) * time.Second}\n\t}\n\n\t// Slack seems to send an HTML body along with 5xx error codes. Don't parse it.\n\tif resp.StatusCode != http.StatusOK {\n\t\tlogResponse(resp, d)\n\t\treturn StatusCodeError{Code: resp.StatusCode, Status: resp.Status}\n\t}\n\n\treturn nil\n}\n\ntype responseParser func(*http.Response) error\n\nfunc newJSONParser(dst interface{}) responseParser {\n\treturn func(resp *http.Response) error {\n\t\tif dst == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn json.NewDecoder(resp.Body).Decode(dst)\n\t}\n}\n\nfunc newTextParser(dst interface{}) responseParser {\n\treturn func(resp *http.Response) error {\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !bytes.Equal(b, []byte(\"ok\")) {\n\t\t\treturn errors.New(string(b))\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\nfunc newContentTypeParser(dst interface{}) responseParser {\n\treturn func(req *http.Response) (err error) {\n\t\tvar (\n\t\t\tctype string\n\t\t)\n\n\t\tif ctype, _, err = mime.ParseMediaType(req.Header.Get(\"Content-Type\")); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch ctype {\n\t\tcase \"application/json\":\n\t\t\treturn newJSONParser(dst)(req)\n\t\tdefault:\n\t\t\treturn newTextParser(dst)(req)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "misc_test.go",
          "type": "blob",
          "size": 2.6376953125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/slack-go/slack/slackutilsx\"\n)\n\nvar (\n\tparseResponseOnce sync.Once\n)\n\nfunc parseResponseHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\ttoken := r.FormValue(\"token\")\n\tlog.Println(token)\n\tif token == \"\" {\n\t\trw.Write([]byte(`{\"ok\":false,\"error\":\"not_authed\"}`))\n\t\treturn\n\t}\n\tif token != validToken {\n\t\trw.Write([]byte(`{\"ok\":false,\"error\":\"invalid_auth\"}`))\n\t\treturn\n\t}\n\tresponse := []byte(`{\"ok\": true}`)\n\trw.Write(response)\n}\n\nfunc setParseResponseHandler() {\n\thttp.HandleFunc(\"/parseResponse\", parseResponseHandler)\n}\n\nfunc TestParseResponse(t *testing.T) {\n\tparseResponseOnce.Do(setParseResponseHandler)\n\tonce.Do(startServer)\n\tAPIURL := \"http://\" + serverAddr + \"/\"\n\tvalues := url.Values{\n\t\t\"token\": {validToken},\n\t}\n\n\tresponsePartial := &SlackResponse{}\n\terr := postForm(context.Background(), http.DefaultClient, APIURL+\"parseResponse\", values, responsePartial, discard{})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestParseResponseNoToken(t *testing.T) {\n\tparseResponseOnce.Do(setParseResponseHandler)\n\tonce.Do(startServer)\n\tAPIURL := \"http://\" + serverAddr + \"/\"\n\tvalues := url.Values{}\n\n\tresponsePartial := &SlackResponse{}\n\terr := postForm(context.Background(), http.DefaultClient, APIURL+\"parseResponse\", values, responsePartial, discard{})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif responsePartial.Ok {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t} else if responsePartial.Error != \"not_authed\" {\n\t\tt.Errorf(\"got %v; want %v\", responsePartial.Error, \"not_authed\")\n\t}\n}\n\nfunc TestParseResponseInvalidToken(t *testing.T) {\n\tparseResponseOnce.Do(setParseResponseHandler)\n\tonce.Do(startServer)\n\tAPIURL := \"http://\" + serverAddr + \"/\"\n\tvalues := url.Values{\n\t\t\"token\": {\"whatever\"},\n\t}\n\tresponsePartial := &SlackResponse{}\n\terr := postForm(context.Background(), http.DefaultClient, APIURL+\"parseResponse\", values, responsePartial, discard{})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif responsePartial.Ok {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t} else if responsePartial.Error != \"invalid_auth\" {\n\t\tt.Errorf(\"got %v; want %v\", responsePartial.Error, \"invalid_auth\")\n\t}\n}\n\nfunc TestRetryable(t *testing.T) {\n\tfor _, e := range []error{\n\t\t&RateLimitedError{},\n\t\tStatusCodeError{Code: http.StatusInternalServerError},\n\t\tStatusCodeError{Code: http.StatusTooManyRequests},\n\t} {\n\t\tr, ok := e.(slackutilsx.Retryable)\n\t\tif !ok {\n\t\t\tt.Errorf(\"expected %#v to implement Retryable\", e)\n\t\t}\n\t\tif !r.Retryable() {\n\t\t\tt.Errorf(\"expected %#v to be Retryable\", e)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "oauth.go",
          "type": "blob",
          "size": 8.50390625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\n// OAuthResponseIncomingWebhook ...\ntype OAuthResponseIncomingWebhook struct {\n\tURL              string `json:\"url\"`\n\tChannel          string `json:\"channel\"`\n\tChannelID        string `json:\"channel_id,omitempty\"`\n\tConfigurationURL string `json:\"configuration_url\"`\n}\n\n// OAuthResponseBot ...\ntype OAuthResponseBot struct {\n\tBotUserID      string `json:\"bot_user_id\"`\n\tBotAccessToken string `json:\"bot_access_token\"`\n}\n\n// OAuthResponse ...\ntype OAuthResponse struct {\n\tAccessToken     string                       `json:\"access_token\"`\n\tScope           string                       `json:\"scope\"`\n\tTeamName        string                       `json:\"team_name\"`\n\tTeamID          string                       `json:\"team_id\"`\n\tIncomingWebhook OAuthResponseIncomingWebhook `json:\"incoming_webhook\"`\n\tBot             OAuthResponseBot             `json:\"bot\"`\n\tUserID          string                       `json:\"user_id,omitempty\"`\n\tSlackResponse\n}\n\n// OAuthV2Response ...\ntype OAuthV2Response struct {\n\tAccessToken         string                       `json:\"access_token\"`\n\tTokenType           string                       `json:\"token_type\"`\n\tScope               string                       `json:\"scope\"`\n\tBotUserID           string                       `json:\"bot_user_id\"`\n\tAppID               string                       `json:\"app_id\"`\n\tTeam                OAuthV2ResponseTeam          `json:\"team\"`\n\tIncomingWebhook     OAuthResponseIncomingWebhook `json:\"incoming_webhook\"`\n\tEnterprise          OAuthV2ResponseEnterprise    `json:\"enterprise\"`\n\tIsEnterpriseInstall bool                         `json:\"is_enterprise_install\"`\n\tAuthedUser          OAuthV2ResponseAuthedUser    `json:\"authed_user\"`\n\tRefreshToken        string                       `json:\"refresh_token\"`\n\tExpiresIn           int                          `json:\"expires_in\"`\n\tSlackResponse\n}\n\n// OAuthV2ResponseTeam ...\ntype OAuthV2ResponseTeam struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\n// OAuthV2ResponseEnterprise ...\ntype OAuthV2ResponseEnterprise struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\n// OAuthV2ResponseAuthedUser ...\ntype OAuthV2ResponseAuthedUser struct {\n\tID           string `json:\"id\"`\n\tScope        string `json:\"scope\"`\n\tAccessToken  string `json:\"access_token\"`\n\tExpiresIn    int    `json:\"expires_in\"`\n\tRefreshToken string `json:\"refresh_token\"`\n\tTokenType    string `json:\"token_type\"`\n}\n\n// OpenIDConnectResponse ...\ntype OpenIDConnectResponse struct {\n\tOk          bool   `json:\"ok\"`\n\tAccessToken string `json:\"access_token\"`\n\tTokenType   string `json:\"token_type\"`\n\tIdToken     string `json:\"id_token\"`\n\tSlackResponse\n}\n\n// GetOAuthToken retrieves an AccessToken.\n// For more details, see GetOAuthTokenContext documentation.\nfunc GetOAuthToken(client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, err error) {\n\treturn GetOAuthTokenContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n}\n\n// GetOAuthTokenContext retrieves an AccessToken with a custom context.\n// For more details, see GetOAuthResponseContext documentation.\nfunc GetOAuthTokenContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, err error) {\n\tresponse, err := GetOAuthResponseContext(ctx, client, clientID, clientSecret, code, redirectURI)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn response.AccessToken, response.Scope, nil\n}\n\n// GetBotOAuthToken retrieves top-level and bot AccessToken - https://api.slack.com/legacy/oauth#bot_user_access_tokens\n// For more details, see GetBotOAuthTokenContext documentation.\nfunc GetBotOAuthToken(client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, bot OAuthResponseBot, err error) {\n\treturn GetBotOAuthTokenContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n}\n\n// GetBotOAuthTokenContext retrieves top-level and bot AccessToken with a custom context.\n// For more details, see GetOAuthResponseContext documentation.\nfunc GetBotOAuthTokenContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, bot OAuthResponseBot, err error) {\n\tresponse, err := GetOAuthResponseContext(ctx, client, clientID, clientSecret, code, redirectURI)\n\tif err != nil {\n\t\treturn \"\", \"\", OAuthResponseBot{}, err\n\t}\n\treturn response.AccessToken, response.Scope, response.Bot, nil\n}\n\n// GetOAuthResponse retrieves OAuth response.\n// For more details, see GetOAuthResponseContext documentation.\nfunc GetOAuthResponse(client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthResponse, err error) {\n\treturn GetOAuthResponseContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n}\n\n// GetOAuthResponseContext retrieves OAuth response with custom context.\n// Slack API docs: https://api.slack.com/methods/oauth.access\nfunc GetOAuthResponseContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthResponse, err error) {\n\tvalues := url.Values{\n\t\t\"client_id\":     {clientID},\n\t\t\"client_secret\": {clientSecret},\n\t\t\"code\":          {code},\n\t\t\"redirect_uri\":  {redirectURI},\n\t}\n\tresponse := &OAuthResponse{}\n\tif err = postForm(ctx, client, APIURL+\"oauth.access\", values, response, discard{}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n\n// GetOAuthV2Response gets a V2 OAuth access token response.\n// For more details, see GetOAuthV2ResponseContext documentation.\nfunc GetOAuthV2Response(client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthV2Response, err error) {\n\treturn GetOAuthV2ResponseContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n}\n\n// GetOAuthV2ResponseContext with a context, gets a V2 OAuth access token response.\n// Slack API docs: https://api.slack.com/methods/oauth.v2.access\nfunc GetOAuthV2ResponseContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthV2Response, err error) {\n\tvalues := url.Values{\n\t\t\"client_id\":     {clientID},\n\t\t\"client_secret\": {clientSecret},\n\t\t\"code\":          {code},\n\t\t\"redirect_uri\":  {redirectURI},\n\t}\n\tresponse := &OAuthV2Response{}\n\tif err = postForm(ctx, client, APIURL+\"oauth.v2.access\", values, response, discard{}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n\n// RefreshOAuthV2Token with a context, gets a V2 OAuth access token response.\n// For more details, see RefreshOAuthV2TokenContext documentation.\nfunc RefreshOAuthV2Token(client httpClient, clientID, clientSecret, refreshToken string) (resp *OAuthV2Response, err error) {\n\treturn RefreshOAuthV2TokenContext(context.Background(), client, clientID, clientSecret, refreshToken)\n}\n\n// RefreshOAuthV2TokenContext with a context, gets a V2 OAuth access token response.\n// Slack API docs: https://api.slack.com/methods/oauth.v2.access\nfunc RefreshOAuthV2TokenContext(ctx context.Context, client httpClient, clientID, clientSecret, refreshToken string) (resp *OAuthV2Response, err error) {\n\tvalues := url.Values{\n\t\t\"client_id\":     {clientID},\n\t\t\"client_secret\": {clientSecret},\n\t\t\"refresh_token\": {refreshToken},\n\t\t\"grant_type\":    {\"refresh_token\"},\n\t}\n\tresponse := &OAuthV2Response{}\n\tif err = postForm(ctx, client, APIURL+\"oauth.v2.access\", values, response, discard{}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n\n// GetOpenIDConnectToken exchanges a temporary OAuth verifier code for an access token for Sign in with Slack.\n// For more details, see GetOpenIDConnectTokenContext documentation.\nfunc GetOpenIDConnectToken(client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OpenIDConnectResponse, err error) {\n\treturn GetOpenIDConnectTokenContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n}\n\n// GetOpenIDConnectTokenContext with a context, gets an access token for Sign in with Slack.\n// Slack API docs: https://api.slack.com/methods/openid.connect.token\nfunc GetOpenIDConnectTokenContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OpenIDConnectResponse, err error) {\n\tvalues := url.Values{\n\t\t\"client_id\":     {clientID},\n\t\t\"client_secret\": {clientSecret},\n\t\t\"code\":          {code},\n\t\t\"redirect_uri\":  {redirectURI},\n\t}\n\tresponse := &OpenIDConnectResponse{}\n\tif err = postForm(ctx, client, APIURL+\"openid.connect.token\", values, response, discard{}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n"
        },
        {
          "name": "pagination.go",
          "type": "blob",
          "size": 0.5107421875,
          "content": "package slack\n\n// Paging contains paging information\ntype Paging struct {\n\tCount int `json:\"count\"`\n\tTotal int `json:\"total\"`\n\tPage  int `json:\"page\"`\n\tPages int `json:\"pages\"`\n}\n\n// Pagination contains pagination information\n// This is different from Paging in that it contains additional details\ntype Pagination struct {\n\tTotalCount int `json:\"total_count\"`\n\tPage       int `json:\"page\"`\n\tPerPage    int `json:\"per_page\"`\n\tPageCount  int `json:\"page_count\"`\n\tFirst      int `json:\"first\"`\n\tLast       int `json:\"last\"`\n}\n"
        },
        {
          "name": "pins.go",
          "type": "blob",
          "size": 2.6865234375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/url\"\n)\n\ntype listPinsResponseFull struct {\n\tItems  []Item\n\tPaging `json:\"paging\"`\n\tSlackResponse\n}\n\n// AddPin pins an item in a channel.\n// For more details, see AddPinContext documentation.\nfunc (api *Client) AddPin(channel string, item ItemRef) error {\n\treturn api.AddPinContext(context.Background(), channel, item)\n}\n\n// AddPinContext pins an item in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/pins.add\nfunc (api *Client) AddPinContext(ctx context.Context, channel string, item ItemRef) error {\n\tvalues := url.Values{\n\t\t\"channel\": {channel},\n\t\t\"token\":   {api.token},\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"pins.add\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// RemovePin un-pins an item from a channel.\n// For more details, see RemovePinContext documentation.\nfunc (api *Client) RemovePin(channel string, item ItemRef) error {\n\treturn api.RemovePinContext(context.Background(), channel, item)\n}\n\n// RemovePinContext un-pins an item from a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/pins.remove\nfunc (api *Client) RemovePinContext(ctx context.Context, channel string, item ItemRef) error {\n\tvalues := url.Values{\n\t\t\"channel\": {channel},\n\t\t\"token\":   {api.token},\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"pins.remove\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// ListPins returns information about the items a user reacted to.\n// For more details, see ListPinsContext documentation.\nfunc (api *Client) ListPins(channel string) ([]Item, *Paging, error) {\n\treturn api.ListPinsContext(context.Background(), channel)\n}\n\n// ListPinsContext returns information about the items a user reacted to with a custom context.\n// Slack API docs: https://api.slack.com/methods/pins.list\nfunc (api *Client) ListPinsContext(ctx context.Context, channel string) ([]Item, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"channel\": {channel},\n\t\t\"token\":   {api.token},\n\t}\n\n\tresponse := &listPinsResponseFull{}\n\terr := api.postMethod(ctx, \"pins.list\", values, response)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif !response.Ok {\n\t\treturn nil, nil, errors.New(response.Error)\n\t}\n\treturn response.Items, &response.Paging, nil\n}\n"
        },
        {
          "name": "pins_test.go",
          "type": "blob",
          "size": 5.6513671875,
          "content": "package slack\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype pinsHandler struct {\n\tgotParams map[string]string\n\tresponse  string\n}\n\nfunc newPinsHandler() *pinsHandler {\n\treturn &pinsHandler{\n\t\tgotParams: make(map[string]string),\n\t\tresponse:  `{ \"ok\": true }`,\n\t}\n}\n\nfunc (rh *pinsHandler) accumulateFormValue(k string, r *http.Request) {\n\tif v := r.FormValue(k); v != \"\" {\n\t\trh.gotParams[k] = v\n\t}\n}\n\nfunc (rh *pinsHandler) handler(w http.ResponseWriter, r *http.Request) {\n\trh.accumulateFormValue(\"channel\", r)\n\trh.accumulateFormValue(\"count\", r)\n\trh.accumulateFormValue(\"file\", r)\n\trh.accumulateFormValue(\"file_comment\", r)\n\trh.accumulateFormValue(\"page\", r)\n\trh.accumulateFormValue(\"timestamp\", r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write([]byte(rh.response))\n}\n\nfunc TestSlack_AddPin(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tchannel    string\n\t\tref        ItemRef\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\": \"ChannelID\",\n\t\t\t\t\"file\":    \"FileID\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":      \"ChannelID\",\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *pinsHandler\n\thttp.HandleFunc(\"/pins.add\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newPinsHandler()\n\t\terr := api.AddPin(test.channel, test.ref)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_RemovePin(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tchannel    string\n\t\tref        ItemRef\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\": \"ChannelID\",\n\t\t\t\t\"file\":    \"FileID\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":      \"ChannelID\",\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *pinsHandler\n\thttp.HandleFunc(\"/pins.remove\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newPinsHandler()\n\t\terr := api.RemovePin(test.channel, test.ref)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_ListPins(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\trh := newPinsHandler()\n\thttp.HandleFunc(\"/pins.list\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\trh.response = `{\"ok\": true,\n    \"items\": [\n        {\n            \"type\": \"message\",\n            \"channel\": \"C1\",\n            \"message\": {\n                \"text\": \"hello\",\n                \"reactions\": [\n                    {\n                        \"name\": \"astonished\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\", \"U3\" ]\n                    },\n                    {\n                        \"name\": \"clock1\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\" ]\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"file\",\n            \"file\": {\n                \"name\": \"toy\",\n                \"reactions\": [\n                    {\n                        \"name\": \"clock1\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\" ]\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"file_comment\",\n            \"file\": {\n                \"name\": \"toy\"\n            },\n            \"comment\": {\n                \"comment\": \"cool toy\",\n                \"reactions\": [\n                    {\n                        \"name\": \"astonished\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\", \"U3\" ]\n                    }\n                ]\n            }\n        }\n    ],\n    \"paging\": {\n        \"count\": 100,\n        \"total\": 4,\n        \"page\": 1,\n        \"pages\": 1\n    }}`\n\twant := []Item{\n\t\tNewMessageItem(\"C1\", &Message{Msg: Msg{\n\t\t\tText: \"hello\",\n\t\t\tReactions: []ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t}}),\n\t\tNewFileItem(&File{Name: \"toy\"}),\n\t\tNewFileCommentItem(&File{Name: \"toy\"}, &Comment{Comment: \"cool toy\"}),\n\t}\n\twantParams := map[string]string{\n\t\t\"channel\": \"ChannelID\",\n\t}\n\tgot, paging, err := api.ListPins(\"ChannelID\")\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Got Pins %#v, want %#v\", got, want)\n\t\tfor i, item := range got {\n\t\t\tfmt.Printf(\"Item %d, Type: %s\\n\", i, item.Type)\n\t\t\tfmt.Printf(\"Message  %#v\\n\", item.Message)\n\t\t\tfmt.Printf(\"File     %#v\\n\", item.File)\n\t\t\tfmt.Printf(\"Comment  %#v\\n\", item.Comment)\n\t\t}\n\t}\n\tif !reflect.DeepEqual(rh.gotParams, wantParams) {\n\t\tt.Errorf(\"Got params %#v, want %#v\", rh.gotParams, wantParams)\n\t}\n\tif reflect.DeepEqual(paging, Paging{}) {\n\t\tt.Errorf(\"Want paging data, got empty struct\")\n\t}\n}\n"
        },
        {
          "name": "reactions.go",
          "type": "blob",
          "size": 7.337890625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\n// ItemReaction is the reactions that have happened on an item.\ntype ItemReaction struct {\n\tName  string   `json:\"name\"`\n\tCount int      `json:\"count\"`\n\tUsers []string `json:\"users\"`\n}\n\n// ReactedItem is an item that was reacted to, and the details of the\n// reactions.\ntype ReactedItem struct {\n\tItem\n\tReactions []ItemReaction\n}\n\n// GetReactionsParameters is the inputs to get reactions to an item.\ntype GetReactionsParameters struct {\n\tFull bool\n}\n\n// NewGetReactionsParameters initializes the inputs to get reactions to an item.\nfunc NewGetReactionsParameters() GetReactionsParameters {\n\treturn GetReactionsParameters{\n\t\tFull: false,\n\t}\n}\n\ntype getReactionsResponseFull struct {\n\tType string\n\tM    struct {\n\t\tReactions []ItemReaction\n\t} `json:\"message\"`\n\tF struct {\n\t\tReactions []ItemReaction\n\t} `json:\"file\"`\n\tFC struct {\n\t\tReactions []ItemReaction\n\t} `json:\"comment\"`\n\tSlackResponse\n}\n\nfunc (res getReactionsResponseFull) extractReactions() []ItemReaction {\n\tswitch res.Type {\n\tcase \"message\":\n\t\treturn res.M.Reactions\n\tcase \"file\":\n\t\treturn res.F.Reactions\n\tcase \"file_comment\":\n\t\treturn res.FC.Reactions\n\t}\n\treturn []ItemReaction{}\n}\n\nconst (\n\tDEFAULT_REACTIONS_USER  = \"\"\n\tDEFAULT_REACTIONS_COUNT = 100\n\tDEFAULT_REACTIONS_PAGE  = 1\n\tDEFAULT_REACTIONS_FULL  = false\n)\n\n// ListReactionsParameters is the inputs to find all reactions by a user.\ntype ListReactionsParameters struct {\n\tUser   string\n\tTeamID string\n\tCount  int\n\tPage   int\n\tFull   bool\n}\n\n// NewListReactionsParameters initializes the inputs to find all reactions\n// performed by a user.\nfunc NewListReactionsParameters() ListReactionsParameters {\n\treturn ListReactionsParameters{\n\t\tUser:  DEFAULT_REACTIONS_USER,\n\t\tCount: DEFAULT_REACTIONS_COUNT,\n\t\tPage:  DEFAULT_REACTIONS_PAGE,\n\t\tFull:  DEFAULT_REACTIONS_FULL,\n\t}\n}\n\ntype listReactionsResponseFull struct {\n\tItems []struct {\n\t\tType    string\n\t\tChannel string\n\t\tM       struct {\n\t\t\t*Message\n\t\t} `json:\"message\"`\n\t\tF struct {\n\t\t\t*File\n\t\t\tReactions []ItemReaction\n\t\t} `json:\"file\"`\n\t\tFC struct {\n\t\t\t*Comment\n\t\t\tReactions []ItemReaction\n\t\t} `json:\"comment\"`\n\t}\n\tPaging `json:\"paging\"`\n\tSlackResponse\n}\n\nfunc (res listReactionsResponseFull) extractReactedItems() []ReactedItem {\n\titems := make([]ReactedItem, len(res.Items))\n\tfor i, input := range res.Items {\n\t\titem := ReactedItem{}\n\t\titem.Type = input.Type\n\t\tswitch input.Type {\n\t\tcase \"message\":\n\t\t\titem.Channel = input.Channel\n\t\t\titem.Message = input.M.Message\n\t\t\titem.Reactions = input.M.Reactions\n\t\tcase \"file\":\n\t\t\titem.File = input.F.File\n\t\t\titem.Reactions = input.F.Reactions\n\t\tcase \"file_comment\":\n\t\t\titem.File = input.F.File\n\t\t\titem.Comment = input.FC.Comment\n\t\t\titem.Reactions = input.FC.Reactions\n\t\t}\n\t\titems[i] = item\n\t}\n\treturn items\n}\n\n// AddReaction adds a reaction emoji to a message, file or file comment.\n// For more details, see AddReactionContext documentation.\nfunc (api *Client) AddReaction(name string, item ItemRef) error {\n\treturn api.AddReactionContext(context.Background(), name, item)\n}\n\n// AddReactionContext adds a reaction emoji to a message, file or file comment with a custom context.\n// Slack API docs: https://api.slack.com/methods/reactions.add\nfunc (api *Client) AddReactionContext(ctx context.Context, name string, item ItemRef) error {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif name != \"\" {\n\t\tvalues.Set(\"name\", name)\n\t}\n\tif item.Channel != \"\" {\n\t\tvalues.Set(\"channel\", item.Channel)\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"reactions.add\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// RemoveReaction removes a reaction emoji from a message, file or file comment.\n// For more details, see RemoveReactionContext documentation.\nfunc (api *Client) RemoveReaction(name string, item ItemRef) error {\n\treturn api.RemoveReactionContext(context.Background(), name, item)\n}\n\n// RemoveReactionContext removes a reaction emoji from a message, file or file comment with a custom context.\n// Slack API docs: https://api.slack.com/methods/reactions.remove\nfunc (api *Client) RemoveReactionContext(ctx context.Context, name string, item ItemRef) error {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif name != \"\" {\n\t\tvalues.Set(\"name\", name)\n\t}\n\tif item.Channel != \"\" {\n\t\tvalues.Set(\"channel\", item.Channel)\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"reactions.remove\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// GetReactions returns details about the reactions on an item.\n// For more details, see GetReactionsContext documentation.\nfunc (api *Client) GetReactions(item ItemRef, params GetReactionsParameters) ([]ItemReaction, error) {\n\treturn api.GetReactionsContext(context.Background(), item, params)\n}\n\n// GetReactionsContext returns details about the reactions on an item with a custom context.\n// Slack API docs: https://api.slack.com/methods/reactions.get\nfunc (api *Client) GetReactionsContext(ctx context.Context, item ItemRef, params GetReactionsParameters) ([]ItemReaction, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif item.Channel != \"\" {\n\t\tvalues.Set(\"channel\", item.Channel)\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\tif params.Full != DEFAULT_REACTIONS_FULL {\n\t\tvalues.Set(\"full\", strconv.FormatBool(params.Full))\n\t}\n\n\tresponse := &getReactionsResponseFull{}\n\tif err := api.postMethod(ctx, \"reactions.get\", values, response); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := response.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.extractReactions(), nil\n}\n\n// ListReactions returns information about the items a user reacted to.\n// For more details, see ListReactionsContext documentation.\nfunc (api *Client) ListReactions(params ListReactionsParameters) ([]ReactedItem, *Paging, error) {\n\treturn api.ListReactionsContext(context.Background(), params)\n}\n\n// ListReactionsContext returns information about the items a user reacted to with a custom context.\n// Slack API docs: https://api.slack.com/methods/reactions.list\nfunc (api *Client) ListReactionsContext(ctx context.Context, params ListReactionsParameters) ([]ReactedItem, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.User != DEFAULT_REACTIONS_USER {\n\t\tvalues.Add(\"user\", params.User)\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.Count != DEFAULT_REACTIONS_COUNT {\n\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n\t}\n\tif params.Page != DEFAULT_REACTIONS_PAGE {\n\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n\t}\n\tif params.Full != DEFAULT_REACTIONS_FULL {\n\t\tvalues.Add(\"full\", strconv.FormatBool(params.Full))\n\t}\n\n\tresponse := &listReactionsResponseFull{}\n\terr := api.postMethod(ctx, \"reactions.list\", values, response)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := response.Err(); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn response.extractReactedItems(), &response.Paging, nil\n}\n"
        },
        {
          "name": "reactions_test.go",
          "type": "blob",
          "size": 9.4091796875,
          "content": "package slack\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype reactionsHandler struct {\n\tgotParams map[string]string\n\tresponse  string\n}\n\nfunc newReactionsHandler() *reactionsHandler {\n\treturn &reactionsHandler{\n\t\tgotParams: make(map[string]string),\n\t\tresponse:  `{ \"ok\": true }`,\n\t}\n}\n\nfunc (rh *reactionsHandler) accumulateFormValue(k string, r *http.Request) {\n\tif v := r.FormValue(k); v != \"\" {\n\t\trh.gotParams[k] = v\n\t}\n}\n\nfunc (rh *reactionsHandler) handler(w http.ResponseWriter, r *http.Request) {\n\trh.accumulateFormValue(\"channel\", r)\n\trh.accumulateFormValue(\"count\", r)\n\trh.accumulateFormValue(\"file\", r)\n\trh.accumulateFormValue(\"file_comment\", r)\n\trh.accumulateFormValue(\"full\", r)\n\trh.accumulateFormValue(\"name\", r)\n\trh.accumulateFormValue(\"page\", r)\n\trh.accumulateFormValue(\"timestamp\", r)\n\trh.accumulateFormValue(\"user\", r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write([]byte(rh.response))\n}\n\nfunc TestSlack_AddReaction(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tname       string\n\t\tref        ItemRef\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t\"thumbsup\",\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"name\":      \"thumbsup\",\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"thumbsup\",\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"name\": \"thumbsup\",\n\t\t\t\t\"file\": \"FileID\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"thumbsup\",\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"name\":         \"thumbsup\",\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *reactionsHandler\n\thttp.HandleFunc(\"/reactions.add\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newReactionsHandler()\n\t\terr := api.AddReaction(test.name, test.ref)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_RemoveReaction(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tname       string\n\t\tref        ItemRef\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t\"thumbsup\",\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"name\":      \"thumbsup\",\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"thumbsup\",\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"name\": \"thumbsup\",\n\t\t\t\t\"file\": \"FileID\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"thumbsup\",\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"name\":         \"thumbsup\",\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *reactionsHandler\n\thttp.HandleFunc(\"/reactions.remove\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newReactionsHandler()\n\t\terr := api.RemoveReaction(test.name, test.ref)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_GetReactions(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tref           ItemRef\n\t\tparams        GetReactionsParameters\n\t\twantParams    map[string]string\n\t\tjson          string\n\t\twantReactions []ItemReaction\n\t}{\n\t\t{\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tGetReactionsParameters{},\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t\t`{\"ok\": true,\n    \"type\": \"message\",\n    \"message\": {\n        \"reactions\": [\n            {\n                \"name\": \"astonished\",\n                \"count\": 3,\n                \"users\": [ \"U1\", \"U2\", \"U3\" ]\n            },\n            {\n                \"name\": \"clock1\",\n                \"count\": 3,\n                \"users\": [ \"U1\", \"U2\" ]\n            }\n        ]\n    }}`,\n\t\t\t[]ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tGetReactionsParameters{Full: true},\n\t\t\tmap[string]string{\n\t\t\t\t\"file\": \"FileID\",\n\t\t\t\t\"full\": \"true\",\n\t\t\t},\n\t\t\t`{\"ok\": true,\n    \"type\": \"file\",\n    \"file\": {\n        \"reactions\": [\n            {\n                \"name\": \"astonished\",\n                \"count\": 3,\n                \"users\": [ \"U1\", \"U2\", \"U3\" ]\n            },\n            {\n                \"name\": \"clock1\",\n                \"count\": 3,\n                \"users\": [ \"U1\", \"U2\" ]\n            }\n        ]\n    }}`,\n\t\t\t[]ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tGetReactionsParameters{},\n\t\t\tmap[string]string{\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t\t`{\"ok\": true,\n    \"type\": \"file_comment\",\n    \"file\": {},\n    \"comment\": {\n        \"reactions\": [\n            {\n                \"name\": \"astonished\",\n                \"count\": 3,\n                \"users\": [ \"U1\", \"U2\", \"U3\" ]\n            },\n            {\n                \"name\": \"clock1\",\n                \"count\": 3,\n                \"users\": [ \"U1\", \"U2\" ]\n            }\n        ]\n    }}`,\n\t\t\t[]ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *reactionsHandler\n\thttp.HandleFunc(\"/reactions.get\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newReactionsHandler()\n\t\trh.response = test.json\n\t\tgot, err := api.GetReactions(test.ref, test.params)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(got, test.wantReactions) {\n\t\t\tt.Errorf(\"%d: Got reaction %#v, want %#v\", i, got, test.wantReactions)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_ListReactions(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\trh := newReactionsHandler()\n\thttp.HandleFunc(\"/reactions.list\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\trh.response = `{\"ok\": true,\n    \"items\": [\n        {\n            \"type\": \"message\",\n            \"channel\": \"C1\",\n            \"message\": {\n                \"text\": \"hello\",\n                \"reactions\": [\n                    {\n                        \"name\": \"astonished\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\", \"U3\" ]\n                    },\n                    {\n                        \"name\": \"clock1\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\" ]\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"file\",\n            \"file\": {\n                \"name\": \"toy\",\n                \"reactions\": [\n                    {\n                        \"name\": \"clock1\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\" ]\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"file_comment\",\n            \"file\": {\n                \"name\": \"toy\"\n            },\n            \"comment\": {\n                \"comment\": \"cool toy\",\n                \"reactions\": [\n                    {\n                        \"name\": \"astonished\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\", \"U3\" ]\n                    }\n                ]\n            }\n        }\n    ],\n    \"paging\": {\n        \"count\": 100,\n        \"total\": 4,\n        \"page\": 1,\n        \"pages\": 1\n    }}`\n\twant := []ReactedItem{\n\t\t{\n\t\t\tItem: NewMessageItem(\"C1\", &Message{Msg: Msg{\n\t\t\t\tText: \"hello\",\n\t\t\t\tReactions: []ItemReaction{\n\t\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t\t},\n\t\t\t}}),\n\t\t\tReactions: []ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tItem: NewFileItem(&File{Name: \"toy\"}),\n\t\t\tReactions: []ItemReaction{\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tItem: NewFileCommentItem(&File{Name: \"toy\"}, &Comment{Comment: \"cool toy\"}),\n\t\t\tReactions: []ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t},\n\t\t},\n\t}\n\twantParams := map[string]string{\n\t\t\"user\":  \"User\",\n\t\t\"count\": \"200\",\n\t\t\"page\":  \"2\",\n\t\t\"full\":  \"true\",\n\t}\n\tparams := NewListReactionsParameters()\n\tparams.User = \"User\"\n\tparams.Count = 200\n\tparams.Page = 2\n\tparams.Full = true\n\tgot, paging, err := api.ListReactions(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Got reaction %#v, want %#v\", got, want)\n\t\tfor i, item := range got {\n\t\t\tfmt.Printf(\"Item %d, Type: %s\\n\", i, item.Type)\n\t\t\tfmt.Printf(\"Message  %#v\\n\", item.Message)\n\t\t\tfmt.Printf(\"File     %#v\\n\", item.File)\n\t\t\tfmt.Printf(\"Comment  %#v\\n\", item.Comment)\n\t\t\tfmt.Printf(\"Reactions %#v\\n\", item.Reactions)\n\t\t}\n\t}\n\tif !reflect.DeepEqual(rh.gotParams, wantParams) {\n\t\tt.Errorf(\"Got params %#v, want %#v\", rh.gotParams, wantParams)\n\t}\n\tif reflect.DeepEqual(paging, Paging{}) {\n\t\tt.Errorf(\"Want paging data, got empty struct\")\n\t}\n}\n"
        },
        {
          "name": "reminders.go",
          "type": "blob",
          "size": 3.91796875,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\ntype Reminder struct {\n\tID         string `json:\"id\"`\n\tCreator    string `json:\"creator\"`\n\tUser       string `json:\"user\"`\n\tText       string `json:\"text\"`\n\tRecurring  bool   `json:\"recurring\"`\n\tTime       int    `json:\"time\"`\n\tCompleteTS int    `json:\"complete_ts\"`\n}\n\ntype reminderResp struct {\n\tSlackResponse\n\tReminder Reminder `json:\"reminder\"`\n}\n\ntype remindersResp struct {\n\tSlackResponse\n\tReminders []*Reminder `json:\"reminders\"`\n}\n\nfunc (api *Client) doReminder(ctx context.Context, path string, values url.Values) (*Reminder, error) {\n\tresponse := &reminderResp{}\n\tif err := api.postMethod(ctx, path, values, response); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.Reminder, response.Err()\n}\n\nfunc (api *Client) doReminders(ctx context.Context, path string, values url.Values) ([]*Reminder, error) {\n\tresponse := &remindersResp{}\n\tif err := api.postMethod(ctx, path, values, response); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// create an array of pointers to reminders\n\tvar reminders = make([]*Reminder, 0, len(response.Reminders))\n\treminders = append(reminders, response.Reminders...)\n\treturn reminders, response.Err()\n}\n\n// ListReminders lists all the reminders created by or for the authenticated user\n// For more details, see ListRemindersContext documentation.\nfunc (api *Client) ListReminders() ([]*Reminder, error) {\n\treturn api.ListRemindersContext(context.Background())\n}\n\n// ListRemindersContext lists all the reminders created by or for the authenticated user with a custom context.\n// Slack API docs: https://api.slack.com/methods/reminders.list\nfunc (api *Client) ListRemindersContext(ctx context.Context) ([]*Reminder, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\treturn api.doReminders(ctx, \"reminders.list\", values)\n}\n\n// AddChannelReminder adds a reminder for a channel.\n// For more details, see AddChannelReminderContext documentation.\nfunc (api *Client) AddChannelReminder(channelID, text, time string) (*Reminder, error) {\n\treturn api.AddChannelReminderContext(context.Background(), channelID, text, time)\n}\n\n// AddChannelReminderContext adds a reminder for a channel with a custom context\n// NOTE: the ability to set reminders on a channel is currently undocumented but has been tested to work.\n// Slack API docs: https://api.slack.com/methods/reminders.add\nfunc (api *Client) AddChannelReminderContext(ctx context.Context, channelID, text, time string) (*Reminder, error) {\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"text\":    {text},\n\t\t\"time\":    {time},\n\t\t\"channel\": {channelID},\n\t}\n\treturn api.doReminder(ctx, \"reminders.add\", values)\n}\n\n// AddUserReminder adds a reminder for a user.\n// For more details, see AddUserReminderContext documentation.\nfunc (api *Client) AddUserReminder(userID, text, time string) (*Reminder, error) {\n\treturn api.AddUserReminderContext(context.Background(), userID, text, time)\n}\n\n// AddUserReminderContext adds a reminder for a user with a custom context\n// Slack API docs: https://api.slack.com/methods/reminders.add\nfunc (api *Client) AddUserReminderContext(ctx context.Context, userID, text, time string) (*Reminder, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"text\":  {text},\n\t\t\"time\":  {time},\n\t\t\"user\":  {userID},\n\t}\n\treturn api.doReminder(ctx, \"reminders.add\", values)\n}\n\n// DeleteReminder deletes an existing reminder.\n// For more details, see DeleteReminderContext documentation.\nfunc (api *Client) DeleteReminder(id string) error {\n\treturn api.DeleteReminderContext(context.Background(), id)\n}\n\n// DeleteReminderContext deletes an existing reminder with a custom context\n// Slack API docs: https://api.slack.com/methods/reminders.delete\nfunc (api *Client) DeleteReminderContext(ctx context.Context, id string) error {\n\tvalues := url.Values{\n\t\t\"token\":    {api.token},\n\t\t\"reminder\": {id},\n\t}\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"reminders.delete\", values, response); err != nil {\n\t\treturn err\n\t}\n\treturn response.Err()\n}\n"
        },
        {
          "name": "reminders_test.go",
          "type": "blob",
          "size": 4.841796875,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype remindersHandler struct {\n\tgotParams map[string]string\n}\n\nfunc newRemindersHandler() *remindersHandler {\n\treturn &remindersHandler{\n\t\tgotParams: make(map[string]string),\n\t}\n}\n\nfunc (rh *remindersHandler) accumulateFormValue(k string, r *http.Request) {\n\tif v := r.FormValue(k); v != \"\" {\n\t\trh.gotParams[k] = v\n\t}\n}\n\nfunc (rh *remindersHandler) handler(w http.ResponseWriter, r *http.Request) {\n\trh.accumulateFormValue(\"channel\", r)\n\trh.accumulateFormValue(\"user\", r)\n\trh.accumulateFormValue(\"text\", r)\n\trh.accumulateFormValue(\"time\", r)\n\trh.accumulateFormValue(\"reminder\", r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif rh.gotParams[\"text\"] == \"trigger-error\" || rh.gotParams[\"reminder\"] == \"trigger-error\" {\n\t\tw.Write([]byte(`{ \"ok\": false, \"error\": \"oh no\" }`))\n\t} else {\n\t\tw.Write([]byte(`{ \"ok\": true }`))\n\t}\n}\n\nfunc TestSlack_AddReminder(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tchanID     string\n\t\tuserID     string\n\t\ttext       string\n\t\ttime       string\n\t\twantParams map[string]string\n\t\texpectErr  bool\n\t}{\n\t\t{\n\t\t\t\"someChannelID\",\n\t\t\t\"\",\n\t\t\t\"hello world\",\n\t\t\t\"tomorrow at 9am\",\n\t\t\tmap[string]string{\n\t\t\t\t\"text\":    \"hello world\",\n\t\t\t\t\"time\":    \"tomorrow at 9am\",\n\t\t\t\t\"channel\": \"someChannelID\",\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"someChannelID\",\n\t\t\t\"\",\n\t\t\t\"trigger-error\",\n\t\t\t\"tomorrow at 9am\",\n\t\t\tmap[string]string{\n\t\t\t\t\"text\":    \"trigger-error\",\n\t\t\t\t\"time\":    \"tomorrow at 9am\",\n\t\t\t\t\"channel\": \"someChannelID\",\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"\",\n\t\t\t\"someUserID\",\n\t\t\t\"hello world\",\n\t\t\t\"tomorrow at 9am\",\n\t\t\tmap[string]string{\n\t\t\t\t\"text\": \"hello world\",\n\t\t\t\t\"time\": \"tomorrow at 9am\",\n\t\t\t\t\"user\": \"someUserID\",\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"\",\n\t\t\t\"someUserID\",\n\t\t\t\"trigger-error\",\n\t\t\t\"tomorrow at 9am\",\n\t\t\tmap[string]string{\n\t\t\t\t\"text\": \"trigger-error\",\n\t\t\t\t\"time\": \"tomorrow at 9am\",\n\t\t\t\t\"user\": \"someUserID\",\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\tvar rh *remindersHandler\n\thttp.HandleFunc(\"/reminders.add\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newRemindersHandler()\n\t\tvar err error\n\t\tif test.chanID != \"\" {\n\t\t\t_, err = api.AddChannelReminder(test.chanID, test.text, test.time)\n\t\t} else {\n\t\t\t_, err = api.AddUserReminder(test.userID, test.text, test.time)\n\t\t}\n\t\tif test.expectErr == false && err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t} else if test.expectErr == true && err == nil {\n\t\t\tt.Fatalf(\"%d: Expected error but got none!\", i)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_DeleteReminder(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\treminder   string\n\t\twantParams map[string]string\n\t\texpectErr  bool\n\t}{\n\t\t{\n\t\t\t\"foo\",\n\t\t\tmap[string]string{\n\t\t\t\t\"reminder\": \"foo\",\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"trigger-error\",\n\t\t\tmap[string]string{\n\t\t\t\t\"reminder\": \"trigger-error\",\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\tvar rh *remindersHandler\n\thttp.HandleFunc(\"/reminders.delete\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newRemindersHandler()\n\t\terr := api.DeleteReminder(test.reminder)\n\t\tif test.expectErr == false && err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t} else if test.expectErr == true && err == nil {\n\t\t\tt.Fatalf(\"%d: Expected error but got none!\", i)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\ntype mockRemindersListHTTPClient struct{}\n\nfunc (m *mockRemindersListHTTPClient) Do(*http.Request) (*http.Response, error) {\n\tresponseString := `{\n\t\t\"ok\": true,\n\t\t\"reminders\": [\n\t        {\n\t\t\t\t\"id\": \"Rm12345678\",\n\t\t\t\t\"creator\": \"U18888888\",\n\t\t\t\t\"user\": \"U18888888\",\n\t\t\t\t\"text\": \"eat a banana\",\n\t\t\t\t\"recurring\": false,\n\t\t\t\t\"time\": 1458678068,\n\t\t\t\t\"complete_ts\": 0\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": \"Gm12345678\",\n\t\t\t\t\"creator\": \"U18888888\",\n\t\t\t\t\"user\": \"U18888888\",\n\t\t\t\t\"text\": \"drink some water\",\n\t\t\t\t\"recurring\": false,\n\t\t\t\t\"time\": 1458678090,\n\t\t\t\t\"complete_ts\": 0\n\t\t\t}\n\t\t]\n\t}`\n\n\treturn &http.Response{StatusCode: 200, Body: io.NopCloser(bytes.NewBufferString(responseString))}, nil\n}\n\nfunc TestSlack_ListReminders(t *testing.T) {\n\texpectedIDs := []string{\"Rm12345678\", \"Gm12345678\"}\n\n\tonce.Do(startServer)\n\tapi := &Client{\n\t\tendpoint:   \"http://\" + serverAddr + \"/\",\n\t\ttoken:      \"testing-token\",\n\t\thttpclient: &mockRemindersListHTTPClient{},\n\t}\n\n\treminders, err := api.ListReminders()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\n\tfor i := range reminders {\n\t\tif reminders[i].ID != expectedIDs[i] {\n\t\t\tt.Fatalf(\"List Reminders data wasn't correctly populated: wanted %v, got %v\", expectedIDs[i], reminders[i].ID)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "remotefiles.go",
          "type": "blob",
          "size": 10.765625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tDEFAULT_REMOTE_FILES_CHANNEL = \"\"\n\tDEFAULT_REMOTE_FILES_TS_FROM = 0\n\tDEFAULT_REMOTE_FILES_TS_TO   = -1\n\tDEFAULT_REMOTE_FILES_COUNT   = 100\n)\n\n// RemoteFile contains all the information for a remote file\n// For more details:\n// https://api.slack.com/messaging/files/remote\ntype RemoteFile struct {\n\tID              string   `json:\"id\"`\n\tCreated         JSONTime `json:\"created\"`\n\tTimestamp       JSONTime `json:\"timestamp\"`\n\tName            string   `json:\"name\"`\n\tTitle           string   `json:\"title\"`\n\tMimetype        string   `json:\"mimetype\"`\n\tFiletype        string   `json:\"filetype\"`\n\tPrettyType      string   `json:\"pretty_type\"`\n\tUser            string   `json:\"user\"`\n\tEditable        bool     `json:\"editable\"`\n\tSize            int      `json:\"size\"`\n\tMode            string   `json:\"mode\"`\n\tIsExternal      bool     `json:\"is_external\"`\n\tExternalType    string   `json:\"external_type\"`\n\tIsPublic        bool     `json:\"is_public\"`\n\tPublicURLShared bool     `json:\"public_url_shared\"`\n\tDisplayAsBot    bool     `json:\"display_as_bot\"`\n\tUsername        string   `json:\"username\"`\n\tURLPrivate      string   `json:\"url_private\"`\n\tPermalink       string   `json:\"permalink\"`\n\tCommentsCount   int      `json:\"comments_count\"`\n\tIsStarred       bool     `json:\"is_starred\"`\n\tShares          Share    `json:\"shares\"`\n\tChannels        []string `json:\"channels\"`\n\tGroups          []string `json:\"groups\"`\n\tIMs             []string `json:\"ims\"`\n\tExternalID      string   `json:\"external_id\"`\n\tExternalURL     string   `json:\"external_url\"`\n\tHasRichPreview  bool     `json:\"has_rich_preview\"`\n}\n\n// RemoteFileParameters contains required and optional parameters for a remote file.\n//\n// ExternalID is a user defined GUID, ExternalURL is where the remote file can be accessed,\n// and Title is the name of the file.\n//\n// For more details:\n// https://api.slack.com/methods/files.remote.add\ntype RemoteFileParameters struct {\n\tExternalID            string // required\n\tExternalURL           string // required\n\tTitle                 string // required\n\tFiletype              string\n\tIndexableFileContents string\n\tPreviewImage          string\n\tPreviewImageReader    io.Reader\n}\n\n// ListRemoteFilesParameters contains arguments for the ListRemoteFiles method.\n// For more details:\n// https://api.slack.com/methods/files.remote.list\ntype ListRemoteFilesParameters struct {\n\tChannel       string\n\tCursor        string\n\tLimit         int\n\tTimestampFrom JSONTime\n\tTimestampTo   JSONTime\n}\n\ntype remoteFileResponseFull struct {\n\tRemoteFile `json:\"file\"`\n\tPaging     `json:\"paging\"`\n\tFiles      []RemoteFile `json:\"files\"`\n\tSlackResponse\n}\n\nfunc (api *Client) remoteFileRequest(ctx context.Context, path string, values url.Values) (*remoteFileResponseFull, error) {\n\tresponse := &remoteFileResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// AddRemoteFile adds a remote file. Unlike regular files, remote files must be explicitly shared.\n// For more details see the AddRemoteFileContext documentation.\nfunc (api *Client) AddRemoteFile(params RemoteFileParameters) (*RemoteFile, error) {\n\treturn api.AddRemoteFileContext(context.Background(), params)\n}\n\n// AddRemoteFileContext adds a remote file and setting a custom context\n// Slack API docs: https://api.slack.com/methods/files.remote.add\nfunc (api *Client) AddRemoteFileContext(ctx context.Context, params RemoteFileParameters) (remotefile *RemoteFile, err error) {\n\tif params.ExternalID == \"\" || params.ExternalURL == \"\" || params.Title == \"\" {\n\t\treturn nil, ErrParametersMissing\n\t}\n\tresponse := &remoteFileResponseFull{}\n\tvalues := url.Values{\n\t\t\"token\":        {api.token},\n\t\t\"external_id\":  {params.ExternalID},\n\t\t\"external_url\": {params.ExternalURL},\n\t\t\"title\":        {params.Title},\n\t}\n\tif params.Filetype != \"\" {\n\t\tvalues.Add(\"filetype\", params.Filetype)\n\t}\n\tif params.IndexableFileContents != \"\" {\n\t\tvalues.Add(\"indexable_file_contents\", params.IndexableFileContents)\n\t}\n\tif params.PreviewImage != \"\" {\n\t\terr = postLocalWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.remote.add\", params.PreviewImage, \"preview_image\", api.token, values, response, api)\n\t} else if params.PreviewImageReader != nil {\n\t\terr = postWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.remote.add\", \"preview.png\", \"preview_image\", api.token, values, params.PreviewImageReader, response, api)\n\t} else {\n\t\tresponse, err = api.remoteFileRequest(ctx, \"files.remote.add\", values)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.RemoteFile, response.Err()\n}\n\n// ListRemoteFiles retrieves all remote files according to the parameters given. Uses cursor based pagination.\n// For more details see the ListRemoteFilesContext documentation.\nfunc (api *Client) ListRemoteFiles(params ListRemoteFilesParameters) ([]RemoteFile, error) {\n\treturn api.ListRemoteFilesContext(context.Background(), params)\n}\n\n// ListRemoteFilesContext retrieves all remote files according to the parameters given with a custom context. Uses cursor based pagination.\n// Slack API docs: https://api.slack.com/methods/files.remote.list\nfunc (api *Client) ListRemoteFilesContext(ctx context.Context, params ListRemoteFilesParameters) ([]RemoteFile, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.Channel != DEFAULT_REMOTE_FILES_CHANNEL {\n\t\tvalues.Add(\"channel\", params.Channel)\n\t}\n\tif params.TimestampFrom != DEFAULT_REMOTE_FILES_TS_FROM {\n\t\tvalues.Add(\"ts_from\", strconv.FormatInt(int64(params.TimestampFrom), 10))\n\t}\n\tif params.TimestampTo != DEFAULT_REMOTE_FILES_TS_TO {\n\t\tvalues.Add(\"ts_to\", strconv.FormatInt(int64(params.TimestampTo), 10))\n\t}\n\tif params.Limit != DEFAULT_REMOTE_FILES_COUNT {\n\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n\t}\n\tif params.Cursor != \"\" {\n\t\tvalues.Add(\"cursor\", params.Cursor)\n\t}\n\n\tresponse, err := api.remoteFileRequest(ctx, \"files.remote.list\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tparams.Cursor = response.SlackResponse.ResponseMetadata.Cursor\n\n\treturn response.Files, nil\n}\n\n// GetRemoteFileInfo retrieves the complete remote file information.\n// For more details see the GetRemoteFileInfoContext documentation.\nfunc (api *Client) GetRemoteFileInfo(externalID, fileID string) (remotefile *RemoteFile, err error) {\n\treturn api.GetRemoteFileInfoContext(context.Background(), externalID, fileID)\n}\n\n// GetRemoteFileInfoContext retrieves the complete remote file information given with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.remote.info\nfunc (api *Client) GetRemoteFileInfoContext(ctx context.Context, externalID, fileID string) (remotefile *RemoteFile, err error) {\n\tif fileID == \"\" && externalID == \"\" {\n\t\treturn nil, fmt.Errorf(\"either externalID or fileID is required\")\n\t}\n\tif fileID != \"\" && externalID != \"\" {\n\t\treturn nil, fmt.Errorf(\"don't provide both externalID and fileID\")\n\t}\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif fileID != \"\" {\n\t\tvalues.Add(\"file\", fileID)\n\t}\n\tif externalID != \"\" {\n\t\tvalues.Add(\"external_id\", externalID)\n\t}\n\tresponse, err := api.remoteFileRequest(ctx, \"files.remote.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.RemoteFile, err\n}\n\n// ShareRemoteFile shares a remote file to channels.\n// For more details see the ShareRemoteFileContext documentation.\nfunc (api *Client) ShareRemoteFile(channels []string, externalID, fileID string) (file *RemoteFile, err error) {\n\treturn api.ShareRemoteFileContext(context.Background(), channels, externalID, fileID)\n}\n\n// ShareRemoteFileContext shares a remote file to channels with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.remote.share\nfunc (api *Client) ShareRemoteFileContext(ctx context.Context, channels []string, externalID, fileID string) (file *RemoteFile, err error) {\n\tif channels == nil || len(channels) == 0 {\n\t\treturn nil, ErrParametersMissing\n\t}\n\tif fileID == \"\" && externalID == \"\" {\n\t\treturn nil, fmt.Errorf(\"either externalID or fileID is required\")\n\t}\n\tvalues := url.Values{\n\t\t\"token\":    {api.token},\n\t\t\"channels\": {strings.Join(channels, \",\")},\n\t}\n\tif fileID != \"\" {\n\t\tvalues.Add(\"file\", fileID)\n\t}\n\tif externalID != \"\" {\n\t\tvalues.Add(\"external_id\", externalID)\n\t}\n\tresponse, err := api.remoteFileRequest(ctx, \"files.remote.share\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.RemoteFile, err\n}\n\n// UpdateRemoteFile updates a remote file.\n// For more details see the UpdateRemoteFileContext documentation.\nfunc (api *Client) UpdateRemoteFile(fileID string, params RemoteFileParameters) (remotefile *RemoteFile, err error) {\n\treturn api.UpdateRemoteFileContext(context.Background(), fileID, params)\n}\n\n// UpdateRemoteFileContext updates a remote file with a custom context.\n// Slack API docs: https://api.slack.com/methods/files.remote.update\nfunc (api *Client) UpdateRemoteFileContext(ctx context.Context, fileID string, params RemoteFileParameters) (remotefile *RemoteFile, err error) {\n\tresponse := &remoteFileResponseFull{}\n\tvalues := url.Values{}\n\tif fileID != \"\" {\n\t\tvalues.Add(\"file\", fileID)\n\t}\n\tif params.ExternalID != \"\" {\n\t\tvalues.Add(\"external_id\", params.ExternalID)\n\t}\n\tif params.ExternalURL != \"\" {\n\t\tvalues.Add(\"external_url\", params.ExternalURL)\n\t}\n\tif params.Title != \"\" {\n\t\tvalues.Add(\"title\", params.Title)\n\t}\n\tif params.Filetype != \"\" {\n\t\tvalues.Add(\"filetype\", params.Filetype)\n\t}\n\tif params.IndexableFileContents != \"\" {\n\t\tvalues.Add(\"indexable_file_contents\", params.IndexableFileContents)\n\t}\n\tif params.PreviewImageReader != nil {\n\t\terr = postWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.remote.update\", \"preview.png\", \"preview_image\", api.token, values, params.PreviewImageReader, response, api)\n\t} else {\n\t\tvalues.Add(\"token\", api.token)\n\t\tresponse, err = api.remoteFileRequest(ctx, \"files.remote.update\", values)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.RemoteFile, response.Err()\n}\n\n// RemoveRemoteFile removes a remote file.\n// For more information see the RemoveRemoteFileContext documentation.\nfunc (api *Client) RemoveRemoteFile(externalID, fileID string) (err error) {\n\treturn api.RemoveRemoteFileContext(context.Background(), externalID, fileID)\n}\n\n// RemoveRemoteFileContext removes a remote file with a custom context\n// Slack API docs: https://api.slack.com/methods/files.remote.remove\nfunc (api *Client) RemoveRemoteFileContext(ctx context.Context, externalID, fileID string) (err error) {\n\tif fileID == \"\" && externalID == \"\" {\n\t\treturn fmt.Errorf(\"either externalID or fileID is required\")\n\t}\n\tif fileID != \"\" && externalID != \"\" {\n\t\treturn fmt.Errorf(\"don't provide both externalID and fileID\")\n\t}\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif fileID != \"\" {\n\t\tvalues.Add(\"file\", fileID)\n\t}\n\tif externalID != \"\" {\n\t\tvalues.Add(\"external_id\", externalID)\n\t}\n\t_, err = api.remoteFileRequest(ctx, \"files.remote.remove\", values)\n\treturn err\n}\n"
        },
        {
          "name": "remotefiles_test.go",
          "type": "blob",
          "size": 6.51953125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc addRemoteFileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(remoteFileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestAddRemoteFile(t *testing.T) {\n\thttp.HandleFunc(\"/files.remote.add\", addRemoteFileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := RemoteFileParameters{\n\t\tExternalID:  \"externalID\",\n\t\tExternalURL: \"http://example.com/\",\n\t\tTitle:       \"example\",\n\t}\n\tif _, err := api.AddRemoteFile(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestAddRemoteFileWithoutTitle(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := RemoteFileParameters{\n\t\tExternalID:  \"externalID\",\n\t\tExternalURL: \"http://example.com/\",\n\t}\n\tif _, err := api.AddRemoteFile(params); err != ErrParametersMissing {\n\t\tt.Errorf(\"Expected ErrParametersMissing. got %s\", err)\n\t}\n}\n\nfunc listRemoteFileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(remoteFileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestListRemoteFile(t *testing.T) {\n\thttp.HandleFunc(\"/files.remote.list\", listRemoteFileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := ListRemoteFilesParameters{}\n\tif _, err := api.ListRemoteFiles(params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc getRemoteFileInfoHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(remoteFileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestGetRemoteFileInfo(t *testing.T) {\n\thttp.HandleFunc(\"/files.remote.info\", getRemoteFileInfoHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tif _, err := api.GetRemoteFileInfo(\"ExternalID\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestGetRemoteFileInfoWithoutID(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, err := api.GetRemoteFileInfo(\"\", \"\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when both externalID and fileID is not provided, instead got nil\")\n\t}\n\tif !strings.Contains(err.Error(), \"either externalID or fileID is required\") {\n\t\tt.Errorf(\"Error message should mention a required field\")\n\t}\n}\n\nfunc TestGetRemoteFileInfoWithFileIDAndExternalID(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, err := api.GetRemoteFileInfo(\"ExternalID\", \"FileID\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when both externalID and fileID are both provided, instead got nil\")\n\t}\n\tif !strings.Contains(err.Error(), \"don't provide both externalID and fileID\") {\n\t\tt.Errorf(\"Error message should mention don't providing both externalID and fileID\")\n\t}\n}\n\nfunc shareRemoteFileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(remoteFileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestShareRemoteFile(t *testing.T) {\n\thttp.HandleFunc(\"/files.remote.share\", shareRemoteFileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tif _, err := api.ShareRemoteFile([]string{\"channel\"}, \"ExternalID\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestShareRemoteFileWithoutChannels(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tif _, err := api.ShareRemoteFile([]string{}, \"ExternalID\", \"\"); err != ErrParametersMissing {\n\t\tt.Errorf(\"Expected ErrParametersMissing. got %s\", err)\n\t}\n}\n\nfunc TestShareRemoteFileWithoutID(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\t_, err := api.ShareRemoteFile([]string{\"channel\"}, \"\", \"\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when both externalID and fileID is not provided, instead got nil\")\n\t}\n\tif !strings.Contains(err.Error(), \"either externalID or fileID is required\") {\n\t\tt.Errorf(\"Error message should mention a required field\")\n\t}\n}\n\nfunc updateRemoteFileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(remoteFileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestUpdateRemoteFile(t *testing.T) {\n\thttp.HandleFunc(\"/files.remote.update\", updateRemoteFileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tparams := RemoteFileParameters{\n\t\tExternalURL: \"http://example.com/\",\n\t\tTitle:       \"example\",\n\t}\n\tif _, err := api.UpdateRemoteFile(\"fileID\", params); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc removeRemoteFileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(remoteFileResponseFull{\n\t\tSlackResponse: SlackResponse{Ok: true}})\n\trw.Write(response)\n}\n\nfunc TestRemoveRemoteFile(t *testing.T) {\n\thttp.HandleFunc(\"/files.remote.remove\", removeRemoteFileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tif err := api.RemoveRemoteFile(\"ExternalID\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestRemoveRemoteFileWithoutID(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.RemoveRemoteFile(\"\", \"\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when both externalID and fileID is not provided, instead got nil\")\n\t}\n\tif !strings.Contains(err.Error(), \"either externalID or fileID is required\") {\n\t\tt.Errorf(\"Error message should mention a required field\")\n\t}\n}\n\nfunc TestRemoveRemoteFileWithFileIDAndExternalID(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\terr := api.RemoveRemoteFile(\"ExternalID\", \"FileID\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when both externalID and fileID are both provided, instead got nil\")\n\t}\n\tif !strings.Contains(err.Error(), \"don't provide both externalID and fileID\") {\n\t\tt.Errorf(\"Error message should mention don't providing both externalID and fileID\")\n\t}\n}\n"
        },
        {
          "name": "rtm.go",
          "type": "blob",
          "size": 4.1474609375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\twebsocketDefaultTimeout = 10 * time.Second\n\tdefaultPingInterval     = 30 * time.Second\n)\n\nconst (\n\trtmEventTypeAck                 = \"\"\n\trtmEventTypeHello               = \"hello\"\n\trtmEventTypeGoodbye             = \"goodbye\"\n\trtmEventTypePong                = \"pong\"\n\trtmEventTypeDesktopNotification = \"desktop_notification\"\n)\n\n// StartRTM calls the \"rtm.start\" endpoint and returns the provided URL and the full Info block.\n//\n// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\nfunc (api *Client) StartRTM() (info *Info, websocketURL string, err error) {\n\tctx, cancel := context.WithTimeout(context.Background(), websocketDefaultTimeout)\n\tdefer cancel()\n\n\treturn api.StartRTMContext(ctx)\n}\n\n// StartRTMContext calls the \"rtm.start\" endpoint and returns the provided URL and the full Info block with a custom context.\n//\n// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\nfunc (api *Client) StartRTMContext(ctx context.Context) (info *Info, websocketURL string, err error) {\n\tresponse := &infoResponseFull{}\n\terr = api.postMethod(ctx, \"rtm.start\", url.Values{\"token\": {api.token}}, response)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tapi.Debugln(\"Using URL:\", response.Info.URL)\n\treturn &response.Info, response.Info.URL, response.Err()\n}\n\n// ConnectRTM calls the \"rtm.connect\" endpoint and returns the provided URL and the compact Info block.\n//\n// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\nfunc (api *Client) ConnectRTM() (info *Info, websocketURL string, err error) {\n\tctx, cancel := context.WithTimeout(context.Background(), websocketDefaultTimeout)\n\tdefer cancel()\n\n\treturn api.ConnectRTMContext(ctx)\n}\n\n// ConnectRTMContext calls the \"rtm.connect\" endpoint and returns the\n// provided URL and the compact Info block with a custom context.\n//\n// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\nfunc (api *Client) ConnectRTMContext(ctx context.Context) (info *Info, websocketURL string, err error) {\n\tresponse := &infoResponseFull{}\n\terr = api.postMethod(ctx, \"rtm.connect\", url.Values{\"token\": {api.token}}, response)\n\tif err != nil {\n\t\tapi.Debugf(\"Failed to connect to RTM: %s\", err)\n\t\treturn nil, \"\", err\n\t}\n\n\tapi.Debugln(\"Using URL:\", response.Info.URL)\n\treturn &response.Info, response.Info.URL, response.Err()\n}\n\n// RTMOption options for the managed RTM.\ntype RTMOption func(*RTM)\n\n// RTMOptionUseStart as of 11th July 2017 you should prefer setting this to false, see:\n// https://api.slack.com/changelog/2017-04-start-using-rtm-connect-and-stop-using-rtm-start\nfunc RTMOptionUseStart(b bool) RTMOption {\n\treturn func(rtm *RTM) {\n\t\trtm.useRTMStart = b\n\t}\n}\n\n// RTMOptionDialer takes a gorilla websocket Dialer and uses it as the\n// Dialer when opening the websocket for the RTM connection.\nfunc RTMOptionDialer(d *websocket.Dialer) RTMOption {\n\treturn func(rtm *RTM) {\n\t\trtm.dialer = d\n\t}\n}\n\n// RTMOptionPingInterval determines how often to deliver a ping message to slack.\nfunc RTMOptionPingInterval(d time.Duration) RTMOption {\n\treturn func(rtm *RTM) {\n\t\trtm.pingInterval = d\n\t\trtm.resetDeadman()\n\t}\n}\n\n// RTMOptionConnParams installs parameters to embed into the connection URL.\nfunc RTMOptionConnParams(connParams url.Values) RTMOption {\n\treturn func(rtm *RTM) {\n\t\trtm.connParams = connParams\n\t}\n}\n\n// NewRTM returns a RTM, which provides a fully managed connection to\n// Slack's websocket-based Real-Time Messaging protocol.\nfunc (api *Client) NewRTM(options ...RTMOption) *RTM {\n\tresult := &RTM{\n\t\tClient:           *api,\n\t\tIncomingEvents:   make(chan RTMEvent, 50),\n\t\toutgoingMessages: make(chan OutgoingMessage, 20),\n\t\tpingInterval:     defaultPingInterval,\n\t\tpingDeadman:      time.NewTimer(deadmanDuration(defaultPingInterval)),\n\t\tkillChannel:      make(chan bool),\n\t\tdisconnected:     make(chan struct{}),\n\t\tdisconnectedm:    &sync.Once{},\n\t\tforcePing:        make(chan bool),\n\t\tidGen:            NewSafeID(1),\n\t\tmu:               &sync.Mutex{},\n\t}\n\n\tfor _, opt := range options {\n\t\topt(result)\n\t}\n\n\treturn result\n}\n"
        },
        {
          "name": "search.go",
          "type": "blob",
          "size": 4.548828125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\nconst (\n\tDEFAULT_SEARCH_SORT      = \"score\"\n\tDEFAULT_SEARCH_SORT_DIR  = \"desc\"\n\tDEFAULT_SEARCH_HIGHLIGHT = false\n\tDEFAULT_SEARCH_COUNT     = 20\n\tDEFAULT_SEARCH_PAGE      = 1\n)\n\ntype SearchParameters struct {\n\tTeamID        string\n\tSort          string\n\tSortDirection string\n\tHighlight     bool\n\tCount         int\n\tPage          int\n}\n\ntype CtxChannel struct {\n\tID                 string `json:\"id\"`\n\tName               string `json:\"name\"`\n\tIsExtShared        bool   `json:\"is_ext_shared\"`\n\tIsMPIM             bool   `json:\"is_mpim\"`\n\tISOrgShared        bool   `json:\"is_org_shared\"`\n\tIsPendingExtShared bool   `json:\"is_pending_ext_shared\"`\n\tIsPrivate          bool   `json:\"is_private\"`\n\tIsShared           bool   `json:\"is_shared\"`\n}\n\ntype CtxMessage struct {\n\tUser      string `json:\"user\"`\n\tUsername  string `json:\"username\"`\n\tText      string `json:\"text\"`\n\tTimestamp string `json:\"ts\"`\n\tType      string `json:\"type\"`\n}\n\ntype SearchMessage struct {\n\tType        string       `json:\"type\"`\n\tChannel     CtxChannel   `json:\"channel\"`\n\tUser        string       `json:\"user\"`\n\tUsername    string       `json:\"username\"`\n\tTimestamp   string       `json:\"ts\"`\n\tBlocks      Blocks       `json:\"blocks,omitempty\"`\n\tText        string       `json:\"text\"`\n\tPermalink   string       `json:\"permalink\"`\n\tAttachments []Attachment `json:\"attachments\"`\n\tPrevious    CtxMessage   `json:\"previous\"`\n\tPrevious2   CtxMessage   `json:\"previous_2\"`\n\tNext        CtxMessage   `json:\"next\"`\n\tNext2       CtxMessage   `json:\"next_2\"`\n}\n\ntype SearchMessages struct {\n\tMatches    []SearchMessage `json:\"matches\"`\n\tPaging     `json:\"paging\"`\n\tPagination `json:\"pagination\"`\n\tTotal      int `json:\"total\"`\n}\n\ntype SearchFiles struct {\n\tMatches    []File `json:\"matches\"`\n\tPaging     `json:\"paging\"`\n\tPagination `json:\"pagination\"`\n\tTotal      int `json:\"total\"`\n}\n\ntype searchResponseFull struct {\n\tQuery          string `json:\"query\"`\n\tSearchMessages `json:\"messages\"`\n\tSearchFiles    `json:\"files\"`\n\tSlackResponse\n}\n\nfunc NewSearchParameters() SearchParameters {\n\treturn SearchParameters{\n\t\tSort:          DEFAULT_SEARCH_SORT,\n\t\tSortDirection: DEFAULT_SEARCH_SORT_DIR,\n\t\tHighlight:     DEFAULT_SEARCH_HIGHLIGHT,\n\t\tCount:         DEFAULT_SEARCH_COUNT,\n\t\tPage:          DEFAULT_SEARCH_PAGE,\n\t}\n}\n\nfunc (api *Client) _search(ctx context.Context, path, query string, params SearchParameters, files, messages bool) (response *searchResponseFull, error error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"query\": {query},\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.Sort != DEFAULT_SEARCH_SORT {\n\t\tvalues.Add(\"sort\", params.Sort)\n\t}\n\tif params.SortDirection != DEFAULT_SEARCH_SORT_DIR {\n\t\tvalues.Add(\"sort_dir\", params.SortDirection)\n\t}\n\tif params.Highlight != DEFAULT_SEARCH_HIGHLIGHT {\n\t\tvalues.Add(\"highlight\", strconv.Itoa(1))\n\t}\n\tif params.Count != DEFAULT_SEARCH_COUNT {\n\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n\t}\n\tif params.Page != DEFAULT_SEARCH_PAGE {\n\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n\t}\n\n\tresponse = &searchResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n\n}\n\nfunc (api *Client) Search(query string, params SearchParameters) (*SearchMessages, *SearchFiles, error) {\n\treturn api.SearchContext(context.Background(), query, params)\n}\n\nfunc (api *Client) SearchContext(ctx context.Context, query string, params SearchParameters) (*SearchMessages, *SearchFiles, error) {\n\tresponse, err := api._search(ctx, \"search.all\", query, params, true, true)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn &response.SearchMessages, &response.SearchFiles, nil\n}\n\nfunc (api *Client) SearchFiles(query string, params SearchParameters) (*SearchFiles, error) {\n\treturn api.SearchFilesContext(context.Background(), query, params)\n}\n\nfunc (api *Client) SearchFilesContext(ctx context.Context, query string, params SearchParameters) (*SearchFiles, error) {\n\tresponse, err := api._search(ctx, \"search.files\", query, params, true, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.SearchFiles, nil\n}\n\nfunc (api *Client) SearchMessages(query string, params SearchParameters) (*SearchMessages, error) {\n\treturn api.SearchMessagesContext(context.Background(), query, params)\n}\n\nfunc (api *Client) SearchMessagesContext(ctx context.Context, query string, params SearchParameters) (*SearchMessages, error) {\n\tresponse, err := api._search(ctx, \"search.messages\", query, params, false, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.SearchMessages, nil\n}\n"
        },
        {
          "name": "security.go",
          "type": "blob",
          "size": 2.5556640625,
          "content": "package slack\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"hash\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Signature headers\nconst (\n\thSignature = \"X-Slack-Signature\"\n\thTimestamp = \"X-Slack-Request-Timestamp\"\n)\n\n// SecretsVerifier contains the information needed to verify that the request comes from Slack\ntype SecretsVerifier struct {\n\td         Debug\n\tsignature []byte\n\thmac      hash.Hash\n}\n\nfunc unsafeSignatureVerifier(header http.Header, secret string) (_ SecretsVerifier, err error) {\n\tvar (\n\t\tbsignature []byte\n\t)\n\n\tsignature := header.Get(hSignature)\n\tstimestamp := header.Get(hTimestamp)\n\n\tif signature == \"\" || stimestamp == \"\" {\n\t\treturn SecretsVerifier{}, ErrMissingHeaders\n\t}\n\n\tif bsignature, err = hex.DecodeString(strings.TrimPrefix(signature, \"v0=\")); err != nil {\n\t\treturn SecretsVerifier{}, err\n\t}\n\n\thash := hmac.New(sha256.New, []byte(secret))\n\tif _, err = hash.Write([]byte(fmt.Sprintf(\"v0:%s:\", stimestamp))); err != nil {\n\t\treturn SecretsVerifier{}, err\n\t}\n\n\treturn SecretsVerifier{\n\t\tsignature: bsignature,\n\t\thmac:      hash,\n\t}, nil\n}\n\n// NewSecretsVerifier returns a SecretsVerifier object in exchange for an http.Header object and signing secret\nfunc NewSecretsVerifier(header http.Header, secret string) (sv SecretsVerifier, err error) {\n\tvar (\n\t\ttimestamp int64\n\t)\n\n\tstimestamp := header.Get(hTimestamp)\n\n\tif sv, err = unsafeSignatureVerifier(header, secret); err != nil {\n\t\treturn SecretsVerifier{}, err\n\t}\n\n\tif timestamp, err = strconv.ParseInt(stimestamp, 10, 64); err != nil {\n\t\treturn SecretsVerifier{}, err\n\t}\n\n\tdiff := absDuration(time.Since(time.Unix(timestamp, 0)))\n\tif diff > 5*time.Minute {\n\t\treturn SecretsVerifier{}, ErrExpiredTimestamp\n\t}\n\n\treturn sv, err\n}\n\nfunc (v *SecretsVerifier) WithDebug(d Debug) *SecretsVerifier {\n\tv.d = d\n\treturn v\n}\n\nfunc (v *SecretsVerifier) Write(body []byte) (n int, err error) {\n\treturn v.hmac.Write(body)\n}\n\n// Ensure compares the signature sent from Slack with the actual computed hash to judge validity\nfunc (v SecretsVerifier) Ensure() error {\n\tcomputed := v.hmac.Sum(nil)\n\t// use hmac.Equal prevent leaking timing information.\n\tif hmac.Equal(computed, v.signature) {\n\t\treturn nil\n\t}\n\tif v.d != nil && v.d.Debug() {\n\t\tv.d.Debugln(fmt.Sprintf(\"Expected signing signature: %s, but computed: %s\", hex.EncodeToString(v.signature), hex.EncodeToString(computed)))\n\t}\n\treturn fmt.Errorf(\"Computed unexpected signature of: %s\", hex.EncodeToString(computed))\n}\n\nfunc abs64(n int64) int64 {\n\ty := n >> 63\n\treturn (n ^ y) - y\n}\n\nfunc absDuration(n time.Duration) time.Duration {\n\treturn time.Duration(abs64(int64(n)))\n}\n"
        },
        {
          "name": "security_test.go",
          "type": "blob",
          "size": 3.46875,
          "content": "package slack\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nconst (\n\tvalidSigningSecret   = \"e6b19c573432dcc6b075501d51b51bb8\"\n\tinvalidSigningSecret = \"e6b19c573432dcc6b075501d51b51boo\"\n\tvalidBody            = `{\"token\":\"aF5ynEYQH0dFN9imlgcADxDB\",\"team_id\":\"XXXXXXXXX\",\"api_app_id\":\"YYYYYYYYY\",\"event\":{\"type\":\"app_mention\",\"user\":\"AAAAAAAAA\",\"text\":\"<@EEEEEEEEE> hello world\",\"client_msg_id\":\"477cc591-ch73-a14z-4db8-g0cd76321bec\",\"ts\":\"1531431954.000073\",\"channel\":\"TTTTTTTTT\",\"event_ts\":\"1531431954.000073\"},\"type\":\"event_callback\",\"event_id\":\"TvBP7LRED7\",\"event_time\":1531431954,\"authed_users\":[\"EEEEEEEEE\"]}`\n\tinvalidBody          = `{\"token\":\"12345678abcdefghlmnopqrs\",\"team_id\":\"XXXXXXXXX\",\"api_app_id\":\"YYYYYYYYY\",\"event\":{\"type\":\"app_mention\",\"user\":\"AAAAAAAAA\",\"text\":\"<@EEEEEEEEE> hello world\",\"client_msg_id\":\"477cc591-ch73-a14z-4db8-g0cd76321bec\",\"ts\":\"1531431954.000073\",\"channel\":\"TTTTTTTTT\",\"event_ts\":\"1531431954.000073\"},\"type\":\"event_callback\",\"event_id\":\"TvBP7LRED7\",\"event_time\":1531431954,\"authed_users\":[\"EEEEEEEEE\"]}`\n)\n\nfunc newHeader(valid bool) http.Header {\n\th := http.Header{}\n\tif valid {\n\t\th.Set(\"X-Slack-Signature\", \"v0=adada4ed31709aef585c2580ca3267678c6a8eaeb7e0c1aca3ee57b656886b2c\")\n\t\th.Set(\"X-Slack-Request-Timestamp\", \"1531431954\")\n\t} else {\n\t\th.Set(\"X-Slack-Signature\", \"\")\n\t}\n\treturn h\n}\n\nfunc TestExpiredTimestamp(t *testing.T) {\n\t_, err := NewSecretsVerifier(newHeader(true), \"abcdefg12345\")\n\tif err == nil {\n\t\tt.Fatal(\"expected an error but got none\")\n\t}\n}\n\nfunc TestUnsafeSignatureVerifier(t *testing.T) {\n\ttests := []struct {\n\t\ttitle         string\n\t\theader        http.Header\n\t\tsigningSecret string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\ttitle:         \"Testing with acceptable params\",\n\t\t\theader:        newHeader(true),\n\t\t\tsigningSecret: \"abcdefg12345\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\ttitle:         \"Testing with unacceptable params\",\n\t\t\theader:        newHeader(false),\n\t\t\tsigningSecret: \"abcdefg12345\",\n\t\t\texpectError:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := unsafeSignatureVerifier(test.header, test.signingSecret)\n\n\t\tif !test.expectError && err != nil {\n\t\t\tlog.Fatalf(\"%s: Unexpected error: %s in test\", test.title, err)\n\t\t} else if test.expectError == true && err == nil {\n\t\t\tlog.Fatalf(\"Expected error but got none\")\n\t\t}\n\t}\n}\n\nfunc TestEnsure(t *testing.T) {\n\ttests := []struct {\n\t\ttitle         string\n\t\theader        http.Header\n\t\tsigningSecret string\n\t\tbody          string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\ttitle:         \"Testing with acceptable signing secret and valid body\",\n\t\t\theader:        newHeader(true),\n\t\t\tsigningSecret: validSigningSecret,\n\t\t\tbody:          validBody,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\ttitle:         \"Testing with unacceptable signing secret and valid body\",\n\t\t\theader:        newHeader(true),\n\t\t\tsigningSecret: invalidSigningSecret,\n\t\t\tbody:          validBody,\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\ttitle:         \"Testing with acceptable signing secret and invalid body\",\n\t\t\theader:        newHeader(true),\n\t\t\tsigningSecret: validSigningSecret,\n\t\t\tbody:          invalidBody,\n\t\t\texpectError:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tsv, err := unsafeSignatureVerifier(test.header, test.signingSecret)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tio.WriteString(&sv, test.body)\n\n\t\terr = sv.Ensure()\n\n\t\tif !test.expectError && err != nil {\n\t\t\tlog.Fatalf(\"%s: Unexpected error: %s in test\", test.title, err)\n\t\t} else if test.expectError == true && err == nil {\n\t\t\tlog.Fatalf(\"Expected error but got none\")\n\t\t}\n\t}\n\n}\n"
        },
        {
          "name": "slack.go",
          "type": "blob",
          "size": 4.46484375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n)\n\nconst (\n\t// APIURL of the slack api.\n\tAPIURL = \"https://slack.com/api/\"\n\t// WEBAPIURLFormat ...\n\tWEBAPIURLFormat = \"https://%s.slack.com/api/users.admin.%s?t=%d\"\n)\n\n// httpClient defines the minimal interface needed for an http.Client to be implemented.\ntype httpClient interface {\n\tDo(*http.Request) (*http.Response, error)\n}\n\n// ResponseMetadata holds pagination metadata\ntype ResponseMetadata struct {\n\tCursor   string   `json:\"next_cursor\"`\n\tMessages []string `json:\"messages\"`\n\tWarnings []string `json:\"warnings\"`\n}\n\nfunc (t *ResponseMetadata) initialize() *ResponseMetadata {\n\tif t != nil {\n\t\treturn t\n\t}\n\n\treturn &ResponseMetadata{}\n}\n\n// AuthTestResponse ...\ntype AuthTestResponse struct {\n\tURL    string `json:\"url\"`\n\tTeam   string `json:\"team\"`\n\tUser   string `json:\"user\"`\n\tTeamID string `json:\"team_id\"`\n\tUserID string `json:\"user_id\"`\n\t// EnterpriseID is only returned when an enterprise id present\n\tEnterpriseID string `json:\"enterprise_id,omitempty\"`\n\tBotID        string `json:\"bot_id\"`\n}\n\ntype authTestResponseFull struct {\n\tSlackResponse\n\tAuthTestResponse\n}\n\n// Client for the slack api.\ntype ParamOption func(*url.Values)\n\ntype Client struct {\n\ttoken              string\n\tappLevelToken      string\n\tconfigToken        string\n\tconfigRefreshToken string\n\tendpoint           string\n\tdebug              bool\n\tlog                ilogger\n\thttpclient         httpClient\n}\n\n// Option defines an option for a Client\ntype Option func(*Client)\n\n// OptionHTTPClient - provide a custom http client to the slack client.\nfunc OptionHTTPClient(client httpClient) func(*Client) {\n\treturn func(c *Client) {\n\t\tc.httpclient = client\n\t}\n}\n\n// OptionDebug enable debugging for the client\nfunc OptionDebug(b bool) func(*Client) {\n\treturn func(c *Client) {\n\t\tc.debug = b\n\t}\n}\n\n// OptionLog set logging for client.\nfunc OptionLog(l logger) func(*Client) {\n\treturn func(c *Client) {\n\t\tc.log = internalLog{logger: l}\n\t}\n}\n\n// OptionAPIURL set the url for the client. only useful for testing.\nfunc OptionAPIURL(u string) func(*Client) {\n\treturn func(c *Client) { c.endpoint = u }\n}\n\n// OptionAppLevelToken sets an app-level token for the client.\nfunc OptionAppLevelToken(token string) func(*Client) {\n\treturn func(c *Client) { c.appLevelToken = token }\n}\n\n// OptionConfigToken sets a configuration token for the client.\nfunc OptionConfigToken(token string) func(*Client) {\n\treturn func(c *Client) { c.configToken = token }\n}\n\n// OptionConfigRefreshToken sets a configuration refresh token for the client.\nfunc OptionConfigRefreshToken(token string) func(*Client) {\n\treturn func(c *Client) { c.configRefreshToken = token }\n}\n\n// New builds a slack client from the provided token and options.\nfunc New(token string, options ...Option) *Client {\n\ts := &Client{\n\t\ttoken:      token,\n\t\tendpoint:   APIURL,\n\t\thttpclient: &http.Client{},\n\t\tlog:        log.New(os.Stderr, \"slack-go/slack\", log.LstdFlags|log.Lshortfile),\n\t}\n\n\tfor _, opt := range options {\n\t\topt(s)\n\t}\n\n\treturn s\n}\n\n// AuthTest tests if the user is able to do authenticated requests or not\nfunc (api *Client) AuthTest() (response *AuthTestResponse, error error) {\n\treturn api.AuthTestContext(context.Background())\n}\n\n// AuthTestContext tests if the user is able to do authenticated requests or not with a custom context\nfunc (api *Client) AuthTestContext(ctx context.Context) (response *AuthTestResponse, err error) {\n\tapi.Debugf(\"Challenging auth...\")\n\tresponseFull := &authTestResponseFull{}\n\terr = api.postMethod(ctx, \"auth.test\", url.Values{\"token\": {api.token}}, responseFull)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &responseFull.AuthTestResponse, responseFull.Err()\n}\n\n// Debugf print a formatted debug line.\nfunc (api *Client) Debugf(format string, v ...interface{}) {\n\tif api.debug {\n\t\tapi.log.Output(2, fmt.Sprintf(format, v...))\n\t}\n}\n\n// Debugln print a debug line.\nfunc (api *Client) Debugln(v ...interface{}) {\n\tif api.debug {\n\t\tapi.log.Output(2, fmt.Sprintln(v...))\n\t}\n}\n\n// Debug returns if debug is enabled.\nfunc (api *Client) Debug() bool {\n\treturn api.debug\n}\n\n// post to a slack web method.\nfunc (api *Client) postMethod(ctx context.Context, path string, values url.Values, intf interface{}) error {\n\treturn postForm(ctx, api.httpclient, api.endpoint+path, values, intf, api)\n}\n\n// get a slack web method.\nfunc (api *Client) getMethod(ctx context.Context, path string, token string, values url.Values, intf interface{}) error {\n\treturn getResource(ctx, api.httpclient, api.endpoint+path, token, values, intf, api)\n}\n"
        },
        {
          "name": "slack_test.go",
          "type": "blob",
          "size": 0.3125,
          "content": "package slack\n\nimport (\n\t\"log\"\n\t\"net/http/httptest\"\n\t\"sync\"\n)\n\nconst (\n\tvalidToken = \"testing-token\"\n)\n\nvar (\n\tserverAddr string\n\tonce       sync.Once\n)\n\nfunc startServer() {\n\tserver := httptest.NewServer(nil)\n\tserverAddr = server.Listener.Addr().String()\n\tlog.Print(\"Test WebSocket server listening on \", serverAddr)\n}\n"
        },
        {
          "name": "slackevents",
          "type": "tree",
          "content": null
        },
        {
          "name": "slacktest",
          "type": "tree",
          "content": null
        },
        {
          "name": "slackutilsx",
          "type": "tree",
          "content": null
        },
        {
          "name": "slash.go",
          "type": "blob",
          "size": 2.8173828125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\n// SlashCommand contains information about a request of the slash command\ntype SlashCommand struct {\n\tToken               string `json:\"token\"`\n\tTeamID              string `json:\"team_id\"`\n\tTeamDomain          string `json:\"team_domain\"`\n\tEnterpriseID        string `json:\"enterprise_id,omitempty\"`\n\tEnterpriseName      string `json:\"enterprise_name,omitempty\"`\n\tIsEnterpriseInstall bool   `json:\"is_enterprise_install\"`\n\tChannelID           string `json:\"channel_id\"`\n\tChannelName         string `json:\"channel_name\"`\n\tUserID              string `json:\"user_id\"`\n\tUserName            string `json:\"user_name\"`\n\tCommand             string `json:\"command\"`\n\tText                string `json:\"text\"`\n\tResponseURL         string `json:\"response_url\"`\n\tTriggerID           string `json:\"trigger_id\"`\n\tAPIAppID            string `json:\"api_app_id\"`\n}\n\n// SlashCommandParse will parse the request of the slash command\nfunc SlashCommandParse(r *http.Request) (s SlashCommand, err error) {\n\tif err = r.ParseForm(); err != nil {\n\t\treturn s, err\n\t}\n\ts.Token = r.PostForm.Get(\"token\")\n\ts.TeamID = r.PostForm.Get(\"team_id\")\n\ts.TeamDomain = r.PostForm.Get(\"team_domain\")\n\ts.EnterpriseID = r.PostForm.Get(\"enterprise_id\")\n\ts.EnterpriseName = r.PostForm.Get(\"enterprise_name\")\n\ts.IsEnterpriseInstall = r.PostForm.Get(\"is_enterprise_install\") == \"true\"\n\ts.ChannelID = r.PostForm.Get(\"channel_id\")\n\ts.ChannelName = r.PostForm.Get(\"channel_name\")\n\ts.UserID = r.PostForm.Get(\"user_id\")\n\ts.UserName = r.PostForm.Get(\"user_name\")\n\ts.Command = r.PostForm.Get(\"command\")\n\ts.Text = r.PostForm.Get(\"text\")\n\ts.ResponseURL = r.PostForm.Get(\"response_url\")\n\ts.TriggerID = r.PostForm.Get(\"trigger_id\")\n\ts.APIAppID = r.PostForm.Get(\"api_app_id\")\n\treturn s, nil\n}\n\n// ValidateToken validates verificationTokens\nfunc (s SlashCommand) ValidateToken(verificationTokens ...string) bool {\n\tfor _, token := range verificationTokens {\n\t\tif s.Token == token {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// UnmarshalJSON handles is_enterprise_install being either a boolean or a\n// string when parsing JSON from various payloads\nfunc (s *SlashCommand) UnmarshalJSON(data []byte) error {\n\ttype SlashCommandCopy SlashCommand\n\tscopy := &struct {\n\t\t*SlashCommandCopy\n\t\tIsEnterpriseInstall interface{} `json:\"is_enterprise_install\"`\n\t}{\n\t\tSlashCommandCopy: (*SlashCommandCopy)(s),\n\t}\n\n\tif err := json.Unmarshal(data, scopy); err != nil {\n\t\treturn err\n\t}\n\n\tswitch rawValue := scopy.IsEnterpriseInstall.(type) {\n\tcase string:\n\t\tb, err := strconv.ParseBool(rawValue)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing boolean for is_enterprise_install: %w\", err)\n\t\t}\n\t\ts.IsEnterpriseInstall = b\n\tcase bool:\n\t\ts.IsEnterpriseInstall = rawValue\n\tdefault:\n\t\treturn fmt.Errorf(\"wrong data type for is_enterprise_install: %T\", scopy.IsEnterpriseInstall)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "slash_test.go",
          "type": "blob",
          "size": 5.0078125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestSlash_ServeHTTP(t *testing.T) {\n\tonce.Do(startServer)\n\tserverURL := fmt.Sprintf(\"http://%s/slash\", serverAddr)\n\n\ttests := []struct {\n\t\tbody           url.Values\n\t\twantParams     SlashCommand\n\t\twantStatusCode int\n\t}{\n\t\t{\n\t\t\tbody: url.Values{\n\t\t\t\t\"command\":         []string{\"/command\"},\n\t\t\t\t\"team_domain\":     []string{\"team\"},\n\t\t\t\t\"enterprise_id\":   []string{\"E0001\"},\n\t\t\t\t\"enterprise_name\": []string{\"Globular%20Construct%20Inc\"},\n\t\t\t\t\"channel_id\":      []string{\"C1234ABCD\"},\n\t\t\t\t\"text\":            []string{\"text\"},\n\t\t\t\t\"team_id\":         []string{\"T1234ABCD\"},\n\t\t\t\t\"user_id\":         []string{\"U1234ABCD\"},\n\t\t\t\t\"user_name\":       []string{\"username\"},\n\t\t\t\t\"response_url\":    []string{\"https://hooks.slack.com/commands/XXXXXXXX/00000000000/YYYYYYYYYYYYYY\"},\n\t\t\t\t\"token\":           []string{\"valid\"},\n\t\t\t\t\"channel_name\":    []string{\"channel\"},\n\t\t\t\t\"trigger_id\":      []string{\"0000000000.1111111111.222222222222aaaaaaaaaaaaaa\"},\n\t\t\t\t\"api_app_id\":      []string{\"A123456\"},\n\t\t\t},\n\t\t\twantParams: SlashCommand{\n\t\t\t\tCommand:        \"/command\",\n\t\t\t\tTeamDomain:     \"team\",\n\t\t\t\tEnterpriseID:   \"E0001\",\n\t\t\t\tEnterpriseName: \"Globular%20Construct%20Inc\",\n\t\t\t\tChannelID:      \"C1234ABCD\",\n\t\t\t\tText:           \"text\",\n\t\t\t\tTeamID:         \"T1234ABCD\",\n\t\t\t\tUserID:         \"U1234ABCD\",\n\t\t\t\tUserName:       \"username\",\n\t\t\t\tResponseURL:    \"https://hooks.slack.com/commands/XXXXXXXX/00000000000/YYYYYYYYYYYYYY\",\n\t\t\t\tToken:          \"valid\",\n\t\t\t\tChannelName:    \"channel\",\n\t\t\t\tTriggerID:      \"0000000000.1111111111.222222222222aaaaaaaaaaaaaa\",\n\t\t\t\tAPIAppID:       \"A123456\",\n\t\t\t},\n\t\t\twantStatusCode: http.StatusOK,\n\t\t},\n\t\t{\n\t\t\tbody: url.Values{\n\t\t\t\t\"token\": []string{\"invalid\"},\n\t\t\t},\n\t\t\twantParams: SlashCommand{\n\t\t\t\tToken: \"invalid\",\n\t\t\t},\n\t\t\twantStatusCode: http.StatusUnauthorized,\n\t\t},\n\t}\n\n\tvar slashCommand SlashCommand\n\tclient := &http.Client{}\n\thttp.HandleFunc(\"/slash\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvar err error\n\t\tslashCommand, err = SlashCommandParse(r)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t}\n\t\tacceptableTokens := []string{\"valid\", \"valid2\"}\n\t\tif !slashCommand.ValidateToken(acceptableTokens...) {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t}\n\t})\n\n\tfor i, test := range tests {\n\t\treq, err := http.NewRequest(http.MethodPost, serverURL, strings.NewReader(test.body.Encode()))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\n\t\tif resp.StatusCode != test.wantStatusCode {\n\t\t\tt.Errorf(\"%d: Got status code %d, want %d\", i, resp.StatusCode, test.wantStatusCode)\n\t\t}\n\t\tif !reflect.DeepEqual(slashCommand, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, slashCommand, test.wantParams)\n\t\t}\n\t\tresp.Body.Close()\n\t}\n}\n\nfunc TestSlash_UnmarshalJSON(t *testing.T) {\n\ttests := []struct {\n\t\tbody                    string\n\t\twantIsEnterpriseInstall bool\n\t\twantToken               string\n\t\twantUnmarshalError      string\n\t}{\n\t\t{\n\t\t\tbody:                    `{\"token\":\"blahblah\",\"is_enterprise_install\":\"false\"}`,\n\t\t\twantIsEnterpriseInstall: false,\n\t\t\twantToken:               \"blahblah\",\n\t\t\twantUnmarshalError:      \"\",\n\t\t},\n\t\t{\n\t\t\tbody:                    `{\"token\":\"blahblah\",\"is_enterprise_install\":false}`,\n\t\t\twantIsEnterpriseInstall: false,\n\t\t\twantToken:               \"blahblah\",\n\t\t\twantUnmarshalError:      \"\",\n\t\t},\n\t\t{\n\t\t\tbody:                    `{\"token\":\"blahblah\",\"is_enterprise_install\":\"true\"}`,\n\t\t\twantIsEnterpriseInstall: true,\n\t\t\twantToken:               \"blahblah\",\n\t\t\twantUnmarshalError:      \"\",\n\t\t},\n\t\t{\n\t\t\tbody:                    `{\"token\":\"blahblah\",\"is_enterprise_install\":true}`,\n\t\t\twantIsEnterpriseInstall: true,\n\t\t\twantToken:               \"blahblah\",\n\t\t\twantUnmarshalError:      \"\",\n\t\t},\n\t\t{\n\t\t\tbody:               `{\"token\":\"blahblah\",\"is_enterprise_install\":42}`,\n\t\t\twantUnmarshalError: \"wrong data type for is_enterprise_install: float64\",\n\t\t},\n\t\t{\n\t\t\tbody:               `{\"token\":\"blahblah\",\"is_enterprise_install\":\"unconvertable to bool\"}`,\n\t\t\twantUnmarshalError: \"parsing boolean for is_enterprise_install: strconv.ParseBool: parsing \\\"unconvertable to bool\\\": invalid syntax\",\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar result SlashCommand\n\n\t\terr := json.Unmarshal([]byte(test.body), &result)\n\t\tif err != nil {\n\t\t\tif err.Error() != test.wantUnmarshalError {\n\t\t\t\tt.Errorf(\"%d: Got error %v, want error %q\", i, err, test.wantUnmarshalError)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.wantUnmarshalError != \"\" {\n\t\t\tt.Errorf(\"%d: Got no error, want error %q\", i, test.wantUnmarshalError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result.IsEnterpriseInstall != test.wantIsEnterpriseInstall {\n\t\t\tt.Errorf(\"%d: Got IsEnterpriseInstall %v, want IsEnterpriseInstall %v\", i, result.IsEnterpriseInstall, test.wantIsEnterpriseInstall)\n\t\t}\n\n\t\tif result.Token != test.wantToken {\n\t\t\tt.Errorf(\"%d: Got Token %v, want Token %v\", i, result.Token, test.wantToken)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "socket_mode.go",
          "type": "blob",
          "size": 1.1025390625,
          "content": "package slack\n\nimport (\n\t\"context\"\n)\n\n// SocketModeConnection contains various details about the SocketMode connection.\n// It is returned by an \"apps.connections.open\" API call.\ntype SocketModeConnection struct {\n\tURL  string                 `json:\"url,omitempty\"`\n\tData map[string]interface{} `json:\"-\"`\n}\n\ntype openResponseFull struct {\n\tSlackResponse\n\tSocketModeConnection\n}\n\n// StartSocketModeContext calls the \"apps.connections.open\" endpoint and returns the provided URL and the full Info block with a custom context.\n//\n// To have a fully managed Socket Mode connection, use `socketmode.New()`, and call `Run()` on it.\nfunc (api *Client) StartSocketModeContext(ctx context.Context) (info *SocketModeConnection, websocketURL string, err error) {\n\tresponse := &openResponseFull{}\n\terr = postJSON(ctx, api.httpclient, api.endpoint+\"apps.connections.open\", api.appLevelToken, nil, response, api)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif response.Err() == nil {\n\t\tapi.Debugln(\"Using URL:\", response.SocketModeConnection.URL)\n\t}\n\n\treturn &response.SocketModeConnection, response.SocketModeConnection.URL, response.Err()\n}\n"
        },
        {
          "name": "socketmode",
          "type": "tree",
          "content": null
        },
        {
          "name": "stars.go",
          "type": "blob",
          "size": 7.041015625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n)\n\nconst (\n\tDEFAULT_STARS_USER  = \"\"\n\tDEFAULT_STARS_COUNT = 100\n\tDEFAULT_STARS_PAGE  = 1\n)\n\ntype StarsParameters struct {\n\tUser  string\n\tCount int\n\tPage  int\n}\n\ntype StarredItem Item\n\ntype listResponseFull struct {\n\tItems  []Item `json:\"items\"`\n\tPaging `json:\"paging\"`\n\tSlackResponse\n}\n\n// NewStarsParameters initialises StarsParameters with default values\nfunc NewStarsParameters() StarsParameters {\n\treturn StarsParameters{\n\t\tUser:  DEFAULT_STARS_USER,\n\t\tCount: DEFAULT_STARS_COUNT,\n\t\tPage:  DEFAULT_STARS_PAGE,\n\t}\n}\n\n// AddStar stars an item in a channel.\n// For more information see the AddStarContext documentation.\nfunc (api *Client) AddStar(channel string, item ItemRef) error {\n\treturn api.AddStarContext(context.Background(), channel, item)\n}\n\n// AddStarContext stars an item in a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/stars.add\nfunc (api *Client) AddStarContext(ctx context.Context, channel string, item ItemRef) error {\n\tvalues := url.Values{\n\t\t\"channel\": {channel},\n\t\t\"token\":   {api.token},\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"stars.add\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// RemoveStar removes a starred item from a channel.\n// For more information see the RemoveStarContext documentation.\nfunc (api *Client) RemoveStar(channel string, item ItemRef) error {\n\treturn api.RemoveStarContext(context.Background(), channel, item)\n}\n\n// RemoveStarContext removes a starred item from a channel with a custom context.\n// Slack API docs: https://api.slack.com/methods/stars.remove\nfunc (api *Client) RemoveStarContext(ctx context.Context, channel string, item ItemRef) error {\n\tvalues := url.Values{\n\t\t\"channel\": {channel},\n\t\t\"token\":   {api.token},\n\t}\n\tif item.Timestamp != \"\" {\n\t\tvalues.Set(\"timestamp\", item.Timestamp)\n\t}\n\tif item.File != \"\" {\n\t\tvalues.Set(\"file\", item.File)\n\t}\n\tif item.Comment != \"\" {\n\t\tvalues.Set(\"file_comment\", item.Comment)\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := api.postMethod(ctx, \"stars.remove\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// ListStars returns information about the stars a user added.\n// For more information see the ListStarsContext documentation.\nfunc (api *Client) ListStars(params StarsParameters) ([]Item, *Paging, error) {\n\treturn api.ListStarsContext(context.Background(), params)\n}\n\n// ListStarsContext returns information about the stars a user added with a custom context.\n// Slack API docs: https://api.slack.com/methods/stars.list\nfunc (api *Client) ListStarsContext(ctx context.Context, params StarsParameters) ([]Item, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.User != DEFAULT_STARS_USER {\n\t\tvalues.Add(\"user\", params.User)\n\t}\n\tif params.Count != DEFAULT_STARS_COUNT {\n\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n\t}\n\tif params.Page != DEFAULT_STARS_PAGE {\n\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n\t}\n\n\tresponse := &listResponseFull{}\n\terr := api.postMethod(ctx, \"stars.list\", values, response)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := response.Err(); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn response.Items, &response.Paging, nil\n}\n\n// GetStarred returns a list of StarredItem items.\n//\n// The user then has to iterate over them and figure out what they should\n// be looking at according to what is in the Type:\n//\n//\tfor _, item := range items {\n//\t    switch c.Type {\n//\t    case \"file_comment\":\n//\t        log.Println(c.Comment)\n//\t    case \"file\":\n//\t        ...\n//\t}\n//\n// This function still exists to maintain backwards compatibility.\n// I exposed it as returning []StarredItem, so it shall stay as StarredItem.\nfunc (api *Client) GetStarred(params StarsParameters) ([]StarredItem, *Paging, error) {\n\treturn api.GetStarredContext(context.Background(), params)\n}\n\n// GetStarredContext returns a list of StarredItem items with a custom context\n// For more details see GetStarred\nfunc (api *Client) GetStarredContext(ctx context.Context, params StarsParameters) ([]StarredItem, *Paging, error) {\n\titems, paging, err := api.ListStarsContext(ctx, params)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tstarredItems := make([]StarredItem, len(items))\n\tfor i, item := range items {\n\t\tstarredItems[i] = StarredItem(item)\n\t}\n\treturn starredItems, paging, nil\n}\n\ntype listResponsePaginated struct {\n\tItems []Item `json:\"items\"`\n\tSlackResponse\n\tMetadata ResponseMetadata `json:\"response_metadata\"`\n}\n\n// StarredItemPagination allows for paginating over the starred items\ntype StarredItemPagination struct {\n\tItems        []Item\n\tlimit        int\n\tpreviousResp *ResponseMetadata\n\tc            *Client\n}\n\n// ListStarsOption options for the GetUsers method call.\ntype ListStarsOption func(*StarredItemPagination)\n\n// ListAllStars returns the complete list of starred items\nfunc (api *Client) ListAllStars() ([]Item, error) {\n\treturn api.ListAllStarsContext(context.Background())\n}\n\n// ListAllStarsContext returns the list of users (with their detailed information) with a custom context\nfunc (api *Client) ListAllStarsContext(ctx context.Context) (results []Item, err error) {\n\tp := api.ListStarsPaginated()\n\tfor err == nil {\n\t\tp, err = p.next(ctx)\n\t\tif err == nil {\n\t\t\tresults = append(results, p.Items...)\n\t\t} else if rateLimitedError, ok := err.(*RateLimitedError); ok {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\terr = ctx.Err()\n\t\t\tcase <-time.After(rateLimitedError.RetryAfter):\n\t\t\t\terr = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results, p.failure(err)\n}\n\n// ListStarsPaginated fetches users in a paginated fashion, see ListStarsPaginationContext for usage.\nfunc (api *Client) ListStarsPaginated(options ...ListStarsOption) StarredItemPagination {\n\treturn newStarPagination(api, options...)\n}\n\nfunc newStarPagination(c *Client, options ...ListStarsOption) (sip StarredItemPagination) {\n\tsip = StarredItemPagination{\n\t\tc:     c,\n\t\tlimit: 200, // per slack api documentation.\n\t}\n\n\tfor _, opt := range options {\n\t\topt(&sip)\n\t}\n\n\treturn sip\n}\n\n// done checks if the pagination has completed\nfunc (StarredItemPagination) done(err error) bool {\n\treturn err == errPaginationComplete\n}\n\n// done checks if pagination failed.\nfunc (t StarredItemPagination) failure(err error) error {\n\tif t.done(err) {\n\t\treturn nil\n\t}\n\n\treturn err\n}\n\n// next gets the next list of starred items based on the cursor value\nfunc (t StarredItemPagination) next(ctx context.Context) (_ StarredItemPagination, err error) {\n\tvar (\n\t\tresp *listResponsePaginated\n\t)\n\n\tif t.c == nil || (t.previousResp != nil && t.previousResp.Cursor == \"\") {\n\t\treturn t, errPaginationComplete\n\t}\n\n\tt.previousResp = t.previousResp.initialize()\n\n\tvalues := url.Values{\n\t\t\"limit\":  {strconv.Itoa(t.limit)},\n\t\t\"token\":  {t.c.token},\n\t\t\"cursor\": {t.previousResp.Cursor},\n\t}\n\n\tif err = t.c.postMethod(ctx, \"stars.list\", values, &resp); err != nil {\n\t\treturn t, err\n\t}\n\n\tt.previousResp = &resp.Metadata\n\tt.Items = resp.Items\n\n\treturn t, nil\n}\n"
        },
        {
          "name": "stars_test.go",
          "type": "blob",
          "size": 6.552734375,
          "content": "package slack\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype starsHandler struct {\n\tgotParams map[string]string\n\tresponse  string\n}\n\nfunc newStarsHandler() *starsHandler {\n\treturn &starsHandler{\n\t\tgotParams: make(map[string]string),\n\t\tresponse:  `{ \"ok\": true }`,\n\t}\n}\n\nfunc (sh *starsHandler) accumulateFormValue(k string, r *http.Request) {\n\tif v := r.FormValue(k); v != \"\" {\n\t\tsh.gotParams[k] = v\n\t}\n}\n\nfunc (sh *starsHandler) handler(w http.ResponseWriter, r *http.Request) {\n\tsh.accumulateFormValue(\"user\", r)\n\tsh.accumulateFormValue(\"count\", r)\n\tsh.accumulateFormValue(\"channel\", r)\n\tsh.accumulateFormValue(\"file\", r)\n\tsh.accumulateFormValue(\"file_comment\", r)\n\tsh.accumulateFormValue(\"page\", r)\n\tsh.accumulateFormValue(\"timestamp\", r)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write([]byte(sh.response))\n}\n\nfunc TestSlack_AddStar(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tchannel    string\n\t\tref        ItemRef\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\": \"ChannelID\",\n\t\t\t\t\"file\":    \"FileID\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":      \"ChannelID\",\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *starsHandler\n\thttp.HandleFunc(\"/stars.add\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newStarsHandler()\n\t\terr := api.AddStar(test.channel, test.ref)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_RemoveStar(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\ttests := []struct {\n\t\tchannel    string\n\t\tref        ItemRef\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToMessage(\"ChannelID\", \"123\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":   \"ChannelID\",\n\t\t\t\t\"timestamp\": \"123\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToFile(\"FileID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\": \"ChannelID\",\n\t\t\t\t\"file\":    \"FileID\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"ChannelID\",\n\t\t\tNewRefToComment(\"FileCommentID\"),\n\t\t\tmap[string]string{\n\t\t\t\t\"channel\":      \"ChannelID\",\n\t\t\t\t\"file_comment\": \"FileCommentID\",\n\t\t\t},\n\t\t},\n\t}\n\tvar rh *starsHandler\n\thttp.HandleFunc(\"/stars.remove\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\tfor i, test := range tests {\n\t\trh = newStarsHandler()\n\t\terr := api.RemoveStar(test.channel, test.ref)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc TestSlack_ListStars(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\trh := newStarsHandler()\n\thttp.HandleFunc(\"/stars.list\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\trh.response = `{\"ok\": true,\n    \"items\": [\n        {\n            \"type\": \"message\",\n            \"channel\": \"C1\",\n            \"message\": {\n                \"text\": \"hello\",\n                \"reactions\": [\n                    {\n                        \"name\": \"astonished\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\", \"U3\" ]\n                    },\n                    {\n                        \"name\": \"clock1\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\" ]\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"file\",\n            \"file\": {\n                \"name\": \"toy\",\n                \"reactions\": [\n                    {\n                        \"name\": \"clock1\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\" ]\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"file_comment\",\n            \"file\": {\n                \"name\": \"toy\"\n            },\n            \"comment\": {\n                \"comment\": \"cool toy\",\n                \"reactions\": [\n                    {\n                        \"name\": \"astonished\",\n                        \"count\": 3,\n                        \"users\": [ \"U1\", \"U2\", \"U3\" ]\n                    }\n                ]\n            }\n        }\n    ],\n    \"paging\": {\n        \"count\": 100,\n        \"total\": 4,\n        \"page\": 1,\n        \"pages\": 1\n    }}`\n\twant := []Item{\n\t\tNewMessageItem(\"C1\", &Message{Msg: Msg{\n\t\t\tText: \"hello\",\n\t\t\tReactions: []ItemReaction{\n\t\t\t\t{Name: \"astonished\", Count: 3, Users: []string{\"U1\", \"U2\", \"U3\"}},\n\t\t\t\t{Name: \"clock1\", Count: 3, Users: []string{\"U1\", \"U2\"}},\n\t\t\t},\n\t\t}}),\n\t\tNewFileItem(&File{Name: \"toy\"}),\n\t\tNewFileCommentItem(&File{Name: \"toy\"}, &Comment{Comment: \"cool toy\"}),\n\t}\n\twantStarred := make([]StarredItem, len(want))\n\tfor i, item := range want {\n\t\twantStarred[i] = StarredItem(item)\n\t}\n\twantParams := map[string]string{\n\t\t\"count\": \"200\",\n\t\t\"page\":  \"2\",\n\t}\n\tparams := NewStarsParameters()\n\tparams.Count = 200\n\tparams.Page = 2\n\tgot, paging, err := api.ListStars(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Got Stars %#v, want %#v\", got, want)\n\t\tfor i, item := range got {\n\t\t\tfmt.Printf(\"Item %d, Type: %s\\n\", i, item.Type)\n\t\t\tfmt.Printf(\"Message  %#v\\n\", item.Message)\n\t\t\tfmt.Printf(\"File     %#v\\n\", item.File)\n\t\t\tfmt.Printf(\"Comment  %#v\\n\", item.Comment)\n\t\t}\n\t}\n\tif !reflect.DeepEqual(rh.gotParams, wantParams) {\n\t\tt.Errorf(\"Got params %#v, want %#v\", rh.gotParams, wantParams)\n\t}\n\tif reflect.DeepEqual(paging, Paging{}) {\n\t\tt.Errorf(\"Want paging data, got empty struct\")\n\t}\n\t// Test GetStarred\n\tgotStarred, paging, err := api.GetStarred(params)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\tif !reflect.DeepEqual(gotStarred, wantStarred) {\n\t\tt.Errorf(\"Got Stars %#v, want %#v\", gotStarred, wantStarred)\n\t\tfor i, item := range got {\n\t\t\tfmt.Printf(\"Item %d, Type: %s\\n\", i, item.Type)\n\t\t\tfmt.Printf(\"Message  %#v\\n\", item.Message)\n\t\t\tfmt.Printf(\"File     %#v\\n\", item.File)\n\t\t\tfmt.Printf(\"Comment  %#v\\n\", item.Comment)\n\t\t}\n\t}\n\tif !reflect.DeepEqual(rh.gotParams, wantParams) {\n\t\tt.Errorf(\"Got params %#v, want %#v\", rh.gotParams, wantParams)\n\t}\n\tif reflect.DeepEqual(paging, Paging{}) {\n\t\tt.Errorf(\"Want paging data, got empty struct\")\n\t}\n}\n"
        },
        {
          "name": "status_code_error.go",
          "type": "blob",
          "size": 0.5234375,
          "content": "package slack\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// StatusCodeError represents an http response error.\n// type httpStatusCode interface { HTTPStatusCode() int } to handle it.\ntype StatusCodeError struct {\n\tCode   int\n\tStatus string\n}\n\nfunc (t StatusCodeError) Error() string {\n\treturn fmt.Sprintf(\"slack server error: %s\", t.Status)\n}\n\nfunc (t StatusCodeError) HTTPStatusCode() int {\n\treturn t.Code\n}\n\nfunc (t StatusCodeError) Retryable() bool {\n\tif t.Code >= 500 || t.Code == http.StatusTooManyRequests {\n\t\treturn true\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "team.go",
          "type": "blob",
          "size": 7.3408203125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\nconst (\n\tDEFAULT_LOGINS_COUNT = 100\n\tDEFAULT_LOGINS_PAGE  = 1\n)\n\ntype TeamResponse struct {\n\tTeam TeamInfo `json:\"team\"`\n\tSlackResponse\n}\n\ntype TeamInfo struct {\n\tID          string                 `json:\"id\"`\n\tName        string                 `json:\"name\"`\n\tDomain      string                 `json:\"domain\"`\n\tEmailDomain string                 `json:\"email_domain\"`\n\tIcon        map[string]interface{} `json:\"icon\"`\n}\n\ntype TeamProfileResponse struct {\n\tProfile TeamProfile `json:\"profile\"`\n\tSlackResponse\n}\n\ntype TeamProfile struct {\n\tFields []TeamProfileField `json:\"fields\"`\n}\n\ntype TeamProfileField struct {\n\tID             string          `json:\"id\"`\n\tOrdering       int             `json:\"ordering\"`\n\tLabel          string          `json:\"label\"`\n\tHint           string          `json:\"hint\"`\n\tType           string          `json:\"type\"`\n\tPossibleValues []string        `json:\"possible_values\"`\n\tIsHidden       bool            `json:\"is_hidden\"`\n\tOptions        map[string]bool `json:\"options\"`\n}\n\ntype LoginResponse struct {\n\tLogins []Login `json:\"logins\"`\n\tPaging `json:\"paging\"`\n\tSlackResponse\n}\n\ntype Login struct {\n\tUserID    string `json:\"user_id\"`\n\tUsername  string `json:\"username\"`\n\tDateFirst int    `json:\"date_first\"`\n\tDateLast  int    `json:\"date_last\"`\n\tCount     int    `json:\"count\"`\n\tIP        string `json:\"ip\"`\n\tUserAgent string `json:\"user_agent\"`\n\tISP       string `json:\"isp\"`\n\tCountry   string `json:\"country\"`\n\tRegion    string `json:\"region\"`\n}\n\ntype BillableInfoResponse struct {\n\tBillableInfo map[string]BillingActive `json:\"billable_info\"`\n\tSlackResponse\n}\n\ntype BillingActive struct {\n\tBillingActive bool `json:\"billing_active\"`\n}\n\n// AccessLogParameters contains all the parameters necessary (including the optional ones) for a GetAccessLogs() request\ntype AccessLogParameters struct {\n\tTeamID string\n\tCount  int\n\tPage   int\n}\n\n// NewAccessLogParameters provides an instance of AccessLogParameters with all the sane default values set\nfunc NewAccessLogParameters() AccessLogParameters {\n\treturn AccessLogParameters{\n\t\tCount: DEFAULT_LOGINS_COUNT,\n\t\tPage:  DEFAULT_LOGINS_PAGE,\n\t}\n}\n\nfunc (api *Client) teamRequest(ctx context.Context, path string, values url.Values) (*TeamResponse, error) {\n\tresponse := &TeamResponse{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\nfunc (api *Client) billableInfoRequest(ctx context.Context, path string, values url.Values) (map[string]BillingActive, error) {\n\tresponse := &BillableInfoResponse{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response.BillableInfo, response.Err()\n}\n\nfunc (api *Client) accessLogsRequest(ctx context.Context, path string, values url.Values) (*LoginResponse, error) {\n\tresponse := &LoginResponse{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n\nfunc (api *Client) teamProfileRequest(ctx context.Context, client httpClient, path string, values url.Values) (*TeamProfileResponse, error) {\n\tresponse := &TeamProfileResponse{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response, response.Err()\n}\n\n// GetTeamInfo gets the Team Information of the user.\n// For more information see the GetTeamInfoContext documentation.\nfunc (api *Client) GetTeamInfo() (*TeamInfo, error) {\n\treturn api.GetTeamInfoContext(context.Background())\n}\n\n// GetOtherTeamInfoContext gets Team information for any team with a custom context.\n// Slack API docs: https://api.slack.com/methods/team.info\nfunc (api *Client) GetOtherTeamInfoContext(ctx context.Context, team string) (*TeamInfo, error) {\n\tif team == \"\" {\n\t\treturn api.GetTeamInfoContext(ctx)\n\t}\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tvalues.Add(\"team\", team)\n\tresponse, err := api.teamRequest(ctx, \"team.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.Team, nil\n}\n\n// GetOtherTeamInfo gets Team information for any team.\n// For more information see the GetOtherTeamInfoContext documentation.\nfunc (api *Client) GetOtherTeamInfo(team string) (*TeamInfo, error) {\n\treturn api.GetOtherTeamInfoContext(context.Background(), team)\n}\n\n// GetTeamInfoContext gets the Team Information of the user with a custom context.\n// Slack API docs: https://api.slack.com/methods/team.info\nfunc (api *Client) GetTeamInfoContext(ctx context.Context) (*TeamInfo, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tresponse, err := api.teamRequest(ctx, \"team.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.Team, nil\n}\n\n// GetTeamProfile gets the Team Profile settings of the user.\n// For more information see the GetTeamProfileContext documentation.\nfunc (api *Client) GetTeamProfile(teamID ...string) (*TeamProfile, error) {\n\treturn api.GetTeamProfileContext(context.Background(), teamID...)\n}\n\n// GetTeamProfileContext gets the Team Profile settings of the user with a custom context.\n// Slack API docs: https://api.slack.com/methods/team.profile.get\nfunc (api *Client) GetTeamProfileContext(ctx context.Context, teamID ...string) (*TeamProfile, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif len(teamID) > 0 {\n\t\tvalues[\"team_id\"] = teamID\n\t}\n\n\tresponse, err := api.teamProfileRequest(ctx, api.httpclient, \"team.profile.get\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.Profile, nil\n}\n\n// GetAccessLogs retrieves a page of logins according to the parameters given.\n// For more information see the GetAccessLogsContext documentation.\nfunc (api *Client) GetAccessLogs(params AccessLogParameters) ([]Login, *Paging, error) {\n\treturn api.GetAccessLogsContext(context.Background(), params)\n}\n\n// GetAccessLogsContext retrieves a page of logins according to the parameters given with a custom context.\n// Slack API docs: https://api.slack.com/methods/team.accessLogs\nfunc (api *Client) GetAccessLogsContext(ctx context.Context, params AccessLogParameters) ([]Login, *Paging, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.Count != DEFAULT_LOGINS_COUNT {\n\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n\t}\n\tif params.Page != DEFAULT_LOGINS_PAGE {\n\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n\t}\n\n\tresponse, err := api.accessLogsRequest(ctx, \"team.accessLogs\", values)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn response.Logins, &response.Paging, nil\n}\n\ntype GetBillableInfoParams struct {\n\tUser   string\n\tTeamID string\n}\n\n// GetBillableInfo gets the billable users information of the team.\n// For more information see the GetBillableInfoContext documentation.\nfunc (api *Client) GetBillableInfo(params GetBillableInfoParams) (map[string]BillingActive, error) {\n\treturn api.GetBillableInfoContext(context.Background(), params)\n}\n\n// GetBillableInfoContext gets the billable users information of the team with a custom context.\n// Slack API docs: https://api.slack.com/methods/team.billableInfo\nfunc (api *Client) GetBillableInfoContext(ctx context.Context, params GetBillableInfoParams) (map[string]BillingActive, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\n\tif params.User != \"\" {\n\t\tvalues.Add(\"user\", params.User)\n\t}\n\n\treturn api.billableInfoRequest(ctx, \"team.billableInfo\", values)\n}\n"
        },
        {
          "name": "team_test.go",
          "type": "blob",
          "size": 5.6015625,
          "content": "package slack\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar (\n\tErrIncorrectResponse = errors.New(\"Response is incorrect\")\n)\n\nfunc getTeamInfo(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\"ok\": true, \"team\": {\n\t\t\t\"id\": \"F0UWHUX\",\n\t\t\t\"name\": \"notalar\",\n\t\t\t\"domain\": \"notalar\",\n\t\t\t\"icon\": {\n              \"image_34\": \"https://slack.global.ssl.fastly.net/66f9/img/avatars-teams/ava_0002-34.png\",\n              \"image_44\": \"https://slack.global.ssl.fastly.net/66f9/img/avatars-teams/ava_0002-44.png\",\n              \"image_55\": \"https://slack.global.ssl.fastly.net/66f9/img/avatars-teams/ava_0002-55.png\",\n              \"image_default\": true\n          }\n\t\t}}`)\n\trw.Write(response)\n}\n\nfunc TestGetTeamInfo(t *testing.T) {\n\thttp.HandleFunc(\"/team.info\", getTeamInfo)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tteamInfo, err := api.GetTeamInfo()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\t// t.Fatal refers to -> t.Errorf & return\n\tif teamInfo.ID != \"F0UWHUX\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif teamInfo.Domain != \"notalar\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif teamInfo.Name != \"notalar\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif teamInfo.Icon == nil {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc getTeamProfile(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\n\t\t\"ok\":true,\n\t\t\"profile\":{\n\t\t\t \"fields\":[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\":\"XXXD7KN555\",\n\t\t\t\t\t\t\"ordering\":2,\n\t\t\t\t\t\t\"field_name\":\"\",\n\t\t\t\t\t\t\"label\":\"Skype\",\n\t\t\t\t\t\t\"hint\":\"This will be displayed on your profile.\",\n\t\t\t\t\t\t\"type\":\"text\",\n\t\t\t\t\t\t\"possible_values\":null,\n\t\t\t\t\t\t\"options\":null,\n\t\t\t\t\t\t\"is_hidden\":true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\":\"XXXGGE5AAN7\",\n\t\t\t\t\t\"ordering\":4,\n\t\t\t\t\t\"field_name\":\"title\",\n\t\t\t\t\t\"label\":\"Title\",\n\t\t\t\t\t\"hint\":\"\",\n\t\t\t\t\t\"type\":\"text\",\n\t\t\t\t\t\"possible_values\":null,\n\t\t\t\t\t\"options\":{\n\t\t\t\t\t\t\"is_protected\":true,\n\t\t\t\t\t\t\"is_scim\":true\n\t\t\t\t\t},\n\t\t\t\t\t\"is_hidden\":false\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}`)\n\n\trw.Write(response)\n}\n\nfunc TestGetTeamProfile(t *testing.T) {\n\thttp.HandleFunc(\"/team.profile.get\", getTeamProfile)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tteamProfile, err := api.GetTeamProfile()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\t// t.Fatal refers to -> t.Errorf & return\n\tif teamProfile.Fields[0].ID != \"XXXD7KN555\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif teamProfile.Fields[0].Label != \"Skype\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\n\tif teamProfile.Fields[1].ID != \"XXXGGE5AAN7\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif teamProfile.Fields[1].Label != \"Title\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif !teamProfile.Fields[1].Options[\"is_protected\"] {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\n}\n\nfunc getTeamAccessLogs(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\"ok\": true, \"logins\": [{\n\t\t\t\"user_id\": \"F0UWHUX\",\n\t\t\t\"username\": \"notalar\",\n\t\t\t\"date_first\": 1475684477,\n\t\t\t\"date_last\": 1475684645,\n\t\t\t\"count\": 8,\n\t\t\t\"ip\": \"127.0.0.1\",\n\t\t\t\"user_agent\": \"SlackWeb/3abb0ae2380d48a9ae20c58cc624ebcd Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Slack/1.2.6 Chrome/45.0.2454.85 AtomShell/0.34.3 Safari/537.36 Slack_SSB/1.2.6\",\n\t\t\t\"isp\": \"AT&T U-verse\",\n                        \"country\": \"US\",\n                        \"region\": \"IN\"\n                        },\n                        {\n                        \"user_id\": \"XUHWU0F\",\n\t\t\t\"username\": \"ralaton\",\n\t\t\t\"date_first\": 1447395893,\n\t\t\t\"date_last\": 1447395965,\n\t\t\t\"count\": 5,\n\t\t\t\"ip\": \"192.168.0.1\",\n\t\t\t\"user_agent\": \"com.tinyspeck.chatlyio/2.60 (iPhone; iOS 9.1; Scale/3.00)\",\n\t\t\t\"isp\": null,\n                        \"country\": null,\n                        \"region\": null\n                        }],\n                        \"paging\": {\n    \t\t\t\"count\": 2,\n    \t\t\t\"total\": 2,\n    \t\t\t\"page\": 1,\n    \t\t\t\"pages\": 1\n    \t\t\t}\n  }`)\n\trw.Write(response)\n}\n\nfunc TestGetAccessLogs(t *testing.T) {\n\thttp.HandleFunc(\"/team.accessLogs\", getTeamAccessLogs)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tlogins, paging, err := api.GetAccessLogs(NewAccessLogParameters())\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\tif len(logins) != 2 {\n\t\tt.Fatal(\"Should have been 2 logins\")\n\t}\n\n\t// test the first login\n\tlogin1 := logins[0]\n\tlogin2 := logins[1]\n\n\tif login1.UserID != \"F0UWHUX\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.Username != \"notalar\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.DateFirst != 1475684477 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.DateLast != 1475684645 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.Count != 8 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.IP != \"127.0.0.1\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif !strings.HasPrefix(login1.UserAgent, \"SlackWeb\") {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.ISP != \"AT&T U-verse\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.Country != \"US\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login1.Region != \"IN\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\n\t// test that the null values from login2 are coming across correctly\n\tif login2.ISP != \"\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login2.Country != \"\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif login2.Region != \"\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\n\t// test the paging\n\tif paging.Count != 2 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif paging.Total != 2 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif paging.Page != 1 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif paging.Pages != 1 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n"
        },
        {
          "name": "tokens.go",
          "type": "blob",
          "size": 1.6005859375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n)\n\n// RotateTokens exchanges a refresh token for a new app configuration token.\n// For more information see the RotateTokensContext documentation.\nfunc (api *Client) RotateTokens(configToken string, refreshToken string) (*TokenResponse, error) {\n\treturn api.RotateTokensContext(context.Background(), configToken, refreshToken)\n}\n\n// RotateTokensContext exchanges a refresh token for a new app configuration token with a custom context.\n// Slack API docs: https://api.slack.com/methods/tooling.tokens.rotate\nfunc (api *Client) RotateTokensContext(ctx context.Context, configToken string, refreshToken string) (*TokenResponse, error) {\n\tif configToken == \"\" {\n\t\tconfigToken = api.configToken\n\t}\n\n\tif refreshToken == \"\" {\n\t\trefreshToken = api.configRefreshToken\n\t}\n\n\tvalues := url.Values{\n\t\t\"refresh_token\": {refreshToken},\n\t}\n\n\tresponse := &TokenResponse{}\n\terr := api.getMethod(ctx, \"tooling.tokens.rotate\", configToken, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// UpdateConfigTokens replaces the configuration tokens in the client with those returned by the API\nfunc (api *Client) UpdateConfigTokens(response *TokenResponse) {\n\tapi.configToken = response.Token\n\tapi.configRefreshToken = response.RefreshToken\n}\n\ntype TokenResponse struct {\n\tToken        string `json:\"token,omitempty\"`\n\tRefreshToken string `json:\"refresh_token,omitempty\"`\n\tTeamId       string `json:\"team_id,omitempty\"`\n\tUserId       string `json:\"user_id,omitempty\"`\n\tIssuedAt     uint64 `json:\"iat,omitempty\"`\n\tExpiresAt    uint64 `json:\"exp,omitempty\"`\n\tSlackResponse\n}\n"
        },
        {
          "name": "tokens_test.go",
          "type": "blob",
          "size": 0.9482421875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestRotateTokens(t *testing.T) {\n\thttp.HandleFunc(\"/tooling.tokens.rotate\", handleRotateToken)\n\texpected := getTestTokenResponse()\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\ttok, err := api.RotateTokens(\"expired-config\", \"old-refresh\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual(expected, *tok) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc getTestTokenResponse() TokenResponse {\n\treturn TokenResponse{\n\t\tToken:         \"token\",\n\t\tRefreshToken:  \"refresh\",\n\t\tUserId:        \"uid\",\n\t\tTeamId:        \"tid\",\n\t\tIssuedAt:      1,\n\t\tExpiresAt:     1,\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t}\n}\n\nfunc handleRotateToken(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tresponse, _ := json.Marshal(getTestTokenResponse())\n\trw.Write(response)\n}\n"
        },
        {
          "name": "usergroups.go",
          "type": "blob",
          "size": 10.640625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// UserGroup contains all the information of a user group\ntype UserGroup struct {\n\tID          string         `json:\"id\"`\n\tTeamID      string         `json:\"team_id\"`\n\tIsUserGroup bool           `json:\"is_usergroup\"`\n\tName        string         `json:\"name\"`\n\tDescription string         `json:\"description\"`\n\tHandle      string         `json:\"handle\"`\n\tIsExternal  bool           `json:\"is_external\"`\n\tDateCreate  JSONTime       `json:\"date_create\"`\n\tDateUpdate  JSONTime       `json:\"date_update\"`\n\tDateDelete  JSONTime       `json:\"date_delete\"`\n\tAutoType    string         `json:\"auto_type\"`\n\tCreatedBy   string         `json:\"created_by\"`\n\tUpdatedBy   string         `json:\"updated_by\"`\n\tDeletedBy   string         `json:\"deleted_by\"`\n\tPrefs       UserGroupPrefs `json:\"prefs\"`\n\tUserCount   int            `json:\"user_count\"`\n\tUsers       []string       `json:\"users\"`\n}\n\n// UserGroupPrefs contains default channels and groups (private channels)\ntype UserGroupPrefs struct {\n\tChannels []string `json:\"channels\"`\n\tGroups   []string `json:\"groups\"`\n}\n\ntype userGroupResponseFull struct {\n\tUserGroups []UserGroup `json:\"usergroups\"`\n\tUserGroup  UserGroup   `json:\"usergroup\"`\n\tUsers      []string    `json:\"users\"`\n\tSlackResponse\n}\n\nfunc (api *Client) userGroupRequest(ctx context.Context, path string, values url.Values) (*userGroupResponseFull, error) {\n\tresponse := &userGroupResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// CreateUserGroup creates a new user group.\n// For more information see the CreateUserGroupContext documentation.\nfunc (api *Client) CreateUserGroup(userGroup UserGroup) (UserGroup, error) {\n\treturn api.CreateUserGroupContext(context.Background(), userGroup)\n}\n\n// CreateUserGroupContext creates a new user group with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.create\nfunc (api *Client) CreateUserGroupContext(ctx context.Context, userGroup UserGroup) (UserGroup, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"name\":  {userGroup.Name},\n\t}\n\n\tif userGroup.TeamID != \"\" {\n\t\tvalues[\"team_id\"] = []string{userGroup.TeamID}\n\t}\n\n\tif userGroup.Handle != \"\" {\n\t\tvalues[\"handle\"] = []string{userGroup.Handle}\n\t}\n\n\tif userGroup.Description != \"\" {\n\t\tvalues[\"description\"] = []string{userGroup.Description}\n\t}\n\n\tif len(userGroup.Prefs.Channels) > 0 {\n\t\tvalues[\"channels\"] = []string{strings.Join(userGroup.Prefs.Channels, \",\")}\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.create\", values)\n\tif err != nil {\n\t\treturn UserGroup{}, err\n\t}\n\treturn response.UserGroup, nil\n}\n\n// DisableUserGroup disables an existing user group.\n// For more information see the DisableUserGroupContext documentation.\nfunc (api *Client) DisableUserGroup(userGroup string) (UserGroup, error) {\n\treturn api.DisableUserGroupContext(context.Background(), userGroup)\n}\n\n// DisableUserGroupContext disables an existing user group with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.disable\nfunc (api *Client) DisableUserGroupContext(ctx context.Context, userGroup string) (UserGroup, error) {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"usergroup\": {userGroup},\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.disable\", values)\n\tif err != nil {\n\t\treturn UserGroup{}, err\n\t}\n\treturn response.UserGroup, nil\n}\n\n// EnableUserGroup enables an existing user group.\n// For more information see the EnableUserGroupContext documentation.\nfunc (api *Client) EnableUserGroup(userGroup string) (UserGroup, error) {\n\treturn api.EnableUserGroupContext(context.Background(), userGroup)\n}\n\n// EnableUserGroupContext enables an existing user group with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.enable\nfunc (api *Client) EnableUserGroupContext(ctx context.Context, userGroup string) (UserGroup, error) {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"usergroup\": {userGroup},\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.enable\", values)\n\tif err != nil {\n\t\treturn UserGroup{}, err\n\t}\n\treturn response.UserGroup, nil\n}\n\n// GetUserGroupsOption options for the GetUserGroups method call.\ntype GetUserGroupsOption func(*GetUserGroupsParams)\n\nfunc GetUserGroupsOptionWithTeamID(teamID string) GetUserGroupsOption {\n\treturn func(params *GetUserGroupsParams) {\n\t\tparams.TeamID = teamID\n\t}\n}\n\n// GetUserGroupsOptionIncludeCount include the number of users in each User Group (default: false)\nfunc GetUserGroupsOptionIncludeCount(b bool) GetUserGroupsOption {\n\treturn func(params *GetUserGroupsParams) {\n\t\tparams.IncludeCount = b\n\t}\n}\n\n// GetUserGroupsOptionIncludeDisabled include disabled User Groups (default: false)\nfunc GetUserGroupsOptionIncludeDisabled(b bool) GetUserGroupsOption {\n\treturn func(params *GetUserGroupsParams) {\n\t\tparams.IncludeDisabled = b\n\t}\n}\n\n// GetUserGroupsOptionIncludeUsers include the list of users for each User Group (default: false)\nfunc GetUserGroupsOptionIncludeUsers(b bool) GetUserGroupsOption {\n\treturn func(params *GetUserGroupsParams) {\n\t\tparams.IncludeUsers = b\n\t}\n}\n\n// GetUserGroupsParams contains arguments for GetUserGroups method call\ntype GetUserGroupsParams struct {\n\tTeamID          string\n\tIncludeCount    bool\n\tIncludeDisabled bool\n\tIncludeUsers    bool\n}\n\n// GetUserGroups returns a list of user groups for the team.\n// For more information see the GetUserGroupsContext documentation.\nfunc (api *Client) GetUserGroups(options ...GetUserGroupsOption) ([]UserGroup, error) {\n\treturn api.GetUserGroupsContext(context.Background(), options...)\n}\n\n// GetUserGroupsContext returns a list of user groups for the team with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.list\nfunc (api *Client) GetUserGroupsContext(ctx context.Context, options ...GetUserGroupsOption) ([]UserGroup, error) {\n\tparams := GetUserGroupsParams{}\n\n\tfor _, opt := range options {\n\t\topt(&params)\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tif params.TeamID != \"\" {\n\t\tvalues.Add(\"team_id\", params.TeamID)\n\t}\n\tif params.IncludeCount {\n\t\tvalues.Add(\"include_count\", \"true\")\n\t}\n\tif params.IncludeDisabled {\n\t\tvalues.Add(\"include_disabled\", \"true\")\n\t}\n\tif params.IncludeUsers {\n\t\tvalues.Add(\"include_users\", \"true\")\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.list\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn response.UserGroups, nil\n}\n\n// UpdateUserGroupsOption options for the UpdateUserGroup method call.\ntype UpdateUserGroupsOption func(*UpdateUserGroupsParams)\n\n// UpdateUserGroupsOptionName change the name of the User Group (default: empty, so it's no-op)\nfunc UpdateUserGroupsOptionName(name string) UpdateUserGroupsOption {\n\treturn func(params *UpdateUserGroupsParams) {\n\t\tparams.Name = name\n\t}\n}\n\n// UpdateUserGroupsOptionHandle change the handle of the User Group (default: empty, so it's no-op)\nfunc UpdateUserGroupsOptionHandle(handle string) UpdateUserGroupsOption {\n\treturn func(params *UpdateUserGroupsParams) {\n\t\tparams.Handle = handle\n\t}\n}\n\n// UpdateUserGroupsOptionDescription change the description of the User Group. (default: nil, so it's no-op)\nfunc UpdateUserGroupsOptionDescription(description *string) UpdateUserGroupsOption {\n\treturn func(params *UpdateUserGroupsParams) {\n\t\tparams.Description = description\n\t}\n}\n\n// UpdateUserGroupsOptionChannels change the default channels of the User Group. (default: unspecified, so it's no-op)\nfunc UpdateUserGroupsOptionChannels(channels []string) UpdateUserGroupsOption {\n\treturn func(params *UpdateUserGroupsParams) {\n\t\tparams.Channels = &channels\n\t}\n}\n\n// UpdateUserGroupsParams contains arguments for UpdateUserGroup method call\ntype UpdateUserGroupsParams struct {\n\tName        string\n\tHandle      string\n\tDescription *string\n\tChannels    *[]string\n}\n\n// UpdateUserGroup will update an existing user group.\n// For more information see the UpdateUserGroupContext documentation.\nfunc (api *Client) UpdateUserGroup(userGroupID string, options ...UpdateUserGroupsOption) (UserGroup, error) {\n\treturn api.UpdateUserGroupContext(context.Background(), userGroupID, options...)\n}\n\n// UpdateUserGroupContext will update an existing user group with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.update\nfunc (api *Client) UpdateUserGroupContext(ctx context.Context, userGroupID string, options ...UpdateUserGroupsOption) (UserGroup, error) {\n\tparams := UpdateUserGroupsParams{}\n\n\tfor _, opt := range options {\n\t\topt(&params)\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"usergroup\": {userGroupID},\n\t}\n\n\tif params.Name != \"\" {\n\t\tvalues[\"name\"] = []string{params.Name}\n\t}\n\n\tif params.Handle != \"\" {\n\t\tvalues[\"handle\"] = []string{params.Handle}\n\t}\n\n\tif params.Description != nil {\n\t\tvalues[\"description\"] = []string{*params.Description}\n\t}\n\n\tif params.Channels != nil {\n\t\tvalues[\"channels\"] = []string{strings.Join(*params.Channels, \",\")}\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.update\", values)\n\tif err != nil {\n\t\treturn UserGroup{}, err\n\t}\n\treturn response.UserGroup, nil\n}\n\n// GetUserGroupMembers will retrieve the current list of users in a group.\n// For more information see the GetUserGroupMembersContext documentation.\nfunc (api *Client) GetUserGroupMembers(userGroup string) ([]string, error) {\n\treturn api.GetUserGroupMembersContext(context.Background(), userGroup)\n}\n\n// GetUserGroupMembersContext will retrieve the current list of users in a group with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.users.list\nfunc (api *Client) GetUserGroupMembersContext(ctx context.Context, userGroup string) ([]string, error) {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"usergroup\": {userGroup},\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.users.list\", values)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\treturn response.Users, nil\n}\n\n// UpdateUserGroupMembers will update the members of an existing user group.\n// For more information see the UpdateUserGroupMembersContext documentation.\nfunc (api *Client) UpdateUserGroupMembers(userGroup string, members string) (UserGroup, error) {\n\treturn api.UpdateUserGroupMembersContext(context.Background(), userGroup, members)\n}\n\n// UpdateUserGroupMembersContext will update the members of an existing user group with a custom context.\n// Slack API docs: https://api.slack.com/methods/usergroups.update\nfunc (api *Client) UpdateUserGroupMembersContext(ctx context.Context, userGroup string, members string) (UserGroup, error) {\n\tvalues := url.Values{\n\t\t\"token\":     {api.token},\n\t\t\"usergroup\": {userGroup},\n\t\t\"users\":     {members},\n\t}\n\n\tresponse, err := api.userGroupRequest(ctx, \"usergroups.users.update\", values)\n\tif err != nil {\n\t\treturn UserGroup{}, err\n\t}\n\treturn response.UserGroup, nil\n}\n"
        },
        {
          "name": "usergroups_test.go",
          "type": "blob",
          "size": 6.98828125,
          "content": "package slack\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype userGroupsHandler struct {\n\tgotParams map[string]string\n\tresponse  string\n}\n\nfunc newUserGroupsHandler() *userGroupsHandler {\n\treturn &userGroupsHandler{\n\t\tgotParams: make(map[string]string),\n\t\tresponse: `{\n    \"ok\": true,\n    \"usergroup\": {\n        \"id\": \"S0615G0KT\",\n        \"team_id\": \"T060RNRCH\",\n        \"is_usergroup\": true,\n        \"name\": \"Marketing Team\",\n        \"description\": \"Marketing gurus, PR experts and product advocates.\",\n        \"handle\": \"marketing-team\",\n        \"is_external\": false,\n        \"date_create\": 1446746793,\n        \"date_update\": 1446746793,\n        \"date_delete\": 0,\n        \"auto_type\": null,\n        \"created_by\": \"U060RNRCZ\",\n        \"updated_by\": \"U060RNRCZ\",\n        \"deleted_by\": null,\n        \"prefs\": {\n            \"channels\": [\n\n            ],\n            \"groups\": [\n\n            ]\n        },\n        \"user_count\": 0\n    }\n}`,\n\t}\n}\n\nfunc (ugh *userGroupsHandler) handler(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tfor k, v := range r.Form {\n\t\tugh.gotParams[k] = v[0]\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write([]byte(ugh.response))\n}\n\nfunc TestCreateUserGroup(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\ttests := []struct {\n\t\tuserGroup  UserGroup\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\tUserGroup{\n\t\t\t\tName:        \"Marketing Team\",\n\t\t\t\tDescription: \"Marketing gurus, PR experts and product advocates.\",\n\t\t\t\tHandle:      \"marketing-team\"},\n\t\t\tmap[string]string{\n\t\t\t\t\"token\":       \"testing-token\",\n\t\t\t\t\"name\":        \"Marketing Team\",\n\t\t\t\t\"description\": \"Marketing gurus, PR experts and product advocates.\",\n\t\t\t\t\"handle\":      \"marketing-team\",\n\t\t\t},\n\t\t},\n\t}\n\n\tvar rh *userGroupsHandler\n\thttp.HandleFunc(\"/usergroups.create\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\n\tfor i, test := range tests {\n\t\trh = newUserGroupsHandler()\n\t\t_, err := api.CreateUserGroup(test.userGroup)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n\nfunc getUserGroups(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\n    \"ok\": true,\n    \"usergroups\": [\n        {\n            \"id\": \"S0614TZR7\",\n            \"team_id\": \"T060RNRCH\",\n            \"is_usergroup\": true,\n            \"name\": \"Team Admins\",\n            \"description\": \"A group of all Administrators on your team.\",\n            \"handle\": \"admins\",\n            \"is_external\": false,\n            \"date_create\": 1446598059,\n            \"date_update\": 1446670362,\n            \"date_delete\": 0,\n            \"auto_type\": \"admin\",\n            \"created_by\": \"USLACKBOT\",\n            \"updated_by\": \"U060RNRCZ\",\n            \"deleted_by\": null,\n            \"prefs\": {\n                \"channels\": [\n                  \"channel1\",\n                  \"channel2\"\n                ],\n                \"groups\": [\n                  \"group1\",\n                  \"group2\",\n                  \"group3\"\n                ]\n\t\t\t},\n            \"users\": [\n                \"user1\",\n                \"user2\"\n            ],\n            \"user_count\": 2\n        }\n    ]\n}`)\n\trw.Write(response)\n}\n\nfunc TestGetUserGroups(t *testing.T) {\n\thttp.HandleFunc(\"/usergroups.list\", getUserGroups)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tuserGroups, err := api.GetUserGroups(GetUserGroupsOptionIncludeUsers(true))\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\t// t.Fatal refers to -> t.Errorf & return\n\tif len(userGroups) != 1 {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\n\tS0614TZR7 := UserGroup{\n\t\tID:          \"S0614TZR7\",\n\t\tTeamID:      \"T060RNRCH\",\n\t\tIsUserGroup: true,\n\t\tName:        \"Team Admins\",\n\t\tDescription: \"A group of all Administrators on your team.\",\n\t\tHandle:      \"admins\",\n\t\tIsExternal:  false,\n\t\tDateCreate:  1446598059,\n\t\tDateUpdate:  1446670362,\n\t\tDateDelete:  0,\n\t\tAutoType:    \"admin\",\n\t\tCreatedBy:   \"USLACKBOT\",\n\t\tUpdatedBy:   \"U060RNRCZ\",\n\t\tDeletedBy:   \"\",\n\t\tPrefs: UserGroupPrefs{\n\t\t\tChannels: []string{\"channel1\", \"channel2\"},\n\t\t\tGroups:   []string{\"group1\", \"group2\", \"group3\"},\n\t\t},\n\t\tUsers: []string{\n\t\t\t\"user1\",\n\t\t\t\"user2\",\n\t\t},\n\t\tUserCount: 2,\n\t}\n\n\tif !reflect.DeepEqual(userGroups[0], S0614TZR7) {\n\t\tt.Errorf(\"Got %#v, want %#v\", userGroups[0], S0614TZR7)\n\t}\n}\n\nfunc updateUserGroupsHandler() *userGroupsHandler {\n\treturn &userGroupsHandler{\n\t\tgotParams: make(map[string]string),\n\t\tresponse: `{\n    \"ok\": true,\n    \"usergroup\": {\n        \"id\": \"S0615G0KT\",\n        \"team_id\": \"T060RNRCH\",\n        \"is_usergroup\": true,\n        \"name\": \"Marketing Team\",\n        \"description\": \"Marketing gurus, PR experts and product advocates.\",\n        \"handle\": \"marketing-team\",\n        \"is_external\": false,\n        \"date_create\": 1446746793,\n        \"date_update\": 1446746793,\n        \"date_delete\": 0,\n        \"auto_type\": null,\n        \"created_by\": \"U060RNRCZ\",\n        \"updated_by\": \"U060RNRCZ\",\n        \"deleted_by\": null,\n        \"prefs\": {\n            \"channels\": [\n\t\t\t\t\"channel1\",\n\t\t\t\t\"channel2\"\n            ],\n            \"groups\": [\n\n            ]\n        },\n        \"user_count\": 0\n    }\n}`,\n\t}\n}\nfunc TestUpdateUserGroup(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\temptyDescription := \"\"\n\tpresenceDescription := \"Marketing gurus, PR experts and product advocates.\"\n\n\ttests := []struct {\n\t\toptions    []UpdateUserGroupsOption\n\t\twantParams map[string]string\n\t}{\n\t\t{\n\t\t\t[]UpdateUserGroupsOption{\n\t\t\t\tUpdateUserGroupsOptionName(\"Marketing Team\"),\n\t\t\t\tUpdateUserGroupsOptionHandle(\"marketing-team\"),\n\t\t\t},\n\t\t\tmap[string]string{\n\t\t\t\t\"token\":     \"testing-token\",\n\t\t\t\t\"usergroup\": \"S0615G0KT\",\n\t\t\t\t\"name\":      \"Marketing Team\",\n\t\t\t\t\"handle\":    \"marketing-team\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t[]UpdateUserGroupsOption{\n\t\t\t\tUpdateUserGroupsOptionDescription(&presenceDescription),\n\t\t\t\tUpdateUserGroupsOptionChannels([]string{\"channel1\", \"channel2\"}),\n\t\t\t},\n\t\t\tmap[string]string{\n\t\t\t\t\"token\":       \"testing-token\",\n\t\t\t\t\"usergroup\":   \"S0615G0KT\",\n\t\t\t\t\"description\": \"Marketing gurus, PR experts and product advocates.\",\n\t\t\t\t\"channels\":    \"channel1,channel2\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t[]UpdateUserGroupsOption{\n\t\t\t\tUpdateUserGroupsOptionDescription(&emptyDescription),\n\t\t\t\tUpdateUserGroupsOptionChannels([]string{}),\n\t\t\t},\n\t\t\tmap[string]string{\n\t\t\t\t\"token\":       \"testing-token\",\n\t\t\t\t\"usergroup\":   \"S0615G0KT\",\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"channels\":    \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tvar rh *userGroupsHandler\n\thttp.HandleFunc(\"/usergroups.update\", func(w http.ResponseWriter, r *http.Request) { rh.handler(w, r) })\n\n\tfor i, test := range tests {\n\t\trh = updateUserGroupsHandler()\n\t\t_, err := api.UpdateUserGroup(\"S0615G0KT\", test.options...)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%d: Unexpected error: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(rh.gotParams, test.wantParams) {\n\t\t\tt.Errorf(\"%d: Got params %#v, want %#v\", i, rh.gotParams, test.wantParams)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "users.go",
          "type": "blob",
          "size": 26.0908203125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tDEFAULT_USER_PHOTO_CROP_X = -1\n\tDEFAULT_USER_PHOTO_CROP_Y = -1\n\tDEFAULT_USER_PHOTO_CROP_W = -1\n)\n\n// UserProfile contains all the information details of a given user\ntype UserProfile struct {\n\tFirstName              string                              `json:\"first_name,omitempty\"`\n\tLastName               string                              `json:\"last_name,omitempty\"`\n\tRealName               string                              `json:\"real_name\"`\n\tRealNameNormalized     string                              `json:\"real_name_normalized\"`\n\tDisplayName            string                              `json:\"display_name\"`\n\tDisplayNameNormalized  string                              `json:\"display_name_normalized\"`\n\tAvatarHash             string                              `json:\"avatar_hash\"`\n\tEmail                  string                              `json:\"email,omitempty\"`\n\tSkype                  string                              `json:\"skyp,omitempty\"`\n\tPhone                  string                              `json:\"phone,omitempty\"`\n\tImage24                string                              `json:\"image_24\"`\n\tImage32                string                              `json:\"image_32\"`\n\tImage48                string                              `json:\"image_48\"`\n\tImage72                string                              `json:\"image_72\"`\n\tImage192               string                              `json:\"image_192\"`\n\tImage512               string                              `json:\"image_512\"`\n\tImageOriginal          string                              `json:\"image_original,omitempty\"`\n\tTitle                  string                              `json:\"title,omitempty\"`\n\tBotID                  string                              `json:\"bot_id,omitempty\"`\n\tApiAppID               string                              `json:\"api_app_id,omitempty\"`\n\tStatusText             string                              `json:\"status_text,omitempty\"`\n\tStatusEmoji            string                              `json:\"status_emoji,omitempty\"`\n\tStatusEmojiDisplayInfo []UserProfileStatusEmojiDisplayInfo `json:\"status_emoji_display_info,omitempty\"`\n\tStatusExpiration       int                                 `json:\"status_expiration,omitempty\"`\n\tTeam                   string                              `json:\"team\"`\n\tFields                 UserProfileCustomFields             `json:\"fields,omitempty\"`\n}\n\ntype UserProfileStatusEmojiDisplayInfo struct {\n\tEmojiName    string `json:\"emoji_name\"`\n\tDisplayAlias string `json:\"display_alias,omitempty\"`\n\tDisplayURL   string `json:\"display_url,omitempty\"`\n\tUnicode      string `json:\"unicode,omitempty\"`\n}\n\n// UserProfileCustomFields represents user profile's custom fields.\n// Slack API's response data type is inconsistent so we use the struct.\n// For detail, please see below.\n// https://github.com/slack-go/slack/pull/298#discussion_r185159233\ntype UserProfileCustomFields struct {\n\tfields map[string]UserProfileCustomField\n}\n\n// UnmarshalJSON is the implementation of the json.Unmarshaler interface.\nfunc (fields *UserProfileCustomFields) UnmarshalJSON(b []byte) error {\n\t// https://github.com/slack-go/slack/pull/298#discussion_r185159233\n\tif string(b) == \"[]\" {\n\t\treturn nil\n\t}\n\treturn json.Unmarshal(b, &fields.fields)\n}\n\n// MarshalJSON is the implementation of the json.Marshaler interface.\nfunc (fields UserProfileCustomFields) MarshalJSON() ([]byte, error) {\n\tif len(fields.fields) == 0 {\n\t\treturn []byte(\"[]\"), nil\n\t}\n\treturn json.Marshal(fields.fields)\n}\n\n// ToMap returns a map of custom fields.\nfunc (fields *UserProfileCustomFields) ToMap() map[string]UserProfileCustomField {\n\treturn fields.fields\n}\n\n// Len returns the number of custom fields.\nfunc (fields *UserProfileCustomFields) Len() int {\n\treturn len(fields.fields)\n}\n\n// SetMap sets a map of custom fields.\nfunc (fields *UserProfileCustomFields) SetMap(m map[string]UserProfileCustomField) {\n\tfields.fields = m\n}\n\n// FieldsMap returns a map of custom fields.\nfunc (profile *UserProfile) FieldsMap() map[string]UserProfileCustomField {\n\treturn profile.Fields.ToMap()\n}\n\n// SetFieldsMap sets a map of custom fields.\nfunc (profile *UserProfile) SetFieldsMap(m map[string]UserProfileCustomField) {\n\tprofile.Fields.SetMap(m)\n}\n\n// UserProfileCustomField represents a custom user profile field\ntype UserProfileCustomField struct {\n\tValue string `json:\"value\"`\n\tAlt   string `json:\"alt\"`\n\tLabel string `json:\"label\"`\n}\n\n// User contains all the information of a user\ntype User struct {\n\tID                string         `json:\"id\"`\n\tTeamID            string         `json:\"team_id\"`\n\tName              string         `json:\"name\"`\n\tDeleted           bool           `json:\"deleted\"`\n\tColor             string         `json:\"color\"`\n\tRealName          string         `json:\"real_name\"`\n\tTZ                string         `json:\"tz,omitempty\"`\n\tTZLabel           string         `json:\"tz_label\"`\n\tTZOffset          int            `json:\"tz_offset\"`\n\tProfile           UserProfile    `json:\"profile\"`\n\tIsBot             bool           `json:\"is_bot\"`\n\tIsAdmin           bool           `json:\"is_admin\"`\n\tIsOwner           bool           `json:\"is_owner\"`\n\tIsPrimaryOwner    bool           `json:\"is_primary_owner\"`\n\tIsRestricted      bool           `json:\"is_restricted\"`\n\tIsUltraRestricted bool           `json:\"is_ultra_restricted\"`\n\tIsStranger        bool           `json:\"is_stranger\"`\n\tIsAppUser         bool           `json:\"is_app_user\"`\n\tIsInvitedUser     bool           `json:\"is_invited_user\"`\n\tHas2FA            bool           `json:\"has_2fa\"`\n\tTwoFactorType     *string        `json:\"two_factor_type\"`\n\tHasFiles          bool           `json:\"has_files\"`\n\tPresence          string         `json:\"presence\"`\n\tLocale            string         `json:\"locale\"`\n\tUpdated           JSONTime       `json:\"updated\"`\n\tEnterprise        EnterpriseUser `json:\"enterprise_user,omitempty\"`\n}\n\n// UserPresence contains details about a user online status\ntype UserPresence struct {\n\tPresence        string   `json:\"presence,omitempty\"`\n\tOnline          bool     `json:\"online,omitempty\"`\n\tAutoAway        bool     `json:\"auto_away,omitempty\"`\n\tManualAway      bool     `json:\"manual_away,omitempty\"`\n\tConnectionCount int      `json:\"connection_count,omitempty\"`\n\tLastActivity    JSONTime `json:\"last_activity,omitempty\"`\n}\n\ntype UserIdentityResponse struct {\n\tUser UserIdentity `json:\"user\"`\n\tTeam TeamIdentity `json:\"team\"`\n\tSlackResponse\n}\n\ntype UserIdentity struct {\n\tID       string `json:\"id\"`\n\tName     string `json:\"name\"`\n\tEmail    string `json:\"email\"`\n\tImage24  string `json:\"image_24\"`\n\tImage32  string `json:\"image_32\"`\n\tImage48  string `json:\"image_48\"`\n\tImage72  string `json:\"image_72\"`\n\tImage192 string `json:\"image_192\"`\n\tImage512 string `json:\"image_512\"`\n}\n\n// EnterpriseUser is present when a user is part of Slack Enterprise Grid\n// https://api.slack.com/types/user#enterprise_grid_user_objects\ntype EnterpriseUser struct {\n\tID             string   `json:\"id\"`\n\tEnterpriseID   string   `json:\"enterprise_id\"`\n\tEnterpriseName string   `json:\"enterprise_name\"`\n\tIsAdmin        bool     `json:\"is_admin\"`\n\tIsOwner        bool     `json:\"is_owner\"`\n\tTeams          []string `json:\"teams\"`\n}\n\ntype TeamIdentity struct {\n\tID            string `json:\"id\"`\n\tName          string `json:\"name\"`\n\tDomain        string `json:\"domain\"`\n\tImage34       string `json:\"image_34\"`\n\tImage44       string `json:\"image_44\"`\n\tImage68       string `json:\"image_68\"`\n\tImage88       string `json:\"image_88\"`\n\tImage102      string `json:\"image_102\"`\n\tImage132      string `json:\"image_132\"`\n\tImage230      string `json:\"image_230\"`\n\tImageDefault  bool   `json:\"image_default\"`\n\tImageOriginal string `json:\"image_original\"`\n}\n\ntype userResponseFull struct {\n\tMembers []User `json:\"members,omitempty\"`\n\tUser    `json:\"user,omitempty\"`\n\tUsers   []User `json:\"users,omitempty\"`\n\tUserPresence\n\tSlackResponse\n\tMetadata ResponseMetadata `json:\"response_metadata\"`\n}\n\ntype UserSetPhotoParams struct {\n\tCropX int\n\tCropY int\n\tCropW int\n}\n\nfunc NewUserSetPhotoParams() UserSetPhotoParams {\n\treturn UserSetPhotoParams{\n\t\tCropX: DEFAULT_USER_PHOTO_CROP_X,\n\t\tCropY: DEFAULT_USER_PHOTO_CROP_Y,\n\t\tCropW: DEFAULT_USER_PHOTO_CROP_W,\n\t}\n}\n\nfunc (api *Client) userRequest(ctx context.Context, path string, values url.Values) (*userResponseFull, error) {\n\tresponse := &userResponseFull{}\n\terr := api.postMethod(ctx, path, values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, response.Err()\n}\n\n// GetUserPresence will retrieve the current presence status of given user.\n// For more information see the GetUserPresenceContext documentation.\nfunc (api *Client) GetUserPresence(user string) (*UserPresence, error) {\n\treturn api.GetUserPresenceContext(context.Background(), user)\n}\n\n// GetUserPresenceContext will retrieve the current presence status of given user with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.getPresence\nfunc (api *Client) GetUserPresenceContext(ctx context.Context, user string) (*UserPresence, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"user\":  {user},\n\t}\n\n\tresponse, err := api.userRequest(ctx, \"users.getPresence\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.UserPresence, nil\n}\n\n// GetUserInfo will retrieve the complete user information.\n// For more information see the GetUserInfoContext documentation.\nfunc (api *Client) GetUserInfo(user string) (*User, error) {\n\treturn api.GetUserInfoContext(context.Background(), user)\n}\n\n// GetUserInfoContext will retrieve the complete user information with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.info\nfunc (api *Client) GetUserInfoContext(ctx context.Context, user string) (*User, error) {\n\tvalues := url.Values{\n\t\t\"token\":          {api.token},\n\t\t\"user\":           {user},\n\t\t\"include_locale\": {strconv.FormatBool(true)},\n\t}\n\n\tresponse, err := api.userRequest(ctx, \"users.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.User, nil\n}\n\n// GetUsersInfo will retrieve the complete multi-users information.\n// For more information see the GetUsersInfoContext documentation.\nfunc (api *Client) GetUsersInfo(users ...string) (*[]User, error) {\n\treturn api.GetUsersInfoContext(context.Background(), users...)\n}\n\n// GetUsersInfoContext will retrieve the complete multi-users information with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.info\nfunc (api *Client) GetUsersInfoContext(ctx context.Context, users ...string) (*[]User, error) {\n\tvalues := url.Values{\n\t\t\"token\":          {api.token},\n\t\t\"users\":          {strings.Join(users, \",\")},\n\t\t\"include_locale\": {strconv.FormatBool(true)},\n\t}\n\n\tresponse, err := api.userRequest(ctx, \"users.info\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.Users, nil\n}\n\n// GetUsersOption options for the GetUsers method call.\ntype GetUsersOption func(*UserPagination)\n\n// GetUsersOptionLimit limit the number of users returned\nfunc GetUsersOptionLimit(n int) GetUsersOption {\n\treturn func(p *UserPagination) {\n\t\tp.limit = n\n\t}\n}\n\n// GetUsersOptionPresence include user presence\nfunc GetUsersOptionPresence(n bool) GetUsersOption {\n\treturn func(p *UserPagination) {\n\t\tp.presence = n\n\t}\n}\n\n// GetUsersOptionTeamID include team Id\nfunc GetUsersOptionTeamID(teamId string) GetUsersOption {\n\treturn func(p *UserPagination) {\n\t\tp.teamId = teamId\n\t}\n}\n\nfunc newUserPagination(c *Client, options ...GetUsersOption) (up UserPagination) {\n\tup = UserPagination{\n\t\tc:     c,\n\t\tlimit: 200, // per slack api documentation.\n\t}\n\n\tfor _, opt := range options {\n\t\topt(&up)\n\t}\n\n\treturn up\n}\n\n// UserPagination allows for paginating over the users\ntype UserPagination struct {\n\tUsers        []User\n\tlimit        int\n\tpresence     bool\n\tteamId       string\n\tpreviousResp *ResponseMetadata\n\tc            *Client\n}\n\n// Done checks if the pagination has completed\nfunc (UserPagination) Done(err error) bool {\n\treturn err == errPaginationComplete\n}\n\n// Failure checks if pagination failed.\nfunc (t UserPagination) Failure(err error) error {\n\tif t.Done(err) {\n\t\treturn nil\n\t}\n\n\treturn err\n}\n\nfunc (t UserPagination) Next(ctx context.Context) (_ UserPagination, err error) {\n\tvar (\n\t\tresp *userResponseFull\n\t)\n\n\tif t.c == nil || (t.previousResp != nil && t.previousResp.Cursor == \"\") {\n\t\treturn t, errPaginationComplete\n\t}\n\n\tt.previousResp = t.previousResp.initialize()\n\n\tvalues := url.Values{\n\t\t\"limit\":          {strconv.Itoa(t.limit)},\n\t\t\"presence\":       {strconv.FormatBool(t.presence)},\n\t\t\"token\":          {t.c.token},\n\t\t\"cursor\":         {t.previousResp.Cursor},\n\t\t\"team_id\":        {t.teamId},\n\t\t\"include_locale\": {strconv.FormatBool(true)},\n\t}\n\n\tif resp, err = t.c.userRequest(ctx, \"users.list\", values); err != nil {\n\t\treturn t, err\n\t}\n\n\tt.c.Debugf(\"GetUsersContext: got %d users; metadata %v\", len(resp.Members), resp.Metadata)\n\tt.Users = resp.Members\n\tt.previousResp = &resp.Metadata\n\n\treturn t, nil\n}\n\n// GetUsersPaginated fetches users in a paginated fashion, see GetUsersContext for usage.\nfunc (api *Client) GetUsersPaginated(options ...GetUsersOption) UserPagination {\n\treturn newUserPagination(api, options...)\n}\n\n// GetUsers returns the list of users (with their detailed information)\nfunc (api *Client) GetUsers(options ...GetUsersOption) ([]User, error) {\n\treturn api.GetUsersContext(context.Background(), options...)\n}\n\n// GetUsersContext returns the list of users (with their detailed information) with a custom context\nfunc (api *Client) GetUsersContext(ctx context.Context, options ...GetUsersOption) (results []User, err error) {\n\tp := api.GetUsersPaginated(options...)\n\tfor err == nil {\n\t\tp, err = p.Next(ctx)\n\t\tif err == nil {\n\t\t\tresults = append(results, p.Users...)\n\t\t} else if rateLimitedError, ok := err.(*RateLimitedError); ok {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\terr = ctx.Err()\n\t\t\tcase <-time.After(rateLimitedError.RetryAfter):\n\t\t\t\terr = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results, p.Failure(err)\n}\n\n// GetUserByEmail will retrieve the complete user information by email.\n// For more information see the GetUserByEmailContext documentation.\nfunc (api *Client) GetUserByEmail(email string) (*User, error) {\n\treturn api.GetUserByEmailContext(context.Background(), email)\n}\n\n// GetUserByEmailContext will retrieve the complete user information by email with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.lookupByEmail\nfunc (api *Client) GetUserByEmailContext(ctx context.Context, email string) (*User, error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t\t\"email\": {email},\n\t}\n\tresponse, err := api.userRequest(ctx, \"users.lookupByEmail\", values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &response.User, nil\n}\n\n// SetUserAsActive marks the currently authenticated user as active.\n// For more information see the SetUserAsActiveContext documentation.\nfunc (api *Client) SetUserAsActive() error {\n\treturn api.SetUserAsActiveContext(context.Background())\n}\n\n// SetUserAsActiveContext marks the currently authenticated user as active with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.setActive\nfunc (api *Client) SetUserAsActiveContext(ctx context.Context) (err error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\t_, err = api.userRequest(ctx, \"users.setActive\", values)\n\treturn err\n}\n\n// SetUserPresence changes the currently authenticated user presence.\n// For more information see the SetUserPresenceContext documentation.\nfunc (api *Client) SetUserPresence(presence string) error {\n\treturn api.SetUserPresenceContext(context.Background(), presence)\n}\n\n// SetUserPresenceContext changes the currently authenticated user presence with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.setPresence\nfunc (api *Client) SetUserPresenceContext(ctx context.Context, presence string) error {\n\tvalues := url.Values{\n\t\t\"token\":    {api.token},\n\t\t\"presence\": {presence},\n\t}\n\n\t_, err := api.userRequest(ctx, \"users.setPresence\", values)\n\treturn err\n}\n\n// GetUserIdentity will retrieve user info available per identity scopes.\n// For more information see the GetUserIdentityContext documentation.\nfunc (api *Client) GetUserIdentity() (*UserIdentityResponse, error) {\n\treturn api.GetUserIdentityContext(context.Background())\n}\n\n// GetUserIdentityContext will retrieve user info available per identity scopes with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.identity\nfunc (api *Client) GetUserIdentityContext(ctx context.Context) (response *UserIdentityResponse, err error) {\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\tresponse = &UserIdentityResponse{}\n\n\terr = api.postMethod(ctx, \"users.identity\", values, response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := response.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}\n\n// SetUserPhoto changes the currently authenticated user's profile image.\n// For more information see the SetUserPhotoContext documentation.\nfunc (api *Client) SetUserPhoto(image string, params UserSetPhotoParams) error {\n\treturn api.SetUserPhotoContext(context.Background(), image, params)\n}\n\n// SetUserPhotoContext changes the currently authenticated user's profile image using a custom context.\n// Slack API docs: https://api.slack.com/methods/users.setPhoto\nfunc (api *Client) SetUserPhotoContext(ctx context.Context, image string, params UserSetPhotoParams) (err error) {\n\tresponse := &SlackResponse{}\n\tvalues := url.Values{}\n\tif params.CropX != DEFAULT_USER_PHOTO_CROP_X {\n\t\tvalues.Add(\"crop_x\", strconv.Itoa(params.CropX))\n\t}\n\tif params.CropY != DEFAULT_USER_PHOTO_CROP_Y {\n\t\tvalues.Add(\"crop_y\", strconv.Itoa(params.CropX))\n\t}\n\tif params.CropW != DEFAULT_USER_PHOTO_CROP_W {\n\t\tvalues.Add(\"crop_w\", strconv.Itoa(params.CropW))\n\t}\n\n\terr = postLocalWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"users.setPhoto\", image, \"image\", api.token, values, response, api)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// DeleteUserPhoto deletes the current authenticated user's profile image.\n// For more information see the DeleteUserPhotoContext documentation.\nfunc (api *Client) DeleteUserPhoto() error {\n\treturn api.DeleteUserPhotoContext(context.Background())\n}\n\n// DeleteUserPhotoContext deletes the current authenticated user's profile image with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.deletePhoto\nfunc (api *Client) DeleteUserPhotoContext(ctx context.Context) (err error) {\n\tresponse := &SlackResponse{}\n\tvalues := url.Values{\n\t\t\"token\": {api.token},\n\t}\n\n\terr = api.postMethod(ctx, \"users.deletePhoto\", values, response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// SetUserRealName changes the currently authenticated user's realName\n// For more information see the SetUserRealNameContextWithUser documentation.\nfunc (api *Client) SetUserRealName(realName string) error {\n\treturn api.SetUserRealNameContextWithUser(context.Background(), \"\", realName)\n}\n\n// SetUserRealNameContextWithUser will set a real name for the provided user with a custom context.\n// Slack API docs: https://api.slack.com/methods/users.profile.set\nfunc (api *Client) SetUserRealNameContextWithUser(ctx context.Context, user, realName string) error {\n\tprofile, err := json.Marshal(\n\t\t&struct {\n\t\t\tRealName string `json:\"real_name\"`\n\t\t}{\n\t\t\tRealName: realName,\n\t\t},\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"profile\": {string(profile)},\n\t}\n\n\t// optional field. It should not be set if empty\n\tif user != \"\" {\n\t\tvalues[\"user\"] = []string{user}\n\t}\n\n\tresponse := &userResponseFull{}\n\tif err = api.postMethod(ctx, \"users.profile.set\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// SetUserCustomFields sets Custom Profile fields on the provided users account.\n// For more information see the SetUserCustomFieldsContext documentation.\nfunc (api *Client) SetUserCustomFields(userID string, customFields map[string]UserProfileCustomField) error {\n\treturn api.SetUserCustomFieldsContext(context.Background(), userID, customFields)\n}\n\n// SetUserCustomFieldsContext sets Custom Profile fields on the provided users account.\n// Due to the non-repeating elements within the request, a map fields is required.\n// The key in the map signifies the field that will be updated.\n//\n// Note: You may need to change the way the custom field is populated within the Profile section of the Admin Console\n// from SCIM or User Entered to API.\n//\n// See GetTeamProfile for information to retrieve possible fields for your account.\n//\n// Slack API docs: https://api.slack.com/methods/users.profile.set\nfunc (api *Client) SetUserCustomFieldsContext(ctx context.Context, userID string, customFields map[string]UserProfileCustomField) error {\n\n\t// Convert data to data type with custom marshall / unmarshall\n\t// For more information, see UserProfileCustomFields definition.\n\tupdateFields := UserProfileCustomFields{}\n\tupdateFields.SetMap(customFields)\n\n\t// This anonymous struct is needed to set the fields level of the request data.  The base struct for\n\t// UserProfileCustomFields has an unexported variable named fields that does not contain a struct tag,\n\t// which has resulted in this configuration.\n\tprofile, err := json.Marshal(&struct {\n\t\tFields UserProfileCustomFields `json:\"fields\"`\n\t}{\n\t\tFields: updateFields,\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"user\":    {userID},\n\t\t\"profile\": {string(profile)},\n\t}\n\n\tresponse := &userResponseFull{}\n\tif err := postForm(ctx, api.httpclient, APIURL+\"users.profile.set\", values, response, api); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n\n}\n\n// SetUserCustomStatus will set a custom status and emoji for the currently authenticated user.\n// For more information see the SetUserCustomStatusContext documentation.\nfunc (api *Client) SetUserCustomStatus(statusText, statusEmoji string, statusExpiration int64) error {\n\treturn api.SetUserCustomStatusContextWithUser(context.Background(), \"\", statusText, statusEmoji, statusExpiration)\n}\n\n// SetUserCustomStatusContext will set a custom status and emoji for the currently authenticated user with a custom context.\n// For more information see the SetUserCustomStatusContextWithUser documentation.\nfunc (api *Client) SetUserCustomStatusContext(ctx context.Context, statusText, statusEmoji string, statusExpiration int64) error {\n\treturn api.SetUserCustomStatusContextWithUser(ctx, \"\", statusText, statusEmoji, statusExpiration)\n}\n\n// SetUserCustomStatusWithUser will set a custom status and emoji for the provided user.\n// For more information see the SetUserCustomStatusContextWithUser documentation.\nfunc (api *Client) SetUserCustomStatusWithUser(user, statusText, statusEmoji string, statusExpiration int64) error {\n\treturn api.SetUserCustomStatusContextWithUser(context.Background(), user, statusText, statusEmoji, statusExpiration)\n}\n\n// SetUserCustomStatusContextWithUser will set a custom status and emoji for the currently authenticated user.\n// If statusEmoji is \"\" and statusText is not, the Slack API will automatically set it to \":speech_balloon:\".\n// Otherwise, if both are \"\" the Slack API will unset the custom status/emoji. If statusExpiration is set to 0\n// the status will not expire.\n//\n// Slack API docs: https://api.slack.com/methods/users.profile.set\nfunc (api *Client) SetUserCustomStatusContextWithUser(ctx context.Context, user, statusText, statusEmoji string, statusExpiration int64) error {\n\t// XXX(theckman): this anonymous struct is for making requests to the Slack\n\t// API for setting and unsetting a User's Custom Status/Emoji. To change\n\t// these values we must provide a JSON document as the profile POST field.\n\t//\n\t// We use an anonymous struct over UserProfile because to unset the values\n\t// on the User's profile we cannot use the `json:\"omitempty\"` tag. This is\n\t// because an empty string (\"\") is what's used to unset the values. Check\n\t// out the API docs for more details:\n\t//\n\t// - https://api.slack.com/docs/presence-and-status#custom_status\n\tprofile, err := json.Marshal(\n\t\t&struct {\n\t\t\tStatusText       string `json:\"status_text\"`\n\t\t\tStatusEmoji      string `json:\"status_emoji\"`\n\t\t\tStatusExpiration int64  `json:\"status_expiration\"`\n\t\t}{\n\t\t\tStatusText:       statusText,\n\t\t\tStatusEmoji:      statusEmoji,\n\t\t\tStatusExpiration: statusExpiration,\n\t\t},\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalues := url.Values{\n\t\t\"token\":   {api.token},\n\t\t\"profile\": {string(profile)},\n\t}\n\n\t// optional field. It should not be set if empty\n\tif user != \"\" {\n\t\tvalues[\"user\"] = []string{user}\n\t}\n\n\tresponse := &userResponseFull{}\n\tif err = api.postMethod(ctx, \"users.profile.set\", values, response); err != nil {\n\t\treturn err\n\t}\n\n\treturn response.Err()\n}\n\n// UnsetUserCustomStatus removes the custom status message for the currently\n// authenticated user. This is a convenience method that wraps (*Client).SetUserCustomStatus().\nfunc (api *Client) UnsetUserCustomStatus() error {\n\treturn api.UnsetUserCustomStatusContext(context.Background())\n}\n\n// UnsetUserCustomStatusContext removes the custom status message for the currently authenticated user\n// with a custom context. This is a convenience method that wraps (*Client).SetUserCustomStatus().\nfunc (api *Client) UnsetUserCustomStatusContext(ctx context.Context) error {\n\treturn api.SetUserCustomStatusContext(ctx, \"\", \"\", 0)\n}\n\n// GetUserProfileParameters are the parameters required to get user profile\ntype GetUserProfileParameters struct {\n\tUserID        string\n\tIncludeLabels bool\n}\n\n// GetUserProfile retrieves a user's profile information.\n// For more information see the GetUserProfileContext documentation.\nfunc (api *Client) GetUserProfile(params *GetUserProfileParameters) (*UserProfile, error) {\n\treturn api.GetUserProfileContext(context.Background(), params)\n}\n\ntype getUserProfileResponse struct {\n\tSlackResponse\n\tProfile *UserProfile `json:\"profile\"`\n}\n\n// GetUserProfileContext retrieves a user's profile information with a context.\n// Slack API docs: https://api.slack.com/methods/users.profile.get\nfunc (api *Client) GetUserProfileContext(ctx context.Context, params *GetUserProfileParameters) (*UserProfile, error) {\n\tvalues := url.Values{\"token\": {api.token}}\n\n\tif params.UserID != \"\" {\n\t\tvalues.Add(\"user\", params.UserID)\n\t}\n\tif params.IncludeLabels {\n\t\tvalues.Add(\"include_labels\", \"true\")\n\t}\n\tresp := &getUserProfileResponse{}\n\n\terr := api.postMethod(ctx, \"users.profile.get\", values, &resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := resp.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp.Profile, nil\n}\n"
        },
        {
          "name": "users_test.go",
          "type": "blob",
          "size": 21.7158203125,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n)\n\nfunc getTestUserProfileCustomField() UserProfileCustomField {\n\treturn UserProfileCustomField{\n\t\tValue: \"test value\",\n\t\tAlt:   \"\",\n\t\tLabel: \"\",\n\t}\n}\n\nfunc getTestUserProfileCustomFields() UserProfileCustomFields {\n\treturn UserProfileCustomFields{\n\t\tfields: map[string]UserProfileCustomField{\n\t\t\t\"Xxxxxx\": getTestUserProfileCustomField(),\n\t\t}}\n}\n\nfunc getTestUserProfileStatusEmojiDisplayInfo() []UserProfileStatusEmojiDisplayInfo {\n\treturn []UserProfileStatusEmojiDisplayInfo{{\n\t\tEmojiName:  \"construction\",\n\t\tUnicode:    \"1f6a7\",\n\t\tDisplayURL: \"https://a.slack-edge.com/production-standard-emoji-assets/14.0/apple-large/1f6a7.png\",\n\t}}\n}\n\nfunc getTestUserProfile() UserProfile {\n\treturn UserProfile{\n\t\tStatusText:             \"testStatus\",\n\t\tStatusEmoji:            \":construction:\",\n\t\tStatusEmojiDisplayInfo: getTestUserProfileStatusEmojiDisplayInfo(),\n\t\tRealName:               \"Test Real Name\",\n\t\tRealNameNormalized:     \"Test Real Name Normalized\",\n\t\tDisplayName:            \"Test Display Name\",\n\t\tDisplayNameNormalized:  \"Test Display Name Normalized\",\n\t\tEmail:                  \"test@test.com\",\n\t\tImage24:                \"https://s3-us-west-2.amazonaws.com/slack-files2/avatars/2016-10-18/92962080834_ef14c1469fc0741caea1_24.jpg\",\n\t\tImage32:                \"https://s3-us-west-2.amazonaws.com/slack-files2/avatars/2016-10-18/92962080834_ef14c1469fc0741caea1_32.jpg\",\n\t\tImage48:                \"https://s3-us-west-2.amazonaws.com/slack-files2/avatars/2016-10-18/92962080834_ef14c1469fc0741caea1_48.jpg\",\n\t\tImage72:                \"https://s3-us-west-2.amazonaws.com/slack-files2/avatars/2016-10-18/92962080834_ef14c1469fc0741caea1_72.jpg\",\n\t\tImage192:               \"https://s3-us-west-2.amazonaws.com/slack-files2/avatars/2016-10-18/92962080834_ef14c1469fc0741caea1_192.jpg\",\n\t\tImage512:               \"https://s3-us-west-2.amazonaws.com/slack-files2/avatars/2016-10-18/92962080834_ef14c1469fc0741caea1_512.jpg\",\n\t\tFields:                 getTestUserProfileCustomFields(),\n\t}\n}\n\nfunc getTestUserWithId(id string) User {\n\treturn User{\n\t\tID:                id,\n\t\tName:              \"Test User\",\n\t\tDeleted:           false,\n\t\tColor:             \"9f69e7\",\n\t\tRealName:          \"testuser\",\n\t\tTZ:                \"America/Los_Angeles\",\n\t\tTZLabel:           \"Pacific Daylight Time\",\n\t\tTZOffset:          -25200,\n\t\tProfile:           getTestUserProfile(),\n\t\tIsBot:             false,\n\t\tIsAdmin:           false,\n\t\tIsOwner:           false,\n\t\tIsPrimaryOwner:    false,\n\t\tIsRestricted:      false,\n\t\tIsUltraRestricted: false,\n\t\tUpdated:           1555425715,\n\t\tHas2FA:            false,\n\t}\n}\n\nfunc getTestUser() User {\n\treturn getTestUserWithId(\"UXXXXXXXX\")\n}\n\nfunc getTestUsers() []User {\n\treturn []User{\n\t\tgetTestUserWithId(\"UYYYYYYYY\"),\n\t\tgetTestUserWithId(\"UZZZZZZZZ\"),\n\t}\n}\n\nfunc getUserIdentity(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse := []byte(`{\n  \"ok\": true,\n  \"user\": {\n    \"id\": \"UXXXXXXXX\",\n    \"name\": \"Test User\",\n    \"email\": \"test@test.com\",\n    \"image_24\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_24.jpg\",\n    \"image_32\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_32.jpg\",\n    \"image_48\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_48.jpg\",\n    \"image_72\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_72.jpg\",\n    \"image_192\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_192.jpg\",\n    \"image_512\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_512.jpg\"\n  },\n  \"team\": {\n    \"id\": \"TXXXXXXXX\",\n    \"name\": \"team-name\",\n    \"domain\": \"team-domain\",\n    \"image_34\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_34.jpg\",\n    \"image_44\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_44.jpg\",\n    \"image_68\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_68.jpg\",\n    \"image_88\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_88.jpg\",\n    \"image_102\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_102.jpg\",\n    \"image_132\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_132.jpg\",\n    \"image_230\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_230.jpg\",\n    \"image_original\": \"https:\\/\\/s3-us-west-2.amazonaws.com\\/slack-files2\\/avatars\\/2016-10-18\\/92962080834_ef14c1469fc0741caea1_original.jpg\"\n  }\n}`)\n\trw.Write(response)\n}\n\nfunc getUserInfo(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tOk   bool `json:\"ok\"`\n\t\tUser User `json:\"user\"`\n\t}{\n\t\tOk:   true,\n\t\tUser: getTestUser(),\n\t})\n\trw.Write(response)\n}\n\nfunc getUsersInfo(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tOk    bool   `json:\"ok\"`\n\t\tUsers []User `json:\"users\"`\n\t}{\n\t\tOk:    true,\n\t\tUsers: getTestUsers(),\n\t})\n\trw.Write(response)\n}\n\nfunc getUserByEmail(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(struct {\n\t\tOk   bool `json:\"ok\"`\n\t\tUser User `json:\"user\"`\n\t}{\n\t\tOk:   true,\n\t\tUser: getTestUser(),\n\t})\n\trw.Write(response)\n}\n\nfunc httpTestErrReply(w http.ResponseWriter, clientErr bool, msg string) {\n\tif clientErr {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t} else {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tbody, _ := json.Marshal(&SlackResponse{\n\t\tOk: false, Error: msg,\n\t})\n\n\tw.Write(body)\n}\n\nfunc newProfileHandler(up *UserProfile) (setter func(http.ResponseWriter, *http.Request)) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif up == nil {\n\t\t\thttpTestErrReply(w, false, \"err: UserProfile is nil\")\n\t\t\treturn\n\t\t}\n\n\t\tif err := r.ParseForm(); err != nil {\n\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"err parsing form: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tvalues := r.Form\n\n\t\tif v, ok := values[\"user\"]; ok {\n\t\t\tif len(v) == 0 || v[0] == \"\" {\n\t\t\t\thttpTestErrReply(w, true, `POST data must not include an empty in a \"user\" field`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif len(values[\"profile\"]) == 0 {\n\t\t\thttpTestErrReply(w, true, `POST data must include a \"profile\" field`)\n\t\t\treturn\n\t\t}\n\n\t\tprofile := []byte(values[\"profile\"][0])\n\n\t\tuserProfile := UserProfile{}\n\n\t\tif err := json.Unmarshal(profile, &userProfile); err != nil {\n\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"err parsing JSON: %s\\n\\njson: `%s`\", err.Error(), profile))\n\t\t\treturn\n\t\t}\n\n\t\t*up = userProfile\n\n\t\t// TODO(theckman): enhance this to return a full User object\n\t\tfmt.Fprint(w, `{\"ok\":true}`)\n\t}\n}\n\nfunc TestGetUserIdentity(t *testing.T) {\n\thttp.HandleFunc(\"/users.identity\", getUserIdentity)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tidentity, err := api.GetUserIdentity()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\t// t.Fatal refers to -> t.Errorf & return\n\tif identity.User.ID != \"UXXXXXXXX\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.User.Name != \"Test User\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.User.Email != \"test@test.com\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.Team.ID != \"TXXXXXXXX\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.Team.Name != \"team-name\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.Team.Domain != \"team-domain\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.User.Image24 == \"\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n\tif identity.Team.Image34 == \"\" {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc TestGetUserInfo(t *testing.T) {\n\thttp.HandleFunc(\"/users.info\", getUserInfo)\n\texpectedUser := getTestUser()\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tuser, err := api.GetUserInfo(\"UXXXXXXXX\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(expectedUser, *user) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc TestGetUsersInfo(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/users.info\", getUsersInfo)\n\texpectedUsers := getTestUsers()\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tuser, err := api.GetUsersInfo(\"UYYYYYYYY\", \"UZZZZZZZZ\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(expectedUsers, *user) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc TestGetUserByEmail(t *testing.T) {\n\thttp.HandleFunc(\"/users.lookupByEmail\", getUserByEmail)\n\texpectedUser := getTestUser()\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tuser, err := api.GetUserByEmail(\"test@test.com\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(expectedUser, *user) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc TestUserProfileSet(t *testing.T) {\n\tup := &UserProfile{}\n\n\tsetUserProfile := newProfileHandler(up)\n\n\thttp.HandleFunc(\"/users.profile.set\", setUserProfile)\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\ttestSetUserCustomStatus(api, up, t)\n\ttestUnsetUserCustomStatus(api, up, t)\n\n\tup.RealName = \"Test User\"\n\ttestSetUserCustomStatusWithUser(api, \"Test User\", up, t)\n\n\tup.RealName = \"Real Name Test\"\n\ttestSetUserRealName(api, up, t)\n}\n\nfunc testSetUserRealName(api *Client, up *UserProfile, t *testing.T) {\n\tconst (\n\t\trealName = \"Real Name Test\"\n\t)\n\tif err := api.SetUserRealName(realName); err != nil {\n\t\tt.Fatalf(`SetUserRealName(%q) = %#v, want <nil>`, realName, err)\n\t}\n\n\tif up.RealName != realName {\n\t\tt.Fatalf(`UserProfile.RealName = %q, want %q`, up.RealName, realName)\n\t}\n}\n\nfunc testSetUserCustomStatus(api *Client, up *UserProfile, t *testing.T) {\n\tconst (\n\t\tstatusText       = \"testStatus\"\n\t\tstatusEmoji      = \":construction:\"\n\t\tstatusExpiration = 1551619082\n\t)\n\tif err := api.SetUserCustomStatus(statusText, statusEmoji, statusExpiration); err != nil {\n\t\tt.Fatalf(`SetUserCustomStatus(%q, %q, %q) = %#v, want <nil>`, statusText, statusEmoji, statusExpiration, err)\n\t}\n\n\tif up.StatusText != statusText {\n\t\tt.Fatalf(`UserProfile.StatusText = %q, want %q`, up.StatusText, statusText)\n\t}\n\n\tif up.StatusEmoji != statusEmoji {\n\t\tt.Fatalf(`UserProfile.StatusEmoji = %q, want %q`, up.StatusEmoji, statusEmoji)\n\t}\n\tif up.StatusExpiration != statusExpiration {\n\t\tt.Fatalf(`UserProfile.StatusExpiration = %q, want %q`, up.StatusExpiration, statusExpiration)\n\t}\n}\n\nfunc testSetUserCustomStatusWithUser(api *Client, user string, up *UserProfile, t *testing.T) {\n\tconst (\n\t\tstatusText       = \"testStatus\"\n\t\tstatusEmoji      = \":construction:\"\n\t\tstatusExpiration = 1551619082\n\t)\n\tif err := api.SetUserCustomStatusWithUser(user, statusText, statusEmoji, statusExpiration); err != nil {\n\t\tt.Fatalf(`SetUserCustomStatusWithUser(%q, %q, %q, %q) = %#v, want <nil>`, user, statusText, statusEmoji, statusExpiration, err)\n\t}\n\n\tif up.StatusText != statusText {\n\t\tt.Fatalf(`UserProfile.StatusText = %q, want %q`, up.StatusText, statusText)\n\t}\n\n\tif up.StatusEmoji != statusEmoji {\n\t\tt.Fatalf(`UserProfile.StatusEmoji = %q, want %q`, up.StatusEmoji, statusEmoji)\n\t}\n\tif up.StatusExpiration != statusExpiration {\n\t\tt.Fatalf(`UserProfile.StatusExpiration = %q, want %q`, up.StatusExpiration, statusExpiration)\n\t}\n}\n\nfunc testUnsetUserCustomStatus(api *Client, up *UserProfile, t *testing.T) {\n\tif err := api.UnsetUserCustomStatus(); err != nil {\n\t\tt.Fatalf(`UnsetUserCustomStatus() = %#v, want <nil>`, err)\n\t}\n\n\tif up.StatusText != \"\" {\n\t\tt.Fatalf(`UserProfile.StatusText = %q, want %q`, up.StatusText, \"\")\n\t}\n\n\tif up.StatusEmoji != \"\" {\n\t\tt.Fatalf(`UserProfile.StatusEmoji = %q, want %q`, up.StatusEmoji, \"\")\n\t}\n}\n\nfunc TestGetUsers(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/users.list\", getUserPage(4))\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tusers, err := api.GetUsers()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual([]User{\n\t\tgetTestUserWithId(\"U000\"),\n\t\tgetTestUserWithId(\"U001\"),\n\t\tgetTestUserWithId(\"U002\"),\n\t\tgetTestUserWithId(\"U003\"),\n\t}, users) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\n// returns n pages users.\nfunc getUserPage(max int64) func(rw http.ResponseWriter, r *http.Request) {\n\tvar n int64\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tvar cpage int64\n\t\tsresp := SlackResponse{\n\t\t\tOk: true,\n\t\t}\n\t\tmembers := []User{\n\t\t\tgetTestUserWithId(fmt.Sprintf(\"U%03d\", n)),\n\t\t}\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tif cpage = atomic.AddInt64(&n, 1); cpage == max {\n\t\t\tresponse, _ := json.Marshal(userResponseFull{\n\t\t\t\tSlackResponse: sresp,\n\t\t\t\tMembers:       members,\n\t\t\t})\n\t\t\trw.Write(response)\n\t\t\treturn\n\t\t}\n\t\tresponse, _ := json.Marshal(userResponseFull{\n\t\t\tSlackResponse: sresp,\n\t\t\tMembers:       members,\n\t\t\tMetadata:      ResponseMetadata{Cursor: strconv.Itoa(int(cpage))},\n\t\t})\n\t\trw.Write(response)\n\t}\n}\n\n// returns n pages of users and sends rate limited errors in between successful pages.\nfunc getUserPagesWithRateLimitErrors(max int64) func(rw http.ResponseWriter, r *http.Request) {\n\tvar n int64\n\tdoRateLimit := false\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tdoRateLimit = !doRateLimit\n\t\t}()\n\t\tif doRateLimit {\n\t\t\trw.Header().Set(\"Retry-After\", \"1\")\n\t\t\trw.WriteHeader(http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\t\tvar cpage int64\n\t\tsresp := SlackResponse{\n\t\t\tOk: true,\n\t\t}\n\t\tmembers := []User{\n\t\t\tgetTestUserWithId(fmt.Sprintf(\"U%03d\", n)),\n\t\t}\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tif cpage = atomic.AddInt64(&n, 1); cpage == max {\n\t\t\tresponse, _ := json.Marshal(userResponseFull{\n\t\t\t\tSlackResponse: sresp,\n\t\t\t\tMembers:       members,\n\t\t\t})\n\t\t\trw.Write(response)\n\t\t\treturn\n\t\t}\n\t\tresponse, _ := json.Marshal(userResponseFull{\n\t\t\tSlackResponse: sresp,\n\t\t\tMembers:       members,\n\t\t\tMetadata:      ResponseMetadata{Cursor: strconv.Itoa(int(cpage))},\n\t\t})\n\t\trw.Write(response)\n\t}\n}\n\nfunc TestSetUserPhoto(t *testing.T) {\n\tfile, fileContent, teardown := createUserPhoto(t)\n\tdefer teardown()\n\n\tparams := UserSetPhotoParams{CropX: 0, CropY: 0, CropW: 32}\n\n\thttp.HandleFunc(\"/users.setPhoto\", setUserPhotoHandler(fileContent, params))\n\n\tonce.Do(startServer)\n\tapi := New(validToken, OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\terr := api.SetUserPhoto(file.Name(), params)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %+v\\n\", err)\n\t}\n}\n\nfunc setUserPhotoHandler(wantBytes []byte, wantParams UserSetPhotoParams) http.HandlerFunc {\n\tconst maxMemory = 1 << 20 // 1 MB\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif err := r.ParseMultipartForm(maxMemory); err != nil {\n\t\t\thttpTestErrReply(w, false, fmt.Sprintf(\"failed to parse multipart/form: %+v\", err))\n\t\t\treturn\n\t\t}\n\n\t\t// Test for expected token\n\t\tactualToken := strings.Split(r.Header.Get(\"Authorization\"), \"Bearer \")[1]\n\t\tif actualToken != validToken {\n\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"expected multipart form value token=%v\", validToken))\n\t\t\treturn\n\t\t}\n\n\t\t// Test for expected crop params\n\t\tif wantParams.CropX != DEFAULT_USER_PHOTO_CROP_X {\n\t\t\tif cx, err := strconv.Atoi(r.Form.Get(\"crop_x\")); err != nil || cx != wantParams.CropX {\n\t\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"expected multipart form value crop_x=%d\", wantParams.CropX))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif wantParams.CropY != DEFAULT_USER_PHOTO_CROP_Y {\n\t\t\tif cy, err := strconv.Atoi(r.Form.Get(\"crop_y\")); err != nil || cy != wantParams.CropY {\n\t\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"expected multipart form value crop_y=%d\", wantParams.CropY))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif wantParams.CropW != DEFAULT_USER_PHOTO_CROP_W {\n\t\t\tif cw, err := strconv.Atoi(r.Form.Get(\"crop_w\")); err != nil || cw != wantParams.CropW {\n\t\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"expected multipart form value crop_w=%d\", wantParams.CropW))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Test for expected image\n\t\tf, ok := r.MultipartForm.File[\"image\"]\n\t\tif !ok || len(f) == 0 {\n\t\t\thttpTestErrReply(w, true, `expected multipart form file \"image\"`)\n\t\t\treturn\n\t\t}\n\t\tfile, err := f[0].Open()\n\t\tif err != nil {\n\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"failed to open uploaded file: %+v\", err))\n\t\t\treturn\n\t\t}\n\t\tgotBytes, err := io.ReadAll(file)\n\t\tif err != nil {\n\t\t\thttpTestErrReply(w, true, fmt.Sprintf(\"failed to read uploaded file: %+v\", err))\n\t\t\treturn\n\t\t}\n\t\tif !bytes.Equal(wantBytes, gotBytes) {\n\t\t\thttpTestErrReply(w, true, \"uploaded bytes did not match expected bytes\")\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprint(w, `{\"ok\":true}`)\n\t}\n}\n\n// createUserPhoto generates a temp photo for testing. It returns the file handle, the file\n// contents, and a function that can be called to remove the file.\nfunc createUserPhoto(t *testing.T) (*os.File, []byte, func()) {\n\tphoto := image.NewRGBA(image.Rect(0, 0, 64, 64))\n\tdraw.Draw(photo, photo.Bounds(), image.Black, image.ZP, draw.Src)\n\n\tf, err := os.CreateTemp(os.TempDir(), \"profile.png\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create test photo: %+v\\n\", err)\n\t}\n\n\tvar buf bytes.Buffer\n\tif err := png.Encode(io.MultiWriter(&buf, f), photo); err != nil {\n\t\tt.Fatalf(\"failed to write test photo: %+v\\n\", err)\n\t}\n\n\tteardown := func() {\n\t\tif err := os.Remove(f.Name()); err != nil {\n\t\t\tt.Fatalf(\"failed to remove test photo: %+v\\n\", err)\n\t\t}\n\t}\n\n\treturn f, buf.Bytes(), teardown\n}\n\nfunc getUserProfileHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tprofile := getTestUserProfile()\n\tresp, _ := json.Marshal(&getUserProfileResponse{\n\t\tSlackResponse: SlackResponse{Ok: true},\n\t\tProfile:       &profile})\n\trw.Write(resp)\n}\n\nfunc TestGetUserProfile(t *testing.T) {\n\thttp.HandleFunc(\"/users.profile.get\", getUserProfileHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\tprofile, err := api.GetUserProfile(&GetUserProfileParameters{UserID: \"UXXXXXXXX\"})\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\texp := getTestUserProfile()\n\tif profile.DisplayName != exp.DisplayName {\n\t\tt.Fatalf(`profile.DisplayName = \"%s\", wanted \"%s\"`, profile.DisplayName, exp.DisplayName)\n\t}\n\tif len(profile.StatusEmojiDisplayInfo) != 1 {\n\t\tt.Fatalf(`expected 1 emoji, got %d`, len(profile.StatusEmojiDisplayInfo))\n\t}\n}\n\nfunc TestSetFieldsMap(t *testing.T) {\n\tp := &UserProfile{}\n\texp := map[string]UserProfileCustomField{\n\t\t\"Xxxxxx\": getTestUserProfileCustomField(),\n\t}\n\tp.SetFieldsMap(exp)\n\tact := p.FieldsMap()\n\tif !reflect.DeepEqual(act, exp) {\n\t\tt.Fatalf(`p.FieldsMap() = %v, wanted %v`, act, exp)\n\t}\n}\n\nfunc TestUserProfileCustomFieldsUnmarshalJSON(t *testing.T) {\n\tfields := &UserProfileCustomFields{}\n\tif err := json.Unmarshal([]byte(`[]`), fields); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := json.Unmarshal([]byte(`{\n\t  \"Xxxxxx\": {\n\t    \"value\": \"test value\",\n\t    \"alt\": \"\"\n\t  }\n\t}`), fields); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tact := fields.ToMap()[\"Xxxxxx\"].Value\n\texp := \"test value\"\n\tif act != exp {\n\t\tt.Fatalf(`fields.ToMap()[\"Xxxxxx\"][\"value\"] = \"%s\", wanted \"%s\"`, act, exp)\n\t}\n}\n\nfunc TestUserProfileCustomFieldsMarshalJSON(t *testing.T) {\n\tfields := UserProfileCustomFields{}\n\tb, err := json.Marshal(fields)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != \"[]\" {\n\t\tt.Fatalf(`string(b) = \"%s\", wanted \"[]\"`, string(b))\n\t}\n\tfields = getTestUserProfileCustomFields()\n\tif _, err := json.Marshal(fields); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestUserProfileCustomFieldsToMap(t *testing.T) {\n\tm := map[string]UserProfileCustomField{\n\t\t\"Xxxxxx\": getTestUserProfileCustomField(),\n\t}\n\tfields := UserProfileCustomFields{fields: m}\n\tact := fields.ToMap()\n\tif !reflect.DeepEqual(act, m) {\n\t\tt.Fatalf(`fields.ToMap() = %v, wanted %v`, act, m)\n\t}\n}\n\nfunc TestUserProfileCustomFieldsLen(t *testing.T) {\n\tfields := UserProfileCustomFields{\n\t\tfields: map[string]UserProfileCustomField{\n\t\t\t\"Xxxxxx\": getTestUserProfileCustomField(),\n\t\t}}\n\tif fields.Len() != 1 {\n\t\tt.Fatalf(`fields.Len() = %d, wanted 1`, fields.Len())\n\t}\n}\n\nfunc TestUserProfileCustomFieldsSetMap(t *testing.T) {\n\tfields := UserProfileCustomFields{}\n\tm := map[string]UserProfileCustomField{\n\t\t\"Xxxxxx\": getTestUserProfileCustomField(),\n\t}\n\tfields.SetMap(m)\n\tif !reflect.DeepEqual(fields.fields, m) {\n\t\tt.Fatalf(`fields.fields = %v, wanted %v`, fields.fields, m)\n\t}\n}\n\nfunc TestGetUsersHandlesRateLimit(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/users.list\", getUserPagesWithRateLimitErrors(4))\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tusers, err := api.GetUsers()\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\tif !reflect.DeepEqual([]User{\n\t\tgetTestUserWithId(\"U000\"),\n\t\tgetTestUserWithId(\"U001\"),\n\t\tgetTestUserWithId(\"U002\"),\n\t\tgetTestUserWithId(\"U003\"),\n\t}, users) {\n\t\tt.Fatal(ErrIncorrectResponse)\n\t}\n}\n\nfunc TestGetUsersReturnsServerError(t *testing.T) {\n\thttp.DefaultServeMux = new(http.ServeMux)\n\thttp.HandleFunc(\"/users.list\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t})\n\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\t_, err := api.GetUsers()\n\n\tif err == nil {\n\t\tt.Errorf(\"Expected error but got nil\")\n\t\treturn\n\t}\n\n\texpectedErr := \"slack server error: 500 Internal Server Error\"\n\tif err.Error() != expectedErr {\n\t\tt.Errorf(\"Expected: %s. Got: %s\", expectedErr, err.Error())\n\t}\n}\n"
        },
        {
          "name": "views.go",
          "type": "blob",
          "size": 8.9423828125,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n)\n\nconst (\n\tVTModal   ViewType = \"modal\"\n\tVTHomeTab ViewType = \"home\"\n)\n\ntype ViewType string\n\ntype ViewState struct {\n\tValues map[string]map[string]BlockAction `json:\"values\"`\n}\n\ntype View struct {\n\tSlackResponse\n\tID                 string           `json:\"id\"`\n\tTeamID             string           `json:\"team_id\"`\n\tType               ViewType         `json:\"type\"`\n\tTitle              *TextBlockObject `json:\"title\"`\n\tClose              *TextBlockObject `json:\"close\"`\n\tSubmit             *TextBlockObject `json:\"submit\"`\n\tBlocks             Blocks           `json:\"blocks\"`\n\tPrivateMetadata    string           `json:\"private_metadata\"`\n\tCallbackID         string           `json:\"callback_id\"`\n\tState              *ViewState       `json:\"state\"`\n\tHash               string           `json:\"hash\"`\n\tClearOnClose       bool             `json:\"clear_on_close\"`\n\tNotifyOnClose      bool             `json:\"notify_on_close\"`\n\tRootViewID         string           `json:\"root_view_id\"`\n\tPreviousViewID     string           `json:\"previous_view_id\"`\n\tAppID              string           `json:\"app_id\"`\n\tExternalID         string           `json:\"external_id\"`\n\tBotID              string           `json:\"bot_id\"`\n\tAppInstalledTeamID string           `json:\"app_installed_team_id\"`\n}\n\ntype ViewSubmissionCallbackResponseURL struct {\n\tBlockID     string `json:\"block_id\"`\n\tActionID    string `json:\"action_id\"`\n\tChannelID   string `json:\"channel_id\"`\n\tResponseURL string `json:\"response_url\"`\n}\n\ntype ViewSubmissionCallback struct {\n\tHash         string                              `json:\"hash\"`\n\tResponseURLs []ViewSubmissionCallbackResponseURL `json:\"response_urls,omitempty\"`\n}\n\ntype ViewClosedCallback struct {\n\tIsCleared bool `json:\"is_cleared\"`\n}\n\nconst (\n\tRAClear  ViewResponseAction = \"clear\"\n\tRAUpdate ViewResponseAction = \"update\"\n\tRAPush   ViewResponseAction = \"push\"\n\tRAErrors ViewResponseAction = \"errors\"\n)\n\ntype ViewResponseAction string\n\ntype ViewSubmissionResponse struct {\n\tResponseAction ViewResponseAction `json:\"response_action\"`\n\tView           *ModalViewRequest  `json:\"view,omitempty\"`\n\tErrors         map[string]string  `json:\"errors,omitempty\"`\n}\n\nfunc NewClearViewSubmissionResponse() *ViewSubmissionResponse {\n\treturn &ViewSubmissionResponse{\n\t\tResponseAction: RAClear,\n\t}\n}\n\nfunc NewUpdateViewSubmissionResponse(view *ModalViewRequest) *ViewSubmissionResponse {\n\treturn &ViewSubmissionResponse{\n\t\tResponseAction: RAUpdate,\n\t\tView:           view,\n\t}\n}\n\nfunc NewPushViewSubmissionResponse(view *ModalViewRequest) *ViewSubmissionResponse {\n\treturn &ViewSubmissionResponse{\n\t\tResponseAction: RAPush,\n\t\tView:           view,\n\t}\n}\n\nfunc NewErrorsViewSubmissionResponse(errors map[string]string) *ViewSubmissionResponse {\n\treturn &ViewSubmissionResponse{\n\t\tResponseAction: RAErrors,\n\t\tErrors:         errors,\n\t}\n}\n\ntype ModalViewRequest struct {\n\tType            ViewType         `json:\"type\"`\n\tTitle           *TextBlockObject `json:\"title,omitempty\"`\n\tBlocks          Blocks           `json:\"blocks\"`\n\tClose           *TextBlockObject `json:\"close,omitempty\"`\n\tSubmit          *TextBlockObject `json:\"submit,omitempty\"`\n\tPrivateMetadata string           `json:\"private_metadata,omitempty\"`\n\tCallbackID      string           `json:\"callback_id,omitempty\"`\n\tClearOnClose    bool             `json:\"clear_on_close,omitempty\"`\n\tNotifyOnClose   bool             `json:\"notify_on_close,omitempty\"`\n\tExternalID      string           `json:\"external_id,omitempty\"`\n}\n\nfunc (v *ModalViewRequest) ViewType() ViewType {\n\treturn v.Type\n}\n\ntype HomeTabViewRequest struct {\n\tType            ViewType `json:\"type\"`\n\tBlocks          Blocks   `json:\"blocks\"`\n\tPrivateMetadata string   `json:\"private_metadata,omitempty\"`\n\tCallbackID      string   `json:\"callback_id,omitempty\"`\n\tExternalID      string   `json:\"external_id,omitempty\"`\n}\n\nfunc (v *HomeTabViewRequest) ViewType() ViewType {\n\treturn v.Type\n}\n\ntype openViewRequest struct {\n\tTriggerID string           `json:\"trigger_id\"`\n\tView      ModalViewRequest `json:\"view\"`\n}\n\ntype publishViewRequest struct {\n\tUserID string             `json:\"user_id\"`\n\tView   HomeTabViewRequest `json:\"view\"`\n\tHash   string             `json:\"hash,omitempty\"`\n}\n\ntype pushViewRequest struct {\n\tTriggerID string           `json:\"trigger_id\"`\n\tView      ModalViewRequest `json:\"view\"`\n}\n\ntype updateViewRequest struct {\n\tView       ModalViewRequest `json:\"view\"`\n\tExternalID string           `json:\"external_id,omitempty\"`\n\tHash       string           `json:\"hash,omitempty\"`\n\tViewID     string           `json:\"view_id,omitempty\"`\n}\n\ntype ViewResponse struct {\n\tSlackResponse\n\tView `json:\"view\"`\n}\n\n// OpenView opens a view for a user.\n// For more information see the OpenViewContext documentation.\nfunc (api *Client) OpenView(triggerID string, view ModalViewRequest) (*ViewResponse, error) {\n\treturn api.OpenViewContext(context.Background(), triggerID, view)\n}\n\n// ValidateUniqueBlockID will verify if each input block has a unique block ID if set\nfunc ValidateUniqueBlockID(view ModalViewRequest) bool {\n\n\tuniqueBlockID := map[string]bool{}\n\n\tfor _, b := range view.Blocks.BlockSet {\n\t\tif inputBlock, ok := b.(*InputBlock); ok {\n\t\t\tif _, ok := uniqueBlockID[inputBlock.BlockID]; ok {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tuniqueBlockID[inputBlock.BlockID] = true\n\t\t}\n\t}\n\n\treturn true\n}\n\n// OpenViewContext opens a view for a user with a custom context.\n// Slack API docs: https://api.slack.com/methods/views.open\nfunc (api *Client) OpenViewContext(\n\tctx context.Context,\n\ttriggerID string,\n\tview ModalViewRequest,\n) (*ViewResponse, error) {\n\tif triggerID == \"\" {\n\t\treturn nil, ErrParametersMissing\n\t}\n\n\tif !ValidateUniqueBlockID(view) {\n\t\treturn nil, ErrBlockIDNotUnique\n\t}\n\n\treq := openViewRequest{\n\t\tTriggerID: triggerID,\n\t\tView:      view,\n\t}\n\tencoded, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tendpoint := api.endpoint + \"views.open\"\n\tresp := &ViewResponse{}\n\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, resp.Err()\n}\n\n// PublishView publishes a static view for a user.\n// For more information see the PublishViewContext documentation.\nfunc (api *Client) PublishView(userID string, view HomeTabViewRequest, hash string) (*ViewResponse, error) {\n\treturn api.PublishViewContext(context.Background(), userID, view, hash)\n}\n\n// PublishViewContext publishes a static view for a user with a custom context.\n// Slack API docs: https://api.slack.com/methods/views.publish\nfunc (api *Client) PublishViewContext(\n\tctx context.Context,\n\tuserID string,\n\tview HomeTabViewRequest,\n\thash string,\n) (*ViewResponse, error) {\n\tif userID == \"\" {\n\t\treturn nil, ErrParametersMissing\n\t}\n\treq := publishViewRequest{\n\t\tUserID: userID,\n\t\tView:   view,\n\t\tHash:   hash,\n\t}\n\tencoded, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tendpoint := api.endpoint + \"views.publish\"\n\tresp := &ViewResponse{}\n\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, resp.Err()\n}\n\n// PushView pushes a view onto the stack of a root view.\n// For more information see the PushViewContext documentation.\nfunc (api *Client) PushView(triggerID string, view ModalViewRequest) (*ViewResponse, error) {\n\treturn api.PushViewContext(context.Background(), triggerID, view)\n}\n\n// PushViewContext pushes a view onto the stack of a root view with a custom context.\n// Slack API docs: https://api.slack.com/methods/views.push\nfunc (api *Client) PushViewContext(\n\tctx context.Context,\n\ttriggerID string,\n\tview ModalViewRequest,\n) (*ViewResponse, error) {\n\tif triggerID == \"\" {\n\t\treturn nil, ErrParametersMissing\n\t}\n\treq := pushViewRequest{\n\t\tTriggerID: triggerID,\n\t\tView:      view,\n\t}\n\tencoded, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tendpoint := api.endpoint + \"views.push\"\n\tresp := &ViewResponse{}\n\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, resp.Err()\n}\n\n// UpdateView updates an existing view.\n// For more information see the UpdateViewContext documentation.\nfunc (api *Client) UpdateView(view ModalViewRequest, externalID, hash, viewID string) (*ViewResponse, error) {\n\treturn api.UpdateViewContext(context.Background(), view, externalID, hash, viewID)\n}\n\n// UpdateViewContext updates an existing view with a custom context.\n// Slack API docs: https://api.slack.com/methods/views.update\nfunc (api *Client) UpdateViewContext(\n\tctx context.Context,\n\tview ModalViewRequest,\n\texternalID, hash,\n\tviewID string,\n) (*ViewResponse, error) {\n\tif externalID == \"\" && viewID == \"\" {\n\t\treturn nil, ErrParametersMissing\n\t}\n\treq := updateViewRequest{\n\t\tView:       view,\n\t\tExternalID: externalID,\n\t\tHash:       hash,\n\t\tViewID:     viewID,\n\t}\n\tencoded, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tendpoint := api.endpoint + \"views.update\"\n\tresp := &ViewResponse{}\n\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, resp.Err()\n}\n"
        },
        {
          "name": "views_test.go",
          "type": "blob",
          "size": 21.546875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/slack-go/slack/internal/errorsx\"\n)\n\nvar dummySlackErr = errorsx.String(\"dummy_error_from_slack\")\n\ntype viewsHandler struct {\n\trawResponse string\n}\n\nfunc (h *viewsHandler) handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write([]byte(h.rawResponse))\n}\n\nfunc TestSlack_OpenView(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tcases := []struct {\n\t\tcaseName         string\n\t\ttriggerID        string\n\t\tmodalViewRequest ModalViewRequest\n\t\trawResp          string\n\t\texpectedResp     *ViewResponse\n\t\texpectedErr      error\n\t}{\n\t\t{\n\t\t\tcaseName:         \"pass empty trigger_id\",\n\t\t\ttriggerID:        \"\",\n\t\t\tmodalViewRequest: ModalViewRequest{},\n\t\t\trawResp:          \"\",\n\t\t\texpectedResp:     nil,\n\t\t\texpectedErr:      ErrParametersMissing,\n\t\t},\n\t\t{\n\t\t\tcaseName:  \"raise an error for not having a unique block id\",\n\t\t\ttriggerID: \"dummy_trigger_id\",\n\t\t\tmodalViewRequest: ModalViewRequest{\n\t\t\t\tBlocks: Blocks{\n\t\t\t\t\tBlockSet: []Block{\n\t\t\t\t\t\t&InputBlock{\n\t\t\t\t\t\t\tBlockID: \"example\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&InputBlock{\n\t\t\t\t\t\t\tBlockID: \"example\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\trawResp:      \"\",\n\t\t\texpectedResp: nil,\n\t\t\texpectedErr:  ErrBlockIDNotUnique,\n\t\t},\n\t\t{\n\t\t\tcaseName:         \"raise an error from Slack API\",\n\t\t\ttriggerID:        \"dummy_trigger_id\",\n\t\t\tmodalViewRequest: ModalViewRequest{},\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": false,\n\t\t\t\t\"error\": \"dummy_error_from_slack\",\n\t\t\t\t\"response_metadata\": {\n\t\t\t\t\t\"warnings\": [\n\t\t\t\t\t\t\"missing_charset\"\n\t\t\t\t\t],\n\t\t\t\t\t\"messages\": [\n\t\t\t\t\t\t\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    false,\n\t\t\t\t\tError: dummySlackErr.Error(),\n\t\t\t\t\tResponseMetadata: ResponseMetadata{\n\t\t\t\t\t\tMessages: []string{\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"},\n\t\t\t\t\t\tWarnings: []string{\"missing_charset\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tView{},\n\t\t\t},\n\t\t\texpectedErr: dummySlackErr,\n\t\t},\n\t\t{\n\t\t\tcaseName:         \"success\",\n\t\t\ttriggerID:        \"dummy_trigger_id\",\n\t\t\tmodalViewRequest: ModalViewRequest{},\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": true,\n\t\t\t\t\"view\": {\n\t\t\t\t\t\"id\": \"VMHU10V25\",\n\t\t\t\t\t\"team_id\": \"T8N4K1JN\",\n\t\t\t\t\t\"type\": \"modal\",\n\t\t\t\t\t\"title\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Quite a plain modal\"\n\t\t\t\t\t},\n\t\t\t\t\t\"submit\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Create\"\n\t\t\t\t\t},\n\t\t\t\t\t\"blocks\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"input\",\n\t\t\t\t\t\t\t\"block_id\": \"a_block_id\",\n\t\t\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\"text\": \"A simple label\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"optional\": false,\n\t\t\t\t\t\t\t\"element\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\t\t\"placeholder\": {\n\t\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"Placeholder text\"\n\t\t\t\t\t\t \t\t},\n\t\t\t\t\t\t\t\t\"action_id\": \"an_action_id\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"private_metadata\": \"Shh it is a secret\",\n\t\t\t\t\t\"callback_id\": \"identify_your_modals\",\n\t\t\t\t\t\"external_id\": \"\",\n\t\t\t\t\t\"state\": {\n\t\t\t\t\t\t\"values\": {}\n\t\t\t\t\t},\n\t\t\t\t\t\"hash\": \"156772938.1827394\",\n\t\t\t\t\t\"clear_on_close\": false,\n\t\t\t\t\t\"notify_on_close\": false,\n\t\t\t\t\t\"root_view_id\": \"VMHU10V25\",\n\t\t\t\t\t\"app_id\": \"AA4928AQ\",\n\t\t\t\t\t\"bot_id\": \"BA13894H\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    true,\n\t\t\t\t\tError: \"\",\n\t\t\t\t},\n\t\t\t\tView{\n\t\t\t\t\tID:     \"VMHU10V25\",\n\t\t\t\t\tType:   VTModal,\n\t\t\t\t\tTeamID: \"T8N4K1JN\",\n\t\t\t\t\tTitle: &TextBlockObject{\n\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\tText: \"Quite a plain modal\",\n\t\t\t\t\t},\n\t\t\t\t\tSubmit: &TextBlockObject{\n\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\tText: \"Create\",\n\t\t\t\t\t},\n\t\t\t\t\tCallbackID:      \"identify_your_modals\",\n\t\t\t\t\tPrivateMetadata: \"Shh it is a secret\",\n\t\t\t\t\tState:           &ViewState{},\n\t\t\t\t\tHash:            \"156772938.1827394\",\n\t\t\t\t\tRootViewID:      \"VMHU10V25\",\n\t\t\t\t\tAppID:           \"AA4928AQ\",\n\t\t\t\t\tBotID:           \"BA13894H\",\n\t\t\t\t\tBlocks: Blocks{\n\t\t\t\t\t\tBlockSet: []Block{\n\t\t\t\t\t\t\tNewInputBlock(\n\t\t\t\t\t\t\t\t\"a_block_id\",\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple label\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple hint\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNewPlainTextInputBlockElement(\n\t\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\t\tText: \"Placeholder text\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"an_action_id\",\n\t\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\th := &viewsHandler{}\n\thttp.HandleFunc(\"/views.open\", h.handler)\n\tfor _, c := range cases {\n\t\tt.Run(c.caseName, func(t *testing.T) {\n\t\t\th.rawResponse = c.rawResp\n\n\t\t\tresp, err := api.OpenView(c.triggerID, c.modalViewRequest)\n\t\t\tif c.expectedErr == nil && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\\n\", err)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err == nil {\n\t\t\t\tt.Fatalf(\"expected %s, but did not raise an error\", c.expectedErr)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err != nil && c.expectedErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"expected %s as error but got %s\\n\", c.expectedErr, err)\n\t\t\t}\n\t\t\tif resp == nil || c.expectedResp == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Messages, c.expectedResp.ResponseMetadata.Messages) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Messages, resp.ResponseMetadata.Messages)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Warnings, c.expectedResp.ResponseMetadata.Warnings) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Warnings, resp.ResponseMetadata.Warnings)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSlack_View_PublishView(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tcases := []struct {\n\t\tcaseName     string\n\t\tuserID       string\n\t\trawResp      string\n\t\texpectedResp *ViewResponse\n\t\texpectedErr  error\n\t}{\n\t\t{\n\t\t\tcaseName:     \"pass empty user_id\",\n\t\t\tuserID:       \"\",\n\t\t\trawResp:      \"\",\n\t\t\texpectedResp: nil,\n\t\t\texpectedErr:  ErrParametersMissing,\n\t\t},\n\t\t{\n\t\t\tcaseName: \"raise an error from Slack API\",\n\t\t\tuserID:   \"dummy_user_id\",\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": false,\n\t\t\t\t\"error\": \"dummy_error_from_slack\",\n\t\t\t\t\"response_metadata\": {\n\t\t\t\t\t\"warnings\": [\n\t\t\t\t\t\t\"missing_charset\"\n\t\t\t\t\t],\n\t\t\t\t\t\"messages\": [\n\t\t\t\t\t\t\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    false,\n\t\t\t\t\tError: dummySlackErr.Error(),\n\t\t\t\t\tResponseMetadata: ResponseMetadata{\n\t\t\t\t\t\tMessages: []string{\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"},\n\t\t\t\t\t\tWarnings: []string{\"missing_charset\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tView{},\n\t\t\t},\n\t\t\texpectedErr: dummySlackErr,\n\t\t},\n\t\t{\n\t\t\tcaseName: \"success\",\n\t\t\tuserID:   \"dummy_user_id\",\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": true,\n\t\t\t\t\"view\": {\n\t\t\t\t\t\"id\": \"VMHU10V25\",\n\t\t\t\t\t\"team_id\": \"T8N4K1JN\",\n\t\t\t\t\t\"type\": \"home\",\n\t\t\t\t\t\"close\": null,\n\t\t\t\t\t\"submit\": null,\n\t\t\t\t\t\"blocks\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"input\",\n\t\t\t\t\t\t\t\"block_id\": \"a_block_id\",\n\t\t\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\"text\": \"A simple label\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"optional\": false,\n\t\t\t\t\t\t\t\"element\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\t\t\"placeholder\": {\n\t\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"Placeholder text\"\n\t\t\t\t\t\t \t\t},\n\t\t\t\t\t\t\t\t\"action_id\": \"an_action_id\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"private_metadata\": \"Shh it is a secret\",\n\t\t\t\t\t\"callback_id\": \"identify_your_home_tab\",\n\t\t\t\t\t\"state\": {\n\t\t\t\t\t\t\"values\": {}\n\t\t\t\t\t},\n\t\t\t\t\t\"hash\": \"156772938.1827394\",\n\t\t\t\t\t\"clear_on_close\": false,\n\t\t\t\t\t\"notify_on_close\": false,\n\t\t\t\t\t\"root_view_id\": \"VMHU10V25\",\n\t\t\t\t\t\"previous_view_id\": null,\n\t\t\t\t\t\"app_id\": \"AA4928AQ\",\n\t\t\t\t\t\"external_id\": \"\",\n\t\t\t\t\t\"bot_id\": \"BA13894H\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    true,\n\t\t\t\t\tError: \"\",\n\t\t\t\t},\n\t\t\t\tView{\n\t\t\t\t\tID:              \"VMHU10V25\",\n\t\t\t\t\tType:            VTHomeTab,\n\t\t\t\t\tTeamID:          \"T8N4K1JN\",\n\t\t\t\t\tCallbackID:      \"identify_your_home_tab\",\n\t\t\t\t\tPrivateMetadata: \"Shh it is a secret\",\n\t\t\t\t\tState:           &ViewState{},\n\t\t\t\t\tHash:            \"156772938.1827394\",\n\t\t\t\t\tRootViewID:      \"VMHU10V25\",\n\t\t\t\t\tAppID:           \"AA4928AQ\",\n\t\t\t\t\tBotID:           \"BA13894H\",\n\t\t\t\t\tBlocks: Blocks{\n\t\t\t\t\t\tBlockSet: []Block{\n\t\t\t\t\t\t\tNewInputBlock(\n\t\t\t\t\t\t\t\t\"a_block_id\",\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple label\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple hint\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNewPlainTextInputBlockElement(\n\t\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\t\tText: \"Placeholder text\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"an_action_id\",\n\t\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\th := &viewsHandler{}\n\thttp.HandleFunc(\"/views.publish\", h.handler)\n\tfor _, c := range cases {\n\t\tt.Run(c.caseName, func(t *testing.T) {\n\t\t\th.rawResponse = c.rawResp\n\n\t\t\tresp, err := api.PublishView(c.userID, HomeTabViewRequest{}, \"dummy_hash\")\n\t\t\tif c.expectedErr == nil && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\\n\", err)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err == nil {\n\t\t\t\tt.Fatalf(\"expected %s, but did not raise an error\", c.expectedErr)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err != nil && c.expectedErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"expected %s as error but got %s\\n\", c.expectedErr, err)\n\t\t\t}\n\t\t\tif resp == nil || c.expectedResp == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Messages, c.expectedResp.ResponseMetadata.Messages) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Messages, resp.ResponseMetadata.Messages)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Warnings, c.expectedResp.ResponseMetadata.Warnings) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Warnings, resp.ResponseMetadata.Warnings)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSlack_PushView(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tcases := []struct {\n\t\tcaseName     string\n\t\ttriggerID    string\n\t\trawResp      string\n\t\texpectedResp *ViewResponse\n\t\texpectedErr  error\n\t}{\n\t\t{\n\t\t\tcaseName:     \"pass empty trigger_id\",\n\t\t\ttriggerID:    \"\",\n\t\t\trawResp:      \"\",\n\t\t\texpectedResp: nil,\n\t\t\texpectedErr:  ErrParametersMissing,\n\t\t},\n\t\t{\n\t\t\tcaseName:  \"raise an error from Slack API\",\n\t\t\ttriggerID: \"dummy_trigger_id\",\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": false,\n\t\t\t\t\"error\": \"dummy_error_from_slack\",\n\t\t\t\t\"response_metadata\": {\n\t\t\t\t\t\"warnings\": [\n\t\t\t\t\t\t\"missing_charset\"\n\t\t\t\t\t],\n\t\t\t\t\t\"messages\": [\n\t\t\t\t\t\t\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    false,\n\t\t\t\t\tError: dummySlackErr.Error(),\n\t\t\t\t\tResponseMetadata: ResponseMetadata{\n\t\t\t\t\t\tMessages: []string{\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"},\n\t\t\t\t\t\tWarnings: []string{\"missing_charset\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tView{},\n\t\t\t},\n\t\t\texpectedErr: dummySlackErr,\n\t\t},\n\t\t{\n\t\t\tcaseName:  \"success\",\n\t\t\ttriggerID: \"dummy_trigger_id\",\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": true,\n\t\t\t\t\"view\": {\n\t\t\t\t\t\"id\": \"VMHU10V25\",\n\t\t\t\t\t\"team_id\": \"T8N4K1JN\",\n\t\t\t\t\t\"type\": \"modal\",\n\t\t\t\t\t\"title\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Quite a plain modal\"\n\t\t\t\t\t},\n\t\t\t\t\t\"submit\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Create\"\n\t\t\t\t\t},\n\t\t\t\t\t\"blocks\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"input\",\n\t\t\t\t\t\t\t\"block_id\": \"a_block_id\",\n\t\t\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\"text\": \"A simple label\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"optional\": false,\n\t\t\t\t\t\t\t\"element\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\t\t\"placeholder\": {\n\t\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"Placeholder text\"\n\t\t\t\t\t\t \t\t},\n\t\t\t\t\t\t\t\t\"action_id\": \"an_action_id\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"private_metadata\": \"Shh it is a secret\",\n\t\t\t\t\t\"callback_id\": \"identify_your_modals\",\n\t\t\t\t\t\"external_id\": \"\",\n\t\t\t\t\t\"state\": {\n\t\t\t\t\t\t\"values\": {}\n\t\t\t\t\t},\n\t\t\t\t\t\"hash\": \"156772938.1827394\",\n\t\t\t\t\t\"clear_on_close\": false,\n\t\t\t\t\t\"notify_on_close\": false,\n\t\t\t\t\t\"root_view_id\": \"VMHU10V25\",\n\t\t\t\t\t\"app_id\": \"AA4928AQ\",\n\t\t\t\t\t\"bot_id\": \"BA13894H\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    true,\n\t\t\t\t\tError: \"\",\n\t\t\t\t},\n\t\t\t\tView{\n\t\t\t\t\tID:     \"VMHU10V25\",\n\t\t\t\t\tType:   VTModal,\n\t\t\t\t\tTeamID: \"T8N4K1JN\",\n\t\t\t\t\tTitle: &TextBlockObject{\n\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\tText: \"Quite a plain modal\",\n\t\t\t\t\t},\n\t\t\t\t\tSubmit: &TextBlockObject{\n\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\tText: \"Create\",\n\t\t\t\t\t},\n\t\t\t\t\tCallbackID:      \"identify_your_modals\",\n\t\t\t\t\tPrivateMetadata: \"Shh it is a secret\",\n\t\t\t\t\tState:           &ViewState{},\n\t\t\t\t\tHash:            \"156772938.1827394\",\n\t\t\t\t\tRootViewID:      \"VMHU10V25\",\n\t\t\t\t\tAppID:           \"AA4928AQ\",\n\t\t\t\t\tBotID:           \"BA13894H\",\n\t\t\t\t\tBlocks: Blocks{\n\t\t\t\t\t\tBlockSet: []Block{\n\t\t\t\t\t\t\tNewInputBlock(\n\t\t\t\t\t\t\t\t\"a_block_id\",\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple label\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple hint\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNewPlainTextInputBlockElement(\n\t\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\t\tText: \"Placeholder text\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"an_action_id\",\n\t\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\th := &viewsHandler{}\n\thttp.HandleFunc(\"/views.push\", h.handler)\n\tfor _, c := range cases {\n\t\tt.Run(c.caseName, func(t *testing.T) {\n\t\t\th.rawResponse = c.rawResp\n\n\t\t\tresp, err := api.PushView(c.triggerID, ModalViewRequest{})\n\t\t\tif c.expectedErr == nil && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\\n\", err)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err == nil {\n\t\t\t\tt.Fatalf(\"expected %s, but did not raise an error\", c.expectedErr)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err != nil && c.expectedErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"expected %s as error but got %s\\n\", c.expectedErr, err)\n\t\t\t}\n\t\t\tif resp == nil || c.expectedResp == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Messages, c.expectedResp.ResponseMetadata.Messages) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Messages, resp.ResponseMetadata.Messages)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Warnings, c.expectedResp.ResponseMetadata.Warnings) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Warnings, resp.ResponseMetadata.Warnings)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSlack_UpdateView(t *testing.T) {\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tcases := []struct {\n\t\tcaseName     string\n\t\texternalID   string\n\t\tviewID       string\n\t\trawResp      string\n\t\texpectedResp *ViewResponse\n\t\texpectedErr  error\n\t}{\n\t\t{\n\t\t\tcaseName:     \"pass empty external_id and empty view_id\",\n\t\t\texternalID:   \"\",\n\t\t\tviewID:       \"\",\n\t\t\trawResp:      \"\",\n\t\t\texpectedResp: nil,\n\t\t\texpectedErr:  ErrParametersMissing,\n\t\t},\n\t\t{\n\t\t\tcaseName:   \"raise an error from Slack API\",\n\t\t\texternalID: \"dummy_external_id\",\n\t\t\tviewID:     \"\",\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": false,\n\t\t\t\t\"error\": \"dummy_error_from_slack\",\n\t\t\t\t\"response_metadata\": {\n\t\t\t\t\t\"warnings\": [\n\t\t\t\t\t\t\"missing_charset\"\n\t\t\t\t\t],\n\t\t\t\t\t\"messages\": [\n\t\t\t\t\t\t\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    false,\n\t\t\t\t\tError: dummySlackErr.Error(),\n\t\t\t\t\tResponseMetadata: ResponseMetadata{\n\t\t\t\t\t\tMessages: []string{\"[WARN] A Content-Type HTTP header was presented but did not declare a charset, such as a 'utf-8'\"},\n\t\t\t\t\t\tWarnings: []string{\"missing_charset\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tView{},\n\t\t\t},\n\t\t\texpectedErr: dummySlackErr,\n\t\t},\n\t\t{\n\t\t\tcaseName:   \"success\",\n\t\t\texternalID: \"\",\n\t\t\tviewID:     \"dummy_view_id\",\n\t\t\trawResp: `{\n\t\t\t\t\"ok\": true,\n\t\t\t\t\"view\": {\n\t\t\t\t\t\"id\": \"VMHU10V25\",\n\t\t\t\t\t\"team_id\": \"T8N4K1JN\",\n\t\t\t\t\t\"type\": \"modal\",\n\t\t\t\t\t\"title\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Quite a plain modal\"\n\t\t\t\t\t},\n\t\t\t\t\t\"submit\": {\n\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\"text\": \"Create\"\n\t\t\t\t\t},\n\t\t\t\t\t\"blocks\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"input\",\n\t\t\t\t\t\t\t\"block_id\": \"a_block_id\",\n\t\t\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\"text\": \"A simple label\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"optional\": false,\n\t\t\t\t\t\t\t\"element\": {\n\t\t\t\t\t\t\t\t\"type\": \"plain_text_input\",\n\t\t\t\t\t\t\t\t\"placeholder\": {\n\t\t\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"Placeholder text\"\n\t\t\t\t\t\t \t\t},\n\t\t\t\t\t\t\t\t\"action_id\": \"an_action_id\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"private_metadata\": \"Shh it is a secret\",\n\t\t\t\t\t\"callback_id\": \"identify_your_modals\",\n\t\t\t\t\t\"external_id\": \"\",\n\t\t\t\t\t\"state\": {\n\t\t\t\t\t\t\"values\": {}\n\t\t\t\t\t},\n\t\t\t\t\t\"hash\": \"156772938.1827394\",\n\t\t\t\t\t\"clear_on_close\": false,\n\t\t\t\t\t\"notify_on_close\": false,\n\t\t\t\t\t\"root_view_id\": \"VMHU10V25\",\n\t\t\t\t\t\"app_id\": \"AA4928AQ\",\n\t\t\t\t\t\"bot_id\": \"BA13894H\"\n\t\t\t\t}\n\t\t\t}`,\n\t\t\texpectedResp: &ViewResponse{\n\t\t\t\tSlackResponse{\n\t\t\t\t\tOk:    true,\n\t\t\t\t\tError: \"\",\n\t\t\t\t},\n\t\t\t\tView{\n\t\t\t\t\tID:     \"VMHU10V25\",\n\t\t\t\t\tType:   VTModal,\n\t\t\t\t\tTeamID: \"T8N4K1JN\",\n\t\t\t\t\tTitle: &TextBlockObject{\n\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\tText: \"Quite a plain modal\",\n\t\t\t\t\t},\n\t\t\t\t\tSubmit: &TextBlockObject{\n\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\tText: \"Create\",\n\t\t\t\t\t},\n\t\t\t\t\tCallbackID:      \"identify_your_modals\",\n\t\t\t\t\tPrivateMetadata: \"Shh it is a secret\",\n\t\t\t\t\tState:           &ViewState{},\n\t\t\t\t\tHash:            \"156772938.1827394\",\n\t\t\t\t\tRootViewID:      \"VMHU10V25\",\n\t\t\t\t\tAppID:           \"AA4928AQ\",\n\t\t\t\t\tBotID:           \"BA13894H\",\n\t\t\t\t\tBlocks: Blocks{\n\t\t\t\t\t\tBlockSet: []Block{\n\t\t\t\t\t\t\tNewInputBlock(\n\t\t\t\t\t\t\t\t\"a_block_id\",\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple label\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\tText: \"A simple hint\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNewPlainTextInputBlockElement(\n\t\t\t\t\t\t\t\t\t&TextBlockObject{\n\t\t\t\t\t\t\t\t\t\tType: PlainTextType,\n\t\t\t\t\t\t\t\t\t\tText: \"Placeholder text\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"an_action_id\",\n\t\t\t\t\t\t\t\t)),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\th := &viewsHandler{}\n\thttp.HandleFunc(\"/views.update\", h.handler)\n\tfor _, c := range cases {\n\t\tt.Run(c.caseName, func(t *testing.T) {\n\t\t\th.rawResponse = c.rawResp\n\n\t\t\tresp, err := api.UpdateView(ModalViewRequest{}, c.externalID, \"dummy_hash\", c.viewID)\n\t\t\tif c.expectedErr == nil && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\\n\", err)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err == nil {\n\t\t\t\tt.Fatalf(\"expected %s, but did not raise an error\", c.expectedErr)\n\t\t\t}\n\t\t\tif c.expectedErr != nil && err != nil && c.expectedErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"expected %s as error but got %s\\n\", c.expectedErr, err)\n\t\t\t}\n\t\t\tif resp == nil || c.expectedResp == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Messages, c.expectedResp.ResponseMetadata.Messages) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Messages, resp.ResponseMetadata.Messages)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(resp.ResponseMetadata.Warnings, c.expectedResp.ResponseMetadata.Warnings) {\n\t\t\t\tt.Fatalf(\"expected:\\n\\t%v\\n but got:\\n\\t%v\\n\", c.expectedResp.ResponseMetadata.Warnings, resp.ResponseMetadata.Warnings)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc assertViewSubmissionResponse(t *testing.T, resp *ViewSubmissionResponse, encoded string) {\n\tvar decoded *ViewSubmissionResponse\n\tassert.Nil(t, json.Unmarshal([]byte(encoded), &decoded))\n\tassert.Equal(t, decoded, resp)\n}\n\nfunc TestSlack_ClearViewSubmissionResponse(t *testing.T) {\n\tresp := NewClearViewSubmissionResponse()\n\trawResp := `{\n\t\t\"response_action\": \"clear\"\n\t}`\n\n\tassertViewSubmissionResponse(t, resp, rawResp)\n}\n\nfunc TestSlack_UpdateViewSubmissionResponse(t *testing.T) {\n\tresp := NewUpdateViewSubmissionResponse(&ModalViewRequest{\n\t\tType:   VTModal,\n\t\tTitle:  NewTextBlockObject(\"plain_text\", \"Test update view submission response\", false, false),\n\t\tBlocks: Blocks{BlockSet: []Block{NewFileBlock(\"file_block_id\", \"external_string\", \"source_string\")}},\n\t})\n\trawResp := `{\n\t\t\"response_action\": \"update\",\n\t\t\"view\": {\n\t\t\t\"type\": \"modal\",\n\t\t\t\"title\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Test update view submission response\"\n\t\t\t},\n\t\t\t\"blocks\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"file\",\n\t\t\t\t\t\"block_id\": \"file_block_id\",\n\t\t\t\t\t\"external_id\": \"external_string\",\n\t\t\t\t\t\"source\": \"source_string\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}`\n\n\tassertViewSubmissionResponse(t, resp, rawResp)\n}\n\nfunc TestSlack_PushViewSubmissionResponse(t *testing.T) {\n\tresp := NewPushViewSubmissionResponse(&ModalViewRequest{\n\t\tType:  VTModal,\n\t\tTitle: NewTextBlockObject(\"plain_text\", \"Test update view submission response\", false, false),\n\t\tBlocks: Blocks{\n\t\t\tBlockSet: []Block{\n\t\t\t\tNewContextBlock(\n\t\t\t\t\t\"context_block_id\",\n\t\t\t\t\tNewTextBlockObject(\"plain_text\", \"Context text\", false, false),\n\t\t\t\t\tNewImageBlockElement(\"image_url\", \"alt_text\"),\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t})\n\trawResp := `{\n\t\t\"response_action\": \"push\",\n\t\t\"view\": {\n\t\t\t\"type\": \"modal\",\n\t\t\t\"title\": {\n\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\"text\": \"Test update view submission response\"\n\t\t\t},\n\t\t\t\"blocks\": [\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"context\",\n\t\t\t\t\t\"block_id\": \"context_block_id\",\n\t\t\t\t\t\"elements\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"plain_text\",\n\t\t\t\t\t\t\t\"text\": \"Context text\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"image_url\": \"image_url\",\n\t\t\t\t\t\t\t\"alt_text\": \"alt_text\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}`\n\n\tassertViewSubmissionResponse(t, resp, rawResp)\n}\n\nfunc TestSlack_ErrorsViewSubmissionResponse(t *testing.T) {\n\tresp := NewErrorsViewSubmissionResponse(map[string]string{\n\t\t\"input_text_action_id\": \"Please input a name that's at least 6 characters long\",\n\t\t\"file_action_id\":       \"File exceeded size limit of 5 KB\",\n\t})\n\trawResp := `{\n\t\t\"response_action\": \"errors\",\n\t\t\"errors\": {\n\t\t\t\"input_text_action_id\": \"Please input a name that's at least 6 characters long\",\n\t\t\t\"file_action_id\": \"File exceeded size limit of 5 KB\"\n\t\t}\n\t}`\n\n\tassertViewSubmissionResponse(t, resp, rawResp)\n}\n"
        },
        {
          "name": "webhooks.go",
          "type": "blob",
          "size": 2.0986328125,
          "content": "package slack\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype WebhookMessage struct {\n\tUsername        string       `json:\"username,omitempty\"`\n\tIconEmoji       string       `json:\"icon_emoji,omitempty\"`\n\tIconURL         string       `json:\"icon_url,omitempty\"`\n\tChannel         string       `json:\"channel,omitempty\"`\n\tThreadTimestamp string       `json:\"thread_ts,omitempty\"`\n\tText            string       `json:\"text,omitempty\"`\n\tAttachments     []Attachment `json:\"attachments,omitempty\"`\n\tParse           string       `json:\"parse,omitempty\"`\n\tBlocks          *Blocks      `json:\"blocks,omitempty\"`\n\tResponseType    string       `json:\"response_type,omitempty\"`\n\tReplaceOriginal bool         `json:\"replace_original\"`\n\tDeleteOriginal  bool         `json:\"delete_original\"`\n\tReplyBroadcast  bool         `json:\"reply_broadcast,omitempty\"`\n\tUnfurlLinks     bool         `json:\"unfurl_links,omitempty\"`\n\tUnfurlMedia     bool         `json:\"unfurl_media,omitempty\"`\n}\n\nfunc PostWebhook(url string, msg *WebhookMessage) error {\n\treturn PostWebhookCustomHTTPContext(context.Background(), url, http.DefaultClient, msg)\n}\n\nfunc PostWebhookContext(ctx context.Context, url string, msg *WebhookMessage) error {\n\treturn PostWebhookCustomHTTPContext(ctx, url, http.DefaultClient, msg)\n}\n\nfunc PostWebhookCustomHTTP(url string, httpClient *http.Client, msg *WebhookMessage) error {\n\treturn PostWebhookCustomHTTPContext(context.Background(), url, httpClient, msg)\n}\n\nfunc PostWebhookCustomHTTPContext(ctx context.Context, url string, httpClient *http.Client, msg *WebhookMessage) error {\n\traw, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"marshal failed: %w\", err)\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(raw))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed new request: %w\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := httpClient.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to post webhook: %w\", err)\n\t}\n\tdefer func() {\n\t\tio.Copy(io.Discard, resp.Body)\n\t\tresp.Body.Close()\n\t}()\n\n\treturn checkStatusCode(resp, discard{})\n}\n"
        },
        {
          "name": "webhooks_test.go",
          "type": "blob",
          "size": 2.5634765625,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPostWebhook_OK(t *testing.T) {\n\tonce.Do(startServer)\n\n\tvar receivedPayload WebhookMessage\n\n\thttp.HandleFunc(\"/webhook\", func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Header().Set(\"Content-Type\", \"application/json\")\n\n\t\tdecoder := json.NewDecoder(r.Body)\n\t\terr := decoder.Decode(&receivedPayload)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Request contained invalid JSON, %s\", err)\n\t\t}\n\n\t\tresponse := []byte(`{}`)\n\t\trw.Write(response)\n\t})\n\n\turl := \"http://\" + serverAddr + \"/webhook\"\n\n\tpayload := &WebhookMessage{\n\t\tText: \"Test Text\",\n\t\tAttachments: []Attachment{\n\t\t\t{\n\t\t\t\tText: \"Foo\",\n\t\t\t},\n\t\t},\n\t}\n\n\terr := PostWebhook(url, payload)\n\n\tif err != nil {\n\t\tt.Errorf(\"Expected not to receive error: %s\", err)\n\t}\n\n\tif !reflect.DeepEqual(payload, &receivedPayload) {\n\t\tt.Errorf(\"Payload did not match\\nwant: %#v\\n got: %#v\", payload, receivedPayload)\n\t}\n}\n\nfunc TestPostWebhook_NotOK(t *testing.T) {\n\tonce.Do(startServer)\n\n\thttp.HandleFunc(\"/webhook2\", func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\trw.Write([]byte(\"500 - Something bad happened!\"))\n\t})\n\n\turl := \"http://\" + serverAddr + \"/webhook2\"\n\n\terr := PostWebhook(url, &WebhookMessage{})\n\n\tif err == nil {\n\t\tt.Errorf(\"Expected to receive error\")\n\t}\n}\n\nfunc TestWebhookMessage_WithBlocks(t *testing.T) {\n\ttextBlockObject := NewTextBlockObject(\"plain_text\", \"text\", false, false)\n\tsectionBlock := NewSectionBlock(textBlockObject, nil, nil)\n\n\tsingleBlock := &Blocks{BlockSet: []Block{sectionBlock}}\n\ttwoBlocks := &Blocks{BlockSet: []Block{sectionBlock, sectionBlock}}\n\n\tmsgSingleBlock := WebhookMessage{Blocks: singleBlock}\n\tassert.Equal(t, 1, len(msgSingleBlock.Blocks.BlockSet))\n\n\tmsgJsonSingleBlock, _ := json.Marshal(msgSingleBlock)\n\tassert.Equal(t, `{\"blocks\":[{\"type\":\"section\",\"text\":{\"type\":\"plain_text\",\"text\":\"text\"}}],\"replace_original\":false,\"delete_original\":false}`, string(msgJsonSingleBlock))\n\n\tmsgTwoBlocks := WebhookMessage{Blocks: twoBlocks}\n\tassert.Equal(t, 2, len(msgTwoBlocks.Blocks.BlockSet))\n\n\tmsgJsonTwoBlocks, _ := json.Marshal(msgTwoBlocks)\n\tassert.Equal(t, `{\"blocks\":[{\"type\":\"section\",\"text\":{\"type\":\"plain_text\",\"text\":\"text\"}},{\"type\":\"section\",\"text\":{\"type\":\"plain_text\",\"text\":\"text\"}}],\"replace_original\":false,\"delete_original\":false}`, string(msgJsonTwoBlocks))\n\n\tmsgNoBlocks := WebhookMessage{Text: \"foo\"}\n\tmsgJsonNoBlocks, _ := json.Marshal(msgNoBlocks)\n\tassert.Equal(t, `{\"text\":\"foo\",\"replace_original\":false,\"delete_original\":false}`, string(msgJsonNoBlocks))\n}\n"
        },
        {
          "name": "websocket.go",
          "type": "blob",
          "size": 2.6083984375,
          "content": "package slack\n\nimport (\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\t// MaxMessageTextLength is the current maximum message length in number of characters as defined here\n\t// https://api.slack.com/rtm#limits\n\tMaxMessageTextLength = 4000\n)\n\n// RTM represents a managed websocket connection. It also supports\n// all the methods of the `Client` type.\n//\n// Create this element with Client's NewRTM() or NewRTMWithOptions(*RTMOptions)\ntype RTM struct {\n\t// Client is the main API, embedded\n\tClient\n\n\tidGen        IDGenerator\n\tpingInterval time.Duration\n\tpingDeadman  *time.Timer\n\n\t// Connection life-cycle\n\tconn             *websocket.Conn\n\tIncomingEvents   chan RTMEvent\n\toutgoingMessages chan OutgoingMessage\n\tkillChannel      chan bool\n\tdisconnected     chan struct{}\n\tdisconnectedm    *sync.Once\n\tforcePing        chan bool\n\n\t// UserDetails upon connection\n\tinfo *Info\n\n\t// useRTMStart should be set to true if you want to use\n\t// rtm.start to connect to Slack, otherwise it will use\n\t// rtm.connect\n\tuseRTMStart bool\n\n\t// dialer is a gorilla/websocket Dialer. If nil, use the default\n\t// Dialer.\n\tdialer *websocket.Dialer\n\n\t// mu is mutex used to prevent RTM connection race conditions\n\tmu *sync.Mutex\n\n\t// connParams is a map of flags for connection parameters.\n\tconnParams url.Values\n}\n\n// signal that we are disconnected by closing the channel.\n// protect it with a mutex to ensure it only happens once.\nfunc (rtm *RTM) disconnect() {\n\trtm.disconnectedm.Do(func() {\n\t\tclose(rtm.disconnected)\n\t})\n}\n\n// Disconnect and wait, blocking until a successful disconnection.\nfunc (rtm *RTM) Disconnect() error {\n\t// always push into the kill channel when invoked,\n\t// this lets the ManagedConnection() function properly clean up.\n\t// if the buffer is full then just continue on.\n\tselect {\n\tcase rtm.killChannel <- true:\n\t\treturn nil\n\tcase <-rtm.disconnected:\n\t\treturn ErrAlreadyDisconnected\n\t}\n}\n\n// GetInfo returns the info structure received when calling\n// \"startrtm\", holding metadata needed to implement a full\n// chat client. It will be non-nil after a call to StartRTM().\nfunc (rtm *RTM) GetInfo() *Info {\n\treturn rtm.info\n}\n\n// SendMessage submits a simple message through the websocket.  For\n// more complicated messages, use `rtm.PostMessage` with a complete\n// struct describing your attachments and all.\nfunc (rtm *RTM) SendMessage(msg *OutgoingMessage) {\n\tif msg == nil {\n\t\trtm.Debugln(\"Error: Attempted to SendMessage(nil)\")\n\t\treturn\n\t}\n\n\trtm.outgoingMessages <- *msg\n}\n\nfunc (rtm *RTM) resetDeadman() {\n\trtm.pingDeadman.Reset(deadmanDuration(rtm.pingInterval))\n}\n\nfunc deadmanDuration(d time.Duration) time.Duration {\n\treturn d * 4\n}\n"
        },
        {
          "name": "websocket_channels.go",
          "type": "blob",
          "size": 2.20703125,
          "content": "package slack\n\n// ChannelCreatedEvent represents the Channel created event\ntype ChannelCreatedEvent struct {\n\tType           string             `json:\"type\"`\n\tChannel        ChannelCreatedInfo `json:\"channel\"`\n\tEventTimestamp string             `json:\"event_ts\"`\n}\n\n// ChannelCreatedInfo represents the information associated with the Channel created event\ntype ChannelCreatedInfo struct {\n\tID        string `json:\"id\"`\n\tIsChannel bool   `json:\"is_channel\"`\n\tName      string `json:\"name\"`\n\tCreated   int    `json:\"created\"`\n\tCreator   string `json:\"creator\"`\n}\n\n// ChannelJoinedEvent represents the Channel joined event\ntype ChannelJoinedEvent struct {\n\tType    string  `json:\"type\"`\n\tChannel Channel `json:\"channel\"`\n}\n\n// ChannelInfoEvent represents the Channel info event\ntype ChannelInfoEvent struct {\n\t// channel_left\n\t// channel_deleted\n\t// channel_archive\n\t// channel_unarchive\n\tType      string `json:\"type\"`\n\tChannel   string `json:\"channel\"`\n\tUser      string `json:\"user,omitempty\"`\n\tTimestamp string `json:\"ts,omitempty\"`\n}\n\n// ChannelRenameEvent represents the Channel rename event\ntype ChannelRenameEvent struct {\n\tType      string            `json:\"type\"`\n\tChannel   ChannelRenameInfo `json:\"channel\"`\n\tTimestamp string            `json:\"event_ts\"`\n}\n\n// ChannelRenameInfo represents the information associated with a Channel rename event\ntype ChannelRenameInfo struct {\n\tID      string `json:\"id\"`\n\tName    string `json:\"name\"`\n\tCreated int    `json:\"created\"`\n}\n\n// ChannelHistoryChangedEvent represents the Channel history changed event\ntype ChannelHistoryChangedEvent struct {\n\tType           string `json:\"type\"`\n\tLatest         string `json:\"latest\"`\n\tTimestamp      string `json:\"ts\"`\n\tEventTimestamp string `json:\"event_ts\"`\n}\n\n// ChannelMarkedEvent represents the Channel marked event\ntype ChannelMarkedEvent ChannelInfoEvent\n\n// ChannelLeftEvent represents the Channel left event\ntype ChannelLeftEvent ChannelInfoEvent\n\n// ChannelDeletedEvent represents the Channel deleted event\ntype ChannelDeletedEvent ChannelInfoEvent\n\n// ChannelArchiveEvent represents the Channel archive event\ntype ChannelArchiveEvent ChannelInfoEvent\n\n// ChannelUnarchiveEvent represents the Channel unarchive event\ntype ChannelUnarchiveEvent ChannelInfoEvent\n"
        },
        {
          "name": "websocket_desktop_notification.go",
          "type": "blob",
          "size": 0.7060546875,
          "content": "package slack\n\n// DesktopNotificationEvent represents the update event for Desktop Notification.\ntype DesktopNotificationEvent struct {\n\tType            string `json:\"type\"`\n\tTitle           string `json:\"title\"`\n\tSubtitle        string `json:\"subtitle\"`\n\tMessage         string `json:\"msg\"`\n\tTimestamp       string `json:\"ts\"`\n\tContent         string `json:\"content\"`\n\tChannel         string `json:\"channel\"`\n\tLaunchURI       string `json:\"launchUri\"`\n\tAvatarImage     string `json:\"avatarImage\"`\n\tSsbFilename     string `json:\"ssbFilename\"`\n\tImageURI        string `json:\"imageUri\"`\n\tIsShared        bool   `json:\"is_shared\"`\n\tIsChannelInvite bool   `json:\"is_channel_invite\"`\n\tEventTimestamp  string `json:\"event_ts\"`\n}\n"
        },
        {
          "name": "websocket_dm.go",
          "type": "blob",
          "size": 0.693359375,
          "content": "package slack\n\n// IMCreatedEvent represents the IM created event\ntype IMCreatedEvent struct {\n\tType    string             `json:\"type\"`\n\tUser    string             `json:\"user\"`\n\tChannel ChannelCreatedInfo `json:\"channel\"`\n}\n\n// IMHistoryChangedEvent represents the IM history changed event\ntype IMHistoryChangedEvent ChannelHistoryChangedEvent\n\n// IMOpenEvent represents the IM open event\ntype IMOpenEvent ChannelInfoEvent\n\n// IMCloseEvent represents the IM close event\ntype IMCloseEvent ChannelInfoEvent\n\n// IMMarkedEvent represents the IM marked event\ntype IMMarkedEvent ChannelInfoEvent\n\n// IMMarkedHistoryChanged represents the IM marked history changed event\ntype IMMarkedHistoryChanged ChannelInfoEvent\n"
        },
        {
          "name": "websocket_dnd.go",
          "type": "blob",
          "size": 0.2099609375,
          "content": "package slack\n\n// DNDUpdatedEvent represents the update event for Do Not Disturb\ntype DNDUpdatedEvent struct {\n\tType   string    `json:\"type\"`\n\tUser   string    `json:\"user\"`\n\tStatus DNDStatus `json:\"dnd_status\"`\n}\n"
        },
        {
          "name": "websocket_files.go",
          "type": "blob",
          "size": 1.380859375,
          "content": "package slack\n\n// FileActionEvent represents the File action event\ntype fileActionEvent struct {\n\tType           string `json:\"type\"`\n\tEventTimestamp string `json:\"event_ts\"`\n\tFile           File   `json:\"file\"`\n\t// FileID is used for FileDeletedEvent\n\tFileID string `json:\"file_id,omitempty\"`\n}\n\n// FileCreatedEvent represents the File created event\ntype FileCreatedEvent fileActionEvent\n\n// FileSharedEvent represents the File shared event\ntype FileSharedEvent fileActionEvent\n\n// FilePublicEvent represents the File public event\ntype FilePublicEvent fileActionEvent\n\n// FileUnsharedEvent represents the File unshared event\ntype FileUnsharedEvent fileActionEvent\n\n// FileChangeEvent represents the File change event\ntype FileChangeEvent fileActionEvent\n\n// FileDeletedEvent represents the File deleted event\ntype FileDeletedEvent fileActionEvent\n\n// FilePrivateEvent represents the File private event\ntype FilePrivateEvent fileActionEvent\n\n// FileCommentAddedEvent represents the File comment added event\ntype FileCommentAddedEvent struct {\n\tfileActionEvent\n\tComment Comment `json:\"comment\"`\n}\n\n// FileCommentEditedEvent represents the File comment edited event\ntype FileCommentEditedEvent struct {\n\tfileActionEvent\n\tComment Comment `json:\"comment\"`\n}\n\n// FileCommentDeletedEvent represents the File comment deleted event\ntype FileCommentDeletedEvent struct {\n\tfileActionEvent\n\tComment string `json:\"comment\"`\n}\n"
        },
        {
          "name": "websocket_groups.go",
          "type": "blob",
          "size": 1.5185546875,
          "content": "package slack\n\n// GroupCreatedEvent represents the Group created event\ntype GroupCreatedEvent struct {\n\tType    string             `json:\"type\"`\n\tUser    string             `json:\"user\"`\n\tChannel ChannelCreatedInfo `json:\"channel\"`\n}\n\n// XXX: Should we really do this? event.Group is probably nicer than event.Channel\n// even though the api returns \"channel\"\n\n// GroupMarkedEvent represents the Group marked event\ntype GroupMarkedEvent ChannelInfoEvent\n\n// GroupOpenEvent represents the Group open event\ntype GroupOpenEvent ChannelInfoEvent\n\n// GroupCloseEvent represents the Group close event\ntype GroupCloseEvent ChannelInfoEvent\n\n// GroupArchiveEvent represents the Group archive event\ntype GroupArchiveEvent ChannelInfoEvent\n\n// GroupUnarchiveEvent represents the Group unarchive event\ntype GroupUnarchiveEvent ChannelInfoEvent\n\n// GroupLeftEvent represents the Group left event\ntype GroupLeftEvent ChannelInfoEvent\n\n// GroupJoinedEvent represents the Group joined event\ntype GroupJoinedEvent ChannelJoinedEvent\n\n// GroupRenameEvent represents the Group rename event\ntype GroupRenameEvent struct {\n\tType      string          `json:\"type\"`\n\tGroup     GroupRenameInfo `json:\"channel\"`\n\tTimestamp string          `json:\"ts\"`\n}\n\n// GroupRenameInfo represents the group info related to the renamed group\ntype GroupRenameInfo struct {\n\tID      string `json:\"id\"`\n\tName    string `json:\"name\"`\n\tCreated string `json:\"created\"`\n}\n\n// GroupHistoryChangedEvent represents the Group history changed event\ntype GroupHistoryChangedEvent ChannelHistoryChangedEvent\n"
        },
        {
          "name": "websocket_internals.go",
          "type": "blob",
          "size": 2.3662109375,
          "content": "package slack\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n/**\n * Internal events, created by this lib and not mapped to Slack APIs.\n */\n\n// ConnectedEvent is used for when we connect to Slack\ntype ConnectedEvent struct {\n\tConnectionCount int // 1 = first time, 2 = second time\n\tInfo            *Info\n}\n\n// ConnectionErrorEvent contains information about a connection error\ntype ConnectionErrorEvent struct {\n\tAttempt  int\n\tBackoff  time.Duration // how long we'll wait before the next attempt\n\tErrorObj error\n}\n\nfunc (c *ConnectionErrorEvent) Error() string {\n\treturn c.ErrorObj.Error()\n}\n\n// ConnectingEvent contains information about our connection attempt\ntype ConnectingEvent struct {\n\tAttempt         int // 1 = first attempt, 2 = second attempt\n\tConnectionCount int\n}\n\n// DisconnectedEvent contains information about how we disconnected\ntype DisconnectedEvent struct {\n\tIntentional bool\n\tCause       error\n}\n\n// LatencyReport contains information about connection latency\ntype LatencyReport struct {\n\tValue time.Duration\n}\n\n// InvalidAuthEvent is used in case we can't even authenticate with the API\ntype InvalidAuthEvent struct{}\n\n// UnmarshallingErrorEvent is used when there are issues deconstructing a response\ntype UnmarshallingErrorEvent struct {\n\tErrorObj error\n}\n\nfunc (u UnmarshallingErrorEvent) Error() string {\n\treturn u.ErrorObj.Error()\n}\n\n// MessageTooLongEvent is used when sending a message that is too long\ntype MessageTooLongEvent struct {\n\tMessage   OutgoingMessage\n\tMaxLength int\n}\n\nfunc (m *MessageTooLongEvent) Error() string {\n\treturn fmt.Sprintf(\"Message too long (max %d characters)\", m.MaxLength)\n}\n\n// RateLimitEvent is used when Slack warns that rate-limits are being hit.\ntype RateLimitEvent struct{}\n\nfunc (e *RateLimitEvent) Error() string {\n\treturn \"Messages are being sent too fast.\"\n}\n\n// OutgoingErrorEvent contains information in case there were errors sending messages\ntype OutgoingErrorEvent struct {\n\tMessage  OutgoingMessage\n\tErrorObj error\n}\n\nfunc (o OutgoingErrorEvent) Error() string {\n\treturn o.ErrorObj.Error()\n}\n\n// IncomingEventError contains information about an unexpected error receiving a websocket event\ntype IncomingEventError struct {\n\tErrorObj error\n}\n\nfunc (i *IncomingEventError) Error() string {\n\treturn i.ErrorObj.Error()\n}\n\n// AckErrorEvent i\ntype AckErrorEvent struct {\n\tErrorObj error\n\tReplyTo  int\n}\n\nfunc (a *AckErrorEvent) Error() string {\n\treturn a.ErrorObj.Error()\n}\n"
        },
        {
          "name": "websocket_managed_conn.go",
          "type": "blob",
          "size": 19.3173828125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\tstdurl \"net/url\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/slack-go/slack/internal/backoff\"\n\t\"github.com/slack-go/slack/internal/errorsx\"\n\t\"github.com/slack-go/slack/internal/timex\"\n)\n\n// UnmappedError represents error occurred when there is no mapping between given event name\n// and corresponding Go struct.\ntype UnmappedError struct {\n\t// EventType returns event type name.\n\tEventType string\n\t// RawEvent returns raw event body.\n\tRawEvent json.RawMessage\n\n\tctxMsg string\n}\n\n// NewUnmappedError returns new UnmappedError instance.\nfunc NewUnmappedError(ctxMsg, eventType string, raw json.RawMessage) *UnmappedError {\n\treturn &UnmappedError{\n\t\tctxMsg:    ctxMsg,\n\t\tEventType: eventType,\n\t\tRawEvent:  raw,\n\t}\n}\n\n// Error returns human-readable error message.\nfunc (u UnmappedError) Error() string {\n\treturn fmt.Sprintf(\"%s: Received unmapped event %q\", u.ctxMsg, u.EventType)\n}\n\n// ManageConnection can be called on a Slack RTM instance returned by the\n// NewRTM method. It will connect to the slack RTM API and handle all incoming\n// and outgoing events. If a connection fails then it will attempt to reconnect\n// and will notify any listeners through an error event on the IncomingEvents\n// channel.\n//\n// If the connection ends and the disconnect was unintentional then this will\n// attempt to reconnect.\n//\n// This should only be called once per slack API! Otherwise expect undefined\n// behavior.\n//\n// The defined error events are located in websocket_internals.go.\nfunc (rtm *RTM) ManageConnection() {\n\tvar (\n\t\terr  error\n\t\tinfo *Info\n\t\tconn *websocket.Conn\n\t)\n\n\tfor connectionCount := 0; ; connectionCount++ {\n\t\t// start trying to connect\n\t\t// the returned err is already passed onto the IncomingEvents channel\n\t\tif info, conn, err = rtm.connect(connectionCount, rtm.useRTMStart); err != nil {\n\t\t\t// when the connection is unsuccessful its fatal, and we need to bail out.\n\t\t\trtm.Debugf(\"Failed to connect with RTM on try %d: %s\", connectionCount, err)\n\t\t\trtm.disconnect()\n\t\t\treturn\n\t\t}\n\n\t\t// lock to prevent data races with Disconnect particularly around isConnected\n\t\t// and conn.\n\t\trtm.mu.Lock()\n\t\trtm.conn = conn\n\t\trtm.info = info\n\t\trtm.mu.Unlock()\n\n\t\trtm.IncomingEvents <- RTMEvent{\"connected\", &ConnectedEvent{\n\t\t\tConnectionCount: connectionCount,\n\t\t\tInfo:            info,\n\t\t}}\n\n\t\trtm.Debugf(\"RTM connection succeeded on try %d\", connectionCount)\n\n\t\trawEvents := make(chan json.RawMessage)\n\t\t// we're now connected so we can set up listeners\n\t\tgo rtm.handleIncomingEvents(rawEvents)\n\t\t// this should be a blocking call until the connection has ended\n\t\trtm.handleEvents(rawEvents)\n\n\t\tselect {\n\t\tcase <-rtm.disconnected:\n\t\t\t// after handle events returns we need to check if we're disconnected\n\t\t\t// when this happens we need to cleanup the newly created connection.\n\t\t\tif err = conn.Close(); err != nil {\n\t\t\t\trtm.Debugln(\"failed to close conn on disconnected RTM\", err)\n\t\t\t}\n\t\t\treturn\n\t\tdefault:\n\t\t\t// otherwise continue and run the loop again to reconnect\n\t\t}\n\t}\n}\n\n// connect attempts to connect to the slack websocket API. It handles any\n// errors that occur while connecting and will return once a connection\n// has been successfully opened.\n// If useRTMStart is false then it uses rtm.connect to create the connection,\n// otherwise it uses rtm.start.\nfunc (rtm *RTM) connect(connectionCount int, useRTMStart bool) (*Info, *websocket.Conn, error) {\n\tconst (\n\t\terrInvalidAuth      = \"invalid_auth\"\n\t\terrInactiveAccount  = \"account_inactive\"\n\t\terrMissingAuthToken = \"not_authed\"\n\t\terrTokenRevoked     = \"token_revoked\"\n\t)\n\n\t// used to provide exponential backoff wait time with jitter before trying\n\t// to connect to slack again\n\tboff := &backoff.Backoff{\n\t\tMax: 5 * time.Minute,\n\t}\n\n\tfor {\n\t\tvar (\n\t\t\tbackoff time.Duration\n\t\t)\n\n\t\t// send connecting event\n\t\trtm.IncomingEvents <- RTMEvent{\"connecting\", &ConnectingEvent{\n\t\t\tAttempt:         boff.Attempts() + 1,\n\t\t\tConnectionCount: connectionCount,\n\t\t}}\n\n\t\t// attempt to start the connection\n\t\tinfo, conn, err := rtm.startRTMAndDial(useRTMStart)\n\t\tif err == nil {\n\t\t\treturn info, conn, nil\n\t\t}\n\n\t\t// check for fatal errors\n\t\tswitch err.Error() {\n\t\tcase errInvalidAuth, errInactiveAccount, errMissingAuthToken, errTokenRevoked:\n\t\t\trtm.Debugf(\"invalid auth when connecting with RTM: %s\", err)\n\t\t\trtm.IncomingEvents <- RTMEvent{\"invalid_auth\", &InvalidAuthEvent{}}\n\t\t\treturn nil, nil, err\n\t\tdefault:\n\t\t}\n\n\t\tswitch actual := err.(type) {\n\t\tcase StatusCodeError:\n\t\t\tif actual.Code == http.StatusNotFound {\n\t\t\t\trtm.Debugf(\"invalid auth when connecting with RTM: %s\", err)\n\t\t\t\trtm.IncomingEvents <- RTMEvent{\"invalid_auth\", &InvalidAuthEvent{}}\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\tcase *RateLimitedError:\n\t\t\tbackoff = actual.RetryAfter\n\t\tdefault:\n\t\t}\n\n\t\tbackoff = timex.Max(backoff, boff.Duration())\n\t\t// any other errors are treated as recoverable and we try again after\n\t\t// sending the event along the IncomingEvents channel\n\t\trtm.IncomingEvents <- RTMEvent{\"connection_error\", &ConnectionErrorEvent{\n\t\t\tAttempt:  boff.Attempts(),\n\t\t\tBackoff:  backoff,\n\t\t\tErrorObj: err,\n\t\t}}\n\n\t\t// get time we should wait before attempting to connect again\n\t\trtm.Debugf(\"reconnection %d failed: %s reconnecting in %v\\n\", boff.Attempts(), err, backoff)\n\n\t\t// wait for one of the following to occur,\n\t\t// backoff duration has elapsed, killChannel is signalled, or\n\t\t// the rtm finishes disconnecting.\n\t\tselect {\n\t\tcase <-time.After(backoff): // retry after the backoff.\n\t\tcase intentional := <-rtm.killChannel:\n\t\t\tif intentional {\n\t\t\t\trtm.killConnection(intentional, ErrRTMDisconnected)\n\t\t\t\treturn nil, nil, ErrRTMDisconnected\n\t\t\t}\n\t\tcase <-rtm.disconnected:\n\t\t\treturn nil, nil, ErrRTMDisconnected\n\t\t}\n\t}\n}\n\n// startRTMAndDial attempts to connect to the slack websocket. If useRTMStart is true,\n// then it returns the  full information returned by the \"rtm.start\" method on the\n// slack API. Else it uses the \"rtm.connect\" method to connect\nfunc (rtm *RTM) startRTMAndDial(useRTMStart bool) (info *Info, _ *websocket.Conn, err error) {\n\tvar (\n\t\turl string\n\t)\n\n\tif useRTMStart {\n\t\trtm.Debugf(\"Starting RTM\")\n\t\tinfo, url, err = rtm.StartRTM()\n\t} else {\n\t\trtm.Debugf(\"Connecting to RTM\")\n\t\tinfo, url, err = rtm.ConnectRTM()\n\t}\n\tif err != nil {\n\t\trtm.Debugf(\"Failed to start or connect to RTM: %s\", err)\n\t\treturn nil, nil, err\n\t}\n\n\t// install connection parameters\n\tu, err := stdurl.Parse(url)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu.RawQuery = rtm.connParams.Encode()\n\turl = u.String()\n\n\trtm.Debugf(\"Dialing to websocket on url %s\", url)\n\t// Only use HTTPS for connections to prevent MITM attacks on the connection.\n\tupgradeHeader := http.Header{}\n\tupgradeHeader.Add(\"Origin\", \"https://api.slack.com\")\n\tdialer := websocket.DefaultDialer\n\tif rtm.dialer != nil {\n\t\tdialer = rtm.dialer\n\t}\n\tconn, _, err := dialer.Dial(url, upgradeHeader)\n\tif err != nil {\n\t\trtm.Debugf(\"Failed to dial to the websocket: %s\", err)\n\t\treturn nil, nil, err\n\t}\n\treturn info, conn, err\n}\n\n// killConnection stops the websocket connection and signals to all goroutines\n// that they should cease listening to the connection for events.\n//\n// This should not be called directly! Instead a boolean value (true for\n// intentional, false otherwise) should be sent to the killChannel on the RTM.\nfunc (rtm *RTM) killConnection(intentional bool, cause error) (err error) {\n\trtm.Debugln(\"killing connection\", cause)\n\n\tif rtm.conn != nil {\n\t\terr = rtm.conn.Close()\n\t}\n\n\trtm.IncomingEvents <- RTMEvent{\"disconnected\", &DisconnectedEvent{Intentional: intentional, Cause: cause}}\n\n\tif intentional {\n\t\trtm.disconnect()\n\t}\n\n\treturn err\n}\n\n// handleEvents is a blocking function that handles all events. This sends\n// pings when asked to (on rtm.forcePing) and upon every given elapsed\n// interval. This also sends outgoing messages that are received from the RTM's\n// outgoingMessages channel. This also handles incoming raw events from the RTM\n// rawEvents channel.\nfunc (rtm *RTM) handleEvents(events chan json.RawMessage) {\n\tticker := time.NewTicker(rtm.pingInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\t// catch \"stop\" signal on channel close\n\t\tcase intentional := <-rtm.killChannel:\n\t\t\t_ = rtm.killConnection(intentional, errorsx.String(\"signaled\"))\n\t\t\treturn\n\t\t// detect when the connection is dead.\n\t\tcase <-rtm.pingDeadman.C:\n\t\t\t_ = rtm.killConnection(false, ErrRTMDeadman)\n\t\t\treturn\n\t\t// send pings on ticker interval\n\t\tcase <-ticker.C:\n\t\t\tif err := rtm.ping(); err != nil {\n\t\t\t\t_ = rtm.killConnection(false, err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-rtm.forcePing:\n\t\t\tif err := rtm.ping(); err != nil {\n\t\t\t\t_ = rtm.killConnection(false, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t// listen for messages that need to be sent\n\t\tcase msg := <-rtm.outgoingMessages:\n\t\t\trtm.sendOutgoingMessage(msg)\n\t\t\t// listen for incoming messages that need to be parsed\n\t\tcase rawEvent := <-events:\n\t\t\tswitch rtm.handleRawEvent(rawEvent) {\n\t\t\tcase rtmEventTypeGoodbye:\n\t\t\t\t// kill the connection, but DO NOT RETURN, a follow up kill signal will\n\t\t\t\t// be sent that still needs to be processed. this duplication is because\n\t\t\t\t// the event reader restarts once it emits the goodbye event.\n\t\t\t\t// unlike the other cases in this function a final read will be triggered\n\t\t\t\t// against the connection which will emit a kill signal. if we return early\n\t\t\t\t// this kill signal will be processed by the next connection.\n\t\t\t\t_ = rtm.killConnection(false, ErrRTMGoodbye)\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n}\n\n// handleIncomingEvents monitors the RTM's opened websocket for any incoming\n// events. It pushes the raw events into the channel.\n//\n// This will stop executing once the RTM's when a fatal error is detected, or\n// a disconnect occurs.\nfunc (rtm *RTM) handleIncomingEvents(events chan json.RawMessage) {\n\tfor {\n\t\tif err := rtm.receiveIncomingEvent(events); err != nil {\n\t\t\tselect {\n\t\t\tcase rtm.killChannel <- false:\n\t\t\tcase <-rtm.disconnected:\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (rtm *RTM) sendWithDeadline(msg interface{}) error {\n\t// set a write deadline on the connection\n\tif err := rtm.conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n\t\treturn err\n\t}\n\tif err := rtm.conn.WriteJSON(msg); err != nil {\n\t\treturn err\n\t}\n\t// remove write deadline\n\treturn rtm.conn.SetWriteDeadline(time.Time{})\n}\n\n// sendOutgoingMessage sends the given OutgoingMessage to the slack websocket.\n//\n// It does not currently detect if a outgoing message fails due to a disconnect\n// and instead lets a future failed 'PING' detect the failed connection.\nfunc (rtm *RTM) sendOutgoingMessage(msg OutgoingMessage) {\n\trtm.Debugln(\"Sending message:\", msg)\n\tif len([]rune(msg.Text)) > MaxMessageTextLength {\n\t\trtm.IncomingEvents <- RTMEvent{\"outgoing_error\", &MessageTooLongEvent{\n\t\t\tMessage:   msg,\n\t\t\tMaxLength: MaxMessageTextLength,\n\t\t}}\n\t\treturn\n\t}\n\n\tif err := rtm.sendWithDeadline(msg); err != nil {\n\t\trtm.IncomingEvents <- RTMEvent{\"outgoing_error\", &OutgoingErrorEvent{\n\t\t\tMessage:  msg,\n\t\t\tErrorObj: err,\n\t\t}}\n\t}\n}\n\n// ping sends a 'PING' message to the RTM's websocket. If the 'PING' message\n// fails to send then this returns an error signifying that the connection\n// should be considered disconnected.\n//\n// This does not handle incoming 'PONG' responses but does store the time of\n// each successful 'PING' send so latency can be detected upon a 'PONG'\n// response.\nfunc (rtm *RTM) ping() error {\n\tid := rtm.idGen.Next()\n\trtm.Debugln(\"Sending PING \", id)\n\tmsg := &Ping{ID: id, Type: \"ping\", Timestamp: time.Now().Unix()}\n\n\tif err := rtm.sendWithDeadline(msg); err != nil {\n\t\trtm.Debugf(\"RTM Error sending 'PING %d': %s\", id, err.Error())\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// receiveIncomingEvent attempts to receive an event from the RTM's websocket.\n// This will block until a frame is available from the websocket.\n// If the read from the websocket results in a fatal error, this function will return non-nil.\nfunc (rtm *RTM) receiveIncomingEvent(events chan json.RawMessage) error {\n\tevent := json.RawMessage{}\n\terr := rtm.conn.ReadJSON(&event)\n\n\t// check if the connection was closed.\n\tif websocket.IsUnexpectedCloseError(err) {\n\t\treturn err\n\t}\n\n\tswitch {\n\tcase err == io.ErrUnexpectedEOF:\n\t\t// EOF's don't seem to signify a failed connection so instead we ignore\n\t\t// them here and detect a failed connection upon attempting to send a\n\t\t// 'PING' message\n\n\t\t// trigger a 'PING' to detect potential websocket disconnect\n\t\tselect {\n\t\tcase rtm.forcePing <- true:\n\t\tcase <-rtm.disconnected:\n\t\t}\n\tcase err != nil:\n\t\t// All other errors from ReadJSON come from NextReader, and should\n\t\t// kill the read loop and force a reconnect.\n\t\trtm.IncomingEvents <- RTMEvent{\"incoming_error\", &IncomingEventError{\n\t\t\tErrorObj: err,\n\t\t}}\n\n\t\treturn err\n\tcase len(event) == 0:\n\t\trtm.Debugln(\"Received empty event\")\n\tdefault:\n\t\trtm.Debugln(\"Incoming Event:\", string(event))\n\t\tselect {\n\t\tcase events <- event:\n\t\tcase <-rtm.disconnected:\n\t\t\trtm.Debugln(\"disonnected while attempting to send raw event\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// handleRawEvent takes a raw JSON message received from the slack websocket\n// and handles the encoded event.\n// returns the event type of the message.\nfunc (rtm *RTM) handleRawEvent(rawEvent json.RawMessage) string {\n\tevent := &Event{}\n\terr := json.Unmarshal(rawEvent, event)\n\tif err != nil {\n\t\trtm.IncomingEvents <- RTMEvent{\"unmarshalling_error\", &UnmarshallingErrorEvent{err}}\n\t\treturn \"\"\n\t}\n\n\tswitch event.Type {\n\tcase rtmEventTypeAck:\n\t\trtm.handleAck(rawEvent)\n\tcase rtmEventTypeHello:\n\t\trtm.IncomingEvents <- RTMEvent{\"hello\", &HelloEvent{}}\n\tcase rtmEventTypePong:\n\t\trtm.handlePong(rawEvent)\n\tcase rtmEventTypeGoodbye:\n\t\t// just return the event type up for goodbye, will be handled by caller.\n\tdefault:\n\t\trtm.handleEvent(event.Type, rawEvent)\n\t}\n\n\treturn event.Type\n}\n\n// handleAck handles an incoming 'ACK' message.\nfunc (rtm *RTM) handleAck(event json.RawMessage) {\n\tack := &AckMessage{}\n\tif err := json.Unmarshal(event, ack); err != nil {\n\t\trtm.Debugln(\"RTM Error unmarshalling 'ack' event:\", err)\n\t\trtm.Debugln(\" -> Erroneous 'ack' event:\", string(event))\n\t\treturn\n\t}\n\n\tif ack.Ok {\n\t\trtm.IncomingEvents <- RTMEvent{\"ack\", ack}\n\t} else if ack.RTMResponse.Error != nil {\n\t\t// As there is no documentation for RTM error-codes, this\n\t\t// identification of a rate-limit warning is very brittle.\n\t\tif ack.RTMResponse.Error.Code == -1 && ack.RTMResponse.Error.Msg == \"slow down, too many messages...\" {\n\t\t\trtm.IncomingEvents <- RTMEvent{\"ack_error\", &RateLimitEvent{}}\n\t\t} else {\n\t\t\trtm.IncomingEvents <- RTMEvent{\"ack_error\", &AckErrorEvent{ack.Error, ack.ReplyTo}}\n\t\t}\n\t} else {\n\t\trtm.IncomingEvents <- RTMEvent{\"ack_error\", &AckErrorEvent{ErrorObj: fmt.Errorf(\"ack decode failure\")}}\n\t}\n}\n\n// handlePong handles an incoming 'PONG' message which should be in response to\n// a previously sent 'PING' message. This is then used to compute the\n// connection's latency.\nfunc (rtm *RTM) handlePong(event json.RawMessage) {\n\tvar (\n\t\tp Pong\n\t)\n\n\trtm.resetDeadman()\n\n\tif err := json.Unmarshal(event, &p); err != nil {\n\t\trtm.Client.log.Println(\"RTM Error unmarshalling 'pong' event:\", err)\n\t\treturn\n\t}\n\n\tlatency := time.Since(time.Unix(p.Timestamp, 0))\n\trtm.IncomingEvents <- RTMEvent{\"latency_report\", &LatencyReport{Value: latency}}\n}\n\n// handleEvent is the \"default\" response to an event that does not have a\n// special case. It matches the command's name to a mapping of defined events\n// and then sends the corresponding event struct to the IncomingEvents channel.\n// If the event type is not found or the event cannot be unmarshalled into the\n// correct struct then this sends an UnmarshallingErrorEvent to the\n// IncomingEvents channel.\nfunc (rtm *RTM) handleEvent(typeStr string, event json.RawMessage) {\n\tv, exists := EventMapping[typeStr]\n\tif !exists {\n\t\trtm.Debugf(\"RTM Error - received unmapped event %q: %s\\n\", typeStr, string(event))\n\t\terr := NewUnmappedError(\"RTM Error\", typeStr, event)\n\t\trtm.IncomingEvents <- RTMEvent{\"unmarshalling_error\", &UnmarshallingErrorEvent{err}}\n\t\treturn\n\t}\n\tt := reflect.TypeOf(v)\n\trecvEvent := reflect.New(t).Interface()\n\terr := json.Unmarshal(event, recvEvent)\n\tif err != nil {\n\t\trtm.Debugf(\"RTM Error, could not unmarshall event %q: %s\\n\", typeStr, string(event))\n\t\terr := fmt.Errorf(\"RTM Error: Could not unmarshall event %q\", typeStr)\n\t\trtm.IncomingEvents <- RTMEvent{\"unmarshalling_error\", &UnmarshallingErrorEvent{err}}\n\t\treturn\n\t}\n\trtm.IncomingEvents <- RTMEvent{typeStr, recvEvent}\n}\n\n// EventMapping holds a mapping of event names to their corresponding struct\n// implementations. The structs should be instances of the unmarshalling\n// target for the matching event type.\nvar EventMapping = map[string]interface{}{\n\t\"message\":         MessageEvent{},\n\t\"presence_change\": PresenceChangeEvent{},\n\t\"user_typing\":     UserTypingEvent{},\n\n\t\"channel_marked\":          ChannelMarkedEvent{},\n\t\"channel_created\":         ChannelCreatedEvent{},\n\t\"channel_joined\":          ChannelJoinedEvent{},\n\t\"channel_left\":            ChannelLeftEvent{},\n\t\"channel_deleted\":         ChannelDeletedEvent{},\n\t\"channel_rename\":          ChannelRenameEvent{},\n\t\"channel_archive\":         ChannelArchiveEvent{},\n\t\"channel_unarchive\":       ChannelUnarchiveEvent{},\n\t\"channel_history_changed\": ChannelHistoryChangedEvent{},\n\n\t\"dnd_updated\":      DNDUpdatedEvent{},\n\t\"dnd_updated_user\": DNDUpdatedEvent{},\n\n\t\"im_created\":         IMCreatedEvent{},\n\t\"im_open\":            IMOpenEvent{},\n\t\"im_close\":           IMCloseEvent{},\n\t\"im_marked\":          IMMarkedEvent{},\n\t\"im_history_changed\": IMHistoryChangedEvent{},\n\n\t\"group_marked\":          GroupMarkedEvent{},\n\t\"group_open\":            GroupOpenEvent{},\n\t\"group_joined\":          GroupJoinedEvent{},\n\t\"group_left\":            GroupLeftEvent{},\n\t\"group_close\":           GroupCloseEvent{},\n\t\"group_rename\":          GroupRenameEvent{},\n\t\"group_archive\":         GroupArchiveEvent{},\n\t\"group_unarchive\":       GroupUnarchiveEvent{},\n\t\"group_history_changed\": GroupHistoryChangedEvent{},\n\n\t\"file_created\":         FileCreatedEvent{},\n\t\"file_shared\":          FileSharedEvent{},\n\t\"file_unshared\":        FileUnsharedEvent{},\n\t\"file_public\":          FilePublicEvent{},\n\t\"file_private\":         FilePrivateEvent{},\n\t\"file_change\":          FileChangeEvent{},\n\t\"file_deleted\":         FileDeletedEvent{},\n\t\"file_comment_added\":   FileCommentAddedEvent{},\n\t\"file_comment_edited\":  FileCommentEditedEvent{},\n\t\"file_comment_deleted\": FileCommentDeletedEvent{},\n\n\t\"pin_added\":   PinAddedEvent{},\n\t\"pin_removed\": PinRemovedEvent{},\n\n\t\"star_added\":   StarAddedEvent{},\n\t\"star_removed\": StarRemovedEvent{},\n\n\t\"reaction_added\":   ReactionAddedEvent{},\n\t\"reaction_removed\": ReactionRemovedEvent{},\n\n\t\"pref_change\": PrefChangeEvent{},\n\n\t\"team_join\":              TeamJoinEvent{},\n\t\"team_rename\":            TeamRenameEvent{},\n\t\"team_pref_change\":       TeamPrefChangeEvent{},\n\t\"team_domain_change\":     TeamDomainChangeEvent{},\n\t\"team_migration_started\": TeamMigrationStartedEvent{},\n\n\t\"manual_presence_change\": ManualPresenceChangeEvent{},\n\n\t\"user_change\": UserChangeEvent{},\n\n\t\"emoji_changed\": EmojiChangedEvent{},\n\n\t\"commands_changed\": CommandsChangedEvent{},\n\n\t\"email_domain_changed\": EmailDomainChangedEvent{},\n\n\t\"bot_added\":   BotAddedEvent{},\n\t\"bot_changed\": BotChangedEvent{},\n\n\t\"accounts_changed\": AccountsChangedEvent{},\n\n\t\"reconnect_url\": ReconnectUrlEvent{},\n\n\t\"member_joined_channel\": MemberJoinedChannelEvent{},\n\t\"member_left_channel\":   MemberLeftChannelEvent{},\n\n\t\"subteam_created\":         SubteamCreatedEvent{},\n\t\"subteam_members_changed\": SubteamMembersChangedEvent{},\n\t\"subteam_self_added\":      SubteamSelfAddedEvent{},\n\t\"subteam_self_removed\":    SubteamSelfRemovedEvent{},\n\t\"subteam_updated\":         SubteamUpdatedEvent{},\n\n\t\"desktop_notification\":       DesktopNotificationEvent{},\n\t\"mobile_in_app_notification\": MobileInAppNotificationEvent{},\n}\n"
        },
        {
          "name": "websocket_managed_conn_test.go",
          "type": "blob",
          "size": 9.314453125,
          "content": "package slack_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\twebsocket \"github.com/gorilla/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/slack-go/slack\"\n\t\"github.com/slack-go/slack/slacktest\"\n)\n\nconst (\n\ttestMessage = \"test message\"\n\ttestToken   = \"TEST_TOKEN\"\n)\n\nfunc TestRTMBeforeEvents(t *testing.T) {\n\t// Set up the test server.\n\ttestServer := slacktest.NewTestServer()\n\tgo testServer.Start()\n\n\t// Setup and start the RTM.\n\tapi := slack.New(testToken, slack.OptionAPIURL(testServer.GetAPIURL()))\n\trtm := api.NewRTM()\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.DisconnectedEvent:\n\t\t\t\tif ev.Intentional {\n\t\t\t\t\tclose(done)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// t.Logf(\"Discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\tgo rtm.Disconnect()\n\tgo rtm.ManageConnection()\n\tselect {\n\tcase <-done:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Error(\"timed out waiting for disconnect\")\n\t\tt.Fail()\n\t}\n}\n\nfunc TestRTMGoodbye(t *testing.T) {\n\t// Set up the test server.\n\ttestServer := slacktest.NewTestServer(\n\t\tfunc(c slacktest.Customize) {\n\t\t\tc.Handle(\"/ws\", slacktest.Websocket(func(conn *websocket.Conn) {\n\t\t\t\tif err := slacktest.RTMServerSendGoodbye(conn); err != nil {\n\t\t\t\t\tlog.Println(\"failed to send goodbye\", err)\n\t\t\t\t}\n\t\t\t}))\n\t\t},\n\t)\n\tgo testServer.Start()\n\n\t// Setup and start the RTM.\n\tapi := slack.New(\n\t\ttestToken,\n\t\tslack.OptionAPIURL(testServer.GetAPIURL()),\n\t)\n\n\trtm := api.NewRTM(\n\t\tslack.RTMOptionPingInterval(100 * time.Millisecond),\n\t)\n\n\tdone := make(chan struct{})\n\tgo rtm.ManageConnection()\n\tconnected := 0\n\tdisconnected := 0\n\tfunc() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.ConnectedEvent:\n\t\t\t\tconnected += 1\n\t\t\t\tif connected > 5 {\n\t\t\t\t\trtm.Disconnect()\n\t\t\t\t}\n\t\t\tcase *slack.DisconnectedEvent:\n\t\t\t\t// t.Log(\"disconnect event received\", ev.Intentional, ev.Cause)\n\t\t\t\tif ev.Intentional {\n\t\t\t\t\tclose(done)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdisconnected += 1\n\t\t\tdefault:\n\t\t\t\t// t.Logf(\"Discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\t// magic numbers from empirical testing.\n\t\tassert.Equal(t, connected <= 7, true)\n\t\tassert.Equal(t, disconnected <= 12, true)\n\tcase <-time.After(5 * time.Second):\n\t\tt.Error(\"timed out waiting for disconnect\")\n\t\tt.Fail()\n\t}\n}\n\nfunc TestRTMDeadConnection(t *testing.T) {\n\t// Set up the test server.\n\ttestServer := slacktest.NewTestServer(\n\t\tfunc(c slacktest.Customize) {\n\t\t\tc.Handle(\"/ws\", slacktest.Websocket(func(conn *websocket.Conn) {\n\t\t\t\t// closes immediately\n\t\t\t}))\n\t\t},\n\t)\n\tgo testServer.Start()\n\n\t// Setup and start the RTM.\n\tapi := slack.New(\n\t\ttestToken,\n\t\tslack.OptionAPIURL(testServer.GetAPIURL()),\n\t)\n\n\trtm := api.NewRTM(\n\t\tslack.RTMOptionPingInterval(100 * time.Millisecond),\n\t)\n\n\tgo rtm.ManageConnection()\n\tdone := make(chan struct{})\n\tconnected := 0\n\tdisconnected := 0\n\tfunc() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.ConnectedEvent:\n\t\t\t\tconnected += 1\n\t\t\t\tif connected > 5 {\n\t\t\t\t\trtm.Disconnect()\n\t\t\t\t}\n\t\t\tcase *slack.DisconnectedEvent:\n\t\t\t\t// t.Log(\"disconnect event received\", ev.Intentional, ev.Cause)\n\t\t\t\tif ev.Intentional {\n\t\t\t\t\tclose(done)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdisconnected += 1\n\t\t\tdefault:\n\t\t\t\t// t.Logf(\"Discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\t// magic numbers from empirical testing.\n\t\tassert.Equal(t, connected <= 7, true)\n\t\tassert.Equal(t, disconnected <= 7, true)\n\tcase <-time.After(5 * time.Second):\n\t\tt.Error(\"timed out waiting for disconnect\")\n\t\tt.Fail()\n\t}\n}\n\nfunc TestRTMDisconnect(t *testing.T) {\n\t// actually connect to slack here w/ an invalid token\n\tapi := slack.New(testToken)\n\trtm := api.NewRTM()\n\tgo rtm.ManageConnection()\n\n\t// Observe incoming messages.\n\tdone := make(chan struct{})\n\tconnectingReceived := false\n\tdisconnectedReceived := false\n\n\tgo func() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.InvalidAuthEvent:\n\t\t\t\tt.Log(\"invalid auth event received\")\n\t\t\t\tdisconnectedReceived = true\n\t\t\t\tclose(done)\n\t\t\tcase *slack.ConnectingEvent:\n\t\t\t\tconnectingReceived = true\n\t\t\tcase *slack.ConnectedEvent:\n\t\t\t\tt.Error(\"received connected events on an invalid connection\")\n\t\t\t\tt.Fail()\n\t\t\tdefault:\n\t\t\t\tt.Logf(\"discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Error(\"timed out waiting for disconnect\")\n\t\tt.Fail()\n\t}\n\n\t// Verify that all expected events have been received by the RTM client.\n\tassert.True(t, connectingReceived, \"Should have received a connecting event from the RTM instance.\")\n\tassert.True(t, disconnectedReceived, \"Should have received a disconnected event from the RTM instance.\")\n}\n\nfunc TestRTMConnectRateLimit(t *testing.T) {\n\t// Set up the test server.\n\ttestServer := slacktest.NewTestServer(\n\t\tfunc(c slacktest.Customize) {\n\t\t\tc.Handle(\"/rtm.connect\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Header().Add(\"Retry-After\", \"1\")\n\t\t\t\tw.WriteHeader(http.StatusTooManyRequests)\n\t\t\t}))\n\t\t},\n\t)\n\tgo testServer.Start()\n\n\t// Setup and start the RTM.\n\tapi := slack.New(testToken, slack.OptionAPIURL(testServer.GetAPIURL()))\n\trtm := api.NewRTM()\n\tgo rtm.ManageConnection()\n\n\t// Observe incoming failures\n\tconnectionFailure := make(chan *slack.ConnectionErrorEvent)\n\tgo func() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.ConnectingEvent:\n\t\t\tcase *slack.ConnectionErrorEvent:\n\t\t\t\tconnectionFailure <- ev\n\t\t\t\tif ev.Attempt > 5 {\n\t\t\t\t\trtm.Disconnect()\n\t\t\t\t}\n\t\t\tcase *slack.DisconnectedEvent:\n\t\t\t\tif ev.Intentional {\n\t\t\t\t\tclose(connectionFailure)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Logf(\"Discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\n\tprevious := time.Duration(0)\n\tfor ev := range connectionFailure {\n\t\tassert.True(t, previous <= ev.Backoff, fmt.Sprintf(\"backoff should increase during rate limits: %v <= %v\", previous, ev.Backoff))\n\t\tprevious = ev.Backoff\n\t}\n\ttestServer.Stop()\n}\n\nfunc TestRTMSingleConnect(t *testing.T) {\n\t// Set up the test server.\n\ttestServer := slacktest.NewTestServer()\n\tgo testServer.Start()\n\n\t// Setup and start the RTM.\n\tapi := slack.New(testToken, slack.OptionAPIURL(testServer.GetAPIURL()))\n\trtm := api.NewRTM()\n\tgo rtm.ManageConnection()\n\n\t// Observe incoming messages.\n\tdone := make(chan struct{})\n\tconnectingReceived := false\n\tconnectedReceived := false\n\ttestMessageReceived := false\n\tgo func() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.ConnectingEvent:\n\t\t\t\tif connectingReceived {\n\t\t\t\t\tt.Error(\"Received multiple connecting events.\")\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t\tconnectingReceived = true\n\t\t\tcase *slack.ConnectedEvent:\n\t\t\t\tif connectedReceived {\n\t\t\t\t\tt.Error(\"Received multiple connected events.\")\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t\tconnectedReceived = true\n\t\t\tcase *slack.MessageEvent:\n\t\t\t\tif ev.Text == testMessage {\n\t\t\t\t\ttestMessageReceived = true\n\t\t\t\t\trtm.Disconnect()\n\t\t\t\t}\n\t\t\t\tt.Logf(\"Discarding message with content %+v\", ev)\n\t\t\tcase *slack.DisconnectedEvent:\n\t\t\t\tif ev.Intentional {\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Logf(\"Discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Send a message and sleep for some time to make sure the message can be processed client-side.\n\ttestServer.SendDirectMessageToBot(testMessage)\n\t<-done\n\ttestServer.Stop()\n\n\t// Verify that all expected events have been received by the RTM client.\n\tassert.True(t, connectingReceived, \"Should have received a connecting event from the RTM instance.\")\n\tassert.True(t, connectedReceived, \"Should have received a connected event from the RTM instance.\")\n\tassert.True(t, testMessageReceived, \"Should have received a test message from the server.\")\n}\n\nfunc TestRTMUnmappedError(t *testing.T) {\n\tconst unmappedEventName = \"user_status_changed\"\n\t// Set up the test server.\n\ttestServer := slacktest.NewTestServer()\n\tgo testServer.Start()\n\n\t// Setup and start the RTM.\n\tapi := slack.New(testToken, slack.OptionAPIURL(testServer.GetAPIURL()))\n\trtm := api.NewRTM()\n\tgo rtm.ManageConnection()\n\n\t// Observe incoming messages.\n\tdone := make(chan struct{})\n\tvar gotUnmarshallingError *slack.UnmarshallingErrorEvent\n\tgo func() {\n\t\tfor msg := range rtm.IncomingEvents {\n\t\t\tswitch ev := msg.Data.(type) {\n\t\t\tcase *slack.UnmarshallingErrorEvent:\n\t\t\t\tgotUnmarshallingError = ev\n\t\t\t\trtm.Disconnect()\n\t\t\tcase *slack.DisconnectedEvent:\n\t\t\t\tif ev.Intentional {\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Logf(\"Discarded event of type '%s' with content '%#v'\", msg.Type, ev)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Send a message and sleep for some time to make sure the message can be processed client-side.\n\ttestServer.SendToWebsocket(fixSlackMessage(t, unmappedEventName))\n\t<-done\n\ttestServer.Stop()\n\n\t// Verify that we got the expected error with details\n\tunmappedErr, ok := gotUnmarshallingError.ErrorObj.(*slack.UnmappedError)\n\trequire.True(t, ok)\n\tassert.Equal(t, unmappedEventName, unmappedErr.EventType)\n}\n\nfunc fixSlackMessage(t *testing.T, eType string) string {\n\tt.Helper()\n\n\tm := slack.Message{\n\t\tMsg: slack.Msg{\n\t\t\tType:      eType,\n\t\t\tText:      \"Fixture Slack message\",\n\t\t\tTimestamp: fmt.Sprintf(\"%d\", time.Now().Unix()),\n\t\t},\n\t}\n\tmsg, err := json.Marshal(m)\n\trequire.NoError(t, err)\n\n\treturn string(msg)\n}\n"
        },
        {
          "name": "websocket_misc.go",
          "type": "blob",
          "size": 3.720703125,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// AckMessage is used for messages received in reply to other messages\ntype AckMessage struct {\n\tReplyTo   int    `json:\"reply_to\"`\n\tTimestamp string `json:\"ts\"`\n\tText      string `json:\"text\"`\n\tRTMResponse\n}\n\n// RTMResponse encapsulates response details as returned by the Slack API\ntype RTMResponse struct {\n\tOk    bool      `json:\"ok\"`\n\tError *RTMError `json:\"error\"`\n}\n\n// RTMError encapsulates error information as returned by the Slack API\ntype RTMError struct {\n\tCode int\n\tMsg  string\n}\n\nfunc (s RTMError) Error() string {\n\treturn fmt.Sprintf(\"Code %d - %s\", s.Code, s.Msg)\n}\n\n// MessageEvent represents a Slack Message (used as the event type for an incoming message)\ntype MessageEvent Message\n\n// RTMEvent is the main wrapper. You will find all the other messages attached\ntype RTMEvent struct {\n\tType string\n\tData interface{}\n}\n\n// HelloEvent represents the hello event\ntype HelloEvent struct{}\n\n// PresenceChangeEvent represents the presence change event\ntype PresenceChangeEvent struct {\n\tType     string   `json:\"type\"`\n\tPresence string   `json:\"presence\"`\n\tUser     string   `json:\"user\"`\n\tUsers    []string `json:\"users\"`\n}\n\n// UserTypingEvent represents the user typing event\ntype UserTypingEvent struct {\n\tType    string `json:\"type\"`\n\tUser    string `json:\"user\"`\n\tChannel string `json:\"channel\"`\n}\n\n// PrefChangeEvent represents a user preferences change event\ntype PrefChangeEvent struct {\n\tType  string          `json:\"type\"`\n\tName  string          `json:\"name\"`\n\tValue json.RawMessage `json:\"value\"`\n}\n\n// ManualPresenceChangeEvent represents the manual presence change event\ntype ManualPresenceChangeEvent struct {\n\tType     string `json:\"type\"`\n\tPresence string `json:\"presence\"`\n}\n\n// UserChangeEvent represents the user change event\ntype UserChangeEvent struct {\n\tType string `json:\"type\"`\n\tUser User   `json:\"user\"`\n}\n\n// EmojiChangedEvent represents the emoji changed event\ntype EmojiChangedEvent struct {\n\tType           string   `json:\"type\"`\n\tSubType        string   `json:\"subtype\"`\n\tName           string   `json:\"name\"`\n\tNames          []string `json:\"names\"`\n\tValue          string   `json:\"value\"`\n\tEventTimestamp string   `json:\"event_ts\"`\n}\n\n// CommandsChangedEvent represents the commands changed event\ntype CommandsChangedEvent struct {\n\tType           string `json:\"type\"`\n\tEventTimestamp string `json:\"event_ts\"`\n}\n\n// EmailDomainChangedEvent represents the email domain changed event\ntype EmailDomainChangedEvent struct {\n\tType           string `json:\"type\"`\n\tEventTimestamp string `json:\"event_ts\"`\n\tEmailDomain    string `json:\"email_domain\"`\n}\n\n// BotAddedEvent represents the bot added event\ntype BotAddedEvent struct {\n\tType string `json:\"type\"`\n\tBot  Bot    `json:\"bot\"`\n}\n\n// BotChangedEvent represents the bot changed event\ntype BotChangedEvent struct {\n\tType string `json:\"type\"`\n\tBot  Bot    `json:\"bot\"`\n}\n\n// AccountsChangedEvent represents the accounts changed event\ntype AccountsChangedEvent struct {\n\tType string `json:\"type\"`\n}\n\n// ReconnectUrlEvent represents the receiving reconnect url event\ntype ReconnectUrlEvent struct {\n\tType string `json:\"type\"`\n\tURL  string `json:\"url\"`\n}\n\n// MemberJoinedChannelEvent, a user joined a public or private channel\ntype MemberJoinedChannelEvent struct {\n\tType        string `json:\"type\"`\n\tUser        string `json:\"user\"`\n\tChannel     string `json:\"channel\"`\n\tChannelType string `json:\"channel_type\"`\n\tTeam        string `json:\"team\"`\n\tInviter     string `json:\"inviter\"`\n}\n\n// MemberLeftChannelEvent a user left a public or private channel\ntype MemberLeftChannelEvent struct {\n\tType        string `json:\"type\"`\n\tUser        string `json:\"user\"`\n\tChannel     string `json:\"channel\"`\n\tChannelType string `json:\"channel_type\"`\n\tTeam        string `json:\"team\"`\n}\n"
        },
        {
          "name": "websocket_mobile_in_app_notification.go",
          "type": "blob",
          "size": 0.8017578125,
          "content": "package slack\n\n// MobileInAppNotificationEvent represents the update event for Mobile App Notification.\ntype MobileInAppNotificationEvent struct {\n\tType              string `json:\"type\"`\n\tTitle             string `json:\"title\"`\n\tSubtitle          string `json:\"subtitle\"`\n\tTimestamp         string `json:\"ts\"`\n\tChannel           string `json:\"channel\"`\n\tAvatarImage       string `json:\"avatarImage\"`\n\tIsShared          bool   `json:\"is_shared\"`\n\tChannelName       string `json:\"channel_name\"`\n\tAuthorID          string `json:\"author_id\"`\n\tAuthorDisplayName string `json:\"author_display_name\"`\n\tMessageText       string `json:\"msg_text\"`\n\tPushID            string `json:\"push_id\"`\n\tNotifcationID     string `json:\"notif_id\"`\n\tMobileLaunchURI   string `json:\"mobileLaunchUri\"`\n\tEventTimestamp    string `json:\"event_ts\"`\n}\n"
        },
        {
          "name": "websocket_pins.go",
          "type": "blob",
          "size": 0.435546875,
          "content": "package slack\n\ntype pinEvent struct {\n\tType           string `json:\"type\"`\n\tUser           string `json:\"user\"`\n\tItem           Item   `json:\"item\"`\n\tChannel        string `json:\"channel_id\"`\n\tEventTimestamp string `json:\"event_ts\"`\n\tHasPins        bool   `json:\"has_pins,omitempty\"`\n}\n\n// PinAddedEvent represents the Pin added event\ntype PinAddedEvent pinEvent\n\n// PinRemovedEvent represents the Pin removed event\ntype PinRemovedEvent pinEvent\n"
        },
        {
          "name": "websocket_reactions.go",
          "type": "blob",
          "size": 0.826171875,
          "content": "package slack\n\n// ReactionItem is a lighter-weight item than is returned by the reactions list.\ntype ReactionItem struct {\n\tType        string `json:\"type\"`\n\tChannel     string `json:\"channel,omitempty\"`\n\tFile        string `json:\"file,omitempty\"`\n\tFileComment string `json:\"file_comment,omitempty\"`\n\tTimestamp   string `json:\"ts,omitempty\"`\n}\n\ntype ReactionEvent struct {\n\tType           string       `json:\"type\"`\n\tUser           string       `json:\"user\"`\n\tItemUser       string       `json:\"item_user\"`\n\tItem           ReactionItem `json:\"item\"`\n\tReaction       string       `json:\"reaction\"`\n\tEventTimestamp string       `json:\"event_ts\"`\n}\n\n// ReactionAddedEvent represents the Reaction added event\ntype ReactionAddedEvent ReactionEvent\n\n// ReactionRemovedEvent represents the Reaction removed event\ntype ReactionRemovedEvent ReactionEvent\n"
        },
        {
          "name": "websocket_stars.go",
          "type": "blob",
          "size": 0.3720703125,
          "content": "package slack\n\ntype starEvent struct {\n\tType           string      `json:\"type\"`\n\tUser           string      `json:\"user\"`\n\tItem           StarredItem `json:\"item\"`\n\tEventTimestamp string      `json:\"event_ts\"`\n}\n\n// StarAddedEvent represents the Star added event\ntype StarAddedEvent starEvent\n\n// StarRemovedEvent represents the Star removed event\ntype StarRemovedEvent starEvent\n"
        },
        {
          "name": "websocket_subteam.go",
          "type": "blob",
          "size": 1.298828125,
          "content": "package slack\n\n// SubteamCreatedEvent represents the Subteam created event\ntype SubteamCreatedEvent struct {\n\tType    string    `json:\"type\"`\n\tSubteam UserGroup `json:\"subteam\"`\n}\n\n// SubteamCreatedEvent represents the membership of an existing User Group has changed event\ntype SubteamMembersChangedEvent struct {\n\tType               string   `json:\"type\"`\n\tSubteamID          string   `json:\"subteam_id\"`\n\tTeamID             string   `json:\"team_id\"`\n\tDatePreviousUpdate JSONTime `json:\"date_previous_update\"`\n\tDateUpdate         JSONTime `json:\"date_update\"`\n\tAddedUsers         []string `json:\"added_users\"`\n\tAddedUsersCount    int      `json:\"added_users_count\"`\n\tRemovedUsers       []string `json:\"removed_users\"`\n\tRemovedUsersCount  int      `json:\"removed_users_count\"`\n}\n\n// SubteamSelfAddedEvent represents an event of you have been added to a User Group\ntype SubteamSelfAddedEvent struct {\n\tType      string `json:\"type\"`\n\tSubteamID string `json:\"subteam_id\"`\n}\n\n// SubteamSelfRemovedEvent represents an event of you have been removed from a User Group\ntype SubteamSelfRemovedEvent SubteamSelfAddedEvent\n\n// SubteamUpdatedEvent represents an event of an existing User Group has been updated or its members changed\ntype SubteamUpdatedEvent struct {\n\tType    string    `json:\"type\"`\n\tSubteam UserGroup `json:\"subteam\"`\n}\n"
        },
        {
          "name": "websocket_teams.go",
          "type": "blob",
          "size": 0.8955078125,
          "content": "package slack\n\n// TeamJoinEvent represents the Team join event\ntype TeamJoinEvent struct {\n\tType string `json:\"type\"`\n\tUser User   `json:\"user\"`\n}\n\n// TeamRenameEvent represents the Team rename event\ntype TeamRenameEvent struct {\n\tType           string `json:\"type\"`\n\tName           string `json:\"name,omitempty\"`\n\tEventTimestamp string `json:\"event_ts,omitempty\"`\n}\n\n// TeamPrefChangeEvent represents the Team preference change event\ntype TeamPrefChangeEvent struct {\n\tType  string   `json:\"type\"`\n\tName  string   `json:\"name,omitempty\"`\n\tValue []string `json:\"value,omitempty\"`\n}\n\n// TeamDomainChangeEvent represents the Team domain change event\ntype TeamDomainChangeEvent struct {\n\tType   string `json:\"type\"`\n\tURL    string `json:\"url\"`\n\tDomain string `json:\"domain\"`\n}\n\n// TeamMigrationStartedEvent represents the Team migration started event\ntype TeamMigrationStartedEvent struct {\n\tType string `json:\"type\"`\n}\n"
        },
        {
          "name": "workflow_step.go",
          "type": "blob",
          "size": 2.8974609375,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n)\n\nconst VTWorkflowStep ViewType = \"workflow_step\"\n\ntype (\n\tConfigurationModalRequest struct {\n\t\tModalViewRequest\n\t}\n\n\tWorkflowStepCompleteResponse struct {\n\t\tWorkflowStepEditID string                `json:\"workflow_step_edit_id\"`\n\t\tInputs             *WorkflowStepInputs   `json:\"inputs,omitempty\"`\n\t\tOutputs            *[]WorkflowStepOutput `json:\"outputs,omitempty\"`\n\t}\n\n\tWorkflowStepInputElement struct {\n\t\tValue                   string `json:\"value\"`\n\t\tSkipVariableReplacement bool   `json:\"skip_variable_replacement\"`\n\t}\n\n\tWorkflowStepInputs map[string]WorkflowStepInputElement\n\n\tWorkflowStepOutput struct {\n\t\tName  string `json:\"name\"`\n\t\tType  string `json:\"type\"`\n\t\tLabel string `json:\"label\"`\n\t}\n)\n\nfunc NewConfigurationModalRequest(blocks Blocks, privateMetaData string, externalID string) *ConfigurationModalRequest {\n\treturn &ConfigurationModalRequest{\n\t\tModalViewRequest{\n\t\t\tType:            VTWorkflowStep,\n\t\t\tTitle:           nil, // slack configuration modal must not have a title!\n\t\t\tBlocks:          blocks,\n\t\t\tPrivateMetadata: privateMetaData,\n\t\t\tExternalID:      externalID,\n\t\t},\n\t}\n}\n\n// SaveWorkflowStepConfiguration opens a configuration modal for a workflow step.\n// For more information see the SaveWorkflowStepConfigurationContext documentation.\nfunc (api *Client) SaveWorkflowStepConfiguration(workflowStepEditID string, inputs *WorkflowStepInputs, outputs *[]WorkflowStepOutput) error {\n\treturn api.SaveWorkflowStepConfigurationContext(context.Background(), workflowStepEditID, inputs, outputs)\n}\n\n// SaveWorkflowStepConfigurationContext saves the configuration of a workflow step with a custom context.\n// Slack API docs: https://api.slack.com/methods/workflows.updateStep\nfunc (api *Client) SaveWorkflowStepConfigurationContext(ctx context.Context, workflowStepEditID string, inputs *WorkflowStepInputs, outputs *[]WorkflowStepOutput) error {\n\twscr := WorkflowStepCompleteResponse{\n\t\tWorkflowStepEditID: workflowStepEditID,\n\t\tInputs:             inputs,\n\t\tOutputs:            outputs,\n\t}\n\n\tendpoint := api.endpoint + \"workflows.updateStep\"\n\tjsonData, err := json.Marshal(wscr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := postJSON(ctx, api.httpclient, endpoint, api.token, jsonData, response, api); err != nil {\n\t\treturn err\n\t}\n\n\tif !response.Ok {\n\t\treturn response.Err()\n\t}\n\n\treturn nil\n}\n\nfunc GetInitialOptionFromWorkflowStepInput(selection *SelectBlockElement, inputs *WorkflowStepInputs, options []*OptionBlockObject) (*OptionBlockObject, bool) {\n\tif len(*inputs) == 0 {\n\t\treturn &OptionBlockObject{}, false\n\t}\n\tif len(options) == 0 {\n\t\treturn &OptionBlockObject{}, false\n\t}\n\n\tif val, ok := (*inputs)[selection.ActionID]; ok {\n\t\tif val.SkipVariableReplacement {\n\t\t\treturn &OptionBlockObject{}, false\n\t\t}\n\n\t\tfor _, option := range options {\n\t\t\tif option.Value == val.Value {\n\t\t\t\treturn option, true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &OptionBlockObject{}, false\n}\n"
        },
        {
          "name": "workflow_step_execute.go",
          "type": "blob",
          "size": 2.12890625,
          "content": "package slack\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n)\n\ntype (\n\tWorkflowStepCompletedRequest struct {\n\t\tWorkflowStepExecuteID string            `json:\"workflow_step_execute_id\"`\n\t\tOutputs               map[string]string `json:\"outputs\"`\n\t}\n\n\tWorkflowStepFailedRequest struct {\n\t\tWorkflowStepExecuteID string `json:\"workflow_step_execute_id\"`\n\t\tError                 struct {\n\t\t\tMessage string `json:\"message\"`\n\t\t} `json:\"error\"`\n\t}\n)\n\ntype WorkflowStepCompletedRequestOption func(opt *WorkflowStepCompletedRequest) error\n\nfunc WorkflowStepCompletedRequestOptionOutput(outputs map[string]string) WorkflowStepCompletedRequestOption {\n\treturn func(opt *WorkflowStepCompletedRequest) error {\n\t\tif len(outputs) > 0 {\n\t\t\topt.Outputs = outputs\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WorkflowStepCompleted indicates step is completed\nfunc (api *Client) WorkflowStepCompleted(workflowStepExecuteID string, options ...WorkflowStepCompletedRequestOption) error {\n\t// More information: https://api.slack.com/methods/workflows.stepCompleted\n\tr := &WorkflowStepCompletedRequest{\n\t\tWorkflowStepExecuteID: workflowStepExecuteID,\n\t}\n\tfor _, option := range options {\n\t\toption(r)\n\t}\n\n\tendpoint := api.endpoint + \"workflows.stepCompleted\"\n\tjsonData, err := json.Marshal(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := postJSON(context.Background(), api.httpclient, endpoint, api.token, jsonData, response, api); err != nil {\n\t\treturn err\n\t}\n\n\tif !response.Ok {\n\t\treturn response.Err()\n\t}\n\n\treturn nil\n}\n\n// WorkflowStepFailed indicates step is failed\nfunc (api *Client) WorkflowStepFailed(workflowStepExecuteID string, errorMessage string) error {\n\t// More information: https://api.slack.com/methods/workflows.stepFailed\n\tr := WorkflowStepFailedRequest{\n\t\tWorkflowStepExecuteID: workflowStepExecuteID,\n\t}\n\tr.Error.Message = errorMessage\n\n\tendpoint := api.endpoint + \"workflows.stepFailed\"\n\tjsonData, err := json.Marshal(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponse := &SlackResponse{}\n\tif err := postJSON(context.Background(), api.httpclient, endpoint, api.token, jsonData, response, api); err != nil {\n\t\treturn err\n\t}\n\n\tif !response.Ok {\n\t\treturn response.Err()\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "workflow_step_execute_test.go",
          "type": "blob",
          "size": 0.88671875,
          "content": "package slack\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc workflowStepHandler(rw http.ResponseWriter, r *http.Request) {\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse, _ := json.Marshal(SlackResponse{\n\t\tOk: true,\n\t})\n\trw.Write(response)\n}\n\nfunc TestWorkflowStepCompleted(t *testing.T) {\n\thttp.HandleFunc(\"/workflows.stepCompleted\", workflowStepHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tif err := api.WorkflowStepCompleted(\"executeID\"); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n\nfunc TestWorkflowStepFailed(t *testing.T) {\n\thttp.HandleFunc(\"/workflows.stepFailed\", workflowStepHandler)\n\tonce.Do(startServer)\n\tapi := New(\"testing-token\", OptionAPIURL(\"http://\"+serverAddr+\"/\"))\n\n\tif err := api.WorkflowStepFailed(\"executeID\", \"error message\"); err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "workflow_step_test.go",
          "type": "blob",
          "size": 4.7646484375,
          "content": "package slack\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nconst (\n\tIDExampleSelectInput = \"ae9642ae-a9ef-4394-904b-a5c7a83bf4a6\"\n\tIDSelectOptionBlock  = \"832bf7af-22ea-4acb-82e3-a0cc3722052b\"\n)\n\nfunc TestNewConfigurationModalRequest(t *testing.T) {\n\tblocks := configModalBlocks()\n\tprivateMetaData := \"An optional string that will be sent to your app in view_submission and block_actions events. Max length of 3000 characters.\"\n\texternalID := \"c4baf441-fbc1-4131-b349-7c8df0ae7df6\"\n\n\tresult := NewConfigurationModalRequest(blocks, privateMetaData, externalID)\n\n\tif result.ModalViewRequest.Title != nil {\n\t\tt.Fail()\n\t}\n\tif result.PrivateMetadata != privateMetaData {\n\t\tt.Fail()\n\t}\n\tif result.ExternalID != externalID {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestGetInitialOptionFromWorkflowStepInput(t *testing.T) {\n\toptions, testOption := createOptionBlockObjects()\n\tselection := createSelection(options)\n\n\tscenarios := []struct {\n\t\toptions        []*OptionBlockObject\n\t\tinputs         *WorkflowStepInputs\n\t\texpectedResult *OptionBlockObject\n\t\texpectedFlag   bool\n\t}{\n\t\t{\n\t\t\toptions:        options,\n\t\t\tinputs:         createWorkflowStepInputs1(),\n\t\t\texpectedResult: &OptionBlockObject{},\n\t\t\texpectedFlag:   false,\n\t\t},\n\t\t{\n\t\t\toptions:        []*OptionBlockObject{},\n\t\t\tinputs:         createWorkflowStepInputs4(testOption.Value),\n\t\t\texpectedResult: &OptionBlockObject{},\n\t\t\texpectedFlag:   false,\n\t\t},\n\t\t{\n\t\t\toptions:        options,\n\t\t\tinputs:         createWorkflowStepInputs2(),\n\t\t\texpectedResult: &OptionBlockObject{},\n\t\t\texpectedFlag:   false,\n\t\t},\n\t\t{\n\t\t\toptions:        options,\n\t\t\tinputs:         createWorkflowStepInputs3(),\n\t\t\texpectedResult: &OptionBlockObject{},\n\t\t\texpectedFlag:   false,\n\t\t},\n\t\t{\n\t\t\toptions:        options,\n\t\t\tinputs:         createWorkflowStepInputs4(testOption.Value),\n\t\t\texpectedResult: testOption,\n\t\t\texpectedFlag:   true,\n\t\t},\n\t}\n\n\tfor _, scenario := range scenarios {\n\t\tresult, ok := GetInitialOptionFromWorkflowStepInput(selection, scenario.inputs, scenario.options)\n\t\tif ok != scenario.expectedFlag {\n\t\t\tt.Fail()\n\t\t}\n\n\t\tif !cmp.Equal(result, scenario.expectedResult) {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc createOptionBlockObjects() ([]*OptionBlockObject, *OptionBlockObject) {\n\tvar options []*OptionBlockObject\n\toptions = append(\n\t\toptions,\n\t\tNewOptionBlockObject(\"one\", NewTextBlockObject(\"plain_text\", \"One\", false, false), nil),\n\t)\n\n\toption2 := NewOptionBlockObject(\"two\", NewTextBlockObject(\"plain_text\", \"Two\", false, false), nil)\n\toptions = append(\n\t\toptions,\n\t\toption2,\n\t)\n\n\toptions = append(\n\t\toptions,\n\t\tNewOptionBlockObject(\"three\", NewTextBlockObject(\"plain_text\", \"Three\", false, false), nil),\n\t)\n\n\treturn options, option2\n}\n\nfunc createSelection(options []*OptionBlockObject) *SelectBlockElement {\n\treturn NewOptionsSelectBlockElement(\n\t\t\"static_select\",\n\t\tNewTextBlockObject(\"plain_text\", \"your choice\", false, false),\n\t\tIDExampleSelectInput,\n\t\toptions...,\n\t)\n}\n\nfunc configModalBlocks() Blocks {\n\theaderText := NewTextBlockObject(\"mrkdwn\", \"Hello World!\\nThis is your workflow step app configuration view\", false, false)\n\theaderSection := NewSectionBlock(headerText, nil, nil)\n\n\toptions, _ := createOptionBlockObjects()\n\n\tselection := createSelection(options)\n\n\tinputBlock := NewInputBlock(\n\t\tIDSelectOptionBlock,\n\t\tNewTextBlockObject(\"plain_text\", \"Select an option\", false, false),\n\t\tNewTextBlockObject(\"plain_text\", \"Hint\", false, false),\n\t\tselection,\n\t)\n\n\tblocks := Blocks{\n\t\tBlockSet: []Block{\n\t\t\theaderSection,\n\t\t\tinputBlock,\n\t\t},\n\t}\n\n\treturn blocks\n}\n\nfunc createWorkflowStepInputs1() *WorkflowStepInputs {\n\treturn &WorkflowStepInputs{}\n}\n\nfunc createWorkflowStepInputs2() *WorkflowStepInputs {\n\treturn &WorkflowStepInputs{\n\t\t\"test\": WorkflowStepInputElement{\n\t\t\tValue:                   \"random-string\",\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t\t\"123-test\": WorkflowStepInputElement{\n\t\t\tValue:                   \"another-string\",\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t}\n}\n\nfunc createWorkflowStepInputs3() *WorkflowStepInputs {\n\treturn &WorkflowStepInputs{\n\t\t\"test\": WorkflowStepInputElement{\n\t\t\tValue:                   \"random-string\",\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t\t\"123-test\": WorkflowStepInputElement{\n\t\t\tValue:                   \"another-string\",\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t\tIDExampleSelectInput: WorkflowStepInputElement{\n\t\t\tValue:                   \"lorem-ipsum\",\n\t\t\tSkipVariableReplacement: true,\n\t\t},\n\t}\n}\n\nfunc createWorkflowStepInputs4(optionValue string) *WorkflowStepInputs {\n\treturn &WorkflowStepInputs{\n\t\t\"test\": WorkflowStepInputElement{\n\t\t\tValue:                   \"random-string\",\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t\t\"123-test\": WorkflowStepInputElement{\n\t\t\tValue:                   \"another-string\",\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t\tIDExampleSelectInput: WorkflowStepInputElement{\n\t\t\tValue:                   optionValue,\n\t\t\tSkipVariableReplacement: false,\n\t\t},\n\t}\n}\n"
        }
      ]
    }
  ]
}