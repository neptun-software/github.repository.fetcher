{
  "metadata": {
    "timestamp": 1736567292328,
    "page": 891,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "johnfercher/maroto",
      "stars": 2296,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.30078125,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# JetBrains\n.idea\n\n.DS_Store\n*.tmp\n\ngoreportcard\n\n# Ignore\nignore.sh\n\n.vscode\n\nnode_modules/*\n\nreport-test-demo.txt"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.349609375,
          "content": "run:\n  timeout: 5m\n  modules-download-mode: readonly\n  skip-files:\n    - cmd/*\n    - mocks/*\n    - internal/fpdf/*\n    - internal/fixture\n\nlinters-settings:\n  lll:\n    line-length: 140\n  gocritic:\n    enabled-checks:\n      - appendAssign\n      - argOrder\n      - assignOp\n      - badCall\n      - badCond\n      - boolExprSimplify\n      - captLocal\n      - caseOrder\n      - codegenComment\n      - commentedOutCode\n      - commentedOutImport\n      - commentFormatting\n      - defaultCaseOrder\n      - deprecatedComment\n      - dupArg\n      - dupBranchBody\n      - dupCase\n      - dupImport\n      - dupSubExpr\n      - elseif\n      - exitAfterDefer\n      - flagDeref\n      - flagName\n      - ifElseChain\n      - mapKey\n      - newDeref\n      - offBy1\n      - regexpMust\n      - singleCaseSwitch\n      - sloppyLen\n      - stringXbytes\n      - switchTrue\n      - typeSwitchVar\n      - underef\n      - unlambda\n      - unslice\n      - valSwap\n      - wrapperFunc\n\nlinters:\n  disable-all: true\n  enable:\n    - bodyclose\n    - dogsled\n    - dupl\n    - errcheck\n    - gochecknoinits\n    - goconst\n    - gocritic\n    - gofmt\n    - gofumpt\n    - goimports\n    - goprintffuncname\n    - govet\n    - gosimple\n    - ineffassign\n    - lll\n    - misspell\n    - nakedret\n    - rowserrcheck\n    - staticcheck\n    - stylecheck\n    - typecheck\n    - unconvert\n    - unparam\n    - unused\n    - whitespace\n"
        },
        {
          "name": ".maroto.yml",
          "type": "blob",
          "size": 0.0244140625,
          "content": "test_path: \"test/maroto/\""
        },
        {
          "name": ".mockery.yaml",
          "type": "blob",
          "size": 0.19921875,
          "content": "all: True\ndir: \"mocks/\"\noutpkg: \"mocks\"\nfilename: \"{{.InterfaceName}}.go\"\nmockname: \"{{.InterfaceName}}\"\nwith-expecter: True\npackages:\n  github.com/johnfercher/maroto/v2:\n    config:\n      recursive: True"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.1376953125,
          "content": "## Code of Conduct\n\nThe maroto project follows the [CNCF Code of Conduct](https://github.com/cncf/foundation/blob/master/code-of-conduct.md)."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "MIT License\n\nCopyright (c) 2019 Johnathan Fercher da Rosa\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.384765625,
          "content": "GO_FILES = $(shell find . '(' -path '*/.*' -o -path './vendor' ')' -prune -o -name '*.go' -print | cut -b3-)\nGO_PATHS =  $(shell go list -f '{{ .Dir }}' ./... | grep -E -v 'docs|cmd|mocks')\nGO_EXAMPLES =  $(shell go list -f '{{ .Dir }}' ./docs/assets/examples/...)\n\n.PHONY: dod\ndod: build test fmt lint\n\n.PHONY: build\nbuild:\n\tgo build $(GO_PATHS)\n\n.PHONY: test\ntest:\n\tgo test $(GO_PATHS)\n\tgo test $(GO_EXAMPLES)\n\n.PHONY: fmt\nfmt:\n\tgofmt -s -w ${GO_FILES}\n\tgofumpt -l -w ${GO_FILES}\n\tgoimports -w ${GO_PATHS}\n\n.PHONY: lint\nlint:\n\tgolangci-lint run --config=.golangci.yml ./...\n\tmake mock-lint\n\n.PHONY: mock-lint\nmock-lint:\n\tbash shell/mock-check.sh\n\n.PHONY: install\ninstall:\n\tbash shell/install.sh\n\n.PHONY: docs\ndocs:\n\tdocsify serve docs/\n\n.PHONY: godoc\ngodoc:\n\tgodoc -http=127.0.0.1:6060\n\n\n.PHONY: mocks\nmocks:\n\trm -R mocks || true\n\tmockery\n\tmake fmt\n\n.PHONY: examples\nexamples:\n\tgo run docs/assets/examples/addpage/v2/main.go\n\tgo run docs/assets/examples/autorow/v2/main.go\n\tgo run docs/assets/examples/background/v2/main.go\n\tgo run docs/assets/examples/barcodegrid/v2/main.go\n\tgo run docs/assets/examples/billing/v2/main.go\n\tgo run docs/assets/examples/cellstyle/v2/main.go\n\tgo run docs/assets/examples/compression/v2/main.go\n\tgo run docs/assets/examples/customdimensions/v2/main.go\n\tgo run docs/assets/examples/customfont/v2/main.go\n\tgo run docs/assets/examples/custompage/v2/main.go\n\tgo run docs/assets/examples/datamatrixgrid/v2/main.go\n\tgo run docs/assets/examples/disablepagebreak/v2/main.go\n\tgo run docs/assets/examples/footer/v2/main.go\n\tgo run docs/assets/examples/header/v2/main.go\n\tgo run docs/assets/examples/imagegrid/v2/main.go\n\tgo run docs/assets/examples/line/v2/main.go\n\tgo run docs/assets/examples/list/v2/main.go\n\tgo run docs/assets/examples/lowmemory/v2/main.go\n\tgo run docs/assets/examples/margins/v2/main.go\n\tgo run docs/assets/examples/maxgridsum/v2/main.go\n\tgo run docs/assets/examples/mergepdf/v2/main.go\n\tgo run docs/assets/examples/metadatas/v2/main.go\n\tgo run docs/assets/examples/orientation/v2/main.go\n\tgo run docs/assets/examples/pagenumber/v2/main.go\n\tgo run docs/assets/examples/parallelism/v2/main.go\n\tgo run docs/assets/examples/protection/v2/main.go\n\tgo run docs/assets/examples/qrgrid/v2/main.go\n\tgo run docs/assets/examples/signaturegrid/v2/main.go\n\tgo run docs/assets/examples/simplest/v2/main.go\n\tgo run docs/assets/examples/textgrid/v2/main.go\n\tgo test docs/assets/examples/unittests/v2/main_test.go\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.90625,
          "content": "# Maroto V2\n\n[![GoDoc](https://godoc.org/github.com/johnfercher/maroto?status.svg)](https://pkg.go.dev/github.com/johnfercher/maroto/v2)\n[![Go Report Card](https://goreportcard.com/badge/github.com/johnfercher/maroto)](https://goreportcard.com/report/github.com/johnfercher/maroto)\n[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge.svg)](https://github.com/avelino/awesome-go#template-engines)  \n[![CI](https://github.com/johnfercher/maroto/actions/workflows/goci.yml/badge.svg)](https://github.com/johnfercher/maroto/actions/workflows/goci.yml)\n[![Lint](https://github.com/johnfercher/maroto/actions/workflows/golangci-lint.yml/badge.svg)](https://github.com/johnfercher/maroto/actions/workflows/golangci-lint.yml)\n[![Codecov](https://img.shields.io/codecov/c/github/johnfercher/maroto)](https://codecov.io/gh/johnfercher/maroto)\n[![Visits Badge](https://badges.pufler.dev/visits/johnfercher/maroto)](https://badges.pufler.dev)\n[![Stars Badge](https://img.shields.io/github/stars/johnfercher/maroto.svg?style=social&label=Stars)](https://github.com/johnfercher/maroto/stargazers)\n\n\nA Maroto way to create PDFs. Maroto is inspired in Bootstrap and uses [Gofpdf](https://github.com/jung-kurt/gofpdf). Fast and simple.\n\n![sirmaroto](docs/assets/images/logosmall.png)\n> Maroto definition: Brazilian expression, means an astute/clever/intelligent person. \n> [Art by **@marinabankr**](https://www.instagram.com/marinabankr/)\n\nYou can write your PDFs like you are creating a site using Bootstrap. A Row may have many Cols, and a Col may have many components. \nBesides that, pages will be added when content may extrapolate the useful area. You can define a header which will be added\nalways when a new page appear, in this case, a header may have many rows, lines or tablelist. \n\n#### Maroto `v2.2.2` is here! Try out:\n\n* Installation with`go get`:\n\n```bash\ngo get github.com/johnfercher/maroto/v2@v2.2.2\n```\n\n* You can see the full `v2` documentation [here](https://maroto.io/).\n* The `v1` still exists in [this branch](https://github.com/johnfercher/maroto/tree/v1), and you can see the doc [here](https://maroto.io/#/v1/README?id=deprecated).\n\n![result](docs/assets/images/result.png)\n\n## Contributing\n\n| Command         | Description                                       | Dependencies                                                  |\n|-----------------|---------------------------------------------------|---------------------------------------------------------------|\n| `make build`    | Build project                                     | `go`                                                          |\n| `make test`     | Run unit tests                                    | `go`                                                          |\n| `make fmt`      | Format files                                      | `gofmt`, `gofumpt` and `goimports`                            |\n| `make lint`     | Check files                                       | `golangci-lint`                                               |\n| `make dod`      | (Definition of Done) Format files and check files | Same as `make build`, `make test`, `make fmt` and `make lint` | \n| `make install`  | Install all dependencies                          | `go`, `curl` and `git`                                        |\n| `make examples` | Run all examples                                  | `go`                                                          |\n| `make mocks`    | Generate mocks                                    | `go` and `mockery`                                            |\n| `make docs`     | Run docsify docs server local                     | `docsify`                                                     |\n| `make godoc`    | Run godoc server local                            | `godoc`                                                       |\n\n## Stargazers over time\n[![Stargazers over time](https://starchart.cc/johnfercher/maroto.svg?variant=adaptive)](https://starchart.cc/johnfercher/maroto)\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.1494140625,
          "content": "coverage:\n  precision: 2\n  round: up\n  range: \"70...100\"\n\nignore:\n  - \".idea\"\n  - \"docs\"\n  - \"cmd\"\n  - \"mocks\"\n  - \"internal/fpdf\"\n  - \"internal/fixture\""
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 3.20703125,
          "content": "package maroto_test\n\nimport (\n\t\"log\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/components/text\"\n\n\t\"github.com/johnfercher/maroto/v2\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/code\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/page\"\n\t\"github.com/johnfercher/maroto/v2/pkg/config\"\n)\n\n// ExampleNew demonstrates how to create a maroto instance.\nfunc ExampleNew() {\n\t// optional\n\tb := config.NewBuilder()\n\tcfg := b.Build()\n\n\tm := maroto.New(cfg) // cfg is an optional\n\n\t// Do things and generate\n\t_, _ = m.Generate()\n}\n\n// ExampleNewMetricsDecorator demonstrates how to create a maroto metrics decorator instance.\nfunc ExampleNewMetricsDecorator() {\n\t// optional\n\tb := config.NewBuilder()\n\tcfg := b.Build()\n\n\tmrt := maroto.New(cfg)               // cfg is an optional\n\tm := maroto.NewMetricsDecorator(mrt) // decorator of maroto\n\n\t// Do things and generate\n\t_, _ = m.Generate()\n}\n\n// ExampleMaroto_AddPages demonstrates how to add a new page in maroto.\nfunc ExampleMaroto_AddPages() {\n\tm := maroto.New()\n\n\tp := page.New()\n\tp.Add(code.NewBarRow(10, \"barcode\"))\n\n\tm.AddPages(p)\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_AddRows demonstrates how to add new rows in maroto.\nfunc ExampleMaroto_AddRows() {\n\tm := maroto.New()\n\n\tm.AddRows(\n\t\tcode.NewBarRow(12, \"barcode\"),\n\t\ttext.NewRow(12, \"text\"),\n\t)\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_AddRow demonstrates how to add a new row in maroto.\nfunc ExampleMaroto_AddRow() {\n\tm := maroto.New()\n\n\tm.AddRow(10, text.NewCol(12, \"text\"))\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_FitlnCurrentPage demonstrate how to check if the new line fits on the current page\nfunc ExampleMaroto_FitlnCurrentPage() {\n\tm := maroto.New()\n\n\tm.FitlnCurrentPage(12)\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_FitlnCurrentPage demonstrate how to check if the new line fits on the current page\nfunc ExampleMaroto_GetCurrentConfig() {\n\tm := maroto.New()\n\n\tm.GetCurrentConfig()\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_RegisterHeader demonstrates how to register a header to me added in every new page.\n// An error is returned if the area occupied by the header is greater than the page area.\nfunc ExampleMaroto_RegisterHeader() {\n\tm := maroto.New()\n\n\terr := m.RegisterHeader(\n\t\tcode.NewBarRow(12, \"barcode\"),\n\t\ttext.NewRow(12, \"text\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_RegisterFooter demonstrates how to register a footer to me added in every new page.\n// An error is returned if the area occupied by the footer is greater than the page area.\nfunc ExampleMaroto_RegisterFooter() {\n\tm := maroto.New()\n\n\terr := m.RegisterFooter(\n\t\tcode.NewBarRow(12, \"barcode\"),\n\t\ttext.NewRow(12, \"text\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Do things and generate\n}\n\n// ExampleMaroto_Generate demonstrates how to generate a file.\nfunc ExampleMaroto_Generate() {\n\tm := maroto.New()\n\n\t// Add rows, pages and etc.\n\n\tdoc, err := m.Generate()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// You can retrieve as Base64, Save file, Merge with another file or GetReport.\n\t_ = doc.GetBytes()\n}\n\n// ExampleMarotoGetStruct demonstrates how to get maroto component tree\nfunc ExampleMaroto_GetStructure() {\n\tm := maroto.New()\n\n\tm.AddRow(40, text.NewCol(12, \"text\"))\n\n\tm.GetStructure()\n\n\t// Do things and generate\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.8154296875,
          "content": "module github.com/johnfercher/maroto/v2\n\ngo 1.21.1\n\nrequire (\n\tgithub.com/boombuler/barcode v1.0.1\n\tgithub.com/f-amaral/go-async v0.3.0\n\tgithub.com/google/uuid v1.5.0\n\tgithub.com/johnfercher/go-tree v1.0.5\n\tgithub.com/jung-kurt/gofpdf v1.16.2\n\tgithub.com/pdfcpu/pdfcpu v0.6.0\n\tgithub.com/stretchr/testify v1.8.4\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/hhrutter/lzw v1.0.0 // indirect\n\tgithub.com/hhrutter/tiff v1.0.1 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n\tgithub.com/stretchr/objx v0.5.1 // indirect\n\tgolang.org/x/image v0.18.0 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.8310546875,
          "content": "github.com/boombuler/barcode v1.0.0/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/boombuler/barcode v1.0.1 h1:NDBbPmhS+EqABEs5Kg3n/5ZNjy73Pz7SIV+KCeqyXcs=\ngithub.com/boombuler/barcode v1.0.1/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/f-amaral/go-async v0.3.0 h1:h4kLsX7aKfdWaHvV0lf+/EE3OIeCzyeDYJDb/vDZUyg=\ngithub.com/f-amaral/go-async v0.3.0/go.mod h1:Hz5Qr6DAWpbTTUjytnrg1WIsDgS7NtOei5y8SipYS7U=\ngithub.com/google/uuid v1.5.0 h1:1p67kYwdtXjb0gL0BPiP1Av9wiZPo5A8z2cWkTZ+eyU=\ngithub.com/google/uuid v1.5.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/hhrutter/lzw v1.0.0 h1:laL89Llp86W3rRs83LvKbwYRx6INE8gDn0XNb1oXtm0=\ngithub.com/hhrutter/lzw v1.0.0/go.mod h1:2HC6DJSn/n6iAZfgM3Pg+cP1KxeWc3ezG8bBqW5+WEo=\ngithub.com/hhrutter/tiff v1.0.1 h1:MIus8caHU5U6823gx7C6jrfoEvfSTGtEFRiM8/LOzC0=\ngithub.com/hhrutter/tiff v1.0.1/go.mod h1:zU/dNgDm0cMIa8y8YwcYBeuEEveI4B0owqHyiPpJPHc=\ngithub.com/johnfercher/go-tree v1.0.5 h1:zpgVhJsChavzhKdxhQiCJJzcSY3VCT9oal2JoA2ZevY=\ngithub.com/johnfercher/go-tree v1.0.5/go.mod h1:DUO6QkXIFh1K7jeGBIkLCZaeUgnkdQAsB64FDSoHswg=\ngithub.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/jung-kurt/gofpdf v1.16.2 h1:jgbatWHfRlPYiK85qgevsZTHviWXKwB1TTiKdz5PtRc=\ngithub.com/jung-kurt/gofpdf v1.16.2/go.mod h1:1hl7y57EsiPAkLbOwzpzqgx1A30nQCk/YmFV8S2vmK0=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/pdfcpu/pdfcpu v0.6.0 h1:z4kARP5bcWa39TTYMcN/kjBnm7MvhTWjXgeYmkdAGMI=\ngithub.com/pdfcpu/pdfcpu v0.6.0/go.mod h1:kmpD0rk8YnZj0l3qSeGBlAB+XszHUgNv//ORH/E7EYo=\ngithub.com/phpdave11/gofpdi v1.0.7/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/ruudk/golang-pdf417 v0.0.0-20181029194003-1af4ab5afa58/go.mod h1:6lfFZQK844Gfx8o5WFuvpxWRwnSoipWe/p622j1v06w=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.1 h1:4VhoImhV/Bm0ToFkXFi8hXNXwpDRZ/ynw3amt82mzq0=\ngithub.com/stretchr/objx v0.5.1/go.mod h1:/iHQpkQwBD6DLUmQ4pE+s1TXdob1mORJ4/UFdrifcy0=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.2/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngolang.org/x/image v0.0.0-20190910094157-69e4b8554b2a/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.18.0 h1:jGzIakQa/ZXI1I0Fxvaa9W7yP25TqT6cHIHn+6CqvSQ=\ngolang.org/x/image v0.18.0/go.mod h1:4yyo5vMFQjVjUcVk4jEQcU9MGy/rulF5WvUILseCM2E=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "maroto.go",
          "type": "blob",
          "size": 9.794921875,
          "content": "package maroto\n\nimport (\n\t\"errors\"\n\n\t\"github.com/f-amaral/go-async/pool\"\n\t\"github.com/johnfercher/maroto/v2/pkg/consts/generation\"\n\n\t\"github.com/johnfercher/maroto/v2/internal/cache\"\n\n\t\"github.com/johnfercher/maroto/v2/internal/providers/gofpdf\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/merge\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/core/entity\"\n\n\t\"github.com/johnfercher/go-tree/node\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/components/col\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/page\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/row\"\n\t\"github.com/johnfercher/maroto/v2/pkg/config\"\n\t\"github.com/johnfercher/maroto/v2/pkg/core\"\n)\n\ntype Maroto struct {\n\tconfig   *entity.Config\n\tprovider core.Provider\n\tcache    cache.Cache\n\n\t// Building\n\tcell          entity.Cell\n\tpages         []core.Page\n\trows          []core.Row\n\theader        []core.Row\n\tfooter        []core.Row\n\theaderHeight  float64\n\tfooterHeight  float64\n\tcurrentHeight float64\n}\n\n// GetCurrentConfig is responsible for returning the current settings from the file\nfunc (m *Maroto) GetCurrentConfig() *entity.Config {\n\treturn m.config\n}\n\n// New is responsible for create a new instance of core.Maroto.\n// It's optional to provide an *entity.Config with customizations\n// those customization are created by using the config.Builder.\nfunc New(cfgs ...*entity.Config) core.Maroto {\n\tcache := cache.New()\n\tcfg := getConfig(cfgs...)\n\tprovider := getProvider(cache, cfg)\n\n\tm := &Maroto{\n\t\tprovider: provider,\n\t\tcell: entity.NewRootCell(cfg.Dimensions.Width, cfg.Dimensions.Height, entity.Margins{\n\t\t\tLeft:   cfg.Margins.Left,\n\t\t\tTop:    cfg.Margins.Top,\n\t\t\tRight:  cfg.Margins.Right,\n\t\t\tBottom: cfg.Margins.Bottom,\n\t\t}),\n\t\tcache:  cache,\n\t\tconfig: cfg,\n\t}\n\n\treturn m\n}\n\n// AddPages is responsible for add pages directly in the document.\n// By adding a page directly, the current cursor will reset and the\n// new page will appear as the next. If the page provided have\n// more rows than the maximum useful area of a page, maroto will split\n// that page in more than one.\nfunc (m *Maroto) AddPages(pages ...core.Page) {\n\tfor _, page := range pages {\n\t\tif m.currentHeight != m.headerHeight {\n\t\t\tm.fillPageToAddNew()\n\t\t\tm.addHeader()\n\t\t}\n\t\tm.addRows(page.GetRows()...)\n\t}\n}\n\n// AddRows is responsible for add rows in the current document.\n// By adding a row, if the row will extrapolate the useful area of a page,\n// maroto will automatically add a new page. Maroto use the information of\n// PageSize, PageMargin, FooterSize and HeaderSize to calculate the useful\n// area of a page.\nfunc (m *Maroto) AddRows(rows ...core.Row) {\n\tm.addRows(rows...)\n}\n\n// AddRow is responsible for add one row in the current document.\n// By adding a row, if the row will extrapolate the useful area of a page,\n// maroto will automatically add a new page. Maroto use the information of\n// PageSize, PageMargin, FooterSize and HeaderSize to calculate the useful\n// area of a page.\nfunc (m *Maroto) AddRow(rowHeight float64, cols ...core.Col) core.Row {\n\tr := row.New(rowHeight).Add(cols...)\n\tm.addRow(r)\n\treturn r\n}\n\n// AddAutoRow is responsible for adding a line with automatic height to the\n// current document.\n// The row height will be calculated based on its content.\nfunc (m *Maroto) AddAutoRow(cols ...core.Col) core.Row {\n\tr := row.New().Add(cols...)\n\tm.addRow(r)\n\treturn r\n}\n\n// FitlnCurrentPage is responsible to validating whether a line fits on\n// the current page.\nfunc (m *Maroto) FitlnCurrentPage(heightNewLine float64) bool {\n\tcontentSize := m.getRowsHeight(m.rows...) + m.footerHeight + m.headerHeight\n\treturn contentSize+heightNewLine < m.config.Dimensions.Height\n}\n\n// RegisterHeader is responsible to define a set of rows as a header\n// of the document. The header will appear in every new page of the document.\n// The header cannot occupy an area greater than the useful area of the page,\n// it this case the method will return an error.\nfunc (m *Maroto) RegisterHeader(rows ...core.Row) error {\n\theight := m.getRowsHeight(rows...)\n\tif height+m.footerHeight > m.config.Dimensions.Height {\n\t\treturn errors.New(\"header height is greater than page useful area\")\n\t}\n\n\tm.headerHeight = height\n\tm.header = rows\n\n\tfor _, headerRow := range rows {\n\t\tm.addRow(headerRow)\n\t}\n\n\treturn nil\n}\n\n// RegisterFooter is responsible to define a set of rows as a footer\n// of the document. The footer will appear in every new page of the document.\n// The footer cannot occupy an area greater than the useful area of the page,\n// it this case the method will return an error.\nfunc (m *Maroto) RegisterFooter(rows ...core.Row) error {\n\theight := m.getRowsHeight(rows...)\n\tif height > m.config.Dimensions.Height {\n\t\treturn errors.New(\"footer height is greater than page useful area\")\n\t}\n\n\tm.footerHeight = height\n\tm.footer = rows\n\treturn nil\n}\n\n// Generate is responsible to compute the component tree created by\n// the usage of all other Maroto methods, and generate the PDF document.\nfunc (m *Maroto) Generate() (core.Document, error) {\n\tm.fillPageToAddNew()\n\tm.setConfig()\n\n\tif m.config.GenerationMode == generation.Concurrent {\n\t\treturn m.generateConcurrently()\n\t}\n\n\tif m.config.GenerationMode == generation.SequentialLowMemory {\n\t\treturn m.generateLowMemory()\n\t}\n\n\treturn m.generate()\n}\n\n// GetStructure is responsible for return the component tree, this is useful\n// on unit tests cases.\nfunc (m *Maroto) GetStructure() *node.Node[core.Structure] {\n\tm.fillPageToAddNew()\n\n\tstr := core.Structure{\n\t\tType:    \"maroto\",\n\t\tDetails: m.config.ToMap(),\n\t}\n\tnode := node.New(str)\n\n\tfor _, p := range m.pages {\n\t\tinner := p.GetStructure()\n\t\tnode.AddNext(inner)\n\t}\n\n\treturn node\n}\n\nfunc (m *Maroto) addRows(rows ...core.Row) {\n\tfor _, row := range rows {\n\t\tm.addRow(row)\n\t}\n}\n\nfunc (m *Maroto) addRow(r core.Row) {\n\tif len(r.GetColumns()) == 0 {\n\t\tr.Add(col.New())\n\t}\n\n\tmaxHeight := m.cell.Height\n\n\tr.SetConfig(m.config)\n\trowHeight := r.GetHeight(m.provider, &m.cell)\n\tsumHeight := rowHeight + m.currentHeight + m.footerHeight\n\n\t// Row smaller than the remain space on page\n\tif sumHeight < maxHeight {\n\t\tm.currentHeight += rowHeight\n\t\tm.rows = append(m.rows, r)\n\t\treturn\n\t}\n\n\t// As row will extrapolate page, we will add empty space\n\t// on the page to force a new page\n\tm.fillPageToAddNew()\n\n\tm.addHeader()\n\n\t// AddRows row on the new page\n\tm.currentHeight += rowHeight\n\tm.rows = append(m.rows, r)\n}\n\nfunc (m *Maroto) addHeader() {\n\tfor _, headerRow := range m.header {\n\t\tm.currentHeight += headerRow.GetHeight(m.provider, &m.cell)\n\t\tm.rows = append(m.rows, headerRow)\n\t}\n}\n\nfunc (m *Maroto) fillPageToAddNew() {\n\tspace := m.cell.Height - m.currentHeight - m.footerHeight\n\n\tc := col.New(m.config.MaxGridSize)\n\tspaceRow := row.New(space)\n\tspaceRow.Add(c)\n\n\tm.rows = append(m.rows, spaceRow)\n\tm.rows = append(m.rows, m.footer...)\n\n\tvar p core.Page\n\tif m.config.PageNumber != nil {\n\t\tp = page.New(*m.config.PageNumber)\n\t} else {\n\t\tp = page.New()\n\t}\n\n\tp.SetConfig(m.config)\n\tp.Add(m.rows...)\n\n\tm.pages = append(m.pages, p)\n\tm.rows = nil\n\tm.currentHeight = 0\n}\n\nfunc (m *Maroto) setConfig() {\n\tfor i, page := range m.pages {\n\t\tpage.SetConfig(m.config)\n\t\tpage.SetNumber(i+1, len(m.pages))\n\t}\n}\n\nfunc (m *Maroto) generate() (core.Document, error) {\n\tinnerCtx := m.cell.Copy()\n\n\tfor _, page := range m.pages {\n\t\tpage.Render(m.provider, innerCtx)\n\t}\n\n\tdocumentBytes, err := m.provider.GenerateBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn core.NewPDF(documentBytes, nil), nil\n}\n\nfunc (m *Maroto) generateConcurrently() (core.Document, error) {\n\tp := pool.NewPool[[]core.Page, []byte](m.config.ChunkWorkers, m.processPage,\n\t\tpool.WithSortingOutput[[]core.Page, []byte]())\n\tdefer p.Close()\n\tchunks := len(m.pages) / m.config.ChunkWorkers\n\tif chunks == 0 {\n\t\tchunks = 1\n\t}\n\tpageGroups := make([][]core.Page, 0)\n\tfor i := 0; i < len(m.pages); i += chunks {\n\t\tend := i + chunks\n\n\t\tif end > len(m.pages) {\n\t\t\tend = len(m.pages)\n\t\t}\n\n\t\tpageGroups = append(pageGroups, m.pages[i:end])\n\t}\n\n\tprocessed := p.Process(pageGroups)\n\tif processed.HasError {\n\t\treturn nil, errors.New(\"an error has occurred while trying to generate PDFs concurrently\")\n\t}\n\n\tpdfs := make([][]byte, len(processed.Results))\n\tfor i, result := range processed.Results {\n\t\tbytes := result.Output.([]byte)\n\t\tpdfs[i] = bytes\n\t}\n\n\tmergedBytes, err := merge.Bytes(pdfs...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn core.NewPDF(mergedBytes, nil), nil\n}\n\nfunc (m *Maroto) generateLowMemory() (core.Document, error) {\n\tchunks := len(m.pages) / m.config.ChunkWorkers\n\tif chunks == 0 {\n\t\tchunks = 1\n\t}\n\tpageGroups := make([][]core.Page, 0)\n\tfor i := 0; i < len(m.pages); i += chunks {\n\t\tend := i + chunks\n\n\t\tif end > len(m.pages) {\n\t\t\tend = len(m.pages)\n\t\t}\n\n\t\tpageGroups = append(pageGroups, m.pages[i:end])\n\t}\n\n\tvar pdfResults [][]byte\n\tfor _, pageGroup := range pageGroups {\n\t\tbytes, err := m.processPage(pageGroup)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"an error has occurred while trying to generate PDFs in low memory mode\")\n\t\t}\n\n\t\tpdfResults = append(pdfResults, bytes)\n\t}\n\n\tmergedBytes, err := merge.Bytes(pdfResults...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn core.NewPDF(mergedBytes, nil), nil\n}\n\nfunc (m *Maroto) processPage(pages []core.Page) ([]byte, error) {\n\tinnerCtx := m.cell.Copy()\n\n\tinnerProvider := getProvider(cache.NewMutexDecorator(cache.New()), m.config)\n\tfor _, page := range pages {\n\t\tpage.Render(innerProvider, innerCtx)\n\t}\n\n\treturn innerProvider.GenerateBytes()\n}\n\nfunc (m *Maroto) getRowsHeight(rows ...core.Row) float64 {\n\tvar height float64\n\tfor _, r := range rows {\n\t\tr.SetConfig(m.config)\n\t\theight += r.GetHeight(m.provider, &m.cell)\n\t}\n\n\treturn height\n}\n\nfunc getConfig(configs ...*entity.Config) *entity.Config {\n\tif len(configs) > 0 {\n\t\treturn configs[0]\n\t}\n\n\treturn config.NewBuilder().Build()\n}\n\nfunc getProvider(cache cache.Cache, cfg *entity.Config) core.Provider {\n\tdeps := gofpdf.NewBuilder().Build(cfg, cache)\n\tprovider := gofpdf.New(deps)\n\tprovider.SetMetadata(cfg.Metadata)\n\tprovider.SetCompression(cfg.Compression)\n\tprovider.SetProtection(cfg.Protection)\n\treturn provider\n}\n"
        },
        {
          "name": "maroto_test.go",
          "type": "blob",
          "size": 12.431640625,
          "content": "package maroto_test\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/components/code\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/text\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/components/col\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/page\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/row\"\n\t\"github.com/johnfercher/maroto/v2/pkg/config\"\n\t\"github.com/johnfercher/maroto/v2/pkg/core\"\n\t\"github.com/johnfercher/maroto/v2/pkg/test\"\n\n\t\"github.com/johnfercher/maroto/v2\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNew(t *testing.T) {\n\tt.Run(\"new default\", func(t *testing.T) {\n\t\t// Act\n\t\tsut := maroto.New()\n\n\t\t// Assert\n\t\tassert.NotNil(t, sut)\n\t\tassert.Equal(t, \"*maroto.Maroto\", fmt.Sprintf(\"%T\", sut))\n\t})\n\tt.Run(\"new with config\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tBuild()\n\n\t\t// Act\n\t\tsut := maroto.New(cfg)\n\n\t\t// Assert\n\t\tassert.NotNil(t, sut)\n\t\tassert.Equal(t, \"*maroto.Maroto\", fmt.Sprintf(\"%T\", sut))\n\t})\n\tt.Run(\"new with config an concurrent mode on\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithConcurrentMode(7).\n\t\t\tBuild()\n\n\t\t// Act\n\t\tsut := maroto.New(cfg)\n\n\t\t// Assert\n\t\tassert.NotNil(t, sut)\n\t\tassert.Equal(t, \"*maroto.Maroto\", fmt.Sprintf(\"%T\", sut))\n\t})\n\tt.Run(\"new with config an low memory mode on\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithSequentialLowMemoryMode(10).\n\t\t\tBuild()\n\n\t\t// Act\n\t\tsut := maroto.New(cfg)\n\n\t\t// Assert\n\t\tassert.NotNil(t, sut)\n\t\tassert.Equal(t, \"*maroto.Maroto\", fmt.Sprintf(\"%T\", sut))\n\t})\n}\n\nfunc TestMaroto_AddRow(t *testing.T) {\n\tt.Run(\"when col is not sent, should empty col is set\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\t\t// Act\n\t\tsut.AddRow(10)\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_row_4.json\")\n\t})\n\tt.Run(\"add one row\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRow(10, col.New(12))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_row_1.json\")\n\t})\n\tt.Run(\"add one row\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRow(10, col.New(12))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_row_1.json\")\n\t})\n\tt.Run(\"add two rows\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRow(10, col.New(12))\n\t\tsut.AddRow(10, col.New(12))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_row_2.json\")\n\t})\n\tt.Run(\"add rows until add new page\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_row_3.json\")\n\t})\n}\n\nfunc TestMaroto_AddRows(t *testing.T) {\n\tt.Run(\"when col is not sent, should empty col is set\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRows(row.New(15))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_rows_4.json\")\n\t})\n\tt.Run(\"add one row\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRows(row.New(15).Add(col.New(12)))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_rows_1.json\")\n\t})\n\tt.Run(\"add two rows\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRows(row.New(15).Add(col.New(12)))\n\t\tsut.AddRows(row.New(15).Add(col.New(12)))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_rows_2.json\")\n\t})\n\tt.Run(\"add rows until add new page\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tsut.AddRows(row.New(15).Add(col.New(12)))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_rows_3.json\")\n\t})\n\n\tt.Run(\"when autoRow is sent, should set autoRow\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tsut.AddRows(row.New().Add(text.NewCol(12, \"teste\")))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_rows_5.json\")\n\t})\n}\n\nfunc TestMaroto_AddAutoRow(t *testing.T) {\n\tt.Run(\"When 100 automatic rows are sent, it should create 2 pages\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tfor i := 0; i < 150; i++ {\n\t\t\tsut.AddAutoRow(text.NewCol(12, \"teste\"))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_auto_row_1.json\")\n\t})\n}\n\nfunc TestMaroto_AddPages(t *testing.T) {\n\tt.Run(\"add one page\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddPages(\n\t\t\tpage.New().Add(\n\t\t\t\trow.New(20).Add(col.New(12)),\n\t\t\t),\n\t\t)\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_pages_1.json\")\n\t})\n\tt.Run(\"add two pages\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddPages(\n\t\t\tpage.New().Add(\n\t\t\t\trow.New(20).Add(col.New(12)),\n\t\t\t),\n\t\t\tpage.New().Add(\n\t\t\t\trow.New(20).Add(col.New(12)),\n\t\t\t),\n\t\t)\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_pages_2.json\")\n\t})\n\tt.Run(\"add page greater than one page\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 15; i++ {\n\t\t\trows = append(rows, row.New(20).Add(col.New(12)))\n\t\t}\n\n\t\t// Act\n\t\tsut.AddPages(page.New().Add(rows...))\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_add_pages_3.json\")\n\t})\n}\n\nfunc TestMaroto_Generate(t *testing.T) {\n\tt.Run(\"add one row\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRow(10, col.New(12))\n\n\t\t// Assert\n\t\tdoc, err := sut.Generate()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, doc)\n\t})\n\tt.Run(\"add two rows\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tsut.AddRow(10, col.New(12))\n\t\tsut.AddRow(10, col.New(12))\n\n\t\t// Assert\n\t\tdoc, err := sut.Generate()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, doc)\n\t})\n\tt.Run(\"add rows until add new page\", func(t *testing.T) {\n\t\t// Arrange\n\t\tsut := maroto.New()\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\tdoc, err := sut.Generate()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, doc)\n\t})\n\tt.Run(\"add rows until add new page, execute in parallel\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithConcurrentMode(7).\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\tdoc, err := sut.Generate()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, doc)\n\t})\n\tt.Run(\"add rows until add new page, execute in low memory mode\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithSequentialLowMemoryMode(10).\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\tdoc, err := sut.Generate()\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, doc)\n\t})\n\tt.Run(\"sequential generation\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithSequentialMode().\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_sequential.json\")\n\t})\n\tt.Run(\"sequential low memory generation\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithSequentialLowMemoryMode(10).\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_sequential_low_memory.json\")\n\t})\n\tt.Run(\"sequential low memory generation\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithConcurrentMode(10).\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_concurrent.json\")\n\t})\n\tt.Run(\"goroutines do not leak after multiple generate calls on concurrent mode\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithConcurrentMode(10).\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\t\tinitialGoroutines := runtime.NumGoroutine()\n\t\t_, err1 := sut.Generate()\n\t\t_, err2 := sut.Generate()\n\t\t_, err3 := sut.Generate()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfinalGoroutines := runtime.NumGoroutine()\n\n\t\t// Assert\n\t\tassert.Nil(t, err1)\n\t\tassert.Nil(t, err2)\n\t\tassert.Nil(t, err3)\n\t\tassert.Equal(t, initialGoroutines, finalGoroutines)\n\t})\n\tt.Run(\"page number\", func(t *testing.T) {\n\t\t// Arrange\n\t\tcfg := config.NewBuilder().\n\t\t\tWithPageNumber().\n\t\t\tBuild()\n\n\t\tsut := maroto.New(cfg)\n\n\t\t// Act\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tsut.AddRow(10, col.New(12))\n\t\t}\n\n\t\t// Assert\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"maroto_page_number.json\")\n\t})\n}\n\nfunc TestMaroto_FitlnCurrentPage(t *testing.T) {\n\tt.Run(\"when component is smaller should available size, then false\", func(t *testing.T) {\n\t\tsut := maroto.New(config.NewBuilder().\n\t\t\tWithDimensions(210.0, 297.0).\n\t\t\tBuild())\n\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 26; i++ {\n\t\t\trows = append(rows, row.New(10).Add(col.New(12)))\n\t\t}\n\n\t\tsut.AddPages(page.New().Add(rows...))\n\t\tassert.False(t, sut.FitlnCurrentPage(40))\n\t})\n\tt.Run(\"when component is larger should the available size, then true\", func(t *testing.T) {\n\t\tsut := maroto.New(config.NewBuilder().\n\t\t\tWithDimensions(210.0, 297.0).\n\t\t\tBuild())\n\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 10; i++ {\n\t\t\trows = append(rows, row.New(10).Add(col.New(12)))\n\t\t}\n\n\t\tsut.AddPages(page.New().Add(rows...))\n\t\tassert.True(t, sut.FitlnCurrentPage(40))\n\t})\n\tt.Run(\"when it have content with an automatic height of 10 and the height sent fits the current page, it should return true\",\n\t\tfunc(t *testing.T) {\n\t\t\tsut := maroto.New(config.NewBuilder().\n\t\t\t\tWithDimensions(210.0, 297.0).\n\t\t\t\tBuild())\n\n\t\t\tvar rows []core.Row\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\trows = append(rows, row.New().Add(text.NewCol(12, \"teste\")))\n\t\t\t}\n\n\t\t\tsut.AddPages(page.New().Add(rows...))\n\t\t\tassert.True(t, sut.FitlnCurrentPage(40))\n\t\t})\n}\n\nfunc TestMaroto_GetCurrentConfig(t *testing.T) {\n\tt.Run(\"When GetCurrentConfig is called then current settings are returned\", func(t *testing.T) {\n\t\tsut := maroto.New(config.NewBuilder().\n\t\t\tWithMaxGridSize(20).\n\t\t\tBuild())\n\n\t\tassert.Equal(t, sut.GetCurrentConfig().MaxGridSize, 20)\n\t})\n}\n\n// nolint:dupl // dupl is good here\nfunc TestMaroto_RegisterHeader(t *testing.T) {\n\tt.Run(\"when header size is greater than useful area, should return error\", func(t *testing.T) {\n\t\tsut := maroto.New()\n\n\t\terr := sut.RegisterHeader(row.New(1000))\n\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, \"header height is greater than page useful area\", err.Error())\n\t})\n\tt.Run(\"when header size is correct, should not return error and apply header\", func(t *testing.T) {\n\t\tsut := maroto.New()\n\n\t\terr := sut.RegisterHeader(code.NewBarRow(10, \"header\"))\n\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 5; i++ {\n\t\t\trows = append(rows, row.New(100).Add(col.New(12)))\n\t\t}\n\n\t\tsut.AddRows(rows...)\n\n\t\t// Assert\n\t\tassert.Nil(t, err)\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"header.json\")\n\t})\n\tt.Run(\"when autoRow is sent, should set autoRow\", func(t *testing.T) {\n\t\tsut := maroto.New()\n\n\t\terr := sut.RegisterHeader(text.NewAutoRow(\"header\"))\n\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 5; i++ {\n\t\t\trows = append(rows, row.New(100).Add(col.New(12)))\n\t\t}\n\n\t\tsut.AddRows(rows...)\n\n\t\t// Assert\n\t\tassert.Nil(t, err)\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"header_auto_row.json\")\n\t})\n}\n\n// nolint:dupl // dupl is good here\nfunc TestMaroto_RegisterFooter(t *testing.T) {\n\tt.Run(\"when footer size is greater than useful area, should return error\", func(t *testing.T) {\n\t\tsut := maroto.New()\n\n\t\terr := sut.RegisterFooter(row.New(1000))\n\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, \"footer height is greater than page useful area\", err.Error())\n\t})\n\tt.Run(\"when header size is correct, should not return error and apply header\", func(t *testing.T) {\n\t\tsut := maroto.New()\n\n\t\terr := sut.RegisterFooter(code.NewBarRow(10, \"footer\"))\n\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 5; i++ {\n\t\t\trows = append(rows, row.New(100).Add(col.New(12)))\n\t\t}\n\n\t\tsut.AddRows(rows...)\n\n\t\t// Assert\n\t\tassert.Nil(t, err)\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"footer.json\")\n\t})\n\tt.Run(\"when autoRow is sent, should set autoRow\", func(t *testing.T) {\n\t\tsut := maroto.New()\n\n\t\terr := sut.RegisterFooter(text.NewAutoRow(\"header\"))\n\n\t\tvar rows []core.Row\n\t\tfor i := 0; i < 5; i++ {\n\t\t\trows = append(rows, row.New(100).Add(col.New(12)))\n\t\t}\n\n\t\tsut.AddRows(rows...)\n\n\t\t// Assert\n\t\tassert.Nil(t, err)\n\t\ttest.New(t).Assert(sut.GetStructure()).Equals(\"footer_auto_row.json\")\n\t})\n}\n"
        },
        {
          "name": "metricsdecorator.go",
          "type": "blob",
          "size": 5.2353515625,
          "content": "package maroto\n\nimport (\n\t\"github.com/johnfercher/go-tree/node\"\n\t\"github.com/johnfercher/maroto/v2/internal/time\"\n\t\"github.com/johnfercher/maroto/v2/pkg/core\"\n\t\"github.com/johnfercher/maroto/v2/pkg/core/entity\"\n\t\"github.com/johnfercher/maroto/v2/pkg/metrics\"\n)\n\ntype MetricsDecorator struct {\n\taddRowsTime    []*metrics.Time\n\taddRowTime     []*metrics.Time\n\taddAutoRowTime []*metrics.Time\n\taddPageTime    []*metrics.Time\n\theaderTime     *metrics.Time\n\tfooterTime     *metrics.Time\n\tgenerateTime   *metrics.Time\n\tstructureTime  *metrics.Time\n\tinner          core.Maroto\n}\n\n// NewMetricsDecorator is responsible to create the metrics decorator\n// for the maroto instance.\nfunc NewMetricsDecorator(inner core.Maroto) core.Maroto {\n\treturn &MetricsDecorator{\n\t\tinner: inner,\n\t}\n}\n\n// FitlnCurrentPage decoratess the FitlnCurrentPage method of maroto instance.\nfunc (m *MetricsDecorator) FitlnCurrentPage(heightNewLine float64) bool {\n\treturn m.inner.FitlnCurrentPage(heightNewLine)\n}\n\n// GetCurrentConfig decorates the GetCurrentConfig method of maroto instance.\nfunc (m *MetricsDecorator) GetCurrentConfig() *entity.Config {\n\treturn m.inner.GetCurrentConfig()\n}\n\n// Generate decorates the Generate method of maroto instance.\nfunc (m *MetricsDecorator) Generate() (core.Document, error) {\n\tvar document core.Document\n\tvar err error\n\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\tdocument, err = m.inner.Generate()\n\t})\n\tm.generateTime = timeSpent\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbytes := document.GetBytes()\n\n\treport := m.buildMetrics(len(bytes)).Normalize()\n\n\treturn core.NewPDF(bytes, report), nil\n}\n\n// AddPages decorates the AddPages method of maroto instance.\nfunc (m *MetricsDecorator) AddPages(pages ...core.Page) {\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\tm.inner.AddPages(pages...)\n\t})\n\n\tm.addPageTime = append(m.addPageTime, timeSpent)\n}\n\n// AddRows decorates the AddRows method of maroto instance.\nfunc (m *MetricsDecorator) AddRows(rows ...core.Row) {\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\tm.inner.AddRows(rows...)\n\t})\n\n\tm.addRowsTime = append(m.addRowsTime, timeSpent)\n}\n\n// AddRow decorates the AddRow method of maroto instance.\nfunc (m *MetricsDecorator) AddRow(rowHeight float64, cols ...core.Col) core.Row {\n\tvar r core.Row\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\tr = m.inner.AddRow(rowHeight, cols...)\n\t})\n\n\tm.addRowTime = append(m.addRowTime, timeSpent)\n\treturn r\n}\n\n// AddRow decorates the AddRow method of maroto instance.\nfunc (m *MetricsDecorator) AddAutoRow(cols ...core.Col) core.Row {\n\tvar r core.Row\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\tr = m.inner.AddAutoRow(cols...)\n\t})\n\n\tm.addAutoRowTime = append(m.addAutoRowTime, timeSpent)\n\treturn r\n}\n\n// RegisterHeader decorates the RegisterHeader method of maroto instance.\nfunc (m *MetricsDecorator) RegisterHeader(rows ...core.Row) error {\n\tvar err error\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\terr = m.inner.RegisterHeader(rows...)\n\t})\n\tm.headerTime = timeSpent\n\treturn err\n}\n\n// RegisterFooter decorates the RegisterFooter method of maroto instance.\nfunc (m *MetricsDecorator) RegisterFooter(rows ...core.Row) error {\n\tvar err error\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\terr = m.inner.RegisterFooter(rows...)\n\t})\n\tm.footerTime = timeSpent\n\treturn err\n}\n\n// GetStructure decorates the GetStructure method of maroto instance.\nfunc (m *MetricsDecorator) GetStructure() *node.Node[core.Structure] {\n\tvar tree *node.Node[core.Structure]\n\n\ttimeSpent := time.GetTimeSpent(func() {\n\t\ttree = m.inner.GetStructure()\n\t})\n\tm.structureTime = timeSpent\n\n\treturn tree\n}\n\nfunc (m *MetricsDecorator) buildMetrics(bytesSize int) *metrics.Report {\n\tvar timeMetrics []metrics.TimeMetric\n\n\tif m.structureTime != nil {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"get_tree_structure\",\n\t\t\tTimes: []*metrics.Time{m.structureTime},\n\t\t\tAvg:   m.structureTime,\n\t\t})\n\t}\n\n\tif m.generateTime != nil {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"generate\",\n\t\t\tTimes: []*metrics.Time{m.generateTime},\n\t\t\tAvg:   m.generateTime,\n\t\t})\n\t}\n\n\tif m.headerTime != nil {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"header\",\n\t\t\tTimes: []*metrics.Time{m.headerTime},\n\t\t\tAvg:   m.headerTime,\n\t\t})\n\t}\n\n\tif m.footerTime != nil {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"footer\",\n\t\t\tTimes: []*metrics.Time{m.footerTime},\n\t\t\tAvg:   m.footerTime,\n\t\t})\n\t}\n\n\tif len(m.addPageTime) > 0 {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"add_page\",\n\t\t\tTimes: m.addPageTime,\n\t\t\tAvg:   m.getAVG(m.addPageTime),\n\t\t})\n\t}\n\n\tif len(m.addRowTime) > 0 {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"add_row\",\n\t\t\tTimes: m.addRowTime,\n\t\t\tAvg:   m.getAVG(m.addRowTime),\n\t\t})\n\t}\n\n\tif len(m.addRowsTime) > 0 {\n\t\ttimeMetrics = append(timeMetrics, metrics.TimeMetric{\n\t\t\tKey:   \"add_rows\",\n\t\t\tTimes: m.addRowsTime,\n\t\t\tAvg:   m.getAVG(m.addRowsTime),\n\t\t})\n\t}\n\n\treturn &metrics.Report{\n\t\tTimeMetrics: timeMetrics,\n\t\tSizeMetric: metrics.SizeMetric{\n\t\t\tKey: \"file_size\",\n\t\t\tSize: metrics.Size{\n\t\t\t\tValue: float64(bytesSize),\n\t\t\t\tScale: metrics.Byte,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc (m *MetricsDecorator) getAVG(times []*metrics.Time) *metrics.Time {\n\tvar sum float64\n\tfor _, time := range times {\n\t\tsum += time.Value\n\t}\n\n\treturn &metrics.Time{\n\t\tValue: sum / float64(len(times)),\n\t\tScale: times[0].Scale,\n\t}\n}\n"
        },
        {
          "name": "metricsdecorator_test.go",
          "type": "blob",
          "size": 5.75,
          "content": "package maroto\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/core/entity\"\n\n\t\"github.com/johnfercher/maroto/v2/pkg/components/text\"\n\n\t\"github.com/johnfercher/go-tree/node\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/col\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/row\"\n\t\"github.com/johnfercher/maroto/v2/pkg/core\"\n\n\t\"github.com/johnfercher/maroto/v2/mocks\"\n\t\"github.com/johnfercher/maroto/v2/pkg/components/page\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewMetricsDecorator(t *testing.T) {\n\t// Act\n\tsut := NewMetricsDecorator(nil)\n\n\t// Assert\n\tassert.NotNil(t, sut)\n\tassert.Equal(t, \"*maroto.MetricsDecorator\", fmt.Sprintf(\"%T\", sut))\n}\n\nfunc TestMetricsDecorator_AddPages(t *testing.T) {\n\t// Arrange\n\tpg := page.New()\n\n\tdocToReturn := mocks.NewDocument(t)\n\tdocToReturn.EXPECT().GetBytes().Return([]byte{1, 2, 3})\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().AddPages(pg)\n\tinner.EXPECT().Generate().Return(docToReturn, nil)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act\n\tsut.AddPages(pg)\n\tsut.AddPages(pg)\n\n\t// Assert\n\tdoc, err := sut.Generate()\n\tassert.Nil(t, err)\n\tassert.NotNil(t, doc)\n\n\treport := doc.GetReport()\n\tassert.NotNil(t, report)\n\tassert.Equal(t, 2, len(report.TimeMetrics))\n\tassert.Equal(t, \"generate\", report.TimeMetrics[0].Key)\n\tassert.Equal(t, \"add_page\", report.TimeMetrics[1].Key)\n\tassert.Equal(t, 2, len(report.TimeMetrics[1].Times))\n\tinner.AssertNumberOfCalls(t, \"AddPages\", 2)\n}\n\nfunc TestMetricsDecorator_AddRow(t *testing.T) {\n\t// Arrange\n\tcol := col.New(12)\n\n\tdocToReturn := mocks.NewDocument(t)\n\tdocToReturn.EXPECT().GetBytes().Return([]byte{1, 2, 3})\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().AddRow(10.0, col).Return(nil)\n\tinner.EXPECT().Generate().Return(docToReturn, nil)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act\n\tsut.AddRow(10, col)\n\tsut.AddRow(10, col)\n\n\t// Assert\n\tdoc, err := sut.Generate()\n\tassert.Nil(t, err)\n\tassert.NotNil(t, doc)\n\n\treport := doc.GetReport()\n\tassert.NotNil(t, report)\n\tassert.Equal(t, 2, len(report.TimeMetrics))\n\tassert.Equal(t, \"generate\", report.TimeMetrics[0].Key)\n\tassert.Equal(t, \"add_row\", report.TimeMetrics[1].Key)\n\tassert.Equal(t, 2, len(report.TimeMetrics[1].Times))\n\tinner.AssertNumberOfCalls(t, \"AddRow\", 2)\n}\n\nfunc TestMetricsDecorator_AddRows(t *testing.T) {\n\t// Arrange\n\trow := row.New(10).Add(col.New(12))\n\n\tdocToReturn := mocks.NewDocument(t)\n\tdocToReturn.EXPECT().GetBytes().Return([]byte{1, 2, 3})\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().AddRows(row)\n\tinner.EXPECT().Generate().Return(docToReturn, nil)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act\n\tsut.AddRows(row)\n\tsut.AddRows(row)\n\n\t// Assert\n\tdoc, err := sut.Generate()\n\tassert.Nil(t, err)\n\tassert.NotNil(t, doc)\n\n\treport := doc.GetReport()\n\tassert.NotNil(t, report)\n\tassert.Equal(t, 2, len(report.TimeMetrics))\n\tassert.Equal(t, \"generate\", report.TimeMetrics[0].Key)\n\tassert.Equal(t, \"add_rows\", report.TimeMetrics[1].Key)\n\tassert.Equal(t, 2, len(report.TimeMetrics[1].Times))\n\tinner.AssertNumberOfCalls(t, \"AddRows\", 2)\n}\n\nfunc TestMetricsDecorator_GetStructure(t *testing.T) {\n\t// Arrange\n\trow := row.New(10).Add(col.New(12))\n\n\tdocToReturn := mocks.NewDocument(t)\n\tdocToReturn.EXPECT().GetBytes().Return([]byte{1, 2, 3})\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().AddRows(row)\n\tinner.EXPECT().GetStructure().Return(&node.Node[core.Structure]{})\n\tinner.EXPECT().Generate().Return(docToReturn, nil)\n\n\tsut := NewMetricsDecorator(inner)\n\tsut.AddRows(row)\n\n\t// Act\n\t_ = sut.GetStructure()\n\n\t// Assert\n\tdoc, err := sut.Generate()\n\tassert.Nil(t, err)\n\tassert.NotNil(t, doc)\n\n\treport := doc.GetReport()\n\tassert.NotNil(t, report)\n\tassert.Equal(t, 3, len(report.TimeMetrics))\n\tassert.Equal(t, \"get_tree_structure\", report.TimeMetrics[0].Key)\n\tassert.Equal(t, \"generate\", report.TimeMetrics[1].Key)\n\tassert.Equal(t, \"add_rows\", report.TimeMetrics[2].Key)\n\tassert.Equal(t, 1, len(report.TimeMetrics[1].Times))\n\tinner.AssertNumberOfCalls(t, \"AddRows\", 1)\n\tinner.AssertNumberOfCalls(t, \"GetStructure\", 1)\n}\n\nfunc TestMetricsDecorator_FitlnCurrentPage(t *testing.T) {\n\t// Arrange\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().FitlnCurrentPage(10.0).Return(true)\n\tinner.EXPECT().FitlnCurrentPage(20.0).Return(false)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act & Assert\n\tassert.True(t, sut.FitlnCurrentPage(10))\n\tassert.False(t, sut.FitlnCurrentPage(20))\n}\n\nfunc TestMetricsDecorator_GetCurrentConfig(t *testing.T) {\n\t// Arrange\n\tcfgToReturn := &entity.Config{\n\t\tMaxGridSize: 15,\n\t}\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().GetCurrentConfig().Return(cfgToReturn)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act\n\tcfg := sut.GetCurrentConfig()\n\n\t// Assert\n\tassert.Equal(t, cfgToReturn.MaxGridSize, cfg.MaxGridSize)\n}\n\nfunc TestMetricsDecorator_RegisterHeader(t *testing.T) {\n\t// Arrange\n\trow := text.NewRow(10, \"text\")\n\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().RegisterHeader(row).Return(nil)\n\tinner.EXPECT().Generate().Return(&core.Pdf{}, nil)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act\n\terr := sut.RegisterHeader(row)\n\n\t// Assert\n\tassert.Nil(t, err)\n\n\tdoc, err := sut.Generate()\n\tassert.Nil(t, err)\n\n\treport := doc.GetReport()\n\tassert.NotNil(t, report)\n\tassert.Equal(t, 2, len(report.TimeMetrics))\n\tassert.Equal(t, \"generate\", report.TimeMetrics[0].Key)\n\tassert.Equal(t, \"header\", report.TimeMetrics[1].Key)\n}\n\nfunc TestMetricsDecorator_RegisterFooter(t *testing.T) {\n\t// Arrange\n\trow := text.NewRow(10, \"text\")\n\n\tinner := mocks.NewMaroto(t)\n\tinner.EXPECT().RegisterFooter(row).Return(nil)\n\tinner.EXPECT().Generate().Return(&core.Pdf{}, nil)\n\n\tsut := NewMetricsDecorator(inner)\n\n\t// Act\n\terr := sut.RegisterFooter(row)\n\n\t// Assert\n\tassert.Nil(t, err)\n\n\tdoc, err := sut.Generate()\n\tassert.Nil(t, err)\n\n\treport := doc.GetReport()\n\tassert.NotNil(t, report)\n\tassert.Equal(t, 2, len(report.TimeMetrics))\n\tassert.Equal(t, \"generate\", report.TimeMetrics[0].Key)\n\tassert.Equal(t, \"footer\", report.TimeMetrics[1].Key)\n}\n"
        },
        {
          "name": "mocks",
          "type": "tree",
          "content": null
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "pull_request_template.md",
          "type": "blob",
          "size": 1.2001953125,
          "content": "<!-- Please follow the PR naming pattern. -->\n<!-- For features: feature/name -->\n<!-- For fixes: fix/name -->\n\n**Description**\n<!-- Please, describe how this PR will be useful. If it has any tricky technical detail, please explain too. -->\n\n**Related Issue**\n<!-- If it has any issue related to this PR, please add a reference here. -->\n\n**Checklist**\n> check with \"x\", **ONLY IF APPLIED** to your change\n\n- [ ] All methods associated with structs has ```func (<first letter of struct> *struct) method() {}``` name style. <!-- If applied -->\n- [ ] Wrote unit tests for new/changed features. <!-- If applied -->\n- [ ] Followed the unit test ```when,should``` naming pattern. <!-- If applied -->\n- [ ] All mocks created with ```m := mocks.NewConstructor(t)```. <!-- If applied -->\n- [ ] All mocks using ```m.EXPECT().MethodName()``` method to mock methods. <!-- If applied -->\n- [ ] Updated docs/doc.go and docs/* <!-- If applied -->\n- [ ] Updated ```example_test.go```. <!-- If applied -->\n- [ ] Updated README.md <!-- If applied -->\n- [ ] New public methods/structs/interfaces has comments upside them explaining they responsibilities <!-- If applied -->\n- [ ] Executed `make dod` with none issues pointed out by `golangci-lint`"
        },
        {
          "name": "shell",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}