{
  "metadata": {
    "timestamp": 1736567251608,
    "page": 849,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ebitengine/purego",
      "stars": 2372,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0029296875,
          "content": "*~\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.5673828125,
          "content": "# purego\n[![Go Reference](https://pkg.go.dev/badge/github.com/ebitengine/purego?GOOS=darwin.svg)](https://pkg.go.dev/github.com/ebitengine/purego?GOOS=darwin)\n\nA library for calling C functions from Go without Cgo.\n\n> This is beta software so expect bugs and potentially API breaking changes\n> but each release will be tagged to avoid breaking people's code.\n> Bug reports are encouraged.\n\n## Motivation\n\nThe [Ebitengine](https://github.com/hajimehoshi/ebiten) game engine was ported to use only Go on Windows. This enabled\ncross-compiling to Windows from any other operating system simply by setting `GOOS=windows`. The purego project was\nborn to bring that same vision to the other platforms supported by Ebitengine.\n\n## Benefits\n\n- **Simple Cross-Compilation**: No C means you can build for other platforms easily without a C compiler.\n- **Faster Compilation**: Efficiently cache your entirely Go builds.\n- **Smaller Binaries**: Using Cgo generates a C wrapper function for each C function called. Purego doesn't!\n- **Dynamic Linking**: Load symbols at runtime and use it as a plugin system.\n- **Foreign Function Interface**: Call into other languages that are compiled into shared objects.\n- **Cgo Fallback**: Works even with CGO_ENABLED=1 so incremental porting is possible. \nThis also means unsupported GOARCHs (freebsd/riscv64, linux/mips, etc.) will still work\nexcept for float arguments and return values.\n\n## Supported Platforms\n\n- **FreeBSD**: amd64, arm64\n- **Linux**: amd64, arm64\n- **macOS / iOS**: amd64, arm64\n- **Windows**: 386*, amd64, arm*, arm64\n\n`*` These architectures only support SyscallN and NewCallback\n\n## Example\n\nThe example below only showcases purego use for macOS and Linux. The other platforms require special handling which can\nbe seen in the complete example at [examples/libc](https://github.com/ebitengine/purego/tree/main/examples/libc) which supports Windows and FreeBSD.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\n\t\"github.com/ebitengine/purego\"\n)\n\nfunc getSystemLibrary() string {\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\treturn \"/usr/lib/libSystem.B.dylib\"\n\tcase \"linux\":\n\t\treturn \"libc.so.6\"\n\tdefault:\n\t\tpanic(fmt.Errorf(\"GOOS=%s is not supported\", runtime.GOOS))\n\t}\n}\n\nfunc main() {\n\tlibc, err := purego.Dlopen(getSystemLibrary(), purego.RTLD_NOW|purego.RTLD_GLOBAL)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar puts func(string)\n\tpurego.RegisterLibFunc(&puts, libc, \"puts\")\n\tputs(\"Calling C from Go without Cgo!\")\n}\n```\n\nThen to run: `CGO_ENABLED=0 go run main.go`\n\n## Questions\n\nIf you have questions about how to incorporate purego in your project or want to discuss\nhow it works join the [Discord](https://discord.gg/HzGZVD6BkY)!\n\n### External Code\n\nPurego uses code that originates from the Go runtime. These files are under the BSD-3\nLicense that can be found [in the Go Source](https://github.com/golang/go/blob/master/LICENSE).\nThis is a list of the copied files:\n\n* `abi_*.h` from package `runtime/cgo`\n* `zcallback_darwin_*.s` from package `runtime`\n* `internal/fakecgo/abi_*.h` from package `runtime/cgo`\n* `internal/fakecgo/asm_GOARCH.s` from package `runtime/cgo`\n* `internal/fakecgo/callbacks.go` from package `runtime/cgo`\n* `internal/fakecgo/go_GOOS_GOARCH.go` from package `runtime/cgo`\n* `internal/fakecgo/iscgo.go` from package `runtime/cgo`\n* `internal/fakecgo/setenv.go` from package `runtime/cgo`\n* `internal/fakecgo/freebsd.go` from package `runtime/cgo`\n\nThe files `abi_*.h` and `internal/fakecgo/abi_*.h` are the same because Bazel does not support cross-package use of\n`#include` so we need each one once per package. (cf. [issue](https://github.com/bazelbuild/rules_go/issues/3636))\n"
        },
        {
          "name": "abi_amd64.h",
          "type": "blob",
          "size": 2.7294921875,
          "content": "// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Macros for transitioning from the host ABI to Go ABI0.\n//\n// These save the frame pointer, so in general, functions that use\n// these should have zero frame size to suppress the automatic frame\n// pointer, though it's harmless to not do this.\n\n#ifdef GOOS_windows\n\n// REGS_HOST_TO_ABI0_STACK is the stack bytes used by\n// PUSH_REGS_HOST_TO_ABI0.\n#define REGS_HOST_TO_ABI0_STACK (28*8 + 8)\n\n// PUSH_REGS_HOST_TO_ABI0 prepares for transitioning from\n// the host ABI to Go ABI0 code. It saves all registers that are\n// callee-save in the host ABI and caller-save in Go ABI0 and prepares\n// for entry to Go.\n//\n// Save DI SI BP BX R12 R13 R14 R15 X6-X15 registers and the DF flag.\n// Clear the DF flag for the Go ABI.\n// MXCSR matches the Go ABI, so we don't have to set that,\n// and Go doesn't modify it, so we don't have to save it.\n#define PUSH_REGS_HOST_TO_ABI0()\t\\\n\tPUSHFQ\t\t\t\\\n\tCLD\t\t\t\\\n\tADJSP\t$(REGS_HOST_TO_ABI0_STACK - 8)\t\\\n\tMOVQ\tDI, (0*0)(SP)\t\\\n\tMOVQ\tSI, (1*8)(SP)\t\\\n\tMOVQ\tBP, (2*8)(SP)\t\\\n\tMOVQ\tBX, (3*8)(SP)\t\\\n\tMOVQ\tR12, (4*8)(SP)\t\\\n\tMOVQ\tR13, (5*8)(SP)\t\\\n\tMOVQ\tR14, (6*8)(SP)\t\\\n\tMOVQ\tR15, (7*8)(SP)\t\\\n\tMOVUPS\tX6, (8*8)(SP)\t\\\n\tMOVUPS\tX7, (10*8)(SP)\t\\\n\tMOVUPS\tX8, (12*8)(SP)\t\\\n\tMOVUPS\tX9, (14*8)(SP)\t\\\n\tMOVUPS\tX10, (16*8)(SP)\t\\\n\tMOVUPS\tX11, (18*8)(SP)\t\\\n\tMOVUPS\tX12, (20*8)(SP)\t\\\n\tMOVUPS\tX13, (22*8)(SP)\t\\\n\tMOVUPS\tX14, (24*8)(SP)\t\\\n\tMOVUPS\tX15, (26*8)(SP)\n\n#define POP_REGS_HOST_TO_ABI0()\t\\\n\tMOVQ\t(0*0)(SP), DI\t\\\n\tMOVQ\t(1*8)(SP), SI\t\\\n\tMOVQ\t(2*8)(SP), BP\t\\\n\tMOVQ\t(3*8)(SP), BX\t\\\n\tMOVQ\t(4*8)(SP), R12\t\\\n\tMOVQ\t(5*8)(SP), R13\t\\\n\tMOVQ\t(6*8)(SP), R14\t\\\n\tMOVQ\t(7*8)(SP), R15\t\\\n\tMOVUPS\t(8*8)(SP), X6\t\\\n\tMOVUPS\t(10*8)(SP), X7\t\\\n\tMOVUPS\t(12*8)(SP), X8\t\\\n\tMOVUPS\t(14*8)(SP), X9\t\\\n\tMOVUPS\t(16*8)(SP), X10\t\\\n\tMOVUPS\t(18*8)(SP), X11\t\\\n\tMOVUPS\t(20*8)(SP), X12\t\\\n\tMOVUPS\t(22*8)(SP), X13\t\\\n\tMOVUPS\t(24*8)(SP), X14\t\\\n\tMOVUPS\t(26*8)(SP), X15\t\\\n\tADJSP\t$-(REGS_HOST_TO_ABI0_STACK - 8)\t\\\n\tPOPFQ\n\n#else\n// SysV ABI\n\n#define REGS_HOST_TO_ABI0_STACK (6*8)\n\n// SysV MXCSR matches the Go ABI, so we don't have to set that,\n// and Go doesn't modify it, so we don't have to save it.\n// Both SysV and Go require DF to be cleared, so that's already clear.\n// The SysV and Go frame pointer conventions are compatible.\n#define PUSH_REGS_HOST_TO_ABI0()\t\\\n\tADJSP\t$(REGS_HOST_TO_ABI0_STACK)\t\\\n\tMOVQ\tBP, (5*8)(SP)\t\\\n\tLEAQ\t(5*8)(SP), BP\t\\\n\tMOVQ\tBX, (0*8)(SP)\t\\\n\tMOVQ\tR12, (1*8)(SP)\t\\\n\tMOVQ\tR13, (2*8)(SP)\t\\\n\tMOVQ\tR14, (3*8)(SP)\t\\\n\tMOVQ\tR15, (4*8)(SP)\n\n#define POP_REGS_HOST_TO_ABI0()\t\\\n\tMOVQ\t(0*8)(SP), BX\t\\\n\tMOVQ\t(1*8)(SP), R12\t\\\n\tMOVQ\t(2*8)(SP), R13\t\\\n\tMOVQ\t(3*8)(SP), R14\t\\\n\tMOVQ\t(4*8)(SP), R15\t\\\n\tMOVQ\t(5*8)(SP), BP\t\\\n\tADJSP\t$-(REGS_HOST_TO_ABI0_STACK)\n\n#endif\n"
        },
        {
          "name": "abi_arm64.h",
          "type": "blob",
          "size": 1.4912109375,
          "content": "// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Macros for transitioning from the host ABI to Go ABI0.\n//\n// These macros save and restore the callee-saved registers\n// from the stack, but they don't adjust stack pointer, so\n// the user should prepare stack space in advance.\n// SAVE_R19_TO_R28(offset) saves R19 ~ R28 to the stack space\n// of ((offset)+0*8)(RSP) ~ ((offset)+9*8)(RSP).\n//\n// SAVE_F8_TO_F15(offset) saves F8 ~ F15 to the stack space\n// of ((offset)+0*8)(RSP) ~ ((offset)+7*8)(RSP).\n//\n// R29 is not saved because Go will save and restore it.\n\n#define SAVE_R19_TO_R28(offset) \\\n\tSTP\t(R19, R20), ((offset)+0*8)(RSP) \\\n\tSTP\t(R21, R22), ((offset)+2*8)(RSP) \\\n\tSTP\t(R23, R24), ((offset)+4*8)(RSP) \\\n\tSTP\t(R25, R26), ((offset)+6*8)(RSP) \\\n\tSTP\t(R27, g), ((offset)+8*8)(RSP)\n#define RESTORE_R19_TO_R28(offset) \\\n\tLDP\t((offset)+0*8)(RSP), (R19, R20) \\\n\tLDP\t((offset)+2*8)(RSP), (R21, R22) \\\n\tLDP\t((offset)+4*8)(RSP), (R23, R24) \\\n\tLDP\t((offset)+6*8)(RSP), (R25, R26) \\\n\tLDP\t((offset)+8*8)(RSP), (R27, g) /* R28 */\n#define SAVE_F8_TO_F15(offset) \\\n\tFSTPD\t(F8, F9), ((offset)+0*8)(RSP) \\\n\tFSTPD\t(F10, F11), ((offset)+2*8)(RSP) \\\n\tFSTPD\t(F12, F13), ((offset)+4*8)(RSP) \\\n\tFSTPD\t(F14, F15), ((offset)+6*8)(RSP)\n#define RESTORE_F8_TO_F15(offset) \\\n\tFLDPD\t((offset)+0*8)(RSP), (F8, F9) \\\n\tFLDPD\t((offset)+2*8)(RSP), (F10, F11) \\\n\tFLDPD\t((offset)+4*8)(RSP), (F12, F13) \\\n\tFLDPD\t((offset)+6*8)(RSP), (F14, F15)\n"
        },
        {
          "name": "callback_test.go",
          "type": "blob",
          "size": 5.3466796875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2023 The Ebitengine Authors\n\n//go:build darwin || (linux && (amd64 || arm64))\n\npackage purego_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"github.com/ebitengine/purego\"\n)\n\n// TestCallGoFromSharedLib is a test that checks for stack corruption on arm64\n// when C calls Go code from a non-Go thread in a dynamically loaded share library.\nfunc TestCallGoFromSharedLib(t *testing.T) {\n\tlibFileName := filepath.Join(t.TempDir(), \"libcbtest.so\")\n\tt.Logf(\"Build %v\", libFileName)\n\n\tif err := buildSharedLib(\"CC\", libFileName, filepath.Join(\"testdata\", \"libcbtest\", \"callback_test.c\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(libFileName)\n\n\tlib, err := purego.Dlopen(libFileName, purego.RTLD_NOW|purego.RTLD_GLOBAL)\n\tif err != nil {\n\t\tt.Fatalf(\"Dlopen(%q) failed: %v\", libFileName, err)\n\t}\n\n\tvar callCallback func(p uintptr, s string) int\n\tpurego.RegisterLibFunc(&callCallback, lib, \"callCallback\")\n\n\tgoFunc := func(cstr *byte, n int) int {\n\t\ts := string(unsafe.Slice(cstr, n))\n\t\tt.Logf(\"FROM Go: %s\\n\", s)\n\t\treturn 1\n\t}\n\n\tconst want = 10101\n\tcb := purego.NewCallback(goFunc)\n\tfor i := 0; i < 10; i++ {\n\t\tgot := callCallback(cb, \"a test string\")\n\t\tif got != want {\n\t\t\tt.Fatalf(\"%d: callCallback() got %v want %v\", i, got, want)\n\t\t}\n\t}\n}\n\nfunc TestNewCallbackFloat64(t *testing.T) {\n\t// This tests the maximum number of arguments a function to NewCallback can take\n\tconst (\n\t\texpectCbTotal    = -3\n\t\texpectedCbTotalF = float64(36)\n\t)\n\tvar cbTotal int\n\tvar cbTotalF float64\n\timp := purego.NewCallback(func(a1, a2, a3, a4, a5, a6, a7, a8, a9 int,\n\t\tf1, f2, f3, f4, f5, f6, f7, f8 float64,\n\t) {\n\t\tcbTotal = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9\n\t\tcbTotalF = f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8\n\t})\n\tvar fn func(a1, a2, a3, a4, a5, a6, a7, a8, a9 int,\n\t\tf1, f2, f3, f4, f5, f6, f7, f8 float64)\n\tpurego.RegisterFunc(&fn, imp)\n\tfn(1, 2, -3, 4, -5, 6, -7, 8, -9,\n\t\t1, 2, 3, 4, 5, 6, 7, 8)\n\n\tif cbTotal != expectCbTotal {\n\t\tt.Errorf(\"cbTotal not correct got %d but wanted %d\", cbTotal, expectCbTotal)\n\t}\n\tif cbTotalF != expectedCbTotalF {\n\t\tt.Errorf(\"cbTotalF not correct got %f but wanted %f\", cbTotalF, expectedCbTotalF)\n\t}\n}\n\nfunc TestNewCallbackFloat64AndIntMix(t *testing.T) {\n\t// This tests interleaving float and integer arguments to NewCallback\n\tconst (\n\t\texpectCbTotal = 54.75\n\t)\n\tvar cbTotal float64\n\timp := purego.NewCallback(func(a1, a2 float64, a3, a4, a5 int, a6, a7, a8 float64, a9 int) {\n\t\tcbTotal = a1 + a2 + float64(a3) + float64(a4) + float64(a5) + a6 + a7 + a8 + float64(a9)\n\t})\n\tvar fn func(a1, a2 float64, a3, a4, a5 int, a6, a7, a8 float64, a9 int)\n\tpurego.RegisterFunc(&fn, imp)\n\tfn(1.25, 3.25, 4, 5, 6, 7.5, 8.25, 9.5, 10)\n\n\tif cbTotal != expectCbTotal {\n\t\tt.Errorf(\"cbTotal not correct got %f but wanted %f\", cbTotal, expectCbTotal)\n\t}\n}\n\nfunc TestNewCallbackFloat32(t *testing.T) {\n\t// This tests the maximum number of float32 arguments a function to NewCallback can take\n\tconst (\n\t\texpectCbTotal    = 6\n\t\texpectedCbTotalF = float32(45)\n\t)\n\tvar cbTotal int\n\tvar cbTotalF float32\n\timp := purego.NewCallback(func(a1, a2, a3, a4, a5, a6, a7, a8 int,\n\t\tf1, f2, f3, f4, f5, f6, f7, f8, f9 float32,\n\t) {\n\t\tcbTotal = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8\n\t\tcbTotalF = f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9\n\t})\n\tvar fn func(a1, a2, a3, a4, a5, a6, a7, a8 int,\n\t\tf1, f2, f3, f4, f5, f6, f7, f8, f9 float32)\n\tpurego.RegisterFunc(&fn, imp)\n\tfn(1, 2, -3, 4, -5, 6, -7, 8,\n\t\t1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n\tif cbTotal != expectCbTotal {\n\t\tt.Errorf(\"cbTotal not correct got %d but wanted %d\", cbTotal, expectCbTotal)\n\t}\n\tif cbTotalF != expectedCbTotalF {\n\t\tt.Errorf(\"cbTotalF not correct got %f but wanted %f\", cbTotalF, expectedCbTotalF)\n\t}\n}\n\nfunc TestNewCallbackFloat32AndFloat64(t *testing.T) {\n\t// This tests that calling a function with a mix of float32 and float64 arguments works\n\tconst (\n\t\texpectedCbTotalF32 = float32(72)\n\t\texpectedCbTotalF64 = float64(48)\n\t)\n\tvar cbTotalF32 float32\n\tvar cbTotalF64 float64\n\timp := purego.NewCallback(func(f1, f2, f3 float32, f4, f5, f6 float64, f7, f8, f9 float32, f10, f11, f12 float64, f13, f14, f15 float32) {\n\t\tcbTotalF32 = f1 + f2 + f3 + f7 + f8 + f9 + f13 + f14 + f15\n\t\tcbTotalF64 = f4 + f5 + f6 + f10 + f11 + f12\n\t})\n\tvar fn func(f1, f2, f3 float32, f4, f5, f6 float64, f7, f8, f9 float32, f10, f11, f12 float64, f13, f14, f15 float32)\n\tpurego.RegisterFunc(&fn, imp)\n\tfn(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n\n\tif cbTotalF32 != expectedCbTotalF32 {\n\t\tt.Errorf(\"cbTotalF32 not correct got %f but wanted %f\", cbTotalF32, expectedCbTotalF32)\n\t}\n\tif cbTotalF64 != expectedCbTotalF64 {\n\t\tt.Errorf(\"cbTotalF64 not correct got %f but wanted %f\", cbTotalF64, expectedCbTotalF64)\n\t}\n}\n\nfunc ExampleNewCallback() {\n\tcb := purego.NewCallback(func(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 int) int {\n\t\tfmt.Println(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)\n\t\treturn a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15\n\t})\n\n\tvar fn func(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 int) int\n\tpurego.RegisterFunc(&fn, cb)\n\n\tret := fn(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n\tfmt.Println(ret)\n\n\t// Output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n\t// 120\n}\n\nfunc ExampleNewCallback_cdecl() {\n\tfn := func(_ purego.CDecl, a int) {\n\t\tfmt.Println(a)\n\t}\n\tcb := purego.NewCallback(fn)\n\tpurego.SyscallN(cb, 83)\n\n\t// Output: 83\n}\n"
        },
        {
          "name": "cgo.go",
          "type": "blob",
          "size": 0.7607421875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build cgo && (darwin || freebsd || linux)\n\npackage purego\n\n// if CGO_ENABLED=1 import the Cgo runtime to ensure that it is set up properly.\n// This is required since some frameworks need TLS setup the C way which Go doesn't do.\n// We currently don't support ios in fakecgo mode so force Cgo or fail\n// Even if CGO_ENABLED=1 the Cgo runtime is not imported unless `import \"C\"` is used.\n// which will import this package automatically. Normally this isn't an issue since it\n// usually isn't possible to call into C without using that import. However, with purego\n// it is since we don't use `import \"C\"`!\nimport (\n\t_ \"runtime/cgo\"\n\n\t_ \"github.com/ebitengine/purego/internal/cgo\"\n)\n"
        },
        {
          "name": "dlerror.go",
          "type": "blob",
          "size": 0.390625,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2023 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux\n\npackage purego\n\n// Dlerror represents an error value returned from Dlopen, Dlsym, or Dlclose.\n//\n// This type is not available on Windows as there is no counterpart to it on Windows.\ntype Dlerror struct {\n\ts string\n}\n\nfunc (e Dlerror) Error() string {\n\treturn e.s\n}\n"
        },
        {
          "name": "dlfcn.go",
          "type": "blob",
          "size": 3.4443359375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build (darwin || freebsd || linux) && !android && !faketime\n\npackage purego\n\nimport (\n\t\"unsafe\"\n)\n\n// Unix Specification for dlfcn.h: https://pubs.opengroup.org/onlinepubs/7908799/xsh/dlfcn.h.html\n\nvar (\n\tfnDlopen  func(path string, mode int) uintptr\n\tfnDlsym   func(handle uintptr, name string) uintptr\n\tfnDlerror func() string\n\tfnDlclose func(handle uintptr) bool\n)\n\nfunc init() {\n\tRegisterFunc(&fnDlopen, dlopenABI0)\n\tRegisterFunc(&fnDlsym, dlsymABI0)\n\tRegisterFunc(&fnDlerror, dlerrorABI0)\n\tRegisterFunc(&fnDlclose, dlcloseABI0)\n}\n\n// Dlopen examines the dynamic library or bundle file specified by path. If the file is compatible\n// with the current process and has not already been loaded into the\n// current process, it is loaded and linked. After being linked, if it contains\n// any initializer functions, they are called, before Dlopen\n// returns. It returns a handle that can be used with Dlsym and Dlclose.\n// A second call to Dlopen with the same path will return the same handle, but the internal\n// reference count for the handle will be incremented. Therefore, all\n// Dlopen calls should be balanced with a Dlclose call.\n//\n// This function is not available on Windows.\n// Use [golang.org/x/sys/windows.LoadLibrary], [golang.org/x/sys/windows.LoadLibraryEx],\n// [golang.org/x/sys/windows.NewLazyDLL], or [golang.org/x/sys/windows.NewLazySystemDLL] for Windows instead.\nfunc Dlopen(path string, mode int) (uintptr, error) {\n\tu := fnDlopen(path, mode)\n\tif u == 0 {\n\t\treturn 0, Dlerror{fnDlerror()}\n\t}\n\treturn u, nil\n}\n\n// Dlsym takes a \"handle\" of a dynamic library returned by Dlopen and the symbol name.\n// It returns the address where that symbol is loaded into memory. If the symbol is not found,\n// in the specified library or any of the libraries that were automatically loaded by Dlopen\n// when that library was loaded, Dlsym returns zero.\n//\n// This function is not available on Windows.\n// Use [golang.org/x/sys/windows.GetProcAddress] for Windows instead.\nfunc Dlsym(handle uintptr, name string) (uintptr, error) {\n\tu := fnDlsym(handle, name)\n\tif u == 0 {\n\t\treturn 0, Dlerror{fnDlerror()}\n\t}\n\treturn u, nil\n}\n\n// Dlclose decrements the reference count on the dynamic library handle.\n// If the reference count drops to zero and no other loaded libraries\n// use symbols in it, then the dynamic library is unloaded.\n//\n// This function is not available on Windows.\n// Use [golang.org/x/sys/windows.FreeLibrary] for Windows instead.\nfunc Dlclose(handle uintptr) error {\n\tif fnDlclose(handle) {\n\t\treturn Dlerror{fnDlerror()}\n\t}\n\treturn nil\n}\n\nfunc loadSymbol(handle uintptr, name string) (uintptr, error) {\n\treturn Dlsym(handle, name)\n}\n\n// these functions exist in dlfcn_stubs.s and are calling C functions linked to in dlfcn_GOOS.go\n// the indirection is necessary because a function is actually a pointer to the pointer to the code.\n// sadly, I do not know of anyway to remove the assembly stubs entirely because //go:linkname doesn't\n// appear to work if you link directly to the C function on darwin arm64.\n\n//go:linkname dlopen dlopen\nvar dlopen uintptr\nvar dlopenABI0 = uintptr(unsafe.Pointer(&dlopen))\n\n//go:linkname dlsym dlsym\nvar dlsym uintptr\nvar dlsymABI0 = uintptr(unsafe.Pointer(&dlsym))\n\n//go:linkname dlclose dlclose\nvar dlclose uintptr\nvar dlcloseABI0 = uintptr(unsafe.Pointer(&dlclose))\n\n//go:linkname dlerror dlerror\nvar dlerror uintptr\nvar dlerrorABI0 = uintptr(unsafe.Pointer(&dlerror))\n"
        },
        {
          "name": "dlfcn_android.go",
          "type": "blob",
          "size": 0.865234375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2024 The Ebitengine Authors\n\npackage purego\n\nimport \"github.com/ebitengine/purego/internal/cgo\"\n\n// Source for constants: https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/include/dlfcn.h\n\nconst (\n\tis64bit      = 1 << (^uintptr(0) >> 63) / 2\n\tis32bit      = 1 - is64bit\n\tRTLD_DEFAULT = is32bit * 0xffffffff\n\tRTLD_LAZY    = 0x00000001\n\tRTLD_NOW     = is64bit * 0x00000002\n\tRTLD_LOCAL   = 0x00000000\n\tRTLD_GLOBAL  = is64bit*0x00100 | is32bit*0x00000002\n)\n\nfunc Dlopen(path string, mode int) (uintptr, error) {\n\treturn cgo.Dlopen(path, mode)\n}\n\nfunc Dlsym(handle uintptr, name string) (uintptr, error) {\n\treturn cgo.Dlsym(handle, name)\n}\n\nfunc Dlclose(handle uintptr) error {\n\treturn cgo.Dlclose(handle)\n}\n\nfunc loadSymbol(handle uintptr, name string) (uintptr, error) {\n\treturn Dlsym(handle, name)\n}\n"
        },
        {
          "name": "dlfcn_darwin.go",
          "type": "blob",
          "size": 1.259765625,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\npackage purego\n\n// Source for constants: https://opensource.apple.com/source/dyld/dyld-360.14/include/dlfcn.h.auto.html\n\nconst (\n\tRTLD_DEFAULT = 1<<64 - 2 // Pseudo-handle for dlsym so search for any loaded symbol\n\tRTLD_LAZY    = 0x1       // Relocations are performed at an implementation-dependent time.\n\tRTLD_NOW     = 0x2       // Relocations are performed when the object is loaded.\n\tRTLD_LOCAL   = 0x4       // All symbols are not made available for relocation processing by other modules.\n\tRTLD_GLOBAL  = 0x8       // All symbols are available for relocation processing of other modules.\n)\n\n//go:cgo_import_dynamic purego_dlopen dlopen \"/usr/lib/libSystem.B.dylib\"\n//go:cgo_import_dynamic purego_dlsym dlsym \"/usr/lib/libSystem.B.dylib\"\n//go:cgo_import_dynamic purego_dlerror dlerror \"/usr/lib/libSystem.B.dylib\"\n//go:cgo_import_dynamic purego_dlclose dlclose \"/usr/lib/libSystem.B.dylib\"\n\n//go:cgo_import_dynamic purego_dlopen dlopen \"/usr/lib/libSystem.B.dylib\"\n//go:cgo_import_dynamic purego_dlsym dlsym \"/usr/lib/libSystem.B.dylib\"\n//go:cgo_import_dynamic purego_dlerror dlerror \"/usr/lib/libSystem.B.dylib\"\n//go:cgo_import_dynamic purego_dlclose dlclose \"/usr/lib/libSystem.B.dylib\"\n"
        },
        {
          "name": "dlfcn_freebsd.go",
          "type": "blob",
          "size": 0.7763671875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\npackage purego\n\n// Constants as defined in https://github.com/freebsd/freebsd-src/blob/main/include/dlfcn.h\nconst (\n\tintSize      = 32 << (^uint(0) >> 63) // 32 or 64\n\tRTLD_DEFAULT = 1<<intSize - 2         // Pseudo-handle for dlsym so search for any loaded symbol\n\tRTLD_LAZY    = 0x00000001             // Relocations are performed at an implementation-dependent time.\n\tRTLD_NOW     = 0x00000002             // Relocations are performed when the object is loaded.\n\tRTLD_LOCAL   = 0x00000000             // All symbols are not made available for relocation processing by other modules.\n\tRTLD_GLOBAL  = 0x00000100             // All symbols are available for relocation processing of other modules.\n)\n"
        },
        {
          "name": "dlfcn_linux.go",
          "type": "blob",
          "size": 0.662109375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build !android\n\npackage purego\n\n// Source for constants: https://codebrowser.dev/glibc/glibc/bits/dlfcn.h.html\n\nconst (\n\tRTLD_DEFAULT = 0x00000 // Pseudo-handle for dlsym so search for any loaded symbol\n\tRTLD_LAZY    = 0x00001 // Relocations are performed at an implementation-dependent time.\n\tRTLD_NOW     = 0x00002 // Relocations are performed when the object is loaded.\n\tRTLD_LOCAL   = 0x00000 // All symbols are not made available for relocation processing by other modules.\n\tRTLD_GLOBAL  = 0x00100 // All symbols are available for relocation processing of other modules.\n)\n"
        },
        {
          "name": "dlfcn_nocgo_freebsd.go",
          "type": "blob",
          "size": 0.349609375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build !cgo\n\npackage purego\n\n//go:cgo_import_dynamic purego_dlopen dlopen \"libc.so.7\"\n//go:cgo_import_dynamic purego_dlsym dlsym \"libc.so.7\"\n//go:cgo_import_dynamic purego_dlerror dlerror \"libc.so.7\"\n//go:cgo_import_dynamic purego_dlclose dlclose \"libc.so.7\"\n"
        },
        {
          "name": "dlfcn_nocgo_linux.go",
          "type": "blob",
          "size": 0.7314453125,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build !cgo && !faketime\n\npackage purego\n\n// if there is no Cgo we must link to each of the functions from dlfcn.h\n// then the functions are called inside dlfcn_stubs.s\n\n//go:cgo_import_dynamic purego_dlopen dlopen \"libdl.so.2\"\n//go:cgo_import_dynamic purego_dlsym dlsym \"libdl.so.2\"\n//go:cgo_import_dynamic purego_dlerror dlerror \"libdl.so.2\"\n//go:cgo_import_dynamic purego_dlclose dlclose \"libdl.so.2\"\n\n// on amd64 we don't need the following line - on 386 we do...\n// anyway - with those lines the output is better (but doesn't matter) - without it on amd64 we get multiple DT_NEEDED with \"libc.so.6\" etc\n\n//go:cgo_import_dynamic _ _ \"libdl.so.2\"\n"
        },
        {
          "name": "dlfcn_playground.go",
          "type": "blob",
          "size": 0.5859375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2024 The Ebitengine Authors\n\n//go:build faketime\n\npackage purego\n\nimport \"errors\"\n\nfunc Dlopen(path string, mode int) (uintptr, error) {\n\treturn 0, errors.New(\"Dlopen is not supported in the playground\")\n}\n\nfunc Dlsym(handle uintptr, name string) (uintptr, error) {\n\treturn 0, errors.New(\"Dlsym is not supported in the playground\")\n}\n\nfunc Dlclose(handle uintptr) error {\n\treturn errors.New(\"Dlclose is not supported in the playground\")\n}\n\nfunc loadSymbol(handle uintptr, name string) (uintptr, error) {\n\treturn Dlsym(handle, name)\n}\n"
        },
        {
          "name": "dlfcn_stubs.s",
          "type": "blob",
          "size": 0.619140625,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || !cgo && (freebsd || linux) && !faketime\n\n#include \"textflag.h\"\n\n// func dlopen(path *byte, mode int) (ret uintptr)\nTEXT dlopen(SB), NOSPLIT|NOFRAME, $0-0\n\tJMP purego_dlopen(SB)\n\tRET\n\n// func dlsym(handle uintptr, symbol *byte) (ret uintptr)\nTEXT dlsym(SB), NOSPLIT|NOFRAME, $0-0\n\tJMP purego_dlsym(SB)\n\tRET\n\n// func dlerror() (ret *byte)\nTEXT dlerror(SB), NOSPLIT|NOFRAME, $0-0\n\tJMP purego_dlerror(SB)\n\tRET\n\n// func dlclose(handle uintptr) (ret int)\nTEXT dlclose(SB), NOSPLIT|NOFRAME, $0-0\n\tJMP purego_dlclose(SB)\n\tRET\n"
        },
        {
          "name": "dlfcn_test.go",
          "type": "blob",
          "size": 2.5107421875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2023 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux\n\npackage purego_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"github.com/ebitengine/purego\"\n)\n\nfunc TestSimpleDlsym(t *testing.T) {\n\tif _, err := purego.Dlsym(purego.RTLD_DEFAULT, \"dlsym\"); err != nil {\n\t\tt.Errorf(\"Dlsym with RTLD_DEFAULT failed: %v\", err)\n\t}\n}\n\nfunc TestNestedDlopenCall(t *testing.T) {\n\tlibFileName := filepath.Join(t.TempDir(), \"libdlnested.so\")\n\tt.Logf(\"Build %v\", libFileName)\n\n\tif err := buildSharedLib(\"CXX\", libFileName, filepath.Join(\"testdata\", \"libdlnested\", \"nested_test.cpp\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(libFileName)\n\n\tlib, err := purego.Dlopen(libFileName, purego.RTLD_NOW|purego.RTLD_GLOBAL)\n\tif err != nil {\n\t\tt.Fatalf(\"Dlopen(%q) failed: %v\", libFileName, err)\n\t}\n\n\tpurego.Dlclose(lib)\n}\n\nfunc buildSharedLib(compilerEnv, libFile string, sources ...string) error {\n\tout, err := exec.Command(\"go\", \"env\", compilerEnv).Output()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"go env %s error: %w\", compilerEnv, err)\n\t}\n\n\tcompiler := strings.TrimSpace(string(out))\n\tif compiler == \"\" {\n\t\treturn errors.New(\"compiler not found\")\n\t}\n\n\tvar args []string\n\tif runtime.GOOS == \"freebsd\" {\n\t\targs = []string{\"-shared\", \"-Wall\", \"-Werror\", \"-fPIC\", \"-o\", libFile}\n\t} else {\n\t\targs = []string{\"-shared\", \"-Wall\", \"-Werror\", \"-o\", libFile}\n\t}\n\tif runtime.GOARCH == \"386\" {\n\t\targs = append(args, \"-m32\")\n\t}\n\t// macOS arm64 can run amd64 tests through Rossetta.\n\t// Build the shared library based on the GOARCH and not\n\t// the default behavior of the compiler.\n\tif runtime.GOOS == \"darwin\" {\n\t\tvar arch string\n\t\tswitch runtime.GOARCH {\n\t\tcase \"arm64\":\n\t\t\tarch = \"arm64\"\n\t\tcase \"amd64\":\n\t\t\tarch = \"x86_64\"\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown macOS architecture %s\", runtime.GOARCH)\n\t\t}\n\t\targs = append(args, \"-arch\", arch)\n\t}\n\tcmd := exec.Command(compiler, append(args, sources...)...)\n\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"compile lib: %w\\n%q\\n%s\", err, cmd, string(out))\n\t}\n\n\treturn nil\n}\n\nfunc TestSyscallN(t *testing.T) {\n\tvar dlsym uintptr\n\tvar err error\n\tif dlsym, err = purego.Dlsym(purego.RTLD_DEFAULT, \"dlsym\"); err != nil {\n\t\tt.Errorf(\"Dlsym with RTLD_DEFAULT failed: %v\", err)\n\t}\n\tr1, _, err2 := purego.SyscallN(dlsym, purego.RTLD_DEFAULT, uintptr(unsafe.Pointer(&[]byte(\"dlsym\\x00\")[0])))\n\tif dlsym != r1 {\n\t\tt.Fatalf(\"SyscallN didn't return the same result as purego.Dlsym: %d\", err2)\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "func.go",
          "type": "blob",
          "size": 15.6640625,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux || windows\n\npackage purego\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/ebitengine/purego/internal/strings\"\n)\n\nvar thePool = sync.Pool{New: func() any {\n\treturn new(syscall15Args)\n}}\n\n// RegisterLibFunc is a wrapper around RegisterFunc that uses the C function returned from Dlsym(handle, name).\n// It panics if it can't find the name symbol.\nfunc RegisterLibFunc(fptr any, handle uintptr, name string) {\n\tsym, err := loadSymbol(handle, name)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tRegisterFunc(fptr, sym)\n}\n\n// RegisterFunc takes a pointer to a Go function representing the calling convention of the C function.\n// fptr will be set to a function that when called will call the C function given by cfn with the\n// parameters passed in the correct registers and stack.\n//\n// A panic is produced if the type is not a function pointer or if the function returns more than 1 value.\n//\n// These conversions describe how a Go type in the fptr will be used to call\n// the C function. It is important to note that there is no way to verify that fptr\n// matches the C function. This also holds true for struct types where the padding\n// needs to be ensured to match that of C; RegisterFunc does not verify this.\n//\n// # Type Conversions (Go <=> C)\n//\n//\tstring <=> char*\n//\tbool <=> _Bool\n//\tuintptr <=> uintptr_t\n//\tuint <=> uint32_t or uint64_t\n//\tuint8 <=> uint8_t\n//\tuint16 <=> uint16_t\n//\tuint32 <=> uint32_t\n//\tuint64 <=> uint64_t\n//\tint <=> int32_t or int64_t\n//\tint8 <=> int8_t\n//\tint16 <=> int16_t\n//\tint32 <=> int32_t\n//\tint64 <=> int64_t\n//\tfloat32 <=> float\n//\tfloat64 <=> double\n//\tstruct <=> struct (WIP - darwin only)\n//\tfunc <=> C function\n//\tunsafe.Pointer, *T <=> void*\n//\t[]T => void*\n//\n// There is a special case when the last argument of fptr is a variadic interface (or []interface}\n// it will be expanded into a call to the C function as if it had the arguments in that slice.\n// This means that using arg ...any is like a cast to the function with the arguments inside arg.\n// This is not the same as C variadic.\n//\n// # Memory\n//\n// In general it is not possible for purego to guarantee the lifetimes of objects returned or received from\n// calling functions using RegisterFunc. For arguments to a C function it is important that the C function doesn't\n// hold onto a reference to Go memory. This is the same as the [Cgo rules].\n//\n// However, there are some special cases. When passing a string as an argument if the string does not end in a null\n// terminated byte (\\x00) then the string will be copied into memory maintained by purego. The memory is only valid for\n// that specific call. Therefore, if the C code keeps a reference to that string it may become invalid at some\n// undefined time. However, if the string does already contain a null-terminated byte then no copy is done.\n// It is then the responsibility of the caller to ensure the string stays alive as long as it's needed in C memory.\n// This can be done using runtime.KeepAlive or allocating the string in C memory using malloc. When a C function\n// returns a null-terminated pointer to char a Go string can be used. Purego will allocate a new string in Go memory\n// and copy the data over. This string will be garbage collected whenever Go decides it's no longer referenced.\n// This C created string will not be freed by purego. If the pointer to char is not null-terminated or must continue\n// to point to C memory (because it's a buffer for example) then use a pointer to byte and then convert that to a slice\n// using unsafe.Slice. Doing this means that it becomes the responsibility of the caller to care about the lifetime\n// of the pointer\n//\n// # Structs\n//\n// Purego can handle the most common structs that have fields of builtin types like int8, uint16, float32, etc. However,\n// it does not support aligning fields properly. It is therefore the responsibility of the caller to ensure\n// that all padding is added to the Go struct to match the C one. See `BoolStructFn` in struct_test.go for an example.\n//\n// # Example\n//\n// All functions below call this C function:\n//\n//\tchar *foo(char *str);\n//\n//\t// Let purego convert types\n//\tvar foo func(s string) string\n//\tgoString := foo(\"copied\")\n//\t// Go will garbage collect this string\n//\n//\t// Manually, handle allocations\n//\tvar foo2 func(b string) *byte\n//\tmustFree := foo2(\"not copied\\x00\")\n//\tdefer free(mustFree)\n//\n// [Cgo rules]: https://pkg.go.dev/cmd/cgo#hdr-Go_references_to_C\nfunc RegisterFunc(fptr any, cfn uintptr) {\n\tfn := reflect.ValueOf(fptr).Elem()\n\tty := fn.Type()\n\tif ty.Kind() != reflect.Func {\n\t\tpanic(\"purego: fptr must be a function pointer\")\n\t}\n\tif ty.NumOut() > 1 {\n\t\tpanic(\"purego: function can only return zero or one values\")\n\t}\n\tif cfn == 0 {\n\t\tpanic(\"purego: cfn is nil\")\n\t}\n\tif ty.NumOut() == 1 && (ty.Out(0).Kind() == reflect.Float32 || ty.Out(0).Kind() == reflect.Float64) &&\n\t\truntime.GOARCH != \"arm64\" && runtime.GOARCH != \"amd64\" {\n\t\tpanic(\"purego: float returns are not supported\")\n\t}\n\t{\n\t\t// this code checks how many registers and stack this function will use\n\t\t// to avoid crashing with too many arguments\n\t\tvar ints int\n\t\tvar floats int\n\t\tvar stack int\n\t\tfor i := 0; i < ty.NumIn(); i++ {\n\t\t\targ := ty.In(i)\n\t\t\tswitch arg.Kind() {\n\t\t\tcase reflect.Func:\n\t\t\t\t// This only does preliminary testing to ensure the CDecl argument\n\t\t\t\t// is the first argument. Full testing is done when the callback is actually\n\t\t\t\t// created in NewCallback.\n\t\t\t\tfor j := 0; j < arg.NumIn(); j++ {\n\t\t\t\t\tin := arg.In(j)\n\t\t\t\t\tif !in.AssignableTo(reflect.TypeOf(CDecl{})) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif j != 0 {\n\t\t\t\t\t\tpanic(\"purego: CDecl must be the first argument\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase reflect.String, reflect.Uintptr, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Ptr, reflect.UnsafePointer,\n\t\t\t\treflect.Slice, reflect.Bool:\n\t\t\t\tif ints < numOfIntegerRegisters() {\n\t\t\t\t\tints++\n\t\t\t\t} else {\n\t\t\t\t\tstack++\n\t\t\t\t}\n\t\t\tcase reflect.Float32, reflect.Float64:\n\t\t\t\tconst is32bit = unsafe.Sizeof(uintptr(0)) == 4\n\t\t\t\tif is32bit {\n\t\t\t\t\tpanic(\"purego: floats only supported on 64bit platforms\")\n\t\t\t\t}\n\t\t\t\tif floats < numOfFloats {\n\t\t\t\t\tfloats++\n\t\t\t\t} else {\n\t\t\t\t\tstack++\n\t\t\t\t}\n\t\t\tcase reflect.Struct:\n\t\t\t\tif runtime.GOOS != \"darwin\" || (runtime.GOARCH != \"amd64\" && runtime.GOARCH != \"arm64\") {\n\t\t\t\t\tpanic(\"purego: struct arguments are only supported on darwin amd64 & arm64\")\n\t\t\t\t}\n\t\t\t\tif arg.Size() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\taddInt := func(u uintptr) {\n\t\t\t\t\tints++\n\t\t\t\t}\n\t\t\t\taddFloat := func(u uintptr) {\n\t\t\t\t\tfloats++\n\t\t\t\t}\n\t\t\t\taddStack := func(u uintptr) {\n\t\t\t\t\tstack++\n\t\t\t\t}\n\t\t\t\t_ = addStruct(reflect.New(arg).Elem(), &ints, &floats, &stack, addInt, addFloat, addStack, nil)\n\t\t\tdefault:\n\t\t\t\tpanic(\"purego: unsupported kind \" + arg.Kind().String())\n\t\t\t}\n\t\t}\n\t\tif ty.NumOut() == 1 && ty.Out(0).Kind() == reflect.Struct {\n\t\t\tif runtime.GOOS != \"darwin\" {\n\t\t\t\tpanic(\"purego: struct return values only supported on darwin arm64 & amd64\")\n\t\t\t}\n\t\t\toutType := ty.Out(0)\n\t\t\tcheckStructFieldsSupported(outType)\n\t\t\tif runtime.GOARCH == \"amd64\" && outType.Size() > maxRegAllocStructSize {\n\t\t\t\t// on amd64 if struct is bigger than 16 bytes allocate the return struct\n\t\t\t\t// and pass it in as a hidden first argument.\n\t\t\t\tints++\n\t\t\t}\n\t\t}\n\t\tsizeOfStack := maxArgs - numOfIntegerRegisters()\n\t\tif stack > sizeOfStack {\n\t\t\tpanic(\"purego: too many arguments\")\n\t\t}\n\t}\n\tv := reflect.MakeFunc(ty, func(args []reflect.Value) (results []reflect.Value) {\n\t\tvar sysargs [maxArgs]uintptr\n\t\tstack := sysargs[numOfIntegerRegisters():]\n\t\tvar floats [numOfFloats]uintptr\n\t\tvar numInts int\n\t\tvar numFloats int\n\t\tvar numStack int\n\t\tvar addStack, addInt, addFloat func(x uintptr)\n\t\tif runtime.GOARCH == \"arm64\" || runtime.GOOS != \"windows\" {\n\t\t\t// Windows arm64 uses the same calling convention as macOS and Linux\n\t\t\taddStack = func(x uintptr) {\n\t\t\t\tstack[numStack] = x\n\t\t\t\tnumStack++\n\t\t\t}\n\t\t\taddInt = func(x uintptr) {\n\t\t\t\tif numInts >= numOfIntegerRegisters() {\n\t\t\t\t\taddStack(x)\n\t\t\t\t} else {\n\t\t\t\t\tsysargs[numInts] = x\n\t\t\t\t\tnumInts++\n\t\t\t\t}\n\t\t\t}\n\t\t\taddFloat = func(x uintptr) {\n\t\t\t\tif numFloats < len(floats) {\n\t\t\t\t\tfloats[numFloats] = x\n\t\t\t\t\tnumFloats++\n\t\t\t\t} else {\n\t\t\t\t\taddStack(x)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// On Windows amd64 the arguments are passed in the numbered registered.\n\t\t\t// So the first int is in the first integer register and the first float\n\t\t\t// is in the second floating register if there is already a first int.\n\t\t\t// This is in contrast to how macOS and Linux pass arguments which\n\t\t\t// tries to use as many registers as possible in the calling convention.\n\t\t\taddStack = func(x uintptr) {\n\t\t\t\tsysargs[numStack] = x\n\t\t\t\tnumStack++\n\t\t\t}\n\t\t\taddInt = addStack\n\t\t\taddFloat = addStack\n\t\t}\n\n\t\tvar keepAlive []any\n\t\tdefer func() {\n\t\t\truntime.KeepAlive(keepAlive)\n\t\t\truntime.KeepAlive(args)\n\t\t}()\n\n\t\tvar arm64_r8 uintptr\n\t\tif ty.NumOut() == 1 && ty.Out(0).Kind() == reflect.Struct {\n\t\t\toutType := ty.Out(0)\n\t\t\tif runtime.GOARCH == \"amd64\" && outType.Size() > maxRegAllocStructSize {\n\t\t\t\tval := reflect.New(outType)\n\t\t\t\tkeepAlive = append(keepAlive, val)\n\t\t\t\taddInt(val.Pointer())\n\t\t\t} else if runtime.GOARCH == \"arm64\" && outType.Size() > maxRegAllocStructSize {\n\t\t\t\tisAllFloats, numFields := isAllSameFloat(outType)\n\t\t\t\tif !isAllFloats || numFields > 4 {\n\t\t\t\t\tval := reflect.New(outType)\n\t\t\t\t\tkeepAlive = append(keepAlive, val)\n\t\t\t\t\tarm64_r8 = val.Pointer()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor i, v := range args {\n\t\t\tif variadic, ok := args[i].Interface().([]any); ok {\n\t\t\t\tif i != len(args)-1 {\n\t\t\t\t\tpanic(\"purego: can only expand last parameter\")\n\t\t\t\t}\n\t\t\t\tfor _, x := range variadic {\n\t\t\t\t\tkeepAlive = addValue(reflect.ValueOf(x), keepAlive, addInt, addFloat, addStack, &numInts, &numFloats, &numStack)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tkeepAlive = addValue(v, keepAlive, addInt, addFloat, addStack, &numInts, &numFloats, &numStack)\n\t\t}\n\n\t\tsyscall := thePool.Get().(*syscall15Args)\n\t\tdefer thePool.Put(syscall)\n\n\t\tif runtime.GOARCH == \"arm64\" || runtime.GOOS != \"windows\" {\n\t\t\t// Use the normal arm64 calling convention even on Windows\n\t\t\t*syscall = syscall15Args{\n\t\t\t\tcfn,\n\t\t\t\tsysargs[0], sysargs[1], sysargs[2], sysargs[3], sysargs[4], sysargs[5],\n\t\t\t\tsysargs[6], sysargs[7], sysargs[8], sysargs[9], sysargs[10], sysargs[11],\n\t\t\t\tsysargs[12], sysargs[13], sysargs[14],\n\t\t\t\tfloats[0], floats[1], floats[2], floats[3], floats[4], floats[5], floats[6], floats[7],\n\t\t\t\tarm64_r8,\n\t\t\t}\n\t\t\truntime_cgocall(syscall15XABI0, unsafe.Pointer(syscall))\n\t\t} else {\n\t\t\t*syscall = syscall15Args{}\n\t\t\t// This is a fallback for Windows amd64, 386, and arm. Note this may not support floats\n\t\t\tsyscall.a1, syscall.a2, _ = syscall_syscall15X(cfn, sysargs[0], sysargs[1], sysargs[2], sysargs[3], sysargs[4],\n\t\t\t\tsysargs[5], sysargs[6], sysargs[7], sysargs[8], sysargs[9], sysargs[10], sysargs[11],\n\t\t\t\tsysargs[12], sysargs[13], sysargs[14])\n\t\t\tsyscall.f1 = syscall.a2 // on amd64 a2 stores the float return. On 32bit platforms floats aren't support\n\t\t}\n\t\tif ty.NumOut() == 0 {\n\t\t\treturn nil\n\t\t}\n\t\toutType := ty.Out(0)\n\t\tv := reflect.New(outType).Elem()\n\t\tswitch outType.Kind() {\n\t\tcase reflect.Uintptr, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\tv.SetUint(uint64(syscall.a1))\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\tv.SetInt(int64(syscall.a1))\n\t\tcase reflect.Bool:\n\t\t\tv.SetBool(byte(syscall.a1) != 0)\n\t\tcase reflect.UnsafePointer:\n\t\t\t// We take the address and then dereference it to trick go vet from creating a possible miss-use of unsafe.Pointer\n\t\t\tv.SetPointer(*(*unsafe.Pointer)(unsafe.Pointer(&syscall.a1)))\n\t\tcase reflect.Ptr:\n\t\t\tv = reflect.NewAt(outType, unsafe.Pointer(&syscall.a1)).Elem()\n\t\tcase reflect.Func:\n\t\t\t// wrap this C function in a nicely typed Go function\n\t\t\tv = reflect.New(outType)\n\t\t\tRegisterFunc(v.Interface(), syscall.a1)\n\t\tcase reflect.String:\n\t\t\tv.SetString(strings.GoString(syscall.a1))\n\t\tcase reflect.Float32:\n\t\t\t// NOTE: syscall.r2 is only the floating return value on 64bit platforms.\n\t\t\t// On 32bit platforms syscall.r2 is the upper part of a 64bit return.\n\t\t\tv.SetFloat(float64(math.Float32frombits(uint32(syscall.f1))))\n\t\tcase reflect.Float64:\n\t\t\t// NOTE: syscall.r2 is only the floating return value on 64bit platforms.\n\t\t\t// On 32bit platforms syscall.r2 is the upper part of a 64bit return.\n\t\t\tv.SetFloat(math.Float64frombits(uint64(syscall.f1)))\n\t\tcase reflect.Struct:\n\t\t\tv = getStruct(outType, *syscall)\n\t\tdefault:\n\t\t\tpanic(\"purego: unsupported return kind: \" + outType.Kind().String())\n\t\t}\n\t\tif len(args) > 0 {\n\t\t\t// reuse args slice instead of allocating one when possible\n\t\t\targs[0] = v\n\t\t\treturn args[:1]\n\t\t} else {\n\t\t\treturn []reflect.Value{v}\n\t\t}\n\t})\n\tfn.Set(v)\n}\n\nfunc addValue(v reflect.Value, keepAlive []any, addInt func(x uintptr), addFloat func(x uintptr), addStack func(x uintptr), numInts *int, numFloats *int, numStack *int) []any {\n\tswitch v.Kind() {\n\tcase reflect.String:\n\t\tptr := strings.CString(v.String())\n\t\tkeepAlive = append(keepAlive, ptr)\n\t\taddInt(uintptr(unsafe.Pointer(ptr)))\n\tcase reflect.Uintptr, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\taddInt(uintptr(v.Uint()))\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\taddInt(uintptr(v.Int()))\n\tcase reflect.Ptr, reflect.UnsafePointer, reflect.Slice:\n\t\t// There is no need to keepAlive this pointer separately because it is kept alive in the args variable\n\t\taddInt(v.Pointer())\n\tcase reflect.Func:\n\t\taddInt(NewCallback(v.Interface()))\n\tcase reflect.Bool:\n\t\tif v.Bool() {\n\t\t\taddInt(1)\n\t\t} else {\n\t\t\taddInt(0)\n\t\t}\n\tcase reflect.Float32:\n\t\taddFloat(uintptr(math.Float32bits(float32(v.Float()))))\n\tcase reflect.Float64:\n\t\taddFloat(uintptr(math.Float64bits(v.Float())))\n\tcase reflect.Struct:\n\t\tkeepAlive = addStruct(v, numInts, numFloats, numStack, addInt, addFloat, addStack, keepAlive)\n\tdefault:\n\t\tpanic(\"purego: unsupported kind: \" + v.Kind().String())\n\t}\n\treturn keepAlive\n}\n\n// maxRegAllocStructSize is the biggest a struct can be while still fitting in registers.\n// if it is bigger than this than enough space must be allocated on the heap and then passed into\n// the function as the first parameter on amd64 or in R8 on arm64.\n//\n// If you change this make sure to update it in objc_runtime_darwin.go\nconst maxRegAllocStructSize = 16\n\nfunc isAllSameFloat(ty reflect.Type) (allFloats bool, numFields int) {\n\tallFloats = true\n\troot := ty.Field(0).Type\n\tfor root.Kind() == reflect.Struct {\n\t\troot = root.Field(0).Type\n\t}\n\tfirst := root.Kind()\n\tif first != reflect.Float32 && first != reflect.Float64 {\n\t\tallFloats = false\n\t}\n\tfor i := 0; i < ty.NumField(); i++ {\n\t\tf := ty.Field(i).Type\n\t\tif f.Kind() == reflect.Struct {\n\t\t\tvar structNumFields int\n\t\t\tallFloats, structNumFields = isAllSameFloat(f)\n\t\t\tnumFields += structNumFields\n\t\t\tcontinue\n\t\t}\n\t\tnumFields++\n\t\tif f.Kind() != first {\n\t\t\tallFloats = false\n\t\t}\n\t}\n\treturn allFloats, numFields\n}\n\nfunc checkStructFieldsSupported(ty reflect.Type) {\n\tfor i := 0; i < ty.NumField(); i++ {\n\t\tf := ty.Field(i).Type\n\t\tif f.Kind() == reflect.Array {\n\t\t\tf = f.Elem()\n\t\t} else if f.Kind() == reflect.Struct {\n\t\t\tcheckStructFieldsSupported(f)\n\t\t\tcontinue\n\t\t}\n\t\tswitch f.Kind() {\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\treflect.Uintptr, reflect.Ptr, reflect.UnsafePointer, reflect.Float64, reflect.Float32:\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"purego: struct field type %s is not supported\", f))\n\t\t}\n\t}\n}\n\nfunc roundUpTo8(val uintptr) uintptr {\n\treturn (val + 7) &^ 7\n}\n\nfunc numOfIntegerRegisters() int {\n\tswitch runtime.GOARCH {\n\tcase \"arm64\":\n\t\treturn 8\n\tcase \"amd64\":\n\t\treturn 6\n\tdefault:\n\t\t// since this platform isn't supported and can therefore only access\n\t\t// integer registers it is fine to return the maxArgs\n\t\treturn maxArgs\n\t}\n}\n"
        },
        {
          "name": "func_test.go",
          "type": "blob",
          "size": 3.2109375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2023 The Ebitengine Authors\n\npackage purego_test\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"github.com/ebitengine/purego\"\n\t\"github.com/ebitengine/purego/internal/load\"\n)\n\nfunc getSystemLibrary() (string, error) {\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\treturn \"/usr/lib/libSystem.B.dylib\", nil\n\tcase \"linux\":\n\t\treturn \"libc.so.6\", nil\n\tcase \"freebsd\":\n\t\treturn \"libc.so.7\", nil\n\tcase \"windows\":\n\t\treturn \"ucrtbase.dll\", nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"GOOS=%s is not supported\", runtime.GOOS)\n\t}\n}\n\nfunc TestRegisterFunc(t *testing.T) {\n\tlibrary, err := getSystemLibrary()\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get system library: %s\", err)\n\t}\n\tlibc, err := load.OpenLibrary(library)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to dlopen: %s\", err)\n\t}\n\tvar puts func(string)\n\tpurego.RegisterLibFunc(&puts, libc, \"puts\")\n\tputs(\"Calling C from from Go without Cgo!\")\n}\n\nfunc Test_qsort(t *testing.T) {\n\tif runtime.GOARCH != \"arm64\" && runtime.GOARCH != \"amd64\" {\n\t\tt.Skip(\"Platform doesn't support Floats\")\n\t\treturn\n\t}\n\tlibrary, err := getSystemLibrary()\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get system library: %s\", err)\n\t}\n\tlibc, err := load.OpenLibrary(library)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to dlopen: %s\", err)\n\t}\n\n\tdata := []int{88, 56, 100, 2, 25}\n\tsorted := []int{2, 25, 56, 88, 100}\n\tcompare := func(_ purego.CDecl, a, b *int) int {\n\t\treturn *a - *b\n\t}\n\tvar qsort func(data []int, nitms uintptr, size uintptr, compar func(_ purego.CDecl, a, b *int) int)\n\tpurego.RegisterLibFunc(&qsort, libc, \"qsort\")\n\tqsort(data, uintptr(len(data)), unsafe.Sizeof(int(0)), compare)\n\tfor i := range data {\n\t\tif data[i] != sorted[i] {\n\t\t\tt.Errorf(\"got %d wanted %d at %d\", data[i], sorted[i], i)\n\t\t}\n\t}\n}\n\nfunc TestRegisterFunc_Floats(t *testing.T) {\n\tif runtime.GOARCH != \"arm64\" && runtime.GOARCH != \"amd64\" {\n\t\tt.Skip(\"Platform doesn't support Floats\")\n\t\treturn\n\t}\n\tlibrary, err := getSystemLibrary()\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't get system library: %s\", err)\n\t}\n\tlibc, err := load.OpenLibrary(library)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to dlopen: %s\", err)\n\t}\n\t{\n\t\tvar strtof func(arg string) float32\n\t\tpurego.RegisterLibFunc(&strtof, libc, \"strtof\")\n\t\tconst (\n\t\t\targ = \"2\"\n\t\t)\n\t\tgot := strtof(arg)\n\t\texpected := float32(2)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"strtof failed. got %f but wanted %f\", got, expected)\n\t\t}\n\t}\n\t{\n\t\tvar strtod func(arg string, ptr **byte) float64\n\t\tpurego.RegisterLibFunc(&strtod, libc, \"strtod\")\n\t\tconst (\n\t\t\targ = \"1\"\n\t\t)\n\t\tgot := strtod(arg, nil)\n\t\texpected := float64(1)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"strtod failed. got %f but wanted %f\", got, expected)\n\t\t}\n\t}\n}\n\nfunc TestRegisterLibFunc_Bool(t *testing.T) {\n\tif runtime.GOARCH != \"arm64\" && runtime.GOARCH != \"amd64\" {\n\t\tt.Skip(\"Platform doesn't support callbacks\")\n\t\treturn\n\t}\n\t// this callback recreates the state where the return register\n\t// contains other information but the least significant byte is false\n\tcbFalse := purego.NewCallback(func() uintptr {\n\t\tx := uint64(0x7F5948AE9A00)\n\t\treturn uintptr(x)\n\t})\n\tvar runFalse func() bool\n\tpurego.RegisterFunc(&runFalse, cbFalse)\n\texpected := false\n\tif got := runFalse(); got != expected {\n\t\tt.Errorf(\"runFalse failed. got %t but wanted %t\", got, expected)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0439453125,
          "content": "module github.com/ebitengine/purego\n\ngo 1.18\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "go_runtime.go",
          "type": "blob",
          "size": 0.30859375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux || windows\n\npackage purego\n\nimport (\n\t\"unsafe\"\n)\n\n//go:linkname runtime_cgocall runtime.cgocall\nfunc runtime_cgocall(fn uintptr, arg unsafe.Pointer) int32 // from runtime/sys_libc.go\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "is_ios.go",
          "type": "blob",
          "size": 0.3720703125,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build !cgo\n\npackage purego\n\n// if you are getting this error it means that you have\n// CGO_ENABLED=0 while trying to build for ios.\n// purego does not support this mode yet.\n// the fix is to set CGO_ENABLED=1 which will require\n// a C compiler.\nvar _ = _PUREGO_REQUIRES_CGO_ON_IOS\n"
        },
        {
          "name": "nocgo.go",
          "type": "blob",
          "size": 1.2451171875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build !cgo && (darwin || freebsd || linux)\n\npackage purego\n\n// if CGO_ENABLED=0 import fakecgo to setup the Cgo runtime correctly.\n// This is required since some frameworks need TLS setup the C way which Go doesn't do.\n// We currently don't support ios in fakecgo mode so force Cgo or fail\n//\n// The way that the Cgo runtime (runtime/cgo) works is by setting some variables found\n// in runtime with non-null GCC compiled functions. The variables that are replaced are\n// var (\n//\t\tiscgo             bool \t\t\t\t\t\t\t// in runtime/cgo.go\n//\t\t_cgo_init         unsafe.Pointer \t\t\t\t// in runtime/cgo.go\n//\t\t_cgo_thread_start unsafe.Pointer\t\t\t\t// in runtime/cgo.go\n//\t\t_cgo_notify_runtime_init_done unsafe.Pointer \t// in runtime/cgo.go\n//\t\t_cgo_setenv unsafe.Pointer  \t\t\t\t\t// in runtime/env_posix.go\n//\t\t_cgo_unsetenv unsafe.Pointer\t\t\t\t\t// in runtime/env_posix.go\n// )\n// importing fakecgo will set these (using //go:linkname) with functions written\n// entirely in Go (except for some assembly trampolines to change GCC ABI to Go ABI).\n// Doing so makes it possible to build applications that call into C without CGO_ENABLED=1.\nimport _ \"github.com/ebitengine/purego/internal/fakecgo\"\n"
        },
        {
          "name": "objc",
          "type": "tree",
          "content": null
        },
        {
          "name": "struct_amd64.go",
          "type": "blob",
          "size": 6.5693359375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2024 The Ebitengine Authors\n\npackage purego\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nfunc getStruct(outType reflect.Type, syscall syscall15Args) (v reflect.Value) {\n\toutSize := outType.Size()\n\tswitch {\n\tcase outSize == 0:\n\t\treturn reflect.New(outType).Elem()\n\tcase outSize <= 8:\n\t\tif isAllFloats(outType) {\n\t\t\t// 2 float32s or 1 float64s are return in the float register\n\t\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a uintptr }{syscall.f1})).Elem()\n\t\t}\n\t\t// up to 8 bytes is returned in RAX\n\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a uintptr }{syscall.a1})).Elem()\n\tcase outSize <= 16:\n\t\tr1, r2 := syscall.a1, syscall.a2\n\t\tif isAllFloats(outType) {\n\t\t\tr1 = syscall.f1\n\t\t\tr2 = syscall.f2\n\t\t} else {\n\t\t\t// check first 8 bytes if it's floats\n\t\t\thasFirstFloat := false\n\t\t\tf1 := outType.Field(0).Type\n\t\t\tif f1.Kind() == reflect.Float64 || f1.Kind() == reflect.Float32 && outType.Field(1).Type.Kind() == reflect.Float32 {\n\t\t\t\tr1 = syscall.f1\n\t\t\t\thasFirstFloat = true\n\t\t\t}\n\n\t\t\t// find index of the field that starts the second 8 bytes\n\t\t\tvar i int\n\t\t\tfor i = 0; i < outType.NumField(); i++ {\n\t\t\t\tif outType.Field(i).Offset == 8 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check last 8 bytes if they are floats\n\t\t\tf1 = outType.Field(i).Type\n\t\t\tif f1.Kind() == reflect.Float64 || f1.Kind() == reflect.Float32 && i+1 == outType.NumField() {\n\t\t\t\tr2 = syscall.f1\n\t\t\t} else if hasFirstFloat {\n\t\t\t\t// if the first field was a float then that means the second integer field\n\t\t\t\t// comes from the first integer register\n\t\t\t\tr2 = syscall.a1\n\t\t\t}\n\t\t}\n\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a, b uintptr }{r1, r2})).Elem()\n\tdefault:\n\t\t// create struct from the Go pointer created above\n\t\t// weird pointer dereference to circumvent go vet\n\t\treturn reflect.NewAt(outType, *(*unsafe.Pointer)(unsafe.Pointer(&syscall.a1))).Elem()\n\t}\n}\n\nfunc isAllFloats(ty reflect.Type) bool {\n\tfor i := 0; i < ty.NumField(); i++ {\n\t\tf := ty.Field(i)\n\t\tswitch f.Type.Kind() {\n\t\tcase reflect.Float64, reflect.Float32:\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf\n// https://gitlab.com/x86-psABIs/x86-64-ABI\n// Class determines where the 8 byte value goes.\n// Higher value classes win over lower value classes\nconst (\n\t_NO_CLASS = 0b0000\n\t_SSE      = 0b0001\n\t_X87      = 0b0011 // long double not used in Go\n\t_INTEGER  = 0b0111\n\t_MEMORY   = 0b1111\n)\n\nfunc addStruct(v reflect.Value, numInts, numFloats, numStack *int, addInt, addFloat, addStack func(uintptr), keepAlive []any) []any {\n\tif v.Type().Size() == 0 {\n\t\treturn keepAlive\n\t}\n\n\t// if greater than 64 bytes place on stack\n\tif v.Type().Size() > 8*8 {\n\t\tplaceStack(v, addStack)\n\t\treturn keepAlive\n\t}\n\tvar (\n\t\tsavedNumFloats = *numFloats\n\t\tsavedNumInts   = *numInts\n\t\tsavedNumStack  = *numStack\n\t)\n\tplaceOnStack := postMerger(v.Type()) || !tryPlaceRegister(v, addFloat, addInt)\n\tif placeOnStack {\n\t\t// reset any values placed in registers\n\t\t*numFloats = savedNumFloats\n\t\t*numInts = savedNumInts\n\t\t*numStack = savedNumStack\n\t\tplaceStack(v, addStack)\n\t}\n\treturn keepAlive\n}\n\nfunc postMerger(t reflect.Type) (passInMemory bool) {\n\t// (c) If the size of the aggregate exceeds two eightbytes and the first eight- byte isnt SSE or any other\n\t// eightbyte isnt SSEUP, the whole argument is passed in memory.\n\tif t.Kind() != reflect.Struct {\n\t\treturn false\n\t}\n\tif t.Size() <= 2*8 {\n\t\treturn false\n\t}\n\treturn true // Go does not have an SSE/SSEUP type so this is always true\n}\n\nfunc tryPlaceRegister(v reflect.Value, addFloat func(uintptr), addInt func(uintptr)) (ok bool) {\n\tok = true\n\tvar val uint64\n\tvar shift byte // # of bits to shift\n\tvar flushed bool\n\tclass := _NO_CLASS\n\tflushIfNeeded := func() {\n\t\tif flushed {\n\t\t\treturn\n\t\t}\n\t\tflushed = true\n\t\tif class == _SSE {\n\t\t\taddFloat(uintptr(val))\n\t\t} else {\n\t\t\taddInt(uintptr(val))\n\t\t}\n\t\tval = 0\n\t\tshift = 0\n\t\tclass = _NO_CLASS\n\t}\n\tvar place func(v reflect.Value)\n\tplace = func(v reflect.Value) {\n\t\tvar numFields int\n\t\tif v.Kind() == reflect.Struct {\n\t\t\tnumFields = v.Type().NumField()\n\t\t} else {\n\t\t\tnumFields = v.Type().Len()\n\t\t}\n\n\t\tfor i := 0; i < numFields; i++ {\n\t\t\tflushed = false\n\t\t\tvar f reflect.Value\n\t\t\tif v.Kind() == reflect.Struct {\n\t\t\t\tf = v.Field(i)\n\t\t\t} else {\n\t\t\t\tf = v.Index(i)\n\t\t\t}\n\t\t\tswitch f.Kind() {\n\t\t\tcase reflect.Struct:\n\t\t\t\tplace(f)\n\t\t\tcase reflect.Bool:\n\t\t\t\tif f.Bool() {\n\t\t\t\t\tval |= 1\n\t\t\t\t}\n\t\t\t\tshift += 8\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Pointer:\n\t\t\t\tok = false\n\t\t\t\treturn\n\t\t\tcase reflect.Int8:\n\t\t\t\tval |= uint64(f.Int()&0xFF) << shift\n\t\t\t\tshift += 8\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Int16:\n\t\t\t\tval |= uint64(f.Int()&0xFFFF) << shift\n\t\t\t\tshift += 16\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Int32:\n\t\t\t\tval |= uint64(f.Int()&0xFFFF_FFFF) << shift\n\t\t\t\tshift += 32\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Int64, reflect.Int:\n\t\t\t\tval = uint64(f.Int())\n\t\t\t\tshift = 64\n\t\t\t\tclass = _INTEGER\n\t\t\tcase reflect.Uint8:\n\t\t\t\tval |= f.Uint() << shift\n\t\t\t\tshift += 8\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Uint16:\n\t\t\t\tval |= f.Uint() << shift\n\t\t\t\tshift += 16\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Uint32:\n\t\t\t\tval |= f.Uint() << shift\n\t\t\t\tshift += 32\n\t\t\t\tclass |= _INTEGER\n\t\t\tcase reflect.Uint64, reflect.Uint:\n\t\t\t\tval = f.Uint()\n\t\t\t\tshift = 64\n\t\t\t\tclass = _INTEGER\n\t\t\tcase reflect.Float32:\n\t\t\t\tval |= uint64(math.Float32bits(float32(f.Float()))) << shift\n\t\t\t\tshift += 32\n\t\t\t\tclass |= _SSE\n\t\t\tcase reflect.Float64:\n\t\t\t\tif v.Type().Size() > 16 {\n\t\t\t\t\tok = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tval = uint64(math.Float64bits(f.Float()))\n\t\t\t\tshift = 64\n\t\t\t\tclass = _SSE\n\t\t\tcase reflect.Array:\n\t\t\t\tplace(f)\n\t\t\tdefault:\n\t\t\t\tpanic(\"purego: unsupported kind \" + f.Kind().String())\n\t\t\t}\n\n\t\t\tif shift == 64 {\n\t\t\t\tflushIfNeeded()\n\t\t\t} else if shift > 64 {\n\t\t\t\t// Should never happen, but may if we forget to reset shift after flush (or forget to flush),\n\t\t\t\t// better fall apart here, than corrupt arguments.\n\t\t\t\tpanic(\"purego: tryPlaceRegisters shift > 64\")\n\t\t\t}\n\t\t}\n\t}\n\n\tplace(v)\n\tflushIfNeeded()\n\treturn ok\n}\n\nfunc placeStack(v reflect.Value, addStack func(uintptr)) {\n\tfor i := 0; i < v.Type().NumField(); i++ {\n\t\tf := v.Field(i)\n\t\tswitch f.Kind() {\n\t\tcase reflect.Pointer:\n\t\t\taddStack(f.Pointer())\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\taddStack(uintptr(f.Int()))\n\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\taddStack(uintptr(f.Uint()))\n\t\tcase reflect.Float32:\n\t\t\taddStack(uintptr(math.Float32bits(float32(f.Float()))))\n\t\tcase reflect.Float64:\n\t\t\taddStack(uintptr(math.Float64bits(f.Float())))\n\t\tcase reflect.Struct:\n\t\t\tplaceStack(f, addStack)\n\t\tdefault:\n\t\t\tpanic(\"purego: unsupported kind \" + f.Kind().String())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "struct_arm64.go",
          "type": "blob",
          "size": 7.40234375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2024 The Ebitengine Authors\n\npackage purego\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nfunc getStruct(outType reflect.Type, syscall syscall15Args) (v reflect.Value) {\n\toutSize := outType.Size()\n\tswitch {\n\tcase outSize == 0:\n\t\treturn reflect.New(outType).Elem()\n\tcase outSize <= 8:\n\t\tr1 := syscall.a1\n\t\tif isAllFloats, numFields := isAllSameFloat(outType); isAllFloats {\n\t\t\tr1 = syscall.f1\n\t\t\tif numFields == 2 {\n\t\t\t\tr1 = syscall.f2<<32 | syscall.f1\n\t\t\t}\n\t\t}\n\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a uintptr }{r1})).Elem()\n\tcase outSize <= 16:\n\t\tr1, r2 := syscall.a1, syscall.a2\n\t\tif isAllFloats, numFields := isAllSameFloat(outType); isAllFloats {\n\t\t\tswitch numFields {\n\t\t\tcase 4:\n\t\t\t\tr1 = syscall.f2<<32 | syscall.f1\n\t\t\t\tr2 = syscall.f4<<32 | syscall.f3\n\t\t\tcase 3:\n\t\t\t\tr1 = syscall.f2<<32 | syscall.f1\n\t\t\t\tr2 = syscall.f3\n\t\t\tcase 2:\n\t\t\t\tr1 = syscall.f1\n\t\t\t\tr2 = syscall.f2\n\t\t\tdefault:\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t}\n\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a, b uintptr }{r1, r2})).Elem()\n\tdefault:\n\t\tif isAllFloats, numFields := isAllSameFloat(outType); isAllFloats && numFields <= 4 {\n\t\t\tswitch numFields {\n\t\t\tcase 4:\n\t\t\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a, b, c, d uintptr }{syscall.f1, syscall.f2, syscall.f3, syscall.f4})).Elem()\n\t\t\tcase 3:\n\t\t\t\treturn reflect.NewAt(outType, unsafe.Pointer(&struct{ a, b, c uintptr }{syscall.f1, syscall.f2, syscall.f3})).Elem()\n\t\t\tdefault:\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t}\n\t\t// create struct from the Go pointer created in arm64_r8\n\t\t// weird pointer dereference to circumvent go vet\n\t\treturn reflect.NewAt(outType, *(*unsafe.Pointer)(unsafe.Pointer(&syscall.arm64_r8))).Elem()\n\t}\n}\n\n// https://github.com/ARM-software/abi-aa/blob/main/sysvabi64/sysvabi64.rst\nconst (\n\t_NO_CLASS = 0b00\n\t_FLOAT    = 0b01\n\t_INT      = 0b11\n)\n\nfunc addStruct(v reflect.Value, numInts, numFloats, numStack *int, addInt, addFloat, addStack func(uintptr), keepAlive []any) []any {\n\tif v.Type().Size() == 0 {\n\t\treturn keepAlive\n\t}\n\n\tif hva, hfa, size := isHVA(v.Type()), isHFA(v.Type()), v.Type().Size(); hva || hfa || size <= 16 {\n\t\t// if this doesn't fit entirely in registers then\n\t\t// each element goes onto the stack\n\t\tif hfa && *numFloats+v.NumField() > numOfFloats {\n\t\t\t*numFloats = numOfFloats\n\t\t} else if hva && *numInts+v.NumField() > numOfIntegerRegisters() {\n\t\t\t*numInts = numOfIntegerRegisters()\n\t\t}\n\n\t\tplaceRegisters(v, addFloat, addInt)\n\t} else {\n\t\tkeepAlive = placeStack(v, keepAlive, addInt)\n\t}\n\treturn keepAlive // the struct was allocated so don't panic\n}\n\nfunc placeRegisters(v reflect.Value, addFloat func(uintptr), addInt func(uintptr)) {\n\tvar val uint64\n\tvar shift byte\n\tvar flushed bool\n\tclass := _NO_CLASS\n\tvar place func(v reflect.Value)\n\tplace = func(v reflect.Value) {\n\t\tvar numFields int\n\t\tif v.Kind() == reflect.Struct {\n\t\t\tnumFields = v.Type().NumField()\n\t\t} else {\n\t\t\tnumFields = v.Type().Len()\n\t\t}\n\t\tfor k := 0; k < numFields; k++ {\n\t\t\tflushed = false\n\t\t\tvar f reflect.Value\n\t\t\tif v.Kind() == reflect.Struct {\n\t\t\t\tf = v.Field(k)\n\t\t\t} else {\n\t\t\t\tf = v.Index(k)\n\t\t\t}\n\t\t\tif shift >= 64 {\n\t\t\t\tshift = 0\n\t\t\t\tflushed = true\n\t\t\t\tif class == _FLOAT {\n\t\t\t\t\taddFloat(uintptr(val))\n\t\t\t\t} else {\n\t\t\t\t\taddInt(uintptr(val))\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch f.Type().Kind() {\n\t\t\tcase reflect.Struct:\n\t\t\t\tplace(f)\n\t\t\tcase reflect.Bool:\n\t\t\t\tif f.Bool() {\n\t\t\t\t\tval |= 1\n\t\t\t\t}\n\t\t\t\tshift += 8\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Uint8:\n\t\t\t\tval |= f.Uint() << shift\n\t\t\t\tshift += 8\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Uint16:\n\t\t\t\tval |= f.Uint() << shift\n\t\t\t\tshift += 16\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Uint32:\n\t\t\t\tval |= f.Uint() << shift\n\t\t\t\tshift += 32\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Uint64:\n\t\t\t\taddInt(uintptr(f.Uint()))\n\t\t\t\tshift = 0\n\t\t\t\tflushed = true\n\t\t\tcase reflect.Int8:\n\t\t\t\tval |= uint64(f.Int()&0xFF) << shift\n\t\t\t\tshift += 8\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Int16:\n\t\t\t\tval |= uint64(f.Int()&0xFFFF) << shift\n\t\t\t\tshift += 16\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Int32:\n\t\t\t\tval |= uint64(f.Int()&0xFFFF_FFFF) << shift\n\t\t\t\tshift += 32\n\t\t\t\tclass |= _INT\n\t\t\tcase reflect.Int64:\n\t\t\t\taddInt(uintptr(f.Int()))\n\t\t\t\tshift = 0\n\t\t\t\tflushed = true\n\t\t\tcase reflect.Float32:\n\t\t\t\tif class == _FLOAT {\n\t\t\t\t\taddFloat(uintptr(val))\n\t\t\t\t\tval = 0\n\t\t\t\t\tshift = 0\n\t\t\t\t}\n\t\t\t\tval |= uint64(math.Float32bits(float32(f.Float()))) << shift\n\t\t\t\tshift += 32\n\t\t\t\tclass |= _FLOAT\n\t\t\tcase reflect.Float64:\n\t\t\t\taddFloat(uintptr(math.Float64bits(float64(f.Float()))))\n\t\t\t\tshift = 0\n\t\t\t\tflushed = true\n\t\t\tcase reflect.Array:\n\t\t\t\tplace(f)\n\t\t\tdefault:\n\t\t\t\tpanic(\"purego: unsupported kind \" + f.Kind().String())\n\t\t\t}\n\t\t}\n\t}\n\tplace(v)\n\tif !flushed {\n\t\tif class == _FLOAT {\n\t\t\taddFloat(uintptr(val))\n\t\t} else {\n\t\t\taddInt(uintptr(val))\n\t\t}\n\t}\n}\n\nfunc placeStack(v reflect.Value, keepAlive []any, addInt func(uintptr)) []any {\n\t// Struct is too big to be placed in registers.\n\t// Copy to heap and place the pointer in register\n\tptrStruct := reflect.New(v.Type())\n\tptrStruct.Elem().Set(v)\n\tptr := ptrStruct.Elem().Addr().UnsafePointer()\n\tkeepAlive = append(keepAlive, ptr)\n\taddInt(uintptr(ptr))\n\treturn keepAlive\n}\n\n// isHFA reports a Homogeneous Floating-point Aggregate (HFA) which is a Fundamental Data Type that is a\n// Floating-Point type and at most four uniquely addressable members (5.9.5.1 in [Arm64 Calling Convention]).\n// This type of struct will be placed more compactly than the individual fields.\n//\n// [Arm64 Calling Convention]: https://github.com/ARM-software/abi-aa/blob/main/sysvabi64/sysvabi64.rst\nfunc isHFA(t reflect.Type) bool {\n\t// round up struct size to nearest 8 see section B.4\n\tstructSize := roundUpTo8(t.Size())\n\tif structSize == 0 || t.NumField() > 4 {\n\t\treturn false\n\t}\n\tfirst := t.Field(0)\n\tswitch first.Type.Kind() {\n\tcase reflect.Float32, reflect.Float64:\n\t\tfirstKind := first.Type.Kind()\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tif t.Field(i).Type.Kind() != firstKind {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase reflect.Array:\n\t\tswitch first.Type.Elem().Kind() {\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\tcase reflect.Struct:\n\t\tfor i := 0; i < first.Type.NumField(); i++ {\n\t\t\tif !isHFA(first.Type) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// isHVA reports a Homogeneous Aggregate with a Fundamental Data Type that is a Short-Vector type\n// and at most four uniquely addressable members (5.9.5.2 in [Arm64 Calling Convention]).\n// A short vector is a machine type that is composed of repeated instances of one fundamental integral or\n// floating-point type. It may be 8 or 16 bytes in total size (5.4 in [Arm64 Calling Convention]).\n// This type of struct will be placed more compactly than the individual fields.\n//\n// [Arm64 Calling Convention]: https://github.com/ARM-software/abi-aa/blob/main/sysvabi64/sysvabi64.rst\nfunc isHVA(t reflect.Type) bool {\n\t// round up struct size to nearest 8 see section B.4\n\tstructSize := roundUpTo8(t.Size())\n\tif structSize == 0 || (structSize != 8 && structSize != 16) {\n\t\treturn false\n\t}\n\tfirst := t.Field(0)\n\tswitch first.Type.Kind() {\n\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Int8, reflect.Int16, reflect.Int32:\n\t\tfirstKind := first.Type.Kind()\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tif t.Field(i).Type.Kind() != firstKind {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase reflect.Array:\n\t\tswitch first.Type.Elem().Kind() {\n\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Int8, reflect.Int16, reflect.Int32:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\tdefault:\n\t\treturn false\n\t}\n}\n"
        },
        {
          "name": "struct_other.go",
          "type": "blob",
          "size": 0.4697265625,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2024 The Ebitengine Authors\n\n//go:build !amd64 && !arm64\n\npackage purego\n\nimport \"reflect\"\n\nfunc addStruct(v reflect.Value, numInts, numFloats, numStack *int, addInt, addFloat, addStack func(uintptr), keepAlive []any) []any {\n\tpanic(\"purego: struct arguments are not supported\")\n}\n\nfunc getStruct(outType reflect.Type, syscall syscall15Args) (v reflect.Value) {\n\tpanic(\"purego: struct returns are not supported\")\n}\n"
        },
        {
          "name": "struct_test.go",
          "type": "blob",
          "size": 24.4482421875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2024 The Ebitengine Authors\n\n//go:build darwin && (arm64 || amd64)\n\npackage purego_test\n\nimport (\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"github.com/ebitengine/purego\"\n)\n\nfunc TestRegisterFunc_structArgs(t *testing.T) {\n\tlibFileName := filepath.Join(t.TempDir(), \"structtest.so\")\n\tt.Logf(\"Build %v\", libFileName)\n\n\tif err := buildSharedLib(\"CC\", libFileName, filepath.Join(\"testdata\", \"structtest\", \"struct_test.c\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(libFileName)\n\n\tlib, err := purego.Dlopen(libFileName, purego.RTLD_NOW|purego.RTLD_GLOBAL)\n\tif err != nil {\n\t\tt.Fatalf(\"Dlopen(%q) failed: %v\", libFileName, err)\n\t}\n\n\tconst (\n\t\texpectedUnsigned         = 0xdeadbeef\n\t\texpectedSigned           = -123\n\t\texpectedOdd              = 12 + 23 + 46\n\t\texpectedLong     uint64  = 0xdeadbeefcafebabe\n\t\texpectedFloat    float32 = 10\n\t\texpectedDouble   float64 = 10\n\t)\n\n\t{\n\t\ttype Empty struct{}\n\t\tvar NoStruct func(Empty) int64\n\t\tpurego.RegisterLibFunc(&NoStruct, lib, \"NoStruct\")\n\t\tif ret := NoStruct(Empty{}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"NoStruct returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype EmptyEmpty struct{}\n\t\tvar EmptyEmptyFn func(EmptyEmpty) int64\n\t\tpurego.RegisterLibFunc(&EmptyEmptyFn, lib, \"EmptyEmpty\")\n\t\tif ret := EmptyEmptyFn(EmptyEmpty{}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"EmptyEmpty returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t\tvar EmptyEmptyWithReg func(uint32, EmptyEmpty, uint32) int64\n\t\tpurego.RegisterLibFunc(&EmptyEmptyWithReg, lib, \"EmptyEmptyWithReg\")\n\t\tif ret := EmptyEmptyWithReg(0xdead, EmptyEmpty{}, 0xbeef); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"EmptyEmptyWithReg returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype GreaterThan16Bytes struct {\n\t\t\tx, y, z *int64\n\t\t}\n\t\tvar x, y, z int64 = 0xEF, 0xBE00, 0xDEAD0000\n\t\tvar GreaterThan16BytesFn func(GreaterThan16Bytes) int64\n\t\tpurego.RegisterLibFunc(&GreaterThan16BytesFn, lib, \"GreaterThan16Bytes\")\n\t\tif ret := GreaterThan16BytesFn(GreaterThan16Bytes{x: &x, y: &y, z: &z}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"GreaterThan16Bytes returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype GreaterThan16BytesStruct struct {\n\t\t\ta struct {\n\t\t\t\tx, y, z *int64\n\t\t\t}\n\t\t}\n\t\tvar x, y, z int64 = 0xEF, 0xBE00, 0xDEAD0000\n\t\tvar GreaterThan16BytesStructFn func(GreaterThan16BytesStruct) int64\n\t\tpurego.RegisterLibFunc(&GreaterThan16BytesStructFn, lib, \"GreaterThan16BytesStruct\")\n\t\tif ret := GreaterThan16BytesStructFn(GreaterThan16BytesStruct{a: struct{ x, y, z *int64 }{x: &x, y: &y, z: &z}}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"GreaterThan16BytesStructFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype GreaterThan16Bytes struct {\n\t\t\tx, y, z *int64\n\t\t}\n\t\tvar x, y, z int64 = 0xEF, 0xBE00, 0xDEAD0000\n\t\tvar AfterRegisters func(a, b, c, d, e, f, g, h int, bytes GreaterThan16Bytes) int64\n\t\tpurego.RegisterLibFunc(&AfterRegisters, lib, \"AfterRegisters\")\n\t\tif ret := AfterRegisters(0xD0000000, 0xE000000, 0xA00000, 0xD0000, 0xB000, 0xE00, 0xE0, 0xF, GreaterThan16Bytes{x: &x, y: &y, z: &z}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"AfterRegisters returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t\tvar BeforeRegisters func(bytes GreaterThan16Bytes, a, b int64) uint64\n\t\tz -= 0xFF\n\t\tpurego.RegisterLibFunc(&BeforeRegisters, lib, \"BeforeRegisters\")\n\t\tif ret := BeforeRegisters(GreaterThan16Bytes{&x, &y, &z}, 0x0F, 0xF0); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"BeforeRegisters returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype IntLessThan16Bytes struct {\n\t\t\tx, y int64\n\t\t}\n\t\tvar IntLessThan16BytesFn func(bytes IntLessThan16Bytes) int64\n\t\tpurego.RegisterLibFunc(&IntLessThan16BytesFn, lib, \"IntLessThan16Bytes\")\n\t\tif ret := IntLessThan16BytesFn(IntLessThan16Bytes{0xDEAD0000, 0xBEEF}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"IntLessThan16BytesFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype FloatLessThan16Bytes struct {\n\t\t\tx, y float32\n\t\t}\n\t\tvar FloatLessThan16BytesFn func(FloatLessThan16Bytes) float32\n\t\tpurego.RegisterLibFunc(&FloatLessThan16BytesFn, lib, \"FloatLessThan16Bytes\")\n\t\tif ret := FloatLessThan16BytesFn(FloatLessThan16Bytes{3, 7}); ret != expectedFloat {\n\t\t\tt.Fatalf(\"FloatLessThan16Bytes returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype ThreeSmallFields struct {\n\t\t\tx, y, z float32\n\t\t}\n\t\tvar ThreeSmallFieldsFn func(ThreeSmallFields) float32\n\t\tpurego.RegisterLibFunc(&ThreeSmallFieldsFn, lib, \"ThreeSmallFields\")\n\t\tif ret := ThreeSmallFieldsFn(ThreeSmallFields{1, 2, 7}); ret != expectedFloat {\n\t\t\tt.Fatalf(\"ThreeSmallFields returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype FloatAndInt struct {\n\t\t\tx float32\n\t\t\ty int32\n\t\t}\n\t\tvar FloatAndIntFn func(FloatAndInt) float32\n\t\tpurego.RegisterLibFunc(&FloatAndIntFn, lib, \"FloatAndInt\")\n\t\tif ret := FloatAndIntFn(FloatAndInt{3, 7}); ret != expectedFloat {\n\t\t\tt.Fatalf(\"FloatAndIntFn returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype DoubleStruct struct {\n\t\t\tx float64\n\t\t}\n\t\tvar DoubleStructFn func(DoubleStruct) float64\n\t\tpurego.RegisterLibFunc(&DoubleStructFn, lib, \"DoubleStruct\")\n\t\tif ret := DoubleStructFn(DoubleStruct{10}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"DoubleStruct returned %f wanted %f\", ret, expectedDouble)\n\t\t}\n\t}\n\t{\n\t\ttype TwoDoubleStruct struct {\n\t\t\tx, y float64\n\t\t}\n\t\tvar TwoDoubleStructFn func(TwoDoubleStruct) float64\n\t\tpurego.RegisterLibFunc(&TwoDoubleStructFn, lib, \"TwoDoubleStruct\")\n\t\tif ret := TwoDoubleStructFn(TwoDoubleStruct{3, 7}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"TwoDoubleStruct returned %f wanted %f\", ret, expectedDouble)\n\t\t}\n\t}\n\t{\n\t\ttype TwoDoubleTwoStruct struct {\n\t\t\tx struct {\n\t\t\t\tx, y float64\n\t\t\t}\n\t\t}\n\t\tvar TwoDoubleTwoStructFn func(TwoDoubleTwoStruct) float64\n\t\tpurego.RegisterLibFunc(&TwoDoubleTwoStructFn, lib, \"TwoDoubleTwoStruct\")\n\t\tif ret := TwoDoubleTwoStructFn(TwoDoubleTwoStruct{x: struct{ x, y float64 }{x: 3, y: 7}}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"TwoDoubleTwoStruct returned %f wanted %f\", ret, expectedDouble)\n\t\t}\n\t}\n\t{\n\t\ttype ThreeDoubleStruct struct {\n\t\t\tx, y, z float64\n\t\t}\n\t\tvar ThreeDoubleStructFn func(ThreeDoubleStruct) float64\n\t\tpurego.RegisterLibFunc(&ThreeDoubleStructFn, lib, \"ThreeDoubleStruct\")\n\t\tif ret := ThreeDoubleStructFn(ThreeDoubleStruct{1, 3, 6}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"ThreeDoubleStructFn returned %f wanted %f\", ret, expectedDouble)\n\t\t}\n\t}\n\t{\n\t\ttype LargeFloatStruct struct {\n\t\t\ta, b, c, d, e, f float64\n\t\t}\n\t\tvar LargeFloatStructFn func(LargeFloatStruct) float64\n\t\tpurego.RegisterLibFunc(&LargeFloatStructFn, lib, \"LargeFloatStruct\")\n\t\tif ret := LargeFloatStructFn(LargeFloatStruct{1, 2, 3, 4, 5, -5}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"LargeFloatStructFn returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t\tvar LargeFloatStructWithRegs func(a, b, c float64, s LargeFloatStruct) float64\n\t\tpurego.RegisterLibFunc(&LargeFloatStructWithRegs, lib, \"LargeFloatStructWithRegs\")\n\t\tif ret := LargeFloatStructWithRegs(1, -1, 0, LargeFloatStruct{1, 2, 3, 4, 5, -5}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"LargeFloatStructWithRegs returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype Rect struct {\n\t\t\tx, y, w, h float64\n\t\t}\n\t\tvar RectangleWithRegs func(a, b, c, d, e float64, rect Rect) float64\n\t\tpurego.RegisterLibFunc(&RectangleWithRegs, lib, \"RectangleWithRegs\")\n\t\tif ret := RectangleWithRegs(1, 2, 3, 4, -2, Rect{1, 2, 3, -4}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"RectangleWithRegs returned %f wanted %f\", ret, expectedDouble)\n\t\t}\n\t\tvar RectangleSubtract func(rect Rect) float64\n\t\tpurego.RegisterLibFunc(&RectangleSubtract, lib, \"RectangleSubtract\")\n\t\tif ret := RectangleSubtract(Rect{15, 5, 3, 7}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"RectangleSubtract returned %f wanted %f\", ret, expectedDouble)\n\t\t}\n\t\tvar Rectangle func(rect Rect) float64\n\t\tpurego.RegisterLibFunc(&Rectangle, lib, \"Rectangle\")\n\t\tif ret := Rectangle(Rect{1, 2, 3, 4}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"Rectangle returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype FloatArray struct {\n\t\t\ta [2]float64\n\t\t}\n\t\tvar FloatArrayFn func(rect FloatArray) float64\n\t\tpurego.RegisterLibFunc(&FloatArrayFn, lib, \"FloatArray\")\n\t\tif ret := FloatArrayFn(FloatArray{a: [2]float64{3, 7}}); ret != expectedDouble {\n\t\t\tt.Fatalf(\"FloatArray returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype UnsignedChar4Bytes struct {\n\t\t\ta, b, c, d byte\n\t\t}\n\t\tvar UnsignedChar4BytesFn func(UnsignedChar4Bytes) uint32\n\t\tpurego.RegisterLibFunc(&UnsignedChar4BytesFn, lib, \"UnsignedChar4Bytes\")\n\t\tif ret := UnsignedChar4BytesFn(UnsignedChar4Bytes{a: 0xDE, b: 0xAD, c: 0xBE, d: 0xEF}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"UnsignedChar4BytesFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype UnsignedChar4BytesStruct struct {\n\t\t\tx struct {\n\t\t\t\ta byte\n\t\t\t}\n\t\t\ty struct {\n\t\t\t\tb byte\n\t\t\t}\n\t\t\tz struct {\n\t\t\t\tc byte\n\t\t\t}\n\t\t\tw struct {\n\t\t\t\td byte\n\t\t\t}\n\t\t}\n\t\tvar UnsignedChar4BytesStructFn func(UnsignedChar4BytesStruct) uint32\n\t\tpurego.RegisterLibFunc(&UnsignedChar4BytesStructFn, lib, \"UnsignedChar4BytesStruct\")\n\t\tif ret := UnsignedChar4BytesStructFn(UnsignedChar4BytesStruct{\n\t\t\tx: struct{ a byte }{a: 0xDE},\n\t\t\ty: struct{ b byte }{b: 0xAD},\n\t\t\tz: struct{ c byte }{c: 0xBE},\n\t\t\tw: struct{ d byte }{d: 0xEF},\n\t\t}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"UnsignedChar4BytesStructFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype Short struct {\n\t\t\ta, b, c, d uint16\n\t\t}\n\t\tvar ShortFn func(Short) uint64\n\t\tpurego.RegisterLibFunc(&ShortFn, lib, \"Short\")\n\t\tif ret := ShortFn(Short{a: 0xDEAD, b: 0xBEEF, c: 0xCAFE, d: 0xBABE}); ret != expectedLong {\n\t\t\tt.Fatalf(\"ShortFn returned %#x wanted %#x\", ret, expectedLong)\n\t\t}\n\t}\n\t{\n\t\ttype Int struct {\n\t\t\ta, b uint32\n\t\t}\n\t\tvar IntFn func(Int) uint64\n\t\tpurego.RegisterLibFunc(&IntFn, lib, \"Int\")\n\t\tif ret := IntFn(Int{a: 0xDEADBEEF, b: 0xCAFEBABE}); ret != expectedLong {\n\t\t\tt.Fatalf(\"IntFn returned %#x wanted %#x\", ret, expectedLong)\n\t\t}\n\t}\n\t{\n\t\ttype Long struct {\n\t\t\ta uint64\n\t\t}\n\t\tvar LongFn func(Long) uint64\n\t\tpurego.RegisterLibFunc(&LongFn, lib, \"Long\")\n\t\tif ret := LongFn(Long{a: 0xDEADBEEFCAFEBABE}); ret != expectedLong {\n\t\t\tt.Fatalf(\"LongFn returned %#x wanted %#x\", ret, expectedLong)\n\t\t}\n\t}\n\t{\n\t\ttype Char8Bytes struct {\n\t\t\ta, b, c, d, e, f, g, h int8\n\t\t}\n\t\tvar Char8BytesFn func(Char8Bytes) int32\n\t\tpurego.RegisterLibFunc(&Char8BytesFn, lib, \"Char8Bytes\")\n\t\tif ret := Char8BytesFn(Char8Bytes{a: -128, b: 127, c: 3, d: -88, e: -3, f: 34, g: -48, h: -20}); ret != expectedSigned {\n\t\t\tt.Fatalf(\"Char8Bytes returned %d wanted %d\", ret, expectedSigned)\n\t\t}\n\t}\n\t{\n\t\ttype Odd struct {\n\t\t\ta, b, c byte\n\t\t}\n\t\tvar OddFn func(Odd) int32\n\t\tpurego.RegisterLibFunc(&OddFn, lib, \"Odd\")\n\t\tif ret := OddFn(Odd{a: 12, b: 23, c: 46}); ret != expectedOdd {\n\t\t\tt.Fatalf(\"OddFn returned %d wanted %d\", ret, expectedOdd)\n\t\t}\n\t}\n\t{\n\t\ttype Char2Short1 struct {\n\t\t\ta, b byte\n\t\t\tc    uint16\n\t\t}\n\t\tvar Char2Short1s func(Char2Short1) int32\n\t\tpurego.RegisterLibFunc(&Char2Short1s, lib, \"Char2Short1s\")\n\t\tif ret := Char2Short1s(Char2Short1{a: 12, b: 23, c: 46}); ret != expectedOdd {\n\t\t\tt.Fatalf(\"Char2Short1s returned %d wanted %d\", ret, expectedOdd)\n\t\t}\n\t}\n\t{\n\t\ttype SignedChar2Short1 struct {\n\t\t\ta, b int8\n\t\t\tc    int16\n\t\t}\n\t\tvar SignedChar2Short1Fn func(SignedChar2Short1) int32\n\t\tpurego.RegisterLibFunc(&SignedChar2Short1Fn, lib, \"SignedChar2Short1\")\n\t\tif ret := SignedChar2Short1Fn(SignedChar2Short1{a: 100, b: -23, c: -200}); ret != expectedSigned {\n\t\t\tt.Fatalf(\"SignedChar2Short1Fn returned %d wanted %d\", ret, expectedSigned)\n\t\t}\n\t}\n\t{\n\t\ttype Array4UnsignedChars struct {\n\t\t\ta [4]uint8\n\t\t}\n\t\tvar Array4UnsignedCharsFn func(chars Array4UnsignedChars) uint32\n\t\tpurego.RegisterLibFunc(&Array4UnsignedCharsFn, lib, \"Array4UnsignedChars\")\n\t\tif ret := Array4UnsignedCharsFn(Array4UnsignedChars{a: [...]uint8{0xDE, 0xAD, 0xBE, 0xEF}}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"Array4UnsignedCharsFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype Array3UnsignedChar struct {\n\t\t\ta [3]uint8\n\t\t}\n\t\tvar Array3UnsignedChars func(chars Array3UnsignedChar) uint32\n\t\tpurego.RegisterLibFunc(&Array3UnsignedChars, lib, \"Array3UnsignedChars\")\n\t\tif ret := Array3UnsignedChars(Array3UnsignedChar{a: [...]uint8{0xDE, 0xAD, 0xBE}}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"Array4UnsignedCharsFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype Array2UnsignedShort struct {\n\t\t\ta [2]uint16\n\t\t}\n\t\tvar Array2UnsignedShorts func(chars Array2UnsignedShort) uint32\n\t\tpurego.RegisterLibFunc(&Array2UnsignedShorts, lib, \"Array2UnsignedShorts\")\n\t\tif ret := Array2UnsignedShorts(Array2UnsignedShort{a: [...]uint16{0xDEAD, 0xBEEF}}); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"Array4UnsignedCharsFn returned %#x wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype Array4Chars struct {\n\t\t\ta [4]int8\n\t\t}\n\t\tvar Array4CharsFn func(chars Array4Chars) int32\n\t\tpurego.RegisterLibFunc(&Array4CharsFn, lib, \"Array4Chars\")\n\t\tif ret := Array4CharsFn(Array4Chars{a: [...]int8{100, -127, 4, -100}}); ret != expectedSigned {\n\t\t\tt.Fatalf(\"Array4CharsFn returned %#x wanted %#x\", ret, expectedSigned)\n\t\t}\n\t}\n\t{\n\t\ttype Array2Short struct {\n\t\t\ta [2]int16\n\t\t}\n\t\tvar Array2Shorts func(chars Array2Short) int32\n\t\tpurego.RegisterLibFunc(&Array2Shorts, lib, \"Array2Shorts\")\n\t\tif ret := Array2Shorts(Array2Short{a: [...]int16{-333, 210}}); ret != expectedSigned {\n\t\t\tt.Fatalf(\"Array4Shorts returned %#x wanted %#x\", ret, expectedSigned)\n\t\t}\n\t}\n\t{\n\t\ttype Array3Short struct {\n\t\t\ta [3]int16\n\t\t}\n\t\tvar Array3Shorts func(chars Array3Short) int32\n\t\tpurego.RegisterLibFunc(&Array3Shorts, lib, \"Array3Shorts\")\n\t\tif ret := Array3Shorts(Array3Short{a: [...]int16{-333, 100, 110}}); ret != expectedSigned {\n\t\t\tt.Fatalf(\"Array4Shorts returned %#x wanted %#x\", ret, expectedSigned)\n\t\t}\n\t}\n\t{\n\t\ttype BoolStruct struct {\n\t\t\tb bool\n\t\t}\n\t\tvar BoolStructFn func(BoolStruct) bool\n\t\tpurego.RegisterLibFunc(&BoolStructFn, lib, \"BoolStruct\")\n\t\tif ret := BoolStructFn(BoolStruct{true}); ret != true {\n\t\t\tt.Fatalf(\"BoolStructFn returned %v wanted %v\", ret, true)\n\t\t}\n\t\tif ret := BoolStructFn(BoolStruct{false}); ret != false {\n\t\t\tt.Fatalf(\"BoolStructFn returned %v wanted %v\", ret, false)\n\t\t}\n\t}\n\t{\n\t\ttype BoolFloat struct {\n\t\t\tb bool\n\t\t\t_ [3]byte // purego won't do padding for you so make sure it aligns properly with C struct\n\t\t\tf float32\n\t\t}\n\t\tvar BoolFloatFn func(BoolFloat) float32\n\t\tpurego.RegisterLibFunc(&BoolFloatFn, lib, \"BoolFloat\")\n\t\tif ret := BoolFloatFn(BoolFloat{b: true, f: 10}); ret != expectedFloat {\n\t\t\tt.Fatalf(\"BoolFloatFn returned %f wanted %f\", ret, expectedFloat)\n\t\t}\n\t\tif ret := BoolFloatFn(BoolFloat{b: false, f: 10}); ret != -expectedFloat {\n\t\t\tt.Fatalf(\"BoolFloatFn returned %f wanted %f\", ret, -expectedFloat)\n\t\t}\n\t}\n\t{\n\t\ttype point struct{ x, y float64 }\n\t\ttype size struct{ width, height float64 }\n\t\ttype Content struct {\n\t\t\tpoint point\n\t\t\tsize  size\n\t\t}\n\t\tvar InitWithContentRect func(*int, Content, int32, int32, bool) uint64\n\t\tpurego.RegisterLibFunc(&InitWithContentRect, lib, \"InitWithContentRect\")\n\t\tif ret := InitWithContentRect(new(int),\n\t\t\t// These numbers are created so that when added together and then divided by 11 it produces 0xdeadbeef\n\t\t\tContent{point{x: 41_000_000_000, y: 95_000_000}, size{width: 214_000, height: 149}},\n\t\t\t15, 4, true); ret != expectedUnsigned {\n\t\t\tt.Fatalf(\"InitWithContentRect returned %d wanted %#x\", ret, expectedUnsigned)\n\t\t}\n\t}\n\t{\n\t\ttype GoInt4 struct {\n\t\t\tA, B, C, D int\n\t\t}\n\t\tvar GoInt4Fn func(GoInt4) int\n\t\tpurego.RegisterLibFunc(&GoInt4Fn, lib, \"GoInt4\")\n\t\tconst expected = math.MaxInt - 52 - 3 + 4\n\t\tif ret := GoInt4Fn(GoInt4{math.MaxInt, -52, 3, 4}); ret != expected {\n\t\t\tt.Fatalf(\"GoInt4Fn returned %d wanted %#x\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype GoUint4 struct {\n\t\t\tA, B, C, D uint\n\t\t}\n\t\tvar GoUint4Fn func(GoUint4) uint\n\t\tpurego.RegisterLibFunc(&GoUint4Fn, lib, \"GoUint4\")\n\t\tconst expected = 1_000_000 + 53 + 71 + 8\n\t\tif ret := GoUint4Fn(GoUint4{1_000_000, 53, 71, 8}); ret != expected {\n\t\t\tt.Fatalf(\"GoUint4Fn returned %d wanted %#x\", ret, expected)\n\t\t}\n\t}\n}\n\nfunc TestRegisterFunc_structReturns(t *testing.T) {\n\tlibFileName := filepath.Join(t.TempDir(), \"structreturntest.so\")\n\tt.Logf(\"Build %v\", libFileName)\n\n\tif err := buildSharedLib(\"CC\", libFileName, filepath.Join(\"testdata\", \"structtest\", \"structreturn_test.c\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(libFileName)\n\n\tlib, err := purego.Dlopen(libFileName, purego.RTLD_NOW|purego.RTLD_GLOBAL)\n\tif err != nil {\n\t\tt.Fatalf(\"Dlopen(%q) failed: %v\", libFileName, err)\n\t}\n\n\t{\n\t\ttype Empty struct{}\n\t\tvar ReturnEmpty func() Empty\n\t\tpurego.RegisterLibFunc(&ReturnEmpty, lib, \"ReturnEmpty\")\n\t\tret := ReturnEmpty()\n\t\t_ = ret\n\t}\n\t{\n\t\ttype inner struct{ a int16 }\n\t\ttype StructInStruct struct {\n\t\t\ta inner\n\t\t\tb inner\n\t\t\tc inner\n\t\t}\n\t\tvar ReturnStructInStruct func(a, b, c int16) StructInStruct\n\t\tpurego.RegisterLibFunc(&ReturnStructInStruct, lib, \"ReturnStructInStruct\")\n\t\texpected := StructInStruct{inner{^int16(0)}, inner{2}, inner{3}}\n\t\tif ret := ReturnStructInStruct(^int16(0), 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"StructInStruct returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype ThreeShorts struct{ a, b, c int16 }\n\t\tvar ReturnThreeShorts func(a, b, c int16) ThreeShorts\n\t\tpurego.RegisterLibFunc(&ReturnThreeShorts, lib, \"ReturnThreeShorts\")\n\t\texpected := ThreeShorts{^int16(0), 2, 3}\n\t\tif ret := ReturnThreeShorts(^int16(0), 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnThreeShorts returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype FourShorts struct{ a, b, c, d int16 }\n\t\tvar ReturnFourShorts func(a, b, c, d int16) FourShorts\n\t\tpurego.RegisterLibFunc(&ReturnFourShorts, lib, \"ReturnFourShorts\")\n\t\texpected := FourShorts{^int16(0), 2, 3, 4}\n\t\tif ret := ReturnFourShorts(^int16(0), 2, 3, 4); ret != expected {\n\t\t\tt.Fatalf(\"ReturnFourShorts returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype OneLong struct{ a int64 }\n\t\tvar ReturnOneLong func(a int64) OneLong\n\t\tpurego.RegisterLibFunc(&ReturnOneLong, lib, \"ReturnOneLong\")\n\t\texpected := OneLong{5}\n\t\tif ret := ReturnOneLong(5); ret != expected {\n\t\t\tt.Fatalf(\"ReturnOneLong returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype TwoLongs struct{ a, b int64 }\n\t\tvar ReturnTwoLongs func(a, b int64) TwoLongs\n\t\tpurego.RegisterLibFunc(&ReturnTwoLongs, lib, \"ReturnTwoLongs\")\n\t\texpected := TwoLongs{1, 2}\n\t\tif ret := ReturnTwoLongs(1, 2); ret != expected {\n\t\t\tt.Fatalf(\"ReturnTwoLongs returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype ThreeLongs struct{ a, b, c int64 }\n\t\tvar ReturnThreeLongs func(a, b, c int64) ThreeLongs\n\t\tpurego.RegisterLibFunc(&ReturnThreeLongs, lib, \"ReturnThreeLongs\")\n\t\texpected := ThreeLongs{1, 2, 3}\n\t\tif ret := ReturnThreeLongs(1, 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnThreeLongs returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype OneFloat struct{ a float32 }\n\t\tvar ReturnOneFloat func(a float32) OneFloat\n\t\tpurego.RegisterLibFunc(&ReturnOneFloat, lib, \"ReturnOneFloat\")\n\t\texpected := OneFloat{1}\n\t\tif ret := ReturnOneFloat(1); ret != expected {\n\t\t\tt.Fatalf(\"ReturnOneFloat returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype TwoFloats struct{ a, b float32 }\n\t\tvar ReturnTwoFloats func(a, b float32) TwoFloats\n\t\tpurego.RegisterLibFunc(&ReturnTwoFloats, lib, \"ReturnTwoFloats\")\n\t\texpected := TwoFloats{3, 10}\n\t\tif ret := ReturnTwoFloats(5, 2); ret != expected {\n\t\t\tt.Fatalf(\"ReturnTwoFloats returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype ThreeFloats struct{ a, b, c float32 }\n\t\tvar ReturnThreeFloats func(a, b, c float32) ThreeFloats\n\t\tpurego.RegisterLibFunc(&ReturnThreeFloats, lib, \"ReturnThreeFloats\")\n\t\texpected := ThreeFloats{1, 2, 3}\n\t\tif ret := ReturnThreeFloats(1, 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnThreeFloats returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype OneDouble struct{ a float64 }\n\t\tvar ReturnOneDouble func(a float64) OneDouble\n\t\tpurego.RegisterLibFunc(&ReturnOneDouble, lib, \"ReturnOneDouble\")\n\t\texpected := OneDouble{1}\n\t\tif ret := ReturnOneDouble(1); ret != expected {\n\t\t\tt.Fatalf(\"ReturnOneDouble returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype TwoDoubles struct{ a, b float64 }\n\t\tvar ReturnTwoDoubles func(a, b float64) TwoDoubles\n\t\tpurego.RegisterLibFunc(&ReturnTwoDoubles, lib, \"ReturnTwoDoubles\")\n\t\texpected := TwoDoubles{1, 2}\n\t\tif ret := ReturnTwoDoubles(1, 2); ret != expected {\n\t\t\tt.Fatalf(\"ReturnTwoDoubles returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype ThreeDoubles struct{ a, b, c float64 }\n\t\tvar ReturnThreeDoubles func(a, b, c float64) ThreeDoubles\n\t\tpurego.RegisterLibFunc(&ReturnThreeDoubles, lib, \"ReturnThreeDoubles\")\n\t\texpected := ThreeDoubles{1, 2, 3}\n\t\tif ret := ReturnThreeDoubles(1, 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnThreeDoubles returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype FourDoubles struct{ a, b, c, d float64 }\n\t\tvar ReturnFourDoubles func(a, b, c, d float64) FourDoubles\n\t\tpurego.RegisterLibFunc(&ReturnFourDoubles, lib, \"ReturnFourDoubles\")\n\t\texpected := FourDoubles{1, 2, 3, 4}\n\t\tif ret := ReturnFourDoubles(1, 2, 3, 4); ret != expected {\n\t\t\tt.Fatalf(\"ReturnFourDoubles returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype FourDoublesInternal struct {\n\t\t\tf struct{ a, b float64 }\n\t\t\tg struct{ c, d float64 }\n\t\t}\n\t\tvar ReturnFourDoublesInternal func(a, b, c, d float64) FourDoublesInternal\n\t\tpurego.RegisterLibFunc(&ReturnFourDoublesInternal, lib, \"ReturnFourDoublesInternal\")\n\t\texpected := FourDoublesInternal{f: struct{ a, b float64 }{a: 1, b: 2}, g: struct{ c, d float64 }{c: 3, d: 4}}\n\t\tif ret := ReturnFourDoublesInternal(1, 2, 3, 4); ret != expected {\n\t\t\tt.Fatalf(\"ReturnFourDoublesInternal returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype FiveDoubles struct{ a, b, c, d, e float64 }\n\t\tvar ReturnFiveDoubles func(a, b, c, d, e float64) FiveDoubles\n\t\tpurego.RegisterLibFunc(&ReturnFiveDoubles, lib, \"ReturnFiveDoubles\")\n\t\texpected := FiveDoubles{1, 2, 3, 4, 5}\n\t\tif ret := ReturnFiveDoubles(1, 2, 3, 4, 5); ret != expected {\n\t\t\tt.Fatalf(\"ReturnFiveDoubles returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype OneFloatOneDouble struct {\n\t\t\ta float32\n\t\t\t_ float32\n\t\t\tb float64\n\t\t}\n\t\tvar ReturnOneFloatOneDouble func(a float32, b float64) OneFloatOneDouble\n\t\tpurego.RegisterLibFunc(&ReturnOneFloatOneDouble, lib, \"ReturnOneFloatOneDouble\")\n\t\texpected := OneFloatOneDouble{a: 1, b: 2}\n\t\tif ret := ReturnOneFloatOneDouble(1, 2); ret != expected {\n\t\t\tt.Fatalf(\"ReturnOneFloatOneDouble returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype OneDoubleOneFloat struct {\n\t\t\ta float64\n\t\t\tb float32\n\t\t}\n\t\tvar ReturnOneDoubleOneFloat func(a float64, b float32) OneDoubleOneFloat\n\t\tpurego.RegisterLibFunc(&ReturnOneDoubleOneFloat, lib, \"ReturnOneDoubleOneFloat\")\n\t\texpected := OneDoubleOneFloat{1, 2}\n\t\tif ret := ReturnOneDoubleOneFloat(1, 2); ret != expected {\n\t\t\tt.Fatalf(\"ReturnOneDoubleOneFloat returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype Unaligned1 struct {\n\t\t\ta int8\n\t\t\t_ [1]int8\n\t\t\tb int16\n\t\t\t_ [1]int32\n\t\t\tc int64\n\t\t}\n\t\tvar ReturnUnaligned1 func(a int8, b int16, c int64) Unaligned1\n\t\tpurego.RegisterLibFunc(&ReturnUnaligned1, lib, \"ReturnUnaligned1\")\n\t\texpected := Unaligned1{a: 1, b: 2, c: 3}\n\t\tif ret := ReturnUnaligned1(1, 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnUnaligned1 returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype Mixed1 struct {\n\t\t\ta float32\n\t\t\tb int32\n\t\t}\n\t\tvar ReturnMixed1 func(a float32, b int32) Mixed1\n\t\tpurego.RegisterLibFunc(&ReturnMixed1, lib, \"ReturnMixed1\")\n\t\texpected := Mixed1{1, 2}\n\t\tif ret := ReturnMixed1(1, 2); ret != expected {\n\t\t\tt.Fatalf(\"ReturnMixed1 returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype Mixed2 struct {\n\t\t\ta float32\n\t\t\tb int32\n\t\t\tc float32\n\t\t\td int32\n\t\t}\n\t\tvar ReturnMixed2 func(a float32, b int32, c float32, d int32) Mixed2\n\t\tpurego.RegisterLibFunc(&ReturnMixed2, lib, \"ReturnMixed2\")\n\t\texpected := Mixed2{1, 2, 3, 4}\n\t\tif ret := ReturnMixed2(1, 2, 3, 4); ret != expected {\n\t\t\tt.Fatalf(\"ReturnMixed2 returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype Mixed3 struct {\n\t\t\ta float32\n\t\t\tb uint32\n\t\t\tc float64\n\t\t}\n\t\tvar ReturnMixed3 func(a float32, b uint32, c float64) Mixed3\n\t\tpurego.RegisterLibFunc(&ReturnMixed3, lib, \"ReturnMixed3\")\n\t\texpected := Mixed3{1, 2, 3}\n\t\tif ret := ReturnMixed3(1, 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnMixed3 returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype Mixed4 struct {\n\t\t\ta float64\n\t\t\tb uint32\n\t\t\tc float32\n\t\t}\n\t\tvar ReturnMixed4 func(a float64, b uint32, c float32) Mixed4\n\t\tpurego.RegisterLibFunc(&ReturnMixed4, lib, \"ReturnMixed4\")\n\t\texpected := Mixed4{1, 2, 3}\n\t\tif ret := ReturnMixed4(1, 2, 3); ret != expected {\n\t\t\tt.Fatalf(\"ReturnMixed4 returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t}\n\t{\n\t\ttype Ptr1 struct {\n\t\t\ta *int64\n\t\t\tb unsafe.Pointer\n\t\t}\n\t\tvar ReturnPtr1 func(a *int64, b unsafe.Pointer) Ptr1\n\t\tpurego.RegisterLibFunc(&ReturnPtr1, lib, \"ReturnPtr1\")\n\t\ta, b := new(int64), new(struct{})\n\t\texpected := Ptr1{a, unsafe.Pointer(b)}\n\t\tif ret := ReturnPtr1(a, unsafe.Pointer(b)); ret != expected {\n\t\t\tt.Fatalf(\"ReturnPtr1 returned %+v wanted %+v\", ret, expected)\n\t\t}\n\t\truntime.KeepAlive(a)\n\t\truntime.KeepAlive(b)\n\t}\n}\n"
        },
        {
          "name": "sys_amd64.s",
          "type": "blob",
          "size": 4.9755859375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux\n\n#include \"textflag.h\"\n#include \"abi_amd64.h\"\n#include \"go_asm.h\"\n#include \"funcdata.h\"\n\n#define STACK_SIZE 80\n#define PTR_ADDRESS (STACK_SIZE - 8)\n\n// syscall15X calls a function in libc on behalf of the syscall package.\n// syscall15X takes a pointer to a struct like:\n// struct {\n//\tfn    uintptr\n//\ta1    uintptr\n//\ta2    uintptr\n//\ta3    uintptr\n//\ta4    uintptr\n//\ta5    uintptr\n//\ta6    uintptr\n//\ta7    uintptr\n//\ta8    uintptr\n//\ta9    uintptr\n//\ta10    uintptr\n//\ta11    uintptr\n//\ta12    uintptr\n//\ta13    uintptr\n//\ta14    uintptr\n//\ta15    uintptr\n//\tr1    uintptr\n//\tr2    uintptr\n//\terr   uintptr\n// }\n// syscall15X must be called on the g0 stack with the\n// C calling convention (use libcCall).\nGLOBL syscall15XABI0(SB), NOPTR|RODATA, $8\nDATA syscall15XABI0(SB)/8, $syscall15X(SB)\nTEXT syscall15X(SB), NOSPLIT|NOFRAME, $0\n\tPUSHQ BP\n\tMOVQ  SP, BP\n\tSUBQ  $STACK_SIZE, SP\n\tMOVQ  DI, PTR_ADDRESS(BP) // save the pointer\n\tMOVQ  DI, R11\n\n\tMOVQ syscall15Args_f1(R11), X0 // f1\n\tMOVQ syscall15Args_f2(R11), X1 // f2\n\tMOVQ syscall15Args_f3(R11), X2 // f3\n\tMOVQ syscall15Args_f4(R11), X3 // f4\n\tMOVQ syscall15Args_f5(R11), X4 // f5\n\tMOVQ syscall15Args_f6(R11), X5 // f6\n\tMOVQ syscall15Args_f7(R11), X6 // f7\n\tMOVQ syscall15Args_f8(R11), X7 // f8\n\n\tMOVQ syscall15Args_a1(R11), DI // a1\n\tMOVQ syscall15Args_a2(R11), SI // a2\n\tMOVQ syscall15Args_a3(R11), DX // a3\n\tMOVQ syscall15Args_a4(R11), CX // a4\n\tMOVQ syscall15Args_a5(R11), R8 // a5\n\tMOVQ syscall15Args_a6(R11), R9 // a6\n\n\t// push the remaining paramters onto the stack\n\tMOVQ syscall15Args_a7(R11), R12\n\tMOVQ R12, 0(SP)                  // push a7\n\tMOVQ syscall15Args_a8(R11), R12\n\tMOVQ R12, 8(SP)                  // push a8\n\tMOVQ syscall15Args_a9(R11), R12\n\tMOVQ R12, 16(SP)                 // push a9\n\tMOVQ syscall15Args_a10(R11), R12\n\tMOVQ R12, 24(SP)                 // push a10\n\tMOVQ syscall15Args_a11(R11), R12\n\tMOVQ R12, 32(SP)                 // push a11\n\tMOVQ syscall15Args_a12(R11), R12\n\tMOVQ R12, 40(SP)                 // push a12\n\tMOVQ syscall15Args_a13(R11), R12\n\tMOVQ R12, 48(SP)                 // push a13\n\tMOVQ syscall15Args_a14(R11), R12\n\tMOVQ R12, 56(SP)                 // push a14\n\tMOVQ syscall15Args_a15(R11), R12\n\tMOVQ R12, 64(SP)                 // push a15\n\tXORL AX, AX                      // vararg: say \"no float args\"\n\n\tMOVQ syscall15Args_fn(R11), R10 // fn\n\tCALL R10\n\n\tMOVQ PTR_ADDRESS(BP), DI      // get the pointer back\n\tMOVQ AX, syscall15Args_a1(DI) // r1\n\tMOVQ DX, syscall15Args_a2(DI) // r3\n\tMOVQ X0, syscall15Args_f1(DI) // f1\n\tMOVQ X1, syscall15Args_f2(DI) // f2\n\n\tXORL AX, AX          // no error (it's ignored anyway)\n\tADDQ $STACK_SIZE, SP\n\tMOVQ BP, SP\n\tPOPQ BP\n\tRET\n\nTEXT callbackasm1(SB), NOSPLIT|NOFRAME, $0\n\tMOVQ 0(SP), AX  // save the return address to calculate the cb index\n\tMOVQ 8(SP), R10 // get the return SP so that we can align register args with stack args\n\tADDQ $8, SP     // remove return address from stack, we are not returning to callbackasm, but to its caller.\n\n\t// make space for first six int and 8 float arguments below the frame\n\tADJSP $14*8, SP\n\tMOVSD X0, (1*8)(SP)\n\tMOVSD X1, (2*8)(SP)\n\tMOVSD X2, (3*8)(SP)\n\tMOVSD X3, (4*8)(SP)\n\tMOVSD X4, (5*8)(SP)\n\tMOVSD X5, (6*8)(SP)\n\tMOVSD X6, (7*8)(SP)\n\tMOVSD X7, (8*8)(SP)\n\tMOVQ  DI, (9*8)(SP)\n\tMOVQ  SI, (10*8)(SP)\n\tMOVQ  DX, (11*8)(SP)\n\tMOVQ  CX, (12*8)(SP)\n\tMOVQ  R8, (13*8)(SP)\n\tMOVQ  R9, (14*8)(SP)\n\tLEAQ  8(SP), R8      // R8 = address of args vector\n\n\tPUSHQ R10 // push the stack pointer below registers\n\n\t// Switch from the host ABI to the Go ABI.\n\tPUSH_REGS_HOST_TO_ABI0()\n\n\t// determine index into runtimecbs table\n\tMOVQ $callbackasm(SB), DX\n\tSUBQ DX, AX\n\tMOVQ $0, DX\n\tMOVQ $5, CX               // divide by 5 because each call instruction in callbacks is 5 bytes long\n\tDIVL CX\n\tSUBQ $1, AX               // subtract 1 because return PC is to the next slot\n\n\t// Create a struct callbackArgs on our stack to be passed as\n\t// the \"frame\" to cgocallback and on to callbackWrap.\n\t// $24 to make enough room for the arguments to runtime.cgocallback\n\tSUBQ $(24+callbackArgs__size), SP\n\tMOVQ AX, (24+callbackArgs_index)(SP)  // callback index\n\tMOVQ R8, (24+callbackArgs_args)(SP)   // address of args vector\n\tMOVQ $0, (24+callbackArgs_result)(SP) // result\n\tLEAQ 24(SP), AX                       // take the address of callbackArgs\n\n\t// Call cgocallback, which will call callbackWrap(frame).\n\tMOVQ callbackWrap_call(SB), DI // Get the ABIInternal function pointer\n\tMOVQ (DI), DI                   // without <ABIInternal> by using a closure.\n\tMOVQ AX, SI                     // frame (address of callbackArgs)\n\tMOVQ $0, CX                     // context\n\n\tCALL crosscall2(SB) // runtime.cgocallback(fn, frame, ctxt uintptr)\n\n\t// Get callback result.\n\tMOVQ (24+callbackArgs_result)(SP), AX\n\tADDQ $(24+callbackArgs__size), SP     // remove callbackArgs struct\n\n\tPOP_REGS_HOST_TO_ABI0()\n\n\tPOPQ  R10        // get the SP back\n\tADJSP $-14*8, SP // remove arguments\n\n\tMOVQ R10, 0(SP)\n\n\tRET\n"
        },
        {
          "name": "sys_arm64.s",
          "type": "blob",
          "size": 2.689453125,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux || windows\n\n#include \"textflag.h\"\n#include \"go_asm.h\"\n#include \"funcdata.h\"\n\n#define STACK_SIZE 64\n#define PTR_ADDRESS (STACK_SIZE - 8)\n\n// syscall15X calls a function in libc on behalf of the syscall package.\n// syscall15X takes a pointer to a struct like:\n// struct {\n//\tfn    uintptr\n//\ta1    uintptr\n//\ta2    uintptr\n//\ta3    uintptr\n//\ta4    uintptr\n//\ta5    uintptr\n//\ta6    uintptr\n//\ta7    uintptr\n//\ta8    uintptr\n//\ta9    uintptr\n//\ta10    uintptr\n//\ta11    uintptr\n//\ta12    uintptr\n//\ta13    uintptr\n//\ta14    uintptr\n//\ta15    uintptr\n//\tr1    uintptr\n//\tr2    uintptr\n//\terr   uintptr\n// }\n// syscall15X must be called on the g0 stack with the\n// C calling convention (use libcCall).\nGLOBL syscall15XABI0(SB), NOPTR|RODATA, $8\nDATA syscall15XABI0(SB)/8, $syscall15X(SB)\nTEXT syscall15X(SB), NOSPLIT, $0\n\tSUB  $STACK_SIZE, RSP     // push structure pointer\n\tMOVD R0, PTR_ADDRESS(RSP)\n\tMOVD R0, R9\n\n\tFMOVD syscall15Args_f1(R9), F0 // f1\n\tFMOVD syscall15Args_f2(R9), F1 // f2\n\tFMOVD syscall15Args_f3(R9), F2 // f3\n\tFMOVD syscall15Args_f4(R9), F3 // f4\n\tFMOVD syscall15Args_f5(R9), F4 // f5\n\tFMOVD syscall15Args_f6(R9), F5 // f6\n\tFMOVD syscall15Args_f7(R9), F6 // f7\n\tFMOVD syscall15Args_f8(R9), F7 // f8\n\n\tMOVD syscall15Args_a1(R9), R0       // a1\n\tMOVD syscall15Args_a2(R9), R1       // a2\n\tMOVD syscall15Args_a3(R9), R2       // a3\n\tMOVD syscall15Args_a4(R9), R3       // a4\n\tMOVD syscall15Args_a5(R9), R4       // a5\n\tMOVD syscall15Args_a6(R9), R5       // a6\n\tMOVD syscall15Args_a7(R9), R6       // a7\n\tMOVD syscall15Args_a8(R9), R7       // a8\n\tMOVD syscall15Args_arm64_r8(R9), R8 // r8\n\n\tMOVD syscall15Args_a9(R9), R10\n\tMOVD R10, 0(RSP)                // push a9 onto stack\n\tMOVD syscall15Args_a10(R9), R10\n\tMOVD R10, 8(RSP)                // push a10 onto stack\n\tMOVD syscall15Args_a11(R9), R10\n\tMOVD R10, 16(RSP)               // push a11 onto stack\n\tMOVD syscall15Args_a12(R9), R10\n\tMOVD R10, 24(RSP)               // push a12 onto stack\n\tMOVD syscall15Args_a13(R9), R10\n\tMOVD R10, 32(RSP)               // push a13 onto stack\n\tMOVD syscall15Args_a14(R9), R10\n\tMOVD R10, 40(RSP)               // push a14 onto stack\n\tMOVD syscall15Args_a15(R9), R10\n\tMOVD R10, 48(RSP)               // push a15 onto stack\n\n\tMOVD syscall15Args_fn(R9), R10 // fn\n\tBL   (R10)\n\n\tMOVD PTR_ADDRESS(RSP), R2 // pop structure pointer\n\tADD  $STACK_SIZE, RSP\n\n\tMOVD  R0, syscall15Args_a1(R2) // save r1\n\tMOVD  R1, syscall15Args_a2(R2) // save r3\n\tFMOVD F0, syscall15Args_f1(R2) // save f0\n\tFMOVD F1, syscall15Args_f2(R2) // save f1\n\tFMOVD F2, syscall15Args_f3(R2) // save f2\n\tFMOVD F3, syscall15Args_f4(R2) // save f3\n\n\tRET\n"
        },
        {
          "name": "sys_unix_arm64.s",
          "type": "blob",
          "size": 2.06640625,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2023 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux\n\n#include \"textflag.h\"\n#include \"go_asm.h\"\n#include \"funcdata.h\"\n#include \"abi_arm64.h\"\n\nTEXT callbackasm1(SB), NOSPLIT|NOFRAME, $0\n\tNO_LOCAL_POINTERS\n\n\t// On entry, the trampoline in zcallback_darwin_arm64.s left\n\t// the callback index in R12 (which is volatile in the C ABI).\n\n\t// Save callback register arguments R0-R7 and F0-F7.\n\t// We do this at the top of the frame so they're contiguous with stack arguments.\n\tSUB   $(16*8), RSP, R14\n\tFSTPD (F0, F1), (0*8)(R14)\n\tFSTPD (F2, F3), (2*8)(R14)\n\tFSTPD (F4, F5), (4*8)(R14)\n\tFSTPD (F6, F7), (6*8)(R14)\n\tSTP   (R0, R1), (8*8)(R14)\n\tSTP   (R2, R3), (10*8)(R14)\n\tSTP   (R4, R5), (12*8)(R14)\n\tSTP   (R6, R7), (14*8)(R14)\n\n\t// Adjust SP by frame size.\n\tSUB $(26*8), RSP\n\n\t// It is important to save R27 because the go assembler\n\t// uses it for move instructions for a variable.\n\t// This line:\n\t// MOVD callbackWrap_call(SB), R0\n\t// Creates the instructions:\n\t// ADRP 14335(PC), R27\n\t// MOVD 388(27), R0\n\t// R27 is a callee saved register so we are responsible\n\t// for ensuring its value doesn't change. So save it and\n\t// restore it at the end of this function.\n\t// R30 is the link register. crosscall2 doesn't save it\n\t// so it's saved here.\n\tSTP (R27, R30), 0(RSP)\n\n\t// Create a struct callbackArgs on our stack.\n\tMOVD $(callbackArgs__size)(RSP), R13\n\tMOVD R12, callbackArgs_index(R13)    // callback index\n\tMOVD R14, callbackArgs_args(R13)     // address of args vector\n\tMOVD ZR, callbackArgs_result(R13)    // result\n\n\t// Move parameters into registers\n\t// Get the ABIInternal function pointer\n\t// without <ABIInternal> by using a closure.\n\tMOVD callbackWrap_call(SB), R0\n\tMOVD (R0), R0                   // fn unsafe.Pointer\n\tMOVD R13, R1                    // frame (&callbackArgs{...})\n\tMOVD $0, R3                     // ctxt uintptr\n\n\tBL crosscall2(SB)\n\n\t// Get callback result.\n\tMOVD $(callbackArgs__size)(RSP), R13\n\tMOVD callbackArgs_result(R13), R0\n\n\t// Restore LR and R27\n\tLDP 0(RSP), (R27, R30)\n\tADD $(26*8), RSP\n\n\tRET\n"
        },
        {
          "name": "syscall.go",
          "type": "blob",
          "size": 2.138671875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || freebsd || linux || windows\n\npackage purego\n\n// CDecl marks a function as being called using the __cdecl calling convention as defined in\n// the [MSDocs] when passed to NewCallback. It must be the first argument to the function.\n// This is only useful on 386 Windows, but it is safe to use on other platforms.\n//\n// [MSDocs]: https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-170\ntype CDecl struct{}\n\nconst (\n\tmaxArgs     = 15\n\tnumOfFloats = 8 // arm64 and amd64 both have 8 float registers\n)\n\ntype syscall15Args struct {\n\tfn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr\n\tf1, f2, f3, f4, f5, f6, f7, f8                                       uintptr\n\tarm64_r8                                                             uintptr\n}\n\n// SyscallN takes fn, a C function pointer and a list of arguments as uintptr.\n// There is an internal maximum number of arguments that SyscallN can take. It panics\n// when the maximum is exceeded. It returns the result and the libc error code if there is one.\n//\n// NOTE: SyscallN does not properly call functions that have both integer and float parameters.\n// See discussion comment https://github.com/ebiten/purego/pull/1#issuecomment-1128057607\n// for an explanation of why that is.\n//\n// On amd64, if there are more than 8 floats the 9th and so on will be placed incorrectly on the\n// stack.\n//\n// The pragma go:nosplit is not needed at this function declaration because it uses go:uintptrescapes\n// which forces all the objects that the uintptrs point to onto the heap where a stack split won't affect\n// their memory location.\n//\n//go:uintptrescapes\nfunc SyscallN(fn uintptr, args ...uintptr) (r1, r2, err uintptr) {\n\tif fn == 0 {\n\t\tpanic(\"purego: fn is nil\")\n\t}\n\tif len(args) > maxArgs {\n\t\tpanic(\"purego: too many arguments to SyscallN\")\n\t}\n\t// add padding so there is no out-of-bounds slicing\n\tvar tmp [maxArgs]uintptr\n\tcopy(tmp[:], args)\n\treturn syscall_syscall15X(fn, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14])\n}\n"
        },
        {
          "name": "syscall_cgo_linux.go",
          "type": "blob",
          "size": 0.583984375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build cgo && !(amd64 || arm64)\n\npackage purego\n\nimport (\n\t\"github.com/ebitengine/purego/internal/cgo\"\n)\n\nvar syscall15XABI0 = uintptr(cgo.Syscall15XABI0)\n\n//go:nosplit\nfunc syscall_syscall15X(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2, err uintptr) {\n\treturn cgo.Syscall15X(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)\n}\n\nfunc NewCallback(_ any) uintptr {\n\tpanic(\"purego: NewCallback on Linux is only supported on amd64/arm64\")\n}\n"
        },
        {
          "name": "syscall_sysv.go",
          "type": "blob",
          "size": 6.7060546875,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\n//go:build darwin || freebsd || (linux && (amd64 || arm64))\n\npackage purego\n\nimport (\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\nvar syscall15XABI0 uintptr\n\n//go:nosplit\nfunc syscall_syscall15X(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2, err uintptr) {\n\targs := syscall15Args{\n\t\tfn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,\n\t\ta1, a2, a3, a4, a5, a6, a7, a8,\n\t\t0,\n\t}\n\truntime_cgocall(syscall15XABI0, unsafe.Pointer(&args))\n\treturn args.a1, args.a2, 0\n}\n\n// NewCallback converts a Go function to a function pointer conforming to the C calling convention.\n// This is useful when interoperating with C code requiring callbacks. The argument is expected to be a\n// function with zero or one uintptr-sized result. The function must not have arguments with size larger than the size\n// of uintptr. Only a limited number of callbacks may be created in a single Go process, and any memory allocated\n// for these callbacks is never released. At least 2000 callbacks can always be created. Although this function\n// provides similar functionality to windows.NewCallback it is distinct.\nfunc NewCallback(fn any) uintptr {\n\tty := reflect.TypeOf(fn)\n\tfor i := 0; i < ty.NumIn(); i++ {\n\t\tin := ty.In(i)\n\t\tif !in.AssignableTo(reflect.TypeOf(CDecl{})) {\n\t\t\tcontinue\n\t\t}\n\t\tif i != 0 {\n\t\t\tpanic(\"purego: CDecl must be the first argument\")\n\t\t}\n\t}\n\treturn compileCallback(fn)\n}\n\n// maxCb is the maximum number of callbacks\n// only increase this if you have added more to the callbackasm function\nconst maxCB = 2000\n\nvar cbs struct {\n\tlock  sync.Mutex\n\tnumFn int                  // the number of functions currently in cbs.funcs\n\tfuncs [maxCB]reflect.Value // the saved callbacks\n}\n\ntype callbackArgs struct {\n\tindex uintptr\n\t// args points to the argument block.\n\t//\n\t// The structure of the arguments goes\n\t// float registers followed by the\n\t// integer registers followed by the stack.\n\t//\n\t// This variable is treated as a continuous\n\t// block of memory containing all of the arguments\n\t// for this callback.\n\targs unsafe.Pointer\n\t// Below are out-args from callbackWrap\n\tresult uintptr\n}\n\nfunc compileCallback(fn any) uintptr {\n\tval := reflect.ValueOf(fn)\n\tif val.Kind() != reflect.Func {\n\t\tpanic(\"purego: the type must be a function but was not\")\n\t}\n\tif val.IsNil() {\n\t\tpanic(\"purego: function must not be nil\")\n\t}\n\tty := val.Type()\n\tfor i := 0; i < ty.NumIn(); i++ {\n\t\tin := ty.In(i)\n\t\tswitch in.Kind() {\n\t\tcase reflect.Struct:\n\t\t\tif i == 0 && in.AssignableTo(reflect.TypeOf(CDecl{})) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfallthrough\n\t\tcase reflect.Interface, reflect.Func, reflect.Slice,\n\t\t\treflect.Chan, reflect.Complex64, reflect.Complex128,\n\t\t\treflect.String, reflect.Map, reflect.Invalid:\n\t\t\tpanic(\"purego: unsupported argument type: \" + in.Kind().String())\n\t\t}\n\t}\noutput:\n\tswitch {\n\tcase ty.NumOut() == 1:\n\t\tswitch ty.Out(0).Kind() {\n\t\tcase reflect.Pointer, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,\n\t\t\treflect.Bool, reflect.UnsafePointer:\n\t\t\tbreak output\n\t\t}\n\t\tpanic(\"purego: unsupported return type: \" + ty.String())\n\tcase ty.NumOut() > 1:\n\t\tpanic(\"purego: callbacks can only have one return\")\n\t}\n\tcbs.lock.Lock()\n\tdefer cbs.lock.Unlock()\n\tif cbs.numFn >= maxCB {\n\t\tpanic(\"purego: the maximum number of callbacks has been reached\")\n\t}\n\tcbs.funcs[cbs.numFn] = val\n\tcbs.numFn++\n\treturn callbackasmAddr(cbs.numFn - 1)\n}\n\nconst ptrSize = unsafe.Sizeof((*int)(nil))\n\nconst callbackMaxFrame = 64 * ptrSize\n\n// callbackasm is implemented in zcallback_GOOS_GOARCH.s\n//\n//go:linkname __callbackasm callbackasm\nvar __callbackasm byte\nvar callbackasmABI0 = uintptr(unsafe.Pointer(&__callbackasm))\n\n// callbackWrap_call allows the calling of the ABIInternal wrapper\n// which is required for runtime.cgocallback without the\n// <ABIInternal> tag which is only allowed in the runtime.\n// This closure is used inside sys_darwin_GOARCH.s\nvar callbackWrap_call = callbackWrap\n\n// callbackWrap is called by assembly code which determines which Go function to call.\n// This function takes the arguments and passes them to the Go function and returns the result.\nfunc callbackWrap(a *callbackArgs) {\n\tcbs.lock.Lock()\n\tfn := cbs.funcs[a.index]\n\tcbs.lock.Unlock()\n\tfnType := fn.Type()\n\targs := make([]reflect.Value, fnType.NumIn())\n\tframe := (*[callbackMaxFrame]uintptr)(a.args)\n\tvar floatsN int // floatsN represents the number of float arguments processed\n\tvar intsN int   // intsN represents the number of integer arguments processed\n\t// stack points to the index into frame of the current stack element.\n\t// The stack begins after the float and integer registers.\n\tstack := numOfIntegerRegisters() + numOfFloats\n\tfor i := range args {\n\t\tvar pos int\n\t\tswitch fnType.In(i).Kind() {\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tif floatsN >= numOfFloats {\n\t\t\t\tpos = stack\n\t\t\t\tstack++\n\t\t\t} else {\n\t\t\t\tpos = floatsN\n\t\t\t}\n\t\t\tfloatsN++\n\t\tcase reflect.Struct:\n\t\t\t// This is the CDecl field\n\t\t\targs[i] = reflect.Zero(fnType.In(i))\n\t\t\tcontinue\n\t\tdefault:\n\n\t\t\tif intsN >= numOfIntegerRegisters() {\n\t\t\t\tpos = stack\n\t\t\t\tstack++\n\t\t\t} else {\n\t\t\t\t// the integers begin after the floats in frame\n\t\t\t\tpos = intsN + numOfFloats\n\t\t\t}\n\t\t\tintsN++\n\t\t}\n\t\targs[i] = reflect.NewAt(fnType.In(i), unsafe.Pointer(&frame[pos])).Elem()\n\t}\n\tret := fn.Call(args)\n\tif len(ret) > 0 {\n\t\tswitch k := ret[0].Kind(); k {\n\t\tcase reflect.Uint, reflect.Uint64, reflect.Uint32, reflect.Uint16, reflect.Uint8, reflect.Uintptr:\n\t\t\ta.result = uintptr(ret[0].Uint())\n\t\tcase reflect.Int, reflect.Int64, reflect.Int32, reflect.Int16, reflect.Int8:\n\t\t\ta.result = uintptr(ret[0].Int())\n\t\tcase reflect.Bool:\n\t\t\tif ret[0].Bool() {\n\t\t\t\ta.result = 1\n\t\t\t} else {\n\t\t\t\ta.result = 0\n\t\t\t}\n\t\tcase reflect.Pointer:\n\t\t\ta.result = ret[0].Pointer()\n\t\tcase reflect.UnsafePointer:\n\t\t\ta.result = ret[0].Pointer()\n\t\tdefault:\n\t\t\tpanic(\"purego: unsupported kind: \" + k.String())\n\t\t}\n\t}\n}\n\n// callbackasmAddr returns address of runtime.callbackasm\n// function adjusted by i.\n// On x86 and amd64, runtime.callbackasm is a series of CALL instructions,\n// and we want callback to arrive at\n// correspondent call instruction instead of start of\n// runtime.callbackasm.\n// On ARM, runtime.callbackasm is a series of mov and branch instructions.\n// R12 is loaded with the callback index. Each entry is two instructions,\n// hence 8 bytes.\nfunc callbackasmAddr(i int) uintptr {\n\tvar entrySize int\n\tswitch runtime.GOARCH {\n\tdefault:\n\t\tpanic(\"purego: unsupported architecture\")\n\tcase \"386\", \"amd64\":\n\t\tentrySize = 5\n\tcase \"arm\", \"arm64\":\n\t\t// On ARM and ARM64, each entry is a MOV instruction\n\t\t// followed by a branch instruction\n\t\tentrySize = 8\n\t}\n\treturn callbackasmABI0 + uintptr(i*entrySize)\n}\n"
        },
        {
          "name": "syscall_test.go",
          "type": "blob",
          "size": 0.4658203125,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2023 The Ebitengine Authors\n\npackage purego_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t_ \"github.com/ebitengine/purego\"\n)\n\nfunc TestOS(t *testing.T) {\n\t// set and unset an environment variable since this calls into fakecgo.\n\terr := os.Setenv(\"TESTING\", \"SOMETHING\")\n\tif err != nil {\n\t\tt.Errorf(\"failed to Setenv: %s\", err)\n\t}\n\terr = os.Unsetenv(\"TESTING\")\n\tif err != nil {\n\t\tt.Errorf(\"failed to Unsetenv: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "syscall_windows.go",
          "type": "blob",
          "size": 1.568359375,
          "content": "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 The Ebitengine Authors\n\npackage purego\n\nimport (\n\t\"reflect\"\n\t\"syscall\"\n)\n\nvar syscall15XABI0 uintptr\n\nfunc syscall_syscall15X(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2, err uintptr) {\n\tr1, r2, errno := syscall.Syscall15(fn, 15, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)\n\treturn r1, r2, uintptr(errno)\n}\n\n// NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.\n// This is useful when interoperating with Windows code requiring callbacks. The argument is expected to be a\n// function with one uintptr-sized result. The function must not have arguments with size larger than the\n// size of uintptr. Only a limited number of callbacks may be created in a single Go process, and any memory\n// allocated for these callbacks is never released. Between NewCallback and NewCallbackCDecl, at least 1024\n// callbacks can always be created. Although this function is similiar to the darwin version it may act\n// differently.\nfunc NewCallback(fn any) uintptr {\n\tisCDecl := false\n\tty := reflect.TypeOf(fn)\n\tfor i := 0; i < ty.NumIn(); i++ {\n\t\tin := ty.In(i)\n\t\tif !in.AssignableTo(reflect.TypeOf(CDecl{})) {\n\t\t\tcontinue\n\t\t}\n\t\tif i != 0 {\n\t\t\tpanic(\"purego: CDecl must be the first argument\")\n\t\t}\n\t\tisCDecl = true\n\t}\n\tif isCDecl {\n\t\treturn syscall.NewCallbackCDecl(fn)\n\t}\n\treturn syscall.NewCallback(fn)\n}\n\nfunc loadSymbol(handle uintptr, name string) (uintptr, error) {\n\treturn syscall.GetProcAddress(syscall.Handle(handle), name)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "zcallback_amd64.s",
          "type": "blob",
          "size": 45.484375,
          "content": "// Code generated by wincallback.go using 'go generate'. DO NOT EDIT.\n\n//go:build darwin || freebsd || linux\n\n// runtimecallbackasm is called by external code to\n// execute Go implemented callback function. It is not\n// called from the start, instead runtimecompilecallback\n// always returns address into runtimecallbackasm offset\n// appropriately so different callbacks start with different\n// CALL instruction in runtimecallbackasm. This determines\n// which Go callback function is executed later on.\n#include \"textflag.h\"\n\nTEXT callbackasm(SB), NOSPLIT|NOFRAME, $0\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n\tCALL callbackasm1(SB)\n"
        },
        {
          "name": "zcallback_arm64.s",
          "type": "blob",
          "size": 77.6357421875,
          "content": "// Code generated by wincallback.go using 'go generate'. DO NOT EDIT.\n\n//go:build darwin || freebsd || linux\n\n// External code calls into callbackasm at an offset corresponding\n// to the callback index. Callbackasm is a table of MOV and B instructions.\n// The MOV instruction loads R12 with the callback index, and the\n// B instruction branches to callbackasm1.\n// callbackasm1 takes the callback index from R12 and\n// indexes into an array that stores information about each callback.\n// It then calls the Go implementation for that callback.\n#include \"textflag.h\"\n\nTEXT callbackasm(SB), NOSPLIT|NOFRAME, $0\n\tMOVD $0, R12\n\tB    callbackasm1(SB)\n\tMOVD $1, R12\n\tB    callbackasm1(SB)\n\tMOVD $2, R12\n\tB    callbackasm1(SB)\n\tMOVD $3, R12\n\tB    callbackasm1(SB)\n\tMOVD $4, R12\n\tB    callbackasm1(SB)\n\tMOVD $5, R12\n\tB    callbackasm1(SB)\n\tMOVD $6, R12\n\tB    callbackasm1(SB)\n\tMOVD $7, R12\n\tB    callbackasm1(SB)\n\tMOVD $8, R12\n\tB    callbackasm1(SB)\n\tMOVD $9, R12\n\tB    callbackasm1(SB)\n\tMOVD $10, R12\n\tB    callbackasm1(SB)\n\tMOVD $11, R12\n\tB    callbackasm1(SB)\n\tMOVD $12, R12\n\tB    callbackasm1(SB)\n\tMOVD $13, R12\n\tB    callbackasm1(SB)\n\tMOVD $14, R12\n\tB    callbackasm1(SB)\n\tMOVD $15, R12\n\tB    callbackasm1(SB)\n\tMOVD $16, R12\n\tB    callbackasm1(SB)\n\tMOVD $17, R12\n\tB    callbackasm1(SB)\n\tMOVD $18, R12\n\tB    callbackasm1(SB)\n\tMOVD $19, R12\n\tB    callbackasm1(SB)\n\tMOVD $20, R12\n\tB    callbackasm1(SB)\n\tMOVD $21, R12\n\tB    callbackasm1(SB)\n\tMOVD $22, R12\n\tB    callbackasm1(SB)\n\tMOVD $23, R12\n\tB    callbackasm1(SB)\n\tMOVD $24, R12\n\tB    callbackasm1(SB)\n\tMOVD $25, R12\n\tB    callbackasm1(SB)\n\tMOVD $26, R12\n\tB    callbackasm1(SB)\n\tMOVD $27, R12\n\tB    callbackasm1(SB)\n\tMOVD $28, R12\n\tB    callbackasm1(SB)\n\tMOVD $29, R12\n\tB    callbackasm1(SB)\n\tMOVD $30, R12\n\tB    callbackasm1(SB)\n\tMOVD $31, R12\n\tB    callbackasm1(SB)\n\tMOVD $32, R12\n\tB    callbackasm1(SB)\n\tMOVD $33, R12\n\tB    callbackasm1(SB)\n\tMOVD $34, R12\n\tB    callbackasm1(SB)\n\tMOVD $35, R12\n\tB    callbackasm1(SB)\n\tMOVD $36, R12\n\tB    callbackasm1(SB)\n\tMOVD $37, R12\n\tB    callbackasm1(SB)\n\tMOVD $38, R12\n\tB    callbackasm1(SB)\n\tMOVD $39, R12\n\tB    callbackasm1(SB)\n\tMOVD $40, R12\n\tB    callbackasm1(SB)\n\tMOVD $41, R12\n\tB    callbackasm1(SB)\n\tMOVD $42, R12\n\tB    callbackasm1(SB)\n\tMOVD $43, R12\n\tB    callbackasm1(SB)\n\tMOVD $44, R12\n\tB    callbackasm1(SB)\n\tMOVD $45, R12\n\tB    callbackasm1(SB)\n\tMOVD $46, R12\n\tB    callbackasm1(SB)\n\tMOVD $47, R12\n\tB    callbackasm1(SB)\n\tMOVD $48, R12\n\tB    callbackasm1(SB)\n\tMOVD $49, R12\n\tB    callbackasm1(SB)\n\tMOVD $50, R12\n\tB    callbackasm1(SB)\n\tMOVD $51, R12\n\tB    callbackasm1(SB)\n\tMOVD $52, R12\n\tB    callbackasm1(SB)\n\tMOVD $53, R12\n\tB    callbackasm1(SB)\n\tMOVD $54, R12\n\tB    callbackasm1(SB)\n\tMOVD $55, R12\n\tB    callbackasm1(SB)\n\tMOVD $56, R12\n\tB    callbackasm1(SB)\n\tMOVD $57, R12\n\tB    callbackasm1(SB)\n\tMOVD $58, R12\n\tB    callbackasm1(SB)\n\tMOVD $59, R12\n\tB    callbackasm1(SB)\n\tMOVD $60, R12\n\tB    callbackasm1(SB)\n\tMOVD $61, R12\n\tB    callbackasm1(SB)\n\tMOVD $62, R12\n\tB    callbackasm1(SB)\n\tMOVD $63, R12\n\tB    callbackasm1(SB)\n\tMOVD $64, R12\n\tB    callbackasm1(SB)\n\tMOVD $65, R12\n\tB    callbackasm1(SB)\n\tMOVD $66, R12\n\tB    callbackasm1(SB)\n\tMOVD $67, R12\n\tB    callbackasm1(SB)\n\tMOVD $68, R12\n\tB    callbackasm1(SB)\n\tMOVD $69, R12\n\tB    callbackasm1(SB)\n\tMOVD $70, R12\n\tB    callbackasm1(SB)\n\tMOVD $71, R12\n\tB    callbackasm1(SB)\n\tMOVD $72, R12\n\tB    callbackasm1(SB)\n\tMOVD $73, R12\n\tB    callbackasm1(SB)\n\tMOVD $74, R12\n\tB    callbackasm1(SB)\n\tMOVD $75, R12\n\tB    callbackasm1(SB)\n\tMOVD $76, R12\n\tB    callbackasm1(SB)\n\tMOVD $77, R12\n\tB    callbackasm1(SB)\n\tMOVD $78, R12\n\tB    callbackasm1(SB)\n\tMOVD $79, R12\n\tB    callbackasm1(SB)\n\tMOVD $80, R12\n\tB    callbackasm1(SB)\n\tMOVD $81, R12\n\tB    callbackasm1(SB)\n\tMOVD $82, R12\n\tB    callbackasm1(SB)\n\tMOVD $83, R12\n\tB    callbackasm1(SB)\n\tMOVD $84, R12\n\tB    callbackasm1(SB)\n\tMOVD $85, R12\n\tB    callbackasm1(SB)\n\tMOVD $86, R12\n\tB    callbackasm1(SB)\n\tMOVD $87, R12\n\tB    callbackasm1(SB)\n\tMOVD $88, R12\n\tB    callbackasm1(SB)\n\tMOVD $89, R12\n\tB    callbackasm1(SB)\n\tMOVD $90, R12\n\tB    callbackasm1(SB)\n\tMOVD $91, R12\n\tB    callbackasm1(SB)\n\tMOVD $92, R12\n\tB    callbackasm1(SB)\n\tMOVD $93, R12\n\tB    callbackasm1(SB)\n\tMOVD $94, R12\n\tB    callbackasm1(SB)\n\tMOVD $95, R12\n\tB    callbackasm1(SB)\n\tMOVD $96, R12\n\tB    callbackasm1(SB)\n\tMOVD $97, R12\n\tB    callbackasm1(SB)\n\tMOVD $98, R12\n\tB    callbackasm1(SB)\n\tMOVD $99, R12\n\tB    callbackasm1(SB)\n\tMOVD $100, R12\n\tB    callbackasm1(SB)\n\tMOVD $101, R12\n\tB    callbackasm1(SB)\n\tMOVD $102, R12\n\tB    callbackasm1(SB)\n\tMOVD $103, R12\n\tB    callbackasm1(SB)\n\tMOVD $104, R12\n\tB    callbackasm1(SB)\n\tMOVD $105, R12\n\tB    callbackasm1(SB)\n\tMOVD $106, R12\n\tB    callbackasm1(SB)\n\tMOVD $107, R12\n\tB    callbackasm1(SB)\n\tMOVD $108, R12\n\tB    callbackasm1(SB)\n\tMOVD $109, R12\n\tB    callbackasm1(SB)\n\tMOVD $110, R12\n\tB    callbackasm1(SB)\n\tMOVD $111, R12\n\tB    callbackasm1(SB)\n\tMOVD $112, R12\n\tB    callbackasm1(SB)\n\tMOVD $113, R12\n\tB    callbackasm1(SB)\n\tMOVD $114, R12\n\tB    callbackasm1(SB)\n\tMOVD $115, R12\n\tB    callbackasm1(SB)\n\tMOVD $116, R12\n\tB    callbackasm1(SB)\n\tMOVD $117, R12\n\tB    callbackasm1(SB)\n\tMOVD $118, R12\n\tB    callbackasm1(SB)\n\tMOVD $119, R12\n\tB    callbackasm1(SB)\n\tMOVD $120, R12\n\tB    callbackasm1(SB)\n\tMOVD $121, R12\n\tB    callbackasm1(SB)\n\tMOVD $122, R12\n\tB    callbackasm1(SB)\n\tMOVD $123, R12\n\tB    callbackasm1(SB)\n\tMOVD $124, R12\n\tB    callbackasm1(SB)\n\tMOVD $125, R12\n\tB    callbackasm1(SB)\n\tMOVD $126, R12\n\tB    callbackasm1(SB)\n\tMOVD $127, R12\n\tB    callbackasm1(SB)\n\tMOVD $128, R12\n\tB    callbackasm1(SB)\n\tMOVD $129, R12\n\tB    callbackasm1(SB)\n\tMOVD $130, R12\n\tB    callbackasm1(SB)\n\tMOVD $131, R12\n\tB    callbackasm1(SB)\n\tMOVD $132, R12\n\tB    callbackasm1(SB)\n\tMOVD $133, R12\n\tB    callbackasm1(SB)\n\tMOVD $134, R12\n\tB    callbackasm1(SB)\n\tMOVD $135, R12\n\tB    callbackasm1(SB)\n\tMOVD $136, R12\n\tB    callbackasm1(SB)\n\tMOVD $137, R12\n\tB    callbackasm1(SB)\n\tMOVD $138, R12\n\tB    callbackasm1(SB)\n\tMOVD $139, R12\n\tB    callbackasm1(SB)\n\tMOVD $140, R12\n\tB    callbackasm1(SB)\n\tMOVD $141, R12\n\tB    callbackasm1(SB)\n\tMOVD $142, R12\n\tB    callbackasm1(SB)\n\tMOVD $143, R12\n\tB    callbackasm1(SB)\n\tMOVD $144, R12\n\tB    callbackasm1(SB)\n\tMOVD $145, R12\n\tB    callbackasm1(SB)\n\tMOVD $146, R12\n\tB    callbackasm1(SB)\n\tMOVD $147, R12\n\tB    callbackasm1(SB)\n\tMOVD $148, R12\n\tB    callbackasm1(SB)\n\tMOVD $149, R12\n\tB    callbackasm1(SB)\n\tMOVD $150, R12\n\tB    callbackasm1(SB)\n\tMOVD $151, R12\n\tB    callbackasm1(SB)\n\tMOVD $152, R12\n\tB    callbackasm1(SB)\n\tMOVD $153, R12\n\tB    callbackasm1(SB)\n\tMOVD $154, R12\n\tB    callbackasm1(SB)\n\tMOVD $155, R12\n\tB    callbackasm1(SB)\n\tMOVD $156, R12\n\tB    callbackasm1(SB)\n\tMOVD $157, R12\n\tB    callbackasm1(SB)\n\tMOVD $158, R12\n\tB    callbackasm1(SB)\n\tMOVD $159, R12\n\tB    callbackasm1(SB)\n\tMOVD $160, R12\n\tB    callbackasm1(SB)\n\tMOVD $161, R12\n\tB    callbackasm1(SB)\n\tMOVD $162, R12\n\tB    callbackasm1(SB)\n\tMOVD $163, R12\n\tB    callbackasm1(SB)\n\tMOVD $164, R12\n\tB    callbackasm1(SB)\n\tMOVD $165, R12\n\tB    callbackasm1(SB)\n\tMOVD $166, R12\n\tB    callbackasm1(SB)\n\tMOVD $167, R12\n\tB    callbackasm1(SB)\n\tMOVD $168, R12\n\tB    callbackasm1(SB)\n\tMOVD $169, R12\n\tB    callbackasm1(SB)\n\tMOVD $170, R12\n\tB    callbackasm1(SB)\n\tMOVD $171, R12\n\tB    callbackasm1(SB)\n\tMOVD $172, R12\n\tB    callbackasm1(SB)\n\tMOVD $173, R12\n\tB    callbackasm1(SB)\n\tMOVD $174, R12\n\tB    callbackasm1(SB)\n\tMOVD $175, R12\n\tB    callbackasm1(SB)\n\tMOVD $176, R12\n\tB    callbackasm1(SB)\n\tMOVD $177, R12\n\tB    callbackasm1(SB)\n\tMOVD $178, R12\n\tB    callbackasm1(SB)\n\tMOVD $179, R12\n\tB    callbackasm1(SB)\n\tMOVD $180, R12\n\tB    callbackasm1(SB)\n\tMOVD $181, R12\n\tB    callbackasm1(SB)\n\tMOVD $182, R12\n\tB    callbackasm1(SB)\n\tMOVD $183, R12\n\tB    callbackasm1(SB)\n\tMOVD $184, R12\n\tB    callbackasm1(SB)\n\tMOVD $185, R12\n\tB    callbackasm1(SB)\n\tMOVD $186, R12\n\tB    callbackasm1(SB)\n\tMOVD $187, R12\n\tB    callbackasm1(SB)\n\tMOVD $188, R12\n\tB    callbackasm1(SB)\n\tMOVD $189, R12\n\tB    callbackasm1(SB)\n\tMOVD $190, R12\n\tB    callbackasm1(SB)\n\tMOVD $191, R12\n\tB    callbackasm1(SB)\n\tMOVD $192, R12\n\tB    callbackasm1(SB)\n\tMOVD $193, R12\n\tB    callbackasm1(SB)\n\tMOVD $194, R12\n\tB    callbackasm1(SB)\n\tMOVD $195, R12\n\tB    callbackasm1(SB)\n\tMOVD $196, R12\n\tB    callbackasm1(SB)\n\tMOVD $197, R12\n\tB    callbackasm1(SB)\n\tMOVD $198, R12\n\tB    callbackasm1(SB)\n\tMOVD $199, R12\n\tB    callbackasm1(SB)\n\tMOVD $200, R12\n\tB    callbackasm1(SB)\n\tMOVD $201, R12\n\tB    callbackasm1(SB)\n\tMOVD $202, R12\n\tB    callbackasm1(SB)\n\tMOVD $203, R12\n\tB    callbackasm1(SB)\n\tMOVD $204, R12\n\tB    callbackasm1(SB)\n\tMOVD $205, R12\n\tB    callbackasm1(SB)\n\tMOVD $206, R12\n\tB    callbackasm1(SB)\n\tMOVD $207, R12\n\tB    callbackasm1(SB)\n\tMOVD $208, R12\n\tB    callbackasm1(SB)\n\tMOVD $209, R12\n\tB    callbackasm1(SB)\n\tMOVD $210, R12\n\tB    callbackasm1(SB)\n\tMOVD $211, R12\n\tB    callbackasm1(SB)\n\tMOVD $212, R12\n\tB    callbackasm1(SB)\n\tMOVD $213, R12\n\tB    callbackasm1(SB)\n\tMOVD $214, R12\n\tB    callbackasm1(SB)\n\tMOVD $215, R12\n\tB    callbackasm1(SB)\n\tMOVD $216, R12\n\tB    callbackasm1(SB)\n\tMOVD $217, R12\n\tB    callbackasm1(SB)\n\tMOVD $218, R12\n\tB    callbackasm1(SB)\n\tMOVD $219, R12\n\tB    callbackasm1(SB)\n\tMOVD $220, R12\n\tB    callbackasm1(SB)\n\tMOVD $221, R12\n\tB    callbackasm1(SB)\n\tMOVD $222, R12\n\tB    callbackasm1(SB)\n\tMOVD $223, R12\n\tB    callbackasm1(SB)\n\tMOVD $224, R12\n\tB    callbackasm1(SB)\n\tMOVD $225, R12\n\tB    callbackasm1(SB)\n\tMOVD $226, R12\n\tB    callbackasm1(SB)\n\tMOVD $227, R12\n\tB    callbackasm1(SB)\n\tMOVD $228, R12\n\tB    callbackasm1(SB)\n\tMOVD $229, R12\n\tB    callbackasm1(SB)\n\tMOVD $230, R12\n\tB    callbackasm1(SB)\n\tMOVD $231, R12\n\tB    callbackasm1(SB)\n\tMOVD $232, R12\n\tB    callbackasm1(SB)\n\tMOVD $233, R12\n\tB    callbackasm1(SB)\n\tMOVD $234, R12\n\tB    callbackasm1(SB)\n\tMOVD $235, R12\n\tB    callbackasm1(SB)\n\tMOVD $236, R12\n\tB    callbackasm1(SB)\n\tMOVD $237, R12\n\tB    callbackasm1(SB)\n\tMOVD $238, R12\n\tB    callbackasm1(SB)\n\tMOVD $239, R12\n\tB    callbackasm1(SB)\n\tMOVD $240, R12\n\tB    callbackasm1(SB)\n\tMOVD $241, R12\n\tB    callbackasm1(SB)\n\tMOVD $242, R12\n\tB    callbackasm1(SB)\n\tMOVD $243, R12\n\tB    callbackasm1(SB)\n\tMOVD $244, R12\n\tB    callbackasm1(SB)\n\tMOVD $245, R12\n\tB    callbackasm1(SB)\n\tMOVD $246, R12\n\tB    callbackasm1(SB)\n\tMOVD $247, R12\n\tB    callbackasm1(SB)\n\tMOVD $248, R12\n\tB    callbackasm1(SB)\n\tMOVD $249, R12\n\tB    callbackasm1(SB)\n\tMOVD $250, R12\n\tB    callbackasm1(SB)\n\tMOVD $251, R12\n\tB    callbackasm1(SB)\n\tMOVD $252, R12\n\tB    callbackasm1(SB)\n\tMOVD $253, R12\n\tB    callbackasm1(SB)\n\tMOVD $254, R12\n\tB    callbackasm1(SB)\n\tMOVD $255, R12\n\tB    callbackasm1(SB)\n\tMOVD $256, R12\n\tB    callbackasm1(SB)\n\tMOVD $257, R12\n\tB    callbackasm1(SB)\n\tMOVD $258, R12\n\tB    callbackasm1(SB)\n\tMOVD $259, R12\n\tB    callbackasm1(SB)\n\tMOVD $260, R12\n\tB    callbackasm1(SB)\n\tMOVD $261, R12\n\tB    callbackasm1(SB)\n\tMOVD $262, R12\n\tB    callbackasm1(SB)\n\tMOVD $263, R12\n\tB    callbackasm1(SB)\n\tMOVD $264, R12\n\tB    callbackasm1(SB)\n\tMOVD $265, R12\n\tB    callbackasm1(SB)\n\tMOVD $266, R12\n\tB    callbackasm1(SB)\n\tMOVD $267, R12\n\tB    callbackasm1(SB)\n\tMOVD $268, R12\n\tB    callbackasm1(SB)\n\tMOVD $269, R12\n\tB    callbackasm1(SB)\n\tMOVD $270, R12\n\tB    callbackasm1(SB)\n\tMOVD $271, R12\n\tB    callbackasm1(SB)\n\tMOVD $272, R12\n\tB    callbackasm1(SB)\n\tMOVD $273, R12\n\tB    callbackasm1(SB)\n\tMOVD $274, R12\n\tB    callbackasm1(SB)\n\tMOVD $275, R12\n\tB    callbackasm1(SB)\n\tMOVD $276, R12\n\tB    callbackasm1(SB)\n\tMOVD $277, R12\n\tB    callbackasm1(SB)\n\tMOVD $278, R12\n\tB    callbackasm1(SB)\n\tMOVD $279, R12\n\tB    callbackasm1(SB)\n\tMOVD $280, R12\n\tB    callbackasm1(SB)\n\tMOVD $281, R12\n\tB    callbackasm1(SB)\n\tMOVD $282, R12\n\tB    callbackasm1(SB)\n\tMOVD $283, R12\n\tB    callbackasm1(SB)\n\tMOVD $284, R12\n\tB    callbackasm1(SB)\n\tMOVD $285, R12\n\tB    callbackasm1(SB)\n\tMOVD $286, R12\n\tB    callbackasm1(SB)\n\tMOVD $287, R12\n\tB    callbackasm1(SB)\n\tMOVD $288, R12\n\tB    callbackasm1(SB)\n\tMOVD $289, R12\n\tB    callbackasm1(SB)\n\tMOVD $290, R12\n\tB    callbackasm1(SB)\n\tMOVD $291, R12\n\tB    callbackasm1(SB)\n\tMOVD $292, R12\n\tB    callbackasm1(SB)\n\tMOVD $293, R12\n\tB    callbackasm1(SB)\n\tMOVD $294, R12\n\tB    callbackasm1(SB)\n\tMOVD $295, R12\n\tB    callbackasm1(SB)\n\tMOVD $296, R12\n\tB    callbackasm1(SB)\n\tMOVD $297, R12\n\tB    callbackasm1(SB)\n\tMOVD $298, R12\n\tB    callbackasm1(SB)\n\tMOVD $299, R12\n\tB    callbackasm1(SB)\n\tMOVD $300, R12\n\tB    callbackasm1(SB)\n\tMOVD $301, R12\n\tB    callbackasm1(SB)\n\tMOVD $302, R12\n\tB    callbackasm1(SB)\n\tMOVD $303, R12\n\tB    callbackasm1(SB)\n\tMOVD $304, R12\n\tB    callbackasm1(SB)\n\tMOVD $305, R12\n\tB    callbackasm1(SB)\n\tMOVD $306, R12\n\tB    callbackasm1(SB)\n\tMOVD $307, R12\n\tB    callbackasm1(SB)\n\tMOVD $308, R12\n\tB    callbackasm1(SB)\n\tMOVD $309, R12\n\tB    callbackasm1(SB)\n\tMOVD $310, R12\n\tB    callbackasm1(SB)\n\tMOVD $311, R12\n\tB    callbackasm1(SB)\n\tMOVD $312, R12\n\tB    callbackasm1(SB)\n\tMOVD $313, R12\n\tB    callbackasm1(SB)\n\tMOVD $314, R12\n\tB    callbackasm1(SB)\n\tMOVD $315, R12\n\tB    callbackasm1(SB)\n\tMOVD $316, R12\n\tB    callbackasm1(SB)\n\tMOVD $317, R12\n\tB    callbackasm1(SB)\n\tMOVD $318, R12\n\tB    callbackasm1(SB)\n\tMOVD $319, R12\n\tB    callbackasm1(SB)\n\tMOVD $320, R12\n\tB    callbackasm1(SB)\n\tMOVD $321, R12\n\tB    callbackasm1(SB)\n\tMOVD $322, R12\n\tB    callbackasm1(SB)\n\tMOVD $323, R12\n\tB    callbackasm1(SB)\n\tMOVD $324, R12\n\tB    callbackasm1(SB)\n\tMOVD $325, R12\n\tB    callbackasm1(SB)\n\tMOVD $326, R12\n\tB    callbackasm1(SB)\n\tMOVD $327, R12\n\tB    callbackasm1(SB)\n\tMOVD $328, R12\n\tB    callbackasm1(SB)\n\tMOVD $329, R12\n\tB    callbackasm1(SB)\n\tMOVD $330, R12\n\tB    callbackasm1(SB)\n\tMOVD $331, R12\n\tB    callbackasm1(SB)\n\tMOVD $332, R12\n\tB    callbackasm1(SB)\n\tMOVD $333, R12\n\tB    callbackasm1(SB)\n\tMOVD $334, R12\n\tB    callbackasm1(SB)\n\tMOVD $335, R12\n\tB    callbackasm1(SB)\n\tMOVD $336, R12\n\tB    callbackasm1(SB)\n\tMOVD $337, R12\n\tB    callbackasm1(SB)\n\tMOVD $338, R12\n\tB    callbackasm1(SB)\n\tMOVD $339, R12\n\tB    callbackasm1(SB)\n\tMOVD $340, R12\n\tB    callbackasm1(SB)\n\tMOVD $341, R12\n\tB    callbackasm1(SB)\n\tMOVD $342, R12\n\tB    callbackasm1(SB)\n\tMOVD $343, R12\n\tB    callbackasm1(SB)\n\tMOVD $344, R12\n\tB    callbackasm1(SB)\n\tMOVD $345, R12\n\tB    callbackasm1(SB)\n\tMOVD $346, R12\n\tB    callbackasm1(SB)\n\tMOVD $347, R12\n\tB    callbackasm1(SB)\n\tMOVD $348, R12\n\tB    callbackasm1(SB)\n\tMOVD $349, R12\n\tB    callbackasm1(SB)\n\tMOVD $350, R12\n\tB    callbackasm1(SB)\n\tMOVD $351, R12\n\tB    callbackasm1(SB)\n\tMOVD $352, R12\n\tB    callbackasm1(SB)\n\tMOVD $353, R12\n\tB    callbackasm1(SB)\n\tMOVD $354, R12\n\tB    callbackasm1(SB)\n\tMOVD $355, R12\n\tB    callbackasm1(SB)\n\tMOVD $356, R12\n\tB    callbackasm1(SB)\n\tMOVD $357, R12\n\tB    callbackasm1(SB)\n\tMOVD $358, R12\n\tB    callbackasm1(SB)\n\tMOVD $359, R12\n\tB    callbackasm1(SB)\n\tMOVD $360, R12\n\tB    callbackasm1(SB)\n\tMOVD $361, R12\n\tB    callbackasm1(SB)\n\tMOVD $362, R12\n\tB    callbackasm1(SB)\n\tMOVD $363, R12\n\tB    callbackasm1(SB)\n\tMOVD $364, R12\n\tB    callbackasm1(SB)\n\tMOVD $365, R12\n\tB    callbackasm1(SB)\n\tMOVD $366, R12\n\tB    callbackasm1(SB)\n\tMOVD $367, R12\n\tB    callbackasm1(SB)\n\tMOVD $368, R12\n\tB    callbackasm1(SB)\n\tMOVD $369, R12\n\tB    callbackasm1(SB)\n\tMOVD $370, R12\n\tB    callbackasm1(SB)\n\tMOVD $371, R12\n\tB    callbackasm1(SB)\n\tMOVD $372, R12\n\tB    callbackasm1(SB)\n\tMOVD $373, R12\n\tB    callbackasm1(SB)\n\tMOVD $374, R12\n\tB    callbackasm1(SB)\n\tMOVD $375, R12\n\tB    callbackasm1(SB)\n\tMOVD $376, R12\n\tB    callbackasm1(SB)\n\tMOVD $377, R12\n\tB    callbackasm1(SB)\n\tMOVD $378, R12\n\tB    callbackasm1(SB)\n\tMOVD $379, R12\n\tB    callbackasm1(SB)\n\tMOVD $380, R12\n\tB    callbackasm1(SB)\n\tMOVD $381, R12\n\tB    callbackasm1(SB)\n\tMOVD $382, R12\n\tB    callbackasm1(SB)\n\tMOVD $383, R12\n\tB    callbackasm1(SB)\n\tMOVD $384, R12\n\tB    callbackasm1(SB)\n\tMOVD $385, R12\n\tB    callbackasm1(SB)\n\tMOVD $386, R12\n\tB    callbackasm1(SB)\n\tMOVD $387, R12\n\tB    callbackasm1(SB)\n\tMOVD $388, R12\n\tB    callbackasm1(SB)\n\tMOVD $389, R12\n\tB    callbackasm1(SB)\n\tMOVD $390, R12\n\tB    callbackasm1(SB)\n\tMOVD $391, R12\n\tB    callbackasm1(SB)\n\tMOVD $392, R12\n\tB    callbackasm1(SB)\n\tMOVD $393, R12\n\tB    callbackasm1(SB)\n\tMOVD $394, R12\n\tB    callbackasm1(SB)\n\tMOVD $395, R12\n\tB    callbackasm1(SB)\n\tMOVD $396, R12\n\tB    callbackasm1(SB)\n\tMOVD $397, R12\n\tB    callbackasm1(SB)\n\tMOVD $398, R12\n\tB    callbackasm1(SB)\n\tMOVD $399, R12\n\tB    callbackasm1(SB)\n\tMOVD $400, R12\n\tB    callbackasm1(SB)\n\tMOVD $401, R12\n\tB    callbackasm1(SB)\n\tMOVD $402, R12\n\tB    callbackasm1(SB)\n\tMOVD $403, R12\n\tB    callbackasm1(SB)\n\tMOVD $404, R12\n\tB    callbackasm1(SB)\n\tMOVD $405, R12\n\tB    callbackasm1(SB)\n\tMOVD $406, R12\n\tB    callbackasm1(SB)\n\tMOVD $407, R12\n\tB    callbackasm1(SB)\n\tMOVD $408, R12\n\tB    callbackasm1(SB)\n\tMOVD $409, R12\n\tB    callbackasm1(SB)\n\tMOVD $410, R12\n\tB    callbackasm1(SB)\n\tMOVD $411, R12\n\tB    callbackasm1(SB)\n\tMOVD $412, R12\n\tB    callbackasm1(SB)\n\tMOVD $413, R12\n\tB    callbackasm1(SB)\n\tMOVD $414, R12\n\tB    callbackasm1(SB)\n\tMOVD $415, R12\n\tB    callbackasm1(SB)\n\tMOVD $416, R12\n\tB    callbackasm1(SB)\n\tMOVD $417, R12\n\tB    callbackasm1(SB)\n\tMOVD $418, R12\n\tB    callbackasm1(SB)\n\tMOVD $419, R12\n\tB    callbackasm1(SB)\n\tMOVD $420, R12\n\tB    callbackasm1(SB)\n\tMOVD $421, R12\n\tB    callbackasm1(SB)\n\tMOVD $422, R12\n\tB    callbackasm1(SB)\n\tMOVD $423, R12\n\tB    callbackasm1(SB)\n\tMOVD $424, R12\n\tB    callbackasm1(SB)\n\tMOVD $425, R12\n\tB    callbackasm1(SB)\n\tMOVD $426, R12\n\tB    callbackasm1(SB)\n\tMOVD $427, R12\n\tB    callbackasm1(SB)\n\tMOVD $428, R12\n\tB    callbackasm1(SB)\n\tMOVD $429, R12\n\tB    callbackasm1(SB)\n\tMOVD $430, R12\n\tB    callbackasm1(SB)\n\tMOVD $431, R12\n\tB    callbackasm1(SB)\n\tMOVD $432, R12\n\tB    callbackasm1(SB)\n\tMOVD $433, R12\n\tB    callbackasm1(SB)\n\tMOVD $434, R12\n\tB    callbackasm1(SB)\n\tMOVD $435, R12\n\tB    callbackasm1(SB)\n\tMOVD $436, R12\n\tB    callbackasm1(SB)\n\tMOVD $437, R12\n\tB    callbackasm1(SB)\n\tMOVD $438, R12\n\tB    callbackasm1(SB)\n\tMOVD $439, R12\n\tB    callbackasm1(SB)\n\tMOVD $440, R12\n\tB    callbackasm1(SB)\n\tMOVD $441, R12\n\tB    callbackasm1(SB)\n\tMOVD $442, R12\n\tB    callbackasm1(SB)\n\tMOVD $443, R12\n\tB    callbackasm1(SB)\n\tMOVD $444, R12\n\tB    callbackasm1(SB)\n\tMOVD $445, R12\n\tB    callbackasm1(SB)\n\tMOVD $446, R12\n\tB    callbackasm1(SB)\n\tMOVD $447, R12\n\tB    callbackasm1(SB)\n\tMOVD $448, R12\n\tB    callbackasm1(SB)\n\tMOVD $449, R12\n\tB    callbackasm1(SB)\n\tMOVD $450, R12\n\tB    callbackasm1(SB)\n\tMOVD $451, R12\n\tB    callbackasm1(SB)\n\tMOVD $452, R12\n\tB    callbackasm1(SB)\n\tMOVD $453, R12\n\tB    callbackasm1(SB)\n\tMOVD $454, R12\n\tB    callbackasm1(SB)\n\tMOVD $455, R12\n\tB    callbackasm1(SB)\n\tMOVD $456, R12\n\tB    callbackasm1(SB)\n\tMOVD $457, R12\n\tB    callbackasm1(SB)\n\tMOVD $458, R12\n\tB    callbackasm1(SB)\n\tMOVD $459, R12\n\tB    callbackasm1(SB)\n\tMOVD $460, R12\n\tB    callbackasm1(SB)\n\tMOVD $461, R12\n\tB    callbackasm1(SB)\n\tMOVD $462, R12\n\tB    callbackasm1(SB)\n\tMOVD $463, R12\n\tB    callbackasm1(SB)\n\tMOVD $464, R12\n\tB    callbackasm1(SB)\n\tMOVD $465, R12\n\tB    callbackasm1(SB)\n\tMOVD $466, R12\n\tB    callbackasm1(SB)\n\tMOVD $467, R12\n\tB    callbackasm1(SB)\n\tMOVD $468, R12\n\tB    callbackasm1(SB)\n\tMOVD $469, R12\n\tB    callbackasm1(SB)\n\tMOVD $470, R12\n\tB    callbackasm1(SB)\n\tMOVD $471, R12\n\tB    callbackasm1(SB)\n\tMOVD $472, R12\n\tB    callbackasm1(SB)\n\tMOVD $473, R12\n\tB    callbackasm1(SB)\n\tMOVD $474, R12\n\tB    callbackasm1(SB)\n\tMOVD $475, R12\n\tB    callbackasm1(SB)\n\tMOVD $476, R12\n\tB    callbackasm1(SB)\n\tMOVD $477, R12\n\tB    callbackasm1(SB)\n\tMOVD $478, R12\n\tB    callbackasm1(SB)\n\tMOVD $479, R12\n\tB    callbackasm1(SB)\n\tMOVD $480, R12\n\tB    callbackasm1(SB)\n\tMOVD $481, R12\n\tB    callbackasm1(SB)\n\tMOVD $482, R12\n\tB    callbackasm1(SB)\n\tMOVD $483, R12\n\tB    callbackasm1(SB)\n\tMOVD $484, R12\n\tB    callbackasm1(SB)\n\tMOVD $485, R12\n\tB    callbackasm1(SB)\n\tMOVD $486, R12\n\tB    callbackasm1(SB)\n\tMOVD $487, R12\n\tB    callbackasm1(SB)\n\tMOVD $488, R12\n\tB    callbackasm1(SB)\n\tMOVD $489, R12\n\tB    callbackasm1(SB)\n\tMOVD $490, R12\n\tB    callbackasm1(SB)\n\tMOVD $491, R12\n\tB    callbackasm1(SB)\n\tMOVD $492, R12\n\tB    callbackasm1(SB)\n\tMOVD $493, R12\n\tB    callbackasm1(SB)\n\tMOVD $494, R12\n\tB    callbackasm1(SB)\n\tMOVD $495, R12\n\tB    callbackasm1(SB)\n\tMOVD $496, R12\n\tB    callbackasm1(SB)\n\tMOVD $497, R12\n\tB    callbackasm1(SB)\n\tMOVD $498, R12\n\tB    callbackasm1(SB)\n\tMOVD $499, R12\n\tB    callbackasm1(SB)\n\tMOVD $500, R12\n\tB    callbackasm1(SB)\n\tMOVD $501, R12\n\tB    callbackasm1(SB)\n\tMOVD $502, R12\n\tB    callbackasm1(SB)\n\tMOVD $503, R12\n\tB    callbackasm1(SB)\n\tMOVD $504, R12\n\tB    callbackasm1(SB)\n\tMOVD $505, R12\n\tB    callbackasm1(SB)\n\tMOVD $506, R12\n\tB    callbackasm1(SB)\n\tMOVD $507, R12\n\tB    callbackasm1(SB)\n\tMOVD $508, R12\n\tB    callbackasm1(SB)\n\tMOVD $509, R12\n\tB    callbackasm1(SB)\n\tMOVD $510, R12\n\tB    callbackasm1(SB)\n\tMOVD $511, R12\n\tB    callbackasm1(SB)\n\tMOVD $512, R12\n\tB    callbackasm1(SB)\n\tMOVD $513, R12\n\tB    callbackasm1(SB)\n\tMOVD $514, R12\n\tB    callbackasm1(SB)\n\tMOVD $515, R12\n\tB    callbackasm1(SB)\n\tMOVD $516, R12\n\tB    callbackasm1(SB)\n\tMOVD $517, R12\n\tB    callbackasm1(SB)\n\tMOVD $518, R12\n\tB    callbackasm1(SB)\n\tMOVD $519, R12\n\tB    callbackasm1(SB)\n\tMOVD $520, R12\n\tB    callbackasm1(SB)\n\tMOVD $521, R12\n\tB    callbackasm1(SB)\n\tMOVD $522, R12\n\tB    callbackasm1(SB)\n\tMOVD $523, R12\n\tB    callbackasm1(SB)\n\tMOVD $524, R12\n\tB    callbackasm1(SB)\n\tMOVD $525, R12\n\tB    callbackasm1(SB)\n\tMOVD $526, R12\n\tB    callbackasm1(SB)\n\tMOVD $527, R12\n\tB    callbackasm1(SB)\n\tMOVD $528, R12\n\tB    callbackasm1(SB)\n\tMOVD $529, R12\n\tB    callbackasm1(SB)\n\tMOVD $530, R12\n\tB    callbackasm1(SB)\n\tMOVD $531, R12\n\tB    callbackasm1(SB)\n\tMOVD $532, R12\n\tB    callbackasm1(SB)\n\tMOVD $533, R12\n\tB    callbackasm1(SB)\n\tMOVD $534, R12\n\tB    callbackasm1(SB)\n\tMOVD $535, R12\n\tB    callbackasm1(SB)\n\tMOVD $536, R12\n\tB    callbackasm1(SB)\n\tMOVD $537, R12\n\tB    callbackasm1(SB)\n\tMOVD $538, R12\n\tB    callbackasm1(SB)\n\tMOVD $539, R12\n\tB    callbackasm1(SB)\n\tMOVD $540, R12\n\tB    callbackasm1(SB)\n\tMOVD $541, R12\n\tB    callbackasm1(SB)\n\tMOVD $542, R12\n\tB    callbackasm1(SB)\n\tMOVD $543, R12\n\tB    callbackasm1(SB)\n\tMOVD $544, R12\n\tB    callbackasm1(SB)\n\tMOVD $545, R12\n\tB    callbackasm1(SB)\n\tMOVD $546, R12\n\tB    callbackasm1(SB)\n\tMOVD $547, R12\n\tB    callbackasm1(SB)\n\tMOVD $548, R12\n\tB    callbackasm1(SB)\n\tMOVD $549, R12\n\tB    callbackasm1(SB)\n\tMOVD $550, R12\n\tB    callbackasm1(SB)\n\tMOVD $551, R12\n\tB    callbackasm1(SB)\n\tMOVD $552, R12\n\tB    callbackasm1(SB)\n\tMOVD $553, R12\n\tB    callbackasm1(SB)\n\tMOVD $554, R12\n\tB    callbackasm1(SB)\n\tMOVD $555, R12\n\tB    callbackasm1(SB)\n\tMOVD $556, R12\n\tB    callbackasm1(SB)\n\tMOVD $557, R12\n\tB    callbackasm1(SB)\n\tMOVD $558, R12\n\tB    callbackasm1(SB)\n\tMOVD $559, R12\n\tB    callbackasm1(SB)\n\tMOVD $560, R12\n\tB    callbackasm1(SB)\n\tMOVD $561, R12\n\tB    callbackasm1(SB)\n\tMOVD $562, R12\n\tB    callbackasm1(SB)\n\tMOVD $563, R12\n\tB    callbackasm1(SB)\n\tMOVD $564, R12\n\tB    callbackasm1(SB)\n\tMOVD $565, R12\n\tB    callbackasm1(SB)\n\tMOVD $566, R12\n\tB    callbackasm1(SB)\n\tMOVD $567, R12\n\tB    callbackasm1(SB)\n\tMOVD $568, R12\n\tB    callbackasm1(SB)\n\tMOVD $569, R12\n\tB    callbackasm1(SB)\n\tMOVD $570, R12\n\tB    callbackasm1(SB)\n\tMOVD $571, R12\n\tB    callbackasm1(SB)\n\tMOVD $572, R12\n\tB    callbackasm1(SB)\n\tMOVD $573, R12\n\tB    callbackasm1(SB)\n\tMOVD $574, R12\n\tB    callbackasm1(SB)\n\tMOVD $575, R12\n\tB    callbackasm1(SB)\n\tMOVD $576, R12\n\tB    callbackasm1(SB)\n\tMOVD $577, R12\n\tB    callbackasm1(SB)\n\tMOVD $578, R12\n\tB    callbackasm1(SB)\n\tMOVD $579, R12\n\tB    callbackasm1(SB)\n\tMOVD $580, R12\n\tB    callbackasm1(SB)\n\tMOVD $581, R12\n\tB    callbackasm1(SB)\n\tMOVD $582, R12\n\tB    callbackasm1(SB)\n\tMOVD $583, R12\n\tB    callbackasm1(SB)\n\tMOVD $584, R12\n\tB    callbackasm1(SB)\n\tMOVD $585, R12\n\tB    callbackasm1(SB)\n\tMOVD $586, R12\n\tB    callbackasm1(SB)\n\tMOVD $587, R12\n\tB    callbackasm1(SB)\n\tMOVD $588, R12\n\tB    callbackasm1(SB)\n\tMOVD $589, R12\n\tB    callbackasm1(SB)\n\tMOVD $590, R12\n\tB    callbackasm1(SB)\n\tMOVD $591, R12\n\tB    callbackasm1(SB)\n\tMOVD $592, R12\n\tB    callbackasm1(SB)\n\tMOVD $593, R12\n\tB    callbackasm1(SB)\n\tMOVD $594, R12\n\tB    callbackasm1(SB)\n\tMOVD $595, R12\n\tB    callbackasm1(SB)\n\tMOVD $596, R12\n\tB    callbackasm1(SB)\n\tMOVD $597, R12\n\tB    callbackasm1(SB)\n\tMOVD $598, R12\n\tB    callbackasm1(SB)\n\tMOVD $599, R12\n\tB    callbackasm1(SB)\n\tMOVD $600, R12\n\tB    callbackasm1(SB)\n\tMOVD $601, R12\n\tB    callbackasm1(SB)\n\tMOVD $602, R12\n\tB    callbackasm1(SB)\n\tMOVD $603, R12\n\tB    callbackasm1(SB)\n\tMOVD $604, R12\n\tB    callbackasm1(SB)\n\tMOVD $605, R12\n\tB    callbackasm1(SB)\n\tMOVD $606, R12\n\tB    callbackasm1(SB)\n\tMOVD $607, R12\n\tB    callbackasm1(SB)\n\tMOVD $608, R12\n\tB    callbackasm1(SB)\n\tMOVD $609, R12\n\tB    callbackasm1(SB)\n\tMOVD $610, R12\n\tB    callbackasm1(SB)\n\tMOVD $611, R12\n\tB    callbackasm1(SB)\n\tMOVD $612, R12\n\tB    callbackasm1(SB)\n\tMOVD $613, R12\n\tB    callbackasm1(SB)\n\tMOVD $614, R12\n\tB    callbackasm1(SB)\n\tMOVD $615, R12\n\tB    callbackasm1(SB)\n\tMOVD $616, R12\n\tB    callbackasm1(SB)\n\tMOVD $617, R12\n\tB    callbackasm1(SB)\n\tMOVD $618, R12\n\tB    callbackasm1(SB)\n\tMOVD $619, R12\n\tB    callbackasm1(SB)\n\tMOVD $620, R12\n\tB    callbackasm1(SB)\n\tMOVD $621, R12\n\tB    callbackasm1(SB)\n\tMOVD $622, R12\n\tB    callbackasm1(SB)\n\tMOVD $623, R12\n\tB    callbackasm1(SB)\n\tMOVD $624, R12\n\tB    callbackasm1(SB)\n\tMOVD $625, R12\n\tB    callbackasm1(SB)\n\tMOVD $626, R12\n\tB    callbackasm1(SB)\n\tMOVD $627, R12\n\tB    callbackasm1(SB)\n\tMOVD $628, R12\n\tB    callbackasm1(SB)\n\tMOVD $629, R12\n\tB    callbackasm1(SB)\n\tMOVD $630, R12\n\tB    callbackasm1(SB)\n\tMOVD $631, R12\n\tB    callbackasm1(SB)\n\tMOVD $632, R12\n\tB    callbackasm1(SB)\n\tMOVD $633, R12\n\tB    callbackasm1(SB)\n\tMOVD $634, R12\n\tB    callbackasm1(SB)\n\tMOVD $635, R12\n\tB    callbackasm1(SB)\n\tMOVD $636, R12\n\tB    callbackasm1(SB)\n\tMOVD $637, R12\n\tB    callbackasm1(SB)\n\tMOVD $638, R12\n\tB    callbackasm1(SB)\n\tMOVD $639, R12\n\tB    callbackasm1(SB)\n\tMOVD $640, R12\n\tB    callbackasm1(SB)\n\tMOVD $641, R12\n\tB    callbackasm1(SB)\n\tMOVD $642, R12\n\tB    callbackasm1(SB)\n\tMOVD $643, R12\n\tB    callbackasm1(SB)\n\tMOVD $644, R12\n\tB    callbackasm1(SB)\n\tMOVD $645, R12\n\tB    callbackasm1(SB)\n\tMOVD $646, R12\n\tB    callbackasm1(SB)\n\tMOVD $647, R12\n\tB    callbackasm1(SB)\n\tMOVD $648, R12\n\tB    callbackasm1(SB)\n\tMOVD $649, R12\n\tB    callbackasm1(SB)\n\tMOVD $650, R12\n\tB    callbackasm1(SB)\n\tMOVD $651, R12\n\tB    callbackasm1(SB)\n\tMOVD $652, R12\n\tB    callbackasm1(SB)\n\tMOVD $653, R12\n\tB    callbackasm1(SB)\n\tMOVD $654, R12\n\tB    callbackasm1(SB)\n\tMOVD $655, R12\n\tB    callbackasm1(SB)\n\tMOVD $656, R12\n\tB    callbackasm1(SB)\n\tMOVD $657, R12\n\tB    callbackasm1(SB)\n\tMOVD $658, R12\n\tB    callbackasm1(SB)\n\tMOVD $659, R12\n\tB    callbackasm1(SB)\n\tMOVD $660, R12\n\tB    callbackasm1(SB)\n\tMOVD $661, R12\n\tB    callbackasm1(SB)\n\tMOVD $662, R12\n\tB    callbackasm1(SB)\n\tMOVD $663, R12\n\tB    callbackasm1(SB)\n\tMOVD $664, R12\n\tB    callbackasm1(SB)\n\tMOVD $665, R12\n\tB    callbackasm1(SB)\n\tMOVD $666, R12\n\tB    callbackasm1(SB)\n\tMOVD $667, R12\n\tB    callbackasm1(SB)\n\tMOVD $668, R12\n\tB    callbackasm1(SB)\n\tMOVD $669, R12\n\tB    callbackasm1(SB)\n\tMOVD $670, R12\n\tB    callbackasm1(SB)\n\tMOVD $671, R12\n\tB    callbackasm1(SB)\n\tMOVD $672, R12\n\tB    callbackasm1(SB)\n\tMOVD $673, R12\n\tB    callbackasm1(SB)\n\tMOVD $674, R12\n\tB    callbackasm1(SB)\n\tMOVD $675, R12\n\tB    callbackasm1(SB)\n\tMOVD $676, R12\n\tB    callbackasm1(SB)\n\tMOVD $677, R12\n\tB    callbackasm1(SB)\n\tMOVD $678, R12\n\tB    callbackasm1(SB)\n\tMOVD $679, R12\n\tB    callbackasm1(SB)\n\tMOVD $680, R12\n\tB    callbackasm1(SB)\n\tMOVD $681, R12\n\tB    callbackasm1(SB)\n\tMOVD $682, R12\n\tB    callbackasm1(SB)\n\tMOVD $683, R12\n\tB    callbackasm1(SB)\n\tMOVD $684, R12\n\tB    callbackasm1(SB)\n\tMOVD $685, R12\n\tB    callbackasm1(SB)\n\tMOVD $686, R12\n\tB    callbackasm1(SB)\n\tMOVD $687, R12\n\tB    callbackasm1(SB)\n\tMOVD $688, R12\n\tB    callbackasm1(SB)\n\tMOVD $689, R12\n\tB    callbackasm1(SB)\n\tMOVD $690, R12\n\tB    callbackasm1(SB)\n\tMOVD $691, R12\n\tB    callbackasm1(SB)\n\tMOVD $692, R12\n\tB    callbackasm1(SB)\n\tMOVD $693, R12\n\tB    callbackasm1(SB)\n\tMOVD $694, R12\n\tB    callbackasm1(SB)\n\tMOVD $695, R12\n\tB    callbackasm1(SB)\n\tMOVD $696, R12\n\tB    callbackasm1(SB)\n\tMOVD $697, R12\n\tB    callbackasm1(SB)\n\tMOVD $698, R12\n\tB    callbackasm1(SB)\n\tMOVD $699, R12\n\tB    callbackasm1(SB)\n\tMOVD $700, R12\n\tB    callbackasm1(SB)\n\tMOVD $701, R12\n\tB    callbackasm1(SB)\n\tMOVD $702, R12\n\tB    callbackasm1(SB)\n\tMOVD $703, R12\n\tB    callbackasm1(SB)\n\tMOVD $704, R12\n\tB    callbackasm1(SB)\n\tMOVD $705, R12\n\tB    callbackasm1(SB)\n\tMOVD $706, R12\n\tB    callbackasm1(SB)\n\tMOVD $707, R12\n\tB    callbackasm1(SB)\n\tMOVD $708, R12\n\tB    callbackasm1(SB)\n\tMOVD $709, R12\n\tB    callbackasm1(SB)\n\tMOVD $710, R12\n\tB    callbackasm1(SB)\n\tMOVD $711, R12\n\tB    callbackasm1(SB)\n\tMOVD $712, R12\n\tB    callbackasm1(SB)\n\tMOVD $713, R12\n\tB    callbackasm1(SB)\n\tMOVD $714, R12\n\tB    callbackasm1(SB)\n\tMOVD $715, R12\n\tB    callbackasm1(SB)\n\tMOVD $716, R12\n\tB    callbackasm1(SB)\n\tMOVD $717, R12\n\tB    callbackasm1(SB)\n\tMOVD $718, R12\n\tB    callbackasm1(SB)\n\tMOVD $719, R12\n\tB    callbackasm1(SB)\n\tMOVD $720, R12\n\tB    callbackasm1(SB)\n\tMOVD $721, R12\n\tB    callbackasm1(SB)\n\tMOVD $722, R12\n\tB    callbackasm1(SB)\n\tMOVD $723, R12\n\tB    callbackasm1(SB)\n\tMOVD $724, R12\n\tB    callbackasm1(SB)\n\tMOVD $725, R12\n\tB    callbackasm1(SB)\n\tMOVD $726, R12\n\tB    callbackasm1(SB)\n\tMOVD $727, R12\n\tB    callbackasm1(SB)\n\tMOVD $728, R12\n\tB    callbackasm1(SB)\n\tMOVD $729, R12\n\tB    callbackasm1(SB)\n\tMOVD $730, R12\n\tB    callbackasm1(SB)\n\tMOVD $731, R12\n\tB    callbackasm1(SB)\n\tMOVD $732, R12\n\tB    callbackasm1(SB)\n\tMOVD $733, R12\n\tB    callbackasm1(SB)\n\tMOVD $734, R12\n\tB    callbackasm1(SB)\n\tMOVD $735, R12\n\tB    callbackasm1(SB)\n\tMOVD $736, R12\n\tB    callbackasm1(SB)\n\tMOVD $737, R12\n\tB    callbackasm1(SB)\n\tMOVD $738, R12\n\tB    callbackasm1(SB)\n\tMOVD $739, R12\n\tB    callbackasm1(SB)\n\tMOVD $740, R12\n\tB    callbackasm1(SB)\n\tMOVD $741, R12\n\tB    callbackasm1(SB)\n\tMOVD $742, R12\n\tB    callbackasm1(SB)\n\tMOVD $743, R12\n\tB    callbackasm1(SB)\n\tMOVD $744, R12\n\tB    callbackasm1(SB)\n\tMOVD $745, R12\n\tB    callbackasm1(SB)\n\tMOVD $746, R12\n\tB    callbackasm1(SB)\n\tMOVD $747, R12\n\tB    callbackasm1(SB)\n\tMOVD $748, R12\n\tB    callbackasm1(SB)\n\tMOVD $749, R12\n\tB    callbackasm1(SB)\n\tMOVD $750, R12\n\tB    callbackasm1(SB)\n\tMOVD $751, R12\n\tB    callbackasm1(SB)\n\tMOVD $752, R12\n\tB    callbackasm1(SB)\n\tMOVD $753, R12\n\tB    callbackasm1(SB)\n\tMOVD $754, R12\n\tB    callbackasm1(SB)\n\tMOVD $755, R12\n\tB    callbackasm1(SB)\n\tMOVD $756, R12\n\tB    callbackasm1(SB)\n\tMOVD $757, R12\n\tB    callbackasm1(SB)\n\tMOVD $758, R12\n\tB    callbackasm1(SB)\n\tMOVD $759, R12\n\tB    callbackasm1(SB)\n\tMOVD $760, R12\n\tB    callbackasm1(SB)\n\tMOVD $761, R12\n\tB    callbackasm1(SB)\n\tMOVD $762, R12\n\tB    callbackasm1(SB)\n\tMOVD $763, R12\n\tB    callbackasm1(SB)\n\tMOVD $764, R12\n\tB    callbackasm1(SB)\n\tMOVD $765, R12\n\tB    callbackasm1(SB)\n\tMOVD $766, R12\n\tB    callbackasm1(SB)\n\tMOVD $767, R12\n\tB    callbackasm1(SB)\n\tMOVD $768, R12\n\tB    callbackasm1(SB)\n\tMOVD $769, R12\n\tB    callbackasm1(SB)\n\tMOVD $770, R12\n\tB    callbackasm1(SB)\n\tMOVD $771, R12\n\tB    callbackasm1(SB)\n\tMOVD $772, R12\n\tB    callbackasm1(SB)\n\tMOVD $773, R12\n\tB    callbackasm1(SB)\n\tMOVD $774, R12\n\tB    callbackasm1(SB)\n\tMOVD $775, R12\n\tB    callbackasm1(SB)\n\tMOVD $776, R12\n\tB    callbackasm1(SB)\n\tMOVD $777, R12\n\tB    callbackasm1(SB)\n\tMOVD $778, R12\n\tB    callbackasm1(SB)\n\tMOVD $779, R12\n\tB    callbackasm1(SB)\n\tMOVD $780, R12\n\tB    callbackasm1(SB)\n\tMOVD $781, R12\n\tB    callbackasm1(SB)\n\tMOVD $782, R12\n\tB    callbackasm1(SB)\n\tMOVD $783, R12\n\tB    callbackasm1(SB)\n\tMOVD $784, R12\n\tB    callbackasm1(SB)\n\tMOVD $785, R12\n\tB    callbackasm1(SB)\n\tMOVD $786, R12\n\tB    callbackasm1(SB)\n\tMOVD $787, R12\n\tB    callbackasm1(SB)\n\tMOVD $788, R12\n\tB    callbackasm1(SB)\n\tMOVD $789, R12\n\tB    callbackasm1(SB)\n\tMOVD $790, R12\n\tB    callbackasm1(SB)\n\tMOVD $791, R12\n\tB    callbackasm1(SB)\n\tMOVD $792, R12\n\tB    callbackasm1(SB)\n\tMOVD $793, R12\n\tB    callbackasm1(SB)\n\tMOVD $794, R12\n\tB    callbackasm1(SB)\n\tMOVD $795, R12\n\tB    callbackasm1(SB)\n\tMOVD $796, R12\n\tB    callbackasm1(SB)\n\tMOVD $797, R12\n\tB    callbackasm1(SB)\n\tMOVD $798, R12\n\tB    callbackasm1(SB)\n\tMOVD $799, R12\n\tB    callbackasm1(SB)\n\tMOVD $800, R12\n\tB    callbackasm1(SB)\n\tMOVD $801, R12\n\tB    callbackasm1(SB)\n\tMOVD $802, R12\n\tB    callbackasm1(SB)\n\tMOVD $803, R12\n\tB    callbackasm1(SB)\n\tMOVD $804, R12\n\tB    callbackasm1(SB)\n\tMOVD $805, R12\n\tB    callbackasm1(SB)\n\tMOVD $806, R12\n\tB    callbackasm1(SB)\n\tMOVD $807, R12\n\tB    callbackasm1(SB)\n\tMOVD $808, R12\n\tB    callbackasm1(SB)\n\tMOVD $809, R12\n\tB    callbackasm1(SB)\n\tMOVD $810, R12\n\tB    callbackasm1(SB)\n\tMOVD $811, R12\n\tB    callbackasm1(SB)\n\tMOVD $812, R12\n\tB    callbackasm1(SB)\n\tMOVD $813, R12\n\tB    callbackasm1(SB)\n\tMOVD $814, R12\n\tB    callbackasm1(SB)\n\tMOVD $815, R12\n\tB    callbackasm1(SB)\n\tMOVD $816, R12\n\tB    callbackasm1(SB)\n\tMOVD $817, R12\n\tB    callbackasm1(SB)\n\tMOVD $818, R12\n\tB    callbackasm1(SB)\n\tMOVD $819, R12\n\tB    callbackasm1(SB)\n\tMOVD $820, R12\n\tB    callbackasm1(SB)\n\tMOVD $821, R12\n\tB    callbackasm1(SB)\n\tMOVD $822, R12\n\tB    callbackasm1(SB)\n\tMOVD $823, R12\n\tB    callbackasm1(SB)\n\tMOVD $824, R12\n\tB    callbackasm1(SB)\n\tMOVD $825, R12\n\tB    callbackasm1(SB)\n\tMOVD $826, R12\n\tB    callbackasm1(SB)\n\tMOVD $827, R12\n\tB    callbackasm1(SB)\n\tMOVD $828, R12\n\tB    callbackasm1(SB)\n\tMOVD $829, R12\n\tB    callbackasm1(SB)\n\tMOVD $830, R12\n\tB    callbackasm1(SB)\n\tMOVD $831, R12\n\tB    callbackasm1(SB)\n\tMOVD $832, R12\n\tB    callbackasm1(SB)\n\tMOVD $833, R12\n\tB    callbackasm1(SB)\n\tMOVD $834, R12\n\tB    callbackasm1(SB)\n\tMOVD $835, R12\n\tB    callbackasm1(SB)\n\tMOVD $836, R12\n\tB    callbackasm1(SB)\n\tMOVD $837, R12\n\tB    callbackasm1(SB)\n\tMOVD $838, R12\n\tB    callbackasm1(SB)\n\tMOVD $839, R12\n\tB    callbackasm1(SB)\n\tMOVD $840, R12\n\tB    callbackasm1(SB)\n\tMOVD $841, R12\n\tB    callbackasm1(SB)\n\tMOVD $842, R12\n\tB    callbackasm1(SB)\n\tMOVD $843, R12\n\tB    callbackasm1(SB)\n\tMOVD $844, R12\n\tB    callbackasm1(SB)\n\tMOVD $845, R12\n\tB    callbackasm1(SB)\n\tMOVD $846, R12\n\tB    callbackasm1(SB)\n\tMOVD $847, R12\n\tB    callbackasm1(SB)\n\tMOVD $848, R12\n\tB    callbackasm1(SB)\n\tMOVD $849, R12\n\tB    callbackasm1(SB)\n\tMOVD $850, R12\n\tB    callbackasm1(SB)\n\tMOVD $851, R12\n\tB    callbackasm1(SB)\n\tMOVD $852, R12\n\tB    callbackasm1(SB)\n\tMOVD $853, R12\n\tB    callbackasm1(SB)\n\tMOVD $854, R12\n\tB    callbackasm1(SB)\n\tMOVD $855, R12\n\tB    callbackasm1(SB)\n\tMOVD $856, R12\n\tB    callbackasm1(SB)\n\tMOVD $857, R12\n\tB    callbackasm1(SB)\n\tMOVD $858, R12\n\tB    callbackasm1(SB)\n\tMOVD $859, R12\n\tB    callbackasm1(SB)\n\tMOVD $860, R12\n\tB    callbackasm1(SB)\n\tMOVD $861, R12\n\tB    callbackasm1(SB)\n\tMOVD $862, R12\n\tB    callbackasm1(SB)\n\tMOVD $863, R12\n\tB    callbackasm1(SB)\n\tMOVD $864, R12\n\tB    callbackasm1(SB)\n\tMOVD $865, R12\n\tB    callbackasm1(SB)\n\tMOVD $866, R12\n\tB    callbackasm1(SB)\n\tMOVD $867, R12\n\tB    callbackasm1(SB)\n\tMOVD $868, R12\n\tB    callbackasm1(SB)\n\tMOVD $869, R12\n\tB    callbackasm1(SB)\n\tMOVD $870, R12\n\tB    callbackasm1(SB)\n\tMOVD $871, R12\n\tB    callbackasm1(SB)\n\tMOVD $872, R12\n\tB    callbackasm1(SB)\n\tMOVD $873, R12\n\tB    callbackasm1(SB)\n\tMOVD $874, R12\n\tB    callbackasm1(SB)\n\tMOVD $875, R12\n\tB    callbackasm1(SB)\n\tMOVD $876, R12\n\tB    callbackasm1(SB)\n\tMOVD $877, R12\n\tB    callbackasm1(SB)\n\tMOVD $878, R12\n\tB    callbackasm1(SB)\n\tMOVD $879, R12\n\tB    callbackasm1(SB)\n\tMOVD $880, R12\n\tB    callbackasm1(SB)\n\tMOVD $881, R12\n\tB    callbackasm1(SB)\n\tMOVD $882, R12\n\tB    callbackasm1(SB)\n\tMOVD $883, R12\n\tB    callbackasm1(SB)\n\tMOVD $884, R12\n\tB    callbackasm1(SB)\n\tMOVD $885, R12\n\tB    callbackasm1(SB)\n\tMOVD $886, R12\n\tB    callbackasm1(SB)\n\tMOVD $887, R12\n\tB    callbackasm1(SB)\n\tMOVD $888, R12\n\tB    callbackasm1(SB)\n\tMOVD $889, R12\n\tB    callbackasm1(SB)\n\tMOVD $890, R12\n\tB    callbackasm1(SB)\n\tMOVD $891, R12\n\tB    callbackasm1(SB)\n\tMOVD $892, R12\n\tB    callbackasm1(SB)\n\tMOVD $893, R12\n\tB    callbackasm1(SB)\n\tMOVD $894, R12\n\tB    callbackasm1(SB)\n\tMOVD $895, R12\n\tB    callbackasm1(SB)\n\tMOVD $896, R12\n\tB    callbackasm1(SB)\n\tMOVD $897, R12\n\tB    callbackasm1(SB)\n\tMOVD $898, R12\n\tB    callbackasm1(SB)\n\tMOVD $899, R12\n\tB    callbackasm1(SB)\n\tMOVD $900, R12\n\tB    callbackasm1(SB)\n\tMOVD $901, R12\n\tB    callbackasm1(SB)\n\tMOVD $902, R12\n\tB    callbackasm1(SB)\n\tMOVD $903, R12\n\tB    callbackasm1(SB)\n\tMOVD $904, R12\n\tB    callbackasm1(SB)\n\tMOVD $905, R12\n\tB    callbackasm1(SB)\n\tMOVD $906, R12\n\tB    callbackasm1(SB)\n\tMOVD $907, R12\n\tB    callbackasm1(SB)\n\tMOVD $908, R12\n\tB    callbackasm1(SB)\n\tMOVD $909, R12\n\tB    callbackasm1(SB)\n\tMOVD $910, R12\n\tB    callbackasm1(SB)\n\tMOVD $911, R12\n\tB    callbackasm1(SB)\n\tMOVD $912, R12\n\tB    callbackasm1(SB)\n\tMOVD $913, R12\n\tB    callbackasm1(SB)\n\tMOVD $914, R12\n\tB    callbackasm1(SB)\n\tMOVD $915, R12\n\tB    callbackasm1(SB)\n\tMOVD $916, R12\n\tB    callbackasm1(SB)\n\tMOVD $917, R12\n\tB    callbackasm1(SB)\n\tMOVD $918, R12\n\tB    callbackasm1(SB)\n\tMOVD $919, R12\n\tB    callbackasm1(SB)\n\tMOVD $920, R12\n\tB    callbackasm1(SB)\n\tMOVD $921, R12\n\tB    callbackasm1(SB)\n\tMOVD $922, R12\n\tB    callbackasm1(SB)\n\tMOVD $923, R12\n\tB    callbackasm1(SB)\n\tMOVD $924, R12\n\tB    callbackasm1(SB)\n\tMOVD $925, R12\n\tB    callbackasm1(SB)\n\tMOVD $926, R12\n\tB    callbackasm1(SB)\n\tMOVD $927, R12\n\tB    callbackasm1(SB)\n\tMOVD $928, R12\n\tB    callbackasm1(SB)\n\tMOVD $929, R12\n\tB    callbackasm1(SB)\n\tMOVD $930, R12\n\tB    callbackasm1(SB)\n\tMOVD $931, R12\n\tB    callbackasm1(SB)\n\tMOVD $932, R12\n\tB    callbackasm1(SB)\n\tMOVD $933, R12\n\tB    callbackasm1(SB)\n\tMOVD $934, R12\n\tB    callbackasm1(SB)\n\tMOVD $935, R12\n\tB    callbackasm1(SB)\n\tMOVD $936, R12\n\tB    callbackasm1(SB)\n\tMOVD $937, R12\n\tB    callbackasm1(SB)\n\tMOVD $938, R12\n\tB    callbackasm1(SB)\n\tMOVD $939, R12\n\tB    callbackasm1(SB)\n\tMOVD $940, R12\n\tB    callbackasm1(SB)\n\tMOVD $941, R12\n\tB    callbackasm1(SB)\n\tMOVD $942, R12\n\tB    callbackasm1(SB)\n\tMOVD $943, R12\n\tB    callbackasm1(SB)\n\tMOVD $944, R12\n\tB    callbackasm1(SB)\n\tMOVD $945, R12\n\tB    callbackasm1(SB)\n\tMOVD $946, R12\n\tB    callbackasm1(SB)\n\tMOVD $947, R12\n\tB    callbackasm1(SB)\n\tMOVD $948, R12\n\tB    callbackasm1(SB)\n\tMOVD $949, R12\n\tB    callbackasm1(SB)\n\tMOVD $950, R12\n\tB    callbackasm1(SB)\n\tMOVD $951, R12\n\tB    callbackasm1(SB)\n\tMOVD $952, R12\n\tB    callbackasm1(SB)\n\tMOVD $953, R12\n\tB    callbackasm1(SB)\n\tMOVD $954, R12\n\tB    callbackasm1(SB)\n\tMOVD $955, R12\n\tB    callbackasm1(SB)\n\tMOVD $956, R12\n\tB    callbackasm1(SB)\n\tMOVD $957, R12\n\tB    callbackasm1(SB)\n\tMOVD $958, R12\n\tB    callbackasm1(SB)\n\tMOVD $959, R12\n\tB    callbackasm1(SB)\n\tMOVD $960, R12\n\tB    callbackasm1(SB)\n\tMOVD $961, R12\n\tB    callbackasm1(SB)\n\tMOVD $962, R12\n\tB    callbackasm1(SB)\n\tMOVD $963, R12\n\tB    callbackasm1(SB)\n\tMOVD $964, R12\n\tB    callbackasm1(SB)\n\tMOVD $965, R12\n\tB    callbackasm1(SB)\n\tMOVD $966, R12\n\tB    callbackasm1(SB)\n\tMOVD $967, R12\n\tB    callbackasm1(SB)\n\tMOVD $968, R12\n\tB    callbackasm1(SB)\n\tMOVD $969, R12\n\tB    callbackasm1(SB)\n\tMOVD $970, R12\n\tB    callbackasm1(SB)\n\tMOVD $971, R12\n\tB    callbackasm1(SB)\n\tMOVD $972, R12\n\tB    callbackasm1(SB)\n\tMOVD $973, R12\n\tB    callbackasm1(SB)\n\tMOVD $974, R12\n\tB    callbackasm1(SB)\n\tMOVD $975, R12\n\tB    callbackasm1(SB)\n\tMOVD $976, R12\n\tB    callbackasm1(SB)\n\tMOVD $977, R12\n\tB    callbackasm1(SB)\n\tMOVD $978, R12\n\tB    callbackasm1(SB)\n\tMOVD $979, R12\n\tB    callbackasm1(SB)\n\tMOVD $980, R12\n\tB    callbackasm1(SB)\n\tMOVD $981, R12\n\tB    callbackasm1(SB)\n\tMOVD $982, R12\n\tB    callbackasm1(SB)\n\tMOVD $983, R12\n\tB    callbackasm1(SB)\n\tMOVD $984, R12\n\tB    callbackasm1(SB)\n\tMOVD $985, R12\n\tB    callbackasm1(SB)\n\tMOVD $986, R12\n\tB    callbackasm1(SB)\n\tMOVD $987, R12\n\tB    callbackasm1(SB)\n\tMOVD $988, R12\n\tB    callbackasm1(SB)\n\tMOVD $989, R12\n\tB    callbackasm1(SB)\n\tMOVD $990, R12\n\tB    callbackasm1(SB)\n\tMOVD $991, R12\n\tB    callbackasm1(SB)\n\tMOVD $992, R12\n\tB    callbackasm1(SB)\n\tMOVD $993, R12\n\tB    callbackasm1(SB)\n\tMOVD $994, R12\n\tB    callbackasm1(SB)\n\tMOVD $995, R12\n\tB    callbackasm1(SB)\n\tMOVD $996, R12\n\tB    callbackasm1(SB)\n\tMOVD $997, R12\n\tB    callbackasm1(SB)\n\tMOVD $998, R12\n\tB    callbackasm1(SB)\n\tMOVD $999, R12\n\tB    callbackasm1(SB)\n\tMOVD $1000, R12\n\tB    callbackasm1(SB)\n\tMOVD $1001, R12\n\tB    callbackasm1(SB)\n\tMOVD $1002, R12\n\tB    callbackasm1(SB)\n\tMOVD $1003, R12\n\tB    callbackasm1(SB)\n\tMOVD $1004, R12\n\tB    callbackasm1(SB)\n\tMOVD $1005, R12\n\tB    callbackasm1(SB)\n\tMOVD $1006, R12\n\tB    callbackasm1(SB)\n\tMOVD $1007, R12\n\tB    callbackasm1(SB)\n\tMOVD $1008, R12\n\tB    callbackasm1(SB)\n\tMOVD $1009, R12\n\tB    callbackasm1(SB)\n\tMOVD $1010, R12\n\tB    callbackasm1(SB)\n\tMOVD $1011, R12\n\tB    callbackasm1(SB)\n\tMOVD $1012, R12\n\tB    callbackasm1(SB)\n\tMOVD $1013, R12\n\tB    callbackasm1(SB)\n\tMOVD $1014, R12\n\tB    callbackasm1(SB)\n\tMOVD $1015, R12\n\tB    callbackasm1(SB)\n\tMOVD $1016, R12\n\tB    callbackasm1(SB)\n\tMOVD $1017, R12\n\tB    callbackasm1(SB)\n\tMOVD $1018, R12\n\tB    callbackasm1(SB)\n\tMOVD $1019, R12\n\tB    callbackasm1(SB)\n\tMOVD $1020, R12\n\tB    callbackasm1(SB)\n\tMOVD $1021, R12\n\tB    callbackasm1(SB)\n\tMOVD $1022, R12\n\tB    callbackasm1(SB)\n\tMOVD $1023, R12\n\tB    callbackasm1(SB)\n\tMOVD $1024, R12\n\tB    callbackasm1(SB)\n\tMOVD $1025, R12\n\tB    callbackasm1(SB)\n\tMOVD $1026, R12\n\tB    callbackasm1(SB)\n\tMOVD $1027, R12\n\tB    callbackasm1(SB)\n\tMOVD $1028, R12\n\tB    callbackasm1(SB)\n\tMOVD $1029, R12\n\tB    callbackasm1(SB)\n\tMOVD $1030, R12\n\tB    callbackasm1(SB)\n\tMOVD $1031, R12\n\tB    callbackasm1(SB)\n\tMOVD $1032, R12\n\tB    callbackasm1(SB)\n\tMOVD $1033, R12\n\tB    callbackasm1(SB)\n\tMOVD $1034, R12\n\tB    callbackasm1(SB)\n\tMOVD $1035, R12\n\tB    callbackasm1(SB)\n\tMOVD $1036, R12\n\tB    callbackasm1(SB)\n\tMOVD $1037, R12\n\tB    callbackasm1(SB)\n\tMOVD $1038, R12\n\tB    callbackasm1(SB)\n\tMOVD $1039, R12\n\tB    callbackasm1(SB)\n\tMOVD $1040, R12\n\tB    callbackasm1(SB)\n\tMOVD $1041, R12\n\tB    callbackasm1(SB)\n\tMOVD $1042, R12\n\tB    callbackasm1(SB)\n\tMOVD $1043, R12\n\tB    callbackasm1(SB)\n\tMOVD $1044, R12\n\tB    callbackasm1(SB)\n\tMOVD $1045, R12\n\tB    callbackasm1(SB)\n\tMOVD $1046, R12\n\tB    callbackasm1(SB)\n\tMOVD $1047, R12\n\tB    callbackasm1(SB)\n\tMOVD $1048, R12\n\tB    callbackasm1(SB)\n\tMOVD $1049, R12\n\tB    callbackasm1(SB)\n\tMOVD $1050, R12\n\tB    callbackasm1(SB)\n\tMOVD $1051, R12\n\tB    callbackasm1(SB)\n\tMOVD $1052, R12\n\tB    callbackasm1(SB)\n\tMOVD $1053, R12\n\tB    callbackasm1(SB)\n\tMOVD $1054, R12\n\tB    callbackasm1(SB)\n\tMOVD $1055, R12\n\tB    callbackasm1(SB)\n\tMOVD $1056, R12\n\tB    callbackasm1(SB)\n\tMOVD $1057, R12\n\tB    callbackasm1(SB)\n\tMOVD $1058, R12\n\tB    callbackasm1(SB)\n\tMOVD $1059, R12\n\tB    callbackasm1(SB)\n\tMOVD $1060, R12\n\tB    callbackasm1(SB)\n\tMOVD $1061, R12\n\tB    callbackasm1(SB)\n\tMOVD $1062, R12\n\tB    callbackasm1(SB)\n\tMOVD $1063, R12\n\tB    callbackasm1(SB)\n\tMOVD $1064, R12\n\tB    callbackasm1(SB)\n\tMOVD $1065, R12\n\tB    callbackasm1(SB)\n\tMOVD $1066, R12\n\tB    callbackasm1(SB)\n\tMOVD $1067, R12\n\tB    callbackasm1(SB)\n\tMOVD $1068, R12\n\tB    callbackasm1(SB)\n\tMOVD $1069, R12\n\tB    callbackasm1(SB)\n\tMOVD $1070, R12\n\tB    callbackasm1(SB)\n\tMOVD $1071, R12\n\tB    callbackasm1(SB)\n\tMOVD $1072, R12\n\tB    callbackasm1(SB)\n\tMOVD $1073, R12\n\tB    callbackasm1(SB)\n\tMOVD $1074, R12\n\tB    callbackasm1(SB)\n\tMOVD $1075, R12\n\tB    callbackasm1(SB)\n\tMOVD $1076, R12\n\tB    callbackasm1(SB)\n\tMOVD $1077, R12\n\tB    callbackasm1(SB)\n\tMOVD $1078, R12\n\tB    callbackasm1(SB)\n\tMOVD $1079, R12\n\tB    callbackasm1(SB)\n\tMOVD $1080, R12\n\tB    callbackasm1(SB)\n\tMOVD $1081, R12\n\tB    callbackasm1(SB)\n\tMOVD $1082, R12\n\tB    callbackasm1(SB)\n\tMOVD $1083, R12\n\tB    callbackasm1(SB)\n\tMOVD $1084, R12\n\tB    callbackasm1(SB)\n\tMOVD $1085, R12\n\tB    callbackasm1(SB)\n\tMOVD $1086, R12\n\tB    callbackasm1(SB)\n\tMOVD $1087, R12\n\tB    callbackasm1(SB)\n\tMOVD $1088, R12\n\tB    callbackasm1(SB)\n\tMOVD $1089, R12\n\tB    callbackasm1(SB)\n\tMOVD $1090, R12\n\tB    callbackasm1(SB)\n\tMOVD $1091, R12\n\tB    callbackasm1(SB)\n\tMOVD $1092, R12\n\tB    callbackasm1(SB)\n\tMOVD $1093, R12\n\tB    callbackasm1(SB)\n\tMOVD $1094, R12\n\tB    callbackasm1(SB)\n\tMOVD $1095, R12\n\tB    callbackasm1(SB)\n\tMOVD $1096, R12\n\tB    callbackasm1(SB)\n\tMOVD $1097, R12\n\tB    callbackasm1(SB)\n\tMOVD $1098, R12\n\tB    callbackasm1(SB)\n\tMOVD $1099, R12\n\tB    callbackasm1(SB)\n\tMOVD $1100, R12\n\tB    callbackasm1(SB)\n\tMOVD $1101, R12\n\tB    callbackasm1(SB)\n\tMOVD $1102, R12\n\tB    callbackasm1(SB)\n\tMOVD $1103, R12\n\tB    callbackasm1(SB)\n\tMOVD $1104, R12\n\tB    callbackasm1(SB)\n\tMOVD $1105, R12\n\tB    callbackasm1(SB)\n\tMOVD $1106, R12\n\tB    callbackasm1(SB)\n\tMOVD $1107, R12\n\tB    callbackasm1(SB)\n\tMOVD $1108, R12\n\tB    callbackasm1(SB)\n\tMOVD $1109, R12\n\tB    callbackasm1(SB)\n\tMOVD $1110, R12\n\tB    callbackasm1(SB)\n\tMOVD $1111, R12\n\tB    callbackasm1(SB)\n\tMOVD $1112, R12\n\tB    callbackasm1(SB)\n\tMOVD $1113, R12\n\tB    callbackasm1(SB)\n\tMOVD $1114, R12\n\tB    callbackasm1(SB)\n\tMOVD $1115, R12\n\tB    callbackasm1(SB)\n\tMOVD $1116, R12\n\tB    callbackasm1(SB)\n\tMOVD $1117, R12\n\tB    callbackasm1(SB)\n\tMOVD $1118, R12\n\tB    callbackasm1(SB)\n\tMOVD $1119, R12\n\tB    callbackasm1(SB)\n\tMOVD $1120, R12\n\tB    callbackasm1(SB)\n\tMOVD $1121, R12\n\tB    callbackasm1(SB)\n\tMOVD $1122, R12\n\tB    callbackasm1(SB)\n\tMOVD $1123, R12\n\tB    callbackasm1(SB)\n\tMOVD $1124, R12\n\tB    callbackasm1(SB)\n\tMOVD $1125, R12\n\tB    callbackasm1(SB)\n\tMOVD $1126, R12\n\tB    callbackasm1(SB)\n\tMOVD $1127, R12\n\tB    callbackasm1(SB)\n\tMOVD $1128, R12\n\tB    callbackasm1(SB)\n\tMOVD $1129, R12\n\tB    callbackasm1(SB)\n\tMOVD $1130, R12\n\tB    callbackasm1(SB)\n\tMOVD $1131, R12\n\tB    callbackasm1(SB)\n\tMOVD $1132, R12\n\tB    callbackasm1(SB)\n\tMOVD $1133, R12\n\tB    callbackasm1(SB)\n\tMOVD $1134, R12\n\tB    callbackasm1(SB)\n\tMOVD $1135, R12\n\tB    callbackasm1(SB)\n\tMOVD $1136, R12\n\tB    callbackasm1(SB)\n\tMOVD $1137, R12\n\tB    callbackasm1(SB)\n\tMOVD $1138, R12\n\tB    callbackasm1(SB)\n\tMOVD $1139, R12\n\tB    callbackasm1(SB)\n\tMOVD $1140, R12\n\tB    callbackasm1(SB)\n\tMOVD $1141, R12\n\tB    callbackasm1(SB)\n\tMOVD $1142, R12\n\tB    callbackasm1(SB)\n\tMOVD $1143, R12\n\tB    callbackasm1(SB)\n\tMOVD $1144, R12\n\tB    callbackasm1(SB)\n\tMOVD $1145, R12\n\tB    callbackasm1(SB)\n\tMOVD $1146, R12\n\tB    callbackasm1(SB)\n\tMOVD $1147, R12\n\tB    callbackasm1(SB)\n\tMOVD $1148, R12\n\tB    callbackasm1(SB)\n\tMOVD $1149, R12\n\tB    callbackasm1(SB)\n\tMOVD $1150, R12\n\tB    callbackasm1(SB)\n\tMOVD $1151, R12\n\tB    callbackasm1(SB)\n\tMOVD $1152, R12\n\tB    callbackasm1(SB)\n\tMOVD $1153, R12\n\tB    callbackasm1(SB)\n\tMOVD $1154, R12\n\tB    callbackasm1(SB)\n\tMOVD $1155, R12\n\tB    callbackasm1(SB)\n\tMOVD $1156, R12\n\tB    callbackasm1(SB)\n\tMOVD $1157, R12\n\tB    callbackasm1(SB)\n\tMOVD $1158, R12\n\tB    callbackasm1(SB)\n\tMOVD $1159, R12\n\tB    callbackasm1(SB)\n\tMOVD $1160, R12\n\tB    callbackasm1(SB)\n\tMOVD $1161, R12\n\tB    callbackasm1(SB)\n\tMOVD $1162, R12\n\tB    callbackasm1(SB)\n\tMOVD $1163, R12\n\tB    callbackasm1(SB)\n\tMOVD $1164, R12\n\tB    callbackasm1(SB)\n\tMOVD $1165, R12\n\tB    callbackasm1(SB)\n\tMOVD $1166, R12\n\tB    callbackasm1(SB)\n\tMOVD $1167, R12\n\tB    callbackasm1(SB)\n\tMOVD $1168, R12\n\tB    callbackasm1(SB)\n\tMOVD $1169, R12\n\tB    callbackasm1(SB)\n\tMOVD $1170, R12\n\tB    callbackasm1(SB)\n\tMOVD $1171, R12\n\tB    callbackasm1(SB)\n\tMOVD $1172, R12\n\tB    callbackasm1(SB)\n\tMOVD $1173, R12\n\tB    callbackasm1(SB)\n\tMOVD $1174, R12\n\tB    callbackasm1(SB)\n\tMOVD $1175, R12\n\tB    callbackasm1(SB)\n\tMOVD $1176, R12\n\tB    callbackasm1(SB)\n\tMOVD $1177, R12\n\tB    callbackasm1(SB)\n\tMOVD $1178, R12\n\tB    callbackasm1(SB)\n\tMOVD $1179, R12\n\tB    callbackasm1(SB)\n\tMOVD $1180, R12\n\tB    callbackasm1(SB)\n\tMOVD $1181, R12\n\tB    callbackasm1(SB)\n\tMOVD $1182, R12\n\tB    callbackasm1(SB)\n\tMOVD $1183, R12\n\tB    callbackasm1(SB)\n\tMOVD $1184, R12\n\tB    callbackasm1(SB)\n\tMOVD $1185, R12\n\tB    callbackasm1(SB)\n\tMOVD $1186, R12\n\tB    callbackasm1(SB)\n\tMOVD $1187, R12\n\tB    callbackasm1(SB)\n\tMOVD $1188, R12\n\tB    callbackasm1(SB)\n\tMOVD $1189, R12\n\tB    callbackasm1(SB)\n\tMOVD $1190, R12\n\tB    callbackasm1(SB)\n\tMOVD $1191, R12\n\tB    callbackasm1(SB)\n\tMOVD $1192, R12\n\tB    callbackasm1(SB)\n\tMOVD $1193, R12\n\tB    callbackasm1(SB)\n\tMOVD $1194, R12\n\tB    callbackasm1(SB)\n\tMOVD $1195, R12\n\tB    callbackasm1(SB)\n\tMOVD $1196, R12\n\tB    callbackasm1(SB)\n\tMOVD $1197, R12\n\tB    callbackasm1(SB)\n\tMOVD $1198, R12\n\tB    callbackasm1(SB)\n\tMOVD $1199, R12\n\tB    callbackasm1(SB)\n\tMOVD $1200, R12\n\tB    callbackasm1(SB)\n\tMOVD $1201, R12\n\tB    callbackasm1(SB)\n\tMOVD $1202, R12\n\tB    callbackasm1(SB)\n\tMOVD $1203, R12\n\tB    callbackasm1(SB)\n\tMOVD $1204, R12\n\tB    callbackasm1(SB)\n\tMOVD $1205, R12\n\tB    callbackasm1(SB)\n\tMOVD $1206, R12\n\tB    callbackasm1(SB)\n\tMOVD $1207, R12\n\tB    callbackasm1(SB)\n\tMOVD $1208, R12\n\tB    callbackasm1(SB)\n\tMOVD $1209, R12\n\tB    callbackasm1(SB)\n\tMOVD $1210, R12\n\tB    callbackasm1(SB)\n\tMOVD $1211, R12\n\tB    callbackasm1(SB)\n\tMOVD $1212, R12\n\tB    callbackasm1(SB)\n\tMOVD $1213, R12\n\tB    callbackasm1(SB)\n\tMOVD $1214, R12\n\tB    callbackasm1(SB)\n\tMOVD $1215, R12\n\tB    callbackasm1(SB)\n\tMOVD $1216, R12\n\tB    callbackasm1(SB)\n\tMOVD $1217, R12\n\tB    callbackasm1(SB)\n\tMOVD $1218, R12\n\tB    callbackasm1(SB)\n\tMOVD $1219, R12\n\tB    callbackasm1(SB)\n\tMOVD $1220, R12\n\tB    callbackasm1(SB)\n\tMOVD $1221, R12\n\tB    callbackasm1(SB)\n\tMOVD $1222, R12\n\tB    callbackasm1(SB)\n\tMOVD $1223, R12\n\tB    callbackasm1(SB)\n\tMOVD $1224, R12\n\tB    callbackasm1(SB)\n\tMOVD $1225, R12\n\tB    callbackasm1(SB)\n\tMOVD $1226, R12\n\tB    callbackasm1(SB)\n\tMOVD $1227, R12\n\tB    callbackasm1(SB)\n\tMOVD $1228, R12\n\tB    callbackasm1(SB)\n\tMOVD $1229, R12\n\tB    callbackasm1(SB)\n\tMOVD $1230, R12\n\tB    callbackasm1(SB)\n\tMOVD $1231, R12\n\tB    callbackasm1(SB)\n\tMOVD $1232, R12\n\tB    callbackasm1(SB)\n\tMOVD $1233, R12\n\tB    callbackasm1(SB)\n\tMOVD $1234, R12\n\tB    callbackasm1(SB)\n\tMOVD $1235, R12\n\tB    callbackasm1(SB)\n\tMOVD $1236, R12\n\tB    callbackasm1(SB)\n\tMOVD $1237, R12\n\tB    callbackasm1(SB)\n\tMOVD $1238, R12\n\tB    callbackasm1(SB)\n\tMOVD $1239, R12\n\tB    callbackasm1(SB)\n\tMOVD $1240, R12\n\tB    callbackasm1(SB)\n\tMOVD $1241, R12\n\tB    callbackasm1(SB)\n\tMOVD $1242, R12\n\tB    callbackasm1(SB)\n\tMOVD $1243, R12\n\tB    callbackasm1(SB)\n\tMOVD $1244, R12\n\tB    callbackasm1(SB)\n\tMOVD $1245, R12\n\tB    callbackasm1(SB)\n\tMOVD $1246, R12\n\tB    callbackasm1(SB)\n\tMOVD $1247, R12\n\tB    callbackasm1(SB)\n\tMOVD $1248, R12\n\tB    callbackasm1(SB)\n\tMOVD $1249, R12\n\tB    callbackasm1(SB)\n\tMOVD $1250, R12\n\tB    callbackasm1(SB)\n\tMOVD $1251, R12\n\tB    callbackasm1(SB)\n\tMOVD $1252, R12\n\tB    callbackasm1(SB)\n\tMOVD $1253, R12\n\tB    callbackasm1(SB)\n\tMOVD $1254, R12\n\tB    callbackasm1(SB)\n\tMOVD $1255, R12\n\tB    callbackasm1(SB)\n\tMOVD $1256, R12\n\tB    callbackasm1(SB)\n\tMOVD $1257, R12\n\tB    callbackasm1(SB)\n\tMOVD $1258, R12\n\tB    callbackasm1(SB)\n\tMOVD $1259, R12\n\tB    callbackasm1(SB)\n\tMOVD $1260, R12\n\tB    callbackasm1(SB)\n\tMOVD $1261, R12\n\tB    callbackasm1(SB)\n\tMOVD $1262, R12\n\tB    callbackasm1(SB)\n\tMOVD $1263, R12\n\tB    callbackasm1(SB)\n\tMOVD $1264, R12\n\tB    callbackasm1(SB)\n\tMOVD $1265, R12\n\tB    callbackasm1(SB)\n\tMOVD $1266, R12\n\tB    callbackasm1(SB)\n\tMOVD $1267, R12\n\tB    callbackasm1(SB)\n\tMOVD $1268, R12\n\tB    callbackasm1(SB)\n\tMOVD $1269, R12\n\tB    callbackasm1(SB)\n\tMOVD $1270, R12\n\tB    callbackasm1(SB)\n\tMOVD $1271, R12\n\tB    callbackasm1(SB)\n\tMOVD $1272, R12\n\tB    callbackasm1(SB)\n\tMOVD $1273, R12\n\tB    callbackasm1(SB)\n\tMOVD $1274, R12\n\tB    callbackasm1(SB)\n\tMOVD $1275, R12\n\tB    callbackasm1(SB)\n\tMOVD $1276, R12\n\tB    callbackasm1(SB)\n\tMOVD $1277, R12\n\tB    callbackasm1(SB)\n\tMOVD $1278, R12\n\tB    callbackasm1(SB)\n\tMOVD $1279, R12\n\tB    callbackasm1(SB)\n\tMOVD $1280, R12\n\tB    callbackasm1(SB)\n\tMOVD $1281, R12\n\tB    callbackasm1(SB)\n\tMOVD $1282, R12\n\tB    callbackasm1(SB)\n\tMOVD $1283, R12\n\tB    callbackasm1(SB)\n\tMOVD $1284, R12\n\tB    callbackasm1(SB)\n\tMOVD $1285, R12\n\tB    callbackasm1(SB)\n\tMOVD $1286, R12\n\tB    callbackasm1(SB)\n\tMOVD $1287, R12\n\tB    callbackasm1(SB)\n\tMOVD $1288, R12\n\tB    callbackasm1(SB)\n\tMOVD $1289, R12\n\tB    callbackasm1(SB)\n\tMOVD $1290, R12\n\tB    callbackasm1(SB)\n\tMOVD $1291, R12\n\tB    callbackasm1(SB)\n\tMOVD $1292, R12\n\tB    callbackasm1(SB)\n\tMOVD $1293, R12\n\tB    callbackasm1(SB)\n\tMOVD $1294, R12\n\tB    callbackasm1(SB)\n\tMOVD $1295, R12\n\tB    callbackasm1(SB)\n\tMOVD $1296, R12\n\tB    callbackasm1(SB)\n\tMOVD $1297, R12\n\tB    callbackasm1(SB)\n\tMOVD $1298, R12\n\tB    callbackasm1(SB)\n\tMOVD $1299, R12\n\tB    callbackasm1(SB)\n\tMOVD $1300, R12\n\tB    callbackasm1(SB)\n\tMOVD $1301, R12\n\tB    callbackasm1(SB)\n\tMOVD $1302, R12\n\tB    callbackasm1(SB)\n\tMOVD $1303, R12\n\tB    callbackasm1(SB)\n\tMOVD $1304, R12\n\tB    callbackasm1(SB)\n\tMOVD $1305, R12\n\tB    callbackasm1(SB)\n\tMOVD $1306, R12\n\tB    callbackasm1(SB)\n\tMOVD $1307, R12\n\tB    callbackasm1(SB)\n\tMOVD $1308, R12\n\tB    callbackasm1(SB)\n\tMOVD $1309, R12\n\tB    callbackasm1(SB)\n\tMOVD $1310, R12\n\tB    callbackasm1(SB)\n\tMOVD $1311, R12\n\tB    callbackasm1(SB)\n\tMOVD $1312, R12\n\tB    callbackasm1(SB)\n\tMOVD $1313, R12\n\tB    callbackasm1(SB)\n\tMOVD $1314, R12\n\tB    callbackasm1(SB)\n\tMOVD $1315, R12\n\tB    callbackasm1(SB)\n\tMOVD $1316, R12\n\tB    callbackasm1(SB)\n\tMOVD $1317, R12\n\tB    callbackasm1(SB)\n\tMOVD $1318, R12\n\tB    callbackasm1(SB)\n\tMOVD $1319, R12\n\tB    callbackasm1(SB)\n\tMOVD $1320, R12\n\tB    callbackasm1(SB)\n\tMOVD $1321, R12\n\tB    callbackasm1(SB)\n\tMOVD $1322, R12\n\tB    callbackasm1(SB)\n\tMOVD $1323, R12\n\tB    callbackasm1(SB)\n\tMOVD $1324, R12\n\tB    callbackasm1(SB)\n\tMOVD $1325, R12\n\tB    callbackasm1(SB)\n\tMOVD $1326, R12\n\tB    callbackasm1(SB)\n\tMOVD $1327, R12\n\tB    callbackasm1(SB)\n\tMOVD $1328, R12\n\tB    callbackasm1(SB)\n\tMOVD $1329, R12\n\tB    callbackasm1(SB)\n\tMOVD $1330, R12\n\tB    callbackasm1(SB)\n\tMOVD $1331, R12\n\tB    callbackasm1(SB)\n\tMOVD $1332, R12\n\tB    callbackasm1(SB)\n\tMOVD $1333, R12\n\tB    callbackasm1(SB)\n\tMOVD $1334, R12\n\tB    callbackasm1(SB)\n\tMOVD $1335, R12\n\tB    callbackasm1(SB)\n\tMOVD $1336, R12\n\tB    callbackasm1(SB)\n\tMOVD $1337, R12\n\tB    callbackasm1(SB)\n\tMOVD $1338, R12\n\tB    callbackasm1(SB)\n\tMOVD $1339, R12\n\tB    callbackasm1(SB)\n\tMOVD $1340, R12\n\tB    callbackasm1(SB)\n\tMOVD $1341, R12\n\tB    callbackasm1(SB)\n\tMOVD $1342, R12\n\tB    callbackasm1(SB)\n\tMOVD $1343, R12\n\tB    callbackasm1(SB)\n\tMOVD $1344, R12\n\tB    callbackasm1(SB)\n\tMOVD $1345, R12\n\tB    callbackasm1(SB)\n\tMOVD $1346, R12\n\tB    callbackasm1(SB)\n\tMOVD $1347, R12\n\tB    callbackasm1(SB)\n\tMOVD $1348, R12\n\tB    callbackasm1(SB)\n\tMOVD $1349, R12\n\tB    callbackasm1(SB)\n\tMOVD $1350, R12\n\tB    callbackasm1(SB)\n\tMOVD $1351, R12\n\tB    callbackasm1(SB)\n\tMOVD $1352, R12\n\tB    callbackasm1(SB)\n\tMOVD $1353, R12\n\tB    callbackasm1(SB)\n\tMOVD $1354, R12\n\tB    callbackasm1(SB)\n\tMOVD $1355, R12\n\tB    callbackasm1(SB)\n\tMOVD $1356, R12\n\tB    callbackasm1(SB)\n\tMOVD $1357, R12\n\tB    callbackasm1(SB)\n\tMOVD $1358, R12\n\tB    callbackasm1(SB)\n\tMOVD $1359, R12\n\tB    callbackasm1(SB)\n\tMOVD $1360, R12\n\tB    callbackasm1(SB)\n\tMOVD $1361, R12\n\tB    callbackasm1(SB)\n\tMOVD $1362, R12\n\tB    callbackasm1(SB)\n\tMOVD $1363, R12\n\tB    callbackasm1(SB)\n\tMOVD $1364, R12\n\tB    callbackasm1(SB)\n\tMOVD $1365, R12\n\tB    callbackasm1(SB)\n\tMOVD $1366, R12\n\tB    callbackasm1(SB)\n\tMOVD $1367, R12\n\tB    callbackasm1(SB)\n\tMOVD $1368, R12\n\tB    callbackasm1(SB)\n\tMOVD $1369, R12\n\tB    callbackasm1(SB)\n\tMOVD $1370, R12\n\tB    callbackasm1(SB)\n\tMOVD $1371, R12\n\tB    callbackasm1(SB)\n\tMOVD $1372, R12\n\tB    callbackasm1(SB)\n\tMOVD $1373, R12\n\tB    callbackasm1(SB)\n\tMOVD $1374, R12\n\tB    callbackasm1(SB)\n\tMOVD $1375, R12\n\tB    callbackasm1(SB)\n\tMOVD $1376, R12\n\tB    callbackasm1(SB)\n\tMOVD $1377, R12\n\tB    callbackasm1(SB)\n\tMOVD $1378, R12\n\tB    callbackasm1(SB)\n\tMOVD $1379, R12\n\tB    callbackasm1(SB)\n\tMOVD $1380, R12\n\tB    callbackasm1(SB)\n\tMOVD $1381, R12\n\tB    callbackasm1(SB)\n\tMOVD $1382, R12\n\tB    callbackasm1(SB)\n\tMOVD $1383, R12\n\tB    callbackasm1(SB)\n\tMOVD $1384, R12\n\tB    callbackasm1(SB)\n\tMOVD $1385, R12\n\tB    callbackasm1(SB)\n\tMOVD $1386, R12\n\tB    callbackasm1(SB)\n\tMOVD $1387, R12\n\tB    callbackasm1(SB)\n\tMOVD $1388, R12\n\tB    callbackasm1(SB)\n\tMOVD $1389, R12\n\tB    callbackasm1(SB)\n\tMOVD $1390, R12\n\tB    callbackasm1(SB)\n\tMOVD $1391, R12\n\tB    callbackasm1(SB)\n\tMOVD $1392, R12\n\tB    callbackasm1(SB)\n\tMOVD $1393, R12\n\tB    callbackasm1(SB)\n\tMOVD $1394, R12\n\tB    callbackasm1(SB)\n\tMOVD $1395, R12\n\tB    callbackasm1(SB)\n\tMOVD $1396, R12\n\tB    callbackasm1(SB)\n\tMOVD $1397, R12\n\tB    callbackasm1(SB)\n\tMOVD $1398, R12\n\tB    callbackasm1(SB)\n\tMOVD $1399, R12\n\tB    callbackasm1(SB)\n\tMOVD $1400, R12\n\tB    callbackasm1(SB)\n\tMOVD $1401, R12\n\tB    callbackasm1(SB)\n\tMOVD $1402, R12\n\tB    callbackasm1(SB)\n\tMOVD $1403, R12\n\tB    callbackasm1(SB)\n\tMOVD $1404, R12\n\tB    callbackasm1(SB)\n\tMOVD $1405, R12\n\tB    callbackasm1(SB)\n\tMOVD $1406, R12\n\tB    callbackasm1(SB)\n\tMOVD $1407, R12\n\tB    callbackasm1(SB)\n\tMOVD $1408, R12\n\tB    callbackasm1(SB)\n\tMOVD $1409, R12\n\tB    callbackasm1(SB)\n\tMOVD $1410, R12\n\tB    callbackasm1(SB)\n\tMOVD $1411, R12\n\tB    callbackasm1(SB)\n\tMOVD $1412, R12\n\tB    callbackasm1(SB)\n\tMOVD $1413, R12\n\tB    callbackasm1(SB)\n\tMOVD $1414, R12\n\tB    callbackasm1(SB)\n\tMOVD $1415, R12\n\tB    callbackasm1(SB)\n\tMOVD $1416, R12\n\tB    callbackasm1(SB)\n\tMOVD $1417, R12\n\tB    callbackasm1(SB)\n\tMOVD $1418, R12\n\tB    callbackasm1(SB)\n\tMOVD $1419, R12\n\tB    callbackasm1(SB)\n\tMOVD $1420, R12\n\tB    callbackasm1(SB)\n\tMOVD $1421, R12\n\tB    callbackasm1(SB)\n\tMOVD $1422, R12\n\tB    callbackasm1(SB)\n\tMOVD $1423, R12\n\tB    callbackasm1(SB)\n\tMOVD $1424, R12\n\tB    callbackasm1(SB)\n\tMOVD $1425, R12\n\tB    callbackasm1(SB)\n\tMOVD $1426, R12\n\tB    callbackasm1(SB)\n\tMOVD $1427, R12\n\tB    callbackasm1(SB)\n\tMOVD $1428, R12\n\tB    callbackasm1(SB)\n\tMOVD $1429, R12\n\tB    callbackasm1(SB)\n\tMOVD $1430, R12\n\tB    callbackasm1(SB)\n\tMOVD $1431, R12\n\tB    callbackasm1(SB)\n\tMOVD $1432, R12\n\tB    callbackasm1(SB)\n\tMOVD $1433, R12\n\tB    callbackasm1(SB)\n\tMOVD $1434, R12\n\tB    callbackasm1(SB)\n\tMOVD $1435, R12\n\tB    callbackasm1(SB)\n\tMOVD $1436, R12\n\tB    callbackasm1(SB)\n\tMOVD $1437, R12\n\tB    callbackasm1(SB)\n\tMOVD $1438, R12\n\tB    callbackasm1(SB)\n\tMOVD $1439, R12\n\tB    callbackasm1(SB)\n\tMOVD $1440, R12\n\tB    callbackasm1(SB)\n\tMOVD $1441, R12\n\tB    callbackasm1(SB)\n\tMOVD $1442, R12\n\tB    callbackasm1(SB)\n\tMOVD $1443, R12\n\tB    callbackasm1(SB)\n\tMOVD $1444, R12\n\tB    callbackasm1(SB)\n\tMOVD $1445, R12\n\tB    callbackasm1(SB)\n\tMOVD $1446, R12\n\tB    callbackasm1(SB)\n\tMOVD $1447, R12\n\tB    callbackasm1(SB)\n\tMOVD $1448, R12\n\tB    callbackasm1(SB)\n\tMOVD $1449, R12\n\tB    callbackasm1(SB)\n\tMOVD $1450, R12\n\tB    callbackasm1(SB)\n\tMOVD $1451, R12\n\tB    callbackasm1(SB)\n\tMOVD $1452, R12\n\tB    callbackasm1(SB)\n\tMOVD $1453, R12\n\tB    callbackasm1(SB)\n\tMOVD $1454, R12\n\tB    callbackasm1(SB)\n\tMOVD $1455, R12\n\tB    callbackasm1(SB)\n\tMOVD $1456, R12\n\tB    callbackasm1(SB)\n\tMOVD $1457, R12\n\tB    callbackasm1(SB)\n\tMOVD $1458, R12\n\tB    callbackasm1(SB)\n\tMOVD $1459, R12\n\tB    callbackasm1(SB)\n\tMOVD $1460, R12\n\tB    callbackasm1(SB)\n\tMOVD $1461, R12\n\tB    callbackasm1(SB)\n\tMOVD $1462, R12\n\tB    callbackasm1(SB)\n\tMOVD $1463, R12\n\tB    callbackasm1(SB)\n\tMOVD $1464, R12\n\tB    callbackasm1(SB)\n\tMOVD $1465, R12\n\tB    callbackasm1(SB)\n\tMOVD $1466, R12\n\tB    callbackasm1(SB)\n\tMOVD $1467, R12\n\tB    callbackasm1(SB)\n\tMOVD $1468, R12\n\tB    callbackasm1(SB)\n\tMOVD $1469, R12\n\tB    callbackasm1(SB)\n\tMOVD $1470, R12\n\tB    callbackasm1(SB)\n\tMOVD $1471, R12\n\tB    callbackasm1(SB)\n\tMOVD $1472, R12\n\tB    callbackasm1(SB)\n\tMOVD $1473, R12\n\tB    callbackasm1(SB)\n\tMOVD $1474, R12\n\tB    callbackasm1(SB)\n\tMOVD $1475, R12\n\tB    callbackasm1(SB)\n\tMOVD $1476, R12\n\tB    callbackasm1(SB)\n\tMOVD $1477, R12\n\tB    callbackasm1(SB)\n\tMOVD $1478, R12\n\tB    callbackasm1(SB)\n\tMOVD $1479, R12\n\tB    callbackasm1(SB)\n\tMOVD $1480, R12\n\tB    callbackasm1(SB)\n\tMOVD $1481, R12\n\tB    callbackasm1(SB)\n\tMOVD $1482, R12\n\tB    callbackasm1(SB)\n\tMOVD $1483, R12\n\tB    callbackasm1(SB)\n\tMOVD $1484, R12\n\tB    callbackasm1(SB)\n\tMOVD $1485, R12\n\tB    callbackasm1(SB)\n\tMOVD $1486, R12\n\tB    callbackasm1(SB)\n\tMOVD $1487, R12\n\tB    callbackasm1(SB)\n\tMOVD $1488, R12\n\tB    callbackasm1(SB)\n\tMOVD $1489, R12\n\tB    callbackasm1(SB)\n\tMOVD $1490, R12\n\tB    callbackasm1(SB)\n\tMOVD $1491, R12\n\tB    callbackasm1(SB)\n\tMOVD $1492, R12\n\tB    callbackasm1(SB)\n\tMOVD $1493, R12\n\tB    callbackasm1(SB)\n\tMOVD $1494, R12\n\tB    callbackasm1(SB)\n\tMOVD $1495, R12\n\tB    callbackasm1(SB)\n\tMOVD $1496, R12\n\tB    callbackasm1(SB)\n\tMOVD $1497, R12\n\tB    callbackasm1(SB)\n\tMOVD $1498, R12\n\tB    callbackasm1(SB)\n\tMOVD $1499, R12\n\tB    callbackasm1(SB)\n\tMOVD $1500, R12\n\tB    callbackasm1(SB)\n\tMOVD $1501, R12\n\tB    callbackasm1(SB)\n\tMOVD $1502, R12\n\tB    callbackasm1(SB)\n\tMOVD $1503, R12\n\tB    callbackasm1(SB)\n\tMOVD $1504, R12\n\tB    callbackasm1(SB)\n\tMOVD $1505, R12\n\tB    callbackasm1(SB)\n\tMOVD $1506, R12\n\tB    callbackasm1(SB)\n\tMOVD $1507, R12\n\tB    callbackasm1(SB)\n\tMOVD $1508, R12\n\tB    callbackasm1(SB)\n\tMOVD $1509, R12\n\tB    callbackasm1(SB)\n\tMOVD $1510, R12\n\tB    callbackasm1(SB)\n\tMOVD $1511, R12\n\tB    callbackasm1(SB)\n\tMOVD $1512, R12\n\tB    callbackasm1(SB)\n\tMOVD $1513, R12\n\tB    callbackasm1(SB)\n\tMOVD $1514, R12\n\tB    callbackasm1(SB)\n\tMOVD $1515, R12\n\tB    callbackasm1(SB)\n\tMOVD $1516, R12\n\tB    callbackasm1(SB)\n\tMOVD $1517, R12\n\tB    callbackasm1(SB)\n\tMOVD $1518, R12\n\tB    callbackasm1(SB)\n\tMOVD $1519, R12\n\tB    callbackasm1(SB)\n\tMOVD $1520, R12\n\tB    callbackasm1(SB)\n\tMOVD $1521, R12\n\tB    callbackasm1(SB)\n\tMOVD $1522, R12\n\tB    callbackasm1(SB)\n\tMOVD $1523, R12\n\tB    callbackasm1(SB)\n\tMOVD $1524, R12\n\tB    callbackasm1(SB)\n\tMOVD $1525, R12\n\tB    callbackasm1(SB)\n\tMOVD $1526, R12\n\tB    callbackasm1(SB)\n\tMOVD $1527, R12\n\tB    callbackasm1(SB)\n\tMOVD $1528, R12\n\tB    callbackasm1(SB)\n\tMOVD $1529, R12\n\tB    callbackasm1(SB)\n\tMOVD $1530, R12\n\tB    callbackasm1(SB)\n\tMOVD $1531, R12\n\tB    callbackasm1(SB)\n\tMOVD $1532, R12\n\tB    callbackasm1(SB)\n\tMOVD $1533, R12\n\tB    callbackasm1(SB)\n\tMOVD $1534, R12\n\tB    callbackasm1(SB)\n\tMOVD $1535, R12\n\tB    callbackasm1(SB)\n\tMOVD $1536, R12\n\tB    callbackasm1(SB)\n\tMOVD $1537, R12\n\tB    callbackasm1(SB)\n\tMOVD $1538, R12\n\tB    callbackasm1(SB)\n\tMOVD $1539, R12\n\tB    callbackasm1(SB)\n\tMOVD $1540, R12\n\tB    callbackasm1(SB)\n\tMOVD $1541, R12\n\tB    callbackasm1(SB)\n\tMOVD $1542, R12\n\tB    callbackasm1(SB)\n\tMOVD $1543, R12\n\tB    callbackasm1(SB)\n\tMOVD $1544, R12\n\tB    callbackasm1(SB)\n\tMOVD $1545, R12\n\tB    callbackasm1(SB)\n\tMOVD $1546, R12\n\tB    callbackasm1(SB)\n\tMOVD $1547, R12\n\tB    callbackasm1(SB)\n\tMOVD $1548, R12\n\tB    callbackasm1(SB)\n\tMOVD $1549, R12\n\tB    callbackasm1(SB)\n\tMOVD $1550, R12\n\tB    callbackasm1(SB)\n\tMOVD $1551, R12\n\tB    callbackasm1(SB)\n\tMOVD $1552, R12\n\tB    callbackasm1(SB)\n\tMOVD $1553, R12\n\tB    callbackasm1(SB)\n\tMOVD $1554, R12\n\tB    callbackasm1(SB)\n\tMOVD $1555, R12\n\tB    callbackasm1(SB)\n\tMOVD $1556, R12\n\tB    callbackasm1(SB)\n\tMOVD $1557, R12\n\tB    callbackasm1(SB)\n\tMOVD $1558, R12\n\tB    callbackasm1(SB)\n\tMOVD $1559, R12\n\tB    callbackasm1(SB)\n\tMOVD $1560, R12\n\tB    callbackasm1(SB)\n\tMOVD $1561, R12\n\tB    callbackasm1(SB)\n\tMOVD $1562, R12\n\tB    callbackasm1(SB)\n\tMOVD $1563, R12\n\tB    callbackasm1(SB)\n\tMOVD $1564, R12\n\tB    callbackasm1(SB)\n\tMOVD $1565, R12\n\tB    callbackasm1(SB)\n\tMOVD $1566, R12\n\tB    callbackasm1(SB)\n\tMOVD $1567, R12\n\tB    callbackasm1(SB)\n\tMOVD $1568, R12\n\tB    callbackasm1(SB)\n\tMOVD $1569, R12\n\tB    callbackasm1(SB)\n\tMOVD $1570, R12\n\tB    callbackasm1(SB)\n\tMOVD $1571, R12\n\tB    callbackasm1(SB)\n\tMOVD $1572, R12\n\tB    callbackasm1(SB)\n\tMOVD $1573, R12\n\tB    callbackasm1(SB)\n\tMOVD $1574, R12\n\tB    callbackasm1(SB)\n\tMOVD $1575, R12\n\tB    callbackasm1(SB)\n\tMOVD $1576, R12\n\tB    callbackasm1(SB)\n\tMOVD $1577, R12\n\tB    callbackasm1(SB)\n\tMOVD $1578, R12\n\tB    callbackasm1(SB)\n\tMOVD $1579, R12\n\tB    callbackasm1(SB)\n\tMOVD $1580, R12\n\tB    callbackasm1(SB)\n\tMOVD $1581, R12\n\tB    callbackasm1(SB)\n\tMOVD $1582, R12\n\tB    callbackasm1(SB)\n\tMOVD $1583, R12\n\tB    callbackasm1(SB)\n\tMOVD $1584, R12\n\tB    callbackasm1(SB)\n\tMOVD $1585, R12\n\tB    callbackasm1(SB)\n\tMOVD $1586, R12\n\tB    callbackasm1(SB)\n\tMOVD $1587, R12\n\tB    callbackasm1(SB)\n\tMOVD $1588, R12\n\tB    callbackasm1(SB)\n\tMOVD $1589, R12\n\tB    callbackasm1(SB)\n\tMOVD $1590, R12\n\tB    callbackasm1(SB)\n\tMOVD $1591, R12\n\tB    callbackasm1(SB)\n\tMOVD $1592, R12\n\tB    callbackasm1(SB)\n\tMOVD $1593, R12\n\tB    callbackasm1(SB)\n\tMOVD $1594, R12\n\tB    callbackasm1(SB)\n\tMOVD $1595, R12\n\tB    callbackasm1(SB)\n\tMOVD $1596, R12\n\tB    callbackasm1(SB)\n\tMOVD $1597, R12\n\tB    callbackasm1(SB)\n\tMOVD $1598, R12\n\tB    callbackasm1(SB)\n\tMOVD $1599, R12\n\tB    callbackasm1(SB)\n\tMOVD $1600, R12\n\tB    callbackasm1(SB)\n\tMOVD $1601, R12\n\tB    callbackasm1(SB)\n\tMOVD $1602, R12\n\tB    callbackasm1(SB)\n\tMOVD $1603, R12\n\tB    callbackasm1(SB)\n\tMOVD $1604, R12\n\tB    callbackasm1(SB)\n\tMOVD $1605, R12\n\tB    callbackasm1(SB)\n\tMOVD $1606, R12\n\tB    callbackasm1(SB)\n\tMOVD $1607, R12\n\tB    callbackasm1(SB)\n\tMOVD $1608, R12\n\tB    callbackasm1(SB)\n\tMOVD $1609, R12\n\tB    callbackasm1(SB)\n\tMOVD $1610, R12\n\tB    callbackasm1(SB)\n\tMOVD $1611, R12\n\tB    callbackasm1(SB)\n\tMOVD $1612, R12\n\tB    callbackasm1(SB)\n\tMOVD $1613, R12\n\tB    callbackasm1(SB)\n\tMOVD $1614, R12\n\tB    callbackasm1(SB)\n\tMOVD $1615, R12\n\tB    callbackasm1(SB)\n\tMOVD $1616, R12\n\tB    callbackasm1(SB)\n\tMOVD $1617, R12\n\tB    callbackasm1(SB)\n\tMOVD $1618, R12\n\tB    callbackasm1(SB)\n\tMOVD $1619, R12\n\tB    callbackasm1(SB)\n\tMOVD $1620, R12\n\tB    callbackasm1(SB)\n\tMOVD $1621, R12\n\tB    callbackasm1(SB)\n\tMOVD $1622, R12\n\tB    callbackasm1(SB)\n\tMOVD $1623, R12\n\tB    callbackasm1(SB)\n\tMOVD $1624, R12\n\tB    callbackasm1(SB)\n\tMOVD $1625, R12\n\tB    callbackasm1(SB)\n\tMOVD $1626, R12\n\tB    callbackasm1(SB)\n\tMOVD $1627, R12\n\tB    callbackasm1(SB)\n\tMOVD $1628, R12\n\tB    callbackasm1(SB)\n\tMOVD $1629, R12\n\tB    callbackasm1(SB)\n\tMOVD $1630, R12\n\tB    callbackasm1(SB)\n\tMOVD $1631, R12\n\tB    callbackasm1(SB)\n\tMOVD $1632, R12\n\tB    callbackasm1(SB)\n\tMOVD $1633, R12\n\tB    callbackasm1(SB)\n\tMOVD $1634, R12\n\tB    callbackasm1(SB)\n\tMOVD $1635, R12\n\tB    callbackasm1(SB)\n\tMOVD $1636, R12\n\tB    callbackasm1(SB)\n\tMOVD $1637, R12\n\tB    callbackasm1(SB)\n\tMOVD $1638, R12\n\tB    callbackasm1(SB)\n\tMOVD $1639, R12\n\tB    callbackasm1(SB)\n\tMOVD $1640, R12\n\tB    callbackasm1(SB)\n\tMOVD $1641, R12\n\tB    callbackasm1(SB)\n\tMOVD $1642, R12\n\tB    callbackasm1(SB)\n\tMOVD $1643, R12\n\tB    callbackasm1(SB)\n\tMOVD $1644, R12\n\tB    callbackasm1(SB)\n\tMOVD $1645, R12\n\tB    callbackasm1(SB)\n\tMOVD $1646, R12\n\tB    callbackasm1(SB)\n\tMOVD $1647, R12\n\tB    callbackasm1(SB)\n\tMOVD $1648, R12\n\tB    callbackasm1(SB)\n\tMOVD $1649, R12\n\tB    callbackasm1(SB)\n\tMOVD $1650, R12\n\tB    callbackasm1(SB)\n\tMOVD $1651, R12\n\tB    callbackasm1(SB)\n\tMOVD $1652, R12\n\tB    callbackasm1(SB)\n\tMOVD $1653, R12\n\tB    callbackasm1(SB)\n\tMOVD $1654, R12\n\tB    callbackasm1(SB)\n\tMOVD $1655, R12\n\tB    callbackasm1(SB)\n\tMOVD $1656, R12\n\tB    callbackasm1(SB)\n\tMOVD $1657, R12\n\tB    callbackasm1(SB)\n\tMOVD $1658, R12\n\tB    callbackasm1(SB)\n\tMOVD $1659, R12\n\tB    callbackasm1(SB)\n\tMOVD $1660, R12\n\tB    callbackasm1(SB)\n\tMOVD $1661, R12\n\tB    callbackasm1(SB)\n\tMOVD $1662, R12\n\tB    callbackasm1(SB)\n\tMOVD $1663, R12\n\tB    callbackasm1(SB)\n\tMOVD $1664, R12\n\tB    callbackasm1(SB)\n\tMOVD $1665, R12\n\tB    callbackasm1(SB)\n\tMOVD $1666, R12\n\tB    callbackasm1(SB)\n\tMOVD $1667, R12\n\tB    callbackasm1(SB)\n\tMOVD $1668, R12\n\tB    callbackasm1(SB)\n\tMOVD $1669, R12\n\tB    callbackasm1(SB)\n\tMOVD $1670, R12\n\tB    callbackasm1(SB)\n\tMOVD $1671, R12\n\tB    callbackasm1(SB)\n\tMOVD $1672, R12\n\tB    callbackasm1(SB)\n\tMOVD $1673, R12\n\tB    callbackasm1(SB)\n\tMOVD $1674, R12\n\tB    callbackasm1(SB)\n\tMOVD $1675, R12\n\tB    callbackasm1(SB)\n\tMOVD $1676, R12\n\tB    callbackasm1(SB)\n\tMOVD $1677, R12\n\tB    callbackasm1(SB)\n\tMOVD $1678, R12\n\tB    callbackasm1(SB)\n\tMOVD $1679, R12\n\tB    callbackasm1(SB)\n\tMOVD $1680, R12\n\tB    callbackasm1(SB)\n\tMOVD $1681, R12\n\tB    callbackasm1(SB)\n\tMOVD $1682, R12\n\tB    callbackasm1(SB)\n\tMOVD $1683, R12\n\tB    callbackasm1(SB)\n\tMOVD $1684, R12\n\tB    callbackasm1(SB)\n\tMOVD $1685, R12\n\tB    callbackasm1(SB)\n\tMOVD $1686, R12\n\tB    callbackasm1(SB)\n\tMOVD $1687, R12\n\tB    callbackasm1(SB)\n\tMOVD $1688, R12\n\tB    callbackasm1(SB)\n\tMOVD $1689, R12\n\tB    callbackasm1(SB)\n\tMOVD $1690, R12\n\tB    callbackasm1(SB)\n\tMOVD $1691, R12\n\tB    callbackasm1(SB)\n\tMOVD $1692, R12\n\tB    callbackasm1(SB)\n\tMOVD $1693, R12\n\tB    callbackasm1(SB)\n\tMOVD $1694, R12\n\tB    callbackasm1(SB)\n\tMOVD $1695, R12\n\tB    callbackasm1(SB)\n\tMOVD $1696, R12\n\tB    callbackasm1(SB)\n\tMOVD $1697, R12\n\tB    callbackasm1(SB)\n\tMOVD $1698, R12\n\tB    callbackasm1(SB)\n\tMOVD $1699, R12\n\tB    callbackasm1(SB)\n\tMOVD $1700, R12\n\tB    callbackasm1(SB)\n\tMOVD $1701, R12\n\tB    callbackasm1(SB)\n\tMOVD $1702, R12\n\tB    callbackasm1(SB)\n\tMOVD $1703, R12\n\tB    callbackasm1(SB)\n\tMOVD $1704, R12\n\tB    callbackasm1(SB)\n\tMOVD $1705, R12\n\tB    callbackasm1(SB)\n\tMOVD $1706, R12\n\tB    callbackasm1(SB)\n\tMOVD $1707, R12\n\tB    callbackasm1(SB)\n\tMOVD $1708, R12\n\tB    callbackasm1(SB)\n\tMOVD $1709, R12\n\tB    callbackasm1(SB)\n\tMOVD $1710, R12\n\tB    callbackasm1(SB)\n\tMOVD $1711, R12\n\tB    callbackasm1(SB)\n\tMOVD $1712, R12\n\tB    callbackasm1(SB)\n\tMOVD $1713, R12\n\tB    callbackasm1(SB)\n\tMOVD $1714, R12\n\tB    callbackasm1(SB)\n\tMOVD $1715, R12\n\tB    callbackasm1(SB)\n\tMOVD $1716, R12\n\tB    callbackasm1(SB)\n\tMOVD $1717, R12\n\tB    callbackasm1(SB)\n\tMOVD $1718, R12\n\tB    callbackasm1(SB)\n\tMOVD $1719, R12\n\tB    callbackasm1(SB)\n\tMOVD $1720, R12\n\tB    callbackasm1(SB)\n\tMOVD $1721, R12\n\tB    callbackasm1(SB)\n\tMOVD $1722, R12\n\tB    callbackasm1(SB)\n\tMOVD $1723, R12\n\tB    callbackasm1(SB)\n\tMOVD $1724, R12\n\tB    callbackasm1(SB)\n\tMOVD $1725, R12\n\tB    callbackasm1(SB)\n\tMOVD $1726, R12\n\tB    callbackasm1(SB)\n\tMOVD $1727, R12\n\tB    callbackasm1(SB)\n\tMOVD $1728, R12\n\tB    callbackasm1(SB)\n\tMOVD $1729, R12\n\tB    callbackasm1(SB)\n\tMOVD $1730, R12\n\tB    callbackasm1(SB)\n\tMOVD $1731, R12\n\tB    callbackasm1(SB)\n\tMOVD $1732, R12\n\tB    callbackasm1(SB)\n\tMOVD $1733, R12\n\tB    callbackasm1(SB)\n\tMOVD $1734, R12\n\tB    callbackasm1(SB)\n\tMOVD $1735, R12\n\tB    callbackasm1(SB)\n\tMOVD $1736, R12\n\tB    callbackasm1(SB)\n\tMOVD $1737, R12\n\tB    callbackasm1(SB)\n\tMOVD $1738, R12\n\tB    callbackasm1(SB)\n\tMOVD $1739, R12\n\tB    callbackasm1(SB)\n\tMOVD $1740, R12\n\tB    callbackasm1(SB)\n\tMOVD $1741, R12\n\tB    callbackasm1(SB)\n\tMOVD $1742, R12\n\tB    callbackasm1(SB)\n\tMOVD $1743, R12\n\tB    callbackasm1(SB)\n\tMOVD $1744, R12\n\tB    callbackasm1(SB)\n\tMOVD $1745, R12\n\tB    callbackasm1(SB)\n\tMOVD $1746, R12\n\tB    callbackasm1(SB)\n\tMOVD $1747, R12\n\tB    callbackasm1(SB)\n\tMOVD $1748, R12\n\tB    callbackasm1(SB)\n\tMOVD $1749, R12\n\tB    callbackasm1(SB)\n\tMOVD $1750, R12\n\tB    callbackasm1(SB)\n\tMOVD $1751, R12\n\tB    callbackasm1(SB)\n\tMOVD $1752, R12\n\tB    callbackasm1(SB)\n\tMOVD $1753, R12\n\tB    callbackasm1(SB)\n\tMOVD $1754, R12\n\tB    callbackasm1(SB)\n\tMOVD $1755, R12\n\tB    callbackasm1(SB)\n\tMOVD $1756, R12\n\tB    callbackasm1(SB)\n\tMOVD $1757, R12\n\tB    callbackasm1(SB)\n\tMOVD $1758, R12\n\tB    callbackasm1(SB)\n\tMOVD $1759, R12\n\tB    callbackasm1(SB)\n\tMOVD $1760, R12\n\tB    callbackasm1(SB)\n\tMOVD $1761, R12\n\tB    callbackasm1(SB)\n\tMOVD $1762, R12\n\tB    callbackasm1(SB)\n\tMOVD $1763, R12\n\tB    callbackasm1(SB)\n\tMOVD $1764, R12\n\tB    callbackasm1(SB)\n\tMOVD $1765, R12\n\tB    callbackasm1(SB)\n\tMOVD $1766, R12\n\tB    callbackasm1(SB)\n\tMOVD $1767, R12\n\tB    callbackasm1(SB)\n\tMOVD $1768, R12\n\tB    callbackasm1(SB)\n\tMOVD $1769, R12\n\tB    callbackasm1(SB)\n\tMOVD $1770, R12\n\tB    callbackasm1(SB)\n\tMOVD $1771, R12\n\tB    callbackasm1(SB)\n\tMOVD $1772, R12\n\tB    callbackasm1(SB)\n\tMOVD $1773, R12\n\tB    callbackasm1(SB)\n\tMOVD $1774, R12\n\tB    callbackasm1(SB)\n\tMOVD $1775, R12\n\tB    callbackasm1(SB)\n\tMOVD $1776, R12\n\tB    callbackasm1(SB)\n\tMOVD $1777, R12\n\tB    callbackasm1(SB)\n\tMOVD $1778, R12\n\tB    callbackasm1(SB)\n\tMOVD $1779, R12\n\tB    callbackasm1(SB)\n\tMOVD $1780, R12\n\tB    callbackasm1(SB)\n\tMOVD $1781, R12\n\tB    callbackasm1(SB)\n\tMOVD $1782, R12\n\tB    callbackasm1(SB)\n\tMOVD $1783, R12\n\tB    callbackasm1(SB)\n\tMOVD $1784, R12\n\tB    callbackasm1(SB)\n\tMOVD $1785, R12\n\tB    callbackasm1(SB)\n\tMOVD $1786, R12\n\tB    callbackasm1(SB)\n\tMOVD $1787, R12\n\tB    callbackasm1(SB)\n\tMOVD $1788, R12\n\tB    callbackasm1(SB)\n\tMOVD $1789, R12\n\tB    callbackasm1(SB)\n\tMOVD $1790, R12\n\tB    callbackasm1(SB)\n\tMOVD $1791, R12\n\tB    callbackasm1(SB)\n\tMOVD $1792, R12\n\tB    callbackasm1(SB)\n\tMOVD $1793, R12\n\tB    callbackasm1(SB)\n\tMOVD $1794, R12\n\tB    callbackasm1(SB)\n\tMOVD $1795, R12\n\tB    callbackasm1(SB)\n\tMOVD $1796, R12\n\tB    callbackasm1(SB)\n\tMOVD $1797, R12\n\tB    callbackasm1(SB)\n\tMOVD $1798, R12\n\tB    callbackasm1(SB)\n\tMOVD $1799, R12\n\tB    callbackasm1(SB)\n\tMOVD $1800, R12\n\tB    callbackasm1(SB)\n\tMOVD $1801, R12\n\tB    callbackasm1(SB)\n\tMOVD $1802, R12\n\tB    callbackasm1(SB)\n\tMOVD $1803, R12\n\tB    callbackasm1(SB)\n\tMOVD $1804, R12\n\tB    callbackasm1(SB)\n\tMOVD $1805, R12\n\tB    callbackasm1(SB)\n\tMOVD $1806, R12\n\tB    callbackasm1(SB)\n\tMOVD $1807, R12\n\tB    callbackasm1(SB)\n\tMOVD $1808, R12\n\tB    callbackasm1(SB)\n\tMOVD $1809, R12\n\tB    callbackasm1(SB)\n\tMOVD $1810, R12\n\tB    callbackasm1(SB)\n\tMOVD $1811, R12\n\tB    callbackasm1(SB)\n\tMOVD $1812, R12\n\tB    callbackasm1(SB)\n\tMOVD $1813, R12\n\tB    callbackasm1(SB)\n\tMOVD $1814, R12\n\tB    callbackasm1(SB)\n\tMOVD $1815, R12\n\tB    callbackasm1(SB)\n\tMOVD $1816, R12\n\tB    callbackasm1(SB)\n\tMOVD $1817, R12\n\tB    callbackasm1(SB)\n\tMOVD $1818, R12\n\tB    callbackasm1(SB)\n\tMOVD $1819, R12\n\tB    callbackasm1(SB)\n\tMOVD $1820, R12\n\tB    callbackasm1(SB)\n\tMOVD $1821, R12\n\tB    callbackasm1(SB)\n\tMOVD $1822, R12\n\tB    callbackasm1(SB)\n\tMOVD $1823, R12\n\tB    callbackasm1(SB)\n\tMOVD $1824, R12\n\tB    callbackasm1(SB)\n\tMOVD $1825, R12\n\tB    callbackasm1(SB)\n\tMOVD $1826, R12\n\tB    callbackasm1(SB)\n\tMOVD $1827, R12\n\tB    callbackasm1(SB)\n\tMOVD $1828, R12\n\tB    callbackasm1(SB)\n\tMOVD $1829, R12\n\tB    callbackasm1(SB)\n\tMOVD $1830, R12\n\tB    callbackasm1(SB)\n\tMOVD $1831, R12\n\tB    callbackasm1(SB)\n\tMOVD $1832, R12\n\tB    callbackasm1(SB)\n\tMOVD $1833, R12\n\tB    callbackasm1(SB)\n\tMOVD $1834, R12\n\tB    callbackasm1(SB)\n\tMOVD $1835, R12\n\tB    callbackasm1(SB)\n\tMOVD $1836, R12\n\tB    callbackasm1(SB)\n\tMOVD $1837, R12\n\tB    callbackasm1(SB)\n\tMOVD $1838, R12\n\tB    callbackasm1(SB)\n\tMOVD $1839, R12\n\tB    callbackasm1(SB)\n\tMOVD $1840, R12\n\tB    callbackasm1(SB)\n\tMOVD $1841, R12\n\tB    callbackasm1(SB)\n\tMOVD $1842, R12\n\tB    callbackasm1(SB)\n\tMOVD $1843, R12\n\tB    callbackasm1(SB)\n\tMOVD $1844, R12\n\tB    callbackasm1(SB)\n\tMOVD $1845, R12\n\tB    callbackasm1(SB)\n\tMOVD $1846, R12\n\tB    callbackasm1(SB)\n\tMOVD $1847, R12\n\tB    callbackasm1(SB)\n\tMOVD $1848, R12\n\tB    callbackasm1(SB)\n\tMOVD $1849, R12\n\tB    callbackasm1(SB)\n\tMOVD $1850, R12\n\tB    callbackasm1(SB)\n\tMOVD $1851, R12\n\tB    callbackasm1(SB)\n\tMOVD $1852, R12\n\tB    callbackasm1(SB)\n\tMOVD $1853, R12\n\tB    callbackasm1(SB)\n\tMOVD $1854, R12\n\tB    callbackasm1(SB)\n\tMOVD $1855, R12\n\tB    callbackasm1(SB)\n\tMOVD $1856, R12\n\tB    callbackasm1(SB)\n\tMOVD $1857, R12\n\tB    callbackasm1(SB)\n\tMOVD $1858, R12\n\tB    callbackasm1(SB)\n\tMOVD $1859, R12\n\tB    callbackasm1(SB)\n\tMOVD $1860, R12\n\tB    callbackasm1(SB)\n\tMOVD $1861, R12\n\tB    callbackasm1(SB)\n\tMOVD $1862, R12\n\tB    callbackasm1(SB)\n\tMOVD $1863, R12\n\tB    callbackasm1(SB)\n\tMOVD $1864, R12\n\tB    callbackasm1(SB)\n\tMOVD $1865, R12\n\tB    callbackasm1(SB)\n\tMOVD $1866, R12\n\tB    callbackasm1(SB)\n\tMOVD $1867, R12\n\tB    callbackasm1(SB)\n\tMOVD $1868, R12\n\tB    callbackasm1(SB)\n\tMOVD $1869, R12\n\tB    callbackasm1(SB)\n\tMOVD $1870, R12\n\tB    callbackasm1(SB)\n\tMOVD $1871, R12\n\tB    callbackasm1(SB)\n\tMOVD $1872, R12\n\tB    callbackasm1(SB)\n\tMOVD $1873, R12\n\tB    callbackasm1(SB)\n\tMOVD $1874, R12\n\tB    callbackasm1(SB)\n\tMOVD $1875, R12\n\tB    callbackasm1(SB)\n\tMOVD $1876, R12\n\tB    callbackasm1(SB)\n\tMOVD $1877, R12\n\tB    callbackasm1(SB)\n\tMOVD $1878, R12\n\tB    callbackasm1(SB)\n\tMOVD $1879, R12\n\tB    callbackasm1(SB)\n\tMOVD $1880, R12\n\tB    callbackasm1(SB)\n\tMOVD $1881, R12\n\tB    callbackasm1(SB)\n\tMOVD $1882, R12\n\tB    callbackasm1(SB)\n\tMOVD $1883, R12\n\tB    callbackasm1(SB)\n\tMOVD $1884, R12\n\tB    callbackasm1(SB)\n\tMOVD $1885, R12\n\tB    callbackasm1(SB)\n\tMOVD $1886, R12\n\tB    callbackasm1(SB)\n\tMOVD $1887, R12\n\tB    callbackasm1(SB)\n\tMOVD $1888, R12\n\tB    callbackasm1(SB)\n\tMOVD $1889, R12\n\tB    callbackasm1(SB)\n\tMOVD $1890, R12\n\tB    callbackasm1(SB)\n\tMOVD $1891, R12\n\tB    callbackasm1(SB)\n\tMOVD $1892, R12\n\tB    callbackasm1(SB)\n\tMOVD $1893, R12\n\tB    callbackasm1(SB)\n\tMOVD $1894, R12\n\tB    callbackasm1(SB)\n\tMOVD $1895, R12\n\tB    callbackasm1(SB)\n\tMOVD $1896, R12\n\tB    callbackasm1(SB)\n\tMOVD $1897, R12\n\tB    callbackasm1(SB)\n\tMOVD $1898, R12\n\tB    callbackasm1(SB)\n\tMOVD $1899, R12\n\tB    callbackasm1(SB)\n\tMOVD $1900, R12\n\tB    callbackasm1(SB)\n\tMOVD $1901, R12\n\tB    callbackasm1(SB)\n\tMOVD $1902, R12\n\tB    callbackasm1(SB)\n\tMOVD $1903, R12\n\tB    callbackasm1(SB)\n\tMOVD $1904, R12\n\tB    callbackasm1(SB)\n\tMOVD $1905, R12\n\tB    callbackasm1(SB)\n\tMOVD $1906, R12\n\tB    callbackasm1(SB)\n\tMOVD $1907, R12\n\tB    callbackasm1(SB)\n\tMOVD $1908, R12\n\tB    callbackasm1(SB)\n\tMOVD $1909, R12\n\tB    callbackasm1(SB)\n\tMOVD $1910, R12\n\tB    callbackasm1(SB)\n\tMOVD $1911, R12\n\tB    callbackasm1(SB)\n\tMOVD $1912, R12\n\tB    callbackasm1(SB)\n\tMOVD $1913, R12\n\tB    callbackasm1(SB)\n\tMOVD $1914, R12\n\tB    callbackasm1(SB)\n\tMOVD $1915, R12\n\tB    callbackasm1(SB)\n\tMOVD $1916, R12\n\tB    callbackasm1(SB)\n\tMOVD $1917, R12\n\tB    callbackasm1(SB)\n\tMOVD $1918, R12\n\tB    callbackasm1(SB)\n\tMOVD $1919, R12\n\tB    callbackasm1(SB)\n\tMOVD $1920, R12\n\tB    callbackasm1(SB)\n\tMOVD $1921, R12\n\tB    callbackasm1(SB)\n\tMOVD $1922, R12\n\tB    callbackasm1(SB)\n\tMOVD $1923, R12\n\tB    callbackasm1(SB)\n\tMOVD $1924, R12\n\tB    callbackasm1(SB)\n\tMOVD $1925, R12\n\tB    callbackasm1(SB)\n\tMOVD $1926, R12\n\tB    callbackasm1(SB)\n\tMOVD $1927, R12\n\tB    callbackasm1(SB)\n\tMOVD $1928, R12\n\tB    callbackasm1(SB)\n\tMOVD $1929, R12\n\tB    callbackasm1(SB)\n\tMOVD $1930, R12\n\tB    callbackasm1(SB)\n\tMOVD $1931, R12\n\tB    callbackasm1(SB)\n\tMOVD $1932, R12\n\tB    callbackasm1(SB)\n\tMOVD $1933, R12\n\tB    callbackasm1(SB)\n\tMOVD $1934, R12\n\tB    callbackasm1(SB)\n\tMOVD $1935, R12\n\tB    callbackasm1(SB)\n\tMOVD $1936, R12\n\tB    callbackasm1(SB)\n\tMOVD $1937, R12\n\tB    callbackasm1(SB)\n\tMOVD $1938, R12\n\tB    callbackasm1(SB)\n\tMOVD $1939, R12\n\tB    callbackasm1(SB)\n\tMOVD $1940, R12\n\tB    callbackasm1(SB)\n\tMOVD $1941, R12\n\tB    callbackasm1(SB)\n\tMOVD $1942, R12\n\tB    callbackasm1(SB)\n\tMOVD $1943, R12\n\tB    callbackasm1(SB)\n\tMOVD $1944, R12\n\tB    callbackasm1(SB)\n\tMOVD $1945, R12\n\tB    callbackasm1(SB)\n\tMOVD $1946, R12\n\tB    callbackasm1(SB)\n\tMOVD $1947, R12\n\tB    callbackasm1(SB)\n\tMOVD $1948, R12\n\tB    callbackasm1(SB)\n\tMOVD $1949, R12\n\tB    callbackasm1(SB)\n\tMOVD $1950, R12\n\tB    callbackasm1(SB)\n\tMOVD $1951, R12\n\tB    callbackasm1(SB)\n\tMOVD $1952, R12\n\tB    callbackasm1(SB)\n\tMOVD $1953, R12\n\tB    callbackasm1(SB)\n\tMOVD $1954, R12\n\tB    callbackasm1(SB)\n\tMOVD $1955, R12\n\tB    callbackasm1(SB)\n\tMOVD $1956, R12\n\tB    callbackasm1(SB)\n\tMOVD $1957, R12\n\tB    callbackasm1(SB)\n\tMOVD $1958, R12\n\tB    callbackasm1(SB)\n\tMOVD $1959, R12\n\tB    callbackasm1(SB)\n\tMOVD $1960, R12\n\tB    callbackasm1(SB)\n\tMOVD $1961, R12\n\tB    callbackasm1(SB)\n\tMOVD $1962, R12\n\tB    callbackasm1(SB)\n\tMOVD $1963, R12\n\tB    callbackasm1(SB)\n\tMOVD $1964, R12\n\tB    callbackasm1(SB)\n\tMOVD $1965, R12\n\tB    callbackasm1(SB)\n\tMOVD $1966, R12\n\tB    callbackasm1(SB)\n\tMOVD $1967, R12\n\tB    callbackasm1(SB)\n\tMOVD $1968, R12\n\tB    callbackasm1(SB)\n\tMOVD $1969, R12\n\tB    callbackasm1(SB)\n\tMOVD $1970, R12\n\tB    callbackasm1(SB)\n\tMOVD $1971, R12\n\tB    callbackasm1(SB)\n\tMOVD $1972, R12\n\tB    callbackasm1(SB)\n\tMOVD $1973, R12\n\tB    callbackasm1(SB)\n\tMOVD $1974, R12\n\tB    callbackasm1(SB)\n\tMOVD $1975, R12\n\tB    callbackasm1(SB)\n\tMOVD $1976, R12\n\tB    callbackasm1(SB)\n\tMOVD $1977, R12\n\tB    callbackasm1(SB)\n\tMOVD $1978, R12\n\tB    callbackasm1(SB)\n\tMOVD $1979, R12\n\tB    callbackasm1(SB)\n\tMOVD $1980, R12\n\tB    callbackasm1(SB)\n\tMOVD $1981, R12\n\tB    callbackasm1(SB)\n\tMOVD $1982, R12\n\tB    callbackasm1(SB)\n\tMOVD $1983, R12\n\tB    callbackasm1(SB)\n\tMOVD $1984, R12\n\tB    callbackasm1(SB)\n\tMOVD $1985, R12\n\tB    callbackasm1(SB)\n\tMOVD $1986, R12\n\tB    callbackasm1(SB)\n\tMOVD $1987, R12\n\tB    callbackasm1(SB)\n\tMOVD $1988, R12\n\tB    callbackasm1(SB)\n\tMOVD $1989, R12\n\tB    callbackasm1(SB)\n\tMOVD $1990, R12\n\tB    callbackasm1(SB)\n\tMOVD $1991, R12\n\tB    callbackasm1(SB)\n\tMOVD $1992, R12\n\tB    callbackasm1(SB)\n\tMOVD $1993, R12\n\tB    callbackasm1(SB)\n\tMOVD $1994, R12\n\tB    callbackasm1(SB)\n\tMOVD $1995, R12\n\tB    callbackasm1(SB)\n\tMOVD $1996, R12\n\tB    callbackasm1(SB)\n\tMOVD $1997, R12\n\tB    callbackasm1(SB)\n\tMOVD $1998, R12\n\tB    callbackasm1(SB)\n\tMOVD $1999, R12\n\tB    callbackasm1(SB)\n"
        }
      ]
    }
  ]
}