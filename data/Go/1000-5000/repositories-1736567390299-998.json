{
  "metadata": {
    "timestamp": 1736567390299,
    "page": 998,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMDA=",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "muesli/cache2go",
      "stars": 2135,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1181640625,
          "content": "# Compiled object files, static and dynamic libs (shared objects)\n*.o\n*.a\n*.so\n*.exe\n\n# Folders\n_test\n\n# Backup files\n*~\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3408203125,
          "content": "run:\n  tests: false\n\nissues:\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - dupl\n    - exportloopref\n    - goconst\n    - godot\n    - godox\n    - goimports\n    - goprintffuncname\n    - gosec\n    - misspell\n    - prealloc\n    - rowserrcheck\n    - sqlclosecheck\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.5087890625,
          "content": "Copyright (c) 2012, Radu Ioan Fericean\n              2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this\nlist of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\nNeither the name of Radu Ioan Fericean nor the names of its contributors may be\nused to endorse or promote products derived from this software without specific\nprior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.6337890625,
          "content": "# cache2go\n\n[![Latest Release](https://img.shields.io/github/release/muesli/cache2go.svg)](https://github.com/muesli/cache2go/releases)\n[![Build Status](https://github.com/muesli/cache2go/workflows/build/badge.svg)](https://github.com/muesli/cache2go/actions)\n[![Coverage Status](https://coveralls.io/repos/github/muesli/cache2go/badge.svg?branch=master)](https://coveralls.io/github/muesli/cache2go?branch=master)\n[![Go ReportCard](https://goreportcard.com/badge/muesli/cache2go)](https://goreportcard.com/report/muesli/cache2go)\n[![GoDoc](https://godoc.org/github.com/golang/gddo?status.svg)](https://pkg.go.dev/github.com/muesli/cache2go)\n\nConcurrency-safe golang caching library with expiration capabilities.\n\n## Installation\n\nMake sure you have a working Go environment (Go 1.2 or higher is required).\nSee the [install instructions](https://golang.org/doc/install.html).\n\nTo install cache2go, simply run:\n\n    go get github.com/muesli/cache2go\n\nTo compile it from source:\n\n    cd $GOPATH/src/github.com/muesli/cache2go\n    go get -u -v\n    go build && go test -v\n\n## Example\n```go\npackage main\n\nimport (\n\t\"github.com/muesli/cache2go\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Keys & values in cache2go can be of arbitrary types, e.g. a struct.\ntype myStruct struct {\n\ttext     string\n\tmoreData []byte\n}\n\nfunc main() {\n\t// Accessing a new cache table for the first time will create it.\n\tcache := cache2go.Cache(\"myCache\")\n\n\t// We will put a new item in the cache. It will expire after\n\t// not being accessed via Value(key) for more than 5 seconds.\n\tval := myStruct{\"This is a test!\", []byte{}}\n\tcache.Add(\"someKey\", 5*time.Second, &val)\n\n\t// Let's retrieve the item from the cache.\n\tres, err := cache.Value(\"someKey\")\n\tif err == nil {\n\t\tfmt.Println(\"Found value in cache:\", res.Data().(*myStruct).text)\n\t} else {\n\t\tfmt.Println(\"Error retrieving value from cache:\", err)\n\t}\n\n\t// Wait for the item to expire in cache.\n\ttime.Sleep(6 * time.Second)\n\tres, err = cache.Value(\"someKey\")\n\tif err != nil {\n\t\tfmt.Println(\"Item is not cached (anymore).\")\n\t}\n\n\t// Add another item that never expires.\n\tcache.Add(\"someKey\", 0, &val)\n\n\t// cache2go supports a few handy callbacks and loading mechanisms.\n\tcache.SetAboutToDeleteItemCallback(func(e *cache2go.CacheItem) {\n\t\tfmt.Println(\"Deleting:\", e.Key(), e.Data().(*myStruct).text, e.CreatedOn())\n\t})\n\n\t// Remove the item from the cache.\n\tcache.Delete(\"someKey\")\n\n\t// And wipe the entire cache table.\n\tcache.Flush()\n}\n```\n\nTo run this example, go to examples/mycachedapp/ and run:\n\n    go run mycachedapp.go\n\nYou can find a [few more examples here](https://github.com/muesli/cache2go/tree/master/examples).\nAlso see our test-cases in cache_test.go for further working examples.\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 0.7578125,
          "content": "/*\n * Simple caching library with expiration capabilities\n *     Copyright (c) 2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\n *\n *   For license see LICENSE.txt\n */\n\npackage cache2go\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc BenchmarkNotFoundAdd(b *testing.B) {\n\ttable := Cache(\"testNotFoundAdd\")\n\n\tvar finish sync.WaitGroup\n\tvar added int32\n\tvar idle int32\n\n\tfn := func(id int) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tif table.NotFoundAdd(i, 0, i+id) {\n\t\t\t\tatomic.AddInt32(&added, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt32(&idle, 1)\n\t\t\t}\n\t\t\ttime.Sleep(0)\n\t\t}\n\t\tfinish.Done()\n\t}\n\n\tfinish.Add(10)\n\tgo fn(0x0000)\n\tgo fn(0x1100)\n\tgo fn(0x2200)\n\tgo fn(0x3300)\n\tgo fn(0x4400)\n\tgo fn(0x5500)\n\tgo fn(0x6600)\n\tgo fn(0x7700)\n\tgo fn(0x8800)\n\tgo fn(0x9900)\n\tfinish.Wait()\n\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 0.7705078125,
          "content": "/*\n * Simple caching library with expiration capabilities\n *     Copyright (c) 2012, Radu Ioan Fericean\n *                   2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\n *\n *   For license see LICENSE.txt\n */\n\npackage cache2go\n\nimport (\n\t\"sync\"\n)\n\nvar (\n\tcache = make(map[string]*CacheTable)\n\tmutex sync.RWMutex\n)\n\n// Cache returns the existing cache table with given name or creates a new one\n// if the table does not exist yet.\nfunc Cache(table string) *CacheTable {\n\tmutex.RLock()\n\tt, ok := cache[table]\n\tmutex.RUnlock()\n\n\tif !ok {\n\t\tmutex.Lock()\n\t\tt, ok = cache[table]\n\t\t// Double check whether the table exists or not.\n\t\tif !ok {\n\t\t\tt = &CacheTable{\n\t\t\t\tname:  table,\n\t\t\t\titems: make(map[interface{}]*CacheItem),\n\t\t\t}\n\t\t\tcache[table] = t\n\t\t}\n\t\tmutex.Unlock()\n\t}\n\n\treturn t\n}\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 10.8349609375,
          "content": "/*\n * Simple caching library with expiration capabilities\n *     Copyright (c) 2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\n *\n *   For license see LICENSE.txt\n */\n\npackage cache2go\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar (\n\tk = \"testkey\"\n\tv = \"testvalue\"\n)\n\nfunc TestCache(t *testing.T) {\n\t// add an expiring item after a non-expiring one to\n\t// trigger expirationCheck iterating over non-expiring items\n\ttable := Cache(\"testCache\")\n\ttable.Add(k+\"_1\", 0*time.Second, v)\n\ttable.Add(k+\"_2\", 1*time.Second, v)\n\n\t// check if both items are still there\n\tp, err := table.Value(k + \"_1\")\n\tif err != nil || p == nil || p.Data().(string) != v {\n\t\tt.Error(\"Error retrieving non expiring data from cache\", err)\n\t}\n\tp, err = table.Value(k + \"_2\")\n\tif err != nil || p == nil || p.Data().(string) != v {\n\t\tt.Error(\"Error retrieving data from cache\", err)\n\t}\n\n\t// sanity checks\n\tif p.AccessCount() != 1 {\n\t\tt.Error(\"Error getting correct access count\")\n\t}\n\tif p.LifeSpan() != 1*time.Second {\n\t\tt.Error(\"Error getting correct life-span\")\n\t}\n\tif p.AccessedOn().Unix() == 0 {\n\t\tt.Error(\"Error getting access time\")\n\t}\n\tif p.CreatedOn().Unix() == 0 {\n\t\tt.Error(\"Error getting creation time\")\n\t}\n}\n\nfunc TestCacheExpire(t *testing.T) {\n\ttable := Cache(\"testCache\")\n\n\ttable.Add(k+\"_1\", 250*time.Millisecond, v+\"_1\")\n\ttable.Add(k+\"_2\", 200*time.Millisecond, v+\"_2\")\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// check key `1` is still alive\n\t_, err := table.Value(k + \"_1\")\n\tif err != nil {\n\t\tt.Error(\"Error retrieving value from cache:\", err)\n\t}\n\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// check key `1` again, it should still be alive since we just accessed it\n\t_, err = table.Value(k + \"_1\")\n\tif err != nil {\n\t\tt.Error(\"Error retrieving value from cache:\", err)\n\t}\n\n\t// check key `2`, it should have been removed by now\n\t_, err = table.Value(k + \"_2\")\n\tif err == nil {\n\t\tt.Error(\"Found key which should have been expired by now\")\n\t}\n}\n\nfunc TestExists(t *testing.T) {\n\t// add an expiring item\n\ttable := Cache(\"testExists\")\n\ttable.Add(k, 0, v)\n\t// check if it exists\n\tif !table.Exists(k) {\n\t\tt.Error(\"Error verifying existing data in cache\")\n\t}\n}\n\nfunc TestNotFoundAdd(t *testing.T) {\n\ttable := Cache(\"testNotFoundAdd\")\n\n\tif !table.NotFoundAdd(k, 0, v) {\n\t\tt.Error(\"Error verifying NotFoundAdd, data not in cache\")\n\t}\n\n\tif table.NotFoundAdd(k, 0, v) {\n\t\tt.Error(\"Error verifying NotFoundAdd data in cache\")\n\t}\n}\n\nfunc TestNotFoundAddConcurrency(t *testing.T) {\n\ttable := Cache(\"testNotFoundAdd\")\n\n\tvar finish sync.WaitGroup\n\tvar added int32\n\tvar idle int32\n\n\tfn := func(id int) {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif table.NotFoundAdd(i, 0, i+id) {\n\t\t\t\tatomic.AddInt32(&added, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt32(&idle, 1)\n\t\t\t}\n\t\t\ttime.Sleep(0)\n\t\t}\n\t\tfinish.Done()\n\t}\n\n\tfinish.Add(10)\n\tgo fn(0x0000)\n\tgo fn(0x1100)\n\tgo fn(0x2200)\n\tgo fn(0x3300)\n\tgo fn(0x4400)\n\tgo fn(0x5500)\n\tgo fn(0x6600)\n\tgo fn(0x7700)\n\tgo fn(0x8800)\n\tgo fn(0x9900)\n\tfinish.Wait()\n\n\tt.Log(added, idle)\n\n\ttable.Foreach(func(key interface{}, item *CacheItem) {\n\t\tv, _ := item.Data().(int)\n\t\tk, _ := key.(int)\n\t\tt.Logf(\"%02x  %04x\\n\", k, v)\n\t})\n}\n\nfunc TestCacheKeepAlive(t *testing.T) {\n\t// add an expiring item\n\ttable := Cache(\"testKeepAlive\")\n\tp := table.Add(k, 250*time.Millisecond, v)\n\n\t// keep it alive before it expires\n\ttime.Sleep(100 * time.Millisecond)\n\tp.KeepAlive()\n\n\t// check it's still alive after it was initially supposed to expire\n\ttime.Sleep(150 * time.Millisecond)\n\tif !table.Exists(k) {\n\t\tt.Error(\"Error keeping item alive\")\n\t}\n\n\t// check it expires eventually\n\ttime.Sleep(300 * time.Millisecond)\n\tif table.Exists(k) {\n\t\tt.Error(\"Error expiring item after keeping it alive\")\n\t}\n}\n\nfunc TestDelete(t *testing.T) {\n\t// add an item to the cache\n\ttable := Cache(\"testDelete\")\n\ttable.Add(k, 0, v)\n\t// check it's really cached\n\tp, err := table.Value(k)\n\tif err != nil || p == nil || p.Data().(string) != v {\n\t\tt.Error(\"Error retrieving data from cache\", err)\n\t}\n\t// try to delete it\n\ttable.Delete(k)\n\t// verify it has been deleted\n\tp, err = table.Value(k)\n\tif err == nil || p != nil {\n\t\tt.Error(\"Error deleting data\")\n\t}\n\n\t// test error handling\n\t_, err = table.Delete(k)\n\tif err == nil {\n\t\tt.Error(\"Expected error deleting item\")\n\t}\n}\n\nfunc TestFlush(t *testing.T) {\n\t// add an item to the cache\n\ttable := Cache(\"testFlush\")\n\ttable.Add(k, 10*time.Second, v)\n\t// flush the entire table\n\ttable.Flush()\n\n\t// try to retrieve the item\n\tp, err := table.Value(k)\n\tif err == nil || p != nil {\n\t\tt.Error(\"Error flushing table\")\n\t}\n\t// make sure there's really nothing else left in the cache\n\tif table.Count() != 0 {\n\t\tt.Error(\"Error verifying count of flushed table\")\n\t}\n}\n\nfunc TestCount(t *testing.T) {\n\t// add a huge amount of items to the cache\n\ttable := Cache(\"testCount\")\n\tcount := 100000\n\tfor i := 0; i < count; i++ {\n\t\tkey := k + strconv.Itoa(i)\n\t\ttable.Add(key, 10*time.Second, v)\n\t}\n\t// confirm every single item has been cached\n\tfor i := 0; i < count; i++ {\n\t\tkey := k + strconv.Itoa(i)\n\t\tp, err := table.Value(key)\n\t\tif err != nil || p == nil || p.Data().(string) != v {\n\t\t\tt.Error(\"Error retrieving data\")\n\t\t}\n\t}\n\t// make sure the item count matches (no dupes etc.)\n\tif table.Count() != count {\n\t\tt.Error(\"Data count mismatch\")\n\t}\n}\n\nfunc TestDataLoader(t *testing.T) {\n\t// setup a cache with a configured data-loader\n\ttable := Cache(\"testDataLoader\")\n\ttable.SetDataLoader(func(key interface{}, args ...interface{}) *CacheItem {\n\t\tvar item *CacheItem\n\t\tif key.(string) != \"nil\" {\n\t\t\tval := k + key.(string)\n\t\t\ti := NewCacheItem(key, 500*time.Millisecond, val)\n\t\t\titem = i\n\t\t}\n\n\t\treturn item\n\t})\n\n\t// make sure data-loader works as expected and handles unloadable keys\n\t_, err := table.Value(\"nil\")\n\tif err == nil || table.Exists(\"nil\") {\n\t\tt.Error(\"Error validating data loader for nil values\")\n\t}\n\n\t// retrieve a bunch of items via the data-loader\n\tfor i := 0; i < 10; i++ {\n\t\tkey := k + strconv.Itoa(i)\n\t\tvp := k + key\n\t\tp, err := table.Value(key)\n\t\tif err != nil || p == nil || p.Data().(string) != vp {\n\t\t\tt.Error(\"Error validating data loader\")\n\t\t}\n\t}\n}\n\nfunc TestAccessCount(t *testing.T) {\n\t// add 100 items to the cache\n\tcount := 100\n\ttable := Cache(\"testAccessCount\")\n\tfor i := 0; i < count; i++ {\n\t\ttable.Add(i, 10*time.Second, v)\n\t}\n\t// never access the first item, access the second item once, the third\n\t// twice and so on...\n\tfor i := 0; i < count; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\ttable.Value(i)\n\t\t}\n\t}\n\n\t// check MostAccessed returns the items in correct order\n\tma := table.MostAccessed(int64(count))\n\tfor i, item := range ma {\n\t\tif item.Key() != count-1-i {\n\t\t\tt.Error(\"Most accessed items seem to be sorted incorrectly\")\n\t\t}\n\t}\n\n\t// check MostAccessed returns the correct amount of items\n\tma = table.MostAccessed(int64(count - 1))\n\tif len(ma) != count-1 {\n\t\tt.Error(\"MostAccessed returns incorrect amount of items\")\n\t}\n}\n\nfunc TestCallbacks(t *testing.T) {\n\tvar m sync.Mutex\n\taddedKey := \"\"\n\tremovedKey := \"\"\n\tcalledAddedItem := false\n\tcalledRemoveItem := false\n\texpired := false\n\tcalledExpired := false\n\n\t// setup a cache with AddedItem & SetAboutToDelete handlers configured\n\ttable := Cache(\"testCallbacks\")\n\ttable.SetAddedItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\taddedKey = item.Key().(string)\n\t\tm.Unlock()\n\t})\n\ttable.SetAddedItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\tcalledAddedItem = true\n\t\tm.Unlock()\n\t})\n\ttable.SetAboutToDeleteItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\tremovedKey = item.Key().(string)\n\t\tm.Unlock()\n\t})\n\n\ttable.SetAboutToDeleteItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\tcalledRemoveItem = true\n\t\tm.Unlock()\n\t})\n\t// add an item to the cache and setup its AboutToExpire handler\n\ti := table.Add(k, 500*time.Millisecond, v)\n\ti.SetAboutToExpireCallback(func(key interface{}) {\n\t\tm.Lock()\n\t\texpired = true\n\t\tm.Unlock()\n\t})\n\n\ti.SetAboutToExpireCallback(func(key interface{}) {\n\t\tm.Lock()\n\t\tcalledExpired = true\n\t\tm.Unlock()\n\t})\n\n\t// verify the AddedItem handler works\n\ttime.Sleep(250 * time.Millisecond)\n\tm.Lock()\n\tif addedKey == k && !calledAddedItem {\n\t\tt.Error(\"AddedItem callback not working\")\n\t}\n\tm.Unlock()\n\t// verify the AboutToDelete handler works\n\ttime.Sleep(500 * time.Millisecond)\n\tm.Lock()\n\tif removedKey == k && !calledRemoveItem {\n\t\tt.Error(\"AboutToDeleteItem callback not working:\" + k + \"_\" + removedKey)\n\t}\n\t// verify the AboutToExpire handler works\n\tif expired && !calledExpired {\n\t\tt.Error(\"AboutToExpire callback not working\")\n\t}\n\tm.Unlock()\n\n}\n\nfunc TestCallbackQueue(t *testing.T) {\n\tvar m sync.Mutex\n\taddedKey := \"\"\n\taddedkeyCallback2 := \"\"\n\tsecondCallbackResult := \"second\"\n\tremovedKey := \"\"\n\tremovedKeyCallback := \"\"\n\texpired := false\n\tcalledExpired := false\n\t// setup a cache with AddedItem & SetAboutToDelete handlers configured\n\ttable := Cache(\"testCallbacks\")\n\n\t// test callback queue\n\ttable.AddAddedItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\taddedKey = item.Key().(string)\n\t\tm.Unlock()\n\t})\n\ttable.AddAddedItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\taddedkeyCallback2 = secondCallbackResult\n\t\tm.Unlock()\n\t})\n\n\ttable.AddAboutToDeleteItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\tremovedKey = item.Key().(string)\n\t\tm.Unlock()\n\t})\n\ttable.AddAboutToDeleteItemCallback(func(item *CacheItem) {\n\t\tm.Lock()\n\t\tremovedKeyCallback = secondCallbackResult\n\t\tm.Unlock()\n\t})\n\n\ti := table.Add(k, 500*time.Millisecond, v)\n\ti.AddAboutToExpireCallback(func(key interface{}) {\n\t\tm.Lock()\n\t\texpired = true\n\t\tm.Unlock()\n\t})\n\ti.AddAboutToExpireCallback(func(key interface{}) {\n\t\tm.Lock()\n\t\tcalledExpired = true\n\t\tm.Unlock()\n\t})\n\n\ttime.Sleep(250 * time.Millisecond)\n\tm.Lock()\n\tif addedKey != k && addedkeyCallback2 != secondCallbackResult {\n\t\tt.Error(\"AddedItem callback queue not working\")\n\t}\n\tm.Unlock()\n\n\ttime.Sleep(500 * time.Millisecond)\n\tm.Lock()\n\tif removedKey != k && removedKeyCallback != secondCallbackResult {\n\t\tt.Error(\"Item removed callback queue not working\")\n\t}\n\tm.Unlock()\n\n\t// test removing of the callbacks\n\ttable.RemoveAddedItemCallbacks()\n\ttable.RemoveAboutToDeleteItemCallback()\n\tsecondItemKey := \"itemKey02\"\n\texpired = false\n\ti = table.Add(secondItemKey, 500*time.Millisecond, v)\n\ti.SetAboutToExpireCallback(func(key interface{}) {\n\t\tm.Lock()\n\t\texpired = true\n\t\tm.Unlock()\n\t})\n\ti.RemoveAboutToExpireCallback()\n\n\t// verify if the callbacks were removed\n\ttime.Sleep(250 * time.Millisecond)\n\tm.Lock()\n\tif addedKey == secondItemKey {\n\t\tt.Error(\"AddedItemCallbacks were not removed\")\n\t}\n\tm.Unlock()\n\n\t// verify the AboutToDelete handler works\n\ttime.Sleep(500 * time.Millisecond)\n\tm.Lock()\n\tif removedKey == secondItemKey {\n\t\tt.Error(\"AboutToDeleteItem not removed\")\n\t}\n\t// verify the AboutToExpire handler works\n\tif !expired && !calledExpired {\n\t\tt.Error(\"AboutToExpire callback not working\")\n\t}\n\tm.Unlock()\n}\n\nfunc TestLogger(t *testing.T) {\n\t// setup a logger\n\tout := new(bytes.Buffer)\n\tl := log.New(out, \"cache2go \", log.Ldate|log.Ltime)\n\n\t// setup a cache with this logger\n\ttable := Cache(\"testLogger\")\n\ttable.SetLogger(l)\n\ttable.Add(k, 0, v)\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// verify the logger has been used\n\tif out.Len() == 0 {\n\t\tt.Error(\"Logger is empty\")\n\t}\n}\n"
        },
        {
          "name": "cacheitem.go",
          "type": "blob",
          "size": 3.1435546875,
          "content": "/*\n * Simple caching library with expiration capabilities\n *     Copyright (c) 2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\n *\n *   For license see LICENSE.txt\n */\n\npackage cache2go\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// CacheItem is an individual cache item\n// Parameter data contains the user-set value in the cache.\ntype CacheItem struct {\n\tsync.RWMutex\n\n\t// The item's key.\n\tkey interface{}\n\t// The item's data.\n\tdata interface{}\n\t// How long will the item live in the cache when not being accessed/kept alive.\n\tlifeSpan time.Duration\n\n\t// Creation timestamp.\n\tcreatedOn time.Time\n\t// Last access timestamp.\n\taccessedOn time.Time\n\t// How often the item was accessed.\n\taccessCount int64\n\n\t// Callback method triggered right before removing the item from the cache\n\taboutToExpire []func(key interface{})\n}\n\n// NewCacheItem returns a newly created CacheItem.\n// Parameter key is the item's cache-key.\n// Parameter lifeSpan determines after which time period without an access the item\n// will get removed from the cache.\n// Parameter data is the item's value.\nfunc NewCacheItem(key interface{}, lifeSpan time.Duration, data interface{}) *CacheItem {\n\tt := time.Now()\n\treturn &CacheItem{\n\t\tkey:           key,\n\t\tlifeSpan:      lifeSpan,\n\t\tcreatedOn:     t,\n\t\taccessedOn:    t,\n\t\taccessCount:   0,\n\t\taboutToExpire: nil,\n\t\tdata:          data,\n\t}\n}\n\n// KeepAlive marks an item to be kept for another expireDuration period.\nfunc (item *CacheItem) KeepAlive() {\n\titem.Lock()\n\tdefer item.Unlock()\n\titem.accessedOn = time.Now()\n\titem.accessCount++\n}\n\n// LifeSpan returns this item's expiration duration.\nfunc (item *CacheItem) LifeSpan() time.Duration {\n\t// immutable\n\treturn item.lifeSpan\n}\n\n// AccessedOn returns when this item was last accessed.\nfunc (item *CacheItem) AccessedOn() time.Time {\n\titem.RLock()\n\tdefer item.RUnlock()\n\treturn item.accessedOn\n}\n\n// CreatedOn returns when this item was added to the cache.\nfunc (item *CacheItem) CreatedOn() time.Time {\n\t// immutable\n\treturn item.createdOn\n}\n\n// AccessCount returns how often this item has been accessed.\nfunc (item *CacheItem) AccessCount() int64 {\n\titem.RLock()\n\tdefer item.RUnlock()\n\treturn item.accessCount\n}\n\n// Key returns the key of this cached item.\nfunc (item *CacheItem) Key() interface{} {\n\t// immutable\n\treturn item.key\n}\n\n// Data returns the value of this cached item.\nfunc (item *CacheItem) Data() interface{} {\n\t// immutable\n\treturn item.data\n}\n\n// SetAboutToExpireCallback configures a callback, which will be called right\n// before the item is about to be removed from the cache.\nfunc (item *CacheItem) SetAboutToExpireCallback(f func(interface{})) {\n\tif len(item.aboutToExpire) > 0 {\n\t\titem.RemoveAboutToExpireCallback()\n\t}\n\titem.Lock()\n\tdefer item.Unlock()\n\titem.aboutToExpire = append(item.aboutToExpire, f)\n}\n\n// AddAboutToExpireCallback appends a new callback to the AboutToExpire queue\nfunc (item *CacheItem) AddAboutToExpireCallback(f func(interface{})) {\n\titem.Lock()\n\tdefer item.Unlock()\n\titem.aboutToExpire = append(item.aboutToExpire, f)\n}\n\n// RemoveAboutToExpireCallback empties the about to expire callback queue\nfunc (item *CacheItem) RemoveAboutToExpireCallback() {\n\titem.Lock()\n\tdefer item.Unlock()\n\titem.aboutToExpire = nil\n}\n"
        },
        {
          "name": "cachetable.go",
          "type": "blob",
          "size": 9.69921875,
          "content": "/*\n * Simple caching library with expiration capabilities\n *     Copyright (c) 2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\n *\n *   For license see LICENSE.txt\n */\n\npackage cache2go\n\nimport (\n\t\"log\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n)\n\n// CacheTable is a table within the cache\ntype CacheTable struct {\n\tsync.RWMutex\n\n\t// The table's name.\n\tname string\n\t// All cached items.\n\titems map[interface{}]*CacheItem\n\n\t// Timer responsible for triggering cleanup.\n\tcleanupTimer *time.Timer\n\t// Current timer duration.\n\tcleanupInterval time.Duration\n\n\t// The logger used for this table.\n\tlogger *log.Logger\n\n\t// Callback method triggered when trying to load a non-existing key.\n\tloadData func(key interface{}, args ...interface{}) *CacheItem\n\t// Callback method triggered when adding a new item to the cache.\n\taddedItem []func(item *CacheItem)\n\t// Callback method triggered before deleting an item from the cache.\n\taboutToDeleteItem []func(item *CacheItem)\n}\n\n// Count returns how many items are currently stored in the cache.\nfunc (table *CacheTable) Count() int {\n\ttable.RLock()\n\tdefer table.RUnlock()\n\treturn len(table.items)\n}\n\n// Foreach all items\nfunc (table *CacheTable) Foreach(trans func(key interface{}, item *CacheItem)) {\n\ttable.RLock()\n\tdefer table.RUnlock()\n\n\tfor k, v := range table.items {\n\t\ttrans(k, v)\n\t}\n}\n\n// SetDataLoader configures a data-loader callback, which will be called when\n// trying to access a non-existing key. The key and 0...n additional arguments\n// are passed to the callback function.\nfunc (table *CacheTable) SetDataLoader(f func(interface{}, ...interface{}) *CacheItem) {\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.loadData = f\n}\n\n// SetAddedItemCallback configures a callback, which will be called every time\n// a new item is added to the cache.\nfunc (table *CacheTable) SetAddedItemCallback(f func(*CacheItem)) {\n\tif len(table.addedItem) > 0 {\n\t\ttable.RemoveAddedItemCallbacks()\n\t}\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.addedItem = append(table.addedItem, f)\n}\n\n//AddAddedItemCallback appends a new callback to the addedItem queue\nfunc (table *CacheTable) AddAddedItemCallback(f func(*CacheItem)) {\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.addedItem = append(table.addedItem, f)\n}\n\n// RemoveAddedItemCallbacks empties the added item callback queue\nfunc (table *CacheTable) RemoveAddedItemCallbacks() {\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.addedItem = nil\n}\n\n// SetAboutToDeleteItemCallback configures a callback, which will be called\n// every time an item is about to be removed from the cache.\nfunc (table *CacheTable) SetAboutToDeleteItemCallback(f func(*CacheItem)) {\n\tif len(table.aboutToDeleteItem) > 0 {\n\t\ttable.RemoveAboutToDeleteItemCallback()\n\t}\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.aboutToDeleteItem = append(table.aboutToDeleteItem, f)\n}\n\n// AddAboutToDeleteItemCallback appends a new callback to the AboutToDeleteItem queue\nfunc (table *CacheTable) AddAboutToDeleteItemCallback(f func(*CacheItem)) {\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.aboutToDeleteItem = append(table.aboutToDeleteItem, f)\n}\n\n// RemoveAboutToDeleteItemCallback empties the about to delete item callback queue\nfunc (table *CacheTable) RemoveAboutToDeleteItemCallback() {\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.aboutToDeleteItem = nil\n}\n\n// SetLogger sets the logger to be used by this cache table.\nfunc (table *CacheTable) SetLogger(logger *log.Logger) {\n\ttable.Lock()\n\tdefer table.Unlock()\n\ttable.logger = logger\n}\n\n// Expiration check loop, triggered by a self-adjusting timer.\nfunc (table *CacheTable) expirationCheck() {\n\ttable.Lock()\n\tif table.cleanupTimer != nil {\n\t\ttable.cleanupTimer.Stop()\n\t}\n\tif table.cleanupInterval > 0 {\n\t\ttable.log(\"Expiration check triggered after\", table.cleanupInterval, \"for table\", table.name)\n\t} else {\n\t\ttable.log(\"Expiration check installed for table\", table.name)\n\t}\n\n\t// To be more accurate with timers, we would need to update 'now' on every\n\t// loop iteration. Not sure it's really efficient though.\n\tnow := time.Now()\n\tsmallestDuration := 0 * time.Second\n\tfor key, item := range table.items {\n\t\t// Cache values so we don't keep blocking the mutex.\n\t\titem.RLock()\n\t\tlifeSpan := item.lifeSpan\n\t\taccessedOn := item.accessedOn\n\t\titem.RUnlock()\n\n\t\tif lifeSpan == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif now.Sub(accessedOn) >= lifeSpan {\n\t\t\t// Item has excessed its lifespan.\n\t\t\ttable.deleteInternal(key)\n\t\t} else {\n\t\t\t// Find the item chronologically closest to its end-of-lifespan.\n\t\t\tif smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) < smallestDuration {\n\t\t\t\tsmallestDuration = lifeSpan - now.Sub(accessedOn)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Setup the interval for the next cleanup run.\n\ttable.cleanupInterval = smallestDuration\n\tif smallestDuration > 0 {\n\t\ttable.cleanupTimer = time.AfterFunc(smallestDuration, func() {\n\t\t\tgo table.expirationCheck()\n\t\t})\n\t}\n\ttable.Unlock()\n}\n\nfunc (table *CacheTable) addInternal(item *CacheItem) {\n\t// Careful: do not run this method unless the table-mutex is locked!\n\t// It will unlock it for the caller before running the callbacks and checks\n\ttable.log(\"Adding item with key\", item.key, \"and lifespan of\", item.lifeSpan, \"to table\", table.name)\n\ttable.items[item.key] = item\n\n\t// Cache values so we don't keep blocking the mutex.\n\texpDur := table.cleanupInterval\n\taddedItem := table.addedItem\n\ttable.Unlock()\n\n\t// Trigger callback after adding an item to cache.\n\tif addedItem != nil {\n\t\tfor _, callback := range addedItem {\n\t\t\tcallback(item)\n\t\t}\n\t}\n\n\t// If we haven't set up any expiration check timer or found a more imminent item.\n\tif item.lifeSpan > 0 && (expDur == 0 || item.lifeSpan < expDur) {\n\t\ttable.expirationCheck()\n\t}\n}\n\n// Add adds a key/value pair to the cache.\n// Parameter key is the item's cache-key.\n// Parameter lifeSpan determines after which time period without an access the item\n// will get removed from the cache.\n// Parameter data is the item's value.\nfunc (table *CacheTable) Add(key interface{}, lifeSpan time.Duration, data interface{}) *CacheItem {\n\titem := NewCacheItem(key, lifeSpan, data)\n\n\t// Add item to cache.\n\ttable.Lock()\n\ttable.addInternal(item)\n\n\treturn item\n}\n\nfunc (table *CacheTable) deleteInternal(key interface{}) (*CacheItem, error) {\n\tr, ok := table.items[key]\n\tif !ok {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\n\t// Cache value so we don't keep blocking the mutex.\n\taboutToDeleteItem := table.aboutToDeleteItem\n\ttable.Unlock()\n\n\t// Trigger callbacks before deleting an item from cache.\n\tif aboutToDeleteItem != nil {\n\t\tfor _, callback := range aboutToDeleteItem {\n\t\t\tcallback(r)\n\t\t}\n\t}\n\n\tr.RLock()\n\tdefer r.RUnlock()\n\tif r.aboutToExpire != nil {\n\t\tfor _, callback := range r.aboutToExpire {\n\t\t\tcallback(key)\n\t\t}\n\t}\n\n\ttable.Lock()\n\ttable.log(\"Deleting item with key\", key, \"created on\", r.createdOn, \"and hit\", r.accessCount, \"times from table\", table.name)\n\tdelete(table.items, key)\n\n\treturn r, nil\n}\n\n// Delete an item from the cache.\nfunc (table *CacheTable) Delete(key interface{}) (*CacheItem, error) {\n\ttable.Lock()\n\tdefer table.Unlock()\n\n\treturn table.deleteInternal(key)\n}\n\n// Exists returns whether an item exists in the cache. Unlike the Value method\n// Exists neither tries to fetch data via the loadData callback nor does it\n// keep the item alive in the cache.\nfunc (table *CacheTable) Exists(key interface{}) bool {\n\ttable.RLock()\n\tdefer table.RUnlock()\n\t_, ok := table.items[key]\n\n\treturn ok\n}\n\n// NotFoundAdd checks whether an item is not yet cached. Unlike the Exists\n// method this also adds data if the key could not be found.\nfunc (table *CacheTable) NotFoundAdd(key interface{}, lifeSpan time.Duration, data interface{}) bool {\n\ttable.Lock()\n\n\tif _, ok := table.items[key]; ok {\n\t\ttable.Unlock()\n\t\treturn false\n\t}\n\n\titem := NewCacheItem(key, lifeSpan, data)\n\ttable.addInternal(item)\n\n\treturn true\n}\n\n// Value returns an item from the cache and marks it to be kept alive. You can\n// pass additional arguments to your DataLoader callback function.\nfunc (table *CacheTable) Value(key interface{}, args ...interface{}) (*CacheItem, error) {\n\ttable.RLock()\n\tr, ok := table.items[key]\n\tloadData := table.loadData\n\ttable.RUnlock()\n\n\tif ok {\n\t\t// Update access counter and timestamp.\n\t\tr.KeepAlive()\n\t\treturn r, nil\n\t}\n\n\t// Item doesn't exist in cache. Try and fetch it with a data-loader.\n\tif loadData != nil {\n\t\titem := loadData(key, args...)\n\t\tif item != nil {\n\t\t\ttable.Add(key, item.lifeSpan, item.data)\n\t\t\treturn item, nil\n\t\t}\n\n\t\treturn nil, ErrKeyNotFoundOrLoadable\n\t}\n\n\treturn nil, ErrKeyNotFound\n}\n\n// Flush deletes all items from this cache table.\nfunc (table *CacheTable) Flush() {\n\ttable.Lock()\n\tdefer table.Unlock()\n\n\ttable.log(\"Flushing table\", table.name)\n\n\ttable.items = make(map[interface{}]*CacheItem)\n\ttable.cleanupInterval = 0\n\tif table.cleanupTimer != nil {\n\t\ttable.cleanupTimer.Stop()\n\t}\n}\n\n// CacheItemPair maps key to access counter\ntype CacheItemPair struct {\n\tKey         interface{}\n\tAccessCount int64\n}\n\n// CacheItemPairList is a slice of CacheItemPairs that implements sort.\n// Interface to sort by AccessCount.\ntype CacheItemPairList []CacheItemPair\n\nfunc (p CacheItemPairList) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p CacheItemPairList) Len() int           { return len(p) }\nfunc (p CacheItemPairList) Less(i, j int) bool { return p[i].AccessCount > p[j].AccessCount }\n\n// MostAccessed returns the most accessed items in this cache table\nfunc (table *CacheTable) MostAccessed(count int64) []*CacheItem {\n\ttable.RLock()\n\tdefer table.RUnlock()\n\n\tp := make(CacheItemPairList, len(table.items))\n\ti := 0\n\tfor k, v := range table.items {\n\t\tp[i] = CacheItemPair{k, v.accessCount}\n\t\ti++\n\t}\n\tsort.Sort(p)\n\n\tvar r []*CacheItem\n\tc := int64(0)\n\tfor _, v := range p {\n\t\tif c >= count {\n\t\t\tbreak\n\t\t}\n\n\t\titem, ok := table.items[v.Key]\n\t\tif ok {\n\t\t\tr = append(r, item)\n\t\t}\n\t\tc++\n\t}\n\n\treturn r\n}\n\n// Internal logging method for convenience.\nfunc (table *CacheTable) log(v ...interface{}) {\n\tif table.logger == nil {\n\t\treturn\n\t}\n\n\ttable.logger.Println(v...)\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.5625,
          "content": "/*\n * Simple caching library with expiration capabilities\n *     Copyright (c) 2013-2017, Christian Muehlhaeuser <muesli@gmail.com>\n *\n *   For license see LICENSE.txt\n */\n\npackage cache2go\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\t// ErrKeyNotFound gets returned when a specific key couldn't be found\n\tErrKeyNotFound = errors.New(\"Key not found in cache\")\n\t// ErrKeyNotFoundOrLoadable gets returned when a specific key couldn't be\n\t// found and loading via the data-loader callback also failed\n\tErrKeyNotFoundOrLoadable = errors.New(\"Key not found and could not be loaded into cache\")\n)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/muesli/cache2go\n\ngo 1.15\n"
        }
      ]
    }
  ]
}