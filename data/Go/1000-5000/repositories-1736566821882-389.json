{
  "metadata": {
    "timestamp": 1736566821882,
    "page": 389,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "parnurzeal/gorequest",
      "stars": 3449,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2568359375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n.idea\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\ntags\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.19921875,
          "content": "language: go\ngo:\n  - 1.7\n  - 1.6\n  - 1.5\n  - 1.4\n  - 1.3\n  - 1.2\ninstall:\n  - go get -t -v ./...\nnotifications:\n  email:\n    recipients: parnurzeal@gmail.com\n    on_success: change\n    on_failure: always\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 3.177734375,
          "content": "Changelog\n=========\n\nv0.2.15 (2016-08-30)\n\n\tFeatures\n\t\t* Allow float and boolean in Query()'s queryStruct @davyzhang\n\t\t* Support Map in Query() @yangmls\n\t\t* Support Map in Send() @longlongh4\n\t\t* Document RedirectPolicy @codegoalie\n\t\t* Enable Debug mode by ENV variable @heytitle\n\t\t* Add Retry() @xild\n\tBug/Fixes\n\t\t* Allow bodies with all methods @pkopac\n\t\t* Change std \"errors\" pkg to \"github.com/pkg/errors\" @pkopac\n\nv0.2.14 (2016-08-30)\n\n\tFeatures\n\t\t* Support multipart @fraenky8\n\t\t* Support OPTIONS request @coderhaoxin\n\t\t* Add EndStruct method @franciscocpg\n\t\t* Add AsCurlCommand @jaytaylor\n\t\t* Add CustomMethod @WaveCutz\n\t\t* Add MakeRequest @quangbuule\n\tBug/Fixes\n\t\t* Disable keep alive by default\n\n\nv0.2.13 (2015-11-21)\n\n\tFeatures\n\t\t* Add DisableTransportSwap to stop gorequest from modifying Transport settings.\n\t\t\tNote that this will effect many functions that modify gorequest's\n\t\t\ttranport. (So, use with caution.) (Bug #47, PR #59 by @piotrmiskiewicz)\n\n\nv0.2.12 (2015-11-21)\n\n\tFeatures\n\t\t* Add SetCurlCommand for printing comparable CURL command of the request\n\t\t(PR #60 by @QuentinPerez)\n\nv0.2.11 (2015-10-24)\n\n\tBug/Fixes\n\t\t* Add support to Slice data structure (Bug #40, #42)\n\t\t* Refactor sendStruct to be public function SendStruct\n\nv0.2.10 (2015-10-24)\n\n\tBug/Fixes\n\t\t* Fix incorrect text output in tests (PR #52 by @QuentinPerez)\n\t\t* Fix Panic and runtime error properly (PR #53 by @QuentinPerez)\n\t\t* Add support for \"text/plain\" and \"application/xml\" (PR #51 by\n\t\t@smallnest)\n\t\t* Content-Type header is also equivalent with Type function to identify\n\t\tsupported Gorequest's Target Type\n\nv0.2.9 (2015-08-16)\n\n\tBug/Fixes\n\t\t* ParseQuery accepts ; as a synonym for &. thus Gorequest Query won't\n\t\taccept ; as in a query string. We add additional Param to solve this  (PR\n\t\t#43 by @6david9)\n\t\t* AddCookies for bulk adding cookies (PR #46 by @pencil001)\n\nv0.2.8 (2015-08-10)\n\n  Bug/Fixes\n    * Added SetDebug and SetLogger for debug mode (PR #28 by @dafang)\n    * Ensure the response Body is reusable (PR #37 by alaingilbert)\n\nv0.2.7 (2015-07-11)\n\n\tBug/Fixes\n\t\t* Incorrectly reset \"Authentication\" header (Hot fix by @na-ga PR #38 & Issue #39)\n\nv0.2.6 (2015-07-10)\n\n  Features\n    * Added EndBytes (PR #30 by @jaytaylor)\n\nv0.2.5 (2015-07-01)\n\n  Features\n    * Added Basic Auth support (pull request #24 by @dickeyxxx)\n\n  Bug/Fixes\n    * Fix #31 incorrect number conversion (PR #34 by @killix)\n\nv0.2.4 (2015-04-13)\n\n\tFeatures\n\t\t* Query() now supports Struct as same as Send() (pull request #25 by @figlief)\n\nv0.2.3 (2015-02-08)\n\n\tFeatures\n  \t* Added Patch HTTP Method\n\n\tBug/Fixes\n\t\t* Refactored testing code\n\nv0.2.2 (2015-01-03)\n\n\tFeatures\n  \t* Added TLSClientConfig for better control over tls\n\t\t* Added AddCookie func to set \"Cookie\" field in request (pull request #17 by @austinov) - Issue #7\n\t\t* Added CookieJar (pull request #15 by @kemadz)\n\nv0.2.1 (2014-07-06)\n\n\tFeatures\n  \t* Implemented timeout test\n\n\tBugs/Fixes\n  \t* Improved timeout feature by control over both dial + read/write timeout compared to previously controlling only dial connection timeout.\n\nv0.2.0 (2014-06-13) - Send is now supporting Struct type as a parameter\n\nv0.1.0 (2014-04-14) - Finished release with enough rich functions to do get, post, json and redirectpolicy\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.7373046875,
          "content": "# Contributing to GoRequest\n\nThanks for taking the time to contribute!!\n\nGoRequest welcomes any kind of contributions including documentation, bug reports,\nissues, feature requests, feature implementations, pull requests, helping to manage and answer issues, etc.\n\n### Code Guidelines\n\nTo make the contribution process as seamless as possible, we ask for the following:\n\n* Go ahead and fork the project and make your changes.  We encourage pull requests to allow for review and discussion of code changes.\n* When you’re ready to create a pull request, be sure to:\n    * Have test cases for the new code.\n    * Follow [GoDoc](https://blog.golang.org/godoc-documenting-go-code) guideline and always add documentation for new function/variable definitions.\n    * Run `go fmt`.\n    * Additonally, add documentation to README.md if you are adding new features or changing functionality.\n    * Squash your commits into a single commit. `git rebase -i`. It’s okay to force update your pull request with `git push -f`.\n    * Make sure `go test ./...` passes, and `go build` completes.\n    * Follow the **Git Commit Message Guidelines** below.\n\n### Writing Commit Message\n\nFollow this [blog article](http://chris.beams.io/posts/git-commit/). It is a good resource for learning how to write good commit messages,\nthe most important part being that each commit message should have a title/subject in imperative mood starting with a capital letter and no trailing period:\n*\"Return error when sending incorrect JSON format\"*, **NOT** *\"returning some error.\"*\nAlso, if your commit references one or more GitHub issues, always end your commit message body with *See #1234* or *Fixes #1234*.\nReplace *1234* with the GitHub issue ID. The last example will close the issue when the commit is merged into *master*.\n\n### Sending a Pull Request\n\nDue to the way Go handles package imports, the best approach for working on a\nfork is to use Git Remotes.  You can follow the instructions below:\n\n1. Get the latest sources:\n\n    ```\n    go get -u -t github.com/parnurzeal/gorequest/...\n    ```\n\n1. Change to the GoRequest source directory:\n\n    ```\n    cd $GOPATH/src/github.com/parnurzeal/gorequest\n    ```\n\n1. Create a new branch for your changes (the branch name is arbitrary):\n\n    ```\n    git checkout -b issue_1234\n    ```\n\n1. After making your changes, commit them to your new branch:\n\n    ```\n    git commit -a -v\n    ```\n\n1. Fork GoRequest in Github.\n\n1. Add your fork as a new remote (the remote name, \"fork\" in this example, is arbitrary):\n\n    ```\n    git remote add fork git://github.com/USERNAME/gorequest.git\n    ```\n\n1. Push the changes to your new remote:\n\n    ```\n    git push --set-upstream fork issue_1234\n    ```\n\n1. You're now ready to submit a PR based upon the new branch in your forked repository.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Theeraphol Wattanavekin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.818359375,
          "content": "GoRequest\n=========\n\nGoRequest -- Simplified HTTP client ( inspired by famous SuperAgent lib in Node.js )\n\n![GopherGoRequest](https://raw.githubusercontent.com/parnurzeal/gorequest/gh-pages/images/Gopher_GoRequest_400x300.jpg)\n\n#### \"Shooting Requests like a Machine Gun\" - Gopher\n\nSending request has never been as fun nor easier than this. It comes with lots of features:\n\n* Get/Post/Put/Head/Delete/Patch/Options\n* Set - simple header setting\n* JSON - made it simple with JSON string as a parameter\n* Multipart-Support - send data and files as multipart request\n* Proxy - sending request via proxy\n* Timeout - setting timeout for a request\n* TLSClientConfig - taking control over tls where at least you can disable security check for https\n* RedirectPolicy\n* Cookie - setting cookies for your request\n* CookieJar - automatic in-memory cookiejar\n* BasicAuth - setting basic authentication header\n* more to come..\n\n## Installation\n\n```bash\n$ go get github.com/parnurzeal/gorequest\n```\n\n## Documentation\nSee [Go Doc](http://godoc.org/github.com/parnurzeal/gorequest) or [Go Walker](http://gowalker.org/github.com/parnurzeal/gorequest) for usage and details.\n\n## Status\n\n[![Drone Build Status](https://drone.io/github.com/jmcvetta/restclient/status.png)](https://drone.io/github.com/parnurzeal/gorequest/latest)\n[![Travis Build Status](https://travis-ci.org/parnurzeal/gorequest.svg?branch=master)](https://travis-ci.org/parnurzeal/gorequest)\n\n## Why should you use GoRequest?\n\nGoRequest makes thing much more simple for you, making http client more awesome and fun like SuperAgent + golang style usage.\n\nThis is what you normally do for a simple GET without GoRequest:\n\n```go\nresp, err := http.Get(\"http://example.com/\")\n```\n\nWith GoRequest:\n\n```go\nrequest := gorequest.New()\nresp, body, errs := request.Get(\"http://example.com/\").End()\n```\n\nOr below if you don't want to reuse it for other requests.\n\n```go\nresp, body, errs := gorequest.New().Get(\"http://example.com/\").End()\n```\n\nHow about getting control over HTTP client headers, redirect policy, and etc. Things can quickly get more complicated in golang. You need to create a Client, set headers in a different command, ... just to do only one __GET__\n\n```go\nclient := &http.Client{\n  CheckRedirect: redirectPolicyFunc,\n}\n\nreq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\nreq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\nresp, err := client.Do(req)\n```\n\nWhy make things ugly while you can just do it as follows:\n\n```go\nrequest := gorequest.New()\nresp, body, errs := request.Get(\"http://example.com\").\n  RedirectPolicy(redirectPolicyFunc).\n  Set(\"If-None-Match\", `W/\"wyzzy\"`).\n  End()\n```\n\n__DELETE__, __HEAD__, __POST__, __PUT__, __PATCH__ are now supported and can be used in the same way as __GET__:\n\n```go\nrequest := gorequest.New()\nresp, body, errs := request.Post(\"http://example.com\").End()\n// PUT -> request.Put(\"http://example.com\").End()\n// DELETE -> request.Delete(\"http://example.com\").End()\n// HEAD -> request.Head(\"http://example.com\").End()\n// ANYTHING -> request.CustomMethod(\"TRACE\", \"http://example.com\").End()\n```\n\n### JSON\n\nFor a __JSON POST__ with standard libraries, you might need to marshal map data structure to json format, set headers to 'application/json' (and other headers if you need to) and declare http.Client. So, your code becomes longer and harder to maintain:\n\n```go\nm := map[string]interface{}{\n  \"name\": \"backy\",\n  \"species\": \"dog\",\n}\nmJson, _ := json.Marshal(m)\ncontentReader := bytes.NewReader(mJson)\nreq, _ := http.NewRequest(\"POST\", \"http://example.com\", contentReader)\nreq.Header.Set(\"Content-Type\", \"application/json\")\nreq.Header.Set(\"Notes\",\"GoRequest is coming!\")\nclient := &http.Client{}\nresp, _ := client.Do(req)\n```\n\nCompared to our GoRequest version, JSON is for sure a default. So, it turns out to be just one simple line!:\n\n```go\nrequest := gorequest.New()\nresp, body, errs := request.Post(\"http://example.com\").\n  Set(\"Notes\",\"gorequst is coming!\").\n  Send(`{\"name\":\"backy\", \"species\":\"dog\"}`).\n  End()\n```\n\nMoreover, it also supports struct type. So, you can have a fun __Mix & Match__ sending the different data types for your request:\n\n```go\ntype BrowserVersionSupport struct {\n  Chrome string\n  Firefox string\n}\nver := BrowserVersionSupport{ Chrome: \"37.0.2041.6\", Firefox: \"30.0\" }\nrequest := gorequest.New()\nresp, body, errs := request.Post(\"http://version.com/update\").\n  Send(ver).\n  Send(`{\"Safari\":\"5.1.10\"}`).\n  End()\n```\n\nNot only for Send() but Query() is also supported. Just give it a try! :)\n\n## Callback\n\nMoreover, GoRequest also supports callback function. This gives you much more flexibility on using it. You can use it any way to match your own style!\nLet's see a bit of callback example:\n\n```go\nfunc printStatus(resp gorequest.Response, body string, errs []error){\n  fmt.Println(resp.Status)\n}\ngorequest.New().Get(\"http://example.com\").End(printStatus)\n```\n\n## Multipart/Form-Data\n\nYou can specify the content-type of the request to type `multipart` to send all data as `multipart/form-data`. This feature also allows you to send (multiple) files! Check the examples below!\n\n```go\ngorequest.New().Post(\"http://example.com/\").\n  Type(\"multipart\").\n  Send(`{\"query1\":\"test\"}`).\n  End()\n```\n\nThe `SendFile` function accepts `strings` as path to a file, `[]byte` slice or even a `os.File`! You can also combine them to send multiple files with either custom name and/or custom fieldname:\n\n```go\n          f, _ := filepath.Abs(\"./file2.txt\")\nbytesOfFile, _ := ioutil.ReadFile(f)\n\ngorequest.New().Post(\"http://example.com/\").\n  Type(\"multipart\").\n  SendFile(\"./file1.txt\").\n  SendFile(bytesOfFile, \"file2.txt\", \"my_file_fieldname\").\n  End()\n```\n\nCheck the docs for `SendFile` to get more information about the types of arguments.\n\n## Headers\n\nWhen setting one header to the request, the `Set` method can be used:\n\n```go\ngorequest.New().\n      Post(\"/gamelist\").\n      Set(\"Accept\", \"application/json\").\n      End()\n```\n\nThis will clear all headers currently attached to a request and add the specified header.\n\nIf there are multiple headers that must be appended to the request before sending, use `AppendHeader`. These can be chained together to add additional headers to the request:\n\n```go\ngorequest.New().\n      Post(\"/gamelist\").\n      AppendHeader(\"Accept\", \"application/json\").\n      AppendHeader(\"Accept\", \"text/plain\").\n      End()\n```\n\nSee the docs for the `Set` and `AppendHeader` methods for information about parameter and return types.\n\n## Proxy\n\nIn the case when you are behind proxy, GoRequest can handle it easily with Proxy func:\n\n```go\nrequest := gorequest.New().Proxy(\"http://proxy:999\")\nresp, body, errs := request.Get(\"http://example-proxy.com\").End()\n// To reuse same client with no_proxy, use empty string:\nresp, body, errs = request.Proxy(\"\").Get(\"http://example-no-proxy.com\").End()\n```\n\n## Basic Authentication\n\nTo add a basic authentication header:\n\n```go\nrequest := gorequest.New().SetBasicAuth(\"username\", \"password\")\nresp, body, errs := request.Get(\"http://example-proxy.com\").End()\n```\n\n## Timeout\n\nTimeout can be set in any time duration using time package:\n\n```go\nrequest := gorequest.New().Timeout(2*time.Millisecond)\nresp, body, errs:= request.Get(\"http://example.com\").End()\n```\n\nTimeout func defines both dial + read/write timeout to the specified time parameter.\n\n## EndBytes\n\nThanks to @jaytaylor, we now have EndBytes to use when you want the body as bytes.\n\nThe callbacks work the same way as with `End`, except that a byte array is used instead of a string.\n\n```go\nresp, bodyBytes, errs := gorequest.New().Get(\"http://example.com/\").EndBytes()\n```\n\n## EndStruct\n\nWe now have EndStruct to use when you want the body as struct.\n\nThe callbacks work the same way as with `End`, except that a struct is used instead of a string.\n\nSupposing the URL **http://example.com/** returns the body `{\"hey\":\"you\"}`\n\n```go\nheyYou struct {\n  Hey string `json:\"hey\"`\n}\n\nvar heyYou heyYou\n\nresp, _, errs := gorequest.New().Get(\"http://example.com/\").EndStruct(&heyYou)\n```\n\n## Retry\n\nSupposing you need retry 3 times, with 5 seconds between each attempt when gets a BadRequest or a InternalServerError\n\n```go\nrequest := gorequest.New()\nresp, body, errs := request.Get(\"http://example.com/\").\n                    Retry(3, 5 * time.Second, http.StatusBadRequest, http.StatusInternalServerError).\n                    End()\n```\n\n## Handling Redirects\n\nRedirects can be handled with RedirectPolicy which behaves similarly to\nnet/http Client's [CheckRedirect\nfunction](https://golang.org/pkg/net/http#Client). Simply specify a function\nwhich takes the Request about to be made and a slice of previous Requests in\norder of oldest first. When this function returns an error, the Request is not\nmade.\n\nFor example to redirect only to https endpoints:\n\n```go\nrequest := gorequest.New()\nresp, body, errs := request.Get(\"http://example.com/\").\n                    RedirectPolicy(func(req Request, via []*Request) error {\n                      if req.URL.Scheme != \"https\" {\n                        return http.ErrUseLastResponse\n                      }\n                    }).\n                    End()\n```\n\n\n## Clone\n\nYou can reuse settings of a Request by cloning it _before_ making any requests. This can be useful if you wish to re-use the SuperAgent across multiple requests without worrying about concurrency or having too many Transports being created.\n\nClones will copy the same settings (headers, query, etc..), but will only shallow copy any \"Data\" given to it. They will also share the same Transport and http.Client.\n\n```go\nbaseRequest := gorequest.New()\n// apply anything you want to these settings. Eg:\nbaseRequest.Timeout(10 * time.Millisecond).\n  BasicAuth(\"user\", \"password\")\n\n// then reuse the base request elsewhere, cloning before modifying or using it.\nresp, body, errs := baseRequest.Clone().Get(\"http://exmaple.com/\").End()\n```\n\n## Debug\n\nFor debugging, GoRequest leverages `httputil` to dump details of every request/response. (Thanks to @dafang)\n\nYou can just use `SetDebug` or environment variable `GOREQUEST_DEBUG=0|1` to enable/disable debug mode and `SetLogger` to set your own choice of logger.\n\nThanks to @QuentinPerez, we can see even how gorequest is compared to CURL by using `SetCurlCommand`.\n\n## Noted\nAs the underlying gorequest is based on http.Client in most use cases, gorequest.New() should be called once and reuse gorequest as much as possible.\n\n## Contributing to GoRequest:\n\nIf you find any improvement or issue you want to fix, feel free to send me a pull request with testing.\n\nThanks to all contributors thus far:\n\n\n|   Contributors                        |\n|---------------------------------------|\n| https://github.com/alaingilbert       |\n| https://github.com/austinov           |\n| https://github.com/coderhaoxin        |\n| https://github.com/codegoalie         |\n| https://github.com/dafang             |\n| https://github.com/davyzhang          |\n| https://github.com/dickeyxxx          |\n| https://github.com/figlief            |\n| https://github.com/fraenky8           |\n| https://github.com/franciscocpg       |\n| https://github.com/heytitle           |\n| https://github.com/hownowstephen      |\n| https://github.com/kemadz             |\n| https://github.com/killix             |\n| https://github.com/jaytaylor          |\n| https://github.com/na-ga              |\n| https://github.com/piotrmiskiewicz    |\n| https://github.com/pencil001          |\n| https://github.com/pkopac             |\n| https://github.com/quangbuule         |\n| https://github.com/QuentinPerez       |\n| https://github.com/smallnest          |\n| https://github.com/WaveCutz           |\n| https://github.com/xild               |\n| https://github.com/yangmls            |\n| https://github.com/6david9            |\n\n\nAlso, co-maintainer is needed here. If anyone is interested, please email me (parnurzeal at gmail.com)\n\n## Credits\n\n* Renee French - the creator of Gopher mascot\n* [Wisi Mongkhonsrisawat](https://www.facebook.com/puairw) for providing an awesome GoRequest's Gopher image :)\n\n## License\n\nGoRequest is MIT License.\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2529296875,
          "content": "module parnurzeal/gorequest\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/elazarl/goproxy v0.0.0-20231117061959-7cc037d33fb5\n\tgithub.com/pkg/errors v0.9.1\n\tgolang.org/x/net v0.21.0\n\tmoul.io/http2curl v1.0.0\n)\n\nrequire github.com/smartystreets/goconvey v1.8.1 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.736328125,
          "content": "github.com/elazarl/goproxy v0.0.0-20231117061959-7cc037d33fb5 h1:m62nsMU279qRD9PQSWD1l66kmkXzuYcnVJqL4XLeV2M=\ngithub.com/elazarl/goproxy v0.0.0-20231117061959-7cc037d33fb5/go.mod h1:Ro8st/ElPeALwNFlcTpWmkr6IoMFfkjXAvTHpevnDsM=\ngithub.com/elazarl/goproxy/ext v0.0.0-20190711103511-473e67f1d7d2 h1:dWB6v3RcOy03t/bUadywsbyrQwCqZeNIEX6M1OtSZOM=\ngithub.com/elazarl/goproxy/ext v0.0.0-20190711103511-473e67f1d7d2/go.mod h1:gNh8nYJoAm43RfaxurUnxr+N1PwuFV3ZMl/efxlIlY8=\ngithub.com/gopherjs/gopherjs v1.17.2 h1:fQnZVsXk8uxXIStYb0N4bGk7jeyTalG/wsZjQ25dO0g=\ngithub.com/gopherjs/gopherjs v1.17.2/go.mod h1:pRRIvn/QzFLrKfvEz3qUuEhtE/zLCWfreZ6J5gM2i+k=\ngithub.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=\ngithub.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/rogpeppe/go-charset v0.0.0-20180617210344-2471d30d28b4/go.mod h1:qgYeAmZ5ZIpBWTGllZSQnw97Dj+woV0toclVaRGI8pc=\ngithub.com/smarty/assertions v1.15.0 h1:cR//PqUBUiQRakZWqBiFFQ9wb8emQGDb0HeGdqGByCY=\ngithub.com/smarty/assertions v1.15.0/go.mod h1:yABtdzeQs6l1brC900WlRNwj6ZR55d7B+E8C6HtKdec=\ngithub.com/smartystreets/goconvey v1.8.1 h1:qGjIddxOk4grTu9JPOU31tVfq3cNdBlNa5sSznIX1xY=\ngithub.com/smartystreets/goconvey v1.8.1/go.mod h1:+/u4qLyY6x1jReYOp7GOM2FSt8aP9CzCZL03bI28W60=\ngolang.org/x/net v0.21.0 h1:AQyQV4dYCvJ7vGmJyKki9+PBdyvhkSd8EIx/qb0AYv4=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\nmoul.io/http2curl v1.0.0 h1:6XwpyZOYsgZJrU8exnG87ncVkU1FVCcTRpwzOkTDUi8=\nmoul.io/http2curl v1.0.0/go.mod h1:f6cULg+e4Md/oW1cYmwW4IWQOVl2lGbmCNGOHvzX2kE=\n"
        },
        {
          "name": "gorequest.go",
          "type": "blob",
          "size": 40.6884765625,
          "content": "// Package gorequest inspired by Nodejs SuperAgent provides easy-way to write http client\npackage gorequest\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/http/httputil\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/publicsuffix\"\n\t\"moul.io/http2curl\"\n)\n\ntype Request *http.Request\ntype Response *http.Response\n\n// HTTP methods we support\nconst (\n\tPOST    = \"POST\"\n\tGET     = \"GET\"\n\tHEAD    = \"HEAD\"\n\tPUT     = \"PUT\"\n\tDELETE  = \"DELETE\"\n\tPATCH   = \"PATCH\"\n\tOPTIONS = \"OPTIONS\"\n)\n\n// Types we support.\nconst (\n\tTypeJSON       = \"json\"\n\tTypeXML        = \"xml\"\n\tTypeUrlencoded = \"urlencoded\"\n\tTypeForm       = \"form\"\n\tTypeFormData   = \"form-data\"\n\tTypeHTML       = \"html\"\n\tTypeText       = \"text\"\n\tTypeMultipart  = \"multipart\"\n)\n\ntype superAgentRetryable struct {\n\tRetryableStatus []int\n\tRetryerTime     time.Duration\n\tRetryerCount    int\n\tAttempt         int\n\tEnable          bool\n}\n\n// A SuperAgent is a object storing all request data for client.\ntype SuperAgent struct {\n\tUrl                  string\n\tMethod               string\n\tHeader               http.Header\n\tTargetType           string\n\tForceType            string\n\tData                 map[string]interface{}\n\tSliceData            []interface{}\n\tFormData             url.Values\n\tQueryData            url.Values\n\tFileData             []File\n\tBounceToRawString    bool\n\tRawString            string\n\tClient               *http.Client\n\tTransport            *http.Transport\n\tCookies              []*http.Cookie\n\tErrors               []error\n\tBasicAuth            struct{ Username, Password string }\n\tDebug                bool\n\tCurlCommand          bool\n\tlogger               Logger\n\tRetryable            superAgentRetryable\n\tDoNotClearSuperAgent bool\n\tisClone              bool\n\tcontext\t\t\t\t context.Context\n}\n\nvar DisableTransportSwap = false\n\n// Used to create a new SuperAgent object.\nfunc New() *SuperAgent {\n\tcookiejarOptions := cookiejar.Options{\n\t\tPublicSuffixList: publicsuffix.List,\n\t}\n\tjar, _ := cookiejar.New(&cookiejarOptions)\n\n\tdebug := os.Getenv(\"GOREQUEST_DEBUG\") == \"1\"\n\n\ts := &SuperAgent{\n\t\tTargetType:        TypeJSON,\n\t\tData:              make(map[string]interface{}),\n\t\tHeader:            http.Header{},\n\t\tRawString:         \"\",\n\t\tSliceData:         []interface{}{},\n\t\tFormData:          url.Values{},\n\t\tQueryData:         url.Values{},\n\t\tFileData:          make([]File, 0),\n\t\tBounceToRawString: false,\n\t\tClient:            &http.Client{Jar: jar},\n\t\tTransport:         &http.Transport{},\n\t\tCookies:           make([]*http.Cookie, 0),\n\t\tErrors:            nil,\n\t\tBasicAuth:         struct{ Username, Password string }{},\n\t\tDebug:             debug,\n\t\tCurlCommand:       false,\n\t\tlogger:            log.New(os.Stderr, \"[gorequest]\", log.LstdFlags),\n\t\tisClone:           false,\n\t\tcontext:           nil,\n\t}\n\t// disable keep alives by default, see this issue https://github.com/parnurzeal/gorequest/issues/75\n\ts.Transport.DisableKeepAlives = true\n\treturn s\n}\n\nfunc cloneMapArray(old map[string][]string) map[string][]string {\n\tnewMap := make(map[string][]string, len(old))\n\tfor k, vals := range old {\n\t\tnewMap[k] = make([]string, len(vals))\n\t\tfor i := range vals {\n\t\t\tnewMap[k][i] = vals[i]\n\t\t}\n\t}\n\treturn newMap\n}\nfunc shallowCopyData(old map[string]interface{}) map[string]interface{} {\n\tif old == nil {\n\t\treturn nil\n\t}\n\tnewData := make(map[string]interface{})\n\tfor k, val := range old {\n\t\tnewData[k] = val\n\t}\n\treturn newData\n}\nfunc shallowCopyDataSlice(old []interface{}) []interface{} {\n\tif old == nil {\n\t\treturn nil\n\t}\n\tnewData := make([]interface{}, len(old))\n\tfor i := range old {\n\t\tnewData[i] = old[i]\n\t}\n\treturn newData\n}\nfunc shallowCopyFileArray(old []File) []File {\n\tif old == nil {\n\t\treturn nil\n\t}\n\tnewData := make([]File, len(old))\n\tfor i := range old {\n\t\tnewData[i] = old[i]\n\t}\n\treturn newData\n}\nfunc shallowCopyCookies(old []*http.Cookie) []*http.Cookie {\n\tif old == nil {\n\t\treturn nil\n\t}\n\tnewData := make([]*http.Cookie, len(old))\n\tfor i := range old {\n\t\tnewData[i] = old[i]\n\t}\n\treturn newData\n}\nfunc shallowCopyErrors(old []error) []error {\n\tif old == nil {\n\t\treturn nil\n\t}\n\tnewData := make([]error, len(old))\n\tfor i := range old {\n\t\tnewData[i] = old[i]\n\t}\n\treturn newData\n}\n\n// just need to change the array pointer?\nfunc copyRetryable(old superAgentRetryable) superAgentRetryable {\n\tnewRetryable := old\n\tnewRetryable.RetryableStatus = make([]int, len(old.RetryableStatus))\n\tfor i := range old.RetryableStatus {\n\t\tnewRetryable.RetryableStatus[i] = old.RetryableStatus[i]\n\t}\n\treturn newRetryable\n}\n\n// Returns a copy of this superagent. Useful if you want to reuse the client/settings\n// concurrently.\n// Note: This does a shallow copy of the parent. So you will need to be\n// careful of Data provided\n// Note: It also directly re-uses the client and transport. If you modify the Timeout,\n// or RedirectPolicy on a clone, the clone will have a new http.client. It is recommended\n// that the base request set your timeout and redirect polices, and no modification of\n// the client or transport happen after cloning.\n// Note: DoNotClearSuperAgent is forced to \"true\" after Clone\nfunc (s *SuperAgent) Clone() *SuperAgent {\n\tclone := &SuperAgent{\n\t\tUrl:                  s.Url,\n\t\tMethod:               s.Method,\n\t\tHeader:               http.Header(cloneMapArray(s.Header)),\n\t\tTargetType:           s.TargetType,\n\t\tForceType:            s.ForceType,\n\t\tData:                 shallowCopyData(s.Data),\n\t\tSliceData:            shallowCopyDataSlice(s.SliceData),\n\t\tFormData:             url.Values(cloneMapArray(s.FormData)),\n\t\tQueryData:            url.Values(cloneMapArray(s.QueryData)),\n\t\tFileData:             shallowCopyFileArray(s.FileData),\n\t\tBounceToRawString:    s.BounceToRawString,\n\t\tRawString:            s.RawString,\n\t\tClient:               s.Client,\n\t\tTransport:            s.Transport,\n\t\tCookies:              shallowCopyCookies(s.Cookies),\n\t\tErrors:               shallowCopyErrors(s.Errors),\n\t\tBasicAuth:            s.BasicAuth,\n\t\tDebug:                s.Debug,\n\t\tCurlCommand:          s.CurlCommand,\n\t\tlogger:               s.logger, // thread safe.. anyway\n\t\tRetryable:            copyRetryable(s.Retryable),\n\t\tDoNotClearSuperAgent: true,\n\t\tisClone:              true,\n\t\tcontext: \t\t\t  s.context,\n\t}\n\treturn clone\n}\n\n// Enable the debug mode which logs request/response detail\nfunc (s *SuperAgent) SetDebug(enable bool) *SuperAgent {\n\ts.Debug = enable\n\treturn s\n}\n\n// Enable the curlcommand mode which display a CURL command line\nfunc (s *SuperAgent) SetCurlCommand(enable bool) *SuperAgent {\n\ts.CurlCommand = enable\n\treturn s\n}\n\n// Enable the DoNotClear mode for not clearing super agent and reuse for the next request\nfunc (s *SuperAgent) SetDoNotClearSuperAgent(enable bool) *SuperAgent {\n\ts.DoNotClearSuperAgent = enable\n\treturn s\n}\n\nfunc (s *SuperAgent) SetLogger(logger Logger) *SuperAgent {\n\ts.logger = logger\n\treturn s\n}\n\n// Clear SuperAgent data for another new request.\nfunc (s *SuperAgent) ClearSuperAgent() {\n\tif s.DoNotClearSuperAgent {\n\t\treturn\n\t}\n\ts.Url = \"\"\n\ts.Method = \"\"\n\ts.Header = http.Header{}\n\ts.Data = make(map[string]interface{})\n\ts.SliceData = []interface{}{}\n\ts.FormData = url.Values{}\n\ts.QueryData = url.Values{}\n\ts.FileData = make([]File, 0)\n\ts.BounceToRawString = false\n\ts.RawString = \"\"\n\ts.ForceType = \"\"\n\ts.TargetType = TypeJSON\n\ts.Cookies = make([]*http.Cookie, 0)\n\ts.Errors = nil\n\ts.context = nil\n}\n\n// Just a wrapper to initialize SuperAgent instance by method string\nfunc (s *SuperAgent) CustomMethod(method, targetUrl string) *SuperAgent {\n\tswitch method {\n\tcase POST:\n\t\treturn s.Post(targetUrl)\n\tcase GET:\n\t\treturn s.Get(targetUrl)\n\tcase HEAD:\n\t\treturn s.Head(targetUrl)\n\tcase PUT:\n\t\treturn s.Put(targetUrl)\n\tcase DELETE:\n\t\treturn s.Delete(targetUrl)\n\tcase PATCH:\n\t\treturn s.Patch(targetUrl)\n\tcase OPTIONS:\n\t\treturn s.Options(targetUrl)\n\tdefault:\n\t\ts.ClearSuperAgent()\n\t\ts.Method = method\n\t\ts.Url = targetUrl\n\t\ts.Errors = nil\n\t\treturn s\n\t}\n}\n\nfunc (s *SuperAgent) Get(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = GET\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\nfunc (s *SuperAgent) Post(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = POST\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\nfunc (s *SuperAgent) Head(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = HEAD\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\nfunc (s *SuperAgent) Put(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = PUT\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\nfunc (s *SuperAgent) Delete(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = DELETE\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\nfunc (s *SuperAgent) Patch(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = PATCH\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\nfunc (s *SuperAgent) Options(targetUrl string) *SuperAgent {\n\ts.ClearSuperAgent()\n\ts.Method = OPTIONS\n\ts.Url = targetUrl\n\ts.Errors = nil\n\treturn s\n}\n\n// Set is used for setting header fields,\n// this will overwrite the existed values of Header through AppendHeader().\n// Example. To set `Accept` as `application/json`\n//\n//    gorequest.New().\n//      Post(\"/gamelist\").\n//      Set(\"Accept\", \"application/json\").\n//      End()\nfunc (s *SuperAgent) Set(param string, value string) *SuperAgent {\n\ts.Header.Set(param, value)\n\treturn s\n}\n\n// AppendHeader is used for setting header fileds with multiple values,\n// Example. To set `Accept` as `application/json, text/plain`\n//\n//    gorequest.New().\n//      Post(\"/gamelist\").\n//      AppendHeader(\"Accept\", \"application/json\").\n//      AppendHeader(\"Accept\", \"text/plain\").\n//      End()\nfunc (s *SuperAgent) AppendHeader(param string, value string) *SuperAgent {\n\ts.Header.Add(param, value)\n\treturn s\n}\n\n// Retryable is used for setting a Retryer policy\n// Example. To set Retryer policy with 5 seconds between each attempt.\n//          3 max attempt.\n//          And StatusBadRequest and StatusInternalServerError as RetryableStatus\n\n//    gorequest.New().\n//      Post(\"/gamelist\").\n//      Retry(3, 5 * time.Second, http.StatusBadRequest, http.StatusInternalServerError).\n//      End()\nfunc (s *SuperAgent) Retry(retryerCount int, retryerTime time.Duration, statusCode ...int) *SuperAgent {\n\tfor _, code := range statusCode {\n\t\tstatusText := http.StatusText(code)\n\t\tif len(statusText) == 0 {\n\t\t\ts.Errors = append(s.Errors, errors.New(\"StatusCode '\"+strconv.Itoa(code)+\"' doesn't exist in http package\"))\n\t\t}\n\t}\n\n\ts.Retryable = struct {\n\t\tRetryableStatus []int\n\t\tRetryerTime     time.Duration\n\t\tRetryerCount    int\n\t\tAttempt         int\n\t\tEnable          bool\n\t}{\n\t\tstatusCode,\n\t\tretryerTime,\n\t\tretryerCount,\n\t\t0,\n\t\ttrue,\n\t}\n\treturn s\n}\n\n// SetBasicAuth sets the basic authentication header\n// Example. To set the header for username \"myuser\" and password \"mypass\"\n//\n//    gorequest.New()\n//      Post(\"/gamelist\").\n//      SetBasicAuth(\"myuser\", \"mypass\").\n//      End()\nfunc (s *SuperAgent) SetBasicAuth(username string, password string) *SuperAgent {\n\ts.BasicAuth = struct{ Username, Password string }{username, password}\n\treturn s\n}\n\n// AddCookie adds a cookie to the request. The behavior is the same as AddCookie on Request from net/http\nfunc (s *SuperAgent) AddCookie(c *http.Cookie) *SuperAgent {\n\ts.Cookies = append(s.Cookies, c)\n\treturn s\n}\n\n// AddCookies is a convenient method to add multiple cookies\nfunc (s *SuperAgent) AddCookies(cookies []*http.Cookie) *SuperAgent {\n\ts.Cookies = append(s.Cookies, cookies...)\n\treturn s\n}\n\nvar Types = map[string]string{\n\tTypeJSON:       \"application/json\",\n\tTypeXML:        \"application/xml\",\n\tTypeForm:       \"application/x-www-form-urlencoded\",\n\tTypeFormData:   \"application/x-www-form-urlencoded\",\n\tTypeUrlencoded: \"application/x-www-form-urlencoded\",\n\tTypeHTML:       \"text/html\",\n\tTypeText:       \"text/plain\",\n\tTypeMultipart:  \"multipart/form-data\",\n}\n\n// Type is a convenience function to specify the data type to send.\n// For example, to send data as `application/x-www-form-urlencoded` :\n//\n//    gorequest.New().\n//      Post(\"/recipe\").\n//      Type(\"form\").\n//      Send(`{ \"name\": \"egg benedict\", \"category\": \"brunch\" }`).\n//      End()\n//\n// This will POST the body \"name=egg benedict&category=brunch\" to url /recipe\n//\n// GoRequest supports\n//\n//    \"text/html\" uses \"html\"\n//    \"application/json\" uses \"json\"\n//    \"application/xml\" uses \"xml\"\n//    \"text/plain\" uses \"text\"\n//    \"application/x-www-form-urlencoded\" uses \"urlencoded\", \"form\" or \"form-data\"\n//\nfunc (s *SuperAgent) Type(typeStr string) *SuperAgent {\n\tif _, ok := Types[typeStr]; ok {\n\t\ts.ForceType = typeStr\n\t} else {\n\t\ts.Errors = append(s.Errors, errors.New(\"Type func: incorrect type \\\"\"+typeStr+\"\\\"\"))\n\t}\n\treturn s\n}\n\n// Query function accepts either json string or strings which will form a query-string in url of GET method or body of POST method.\n// For example, making \"/search?query=bicycle&size=50x50&weight=20kg\" using GET method:\n//\n//      gorequest.New().\n//        Get(\"/search\").\n//        Query(`{ query: 'bicycle' }`).\n//        Query(`{ size: '50x50' }`).\n//        Query(`{ weight: '20kg' }`).\n//        End()\n//\n// Or you can put multiple json values:\n//\n//      gorequest.New().\n//        Get(\"/search\").\n//        Query(`{ query: 'bicycle', size: '50x50', weight: '20kg' }`).\n//        End()\n//\n// Strings are also acceptable:\n//\n//      gorequest.New().\n//        Get(\"/search\").\n//        Query(\"query=bicycle&size=50x50\").\n//        Query(\"weight=20kg\").\n//        End()\n//\n// Or even Mixed! :)\n//\n//      gorequest.New().\n//        Get(\"/search\").\n//        Query(\"query=bicycle\").\n//        Query(`{ size: '50x50', weight:'20kg' }`).\n//        End()\n//\nfunc (s *SuperAgent) Query(content interface{}) *SuperAgent {\n\tswitch v := reflect.ValueOf(content); v.Kind() {\n\tcase reflect.String:\n\t\ts.queryString(v.String())\n\tcase reflect.Struct:\n\t\ts.queryStruct(v.Interface())\n\tcase reflect.Map:\n\t\ts.queryMap(v.Interface())\n\tdefault:\n\t}\n\treturn s\n}\n\nfunc (s *SuperAgent) queryStruct(content interface{}) *SuperAgent {\n\tif marshalContent, err := json.Marshal(content); err != nil {\n\t\ts.Errors = append(s.Errors, err)\n\t} else {\n\t\tvar val map[string]interface{}\n\t\tif err := json.Unmarshal(marshalContent, &val); err != nil {\n\t\t\ts.Errors = append(s.Errors, err)\n\t\t} else {\n\t\t\tfor k, v := range val {\n\t\t\t\tvar queryVal string\n\t\t\t\tswitch t := v.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\tqueryVal = t\n\t\t\t\tcase float64:\n\t\t\t\t\tqueryVal = strconv.FormatFloat(t, 'f', -1, 64)\n\t\t\t\tcase time.Time:\n\t\t\t\t\tqueryVal = t.Format(time.RFC3339)\n\t\t\t\tdefault:\n\t\t\t\t\tj, err := json.Marshal(v)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tqueryVal = string(j)\n\t\t\t\t}\n\t\t\t\ts.QueryData.Add(k, queryVal)\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\nfunc (s *SuperAgent) queryString(content string) *SuperAgent {\n\tvar val map[string]string\n\tif err := json.Unmarshal([]byte(content), &val); err == nil {\n\t\tfor k, v := range val {\n\t\t\ts.QueryData.Add(k, v)\n\t\t}\n\t} else {\n\t\tif queryData, err := url.ParseQuery(content); err == nil {\n\t\t\tfor k, queryValues := range queryData {\n\t\t\t\tfor _, queryValue := range queryValues {\n\t\t\t\t\ts.QueryData.Add(k, string(queryValue))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.Errors = append(s.Errors, err)\n\t\t}\n\t\t// TODO: need to check correct format of 'field=val&field=val&...'\n\t}\n\treturn s\n}\n\nfunc (s *SuperAgent) queryMap(content interface{}) *SuperAgent {\n\treturn s.queryStruct(content)\n}\n\n// As Go conventions accepts ; as a synonym for &. (https://github.com/golang/go/issues/2210)\n// Thus, Query won't accept ; in a querystring if we provide something like fields=f1;f2;f3\n// This Param is then created as an alternative method to solve this.\nfunc (s *SuperAgent) Param(key string, value string) *SuperAgent {\n\ts.QueryData.Add(key, value)\n\treturn s\n}\n\n// Set TLSClientConfig for underling Transport.\n// One example is you can use it to disable security check (https):\n//\n//      gorequest.New().TLSClientConfig(&tls.Config{ InsecureSkipVerify: true}).\n//        Get(\"https://disable-security-check.com\").\n//        End()\n//\nfunc (s *SuperAgent) TLSClientConfig(config *tls.Config) *SuperAgent {\n\ts.safeModifyTransport()\n\ts.Transport.TLSClientConfig = config\n\treturn s\n}\n\n// Proxy function accepts a proxy url string to setup proxy url for any request.\n// It provides a convenience way to setup proxy which have advantages over usual old ways.\n// One example is you might try to set `http_proxy` environment. This means you are setting proxy up for all the requests.\n// You will not be able to send different request with different proxy unless you change your `http_proxy` environment again.\n// Another example is using Golang proxy setting. This is normal prefer way to do but too verbase compared to GoRequest's Proxy:\n//\n//      gorequest.New().Proxy(\"http://myproxy:9999\").\n//        Post(\"http://www.google.com\").\n//        End()\n//\n// To set no_proxy, just put empty string to Proxy func:\n//\n//      gorequest.New().Proxy(\"\").\n//        Post(\"http://www.google.com\").\n//        End()\n//\nfunc (s *SuperAgent) Proxy(proxyUrl string) *SuperAgent {\n\tparsedProxyUrl, err := url.Parse(proxyUrl)\n\tif err != nil {\n\t\ts.Errors = append(s.Errors, err)\n\t} else if proxyUrl == \"\" {\n\t\ts.safeModifyTransport()\n\t\ts.Transport.Proxy = nil\n\t} else {\n\t\ts.safeModifyTransport()\n\t\ts.Transport.Proxy = http.ProxyURL(parsedProxyUrl)\n\t}\n\treturn s\n}\n\n// RedirectPolicy accepts a function to define how to handle redirects. If the\n// policy function returns an error, the next Request is not made and the previous\n// request is returned.\n//\n// The policy function's arguments are the Request about to be made and the\n// past requests in order of oldest first.\nfunc (s *SuperAgent) RedirectPolicy(policy func(req Request, via []Request) error) *SuperAgent {\n\ts.safeModifyHttpClient()\n\ts.Client.CheckRedirect = func(r *http.Request, v []*http.Request) error {\n\t\tvv := make([]Request, len(v))\n\t\tfor i, r := range v {\n\t\t\tvv[i] = Request(r)\n\t\t}\n\t\treturn policy(Request(r), vv)\n\t}\n\treturn s\n}\n\n// Send function accepts either json string or query strings which is usually used to assign data to POST or PUT method.\n// Without specifying any type, if you give Send with json data, you are doing requesting in json format:\n//\n//      gorequest.New().\n//        Post(\"/search\").\n//        Send(`{ query: 'sushi' }`).\n//        End()\n//\n// While if you use at least one of querystring, GoRequest understands and automatically set the Content-Type to `application/x-www-form-urlencoded`\n//\n//      gorequest.New().\n//        Post(\"/search\").\n//        Send(\"query=tonkatsu\").\n//        End()\n//\n// So, if you want to strictly send json format, you need to use Type func to set it as `json` (Please see more details in Type function).\n// You can also do multiple chain of Send:\n//\n//      gorequest.New().\n//        Post(\"/search\").\n//        Send(\"query=bicycle&size=50x50\").\n//        Send(`{ wheel: '4'}`).\n//        End()\n//\n// From v0.2.0, Send function provide another convenience way to work with Struct type. You can mix and match it with json and query string:\n//\n//      type BrowserVersionSupport struct {\n//        Chrome string\n//        Firefox string\n//      }\n//      ver := BrowserVersionSupport{ Chrome: \"37.0.2041.6\", Firefox: \"30.0\" }\n//      gorequest.New().\n//        Post(\"/update_version\").\n//        Send(ver).\n//        Send(`{\"Safari\":\"5.1.10\"}`).\n//        End()\n//\n// If you have set Type to text or Content-Type to text/plain, content will be sent as raw string in body instead of form\n//\n//      gorequest.New().\n//        Post(\"/greet\").\n//        Type(\"text\").\n//        Send(\"hello world\").\n//        End()\n//\nfunc (s *SuperAgent) Send(content interface{}) *SuperAgent {\n\t// TODO: add normal text mode or other mode to Send func\n\tswitch v := reflect.ValueOf(content); v.Kind() {\n\tcase reflect.String:\n\t\ts.SendString(v.String())\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: // includes rune\n\t\ts.SendString(strconv.FormatInt(v.Int(), 10))\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64: // includes byte\n\t\ts.SendString(strconv.FormatUint(v.Uint(), 10))\n\tcase reflect.Float64:\n\t\ts.SendString(strconv.FormatFloat(v.Float(), 'f', -1, 64))\n\tcase reflect.Float32:\n\t\ts.SendString(strconv.FormatFloat(v.Float(), 'f', -1, 32))\n\tcase reflect.Bool:\n\t\ts.SendString(strconv.FormatBool(v.Bool()))\n\tcase reflect.Struct:\n\t\ts.SendStruct(v.Interface())\n\tcase reflect.Slice:\n\t\ts.SendSlice(makeSliceOfReflectValue(v))\n\tcase reflect.Array:\n\t\ts.SendSlice(makeSliceOfReflectValue(v))\n\tcase reflect.Ptr:\n\t\ts.Send(v.Elem().Interface())\n\tcase reflect.Map:\n\t\ts.SendMap(v.Interface())\n\tdefault:\n\t\t// TODO: leave default for handling other types in the future, such as complex numbers, (nested) maps, etc\n\t\treturn s\n\t}\n\treturn s\n}\n\nfunc makeSliceOfReflectValue(v reflect.Value) (slice []interface{}) {\n\n\tkind := v.Kind()\n\tif kind != reflect.Slice && kind != reflect.Array {\n\t\treturn slice\n\t}\n\n\tslice = make([]interface{}, v.Len())\n\tfor i := 0; i < v.Len(); i++ {\n\t\tslice[i] = v.Index(i).Interface()\n\t}\n\n\treturn slice\n}\n\n// SendSlice (similar to SendString) returns SuperAgent's itself for any next chain and takes content []interface{} as a parameter.\n// Its duty is to append slice of interface{} into s.SliceData ([]interface{}) which later changes into json array in the End() func.\nfunc (s *SuperAgent) SendSlice(content []interface{}) *SuperAgent {\n\ts.SliceData = append(s.SliceData, content...)\n\treturn s\n}\n\nfunc (s *SuperAgent) SendMap(content interface{}) *SuperAgent {\n\treturn s.SendStruct(content)\n}\n\n// SendStruct (similar to SendString) returns SuperAgent's itself for any next chain and takes content interface{} as a parameter.\n// Its duty is to transfrom interface{} (implicitly always a struct) into s.Data (map[string]interface{}) which later changes into appropriate format such as json, form, text, etc. in the End() func.\nfunc (s *SuperAgent) SendStruct(content interface{}) *SuperAgent {\n\tif marshalContent, err := json.Marshal(content); err != nil {\n\t\ts.Errors = append(s.Errors, err)\n\t} else {\n\t\tvar val map[string]interface{}\n\t\td := json.NewDecoder(bytes.NewBuffer(marshalContent))\n\t\td.UseNumber()\n\t\tif err := d.Decode(&val); err != nil {\n\t\t\ts.Errors = append(s.Errors, err)\n\t\t} else {\n\t\t\tfor k, v := range val {\n\t\t\t\ts.Data[k] = v\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\n// SendString returns SuperAgent's itself for any next chain and takes content string as a parameter.\n// Its duty is to transform String into s.Data (map[string]interface{}) which later changes into appropriate format such as json, form, text, etc. in the End func.\n// Send implicitly uses SendString and you should use Send instead of this.\nfunc (s *SuperAgent) SendString(content string) *SuperAgent {\n\tif !s.BounceToRawString {\n\t\tvar val interface{}\n\t\td := json.NewDecoder(strings.NewReader(content))\n\t\td.UseNumber()\n\t\tif err := d.Decode(&val); err == nil {\n\t\t\tswitch v := reflect.ValueOf(val); v.Kind() {\n\t\t\tcase reflect.Map:\n\t\t\t\tfor k, v := range val.(map[string]interface{}) {\n\t\t\t\t\ts.Data[k] = v\n\t\t\t\t}\n\t\t\t// add to SliceData\n\t\t\tcase reflect.Slice:\n\t\t\t\ts.SendSlice(val.([]interface{}))\n\t\t\t// bounce to rawstring if it is arrayjson, or others\n\t\t\tdefault:\n\t\t\t\ts.BounceToRawString = true\n\t\t\t}\n\t\t} else if formData, err := url.ParseQuery(content); err == nil {\n\t\t\tfor k, formValues := range formData {\n\t\t\t\tfor _, formValue := range formValues {\n\t\t\t\t\t// make it array if already have key\n\t\t\t\t\tif val, ok := s.Data[k]; ok {\n\t\t\t\t\t\tvar strArray []string\n\t\t\t\t\t\tstrArray = append(strArray, string(formValue))\n\t\t\t\t\t\t// check if previous data is one string or array\n\t\t\t\t\t\tswitch oldValue := val.(type) {\n\t\t\t\t\t\tcase []string:\n\t\t\t\t\t\t\tstrArray = append(strArray, oldValue...)\n\t\t\t\t\t\tcase string:\n\t\t\t\t\t\t\tstrArray = append(strArray, oldValue)\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.Data[k] = strArray\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// make it just string if does not already have same key\n\t\t\t\t\t\ts.Data[k] = formValue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.TargetType = TypeForm\n\t\t} else {\n\t\t\ts.BounceToRawString = true\n\t\t}\n\t}\n\t// Dump all contents to RawString in case in the end user doesn't want json or form.\n\ts.RawString += content\n\treturn s\n}\n\ntype File struct {\n\tFilename  string\n\tFieldname string\n\tData      []byte\n}\n\n// SendFile function works only with type \"multipart\". The function accepts one mandatory and up to two optional arguments. The mandatory (first) argument is the file.\n// The function accepts a path to a file as string:\n//\n//      gorequest.New().\n//        Post(\"http://example.com\").\n//        Type(\"multipart\").\n//        SendFile(\"./example_file.ext\").\n//        End()\n//\n// File can also be a []byte slice of a already file read by eg. ioutil.ReadFile:\n//\n//      b, _ := ioutil.ReadFile(\"./example_file.ext\")\n//      gorequest.New().\n//        Post(\"http://example.com\").\n//        Type(\"multipart\").\n//        SendFile(b).\n//        End()\n//\n// Furthermore file can also be a os.File:\n//\n//      f, _ := os.Open(\"./example_file.ext\")\n//      gorequest.New().\n//        Post(\"http://example.com\").\n//        Type(\"multipart\").\n//        SendFile(f).\n//        End()\n//\n// The first optional argument (second argument overall) is the filename, which will be automatically determined when file is a string (path) or a os.File.\n// When file is a []byte slice, filename defaults to \"filename\". In all cases the automatically determined filename can be overwritten:\n//\n//      b, _ := ioutil.ReadFile(\"./example_file.ext\")\n//      gorequest.New().\n//        Post(\"http://example.com\").\n//        Type(\"multipart\").\n//        SendFile(b, \"my_custom_filename\").\n//        End()\n//\n// The second optional argument (third argument overall) is the fieldname in the multipart/form-data request. It defaults to fileNUMBER (eg. file1), where number is ascending and starts counting at 1.\n// So if you send multiple files, the fieldnames will be file1, file2, ... unless it is overwritten. If fieldname is set to \"file\" it will be automatically set to fileNUMBER, where number is the greatest exsiting number+1 unless\n// a third argument skipFileNumbering is provided and true.\n//\n//      b, _ := ioutil.ReadFile(\"./example_file.ext\")\n//      gorequest.New().\n//        Post(\"http://example.com\").\n//        Type(\"multipart\").\n//        SendFile(b, \"\", \"my_custom_fieldname\"). // filename left blank, will become \"example_file.ext\"\n//        End()\n//\nfunc (s *SuperAgent) SendFile(file interface{}, args ...interface{}) *SuperAgent {\n\n\tfilename := \"\"\n\tfieldname := \"file\"\n\tskipFileNumbering := false\n\n\tif len(args) >= 1 {\n\t\targFilename := fmt.Sprintf(\"%v\", args[0])\n\t\tif len(argFilename) > 0 {\n\t\t\tfilename = strings.TrimSpace(argFilename)\n\t\t}\n\t}\n\n\tif len(args) >= 2 {\n\t\targFieldname := fmt.Sprintf(\"%v\", args[1])\n\t\tif len(argFieldname) > 0 {\n\t\t\tfieldname = strings.TrimSpace(argFieldname)\n\t\t}\n\t}\n\n\tif len(args) >= 3 {\n\t\targSkipFileNumbering := reflect.ValueOf(args[2])\n\t\tif argSkipFileNumbering.Type().Name() == \"bool\" {\n\t\t\tskipFileNumbering = argSkipFileNumbering.Interface().(bool)\n\t\t}\n\t}\n\n\tif (fieldname == \"file\" && !skipFileNumbering) || fieldname == \"\" {\n\t\tfieldname = \"file\" + strconv.Itoa(len(s.FileData)+1)\n\t}\n\n\tswitch v := reflect.ValueOf(file); v.Kind() {\n\tcase reflect.String:\n\t\tpathToFile, err := filepath.Abs(v.String())\n\t\tif err != nil {\n\t\t\ts.Errors = append(s.Errors, err)\n\t\t\treturn s\n\t\t}\n\t\tif filename == \"\" {\n\t\t\tfilename = filepath.Base(pathToFile)\n\t\t}\n\t\tdata, err := ioutil.ReadFile(v.String())\n\t\tif err != nil {\n\t\t\ts.Errors = append(s.Errors, err)\n\t\t\treturn s\n\t\t}\n\t\ts.FileData = append(s.FileData, File{\n\t\t\tFilename:  filename,\n\t\t\tFieldname: fieldname,\n\t\t\tData:      data,\n\t\t})\n\tcase reflect.Slice:\n\t\tslice := makeSliceOfReflectValue(v)\n\t\tif filename == \"\" {\n\t\t\tfilename = \"filename\"\n\t\t}\n\t\tf := File{\n\t\t\tFilename:  filename,\n\t\t\tFieldname: fieldname,\n\t\t\tData:      make([]byte, len(slice)),\n\t\t}\n\t\tfor i := range slice {\n\t\t\tf.Data[i] = slice[i].(byte)\n\t\t}\n\t\ts.FileData = append(s.FileData, f)\n\tcase reflect.Ptr:\n\t\tif len(args) == 1 {\n\t\t\treturn s.SendFile(v.Elem().Interface(), args[0])\n\t\t}\n\t\tif len(args) == 2 {\n\t\t\treturn s.SendFile(v.Elem().Interface(), args[0], args[1])\n\t\t}\n\t\tif len(args) == 3 {\n\t\t\treturn s.SendFile(v.Elem().Interface(), args[0], args[1], args[2])\n\t\t}\n\t\treturn s.SendFile(v.Elem().Interface())\n\tdefault:\n\t\tif v.Type() == reflect.TypeOf(os.File{}) {\n\t\t\tosfile := v.Interface().(os.File)\n\t\t\tif filename == \"\" {\n\t\t\t\tfilename = filepath.Base(osfile.Name())\n\t\t\t}\n\t\t\tdata, err := ioutil.ReadFile(osfile.Name())\n\t\t\tif err != nil {\n\t\t\t\ts.Errors = append(s.Errors, err)\n\t\t\t\treturn s\n\t\t\t}\n\t\t\ts.FileData = append(s.FileData, File{\n\t\t\t\tFilename:  filename,\n\t\t\t\tFieldname: fieldname,\n\t\t\t\tData:      data,\n\t\t\t})\n\t\t\treturn s\n\t\t}\n\n\t\ts.Errors = append(s.Errors, errors.New(\"SendFile currently only supports either a string (path/to/file), a slice of bytes (file content itself), or a os.File!\"))\n\t}\n\n\treturn s\n}\n\nfunc changeMapToURLValues(data map[string]interface{}) url.Values {\n\tvar newUrlValues = url.Values{}\n\tfor k, v := range data {\n\t\tswitch val := v.(type) {\n\t\tcase string:\n\t\t\tnewUrlValues.Add(k, val)\n\t\tcase bool:\n\t\t\tnewUrlValues.Add(k, strconv.FormatBool(val))\n\t\t// if a number, change to string\n\t\t// json.Number used to protect against a wrong (for GoRequest) default conversion\n\t\t// which always converts number to float64.\n\t\t// This type is caused by using Decoder.UseNumber()\n\t\tcase json.Number:\n\t\t\tnewUrlValues.Add(k, string(val))\n\t\tcase int:\n\t\t\tnewUrlValues.Add(k, strconv.FormatInt(int64(val), 10))\n\t\t// TODO add all other int-Types (int8, int16, ...)\n\t\tcase float64:\n\t\t\tnewUrlValues.Add(k, strconv.FormatFloat(float64(val), 'f', -1, 64))\n\t\tcase float32:\n\t\t\tnewUrlValues.Add(k, strconv.FormatFloat(float64(val), 'f', -1, 64))\n\t\t// following slices are mostly needed for tests\n\t\tcase []string:\n\t\t\tfor _, element := range val {\n\t\t\t\tnewUrlValues.Add(k, element)\n\t\t\t}\n\t\tcase []int:\n\t\t\tfor _, element := range val {\n\t\t\t\tnewUrlValues.Add(k, strconv.FormatInt(int64(element), 10))\n\t\t\t}\n\t\tcase []bool:\n\t\t\tfor _, element := range val {\n\t\t\t\tnewUrlValues.Add(k, strconv.FormatBool(element))\n\t\t\t}\n\t\tcase []float64:\n\t\t\tfor _, element := range val {\n\t\t\t\tnewUrlValues.Add(k, strconv.FormatFloat(float64(element), 'f', -1, 64))\n\t\t\t}\n\t\tcase []float32:\n\t\t\tfor _, element := range val {\n\t\t\t\tnewUrlValues.Add(k, strconv.FormatFloat(float64(element), 'f', -1, 64))\n\t\t\t}\n\t\t// these slices are used in practice like sending a struct\n\t\tcase []interface{}:\n\n\t\t\tif len(val) <= 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch val[0].(type) {\n\t\t\tcase string:\n\t\t\t\tfor _, element := range val {\n\t\t\t\t\tnewUrlValues.Add(k, element.(string))\n\t\t\t\t}\n\t\t\tcase bool:\n\t\t\t\tfor _, element := range val {\n\t\t\t\t\tnewUrlValues.Add(k, strconv.FormatBool(element.(bool)))\n\t\t\t\t}\n\t\t\tcase json.Number:\n\t\t\t\tfor _, element := range val {\n\t\t\t\t\tnewUrlValues.Add(k, string(element.(json.Number)))\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\t// TODO add ptr, arrays, ...\n\t\t}\n\t}\n\treturn newUrlValues\n}\n\n// End is the most important function that you need to call when ending the chain. The request won't proceed without calling it.\n// End function returns Response which matchs the structure of Response type in Golang's http package (but without Body data). The body data itself returns as a string in a 2nd return value.\n// Lastly but worth noticing, error array (NOTE: not just single error value) is returned as a 3rd value and nil otherwise.\n//\n// For example:\n//\n//    resp, body, errs := gorequest.New().Get(\"http://www.google.com\").End()\n//    if errs != nil {\n//      fmt.Println(errs)\n//    }\n//    fmt.Println(resp, body)\n//\n// Moreover, End function also supports callback which you can put as a parameter.\n// This extends the flexibility and makes GoRequest fun and clean! You can use GoRequest in whatever style you love!\n//\n// For example:\n//\n//    func printBody(resp gorequest.Response, body string, errs []error){\n//      fmt.Println(resp.Status)\n//    }\n//    gorequest.New().Get(\"http://www..google.com\").End(printBody)\n//\nfunc (s *SuperAgent) End(callback ...func(response Response, body string, errs []error)) (Response, string, []error) {\n\tvar bytesCallback []func(response Response, body []byte, errs []error)\n\tif len(callback) > 0 {\n\t\tbytesCallback = []func(response Response, body []byte, errs []error){\n\t\t\tfunc(response Response, body []byte, errs []error) {\n\t\t\t\tcallback[0](response, string(body), errs)\n\t\t\t},\n\t\t}\n\t}\n\n\tresp, body, errs := s.EndBytes(bytesCallback...)\n\tbodyString := string(body)\n\n\treturn resp, bodyString, errs\n}\n\n// EndBytes should be used when you want the body as bytes. The callbacks work the same way as with `End`, except that a byte array is used instead of a string.\nfunc (s *SuperAgent) EndBytes(callback ...func(response Response, body []byte, errs []error)) (Response, []byte, []error) {\n\tvar (\n\t\terrs []error\n\t\tresp Response\n\t\tbody []byte\n\t)\n\n\tfor {\n\t\tresp, body, errs = s.getResponseBytes()\n\t\tif errs != nil {\n\t\t\treturn nil, nil, errs\n\t\t}\n\t\tif s.isRetryableRequest(resp) {\n\t\t\tresp.Header.Set(\"Retry-Count\", strconv.Itoa(s.Retryable.Attempt))\n\t\t\tbreak\n\t\t}\n\t}\n\n\trespCallback := *resp\n\tif len(callback) != 0 {\n\t\tcallback[0](&respCallback, body, s.Errors)\n\t}\n\treturn resp, body, nil\n}\n\nfunc (s *SuperAgent) isRetryableRequest(resp Response) bool {\n\tif s.Retryable.Enable && s.Retryable.Attempt < s.Retryable.RetryerCount && contains(resp.StatusCode, s.Retryable.RetryableStatus) {\n\t\ttime.Sleep(s.Retryable.RetryerTime)\n\t\ts.Retryable.Attempt++\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc contains(respStatus int, statuses []int) bool {\n\tfor _, status := range statuses {\n\t\tif status == respStatus {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *SuperAgent) Context(ctx context.Context) *SuperAgent{\n\tif ctx == nil {\n\t\tpanic(\"context can't be nil\")\n\t}\n\ts.context = ctx\n\treturn s\n}\n\n// EndStruct should be used when you want the body as a struct. The callbacks work the same way as with `End`, except that a struct is used instead of a string.\nfunc (s *SuperAgent) EndStruct(v interface{}, callback ...func(response Response, v interface{}, body []byte, errs []error)) (Response, []byte, []error) {\n\tresp, body, errs := s.EndBytes()\n\tif errs != nil {\n\t\treturn nil, body, errs\n\t}\n\terr := json.Unmarshal(body, &v)\n\tif err != nil {\n\t\ts.Errors = append(s.Errors, err)\n\t\treturn resp, body, s.Errors\n\t}\n\trespCallback := *resp\n\tif len(callback) != 0 {\n\t\tcallback[0](&respCallback, v, body, s.Errors)\n\t}\n\treturn resp, body, nil\n}\n\nfunc (s *SuperAgent) getResponseBytes() (Response, []byte, []error) {\n\tvar (\n\t\treq  *http.Request\n\t\terr  error\n\t\tresp Response\n\t)\n\t// check whether there is an error. if yes, return all errors\n\tif len(s.Errors) != 0 {\n\t\treturn nil, nil, s.Errors\n\t}\n\t// check if there is forced type\n\tswitch s.ForceType {\n\tcase TypeJSON, TypeForm, TypeXML, TypeText, TypeMultipart:\n\t\ts.TargetType = s.ForceType\n\t\t// If forcetype is not set, check whether user set Content-Type header.\n\t\t// If yes, also bounce to the correct supported TargetType automatically.\n\tdefault:\n\t\tcontentType := s.Header.Get(\"Content-Type\")\n\t\tfor k, v := range Types {\n\t\t\tif contentType == v {\n\t\t\t\ts.TargetType = k\n\t\t\t}\n\t\t}\n\t}\n\n\t// if slice and map get mixed, let's bounce to rawstring\n\tif len(s.Data) != 0 && len(s.SliceData) != 0 {\n\t\ts.BounceToRawString = true\n\t}\n\n\t// Make Request\n\treq, err = s.MakeRequest()\n\tif err != nil {\n\t\ts.Errors = append(s.Errors, err)\n\t\treturn nil, nil, s.Errors\n\t}\n\n\t// Set Transport\n\tif !DisableTransportSwap {\n\t\ts.Client.Transport = s.Transport\n\t}\n\n\t// Log details of this request\n\tif s.Debug {\n\t\tdump, err := httputil.DumpRequest(req, true)\n\t\ts.logger.SetPrefix(\"[http] \")\n\t\tif err != nil {\n\t\t\ts.logger.Println(\"Error:\", err)\n\t\t} else {\n\t\t\ts.logger.Printf(\"HTTP Request: %s\", string(dump))\n\t\t}\n\t}\n\n\t// Display CURL command line\n\tif s.CurlCommand {\n\t\tcurl, err := http2curl.GetCurlCommand(req)\n\t\ts.logger.SetPrefix(\"[curl] \")\n\t\tif err != nil {\n\t\t\ts.logger.Println(\"Error:\", err)\n\t\t} else {\n\t\t\ts.logger.Printf(\"CURL command line: %s\", curl)\n\t\t}\n\t}\n\n\t// Send request\n\tresp, err = s.Client.Do(req)\n\tif err != nil {\n\t\ts.Errors = append(s.Errors, err)\n\t\treturn nil, nil, s.Errors\n\t}\n\tdefer resp.Body.Close()\n\n\t// Log details of this response\n\tif s.Debug {\n\t\tdump, err := httputil.DumpResponse(resp, true)\n\t\tif nil != err {\n\t\t\ts.logger.Println(\"Error:\", err)\n\t\t} else {\n\t\t\ts.logger.Printf(\"HTTP Response: %s\", string(dump))\n\t\t}\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\t// Reset resp.Body so it can be use again\n\tresp.Body = ioutil.NopCloser(bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn nil, nil, []error{err}\n\t}\n\treturn resp, body, nil\n}\n\nfunc (s *SuperAgent) MakeRequest() (*http.Request, error) {\n\tvar (\n\t\treq           *http.Request\n\t\tcontentType   string // This is only set when the request body content is non-empty.\n\t\tcontentReader io.Reader\n\t\terr           error\n\t)\n\n\tif s.Method == \"\" {\n\t\treturn nil, errors.New(\"No method specified\")\n\t}\n\n\t// !!! Important Note !!!\n\t//\n\t// Throughout this region, contentReader and contentType are only set when\n\t// the contents will be non-empty.\n\t// This is done avoid ever sending a non-nil request body with nil contents\n\t// to http.NewRequest, because it contains logic which dependends on\n\t// whether or not the body is \"nil\".\n\t//\n\t// See PR #136 for more information:\n\t//\n\t//     https://github.com/parnurzeal/gorequest/pull/136\n\t//\n\tswitch s.TargetType {\n\tcase TypeJSON:\n\t\t// If-case to give support to json array. we check if\n\t\t// 1) Map only: send it as json map from s.Data\n\t\t// 2) Array or Mix of map & array or others: send it as rawstring from s.RawString\n\t\tvar contentJson []byte\n\t\tif s.BounceToRawString {\n\t\t\tcontentJson = []byte(s.RawString)\n\t\t} else if len(s.Data) != 0 {\n\t\t\tcontentJson, _ = json.Marshal(s.Data)\n\t\t} else if len(s.SliceData) != 0 {\n\t\t\tcontentJson, _ = json.Marshal(s.SliceData)\n\t\t}\n\t\tif contentJson != nil {\n\t\t\tcontentReader = bytes.NewReader(contentJson)\n\t\t\tcontentType = \"application/json\"\n\t\t}\n\tcase TypeForm, TypeFormData, TypeUrlencoded:\n\t\tvar contentForm []byte\n\t\tif s.BounceToRawString || len(s.SliceData) != 0 {\n\t\t\tcontentForm = []byte(s.RawString)\n\t\t} else {\n\t\t\tformData := changeMapToURLValues(s.Data)\n\t\t\tcontentForm = []byte(formData.Encode())\n\t\t}\n\t\tif len(contentForm) != 0 {\n\t\t\tcontentReader = bytes.NewReader(contentForm)\n\t\t\tcontentType = \"application/x-www-form-urlencoded\"\n\t\t}\n\tcase TypeText:\n\t\tif len(s.RawString) != 0 {\n\t\t\tcontentReader = strings.NewReader(s.RawString)\n\t\t\tcontentType = \"text/plain\"\n\t\t}\n\tcase TypeXML:\n\t\tif len(s.RawString) != 0 {\n\t\t\tcontentReader = strings.NewReader(s.RawString)\n\t\t\tcontentType = \"application/xml\"\n\t\t}\n\tcase TypeMultipart:\n\t\tvar (\n\t\t\tbuf = &bytes.Buffer{}\n\t\t\tmw  = multipart.NewWriter(buf)\n\t\t)\n\n\t\tif s.BounceToRawString {\n\t\t\tfieldName := s.Header.Get(\"data_fieldname\")\n\t\t\tif fieldName == \"\" {\n\t\t\t\tfieldName = \"data\"\n\t\t\t}\n\t\t\tfw, _ := mw.CreateFormField(fieldName)\n\t\t\tfw.Write([]byte(s.RawString))\n\t\t\tcontentReader = buf\n\t\t}\n\n\t\tif len(s.Data) != 0 {\n\t\t\tformData := changeMapToURLValues(s.Data)\n\t\t\tfor key, values := range formData {\n\t\t\t\tfor _, value := range values {\n\t\t\t\t\tfw, _ := mw.CreateFormField(key)\n\t\t\t\t\tfw.Write([]byte(value))\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontentReader = buf\n\t\t}\n\n\t\tif len(s.SliceData) != 0 {\n\t\t\tfieldName := s.Header.Get(\"json_fieldname\")\n\t\t\tif fieldName == \"\" {\n\t\t\t\tfieldName = \"data\"\n\t\t\t}\n\t\t\t// copied from CreateFormField() in mime/multipart/writer.go\n\t\t\th := make(textproto.MIMEHeader)\n\t\t\tfieldName = strings.Replace(strings.Replace(fieldName, \"\\\\\", \"\\\\\\\\\", -1), `\"`, \"\\\\\\\"\", -1)\n\t\t\th.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"`, fieldName))\n\t\t\th.Set(\"Content-Type\", \"application/json\")\n\t\t\tfw, _ := mw.CreatePart(h)\n\t\t\tcontentJson, err := json.Marshal(s.SliceData)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfw.Write(contentJson)\n\t\t\tcontentReader = buf\n\t\t}\n\n\t\t// add the files\n\t\tif len(s.FileData) != 0 {\n\t\t\tfor _, file := range s.FileData {\n\t\t\t\tfw, _ := mw.CreateFormFile(file.Fieldname, file.Filename)\n\t\t\t\tfw.Write(file.Data)\n\t\t\t}\n\t\t\tcontentReader = buf\n\t\t}\n\n\t\t// close before call to FormDataContentType ! otherwise its not valid multipart\n\t\tmw.Close()\n\n\t\tif contentReader != nil {\n\t\t\tcontentType = mw.FormDataContentType()\n\t\t}\n\tdefault:\n\t\t// let's return an error instead of an nil pointer exception here\n\t\treturn nil, errors.New(\"TargetType '\" + s.TargetType + \"' could not be determined\")\n\t}\n\n\tif req, err = http.NewRequest(s.Method, s.Url, contentReader); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif s.context != nil {\n\t\treq = req.WithContext(s.context)\n\t}\n\n\tfor k, vals := range s.Header {\n\t\tfor _, v := range vals {\n\t\t\treq.Header.Add(k, v)\n\t\t}\n\n\t\t// Setting the Host header is a special case, see this issue: https://github.com/golang/go/issues/7682\n\t\tif strings.EqualFold(k, \"Host\") {\n\t\t\treq.Host = vals[0]\n\t\t}\n\t}\n\n\t// https://github.com/parnurzeal/gorequest/issues/164\n\t// Don't infer the content type header if an overrride is already provided.\n\tif len(contentType) != 0 && req.Header.Get(\"Content-Type\") == \"\" {\n\t\treq.Header.Set(\"Content-Type\", contentType)\n\t}\n\n\t// Add all querystring from Query func\n\tq := req.URL.Query()\n\tfor k, v := range s.QueryData {\n\t\tfor _, vv := range v {\n\t\t\tq.Add(k, vv)\n\t\t}\n\t}\n\treq.URL.RawQuery = q.Encode()\n\n\t// Add basic auth\n\tif s.BasicAuth != struct{ Username, Password string }{} {\n\t\treq.SetBasicAuth(s.BasicAuth.Username, s.BasicAuth.Password)\n\t}\n\n\t// Add cookies\n\tfor _, cookie := range s.Cookies {\n\t\treq.AddCookie(cookie)\n\t}\n\n\treturn req, nil\n}\n\n// AsCurlCommand returns a string representing the runnable `curl' command\n// version of the request.\nfunc (s *SuperAgent) AsCurlCommand() (string, error) {\n\treq, err := s.MakeRequest()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcmd, err := http2curl.GetCurlCommand(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn cmd.String(), nil\n}\n"
        },
        {
          "name": "gorequest_client_go1.2.go",
          "type": "blob",
          "size": 0.962890625,
          "content": "// +build go1.2\r\n// +build !go1.3\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net\"\r\n    \"net/http\"\r\n    \"time\"\r\n)\r\n\r\n\r\n// we don't want to mess up other clones when we modify the client..\r\n// so unfortantely we need to create a new client\r\nfunc (s *SuperAgent) safeModifyHttpClient() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldClient := s.Client\r\n    s.Client = &http.Client{}\r\n    s.Client.Jar = oldClient.Jar\r\n    s.Client.Transport = oldClient.Transport\r\n    s.Client.CheckRedirect = oldClient.CheckRedirect\r\n}\r\n\r\n// I'm not sure how this func will work with Clone.\r\nfunc (s *SuperAgent) Timeout(timeout time.Duration) *SuperAgent {\r\n    s.Transport.Dial = func(network, addr string) (net.Conn, error) {\r\n        conn, err := net.DialTimeout(network, addr, timeout)\r\n        if err != nil {\r\n            s.Errors = append(s.Errors, err)\r\n            return nil, err\r\n        }\r\n        conn.SetDeadline(time.Now().Add(timeout))\r\n        return conn, nil\r\n    }\r\n    return s\r\n}"
        },
        {
          "name": "gorequest_client_go1.3.go",
          "type": "blob",
          "size": 0.666015625,
          "content": "// +build go1.3\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"time\"\r\n    \"net/http\"\r\n)\r\n\r\n\r\n// we don't want to mess up other clones when we modify the client..\r\n// so unfortantely we need to create a new client\r\nfunc (s *SuperAgent) safeModifyHttpClient() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldClient := s.Client\r\n    s.Client = &http.Client{}\r\n    s.Client.Jar = oldClient.Jar\r\n    s.Client.Transport = oldClient.Transport\r\n    s.Client.Timeout = oldClient.Timeout\r\n    s.Client.CheckRedirect = oldClient.CheckRedirect\r\n}\r\n\r\n\r\nfunc (s *SuperAgent) Timeout(timeout time.Duration) *SuperAgent {\r\n    s.safeModifyHttpClient()\r\n    s.Client.Timeout = timeout\r\n    return s\r\n}"
        },
        {
          "name": "gorequest_test.go",
          "type": "blob",
          "size": 83.505859375,
          "content": "package gorequest\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"mime/multipart\"\n\n\t\"os\"\n\n\t\"github.com/elazarl/goproxy\"\n)\n\ntype (\n\theyYou struct {\n\t\tHey string `json:\"hey\"`\n\t}\n\ttestStruct struct {\n\t\tString      string\n\t\tInt         int\n\t\tBtrue       bool\n\t\tBfalse      bool\n\t\tFloat       float64\n\t\tStringArray []string\n\t\tIntArray    []int\n\t\tBoolArray   []bool\n\t\tFloatArray  []float64\n\t}\n)\n\n// Test for type constants.\nfunc TestTypeConstants(t *testing.T) {\n\tif TypeJSON != \"json\" {\n\t\tt.Errorf(\"Expected TypeJSON -> json | but got %s\", TypeJSON)\n\t}\n\n\tif TypeXML != \"xml\" {\n\t\tt.Errorf(\"Expected TypeXML -> xml | but got %s\", TypeXML)\n\t}\n\n\tif TypeForm != \"form\" {\n\t\tt.Errorf(\"Expected TypeForm -> form | but got %s\", TypeForm)\n\t}\n\n\tif TypeFormData != \"form-data\" {\n\t\tt.Errorf(\"Expected TypeFormData -> form-data | but got %s\", TypeFormData)\n\t}\n\n\tif TypeUrlencoded != \"urlencoded\" {\n\t\tt.Errorf(\"Expected TypeUrlencoded -> urlencoded | but got %s\", TypeUrlencoded)\n\t}\n\n\tif TypeHTML != \"html\" {\n\t\tt.Errorf(\"Expected TypeHTML -> html | but got %s\", TypeHTML)\n\t}\n\n\tif TypeText != \"text\" {\n\t\tt.Errorf(\"Expected TypeText -> text | but got %s\", TypeText)\n\t}\n\n\tif TypeMultipart != \"multipart\" {\n\t\tt.Errorf(\"Expected TypeMultipart -> multipart | but got %s\", TypeMultipart)\n\t}\n}\n\n// Test for Types map.\nfunc TestTypesMap(t *testing.T) {\n\tif Types[TypeJSON] != \"application/json\" {\n\t\tt.Errorf(`Expected Types[\"json\"] -> \"application/json\" | but got %s`, Types[TypeJSON])\n\t}\n\n\tif Types[TypeXML] != \"application/xml\" {\n\t\tt.Errorf(`Expected Types[\"xml\"] -> \"applicaion/xml\" | but got %s`, Types[TypeXML])\n\t}\n\n\tif Types[TypeForm] != \"application/x-www-form-urlencoded\" {\n\t\tt.Errorf(`Expected Types[\"form\"] -> \"application/x-www-form-urlencoded\" | but got %s`, Types[TypeForm])\n\t}\n\n\tif Types[TypeFormData] != \"application/x-www-form-urlencoded\" {\n\t\tt.Errorf(`Expected Types[\"form-data\"] -> \"application/x-www-form-urlencoded\" | but got %s`, Types[TypeFormData])\n\t}\n\n\tif Types[TypeUrlencoded] != \"application/x-www-form-urlencoded\" {\n\t\tt.Errorf(`Expected Types[\"urlencoded\"] -> \"application/x-www-form-urlencoded\" | but got %s`, Types[TypeUrlencoded])\n\t}\n\n\tif Types[TypeHTML] != \"text/html\" {\n\t\tt.Errorf(`Expected Types[\"html\"] -> \"text/html\" | but got %s`, Types[TypeHTML])\n\t}\n\n\tif Types[TypeText] != \"text/plain\" {\n\t\tt.Errorf(`Expected Types[\"text\"] -> \"text/plain\" | but got %s`, Types[TypeText])\n\t}\n\n\tif Types[TypeMultipart] != \"multipart/form-data\" {\n\t\tt.Errorf(`Expected Types[\"multipart\"] -> \"multipart/form-data\" | but got %s`, Types[TypeMultipart])\n\t}\n}\n\n// Test for changeMapToURLValues\nfunc TestChangeMapToURLValues(t *testing.T) {\n\n\tdata := map[string]interface{}{\n\t\t\"s\":  \"a string\",\n\t\t\"i\":  42,\n\t\t\"bt\": true,\n\t\t\"bf\": false,\n\t\t\"f\":  12.345,\n\t\t\"sa\": []string{\"s1\", \"s2\"},\n\t\t\"ia\": []int{47, 73},\n\t\t\"fa\": []float64{1.23, 4.56},\n\t\t\"ba\": []bool{true, false},\n\t}\n\n\turlValues := changeMapToURLValues(data)\n\n\tvar (\n\t\ts  string\n\t\tsd string\n\t)\n\n\tif s := urlValues.Get(\"s\"); s != data[\"s\"] {\n\t\tt.Errorf(\"Expected string %v, got %v\", data[\"s\"], s)\n\t}\n\n\ts = urlValues.Get(\"i\")\n\tsd = strconv.Itoa(data[\"i\"].(int))\n\tif s != sd {\n\t\tt.Errorf(\"Expected int %v, got %v\", sd, s)\n\t}\n\n\ts = urlValues.Get(\"bt\")\n\tsd = strconv.FormatBool(data[\"bt\"].(bool))\n\tif s != sd {\n\t\tt.Errorf(\"Expected boolean %v, got %v\", sd, s)\n\t}\n\n\ts = urlValues.Get(\"bf\")\n\tsd = strconv.FormatBool(data[\"bf\"].(bool))\n\tif s != sd {\n\t\tt.Errorf(\"Expected boolean %v, got %v\", sd, s)\n\t}\n\n\ts = urlValues.Get(\"f\")\n\tsd = strconv.FormatFloat(data[\"f\"].(float64), 'f', -1, 64)\n\tif s != sd {\n\t\tt.Errorf(\"Expected float %v, got %v\", data[\"f\"], s)\n\t}\n\n\t// array cases\n\t// \"To access multiple values, use the map directly.\"\n\n\tif size := len(urlValues[\"sa\"]); size != 2 {\n\t\tt.Fatalf(\"Expected length %v, got %v\", 2, size)\n\t}\n\tif urlValues[\"sa\"][0] != \"s1\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"s1\", urlValues[\"sa\"][0])\n\t}\n\tif urlValues[\"sa\"][1] != \"s2\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"s2\", urlValues[\"sa\"][1])\n\t}\n\n\tif size := len(urlValues[\"ia\"]); size != 2 {\n\t\tt.Fatalf(\"Expected length %v, got %v\", 2, size)\n\t}\n\tif urlValues[\"ia\"][0] != \"47\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"47\", urlValues[\"ia\"][0])\n\t}\n\tif urlValues[\"ia\"][1] != \"73\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"73\", urlValues[\"ia\"][1])\n\t}\n\n\tif size := len(urlValues[\"ba\"]); size != 2 {\n\t\tt.Fatalf(\"Expected length %v, got %v\", 2, size)\n\t}\n\tif urlValues[\"ba\"][0] != \"true\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"true\", urlValues[\"ba\"][0])\n\t}\n\tif urlValues[\"ba\"][1] != \"false\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"false\", urlValues[\"ba\"][1])\n\t}\n\n\tif size := len(urlValues[\"fa\"]); size != 2 {\n\t\tt.Fatalf(\"Expected length %v, got %v\", 2, size)\n\t}\n\tif urlValues[\"fa\"][0] != \"1.23\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"true\", urlValues[\"fa\"][0])\n\t}\n\tif urlValues[\"fa\"][1] != \"4.56\" {\n\t\tt.Errorf(\"Expected string %v, got %v\", \"false\", urlValues[\"fa\"][1])\n\t}\n}\n\n// Test for Make request\nfunc TestMakeRequest(t *testing.T) {\n\tvar err error\n\tvar cases = []struct {\n\t\tm string\n\t\ts *SuperAgent\n\t}{\n\t\t{POST, New().Post(\"/\")},\n\t\t{GET, New().Get(\"/\")},\n\t\t{HEAD, New().Head(\"/\")},\n\t\t{PUT, New().Put(\"/\")},\n\t\t{PATCH, New().Patch(\"/\")},\n\t\t{DELETE, New().Delete(\"/\")},\n\t\t{OPTIONS, New().Options(\"/\")},\n\t\t{\"TRACE\", New().CustomMethod(\"TRACE\", \"/\")}, // valid HTTP 1.1 method, see W3C RFC 2616\n\t}\n\n\tfor _, c := range cases {\n\t\t_, err = c.s.MakeRequest()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Expected nil error for method %q; got %q\", c.m, err.Error())\n\t\t}\n\t}\n\n\t// empty method should fail\n\t_, err = New().CustomMethod(\"\", \"/\").MakeRequest()\n\tif err == nil {\n\t\tt.Errorf(\"Expected non-nil error for empty method; got %q\", err.Error())\n\t}\n}\n\n// testing for Get method\nfunc TestGet(t *testing.T) {\n\tconst case1_empty = \"/\"\n\tconst case2_set_header = \"/set_header\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is GET before going to check other features\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty:\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\tcase case2_set_header:\n\t\t\tt.Logf(\"case %v \", case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Get(ts.URL + case1_empty).\n\t\tEnd()\n\n\tNew().Get(ts.URL+case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\").\n\t\tEnd()\n}\n\n// testing for Get method.. but clone our base.\nfunc TestGetWithClone(t *testing.T) {\n\tconst case1_empty = \"/\"\n\tconst case2_set_header = \"/set_header\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is GET before going to check other features\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty:\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\tcase case2_set_header:\n\t\t\tt.Logf(\"case %v \", case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\treqBase := New()\n\treqBase.Clone().Get(ts.URL + case1_empty).\n\t\tEnd()\n\n\treqBase.Clone().Get(ts.URL+case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\").\n\t\tEnd()\n}\n\n// testing for Get method.. but clone our base.\nfunc TestGetWithCloneRequestAfterMake(t *testing.T) {\n\tconst case1_empty = \"/\"\n\tconst case2_set_header = \"/set_header\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is GET before going to check other features\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty:\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\tcase case2_set_header:\n\t\t\tt.Logf(\"case %v \", case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\treqBase := New()\n\t// define the two request\n\treq1 := reqBase.Clone().Get(ts.URL + case1_empty)\n\treq2 := reqBase.Clone().Get(ts.URL+case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\")\n\t// now they have different bases, so make the requests\n\treq1.End()\n\treq2.End()\n}\n\n// testing for Get method.. but clone our base.\nfunc TestGetWithCloneWithHeadersAndQuery(t *testing.T) {\n\tconst case1_empty = \"/\"\n\tconst case2_set_header = \"/set_header\"\n\tconst case3_set_query = \"/set_query\"\n\tconst case4_set_both = \"/set_both\"\n\tconst case5_empty = \"/empty\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is GET before going to check other features\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tt.Logf(\"header %v\", r.Header)\n\t\tif r.Header.Get(\"base\") != \"header\" {\n\t\t\tt.Errorf(\"Expected base header: %s\", r.Header.Get(\"base\"))\n\t\t}\n\t\tif r.URL.Query().Get(\"queryBase\") != \"yep\" {\n\t\t\tt.Errorf(\"Expected queryBase queryParam: %s\", r.URL.Query().Get(\"queryBase\"))\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty, case5_empty:\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\t\tif r.Header.Get(\"API-Key\") != \"base\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"base\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\t\tif r.URL.Query().Get(\"newQuery\") != \"\" {\n\t\t\t\tt.Errorf(\"Expected 'newQuery' == %q; got %q\", \"\", r.URL.Query().Get(\"newQuery\"))\n\t\t\t}\n\t\t\tif r.Header.Get(\"FOURTH\") != \"\" {\n\t\t\t\tt.Errorf(\"Expected 'FOURTH' == %q; got %q\", \"\", r.Header.Get(\"FOURTH\"))\n\t\t\t}\n\t\tcase case2_set_header:\n\t\t\tt.Logf(\"case %v \", case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\tcase case3_set_query:\n\t\t\tt.Logf(\"case %v \", case3_set_query)\n\t\t\tif r.URL.Query().Get(\"newQuery\") != \"newVal\" {\n\t\t\t\tt.Errorf(\"Expected 'newQuery' == %q; got %q\", \"newVal\", r.URL.Query().Get(\"newQuery\"))\n\t\t\t}\n\t\tcase case4_set_both:\n\t\t\tt.Logf(\"case %v \", case3_set_query)\n\t\t\tif r.URL.Query().Get(\"fourth\") != \"4val\" {\n\t\t\t\tt.Errorf(\"Expected 'fourth' == %q; got %q\", \"4val\", r.URL.Query().Get(\"fourth\"))\n\t\t\t}\n\t\t\tif r.Header.Get(\"FOURTH\") != \"fourkey\" {\n\t\t\t\tt.Errorf(\"Expected 'FOURTH' == %q; got %q\", \"fourkey\", r.Header.Get(\"FOURTH\"))\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\treqBase := New().\n\t\tSet(\"base\", \"header\").\n\t\tSet(\"API-KEY\", \"base\").\n\t\tParam(\"queryBase\", \"yep\")\n\n\t// define the two request\n\treq1 := reqBase.Clone().Get(ts.URL + case1_empty)\n\treq2 := reqBase.Clone().Get(ts.URL+case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\")\n\treq3 := reqBase.Clone().Get(ts.URL+case3_set_query).\n\t\tParam(\"newQuery\", \"newVal\")\n\treq4 := reqBase.Clone().Get(ts.URL+case4_set_both).\n\t\tParam(\"fourth\", \"4val\").\n\t\tSet(\"FOURTH\", \"fourkey\")\n\treq5 := reqBase.Clone().Get(ts.URL + case5_empty)\n\t// now they have different bases, so make the requests\n\treq1.End()\n\treq2.End()\n\treq3.End()\n\treq4.End()\n\treq5.End()\n}\n\n// testing for Get method.. but clone our base.\nfunc TestConcurrently(t *testing.T) {\n\tconst case1_empty = \"/\"\n\tconst case2_set_header = \"/set_header\"\n\tconst case3_set_query = \"/set_query\"\n\tconst case4_set_both = \"/set_both\"\n\tconst case5_post = \"/post\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is GET before going to check other features\n\t\tif r.Method != GET && r.URL.Path != case5_post {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t} else if r.Method != POST && r.URL.Path == case5_post {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tt.Logf(\"header %v\", r.Header)\n\t\tif r.Header.Get(\"base\") != \"header\" {\n\t\t\tt.Errorf(\"Expected base header: %s\", r.Header.Get(\"base\"))\n\t\t}\n\t\tif r.URL.Query().Get(\"queryBase\") != \"yep\" {\n\t\t\tt.Errorf(\"Expected queryBase queryParam: %s\", r.URL.Query().Get(\"queryBase\"))\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty:\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\t\tif r.Header.Get(\"API-Key\") != \"base\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"base\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\t\tif r.URL.Query().Get(\"newQuery\") != \"\" {\n\t\t\t\tt.Errorf(\"Expected 'newQuery' == %q; got %q\", \"\", r.URL.Query().Get(\"newQuery\"))\n\t\t\t}\n\t\t\tif r.Header.Get(\"FOURTH\") != \"\" {\n\t\t\t\tt.Errorf(\"Expected 'FOURTH' == %q; got %q\", \"\", r.Header.Get(\"FOURTH\"))\n\t\t\t}\n\t\tcase case2_set_header:\n\t\t\tt.Logf(\"case %v \", case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\tcase case3_set_query:\n\t\t\tt.Logf(\"case %v \", case3_set_query)\n\t\t\tif r.URL.Query().Get(\"newQuery\") != \"newVal\" {\n\t\t\t\tt.Errorf(\"Expected 'newQuery' == %q; got %q\", \"newVal\", r.URL.Query().Get(\"newQuery\"))\n\t\t\t}\n\t\tcase case4_set_both:\n\t\t\tt.Logf(\"case %v \", case3_set_query)\n\t\t\tif r.URL.Query().Get(\"fourth\") != \"4val\" {\n\t\t\t\tt.Errorf(\"Expected 'fourth' == %q; got %q\", \"4val\", r.URL.Query().Get(\"fourth\"))\n\t\t\t}\n\t\t\tif r.Header.Get(\"FOURTH\") != \"fourkey\" {\n\t\t\t\tt.Errorf(\"Expected 'FOURTH' == %q; got %q\", \"fourkey\", r.Header.Get(\"FOURTH\"))\n\t\t\t}\n\t\tcase case5_post:\n\t\t\tt.Logf(\"case %v \", case5_post)\n\t\t\tif r.URL.Query().Get(\"iteration\") == \"\" {\n\t\t\t\tt.Errorf(\"Expected 'fourth' != %q; got %q\", \"\", r.URL.Query().Get(\"iteration\"))\n\t\t\t}\n\t\t\tr.ParseForm()\n\t\t\tif r.Form.Get(\"form_iteration\") == \"\" {\n\t\t\t\tt.Errorf(\"Expected 'form_iteration' != %q; got %q\", \"\", r.Form.Get(\"form_iteration\"))\n\t\t\t}\n\t\t\tif r.Form.Get(\"form_iteration\") != r.URL.Query().Get(\"iteration\") {\n\t\t\t\tt.Errorf(\"Expected 'form_iteration' == %q; got %q\", r.URL.Query().Get(\"iteration\"), r.Form.Get(\"form_iteration\"))\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\treqBase := New().\n\t\tSet(\"base\", \"header\").\n\t\tSet(\"API-KEY\", \"base\").\n\t\tParam(\"queryBase\", \"yep\")\n\n\tvar waitForCompletion sync.WaitGroup\n\n\t// define the two request\n\tfor i := 0; i < 1000; i++ {\n\t\twaitForCompletion.Add(5)\n\t\tgo func() {\n\t\t\treqBase.Clone().Get(ts.URL + case1_empty).End()\n\t\t\twaitForCompletion.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\treqBase.Clone().Get(ts.URL+case2_set_header).\n\t\t\t\tSet(\"API-Key\", \"fookey\").\n\t\t\t\tEnd()\n\t\t\twaitForCompletion.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\treqBase.Clone().Get(ts.URL+case3_set_query).\n\t\t\t\tParam(\"newQuery\", \"newVal\").\n\t\t\t\tEnd()\n\t\t\twaitForCompletion.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\treqBase.Clone().Get(ts.URL+case4_set_both).\n\t\t\t\tParam(\"fourth\", \"4val\").\n\t\t\t\tSet(\"FOURTH\", \"fourkey\").\n\t\t\t\tEnd()\n\t\t\twaitForCompletion.Done()\n\t\t}()\n\t\tgo func(iter int) {\n\t\t\titerStr := fmt.Sprintf(\"%d\", iter)\n\t\t\treqBase.Clone().Post(ts.URL+case5_post).\n\t\t\t\tParam(\"iteration\", iterStr).\n\t\t\t\tType(\"form\").\n\t\t\t\tSend(fmt.Sprintf(`{\"form_iteration\": \"%s\"}`, iterStr)).\n\t\t\t\tEnd()\n\t\t\twaitForCompletion.Done()\n\t\t}(i)\n\t}\n\twaitForCompletion.Wait()\n}\n\n// testing for Get method with retry option\nfunc TestRetryGet(t *testing.T) {\n\tconst (\n\t\tcase1_empty                         = \"/\"\n\t\tcase24_after_3_attempt_return_valid = \"/retry_3_attempt_then_valid\"\n\t\tretry_count_expected                = \"3\"\n\t)\n\n\tvar attempt int\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is GET before going to check other features\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\n\t\t//set return status\n\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty:\n\t\t\tw.WriteHeader(400)\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\tcase case24_after_3_attempt_return_valid:\n\t\t\tif attempt == 3 {\n\t\t\t\tw.WriteHeader(200)\n\t\t\t} else {\n\t\t\t\tw.WriteHeader(400)\n\t\t\t\tt.Logf(\"case %v \", case24_after_3_attempt_return_valid)\n\t\t\t}\n\t\t\tattempt++\n\t\t}\n\n\t}))\n\n\tdefer ts.Close()\n\n\tresp, _, errs := New().Get(ts.URL+case1_empty).\n\t\tRetry(3, 1*time.Nanosecond, http.StatusBadRequest).\n\t\tEnd()\n\tif errs != nil {\n\t\tt.Errorf(\"No testing for this case yet : %q\", errs)\n\t}\n\n\tretryCountReturn := resp.Header.Get(\"Retry-Count\")\n\tif retryCountReturn != retry_count_expected {\n\t\tt.Errorf(\"Expected [%s] retry but was [%s]\", retry_count_expected, retryCountReturn)\n\t}\n\n\tresp, _, errs = New().Get(ts.URL+case24_after_3_attempt_return_valid).\n\t\tRetry(4, 1*time.Nanosecond, http.StatusBadRequest).\n\t\tEnd()\n\tif errs != nil {\n\t\tt.Errorf(\"No testing for this case yet : %q\", errs)\n\t}\n\n\tretryCountReturn = resp.Header.Get(\"Retry-Count\")\n\tif retryCountReturn != retry_count_expected {\n\t\tt.Errorf(\"Expected [%s] retry but was [%s]\", retry_count_expected, retryCountReturn)\n\t}\n}\n\n// testing for Options method\nfunc TestOptions(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is OPTIONS before going to check other features\n\t\tif r.Method != OPTIONS {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", OPTIONS, r.Method)\n\t\t}\n\t\tt.Log(\"test Options\")\n\t\tw.Header().Set(\"Allow\", \"HEAD, GET\")\n\t\tw.WriteHeader(204)\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Options(ts.URL).\n\t\tEnd()\n}\n\n// testing that resp.Body is reusable\nfunc TestResetBody(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Just some text\"))\n\t}))\n\n\tdefer ts.Close()\n\n\tresp, _, _ := New().Get(ts.URL).End()\n\tbodyBytes, _ := ioutil.ReadAll(resp.Body)\n\tif string(bodyBytes) != \"Just some text\" {\n\t\tt.Error(\"Expected to be able to reuse the response body\")\n\t}\n}\n\n// testing for Param method\nfunc TestParam(t *testing.T) {\n\tparamCode := \"123456\"\n\tparamFields := \"f1;f2;f3\"\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Form.Get(\"code\") != paramCode {\n\t\t\tt.Errorf(\"Expected 'code' == %s; got %v\", paramCode, r.Form.Get(\"code\"))\n\t\t}\n\n\t\tif r.Form.Get(\"fields\") != paramFields {\n\t\t\tt.Errorf(\"Expected 'fields' == %s; got %v\", paramFields, r.Form.Get(\"fields\"))\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Get(ts.URL).\n\t\tParam(\"code\", paramCode).\n\t\tParam(\"fields\", paramFields)\n}\n\nconst (\n\ttest_post_case1_empty                        = \"/\"\n\ttest_post_case2_set_header                   = \"/set_header\"\n\ttest_post_case3_send_json                    = \"/send_json\"\n\ttest_post_case4_send_string                  = \"/send_string\"\n\ttest_post_case5_integration_send_json_string = \"/integration_send_json_string\"\n\ttest_post_case6_set_query                    = \"/set_query\"\n\ttest_post_case7_integration_send_json_struct = \"/integration_send_json_struct\"\n\t// Check that the number conversion should be converted as string not float64\n\ttest_post_case8_send_json_with_long_id_number                       = \"/send_json_with_long_id_number\"\n\ttest_post_case9_send_json_string_with_long_id_number_as_form_result = \"/send_json_string_with_long_id_number_as_form_result\"\n\ttest_post_case10_send_struct_pointer                                = \"/send_struct_pointer\"\n\ttest_post_case11_send_string_pointer                                = \"/send_string_pointer\"\n\ttest_post_case12_send_slice_string                                  = \"/send_slice_string\"\n\ttest_post_case13_send_slice_string_pointer                          = \"/send_slice_string_pointer\"\n\ttest_post_case14_send_int_pointer                                   = \"/send_int_pointer\"\n\ttest_post_case15_send_float_pointer                                 = \"/send_float_pointer\"\n\ttest_post_case16_send_bool_pointer                                  = \"/send_bool_pointer\"\n\ttest_post_case17_send_string_array                                  = \"/send_string_array\"\n\ttest_post_case18_send_string_array_pointer                          = \"/send_string_array_pointer\"\n\ttest_post_case19_send_struct                                        = \"/send_struct\"\n\ttest_post_case20_send_byte_char                                     = \"/send_byte_char\"\n\ttest_post_case21_send_byte_char_pointer                             = \"/send_byte_char_pointer\"\n\ttest_post_case22_send_byte_int                                      = \"/send_byte_int\"\n\ttest_post_case22_send_byte_int_pointer                              = \"/send_byte_int_pointer\"\n\ttest_post_case23_send_duplicate_query_params                        = \"/send_duplicate_query_params\"\n\ttest_post_case24_send_query_and_request_body                        = \"/send_query_and_request_body\"\n)\n\n// testing for POST method\nfunc testPostServer(t *testing.T) *httptest.Server {\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is POST before going to check other features\n\t\tif r.Method != POST {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase test_post_case1_empty:\n\t\t\tt.Logf(\"case %v \", test_post_case1_empty)\n\t\tcase test_post_case2_set_header:\n\t\t\tt.Logf(\"case %v \", test_post_case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\tcase test_post_case3_send_json:\n\t\t\tt.Logf(\"case %v \", test_post_case3_send_json)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != `{\"query1\":\"test\",\"query2\":\"test\"}` {\n\t\t\t\tt.Error(`Expected Body with {\"query1\":\"test\",\"query2\":\"test\"}`, \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case4_send_string, test_post_case11_send_string_pointer:\n\t\t\tt.Logf(\"case %v \", r.URL.Path)\n\t\t\tif r.Header.Get(\"Content-Type\") != \"application/x-www-form-urlencoded\" {\n\t\t\t\tt.Error(\"Expected Header Content-Type -> application/x-www-form-urlencoded\", \"| but got\", r.Header.Get(\"Content-Type\"))\n\t\t\t}\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != \"query1=test&query2=test\" {\n\t\t\t\tt.Error(\"Expected Body with \\\"query1=test&query2=test\\\"\", \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case5_integration_send_json_string:\n\t\t\tt.Logf(\"case %v \", test_post_case5_integration_send_json_string)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != \"query1=test&query2=test\" {\n\t\t\t\tt.Error(\"Expected Body with \\\"query1=test&query2=test\\\"\", \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case6_set_query:\n\t\t\tt.Logf(\"case %v \", test_post_case6_set_query)\n\t\t\tv := r.URL.Query()\n\t\t\tif v[\"query1\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query1:test\", \"| but got\", v[\"query1\"][0])\n\t\t\t}\n\t\t\tif v[\"query2\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query2:test\", \"| but got\", v[\"query2\"][0])\n\t\t\t}\n\t\tcase test_post_case7_integration_send_json_struct:\n\t\t\tt.Logf(\"case %v \", test_post_case7_integration_send_json_struct)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tcomparedBody := []byte(`{\"Lower\":{\"Color\":\"green\",\"Size\":1.7},\"Upper\":{\"Color\":\"red\",\"Size\":0},\"a\":\"a\",\"name\":\"Cindy\"}`)\n\t\t\tif !bytes.Equal(body, comparedBody) {\n\t\t\t\tt.Errorf(`Expected correct json but got ` + string(body))\n\t\t\t}\n\t\tcase test_post_case8_send_json_with_long_id_number:\n\t\t\tt.Logf(\"case %v \", test_post_case8_send_json_with_long_id_number)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != `{\"id\":123456789,\"name\":\"nemo\"}` {\n\t\t\t\tt.Error(`Expected Body with {\"id\":123456789,\"name\":\"nemo\"}`, \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case9_send_json_string_with_long_id_number_as_form_result:\n\t\t\tt.Logf(\"case %v \", test_post_case9_send_json_string_with_long_id_number_as_form_result)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != `id=123456789&name=nemo` {\n\t\t\t\tt.Error(`Expected Body with \"id=123456789&name=nemo\"`, `| but got`, string(body))\n\t\t\t}\n\t\tcase test_post_case19_send_struct, test_post_case10_send_struct_pointer:\n\t\t\tt.Logf(\"case %v \", r.URL.Path)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tcomparedBody := []byte(`{\"Bfalse\":false,\"BoolArray\":[true,false],\"Btrue\":true,\"Float\":12.345,\"FloatArray\":[1.23,4.56,7.89],\"Int\":42,\"IntArray\":[1,2],\"String\":\"a string\",\"StringArray\":[\"string1\",\"string2\"]}`)\n\t\t\tif !bytes.Equal(body, comparedBody) {\n\t\t\t\tt.Errorf(`Expected correct json but got ` + string(body))\n\t\t\t}\n\t\tcase test_post_case12_send_slice_string, test_post_case13_send_slice_string_pointer, test_post_case17_send_string_array, test_post_case18_send_string_array_pointer:\n\t\t\tt.Logf(\"case %v \", r.URL.Path)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tcomparedBody := []byte(`[\"string1\",\"string2\"]`)\n\t\t\tif !bytes.Equal(body, comparedBody) {\n\t\t\t\tt.Errorf(`Expected correct json but got ` + string(body))\n\t\t\t}\n\t\tcase test_post_case14_send_int_pointer:\n\t\t\tt.Logf(\"case %v \", test_post_case14_send_int_pointer)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != \"42\" {\n\t\t\t\tt.Error(\"Expected Body with \\\"42\\\"\", \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case15_send_float_pointer:\n\t\t\tt.Logf(\"case %v \", test_post_case15_send_float_pointer)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != \"12.345\" {\n\t\t\t\tt.Error(\"Expected Body with \\\"12.345\\\"\", \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case16_send_bool_pointer:\n\t\t\tt.Logf(\"case %v \", test_post_case16_send_bool_pointer)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != \"true\" {\n\t\t\t\tt.Error(\"Expected Body with \\\"true\\\"\", \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case20_send_byte_char, test_post_case21_send_byte_char_pointer, test_post_case22_send_byte_int, test_post_case22_send_byte_int_pointer:\n\t\t\tt.Logf(\"case %v \", r.URL.Path)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != \"71\" {\n\t\t\t\tt.Error(\"Expected Body with \\\"71\\\"\", \"| but got\", string(body))\n\t\t\t}\n\t\tcase test_post_case23_send_duplicate_query_params:\n\t\t\tt.Logf(\"case %v \", test_post_case23_send_duplicate_query_params)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tsbody := string(body)\n\t\t\tif sbody != \"param=4&param=3&param=2&param=1\" {\n\t\t\t\tt.Error(\"Expected Body \\\"param=4&param=3&param=2&param=1\\\"\", \"| but got\", sbody)\n\t\t\t}\n\t\t\tvalues, _ := url.ParseQuery(sbody)\n\t\t\tif len(values[\"param\"]) != 4 {\n\t\t\t\tt.Error(\"Expected Body with 4 params\", \"| but got\", sbody)\n\t\t\t}\n\t\t\tif values[\"param\"][0] != \"4\" || values[\"param\"][1] != \"3\" || values[\"param\"][2] != \"2\" || values[\"param\"][3] != \"1\" {\n\t\t\t\tt.Error(\"Expected Body with 4 params and values\", \"| but got\", sbody)\n\t\t\t}\n\t\tcase test_post_case24_send_query_and_request_body:\n\t\t\tt.Logf(\"case %v \", test_post_case24_send_query_and_request_body)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tsbody := string(body)\n\t\t\tif sbody != `{\"name\":\"jkbbwr\"}` {\n\t\t\t\tt.Error(`Expected Body \"{\"name\":\"jkbbwr\"}\"`, \"| but got\", sbody)\n\t\t\t}\n\n\t\t\tv := r.URL.Query()\n\t\t\tif v[\"test\"][0] != \"true\" {\n\t\t\t\tt.Error(\"Expected test:true\", \"| but got\", v[\"test\"][0])\n\t\t\t}\n\t\t}\n\t}))\n\treturn ts\n}\n\nfunc TestPost(t *testing.T) {\n\tts := testPostServer(t)\n\tdefer ts.Close()\n\n\tNew().Post(ts.URL + test_post_case1_empty).\n\t\tEnd()\n\n\tNew().Post(ts.URL+test_post_case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case3_send_json).\n\t\tSend(`{\"query1\":\"test\"}`).\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case4_send_string).\n\t\tSend(\"query1=test\").\n\t\tSend(\"query2=test\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case5_integration_send_json_string).\n\t\tSend(\"query1=test\").\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n\n\t/* TODO: More testing post for application/x-www-form-urlencoded\n\t   post.query(json), post.query(string), post.send(json), post.send(string), post.query(both).send(both)\n\t*/\n\tNew().Post(ts.URL + test_post_case6_set_query).\n\t\tQuery(\"query1=test\").\n\t\tQuery(\"query2=test\").\n\t\tEnd()\n\t// TODO:\n\t// 1. test 2nd layer nested struct\n\t// 2. test lowercase won't be export to json\n\t// 3. test field tag change to json field name\n\ttype Upper struct {\n\t\tColor string\n\t\tSize  int\n\t\tnote  string\n\t}\n\ttype Lower struct {\n\t\tColor string\n\t\tSize  float64\n\t\tnote  string\n\t}\n\ttype Style struct {\n\t\tUpper Upper\n\t\tLower Lower\n\t\tName  string `json:\"name\"`\n\t}\n\tmyStyle := Style{Upper: Upper{Color: \"red\"}, Name: \"Cindy\", Lower: Lower{Color: \"green\", Size: 1.7}}\n\tNew().Post(ts.URL + test_post_case7_integration_send_json_struct).\n\t\tSend(`{\"a\":\"a\"}`).\n\t\tSend(myStyle).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case8_send_json_with_long_id_number).\n\t\tSend(`{\"id\":123456789, \"name\":\"nemo\"}`).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case9_send_json_string_with_long_id_number_as_form_result).\n\t\tType(\"form\").\n\t\tSend(`{\"id\":123456789, \"name\":\"nemo\"}`).\n\t\tEnd()\n\n\tpayload := testStruct{\n\t\tString:      \"a string\",\n\t\tInt:         42,\n\t\tBtrue:       true,\n\t\tBfalse:      false,\n\t\tFloat:       12.345,\n\t\tStringArray: []string{\"string1\", \"string2\"},\n\t\tIntArray:    []int{1, 2},\n\t\tBoolArray:   []bool{true, false},\n\t\tFloatArray:  []float64{1.23, 4.56, 7.89},\n\t}\n\n\tNew().Post(ts.URL + test_post_case10_send_struct_pointer).\n\t\tSend(&payload).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case19_send_struct).\n\t\tSend(payload).\n\t\tEnd()\n\n\ts1 := \"query1=test\"\n\ts2 := \"query2=test\"\n\tNew().Post(ts.URL + test_post_case11_send_string_pointer).\n\t\tSend(&s1).\n\t\tSend(&s2).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case12_send_slice_string).\n\t\tSend([]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case13_send_slice_string_pointer).\n\t\tSend(&[]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\ti := 42\n\tNew().Post(ts.URL + test_post_case14_send_int_pointer).\n\t\tSend(&i).\n\t\tEnd()\n\n\tf := 12.345\n\tNew().Post(ts.URL + test_post_case15_send_float_pointer).\n\t\tSend(&f).\n\t\tEnd()\n\n\tb := true\n\tNew().Post(ts.URL + test_post_case16_send_bool_pointer).\n\t\tSend(&b).\n\t\tEnd()\n\n\tvar a [2]string\n\ta[0] = \"string1\"\n\ta[1] = \"string2\"\n\tNew().Post(ts.URL + test_post_case17_send_string_array).\n\t\tSend(a).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case18_send_string_array_pointer).\n\t\tSend(&a).\n\t\tEnd()\n\n\taByte := byte('G') // = 71 dec\n\tNew().Post(ts.URL + test_post_case20_send_byte_char).\n\t\tSend(aByte).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case21_send_byte_char_pointer).\n\t\tSend(&aByte).\n\t\tEnd()\n\n\tiByte := byte(71) // = 'G'\n\tNew().Post(ts.URL + test_post_case22_send_byte_int).\n\t\tSend(iByte).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case22_send_byte_int_pointer).\n\t\tSend(&iByte).\n\t\tEnd()\n\n\tNew().Post(ts.URL + test_post_case23_send_duplicate_query_params).\n\t\tSend(\"param=1\").\n\t\tSend(\"param=2\").\n\t\tSend(\"param=3&param=4\").\n\t\tEnd()\n\n\tdata24 := struct {\n\t\tName string `json:\"name\"`\n\t}{\"jkbbwr\"}\n\tNew().Post(ts.URL + test_post_case24_send_query_and_request_body).\n\t\tQuery(\"test=true\").\n\t\tSend(data24).\n\t\tEnd()\n}\n\n// clone the super agent instead of calling New each time\nfunc TestPostCloneSuperAgent(t *testing.T) {\n\tts := testPostServer(t)\n\tdefer ts.Close()\n\n\tbaseRequest := New()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case1_empty).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL+test_post_case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\").\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case3_send_json).\n\t\tSend(`{\"query1\":\"test\"}`).\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case4_send_string).\n\t\tSend(\"query1=test\").\n\t\tSend(\"query2=test\").\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case5_integration_send_json_string).\n\t\tSend(\"query1=test\").\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n\n\t/* TODO: More testing post for application/x-www-form-urlencoded\n\t   post.query(json), post.query(string), post.send(json), post.send(string), post.query(both).send(both)\n\t*/\n\tbaseRequest.Clone().Post(ts.URL + test_post_case6_set_query).\n\t\tQuery(\"query1=test\").\n\t\tQuery(\"query2=test\").\n\t\tEnd()\n\t// TODO:\n\t// 1. test 2nd layer nested struct\n\t// 2. test lowercase won't be export to json\n\t// 3. test field tag change to json field name\n\ttype Upper struct {\n\t\tColor string\n\t\tSize  int\n\t\tnote  string\n\t}\n\ttype Lower struct {\n\t\tColor string\n\t\tSize  float64\n\t\tnote  string\n\t}\n\ttype Style struct {\n\t\tUpper Upper\n\t\tLower Lower\n\t\tName  string `json:\"name\"`\n\t}\n\tmyStyle := Style{Upper: Upper{Color: \"red\"}, Name: \"Cindy\", Lower: Lower{Color: \"green\", Size: 1.7}}\n\tbaseRequest.Clone().Post(ts.URL + test_post_case7_integration_send_json_struct).\n\t\tSend(`{\"a\":\"a\"}`).\n\t\tSend(myStyle).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case8_send_json_with_long_id_number).\n\t\tSend(`{\"id\":123456789, \"name\":\"nemo\"}`).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case9_send_json_string_with_long_id_number_as_form_result).\n\t\tType(\"form\").\n\t\tSend(`{\"id\":123456789, \"name\":\"nemo\"}`).\n\t\tEnd()\n\n\tpayload := testStruct{\n\t\tString:      \"a string\",\n\t\tInt:         42,\n\t\tBtrue:       true,\n\t\tBfalse:      false,\n\t\tFloat:       12.345,\n\t\tStringArray: []string{\"string1\", \"string2\"},\n\t\tIntArray:    []int{1, 2},\n\t\tBoolArray:   []bool{true, false},\n\t\tFloatArray:  []float64{1.23, 4.56, 7.89},\n\t}\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case10_send_struct_pointer).\n\t\tSend(&payload).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case19_send_struct).\n\t\tSend(payload).\n\t\tEnd()\n\n\ts1 := \"query1=test\"\n\ts2 := \"query2=test\"\n\tbaseRequest.Clone().Post(ts.URL + test_post_case11_send_string_pointer).\n\t\tSend(&s1).\n\t\tSend(&s2).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case12_send_slice_string).\n\t\tSend([]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case13_send_slice_string_pointer).\n\t\tSend(&[]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\ti := 42\n\tbaseRequest.Clone().Post(ts.URL + test_post_case14_send_int_pointer).\n\t\tSend(&i).\n\t\tEnd()\n\n\tf := 12.345\n\tbaseRequest.Clone().Post(ts.URL + test_post_case15_send_float_pointer).\n\t\tSend(&f).\n\t\tEnd()\n\n\tb := true\n\tbaseRequest.Clone().Post(ts.URL + test_post_case16_send_bool_pointer).\n\t\tSend(&b).\n\t\tEnd()\n\n\tvar a [2]string\n\ta[0] = \"string1\"\n\ta[1] = \"string2\"\n\tbaseRequest.Clone().Post(ts.URL + test_post_case17_send_string_array).\n\t\tSend(a).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case18_send_string_array_pointer).\n\t\tSend(&a).\n\t\tEnd()\n\n\taByte := byte('G') // = 71 dec\n\tbaseRequest.Clone().Post(ts.URL + test_post_case20_send_byte_char).\n\t\tSend(aByte).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case21_send_byte_char_pointer).\n\t\tSend(&aByte).\n\t\tEnd()\n\n\tiByte := byte(71) // = 'G'\n\tbaseRequest.Clone().Post(ts.URL + test_post_case22_send_byte_int).\n\t\tSend(iByte).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case22_send_byte_int_pointer).\n\t\tSend(&iByte).\n\t\tEnd()\n\n\tbaseRequest.Clone().Post(ts.URL + test_post_case23_send_duplicate_query_params).\n\t\tSend(\"param=1\").\n\t\tSend(\"param=2\").\n\t\tSend(\"param=3&param=4\").\n\t\tEnd()\n\n\tdata24 := struct {\n\t\tName string `json:\"name\"`\n\t}{\"jkbbwr\"}\n\tbaseRequest.Clone().Post(ts.URL + test_post_case24_send_query_and_request_body).\n\t\tQuery(\"test=true\").\n\t\tSend(data24).\n\t\tEnd()\n}\n\nfunc checkFile(t *testing.T, fileheader *multipart.FileHeader) {\n\tinfile, err := fileheader.Open()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer infile.Close()\n\tb, err := ioutil.ReadAll(infile)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif len(b) == 0 {\n\t\tt.Error(\"Expected file-content > 0\", \"| but got\", len(b), string(b))\n\t}\n}\n\n// testing for POST-Request of Type multipart\nfunc TestMultipartRequest(t *testing.T) {\n\n\tconst case0_send_not_supported_filetype = \"/send_not_supported_filetype\"\n\tconst case1_send_string = \"/send_string\"\n\tconst case2_send_json = \"/send_json\"\n\tconst case3_integration_send_json_string = \"/integration_send_json_string\"\n\tconst case4_set_query = \"/set_query\"\n\tconst case5_send_struct = \"/send_struct\"\n\tconst case6_send_slice_string = \"/send_slice_string\"\n\tconst case6_send_slice_string_with_custom_fieldname = \"/send_slice_string_with_custom_fieldname\"\n\tconst case7_send_array = \"/send_array\"\n\tconst case8_integration_send_json_struct = \"/integration_send_json_struct\"\n\tconst case9_send_duplicate_query_params = \"/send_duplicate_query_params\"\n\n\tconst case10_send_file_by_path = \"/send_file_by_path\"\n\tconst case10a_send_file_by_path_with_name = \"/send_file_by_path_with_name\"\n\tconst case10b_send_file_by_path_pointer = \"/send_file_by_path_pointer\"\n\tconst case11_send_file_by_path_without_name = \"/send_file_by_path_without_name\"\n\tconst case12_send_file_by_path_without_name_but_with_fieldname = \"/send_file_by_path_without_name_but_with_fieldname\"\n\n\tconst case13_send_file_by_content_without_name = \"/send_file_by_content_without_name\"\n\tconst case13a_send_file_by_content_without_name_pointer = \"/send_file_by_content_without_name_pointer\"\n\tconst case14_send_file_by_content_with_name = \"/send_file_by_content_with_name\"\n\n\tconst case15_send_file_by_content_without_name_but_with_fieldname = \"/send_file_by_content_without_name_but_with_fieldname\"\n\tconst case16_send_file_by_content_with_name_and_with_fieldname = \"/send_file_by_content_with_name_and_with_fieldname\"\n\n\tconst case17_send_file_multiple_by_path_and_content_without_name = \"/send_file_multiple_by_path_and_content_without_name\"\n\tconst case18_send_file_multiple_by_path_and_content_with_name = \"/send_file_multiple_by_path_and_content_with_name\"\n\tconst case19_integration_send_file_and_data = \"/integration_send_file_and_data\"\n\n\tconst case20_send_file_as_osfile = \"/send_file_as_osfile\"\n\tconst case21_send_file_as_osfile_with_name = \"/send_file_as_osfile_with_name\"\n\tconst case22_send_file_as_osfile_with_name_and_with_fieldname = \"/send_file_as_osfile_with_name_and_with_fieldname\"\n\n\tconst case23_send_file_with_file_as_fieldname = \"/send_file_with_file_as_fieldname\"\n\tconst case24_send_file_with_name_with_spaces = \"/send_file_with_name_with_spaces\"\n\tconst case25_send_file_with_name_with_spaces_only = \"/send_file_with_name_with_spaces_only\"\n\tconst case26_send_file_with_fieldname_with_spaces = \"/send_file_with_fieldname_with_spaces\"\n\tconst case27_send_file_with_fieldname_with_spaces_only = \"/send_file_with_fieldname_with_spaces_only\"\n\tconst case28_send_file_with_file_as_fieldname_and_skip_file_numbering_true = \"/send_file_with_file_as_fieldname_and_skip_file_numbering_true\"\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is POST before going to check other features\n\t\tif r.Method != POST {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data\") {\n\t\t\tt.Error(\"Expected Header Content-Type -> multipart/form-data\", \"| but got\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tconst _24K = (1 << 20) * 24\n\t\terr := r.ParseMultipartForm(_24K)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error: %v\", err)\n\t\t}\n\t\tt.Logf(\"case %v \", r.URL.Path)\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case0_send_not_supported_filetype:\n\t\t\t// will be handled at place\n\t\tcase case1_send_string, case2_send_json, case3_integration_send_json_string:\n\t\t\tif len(r.MultipartForm.Value[\"query1\"]) != 1 {\n\t\t\t\tt.Error(\"Expected length of query1:test == 1\", \"| but got\", len(r.MultipartForm.Value[\"query1\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"query1\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query1:test\", \"| but got\", r.MultipartForm.Value[\"query1\"][0])\n\t\t\t}\n\t\t\tif len(r.MultipartForm.Value[\"query2\"]) != 1 {\n\t\t\t\tt.Error(\"Expected length of query2:test == 1\", \"| but got\", len(r.MultipartForm.Value[\"query2\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"query2\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query2:test\", \"| but got\", r.MultipartForm.Value[\"query2\"][0])\n\t\t\t}\n\t\tcase case4_set_query:\n\t\t\tv := r.URL.Query()\n\t\t\tif v[\"query1\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query1:test\", \"| but got\", v[\"query1\"][0])\n\t\t\t}\n\t\t\tif v[\"query2\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query2:test\", \"| but got\", v[\"query2\"][0])\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.Value[\"query1\"]; ok {\n\t\t\t\tt.Error(\"Expected no value\", \"| but got\", val)\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.Value[\"query2\"]; ok {\n\t\t\t\tt.Error(\"Expected no value\", \"| but got\", val)\n\t\t\t}\n\t\tcase case5_send_struct:\n\t\t\tif r.MultipartForm.Value[\"String\"][0] != \"a string\" {\n\t\t\t\tt.Error(\"Expected String:'a string'\", \"| but got\", r.MultipartForm.Value[\"String\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"Int\"][0] != \"42\" {\n\t\t\t\tt.Error(\"Expected Int:42\", \"| but got\", r.MultipartForm.Value[\"Int\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"Btrue\"][0] != \"true\" {\n\t\t\t\tt.Error(\"Expected Btrue:true\", \"| but got\", r.MultipartForm.Value[\"Btrue\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"Bfalse\"][0] != \"false\" {\n\t\t\t\tt.Error(\"Expected Btrue:false\", \"| but got\", r.MultipartForm.Value[\"Bfalse\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"Float\"][0] != \"12.345\" {\n\t\t\t\tt.Error(\"Expected Float:12.345\", \"| but got\", r.MultipartForm.Value[\"Float\"][0])\n\t\t\t}\n\t\t\tif len(r.MultipartForm.Value[\"StringArray\"]) != 2 {\n\t\t\t\tt.Error(\"Expected length of StringArray:2\", \"| but got\", len(r.MultipartForm.Value[\"StringArray\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"StringArray\"][0] != \"string1\" {\n\t\t\t\tt.Error(\"Expected StringArray:string1\", \"| but got\", r.MultipartForm.Value[\"StringArray\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"StringArray\"][1] != \"string2\" {\n\t\t\t\tt.Error(\"Expected StringArray:string2\", \"| but got\", r.MultipartForm.Value[\"StringArray\"][1])\n\t\t\t}\n\t\t\tif len(r.MultipartForm.Value[\"IntArray\"]) != 2 {\n\t\t\t\tt.Error(\"Expected length of IntArray:2\", \"| but got\", len(r.MultipartForm.Value[\"IntArray\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"IntArray\"][0] != \"1\" {\n\t\t\t\tt.Error(\"Expected IntArray:1\", \"| but got\", r.MultipartForm.Value[\"IntArray\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"IntArray\"][1] != \"2\" {\n\t\t\t\tt.Error(\"Expected IntArray:2\", \"| but got\", r.MultipartForm.Value[\"IntArray\"][1])\n\t\t\t}\n\t\t\tif len(r.MultipartForm.Value[\"BoolArray\"]) != 2 {\n\t\t\t\tt.Error(\"Expected length of BoolArray:2\", \"| but got\", len(r.MultipartForm.Value[\"BoolArray\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"BoolArray\"][0] != \"true\" {\n\t\t\t\tt.Error(\"Expected BoolArray:true\", \"| but got\", r.MultipartForm.Value[\"BoolArray\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"BoolArray\"][1] != \"false\" {\n\t\t\t\tt.Error(\"Expected BoolArray:false\", \"| but got\", r.MultipartForm.Value[\"BoolArray\"][1])\n\t\t\t}\n\t\t\tif len(r.MultipartForm.Value[\"FloatArray\"]) != 3 {\n\t\t\t\tt.Error(\"Expected length of FloatArray:3\", \"| but got\", len(r.MultipartForm.Value[\"FloatArray\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"FloatArray\"][0] != \"1.23\" {\n\t\t\t\tt.Error(\"Expected FloatArray:1.23\", \"| but got\", r.MultipartForm.Value[\"FloatArray\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"FloatArray\"][1] != \"4.56\" {\n\t\t\t\tt.Error(\"Expected FloatArray:4.56\", \"| but got\", r.MultipartForm.Value[\"FloatArray\"][1])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"FloatArray\"][2] != \"7.89\" {\n\t\t\t\tt.Error(\"Expected FloatArray:7.89\", \"| but got\", r.MultipartForm.Value[\"FloatArray\"][2])\n\t\t\t}\n\t\tcase case6_send_slice_string, case7_send_array:\n\t\t\tif len(r.MultipartForm.Value[\"data\"]) != 1 {\n\t\t\t\tt.Error(\"Expected length of data:JSON == 1\", \"| but got\", len(r.MultipartForm.Value[\"data\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"data\"][0] != `[\"string1\",\"string2\"]` {\n\t\t\t\tt.Error(`Expected 'data' with [\"string1\",\"string2\"]`, \"| but got\", r.MultipartForm.Value[\"data\"][0])\n\t\t\t}\n\t\tcase case6_send_slice_string_with_custom_fieldname:\n\t\t\tif len(r.MultipartForm.Value[\"my_custom_data\"]) != 1 {\n\t\t\t\tt.Error(\"Expected length of my_custom_data:JSON == 1\", \"| but got\", len(r.MultipartForm.Value[\"my_custom_data\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"my_custom_data\"][0] != `[\"string1\",\"string2\"]` {\n\t\t\t\tt.Error(`Expected 'my_custom_data' with [\"string1\",\"string2\"]`, \"| but got\", r.MultipartForm.Value[\"my_custom_data\"][0])\n\t\t\t}\n\t\tcase case8_integration_send_json_struct:\n\t\t\tif len(r.MultipartForm.Value[\"query1\"]) != 1 {\n\t\t\t\tt.Error(\"Expected length of query1:test == 1\", \"| but got\", len(r.MultipartForm.Value[\"query1\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"query1\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query1:test\", \"| but got\", r.MultipartForm.Value[\"query1\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"hey\"][0] != \"hey\" {\n\t\t\t\tt.Error(\"Expected hey:'hey'\", \"| but got\", r.MultipartForm.Value[\"Hey\"][0])\n\t\t\t}\n\t\tcase case9_send_duplicate_query_params:\n\t\t\tif len(r.MultipartForm.Value[\"param\"]) != 4 {\n\t\t\t\tt.Error(\"Expected length of param:[] == 4\", \"| but got\", len(r.MultipartForm.Value[\"param\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"param\"][0] != \"4\" {\n\t\t\t\tt.Error(\"Expected param:0:4\", \"| but got\", r.MultipartForm.Value[\"param\"][0])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"param\"][1] != \"3\" {\n\t\t\t\tt.Error(\"Expected param:1:3\", \"| but got\", r.MultipartForm.Value[\"param\"][1])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"param\"][2] != \"2\" {\n\t\t\t\tt.Error(\"Expected param:2:2\", \"| but got\", r.MultipartForm.Value[\"param\"][2])\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"param\"][3] != \"1\" {\n\t\t\t\tt.Error(\"Expected param:3:1\", \"| but got\", r.MultipartForm.Value[\"param\"][3])\n\t\t\t}\n\t\tcase case10_send_file_by_path, case11_send_file_by_path_without_name, case14_send_file_by_content_with_name, case20_send_file_as_osfile:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\tcase case10a_send_file_by_path_with_name, case10b_send_file_by_path_pointer, case21_send_file_as_osfile_with_name:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"MY_LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:MY_LICENSE\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\tcase case12_send_file_by_path_without_name_but_with_fieldname:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif _, ok := r.MultipartForm.File[\"my_fieldname\"]; !ok {\n\t\t\t\tkeys := reflect.ValueOf(r.MultipartForm.File).MapKeys()\n\t\t\t\tt.Error(\"Expected Fieldname:my_fieldname\", \"| but got\", keys)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"my_fieldname\"][0])\n\t\tcase case13_send_file_by_content_without_name, case13a_send_file_by_content_without_name_pointer:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"filename\" {\n\t\t\t\tt.Error(\"Expected Filename:filename\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\tcase case15_send_file_by_content_without_name_but_with_fieldname:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif _, ok := r.MultipartForm.File[\"my_fieldname\"]; !ok {\n\t\t\t\tkeys := reflect.ValueOf(r.MultipartForm.File).MapKeys()\n\t\t\t\tt.Error(\"Expected Fieldname:my_fieldname\", \"| but got\", keys)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Filename != \"filename\" {\n\t\t\t\tt.Error(\"Expected Filename:filename\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"my_fieldname\"][0])\n\t\tcase case16_send_file_by_content_with_name_and_with_fieldname, case22_send_file_as_osfile_with_name_and_with_fieldname:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif _, ok := r.MultipartForm.File[\"my_fieldname\"]; !ok {\n\t\t\t\tkeys := reflect.ValueOf(r.MultipartForm.File).MapKeys()\n\t\t\t\tt.Error(\"Expected Fieldname:my_fieldname\", \"| but got\", keys)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Filename != \"MY_LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:MY_LICENSE\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"my_fieldname\"][0])\n\t\tcase case17_send_file_multiple_by_path_and_content_without_name:\n\t\t\tif len(r.MultipartForm.File) != 2 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 2\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\t// depends on map iteration order\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"LICENSE\" && r.MultipartForm.File[\"file1\"][0].Filename != \"filename\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE||filename\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\t// depends on map iteration order\n\t\t\tif r.MultipartForm.File[\"file2\"][0].Filename != \"LICENSE\" && r.MultipartForm.File[\"file2\"][0].Filename != \"filename\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE||filename\", \"| but got\", r.MultipartForm.File[\"file2\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file2\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file2\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file2\"][0])\n\t\tcase case18_send_file_multiple_by_path_and_content_with_name:\n\t\t\tif len(r.MultipartForm.File) != 2 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 2\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\t// depends on map iteration order\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"LICENSE\" && r.MultipartForm.File[\"file1\"][0].Filename != \"MY_LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE||MY_LICENSE\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\t// depends on map iteration order\n\t\t\tif r.MultipartForm.File[\"file2\"][0].Filename != \"LICENSE\" && r.MultipartForm.File[\"file2\"][0].Filename != \"MY_LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE||MY_LICENSE\", \"| but got\", r.MultipartForm.File[\"file2\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file2\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file2\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file2\"][0])\n\t\tcase case19_integration_send_file_and_data:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"][0] != \"application/octet-stream\" {\n\t\t\t\tt.Error(\"Expected Header:Content-Type:application/octet-stream\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Header[\"Content-Type\"])\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\t\tif len(r.MultipartForm.Value[\"query1\"]) != 1 {\n\t\t\t\tt.Error(\"Expected length of query1:test == 1\", \"| but got\", len(r.MultipartForm.Value[\"query1\"]))\n\t\t\t}\n\t\t\tif r.MultipartForm.Value[\"query1\"][0] != \"test\" {\n\t\t\t\tt.Error(\"Expected query1:test\", \"| but got\", r.MultipartForm.Value[\"query1\"][0])\n\t\t\t}\n\t\tcase case23_send_file_with_file_as_fieldname:\n\t\t\tif len(r.MultipartForm.File) != 2 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 2\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.File[\"file1\"]; !ok {\n\t\t\t\tt.Error(\"Expected file with key: file1\", \"| but got \", val)\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.File[\"file2\"]; !ok {\n\t\t\t\tt.Error(\"Expected file with key: file2\", \"| but got \", val)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"b.file\" {\n\t\t\t\tt.Error(\"Expected Filename:b.file\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file2\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"file2\"][0].Filename)\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file2\"][0])\n\t\tcase case24_send_file_with_name_with_spaces, case25_send_file_with_name_with_spaces_only, case27_send_file_with_fieldname_with_spaces_only:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.File[\"file1\"]; !ok {\n\t\t\t\tt.Error(\"Expected file with key: file1\", \"| but got \", val)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file1\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"file1\"][0].Filename)\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"file1\"][0])\n\t\tcase case26_send_file_with_fieldname_with_spaces:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.File[\"my_fieldname\"]; !ok {\n\t\t\t\tt.Error(\"Expected file with key: my_fieldname\", \"| but got \", val)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"my_fieldname\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"my_fieldname\"][0].Filename)\n\t\t\t}\n\t\t\tcheckFile(t, r.MultipartForm.File[\"my_fieldname\"][0])\n\t\tcase case28_send_file_with_file_as_fieldname_and_skip_file_numbering_true:\n\t\t\tif len(r.MultipartForm.File) != 1 {\n\t\t\t\tt.Error(\"Expected length of files:[] == 1\", \"| but got\", len(r.MultipartForm.File))\n\t\t\t}\n\t\t\tif val, ok := r.MultipartForm.File[\"file\"]; !ok {\n\t\t\t\tt.Error(\"Expected file with key: file\", \"| but got \", val)\n\t\t\t}\n\t\t\tif r.MultipartForm.File[\"file\"][0].Filename != \"LICENSE\" {\n\t\t\t\tt.Error(\"Expected Filename:LICENSE\", \"| but got\", r.MultipartForm.File[\"file\"][0].Filename)\n\t\t\t}\n\t\t}\n\n\t}))\n\tdefer ts.Close()\n\n\t// \"the zero case\"\n\tt.Logf(\"case %v \", case0_send_not_supported_filetype)\n\t_, _, errs := New().Post(ts.URL + case0_send_not_supported_filetype).\n\t\tType(\"multipart\").\n\t\tSendFile(42).\n\t\tEnd()\n\n\tif len(errs) == 0 {\n\t\tt.Errorf(\"Expected error, but got nothing: %v\", errs)\n\t}\n\n\tNew().Post(ts.URL + case1_send_string).\n\t\tType(\"multipart\").\n\t\tSend(\"query1=test\").\n\t\tSend(\"query2=test\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + case2_send_json).\n\t\tType(\"multipart\").\n\t\tSend(`{\"query1\":\"test\"}`).\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case3_integration_send_json_string).\n\t\tType(\"multipart\").\n\t\tSend(\"query1=test\").\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case4_set_query).\n\t\tType(\"multipart\").\n\t\tQuery(\"query1=test\").\n\t\tQuery(\"query2=test\").\n\t\tSend(\"foo\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + case5_send_struct).\n\t\tType(\"multipart\").\n\t\tSend(testStruct{\n\t\t\tString:      \"a string\",\n\t\t\tInt:         42,\n\t\t\tBtrue:       true,\n\t\t\tBfalse:      false,\n\t\t\tFloat:       12.345,\n\t\t\tStringArray: []string{\"string1\", \"string2\"},\n\t\t\tIntArray:    []int{1, 2},\n\t\t\tBoolArray:   []bool{true, false},\n\t\t\tFloatArray:  []float64{1.23, 4.56, 7.89},\n\t\t}).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case6_send_slice_string).\n\t\tType(\"multipart\").\n\t\tSend([]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\tNew().Post(ts.URL+case6_send_slice_string_with_custom_fieldname).\n\t\tType(\"multipart\").\n\t\tSet(\"json_fieldname\", \"my_custom_data\").\n\t\tSend([]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case7_send_array).\n\t\tType(\"multipart\").\n\t\tSend([2]string{\"string1\", \"string2\"}).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case8_integration_send_json_struct).\n\t\tType(\"multipart\").\n\t\tSend(`{\"query1\":\"test\"}`).\n\t\tSend(heyYou{\n\t\t\tHey: \"hey\",\n\t\t}).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case9_send_duplicate_query_params).\n\t\tType(\"multipart\").\n\t\tSend(\"param=1\").\n\t\tSend(\"param=2\").\n\t\tSend(\"param=3&param=4\").\n\t\tEnd()\n\n\tfileByPath := \"./LICENSE\"\n\tNew().Post(ts.URL + case10_send_file_by_path).\n\t\tType(\"multipart\").\n\t\tSendFile(fileByPath).\n\t\tEnd()\n\n\tNew().Post(ts.URL+case10a_send_file_by_path_with_name).\n\t\tType(\"multipart\").\n\t\tSendFile(fileByPath, \"MY_LICENSE\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case10b_send_file_by_path_pointer).\n\t\tType(\"multipart\").\n\t\tSendFile(&fileByPath, \"MY_LICENSE\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case11_send_file_by_path_without_name).\n\t\tType(\"multipart\").\n\t\tSendFile(fileByPath, \"\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case12_send_file_by_path_without_name_but_with_fieldname).\n\t\tType(\"multipart\").\n\t\tSendFile(fileByPath, \"\", \"my_fieldname\").\n\t\tEnd()\n\n\tb, _ := ioutil.ReadFile(\"./LICENSE\")\n\tNew().Post(ts.URL + case13_send_file_by_content_without_name).\n\t\tType(\"multipart\").\n\t\tSendFile(b).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case13a_send_file_by_content_without_name_pointer).\n\t\tType(\"multipart\").\n\t\tSendFile(&b).\n\t\tEnd()\n\n\tNew().Post(ts.URL+case14_send_file_by_content_with_name).\n\t\tType(\"multipart\").\n\t\tSendFile(b, \"LICENSE\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case15_send_file_by_content_without_name_but_with_fieldname).\n\t\tType(\"multipart\").\n\t\tSendFile(b, \"\", \"my_fieldname\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case16_send_file_by_content_with_name_and_with_fieldname).\n\t\tType(\"multipart\").\n\t\tSendFile(b, \"MY_LICENSE\", \"my_fieldname\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + case17_send_file_multiple_by_path_and_content_without_name).\n\t\tType(\"multipart\").\n\t\tSendFile(\"./LICENSE\").\n\t\tSendFile(b).\n\t\tEnd()\n\n\tNew().Post(ts.URL+case18_send_file_multiple_by_path_and_content_with_name).\n\t\tType(\"multipart\").\n\t\tSendFile(\"./LICENSE\").\n\t\tSendFile(b, \"MY_LICENSE\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + case19_integration_send_file_and_data).\n\t\tType(\"multipart\").\n\t\tSendFile(\"./LICENSE\").\n\t\tSend(\"query1=test\").\n\t\tEnd()\n\n\tosFile, _ := os.Open(\"./LICENSE\")\n\tNew().Post(ts.URL + case20_send_file_as_osfile).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile).\n\t\tEnd()\n\n\tNew().Post(ts.URL+case21_send_file_as_osfile_with_name).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \"MY_LICENSE\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case22_send_file_as_osfile_with_name_and_with_fieldname).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \"MY_LICENSE\", \"my_fieldname\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case23_send_file_with_file_as_fieldname).\n\t\tType(\"multipart\").\n\t\tSendFile(b, \"b.file\").\n\t\tSendFile(osFile, \"\", \"file\").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case24_send_file_with_name_with_spaces).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \" LICENSE  \").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case25_send_file_with_name_with_spaces_only).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \"   \").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case26_send_file_with_fieldname_with_spaces).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \"\", \" my_fieldname  \").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case27_send_file_with_fieldname_with_spaces_only).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \"\", \"   \").\n\t\tEnd()\n\n\tNew().Post(ts.URL+case28_send_file_with_file_as_fieldname_and_skip_file_numbering_true).\n\t\tType(\"multipart\").\n\t\tSendFile(osFile, \"\", \"file\", true).\n\t\tEnd()\n}\n\n// testing for Patch method\nfunc TestPatch(t *testing.T) {\n\tconst case1_empty = \"/\"\n\tconst case2_set_header = \"/set_header\"\n\tconst case3_send_json = \"/send_json\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is PATCH before going to check other features\n\t\tif r.Method != PATCH {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", PATCH, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_empty:\n\t\t\tt.Logf(\"case %v \", case1_empty)\n\t\tcase case2_set_header:\n\t\t\tt.Logf(\"case %v \", case2_set_header)\n\t\t\tif r.Header.Get(\"API-Key\") != \"fookey\" {\n\t\t\t\tt.Errorf(\"Expected 'API-Key' == %q; got %q\", \"fookey\", r.Header.Get(\"API-Key\"))\n\t\t\t}\n\t\tcase case3_send_json:\n\t\t\tt.Logf(\"case %v \", case3_send_json)\n\t\t\tdefer r.Body.Close()\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tif string(body) != `{\"query1\":\"test\",\"query2\":\"test\"}` {\n\t\t\t\tt.Error(`Expected Body with {\"query1\":\"test\",\"query2\":\"test\"}`, \"| but got\", string(body))\n\t\t\t}\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Patch(ts.URL + case1_empty).\n\t\tEnd()\n\n\tNew().Patch(ts.URL+case2_set_header).\n\t\tSet(\"API-Key\", \"fookey\").\n\t\tEnd()\n\n\tNew().Patch(ts.URL + case3_send_json).\n\t\tSend(`{\"query1\":\"test\"}`).\n\t\tSend(`{\"query2\":\"test\"}`).\n\t\tEnd()\n}\n\nfunc checkQuery(t *testing.T, q map[string][]string, key string, want string) {\n\tv, ok := q[key]\n\tif !ok {\n\t\tt.Error(key, \"Not Found\")\n\t} else if len(v) < 1 {\n\t\tt.Error(\"No values for\", key)\n\t} else if v[0] != want {\n\t\tt.Errorf(\"Expected %v:%v | but got %v\", key, want, v[0])\n\t}\n\treturn\n}\n\n// TODO: more check on url query (all testcases)\nfunc TestQueryFunc(t *testing.T) {\n\tconst case1_send_string = \"/send_string\"\n\tconst case2_send_struct = \"/send_struct\"\n\tconst case3_send_string_with_duplicates = \"/send_string_with_duplicates\"\n\tconst case4_send_map = \"/send_map\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != POST {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tv := r.URL.Query()\n\n\t\tswitch r.URL.Path {\n\t\tdefault:\n\t\t\tt.Errorf(\"No testing for this case yet : %q\", r.URL.Path)\n\t\tcase case1_send_string, case2_send_struct:\n\t\t\tcheckQuery(t, v, \"query1\", \"test1\")\n\t\t\tcheckQuery(t, v, \"query2\", \"test2\")\n\t\tcase case3_send_string_with_duplicates:\n\t\t\tcheckQuery(t, v, \"query1\", \"test1\")\n\t\t\tcheckQuery(t, v, \"query2\", \"test2\")\n\n\t\t\tif len(v[\"param\"]) != 4 {\n\t\t\t\tt.Errorf(\"Expected Body with 4 params | but got %q\", len(v[\"param\"]))\n\t\t\t}\n\t\t\tif v[\"param\"][0] != \"1\" || v[\"param\"][1] != \"2\" || v[\"param\"][2] != \"3\" || v[\"param\"][3] != \"4\" {\n\t\t\t\tt.Error(\"Expected Body with 4 params and values\", \"| but got\", r.URL.RawQuery)\n\t\t\t}\n\t\tcase case4_send_map:\n\t\t\tcheckQuery(t, v, \"query1\", \"test1\")\n\t\t\tcheckQuery(t, v, \"query2\", \"test2\")\n\t\t\tcheckQuery(t, v, \"query3\", \"3.1415926\")\n\t\t\tcheckQuery(t, v, \"query4\", \"true\")\n\t\t}\n\t}))\n\tdefer ts.Close()\n\n\tNew().Post(ts.URL + case1_send_string).\n\t\tQuery(\"query1=test1\").\n\t\tQuery(\"query2=test2\").\n\t\tEnd()\n\n\tqq := struct {\n\t\tQuery1 string\n\t\tQuery2 string\n\t}{\n\t\tQuery1: \"test1\",\n\t\tQuery2: \"test2\",\n\t}\n\tNew().Post(ts.URL + case2_send_struct).\n\t\tQuery(qq).\n\t\tEnd()\n\n\tNew().Post(ts.URL + case3_send_string_with_duplicates).\n\t\tQuery(\"query1=test1\").\n\t\tQuery(\"query2=test2\").\n\t\tQuery(\"param=1\").\n\t\tQuery(\"param=2\").\n\t\tQuery(\"param=3&param=4\").\n\t\tEnd()\n\n\tNew().Post(ts.URL + case4_send_map).\n\t\tQuery(map[string]interface{}{\n\t\t\t\"query1\": \"test1\",\n\t\t\t\"query2\": \"test2\",\n\t\t\t\"query3\": 3.1415926,\n\t\t\t\"query4\": true,\n\t\t}).\n\t\tEnd()\n}\n\n// TODO: more tests on redirect\nfunc TestRedirectPolicyFunc(t *testing.T) {\n\tredirectSuccess := false\n\tredirectFuncGetCalled := false\n\ttsRedirect := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tredirectSuccess = true\n\t}))\n\tdefer tsRedirect.Close()\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, tsRedirect.URL, http.StatusMovedPermanently)\n\t}))\n\tdefer ts.Close()\n\n\tNew().\n\t\tGet(ts.URL).\n\t\tRedirectPolicy(func(req Request, via []Request) error {\n\t\t\tredirectFuncGetCalled = true\n\t\t\treturn nil\n\t\t}).End()\n\tif !redirectSuccess {\n\t\tt.Error(\"Expected reaching another redirect url not original one\")\n\t}\n\tif !redirectFuncGetCalled {\n\t\tt.Error(\"Expected redirect policy func to get called\")\n\t}\n}\n\nfunc TestEndBytes(t *testing.T) {\n\tserverOutput := \"hello world\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(serverOutput))\n\t}))\n\tdefer ts.Close()\n\n\t// Callback.\n\t{\n\t\tresp, bodyBytes, errs := New().Get(ts.URL).EndBytes(func(resp Response, body []byte, errs []error) {\n\t\t\tif len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"Unexpected errors: %s\", errs)\n\t\t\t}\n\t\t\tif resp.StatusCode != 200 {\n\t\t\t\tt.Fatalf(\"Expected StatusCode=200, actual StatusCode=%v\", resp.StatusCode)\n\t\t\t}\n\t\t\tif string(body) != serverOutput {\n\t\t\t\tt.Errorf(\"Expected bodyBytes=%s, actual bodyBytes=%s\", serverOutput, string(body))\n\t\t\t}\n\t\t})\n\t\tif len(errs) > 0 {\n\t\t\tt.Fatalf(\"Unexpected errors: %s\", errs)\n\t\t}\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Fatalf(\"Expected StatusCode=200, actual StatusCode=%v\", resp.StatusCode)\n\t\t}\n\t\tif string(bodyBytes) != serverOutput {\n\t\t\tt.Errorf(\"Expected bodyBytes=%s, actual bodyBytes=%s\", serverOutput, string(bodyBytes))\n\t\t}\n\t}\n\n\t// No callback.\n\t{\n\t\tresp, bodyBytes, errs := New().Get(ts.URL).EndBytes()\n\t\tif len(errs) > 0 {\n\t\t\tt.Errorf(\"Unexpected errors: %s\", errs)\n\t\t}\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Errorf(\"Expected StatusCode=200, actual StatusCode=%v\", resp.StatusCode)\n\t\t}\n\t\tif string(bodyBytes) != serverOutput {\n\t\t\tt.Errorf(\"Expected bodyBytes=%s, actual bodyBytes=%s\", serverOutput, string(bodyBytes))\n\t\t}\n\t}\n}\n\nfunc TestEndStruct(t *testing.T) {\n\tvar resStruct heyYou\n\texpStruct := heyYou{Hey: \"you\"}\n\tserverOutput, err := json.Marshal(expStruct)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected errors: %s\", err)\n\t}\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write(serverOutput)\n\t}))\n\tdefer ts.Close()\n\n\t// Callback.\n\t{\n\t\tresp, bodyBytes, errs := New().Get(ts.URL).EndStruct(func(resp Response, v interface{}, body []byte, errs []error) {\n\t\t\tif len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"Unexpected errors: %s\", errs)\n\t\t\t}\n\t\t\tif resp.StatusCode != 200 {\n\t\t\t\tt.Fatalf(\"Expected StatusCode=200, actual StatusCode=%v\", resp.StatusCode)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(expStruct, resStruct) {\n\t\t\t\tresBytes, _ := json.Marshal(resStruct)\n\t\t\t\tt.Errorf(\"Expected body=%s, actual bodyBytes=%s\", serverOutput, string(resBytes))\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(body, serverOutput) {\n\t\t\t\tt.Errorf(\"Expected bodyBytes=%s, actual bodyBytes=%s\", serverOutput, string(body))\n\t\t\t}\n\t\t})\n\t\tif len(errs) > 0 {\n\t\t\tt.Fatalf(\"Unexpected errors: %s\", errs)\n\t\t}\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Fatalf(\"Expected StatusCode=200, actual StatusCode=%v\", resp.StatusCode)\n\t\t}\n\t\tif !reflect.DeepEqual(bodyBytes, serverOutput) {\n\t\t\tt.Errorf(\"Expected bodyBytes=%s, actual bodyBytes=%s\", serverOutput, string(bodyBytes))\n\t\t}\n\t}\n\n\t// No callback.\n\t{\n\t\tresp, bodyBytes, errs := New().Get(ts.URL).EndStruct(&resStruct)\n\t\tif len(errs) > 0 {\n\t\t\tt.Errorf(\"Unexpected errors: %s\", errs)\n\t\t}\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Errorf(\"Expected StatusCode=200, actual StatusCode=%v\", resp.StatusCode)\n\t\t}\n\t\tif !reflect.DeepEqual(expStruct, resStruct) {\n\t\t\tresBytes, _ := json.Marshal(resStruct)\n\t\t\tt.Errorf(\"Expected body=%s, actual bodyBytes=%s\", serverOutput, string(resBytes))\n\t\t}\n\t\tif !reflect.DeepEqual(bodyBytes, serverOutput) {\n\t\t\tt.Errorf(\"Expected bodyBytes=%s, actual bodyBytes=%s\", serverOutput, string(bodyBytes))\n\t\t}\n\t}\n}\n\nfunc TestProxyFunc(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, \"proxy passed\")\n\t}))\n\tdefer ts.Close()\n\t// start proxy\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().DoFunc(\n\t\tfunc(r *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\treturn r, nil\n\t\t})\n\tts2 := httptest.NewServer(proxy)\n\t// sending request via Proxy\n\tresp, body, _ := New().Proxy(ts2.URL).Get(ts.URL).End()\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Expected 200 Status code\")\n\t}\n\tif body != \"proxy passed\" {\n\t\tt.Error(\"Expected 'proxy passed' body string\")\n\t}\n}\n\nfunc TestProxyFuncPostClone(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/proxy1\" {\n\t\t\tfmt.Fprint(w, \"proxy1 passed\")\n\t\t\treturn\n\t\t}\n\t\tif r.URL.Path == \"/proxy2\" {\n\t\t\tfmt.Fprint(w, \"proxy2 passed\")\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprint(w, \"proxy failed\")\n\t}))\n\tdefer ts.Close()\n\t// start proxy\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.OnRequest().DoFunc(\n\t\tfunc(r *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\tr.URL.Path = \"/proxy1\"\n\t\t\treturn r, nil\n\t\t})\n\tproxyTs := httptest.NewServer(proxy)\n\tdefer proxyTs.Close()\n\n\tproxy2 := goproxy.NewProxyHttpServer()\n\tproxy2.OnRequest().DoFunc(\n\t\tfunc(r *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\t\t\tr.URL.Path = \"/proxy2\"\n\t\t\treturn r, nil\n\t\t})\n\tproxy2Ts := httptest.NewServer(proxy2)\n\tdefer proxy2Ts.Close()\n\n\tbaseRequest := New().Proxy(proxyTs.URL)\n\t// sending request via Proxy\n\tresp1, body1, _ := baseRequest.Clone().Proxy(proxy2Ts.URL).Get(ts.URL).End()\n\tif resp1.StatusCode != 200 {\n\t\tt.Error(\"Expected 200 Status code\")\n\t}\n\tif body1 != \"proxy2 passed\" {\n\t\tt.Error(\"Expected 'proxy2 passed' body1 string\")\n\t}\n\t// sending request via Proxy\n\tresp2, body2, _ := baseRequest.Clone().Get(ts.URL).End()\n\tif resp2.StatusCode != 200 {\n\t\tt.Error(\"Expected 200 Status code\")\n\t}\n\tif body2 != \"proxy1 passed\" {\n\t\tt.Error(\"Expected 'proxy1 passed' body2 string\")\n\t}\n}\n\nfunc TestTimeoutFunc(t *testing.T) {\n\t// 1st case, dial timeout\n\tstartTime := time.Now()\n\t_, _, errs := New().Timeout(1000 * time.Millisecond).Get(\"http://www.google.com:81\").End()\n\telapsedTime := time.Since(startTime)\n\tif errs == nil {\n\t\tt.Error(\"Expected dial timeout error but get nothing\")\n\t}\n\tif elapsedTime < 1000*time.Millisecond || elapsedTime > 1500*time.Millisecond {\n\t\tt.Errorf(\"Expected timeout in between 1000 -> 1500 ms | but got %d\", elapsedTime)\n\t}\n\t// 2st case, read/write timeout (Can dial to url but want to timeout because too long operation on the server)\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(1100 * time.Millisecond) // slightly longer than expected\n\t\tw.WriteHeader(200)\n\t}))\n\trequest := New().Timeout(1000 * time.Millisecond)\n\tstartTime = time.Now()\n\t_, _, errs = request.Get(ts.URL).End()\n\telapsedTime = time.Since(startTime)\n\tif errs == nil {\n\t\tt.Error(\"Expected dial+read/write timeout | but get nothing\")\n\t}\n\tif elapsedTime < 1000*time.Millisecond || elapsedTime > 1500*time.Millisecond {\n\t\tt.Errorf(\"Expected timeout in between 1000 -> 1500 ms | but got %d\", elapsedTime)\n\t}\n\t// 3rd case, testing reuse of same request\n\tts = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(1100 * time.Millisecond) // slightly longer than expected\n\t\tw.WriteHeader(200)\n\t}))\n\tstartTime = time.Now()\n\t_, _, errs = request.Get(ts.URL).End()\n\telapsedTime = time.Since(startTime)\n\tif errs == nil {\n\t\tt.Error(\"Expected dial+read/write timeout | but get nothing\")\n\t}\n\tif elapsedTime < 1000*time.Millisecond || elapsedTime > 1500*time.Millisecond {\n\t\tt.Errorf(\"Expected timeout in between 1000 -> 1500 ms | but got %d\", elapsedTime)\n\t}\n\n}\n\nfunc TestCookies(t *testing.T) {\n\trequest := New().Timeout(60 * time.Second)\n\t_, _, errs := request.Get(\"https://github.com\").End()\n\tif errs != nil {\n\t\tt.Error(\"Cookies test request did not complete\")\n\t\treturn\n\t}\n\tdomain, _ := url.Parse(\"https://github.com\")\n\tif len(request.Client.Jar.Cookies(domain)) == 0 {\n\t\tt.Error(\"Expected cookies | but get nothing\")\n\t}\n}\n\nfunc TestGetSetCookie(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\t\tc, err := r.Cookie(\"API-Cookie-Name\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif c == nil {\n\t\t\tt.Error(\"Expected non-nil request Cookie 'API-Cookie-Name'\")\n\t\t} else if c.Value != \"api-cookie-value\" {\n\t\t\tt.Errorf(\"Expected 'API-Cookie-Name' == %q; got %q\", \"api-cookie-value\", c.Value)\n\t\t}\n\t}))\n\tdefer ts.Close()\n\n\tNew().Get(ts.URL).\n\t\tAddCookie(&http.Cookie{Name: \"API-Cookie-Name\", Value: \"api-cookie-value\"}).\n\t\tEnd()\n}\n\nfunc TestGetSetCookies(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != GET {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", GET, r.Method)\n\t\t}\n\t\tc, err := r.Cookie(\"API-Cookie-Name1\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif c == nil {\n\t\t\tt.Error(\"Expected non-nil request Cookie 'API-Cookie-Name1'\")\n\t\t} else if c.Value != \"api-cookie-value1\" {\n\t\t\tt.Errorf(\"Expected 'API-Cookie-Name1' == %q; got %q\", \"api-cookie-value1\", c.Value)\n\t\t}\n\t\tc, err = r.Cookie(\"API-Cookie-Name2\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif c == nil {\n\t\t\tt.Error(\"Expected non-nil request Cookie 'API-Cookie-Name2'\")\n\t\t} else if c.Value != \"api-cookie-value2\" {\n\t\t\tt.Errorf(\"Expected 'API-Cookie-Name2' == %q; got %q\", \"api-cookie-value2\", c.Value)\n\t\t}\n\t}))\n\tdefer ts.Close()\n\n\tNew().Get(ts.URL).AddCookies([]*http.Cookie{\n\t\t{Name: \"API-Cookie-Name1\", Value: \"api-cookie-value1\"},\n\t\t{Name: \"API-Cookie-Name2\", Value: \"api-cookie-value2\"},\n\t}).End()\n}\n\nfunc TestErrorTypeWrongKey(t *testing.T) {\n\t//defer afterTest(t)\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, checkTypeWrongKey\")\n\t}))\n\tdefer ts.Close()\n\n\t_, _, err := New().\n\t\tGet(ts.URL).\n\t\tType(\"wrongtype\").\n\t\tEnd()\n\tif len(err) != 0 {\n\t\tif err[0].Error() != \"Type func: incorrect type \\\"wrongtype\\\"\" {\n\t\t\tt.Errorf(\"Wrong error message: \" + err[0].Error())\n\t\t}\n\t} else {\n\t\tt.Error(\"Should have error\")\n\t}\n}\n\n// expect the first clone to result in an erro\n// the second clone should succeed\nfunc TestErrorThenReUseBase(t *testing.T) {\n\t//defer afterTest(t)\n\trequestCount := 0\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tif requestCount == 1 {\n\t\t\tfmt.Fprintln(w, \"Hello, checkTypeWrongKey\")\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer ts.Close()\n\n\tbaseRequest := New()\n\t_, _, err := baseRequest.Clone().\n\t\tGet(ts.URL).\n\t\tType(\"wrongtype\").\n\t\tEnd()\n\tif len(err) != 0 {\n\t\tif err[0].Error() != \"Type func: incorrect type \\\"wrongtype\\\"\" {\n\t\t\tt.Errorf(\"Wrong error message: \" + err[0].Error())\n\t\t}\n\t} else {\n\t\tt.Error(\"Should have error\")\n\t}\n\n\t_, _, err = baseRequest.Clone().\n\t\tGet(ts.URL).\n\t\tEnd()\n\tif len(err) != 0 {\n\t\tt.Errorf(\"Expected No error %v\", err)\n\t}\n}\n\nfunc TestBasicAuth(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header[\"Authorization\"][0], \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tt.Error(\"bad syntax\")\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif pair[0] != \"myusername\" || pair[1] != \"mypassword\" {\n\t\t\tt.Error(\"Wrong username/password\")\n\t\t}\n\t}))\n\tdefer ts.Close()\n\tNew().Post(ts.URL).\n\t\tSetBasicAuth(\"myusername\", \"mypassword\").\n\t\tEnd()\n}\n\nfunc TestBasicAuthCloneToDifferentAuths(t *testing.T) {\n\trequestCount := 0\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tauth := strings.SplitN(r.Header[\"Authorization\"][0], \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tt.Error(\"bad syntax\")\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif requestCount == 1 {\n\t\t\tif pair[0] != \"myusername\" || pair[1] != \"mypassword\" {\n\t\t\t\tt.Error(\"Wrong username/password\")\n\t\t\t}\n\t\t} else {\n\t\t\tif pair[0] != \"request2\" || pair[1] != \"request2passowrd\" {\n\t\t\t\tt.Error(\"Wrong username/password\")\n\t\t\t}\n\t\t}\n\t}))\n\tdefer ts.Close()\n\tbaseRequest := New()\n\tbaseRequest.Clone().\n\t\tPost(ts.URL).\n\t\tSetBasicAuth(\"myusername\", \"mypassword\").\n\t\tEnd()\n\n\tbaseRequest.Clone().\n\t\tPost(ts.URL).\n\t\tSetBasicAuth(\"request2\", \"request2passowrd\").\n\t\tEnd()\n}\n\nfunc TestBasicAuthCloneReuseAuth(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header[\"Authorization\"][0], \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tt.Error(\"bad syntax\")\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif pair[0] != \"myusername\" || pair[1] != \"mypassword\" {\n\t\t\tt.Error(\"Wrong username/password\")\n\t\t}\n\t}))\n\tdefer ts.Close()\n\tbaseRequest := New().\n\t\tSetBasicAuth(\"myusername\", \"mypassword\")\n\tbaseRequest.Clone().\n\t\tPost(ts.URL).\n\t\tEnd()\n\n\tbaseRequest.Clone().\n\t\tPost(ts.URL).\n\t\tEnd()\n}\n\nfunc TestBasicAuthCloneOverrideAuth(t *testing.T) {\n\trequestCount := 0\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tauth := strings.SplitN(r.Header[\"Authorization\"][0], \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tt.Error(\"bad syntax\")\n\t\t}\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif requestCount == 1 {\n\t\t\tif pair[0] != \"request1\" || pair[1] != \"request1passowrd\" {\n\t\t\t\tt.Error(\"Wrong username/password\")\n\t\t\t}\n\t\t} else {\n\t\t\tif pair[0] != \"myusername\" || pair[1] != \"mypassword\" {\n\t\t\t\tt.Error(\"Wrong username/password\")\n\t\t\t}\n\t\t}\n\t}))\n\tdefer ts.Close()\n\tbaseRequest := New().\n\t\tSetBasicAuth(\"myusername\", \"mypassword\")\n\tbaseRequest.Clone().\n\t\tPost(ts.URL).\n\t\tSetBasicAuth(\"request1\", \"request1passowrd\").\n\t\tEnd()\n\n\tbaseRequest.Clone().\n\t\tPost(ts.URL).\n\t\tEnd()\n}\n\nfunc TestXml(t *testing.T) {\n\txml := `<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>`\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is PATCH before going to check other features\n\t\tif r.Method != POST {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\n\t\tif r.Header.Get(\"Content-Type\") != \"application/xml\" {\n\t\t\tt.Error(\"Expected Header Content-Type -> application/xml\", \"| but got\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\n\t\tdefer r.Body.Close()\n\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\tif string(body) != xml {\n\t\t\tt.Error(`Expected XML `, xml, \"| but got\", string(body))\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Post(ts.URL).\n\t\tType(\"xml\").\n\t\tSend(xml).\n\t\tEnd()\n\n\tNew().Post(ts.URL).\n\t\tSet(\"Content-Type\", \"application/xml\").\n\t\tSend(xml).\n\t\tEnd()\n}\n\nfunc TestPlainText(t *testing.T) {\n\ttext := `hello world \\r\\n I am GoRequest`\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is PATCH before going to check other features\n\t\tif r.Method != POST {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tif r.Header.Get(\"Content-Type\") != \"text/plain\" {\n\t\t\tt.Error(\"Expected Header Content-Type -> text/plain\", \"| but got\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\n\t\tdefer r.Body.Close()\n\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\tif string(body) != text {\n\t\t\tt.Error(`Expected text `, text, \"| but got\", string(body))\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Post(ts.URL).\n\t\tType(\"text\").\n\t\tSend(text).\n\t\tEnd()\n\n\tNew().Post(ts.URL).\n\t\tSet(\"Content-Type\", \"text/plain\").\n\t\tSend(text).\n\t\tEnd()\n}\n\n// TestContentTypeInference tests that the ContentType header is set\n// properly when a custom override is provided using AppendHeader\n// or Set methods.\n// https://github.com/parnurzeal/gorequest/issues/164\nfunc TestContentTypeInference(t *testing.T) {\n\tvar tests = []struct {\n\t\tcustomContentType string\n\t\t//type is reserved keyword\n\t\tType           string\n\t\texpectedHeader string\n\t\tbody           string\n\t}{\n\t\t{\"application/json\", \"json\", \"application/json\", \"{}\"},\n\t\t{\"\", \"json\", \"\", \"\"},\n\t\t{\"\", \"json\", \"\", \"{}\"},\n\t\t{\"text/json\", \"json\", \"text/json\", \"{}\"},\n\t\t{\"text/xml\", \"json\", \"text/xml\", \"<a />\"},\n\t}\n\tfor _, test := range tests {\n\t\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// check method is PATCH before going to check other features\n\t\t\tif r.Method != POST {\n\t\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t\t}\n\t\t\tif r.Header == nil {\n\t\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t\t}\n\t\t\tif r.Header.Get(\"Content-Type\") != test.expectedHeader {\n\t\t\t\tt.Errorf(\"Expected Header Content-Type -> %q | but got %q\", test.expectedHeader, r.Header.Get(\"Content-Type\"))\n\t\t\t}\n\t\t}))\n\n\t\tNew().Post(ts.URL).\n\t\t\tSet(\"Content-Type\", test.customContentType).\n\t\t\tType(test.Type).\n\t\t\tSend(test.body).\n\t\t\tEnd()\n\t\tNew().Post(ts.URL).\n\t\t\tSet(\"cOnTent-tYpE\", test.customContentType).\n\t\t\tType(test.Type).\n\t\t\tSend(test.body).\n\t\t\tEnd()\n\t\tNew().Post(ts.URL).\n\t\t\tAppendHeader(\"Content-Type\", test.customContentType).\n\t\t\tType(test.Type).\n\t\t\tSend(test.body).\n\t\t\tEnd()\n\t\tts.Close()\n\t}\n}\n\n// Test for request can accept multiple types.\nfunc TestAcceptMultipleTypes(t *testing.T) {\n\ttext := `hello world \\r\\n I am GoRequest`\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// check method is PATCH before going to check other features\n\t\tif r.Method != POST {\n\t\t\tt.Errorf(\"Expected method %q; got %q\", POST, r.Method)\n\t\t}\n\t\tif r.Header == nil {\n\t\t\tt.Error(\"Expected non-nil request Header\")\n\t\t}\n\t\tif r.Header.Get(\"Content-Type\") != \"text/plain\" {\n\t\t\tt.Error(\"Expected Header Content-Type -> text/plain\", \"| but got\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\n\t\texpectedAccepts := []string{\"text/plain\", \"application/json\"}\n\t\tif strings.Join(r.Header[\"Accept\"], \", \") != strings.Join(expectedAccepts, \", \") {\n\t\t\tt.Error(\"Expected Header Accept -> \", expectedAccepts, \"| but got\", r.Header[\"Accept\"])\n\t\t}\n\n\t\tdefer r.Body.Close()\n\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\tif string(body) != text {\n\t\t\tt.Error(`Expected text `, text, \"| but got\", string(body))\n\t\t}\n\t}))\n\n\tdefer ts.Close()\n\n\tNew().Post(ts.URL).\n\t\tAppendHeader(\"Accept\", \"text/plain\").\n\t\tAppendHeader(\"Accept\", \"application/json\").\n\t\tType(\"text\").\n\t\tSend(text).\n\t\tEnd()\n\n\tNew().Post(ts.URL).\n\t\tSet(\"Accept\", \"text/plain\").\n\t\tAppendHeader(\"Accept\", \"application/json\").\n\t\tSet(\"Content-Type\", \"text/plain\").\n\t\tSend(text).\n\t\tEnd()\n\n\tNew().Post(ts.URL).\n\t\tAppendHeader(\"Accept\", \"texxt/html\"). // This will be overwritten by Set(\"Accept\")\n\t\tSet(\"Accept\", \"text/plain\").\n\t\tAppendHeader(\"Accept\", \"application/json\").\n\t\tType(\"text\").\n\t\tSend(text).\n\t\tEnd()\n}\n\nfunc TestAsCurlCommand(t *testing.T) {\n\tvar (\n\t\tendpoint = \"http://github.com/parnurzeal/gorequest\"\n\t\tjsonData = `{\"here\": \"is\", \"some\": {\"json\": [\"data\"]}}`\n\t)\n\n\trequest := New().Timeout(10*time.Second).Put(endpoint).Set(\"Content-Type\", \"application/json\").Send(jsonData)\n\n\tcurlComand, err := request.AsCurlCommand()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := fmt.Sprintf(`curl -X 'PUT' -d '%v' -H 'Content-Type: application/json' '%v'`, strings.Replace(jsonData, \" \", \"\", -1), endpoint)\n\tif curlComand != expected {\n\t\tt.Fatalf(\"\\nExpected curlCommand=%v\\n   but actual result=%v\", expected, curlComand)\n\t}\n}\n\nfunc TestSetDebugByEnvironmentVar(t *testing.T) {\n\tendpoint := \"http://github.com/parnurzeal/gorequest\"\n\n\tvar buf bytes.Buffer\n\tlogger := log.New(&buf, \"[gorequest]\", log.LstdFlags)\n\n\tos.Setenv(\"GOREQUEST_DEBUG\", \"1\")\n\tNew().SetLogger(logger).Get(endpoint).End()\n\n\tif len(buf.String()) == 0 {\n\t\tt.Fatalf(\"\\nExpected gorequest to log request and response object if GOREQUEST_DEBUG=1\")\n\t}\n\n\tos.Setenv(\"GOREQUEST_DEBUG\", \"\")\n\tbuf.Reset()\n\n\tNew().SetLogger(logger).Get(endpoint).End()\n\n\tif len(buf.String()) > 0 {\n\t\tt.Fatalf(\"\\nExpected gorequest not to log request and response object if GOREQUEST_DEBUG is not set.\")\n\t}\n}\n\nfunc TestContenxt(t *testing.T) {\n\t// requesting a long connection which block this requst for a time,\n\t// but 2 seconds later we unable to hold ourself back and force close it\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo New().Context(ctx).Get(\"http://127.0.0.1:8080/foo\").EndBytes(func(response Response, body []byte, errs []error) {\n\n\n\t\tif len(errs) > 0 {\n\t\t\tfmt.Printf(\"%+v\\n\", errs[0])\n\t\t}\n\t\tfmt.Println(string(body))\n\t})\n\n\tselect {\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"cancel...\")\n\t\tcancel()\n\t}\n}\n"
        },
        {
          "name": "gorequest_transport_go1.2.go",
          "type": "blob",
          "size": 0.7177734375,
          "content": "// +build go1.2\r\n// +build !go1.3\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net/http\"\r\n)\r\n\r\n// does a shallow clone of the transport\r\nfunc (s *SuperAgent) safeModifyTransport() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldTransport := s.Transport\r\n    s.Transport = &http.Transport{\r\n        Proxy:                  oldTransport.Proxy,\r\n        Dial:                   oldTransport.Dial,\r\n        TLSClientConfig:        oldTransport.TLSClientConfig,\r\n        DisableKeepAlives:      oldTransport.DisableKeepAlives,\r\n        DisableCompression:     oldTransport.DisableCompression,\r\n        MaxIdleConnsPerHost:    oldTransport.MaxIdleConnsPerHost,\r\n        ResponseHeaderTimeout:  oldTransport.ResponseHeaderTimeout,\r\n    }\r\n}\r\n"
        },
        {
          "name": "gorequest_transport_go1.3.go",
          "type": "blob",
          "size": 0.8056640625,
          "content": "// +build go1.3\r\n// +build !go1.4\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net/http\"\r\n)\r\n\r\n// does a shallow clone of the transport\r\nfunc (s *SuperAgent) safeModifyTransport() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldTransport := s.Transport\r\n    s.Transport = &http.Transport{\r\n        Proxy:                  oldTransport.Proxy,\r\n        Dial:                   oldTransport.Dial,\r\n        TLSClientConfig:        oldTransport.TLSClientConfig,\r\n        DisableKeepAlives:      oldTransport.DisableKeepAlives,\r\n        DisableCompression:     oldTransport.DisableCompression,\r\n        MaxIdleConnsPerHost:    oldTransport.MaxIdleConnsPerHost,\r\n        ResponseHeaderTimeout:  oldTransport.ResponseHeaderTimeout,\r\n        // new in 1.3\r\n        TLSHandshakeTimeout:    oldTransport.TLSHandshakeTimeout,\r\n    }\r\n}\r\n"
        },
        {
          "name": "gorequest_transport_go1.4.go",
          "type": "blob",
          "size": 0.861328125,
          "content": "// +build go1.4\r\n// +build !go1.6\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net/http\"\r\n)\r\n\r\n// does a shallow clone of the transport\r\nfunc (s *SuperAgent) safeModifyTransport() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldTransport := s.Transport\r\n    s.Transport = &http.Transport{\r\n        Proxy:                  oldTransport.Proxy,\r\n        Dial:                   oldTransport.Dial,\r\n        TLSClientConfig:        oldTransport.TLSClientConfig,\r\n        TLSHandshakeTimeout:    oldTransport.TLSHandshakeTimeout,\r\n        DisableKeepAlives:      oldTransport.DisableKeepAlives,\r\n        DisableCompression:     oldTransport.DisableCompression,\r\n        MaxIdleConnsPerHost:    oldTransport.MaxIdleConnsPerHost,\r\n        ResponseHeaderTimeout:  oldTransport.ResponseHeaderTimeout,\r\n        // new in go1.4\r\n        DialTLS:                oldTransport.DialTLS,\r\n    }\r\n}\r\n"
        },
        {
          "name": "gorequest_transport_go1.6.go",
          "type": "blob",
          "size": 0.9853515625,
          "content": "// +build go1.6\r\n// +build !go1.7\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net/http\"\r\n)\r\n\r\n// does a shallow clone of the transport\r\nfunc (s *SuperAgent) safeModifyTransport() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldTransport := s.Transport\r\n    s.Transport = &http.Transport{\r\n        Proxy:                  oldTransport.Proxy,\r\n        Dial:                   oldTransport.Dial,\r\n        DialTLS:                oldTransport.DialTLS,\r\n        TLSClientConfig:        oldTransport.TLSClientConfig,\r\n        TLSHandshakeTimeout:    oldTransport.TLSHandshakeTimeout,\r\n        DisableKeepAlives:      oldTransport.DisableKeepAlives,\r\n        DisableCompression:     oldTransport.DisableCompression,\r\n        MaxIdleConnsPerHost:    oldTransport.MaxIdleConnsPerHost,\r\n        ResponseHeaderTimeout:  oldTransport.ResponseHeaderTimeout,\r\n        // new in 1.6\r\n        ExpectContinueTimeout:  oldTransport.ExpectContinueTimeout,\r\n        TLSNextProto:           oldTransport.TLSNextProto,\r\n    }\r\n}\r\n"
        },
        {
          "name": "gorequest_transport_go1.7.go",
          "type": "blob",
          "size": 1.2333984375,
          "content": "// +build go1.7\r\n// +build !go1.8\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net/http\"\r\n)\r\n\r\n// does a shallow clone of the transport\r\nfunc (s *SuperAgent) safeModifyTransport() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldTransport := s.Transport\r\n    s.Transport = &http.Transport{\r\n        Proxy:                  oldTransport.Proxy,\r\n        Dial:                   oldTransport.Dial,\r\n        DialTLS:                oldTransport.DialTLS,\r\n        TLSClientConfig:        oldTransport.TLSClientConfig,\r\n        TLSHandshakeTimeout:    oldTransport.TLSHandshakeTimeout,\r\n        DisableKeepAlives:      oldTransport.DisableKeepAlives,\r\n        DisableCompression:     oldTransport.DisableCompression,\r\n        MaxIdleConns:           oldTransport.MaxIdleConns,\r\n        MaxIdleConnsPerHost:    oldTransport.MaxIdleConnsPerHost,\r\n        ResponseHeaderTimeout:  oldTransport.ResponseHeaderTimeout,\r\n        ExpectContinueTimeout:  oldTransport.ExpectContinueTimeout,\r\n        TLSNextProto:           oldTransport.TLSNextProto,\r\n        // new in go1.7\r\n        DialContext:            oldTransport.DialContext,\r\n        IdleConnTimeout:        oldTransport.IdleConnTimeout,\r\n        MaxResponseHeaderBytes: oldTransport.MaxResponseHeaderBytes,\r\n    }\r\n}\r\n"
        },
        {
          "name": "gorequest_transport_go1.8.go",
          "type": "blob",
          "size": 1.2802734375,
          "content": "// +build go1.8\r\n\r\npackage gorequest\r\n\r\nimport (\r\n    \"net/http\"\r\n)\r\n\r\n// does a shallow clone of the transport\r\nfunc (s *SuperAgent) safeModifyTransport() {\r\n    if !s.isClone {\r\n        return\r\n    }\r\n    oldTransport := s.Transport\r\n    s.Transport = &http.Transport{\r\n        Proxy:                  oldTransport.Proxy,\r\n        DialContext:            oldTransport.DialContext,\r\n        Dial:                   oldTransport.Dial,\r\n        DialTLS:                oldTransport.DialTLS,\r\n        TLSClientConfig:        oldTransport.TLSClientConfig,\r\n        TLSHandshakeTimeout:    oldTransport.TLSHandshakeTimeout,\r\n        DisableKeepAlives:      oldTransport.DisableKeepAlives,\r\n        DisableCompression:     oldTransport.DisableCompression,\r\n        MaxIdleConns:           oldTransport.MaxIdleConns,\r\n        MaxIdleConnsPerHost:    oldTransport.MaxIdleConnsPerHost,\r\n        IdleConnTimeout:        oldTransport.IdleConnTimeout,\r\n        ResponseHeaderTimeout:  oldTransport.ResponseHeaderTimeout,\r\n        ExpectContinueTimeout:  oldTransport.ExpectContinueTimeout,\r\n        TLSNextProto:           oldTransport.TLSNextProto,\r\n        MaxResponseHeaderBytes: oldTransport.MaxResponseHeaderBytes,\r\n        // new in go1.8\r\n        ProxyConnectHeader:     oldTransport.ProxyConnectHeader,\r\n    }\r\n}\r\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.12890625,
          "content": "package gorequest\n\ntype Logger interface {\n\tSetPrefix(string)\n\tPrintf(format string, v ...interface{})\n\tPrintln(v ...interface{})\n}\n"
        }
      ]
    }
  ]
}