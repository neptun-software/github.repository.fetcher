{
  "metadata": {
    "timestamp": 1736566808638,
    "page": 373,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "opentracing/opentracing-go",
      "stars": 3494,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0126953125,
          "content": "coverage.txt\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.064453125,
          "content": "linters-settings:\n  staticcheck:\n    checks: [ \"all\", \"-SA1019\" ]\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.58203125,
          "content": "Changes by Version\n==================\n\n\n1.2.0 (2020-07-01)\n-------------------\n\n* Restore the ability to reset the current span in context to nil (#231) -- Yuri Shkuro\n* Use error.object per OpenTracing Semantic Conventions (#179) -- Rahman Syed\n* Convert nil pointer log field value to string \"nil\" (#230) -- Cyril Tovena\n* Add Go module support (#215) -- Zaba505\n* Make SetTag helper types in ext public (#229) -- Blake Edwards\n* Add log/fields helpers for keys from specification (#226) -- Dmitry Monakhov\n* Improve noop impementation (#223) -- chanxuehong\n* Add an extension to Tracer interface for custom go context creation (#220) -- Krzesimir Nowak\n* Fix typo in comments (#222) -- meteorlxy\n* Improve documentation for log.Object() to emphasize the requirement to pass immutable arguments (#219) -- 疯狂的小企鹅\n* [mock] Return ErrInvalidSpanContext if span context is not MockSpanContext (#216) -- Milad Irannejad\n\n\n1.1.0 (2019-03-23)\n-------------------\n\nNotable changes:\n- The library is now released under Apache 2.0 license\n- Use Set() instead of Add() in HTTPHeadersCarrier is functionally a breaking change (fixes issue [#159](https://github.com/opentracing/opentracing-go/issues/159))\n- 'golang.org/x/net/context' is replaced with 'context' from the standard library\n\nList of all changes:\n\n- Export StartSpanFromContextWithTracer (#214) <Aaron Delaney>\n- Add IsGlobalTracerRegistered() to indicate if a tracer has been registered (#201) <Mike Goldsmith>\n- Use Set() instead of Add() in HTTPHeadersCarrier (#191) <jeremyxu2010>\n- Update license to Apache 2.0 (#181) <Andrea Kao>\n- Replace 'golang.org/x/net/context' with 'context' (#176) <Tony Ghita>\n- Port of Python opentracing/harness/api_check.py to Go (#146) <chris erway>\n- Fix race condition in MockSpan.Context() (#170) <Brad>\n- Add PeerHostIPv4.SetString() (#155)  <NeoCN>\n- Add a Noop log field type to log to allow for optional fields (#150)  <Matt Ho>\n\n\n1.0.2 (2017-04-26)\n-------------------\n\n- Add more semantic tags (#139) <Rustam Zagirov>\n\n\n1.0.1 (2017-02-06)\n-------------------\n\n- Correct spelling in comments <Ben Sigelman>\n- Address race in nextMockID() (#123) <bill fumerola>\n- log: avoid panic marshaling nil error (#131) <Anthony Voutas>\n- Deprecate InitGlobalTracer in favor of SetGlobalTracer (#128) <Yuri Shkuro>\n- Drop Go 1.5 that fails in Travis (#129) <Yuri Shkuro>\n- Add convenience methods Key() and Value() to log.Field <Ben Sigelman>\n- Add convenience methods to log.Field (2 years, 6 months ago) <Radu Berinde>\n\n1.0.0 (2016-09-26)\n-------------------\n\n- This release implements OpenTracing Specification 1.0 (https://opentracing.io/spec)\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0869140625,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2016 The OpenTracing Authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3759765625,
          "content": ".DEFAULT_GOAL := test-and-lint\n\n.PHONY: test-and-lint\ntest-and-lint: test lint\n\n.PHONY: test\ntest:\n\tgo test -v -cover -race ./...\n\n.PHONY: cover\ncover:\n\tgo test -v -coverprofile=coverage.txt -covermode=atomic -race ./...\n\n.PHONY: lint\nlint:\n\tgo fmt ./...\n\tgolint ./...\n\t@# Run again with magic to exit non-zero if golint outputs anything.\n\t@! (golint ./... | read dummy)\n\tgo vet ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.6025390625,
          "content": "[![Gitter chat](http://img.shields.io/badge/gitter-join%20chat%20%E2%86%92-brightgreen.svg)](https://gitter.im/opentracing/public) [![Build Status](https://travis-ci.org/opentracing/opentracing-go.svg?branch=master)](https://travis-ci.org/opentracing/opentracing-go) [![GoDoc](https://godoc.org/github.com/opentracing/opentracing-go?status.svg)](http://godoc.org/github.com/opentracing/opentracing-go)\n[![Sourcegraph Badge](https://sourcegraph.com/github.com/opentracing/opentracing-go/-/badge.svg)](https://sourcegraph.com/github.com/opentracing/opentracing-go?badge)\n\n# OpenTracing API for Go\n\nThis package is a Go platform API for OpenTracing.\n\n## Required Reading\n\nIn order to understand the Go platform API, one must first be familiar with the\n[OpenTracing project](https://opentracing.io) and\n[terminology](https://opentracing.io/specification/) more specifically.\n\n## API overview for those adding instrumentation\n\nEveryday consumers of this `opentracing` package really only need to worry\nabout a couple of key abstractions: the `StartSpan` function, the `Span`\ninterface, and binding a `Tracer` at `main()`-time. Here are code snippets\ndemonstrating some important use cases.\n\n#### Singleton initialization\n\nThe simplest starting point is `./default_tracer.go`. As early as possible, call\n\n```go\n    import \"github.com/opentracing/opentracing-go\"\n    import \".../some_tracing_impl\"\n\n    func main() {\n        opentracing.SetGlobalTracer(\n            // tracing impl specific:\n            some_tracing_impl.New(...),\n        )\n        ...\n    }\n```\n\n#### Non-Singleton initialization\n\nIf you prefer direct control to singletons, manage ownership of the\n`opentracing.Tracer` implementation explicitly.\n\n#### Creating a Span given an existing Go `context.Context`\n\nIf you use `context.Context` in your application, OpenTracing's Go library will\nhappily rely on it for `Span` propagation. To start a new (blocking child)\n`Span`, you can use `StartSpanFromContext`.\n\n```go\n    func xyz(ctx context.Context, ...) {\n        ...\n        span, ctx := opentracing.StartSpanFromContext(ctx, \"operation_name\")\n        defer span.Finish()\n        span.LogFields(\n            log.String(\"event\", \"soft error\"),\n            log.String(\"type\", \"cache timeout\"),\n            log.Int(\"waited.millis\", 1500))\n        ...\n    }\n```\n\n#### Starting an empty trace by creating a \"root span\"\n\nIt's always possible to create a \"root\" `Span` with no parent or other causal\nreference.\n\n```go\n    func xyz() {\n        ...\n        sp := opentracing.StartSpan(\"operation_name\")\n        defer sp.Finish()\n        ...\n    }\n```\n\n#### Creating a (child) Span given an existing (parent) Span\n\n```go\n    func xyz(parentSpan opentracing.Span, ...) {\n        ...\n        sp := opentracing.StartSpan(\n            \"operation_name\",\n            opentracing.ChildOf(parentSpan.Context()))\n        defer sp.Finish()\n        ...\n    }\n```\n\n#### Serializing to the wire\n\n```go\n    func makeSomeRequest(ctx context.Context) ... {\n        if span := opentracing.SpanFromContext(ctx); span != nil {\n            httpClient := &http.Client{}\n            httpReq, _ := http.NewRequest(\"GET\", \"http://myservice/\", nil)\n\n            // Transmit the span's TraceContext as HTTP headers on our\n            // outbound request.\n            opentracing.GlobalTracer().Inject(\n                span.Context(),\n                opentracing.HTTPHeaders,\n                opentracing.HTTPHeadersCarrier(httpReq.Header))\n\n            resp, err := httpClient.Do(httpReq)\n            ...\n        }\n        ...\n    }\n```\n\n#### Deserializing from the wire\n\n```go\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n        var serverSpan opentracing.Span\n        appSpecificOperationName := ...\n        wireContext, err := opentracing.GlobalTracer().Extract(\n            opentracing.HTTPHeaders,\n            opentracing.HTTPHeadersCarrier(req.Header))\n        if err != nil {\n            // Optionally record something about err here\n        }\n\n        // Create the span referring to the RPC client if available.\n        // If wireContext == nil, a root span will be created.\n        serverSpan = opentracing.StartSpan(\n            appSpecificOperationName,\n            ext.RPCServerOption(wireContext))\n\n        defer serverSpan.Finish()\n\n        ctx := opentracing.ContextWithSpan(context.Background(), serverSpan)\n        ...\n    }\n```\n\n#### Conditionally capture a field using `log.Noop`\n\nIn some situations, you may want to dynamically decide whether or not\nto log a field.  For example, you may want to capture additional data,\nsuch as a customer ID, in non-production environments:\n\n```go\n    func Customer(order *Order) log.Field {\n        if os.Getenv(\"ENVIRONMENT\") == \"dev\" {\n            return log.String(\"customer\", order.Customer.ID)\n        }\n        return log.Noop()\n    }\n```\n\n#### Goroutine-safety\n\nThe entire public API is goroutine-safe and does not require external\nsynchronization.\n\n## API pointers for those implementing a tracing system\n\nTracing system implementors may be able to reuse or copy-paste-modify the `basictracer` package, found [here](https://github.com/opentracing/basictracer-go). In particular, see `basictracer.New(...)`.\n\n## API compatibility\n\nFor the time being, \"mild\" backwards-incompatible changes may be made without changing the major version number. As OpenTracing and `opentracing-go` mature, backwards compatibility will become more of a priority.\n\n## Tracer test suite\n\nA test suite is available in the [harness](https://godoc.org/github.com/opentracing/opentracing-go/harness) package that can assist Tracer implementors to assert that their Tracer is working correctly.\n\n## Licensing\n\n[Apache 2.0 License](./LICENSE).\n"
        },
        {
          "name": "ext.go",
          "type": "blob",
          "size": 0.849609375,
          "content": "package opentracing\n\nimport (\n\t\"context\"\n)\n\n// TracerContextWithSpanExtension is an extension interface that the\n// implementation of the Tracer interface may want to implement. It\n// allows to have some control over the go context when the\n// ContextWithSpan is invoked.\n//\n// The primary purpose of this extension are adapters from opentracing\n// API to some other tracing API.\ntype TracerContextWithSpanExtension interface {\n\t// ContextWithSpanHook gets called by the ContextWithSpan\n\t// function, when the Tracer implementation also implements\n\t// this interface. It allows to put extra information into the\n\t// context and make it available to the callers of the\n\t// ContextWithSpan.\n\t//\n\t// This hook is invoked before the ContextWithSpan function\n\t// actually puts the span into the context.\n\tContextWithSpanHook(ctx context.Context, span Span) context.Context\n}\n"
        },
        {
          "name": "ext",
          "type": "tree",
          "content": null
        },
        {
          "name": "globaltracer.go",
          "type": "blob",
          "size": 1.3701171875,
          "content": "package opentracing\n\ntype registeredTracer struct {\n\ttracer       Tracer\n\tisRegistered bool\n}\n\nvar (\n\tglobalTracer = registeredTracer{NoopTracer{}, false}\n)\n\n// SetGlobalTracer sets the [singleton] opentracing.Tracer returned by\n// GlobalTracer(). Those who use GlobalTracer (rather than directly manage an\n// opentracing.Tracer instance) should call SetGlobalTracer as early as\n// possible in main(), prior to calling the `StartSpan` global func below.\n// Prior to calling `SetGlobalTracer`, any Spans started via the `StartSpan`\n// (etc) globals are noops.\nfunc SetGlobalTracer(tracer Tracer) {\n\tglobalTracer = registeredTracer{tracer, true}\n}\n\n// GlobalTracer returns the global singleton `Tracer` implementation.\n// Before `SetGlobalTracer()` is called, the `GlobalTracer()` is a noop\n// implementation that drops all data handed to it.\nfunc GlobalTracer() Tracer {\n\treturn globalTracer.tracer\n}\n\n// StartSpan defers to `Tracer.StartSpan`. See `GlobalTracer()`.\nfunc StartSpan(operationName string, opts ...StartSpanOption) Span {\n\treturn globalTracer.tracer.StartSpan(operationName, opts...)\n}\n\n// InitGlobalTracer is deprecated. Please use SetGlobalTracer.\nfunc InitGlobalTracer(tracer Tracer) {\n\tSetGlobalTracer(tracer)\n}\n\n// IsGlobalTracerRegistered returns a `bool` to indicate if a tracer has been globally registered\nfunc IsGlobalTracerRegistered() bool {\n\treturn globalTracer.isRegistered\n}\n"
        },
        {
          "name": "globaltracer_test.go",
          "type": "blob",
          "size": 0.6357421875,
          "content": "package opentracing\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestIsGlobalTracerRegisteredDefaultIsFalse(t *testing.T) {\n\tif IsGlobalTracerRegistered() {\n\t\tt.Errorf(\"Should return false when no global tracer is registered.\")\n\t}\n}\n\nfunc TestAfterSettingGlobalTracerIsGlobalTracerRegisteredReturnsTrue(t *testing.T) {\n\tSetGlobalTracer(NoopTracer{})\n\n\tif !IsGlobalTracerRegistered() {\n\t\tt.Errorf(\"Should return true after a tracer has been registered.\")\n\t}\n}\n\nfunc TestDefaultTracerIsNoopTracer(t *testing.T) {\n\tif reflect.TypeOf(GlobalTracer()) != reflect.TypeOf(NoopTracer{}) {\n\t\tt.Errorf(\"Should return false when no global tracer is registered.\")\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.095703125,
          "content": "module github.com/opentracing/opentracing-go\n\ngo 1.14\n\nrequire github.com/stretchr/testify v1.7.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gocontext.go",
          "type": "blob",
          "size": 2.4091796875,
          "content": "package opentracing\n\nimport \"context\"\n\ntype contextKey struct{}\n\nvar activeSpanKey = contextKey{}\n\n// ContextWithSpan returns a new `context.Context` that holds a reference to\n// the span. If span is nil, a new context without an active span is returned.\nfunc ContextWithSpan(ctx context.Context, span Span) context.Context {\n\tif span != nil {\n\t\tif tracerWithHook, ok := span.Tracer().(TracerContextWithSpanExtension); ok {\n\t\t\tctx = tracerWithHook.ContextWithSpanHook(ctx, span)\n\t\t}\n\t}\n\treturn context.WithValue(ctx, activeSpanKey, span)\n}\n\n// SpanFromContext returns the `Span` previously associated with `ctx`, or\n// `nil` if no such `Span` could be found.\n//\n// NOTE: context.Context != SpanContext: the former is Go's intra-process\n// context propagation mechanism, and the latter houses OpenTracing's per-Span\n// identity and baggage information.\nfunc SpanFromContext(ctx context.Context) Span {\n\tval := ctx.Value(activeSpanKey)\n\tif sp, ok := val.(Span); ok {\n\t\treturn sp\n\t}\n\treturn nil\n}\n\n// StartSpanFromContext starts and returns a Span with `operationName`, using\n// any Span found within `ctx` as a ChildOfRef. If no such parent could be\n// found, StartSpanFromContext creates a root (parentless) Span.\n//\n// The second return value is a context.Context object built around the\n// returned Span.\n//\n// Example usage:\n//\n//    SomeFunction(ctx context.Context, ...) {\n//        sp, ctx := opentracing.StartSpanFromContext(ctx, \"SomeFunction\")\n//        defer sp.Finish()\n//        ...\n//    }\nfunc StartSpanFromContext(ctx context.Context, operationName string, opts ...StartSpanOption) (Span, context.Context) {\n\treturn StartSpanFromContextWithTracer(ctx, GlobalTracer(), operationName, opts...)\n}\n\n// StartSpanFromContextWithTracer starts and returns a span with `operationName`\n// using  a span found within the context as a ChildOfRef. If that doesn't exist\n// it creates a root span. It also returns a context.Context object built\n// around the returned span.\n//\n// It's behavior is identical to StartSpanFromContext except that it takes an explicit\n// tracer as opposed to using the global tracer.\nfunc StartSpanFromContextWithTracer(ctx context.Context, tracer Tracer, operationName string, opts ...StartSpanOption) (Span, context.Context) {\n\tif parentSpan := SpanFromContext(ctx); parentSpan != nil {\n\t\topts = append(opts, ChildOf(parentSpan.Context()))\n\t}\n\tspan := tracer.StartSpan(operationName, opts...)\n\treturn span, ContextWithSpan(ctx, span)\n}\n"
        },
        {
          "name": "gocontext_test.go",
          "type": "blob",
          "size": 3.408203125,
          "content": "package opentracing\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestContextWithSpan(t *testing.T) {\n\tspan := &noopSpan{}\n\tctx := ContextWithSpan(context.Background(), span)\n\tspan2 := SpanFromContext(ctx)\n\tif span != span2 {\n\t\tt.Errorf(\"Not the same span returned from context, expected=%+v, actual=%+v\", span, span2)\n\t}\n\n\tctx = context.Background()\n\tspan2 = SpanFromContext(ctx)\n\tif span2 != nil {\n\t\tt.Errorf(\"Expected nil span, found %+v\", span2)\n\t}\n\n\tctx = ContextWithSpan(ctx, span)\n\tspan2 = SpanFromContext(ctx)\n\tif span != span2 {\n\t\tt.Errorf(\"Not the same span returned from context, expected=%+v, actual=%+v\", span, span2)\n\t}\n\n\tctx = ContextWithSpan(ctx, nil)\n\tif s := SpanFromContext(ctx); s != nil {\n\t\tt.Errorf(\"Not able to reset span in context, expected=nil, actual=%+v\", s)\n\t}\n}\n\ntype noopExtTracer struct {\n\tNoopTracer\n}\n\ntype noopExtTracerCtxType struct{}\n\nfunc (noopExtTracer) ContextWithSpanHook(ctx context.Context, span Span) context.Context {\n\treturn context.WithValue(ctx, noopExtTracerCtxType{}, noopExtTracerCtxType{})\n}\n\nvar _ Tracer = noopExtTracer{}\nvar _ TracerContextWithSpanExtension = noopExtTracer{}\n\ntype noopExtSpan struct {\n\tnoopSpan\n}\n\nfunc (noopExtSpan) Tracer() Tracer {\n\treturn noopExtTracer{}\n}\n\nvar _ Span = noopExtSpan{}\n\nfunc TestContextWithSpanWithExtension(t *testing.T) {\n\tspan := &noopExtSpan{}\n\tctx := ContextWithSpan(context.Background(), span)\n\tspan2 := SpanFromContext(ctx)\n\tif span != span2 {\n\t\tt.Errorf(\"Not the same span returned from context, expected=%+v, actual=%+v\", span, span2)\n\t}\n\tif _, ok := ctx.Value(noopExtTracerCtxType{}).(noopExtTracerCtxType); !ok {\n\t\tt.Error(\"ContextWithSpanHook was not called\")\n\t}\n}\n\nfunc TestStartSpanFromContext(t *testing.T) {\n\ttestTracer := testTracer{}\n\n\t// Test the case where there *is* a Span in the Context.\n\t{\n\t\tparentSpan := &testSpan{}\n\t\tparentCtx := ContextWithSpan(context.Background(), parentSpan)\n\t\tchildSpan, childCtx := StartSpanFromContextWithTracer(parentCtx, testTracer, \"child\")\n\t\tif !childSpan.Context().(testSpanContext).HasParent {\n\t\t\tt.Errorf(\"Failed to find parent: %v\", childSpan)\n\t\t}\n\t\tif !childSpan.(testSpan).Equal(SpanFromContext(childCtx)) {\n\t\t\tt.Errorf(\"Unable to find child span in context: %v\", childCtx)\n\t\t}\n\t}\n\n\t// Test the case where there *is not* a Span in the Context.\n\t{\n\t\temptyCtx := context.Background()\n\t\tchildSpan, childCtx := StartSpanFromContextWithTracer(emptyCtx, testTracer, \"child\")\n\t\tif childSpan.Context().(testSpanContext).HasParent {\n\t\t\tt.Errorf(\"Should not have found parent: %v\", childSpan)\n\t\t}\n\t\tif !childSpan.(testSpan).Equal(SpanFromContext(childCtx)) {\n\t\t\tt.Errorf(\"Unable to find child span in context: %v\", childCtx)\n\t\t}\n\t}\n}\n\nfunc TestStartSpanFromContextOptions(t *testing.T) {\n\ttestTracer := testTracer{}\n\n\t// Test options are passed to tracer\n\n\tstartTime := time.Now().Add(-10 * time.Second) // ten seconds ago\n\tspan, ctx := StartSpanFromContextWithTracer(\n\t\tcontext.Background(), testTracer, \"parent\", StartTime(startTime), Tag{\"component\", \"test\"})\n\n\tassert.Equal(t, \"test\", span.(testSpan).Tags[\"component\"])\n\tassert.Equal(t, startTime, span.(testSpan).StartTime)\n\n\t// Test it also works for a child span\n\n\tchildStartTime := startTime.Add(3 * time.Second)\n\tchildSpan, _ := StartSpanFromContextWithTracer(\n\t\tctx, testTracer, \"child\", StartTime(childStartTime))\n\n\tassert.Equal(t, childSpan.(testSpan).Tags[\"component\"], nil)\n\tassert.Equal(t, childSpan.(testSpan).StartTime, childStartTime)\n}\n"
        },
        {
          "name": "harness",
          "type": "tree",
          "content": null
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "mocktracer",
          "type": "tree",
          "content": null
        },
        {
          "name": "noop.go",
          "type": "blob",
          "size": 2.61328125,
          "content": "package opentracing\n\nimport \"github.com/opentracing/opentracing-go/log\"\n\n// A NoopTracer is a trivial, minimum overhead implementation of Tracer\n// for which all operations are no-ops.\n//\n// The primary use of this implementation is in libraries, such as RPC\n// frameworks, that make tracing an optional feature controlled by the\n// end user. A no-op implementation allows said libraries to use it\n// as the default Tracer and to write instrumentation that does\n// not need to keep checking if the tracer instance is nil.\n//\n// For the same reason, the NoopTracer is the default \"global\" tracer\n// (see GlobalTracer and SetGlobalTracer functions).\n//\n// WARNING: NoopTracer does not support baggage propagation.\ntype NoopTracer struct{}\n\ntype noopSpan struct{}\ntype noopSpanContext struct{}\n\nvar (\n\tdefaultNoopSpanContext SpanContext = noopSpanContext{}\n\tdefaultNoopSpan        Span        = noopSpan{}\n\tdefaultNoopTracer      Tracer      = NoopTracer{}\n)\n\nconst (\n\temptyString = \"\"\n)\n\n// noopSpanContext:\nfunc (n noopSpanContext) ForeachBaggageItem(handler func(k, v string) bool) {}\n\n// noopSpan:\nfunc (n noopSpan) Context() SpanContext                                  { return defaultNoopSpanContext }\nfunc (n noopSpan) SetBaggageItem(key, val string) Span                   { return n }\nfunc (n noopSpan) BaggageItem(key string) string                         { return emptyString }\nfunc (n noopSpan) SetTag(key string, value interface{}) Span             { return n }\nfunc (n noopSpan) LogFields(fields ...log.Field)                         {}\nfunc (n noopSpan) LogKV(keyVals ...interface{})                          {}\nfunc (n noopSpan) Finish()                                               {}\nfunc (n noopSpan) FinishWithOptions(opts FinishOptions)                  {}\nfunc (n noopSpan) SetOperationName(operationName string) Span            { return n }\nfunc (n noopSpan) Tracer() Tracer                                        { return defaultNoopTracer }\nfunc (n noopSpan) LogEvent(event string)                                 {}\nfunc (n noopSpan) LogEventWithPayload(event string, payload interface{}) {}\nfunc (n noopSpan) Log(data LogData)                                      {}\n\n// StartSpan belongs to the Tracer interface.\nfunc (n NoopTracer) StartSpan(operationName string, opts ...StartSpanOption) Span {\n\treturn defaultNoopSpan\n}\n\n// Inject belongs to the Tracer interface.\nfunc (n NoopTracer) Inject(sp SpanContext, format interface{}, carrier interface{}) error {\n\treturn nil\n}\n\n// Extract belongs to the Tracer interface.\nfunc (n NoopTracer) Extract(format interface{}, carrier interface{}) (SpanContext, error) {\n\treturn nil, ErrSpanContextNotFound\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 0.724609375,
          "content": "package opentracing\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestChildOfAndFollowsFrom(t *testing.T) {\n\ttests := []struct {\n\t\tnewOpt  func(SpanContext) SpanReference\n\t\trefType SpanReferenceType\n\t\tname    string\n\t}{\n\t\t{ChildOf, ChildOfRef, \"ChildOf\"},\n\t\t{FollowsFrom, FollowsFromRef, \"FollowsFrom\"},\n\t}\n\n\tfor _, test := range tests {\n\t\topts := new(StartSpanOptions)\n\n\t\ttest.newOpt(nil).Apply(opts)\n\t\trequire.Nil(t, opts.References, \"%s(nil) must not append a reference\", test.name)\n\n\t\tctx := new(noopSpanContext)\n\t\ttest.newOpt(ctx).Apply(opts)\n\t\trequire.Equal(t, []SpanReference{\n\t\t\tSpanReference{ReferencedContext: ctx, Type: test.refType},\n\t\t}, opts.References, \"%s(ctx) must append a reference\", test.name)\n\t}\n}\n"
        },
        {
          "name": "propagation.go",
          "type": "blob",
          "size": 6.298828125,
          "content": "package opentracing\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n)\n\n///////////////////////////////////////////////////////////////////////////////\n// CORE PROPAGATION INTERFACES:\n///////////////////////////////////////////////////////////////////////////////\n\nvar (\n\t// ErrUnsupportedFormat occurs when the `format` passed to Tracer.Inject() or\n\t// Tracer.Extract() is not recognized by the Tracer implementation.\n\tErrUnsupportedFormat = errors.New(\"opentracing: Unknown or unsupported Inject/Extract format\")\n\n\t// ErrSpanContextNotFound occurs when the `carrier` passed to\n\t// Tracer.Extract() is valid and uncorrupted but has insufficient\n\t// information to extract a SpanContext.\n\tErrSpanContextNotFound = errors.New(\"opentracing: SpanContext not found in Extract carrier\")\n\n\t// ErrInvalidSpanContext errors occur when Tracer.Inject() is asked to\n\t// operate on a SpanContext which it is not prepared to handle (for\n\t// example, since it was created by a different tracer implementation).\n\tErrInvalidSpanContext = errors.New(\"opentracing: SpanContext type incompatible with tracer\")\n\n\t// ErrInvalidCarrier errors occur when Tracer.Inject() or Tracer.Extract()\n\t// implementations expect a different type of `carrier` than they are\n\t// given.\n\tErrInvalidCarrier = errors.New(\"opentracing: Invalid Inject/Extract carrier\")\n\n\t// ErrSpanContextCorrupted occurs when the `carrier` passed to\n\t// Tracer.Extract() is of the expected type but is corrupted.\n\tErrSpanContextCorrupted = errors.New(\"opentracing: SpanContext data corrupted in Extract carrier\")\n)\n\n///////////////////////////////////////////////////////////////////////////////\n// BUILTIN PROPAGATION FORMATS:\n///////////////////////////////////////////////////////////////////////////////\n\n// BuiltinFormat is used to demarcate the values within package `opentracing`\n// that are intended for use with the Tracer.Inject() and Tracer.Extract()\n// methods.\ntype BuiltinFormat byte\n\nconst (\n\t// Binary represents SpanContexts as opaque binary data.\n\t//\n\t// For Tracer.Inject(): the carrier must be an `io.Writer`.\n\t//\n\t// For Tracer.Extract(): the carrier must be an `io.Reader`.\n\tBinary BuiltinFormat = iota\n\n\t// TextMap represents SpanContexts as key:value string pairs.\n\t//\n\t// Unlike HTTPHeaders, the TextMap format does not restrict the key or\n\t// value character sets in any way.\n\t//\n\t// For Tracer.Inject(): the carrier must be a `TextMapWriter`.\n\t//\n\t// For Tracer.Extract(): the carrier must be a `TextMapReader`.\n\tTextMap\n\n\t// HTTPHeaders represents SpanContexts as HTTP header string pairs.\n\t//\n\t// Unlike TextMap, the HTTPHeaders format requires that the keys and values\n\t// be valid as HTTP headers as-is (i.e., character casing may be unstable\n\t// and special characters are disallowed in keys, values should be\n\t// URL-escaped, etc).\n\t//\n\t// For Tracer.Inject(): the carrier must be a `TextMapWriter`.\n\t//\n\t// For Tracer.Extract(): the carrier must be a `TextMapReader`.\n\t//\n\t// See HTTPHeadersCarrier for an implementation of both TextMapWriter\n\t// and TextMapReader that defers to an http.Header instance for storage.\n\t// For example, Inject():\n\t//\n\t//    carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)\n\t//    err := span.Tracer().Inject(\n\t//        span.Context(), opentracing.HTTPHeaders, carrier)\n\t//\n\t// Or Extract():\n\t//\n\t//    carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)\n\t//    clientContext, err := tracer.Extract(\n\t//        opentracing.HTTPHeaders, carrier)\n\t//\n\tHTTPHeaders\n)\n\n// TextMapWriter is the Inject() carrier for the TextMap builtin format. With\n// it, the caller can encode a SpanContext for propagation as entries in a map\n// of unicode strings.\ntype TextMapWriter interface {\n\t// Set a key:value pair to the carrier. Multiple calls to Set() for the\n\t// same key leads to undefined behavior.\n\t//\n\t// NOTE: The backing store for the TextMapWriter may contain data unrelated\n\t// to SpanContext. As such, Inject() and Extract() implementations that\n\t// call the TextMapWriter and TextMapReader interfaces must agree on a\n\t// prefix or other convention to distinguish their own key:value pairs.\n\tSet(key, val string)\n}\n\n// TextMapReader is the Extract() carrier for the TextMap builtin format. With it,\n// the caller can decode a propagated SpanContext as entries in a map of\n// unicode strings.\ntype TextMapReader interface {\n\t// ForeachKey returns TextMap contents via repeated calls to the `handler`\n\t// function. If any call to `handler` returns a non-nil error, ForeachKey\n\t// terminates and returns that error.\n\t//\n\t// NOTE: The backing store for the TextMapReader may contain data unrelated\n\t// to SpanContext. As such, Inject() and Extract() implementations that\n\t// call the TextMapWriter and TextMapReader interfaces must agree on a\n\t// prefix or other convention to distinguish their own key:value pairs.\n\t//\n\t// The \"foreach\" callback pattern reduces unnecessary copying in some cases\n\t// and also allows implementations to hold locks while the map is read.\n\tForeachKey(handler func(key, val string) error) error\n}\n\n// TextMapCarrier allows the use of regular map[string]string\n// as both TextMapWriter and TextMapReader.\ntype TextMapCarrier map[string]string\n\n// ForeachKey conforms to the TextMapReader interface.\nfunc (c TextMapCarrier) ForeachKey(handler func(key, val string) error) error {\n\tfor k, v := range c {\n\t\tif err := handler(k, v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Set implements Set() of opentracing.TextMapWriter\nfunc (c TextMapCarrier) Set(key, val string) {\n\tc[key] = val\n}\n\n// HTTPHeadersCarrier satisfies both TextMapWriter and TextMapReader.\n//\n// Example usage for server side:\n//\n//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)\n//     clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier)\n//\n// Example usage for client side:\n//\n//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)\n//     err := tracer.Inject(\n//         span.Context(),\n//         opentracing.HTTPHeaders,\n//         carrier)\n//\ntype HTTPHeadersCarrier http.Header\n\n// Set conforms to the TextMapWriter interface.\nfunc (c HTTPHeadersCarrier) Set(key, val string) {\n\th := http.Header(c)\n\th.Set(key, val)\n}\n\n// ForeachKey conforms to the TextMapReader interface.\nfunc (c HTTPHeadersCarrier) ForeachKey(handler func(key, val string) error) error {\n\tfor k, vals := range c {\n\t\tfor _, v := range vals {\n\t\t\tif err := handler(k, v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "propagation_test.go",
          "type": "blob",
          "size": 2.2197265625,
          "content": "package opentracing\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestTextMapCarrierInject(t *testing.T) {\n\tm := make(map[string]string)\n\tm[\"NotOT\"] = \"blah\"\n\tm[\"opname\"] = \"AlsoNotOT\"\n\ttracer := testTracer{}\n\tspan := tracer.StartSpan(\"someSpan\")\n\tfakeID := span.Context().(testSpanContext).FakeID\n\n\tcarrier := TextMapCarrier(m)\n\tif err := span.Tracer().Inject(span.Context(), TextMap, carrier); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(m) != 3 {\n\t\tt.Errorf(\"Unexpected header length: %v\", len(m))\n\t}\n\t// The prefix comes from just above; the suffix comes from\n\t// testTracer.Inject().\n\tif m[\"testprefix-fakeid\"] != strconv.Itoa(fakeID) {\n\t\tt.Errorf(\"Could not find fakeid at expected key\")\n\t}\n}\n\nfunc TestTextMapCarrierExtract(t *testing.T) {\n\tm := make(map[string]string)\n\tm[\"NotOT\"] = \"blah\"\n\tm[\"opname\"] = \"AlsoNotOT\"\n\tm[\"testprefix-fakeid\"] = \"42\"\n\ttracer := testTracer{}\n\n\tcarrier := TextMapCarrier(m)\n\textractedContext, err := tracer.Extract(TextMap, carrier)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif extractedContext.(testSpanContext).FakeID != 42 {\n\t\tt.Errorf(\"Failed to read testprefix-fakeid correctly\")\n\t}\n}\n\nfunc TestHTTPHeaderInject(t *testing.T) {\n\th := http.Header{}\n\th.Add(\"NotOT\", \"blah\")\n\th.Add(\"opname\", \"AlsoNotOT\")\n\ttracer := testTracer{}\n\tspan := tracer.StartSpan(\"someSpan\")\n\tfakeID := span.Context().(testSpanContext).FakeID\n\n\t// Use HTTPHeadersCarrier to wrap around `h`.\n\tcarrier := HTTPHeadersCarrier(h)\n\tif err := span.Tracer().Inject(span.Context(), HTTPHeaders, carrier); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(h) != 3 {\n\t\tt.Errorf(\"Unexpected header length: %v\", len(h))\n\t}\n\t// The prefix comes from just above; the suffix comes from\n\t// testTracer.Inject().\n\tif h.Get(\"testprefix-fakeid\") != strconv.Itoa(fakeID) {\n\t\tt.Errorf(\"Could not find fakeid at expected key\")\n\t}\n}\n\nfunc TestHTTPHeaderExtract(t *testing.T) {\n\th := http.Header{}\n\th.Add(\"NotOT\", \"blah\")\n\th.Add(\"opname\", \"AlsoNotOT\")\n\th.Add(\"testprefix-fakeid\", \"42\")\n\ttracer := testTracer{}\n\n\t// Use HTTPHeadersCarrier to wrap around `h`.\n\tcarrier := HTTPHeadersCarrier(h)\n\tspanContext, err := tracer.Extract(HTTPHeaders, carrier)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif spanContext.(testSpanContext).FakeID != 42 {\n\t\tt.Errorf(\"Failed to read testprefix-fakeid correctly\")\n\t}\n}\n"
        },
        {
          "name": "span.go",
          "type": "blob",
          "size": 6.541015625,
          "content": "package opentracing\n\nimport (\n\t\"time\"\n\n\t\"github.com/opentracing/opentracing-go/log\"\n)\n\n// SpanContext represents Span state that must propagate to descendant Spans and across process\n// boundaries (e.g., a <trace_id, span_id, sampled> tuple).\ntype SpanContext interface {\n\t// ForeachBaggageItem grants access to all baggage items stored in the\n\t// SpanContext.\n\t// The handler function will be called for each baggage key/value pair.\n\t// The ordering of items is not guaranteed.\n\t//\n\t// The bool return value indicates if the handler wants to continue iterating\n\t// through the rest of the baggage items; for example if the handler is trying to\n\t// find some baggage item by pattern matching the name, it can return false\n\t// as soon as the item is found to stop further iterations.\n\tForeachBaggageItem(handler func(k, v string) bool)\n}\n\n// Span represents an active, un-finished span in the OpenTracing system.\n//\n// Spans are created by the Tracer interface.\ntype Span interface {\n\t// Sets the end timestamp and finalizes Span state.\n\t//\n\t// With the exception of calls to Context() (which are always allowed),\n\t// Finish() must be the last call made to any span instance, and to do\n\t// otherwise leads to undefined behavior.\n\tFinish()\n\t// FinishWithOptions is like Finish() but with explicit control over\n\t// timestamps and log data.\n\tFinishWithOptions(opts FinishOptions)\n\n\t// Context() yields the SpanContext for this Span. Note that the return\n\t// value of Context() is still valid after a call to Span.Finish(), as is\n\t// a call to Span.Context() after a call to Span.Finish().\n\tContext() SpanContext\n\n\t// Sets or changes the operation name.\n\t//\n\t// Returns a reference to this Span for chaining.\n\tSetOperationName(operationName string) Span\n\n\t// Adds a tag to the span.\n\t//\n\t// If there is a pre-existing tag set for `key`, it is overwritten.\n\t//\n\t// Tag values can be numeric types, strings, or bools. The behavior of\n\t// other tag value types is undefined at the OpenTracing level. If a\n\t// tracing system does not know how to handle a particular value type, it\n\t// may ignore the tag, but shall not panic.\n\t//\n\t// Returns a reference to this Span for chaining.\n\tSetTag(key string, value interface{}) Span\n\n\t// LogFields is an efficient and type-checked way to record key:value\n\t// logging data about a Span, though the programming interface is a little\n\t// more verbose than LogKV(). Here's an example:\n\t//\n\t//    span.LogFields(\n\t//        log.String(\"event\", \"soft error\"),\n\t//        log.String(\"type\", \"cache timeout\"),\n\t//        log.Int(\"waited.millis\", 1500))\n\t//\n\t// Also see Span.FinishWithOptions() and FinishOptions.BulkLogData.\n\tLogFields(fields ...log.Field)\n\n\t// LogKV is a concise, readable way to record key:value logging data about\n\t// a Span, though unfortunately this also makes it less efficient and less\n\t// type-safe than LogFields(). Here's an example:\n\t//\n\t//    span.LogKV(\n\t//        \"event\", \"soft error\",\n\t//        \"type\", \"cache timeout\",\n\t//        \"waited.millis\", 1500)\n\t//\n\t// For LogKV (as opposed to LogFields()), the parameters must appear as\n\t// key-value pairs, like\n\t//\n\t//    span.LogKV(key1, val1, key2, val2, key3, val3, ...)\n\t//\n\t// The keys must all be strings. The values may be strings, numeric types,\n\t// bools, Go error instances, or arbitrary structs.\n\t//\n\t// (Note to implementors: consider the log.InterleavedKVToFields() helper)\n\tLogKV(alternatingKeyValues ...interface{})\n\n\t// SetBaggageItem sets a key:value pair on this Span and its SpanContext\n\t// that also propagates to descendants of this Span.\n\t//\n\t// SetBaggageItem() enables powerful functionality given a full-stack\n\t// opentracing integration (e.g., arbitrary application data from a mobile\n\t// app can make it, transparently, all the way into the depths of a storage\n\t// system), and with it some powerful costs: use this feature with care.\n\t//\n\t// IMPORTANT NOTE #1: SetBaggageItem() will only propagate baggage items to\n\t// *future* causal descendants of the associated Span.\n\t//\n\t// IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n\t// value is copied into every local *and remote* child of the associated\n\t// Span, and that can add up to a lot of network and cpu overhead.\n\t//\n\t// Returns a reference to this Span for chaining.\n\tSetBaggageItem(restrictedKey, value string) Span\n\n\t// Gets the value for a baggage item given its key. Returns the empty string\n\t// if the value isn't found in this Span.\n\tBaggageItem(restrictedKey string) string\n\n\t// Provides access to the Tracer that created this Span.\n\tTracer() Tracer\n\n\t// Deprecated: use LogFields or LogKV\n\tLogEvent(event string)\n\t// Deprecated: use LogFields or LogKV\n\tLogEventWithPayload(event string, payload interface{})\n\t// Deprecated: use LogFields or LogKV\n\tLog(data LogData)\n}\n\n// LogRecord is data associated with a single Span log. Every LogRecord\n// instance must specify at least one Field.\ntype LogRecord struct {\n\tTimestamp time.Time\n\tFields    []log.Field\n}\n\n// FinishOptions allows Span.FinishWithOptions callers to override the finish\n// timestamp and provide log data via a bulk interface.\ntype FinishOptions struct {\n\t// FinishTime overrides the Span's finish time, or implicitly becomes\n\t// time.Now() if FinishTime.IsZero().\n\t//\n\t// FinishTime must resolve to a timestamp that's >= the Span's StartTime\n\t// (per StartSpanOptions).\n\tFinishTime time.Time\n\n\t// LogRecords allows the caller to specify the contents of many LogFields()\n\t// calls with a single slice. May be nil.\n\t//\n\t// None of the LogRecord.Timestamp values may be .IsZero() (i.e., they must\n\t// be set explicitly). Also, they must be >= the Span's start timestamp and\n\t// <= the FinishTime (or time.Now() if FinishTime.IsZero()). Otherwise the\n\t// behavior of FinishWithOptions() is undefined.\n\t//\n\t// If specified, the caller hands off ownership of LogRecords at\n\t// FinishWithOptions() invocation time.\n\t//\n\t// If specified, the (deprecated) BulkLogData must be nil or empty.\n\tLogRecords []LogRecord\n\n\t// BulkLogData is DEPRECATED.\n\tBulkLogData []LogData\n}\n\n// LogData is DEPRECATED\ntype LogData struct {\n\tTimestamp time.Time\n\tEvent     string\n\tPayload   interface{}\n}\n\n// ToLogRecord converts a deprecated LogData to a non-deprecated LogRecord\nfunc (ld *LogData) ToLogRecord() LogRecord {\n\tvar literalTimestamp time.Time\n\tif ld.Timestamp.IsZero() {\n\t\tliteralTimestamp = time.Now()\n\t} else {\n\t\tliteralTimestamp = ld.Timestamp\n\t}\n\trval := LogRecord{\n\t\tTimestamp: literalTimestamp,\n\t}\n\tif ld.Payload == nil {\n\t\trval.Fields = []log.Field{\n\t\t\tlog.String(\"event\", ld.Event),\n\t\t}\n\t} else {\n\t\trval.Fields = []log.Field{\n\t\t\tlog.String(\"event\", ld.Event),\n\t\t\tlog.Object(\"payload\", ld.Payload),\n\t\t}\n\t}\n\treturn rval\n}\n"
        },
        {
          "name": "testtracer_test.go",
          "type": "blob",
          "size": 3.7978515625,
          "content": "package opentracing\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/opentracing/opentracing-go/log\"\n)\n\nconst testHTTPHeaderPrefix = \"testprefix-\"\n\n// testTracer is a most-noop Tracer implementation that makes it possible for\n// unittests to verify whether certain methods were / were not called.\ntype testTracer struct{}\n\nvar fakeIDSource = 1\n\nfunc nextFakeID() int {\n\tfakeIDSource++\n\treturn fakeIDSource\n}\n\ntype testSpanContext struct {\n\tHasParent bool\n\tFakeID    int\n}\n\nfunc (n testSpanContext) ForeachBaggageItem(handler func(k, v string) bool) {}\n\ntype testSpan struct {\n\tspanContext   testSpanContext\n\tOperationName string\n\tStartTime     time.Time\n\tTags          map[string]interface{}\n}\n\nfunc (n testSpan) Equal(os Span) bool {\n\tother, ok := os.(testSpan)\n\tif !ok {\n\t\treturn false\n\t}\n\tif n.spanContext != other.spanContext {\n\t\treturn false\n\t}\n\tif n.OperationName != other.OperationName {\n\t\treturn false\n\t}\n\tif !n.StartTime.Equal(other.StartTime) {\n\t\treturn false\n\t}\n\tif len(n.Tags) != len(other.Tags) {\n\t\treturn false\n\t}\n\n\tfor k, v := range n.Tags {\n\t\tif ov, ok := other.Tags[k]; !ok || ov != v {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// testSpan:\nfunc (n testSpan) Context() SpanContext                                  { return n.spanContext }\nfunc (n testSpan) SetTag(key string, value interface{}) Span             { return n }\nfunc (n testSpan) Finish()                                               {}\nfunc (n testSpan) FinishWithOptions(opts FinishOptions)                  {}\nfunc (n testSpan) LogFields(fields ...log.Field)                         {}\nfunc (n testSpan) LogKV(kvs ...interface{})                              {}\nfunc (n testSpan) SetOperationName(operationName string) Span            { return n }\nfunc (n testSpan) Tracer() Tracer                                        { return testTracer{} }\nfunc (n testSpan) SetBaggageItem(key, val string) Span                   { return n }\nfunc (n testSpan) BaggageItem(key string) string                         { return \"\" }\nfunc (n testSpan) LogEvent(event string)                                 {}\nfunc (n testSpan) LogEventWithPayload(event string, payload interface{}) {}\nfunc (n testSpan) Log(data LogData)                                      {}\n\n// StartSpan belongs to the Tracer interface.\nfunc (n testTracer) StartSpan(operationName string, opts ...StartSpanOption) Span {\n\tsso := StartSpanOptions{}\n\tfor _, o := range opts {\n\t\to.Apply(&sso)\n\t}\n\treturn n.startSpanWithOptions(operationName, sso)\n}\n\nfunc (n testTracer) startSpanWithOptions(name string, opts StartSpanOptions) Span {\n\tfakeID := nextFakeID()\n\tif len(opts.References) > 0 {\n\t\tfakeID = opts.References[0].ReferencedContext.(testSpanContext).FakeID\n\t}\n\n\treturn testSpan{\n\t\tOperationName: name,\n\t\tStartTime:     opts.StartTime,\n\t\tTags:          opts.Tags,\n\t\tspanContext: testSpanContext{\n\t\t\tHasParent: len(opts.References) > 0,\n\t\t\tFakeID:    fakeID,\n\t\t},\n\t}\n}\n\n// Inject belongs to the Tracer interface.\nfunc (n testTracer) Inject(sp SpanContext, format interface{}, carrier interface{}) error {\n\tspanContext := sp.(testSpanContext)\n\tswitch format {\n\tcase HTTPHeaders, TextMap:\n\t\tcarrier.(TextMapWriter).Set(testHTTPHeaderPrefix+\"fakeid\", strconv.Itoa(spanContext.FakeID))\n\t\treturn nil\n\t}\n\treturn ErrUnsupportedFormat\n}\n\n// Extract belongs to the Tracer interface.\nfunc (n testTracer) Extract(format interface{}, carrier interface{}) (SpanContext, error) {\n\tswitch format {\n\tcase HTTPHeaders, TextMap:\n\t\t// Just for testing purposes... generally not a worthwhile thing to\n\t\t// propagate.\n\t\tsm := testSpanContext{}\n\t\terr := carrier.(TextMapReader).ForeachKey(func(key, val string) error {\n\t\t\tswitch strings.ToLower(key) {\n\t\t\tcase testHTTPHeaderPrefix + \"fakeid\":\n\t\t\t\ti, err := strconv.Atoi(val)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsm.FakeID = i\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\treturn sm, err\n\t}\n\treturn nil, ErrSpanContextNotFound\n}\n"
        },
        {
          "name": "tracer.go",
          "type": "blob",
          "size": 9.955078125,
          "content": "package opentracing\n\nimport \"time\"\n\n// Tracer is a simple, thin interface for Span creation and SpanContext\n// propagation.\ntype Tracer interface {\n\n\t// Create, start, and return a new Span with the given `operationName` and\n\t// incorporate the given StartSpanOption `opts`. (Note that `opts` borrows\n\t// from the \"functional options\" pattern, per\n\t// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)\n\t//\n\t// A Span with no SpanReference options (e.g., opentracing.ChildOf() or\n\t// opentracing.FollowsFrom()) becomes the root of its own trace.\n\t//\n\t// Examples:\n\t//\n\t//     var tracer opentracing.Tracer = ...\n\t//\n\t//     // The root-span case:\n\t//     sp := tracer.StartSpan(\"GetFeed\")\n\t//\n\t//     // The vanilla child span case:\n\t//     sp := tracer.StartSpan(\n\t//         \"GetFeed\",\n\t//         opentracing.ChildOf(parentSpan.Context()))\n\t//\n\t//     // All the bells and whistles:\n\t//     sp := tracer.StartSpan(\n\t//         \"GetFeed\",\n\t//         opentracing.ChildOf(parentSpan.Context()),\n\t//         opentracing.Tag{\"user_agent\", loggedReq.UserAgent},\n\t//         opentracing.StartTime(loggedReq.Timestamp),\n\t//     )\n\t//\n\tStartSpan(operationName string, opts ...StartSpanOption) Span\n\n\t// Inject() takes the `sm` SpanContext instance and injects it for\n\t// propagation within `carrier`. The actual type of `carrier` depends on\n\t// the value of `format`.\n\t//\n\t// OpenTracing defines a common set of `format` values (see BuiltinFormat),\n\t// and each has an expected carrier type.\n\t//\n\t// Other packages may declare their own `format` values, much like the keys\n\t// used by `context.Context` (see https://godoc.org/context#WithValue).\n\t//\n\t// Example usage (sans error handling):\n\t//\n\t//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)\n\t//     err := tracer.Inject(\n\t//         span.Context(),\n\t//         opentracing.HTTPHeaders,\n\t//         carrier)\n\t//\n\t// NOTE: All opentracing.Tracer implementations MUST support all\n\t// BuiltinFormats.\n\t//\n\t// Implementations may return opentracing.ErrUnsupportedFormat if `format`\n\t// is not supported by (or not known by) the implementation.\n\t//\n\t// Implementations may return opentracing.ErrInvalidCarrier or any other\n\t// implementation-specific error if the format is supported but injection\n\t// fails anyway.\n\t//\n\t// See Tracer.Extract().\n\tInject(sm SpanContext, format interface{}, carrier interface{}) error\n\n\t// Extract() returns a SpanContext instance given `format` and `carrier`.\n\t//\n\t// OpenTracing defines a common set of `format` values (see BuiltinFormat),\n\t// and each has an expected carrier type.\n\t//\n\t// Other packages may declare their own `format` values, much like the keys\n\t// used by `context.Context` (see\n\t// https://godoc.org/golang.org/x/net/context#WithValue).\n\t//\n\t// Example usage (with StartSpan):\n\t//\n\t//\n\t//     carrier := opentracing.HTTPHeadersCarrier(httpReq.Header)\n\t//     clientContext, err := tracer.Extract(opentracing.HTTPHeaders, carrier)\n\t//\n\t//     // ... assuming the ultimate goal here is to resume the trace with a\n\t//     // server-side Span:\n\t//     var serverSpan opentracing.Span\n\t//     if err == nil {\n\t//         span = tracer.StartSpan(\n\t//             rpcMethodName, ext.RPCServerOption(clientContext))\n\t//     } else {\n\t//         span = tracer.StartSpan(rpcMethodName)\n\t//     }\n\t//\n\t//\n\t// NOTE: All opentracing.Tracer implementations MUST support all\n\t// BuiltinFormats.\n\t//\n\t// Return values:\n\t//  - A successful Extract returns a SpanContext instance and a nil error\n\t//  - If there was simply no SpanContext to extract in `carrier`, Extract()\n\t//    returns (nil, opentracing.ErrSpanContextNotFound)\n\t//  - If `format` is unsupported or unrecognized, Extract() returns (nil,\n\t//    opentracing.ErrUnsupportedFormat)\n\t//  - If there are more fundamental problems with the `carrier` object,\n\t//    Extract() may return opentracing.ErrInvalidCarrier,\n\t//    opentracing.ErrSpanContextCorrupted, or implementation-specific\n\t//    errors.\n\t//\n\t// See Tracer.Inject().\n\tExtract(format interface{}, carrier interface{}) (SpanContext, error)\n}\n\n// StartSpanOptions allows Tracer.StartSpan() callers and implementors a\n// mechanism to override the start timestamp, specify Span References, and make\n// a single Tag or multiple Tags available at Span start time.\n//\n// StartSpan() callers should look at the StartSpanOption interface and\n// implementations available in this package.\n//\n// Tracer implementations can convert a slice of `StartSpanOption` instances\n// into a `StartSpanOptions` struct like so:\n//\n//     func StartSpan(opName string, opts ...opentracing.StartSpanOption) {\n//         sso := opentracing.StartSpanOptions{}\n//         for _, o := range opts {\n//             o.Apply(&sso)\n//         }\n//         ...\n//     }\n//\ntype StartSpanOptions struct {\n\t// Zero or more causal references to other Spans (via their SpanContext).\n\t// If empty, start a \"root\" Span (i.e., start a new trace).\n\tReferences []SpanReference\n\n\t// StartTime overrides the Span's start time, or implicitly becomes\n\t// time.Now() if StartTime.IsZero().\n\tStartTime time.Time\n\n\t// Tags may have zero or more entries; the restrictions on map values are\n\t// identical to those for Span.SetTag(). May be nil.\n\t//\n\t// If specified, the caller hands off ownership of Tags at\n\t// StartSpan() invocation time.\n\tTags map[string]interface{}\n}\n\n// StartSpanOption instances (zero or more) may be passed to Tracer.StartSpan.\n//\n// StartSpanOption borrows from the \"functional options\" pattern, per\n// http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis\ntype StartSpanOption interface {\n\tApply(*StartSpanOptions)\n}\n\n// SpanReferenceType is an enum type describing different categories of\n// relationships between two Spans. If Span-2 refers to Span-1, the\n// SpanReferenceType describes Span-1 from Span-2's perspective. For example,\n// ChildOfRef means that Span-1 created Span-2.\n//\n// NOTE: Span-1 and Span-2 do *not* necessarily depend on each other for\n// completion; e.g., Span-2 may be part of a background job enqueued by Span-1,\n// or Span-2 may be sitting in a distributed queue behind Span-1.\ntype SpanReferenceType int\n\nconst (\n\t// ChildOfRef refers to a parent Span that caused *and* somehow depends\n\t// upon the new child Span. Often (but not always), the parent Span cannot\n\t// finish until the child Span does.\n\t//\n\t// An timing diagram for a ChildOfRef that's blocked on the new Span:\n\t//\n\t//     [-Parent Span---------]\n\t//          [-Child Span----]\n\t//\n\t// See http://opentracing.io/spec/\n\t//\n\t// See opentracing.ChildOf()\n\tChildOfRef SpanReferenceType = iota\n\n\t// FollowsFromRef refers to a parent Span that does not depend in any way\n\t// on the result of the new child Span. For instance, one might use\n\t// FollowsFromRefs to describe pipeline stages separated by queues,\n\t// or a fire-and-forget cache insert at the tail end of a web request.\n\t//\n\t// A FollowsFromRef Span is part of the same logical trace as the new Span:\n\t// i.e., the new Span is somehow caused by the work of its FollowsFromRef.\n\t//\n\t// All of the following could be valid timing diagrams for children that\n\t// \"FollowFrom\" a parent.\n\t//\n\t//     [-Parent Span-]  [-Child Span-]\n\t//\n\t//\n\t//     [-Parent Span--]\n\t//      [-Child Span-]\n\t//\n\t//\n\t//     [-Parent Span-]\n\t//                 [-Child Span-]\n\t//\n\t// See http://opentracing.io/spec/\n\t//\n\t// See opentracing.FollowsFrom()\n\tFollowsFromRef\n)\n\n// SpanReference is a StartSpanOption that pairs a SpanReferenceType and a\n// referenced SpanContext. See the SpanReferenceType documentation for\n// supported relationships.  If SpanReference is created with\n// ReferencedContext==nil, it has no effect. Thus it allows for a more concise\n// syntax for starting spans:\n//\n//     sc, _ := tracer.Extract(someFormat, someCarrier)\n//     span := tracer.StartSpan(\"operation\", opentracing.ChildOf(sc))\n//\n// The `ChildOf(sc)` option above will not panic if sc == nil, it will just\n// not add the parent span reference to the options.\ntype SpanReference struct {\n\tType              SpanReferenceType\n\tReferencedContext SpanContext\n}\n\n// Apply satisfies the StartSpanOption interface.\nfunc (r SpanReference) Apply(o *StartSpanOptions) {\n\tif r.ReferencedContext != nil {\n\t\to.References = append(o.References, r)\n\t}\n}\n\n// ChildOf returns a StartSpanOption pointing to a dependent parent span.\n// If sc == nil, the option has no effect.\n//\n// See ChildOfRef, SpanReference\nfunc ChildOf(sc SpanContext) SpanReference {\n\treturn SpanReference{\n\t\tType:              ChildOfRef,\n\t\tReferencedContext: sc,\n\t}\n}\n\n// FollowsFrom returns a StartSpanOption pointing to a parent Span that caused\n// the child Span but does not directly depend on its result in any way.\n// If sc == nil, the option has no effect.\n//\n// See FollowsFromRef, SpanReference\nfunc FollowsFrom(sc SpanContext) SpanReference {\n\treturn SpanReference{\n\t\tType:              FollowsFromRef,\n\t\tReferencedContext: sc,\n\t}\n}\n\n// StartTime is a StartSpanOption that sets an explicit start timestamp for the\n// new Span.\ntype StartTime time.Time\n\n// Apply satisfies the StartSpanOption interface.\nfunc (t StartTime) Apply(o *StartSpanOptions) {\n\to.StartTime = time.Time(t)\n}\n\n// Tags are a generic map from an arbitrary string key to an opaque value type.\n// The underlying tracing system is responsible for interpreting and\n// serializing the values.\ntype Tags map[string]interface{}\n\n// Apply satisfies the StartSpanOption interface.\nfunc (t Tags) Apply(o *StartSpanOptions) {\n\tif o.Tags == nil {\n\t\to.Tags = make(map[string]interface{})\n\t}\n\tfor k, v := range t {\n\t\to.Tags[k] = v\n\t}\n}\n\n// Tag may be passed as a StartSpanOption to add a tag to new spans,\n// or its Set method may be used to apply the tag to an existing Span,\n// for example:\n//\n// tracer.StartSpan(\"opName\", Tag{\"Key\", value})\n//\n//   or\n//\n// Tag{\"key\", value}.Set(span)\ntype Tag struct {\n\tKey   string\n\tValue interface{}\n}\n\n// Apply satisfies the StartSpanOption interface.\nfunc (t Tag) Apply(o *StartSpanOptions) {\n\tif o.Tags == nil {\n\t\to.Tags = make(map[string]interface{})\n\t}\n\to.Tags[t.Key] = t.Value\n}\n\n// Set applies the tag to an existing Span.\nfunc (t Tag) Set(s Span) {\n\ts.SetTag(t.Key, t.Value)\n}\n"
        }
      ]
    }
  ]
}