{
  "metadata": {
    "timestamp": 1736567192309,
    "page": 788,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tidwall/sjson",
      "stars": 2479,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Josh Baker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.2900390625,
          "content": "<p align=\"center\">\n<img \n    src=\"logo.png\" \n    width=\"240\" height=\"78\" border=\"0\" alt=\"SJSON\">\n<br>\n<a href=\"https://godoc.org/github.com/tidwall/sjson\"><img src=\"https://img.shields.io/badge/api-reference-blue.svg?style=flat-square\" alt=\"GoDoc\"></a>\n</p>\n\n<p align=\"center\">set a json value quickly</p>\n\nSJSON is a Go package that provides a [very fast](#performance) and simple way to set a value in a json document.\nFor quickly retrieving json values check out [GJSON](https://github.com/tidwall/gjson).\n\nFor a command line interface check out [JJ](https://github.com/tidwall/jj).\n\nGetting Started\n===============\n\nInstalling\n----------\n\nTo start using SJSON, install Go and run `go get`:\n\n```sh\n$ go get -u github.com/tidwall/sjson\n```\n\nThis will retrieve the library.\n\nSet a value\n-----------\nSet sets the value for the specified path. \nA path is in dot syntax, such as \"name.last\" or \"age\". \nThis function expects that the json is well-formed and validated. \nInvalid json will not panic, but it may return back unexpected results.\nInvalid paths may return an error.\n\n```go\npackage main\n\nimport \"github.com/tidwall/sjson\"\n\nconst json = `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`\n\nfunc main() {\n\tvalue, _ := sjson.Set(json, \"name.last\", \"Anderson\")\n\tprintln(value)\n}\n```\n\nThis will print:\n\n```json\n{\"name\":{\"first\":\"Janet\",\"last\":\"Anderson\"},\"age\":47}\n```\n\nPath syntax\n-----------\n\nA path is a series of keys separated by a dot.\nThe dot and colon characters can be escaped with ``\\``.\n\n```json\n{\n  \"name\": {\"first\": \"Tom\", \"last\": \"Anderson\"},\n  \"age\":37,\n  \"children\": [\"Sara\",\"Alex\",\"Jack\"],\n  \"fav.movie\": \"Deer Hunter\",\n  \"friends\": [\n\t{\"first\": \"James\", \"last\": \"Murphy\"},\n\t{\"first\": \"Roger\", \"last\": \"Craig\"}\n  ]\n}\n```\n```\n\"name.last\"          >> \"Anderson\"\n\"age\"                >> 37\n\"children.1\"         >> \"Alex\"\n\"friends.1.last\"     >> \"Craig\"\n```\n\nThe `-1` key can be used to append a value to an existing array:\n\n```\n\"children.-1\"  >> appends a new value to the end of the children array\n```\n\nNormally number keys are used to modify arrays, but it's possible to force a numeric object key by using the colon character:\n\n```json\n{\n  \"users\":{\n    \"2313\":{\"name\":\"Sara\"},\n    \"7839\":{\"name\":\"Andy\"}\n  }\n}\n```\n\nA colon path would look like:\n\n```\n\"users.:2313.name\"    >> \"Sara\"\n```\n\nSupported types\n---------------\n\nPretty much any type is supported:\n\n```go\nsjson.Set(`{\"key\":true}`, \"key\", nil)\nsjson.Set(`{\"key\":true}`, \"key\", false)\nsjson.Set(`{\"key\":true}`, \"key\", 1)\nsjson.Set(`{\"key\":true}`, \"key\", 10.5)\nsjson.Set(`{\"key\":true}`, \"key\", \"hello\")\nsjson.Set(`{\"key\":true}`, \"key\", []string{\"hello\", \"world\"})\nsjson.Set(`{\"key\":true}`, \"key\", map[string]interface{}{\"hello\":\"world\"})\n```\n\nWhen a type is not recognized, SJSON will fallback to the `encoding/json` Marshaller.\n\n\nExamples\n--------\n\nSet a value from empty document:\n```go\nvalue, _ := sjson.Set(\"\", \"name\", \"Tom\")\nprintln(value)\n\n// Output:\n// {\"name\":\"Tom\"}\n```\n\nSet a nested value from empty document:\n```go\nvalue, _ := sjson.Set(\"\", \"name.last\", \"Anderson\")\nprintln(value)\n\n// Output:\n// {\"name\":{\"last\":\"Anderson\"}}\n```\n\nSet a new value:\n```go\nvalue, _ := sjson.Set(`{\"name\":{\"last\":\"Anderson\"}}`, \"name.first\", \"Sara\")\nprintln(value)\n\n// Output:\n// {\"name\":{\"first\":\"Sara\",\"last\":\"Anderson\"}}\n```\n\nUpdate an existing value:\n```go\nvalue, _ := sjson.Set(`{\"name\":{\"last\":\"Anderson\"}}`, \"name.last\", \"Smith\")\nprintln(value)\n\n// Output:\n// {\"name\":{\"last\":\"Smith\"}}\n```\n\nSet a new array value:\n```go\nvalue, _ := sjson.Set(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.2\", \"Sara\")\nprintln(value)\n\n// Output:\n// {\"friends\":[\"Andy\",\"Carol\",\"Sara\"]\n```\n\nAppend an array value by using the `-1` key in a path:\n```go\nvalue, _ := sjson.Set(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.-1\", \"Sara\")\nprintln(value)\n\n// Output:\n// {\"friends\":[\"Andy\",\"Carol\",\"Sara\"]\n```\n\nAppend an array value that is past the end:\n```go\nvalue, _ := sjson.Set(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.4\", \"Sara\")\nprintln(value)\n\n// Output:\n// {\"friends\":[\"Andy\",\"Carol\",null,null,\"Sara\"]\n```\n\nDelete a value:\n```go\nvalue, _ := sjson.Delete(`{\"name\":{\"first\":\"Sara\",\"last\":\"Anderson\"}}`, \"name.first\")\nprintln(value)\n\n// Output:\n// {\"name\":{\"last\":\"Anderson\"}}\n```\n\nDelete an array value:\n```go\nvalue, _ := sjson.Delete(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.1\")\nprintln(value)\n\n// Output:\n// {\"friends\":[\"Andy\"]}\n```\n\nDelete the last array value:\n```go\nvalue, _ := sjson.Delete(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.-1\")\nprintln(value)\n\n// Output:\n// {\"friends\":[\"Andy\"]}\n```\n\n## Performance\n\nBenchmarks of SJSON alongside [encoding/json](https://golang.org/pkg/encoding/json/), \n[ffjson](https://github.com/pquerna/ffjson), \n[EasyJSON](https://github.com/mailru/easyjson),\nand [Gabs](https://github.com/Jeffail/gabs)\n\n```\nBenchmark_SJSON-8                  \t 3000000\t       805 ns/op\t    1077 B/op\t       3 allocs/op\nBenchmark_SJSON_ReplaceInPlace-8   \t 3000000\t       449 ns/op\t       0 B/op\t       0 allocs/op\nBenchmark_JSON_Map-8               \t  300000\t     21236 ns/op\t    6392 B/op\t     150 allocs/op\nBenchmark_JSON_Struct-8            \t  300000\t     14691 ns/op\t    1789 B/op\t      24 allocs/op\nBenchmark_Gabs-8                   \t  300000\t     21311 ns/op\t    6752 B/op\t     150 allocs/op\nBenchmark_FFJSON-8                 \t  300000\t     17673 ns/op\t    3589 B/op\t      47 allocs/op\nBenchmark_EasyJSON-8               \t 1500000\t      3119 ns/op\t    1061 B/op\t      13 allocs/op\n```\n\nJSON document used:\n\n```json\n{\n  \"widget\": {\n    \"debug\": \"on\",\n    \"window\": {\n      \"title\": \"Sample Konfabulator Widget\",\n      \"name\": \"main_window\",\n      \"width\": 500,\n      \"height\": 500\n    },\n    \"image\": { \n      \"src\": \"Images/Sun.png\",\n      \"hOffset\": 250,\n      \"vOffset\": 250,\n      \"alignment\": \"center\"\n    },\n    \"text\": {\n      \"data\": \"Click Here\",\n      \"size\": 36,\n      \"style\": \"bold\",\n      \"vOffset\": 100,\n      \"alignment\": \"center\",\n      \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\"\n    }\n  }\n}    \n```\n\nEach operation was rotated though one of the following search paths:\n\n```\nwidget.window.name\nwidget.image.hOffset\nwidget.text.onMouseUp\n```\n\n*These benchmarks were run on a MacBook Pro 15\" 2.8 GHz Intel Core i7 using Go 1.7 and can be be found [here](https://github.com/tidwall/sjson-benchmarks)*.\n\n## Contact\nJosh Baker [@tidwall](http://twitter.com/tidwall)\n\n## License\n\nSJSON source code is available under the MIT [License](/LICENSE).\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.119140625,
          "content": "module github.com/tidwall/sjson\n\ngo 1.14\n\nrequire (\n\tgithub.com/tidwall/gjson v1.14.2\n\tgithub.com/tidwall/pretty v1.2.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.4931640625,
          "content": "github.com/tidwall/gjson v1.14.2 h1:6BBkirS0rAHjumnjHF6qgy5d2YAJ1TLIaFE2lzfOLqo=\ngithub.com/tidwall/gjson v1.14.2/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=\ngithub.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=\ngithub.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=\ngithub.com/tidwall/pretty v1.2.0 h1:RWIZEg2iJ8/g6fDDYzMpobmaoGh5OLl4AXtGUGPcqCs=\ngithub.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 16.478515625,
          "content": null
        },
        {
          "name": "sjson.go",
          "type": "blob",
          "size": 18.234375,
          "content": "// Package sjson provides setting json values.\npackage sjson\n\nimport (\n\tjsongo \"encoding/json\"\n\t\"sort\"\n\t\"strconv\"\n\t\"unsafe\"\n\n\t\"github.com/tidwall/gjson\"\n)\n\ntype errorType struct {\n\tmsg string\n}\n\nfunc (err *errorType) Error() string {\n\treturn err.msg\n}\n\n// Options represents additional options for the Set and Delete functions.\ntype Options struct {\n\t// Optimistic is a hint that the value likely exists which\n\t// allows for the sjson to perform a fast-track search and replace.\n\tOptimistic bool\n\t// ReplaceInPlace is a hint to replace the input json rather than\n\t// allocate a new json byte slice. When this field is specified\n\t// the input json will not longer be valid and it should not be used\n\t// In the case when the destination slice doesn't have enough free\n\t// bytes to replace the data in place, a new bytes slice will be\n\t// created under the hood.\n\t// The Optimistic flag must be set to true and the input must be a\n\t// byte slice in order to use this field.\n\tReplaceInPlace bool\n}\n\ntype pathResult struct {\n\tpart  string // current key part\n\tgpart string // gjson get part\n\tpath  string // remaining path\n\tforce bool   // force a string key\n\tmore  bool   // there is more path to parse\n}\n\nfunc isSimpleChar(ch byte) bool {\n\tswitch ch {\n\tcase '|', '#', '@', '*', '?':\n\t\treturn false\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc parsePath(path string) (res pathResult, simple bool) {\n\tvar r pathResult\n\tif len(path) > 0 && path[0] == ':' {\n\t\tr.force = true\n\t\tpath = path[1:]\n\t}\n\tfor i := 0; i < len(path); i++ {\n\t\tif path[i] == '.' {\n\t\t\tr.part = path[:i]\n\t\t\tr.gpart = path[:i]\n\t\t\tr.path = path[i+1:]\n\t\t\tr.more = true\n\t\t\treturn r, true\n\t\t}\n\t\tif !isSimpleChar(path[i]) {\n\t\t\treturn r, false\n\t\t}\n\t\tif path[i] == '\\\\' {\n\t\t\t// go into escape mode. this is a slower path that\n\t\t\t// strips off the escape character from the part.\n\t\t\tepart := []byte(path[:i])\n\t\t\tgpart := []byte(path[:i+1])\n\t\t\ti++\n\t\t\tif i < len(path) {\n\t\t\t\tepart = append(epart, path[i])\n\t\t\t\tgpart = append(gpart, path[i])\n\t\t\t\ti++\n\t\t\t\tfor ; i < len(path); i++ {\n\t\t\t\t\tif path[i] == '\\\\' {\n\t\t\t\t\t\tgpart = append(gpart, '\\\\')\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tif i < len(path) {\n\t\t\t\t\t\t\tepart = append(epart, path[i])\n\t\t\t\t\t\t\tgpart = append(gpart, path[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else if path[i] == '.' {\n\t\t\t\t\t\tr.part = string(epart)\n\t\t\t\t\t\tr.gpart = string(gpart)\n\t\t\t\t\t\tr.path = path[i+1:]\n\t\t\t\t\t\tr.more = true\n\t\t\t\t\t\treturn r, true\n\t\t\t\t\t} else if !isSimpleChar(path[i]) {\n\t\t\t\t\t\treturn r, false\n\t\t\t\t\t}\n\t\t\t\t\tepart = append(epart, path[i])\n\t\t\t\t\tgpart = append(gpart, path[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\t// append the last part\n\t\t\tr.part = string(epart)\n\t\t\tr.gpart = string(gpart)\n\t\t\treturn r, true\n\t\t}\n\t}\n\tr.part = path\n\tr.gpart = path\n\treturn r, true\n}\n\nfunc mustMarshalString(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] < ' ' || s[i] > 0x7f || s[i] == '\"' || s[i] == '\\\\' {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// appendStringify makes a json string and appends to buf.\nfunc appendStringify(buf []byte, s string) []byte {\n\tif mustMarshalString(s) {\n\t\tb, _ := jsongo.Marshal(s)\n\t\treturn append(buf, b...)\n\t}\n\tbuf = append(buf, '\"')\n\tbuf = append(buf, s...)\n\tbuf = append(buf, '\"')\n\treturn buf\n}\n\n// appendBuild builds a json block from a json path.\nfunc appendBuild(buf []byte, array bool, paths []pathResult, raw string,\n\tstringify bool) []byte {\n\tif !array {\n\t\tbuf = appendStringify(buf, paths[0].part)\n\t\tbuf = append(buf, ':')\n\t}\n\tif len(paths) > 1 {\n\t\tn, numeric := atoui(paths[1])\n\t\tif numeric || (!paths[1].force && paths[1].part == \"-1\") {\n\t\t\tbuf = append(buf, '[')\n\t\t\tbuf = appendRepeat(buf, \"null,\", n)\n\t\t\tbuf = appendBuild(buf, true, paths[1:], raw, stringify)\n\t\t\tbuf = append(buf, ']')\n\t\t} else {\n\t\t\tbuf = append(buf, '{')\n\t\t\tbuf = appendBuild(buf, false, paths[1:], raw, stringify)\n\t\t\tbuf = append(buf, '}')\n\t\t}\n\t} else {\n\t\tif stringify {\n\t\t\tbuf = appendStringify(buf, raw)\n\t\t} else {\n\t\t\tbuf = append(buf, raw...)\n\t\t}\n\t}\n\treturn buf\n}\n\n// atoui does a rip conversion of string -> unigned int.\nfunc atoui(r pathResult) (n int, ok bool) {\n\tif r.force {\n\t\treturn 0, false\n\t}\n\tfor i := 0; i < len(r.part); i++ {\n\t\tif r.part[i] < '0' || r.part[i] > '9' {\n\t\t\treturn 0, false\n\t\t}\n\t\tn = n*10 + int(r.part[i]-'0')\n\t}\n\treturn n, true\n}\n\n// appendRepeat repeats string \"n\" times and appends to buf.\nfunc appendRepeat(buf []byte, s string, n int) []byte {\n\tfor i := 0; i < n; i++ {\n\t\tbuf = append(buf, s...)\n\t}\n\treturn buf\n}\n\n// trim does a rip trim\nfunc trim(s string) string {\n\tfor len(s) > 0 {\n\t\tif s[0] <= ' ' {\n\t\t\ts = s[1:]\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\tfor len(s) > 0 {\n\t\tif s[len(s)-1] <= ' ' {\n\t\t\ts = s[:len(s)-1]\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\treturn s\n}\n\n// deleteTailItem deletes the previous key or comma.\nfunc deleteTailItem(buf []byte) ([]byte, bool) {\nloop:\n\tfor i := len(buf) - 1; i >= 0; i-- {\n\t\t// look for either a ',',':','['\n\t\tswitch buf[i] {\n\t\tcase '[':\n\t\t\treturn buf, true\n\t\tcase ',':\n\t\t\treturn buf[:i], false\n\t\tcase ':':\n\t\t\t// delete tail string\n\t\t\ti--\n\t\t\tfor ; i >= 0; i-- {\n\t\t\t\tif buf[i] == '\"' {\n\t\t\t\t\ti--\n\t\t\t\t\tfor ; i >= 0; i-- {\n\t\t\t\t\t\tif buf[i] == '\"' {\n\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\tif i >= 0 && buf[i] == '\\\\' {\n\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ; i >= 0; i-- {\n\t\t\t\t\t\t\t\t// look for either a ',','{'\n\t\t\t\t\t\t\t\tswitch buf[i] {\n\t\t\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\t\t\treturn buf[:i+1], true\n\t\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\t\treturn buf[:i], false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak loop\n\t\t}\n\t}\n\treturn buf, false\n}\n\nvar errNoChange = &errorType{\"no change\"}\n\nfunc appendRawPaths(buf []byte, jstr string, paths []pathResult, raw string,\n\tstringify, del bool) ([]byte, error) {\n\tvar err error\n\tvar res gjson.Result\n\tvar found bool\n\tif del {\n\t\tif paths[0].part == \"-1\" && !paths[0].force {\n\t\t\tres = gjson.Get(jstr, \"#\")\n\t\t\tif res.Int() > 0 {\n\t\t\t\tres = gjson.Get(jstr, strconv.FormatInt(int64(res.Int()-1), 10))\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t}\n\tif !found {\n\t\tres = gjson.Get(jstr, paths[0].gpart)\n\t}\n\tif res.Index > 0 {\n\t\tif len(paths) > 1 {\n\t\t\tbuf = append(buf, jstr[:res.Index]...)\n\t\t\tbuf, err = appendRawPaths(buf, res.Raw, paths[1:], raw,\n\t\t\t\tstringify, del)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tbuf = append(buf, jstr[res.Index+len(res.Raw):]...)\n\t\t\treturn buf, nil\n\t\t}\n\t\tbuf = append(buf, jstr[:res.Index]...)\n\t\tvar exidx int // additional forward stripping\n\t\tif del {\n\t\t\tvar delNextComma bool\n\t\t\tbuf, delNextComma = deleteTailItem(buf)\n\t\t\tif delNextComma {\n\t\t\t\ti, j := res.Index+len(res.Raw), 0\n\t\t\t\tfor ; i < len(jstr); i, j = i+1, j+1 {\n\t\t\t\t\tif jstr[i] <= ' ' {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif jstr[i] == ',' {\n\t\t\t\t\t\texidx = j + 1\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif stringify {\n\t\t\t\tbuf = appendStringify(buf, raw)\n\t\t\t} else {\n\t\t\t\tbuf = append(buf, raw...)\n\t\t\t}\n\t\t}\n\t\tbuf = append(buf, jstr[res.Index+len(res.Raw)+exidx:]...)\n\t\treturn buf, nil\n\t}\n\tif del {\n\t\treturn nil, errNoChange\n\t}\n\tn, numeric := atoui(paths[0])\n\tisempty := true\n\tfor i := 0; i < len(jstr); i++ {\n\t\tif jstr[i] > ' ' {\n\t\t\tisempty = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif isempty {\n\t\tif numeric {\n\t\t\tjstr = \"[]\"\n\t\t} else {\n\t\t\tjstr = \"{}\"\n\t\t}\n\t}\n\tjsres := gjson.Parse(jstr)\n\tif jsres.Type != gjson.JSON {\n\t\tif numeric {\n\t\t\tjstr = \"[]\"\n\t\t} else {\n\t\t\tjstr = \"{}\"\n\t\t}\n\t\tjsres = gjson.Parse(jstr)\n\t}\n\tvar comma bool\n\tfor i := 1; i < len(jsres.Raw); i++ {\n\t\tif jsres.Raw[i] <= ' ' {\n\t\t\tcontinue\n\t\t}\n\t\tif jsres.Raw[i] == '}' || jsres.Raw[i] == ']' {\n\t\t\tbreak\n\t\t}\n\t\tcomma = true\n\t\tbreak\n\t}\n\tswitch jsres.Raw[0] {\n\tdefault:\n\t\treturn nil, &errorType{\"json must be an object or array\"}\n\tcase '{':\n\t\tend := len(jsres.Raw) - 1\n\t\tfor ; end > 0; end-- {\n\t\t\tif jsres.Raw[end] == '}' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tbuf = append(buf, jsres.Raw[:end]...)\n\t\tif comma {\n\t\t\tbuf = append(buf, ',')\n\t\t}\n\t\tbuf = appendBuild(buf, false, paths, raw, stringify)\n\t\tbuf = append(buf, '}')\n\t\treturn buf, nil\n\tcase '[':\n\t\tvar appendit bool\n\t\tif !numeric {\n\t\t\tif paths[0].part == \"-1\" && !paths[0].force {\n\t\t\t\tappendit = true\n\t\t\t} else {\n\t\t\t\treturn nil, &errorType{\n\t\t\t\t\t\"cannot set array element for non-numeric key '\" +\n\t\t\t\t\t\tpaths[0].part + \"'\"}\n\t\t\t}\n\t\t}\n\t\tif appendit {\n\t\t\tnjson := trim(jsres.Raw)\n\t\t\tif njson[len(njson)-1] == ']' {\n\t\t\t\tnjson = njson[:len(njson)-1]\n\t\t\t}\n\t\t\tbuf = append(buf, njson...)\n\t\t\tif comma {\n\t\t\t\tbuf = append(buf, ',')\n\t\t\t}\n\n\t\t\tbuf = appendBuild(buf, true, paths, raw, stringify)\n\t\t\tbuf = append(buf, ']')\n\t\t\treturn buf, nil\n\t\t}\n\t\tbuf = append(buf, '[')\n\t\tress := jsres.Array()\n\t\tfor i := 0; i < len(ress); i++ {\n\t\t\tif i > 0 {\n\t\t\t\tbuf = append(buf, ',')\n\t\t\t}\n\t\t\tbuf = append(buf, ress[i].Raw...)\n\t\t}\n\t\tif len(ress) == 0 {\n\t\t\tbuf = appendRepeat(buf, \"null,\", n-len(ress))\n\t\t} else {\n\t\t\tbuf = appendRepeat(buf, \",null\", n-len(ress))\n\t\t\tif comma {\n\t\t\t\tbuf = append(buf, ',')\n\t\t\t}\n\t\t}\n\t\tbuf = appendBuild(buf, true, paths, raw, stringify)\n\t\tbuf = append(buf, ']')\n\t\treturn buf, nil\n\t}\n}\n\nfunc isOptimisticPath(path string) bool {\n\tfor i := 0; i < len(path); i++ {\n\t\tif path[i] < '.' || path[i] > 'z' {\n\t\t\treturn false\n\t\t}\n\t\tif path[i] > '9' && path[i] < 'A' {\n\t\t\treturn false\n\t\t}\n\t\tif path[i] > 'z' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Set sets a json value for the specified path.\n// A path is in dot syntax, such as \"name.last\" or \"age\".\n// This function expects that the json is well-formed, and does not validate.\n// Invalid json will not panic, but it may return back unexpected results.\n// An error is returned if the path is not valid.\n//\n// A path is a series of keys separated by a dot.\n//\n//  {\n//    \"name\": {\"first\": \"Tom\", \"last\": \"Anderson\"},\n//    \"age\":37,\n//    \"children\": [\"Sara\",\"Alex\",\"Jack\"],\n//    \"friends\": [\n//      {\"first\": \"James\", \"last\": \"Murphy\"},\n//      {\"first\": \"Roger\", \"last\": \"Craig\"}\n//    ]\n//  }\n//  \"name.last\"          >> \"Anderson\"\n//  \"age\"                >> 37\n//  \"children.1\"         >> \"Alex\"\n//\nfunc Set(json, path string, value interface{}) (string, error) {\n\treturn SetOptions(json, path, value, nil)\n}\n\n// SetBytes sets a json value for the specified path.\n// If working with bytes, this method preferred over\n// Set(string(data), path, value)\nfunc SetBytes(json []byte, path string, value interface{}) ([]byte, error) {\n\treturn SetBytesOptions(json, path, value, nil)\n}\n\n// SetRaw sets a raw json value for the specified path.\n// This function works the same as Set except that the value is set as a\n// raw block of json. This allows for setting premarshalled json objects.\nfunc SetRaw(json, path, value string) (string, error) {\n\treturn SetRawOptions(json, path, value, nil)\n}\n\n// SetRawOptions sets a raw json value for the specified path with options.\n// This furnction works the same as SetOptions except that the value is set\n// as a raw block of json. This allows for setting premarshalled json objects.\nfunc SetRawOptions(json, path, value string, opts *Options) (string, error) {\n\tvar optimistic bool\n\tif opts != nil {\n\t\toptimistic = opts.Optimistic\n\t}\n\tres, err := set(json, path, value, false, false, optimistic, false)\n\tif err == errNoChange {\n\t\treturn json, nil\n\t}\n\treturn string(res), err\n}\n\n// SetRawBytes sets a raw json value for the specified path.\n// If working with bytes, this method preferred over\n// SetRaw(string(data), path, value)\nfunc SetRawBytes(json []byte, path string, value []byte) ([]byte, error) {\n\treturn SetRawBytesOptions(json, path, value, nil)\n}\n\ntype dtype struct{}\n\n// Delete deletes a value from json for the specified path.\nfunc Delete(json, path string) (string, error) {\n\treturn Set(json, path, dtype{})\n}\n\n// DeleteBytes deletes a value from json for the specified path.\nfunc DeleteBytes(json []byte, path string) ([]byte, error) {\n\treturn SetBytes(json, path, dtype{})\n}\n\ntype stringHeader struct {\n\tdata unsafe.Pointer\n\tlen  int\n}\n\ntype sliceHeader struct {\n\tdata unsafe.Pointer\n\tlen  int\n\tcap  int\n}\n\nfunc set(jstr, path, raw string,\n\tstringify, del, optimistic, inplace bool) ([]byte, error) {\n\tif path == \"\" {\n\t\treturn []byte(jstr), &errorType{\"path cannot be empty\"}\n\t}\n\tif !del && optimistic && isOptimisticPath(path) {\n\t\tres := gjson.Get(jstr, path)\n\t\tif res.Exists() && res.Index > 0 {\n\t\t\tsz := len(jstr) - len(res.Raw) + len(raw)\n\t\t\tif stringify {\n\t\t\t\tsz += 2\n\t\t\t}\n\t\t\tif inplace && sz <= len(jstr) {\n\t\t\t\tif !stringify || !mustMarshalString(raw) {\n\t\t\t\t\tjsonh := *(*stringHeader)(unsafe.Pointer(&jstr))\n\t\t\t\t\tjsonbh := sliceHeader{\n\t\t\t\t\t\tdata: jsonh.data, len: jsonh.len, cap: jsonh.len}\n\t\t\t\t\tjbytes := *(*[]byte)(unsafe.Pointer(&jsonbh))\n\t\t\t\t\tif stringify {\n\t\t\t\t\t\tjbytes[res.Index] = '\"'\n\t\t\t\t\t\tcopy(jbytes[res.Index+1:], []byte(raw))\n\t\t\t\t\t\tjbytes[res.Index+1+len(raw)] = '\"'\n\t\t\t\t\t\tcopy(jbytes[res.Index+1+len(raw)+1:],\n\t\t\t\t\t\t\tjbytes[res.Index+len(res.Raw):])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcopy(jbytes[res.Index:], []byte(raw))\n\t\t\t\t\t\tcopy(jbytes[res.Index+len(raw):],\n\t\t\t\t\t\t\tjbytes[res.Index+len(res.Raw):])\n\t\t\t\t\t}\n\t\t\t\t\treturn jbytes[:sz], nil\n\t\t\t\t}\n\t\t\t\treturn []byte(jstr), nil\n\t\t\t}\n\t\t\tbuf := make([]byte, 0, sz)\n\t\t\tbuf = append(buf, jstr[:res.Index]...)\n\t\t\tif stringify {\n\t\t\t\tbuf = appendStringify(buf, raw)\n\t\t\t} else {\n\t\t\t\tbuf = append(buf, raw...)\n\t\t\t}\n\t\t\tbuf = append(buf, jstr[res.Index+len(res.Raw):]...)\n\t\t\treturn buf, nil\n\t\t}\n\t}\n\tvar paths []pathResult\n\tr, simple := parsePath(path)\n\tif simple {\n\t\tpaths = append(paths, r)\n\t\tfor r.more {\n\t\t\tr, simple = parsePath(r.path)\n\t\t\tif !simple {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tpaths = append(paths, r)\n\t\t}\n\t}\n\tif !simple {\n\t\tif del {\n\t\t\treturn []byte(jstr),\n\t\t\t\t&errorType{\"cannot delete value from a complex path\"}\n\t\t}\n\t\treturn setComplexPath(jstr, path, raw, stringify)\n\t}\n\tnjson, err := appendRawPaths(nil, jstr, paths, raw, stringify, del)\n\tif err != nil {\n\t\treturn []byte(jstr), err\n\t}\n\treturn njson, nil\n}\n\nfunc setComplexPath(jstr, path, raw string, stringify bool) ([]byte, error) {\n\tres := gjson.Get(jstr, path)\n\tif !res.Exists() || !(res.Index != 0 || len(res.Indexes) != 0) {\n\t\treturn []byte(jstr), errNoChange\n\t}\n\tif res.Index != 0 {\n\t\tnjson := []byte(jstr[:res.Index])\n\t\tif stringify {\n\t\t\tnjson = appendStringify(njson, raw)\n\t\t} else {\n\t\t\tnjson = append(njson, raw...)\n\t\t}\n\t\tnjson = append(njson, jstr[res.Index+len(res.Raw):]...)\n\t\tjstr = string(njson)\n\t}\n\tif len(res.Indexes) > 0 {\n\t\ttype val struct {\n\t\t\tindex int\n\t\t\tres   gjson.Result\n\t\t}\n\t\tvals := make([]val, 0, len(res.Indexes))\n\t\tres.ForEach(func(_, vres gjson.Result) bool {\n\t\t\tvals = append(vals, val{res: vres})\n\t\t\treturn true\n\t\t})\n\t\tif len(res.Indexes) != len(vals) {\n\t\t\treturn []byte(jstr), errNoChange\n\t\t}\n\t\tfor i := 0; i < len(res.Indexes); i++ {\n\t\t\tvals[i].index = res.Indexes[i]\n\t\t}\n\t\tsort.SliceStable(vals, func(i, j int) bool {\n\t\t\treturn vals[i].index > vals[j].index\n\t\t})\n\t\tfor _, val := range vals {\n\t\t\tvres := val.res\n\t\t\tindex := val.index\n\t\t\tnjson := []byte(jstr[:index])\n\t\t\tif stringify {\n\t\t\t\tnjson = appendStringify(njson, raw)\n\t\t\t} else {\n\t\t\t\tnjson = append(njson, raw...)\n\t\t\t}\n\t\t\tnjson = append(njson, jstr[index+len(vres.Raw):]...)\n\t\t\tjstr = string(njson)\n\t\t}\n\t}\n\treturn []byte(jstr), nil\n}\n\n// SetOptions sets a json value for the specified path with options.\n// A path is in dot syntax, such as \"name.last\" or \"age\".\n// This function expects that the json is well-formed, and does not validate.\n// Invalid json will not panic, but it may return back unexpected results.\n// An error is returned if the path is not valid.\nfunc SetOptions(json, path string, value interface{},\n\topts *Options) (string, error) {\n\tif opts != nil {\n\t\tif opts.ReplaceInPlace {\n\t\t\t// it's not safe to replace bytes in-place for strings\n\t\t\t// copy the Options and set options.ReplaceInPlace to false.\n\t\t\tnopts := *opts\n\t\t\topts = &nopts\n\t\t\topts.ReplaceInPlace = false\n\t\t}\n\t}\n\tjsonh := *(*stringHeader)(unsafe.Pointer(&json))\n\tjsonbh := sliceHeader{data: jsonh.data, len: jsonh.len, cap: jsonh.len}\n\tjsonb := *(*[]byte)(unsafe.Pointer(&jsonbh))\n\tres, err := SetBytesOptions(jsonb, path, value, opts)\n\treturn string(res), err\n}\n\n// SetBytesOptions sets a json value for the specified path with options.\n// If working with bytes, this method preferred over\n// SetOptions(string(data), path, value)\nfunc SetBytesOptions(json []byte, path string, value interface{},\n\topts *Options) ([]byte, error) {\n\tvar optimistic, inplace bool\n\tif opts != nil {\n\t\toptimistic = opts.Optimistic\n\t\tinplace = opts.ReplaceInPlace\n\t}\n\tjstr := *(*string)(unsafe.Pointer(&json))\n\tvar res []byte\n\tvar err error\n\tswitch v := value.(type) {\n\tdefault:\n\t\tb, merr := jsongo.Marshal(value)\n\t\tif merr != nil {\n\t\t\treturn nil, merr\n\t\t}\n\t\traw := *(*string)(unsafe.Pointer(&b))\n\t\tres, err = set(jstr, path, raw, false, false, optimistic, inplace)\n\tcase dtype:\n\t\tres, err = set(jstr, path, \"\", false, true, optimistic, inplace)\n\tcase string:\n\t\tres, err = set(jstr, path, v, true, false, optimistic, inplace)\n\tcase []byte:\n\t\traw := *(*string)(unsafe.Pointer(&v))\n\t\tres, err = set(jstr, path, raw, true, false, optimistic, inplace)\n\tcase bool:\n\t\tif v {\n\t\t\tres, err = set(jstr, path, \"true\", false, false, optimistic, inplace)\n\t\t} else {\n\t\t\tres, err = set(jstr, path, \"false\", false, false, optimistic, inplace)\n\t\t}\n\tcase int8:\n\t\tres, err = set(jstr, path, strconv.FormatInt(int64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase int16:\n\t\tres, err = set(jstr, path, strconv.FormatInt(int64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase int32:\n\t\tres, err = set(jstr, path, strconv.FormatInt(int64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase int64:\n\t\tres, err = set(jstr, path, strconv.FormatInt(int64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase uint8:\n\t\tres, err = set(jstr, path, strconv.FormatUint(uint64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase uint16:\n\t\tres, err = set(jstr, path, strconv.FormatUint(uint64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase uint32:\n\t\tres, err = set(jstr, path, strconv.FormatUint(uint64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase uint64:\n\t\tres, err = set(jstr, path, strconv.FormatUint(uint64(v), 10),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase float32:\n\t\tres, err = set(jstr, path, strconv.FormatFloat(float64(v), 'f', -1, 64),\n\t\t\tfalse, false, optimistic, inplace)\n\tcase float64:\n\t\tres, err = set(jstr, path, strconv.FormatFloat(float64(v), 'f', -1, 64),\n\t\t\tfalse, false, optimistic, inplace)\n\t}\n\tif err == errNoChange {\n\t\treturn json, nil\n\t}\n\treturn res, err\n}\n\n// SetRawBytesOptions sets a raw json value for the specified path with options.\n// If working with bytes, this method preferred over\n// SetRawOptions(string(data), path, value, opts)\nfunc SetRawBytesOptions(json []byte, path string, value []byte,\n\topts *Options) ([]byte, error) {\n\tjstr := *(*string)(unsafe.Pointer(&json))\n\tvstr := *(*string)(unsafe.Pointer(&value))\n\tvar optimistic, inplace bool\n\tif opts != nil {\n\t\toptimistic = opts.Optimistic\n\t\tinplace = opts.ReplaceInPlace\n\t}\n\tres, err := set(jstr, path, vstr, false, false, optimistic, inplace)\n\tif err == errNoChange {\n\t\treturn json, nil\n\t}\n\treturn res, err\n}\n"
        },
        {
          "name": "sjson_test.go",
          "type": "blob",
          "size": 9.7412109375,
          "content": "package sjson\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/tidwall/gjson\"\n\t\"github.com/tidwall/pretty\"\n)\n\nconst (\n\tsetRaw    = 1\n\tsetBool   = 2\n\tsetInt    = 3\n\tsetFloat  = 4\n\tsetString = 5\n\tsetDelete = 6\n)\n\nfunc sortJSON(json string) string {\n\topts := pretty.Options{SortKeys: true}\n\treturn string(pretty.Ugly(pretty.PrettyOptions([]byte(json), &opts)))\n}\n\nfunc testRaw(t *testing.T, kind int, expect, json, path string, value interface{}) {\n\tt.Helper()\n\texpect = sortJSON(expect)\n\tvar json2 string\n\tvar err error\n\tswitch kind {\n\tdefault:\n\t\tjson2, err = Set(json, path, value)\n\tcase setRaw:\n\t\tjson2, err = SetRaw(json, path, value.(string))\n\tcase setDelete:\n\t\tjson2, err = Delete(json, path)\n\t}\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tjson2 = sortJSON(json2)\n\tif json2 != expect {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", expect, json2)\n\t}\n\tvar json3 []byte\n\tswitch kind {\n\tdefault:\n\t\tjson3, err = SetBytes([]byte(json), path, value)\n\tcase setRaw:\n\t\tjson3, err = SetRawBytes([]byte(json), path, []byte(value.(string)))\n\tcase setDelete:\n\t\tjson3, err = DeleteBytes([]byte(json), path)\n\t}\n\tjson3 = []byte(sortJSON(string(json3)))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t} else if string(json3) != expect {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", expect, string(json3))\n\t}\n}\nfunc TestBasic(t *testing.T) {\n\ttestRaw(t, setRaw, `[{\"hiw\":\"planet\",\"hi\":\"world\"}]`, `[{\"hi\":\"world\"}]`, \"0.hiw\", `\"planet\"`)\n\ttestRaw(t, setRaw, `[true]`, ``, \"0\", `true`)\n\ttestRaw(t, setRaw, `[null,true]`, ``, \"1\", `true`)\n\ttestRaw(t, setRaw, `[1,null,true]`, `[1]`, \"2\", `true`)\n\ttestRaw(t, setRaw, `[1,true,false]`, `[1,null,false]`, \"1\", `true`)\n\ttestRaw(t, setRaw,\n\t\t`[1,{\"hello\":\"when\",\"this\":[0,null,2]},false]`,\n\t\t`[1,{\"hello\":\"when\",\"this\":[0,1,2]},false]`,\n\t\t\"1.this.1\", `null`)\n\ttestRaw(t, setRaw,\n\t\t`{\"a\":1,\"b\":{\"hello\":\"when\",\"this\":[0,null,2]},\"c\":false}`,\n\t\t`{\"a\":1,\"b\":{\"hello\":\"when\",\"this\":[0,1,2]},\"c\":false}`,\n\t\t\"b.this.1\", `null`)\n\ttestRaw(t, setRaw,\n\t\t`{\"a\":1,\"b\":{\"hello\":\"when\",\"this\":[0,null,2,null,4]},\"c\":false}`,\n\t\t`{\"a\":1,\"b\":{\"hello\":\"when\",\"this\":[0,null,2]},\"c\":false}`,\n\t\t\"b.this.4\", `4`)\n\ttestRaw(t, setRaw,\n\t\t`{\"b\":{\"this\":[null,null,null,null,4]}}`,\n\t\t``,\n\t\t\"b.this.4\", `4`)\n\ttestRaw(t, setRaw,\n\t\t`[null,{\"this\":[null,null,null,null,4]}]`,\n\t\t``,\n\t\t\"1.this.4\", `4`)\n\ttestRaw(t, setRaw,\n\t\t`{\"1\":{\"this\":[null,null,null,null,4]}}`,\n\t\t``,\n\t\t\":1.this.4\", `4`)\n\ttestRaw(t, setRaw,\n\t\t`{\":1\":{\"this\":[null,null,null,null,4]}}`,\n\t\t``,\n\t\t\"\\\\:1.this.4\", `4`)\n\ttestRaw(t, setRaw,\n\t\t`{\":\\\\1\":{\"this\":[null,null,null,null,{\".HI\":4}]}}`,\n\t\t``,\n\t\t\"\\\\:\\\\\\\\1.this.4.\\\\.HI\", `4`)\n\ttestRaw(t, setRaw,\n\t\t`{\"app.token\":\"cde\"}`,\n\t\t`{\"app.token\":\"abc\"}`,\n\t\t\"app\\\\.token\", `\"cde\"`)\n\ttestRaw(t, setRaw,\n\t\t`{\"b\":{\"this\":{\"😇\":\"\"}}}`,\n\t\t``,\n\t\t\"b.this.😇\", `\"\"`)\n\ttestRaw(t, setRaw,\n\t\t`[ 1,2  ,3]`,\n\t\t`  [ 1,2  ] `,\n\t\t\"-1\", `3`)\n\ttestRaw(t, setInt, `[1234]`, ``, `0`, int64(1234))\n\ttestRaw(t, setFloat, `[1234.5]`, ``, `0`, float64(1234.5))\n\ttestRaw(t, setString, `[\"1234.5\"]`, ``, `0`, \"1234.5\")\n\ttestRaw(t, setBool, `[true]`, ``, `0`, true)\n\ttestRaw(t, setBool, `[null]`, ``, `0`, nil)\n\ttestRaw(t, setString, `{\"arr\":[1]}`, ``, `arr.-1`, 1)\n\ttestRaw(t, setString, `{\"a\":\"\\\\\"}`, ``, `a`, \"\\\\\")\n\ttestRaw(t, setString, `{\"a\":\"C:\\\\Windows\\\\System32\"}`, ``, `a`, `C:\\Windows\\System32`)\n}\n\nfunc TestDelete(t *testing.T) {\n\ttestRaw(t, setDelete, `[456]`, `[123,456]`, `0`, nil)\n\ttestRaw(t, setDelete, `[123,789]`, `[123,456,789]`, `1`, nil)\n\ttestRaw(t, setDelete, `[123,456]`, `[123,456,789]`, `-1`, nil)\n\ttestRaw(t, setDelete, `{\"a\":[123,456]}`, `{\"a\":[123,456,789]}`, `a.-1`, nil)\n\ttestRaw(t, setDelete, `{\"and\":\"another\"}`, `{\"this\":\"that\",\"and\":\"another\"}`, `this`, nil)\n\ttestRaw(t, setDelete, `{\"this\":\"that\"}`, `{\"this\":\"that\",\"and\":\"another\"}`, `and`, nil)\n\ttestRaw(t, setDelete, `{}`, `{\"and\":\"another\"}`, `and`, nil)\n\ttestRaw(t, setDelete, `{\"1\":\"2\"}`, `{\"1\":\"2\"}`, `3`, nil)\n}\n\n// TestRandomData is a fuzzing test that throws random data at SetRaw\n// function looking for panics.\nfunc TestRandomData(t *testing.T) {\n\tvar lstr string\n\tdefer func() {\n\t\tif v := recover(); v != nil {\n\t\t\tprintln(\"'\" + hex.EncodeToString([]byte(lstr)) + \"'\")\n\t\t\tprintln(\"'\" + lstr + \"'\")\n\t\t\tpanic(v)\n\t\t}\n\t}()\n\trand.Seed(time.Now().UnixNano())\n\tb := make([]byte, 200)\n\tfor i := 0; i < 2000000; i++ {\n\t\tn, err := rand.Read(b[:rand.Int()%len(b)])\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tlstr = string(b[:n])\n\t\tSetRaw(lstr, \"zzzz.zzzz.zzzz\", \"123\")\n\t}\n}\n\nfunc TestDeleteIssue21(t *testing.T) {\n\tjson := `{\"country_code_from\":\"NZ\",\"country_code_to\":\"SA\",\"date_created\":\"2018-09-13T02:56:11.25783Z\",\"date_updated\":\"2018-09-14T03:15:16.67356Z\",\"disabled\":false,\"last_edited_by\":\"Developers\",\"id\":\"a3e...bc454\",\"merchant_id\":\"f2b...b91abf\",\"signed_date\":\"2018-02-01T00:00:00Z\",\"start_date\":\"2018-03-01T00:00:00Z\",\"url\":\"https://www.google.com\"}`\n\tres1 := gjson.Get(json, \"date_updated\")\n\tvar err error\n\tjson, err = Delete(json, \"date_updated\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tres2 := gjson.Get(json, \"date_updated\")\n\tres3 := gjson.Get(json, \"date_created\")\n\tif !res1.Exists() || res2.Exists() || !res3.Exists() {\n\t\tt.Fatal(\"bad news\")\n\t}\n\n\t// We change the number of characters in this to make the section of the string before the section that we want to delete a certain length\n\n\t//---------------------------\n\tlenBeforeToDeleteIs307AsBytes := `{\"1\":\"\",\"0\":\"012345678901234567890123456789012345678901234567890123456789012345678901234567\",\"to_delete\":\"0\",\"2\":\"\"}`\n\n\texpectedForLenBefore307AsBytes := `{\"1\":\"\",\"0\":\"012345678901234567890123456789012345678901234567890123456789012345678901234567\",\"2\":\"\"}`\n\t//---------------------------\n\n\t//---------------------------\n\tlenBeforeToDeleteIs308AsBytes := `{\"1\":\"\",\"0\":\"0123456789012345678901234567890123456789012345678901234567890123456789012345678\",\"to_delete\":\"0\",\"2\":\"\"}`\n\n\texpectedForLenBefore308AsBytes := `{\"1\":\"\",\"0\":\"0123456789012345678901234567890123456789012345678901234567890123456789012345678\",\"2\":\"\"}`\n\t//---------------------------\n\n\t//---------------------------\n\tlenBeforeToDeleteIs309AsBytes := `{\"1\":\"\",\"0\":\"01234567890123456789012345678901234567890123456789012345678901234567890123456\",\"to_delete\":\"0\",\"2\":\"\"}`\n\n\texpectedForLenBefore309AsBytes := `{\"1\":\"\",\"0\":\"01234567890123456789012345678901234567890123456789012345678901234567890123456\",\"2\":\"\"}`\n\t//---------------------------\n\n\tvar data = []struct {\n\t\tdesc     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tdesc:     \"len before \\\"to_delete\\\"... = 307\",\n\t\t\tinput:    lenBeforeToDeleteIs307AsBytes,\n\t\t\texpected: expectedForLenBefore307AsBytes,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"len before \\\"to_delete\\\"... = 308\",\n\t\t\tinput:    lenBeforeToDeleteIs308AsBytes,\n\t\t\texpected: expectedForLenBefore308AsBytes,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"len before \\\"to_delete\\\"... = 309\",\n\t\t\tinput:    lenBeforeToDeleteIs309AsBytes,\n\t\t\texpected: expectedForLenBefore309AsBytes,\n\t\t},\n\t}\n\n\tfor i, d := range data {\n\t\tresult, err := Delete(d.input, \"to_delete\")\n\n\t\tif err != nil {\n\t\t\tt.Error(fmtErrorf(testError{\n\t\t\t\tunexpected: \"error\",\n\t\t\t\tdesc:       d.desc,\n\t\t\t\ti:          i,\n\t\t\t\tlenInput:   len(d.input),\n\t\t\t\tinput:      d.input,\n\t\t\t\texpected:   d.expected,\n\t\t\t\tresult:     result,\n\t\t\t}))\n\t\t}\n\t\tif result != d.expected {\n\t\t\tt.Error(fmtErrorf(testError{\n\t\t\t\tunexpected: \"result\",\n\t\t\t\tdesc:       d.desc,\n\t\t\t\ti:          i,\n\t\t\t\tlenInput:   len(d.input),\n\t\t\t\tinput:      d.input,\n\t\t\t\texpected:   d.expected,\n\t\t\t\tresult:     result,\n\t\t\t}))\n\t\t}\n\t}\n}\n\ntype testError struct {\n\tunexpected string\n\tdesc       string\n\ti          int\n\tlenInput   int\n\tinput      interface{}\n\texpected   interface{}\n\tresult     interface{}\n}\n\nfunc fmtErrorf(e testError) string {\n\treturn fmt.Sprintf(\n\t\t\"Unexpected %s:\\n\\t\"+\n\t\t\t\"for=%q\\n\\t\"+\n\t\t\t\"i=%d\\n\\t\"+\n\t\t\t\"len(input)=%d\\n\\t\"+\n\t\t\t\"input=%v\\n\\t\"+\n\t\t\t\"expected=%v\\n\\t\"+\n\t\t\t\"result=%v\",\n\t\te.unexpected, e.desc, e.i, e.lenInput, e.input, e.expected, e.result,\n\t)\n}\n\nfunc TestSetDotKeyIssue10(t *testing.T) {\n\tjson := `{\"app.token\":\"abc\"}`\n\tjson, _ = Set(json, `app\\.token`, \"cde\")\n\tif json != `{\"app.token\":\"cde\"}` {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", `{\"app.token\":\"cde\"}`, json)\n\t}\n}\nfunc TestDeleteDotKeyIssue19(t *testing.T) {\n\tjson := []byte(`{\"data\":{\"key1\":\"value1\",\"key2.something\":\"value2\"}}`)\n\tjson, _ = DeleteBytes(json, `data.key2\\.something`)\n\tif string(json) != `{\"data\":{\"key1\":\"value1\"}}` {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", `{\"data\":{\"key1\":\"value1\"}}`, json)\n\t}\n}\n\nfunc TestIssue36(t *testing.T) {\n\tvar json = `\n\t{\n\t    \"size\": 1000\n    }\n`\n\tvar raw = `\n\t{\n\t    \"sample\": \"hello\"\n\t}\n`\n\t_ = raw\n\tif true {\n\t\tjson, _ = SetRaw(json, \"aggs\", raw)\n\t}\n\tif !gjson.Valid(json) {\n\t\tt.Fatal(\"invalid json\")\n\t}\n\tres := gjson.Get(json, \"aggs.sample\").String()\n\tif res != \"hello\" {\n\t\tt.Fatal(\"unexpected result\")\n\t}\n}\n\nvar example = `\n{\n\t\"name\": {\"first\": \"Tom\", \"last\": \"Anderson\"},\n\t\"age\":37,\n\t\"children\": [\"Sara\",\"Alex\",\"Jack\"],\n\t\"fav.movie\": \"Deer Hunter\",\n\t\"friends\": [\n\t  {\"first\": \"Dale\", \"last\": \"Murphy\", \"age\": 44, \"nets\": [\"ig\", \"fb\", \"tw\"]},\n\t  {\"first\": \"Roger\", \"last\": \"Craig\", \"age\": 68, \"nets\": [\"fb\", \"tw\"]},\n\t  {\"first\": \"Jane\", \"last\": \"Murphy\", \"age\": 47, \"nets\": [\"ig\", \"tw\"]}\n\t]\n  }\n  `\n\nfunc TestIndex(t *testing.T) {\n\tpath := `friends.#(last=\"Murphy\").last`\n\tjson, err := Set(example, path, \"Johnson\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif gjson.Get(json, \"friends.#.last\").String() != `[\"Johnson\",\"Craig\",\"Murphy\"]` {\n\t\tt.Fatal(\"mismatch\")\n\t}\n}\n\nfunc TestIndexes(t *testing.T) {\n\tpath := `friends.#(last=\"Murphy\")#.last`\n\tjson, err := Set(example, path, \"Johnson\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif gjson.Get(json, \"friends.#.last\").String() != `[\"Johnson\",\"Craig\",\"Johnson\"]` {\n\t\tt.Fatal(\"mismatch\")\n\t}\n}\n\nfunc TestIssue61(t *testing.T) {\n\tjson := `{\n\t\t\"@context\": {\n\t\t  \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n\t\t  \"@vocab\": \"http://schema.org/\",\n\t\t  \"sh\": \"http://www.w3.org/ns/shacl#\"\n\t\t}\n\t}`\n\tjson1, _ := Set(json, \"@context.@vocab\", \"newval\")\n\tif gjson.Get(json1, \"@context.@vocab\").String() != \"newval\" {\n\t\tt.Fail()\n\t}\n}\n"
        }
      ]
    }
  ]
}