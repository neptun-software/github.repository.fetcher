{
  "metadata": {
    "timestamp": 1736567042418,
    "page": 624,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "monochromegane/the_platinum_searcher",
      "stars": 2811,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0576171875,
          "content": "*.test\nthe_platinum_searcher\npt\n!cmd/pt\nGodeps/_workspace/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.5078125,
          "content": "sudo: false\nlanguage: go\ngo:\n  - \"1.11.x\"\n  - master\nenv:\n  CGO_ENABLED=0\ninstall:\n  - go get github.com/BurntSushi/toml\n  - go get github.com/jessevdk/go-flags\n  - go get github.com/monochromegane/conflag\n  - go get github.com/monochromegane/go-gitignore\n  - go get github.com/monochromegane/go-home\n  - go get github.com/monochromegane/terminal\n  - go get github.com/shiena/ansicolor\n  - go get golang.org/x/text/encoding\n  - go get golang.org/x/text/transform\n  - go get gopkg.in/yaml.v2\nscript:\n  - go test -v ./...\n"
        },
        {
          "name": "Godeps",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.06640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) [2014] [the_platinum_searcher]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.087890625,
          "content": "# The Platinum Searcher [![Build Status](https://travis-ci.org/monochromegane/the_platinum_searcher.svg?branch=master)](https://travis-ci.org/monochromegane/the_platinum_searcher) [![wercker status](https://app.wercker.com/status/59ef90ac217537abc0994546958037f3/s/master \"wercker status\")](https://app.wercker.com/project/bykey/59ef90ac217537abc0994546958037f3)\n\nA code search tool similar to `ack` and `the_silver_searcher(ag)`. It supports multi platforms and multi encodings.\n\n## Features\n\n- It searches code about 3–5× faster than `ack`.\n- It searches code as fast as `the_silver_searcher(ag)`.\n- It ignores file patterns from your `.gitignore`.\n- It ignores directories with names that start with `.`, eg `.config`. Use `--hidden` option, if you want to search.\n- It searches `UTF-8`, `EUC-JP` and `Shift_JIS` files.\n- It provides binaries for multi platform (macOS, Windows, Linux).\n\n### Benchmarks\n\n```sh\ncd ~/src/github.com/torvalds/linux\nack EXPORT_SYMBOL_GPL 30.18s user 2.32s system  99% cpu 32.613 total # ack\nag  EXPORT_SYMBOL_GPL  1.57s user 1.76s system 311% cpu  1.069 total # ag: It's faster than ack.\npt  EXPORT_SYMBOL_GPL  2.29s user 1.26s system 358% cpu  0.991 total # pt: It's faster than ag!!\n```\n\n## Usage\n\n```sh\n$ # Recursively searches for PATTERN in current directory.\n$ pt PATTERN\n\n$ # You can specify PATH and some OPTIONS.\n$ pt OPTIONS PATTERN PATH\n```\n\n## Configuration\n\nIf you put configuration file on the following directories, pt use option in the file.\n\n- $XDG\\_CONFIG\\_HOME/pt/config.toml\n- $HOME/.ptconfig.toml\n- .ptconfig.toml (current directory)\n\nThe file is TOML format like the following.\n\n```toml\ncolor = true\ncontext = 3\nignore = [\"dir1\", \"dir2\"]\ncolor-path = \"1;34\"\n```\n\nThe options are same as command line options.\n\n## Editor Integration\n\n### Vim + Unite.vim\n\nYou can use pt with [Unite.vim](https://github.com/Shougo/unite.vim).\n\n```vim\nnnoremap <silent> ,g :<C-u>Unite grep:. -buffer-name=search-buffer<CR>\nif executable('pt')\n  let g:unite_source_grep_command = 'pt'\n  let g:unite_source_grep_default_opts = '--nogroup --nocolor'\n  let g:unite_source_grep_recursive_opt = ''\n  let g:unite_source_grep_encoding = 'utf-8'\nendif\n```\n\n### Emacs + pt.el\n\nYou can use pt with [pt.el](https://github.com/bling/pt.el), which can be installed from [MELPA](http://melpa.milkbox.net/).\n\n## Installation\n\n### Developer\n\n```sh\n$ go get -u github.com/monochromegane/the_platinum_searcher/...\n```\n\n### User\n\nDownload from the following url.\n\n- [https://github.com/monochromegane/the_platinum_searcher/releases](https://github.com/monochromegane/the_platinum_searcher/releases)\n\nOr, you can use Homebrew (Only macOS).\n\n```sh\n$ brew install pt\n```\n\n`pt` is an alias for `the_platinum_searcher` in Homebrew.\n\n## Contribution\n\n1. Fork it\n2. Create a feature branch\n3. Commit your changes\n4. Rebase your local changes against the master branch\n5. Run test suite with the `go test ./...` command and confirm that it passes\n6. Run `gofmt -s`\n7. Create new Pull Request\n\n## License\n\n[MIT](https://github.com/monochromegane/the_platinum_searcher/blob/master/LICENSE)\n\n## Author\n\n[monochromegane](https://github.com/monochromegane)\n\n"
        },
        {
          "name": "buffer_grep.go",
          "type": "blob",
          "size": 3.0244140625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\ntype bufferGrep struct {\n\tprinter\n\tpattern pattern\n\tcolumn  bool\n}\n\nfunc (g bufferGrep) grep(path string, buf []byte) {\n\tf, err := getFileHandler(path)\n\tif err != nil {\n\t\tlog.Fatalf(\"open: %s\\n\", err)\n\t}\n\tdefer f.Close()\n\n\tidentified := false\n\tvar encoding int\n\tpattern := g.pattern.pattern\n\tmatch := match{path: path}\n\toffset, read := 0, 0\n\nloop:\n\tfor {\n\t\tn, err := f.Read(buf[offset:])\n\t\tif err == io.EOF {\n\t\t\t// Scan remain (For last line without new line.)\n\t\t\tscan(&match, buf[:offset], pattern, read, encoding, g.column)\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tcbuf := buf[0 : offset+n]\n\n\t\t// detect encoding.\n\t\tif !identified {\n\t\t\tlimit := n\n\t\t\tif limit > 512 {\n\t\t\t\tlimit = 512\n\t\t\t}\n\n\t\t\tif f == os.Stdin {\n\t\t\t\t// TODO: File type is fixed in ASCII because it can not determine the character code.\n\t\t\t\tencoding = ASCII\n\t\t\t} else {\n\t\t\t\tencoding = detectEncoding(cbuf[:limit])\n\t\t\t}\n\t\t\tif encoding == ERROR || encoding == BINARY {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif r := newEncodeReader(bytes.NewReader(pattern), encoding); r != nil {\n\t\t\t\t// encode pattern to shift-jis or euc-jp.\n\t\t\t\tpattern, _ = ioutil.ReadAll(r)\n\t\t\t}\n\t\t\tidentified = true\n\t\t}\n\n\t\tnewLine := bytes.LastIndexByte(cbuf, '\\n')\n\t\t// fmt.Printf(\"offset: %d, newLine: %d\\n\", offset, newLine)\n\t\tif newLine >= 0 {\n\t\t\tc := scan(&match, cbuf[0:newLine], pattern, read, encoding, g.column)\n\t\t\t// matchLines = append(matchLines, m...)\n\t\t\toffset = len(cbuf[newLine+1:])\n\t\t\tfor i, _ := range cbuf[newLine+1:] {\n\t\t\t\tbuf[0+i] = cbuf[newLine+1+i]\n\t\t\t}\n\t\t\tread += c\n\t\t} else {\n\t\t\tgrow := make([]byte, len(cbuf)*2)\n\t\t\tcopy(grow, buf)\n\t\t\tbuf = grow\n\t\t\toffset = len(cbuf)\n\t\t\tcontinue loop\n\t\t}\n\t}\n\tg.printer.print(match)\n}\n\nvar NewLineBytes = []byte{10}\n\nfunc scanNewLine(buf []byte) int {\n\treturn bytes.Count(buf, NewLineBytes)\n}\n\nfunc scan(match *match, buf, pattern []byte, base, encoding int, column bool) int {\n\toffset, newLineCount := 0, 0\n\tfor {\n\t\tif offset > len(buf) {\n\t\t\tbreak\n\t\t}\n\t\tcbuf := buf[offset:]\n\t\tidx := bytes.Index(cbuf, pattern)\n\t\tif idx == -1 {\n\t\t\tnewLineCount += scanNewLineCount(cbuf)\n\t\t\tbreak\n\t\t}\n\t\tbeforeNewLine := bytes.LastIndexByte(cbuf[:idx], '\\n')\n\t\tif beforeNewLine != -1 {\n\t\t\tnewLineCount += (scanNewLineCount(cbuf[:beforeNewLine]) + 1)\n\t\t}\n\t\tnum := base + newLineCount + 1\n\t\tafterNewLine := bytes.IndexByte(cbuf[idx+len(pattern):], '\\n')\n\t\tif afterNewLine == -1 {\n\t\t\tafterNewLine = len(cbuf) - (idx + len(pattern))\n\t\t} else {\n\t\t\tnewLineCount++\n\t\t}\n\t\tmbuf := cbuf[beforeNewLine+1 : idx+len(pattern)+afterNewLine]\n\t\tline := make([]byte, len(mbuf))\n\t\tcopy(line, mbuf)\n\n\t\t// decode bytes from shift-jis or euc-jp.\n\t\tif r := newDecodeReader(bytes.NewReader(line), encoding); r != nil {\n\t\t\tline, _ = ioutil.ReadAll(r)\n\t\t}\n\t\tc := 0\n\t\tif column {\n\t\t\tif beforeNewLine == -1 {\n\t\t\t\tc = idx + 1\n\t\t\t} else {\n\t\t\t\tc = idx - beforeNewLine\n\t\t\t}\n\t\t}\n\t\tmatch.add(num, c, string(line), true)\n\t\toffset += idx + len(pattern) + afterNewLine + 1\n\t}\n\treturn newLineCount + 1\n}\n\nfunc scanNewLineCount(buf []byte) int {\n\treturn bytes.Count(buf, NewLineBytes)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "decoder.go",
          "type": "blob",
          "size": 0.361328125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io\"\n\n\t\"golang.org/x/text/encoding/japanese\"\n\t\"golang.org/x/text/transform\"\n)\n\nfunc newDecodeReader(r io.Reader, encoding int) io.Reader {\n\tswitch encoding {\n\tcase EUCJP:\n\t\treturn transform.NewReader(r, japanese.EUCJP.NewDecoder())\n\tcase SHIFTJIS:\n\t\treturn transform.NewReader(r, japanese.ShiftJIS.NewDecoder())\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "decorator.go",
          "type": "blob",
          "size": 2.1640625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tColorReset = \"\\x1b[0m\\x1b[K\"\n\n\tSeparatorColon  = \":\"\n\tSeparatorHyphen = \"-\"\n)\n\ntype decorator interface {\n\tpath(path string) string\n\tlineNumber(lineNum int) string\n\tcolumnNumber(columnNum int) string\n\tmatch(line string, matched bool) string\n}\n\nfunc newDecorator(pattern pattern, option Option) decorator {\n\tif option.OutputOption.EnableColor {\n\t\treturn newColor(pattern, option)\n\t} else {\n\t\treturn plain{}\n\t}\n}\n\ntype color struct {\n\tfrom   string\n\tto     string\n\tregexp *regexp.Regexp\n\n\tcolorLineNumber string\n\tcolorPath       string\n\tcolorMatch      string\n}\n\nfunc newColor(pattern pattern, option Option) color {\n\tcolor := color{\n\t\tcolorLineNumber: ansiEscape(option.OutputOption.ColorCodeLineNumber),\n\t\tcolorPath:       ansiEscape(option.OutputOption.ColorCodePath),\n\t\tcolorMatch:      ansiEscape(option.OutputOption.ColorCodeMatch),\n\t}\n\tif pattern.regexp == nil {\n\t\tp := string(pattern.pattern)\n\t\tcolor.from = p\n\t\tcolor.to = color.colorMatch + p + ColorReset\n\t} else {\n\t\tcolor.to = color.colorMatch + \"${1}\" + ColorReset\n\t\tcolor.regexp = pattern.regexp\n\t}\n\treturn color\n}\n\nfunc ansiEscape(code string) string {\n\tre := regexp.MustCompile(\"[^0-9;]\")\n\tsanitized := re.ReplaceAllString(code, \"\")\n\tif sanitized == \"\" {\n\t\tsanitized = \"0\" // all attributes off\n\t}\n\treturn \"\\x1b[\" + sanitized + \"m\"\n}\n\nfunc (c color) path(path string) string {\n\treturn c.colorPath + path + ColorReset\n}\n\nfunc (c color) lineNumber(lineNum int) string {\n\treturn c.colorLineNumber + strconv.Itoa(lineNum) + ColorReset\n}\n\nfunc (c color) columnNumber(columnNum int) string {\n\treturn strconv.Itoa(columnNum)\n}\n\nfunc (c color) match(line string, matched bool) string {\n\tif !matched {\n\t\treturn line\n\t} else if c.regexp == nil {\n\t\treturn strings.Replace(line, c.from, c.to, -1)\n\t} else {\n\t\treturn c.regexp.ReplaceAllString(line, c.to)\n\t}\n}\n\ntype plain struct {\n}\n\nfunc (p plain) path(path string) string {\n\treturn path\n}\n\nfunc (p plain) lineNumber(lineNum int) string {\n\treturn strconv.Itoa(lineNum)\n}\n\nfunc (p plain) columnNumber(columnNum int) string {\n\treturn strconv.Itoa(columnNum)\n}\n\nfunc (p plain) match(line string, matched bool) string {\n\treturn line\n}\n"
        },
        {
          "name": "encoder.go",
          "type": "blob",
          "size": 0.361328125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io\"\n\n\t\"golang.org/x/text/encoding/japanese\"\n\t\"golang.org/x/text/transform\"\n)\n\nfunc newEncodeReader(r io.Reader, encoding int) io.Reader {\n\tswitch encoding {\n\tcase EUCJP:\n\t\treturn transform.NewReader(r, japanese.EUCJP.NewEncoder())\n\tcase SHIFTJIS:\n\t\treturn transform.NewReader(r, japanese.ShiftJIS.NewEncoder())\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "encoding.go",
          "type": "blob",
          "size": 2.29296875,
          "content": "package the_platinum_searcher\n\nconst (\n\tUNKNOWN = iota\n\tERROR\n\tBINARY\n\tASCII\n\tUTF8\n\tEUCJP\n\tSHIFTJIS\n)\n\nfunc detectEncoding(bs []byte) int {\n\n\tvar (\n\t\tsuspiciousBytes = 0\n\t\tlikelyUtf8      = 0\n\t\tlikelyEucjp     = 0\n\t\tlikelyShiftjis  = 0\n\t)\n\n\tlength := len(bs)\n\n\tif length == 0 {\n\t\treturn ASCII\n\t}\n\n\tif length >= 3 && bs[0] == 0xEF && bs[1] == 0xBB && bs[2] == 0xBF {\n\t\t// UTF-8 BOM. This isn't binary.\n\t\treturn UTF8\n\t}\n\n\tif length >= 5 && bs[0] == 0x25 && bs[1] == 0x50 && bs[2] == 0x44 && bs[3] == 0x46 && bs[4] == 0x2D {\n\t\t/*  %PDF-. This is binary. */\n\t\treturn BINARY\n\t}\n\n\tfor i := 0; i < length; i++ {\n\t\tif bs[i] == 0x00 {\n\t\t\t/* NULL char. It's binary */\n\t\t\treturn BINARY\n\t\t} else if (bs[i] < 7 || bs[i] > 14) && (bs[i] < 32 || bs[i] > 127) {\n\t\t\t/* UTF-8 detection */\n\t\t\tif bs[i] > 193 && bs[i] < 224 && i+1 < length {\n\t\t\t\ti++\n\t\t\t\tif bs[i] > 127 && bs[i] < 192 {\n\t\t\t\t\tlikelyUtf8++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t} else if bs[i] > 223 && bs[i] < 240 && i+2 < length {\n\t\t\t\ti++\n\t\t\t\tif bs[i] > 127 && bs[i] < 192 && bs[i+1] > 127 && bs[i+1] < 192 {\n\t\t\t\t\ti++\n\t\t\t\t\tlikelyUtf8++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* EUC-JP detection */\n\t\t\tif bs[i] == 142 && i+1 < length {\n\t\t\t\ti++\n\t\t\t\tif bs[i] > 160 && bs[i] < 224 {\n\t\t\t\t\tlikelyEucjp++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else if bs[i] > 160 && bs[i] < 255 && i+1 < length {\n\t\t\t\ti++\n\t\t\t\tif bs[i] > 160 && bs[i] < 255 {\n\t\t\t\t\tlikelyEucjp++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Shift-JIS detection */\n\t\t\tif bs[i] > 160 && bs[i] < 224 {\n\t\t\t\tlikelyShiftjis++\n\t\t\t\tcontinue\n\t\t\t} else if ((bs[i] > 128 && bs[i] < 160) || (bs[i] > 223 && bs[i] < 240)) && i+1 < length {\n\t\t\t\ti++\n\t\t\t\tif (bs[i] > 63 && bs[i] < 127) || (bs[i] > 127 && bs[i] < 253) {\n\t\t\t\t\tlikelyShiftjis++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsuspiciousBytes++\n\t\t\tif i >= 32 && (suspiciousBytes*100)/length > 10 {\n\t\t\t\treturn BINARY\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (suspiciousBytes*100)/length > 10 {\n\t\treturn BINARY\n\t}\n\n\t// fmt.Printf(\"Detected points[utf8/eucjp/shiftjis] is %d/%d/%d.\\n\", likelyUtf8, likelyEucjp, likelyShiftjis)\n\n\tif likelyUtf8 == 0 && likelyEucjp == 0 && likelyShiftjis == 0 {\n\t\treturn ASCII\n\t} else if likelyUtf8 >= likelyEucjp && likelyUtf8 >= likelyShiftjis {\n\t\treturn UTF8\n\t} else if likelyEucjp >= likelyUtf8 && likelyEucjp >= likelyShiftjis {\n\t\treturn EUCJP\n\t} else if likelyShiftjis >= likelyUtf8 && likelyShiftjis >= likelyEucjp {\n\t\treturn SHIFTJIS\n\t}\n\n\treturn ASCII\n\n}\n"
        },
        {
          "name": "encoding_test.go",
          "type": "blob",
          "size": 0.689453125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\ntype Assert struct {\n\tpath     string\n\tfileType int\n}\n\nvar Asserts = []Assert{\n\tAssert{\"ascii.txt\", ASCII},\n\tAssert{\"binary/binary.bin\", BINARY},\n\tAssert{\"ja/euc-jp.txt\", EUCJP},\n\tAssert{\"ja/shift_jis.txt\", SHIFTJIS},\n\tAssert{\"ja/utf8.txt\", UTF8},\n\tAssert{\"ja/broken_euc-jp.txt\", EUCJP},\n\tAssert{\"ja/broken_shift_jis.txt\", SHIFTJIS},\n\tAssert{\"ja/broken_utf8.txt\", UTF8},\n}\n\nfunc TestIdentifyType(t *testing.T) {\n\tfor _, f := range Asserts {\n\t\tb, _ := ioutil.ReadFile(filepath.Join(\"files\", f.path))\n\t\tfileType := detectEncoding(b)\n\t\tif fileType != f.fileType {\n\t\t\tt.Errorf(\"%s should be %d.\", f.path, f.fileType)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "extended_grep.go",
          "type": "blob",
          "size": 1.015625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\ntype extendedGrep struct {\n\tlineGrep\n\tpattern pattern\n}\n\nfunc (g extendedGrep) grep(path string, buf []byte) {\n\tf, err := getFileHandler(path)\n\tif err != nil {\n\t\tlog.Fatalf(\"open: %s\\n\", err)\n\t}\n\tdefer f.Close()\n\n\tif f == os.Stdin {\n\t\t// TODO: File type is fixed in ASCII because it can not determine the character code.\n\t\tg.grepEachLines(f, ASCII, func(b []byte) bool {\n\t\t\treturn g.pattern.regexp.Match(b)\n\t\t}, func(b []byte) int {\n\t\t\treturn g.pattern.regexp.FindIndex(b)[0] + 1\n\t\t})\n\t\treturn\n\t}\n\n\tc, err := f.Read(buf)\n\tif err != nil && err != io.EOF {\n\t\tlog.Fatalf(\"read: %s\\n\", err)\n\t}\n\n\tif err == io.EOF {\n\t\treturn\n\t}\n\n\t// detect encoding.\n\tlimit := c\n\tif limit > 512 {\n\t\tlimit = 512\n\t}\n\n\tencoding := detectEncoding(buf[:limit])\n\tif encoding == ERROR || encoding == BINARY {\n\t\treturn\n\t}\n\n\t// grep each lines.\n\tg.grepEachLines(f, encoding, func(b []byte) bool {\n\t\treturn g.pattern.regexp.Match(b)\n\t}, func(b []byte) int {\n\t\treturn g.pattern.regexp.FindIndex(b)[0] + 1\n\t})\n}\n"
        },
        {
          "name": "file_handler.go",
          "type": "blob",
          "size": 0.1708984375,
          "content": "package the_platinum_searcher\n\nimport \"os\"\n\nfunc getFileHandler(path string) (*os.File, error) {\n\tif path == \"\" {\n\t\treturn os.Stdin, nil\n\t} else {\n\t\treturn os.Open(path)\n\t}\n}\n"
        },
        {
          "name": "file_info.go",
          "type": "blob",
          "size": 0.6953125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype fileInfo struct {\n\tpath, name string\n\ttyp        os.FileMode\n}\n\nfunc (f *fileInfo) isDir(follow bool) bool {\n\tif follow && f.isSymlink() {\n\t\tif _, err := ioutil.ReadDir(filepath.Join(f.path, f.name)); err == nil {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\treturn f.typ&os.ModeDir == os.ModeDir\n\t}\n}\n\nfunc (f *fileInfo) isSymlink() bool {\n\treturn f.typ&os.ModeSymlink == os.ModeSymlink\n}\n\nfunc (f *fileInfo) isNamedPipe() bool {\n\treturn f.typ&os.ModeNamedPipe == os.ModeNamedPipe\n}\n\nfunc newFileInfo(path, name string, typ os.FileMode) *fileInfo {\n\treturn &fileInfo{\n\t\tpath: path,\n\t\tname: name,\n\t\ttyp:  typ,\n\t}\n}\n"
        },
        {
          "name": "files",
          "type": "tree",
          "content": null
        },
        {
          "name": "find.go",
          "type": "blob",
          "size": 2.4599609375,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/monochromegane/go-gitignore\"\n)\n\ntype find struct {\n\tout  chan string\n\topts Option\n}\n\nfunc (f find) start(roots []string, regexp *regexp.Regexp) {\n\tdefer close(f.out)\n\n\tif f.opts.SearchOption.SearchStream {\n\t\tf.out <- \"\"\n\t} else if len(roots) == 1 {\n\t\tf.findFile(roots[0], regexp)\n\t} else {\n\t\tf.findFiles(roots, regexp)\n\t}\n}\n\nfunc (f find) findFiles(roots []string, reg *regexp.Regexp) {\n\twg := &sync.WaitGroup{}\n\twg.Add(len(roots))\n\tfor _, r := range roots {\n\t\tgo func(root string, reg *regexp.Regexp, wg *sync.WaitGroup) {\n\t\t\tdefer wg.Done()\n\t\t\tf.findFile(root, reg)\n\t\t}(r, reg, wg)\n\t}\n\twg.Wait()\n}\n\nfunc (f find) findFile(root string, regexp *regexp.Regexp) {\n\tvar ignores ignoreMatchers\n\n\t// add ignores from ignore option.\n\tif len(f.opts.SearchOption.Ignore) > 0 {\n\t\tignores = append(ignores, gitignore.NewGitIgnoreFromReader(\n\t\t\troot,\n\t\t\tstrings.NewReader(strings.Join(f.opts.SearchOption.Ignore, \"\\n\")),\n\t\t))\n\t}\n\n\t// add global gitignore.\n\tif f.opts.SearchOption.GlobalGitIgnore {\n\t\tif ignore := globalGitIgnore(root); ignore != nil {\n\t\t\tignores = append(ignores, ignore)\n\t\t}\n\t}\n\n\t// add home ptignore.\n\tif f.opts.SearchOption.HomePtIgnore {\n\t\tif ignore := homePtIgnore(root); ignore != nil {\n\t\t\tignores = append(ignores, ignore)\n\t\t}\n\t}\n\n\tfollowed := f.opts.SearchOption.Follow\n\twalkIn(root, ignores, followed, func(path string, info *fileInfo, depth int, ignores ignoreMatchers) (ignoreMatchers, error) {\n\t\tif info.isDir(followed) {\n\t\t\tif depth > f.opts.SearchOption.Depth+1 {\n\t\t\t\treturn ignores, filepath.SkipDir\n\t\t\t}\n\n\t\t\tif !f.opts.SearchOption.Hidden && isHidden(info.name) {\n\t\t\t\treturn ignores, filepath.SkipDir\n\t\t\t}\n\n\t\t\tif ignores.Match(path, true) {\n\t\t\t\treturn ignores, filepath.SkipDir\n\t\t\t}\n\n\t\t\tif !f.opts.SearchOption.SkipVcsIgnore {\n\t\t\t\tignores = append(ignores, newIgnoreMatchers(path, f.opts.SearchOption.VcsIgnore)...)\n\t\t\t}\n\t\t\treturn ignores, nil\n\t\t}\n\t\tif !f.opts.SearchOption.Follow && info.isSymlink() {\n\t\t\treturn ignores, nil\n\t\t}\n\n\t\tif info.isNamedPipe() {\n\t\t\treturn ignores, nil\n\t\t}\n\n\t\tif !f.opts.SearchOption.Hidden && isHidden(info.name) {\n\t\t\treturn ignores, filepath.SkipDir\n\t\t}\n\n\t\tif ignores.Match(path, false) {\n\t\t\treturn ignores, nil\n\t\t}\n\n\t\tif regexp != nil && !regexp.MatchString(path) {\n\t\t\treturn ignores, nil\n\t\t}\n\n\t\tf.out <- path\n\t\treturn ignores, nil\n\t})\n}\n\nfunc isHidden(name string) bool {\n\tif name == \".\" || name == \"..\" {\n\t\treturn false\n\t}\n\treturn len(name) > 1 && name[0] == '.'\n}\n"
        },
        {
          "name": "find_test.go",
          "type": "blob",
          "size": 2.869140625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\tout := make(chan string)\n\tfind := find{out, defaultOption()}\n\tgo find.start([]string{\"files\"}, nil)\n\n\ttestPath := makeAssertPaths(out)\n\n\t// Ensure these files were not returned\n\tif e := \"files/.hidden/hidden.txt\"; testPath(e) {\n\t\tt.Errorf(\"Found %s, It should not contains file under hidden directory.\", e)\n\t}\n\n\t// Enumerate found paths and ensure a couple of them are in there.\n\tif e := \"files/ascii.txt\"; !testPath(e) {\n\t\tt.Errorf(\"Find failed to locate: %s\", e)\n\t}\n\n\tif e := \"files/depth/file_1.txt\"; !testPath(e) {\n\t\tt.Errorf(\"Find failed to locate: %s\", e)\n\t}\n}\n\nfunc TestFindWithHidden(t *testing.T) {\n\tout := make(chan string)\n\topt := defaultOption()\n\topt.SearchOption.Hidden = true\n\tfind := find{out, opt}\n\tgo find.start([]string{\"files\"}, nil)\n\n\ttestPath := makeAssertPaths(out)\n\n\t// Enumerate found paths and ensure a couple of them are in there.\n\tif e := \"files/.hidden/hidden.txt\"; !testPath(e) {\n\t\tt.Errorf(\"Find failed to locate: %s\", e)\n\t}\n\tif e := \"files/.hidden/.hidden.txt\"; !testPath(e) {\n\t\tt.Errorf(\"Find failed to locate: %s\", e)\n\t}\n}\n\nfunc TestFindWithIgnore(t *testing.T) {\n\tout := make(chan string)\n\topt := defaultOption()\n\topt.SearchOption.VcsIgnore = []string{\".vcsignore\"}\n\tfind := find{out, opt}\n\tgo find.start([]string{\"files/vcs\"}, nil)\n\n\ttestPath := makeAssertPaths(out)\n\n\tignores := []string{\n\t\t\"match/ignore.txt\",\n\t\t\"ignore/ignore.txt\",\n\t\t\"absolute/ignore.txt\",\n\t}\n\n\tfor _, ignore := range ignores {\n\t\t// Ensure these files were not returned\n\t\tif e := \"files/vcs/\" + ignore; testPath(e) {\n\t\t\tt.Errorf(\"Found %s, It should not contains ignore file.\", e)\n\t\t}\n\t}\n}\n\nfunc TestFindWithDepth(t *testing.T) {\n\tout := make(chan string)\n\topt := defaultOption()\n\topt.SearchOption.Depth = 1\n\tfind := find{out, opt}\n\tgo find.start([]string{\"files/depth\"}, nil)\n\n\ttestPath := makeAssertPaths(out)\n\n\t// Ensure these files were not returned\n\tif e := \"files/depth/dir_1/dir_2/file_3.txt\"; testPath(e) {\n\t\tt.Errorf(\"Found %s, It should not contains file from over max depth.\", e)\n\t}\n}\n\nfunc TestFindWithFileSearchPattern(t *testing.T) {\n\tout := make(chan string)\n\tfind := find{out, defaultOption()}\n\tgo find.start([]string{\"files/vcs/match\"}, regexp.MustCompile(\"match.txt\"))\n\n\ttestPath := makeAssertPaths(out)\n\n\t// Ensure these files were not returned\n\tif e := \"files/vcs/match/ignore.txt\"; testPath(e) {\n\t\tt.Errorf(\"Found %s, It should not contains no match file.\", e)\n\t}\n}\n\nfunc makeAssertPaths(ch chan string) func(f string) bool {\n\tvar list []string\n\tfor path := range ch {\n\t\tlist = append(list, filepath.ToSlash(path))\n\t}\n\treturn func(m string) bool {\n\t\tfor _, s := range list {\n\t\t\tif m == s {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\nfunc defaultOption() Option {\n\treturn Option{\n\t\tOutputOption: &OutputOption{\n\t\t\tEnableLineNumber: true,\n\t\t},\n\t\tSearchOption: &SearchOption{\n\t\t\tDepth: 25,\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "fixed_grep.go",
          "type": "blob",
          "size": 2.2041015625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\ntype fixedGrep struct {\n\tlineGrep\n\tpattern pattern\n}\n\nfunc (g fixedGrep) grep(path string, buf []byte) {\n\tf, err := getFileHandler(path)\n\tif err != nil {\n\t\tlog.Fatalf(\"open: %s\\n\", err)\n\t}\n\tdefer f.Close()\n\n\tif f == os.Stdin {\n\t\t// TODO: File type is fixed in ASCII because it can not determine the character code.\n\t\tg.grepEachLines(f, ASCII, func(b []byte) bool {\n\t\t\treturn bytes.Contains(b, g.pattern.pattern)\n\t\t}, func(b []byte) int {\n\t\t\treturn bytes.Index(b, g.pattern.pattern) + 1\n\t\t})\n\t\treturn\n\t}\n\n\tvar stash []byte\n\tidentified := false\n\tvar encoding int\n\tpattern := g.pattern.pattern\n\n\tfor {\n\t\tc, err := f.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\tlog.Fatalf(\"read: %s\\n\", err)\n\t\t}\n\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\n\t\t// detect encoding.\n\t\tif !identified {\n\t\t\tlimit := c\n\t\t\tif limit > 512 {\n\t\t\t\tlimit = 512\n\t\t\t}\n\n\t\t\tencoding = detectEncoding(buf[:limit])\n\t\t\tif encoding == ERROR || encoding == BINARY {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif r := newEncodeReader(bytes.NewReader(pattern), encoding); r != nil {\n\t\t\t\t// encode pattern to shift-jis or euc-jp.\n\t\t\t\tpattern, _ = ioutil.ReadAll(r)\n\t\t\t}\n\t\t\tidentified = true\n\t\t}\n\n\t\t// repair first line from previous last line.\n\t\tif len(stash) > 0 {\n\t\t\tvar repaired []byte\n\t\t\tindex := bytes.Index(buf[:c], newLine)\n\t\t\tif index == -1 {\n\t\t\t\trepaired = append(stash, buf[:c]...)\n\t\t\t} else {\n\t\t\t\trepaired = append(stash, buf[:index]...)\n\t\t\t}\n\t\t\t// grep from repaied line.\n\t\t\tif bytes.Contains(repaired, pattern) {\n\t\t\t\t// grep each lines.\n\t\t\t\tg.grepEachLines(f, encoding, func(b []byte) bool {\n\t\t\t\t\treturn bytes.Contains(b, g.pattern.pattern)\n\t\t\t\t}, func(b []byte) int {\n\t\t\t\t\treturn bytes.Index(b, g.pattern.pattern) + 1\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// grep from buffer.\n\t\tif bytes.Contains(buf[:c], pattern) {\n\t\t\t// grep each lines.\n\t\t\tg.grepEachLines(f, encoding, func(b []byte) bool {\n\t\t\t\treturn bytes.Contains(b, g.pattern.pattern)\n\t\t\t}, func(b []byte) int {\n\t\t\t\treturn bytes.Index(b, g.pattern.pattern) + 1\n\t\t\t})\n\t\t\tbreak\n\t\t}\n\n\t\t// stash last line.\n\t\tindex := bytes.LastIndex(buf[:c], newLine)\n\t\tif index == -1 {\n\t\t\tstash = append(stash, buf[:c]...)\n\t\t} else {\n\t\t\tstash = make([]byte, c-index)\n\t\t\tcopy(stash, buf[index:c])\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "formatter.go",
          "type": "blob",
          "size": 3.6845703125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/shiena/ansicolor\"\n\t\"golang.org/x/text/encoding/japanese\"\n\t\"golang.org/x/text/transform\"\n)\n\ntype formatPrinter interface {\n\tprint(match match)\n}\n\nfunc newFormatPrinter(pattern pattern, w io.Writer, opts Option) formatPrinter {\n\twriter := newWriter(w, opts)\n\tdecorator := newDecorator(pattern, opts)\n\n\tswitch {\n\tcase opts.SearchOption.SearchStream:\n\t\treturn matchLine{decorator: decorator, w: writer}\n\tcase opts.OutputOption.FilesWithMatches:\n\t\treturn fileWithMatch{decorator: decorator, w: writer, useNull: opts.OutputOption.Null}\n\tcase opts.OutputOption.Count:\n\t\treturn count{decorator: decorator, w: writer}\n\tcase opts.OutputOption.EnableGroup:\n\t\treturn group{decorator: decorator, w: writer, useNull: opts.OutputOption.Null, enableLineNumber: opts.OutputOption.EnableLineNumber}\n\tdefault:\n\t\treturn noGroup{decorator: decorator, w: writer, enableLineNumber: opts.OutputOption.EnableLineNumber}\n\t}\n}\n\ntype matchLine struct {\n\tw         io.Writer\n\tdecorator decorator\n}\n\nfunc (f matchLine) print(match match) {\n\tfor _, line := range match.lines {\n\t\tcolumn := \"\"\n\t\tif line.matched && line.column > 0 {\n\t\t\tcolumn = f.decorator.columnNumber(line.column) + SeparatorColon\n\t\t}\n\t\tfmt.Fprintln(f.w,\n\t\t\tcolumn+\n\t\t\t\tf.decorator.match(line.text, line.matched),\n\t\t)\n\t}\n}\n\ntype fileWithMatch struct {\n\tw         io.Writer\n\tdecorator decorator\n\tuseNull   bool\n}\n\nfunc (f fileWithMatch) print(match match) {\n\tif f.useNull {\n\t\tfmt.Fprint(f.w, f.decorator.path(match.path))\n\t\tfmt.Fprint(f.w, \"\\x00\")\n\t} else {\n\t\tfmt.Fprintln(f.w, f.decorator.path(match.path))\n\t}\n}\n\ntype count struct {\n\tw         io.Writer\n\tdecorator decorator\n}\n\nfunc (f count) print(match match) {\n\tcount := len(match.lines)\n\tfmt.Fprintln(f.w,\n\t\tf.decorator.path(match.path)+\n\t\t\tSeparatorColon+\n\t\t\tf.decorator.lineNumber(count),\n\t)\n}\n\ntype group struct {\n\tw                io.Writer\n\tdecorator        decorator\n\tuseNull          bool\n\tenableLineNumber bool\n}\n\nfunc (f group) print(match match) {\n\tif f.useNull {\n\t\tfmt.Fprint(f.w, f.decorator.path(match.path))\n\t\tfmt.Fprint(f.w, \"\\x00\")\n\t} else {\n\t\tfmt.Fprintln(f.w, f.decorator.path(match.path))\n\t}\n\n\tfor _, line := range match.lines {\n\t\tsep := SeparatorColon\n\t\tif !line.matched {\n\t\t\tsep = SeparatorHyphen\n\t\t}\n\t\tcolumn := \"\"\n\t\tif line.matched && line.column > 0 {\n\t\t\tcolumn = f.decorator.columnNumber(line.column) + SeparatorColon\n\t\t}\n\t\tlineNum := \"\"\n\t\tif f.enableLineNumber {\n\t\t\tlineNum = f.decorator.lineNumber(line.num) + sep\n\t\t}\n\t\tfmt.Fprintln(f.w,\n\t\t\tlineNum+\n\t\t\t\tcolumn+\n\t\t\t\tf.decorator.match(line.text, line.matched),\n\t\t)\n\t}\n\tfmt.Fprintln(f.w)\n}\n\ntype noGroup struct {\n\tw                io.Writer\n\tdecorator        decorator\n\tenableLineNumber bool\n}\n\nfunc (f noGroup) print(match match) {\n\tpath := f.decorator.path(match.path) + SeparatorColon\n\tfor _, line := range match.lines {\n\t\tsep := SeparatorColon\n\t\tif !line.matched {\n\t\t\tsep = SeparatorHyphen\n\t\t}\n\t\tcolumn := \"\"\n\t\tif line.matched && line.column > 0 {\n\t\t\tcolumn = f.decorator.columnNumber(line.column) + SeparatorColon\n\t\t}\n\t\tlineNum := \"\"\n\t\tif f.enableLineNumber {\n\t\t\tlineNum = f.decorator.lineNumber(line.num) + sep\n\t\t}\n\t\tfmt.Fprintln(f.w,\n\t\t\tpath+\n\t\t\t\tlineNum+\n\t\t\t\tcolumn+\n\t\t\t\tf.decorator.match(line.text, line.matched),\n\t\t)\n\t}\n}\n\nfunc newWriter(out io.Writer, opts Option) io.Writer {\n\tencoder := func() io.Writer {\n\t\tswitch opts.OutputOption.OutputEncode {\n\t\tcase \"sjis\":\n\t\t\treturn transform.NewWriter(out, japanese.ShiftJIS.NewEncoder())\n\t\tcase \"euc\":\n\t\t\treturn transform.NewWriter(out, japanese.EUCJP.NewEncoder())\n\t\tcase \"jis\":\n\t\t\treturn transform.NewWriter(out, japanese.ISO2022JP.NewEncoder())\n\t\tdefault:\n\t\t\treturn out\n\t\t}\n\t}()\n\tif opts.OutputOption.EnableColor {\n\t\treturn ansicolor.NewAnsiColorWriter(encoder)\n\t}\n\treturn encoder\n}\n"
        },
        {
          "name": "formatter_test.go",
          "type": "blob",
          "size": 3.529296875,
          "content": "package the_platinum_searcher\n\nimport \"os\"\n\nfunc ExampleFormatPrinterFileWithMatch() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.FilesWithMatches = true\n\n\tmatch := match{path: \"filename\"}\n\tmatch.add(1, 0, \"go test\", true)\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// filename\n}\n\nfunc ExampleFormatPrinterCount() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.Count = true\n\n\tmatch := match{path: \"filename\"}\n\tmatch.add(1, 0, \"go test\", true)\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// filename:1\n}\n\nfunc ExampleFormatEnableGroup() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = true\n\n\tmatch := match{path: \"filename\"}\n\tmatch.add(1, 0, \"before\", false) // before\n\tmatch.add(2, 0, \"go test\", true) // no column\n\tmatch.add(3, 0, \"after\", false)  // after\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// filename\n\t// 1-before\n\t// 2:go test\n\t// 3-after\n}\n\nfunc ExampleFormatEnableGroupWithColumn() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = true\n\n\tmatch := match{path: \"filename\"}\n\tmatch.add(1, 0, \"before\", false) // before\n\tmatch.add(2, 1, \"go test\", true) // no column\n\tmatch.add(3, 0, \"after\", false)  // after\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// filename\n\t// 1-before\n\t// 2:1:go test\n\t// 3-after\n}\n\nfunc ExampleFormatNoGroup() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = false\n\n\tmatch := match{path: \"filename\"}\n\tmatch.add(1, 0, \"before\", false) // before\n\tmatch.add(2, 0, \"go test\", true) // no column\n\tmatch.add(3, 0, \"after\", false)  // after\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// filename:1-before\n\t// filename:2:go test\n\t// filename:3-after\n}\n\nfunc ExampleFormatNoGroupWithColumn() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = false\n\n\tmatch := match{path: \"filename\"}\n\tmatch.add(1, 0, \"before\", false) // before\n\tmatch.add(2, 1, \"go test\", true) // no column\n\tmatch.add(3, 0, \"after\", false)  // after\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// filename:1-before\n\t// filename:2:1:go test\n\t// filename:3-after\n}\n\nfunc ExampleFormatMatchLine() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.SearchOption.SearchStream = true\n\n\tmatch := match{path: \"/dev/stdin\"}\n\tmatch.add(1, 0, \"before\", false) // before\n\tmatch.add(2, 0, \"go test\", true) // no column\n\tmatch.add(3, 0, \"after\", false)  // after\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// before\n\t// go test\n\t// after\n}\n\nfunc ExampleFormatMatchLineWithColumn() {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.SearchOption.SearchStream = true\n\n\tmatch := match{path: \"/dev/stdin\"}\n\tmatch.add(1, 0, \"before\", false) // before\n\tmatch.add(2, 1, \"go test\", true) // no column\n\tmatch.add(3, 0, \"after\", false)  // after\n\n\tpattern, _ := newPattern(\"go\", opts)\n\tp := newFormatPrinter(pattern, os.Stdout, opts)\n\tp.print(match)\n\n\t// Output:\n\t// before\n\t// 1:go test\n\t// after\n}\n"
        },
        {
          "name": "grep.go",
          "type": "blob",
          "size": 1.419921875,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"math\"\n\t\"runtime\"\n\t\"sync\"\n)\n\nvar newLine = []byte(\"\\n\")\n\ntype grep struct {\n\tin      chan string\n\tdone    chan struct{}\n\tgrepper grepper\n\tprinter printer\n\topts    Option\n}\n\nfunc newGrep(pattern pattern, in chan string, done chan struct{}, opts Option, printer printer) grep {\n\treturn grep{\n\t\tin:   in,\n\t\tdone: done,\n\t\tgrepper: newGrepper(\n\t\t\tpattern,\n\t\t\tprinter,\n\t\t\topts,\n\t\t),\n\t\tprinter: printer,\n\t\topts:    opts,\n\t}\n}\n\nfunc (g grep) start() {\n\twg := &sync.WaitGroup{}\n\tworker := func() {\n\t\tdefer wg.Done()\n\t\tbuf := make([]byte, 16384)\n\t\tfor path := range g.in {\n\t\t\tg.grepper.grep(path, buf)\n\t\t}\n\t}\n\tnum := int(math.Max(float64(runtime.NumCPU()), 2.0))\n\tfor i := 0; i < num; i++ {\n\t\twg.Add(1)\n\t\tgo worker()\n\t}\n\n\twg.Wait()\n\tclose(g.printer.in)\n\tg.done <- <-g.printer.done\n}\n\ntype grepper interface {\n\tgrep(path string, buf []byte)\n}\n\nfunc newGrepper(pattern pattern, printer printer, opts Option) grepper {\n\tif opts.SearchOption.EnableFilesWithRegexp {\n\t\treturn passthroughGrep{\n\t\t\tprinter: printer,\n\t\t}\n\t} else if opts.SearchOption.Regexp {\n\t\treturn extendedGrep{\n\t\t\tpattern:  pattern,\n\t\t\tlineGrep: newLineGrep(printer, opts),\n\t\t}\n\t} else {\n\t\tif opts.OutputOption.Before > 0 || opts.OutputOption.After > 0 {\n\t\t\treturn fixedGrep{\n\t\t\t\tpattern:  pattern,\n\t\t\t\tlineGrep: newLineGrep(printer, opts),\n\t\t\t}\n\t\t}\n\t\treturn bufferGrep{\n\t\t\tpattern: pattern,\n\t\t\tprinter: printer,\n\t\t\tcolumn:  opts.OutputOption.Column,\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "grep_test.go",
          "type": "blob",
          "size": 2.978515625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestFixedGrep(t *testing.T) {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = false\n\n\tpattern, _ := newPattern(\"go\", opts)\n\n\tpaths := []string{\n\t\t\"ascii.txt\",\n\t\t\"ja/utf8.txt\",\n\t\t\"ja/euc-jp.txt\",\n\t\t\"ja/shift_jis.txt\",\n\t\t\"ja/broken_utf8.txt\",\n\t\t\"ja/broken_euc-jp.txt\",\n\t\t\"ja/broken_shift_jis.txt\",\n\t}\n\n\tasserts := []string{\n\t\t\"ascii.txt:2:go test\",\n\t\t\"ja/utf8.txt:2:go テスト\",\n\t\t\"ja/euc-jp.txt:2:go テスト\",\n\t\t\"ja/shift_jis.txt:2:go テスト\",\n\t\t\"ja/broken_utf8.txt:2:go テスト\",\n\t\t\"ja/broken_euc-jp.txt:2:go テスト\",\n\t\t\"ja/broken_shift_jis.txt:2:go テスト\",\n\t}\n\n\tif !assertGrep(pattern, opts, paths, asserts) {\n\t\tt.Errorf(\"Grep result should contain assserts.\")\n\t}\n\n}\n\nfunc TestFixedGrepLargeFile(t *testing.T) {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = false\n\n\tpattern, _ := newPattern(\"This is a large file.\", opts)\n\n\tpaths := []string{\"large/large.txt\"}\n\n\tasserts := []string{\n\t\t\"large/large.txt:10:This is a large file.\",\n\t}\n\n\tif !assertGrep(pattern, opts, paths, asserts) {\n\t\tt.Errorf(\"Grep result should contain assserts.\")\n\t}\n\n}\n\nfunc TestExtendedGrep(t *testing.T) {\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.OutputOption.EnableGroup = false\n\topts.SearchOption.Regexp = true\n\n\tpattern, _ := newPattern(\"g.*\", opts)\n\n\tpaths := []string{\n\t\t\"ascii.txt\",\n\t\t\"ja/utf8.txt\",\n\t\t\"ja/euc-jp.txt\",\n\t\t\"ja/shift_jis.txt\",\n\t\t\"ja/broken_utf8.txt\",\n\t\t\"ja/broken_euc-jp.txt\",\n\t\t\"ja/broken_shift_jis.txt\",\n\t}\n\n\tasserts := []string{\n\t\t\"ascii.txt:2:go test\",\n\t\t\"ja/utf8.txt:2:go テスト\",\n\t\t\"ja/euc-jp.txt:2:go テスト\",\n\t\t\"ja/shift_jis.txt:2:go テスト\",\n\t\t\"ja/broken_utf8.txt:2:go テスト\",\n\t\t\"ja/broken_euc-jp.txt:2:go テスト\",\n\t\t\"ja/broken_shift_jis.txt:2:go テスト\",\n\t}\n\n\tif !assertGrep(pattern, opts, paths, asserts) {\n\t\tt.Errorf(\"Grep result should contain assserts.\")\n\t}\n\n}\n\nfunc TestStdinGrep(t *testing.T) {\n\t// emulate stdin\n\tstashStdin := os.Stdin\n\tfh, _ := os.Open(\"files/ascii.txt\")\n\tos.Stdin = fh\n\tdefer func() { os.Stdin = stashStdin }()\n\n\topts := defaultOption()\n\topts.OutputOption.EnableColor = false\n\topts.SearchOption.SearchStream = true\n\n\tpattern, _ := newPattern(\"go\", opts)\n\n\tpaths := []string{\"\"} // from stdin\n\n\tasserts := []string{\n\t\t\"go test\",\n\t}\n\n\tif !assertGrep(pattern, opts, paths, asserts) {\n\t\tt.Errorf(\"Grep result should contain assserts.\")\n\t}\n}\n\nfunc assertGrep(pattern pattern, opts Option, paths, asserts []string) bool {\n\tbuf := new(bytes.Buffer)\n\tprinter := newPrinter(pattern, buf, opts)\n\n\tin := make(chan string)\n\tdone := make(chan struct{})\n\tgrep := newGrep(pattern, in, done, opts, printer)\n\tgo grep.start()\n\n\tfor _, path := range paths {\n\t\tif path == \"\" {\n\t\t\tin <- path\n\t\t} else {\n\t\t\tin <- \"files/\" + path\n\t\t}\n\t}\n\tclose(in)\n\t<-done\n\n\tresult := buf.String()\n\tfor _, assert := range asserts {\n\t\tif !strings.Contains(result, assert) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "ignore.go",
          "type": "blob",
          "size": 1.48828125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/monochromegane/go-gitignore\"\n\t\"github.com/monochromegane/go-home\"\n)\n\ntype ignoreMatchers []gitignore.IgnoreMatcher\n\nfunc (im ignoreMatchers) Match(path string, isDir bool) bool {\n\tfor _, ig := range im {\n\t\tif ig == nil {\n\t\t\treturn false\n\t\t}\n\t\tif ig.Match(path, isDir) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc newIgnoreMatchers(path string, ignores []string) ignoreMatchers {\n\tvar matchers ignoreMatchers\n\tfor _, i := range ignores {\n\t\tif matcher, err := gitignore.NewGitIgnore(filepath.Join(path, i), path); err == nil {\n\t\t\tmatchers = append(matchers, matcher)\n\t\t}\n\t}\n\treturn matchers\n}\n\nfunc globalGitIgnore(base string) gitignore.IgnoreMatcher {\n\tif homeDir := home.Dir(); homeDir != \"\" {\n\t\tglobalIgnore := globalGitIgnoreName()\n\t\tif globalIgnore != \"\" {\n\t\t\tif matcher, err := gitignore.NewGitIgnore(filepath.Join(homeDir, globalIgnore), base); err == nil {\n\t\t\t\treturn matcher\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc globalGitIgnoreName() string {\n\tgitCmd, err := exec.LookPath(\"git\")\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\tfile, err := exec.Command(gitCmd, \"config\", \"--get\", \"core.excludesfile\").Output()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn strings.TrimSpace(filepath.Base(string(file)))\n}\n\nfunc homePtIgnore(base string) gitignore.IgnoreMatcher {\n\tif homeDir := home.Dir(); homeDir != \"\" {\n\t\tif matcher, err := gitignore.NewGitIgnore(filepath.Join(homeDir, \".ptignore\"), base); err == nil {\n\t\t\treturn matcher\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "line_grep.go",
          "type": "blob",
          "size": 2.658203125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"os\"\n)\n\ntype lineGrep struct {\n\tprinter printer\n\tbefore  int\n\tafter   int\n\tcolumn  bool\n}\n\nfunc newLineGrep(printer printer, opts Option) lineGrep {\n\treturn lineGrep{\n\t\tprinter: printer,\n\t\tbefore:  opts.OutputOption.Before,\n\t\tafter:   opts.OutputOption.After,\n\t\tcolumn:  opts.OutputOption.Column,\n\t}\n}\n\nfunc (g lineGrep) enableContext() bool {\n\treturn g.before > 0 || g.after > 0\n}\n\ntype matchFunc func(b []byte) bool\ntype countFunc func(b []byte) int\n\nfunc (g lineGrep) grepEachLines(f *os.File, encoding int, matchFn matchFunc, countFn countFunc) {\n\tf.Seek(0, 0)\n\tmatch := match{path: f.Name()}\n\n\tvar reader io.Reader\n\tif r := newDecodeReader(f, encoding); r != nil {\n\t\t// decode file from shift-jis or euc-jp.\n\t\treader = r\n\t} else {\n\t\treader = f\n\t}\n\n\tlineNum := 1\n\tmatchState := newMatchState()\n\tafterCount := 0\n\tbeforeMatches := make([]line, 0, g.before)\n\n\tscanner := bufio.NewScanner(reader)\n\tfor scanner.Scan() {\n\t\tif matched := matchFn(scanner.Bytes()); matched || g.enableContext() {\n\t\t\tif g.enableContext() {\n\t\t\t\t// print match and context lines.\n\t\t\t\tmatchState = matchState.transition(matched)\n\n\t\t\t\tif matchState.isBefore() {\n\t\t\t\t\t// store before line.\n\t\t\t\t\tbeforeMatches = g.storeBeforeMatch(beforeMatches, lineNum, scanner.Text(), matched)\n\t\t\t\t} else if matchState.isAfter() {\n\t\t\t\t\tif g.after > 0 {\n\t\t\t\t\t\t// append after line.\n\t\t\t\t\t\tmatch.add(lineNum, 0, scanner.Text(), matched)\n\t\t\t\t\t\tafterCount++\n\t\t\t\t\t} else if g.before > 0 && g.after == 0 {\n\t\t\t\t\t\tbeforeMatches = g.storeBeforeMatch(beforeMatches, lineNum, scanner.Text(), matched)\n\t\t\t\t\t}\n\t\t\t\t\tif afterCount >= g.after {\n\t\t\t\t\t\t// reset to before match\n\t\t\t\t\t\tmatchState = matchState.reset()\n\t\t\t\t\t\tafterCount = 0\n\t\t\t\t\t}\n\t\t\t\t} else if matchState.isMatching() {\n\t\t\t\t\t// append and reset before lines.\n\t\t\t\t\tmatch.lines = append(match.lines, beforeMatches...)\n\t\t\t\t\tbeforeMatches = make([]line, 0, g.before)\n\t\t\t\t\t// append match line.\n\t\t\t\t\tcolumn := 0\n\t\t\t\t\tif g.column {\n\t\t\t\t\t\tcolumn = countFn(scanner.Bytes())\n\t\t\t\t\t}\n\t\t\t\t\tmatch.add(lineNum, column, scanner.Text(), matched)\n\t\t\t\t\t// reset after count.\n\t\t\t\t\tafterCount = 0\n\t\t\t\t}\n\t\t\t} else if matched {\n\t\t\t\t// print only match line.\n\t\t\t\tcolumn := 0\n\t\t\t\tif g.column {\n\t\t\t\t\tcolumn = countFn(scanner.Bytes())\n\t\t\t\t}\n\t\t\t\tmatch.add(lineNum, column, scanner.Text(), matched)\n\t\t\t}\n\t\t}\n\t\tlineNum++\n\t}\n\tg.printer.print(match)\n}\n\nfunc (g lineGrep) storeBeforeMatch(beforeMatches []line, lineNum int, text string, matched bool) []line {\n\tif g.before == 0 {\n\t\treturn beforeMatches\n\t}\n\tif len(beforeMatches) >= g.before {\n\t\tbeforeMatches = beforeMatches[1:]\n\t}\n\treturn append(beforeMatches, line{\n\t\tnum:     lineNum,\n\t\tcolumn:  0,\n\t\ttext:    text,\n\t\tmatched: matched,\n\t})\n}\n"
        },
        {
          "name": "line_grep_test.go",
          "type": "blob",
          "size": 1.6513671875,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestLineGrepOnlyMatch(t *testing.T) {\n\topts := defaultOption()\n\n\texpect := `files/context/context.txt:4:go test\nfiles/context/context.txt:6:go test\n`\n\n\tif !assertLineGrep(opts, \"files/context/context.txt\", expect) {\n\t\tt.Errorf(\"Failed line grep (only match).\")\n\t}\n}\n\nfunc TestLineGrepContext(t *testing.T) {\n\topts := defaultOption()\n\topts.OutputOption.Before = 2\n\topts.OutputOption.After = 2\n\n\texpect := `files/context/context.txt:2-before\nfiles/context/context.txt:3-before\nfiles/context/context.txt:4:go test\nfiles/context/context.txt:5-after\nfiles/context/context.txt:6:go test\nfiles/context/context.txt:7-after\nfiles/context/context.txt:8-after\n`\n\n\tif !assertLineGrep(opts, \"files/context/context.txt\", expect) {\n\t\tt.Errorf(\"Failed line grep (context).\")\n\t}\n}\n\n// Regression test of https://github.com/monochromegane/the_platinum_searcher/issues/166\nfunc TestLineGrepBefore(t *testing.T) {\n\topts := defaultOption()\n\topts.OutputOption.Before = 1\n\n\texpect := `files/context/context.txt:3-before\nfiles/context/context.txt:4:go test\nfiles/context/context.txt:5-after\nfiles/context/context.txt:6:go test\n`\n\tif !assertLineGrep(opts, \"files/context/context.txt\", expect) {\n\t\tt.Errorf(\"Failed line grep (before).\")\n\t}\n}\n\nfunc assertLineGrep(opts Option, path string, expect string) bool {\n\tbuf := new(bytes.Buffer)\n\tprinter := newPrinter(pattern{}, buf, opts)\n\tgrep := newLineGrep(printer, opts)\n\n\tf, _ := os.Open(path)\n\n\tgrep.grepEachLines(f, ASCII, func(b []byte) bool {\n\t\treturn bytes.Contains(b, []byte(\"go\"))\n\t}, func(b []byte) int { return 0 })\n\n\tclose(printer.in)\n\t<-printer.done\n\n\treturn buf.String() == expect\n}\n"
        },
        {
          "name": "match.go",
          "type": "blob",
          "size": 0.3837890625,
          "content": "package the_platinum_searcher\n\ntype match struct {\n\tpath  string\n\tlines []line\n}\n\ntype line struct {\n\tnum     int\n\tcolumn  int\n\ttext    string\n\tmatched bool\n}\n\nfunc (m *match) add(num int, column int, text string, matched bool) {\n\tm.lines = append(m.lines, line{\n\t\tnum:     num,\n\t\tcolumn:  column,\n\t\ttext:    text,\n\t\tmatched: matched,\n\t})\n}\n\nfunc (m match) size() int {\n\treturn len(m.lines)\n}\n"
        },
        {
          "name": "match_state.go",
          "type": "blob",
          "size": 1.4267578125,
          "content": "package the_platinum_searcher\n\ntype matchState interface {\n\ttransition(matched bool) matchState\n\treset() matchState\n\tisBefore() bool\n\tisMatching() bool\n\tisAfter() bool\n}\n\nfunc newMatchState() matchState {\n\treturn stateBeforeMatch{}\n}\n\ntype stateBeforeMatch struct{}\n\nfunc (s stateBeforeMatch) transition(matched bool) matchState {\n\tif matched {\n\t\treturn stateMatching{}\n\t} else {\n\t\treturn s\n\t}\n}\n\nfunc (s stateBeforeMatch) reset() matchState {\n\treturn s\n}\n\nfunc (s stateBeforeMatch) isBefore() bool {\n\treturn true\n}\n\nfunc (s stateBeforeMatch) isMatching() bool {\n\treturn false\n}\n\nfunc (s stateBeforeMatch) isAfter() bool {\n\treturn false\n}\n\ntype stateMatching struct{}\n\nfunc (s stateMatching) transition(matched bool) matchState {\n\tif matched {\n\t\treturn s\n\t} else {\n\t\treturn stateAfterMatch{}\n\t}\n}\n\nfunc (s stateMatching) reset() matchState {\n\treturn stateBeforeMatch{}\n}\n\nfunc (s stateMatching) isBefore() bool {\n\treturn false\n}\n\nfunc (s stateMatching) isMatching() bool {\n\treturn true\n}\n\nfunc (s stateMatching) isAfter() bool {\n\treturn false\n}\n\ntype stateAfterMatch struct{}\n\nfunc (s stateAfterMatch) transition(matched bool) matchState {\n\tif matched {\n\t\treturn stateMatching{}\n\t} else {\n\t\treturn s\n\t}\n}\n\nfunc (s stateAfterMatch) reset() matchState {\n\treturn stateBeforeMatch{}\n}\n\nfunc (s stateAfterMatch) isBefore() bool {\n\treturn false\n}\n\nfunc (s stateAfterMatch) isMatching() bool {\n\treturn false\n}\n\nfunc (s stateAfterMatch) isAfter() bool {\n\treturn true\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 6.8916015625,
          "content": "package the_platinum_searcher\n\nimport \"github.com/jessevdk/go-flags\"\n\n// Top level options\ntype Option struct {\n\tVersion      bool          `long:\"version\" description:\"Show version\"`\n\tOutputOption *OutputOption `group:\"Output Options\"`\n\tSearchOption *SearchOption `group:\"Search Options\"`\n}\n\n// Output options.\ntype OutputOption struct {\n\tColor               func()       `long:\"color\" description:\"Print color codes in results (default: true)\"`\n\tNoColor             func()       `long:\"nocolor\" description:\"Don't print color codes in results (default: false)\"`\n\tForceColor          bool         // Force color. Not user option.\n\tEnableColor         bool         // Enable color. Not user option.\n\tColorLineNumber     func(string) `long:\"color-line-number\" description:\"Color codes for line numbers (default: 1;33)\"`\n\tColorPath           func(string) `long:\"color-path\" description:\"Color codes for path names (default: 1;32)\"`\n\tColorMatch          func(string) `long:\"color-match\" description:\"Color codes for result matches (default: 30;43)\"`\n\tColorCodeLineNumber string       // Color line numbers. Not user option.\n\tColorCodePath       string       // Color path names. Not user option.\n\tColorCodeMatch      string       // Color result matches. Not user option.\n\tGroup               func()       `long:\"group\" description:\"Print file name at header (default: true)\"`\n\tNoGroup             func()       `long:\"nogroup\" description:\"Don't print file name at header (default: false)\"`\n\tForceGroup          bool         // Force group. Not user option.\n\tEnableGroup         bool         // Enable group. Not user option.\n\tNull                bool         `short:\"0\" long:\"null\" description:\"Separate filenames with null (for 'xargs -0') (default: false)\"`\n\tColumn              bool         `long:\"column\" description:\"Print column (default: false)\"`\n\tLineNumber          func()       `long:\"numbers\" description:\"Print Line number. (default: true)\"`\n\tNoLineNumber        func()       `short:\"N\" long:\"nonumbers\" description:\"Omit Line number. (default: false)\"`\n\tForceLineNumber     bool         // Force line number. Not user option.\n\tEnableLineNumber    bool         // Enable line number. Not user option.\n\tAfter               int          `short:\"A\" long:\"after\" description:\"Print lines after match\"`\n\tBefore              int          `short:\"B\" long:\"before\" description:\"Print lines before match\"`\n\tContext             int          `short:\"C\" long:\"context\" description:\"Print lines before and after match\"`\n\tFilesWithMatches    bool         `short:\"l\" long:\"files-with-matches\" description:\"Only print filenames that contain matches\"`\n\tCount               bool         `short:\"c\" long:\"count\" description:\"Only print the number of matching lines for each input file.\"`\n\tOutputEncode        string       `short:\"o\" long:\"output-encode\" description:\"Specify output encoding (none, jis, sjis, euc)\"`\n}\n\nfunc newOutputOption() *OutputOption {\n\topt := &OutputOption{}\n\n\topt.Color = opt.SetEnableColor\n\topt.NoColor = opt.SetDisableColor\n\topt.EnableColor = true\n\n\topt.Group = opt.SetEnableGroup\n\topt.NoGroup = opt.SetDisableGroup\n\topt.EnableGroup = true\n\n\topt.LineNumber = opt.SetEnableLineNumber\n\topt.NoLineNumber = opt.SetDisableLineNumber\n\topt.EnableLineNumber = true\n\n\topt.ColorLineNumber = opt.SetColorLineNumber\n\topt.ColorPath = opt.SetColorPath\n\topt.ColorMatch = opt.SetColorMatch\n\topt.ColorCodeLineNumber = \"1;33\" // yellow with black background\n\topt.ColorCodePath = \"1;32\"       // bold green\n\topt.ColorCodeMatch = \"30;43\"     // black with yellow background\n\n\treturn opt\n}\n\nfunc (o *OutputOption) SetEnableColor() {\n\to.ForceColor = true\n\to.EnableColor = true\n}\n\nfunc (o *OutputOption) SetDisableColor() {\n\to.EnableColor = false\n}\n\nfunc (o *OutputOption) SetEnableLineNumber() {\n\to.ForceLineNumber = true\n\to.EnableLineNumber = true\n}\n\nfunc (o *OutputOption) SetDisableLineNumber() {\n\to.EnableLineNumber = false\n}\n\nfunc (o *OutputOption) SetEnableGroup() {\n\to.ForceGroup = true\n\to.EnableGroup = true\n}\n\nfunc (o *OutputOption) SetDisableGroup() {\n\to.EnableGroup = false\n}\n\nfunc (o *OutputOption) SetColorLineNumber(code string) {\n\to.ColorCodeLineNumber = code\n}\n\nfunc (o *OutputOption) SetColorPath(code string) {\n\to.ColorCodePath = code\n}\n\nfunc (o *OutputOption) SetColorMatch(code string) {\n\to.ColorCodeMatch = code\n}\n\n// Search options.\ntype SearchOption struct {\n\tRegexp                 bool         `short:\"e\" description:\"Parse PATTERN as a regular expression (default: false). Accepted syntax is the same as https://github.com/google/re2/wiki/Syntax except from \\\\C\"`\n\tIgnoreCase             bool         `short:\"i\" long:\"ignore-case\" description:\"Match case insensitively\"`\n\tSmartCase              bool         `short:\"S\" long:\"smart-case\" description:\"Match case insensitively unless PATTERN contains uppercase characters\"`\n\tWordRegexp             bool         `short:\"w\" long:\"word-regexp\" description:\"Only match whole words\"`\n\tIgnore                 []string     `long:\"ignore\" description:\"Ignore files/directories matching pattern\"`\n\tVcsIgnore              []string     `long:\"vcs-ignore\" description:\"VCS ignore files\" default:\".gitignore\"`\n\tGlobalGitIgnore        bool         `long:\"global-gitignore\" description:\"Use git's global gitignore file for ignore patterns\"`\n\tHomePtIgnore           bool         `long:\"home-ptignore\" description:\"Use $Home/.ptignore file for ignore patterns\"`\n\tSkipVcsIgnore          bool         `short:\"U\" long:\"skip-vcs-ignores\" description:\"Don't use VCS ignore file for ignore patterns\"`\n\tFilesWithRegexp        func(string) `short:\"g\" description:\"Print filenames matching PATTERN\"`\n\tEnableFilesWithRegexp  bool         // Enable files with regexp. Not user option.\n\tPatternFilesWithRegexp string       // Pattern files with regexp. Not user option.\n\tFileSearchRegexp       string       `short:\"G\" long:\"file-search-regexp\" description:\"PATTERN Limit search to filenames matching PATTERN\"`\n\tDepth                  int          `long:\"depth\" default:\"25\" description:\"Search up to NUM directories deep\"`\n\tFollow                 bool         `short:\"f\" long:\"follow\" description:\"Follow symlinks\"`\n\tHidden                 bool         `long:\"hidden\" description:\"Search hidden files and directories\"`\n\tSearchStream           bool         // Input from pipe. Not user option.\n}\n\nfunc (o *SearchOption) SetFilesWithRegexp(p string) {\n\to.EnableFilesWithRegexp = true\n\to.PatternFilesWithRegexp = p\n}\n\nfunc newSearchOption() *SearchOption {\n\topt := &SearchOption{}\n\topt.FilesWithRegexp = opt.SetFilesWithRegexp\n\treturn opt\n}\n\nfunc newOptionParser(opts *Option) *flags.Parser {\n\toutput := flags.NewNamedParser(\"pt\", flags.Default)\n\toutput.AddGroup(\"Output Options\", \"\", &OutputOption{})\n\n\tsearch := flags.NewNamedParser(\"pt\", flags.Default)\n\tsearch.AddGroup(\"Search Options\", \"\", &SearchOption{})\n\n\topts.OutputOption = newOutputOption()\n\topts.SearchOption = newSearchOption()\n\n\tparser := flags.NewParser(opts, flags.Default)\n\tparser.Name = \"pt\"\n\tparser.Usage = \"[OPTIONS] PATTERN [PATH]\"\n\treturn parser\n}\n"
        },
        {
          "name": "passthrough_grep.go",
          "type": "blob",
          "size": 0.2099609375,
          "content": "package the_platinum_searcher\n\ntype passthroughGrep struct {\n\tprinter printer\n}\n\nfunc (g passthroughGrep) grep(path string, buf []byte) {\n\tmatch := match{path: path, lines: []line{line{}}}\n\tg.printer.print(match)\n}\n"
        },
        {
          "name": "pattern.go",
          "type": "blob",
          "size": 0.634765625,
          "content": "package the_platinum_searcher\n\nimport \"regexp\"\n\n// pattern should be interface, but match(large []byte) method called through interface is too slow.\ntype pattern struct {\n\tpattern []byte\n\tregexp  *regexp.Regexp\n\topts    Option\n}\n\nfunc newPattern(p string, opts Option) (pattern, error) {\n\tpattern := pattern{pattern: []byte(p), opts: opts}\n\n\tif opts.SearchOption.Regexp {\n\t\tvar reg *regexp.Regexp\n\t\tvar err error\n\t\tif opts.SearchOption.IgnoreCase {\n\t\t\treg, err = regexp.Compile(`(?i)(` + p + `)`)\n\t\t} else {\n\t\t\treg, err = regexp.Compile(`(` + p + `)`)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn pattern, err\n\t\t}\n\t\tpattern.regexp = reg\n\t}\n\treturn pattern, nil\n}\n"
        },
        {
          "name": "platinum_searcher.go",
          "type": "blob",
          "size": 2.6015625,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\n\t\"github.com/jessevdk/go-flags\"\n\t\"github.com/monochromegane/conflag\"\n\t\"github.com/monochromegane/go-home\"\n\t\"github.com/monochromegane/terminal\"\n)\n\nconst version = \"2.2.0\"\n\nconst (\n\tExitCodeOK = iota\n\tExitCodeError\n)\n\nvar opts Option\n\ntype PlatinumSearcher struct {\n\tOut, Err io.Writer\n}\n\nfunc (p PlatinumSearcher) Run(args []string) int {\n\n\tparser := newOptionParser(&opts)\n\n\tconflag.LongHyphen = true\n\tconflag.BoolValue = false\n\tfor _, c := range [...]string{\n\t\tfilepath.Join(xdgConfigHomeDir(), \"pt\", \"config.toml\"),\n\t\tfilepath.Join(home.Dir(), \".ptconfig.toml\"),\n\t\t\".ptconfig.toml\",\n\t} {\n\t\tif args, err := conflag.ArgsFrom(c); err == nil {\n\t\t\tparser.ParseArgs(args)\n\t\t}\n\t}\n\n\targs, err := parser.ParseArgs(args)\n\tif err != nil {\n\t\tif ferr, ok := err.(*flags.Error); ok && ferr.Type == flags.ErrHelp {\n\t\t\treturn ExitCodeOK\n\t\t}\n\t\treturn ExitCodeError\n\t}\n\n\tif opts.Version {\n\t\tfmt.Printf(\"pt version %s\\n\", version)\n\t\treturn ExitCodeOK\n\t}\n\n\tif len(args) == 0 && !opts.SearchOption.EnableFilesWithRegexp {\n\t\tparser.WriteHelp(p.Err)\n\t\treturn ExitCodeError\n\t}\n\n\tif !terminal.IsTerminal(os.Stdout) {\n\t\tif !opts.OutputOption.ForceColor {\n\t\t\topts.OutputOption.EnableColor = false\n\t\t}\n\t\tif !opts.OutputOption.ForceGroup {\n\t\t\topts.OutputOption.EnableGroup = false\n\t\t}\n\t}\n\n\tif p.givenStdin() && p.noRootPathIn(args) {\n\t\topts.SearchOption.SearchStream = true\n\t}\n\n\tif opts.SearchOption.EnableFilesWithRegexp {\n\t\targs = append([]string{\"\"}, args...)\n\t}\n\n\tif opts.OutputOption.Count {\n\t\topts.OutputOption.Before = 0\n\t\topts.OutputOption.After = 0\n\t\topts.OutputOption.Context = 0\n\t}\n\n\tsearch := search{\n\t\troots: p.rootsFrom(args),\n\t\tout:   p.Out,\n\t}\n\tif err = search.start(p.patternFrom(args)); err != nil {\n\t\tfmt.Fprintf(p.Err, \"%s\\n\", err)\n\t\treturn ExitCodeError\n\t}\n\treturn ExitCodeOK\n}\n\nfunc (p PlatinumSearcher) patternFrom(args []string) string {\n\treturn args[0]\n}\n\nfunc (p PlatinumSearcher) rootsFrom(args []string) []string {\n\tif len(args) > 1 {\n\t\treturn args[1:]\n\t} else {\n\t\treturn []string{\".\"}\n\t}\n}\n\nfunc (p PlatinumSearcher) givenStdin() bool {\n\tfi, err := os.Stdin.Stat()\n\tif runtime.GOOS == \"windows\" {\n\t\tif err == nil {\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tmode := fi.Mode()\n\t\tif (mode&os.ModeNamedPipe != 0) || mode.IsRegular() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p PlatinumSearcher) noRootPathIn(args []string) bool {\n\treturn len(args) == 1\n}\n\nfunc xdgConfigHomeDir() string {\n\txdgConfigHome := os.Getenv(\"XDG_CONFIG_HOME\")\n\tif xdgConfigHome == \"\" {\n\t\txdgConfigHome = filepath.Join(home.Dir(), \".config\")\n\t}\n\treturn xdgConfigHome\n}\n"
        },
        {
          "name": "platinum_searcher_test.go",
          "type": "blob",
          "size": 0.4560546875,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc BenchmarkPT(b *testing.B) {\n\tfor name, args := range map[string][]string{\n\t\t\"findOnly\": {\"-g\", \".\", os.Getenv(\"GOPATH\")},\n\t\t\"normal\":   {\"test\", os.Getenv(\"GOPATH\")},\n\t} {\n\t\targs := args\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tret := PlatinumSearcher{Out: ioutil.Discard, Err: os.Stderr}.Run(args)\n\t\t\t\tif ret != 0 {\n\t\t\t\t\tb.Fatal(\"failed\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "print.go",
          "type": "blob",
          "size": 0.6279296875,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io\"\n)\n\ntype printer struct {\n\tin        chan match\n\topts      Option\n\tformatter formatPrinter\n\tdone      chan struct{}\n}\n\nfunc newPrinter(pattern pattern, out io.Writer, opts Option) printer {\n\tp := printer{\n\t\tin:        make(chan match, 200),\n\t\topts:      opts,\n\t\tformatter: newFormatPrinter(pattern, out, opts),\n\t\tdone:      make(chan struct{}),\n\t}\n\n\tgo p.loop()\n\treturn p\n}\n\nfunc (p printer) print(match match) {\n\tif match.size() == 0 {\n\t\treturn\n\t}\n\n\tp.in <- match\n}\n\nfunc (p printer) loop() {\n\tdefer func() {\n\t\tp.done <- struct{}{}\n\t}()\n\n\tfor match := range p.in {\n\t\tp.formatter.print(match)\n\t}\n}\n"
        },
        {
          "name": "readdir_dirent_fileno.go",
          "type": "blob",
          "size": 0.1611328125,
          "content": "// +build freebsd openbsd netbsd\n\npackage the_platinum_searcher\n\nimport \"syscall\"\n\nfunc direntInode(dirent *syscall.Dirent) uint64 {\n\treturn uint64(dirent.Fileno)\n}\n"
        },
        {
          "name": "readdir_dirent_ino.go",
          "type": "blob",
          "size": 0.1591796875,
          "content": "// +build linux,!appengine darwin\n\npackage the_platinum_searcher\n\nimport \"syscall\"\n\nfunc direntInode(dirent *syscall.Dirent) uint64 {\n\treturn uint64(dirent.Ino)\n}\n"
        },
        {
          "name": "readdir_portable.go",
          "type": "blob",
          "size": 0.3857421875,
          "content": "// +build appengine !linux,!darwin,!freebsd,!openbsd,!netbsd\n\npackage the_platinum_searcher\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc readDir(dirName string) ([]*fileInfo, error) {\n\tfis := []*fileInfo{}\n\tfs, err := ioutil.ReadDir(dirName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, fi := range fs {\n\t\tfis = append(fis, newFileInfo(dirName, fi.Name(), fi.Mode()&os.ModeType))\n\t}\n\treturn fis, nil\n}\n"
        },
        {
          "name": "readdir_unix.go",
          "type": "blob",
          "size": 3.0751953125,
          "content": "// +build linux,!appengine darwin freebsd openbsd netbsd\n\npackage the_platinum_searcher\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nconst blockSize = 8 << 10\n\n// unknownFileMode is a sentinel (and bogus) os.FileMode\n// value used to represent a syscall.DT_UNKNOWN Dirent.Type.\nconst unknownFileMode os.FileMode = os.ModeNamedPipe | os.ModeSocket | os.ModeDevice\n\nfunc readDir(dirName string) ([]*fileInfo, error) {\n\tfd, err := syscall.Open(dirName, 0, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer syscall.Close(fd)\n\n\tfis := []*fileInfo{}\n\t// The buffer must be at least a block long.\n\tbuf := make([]byte, blockSize) // stack-allocated; doesn't escape\n\tbufp := 0                      // starting read position in buf\n\tnbuf := 0                      // end valid data in buf\n\tfor {\n\t\tif bufp >= nbuf {\n\t\t\tbufp = 0\n\t\t\tnbuf, err = syscall.ReadDirent(fd, buf)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, os.NewSyscallError(\"readdirent\", err)\n\t\t\t}\n\t\t\tif nbuf <= 0 {\n\t\t\t\treturn fis, nil\n\t\t\t}\n\t\t}\n\t\tconsumed, name, typ := parseDirEnt(buf[bufp:nbuf])\n\t\tbufp += consumed\n\t\tif name == \"\" || name == \".\" || name == \"..\" {\n\t\t\tcontinue\n\t\t}\n\t\t// Fallback for filesystems (like old XFS) that don't\n\t\t// support Dirent.Type and have DT_UNKNOWN (0) there\n\t\t// instead.\n\t\tif typ == unknownFileMode {\n\t\t\tfi, err := os.Lstat(dirName + \"/\" + name)\n\t\t\tif err != nil {\n\t\t\t\t// It got deleted in the meantime.\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ttyp = fi.Mode() & os.ModeType\n\t\t}\n\t\tfis = append(fis, newFileInfo(dirName, name, typ))\n\t}\n}\n\nfunc parseDirEnt(buf []byte) (consumed int, name string, typ os.FileMode) {\n\t// golang.org/issue/15653\n\tdirent := (*syscall.Dirent)(unsafe.Pointer(&buf[0]))\n\tif v := unsafe.Offsetof(dirent.Reclen) + unsafe.Sizeof(dirent.Reclen); uintptr(len(buf)) < v {\n\t\tpanic(fmt.Sprintf(\"buf size of %d smaller than dirent header size %d\", len(buf), v))\n\t}\n\tif len(buf) < int(dirent.Reclen) {\n\t\tpanic(fmt.Sprintf(\"buf size %d < record length %d\", len(buf), dirent.Reclen))\n\t}\n\tconsumed = int(dirent.Reclen)\n\tif direntInode(dirent) == 0 { // File absent in directory.\n\t\treturn\n\t}\n\tswitch dirent.Type {\n\tcase syscall.DT_REG:\n\t\ttyp = 0\n\tcase syscall.DT_DIR:\n\t\ttyp = os.ModeDir\n\tcase syscall.DT_LNK:\n\t\ttyp = os.ModeSymlink\n\tcase syscall.DT_BLK:\n\t\ttyp = os.ModeDevice\n\tcase syscall.DT_FIFO:\n\t\ttyp = os.ModeNamedPipe\n\tcase syscall.DT_SOCK:\n\t\ttyp = os.ModeSocket\n\tcase syscall.DT_UNKNOWN:\n\t\ttyp = unknownFileMode\n\tdefault:\n\t\t// Skip weird things.\n\t\t// It's probably a DT_WHT (http://lwn.net/Articles/325369/)\n\t\t// or something. Revisit if/when this package is moved outside\n\t\t// of goimports. goimports only cares about regular files,\n\t\t// symlinks, and directories.\n\t\treturn\n\t}\n\n\tnameBuf := (*[unsafe.Sizeof(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))\n\tnameLen := bytes.IndexByte(nameBuf[:], 0)\n\tif nameLen < 0 {\n\t\tpanic(\"failed to find terminating 0 byte in dirent\")\n\t}\n\n\t// Special cases for common things:\n\tif nameLen == 1 && nameBuf[0] == '.' {\n\t\tname = \".\"\n\t} else if nameLen == 2 && nameBuf[0] == '.' && nameBuf[1] == '.' {\n\t\tname = \"..\"\n\t} else {\n\t\tname = string(nameBuf[:nameLen])\n\t}\n\treturn\n}\n"
        },
        {
          "name": "search.go",
          "type": "blob",
          "size": 1.37109375,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"io\"\n\t\"regexp\"\n)\n\ntype search struct {\n\troots []string\n\tout   io.Writer\n}\n\nfunc (s search) start(pattern string) error {\n\tgrepChan := make(chan string, 5000)\n\tdone := make(chan struct{})\n\n\tif opts.SearchOption.WordRegexp {\n\t\topts.SearchOption.Regexp = true\n\t\tpattern = \"\\\\b\" + pattern + \"\\\\b\"\n\t}\n\n\tif opts.SearchOption.SmartCase {\n\t\tif !regexp.MustCompile(`[[:upper:]]`).MatchString(pattern) {\n\t\t\topts.SearchOption.IgnoreCase = true\n\t\t}\n\t}\n\n\tif opts.SearchOption.IgnoreCase {\n\t\topts.SearchOption.Regexp = true\n\t}\n\n\tp, err := newPattern(pattern, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif opts.OutputOption.Context > 0 {\n\t\topts.OutputOption.Before = opts.OutputOption.Context\n\t\topts.OutputOption.After = opts.OutputOption.Context\n\t}\n\n\tvar regFile *regexp.Regexp\n\tif opts.SearchOption.FileSearchRegexp != \"\" {\n\t\tregFile, err = regexp.Compile(opts.SearchOption.FileSearchRegexp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif opts.SearchOption.EnableFilesWithRegexp {\n\t\topts.OutputOption.FilesWithMatches = true\n\t\tif opts.SearchOption.PatternFilesWithRegexp != \"\" {\n\t\t\tregFile, err = regexp.Compile(opts.SearchOption.PatternFilesWithRegexp)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tgo find{\n\t\tout:  grepChan,\n\t\topts: opts,\n\t}.start(s.roots, regFile)\n\n\tgo newGrep(\n\t\tp,\n\t\tgrepChan,\n\t\tdone,\n\t\topts,\n\t\tnewPrinter(p, s.out, opts),\n\t).start()\n\n\t<-done\n\n\treturn nil\n}\n"
        },
        {
          "name": "walk.go",
          "type": "blob",
          "size": 0.95703125,
          "content": "package the_platinum_searcher\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype walkFunc func(path string, info *fileInfo, depth int, ignores ignoreMatchers) (ignoreMatchers, error)\n\nfunc walkIn(root string, ignores ignoreMatchers, followed bool, walkFn walkFunc) error {\n\tinfo, err := os.Lstat(root)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn walk(root, newFileInfo(root, info.Name(), info.Mode()), 1, ignores, followed, walkFn)\n}\n\nfunc walk(path string, info *fileInfo, depth int, parentIgnores ignoreMatchers, followed bool, walkFn walkFunc) error {\n\tignores, walkError := walkFn(path, info, depth, parentIgnores)\n\tif walkError != nil {\n\t\tif info.isDir(false) && walkError == filepath.SkipDir {\n\t\t\treturn nil\n\t\t}\n\t\treturn walkError\n\t}\n\n\tif !info.isDir(followed) {\n\t\treturn nil\n\t}\n\n\tfiles, err := readDir(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdepth++\n\tfor _, file := range files {\n\t\twalk(path+string(os.PathSeparator)+file.name, file, depth, ignores, followed, walkFn)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "wercker.yml",
          "type": "blob",
          "size": 1.91796875,
          "content": "box: golang\nbuild:\n  steps:\n    - setup-go-workspace\n    - script:\n        name: install packages\n        code: |\n          go get -u -v github.com/laher/goxc\n          go get -u -v github.com/tools/godep\n    - script:\n        name: go get\n        code: |\n          go version\n          godep restore\n    - script:\n        name: go test\n        code: |\n          godep go test ./...\n    - script:\n        name: goxc build & archive\n        code: |\n          mkdir Godeps/_workspace\n          GODEPPATH=`godep path`\n          export GOPATH=\"$GODEPPATH:$GOPATH\"\n          goxc -tasks='xc archive' -bc 'linux windows darwin' -d $WERCKER_OUTPUT_DIR/ -resources-include='README*' -main-dirs-exclude='Godeps,lib' -n pt\n    - script:\n        name: output release tag\n        code: |\n          git describe --tags --exact --match 'v*' > $WERCKER_OUTPUT_DIR/.release_tag || true\ndeploy:\n  steps:\n    - script:\n        name: install packages\n        code: |\n          apt-get update -y\n          apt-get install -y file\n    - script:\n        name: restore release tag\n        code: |\n          export RELEASE_TAG=$(cat .release_tag)\n    - wercker/github-create-release:\n        token: $GITHUB_TOKEN\n        tag: $RELEASE_TAG\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_linux_386.tar.gz\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_linux_amd64.tar.gz\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_linux_arm.tar.gz\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_darwin_386.zip\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_darwin_amd64.zip\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_windows_386.zip\n    - wercker/github-upload-asset:\n        token: $GITHUB_TOKEN\n        file: snapshot/pt_windows_amd64.zip\n"
        }
      ]
    }
  ]
}