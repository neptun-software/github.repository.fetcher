{
  "metadata": {
    "timestamp": 1736567076330,
    "page": 662,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hpcloud/tail",
      "stars": 2729,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": ".test\n.go\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.208984375,
          "content": "language: go\n\nscript:\n  - go test -race -v ./...\n\ngo:\n  - 1.5\n  - 1.6\n  - 1.7\n  - 1.8\n  - tip\n\nmatrix:\n  allow_failures:\n    - go: tip\n\ninstall:\n  - go get gopkg.in/fsnotify/fsnotify.v1\n  - go get gopkg.in/tomb.v1\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 1.3427734375,
          "content": "# API v1 (gopkg.in/hpcloud/tail.v1)\n\n## April, 2016\n\n* Migrated to godep, as depman is not longer supported\n* Introduced golang vendoring feature\n* Fixed issue [#57](https://github.com/hpcloud/tail/issues/57) related to reopen deleted file \n\n## July, 2015\n\n* Fix inotify watcher leak; remove `Cleanup` (#51)\n\n# API v0 (gopkg.in/hpcloud/tail.v0)\n\n## June, 2015\n\n* Don't return partial lines (PR #40)\n* Use stable version of fsnotify (#46)\n\n## July, 2014\n\n* Fix tail for Windows (PR #36)\n\n## May, 2014\n\n* Improved rate limiting using leaky bucket (PR #29)\n* Fix odd line splitting (PR #30)\n\n## Apr, 2014\n\n* LimitRate now discards read buffer (PR #28)\n* allow reading of longer lines if MaxLineSize is unset (PR #24)\n* updated deps.json to latest fsnotify (441bbc86b1)\n\n## Feb, 2014\n\n* added `Config.Logger` to suppress library logging\n\n## Nov, 2013\n\n* add Cleanup to remove leaky inotify watches (PR #20)\n\n## Aug, 2013\n\n* redesigned Location field (PR #12)\n* add tail.Tell (PR #14)\n\n## July, 2013\n\n* Rate limiting (PR #10)\n\n## May, 2013\n\n* Detect file deletions/renames in polling file watcher (PR #1)\n* Detect file truncation\n* Fix potential race condition when reopening the file (issue 5)\n* Fix potential blocking of `tail.Stop` (issue 4)\n* Fix uncleaned up ChangeEvents goroutines after calling tail.Stop\n* Support Follow=false\n\n## Feb, 2013\n\n* Initial open source release\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.4736328125,
          "content": "FROM golang\n\nRUN mkdir -p $GOPATH/src/github.com/hpcloud/tail/\nADD . $GOPATH/src/github.com/hpcloud/tail/\n\n# expecting to fetch dependencies successfully.\nRUN go get -v github.com/hpcloud/tail\n\n# expecting to run the test successfully.\nRUN go test -v github.com/hpcloud/tail\n\n# expecting to install successfully\nRUN go install -v github.com/hpcloud/tail\nRUN go install -v github.com/hpcloud/tail/cmd/gotail\n\nRUN $GOPATH/bin/gotail -h || true\n\nENV PATH $GOPATH/bin:$PATH\nCMD [\"gotail\"]\n"
        },
        {
          "name": "Godeps",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.1142578125,
          "content": "# The MIT License (MIT)\n\n# Â© Copyright 2015 Hewlett Packard Enterprise Development LP\nCopyright (c) 2014 ActiveState\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.150390625,
          "content": "default:\ttest\n\ntest:\t*.go\n\tgo test -v -race ./...\n\nfmt:\n\tgofmt -w .\n\n# Run the test in an isolated environment.\nfulltest:\n\tdocker build -t hpcloud/tail .\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.8623046875,
          "content": "[![Build Status](https://travis-ci.org/hpcloud/tail.svg)](https://travis-ci.org/hpcloud/tail)\n[![Build status](https://ci.appveyor.com/api/projects/status/vrl3paf9md0a7bgk/branch/master?svg=true)](https://ci.appveyor.com/project/Nino-K/tail/branch/master)\n\n# Go package for tail-ing files\n\nA Go package striving to emulate the features of the BSD `tail` program. \n\n```Go\nt, err := tail.TailFile(\"/var/log/nginx.log\", tail.Config{Follow: true})\nfor line := range t.Lines {\n    fmt.Println(line.Text)\n}\n```\n\nSee [API documentation](http://godoc.org/github.com/hpcloud/tail).\n\n## Log rotation\n\nTail comes with full support for truncation/move detection as it is\ndesigned to work with log rotation tools.\n\n## Installing\n\n    go get github.com/hpcloud/tail/...\n\n## Windows support\n\nThis package [needs assistance](https://github.com/hpcloud/tail/labels/Windows) for full Windows support.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.2392578125,
          "content": "version: 0.{build}\nskip_tags: true\ncache: C:\\Users\\appveyor\\AppData\\Local\\NuGet\\Cache\nbuild_script:\n- SET GOPATH=c:\\workspace\n- go test -v -race ./...\ntest: off\nclone_folder: c:\\workspace\\src\\github.com\\hpcloud\\tail\nbranches:\n  only:\n  - master\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "ratelimiter",
          "type": "tree",
          "content": null
        },
        {
          "name": "tail.go",
          "type": "blob",
          "size": 10.0478515625,
          "content": "// Copyright (c) 2015 HPE Software Inc. All rights reserved.\n// Copyright (c) 2013 ActiveState Software Inc. All rights reserved.\n\npackage tail\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hpcloud/tail/ratelimiter\"\n\t\"github.com/hpcloud/tail/util\"\n\t\"github.com/hpcloud/tail/watch\"\n\t\"gopkg.in/tomb.v1\"\n)\n\nvar (\n\tErrStop = errors.New(\"tail should now stop\")\n)\n\ntype Line struct {\n\tText string\n\tTime time.Time\n\tErr  error // Error from tail\n}\n\n// NewLine returns a Line with present time.\nfunc NewLine(text string) *Line {\n\treturn &Line{text, time.Now(), nil}\n}\n\n// SeekInfo represents arguments to `os.Seek`\ntype SeekInfo struct {\n\tOffset int64\n\tWhence int // os.SEEK_*\n}\n\ntype logger interface {\n\tFatal(v ...interface{})\n\tFatalf(format string, v ...interface{})\n\tFatalln(v ...interface{})\n\tPanic(v ...interface{})\n\tPanicf(format string, v ...interface{})\n\tPanicln(v ...interface{})\n\tPrint(v ...interface{})\n\tPrintf(format string, v ...interface{})\n\tPrintln(v ...interface{})\n}\n\n// Config is used to specify how a file must be tailed.\ntype Config struct {\n\t// File-specifc\n\tLocation    *SeekInfo // Seek to this location before tailing\n\tReOpen      bool      // Reopen recreated files (tail -F)\n\tMustExist   bool      // Fail early if the file does not exist\n\tPoll        bool      // Poll for file changes instead of using inotify\n\tPipe        bool      // Is a named pipe (mkfifo)\n\tRateLimiter *ratelimiter.LeakyBucket\n\n\t// Generic IO\n\tFollow      bool // Continue looking for new lines (tail -f)\n\tMaxLineSize int  // If non-zero, split longer lines into multiple lines\n\n\t// Logger, when nil, is set to tail.DefaultLogger\n\t// To disable logging: set field to tail.DiscardingLogger\n\tLogger logger\n}\n\ntype Tail struct {\n\tFilename string\n\tLines    chan *Line\n\tConfig\n\n\tfile   *os.File\n\treader *bufio.Reader\n\n\twatcher watch.FileWatcher\n\tchanges *watch.FileChanges\n\n\ttomb.Tomb // provides: Done, Kill, Dying\n\n\tlk sync.Mutex\n}\n\nvar (\n\t// DefaultLogger is used when Config.Logger == nil\n\tDefaultLogger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t// DiscardingLogger can be used to disable logging output\n\tDiscardingLogger = log.New(ioutil.Discard, \"\", 0)\n)\n\n// TailFile begins tailing the file. Output stream is made available\n// via the `Tail.Lines` channel. To handle errors during tailing,\n// invoke the `Wait` or `Err` method after finishing reading from the\n// `Lines` channel.\nfunc TailFile(filename string, config Config) (*Tail, error) {\n\tif config.ReOpen && !config.Follow {\n\t\tutil.Fatal(\"cannot set ReOpen without Follow.\")\n\t}\n\n\tt := &Tail{\n\t\tFilename: filename,\n\t\tLines:    make(chan *Line),\n\t\tConfig:   config,\n\t}\n\n\t// when Logger was not specified in config, use default logger\n\tif t.Logger == nil {\n\t\tt.Logger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t}\n\n\tif t.Poll {\n\t\tt.watcher = watch.NewPollingFileWatcher(filename)\n\t} else {\n\t\tt.watcher = watch.NewInotifyFileWatcher(filename)\n\t}\n\n\tif t.MustExist {\n\t\tvar err error\n\t\tt.file, err = OpenFile(t.Filename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tgo t.tailFileSync()\n\n\treturn t, nil\n}\n\n// Return the file's current position, like stdio's ftell().\n// But this value is not very accurate.\n// it may readed one line in the chan(tail.Lines),\n// so it may lost one line.\nfunc (tail *Tail) Tell() (offset int64, err error) {\n\tif tail.file == nil {\n\t\treturn\n\t}\n\toffset, err = tail.file.Seek(0, os.SEEK_CUR)\n\tif err != nil {\n\t\treturn\n\t}\n\n\ttail.lk.Lock()\n\tdefer tail.lk.Unlock()\n\tif tail.reader == nil {\n\t\treturn\n\t}\n\n\toffset -= int64(tail.reader.Buffered())\n\treturn\n}\n\n// Stop stops the tailing activity.\nfunc (tail *Tail) Stop() error {\n\ttail.Kill(nil)\n\treturn tail.Wait()\n}\n\n// StopAtEOF stops tailing as soon as the end of the file is reached.\nfunc (tail *Tail) StopAtEOF() error {\n\ttail.Kill(errStopAtEOF)\n\treturn tail.Wait()\n}\n\nvar errStopAtEOF = errors.New(\"tail: stop at eof\")\n\nfunc (tail *Tail) close() {\n\tclose(tail.Lines)\n\ttail.closeFile()\n}\n\nfunc (tail *Tail) closeFile() {\n\tif tail.file != nil {\n\t\ttail.file.Close()\n\t\ttail.file = nil\n\t}\n}\n\nfunc (tail *Tail) reopen() error {\n\ttail.closeFile()\n\tfor {\n\t\tvar err error\n\t\ttail.file, err = OpenFile(tail.Filename)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\ttail.Logger.Printf(\"Waiting for %s to appear...\", tail.Filename)\n\t\t\t\tif err := tail.watcher.BlockUntilExists(&tail.Tomb); err != nil {\n\t\t\t\t\tif err == tomb.ErrDying {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn fmt.Errorf(\"Failed to detect creation of %s: %s\", tail.Filename, err)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"Unable to open file %s: %s\", tail.Filename, err)\n\t\t}\n\t\tbreak\n\t}\n\treturn nil\n}\n\nfunc (tail *Tail) readLine() (string, error) {\n\ttail.lk.Lock()\n\tline, err := tail.reader.ReadString('\\n')\n\ttail.lk.Unlock()\n\tif err != nil {\n\t\t// Note ReadString \"returns the data read before the error\" in\n\t\t// case of an error, including EOF, so we return it as is. The\n\t\t// caller is expected to process it if err is EOF.\n\t\treturn line, err\n\t}\n\n\tline = strings.TrimRight(line, \"\\n\")\n\n\treturn line, err\n}\n\nfunc (tail *Tail) tailFileSync() {\n\tdefer tail.Done()\n\tdefer tail.close()\n\n\tif !tail.MustExist {\n\t\t// deferred first open.\n\t\terr := tail.reopen()\n\t\tif err != nil {\n\t\t\tif err != tomb.ErrDying {\n\t\t\t\ttail.Kill(err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Seek to requested location on first open of the file.\n\tif tail.Location != nil {\n\t\t_, err := tail.file.Seek(tail.Location.Offset, tail.Location.Whence)\n\t\ttail.Logger.Printf(\"Seeked %s - %+v\\n\", tail.Filename, tail.Location)\n\t\tif err != nil {\n\t\t\ttail.Killf(\"Seek error on %s: %s\", tail.Filename, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\ttail.openReader()\n\n\tvar offset int64\n\tvar err error\n\n\t// Read line by line.\n\tfor {\n\t\t// do not seek in named pipes\n\t\tif !tail.Pipe {\n\t\t\t// grab the position in case we need to back up in the event of a half-line\n\t\t\toffset, err = tail.Tell()\n\t\t\tif err != nil {\n\t\t\t\ttail.Kill(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tline, err := tail.readLine()\n\n\t\t// Process `line` even if err is EOF.\n\t\tif err == nil {\n\t\t\tcooloff := !tail.sendLine(line)\n\t\t\tif cooloff {\n\t\t\t\t// Wait a second before seeking till the end of\n\t\t\t\t// file when rate limit is reached.\n\t\t\t\tmsg := (\"Too much log activity; waiting a second \" +\n\t\t\t\t\t\"before resuming tailing\")\n\t\t\t\ttail.Lines <- &Line{msg, time.Now(), errors.New(msg)}\n\t\t\t\tselect {\n\t\t\t\tcase <-time.After(time.Second):\n\t\t\t\tcase <-tail.Dying():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := tail.seekEnd(); err != nil {\n\t\t\t\t\ttail.Kill(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else if err == io.EOF {\n\t\t\tif !tail.Follow {\n\t\t\t\tif line != \"\" {\n\t\t\t\t\ttail.sendLine(line)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tail.Follow && line != \"\" {\n\t\t\t\t// this has the potential to never return the last line if\n\t\t\t\t// it's not followed by a newline; seems a fair trade here\n\t\t\t\terr := tail.seekTo(SeekInfo{Offset: offset, Whence: 0})\n\t\t\t\tif err != nil {\n\t\t\t\t\ttail.Kill(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// When EOF is reached, wait for more data to become\n\t\t\t// available. Wait strategy is based on the `tail.watcher`\n\t\t\t// implementation (inotify or polling).\n\t\t\terr := tail.waitForChanges()\n\t\t\tif err != nil {\n\t\t\t\tif err != ErrStop {\n\t\t\t\t\ttail.Kill(err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t// non-EOF error\n\t\t\ttail.Killf(\"Error reading %s: %s\", tail.Filename, err)\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase <-tail.Dying():\n\t\t\tif tail.Err() == errStopAtEOF {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t}\n}\n\n// waitForChanges waits until the file has been appended, deleted,\n// moved or truncated. When moved or deleted - the file will be\n// reopened if ReOpen is true. Truncated files are always reopened.\nfunc (tail *Tail) waitForChanges() error {\n\tif tail.changes == nil {\n\t\tpos, err := tail.file.Seek(0, os.SEEK_CUR)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttail.changes, err = tail.watcher.ChangeEvents(&tail.Tomb, pos)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tselect {\n\tcase <-tail.changes.Modified:\n\t\treturn nil\n\tcase <-tail.changes.Deleted:\n\t\ttail.changes = nil\n\t\tif tail.ReOpen {\n\t\t\t// XXX: we must not log from a library.\n\t\t\ttail.Logger.Printf(\"Re-opening moved/deleted file %s ...\", tail.Filename)\n\t\t\tif err := tail.reopen(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttail.Logger.Printf(\"Successfully reopened %s\", tail.Filename)\n\t\t\ttail.openReader()\n\t\t\treturn nil\n\t\t} else {\n\t\t\ttail.Logger.Printf(\"Stopping tail as file no longer exists: %s\", tail.Filename)\n\t\t\treturn ErrStop\n\t\t}\n\tcase <-tail.changes.Truncated:\n\t\t// Always reopen truncated files (Follow is true)\n\t\ttail.Logger.Printf(\"Re-opening truncated file %s ...\", tail.Filename)\n\t\tif err := tail.reopen(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttail.Logger.Printf(\"Successfully reopened truncated %s\", tail.Filename)\n\t\ttail.openReader()\n\t\treturn nil\n\tcase <-tail.Dying():\n\t\treturn ErrStop\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc (tail *Tail) openReader() {\n\tif tail.MaxLineSize > 0 {\n\t\t// add 2 to account for newline characters\n\t\ttail.reader = bufio.NewReaderSize(tail.file, tail.MaxLineSize+2)\n\t} else {\n\t\ttail.reader = bufio.NewReader(tail.file)\n\t}\n}\n\nfunc (tail *Tail) seekEnd() error {\n\treturn tail.seekTo(SeekInfo{Offset: 0, Whence: os.SEEK_END})\n}\n\nfunc (tail *Tail) seekTo(pos SeekInfo) error {\n\t_, err := tail.file.Seek(pos.Offset, pos.Whence)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Seek error on %s: %s\", tail.Filename, err)\n\t}\n\t// Reset the read buffer whenever the file is re-seek'ed\n\ttail.reader.Reset(tail.file)\n\treturn nil\n}\n\n// sendLine sends the line(s) to Lines channel, splitting longer lines\n// if necessary. Return false if rate limit is reached.\nfunc (tail *Tail) sendLine(line string) bool {\n\tnow := time.Now()\n\tlines := []string{line}\n\n\t// Split longer lines\n\tif tail.MaxLineSize > 0 && len(line) > tail.MaxLineSize {\n\t\tlines = util.PartitionString(line, tail.MaxLineSize)\n\t}\n\n\tfor _, line := range lines {\n\t\ttail.Lines <- &Line{line, now, nil}\n\t}\n\n\tif tail.Config.RateLimiter != nil {\n\t\tok := tail.Config.RateLimiter.Pour(uint16(len(lines)))\n\t\tif !ok {\n\t\t\ttail.Logger.Printf(\"Leaky bucket full (%v); entering 1s cooloff period.\\n\",\n\t\t\t\ttail.Filename)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Cleanup removes inotify watches added by the tail package. This function is\n// meant to be invoked from a process's exit handler. Linux kernel may not\n// automatically remove inotify watches after the process exits.\nfunc (tail *Tail) Cleanup() {\n\twatch.Cleanup(tail.Filename)\n}\n"
        },
        {
          "name": "tail_posix.go",
          "type": "blob",
          "size": 0.1552734375,
          "content": "// +build linux darwin freebsd netbsd openbsd\n\npackage tail\n\nimport (\n\t\"os\"\n)\n\nfunc OpenFile(name string) (file *os.File, err error) {\n\treturn os.Open(name)\n}\n"
        },
        {
          "name": "tail_test.go",
          "type": "blob",
          "size": 15.76171875,
          "content": "// Copyright (c) 2015 HPE Software Inc. All rights reserved.\n// Copyright (c) 2013 ActiveState Software Inc. All rights reserved.\n\n// TODO:\n//  * repeat all the tests with Poll:true\n\npackage tail\n\nimport (\n\t_ \"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hpcloud/tail/ratelimiter\"\n\t\"github.com/hpcloud/tail/watch\"\n)\n\nfunc init() {\n\t// Clear the temporary test directory\n\terr := os.RemoveAll(\".test\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestMain(m *testing.M) {\n\t// Use a smaller poll duration for faster test runs. Keep it below\n\t// 100ms (which value is used as common delays for tests)\n\twatch.POLL_DURATION = 5 * time.Millisecond\n\tos.Exit(m.Run())\n}\n\nfunc TestMustExist(t *testing.T) {\n\ttail, err := TailFile(\"/no/such/file\", Config{Follow: true, MustExist: true})\n\tif err == nil {\n\t\tt.Error(\"MustExist:true is violated\")\n\t\ttail.Stop()\n\t}\n\ttail, err = TailFile(\"/no/such/file\", Config{Follow: true, MustExist: false})\n\tif err != nil {\n\t\tt.Error(\"MustExist:false is violated\")\n\t}\n\ttail.Stop()\n\t_, err = TailFile(\"README.md\", Config{Follow: true, MustExist: true})\n\tif err != nil {\n\t\tt.Error(\"MustExist:true on an existing file is violated\")\n\t}\n\ttail.Cleanup()\n}\n\nfunc TestWaitsForFileToExist(t *testing.T) {\n\ttailTest := NewTailTest(\"waits-for-file-to-exist\", t)\n\ttail := tailTest.StartTail(\"test.txt\", Config{})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"hello\", \"world\"}, false)\n\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestWaitsForFileToExistRelativePath(t *testing.T) {\n\ttailTest := NewTailTest(\"waits-for-file-to-exist-relative\", t)\n\n\toldWD, err := os.Getwd()\n\tif err != nil {\n\t\ttailTest.Fatal(err)\n\t}\n\tos.Chdir(tailTest.path)\n\tdefer os.Chdir(oldWD)\n\n\ttail, err := TailFile(\"test.txt\", Config{})\n\tif err != nil {\n\t\ttailTest.Fatal(err)\n\t}\n\n\tgo tailTest.VerifyTailOutput(tail, []string{\"hello\", \"world\"}, false)\n\n\t<-time.After(100 * time.Millisecond)\n\tif err := ioutil.WriteFile(\"test.txt\", []byte(\"hello\\nworld\\n\"), 0600); err != nil {\n\t\ttailTest.Fatal(err)\n\t}\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestStop(t *testing.T) {\n\ttail, err := TailFile(\"_no_such_file\", Config{Follow: true, MustExist: false})\n\tif err != nil {\n\t\tt.Error(\"MustExist:false is violated\")\n\t}\n\tif tail.Stop() != nil {\n\t\tt.Error(\"Should be stoped successfully\")\n\t}\n\ttail.Cleanup()\n}\n\nfunc TestStopAtEOF(t *testing.T) {\n\ttailTest := NewTailTest(\"maxlinesize\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nthere\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: true, Location: nil})\n\n\t// read \"hello\"\n\tline := <-tail.Lines\n\tif line.Text != \"hello\" {\n\t\tt.Errorf(\"Expected to get 'hello', got '%s' instead\", line.Text)\n\t}\n\n\ttailTest.VerifyTailOutput(tail, []string{\"there\", \"world\"}, false)\n\ttail.StopAtEOF()\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestMaxLineSizeFollow(t *testing.T) {\n\t// As last file line does not end with newline, it will not be present in tail's output\n\tmaxLineSize(t, true, \"hello\\nworld\\nfin\\nhe\", []string{\"hel\", \"lo\", \"wor\", \"ld\", \"fin\"})\n}\n\nfunc TestMaxLineSizeNoFollow(t *testing.T) {\n\tmaxLineSize(t, false, \"hello\\nworld\\nfin\\nhe\", []string{\"hel\", \"lo\", \"wor\", \"ld\", \"fin\", \"he\"})\n}\n\nfunc TestOver4096ByteLine(t *testing.T) {\n\ttailTest := NewTailTest(\"Over4096ByteLine\", t)\n\ttestString := strings.Repeat(\"a\", 4097)\n\ttailTest.CreateFile(\"test.txt\", \"test\\n\"+testString+\"\\nhello\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: true, Location: nil})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"test\", testString, \"hello\", \"world\"}, false)\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\ttailTest.Cleanup(tail, true)\n}\nfunc TestOver4096ByteLineWithSetMaxLineSize(t *testing.T) {\n\ttailTest := NewTailTest(\"Over4096ByteLineMaxLineSize\", t)\n\ttestString := strings.Repeat(\"a\", 4097)\n\ttailTest.CreateFile(\"test.txt\", \"test\\n\"+testString+\"\\nhello\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: true, Location: nil, MaxLineSize: 4097})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"test\", testString, \"hello\", \"world\"}, false)\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestLocationFull(t *testing.T) {\n\ttailTest := NewTailTest(\"location-full\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: true, Location: nil})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"hello\", \"world\"}, false)\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestLocationFullDontFollow(t *testing.T) {\n\ttailTest := NewTailTest(\"location-full-dontfollow\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: false, Location: nil})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"hello\", \"world\"}, false)\n\n\t// Add more data only after reasonable delay.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.AppendFile(\"test.txt\", \"more\\ndata\\n\")\n\t<-time.After(100 * time.Millisecond)\n\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestLocationEnd(t *testing.T) {\n\ttailTest := NewTailTest(\"location-end\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: true, Location: &SeekInfo{0, os.SEEK_END}})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"more\", \"data\"}, false)\n\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.AppendFile(\"test.txt\", \"more\\ndata\\n\")\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestLocationMiddle(t *testing.T) {\n\t// Test reading from middle.\n\ttailTest := NewTailTest(\"location-middle\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: true, Location: &SeekInfo{-6, os.SEEK_END}})\n\tgo tailTest.VerifyTailOutput(tail, []string{\"world\", \"more\", \"data\"}, false)\n\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.AppendFile(\"test.txt\", \"more\\ndata\\n\")\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\ttailTest.Cleanup(tail, true)\n}\n\n// The use of polling file watcher could affect file rotation\n// (detected via renames), so test these explicitly.\n\nfunc TestReOpenInotify(t *testing.T) {\n\treOpen(t, false)\n}\n\nfunc TestReOpenPolling(t *testing.T) {\n\treOpen(t, true)\n}\n\n// The use of polling file watcher could affect file rotation\n// (detected via renames), so test these explicitly.\n\nfunc TestReSeekInotify(t *testing.T) {\n\treSeek(t, false)\n}\n\nfunc TestReSeekPolling(t *testing.T) {\n\treSeek(t, true)\n}\n\nfunc TestRateLimiting(t *testing.T) {\n\ttailTest := NewTailTest(\"rate-limiting\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\nagain\\nextra\\n\")\n\tconfig := Config{\n\t\tFollow:      true,\n\t\tRateLimiter: ratelimiter.NewLeakyBucket(2, time.Second)}\n\tleakybucketFull := \"Too much log activity; waiting a second before resuming tailing\"\n\ttail := tailTest.StartTail(\"test.txt\", config)\n\n\t// TODO: also verify that tail resumes after the cooloff period.\n\tgo tailTest.VerifyTailOutput(tail, []string{\n\t\t\"hello\", \"world\", \"again\",\n\t\tleakybucketFull,\n\t\t\"more\", \"data\",\n\t\tleakybucketFull}, false)\n\n\t// Add more data only after reasonable delay.\n\t<-time.After(1200 * time.Millisecond)\n\ttailTest.AppendFile(\"test.txt\", \"more\\ndata\\n\")\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc TestTell(t *testing.T) {\n\ttailTest := NewTailTest(\"tell-position\", t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\nagain\\nmore\\n\")\n\tconfig := Config{\n\t\tFollow:   false,\n\t\tLocation: &SeekInfo{0, os.SEEK_SET}}\n\ttail := tailTest.StartTail(\"test.txt\", config)\n\t// read noe line\n\t<-tail.Lines\n\toffset, err := tail.Tell()\n\tif err != nil {\n\t\ttailTest.Errorf(\"Tell return error: %s\", err.Error())\n\t}\n\ttail.Done()\n\t// tail.close()\n\n\tconfig = Config{\n\t\tFollow:   false,\n\t\tLocation: &SeekInfo{offset, os.SEEK_SET}}\n\ttail = tailTest.StartTail(\"test.txt\", config)\n\tfor l := range tail.Lines {\n\t\t// it may readed one line in the chan(tail.Lines),\n\t\t// so it may lost one line.\n\t\tif l.Text != \"world\" && l.Text != \"again\" {\n\t\t\ttailTest.Fatalf(\"mismatch; expected world or again, but got %s\",\n\t\t\t\tl.Text)\n\t\t}\n\t\tbreak\n\t}\n\ttailTest.RemoveFile(\"test.txt\")\n\ttail.Done()\n\ttail.Cleanup()\n}\n\nfunc TestBlockUntilExists(t *testing.T) {\n\ttailTest := NewTailTest(\"block-until-file-exists\", t)\n\tconfig := Config{\n\t\tFollow: true,\n\t}\n\ttail := tailTest.StartTail(\"test.txt\", config)\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttailTest.CreateFile(\"test.txt\", \"hello world\\n\")\n\t}()\n\tfor l := range tail.Lines {\n\t\tif l.Text != \"hello world\" {\n\t\t\ttailTest.Fatalf(\"mismatch; expected hello world, but got %s\",\n\t\t\t\tl.Text)\n\t\t}\n\t\tbreak\n\t}\n\ttailTest.RemoveFile(\"test.txt\")\n\ttail.Stop()\n\ttail.Cleanup()\n}\n\nfunc maxLineSize(t *testing.T, follow bool, fileContent string, expected []string) {\n\ttailTest := NewTailTest(\"maxlinesize\", t)\n\ttailTest.CreateFile(\"test.txt\", fileContent)\n\ttail := tailTest.StartTail(\"test.txt\", Config{Follow: follow, Location: nil, MaxLineSize: 3})\n\tgo tailTest.VerifyTailOutput(tail, expected, false)\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\ttailTest.Cleanup(tail, true)\n}\n\nfunc reOpen(t *testing.T, poll bool) {\n\tvar name string\n\tvar delay time.Duration\n\tif poll {\n\t\tname = \"reopen-polling\"\n\t\tdelay = 300 * time.Millisecond // account for POLL_DURATION\n\t} else {\n\t\tname = \"reopen-inotify\"\n\t\tdelay = 100 * time.Millisecond\n\t}\n\ttailTest := NewTailTest(name, t)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttail := tailTest.StartTail(\n\t\t\"test.txt\",\n\t\tConfig{Follow: true, ReOpen: true, Poll: poll})\n\tcontent := []string{\"hello\", \"world\", \"more\", \"data\", \"endofworld\"}\n\tgo tailTest.VerifyTailOutput(tail, content, false)\n\n\tif poll {\n\t\t// deletion must trigger reopen\n\t\t<-time.After(delay)\n\t\ttailTest.RemoveFile(\"test.txt\")\n\t\t<-time.After(delay)\n\t\ttailTest.CreateFile(\"test.txt\", \"more\\ndata\\n\")\n\t} else {\n\t\t// In inotify mode, fsnotify is currently unable to deliver notifications\n\t\t// about deletion of open files, so we are not testing file deletion.\n\t\t// (see https://github.com/fsnotify/fsnotify/issues/194 for details).\n\t\t<-time.After(delay)\n\t\ttailTest.AppendToFile(\"test.txt\", \"more\\ndata\\n\")\n\t}\n\n\t// rename must trigger reopen\n\t<-time.After(delay)\n\ttailTest.RenameFile(\"test.txt\", \"test.txt.rotated\")\n\t<-time.After(delay)\n\ttailTest.CreateFile(\"test.txt\", \"endofworld\\n\")\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(delay)\n\ttailTest.RemoveFile(\"test.txt\")\n\t<-time.After(delay)\n\n\t// Do not bother with stopping as it could kill the tomb during\n\t// the reading of data written above. Timings can vary based on\n\t// test environment.\n\ttailTest.Cleanup(tail, false)\n}\n\nfunc TestInotify_WaitForCreateThenMove(t *testing.T) {\n\ttailTest := NewTailTest(\"wait-for-create-then-reopen\", t)\n\tos.Remove(tailTest.path + \"/test.txt\") // Make sure the file does NOT exist.\n\n\ttail := tailTest.StartTail(\n\t\t\"test.txt\",\n\t\tConfig{Follow: true, ReOpen: true, Poll: false})\n\n\tcontent := []string{\"hello\", \"world\", \"endofworld\"}\n\tgo tailTest.VerifyTailOutput(tail, content, false)\n\n\ttime.Sleep(50 * time.Millisecond)\n\ttailTest.CreateFile(\"test.txt\", \"hello\\nworld\\n\")\n\ttime.Sleep(50 * time.Millisecond)\n\ttailTest.RenameFile(\"test.txt\", \"test.txt.rotated\")\n\ttime.Sleep(50 * time.Millisecond)\n\ttailTest.CreateFile(\"test.txt\", \"endofworld\\n\")\n\ttime.Sleep(50 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt.rotated\")\n\ttailTest.RemoveFile(\"test.txt\")\n\n\t// Do not bother with stopping as it could kill the tomb during\n\t// the reading of data written above. Timings can vary based on\n\t// test environment.\n\ttailTest.Cleanup(tail, false)\n}\n\nfunc reSeek(t *testing.T, poll bool) {\n\tvar name string\n\tif poll {\n\t\tname = \"reseek-polling\"\n\t} else {\n\t\tname = \"reseek-inotify\"\n\t}\n\ttailTest := NewTailTest(name, t)\n\ttailTest.CreateFile(\"test.txt\", \"a really long string goes here\\nhello\\nworld\\n\")\n\ttail := tailTest.StartTail(\n\t\t\"test.txt\",\n\t\tConfig{Follow: true, ReOpen: false, Poll: poll})\n\n\tgo tailTest.VerifyTailOutput(tail, []string{\n\t\t\"a really long string goes here\", \"hello\", \"world\", \"h311o\", \"w0r1d\", \"endofworld\"}, false)\n\n\t// truncate now\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.TruncateFile(\"test.txt\", \"h311o\\nw0r1d\\nendofworld\\n\")\n\n\t// Delete after a reasonable delay, to give tail sufficient time\n\t// to read all lines.\n\t<-time.After(100 * time.Millisecond)\n\ttailTest.RemoveFile(\"test.txt\")\n\n\t// Do not bother with stopping as it could kill the tomb during\n\t// the reading of data written above. Timings can vary based on\n\t// test environment.\n\ttailTest.Cleanup(tail, false)\n}\n\n// Test library\n\ntype TailTest struct {\n\tName string\n\tpath string\n\tdone chan struct{}\n\t*testing.T\n}\n\nfunc NewTailTest(name string, t *testing.T) TailTest {\n\ttt := TailTest{name, \".test/\" + name, make(chan struct{}), t}\n\terr := os.MkdirAll(tt.path, os.ModeTemporary|0700)\n\tif err != nil {\n\t\ttt.Fatal(err)\n\t}\n\n\treturn tt\n}\n\nfunc (t TailTest) CreateFile(name string, contents string) {\n\terr := ioutil.WriteFile(t.path+\"/\"+name, []byte(contents), 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (t TailTest) AppendToFile(name string, contents string) {\n\terr := ioutil.WriteFile(t.path+\"/\"+name, []byte(contents), 0600|os.ModeAppend)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (t TailTest) RemoveFile(name string) {\n\terr := os.Remove(t.path + \"/\" + name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (t TailTest) RenameFile(oldname string, newname string) {\n\toldname = t.path + \"/\" + oldname\n\tnewname = t.path + \"/\" + newname\n\terr := os.Rename(oldname, newname)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (t TailTest) AppendFile(name string, contents string) {\n\tf, err := os.OpenFile(t.path+\"/\"+name, os.O_APPEND|os.O_WRONLY, 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\t_, err = f.WriteString(contents)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (t TailTest) TruncateFile(name string, contents string) {\n\tf, err := os.OpenFile(t.path+\"/\"+name, os.O_TRUNC|os.O_WRONLY, 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\t_, err = f.WriteString(contents)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (t TailTest) StartTail(name string, config Config) *Tail {\n\ttail, err := TailFile(t.path+\"/\"+name, config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn tail\n}\n\nfunc (t TailTest) VerifyTailOutput(tail *Tail, lines []string, expectEOF bool) {\n\tdefer close(t.done)\n\tt.ReadLines(tail, lines)\n\t// It is important to do this if only EOF is expected\n\t// otherwise we could block on <-tail.Lines\n\tif expectEOF {\n\t\tline, ok := <-tail.Lines\n\t\tif ok {\n\t\t\tt.Fatalf(\"more content from tail: %+v\", line)\n\t\t}\n\t}\n}\n\nfunc (t TailTest) ReadLines(tail *Tail, lines []string) {\n\tfor idx, line := range lines {\n\t\ttailedLine, ok := <-tail.Lines\n\t\tif !ok {\n\t\t\t// tail.Lines is closed and empty.\n\t\t\terr := tail.Err()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"tail ended with error: %v\", err)\n\t\t\t}\n\t\t\tt.Fatalf(\"tail ended early; expecting more: %v\", lines[idx:])\n\t\t}\n\t\tif tailedLine == nil {\n\t\t\tt.Fatalf(\"tail.Lines returned nil; not possible\")\n\t\t}\n\t\t// Note: not checking .Err as the `lines` argument is designed\n\t\t// to match error strings as well.\n\t\tif tailedLine.Text != line {\n\t\t\tt.Fatalf(\n\t\t\t\t\"unexpected line/err from tail: \"+\n\t\t\t\t\t\"expecting <<%s>>>, but got <<<%s>>>\",\n\t\t\t\tline, tailedLine.Text)\n\t\t}\n\t}\n}\n\nfunc (t TailTest) Cleanup(tail *Tail, stop bool) {\n\t<-t.done\n\tif stop {\n\t\ttail.Stop()\n\t}\n\ttail.Cleanup()\n}\n"
        },
        {
          "name": "tail_windows.go",
          "type": "blob",
          "size": 0.1865234375,
          "content": "// +build windows\n\npackage tail\n\nimport (\n\t\"github.com/hpcloud/tail/winfile\"\n\t\"os\"\n)\n\nfunc OpenFile(name string) (file *os.File, err error) {\n\treturn winfile.OpenFile(name, os.O_RDONLY, 0)\n}\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "watch",
          "type": "tree",
          "content": null
        },
        {
          "name": "winfile",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}