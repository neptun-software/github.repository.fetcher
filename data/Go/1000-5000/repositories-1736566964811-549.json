{
  "metadata": {
    "timestamp": 1736566964811,
    "page": 549,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "divan/txqr",
      "stars": 2991,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0244140625,
          "content": "txqr.framework\n.DS_Store\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2019 Ivan Danyliuk\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.08203125,
          "content": "gomobile:\n\tgomobile bind -target=ios -o txqr.framework github.com/divan/txqr/mobile\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.8095703125,
          "content": "# TXQR\n\n[![GoDoc](https://godoc.org/github.com/divan/txqr?status.svg)](https://godoc.org/github.com/divan/txqr)\n\nTXQR (Transfer via QR) is a protocol and set of tools and libs to transfer data via animated QR codes. It uses [fountain codes](https://en.wikipedia.org/wiki/Fountain_code) for error correction.\n\nSee related blog posts for more details:\n - [Animated QR data transfer with Gomobile and Gopherjs](https://divan.github.io/posts/animatedqr/)\n - [Fountain codes and animated QR](https://divan.github.io/posts/fountaincodes/)\n\n# Demo\n\n![Demo](./docs/demo.gif)\n\nReader iOS app in the demo (uses this lib via Gomobile): [https://github.com/divan/txqr-reader](https://github.com/divan/txqr-reader)\n\n## Automated tester app\nAlso see `cmd/txqr-tester` app for automated testing of different encoder parameters.\n\n# Licence\n\nMIT\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "decode.go",
          "type": "blob",
          "size": 3.4365234375,
          "content": "package txqr\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\n\tfountain \"github.com/google/gofountain\"\n)\n\n// Decoder represents protocol decode.\ntype Decoder struct {\n\tchunkLen  int\n\tcodec     fountain.Codec\n\tfd        fountain.Decoder\n\tcompleted bool\n\ttotal     int\n\tcache     map[string]struct{}\n}\n\n// NewDecoder creates and inits a new decoder.\nfunc NewDecoder() *Decoder {\n\treturn &Decoder{\n\t\tcache: make(map[string]struct{}),\n\t}\n}\n\n// NewDecoderSize creates and inits a new decoder for the known size.\nfunc NewDecoderSize(size, chunkLen int) *Decoder {\n\tnumChunks := numberOfChunks(size, chunkLen)\n\tcodec := fountain.NewLubyCodec(numChunks, rand.New(fountain.NewMersenneTwister(200)), solitonDistribution(numChunks))\n\treturn &Decoder{\n\t\tcodec:    codec,\n\t\tfd:       codec.NewDecoder(size),\n\t\ttotal:    size,\n\t\tchunkLen: chunkLen,\n\t\tcache:    make(map[string]struct{}),\n\t}\n}\n\n// Decode takes a single chunk of data and decodes it.\n// Chunk expected to be validated (see Validate) before.\nfunc (d *Decoder) Decode(chunk string) error {\n\tidx := strings.IndexByte(chunk, '|') // expected to be validated before\n\tif idx == -1 {\n\t\treturn fmt.Errorf(\"invalid frame: \\\"%s\\\"\", chunk)\n\t}\n\n\theader := chunk[:idx]\n\t// continuous QR reading often sends the same chunk in a row, skip it\n\tif d.isCached(header) {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\tblockCode       int64\n\t\tchunkLen, total int\n\t)\n\t_, err := fmt.Sscanf(header, \"%d/%d/%d\", &blockCode, &chunkLen, &total)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid header: %v (%s)\", err, header)\n\t}\n\n\tpayload := chunk[idx+1:]\n\tlubyBlock := fountain.LTBlock{\n\t\tBlockCode: blockCode,\n\t\tData:      []byte(payload),\n\t}\n\n\tif d.fd == nil {\n\t\td.total = total\n\t\td.chunkLen = chunkLen\n\t\tnumChunks := numberOfChunks(d.total, d.chunkLen)\n\t\td.codec = fountain.NewLubyCodec(numChunks, rand.New(fountain.NewMersenneTwister(200)), solitonDistribution(numChunks))\n\t\td.fd = d.codec.NewDecoder(total)\n\t}\n\td.completed = d.fd.AddBlocks([]fountain.LTBlock{lubyBlock})\n\n\treturn nil\n}\n\n// Validate checks if a given chunk of data is a valid txqr protocol packet.\nfunc (d *Decoder) Validate(chunk string) error {\n\tif chunk == \"\" || len(chunk) < 4 {\n\t\treturn fmt.Errorf(\"invalid frame: \\\"%s\\\"\", chunk)\n\t}\n\n\tidx := strings.IndexByte(chunk, '|')\n\tif idx == -1 {\n\t\treturn fmt.Errorf(\"invalid frame: \\\"%s\\\"\", chunk)\n\t}\n\n\treturn nil\n}\n\n// Data returns decoded data.\nfunc (d *Decoder) Data() string {\n\treturn string(d.DataBytes())\n}\n\n// DataBytes returns decoded data as a byte slice.\nfunc (d *Decoder) DataBytes() []byte {\n\tif d.fd == nil {\n\t\treturn []byte{}\n\t}\n\n\tif !d.completed {\n\t\treturn []byte{}\n\t}\n\treturn d.fd.Decode()\n}\n\n// Length returns length of the decoded data.\n// TODO: remove\nfunc (d *Decoder) Length() int {\n\treturn 0\n}\n\n// Read returns amount of currently read bytes.\n// TODO: remove\nfunc (d *Decoder) Read() int {\n\treturn 0\n}\n\n// Total returns total amount of data.\nfunc (d *Decoder) Total() int {\n\treturn d.total\n}\n\n// IsCompleted reports whether the read was completed successfully or not.\nfunc (d *Decoder) IsCompleted() bool {\n\treturn d.completed\n}\n\n// Reset resets decoder, preparing it for the next run.\nfunc (d *Decoder) Reset() {\n\td.fd = nil\n\td.completed = false\n\td.chunkLen = 0\n\td.total = 0\n\td.cache = map[string]struct{}{}\n\td.codec = nil\n}\n\n// isCached takes the header of chunk data and see if it's been cached.\n// If not, it caches it.\nfunc (d *Decoder) isCached(header string) bool {\n\tif _, ok := d.cache[header]; ok {\n\t\treturn true\n\t}\n\n\t// cache it\n\td.cache[header] = struct{}{}\n\treturn false\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.3076171875,
          "content": "/*Package txqr implements the transmission protocol over QR codes.\n\nIntro\n\nThe protocol allows to send a relatively small (fits into the memory fast)\ndata of a known size. Stream data is not supported by design.\n\nQR codes are supposed to be sent and received by means of optical displays\nand sensors with unknown properties. Sender might be a 85 inch OLED TV with\n240Hz rate, while receiver could be an old Android phone with 2MP camera and\nbound by CPU allowing only 5FPS. Or vice versa. Protocol must adapt to all\ncases.\n\nThe basic idea is to split the data into chunks, suitable for encoding as a\nsingle QR frame, add frame header/footer information and run it in the loop.\n\n- splitting into frame is crucial to adapt to desired QR code size/error recovery level\n\n- header and footer contain enough information to uniquely identify frame and be able to restore the whole data even if all frames received out of order.\n\n- loop is needed to make sure slow receiver has enough opportunity to restore from missed frames\n\nAll data should be within alphanumeric space.\nNo error correction is implemented, as QR code layer already has one.\n\nHeader\n\n    offset/total|<data>\n\n\tboth offset and total are represents byte position\n\tand printed in HEX\n\nFor, example:\n\n First chunk:\n\n    0/11|hello\n\n Second chunk:\n\n    5/11|world!\n\n\n*/\npackage txqr\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "encode.go",
          "type": "blob",
          "size": 1.6220703125,
          "content": "package txqr\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\n\tfountain \"github.com/google/gofountain\"\n)\n\n// Encoder represents protocol encoder.\ntype Encoder struct {\n\tchunkLen         int\n\tredundancyFactor float64\n}\n\n// NewEncoder creates and inits a new encoder for the given chunk length.\nfunc NewEncoder(n int) *Encoder {\n\treturn &Encoder{\n\t\tchunkLen:         n,\n\t\tredundancyFactor: 2.0,\n\t}\n}\n\n// Encode encodes data from reader and splits it into chunks to be\n// futher converted to QR code frames.\nfunc (e *Encoder) Encode(str string) ([]string, error) {\n\tif len(str) < e.chunkLen {\n\t\treturn []string{e.frame(0, len(str), []byte(str))}, nil\n\t}\n\n\tnumChunks := numberOfChunks(len(str), e.chunkLen)\n\tcodec := fountain.NewLubyCodec(numChunks, rand.New(fountain.NewMersenneTwister(200)), solitonDistribution(numChunks))\n\n\tvar msg = []byte(str) // copy of str, as EncodeLTBlock is destructive to msg\n\tidsToEncode := ids(int(float64(numChunks) * e.redundancyFactor))\n\tlubyBlocks := fountain.EncodeLTBlocks(msg, idsToEncode, codec)\n\n\t// TODO(divan): use sync.Pool as this probably will be used many times\n\tret := make([]string, len(lubyBlocks))\n\tfor i, block := range lubyBlocks {\n\t\tret[i] = e.frame(block.BlockCode, len(str), block.Data)\n\t}\n\treturn ret, nil\n}\n\n// SetRedundancyFactor changes the value of redundancy factor.\nfunc (e *Encoder) SetRedundancyFactor(rf float64) {\n\te.redundancyFactor = rf\n}\n\nfunc (e *Encoder) frame(blockCode int64, total int, data []byte) string {\n\treturn fmt.Sprintf(\"%d/%d/%d|%s\", blockCode, e.chunkLen, total, string(data))\n}\n\nfunc numberOfChunks(length, chunkLen int) int {\n\tn := length / chunkLen\n\tif length%chunkLen > 0 {\n\t\tn++\n\t}\n\treturn n\n}\n"
        },
        {
          "name": "fountain.go",
          "type": "blob",
          "size": 0.9814453125,
          "content": "package txqr\n\n// Note that these CDFs (cumulative distribution function) will be used for\n// selecting source blocks for code block generation. A typical algorithm\n// is to choose a number from a distribution, then pick uniformly that many\n// source blocks to XOR into a code block. To use CDF mapping values, pick a\n// random number r (0 <= r < 1) and then find the smallest i such that\n// CDF[i] >= r.\n\n// solitonDistribution returns a CDF mapping for the soliton distribution.\n// N (the number of elements in the CDF) cannot be less than 1\n// The CDF is one-based: the probability of picking 1 from the distribution\n// is CDF[1].\nfunc solitonDistribution(n int) []float64 {\n\tcdf := make([]float64, n+1)\n\tcdf[1] = 1 / float64(n)\n\tfor i := 2; i < len(cdf); i++ {\n\t\tcdf[i] = cdf[i-1] + (1 / (float64(i) * float64(i-1)))\n\t}\n\treturn cdf\n}\n\n// ids create slice with IDs for 0..n values.\nfunc ids(n int) []int64 {\n\tids := make([]int64, n)\n\tfor i := int64(0); i < int64(n); i++ {\n\t\tids[i] = i\n\t}\n\treturn ids\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6259765625,
          "content": "module github.com/divan/txqr\n\nrequire (\n\tgithub.com/elazarl/go-bindata-assetfs v1.0.0\n\tgithub.com/google/gofountain v0.0.0-20160820054803-4928733085e9\n\tgithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e\n\tgithub.com/gopherjs/vecty v0.0.0-20180525005238-a3bd138280bf\n\tgithub.com/gopherjs/websocket v0.0.0-20170522004412-87ee47603f13\n\tgithub.com/gorilla/websocket v1.4.0\n\tgithub.com/makiuchi-d/gozxing v0.0.0-20181111004219-a01698524e72\n\tgithub.com/mdp/qrterminal v1.0.1\n\tgithub.com/pyk/byten v0.0.0-20140925233358-f847a130bf6d\n\tgithub.com/skip2/go-qrcode v0.0.0-20171229120447-cf5f9fa2f0d8\n\tgolang.org/x/text v0.3.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.365234375,
          "content": "github.com/elazarl/go-bindata-assetfs v1.0.0 h1:G/bYguwHIzWq9ZoyUQqrjTmJbbYn3j3CKKpKinvZLFk=\ngithub.com/elazarl/go-bindata-assetfs v1.0.0/go.mod h1:v+YaWX3bdea5J/mo8dSETolEo7R71Vk1u8bnjau5yw4=\ngithub.com/google/gofountain v0.0.0-20160820054803-4928733085e9 h1:Ngb7dbv9x/c5wWGpGxicH4iN8g90++AcRjwjHSllofA=\ngithub.com/google/gofountain v0.0.0-20160820054803-4928733085e9/go.mod h1:5K3gm9YuA6H5iBSG5JugS+7xTT0fK+E5zf8On8bgz1w=\ngithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e h1:JKmoR8x90Iww1ks85zJ1lfDGgIiMDuIptTOhJq+zKyg=\ngithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gopherjs/vecty v0.0.0-20180525005238-a3bd138280bf h1:J7WjKCdpxMhXDzFPP6d41YonnCnPi1JkYOFxIPoH1E0=\ngithub.com/gopherjs/vecty v0.0.0-20180525005238-a3bd138280bf/go.mod h1:5YRDuy7i7SgM0kL+0b5oq+jfDTqPyzV3TQbcDkBvcoE=\ngithub.com/gopherjs/websocket v0.0.0-20170522004412-87ee47603f13 h1:3TcZe31zyrteCrSU2+4QSSx9N6sQC6PjXwrHjfX3USM=\ngithub.com/gopherjs/websocket v0.0.0-20170522004412-87ee47603f13/go.mod h1:jd+zY81Fx2lC4bfw58+Rflg1srqmedQjbBUejKOjYNY=\ngithub.com/gorilla/websocket v1.4.0 h1:WDFjx/TMzVgy9VdMMQi2K2Emtwi2QcUQsztZ/zLaH/Q=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/makiuchi-d/gozxing v0.0.0-20181111004219-a01698524e72 h1:hnSfRf2GSdQC/aOxI1ZNmqapRcgQfeld4ItWYGp+xLI=\ngithub.com/makiuchi-d/gozxing v0.0.0-20181111004219-a01698524e72/go.mod h1:WoI7z45M7ZNA5BJxiJHaB+x7+k8S/3phW5Y13IR4yWY=\ngithub.com/mdp/qrterminal v1.0.1 h1:07+fzVDlPuBlXS8tB0ktTAyf+Lp1j2+2zK3fBOL5b7c=\ngithub.com/mdp/qrterminal v1.0.1/go.mod h1:Z33WhxQe9B6CdW37HaVqcRKzP+kByF3q/qLxOGe12xQ=\ngithub.com/pyk/byten v0.0.0-20140925233358-f847a130bf6d h1:/0nqYrqVyPTVDT2jPx9z9BZ+ItJWlWA9VITUGvNaZkI=\ngithub.com/pyk/byten v0.0.0-20140925233358-f847a130bf6d/go.mod h1:El8LdwAxb76Ih0mRmpu9uMVq+ajiqGSxmYiUe+nSr+w=\ngithub.com/skip2/go-qrcode v0.0.0-20171229120447-cf5f9fa2f0d8 h1:5C4yAeYifeRO+7z2/H2kxL8tJZE9ZE9LpxK6YUZPByo=\ngithub.com/skip2/go-qrcode v0.0.0-20171229120447-cf5f9fa2f0d8/go.mod h1:PLPIyL7ikehBD1OAjmKKiOEhbvWyHGaNDjquXMcYABo=\ngolang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\nrsc.io/qr v0.2.0 h1:6vBLea5/NRMVTz8V66gipeLycZMl/+UlFmk8DvqQ6WY=\nrsc.io/qr v0.2.0/go.mod h1:IF+uZjkb9fqyeF/4tlBoynqmQxUoPfWEKh921coOuXs=\n"
        },
        {
          "name": "mobile",
          "type": "tree",
          "content": null
        },
        {
          "name": "qr",
          "type": "tree",
          "content": null
        },
        {
          "name": "txqr_test.go",
          "type": "blob",
          "size": 5.3701171875,
          "content": "package txqr\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestTXQR(t *testing.T) {\n\tvar tests = []struct {\n\t\tlength  int\n\t\tchunkSz int\n\t}{\n\t\t{10 * 1024, 100},\n\t\t{10 * 1024, 200},\n\t\t{10 * 1024, 300},\n\t\t{10 * 1024, 400},\n\t\t{10 * 1024, 500},\n\t\t{10 * 1024, 650},\n\t\t{10 * 1024, 800},\n\t\t{10 * 1024, 900},\n\t\t{10 * 1024, 1000},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d, %d\", test.length, test.chunkSz), func(t *testing.T) {\n\t\t\tstr := newTestData(test.length)\n\t\t\tenc := NewEncoder(test.chunkSz)\n\t\t\tchunks, err := enc.Encode(str)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Encode failed: %v\", err)\n\t\t\t}\n\n\t\t\tdec := NewDecoder()\n\t\t\tfor !dec.IsCompleted() {\n\t\t\t\tfor _, chunk := range chunks {\n\t\t\t\t\terr = dec.Decode(chunk)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"Decode failed: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot := dec.Data()\n\t\t\tif got != str {\n\t\t\t\tt.Fatalf(\"Expected '%s', but got '%s'\", str, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestTXQRErasures tests information decoding over erasure channels\n// with different erasure probabilities.\nfunc TestTXQRErasures(t *testing.T) {\n\tvar tests = []struct {\n\t\tlength  int\n\t\tchunkSz int\n\t\tfps     int\n\t}{\n\t\t{10 * 1024, 100, 3},\n\t\t{10 * 1024, 300, 3},\n\t\t{10 * 1024, 500, 3},\n\t\t{10 * 1024, 650, 3},\n\t\t{10 * 1024, 800, 3},\n\t\t{10 * 1024, 800, 3},\n\t\t{10 * 1024, 100, 6},\n\t\t{10 * 1024, 300, 6},\n\t\t{10 * 1024, 500, 6},\n\t\t{10 * 1024, 800, 6},\n\t\t{10 * 1024, 800, 6},\n\t\t{10 * 1024, 100, 9},\n\t\t{10 * 1024, 300, 9},\n\t\t{10 * 1024, 500, 9},\n\t\t{10 * 1024, 800, 9},\n\t\t{10 * 1024, 800, 9},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d, %d\", test.length, test.chunkSz), func(t *testing.T) {\n\t\t\tstr := newTestData(test.length)\n\t\t\tenc := NewEncoder(test.chunkSz)\n\t\t\tchunks, err := enc.Encode(str)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Encode failed: %v\", err)\n\t\t\t}\n\n\t\t\tdec := NewDecoder()\n\t\t\tnow := time.Now()\n\t\t\tfor !dec.IsCompleted() {\n\t\t\t\t// erase new set of chunks every time\n\t\t\t\ttoDel := chunksCountToDelete(len(chunks))\n\t\t\t\ttransmitted := eraseChunks(chunks, toDel)\n\t\t\t\tfor _, chunk := range transmitted {\n\t\t\t\t\terr = dec.Decode(chunk)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"Decode failed: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tif dec.IsCompleted() {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttime.Sleep(1 * time.Second / time.Duration(test.fps))\n\t\t\t}\n\t\t\tduration := time.Since(now)\n\t\t\tt.Logf(\"[%db/%d, %dfps] took: %v\", test.length, test.chunkSz, test.fps, duration)\n\t\t\tgot := dec.Data()\n\t\t\tif got != str {\n\t\t\t\tt.Fatalf(\"Expected '%s', but got '%s'\", str, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// eraseChunks randomly erases n chunks from the input slice.\nfunc eraseChunks(chunks []string, n int) []string {\n\ttoErase := make(map[int]bool)\n\tfor i := 0; i < n; i++ {\n\t\tidx := rand.Intn(len(chunks))\n\t\ttoErase[idx] = true\n\t}\n\n\tret := make([]string, 0, len(chunks)-n)\n\tfor idx, chunk := range chunks {\n\t\tif toErase[idx] {\n\t\t\tcontinue\n\t\t}\n\t\tret = append(ret, chunk)\n\t}\n\treturn ret\n}\n\n// chunksCountToDelete returns random number of chunks for deletion,\n// using normal distribution with 2 std deviation and N/3 as a mean.\nfunc chunksCountToDelete(n int) int {\n\tmean := float64(n / 2)\n\tdev := 2.0\n\tdel := int(rand.NormFloat64()*dev + mean)\n\tif del < 0 {\n\t\tdel = 0\n\t}\n\tif del > n {\n\t\tdel = n\n\t}\n\treturn del\n}\n\nfunc BenchmarkTXQREncode(b *testing.B) {\n\tvar tests = []struct {\n\t\tlength  int\n\t\tchunkSz int\n\t}{\n\t\t{100, 10},\n\t\t{1000, 10},\n\t\t{1000, 100},\n\t\t{10 * 1024, 100},\n\t\t{10 * 1024, 1000},\n\t}\n\n\tfor _, test := range tests {\n\t\tb.Run(fmt.Sprintf(\"%d, %d\", test.length, test.chunkSz), func(b *testing.B) {\n\t\t\tstr := strings.Repeat(\"hello, world!\", test.length)\n\t\t\tenc := NewEncoder(test.chunkSz)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, _ = enc.Encode(str)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkTXQRDecode(b *testing.B) {\n\tvar tests = []struct {\n\t\tlength  int\n\t\tchunkSz int\n\t}{\n\t\t{100, 10},\n\t\t{1000, 10},\n\t\t{1000, 100},\n\t\t{10 * 1024, 100},\n\t\t{10 * 1024, 1000},\n\t}\n\n\tfor _, test := range tests {\n\t\tb.Run(fmt.Sprintf(\"%d, %d\", test.length, test.chunkSz), func(b *testing.B) {\n\t\t\tstr := strings.Repeat(\"hello, world!\", test.length)\n\t\t\tenc := NewEncoder(test.chunkSz)\n\t\t\tchunks, err := enc.Encode(str)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatalf(\"Encode failed: %v\", err)\n\t\t\t}\n\t\t\tdec := NewDecoder()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tfor _, chunk := range chunks {\n\t\t\t\t\terr = dec.Decode(chunk)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tb.Fatalf(\"Decode failed: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// BenchmarkTXQRErasures benchmarks information decoding over erasure channels\n// with different erasure probabilities.\nfunc BenchmarkTXQRErasures(b *testing.B) {\n\tvar tests = []struct {\n\t\tlength  int\n\t\tchunkSz int\n\t}{\n\t\t{10 * 1024, 10},\n\t\t{10 * 1024, 100},\n\t\t{10 * 1024, 1000},\n\t}\n\n\tfor _, test := range tests {\n\t\tb.Run(fmt.Sprintf(\"%d, %d\", test.length, test.chunkSz), func(b *testing.B) {\n\t\t\tstr := strings.Repeat(\"hello, world!\", test.length)\n\t\t\tenc := NewEncoder(test.chunkSz)\n\t\t\tchunks, err := enc.Encode(str)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatalf(\"Encode failed: %v\", err)\n\t\t\t}\n\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tdec := NewDecoder()\n\t\t\t\tfor !dec.IsCompleted() {\n\t\t\t\t\t// erase new set of chunks every time\n\t\t\t\t\ttoDel := chunksCountToDelete(len(chunks))\n\t\t\t\t\ttransmitted := eraseChunks(chunks, toDel)\n\t\t\t\t\tfor _, chunk := range transmitted {\n\t\t\t\t\t\terr = dec.Decode(chunk)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tb.Fatalf(\"Decode failed: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc newTestData(size int) string {\n\tdata := make([]byte, size)\n\t_, err := rand.Read(data)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Can't generate rand data: %v\", err))\n\t}\n\treturn string(data)\n}\n"
        }
      ]
    }
  ]
}