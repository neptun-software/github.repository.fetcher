{
  "metadata": {
    "timestamp": 1736566918243,
    "page": 491,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "esrrhs/pingtunnel",
      "stars": 3129,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1875,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2470703125,
          "content": "FROM golang AS build-env\n\nWORKDIR /app\n\nCOPY go.* ./\nRUN go mod download\nCOPY . ./\nRUN go mod tidy\nRUN cd cmd && go build -v -o pingtunnel && mv pingtunnel ../\n\nFROM debian\nCOPY --from=build-env /app/pingtunnel .\nCOPY GeoLite2-Country.mmdb .\nWORKDIR ./\n"
        },
        {
          "name": "GeoLite2-Country.mmdb",
          "type": "blob",
          "size": 3876.548828125,
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2018 zhao xin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.0771484375,
          "content": "# Pingtunnel\n\n[<img src=\"https://img.shields.io/github/license/esrrhs/pingtunnel\">](https://github.com/esrrhs/pingtunnel)\n[<img src=\"https://img.shields.io/github/languages/top/esrrhs/pingtunnel\">](https://github.com/esrrhs/pingtunnel)\n[![Go Report Card](https://goreportcard.com/badge/github.com/esrrhs/pingtunnel)](https://goreportcard.com/report/github.com/esrrhs/pingtunnel)\n[<img src=\"https://img.shields.io/github/v/release/esrrhs/pingtunnel\">](https://github.com/esrrhs/pingtunnel/releases)\n[<img src=\"https://img.shields.io/github/downloads/esrrhs/pingtunnel/total\">](https://github.com/esrrhs/pingtunnel/releases)\n[<img src=\"https://img.shields.io/docker/pulls/esrrhs/pingtunnel\">](https://hub.docker.com/repository/docker/esrrhs/pingtunnel)\n[<img src=\"https://img.shields.io/github/actions/workflow/status/esrrhs/pingtunnel/go.yml?branch=master\">](https://github.com/esrrhs/pingtunnel/actions)\n\nPingtunnel is a tool that send TCP/UDP traffic over ICMP.\n\n## Note: This tool is only to be used for study and research, do not use it for illegal purposes\n\n![image](network.jpg)\n\n## Usage\n\n### Install server\n\n-   First prepare a server with a public IP, such as EC2 on AWS, assuming the domain name or public IP is www.yourserver.com\n-   Download the corresponding installation package from [releases](https://github.com/esrrhs/pingtunnel/releases), such as pingtunnel_linux64.zip, then decompress and execute with **root** privileges\n-   “-key” parameter is **int** type, only supports numbers between 0-2147483647\n\n```\nsudo wget (link of latest release)\nsudo unzip pingtunnel_linux64.zip\nsudo ./pingtunnel -type server\n```\n\n-   (Optional) Disable system default ping\n\n```\necho 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all\n```\n\n### Install the client\n\n-   Download the corresponding installation package from [releases](https://github.com/esrrhs/pingtunnel/releases), such as pingtunnel_windows64.zip, and decompress it\n-   Then run with **administrator** privileges. The commands corresponding to different forwarding functions are as follows.\n-   If you see a log of ping pong, the connection is normal\n-   “-key” parameter is **int** type, only supports numbers between 0-2147483647\n\n\n#### Forward sock5\n\n```\npingtunnel.exe -type client -l :4455 -s www.yourserver.com -sock5 1\n```\n\n#### Forward tcp\n\n```\npingtunnel.exe -type client -l :4455 -s www.yourserver.com -t www.yourserver.com:4455 -tcp 1\n```\n\n#### Forward udp\n\n```\npingtunnel.exe -type client -l :4455 -s www.yourserver.com -t www.yourserver.com:4455\n```\n\n### Use Docker\nIt can also be started directly with docker, which is more convenient. Same parameters as above\n-   server:\n```\ndocker run --name pingtunnel-server -d --privileged --network host --restart=always esrrhs/pingtunnel ./pingtunnel -type server -key 123456\n```\n-   client:\n```\ndocker run --name pingtunnel-client -d --restart=always -p 1080:1080 esrrhs/pingtunnel ./pingtunnel -type client -l :1080 -s www.yourserver.com -sock5 1 -key 123456\n```\n\n## Thanks for free JetBrains Open Source license\n\n<img src=\"https://resources.jetbrains.com/storage/products/company/brand/logos/GoLand.png\" height=\"200\"/></a>\n\n\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.025390625,
          "content": "theme: jekyll-theme-cayman"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 19.8974609375,
          "content": "package pingtunnel\n\nimport (\n\t\"github.com/esrrhs/gohome/common\"\n\t\"github.com/esrrhs/gohome/frame\"\n\t\"github.com/esrrhs/gohome/loggo\"\n\t\"github.com/esrrhs/gohome/network\"\n\t\"github.com/golang/protobuf/proto\"\n\t\"golang.org/x/net/icmp\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tSEND_PROTO int = 8\n\tRECV_PROTO int = 0\n)\n\nfunc NewClient(addr string, server string, target string, timeout int, key int,\n\ttcpmode int, tcpmode_buffersize int, tcpmode_maxwin int, tcpmode_resend_timems int, tcpmode_compress int,\n\ttcpmode_stat int, open_sock5 int, maxconn int, sock5_filter *func(addr string) bool) (*Client, error) {\n\n\tvar ipaddr *net.UDPAddr\n\tvar tcpaddr *net.TCPAddr\n\tvar err error\n\n\tif tcpmode > 0 {\n\t\ttcpaddr, err = net.ResolveTCPAddr(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tipaddr, err = net.ResolveUDPAddr(\"udp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tipaddrServer, err := net.ResolveIPAddr(\"ip\", server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trand.Seed(time.Now().UnixNano())\n\treturn &Client{\n\t\texit:                  false,\n\t\trtt:                   0,\n\t\tid:                    rand.Intn(math.MaxInt16),\n\t\tipaddr:                ipaddr,\n\t\ttcpaddr:               tcpaddr,\n\t\taddr:                  addr,\n\t\tipaddrServer:          ipaddrServer,\n\t\taddrServer:            server,\n\t\ttargetAddr:            target,\n\t\ttimeout:               timeout,\n\t\tkey:                   key,\n\t\ttcpmode:               tcpmode,\n\t\ttcpmode_buffersize:    tcpmode_buffersize,\n\t\ttcpmode_maxwin:        tcpmode_maxwin,\n\t\ttcpmode_resend_timems: tcpmode_resend_timems,\n\t\ttcpmode_compress:      tcpmode_compress,\n\t\ttcpmode_stat:          tcpmode_stat,\n\t\topen_sock5:            open_sock5,\n\t\tmaxconn:               maxconn,\n\t\tpongTime:              time.Now(),\n\t\tsock5_filter:          sock5_filter,\n\t}, nil\n}\n\ntype Client struct {\n\texit           bool\n\trtt            time.Duration\n\tworkResultLock sync.WaitGroup\n\tmaxconn        int\n\n\tid       int\n\tsequence int\n\n\ttimeout               int\n\tsproto                int\n\trproto                int\n\tkey                   int\n\ttcpmode               int\n\ttcpmode_buffersize    int\n\ttcpmode_maxwin        int\n\ttcpmode_resend_timems int\n\ttcpmode_compress      int\n\ttcpmode_stat          int\n\n\topen_sock5   int\n\tsock5_filter *func(addr string) bool\n\n\tipaddr  *net.UDPAddr\n\ttcpaddr *net.TCPAddr\n\taddr    string\n\n\tipaddrServer *net.IPAddr\n\taddrServer   string\n\n\ttargetAddr string\n\n\tconn          *icmp.PacketConn\n\tlistenConn    *net.UDPConn\n\ttcplistenConn *net.TCPListener\n\n\tlocalAddrToConnMap sync.Map\n\tlocalIdToConnMap   sync.Map\n\n\tsendPacket             uint64\n\trecvPacket             uint64\n\tsendPacketSize         uint64\n\trecvPacketSize         uint64\n\tlocalAddrToConnMapSize int\n\tlocalIdToConnMapSize   int\n\n\trecvcontrol chan int\n\n\tpongTime time.Time\n}\n\ntype ClientConn struct {\n\texit           bool\n\tipaddr         *net.UDPAddr\n\ttcpaddr        *net.TCPAddr\n\tid             string\n\tactiveRecvTime time.Time\n\tactiveSendTime time.Time\n\tclose          bool\n\n\tfm *frame.FrameMgr\n}\n\nfunc (p *Client) Addr() string {\n\treturn p.addr\n}\n\nfunc (p *Client) IPAddr() *net.UDPAddr {\n\treturn p.ipaddr\n}\n\nfunc (p *Client) TargetAddr() string {\n\treturn p.targetAddr\n}\n\nfunc (p *Client) ServerIPAddr() *net.IPAddr {\n\treturn p.ipaddrServer\n}\n\nfunc (p *Client) ServerAddr() string {\n\treturn p.addrServer\n}\n\nfunc (p *Client) RTT() time.Duration {\n\treturn p.rtt\n}\n\nfunc (p *Client) RecvPacketSize() uint64 {\n\treturn p.recvPacketSize\n}\n\nfunc (p *Client) SendPacketSize() uint64 {\n\treturn p.sendPacketSize\n}\n\nfunc (p *Client) RecvPacket() uint64 {\n\treturn p.recvPacket\n}\n\nfunc (p *Client) SendPacket() uint64 {\n\treturn p.sendPacket\n}\n\nfunc (p *Client) LocalIdToConnMapSize() int {\n\treturn p.localIdToConnMapSize\n}\n\nfunc (p *Client) LocalAddrToConnMapSize() int {\n\treturn p.localAddrToConnMapSize\n}\n\nfunc (p *Client) Run() error {\n\n\tconn, err := icmp.ListenPacket(\"ip4:icmp\", \"\")\n\tif err != nil {\n\t\tloggo.Error(\"Error listening for ICMP packets: %s\", err.Error())\n\t\treturn err\n\t}\n\tp.conn = conn\n\n\tif p.tcpmode > 0 {\n\t\ttcplistenConn, err := net.ListenTCP(\"tcp\", p.tcpaddr)\n\t\tif err != nil {\n\t\t\tloggo.Error(\"Error listening for tcp packets: %s\", err.Error())\n\t\t\treturn err\n\t\t}\n\t\tp.tcplistenConn = tcplistenConn\n\t} else {\n\t\tlistener, err := net.ListenUDP(\"udp\", p.ipaddr)\n\t\tif err != nil {\n\t\t\tloggo.Error(\"Error listening for udp packets: %s\", err.Error())\n\t\t\treturn err\n\t\t}\n\t\tp.listenConn = listener\n\t}\n\n\tif p.tcpmode > 0 {\n\t\tgo p.AcceptTcp()\n\t} else {\n\t\tgo p.Accept()\n\t}\n\n\trecv := make(chan *Packet, 10000)\n\tp.recvcontrol = make(chan int, 1)\n\tgo recvICMP(&p.workResultLock, &p.exit, *p.conn, recv)\n\n\tgo func() {\n\t\tdefer common.CrashLog()\n\n\t\tp.workResultLock.Add(1)\n\t\tdefer p.workResultLock.Done()\n\n\t\tfor !p.exit {\n\t\t\tp.checkTimeoutConn()\n\t\t\tp.ping()\n\t\t\tp.showNet()\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer common.CrashLog()\n\n\t\tp.workResultLock.Add(1)\n\t\tdefer p.workResultLock.Done()\n\n\t\tfor !p.exit {\n\t\t\tp.updateServerAddr()\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer common.CrashLog()\n\n\t\tp.workResultLock.Add(1)\n\t\tdefer p.workResultLock.Done()\n\n\t\tfor !p.exit {\n\t\t\tselect {\n\t\t\tcase <-p.recvcontrol:\n\t\t\t\treturn\n\t\t\tcase r := <-recv:\n\t\t\t\tp.processPacket(r)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (p *Client) Stop() {\n\tp.exit = true\n\tp.recvcontrol <- 1\n\tp.workResultLock.Wait()\n\tp.conn.Close()\n\tif p.tcplistenConn != nil {\n\t\tp.tcplistenConn.Close()\n\t}\n\tif p.listenConn != nil {\n\t\tp.listenConn.Close()\n\t}\n}\n\nfunc (p *Client) AcceptTcp() error {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\tloggo.Info(\"client waiting local accept tcp\")\n\n\tfor !p.exit {\n\t\tp.tcplistenConn.SetDeadline(time.Now().Add(time.Millisecond * 1000))\n\n\t\tconn, err := p.tcplistenConn.AcceptTCP()\n\t\tif err != nil {\n\t\t\tnerr, ok := err.(net.Error)\n\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\tloggo.Info(\"Error accept tcp %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif conn != nil {\n\t\t\tif p.open_sock5 > 0 {\n\t\t\t\tgo p.AcceptSock5Conn(conn)\n\t\t\t} else {\n\t\t\t\tgo p.AcceptTcpConn(conn, p.targetAddr)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *Client) AcceptTcpConn(conn *net.TCPConn, targetAddr string) {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\ttcpsrcaddr := conn.RemoteAddr().(*net.TCPAddr)\n\n\tif p.maxconn > 0 && p.localIdToConnMapSize >= p.maxconn {\n\t\tloggo.Info(\"too many connections %d, client accept new local tcp fail %s\", p.localIdToConnMapSize, tcpsrcaddr.String())\n\t\treturn\n\t}\n\n\tuuid := common.UniqueId()\n\n\tfm := frame.NewFrameMgr(FRAME_MAX_SIZE, FRAME_MAX_ID, p.tcpmode_buffersize, p.tcpmode_maxwin, p.tcpmode_resend_timems, p.tcpmode_compress, p.tcpmode_stat)\n\n\tnow := time.Now()\n\tclientConn := &ClientConn{exit: false, tcpaddr: tcpsrcaddr, id: uuid, activeRecvTime: now, activeSendTime: now, close: false,\n\t\tfm: fm}\n\tp.addClientConn(uuid, tcpsrcaddr.String(), clientConn)\n\tloggo.Info(\"client accept new local tcp %s %s\", uuid, tcpsrcaddr.String())\n\n\tloggo.Info(\"start connect remote tcp %s %s\", uuid, tcpsrcaddr.String())\n\tclientConn.fm.Connect()\n\tstartConnectTime := common.GetNowUpdateInSecond()\n\tfor !p.exit && !clientConn.exit {\n\t\tif clientConn.fm.IsConnected() {\n\t\t\tbreak\n\t\t}\n\t\tclientConn.fm.Update()\n\t\tsendlist := clientConn.fm.GetSendList()\n\t\tfor e := sendlist.Front(); e != nil; e = e.Next() {\n\t\t\tf := e.Value.(*frame.Frame)\n\t\t\tmb, _ := clientConn.fm.MarshalFrame(f)\n\t\t\tp.sequence++\n\t\t\tsendICMP(p.id, p.sequence, *p.conn, p.ipaddrServer, targetAddr, clientConn.id, (uint32)(MyMsg_DATA), mb,\n\t\t\t\tSEND_PROTO, RECV_PROTO, p.key,\n\t\t\t\tp.tcpmode, p.tcpmode_buffersize, p.tcpmode_maxwin, p.tcpmode_resend_timems, p.tcpmode_compress, p.tcpmode_stat,\n\t\t\t\tp.timeout)\n\t\t\tp.sendPacket++\n\t\t\tp.sendPacketSize += (uint64)(len(mb))\n\t\t}\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tdiffclose := now.Sub(startConnectTime)\n\t\tif diffclose > time.Second*5 {\n\t\t\tloggo.Info(\"can not connect remote tcp %s %s\", uuid, tcpsrcaddr.String())\n\t\t\tp.close(clientConn)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif !clientConn.exit {\n\t\tloggo.Info(\"connected remote tcp %s %s\", uuid, tcpsrcaddr.String())\n\t}\n\n\tbytes := make([]byte, 10240)\n\n\ttcpActiveRecvTime := common.GetNowUpdateInSecond()\n\ttcpActiveSendTime := common.GetNowUpdateInSecond()\n\n\tfor !p.exit && !clientConn.exit {\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tsleep := true\n\n\t\tleft := common.MinOfInt(clientConn.fm.GetSendBufferLeft(), len(bytes))\n\t\tif left > 0 {\n\t\t\tconn.SetReadDeadline(time.Now().Add(time.Millisecond * 1))\n\t\t\tn, err := conn.Read(bytes[0:left])\n\t\t\tif err != nil {\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\t\tloggo.Info(\"Error read tcp %s %s %s\", uuid, tcpsrcaddr.String(), err)\n\t\t\t\t\tclientConn.fm.Close()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif n > 0 {\n\t\t\t\tsleep = false\n\t\t\t\tclientConn.fm.WriteSendBuffer(bytes[:n])\n\t\t\t\ttcpActiveRecvTime = now\n\t\t\t}\n\t\t}\n\n\t\tclientConn.fm.Update()\n\n\t\tsendlist := clientConn.fm.GetSendList()\n\t\tif sendlist.Len() > 0 {\n\t\t\tsleep = false\n\t\t\tclientConn.activeSendTime = now\n\t\t\tfor e := sendlist.Front(); e != nil; e = e.Next() {\n\t\t\t\tf := e.Value.(*frame.Frame)\n\t\t\t\tmb, err := clientConn.fm.MarshalFrame(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\tloggo.Error(\"Error tcp Marshal %s %s %s\", uuid, tcpsrcaddr.String(), err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tp.sequence++\n\t\t\t\tsendICMP(p.id, p.sequence, *p.conn, p.ipaddrServer, targetAddr, clientConn.id, (uint32)(MyMsg_DATA), mb,\n\t\t\t\t\tSEND_PROTO, RECV_PROTO, p.key,\n\t\t\t\t\tp.tcpmode, 0, 0, 0, 0, 0,\n\t\t\t\t\t0)\n\t\t\t\tp.sendPacket++\n\t\t\t\tp.sendPacketSize += (uint64)(len(mb))\n\t\t\t}\n\t\t}\n\n\t\tif clientConn.fm.GetRecvBufferSize() > 0 {\n\t\t\tsleep = false\n\t\t\trr := clientConn.fm.GetRecvReadLineBuffer()\n\t\t\tconn.SetWriteDeadline(time.Now().Add(time.Millisecond * 1))\n\t\t\tn, err := conn.Write(rr)\n\t\t\tif err != nil {\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\t\tloggo.Info(\"Error write tcp %s %s %s\", uuid, tcpsrcaddr.String(), err)\n\t\t\t\t\tclientConn.fm.Close()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif n > 0 {\n\t\t\t\tclientConn.fm.SkipRecvBuffer(n)\n\t\t\t\ttcpActiveSendTime = now\n\t\t\t}\n\t\t}\n\n\t\tif sleep {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t}\n\n\t\tdiffrecv := now.Sub(clientConn.activeRecvTime)\n\t\tdiffsend := now.Sub(clientConn.activeSendTime)\n\t\ttcpdiffrecv := now.Sub(tcpActiveRecvTime)\n\t\ttcpdiffsend := now.Sub(tcpActiveSendTime)\n\t\tif diffrecv > time.Second*(time.Duration(p.timeout)) || diffsend > time.Second*(time.Duration(p.timeout)) ||\n\t\t\t(tcpdiffrecv > time.Second*(time.Duration(p.timeout)) && tcpdiffsend > time.Second*(time.Duration(p.timeout))) {\n\t\t\tloggo.Info(\"close inactive conn %s %s\", clientConn.id, clientConn.tcpaddr.String())\n\t\t\tclientConn.fm.Close()\n\t\t\tbreak\n\t\t}\n\n\t\tif clientConn.fm.IsRemoteClosed() {\n\t\t\tloggo.Info(\"closed by remote conn %s %s\", clientConn.id, clientConn.tcpaddr.String())\n\t\t\tclientConn.fm.Close()\n\t\t\tbreak\n\t\t}\n\t}\n\n\tclientConn.fm.Close()\n\n\tstartCloseTime := common.GetNowUpdateInSecond()\n\tfor !p.exit && !clientConn.exit {\n\t\tnow := common.GetNowUpdateInSecond()\n\n\t\tclientConn.fm.Update()\n\n\t\tsendlist := clientConn.fm.GetSendList()\n\t\tfor e := sendlist.Front(); e != nil; e = e.Next() {\n\t\t\tf := e.Value.(*frame.Frame)\n\t\t\tmb, _ := clientConn.fm.MarshalFrame(f)\n\t\t\tp.sequence++\n\t\t\tsendICMP(p.id, p.sequence, *p.conn, p.ipaddrServer, targetAddr, clientConn.id, (uint32)(MyMsg_DATA), mb,\n\t\t\t\tSEND_PROTO, RECV_PROTO, p.key,\n\t\t\t\tp.tcpmode, 0, 0, 0, 0, 0,\n\t\t\t\t0)\n\t\t\tp.sendPacket++\n\t\t\tp.sendPacketSize += (uint64)(len(mb))\n\t\t}\n\n\t\tnodatarecv := true\n\t\tif clientConn.fm.GetRecvBufferSize() > 0 {\n\t\t\trr := clientConn.fm.GetRecvReadLineBuffer()\n\t\t\tconn.SetWriteDeadline(time.Now().Add(time.Millisecond * 100))\n\t\t\tn, _ := conn.Write(rr)\n\t\t\tif n > 0 {\n\t\t\t\tclientConn.fm.SkipRecvBuffer(n)\n\t\t\t\tnodatarecv = false\n\t\t\t}\n\t\t}\n\n\t\tdiffclose := now.Sub(startCloseTime)\n\t\tif diffclose > time.Second*60 {\n\t\t\tloggo.Info(\"close conn had timeout %s %s\", clientConn.id, clientConn.tcpaddr.String())\n\t\t\tbreak\n\t\t}\n\n\t\tremoteclosed := clientConn.fm.IsRemoteClosed()\n\t\tif remoteclosed && nodatarecv {\n\t\t\tloggo.Info(\"remote conn had closed %s %s\", clientConn.id, clientConn.tcpaddr.String())\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tloggo.Info(\"close tcp conn %s %s\", clientConn.id, clientConn.tcpaddr.String())\n\tconn.Close()\n\tp.close(clientConn)\n}\n\nfunc (p *Client) Accept() error {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\tloggo.Info(\"client waiting local accept udp\")\n\n\tbytes := make([]byte, 10240)\n\n\tfor !p.exit {\n\t\tp.listenConn.SetReadDeadline(time.Now().Add(time.Millisecond * 100))\n\t\tn, srcaddr, err := p.listenConn.ReadFromUDP(bytes)\n\t\tif err != nil {\n\t\t\tnerr, ok := err.(net.Error)\n\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\tloggo.Info(\"Error read udp %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif n <= 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tclientConn := p.getClientConnByAddr(srcaddr.String())\n\t\tif clientConn == nil {\n\t\t\tif p.maxconn > 0 && p.localIdToConnMapSize >= p.maxconn {\n\t\t\t\tloggo.Info(\"too many connections %d, client accept new local udp fail %s\", p.localIdToConnMapSize, srcaddr.String())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tuuid := common.UniqueId()\n\t\t\tclientConn = &ClientConn{exit: false, ipaddr: srcaddr, id: uuid, activeRecvTime: now, activeSendTime: now, close: false}\n\t\t\tp.addClientConn(uuid, srcaddr.String(), clientConn)\n\t\t\tloggo.Info(\"client accept new local udp %s %s\", uuid, srcaddr.String())\n\t\t}\n\n\t\tclientConn.activeSendTime = now\n\t\tsendICMP(p.id, p.sequence, *p.conn, p.ipaddrServer, p.targetAddr, clientConn.id, (uint32)(MyMsg_DATA), bytes[:n],\n\t\t\tSEND_PROTO, RECV_PROTO, p.key,\n\t\t\tp.tcpmode, 0, 0, 0, 0, 0,\n\t\t\tp.timeout)\n\n\t\tp.sequence++\n\n\t\tp.sendPacket++\n\t\tp.sendPacketSize += (uint64)(n)\n\t}\n\treturn nil\n}\n\nfunc (p *Client) processPacket(packet *Packet) {\n\n\tif packet.my.Rproto >= 0 {\n\t\treturn\n\t}\n\n\tif packet.my.Key != (int32)(p.key) {\n\t\treturn\n\t}\n\n\tif packet.echoId != p.id {\n\t\treturn\n\t}\n\n\tif packet.my.Type == (int32)(MyMsg_PING) {\n\t\tt := time.Time{}\n\t\tt.UnmarshalBinary(packet.my.Data)\n\t\tnow := time.Now()\n\t\td := now.Sub(t)\n\t\tloggo.Info(\"pong from %s %s\", packet.src.String(), d.String())\n\t\tp.rtt = d\n\t\tp.pongTime = now\n\t\treturn\n\t}\n\n\tif packet.my.Type == (int32)(MyMsg_KICK) {\n\t\tclientConn := p.getClientConnById(packet.my.Id)\n\t\tif clientConn != nil {\n\t\t\tp.close(clientConn)\n\t\t\tloggo.Info(\"remote kick local %s\", packet.my.Id)\n\t\t}\n\t\treturn\n\t}\n\n\tloggo.Debug(\"processPacket %s %s %d\", packet.my.Id, packet.src.String(), len(packet.my.Data))\n\n\tclientConn := p.getClientConnById(packet.my.Id)\n\tif clientConn == nil {\n\t\tloggo.Debug(\"processPacket no conn %s \", packet.my.Id)\n\t\tp.remoteError(packet.my.Id)\n\t\treturn\n\t}\n\n\tnow := common.GetNowUpdateInSecond()\n\tclientConn.activeRecvTime = now\n\n\tif p.tcpmode > 0 {\n\t\tf := &frame.Frame{}\n\t\terr := proto.Unmarshal(packet.my.Data, f)\n\t\tif err != nil {\n\t\t\tloggo.Error(\"Unmarshal tcp Error %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tclientConn.fm.OnRecvFrame(f)\n\t} else {\n\t\tif packet.my.Data == nil {\n\t\t\treturn\n\t\t}\n\t\taddr := clientConn.ipaddr\n\t\t_, err := p.listenConn.WriteToUDP(packet.my.Data, addr)\n\t\tif err != nil {\n\t\t\tloggo.Info(\"WriteToUDP Error read udp %s\", err)\n\t\t\tclientConn.close = true\n\t\t\treturn\n\t\t}\n\t}\n\n\tp.recvPacket++\n\tp.recvPacketSize += (uint64)(len(packet.my.Data))\n}\n\nfunc (p *Client) close(clientConn *ClientConn) {\n\tclientConn.exit = true\n\tp.deleteClientConn(clientConn.id, clientConn.ipaddr.String())\n\tp.deleteClientConn(clientConn.id, clientConn.tcpaddr.String())\n}\n\nfunc (p *Client) checkTimeoutConn() {\n\n\tif p.tcpmode > 0 {\n\t\treturn\n\t}\n\n\ttmp := make(map[string]*ClientConn)\n\tp.localIdToConnMap.Range(func(key, value interface{}) bool {\n\t\tid := key.(string)\n\t\tclientConn := value.(*ClientConn)\n\t\ttmp[id] = clientConn\n\t\treturn true\n\t})\n\n\tnow := common.GetNowUpdateInSecond()\n\tfor _, conn := range tmp {\n\t\tdiffrecv := now.Sub(conn.activeRecvTime)\n\t\tdiffsend := now.Sub(conn.activeSendTime)\n\t\tif diffrecv > time.Second*(time.Duration(p.timeout)) || diffsend > time.Second*(time.Duration(p.timeout)) {\n\t\t\tconn.close = true\n\t\t}\n\t}\n\n\tfor id, conn := range tmp {\n\t\tif conn.close {\n\t\t\tloggo.Info(\"close inactive conn %s %s\", id, conn.ipaddr.String())\n\t\t\tp.close(conn)\n\t\t}\n\t}\n}\n\nfunc (p *Client) ping() {\n\tnow := time.Now()\n\tb, _ := now.MarshalBinary()\n\tsendICMP(p.id, p.sequence, *p.conn, p.ipaddrServer, \"\", \"\", (uint32)(MyMsg_PING), b,\n\t\tSEND_PROTO, RECV_PROTO, p.key,\n\t\t0, 0, 0, 0, 0, 0,\n\t\t0)\n\tloggo.Info(\"ping %s %s %d %d %d %d\", p.addrServer, now.String(), p.sproto, p.rproto, p.id, p.sequence)\n\tp.sequence++\n\tif now.Sub(p.pongTime) > time.Second*3 {\n\t\tp.rtt = 0\n\t}\n}\n\nfunc (p *Client) showNet() {\n\tp.localAddrToConnMapSize = 0\n\tp.localIdToConnMap.Range(func(key, value interface{}) bool {\n\t\tp.localAddrToConnMapSize++\n\t\treturn true\n\t})\n\tp.localIdToConnMapSize = 0\n\tp.localIdToConnMap.Range(func(key, value interface{}) bool {\n\t\tp.localIdToConnMapSize++\n\t\treturn true\n\t})\n\tloggo.Info(\"send %dPacket/s %dKB/s recv %dPacket/s %dKB/s %d/%dConnections\",\n\t\tp.sendPacket, p.sendPacketSize/1024, p.recvPacket, p.recvPacketSize/1024, p.localAddrToConnMapSize, p.localIdToConnMapSize)\n\tp.sendPacket = 0\n\tp.recvPacket = 0\n\tp.sendPacketSize = 0\n\tp.recvPacketSize = 0\n}\n\nfunc (p *Client) AcceptSock5Conn(conn *net.TCPConn) {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\tvar err error = nil\n\tif err = network.Sock5HandshakeBy(conn, \"\", \"\"); err != nil {\n\t\tloggo.Error(\"socks handshake: %s\", err)\n\t\tconn.Close()\n\t\treturn\n\t}\n\t_, addr, err := network.Sock5GetRequest(conn)\n\tif err != nil {\n\t\tloggo.Error(\"error getting request: %s\", err)\n\t\tconn.Close()\n\t\treturn\n\t}\n\t// Sending connection established message immediately to client.\n\t// This some round trip time for creating socks connection with the client.\n\t// But if connection failed, the client will get connection reset error.\n\t_, err = conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43})\n\tif err != nil {\n\t\tloggo.Error(\"send connection confirmation: %s\", err)\n\t\tconn.Close()\n\t\treturn\n\t}\n\n\tloggo.Info(\"accept new sock5 conn: %s\", addr)\n\n\tif p.sock5_filter == nil {\n\t\tp.AcceptTcpConn(conn, addr)\n\t} else {\n\t\tif (*p.sock5_filter)(addr) {\n\t\t\tp.AcceptTcpConn(conn, addr)\n\t\t\treturn\n\t\t}\n\t\tp.AcceptDirectTcpConn(conn, addr)\n\t}\n}\n\nfunc (p *Client) addClientConn(uuid string, addr string, clientConn *ClientConn) {\n\n\tp.localAddrToConnMap.Store(addr, clientConn)\n\tp.localIdToConnMap.Store(uuid, clientConn)\n}\n\nfunc (p *Client) getClientConnByAddr(addr string) *ClientConn {\n\tret, ok := p.localAddrToConnMap.Load(addr)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn ret.(*ClientConn)\n}\n\nfunc (p *Client) getClientConnById(uuid string) *ClientConn {\n\tret, ok := p.localIdToConnMap.Load(uuid)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn ret.(*ClientConn)\n}\n\nfunc (p *Client) deleteClientConn(uuid string, addr string) {\n\tp.localIdToConnMap.Delete(uuid)\n\tp.localAddrToConnMap.Delete(addr)\n}\n\nfunc (p *Client) remoteError(uuid string) {\n\tsendICMP(p.id, p.sequence, *p.conn, p.ipaddrServer, \"\", uuid, (uint32)(MyMsg_KICK), []byte{},\n\t\tSEND_PROTO, RECV_PROTO, p.key,\n\t\t0, 0, 0, 0, 0, 0,\n\t\t0)\n}\n\nfunc (p *Client) AcceptDirectTcpConn(conn *net.TCPConn, targetAddr string) {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\ttcpsrcaddr := conn.RemoteAddr().(*net.TCPAddr)\n\n\tloggo.Info(\"client accept new direct local tcp %s %s\", tcpsrcaddr.String(), targetAddr)\n\n\ttcpaddrTarget, err := net.ResolveTCPAddr(\"tcp\", targetAddr)\n\tif err != nil {\n\t\tloggo.Info(\"direct local tcp ResolveTCPAddr fail: %s %s\", targetAddr, err.Error())\n\t\treturn\n\t}\n\n\ttargetconn, err := net.DialTCP(\"tcp\", nil, tcpaddrTarget)\n\tif err != nil {\n\t\tloggo.Info(\"direct local tcp DialTCP fail: %s %s\", targetAddr, err.Error())\n\t\treturn\n\t}\n\n\tgo p.transfer(conn, targetconn, conn.RemoteAddr().String(), targetconn.RemoteAddr().String())\n\tgo p.transfer(targetconn, conn, targetconn.RemoteAddr().String(), conn.RemoteAddr().String())\n\n\tloggo.Info(\"client accept new direct local tcp ok %s %s\", tcpsrcaddr.String(), targetAddr)\n}\n\nfunc (p *Client) transfer(destination io.WriteCloser, source io.ReadCloser, dst string, src string) {\n\n\tdefer common.CrashLog()\n\n\tdefer destination.Close()\n\tdefer source.Close()\n\tloggo.Info(\"client begin transfer from %s -> %s\", src, dst)\n\tio.Copy(destination, source)\n\tloggo.Info(\"client end transfer from %s -> %s\", src, dst)\n}\n\nfunc (p *Client) updateServerAddr() {\n\tipaddrServer, err := net.ResolveIPAddr(\"ip\", p.addrServer)\n\tif err != nil {\n\t\treturn\n\t}\n\tif p.ipaddrServer.String() != ipaddrServer.String() {\n\t\tp.ipaddrServer = ipaddrServer\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose",
          "type": "tree",
          "content": null
        },
        {
          "name": "gen.bat",
          "type": "blob",
          "size": 0.0244140625,
          "content": "protoc --go_out=. *.proto"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4697265625,
          "content": "module github.com/esrrhs/pingtunnel\n\ngo 1.21\n\nrequire (\n\tgithub.com/esrrhs/gohome v0.0.0-20231129030235-4e6f13493d6c\n\tgithub.com/golang/protobuf v1.5.3\n\tgolang.org/x/net v0.23.0\n)\n\nrequire (\n\tgithub.com/OneOfOne/xxhash v1.2.8 // indirect\n\tgithub.com/google/uuid v1.4.0 // indirect\n\tgithub.com/oschwald/geoip2-golang v1.9.0 // indirect\n\tgithub.com/oschwald/maxminddb-golang v1.12.0 // indirect\n\tgolang.org/x/sys v0.18.0 // indirect\n\tgoogle.golang.org/protobuf v1.33.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.8447265625,
          "content": "github.com/OneOfOne/xxhash v1.2.8 h1:31czK/TI9sNkxIKfaUfGlU47BAxQ0ztGgd9vPyqimf8=\ngithub.com/OneOfOne/xxhash v1.2.8/go.mod h1:eZbhyaAYD41SGSSsnmcpxVoRiQ/MPUTjUdIIOT9Um7Q=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/esrrhs/gohome v0.0.0-20231129030235-4e6f13493d6c h1:i5uscwGClUYsOier4aVbkD8Tna7aQgRZpbllMygKSMM=\ngithub.com/esrrhs/gohome v0.0.0-20231129030235-4e6f13493d6c/go.mod h1:gSrPvj3oNMs3rdHFQka+Di6hHlFnkZbSKCa2z80KisU=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/uuid v1.4.0 h1:MtMxsa51/r9yyhkyLsVeVt0B+BGQZzpQiTQ4eHZ8bc4=\ngithub.com/google/uuid v1.4.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/oschwald/geoip2-golang v1.9.0 h1:uvD3O6fXAXs+usU+UGExshpdP13GAqp4GBrzN7IgKZc=\ngithub.com/oschwald/geoip2-golang v1.9.0/go.mod h1:BHK6TvDyATVQhKNbQBdrj9eAvuwOMi2zSFXizL3K81Y=\ngithub.com/oschwald/maxminddb-golang v1.12.0 h1:9FnTOD0YOhP7DGxGsq4glzpGy5+w7pq50AS6wALUMYs=\ngithub.com/oschwald/maxminddb-golang v1.12.0/go.mod h1:q0Nob5lTCqyQ8WT6FYgS1L7PXKVVbgiymefNwIjPzgY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/sys v0.18.0 h1:DBdB3niSjOA/O0blCZBqDefyWNYveAYMNF1Wum0DYQ4=\ngolang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=\ngoogle.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "msg.pb.go",
          "type": "blob",
          "size": 7.1787109375,
          "content": "// Code generated by protoc-gen-go. DO NOT EDIT.\n// source: msg.proto\n\npackage pingtunnel\n\nimport (\n\tfmt \"fmt\"\n\tproto \"github.com/golang/protobuf/proto\"\n\tmath \"math\"\n)\n\n// Reference imports to suppress errors if they are not otherwise used.\nvar _ = proto.Marshal\nvar _ = fmt.Errorf\nvar _ = math.Inf\n\n// This is a compile-time assertion to ensure that this generated file\n// is compatible with the proto package it is being compiled against.\n// A compilation error at this line likely means your copy of the\n// proto package needs to be updated.\nconst _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package\n\ntype MyMsg_TYPE int32\n\nconst (\n\tMyMsg_DATA  MyMsg_TYPE = 0\n\tMyMsg_PING  MyMsg_TYPE = 1\n\tMyMsg_KICK  MyMsg_TYPE = 2\n\tMyMsg_MAGIC MyMsg_TYPE = 57005\n)\n\nvar MyMsg_TYPE_name = map[int32]string{\n\t0:     \"DATA\",\n\t1:     \"PING\",\n\t2:     \"KICK\",\n\t57005: \"MAGIC\",\n}\n\nvar MyMsg_TYPE_value = map[string]int32{\n\t\"DATA\":  0,\n\t\"PING\":  1,\n\t\"KICK\":  2,\n\t\"MAGIC\": 57005,\n}\n\nfunc (x MyMsg_TYPE) String() string {\n\treturn proto.EnumName(MyMsg_TYPE_name, int32(x))\n}\n\nfunc (MyMsg_TYPE) EnumDescriptor() ([]byte, []int) {\n\treturn fileDescriptor_c06e4cca6c2cc899, []int{0, 0}\n}\n\ntype MyMsg struct {\n\tId                   string   `protobuf:\"bytes,1,opt,name=id,proto3\" json:\"id,omitempty\"`\n\tType                 int32    `protobuf:\"varint,2,opt,name=type,proto3\" json:\"type,omitempty\"`\n\tTarget               string   `protobuf:\"bytes,3,opt,name=target,proto3\" json:\"target,omitempty\"`\n\tData                 []byte   `protobuf:\"bytes,4,opt,name=data,proto3\" json:\"data,omitempty\"`\n\tRproto               int32    `protobuf:\"zigzag32,5,opt,name=rproto,proto3\" json:\"rproto,omitempty\"`\n\tMagic                int32    `protobuf:\"zigzag32,6,opt,name=magic,proto3\" json:\"magic,omitempty\"`\n\tKey                  int32    `protobuf:\"zigzag32,7,opt,name=key,proto3\" json:\"key,omitempty\"`\n\tTimeout              int32    `protobuf:\"varint,8,opt,name=timeout,proto3\" json:\"timeout,omitempty\"`\n\tTcpmode              int32    `protobuf:\"varint,9,opt,name=tcpmode,proto3\" json:\"tcpmode,omitempty\"`\n\tTcpmodeBuffersize    int32    `protobuf:\"varint,10,opt,name=tcpmode_buffersize,json=tcpmodeBuffersize,proto3\" json:\"tcpmode_buffersize,omitempty\"`\n\tTcpmodeMaxwin        int32    `protobuf:\"varint,11,opt,name=tcpmode_maxwin,json=tcpmodeMaxwin,proto3\" json:\"tcpmode_maxwin,omitempty\"`\n\tTcpmodeResendTimems  int32    `protobuf:\"varint,12,opt,name=tcpmode_resend_timems,json=tcpmodeResendTimems,proto3\" json:\"tcpmode_resend_timems,omitempty\"`\n\tTcpmodeCompress      int32    `protobuf:\"varint,13,opt,name=tcpmode_compress,json=tcpmodeCompress,proto3\" json:\"tcpmode_compress,omitempty\"`\n\tTcpmodeStat          int32    `protobuf:\"varint,14,opt,name=tcpmode_stat,json=tcpmodeStat,proto3\" json:\"tcpmode_stat,omitempty\"`\n\tXXX_NoUnkeyedLiteral struct{} `json:\"-\"`\n\tXXX_unrecognized     []byte   `json:\"-\"`\n\tXXX_sizecache        int32    `json:\"-\"`\n}\n\nfunc (m *MyMsg) Reset()         { *m = MyMsg{} }\nfunc (m *MyMsg) String() string { return proto.CompactTextString(m) }\nfunc (*MyMsg) ProtoMessage()    {}\nfunc (*MyMsg) Descriptor() ([]byte, []int) {\n\treturn fileDescriptor_c06e4cca6c2cc899, []int{0}\n}\n\nfunc (m *MyMsg) XXX_Unmarshal(b []byte) error {\n\treturn xxx_messageInfo_MyMsg.Unmarshal(m, b)\n}\nfunc (m *MyMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\n\treturn xxx_messageInfo_MyMsg.Marshal(b, m, deterministic)\n}\nfunc (m *MyMsg) XXX_Merge(src proto.Message) {\n\txxx_messageInfo_MyMsg.Merge(m, src)\n}\nfunc (m *MyMsg) XXX_Size() int {\n\treturn xxx_messageInfo_MyMsg.Size(m)\n}\nfunc (m *MyMsg) XXX_DiscardUnknown() {\n\txxx_messageInfo_MyMsg.DiscardUnknown(m)\n}\n\nvar xxx_messageInfo_MyMsg proto.InternalMessageInfo\n\nfunc (m *MyMsg) GetId() string {\n\tif m != nil {\n\t\treturn m.Id\n\t}\n\treturn \"\"\n}\n\nfunc (m *MyMsg) GetType() int32 {\n\tif m != nil {\n\t\treturn m.Type\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTarget() string {\n\tif m != nil {\n\t\treturn m.Target\n\t}\n\treturn \"\"\n}\n\nfunc (m *MyMsg) GetData() []byte {\n\tif m != nil {\n\t\treturn m.Data\n\t}\n\treturn nil\n}\n\nfunc (m *MyMsg) GetRproto() int32 {\n\tif m != nil {\n\t\treturn m.Rproto\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetMagic() int32 {\n\tif m != nil {\n\t\treturn m.Magic\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetKey() int32 {\n\tif m != nil {\n\t\treturn m.Key\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTimeout() int32 {\n\tif m != nil {\n\t\treturn m.Timeout\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTcpmode() int32 {\n\tif m != nil {\n\t\treturn m.Tcpmode\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTcpmodeBuffersize() int32 {\n\tif m != nil {\n\t\treturn m.TcpmodeBuffersize\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTcpmodeMaxwin() int32 {\n\tif m != nil {\n\t\treturn m.TcpmodeMaxwin\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTcpmodeResendTimems() int32 {\n\tif m != nil {\n\t\treturn m.TcpmodeResendTimems\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTcpmodeCompress() int32 {\n\tif m != nil {\n\t\treturn m.TcpmodeCompress\n\t}\n\treturn 0\n}\n\nfunc (m *MyMsg) GetTcpmodeStat() int32 {\n\tif m != nil {\n\t\treturn m.TcpmodeStat\n\t}\n\treturn 0\n}\n\nfunc init() {\n\tproto.RegisterEnum(\"MyMsg_TYPE\", MyMsg_TYPE_name, MyMsg_TYPE_value)\n\tproto.RegisterType((*MyMsg)(nil), \"MyMsg\")\n}\n\nfunc init() { proto.RegisterFile(\"msg.proto\", fileDescriptor_c06e4cca6c2cc899) }\n\nvar fileDescriptor_c06e4cca6c2cc899 = []byte{\n\t// 342 bytes of a gzipped FileDescriptorProto\n\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0x90, 0xdb, 0x6a, 0xe2, 0x50,\n\t0x14, 0x86, 0x27, 0x27, 0x0f, 0xcb, 0xe8, 0xc4, 0x35, 0x07, 0xd6, 0x65, 0x46, 0x18, 0xc8, 0x5c,\n\t0xcc, 0xc0, 0xb4, 0x4f, 0xa0, 0xb6, 0x88, 0x48, 0x8a, 0xa4, 0xde, 0xb4, 0x37, 0x12, 0xcd, 0x36,\n\t0x84, 0x36, 0x07, 0xb2, 0xb7, 0xb4, 0xf6, 0x9d, 0xfa, 0x08, 0x7d, 0x8d, 0x3e, 0x4f, 0xc9, 0x72,\n\t0xa7, 0x77, 0xff, 0xff, 0x7f, 0x5f, 0xc8, 0x62, 0x43, 0x3f, 0x97, 0xe9, 0xbf, 0xaa, 0x2e, 0x55,\n\t0x39, 0x79, 0xb7, 0xc0, 0x09, 0x4f, 0xa1, 0x4c, 0x71, 0x04, 0x66, 0x96, 0x90, 0xe1, 0x1b, 0x41,\n\t0x3f, 0x32, 0xb3, 0x04, 0x11, 0x6c, 0x75, 0xaa, 0x04, 0x99, 0xbe, 0x11, 0x38, 0x11, 0x67, 0xfc,\n\t0x09, 0x1d, 0x15, 0xd7, 0xa9, 0x50, 0x64, 0xb1, 0xa7, 0x5b, 0xe3, 0x26, 0xb1, 0x8a, 0xc9, 0xf6,\n\t0x8d, 0xc0, 0x8d, 0x38, 0x37, 0x6e, 0xcd, 0xff, 0x20, 0xc7, 0x37, 0x82, 0x71, 0xa4, 0x1b, 0x7e,\n\t0x07, 0x27, 0x8f, 0xd3, 0x6c, 0x4f, 0x1d, 0x9e, 0xcf, 0x05, 0x3d, 0xb0, 0x1e, 0xc4, 0x89, 0xba,\n\t0xbc, 0x35, 0x11, 0x09, 0xba, 0x2a, 0xcb, 0x45, 0x79, 0x54, 0xd4, 0xe3, 0x13, 0xda, 0xca, 0x64,\n\t0x5f, 0xe5, 0x65, 0x22, 0xa8, 0xaf, 0xc9, 0xb9, 0xe2, 0x5f, 0x40, 0x1d, 0xb7, 0xbb, 0xe3, 0xe1,\n\t0x20, 0x6a, 0x99, 0xbd, 0x08, 0x02, 0x96, 0xc6, 0x9a, 0xcc, 0x3e, 0x01, 0xfe, 0x86, 0x51, 0xab,\n\t0xe7, 0xf1, 0xf3, 0x53, 0x56, 0xd0, 0x80, 0xd5, 0xa1, 0x5e, 0x43, 0x1e, 0xf1, 0x02, 0x7e, 0xb4,\n\t0x5a, 0x2d, 0xa4, 0x28, 0x92, 0x6d, 0x73, 0x49, 0x2e, 0xc9, 0x65, 0xfb, 0x9b, 0x86, 0x11, 0xb3,\n\t0x0d, 0x23, 0xfc, 0x03, 0x5e, 0xfb, 0xcd, 0xbe, 0xcc, 0xab, 0x5a, 0x48, 0x49, 0x43, 0xd6, 0xbf,\n\t0xea, 0x7d, 0xae, 0x67, 0xfc, 0x05, 0x6e, 0xab, 0x4a, 0x15, 0x2b, 0x1a, 0xb1, 0x36, 0xd0, 0xdb,\n\t0xad, 0x8a, 0xd5, 0xe4, 0x3f, 0xd8, 0x9b, 0xbb, 0xf5, 0x35, 0xf6, 0xc0, 0xbe, 0x9a, 0x6e, 0xa6,\n\t0xde, 0x97, 0x26, 0xad, 0x97, 0x37, 0x0b, 0xcf, 0x68, 0xd2, 0x6a, 0x39, 0x5f, 0x79, 0x26, 0x0e,\n\t0xc0, 0x09, 0xa7, 0x8b, 0xe5, 0xdc, 0x7b, 0x7d, 0xb3, 0x66, 0xee, 0x3d, 0x54, 0x59, 0x91, 0xaa,\n\t0x63, 0x51, 0x88, 0xc7, 0x5d, 0x87, 0xdf, 0xfe, 0xf2, 0x23, 0x00, 0x00, 0xff, 0xff, 0x59, 0xbc,\n\t0x55, 0x76, 0xfa, 0x01, 0x00, 0x00,\n}\n"
        },
        {
          "name": "msg.proto",
          "type": "blob",
          "size": 0.47265625,
          "content": "syntax = \"proto3\";\noption go_package = \"pingtunnel\";\n\nmessage MyMsg {\n  enum TYPE {\n    DATA = 0;\n    PING = 1;\n    KICK = 2;\n    MAGIC = 0xdead;\n  }\n\n  string id = 1;\n  int32 type = 2;\n  string target = 3;\n  bytes data = 4;\n  sint32 rproto = 5;\n  sint32 magic = 6;\n  sint32 key = 7;\n  int32 timeout = 8;\n  int32 tcpmode = 9;\n  int32 tcpmode_buffersize = 10;\n  int32 tcpmode_maxwin = 11;\n  int32 tcpmode_resend_timems = 12;\n  int32 tcpmode_compress = 13;\n  int32 tcpmode_stat = 14;\n}\n"
        },
        {
          "name": "network.jpg",
          "type": "blob",
          "size": 14.361328125,
          "content": null
        },
        {
          "name": "pack.sh",
          "type": "blob",
          "size": 1.189453125,
          "content": "#! /bin/bash\n#set -x\nNAME=\"pingtunnel\"\n\nexport GO111MODULE=on\n\n#go tool dist list\nbuild_list=$(go tool dist list)\n\ngo mod tidy\n\ncd cmd/\n\nrm pack -rf\nrm pack.zip -f\nmkdir pack\n\nfor line in $build_list; do\n  os=$(echo \"$line\" | awk -F\"/\" '{print $1}')\n  arch=$(echo \"$line\" | awk -F\"/\" '{print $2}')\n  echo \"os=\"$os\" arch=\"$arch\" start build\"\n  if [ $os == \"android\" ]; then\n    continue\n  fi\n  if [ $os == \"ios\" ]; then\n    continue\n  fi\n  if [ $arch == \"wasm\" ]; then\n    continue\n  fi\n  CGO_ENABLED=0 GOOS=$os GOARCH=$arch go build -ldflags=\"-s -w\"\n  if [ $? -ne 0 ]; then\n    echo \"os=\"$os\" arch=\"$arch\" build fail\"\n    exit 1\n  fi\n  if [ $os = \"windows\" ]; then\n    mv cmd.exe ${NAME}.exe\n    zip ${NAME}_\"${os}\"_\"${arch}\"\".zip\" ${NAME}.exe\n    if [ $? -ne 0 ]; then\n      echo \"os=\"$os\" arch=\"$arch\" zip fail\"\n      exit 1\n    fi\n    mv ${NAME}_\"${os}\"_\"${arch}\"\".zip\" pack/\n    rm $NAME\".exe\" -f\n  else\n    mv cmd ${NAME}\n    zip ${NAME}_\"${os}\"_\"${arch}\"\".zip\" ${NAME}\n    if [ $? -ne 0 ]; then\n      echo \"os=\"$os\" arch=\"$arch\" zip fail\"\n      exit 1\n    fi\n    mv ${NAME}_\"${os}\"_\"${arch}\"\".zip\" pack/\n    rm $NAME -f\n  fi\n  echo \"os=\"$os\" arch=\"$arch\" done build\"\ndone\n\nzip pack.zip pack/ -r\n\necho \"all done\"\n"
        },
        {
          "name": "pingtunnel.go",
          "type": "blob",
          "size": 2.66796875,
          "content": "package pingtunnel\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/esrrhs/gohome/common\"\n\t\"github.com/esrrhs/gohome/loggo\"\n\t\"github.com/golang/protobuf/proto\"\n\t\"golang.org/x/net/icmp\"\n\t\"golang.org/x/net/ipv4\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc sendICMP(id int, sequence int, conn icmp.PacketConn, server *net.IPAddr, target string,\n\tconnId string, msgType uint32, data []byte, sproto int, rproto int, key int,\n\ttcpmode int, tcpmode_buffer_size int, tcpmode_maxwin int, tcpmode_resend_time int, tcpmode_compress int, tcpmode_stat int,\n\ttimeout int) {\n\n\tm := &MyMsg{\n\t\tId:                  connId,\n\t\tType:                (int32)(msgType),\n\t\tTarget:              target,\n\t\tData:                data,\n\t\tRproto:              (int32)(rproto),\n\t\tKey:                 (int32)(key),\n\t\tTcpmode:             (int32)(tcpmode),\n\t\tTcpmodeBuffersize:   (int32)(tcpmode_buffer_size),\n\t\tTcpmodeMaxwin:       (int32)(tcpmode_maxwin),\n\t\tTcpmodeResendTimems: (int32)(tcpmode_resend_time),\n\t\tTcpmodeCompress:     (int32)(tcpmode_compress),\n\t\tTcpmodeStat:         (int32)(tcpmode_stat),\n\t\tTimeout:             (int32)(timeout),\n\t\tMagic:               (int32)(MyMsg_MAGIC),\n\t}\n\n\tmb, err := proto.Marshal(m)\n\tif err != nil {\n\t\tloggo.Error(\"sendICMP Marshal MyMsg error %s %s\", server.String(), err)\n\t\treturn\n\t}\n\n\tbody := &icmp.Echo{\n\t\tID:   id,\n\t\tSeq:  sequence,\n\t\tData: mb,\n\t}\n\n\tmsg := &icmp.Message{\n\t\tType: (ipv4.ICMPType)(sproto),\n\t\tCode: 0,\n\t\tBody: body,\n\t}\n\n\tbytes, err := msg.Marshal(nil)\n\tif err != nil {\n\t\tloggo.Error(\"sendICMP Marshal error %s %s\", server.String(), err)\n\t\treturn\n\t}\n\n\tconn.WriteTo(bytes, server)\n}\n\nfunc recvICMP(workResultLock *sync.WaitGroup, exit *bool, conn icmp.PacketConn, recv chan<- *Packet) {\n\n\tdefer common.CrashLog()\n\n\t(*workResultLock).Add(1)\n\tdefer (*workResultLock).Done()\n\n\tbytes := make([]byte, 10240)\n\tfor !*exit {\n\t\tconn.SetReadDeadline(time.Now().Add(time.Millisecond * 100))\n\t\tn, srcaddr, err := conn.ReadFrom(bytes)\n\n\t\tif err != nil {\n\t\t\tnerr, ok := err.(net.Error)\n\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\tloggo.Info(\"Error read icmp message %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif n <= 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\techoId := int(binary.BigEndian.Uint16(bytes[4:6]))\n\t\techoSeq := int(binary.BigEndian.Uint16(bytes[6:8]))\n\n\t\tmy := &MyMsg{}\n\t\terr = proto.Unmarshal(bytes[8:n], my)\n\t\tif err != nil {\n\t\t\tloggo.Debug(\"Unmarshal MyMsg error: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif my.Magic != (int32)(MyMsg_MAGIC) {\n\t\t\tloggo.Debug(\"processPacket data invalid %s\", my.Id)\n\t\t\tcontinue\n\t\t}\n\n\t\trecv <- &Packet{my: my,\n\t\t\tsrc:    srcaddr.(*net.IPAddr),\n\t\t\techoId: echoId, echoSeq: echoSeq}\n\t}\n}\n\ntype Packet struct {\n\tmy      *MyMsg\n\tsrc     *net.IPAddr\n\techoId  int\n\techoSeq int\n}\n\nconst (\n\tFRAME_MAX_SIZE int = 888\n\tFRAME_MAX_ID   int = 1000000\n)\n"
        },
        {
          "name": "pingtunnel_test.go",
          "type": "blob",
          "size": 0.4345703125,
          "content": "package pingtunnel\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang/protobuf/proto\"\n\t\"testing\"\n)\n\nfunc Test0001(t *testing.T) {\n\n\tmy := &MyMsg{}\n\tmy.Id = \"12345\"\n\tmy.Target = \"111:11\"\n\tmy.Type = 12\n\tmy.Data = make([]byte, 0)\n\tdst, _ := proto.Marshal(my)\n\tfmt.Println(\"dst = \", dst)\n\n\tmy1 := &MyMsg{}\n\tproto.Unmarshal(dst, my1)\n\tfmt.Println(\"my1 = \", my1)\n\tfmt.Println(\"my1.Data = \", my1.Data)\n\n\tproto.Unmarshal(dst[0:4], my1)\n\tfmt.Println(\"my1 = \", my1)\n\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 15.251953125,
          "content": "package pingtunnel\n\nimport (\n\t\"github.com/esrrhs/gohome/common\"\n\t\"github.com/esrrhs/gohome/frame\"\n\t\"github.com/esrrhs/gohome/loggo\"\n\t\"github.com/esrrhs/gohome/threadpool\"\n\t\"github.com/golang/protobuf/proto\"\n\t\"golang.org/x/net/icmp\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc NewServer(key int, maxconn int, maxprocessthread int, maxprocessbuffer int, connecttmeout int) (*Server, error) {\n\ts := &Server{\n\t\texit:             false,\n\t\tkey:              key,\n\t\tmaxconn:          maxconn,\n\t\tmaxprocessthread: maxprocessthread,\n\t\tmaxprocessbuffer: maxprocessbuffer,\n\t\tconnecttmeout:    connecttmeout,\n\t}\n\n\tif maxprocessthread > 0 {\n\t\ts.processtp = threadpool.NewThreadPool(maxprocessthread, maxprocessbuffer, func(v interface{}) {\n\t\t\tpacket := v.(*Packet)\n\t\t\ts.processDataPacket(packet)\n\t\t})\n\t}\n\n\treturn s, nil\n}\n\ntype Server struct {\n\texit             bool\n\tkey              int\n\tworkResultLock   sync.WaitGroup\n\tmaxconn          int\n\tmaxprocessthread int\n\tmaxprocessbuffer int\n\tconnecttmeout    int\n\n\tconn *icmp.PacketConn\n\n\tlocalConnMap sync.Map\n\tconnErrorMap sync.Map\n\n\tsendPacket       uint64\n\trecvPacket       uint64\n\tsendPacketSize   uint64\n\trecvPacketSize   uint64\n\tlocalConnMapSize int\n\n\tprocesstp   *threadpool.ThreadPool\n\trecvcontrol chan int\n}\n\ntype ServerConn struct {\n\texit           bool\n\ttimeout        int\n\tipaddrTarget   *net.UDPAddr\n\tconn           *net.UDPConn\n\ttcpaddrTarget  *net.TCPAddr\n\ttcpconn        *net.TCPConn\n\tid             string\n\tactiveRecvTime time.Time\n\tactiveSendTime time.Time\n\tclose          bool\n\trproto         int\n\tfm             *frame.FrameMgr\n\ttcpmode        int\n\techoId         int\n\techoSeq        int\n}\n\nfunc (p *Server) Run() error {\n\n\tconn, err := icmp.ListenPacket(\"ip4:icmp\", \"\")\n\tif err != nil {\n\t\tloggo.Error(\"Error listening for ICMP packets: %s\", err.Error())\n\t\treturn err\n\t}\n\tp.conn = conn\n\n\trecv := make(chan *Packet, 10000)\n\tp.recvcontrol = make(chan int, 1)\n\tgo recvICMP(&p.workResultLock, &p.exit, *p.conn, recv)\n\n\tgo func() {\n\t\tdefer common.CrashLog()\n\n\t\tp.workResultLock.Add(1)\n\t\tdefer p.workResultLock.Done()\n\n\t\tfor !p.exit {\n\t\t\tp.checkTimeoutConn()\n\t\t\tp.showNet()\n\t\t\tp.updateConnError()\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer common.CrashLog()\n\n\t\tp.workResultLock.Add(1)\n\t\tdefer p.workResultLock.Done()\n\n\t\tfor !p.exit {\n\t\t\tselect {\n\t\t\tcase <-p.recvcontrol:\n\t\t\t\treturn\n\t\t\tcase r := <-recv:\n\t\t\t\tp.processPacket(r)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (p *Server) Stop() {\n\tp.exit = true\n\tp.recvcontrol <- 1\n\tp.workResultLock.Wait()\n\tp.processtp.Stop()\n\tp.conn.Close()\n}\n\nfunc (p *Server) processPacket(packet *Packet) {\n\n\tif packet.my.Key != (int32)(p.key) {\n\t\treturn\n\t}\n\n\tif packet.my.Type == (int32)(MyMsg_PING) {\n\t\tt := time.Time{}\n\t\tt.UnmarshalBinary(packet.my.Data)\n\t\tloggo.Info(\"ping from %s %s %d %d %d\", packet.src.String(), t.String(), packet.my.Rproto, packet.echoId, packet.echoSeq)\n\t\tsendICMP(packet.echoId, packet.echoSeq, *p.conn, packet.src, \"\", \"\", (uint32)(MyMsg_PING), packet.my.Data,\n\t\t\t(int)(packet.my.Rproto), -1, p.key,\n\t\t\t0, 0, 0, 0, 0, 0,\n\t\t\t0)\n\t\treturn\n\t}\n\n\tif packet.my.Type == (int32)(MyMsg_KICK) {\n\t\tlocalConn := p.getServerConnById(packet.my.Id)\n\t\tif localConn != nil {\n\t\t\tp.close(localConn)\n\t\t\tloggo.Info(\"remote kick local %s\", packet.my.Id)\n\t\t}\n\t\treturn\n\t}\n\n\tif p.maxprocessthread > 0 {\n\t\tp.processtp.AddJob((int)(common.HashString(packet.my.Id)), packet)\n\t} else {\n\t\tp.processDataPacket(packet)\n\t}\n}\n\nfunc (p *Server) processDataPacketNewConn(id string, packet *Packet) *ServerConn {\n\n\tnow := common.GetNowUpdateInSecond()\n\n\tloggo.Info(\"start add new connect  %s %s\", id, packet.my.Target)\n\n\tif p.maxconn > 0 && p.localConnMapSize >= p.maxconn {\n\t\tloggo.Info(\"too many connections %d, server connected target fail %s\", p.localConnMapSize, packet.my.Target)\n\t\tp.remoteError(packet.echoId, packet.echoSeq, id, (int)(packet.my.Rproto), packet.src)\n\t\treturn nil\n\t}\n\n\taddr := packet.my.Target\n\tif p.isConnError(addr) {\n\t\tloggo.Info(\"addr connect Error before: %s %s\", id, addr)\n\t\tp.remoteError(packet.echoId, packet.echoSeq, id, (int)(packet.my.Rproto), packet.src)\n\t\treturn nil\n\t}\n\n\tif packet.my.Tcpmode > 0 {\n\n\t\tc, err := net.DialTimeout(\"tcp\", addr, time.Millisecond*time.Duration(p.connecttmeout))\n\t\tif err != nil {\n\t\t\tloggo.Error(\"Error listening for tcp packets: %s %s\", id, err.Error())\n\t\t\tp.remoteError(packet.echoId, packet.echoSeq, id, (int)(packet.my.Rproto), packet.src)\n\t\t\tp.addConnError(addr)\n\t\t\treturn nil\n\t\t}\n\t\ttargetConn := c.(*net.TCPConn)\n\t\tipaddrTarget := targetConn.RemoteAddr().(*net.TCPAddr)\n\n\t\tfm := frame.NewFrameMgr(FRAME_MAX_SIZE, FRAME_MAX_ID, (int)(packet.my.TcpmodeBuffersize), (int)(packet.my.TcpmodeMaxwin), (int)(packet.my.TcpmodeResendTimems), (int)(packet.my.TcpmodeCompress),\n\t\t\t(int)(packet.my.TcpmodeStat))\n\n\t\tlocalConn := &ServerConn{exit: false, timeout: (int)(packet.my.Timeout), tcpconn: targetConn, tcpaddrTarget: ipaddrTarget, id: id, activeRecvTime: now, activeSendTime: now, close: false,\n\t\t\trproto: (int)(packet.my.Rproto), fm: fm, tcpmode: (int)(packet.my.Tcpmode)}\n\n\t\tp.addServerConn(id, localConn)\n\n\t\tgo p.RecvTCP(localConn, id, packet.src)\n\t\treturn localConn\n\n\t} else {\n\n\t\tc, err := net.DialTimeout(\"udp\", addr, time.Millisecond*time.Duration(p.connecttmeout))\n\t\tif err != nil {\n\t\t\tloggo.Error(\"Error listening for udp packets: %s %s\", id, err.Error())\n\t\t\tp.remoteError(packet.echoId, packet.echoSeq, id, (int)(packet.my.Rproto), packet.src)\n\t\t\tp.addConnError(addr)\n\t\t\treturn nil\n\t\t}\n\t\ttargetConn := c.(*net.UDPConn)\n\t\tipaddrTarget := targetConn.RemoteAddr().(*net.UDPAddr)\n\n\t\tlocalConn := &ServerConn{exit: false, timeout: (int)(packet.my.Timeout), conn: targetConn, ipaddrTarget: ipaddrTarget, id: id, activeRecvTime: now, activeSendTime: now, close: false,\n\t\t\trproto: (int)(packet.my.Rproto), tcpmode: (int)(packet.my.Tcpmode)}\n\n\t\tp.addServerConn(id, localConn)\n\n\t\tgo p.Recv(localConn, id, packet.src)\n\n\t\treturn localConn\n\t}\n\n\treturn nil\n}\n\nfunc (p *Server) processDataPacket(packet *Packet) {\n\n\tloggo.Debug(\"processPacket %s %s %d\", packet.my.Id, packet.src.String(), len(packet.my.Data))\n\n\tnow := common.GetNowUpdateInSecond()\n\n\tid := packet.my.Id\n\tlocalConn := p.getServerConnById(id)\n\tif localConn == nil {\n\t\tlocalConn = p.processDataPacketNewConn(id, packet)\n\t\tif localConn == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tlocalConn.activeRecvTime = now\n\tlocalConn.echoId = packet.echoId\n\tlocalConn.echoSeq = packet.echoSeq\n\n\tif packet.my.Type == (int32)(MyMsg_DATA) {\n\n\t\tif packet.my.Tcpmode > 0 {\n\t\t\tf := &frame.Frame{}\n\t\t\terr := proto.Unmarshal(packet.my.Data, f)\n\t\t\tif err != nil {\n\t\t\t\tloggo.Error(\"Unmarshal tcp Error %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlocalConn.fm.OnRecvFrame(f)\n\n\t\t} else {\n\t\t\tif packet.my.Data == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err := localConn.conn.Write(packet.my.Data)\n\t\t\tif err != nil {\n\t\t\t\tloggo.Info(\"WriteToUDP Error %s\", err)\n\t\t\t\tlocalConn.close = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tp.recvPacket++\n\t\tp.recvPacketSize += (uint64)(len(packet.my.Data))\n\t}\n}\n\nfunc (p *Server) RecvTCP(conn *ServerConn, id string, src *net.IPAddr) {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\tloggo.Info(\"server waiting target response %s -> %s %s\", conn.tcpaddrTarget.String(), conn.id, conn.tcpconn.LocalAddr().String())\n\n\tloggo.Info(\"start wait remote connect tcp %s %s\", conn.id, conn.tcpaddrTarget.String())\n\tstartConnectTime := common.GetNowUpdateInSecond()\n\tfor !p.exit && !conn.exit {\n\t\tif conn.fm.IsConnected() {\n\t\t\tbreak\n\t\t}\n\t\tconn.fm.Update()\n\t\tsendlist := conn.fm.GetSendList()\n\t\tfor e := sendlist.Front(); e != nil; e = e.Next() {\n\t\t\tf := e.Value.(*frame.Frame)\n\t\t\tmb, _ := conn.fm.MarshalFrame(f)\n\t\t\tsendICMP(conn.echoId, conn.echoSeq, *p.conn, src, \"\", id, (uint32)(MyMsg_DATA), mb,\n\t\t\t\tconn.rproto, -1, p.key,\n\t\t\t\t0, 0, 0, 0, 0, 0,\n\t\t\t\t0)\n\t\t\tp.sendPacket++\n\t\t\tp.sendPacketSize += (uint64)(len(mb))\n\t\t}\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tdiffclose := now.Sub(startConnectTime)\n\t\tif diffclose > time.Second*5 {\n\t\t\tloggo.Info(\"can not connect remote tcp %s %s\", conn.id, conn.tcpaddrTarget.String())\n\t\t\tp.close(conn)\n\t\t\tp.remoteError(conn.echoId, conn.echoSeq, id, conn.rproto, src)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif !conn.exit {\n\t\tloggo.Info(\"remote connected tcp %s %s\", conn.id, conn.tcpaddrTarget.String())\n\t}\n\n\tbytes := make([]byte, 10240)\n\n\ttcpActiveRecvTime := common.GetNowUpdateInSecond()\n\ttcpActiveSendTime := common.GetNowUpdateInSecond()\n\n\tfor !p.exit && !conn.exit {\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tsleep := true\n\n\t\tleft := common.MinOfInt(conn.fm.GetSendBufferLeft(), len(bytes))\n\t\tif left > 0 {\n\t\t\tconn.tcpconn.SetReadDeadline(time.Now().Add(time.Millisecond * 1))\n\t\t\tn, err := conn.tcpconn.Read(bytes[0:left])\n\t\t\tif err != nil {\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\t\tloggo.Info(\"Error read tcp %s %s %s\", conn.id, conn.tcpaddrTarget.String(), err)\n\t\t\t\t\tconn.fm.Close()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif n > 0 {\n\t\t\t\tsleep = false\n\t\t\t\tconn.fm.WriteSendBuffer(bytes[:n])\n\t\t\t\ttcpActiveRecvTime = now\n\t\t\t}\n\t\t}\n\n\t\tconn.fm.Update()\n\n\t\tsendlist := conn.fm.GetSendList()\n\t\tif sendlist.Len() > 0 {\n\t\t\tsleep = false\n\t\t\tconn.activeSendTime = now\n\t\t\tfor e := sendlist.Front(); e != nil; e = e.Next() {\n\t\t\t\tf := e.Value.(*frame.Frame)\n\t\t\t\tmb, err := conn.fm.MarshalFrame(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\tloggo.Error(\"Error tcp Marshal %s %s %s\", conn.id, conn.tcpaddrTarget.String(), err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsendICMP(conn.echoId, conn.echoSeq, *p.conn, src, \"\", id, (uint32)(MyMsg_DATA), mb,\n\t\t\t\t\tconn.rproto, -1, p.key,\n\t\t\t\t\t0, 0, 0, 0, 0, 0,\n\t\t\t\t\t0)\n\t\t\t\tp.sendPacket++\n\t\t\t\tp.sendPacketSize += (uint64)(len(mb))\n\t\t\t}\n\t\t}\n\n\t\tif conn.fm.GetRecvBufferSize() > 0 {\n\t\t\tsleep = false\n\t\t\trr := conn.fm.GetRecvReadLineBuffer()\n\t\t\tconn.tcpconn.SetWriteDeadline(time.Now().Add(time.Millisecond * 1))\n\t\t\tn, err := conn.tcpconn.Write(rr)\n\t\t\tif err != nil {\n\t\t\t\tnerr, ok := err.(net.Error)\n\t\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\t\tloggo.Info(\"Error write tcp %s %s %s\", conn.id, conn.tcpaddrTarget.String(), err)\n\t\t\t\t\tconn.fm.Close()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif n > 0 {\n\t\t\t\tconn.fm.SkipRecvBuffer(n)\n\t\t\t\ttcpActiveSendTime = now\n\t\t\t}\n\t\t}\n\n\t\tif sleep {\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t}\n\n\t\tdiffrecv := now.Sub(conn.activeRecvTime)\n\t\tdiffsend := now.Sub(conn.activeSendTime)\n\t\ttcpdiffrecv := now.Sub(tcpActiveRecvTime)\n\t\ttcpdiffsend := now.Sub(tcpActiveSendTime)\n\t\tif diffrecv > time.Second*(time.Duration(conn.timeout)) || diffsend > time.Second*(time.Duration(conn.timeout)) ||\n\t\t\t(tcpdiffrecv > time.Second*(time.Duration(conn.timeout)) && tcpdiffsend > time.Second*(time.Duration(conn.timeout))) {\n\t\t\tloggo.Info(\"close inactive conn %s %s\", conn.id, conn.tcpaddrTarget.String())\n\t\t\tconn.fm.Close()\n\t\t\tbreak\n\t\t}\n\n\t\tif conn.fm.IsRemoteClosed() {\n\t\t\tloggo.Info(\"closed by remote conn %s %s\", conn.id, conn.tcpaddrTarget.String())\n\t\t\tconn.fm.Close()\n\t\t\tbreak\n\t\t}\n\t}\n\n\tconn.fm.Close()\n\n\tstartCloseTime := common.GetNowUpdateInSecond()\n\tfor !p.exit && !conn.exit {\n\t\tnow := common.GetNowUpdateInSecond()\n\n\t\tconn.fm.Update()\n\n\t\tsendlist := conn.fm.GetSendList()\n\t\tfor e := sendlist.Front(); e != nil; e = e.Next() {\n\t\t\tf := e.Value.(*frame.Frame)\n\t\t\tmb, _ := conn.fm.MarshalFrame(f)\n\t\t\tsendICMP(conn.echoId, conn.echoSeq, *p.conn, src, \"\", id, (uint32)(MyMsg_DATA), mb,\n\t\t\t\tconn.rproto, -1, p.key,\n\t\t\t\t0, 0, 0, 0, 0, 0,\n\t\t\t\t0)\n\t\t\tp.sendPacket++\n\t\t\tp.sendPacketSize += (uint64)(len(mb))\n\t\t}\n\n\t\tnodatarecv := true\n\t\tif conn.fm.GetRecvBufferSize() > 0 {\n\t\t\trr := conn.fm.GetRecvReadLineBuffer()\n\t\t\tconn.tcpconn.SetWriteDeadline(time.Now().Add(time.Millisecond * 100))\n\t\t\tn, _ := conn.tcpconn.Write(rr)\n\t\t\tif n > 0 {\n\t\t\t\tconn.fm.SkipRecvBuffer(n)\n\t\t\t\tnodatarecv = false\n\t\t\t}\n\t\t}\n\n\t\tdiffclose := now.Sub(startCloseTime)\n\t\tif diffclose > time.Second*60 {\n\t\t\tloggo.Info(\"close conn had timeout %s %s\", conn.id, conn.tcpaddrTarget.String())\n\t\t\tbreak\n\t\t}\n\n\t\tremoteclosed := conn.fm.IsRemoteClosed()\n\t\tif remoteclosed && nodatarecv {\n\t\t\tloggo.Info(\"remote conn had closed %s %s\", conn.id, conn.tcpaddrTarget.String())\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\ttime.Sleep(time.Second)\n\n\tloggo.Info(\"close tcp conn %s %s\", conn.id, conn.tcpaddrTarget.String())\n\tp.close(conn)\n}\n\nfunc (p *Server) Recv(conn *ServerConn, id string, src *net.IPAddr) {\n\n\tdefer common.CrashLog()\n\n\tp.workResultLock.Add(1)\n\tdefer p.workResultLock.Done()\n\n\tloggo.Info(\"server waiting target response %s -> %s %s\", conn.ipaddrTarget.String(), conn.id, conn.conn.LocalAddr().String())\n\n\tbytes := make([]byte, 2000)\n\n\tfor !p.exit {\n\n\t\tconn.conn.SetReadDeadline(time.Now().Add(time.Millisecond * 100))\n\t\tn, _, err := conn.conn.ReadFromUDP(bytes)\n\t\tif err != nil {\n\t\t\tnerr, ok := err.(net.Error)\n\t\t\tif !ok || !nerr.Timeout() {\n\t\t\t\tloggo.Info(\"ReadFromUDP Error read udp %s\", err)\n\t\t\t\tconn.close = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tconn.activeSendTime = now\n\n\t\tsendICMP(conn.echoId, conn.echoSeq, *p.conn, src, \"\", id, (uint32)(MyMsg_DATA), bytes[:n],\n\t\t\tconn.rproto, -1, p.key,\n\t\t\t0, 0, 0, 0, 0, 0,\n\t\t\t0)\n\n\t\tp.sendPacket++\n\t\tp.sendPacketSize += (uint64)(n)\n\t}\n}\n\nfunc (p *Server) close(conn *ServerConn) {\n\tif p.getServerConnById(conn.id) != nil {\n\t\tconn.exit = true\n\t\tif conn.conn != nil {\n\t\t\tconn.conn.Close()\n\t\t}\n\t\tif conn.tcpconn != nil {\n\t\t\tconn.tcpconn.Close()\n\t\t}\n\t\tp.deleteServerConn(conn.id)\n\t}\n}\n\nfunc (p *Server) checkTimeoutConn() {\n\n\ttmp := make(map[string]*ServerConn)\n\tp.localConnMap.Range(func(key, value interface{}) bool {\n\t\tid := key.(string)\n\t\tserverConn := value.(*ServerConn)\n\t\ttmp[id] = serverConn\n\t\treturn true\n\t})\n\n\tnow := common.GetNowUpdateInSecond()\n\tfor _, conn := range tmp {\n\t\tif conn.tcpmode > 0 {\n\t\t\tcontinue\n\t\t}\n\t\tdiffrecv := now.Sub(conn.activeRecvTime)\n\t\tdiffsend := now.Sub(conn.activeSendTime)\n\t\tif diffrecv > time.Second*(time.Duration(conn.timeout)) || diffsend > time.Second*(time.Duration(conn.timeout)) {\n\t\t\tconn.close = true\n\t\t}\n\t}\n\n\tfor id, conn := range tmp {\n\t\tif conn.tcpmode > 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif conn.close {\n\t\t\tloggo.Info(\"close inactive conn %s %s\", id, conn.ipaddrTarget.String())\n\t\t\tp.close(conn)\n\t\t}\n\t}\n}\n\nfunc (p *Server) showNet() {\n\tp.localConnMapSize = 0\n\tp.localConnMap.Range(func(key, value interface{}) bool {\n\t\tp.localConnMapSize++\n\t\treturn true\n\t})\n\tloggo.Info(\"send %dPacket/s %dKB/s recv %dPacket/s %dKB/s %dConnections\",\n\t\tp.sendPacket, p.sendPacketSize/1024, p.recvPacket, p.recvPacketSize/1024, p.localConnMapSize)\n\tp.sendPacket = 0\n\tp.recvPacket = 0\n\tp.sendPacketSize = 0\n\tp.recvPacketSize = 0\n}\n\nfunc (p *Server) addServerConn(uuid string, serverConn *ServerConn) {\n\tp.localConnMap.Store(uuid, serverConn)\n}\n\nfunc (p *Server) getServerConnById(uuid string) *ServerConn {\n\tret, ok := p.localConnMap.Load(uuid)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn ret.(*ServerConn)\n}\n\nfunc (p *Server) deleteServerConn(uuid string) {\n\tp.localConnMap.Delete(uuid)\n}\n\nfunc (p *Server) remoteError(echoId int, echoSeq int, uuid string, rprpto int, src *net.IPAddr) {\n\tsendICMP(echoId, echoSeq, *p.conn, src, \"\", uuid, (uint32)(MyMsg_KICK), []byte{},\n\t\trprpto, -1, p.key,\n\t\t0, 0, 0, 0, 0, 0,\n\t\t0)\n}\n\nfunc (p *Server) addConnError(addr string) {\n\t_, ok := p.connErrorMap.Load(addr)\n\tif !ok {\n\t\tnow := common.GetNowUpdateInSecond()\n\t\tp.connErrorMap.Store(addr, now)\n\t}\n}\n\nfunc (p *Server) isConnError(addr string) bool {\n\t_, ok := p.connErrorMap.Load(addr)\n\treturn ok\n}\n\nfunc (p *Server) updateConnError() {\n\n\ttmp := make(map[string]time.Time)\n\tp.connErrorMap.Range(func(key, value interface{}) bool {\n\t\tid := key.(string)\n\t\tt := value.(time.Time)\n\t\ttmp[id] = t\n\t\treturn true\n\t})\n\n\tnow := common.GetNowUpdateInSecond()\n\tfor id, t := range tmp {\n\t\tdiff := now.Sub(t)\n\t\tif diff > time.Second*5 {\n\t\t\tp.connErrorMap.Delete(id)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}