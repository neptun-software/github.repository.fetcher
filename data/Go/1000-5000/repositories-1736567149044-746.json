{
  "metadata": {
    "timestamp": 1736567149044,
    "page": 746,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "astaxie/bat",
      "stars": 2552,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.1171875,
          "content": "FROM golang:1.8\n\nADD . /go/src/github.com/astaxie/bat\n\nRUN go install github.com/astaxie/bat\n\nENTRYPOINT [\"/go/bin/bat\"]"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.9580078125,
          "content": "# bat\nGo implemented CLI cURL-like tool for humans. Bat can be used for testing, debugging, and generally interacting with HTTP servers.\n\nInspired by [Httpie](https://github.com/jakubroztocil/httpie). Thanks to the author, Jakub.\n\n\n![](images/logo.png)\n\n![](images/example.png)\n\n- [Main Features](#main-features)\n- [Installation](#installation)\n- [Usage](#usage)\n- [HTTP Method](#http-method)\n- [Request URL](#request-url)\n- [Request Items](#request-items)\n- [JSON](#json)\n- [Forms](#forms)\n- [HTTP Headers](#http-headers)\n- [Authentication](#authentication)\n- [Proxies](#proxies)\n\n## Docker\n\n    # Build the docker image\n\t$ docker build -t astaxie/bat .\n\t\n\t# Run bat in a container\n\t$ docker run --rm -it --net=host astaxie/bat example.org\n\n## Main Features\n\n- Expressive and intuitive syntax\n- Built-in JSON support\n- Forms and file uploads\n- HTTPS, proxies, and authentication\n- Arbitrary request data\n- Custom headers\n\n## Installation\n\n### Install with Modules - Go 1.11 or higher\n\nIf you only want to install the `bat` tool:\n\n\tgo get -u github.com/astaxie/bat\n\nIf you want a mutable copy of source code:\n\n\tgit clone https://github.com/astaxie/bat ;# clone outside of GOPATH\n\tcd bat\n\tgo install\n\nMake sure the `~/go/bin` is added into `$PATH`.\n\n### Install without Modules - Before Go 1.11\n\n\tgo get -u github.com/astaxie/bat\n\nMake sure the `$GOPATH/bin` is added into `$PATH`.\n\n## Usage\n\nHello World:\n\n\t$ bat beego.me\n\nSynopsis:\n\n\tbat [flags] [METHOD] URL [ITEM [ITEM]]\n\t\nSee also `bat --help`.\t\n\n### Examples\n\nBasic settings - [HTTP method](#http-method), [HTTP headers](#http-headers) and [JSON](#json) data:\n\n\t$ bat PUT example.org X-API-Token:123 name=John\n\nAny custom HTTP method (such as WebDAV, etc.):\n\n\t$ bat -method=PROPFIND example.org name=John\n\nSubmitting forms:\n\n\t$ bat -form=true POST example.org hello=World\n\t\nSee the request that is being sent using one of the output options:\n\n\t$ bat -print=\"Hhb\" example.org\n\nUse Github API to post a comment on an issue with authentication:\n\n\t$ bat -a USERNAME POST https://api.github.com/repos/astaxie/bat/issues/1/comments body='bat is awesome!'\n\nUpload a file using redirected input:\n\n\t$ bat example.org < file.json\n\t\nDownload a file and save it via redirected output:\n\n\t$ bat example.org/file > file\n\t\nDownload a file wget style:\n\n\t$ bat -download=true example.org/file\n\nSet a custom Host header to work around missing DNS records:\n\n\t$ bat localhost:8000 Host:example.com\n\t\nFollowing is the detailed documentation. It covers the command syntax, advanced usage, and also features additional examples.\n\t\n## HTTP Method\nThe name of the HTTP method comes right before the URL argument:\n\n\t$ bat DELETE example.org/todos/7\n\t\nwhich looks similar to the actual Request-Line that is sent:\n\nDELETE /todos/7 HTTP/1.1\n\nWhen the METHOD argument is omitted from the command, bat defaults to either GET (if there is no request data) or POST (with request data).\n\n## Request URL\nThe only information bat needs to perform a request is a URL. The default scheme is, somewhat unsurprisingly, http://, and can be omitted from the argument – `bat example.org` works just fine.\n\nAdditionally, curl-like shorthand for localhost is supported. This means that, for example :3000 would expand to http://localhost:3000 If the port is omitted, then port 80 is assumed.\n\n\t$ bat :/foo\n\n\tGET /foo HTTP/1.1\n\tHost: localhost\n\n\t$ bat :3000/bar\n\t\n\tGET /bar HTTP/1.1\n\tHost: localhost:3000\n\n\t$ bat :\n\n\tGET / HTTP/1.1\n\tHost: localhost\n\nIf you find yourself manually constructing URLs with query string parameters on the terminal, you may appreciate the `param=value` syntax for appending URL parameters so that you don't have to worry about escaping the & separators. To search for bat on Google Images you could use this command:\n\n\t$ bat GET www.google.com search=bat tbm=isch\n\n\tGET /?search=bat&tbm=isch HTTP/1.1\n\n## Request Items\nThere are a few different request item types that provide a convenient mechanism for specifying HTTP headers, simple JSON and form data, files, and URL parameters.\n\nThey are key/value pairs specified after the URL. All have in common that they become part of the actual request that is sent and that their type is distinguished only by the separator used: `:`, `=`, `:=`, `@`, `=@`, and `:=@`. The ones with an `@` expect a file path as value.\n\n\n|       Item Type         |\t          Description           |\n| ------------------------| ------------------------------ | \n|HTTP Headers `Name:Value`|Arbitrary HTTP header, e.g. `X-API-Token:123`.|\n|Data Fields `field=value`|Request data fields to be serialized as a JSON object (default), or to be form-encoded (--form, -f).|\n|Form File Fields `field@/dir/file`|Only available with `-form`, `-f`. For example `screenshot@~/Pictures/img.png`. The presence of a file field results in a `multipart/form-data` request.|\n|Form Fields from file `field=@file.txt`|read content from file as value|\n|Raw JSON fields `field:=json`, `field:=@file.json`|Useful when sending JSON and one or more fields need to be a Boolean, Number, nested Object, or an Array, e.g., meals:='[\"ham\",\"spam\"]' or pies:=[1,2,3] (note the quotes).|\n\nYou can use `\\` to escape characters that shouldn't be used as separators (or parts thereof). For instance, foo\\==bar will become a data key/value pair (foo= and bar) instead of a URL parameter.\n\nYou can also quote values, e.g. `foo=\"bar baz\"`.\n## JSON\nJSON is the lingua franca of modern web services and it is also the implicit content type bat by default uses:\n\nIf your command includes some data items, they are serialized as a JSON object by default. bat also automatically sets the following headers, both of which can be overridden:\n\n| header       | value            |\n| ------------ | ---------------- |\n| Content-Type | application/json |\n| Accept       | application/json |\n\nYou can use --json=true, -j=true to explicitly set Accept to `application/json` regardless of whether you are sending data (it's a shortcut for setting the header via the usual header notation – `bat url Accept:application/json`).\n\nSimple example:\n\n\t$ bat PUT example.org name=John email=john@example.org\n\tPUT / HTTP/1.1\n\tAccept: application/json\n\tAccept-Encoding: gzip, deflate\n\tContent-Type: application/json\n\tHost: example.org\n\t\n\t{\n\t    \"name\": \"John\",\n\t    \"email\": \"john@example.org\"\n\t}\n\nEven custom/vendored media types that have a json format are getting detected, as long as they implement a json type response and contain a `json` in their declared form:\n\n\t$ bat GET example.org/user/1 Accept:application/vnd.example.v2.0+json\n\tGET / HTTP/1.1\n\tAccept: application/vnd.example.v2.0+json\n\tAccept-Encoding: gzip, deflate\n\tContent-Type: application/vnd.example.v2.0+json\n\tHost: example.org\n\n\t{\n\t    \"name\": \"John\",\n\t    \"email\": \"john@example.org\"\n\t}\n\nNon-string fields use the := separator, which allows you to embed raw JSON into the resulting object. Text and raw JSON files can also be embedded into fields using =@ and :=@:\n\n\t$ bat PUT api.example.com/person/1 \\\n    name=John \\\n    age:=29 married:=false hobbies:='[\"http\", \"pies\"]' \\  # Raw JSON\n    description=@about-john.txt \\   # Embed text file\n    bookmarks:=@bookmarks.json      # Embed JSON file\n\n\tPUT /person/1 HTTP/1.1\n\tAccept: application/json\n\tContent-Type: application/json\n\tHost: api.example.com\n\t\n\t{\n\t    \"age\": 29,\n\t    \"hobbies\": [\n\t        \"http\",\n\t        \"pies\"\n\t    ],\n\t    \"description\": \"John is a nice guy who likes pies.\",\n\t    \"married\": false,\n\t    \"name\": \"John\",\n\t    \"bookmarks\": {\n\t        \"HTTPie\": \"http://httpie.org\",\n\t    }\n\t}\n\t\nSend JSON data stored in a file (see redirected input for more examples):\n\n\t$ bat POST api.example.com/person/1 < person.json\n\t\n## Forms\nSubmitting forms are very similar to sending JSON requests. Often the only difference is in adding the `-form=true`, `-f` option, which ensures that data fields are serialized correctly and Content-Type is set to, `application/x-www-form-urlencoded; charset=utf-8`.\n\nIt is possible to make form data the implicit content type instead of JSON via the config file.\n\n### Regular Forms\n\n\t$ bat -f=true POST api.example.org/person/1 name='John Smith' \\\n    email=john@example.org\n\n\tPOST /person/1 HTTP/1.1\n\tContent-Type: application/x-www-form-urlencoded; charset=utf-8\n\n\tname=John+Smith&email=john%40example.org\n\n### File Upload Forms\n\nIf one or more file fields is present, the serialization and content type is `multipart/form-data`:\n\n\t$ bat -f=true POST example.com/jobs name='John Smith' cv@~/Documents/cv.pdf\n\t\nThe request above is the same as if the following HTML form were submitted:\n\n```\n<form enctype=\"multipart/form-data\" method=\"post\" action=\"http://example.com/jobs\">\n    <input type=\"text\" name=\"name\" />\n    <input type=\"file\" name=\"cv\" />\n</form>\n```\n\nNote that `@` is used to simulate a file upload form field.\n\n## HTTP Headers\nTo set custom headers you can use the Header:Value notation:\n\n\t$ bat example.org  User-Agent:Bacon/1.0  'Cookie:valued-visitor=yes;foo=bar'  \\\n    X-Foo:Bar  Referer:http://beego.me/\n\n\tGET / HTTP/1.1\n\tAccept: */*\n\tAccept-Encoding: gzip, deflate\n\tCookie: valued-visitor=yes;foo=bar\n\tHost: example.org\n\tReferer: http://beego.me/\n\tUser-Agent: Bacon/1.0\n\tX-Foo: Bar\n\t\nThere are a couple of default headers that bat sets:\n\n\tGET / HTTP/1.1\n\tAccept: */*\n\tAccept-Encoding: gzip, deflate\n\tUser-Agent: bat/<version>\n\tHost: <taken-from-URL>\n\nAny of the default headers can be overridden.\n\n# Authentication\nBasic auth:\n\n\t$ bat -a=username:password example.org\n\n# Proxies\nYou can specify proxies to be used through the --proxy argument for each protocol (which is included in the value in case of redirects across protocols):\n\n\t$ bat --proxy=http://10.10.1.10:3128 example.org\n\t\nWith Basic authentication:\n\n\t$ bat --proxy=http://user:pass@10.10.1.10:3128 example.org\n\t\nYou can also configure proxies by environment variables HTTP_PROXY and HTTPS_PROXY, and the underlying Requests library will pick them up as well. If you want to disable proxies configured through the environment variables for certain hosts, you can specify them in NO_PROXY.\n\nIn your ~/.bash_profile:\n\n\texport HTTP_PROXY=http://10.10.1.10:3128\n\texport HTTPS_PROXY=https://10.10.1.10:1080\n\texport NO_PROXY=localhost,example.com\n"
        },
        {
          "name": "bat.go",
          "type": "blob",
          "size": 10.818359375,
          "content": "// Copyright 2015 bat authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n// Bat is a Go implemented CLI cURL-like tool for humans\n// bat [flags] [METHOD] URL [ITEM [ITEM]]\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tversion              = \"0.1.0\"\n\tprintReqHeader uint8 = 1 << (iota - 1)\n\tprintReqBody\n\tprintRespHeader\n\tprintRespBody\n)\n\nvar (\n\tver              bool\n\tform             bool\n\tpretty           bool\n\tdownload         bool\n\tinsecureSSL      bool\n\tauth             string\n\tproxy            string\n\tprintV           string\n\tprintOption      uint8\n\tbody             string\n\tbench            bool\n\tbenchN           int\n\tbenchC           int\n\tisjson           = flag.Bool(\"json\", true, \"Send the data as a JSON object\")\n\tmethod           = flag.String(\"method\", \"GET\", \"HTTP method\")\n\tURL              = flag.String(\"url\", \"\", \"HTTP request URL\")\n\tjsonmap          map[string]interface{}\n\tcontentJsonRegex = `application/(.*)json`\n)\n\nfunc init() {\n\tflag.BoolVar(&ver, \"v\", false, \"Print Version Number\")\n\tflag.BoolVar(&ver, \"version\", false, \"Print Version Number\")\n\tflag.BoolVar(&pretty, \"pretty\", true, \"Print Json Pretty Format\")\n\tflag.BoolVar(&pretty, \"p\", true, \"Print Json Pretty Format\")\n\tflag.StringVar(&printV, \"print\", \"A\", \"Print request and response\")\n\tflag.BoolVar(&form, \"form\", false, \"Submitting as a form\")\n\tflag.BoolVar(&form, \"f\", false, \"Submitting as a form\")\n\tflag.BoolVar(&download, \"download\", false, \"Download the url content as file\")\n\tflag.BoolVar(&download, \"d\", false, \"Download the url content as file\")\n\tflag.BoolVar(&insecureSSL, \"insecure\", false, \"Allow connections to SSL sites without certs\")\n\tflag.BoolVar(&insecureSSL, \"i\", false, \"Allow connections to SSL sites without certs\")\n\tflag.StringVar(&auth, \"auth\", \"\", \"HTTP authentication username:password, USER[:PASS]\")\n\tflag.StringVar(&auth, \"a\", \"\", \"HTTP authentication username:password, USER[:PASS]\")\n\tflag.StringVar(&proxy, \"proxy\", \"\", \"Proxy host and port, PROXY_URL\")\n\tflag.BoolVar(&bench, \"bench\", false, \"Sends bench requests to URL\")\n\tflag.BoolVar(&bench, \"b\", false, \"Sends bench requests to URL\")\n\tflag.IntVar(&benchN, \"b.N\", 1000, \"Number of requests to run\")\n\tflag.IntVar(&benchC, \"b.C\", 100, \"Number of requests to run concurrently.\")\n\tflag.StringVar(&body, \"body\", \"\", \"Raw data send as body\")\n\tjsonmap = make(map[string]interface{})\n}\n\nfunc parsePrintOption(s string) {\n\tif strings.ContainsRune(s, 'A') {\n\t\tprintOption = printReqHeader | printReqBody | printRespHeader | printRespBody\n\t\treturn\n\t}\n\n\tif strings.ContainsRune(s, 'H') {\n\t\tprintOption |= printReqHeader\n\t}\n\tif strings.ContainsRune(s, 'B') {\n\t\tprintOption |= printReqBody\n\t}\n\tif strings.ContainsRune(s, 'h') {\n\t\tprintOption |= printRespHeader\n\t}\n\tif strings.ContainsRune(s, 'b') {\n\t\tprintOption |= printRespBody\n\t}\n\treturn\n}\n\nfunc main() {\n\tlog.SetFlags(log.LstdFlags | log.Lshortfile | log.Lmicroseconds)\n\tflag.Usage = usage\n\tflag.Parse()\n\targs := flag.Args()\n\tif len(args) > 0 {\n\t\targs = filter(args)\n\t}\n\tif ver {\n\t\tfmt.Println(\"Version:\", version)\n\t\tos.Exit(2)\n\t}\n\tparsePrintOption(printV)\n\tif printOption&printReqBody != printReqBody {\n\t\tdefaultSetting.DumpBody = false\n\t}\n\tvar stdin []byte\n\tif runtime.GOOS != \"windows\" {\n\t\tfi, err := os.Stdin.Stat()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif fi.Size() != 0 {\n\t\t\tstdin, err = ioutil.ReadAll(os.Stdin)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(\"Read from Stdin\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif *URL == \"\" {\n\t\tusage()\n\t}\n\tif strings.HasPrefix(*URL, \":\") {\n\t\turlb := []byte(*URL)\n\t\tif *URL == \":\" {\n\t\t\t*URL = \"http://localhost/\"\n\t\t} else if len(*URL) > 1 && urlb[1] != '/' {\n\t\t\t*URL = \"http://localhost\" + *URL\n\t\t} else {\n\t\t\t*URL = \"http://localhost\" + string(urlb[1:])\n\t\t}\n\t}\n\tif !strings.HasPrefix(*URL, \"http://\") && !strings.HasPrefix(*URL, \"https://\") {\n\t\t*URL = \"http://\" + *URL\n\t}\n\tu, err := url.Parse(*URL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif auth != \"\" {\n\t\tuserpass := strings.Split(auth, \":\")\n\t\tif len(userpass) == 2 {\n\t\t\tu.User = url.UserPassword(userpass[0], userpass[1])\n\t\t} else {\n\t\t\tu.User = url.User(auth)\n\t\t}\n\t}\n\t*URL = u.String()\n\thttpreq := getHTTP(*method, *URL, args)\n\tif u.User != nil {\n\t\tpassword, _ := u.User.Password()\n\t\thttpreq.GetRequest().SetBasicAuth(u.User.Username(), password)\n\t}\n\t// Insecure SSL Support\n\tif insecureSSL {\n\t\thttpreq.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})\n\t}\n\t// Proxy Support\n\tif proxy != \"\" {\n\t\tpurl, err := url.Parse(proxy)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Proxy Url parse err\", err)\n\t\t}\n\t\thttpreq.SetProxy(http.ProxyURL(purl))\n\t} else {\n\t\teurl, err := http.ProxyFromEnvironment(httpreq.GetRequest())\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Environment Proxy Url parse err\", err)\n\t\t}\n\t\thttpreq.SetProxy(http.ProxyURL(eurl))\n\t}\n\tif body != \"\" {\n\t\thttpreq.Body(body)\n\t}\n\tif len(stdin) > 0 {\n\t\tvar j interface{}\n\t\td := json.NewDecoder(bytes.NewReader(stdin))\n\t\td.UseNumber()\n\t\terr = d.Decode(&j)\n\t\tif err != nil {\n\t\t\thttpreq.Body(stdin)\n\t\t} else {\n\t\t\thttpreq.JsonBody(j)\n\t\t}\n\t}\n\n\t// AB bench\n\tif bench {\n\t\thttpreq.Debug(false)\n\t\tRunBench(httpreq)\n\t\treturn\n\t}\n\tres, err := httpreq.Response()\n\tif err != nil {\n\t\tlog.Fatalln(\"can't get the url\", err)\n\t}\n\n\t// download file\n\tif download {\n\t\tvar fl string\n\t\tif disposition := res.Header.Get(\"Content-Disposition\"); disposition != \"\" {\n\t\t\tfls := strings.Split(disposition, \";\")\n\t\t\tfor _, f := range fls {\n\t\t\t\tf = strings.TrimSpace(f)\n\t\t\t\tif strings.HasPrefix(f, \"filename=\") {\n\t\t\t\t\t// Remove 'filename='\n\t\t\t\t\tf = strings.TrimLeft(f, \"filename=\")\n\n\t\t\t\t\t// Remove quotes and spaces from either end\n\t\t\t\t\tf = strings.TrimLeft(f, \"\\\"' \")\n\t\t\t\t\tfl = strings.TrimRight(f, \"\\\"' \")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif fl == \"\" {\n\t\t\t_, fl = filepath.Split(u.Path)\n\t\t}\n\t\tfd, err := os.OpenFile(fl, os.O_RDWR|os.O_CREATE, 0666)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"can't create file\", err)\n\t\t}\n\t\tif runtime.GOOS != \"windows\" {\n\t\t\tfmt.Println(Color(res.Proto, Magenta), Color(res.Status, Green))\n\t\t\tfor k, v := range res.Header {\n\t\t\t\tfmt.Println(Color(k, Gray), \":\", Color(strings.Join(v, \" \"), Cyan))\n\t\t\t}\n\t\t} else {\n\t\t\tfmt.Println(res.Proto, res.Status)\n\t\t\tfor k, v := range res.Header {\n\t\t\t\tfmt.Println(k, \":\", strings.Join(v, \" \"))\n\t\t\t}\n\t\t}\n\t\tfmt.Println(\"\")\n\t\tcontentLength := res.Header.Get(\"Content-Length\")\n\t\tvar total int64\n\t\tif contentLength != \"\" {\n\t\t\ttotal, _ = strconv.ParseInt(contentLength, 10, 64)\n\t\t}\n\t\tfmt.Printf(\"Downloading to \\\"%s\\\"\\n\", fl)\n\t\tpb := NewProgressBar(total)\n\t\tpb.Start()\n\t\tmultiWriter := io.MultiWriter(fd, pb)\n\t\t_, err = io.Copy(multiWriter, res.Body)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Can't Write the body into file\", err)\n\t\t}\n\t\tpb.Finish()\n\t\tdefer fd.Close()\n\t\tdefer res.Body.Close()\n\t\treturn\n\t}\n\n\tif runtime.GOOS != \"windows\" {\n\t\tfi, err := os.Stdout.Stat()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif fi.Mode()&os.ModeDevice == os.ModeDevice {\n\t\t\tvar dumpHeader, dumpBody []byte\n\t\t\tdump := httpreq.DumpRequest()\n\t\t\tdps := strings.Split(string(dump), \"\\n\")\n\t\t\tfor i, line := range dps {\n\t\t\t\tif len(strings.Trim(line, \"\\r\\n \")) == 0 {\n\t\t\t\t\tdumpHeader = []byte(strings.Join(dps[:i], \"\\n\"))\n\t\t\t\t\tdumpBody = []byte(strings.Join(dps[i:], \"\\n\"))\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif printOption&printReqHeader == printReqHeader {\n\t\t\t\tfmt.Println(ColorfulRequest(string(dumpHeader)))\n\t\t\t\tfmt.Println(\"\")\n\t\t\t}\n\t\t\tif printOption&printReqBody == printReqBody {\n\t\t\t\tif string(dumpBody) != \"\\r\\n\" {\n\t\t\t\t\tfmt.Println(string(dumpBody))\n\t\t\t\t\tfmt.Println(\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif printOption&printRespHeader == printRespHeader {\n\t\t\t\tfmt.Println(Color(res.Proto, Magenta), Color(res.Status, Green))\n\t\t\t\tfor k, v := range res.Header {\n\t\t\t\t\tfmt.Printf(\"%s: %s\\n\", Color(k, Gray), Color(strings.Join(v, \" \"), Cyan))\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"\")\n\t\t\t}\n\t\t\tif printOption&printRespBody == printRespBody {\n\t\t\t\tbody := formatResponseBody(res, httpreq, pretty)\n\t\t\t\tfmt.Println(ColorfulResponse(body, res.Header.Get(\"Content-Type\")))\n\t\t\t}\n\t\t} else {\n\t\t\tbody := formatResponseBody(res, httpreq, pretty)\n\t\t\t_, err = os.Stdout.WriteString(body)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar dumpHeader, dumpBody []byte\n\t\tdump := httpreq.DumpRequest()\n\t\tdps := strings.Split(string(dump), \"\\n\")\n\t\tfor i, line := range dps {\n\t\t\tif len(strings.Trim(line, \"\\r\\n \")) == 0 {\n\t\t\t\tdumpHeader = []byte(strings.Join(dps[:i], \"\\n\"))\n\t\t\t\tdumpBody = []byte(strings.Join(dps[i:], \"\\n\"))\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif printOption&printReqHeader == printReqHeader {\n\t\t\tfmt.Println(string(dumpHeader))\n\t\t\tfmt.Println(\"\")\n\t\t}\n\t\tif printOption&printReqBody == printReqBody {\n\t\t\tfmt.Println(string(dumpBody))\n\t\t\tfmt.Println(\"\")\n\t\t}\n\t\tif printOption&printRespHeader == printRespHeader {\n\t\t\tfmt.Println(res.Proto, res.Status)\n\t\t\tfor k, v := range res.Header {\n\t\t\t\tfmt.Println(k, \":\", strings.Join(v, \" \"))\n\t\t\t}\n\t\t\tfmt.Println(\"\")\n\t\t}\n\t\tif printOption&printRespBody == printRespBody {\n\t\t\tbody := formatResponseBody(res, httpreq, pretty)\n\t\t\tfmt.Println(body)\n\t\t}\n\t}\n}\n\nvar usageinfo string = `bat is a Go implemented CLI cURL-like tool for humans.\n\nUsage:\n\n\tbat [flags] [METHOD] URL [ITEM [ITEM]]\n\nflags:\n  -a, -auth=USER[:PASS]       Pass a username:password pair as the argument\n  -b, -bench=false            Sends bench requests to URL\n  -b.N=1000                   Number of requests to run\n  -b.C=100                    Number of requests to run concurrently\n  -body=\"\"                    Send RAW data as body\n  -f, -form=false             Submitting the data as a form\n  -j, -json=true              Send the data in a JSON object\n  -p, -pretty=true            Print Json Pretty Format\n  -i, -insecure=false         Allow connections to SSL sites without certs\n  -proxy=PROXY_URL            Proxy with host and port\n  -print=\"A\"                  String specifying what the output should contain, default will print all information\n         \"H\" request headers\n         \"B\" request body\n         \"h\" response headers\n         \"b\" response body\n  -v, -version=true           Show Version Number\n\nMETHOD:\n  bat defaults to either GET (if there is no request data) or POST (with request data).\n\nURL:\n  The only information needed to perform a request is a URL. The default scheme is http://,\n  which can be omitted from the argument; example.org works just fine.\n\nITEM:\n  Can be any of:\n    Query string   key=value\n    Header         key:value\n    Post data      key=value\n    File upload    key@/path/file\n\nExample:\n\n\tbat beego.me\n\nmore help information please refer to https://github.com/astaxie/bat\n`\n\nfunc usage() {\n\tfmt.Println(usageinfo)\n\tos.Exit(2)\n}\n"
        },
        {
          "name": "bench.go",
          "type": "blob",
          "size": 4.57421875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/astaxie/bat/httplib\"\n)\n\ntype result struct {\n\terr           error\n\tstatusCode    int\n\tduration      time.Duration\n\tcontentLength int64\n}\n\nfunc RunBench(b *httplib.BeegoHttpRequest) {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\tstart := time.Now()\n\tresults := make(chan *result, benchN)\n\tvar wg sync.WaitGroup\n\twg.Add(benchN)\n\n\tjobs := make(chan int, benchN)\n\tfor i := 0; i < benchC; i++ {\n\t\tgo func() {\n\t\t\tworker(&wg, jobs, results, b)\n\t\t}()\n\t}\n\tfor i := 0; i < benchN; i++ {\n\t\tjobs <- i\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n\tprintReport(benchN, results, \"\", time.Now().Sub(start))\n\tclose(results)\n}\n\nfunc worker(wg *sync.WaitGroup, ch chan int, results chan *result, b *httplib.BeegoHttpRequest) {\n\tfor _ = range ch {\n\t\ts := time.Now()\n\t\tcode := 0\n\t\tsize := int64(0)\n\t\tresp, err := b.SendOut()\n\t\tif err == nil {\n\t\t\tsize = resp.ContentLength\n\t\t\tcode = resp.StatusCode\n\t\t\tresp.Body.Close()\n\t\t}\n\t\twg.Done()\n\n\t\tresults <- &result{\n\t\t\tstatusCode:    code,\n\t\t\tduration:      time.Now().Sub(s),\n\t\t\terr:           err,\n\t\t\tcontentLength: size,\n\t\t}\n\t}\n}\n\nconst (\n\tbarChar = \"∎\"\n)\n\ntype report struct {\n\tavgTotal float64\n\tfastest  float64\n\tslowest  float64\n\taverage  float64\n\trps      float64\n\n\tresults chan *result\n\ttotal   time.Duration\n\n\terrorDist      map[string]int\n\tstatusCodeDist map[int]int\n\tlats           []float64\n\tsizeTotal      int64\n\n\toutput string\n}\n\nfunc printReport(size int, results chan *result, output string, total time.Duration) {\n\tr := &report{\n\t\toutput:         output,\n\t\tresults:        results,\n\t\ttotal:          total,\n\t\tstatusCodeDist: make(map[int]int),\n\t\terrorDist:      make(map[string]int),\n\t}\n\tr.finalize()\n}\n\nfunc (r *report) finalize() {\n\tfor {\n\t\tselect {\n\t\tcase res := <-r.results:\n\t\t\tif res.err != nil {\n\t\t\t\tr.errorDist[res.err.Error()]++\n\t\t\t} else {\n\t\t\t\tr.lats = append(r.lats, res.duration.Seconds())\n\t\t\t\tr.avgTotal += res.duration.Seconds()\n\t\t\t\tr.statusCodeDist[res.statusCode]++\n\t\t\t\tif res.contentLength > 0 {\n\t\t\t\t\tr.sizeTotal += res.contentLength\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tr.rps = float64(len(r.lats)) / r.total.Seconds()\n\t\t\tr.average = r.avgTotal / float64(len(r.lats))\n\t\t\tr.print()\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (r *report) print() {\n\tsort.Float64s(r.lats)\n\n\tif r.output == \"csv\" {\n\t\tr.printCSV()\n\t\treturn\n\t}\n\n\tif len(r.lats) > 0 {\n\t\tr.fastest = r.lats[0]\n\t\tr.slowest = r.lats[len(r.lats)-1]\n\t\tfmt.Printf(\"\\nSummary:\\n\")\n\t\tfmt.Printf(\"  Total:\\t%4.4f secs.\\n\", r.total.Seconds())\n\t\tfmt.Printf(\"  Slowest:\\t%4.4f secs.\\n\", r.slowest)\n\t\tfmt.Printf(\"  Fastest:\\t%4.4f secs.\\n\", r.fastest)\n\t\tfmt.Printf(\"  Average:\\t%4.4f secs.\\n\", r.average)\n\t\tfmt.Printf(\"  Requests/sec:\\t%4.4f\\n\", r.rps)\n\t\tif r.sizeTotal > 0 {\n\t\t\tfmt.Printf(\"  Total Data Received:\\t%d bytes.\\n\", r.sizeTotal)\n\t\t\tfmt.Printf(\"  Response Size per Request:\\t%d bytes.\\n\", r.sizeTotal/int64(len(r.lats)))\n\t\t}\n\t\tr.printStatusCodes()\n\t\tr.printHistogram()\n\t\tr.printLatencies()\n\t}\n\n\tif len(r.errorDist) > 0 {\n\t\tr.printErrors()\n\t}\n}\n\nfunc (r *report) printCSV() {\n\tfor i, val := range r.lats {\n\t\tfmt.Printf(\"%v,%4.4f\\n\", i+1, val)\n\t}\n}\n\n// Prints percentile latencies.\nfunc (r *report) printLatencies() {\n\tpctls := []int{10, 25, 50, 75, 90, 95, 99}\n\tdata := make([]float64, len(pctls))\n\tj := 0\n\tfor i := 0; i < len(r.lats) && j < len(pctls); i++ {\n\t\tcurrent := i * 100 / len(r.lats)\n\t\tif current >= pctls[j] {\n\t\t\tdata[j] = r.lats[i]\n\t\t\tj++\n\t\t}\n\t}\n\tfmt.Printf(\"\\nLatency distribution:\\n\")\n\tfor i := 0; i < len(pctls); i++ {\n\t\tif data[i] > 0 {\n\t\t\tfmt.Printf(\"  %v%% in %4.4f secs.\\n\", pctls[i], data[i])\n\t\t}\n\t}\n}\n\nfunc (r *report) printHistogram() {\n\tbc := 10\n\tbuckets := make([]float64, bc+1)\n\tcounts := make([]int, bc+1)\n\tbs := (r.slowest - r.fastest) / float64(bc)\n\tfor i := 0; i < bc; i++ {\n\t\tbuckets[i] = r.fastest + bs*float64(i)\n\t}\n\tbuckets[bc] = r.slowest\n\tvar bi int\n\tvar max int\n\tfor i := 0; i < len(r.lats); {\n\t\tif r.lats[i] <= buckets[bi] {\n\t\t\ti++\n\t\t\tcounts[bi]++\n\t\t\tif max < counts[bi] {\n\t\t\t\tmax = counts[bi]\n\t\t\t}\n\t\t} else if bi < len(buckets)-1 {\n\t\t\tbi++\n\t\t}\n\t}\n\tfmt.Printf(\"\\nResponse time histogram:\\n\")\n\tfor i := 0; i < len(buckets); i++ {\n\t\t// Normalize bar lengths.\n\t\tvar barLen int\n\t\tif max > 0 {\n\t\t\tbarLen = counts[i] * 40 / max\n\t\t}\n\t\tfmt.Printf(\"  %4.3f [%v]\\t|%v\\n\", buckets[i], counts[i], strings.Repeat(barChar, barLen))\n\t}\n}\n\n// Prints status code distribution.\nfunc (r *report) printStatusCodes() {\n\tfmt.Printf(\"\\nStatus code distribution:\\n\")\n\tfor code, num := range r.statusCodeDist {\n\t\tfmt.Printf(\"  [%d]\\t%d responses\\n\", code, num)\n\t}\n}\n\nfunc (r *report) printErrors() {\n\tfmt.Printf(\"\\nError distribution:\\n\")\n\tfor err, num := range r.errorDist {\n\t\tfmt.Printf(\"  [%d]\\t%s\\n\", num, err)\n\t}\n}\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 3.0966796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tGray = uint8(iota + 90)\n\tRed\n\tGreen\n\tYellow\n\tBlue\n\tMagenta\n\tCyan\n\tWhite\n\n\tEndColor = \"\\033[0m\"\n)\n\nfunc Color(str string, color uint8) string {\n\treturn fmt.Sprintf(\"%s%s%s\", ColorStart(color), str, EndColor)\n}\n\nfunc ColorStart(color uint8) string {\n\treturn fmt.Sprintf(\"\\033[%dm\", color)\n}\n\nfunc ColorfulRequest(str string) string {\n\tlines := strings.Split(str, \"\\n\")\n\tif printOption&printReqHeader == printReqHeader {\n\t\tstrs := strings.Split(lines[0], \" \")\n\t\tstrs[0] = Color(strs[0], Magenta)\n\t\tstrs[1] = Color(strs[1], Cyan)\n\t\tstrs[2] = Color(strs[2], Magenta)\n\t\tlines[0] = strings.Join(strs, \" \")\n\t}\n\tfor i, line := range lines[1:] {\n\t\tsubstr := strings.Split(line, \":\")\n\t\tif len(substr) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tsubstr[0] = Color(substr[0], Gray)\n\t\tsubstr[1] = Color(strings.Join(substr[1:], \":\"), Cyan)\n\t\tlines[i+1] = strings.Join(substr[:2], \":\")\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}\n\nfunc ColorfulResponse(str, contenttype string) string {\n\tmatch, err := regexp.MatchString(contentJsonRegex, contenttype)\n\tif err != nil {\n\t\tlog.Fatalln(\"failed to compile regex\", err)\n\t}\n\tif match {\n\t\tstr = ColorfulJson(str)\n\t} else {\n\t\tstr = ColorfulHTML(str)\n\t}\n\treturn str\n}\n\nfunc ColorfulJson(str string) string {\n\tvar rsli []rune\n\tvar key, val, startcolor, endcolor, startsemicolon bool\n\tvar prev rune\n\tfor _, char := range []rune(str) {\n\t\tswitch char {\n\t\tcase ' ':\n\t\t\trsli = append(rsli, char)\n\t\tcase '{':\n\t\t\tstartcolor = true\n\t\t\tkey = true\n\t\t\tval = false\n\t\t\trsli = append(rsli, char)\n\t\tcase '}':\n\t\t\tstartcolor = false\n\t\t\tendcolor = false\n\t\t\tkey = false\n\t\t\tval = false\n\t\t\trsli = append(rsli, char)\n\t\tcase '\"':\n\t\t\tif startsemicolon && prev == '\\\\' {\n\t\t\t\trsli = append(rsli, char)\n\t\t\t} else {\n\t\t\t\tif startcolor {\n\t\t\t\t\trsli = append(rsli, char)\n\t\t\t\t\tif key {\n\t\t\t\t\t\trsli = append(rsli, []rune(ColorStart(Magenta))...)\n\t\t\t\t\t} else if val {\n\t\t\t\t\t\trsli = append(rsli, []rune(ColorStart(Cyan))...)\n\t\t\t\t\t}\n\t\t\t\t\tstartsemicolon = true\n\t\t\t\t\tkey = false\n\t\t\t\t\tval = false\n\t\t\t\t\tstartcolor = false\n\t\t\t\t} else {\n\t\t\t\t\trsli = append(rsli, []rune(EndColor)...)\n\t\t\t\t\trsli = append(rsli, char)\n\t\t\t\t\tendcolor = true\n\t\t\t\t\tstartsemicolon = false\n\t\t\t\t}\n\t\t\t}\n\t\tcase ',':\n\t\t\tif !startsemicolon {\n\t\t\t\tstartcolor = true\n\t\t\t\tkey = true\n\t\t\t\tval = false\n\t\t\t\tif !endcolor {\n\t\t\t\t\trsli = append(rsli, []rune(EndColor)...)\n\t\t\t\t\tendcolor = true\n\t\t\t\t}\n\t\t\t}\n\t\t\trsli = append(rsli, char)\n\t\tcase ':':\n\t\t\tif !startsemicolon {\n\t\t\t\tkey = false\n\t\t\t\tval = true\n\t\t\t\tstartcolor = true\n\t\t\t\tif !endcolor {\n\t\t\t\t\trsli = append(rsli, []rune(EndColor)...)\n\t\t\t\t\tendcolor = true\n\t\t\t\t}\n\t\t\t}\n\t\t\trsli = append(rsli, char)\n\t\tcase '\\n', '\\r', '[', ']':\n\t\t\trsli = append(rsli, char)\n\t\tdefault:\n\t\t\tif !startsemicolon {\n\t\t\t\tif key && startcolor {\n\t\t\t\t\trsli = append(rsli, []rune(ColorStart(Magenta))...)\n\t\t\t\t\tkey = false\n\t\t\t\t\tstartcolor = false\n\t\t\t\t\tendcolor = false\n\t\t\t\t}\n\t\t\t\tif val && startcolor {\n\t\t\t\t\trsli = append(rsli, []rune(ColorStart(Cyan))...)\n\t\t\t\t\tval = false\n\t\t\t\t\tstartcolor = false\n\t\t\t\t\tendcolor = false\n\t\t\t\t}\n\t\t\t}\n\t\t\trsli = append(rsli, char)\n\t\t}\n\t\tprev = char\n\t}\n\treturn string(rsli)\n}\n\nfunc ColorfulHTML(str string) string {\n\treturn Color(str, Green)\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 0.78515625,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"strings\"\n)\n\nvar methodList = []string{\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"HEAD\", \"OPTIONS\"}\n\nfunc filter(args []string) []string {\n\tvar i int\n\tif inSlice(strings.ToUpper(args[i]), methodList) {\n\t\t*method = strings.ToUpper(args[i])\n\t\ti++\n\t} else if len(args) > 0 && *method == \"GET\" {\n\t\tfor _, v := range args[1:] {\n\t\t\t// defaults to either GET (with no request data) or POST (with request data).\n\t\t\t// Params\n\t\t\tstrs := strings.Split(v, \"=\")\n\t\t\tif len(strs) == 2 {\n\t\t\t\t*method = \"POST\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// files\n\t\t\tstrs = strings.Split(v, \"@\")\n\t\t\tif len(strs) == 2 {\n\t\t\t\t*method = \"POST\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else if *method == \"GET\" && body != \"\" {\n\t\t*method = \"POST\"\n\t}\n\tif len(args) <= i {\n\t\tlog.Fatal(\"Miss the URL\")\n\t}\n\t*URL = args[i]\n\ti++\n\treturn args[i:]\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0380859375,
          "content": "module github.com/astaxie/bat\n\ngo 1.12\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 3.02734375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/astaxie/bat/httplib\"\n)\n\nvar defaultSetting = httplib.BeegoHttpSettings{\n\tShowDebug:        true,\n\tUserAgent:        \"bat/\" + version,\n\tConnectTimeout:   60 * time.Second,\n\tReadWriteTimeout: 60 * time.Second,\n\tGzip:             true,\n\tDumpBody:         true,\n}\n\nfunc getHTTP(method string, url string, args []string) (r *httplib.BeegoHttpRequest) {\n\tr = httplib.NewBeegoRequest(url, method)\n\tr.Setting(defaultSetting)\n\tr.Header(\"Accept-Encoding\", \"gzip, deflate\")\n\tif *isjson {\n\t\tr.Header(\"Accept\", \"application/json\")\n\t} else if form || method == \"GET\" {\n\t\tr.Header(\"Accept\", \"*/*\")\n\t} else {\n\t\tr.Header(\"Accept\", \"application/json\")\n\t}\n\tfor i := range args {\n\t\t// Headers\n\t\tstrs := strings.Split(args[i], \":\")\n\t\tif len(strs) >= 2 {\n\t\t\tif strs[0] == \"Host\" {\n\t\t\t\tr.SetHost(strings.Join(strs[1:], \":\"))\n\t\t\t}\n\t\t\tr.Header(strs[0], strings.Join(strs[1:], \":\"))\n\t\t\tcontinue\n\t\t}\n\t\t// files\n\t\tstrs = strings.SplitN(args[i], \"@\", 2)\n\t\tif !*isjson && len(strs) == 2 {\n\t\t\tif !form {\n\t\t\t\tlog.Fatal(\"file upload only support in forms style: -f=true\")\n\t\t\t}\n\t\t\tr.PostFile(strs[0], strs[1])\n\t\t\tcontinue\n\t\t}\n\t\t// Json raws\n\t\tstrs = strings.SplitN(args[i], \":=\", 2)\n\t\tif len(strs) == 2 {\n\t\t\tif strings.HasPrefix(strs[1], \"@\") {\n\t\t\t\tf, err := os.Open(strings.TrimLeft(strs[1], \"@\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(\"Read File\", strings.TrimLeft(strs[1], \"@\"), err)\n\t\t\t\t}\n\t\t\t\tcontent, err := ioutil.ReadAll(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(\"ReadAll from File\", strings.TrimLeft(strs[1], \"@\"), err)\n\t\t\t\t}\n\t\t\t\tvar j interface{}\n\t\t\t\terr = json.Unmarshal(content, &j)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(\"Read from File\", strings.TrimLeft(strs[1], \"@\"), \"Unmarshal\", err)\n\t\t\t\t}\n\t\t\t\tjsonmap[strs[0]] = j\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tjsonmap[strs[0]] = toRealType(strs[1])\n\t\t\tcontinue\n\t\t}\n\t\t// Params\n\t\tstrs = strings.SplitN(args[i], \"=\", 2)\n\t\tif len(strs) == 2 {\n\t\t\tif strings.HasPrefix(strs[1], \"@\") {\n\t\t\t\tf, err := os.Open(strings.TrimLeft(strs[1], \"@\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(\"Read File\", strings.TrimLeft(strs[1], \"@\"), err)\n\t\t\t\t}\n\t\t\t\tcontent, err := ioutil.ReadAll(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(\"ReadAll from File\", strings.TrimLeft(strs[1], \"@\"), err)\n\t\t\t\t}\n\t\t\t\tstrs[1] = string(content)\n\t\t\t}\n\t\t\tif form || method == \"GET\" {\n\t\t\t\tr.Param(strs[0], strs[1])\n\t\t\t} else {\n\t\t\t\tjsonmap[strs[0]] = strs[1]\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t}\n\tif !form && len(jsonmap) > 0 {\n\t\tr.JsonBody(jsonmap)\n\t}\n\treturn\n}\n\nfunc formatResponseBody(res *http.Response, httpreq *httplib.BeegoHttpRequest, pretty bool) string {\n\tbody, err := httpreq.Bytes()\n\tif err != nil {\n\t\tlog.Fatalln(\"can't get the url\", err)\n\t}\n\tfmt.Println(\"\")\n\tmatch, err := regexp.MatchString(contentJsonRegex, res.Header.Get(\"Content-Type\"))\n\tif err != nil {\n\t\tlog.Fatalln(\"failed to compile regex\", err)\n\t}\n\tif pretty && match {\n\t\tvar output bytes.Buffer\n\t\terr := json.Indent(&output, body, \"\", \"  \")\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Response Json Indent: \", err)\n\t\t}\n\n\t\treturn output.String()\n\t}\n\n\treturn string(body)\n}\n"
        },
        {
          "name": "httplib",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "pb.go",
          "type": "blob",
          "size": 4.0322265625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nconst (\n\tDEFAULT_REFRESH_RATE = time.Millisecond * 200\n\tFORMAT               = \"[=>-]\"\n)\n\ntype ProgressBar struct {\n\tcurrent                          int64\n\tTotal                            int64\n\tRefreshRate                      time.Duration\n\tShowPercent, ShowCounters        bool\n\tShowSpeed, ShowTimeLeft, ShowBar bool\n\tShowFinalTime                    bool\n\n\tisFinish     int32\n\tstartTime    time.Time\n\tcurrentValue int64\n\n\tBarStart string\n\tBarEnd   string\n\tEmpty    string\n\tCurrent  string\n\tCurrentN string\n}\n\nfunc NewProgressBar(total int64) (pb *ProgressBar) {\n\tpb = &ProgressBar{\n\t\tTotal:         total,\n\t\tRefreshRate:   DEFAULT_REFRESH_RATE,\n\t\tShowPercent:   true,\n\t\tShowBar:       true,\n\t\tShowCounters:  true,\n\t\tShowFinalTime: true,\n\t\tShowTimeLeft:  true,\n\t\tShowSpeed:     true,\n\t\tBarStart:      \"[\",\n\t\tBarEnd:        \"]\",\n\t\tEmpty:         \"_\",\n\t\tCurrent:       \"=\",\n\t\tCurrentN:      \">\",\n\t}\n\treturn\n}\n\nfunc (pb *ProgressBar) Start() {\n\tpb.startTime = time.Now()\n\tif pb.Total == 0 {\n\t\tpb.ShowBar = false\n\t\tpb.ShowTimeLeft = false\n\t\tpb.ShowPercent = false\n\t}\n\tgo pb.writer()\n}\n\n// Write the current state of the progressbar\nfunc (pb *ProgressBar) Update() {\n\tc := atomic.LoadInt64(&pb.current)\n\tif c != pb.currentValue {\n\t\tpb.write(c)\n\t\tpb.currentValue = c\n\t}\n}\n\n// Internal loop for writing progressbar\nfunc (pb *ProgressBar) writer() {\n\tfor {\n\t\tif atomic.LoadInt32(&pb.isFinish) != 0 {\n\t\t\tbreak\n\t\t}\n\t\tpb.Update()\n\t\ttime.Sleep(pb.RefreshRate)\n\t}\n}\n\n// Increment current value\nfunc (pb *ProgressBar) Increment() int {\n\treturn pb.Add(1)\n}\n\n// Set current value\nfunc (pb *ProgressBar) Set(current int) {\n\tatomic.StoreInt64(&pb.current, int64(current))\n}\n\n// Add to current value\nfunc (pb *ProgressBar) Add(add int) int {\n\treturn int(pb.Add64(int64(add)))\n}\n\nfunc (pb *ProgressBar) Add64(add int64) int64 {\n\treturn atomic.AddInt64(&pb.current, add)\n}\n\n// End print\nfunc (pb *ProgressBar) Finish() {\n\tatomic.StoreInt32(&pb.isFinish, 1)\n\tpb.write(atomic.LoadInt64(&pb.current))\n}\n\n// implement io.Writer\nfunc (pb *ProgressBar) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\tpb.Add(n)\n\treturn\n}\n\nfunc (pb *ProgressBar) write(current int64) {\n\twidth := 123\n\n\tvar percentBox, countersBox, timeLeftBox, speedBox, barBox, end, out string\n\n\t// percents\n\tif pb.ShowPercent {\n\t\tpercent := float64(current) / (float64(pb.Total) / float64(100))\n\t\tpercentBox = fmt.Sprintf(\" %#.02f %% \", percent)\n\t}\n\n\t// counters\n\tif pb.ShowCounters {\n\t\tif pb.Total > 0 {\n\t\t\tcountersBox = fmt.Sprintf(\"%s / %s \", FormatBytes(current), FormatBytes(pb.Total))\n\t\t} else {\n\t\t\tcountersBox = FormatBytes(current) + \" \"\n\t\t}\n\t}\n\n\t// time left\n\tfromStart := time.Now().Sub(pb.startTime)\n\tif atomic.LoadInt32(&pb.isFinish) != 0 {\n\t\tif pb.ShowFinalTime {\n\t\t\tleft := (fromStart / time.Second) * time.Second\n\t\t\ttimeLeftBox = left.String()\n\t\t}\n\t} else if pb.ShowTimeLeft && current > 0 {\n\t\tperEntry := fromStart / time.Duration(current)\n\t\tleft := time.Duration(pb.Total-current) * perEntry\n\t\tleft = (left / time.Second) * time.Second\n\t\ttimeLeftBox = left.String()\n\t}\n\n\t// speed\n\tif pb.ShowSpeed && current > 0 {\n\t\tfromStart := time.Now().Sub(pb.startTime)\n\t\tspeed := float64(current) / (float64(fromStart) / float64(time.Second))\n\t\tspeedBox = FormatBytes(int64(speed)) + \"/s \"\n\t}\n\n\t// bar\n\tif pb.ShowBar {\n\t\tsize := width - len(countersBox+pb.BarStart+pb.BarEnd+percentBox+timeLeftBox+speedBox)\n\t\tif size > 0 {\n\t\t\tcurCount := int(math.Ceil((float64(current) / float64(pb.Total)) * float64(size)))\n\t\t\temptCount := size - curCount\n\t\t\tbarBox = pb.BarStart\n\t\t\tif emptCount < 0 {\n\t\t\t\temptCount = 0\n\t\t\t}\n\t\t\tif curCount > size {\n\t\t\t\tcurCount = size\n\t\t\t}\n\t\t\tif emptCount <= 0 {\n\t\t\t\tbarBox += strings.Repeat(pb.Current, curCount)\n\t\t\t} else if curCount > 0 {\n\t\t\t\tbarBox += strings.Repeat(pb.Current, curCount-1) + pb.CurrentN\n\t\t\t}\n\n\t\t\tbarBox += strings.Repeat(pb.Empty, emptCount) + pb.BarEnd\n\t\t}\n\t}\n\n\t// check len\n\tout = countersBox + barBox + percentBox + speedBox + timeLeftBox\n\tif len(out) < width {\n\t\tend = strings.Repeat(\" \", width-len(out))\n\t}\n\n\t// and print!\n\tfmt.Print(\"\\r\" + out + end)\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 1.63671875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc inSlice(str string, l []string) bool {\n\tfor i := range l {\n\t\tif l[i] == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc toRealType(str string) interface{} {\n\tif i, err := isint(str); err == nil {\n\t\treturn i\n\t}\n\tif b, err := isbool(str); err == nil {\n\t\treturn b\n\t}\n\tif f, err := isfloat(str); err == nil {\n\t\treturn f\n\t}\n\tif strings.HasPrefix(str, \"[\") && strings.HasSuffix(str, \"]\") {\n\t\tbstr := []byte(str)\n\t\tstrs := strings.Split(string(bstr[1:len(bstr)-1]), \",\")\n\t\tvar r []interface{}\n\t\tfor _, s := range strs {\n\t\t\tif i, err := isint(s); err == nil {\n\t\t\t\tr = append(r, i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i, err := isbool(s); err == nil {\n\t\t\t\tr = append(r, i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif i, err := isfloat(s); err == nil {\n\t\t\t\tr = append(r, i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tr = append(r, strings.Trim(s, \"\\\"' \"))\n\t\t}\n\t\treturn r\n\t}\n\treturn str\n}\n\nfunc isint(v string) (i int, err error) {\n\treturn strconv.Atoi(v)\n}\n\nfunc isbool(v string) (bool, error) {\n\treturn strconv.ParseBool(v)\n}\n\nfunc isfloat(v string) (float64, error) {\n\treturn strconv.ParseFloat(v, 64)\n}\n\n// Convert bytes to human readable string. Like a 2 MB, 64.2 KB, 52 B\nfunc FormatBytes(i int64) (result string) {\n\tswitch {\n\tcase i > (1024 * 1024 * 1024 * 1024):\n\t\tresult = fmt.Sprintf(\"%#.02f TB\", float64(i)/1024/1024/1024/1024)\n\tcase i > (1024 * 1024 * 1024):\n\t\tresult = fmt.Sprintf(\"%#.02f GB\", float64(i)/1024/1024/1024)\n\tcase i > (1024 * 1024):\n\t\tresult = fmt.Sprintf(\"%#.02f MB\", float64(i)/1024/1024)\n\tcase i > 1024:\n\t\tresult = fmt.Sprintf(\"%#.02f KB\", float64(i)/1024)\n\tdefault:\n\t\tresult = fmt.Sprintf(\"%d B\", i)\n\t}\n\tresult = strings.Trim(result, \" \")\n\treturn\n}\n"
        }
      ]
    }
  ]
}