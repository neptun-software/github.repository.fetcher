{
  "metadata": {
    "timestamp": 1736566991688,
    "page": 572,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cloudflare/tableflip",
      "stars": 2934,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4521484375,
          "content": "Copyright (c) 2017-2018, Cloudflare. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.177734375,
          "content": "# Graceful process restarts in Go\n\n[![](https://godoc.org/github.com/cloudflare/tableflip?status.svg)](https://godoc.org/github.com/cloudflare/tableflip)\n\nIt is sometimes useful to update the running code and / or configuration of a\nnetwork service, without disrupting existing connections. Usually, this is\nachieved by starting a new process, somehow transferring clients to it and\nthen exiting the old process.\n\nThere are [many ways to implement graceful upgrades](https://blog.cloudflare.com/graceful-upgrades-in-go/).\nThey vary wildly in the trade-offs they make, and how much control they afford the user. This library\nhas the following goals:\n\n* No old code keeps running after a successful upgrade\n* The new process has a grace period for performing initialisation\n* Crashing during initialisation is OK\n* Only a single upgrade is ever run in parallel\n\n**`tableflip` works on Linux and macOS.**\n\n## Using the library\n\n```Go\nupg, _ := tableflip.New(tableflip.Options{})\ndefer upg.Stop()\n\ngo func() {\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, syscall.SIGHUP)\n\tfor range sig {\n\t\tupg.Upgrade()\n\t}\n}()\n\n// Listen must be called before Ready\nln, _ := upg.Listen(\"tcp\", \"localhost:8080\")\ndefer ln.Close()\n\ngo http.Serve(ln, nil)\n\nif err := upg.Ready(); err != nil {\n\tpanic(err)\n}\n\n<-upg.Exit()\n```\n\nPlease see the more elaborate [graceful shutdown with net/http](http_example_test.go) example.\n\n## Integration with `systemd`\n\n```text\n[Unit]\nDescription=Service using tableflip\n\n[Service]\nExecStart=/path/to/binary -some-flag /path/to/pid-file\nExecReload=/bin/kill -HUP $MAINPID\nPIDFile=/path/to/pid-file\n```\n\nSee the [documentation](https://godoc.org/github.com/cloudflare/tableflip) as well.\n\nThe logs of a process using `tableflip` may go missing due to a [bug in journald](https://github.com/systemd/systemd/issues/13708),\nwhich has been fixed by systemd v244 release. If you are running an older version\nof systemd, you can work around this by logging directly to journald, for example\nby using [go-systemd/journal](https://godoc.org/github.com/coreos/go-systemd/journal)\nand looking for the [$JOURNAL_STREAM](https://www.freedesktop.org/software/systemd/man/systemd.exec.html#$JOURNAL_STREAM)\nenvironment variable.\n"
        },
        {
          "name": "child.go",
          "type": "blob",
          "size": 2.5146484375,
          "content": "package tableflip\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype child struct {\n\t*env\n\tproc           process\n\treadyR, namesW *os.File\n\tready          <-chan *os.File\n\tresult         <-chan error\n\texited         <-chan struct{}\n}\n\nfunc startChild(env *env, passedFiles map[fileName]*file) (*child, error) {\n\t// These pipes are used for communication between parent and child\n\t// readyW is passed to the child, readyR stays with the parent\n\treadyR, readyW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pipe failed: %s\", err)\n\t}\n\n\tnamesR, namesW, err := os.Pipe()\n\tif err != nil {\n\t\treadyR.Close()\n\t\treadyW.Close()\n\t\treturn nil, fmt.Errorf(\"pipe failed: %s\", err)\n\t}\n\n\t// Copy passed fds and append the notification pipe\n\tfds := []*os.File{os.Stdin, os.Stdout, os.Stderr, readyW, namesR}\n\tvar fdNames [][]string\n\tfor name, file := range passedFiles {\n\t\tnameSlice := make([]string, len(name))\n\t\tcopy(nameSlice, name[:])\n\t\tfdNames = append(fdNames, nameSlice)\n\t\tfds = append(fds, file.File)\n\t}\n\n\t// Copy environment and append the notification env vars\n\tsentinel := fmt.Sprintf(\"%s=yes\", sentinelEnvVar)\n\tvar environ []string\n\tfor _, val := range env.environ() {\n\t\tif val != sentinel {\n\t\t\tenviron = append(environ, val)\n\t\t}\n\t}\n\tenviron = append(environ, sentinel)\n\n\tproc, err := env.newProc(os.Args[0], os.Args[1:], fds, environ)\n\tif err != nil {\n\t\treadyR.Close()\n\t\treadyW.Close()\n\t\tnamesR.Close()\n\t\tnamesW.Close()\n\t\treturn nil, fmt.Errorf(\"can't start process %s: %s\", os.Args[0], err)\n\t}\n\n\texited := make(chan struct{})\n\tresult := make(chan error, 1)\n\tready := make(chan *os.File, 1)\n\n\tc := &child{\n\t\tenv,\n\t\tproc,\n\t\treadyR,\n\t\tnamesW,\n\t\tready,\n\t\tresult,\n\t\texited,\n\t}\n\tgo c.writeNames(fdNames)\n\tgo c.waitExit(result, exited)\n\tgo c.waitReady(ready)\n\treturn c, nil\n}\n\nfunc (c *child) String() string {\n\treturn c.proc.String()\n}\n\nfunc (c *child) Kill() {\n\tc.proc.Signal(os.Kill)\n}\n\nfunc (c *child) waitExit(result chan<- error, exited chan<- struct{}) {\n\tresult <- c.proc.Wait()\n\tclose(exited)\n\t// Unblock waitReady and writeNames\n\tc.readyR.Close()\n\tc.namesW.Close()\n}\n\nfunc (c *child) waitReady(ready chan<- *os.File) {\n\tvar b [1]byte\n\tif n, _ := c.readyR.Read(b[:]); n > 0 && b[0] == notifyReady {\n\t\t// We know that writeNames has exited by this point.\n\t\t// Closing the FD now signals to the child that the parent\n\t\t// has exited.\n\t\tready <- c.namesW\n\t}\n\tc.readyR.Close()\n}\n\nfunc (c *child) writeNames(names [][]string) {\n\tenc := gob.NewEncoder(c.namesW)\n\tif names == nil {\n\t\t// Gob panics on nil\n\t\t_ = enc.Encode([][]string{})\n\t\treturn\n\t}\n\t_ = enc.Encode(names)\n}\n"
        },
        {
          "name": "child_test.go",
          "type": "blob",
          "size": 1.8427734375,
          "content": "package tableflip\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestChildExit(t *testing.T) {\n\tenv, procs := testEnv()\n\n\tchild, err := startChild(env, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\tproc.exit(nil)\n\tif err := <-child.result; err != nil {\n\t\tt.Error(\"Wait returns non-nil error:\", err)\n\t}\n}\n\nfunc TestChildKill(t *testing.T) {\n\tenv, procs := testEnv()\n\n\tchild, err := startChild(env, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\n\tgo child.Kill()\n\tif sig := proc.recvSignal(nil); sig != os.Kill {\n\t\tt.Errorf(\"Received %v instead of os.Kill\", sig)\n\t}\n\n\tproc.exit(nil)\n}\n\nfunc TestChildNotReady(t *testing.T) {\n\tenv, procs := testEnv()\n\n\tchild, err := startChild(env, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\tproc.exit(nil)\n\t<-child.result\n\t<-child.exited\n\n\tselect {\n\tcase <-child.ready:\n\t\tt.Error(\"Child signals readiness without pipe being closed\")\n\tdefault:\n\t}\n}\n\nfunc TestChildReady(t *testing.T) {\n\tenv, procs := testEnv()\n\n\tchild, err := startChild(env, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\tif _, _, err := proc.notify(); err != nil {\n\t\tt.Fatal(\"Can't notify:\", err)\n\t}\n\t<-child.ready\n\tproc.exit(nil)\n}\n\nfunc TestChildPassedFds(t *testing.T) {\n\tenv, procs := testEnv()\n\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tin := map[fileName]*file{\n\t\t{\"r\"}: newFile(r.Fd(), fileName{\"r\"}),\n\t\t{\"w\"}: newFile(w.Fd(), fileName{\"w\"}),\n\t}\n\n\tif _, err := startChild(env, in); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\tout, _, err := proc.notify()\n\tif err != nil {\n\t\tt.Fatal(\"Notify failed:\", err)\n\t}\n\n\tif len(out) != len(in) {\n\t\tt.Errorf(\"Expected %d files, got %d\", len(in), len(out))\n\t}\n\n\tfor name, inFd := range in {\n\t\tif outFd, ok := out[name]; !ok {\n\t\t\tt.Error(name, \"is missing\")\n\t\t} else if outFd.Fd() != inFd.Fd() {\n\t\t\tt.Error(name, \"fd mismatch:\", outFd.Fd(), inFd.Fd())\n\t\t}\n\t}\n\n\tproc.exit(nil)\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.86328125,
          "content": "// Package tableflip implements zero downtime upgrades.\n//\n// An upgrade spawns a new copy of argv[0] and passes\n// file descriptors of used listening sockets to the new process. The old process exits\n// once the new process signals readiness. Thus new code can use sockets allocated\n// in the old process. This is similar to the approach used by nginx, but\n// as a library.\n//\n// At any point in time there are one or two processes, with at most one of them\n// in non-ready state. A successful upgrade fully replaces all old configuration\n// and code.\n//\n// To use this library with systemd you need to use the PIDFile option in the service\n// file.\n//\n//    [Unit]\n//    Description=Service using tableflip\n//\n//    [Service]\n//    ExecStart=/path/to/binary -some-flag /path/to/pid-file\n//    ExecReload=/bin/kill -HUP $MAINPID\n//    PIDFile=/path/to/pid-file\n//\n// Then pass /path/to/pid-file to New. You can use systemd-run to\n// test your implementation:\n//\n//    systemd-run --user -p PIDFile=/path/to/pid-file /path/to/binary\n//\n// systemd-run will print a unit name, which you can use with systemctl to\n// inspect the service.\n//\n// NOTES:\n//\n// Requires at least Go 1.9, since there is a race condition on the\n// pipes used for communication between parent and child.\n//\n// If you're seeing \"can't start process: no such file or directory\",\n// you're probably using \"go run main.go\", for graceful reloads to work,\n// you'll need use \"go build main.go\".\n//\n// Tableflip does not work on Windows, because Windows does not have\n// the mechanisms required to support this method of graceful restarting.\n// It is still possible to include this package in code that runs on Windows,\n// which may be necessary in certain development circumstances, but it will not\n// provide zero downtime upgrades when running on Windows. See the `testing`\n// package for an example of how to use it.\n//\npackage tableflip\n"
        },
        {
          "name": "dup_fd.go",
          "type": "blob",
          "size": 0.34375,
          "content": "//go:build !windows\n// +build !windows\n\npackage tableflip\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\nfunc dupFd(fd uintptr, name fileName) (*file, error) {\n\tdupfd, _, errno := syscall.Syscall(syscall.SYS_FCNTL, fd, syscall.F_DUPFD_CLOEXEC, 0)\n\tif errno != 0 {\n\t\treturn nil, fmt.Errorf(\"can't dup fd using fcntl: %s\", errno)\n\t}\n\n\treturn newFile(dupfd, name), nil\n}\n"
        },
        {
          "name": "dup_fd_windows.go",
          "type": "blob",
          "size": 0.189453125,
          "content": "package tableflip\n\nimport \"errors\"\n\nfunc dupFd(fd uintptr, name fileName) (*file, error) {\n\treturn nil, errors.New(\"tableflip: duplicating file descriptors is not supported on this platform\")\n}\n"
        },
        {
          "name": "env.go",
          "type": "blob",
          "size": 0.265625,
          "content": "package tableflip\n\nimport (\n\t\"os\"\n)\n\ntype env struct {\n\tnewProc     func(string, []string, []*os.File, []string) (process, error)\n\tnewFile     func(fd uintptr, name string) *os.File\n\tenviron     func() []string\n\tgetenv      func(string) string\n\tcloseOnExec func(fd int)\n}\n"
        },
        {
          "name": "env_syscalls.go",
          "type": "blob",
          "size": 0.2431640625,
          "content": "//go:build !windows\n// +build !windows\n\npackage tableflip\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\nvar stdEnv = &env{\n\tnewProc:     newOSProcess,\n\tnewFile:     os.NewFile,\n\tenviron:     os.Environ,\n\tgetenv:      os.Getenv,\n\tcloseOnExec: syscall.CloseOnExec,\n}\n"
        },
        {
          "name": "env_test.go",
          "type": "blob",
          "size": 0.470703125,
          "content": "package tableflip\n\nimport (\n\t\"os\"\n)\n\nfunc testEnv() (*env, chan *testProcess) {\n\tprocs := make(chan *testProcess, 10)\n\treturn &env{\n\t\tnewProc: func(_ string, _ []string, files []*os.File, env []string) (process, error) {\n\t\t\tp, err := newTestProcess(files, env)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tprocs <- p\n\t\t\treturn p, nil\n\t\t},\n\t\tenviron:     func() []string { return nil },\n\t\tgetenv:      func(string) string { return \"\" },\n\t\tcloseOnExec: func(fd int) {},\n\t}, procs\n}\n"
        },
        {
          "name": "env_windows.go",
          "type": "blob",
          "size": 0.12109375,
          "content": "package tableflip\n\n// replace Unix-specific syscall with a no-op so it will build\n// without errors.\n\nvar stdEnv *env = nil\n"
        },
        {
          "name": "fds.go",
          "type": "blob",
          "size": 11.609375,
          "content": "package tableflip\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n)\n\n// Listener can be shared between processes.\ntype Listener interface {\n\tnet.Listener\n\tsyscall.Conn\n}\n\n// PacketConn can be shared between processes.\ntype PacketConn interface {\n\tnet.PacketConn\n\tsyscall.Conn\n}\n\n// Conn can be shared between processes.\ntype Conn interface {\n\tnet.Conn\n\tsyscall.Conn\n}\n\nconst (\n\tlistenKind = \"listener\"\n\tpacketKind = \"packet\"\n\tconnKind   = \"conn\"\n\tfdKind     = \"fd\"\n)\n\ntype fileName [3]string\n\nfunc (name fileName) String() string {\n\treturn strings.Join(name[:], \":\")\n}\n\nfunc (name fileName) isUnix() bool {\n\tif name[0] == listenKind && (name[1] == \"unix\" || name[1] == \"unixpacket\") {\n\t\treturn true\n\t}\n\tif name[0] == packetKind && (name[1] == \"unixgram\") {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// file works around the fact that it's not possible\n// to get the fd from an os.File without putting it into\n// blocking mode.\ntype file struct {\n\t*os.File\n\tfd uintptr\n}\n\nfunc newFile(fd uintptr, name fileName) *file {\n\tf := os.NewFile(fd, name.String())\n\tif f == nil {\n\t\treturn nil\n\t}\n\n\treturn &file{\n\t\tf,\n\t\tfd,\n\t}\n}\n\nfunc isPortDynamicallyAssigned(addr string) bool {\n\t// udp* and tcp* use the same resolver\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\t// anything that's not udp* tcp*\n\t\treturn false\n\t}\n\treturn udpAddr.Port == 0\n}\n\n// Fds holds all file descriptors inherited from the\n// parent process.\ntype Fds struct {\n\tmu        sync.Mutex\n\tinherited map[fileName]*file\n\tused      map[fileName]*file\n\tlc        *net.ListenConfig\n}\n\nfunc newFds(inherited map[fileName]*file, lc *net.ListenConfig) *Fds {\n\tif inherited == nil {\n\t\tinherited = make(map[fileName]*file)\n\t}\n\n\tif lc == nil {\n\t\tlc = &net.ListenConfig{}\n\t}\n\n\treturn &Fds{\n\t\tinherited: inherited,\n\t\tused:      make(map[fileName]*file),\n\t\tlc:        lc,\n\t}\n}\n\nfunc (f *Fds) newListener(network, addr string) (net.Listener, error) {\n\treturn f.lc.Listen(context.Background(), network, addr)\n}\n\n// Listen returns a listener inherited from the parent process, or creates a new one.\nfunc (f *Fds) Listen(network, addr string) (net.Listener, error) {\n\treturn f.ListenWithCallback(network, addr, f.newListener)\n}\n\n// ListenWithCallback returns a listener inherited from the parent process,\n// or calls the supplied callback to create a new one.\n//\n// This should be used in case some customization has to be applied to create the\n// connection. Note that the callback must not use the underlying `Fds` object\n// as it will be locked during the call.\nfunc (f *Fds) ListenWithCallback(network, addr string, callback func(network, addr string) (net.Listener, error)) (net.Listener, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tdynamicPort := isPortDynamicallyAssigned(addr)\n\tif !dynamicPort {\n\t\tln, err := f.listenerLocked(network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif ln != nil {\n\t\t\treturn ln, nil\n\t\t}\n\t}\n\tln, err := callback(network, addr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't create new listener: %s\", err)\n\t}\n\n\tif _, ok := ln.(Listener); !ok {\n\t\tln.Close()\n\t\treturn nil, fmt.Errorf(\"%T doesn't implement tableflip.Listener\", ln)\n\t}\n\n\tif dynamicPort {\n\t\t// Update addr to have the assigned port\n\t\taddr = ln.Addr().String()\n\t}\n\terr = f.addListenerLocked(network, addr, ln.(Listener))\n\tif err != nil {\n\t\tln.Close()\n\t\treturn nil, err\n\t}\n\n\treturn ln, nil\n}\n\n// Listener returns an inherited listener or nil.\n//\n// It is safe to close the returned listener.\nfunc (f *Fds) Listener(network, addr string) (net.Listener, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.listenerLocked(network, addr)\n}\n\nfunc (f *Fds) listenerLocked(network, addr string) (net.Listener, error) {\n\tkey := fileName{listenKind, network, addr}\n\tfile := f.inherited[key]\n\tif file == nil {\n\t\treturn nil, nil\n\t}\n\n\tln, err := net.FileListener(file.File)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't inherit listener %s %s: %s\", network, addr, err)\n\t}\n\n\tdelete(f.inherited, key)\n\tf.used[key] = file\n\treturn ln, nil\n}\n\n// AddListener adds a listener.\n//\n// It is safe to close ln after calling the method.\n// Any existing listener with the same address is overwitten.\nfunc (f *Fds) AddListener(network, addr string, ln Listener) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.addListenerLocked(network, addr, ln)\n}\n\ntype unlinkOnCloser interface {\n\tSetUnlinkOnClose(bool)\n}\n\nfunc (f *Fds) addListenerLocked(network, addr string, ln Listener) error {\n\tif ifc, ok := ln.(unlinkOnCloser); ok {\n\t\tifc.SetUnlinkOnClose(false)\n\t}\n\n\treturn f.addSyscallConnLocked(listenKind, network, addr, ln)\n}\n\nfunc (f *Fds) newPacketConn(network, addr string) (net.PacketConn, error) {\n\treturn f.lc.ListenPacket(context.Background(), network, addr)\n}\n\n// ListenPacket returns a packet conn inherited from the parent process, or creates a new one.\nfunc (f *Fds) ListenPacket(network, addr string) (net.PacketConn, error) {\n\treturn f.ListenPacketWithCallback(network, addr, f.newPacketConn)\n}\n\n// ListenPacketWithCallback returns a packet conn inherited from the parent process,\n// or calls the supplied callback to create a new one.\n//\n// This should be used in case some customization has to be applied to create the\n// connection. Note that the callback must not use the underlying `Fds` object\n// as it will be locked during the call.\nfunc (f *Fds) ListenPacketWithCallback(network, addr string, callback func(network, addr string) (net.PacketConn, error)) (net.PacketConn, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tdynamicPort := isPortDynamicallyAssigned(addr)\n\tif !dynamicPort {\n\t\tconn, err := f.packetConnLocked(network, addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif conn != nil {\n\t\t\treturn conn, nil\n\t\t}\n\t}\n\tconn, err := callback(network, addr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't create new listener: %s\", err)\n\t}\n\n\tif _, ok := conn.(PacketConn); !ok {\n\t\treturn nil, fmt.Errorf(\"%T doesn't implement tableflip.PacketConn\", conn)\n\t}\n\n\tif dynamicPort {\n\t\t// Update addr to have the assigned port\n\t\taddr = conn.LocalAddr().String()\n\t}\n\terr = f.addSyscallConnLocked(packetKind, network, addr, conn.(PacketConn))\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\n// PacketConn returns an inherited packet connection or nil.\n//\n// It is safe to close the returned packet connection.\nfunc (f *Fds) PacketConn(network, addr string) (net.PacketConn, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.packetConnLocked(network, addr)\n}\n\n// AddPacketConn adds a PacketConn.\n//\n// It is safe to close conn after calling the method.\n// Any existing packet connection with the same address is overwitten.\nfunc (f *Fds) AddPacketConn(network, addr string, conn PacketConn) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.addSyscallConnLocked(packetKind, network, addr, conn)\n}\n\nfunc (f *Fds) packetConnLocked(network, addr string) (net.PacketConn, error) {\n\tkey := fileName{packetKind, network, addr}\n\tfile := f.inherited[key]\n\tif file == nil {\n\t\treturn nil, nil\n\t}\n\n\tconn, err := net.FilePacketConn(file.File)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't inherit packet conn %s %s: %s\", network, addr, err)\n\t}\n\n\tdelete(f.inherited, key)\n\tf.used[key] = file\n\treturn conn, nil\n}\n\n// Conn returns an inherited connection or nil.\n//\n// It is safe to close the returned Conn.\nfunc (f *Fds) Conn(network, addr string) (net.Conn, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tkey := fileName{connKind, network, addr}\n\tfile := f.inherited[key]\n\tif file == nil {\n\t\treturn nil, nil\n\t}\n\n\tconn, err := net.FileConn(file.File)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't inherit connection %s %s: %s\", network, addr, err)\n\t}\n\n\tdelete(f.inherited, key)\n\tf.used[key] = file\n\treturn conn, nil\n}\n\n// AddConn adds a connection.\n//\n// It is safe to close conn after calling this method.\nfunc (f *Fds) AddConn(network, addr string, conn Conn) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.addSyscallConnLocked(connKind, network, addr, conn)\n}\n\nfunc (f *Fds) addSyscallConnLocked(kind, network, addr string, conn syscall.Conn) error {\n\tkey := fileName{kind, network, addr}\n\tfile, err := dupConn(conn, key)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't dup %s (%s %s): %s\", kind, network, addr, err)\n\t}\n\n\tdelete(f.inherited, key)\n\tf.used[key] = file\n\treturn nil\n}\n\n// Files returns all inherited files and mark them as used.\n//\n// The descriptors may be in blocking mode.\nfunc (f *Fds) Files() ([]*os.File, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tvar files []*os.File\n\n\tfor key, file := range f.inherited {\n\t\tif key[0] != fdKind {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Make a copy of the file, since we don't want to\n\t\t// allow the caller to invalidate fds in f.inherited.\n\t\tdup, err := dupFd(file.fd, key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tf.used[key] = file\n\t\tdelete(f.inherited, key)\n\n\t\tfiles = append(files, dup.File)\n\t}\n\n\treturn files, nil\n}\n\n// File returns an inherited file or nil.\n//\n// The descriptor may be in blocking mode.\nfunc (f *Fds) File(name string) (*os.File, error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tkey := fileName{fdKind, name}\n\tfile := f.inherited[key]\n\tif file == nil {\n\t\treturn nil, nil\n\t}\n\n\t// Make a copy of the file, since we don't want to\n\t// allow the caller to invalidate fds in f.inherited.\n\tdup, err := dupFd(file.fd, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdelete(f.inherited, key)\n\tf.used[key] = file\n\treturn dup.File, nil\n}\n\n// AddFile adds a file.\nfunc (f *Fds) AddFile(name string, file *os.File) error {\n\tkey := fileName{fdKind, name}\n\n\tdup, err := dupConn(file, key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tdelete(f.inherited, key)\n\tf.used[key] = dup\n\treturn nil\n}\n\nfunc (f *Fds) copy() map[fileName]*file {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfiles := make(map[fileName]*file, len(f.used))\n\tfor key, file := range f.used {\n\t\tfiles[key] = file\n\t}\n\n\treturn files\n}\n\nfunc (f *Fds) closeInherited() {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfor key, file := range f.inherited {\n\t\tif key.isUnix() {\n\t\t\t// Remove inherited but unused Unix sockets from the file system.\n\t\t\t// This undoes the effect of SetUnlinkOnClose(false).\n\t\t\t_ = unlinkUnixSocket(key[2])\n\t\t}\n\t\t_ = file.Close()\n\t}\n\tf.inherited = make(map[fileName]*file)\n}\n\nfunc unlinkUnixSocket(path string) error {\n\tif runtime.GOOS == \"linux\" && strings.HasPrefix(path, \"@\") {\n\t\t// Don't unlink sockets using the abstract namespace.\n\t\treturn nil\n\t}\n\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif info.Mode()&os.ModeSocket == 0 {\n\t\treturn nil\n\t}\n\n\treturn os.Remove(path)\n}\n\nfunc (f *Fds) closeUsed() {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfor _, file := range f.used {\n\t\t_ = file.Close()\n\t}\n\tf.used = make(map[fileName]*file)\n}\n\nfunc (f *Fds) closeAndRemoveUsed() {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfor key, file := range f.used {\n\t\tif key.isUnix() {\n\t\t\t// Remove used Unix Domain Sockets if we are shutting\n\t\t\t// down without having done an upgrade.\n\t\t\t// This undoes the effect of SetUnlinkOnClose(false).\n\t\t\t_ = unlinkUnixSocket(key[2])\n\t\t}\n\t\t_ = file.Close()\n\t}\n\tf.used = make(map[fileName]*file)\n}\n\nfunc dupConn(conn syscall.Conn, name fileName) (*file, error) {\n\t// Use SyscallConn instead of File to avoid making the original\n\t// fd non-blocking.\n\traw, err := conn.SyscallConn()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar dup *file\n\tvar duperr error\n\terr = raw.Control(func(fd uintptr) {\n\t\tdup, duperr = dupFd(fd, name)\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't access fd: %s\", err)\n\t}\n\treturn dup, duperr\n}\n\n// sysConnFd retrieves the fd for a syscall.Conn.\n//\n// Don't close the conn while using the fd.\nfunc sysConnFd(conn syscall.Conn) (uintptr, error) {\n\traw, err := conn.SyscallConn()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar fd uintptr\n\terr = raw.Control(func(fdArg uintptr) {\n\t\tfd = fdArg\n\t})\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"can't access fd: %s\", err)\n\t}\n\treturn fd, nil\n}\n"
        },
        {
          "name": "fds_test.go",
          "type": "blob",
          "size": 9.9326171875,
          "content": "package tableflip\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nfunc TestFdsAddListener(t *testing.T) {\n\tsocketPath, cleanup := tempSocket(t)\n\tdefer cleanup()\n\n\taddrs := [][2]string{\n\t\t{\"unix\", socketPath},\n\t\t{\"tcp\", \"localhost:0\"},\n\t}\n\n\tfds := newFds(nil, nil)\n\n\tfor _, addr := range addrs {\n\t\tln, err := net.Listen(addr[0], addr[1])\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := fds.AddListener(addr[0], addr[1], ln.(Listener)); err != nil {\n\t\t\tt.Fatalf(\"Can't add %s listener: %s\", addr[0], err)\n\t\t}\n\t\tln.Close()\n\t}\n}\n\nfunc TestFdsAddPacketConn(t *testing.T) {\n\tsocketPath, cleanup := tempSocket(t)\n\tdefer cleanup()\n\n\taddrs := [][2]string{\n\t\t{\"unix\", socketPath},\n\t\t{\"udp\", \"localhost:0\"},\n\t}\n\n\tfds := newFds(nil, nil)\n\tfor _, addr := range addrs {\n\t\tconn, err := net.ListenPacket(addr[0], addr[1])\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := fds.AddPacketConn(addr[0], addr[1], conn.(PacketConn)); err != nil {\n\t\t\tt.Fatalf(\"Can't add %s listener: %s\", addr[0], err)\n\t\t}\n\t\tconn.Close()\n\t}\n}\n\nfunc tempSocket(t *testing.T) (string, func()) {\n\tt.Helper()\n\n\ttemp, err := ioutil.TempDir(\"\", \"tableflip\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn filepath.Join(temp, \"socket\"), func() { os.RemoveAll(temp) }\n}\n\nfunc TestFdsListen(t *testing.T) {\n\tsocketPath, cleanup := tempSocket(t)\n\tdefer cleanup()\n\n\tactualAddrs := [][]string{}\n\taddrs := [][2]string{\n\t\t{\"tcp\", \"localhost:0\"},\n\t\t{\"udp\", \"localhost:0\"},\n\t\t{\"unix\", socketPath},\n\t\t{\"unixgram\", socketPath + \"Unixgram\"},\n\t}\n\n\t// Linux supports the abstract namespace for domain sockets.\n\tif runtime.GOOS == \"linux\" {\n\t\taddrs = append(addrs,\n\t\t\t[2]string{\"unixpacket\", socketPath + \"Unixpacket\"},\n\t\t\t[2]string{\"unix\", \"\"},\n\t\t\t[2]string{\"unixpacket\", \"\"},\n\t\t\t[2]string{\"unixgram\", \"\"},\n\t\t)\n\t}\n\n\tparent := newFds(nil, nil)\n\tfor _, addr := range addrs {\n\t\tswitch addr[0] {\n\t\tcase \"udp\", \"unixgram\":\n\t\t\tln, err := parent.ListenPacket(addr[0], addr[1])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Can't create %s listener: %s\", addr[0], err)\n\t\t\t}\n\t\t\tif ln == nil {\n\t\t\t\tt.Fatalf(\"Got a nil %s listener\", addr[0])\n\t\t\t}\n\t\t\tactualAddrs = append(actualAddrs, []string{addr[0], ln.LocalAddr().String()})\n\t\t\tln.Close()\n\t\tdefault:\n\t\t\tln, err := parent.Listen(addr[0], addr[1])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Can't create %s listener: %s\", addr[0], err)\n\t\t\t}\n\t\t\tif ln == nil {\n\t\t\t\tt.Fatalf(\"Got a nil %s listener\", addr[0])\n\t\t\t}\n\t\t\tactualAddrs = append(actualAddrs, []string{addr[0], ln.Addr().String()})\n\t\t\tln.Close()\n\t\t}\n\t}\n\n\tvar (\n\t\tln  io.Closer\n\t\terr error\n\t)\n\tchild := newFds(parent.copy(), nil)\n\tfor _, addr := range actualAddrs {\n\t\tswitch addr[0] {\n\t\tcase \"udp\", \"unixgram\":\n\t\t\tln, err = child.PacketConn(addr[0], addr[1])\n\t\tdefault:\n\t\t\tln, err = child.Listener(addr[0], addr[1])\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Can't get retrieve %s from child: %s\", addr[0], err)\n\t\t}\n\t\tif ln == nil {\n\t\t\tt.Fatalf(\"Missing %s listener\", addr[0])\n\t\t}\n\t\tln.Close()\n\t}\n}\n\nfunc TestFdsListenWithCallback(t *testing.T) {\n\tsocketPath, cleanup := tempSocket(t)\n\tdefer cleanup()\n\n\tactualAddrs := [][]string{}\n\taddrs := [][2]string{\n\t\t{\"tcp\", \"localhost:0\"},\n\t\t{\"udp\", \"localhost:0\"},\n\t\t{\"unix\", socketPath},\n\t\t{\"unixgram\", socketPath + \"Unixgram\"},\n\t}\n\tparent := newFds(nil, nil)\n\n\tcalled := false\n\tpacketCb := func(network, addr string) (net.PacketConn, error) {\n\t\tcalled = true\n\t\treturn net.ListenPacket(network, addr)\n\t}\n\tlistenerCb := func(network, addr string) (net.Listener, error) {\n\t\tcalled = true\n\t\treturn net.Listen(network, addr)\n\t}\n\n\tfor _, addr := range addrs {\n\t\tcalled = false\n\t\tswitch addr[0] {\n\t\tcase \"udp\", \"unixgram\":\n\t\t\tln, err := parent.ListenPacketWithCallback(addr[0], addr[1], packetCb)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Can't create %s listener: %s\", addr[0], err)\n\t\t\t}\n\t\t\tif ln == nil {\n\t\t\t\tt.Fatalf(\"Got a nil %s listener\", addr[0])\n\t\t\t}\n\t\t\tactualAddrs = append(actualAddrs, []string{addr[0], ln.LocalAddr().String()})\n\t\t\tln.Close()\n\t\tdefault:\n\t\t\tln, err := parent.ListenWithCallback(addr[0], addr[1], listenerCb)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Can't create %s listener: %s\", addr[0], err)\n\t\t\t}\n\t\t\tif ln == nil {\n\t\t\t\tt.Fatalf(\"Got a nil %s listener\", addr[0])\n\t\t\t}\n\t\t\tactualAddrs = append(actualAddrs, []string{addr[0], ln.Addr().String()})\n\t\t\tln.Close()\n\t\t}\n\t\tif !called {\n\t\t\tt.Fatalf(\"Callback not called for new %s listener\", addr[0])\n\t\t}\n\t}\n\n\tvar (\n\t\tln  io.Closer\n\t\terr error\n\t)\n\n\tchild := newFds(parent.copy(), nil)\n\tfor _, addr := range actualAddrs {\n\t\tcalled = false\n\t\tswitch addr[0] {\n\t\tcase \"udp\", \"unixgram\":\n\t\t\tln, err = child.ListenPacketWithCallback(addr[0], addr[1], packetCb)\n\t\tdefault:\n\t\t\tln, err = child.ListenWithCallback(addr[0], addr[1], listenerCb)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Can't get retrieve %s from child: %s\", addr[0], err)\n\t\t}\n\t\tif ln == nil {\n\t\t\tt.Fatalf(\"Missing %s listener\", addr[0])\n\t\t}\n\t\tif called {\n\t\t\tt.Fatalf(\"Callback called for inherited %s listener\", addr[0])\n\t\t}\n\t\tln.Close()\n\t}\n}\n\nfunc TestFdsListenPacketDynamicPort(t *testing.T) {\n\trequestedAddr := \"localhost:0\"\n\n\tparent := newFds(nil, nil)\n\tlistenDynamicPort := func() *net.UDPAddr {\n\t\tpacketListener, err := parent.ListenPacket(\"udp\", requestedAddr)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Can't create listener\")\n\t\t}\n\t\tif packetListener == nil {\n\t\t\tt.Fatal(\"Got a nil listener\")\n\t\t}\n\t\tlocalAddr := packetListener.LocalAddr().(*net.UDPAddr)\n\t\tpacketListener.Close()\n\t\treturn localAddr\n\t}\n\n\tlocalAddrs := []*net.UDPAddr{listenDynamicPort(), listenDynamicPort()}\n\tfor _, localAddr := range localAddrs {\n\t\tchild := newFds(parent.copy(), nil)\n\t\tpacketListener, err := child.ListenPacket(\"udp\", localAddr.String())\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Can't get retrieve %s from child: %s\", localAddr.String(), err)\n\t\t}\n\t\tif packetListener == nil {\n\t\t\tt.Fatalf(\"Missing %s listener\", localAddr.String())\n\t\t}\n\t\tpacketListener.Close()\n\t}\n}\n\nfunc TestFdsListenDynamicPort(t *testing.T) {\n\trequestedAddr := \"localhost:0\"\n\n\tparent := newFds(nil, nil)\n\tlistenDynamicPort := func() *net.TCPAddr {\n\t\tlistener, err := parent.Listen(\"tcp\", requestedAddr)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Can't create listener\")\n\t\t}\n\t\tif listener == nil {\n\t\t\tt.Fatal(\"Got a nil listener\")\n\t\t}\n\t\tlocalAddr := listener.Addr().(*net.TCPAddr)\n\t\tlistener.Close()\n\t\treturn localAddr\n\t}\n\n\tlocalAddrs := []*net.TCPAddr{listenDynamicPort(), listenDynamicPort()}\n\tfor _, localAddr := range localAddrs {\n\t\tchild := newFds(parent.copy(), nil)\n\t\tlistener, err := child.Listen(\"tcp\", localAddr.String())\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Can't get retrieve %s from child: %s\", localAddr.String(), err)\n\t\t}\n\t\tif listener == nil {\n\t\t\tt.Fatalf(\"Missing %s listener\", localAddr.String())\n\t\t}\n\t\tlistener.Close()\n\t}\n}\n\nfunc TestFdsRemoveUnix(t *testing.T) {\n\tsocketPath, cleanup := tempSocket(t)\n\tdefer cleanup()\n\n\taddrs := [][2]string{\n\t\t{\"unix\", socketPath},\n\t\t{\"unixgram\", socketPath + \"Unixgram\"},\n\t}\n\n\tif runtime.GOOS == \"linux\" {\n\t\taddrs = append(addrs,\n\t\t\t[2]string{\"unixpacket\", socketPath + \"Unixpacket\"},\n\t\t)\n\t}\n\n\tmakeFds := func(t *testing.T) *Fds {\n\t\tfds := newFds(nil, nil)\n\t\tfor _, addr := range addrs {\n\t\t\tvar c io.Closer\n\t\t\tvar err error\n\t\t\tif addr[0] == \"unixgram\" {\n\t\t\t\tc, err = fds.ListenPacket(addr[0], addr[1])\n\t\t\t} else {\n\t\t\t\tc, err = fds.Listen(addr[0], addr[1])\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Can't listen on socket %v: %v\", addr, err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\tif _, err := os.Stat(addr[1]); err != nil {\n\t\t\t\tt.Errorf(\"%s Close() unlinked socket: %s\", addr[0], err)\n\t\t\t}\n\t\t}\n\t\treturn fds\n\t}\n\n\tt.Run(\"closeAndRemoveUsed\", func(t *testing.T) {\n\t\tparent := makeFds(t)\n\t\tparent.closeAndRemoveUsed()\n\t\tfor _, addr := range addrs {\n\t\t\tif _, err := os.Stat(addr[1]); err == nil {\n\t\t\t\tt.Errorf(\"Used %s listeners are not removed\", addr[0])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"closeInherited\", func(t *testing.T) {\n\t\tparent := makeFds(t)\n\t\tchild := newFds(parent.copy(), nil)\n\t\tchild.closeInherited()\n\t\tfor _, addr := range addrs {\n\t\t\tif _, err := os.Stat(addr[1]); err == nil {\n\t\t\t\tt.Errorf(\"Inherited but unused %s listeners are not removed\", addr[0])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"closeUsed\", func(t *testing.T) {\n\t\tparent := makeFds(t)\n\t\tparent.closeUsed()\n\t\tfor _, addr := range addrs {\n\t\t\tif _, err := os.Stat(addr[1]); err != nil {\n\t\t\t\tt.Errorf(\"Used %s listeners are removed\", addr[0])\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestFdsConn(t *testing.T) {\n\tsocketPath, cleanup := tempSocket(t)\n\tdefer cleanup()\n\tunix, err := net.ListenUnixgram(\"unixgram\", &net.UnixAddr{\n\t\tNet:  \"unixgram\",\n\t\tName: socketPath,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tparent := newFds(nil, nil)\n\tif err := parent.AddConn(\"unixgram\", \"\", unix); err != nil {\n\t\tt.Fatal(\"Can't add conn:\", err)\n\t}\n\tunix.Close()\n\n\tchild := newFds(parent.copy(), nil)\n\tconn, err := child.Conn(\"unixgram\", \"\")\n\tif err != nil {\n\t\tt.Fatal(\"Can't get conn:\", err)\n\t}\n\tif conn == nil {\n\t\tt.Fatal(\"Missing conn\")\n\t}\n\tconn.Close()\n}\n\nfunc TestFdsFile(t *testing.T) {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tparent := newFds(nil, nil)\n\tif err := parent.AddFile(\"test\", w); err != nil {\n\t\tt.Fatal(\"Can't add file:\", err)\n\t}\n\tw.Close()\n\n\tchild := newFds(parent.copy(), nil)\n\tfile, err := child.File(\"test\")\n\tif err != nil {\n\t\tt.Fatal(\"Can't get file:\", err)\n\t}\n\tif file == nil {\n\t\tt.Fatal(\"Missing file\")\n\t}\n\tfile.Close()\n}\n\nfunc TestFdsFiles(t *testing.T) {\n\tr1, w1, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r1.Close()\n\n\tr2, w2, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r2.Close()\n\n\ttestcases := []struct {\n\t\tf        *os.File\n\t\tname     string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tw1,\n\t\t\t\"test1\",\n\t\t\t\"fd:test1:\",\n\t\t},\n\t\t{\n\t\t\tw2,\n\t\t\t\"test2\",\n\t\t\t\"fd:test2:\",\n\t\t},\n\t}\n\n\tparent := newFds(nil, nil)\n\tfor _, tc := range testcases {\n\t\tif err := parent.AddFile(tc.name, tc.f); err != nil {\n\t\t\tt.Fatal(\"Can't add file:\", err)\n\t\t}\n\t\ttc.f.Close()\n\t}\n\n\tchild := newFds(parent.copy(), nil)\n\tfiles, err := child.Files()\n\tif err != nil {\n\t\tt.Fatal(\"Can't get inherited files:\", err)\n\t}\n\n\tif len(files) != len(testcases) {\n\t\tt.Fatalf(\"Expected %d files, got %d\", len(testcases), len(files))\n\t}\n\n\tfor i, ff := range files {\n\t\ttc := testcases[i]\n\n\t\tif ff.Name() != tc.expected {\n\t\t\tt.Errorf(\"Expected file %q, got %q\", tc.expected, ff.Name())\n\t\t}\n\n\t\tff.Close()\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1064453125,
          "content": "module github.com/cloudflare/tableflip\n\ngo 1.14\n\nrequire golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.2021484375,
          "content": "golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4 h1:myAQVi0cGEoqQVR5POX+8RR2mrocKqNN1hmeMqhX27k=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n"
        },
        {
          "name": "http_example_test.go",
          "type": "blob",
          "size": 1.5419921875,
          "content": "package tableflip_test\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/cloudflare/tableflip\"\n)\n\n// This shows how to use the upgrader\n// with the graceful shutdown facilities of net/http.\nfunc Example_httpShutdown() {\n\tvar (\n\t\tlistenAddr = flag.String(\"listen\", \"localhost:8080\", \"`Address` to listen on\")\n\t\tpidFile    = flag.String(\"pid-file\", \"\", \"`Path` to pid file\")\n\t)\n\n\tflag.Parse()\n\tlog.SetPrefix(fmt.Sprintf(\"%d \", os.Getpid()))\n\n\tupg, err := tableflip.New(tableflip.Options{\n\t\tPIDFile: *pidFile,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer upg.Stop()\n\n\t// Do an upgrade on SIGHUP\n\tgo func() {\n\t\tsig := make(chan os.Signal, 1)\n\t\tsignal.Notify(sig, syscall.SIGHUP)\n\t\tfor range sig {\n\t\t\terr := upg.Upgrade()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Upgrade failed:\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Listen must be called before Ready\n\tln, err := upg.Listen(\"tcp\", *listenAddr)\n\tif err != nil {\n\t\tlog.Fatalln(\"Can't listen:\", err)\n\t}\n\n\tserver := http.Server{\n\t\t// Set timeouts, etc.\n\t}\n\n\tgo func() {\n\t\terr := server.Serve(ln)\n\t\tif err != http.ErrServerClosed {\n\t\t\tlog.Println(\"HTTP server:\", err)\n\t\t}\n\t}()\n\n\tlog.Printf(\"ready\")\n\tif err := upg.Ready(); err != nil {\n\t\tpanic(err)\n\t}\n\t<-upg.Exit()\n\n\t// Make sure to set a deadline on exiting the process\n\t// after upg.Exit() is closed. No new upgrades can be\n\t// performed if the parent doesn't exit.\n\ttime.AfterFunc(30*time.Second, func() {\n\t\tlog.Println(\"Graceful shutdown timed out\")\n\t\tos.Exit(1)\n\t})\n\n\t// Wait for connections to drain.\n\tserver.Shutdown(context.Background())\n}\n"
        },
        {
          "name": "parent.go",
          "type": "blob",
          "size": 1.5537109375,
          "content": "package tableflip\n\nimport (\n\t\"encoding/gob\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nconst (\n\tsentinelEnvVar = \"TABLEFLIP_HAS_PARENT_7DIU3\"\n\tnotifyReady    = 42\n)\n\ntype parent struct {\n\twr     *os.File\n\tresult <-chan error\n\texited <-chan struct{}\n}\n\nfunc newParent(env *env) (*parent, map[fileName]*file, error) {\n\tif env.getenv(sentinelEnvVar) == \"\" {\n\t\treturn nil, make(map[fileName]*file), nil\n\t}\n\n\twr := env.newFile(3, \"write\")\n\trd := env.newFile(4, \"read\")\n\n\tvar names [][]string\n\tdec := gob.NewDecoder(rd)\n\tif err := dec.Decode(&names); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"can't decode names from parent process: %s\", err)\n\t}\n\n\tfiles := make(map[fileName]*file)\n\tfor i, parts := range names {\n\t\tvar key fileName\n\t\tcopy(key[:], parts)\n\n\t\t// Start at 5 to account for stdin, etc. and write\n\t\t// and read pipes.\n\t\tfd := 5 + i\n\t\tenv.closeOnExec(fd)\n\t\tfiles[key] = &file{\n\t\t\tenv.newFile(uintptr(fd), key.String()),\n\t\t\tuintptr(fd),\n\t\t}\n\t}\n\n\tresult := make(chan error, 1)\n\texited := make(chan struct{})\n\tgo func() {\n\t\tdefer rd.Close()\n\n\t\tn, err := io.Copy(ioutil.Discard, rd)\n\t\tif n != 0 {\n\t\t\terr = errors.New(\"unexpected data from parent process\")\n\t\t} else if err != nil {\n\t\t\terr = fmt.Errorf(\"unexpected error while waiting for parent to exit: %s\", err)\n\t\t}\n\t\tresult <- err\n\t\tclose(exited)\n\t}()\n\n\treturn &parent{\n\t\twr:     wr,\n\t\tresult: result,\n\t\texited: exited,\n\t}, files, nil\n}\n\nfunc (ps *parent) sendReady() error {\n\tdefer ps.wr.Close()\n\tif _, err := ps.wr.Write([]byte{notifyReady}); err != nil {\n\t\treturn fmt.Errorf(\"can't notify parent process: %s\", err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "parent_test.go",
          "type": "blob",
          "size": 0.53515625,
          "content": "package tableflip\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParentExit(t *testing.T) {\n\tenv, procs := testEnv()\n\tchild, err := startChild(env, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\t_, exited, err := proc.notify()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treadyFile := <-child.ready\n\tif _, err = readyFile.Write([]byte{1}); err != nil {\n\t\tt.Fatal(\"Can't inject garbage from parent\")\n\t}\n\tif err := readyFile.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = <-exited\n\tif err == nil {\n\t\tt.Fatal(\"Expect child to detect garbage from parent\")\n\t}\n}\n"
        },
        {
          "name": "process.go",
          "type": "blob",
          "size": 1.423828125,
          "content": "package tableflip\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"syscall\"\n)\n\nvar initialWD, _ = os.Getwd()\n\ntype process interface {\n\tfmt.Stringer\n\tSignal(sig os.Signal) error\n\tWait() error\n}\n\ntype osProcess struct {\n\t*os.Process\n\tfinished bool\n}\n\nfunc newOSProcess(executable string, args []string, files []*os.File, env []string) (process, error) {\n\texecutable, err := exec.LookPath(executable)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfds := make([]uintptr, 0, len(files))\n\tfor _, file := range files {\n\t\tfd, err := sysConnFd(file)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfds = append(fds, fd)\n\t}\n\n\tattr := &syscall.ProcAttr{\n\t\tDir:   initialWD,\n\t\tEnv:   env,\n\t\tFiles: fds,\n\t}\n\n\targs = append([]string{executable}, args...)\n\tpid, _, err := syscall.StartProcess(executable, args, attr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fork/exec: %s\", err)\n\t}\n\n\t// Ensure that fds stay valid until after StartProcess finishes.\n\truntime.KeepAlive(files)\n\n\tproc, err := os.FindProcess(pid)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"find pid %d: %s\", pid, err)\n\t}\n\n\treturn &osProcess{Process: proc}, nil\n}\n\nfunc (osp *osProcess) Wait() error {\n\tif osp.finished {\n\t\treturn fmt.Errorf(\"already waited\")\n\t}\n\tosp.finished = true\n\n\tstate, err := osp.Process.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !state.Success() {\n\t\treturn &exec.ExitError{ProcessState: state}\n\t}\n\n\treturn nil\n}\n\nfunc (osp *osProcess) String() string {\n\treturn fmt.Sprintf(\"pid=%d\", osp.Pid)\n}\n"
        },
        {
          "name": "process_test.go",
          "type": "blob",
          "size": 3.384765625,
          "content": "package tableflip\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestFilesAreNonblocking(t *testing.T) {\n\tpipe := func() (r, w *os.File) {\n\t\tr, w, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Cleanup(func() {\n\t\t\tr.Close()\n\t\t\tw.Close()\n\t\t})\n\t\treturn r, w\n\t}\n\n\t// Set up our own blocking stdin since CI runs tests with stdin closed.\n\trStdin, _ := pipe()\n\trStdin.Fd()\n\n\tr, _ := pipe()\n\tif !isNonblock(t, r) {\n\t\tt.Fatal(\"Read pipe is blocking\")\n\t}\n\n\tproc, err := newOSProcess(\"cat\", nil, []*os.File{rStdin, os.Stdout, os.Stderr, r}, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := proc.Signal(os.Kill); err != nil {\n\t\tt.Fatal(\"Can't signal:\", err)\n\t}\n\n\tvar exitErr *exec.ExitError\n\tif err := proc.Wait(); !errors.As(err, &exitErr) {\n\t\tt.Fatalf(\"Wait should return an ExitError after sending os.Kill, have %T: %s\", err, err)\n\t}\n\n\tif err := proc.Wait(); err == nil {\n\t\tt.Fatal(\"Waiting a second time should return an error\")\n\t}\n\n\tif !isNonblock(t, r) {\n\t\tt.Fatal(\"Read pipe is blocking after newOSProcess\")\n\t}\n}\n\nfunc TestArgumentsArePassedCorrectly(t *testing.T) {\n\tproc, err := newOSProcess(\"printf\", []string{\"\"}, []*os.File{os.Stdin, os.Stdout, os.Stderr}, nil)\n\tif err != nil {\n\t\tt.Fatal(\"Can't execute printf:\", err)\n\t}\n\n\t// If the argument handling is wrong we'll call printf without any arguments.\n\t// In that case printf exits non-zero.\n\tif err = proc.Wait(); err != nil {\n\t\tt.Fatal(\"printf exited non-zero:\", err)\n\t}\n}\n\nfunc isNonblock(tb testing.TB, file *os.File) (nonblocking bool) {\n\ttb.Helper()\n\n\traw, err := file.SyscallConn()\n\tif err != nil {\n\t\ttb.Fatal(\"SyscallConn:\", err)\n\t}\n\n\terr = raw.Control(func(fd uintptr) {\n\t\tflags, err := unix.FcntlInt(fd, unix.F_GETFL, 0)\n\t\tif err != nil {\n\t\t\ttb.Fatal(\"IsNonblock:\", err)\n\t\t}\n\t\tnonblocking = flags&unix.O_NONBLOCK > 0\n\t})\n\tif err != nil {\n\t\ttb.Fatal(\"Control:\", err)\n\t}\n\treturn\n}\n\ntype testProcess struct {\n\tfds     []*os.File\n\tenv     env\n\tsignals chan os.Signal\n\tsigErr  chan error\n\twaitErr chan error\n\tquit    chan struct{}\n}\n\nfunc newTestProcess(fds []*os.File, envstr []string) (*testProcess, error) {\n\tenviron := make(map[string]string)\n\tfor _, entry := range envstr {\n\t\tparts := strings.SplitN(entry, \"=\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid env entry: %s\", entry)\n\t\t}\n\t\tenviron[parts[0]] = parts[1]\n\t}\n\n\treturn &testProcess{\n\t\tfds,\n\t\tenv{\n\t\t\tnewFile: func(fd uintptr, name string) *os.File {\n\t\t\t\treturn fds[fd]\n\t\t\t},\n\t\t\tgetenv: func(key string) string {\n\t\t\t\treturn environ[key]\n\t\t\t},\n\t\t\tcloseOnExec: func(int) {},\n\t\t},\n\t\tmake(chan os.Signal, 1),\n\t\tmake(chan error),\n\t\tmake(chan error),\n\t\tmake(chan struct{}),\n\t}, nil\n}\n\nfunc (tp *testProcess) Signal(sig os.Signal) error {\n\tselect {\n\tcase tp.signals <- sig:\n\t\treturn <-tp.sigErr\n\tcase <-tp.quit:\n\t\treturn nil\n\t}\n}\n\nfunc (tp *testProcess) Wait() error {\n\tselect {\n\tcase err := <-tp.waitErr:\n\t\treturn err\n\tcase <-tp.quit:\n\t\treturn nil\n\t}\n}\n\nfunc (tp *testProcess) String() string {\n\treturn fmt.Sprintf(\"tp=%p\", tp)\n}\n\nfunc (tp *testProcess) exit(err error) {\n\tselect {\n\tcase tp.waitErr <- err:\n\t\tclose(tp.quit)\n\tcase <-tp.quit:\n\t}\n}\n\nfunc (tp *testProcess) recvSignal(err error) os.Signal {\n\tsig := <-tp.signals\n\ttp.sigErr <- err\n\treturn sig\n}\n\nfunc (tp *testProcess) notify() (map[fileName]*file, <-chan error, error) {\n\tparent, files, err := newParent(&tp.env)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn files, parent.result, parent.sendReady()\n}\n"
        },
        {
          "name": "tcp_example_test.go",
          "type": "blob",
          "size": 1.3056640625,
          "content": "package tableflip_test\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/cloudflare/tableflip\"\n)\n\n// This shows how to use the Upgrader\n// with a listener based service.\nfunc Example_tcpServer() {\n\tvar (\n\t\tlistenAddr = flag.String(\"listen\", \"localhost:8080\", \"`Address` to listen on\")\n\t\tpidFile    = flag.String(\"pid-file\", \"\", \"`Path` to pid file\")\n\t)\n\n\tflag.Parse()\n\tlog.SetPrefix(fmt.Sprintf(\"%d \", os.Getpid()))\n\n\tupg, err := tableflip.New(tableflip.Options{\n\t\tPIDFile: *pidFile,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer upg.Stop()\n\n\t// Do an upgrade on SIGHUP\n\tgo func() {\n\t\tsig := make(chan os.Signal, 1)\n\t\tsignal.Notify(sig, syscall.SIGHUP)\n\t\tfor range sig {\n\t\t\terr := upg.Upgrade()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"upgrade failed:\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tln, err := upg.Fds.Listen(\"tcp\", *listenAddr)\n\tif err != nil {\n\t\tlog.Fatalln(\"Can't listen:\", err)\n\t}\n\n\tgo func() {\n\t\tdefer ln.Close()\n\n\t\tlog.Printf(\"listening on %s\", ln.Addr())\n\n\t\tfor {\n\t\t\tc, err := ln.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgo func() {\n\t\t\t\tc.SetDeadline(time.Now().Add(time.Second))\n\t\t\t\tc.Write([]byte(\"It is a mistake to think you can solve any major problems just with potatoes.\\n\"))\n\t\t\t\tc.Close()\n\t\t\t}()\n\t\t}\n\t}()\n\n\tlog.Printf(\"ready\")\n\tif err := upg.Ready(); err != nil {\n\t\tpanic(err)\n\t}\n\t<-upg.Exit()\n}\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "upgrader.go",
          "type": "blob",
          "size": 7.251953125,
          "content": "package tableflip\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n)\n\n// DefaultUpgradeTimeout is the duration before the Upgrader kills the new process if no\n// readiness notification was received.\nconst DefaultUpgradeTimeout time.Duration = time.Minute\n\n// Options control the behaviour of the Upgrader.\ntype Options struct {\n\t// Time after which an upgrade is considered failed. Defaults to\n\t// DefaultUpgradeTimeout.\n\tUpgradeTimeout time.Duration\n\t// The PID of a ready process is written to this file.\n\tPIDFile string\n\t// ListenConfig is a custom ListenConfig. Defaults to an empty ListenConfig\n\tListenConfig *net.ListenConfig\n}\n\n// Upgrader handles zero downtime upgrades and passing files between processes.\ntype Upgrader struct {\n\t*Fds\n\n\t*env\n\topts      Options\n\tparent    *parent\n\tparentErr chan error\n\treadyOnce sync.Once\n\treadyC    chan struct{}\n\tstopOnce  sync.Once\n\tstopC     chan struct{}\n\tupgradeC  chan chan<- error\n\texitC     chan struct{}\n\texitFd    chan neverCloseThisFile\n}\n\nvar (\n\tstdEnvMu       sync.Mutex\n\tstdEnvUpgrader *Upgrader\n)\n\nvar ErrNotSupported = errors.New(\"tableflip: platform does not support graceful restart\")\n\n// New creates a new Upgrader. Files are passed from the parent and may be empty.\n//\n// Only the first call to this function will succeed. May return ErrNotSupported.\nfunc New(opts Options) (upg *Upgrader, err error) {\n\tstdEnvMu.Lock()\n\tdefer stdEnvMu.Unlock()\n\n\tif !isSupportedOS() {\n\t\treturn nil, fmt.Errorf(\"%w\", ErrNotSupported)\n\t}\n\n\tif stdEnvUpgrader != nil {\n\t\treturn nil, errors.New(\"tableflip: only a single Upgrader allowed\")\n\t}\n\n\tupg, err = newUpgrader(stdEnv, opts)\n\t// Store a reference to upg in a private global variable, to prevent\n\t// it from being GC'ed and exitFd being closed prematurely.\n\tstdEnvUpgrader = upg\n\treturn\n}\n\nfunc newUpgrader(env *env, opts Options) (*Upgrader, error) {\n\tif initialWD == \"\" {\n\t\treturn nil, errors.New(\"couldn't determine initial working directory\")\n\t}\n\n\tparent, files, err := newParent(env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif opts.UpgradeTimeout <= 0 {\n\t\topts.UpgradeTimeout = DefaultUpgradeTimeout\n\t}\n\n\tu := &Upgrader{\n\t\tenv:       env,\n\t\topts:      opts,\n\t\tparent:    parent,\n\t\tparentErr: make(chan error, 1),\n\t\treadyC:    make(chan struct{}),\n\t\tstopC:     make(chan struct{}),\n\t\tupgradeC:  make(chan chan<- error),\n\t\texitC:     make(chan struct{}),\n\t\texitFd:    make(chan neverCloseThisFile, 1),\n\t\tFds:       newFds(files, opts.ListenConfig),\n\t}\n\n\tgo u.run()\n\n\treturn u, nil\n}\n\n// Ready signals that the current process is ready to accept connections.\n// It must be called to finish the upgrade.\n//\n// All fds which were inherited but not used are closed after the call to Ready.\nfunc (u *Upgrader) Ready() error {\n\tu.readyOnce.Do(func() {\n\t\tu.Fds.closeInherited()\n\t\tclose(u.readyC)\n\t})\n\n\tif u.opts.PIDFile != \"\" {\n\t\tif err := writePIDFile(u.opts.PIDFile); err != nil {\n\t\t\treturn fmt.Errorf(\"tableflip: can't write PID file: %s\", err)\n\t\t}\n\t}\n\n\tif u.parent == nil {\n\t\treturn nil\n\t}\n\treturn u.parent.sendReady()\n}\n\n// Exit returns a channel which is closed when the process should\n// exit.\nfunc (u *Upgrader) Exit() <-chan struct{} {\n\treturn u.exitC\n}\n\n// Stop prevents any more upgrades from happening, and closes\n// the exit channel.\n//\n// If this function is called before a call to Upgrade() has\n// succeeded, it is assumed that the process is being shut down\n// completely. All Unix sockets known to Upgrader.Fds are then\n// unlinked from the filesystem.\nfunc (u *Upgrader) Stop() {\n\tu.stopOnce.Do(func() {\n\t\t// Interrupt any running Upgrade(), and\n\t\t// prevent new upgrade from happening.\n\t\tclose(u.stopC)\n\t})\n}\n\n// WaitForParent blocks until the parent has exited.\n//\n// Returns an error if the parent misbehaved during shutdown.\nfunc (u *Upgrader) WaitForParent(ctx context.Context) error {\n\tif u.parent == nil {\n\t\treturn nil\n\t}\n\n\tvar err error\n\tselect {\n\tcase err = <-u.parent.result:\n\tcase err = <-u.parentErr:\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n\n\t// This is a bit cheeky, since it means that multiple\n\t// calls to WaitForParent resolve in sequence, but that\n\t// probably doesn't matter.\n\tu.parentErr <- err\n\treturn err\n}\n\n// HasParent checks if the current process is an upgrade or the first invocation.\nfunc (u *Upgrader) HasParent() bool {\n\treturn u.parent != nil\n}\n\n// Upgrade triggers an upgrade.\nfunc (u *Upgrader) Upgrade() error {\n\tresponse := make(chan error, 1)\n\tselect {\n\tcase <-u.stopC:\n\t\treturn errors.New(\"terminating\")\n\tcase <-u.exitC:\n\t\treturn errors.New(\"already upgraded\")\n\tcase u.upgradeC <- response:\n\t}\n\n\treturn <-response\n}\n\nvar errNotReady = errors.New(\"process is not ready yet\")\n\nfunc (u *Upgrader) run() {\n\tdefer close(u.exitC)\n\n\tvar (\n\t\tparentExited <-chan struct{}\n\t\tprocessReady = u.readyC\n\t)\n\n\tif u.parent != nil {\n\t\tparentExited = u.parent.exited\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-parentExited:\n\t\t\tparentExited = nil\n\n\t\tcase <-processReady:\n\t\t\tprocessReady = nil\n\n\t\tcase <-u.stopC:\n\t\t\tu.Fds.closeAndRemoveUsed()\n\t\t\treturn\n\n\t\tcase request := <-u.upgradeC:\n\t\t\tif processReady != nil {\n\t\t\t\trequest <- errNotReady\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif parentExited != nil {\n\t\t\t\trequest <- errors.New(\"parent hasn't exited\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfile, err := u.doUpgrade()\n\t\t\trequest <- err\n\n\t\t\tif err == nil {\n\t\t\t\t// Save file in exitFd, so that it's only closed when the process\n\t\t\t\t// exits. This signals to the new process that the old process\n\t\t\t\t// has exited.\n\t\t\t\tu.exitFd <- neverCloseThisFile{file}\n\t\t\t\tu.Fds.closeUsed()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (u *Upgrader) doUpgrade() (*os.File, error) {\n\tchild, err := startChild(u.env, u.Fds.copy())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't start child: %s\", err)\n\t}\n\n\treadyTimeout := time.After(u.opts.UpgradeTimeout)\n\tfor {\n\t\tselect {\n\t\tcase request := <-u.upgradeC:\n\t\t\trequest <- errors.New(\"upgrade in progress\")\n\n\t\tcase err := <-child.result:\n\t\t\tif err == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"child %s exited\", child)\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"child %s exited: %s\", child, err)\n\n\t\tcase <-u.stopC:\n\t\t\tchild.Kill()\n\t\t\treturn nil, errors.New(\"terminating\")\n\n\t\tcase <-readyTimeout:\n\t\t\tchild.Kill()\n\t\t\treturn nil, fmt.Errorf(\"new child %s timed out\", child)\n\n\t\tcase file := <-child.ready:\n\t\t\treturn file, nil\n\t\t}\n\t}\n}\n\n// This file must never be closed by the Go runtime, since its used by the\n// child to determine when the parent has died. It must only be closed\n// by the OS.\n// Hence we make sure that this file can't be garbage collected by referencing\n// it from an Upgrader.\ntype neverCloseThisFile struct {\n\tfile *os.File\n}\n\nfunc writePIDFile(path string) error {\n\tdir, file := filepath.Split(path)\n\n\t// if dir is empty, the user probably specified just the name\n\t// of the pid file expecting it to be created in the current work directory\n\tif dir == \"\" {\n\t\tdir = initialWD\n\t}\n\n\tif dir == \"\" {\n\t\treturn errors.New(\"empty initial working directory\")\n\t}\n\n\tfh, err := ioutil.TempFile(dir, file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fh.Close()\n\t// Remove temporary PID file if something fails\n\tdefer os.Remove(fh.Name())\n\n\t_, err = fh.WriteString(strconv.Itoa(os.Getpid()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn os.Rename(fh.Name(), path)\n}\n\n// Check if this is a supported OS.\n// That is currently all Unix-like OS's.\n// At the moment, we assume that is everything except Windows.\nfunc isSupportedOS() bool {\n\treturn runtime.GOOS != \"windows\"\n}\n"
        },
        {
          "name": "upgrader_test.go",
          "type": "blob",
          "size": 9.7861328125,
          "content": "package tableflip\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/gob\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype testUpgrader struct {\n\t*Upgrader\n\tprocs chan *testProcess\n}\n\nfunc newTestUpgrader(opts Options) *testUpgrader {\n\tenv, procs := testEnv()\n\tu, err := newUpgrader(env, opts)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = u.Ready()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &testUpgrader{\n\t\tUpgrader: u,\n\t\tprocs:    procs,\n\t}\n}\n\nfunc (tu *testUpgrader) upgradeProc(t *testing.T) (*testProcess, <-chan error) {\n\tt.Helper()\n\n\tch := make(chan error, 1)\n\tgo func() {\n\t\tfor {\n\t\t\terr := tu.Upgrade()\n\t\t\tif err != errNotReady {\n\t\t\t\tch <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase err := <-ch:\n\t\tt.Fatal(\"Upgrade failed:\", err)\n\t\treturn nil, nil\n\n\tcase proc := <-tu.procs:\n\t\treturn proc, ch\n\t}\n}\n\nvar names = []string{\"zaphod\", \"beeblebrox\"}\n\nfunc TestMain(m *testing.M) {\n\tupg, err := New(Options{})\n\tif errors.Is(err, ErrNotSupported) {\n\t\tfmt.Fprintln(os.Stderr, \"Skipping tests, OS is not supported\")\n\t\tos.Exit(0)\n\t}\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif upg.parent == nil {\n\t\t// Execute test suite if there is no parent.\n\t\tos.Exit(m.Run())\n\t}\n\n\tif err := childProcess(upg); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error: %s\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\ntype childState struct {\n\tPID int\n}\n\n// Used by Benchmark and TestUpgraderOnOS\nfunc childProcess(upg *Upgrader) error {\n\tif !upg.HasParent() {\n\t\treturn errors.New(\"Upgrader doesn't recognize parent\")\n\t}\n\n\twState, err := upg.Fds.File(\"wState\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif wState != nil {\n\t\tstate := &childState{\n\t\t\tPID: os.Getpid(),\n\t\t}\n\t\tif err := gob.NewEncoder(wState).Encode(state); err != nil {\n\t\t\treturn err\n\t\t}\n\t\twState.Close()\n\t}\n\n\tfor _, name := range names {\n\t\tfile, err := upg.Fds.File(name)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"can't get file %s: %s\", name, err)\n\t\t}\n\t\tif file == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, err := io.WriteString(file, name); err != nil {\n\t\t\treturn fmt.Errorf(\"can't write to %s: %s\", name, err)\n\t\t}\n\t\tfile.Close()\n\t}\n\n\trExit, err := upg.Fds.File(\"rExit\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Ready closes all inherited but unused files.\n\tif err := upg.Ready(); err != nil {\n\t\treturn fmt.Errorf(\"can't signal ready: %s\", err)\n\t}\n\n\t// Block until the parent is done with us. Returning an\n\t// error here won't make the parent fail, so don't bother.\n\tif rExit != nil {\n\t\tvar b [1]byte\n\t\trExit.Read(b[:])\n\t}\n\n\treturn nil\n}\n\nfunc TestUpgraderOnOS(t *testing.T) {\n\tu, err := newUpgrader(stdEnv, Options{})\n\tif err != nil {\n\t\tt.Fatal(\"Can't create Upgrader:\", err)\n\t}\n\tdefer u.Stop()\n\n\tpipe := func() (r, w *os.File) {\n\t\tt.Helper()\n\n\t\tr, w, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn r, w\n\t}\n\n\taddPipe := func(name string, file *os.File) {\n\t\tt.Helper()\n\n\t\tif err := u.Fds.AddFile(name, file); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfile.Close()\n\t}\n\n\trState, wState := pipe()\n\tdefer rState.Close()\n\n\taddPipe(\"wState\", wState)\n\n\trExit, wExit := pipe()\n\tdefer wExit.Close()\n\n\taddPipe(\"rExit\", rExit)\n\n\tvar readers []*os.File\n\tdefer func() {\n\t\tfor _, r := range readers {\n\t\t\tr.Close()\n\t\t}\n\t}()\n\n\tfor _, name := range names {\n\t\tr, w := pipe()\n\t\taddPipe(name, w)\n\t\treaders = append(readers, r)\n\t}\n\n\tif err := u.Upgrade(); err == nil {\n\t\tt.Error(\"Upgrade before Ready should return an error\")\n\t}\n\n\tif err := u.Ready(); err != nil {\n\t\tt.Fatal(\"Ready failed:\", err)\n\t}\n\n\tfor {\n\t\tif err := u.Upgrade(); err == nil {\n\t\t\tbreak\n\t\t} else if err != errNotReady {\n\t\t\tt.Fatal(\"Upgrade failed:\", err)\n\t\t}\n\t}\n\n\t// Tell child it's OK to exit now.\n\twExit.Close()\n\n\t// Close copies of write pipes, so that\n\t// reads below return EOF.\n\tu.Stop()\n\n\tvar state childState\n\tif err := gob.NewDecoder(rState).Decode(&state); err != nil {\n\t\tt.Fatal(\"Can't decode state from child:\", err)\n\t}\n\n\tif state.PID == os.Getpid() {\n\t\tt.Error(\"Child did not execute in new process\")\n\t}\n\n\tfor i, name := range names {\n\t\tnameBytes, err := ioutil.ReadAll(readers[i])\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(nameBytes, []byte(name)) {\n\t\t\tt.Fatalf(\"File %s has name %s in child\", name, string(nameBytes))\n\t\t}\n\t}\n}\n\nfunc TestUpgraderCleanExit(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{})\n\tdefer u.Stop()\n\n\tproc, errs := u.upgradeProc(t)\n\n\tproc.exit(nil)\n\tif err := <-errs; err == nil {\n\t\tt.Error(\"Expected Upgrade to return error when new child exits clean\")\n\t}\n}\n\nfunc TestUpgraderUncleanExit(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{})\n\tdefer u.Stop()\n\n\tproc, errs := u.upgradeProc(t)\n\n\tproc.exit(errors.New(\"some error\"))\n\tif err := <-errs; err == nil {\n\t\tt.Error(\"Expected Upgrade to return error when new child exits unclean\")\n\t}\n}\n\nfunc TestUpgraderTimeout(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{\n\t\tUpgradeTimeout: 10 * time.Millisecond,\n\t})\n\tdefer u.Stop()\n\n\tnew, errs := u.upgradeProc(t)\n\n\tif sig := new.recvSignal(nil); sig != os.Kill {\n\t\tt.Error(\"Expected os.Kill, got\", sig)\n\t}\n\n\tif err := <-errs; err == nil {\n\t\tt.Error(\"Expected Upgrade to return error when new child times out\")\n\t}\n}\n\nfunc TestUpgraderListenConfig(t *testing.T) {\n\tt.Parallel()\n\n\tvar listenConfigUsed bool\n\tu := newTestUpgrader(Options{\n\t\tListenConfig: &net.ListenConfig{\n\t\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t\t\tlistenConfigUsed = true\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t})\n\tdefer u.Stop()\n\n\tnew, _ := u.upgradeProc(t)\n\n\tgo new.recvSignal(nil)\n\n\t_, err := u.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error from listen: %v\", err)\n\t}\n\n\tif !listenConfigUsed {\n\t\tt.Error(\"Expected ListenConfig to be called during Listen\")\n\t}\n\n\tnew.exit(nil)\n}\n\nfunc TestUpgraderConcurrentUpgrade(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{})\n\tdefer u.Stop()\n\n\tnew, _ := u.upgradeProc(t)\n\n\tgo new.recvSignal(nil)\n\n\tif err := u.Upgrade(); err == nil {\n\t\tt.Error(\"Expected Upgrade to refuse concurrent upgrade\")\n\t}\n\n\tnew.exit(nil)\n}\n\nfunc TestHasParent(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{})\n\tdefer u.Stop()\n\n\tif u.HasParent() {\n\t\tt.Fatal(\"First process cannot have a parent\")\n\t}\n}\n\nfunc TestUpgraderWaitForParent(t *testing.T) {\n\tt.Parallel()\n\n\tenv, procs := testEnv()\n\tchild, err := startChild(env, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproc := <-procs\n\tu, err := newUpgrader(&proc.env, Options{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer u.Stop()\n\n\tif err := u.Ready(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texited := make(chan error, 1)\n\tgo func() {\n\t\texited <- u.WaitForParent(context.Background())\n\t}()\n\n\tselect {\n\tcase <-exited:\n\t\tt.Fatal(\"Returned before parent exited\")\n\tcase <-time.After(time.Second):\n\t}\n\n\treadyFile := <-child.ready\n\tif err := readyFile.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := <-exited; err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n}\n\nfunc TestUpgraderReady(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{})\n\tdefer u.Stop()\n\n\tnew, errs := u.upgradeProc(t)\n\n\t_, exited, err := new.notify()\n\tif err != nil {\n\t\tt.Fatal(\"Can't notify Upgrader:\", err)\n\t}\n\n\tif err := <-errs; err != nil {\n\t\tt.Fatal(\"Expected Upgrade to return nil when child is ready\")\n\t}\n\n\tselect {\n\tcase <-u.Exit():\n\tdefault:\n\t\tt.Error(\"Expected Exit() to be closed when upgrade is done\")\n\t}\n\n\t// Simulate the process exiting\n\tfile := <-u.exitFd\n\tfile.file.Close()\n\n\tselect {\n\tcase err := <-exited:\n\t\tif err != nil {\n\t\t\tt.Error(\"exit error\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Error(\"Child wasn't notified of parent exiting\")\n\t}\n}\n\nfunc TestUpgraderShutdownCancelsUpgrade(t *testing.T) {\n\tt.Parallel()\n\n\tu := newTestUpgrader(Options{})\n\tdefer u.Stop()\n\n\tnew, errs := u.upgradeProc(t)\n\n\tgo new.recvSignal(nil)\n\n\tu.Stop()\n\tif err := <-errs; err == nil {\n\t\tt.Error(\"Upgrade doesn't return an error when Stopp()ed\")\n\t}\n\n\tif err := u.Upgrade(); err == nil {\n\t\tt.Error(\"Upgrade doesn't return an error after Stop()\")\n\t}\n}\n\nfunc TestReadyWritesPIDFile(t *testing.T) {\n\tt.Parallel()\n\n\tdir, err := ioutil.TempDir(\"\", \"tableflip\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dir)\n\n\tfile := dir + \"/pid\"\n\tu := newTestUpgrader(Options{\n\t\tPIDFile: file,\n\t})\n\tdefer u.Stop()\n\n\tif err := u.Ready(); err != nil {\n\t\tt.Fatal(\"Ready returned error:\", err)\n\t}\n\n\tfh, err := os.Open(file)\n\tif err != nil {\n\t\tt.Fatal(\"PID file doesn't exist:\", err)\n\t}\n\tdefer fh.Close()\n\n\tvar pid int\n\tif _, err := fmt.Fscan(fh, &pid); err != nil {\n\t\tt.Fatal(\"Can't read PID:\", err)\n\t}\n\n\tif pid != os.Getpid() {\n\t\tt.Error(\"PID doesn't match\")\n\t}\n}\n\nfunc TestWritePidFileWithoutPath(t *testing.T) {\n\tpidFile := \"tableflip-test.pid\"\n\n\terr := writePIDFile(pidFile)\n\tif err != nil {\n\t\tt.Fatal(\"Could not write pidfile:\", err)\n\t}\n\tdefer os.Remove(pidFile)\n\n\t// lets see if we are able to read the file back\n\tfh, err := os.Open(pidFile)\n\tif err != nil {\n\t\tt.Fatal(\"PID file doesn't exist:\", err)\n\t}\n\tdefer fh.Close()\n\n\t// just to be sure: check the pid for correctness\n\t// if something failed at a previous run we could be reading\n\t// a bogus pidfile\n\tvar pid int\n\tif _, err := fmt.Fscan(fh, &pid); err != nil {\n\t\tt.Fatal(\"Can't read PID:\", err)\n\t}\n\n\tif pid != os.Getpid() {\n\t\tt.Error(\"PID doesn't match\")\n\t}\n}\n\nfunc BenchmarkUpgrade(b *testing.B) {\n\tfor _, n := range []int{4, 400, 4000} {\n\t\tb.Run(fmt.Sprintf(\"n=%d\", n), func(b *testing.B) {\n\t\t\tfds := newFds(nil, nil)\n\t\t\tfor i := 0; i < n; i += 2 {\n\t\t\t\tr, w, err := os.Pipe()\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\terr = fds.AddFile(strconv.Itoa(n), r)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t\tr.Close()\n\n\t\t\t\terr = fds.AddFile(strconv.Itoa(n), w)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t\tw.Close()\n\t\t\t}\n\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tu, err := newUpgrader(stdEnv, Options{})\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(\"Can't create Upgrader:\", err)\n\t\t\t\t}\n\t\t\t\tif err := u.Ready(); err != nil {\n\t\t\t\t\tb.Fatal(\"Can't call Ready:\", err)\n\t\t\t\t}\n\n\t\t\t\tu.Fds = fds\n\t\t\t\tif err := u.Upgrade(); err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.StopTimer()\n\n\t\t\tfor _, f := range fds.used {\n\t\t\t\tf.Close()\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}