{
  "metadata": {
    "timestamp": 1736568961053,
    "page": 12,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjE4",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nvie/gitflow",
      "stars": 26712,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.064453125,
          "content": "debian/files\ndebian/*.substvars\ndebian/*.debhelper.log\ndebian/*/*\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0771484375,
          "content": "[submodule \"shFlags\"]\n\tpath = shFlags\n\turl = git://github.com/nvie/shFlags.git\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.4560546875,
          "content": "Authors are (ordered by first commit date):\n\n- Vincent Driessen\n- Benedikt Böhm\n- Daniel Truemper\n- Jason L. Shiffer\n- Randy Merrill\n- Rick Osborne\n- Mark Derricutt\n- Nowell Strite\n- Felipe Talavera\n- Guillaume-Jean Herbiet\n- Joseph A. Levin\n- Jannis Leidel\n- Konstantin Tjuterev\n- Kiall Mac Innes\n- Jon Bernard\n- Olivier Mengué\n- Emre Berge Ergenekon\n- Eric Holmes\n- Vedang Manerikar\n- Myke Hines\n\nPortions derived from other open source works are clearly marked.\n"
        },
        {
          "name": "Changes.mdown",
          "type": "blob",
          "size": 3.099609375,
          "content": "0.4.2:\n-----\nRelease date: **not yet**\n\n* `git flow init` now detects situations where origin already has gitflow\n  branches set up, and behaves accordingly (thanks Emre Berge Ergenekon).\n\n* `git flow feature finish` can now be called without a feature branch\n  name(prefix) argument and will finish the current branch, if on any.\n\n* `git flow feature pull` now has a `-r` flag, to support `pull --rebase`\n  semantics (thanks Vedang Manerikar).\n\n* Various minor bug fixes related to internal argument passing.\n\n* Improved some documentation.\n\n* Better support for Windows and BSD users.\n\n* Add package installer for the Windows platform.\n\n0.4.1:\n-----\nRelease date: **2011/02/04**\n\n* New option `-d` added to `git flow init`, to initialize with defaults without\n  asking for input interactively.  Ideal for creating git-flow enabled repos in\n  custom scripts.\n\n* The parsing issues related to git-flow feature's flags are now dealt with on\n  all known platforms.  (Fixed #54, #62, #86, #97)\n\n* Escape queries for detecting branch/tag names.  (Fixed #91) \n\n\n0.4:\n---\nRelease date: **2010/10/18**\n\n* The flag parsing issues of git-flow subcommands are solved for most\n  platforms.\n\n* `git flow {feature,hotfix,release} finish` now takes a `-k` flag, to keep the\n  branch around after finishing.\n\n* `git flow release finish` takes a `-n` flag, to skip tagging.\n\n* For consistency, `git flow {release,hotfix}` now, too, have a `publish` and\n  `track` subcommand, just like `feature`.\n\n* Various minor fixes.\n\n\n0.3:\n----\nRelease date: **2010/07/22**\n\n* New subcommands for `git flow feature`:  \n  - **checkout**:  \n    For easily checking out features by their short name.  Even allows\n    unique prefixes as arguments (see below).\n\n  - **pull**:  \n    This subcommand allows you to painlessly work on a feature branch\n    together with another peer.  This is especially valuable for doing\n    peer reviews of other people's code.  For more detailed info, see the\n    [commit log][1].\n\n* Easier addressing of branch names by using name prefixes.  \n  For example, when using:  \n  \n  \tgit flow feature finish fo\n  \n  this automatically finishes the feature branch `foobar` if that's the only\n  feature branch name starting with `fo`.\n\n* No force flag anymore for new feature branches  \n  `git flow feature start` lost its `-f` (force) flag.  You now don't\n  have to be in a clean repo anymore to start a new feature branch. This\n  avoids the manual `git stash`, `git flow feature start`, `git stash\n  pop` cycle.\n\n* You can use `git-flow` in stand-alone repo's now.  \n  This means it does not assume you have an `origin` repository.\n  (Thanks [Mark][2].)\n\n* No commands fetch from `origin` by default anymore.  \n  There were some issues related to disabling this flag on some platforms.\n\n* Init guesses branch names you may want to use for `develop` and `master`.\n\n* Added super-easy installation script. (Thanks [Rick][3].)\n\n* Added BSD license.\n\n[1]: http://github.com/nvie/gitflow/commit/f68d405cc3a11e9df3671f567658a6ab6ed8e0a1\n[2]: http://github.com/talios\n[3]: http://github.com/rickosborne\n\n\nOlder versions\n--------------\nNo change history is recorded for pre-0.3 releases.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.466796875,
          "content": "Copyright 2010 Vincent Driessen. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n   1. Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\nSHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of Vincent Driessen.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.24609375,
          "content": "#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\nprefix=/usr/local\n\n# files that need mode 755\nEXEC_FILES=git-flow\n\n# files that need mode 644\nSCRIPT_FILES =git-flow-init\nSCRIPT_FILES+=git-flow-feature\nSCRIPT_FILES+=git-flow-hotfix\nSCRIPT_FILES+=git-flow-release\nSCRIPT_FILES+=git-flow-support\nSCRIPT_FILES+=git-flow-version\nSCRIPT_FILES+=gitflow-common\nSCRIPT_FILES+=gitflow-shFlags\n\nall:\n\t@echo \"usage: make install\"\n\t@echo \"       make uninstall\"\n\ninstall:\n\t@test -f gitflow-shFlags || (echo \"Run 'git submodule init && git submodule update' first.\" ; exit 1 )\n\tinstall -d -m 0755 $(prefix)/bin\n\tinstall -m 0755 $(EXEC_FILES) $(prefix)/bin\n\tinstall -m 0644 $(SCRIPT_FILES) $(prefix)/bin\n\nuninstall:\n\ttest -d $(prefix)/bin && \\\n\tcd $(prefix)/bin && \\\n\trm -f $(EXEC_FILES) $(SCRIPT_FILES)\n"
        },
        {
          "name": "README.mdown",
          "type": "blob",
          "size": 4.94140625,
          "content": "git-flow\n========\n\nA collection of Git extensions to provide high-level repository operations\nfor Vincent Driessen's [branching model](http://nvie.com/git-model \"original\nblog post\").\n\n\nGetting started\n---------------\nFor the best introduction to get started with `git flow`, please read Jeff\nKreeftmeijer's blog post:\n\n[http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/](http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/)\n\nOr have a look at one of these screen casts:\n\n* [How to use a scalable Git branching model called git-flow](http://buildamodule.com/video/change-management-and-version-control-deploying-releases-features-and-fixes-with-git-how-to-use-a-scalable-git-branching-model-called-gitflow) (by Build a Module)\n* [A short introduction to git-flow](http://vimeo.com/16018419) (by Mark Derricutt)\n* [On the path with git-flow](http://codesherpas.com/screencasts/on_the_path_gitflow.mov) (by Dave Bock)\n\n\nInstalling git-flow\n-------------------\nSee the Wiki for up-to-date [Installation Instructions](https://github.com/nvie/gitflow/wiki/Installation).\n\n\nIntegration with your shell\n---------------------------\nFor those who use the [Bash](http://www.gnu.org/software/bash/) or\n[ZSH](http://www.zsh.org) shell, please check out the excellent work on the\n[git-flow-completion](http://github.com/bobthecow/git-flow-completion) project\nby [bobthecow](http://github.com/bobthecow). It offers tab-completion for all\ngit-flow subcommands and branch names.\n\n\nFAQ\n---\nSee the [FAQ](http://github.com/nvie/gitflow/wiki/FAQ) section of the project\nWiki.\n\n\nPlease help out\n---------------\nThis project is still under development. Feedback and suggestions are very\nwelcome and I encourage you to use the [Issues\nlist](http://github.com/nvie/gitflow/issues) on Github to provide that\nfeedback.\n\nFeel free to fork this repo and to commit your additions. For a list of all\ncontributors, please see the [AUTHORS](AUTHORS) file.\n\nAny questions, tips, or general discussion can be posted to our Google group:\n[http://groups.google.com/group/gitflow-users](http://groups.google.com/group/gitflow-users)\n\nContributing\n------------\nFork the repository.  Then, run:\n\n    git clone --recursive git@github.com:<username>/gitflow.git\n    cd gitflow\n    git branch master origin/master\n    git flow init -d\n    git flow feature start <your feature>\n\nThen, do work and commit your changes.  **Hint**: ``export PATH=`pwd`:$PATH``\nfrom within the gitflow directory makes sure you're using the version of\ngitflow you're currently developing.\n\n    git flow feature publish <your feature>\n\nWhen done, open a pull request to your feature branch.\n\nLicense terms\n-------------\ngit-flow is published under the liberal terms of the BSD License, see the\n[LICENSE](LICENSE) file. Although the BSD License does not require you to share\nany modifications you make to the source code, you are very much encouraged and\ninvited to contribute back your modifications to the community, preferably\nin a Github fork, of course.\n\n\n### Initialization\n\nTo initialize a new repo with the basic branch structure, use:\n  \n\t\tgit flow init [-d]\n  \nThis will then interactively prompt you with some questions on which branches\nyou would like to use as development and production branches, and how you\nwould like your prefixes be named. You may simply press Return on any of\nthose questions to accept the (sane) default suggestions.\n\nThe ``-d`` flag will accept all defaults.\n\n\n### Creating feature/release/hotfix/support branches\n\n* To list/start/finish feature branches, use:\n  \n  \t\tgit flow feature\n  \t\tgit flow feature start <name> [<base>]\n  \t\tgit flow feature finish <name>\n  \n  For feature branches, the `<base>` arg must be a commit on `develop`.\n\n* To push/pull a feature branch to the remote repository, use:\n\n  \t\tgit flow feature publish <name>\n\t\t  git flow feature pull <remote> <name>\n\n* To list/start/finish release branches, use:\n  \n  \t\tgit flow release\n  \t\tgit flow release start <release> [<base>]\n  \t\tgit flow release finish <release>\n  \n  For release branches, the `<base>` arg must be a commit on `develop`.\n  \n* To list/start/finish hotfix branches, use:\n  \n  \t\tgit flow hotfix\n  \t\tgit flow hotfix start <release> [<base>]\n  \t\tgit flow hotfix finish <release>\n  \n  For hotfix branches, the `<base>` arg must be a commit on `master`.\n\n* To list/start support branches, use:\n  \n  \t\tgit flow support\n  \t\tgit flow support start <release> <base>\n  \n  For support branches, the `<base>` arg must be a commit on `master`.\n\n\nShowing your appreciation\n=========================\nA few people already requested it, so now it's here: a Flattr button.\n\nOf course, the best way to show your appreciation for the original\n[blog post](http://nvie.com/posts/a-successful-git-branching-model/) or the git-flow tool itself remains\ncontributing to the community.  If you'd like to show your appreciation in\nanother way, however, consider Flattr'ing me:\n\n[![Flattr this][2]][1]\n\n[1]: http://flattr.com/thing/53771/git-flow\n[2]: http://api.flattr.com/button/button-static-50x60.png\n"
        },
        {
          "name": "bump-version",
          "type": "blob",
          "size": 0.3955078125,
          "content": "#!/bin/sh\nusage() {\n\techo \"usage: bump-version <version-id>\"\n}\n\nif [ $# -ne 1 ]; then\n\tusage\n\texit 1\nfi\n\nif ! sed 's/^GITFLOW_VERSION=.*$/GITFLOW_VERSION='$1'/g' git-flow-version > .git-flow-version.new; then\n\techo \"Could not replace GITFLOW_VERSION variable.\" >&2\n\texit 2\nfi\n\nmv .git-flow-version.new git-flow-version\ngit add git-flow-version\ngit commit -m \"Bumped version number to $1\" git-flow-version\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "git-flow",
          "type": "blob",
          "size": 3.9951171875,
          "content": "#!/bin/sh\n#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\n# set this to workaround expr problems in shFlags on freebsd\nif uname -s | egrep -iq 'bsd'; then export EXPR_COMPAT=1; fi\n\n# enable debug mode\nif [ \"$DEBUG\" = \"yes\" ]; then\n\tset -x\nfi\n\n# The sed expression here replaces all backslashes by forward slashes.\n# This helps our Windows users, while not bothering our Unix users.\nexport GITFLOW_DIR=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")\n\nusage() {\n\techo \"usage: git flow <subcommand>\"\n\techo\n\techo \"Available subcommands are:\"\n\techo \"   init      Initialize a new git repo with support for the branching model.\"\n\techo \"   feature   Manage your feature branches.\"\n\techo \"   release   Manage your release branches.\"\n\techo \"   hotfix    Manage your hotfix branches.\"\n\techo \"   support   Manage your support branches.\"\n\techo \"   version   Shows version information.\"\n\techo\n\techo \"Try 'git flow <subcommand> help' for details.\"\n}\n\nmain() {\n\tif [ $# -lt 1 ]; then\n\t\tusage\n\t\texit 1\n\tfi\n\n\t# load common functionality\n\t. \"$GITFLOW_DIR/gitflow-common\"\n\n\t# This environmental variable fixes non-POSIX getopt style argument\n\t# parsing, effectively breaking git-flow subcommand parsing on several\n\t# Linux platforms.\n\texport POSIXLY_CORRECT=1\n\n\t# use the shFlags project to parse the command line arguments\n\t. \"$GITFLOW_DIR/gitflow-shFlags\"\n\tFLAGS_PARENT=\"git flow\"\n\n  # allow user to request git action logging\n  DEFINE_boolean show_commands false 'show actions taken (git commands)' g\n\n  # do actual parsing\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n\n\t# sanity checks\n\tSUBCOMMAND=\"$1\"; shift\n\n\tif [ ! -e \"$GITFLOW_DIR/git-flow-$SUBCOMMAND\" ]; then\n\t\tusage\n\t\texit 1\n\tfi\n\n\t# run command\n\t. \"$GITFLOW_DIR/git-flow-$SUBCOMMAND\"\n\tFLAGS_PARENT=\"git flow $SUBCOMMAND\"\n\n\t# test if the first argument is a flag (i.e. starts with '-')\n\t# in that case, we interpret this arg as a flag for the default\n\t# command\n\tSUBACTION=\"default\"\n\tif [ \"$1\" != \"\" ] && { ! echo \"$1\" | grep -q \"^-\"; } then\n\t\tSUBACTION=\"$1\"; shift\n\tfi\n\tif ! type \"cmd_$SUBACTION\" >/dev/null 2>&1; then\n\t\twarn \"Unknown subcommand: '$SUBACTION'\"\n\t\tusage\n\t\texit 1\n\tfi\n\n\t# run the specified action\n  if [ $SUBACTION != \"help\" ] && [ $SUBCOMMAND != \"init\" ] ; then\n    init\n  fi\n  cmd_$SUBACTION \"$@\"\n}\n\nmain \"$@\"\n"
        },
        {
          "name": "git-flow-feature",
          "type": "blob",
          "size": 14.2646484375,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\ninit() {\n  require_git_repo\n  require_gitflow_initialized\n  gitflow_load_settings\n  PREFIX=$(git config --get gitflow.prefix.feature)\n}\n\nusage() {\n\techo \"usage: git flow feature [list] [-v]\"\n\techo \"       git flow feature start [-F] <name> [<base>]\"\n\techo \"       git flow feature finish [-rFkDS] [<name|nameprefix>]\"\n\techo \"       git flow feature publish <name>\"\n\techo \"       git flow feature track <name>\"\n\techo \"       git flow feature diff [<name|nameprefix>]\"\n\techo \"       git flow feature rebase [-i] [<name|nameprefix>]\"\n\techo \"       git flow feature checkout [<name|nameprefix>]\"\n\techo \"       git flow feature pull [-r] <remote> [<name>]\"\n}\n\ncmd_default() {\n\tcmd_list \"$@\"\n}\n\ncmd_list() {\n\tDEFINE_boolean verbose false 'verbose (more) output' v\n\tparse_args \"$@\"\n\n\tlocal feature_branches\n\tlocal current_branch\n\tlocal short_names\n\tfeature_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n\tif [ -z \"$feature_branches\" ]; then\n\t\twarn \"No feature branches exist.\"\n\t\twarn \"\"\n\t\twarn \"You can start a new feature branch:\"\n\t\twarn \"\"\n\t\twarn \"    git flow feature start <name> [<base>]\"\n\t\twarn \"\"\n\t\texit 0\n\tfi\n\tcurrent_branch=$(git branch --no-color | grep '^\\* ' | grep -v 'no branch' | sed 's/^* //g')\n\tshort_names=$(echo \"$feature_branches\" | sed \"s ^$PREFIX  g\")\n\n\t# determine column width first\n\tlocal width=0\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal len=${#branch}\n\t\twidth=$(max $width $len)\n\tdone\n\twidth=$(($width+3))\n\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal fullname=$PREFIX$branch\n\t\tlocal base=$(git merge-base \"$fullname\" \"$DEVELOP_BRANCH\")\n\t\tlocal develop_sha=$(git rev-parse \"$DEVELOP_BRANCH\")\n\t\tlocal branch_sha=$(git rev-parse \"$fullname\")\n\t\tif [ \"$fullname\" = \"$current_branch\" ]; then\n\t\t\tprintf \"* \"\n\t\telse\n\t\t\tprintf \"  \"\n\t\tfi\n\t\tif flag verbose; then\n\t\t\tprintf \"%-${width}s\" \"$branch\"\n\t\t\tif [ \"$branch_sha\" = \"$develop_sha\" ]; then\n\t\t\t\tprintf \"(no commits yet)\"\n\t\t\telif [ \"$base\" = \"$branch_sha\" ]; then\n\t\t\t\tprintf \"(is behind develop, may ff)\"\n\t\t\telif [ \"$base\" = \"$develop_sha\" ]; then\n\t\t\t\tprintf \"(based on latest develop)\"\n\t\t\telse\n\t\t\t\tprintf \"(may be rebased)\"\n\t\t\tfi\n\t\telse\n\t\t\tprintf \"%s\" \"$branch\"\n\t\tfi\n\t\techo\n\tdone\n}\n\ncmd_help() {\n\tusage\n\texit 0\n}\n\nrequire_name_arg() {\n\tif [ \"$NAME\" = \"\" ]; then\n\t\twarn \"Missing argument <name>\"\n\t\tusage\n\t\texit 1\n\tfi\n}\n\nexpand_nameprefix_arg() {\n\trequire_name_arg\n\n\tlocal expanded_name\n\tlocal exitcode\n\texpanded_name=$(gitflow_resolve_nameprefix \"$NAME\" \"$PREFIX\")\n\texitcode=$?\n\tcase $exitcode in\n\t\t0) NAME=$expanded_name\n\t\t   BRANCH=$PREFIX$NAME\n\t\t   ;;\n\t\t*) exit 1 ;;\n\tesac\n}\n\nuse_current_feature_branch_name() {\n\tlocal current_branch=$(git_current_branch)\n\tif startswith \"$current_branch\" \"$PREFIX\"; then\n\t\tBRANCH=$current_branch\n\t\tNAME=${BRANCH#$PREFIX}\n\telse\n\t\twarn \"The current HEAD is no feature branch.\"\n\t\twarn \"Please specify a <name> argument.\"\n\t\texit 1\n\tfi\n}\n\nexpand_nameprefix_arg_or_current() {\n\tif [ \"$NAME\" != \"\" ]; then\n\t\texpand_nameprefix_arg\n\t\trequire_branch \"$PREFIX$NAME\"\n\telse\n\t\tuse_current_feature_branch_name\n\tfi\n}\n\nname_or_current() {\n\tif [ -z \"$NAME\" ]; then\n\t\tuse_current_feature_branch_name\n\tfi\n}\n\nparse_args() {\n\t# parse options\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n\n\t# read arguments into global variables\n\tNAME=$1\n\tBRANCH=$PREFIX$NAME\n}\n\nparse_remote_name() {\n\t# parse options\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n\n\t# read arguments into global variables\n\tREMOTE=$1\n\tNAME=$2\n\tBRANCH=$PREFIX$NAME\n}\n\ncmd_start() {\n\tDEFINE_boolean fetch false 'fetch from origin before performing local operation' F\n\tparse_args \"$@\"\n\tBASE=${2:-$DEVELOP_BRANCH}\n\trequire_name_arg\n\n\t# sanity checks\n\trequire_branch_absent \"$BRANCH\"\n\n\t# update the local repo with remote changes, if asked\n\tif flag fetch; then\n\t\tgit_do fetch -q \"$ORIGIN\" \"$DEVELOP_BRANCH\"\n\tfi\n\n\t# if the origin branch counterpart exists, assert that the local branch\n\t# isn't behind it (to avoid unnecessary rebasing)\n\tif git_branch_exists \"$ORIGIN/$DEVELOP_BRANCH\"; then\n\t\trequire_branches_equal \"$DEVELOP_BRANCH\" \"$ORIGIN/$DEVELOP_BRANCH\"\n\tfi\n\n\t# create branch\n\tif ! git_do checkout -b \"$BRANCH\" \"$BASE\"; then\n\t\tdie \"Could not create feature branch '$BRANCH'\"\n\tfi\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new branch '$BRANCH' was created, based on '$BASE'\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo \"\"\n\techo \"Now, start committing on your feature. When done, use:\"\n\techo \"\"\n\techo \"     git flow feature finish $NAME\"\n\techo\n}\n\ncmd_finish() {\n\tDEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n\tDEFINE_boolean rebase false \"rebase instead of merge\" r\n\tDEFINE_boolean keep false \"keep branch after performing finish\" k\n\tDEFINE_boolean force_delete false \"force delete feature branch after finish\" D\n\tDEFINE_boolean squash false \"squash feature during merge\" S\n\tparse_args \"$@\"\n\texpand_nameprefix_arg_or_current\n\n\t# sanity checks\n\trequire_branch \"$BRANCH\"\n\n\t# detect if we're restoring from a merge conflict\n\tif [ -f \"$DOT_GIT_DIR/.gitflow/MERGE_BASE\" ]; then\n\t\t#\n\t\t# TODO: detect that we're working on the correct branch here!\n\t\t# The user need not necessarily have given the same $NAME twice here\n\t\t# (although he/she should).\n\t\t# \n\n\t\t# TODO: git_is_clean_working_tree() should provide an alternative\n\t\t# exit code for \"unmerged changes in working tree\", which we should\n\t\t# actually be testing for here\n\t\tif git_is_clean_working_tree; then\n\t\t\tFINISH_BASE=$(cat \"$DOT_GIT_DIR/.gitflow/MERGE_BASE\")\n\n\t\t\t# Since the working tree is now clean, either the user did a\n\t\t\t# succesfull merge manually, or the merge was cancelled.\n\t\t\t# We detect this using git_is_branch_merged_into()\n\t\t\tif git_is_branch_merged_into \"$BRANCH\" \"$FINISH_BASE\"; then\n\t\t\t\trm -f \"$DOT_GIT_DIR/.gitflow/MERGE_BASE\"\n\t\t\t\thelper_finish_cleanup\n\t\t\t\texit 0\n\t\t\telse\n\t\t\t\t# If the user cancelled the merge and decided to wait until later,\n\t\t\t\t# that's fine. But we have to acknowledge this by removing the\n\t\t\t\t# MERGE_BASE file and continuing normal execution of the finish\n\t\t\t\trm -f \"$DOT_GIT_DIR/.gitflow/MERGE_BASE\"\n\t\t\tfi\n\t\telse\n\t\t\techo\n\t\t\techo \"Merge conflicts not resolved yet, use:\"\n\t\t\techo \"    git mergetool\"\n\t\t\techo \"    git commit\"\n\t\t\techo \n\t\t\techo \"You can then complete the finish by running it again:\"\n\t\t\techo \"    git flow feature finish $NAME\"\n\t\t\techo\n\t\t\texit 1\n\t\tfi\n\tfi\n\n\t# sanity checks\n\trequire_clean_working_tree\n\n\t# update local repo with remote changes first, if asked\n\tif has \"$ORIGIN/$BRANCH\" $(git_remote_branches); then\n\t\tif flag fetch; then\n\t\t\tgit_do fetch -q \"$ORIGIN\" \"$BRANCH\"\n\t\t\tgit_do fetch -q \"$ORIGIN\" \"$DEVELOP_BRANCH\"\n\t\tfi\n\tfi\n\n\tif has \"$ORIGIN/$BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$BRANCH\" \"$ORIGIN/$BRANCH\"\n\tfi\n\tif has \"$ORIGIN/$DEVELOP_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$DEVELOP_BRANCH\" \"$ORIGIN/$DEVELOP_BRANCH\"\n\tfi\n\n\t# if the user wants to rebase, do that first\n\tif flag rebase; then\n\t\tif ! git flow feature rebase \"$NAME\" \"$DEVELOP_BRANCH\"; then\n\t\t\twarn \"Finish was aborted due to conflicts during rebase.\"\n\t\t\twarn \"Please finish the rebase manually now.\"\n\t\t\twarn \"When finished, re-run:\"\n\t\t\twarn \"    git flow feature finish '$NAME' '$DEVELOP_BRANCH'\"\n\t\t\texit 1\n\t\tfi\n\tfi\n\n\t# merge into BASE\n\tgit_do checkout \"$DEVELOP_BRANCH\"\n\tif [ \"$(git rev-list -n2 \"$DEVELOP_BRANCH..$BRANCH\" | wc -l)\" -eq 1 ]; then\n\t\tgit_do merge --ff \"$BRANCH\"\n\telse\n\t\tif noflag squash; then\n\t\t    git_do merge --no-ff \"$BRANCH\"\n\t\telse\n\t\t\tgit_do merge --squash \"$BRANCH\"\n\t\t\tgit_do commit\n\t\t\tgit_do merge \"$BRANCH\"\n\t\tfi\n\tfi\n\n\tif [ $? -ne 0 ]; then\n\t\t# oops.. we have a merge conflict!\n\t\t# write the given $DEVELOP_BRANCH to a temporary file (we need it later)\n\t\tmkdir -p \"$DOT_GIT_DIR/.gitflow\"\n\t\techo \"$DEVELOP_BRANCH\" > \"$DOT_GIT_DIR/.gitflow/MERGE_BASE\"\n\t\techo\n\t\techo \"There were merge conflicts. To resolve the merge conflict manually, use:\"\n\t\techo \"    git mergetool\"\n\t\techo \"    git commit\"\n\t\techo \n\t\techo \"You can then complete the finish by running it again:\"\n\t\techo \"    git flow feature finish $NAME\"\n\t\techo\n\t\texit 1\n\tfi\n\n\t# when no merge conflict is detected, just clean up the feature branch\n\thelper_finish_cleanup\n}\n\nhelper_finish_cleanup() {\n\t# sanity checks\n\trequire_branch \"$BRANCH\"\n\trequire_clean_working_tree\n\n\t# delete branch\n\tif flag fetch; then\n\t\tgit_do push \"$ORIGIN\" \":refs/heads/$BRANCH\"\n\tfi\n\t\n\t\n\tif noflag keep; then\n\t\tif flag force_delete; then\n\t\t\tgit_do branch -D \"$BRANCH\"\n\t\telse\n\t\t\tgit_do branch -d \"$BRANCH\"\n\t\tfi\n\tfi\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- The feature branch '$BRANCH' was merged into '$DEVELOP_BRANCH'\"\n\t#echo \"- Merge conflicts were resolved\"\t\t# TODO: Add this line when it's supported\n\tif flag keep; then\n\t\techo \"- Feature branch '$BRANCH' is still available\"\n\telse\n\t\techo \"- Feature branch '$BRANCH' has been removed\"\n\tfi\n\techo \"- You are now on branch '$DEVELOP_BRANCH'\"\n\techo\n}\n\ncmd_publish() {\n\tparse_args \"$@\"\n\texpand_nameprefix_arg\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch \"$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\trequire_branch_absent \"$ORIGIN/$BRANCH\"\n\n\t# create remote branch\n\tgit_do push \"$ORIGIN\" \"$BRANCH:refs/heads/$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\n\t# configure remote tracking\n\tgit_do config \"branch.$BRANCH.remote\" \"$ORIGIN\"\n\tgit_do config \"branch.$BRANCH.merge\" \"refs/heads/$BRANCH\"\n\tgit_do checkout \"$BRANCH\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new remote branch '$BRANCH' was created\"\n\techo \"- The local branch '$BRANCH' was configured to track the remote branch\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n\ncmd_track() {\n\tparse_args \"$@\"\n\trequire_name_arg\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch_absent \"$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\trequire_branch \"$ORIGIN/$BRANCH\"\n\n\t# create tracking branch\n\tgit_do checkout -b \"$BRANCH\" \"$ORIGIN/$BRANCH\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new remote tracking branch '$BRANCH' was created\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n\ncmd_diff() {\n\tparse_args \"$@\"\n\n\tif [ \"$NAME\" != \"\" ]; then\n\t\texpand_nameprefix_arg\n\t\tBASE=$(git merge-base \"$DEVELOP_BRANCH\" \"$BRANCH\")\n\t\tgit diff \"$BASE..$BRANCH\"\n\telse\n\t\tif ! git_current_branch | grep -q \"^$PREFIX\"; then\n\t\t\tdie \"Not on a feature branch. Name one explicitly.\"\n\t\tfi\n\n\t\tBASE=$(git merge-base \"$DEVELOP_BRANCH\" HEAD)\n\t\tgit diff \"$BASE\"\n\tfi\n}\n\ncmd_checkout() {\n\tparse_args \"$@\"\n\n\tif [ \"$NAME\" != \"\" ]; then\n\t\texpand_nameprefix_arg\n\t\tgit_do checkout \"$BRANCH\"\n\telse\n\t\tdie \"Name a feature branch explicitly.\"\n\tfi\n}\n\ncmd_co() {\n\t# Alias for checkout\n\tcmd_checkout \"$@\"\n}\n\ncmd_rebase() {\n\tDEFINE_boolean interactive false 'do an interactive rebase' i\n\tparse_args \"$@\"\n\texpand_nameprefix_arg_or_current\n\twarn \"Will try to rebase '$NAME'...\"\n\trequire_clean_working_tree\n\trequire_branch \"$BRANCH\"\n\n\tgit_do checkout -q \"$BRANCH\"\n\tlocal OPTS=\n\tif flag interactive; then\n\t\tOPTS=\"$OPTS -i\"\n\tfi\n\tgit_do rebase $OPTS \"$DEVELOP_BRANCH\"\n}\n\navoid_accidental_cross_branch_action() {\n\tlocal current_branch=$(git_current_branch)\n\tif [ \"$BRANCH\" != \"$current_branch\" ]; then\n\t\twarn \"Trying to pull from '$BRANCH' while currently on branch '$current_branch'.\"\n\t\twarn \"To avoid unintended merges, git-flow aborted.\"\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\ncmd_pull() {\n\t#DEFINE_string prefix false 'alternative remote feature branch name prefix' p\n\tDEFINE_boolean rebase false \"pull with rebase\" r\n\tparse_remote_name \"$@\"\n\n\tif [ -z \"$REMOTE\" ]; then\n\t\tdie \"Name a remote explicitly.\"\n\tfi\n\tname_or_current\n\n\t# To avoid accidentally merging different feature branches into each other,\n\t# die if the current feature branch differs from the requested $NAME\n\t# argument.\n\tlocal current_branch=$(git_current_branch)\n\tif startswith \"$current_branch\" \"$PREFIX\"; then\n\t\t# we are on a local feature branch already, so $BRANCH must be equal to\n\t\t# the current branch\n\t\tavoid_accidental_cross_branch_action || die\n\tfi\n\n\trequire_clean_working_tree\n\n\tif git_branch_exists \"$BRANCH\"; then\n\t\t# Again, avoid accidental merges\n\t\tavoid_accidental_cross_branch_action || die\n\n\t\t# we already have a local branch called like this, so simply pull the\n\t\t# remote changes in\n\t\tif flag rebase; then\n\t\t\tif ! git_do pull --rebase -q \"$REMOTE\" \"$BRANCH\"; then\n\t\t\t\twarn \"Pull was aborted. There might be conflicts during rebase or '$REMOTE' might be inaccessible.\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\telse\n\t\t\tgit_do pull -q \"$REMOTE\" \"$BRANCH\" || die \"Failed to pull from remote '$REMOTE'.\"\n\t\tfi\n\n\t\techo \"Pulled $REMOTE's changes into $BRANCH.\"\n\telse\n\t\t# setup the local branch clone for the first time\n\t\tgit_do fetch -q \"$REMOTE\" \"$BRANCH\" || die \"Fetch failed.\"     # stores in FETCH_HEAD\n\t\tgit_do branch --no-track \"$BRANCH\" FETCH_HEAD || die \"Branch failed.\"\n\t\tgit_do checkout -q \"$BRANCH\" || die \"Checking out new local branch failed.\"\n\t\techo \"Created local branch $BRANCH based on $REMOTE's $BRANCH.\"\n\tfi\n}\n"
        },
        {
          "name": "git-flow-hotfix",
          "type": "blob",
          "size": 10.55859375,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\ninit() {\n  require_git_repo\n  require_gitflow_initialized\n  gitflow_load_settings\n  VERSION_PREFIX=$(eval \"echo `git config --get gitflow.prefix.versiontag`\")\n  PREFIX=$(git config --get gitflow.prefix.hotfix)\n}\n\nusage() {\n\techo \"usage: git flow hotfix [list] [-v]\"\n\techo \"       git flow hotfix start [-F] <version> [<base>]\"\n\techo \"       git flow hotfix finish [-Fsumpk] <version>\"\n\techo \"       git flow hotfix publish <version>\"\n\techo \"       git flow hotfix track <version>\"\n}\n\ncmd_default() {\n\tcmd_list \"$@\"\n}\n\ncmd_list() {\n\tDEFINE_boolean verbose false 'verbose (more) output' v\n\tparse_args \"$@\"\n\n\tlocal hotfix_branches\n\tlocal current_branch\n\tlocal short_names\n\thotfix_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n\tif [ -z \"$hotfix_branches\" ]; then\n\t\twarn \"No hotfix branches exist.\"\n                warn \"\"\n                warn \"You can start a new hotfix branch:\"\n                warn \"\"\n                warn \"    git flow hotfix start <version> [<base>]\"\n                warn \"\"\n\t\texit 0\n\tfi\n\tcurrent_branch=$(git branch --no-color | grep '^\\* ' | grep -v 'no branch' | sed 's/^* //g')\n\tshort_names=$(echo \"$hotfix_branches\" | sed \"s ^$PREFIX  g\")\n\n\t# determine column width first\n\tlocal width=0\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal len=${#branch}\n\t\twidth=$(max $width $len)\n\tdone\n\twidth=$(($width+3))\n\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal fullname=$PREFIX$branch\n\t\tlocal base=$(git merge-base \"$fullname\" \"$MASTER_BRANCH\")\n\t\tlocal master_sha=$(git rev-parse \"$MASTER_BRANCH\")\n\t\tlocal branch_sha=$(git rev-parse \"$fullname\")\n\t\tif [ \"$fullname\" = \"$current_branch\" ]; then\n\t\t\tprintf \"* \"\n\t\telse\n\t\t\tprintf \"  \"\n\t\tfi\n\t\tif flag verbose; then\n\t\t\tprintf \"%-${width}s\" \"$branch\"\n\t\t\tif [ \"$branch_sha\" = \"$master_sha\" ]; then\n\t\t\t\tprintf \"(no commits yet)\"\n\t\t\telse\n\t\t\t\tlocal tagname=$(git name-rev --tags --no-undefined --name-only \"$base\")\n\t\t\t\tlocal nicename\n\t\t\t\tif [ \"$tagname\" != \"\" ]; then\n\t\t\t\t\tnicename=$tagname\n\t\t\t\telse\n\t\t\t\t\tnicename=$(git rev-parse --short \"$base\")\n\t\t\t\tfi\n\t\t\t\tprintf \"(based on $nicename)\"\n\t\t\tfi\n\t\telse\n\t\t\tprintf \"%s\" \"$branch\"\n\t\tfi\n\t\techo\n\tdone\n}\n\ncmd_help() {\n\tusage\n\texit 0\n}\n\nparse_args() {\n\t# parse options\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n\n\t# read arguments into global variables\n\tVERSION=$1\n\tBRANCH=$PREFIX$VERSION\n}\n\nrequire_version_arg() {\n\tif [ \"$VERSION\" = \"\" ]; then\n\t\twarn \"Missing argument <version>\"\n\t\tusage\n\t\texit 1\n\tfi\n}\n\nrequire_base_is_on_master() {\n\tif ! git branch --no-color --contains \"$BASE\" 2>/dev/null \\\n\t\t\t| sed 's/[* ] //g' \\\n\t  \t\t| grep -q \"^$MASTER_BRANCH\\$\"; then\n\t\tdie \"fatal: Given base '$BASE' is not a valid commit on '$MASTER_BRANCH'.\"\n\tfi\n}\n\nrequire_no_existing_hotfix_branches() {\n\tlocal hotfix_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n\tlocal first_branch=$(echo ${hotfix_branches} | head -n1)\n\tfirst_branch=${first_branch#$PREFIX}\n\t[ -z \"$hotfix_branches\" ] || \\\n\t\tdie \"There is an existing hotfix branch ($first_branch). Finish that one first.\"\n}\n\ncmd_start() {\n\tDEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n\tparse_args \"$@\"\n\tBASE=${2:-$MASTER_BRANCH}\n\trequire_version_arg\n\trequire_base_is_on_master\n\trequire_no_existing_hotfix_branches\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch_absent \"$BRANCH\"\n\trequire_tag_absent \"$VERSION_PREFIX$VERSION\"\n\tif flag fetch; then\n\t\tgit_do fetch -q \"$ORIGIN\" \"$MASTER_BRANCH\"\n\tfi\n\tif has \"$ORIGIN/$MASTER_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$MASTER_BRANCH\" \"$ORIGIN/$MASTER_BRANCH\"\n\tfi\n\n\t# create branch\n\tgit_do checkout -b \"$BRANCH\" \"$BASE\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new branch '$BRANCH' was created, based on '$BASE'\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n\techo \"Follow-up actions:\"\n\techo \"- Bump the version number now!\"\n\techo \"- Start committing your hot fixes\"\n\techo \"- When done, run:\"\n\techo\n\techo \"     git flow hotfix finish '$VERSION'\"\n\techo\n}\n\ncmd_publish() {\n\tparse_args \"$@\"\n\trequire_version_arg\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch \"$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\trequire_branch_absent \"$ORIGIN/$BRANCH\"\n\n\t# create remote branch\n\tgit_do push \"$ORIGIN\" \"$BRANCH:refs/heads/$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\n\t# configure remote tracking\n\tgit config \"branch.$BRANCH.remote\" \"$ORIGIN\"\n\tgit config \"branch.$BRANCH.merge\" \"refs/heads/$BRANCH\"\n\tgit_do checkout \"$BRANCH\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new remote branch '$BRANCH' was created\"\n\techo \"- The local branch '$BRANCH' was configured to track the remote branch\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n\ncmd_track() {\n\tparse_args \"$@\"\n\trequire_version_arg\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch_absent \"$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\trequire_branch \"$ORIGIN/$BRANCH\"\n\n\t# create tracking branch\n\tgit_do checkout -b \"$BRANCH\" \"$ORIGIN/$BRANCH\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new remote tracking branch '$BRANCH' was created\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n\ncmd_finish() {\n\tDEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n\tDEFINE_boolean sign false \"sign the release tag cryptographically\" s\n\tDEFINE_string signingkey \"\" \"use the given GPG-key for the digital signature (implies -s)\" u\n\tDEFINE_string message \"\" \"use the given tag message\" m\n\tDEFINE_string messagefile \"\" \"use the contents of the given file as tag message\" f\n\tDEFINE_boolean push false \"push to $ORIGIN after performing finish\" p\n\tDEFINE_boolean keep false \"keep branch after performing finish\" k\n\tDEFINE_boolean notag false \"don't tag this release\" n\n\tparse_args \"$@\"\n\trequire_version_arg\n\n\t# handle flags that imply other flags\n\tif [ \"$FLAGS_signingkey\" != \"\" ]; then\n\t\tFLAGS_sign=$FLAGS_TRUE\n\tfi\n\n\t# sanity checks\n\trequire_branch \"$BRANCH\"\n\trequire_clean_working_tree\n\tif flag fetch; then\n\t\tgit_do fetch -q \"$ORIGIN\" \"$MASTER_BRANCH\" || \\\n\t\t  die \"Could not fetch $MASTER_BRANCH from $ORIGIN.\"\n\t\tgit_do fetch -q \"$ORIGIN\" \"$DEVELOP_BRANCH\" || \\\n\t\t  die \"Could not fetch $DEVELOP_BRANCH from $ORIGIN.\"\n\tfi\n\tif has \"$ORIGIN/$MASTER_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$MASTER_BRANCH\" \"$ORIGIN/$MASTER_BRANCH\"\n\tfi\n\tif has \"$ORIGIN/$DEVELOP_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$DEVELOP_BRANCH\" \"$ORIGIN/$DEVELOP_BRANCH\"\n\tfi\n\n\t# try to merge into master\n\t# in case a previous attempt to finish this release branch has failed,\n\t# but the merge into master was successful, we skip it now\n\tif ! git_is_branch_merged_into \"$BRANCH\" \"$MASTER_BRANCH\"; then\n\t\tgit_do checkout \"$MASTER_BRANCH\" || \\\n\t\t  die \"Could not check out $MASTER_BRANCH.\"\n\t\tgit_do merge --no-ff \"$BRANCH\" || \\\n\t\t  die \"There were merge conflicts.\"\n\t\t  # TODO: What do we do now?\n\tfi\n\n\tif noflag notag; then\n\t\t# try to tag the release\n\t\t# in case a previous attempt to finish this release branch has failed,\n\t\t# but the tag was set successful, we skip it now\n\t\tlocal tagname=$VERSION_PREFIX$VERSION\n\t\tif ! git_tag_exists \"$tagname\"; then\n\t\t\tlocal opts=\"-a\"\n\t\t\tflag sign && opts=\"$opts -s\"\n\t\t\t[ \"$FLAGS_signingkey\" != \"\" ] && opts=\"$opts -u '$FLAGS_signingkey'\"\n\t\t\t[ \"$FLAGS_message\" != \"\" ] && opts=\"$opts -m '$FLAGS_message'\"\n\t\t\t[ \"$FLAGS_messagefile\" != \"\" ] && opts=\"$opts -F '$FLAGS_messagefile'\"\n\t\t\teval git_do tag $opts \"$VERSION_PREFIX$VERSION\" \"$BRANCH\" || \\\n\t\t\tdie \"Tagging failed. Please run finish again to retry.\"\n\t\tfi\n\tfi\n\n\t# try to merge into develop\n\t# in case a previous attempt to finish this release branch has failed,\n\t# but the merge into develop was successful, we skip it now\n\tif ! git_is_branch_merged_into \"$BRANCH\" \"$DEVELOP_BRANCH\"; then\n\t\tgit_do checkout \"$DEVELOP_BRANCH\" || \\\n\t\t  die \"Could not check out $DEVELOP_BRANCH.\"\n\n\t\t# TODO: Actually, accounting for 'git describe' pays, so we should\n\t\t# ideally git merge --no-ff $tagname here, instead!\n\t\tgit_do merge --no-ff \"$BRANCH\" || \\\n\t\t  die \"There were merge conflicts.\"\n\t\t  # TODO: What do we do now?\n\tfi\n\n\t# delete branch\n\tif noflag keep; then\n\t\tgit_do branch -d \"$BRANCH\"\n\tfi\n\n\tif flag push; then\n\t\tgit_do push \"$ORIGIN\" \"$DEVELOP_BRANCH\" || \\\n\t\t\tdie \"Could not push to $DEVELOP_BRANCH from $ORIGIN.\"\n\t\tgit_do push \"$ORIGIN\" \"$MASTER_BRANCH\" || \\\n\t\t\tdie \"Could not push to $MASTER_BRANCH from $ORIGIN.\"\n\t\tif noflag notag; then\n\t\t\tgit_do push --tags \"$ORIGIN\" || \\\n\t\t\t\tdie \"Could not push tags to $ORIGIN.\"\n\t\tfi\n\tfi\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- Latest objects have been fetched from '$ORIGIN'\"\n\techo \"- Hotfix branch has been merged into '$MASTER_BRANCH'\"\n\tif noflag notag; then\n\t\techo \"- The hotfix was tagged '$VERSION_PREFIX$VERSION'\"\n\tfi\n\techo \"- Hotfix branch has been back-merged into '$DEVELOP_BRANCH'\"\n\tif flag keep; then\n\t\techo \"- Hotfix branch '$BRANCH' is still available\"\n\telse\n\t\techo \"- Hotfix branch '$BRANCH' has been deleted\"\n\tfi\n\tif flag push; then\n\t\techo \"- '$DEVELOP_BRANCH', '$MASTER_BRANCH' and tags have been pushed to '$ORIGIN'\"\n\tfi\n\techo\n}\n"
        },
        {
          "name": "git-flow-init",
          "type": "blob",
          "size": 10.7099609375,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\nusage() {\n\techo \"usage: git flow init [-fd]\"\n}\n\nparse_args() {\n\t# parse options\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n}\n\n# Default entry when no SUBACTION is given\ncmd_default() {\n\tDEFINE_boolean force false 'force setting of gitflow branches, even if already configured' f\n\tDEFINE_boolean defaults false 'use default branch naming conventions' d\n\tparse_args \"$@\"\n\t\n\tif ! git rev-parse --git-dir >/dev/null 2>&1; then\n\t\tgit_do init\n\telse\n\t\t# assure that we are not working in a repo with local changes\n\t\tgit_repo_is_headless || require_clean_working_tree\n\tfi\n\n\t# running git flow init on an already initialized repo is fine\n\tif gitflow_is_initialized && ! flag force; then\n\t\twarn \"Already initialized for gitflow.\"\n\t\twarn \"To force reinitialization, use: git flow init -f\"\n\t\texit 0\n\tfi\n\n\tlocal branch_count\n\tlocal answer\n\n    if flag defaults; then\n        warn \"Using default branch names.\"\n    fi\n\n\t# add a master branch if no such branch exists yet\n\tlocal master_branch\n\tif gitflow_has_master_configured && ! flag force; then\n\t\tmaster_branch=$(git config --get gitflow.branch.master)\n\telse\n\t\t# Two cases are distinguished:\n\t\t# 1. A fresh git repo (without any branches)\n\t\t#    We will create a new master/develop branch for the user\n\t\t# 2. Some branches do already exist\n\t\t#    We will disallow creation of new master/develop branches and\n\t\t#    rather allow to use existing branches for git-flow.\n\t\tlocal default_suggestion\n\t\tlocal should_check_existence\n\t\tbranch_count=$(git_local_branches | wc -l)\n\t\tif [ \"$branch_count\" -eq 0 ]; then\n\t\t\techo \"No branches exist yet. Base branches must be created now.\"\n\t\t\tshould_check_existence=NO\n\t\t\tdefault_suggestion=$(git config --get gitflow.branch.master || echo master)\n\t\telse\n\t\t\techo\n\t\t\techo \"Which branch should be used for bringing forth production releases?\"\n\t\t\tgit_local_branches | sed 's/^.*$/   - &/g'\n\n\t\t\tshould_check_existence=YES\n\t\t\tdefault_suggestion=\n\t\t\tfor guess in $(git config --get gitflow.branch.master) \\\n\t\t\t             'production' 'main' 'master'; do\n\t\t\t\tif git_local_branch_exists \"$guess\"; then\n\t\t\t\t\tdefault_suggestion=\"$guess\"\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\t\n\t\tprintf \"Branch name for production releases: [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\tmaster_branch=${answer:-$default_suggestion}\n\n\t\t# check existence in case of an already existing repo\n\t\tif [ \"$should_check_existence\" = \"YES\" ]; then\n\t\t\t# if no local branch exists and a remote branch of the same\n\t\t\t# name exists, checkout that branch and use it for master\n\t\t\tif ! git_local_branch_exists \"$master_branch\" && \\\n\t\t\t\tgit_remote_branch_exists \"origin/$master_branch\"; then\n\t\t\t\tgit_do branch \"$master_branch\" \"origin/$master_branch\" >/dev/null 2>&1\n\t\t\telif ! git_local_branch_exists \"$master_branch\"; then\n\t\t\t\tdie \"Local branch '$master_branch' does not exist.\"\n\t\t\tfi\n\t\tfi\n\n\t\t# store the name of the master branch\n\t\tgit_do config gitflow.branch.master \"$master_branch\"\n\tfi\n\n\t# add a develop branch if no such branch exists yet\n\tlocal develop_branch\n\tif gitflow_has_develop_configured && ! flag force; then\n\t\tdevelop_branch=$(git config --get gitflow.branch.develop)\n\telse\n\t\t# Again, the same two cases as with the master selection are\n\t\t# considered (fresh repo or repo that contains branches)\n\t\tlocal default_suggestion\n\t\tlocal should_check_existence\n\t\tbranch_count=$(git_local_branches | grep -v \"^${master_branch}\\$\" | wc -l)\n\t\tif [ \"$branch_count\" -eq 0 ]; then\n\t\t\tshould_check_existence=NO\n\t\t\tdefault_suggestion=$(git config --get gitflow.branch.develop || echo develop)\n\t\telse\n\t\t\techo\n\t\t\techo \"Which branch should be used for integration of the \\\"next release\\\"?\"\n\t\t\tgit_local_branches | grep -v \"^${master_branch}\\$\" | sed 's/^.*$/   - &/g'\n\n\t\t\tshould_check_existence=YES\n\t\t\tdefault_suggestion=\n\t\t\tfor guess in $(git config --get gitflow.branch.develop) \\\n\t\t\t             'develop' 'int' 'integration' 'master'; do\n\t\t\t\tif git_local_branch_exists \"$guess\" && [ \"$guess\" != \"$master_branch\" ]; then\n\t\t\t\t\tdefault_suggestion=\"$guess\"\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\t\t\n\t\t\tif [ -z $default_suggestion ]; then\n\t\t\t\tshould_check_existence=NO\n\t\t\t\tdefault_suggestion=$(git config --get gitflow.branch.develop || echo develop)\n\t\t\tfi\n\t\t\t\n\t\tfi\n\n\t\tprintf \"Branch name for \\\"next release\\\" development: [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\tdevelop_branch=${answer:-$default_suggestion}\n\n\t\tif [ \"$master_branch\" = \"$develop_branch\" ]; then\n\t\t\tdie \"Production and integration branches should differ.\"\n\t\tfi\n\n\t\t# check existence in case of an already existing repo\n\t\tif [ \"$should_check_existence\" = \"YES\" ]; then\n\t\t\tgit_local_branch_exists \"$develop_branch\" || \\\n\t\t\t\tdie \"Local branch '$develop_branch' does not exist.\"\n\t\tfi\n\n\t\t# store the name of the develop branch\n\t\tgit_do config gitflow.branch.develop \"$develop_branch\"\n\tfi\n\n\t# Creation of HEAD\n\t# ----------------\n\t# We create a HEAD now, if it does not exist yet (in a fresh repo). We need\n\t# it to be able to create new branches.\n\tlocal created_gitflow_branch=0\n\tif ! git rev-parse --quiet --verify HEAD >/dev/null 2>&1; then\n\t\tgit_do symbolic-ref HEAD \"refs/heads/$master_branch\"\n\t\tgit_do commit --allow-empty --quiet -m \"Initial commit\"\n\t\tcreated_gitflow_branch=1\n\tfi\n\n\t# Creation of master\n\t# ------------------\n\t# At this point, there always is a master branch: either it existed already\n\t# (and was picked interactively as the production branch) or it has just\n\t# been created in a fresh repo\n\n\t# Creation of develop\n\t# -------------------\n\t# The develop branch possibly does not exist yet.  This is the case when,\n\t# in a git init'ed repo with one or more commits, master was picked as the\n\t# default production branch and develop was \"created\".  We should create\n\t# the develop branch now in that case (we base it on master, of course)\n\tif ! git_local_branch_exists \"$develop_branch\"; then\n\t\tif git_remote_branch_exists \"origin/$develop_branch\"; then\n\t\t\tgit_do branch \"$develop_branch\" \"origin/$develop_branch\" >/dev/null 2>&1\n\t\telse\n\t\t\tgit_do branch --no-track \"$develop_branch\" \"$master_branch\"\n\t\tfi\n\t\tcreated_gitflow_branch=1\n\tfi\n\n\t# assert the gitflow repo has been correctly initialized\n\tgitflow_is_initialized\n\n\t# switch to develop branch if its newly created\n\tif [ $created_gitflow_branch -eq 1 ]; then\n\t\tgit_do checkout -q \"$develop_branch\"\n\tfi\n\n\t# finally, ask the user for naming conventions (branch and tag prefixes)\n\tif flag force || \\\n\t   ! git config --get gitflow.prefix.feature >/dev/null 2>&1 || \n\t   ! git config --get gitflow.prefix.release >/dev/null 2>&1 || \n\t   ! git config --get gitflow.prefix.hotfix >/dev/null 2>&1 || \n\t   ! git config --get gitflow.prefix.support >/dev/null 2>&1 || \n\t   ! git config --get gitflow.prefix.versiontag >/dev/null 2>&1; then\n\t\techo\n\t\techo \"How to name your supporting branch prefixes?\"\n\tfi\n\n\tlocal prefix\n\n\t# Feature branches\n\tif ! git config --get gitflow.prefix.feature >/dev/null 2>&1 || flag force; then\n\t\tdefault_suggestion=$(git config --get gitflow.prefix.feature || echo feature/)\n\t\tprintf \"Feature branches? [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\t[ \"$answer\" = \"-\" ] && prefix= || prefix=${answer:-$default_suggestion}\n\t\tgit_do config gitflow.prefix.feature \"$prefix\"\n\tfi\n\n\t# Release branches\n\tif ! git config --get gitflow.prefix.release >/dev/null 2>&1 || flag force; then\n\t\tdefault_suggestion=$(git config --get gitflow.prefix.release || echo release/)\n\t\tprintf \"Release branches? [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\t[ \"$answer\" = \"-\" ] && prefix= || prefix=${answer:-$default_suggestion}\n\t\tgit_do config gitflow.prefix.release \"$prefix\"\n\tfi\n\n\n\t# Hotfix branches\n\tif ! git config --get gitflow.prefix.hotfix >/dev/null 2>&1 || flag force; then\n\t\tdefault_suggestion=$(git config --get gitflow.prefix.hotfix || echo hotfix/)\n\t\tprintf \"Hotfix branches? [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\t[ \"$answer\" = \"-\" ] && prefix= || prefix=${answer:-$default_suggestion}\n\t\tgit_do config gitflow.prefix.hotfix \"$prefix\"\n\tfi\n\n\n\t# Support branches\n\tif ! git config --get gitflow.prefix.support >/dev/null 2>&1 || flag force; then\n\t\tdefault_suggestion=$(git config --get gitflow.prefix.support || echo support/)\n\t\tprintf \"Support branches? [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\t[ \"$answer\" = \"-\" ] && prefix= || prefix=${answer:-$default_suggestion}\n\t\tgit_do config gitflow.prefix.support \"$prefix\"\n\tfi\n\n\n\t# Version tag prefix\n\tif ! git config --get gitflow.prefix.versiontag >/dev/null 2>&1 || flag force; then\n\t\tdefault_suggestion=$(git config --get gitflow.prefix.versiontag || echo \"\")\n\t\tprintf \"Version tag prefix? [$default_suggestion] \"\n\t\tif noflag defaults; then\n\t\t\tread answer\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\tfi\n\t\t[ \"$answer\" = \"-\" ] && prefix= || prefix=${answer:-$default_suggestion}\n\t\tgit_do config gitflow.prefix.versiontag \"$prefix\"\n\tfi\n\n\n\t# TODO: what to do with origin?\n}\n\ncmd_help() {\n\tusage\n\texit 0\n}\n"
        },
        {
          "name": "git-flow-release",
          "type": "blob",
          "size": 11.041015625,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\ninit() {\n  require_git_repo\n  require_gitflow_initialized\n  gitflow_load_settings\n  VERSION_PREFIX=$(eval \"echo `git config --get gitflow.prefix.versiontag`\")\n  PREFIX=$(git config --get gitflow.prefix.release)\n}\n\nusage() {\n\techo \"usage: git flow release [list] [-v]\"\n\techo \"       git flow release start [-F] <version> [<base>]\"\n\techo \"       git flow release finish [-FsumpkS] <version>\"\n\techo \"       git flow release publish <name>\"\n\techo \"       git flow release track <name>\"\n}\n\ncmd_default() {\n\tcmd_list \"$@\"\n}\n\ncmd_list() {\n\tDEFINE_boolean verbose false 'verbose (more) output' v\n\tparse_args \"$@\"\n\n\tlocal release_branches\n\tlocal current_branch\n\tlocal short_names\n\trelease_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n\tif [ -z \"$release_branches\" ]; then\n\t\twarn \"No release branches exist.\"\n                warn \"\"\n                warn \"You can start a new release branch:\"\n                warn \"\"\n                warn \"    git flow release start <name> [<base>]\"\n                warn \"\"\n\t\texit 0\n\tfi\n\n\tcurrent_branch=$(git branch --no-color | grep '^\\* ' | grep -v 'no branch' | sed 's/^* //g')\n\tshort_names=$(echo \"$release_branches\" | sed \"s ^$PREFIX  g\")\n\n\t# determine column width first\n\tlocal width=0\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal len=${#branch}\n\t\twidth=$(max $width $len)\n\tdone\n\twidth=$(($width+3))\n\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal fullname=$PREFIX$branch\n\t\tlocal base=$(git merge-base \"$fullname\" \"$DEVELOP_BRANCH\")\n\t\tlocal develop_sha=$(git rev-parse \"$DEVELOP_BRANCH\")\n\t\tlocal branch_sha=$(git rev-parse \"$fullname\")\n\t\tif [ \"$fullname\" = \"$current_branch\" ]; then\n\t\t\tprintf \"* \"\n\t\telse\n\t\t\tprintf \"  \"\n\t\tfi\n\t\tif flag verbose; then\n\t\t\tprintf \"%-${width}s\" \"$branch\"\n\t\t\tif [ \"$branch_sha\" = \"$develop_sha\" ]; then\n\t\t\t\tprintf \"(no commits yet)\"\n\t\t\telse\n\t\t\t\tlocal nicename=$(git rev-parse --short \"$base\")\n\t\t\t\tprintf \"(based on $nicename)\"\n\t\t\tfi\n\t\telse\n\t\t\tprintf \"%s\" \"$branch\"\n\t\tfi\n\t\techo\n\tdone\n}\n\ncmd_help() {\n\tusage\n\texit 0\n}\n\nparse_args() {\n\t# parse options\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n\n\t# read arguments into global variables\n\tVERSION=$1\n\tBRANCH=$PREFIX$VERSION\n}\n\nrequire_version_arg() {\n\tif [ \"$VERSION\" = \"\" ]; then\n\t\twarn \"Missing argument <version>\"\n\t\tusage\n\t\texit 1\n\tfi\n}\n\nrequire_base_is_on_develop() {\n\tif ! git_do branch --no-color --contains \"$BASE\" 2>/dev/null \\\n\t\t\t| sed 's/[* ] //g' \\\n\t  \t\t| grep -q \"^$DEVELOP_BRANCH\\$\"; then\n\t\tdie \"fatal: Given base '$BASE' is not a valid commit on '$DEVELOP_BRANCH'.\"\n\tfi\n}\n\nrequire_no_existing_release_branches() {\n\tlocal release_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n\tlocal first_branch=$(echo ${release_branches} | head -n1)\n\tfirst_branch=${first_branch#$PREFIX}\n\t[ -z \"$release_branches\" ] || \\\n\t\tdie \"There is an existing release branch ($first_branch). Finish that one first.\"\n}\n\ncmd_start() {\n\tDEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n\tparse_args \"$@\"\n\tBASE=${2:-$DEVELOP_BRANCH}\n\trequire_version_arg\n\trequire_base_is_on_develop\n\trequire_no_existing_release_branches\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch_absent \"$BRANCH\"\n\trequire_tag_absent \"$VERSION_PREFIX$VERSION\"\n\tif flag fetch; then\n\t\tgit_do fetch -q \"$ORIGIN\" \"$DEVELOP_BRANCH\"\n\tfi\n\tif has \"$ORIGIN/$DEVELOP_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$DEVELOP_BRANCH\" \"$ORIGIN/$DEVELOP_BRANCH\"\n\tfi\n\n\t# create branch\n\tgit_do checkout -b \"$BRANCH\" \"$BASE\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new branch '$BRANCH' was created, based on '$BASE'\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n\techo \"Follow-up actions:\"\n\techo \"- Bump the version number now!\"\n\techo \"- Start committing last-minute fixes in preparing your release\"\n\techo \"- When done, run:\"\n\techo\n\techo \"     git flow release finish '$VERSION'\"\n\techo\n}\n\ncmd_finish() {\n\tDEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n\tDEFINE_boolean sign false \"sign the release tag cryptographically\" s\n\tDEFINE_string signingkey \"\" \"use the given GPG-key for the digital signature (implies -s)\" u\n\tDEFINE_string message \"\" \"use the given tag message\" m\n\tDEFINE_string messagefile \"\" \"use the contents of the given file as a tag message\" f\n\tDEFINE_boolean push false \"push to $ORIGIN after performing finish\" p\n\tDEFINE_boolean keep false \"keep branch after performing finish\" k\n\tDEFINE_boolean notag false \"don't tag this release\" n\n\tDEFINE_boolean squash false \"squash release during merge\" S\n\n\tparse_args \"$@\"\n\trequire_version_arg\n\n\t# handle flags that imply other flags\n\tif [ \"$FLAGS_signingkey\" != \"\" ]; then\n\t\tFLAGS_sign=$FLAGS_TRUE\n\tfi\n\n\t# sanity checks\n\trequire_branch \"$BRANCH\"\n\trequire_clean_working_tree\n\tif flag fetch; then\n\t\tgit_do fetch -q \"$ORIGIN\" \"$MASTER_BRANCH\" || \\\n\t\t  die \"Could not fetch $MASTER_BRANCH from $ORIGIN.\"\n\t\tgit_do fetch -q \"$ORIGIN\" \"$DEVELOP_BRANCH\" || \\\n\t\t  die \"Could not fetch $DEVELOP_BRANCH from $ORIGIN.\"\n\tfi\n\tif has \"$ORIGIN/$MASTER_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$MASTER_BRANCH\" \"$ORIGIN/$MASTER_BRANCH\"\n\tfi\n\tif has \"$ORIGIN/$DEVELOP_BRANCH\" $(git_remote_branches); then\n\t\trequire_branches_equal \"$DEVELOP_BRANCH\" \"$ORIGIN/$DEVELOP_BRANCH\"\n\tfi\n\n\t# try to merge into master\n\t# in case a previous attempt to finish this release branch has failed,\n\t# but the merge into master was successful, we skip it now\n\tif ! git_is_branch_merged_into \"$BRANCH\" \"$MASTER_BRANCH\"; then\n\t\tgit_do checkout \"$MASTER_BRANCH\" || \\\n\t\t  die \"Could not check out $MASTER_BRANCH.\"\n\t\tif noflag squash; then\n\t\t\tgit_do merge --no-ff \"$BRANCH\" || \\\n\t\t\t\tdie \"There were merge conflicts.\"\n\t\t\t\t# TODO: What do we do now?\n\t\telse\n\t\t\tgit_do merge --squash \"$BRANCH\" || \\\n\t\t\t\tdie \"There were merge conflicts.\"\n\t\t\tgit_do commit\n\t\tfi\n\tfi\n\n\tif noflag notag; then\n\t\t# try to tag the release\n\t\t# in case a previous attempt to finish this release branch has failed,\n\t\t# but the tag was set successful, we skip it now\n\t\tlocal tagname=$VERSION_PREFIX$VERSION\n\t\tif ! git_tag_exists \"$tagname\"; then\n\t\t\tlocal opts=\"-a\"\n\t\t\tflag sign && opts=\"$opts -s\"\n\t\t\t[ \"$FLAGS_signingkey\" != \"\" ] && opts=\"$opts -u '$FLAGS_signingkey'\"\n\t\t\t[ \"$FLAGS_message\" != \"\" ] && opts=\"$opts -m '$FLAGS_message'\"\n\t\t\t[ \"$FLAGS_messagefile\" != \"\" ] && opts=\"$opts -F '$FLAGS_messagefile'\"\n\t\t\teval git_do tag $opts \"$tagname\" \"$BRANCH\" || \\\n\t\t\tdie \"Tagging failed. Please run finish again to retry.\"\n\t\tfi\n\tfi\n\n\t# try to merge into develop\n\t# in case a previous attempt to finish this release branch has failed,\n\t# but the merge into develop was successful, we skip it now\n\tif ! git_is_branch_merged_into \"$BRANCH\" \"$DEVELOP_BRANCH\"; then\n\t\tgit_do checkout \"$DEVELOP_BRANCH\" || \\\n\t\t  die \"Could not check out $DEVELOP_BRANCH.\"\n\n\t\t# TODO: Actually, accounting for 'git describe' pays, so we should\n\t\t# ideally git merge --no-ff $tagname here, instead!\n\t\tif noflag squash; then\n\t\t\tgit_do merge --no-ff \"$BRANCH\" || \\\n\t\t\t\tdie \"There were merge conflicts.\"\n\t\t\t\t# TODO: What do we do now?\n\t\telse\n\t\t\tgit_do merge --squash \"$BRANCH\" || \\\n\t\t\t\tdie \"There were merge conflicts.\"\n\t\t\t\t# TODO: What do we do now?\n\t\t\tgit_do commit\n\t\tfi\n\tfi\n\n\t# delete branch\n\tif noflag keep; then\n\t\tif [ \"$BRANCH\" = \"$(git_current_branch)\" ]; then\n\t\t\tgit_do checkout \"$MASTER_BRANCH\"\n\t\tfi\n\t\tgit_do branch -d \"$BRANCH\"\n\tfi\n\n\tif flag push; then\n\t\tgit_do push \"$ORIGIN\" \"$DEVELOP_BRANCH\" || \\\n\t\t\tdie \"Could not push to $DEVELOP_BRANCH from $ORIGIN.\"\n\t\tgit_do push \"$ORIGIN\" \"$MASTER_BRANCH\" || \\\n\t\t\tdie \"Could not push to $MASTER_BRANCH from $ORIGIN.\"\n\t\tif noflag notag; then\n\t\t\tgit_do push --tags \"$ORIGIN\" || \\\n\t\t\t  die \"Could not push tags to $ORIGIN.\"\n\t\tfi\n\t\tgit_do push \"$ORIGIN\" :\"$BRANCH\" || \\\n\t\t\tdie \"Could not delete the remote $BRANCH in $ORIGIN.\"\n\tfi\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- Latest objects have been fetched from '$ORIGIN'\"\n\techo \"- Release branch has been merged into '$MASTER_BRANCH'\"\n\tif noflag notag; then\n\t\techo \"- The release was tagged '$tagname'\"\n\tfi\n\techo \"- Release branch has been back-merged into '$DEVELOP_BRANCH'\"\n\tif flag keep; then\n\t\techo \"- Release branch '$BRANCH' is still available\"\n\telse\n\t\techo \"- Release branch '$BRANCH' has been deleted\"\n\tfi\n\tif flag push; then\n\t\techo \"- '$DEVELOP_BRANCH', '$MASTER_BRANCH' and tags have been pushed to '$ORIGIN'\"\n\t\techo \"- Release branch '$BRANCH' in '$ORIGIN' has been deleted.\"\n\tfi\n\techo\n}\n\ncmd_publish() {\n\tparse_args \"$@\"\n\trequire_version_arg\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch \"$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\trequire_branch_absent \"$ORIGIN/$BRANCH\"\n\n\t# create remote branch\n\tgit_do push \"$ORIGIN\" \"$BRANCH:refs/heads/$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\n\t# configure remote tracking\n\tgit_do config \"branch.$BRANCH.remote\" \"$ORIGIN\"\n\tgit_do config \"branch.$BRANCH.merge\" \"refs/heads/$BRANCH\"\n\tgit_do checkout \"$BRANCH\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new remote branch '$BRANCH' was created\"\n\techo \"- The local branch '$BRANCH' was configured to track the remote branch\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n\ncmd_track() {\n\tparse_args \"$@\"\n\trequire_version_arg\n\n\t# sanity checks\n\trequire_clean_working_tree\n\trequire_branch_absent \"$BRANCH\"\n\tgit_do fetch -q \"$ORIGIN\"\n\trequire_branch \"$ORIGIN/$BRANCH\"\n\n\t# create tracking branch\n\tgit_do checkout -b \"$BRANCH\" \"$ORIGIN/$BRANCH\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new remote tracking branch '$BRANCH' was created\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n"
        },
        {
          "name": "git-flow-support",
          "type": "blob",
          "size": 5.041015625,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\ninit() {\n  require_git_repo\n  require_gitflow_initialized\n  gitflow_load_settings\n  VERSION_PREFIX=$(eval \"echo `git config --get gitflow.prefix.versiontag`\")\n  PREFIX=$(git config --get gitflow.prefix.support)\n}\n\nwarn \"note: The support subcommand is still very EXPERIMENTAL!\"\nwarn \"note: DO NOT use it in a production situation.\"\n\nusage() {\n\techo \"usage: git flow support [list] [-v]\"\n\techo \"       git flow support start [-F] <version> <base>\"\n}\n\ncmd_default() {\n\tcmd_list \"$@\"\n}\n\ncmd_list() {\n\tDEFINE_boolean verbose false 'verbose (more) output' v\n\tparse_args \"$@\"\n\n\tlocal support_branches\n\tlocal current_branch\n\tlocal short_names\n\tsupport_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n\tif [ -z \"$support_branches\" ]; then\n\t\twarn \"No support branches exist.\"\n                warn \"\"\n                warn \"You can start a new support branch:\"\n                warn \"\"\n                warn \"    git flow support start <name> <base>\"\n                warn \"\"\n\t\texit 0\n\tfi\n\tcurrent_branch=$(git branch --no-color | grep '^\\* ' | grep -v 'no branch' | sed 's/^* //g')\n\tshort_names=$(echo \"$support_branches\" | sed \"s ^$PREFIX  g\")\n\n\t# determine column width first\n\tlocal width=0\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal len=${#branch}\n\t\twidth=$(max $width $len)\n\tdone\n\twidth=$(($width+3))\n\n\tlocal branch\n\tfor branch in $short_names; do\n\t\tlocal fullname=$PREFIX$branch\n\t\tlocal base=$(git merge-base \"$fullname\" \"$MASTER_BRANCH\")\n\t\tlocal master_sha=$(git rev-parse \"$MASTER_BRANCH\")\n\t\tlocal branch_sha=$(git rev-parse \"$fullname\")\n\t\tif [ \"$fullname\" = \"$current_branch\" ]; then\n\t\t\tprintf \"* \"\n\t\telse\n\t\t\tprintf \"  \"\n\t\tfi\n\t\tif flag verbose; then\n\t\t\tprintf \"%-${width}s\" \"$branch\"\n\t\t\tif [ \"$branch_sha\" = \"$master_sha\" ]; then\n\t\t\t\tprintf \"(no commits yet)\"\n\t\t\telse\n\t\t\t\tlocal tagname=$(git name-rev --tags --no-undefined --name-only \"$base\")\n\t\t\t\tlocal nicename\n\t\t\t\tif [ \"$tagname\" != \"\" ]; then\n\t\t\t\t\tnicename=$tagname\n\t\t\t\telse\n\t\t\t\t\tnicename=$(git rev-parse --short \"$base\")\n\t\t\t\tfi\n\t\t\t\tprintf \"(based on $nicename)\"\n\t\t\tfi\n\t\telse\n\t\t\tprintf \"%s\" \"$branch\"\n\t\tfi\n\t\techo\n\tdone\n}\n\ncmd_help() {\n\tusage\n\texit 0\n}\n\nparse_args() {\n\t# parse options\n\tFLAGS \"$@\" || exit $?\n\teval set -- \"${FLAGS_ARGV}\"\n\n\t# read arguments into global variables\n\tVERSION=$1\n\tBASE=$2\n\tBRANCH=$PREFIX$VERSION\n}\n\nrequire_version_arg() {\n\tif [ \"$VERSION\" = \"\" ]; then\n\t\twarn \"Missing argument <version>\"\n\t\tusage\n\t\texit 1\n\tfi\n}\n\nrequire_base_arg() {\n\tif [ \"$BASE\" = \"\" ]; then\n\t\twarn \"Missing argument <base>\"\n\t\tusage\n\t\texit 1\n\tfi\n}\n\nrequire_base_is_on_master() {\n\tif ! git branch --no-color --contains \"$BASE\" 2>/dev/null \\\n\t\t\t| sed 's/[* ] //g' \\\n\t  \t\t| grep -q \"^$MASTER_BRANCH\\$\"; then\n\t\tdie \"fatal: Given base '$BASE' is not a valid commit on '$MASTER_BRANCH'.\"\n\tfi\n}\n\ncmd_start() {\n\tDEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n\tparse_args \"$@\"\n\trequire_version_arg\n\trequire_base_arg\n\trequire_base_is_on_master\n\n\t# sanity checks\n\trequire_clean_working_tree\n\n\t# fetch remote changes\n\tif flag fetch; then\n\t\tgit_do fetch -q \"$ORIGIN\" \"$BASE\"\n\tfi\n\trequire_branch_absent \"$BRANCH\"\n\n\t# create branch\n\tgit_do checkout -b \"$BRANCH\" \"$BASE\"\n\n\techo\n\techo \"Summary of actions:\"\n\techo \"- A new branch '$BRANCH' was created, based on '$BASE'\"\n\techo \"- You are now on branch '$BRANCH'\"\n\techo\n}\n"
        },
        {
          "name": "git-flow-version",
          "type": "blob",
          "size": 1.9638671875,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\nGITFLOW_VERSION=0.4.2-pre\n\nusage() {\n\techo \"usage: git flow version\"\n}\n\ncmd_default() {\n\techo \"$GITFLOW_VERSION\"\n}\n\ncmd_help() {\n\tusage\n\texit 0\n}\n"
        },
        {
          "name": "gitflow-common",
          "type": "blob",
          "size": 8.771484375,
          "content": "#\n# git-flow -- A collection of Git extensions to provide high-level\n# repository operations for Vincent Driessen's branching model.\n#\n# Original blog post presenting this model is found at:\n#    http://nvie.com/git-model\n#\n# Feel free to contribute to this project at:\n#    http://github.com/nvie/gitflow\n#\n# Copyright 2010 Vincent Driessen. All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#    1. Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n# \n#    2. Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n# \n# THIS SOFTWARE IS PROVIDED BY VINCENT DRIESSEN ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL VINCENT DRIESSEN OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The views and conclusions contained in the software and documentation are\n# those of the authors and should not be interpreted as representing official\n# policies, either expressed or implied, of Vincent Driessen.\n#\n\n#\n# Common functionality\n#\n\n# shell output\nwarn() { echo \"$@\" >&2; }\ndie() { warn \"$@\"; exit 1; }\n\nescape() {\n\techo \"$1\" | sed 's/\\([\\.\\$\\*]\\)/\\\\\\1/g'\n}\n\n# set logic\nhas() {\n\tlocal item=$1; shift\n\techo \" $@ \" | grep -q \" $(escape $item) \"\n}\n\n# basic math\nmin() { [ \"$1\" -le \"$2\" ] && echo \"$1\" || echo \"$2\"; }\nmax() { [ \"$1\" -ge \"$2\" ] && echo \"$1\" || echo \"$2\"; }\n\n# basic string matching\nstartswith() { [ \"$1\" != \"${1#$2}\" ]; }\nendswith() { [ \"$1\" != \"${1%$2}\" ]; }\n\n# convenience functions for checking shFlags flags\nflag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -eq $FLAGS_TRUE ]; }\nnoflag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -ne $FLAGS_TRUE ]; }\n\n#\n# Git specific common functionality\n#\n\ngit_do() {\n  # equivalent to git, used to indicate actions that make modifications\n  if flag show_commands; then\n    echo \"git $@\" >&2\n  fi\n  git \"$@\"\n}\n\ngit_local_branches() { git branch --no-color | sed 's/^[* ] //'; }\ngit_remote_branches() { git branch -r --no-color | sed 's/^[* ] //'; }\ngit_all_branches() { ( git branch --no-color; git branch -r --no-color) | sed 's/^[* ] //'; }\ngit_all_tags() { git tag; }\n\ngit_current_branch() {\n\tgit branch --no-color | grep '^\\* ' | grep -v 'no branch' | sed 's/^* //g'\n}\n\ngit_is_clean_working_tree() {\n\tif ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code; then\n\t\treturn 1\n\telif ! git diff-index --cached --quiet --ignore-submodules HEAD --; then\n\t\treturn 2\n\telse\n\t\treturn 0\n\tfi\n}\n\ngit_repo_is_headless() {\n\t! git rev-parse --quiet --verify HEAD >/dev/null 2>&1\n}\n\ngit_local_branch_exists() {\n\thas $1 $(git_local_branches)\n}\n\ngit_remote_branch_exists() {\n\thas $1 $(git_remote_branches)\n}\n\ngit_branch_exists() {\n\thas $1 $(git_all_branches)\n}\n\ngit_tag_exists() {\n\thas $1 $(git_all_tags)\n}\n\n#\n# git_compare_branches()\n#\n# Tests whether branches and their \"origin\" counterparts have diverged and need\n# merging first. It returns error codes to provide more detail, like so:\n#\n# 0    Branch heads point to the same commit\n# 1    First given branch needs fast-forwarding\n# 2    Second given branch needs fast-forwarding\n# 3    Branch needs a real merge\n# 4    There is no merge base, i.e. the branches have no common ancestors\n#\ngit_compare_branches() {\n\tlocal commit1=$(git rev-parse \"$1\")\n\tlocal commit2=$(git rev-parse \"$2\")\n\tif [ \"$commit1\" != \"$commit2\" ]; then\n\t\tlocal base=$(git merge-base \"$commit1\" \"$commit2\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\treturn 4\n\t\telif [ \"$commit1\" = \"$base\" ]; then\n\t\t\treturn 1\n\t\telif [ \"$commit2\" = \"$base\" ]; then\n\t\t\treturn 2\n\t\telse\n\t\t\treturn 3\n\t\tfi\n\telse\n\t\treturn 0\n\tfi\n}\n\n#\n# git_is_branch_merged_into()\n#\n# Checks whether branch $1 is succesfully merged into $2\n#\ngit_is_branch_merged_into() {\n\tlocal subject=$1\n\tlocal base=$2\n\tlocal all_merges=\"$(git branch --no-color --contains $subject | sed 's/^[* ] //')\"\n\thas $base $all_merges\n}\n\n#\n# gitflow specific common functionality\n#\n\n# check if this repo has been inited for gitflow\ngitflow_has_master_configured() {\n\tlocal master=$(git config --get gitflow.branch.master)\n\t[ \"$master\" != \"\" ] && git_local_branch_exists \"$master\"\n}\n\ngitflow_has_develop_configured() {\n\tlocal develop=$(git config --get gitflow.branch.develop)\n\t[ \"$develop\" != \"\" ] && git_local_branch_exists \"$develop\"\n}\n\ngitflow_has_prefixes_configured() {\n\tgit config --get gitflow.prefix.feature >/dev/null 2>&1     && \\\n\tgit config --get gitflow.prefix.release >/dev/null 2>&1     && \\\n\tgit config --get gitflow.prefix.hotfix >/dev/null 2>&1      && \\\n\tgit config --get gitflow.prefix.support >/dev/null 2>&1     && \\\n\tgit config --get gitflow.prefix.versiontag >/dev/null 2>&1\n}\n\ngitflow_is_initialized() {\n\tgitflow_has_master_configured                    && \\\n\tgitflow_has_develop_configured                   && \\\n\t[ \"$(git config --get gitflow.branch.master)\" !=    \\\n\t  \"$(git config --get gitflow.branch.develop)\" ] && \\\n\tgitflow_has_prefixes_configured\n}\n\n# loading settings that can be overridden using git config\ngitflow_load_settings() {\n\texport DOT_GIT_DIR=$(git rev-parse --git-dir 2>/dev/null)\n\texport MASTER_BRANCH=$(git config --get gitflow.branch.master)\n\texport DEVELOP_BRANCH=$(git config --get gitflow.branch.develop)\n\texport ORIGIN=$(git config --get gitflow.origin || echo origin)\n}\n\n#\n# gitflow_resolve_nameprefix\n#\n# Inputs:\n# $1 = name prefix to resolve\n# $2 = branch prefix to use\n#\n# Searches branch names from git_local_branches() to look for a unique\n# branch name whose name starts with the given name prefix.\n#\n# There are multiple exit codes possible:\n# 0: The unambiguous full name of the branch is written to stdout\n#    (success)\n# 1: No match is found.\n# 2: Multiple matches found. These matches are written to stderr\n#\ngitflow_resolve_nameprefix() {\n\tlocal name=$1\n\tlocal prefix=$2\n\tlocal matches\n\tlocal num_matches\n\n\t# first, check if there is a perfect match\n\tif git_local_branch_exists \"$prefix$name\"; then\n\t\techo \"$name\"\n\t\treturn 0\n\tfi\n\n\tmatches=$(echo \"$(git_local_branches)\" | grep \"^$(escape \"$prefix$name\")\")\n\tnum_matches=$(echo \"$matches\" | wc -l)\n\tif [ -z \"$matches\" ]; then\n\t\t# no prefix match, so take it literally\n\t\twarn \"No branch matches prefix '$name'\"\n\t\treturn 1\n\telse\n\t\tif [ $num_matches -eq 1 ]; then\n\t\t\techo \"${matches#$prefix}\"\n\t\t\treturn 0\n\t\telse\n\t\t\t# multiple matches, cannot decide\n\t\t\twarn \"Multiple branches match prefix '$name':\"\n\t\t\tfor match in $matches; do\n\t\t\t\twarn \"- $match\"\n\t\t\tdone\n\t\t\treturn 2\n\t\tfi\n\tfi\n}\n\n#\n# Assertions for use in git-flow subcommands\n#\n\nrequire_git_repo() {\n\tif ! git rev-parse --git-dir >/dev/null 2>&1; then\n\t\tdie \"fatal: Not a git repository\"\n\tfi\n}\n\nrequire_gitflow_initialized() {\n\tif ! gitflow_is_initialized; then\n\t\tdie \"fatal: Not a gitflow-enabled repo yet. Please run \\\"git flow init\\\" first.\"\n\tfi\n}\n\nrequire_clean_working_tree() {\n\tgit_is_clean_working_tree\n\tlocal result=$?\n\tif [ $result -eq 1 ]; then\n\t\tdie \"fatal: Working tree contains unstaged changes. Aborting.\"\n\tfi\n\tif [ $result -eq 2 ]; then\n\t\tdie \"fatal: Index contains uncommited changes. Aborting.\"\n\tfi\n}\n\nrequire_local_branch() {\n\tif ! git_local_branch_exists $1; then\n\t\tdie \"fatal: Local branch '$1' does not exist and is required.\"\n\tfi\n}\n\nrequire_remote_branch() {\n\tif ! has $1 $(git_remote_branches); then\n\t\tdie \"Remote branch '$1' does not exist and is required.\"\n\tfi\n}\n\nrequire_branch() {\n\tif ! has $1 $(git_all_branches); then\n\t\tdie \"Branch '$1' does not exist and is required.\"\n\tfi\n}\n\nrequire_branch_absent() {\n\tif has $1 $(git_all_branches); then\n\t\tdie \"Branch '$1' already exists. Pick another name.\"\n\tfi\n}\n\nrequire_tag_absent() {\n\tfor tag in $(git_all_tags); do\n\t\tif [ \"$1\" = \"$tag\" ]; then\n\t\t\tdie \"Tag '$1' already exists. Pick another name.\"\n\t\tfi\n\tdone\n}\n\nrequire_branches_equal() {\n\trequire_local_branch \"$1\"\n\trequire_remote_branch \"$2\"\n\tgit_compare_branches \"$1\" \"$2\"\n\tlocal status=$?\n\tif [ $status -gt 0 ]; then\n\t\twarn \"Branches '$1' and '$2' have diverged.\"\n\t\tif [ $status -eq 1 ]; then\n\t\t\tdie \"And branch '$1' may be fast-forwarded.\"\n\t\telif [ $status -eq 2 ]; then\n\t\t\t# Warn here, since there is no harm in being ahead\n\t\t\twarn \"And local branch '$1' is ahead of '$2'.\"\n\t\telse\n\t\t\tdie \"Branches need merging first.\"\n\t\tfi\n\tfi\n}\n"
        },
        {
          "name": "gitflow-shFlags",
          "type": "blob",
          "size": 0.0185546875,
          "content": "shFlags/src/shflags"
        },
        {
          "name": "shFlags",
          "type": "commit",
          "content": null
        }
      ]
    }
  ]
}