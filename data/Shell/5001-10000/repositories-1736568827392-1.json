{
  "metadata": {
    "timestamp": 1736568827392,
    "page": 1,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "brendangregg/perf-tools",
      "stars": 9963,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.6025390625,
          "content": "GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    {description}\n    Copyright (C) {year}  {fullname}\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  {signature of Ty Coon}, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.90625,
          "content": "perf-tools\n==========\n\nA miscellaneous collection of in-development and unsupported performance analysis tools for Linux ftrace and perf_events (aka the \"perf\" command). Both ftrace and perf are core Linux tracing tools, included in the kernel source. Your system probably has ftrace already, and perf is often just a package add (see Prerequisites).\n\nThese tools are designed to be easy to install (fewest dependencies), provide advanced performance observability, and be simple to use: do one thing and do it well. This collection was created by Brendan Gregg (author of the DTraceToolkit).\n\nMany of these tools employ workarounds so that functionality is possible on existing Linux kernels. Because of this, many tools have caveats (see man pages), and their implementation should be considered a placeholder until future kernel features, or new tracing subsystems, are added.\n\nThese are intended for Linux 3.2 and newer kernels. For Linux 2.6.x, see Warnings.\n\n## Presentation\n\nThese tools were introduced in the USENIX LISA 2014 presentation: Linux Performance Analysis: New Tools and Old Secrets\n\n- slides: http://www.slideshare.net/brendangregg/linux-performance-analysis-new-tools-and-old-secrets\n- video: https://www.usenix.org/conference/lisa14/conference-program/presentation/gregg\n\n## Contents\n<center><a href=\"images/perf-tools_2016.png\"><img src=\"images/perf-tools_2016.png\" border=0 width=700></a></center>\n\nUsing ftrace:\n\n- [iosnoop](iosnoop): trace disk I/O with details including latency. [Examples](examples/iosnoop_example.txt).\n- [iolatency](iolatency): summarize disk I/O latency as a histogram. [Examples](examples/iolatency_example.txt).\n- [execsnoop](execsnoop): trace process exec() with command line argument details. [Examples](examples/execsnoop_example.txt).\n- [opensnoop](opensnoop): trace open() syscalls showing filenames. [Examples](examples/opensnoop_example.txt).\n- [killsnoop](killsnoop): trace kill() signals showing process and signal details. [Examples](examples/killsnoop_example.txt).\n- fs/[cachestat](fs/cachestat): basic cache hit/miss statistics for the Linux page cache. [Examples](examples/cachestat_example.txt).\n- net/[tcpretrans](net/tcpretrans): show TCP retransmits, with address and other details. [Examples](examples/tcpretrans_example.txt).\n- system/[tpoint](system/tpoint): trace a given tracepoint. [Examples](examples/tpoint_example.txt).\n- kernel/[funccount](kernel/funccount): count kernel function calls, matching a string with wildcards. [Examples](examples/funccount_example.txt).\n- kernel/[functrace](kernel/functrace): trace kernel function calls, matching a string with wildcards. [Examples](examples/functrace_example.txt).\n- kernel/[funcslower](kernel/funcslower): trace kernel functions slower than a threshold. [Examples](examples/funcslower_example.txt).\n- kernel/[funcgraph](kernel/funcgraph): trace a graph of kernel function calls, showing children and times. [Examples](examples/funcgraph_example.txt).\n- kernel/[kprobe](kernel/kprobe): dynamically trace a kernel function call or its return, with variables. [Examples](examples/kprobe_example.txt).\n- user/[uprobe](user/uprobe): dynamically trace a user-level function call or its return, with variables. [Examples](examples/uprobe_example.txt).\n- tools/[reset-ftrace](tools/reset-ftrace): reset ftrace state if needed. [Examples](examples/reset-ftrace_example.txt).\n\nUsing perf_events:\n\n- misc/[perf-stat-hist](misc/perf-stat-hist): power-of aggregations for tracepoint variables. [Examples](examples/perf-stat-hist_example.txt).\n- [syscount](syscount): count syscalls by syscall or process. [Examples](examples/syscount_example.txt).\n- disk/[bitesize](disk/bitesize): histogram summary of disk I/O size. [Examples](examples/bitesize_example.txt).\n\nUsing eBPF:\n\n- As a preview of things to come, see the bcc tracing [Tools section](https://github.com/iovisor/bcc/blob/master/README.md#tracing). These use [bcc](https://github.com/iovisor/bcc), a front end for using [eBPF](http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html). bcc+eBPF will allow some of these tools to be rewritten and improved, and additional tools to be created.\n\n## Screenshots\n\nShowing new processes and arguments:\n\n<pre># <b>./execsnoop</b> \nTracing exec()s. Ctrl-C to end.\n   PID   PPID ARGS\n 22898  22004 man ls\n 22905  22898 preconv -e UTF-8\n 22908  22898 pager -s\n 22907  22898 nroff -mandoc -rLL=164n -rLT=164n -Tutf8\n 22906  22898 tbl\n 22911  22910 locale charmap\n 22912  22907 groff -mtty-char -Tutf8 -mandoc -rLL=164n -rLT=164n\n 22913  22912 troff -mtty-char -mandoc -rLL=164n -rLT=164n -Tutf8\n 22914  22912 grotty\n</pre>\n\nMeasuring block device I/O latency from queue insert to completion:\n\n<pre># <b>./iolatency -Q</b>\nTracing block I/O. Output every 1 seconds. Ctrl-C to end.\n\n  &gt;=(ms) .. &lt;(ms)   : I/O      |Distribution                          |\n       0 -> 1       : 1913     |######################################|\n       1 -> 2       : 438      |#########                             |\n       2 -> 4       : 100      |##                                    |\n       4 -> 8       : 145      |###                                   |\n       8 -> 16      : 43       |#                                     |\n      16 -> 32      : 43       |#                                     |\n      32 -> 64      : 1        |#                                     |\n\n[...]\n</pre>\n\nTracing the block:block_rq_insert tracepoint, with kernel stack traces, and only for reads:\n\n<pre># <b>./tpoint -s block:block_rq_insert 'rwbs ~ \"*R*\"'</b>\n   cksum-11908 [000] d... 7269839.919098: block_rq_insert: 202,1 R 0 () 736560 + 136 [cksum]\n   cksum-11908 [000] d... 7269839.919107: <stack trace>\n => __elv_add_request\n => blk_flush_plug_list\n => blk_finish_plug\n => __do_page_cache_readahead\n => ondemand_readahead\n => page_cache_async_readahead\n => generic_file_read_iter\n => new_sync_read\n => vfs_read\n => SyS_read\n => system_call_fastpath\n\n[...]\n</pre>\n\nCount kernel function calls beginning with \"bio_\", summarize every second:\n\n<pre># <b>./funccount -i 1 'bio_*'</b>\nTracing \"bio_*\"... Ctrl-C to end.\n\nFUNC                              COUNT\nbio_attempt_back_merge               26\nbio_get_nr_vecs                     361\nbio_alloc                           536\nbio_alloc_bioset                    536\nbio_endio                           536\nbio_free                            536\nbio_fs_destructor                   536\nbio_init                            536\nbio_integrity_enabled               536\nbio_put                             729\nbio_add_page                       1004\n\n[...]\n</pre>\n\nThere are many more examples in the [examples](examples) directory. Also see the [man pages](man/man8).\n\n## Prerequisites\n\nThe intent is as few as possible. Eg, a Linux 3.2 server without debuginfo. See the tool man page for specifics.\n\n### ftrace\n\nFTRACE configured in the kernel. You may already have this configured and available in your kernel version, as FTRACE was first added in 2.6.27. This requires CONFIG_FTRACE and other FTRACE options depending on the tool. Some tools (eg, funccount) require CONFIG_FUNCTION_PROFILER.\n\n### perf_events\n\nRequires the \"perf\" command to be installed. This is in the linux-tools-common package. After installing that, perf may tell you to install an additional linux-tools package (linux-tools-_kernel_version_). perf can also be built under tools/perf in the kernel source. See [perf_events Prerequisites](http://www.brendangregg.com/perf.html#Prerequisites) for more details about getting perf_events to work fully.\n\n### debugfs\n\nRequires a kernel with CONFIG_DEBUG_FS option enabled. As with FTRACE, this may already be enabled (debugfs was added in 2.6.10-rc3). The debugfs also needs to be mounted:\n\n```\n# mount -t debugfs none /sys/kernel/debug\n```\n\n### awk\n\nMany of there scripts use awk, and will try to use either mawk or gawk depending on the desired behavior: mawk for buffered output (because of its speed), and gawk for synchronous output (as fflush() works, allowing more efficient grouping of writes).\n\n## Install\n\nThese are just scripts. Either grab everything:\n\n```\ngit clone --depth 1 https://github.com/brendangregg/perf-tools\n```\n\nOr use the raw links on github to download individual scripts. Eg:\n\n```\nwget https://raw.githubusercontent.com/brendangregg/perf-tools/master/iosnoop\n```\n\nThis preserves tabs (which copy-n-paste can mess up).\n\n## Warnings\n\nFtrace was first added to Linux 2.6.27, and perf_events to Linux 2.6.31. These early versions had kernel bugs, and lockups and panics have been reported on 2.6.32 series kernels. This includes CentOS 6.x. If you must analyze older kernels, these tools may only be useful in a fault-tolerant environment, such as a lab with simulated issues. These tools have been primarily developed on Linux 3.2 and later kernels.\n\nDepending on the tool, there may also be overhead incurred. See the next section.\n\n## Internals and Overhead\n\nperf_events is evolving. This collection began development circa Linux 3.16, with Linux 3.2 servers as the main target, at a time when perf_events lacks certain programmatic capabilities (eg, custom in-kernel aggregations). It's possible these will be added in a forthcoming kernel release. Until then, many of these tools employ workarounds, tricks, and hacks in order to work. Some of these tools pass event data to user space for post-processing, which costs much higher overhead than in-kernel aggregations. The overhead of each tool is described in its man page.\n\n__WARNING__: In _extreme_ cases, your target application may run 5x slower when using these tools. Depending on the tool and kernel version, there may also be the risk of kernel panics. Read the program header for warnings, and test before use.\n\nIf the overhead is a problem, these tools can be improved. If a tool doesn't already, it could be rewritten in C to use perf_events_open() and mmap() for the trace buffer. It could also implement frequency counts in C, and operate on mmap() directly, rather than using awk/Perl/Python. Additional improvements are possible for ftrace-based tools, such as use of snapshots and per-instance buffers.\n\nSome of these tools are intended as short-term workarounds until more kernel capabilities exist, at which point they can be substantially rewritten. Older versions of these tools will be kept in this repository, for older kernel versions.\n\nAs my main target is a fleet of Linux 3.2 servers that do not have debuginfo, these tools try not to require it. At times, this makes the tool more brittle than it needs to be, as I'm employing workarounds (that may be kernel version and platform specific) instead of using debuginfo information (which can be generic). See the man page for detailed prerequisites for each tool.\n\nI've tried to use perf_events (\"perf\") where possible, since that interface has been developed for multi-user use. For various reasons I've often needed to use ftrace instead. ftrace is surprisingly powerful (thanks Steven Rostedt!), and not all of its features are exposed via perf, or in common usage. This tool collection is in some ways a demonstration of hidden Linux features using ftrace.\n\nSince things are changing, it's very possible you may find some tools don't work on your Linux kernel version. Some expertise and assembly will be required to fix them.\n\n## Links\n\nA case study and summary:\n\n- 13 Aug 2014: http://lwn.net/Articles/608497 Ftrace: The hidden light switch\n\nRelated articles:\n\n- 28 Jun 2015: http://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html\n- 31 Dec 2014: http://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html\n- 06 Sep 2014: http://www.brendangregg.com/blog/2014-09-06/linux-ftrace-tcp-retransmit-tracing.html\n- 28 Jul 2014: http://www.brendangregg.com/blog/2014-07-28/execsnoop-for-linux.html\n- 25 Jul 2014: http://www.brendangregg.com/blog/2014-07-25/opensnoop-for-linux.html\n- 23 Jul 2014: http://www.brendangregg.com/blog/2014-07-23/linux-iosnoop-latency-heat-maps.html\n- 16 Jul 2014: http://www.brendangregg.com/blog/2014-07-16/iosnoop-for-linux.html\n- 10 Jul 2014: http://www.brendangregg.com/blog/2014-07-10/perf-hacktogram.html\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "deprecated",
          "type": "tree",
          "content": null
        },
        {
          "name": "disk",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "execsnoop",
          "type": "blob",
          "size": 8.4853515625,
          "content": "#!/bin/bash\n#\n# execsnoop - trace process exec() with arguments.\n#             Written using Linux ftrace.\n#\n# This shows the execution of new processes, especially short-lived ones that\n# can be missed by sampling tools such as top(1).\n#\n# USAGE: ./execsnoop [-hrt] [-n name]\n#\n# REQUIREMENTS: FTRACE and KPROBE CONFIG, sched:sched_process_fork tracepoint,\n# and either the sys_execve, stub_execve or do_execve kernel function. You may\n# already have these on recent kernels. And awk.\n#\n# This traces exec() from the fork()->exec() sequence, which means it won't\n# catch new processes that only fork(). With the -r option, it will also catch\n# processes that re-exec. It makes a best-effort attempt to retrieve the program\n# arguments and PPID; if these are unavailable, 0 and \"[?]\" are printed\n# respectively. There is also a limit to the number of arguments printed (by\n# default, 8), which can be increased using -a.\n#\n# This implementation is designed to work on older kernel versions, and without\n# kernel debuginfo. It works by dynamic tracing an execve kernel function to\n# read the arguments from the %si register. The sys_execve function is tried\n# first, then stub_execve and do_execve. The sched:sched_process_fork\n# tracepoint is used to get the PPID. This program is a workaround that should be\n# improved in the future when other kernel capabilities are made available. If\n# you need a more reliable tool now, then consider other tracing alternatives\n# (eg, SystemTap). This tool is really a proof of concept to see what ftrace can\n# currently do.\n#\n# From perf-tools: https://github.com/brendangregg/perf-tools\n#\n# See the execsnoop(8) man page (in perf-tools) for more info.\n#\n# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n#\n#  (http://www.gnu.org/copyleft/gpl.html)\n#\n# 07-Jul-2014\tBrendan Gregg\tCreated this.\n\n### default variables\ntracing=/sys/kernel/debug/tracing\nflock=/var/tmp/.ftrace-lock; wroteflock=0\nopt_duration=0; duration=; opt_name=0; name=; opt_time=0; opt_reexec=0\nopt_argc=0; argc=8; max_argc=16; ftext=\ntrap ':' INT QUIT TERM PIPE HUP\t# sends execution to end tracing section\n\nfunction usage {\n\tcat <<-END >&2\n\tUSAGE: execsnoop [-hrt] [-a argc] [-d secs] [name]\n\t                 -d seconds      # trace duration, and use buffers\n\t                 -a argc         # max args to show (default 8)\n\t                 -r              # include re-execs\n\t                 -t              # include time (seconds)\n\t                 -h              # this usage message\n\t                 name            # process name to match (REs allowed)\n\t  eg,\n\t       execsnoop                 # watch exec()s live (unbuffered)\n\t       execsnoop -d 1            # trace 1 sec (buffered)\n\t       execsnoop grep            # trace process names containing grep\n\t       execsnoop 'udevd$'        # process names ending in \"udevd\"\n\n\tSee the man page and example file for more info.\nEND\n\texit\n}\n\nfunction warn {\n\tif ! eval \"$@\"; then\n\t\techo >&2 \"WARNING: command failed \\\"$@\\\"\"\n\tfi\n}\n\nfunction end {\n\t# disable tracing\n\techo 2>/dev/null\n\techo \"Ending tracing...\" 2>/dev/null\n\tcd $tracing\n\twarn \"echo 0 > events/kprobes/$kname/enable\"\n\twarn \"echo 0 > events/sched/sched_process_fork/enable\"\n\twarn \"echo -:$kname >> kprobe_events\"\n\twarn \"echo > trace\"\n\t(( wroteflock )) && warn \"rm $flock\"\n}\n\nfunction die {\n\techo >&2 \"$@\"\n\texit 1\n}\n\nfunction edie {\n\t# die with a quiet end()\n\techo >&2 \"$@\"\n\texec >/dev/null 2>&1\n\tend\n\texit 1\n}\n\n### process options\nwhile getopts a:d:hrt opt\ndo\n\tcase $opt in\n\ta)\topt_argc=1; argc=$OPTARG ;;\n\td)\topt_duration=1; duration=$OPTARG ;;\n\tr)\topt_reexec=1 ;;\n\tt)\topt_time=1 ;;\n\th|?)\tusage ;;\n\tesac\ndone\nshift $(( $OPTIND - 1 ))\nif (( $# )); then\n\topt_name=1\n\tname=$1\n\tshift\nfi\n(( $# )) && usage\n\n### option logic\n(( opt_pid && opt_name )) && die \"ERROR: use either -p or -n.\"\n(( opt_pid )) && ftext=\" issued by PID $pid\"\n(( opt_name )) && ftext=\" issued by process name \\\"$name\\\"\"\n(( opt_file )) && ftext=\"$ftext for filenames containing \\\"$file\\\"\"\n(( opt_argc && argc > max_argc )) && die \"ERROR: max -a argc is $max_argc.\"\nif (( opt_duration )); then\n\techo \"Tracing exec()s$ftext for $duration seconds (buffered)...\"\nelse\n\techo \"Tracing exec()s$ftext. Ctrl-C to end.\"\nfi\n\n### select awk\nif (( opt_duration )); then\n\t[[ -x /usr/bin/mawk ]] && awk=mawk || awk=awk\nelse\n\t# workarounds for mawk/gawk fflush behavior\n\tif [[ -x /usr/bin/gawk ]]; then\n\t\tawk=gawk\n\telif [[ -x /usr/bin/mawk ]]; then\n\t\tawk=\"mawk -W interactive\"\n\telse\n\t\tawk=awk\n\tfi\nfi\n\n### check permissions\ncd $tracing || die \"ERROR: accessing tracing. Root user? Kernel has FTRACE?\n    debugfs mounted? (mount -t debugfs debugfs /sys/kernel/debug)\"\n\n### ftrace lock\n[[ -e $flock ]] && die \"ERROR: ftrace may be in use by PID $(cat $flock) $flock\"\necho $$ > $flock || die \"ERROR: unable to write $flock.\"\nwroteflock=1\n\n### build probe\nif [[ -x /usr/bin/getconf ]]; then\n\tbits=$(getconf LONG_BIT)\nelse\n\tbits=64\n\t[[ $(uname -m) == i* ]] && bits=32\nfi\n(( offset = bits / 8 ))\nfunction makeprobe {\n\tfunc=$1\n\tkname=execsnoop_$func\n\tkprobe=\"p:$kname $func\"\n\ti=0\n\twhile (( i < argc + 1 )); do\n\t\t# p:kname do_execve +0(+0(%si)):string +0(+8(%si)):string ...\n\t\tkprobe=\"$kprobe +0(+$(( i * offset ))(%si)):string\"\n\t\t(( i++ ))\n\tdone\n}\n# try in this order: sys_execve, stub_execve, do_execve\nmakeprobe sys_execve\n\n### setup and begin tracing\necho nop > current_tracer\nif ! echo $kprobe >> kprobe_events 2>/dev/null; then\n\tmakeprobe stub_execve\n\tif ! echo $kprobe >> kprobe_events 2>/dev/null; then\n\t    makeprobe do_execve\n\t    if ! echo $kprobe >> kprobe_events 2>/dev/null; then\n\t\t    edie \"ERROR: adding a kprobe for execve. Exiting.\"\n        fi\n\tfi\nfi\nif ! echo 1 > events/kprobes/$kname/enable; then\n\tedie \"ERROR: enabling kprobe for execve. Exiting.\"\nfi\nif ! echo 1 > events/sched/sched_process_fork/enable; then\n\tedie \"ERROR: enabling sched:sched_process_fork tracepoint. Exiting.\"\nfi\necho \"Instrumenting $func\"\n(( opt_time )) && printf \"%-16s \" \"TIMEs\"\nprintf \"%6s %6s %s\\n\" \"PID\" \"PPID\" \"ARGS\"\n\n#\n# Determine output format. It may be one of the following (newest first):\n#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION\n#           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n# To differentiate between them, the number of header fields is counted,\n# and an offset set, to skip the extra column when needed.\n#\noffset=$($awk 'BEGIN { o = 0; }\n\t$1 == \"#\" && $2 ~ /TASK/ && NF == 6 { o = 1; }\n\t$2 ~ /TASK/ { print o; exit }' trace)\n\n### print trace buffer\nwarn \"echo > trace\"\n( if (( opt_duration )); then\n\t# wait then dump buffer\n\tsleep $duration\n\tcat -v trace\nelse\n\t# print buffer live\n\tcat -v trace_pipe\nfi ) | $awk -v o=$offset -v opt_name=$opt_name -v name=$name \\\n    -v opt_duration=$opt_duration -v opt_time=$opt_time -v kname=$kname \\\n    -v opt_reexec=$opt_reexec '\n\t# common fields\n\t$1 != \"#\" {\n\t\t# task name can contain dashes\n\t\tcomm = pid = $1\n\t\tsub(/-[0-9][0-9]*/, \"\", comm)\n\t\tsub(/.*-/, \"\", pid)\n\t}\n\n\t$1 != \"#\" && $(4+o) ~ /sched_process_fork/ {\n\t\tcpid=$0\n\t\tsub(/.* child_pid=/, \"\", cpid)\n\t\tsub(/ .*/, \"\", cpid)\n\t\tgetppid[cpid] = pid\n\t\tdelete seen[pid]\n\t}\n\n\t$1 != \"#\" && $(4+o) ~ kname {\n\t\tif (seen[pid])\n\t\t\tnext\n\t\tif (opt_name && comm !~ name)\n\t\t\tnext\n\n\t\t#\n\t\t# examples:\n\t\t# ... arg1=\"/bin/echo\" arg2=\"1\" arg3=\"2\" arg4=\"3\" ...\n\t\t# ... arg1=\"sleep\" arg2=\"2\" arg3=(fault) arg4=\"\" ...\n\t\t# ... arg1=\"\" arg2=(fault) arg3=\"\" arg4=\"\" ...\n\t\t# the last example is uncommon, and may be a race.\n\t\t#\n\t\tif ($0 ~ /arg1=\"\"/) {\n\t\t\targs = comm \" [?]\"\n\t\t} else {\n\t\t\targs=$0\n\t\t\tsub(/ arg[0-9]*=\\(fault\\).*/, \"\", args)\n\t\t\tsub(/.*arg1=\"/, \"\", args)\n\t\t\tgsub(/\" arg[0-9]*=\"/, \" \", args)\n\t\t\tsub(/\"$/, \"\", args)\n\t\t\tif ($0 !~ /\\(fault\\)/)\n\t\t\t\targs = args \" [...]\"\n\t\t}\n\n\t\tif (opt_time) {\n\t\t\ttime = $(3+o); sub(\":\", \"\", time)\n\t\t\tprintf \"%-16s \", time\n\t\t}\n\t\tprintf \"%6s %6d %s\\n\", pid, getppid[pid], args\n\t\tif (!opt_duration)\n\t\t\tfflush()\n\t\tif (!opt_reexec) {\n\t\t\tseen[pid] = 1\n\t\t\tdelete getppid[pid]\n\t\t}\n\t}\n\n\t$0 ~ /LOST.*EVENT[S]/ { print \"WARNING: \" $0 > \"/dev/stderr\" }\n'\n\n### end tracing\nend\n"
        },
        {
          "name": "fs",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "iolatency",
          "type": "blob",
          "size": 7.5029296875,
          "content": "#!/bin/bash\n#\n# iolatency - summarize block device I/O latency as a histogram.\n#             Written using Linux ftrace.\n#\n# This shows the distribution of latency, allowing modes and latency outliers\n# to be identified and studied.\n#\n# USAGE: ./iolatency [-hQT] [-d device] [-i iotype] [interval [count]]\n#\n# REQUIREMENTS: FTRACE CONFIG and block:block_rq_* tracepoints, which you may\n# already have on recent kernels.\n#\n# OVERHEAD: block device I/O issue and completion events are traced and buffered\n# in-kernel, then processed and summarized in user space. There may be\n# measurable overhead with this approach, relative to the block device IOPS.\n#\n# This was written as a proof of concept for ftrace.\n#\n# From perf-tools: https://github.com/brendangregg/perf-tools\n#\n# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n#\n#  (http://www.gnu.org/copyleft/gpl.html)\n#\n# 20-Jul-2014\tBrendan Gregg\tCreated this.\n\n### default variables\ntracing=/sys/kernel/debug/tracing\nflock=/var/tmp/.ftrace-lock\nbufsize_kb=4096\nopt_device=0; device=; opt_iotype=0; iotype=; opt_timestamp=0\nopt_interval=0; interval=1; opt_count=0; count=0; opt_queue=0\ntrap ':' INT QUIT TERM PIPE HUP\t# sends execution to end tracing section\n\nfunction usage {\n\tcat <<-END >&2\n\tUSAGE: iolatency [-hQT] [-d device] [-i iotype] [interval [count]]\n\t                 -d device       # device string (eg, \"202,1)\n\t                 -i iotype       # match type (eg, '*R*' for all reads)\n\t                 -Q              # use queue insert as start time\n\t                 -T              # timestamp on output\n\t                 -h              # this usage message\n\t                 interval        # summary interval, seconds (default 1)\n\t                 count           # number of summaries\n\t  eg,\n\t       iolatency                 # summarize latency every second\n\t       iolatency -Q              # include block I/O queue time\n\t       iolatency 5 2             # 2 x 5 second summaries\n\t       iolatency -i '*R*'        # trace reads\n\t       iolatency -d 202,1        # trace device 202,1 only\n\n\tSee the man page and example file for more info.\nEND\n\texit\n}\n\nfunction warn {\n\tif ! eval \"$@\"; then\n\t\techo >&2 \"WARNING: command failed \\\"$@\\\"\"\n\tfi\n}\n\nfunction end {\n\t# disable tracing\n\techo 2>/dev/null\n\techo \"Ending tracing...\" 2>/dev/null\n\tcd $tracing\n\twarn \"echo 0 > events/block/$b_start/enable\"\n\twarn \"echo 0 > events/block/block_rq_complete/enable\"\n\tif (( opt_device || opt_iotype )); then\n\t\twarn \"echo 0 > events/block/$b_start/filter\"\n\t\twarn \"echo 0 > events/block/block_rq_complete/filter\"\n\tfi\n\twarn \"echo > trace\"\n\t(( wroteflock )) && warn \"rm $flock\"\n}\n\nfunction die {\n\techo >&2 \"$@\"\n\texit 1\n}\n\nfunction edie {\n\t# die with a quiet end()\n\techo >&2 \"$@\"\n\texec >/dev/null 2>&1\n\tend\n\texit 1\n}\n\n### process options\nwhile getopts d:hi:QT opt\ndo\n\tcase $opt in\n\td)\topt_device=1; device=$OPTARG ;;\n\ti)\topt_iotype=1; iotype=$OPTARG ;;\n\tQ)\topt_queue=1 ;;\n\tT)\topt_timestamp=1 ;;\n\th|?)\tusage ;;\n\tesac\ndone\nshift $(( $OPTIND - 1 ))\nif (( $# )); then\n\topt_interval=1\n\tinterval=$1\n\tshift\nfi\nif (( $# )); then\n\topt_count=1\n\tcount=$1\nfi\nif (( opt_device )); then\n\tmajor=${device%,*}\n\tminor=${device#*,}\n\tdev=$(( (major << 20) + minor ))\nfi\nif (( opt_queue )); then\n\tb_start=block_rq_insert\nelse\n\tb_start=block_rq_issue\nfi\n\n### select awk\n[[ -x /usr/bin/mawk ]] && awk='mawk -W interactive' || awk=awk\n\n### check permissions\ncd $tracing || die \"ERROR: accessing tracing. Root user? Kernel has FTRACE?\n    debugfs mounted? (mount -t debugfs debugfs /sys/kernel/debug)\"\n\n### ftrace lock\n[[ -e $flock ]] && die \"ERROR: ftrace may be in use by PID $(cat $flock) $flock\"\necho $$ > $flock || die \"ERROR: unable to write $flock.\"\nwroteflock=1\n\n### setup and begin tracing\nwarn \"echo nop > current_tracer\"\nwarn \"echo $bufsize_kb > buffer_size_kb\"\nfilter=\nif (( opt_iotype )); then\n\tfilter=\"rwbs ~ \\\"$iotype\\\"\"\nfi\nif (( opt_device )); then\n\t[[ \"$filter\" != \"\" ]] && filter=\"$filter && \"\n\tfilter=\"${filter}dev == $dev\"\nfi\nif (( opt_iotype || opt_device )); then\n\tif ! echo \"$filter\" > events/block/$b_start/filter || \\\n\t    ! echo \"$filter\" > events/block/block_rq_complete/filter\n\tthen\n\t\tedie \"ERROR: setting -d or -t filter. Exiting.\"\n\tfi\nfi\nif ! echo 1 > events/block/$b_start/enable || \\\n    ! echo 1 > events/block/block_rq_complete/enable; then\n\tedie \"ERROR: enabling block I/O tracepoints. Exiting.\"\nfi\netext=\n(( !opt_count )) && etext=\" Ctrl-C to end.\"\necho \"Tracing block I/O. Output every $interval seconds.$etext\"\n\n#\n# Determine output format. It may be one of the following (newest first):\n#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION\n#           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n# To differentiate between them, the number of header fields is counted,\n# and an offset set, to skip the extra column when needed.\n#\noffset=$($awk 'BEGIN { o = 0; }\n\t$1 == \"#\" && $2 ~ /TASK/ && NF == 6 { o = 1; }\n\t$2 ~ /TASK/ { print o; exit }' trace)\n\n### print trace buffer\nwarn \"echo > trace\"\ni=0\nwhile (( !opt_count || (i < count) )); do\n\t(( i++ ))\n\tsleep $interval\n\n\t# snapshots were added in 3.10\n\tif [[ -x snapshot ]]; then\n\t\techo 1 > snapshot\n\t\techo > trace\n\t\tcat snapshot\n\telse\n\t\tcat trace\n\t\techo > trace\n\tfi\n\n\t(( opt_timestamp )) && printf \"time %(%H:%M:%S)T:\\n\" -1\n\techo \"tick\"\ndone | \\\n$awk -v o=$offset -v opt_timestamp=$opt_timestamp -v b_start=$b_start '\n\tfunction star(sval, smax, swidth) {\n\t\tstars = \"\"\n\t\tif (smax == 0) return \"\"\n\t\tfor (si = 0; si < (swidth * sval / smax); si++) {\n\t\t\tstars = stars \"#\"\n\t\t}\n\t\treturn stars\n\t}\n\n\tBEGIN { max_i = 0 }\n\n\t# common fields\n\t$1 != \"#\" {\n\t\ttime = $(3+o); sub(\":\", \"\", time)\n\t\tdev = $(5+o)\n\t}\n\n\t# block I/O request\n\t$1 != \"#\" && $0 ~ b_start {\n\t\t#\n\t\t# example: (fields1..4+o) 202,1 W 0 () 12862264 + 8 [tar]\n\t\t# The cmd field \"()\" might contain multiple words (hex),\n\t\t# hence stepping from the right (NF-3).\n\t\t#\n\t\tloc = $(NF-3)\n\t\tstarts[dev, loc] = time\n\t\tnext\n\t}\n\n\t# block I/O completion\n\t$1 != \"#\" && $0 ~ /rq_complete/ {\n\t\t#\n\t\t# example: (fields1..4+o) 202,1 W () 12862256 + 8 [0]\n\t\t#\n\t\tdir = $(6+o)\n\t\tloc = $(NF-3)\n\n\t\tif (starts[dev, loc] > 0) {\n\t\t\tlatency_ms = 1000 * (time - starts[dev, loc])\n\t\t\ti = 0\n\t\t\tfor (ms = 1; latency_ms > ms; ms *= 2) { i++ }\n\t\t\thist[i]++\n\t\t\tif (i > max_i)\n\t\t\t\tmax_i = i\n\t\t\tdelete starts[dev, loc]\n\t\t}\n\t\tnext\n\t}\n\n\t# timestamp\n\t$1 == \"time\" {\n\t\tlasttime = $2\n\t}\n\n\t# print summary\n\t$1 == \"tick\" {\n\t\tprint \"\"\n\t\tif (opt_timestamp)\n\t\t\tprint lasttime\n\n\t\t# find max value\n\t\tmax_v = 0\n\t\tfor (i = 0; i <= max_i; i++) {\n\t\t\tif (hist[i] > max_v)\n\t\t\t\tmax_v = hist[i]\n\t\t}\n\n\t\t# print histogram\n\t\tprintf \"%8s .. %-8s: %-8s |%-38s|\\n\", \">=(ms)\", \"<(ms)\",\n\t\t    \"I/O\", \"Distribution\"\n\t\tms = 1\n\t\tfrom = 0\n\t\tfor (i = 0; i <= max_i; i++) {\n\t\t\tprintf \"%8d -> %-8d: %-8d |%-38s|\\n\", from, ms,\n\t\t\t    hist[i], star(hist[i], max_v, 38)\n\t\t\tfrom = ms\n\t\t\tms *= 2\n\t\t}\n\t\tfflush()\n\t\tdelete hist\n\t\tdelete starts\t# invalid if events missed between snapshots\n\t\tmax_i = 0\n\t}\n\n\t$0 ~ /LOST.*EVENTS/ { print \"WARNING: \" $0 > \"/dev/stderr\" }\n'\n\n### end tracing\nend\n"
        },
        {
          "name": "iosnoop",
          "type": "blob",
          "size": 8.8984375,
          "content": "#!/bin/bash\n#\n# iosnoop - trace block device I/O.\n#           Written using Linux ftrace.\n#\n# This traces disk I/O at the block device interface, using the block:\n# tracepoints. This can help characterize the I/O requested for the storage\n# devices and their resulting performance. I/O completions can also be studied\n# event-by-event for debugging disk and controller I/O scheduling issues.\n#\n# USAGE: ./iosnoop [-hQst] [-d device] [-i iotype] [-p pid] [-n name] [duration]\n#\n# Run \"iosnoop -h\" for full usage.\n#\n# REQUIREMENTS: FTRACE CONFIG, block:block_rq_* tracepoints (you may\n# already have these on recent kernels).\n#\n# OVERHEAD: By default, iosnoop works without buffering, printing I/O events\n# as they happen (uses trace_pipe), context switching and consuming CPU to do\n# so. This has a limit of about 10,000 IOPS (depending on your platform), at\n# which point iosnoop will be consuming 1 CPU. The duration mode uses buffering,\n# and can handle much higher IOPS rates, however, the buffer has a limit of\n# about 50,000 I/O, after which events will be dropped. You can tune this with\n# bufsize_kb, which is per-CPU. Also note that the \"-n\" option is currently\n# post-filtered, so all events are traced.\n#\n# This was written as a proof of concept for ftrace. It would be better written\n# using perf_events (after some capabilities are added), which has a better\n# buffering policy, or a tracer such as SystemTap or ktap.\n#\n# From perf-tools: https://github.com/brendangregg/perf-tools\n#\n# See the iosnoop(8) man page (in perf-tools) for more info.\n#\n# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n#\n#  (http://www.gnu.org/copyleft/gpl.html)\n#\n# 12-Jul-2014\tBrendan Gregg\tCreated this.\n\n### default variables\ntracing=/sys/kernel/debug/tracing\nflock=/var/tmp/.ftrace-lock\nbufsize_kb=4096\nopt_duration=0; duration=; opt_name=0; name=; opt_pid=0; pid=; ftext=\nopt_start=0; opt_end=0; opt_device=0; device=; opt_iotype=0; iotype=\nopt_queue=0\ntrap ':' INT QUIT TERM PIPE HUP\t# sends execution to end tracing section\n\nfunction usage {\n\tcat <<-END >&2\n\tUSAGE: iosnoop [-hQst] [-d device] [-i iotype] [-p PID] [-n name]\n\t               [duration]\n\t                 -d device       # device string (eg, \"202,1)\n\t                 -i iotype       # match type (eg, '*R*' for all reads)\n\t                 -n name         # process name to match on I/O issue\n\t                 -p PID          # PID to match on I/O issue\n\t                 -Q              # use queue insert as start time\n\t                 -s              # include start time of I/O (s)\n\t                 -t              # include completion time of I/O (s)\n\t                 -h              # this usage message\n\t                 duration        # duration seconds, and use buffers\n\t  eg,\n\t       iosnoop                   # watch block I/O live (unbuffered)\n\t       iosnoop 1                 # trace 1 sec (buffered)\n\t       iosnoop -Q                # include queueing time in LATms\n\t       iosnoop -ts               # include start and end timestamps\n\t       iosnoop -i '*R*'          # trace reads\n\t       iosnoop -p 91             # show I/O issued when PID 91 is on-CPU\n\t       iosnoop -Qp 91            # show I/O queued by PID 91, queue time\n\n\tSee the man page and example file for more info.\nEND\n\texit\n}\n\nfunction warn {\n\tif ! eval \"$@\"; then\n\t\techo >&2 \"WARNING: command failed \\\"$@\\\"\"\n\tfi\n}\n\nfunction end {\n\t# disable tracing\n\techo 2>/dev/null\n\techo \"Ending tracing...\" 2>/dev/null\n\tcd $tracing\n\twarn \"echo 0 > events/block/$b_start/enable\"\n\twarn \"echo 0 > events/block/block_rq_complete/enable\"\n\tif (( opt_device || opt_iotype || opt_pid )); then\n\t\twarn \"echo 0 > events/block/$b_start/filter\"\n\t\twarn \"echo 0 > events/block/block_rq_complete/filter\"\n\tfi\n\twarn \"echo > trace\"\n\t(( wroteflock )) && warn \"rm $flock\"\n}\n\nfunction die {\n\techo >&2 \"$@\"\n\texit 1\n}\n\nfunction edie {\n\t# die with a quiet end()\n\techo >&2 \"$@\"\n\texec >/dev/null 2>&1\n\tend\n\texit 1\n}\n\n### process options\nwhile getopts d:hi:n:p:Qst opt\ndo\n\tcase $opt in\n\td)\topt_device=1; device=$OPTARG ;;\n\ti)\topt_iotype=1; iotype=$OPTARG ;;\n\tn)\topt_name=1; name=$OPTARG ;;\n\tp)\topt_pid=1; pid=$OPTARG ;;\n\tQ)\topt_queue=1 ;;\n\ts)\topt_start=1 ;;\n\tt)\topt_end=1 ;;\n\th|?)\tusage ;;\n\tesac\ndone\nshift $(( $OPTIND - 1 ))\nif (( $# )); then\n\topt_duration=1\n\tduration=$1\n\tshift\nfi\nif (( opt_device )); then\n\tmajor=${device%,*}\n\tminor=${device#*,}\n\tdev=$(( (major << 20) + minor ))\nfi\n\n### option logic\n(( opt_pid && opt_name )) && die \"ERROR: use either -p or -n.\"\n(( opt_pid )) && ftext=\" issued by PID $pid\"\n(( opt_name )) && ftext=\" issued by process name \\\"$name\\\"\"\nif (( opt_duration )); then\n\techo \"Tracing block I/O$ftext for $duration seconds (buffered)...\"\nelse\n\techo \"Tracing block I/O$ftext. Ctrl-C to end.\"\nfi\nif (( opt_queue )); then\n\tb_start=block_rq_insert\nelse\n\tb_start=block_rq_issue\nfi\n\n### select awk\n(( opt_duration )) && use=mawk || use=gawk\t# workaround for mawk fflush()\n[[ -x /usr/bin/$use ]] && awk=$use || awk=awk\nwroteflock=1\n\n### check permissions\ncd $tracing || die \"ERROR: accessing tracing. Root user? Kernel has FTRACE?\n    debugfs mounted? (mount -t debugfs debugfs /sys/kernel/debug)\"\n\n### ftrace lock\n[[ -e $flock ]] && die \"ERROR: ftrace may be in use by PID $(cat $flock) $flock\"\necho $$ > $flock || die \"ERROR: unable to write $flock.\"\n\n### setup and begin tracing\necho nop > current_tracer\nwarn \"echo $bufsize_kb > buffer_size_kb\"\nfilter=\nif (( opt_iotype )); then\n\tfilter=\"rwbs ~ \\\"$iotype\\\"\"\nfi\nif (( opt_device )); then\n\t[[ \"$filter\" != \"\" ]] && filter=\"$filter && \"\n\tfilter=\"${filter}dev == $dev\"\nfi\nfilter_i=$filter\nif (( opt_pid )); then\n\t[[ \"$filter_i\" != \"\" ]] && filter_i=\"$filter_i && \"\n\tfilter_i=\"${filter_i}common_pid == $pid\"\n\t[[ \"$filter\" == \"\" ]] && filter=0\nfi\nif (( opt_iotype || opt_device || opt_pid )); then\n\tif ! echo \"$filter_i\" > events/block/$b_start/filter || \\\n\t    ! echo \"$filter\" > events/block/block_rq_complete/filter\n\tthen\n\t\tedie \"ERROR: setting -d or -t filter. Exiting.\"\n\tfi\nfi\nif ! echo 1 > events/block/$b_start/enable || \\\n    ! echo 1 > events/block/block_rq_complete/enable; then\n\tedie \"ERROR: enabling block I/O tracepoints. Exiting.\"\nfi\n(( opt_start )) && printf \"%-15s \" \"STARTs\"\n(( opt_end )) && printf \"%-15s \" \"ENDs\"\nprintf \"%-12.12s %-6s %-4s %-8s %-12s %-6s %8s\\n\" \\\n    \"COMM\" \"PID\" \"TYPE\" \"DEV\" \"BLOCK\" \"BYTES\" \"LATms\"\n\n#\n# Determine output format. It may be one of the following (newest first):\n#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION\n#           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n# To differentiate between them, the number of header fields is counted,\n# and an offset set, to skip the extra column when needed.\n#\noffset=$($awk 'BEGIN { o = 0; }\n\t$1 == \"#\" && $2 ~ /TASK/ && NF == 6 { o = 1; }\n\t$2 ~ /TASK/ { print o; exit }' trace)\n\n### print trace buffer\nwarn \"echo > trace\"\n( if (( opt_duration )); then\n\t# wait then dump buffer\n\tsleep $duration\n\tcat trace\nelse\n\t# print buffer live\n\tcat trace_pipe\nfi ) | $awk -v o=$offset -v opt_name=$opt_name -v name=$name \\\n    -v opt_duration=$opt_duration -v opt_start=$opt_start -v opt_end=$opt_end \\\n    -v b_start=$b_start '\n\t# common fields\n\t$1 != \"#\" {\n\t\t# task name can contain dashes\n\t\tcomm = pid = $1\n\t\tsub(/-[0-9][0-9]*/, \"\", comm)\n\t\tsub(/.*-/, \"\", pid)\n\t\ttime = $(3+o); sub(\":\", \"\", time)\n\t\tdev = $(5+o)\n\t}\n\n\t# block I/O request\n\t$1 != \"#\" && $0 ~ b_start {\n\t\tif (opt_name && match(comm, name) == 0)\n\t\t\tnext\n\t\t#\n\t\t# example: (fields1..4+o) 202,1 W 0 () 12862264 + 8 [tar]\n\t\t# The cmd field \"()\" might contain multiple words (hex),\n\t\t# hence stepping from the right (NF-3).\n\t\t#\n\t\tloc = $(NF-3)\n\t\tstarts[dev, loc] = time\n\t\tcomms[dev, loc] = comm\n\t\tpids[dev, loc] = pid\n\t\tnext\n\t}\n\n\t# block I/O completion\n\t$1 != \"#\" && $0 ~ /rq_complete/ {\n\t\t#\n\t\t# example: (fields1..4+o) 202,1 W () 12862256 + 8 [0]\n\t\t#\n\t\tdir = $(6+o)\n\t\tloc = $(NF-3)\n\t\tnsec = $(NF-1)\n\n\t\tif (starts[dev, loc] > 0) {\n\t\t\tlatency = sprintf(\"%.2f\",\n\t\t\t    1000 * (time - starts[dev, loc]))\n\t\t\tcomm = comms[dev, loc]\n\t\t\tpid = pids[dev, loc]\n\n\t\t\tif (opt_start)\n\t\t\t\tprintf \"%-15s \", starts[dev, loc]\n\t\t\tif (opt_end)\n\t\t\t\tprintf \"%-15s \", time\n\t\t\tprintf \"%-12.12s %-6s %-4s %-8s %-12s %-6s %8s\\n\",\n\t\t\t    comm, pid, dir, dev, loc, nsec * 512, latency\n\t\t\tif (!opt_duration)\n\t\t\t\tfflush()\n\n\t\t\tdelete starts[dev, loc]\n\t\t\tdelete comms[dev, loc]\n\t\t\tdelete pids[dev, loc]\n\t\t}\n\t\tnext\n\t}\n\n\t$0 ~ /LOST.*EVENTS/ { print \"WARNING: \" $0 > \"/dev/stderr\" }\n'\n\n### end tracing\nend\n"
        },
        {
          "name": "kernel",
          "type": "tree",
          "content": null
        },
        {
          "name": "killsnoop",
          "type": "blob",
          "size": 7.8623046875,
          "content": "#!/bin/bash\n#\n# killsnoop - trace kill() syscalls with signal/process details.\n#             Written using Linux ftrace.\n#\n# This traces kill() syscalls, showing which process killed which pid and\n# returns the returncode (0 for success, -1 for error).\n#\n# This implementation is designed to work on older kernel versions, and without\n# kernel debuginfo. It works by dynamic tracing of the return value of kill()\n# and associating it with the previous kill() syscall return.\n# This approach is kernel version specific, and may not work on your version.\n# It is a workaround, and proof of concept for ftrace, until more kernel tracing\n# functionality is available.\n#\n# USAGE: ./killsnoop [-hst] [-d secs] [-p pid] [-n name]\n#\n# Run \"killsnoop -h\" for full usage.\n#\n# REQUIREMENTS: FTRACE and KPROBE CONFIG, syscalls:sys_enter_kill and\n# syscalls:sys_exit_kill kernel tracepoints (you may already have these\n# on recent kernels) and awk.\n#\n# From perf-tools: https://github.com/brendangregg/perf-tools\n#\n# See the killsnoop(8) man page (in perf-tools) for more info.\n#\n# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.\n# COPYRIGHT: Copyright (c) 2014 Martin Probst.\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n#\n#  (http://www.gnu.org/copyleft/gpl.html)\n#\n# 20-Jul-2014   Brendan Gregg   Templated this.\n# 13-Sep-2014   Martin Probst   Created this.\n\n### default variables\ntracing=/sys/kernel/debug/tracing\nflock=/var/tmp/.ftrace-lock; wroteflock=0\nopt_duration=0; duration=; opt_name=0; name=; opt_pid=0; pid=; ftext=\nopt_time=0; opt_fail=0; opt_file=0; file=\nkevent_entry=events/syscalls/sys_enter_kill\nkevent_return=events/syscalls/sys_exit_kill\ntrap ':' INT QUIT TERM PIPE HUP # sends execution to end tracing section\n\nfunction usage {\n    cat <<-END >&2\nUSAGE: killsnoop [-hst] [-d secs] [-p PID] [-n name] [filename]\n                 -d seconds      # trace duration, and use buffers\n                 -n name         # process name to match \n                 -p PID          # PID to match on kill issue\n                 -t              # include time (seconds)\n                 -s              # human readable signal names\n                 -h              # this usage message\n  eg,\n       killsnoop                 # watch kill()s live (unbuffered)\n       killsnoop -d 1            # trace 1 sec (buffered)\n       killsnoop -p 181          # trace kill()s issued to PID 181 only\n\nSee the man page and example file for more info.\nEND\n    exit\n}\n\nfunction warn {\n    if ! eval \"$@\"; then\n        echo >&2 \"WARNING: command failed \\\"$@\\\"\"\n    fi\n}\n\nfunction end {\n    # disable tracing\n    echo 2>/dev/null\n    echo \"Ending tracing...\" 2>/dev/null\n    cd $tracing\n    warn \"echo 0 > $kevent_entry/enable\"\n    warn \"echo 0 > $kevent_return/enable\"\n    warn \"echo > trace\"\n    (( wroteflock )) && warn \"rm $flock\"\n}\n\nfunction die {\n    echo >&2 \"$@\"\n    exit 1\n}\n\nfunction edie {\n    # die with a quiet end()\n    echo >&2 \"$@\"\n    exec >/dev/null 2>&1\n    end\n    exit 1\n}\n\n### process options\nwhile getopts d:hn:p:st opt\ndo\n    case $opt in\n    d)  opt_duration=1; duration=$OPTARG ;;\n    n)  opt_name=1; name=$OPTARG ;;\n    p)  opt_pid=1; pid=$OPTARG ;;\n    t)  opt_time=1 ;;\n    s)  opt_fancy=1 ;;\n    h|?)    usage ;;\n    esac\ndone\nshift $(( $OPTIND - 1 ))\n(( $# )) && usage\n\n### option logic\n(( opt_pid && opt_name )) && die \"ERROR: use either -p or -n.\"\n(( opt_pid )) && ftext=\" issued to PID $pid\"\n(( opt_name )) && ftext=\" issued by process name \\\"$name\\\"\"\nif (( opt_duration )); then\n    echo \"Tracing kill()s$ftext for $duration seconds (buffered)...\"\nelse\n    echo \"Tracing kill()s$ftext. Ctrl-C to end.\"\nfi\n\n### select awk\n# workaround for mawk fflush()\n[[ -x /usr/bin/mawk ]] && awk=\"mawk\" && mawk -W interactive && \\\n[ $? -eq 0 ] && awk=\"mawk -W interactive\"\n# workaround for gawk strtonum()\n[[ -x /usr/bin/gawk ]] && awk=\"gawk --non-decimal-data\"\n\n### check permissions\ncd $tracing || die \"ERROR: accessing tracing. Root user? Kernel has FTRACE?\n    debugfs mounted? (mount -t debugfs debugfs /sys/kernel/debug)\"\n\n### ftrace lock\n[[ -e $flock ]] && die \"ERROR: ftrace may be in use by PID $(cat $flock) $flock\"\necho $$ > $flock || die \"ERROR: unable to write $flock.\"\nwroteflock=1\n\n### setup and begin tracing\necho nop > current_tracer\nif ! echo 1 > $kevent_entry/enable; then\n    edie \"ERROR: enabling kill() entry tracepoint Exiting.\"\nfi\nif ! echo 1 > $kevent_return/enable; then\n    edie \"ERROR: enabling kill() return tracepoint. Exiting.\"\nfi\n(( opt_time )) && printf \"%-16s \" \"TIMEs\"\nprintf \"%-16.16s %-6s %-8s %-10s %4s\\n\" \"COMM\" \"PID\" \"TPID\" \"SIGNAL\" \"RETURN\"\n\n#\n# Determine output format. It may be one of the following (newest first):\n#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION\n#           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n# To differentiate between them, the number of header fields is counted,\n# and an offset set, to skip the extra column when needed.\n#\noffset=$($awk 'BEGIN { o = 0; }\n    $1 == \"#\" && $2 ~ /TASK/ && NF == 6 { o = 1; }\n    $2 ~ /TASK/ { print o; exit }' trace)\n\n### print trace buffer\nwarn \"echo > trace\"\n( if (( opt_duration )); then\n    # wait then dump buffer\n    sleep $duration\n    cat trace\nelse\n    # print buffer live\n    cat trace_pipe\nfi ) | $awk -v o=$offset -v opt_name=$opt_name -v name=$name \\\n    -v opt_duration=$opt_duration -v opt_time=$opt_time \\\n    -v opt_pid=$pid -v opt_fancy=$opt_fancy '\n    # fancy signal names\n    BEGIN {\n        signals[1] = \"SIGHUP\"\n        signals[2] = \"SIGINT\"\n        signals[3] = \"SIGQUIT\"\n        signals[4] = \"SIGILL\"\n        signals[6] = \"SIGABRT\"\n        signals[8] = \"SIGFPE\"\n        signals[9] = \"SIGKILL\"\n        signals[11] = \"SIGSEGV\"\n        signals[13] = \"SIGPIPE\"\n        signals[14] = \"SIGALRM\"\n        signals[15] = \"SIGTERM\"\n        signals[10] = \"SIGUSR1\"\n        signals[12] = \"SIGUSR2\"\n        signals[17] = \"SIGCHLD\"\n        signals[18] = \"SIGCONT\"\n        signals[19] = \"SIGSTOP\"\n        signals[20] = \"SIGTSTP\"\n        signals[21] = \"SIGTTIN\"\n        signals[22] = \"SIGTTOU\"\n    }\n\n    # common fields\n    $1 != \"#\" {\n        # task name can contain dashes\n        comm = pid = $1\n        sub(/-[0-9][0-9]*/, \"\", comm)\n        if (opt_name && match(comm, name) == 0)\n            next\n        sub(/.*-/, \"\", pid)\n    }\n\n    # sys_kill() entry\n    $1 != \"#\" && $(4+o) ~ /sys_kill/ && $(5+o) !~ /->/ {\n        #\n        # eg: ... sys_kill(pid:...\n        #\n        kpid = $(5+o)\n        signal = $(7+o)\n        sub(/,$/, \"\", kpid)\n        sub(/\\)$/, \"\", signal)\n        kpid = int(\"0x\"kpid)\n        signal = int(\"0x\"signal)\n        current[pid,\"kpid\"] = kpid\n        current[pid,\"signal\"] = signal\n    }\n\n    # sys_kill exit\n    $1 != \"#\" && $(5+o) ~ /->/ {\n        rv = int($NF)\n        killed_pid = current[pid,\"kpid\"]\n        signal = current[pid,\"signal\"]\n\n        delete current[pid,\"kpid\"]\n        delete current[pid,\"signal\"]\n\n        if(opt_pid && killed_pid != opt_pid) {\n            next\n        }\n\n        if (opt_time) {\n            time = $(3+o); sub(\":\", \"\", time)\n            printf \"%-16s \", time\n        }\n\n        if (opt_fancy) {\n            if (signals[signal] != \"\") {\n                signal = signals[signal]\n            }\n        }\n\n        printf \"%-16.16s %-6s %-8s %-10s %-4s\\n\", comm, pid, killed_pid, signal,\n            rv\n    }\n\n    $0 ~ /LOST.*EVENTS/ { print \"WARNING: \" $0 > \"/dev/stderr\" }\n'\n\n### end tracing\nend\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "net",
          "type": "tree",
          "content": null
        },
        {
          "name": "opensnoop",
          "type": "blob",
          "size": 8.50390625,
          "content": "#!/bin/bash\n#\n# opensnoop - trace open() syscalls with file details.\n#             Written using Linux ftrace.\n#\n# This traces open() syscalls, showing the file name and returned file\n# descriptor number (or -1, for error).\n#\n# This implementation is designed to work on older kernel versions, and without\n# kernel debuginfo. It works by dynamic tracing of the return value of getname()\n# as a string, and associating it with the following open() syscall return.\n# This approach is kernel version specific, and may not work on your version.\n# It is a workaround, and proof of concept for ftrace, until more kernel tracing\n# functionality is available.\n#\n# USAGE: ./opensnoop [-htx] [-d secs] [-p pid] [-L tid] [-n name] [filename]\n#\n# Run \"opensnoop -h\" for full usage.\n#\n# REQUIREMENTS: FTRACE and KPROBE CONFIG, syscalls:sys_exit_open tracepoint,\n# getname() kernel function (you may already have these on recent kernels),\n# and awk.\n#\n# From perf-tools: https://github.com/brendangregg/perf-tools\n#\n# See the opensnoop(8) man page (in perf-tools) for more info.\n#\n# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n#\n#  (http://www.gnu.org/copyleft/gpl.html)\n#\n# 20-Jul-2014\tBrendan Gregg\tCreated this.\n\n### default variables\ntracing=/sys/kernel/debug/tracing\nflock=/var/tmp/.ftrace-lock; wroteflock=0\nopt_duration=0; duration=; opt_name=0; name=; opt_pid=0; pid=; opt_tid=0; tid=\nftext=; opt_time=0; opt_fail=0; opt_file=0; file=\ntrap ':' INT QUIT TERM PIPE HUP\t# sends execution to end tracing section\n\nfunction usage {\n\tcat <<-END >&2\n\tUSAGE: opensnoop [-htx] [-d secs] [-p PID] [-L TID] [-n name] [filename]\n\t                 -d seconds      # trace duration, and use buffers\n\t                 -n name         # process name to match on open\n\t                 -p PID          # PID to match on open\n\t                 -L TID          # PID to match on open\n\t                 -t              # include time (seconds)\n\t                 -x              # only show failed opens\n\t                 -h              # this usage message\n\t                 filename        # match filename (partials, REs, ok)\n\t  eg,\n\t       opensnoop                 # watch open()s live (unbuffered)\n\t       opensnoop -d 1            # trace 1 sec (buffered)\n\t       opensnoop -p 181          # trace I/O issued by PID 181 only\n\t       opensnoop conf            # trace filenames containing \"conf\"\n\t       opensnoop 'log$'          # filenames ending in \"log\"\n\n\tSee the man page and example file for more info.\nEND\n\texit\n}\n\nfunction warn {\n\tif ! eval \"$@\"; then\n\t\techo >&2 \"WARNING: command failed \\\"$@\\\"\"\n\tfi\n}\n\nfunction end {\n\t# disable tracing\n\techo 2>/dev/null\n\techo \"Ending tracing...\" 2>/dev/null\n\tcd $tracing\n\twarn \"echo 0 > events/kprobes/getnameprobe/enable\"\n\twarn \"echo 0 > events/syscalls/sys_exit_open/enable\"\n\twarn \"echo 0 > events/syscalls/sys_exit_openat/enable\"\n\tif (( opt_pid || opt_tid )); then\n\t\twarn \"echo 0 > events/kprobes/getnameprobe/filter\"\n\t\twarn \"echo 0 > events/syscalls/sys_exit_open/filter\"\n\t\twarn \"echo 0 > events/syscalls/sys_exit_openat/filter\"\n\tfi\n\twarn \"echo -:getnameprobe >> kprobe_events\"\n\twarn \"echo > trace\"\n\t(( wroteflock )) && warn \"rm $flock\"\n}\n\nfunction die {\n\techo >&2 \"$@\"\n\texit 1\n}\n\nfunction edie {\n\t# die with a quiet end()\n\techo >&2 \"$@\"\n\texec >/dev/null 2>&1\n\tend\n\texit 1\n}\n\n### process options\nwhile getopts d:hn:p:L:tx opt\ndo\n\tcase $opt in\n\td)\topt_duration=1; duration=$OPTARG ;;\n\tn)\topt_name=1; name=$OPTARG ;;\n\tp)\topt_pid=1; pid=$OPTARG ;;\n\tL)\topt_tid=1; tid=$OPTARG ;;\n\tt)\topt_time=1 ;;\n\tx)\topt_fail=1 ;;\n\th|?)\tusage ;;\n\tesac\ndone\nshift $(( $OPTIND - 1 ))\nif (( $# )); then\n\topt_file=1\n\tfile=$1\n\tshift\nfi\n(( $# )) && usage\n\n### option logic\n(( opt_pid + opt_name + opt_tid > 1 )) && \\\n\tdie \"ERROR: use at most one of -p, -n, -L.\"\n(( opt_pid )) && ftext=\" issued by PID $pid\"\n(( opt_tid )) && ftext=\" issued by TID $tid\"\n(( opt_name )) && ftext=\" issued by process name \\\"$name\\\"\"\n(( opt_file )) && ftext=\"$ftext for filenames containing \\\"$file\\\"\"\nif (( opt_duration )); then\n\techo \"Tracing open()s$ftext for $duration seconds (buffered)...\"\nelse\n\techo \"Tracing open()s$ftext. Ctrl-C to end.\"\nfi\n\n### select awk\n(( opt_duration )) && use=mawk || use=gawk\t# workaround for mawk fflush()\n[[ -x /usr/bin/$use ]] && awk=$use || awk=awk\n\n### check permissions\ncd $tracing || die \"ERROR: accessing tracing. Root user? Kernel has FTRACE?\n    debugfs mounted? (mount -t debugfs debugfs /sys/kernel/debug)\"\n\n### ftrace lock\n[[ -e $flock ]] && die \"ERROR: ftrace may be in use by PID $(cat $flock) $flock\"\necho $$ > $flock || die \"ERROR: unable to write $flock.\"\nwroteflock=1\n\n### setup and begin tracing\necho nop > current_tracer\nver=$(uname -r)\nif [[ \"$ver\" == 2.* || \"$ver\" == 3.[1-6].* ]]; then\n\t# rval is char *\n\tkprobe='r:getnameprobe getname +0($retval):string'\nelse\n\t# rval is struct filename *\n\tkprobe='r:getnameprobe getname +0(+0($retval)):string'\nfi\nif ! echo $kprobe >> kprobe_events; then\n\tedie \"ERROR: adding a kprobe for getname(). Exiting.\"\nfi\nif (( opt_pid )); then\n\tfilter=\n\tfor tid in /proc/$pid/task/*; do\n\t\tfilter=\"$filter || common_pid == ${tid##*/}\"\n\tdone\n\tfilter=${filter:3}  # trim leading ' || ' (four characters)\n\tif ! echo $filter > events/kprobes/getnameprobe/filter || \\\n\t    ! echo $filter > events/syscalls/sys_exit_open/filter || \\\n\t    ! echo $filter > events/syscalls/sys_exit_openat/filter\n\tthen\n\t    edie \"ERROR: setting -p $pid. Exiting.\"\n\tfi\nfi\nif (( opt_tid )); then\n\tif ! echo \"common_pid == $tid\" > events/kprobes/getnameprobe/filter || \\\n\t    ! echo \"common_pid == $tid\" > events/syscalls/sys_exit_open/filter || \\\n\t    ! echo \"common_pid == $tid\" > events/syscalls/sys_exit_openat/filter\n\tthen\n\t    edie \"ERROR: setting -L $tid. Exiting.\"\n\tfi\nfi\nif ! echo 1 > events/kprobes/getnameprobe/enable; then\n\tedie \"ERROR: enabling kprobe for getname(). Exiting.\"\nfi\nif ! echo 1 > events/syscalls/sys_exit_open/enable; then\n\tedie \"ERROR: enabling open() exit tracepoint. Exiting.\"\nfi\nif ! echo 1 > events/syscalls/sys_exit_openat/enable; then\n\tedie \"ERROR: enabling openat() exit tracepoint. Exiting.\"\nfi\n(( opt_time )) && printf \"%-16s \" \"TIMEs\"\nprintf \"%-16.16s %-6s %4s %s\\n\" \"COMM\" \"PID\" \"FD\" \"FILE\"\n\n#\n# Determine output format. It may be one of the following (newest first):\n#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION\n#           TASK-PID    CPU#    TIMESTAMP  FUNCTION\n# To differentiate between them, the number of header fields is counted,\n# and an offset set, to skip the extra column when needed.\n#\noffset=$($awk 'BEGIN { o = 0; }\n\t$1 == \"#\" && $2 ~ /TASK/ && NF == 6 { o = 1; }\n\t$2 ~ /TASK/ { print o; exit }' trace)\n\n### print trace buffer\nwarn \"echo > trace\"\n( if (( opt_duration )); then\n\t# wait then dump buffer\n\tsleep $duration\n\tcat trace\nelse\n\t# print buffer live\n\tcat trace_pipe\nfi ) | $awk -v o=$offset -v opt_name=$opt_name -v name=$name \\\n    -v opt_duration=$opt_duration -v opt_time=$opt_time -v opt_fail=$opt_fail \\\n    -v opt_file=$opt_file -v file=$file '\n\t# common fields\n\t$1 != \"#\" {\n\t\t# task name can contain dashes and space\n\t\tsplit($0, line, \"-\")\n\t\tsub(/^[ \\t\\r\\n]+/, \"\", line[1])\n\t\tcomm = line[1]\n\t\tif (opt_name && match(comm, name) == 0)\n\t\t\tnext\n\t\tsub(/ .*$/, \"\", line[2])\n\t\tpid = line[2]\n\t}\n\n\t# do_sys_open()\n\t$1 != \"#\" && $(5+o) ~ /do_sys_open/ {\n\t\t#\n\t\t# eg: ... (do_sys_open+0xc3/0x220 <- getname) arg1=\"file1\"\n\t\t#\n\t\tmatch($0, /arg1=\\\"(.+)\\\"/, m)\n\t\tlastfile[pid] = m[1]\n\t}\n\n\t# sys_open() / sys_openat()\n\t$1 != \"#\" && ($(4+o) == \"sys_open\" || $(4+o) == \"sys_openat\") {\n\t\tfilename = lastfile[pid]\n\t\tif (!filename)\n\t\t\tnext\n\t\tdelete lastfile[pid]\n\t\tif (opt_file && filename !~ file)\n\t\t\tnext\n\t\trval = $NF\n\t\t# matched failed as beginning with 0xfffff\n\t\tif (opt_fail && rval !~ /0xfffff/)\n\t\t\tnext\n\t\tif (rval ~ /0xfffff/)\n\t\t\trval = -1\n\n\t\tif (opt_time) {\n\t\t\ttime = $(3+o); sub(\":\", \"\", time)\n\t\t\tprintf \"%-16s \", time\n\t\t}\n\t\tprintf \"%-16.16s %-6s %4s %s\\n\", comm, pid, rval, filename\n\t}\n\n\t$0 ~ /LOST.*EVENTS/ {\n\t\tdelete lastfile\n\t\tprint \"WARNING: \" $0 > \"/dev/stderr\" }\n'\n\n### end tracing\nend\n"
        },
        {
          "name": "syscount",
          "type": "blob",
          "size": 6.3349609375,
          "content": "#!/bin/bash\n#\n# syscount - count system calls.\n#            Written using Linux perf_events (aka \"perf\").\n#\n# This is a proof-of-concept using perf_events capabilities for older kernel\n# versions, that lack custom in-kernel aggregations. Once they exist, this\n# script can be substantially rewritten and improved (lower overhead).\n#\n# USAGE: syscount [-chv] [-t top] {-p PID|-d seconds|command}\n#\n# Run \"syscount -h\" for full usage.\n#\n# REQUIREMENTS: Linux perf_events: add linux-tools-common, run \"perf\", then\n# add any additional packages it requests. Also needs awk.\n#\n# OVERHEADS: Modes that report syscall names only (-c, -cp PID, -cd secs) have\n# lower overhead, since they use in-kernel counts. Other modes which report\n# process IDs (-cv) or process names (default) create a perf.data file for\n# post processing, and you will see messages about it doing this. Beware of\n# the file size (test for short durations, or use -c to see counts based on\n# in-kernel counters), and gauge overheads based on the perf.data size.\n#\n# Note that this script delibrately does not pipe perf record into\n# perf script, which would avoid perf.data, because it can create a feedback\n# loop where the perf script syscalls are recorded. Hopefully there will be a\n# fix for this in a later perf version, so perf.data can be skipped, or other\n# kernel features to aggregate by process name in-kernel directly (eg, via\n# eBPF, ktap, or SystemTap).\n#\n# From perf-tools: https://github.com/brendangregg/perf-tools\n#\n# See the syscount(8) man page (in perf-tools) for more info.\n#\n# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n#\n#  (http://www.gnu.org/copyleft/gpl.html)\n#\n# 07-Jul-2014\tBrendan Gregg\tCreated this.\n\n# default variables\nopt_count=0; opt_pid=0; opt_verbose=0; opt_cmd=0; opt_duration=0; opt_tail=0\ntnum=; pid=; duration=; cmd=; cpus=-a; opts=; tcmd=cat; ttext=\ntrap '' INT QUIT TERM PIPE HUP\n\nstdout_workaround=1\t# needed for older perf versions\nwrite_workaround=1\t# needed for perf versions that trace their own writes\n\n### parse options\nwhile getopts cd:hp:t:v opt\ndo\n\tcase $opt in\n\tc)\topt_count=1 ;;\n\td)\topt_duration=1; duration=$OPTARG ;;\n\tp)\topt_pid=1; pid=$OPTARG ;;\n\tt)\topt_tail=1; tnum=$OPTARG ;;\n\tv)\topt_verbose=1 ;;\n\th|?)\tcat <<-END >&2\n\t\tUSAGE: syscount [-chv] [-t top] {-p PID|-d seconds|command}\n\t\t       syscount                  # count by process name\n\t\t                -c               # show counts by syscall name\n\t\t                -h               # this usage message\n\t\t                -v               # verbose: shows PID\n\t\t                -p PID           # trace this PID only\n\t\t                -d seconds       # duration of trace\n\t\t                -t num           # show top number only\n\t\t                command          # run and trace this command\n\t\t  eg,\n\t\t        syscount                 # syscalls by process name\n\t\t        syscount -c              # syscalls by syscall name\n\t\t        syscount -d 5            # trace for 5 seconds\n\t\t        syscount -cp 923         # syscall names for PID 923\n\t\t        syscount -c ls           # syscall names for \"ls\"\n\n\t\tSee the man page and example file for more info.\n\t\tEND\n\t\texit 1\n\tesac\ndone\nshift $(( $OPTIND - 1 ))\n\n### option logic\nif (( $# > 0 )); then\n\topt_cmd=1\n\tcmd=\"$@\"\n\tcpus=\nfi\nif (( opt_pid + opt_duration + opt_cmd > 1 )); then\n\techo >&2 \"ERROR: Pick one of {-p PID|-n name|-d seconds|command}\"\n\texit 1\nfi\nif (( opt_tail )); then\n\ttcmd=\"tail -$tnum\"\n\tttext=\" Top $tnum only.\"\nfi\nif (( opt_duration )); then\n\tcmd=\"sleep $duration\"\n\techo \"Tracing for $duration seconds.$ttext..\"\nfi\nif (( opt_pid )); then\n\tcpus=\n\tcmd=\"-p $pid\"\n\techo \"Tracing PID $pid.$ttext.. Ctrl-C to end.\"\nfi\n(( opt_cmd )) && echo \"Tracing while running: \\\"$cmd\\\".$ttext..\"\n(( opt_pid + opt_duration + opt_cmd == 0 )) && \\\n    echo \"Tracing.$ttext.. Ctrl-C to end.\"\n(( stdout_workaround )) && opts=\"-o /dev/stdout\"\n\nulimit -n 32768\t\t# often needed\n\n### execute syscall name mode\nif (( opt_count && ! opt_verbose )); then\n\t: ${cmd:=sleep 999999}\n\tout=$(perf stat $opts -e 'syscalls:sys_enter_*' $cpus $cmd)\n\tprintf \"%-17s %8s\\n\" \"SYSCALL\" \"COUNT\"\n\techo \"$out\" | awk '\n\t$1 && $2 ~ /syscalls:/ {\n\t\tsub(\"syscalls:sys_enter_\", \"\"); sub(\":\", \"\")\n\t\tgsub(\",\", \"\")\n\t\tprintf \"%-17s %8s\\n\", $2, $1\n\t}' | sort -n -k2 | $tcmd\n\texit\nfi\n\n### execute syscall name with pid mode\nif (( opt_count && opt_verbose )); then\n\tif (( write_workaround )); then\n\t\t# this list must end in write to associate the filter\n\t\ttp=$(perf list syscalls:sys_enter_* | awk '\n\t\t    $1 != \"syscalls:sys_enter_write\" &&  $1 ~ /syscalls:/ { printf \"-e %s \", $1 }')\n\t\ttp=\"$tp -e syscalls:sys_enter_write\"\n\t\tsh -c \"perf record $tp --filter 'common_pid != '\\$\\$ $cpus $cmd\"\n\telse\n\t\tperf record 'syscalls:sys_enter_*' $cpus $cmd\n\t\t# could also pipe direct to perf script\n\tfi\n\n\tprintf \"%-6s %-16s %-17s %8s\\n\" \"PID\" \"COMM\" \"SYSCALL\" \"COUNT\"\n\tperf script --fields pid,comm,event | awk '$1 != \"#\" {\n\t\tsub(\"syscalls:sys_enter_\", \"\"); sub(\":\", \"\")\n\t\ta[$1 \";\" $2 \";\" $3]++\n\t}\n\tEND {\n\t\tfor (k in a) {\n\t\t\tsplit(k, b, \";\");\n\t\t\tprintf \"%-6s %-16s %-17s %8d\\n\", b[2], b[1], b[3], a[k]\n\t\t}\n\t}' | sort -n -k4 | $tcmd\n\texit\nfi\n\n### execute process name mode\ntp=\"-e raw_syscalls:sys_enter\"\nif (( write_workaround )); then\n\tsh -c \"perf record $tp --filter 'common_pid != '\\$\\$ $cpus $cmd\"\nelse\n\tperf record $tp $cpus $cmd\nfi\n\nif (( opt_verbose )); then\n\tprintf \"%-6s %-16s %8s\\n\" \"PID\" \"COMM\" \"COUNT\"\n\tperf script --fields pid,comm | awk '$1 != \"#\" { a[$1 \";\" $2]++ }\n\tEND {\n\t\tfor (k in a) {\n\t\t\tsplit(k, b, \";\");\n\t\t\tprintf \"%-6s %-16s %8d\\n\", b[2], b[1],  a[k]\n\t\t}\n\t}' | sort -n -k3 | $tcmd\nelse\n\tprintf \"%-16s %8s\\n\" \"COMM\" \"COUNT\"\n\tperf script --fields comm | awk '$1 != \"#\" { a[$1]++ }\n\tEND {\n\t\tfor (k in a) {\n\t\t\tprintf \"%-16s %8d\\n\", k,  a[k]\n\t\t}\n\t}' | sort -n -k2 | $tcmd\nfi\n"
        },
        {
          "name": "system",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "user",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}