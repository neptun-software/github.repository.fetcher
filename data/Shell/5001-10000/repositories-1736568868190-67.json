{
  "metadata": {
    "timestamp": 1736568868190,
    "page": 67,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zsh-users/zsh-completions",
      "stars": 7083,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.20703125,
          "content": "; This file is for unifying the coding style for different editors and IDEs.\n; More information at https://editorconfig.org/\n\nroot = true\n\n[_*]\nindent_style = space\nindent_size = 2\ntab_width = 2\nend_of_line = LF\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0556640625,
          "content": "# zsh word code files\n*.zwc\n\n# IDE files\n.vscode/\n.idea/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.9521484375,
          "content": "# Contributing\n\n## How to Contribute to zsh-completions\n\nContributions are welcome, just make sure you follow the guidelines:\n\n * Completions are not accepted when already available in zsh.\n * Completions are not accepted when already available in their original project.\n * Please do not just copy/paste someone else's completion, ask before.\n * Partially implemented completions are not accepted.\n * Please add a header containing authors, status and origin of the script and license header if you do not wish to use the Zsh license (example [here](src/_tox)).\n * Any reasonable open source license is acceptable but note that we recommend the use of the Zsh license and that you should use it if you hope for the function to migrate to zsh itself.\n * Please try to follow the [Zsh completion style guide](https://github.com/zsh-users/zsh/blob/master/Etc/completion-style-guide).\n * Please send one separate pull request per file.\n * Send a pull request or ask for committer access.\n\n## Contributing Completion Functions to Zsh\n\nThe zsh project itself welcomes completion function contributions via\n[github pull requests](https://github.com/zsh-users/zsh/),\n[gitlab merge requests](https://gitlab.com/zsh-org/zsh/) or via patch\nfiles sent to its mailing list, `zsh-workers@zsh.org`.\n\nContributing to zsh has the advantage of reaching the most users.\n\n## Including Completion Functions in Upstream Projects\n\nMany upstream projects include zsh completions.\n\nIf well maintained, this has the advantage that users get a completion\nfunction that matches the installed version of their software.\n\nIf you are the upstream maintainer this is a good choice. If the project\nalready includes completions for bash, fish, tcsh, etc then they are\nlikely open to including zsh's too. It can also be a good option for\ncompletions handling commands that are system or distribution specific.\n\nIdeally, arrange for the project's build system to install the\ncompletion function in `$prefix/share/zsh/site-functions`.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4443359375,
          "content": "The Z Shell is copyright (c) 1992-2017 Paul Falstad, Richard Coleman,\nZoltán Hidvégi, Andrew Main, Peter Stephenson, Sven Wischnowsky, and\nothers.  All rights reserved.  Individual authors, whether or not\nspecifically named, retain copyright in all changes; in what follows, they\nare referred to as `the Zsh Development Group'.  This is for convenience\nonly and this body has no legal status.  The Z shell is distributed under\nthe following licence; any provisions made in individual files take\nprecedence.\n\nPermission is hereby granted, without written agreement and without\nlicence or royalty fees, to use, copy, modify, and distribute this\nsoftware and to distribute modified versions of this software for any\npurpose, provided that the above copyright notice and the following\ntwo paragraphs appear in all copies of this software.\n\nIn no event shall the Zsh Development Group be liable to any party for\ndirect, indirect, special, incidental, or consequential damages arising out\nof the use of this software and its documentation, even if the Zsh\nDevelopment Group have been advised of the possibility of such damage.\n\nThe Zsh Development Group specifically disclaim any warranties, including,\nbut not limited to, the implied warranties of merchantability and fitness\nfor a particular purpose.  The software provided hereunder is on an \"as is\"\nbasis, and the Zsh Development Group have no obligation to provide\nmaintenance, support, updates, enhancements, or modifications.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.8486328125,
          "content": "zsh-completions ![GitHub release](https://img.shields.io/github/release/zsh-users/zsh-completions.svg) ![GitHub contributors](https://img.shields.io/github/contributors/zsh-users/zsh-completions.svg) [![IRC](https://img.shields.io/badge/IRC-%23zsh--completions-yellow.svg)](irc://irc.freenode.net/#zsh-completions) [![Gitter](https://badges.gitter.im/zsh-users/zsh-completions.svg)](https://gitter.im/zsh-users/zsh-completions?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n=============\n\n**Additional completion definitions for [Zsh](https://www.zsh.org/).**\n\n*This projects aims at gathering/developing new completion scripts that are not available in Zsh yet. The scripts may be contributed to the Zsh project when stable enough.*\n\n\n## Usage\n\n### Using packages\n\n| System  | Package |\n| ------------- | ------------- |\n| Debian / Ubuntu | [zsh-completions OBS repository](https://software.opensuse.org/download.html?project=shells%3Azsh-users%3Azsh-completions&package=zsh-completions) |\n| Fedora / CentOS / RHEL / Scientific Linux | [zsh-completions OBS repository](https://software.opensuse.org/download.html?project=shells%3Azsh-users%3Azsh-completions&package=zsh-completions) |\n| OpenSUSE / SLE | [zsh-completions OBS repository](https://software.opensuse.org/download.html?project=shells%3Azsh-users%3Azsh-completions&package=zsh-completions) |\n| Arch Linux / Manjaro / Antergos / Hyperbola | [zsh-completions](https://www.archlinux.org/packages/zsh-completions), [zsh-completions-git](https://aur.archlinux.org/packages/zsh-completions-git) |\n| Gentoo / Funtoo | [app-shells/zsh-completions](https://packages.gentoo.org/packages/app-shells/zsh-completions)  |\n| NixOS | [zsh-completions](https://github.com/NixOS/nixpkgs/blob/master/pkgs/shells/zsh/zsh-completions/default.nix) |\n| Void Linux | [zsh-completions](https://github.com/void-linux/void-packages/blob/master/srcpkgs/zsh-completions/template) |\n| Slackware | [Slackbuilds](https://slackbuilds.org/repository/14.2/system/zsh-completions/) |\n| macOS | [homebrew](https://github.com/Homebrew/homebrew-core/blob/master/Formula/z/zsh-completions.rb), [MacPorts](https://github.com/macports/macports-ports/blob/master/sysutils/zsh-completions/Portfile)  |\n| NetBSD | [pkgsrc](https://ftp.netbsd.org/pub/pkgsrc/current/pkgsrc/shells/zsh-completions/README.html)  |\n| FreeBSD | [shells/zsh-completions](https://www.freshports.org/shells/zsh-completions)  |\n\n\n### Using zsh frameworks\n\n#### [antigen](https://github.com/zsh-users/antigen)\n\nAdd `antigen bundle zsh-users/zsh-completions` to your `~/.zshrc`.\n\n#### [oh-my-zsh](https://github.com/ohmyzsh/ohmyzsh)\n\n* Clone the repository inside your oh-my-zsh repo:\n\n        git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions\n\n* Add it to `FPATH` in your `.zshrc` by adding the following line before `source \"$ZSH/oh-my-zsh.sh\"`:\n\n        fpath+=${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions/src\n\nNote: adding it as a regular Oh My ZSH! plugin will not work properly (see [#603](https://github.com/zsh-users/zsh-completions/issues/603)).\n\n#### [zinit](https://github.com/zdharma-continuum/zinit)\n\nAdd `zinit light zsh-users/zsh-completions` to your `~/.zshrc`.\n\n### Manual installation\n\n* Clone the repository:\n\n        git clone https://github.com/zsh-users/zsh-completions.git\n\n* Include the directory in your `$fpath`, for example by adding in `~/.zshrc`:\n\n        fpath=(path/to/zsh-completions/src $fpath)\n\n* You may have to force rebuild `zcompdump`:\n\n        rm -f ~/.zcompdump; compinit\n\n### Contributing\n\nContributions are welcome, see [CONTRIBUTING](https://github.com/zsh-users/zsh-completions/blob/master/CONTRIBUTING.md).\n\n\n## License\nCompletions use the Zsh license, unless explicitly mentioned in the file header.\nSee [LICENSE](https://github.com/zsh-users/zsh-completions/blob/master/LICENSE) for more information.\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "zsh-completions-howto.org",
          "type": "blob",
          "size": 28.8935546875,
          "content": "* Table of Contents                                                     :TOC:\n- [[#intro][Intro]]\n- [[#getting-started][Getting started]]\n  - [[#telling-zsh-which-function-to-use-for-completing-a-command][Telling zsh which function to use for completing a command]]\n  - [[#completing-generic-gnu-commands][Completing generic gnu commands]]\n  - [[#copying-completions-from-another-command][Copying completions from another command]]\n- [[#writing-your-own-completion-functions][Writing your own completion functions]]\n  - [[#utility-functions][Utility functions]]\n  - [[#writing-simple-completion-functions-using-_describe][Writing simple completion functions using _describe]]\n  - [[#writing-completion-functions-using-_alternative][Writing completion functions using _alternative]]\n  - [[#writing-completion-functions-using-_arguments][Writing completion functions using _arguments]]\n  - [[#writing-completion-functions-using-_regex_arguments-and-_regex_words][Writing completion functions using _regex_arguments and _regex_words]]\n  - [[#complex-completions-with-_values-_sep_parts--_multi_parts][complex completions with _values, _sep_parts, & _multi_parts]]\n  - [[#adding-completion-words-directly-using-compadd][Adding completion words directly using compadd]]\n- [[#testing--debugging][Testing & debugging]]\n- [[#gotchas-things-to-watch-out-for][Gotchas (things to watch out for)]]\n- [[#tips][Tips]]\n- [[#other-resources][Other resources]]\n\n* Intro\nThe official documentation for writing zsh completion functions is difficult to understand, and doesn't give many examples.\nAt the time of writing this document I was able to find a few other tutorials on the web, however those tutorials only\nexplain a small portion of the capabilities of the completion system. This document aims to cover areas not explained elsewhere,\nwith examples, so that you can learn how to write more advanced completion functions. I do not go into all the details, but will\ngive enough information and examples to get you up and running. If you need more details you can look it up for yourself in the\n [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System][official documentation]].\n\nPlease make any scripts that you create publicly available for others (e.g. by forking this repo and making a [[id:64bcd501-b0f0-48c7-b8e2-07af708b95ec][pull request]]).\nAlso if you have any more information to add or improvements to make to this tutorial, please do.\n* Getting started\n** Telling zsh which function to use for completing a command\nCompletion functions for commands are stored in files with names beginning with an underscore _, and these files should\nbe placed in a directory listed in the $fpath variable.\nYou can add a directory to $fpath by adding a line like this to your ~/.zshrc file:\n#+BEGIN_SRC sh\nfpath=(~/newdir $fpath)\n#+END_SRC\nThe first line of a completion function file can look something like this:\n#+BEGIN_SRC sh\n#compdef foobar\n#+END_SRC\nThis tells zsh that the file contains code for completing the foobar command.\nThis is the format that you will use most often for the first line, but you can also use the same file for completing\nseveral different functions if you want. See [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Autoloaded-files][here]] for more details.\n\nYou can also use the compdef command directly (e.g. in your ~/.zshrc file) to tell zsh which function to use for completing\na command like this:\n#+BEGIN_SRC sh\n> compdef _function foobar\n#+END_SRC\nor to use the same completions for several commands:\n#+BEGIN_SRC sh\n> compdef _function foobar goocar hoodar\n#+END_SRC\nor if you want to supply arguments:\n#+BEGIN_SRC sh\n> compdef '_function arg1 arg2' foobar\n#+END_SRC\nSee [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Functions-4][here]] for more details.\n** Completing generic gnu commands\nMany [[https://www.gnu.org/][gnu]] commands have a standardized way of listing option descriptions (when the --help option is used).\nFor these commands you can use the _gnu_generic function for automatically creating completions, like this:\n#+BEGIN_SRC sh\n> compdef _gnu_generic foobar\n#+END_SRC\nor to use _gnu_generic with several different commands:\n#+BEGIN_SRC sh\n> compdef _gnu_generic foobar goocar hoodar\n#+END_SRC\nThis line can be placed in your ~/.zshrc file.\n** Copying completions from another command\nIf you want a command, say cmd1, to have the same completions as another, say cmd2, which has already had\ncompletions defined for it, you can do this:\n#+BEGIN_SRC sh\n> compdef cmd1=cmd2\n#+END_SRC\nThis can be useful for example if you have created an alias for a command to help you remember it.\n* Writing your own completion functions\nA good way to get started is to look at some already defined completion functions.\nOn my linux installation these are found in /usr/share/zsh/functions/Completion/Unix\nand /usr/share/zsh/functions/Completion/Linux and a few other subdirs.\n\nYou will notice that the _arguments function is used a lot in these files.\nThis is a utility function that makes it easy to write simple completion functions.\nThe _arguments function is a wrapper around the compadd builtin function.\nThe compadd builtin is the core function used to add completion words to the command line, and control its behaviour.\nHowever, most of the time you will not need to use compadd, since there are many utility functions such as _arguments\nand _describe which are easier to use.\n\nFor very basic completions the _describe function should be adequate\n\n** Utility functions\nHere is a list of some of the utility functions that may be of use.\nThe full list of utility functions, with full explanations, is available [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-Functions][here]].\nExamples of how to use these functions are given in the next section.\n\n*** main utility functions for overall completion\n| _alternative     | Can be used to generate completion candidates from other utility functions or shell code.                         |\n| _arguments       | Used to specify how to complete individual options & arguments for a command with unix style options.                             |\n| _describe        | Used for creating simple completions consisting of words with descriptions (but no actions). Easier to use than _arguments |\n| _gnu_generic     | Can be used to complete options for commands that understand the `--help' option.                                                 |\n| _regex_arguments | Creates a function for matching commandline arguments with regular expressions, and then performing actions/completions.          |\n*** functions for performing complex completions of single words\n| _values      | Used for completing arbitrary keywords (values) and their arguments, or comma separated lists of such combinations.                                                  |\n| _combination | Used to complete combinations of values, for example pairs of hostnames and usernames.                                                                               |\n| _multi_parts | Used for completing multiple parts of words separately where each part is separated by some char, e.g. for completing partial filepaths: /u/i/sy -> /usr/include/sys |\n| _sep_parts   | Like _multi_parts but allows different separators at different parts of the completion.                                                                              |\n| _sequence    | Used as a wrapper around another completion function to complete a delimited list of matches generated by that other function.\n*** functions for completing specific types of objects\n| _path_files     | Used to complete filepaths. Take several options to control behaviour.                                    |\n| _files          | Calls _path_files with all options except -g and -/. These options depend on file-patterns style setting. |\n| _net_interfaces | Used for completing network interface names                                                               |\n| _users          | Used for completing user names                                                                            |\n| _groups         | Used for completing group names                                                                           |\n| _options        | Used for completing the names of shell options.                                                           |\n| _parameters     | Used for completing the names of shell parameters/variables (can restrict to those matching a pattern).   |\n*** functions for handling cached completions\nIf you have a very large number of completions you can save them in a cache file so that the completions load quickly.\n| _cache_invalid  | indicates whether the completions cache corresponding to a given cache identifier needs rebuilding |\n| _retrieve_cache | retrieves completion information from a cache file                                                 |\n| _store_cache    | store completions corresponding to a given cache identifier in a cache file                        |\n*** other functions\n| _message     | Used for displaying help messages in places where no completions can be generated.                                      |\n| _regex_words | Can be used to generate arguments for the _regex_arguments command. This is easier than writing the arguments manually. |\n| _guard       | Can be used in the ACTION of specifications for _arguments and similar functions to check the word being completed.     |\n*** Actions\nMany of the utility functions such as _arguments, _regex_arguments, _alternative and _values may include an action\nat the end of an option/argument specification. This action indicates how to complete the corresponding argument.\nThe actions can take one of the following forms:\n| ( )                               | Argument is required but no matches are generated for it.                                                                                |\n| (ITEM1 ITEM2)                     | List of possible matches                                                                                                                 |\n| ((ITEM1\\:'DESC1' ITEM2\\:'DESC2')) | List of possible matches, with descriptions. Make sure to use different quotes than those around the whole specification.                |\n| ->STRING                          | Set $state to STRING and continue ($state can be checked in a case statement after the utility function call)                            |\n| FUNCTION                          | Name of a function to call for generating matches or performing some other action, e.g. _files or _message                               |\n| {EVAL-STRING}                     | Evaluate string as shell code to generate matches. This can be used to call a utility function with arguments, e.g. _values or _describe |\n| =ACTION                           | Inserts a dummy word into completion command line without changing the point at which completion takes place.                            |\nNot all action types are available for all utility functions that use them. For example the ->STRING type is not available in the\n_regex_arguments or _alternative functions.\n** Writing simple completion functions using _describe\nThe _describe function can be used for simple completions where the order and position of the options/arguments is\nnot important. You just need to create an array parameter to hold the options & their descriptions, and then pass\nthe parameter name as an argument to _describe. The following example creates completion candidates c and d, with\nthe descriptions (note this should be put in a file called _cmd in some directory listed in $fpath).\n#+BEGIN_SRC sh\n#compdef cmd\nlocal -a subcmds\nsubcmds=('c:description for c command' 'd:description for d command')\n_describe 'command' subcmds\n#+END_SRC\n\nYou can use several different lists separated by a double hyphen as follows but note that this mixes the matches under and single heading and is not intended to be used with different types of completion candidates:\n#+BEGIN_SRC sh\nlocal -a subcmds topics\nsubcmds=('c:description for c command' 'd:description for d command')\ntopics=('e:description for e help topic' 'f:description for f help topic')\n_describe 'command' subcmds -- topics\n#+END_SRC\n\nIf two candidates have the same description, _describe collects them together on the same row and ensures that descriptions are aligned in neatly in columns.\nThe _describe function can be used in an ACTION as part of a specification for _alternative, _arguments or _regex_arguments.\nIn this case you will have to put it in braces with its arguments, e.g. 'TAG:DESCRIPTION:{_describe 'values' options}'\n** Writing completion functions using _alternative\nLike _describe, this function performs simple completions where the order and position of options/arguments is not important.\nHowever, unlike _describe, instead of fixed matches further functions may be called to generate the completion candidates. Furthermore, _alternative allows a mix of different types of completion candidates to be mixed.\n\nAs arguments it takes a list of specifications each in the form 'TAG:DESCRIPTION:ACTION' where TAG is a special tag that identifies the type of completion matches,\nDESCRIPTION is used as a heading to describe the group of completion candidates collectively, and ACTION is one of the action types listed previously (apart from the ->STRING and =ACTION forms).\nFor example:\n#+BEGIN_SRC sh\n_alternative 'arguments:custom arg:(a b c)' 'files:filename:_files'\n#+END_SRC\nThe first specification adds completion candidates a, b & c, and the second specification calls the _files function for completing filepaths.\n\nWe could split the specifications over several lines with \\ and add descriptions to each of the custom args like this:\n#+BEGIN_SRC sh\n_alternative \\\n  'args:custom arg:((a\\:\"description a\" b\\:\"description b\" c\\:\"description c\"))' \\\n  'files:filename:_files'\n#+END_SRC\n\nIf we want to pass arguments to _files they can simply be included, like this:\n#+BEGIN_SRC sh\n_alternative \\\n  'args:custom arg:((a\\:\"description a\" b\\:\"description b\" c\\:\"description c\"))'\\\n  'files:filename:_files -/'\n#+END_SRC\n\nTo use parameter expansion to create our list of completions we must use double quotes to quote the specifications,\ne.g:\n#+BEGIN_SRC sh\n_alternative \\\n  \"dirs:user directory:($userdirs)\" \\\n  \"pids:process ID:($(ps -A o pid=))\"\n#+END_SRC\nIn this case the first specification adds the words stored in the $userdirs variable, and the second specification\nevaluates 'ps -A o pid=' to get a list of pids to use as completion candidates. In practice, we would make used of the existing _pids function for this.\n\nWe can use other utility functions such as _values in the ACTION to perform more complex completions, e.g:\n#+BEGIN_SRC sh\n_alternative \\\n  \"directories:user directory:($userdirs)\" \\\n  'options:comma-separated opt: _values -s , letter a b c'\n#+END_SRC\nthis will complete the items in $userdirs, as well as a comma separated list containing a, b &/or c. Note the use of the initial space before _values. This is needed because _values doesn't understand standard compadd options for descriptions.\n\nAs with _describe, the _alternative function can itself be used in an ACTION as part of a specification for _arguments\nor _regex_arguments.\n** Writing completion functions using _arguments\nWith a single call to the  _arguments function you can create fairly sophisticated completion functions. It is intended to handle typical commands that take a variety of options along with some normal arguments.\nLike the _alternative function, _arguments takes a list of specification strings as arguments.\nThese specification strings specify options and any corresponding option arguments (e.g. -f filename),\nor command arguments.\n\nBasic option specifications take the form '-OPT[DESCRIPTION]', e.g. like this:\n#+BEGIN_SRC sh\n_arguments '-s[sort output]' '--l[long output]' '-l[long output]'\n#+END_SRC\nArguments for the option can be specified after the option description in this form '-OPT[DESCRIPTION]:MESSAGE:ACTION',\nwhere MESSAGE is a message to display and ACTION can be any of the forms mentioned in the ACTIONS section above.\nFor example:\n#+BEGIN_SRC sh\n_arguments '-f[input file]:filename:_files'\n#+END_SRC\n\nCommand argument specifications take the form 'N:MESSAGE:ACTION' where N indicates that it is the Nth command argument,\nand MESSAGE & ACTION are as before. If the N is omitted then it just means the next command argument (after any that have\nalready been specified). If a double colon is used at the start (after N) then the argument is optional.\nFor example:\n#+BEGIN_SRC sh\n_arguments '-s[sort output]' '1:first arg:_net_interfaces' '::optional arg:_files' ':next arg:(a b c)'\n#+END_SRC\nhere the first arg is a network interface, the next optional arg is a file name, the last arg can be either a, b or c,\nand the -s option may be completed at any position.\n\nThe _arguments function allows the full set of ACTION forms listed in the ACTION section above.\nThis means that you can use actions for selecting case statement branches like this:\n#+BEGIN_SRC sh\n_arguments '-m[music file]:filename:->files' '-f[flags]:flag:->flags'\ncase \"$state\" in\n    files)\n        local -a music_files\n        music_files=( Music/**/*.{mp3,wav,flac,ogg} )\n        _multi_parts / music_files\n        ;;\n    flags)\n        _values -s , 'flags' a b c d e\n        ;;\nesac\n#+END_SRC\nIn this case paths to music files are completed stepwise descending down directories using the _multi_parts function,\nand the flags are completed as a comma separated list using the _values function.\n\nI have just given you the basics of _arguments specifications here, you can also specify mutually exclusive options,\nrepeated options & arguments, options beginning with + instead of -, etc. For more details see the [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System][official documentation]].\nAlso have a look at the tutorials mentioned at the end of this document, and the completion functions in the [[https://github.com/vapniks/zsh-completions/tree/master/src][src directory]].\n** Writing completion functions using _regex_arguments and _regex_words\nIf you have a complex command line specification with several different possible argument sequences then\nthe _regex_arguments function may be what you need. It typically works well where you have a series of keywords followed by a variable number of arguments.\n\n_regex_arguments creates a completion function whose name is given by the first argument.\nHence you need to first call _regex_arguments to create the completion function, and then call that function,\ne.g. like this:\n#+BEGIN_SRC sh\n_regex_arguments _cmd OTHER_ARGS..\n_cmd \"$@\"\n#+END_SRC\n\nThe OTHER_ARGS should be sequences of specifications for matching & completing words on the command line.\nThese sequences can be separated by '|' to represent alternative sequences of words.\nYou can use bracketing to arbitrary depth to specify alternate subsequences, but the brackets must be backslashed like this \\( \\)\nor quoted like this '(' ')'.\n\nFor example:\n#+BEGIN_SRC sh\n_regex_arguments _cmd SEQ1 '|' SEQ2 \\( SEQ2a '|' SEQ2b \\)\n_cmd \"$@\"\n#+END_SRC\nThis specifies a command line matching either SEQ1, or SEQ2 followed by SEQ2a or SEQ2b. You are describing the form arguments to the command take in the form of a regular expression grammar.\n\nEach specification in a sequence must contain a / PATTERN/ part at the start followed by an optional ':TAG:DESCRIPTION:ACTION'\npart.\n\nEach PATTERN is a regular expression to match a word on the command line. These patterns are processed sequentially\nuntil we reach a pattern that doesn't match at which point any corresponding ACTION is performed to obtain completions\nfor that word. Note that there needs to be a pattern to match the initial command itself.\nSee below for further explanation about PATTERNs.\n\nThe ':TAG:DESCRIPTION:ACTION' part is interpreted in the same way as for the _alternative function specifications,\nexcept that it has an extra : at the start, and now all of the possible ACTION formats listed previously are allowed.\n\nHere is an example:\n#+BEGIN_SRC sh\n_regex_arguments _cmd /$'[^\\0]##\\0'/ \\( /$'word1(a|b|c)\\0'/ ':word:first word:(word1a word1b word1c)' '|'\\\n   /$'word11(a|b|c)\\0'/ ':word:first word:(word11a word11b word11c)' \\( /$'word2(a|b|c)\\0'/ ':word:second word:(word2a word2b word2c)'\\\n   '|' /$'word22(a|b|c)\\0'/ ':word:second word:(word22a word22b word22c)' \\) \\)\n_cmd \"$@\"\n#+END_SRC\nin this case the first word can be word1 or word11 followed by an a, b or c, and if the first word contains 11 then a second\nword is allowed which can be word2 followed by and a, b, or c, or a filename.\n\nIf this sounds too complicated a much simpler alternative is to use the _regex_words function for creating\nspecifications for _regex_arguments.\n*** Patterns\nYou may notice that the / PATTERN/ specs in the previous example don't look like normal regular expressions.\nOften a string parameter in the form $'foo\\0' is used. This is so that the \\0 in the string is interpreted correctly\nas a null char which is used to separate words in the internal representation. If you don't include the \\0 at the end\nof the pattern you may get problems matching the next word. If you need to use the contents of a variable in a pattern,\nyou can double quote it so that it gets expanded and then put a string parameter containing a null char afterwards,\nlike this: \"$somevar\"$'\\0'\n\nThe regular expression syntax for patterns seems to be a bit different from normal regular expressions,\nand I can't find documentation anywhere.\nHowever I have managed to work out what the following special chars are for:\n| *  | wildcard - any number of chars                                            |\n| ?  | wildcard - single char                                                    |\n| #  | zero or more of the previous char (like * in a normal regular expression) |\n| ## | one or more of the previous char (like + in a normal regular expression)  |\n*** _regex_words\nThe _regex_words function makes it much easier to create specifications for _regex_arguments.\nThe results of calling _regex_words can be stored in a variable which can then be used instead\nof a specification for _regex_arguments.\n\nTo create a specification using _regex_words you supply it with a tag followed by a description followed by a list\nof specifications for individual words. These specifications take the form 'WORD:DESCRIPTION:SPEC' where WORD is the\nword to be completed, DESCRIPTION is a description for it, and SPEC can be another variable created by _regex_words\nspecifying words that come after the current word or blank if there are no further words.\nFor example:\n#+BEGIN_SRC sh\n_regex_words firstword 'The first word' 'word1a:a word:' 'word1b:b word:' 'word1c:c word'\n#+END_SRC\nthe results of this function call will be stored in the $reply array, and so we should store it in another array\nbefore $reply gets changed again, like this:\n#+BEGIN_SRC sh\nlocal -a firstword\n_regex_words word 'The first word' 'word1a:a word:' 'word1b:b word:' 'word1c:c word'\nfirstword=\"$reply[@]\"\n#+END_SRC\nwe could then use it with _regex_arguments like this:\n#+BEGIN_SRC sh\n_regex_arguments _cmd /$'[^\\0]##\\0'/ \"$firstword[@]\"\n_cmd \"$@\"\n#+END_SRC\nNote that I have added an extra pattern for the initial command word itself.\n\nHere is a more complex example where we call _regex_words for different words on the command line\n#+BEGIN_SRC sh\nlocal -a firstword firstword2 secondword secondword2\n_regex_words word1 'The second word' 'woo:tang clan' 'hoo:not me'\nsecondword=(\"$reply[@]\")\n_regex_words word2 'Another second word' 'yee:thou' 'haa:very funny!'\nsecondword2=(\"$reply[@]\")\n_regex_words commands 'The first word' 'foo:do foo' 'man:yeah man' 'chu:at chu'\nfirstword=(\"$reply[@]\")\n_regex_words word4 'Another first word' 'boo:scare somebody:$secondword' 'ga:baby noise:$secondword'\\\n 'loo:go to the toilet:$secondword2'\nfirstword2=(\"$reply[@]\")\n\n_regex_arguments _hello /$'[^\\0]##\\0'/ \"${firstword[@]}\" \"${firstword2[@]}\"\n_hello \"$@\"\n#+END_SRC\nIn this case the first word can be one of \"foo\", \"man\", \"chu\", \"boo\", \"ga\" or \"loo\".\nIf the first word is \"boo\" or \"ga\" then the second word can be \"woo\" or \"hoo\",\nand if the first word is \"loo\" then the second word can be \"yee\" or \"haa\", in the other\ncases there is no second word.\n\nFor a good example of the usage of _regex_words have a look at the _ip function.\n** complex completions with _values, _sep_parts, & _multi_parts\nThe _values, _sep_parts & _multi_parts functions can be used either on their own, or as ACTIONs in specifications for\n_alternative, _arguments or _regex_arguments. The following examples may be instructive.\nSee the [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System][official documentation]] for more info.\n\nSpace separated list of mp3 files:\n#+BEGIN_SRC sh\n_values 'mp3 files' ~/*.mp3\n#+END_SRC\n\nComma separated list of session id numbers:\n#+BEGIN_SRC sh\n_values -s , 'session id' \"${(uonzf)$(ps -A o sid=)}\"\n#+END_SRC\n\nCompletes foo@news:woo, or foo@news:laa, or bar@news:woo, etc:\n#+BEGIN_SRC sh\n_sep_parts '(foo bar)' @ '(news ftp)' : '(woo laa)'\n#+END_SRC\n\nComplete some MAC addresses one octet at a time:\n#+BEGIN_SRC sh\n_multi_parts : '(00:11:22:33:44:55 00:23:34:45:56:67 00:23:45:56:67:78)'\n#+END_SRC\n\n** Adding completion words directly using compadd\nFor more fine grained control you can use the builtin compadd function to add completion words directly.\nThis function has many different options for controlling how completions are displayed and how text on the command line\ncan be altered when words are completed. Read the  [[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System][official documentation]] for full details.\nHere I just give a few simple examples.\n\nAdd some words to the list of possible completions:\n#+BEGIN_SRC sh\ncompadd foo bar blah\n#+END_SRC\n\nAs above but also display an explanation:\n#+BEGIN_SRC sh\ncompadd -X 'Some completions' foo bar blah\n#+END_SRC\n\nAs above but automatically insert a prefix of \"what_\" before the completed word:\n#+BEGIN_SRC sh\ncompadd -P what_ foo bar blah\n#+END_SRC\n\nAs above but automatically insert a suffix of \"_todo\" after the completed word:\n#+BEGIN_SRC sh\ncompadd -S _todo foo bar blah\n#+END_SRC\n\nAs above but automatically remove the \"_todo\" suffix if a blank char is typed after the suffix:\n#+BEGIN_SRC sh\ncompadd -P _todo -q foo bar blah\n#+END_SRC\n\nAdd words in array $wordsarray to the list of possible completions\n#+BEGIN_SRC sh\ncompadd -a wordsarray\n#+END_SRC\n\n* Testing & debugging\nTo reload a completion function:\n#+BEGIN_SRC sh\n> unfunction _func\n> autoload -U _func\n#+END_SRC\n\nThe following functions can be called to obtain useful information.\nIf the default keybindings don't work you can try pressing Alt+x and then enter the command name.\n| Function        | Default keybinding | Description                                                                                                                    |\n|-----------------+--------------------+--------------------------------------------------------------------------------------------------------------------------------|\n| _complete_help  | Ctrl+x h           | displays information about context names, tags, and completion functions used when completing at the current cursor position   |\n| _complete_help  | Alt+2 Ctrl+x h     | as above but displays even more information                                                                                    |\n| _complete_debug | Ctrl+x ?           | performs ordinary completion, but captures in a temporary file a trace of the shell commands executed by the completion system |\n* Gotchas (things to watch out for)\nRemember to include a #compdef line at the beginning of the file containing the completion function.\n\nTake care to use the correct type of quoting for specifications to _arguments or _regex_arguments:\nuse double quotes if there is a parameter that needs to be expanded in the specification, single quotes otherwise,\nand make sure to use different quotes around item descriptions.\n\nCheck that you have the correct number of :'s in the correct places for specifications for _arguments,\n_alternative, _regex_arguments, etc.\n\nRemember to include an initial pattern to match the command word when using _regex_arguments (it does not need a matching action).\n\nRemember to put a null char $'\\0' at the end of any PATTERN argument for _regex_arguments\n* Tips\nSometimes you have a situation where there is just one option that can come after a subcommand, and zsh will complete this\nautomatically when tab is pressed after the subcommand. If instead you want it listed with its description before completing\nyou can add another empty option (i.e. \\:) to the ACTION like this ':TAG:DESCRIPTION:((opt1\\:\"description for opt1\" \\:))'\nNote this only applies to utility functions that use ACTIONs in their specification arguments (_arguments, _regex_arguments, etc.)\n\n* Other resources\n[[https://wikimatze.de/writing-zsh-completion-for-padrino/][Here]] is a nicely formatted short tutorial showing basic usage of the _arguments function,\nand [[https://web.archive.org/web/20190411104837/http://www.linux-mag.com/id/1106/][here]] is a slightly more advanced tutorial using the _arguments function.\n[[https://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System][Here]] is the zshcompsys man page.\n"
        },
        {
          "name": "zsh-completions.plugin.zsh",
          "type": "blob",
          "size": 0.021484375,
          "content": "fpath+=\"${0:A:h}/src\"\n"
        }
      ]
    }
  ]
}