{
  "metadata": {
    "timestamp": 1736568898174,
    "page": 110,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hyperupcall/autoenv",
      "stars": 5754,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2001953125,
          "content": "root = true\n\n[*]\nindent_style = tab\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.{md,yaml,yml}]\nindent_style = space\nindent_size = 2\nquote_type = single\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0322265625,
          "content": "node_modules/\ntests/lasttest.log\n"
        },
        {
          "name": ".markdownlint.json",
          "type": "blob",
          "size": 0.11328125,
          "content": "{\n\t\"commands-show-output\": false,\n\t\"line-length\": false,\n\t\"no-inline-html\": false,\n\t\"no-duplicate-heading\": false\n}\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0205078125,
          "content": "package-lock = false\n"
        },
        {
          "name": ".shellcheckrc",
          "type": "blob",
          "size": 0.029296875,
          "content": "disable=SC3043\ndisable=SC2216\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.2978515625,
          "content": "# Change Log\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/) and this project adheres to [Semantic Versioning](http://semver.org/).\n\n## [v0.3.0] - 2021-9-5\n\n### Fixed\n\n- Leave `$OLDPWD` intact (#141)\n- `AUTOENV_CUR_DIR` contains leading double quote (#150)\n- Prevent any alias usage (#144)\n- Broken mountpoint detection (#151)\n- Add `AUTOENV_ASSUME_YES` (#162)\n- Execute `.env.leave` when leaving directory (#167)\n- Ensure parent directory of `AUTOENV_AUTH_FILE` exists (#201)\n- Improve platform compatibility (#174, #176, #202)\n\n## [v0.2.1] - 2016-10-18\n\n### Fixed\n\n- Remove debug output (#126)\n- Paths with spaces on dash\n- Custom names for .env (#109)\n- Usage of double slashes (#125)\n- Infinite loop when symlinking across mountpoints (#133)\n- Don't allow chdir aliases\n- Mountpoint detection (#138 #139)\n- No more override of `$OLDPWD` (#141)\n- .env files at mountpoint are now being found (#146)\n\n## [v0.2.0] - 2016-08-08\n\n### Added\n\n- setup.py for pyPi\n- setup.py in the Makefile\n- Support for OS X\n- Support for the dash shell\n- Accept 'y' or 'Y' as answer\n- Expose `AUTOENV_CUR_FILE` and `AUTOENV_CUR_DIR`\n\n### Fixed\n\n- Fix spaces in filenames\n- Strange grep behavior\n- Look for a .env file when activating autoenv\n- Fix sha1sum not being found\n- Support aliased cd\n- Require .env to be a regular file\n- autoenv now works with noclobber\n- Crash with zsh 5.1\n\n### Changed\n\n- Don't run in mc\n- Updated readme\n- Export all variables\n- Rewrote tests\n- Follow .env files until the mountpoint\n\n### Security\n\n- Add quotes everywhere in the shell script\n- Print hidden characters\n\n## [v0.1.0] - 2012-02-15\n\n### Added\n\n- .env files need approval now\n\n### Fixed\n\n- Execution on zsh\n\n### Changed\n\n- Put autoenv under a public license\n\n## [v0.0.1] - 2012-02-13\n\n### Added\n\n- Initial public version of autoenv\n- Allows executing .env files recursively\n- Makefile for testing\n- Unit tests with dtf\n- Travis file for testing\n\n[v0.0.1]: https://github.com/inishchith/autoenv/releases/tag/v0.0.1\n[v0.1.0]: https://github.com/inishchith/autoenv/releases/tag/v0.1.0\n[v0.2.0]: https://github.com/inishchith/autoenv/releases/tag/v0.2.0\n[v0.2.1]: https://github.com/inishchith/autoenv/releases/tag/v0.2.1\n[v0.3.0]: https://github.com/inishchith/autoenv/releases/tag/v0.3.0\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0322265625,
          "content": "Copyright (C) 2012 Kenneth Reitz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.29296875,
          "content": ".PHONY: test test-bats publish\n\ntest:\n\tsh tests/test.sh\n\ntest-bats:\n\tbats tests\n\ntest2:\n\t@echo \"=== AUTOENV TESTING SH ===\"\n\tsh ./shelltestrunner.sh\n\t@echo \"=== AUTOENV TESTING BASH ===\"\n\tbash ./shelltestrunner.sh\n\t@echo \"=== AUTOENV TESTING ZSH ===\"\n\tzsh ./shelltestrunner.sh\n\npublish:\n\tnpm publish\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4970703125,
          "content": "# Autoenv: Directory-based Environments ![Build Status](https://github.com/hyperupcall/autoenv/actions/workflows/ci.yml/badge.svg)\n\nMagic per-project shell environments.\n\n## What is it?\n\nIf a directory contains an `.env` file, it will automatically be executed when you `cd` into it. And, if a directory contains an `.env.leave` file (and `AUTOENV_ENABLE_LEAVE` is a non-empty string), the file will automatically be executed when `cd`'ing away from the directory that contains that file.\n\nThis is great for...\n\n- auto-activating virtualenvs\n- auto-deactivating virtualenvs\n- project-specific environment variables\n- making millions\n\nYou can also nest envs within each other. How awesome is that!?\n\nWhen executing, autoenv, will walk up the directories until the mount\npoint and execute all `.env` files beginning at the top.\n\n## Usage\n\nFollow the white rabbit:\n\n```sh\n$ echo \"echo 'whoa'\" > ./project/.env\n$ cd ./project\nwhoa\n```\n\n![Mind blown GIF](http://media.tumblr.com/tumblr_ltuzjvbQ6L1qzgpx9.gif)\n\n## Installation (automated)\n\n```sh\n# with cURL\ncurl -#fLo- 'https://raw.githubusercontent.com/hyperupcall/autoenv/master/scripts/install.sh' | sh\n\n# with wget\nwget --show-progress -o /dev/null -O- 'https://raw.githubusercontent.com/hyperupcall/autoenv/master/scripts/install.sh' | sh\n```\n\nIf you encounter some variant of a `curl: command not found` or `wget: command not found` error, please install either cURL or wget (with your package manager) and try again.\n\n## Installation (manual)\n\nWhen installing manually, you first install autoenv with either Homebrew, npm, or Git. Then, you run a command to ensure autoenv is loaded when you open a terminal (this command depends on your [default shell](https://askubuntu.com/a/590901)).\n\n### Installation Method\n\nNote that depending on your shell and operating system, you may need to write to `.zprofile` instead of `.zshrc`, or write to `.bash_profile` instead of `.bashrc` (or visa-versa).\n\n#### Using Homebrew\n\nPrefer this if you're running macOS. Homebrew [must be installed](https://brew.sh).\n\n<details>\n<summary>Click to expand content</summary>\n\nFirst, download the [autoenv](https://formulae.brew.sh/formula/autoenv) homebrew formulae:\n\n```sh\n$ brew install 'autoenv'\n```\n\nThen, execute one of the following to ensure autoenv is loaded when you open a terminal:\n\n```sh\n# For Zsh shell (on Linux or macOS)\n$ printf '%s\\n' \"source $(brew --prefix autoenv)/activate.sh\" >> \"${ZDOTDIR:-$HOME}/.zprofile\"\n\n# For Bash shell (on Linux)\n$ printf '%s\\n' \"source $(brew --prefix autoenv)/activate.sh\" >> ~/.bashrc\n\n# For Bash shell (on macOS)\n$ printf '%s\\n' \"source $(brew --prefix autoenv)/activate.sh\" >> ~/.bash_profile\n```\n\n</details>\n\n#### Using npm\n\nPrefer this if you're running Linux or an unsupported version of macOS. npm [must be installed](https://nodejs.org/en/download) (usually through NodeJS).\n\n<details>\n<summary>Click to expand content</summary>\n\nFirst, download the [@hyperupcall/autoenv](https://www.npmjs.com/package/@hyperupcall/autoenv) npm package:\n\n```sh\n$ npm install -g '@hyperupcall/autoenv'\n```\n\nThen, execute one of the following to ensure autoenv is loaded when you open a terminal:\n\n```sh\n# For Zsh shell (on Linux or macOS)\n$ printf '%s\\n' \"source $(npm root -g)/@hyperupcall/autoenv/activate.sh\" >> \"${ZDOTDIR:-$HOME}/.zprofile\"\n\n# For Bash shell (on Linux)\n$ printf '%s\\n' \"source $(npm root -g)/@hyperupcall/autoenv/activate.sh\" >> ~/.bashrc\n\n# For Bash shell (on macOS)\n$ printf '%s\\n' \"source $(npm root -g)/@hyperupcall/autoenv/activate.sh\" >> ~/.bash_profile\n```\n\n</details>\n\n#### Using Git\n\nUse this if you cannot install with Homebrew or npm.\n\n<details>\n<summary>Click to expand content</summary>\n\nFirst, clone this repository:\n\n```sh\n$ git clone 'https://github.com/hyperupcall/autoenv' ~/.autoenv\n```\n\nThen, execute one of the following to ensure autoenv is loaded when you open a terminal:\n\n```sh\n# For Zsh shell (on Linux or macOS)\n$ printf '%s\\n' \"source ~/.autoenv/activate.sh\" >> \"${ZDOTDIR:-$HOME}/.zprofile\"\n\n# For Bash shell (on Linux)\n$ printf '%s\\n' \"source ~/.autoenv/activate.sh\" >> ~/.bashrc\n\n# For Bash shell (on macOS)\n$ printf '%s\\n' \"source ~/.autoenv/activate.sh\" >> ~/.bash_profile\n```\n\n</details>\n\n## Configuration\n\n_Before_ `source`ing `activate.sh`, you can set the following variables:\n\n- `AUTOENV_AUTH_FILE`: Files authorized to be sourced; defaults to `~/.autoenv_authorized` if it exists, otherwise, `~/.local/state/autoenv/authorized_list`\n- `AUTOENV_NOTAUTH_FILE`: Files not authorized to be sourced; defaults to `~/.autoenv_not_authorized` if it exists, otherwise, `~/.local/state/autoenv/not_authorized_list` (`master` branch only)\n- `AUTOENV_ENV_FILENAME`: Name of the `.env` file; defaults to `.env`\n- `AUTOENV_LOWER_FIRST`: Set this variable to a non-empty string to flip the order of `.env` files executed\n- `AUTOENV_ENV_LEAVE_FILENAME`: Name of the `.env.leave` file; defaults to `.env.leave`\n- `AUTOENV_ENABLE_LEAVE`: Set this to a non-empty string in order to enable source env when leaving\n- `AUTOENV_ASSUME_YES`: Set this variable to a non-empty string to silently authorize the initialization of new environments\n- `AUTOENV_VIEWER`: Program used to display env files prior to authorization; defaults to `cat` (`master` branch only)\n- `AUTOENV_PRESERVE_CD`: Set this variable to a non-empty string to prevent the `cd` builtin from being overridden (to active autoenv, you must invoke `autoenv_init` within a `cd` function of your own) (`master` branch only)\n\n### API\n\nInside the `.env` file, two _environment variables_ can be accessed:\n\n- `AUTOENV_CUR_FILE` - The file being sourced\n- `AUTOENV_CUR_DIR` - Equivalent to `dirname \"$AUTOENV_CUR_FILE\"`\n\n## Shells\n\nautoenv is tested on:\n\n- Bash\n- Zsh\n- Dash\n- Fish is supported by [autoenv_fish](https://github.com/loopbit/autoenv_fish)\n- More to come\n\n## Disclaimer\n\nAutoenv overrides `cd` (unless `AUTOENV_PRESERVE_CD` is set to a non-empty string). If you already do this, invoke `autoenv_init` within your custom `cd` after sourcing `activate.sh`.\n\nAutoenv can be disabled via `unset -f cd` if you experience I/O issues with certain file systems, particularly those that are FUSE-based (such as `smbnetfs`).\n\n## Other info\n\nTo uninstall autoenv, see [`./docs/uninstall.md`](./docs/uninstall.md).\n\nTo update autoenv, see [`./docs/updating.md`](./docs/updating.md).\n\n## Attributions\n\nAutoenv was originally created by [@kennethreitz](https://github.com/kennethreitz). Later, ownership was transfered to [@inishchith](https://github.com/inishchith). As of August 22nd, 2021, Edwin Kofler ([@hyperupcall](https://github.com/hyperupcall)) owns and maintains the project.\n"
        },
        {
          "name": "activate.sh",
          "type": "blob",
          "size": 9.5693359375,
          "content": "# shellcheck shell=sh\nif [ -n \"$AUTOENV_AUTH_FILE\" ]; then\n\t:\nelif [ -f \"$HOME/.autoenv_authorized\" ]; then\n\tAUTOENV_AUTH_FILE=\"$HOME/.autoenv_authorized\"\nelse\n\t_autoenv_state_dir=\"$XDG_STATE_HOME\"\n\tcase $_autoenv_state_dir in\n\t\t/*) AUTOENV_AUTH_FILE=\"$_autoenv_state_dir/autoenv/authorized_list\" ;;\n\t\t*) AUTOENV_AUTH_FILE=\"$HOME/.local/state/autoenv/authorized_list\" ;;\n\tesac\n\tunset -v _autoenv_state_dir\nfi\nif [ -n \"$AUTOENV_NOTAUTH_FILE\" ]; then\n\t:\nelif [ -f \"$HOME/.autoenv_authorized\" ]; then\n\t# If `.autoenv_authorized` is in home, don't suprise the user by using XDG Base Dir\n\tAUTOENV_NOTAUTH_FILE=\"$HOME/.autoenv_not_authorized\"\nelif [ -f \"$HOME/.autoenv_not_authorized\" ]; then\n\t# Ensure file in ~/ is used, even if the authorized file has been moved or deleted\n\tAUTOENV_NOTAUTH_FILE=\"$HOME/.autoenv_not_authorized\"\nelse\n\t_autoenv_state_dir=\"$XDG_STATE_HOME\"\n\tcase $_autoenv_state_dir in\n\t\t/*) AUTOENV_NOTAUTH_FILE=\"$_autoenv_state_dir/autoenv/not_authorized_list\" ;;\n\t\t*) AUTOENV_NOTAUTH_FILE=\"$HOME/.local/state/autoenv/not_authorized_list\" ;;\n\tesac\n\tunset -v _autoenv_state_dir\nfi\nAUTOENV_ENV_FILENAME=\"${AUTOENV_ENV_FILENAME:-.env}\"\nAUTOENV_ENV_LEAVE_FILENAME=\"${AUTOENV_ENV_LEAVE_FILENAME:-.env.leave}\"\nAUTOENV_VIEWER=\"${AUTOENV_VIEWER:-cat}\"\n# AUTOENV_ENABLE_LEAVE\n\n# @description print a user message to stdout\n# @args\n#   -b[NUM]: number of lines to print before message\n#   -a[NUM]: number of lines to print after message (default=1)\n#   -n: do not print trailing newline (same as -a0)\n#   message: space seperated text of message\n# @example _autoenv_info -n -b1 'my message'\n# @internal\n_autoenv_info() {\n\tlocal after=1 before=0\n\n\twhile : ; do\n\t\tcase \"$1\" in\n\t\t-n)  after=0                           ;;\n\t\t-b*) before=${1#-b} ; : \"${before:=1}\" ;;\n\t\t-a*) after=${1#-a}  ; : \"${after:=1}\"  ;;\n\t\t*)   break                             ;;\n\t\tesac\n\t\tshift\n\tdone\n\n\t[ $before -gt 0 ] && printf '%*s' ${before} | tr \" \" \"\\n\"\n\n\tif [ -n \"$NO_COLOR\" ]; then\n\t\tprintf \"[autoenv] %s\" \"${*}\"\n\telse\n\t\tprintf \"\\033[33m[autoenv]\\033[0m %s\" \"${*}\"\n\tfi\n\n\t[ $after -gt 0 ] && printf '%*s' ${after} | tr \" \" \"\\n\"\n}\n\n# @description print a message to stderr\n# @args\n#   message: space seperated text of message\n# @example _autoenv_err 'there was an error'\n# @internal\n_autoenv_err() {\n\tif [ -n \"$NO_COLOR\" ]; then\n\t\tprintf \"[autoenv] Error %s\" \"${*}\" >&2\n\telse\n\t\tprintf \"\\033[33m[autoenv]\\033[0m \\033[31mError\\033[0m %s\\n\" \"${*}\" >&2\n\tfi\n\n\treturn 1\n}\n\n# @description print a horizontal line\n# @args\n#   text: title to print near the beginning of the line\n# @example _autoenv_draw_line 'text'\n# @internal\n_autoenv_draw_line() {\n\tlocal text=\"${1}\" char=\"-\" width=${COLUMNS:-80} margin=3 line\n\n\tif [ -n \"${text}\" ]; then\n\t\ttext=\"--- ${text} \"\n\tfi\n\n\twidth=$((width - ${#text} - margin))\n\tline=$(printf '%*s\\n' ${width} | tr \" \" \"${char}\")\n\n\tif [ -n \"$NO_COLOR\" ]; then\n\t\tprintf \"%s%s\\n\\n\" \"${text}\" \"$line\"\n\telse\n\t\tprintf \"\\033[1m%s%s\\033[0m\\n\\n\" \"${text}\" \"$line\"\nfi\n}\n\n# @description display the contents of a `.env` or `.env.leave` file using the `$AUTOENV_VIEWER`` command\n# @example _autoenv_show_file './.env_file'\n# @internal\n_autoenv_show_file() {\n\tlocal file=\"$1\" ofs=\"$IFS\"\n\n\t_autoenv_info -b \"New or modified env file detected:\"\n\t_autoenv_draw_line \"${file##*/} contents\"\n\tIFS=\" \"\n\t$AUTOENV_VIEWER \"${file}\"\n\tIFS=\"$ofs\"\n\t_autoenv_draw_line\n}\n\n# @description Main initialization function\n# @internal\nautoenv_init() {\n\tif [ -n \"$AUTOENV_ENABLE_LEAVE\" ]; then\n\t\tautoenv_leave \"$@\"\n\tfi\n\n\tlocal _mountpoint _pwd\n\t_mountpoint=\"$(command df -P \"${PWD}\" | command tail -n 1 | command awk '$0=$NF')\"\n\t_pwd=$(echo \"${PWD}\" | command sed -E 's:/+:/:g') # Removes double slashes. (see #125)\n\n\t# Discover all files that we need to source.\n\tlocal _files\n\t_files=$(\n\t\tcommand -v chdir >/dev/null 2>&1 && chdir \"${_pwd}\" || builtin cd \"${_pwd}\"\n\t\t_hadone=''\n\t\twhile :; do\n\t\t\t_file=\"$(pwd -P)/${AUTOENV_ENV_FILENAME}\"\n\t\t\tif [ -f \"${_file}\" ]; then\n\t\t\t\tif [ -z \"${_hadone}\" ]; then\n\t\t\t\t\tprintf %s \"${_file}\"\n\t\t\t\t\t_hadone='1'\n\t\t\t\telse\n\t\t\t\t\tprintf %s \"\n${_file}\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t[ \"$(pwd -P)\" = \"${_mountpoint}\" ] && break\n\t\t\t[ \"$(pwd -P)\" = \"/\" ] && break\n\t\t\tcommand -v chdir >/dev/null 2>&1 && chdir \"$(pwd -P)/..\" || builtin cd \"$(pwd -P)/..\"\n\t\tdone\n\t)\n\n\t# ZSH: Use traditional for loop\n\tif [ -n \"$ZSH_VERSION\" ]; then\n\t\tsetopt shwordsplit >/dev/null 2>&1\n\tfi\n\n\t# Custom IFS\n\torigIFS=\"${IFS}\"\n\tIFS='\n'\n\n\tset -f\n\t# Turn around the env files order if needed\n\tlocal _orderedfiles=''\n\tif [ -z \"${AUTOENV_LOWER_FIRST}\" ]; then\n\t\tfor _file in ${_files}; do\n\t\t\t_orderedfiles=\"${_file}\n${_orderedfiles}\"\n\t\tdone\n\telse\n\t\t_orderedfiles=\"${_files}\"\n\tfi\n\t# Execute the env files\n\tfor _file in ${_orderedfiles}; do\n\t\t_autoenv_check_authz_and_run \"${_file}\"\n\tdone\n\tunset -v _orderedfiles\n\tIFS=\"${origIFS}\"\n\tset +f\n\n\t# ZSH: Unset shwordsplit\n\tif [ -n \"$ZSH_VERSION\" ]; then\n\t\tunsetopt shwordsplit >/dev/null 2>&1\n\tfi\n}\n\n# @description Checks the hash\n# @internal\nautoenv_hashline() {\n\tlocal _envfile _hash\n\t_envfile=\"${1}\"\n\t_hash=$(autoenv_shasum \"${_envfile}\" | command cut -d' ' -f 1)\n\tprintf '%s\\n' \"${_envfile}:${_hash}\"\n}\n\n# @description Source an env file if is able to do so\n# @internal\n_autoenv_check_authz_and_run() {\n\tlocal _envfile=\"${1}\"\n\tlocal _hash\n\t_hash=$(autoenv_hashline \"${_envfile}\")\n\n\tcommand mkdir -p -- \"$(dirname \"${AUTOENV_AUTH_FILE}\")\" \"$(dirname \"${AUTOENV_NOTAUTH_FILE}\")\"\n\tcommand touch -- \"${AUTOENV_AUTH_FILE}\" \"${AUTOENV_NOTAUTH_FILE}\"\n\tif command grep -q \"${_hash}\" -- \"${AUTOENV_AUTH_FILE}\"; then\n\t\tautoenv_source \"${_envfile}\"\n\t\treturn 0\n\telif command grep -q \"${_hash}\" -- \"${AUTOENV_NOTAUTH_FILE}\"; then\n\t\treturn 0\n\tfi\n\n\tif [ -n \"${AUTOENV_ASSUME_YES}\" ]; then # Don't ask for permission if \"assume yes\" is switched on\n\t\tautoenv_authorize_env \"${_envfile}\"\n\t\tautoenv_source \"${_envfile}\"\n\t\treturn 0\n\tfi\n\n\tif [ -z \"${MC_SID}\" ]; then # Make sure mc is not running\n\t\t_autoenv_show_file \"${_envfile}\"\n\t\t_autoenv_info -n \"Authorize this file? (y/N/D) \"\n\t\tread -r answer\n\t\tif [ \"${answer}\" = \"y\" ] || [ \"${answer}\" = \"Y\" ]; then\n\t\t\tautoenv_authorize_env \"${_envfile}\"\n\t\t\tautoenv_source \"${_envfile}\"\n\t\telif [ \"${answer}\" = \"d\" ] || [ \"${answer}\" = \"D\" ]; then\n\t\t\tautoenv_unauthorize_env \"${_envfile}\"\n\t\tfi\n\tfi\n}\n\n# @description Mark an env file as able to be sourced\n# @internal\nautoenv_deauthorize_env() {\n\tlocal _envfile _noclobber\n\t_envfile=\"${1}\"\n\tcommand cp -- \"${AUTOENV_AUTH_FILE}\" \"${AUTOENV_AUTH_FILE}.tmp\"\n\t_noclobber=\"$(set +o | command grep noclobber)\"\n\tset +C\n\tcommand grep -Gv \"${_envfile}:\" -- \"${AUTOENV_AUTH_FILE}.tmp\" > \"${AUTOENV_AUTH_FILE}\"\n\teval \"${_noclobber}\"\n\tcommand rm -- \"${AUTOENV_AUTH_FILE}.tmp\" 2>/dev/null || :\n}\n\n# @description Mark an env file as not able to be sourced\n# @internal\nautoenv_unauthorize_env() {\n\tlocal _envfile=\"$1\"\n\tautoenv_deauthorize_env \"$_envfile\"\n\tautoenv_hashline \"$_envfile\" >> \"$AUTOENV_NOTAUTH_FILE\"\n}\n\n# @description Mark an env file as able to be sourced\n# @internal\nautoenv_authorize_env() {\n\tlocal _envfile\n\t_envfile=\"${1}\"\n\tautoenv_deauthorize_env \"${_envfile}\"\n\tautoenv_hashline \"${_envfile}\" >> \"${AUTOENV_AUTH_FILE}\"\n}\n\n# @description Actually source a file\n# @internal\nautoenv_source() {\n\tlocal _allexport\n\t_allexport=\"$(set +o | command grep allexport)\"\n\tset -a\n\tAUTOENV_CUR_FILE=\"${1}\"\n\tAUTOENV_CUR_DIR=\"$(dirname \"${1}\")\"\n\t. \"${1}\"\n\t[ \"${ZSH_VERSION#*5.1}\" != \"${ZSH_VERSION}\" ] && set +a\n\teval \"${_allexport}\"\n\tunset AUTOENV_CUR_FILE AUTOENV_CUR_DIR\n}\n\n# @description Function to override the 'cd' builtin\nautoenv_cd() {\n\tlocal _pwd\n\t_pwd=${PWD}\n\tif command -v chdir >/dev/null 2>&1 && chdir \"${@}\" || builtin cd \"${@}\"; then\n\t\tautoenv_init \"${_pwd}\"\n\t\treturn 0\n\telse\n\t\treturn \"${?}\"\n\tfi\n}\n\n# @description Cleanup autoenv\nautoenv_leave() {\n\t# execute file when leaving a directory\n\tlocal from_dir to_dir\n\tfrom_dir=\"${*}\"\n\tto_dir=$(echo \"${PWD}\" | command sed -E 's:/+:/:g')\n\n\t# Discover all files that we need to source.\n\tlocal _files\n\t_files=$(\n\t\tcommand -v chdir >/dev/null 2>&1 && chdir \"${from_dir}\" || builtin cd \"${from_dir}\"\n\t\t_hadone=''\n\t\twhile [ \"$PWD\" != \"\" ] && [ \"$PWD\" != \"/\" ]; do\n\t\t\tcase $to_dir/ in\n\t\t\t\t$PWD/*)\n\t\t\t\tbreak\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_file=\"$PWD/${AUTOENV_ENV_LEAVE_FILENAME}\"\n\t\t\t\tif [ -f \"${_file}\" ]; then\n\t\t\t\t\tif [ -z \"${_hadone}\" ]; then\n\t\t\t\t\t\tprintf %s \"${_file}\"\n\t\t\t\t\t\t_hadone='1'\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf %s \"\n${_file}\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\t\tcommand -v chdir >/dev/null 2>&1 && chdir \"$(pwd)/..\" || builtin cd \"$PWD/..\"\n\t\t\t\t;;\n\t\t\tesac\n\t\tdone\n\t)\n\n\t# ZSH: Use traditional for loop\n\tif [ -n \"$ZSH_VERSION\" ]; then\n\t\tsetopt shwordsplit >/dev/null 2>&1\n\tfi\n\n\t# Custom IFS\n\torigIFS=\"${IFS}\"\n\tIFS='\n'\n\n\t# Execute the env files\n\tset -f\n\tfor _file in ${_files}; do\n\t\t_autoenv_check_authz_and_run \"${_file}\"\n\tdone\n\tIFS=\"${origIFS}\"\n\tset +f\n\n\t# ZSH: Unset shwordsplit\n\tif [ -n \"$ZSH_VERSION\" ]; then\n\t\tunsetopt shwordsplit >/dev/null 2>&1\n\tfi\n}\n\n# Override the cd alias\nif command -v setopt >/dev/null 2>&1; then\n\tif setopt 2> /dev/null | command grep -q aliasfuncdef; then\n\t\thas_alias_func_def_enabled=true\n\telse\n\t\tsetopt ALIAS_FUNC_DEF 2>/dev/null\n\tfi\nfi\n\n# @description Run to automatically replace the cd builtin with our improved one\nenable_autoenv() {\n\tif [ -z \"${AUTOENV_PRESERVE_CD}\" ]; then\n\t\tcd() {\n\t\t\tautoenv_cd \"${@}\"\n\t\t}\n\tfi\n\n\tcd \"${PWD}\"\n}\n\nif ! $has_alias_func_def_enabled; then\n\tunsetopt ALIAS_FUNC_DEF 2> /dev/null\nfi\n\n# Probe to see if we have access to a shasum command, otherwise disable autoenv\nif command -v gsha1sum >/dev/null 2>&1; then\n\tautoenv_shasum() {\n\t\tgsha1sum \"${@}\"\n\t}\n\tenable_autoenv \"$@\"\nelif command -v sha1sum >/dev/null 2>&1; then\n\tautoenv_shasum() {\n\t\tsha1sum \"${@}\"\n\t}\n\tenable_autoenv \"$@\"\nelif command -v shasum >/dev/null 2>&1; then\n\tautoenv_shasum() {\n\t\tshasum \"${@}\"\n\t}\n\tenable_autoenv \"$@\"\nelse\n\t_autoenv_err \"can not locate a compatible shasum binary; not enabling\"\nfi\n"
        },
        {
          "name": "aur",
          "type": "tree",
          "content": null
        },
        {
          "name": "autoenv.plugin.zsh",
          "type": "blob",
          "size": 0.1982421875,
          "content": "# Standarized $0 handling, following:\n# https://z-shell.github.io/zsh-plugin-assessor/Zsh-Plugin-Standard\n0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\"\n0=\"${${(M)0:#/*}:-$PWD/$0}\"\n\n. ${0:h}/activate.sh\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.5830078125,
          "content": "{\n\t\"name\": \"@hyperupcall/autoenv\",\n\t\"version\": \"0.3.0\",\n\t\"description\": \"Magic per-project shell environments\",\n\t\"author\": \"Edwin Kofler <edwin@kofler.dev> (https://edwinkofler.com)\",\n\t\"license\": \"MIT\",\n\t\"files\": [\n\t\t\"activate.sh\"\n\t],\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/hyperupcall/autoenv.git\"\n\t},\n\t\"homepage\": \"https://github.com/hyperupcall/autoenv#readme\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/hyperupcall/autoenv/issues\",\n\t\t\"email\": \"edwin@kofler.dev\"\n\t},\n\t\"keywords\": [\n\t\t\"autoenv\",\n\t\t\"shell\"\n\t],\n\t\"devDependencies\": {\n\t\t\"@hyperupcall/bats-all\": \"^5.1.1\"\n\t}\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "shelltestrunner.sh",
          "type": "blob",
          "size": 1.6435546875,
          "content": "# shellcheck shell=bash\n\n# Until https://github.com/hyperupcall/shelltest gets a release,\n# I've opted to manually create a test runner (using the same\n# interface)\n\nt_is_function() {\n\tif ! __tmp=$(type \"$1\" 2>/dev/null); then\n\t\treturn 1\n\tfi\n\n\t# Most shells have a single line 'my_fn is a function'. In Bash,\n\t# the rest of the function is printed. In Zsh, it says 'my_fn is\n\t# a shell function'\n\tcase $__tmp in\n\t\t\"$1 is a function\"*) return 0 ;;\n\t\t\"$1 is a shell function\"*) return 0 ;;\n\tesac\n\n\treturn 1\n}\n\nt_assert() {\n\tif \"$@\"; then :; else\n\t\tprintf '\\033[41m%s\\033[0m\\n: %s' \"Error\" \"Execution of command '$*' failed with exitcode $?\" >&2\n\t\treturn 1\n\tfi\n}\n\nmain() {\n\tset -e\n\n\tprintf '%s\\n' \"Sourcing api.sh\"\n\tsetup_file() { :; }\n\tteardown_file() { :; }\n\tsetup() { :; }\n\tteardown() { :; }\n\tsource ./shelltests/api.sh\n\tsetup_file\n\tfor fn in test_has_defined_functions; do\n\t\tprintf '%s\\n' \"Running: $fn\"\n\t\tsetup\n\t\t\"$fn\"\n\t\tteardown\n\tdone\n\tteardown_file\n\tprintf '%s\\n\\n'\n\n\n\tprintf '%s\\n' \"Sourcing cd.sh\"\n\tsetup_file() { :; }\n\tteardown_file() { :; }\n\tsetup() { :; }\n\tteardown() { :; }\n\tsource ./shelltests/cd.sh\n\tsetup_file\n\tfor fn in test_cd_noenv test_cd_dir test_cd_subdir test_cd_dir_and_subdir test_cd_dir_and_subdir_spaces test_cd_dir_and_subdir_colons; do\n\t\tprintf '%s\\n' \"Running: $fn\"\n\t\tsetup\n\t\t\"$fn\"\n\t\tteardown\n\tdone\n\tteardown_file\n\tprintf '%s\\n\\n'\n\n\tprintf '%s\\n' \"Sourcing env.sh\"\n\tsetup_file() { :; }\n\tteardown_file() { :; }\n\tsetup() { :; }\n\tteardown() { :; }\n\tsource ./shelltests/env.sh\n\tsetup_file\n\tfor fn in test_AUTOENV_ENV_FILENAME_works test_AUTOENV_ENV_FILENAME_works2; do\n\t\tprintf '%s\\n' \"Running: $fn\"\n\t\tsetup\n\t\t\"$fn\"\n\t\tteardown\n\tdone\n\tteardown_file\n}\nmain \"$@\"\n"
        },
        {
          "name": "shelltests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}