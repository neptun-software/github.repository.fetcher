{
  "metadata": {
    "timestamp": 1736568835643,
    "page": 16,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "phusion/baseimage-docker",
      "stars": 8977,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2275390625,
          "content": "# EditorConfig is awesome: http://EditorConfig.org\n\n# top-most EditorConfig file\nroot = true\n\n# Unix-style newlines with a newline ending every file\n[*]\nend_of_line = lf\ninsert_final_newline = true\nindent_size = 4\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0390625,
          "content": ".DS_Store\n.vagrant\n*.swp\n*.tar.gz\n*.log\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.3115234375,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at Phusion Passenger:\n\n[FloorD](https://github.com/floord) (she/her), floor@phusion.nl, English / Dutch / German\n\n[Scarhand](https://github.com/scarhand) (he/his), niels@phusion.nl, English / Dutch\n\nThe project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.5927734375,
          "content": "Hey, thanks for wanting to contribute to baseimage-docker. :)\n\nIf you have a question, please use the [discussion forum](https://groups.google.com/d/forum/passenger-docker). The Github issue tracker is only for **bug reports and feature requests**.\n\nIf you want to develop baseimage-docker, use the Vagrantfile in the repository. It will setup an Ubuntu VM with Docker installed in it. Use the Makefile to build the Docker image.\n\nAll development happens on the `next` branch. The `master` branch is supposed to point to the latest stable release, because users read documentation from the `master` branch.\n"
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 0.1025390625,
          "content": "For the Changelog, please see [Releases](https://github.com/phusion/baseimage-docker/releases) on GitHub\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0439453125,
          "content": "Copyright (c) 2013-2025 Phusion Holding B.V.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.59765625,
          "content": "VERSION ?= noble-1.0.0\nifdef BASE_IMAGE\n\tBUILD_ARG = --build-arg BASE_IMAGE=$(BASE_IMAGE)\n\tifndef NAME\n\t\tNAME = phusion/baseimage-$(subst :,-,${BASE_IMAGE})\n\tendif\nelse\n\tNAME ?= phusion/baseimage\nendif\nifdef TAG_ARCH\n\t# VERSION_ARG = $(VERSION)-$(subst /,-,$(subst :,-,${BASE_IMAGE}))-$(TAG_ARCH)\n\tVERSION_ARG = $(VERSION)-$(TAG_ARCH)\n\tLATEST_VERSION = latest-$(TAG_ARCH)\nelse\n\t# VERSION_ARG = $(VERSION)-$(subst /,-,$(subst :,-,${BASE_IMAGE}))\n\tVERSION_ARG = $(VERSION)\n\tLATEST_VERSION = latest\nendif\nVERSION_ARG ?= $(VERSION)\n\n.PHONY: all build test tag_latest release ssh\n\nall: build\n\nbuild:\n\tdocker build --no-cache -t $(NAME):$(VERSION_ARG) $(BUILD_ARG) --build-arg QEMU_ARCH=$(QEMU_ARCH) --platform $(PLATFORM) --rm image\n\nbuild_multiarch:\n\tenv NAME=$(NAME) VERSION=$(VERSION_ARG) ./build-multiarch.sh\n\ntest:\n\tenv NAME=$(NAME) VERSION=$(VERSION_ARG) ./test/runner.sh\n\ntag_latest:\n\tdocker tag $(NAME):$(VERSION_ARG) $(NAME):$(LATEST_VERSION)\n\ntag_multiarch_latest:\n\tenv NAME=$(NAME) VERSION=$(VERSION) TAG_LATEST=true ./build-multiarch.sh\n\nrelease: test\n\t@if ! docker images $(NAME) | awk '{ print $$2 }' | grep -q -F $(VERSION_ARG); then echo \"$(NAME) version $(VERSION_ARG) is not yet built. Please run 'make build'\"; false; fi\n\tdocker push $(NAME)\n\t@echo \"*** Don't forget to create a tag by creating an official GitHub release.\"\n\nssh: SSH_COMMAND?=\nssh:\n\tID=$$(docker ps | grep -F \"$(NAME):$(VERSION_ARG)\" | awk '{ print $$1 }') && \\\n\t\tif test \"$$ID\" = \"\"; then echo \"Container is not running.\"; exit 1; fi && \\\n\t\ttools/docker-ssh $$ID ${SSH_COMMAND}\n\ntest_release:\n\techo test_release\n\tenv\n\ntest_master:\n\techo test_master\n\tenv\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 38.9462890625,
          "content": "# A minimal Ubuntu base image modified for Docker-friendliness\n\n[![Release](https://github.com/phusion/baseimage-docker/actions/workflows/main.yml/badge.svg)](https://github.com/phusion/baseimage-docker/actions/workflows/main.yml)\n\n_Baseimage-docker only consumes 8.3 MB RAM and is much more powerful than Busybox or Alpine. See why below._\n\nBaseimage-docker is a special [Docker](https://www.docker.com) image that is configured for correct use within Docker containers. It is Ubuntu, plus:\n\n * Modifications for Docker-friendliness.\n * Administration tools that are especially useful in the context of Docker.\n * Mechanisms for easily running multiple processes, [without violating the Docker philosophy](#docker_single_process).\n\nYou can use it as a base for your own Docker images.\n\nBaseimage-docker is available for pulling from [the Docker registry](https://hub.docker.com/r/phusion/baseimage) and [GHCR (GitHub Container Registry)](https://github.com/phusion/baseimage-docker/pkgs/container/baseimage)!\n\n### What are the problems with the stock Ubuntu base image?\n\nUbuntu is not designed to be run inside Docker. Its init system, Upstart, assumes that it's running on either real hardware or virtualized hardware, but not inside a Docker container. But inside a container you don't want a full system; you want a minimal system.  Configuring that minimal system for use within a container has many strange corner cases that are hard to get right if you are not intimately familiar with the Unix system model. This can cause a lot of strange problems.\n\nBaseimage-docker gets everything right. The \"Contents\" section describes all the things that it modifies.\n\n<a name=\"why_use\"></a>\n### Why use baseimage-docker?\n\nYou can configure the stock `ubuntu` image yourself from your Dockerfile, so why bother using baseimage-docker?\n\n * Configuring the base system for Docker-friendliness is no easy task. As stated before, there are many corner cases. By the time that you've gotten all that right, you've reinvented baseimage-docker. Using baseimage-docker will save you from this effort.\n * It reduces the time needed to write a correct Dockerfile. You won't have to worry about the base system and you can focus on the stack and the app.\n * It reduces the time needed to run `docker build`, allowing you to iterate your Dockerfile more quickly.\n * It reduces download time during redeploys. Docker only needs to download the base image once: during the first deploy. On every subsequent deploys, only the changes you make on top of the base image are downloaded.\n\n-----------------------------------------\n\n**Related resources**:\n  [Website](http://phusion.github.io/baseimage-docker/) |\n  [Github](https://github.com/phusion/baseimage-docker) |\n  [Docker registry](https://registry.hub.docker.com/r/phusion/baseimage/) |\n  [Discussion forum](https://groups.google.com/d/forum/passenger-docker) |\n  [Twitter](https://twitter.com/phusion_nl) |\n  [Blog](http://blog.phusion.nl/)\n\n**Table of contents**\n\n * [What's inside the image?](#whats_inside)\n   * [Overview](#whats_inside_overview)\n   * [Wait, I thought Docker is about running a single process in a container?](#docker_single_process)\n   * [Does Baseimage-docker advocate \"fat containers\" or \"treating containers as VMs\"?](#fat_containers)\n * [Inspecting baseimage-docker](#inspecting)\n * [Using baseimage-docker as base image](#using)\n   * [Getting started](#getting_started)\n   * [Adding additional daemons](#adding_additional_daemons)\n   * [Running scripts during container startup](#running_startup_scripts)\n   * [Environment variables](#environment_variables)\n     * [Centrally defining your own environment variables](#envvar_central_definition)\n     * [Environment variable dumps](#envvar_dumps)\n     * [Modifying environment variables](#modifying_envvars)\n     * [Security](#envvar_security)\n   * [System logging](#logging)\n   * [Upgrading the operating system inside the container](#upgrading_os)\n * [Container administration](#container_administration)\n   * [Running a one-shot command in a new container](#oneshot)\n   * [Running a command in an existing, running container](#run_inside_existing_container)\n   * [Login to the container via `docker exec`](#login_docker_exec)\n     * [Usage](#docker_exec)\n   * [Login to the container via SSH](#login_ssh)\n     * [Enabling SSH](#enabling_ssh)\n     * [About SSH keys](#ssh_keys)\n     * [Using the insecure key for one container only](#using_the_insecure_key_for_one_container_only)\n     * [Enabling the insecure key permanently](#enabling_the_insecure_key_permanently)\n     * [Using your own key](#using_your_own_key)\n     * [The `docker-ssh` tool](#docker_ssh)\n * [Building the image yourself](#building)\n  * [Removing optional services](#removing_optional_services)\n * [Conclusion](#conclusion)\n\n-----------------------------------------\n\n<a name=\"whats_inside\"></a>\n## What's inside the image?\n\n<a name=\"whats_inside_overview\"></a>\n### Overview\n\n*Looking for a more complete base image, one that is ideal for Ruby, Python, Node.js and Meteor web apps? Take a look at [passenger-docker](https://github.com/phusion/passenger-docker).*\n\n| Component        | Why is it included? / Remarks |\n| ---------------- | ------------------- |\n| Ubuntu 24.04 LTS | The base system. |\n| A **correct** init process | _Main article: [Docker and the PID 1 zombie reaping problem](http://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/)._ <br><br>According to the Unix process model, [the init process](https://en.wikipedia.org/wiki/Init) -- PID 1 -- inherits all [orphaned child processes](https://en.wikipedia.org/wiki/Orphan_process) and must [reap them](https://en.wikipedia.org/wiki/Wait_(system_call)). Most Docker containers do not have an init process that does this correctly. As a result, their containers become filled with [zombie processes](https://en.wikipedia.org/wiki/Zombie_process) over time. <br><br>Furthermore, `docker stop` sends SIGTERM to the init process, which stops all services. Unfortunately most init systems don't do this correctly within Docker since they're built for hardware shutdowns instead. This causes processes to be hard killed with SIGKILL, which doesn't give them a chance to correctly deinitialize things. This can cause file corruption. <br><br>Baseimage-docker comes with an init process `/sbin/my_init` that performs both of these tasks correctly. |\n| Fixes APT incompatibilities with Docker | See https://github.com/dotcloud/docker/issues/1024. |\n| syslog-ng | A syslog daemon is necessary so that many services - including the kernel itself - can correctly log to /var/log/syslog. If no syslog daemon is running, a lot of important messages are silently swallowed. <br><br>Only listens locally. All syslog messages are forwarded to \"docker logs\".<br><br>Why syslog-ng?<br>I've had bad experience with rsyslog. I regularly run into bugs with rsyslog, and once in a while it takes my log host down by entering a 100% CPU loop in which it can't do anything. Syslog-ng seems to be much more stable. |\n| logrotate | Rotates and compresses logs on a regular basis. |\n| SSH server | Allows you to easily login to your container to [inspect or administer](#login_ssh) things. <br><br>_SSH is **disabled by default** and is only one of the methods provided by baseimage-docker for this purpose. The other method is through [docker exec](#login_docker_exec). SSH is also provided as an alternative because `docker exec` comes with several caveats._<br><br>Password and challenge-response authentication are disabled by default. Only key authentication is allowed. |\n| cron | The cron daemon must be running for cron jobs to work. |\n| [runit](http://smarden.org/runit/) | Replaces Ubuntu's Upstart. Used for service supervision and management. Much easier to use than SysV init and supports restarting daemons when they crash. Much easier to use and more lightweight than Upstart. |\n| `setuser` | A tool for running a command as another user. Easier to use than `su`, has a smaller attack vector than `sudo`, and unlike `chpst` this tool sets `$HOME` correctly. Available as `/sbin/setuser`. |\n| `install_clean` | A tool for installing `apt` packages that automatically cleans up after itself.  All arguments are passed to `apt-get -y install --no-install-recommends` and after installation the apt caches are cleared.  To include recommended packages, add `--install-recommends`. |\n\nBaseimage-docker is very lightweight: it only consumes 8.3 MB of memory.\n\n<a name=\"docker_single_process\"></a>\n### Wait, I thought Docker is about running a single process in a container?\n\nThe Docker developers advocate the philosophy of running a single *logical service* per container. A logical service can consist of multiple OS processes.\n\nBaseimage-docker only advocates running multiple OS processes inside a single container. We believe this makes sense because at the very least it would solve [the PID 1 problem](http://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/) and the \"syslog blackhole\" problem. By running multiple processes, we solve very real Unix OS-level problems, with minimal overhead and without turning the container into multiple logical services.\n\nSplitting your logical service into multiple OS processes also makes sense from a security standpoint. By running processes as different users, you can limit the impact of vulnerabilities. Baseimage-docker provides tools to encourage running processes as different users, e.g. the `setuser` tool.\n\nDo we advocate running multiple *logical services* in a single container? Not necessarily, but we do not prohibit it either. While the Docker developers are very opinionated and have very rigid philosophies about how containers *should* be built, Baseimage-docker is completely unopinionated. We believe in freedom: sometimes it makes sense to run multiple services in a single container, and sometimes it doesn't. It is up to you to decide what makes sense, not the Docker developers.\n\n<a name=\"fat_containers\"></a>\n### Does Baseimage-docker advocate \"fat containers\" or \"treating containers as VMs\"?\n\nThere are people who think that Baseimage-docker advocates treating containers as VMs because Baseimage-docker advocates the use of multiple processes. Therefore, they also think that Baseimage-docker does not follow the Docker philosophy. Neither of these impressions are true.\n\nThe Docker developers advocate running a single *logical service* inside a single container. But we are not disputing that. Baseimage-docker advocates running multiple *OS processes* inside a single container, and a single logical service can consist of multiple OS processes.\n\nIt follows that Baseimage-docker also does not deny the Docker philosophy. In fact, many of the modifications we introduce are explicitly in line with the Docker philosophy. For example, using environment variables to pass parameters to containers is very much the \"Docker way\", and providing [a mechanism to easily work with environment variables](#environment_variables) in the presence of multiple processes that may run as different users.\n\n<a name=\"inspecting\"></a>\n## Inspecting baseimage-docker\n\nTo look around in the image, run:\n\n    docker run --rm -t -i phusion/baseimage:<VERSION> /sbin/my_init -- bash -l\n\nwhere `<VERSION>` is [one of the baseimage-docker version numbers](https://github.com/phusion/baseimage-docker/blob/master/Changelog.md).\n\nYou don't have to download anything manually. The above command will automatically pull the baseimage-docker image from the Docker registry.\n\n<a name=\"using\"></a>\n## Using baseimage-docker as base image\n\n<a name=\"getting_started\"></a>\n### Getting started\n\nThe image is called `phusion/baseimage`, and is available on the Docker registry.\n\n    # Use phusion/baseimage as base image. To make your builds reproducible, make\n    # sure you lock down to a specific version, not to `latest`!\n    # See https://github.com/phusion/baseimage-docker/blob/master/Changelog.md for\n    # a list of version numbers.\n    FROM phusion/baseimage:<VERSION>\n\n    # Use baseimage-docker's init system.\n    CMD [\"/sbin/my_init\"]\n\n    # ...put your own build instructions here...\n\n    # Clean up APT when done.\n    RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n<a name=\"adding_additional_daemons\"></a>\n### Adding additional daemons\n\nA daemon is a program which runs in the background of its system, such\nas a web server.\n\nYou can add additional daemons (for example, your own app) to the image\nby creating runit service directories. You only have to write a small\nshell script which runs your daemon;\n[`runsv`](http://smarden.org/runit/runsv.8.html) will start your script,\nand - by default - restart it upon its exit, after waiting one second.\n\nThe shell script must be called `run`, must be executable, and is to be\nplaced in the directory `/etc/service/<NAME>`. `runsv` will switch to\nthe directory and invoke `./run` after your container starts.\n\n**Be certain that you do not start your container using interactive mode\n(`-it`) with another command, as `runit` must be the first process to run. If you do this, your runit service directories won't be started. For instance, `docker run -it <name> bash` will bring you to bash in your container, but you'll lose all your daemons.**\n\nHere's an example showing you how a `runit` service directory can be\nmade for a `memcached` server.\n\nIn `memcached.sh`, or whatever you choose to name your file (make sure\nthis file is chmod +x):\n```bash\n#!/bin/sh\n# `/sbin/setuser memcache` runs the given command as the user `memcache`.\n# If you omit that part, the command will be run as root.\nexec /sbin/setuser memcache /usr/bin/memcached >>/var/log/memcached.log 2>&1\n```\nIn an accompanying `Dockerfile`:\n\n```Dockerfile\nRUN mkdir /etc/service/memcached\nCOPY memcached.sh /etc/service/memcached/run\nRUN chmod +x /etc/service/memcached/run\n```\nA given shell script must run **without daemonizing or forking itself**;\nthis is because `runit` will start and restart your script on its own.\nUsually, daemons provide a command line flag or a config file option for\npreventing such behavior - essentially, you just want your script to run\nin the foreground, not the background.\n\n<a name=\"running_startup_scripts\"></a>\n### Running scripts during container startup\n\nThe baseimage-docker init system, `/sbin/my_init`, runs the following scripts during startup, in the following order:\n\n * All executable scripts in `/etc/my_init.d`, if this directory exists. The scripts are run in lexicographic order.\n * The script `/etc/rc.local`, if this file exists.\n\nAll scripts must exit correctly, e.g. with exit code 0. If any script exits with a non-zero exit code, the booting will fail.\n\n**Important note:** If you are executing the container in interactive mode (i.e. when you run a container with `-it`), rather than daemon mode, you are sending stdout directly to the terminal (`-i` interactive `-t` terminal). If you are not calling `/sbin/my_init` in your run declaration, `/sbin/my_init` will not be executed, therefore your scripts will not be called during container startup.\n\nThe following example shows how you can add a startup script. This script simply logs the time of boot to the file /tmp/boottime.txt.\n\nIn `logtime.sh`:\n\n    #!/bin/sh\n    date > /tmp/boottime.txt\n\nIn `Dockerfile`:\n\n    RUN mkdir -p /etc/my_init.d\n    COPY logtime.sh /etc/my_init.d/logtime.sh\n    RUN chmod +x /etc/my_init.d/logtime.sh\n\n<a name=\"environment_variables\"></a>\n\n#### Shutting down your process\n\n`/sbin/my_init` handles termination of children processes at shutdown. When it receives a SIGTERM\nit will pass the signal onto the child processes for correct shutdown. If your process is started with\na shell script, make sure you `exec` the actual process, otherwise the shell will receive the signal\nand not your process.\n\n`/sbin/my_init` will terminate processes after a 5 second timeout. This can be adjusted by setting\nenvironment variables:\n\n    # Give children processes 5 minutes to timeout\n    ENV KILL_PROCESS_TIMEOUT=300\n    # Give all other processes (such as those which have been forked) 5 minutes to timeout\n    ENV KILL_ALL_PROCESSES_TIMEOUT=300\n\nNote: Prior to 0.11.1, the default values for `KILL_PROCESS_TIMEOUT` and `KILL_ALL_PROCESSES_TIMEOUT`\nwere 5 seconds. In version 0.11.1+ the default process timeout has been adjusted to 30 seconds to\nallow more time for containers to terminate gracefully. The default timeout of your container runtime\nmay supersede this setting, for example Docker currently applies a [10s timeout](https://docs.docker.com/engine/reference/commandline/stop/#options)\nby default before sending SIGKILL, upon `docker stop` or receiving SIGTERM.\n\n### Environment variables\n\nIf you use `/sbin/my_init` as the main container command, then any environment variables set with `docker run --env` or with the `ENV` command in the Dockerfile, will be picked up by `my_init`. These variables will also be passed to all child processes, including `/etc/my_init.d` startup scripts, Runit and Runit-managed services. There are however a few caveats you should be aware of:\n\n * Environment variables on Unix are inherited on a per-process basis. This means that it is generally not possible for a child process to change the environment variables of other processes.\n * Because of the aforementioned point, there is no good central place for defining environment variables for all applications and services. Debian has the `/etc/environment` file but it only works in some situations.\n * Some services change environment variables for child processes. Nginx is one such example: it removes all environment variables unless you explicitly instruct it to retain them through the `env` configuration option. If you host any applications on Nginx (e.g. using the [passenger-docker](https://github.com/phusion/passenger-docker) image, or using Phusion Passenger in your own image) then they will not see the environment variables that were originally passed by Docker.\n * We ignore HOME, SHELL, USER and a bunch of other environment variables on purpose, because _not_ ignoring them will break multi-user containers. See https://github.com/phusion/baseimage-docker/pull/86 -- A workaround for setting the `HOME` environment variable looks like this: `RUN echo /root > /etc/container_environment/HOME`. See https://github.com/phusion/baseimage-docker/issues/119\n\n`my_init` provides a solution for all these caveats.\n\n<a name=\"envvar_central_definition\"></a>\n#### Centrally defining your own environment variables\n\nDuring startup, before running any [startup scripts](#running_startup_scripts), `my_init` imports environment variables from the directory `/etc/container_environment`. This directory contains files named after the environment variable names. The file contents contain the environment variable values. This directory is therefore a good place to centrally define your own environment variables, which will be inherited by all startup scripts and Runit services.\n\nFor example, here's how you can define an environment variable from your Dockerfile:\n\n    RUN echo Apachai Hopachai > /etc/container_environment/MY_NAME\n\nYou can verify that it works, as follows:\n\n    $ docker run -t -i <YOUR_NAME_IMAGE> /sbin/my_init -- bash -l\n    ...\n    *** Running bash -l...\n    # echo $MY_NAME\n    Apachai Hopachai\n\n**Handling newlines**\n\nIf you've looked carefully, you'll notice that the 'echo' command actually prints a newline. Why does $MY_NAME not contain a newline then? It's because `my_init` strips the trailing newline. If you intended on the value having a newline, you should add *another* newline, like this:\n\n    RUN echo -e \"Apachai Hopachai\\n\" > /etc/container_environment/MY_NAME\n\n<a name=\"envvar_dumps\"></a>\n#### Environment variable dumps\n\nWhile the previously mentioned mechanism is good for centrally defining environment variables, itself does not prevent services (e.g. Nginx) from changing and resetting environment variables from child processes. However, the `my_init` mechanism does make it easy for you to query what the original environment variables are.\n\nDuring startup, right after importing environment variables from `/etc/container_environment`, `my_init` will dump all its environment variables (that is, all variables imported from `container_environment`, as well as all variables it picked up from `docker run --env`) to the following locations, in the following formats:\n\n * `/etc/container_environment`\n * `/etc/container_environment.sh` - a dump of the environment variables in Bash format. You can source the file directly from a Bash shell script.\n * `/etc/container_environment.json` - a dump of the environment variables in JSON format.\n\nThe multiple formats make it easy for you to query the original environment variables no matter which language your scripts/apps are written in.\n\nHere is an example shell session showing you how the dumps look like:\n\n    $ docker run -t -i \\\n      --env FOO=bar --env HELLO='my beautiful world' \\\n      phusion/baseimage:<VERSION> /sbin/my_init -- \\\n      bash -l\n    ...\n    *** Running bash -l...\n    # ls /etc/container_environment\n    FOO  HELLO  HOME  HOSTNAME  PATH  TERM  container\n    # cat /etc/container_environment/HELLO; echo\n    my beautiful world\n    # cat /etc/container_environment.json; echo\n    {\"TERM\": \"xterm\", \"container\": \"lxc\", \"HOSTNAME\": \"f45449f06950\", \"HOME\": \"/root\", \"PATH\": \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"FOO\": \"bar\", \"HELLO\": \"my beautiful world\"}\n    # source /etc/container_environment.sh\n    # echo $HELLO\n    my beautiful world\n\n<a name=\"modifying_envvars\"></a>\n#### Modifying environment variables\n\nIt is even possible to modify the environment variables in `my_init` (and therefore the environment variables in all child processes that are spawned after that point in time), by altering the files in `/etc/container_environment`. After each time `my_init` runs a [startup script](#running_startup_scripts), it resets its own environment variables to the state in `/etc/container_environment`, and re-dumps the new environment variables to `container_environment.sh` and `container_environment.json`.\n\nBut note that:\n\n * modifying `container_environment.sh` and `container_environment.json` has no effect.\n * Runit services cannot modify the environment like that. `my_init` only activates changes in `/etc/container_environment` when running startup scripts.\n\n<a name=\"envvar_security\"></a>\n#### Security\n\nBecause environment variables can potentially contain sensitive information, `/etc/container_environment` and its Bash and JSON dumps are by default owned by root, and accessible only to the `docker_env` group (so that any user added this group will have these variables automatically loaded).\n\nIf you are sure that your environment variables don't contain sensitive data, then you can also relax the permissions on that directory and those files by making them world-readable:\n\n    RUN chmod 755 /etc/container_environment\n    RUN chmod 644 /etc/container_environment.sh /etc/container_environment.json\n\n<a name=\"logging\"></a>\n### System logging\n\nBaseimage-docker uses syslog-ng to provide a syslog facility to the container. Syslog-ng is not managed as an runit service (see below). Syslog messages are forwarded to the console.\n\n#### Log startup/shutdown sequence\nIn order to ensure that all application log messages are captured by syslog-ng, syslog-ng is started separately before the runit supervisor process, and shutdown after runit exits. This uses the [startup script facility](#running_startup_scripts) provided by this image. This avoids a race condition which would exist if syslog-ng were managed as an runit service, where runit kills syslog-ng in parallel with the container's other services, causing log messages to be dropped during a graceful shutdown if syslog-ng exits while logs are still being produced by other services.\n\n<a name=\"upgrading_os\"></a>\n### Upgrading the operating system inside the container\n\nBaseimage-docker images contain an Ubuntu operating system (see OS version at [Overview](#overview)). You may want to update this OS from time to time, for example to pull in the latest security updates. OpenSSL is a notorious example. Vulnerabilities are discovered in OpenSSL on a regular basis, so you should keep OpenSSL up-to-date as much as you can.\n\nWhile we release Baseimage-docker images with the latest OS updates from time to time, you do not have to rely on us. You can update the OS inside Baseimage-docker images yourself, and it is recommended that you do this instead of waiting for us.\n\nTo upgrade the OS in the image, run this in your Dockerfile:\n\n    RUN apt-get update && apt-get upgrade -y -o Dpkg::Options::=\"--force-confold\"\n\n<a name=\"container_administration\"></a>\n## Container administration\n\nOne of the ideas behind Docker is that containers should be stateless, easily restartable, and behave like a black box. However, you may occasionally encounter situations where you want to login to a container, or to run a command inside a container, for development, inspection and debugging purposes. This section describes how you can administer the container for those purposes.\n\n<a name=\"oneshot\"></a>\n### Running a one-shot command in a new container\n\n_**Note:** This section describes how to run a command insider a -new- container. To run a command inside an existing running container, see [Running a command in an existing, running container](#run_inside_existing_container)._\n\nNormally, when you want to create a new container in order to run a single command inside it, and immediately exit after the command exits, you invoke Docker like this:\n\n    docker run YOUR_IMAGE COMMAND ARGUMENTS...\n\nHowever the downside of this approach is that the init system is not started. That is, while invoking `COMMAND`, important daemons such as cron and syslog are not running. Also, orphaned child processes are not properly reaped, because `COMMAND` is PID 1.\n\nBaseimage-docker provides a facility to run a single one-shot command, while solving all of the aforementioned problems. Run a single command in the following manner:\n\n    docker run YOUR_IMAGE /sbin/my_init -- COMMAND ARGUMENTS ...\n\nThis will perform the following:\n\n * Runs all system startup files, such as /etc/my_init.d/* and /etc/rc.local.\n * Starts all runit services.\n * Runs the specified command.\n * When the specified command exits, stops all runit services.\n\nFor example:\n\n    $ docker run phusion/baseimage:<VERSION> /sbin/my_init -- ls\n    *** Running /etc/rc.local...\n    *** Booting runit daemon...\n    *** Runit started as PID 80\n    *** Running ls...\n    bin  boot  dev  etc  home  image  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var\n    *** ls exited with exit code 0.\n    *** Shutting down runit daemon (PID 80)...\n    *** Killing all processes...\n\nYou may find that the default invocation is too noisy. Or perhaps you don't want to run the startup files. You can customize all this by passing arguments to `my_init`. Invoke `docker run YOUR_IMAGE /sbin/my_init --help` for more information.\n\nThe following example runs `ls` without running the startup files and with less messages, while running all runit services:\n\n    $ docker run phusion/baseimage:<VERSION> /sbin/my_init --skip-startup-files --quiet -- ls\n    bin  boot  dev  etc  home  image  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var\n\n<a name=\"run_inside_existing_container\"></a>\n### Running a command in an existing, running container\n\nThere are two ways to run a command inside an existing, running container.\n\n * Through the `docker exec` tool. This is builtin Docker tool, available since Docker 1.4. Internally, it uses Linux kernel system calls in order to execute a command within the context of a container. Learn more in [Login to the container, or running a command inside it, via `docker exec`](#login_docker_exec).\n * Through SSH. This approach requires running an SSH daemon inside the container, and requires you to setup SSH keys. Learn more in [Login to the container, or running a command inside it, via SSH](#login_ssh).\n\nBoth way have their own pros and cons, which you can learn in their respective subsections.\n\n<a name=\"login_docker_exec\"></a>\n### Login to the container, or running a command inside it, via `docker exec`\n\nYou can use the `docker exec` tool on the Docker host OS to login to any container that is based on baseimage-docker. You can also use it to run a command inside a running container. `docker exec` works by using Linux kernel system calls.\n\nHere's how it compares to [using SSH to login to the container or to run a command inside it](#login_ssh):\n\n * Pros\n   * Does not require running an SSH daemon inside the container.\n   * Does not require setting up SSH keys.\n   * Works on any container, even containers not based on baseimage-docker.\n * Cons\n   * If the `docker exec` process on the host is terminated by a signal (e.g. with the `kill` command or even with Ctrl-C), then the command that is executed by `docker exec` is *not* killed and cleaned up. You will either have to do that manually, or you have to run `docker exec` with `-t -i`.\n   * Requires privileges on the Docker host to be able to access the Docker daemon. Note that anybody who can access the Docker daemon effectively has root access.\n   * Not possible to allow users to login to the container without also letting them login to the Docker host.\n\n<a name=\"docker_exec_usage\"></a>\n#### Usage\n\nStart a container:\n\n    docker run YOUR_IMAGE\n\nFind out the ID of the container that you just ran:\n\n    docker ps\n\nNow that you have the ID, you can use `docker exec` to run arbitrary commands in the container. For example, to run `echo hello world`:\n\n    docker exec YOUR-CONTAINER-ID echo hello world\n\nTo open a bash session inside the container, you must pass `-t -i` so that a terminal is available:\n\n    docker exec -t -i YOUR-CONTAINER-ID bash -l\n\n<a name=\"login_ssh\"></a>\n### Login to the container, or running a command inside it, via SSH\n\nYou can use SSH to login to any container that is based on baseimage-docker. You can also use it to run a command inside a running container.\n\nHere's how it compares to [using `docker exec` to login to the container or to run a command inside it](#login_docker_exec):\n\n * Pros\n   * Does not require root privileges on the Docker host.\n   * Allows you to let users login to the container, without letting them login to the Docker host. However, this is not enabled by default because baseimage-docker does not expose the SSH server to the public Internet by default.\n * Cons\n   * Requires setting up SSH keys. However, baseimage-docker makes this easy for many cases through a pregenerated, insecure key. Read on to learn more.\n\n<a name=\"enabling_ssh\"></a>\n#### Enabling SSH\n\nBaseimage-docker disables the SSH server by default. Add the following to your Dockerfile to enable it:\n\n    RUN rm -f /etc/service/sshd/down\n\n    # Regenerate SSH host keys. baseimage-docker does not contain any, so you\n    # have to do that yourself. You may also comment out this instruction; the\n    # init system will auto-generate one during boot.\n    RUN /etc/my_init.d/00_regen_ssh_host_keys.sh\n\nAlternatively, to enable sshd only for a single instance of your container, create a folder with a [startup script](#running_startup_scripts).  The contents of that should be\n\n    ### In myfolder/enable_ssh.sh (make sure this file is chmod +x):\n    #!/bin/sh\n    rm -f /etc/service/sshd/down\n    ssh-keygen -P \"\" -t dsa -f /etc/ssh/ssh_host_dsa_key\n\nThen, you can start your container with\n\n    docker run -d -v `pwd`/myfolder:/etc/my_init.d my/dockerimage\n\nThis will initialize sshd on container boot.  You can then access it with the insecure key as below, or using the methods to add a secure key.  Further, you can publish the port to your machine with -p 2222:22 allowing you to ssh to 127.0.0.1:2222 instead of looking up the ip address of the container.\n\n<a name=\"ssh_keys\"></a>\n#### About SSH keys\n\nFirst, you must ensure that you have the right SSH keys installed inside the container. By default, no keys are installed, so nobody can login. For convenience reasons, we provide [a pregenerated, insecure key](https://github.com/phusion/baseimage-docker/blob/master/image/services/sshd/keys/insecure_key) [(PuTTY format)](https://github.com/phusion/baseimage-docker/blob/master/image/services/sshd/keys/insecure_key.ppk) that you can easily enable. However, please be aware that using this key is for convenience only. It does not provide any security because this key (both the public and the private side) is publicly available. **In production environments, you should use your own keys**.\n\n<a name=\"using_the_insecure_key_for_one_container_only\"></a>\n#### Using the insecure key for one container only\n\nYou can temporarily enable the insecure key for one container only. This means that the insecure key is installed at container boot. If you `docker stop` and `docker start` the container, the insecure key will still be there, but if you use `docker run` to start a new container then that container will not contain the insecure key.\n\nStart a container with `--enable-insecure-key`:\n\n    docker run YOUR_IMAGE /sbin/my_init --enable-insecure-key\n\nFind out the ID of the container that you just ran:\n\n    docker ps\n\nOnce you have the ID, look for its IP address with:\n\n    docker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\n\nNow that you have the IP address, you can use SSH to login to the container, or to execute a command inside it:\n\n    # Download the insecure private key\n    curl -o insecure_key -fSL https://github.com/phusion/baseimage-docker/raw/master/image/services/sshd/keys/insecure_key\n    chmod 600 insecure_key\n\n    # Login to the container\n    ssh -i insecure_key root@<IP address>\n\n    # Running a command inside the container\n    ssh -i insecure_key root@<IP address> echo hello world\n\n<a name=\"enabling_the_insecure_key_permanently\"></a>\n#### Enabling the insecure key permanently\n\nIt is also possible to enable the insecure key in the image permanently. This is not generally recommended, but is suitable for e.g. temporary development or demo environments where security does not matter.\n\nEdit your Dockerfile to install the insecure key permanently:\n\n    RUN /usr/sbin/enable_insecure_key\n\nInstructions for logging into the container is the same as in section [Using the insecure key for one container only](#using_the_insecure_key_for_one_container_only).\n\n<a name=\"using_your_own_key\"></a>\n#### Using your own key\n\nEdit your Dockerfile to install an SSH public key:\n\n    ## Install an SSH of your choice.\n    COPY your_key.pub /tmp/your_key.pub\n    RUN cat /tmp/your_key.pub >> /root/.ssh/authorized_keys && rm -f /tmp/your_key.pub\n\nThen rebuild your image. Once you have that, start a container based on that image:\n\n    docker run your-image-name\n\nFind out the ID of the container that you just ran:\n\n    docker ps\n\nOnce you have the ID, look for its IP address with:\n\n    docker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\n\nNow that you have the IP address, you can use SSH to login to the container, or to execute a command inside it:\n\n    # Login to the container\n    ssh -i /path-to/your_key root@<IP address>\n\n    # Running a command inside the container\n    ssh -i /path-to/your_key root@<IP address> echo hello world\n\n<a name=\"docker_ssh\"></a>\n#### The `docker-ssh` tool\n\nLooking up the IP of a container and running an SSH command quickly becomes tedious. Luckily, we provide the `docker-ssh` tool which automates this process. This tool is to be run on the *Docker host*, not inside a Docker container.\n\nFirst, install the tool on the Docker host:\n\n    curl --fail -L -O https://github.com/phusion/baseimage-docker/archive/master.tar.gz && \\\n    tar xzf master.tar.gz && \\\n    sudo ./baseimage-docker-master/install-tools.sh\n\nThen run the tool as follows to login to a container using SSH:\n\n    docker-ssh YOUR-CONTAINER-ID\n\nYou can lookup `YOUR-CONTAINER-ID` by running `docker ps`.\n\nBy default, `docker-ssh` will open a Bash session. You can also tell it to run a command, and then exit:\n\n    docker-ssh YOUR-CONTAINER-ID echo hello world\n\n\n<a name=\"building\"></a>\n## Building the image yourself\n\nIf for whatever reason you want to build the image yourself instead of downloading it from the Docker registry, follow these instructions.\n\nClone this repository:\n\n    git clone https://github.com/phusion/baseimage-docker.git\n    cd baseimage-docker\n\nStart a virtual machine with Docker in it. You can use the Vagrantfile that we've already provided.\n\nFirst, install `vagrant-disksize` plug-in:\n\n    vagrant plugin install vagrant-disksize\n\nThen, start the virtual machine\n\n    vagrant up\n    vagrant ssh\n    cd /vagrant\n\nBuild the image:\n\n    make build\n\nIf you want to call the resulting image something else, pass the NAME variable, like this:\n\n    make build NAME=joe/baseimage\n\nYou can also change the `ubuntu` base-image to `debian` as these distributions are quite similar.\n\n    make build BASE_IMAGE=debian:stretch\n\nThe image will be: `phusion/baseimage-debian-stretch`. Use the `NAME` variable in combination with the `BASE_IMAGE` one to call it `joe/stretch`.\n\n    make build BASE_IMAGE=debian:stretch NAME=joe/stretch\n\nTo verify that the various services are started, when the image is run as a container, add `test` to the end of your make invocations, e.g.:\n\n    make build BASE_IMAGE=debian:stretch NAME=joe/stretch test\n\n\n<a name=\"removing_optional_services\"></a>\n### Removing optional services\n\nThe default baseimage-docker installs `syslog-ng`, `cron` and `sshd` services during the build process.\n\nIn case you don't need one or more of these services in your image, you can disable its installation through the `image/buildconfig` that is sourced within `image/system_services.sh`.  Do this at build time by passing a variable in with `--build-arg`  as in `docker build --build-arg DISABLE_SYSLOG=1 image/`, or you may set the variable in `image/Dockerfile` with an ENV setting above the RUN directive.\n\nThese represent build-time configuration, so setting them in the shell env at build-time [will not have any effect](https://github.com/phusion/baseimage-docker/issues/459#issuecomment-439177442).  Setting them in child images' Dockerfiles will also not have any effect.)\n\nYou can also set them directly as shown in the following example, to prevent `sshd` from being installed into your image, set `1` to the `DISABLE_SSH` variable in the `./image/buildconfig` file.\n\n    ### In ./image/buildconfig\n    # ...\n    # Default services\n    # Set 1 to the service you want to disable\n    export DISABLE_SYSLOG=0\n    export DISABLE_SSH=1\n    export DISABLE_CRON=0\n\nThen you can proceed with `make build` command.\n\n<a name=\"conclusion\"></a>\n## Conclusion\n\n * Using baseimage-docker? [Tweet about us](https://twitter.com/share) or [follow us on Twitter](https://twitter.com/phusion_nl).\n * Having problems? Want to participate in development? Please post a message at [the discussion forum](https://groups.google.com/d/forum/passenger-docker).\n * Looking for a more complete base image, one that is ideal for Ruby, Python, Node.js and Meteor web apps? Take a look at [passenger-docker](https://github.com/phusion/passenger-docker).\n * Need a helping hand? Phusion also offers [consulting](https://www.phusion.nl/consultancy) on a wide range of topics, including Web Development, UI/UX Research & Design, Technology Migration and Auditing. \n\n[<img src=\"https://avatars.githubusercontent.com/u/830588?s=200&v=4\">](https://www.phusion.nl/)\n\nPlease enjoy baseimage-docker, a product by [Phusion](http://www.phusion.nl/). :-)\n"
        },
        {
          "name": "README_ZH_cn_.md",
          "type": "blob",
          "size": 29.62109375,
          "content": "<a name=\"a-minimal-ubuntu-base-image-modified-for-docker-friendliness\"></a>\n# Docker友好的，最小的Ubuntu基础镜像\n\nBaseimage-docker是一个特殊的[Docker](http://www.docker.io)镜像，在Docker容器内做了配置，并且可以正确使用。它确实是一个Ubuntu系统, 除此之外进行了如下修订：\n\n * 为更加友好的支持Docker，做了修订。\n * 在Docker环境下，作为管理工具特别有用。\n * 在[不违反Docker哲学](#docker_single_process)的前提下，能够很容易的运行多进程的机制。\n\n可以把它作为自己的基础Docker镜像。\n\nBaseimage-docker项目可以直接从Docker的[registry](https://index.docker.io/u/phusion/baseimage/)获取！\n\n<a name=\"what-are-the-problems-with-the-stock-ubuntu-base-image\"></a>\n### 原生的Ubuntu基础镜像有什么问题呢？          \n\n原生Ubuntu不是为了在Docker内运行而设计的。它的初始化系统Upstart，假定运行的环境要么是真实的硬件，要么是虚拟的硬件，而不是在Docker容器内。但是在一个Docker的容器内，并不需要一个完整的系统，你需要的只是一个很小的系统。但是如果你不是非常熟悉Unix的系统模型，想要在Docker容器内裁减出最小的系统，会碰到很多难以正确解决的陌生的技术坑。这些坑会引起很多莫名其妙的问题。\n\nBaseimage-docker让这一切完美。在\"内容\"部分描述了所有这些修改。\n\n<a name=\"why-use-baseimage-docker\"></a>\n### 为什么使用baseimage-docker？\n\n你自己可以从Dockerfile配置一个原生`ubuntu`镜像，为什么还要多此一举的使用baseimage-docker呢?\n\n * 配置一个Docker友好的基础系统并不是一个简单的任务。如前所述，过程中会碰到很多坑。当你搞定这些坑之后，只不过是又重新发明了一个baseimage-docker而已。使用baseimage-docker可以免去你这方面需要做的努力。          \n * 减少需要正确编写Dockerfile文件的时间。你不用再担心基础系统，可以专注于你自己的技术栈和你的项目。            \n * 减少需要运行`docker build`的时间，让你更快的迭代Dockerfile。         \n * 减少了重新部署的时的下载时间。Docker只需要在第一次部署的时候下载一次基础镜像。在随后的部署中,只需要改变你下载之后对基础镜像进行修改的部分。\n\n-----------------------------------------\n\n**相关资源**\n\n  [网站](http://phusion.github.io/baseimage-docker/) |\n  [Github](https://github.com/phusion/baseimage-docker) |\n  [Docker registry](https://index.docker.io/u/phusion/baseimage/) |\n  [论坛](https://groups.google.com/d/forum/passenger-docker) |\n  [Twitter](https://twitter.com/phusion_nl) |\n  [Blog](http://blog.phusion.nl/)\n\n**目录**\n\n * [镜像里面有什么?](#whats_inside)\n   * [概述](#whats_inside_overview)\n   * [等等,我认为Docker在一个容器中只能允许运行一个进程?](#docker_single_process)           \n   * [Baseimage-docker更侧重于“胖容器”还是“把容器当作虚拟机”？](#fat_containers)            \n * [查看baseimage-docker](#inspecting)\n * [使用baseimage-docker作为基础镜像](#using)\n   * [开始](#getting_started)\n   * [增加额外的后台进程](#adding_additional_daemons)\n   * [容器启动时运行脚本](#running_startup_scripts)\n   * [环境变量](#environment_variables)\n     * [集中定义自己的环境变量](#envvar_central_definition)\n     * [保存环境变量](#envvar_dumps)\n     * [修改环境变量](#modifying_envvars)\n     * [安全性](#envvar_security)\n * [容器管理](#container_administration)\n   * [在一个新容器中运行单条命令](#oneshot)\n   * [在正在运行的的容器中运行一条命令](#run_inside_existing_container)\n   * [通过`docer exec`登录容器](#login_docker_exec)\n     * [用法](#nsenter_usage)\n   * [使用SSH登录容器](#login_ssh)\n     * [启用SSH](#enabling_ssh)\n     * [关于SSH的key](#ssh_keys)\n     * [只对一个容器使用不安全key](#using_insecure_key_for_one_container_only)\n     * [永久开启不安全key](#enabling_the_insecure_key_permanently)\n     * [使用你自己的key](#using_your_own_key)\n     * [`docker-ssh`工具](#docker_ssh)\n * [构建自己的镜像](#building)\n * [总结](#conclusion)\n\n-----------------------------------------\n\n<a name=\"whats_inside\"></a>\n## 镜像里面有什么？\n\n<a name=\"whats_inside_overview\"></a>\n### 概述\n\n*想看一个里面包含Ruby，Python，Node.js以及Meteor的完整基础镜像？可以看一下[passenger-docker](https://github.com/phusion/passenger-docker)。*            \n\n| 模块        | 为什么包含这些？以及备注 |\n| ---------------- | ------------------- |\n| Ubuntu 24.04 LTS | 基础系统。 |\n| 一个**正确**的初始化进程  | *主要文章：[Docker和PID 1 僵尸进程回收问题](http://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/)*<br/><br/>根据Unix进程模型，[初始化进程](https://en.wikipedia.org/wiki/Init) -- PID 1 -- 继承了所有[孤立的子进程](https://en.wikipedia.org/wiki/Orphan_process)，并且必须[进行回收](https://en.wikipedia.org/wiki/Wait_(system_call))。大多数Docker容器没有一个初始化进程可以正确的完成此操作，随着时间的推移会导致他们的容器出现了大量的[僵尸进程](https://en.wikipedia.org/wiki/Zombie_process)。<br/><br/>而且，`docker stop`发送SIGTERM信号给初始化进程，照理说此信号应该可以停止所有服务。不幸的是由于它们对硬件进行了关闭操作，导致Docker内的大多数初始化系统没有正确执行。这会导致进程强行被SIGKILL信号关闭，从而丧失了一个正确取消初始化设置的机会。这会导致文件损坏。<br/><br/>Baseimage-docker配有一个名为`/sbin/my_init`的初始化进程来同时正确的完成这些任务。 |\n| 修复了APT与Docker不兼容的问题 | 详情参见：https://github.com/dotcloud/docker/issues/1024 。 |\n| syslog-ng | 对于很多服务－包括kernel自身，都需要一个syslog后台进程，以便可以正确的将log输出到/var/log/syslog中。如果没有运行syslog后台进程，很多重要的信息就会默默的丢失了。<br/><br/>只对本地进行监听。所有syslog信息会被转发给“docker logs”。 |\n| logrotate | 定期转存和压缩日志。 |\n| SSH服务 | 允许你很容易的登录到容器中进行[查询或管理](#login_ssh)操作。<br/><br/>_SSH**默认是禁用**的，这也是baseimage-docker为此目的提供的唯一方法。其它方法需要通过[docker exec](#login_docker_exec)。由于`docker exec`同时带来了几个需要注意的问题，SSH同时也提供了一个可替换的方法。_<br/><br/>密码和challenge-response认证方式默认是禁用的。只有key认证通过之后才能够开启。 |\n| cron | 为了保证cron任务能够工作，必须运行cron后台进程。 |\n| [runit](http://smarden.org/runit/) | 替换Ubuntu的Upstart。用于服务监控和管理。比SysV init更容易使用，同时当这些服务崩溃之后，支持后台进程自动重启。比Upstart更易使用，更加的轻量级。 |\n| `setuser` | 使用其它账户运行命令的工具。比`su`更容易使用，比使用`sudo`有那么一点优势，跟`chpst`不同，这个工具需要正确的设置`$HOME`。像`/sbin/setuser`这样。 |\nBaseimage-docker非常的轻量级：仅仅占用6MB内存。\n\n<a name=\"docker_single_process\"></a>\n### 等等,我认为Docker在一个容器中就运行一个进程吗?\n绝对不是这样的. 在一个docker容器中,运行多个进程也是很好的. 事实上,没有什么技术原因限制你只运行一个进程,运行很多的进程,只会把容器中系统的基本功能搞的更乱,比如syslog.\n\nBaseimage-docker *鼓励* 通过runit来运行多进程.\n\n<a name=\"inspecting\"></a>\n## 检测一下baseimage-docker\n\n要检测镜像,执行下面的命令:\n\n    docker run --rm -t -i phusion/baseimage:<VERSION> /sbin/my_init -- bash -l\n\n`<VERSION>` 是[baseimage-docker的版本号](https://github.com/phusion/baseimage-docker/blob/master/Changelog.md).\n\n你不用手动去下载任何文件.上面的命令会自动从docker仓库下载baseimage-docker镜像.\n\n<a name=\"using\"></a>\n## 使用baseimage-docker作为基础镜像\n\n<a name=\"getting_started\"></a>\n### 入门指南\n\n镜像名字叫`phusion/baseimage`,在Docker仓库上也是可用的.\n\n下面的这个是一个Dockerfile的模板.\n\n\t# 使用phusion/baseimage作为基础镜像,去构建你自己的镜像,需要下载一个明确的版本,千万不要使用`latest`.\n\t# 查看https://github.com/phusion/baseimage-docker/blob/master/Changelog.md,可用看到版本的列表.\n\tFROM phusion/baseimage:<VERSION>\n\n\t# 设置正确的环境变量.\n\tENV HOME /root\n\n\t# 生成SSH keys,baseimage-docker不包含任何的key,所以需要你自己生成.你也可以注释掉这句命令,系统在启动过程中,会生成一个.\n\tRUN /etc/my_init.d/00_regen_ssh_host_keys.sh\n\n\t# 初始化baseimage-docker系统\n\tCMD [\"/sbin/my_init\"]\n\n\t# 这里可以放置你自己需要构建的命令\n\n\t# 当完成后,清除APT.\n\tRUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n\n<a name=\"adding_additional_daemons\"></a>\n### 增加后台进程\n\n你可以通过runit工具向你的镜像中添加后台进程(例如:你自己的某些应用).你需要编写一个运行你需要的后台进程的脚本就可以了,runit工具会保证它的正常运行,如果进程死掉,runit也会重启它的.\n\n脚本的名称必须是`run`,必须是可以运行的,它需要放到`/etc/service/<NAME>`.\n\n这里有一个例子,向你展示如果运行memcached服务的.\n\n\t### memcached.sh(确定文件的权限是chmod +x):\n\t#!/bin/sh\n\t# `/sbin/setuser memcache` 指定一个`memcache`用户来运行命令.如果你忽略了这部分,就会使用root用户执行.\n\texec /sbin/setuser memcache /usr/bin/memcached >>/var/log/memcached.log 2>&1\n\n\t### 在Dockerfile中:\n    RUN mkdir /etc/service/memcached\n    COPY memcached.sh /etc/service/memcached/run\n\n注意脚本必须运行在后台的,**不能让他们进程进行daemonize/fork**.通常,后台进程会提供一个标志位或者配置文件.\n\n<a name=\"running_startup_scripts\"></a>\n### 在容器启动的时候,运行脚本.\n\nbaseimage-docker的初始化脚本 `/sbin/my_init`,在启动的时候进程运行,按照下面的顺序:\n\n * 如果`/etc/my_init.d`存在,则按照字母顺序执行脚本.\n * 如果`/etc/rc.local`存在,则执行里面的脚本.\n\n所有的脚本都是正确退出的,例如:退出的code是0.如果有任何脚本以非0的code退出,启动就会失败.\n\n下面的例子向你展示了怎么添加一个启动脚本.这个脚本很简单的记录的一个系统启动时间,将启动时间记录到/tmp/boottime.txt.\n\n    ### 在 logtime.sh (文件权限chmod +x):\n    #!/bin/sh\n    date > /tmp/boottime.txt\n\n    ### 在 Dockerfile中:\n    RUN mkdir -p /etc/my_init.d\n    COPY logtime.sh /etc/my_init.d/logtime.sh\n\n\n<a name=\"environment_variables\"></a>\n### 环境变量\n\n如果你使用`/sbin/my_init`作为主容器命令,那么通过`docker run --env`或者在Dockerfile文件中设置的`ENV`环境变量,都会被`my_init`读取.\n\n * 在Unix系统中,环境变量都会被子进程给继承.这就意味着,子进程不可能修改环境变量或者修改其他进程的环境变量.\n * 由于上面提到的一点,这里没有一个可以为所有应用和服务集中定义环境的地方.Debian提供了一个`/etc/environment` 文件,解决一些问题.\n * 某些服务更改环境变量是为了给子进程使用.Nginx有这样的一个例子:它移除了所有的环境变量,除非你通过`env`进行了配置,明确了某些是保留的.如果你部署了任何应用在Nginx镜像(例如:使用[passenger-docker](https://github.com/phusion/passenger-docker)镜像或者使用Phusion Passenger作为你的镜像.),那么你通过Docker,你不会看到任何环境变量.\n\n\n`my_init`提供了一个办法来解决这些问题.\n\n<a name=\"envvar_central_definition\"></a>\n#### 集中定义你的环境变量\n\n在启动的时候,在执行[startup scripts](#running_startup_scripts),`my_init`会从`/etc/container_environment`导入环境变量.这个文件夹下面,包含的文件,文件被命名为环境变量的名字.文件内容就是环境变量的值.这个文件夹是因此是一个集中定义你的环境变量的好地方,它会继承到所有启动项目和Runit管理的服务中.\n\n给个例子,在你的dockerfile如何定义一个环境变量:\n\n    RUN echo Apachai Hopachai > /etc/container_environment/MY_NAME\n\n你可以按照下面这样验证:\n\n    $ docker run -t -i <YOUR_NAME_IMAGE> /sbin/my_init -- bash -l\n    ...\n    *** Running bash -l...\n    # echo $MY_NAME\n    Apachai Hopachai\n\n**换行处理**\n\n如果你观察仔细一点,你会注意到'echo'命令,实际上在它是在新行打印出来的.为什么$MY_NAME没有包含在一行呢? 因为`my_init`在尾部有个换行字符.如果你打算让你的值包含一个新行,你需要增*另外*一个新字符,像这样:\n\n    RUN echo -e \"Apachai Hopachai\\n\" > /etc/container_environment/MY_NAME\n\n<a name=\"envvar_dumps\"></a>\n#### 环境变量存储\n\n上面提到集中定义环境变量,它不会从子服务进程改变父服务进程或者重置环境变量.而且,`my_init`也会很容易的让你查询到原始的环境变量是什么.\n\n在启动的时候,`/etc/container_environment`, `my_init`中的变量会存储起来,并且导入到环境变量中,例如一下的格式:\n\n * `/etc/container_environment`\n * `/etc/container_environment.sh`- 一个bash存储的环境变量格式.你可以从这个命令中得到base格式的文件.\n * `/etc/container_environment.json` - 一个json格式存储的环境变量格式.\n\n多种格式可以让你不管采用什么语言/apps都可以很容易使用环境变量.\n\n这里有个例子,展示怎么使用:\n\n    $ docker run -t -i \\\n      --env FOO=bar --env HELLO='my beautiful world' \\\n      phusion/baseimage:<VERSION> /sbin/my_init -- \\\n      bash -l\n    ...\n    *** Running bash -l...\n    # ls /etc/container_environment\n    FOO  HELLO  HOME  HOSTNAME  PATH  TERM  container\n    # cat /etc/container_environment/HELLO; echo\n    my beautiful world\n    # cat /etc/container_environment.json; echo\n    {\"TERM\": \"xterm\", \"container\": \"lxc\", \"HOSTNAME\": \"f45449f06950\", \"HOME\": \"/root\", \"PATH\": \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"FOO\": \"bar\", \"HELLO\": \"my beautiful world\"}\n    # source /etc/container_environment.sh\n    # echo $HELLO\n    my beautiful world\n\n<a name=\"modifying_envvars\"></a>\n#### 修改环境变量\n\n通过修改`/etc/container_environment`这个文件,很有可能修改了`my_init`中的环境变量.之后,每次`my_init`启动[启动脚本](#running_startup_scripts),就会重置掉我们自己`/etc/container_environment`中的环境变量,也就会导致`container_environment.sh`和`container_environment.json`重新存储.\n\n但是记住这些:\n\n * 修改`container_environment.sh` 和 `container_environment.json`是没有效果的.\n * Runit 的服务是不能像这样修改环境变量的.`my_init`运行的时候,只对`/etc/container_environment`中的修改是生效的.\n\n<a name=\"envvar_security\"></a>\n#### 安全\n\n因为环境变量可能包含敏感信息, `/etc/container_environment`和它的bash文件和JSON文件,默认都是root,都是可以被`docker_env`群组可以访问的(所以任何用户只要添加到群组中,都可以自动的获取这些信息).\n\n如果你确定你的环境变量中没有什么敏感信息,那么你可以放松管理权限,将文件夹和文件分配下面的权限:\n\n    RUN chmod 755 /etc/container_environment\n    RUN chmod 644 /etc/container_environment.sh /etc/container_environment.json\n\n<a name=\"workaroud_modifying_etc_hosts\"></a>\n### 解决Docker没有办法解决的/etc/hosts的问题\n\n当前是没有办法在docker容器中修改`/etc/hosts`,这个是因为[Docker bug 2267](https://github.com/dotcloud/docker/issues/2267).Baseimage-docker包含了解决这个问题的办法,你必须明白是怎么修改的.\n\n修改的办法包含在系统库中的` libnss_files.so.2`文件,这个文件使用`/etc/workaround-docker-2267/hosts`来代替系统使用`/etc/hosts`.如果需要修改`/etc/hosts`,你只要修改`/etc/workaround-docker-2267/hosts`就可以了.\n\n增加这个修改到你的Dockerfile.下面的命令修改了文件`libnss_files.so.2`.\n\n    RUN /usr/bin/workaround-docker-2267\n\n(其实你不用在Dockerfile文件中运行这个命令,你可以在容器中运行一个shell就可以了.)\n\n验证一下它是否生效了,[在你的容器中打开一个shell](#inspecting),修改`/etc/workaround-docker-2267/hosts`,检查一下是否生效了:\n\n    bash# echo 127.0.0.1 my-test-domain.com >> /etc/workaround-docker-2267/hosts\n    bash# ping my-test-domain.com\n    ...should ping 127.0.0.1...\n\n**注意apt-get升级:** 如果Ubuntu升级,就有可能将`libnss_files.so.2`覆盖掉,那么修改就会失效.你必须重新运行`/usr/bin/workaround-docker-2267`.为了安全一点,你应该在运行`apt-get upgrade`之后,运行一下这个命令.\n\n<a name=\"disabling_ssh\"></a>\n### 禁用SSH\nBaseimage-docker默认是支持SSH的,所以可以[使用SSH](#login_ssh)来[管理你的容器](#container_administration).万一你不想支持SSH,你只要禁用它就可以:\n\n    RUN rm -rf /etc/service/sshd /etc/my_init.d/00_regen_ssh_host_keys.sh\n\n<a name=\"container_administration\"></a>\n## 容器管理\n\n一个优秀的docker想法,就是docker是一个无状态的,容易启动的容器,就想一个黑盒子.然而,你可能遇到某种情况,需要登录到容器,或者运行命令在容器中.或者为了开发,需要查看或者debug的目的.这章就给你讲解怎么管理容器.\n\n\n<a name=\"oneshot\"></a>\n### 在一个新容器中运行一个一闪而过的命令\n\n_**备注:** 这章讲解怎么在一个-新-容器中运行命令.要在一个存在的容器中运行命令,请查看[在一个存在的容器中,运行一个命令](#run_inside_existing_container)._\n\n正常情况下,当你创建了一个新容器,为了在容器中运行一个单独的命令,而且在运行之后会立即退出的,你会这样调用docker命令:\n\n    docker run YOUR_IMAGE COMMAND ARGUMENTS...\n\n然而下面的方法初始化系统的进行是不会启动.它是这样的,当调用`COMMAND`的时候,重要的后台进程,例如定时任务和系统日志都是不运行的.同样,子进程也是不会出现的,因为`COMMAND`的pid是1.\n\nBaseimage-docker提供了一个灵活的方式运行只要一闪而过的命令,同时也解决了上述所说的问题.以一下的方式运行一条命令:\n\n    docker run YOUR_IMAGE /sbin/my_init -- COMMAND ARGUMENTS ...\n\n他们会按照下面的流程执行:\n\n * 运行所有的启动文件,例如 /etc/my_init.d/* and /etc/rc.local.\n * 运行所有的runit服务\n * 运行指定的命令\n * 运行指定的命令结束之后,结束所有runit服务.\n\n例如:\n\n    $ docker run phusion/baseimage:<VERSION> /sbin/my_init -- ls\n    *** Running /etc/my_init.d/00_regen_ssh_host_keys.sh...\n    No SSH host key available. Generating one...\n    Creating SSH2 RSA key; this may take some time ...\n    Creating SSH2 DSA key; this may take some time ...\n    Creating SSH2 ECDSA key; this may take some time ...\n    *** Running /etc/rc.local...\n    *** Booting runit daemon...\n    *** Runit started as PID 80\n    *** Running ls...\n    bin  boot  dev  etc  home  image  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var\n    *** ls exited with exit code 0.\n    *** Shutting down runit daemon (PID 80)...\n    *** Killing all processes...\n\n你会发现默认的启动流程太复杂或者你不希望执行启动文件, 你可以自定义这些参数传递给 `my_init`. 调用`docker run YOUR_IMAGE /sbin/my_init --help`可以看到帮助信息.\n\n例如上面运行`ls`命令,同时要求不运行启动脚本,减少信息打印,运行runit所有命令.\n\n    $ docker run phusion/baseimage:<VERSION> /sbin/my_init --skip-startup-files --quiet -- ls\n    bin  boot  dev  etc  home  image  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var\n\n<a name=\"run_inside_existing_container\"></a>\n### 在一个已经运行的容器中,运行一条命令\n\n这里有两种办法, 在一个已经运行的容器内执行命令.\n\n * 通过`nseneter`工具. 这个工具用于Linux内核调用在内嵌容器中运行命令. 可以查看[通过`nsenter`,登录容器或者在容器内执行命令](#login_nsenter).\n * 通过SSH.这种办法需要在容器中运行ssh服务,而且需要你创建自己的sshkey. 可以查看[通过`ssh`,登录容器或者在容器内执行命令](#login_ssh).\n\n两种方法都是他们各自的优点和确定, 你可以学习他们各自的章节来了解他们.\n\n<a name=\"login_nsenter\"></a>\n### 通过`nsenter`,登录容器或者在容器内执行命令\n\n你可以使用在docker主机上面的`nsenter`工具,来登录任何基于baseimage-docker的docker容器.你可以使用它在你的容器中运行命令.\n\n这里有个和[通过`ssh`,登录容器或者在容器内执行命令](#login_ssh)的优缺点的比较:\n\n * 优点\n   * 不需要在容器中运行ssh服务.\n   * 不需要ssh key.\n   * 运行在任何容器上,甚至不是基于baseimage-docker的容器.\n * 缺点\n   * 通过`nsenter`运行的进程会和正常运行稍微有不同.例如,他们不同结束掉在容器中正常运行的进程.这适用于所有的子进程.\n   * 如果`nsenter`进程被其他命令(如`kill`命令)给终止,然后由nsenter所执行的命令,是*不会*被结束的.你将不得不手动清理.(备注:终端控制命令像Ctrl-C *会* 清理所有的子进程,因为终端信号被发送到所有流程的终端会话)\n   * 需要学习新工具.\n   * 需要在docker主机上面提供root权限.\n   * 需要在docker主机上面是可用的.在写这篇文字的时候(2014年7月),大多数linux发行版没有加载它.然而,baseimage-docker提供了预编译的二进制文件,允许你通过[docker-bash](#docker_bash)工具,来很容易的使用它.\n   * 不可能没有登录到docker主机,就登录到docker容器中.(也就是说,你必须登录到docker主机,通过docker主机登录到容器.)\n\n<a name=\"nsenter_usage\"></a>\n#### 用例\n\n第一,确定`nsenter`已经安装了.在写这篇文字的时候(2014年7月),大多数linux发行版没有加载它.然而,baseimage-docker提供了预编译的二进制文件,允许你通过[docker-bash](#docker_bash)工具,让任何人都可以使用.\n\n接着,启动一个容器.\n\n    docker run YOUR_IMAGE\n\n找出你刚才运行容器的`ID`.\n\n    docker ps\n\n一旦得到容器的id, 找到运行容器的主进程`PID`.\n\n    docker inspect -f \"{{ .State.Pid }}\" <ID>\n\n现在你已得到容器的主进程PID, 就可以使用`nsenter`来登录容器, 或者在容器中执行命令:\n\n    # 登录容器\n    nsenter --target <MAIN PROCESS PID> --mount --uts --ipc --net --pid bash -l\n\n    # 在容器中执行命令\n    nsenter --target <MAIN PROCESS PID> --mount --uts --ipc --net --pid -- echo hello world\n\n<a name=\"docker_bash\"></a>\n#### `docker-bash`工具\n目前(2017-03-31), 英文文档没有发现这个命令\n\n查找一个容器的主要进程的PID和输入这么长的nsenter命令很快会变得乏味无比.幸运的是,我们提供了一个`docker-bash` 工具,它可以自动完成只要的工具.这个工具是运行在*docker主机*上面,不是在docker容器中.\n\n该工具还附带了一个预编译的二进制`nsenter`,这样你不需要自己安装`nsenter`了.`docker-bash`是很简单的使用的.\n\n首先,在docker主机上安装这个工具:\n\n    curl --fail -L -O https://github.com/phusion/baseimage-docker/archive/master.tar.gz && \\\n    tar xzf master.tar.gz && \\\n    sudo ./baseimage-docker-master/install-tools.sh\n\n运行这个工具登录到容器中:\n\n    docker-bash YOUR-CONTAINER-ID\n\n你可以通过`docker ps`来查找你的容器ID.\n\n默认,`docker-bash`会打开一个bash 回话.你可以告诉运行什么命令,之后就会自动退出:\n\n    docker-bash YOUR-CONTAINER-ID echo hello world\n\n<a name=\"login_ssh\"></a>\n### 通过`ssh`,登录容器或者在容器内执行命令\n\n你可以使用ssh来登录任何基于baseimage-docker的容器.你可以使用它在容器中执行命令.\n\n这里有个和[通过`nsenter`,登录容器或者在容器内执行命令](#login_nsenter)的优缺点的比较:\n\n * 优点\n   * 不像`nsenter`一样,运行在docker主机上面.几乎每个人都会安装一个ssh客户端.\n   * 不想使用`nsenter`,运行的进程和正在的进程会不一样.\n   * 不需要docker主机提供root权限.\n   * 运行你让用户登录到容器,而不需要登录到docker主机.然而,默认这是不启用的,因为baseimage-docker默认不是开放ssh服务的.\n * 缺点\n   * 需要设置ssh key.然而,baseimage-docker会提供一种方法,会让key的生成变得很容易.阅读更多信息.\n\n第一件事情,就是你需要确定你在容器中已经安装设置了ssh key. 默认是不安装任何key的,所以任何人都无法登录.为了方便的原因,我们提供了一个[已经生成的key](https://github.com/phusion/baseimage-docker/blob/master/image/services/sshd/keys/insecure_key) [(PuTTY format)](https://github.com/phusion/baseimage-docker/blob/master/image/services/sshd/keys/insecure_key.ppk),为了让你使用方便.然后,请注意这个key仅仅是为方便.他没有任何安全性,因为它的key是在网络上提供的.**在生产环境,你必须使用你自己的key.**\n\n\n<a name=\"using_the_insecure_key_for_one_container_only\"></a>\n#### 在容器中使用key\n\n你可以临时的使用key仅仅作为容器使用.这就以为这key是安装在容器上的.如果你使用`docker stop`和`docker start`控制容器,那么key是在容器中,但是如果你使用`docker run`开启一个新容器,那么这个容器是不包含key的.\n\n启动新容器包含key`--enable-insecure-key`:\n\n    docker run YOUR_IMAGE /sbin/my_init --enable-insecure-key\n\n找出你的刚才运行的容器的ID:\n\n    docker ps\n\n一旦你得到容器的ID,就能找到容器使用的IP地址:\n\n    docker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\n\n译者注:  类似 `\"{{ .NetworkSettings.IPAddress }}\"` 是用到了 [Go的模板语法](https://gohugo.io/templates/go-templates/).\n\n现在你得到了IP地址, 你就可以通过SSH来登录容器,或者在容器中执行命令了:\n\n    # 下载key\n    curl -o insecure_key -fSL https://github.com/phusion/baseimage-docker/raw/master/image/services/sshd/keys/insecure_key\n    chmod 600 insecure_key\n\n    # 登录容器\n    ssh -i insecure_key root@<IP address>\n\n    # 在容器中执行命令\n    ssh -i insecure_key root@<IP address> echo hello world\n\n<a name=\"enabling_the_insecure_key_permanently\"></a>\n#### 支持一个长久的key\n\n在一个长久存在的镜像中支持一个key是很可能的.一般是不推荐这么做,但是对于临时开始或者做demo演示,对安全要求不高,还是很合适的.\n\n编辑你的dockerfile,来安装永久的key:\n\n    RUN /usr/sbin/enable_insecure_key\n\n在容器中怎么使用,同[在容器中使用key](#using_the_insecure_key_for_one_container_only)的章节说的一样.\n\n<a name=\"using_your_own_key\"></a>\n#### 使用你自己的key\n\n编辑你的dockerfile,来安装ssh public key:\n\n    ## 安装你自己的public key.\n    COPY your_key.pub /tmp/your_key.pub\n    RUN cat /tmp/your_key.pub >> /root/.ssh/authorized_keys && rm -f /tmp/your_key.pub\n\n重新创建你的镜像.一旦你创建成功,启动基于这个镜像的容器.\n\n    docker run your-image-name\n\n找出你的刚才运行的容器的ID:\n\n    docker ps\n\n一旦你拥有容器的ID,就能找到容器使用的IP地址:\n\n    docker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\n\n现在你有得了IP地址,你就可以通过SSH来登录容器,或者在容器中执行命令了:\n\n    # 登录容器\n    ssh -i /path-to/your_key root@<IP address>\n\n    # 在容器中执行命令\n    ssh -i /path-to/your_key root@<IP address> echo hello world\n\n<a name=\"docker_ssh\"></a>\n#### `docker-ssh`工具\n\n找到容器的IP,运行ssh命令,很快会变得乏味无聊.幸运的是,我们提供了一个`docker-ssh`,可以自动完成这些事情.这个工具是运行在*Docker 主机*上的,不是安装在docker容器中的.\n\n首先,在docker主机上面安装这个工具.\n\n    curl --fail -L -O https://github.com/phusion/baseimage-docker/archive/master.tar.gz && \\\n    tar xzf master.tar.gz && \\\n    sudo ./baseimage-docker-master/install-tools.sh\n\n使用这个工具通过ssh登录容器:\n\n    docker-ssh YOUR-CONTAINER-ID\n\n你可以使用`docker ps`找到`YOUR-CONTAINER-ID`.\n\n默认,`docker-bash`会打开一个bash 回话.你可以告诉运行什么命令,之后就会自动退出:\n\n    docker-ssh YOUR-CONTAINER-ID echo hello world\n\n<a name=\"building\"></a>\n## 创建你自己的镜像\n\n如果某些原因,你需要创建你自己的镜像,来替代从docker仓库下载镜像,可以按照的说明.\n\n克隆仓库:\n\n    git clone https://github.com/phusion/baseimage-docker.git\n    cd baseimage-docker\n\n创建一个包含docker在内的虚拟机.你可以使用我们提供的Vagrantfile.\n\n    vagrant up\n    vagrant ssh\n    cd /vagrant\n\n编译镜像:\n\n    make build\n\n如果你想修改镜像的名称, 通过`NAME`变量可以设置:\n\n    make build NAME=joe/baseimage\n\n<a name=\"conclusion\"></a>\n## 总结\n\n * Using baseimage-docker? [Tweet about us](https://twitter.com/share) or [follow us on Twitter](https://twitter.com/phusion_nl).\n * Having problems? Want to participate in development? Please post a message at [the discussion forum](https://groups.google.com/d/forum/passenger-docker).\n * Looking for a more complete base image, one that is ideal for Ruby, Python, Node.js and Meteor web apps? Take a look at [passenger-docker](https://github.com/phusion/passenger-docker).\n\n[<img src=\"http://www.phusion.nl/assets/logo.png\">](http://www.phusion.nl/)\n\nPlease enjoy baseimage-docker, a product by [Phusion](http://www.phusion.nl/). :-)\n"
        },
        {
          "name": "README_zh_tw.md",
          "type": "blob",
          "size": 29.5576171875,
          "content": "<a name=\"a-minimal-ubuntu-base-image-modified-for-docker-friendliness\"></a>\n# Docker友好的，最小的Ubuntu基礎鏡像\n\nBaseimage-docker是一個特殊的[Docker](http://www.docker.io)鏡像，在Docker容器內做了配置，並且可以正確使用。它確實是一個Ubuntu系統, 除此之外進行了如下修訂：\n\n * 爲更加友好的支持Docker，做了修訂。\n * 在Docker環境下，作爲管理工具特別有用。\n * 在[不違反Docker哲學](#docker_single_process)的前提下，能夠很容易的運行多行程的機制。\n\n可以把它作爲自己的基礎Docker鏡像。\n\nBaseimage-docker項目可以直接從Docker的[registry](https://index.docker.io/u/phusion/baseimage/)獲取！\n        \n<a name=\"what-are-the-problems-with-the-stock-ubuntu-base-image\"></a>\n### 原生的Ubuntu基礎鏡像有什麼問題呢？          \n            \n原生Ubuntu不是爲了在Docker內運行而設計的。它的初始化系統Upstart，假定運行的環境要麼是真實的硬體，要麼是虛擬的硬體，而不是在Docker容器內。但是在一個Docker的容器內，並不需要一個完整的系統，你需要的只是一個很小的系統。但是如果你不是非常熟悉Unix的系統模型，想要在Docker容器內裁減出最小的系統，會碰到很多難以正確解決的陌生的技術坑。這些坑會引起很多莫名其妙的問題。\n\nBaseimage-docker讓這一切完美。在\"內容\"部分描述了所有這些修改。\n\n<a name=\"why-use-baseimage-docker\"></a>\n### 爲什麼使用baseimage-docker？\n\n你自己可以從Dockerfile配置一個原生`ubuntu`鏡像，爲什麼還要多此一舉的使用baseimage-docker呢?\n        \n * 配置一個Docker友好的基礎系統並不是一個簡單的任務。如前所述，過程中會碰到很多坑。當你搞定這些坑之後，只不過是又重新發明了一個baseimage-docker而已。使用baseimage-docker可以免去你這方面需要做的努力。          \n * 減少需要正確編寫Dockerfile文件的時間。你不用再擔心基礎系統，可以專注於你自己的技術棧和你的項目。            \n * 減少需要運行`docker build`的時間，讓你更快的迭代Dockerfile。         \n * 減少了重新部署的時的下載時間。Docker只需要在第一次部署的時候下載一次基礎鏡像。在隨後的部署中,只需要改變你下載之後對基礎鏡像進行修改的部分。\n\n-----------------------------------------\n\n**相關資源**\n\n  [網站](http://phusion.github.io/baseimage-docker/) |\n  [Github](https://github.com/phusion/baseimage-docker) |\n  [Docker registry](https://index.docker.io/u/phusion/baseimage/) |\n  [論壇](https://groups.google.com/d/forum/passenger-docker) |\n  [Twitter](https://twitter.com/phusion_nl) |\n  [Blog](http://blog.phusion.nl/)\n\n**目錄**\n\n * [鏡像裏面有什麼?](#whats_inside)\n   * [概述](#whats_inside_overview)\n   * [等等,我認爲Docker在一個容器中只能允許運行一個行程?](#docker_single_process)           \n   * [Baseimage-docker更側重於“胖容器”還是“把容器當作虛擬機”？](#fat_containers)            \n * [查看baseimage-docker](#inspecting)\n * [使用baseimage-docker作爲基礎鏡像](#using)\n   * [開始](#getting_started)\n   * [增加額外的後臺行程](#adding_additional_daemons)\n   * [容器啓動時運行腳本](#running_startup_scripts)\n   * [環境變數](#environment_variables)\n     * [集中定義自己的環境變數](#envvar_central_definition)\n     * [保存環境變數](#envvar_dumps)\n     * [修改環境變數](#modifying_envvars)\n     * [安全性](#envvar_security)\n * [容器管理](#container_administration)\n   * [在一個新容器中運行單條命令](#oneshot)\n   * [在正在運行的的容器中運行一條命令](#run_inside_existing_container)\n   * [通過`docer exec`登錄容器](#login_docker_exec)\n     * [用法](#nsenter_usage)\n   * [使用SSH登錄容器](#login_ssh)\n     * [啓用SSH](#enabling_ssh)\n     * [關於SSH的key](#ssh_keys)\n     * [只對一個容器使用不安全key](#using_insecure_key_for_one_container_only)\n     * [永久開啓不安全key](#enabling_the_insecure_key_permanently)\n     * [使用你自己的key](#using_your_own_key)\n     * [`docker-ssh`工具](#docker_ssh)\n * [構建自己的鏡像](#building)\n * [總結](#conclusion)\n\n-----------------------------------------\n\n<a name=\"whats_inside\"></a>\n## 鏡像裏面有什麼？\n\n<a name=\"whats_inside_overview\"></a>\n### 概述\n\n*想看一個裏面包含Ruby，Python，Node.js以及Meteor的完整基礎鏡像？可以看一下[passenger-docker](https://github.com/phusion/passenger-docker)。*            \n\n| 模塊        | 爲什麼包含這些？以及備註 |\n| ---------------- | ------------------- |\n| Ubuntu 24.04 LTS | 基礎系統。 |\n| 一個**正確**的初始化行程  | *主要文章：[Docker和PID 1 殭屍行程回收問題](http://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/)*<br/><br/>根據Unix行程模型，[初始化行程](https://en.wikipedia.org/wiki/Init) -- PID 1 -- 繼承了所有[孤立的子行程](https://en.wikipedia.org/wiki/Orphan_process)，並且必須[進行回收](https://en.wikipedia.org/wiki/Wait_(system_call))。大多數Docker容器沒有一個初始化行程可以正確的完成此操作，隨着時間的推移會導致他們的容器出現了大量的[殭屍行程](https://en.wikipedia.org/wiki/Zombie_process)。<br/><br/>而且，`docker stop`發送SIGTERM信號給初始化行程，照理說此信號應該可以停止所有服務。不幸的是由於它們對硬體進行了關閉操作，導致Docker內的大多數初始化系統沒有正確執行。這會導致行程強行被SIGKILL信號關閉，從而喪失了一個正確取消初始化設置的機會。這會導致文件損壞。<br/><br/>Baseimage-docker配有一個名爲`/sbin/my_init`的初始化行程來同時正確的完成這些任務。 |\n| 修復了APT與Docker不兼容的問題 | 詳情參見：https://github.com/dotcloud/docker/issues/1024 。 |\n| syslog-ng | 對於很多服務－包括kernel自身，都需要一個syslog後臺行程，以便可以正確的將log輸出到/var/log/syslog中。如果沒有運行syslog後臺行程，很多重要的信息就會默默的丟失了。<br/><br/>只對本地進行監聽。所有syslog信息會被轉發給“docker logs”。 |\n| logrotate | 定期轉存和壓縮日誌。 |\n| SSH服務 | 允許你很容易的登錄到容器中進行[查詢或管理](#login_ssh)操作。<br/><br/>_SSH**默認是禁用**的，這也是baseimage-docker爲此目的提供的唯一方法。其它方法需要通過[docker exec](#login_docker_exec)。由於`docker exec`同時帶來了幾個需要注意的問題，SSH同時也提供了一個可替換的方法。_<br/><br/>密碼和challenge-response認證方式默認是禁用的。只有key認證通過之後才能夠開啓。 |\n| cron | 爲了保證cron任務能夠工作，必須運行cron後臺行程。 |\n| [runit](http://smarden.org/runit/) | 替換Ubuntu的Upstart。用於服務監控和管理。比SysV init更容易使用，同時當這些服務崩潰之後，支持後臺行程自動重啓。比Upstart更易使用，更加的輕量級。 |\n| `setuser` | 使用其它賬戶運行命令的工具。比`su`更容易使用，比使用`sudo`有那麼一點優勢，跟`chpst`不同，這個工具需要正確的設置`$HOME`。像`/sbin/setuser`這樣。 |\nBaseimage-docker非常的輕量級：僅僅佔用6MB內存。\n\n<a name=\"docker_single_process\"></a>\n### 等等,我認爲Docker在一個容器中就運行一個行程嗎?\n絕對不是這樣的. 在一個docker容器中,運行多個行程也是很好的. 事實上,沒有什麼技術原因限制你只運行一個行程,運行很多的行程,只會把容器中系統的基本功能搞的更亂,比如syslog.\n\nBaseimage-docker *鼓勵* 通過runit來運行多行程.\n\n<a name=\"inspecting\"></a>\n## 檢測一下baseimage-docker\n\n要檢測鏡像,執行下面的命令:\n\n    docker run --rm -t -i phusion/baseimage:<VERSION> /sbin/my_init -- bash -l\n\n`<VERSION>` 是[baseimage-docker的版本號](https://github.com/phusion/baseimage-docker/blob/master/Changelog.md).\n\n你不用手動去下載任何文件.上面的命令會自動從docker倉庫下載baseimage-docker鏡像.\n\n<a name=\"using\"></a>\n## 使用baseimage-docker作爲基礎鏡像\n\n<a name=\"getting_started\"></a>\n### 入門指南\n\nThe image is called `phusion/baseimage`, and is available on the Docker registry.\n鏡像名字叫`phusion/baseimage`,在Docker倉庫上也是可用的.\n\n下面的這個是一個Dockerfile的模板.\n\n\t# 使用phusion/baseimage作爲基礎鏡像,去構建你自己的鏡像,需要下載一個明確的版本,千萬不要使用`latest`.\n\t# 查看https://github.com/phusion/baseimage-docker/blob/master/Changelog.md,可用看到版本的列表.\n\tFROM phusion/baseimage:<VERSION>\n\t\n\t# 設置正確的環境變數.\n\tENV HOME /root\n\t\n\t# 生成SSH keys,baseimage-docker不包含任何的key,所以需要你自己生成.你也可以註釋掉這句命令,系統在啓動過程中,會生成一個.\n\tRUN /etc/my_init.d/00_regen_ssh_host_keys.sh\n\t\n\t# 初始化baseimage-docker系統\n\tCMD [\"/sbin/my_init\"]\n\t\n\t# 這裏可以放置你自己需要構建的命令\n\t\n\t# 當完成後,清除APT.\n\tRUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n\n<a name=\"adding_additional_daemons\"></a>\n### 增加後臺行程\n\n你可以通過runit工具向你的鏡像中添加後臺行程(例如:你自己的某些應用).你需要編寫一個運行你需要的後臺行程的腳本就可以了,runit工具會保證它的正常運行,如果行程死掉,runit也會重啓它的.\n\n腳本的名稱必須是`run`,必須是可以運行的,它需要放到`/etc/service/<NAME>`.\n\n這裏有一個例子,向你展示如果運行memcached服務的.\n\n\t### memcached.sh(確定文件的權限是chmod +x):\n\t#!/bin/sh\n\t# `/sbin/setuser memcache` 指定一個`memcache`用戶來運行命令.如果你忽略了這部分,就會使用root用戶執行.\n\texec /sbin/setuser memcache /usr/bin/memcached >>/var/log/memcached.log 2>&1\n\t\n\t### 在Dockerfile中:\n    RUN mkdir /etc/service/memcached\n    COPY memcached.sh /etc/service/memcached/run\n\n注意腳本必須運行在後臺的,**不能讓他們行程進行daemonize/fork**.通常,後臺行程會提供一個標誌位或者配置文件.\n\n<a name=\"running_startup_scripts\"></a>\n### 在容器啓動的時候,運行腳本.\n\nbaseimage-docker的初始化腳本 `/sbin/my_init`,在啓動的時候行程運行,按照下面的順序:\n\n * 如果`/etc/my_init.d`存在,則按照字母順序執行腳本.\n * 如果`/etc/rc.local`存在,則執行裏面的腳本.\n\n所有的腳本都是正確退出的,例如:退出的code是0.如果有任何腳本以非0的code退出,啓動就會失敗.\n\n下面的例子向你展示了怎麼添加一個啓動腳本.這個腳本很簡單的記錄的一個系統啓動時間,將啓動時間記錄到/tmp/boottime.txt.\n\n    ### 在 logtime.sh (文件權限chmod +x):\n    #!/bin/sh\n    date > /tmp/boottime.txt\n\n    ### 在 Dockerfile中:\n    RUN mkdir -p /etc/my_init.d\n    COPY logtime.sh /etc/my_init.d/logtime.sh\n\n\n<a name=\"environment_variables\"></a>\n### 環境變數\n\n如果你使用`/sbin/my_init`作爲主容器命令,那麼通過`docker run --env`或者在Dockerfile文件中設置的`ENV`環境變數,都會被`my_init`讀取.\n\n * 在Unix系統中,環境變數都會被子行程給繼承.這就意味着,子行程不可能修改環境變數或者修改其他行程的環境變數.\n * 由於上面提到的一點,這裏沒有一個可以爲所有應用和服務集中定義環境的地方.Debian提供了一個`/etc/environment` 文件,解決一些問題.\n * 某些服務更改環境變數是爲了給子行程使用.Nginx有這樣的一個例子:它移除了所有的環境變數,除非你通過`env`進行了配置,明確了某些是保留的.如果你部署了任何應用在Nginx鏡像(例如:使用[passenger-docker](https://github.com/phusion/passenger-docker)鏡像或者使用Phusion Passenger作爲你的鏡像.),那麼你通過Docker,你不會看到任何環境變數.\n \n\n`my_init`提供了一個辦法來解決這些問題.\n\n<a name=\"envvar_central_definition\"></a>\n#### 集中定義你的環境變數\n\n在啓動的時候,在執行[startup scripts](#running_startup_scripts),`my_init`會從`/etc/container_environment`導入環境變數.這個文件夾下面,包含的文件,文件被命名爲環境變數的名字.文件內容就是環境變數的值.這個文件夾是因此是一個集中定義你的環境變數的好地方,它會繼承到所有啓動項目和Runit管理的服務中.\n\n給個例子,在你的dockerfile如何定義一個環境變數:\n\n    RUN echo Apachai Hopachai > /etc/container_environment/MY_NAME\n\n你可以按照下面這樣驗證:\n\n    $ docker run -t -i <YOUR_NAME_IMAGE> /sbin/my_init -- bash -l\n    ...\n    *** Running bash -l...\n    # echo $MY_NAME\n    Apachai Hopachai\n\n**換行處理**\n\n如果你觀察仔細一點,你會注意到'echo'命令,實際上在它是在新行打印出來的.爲什麼$MY_NAME沒有包含在一行呢? 因爲`my_init`在尾部有個換行字符.如果你打算讓你的值包含一個新行,你需要增*另外*一個新字符,像這樣:\n\n    RUN echo -e \"Apachai Hopachai\\n\" > /etc/container_environment/MY_NAME\n\n<a name=\"envvar_dumps\"></a>\n#### 環境變數存儲\n\n上面提到集中定義環境變數,它不會從子服務行程改變父服務行程或者重置環境變數.而且,`my_init`也會很容易的讓你查詢到原始的環境變數是什麼.\n\n在啓動的時候,`/etc/container_environment`, `my_init`中的變數會存儲起來,並且導入到環境變數中,例如一下的格式:\n\n * `/etc/container_environment`\n * `/etc/container_environment.sh`- 一個bash存儲的環境變數格式.你可以從這個命令中得到base格式的文件.\n * `/etc/container_environment.json` - 一個json格式存儲的環境變數格式.\n\n多種格式可以讓你不管採用什麼語言/apps都可以很容易使用環境變數.\n\n這裏有個例子,展示怎麼使用:\n\n    $ docker run -t -i \\\n      --env FOO=bar --env HELLO='my beautiful world' \\\n      phusion/baseimage:<VERSION> /sbin/my_init -- \\\n      bash -l\n    ...\n    *** Running bash -l...\n    # ls /etc/container_environment\n    FOO  HELLO  HOME  HOSTNAME  PATH  TERM  container\n    # cat /etc/container_environment/HELLO; echo\n    my beautiful world\n    # cat /etc/container_environment.json; echo\n    {\"TERM\": \"xterm\", \"container\": \"lxc\", \"HOSTNAME\": \"f45449f06950\", \"HOME\": \"/root\", \"PATH\": \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"FOO\": \"bar\", \"HELLO\": \"my beautiful world\"}\n    # source /etc/container_environment.sh\n    # echo $HELLO\n    my beautiful world\n\n<a name=\"modifying_envvars\"></a>\n#### 修改環境變數\n\n通過修改`/etc/container_environment`這個文件,很有可能修改了`my_init`中的環境變數.之後,每次`my_init`啓動[啓動腳本](#running_startup_scripts),就會重置掉我們自己`/etc/container_environment`中的環境變數,也就會導致`container_environment.sh`和`container_environment.json`重新存儲.\n\n但是記住這些:\n\n * 修改`container_environment.sh` 和 `container_environment.json`是沒有效果的.\n * Runit 的服務是不能像這樣修改環境變數的.`my_init`運行的時候,只對`/etc/container_environment`中的修改是生效的.\n\n<a name=\"envvar_security\"></a>\n#### 安全\n\n因爲環境變數可能包含敏感信息, `/etc/container_environment`和它的bash文件和JSON文件,默認都是root,都是可以被`docker_env`羣組可以訪問的(所以任何用戶只要添加到羣組中,都可以自動的獲取這些信息).\n\n如果你確定你的環境變數中沒有什麼敏感信息,那麼你可以放鬆管理權限,將文件夾和文件分配下面的權限:\n\n    RUN chmod 755 /etc/container_environment\n    RUN chmod 644 /etc/container_environment.sh /etc/container_environment.json\n\n<a name=\"workaroud_modifying_etc_hosts\"></a>\n### 解決Docker沒有辦法解決的/etc/hosts的問題\n\n當前是沒有辦法在docker容器中修改`/etc/hosts`,這個是因爲[Docker bug 2267](https://github.com/dotcloud/docker/issues/2267).Baseimage-docker包含了解決這個問題的辦法,你必須明白是怎麼修改的.\n\n修改的辦法包含在系統庫中的` libnss_files.so.2`文件,這個文件使用`/etc/workaround-docker-2267/hosts`來代替系統使用`/etc/hosts`.如果需要修改`/etc/hosts`,你只要修改`/etc/workaround-docker-2267/hosts`就可以了.\n\n增加這個修改到你的Dockerfile.下面的命令修改了文件`libnss_files.so.2`.\n\n    RUN /usr/bin/workaround-docker-2267\n\n(其實你不用在Dockerfile文件中運行這個命令,你可以在容器中運行一個shell就可以了.)\n\n驗證一下它是否生效了,[在你的容器中打開一個shell](#inspecting),修改`/etc/workaround-docker-2267/hosts`,檢查一下是否生效了:\n\n    bash# echo 127.0.0.1 my-test-domain.com >> /etc/workaround-docker-2267/hosts\n    bash# ping my-test-domain.com\n    ...should ping 127.0.0.1...\n\n**注意apt-get升級:** 如果Ubuntu升級,就有可能將`libnss_files.so.2`覆蓋掉,那麼修改就會失效.你必須重新運行`/usr/bin/workaround-docker-2267`.爲了安全一點,你應該在運行`apt-get upgrade`之後,運行一下這個命令.\n\n<a name=\"disabling_ssh\"></a>\n### 禁用SSH\nBaseimage-docker默認是支持SSH的,所以可以[使用SSH](#login_ssh)來[管理你的容器](#container_administration).萬一你不想支持SSH,你可以只要禁用它:\n\n    RUN rm -rf /etc/service/sshd /etc/my_init.d/00_regen_ssh_host_keys.sh\n\n<a name=\"container_administration\"></a>\n## 容器管理\n\n一個優秀的docker想法,就是docker是一個無狀態的,容易啓動的容器,就想一個黑盒子.然而,你可能遇到某種情況,需要登錄到容器,或者運行命令在容器中.或者爲了開發,需要查看或者debug的目的.這章就給你講解怎麼管理容器.\n\n\n<a name=\"oneshot\"></a>\n### 在一個新容器中運行一個一閃而過的命令\n\n_**備註:** 這章講解怎麼在一個-新-容器中運行命令.要在一個存在的容器中運行命令,請查看[在一個存在的容器中,運行一個命令](#run_inside_existing_container)._\n\n正常情況下,當你創建了一個新容器,爲了在容器中運行一個單獨的命令,而且在運行之後會立即退出的,你會這樣調用docker命令:\n\n    docker run YOUR_IMAGE COMMAND ARGUMENTS...\n\n然而下面的方法初始化系統的進行是不會啓動.它是這樣的,當調用`COMMAND`的時候,重要的後臺行程,例如定時任務和系統日誌都是不運行的.同樣,子行程也是不會出現的,因爲`COMMAND`的pid是1.\n\nBaseimage-docker提供了一個靈活的方式運行只要一閃而過的命令,同時也解決了上述所說的問題.以一下的方式運行一條命令:\n\n    docker run YOUR_IMAGE /sbin/my_init -- COMMAND ARGUMENTS ...\n\n他們會按照下面的流程執行:\n\n * 運行所有的啓動文件,例如 /etc/my_init.d/* and /etc/rc.local.\n * 運行所有的runit服務\n * 運行指定的命令\n * 運行指定的命令結束之後,結束所有runit服務.\n\n例如:\n\n    $ docker run phusion/baseimage:<VERSION> /sbin/my_init -- ls\n    *** Running /etc/my_init.d/00_regen_ssh_host_keys.sh...\n    No SSH host key available. Generating one...\n    Creating SSH2 RSA key; this may take some time ...\n    Creating SSH2 DSA key; this may take some time ...\n    Creating SSH2 ECDSA key; this may take some time ...\n    *** Running /etc/rc.local...\n    *** Booting runit daemon...\n    *** Runit started as PID 80\n    *** Running ls...\n    bin  boot  dev  etc  home  image  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var\n    *** ls exited with exit code 0.\n    *** Shutting down runit daemon (PID 80)...\n    *** Killing all processes...\n\n你會發現默認的啓動的流程太負責.或者你不希望執行啓動文件.你可以自定義所有通過給`my_init`增加參數.調用`docker run YOUR_IMAGE /sbin/my_init --help`可以看到幫助信息.\n\n例如上面運行`ls`命令,同時要求不運行啓動腳本,減少信息打印,運行runit所有命令.\n\n    $ docker run phusion/baseimage:<VERSION> /sbin/my_init --skip-startup-files --quiet -- ls\n    bin  boot  dev  etc  home  image  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var\n\n<a name=\"run_inside_existing_container\"></a>\n### 在一個已經運行的容器中,運行一條命令\n\n這裏有兩種辦法去在一個已經運行的容器中運行命令.\n\n * 通過`nseneter`工具.這個工具用於Linux內核調用在內嵌容器中運行命令.可以查看[通過`nsenter`,登錄容器或者在容器內執行命令](#login_nsenter).\n * 通過SSH.這種辦法需要在容器中運行ssh服務,而且需要你創建自己的sshkey.可以查看[通過`ssh`,登錄容器或者在容器內執行命令](#login_ssh).\n\n兩種方法都是他們各自的優點和確定,你可以學習他們各自的章節來了他們.\n\n<a name=\"login_nsenter\"></a>\n### 通過`nsenter`,登錄容器或者在容器內執行命令\n\n你可以使用在docker主機上面的`nsenter`工具,來登錄任何基於baseimage-docker的docker容器.你可以使用它在你的容器中運行命令.\n\n這裏有個和[通過`ssh`,登錄容器或者在容器內執行命令](#login_ssh)的優缺點的比較:\n\n * 優點\n   * 不需要在容器中運行ssh服務.\n   * 不需要ssh key.\n   * 運行在任何容器上,甚至不是基於baseimage-docker的容器.\n * 缺點\n   * 通過`nsenter`運行的行程會和正常運行稍微有不同.例如,他們不同結束掉在容器中正常運行的行程.這適用於所有的子行程.\n   * 如果`nsenter`行程被其他命令(如`kill`命令)給終止,然後由nsenter所執行的命令,是*不會*被結束的.你將不得不手動清理.(備註:終端控制命令像Ctrl-C *會* 清理所有的子行程,因爲終端信號被髮送到所有流程的終端會話)\n   * 需要學習新工具.\n   * 需要在docker主機上面提供root權限.\n   * 需要在docker主機上面是可用的.在寫這篇文字的時候(2014年7月),大多數linux發行版沒有加載它.然而,baseimage-docker提供了預編譯的二進制文件,允許你通過[docker-bash](#docker_bash)工具,來很容易的使用它.\n   * 不可能沒有登錄到docker主機,就登錄到docker容器中.(也就是說,你必須登錄到docker主機,通過docker主機登錄到容器.)\n\n<a name=\"nsenter_usage\"></a>\n#### 用例\n\n第一,確定`nsenter`已經安裝了.在寫這篇文字的時候(2014年7月),大多數linux發行版沒有加載它.然而,baseimage-docker提供了預編譯的二進制文件,允許你通過[docker-bash](#docker_bash)工具,讓任何人都可以使用.\n\n接着,啓動一個容器.\n\n    docker run YOUR_IMAGE\n\n找出你剛纔運行容器的`ID`.\n\n    docker ps\n\n一旦擁有容器的id,找到運行容器的主要行程額`PID`.\n\n    docker inspect -f \"{{ .State.Pid }}\" <ID>\n\n現在你有的容器的主行程的PID,就可以使用`nsenter`來登錄容器,或者在容器裏面執行命令:\n\n    # 登錄容器\n    nsenter --target <MAIN PROCESS PID> --mount --uts --ipc --net --pid bash -l\n\n    # 在容器中執行命令\n    nsenter --target <MAIN PROCESS PID> --mount --uts --ipc --net --pid -- echo hello world\n\n<a name=\"docker_bash\"></a>\n#### `docker-bash`工具\n\n查找一個容器的主要行程的PID和輸入這麼長的nsenter命令很快會變得乏味無論.幸運的是,我們提供了一個`docker-bash` 工具,它可以自動完成只要的工具.這個工具是運行在*docker主機*上面,不是在docker容器中.\n\n該工具還附帶了一個預編譯的二進制`nsenter`,這樣你不需要自己安裝`nsenter`了.`docker-bash`是很簡單的使用的.\n\n首先,在docker主機上安裝這個工具:\n\n    curl --fail -L -O https://github.com/phusion/baseimage-docker/archive/master.tar.gz && \\\n    tar xzf master.tar.gz && \\\n    sudo ./baseimage-docker-master/install-tools.sh\n\n運行這個工具登錄到容器中:\n\n    docker-bash YOUR-CONTAINER-ID\n\n你可以通過`docker ps`來查找你的容器ID.\n\n默認,`docker-bash`會打開一個bash 回話.你可以告訴運行什麼命令,之後就會自動退出:\n\n    docker-bash YOUR-CONTAINER-ID echo hello world\n\n<a name=\"login_ssh\"></a>\n### 通過`ssh`,登錄容器或者在容器內執行命令\n\n你可以使用ssh來登錄任何基於baseimage-docker的容器.你可以使用它在容器中執行命令.\n\n這裏有個和[通過`nsenter`,登錄容器或者在容器內執行命令](#login_nsenter)的優缺點的比較:\n\n * 優點\n   * 不像`nsenter`一樣,運行在docker主機上面.幾乎每個人都會安裝一個ssh客戶端.\n   * 不想使用`nsenter`,運行的行程和正在的行程會不一樣.\n   * 不需要docker主機提供root權限.\n   * 運行你讓用戶登錄到容器,而不需要登錄到docker主機.然而,默認這是不啓用的,因爲baseimage-docker默認不是開放ssh服務的.\n * 缺點\n   * 需要設置ssh key.然而,baseimage-docker會提供一中辦法,會讓key的生成會很容易.閱讀更多信息.\n\n第一件事情,就是你需要確定你在容器中已經安裝設置了ssh key. 默認是不安裝任何key的,所以任何人都無法登錄.爲了方便的原因,我們提供了一個[已經生成的key](https://github.com/phusion/baseimage-docker/blob/master/image/services/sshd/keys/insecure_key) [(PuTTY format)](https://github.com/phusion/baseimage-docker/blob/master/image/services/sshd/keys/insecure_key.ppk),爲了讓你使用方便.然後,請注意這個key僅僅是爲方便.他沒有任何安全性,因爲它的key是在網絡上提供的.**在生產環境,你必須使用你自己的key.**\n\n\n<a name=\"using_the_insecure_key_for_one_container_only\"></a>\n#### 在容器中使用key\n\n你可以臨時的使用key僅僅作爲容器使用.這就以爲這key是安裝在容器上的.如果你使用`docker stop`和`docker start`控制容器,那麼key是在容器中,但是如果你使用`docker run`開啓一個新容器,那麼這個容器是不包含key的.\n\n啓動新容器包含key`--enable-insecure-key`:\n\n    docker run YOUR_IMAGE /sbin/my_init --enable-insecure-key\n\n找出你的剛纔運行的容器的ID:\n\n    docker ps\n\n一旦你擁有容器的ID,就能找到容器使用的IP地址:\n\n    docker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\n\n現在你有得了IP地址,你就看通過SSH來登錄容器,或者在容器中執行命令了:\n\n    # 下載key\n    curl -o insecure_key -fSL https://github.com/phusion/baseimage-docker/raw/master/image/services/sshd/keys/insecure_key\n    chmod 600 insecure_key\n\n    # 登錄容器\n    ssh -i insecure_key root@<IP address>\n\n    # 在容器中執行命令\n    ssh -i insecure_key root@<IP address> echo hello world\n\n<a name=\"enabling_the_insecure_key_permanently\"></a>\n#### 支持一個長久的key\n\n在一個長久存在的鏡像中支持一個key是很可能的.一般是不推薦這麼做,但是對於臨時開始或者做demo演示,對安全要求不高,還是很合適的.\n\n編輯你的dockerfile,來安裝永久的key:\n\n    RUN /usr/sbin/enable_insecure_key\n\n在容器中怎麼使用,同[在容器中使用key](#using_the_insecure_key_for_one_container_only)的章節說的一樣.\n\n<a name=\"using_your_own_key\"></a>\n#### 使用你自己的key\n\n編輯你的dockerfile,來安裝ssh public key:\n\n    ## 安裝你自己的public key.\n    COPY your_key.pub /tmp/your_key.pub\n    RUN cat /tmp/your_key.pub >> /root/.ssh/authorized_keys && rm -f /tmp/your_key.pub\n\n重新創建你的鏡像.一旦你創建成功,啓動基於這個鏡像的容器.\n\n    docker run your-image-name\n\n找出你的剛纔運行的容器的ID:\n\n    docker ps\n\n一旦你擁有容器的ID,就能找到容器使用的IP地址:\n\n    docker inspect -f \"{{ .NetworkSettings.IPAddress }}\" <ID>\n\n現在你有得了IP地址,你就看通過SSH來登錄容器,或者在容器中執行命令了:\n\n    # 登錄容器\n    ssh -i /path-to/your_key root@<IP address>\n\n    # 在容器中執行命令\n    ssh -i /path-to/your_key root@<IP address> echo hello world\n\n<a name=\"docker_ssh\"></a>\n#### `docker-ssh`工具\n\n找到容器的IP,運行ssh命令,很快會變得乏味無聊.幸運的是,我們提供了一個`docker-ssh`,可以自動完成這些事情.這個工具是運行在*Docker 主機*上的,不是安裝在docker容器中的.\n\n首先,在docker主機上面安裝這個工具.\n\n    curl --fail -L -O https://github.com/phusion/baseimage-docker/archive/master.tar.gz && \\\n    tar xzf master.tar.gz && \\\n    sudo ./baseimage-docker-master/install-tools.sh\n\n使用這個工具通過ssh登錄容器:\n\n    docker-ssh YOUR-CONTAINER-ID\n\n你可以使用`docker ps`找到`YOUR-CONTAINER-ID`.\n\n默認,`docker-bash`會打開一個bash 回話.你可以告訴運行什麼命令,之後就會自動退出:\n\n    docker-ssh YOUR-CONTAINER-ID echo hello world\n\n<a name=\"building\"></a>\n## 創建你自己的鏡像\n\n如果某些原因,你需要創建你自己的鏡像,來替代從docker倉庫下載鏡像,可以按照的說明.\n\n克隆倉庫:\n\n    git clone https://github.com/phusion/baseimage-docker.git\n    cd baseimage-docker\n\n創建一個包含docker在的虛擬機.你可以使用我們提供的Vagrantfile.\n\n    vagrant up\n    vagrant ssh\n    cd /vagrant\n\n編譯鏡像:\n\n    make build\n\n如果你想把創建的鏡像名字,叫其他名字,通過`NAME`變數可以設置:\n\n    make build NAME=joe/baseimage\n\n<a name=\"conclusion\"></a>\n## 總結\n\n * Using baseimage-docker? [Tweet about us](https://twitter.com/share) or [follow us on Twitter](https://twitter.com/phusion_nl).\n * Having problems? Want to participate in development? Please post a message at [the discussion forum](https://groups.google.com/d/forum/passenger-docker).\n * Looking for a more complete base image, one that is ideal for Ruby, Python, Node.js and Meteor web apps? Take a look at [passenger-docker](https://github.com/phusion/passenger-docker).\n\n[<img src=\"http://www.phusion.nl/assets/logo.png\">](http://www.phusion.nl/)\n\nPlease enjoy baseimage-docker, a product by [Phusion](http://www.phusion.nl/). :-)\n"
        },
        {
          "name": "Vagrantfile",
          "type": "blob",
          "size": 2.9921875,
          "content": "# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# All Vagrant configuration is done below. The \"2\" in Vagrant.configure\n# configures the configuration version (we support older styles for\n# backwards compatibility). Please don't change it unless you know what\n# you're doing.\nVagrant.configure(\"2\") do |config|\n\t# The most common configuration options are documented and commented below.\n\t# For a complete reference, please see the online documentation at\n\t# https://docs.vagrantup.com.\n\n\t# Every Vagrant development environment requires a box. You can search for\n\t# boxes at https://atlas.hashicorp.com/search.\n\tconfig.vm.box = \"ubuntu/noble64\"\n\tconfig.disksize.size = '50GB'\n\n\t# Disable automatic box update checking. If you disable this, then\n\t# boxes will only be checked for updates when the user runs\n\t# `vagrant box outdated`. This is not recommended.\n\t# config.vm.box_check_update = false\n\n\t# Create a forwarded port mapping which allows access to a specific port\n\t# within the machine from a port on the host machine. In the example below,\n\t# accessing \"localhost:8080\" will access port 80 on the guest machine.\n\t# config.vm.network \"forwarded_port\", guest: 80, host: 8080\n\n\t# Create a private network, which allows host-only access to the machine\n\t# using a specific IP.\n\t# config.vm.network \"private_network\", ip: \"192.168.33.10\"\n\n\t# Create a public network, which generally matched to bridged network.\n\t# Bridged networks make the machine appear as another physical device on\n\t# your network.\n\t# config.vm.network \"public_network\"\n\n\t# Share an additional folder to the guest VM. The first argument is\n\t# the path on the host to the actual folder. The second argument is\n\t# the path on the guest to mount the folder. And the optional third\n\t# argument is a set of non-required options.\n\t# config.vm.synced_folder \"../data\", \"/vagrant_data\"\n\n\t# Provider-specific configuration so you can fine-tune various\n\t# backing providers for Vagrant. These expose provider-specific options.\n\t# Example for VirtualBox:\n\t#\n\t# config.vm.provider \"virtualbox\" do |vb|\n\t#   # Display the VirtualBox GUI when booting the machine\n\t#   vb.gui = true\n\t#\n\t#   # Customize the amount of memory on the VM:\n\t#   vb.memory = \"1024\"\n\t# end\n\t#\n\t# View the documentation for the provider you are using for more\n\t# information on available options.\n\n\t# Define a Vagrant Push strategy for pushing to Atlas. Other push strategies\n\t# such as FTP and Heroku are also available. See the documentation at\n\t# https://docs.vagrantup.com/v2/push/atlas.html for more information.\n\t# config.push.define \"atlas\" do |push|\n\t#   push.app = \"YOUR_ATLAS_USERNAME/YOUR_APPLICATION_NAME\"\n\t# end\n\n\t# Enable provisioning with a shell script. Additional provisioners such as\n\t# Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n\t# documentation for more information about their specific syntax and use.\n\t# config.vm.provision \"shell\", inline: <<-SHELL\n\t#   apt-get update\n\t#   apt-get install -y apache2\n\t# SHELL\n\tconfig.vm.provision :shell,\n\t  path: \"vagrant-libs/bootstrap.sh\"\n  end\n"
        },
        {
          "name": "build-multiarch.sh",
          "type": "blob",
          "size": 0.607421875,
          "content": "#!/bin/bash\nset -e\nset -x\n\nfor arch in $ARCHS; do\n    docker pull $NAME:$VERSION-${arch}\n\n    if [[ $TAG_LATEST != 'true' ]]; then \n        docker manifest create --amend $NAME:$VERSION $NAME:$VERSION-${arch}\n        docker manifest annotate $NAME:$VERSION $NAME:$VERSION-${arch} --arch ${arch}\n    else\n        docker manifest create --amend $NAME:latest $NAME:$VERSION-${arch}\n        docker manifest annotate $NAME:latest $NAME:$VERSION-${arch} --arch ${arch}\n    fi\ndone\n\necho \"Push manifests\"\nif [[ $TAG_LATEST != 'true' ]]; then \n    docker manifest push $NAME:$VERSION\nelse\n    docker manifest push $NAME:latest\nfi\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.6357421875,
          "content": "#!/bin/bash\nset -e\n\n# # Prepare qemu\n# if [ '$QEMU_ARCH' != 'amd64' ]; then\n#     # docker run --rm --privileged multiarch/qemu-user-static:register --reset\n# fi\n\n# Get qemu package\necho \"Getting qemu package for $QEMU_ARCH\"\n\n# Fake qemu for amd64 builds to avoid breaking COPY in Dockerfile\nif [[ $QEMU_ARCH == \"amd64\" ]]; then\n\ttouch x86_64_qemu-\"$QEMU_ARCH\"-static.tar.gz\n\tmv x86_64_qemu-${QEMU_ARCH}-static.tar.gz image\nelse\n\tcurl -L -o x86_64_qemu-\"$QEMU_ARCH\"-static.tar.gz https://github.com/multiarch/qemu-user-static/releases/download/\"$QEMU_VERSION\"/x86_64_qemu-\"$QEMU_ARCH\"-static.tar.gz\n\tmv x86_64_qemu-${QEMU_ARCH}-static.tar.gz image\nfi\n"
        },
        {
          "name": "image",
          "type": "tree",
          "content": null
        },
        {
          "name": "install-tools.sh",
          "type": "blob",
          "size": 0.3447265625,
          "content": "#!/bin/sh\nset -e\ndir=`dirname \"$0\"`\ncd \"$dir\"\n\nset -x\ncp tools/docker-bash /usr/local/bin/\ncp tools/docker-ssh /usr/local/bin/\ncp tools/baseimage-docker-nsenter /usr/local/bin/\nmkdir -p /usr/local/share/baseimage-docker\ncp image/services/sshd/keys/insecure_key /usr/local/share/baseimage-docker/\nchmod 644 /usr/local/share/baseimage-docker/insecure_key\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "vagrant-libs",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}