{
  "metadata": {
    "timestamp": 1736568881482,
    "page": 84,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dylanaraps/pure-sh-bible",
      "stars": 6530,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2019 Dylan Araps\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 24.966796875,
          "content": "<p align=\"center\"><b>Also see: <a href=\"https://github.com/dylanaraps/pure-bash-bible\">pure bash bible (ðŸ“– A collection of pure bash alternatives to external processes).</a></b></p>\n\n<br>\n\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/6799467/65238742-e0ba4c80-dacc-11e9-9c2a-3dd20a6f138d.png\" width=\"300px\"></p>\n<h1 align=\"center\">pure sh bible</h1> <p\nalign=\"center\">A collection of pure POSIX sh alternatives to external processes.</p><br><br>\n\n<img src=\"https://user-images.githubusercontent.com/6799467/65239338-4eb34380-dace-11e9-8fe2-7b5e28f1bced.png\" width=\"40%\" align=\"right\">\n\nThe goal of this book is to document commonly-known and lesser-known methods of doing various tasks using only built-in POSIX `sh` features. Using the snippets from this bible can help remove unneeded dependencies from scripts and in most cases make them faster. I came across these tips and discovered a few while developing [KISS Linux](https://kisslinux.xyz/) and other smaller projects.\n\nThe snippets below are all linted using `shellcheck`.\n\nSee something incorrectly described, buggy or outright wrong? Open an issue or send a pull request. If the bible is missing something, open an issue and a solution will be found.\n\n- Leanpub book: (*coming soon*)\n- Buy me a coffee: <a href=\"https://www.patreon.com/dyla\"><img src=\"https://img.shields.io/badge/donate-patreon-yellow.svg\"> </a>\n\n<br>\n\n# Table of Contents\n\n<!-- vim-markdown-toc GFM -->\n\n* [STRINGS](#strings)\n    * [Strip pattern from start of string](#strip-pattern-from-start-of-string)\n    * [Strip pattern from end of string](#strip-pattern-from-end-of-string)\n    * [Trim leading and trailing white-space from string](#trim-leading-and-trailing-white-space-from-string)\n    * [Trim all white-space from string and truncate spaces](#trim-all-white-space-from-string-and-truncate-spaces)\n    * [Check if string contains a sub-string](#check-if-string-contains-a-sub-string)\n    * [Check if string starts with sub-string](#check-if-string-starts-with-sub-string)\n    * [Check if string ends with sub-string](#check-if-string-ends-with-sub-string)\n    * [Split a string on a delimiter](#split-a-string-on-a-delimiter)\n    * [Trim quotes from a string](#trim-quotes-from-a-string)\n* [FILES](#files)\n    * [Parsing a `key=val` file.](#parsing-a-keyval-file)\n    * [Get the first N lines of a file](#get-the-first-n-lines-of-a-file)\n    * [Get the number of lines in a file](#get-the-number-of-lines-in-a-file)\n    * [Count files or directories in directory](#count-files-or-directories-in-directory)\n    * [Create an empty file](#create-an-empty-file)\n* [FILE PATHS](#file-paths)\n    * [Get the directory name of a file path](#get-the-directory-name-of-a-file-path)\n    * [Get the base-name of a file path](#get-the-base-name-of-a-file-path)\n* [LOOPS](#loops)\n    * [Loop over a (*small*) range of numbers](#loop-over-a-small-range-of-numbers)\n    * [Loop over a variable range of numbers](#loop-over-a-variable-range-of-numbers)\n    * [Loop over the contents of a file](#loop-over-the-contents-of-a-file)\n    * [Loop over files and directories](#loop-over-files-and-directories)\n* [VARIABLES](#variables)\n    * [Name a variable based on another variable](#name-a-variable-based-on-another-variable)\n* [ESCAPE SEQUENCES](#escape-sequences)\n    * [Text Colors](#text-colors)\n    * [Text Attributes](#text-attributes)\n    * [Cursor Movement](#cursor-movement)\n    * [Erasing Text](#erasing-text)\n* [PARAMETER EXPANSION](#parameter-expansion)\n    * [Prefix and Suffix Deletion](#prefix-and-suffix-deletion)\n    * [Length](#length)\n    * [Default Value](#default-value)\n* [CONDITIONAL EXPRESSIONS](#conditional-expressions)\n    * [File Conditionals](#file-conditionals)\n    * [Variable Conditionals](#variable-conditionals)\n    * [Variable Comparisons](#variable-comparisons)\n* [ARITHMETIC OPERATORS](#arithmetic-operators)\n    * [Assignment](#assignment)\n    * [Arithmetic](#arithmetic)\n    * [Bitwise](#bitwise)\n    * [Logical](#logical)\n    * [Miscellaneous](#miscellaneous)\n* [ARITHMETIC](#arithmetic-1)\n    * [Ternary Tests](#ternary-tests)\n    * [Check if a number is a float](#check-if-a-number-is-a-float)\n    * [Check if a number is an integer](#check-if-a-number-is-an-integer)\n* [TRAPS](#traps)\n    * [Do something on script exit](#do-something-on-script-exit)\n    * [Ignore terminal interrupt (CTRL+C, SIGINT)](#ignore-terminal-interrupt-ctrlc-sigint)\n* [OBSOLETE SYNTAX](#obsolete-syntax)\n    * [Command Substitution](#command-substitution)\n* [INTERNAL AND ENVIRONMENT VARIABLES](#internal-and-environment-variables)\n    * [Open the user's preferred text editor](#open-the-users-preferred-text-editor)\n    * [Get the current working directory](#get-the-current-working-directory)\n    * [Get the PID of the current shell](#get-the-pid-of-the-current-shell)\n    * [Get the current shell options](#get-the-current-shell-options)\n* [AFTERWORD](#afterword)\n\n<!-- vim-markdown-toc -->\n\n\n# STRINGS\n\n## Strip pattern from start of string\n\n**Example Function:**\n\n```sh\nlstrip() {\n    # Usage: lstrip \"string\" \"pattern\"\n    printf '%s\\n' \"${1##$2}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ lstrip \"The Quick Brown Fox\" \"The \"\nQuick Brown Fox\n```\n\n## Strip pattern from end of string\n\n**Example Function:**\n\n```sh\nrstrip() {\n    # Usage: rstrip \"string\" \"pattern\"\n    printf '%s\\n' \"${1%%$2}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ rstrip \"The Quick Brown Fox\" \" Fox\"\nThe Quick Brown\n```\n\n## Trim leading and trailing white-space from string\n\nThis is an alternative to `sed`, `awk`, `perl` and other tools. The\nfunction below works by finding all leading and trailing white-space and\nremoving it from the start and end of the string.\n\n**Example Function:**\n\n```sh\ntrim_string() {\n    # Usage: trim_string \"   example   string    \"\n\n    # Remove all leading white-space.\n    # '${1%%[![:space:]]*}': Strip everything but leading white-space.\n    # '${1#${XXX}}': Remove the white-space from the start of the string.\n    trim=${1#${1%%[![:space:]]*}}\n\n    # Remove all trailing white-space.\n    # '${trim##*[![:space:]]}': Strip everything but trailing white-space.\n    # '${trim%${XXX}}': Remove the white-space from the end of the string.\n    trim=${trim%${trim##*[![:space:]]}}\n\n    printf '%s\\n' \"$trim\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ trim_string \"    Hello,  World    \"\nHello,  World\n\n$ name=\"   John Black  \"\n$ trim_string \"$name\"\nJohn Black\n```\n\n## Trim all white-space from string and truncate spaces\n\nThis is an alternative to `sed`, `awk`, `perl` and other tools. The\nfunction below works by abusing word splitting to create a new string\nwithout leading/trailing white-space and with truncated spaces.\n\n**Example Function:**\n\n```sh\n# shellcheck disable=SC2086,SC2048\ntrim_all() {\n    # Usage: trim_all \"   example   string    \"\n\n    # Disable globbing to make the word-splitting below safe.\n    set -f\n\n    # Set the argument list to the word-splitted string.\n    # This removes all leading/trailing white-space and reduces\n    # all instances of multiple spaces to a single (\"  \" -> \" \").\n    set -- $*\n\n    # Print the argument list as a string.\n    printf '%s\\n' \"$*\"\n\n    # Re-enable globbing.\n    set +f\n}\n```\n\n**Example Usage:**\n\n```shell\n$ trim_all \"    Hello,    World    \"\nHello, World\n\n$ name=\"   John   Black  is     my    name.    \"\n$ trim_all \"$name\"\nJohn Black is my name.\n```\n\n## Check if string contains a sub-string\n\n**Using a case statement:**\n\n```shell\ncase $var in\n    *sub_string1*)\n        # Do stuff\n    ;;\n\n    *sub_string2*)\n        # Do other stuff\n    ;;\n\n    *)\n        # Else\n    ;;\nesac\n```\n\n## Check if string starts with sub-string\n\n**Using a case statement:**\n\n```shell\ncase $var in\n    sub_string1*)\n        # Do stuff\n    ;;\n\n    sub_string2*)\n        # Do other stuff\n    ;;\n\n    *)\n        # Else\n    ;;\nesac\n```\n\n## Check if string ends with sub-string\n\n**Using a case statement:**\n\n```shell\ncase $var in\n    *sub_string1)\n        # Do stuff\n    ;;\n\n    *sub_string2)\n        # Do other stuff\n    ;;\n\n    *)\n        # Else\n    ;;\nesac\n```\n\n## Split a string on a delimiter\n\nThis is an alternative to `cut`, `awk` and other tools.\n\n**Example Function:**\n\n```sh\nsplit() {\n    # Disable globbing.\n    # This ensures that the word-splitting is safe.\n    set -f\n\n    # Store the current value of 'IFS' so we\n    # can restore it later.\n    old_ifs=$IFS\n\n    # Change the field separator to what we're\n    # splitting on.\n    IFS=$2\n\n    # Create an argument list splitting at each\n    # occurance of '$2'.\n    #\n    # This is safe to disable as it just warns against\n    # word-splitting which is the behavior we expect.\n    # shellcheck disable=2086\n    set -- $1\n\n    # Print each list value on its own line.\n    printf '%s\\n' \"$@\"\n\n    # Restore the value of 'IFS'.\n    IFS=$old_ifs\n\n    # Re-enable globbing.\n    set +f\n}\n```\n\n**Example Usage:**\n\n```shell\n$ split \"apples,oranges,pears,grapes\" \",\"\napples\noranges\npears\ngrapes\n\n$ split \"1, 2, 3, 4, 5\" \", \"\n1\n2\n3\n4\n5\n```\n\n## Trim quotes from a string\n\n**Example Function:**\n\n```sh\ntrim_quotes() {\n    # Usage: trim_quotes \"string\"\n\n    # Disable globbing.\n    # This makes the word-splitting below safe.\n    set -f\n\n    # Store the current value of 'IFS' so we\n    # can restore it later.\n    old_ifs=$IFS\n\n    # Set 'IFS' to [\"'].\n    IFS=\\\"\\'\n\n    # Create an argument list, splitting the\n    # string at [\"'].\n    #\n    # Disable this shellcheck error as it only\n    # warns about word-splitting which we expect.\n    # shellcheck disable=2086\n    set -- $1\n\n    # Set 'IFS' to blank to remove spaces left\n    # by the removal of [\"'].\n    IFS=\n\n    # Print the quote-less string.\n    printf '%s\\n' \"$*\"\n\n    # Restore the value of 'IFS'.\n    IFS=$old_ifs\n\n    # Re-enable globbing.\n    set +f\n}\n```\n\n**Example Usage:**\n\n```shell\n$ var=\"'Hello', \\\"World\\\"\"\n$ trim_quotes \"$var\"\nHello, World\n```\n\n# FILES\n\n## Parsing a `key=val` file.\n\nThis could be used to parse a simple `key=value` configuration file.\n\n```shell\n# Setting 'IFS' tells 'read' where to split the string.\nwhile IFS='=' read -r key val; do\n    # Skip over lines containing comments.\n    # (Lines starting with '#').\n    [ \"${key##\\#*}\" ] || continue\n\n    # '$key' stores the key.\n    # '$val' stores the value.\n    printf '%s: %s\\n' \"$key\" \"$val\"\n\n    # Alternatively replacing 'printf' with the following\n    # populates variables called '$key' with the value of '$val'.\n    #\n    # NOTE: I would extend this with a check to ensure 'key' is\n    #       a valid variable name.\n    # export \"$key=$val\"\n    #\n    # Example with error handling:\n    # export \"$key=$val\" 2>/dev/null ||\n    #     printf 'warning %s is not a valid variable name\\n' \"$key\"\ndone < \"file\"\n```\n\n## Get the first N lines of a file\n\nAlternative to the `head` command.\n\n**Example Function:**\n\n```sh\nhead() {\n    # Usage: head \"n\" \"file\"\n    while IFS= read -r line; do\n        printf '%s\\n' \"$line\"\n        i=$((i+1))\n        [ \"$i\" = \"$1\" ] && return\n    done < \"$2\"\n\n    # 'read' used in a loop will skip over\n    # the last line of a file if it does not contain\n    # a newline and instead contains EOF.\n    #\n    # The final line iteration is skipped as 'read'\n    # exits with '1' when it hits EOF. 'read' however,\n    # still populates the variable.\n    #\n    # This ensures that the final line is always printed\n    # if applicable.\n    [ -n \"$line\" ] && printf %s \"$line\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ head 2 ~/.bashrc\n# Prompt\nPS1='âžœ '\n\n$ head 1 ~/.bashrc\n# Prompt\n```\n\n## Get the number of lines in a file\n\nAlternative to `wc -l`.\n\n**Example Function:**\n\n```sh\nlines() {\n    # Usage: lines \"file\"\n\n    # '|| [ -n \"$line\" ]': This ensures that lines\n    # ending with EOL instead of a newline are still\n    # operated on in the loop.\n    #\n    # 'read' exits with '1' when it sees EOL and\n    # without the added test, the line isn't sent\n    # to the loop.\n    while IFS= read -r line || [ -n \"$line\" ]; do\n        lines=$((lines+1))\n    done < \"$1\"\n\n    printf '%s\\n' \"$lines\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ lines ~/.bashrc\n48\n```\n\n## Count files or directories in directory\n\nThis works by passing the output of the glob to the function and then counting the number of arguments.\n\n**Example Function:**\n\n```sh\ncount() {\n    # Usage: count /path/to/dir/*\n    #        count /path/to/dir/*/\n    [ -e \"$1\" ] \\\n        && printf '%s\\n' \"$#\" \\\n        || printf '%s\\n' 0\n}\n```\n\n**Example Usage:**\n\n```shell\n# Count all files in dir.\n$ count ~/Downloads/*\n232\n\n# Count all dirs in dir.\n$ count ~/Downloads/*/\n45\n\n# Count all jpg files in dir.\n$ count ~/Pictures/*.jpg\n64\n```\n\n## Create an empty file\n\nAlternative to `touch`.\n\n```shell\n:>file\n\n# OR (shellcheck warns for this)\n>file\n```\n\n# FILE PATHS\n\n## Get the directory name of a file path\n\nAlternative to the `dirname` command.\n\n**Example Function:**\n\n```sh\ndirname() {\n    # Usage: dirname \"path\"\n\n    # If '$1' is empty set 'dir' to '.', else '$1'.\n    dir=${1:-.}\n\n    # Strip all trailing forward-slashes '/' from\n    # the end of the string.\n    #\n    # \"${dir##*[!/]}\": Remove all non-forward-slashes\n    # from the start of the string, leaving us with only\n    # the trailing slashes.\n    # \"${dir%%\"${}\"}\": Remove the result of the above\n    # substitution (a string of forward slashes) from the\n    # end of the original string.\n    dir=${dir%%\"${dir##*[!/]}\"}\n\n    # If the variable *does not* contain any forward slashes\n    # set its value to '.'.\n    [ \"${dir##*/*}\" ] && dir=.\n\n    # Remove everything *after* the last forward-slash '/'.\n    dir=${dir%/*}\n\n    # Again, strip all trailing forward-slashes '/' from\n    # the end of the string (see above).\n    dir=${dir%%\"${dir##*[!/]}\"}\n\n    # Print the resulting string and if it is empty,\n    # print '/'.\n    printf '%s\\n' \"${dir:-/}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ dirname ~/Pictures/Wallpapers/1.jpg\n/home/black/Pictures/Wallpapers/\n\n$ dirname ~/Pictures/Downloads/\n/home/black/Pictures/\n```\n\n## Get the base-name of a file path\n\nAlternative to the `basename` command.\n\n**Example Function:**\n\n```sh\nbasename() {\n    # Usage: basename \"path\" [\"suffix\"]\n\n    # Strip all trailing forward-slashes '/' from\n    # the end of the string.\n    #\n    # \"${1##*[!/]}\": Remove all non-forward-slashes\n    # from the start of the string, leaving us with only\n    # the trailing slashes.\n    # \"${1%%\"${}\"}:  Remove the result of the above\n    # substitution (a string of forward slashes) from the\n    # end of the original string.\n    dir=${1%${1##*[!/]}}\n\n    # Remove everything before the final forward-slash '/'.\n    dir=${dir##*/}\n\n    # If a suffix was passed to the function, remove it from\n    # the end of the resulting string.\n    dir=${dir%\"$2\"}\n\n    # Print the resulting string and if it is empty,\n    # print '/'.\n    printf '%s\\n' \"${dir:-/}\"\n}\n```\n\n**Example Usage:**\n\n```shell\n$ basename ~/Pictures/Wallpapers/1.jpg\n1.jpg\n\n$ basename ~/Pictures/Wallpapers/1.jpg .jpg\n1\n\n$ basename ~/Pictures/Downloads/\nDownloads\n```\n\n# LOOPS\n\n## Loop over a (*small*) range of numbers\n\nAlternative to `seq` and only suitable for small and static number ranges. The number list can also be replaced with a list of words, variables etc.\n\n```shell\n# Loop from 0-10.\nfor i in 0 1 2 3 4 5 6 7 8 9 10; do\n    printf '%s\\n' \"$i\"\ndone\n```\n\n## Loop over a variable range of numbers\n\nAlternative to `seq`.\n\n```shell\n# Loop from var-var.\nstart=0\nend=50\n\nwhile [ \"$start\" -le \"$end\" ]; do\n    printf '%s\\n' \"$start\"\n    start=$((start+1))\ndone\n```\n\n## Loop over the contents of a file\n\n```shell\nwhile IFS= read -r line || [ -n \"$line\" ]; do\n    printf '%s\\n' \"$line\"\ndone < \"file\"\n```\n\n## Loop over files and directories\n\nDonâ€™t use `ls`.\n\n**CAVEAT:** When the glob does not match anything (empty directory or no matching files) the variable will contain the unexpanded glob. To avoid working on unexpanded globs check the existence of the file contained in the variable using the appropriate [file conditional](#file-conditionals). Be aware that symbolic links are resolved.\n\n```shell\n# Greedy example.\nfor file in *; do\n    [ -e \"$file\" ] || [ -L \"$file\" ] || continue\n    printf '%s\\n' \"$file\"\ndone\n\n# PNG files in dir.\nfor file in ~/Pictures/*.png; do\n    [ -f \"$file\" ] || continue\n    printf '%s\\n' \"$file\"\ndone\n\n# Iterate over directories.\nfor dir in ~/Downloads/*/; do\n    [ -d \"$dir\" ] || continue\n    printf '%s\\n' \"$dir\"\ndone\n```\n\n# VARIABLES\n\n## Name and access a variable based on another variable\n\n```shell\n$ var=\"world\"\n$ eval \"hello_$var=value\"\n$ eval printf '%s\\n' \"\\$hello_$var\"\nvalue\n```\n\n# ESCAPE SEQUENCES\n\nContrary to popular belief, there is no issue in utilizing raw escape sequences. Using `tput` abstracts the same ANSI sequences as if printed manually. Worse still, `tput` is not actually portable. There are a number of `tput` variants each with different commands and syntaxes (*try `tput setaf 3` on a FreeBSD system*). Raw sequences are fine.\n\n## Text Colors\n\n**NOTE:** Sequences requiring RGB values only work in True-Color Terminal Emulators.\n\n| Sequence | What does it do? | Value |\n| -------- | ---------------- | ----- |\n| `\\033[38;5;<NUM>m` | Set text foreground color. | `0-255`\n| `\\033[48;5;<NUM>m` | Set text background color. | `0-255`\n| `\\033[38;2;<R>;<G>;<B>m` | Set text foreground color to RGB color. | `R`, `G`, `B`\n| `\\033[48;2;<R>;<G>;<B>m` | Set text background color to RGB color. | `R`, `G`, `B`\n\n## Text Attributes\n\n| Sequence | What does it do? |\n| -------- | ---------------- |\n| `\\033[m`  | Reset text formatting and colors.\n| `\\033[1m` | Bold text. |\n| `\\033[2m` | Faint text. |\n| `\\033[3m` | Italic text. |\n| `\\033[4m` | Underline text. |\n| `\\033[5m` | Slow blink. |\n| `\\033[7m` | Swap foreground and background colors. |\n| `\\033[8m` | Hidden text. |\n| `\\033[9m` | Strike-through text. |\n\n\n## Cursor Movement\n\n| Sequence | What does it do? | Value |\n| -------- | ---------------- | ----- |\n| `\\033[<LINE>;<COLUMN>H` | Move cursor to absolute position. | `line`, `column`\n| `\\033[H` | Move cursor to home position (`0,0`). |\n| `\\033[<NUM>A` | Move cursor up N lines. | `num`\n| `\\033[<NUM>B` | Move cursor down N lines. | `num`\n| `\\033[<NUM>C` | Move cursor right N columns. | `num`\n| `\\033[<NUM>D` | Move cursor left N columns. | `num`\n| `\\033[s` | Save cursor position. |\n| `\\033[u` | Restore cursor position. |\n\n\n## Erasing Text\n\n| Sequence | What does it do? |\n| -------- | ---------------- |\n| `\\033[K` | Erase from cursor position to end of line.\n| `\\033[1K` | Erase from cursor position to start of line.\n| `\\033[2K` | Erase the entire current line.\n| `\\033[J` | Erase from the current line to the bottom of the screen.\n| `\\033[1J` | Erase from the current line to the top of the screen.\n| `\\033[2J` | Clear the screen.\n| `\\033[2J\\033[H` | Clear the screen and move cursor to `0,0`.\n\n\n# PARAMETER EXPANSION\n\n## Prefix and Suffix Deletion\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${VAR#PATTERN}` | Remove shortest match of pattern from start of string. |\n| `${VAR##PATTERN}` | Remove longest match of pattern from start of string. |\n| `${VAR%PATTERN}` | Remove shortest match of pattern from end of string. |\n| `${VAR%%PATTERN}` | Remove longest match of pattern from end of string. |\n\n## Length\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${#VAR}` | Length of var in characters.\n\n## Default Value\n\n| Parameter | What does it do? |\n| --------- | ---------------- |\n| `${VAR:-STRING}` | If `VAR` is empty or unset, use `STRING` as its value.\n| `${VAR-STRING}` | If `VAR` is unset, use `STRING` as its value.\n| `${VAR:=STRING}` | If `VAR` is empty or unset, set the value of `VAR` to `STRING`.\n| `${VAR=STRING}` | If `VAR` is unset, set the value of `VAR` to `STRING`.\n| `${VAR:+STRING}` | If `VAR` is not empty, use `STRING` as its value.\n| `${VAR+STRING}` | If `VAR` is set, use `STRING` as its value.\n| `${VAR:?STRING}` | Display an error if empty or unset.\n| `${VAR?STRING}` | Display an error if unset.\n\n\n# CONDITIONAL EXPRESSIONS\n\nFor use in `[ ]` `if [ ]; then` and `test`.\n\n## File Conditionals\n\n| Expression | Value  | What does it do? |\n| ---------- | ------ | ---------------- |\n| `-b`       | `file` | If file exists and is a block special file.\n| `-c`       | `file` | If file exists and is a character special file.\n| `-d`       | `file` | If file exists and is a directory.\n| `-e`       | `file` | If file exists.\n| `-f`       | `file` | If file exists and is a regular file.\n| `-g`       | `file` | If file exists and its set-group-id bit is set.\n| `-h`       | `file` | If file exists and is a symbolic link.\n| `-p`       | `file` | If file exists and is a named pipe (*FIFO*).\n| `-r`       | `file` | If file exists and is readable.\n| `-s`       | `file` | If file exists and its size is greater than zero.\n| `-t`       | `fd`   | If file descriptor is open and refers to a terminal.\n| `-u`       | `file` | If file exists and its set-user-id bit is set.\n| `-w`       | `file` | If file exists and is writable.\n| `-x`       | `file` | If file exists and is executable.\n| `-L`       | `file` | If file exists and is a symbolic link.\n| `-S`       | `file` | If file exists and is a socket.\n\n## Variable Conditionals\n\n| Expression | Value | What does it do? |\n| ---------- | ----- | ---------------- |\n| `-z`       | `var` | If the length of string is zero.\n| `-n`       | `var` | If the length of string is non-zero.\n\n## Variable Comparisons\n\n| Expression | What does it do? |\n| ---------- | ---------------- |\n| `var = var2` | Equal to.\n| `var != var2` | Not equal to.\n| `var -eq var2` | Equal to (*algebraically*).\n| `var -ne var2` | Not equal to (*algebraically*).\n| `var -gt var2` | Greater than (*algebraically*).\n| `var -ge var2` | Greater than or equal to (*algebraically*).\n| `var -lt var2` | Less than (*algebraically*).\n| `var -le var2` | Less than or equal to (*algebraically*).\n\n\n# ARITHMETIC OPERATORS\n\n## Assignment\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `=`       | Initialize or change the value of a variable.\n\n## Arithmetic\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `+` | Addition\n| `-` | Subtraction\n| `*` | Multiplication\n| `/` | Division\n| `%` | Modulo\n| `+=` | Plus-Equal (*Increment a variable.*)\n| `-=` | Minus-Equal (*Decrement a variable.*)\n| `*=` | Times-Equal (*Multiply a variable.*)\n| `/=` | Slash-Equal (*Divide a variable.*)\n| `%=` | Mod-Equal (*Remainder of dividing a variable.*)\n\n## Bitwise\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `<<` | Bitwise Left Shift\n| `<<=` | Left-Shift-Equal\n| `>>` | Bitwise Right Shift\n| `>>=` | Right-Shift-Equal\n| `&` | Bitwise AND\n| `&=` | Bitwise AND-Equal\n| `\\|` | Bitwise OR\n| `\\|=` | Bitwise OR-Equal\n| `~` | Bitwise NOT\n| `^` | Bitwise XOR\n| `^=` | Bitwise XOR-Equal\n\n## Logical\n\n| Operators | What does it do? |\n| --------- | ---------------- |\n| `!` | NOT\n| `&&` | AND\n| `\\|\\|` | OR\n\n## Miscellaneous\n\n| Operators | What does it do? | Example |\n| --------- | ---------------- | ------- |\n| `,` | Comma Separator | `((a=1,b=2,c=3))`\n\n\n# ARITHMETIC\n\n## Ternary Tests\n\n```shell\n# Set the value of var to var2 if var2 is greater than var.\n# 'var2 > var': Condition to test.\n# '? var2': If the test succeeds.\n# ': var': If the test fails.\nvar=$((var2 > var ? var2 : var))\n```\n\n## Check if a number is a float\n\n**Example Function:**\n\n```sh\nis_float() {\n    # Usage: is_float \"number\"\n\n    # The test checks to see that the input contains\n    # a '.'. This filters out whole numbers.\n    [ -z \"${1##*.*}\" ] &&\n        printf %f \"$1\" >/dev/null 2>&1\n}\n```\n\n**Example Usage:**\n\n```shell\n$ is_float 1 && echo true\n$\n\n$ is_float 1.1 && echo true\n$ true\n```\n\n## Check if a number is an integer\n\n**Example Function:**\n\n```sh\nis_int() {\n    # usage: is_int \"number\"\n    printf %d \"$1\" >/dev/null 2>&1\n}\n```\n\n**Example Usage:**\n\n```shell\n$ is_int 1 && echo true\n$ true\n\n$ is_int 1.1 && echo true\n$\n```\n\n# TRAPS\n\nTraps allow a script to execute code on various signals. In [pxltrm](https://github.com/dylanaraps/pxltrm) (*a pixel art editor written in bash*)  traps are used to redraw the user interface on window resize. Another use case is cleaning up temporary files on script exit.\n\nTraps should be added near the start of scripts so any early errors are also caught.\n\n## Do something on script exit\n\n```shell\n# Clear screen on script exit.\ntrap 'printf \\\\033[2J\\\\033[H\\\\033[m' EXIT\n\n# Run a function on script exit.\n# 'clean_up' is the name of a function.\ntrap clean_up EXIT\n```\n\n## Ignore terminal interrupt (CTRL+C, SIGINT)\n\n```shell\ntrap '' INT\n```\n\n# OBSOLETE SYNTAX\n\n## Command Substitution\n\nUse `$()` instead of `` ` ` ``.\n\n```shell\n# Right.\nvar=\"$(command)\"\n\n# Wrong.\nvar=`command`\n\n# $() can easily be nested whereas `` cannot.\nvar=\"$(command \"$(command)\")\"\n```\n\n# INTERNAL AND ENVIRONMENT VARIABLES\n\n## Open the user's preferred text editor\n\n```shell\n\"$EDITOR\" \"$file\"\n\n# NOTE: This variable may be empty, set a fallback value.\n\"${EDITOR:-vi}\" \"$file\"\n```\n\n## Get the current working directory\n\nThis is an alternative to the `pwd` built-in.\n\n```shell\n\"$PWD\"\n```\n\n## Get the PID of the current shell\n\n```\n\"$$\"\n```\n\n## Get the current shell options\n\n```\n\"$-\"\n```\n\n# AFTERWORD\n\nThanks for reading! If this bible helped you in any way and you'd like to give back, consider donating. Donations give me the time to make this the best resource possible. Can't donate? That's OK, star the repo and share it with your friends!\n\n<a href=\"https://www.patreon.com/dyla\"><img src=\"https://img.shields.io/badge/donate-patreon-yellow.svg\"></a>\n\n\nRock on. ðŸ¤˜\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 0.5517578125,
          "content": "#!/bin/sh\n# shellcheck source=/dev/null\n#\n# Tests for the Pure sh Bible.\n\nmain() {\n    trap 'rm -f readme_code test_file' EXIT INT\n\n    # Extract code blocks from the README.\n    while read -r line; do\n        [ \"$code\" ] && [ \"$line\" != \\`\\`\\` ] &&\n            printf '%s\\n' \"$line\"\n\n        case $line in\n            \\`\\`\\`sh) code=1 ;;\n            \\`\\`\\`)   code=\n        esac\n    done < README.md > readme_code\n\n    # Run shellcheck on the extracted code blocks\n    # and this test script itself.\n    shellcheck -s sh readme_code test.sh || exit 1\n}\n\nmain \"$@\"\n"
        }
      ]
    }
  ]
}