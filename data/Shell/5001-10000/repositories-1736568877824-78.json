{
  "metadata": {
    "timestamp": 1736568877824,
    "page": 78,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "magicmonty/bash-git-prompt",
      "stars": 6739,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1669921875,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.sh]\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.078125,
          "content": "# Unix lines endings in bash script files\n*.sh text eol=lf\nthemes/* text eol=lf\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "*~\n*.bak\n.idea/\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.26953125,
          "content": "Copyright (c) 2016, Martin Gondermann\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.8203125,
          "content": "# Informative git prompt for bash and fish\n\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/magicmonty/bash-git-prompt?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\nThis prompt is a port of the \"Informative git prompt for zsh\" which you can\nfind [here](https://github.com/olivierverdier/zsh-git-prompt)\n\nA `bash` prompt that displays information about the current git repository.\nIn particular the branch name, difference with remote branch, number of files\nstaged, changed, etc.\n\n`gitstatus.sh` and `git-prompt-help.sh` added by [AKS](http://github.com/aks).\n\n## Examples\n\nThe prompt may look like the following:\n\n![Example prompt](gitprompt.png)\n\n* ``(master↑3|✚1)``: on branch ``master``, ahead of remote by 3 commits, 1 file changed but not staged\n* ``(status|●2)``: on branch ``status``, 2 files staged\n* ``(master|✚7…)``: on branch ``master``, 7 files changed, some files untracked\n* ``(master|✖2✚3)``: on branch ``master``, 2 conflicts, 3 files changed\n* ``(master|⚑2)``: on branch ``master``, 2 stash entries\n* ``(experimental↓2↑3|✔)``: on branch ``experimental``; your branch has diverged by 3 commits, remote by 2 commits; the repository is otherwise clean\n* ``(:70c2952|✔)``: not on any branch; parent commit has hash ``70c2952``; the repository is otherwise clean\n\n## Prompt Structure\n\nBy default, the general appearance of the prompt is::\n\n```plaintext\n(<branch> <upstream branch> <branch tracking>|<local status>)\n```\n\nThe symbols are as follows:\n\n- Local Status Symbols\n  - ``✔``: repository clean\n  - ``●n``: there are ``n`` staged files\n  - ``✖n``: there are ``n`` files with merge conflicts\n  - ``✖-n``: there are ``n`` staged files waiting for removal\n  - ``✚n``: there are ``n`` changed but *unstaged* files\n  - ``…n``: there are ``n`` untracked files\n  - ``⚑n``: there are ``n`` stash entries\n- Upstream branch\n  - Shows the remote tracking branch\n  - Disabled by default\n  - Enable by setting `GIT_PROMPT_SHOW_UPSTREAM=1`\n- Branch Tracking Symbols\n  - ``↑n``: ahead of remote by ``n`` commits\n  - ``↓n``: behind remote by ``n`` commits\n  - ``↓m↑n``: branches diverged, other by ``m`` commits, yours by ``n`` commits\n  - ``L``: local branch, not remotely tracked\n- Branch Symbol:<br />\n  - When the branch name starts with a colon ``:``, it means it's actually a hash, not a branch (although it should be pretty clear, unless you name your branches like hashes :-)\n\n## Installation\n\n### via [Homebrew][homebrew] on Mac OS X\n\n- Run `brew update`\n\n- Run `brew install bash-git-prompt` for the last stable release or `brew install --HEAD bash-git-prompt` for the\n   latest version directly from the repository\n\n- Now you can source the file in your `~/.bash_profile` as follows:\n\n```sh\nif [ -f \"$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh\" ]; then\n  __GIT_PROMPT_DIR=$(brew --prefix)/opt/bash-git-prompt/share\n  GIT_PROMPT_ONLY_IN_REPO=1\n  source \"$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh\"\nfi\n```\n\n### via Git clone\n\n- Clone this repository to your home directory.\n\n```sh\ngit clone https://github.com/magicmonty/bash-git-prompt.git ~/.bash-git-prompt --depth=1\n```\n\nAdd to the `~/.bashrc`:\n\n```bash\nif [ -f \"$HOME/.bash-git-prompt/gitprompt.sh\" ]; then\n    GIT_PROMPT_ONLY_IN_REPO=1\n    source \"$HOME/.bash-git-prompt/gitprompt.sh\"\nfi\n```\n\n### install for the fish shell\n\n- If you cloned the repo to a directory other then `~/.bash-git-prompt` , set `__GIT_PROMPT_DIR` in `~/.config/fish/config.fish`\n   to that path\n\n- To install as an option in the fish_config GUI\n\n```sh\nsudo install -m 666 gitprompt.fish /usr/share/fish/tools/web_config/sample_prompts/\nfish_config\n```\n\n&nbsp;to install the bash-git-prompt as a choice under the prompt tab of the web config. Selecting this will copy it to\n`~/.config/fish/functions/fish_prompt.fish`\n\n- You can also do\n\n```sh\nmkdir -p ~/.config/fish/functions/\ncp gitprompt.fish ~/.config/fish/functions/fish_prompt.fish\n```\n\n&nbsp;to overwrite the current prompt with the bash-git-prompt directly\n\n### All configs for .bashrc\n\n```sh\n# Set config variables first\nGIT_PROMPT_ONLY_IN_REPO=1\n\n# GIT_PROMPT_FETCH_REMOTE_STATUS=0   # uncomment to avoid fetching remote status\n# GIT_PROMPT_IGNORE_SUBMODULES=1 # uncomment to avoid searching for changed files in submodules\n# GIT_PROMPT_WITH_VIRTUAL_ENV=0 # uncomment to avoid setting virtual environment infos for node/python/conda environments\n# GIT_PROMPT_VIRTUAL_ENV_AFTER_PROMPT=1 # uncomment to place virtual environment infos between prompt and git status (instead of left to the prompt)\n\n# GIT_PROMPT_SHOW_UPSTREAM=1 # uncomment to show upstream tracking branch\n# GIT_PROMPT_SHOW_UNTRACKED_FILES=normal # can be no, normal or all; determines counting of untracked files\n\n# GIT_PROMPT_SHOW_CHANGED_FILES_COUNT=0 # uncomment to avoid printing the number of changed files\n\n# GIT_PROMPT_STATUS_COMMAND=gitstatus_pre-1.7.10.sh # uncomment to support Git older than 1.7.10\n\n# GIT_PROMPT_START=...    # uncomment for custom prompt start sequence\n# GIT_PROMPT_END=...      # uncomment for custom prompt end sequence\n\n# as last entry source the gitprompt script\n# GIT_PROMPT_THEME=Custom # use custom theme specified in file GIT_PROMPT_THEME_FILE (default ~/.git-prompt-colors.sh)\n# GIT_PROMPT_THEME_FILE=~/.git-prompt-colors.sh\n# GIT_PROMPT_THEME=Solarized # use theme optimized for solarized color scheme\nsource ~/.bash-git-prompt/gitprompt.sh\n```\n\nYou can set the `GIT_PROMPT_SHOW_UNTRACKED_FILES` variable to `no` or `normal` to speed things up if you have lots of\nuntracked files in your repository. This can be the case for build systems that put their build artifacts in\nthe subdirectory structure of the git repository. Setting it to `all` will count all untracked files, including files\nlisted in .gitignore.\n\n- `cd` to a git repository and test it!\n\n#### Themes\n\nThe most settings are now stored in theme files. To select a theme, set the variable `GIT_PROMPT_THEME` to the name\nof the theme located in `<INSTALLDIR>/themes` without the extension `.bgptheme` like this:\n\n```sh\nGIT_PROMPT_THEME=Solarized\n```\n\nIf you set `GIT_PROMPT_THEME` to `Custom`, then the `.git-prompt-colors.sh` in the home directory will be used.\nThis file can now be generated with the command `git_prompt_make_custom_theme [<Name of base theme>]`. If the name of\nthe base theme is ommitted or the theme file is not found, then the Default theme is used. If you have already a custom\n`.git-prompt-colors.sh` in your home directory, an error message will be shown.\n\nYou can display a list of available themes with `git_prompt_list_themes` (the current theme is highlighted)\n\n**If you omit the `GIT_PROMPT_THEME` variable, the Default theme is used or, if you have a custom `.git-prompt-colors.sh`\nin your home directory, then the Custom theme is used.**\n\n##### Ubuntu Themes\n\nUbuntu requires a bit more spacing for some characters so it has its own themes.\n\nThese can be listed with `git_prompt_list_themes`:\n\n```sh\ngit_prompt_list_themes | grep Ubuntu\n```\n\n##### Theme structure\n\nPlease see the ``Custom.bgptemplate`` in the ``themes`` subdirectory of the installation directory!\n\nA theme consists of a function `override_git_prompt_colors()` which defines at least the variable `GIT_PROMPT_THEME_NAME`\n with a unique theme identifier and a call to the function `reload_git_prompt_colors <ThemeName>` like follows:\n\n```sh\noverride_git_prompt_colors() {\n  GIT_PROMPT_THEME_NAME=\"Custom\" # needed for reload optimization, should be unique\n\n  # Place your overrides here\n  ...\n}\n\n# load the theme\nreload_git_prompt_colors \"Custom\"\n```\n\nThe advantage of this approach is, that you only need to specify the parts, that are different to the Default theme.\n\nIf you use a custom theme in `.git-prompt-colors.sh`, please set `GIT_PROMPT_THEME_NAME=\"Custom\"`.\n\n#### Further customizations\n\n- You can define `GIT_PROMPT_START` and `GIT_PROMPT_END` to tweak your prompt.\n\n- The default colors are defined within `prompt-colors.sh`, which is sourced by\n  `gitprompt.sh`.  The colors used for various git status are defined in\n  `themes/Default.bgptheme`.  Both of these files may be overridden by copying\n  them to $HOME with a `.` prefix.  They can also be placed in `$HOME/lib`\n  without the leading `.`.  The defaults are the original files in the\n  `~/.bash-git-prompt` directory.\n\n- You can use `GIT_PROMPT_START_USER`, `GIT_PROMPT_START_ROOT`,\n  `GIT_PROMPT_END_USER` and `GIT_PROMPT_END_ROOT` in your\n  `.git-prompt-colors.sh` to tweak your prompt. You can also override the start\n  and end of the prompt by setting `GIT_PROMPT_START` and `GIT_PROMPT_END`\n  before you source the `gitprompt.sh`.\n\n- The current git repo information is obtained by the script `gitstatus.sh`.\n- You can define `prompt_callback` function to tweak your prompt dynamically.\n\n```sh\nprompt_callback() {\n    if [ $(jobs | wc -l) -ne 0 ]; then\n        echo -n \" jobs:\\j\"\n    fi\n}\n```\n\n- There are two helper functions that can be used within `prompt_callback`:\n    - `gp_set_window_title <String>` - sets the window title to the given string (should work for XTerm type terminals like in OS X or Ubuntu)\n    - `gp_truncate_pwd` - a function that returns the current PWD truncated to fit the current terminal width. Specify the length to truncate to as a parameter. Otherwise it defaults to 1/3 of the terminal width.\n\n- If you want to show the git prompt only if you are in a git repository you\n  can set `GIT_PROMPT_ONLY_IN_REPO=1` before sourcing the gitprompt script\n\n- You can show an abbreviated `username/repo` in the prompt by setting `GIT_PROMPT_WITH_USERNAME_AND_REPO=1` and setting the placeholder `_USERNAME_REPO_` in your `GIT_PROMPT_PREFIX`. You can also add a `GIT_PROMPT_USERNAME_REPO_SEPARATOR=\" | \"` so the `username/repo` is nicely separated if there is a remote and if there is no remote, neither the username/repo part nor the separator will be shown. See the theme `Single_line_username_repo.bgptheme` for an example.\n\n- There is an indicator at the start of the prompt, which shows\n  the result of the last executed command by if you put the placeholder\n  `_LAST_COMMAND_INDICATOR_` in any of the prompt templates.\n  It is now by default activated in the default theme:\n\n```sh\n  GIT_PROMPT_START_USER=\"_LAST_COMMAND_INDICATOR_ ${Yellow}${PathShort}${ResetColor}\"\n  GIT_PROMPT_START_ROOT=\"_LAST_COMMAND_INDICATOR_ ${GIT_PROMPT_START_USER}\"\n```\n\n  If you want to display the exit code too, you can use the placeholder\n  ``_LAST_COMMAND_STATE_`` in ``GIT_PROMPT_COMMAND_OK`` or ``GIT_PROMPT_COMMAND_FAIL``\n  in your ``.git-prompt-colors.sh``:\n\n```sh\nGIT_PROMPT_COMMAND_OK=\"${Green}✔ \" # displays as ✔\nGIT_PROMPT_COMMAND_FAIL=\"${Red}✘-_LAST_COMMAND_STATE_ \" # displays as ✘-1 for exit code 1\n```\n\n- It is now possible to disable the fetching of the remote repository either\n  globally by setting ``GIT_PROMPT_FETCH_REMOTE_STATUS=0`` in your .bashrc or\n  on a per repository basis by creating a file named ``.bash-git-rc`` with the\n  content ``FETCH_REMOTE_STATUS=0`` in the root of your git repository.\n\n- You can also ignore a repository completely by creating a file named ``.bash-git-rc`` with the\n  content ``GIT_PROMPT_IGNORE=1`` in the root of your git repository.\n\n- If you have a repository with many untracked files, the git prompt can become very slow.\n  You can disable the display of untracked files on a per repository basis by setting\n  ``GIT_PROMPT_SHOW_UNTRACKED_FILES=no`` in your ``.bash-git-rc`` in the repository or\n  by disabling it globally in your ``.bashrc``\n\n- If you have a repository with a deep submodule hierarchy, this can also affect performance.\n  You can disable searching for changes in submodules on a per repository basis by setting\n  ``GIT_PROMPT_IGNORE_SUBMODULES=1`` in your ``.bash-git-rc``\n\n- You can get help on the git prompt with the function ``git_prompt_help``.\n  Examples are available with ``git_prompt_examples``.\n  A list of all available named colors is available with `git_prompt_color_samples`\n\n- If you make any changes to any file that is sourced by `gitprompt.sh`, you\n  should run this command, so that the next prompt update will find all the\n  files and source them anew.\n\n```sh\ngit_prompt_reset\n```\n\n- You can disable/enable gitprompt by running:\n\n```sh\ngit_prompt_toggle\n```\n\n**Enjoy!**\n\n## Alternative RPM Install\n\nThis project ships an RPM spec to simplify installation on RHEL and\nclones. If you wish to install from RPM, you may first build the RPM\nfrom scratch by following this procedure:\n\n* Clone this repository and tag the release with a version number\n\n````sh\ngit tag -a -m \"Tag release 1.1\" 1.1\n````\n\n* Run the following command to create a tarball:\n\n````sh\nVER=$(git describe)\n# replace dash with underscore to work around\n# rpmbuild does not allow dash in version string\nVER=${VER//\\-/_}\ngit archive                                \\\n    --format tar                           \\\n    --prefix=bash-git-prompt-${VER}/       \\\n    HEAD                                   \\\n    --  *.sh                               \\\n        *.fish                             \\\n        LICENSE.txt                        \\\n        README.md                          \\\n        themes                             \\\n    > bash-git-prompt-${VER}.tar\nmkdir -p /tmp/bash-git-prompt-${VER}\nsed \"s/Version:.*/Version:        ${VER}/\"          \\\n    bash-git-prompt.spec                            \\\n    > /tmp/bash-git-prompt-${VER}/bash-git-prompt.spec\nOLDDIR=$(pwd)\ncd /tmp\ntar -uf ${OLDDIR}/bash-git-prompt-${VER}.tar      \\\n        bash-git-prompt-${VER}/bash-git-prompt.spec\ncd ${OLDDIR}\ngzip bash-git-prompt-${VER}.tar\nmv bash-git-prompt-${VER}.tar.gz bash-git-prompt-${VER}.tgz\n````\n\n* Log into an RHEL or clones host and run:\n\n````sh\nrpmbuild -ta bash-git-prompt-xxx.tar.gz\n````\n\nThen you may publish or install the rpm from \"~/rpmbuild/RPMS/noarch\".\n\n## License\n\nThis code is under the [BSD 2 Clause (NetBSD) license][license].\n\n## Who Are You?\n\nThe current maintainer of the original bash-git-prompt is [Martin Gondermann][magicmonty].\n\n## Contributing\n\nIf you want to contribute you can look for issues with the label [up-for-grabs][upforgrabs].\nPlease leave a comment on the issue, that you want to fix it, so others know, the labels are \"taken\".\n\nPull requests are welcome. I will check them and merge them, if I think they help the project.\n\n## Similar projects\n\n- [oh-my-bash](https://github.com/ohmybash/oh-my-bash)\n\n## Donations\n\nI accept tips through [Flattr][flattr].\n\n[![Flattr](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=magicmonty&url=https%3A%2F%2Fgithub.com%2Fmagicmonty%2Fbash-git-prompt)\n\n[blog post]: http://sebastiancelis.com/2009/nov/16/zsh-prompt-git-users/\n[tip]:https://www.gittip.com/magicmonty/\n[magicmonty]: http://blog.pagansoft.de/pages/about.html\n[license]:https://github.com/magicmonty/bash-git-prompt/tree/master/LICENSE.txt\n[flattr]: https://flattr.com/submit/auto?user_id=magicmonty&url=https%3A%2F%2Fgithub.com%2Fmagicmonty%2Fbash-git-prompt\n[homebrew]: http://brew.sh/\n[upforgrabs]: https://github.com/magicmonty/bash-git-prompt/labels/up-for-grabs\n"
        },
        {
          "name": "bash-git-prompt.rb",
          "type": "blob",
          "size": 1.0791015625,
          "content": "class BashGitPrompt < Formula\n  desc \"Informative, fancy bash prompt for Git users\"\n  homepage \"https://github.com/magicmonty/bash-git-prompt\"\n  url \"https://github.com/magicmonty/bash-git-prompt/archive/2.7.1.tar.gz\"\n  sha256 \"5e5fc6f5133b65760fede8050d4c3bc8edb8e78bc7ce26c16db442aa94b8a709\"\n  head \"https://github.com/magicmonty/bash-git-prompt.git\"\n\n  bottle :unneeded\n\n  def install\n    share.install \"gitprompt.sh\", \"gitprompt.fish\", \"git-prompt-help.sh\",\n                  \"gitstatus.py\", \"gitstatus.sh\", \"gitstatus_pre-1.7.10.sh\",\n                  \"prompt-colors.sh\"\n\n    (share/\"themes\").install Dir[\"themes/*.bgptheme\"], \"themes/Custom.bgptemplate\"\n    doc.install \"README.md\"\n  end\n\n  def caveats; <<~EOS\n    You should add the following to your .bashrc (or .bash_profile if bash is your login shell):\n      if [ -f \"#{HOMEBREW_PREFIX}/opt/bash-git-prompt/share/gitprompt.sh\" ]; then\n        __GIT_PROMPT_DIR=\"#{HOMEBREW_PREFIX}/opt/bash-git-prompt/share\"\n        source \"#{HOMEBREW_PREFIX}/opt/bash-git-prompt/share/gitprompt.sh\"\n      fi\n    EOS\n  end\n\n  test do\n    system \"true\"\n  end\nend\n"
        },
        {
          "name": "bash-git-prompt.spec",
          "type": "blob",
          "size": 2.064453125,
          "content": "%global START_TOKEN ### Generated by %{name} rpm package\n%global END_TOKEN ### Generated by %{name} rpm package\n\nName:           bash-git-prompt\nVersion:        2.7.1\nRelease:        1%{?dist}\nSummary:        Informative git prompt for bash and fish\n\nGroup:          Development/Tools\nLicense:        BSD-2-Clause\nURL:            https://github.com/magicmonty/bash-git-prompt\nSource0:        https://github.com/magicmonty/%{name}/archive/%{version}/%{name}-%{version}.tar.gz\nRequires:       git\nBuildArch:      noarch\n\n%description\nA bash prompt that displays information about the current git repository. In particular the branch name, difference with remote branch, number of files staged, changed, etc.\n\nThis package will automatically enable the git prompt for bash after\ninstall. It will disable the prompt accordingly after uninstall.\n\n%prep\n%setup -q\n\n%build\n# No command are required here\n# These comments are here to avoid rpm lint issue\n\n%install\ninstall -dm 755 %{buildroot}%{_datadir}/%{name}\ninstall -pm 755 *.sh %{buildroot}%{_datadir}/%{name}\n#install -pm 755 *.py %{buildroot}%{_datadir}/%{name}\ninstall -pm 755 *.fish %{buildroot}%{_datadir}/%{name}\ninstall -pm 644 README.md %{buildroot}%{_datadir}/%{name}\ninstall -dm 755 %{buildroot}%{_datadir}/%{name}/themes\ninstall -pm 644 themes/*.bgptheme %{buildroot}%{_datadir}/%{name}/themes\ninstall -pm 644 themes/*.bgptemplate %{buildroot}%{_datadir}/%{name}/themes\n\n%post\n# enable bash-git-prompt\ncat << EOF >> /etc/bashrc\n%{START_TOKEN}\nif [ -f %{_datadir}/%{name}/gitprompt.sh ]; then\n    # Set config variables first\n\n    GIT_PROMPT_ONLY_IN_REPO=1\n    GIT_PROMPT_THEME=Default\n    source %{_datadir}/%{name}/gitprompt.sh\nfi\n%{END_TOKEN}\nEOF\n\n%postun\n# remove bash-git-prompt setup\nsed -i -e '/^%{START_TOKEN}/, /^%{END_TOKEN}/{d}' /etc/bashrc\n\n%files\n%defattr(-,root,root,-)\n%{_datadir}/%{name}\n\n%doc README.md\n\n%license LICENSE.txt\n\n%changelog\n* Tue Jun 28 2016 Koustubh Sinkar <ksinkar@gmail.com>\n- Updating the spec file to reflect more recent changes\n\n* Fri Aug 08 2014 Justin Zhang <schnell18@gmail.com - 1.0.1-1\n- Initial version of package\n"
        },
        {
          "name": "git-prompt-help.sh",
          "type": "blob",
          "size": 4.3134765625,
          "content": "#!/usr/bin/env bash\n#  git-prompt-help -- show useful info to help new users with the information\n# being displayed.\n\ngit_prompt_help() {\n  source \"${__GIT_PROMPT_DIR}/prompt-colors.sh\"\n  source \"${__GIT_PROMPT_DIR}/themes/Default.bgptheme\"\n\n cat <<EOF | sed 's/\\\\\\[\\\\033/\u001b/g' | sed 's/\\\\\\]//g'\nThe git prompt format is ${GIT_PROMPT_PREFIX}<BRANCH><TRACKING>${GIT_PROMPT_SEPARATOR}<LOCALSTATUS>${GIT_PROMPT_SUFFIX}${ResetColor}\n\nBRANCH is a branch name, such as \"${GIT_PROMPT_MASTER_BRANCH}master${ResetColor}\" or \"${GIT_PROMPT_BRANCH}stage${ResetColor}\", a tag name, or commit\n${GIT_PROMPT_SYMBOLS_PREHASH}hash${ResetColor} prefixed with '${GIT_PROMPT_SYMBOLS_PREHASH:-':'}${ResetColor}'.\n\nTRACKING indicates how the local branch differs from the\nremote branch.  It can be empty, or one of:\n\n    ${GIT_PROMPT_BRANCH}${ResetColor}${GIT_PROMPT_REMOTE}${GIT_PROMPT_SYMBOLS_AHEAD}N${ResetColor} - ahead of remote by N commits\n    ${GIT_PROMPT_BRANCH}${ResetColor}${GIT_PROMPT_REMOTE}${GIT_PROMPT_SYMBOLS_BEHIND}M${ResetColor} - behind remote by M commits\n    ${GIT_PROMPT_BRANCH}${ResetColor}${GIT_PROMPT_REMOTE}${GIT_PROMPT_SYMBOLS_BEHIND}M${GIT_PROMPT_SYMBOLS_AHEAD}N${ResetColor} - branches diverged, other by M commits, yours by N commits\n\nLOCALSTATUS is one of the following:\n\n    ${GIT_PROMPT_CLEAN}${ResetColor} - repository clean\n    ${GIT_PROMPT_STAGED}N${ResetColor} - N staged files\n    ${GIT_PROMPT_CONFLICTS}N${ResetColor} - N files with merge conflicts\n    ${GIT_PROMPT_CHANGED}N${ResetColor} - N changed but *unstaged* files\n    ${GIT_PROMPT_UNTRACKED}N${ResetColor} - N untracked files\n    ${GIT_PROMPT_STASHED}N${ResetColor} - N stash entries\n\nSee \"git_prompt_examples\" for examples.\nEOF\n}\n\nhelp_git_prompt() { git_prompt_help ; }\n\ngit_prompt_examples() {\n\n  format_branch() {\n    case \"$1\" in\n      ${GIT_PROMPT_MASTER_BRANCHES})\n        echo \"${GIT_PROMPT_MASTER_BRANCH}$1${ResetColor}\"\n        ;;\n      *)\n        echo \"${GIT_PROMPT_BRANCH}$1${ResetColor}\"\n        ;;\n    esac\n  }\n  local p=\"${GIT_PROMPT_PREFIX}\"\n  local s=\"${GIT_PROMPT_SUFFIX}${ResetColor}\"\n\n  cat <<EOF | sed 's/\\\\\\[\\\\033/\u001b/g' | sed 's/\\\\\\]//g'\nThese are examples of the git prompt:\n\n  ${p}$(format_branch master)${GIT_PROMPT_REMOTE}${GIT_PROMPT_SYMBOLS_AHEAD}3${ResetColor}|${GIT_PROMPT_CHANGED}1${ResetColor}${s}  - on branch \"master\", ahead of remote by 3 commits, 1\n                     file changed but not staged\n\n  ${p}$(format_branch status)${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_STAGED}2${ResetColor}${s}     - on branch \"status\", 2 files staged\n\n  ${p}$(format_branch master)${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_CHANGED}7${GIT_PROMPT_UNTRACKED}${ResetColor}${s}   - on branch \"master\", 7 files changed, some files untracked\n\n  ${p}$(format_branch master)${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_CONFLICTS}2${GIT_PROMPT_CHANGED}3${ResetColor}${s}  - on branch \"master\", 2 conflicts, 3 files changed\n\n  ${p}$(format_branch master)${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_STASHED}2${ResetColor}${s}     - on branch \"master\", 2 stash entries\n\n  ${p}$(format_branch experimental)${GIT_PROMPT_REMOTE}${GIT_PROMPT_SYMBOLS_BEHIND}2${GIT_PROMPT_SYMBOLS_AHEAD}3${ResetColor}${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_CLEAN}${ResetColor}${s}\n                   - on branch \"experimental\"; your branch has diverged\n                     by 3 commits, remote by 2 commits; the repository is\n                     otherwise clean\n\n  ${p}${GIT_PROMPT_BRANCH}${GIT_PROMPT_SYMBOLS_PREHASH}70c2952${ResetColor}${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_CLEAN}${ResetColor}${s}    - not on any branch; parent commit has hash \"70c2952\"; the\n                     repository is otherwise clean\n\n  ${p}$(format_branch extra-features)${GIT_PROMPT_SYMBOLS_NO_REMOTE_TRACKING}${ResetColor}${GIT_PROMPT_SEPARATOR}${GIT_PROMPT_CHANGED}2${GIT_PROMPT_UNTRACKED}4${ResetColor}${s}\n                   - on branch \"extra-features\"; no remote set (signalled by '${GIT_PROMPT_SYMBOLS_NO_REMOTE_TRACKING}${ResetColor}'),\n                     2 files changed and 4 untracked files exist\nEOF\n}\n\ngit_prompt_color_samples() {\n\n  showColor() {\n    local color=$(eval echo \"\\${${1}}\")\n    echo -e \"${color}${1}${ResetColor}\" | sed 's/\\\\\\]//g'  | sed 's/\\\\\\[//g'\n  }\n\n  local x=0\n  while (( x < 8 )) ; do\n    showColor \"${ColorNames[@]:$x:1}\"\n    showColor \"Dim${ColorNames[@]:$x:1}\"\n    showColor \"Bold${ColorNames[@]:$x:1}\"\n    showColor \"Bright${ColorNames[@]:$x:1}\"\n    (( x++ ))\n  done\n}\n"
        },
        {
          "name": "gitprompt.fish",
          "type": "blob",
          "size": 3.2958984375,
          "content": "# name: bash-git-prompt\n# author: Mariusz Smykuła <mariuszs@gmail.com>\n\nfunction fish_prompt\n\n    if not set -q __GIT_PROMPT_DIR\n        set __GIT_PROMPT_DIR ~/.bash-git-prompt\n    end\n\n    # Colors\n    # Reset\n    set ResetColor (set_color normal)       # Text Reset\n\n    # Regular Colors\n    set Red (set_color red)                 # Red\n    set Yellow (set_color yellow);          # Yellow\n    set Blue (set_color blue)               # Blue\n    set WHITE (set_color white)\n\n    # Bold\n    set BGreen (set_color -o green)         # Green\n\n    # High Intensty\n    set IBlack (set_color -o black)         # Black\n\n    # Bold High Intensty\n    set Magenta (set_color -o purple)       # Purple\n\n    # Default values for the appearance of the prompt. Configure at will.\n    set GIT_PROMPT_PREFIX \"[\"\n    set GIT_PROMPT_SUFFIX \"]\"\n    set GIT_PROMPT_SEPARATOR \"|\"\n    set GIT_PROMPT_BRANCH \"$Magenta\"\n    set GIT_PROMPT_STAGED \"$Red● \"\n    set GIT_PROMPT_CONFLICTS \"$Red✖ \"\n    set GIT_PROMPT_CHANGED \"$Blue✚ \"\n    set GIT_PROMPT_REMOTE \" \"\n    set GIT_PROMPT_UNTRACKED \"…\"\n    set GIT_PROMPT_STASHED \"⚑ \"\n    set GIT_PROMPT_CLEAN \"$BGreen✔\"\n\n    # Various variables you might want for your PS1 prompt instead\n    set Time (date +%R)\n    set PathShort (pwd|sed \"s=$HOME=~=\")\n\n    set PROMPT_START \"$Yellow$PathShort$ResetColor\"\n    set PROMPT_END \" \\n$WHITE$Time$ResetColor  \\$ \"\n\n    set -e __CURRENT_GIT_STATUS\n    set gitstatus \"$__GIT_PROMPT_DIR/gitstatus.py\"\n\n    set _GIT_STATUS (python $gitstatus)\n    set __CURRENT_GIT_STATUS $_GIT_STATUS\n\n    set __CURRENT_GIT_STATUS_PARAM_COUNT (count $__CURRENT_GIT_STATUS)\n\n    if not test \"0\" -eq $__CURRENT_GIT_STATUS_PARAM_COUNT\n        set GIT_BRANCH $__CURRENT_GIT_STATUS[1]\n        set GIT_REMOTE \"$__CURRENT_GIT_STATUS[2]\"\n        if contains \".\" \"$GIT_REMOTE\"\n            set -e GIT_REMOTE\n        end\n        set GIT_STAGED $__CURRENT_GIT_STATUS[3]\n        set GIT_CONFLICTS $__CURRENT_GIT_STATUS[4]\n        set GIT_CHANGED $__CURRENT_GIT_STATUS[5]\n        set GIT_UNTRACKED $__CURRENT_GIT_STATUS[6]\n        set GIT_STASHED $__CURRENT_GIT_STATUS[7]\n        set GIT_CLEAN $__CURRENT_GIT_STATUS[8]\n    end\n\n    if test -n \"$__CURRENT_GIT_STATUS\"\n        set STATUS \" $GIT_PROMPT_PREFIX$GIT_PROMPT_BRANCH$GIT_BRANCH$ResetColor\"\n\n        if set -q GIT_REMOTE\n            set STATUS \"$STATUS$GIT_PROMPT_REMOTE$GIT_REMOTE$ResetColor\"\n        end\n\n        set STATUS \"$STATUS$GIT_PROMPT_SEPARATOR\"\n\n        if [ $GIT_STAGED != \"0\" ]\n            set STATUS \"$STATUS$GIT_PROMPT_STAGED$GIT_STAGED$ResetColor\"\n        end\n\n        if [ $GIT_CONFLICTS != \"0\" ]\n            set STATUS \"$STATUS$GIT_PROMPT_CONFLICTS$GIT_CONFLICTS$ResetColor\"\n        end\n\n        if [ $GIT_CHANGED != \"0\" ]\n            set STATUS \"$STATUS$GIT_PROMPT_CHANGED$GIT_CHANGED$ResetColor\"\n        end\n\n        if [ \"$GIT_UNTRACKED\" != \"0\" ]\n            set STATUS \"$STATUS$GIT_PROMPT_UNTRACKED$GIT_UNTRACKED$ResetColor\"\n        end\n\n        if [ \"$GIT_STASHED\" != \"0\" ]\n            set STATUS \"$STATUS$GIT_PROMPT_STASHED$GIT_STASHED$ResetColor\"\n        end\n\n        if [ \"$GIT_CLEAN\" = \"1\" ]\n            set STATUS \"$STATUS$GIT_PROMPT_CLEAN\"\n        end\n\n        set STATUS \"$STATUS$ResetColor$GIT_PROMPT_SUFFIX\"\n\n        set PS1 \"$PROMPT_START$STATUS$PROMPT_END\"\n    else\n        set PS1 \"$PROMPT_START$PROMPT_END\"\n    end\n\n    echo -e $PS1\n\nend\n\n\n"
        },
        {
          "name": "gitprompt.png",
          "type": "blob",
          "size": 22.021484375,
          "content": null
        },
        {
          "name": "gitprompt.sh",
          "type": "blob",
          "size": 23.8916015625,
          "content": "#!/usr/bin/env bash\n\n# bash/zsh cross compatibility notes:\n# - always use ${array[@]:offset:length} syntax for array indexing\n\nfunction async_run() {\n  {\n    eval \"$@\" &> /dev/null\n  }&\n}\n\nfunction async_run_zsh() {\n  {\n    eval \"$@\" &> /dev/null\n\n  # `true` is used here to allow bash to parse the script, as the zsh `&!` syntax will otherwise stop parsing prior to any execution.\n  }&! true\n}\n\n\nfunction set_git_prompt_dir() {\n  # code thanks to http://stackoverflow.com/questions/59895\n  if [ -z \"$__GIT_PROMPT_DIR\" ]; then\n    __GIT_PROMPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\n  fi\n}\n\nfunction echoc() {\n  echo -e \"${1}${2}${ResetColor}\" | sed 's/\\\\\\]//g'  | sed 's/\\\\\\[//g'\n}\n\nfunction get_theme() {\n  local CUSTOM_THEME_FILE=\"${HOME}/.git-prompt-colors.sh\"\n  if [[ ! (-z \"${GIT_PROMPT_THEME_FILE:+x}\" ) ]]; then\n    CUSTOM_THEME_FILE=\"${GIT_PROMPT_THEME_FILE}\"\n  fi\n  local DEFAULT_THEME_FILE=\"${__GIT_PROMPT_DIR}/themes/Default.bgptheme\"\n\n  if [[ -z \"${GIT_PROMPT_THEME+x}\" ]]; then\n    if [[ -r \"${CUSTOM_THEME_FILE}\" ]]; then\n      GIT_PROMPT_THEME=\"Custom\"\n      __GIT_PROMPT_THEME_FILE=\"${CUSTOM_THEME_FILE}\"\n    else\n      GIT_PROMPT_THEME=\"Default\"\n      __GIT_PROMPT_THEME_FILE=\"${DEFAULT_THEME_FILE}\"\n    fi\n  else\n    if [[ \"${GIT_PROMPT_THEME}\" = \"Custom\" ]]; then\n      GIT_PROMPT_THEME=\"Custom\"\n      __GIT_PROMPT_THEME_FILE=\"${CUSTOM_THEME_FILE}\"\n\n      if [[ ! (-r \"${__GIT_PROMPT_THEME_FILE}\") ]]; then\n        GIT_PROMPT_THEME=\"Default\"\n        __GIT_PROMPT_THEME_FILE=\"${DEFAULT_THEME_FILE}\"\n      fi\n    else\n      local theme=\"\"\n\n      # use default theme, if theme was not found\n      for themefile in \"${__GIT_PROMPT_DIR}/themes/\"*.bgptheme; do\n        local basename=${themefile##*/}\n        if [[ \"${basename%.bgptheme}\" = \"${GIT_PROMPT_THEME}\" ]]; then\n          theme=\"${GIT_PROMPT_THEME}\"\n          break\n        fi\n      done\n\n      if [[ \"${theme}\" = \"\" ]]; then\n        GIT_PROMPT_THEME=\"Default\"\n      fi\n\n      __GIT_PROMPT_THEME_FILE=\"${__GIT_PROMPT_DIR}/themes/${GIT_PROMPT_THEME}.bgptheme\"\n    fi\n  fi\n}\n\nfunction git_prompt_load_colors() {\n  if gp_set_file_var __PROMPT_COLORS_FILE prompt-colors.sh ; then\n    # outsource the color defs\n    source \"${__PROMPT_COLORS_FILE}\"\n  else\n    echo 1>&2 \"Cannot find prompt-colors.sh!\"\n  fi\n}\n\nfunction git_prompt_load_theme() {\n  get_theme\n  local DEFAULT_THEME_FILE=\"${__GIT_PROMPT_DIR}/themes/Default.bgptheme\"\n  source \"${DEFAULT_THEME_FILE}\"\n  source \"${__GIT_PROMPT_THEME_FILE}\"\n}\n\nfunction git_prompt_list_themes() {\n  git_prompt_load_colors\n  get_theme\n\n  for themefile in \"${__GIT_PROMPT_DIR}/themes/\"*.bgptheme; do\n    local basename=\"${themefile##*/}\"\n    local theme=\"${basename%.bgptheme}\"\n    if [[ \"${GIT_PROMPT_THEME}\" = \"${theme}\" ]]; then\n      echoc \"${Red}\" \"*${theme}\"\n    else\n      echo \"${theme}\"\n    fi\n  done\n\n  if [[ \"${GIT_PROMPT_THEME}\" = \"Custom\" ]]; then\n    echoc \"${Magenta}\" \"*Custom\"\n  else\n    echoc \"${Blue}\" \"Custom\"\n  fi\n}\n\nfunction git_prompt_make_custom_theme() {\n  if [[ -r \"${HOME}/.git-prompt-colors.sh\" ]]; then\n    echoc \"${Red}\" \"You have already created a custom theme!\"\n  else\n    local base=\"Default\"\n    if [[ -n \"${1}\" && -r \"${__GIT_PROMPT_DIR}/themes/${1}.bgptheme\" ]]; then\n      base=\"${1}\"\n      echoc \"${Green}\" \"Using theme ${Magenta}\\\"${base}\\\"${Green} as base theme!\"\n    else\n      echoc \"${Green}\" \"Using theme ${Magenta}\\\"Default\\\"${Green} as base theme!\"\n    fi\n\n    if [[ \"${base}\" = \"Custom\" ]]; then\n      echoc \"${Red}\" \"You cannot use the custom theme as base\"\n    else\n      echoc \"${Green}\" \"Creating new custom theme in \\\"${HOME}/.git-prompt-colors.sh\\\"\"\n      echoc \"${DimYellow}\" \"Please add ${Magenta}\\\"GIT_PROMPT_THEME=Custom\\\"${DimYellow} to your .bashrc to use this theme\"\n      if [[ \"${base}\" == \"Default\" ]]; then\n        cp \"${__GIT_PROMPT_DIR}/themes/Custom.bgptemplate\" \"${HOME}/.git-prompt-colors.sh\"\n      else\n        cp \"${__GIT_PROMPT_DIR}/themes/${base}.bgptheme\" \"${HOME}/.git-prompt-colors.sh\"\n      fi\n    fi\n  fi\n}\n\n# gp_set_file_var ENVAR SOMEFILE\n#\n# If ENVAR is set, check that it's value exists as a readable file.  Otherwise,\n# Set ENVAR to the path to SOMEFILE, based on $HOME, $__GIT_PROMPT_DIR, and the\n# directory of the current script.  The SOMEFILE can be prefixed with '.', or\n# not.\n#\n# Return 0 (success) if ENVAR not already defined, 1 (failure) otherwise.\n\nfunction gp_set_file_var() {\n  local envar=\"${1}\"\n  local file=\"${2}\"\n  if eval \"[[ -n \\\"\\${${envar}+x}\\\" && -r \\\"\\${${envar}+x}\\\" ]]\" ; then # is envar set to a readable file?\n    local basefile\n    eval \"basefile=\\\"\\`basename \\\\\\\"\\${${envar}}\\\\\\\"\\`\\\"\"   # assign basefile\n    if [[ \"${basefile}\" = \"${file}\" || \"${basefile}\" = \".${file}\" ]]; then\n      return 0\n    fi\n  else  # envar is not set, or it's set to a different file than requested\n    eval \"${envar}=\"      # set empty envar\n    gp_maybe_set_envar_to_path \"${envar}\" \"${HOME}/.${file}\" \"${HOME}/${file}\" \"${HOME}/lib/${file}\" && return 0\n    gp_maybe_set_envar_to_path \"${envar}\" \"${__GIT_PROMPT_DIR}/${file}\" \"${0##*/}/${file}\" && return 0\n  fi\n  return 1\n}\n\n# gp_maybe_set_envar_to_path ENVAR FILEPATH ...\n#\n# return 0 (true) if any FILEPATH is readable, set ENVAR to it\n# return 1 (false) if not\n\nfunction gp_maybe_set_envar_to_path() {\n  local envar=\"${1}\"\n  shift\n  local file\n  for file in \"${@}\" ; do\n    if [[ -r \"${file}\" ]]; then\n      eval \"${envar}=\\\"${file}\\\"\"\n      return 0\n    fi\n  done\n  return 1\n}\n\n# git_prompt_reset\n#\n# unsets selected GIT_PROMPT variables, causing the next prompt callback to\n# recalculate them from scratch.\n\ngit_prompt_reset() {\n  local var\n  for var in GIT_PROMPT_DIR __GIT_PROMPT_COLORS_FILE __PROMPT_COLORS_FILE __GIT_STATUS_CMD GIT_PROMPT_THEME_NAME; do\n    unset ${var}\n  done\n}\n\n# gp_format_exit_status RETVAL\n#\n# echos the symbolic signal name represented by RETVAL if the process was\n# signalled, otherwise echos the original value of RETVAL\n\ngp_format_exit_status() {\n  local RETVAL=\"${1}\"\n  local SIGNAL\n  # Suppress STDERR in case RETVAL is not an integer (in such cases, RETVAL\n  # is echoed verbatim)\n  if [[ \"${RETVAL}\" -gt 128 ]] 2>/dev/null; then\n    SIGNAL=$(( RETVAL - 128 ))\n    kill -l \"${SIGNAL}\" 2>/dev/null || echo \"${RETVAL}\"\n  else\n    echo \"${RETVAL}\"\n  fi\n}\n\nfunction gp_format_username_repo() {\n    git config --get remote.origin.url | sed 's|^.*//||; s/.*@//; s/[^:/]\\+[:/]//; s/.git$//'\n}\n\nfunction git_prompt_config() {\n  #Checking if root to change output\n  _isroot=false\n  [[ \"${UID}\" -eq 0 ]] && _isroot=true\n\n  # There are two files related to colors:\n  #\n  #  prompt-colors.sh -- sets generic color names suitable for bash 'PS1' prompt\n  #  git-prompt-colors.sh -- sets the GIT_PROMPT color scheme, using names from prompt-colors.sh\n  git_prompt_load_colors\n\n  # source the user's ~/.git-prompt-colors.sh file, or the one that should be\n  # sitting in the same directory as this script\n  git_prompt_load_theme\n\n  if is_function prompt_callback; then\n    prompt_callback=\"prompt_callback\"\n  else\n    prompt_callback=\"prompt_callback_default\"\n  fi\n\n  if [[ \"${GIT_PROMPT_LAST_COMMAND_STATE:-0}\" = 0 ]]; then\n    LAST_COMMAND_INDICATOR=\"${GIT_PROMPT_COMMAND_OK}\";\n  else\n    LAST_COMMAND_INDICATOR=\"${GIT_PROMPT_COMMAND_FAIL}\";\n  fi\n\n  # replace _LAST_COMMAND_STATE_ token with the actual state\n  GIT_PROMPT_LAST_COMMAND_STATE=$(gp_format_exit_status \"${GIT_PROMPT_LAST_COMMAND_STATE}\")\n  LAST_COMMAND_INDICATOR=\"${LAST_COMMAND_INDICATOR//_LAST_COMMAND_STATE_/${GIT_PROMPT_LAST_COMMAND_STATE}}\"\n\n  # Do this only once to define PROMPT_START and PROMPT_END\n\n  if [[ -z \"${PROMPT_START:+x}\" || -z \"${PROMPT_END:+x}\" ]]; then\n\n    if [[ -z \"${GIT_PROMPT_START:+x}\" ]] ; then\n      if ${_isroot}; then\n        PROMPT_START=\"${GIT_PROMPT_START_ROOT-}\"\n      else\n        PROMPT_START=\"${GIT_PROMPT_START_USER-}\"\n      fi\n    else\n      PROMPT_START=\"${GIT_PROMPT_START-}\"\n    fi\n\n    if [[ -z \"${GIT_PROMPT_END:+x}\" ]] ; then\n      if $_isroot; then\n        PROMPT_END=\"${GIT_PROMPT_END_ROOT-}\"\n      else\n        PROMPT_END=\"${GIT_PROMPT_END_USER-}\"\n      fi\n    else\n      PROMPT_END=\"${GIT_PROMPT_END-}\"\n    fi\n  fi\n\n  # set GIT_PROMPT_LEADING_SPACE to 0 if you want to have no leading space in front of the GIT prompt\n  if [[ \"${GIT_PROMPT_LEADING_SPACE:-1}\" = \"0\" ]]; then\n    PROMPT_LEADING_SPACE=\"\"\n  else\n    PROMPT_LEADING_SPACE=\" \"\n  fi\n\n  if [[ \"${GIT_PROMPT_ONLY_IN_REPO:-0}\" == 1 ]]; then\n    EMPTY_PROMPT=\"${OLD_GITPROMPT}\"\n  elif [[ \"${GIT_PROMPT_WITH_VIRTUAL_ENV:-1}\" == 1 ]]; then\n    if [[ \"${GIT_PROMPT_VIRTUAL_ENV_AFTER_PROMPT:-0}\" == \"0\" ]]; then\n      local ps=\"$(gp_add_virtualenv_to_prompt)${PROMPT_START}$(${prompt_callback})${PROMPT_END}\"\n    else\n      local ps=\"${PROMPT_START}$(${prompt_callback})$(gp_add_virtualenv_to_prompt)${PROMPT_END}\"\n    fi\n    EMPTY_PROMPT=\"${ps//_LAST_COMMAND_INDICATOR_/${LAST_COMMAND_INDICATOR}}\"\n  else\n    local ps=\"${PROMPT_START}$(${prompt_callback})${PROMPT_END}\"\n    EMPTY_PROMPT=\"${ps//_LAST_COMMAND_INDICATOR_/${LAST_COMMAND_INDICATOR}}\"\n  fi\n\n  # fetch remote revisions every other $GIT_PROMPT_FETCH_TIMEOUT (default 5) minutes\n  if [[ -z \"${GIT_PROMPT_FETCH_TIMEOUT:+x}\" ]]; then\n    GIT_PROMPT_FETCH_TIMEOUT=\"5\"\n  fi\n  if [[ -z \"${__GIT_STATUS_CMD:+x}\" ]] ; then          # if GIT_STATUS_CMD not defined..\n    if ! gp_maybe_set_envar_to_path __GIT_STATUS_CMD \"${__GIT_PROMPT_DIR}/${GIT_PROMPT_STATUS_COMMAND}\" ; then\n      echo 1>&2 \"Cannot find ${GIT_PROMPT_STATUS_COMMAND}!\"\n    fi\n    # __GIT_STATUS_CMD defined\n  fi\n  unset GIT_BRANCH\n}\n\nfunction setLastCommandState() {\n  GIT_PROMPT_LAST_COMMAND_STATE=\"${?}\"\n  return ${GIT_PROMPT_LAST_COMMAND_STATE}\n}\n\nfunction we_are_on_repo() {\n  if [[ -e \"$(git rev-parse --git-dir 2> /dev/null)\" ]]; then\n    echo 1\n  else\n    echo 0\n  fi\n}\n\nfunction update_old_git_prompt() {\n  if [[ \"${GIT_PROMPT_OLD_DIR_WAS_GIT:-0}\" = 0 ]]; then\n    OLD_PROMPT_START=\"${PROMPT_START}\"\n    OLD_PROMPT_END=\"${PROMPT_END}\"\n    OLD_GITPROMPT=\"${PS1}\"\n  fi\n\n  GIT_PROMPT_OLD_DIR_WAS_GIT=$(we_are_on_repo)\n}\n\nfunction setGitPrompt() {\n  update_old_git_prompt\n\n  local repo=$(git rev-parse --show-toplevel 2> /dev/null)\n  if [[ ! -e \"${repo}\" ]] && [[ \"${GIT_PROMPT_ONLY_IN_REPO-}\" = 1 ]]; then\n    # we do not permit bash-git-prompt outside git repos, so nothing to do\n    PROMPT_START=${OLD_PROMPT_START}\n    PROMPT_END=${OLD_PROMPT_END}\n    PS1=\"${OLD_GITPROMPT}\"\n    return\n  fi\n\n  local EMPTY_PROMPT\n  local __GIT_STATUS_CMD\n\n  git_prompt_config\n\n  if [[ ! -e \"${repo}\" ]] || [[ \"${GIT_PROMPT_DISABLE-}\" = 1 ]]; then\n    PS1=\"${EMPTY_PROMPT}\"\n    return\n  fi\n\n  local FETCH_REMOTE_STATUS=1\n  if [[ \"${GIT_PROMPT_FETCH_REMOTE_STATUS}\" = 0 ]]; then\n    FETCH_REMOTE_STATUS=0\n  fi\n\n  unset GIT_PROMPT_IGNORE\n  OLD_GIT_PROMPT_SHOW_UNTRACKED_FILES=\"${GIT_PROMPT_SHOW_UNTRACKED_FILES}\"\n  unset GIT_PROMPT_SHOW_UNTRACKED_FILES\n\n  OLD_GIT_PROMPT_IGNORE_SUBMODULES=\"${GIT_PROMPT_IGNORE_SUBMODULES}\"\n  unset GIT_PROMPT_IGNORE_SUBMODULES\n\n  OLD_GIT_PROMPT_SHOW_TRACKING=${GIT_PROMPT_SHOW_TRACKING}\n  unset GIT_PROMPT_SHOW_TRACKING\n\n  if [[ -e \"${repo}/.bash-git-rc\" ]]; then\n    # The config file can only contain variable declarations on the form A_B=0 or G_P=all\n    local CONFIG_SYNTAX=\"^(FETCH_REMOTE_STATUS|GIT_PROMPT_SHOW_UNTRACKED_FILES|GIT_PROMPT_IGNORE_SUBMODULES|GIT_PROMPT_SHOW_TRACKING|GIT_PROMPT_IGNORE)=[0-9a-z]+$\"\n    if grep -q -v -E \"${CONFIG_SYNTAX}\" \"${repo}/.bash-git-rc\"; then\n      echo \".bash-git-rc can only contain variable values on the form NAME=value. Ignoring file.\" >&2\n    else\n      source \"${repo}/.bash-git-rc\"\n    fi\n  fi\n\n  if [[ -z \"${GIT_PROMPT_SHOW_UNTRACKED_FILES+x}\" ]]; then\n    GIT_PROMPT_SHOW_UNTRACKED_FILES=\"${OLD_GIT_PROMPT_SHOW_UNTRACKED_FILES}\"\n  fi\n  unset OLD_GIT_PROMPT_SHOW_UNTRACKED_FILES\n\n  if [[ -z \"${GIT_PROMPT_IGNORE_SUBMODULES+x}\" ]]; then\n    GIT_PROMPT_IGNORE_SUBMODULES=\"${OLD_GIT_PROMPT_IGNORE_SUBMODULES}\"\n  fi\n  unset OLD_GIT_PROMPT_IGNORE_SUBMODULES\n\n  if [[ -z \"${GIT_PROMPT_SHOW_TRACKING+x}\" ]]; then\n    GIT_PROMPT_SHOW_TRACKING=${OLD_GIT_PROMPT_SHOW_TRACKING}\n  fi\n  unset OLD_GIT_PROMPT_SHOW_TRACKING\n\n  if [[ \"${GIT_PROMPT_IGNORE-}\" = 1 ]]; then\n    PS1=\"${EMPTY_PROMPT}\"\n    return\n  fi\n\n  if [[ \"${FETCH_REMOTE_STATUS}\" = 1 ]]; then\n    checkUpstream\n  fi\n\n  updatePrompt\n}\n\n# some versions of find do not have -mmin\n_have_find_mmin=1\n\nfunction olderThanMinutes() {\n  local matches\n  local find_exit_code\n\n  if [[ -z \"${_find_command+x}\" ]]; then\n    if command -v gfind > /dev/null; then\n      _find_command=\"gfind\"\n    else\n      _find_command=\"find\"\n    fi\n  fi\n\n  if [[ \"${_have_find_mmin}\" = 1 ]]; then\n    matches=$(\"${_find_command}\" \"${1}\" -mmin +\"${2}\" 2> /dev/null)\n    find_exit_code=\"${?}\"\n    if [[ -n \"${matches}\" ]]; then\n      return 0\n    else\n      if [[ \"${find_exit_code}\" != 0 ]]; then\n        _have_find_mmin=0\n      else\n        return 1\n      fi\n    fi\n  fi\n\n  # try perl, solaris ships with perl\n  if command -v perl > /dev/null; then\n    perl -e '((time - (stat(\"'\"${1}\"'\"))[9]) / 60) > '\"${2}\"' && exit(0) || exit(1)'\n    return \"${?}\"\n  else\n    echo >&2\n    echo \"\u001b[1;31mWARNING\u001b[0m: neither a find that supports -mmin (such as GNU find) or perl is available, disabling remote status checking. Install GNU find as gfind or perl to enable this feature, or set GIT_PROMPT_FETCH_REMOTE_STATUS=0 to disable this warning.\" >&2\n    echo >&2\n    GIT_PROMPT_FETCH_REMOTE_STATUS=0\n    return 1\n  fi\n}\n\nfunction checkUpstream() {\n  local GIT_PROMPT_FETCH_TIMEOUT\n  git_prompt_config\n\n  local FETCH_HEAD=\"${repo}/.git/FETCH_HEAD\"\n  # Fech repo if local is stale for more than $GIT_FETCH_TIMEOUT minutes\n  if [[ ! -e \"${FETCH_HEAD}\" ]] || olderThanMinutes \"${FETCH_HEAD}\" \"${GIT_PROMPT_FETCH_TIMEOUT}\"\n  then\n    if [[ -n $(git remote show) ]]; then\n      (\n        if [ -n \"$ZSH_VERSION\" ]; then\n          async_run_zsh \"GIT_TERMINAL_PROMPT=0 git fetch --quiet\"\n        else\n          async_run \"GIT_TERMINAL_PROMPT=0 git fetch --quiet\"\n          disown -h\n        fi\n      )\n    fi\n  fi\n}\n\nfunction replaceSymbols() {\n  # Disable globbing, so a * could be used as symbol here\n  set -f\n\n  if [[ -z ${GIT_PROMPT_SYMBOLS_NO_REMOTE_TRACKING+x} ]]; then\n    GIT_PROMPT_SYMBOLS_NO_REMOTE_TRACKING=L\n  fi\n\n  local VALUE=\"${1//_AHEAD_/${GIT_PROMPT_SYMBOLS_AHEAD}}\"\n  local VALUE1=\"${VALUE//_BEHIND_/${GIT_PROMPT_SYMBOLS_BEHIND}}\"\n  local VALUE2=\"${VALUE1//_NO_REMOTE_TRACKING_/${GIT_PROMPT_SYMBOLS_NO_REMOTE_TRACKING}}\"\n  local VALUE3=\"${VALUE2//_PRETAG_/${GIT_PROMPT_SYMBOLS_PRETAG}}\"\n\n  echo \"${VALUE3//_PREHASH_/${GIT_PROMPT_SYMBOLS_PREHASH}}\"\n\n  # reenable globbing symbols\n  set +f\n}\n\nfunction createPrivateIndex {\n  # Create a copy of the index to avoid conflicts with parallel git commands, e.g. git rebase.\n  local __GIT_INDEX_FILE\n  local __GIT_INDEX_PRIVATE\n  if [[ -z \"${GIT_INDEX_FILE+x}\" ]]; then\n    __GIT_INDEX_FILE=\"$(git rev-parse --git-dir)/index\"\n  else\n    __GIT_INDEX_FILE=\"${GIT_INDEX_FILE}\"\n  fi\n  __GIT_INDEX_PRIVATE=\"${TMPDIR:-/tmp}/git-index-private$$\"\n  command cp \"${__GIT_INDEX_FILE}\" \"${__GIT_INDEX_PRIVATE}\" 2>/dev/null\n  echo \"${__GIT_INDEX_PRIVATE}\"\n}\n\nfunction get_branch_prefix() {\n    local GIT_BRANCH=\"${1}\"\n    local DETACHED_HEAD=\"${2}\"\n\n    case \"$GIT_BRANCH\" in\n      ${GIT_PROMPT_MASTER_BRANCHES})\n        local IS_MASTER_BRANCH=1\n        ;;\n      *)\n        local IS_MASTER_BRANCH=0\n        ;;\n    esac\n\n    if [[ \"$IS_MASTER_BRANCH\" == \"1\" ]]; then\n        echo \"$GIT_PROMPT_MASTER_BRANCH\"\n    elif [[ \"$DETACHED_HEAD\" = \"1\" ]]; then\n        echo \"$GIT_PROMPT_DETACHED_HEAD\"\n    else\n        echo \"$GIT_PROMPT_BRANCH\"\n    fi\n}\n\nfunction updatePrompt() {\n  local LAST_COMMAND_INDICATOR\n  local PROMPT_LEADING_SPACE\n  local PROMPT_START\n  local PROMPT_END\n  local EMPTY_PROMPT\n  local Blue=\"\\[\\033[0;34m\\]\"\n  if [ -n \"$ZSH_VERSION\" ]; then\n    Blue='%{fg[blue]%}'\n  fi\n\n  git_prompt_config\n\n  export __GIT_PROMPT_IGNORE_STASH=\"${GIT_PROMPT_IGNORE_STASH:-0}\"\n  export __GIT_PROMPT_SHOW_UPSTREAM=\"${GIT_PROMPT_SHOW_UPSTREAM:-0}\"\n  export __GIT_PROMPT_IGNORE_SUBMODULES=\"${GIT_PROMPT_IGNORE_SUBMODULES:-0}\"\n  export __GIT_PROMPT_WITH_USERNAME_AND_REPO=\"${GIT_PROMPT_WITH_USERNAME_AND_REPO:-0}\"\n  export __GIT_PROMPT_SHOW_TRACKING=${GIT_PROMPT_SHOW_TRACKING:-1}\n  export __GIT_PROMPT_SHOW_UNTRACKED_FILES=\"${GIT_PROMPT_SHOW_UNTRACKED_FILES-normal}\"\n  export __GIT_PROMPT_SHOW_CHANGED_FILES_COUNT=\"${GIT_PROMPT_SHOW_CHANGED_FILES_COUNT:-1}\"\n\n  local GIT_INDEX_PRIVATE=\"$(createPrivateIndex)\"\n  #important to define GIT_INDEX_FILE as local: This way it only affects this function (and below) - even with the export afterwards\n  local GIT_INDEX_FILE\n  export GIT_INDEX_FILE=\"${GIT_INDEX_PRIVATE}\"\n\n  local -a git_status_fields\n  while IFS=$'\\n' read -r line; do git_status_fields+=(\"${line}\"); done < <(\"${__GIT_STATUS_CMD}\" 2>/dev/null)\n\n  export GIT_BRANCH=$(replaceSymbols \"${git_status_fields[@]:0:1}\")\n  if [[ $__GIT_PROMPT_SHOW_TRACKING != \"0\" ]]; then\n    local GIT_REMOTE=\"$(replaceSymbols \"${git_status_fields[@]:1:1}\")\"\n    if [[ \".\" == \"${GIT_REMOTE}\" ]]; then\n      unset GIT_REMOTE\n    fi\n  fi\n  local GIT_REMOTE_USERNAME_REPO=\"$(replaceSymbols \"${git_status_fields[@]:2:1}\")\"\n  if [[ \".\" == \"${GIT_REMOTE_USERNAME_REPO}\" ]]; then\n    unset GIT_REMOTE_USERNAME_REPO\n  fi\n\n  local GIT_FORMATTED_UPSTREAM\n  local GIT_UPSTREAM_PRIVATE=\"${git_status_fields[@]:3:1}\"\n  if [[ \"${__GIT_PROMPT_SHOW_UPSTREAM:-0}\" != \"1\" || \"^\" == \"${GIT_UPSTREAM_PRIVATE}\" ]]; then\n    unset GIT_FORMATTED_UPSTREAM\n  else\n    GIT_FORMATTED_UPSTREAM=\"${GIT_PROMPT_UPSTREAM//_UPSTREAM_/${GIT_UPSTREAM_PRIVATE}}\"\n  fi\n\n  local GIT_STAGED=\"${git_status_fields[@]:4:1}\"\n  local GIT_CONFLICTS=\"${git_status_fields[@]:5:1}\"\n  local GIT_CHANGED=\"${git_status_fields[@]:6:1}\"\n  local GIT_UNTRACKED=\"${git_status_fields[@]:7:1}\"\n  local GIT_STASHED=\"${git_status_fields[@]:8:1}\"\n  local GIT_CLEAN=\"${git_status_fields[@]:9:1}\"\n  local GIT_DETACHED_HEAD=\"${git_status_fields[@]:10:1}\"\n\n  local NEW_PROMPT=\"${EMPTY_PROMPT}\"\n  if [[ \"${#git_status_fields[@]}\" -gt 0 ]]; then\n\n    if [[ -z \"${GIT_REMOTE_USERNAME_REPO+x}\" ]]; then\n      local GIT_PROMPT_PREFIX_FINAL=\"${GIT_PROMPT_PREFIX//_USERNAME_REPO_/${ResetColor}}\"\n    else\n      if [[ -z \"${GIT_PROMPT_USERNAME_REPO_SEPARATOR+x}\" ]]; then\n        local GIT_PROMPT_PREFIX_FINAL=\"${GIT_PROMPT_PREFIX//_USERNAME_REPO_/${GIT_REMOTE_USERNAME_REPO}${ResetColor}}\"\n      else\n        local GIT_PROMPT_PREFIX_FINAL=\"${GIT_PROMPT_PREFIX//_USERNAME_REPO_/${GIT_REMOTE_USERNAME_REPO}${ResetColor}${GIT_PROMPT_USERNAME_REPO_SEPARATOR}}\"\n      fi\n    fi\n\n    local BRANCH_PREFIX=\"$(get_branch_prefix $GIT_BRANCH $GIT_DETACHED_HEAD)\"\n    local STATUS_PREFIX=\"${PROMPT_LEADING_SPACE}${GIT_PROMPT_PREFIX_FINAL}${BRANCH_PREFIX}\\${GIT_BRANCH}${ResetColor}${GIT_FORMATTED_UPSTREAM}\"\n    local STATUS=\"\"\n\n    # __add_status KIND VALEXPR INSERT\n    # eg: __add_status  'STAGED' '-ne 0'\n\n    __chk_gitvar_status() {\n      local v\n      if [[ \"${2-}\" = \"-n\" ]] ; then\n        v=\"${2} \\\"\\${GIT_${1}-}\\\"\"\n      else\n        v=\"\\${GIT_${1}-} ${2}\"\n      fi\n      if eval \"[[ ${v} ]]\" ; then\n        if [[ \"${3-}\" != '-' ]] && [[ \"${__GIT_PROMPT_SHOW_CHANGED_FILES_COUNT}\" == \"1\" || \"${1-}\" == \"REMOTE\" ]]; then\n          __add_status \"\\${GIT_PROMPT_${1}}\\${GIT_${1}}\\${ResetColor}\"\n        else\n          __add_status \"\\${GIT_PROMPT_${1}}\\${ResetColor}\"\n        fi\n      fi\n    }\n\n    __add_gitvar_status() {\n      __add_status \"\\${GIT_PROMPT_${1}}\\${GIT_${1}}\\${ResetColor}\"\n    }\n\n    # __add_status SOMETEXT\n    __add_status() {\n      eval \"STATUS=\\\"${STATUS}${1}\\\"\"\n    }\n\n    __chk_gitvar_status 'REMOTE'       '-n'\n    if [[ \"${GIT_CLEAN}\" -eq 0 ]] || [[ \"${GIT_PROMPT_CLEAN}\" != \"\" ]]; then\n      __add_status        \"${GIT_PROMPT_SEPARATOR}\"\n      __chk_gitvar_status 'STAGED'     '!= \"0\" && ${GIT_STAGED-} != \"^\"'\n      __chk_gitvar_status 'CONFLICTS'  '!= \"0\"'\n      __chk_gitvar_status 'CHANGED'    '!= \"0\"'\n      __chk_gitvar_status 'UNTRACKED'  '!= \"0\"'\n      __chk_gitvar_status 'STASHED'    '!= \"0\"'\n      __chk_gitvar_status 'CLEAN'      '= \"1\"'   -\n    fi\n    __add_status        \"${ResetColor}${GIT_PROMPT_SUFFIX}\"\n\n    if [[ \"${GIT_PROMPT_VIRTUAL_ENV_AFTER_PROMPT:-0}\" == \"0\" ]]; then\n      NEW_PROMPT=\"$(gp_add_virtualenv_to_prompt)${PROMPT_START}$(${prompt_callback})${STATUS_PREFIX}${STATUS}${PROMPT_END}\"\n    else\n      NEW_PROMPT=\"${PROMPT_START}$(${prompt_callback})$(gp_add_virtualenv_to_prompt)${STATUS_PREFIX}${STATUS}${PROMPT_END}\"\n    fi\n  else\n    NEW_PROMPT=\"${EMPTY_PROMPT}\"\n  fi\n\n  PS1=\"${NEW_PROMPT//_LAST_COMMAND_INDICATOR_/${LAST_COMMAND_INDICATOR}${ResetColor}}\"\n  command rm \"${GIT_INDEX_PRIVATE}\" 2>/dev/null\n}\n\n# Helper function that returns virtual env information to be set in prompt\n# Honors virtualenvs own setting VIRTUAL_ENV_DISABLE_PROMPT\nfunction gp_add_virtualenv_to_prompt {\n  local ACCUMULATED_VENV_PROMPT=\"\"\n  local VENV=\"\"\n  if [[ -n \"${VIRTUAL_ENV-}\" && -z \"${VIRTUAL_ENV_DISABLE_PROMPT+x}\" ]]; then\n    if [[ -n \"${VIRTUAL_ENV_PROMPT-}\" ]]; then\n      # first trim any starting white space and parenthesis, and then do the same to the end\n      VENV=\"${VIRTUAL_ENV_PROMPT#\"${VIRTUAL_ENV_PROMPT%%[![:space:]]*}(\"}\"\n      VENV=\"${VENV%\")${VENV##*[![:space:]]}\"}\"\n    else\n      VENV=$(basename \"${VIRTUAL_ENV}\")\n    fi\n    ACCUMULATED_VENV_PROMPT=\"${ACCUMULATED_VENV_PROMPT}${GIT_PROMPT_VIRTUALENV//_VIRTUALENV_/${VENV}}\"\n  fi\n  if [[ -n \"${NODE_VIRTUAL_ENV-}\" && -z \"${NODE_VIRTUAL_ENV_DISABLE_PROMPT+x}\" ]]; then\n    VENV=$(basename \"${NODE_VIRTUAL_ENV}\")\n    ACCUMULATED_VENV_PROMPT=\"${ACCUMULATED_VENV_PROMPT}${GIT_PROMPT_VIRTUALENV//_VIRTUALENV_/${VENV}}\"\n  fi\n  if [[ -n \"${CONDA_DEFAULT_ENV-}\" ]]; then\n    VENV=$(basename \"${CONDA_DEFAULT_ENV}\")\n    ACCUMULATED_VENV_PROMPT=\"${ACCUMULATED_VENV_PROMPT}${GIT_PROMPT_VIRTUALENV//_VIRTUALENV_/${VENV}}\"\n  fi\n  echo \"${ACCUMULATED_VENV_PROMPT}\"\n}\n\n# Use exit status from declare command to determine whether input argument is a\n# bash function\nfunction is_function {\n  declare -Ff \"${1}\" >/dev/null;\n}\n\n# Helper function that truncates $PWD depending on window width\n# Optionally specify maximum length as parameter (defaults to 1/3 of terminal)\nfunction gp_truncate_pwd {\n  local tilde=\"~\"\n  local newPWD=\"${PWD/#${HOME}/${tilde}}\"\n  local pwdmaxlen=\"${1:-$((${COLUMNS:-80}/3))}\"\n  [[ \"${#newPWD}\" -gt \"${pwdmaxlen}\" ]] && newPWD=\"...${newPWD:3-$pwdmaxlen}\"\n  echo -n \"${newPWD}\"\n}\n\n# Sets the window title to the given argument string\nfunction gp_set_window_title {\n  echo -ne \"\\[\\033]0;$1\\007\\]\"\n}\n\nfunction prompt_callback_default {\n  return\n}\n\n# toggle gitprompt\nfunction git_prompt_toggle() {\n  if [[ \"${GIT_PROMPT_DISABLE:-0}\" = 1 ]]; then\n    GIT_PROMPT_DISABLE=0\n  else\n    GIT_PROMPT_DISABLE=1\n  fi\n  return\n}\n\nfunction make_prompt_command_clean() {\n  PROMPT_COMMAND=\"${PROMPT_COMMAND//$'\\n'/;}\" # convert all new lines to semi-colons\n  PROMPT_COMMAND=\"${PROMPT_COMMAND#\\;}\" # remove leading semi-colon\n  PROMPT_COMMAND=\"${PROMPT_COMMAND%% }\" # remove trailing spaces\n  PROMPT_COMMAND=\"${PROMPT_COMMAND%\\;}\" # remove trailing semi-colon\n}\n\nfunction add_prompt_command() {\n  local new_entry=\"$1\"\n  local insert_before=\"$2\"\n\n  if [[ \";${PROMPT_COMMAND};\" == *\";${new_entry};\"* ]]; then\n    return 0\n  fi\n\n  if [[ -z \"$PROMPT_COMMAND\" ]]; then\n    PROMPT_COMMAND=\"$new_entry\"\n    return 0\n  fi\n\n  if [[ \"$insert_before\" == \"true\" ]]; then\n    PROMPT_COMMAND=\"${new_entry};${PROMPT_COMMAND}\"\n  else\n    PROMPT_COMMAND=\"${PROMPT_COMMAND};${new_entry}\"\n  fi\n}\n\nfunction add_to_beginning_of_prompt_command() {\n  add_prompt_command \"$1\" \"true\"\n}\n\nfunction add_to_end_of_prompt_command() {\n  add_prompt_command \"$1\" \"false\"\n}\n\nfunction gp_install_prompt {\n  # 5.1 supports PROMPT_COMMAND as an array\n  if ((BASH_VERSINFO[0] > 5 || BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 1)); then\n    if [[ $(declare -p PROMPT_COMMAND 2>/dev/null) == \"declare --\"* ]]; then\n      make_prompt_command_clean\n      add_to_end_of_prompt_command \"setGitPrompt\"\n      add_to_beginning_of_prompt_command \"setLastCommandState\"\n    else\n      if [[ \"${PROMPT_COMMAND[*]}\" != *setGitPrompt* ]]; then\n        PROMPT_COMMAND+=(setGitPrompt)\n      fi\n      if [[ \"${PROMPT_COMMAND[*]}\" != *setLastCommandState* ]]; then\n        PROMPT_COMMAND=(setLastCommandState \"${PROMPT_COMMAND[@]}\")\n      fi\n    fi\n  else\n    make_prompt_command_clean\n    add_to_end_of_prompt_command \"setGitPrompt\"\n    add_to_beginning_of_prompt_command \"setLastCommandState\"\n  fi\n\n  set_git_prompt_dir\n  source \"${__GIT_PROMPT_DIR}/git-prompt-help.sh\"\n}\n\ngp_install_prompt\n"
        },
        {
          "name": "gitstatus.py",
          "type": "blob",
          "size": 4.7431640625,
          "content": "#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n\"\"\"This module defines a Print function to use with python 2.x or 3.x., so we can use the prompt with older versions of\nPython too\n\nIt's interface is that of python 3.0's print. See\nhttp://docs.python.org/3.0/library/functions.html?highlight=print#print\n\nShamelessly ripped from\nhttp://www.daniweb.com/software-development/python/code/217214/a-print-function-for-different-versions-of-python\n\"\"\"\n# change those symbols to whatever you prefer\nsymbols = {'ahead of': '↑·', 'behind': '↓·', 'prehash': ':'}\n\nimport os\nimport sys\nimport re\nfrom subprocess import Popen, PIPE\n\n__all__ = [\"Print\"]\n\ntry:\n    Print = eval(\"print\")  # python 3.0 case\n    python_version = 3\n    to_str = str\nexcept SyntaxError as e:\n    python_version = 2\n    to_str = unicode\n    D = dict()\n    try:\n        exec (\"from __future__ import print_function\\np=print\", D)\n        Print = D[\"p\"]  # 2.6 case\n    except SyntaxError:\n        def Print(*args, **kwd):  # 2.4, 2.5, define our own Print function\n            fout = kwd.get(\"file\", sys.stdout)\n            w = fout.write\n            if args:\n                w(str(args[0]))\n                sep = kwd.get(\"sep\", \" \")\n                for a in args[1:]:\n                    w(sep)\n                    w(str(a))\n            w(kwd.get(\"end\", \"\\n\"))\n    finally:\n        del D\n\n\ndef get_tag_or_hash():\n    cmd = Popen(['git', 'describe', '--exact-match'], stdout=PIPE, stderr=PIPE)\n    so, se = cmd.communicate()\n    tag = '%s' % so.decode('utf-8').strip()\n\n    if tag:\n        return tag\n    else:\n        cmd = Popen(['git', 'rev-parse', '--short', 'HEAD'], stdout=PIPE, stderr=PIPE)\n        so, se = cmd.communicate()\n        hash_name = '%s' % so.decode('utf-8').strip()\n        return ''.join([symbols['prehash'], hash_name])\n\n\ndef get_stash():\n    cmd = Popen(['git', 'rev-parse', '--git-dir'], stdout=PIPE, stderr=PIPE)\n    so, se = cmd.communicate()\n    stash_file = '%s%s' % (so.decode('utf-8').rstrip(), '/logs/refs/stash')\n\n    try:\n        with open(stash_file) as f:\n            return sum(1 for _ in f)\n    except IOError:\n        return 0\n\n\n# `git status --porcelain --branch` can collect all information\n# branch, remote_branch, untracked, staged, changed, conflicts, ahead, behind\npo = Popen(['git', 'status', '--porcelain', '--branch'],\n           env={'HOME': os.environ['HOME'], 'LC_ALL': 'C'}, stdout=PIPE, stderr=PIPE)\nstdout, stderr = po.communicate()\nif po.returncode != 0:\n    sys.exit(0)  # Not a git repository\n\n# collect git status information\nuntracked, staged, changed, conflicts = [], [], [], []\nnum_ahead, num_behind = 0, 0\nahead, behind = '', ''\nbranch = ''\nremote = ''\nstatus = [(line[0], line[1], line[2:]) for line in stdout.decode('utf-8').splitlines()]\nfor st in status:\n    if st[0] == '#' and st[1] == '#':\n        if re.search('Initial commit on', st[2]):\n            branch = st[2].split(' ')[-1]\n        elif re.search('No commits yet on', st[2]):\n            branch = st[2].split(' ')[-1]\n        elif re.search('no branch', st[2]):  # detached status\n            branch = get_tag_or_hash()\n        elif len(st[2].strip().split('...')) == 1:\n            branch = st[2].strip()\n        else:\n            # current and remote branch info\n            branch, rest = st[2].strip().split('...')\n            if len(rest.split(' ')) == 1:\n                # remote_branch = rest.split(' ')[0]\n                pass\n            else:\n                # ahead or behind\n                divergence = ' '.join(rest.split(' ')[1:])\n                divergence = divergence.lstrip('[').rstrip(']')\n                for div in divergence.split(', '):\n                    if 'ahead' in div:\n                        num_ahead = int(div[len('ahead '):].strip())\n                        ahead = '%s%s' % (symbols['ahead of'], num_ahead)\n                    elif 'behind' in div:\n                        num_behind = int(div[len('behind '):].strip())\n                        behind = '%s%s' % (symbols['behind'], num_behind)\n                remote = ''.join([behind, ahead])\n    elif st[0] == '?' and st[1] == '?':\n        untracked.append(st)\n    else:\n        if st[1] == 'M':\n            changed.append(st)\n        if st[0] == 'U':\n            conflicts.append(st)\n        elif st[0] != ' ':\n            staged.append(st)\n\nstashed = get_stash()\nif not changed and not staged and not conflicts and not untracked and not stashed:\n    clean = 1\nelse:\n    clean = 0\n\nif remote == \"\":\n    remote = '.'\n\nif python_version == 2:\n    remote = remote.decode('utf-8')\n\nout = '\\n'.join([\n    branch,\n    remote,\n    to_str(len(staged)),\n    to_str(len(conflicts)),\n    to_str(len(changed)),\n    to_str(len(untracked)),\n    to_str(stashed),\n    to_str(clean),\n    to_str(python_version),\n])\n\n\nif python_version == 2:\n    Print(out.encode('utf-8'))\nelse:\n    Print(out)\n"
        },
        {
          "name": "gitstatus.sh",
          "type": "blob",
          "size": 5.4638671875,
          "content": "#!/usr/bin/env bash\n# -*- coding: utf-8 -*-\n# gitstatus.sh -- produce the current git repo status on STDOUT\n# Functionally equivalent to 'gitstatus.py', but written in bash (not python).\n#\n# Alan K. Stebbens <aks@stebbens.org> [http://github.com/aks]\n\nset -u\n\nif [[ -z \"${__GIT_PROMPT_DIR:+x}\" ]]; then\n  SOURCE=\"${BASH_SOURCE[0]}\"\n  while [[ -h \"${SOURCE}\" ]]; do\n    DIR=\"$( cd -P \"$( dirname \"${SOURCE}\" )\" && pwd )\"\n    SOURCE=\"$(readlink \"${SOURCE}\")\"\n    [[ \"${SOURCE}\" != /* ]] && SOURCE=\"${DIR}/${SOURCE}\"\n  done\n  __GIT_PROMPT_DIR=\"$( cd -P \"$( dirname \"${SOURCE}\" )\" && pwd )\"\nfi\n\nif [[ \"${__GIT_PROMPT_IGNORE_SUBMODULES:-0}\" == \"1\" ]]; then\n  _ignore_submodules=\"--ignore-submodules\"\nelse\n  _ignore_submodules=\"\"\nfi\n\nif [[ \"${__GIT_PROMPT_WITH_USERNAME_AND_REPO:-0}\" == \"1\" ]]; then\n  # returns \"user/repo\" from remote.origin.url git variable\n  #\n  # supports urls:\n  # https://user@bitbucket.org/user/repo.git\n  # https://github.com/user/repo.git\n  # git@github.com:user/repo.git\n  #\n  remote_url=$(git config --get remote.origin.url | sed 's|^.*//||; s/.*@//; s/[^:/]\\+[:/]//; s/.git$//')\nelse\n  remote_url='.'\nfi\n\n# shellcheck disable=SC2086\ngitstatus=$( LC_ALL=C git --no-optional-locks status ${_ignore_submodules} --untracked-files=\"${__GIT_PROMPT_SHOW_UNTRACKED_FILES:-normal}\" --porcelain --branch )\n\n# if the status is fatal, exit now\n[[ ! \"${?}\" ]] && exit 0\n\ngit_dir=\"$(git rev-parse --git-dir 2>/dev/null)\"\n[[ -z \"${git_dir:+x}\" ]] && exit 0\n\n__git_prompt_read ()\n{\n  local f=\"${1}\"\n  shift\n  [[ -r \"${f}\" ]] && read -r \"${@}\" <\"${f}\"\n}\n\nstate=\"\"\nstep=\"\"\ntotal=\"\"\nif [[ -d \"${git_dir}/rebase-merge\" ]]; then\n  __git_prompt_read \"${git_dir}/rebase-merge/msgnum\" step\n  __git_prompt_read \"${git_dir}/rebase-merge/end\" total\n  if [[ -f \"${git_dir}/rebase-merge/interactive\" ]]; then\n    state=\"|REBASE-i\"\n  else\n    state=\"|REBASE-m\"\n  fi\nelse\n  if [[ -d \"${git_dir}/rebase-apply\" ]]; then\n    __git_prompt_read \"${git_dir}/rebase-apply/next\" step\n    __git_prompt_read \"${git_dir}/rebase-apply/last\" total\n    if [[ -f \"${git_dir}/rebase-apply/rebasing\" ]]; then\n      state=\"|REBASE\"\n    elif [[ -f \"${git_dir}/rebase-apply/applying\" ]]; then\n      state=\"|AM\"\n    else\n      state=\"|AM/REBASE\"\n    fi\n  elif [[ -f \"${git_dir}/MERGE_HEAD\" ]]; then\n    state=\"|MERGING\"\n  elif [[ -f \"${git_dir}/CHERRY_PICK_HEAD\" ]]; then\n    state=\"|CHERRY-PICKING\"\n  elif [[ -f \"${git_dir}/REVERT_HEAD\" ]]; then\n    state=\"|REVERTING\"\n  elif [[ -f \"${git_dir}/BISECT_LOG\" ]]; then\n    state=\"|BISECTING\"\n  fi\nfi\n\nif [[ -n \"${step}\" ]] && [[ -n \"${total}\" ]]; then\n  state=\"${state} ${step}/${total}\"\nfi\n\nnum_staged=0\nnum_changed=0\nnum_conflicts=0\nnum_untracked=0\nwhile IFS='' read -r line || [[ -n \"${line}\" ]]; do\n  status=\"${line:0:2}\"\n  while [[ -n ${status} ]]; do\n    case \"${status}\" in\n      #two fixed character matches, loop finished\n      \\#\\#) branch_line=\"${line/\\.\\.\\./^}\"; break ;;\n      \\?\\?) ((num_untracked++)); break ;;\n      U?) ((num_conflicts++)); break;;\n      ?U) ((num_conflicts++)); break;;\n      DD) ((num_conflicts++)); break;;\n      AA) ((num_conflicts++)); break;;\n      #two character matches, first loop\n      ?M) ((num_changed++)) ;;\n      ?\\ ) ;;\n      #single character matches, second loop\n      U) ((num_conflicts++)) ;;\n      \\ ) ;;\n      *) ((num_staged++)) ;;\n    esac\n    status=\"${status:0:(${#status}-1)}\"\n  done\ndone <<< \"${gitstatus}\"\n\nnum_stashed=0\nif [[ \"${__GIT_PROMPT_IGNORE_STASH:-0}\" != \"1\" ]]; then\n  stash_file=\"${git_dir}/logs/refs/stash\"\n  if [[ -e \"${stash_file}\" ]]; then\n    while IFS='' read -r wcline || [[ -n \"${wcline}\" ]]; do\n      ((num_stashed++))\n    done < \"${stash_file}\"\n  fi\nfi\n\nclean=0\nif (( num_changed == 0 && num_staged == 0 && num_untracked == 0 && num_stashed == 0 && num_conflicts == 0)) ; then\n  clean=1\nfi\n\nIFS=\"^\" read -ra branch_fields <<< \"${branch_line/\\#\\# }\"\nbranch=\"${branch_fields[@]:0:1}\"\nremote=\"\"\nupstream=\"\"\n\ndetached_head=0\n\nif [[ \"${branch}\" == *\"Initial commit on\"* ]]; then\n  IFS=\" \" read -ra fields <<< \"${branch}\"\n  branch=\"${fields[@]:3:1}\"\n  remote=\"_NO_REMOTE_TRACKING_\"\n  remote_url='.'\nelif [[ \"${branch}\" == *\"No commits yet on\"* ]]; then\n  IFS=\" \" read -ra fields <<< \"${branch}\"\n  branch=\"${fields[@]:4:1}\"\n  remote=\"_NO_REMOTE_TRACKING_\"\n  remote_url='.'\nelif [[ \"${branch}\" == *\"no branch\"* ]]; then\n  tag=$( git describe --tags --exact-match )\n  if [[ -n \"${tag}\" ]]; then\n    branch=\"_PRETAG_${tag}\"\n    detached_head=1\n  else\n    branch=\"_PREHASH_$( git rev-parse --short HEAD )\"\n    detached_head=1\n  fi\nelse\n  if [[ \"${#branch_fields[@]}\" -eq 1 ]]; then\n    remote=\"_NO_REMOTE_TRACKING_\"\n    remote_url='.'\n  else\n    IFS=\"[,]\" read -ra remote_fields <<< \"${branch_fields[1]}\"\n    upstream=\"${remote_fields[@]:0:1}\"\n    for remote_field in \"${remote_fields[@]}\"; do\n      if [[ \"${remote_field}\" == \"ahead \"* ]]; then\n        num_ahead=\"${remote_field:6}\"\n        ahead=\"_AHEAD_${num_ahead}\"\n      fi\n      if [[ \"${remote_field}\" == \"behind \"* ]] || [[ \"${remote_field}\" == \" behind \"* ]]; then\n        num_behind=\"${remote_field:7}\"\n        behind=\"_BEHIND_${num_behind# }\"\n      fi\n    done\n    remote=\"${behind-}${ahead-}\"\n  fi\nfi\n\nif [[ -z \"${remote:+x}\" ]] ; then\n  remote='.'\nfi\n\nif [[ -z \"${upstream:+x}\" ]] ; then\n  upstream='^'\nfi\n\nUPSTREAM_TRIMMED=$(echo $upstream | xargs)\n\nprintf \"%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n\" \\\n  \"${branch}${state}\" \\\n  \"${remote}\" \\\n  \"${remote_url}\" \\\n  \"${UPSTREAM_TRIMMED}\" \\\n  \"${num_staged}\" \\\n  \"${num_conflicts}\" \\\n  \"${num_changed}\" \\\n  \"${num_untracked}\" \\\n  \"${num_stashed}\" \\\n  \"${clean}\" \\\n  \"${detached_head}\"\n\nexit\n"
        },
        {
          "name": "gitstatus_pre-1.7.10.sh",
          "type": "blob",
          "size": 3.875,
          "content": "#!/usr/bin/env bash\n# -*- coding: UTF-8 -*-\n# gitstatus.sh -- produce the current git repo status on STDOUT\n# Functionally equivalent to 'gitstatus.py', but written in bash (not python).\n#\n# Alan K. Stebbens <aks@stebbens.org> [http://github.com/aks]\n\n# helper functions\ncount_lines() { echo \"${1}\" | grep -Ec \"^${2}\" ; }\nall_lines() { echo \"${1}\" | grep -v \"^$\" | wc -l ; }\n\nif [[ -z \"${__GIT_PROMPT_DIR-}\" ]]; then\n  SOURCE=\"${BASH_SOURCE[0]}\"\n  while [[ -h \"${SOURCE}\" ]]; do\n    DIR=\"$( cd -P \"$( dirname \"${SOURCE}\" )\" && pwd )\"\n    SOURCE=\"$(readlink \"${SOURCE}\")\"\n    [[ \"${SOURCE}\" != /* ]] && SOURCE=\"${DIR}/${SOURCE}\"\n  done\n  __GIT_PROMPT_DIR=\"$( cd -P \"$( dirname \"${SOURCE}\" )\" && pwd )\"\nfi\n\nif [[ \"${__GIT_PROMPT_WITH_USERNAME_AND_REPO}\" == \"1\" ]]; then\n  # returns \"user/repo\" from remote.origin.url git variable\n  #\n  # supports urls:\n  # https://user@bitbucket.org/user/repo.git\n  # https://github.com/user/repo.git\n  # git@github.com:user/repo.git\n  #\n  remote_url=$(git config --get remote.origin.url | sed 's|^.*//||; s/.*@//; s/[^:/]\\+[:/]//; s/.git$//')\nelse\n  remote_url='.'\nfi\n\ngitsym=$( git symbolic-ref HEAD 2>/dev/null )\n\n#If exit status OK, we have a branch\nif [[ \"${?}\" == 0 ]]; then\n  # the current branch is the tail end of the symbolic reference\n  branch=\"${gitsym##refs/heads/}\"    # get the basename after \"refs/heads/\"\nfi\n\ngitstatus=$( git diff --name-status 2>&1 )\n\n# if the diff is fatal, exit now\nif [[ \"${?}\" != 0 ]]; then exit 0; fi\n\nstaged_files=$( git diff --staged --name-status )\n\nnum_changed=$(( $( all_lines \"${gitstatus}\" ) - $( count_lines \"${gitstatus}\" U ) ))\nnum_conflicts=$( count_lines \"${staged_files}\" U )\nnum_staged=$(( $( all_lines \"${staged_files}\" ) - num_conflicts ))\nnum_untracked=$( git ls-files --others --exclude-standard $(git rev-parse --show-cdup) | wc -l )\n\nnum_stashed=0\nif [[ \"${__GIT_PROMPT_IGNORE_STASH}\" != \"1\" ]]; then\n  stash_file=\"$( git rev-parse --git-dir )/logs/refs/stash\"\n  if [[ -e \"${stash_file}\" ]]; then\n    while IFS='' read -r wcline || [[ -n \"${wcline}\" ]]; do\n      ((num_stashed++))\n    done < \"${stash_file}\"\n  fi\nfi\n\nclean=0\nif (( num_changed == 0 && num_staged == 0 && num_untracked == 0 && num_stashed == 0 && num_conflicts == 0 )) ; then\n  clean=1\nfi\n\nremote=\"\"\nupstream=\"\"\n\nif [[ -z \"${branch-}\" ]]; then\n  tag=$( git describe --tags --exact-match 2>/dev/null )\n  if [[ -n \"${tag}\" ]]; then\n    branch=\"${tag}\"\n  else\n    branch=\"_PREHASH_$( git rev-parse --short HEAD )\"\n  fi\nelse\n  remote_name=$( git config \"branch.${branch}.remote\" )\n\n  if [[ -n \"$remote_name\" ]]; then\n    merge_name=$( git config \"branch.${branch}.merge\" )\n  else\n    remote_name='origin'\n    merge_name=\"refs/heads/${branch}\"\n  fi\n\n  if [[ \"${remote_name}\" == '.' ]]; then\n    remote_ref=\"${merge_name}\"\n  else\n    remote_ref=\"refs/remotes/${remote_name}/${merge_name##refs/heads/}\"\n  fi\n\n  # detect if the local branch have a remote tracking branch\n  upstream=$( git rev-parse --abbrev-ref \"${branch}\"@{upstream} 2>&1 )\n  if [[ \"${?}\" == 0 ]]; then\n     # get the revision list, and count the leading \"<\" and \">\"\n    revgit=$( git rev-list --left-right \"${remote_ref}...HEAD\" 2>/dev/null )\n    if [[ \"${?}\" == 0 ]]; then\n      num_revs=$( all_lines \"${revgit}\" )\n      num_ahead=$( count_lines \"${revgit}\" \"^>\" )\n      num_behind=$(( num_revs - num_ahead ))\n      if (( num_behind > 0 )) ; then\n        remote=\"${remote}_BEHIND_${num_behind}\"\n      fi\n      if (( num_ahead > 0 )) ; then\n        remote=\"${remote}_AHEAD_${num_ahead}\"\n      fi\n    fi\n  else\n    remote='_NO_REMOTE_TRACKING_'\n    remote_url='.'\n    unset upstream\n  fi\nfi\n\nif [[ -z \"${remote:+x}\" ]] ; then\n  remote='.'\nfi\n\nif [[ -z \"${upstream:+x}\" ]] ; then\n  upstream='^'\nfi\n\nprintf \"%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n\" \\\n  \"${branch}\" \\\n  \"${remote}\" \\\n  \"${remote_url}\" \\\n  \"${upstream}\" \\\n  \"${num_staged}\" \\\n  \"${num_conflicts}\" \\\n  \"${num_changed}\" \\\n  \"${num_untracked// /}\" \\\n  \"${num_stashed}\" \\\n  \"${clean}\"\n\nexit\n"
        },
        {
          "name": "prompt-colors.sh",
          "type": "blob",
          "size": 2.970703125,
          "content": "#!/usr/bin/env bash\n# prompt-colors.sh\n#\n# source this file to get color definitions\n# are also printed to STDERR.\n\n# bash/zsh cross compatibility notes:\n# - using colors modules to set colors in zsh, please autoload it\n# - Dim colors, Intense Black not supported in zsh\n\ndefine_color_names() {\n\n  ColorNames=( Black Red Green Yellow Blue Magenta Cyan White )\n  FgColors=(    30   31   32    33     34   35      36   37  )\n  BgColors=(    40   41   42    43     44   45      46   47  )\n\n  local AttrNorm=0\n  local AttrBright=1\n  local AttrDim=2\n  local AttrUnder=4\n  local AttrBlink=5\n  local AttrRev=7\n  local AttrHide=8\n\n  # define \"BoldCOLOR\", \"BrightCOLOR\", and \"DimCOLOR\" names\n\n  # _map_colors ATTRNAME ATTRVALUE\n  #\n  # Defines three names for every color, attribute combintaion:\n  #    {ATTRNAME}{COLORNAME}\n  #    {ATTRNAME}{COLORNAME}Fg\n  #    {ATTRNAME}{COLORNAME}Bg\n  #\n  # Example: BoldRed, BoldRedFg, BoldRedBg\n\n  _map_colors() {\n    local x=0\n    local attrname=\"${1}\"\n    local attrcode=\"${2}\"\n    while (( x < 8 )) ; do\n      local colorname=\"${ColorNames[@]:$x:1}\"\n      local fgcolorcode=\"${FgColors[@]:$x:1}\"\n      local bgcolorcode=\"${BgColors[@]:$x:1}\"\n      longcolorname=\"${attrname}${colorname}\"\n\n      if [ -n \"$ZSH_VERSION\" ]; then\n        # zsh\n        lowercolorname=$(echo $colorname | tr '[A-Z]' '[a-z]')\n        _def_color_zsh \"${longcolorname}\"   \"${attrcode}\" \"${lowercolorname}\" \"fg\"\n        _def_color_zsh \"${longcolorname}Fg\" \"${attrcode}\" \"${lowercolorname}\" \"fg\"\n        _def_color_zsh \"${longcolorname}Bg\" \"${attrcode}\" \"${lowercolorname}\" \"bg\"\n      else\n        # bash\n        _def_color \"${longcolorname}\"   \"${attrcode}\" \"${fgcolorcode}\"\n        _def_color \"${longcolorname}Fg\" \"${attrcode}\" \"${fgcolorcode}\"\n        _def_color \"${longcolorname}Bg\" \"${attrcode}\" \"${bgcolorcode}\"\n      fi\n      (( x++ ))\n    done\n  }\n\n  # _term_color [ N | N M ]\n  _term_color() {\n    local cv\n    if [[ \"${#}\" -gt 1 ]]; then\n      cv=\"${1};${2}\"\n    else\n      cv=\"${1}\"\n    fi\n    echo \"\\[\\033[${cv}m\\]\"\n  }\n\n  # def_color NAME ATTRCODE COLORCODE\n  _def_color() {\n    local def=\"${1}=\\\"\\`_term_color ${2} ${3}\\`\\\"\"\n    eval \"${def}\"\n  }\n\n  # def_color_zsh NAME ATTRCODE COLORNAME FG|BG\n  _def_color_zsh() {\n    if [ \"${3}\" = \"0\" ]; then\n      local def=\"${1}=\\\"%{\\$reset_color%}\\\"\"\n    else\n      case ${2} in\n        1) # bold color\n          local def=\"${1}=\\\"%{\\$${4}_bold[${3}]%}\\\"\"\n          ;;\n        *)\n          local def=\"${1}=\\\"%{\\$${4}[${3}]%}\\\"\"\n          ;;\n      esac\n    fi\n    eval \"${def}\"\n  }\n\n\n  _map_colors Bold   ${AttrBright}\n  _map_colors Bright ${AttrBright}\n  _map_colors Dim    ${AttrDim}\n  _map_colors ''     ${AttrNorm}\n\n  if [ -n \"$ZSH_VERSION\" ]; then\n    _def_color_zsh IntenseBlack 0 90\n    _def_color_zsh ResetColor   0 0\n  else\n    _def_color IntenseBlack 0 90\n    _def_color ResetColor   0 0\n  fi\n}\n\n# do the color definitions only once\nif [[ -z \"${ColorNames+x}\" || \"${#ColorNames[*]}\" = 0 || -z \"${IntenseBlack:+x}\" || -z \"${ResetColor:+x}\" ]]; then\n  define_color_names\nfi\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "themes",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}