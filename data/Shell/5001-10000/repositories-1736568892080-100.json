{
  "metadata": {
    "timestamp": 1736568892080,
    "page": 100,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dehydrated-io/dehydrated",
      "stars": 5995,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.095703125,
          "content": "private_key.pem\nprivate_key.json\ndomains.txt\nconfig\nhook.sh\ncerts/*\narchive/*\naccounts/*\nchains/*\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 6.498046875,
          "content": "# Change Log\nThis file contains a log of major changes in dehydrated\n\n## [x.x.x] - xxxx-xx-xx\n...\n\n## [0.7.1] - 2022-10-31\n## Changed\n- `--force` no longer forces domain name revalidation by default, a new argument `--force-validation` has been added for that\n- Added support for EC secp521r1 algorithm (works with e.g. zerossl)\n- `EC PARAMETERS` are no longer written to privkey.pem (didn't seem necessary and was causing issues with various software)\n\n## Fixed\n- Requests resulting in `badNonce` errors are now automatically retried (fixes operation with LE staging servers)\n- Deprecated `egrep` usage has been removed\n\n## Added\n- Implemented EC for account keys\n- Domain list now also read from domains.txt.d subdirectory (behaviour might change, see docs)\n- Implemented RFC 8738 (validating/signing certificates for IP addresses instead of domain names) support (this will not work with most public CAs, if any!)\n\n## [0.7.0] - 2020-12-10\n## Added\n- Support for external account bindings\n- Special support for ZeroSSL\n- Support presets for some CAs instead of requiring URLs\n- Allow requesting preferred chain (`--preferred-chain`)\n- Added method to show CAs current terms of service (`--display-terms`)\n- Allow setting path to domains.txt using cli arguments (`--domains-txt`)\n- Added new cli command `--cleanupdelete` which deletes old files instead of archiving them\n\n## Fixed\n- No more silent failures on broken hook-scripts\n- Better error-handling with KEEP_GOING enabled\n- Check actual order status instead of assuming it's valid\n- Don't include keyAuthorization in challenge validation (RFC compliance)\n\n## Changed\n- Using EC secp384r1 as default certificate type\n- Use JSON.sh to parse JSON\n- Use account URL instead of account ID (RFC compliance)\n- Dehydrated now has a new home: https://github.com/dehydrated-io/dehydrated\n- Added `OCSP_FETCH` and `OCSP_DAYS` to per-certificate configurable options\n- Cleanup now also removes dangling symlinks\n\n## [0.6.5] - 2019-06-26\n## Fixed\n- Fixed broken APIv1 compatibility from last update\n\n## [0.6.4] - 2019-06-25\n## Changed\n- Fetch account ID from Location header instead of account json\n\n## [0.6.3] - 2019-06-25\n## Changed\n- OCSP refresh interval is now configurable\n- Implemented POST-as-GET\n- Call exit_hook on errors (with error-message as first parameter)\n\n## Added\n- Initial support for tls-alpn-01 validation\n- New hook: sync_cert (for syncing certificate files to disk, see example hook description)\n\n## Fixes\n- Fetch account information after registration to avoid missing account id\n\n## [0.6.2] - 2018-04-25\n## Added\n- New deploy_ocsp hook\n- Allow account registration with custom key\n\n## Changed\n- Don't walk certificate chain for ACMEv2 (certificate contains chain by default)\n- Improved documentation on wildcards\n\n## Fixes\n- Added workaround for compatibility with filesystem ACLs\n- Close unwanted external file-descriptors\n- Fixed JSON parsing on force-renewal\n- Fixed cleanup of challenge files/dns-entries on validation errors\n- A few more minor fixes\n\n## [0.6.1] - 2018-03-13\n## Changed\n- Use new ACME v2 endpoint by default\n\n## [0.6.0] - 2018-03-11\n## Changed\n- Challenge validation loop has been modified to loop over authorization identifiers instead of altnames (ACMEv2 + wildcard support)\n- Removed LICENSE parameter from config (terms of service is now acquired directly from the CA directory)\n\n## Added\n- Support for ACME v02 (including wildcard certificates!)\n- New hook: generate_csr (see example hook script for more information)\n- Calling random hook on startup to make it clear to hook script authors that unknown hooks should just be ignored...\n\n## [0.5.0] - 2018-01-13\n## Changed\n- Certificate chain is now cached (CHAINCACHE)\n- OpenSSL binary path is now configurable (OPENSSL)\n- Cleanup now also moves revoked certificates\n\n## Added\n- New feature for updating contact information (--account)\n- Allow automatic cleanup on exit (AUTO_CLEANUP)\n- Initial support for fetching OCSP status to be used for OCSP stapling (OCSP_FETCH)\n- Certificates can now have aliases to create multiple certificates with identical set of domains (see --alias and domains.txt documentation)\n- Allow dehydrated to run as specified user (/group)\n\n## [0.4.0] - 2017-02-05\n## Changed\n- dehydrated now asks you to read and accept the CAs terms of service before creating an account\n- Skip challenges for already validated domains\n- Removed need for some special commands (BusyBox compatibility)\n- Exported a few more variables for use in hook-scripts\n- fullchain.pem now actually contains the full chain instead of just the certificate with an intermediate cert\n\n## Added\n- Added private-key rollover functionality\n- Added `--lock-suffix` option for allowing parallel execution\n- Added `invalid_challenge` hook\n- Added `request_failure` hook\n- Added `exit_hook` hook\n- Added standalone `register` command\n\n## [0.3.1] - 2016-09-13\n## Changed\n- Renamed project to `dehydrated`.\n- Default WELLKNOWN location is now `/var/www/dehydrated`\n- Config location is renamed to `dehydrated` (e.g. `/etc/dehydrated`)\n\n## [0.3.0] - 2016-09-07\n## Changed\n- Config is now named `config` instead of `config.sh`!\n- Location of domains.txt is now configurable via DOMAINS_TXT config variable\n- Location of certs directory is now configurable via CERTDIR config variable\n- signcsr command now also outputs chain certificate if --full-chain/-fc is set\n- Location of account-key(s) changed\n- Default WELLKNOWN location is now `/var/www/letsencrypt`\n- New version of Let's Encrypt Subscriber Agreement\n\n## Added\n- Added option to add CSR-flag indicating OCSP stapling to be mandatory\n- Initial support for configuration on per-certificate base\n- Support for per-CA account keys and custom config for output cert directory, license, etc.\n- Added option to select IP version of name to address resolution\n- Added option to run letsencrypt.sh without locks\n\n## Fixed\n- letsencrypt.sh no longer stores account keys from invalid registrations\n\n## [0.2.0] - 2016-05-22\n### Changed\n- PRIVATE_KEY config parameter has been renamed to ACCOUNT_KEY to avoid confusion with certificate keys\n- deploy_cert hook now also has the certificates timestamp as standalone parameter\n- Temporary files are now identifiable (template: letsencrypt.sh-XXXXXX)\n- Private keys are now regenerated by default\n\n### Added\n- Added documentation to repository\n\n### Fixed\n- Fixed bug with uppercase names in domains.txt (script now converts everything to lowercase)\n- mktemp no longer uses the deprecated `-t` parameter.\n- Compatibility with \"pretty\" json\n\n## [0.1.0] - 2016-03-25\n### Changed\n- This is the first numbered version of letsencrypt.sh\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2021 Lukas Schauer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.5849609375,
          "content": "# dehydrated [![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=23P9DSJBTY7C8)\n\n![](docs/logo.png)\n\nDehydrated is a client for signing certificates with an ACME-server (e.g. Let's Encrypt) implemented as a relatively simple (zsh-compatible) bash-script.\nThis client supports both ACME v1 and the new ACME v2 including support for wildcard certificates!\n\nIt uses the `openssl` utility for everything related to actually handling keys and certificates, so you need to have that installed.\n\nOther dependencies are: cURL, sed, grep, awk, mktemp (all found pre-installed on almost any system, cURL being the only exception).\n\nCurrent features:\n- Signing of a list of domains (including wildcard domains!)\n- Signing of a custom CSR (either standalone or completely automated using hooks!)\n- Renewal if a certificate is about to expire or defined set of domains changed\n- Certificate revocation\n- and lots more..\n\nPlease keep in mind that this software, the ACME-protocol and all supported CA servers out there are relatively young and there might be a few issues. Feel free to report any issues you find with this script or contribute by submitting a pull request,\nbut please check for duplicates first (feel free to comment on those to get things rolling).\n\n## Getting started\n\nFor getting started I recommend taking a look at [docs/domains_txt.md](docs/domains_txt.md), [docs/wellknown.md](docs/wellknown.md) and the [Usage](#usage) section on this page (you'll probably only need the `-c` option).\n\nGenerally you want to set up your WELLKNOWN path first, and then fill in domains.txt.\n\n**Please note that you should use the staging URL when experimenting with this script to not hit Let's Encrypt's rate limits.** See [docs/staging.md](docs/staging.md).\n\nIf you have any problems take a look at our [Troubleshooting](docs/troubleshooting.md) guide.\n\n## Config\n\ndehydrated is looking for a config file in a few different places, it will use the first one it can find in this order:\n\n- `/etc/dehydrated/config`\n- `/usr/local/etc/dehydrated/config`\n- The current working directory of your shell\n- The directory from which dehydrated was run\n\nHave a look at [docs/examples/config](docs/examples/config) to get started, copy it to e.g. `/etc/dehydrated/config`\nand edit it to fit your needs.\n\n## Usage:\n\n```text\nUsage: ./dehydrated [-h] [command [argument]] [parameter [argument]] [parameter [argument]] ...\n\nDefault command: help\n\nCommands:\n --version (-v)                   Print version information\n --display-terms                  Display current terms of service\n --register                       Register account key\n --account                        Update account contact information\n --cron (-c)                      Sign/renew non-existent/changed/expiring certificates.\n --signcsr (-s) path/to/csr.pem   Sign a given CSR, output CRT on stdout (advanced usage)\n --revoke (-r) path/to/cert.pem   Revoke specified certificate\n --deactivate                     Deactivate account\n --cleanup (-gc)                  Move unused certificate files to archive directory\n --cleanup-delete (-gcd)          Deletes (!) unused certificate files\n --help (-h)                      Show help text\n --env (-e)                       Output configuration variables for use in other scripts\n\nParameters:\n --accept-terms                   Accept CAs terms of service\n --full-chain (-fc)               Print full chain when using --signcsr\n --ipv4 (-4)                      Resolve names to IPv4 addresses only\n --ipv6 (-6)                      Resolve names to IPv6 addresses only\n --domain (-d) domain.tld         Use specified domain name(s) instead of domains.txt entry (one certificate!)\n --ca url/preset                  Use specified CA URL or preset\n --alias certalias                Use specified name for certificate directory (and per-certificate config) instead of the primary domain (only used if --domain is specified)\n --keep-going (-g)                Keep going after encountering an error while creating/renewing multiple certificates in cron mode\n --force (-x)                     Force certificate renewal even if it is not due to expire within RENEW_DAYS\n --force-validation               Force revalidation of domain names (used in combination with --force)\n --no-lock (-n)                   Don't use lockfile (potentially dangerous!)\n --lock-suffix example.com        Suffix lockfile name with a string (useful for with -d)\n --ocsp                           Sets option in CSR indicating OCSP stapling to be mandatory\n --privkey (-p) path/to/key.pem   Use specified private key instead of account key (useful for revocation)\n --domains-txt path/to/domains.txt Use specified domains.txt instead of default/configured one\n --config (-f) path/to/config     Use specified config file\n --hook (-k) path/to/hook.sh      Use specified script for hooks\n --preferred-chain issuer-cn      Use alternative certificate chain identified by issuer CN\n --out (-o) certs/directory       Output certificates into the specified directory\n --alpn alpn-certs/directory      Output alpn verification certificates into the specified directory\n --challenge (-t) http-01|dns-01|tls-alpn-01 Which challenge should be used? Currently http-01, dns-01, and tls-alpn-01 are supported\n --algo (-a) rsa|prime256v1|secp384r1 Which public key algorithm should be used? Supported: rsa, prime256v1 and secp384r1\n```\n\n## Chat\n\nDehydrated has an official IRC-channel `#dehydrated` on libera.chat that can be used for general discussion and suggestions.\n\nThe channel can also be accessed with Matrix using the official libera.chat bridge at `#dehydrated:libera.chat`.\n"
        },
        {
          "name": "dehydrated",
          "type": "blob",
          "size": 86.8916015625,
          "content": "#!/usr/bin/env bash\n\n# dehydrated by lukas2511\n# Source: https://dehydrated.io\n#\n# This script is licensed under The MIT License (see LICENSE for more information).\n\nset -e\nset -u\nset -o pipefail\n[[ -n \"${ZSH_VERSION:-}\" ]] && set -o SH_WORD_SPLIT && set +o FUNCTION_ARGZERO && set -o NULL_GLOB && set -o noglob\n[[ -z \"${ZSH_VERSION:-}\" ]] && shopt -s nullglob && set -f\n\numask 077 # paranoid umask, we're creating private keys\n\n# Close weird external file descriptors\nexec 3>&-\nexec 4>&-\n\nVERSION=\"0.7.2\"\n\n# Find directory in which this script is stored by traversing all symbolic links\nSOURCE=\"${0}\"\nwhile [ -h \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symlink\n  DIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" && pwd )\"\n  SOURCE=\"$(readlink \"$SOURCE\")\"\n  [[ $SOURCE != /* ]] && SOURCE=\"$DIR/$SOURCE\" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located\ndone\nSCRIPTDIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" && pwd )\"\n\nBASEDIR=\"${SCRIPTDIR}\"\nORIGARGS=(\"${@}\")\n\nnoglob_set() {\n  if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    set +o noglob\n  else\n    set +f\n  fi\n}\n\nnoglob_clear() {\n  if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    set -o noglob\n  else\n    set -f\n  fi\n}\n\n# Generate json.sh path matching string\njson_path() {\n\tif [ ! \"${1}\" = \"-p\" ]; then\n\t\tprintf '\"%s\"' \"${1}\"\n\telse\n\t\tprintf '%s' \"${2}\"\n\tfi\n}\n\n# Get string value from json dictionary\nget_json_string_value() {\n  local filter\n  filter=\"$(printf 's/.*\\[%s\\][[:space:]]*\"\\([^\"]*\\)\"/\\\\1/p' \"$(json_path \"${1:-}\" \"${2:-}\")\")\"\n  sed -n \"${filter}\"\n}\n\n# Get array values from json dictionary\nget_json_array_values() {\n  grep -E '^\\['\"$(json_path \"${1:-}\" \"${2:-}\")\"',[0-9]*\\]' | sed -e 's/\\[[^\\]*\\][[:space:]]*//g' -e 's/^\"//' -e 's/\"$//'\n}\n\n# Get sub-dictionary from json\nget_json_dict_value() {\n  local filter\n  filter=\"$(printf 's/.*\\[%s\\][[:space:]]*\\(.*\\)/\\\\1/p' \"$(json_path \"${1:-}\" \"${2:-}\")\")\"\n  sed -n \"${filter}\" | jsonsh\n}\n\n# Get integer value from json\nget_json_int_value() {\n  local filter\n  filter=\"$(printf 's/.*\\[%s\\][[:space:]]*\\([^\"]*\\)/\\\\1/p' \"$(json_path \"${1:-}\" \"${2:-}\")\")\"\n  sed -n \"${filter}\"\n}\n\n# Get boolean value from json\nget_json_bool_value() {\n  local filter\n  filter=\"$(printf 's/.*\\[%s\\][[:space:]]*\\([^\"]*\\)/\\\\1/p' \"$(json_path \"${1:-}\" \"${2:-}\")\")\"\n  sed -n \"${filter}\"\n}\n\n# JSON.sh JSON-parser\n# Modified from https://github.com/dominictarr/JSON.sh\n# Original Copyright (c) 2011 Dominic Tarr\n# Licensed under The MIT License\njsonsh() {\n\n  throw() {\n    echo \"$*\" >&2\n    exit 1\n  }\n\n  awk_egrep () {\n    local pattern_string=$1\n\n    awk '{\n      while ($0) {\n        start=match($0, pattern);\n        token=substr($0, start, RLENGTH);\n        print token;\n        $0=substr($0, start+RLENGTH);\n      }\n    }' pattern=\"$pattern_string\"\n  }\n\n  tokenize () {\n    local GREP\n    local ESCAPE\n    local CHAR\n\n    if echo \"test string\" | grep -Eao --color=never \"test\" >/dev/null 2>&1\n    then\n      GREP='grep -Eao --color=never'\n    else\n      GREP='grep -Eao'\n    fi\n\n    # shellcheck disable=SC2196\n    if echo \"test string\" | grep -Eao \"test\" >/dev/null 2>&1\n    then\n      ESCAPE='(\\\\[^u[:cntrl:]]|\\\\u[0-9a-fA-F]{4})'\n      CHAR='[^[:cntrl:]\"\\\\]'\n    else\n      GREP=awk_egrep\n      ESCAPE='(\\\\\\\\[^u[:cntrl:]]|\\\\u[0-9a-fA-F]{4})'\n      CHAR='[^[:cntrl:]\"\\\\\\\\]'\n    fi\n\n    local STRING=\"\\\"$CHAR*($ESCAPE$CHAR*)*\\\"\"\n    local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'\n    local KEYWORD='null|false|true'\n    local SPACE='[[:space:]]+'\n\n    # Force zsh to expand $A into multiple words\n    local is_wordsplit_disabled\n    is_wordsplit_disabled=\"$(unsetopt 2>/dev/null | grep -c '^shwordsplit$' || true)\"\n    if [ \"${is_wordsplit_disabled}\" != \"0\" ]; then setopt shwordsplit; fi\n    $GREP \"$STRING|$NUMBER|$KEYWORD|$SPACE|.\" | grep -Ev \"^$SPACE$\"\n    if [ \"${is_wordsplit_disabled}\" != \"0\" ]; then unsetopt shwordsplit; fi\n  }\n\n  parse_array () {\n    local index=0\n    local ary=''\n    read -r token\n    case \"$token\" in\n      ']') ;;\n      *)\n        while :\n        do\n          parse_value \"$1\" \"$index\"\n          index=$((index+1))\n          ary=\"$ary\"\"$value\"\n          read -r token\n          case \"$token\" in\n            ']') break ;;\n            ',') ary=\"$ary,\" ;;\n            *) throw \"EXPECTED , or ] GOT ${token:-EOF}\" ;;\n          esac\n          read -r token\n        done\n        ;;\n    esac\n    value=$(printf '[%s]' \"$ary\") || value=\n    :\n  }\n\n  parse_object () {\n    local key\n    local obj=''\n    read -r token\n    case \"$token\" in\n      '}') ;;\n      *)\n        while :\n        do\n          case \"$token\" in\n            '\"'*'\"') key=$token ;;\n            *) throw \"EXPECTED string GOT ${token:-EOF}\" ;;\n          esac\n          read -r token\n          case \"$token\" in\n            ':') ;;\n            *) throw \"EXPECTED : GOT ${token:-EOF}\" ;;\n          esac\n          read -r token\n          parse_value \"$1\" \"$key\"\n          obj=\"$obj$key:$value\"\n          read -r token\n          case \"$token\" in\n            '}') break ;;\n            ',') obj=\"$obj,\" ;;\n            *) throw \"EXPECTED , or } GOT ${token:-EOF}\" ;;\n          esac\n          read -r token\n        done\n      ;;\n    esac\n    value=$(printf '{%s}' \"$obj\") || value=\n    :\n  }\n\n  parse_value () {\n    local jpath=\"${1:+$1,}${2:-}\"\n    case \"$token\" in\n      '{') parse_object \"$jpath\" ;;\n      '[') parse_array  \"$jpath\" ;;\n      # At this point, the only valid single-character tokens are digits.\n      ''|[!0-9]) throw \"EXPECTED value GOT ${token:-EOF}\" ;;\n      *) value=\"${token//\\\\\\///}\"\n         # replace solidus (\"\\/\") in json strings with normalized value: \"/\"\n         ;;\n    esac\n    [ \"$value\" = '' ] && return\n    [ -z \"$jpath\" ] && return # do not print head\n\n    printf \"[%s]\\t%s\\n\" \"$jpath\" \"$value\"\n    :\n  }\n\n  parse () {\n    read -r token\n    parse_value\n    read -r token || true\n    case \"$token\" in\n      '') ;;\n      *) throw \"EXPECTED EOF GOT $token\" ;;\n    esac\n  }\n\n  tokenize | parse\n}\n\n# Convert IP addresses to their reverse dns variants.\n# Used for ALPN certs as validation for IPs uses this in SNI since IPs aren't allowed there.\nip_to_ptr() {\n  ip=\"$(cat)\"\n  if [[ \"${ip}\" =~ : ]]; then\n    printf \"%sip6.arpa\" \"$(printf \"%s\" \"${ip}\" | awk -F: 'BEGIN {OFS=\"\"; }{addCount = 9 - NF; for(i=1; i<=NF;i++){if(length($i) == 0){ for(j=1;j<=addCount;j++){$i = ($i \"0000\");} } else { $i = substr((\"0000\" $i), length($i)+5-4);}}; print}' | rev | sed -e \"s/./&./g\")\"\n  else\n    printf \"%s.in-addr.arpa\" \"$(printf \"%s\" \"${ip}\" | awk -F. '{print $4\".\"$3\".\" $2\".\"$1}')\"\n  fi\n}\n\n# Create (identifiable) temporary files\n_mktemp() {\n  mktemp \"${TMPDIR:-/tmp}/dehydrated-XXXXXX\"\n}\n\n# Check for script dependencies\ncheck_dependencies() {\n  # look for required binaries\n  for binary in grep mktemp diff sed awk curl cut head tail hexdump; do\n    bin_path=\"$(command -v \"${binary}\" 2>/dev/null)\" || _exiterr \"This script requires ${binary}.\"\n    [[ -x \"${bin_path}\" ]] || _exiterr \"${binary} found in PATH but it's not executable\"\n  done\n\n  # just execute some dummy and/or version commands to see if required tools are actually usable\n  \"${OPENSSL}\" version > /dev/null 2>&1 || _exiterr \"This script requires an openssl binary.\"\n  _sed \"\" < /dev/null > /dev/null 2>&1 || _exiterr \"This script requires sed with support for extended (modern) regular expressions.\"\n\n  # curl returns with an error code in some ancient versions so we have to catch that\n  set +e\n  CURL_VERSION=\"$(curl -V 2>&1 | head -n1 | awk '{print $2}')\"\n  set -e\n}\n\nstore_configvars() {\n  __KEY_ALGO=\"${KEY_ALGO}\"\n  __OCSP_MUST_STAPLE=\"${OCSP_MUST_STAPLE}\"\n  __OCSP_FETCH=\"${OCSP_FETCH}\"\n  __OCSP_DAYS=\"${OCSP_DAYS}\"\n  __PRIVATE_KEY_RENEW=\"${PRIVATE_KEY_RENEW}\"\n  __PRIVATE_KEY_ROLLOVER=\"${PRIVATE_KEY_ROLLOVER}\"\n  __KEYSIZE=\"${KEYSIZE}\"\n  __CHALLENGETYPE=\"${CHALLENGETYPE}\"\n  __HOOK=\"${HOOK}\"\n  __PREFERRED_CHAIN=\"${PREFERRED_CHAIN}\"\n  __WELLKNOWN=\"${WELLKNOWN}\"\n  __HOOK_CHAIN=\"${HOOK_CHAIN}\"\n  __OPENSSL_CNF=\"${OPENSSL_CNF}\"\n  __RENEW_DAYS=\"${RENEW_DAYS}\"\n  __IP_VERSION=\"${IP_VERSION}\"\n}\n\nreset_configvars() {\n  KEY_ALGO=\"${__KEY_ALGO}\"\n  OCSP_MUST_STAPLE=\"${__OCSP_MUST_STAPLE}\"\n  OCSP_FETCH=\"${__OCSP_FETCH}\"\n  OCSP_DAYS=\"${__OCSP_DAYS}\"\n  PRIVATE_KEY_RENEW=\"${__PRIVATE_KEY_RENEW}\"\n  PRIVATE_KEY_ROLLOVER=\"${__PRIVATE_KEY_ROLLOVER}\"\n  KEYSIZE=\"${__KEYSIZE}\"\n  CHALLENGETYPE=\"${__CHALLENGETYPE}\"\n  HOOK=\"${__HOOK}\"\n  PREFERRED_CHAIN=\"${__PREFERRED_CHAIN}\"\n  WELLKNOWN=\"${__WELLKNOWN}\"\n  HOOK_CHAIN=\"${__HOOK_CHAIN}\"\n  OPENSSL_CNF=\"${__OPENSSL_CNF}\"\n  RENEW_DAYS=\"${__RENEW_DAYS}\"\n  IP_VERSION=\"${__IP_VERSION}\"\n}\n\nhookscript_bricker_hook() {\n  # Hook scripts should ignore any hooks they don't know.\n  # Calling a random hook to make this clear to the hook script authors...\n  if [[ -n \"${HOOK}\" ]]; then\n    \"${HOOK}\" \"this_hookscript_is_broken__dehydrated_is_working_fine__please_ignore_unknown_hooks_in_your_script\" || _exiterr \"Please check your hook script, it should exit cleanly without doing anything on unknown/new hooks.\"\n  fi\n}\n\n# verify configuration values\nverify_config() {\n  [[ \"${CHALLENGETYPE}\" == \"http-01\" || \"${CHALLENGETYPE}\" == \"dns-01\" || \"${CHALLENGETYPE}\" == \"tls-alpn-01\" ]] || _exiterr \"Unknown challenge type ${CHALLENGETYPE}... cannot continue.\"\n  if [[ \"${CHALLENGETYPE}\" = \"dns-01\" ]] && [[ -z \"${HOOK}\" ]]; then\n    _exiterr \"Challenge type dns-01 needs a hook script for deployment... cannot continue.\"\n  fi\n  if [[ \"${CHALLENGETYPE}\" = \"http-01\" && ! -d \"${WELLKNOWN}\" && ! \"${COMMAND:-}\" = \"register\" ]]; then\n    _exiterr \"WELLKNOWN directory doesn't exist, please create ${WELLKNOWN} and set appropriate permissions.\"\n  fi\n  [[ \"${KEY_ALGO}\" == \"rsa\" || \"${KEY_ALGO}\" == \"prime256v1\" || \"${KEY_ALGO}\" == \"secp384r1\" || \"${KEY_ALGO}\" == \"secp521r1\" ]] || _exiterr \"Unknown public key algorithm ${KEY_ALGO}... cannot continue.\"\n  if [[ -n \"${IP_VERSION}\" ]]; then\n    [[ \"${IP_VERSION}\" = \"4\" || \"${IP_VERSION}\" = \"6\" ]] || _exiterr \"Unknown IP version ${IP_VERSION}... cannot continue.\"\n  fi\n  [[ \"${API}\" == \"auto\" || \"${API}\" == \"1\" || \"${API}\" == \"2\" ]] || _exiterr \"Unsupported API version defined in config: ${API}\"\n  [[ \"${OCSP_DAYS}\" =~ ^[0-9]+$ ]] || _exiterr \"OCSP_DAYS must be a number\"\n}\n\n# Setup default config values, search for and load configuration files\nload_config() {\n  # Check for config in various locations\n  if [[ -z \"${CONFIG:-}\" ]]; then\n    for check_config in \"/etc/dehydrated\" \"/usr/local/etc/dehydrated\" \"${PWD}\" \"${SCRIPTDIR}\"; do\n      if [[ -f \"${check_config}/config\" ]]; then\n        BASEDIR=\"${check_config}\"\n        CONFIG=\"${check_config}/config\"\n        break\n      fi\n    done\n  fi\n\n  # Preset\n  CA_ZEROSSL=\"https://acme.zerossl.com/v2/DV90\"\n  CA_LETSENCRYPT=\"https://acme-v02.api.letsencrypt.org/directory\"\n  CA_LETSENCRYPT_TEST=\"https://acme-staging-v02.api.letsencrypt.org/directory\"\n  CA_BUYPASS=\"https://api.buypass.com/acme/directory\"\n  CA_BUYPASS_TEST=\"https://api.test4.buypass.no/acme/directory\"\n\n  # Default values\n  CA=\"letsencrypt\"\n  OLDCA=\n  CERTDIR=\n  ALPNCERTDIR=\n  ACCOUNTDIR=\n  ACCOUNT_KEYSIZE=\"4096\"\n  ACCOUNT_KEY_ALGO=rsa\n  CHALLENGETYPE=\"http-01\"\n  CONFIG_D=\n  CURL_OPTS=\n  DOMAINS_D=\n  DOMAINS_TXT=\n  HOOK=\n  PREFERRED_CHAIN=\n  HOOK_CHAIN=\"no\"\n  RENEW_DAYS=\"30\"\n  KEYSIZE=\"4096\"\n  WELLKNOWN=\n  PRIVATE_KEY_RENEW=\"yes\"\n  PRIVATE_KEY_ROLLOVER=\"no\"\n  KEY_ALGO=secp384r1\n  OPENSSL=openssl\n  OPENSSL_CNF=\n  CONTACT_EMAIL=\n  LOCKFILE=\n  OCSP_MUST_STAPLE=\"no\"\n  OCSP_FETCH=\"no\"\n  OCSP_DAYS=5\n  IP_VERSION=\n  CHAINCACHE=\n  AUTO_CLEANUP=\"no\"\n  DEHYDRATED_USER=\n  DEHYDRATED_GROUP=\n  API=\"auto\"\n\n  if [[ -z \"${CONFIG:-}\" ]]; then\n    echo \"#\" >&2\n    echo \"# !! WARNING !! No main config file found, using default config!\" >&2\n    echo \"#\" >&2\n  elif [[ -f \"${CONFIG}\" ]]; then\n    echo \"# INFO: Using main config file ${CONFIG}\"\n    BASEDIR=\"$(dirname \"${CONFIG}\")\"\n    # shellcheck disable=SC1090\n    . \"${CONFIG}\"\n  else\n    _exiterr \"Specified config file doesn't exist.\"\n  fi\n\n  if [[ -n \"${CONFIG_D}\" ]]; then\n    if [[ ! -d \"${CONFIG_D}\" ]]; then\n      _exiterr \"The path ${CONFIG_D} specified for CONFIG_D does not point to a directory.\"\n    fi\n\n    # Allow globbing\n    noglob_set\n\n    for check_config_d in \"${CONFIG_D}\"/*.sh; do\n      if [[ -f \"${check_config_d}\" ]] && [[ -r \"${check_config_d}\" ]]; then\n        echo \"# INFO: Using additional config file ${check_config_d}\"\n        # shellcheck disable=SC1090\n        . \"${check_config_d}\"\n      else\n        _exiterr \"Specified additional config ${check_config_d} is not readable or not a file at all.\"\n      fi\n    done\n\n    # Disable globbing\n    noglob_clear\n  fi\n\n  # Check for missing dependencies\n  check_dependencies\n\n  has_sudo() {\n    command -v sudo > /dev/null 2>&1 || _exiterr \"DEHYDRATED_USER set but sudo not available. Please install sudo.\"\n  }\n\n  # Check if we are running & are allowed to run as root\n  if [[ -n \"$DEHYDRATED_USER\" ]]; then\n    command -v getent > /dev/null 2>&1 || _exiterr \"DEHYDRATED_USER set but getent not available. Please install getent.\"\n\n    TARGET_UID=\"$(getent passwd \"${DEHYDRATED_USER}\" | cut -d':' -f3)\" || _exiterr \"DEHYDRATED_USER ${DEHYDRATED_USER} is invalid\"\n    if [[ -z \"${DEHYDRATED_GROUP}\" ]]; then\n      if [[ \"${EUID}\" != \"${TARGET_UID}\" ]]; then\n        echo \"# INFO: Running $0 as ${DEHYDRATED_USER}\"\n        has_sudo && exec sudo -u \"${DEHYDRATED_USER}\" \"${0}\" \"${ORIGARGS[@]}\"\n      fi\n    else\n      TARGET_GID=\"$(getent group \"${DEHYDRATED_GROUP}\" | cut -d':' -f3)\" || _exiterr \"DEHYDRATED_GROUP ${DEHYDRATED_GROUP} is invalid\"\n      if [[ -z \"${EGID:-}\" ]]; then\n        command -v id > /dev/null 2>&1 || _exiterr \"DEHYDRATED_GROUP set, don't know current gid and 'id' not available... Please provide 'id' binary.\"\n        EGID=\"$(id -g)\"\n      fi\n      if [[ \"${EUID}\" != \"${TARGET_UID}\" ]] || [[ \"${EGID}\" != \"${TARGET_GID}\" ]]; then\n        echo \"# INFO: Running $0 as ${DEHYDRATED_USER}/${DEHYDRATED_GROUP}\"\n        has_sudo && exec sudo -u \"${DEHYDRATED_USER}\" -g \"${DEHYDRATED_GROUP}\" \"${0}\" \"${ORIGARGS[@]}\"\n      fi\n    fi\n  elif [[ -n \"${DEHYDRATED_GROUP}\" ]]; then\n    _exiterr \"DEHYDRATED_GROUP can only be used in combination with DEHYDRATED_USER.\"\n  fi\n\n  # Remove slash from end of BASEDIR. Mostly for cleaner outputs, doesn't change functionality.\n  [[ \"$BASEDIR\" != \"/\" ]] && BASEDIR=\"${BASEDIR%%/}\"\n\n  # Check BASEDIR and set default variables\n  [[ -d \"${BASEDIR}\" ]] || _exiterr \"BASEDIR does not exist: ${BASEDIR}\"\n\n  # Check for ca cli parameter\n  if [ -n \"${PARAM_CA:-}\" ]; then\n    CA=\"${PARAM_CA}\"\n  fi\n\n  # Preset CAs\n  if [ \"${CA}\" = \"letsencrypt\" ]; then\n    CA=\"${CA_LETSENCRYPT}\"\n  elif [ \"${CA}\" = \"letsencrypt-test\" ]; then\n    CA=\"${CA_LETSENCRYPT_TEST}\"\n  elif [ \"${CA}\" = \"zerossl\" ]; then\n    CA=\"${CA_ZEROSSL}\"\n  elif [ \"${CA}\" = \"buypass\" ]; then\n    CA=\"${CA_BUYPASS}\"\n  elif [ \"${CA}\" = \"buypass-test\" ]; then\n    CA=\"${CA_BUYPASS_TEST}\"\n  fi\n\n  if [[ -z \"${OLDCA}\" ]] && [[ \"${CA}\" = \"https://acme-v02.api.letsencrypt.org/directory\" ]]; then\n    OLDCA=\"https://acme-v01.api.letsencrypt.org/directory\"\n  fi\n\n  # Create new account directory or symlink to account directory from old CA\n  # dev note: keep in mind that because of the use of 'echo' instead of 'printf' or\n  # similar there is a newline encoded in the directory name. not going to fix this\n  # since it's a non-issue and trying to fix existing installations would be too much\n  # trouble\n  CAHASH=\"$(echo \"${CA}\" | urlbase64)\"\n  [[ -z \"${ACCOUNTDIR}\" ]] && ACCOUNTDIR=\"${BASEDIR}/accounts\"\n  if [[ ! -e \"${ACCOUNTDIR}/${CAHASH}\" ]]; then\n    OLDCAHASH=\"$(echo \"${OLDCA}\" | urlbase64)\"\n    mkdir -p \"${ACCOUNTDIR}\"\n    if [[ -n \"${OLDCA}\" ]] && [[ -e \"${ACCOUNTDIR}/${OLDCAHASH}\" ]]; then\n      echo \"! Reusing account from ${OLDCA}\"\n      ln -s \"${OLDCAHASH}\" \"${ACCOUNTDIR}/${CAHASH}\"\n    else\n      mkdir \"${ACCOUNTDIR}/${CAHASH}\"\n    fi\n  fi\n\n  # shellcheck disable=SC1090\n  [[ -f \"${ACCOUNTDIR}/${CAHASH}/config\" ]] && . \"${ACCOUNTDIR}/${CAHASH}/config\"\n  ACCOUNT_KEY=\"${ACCOUNTDIR}/${CAHASH}/account_key.pem\"\n  ACCOUNT_KEY_JSON=\"${ACCOUNTDIR}/${CAHASH}/registration_info.json\"\n  ACCOUNT_ID_JSON=\"${ACCOUNTDIR}/${CAHASH}/account_id.json\"\n  ACCOUNT_DEACTIVATED=\"${ACCOUNTDIR}/${CAHASH}/deactivated\"\n\n  if [[ -f \"${ACCOUNT_DEACTIVATED}\" ]]; then\n    _exiterr \"Account has been deactivated. Remove account and create a new one using --register.\"\n  fi\n\n  if [[ -f \"${BASEDIR}/private_key.pem\" ]] && [[ ! -f \"${ACCOUNT_KEY}\" ]]; then\n    echo \"! Moving private_key.pem to ${ACCOUNT_KEY}\"\n    mv \"${BASEDIR}/private_key.pem\" \"${ACCOUNT_KEY}\"\n  fi\n  if [[ -f \"${BASEDIR}/private_key.json\" ]] && [[ ! -f \"${ACCOUNT_KEY_JSON}\" ]]; then\n    echo \"! Moving private_key.json to ${ACCOUNT_KEY_JSON}\"\n    mv \"${BASEDIR}/private_key.json\" \"${ACCOUNT_KEY_JSON}\"\n  fi\n\n  [[ -z \"${CERTDIR}\" ]] && CERTDIR=\"${BASEDIR}/certs\"\n  [[ -z \"${ALPNCERTDIR}\" ]] && ALPNCERTDIR=\"${BASEDIR}/alpn-certs\"\n  [[ -z \"${CHAINCACHE}\" ]] && CHAINCACHE=\"${BASEDIR}/chains\"\n  [[ -z \"${DOMAINS_TXT}\" ]] && DOMAINS_TXT=\"${BASEDIR}/domains.txt\"\n  [[ -z \"${WELLKNOWN}\" ]] && WELLKNOWN=\"/var/www/dehydrated\"\n  [[ -z \"${LOCKFILE}\" ]] && LOCKFILE=\"${BASEDIR}/lock\"\n  [[ -z \"${OPENSSL_CNF}\" ]] && OPENSSL_CNF=\"$(\"${OPENSSL}\" version -d | cut -d\\\" -f2)/openssl.cnf\"\n  [[ -n \"${PARAM_LOCKFILE_SUFFIX:-}\" ]] && LOCKFILE=\"${LOCKFILE}-${PARAM_LOCKFILE_SUFFIX}\"\n  [[ -n \"${PARAM_NO_LOCK:-}\" ]] && LOCKFILE=\"\"\n\n  [[ -n \"${PARAM_HOOK:-}\" ]] && HOOK=\"${PARAM_HOOK}\"\n  [[ -n \"${PARAM_DOMAINS_TXT:-}\" ]] && DOMAINS_TXT=\"${PARAM_DOMAINS_TXT}\"\n  [[ -n \"${PARAM_PREFERRED_CHAIN:-}\" ]] && PREFERRED_CHAIN=\"${PARAM_PREFERRED_CHAIN}\"\n  [[ -n \"${PARAM_CERTDIR:-}\" ]] && CERTDIR=\"${PARAM_CERTDIR}\"\n  [[ -n \"${PARAM_ALPNCERTDIR:-}\" ]] && ALPNCERTDIR=\"${PARAM_ALPNCERTDIR}\"\n  [[ -n \"${PARAM_CHALLENGETYPE:-}\" ]] && CHALLENGETYPE=\"${PARAM_CHALLENGETYPE}\"\n  [[ -n \"${PARAM_KEY_ALGO:-}\" ]] && KEY_ALGO=\"${PARAM_KEY_ALGO}\"\n  [[ -n \"${PARAM_OCSP_MUST_STAPLE:-}\" ]] && OCSP_MUST_STAPLE=\"${PARAM_OCSP_MUST_STAPLE}\"\n  [[ -n \"${PARAM_IP_VERSION:-}\" ]] && IP_VERSION=\"${PARAM_IP_VERSION}\"\n\n  if [ \"${PARAM_FORCE_VALIDATION:-no}\" = \"yes\" ] && [ \"${PARAM_FORCE:-no}\" = \"no\" ]; then\n    _exiterr \"Argument --force-validation can only be used in combination with --force (-x)\"\n  fi\n\n  if [ ! \"${1:-}\" = \"noverify\" ]; then\n    verify_config\n  fi\n  store_configvars\n}\n\n# Initialize system\ninit_system() {\n  load_config\n\n  # Lockfile handling (prevents concurrent access)\n  if [[ -n \"${LOCKFILE}\" ]]; then\n    LOCKDIR=\"$(dirname \"${LOCKFILE}\")\"\n    [[ -w \"${LOCKDIR}\" ]] || _exiterr \"Directory ${LOCKDIR} for LOCKFILE ${LOCKFILE} is not writable, aborting.\"\n    ( set -C; date > \"${LOCKFILE}\" ) 2>/dev/null || _exiterr \"Lock file '${LOCKFILE}' present, aborting.\"\n    remove_lock() { rm -f \"${LOCKFILE}\"; }\n    trap 'remove_lock' EXIT\n  fi\n\n  # Get CA URLs\n  CA_DIRECTORY=\"$(http_request get \"${CA}\" | jsonsh)\"\n\n  # Automatic discovery of API version\n  if [[ \"${API}\" = \"auto\" ]]; then\n    grep -q newOrder <<< \"${CA_DIRECTORY}\" && API=2 || API=1\n  fi\n\n  # shellcheck disable=SC2015\n  if [[ \"${API}\" = \"1\" ]]; then\n    CA_NEW_CERT=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value new-cert)\" &&\n    CA_NEW_AUTHZ=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value new-authz)\" &&\n    CA_NEW_REG=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value new-reg)\" &&\n    CA_TERMS=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value terms-of-service)\" &&\n    CA_REQUIRES_EAB=\"false\" &&\n    CA_REVOKE_CERT=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value revoke-cert)\" ||\n    _exiterr \"Problem retrieving ACME/CA-URLs, check if your configured CA points to the directory entrypoint.\"\n    # Since reg URI is missing from directory we will assume it is the same as CA_NEW_REG without the new part\n    CA_REG=${CA_NEW_REG/new-reg/reg}\n  else\n    CA_NEW_ORDER=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value newOrder)\" &&\n    CA_NEW_NONCE=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value newNonce)\" &&\n    CA_NEW_ACCOUNT=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value newAccount)\" &&\n    CA_TERMS=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value -p '\"meta\",\"termsOfService\"')\" &&\n    CA_REQUIRES_EAB=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_bool_value -p '\"meta\",\"externalAccountRequired\"' || echo false)\" &&\n    CA_REVOKE_CERT=\"$(printf \"%s\" \"${CA_DIRECTORY}\" | get_json_string_value revokeCert)\" ||\n    _exiterr \"Problem retrieving ACME/CA-URLs, check if your configured CA points to the directory entrypoint.\"\n  fi\n\n  # Export some environment variables to be used in hook script\n  export WELLKNOWN BASEDIR CERTDIR ALPNCERTDIR CONFIG COMMAND\n\n  # Checking for private key ...\n  register_new_key=\"no\"\n  generated=\"false\"\n  if [[ -n \"${PARAM_ACCOUNT_KEY:-}\" ]]; then\n    # a private key was specified from the command line so use it for this run\n    echo \"Using private key ${PARAM_ACCOUNT_KEY} instead of account key\"\n    ACCOUNT_KEY=\"${PARAM_ACCOUNT_KEY}\"\n    ACCOUNT_KEY_JSON=\"${PARAM_ACCOUNT_KEY}.json\"\n    ACCOUNT_ID_JSON=\"${PARAM_ACCOUNT_KEY}_id.json\"\n    [ \"${COMMAND:-}\" = \"register\" ] && register_new_key=\"yes\"\n  else\n    # Check if private account key exists, if it doesn't exist yet generate a new one (rsa key)\n    if [[ ! -e \"${ACCOUNT_KEY}\" ]]; then\n      if [[ ! \"${PARAM_ACCEPT_TERMS:-}\" = \"yes\" ]]; then\n        printf '\\n' >&2\n        printf 'To use dehydrated with this certificate authority you have to agree to their terms of service which you can find here: %s\\n\\n' \"${CA_TERMS}\" >&2\n        printf 'To accept these terms of service run \"%s --register --accept-terms\".\\n' \"${0}\" >&2\n        exit 1\n      fi\n\n      echo \"+ Generating account key...\"\n      generated=\"true\"\n      local tmp_account_key\n      tmp_account_key=\"$(_mktemp)\"\n      if [[ ${API} -eq 1 && ! \"${ACCOUNT_KEY_ALGO}\" = \"rsa\" ]]; then\n        _exiterr \"ACME API version 1 does not support EC account keys\"\n      fi\n      case \"${ACCOUNT_KEY_ALGO}\" in\n        rsa) _openssl genrsa -out \"${tmp_account_key}\" \"${ACCOUNT_KEYSIZE}\";;\n        prime256v1|secp384r1|secp521r1) _openssl ecparam -genkey -name \"${ACCOUNT_KEY_ALGO}\" -out \"${tmp_account_key}\" -noout;;\n      esac\n      cat \"${tmp_account_key}\" > \"${ACCOUNT_KEY}\"\n      rm \"${tmp_account_key}\"\n      register_new_key=\"yes\"\n    fi\n  fi\n\n  if (\"${OPENSSL}\" rsa -in \"${ACCOUNT_KEY}\" -check 2>/dev/null > /dev/null); then\n    # Get public components from private key and calculate thumbprint\n    pubExponent64=\"$(printf '%x' \"$(\"${OPENSSL}\" rsa -in \"${ACCOUNT_KEY}\" -noout -text | awk '/publicExponent/ {print $2}')\" | hex2bin | urlbase64)\"\n    pubMod64=\"$(\"${OPENSSL}\" rsa -in \"${ACCOUNT_KEY}\" -noout -modulus | cut -d'=' -f2 | hex2bin | urlbase64)\"\n\n    account_key_info=\"$(printf '{\"e\":\"%s\",\"kty\":\"RSA\",\"n\":\"%s\"}' \"${pubExponent64}\" \"${pubMod64}\")\"\n    account_key_sigalgo=RS256\n  elif (\"${OPENSSL}\" ec -in \"${ACCOUNT_KEY}\" -check 2>/dev/null > /dev/null); then\n    curve=\"$(\"${OPENSSL}\" ec -in \"${ACCOUNT_KEY}\" -noout -text 2>/dev/null | grep 'NIST CURVE' | cut -d':' -f2 | tr -d ' ')\"\n    pubkey=\"$(\"${OPENSSL}\" ec -in \"${ACCOUNT_KEY}\" -noout -text 2>/dev/null | tr -d '\\n ' | grep -Eo 'pub:.*ASN1' | _sed -e 's/^pub://' -e 's/ASN1$//' | tr -d ':')\"\n\n    if [ \"${curve}\" = \"P-256\" ]; then\n      account_key_sigalgo=\"ES256\"\n    elif [ \"${curve}\" = \"P-384\" ]; then\n      account_key_sigalgo=\"ES384\"\n    elif [ \"${curve}\" = \"P-521\" ]; then\n      account_key_sigalgo=\"ES512\"\n    else\n      _exiterr \"Unknown account key curve: ${curve}\"\n    fi\n\n    ec_x_offset=2\n    ec_x_len=$((${#pubkey}/2 - 1))\n    ec_x=\"${pubkey:$ec_x_offset:$ec_x_len}\"\n    ec_x64=\"$(printf \"%s\" \"${ec_x}\" | hex2bin | urlbase64)\"\n\n    ec_y_offset=$((ec_x_offset+ec_x_len))\n    ec_y_len=$((${#pubkey}-ec_y_offset))\n    ec_y=\"${pubkey:$ec_y_offset:$ec_y_len}\"\n    ec_y64=\"$(printf \"%s\" \"${ec_y}\" | hex2bin | urlbase64)\"\n\n    account_key_info=\"$(printf '{\"crv\":\"%s\",\"kty\":\"EC\",\"x\":\"%s\",\"y\":\"%s\"}' \"${curve}\" \"${ec_x64}\" \"${ec_y64}\")\"\n  else\n    _exiterr \"Account key is not valid, cannot continue.\"\n  fi\n  thumbprint=\"$(printf '%s' \"${account_key_info}\" | \"${OPENSSL}\" dgst -sha256 -binary | urlbase64)\"\n\n  # If we generated a new private key in the step above we have to register it with the acme-server\n  if [[ \"${register_new_key}\" = \"yes\" ]]; then\n    echo \"+ Registering account key with ACME server...\"\n    FAILED=false\n\n    if [[ ${API} -eq 1 && -z \"${CA_NEW_REG}\" ]] || [[ ${API} -eq 2 && -z \"${CA_NEW_ACCOUNT}\" ]]; then\n      echo \"Certificate authority doesn't allow registrations.\"\n      FAILED=true\n    fi\n\n    # ZeroSSL special sauce\n    if [[ \"${CA}\" = \"${CA_ZEROSSL}\" ]]; then\n      if [[ -z \"${EAB_KID:-}\" ]] ||  [[ -z \"${EAB_HMAC_KEY:-}\" ]]; then\n        if [[ -z \"${CONTACT_EMAIL}\" ]]; then\n          echo \"ZeroSSL requires contact email to be set or EAB_KID/EAB_HMAC_KEY to be manually configured\"\n          FAILED=true\n        else\n          zeroapi=\"$(curl -s \"https://api.zerossl.com/acme/eab-credentials-email\" -d \"email=${CONTACT_EMAIL}\" | jsonsh)\"\n          EAB_KID=\"$(printf \"%s\" \"${zeroapi}\" | get_json_string_value eab_kid)\"\n          EAB_HMAC_KEY=\"$(printf \"%s\" \"${zeroapi}\" | get_json_string_value eab_hmac_key)\"\n          if [[ -z \"${EAB_KID:-}\" ]] ||  [[ -z \"${EAB_HMAC_KEY:-}\" ]]; then\n            echo \"Unknown error retrieving ZeroSSL API credentials\"\n            echo \"${zeroapi}\"\n            FAILED=true\n          fi\n        fi\n      fi\n    fi\n\n    # Check if external account is required\n    if [[ \"${FAILED}\" = \"false\" ]]; then\n      if [[ \"${CA_REQUIRES_EAB}\" = \"true\" ]]; then\n        if [[ -z \"${EAB_KID:-}\" ]] || [[ -z \"${EAB_HMAC_KEY:-}\" ]]; then\n          FAILED=true\n          echo \"This CA requires an external account but no EAB_KID/EAB_HMAC_KEY has been configured\"\n        fi\n      fi\n    fi\n\n    # If an email for the contact has been provided then adding it to the registration request\n    if [[ \"${FAILED}\" = \"false\" ]]; then\n      if [[ ${API} -eq 1 ]]; then\n        if [[ -n \"${CONTACT_EMAIL}\" ]]; then\n          (signed_request \"${CA_NEW_REG}\" '{\"resource\": \"new-reg\", \"contact\":[\"mailto:'\"${CONTACT_EMAIL}\"'\"], \"agreement\": \"'\"${CA_TERMS}\"'\"}' > \"${ACCOUNT_KEY_JSON}\") || FAILED=true\n        else\n          (signed_request \"${CA_NEW_REG}\" '{\"resource\": \"new-reg\", \"agreement\": \"'\"${CA_TERMS}\"'\"}' > \"${ACCOUNT_KEY_JSON}\") || FAILED=true\n        fi\n      else\n        if [[ -n \"${EAB_KID:-}\" ]] && [[ -n \"${EAB_HMAC_KEY:-}\" ]]; then\n          eab_url=\"${CA_NEW_ACCOUNT}\"\n          eab_protected64=\"$(printf '{\"alg\":\"HS256\",\"kid\":\"%s\",\"url\":\"%s\"}' \"${EAB_KID}\" \"${eab_url}\" | urlbase64)\"\n          eab_payload64=\"$(printf \"%s\" \"${account_key_info}\" | urlbase64)\"\n          eab_key=\"$(printf \"%s\" \"${EAB_HMAC_KEY}\" | deurlbase64 | bin2hex)\"\n          eab_signed64=\"$(printf '%s' \"${eab_protected64}.${eab_payload64}\" | \"${OPENSSL}\" dgst -binary -sha256 -mac HMAC -macopt \"hexkey:${eab_key}\" | urlbase64)\"\n\n          if [[ -n \"${CONTACT_EMAIL}\" ]]; then\n            regjson='{\"contact\":[\"mailto:'\"${CONTACT_EMAIL}\"'\"], \"termsOfServiceAgreed\": true, \"externalAccountBinding\": {\"protected\": \"'\"${eab_protected64}\"'\", \"payload\": \"'\"${eab_payload64}\"'\", \"signature\": \"'\"${eab_signed64}\"'\"}}'\n          else\n            regjson='{\"termsOfServiceAgreed\": true, \"externalAccountBinding\": {\"protected\": \"'\"${eab_protected64}\"'\", \"payload\": \"'\"${eab_payload64}\"'\", \"signature\": \"'\"${eab_signed64}\"'\"}}'\n          fi\n        else\n          if [[ -n \"${CONTACT_EMAIL}\" ]]; then\n            regjson='{\"contact\":[\"mailto:'\"${CONTACT_EMAIL}\"'\"], \"termsOfServiceAgreed\": true}'\n          else\n            regjson='{\"termsOfServiceAgreed\": true}'\n          fi\n        fi\n        (signed_request \"${CA_NEW_ACCOUNT}\" \"${regjson}\" > \"${ACCOUNT_KEY_JSON}\") || FAILED=true\n      fi\n    fi\n\n    if [[ \"${FAILED}\" = \"true\" ]]; then\n      echo >&2\n      echo >&2\n      echo \"Error registering account key. See message above for more information.\" >&2\n      if [[ \"${generated}\" = \"true\" ]]; then\n        rm \"${ACCOUNT_KEY}\"\n      fi\n      rm -f \"${ACCOUNT_KEY_JSON}\"\n      exit 1\n    fi\n  elif [[ \"${COMMAND:-}\" = \"register\" ]]; then\n    echo \"+ Account already registered!\"\n    exit 0\n  fi\n\n  # Read account information or request from CA if missing\n  if [[ -e \"${ACCOUNT_KEY_JSON}\" ]]; then\n    if [[ ${API} -eq 1 ]]; then\n      ACCOUNT_ID=\"$(jsonsh < \"${ACCOUNT_KEY_JSON}\" | get_json_int_value id)\"\n      ACCOUNT_URL=\"${CA_REG}/${ACCOUNT_ID}\"\n    else\n      if [[ -e \"${ACCOUNT_ID_JSON}\" ]]; then\n        ACCOUNT_URL=\"$(jsonsh < \"${ACCOUNT_ID_JSON}\" | get_json_string_value url)\"\n      fi\n      # if account URL is not storred, fetch it from the CA\n      if [[ -z \"${ACCOUNT_URL:-}\" ]]; then\n        echo \"+ Fetching account URL...\"\n        ACCOUNT_URL=\"$(signed_request \"${CA_NEW_ACCOUNT}\" '{\"onlyReturnExisting\": true}' 4>&1 | grep -i ^Location: | cut -d':' -f2- | tr -d ' \\t\\r\\n')\"\n        if [[ -z \"${ACCOUNT_URL}\" ]]; then\n          _exiterr \"Unknown error on fetching account information\"\n        fi\n        echo '{\"url\":\"'\"${ACCOUNT_URL}\"'\"}' > \"${ACCOUNT_ID_JSON}\" # store the URL for next time\n      fi\n    fi\n  else\n    echo \"Fetching missing account information from CA...\"\n    if [[ ${API} -eq 1 ]]; then\n      _exiterr \"This is not implemented for ACMEv1! Consider switching to ACMEv2 :)\"\n    else\n      ACCOUNT_URL=\"$(signed_request \"${CA_NEW_ACCOUNT}\" '{\"onlyReturnExisting\": true}' 4>&1 | grep -i ^Location: | cut -d':' -f2- | tr -d ' \\t\\r\\n')\"\n      ACCOUNT_INFO=\"$(signed_request \"${ACCOUNT_URL}\" '{}')\"\n    fi\n    echo \"${ACCOUNT_INFO}\" > \"${ACCOUNT_KEY_JSON}\"\n  fi\n}\n\n# Different sed version for different os types...\n_sed() {\n  if [[ \"${OSTYPE}\" = \"Linux\" || \"${OSTYPE:0:5}\" = \"MINGW\" ]]; then\n    sed -r \"${@}\"\n  else\n    sed -E \"${@}\"\n  fi\n}\n\n# Print error message and exit with error\n_exiterr() {\n  if [ -n \"${1:-}\" ]; then\n    echo \"ERROR: ${1}\" >&2\n  fi\n  [[ \"${skip_exit_hook:-no}\" = \"no\" ]] && [[ -n \"${HOOK:-}\" ]] && (\"${HOOK}\" \"exit_hook\" \"${1:-}\" || echo 'exit_hook returned with non-zero exit code!' >&2)\n  exit 1\n}\n\n# Remove newlines and whitespace from json\nclean_json() {\n  tr -d '\\r\\n' | _sed -e 's/ +/ /g' -e 's/\\{ /{/g' -e 's/ \\}/}/g' -e 's/\\[ /[/g' -e 's/ \\]/]/g'\n}\n\n# Encode data as url-safe formatted base64\nurlbase64() {\n  # urlbase64: base64 encoded string with '+' replaced with '-' and '/' replaced with '_'\n  \"${OPENSSL}\" base64 -e | tr -d '\\n\\r' | _sed -e 's:=*$::g' -e 'y:+/:-_:'\n}\n\n# Decode data from url-safe formatted base64\ndeurlbase64() {\n  data=\"$(cat | tr -d ' \\n\\r')\"\n  modlen=$((${#data} % 4))\n  padding=\"\"\n  if [[ \"${modlen}\" = \"2\" ]]; then padding=\"==\";\n  elif [[ \"${modlen}\" = \"3\" ]]; then padding=\"=\"; fi\n  printf \"%s%s\" \"${data}\" \"${padding}\" | tr -d '\\n\\r' | _sed -e 'y:-_:+/:' | \"${OPENSSL}\" base64 -d -A\n}\n\n# Convert hex string to binary data\nhex2bin() {\n  # Remove spaces, add leading zero, escape as hex string and parse with printf\n  # shellcheck disable=SC2059\n  printf \"%b\" \"$(cat | _sed -e 's/[[:space:]]//g' -e 's/^(.(.{2})*)$/0\\1/' -e 's/(.{2})/\\\\x\\1/g')\"\n}\n\n# Convert binary data to hex string\nbin2hex() {\n  hexdump -v -e '/1 \"%02x\"'\n}\n\n# OpenSSL writes to stderr/stdout even when there are no errors. So just\n# display the output if the exit code was != 0 to simplify debugging.\n_openssl() {\n  set +e\n  out=\"$(\"${OPENSSL}\" \"${@}\" 2>&1)\"\n  res=$?\n  set -e\n  if [[ ${res} -ne 0 ]]; then\n    echo \"  + ERROR: failed to run $* (Exitcode: ${res})\" >&2\n    echo >&2\n    echo \"Details:\" >&2\n    echo \"${out}\" >&2\n    echo >&2\n    exit \"${res}\"\n  fi\n}\n\n# Send http(s) request with specified method\nhttp_request() {\n  tempcont=\"$(_mktemp)\"\n  tempheaders=\"$(_mktemp)\"\n\n  if [[ -n \"${IP_VERSION:-}\" ]]; then\n      ip_version=\"-${IP_VERSION}\"\n  fi\n\n  set +e\n  # shellcheck disable=SC2086\n  if [[ \"${1}\" = \"head\" ]]; then\n    statuscode=\"$(curl ${ip_version:-} ${CURL_OPTS} -A \"dehydrated/${VERSION} curl/${CURL_VERSION}\" -s -w \"%{http_code}\" -o \"${tempcont}\" \"${2}\" -I)\"\n    curlret=\"${?}\"\n    touch \"${tempheaders}\"\n  elif [[ \"${1}\" = \"get\" ]]; then\n    statuscode=\"$(curl ${ip_version:-} ${CURL_OPTS} -A \"dehydrated/${VERSION} curl/${CURL_VERSION}\" -L -s -w \"%{http_code}\" -o \"${tempcont}\" -D \"${tempheaders}\" \"${2}\")\"\n    curlret=\"${?}\"\n  elif [[ \"${1}\" = \"post\" ]]; then\n    statuscode=\"$(curl ${ip_version:-} ${CURL_OPTS} -A \"dehydrated/${VERSION} curl/${CURL_VERSION}\" -s -w \"%{http_code}\" -o \"${tempcont}\" \"${2}\" -D \"${tempheaders}\" -H 'Content-Type: application/jose+json' -d \"${3}\")\"\n    curlret=\"${?}\"\n  else\n    set -e\n    _exiterr \"Unknown request method: ${1}\"\n  fi\n  set -e\n\n  if [[ ! \"${curlret}\" = \"0\" ]]; then\n    _exiterr \"Problem connecting to server (${1} for ${2}; curl returned with ${curlret})\"\n  fi\n\n  if [[ ! \"${statuscode:0:1}\" = \"2\" ]]; then\n    # check for existing registration warning\n    if [[ \"${API}\" = \"1\" ]] && [[ -n \"${CA_NEW_REG:-}\" ]] && [[ \"${2}\" = \"${CA_NEW_REG:-}\" ]] && [[ \"${statuscode}\" = \"409\" ]] && grep -q \"Registration key is already in use\" \"${tempcont}\"; then\n      # do nothing\n      :\n    # check for already-revoked warning\n    elif [[ -n \"${CA_REVOKE_CERT:-}\" ]] && [[ \"${2}\" = \"${CA_REVOKE_CERT:-}\" ]] && [[ \"${statuscode}\" = \"409\" ]]; then\n      grep -q \"Certificate already revoked\" \"${tempcont}\" && return\n    else\n      if grep -q \"urn:ietf:params:acme:error:badNonce\" \"${tempcont}\"; then\n        printf \"badnonce %s\" \"$(grep -Eoi \"^replay-nonce:.*$\" \"${tempheaders}\" | sed 's/ //' | cut -d: -f2)\"\n        return 0\n      fi\n      echo \"  + ERROR: An error occurred while sending ${1}-request to ${2} (Status ${statuscode})\" >&2\n      echo >&2\n      echo \"Details:\" >&2\n      cat \"${tempheaders}\" >&2\n      cat \"${tempcont}\" >&2\n      echo >&2\n      echo >&2\n\n      # An exclusive hook for the {1}-request error might be useful (e.g., for sending an e-mail to admins)\n      if [[ -n \"${HOOK}\" ]]; then\n        errtxt=\"$(cat \"${tempcont}\")\"\n        errheaders=\"$(cat \"${tempheaders}\")\"\n        \"${HOOK}\" \"request_failure\" \"${statuscode}\" \"${errtxt}\" \"${1}\" \"${errheaders}\" || _exiterr 'request_failure hook returned with non-zero exit code'\n      fi\n\n      rm -f \"${tempcont}\"\n      rm -f \"${tempheaders}\"\n\n      # remove temporary domains.txt file if used\n      [[ \"${COMMAND:-}\" = \"sign_domains\" && -n \"${PARAM_DOMAIN:-}\" && -n \"${DOMAINS_TXT:-}\" ]] && rm \"${DOMAINS_TXT}\"\n      _exiterr\n    fi\n  fi\n\n  if { true >&4; } 2>/dev/null; then\n    cat \"${tempheaders}\" >&4\n  fi\n  cat \"${tempcont}\"\n  rm -f \"${tempcont}\"\n  rm -f \"${tempheaders}\"\n}\n\n# Send signed request\nsigned_request() {\n  # Encode payload as urlbase64\n  payload64=\"$(printf '%s' \"${2}\" | urlbase64)\"\n\n  if [ -n \"${3:-}\" ]; then\n    nonce=\"$(printf \"%s\" \"${3}\" | tr -d ' \\t\\n\\r')\"\n  else\n    # Retrieve nonce from acme-server\n    if [[ ${API} -eq 1 ]]; then\n      nonce=\"$(http_request head \"${CA}\" | grep -i ^Replay-Nonce: | cut -d':' -f2- | tr -d ' \\t\\n\\r')\"\n    else\n      nonce=\"$(http_request head \"${CA_NEW_NONCE}\" | grep -i ^Replay-Nonce: | cut -d':' -f2- | tr -d ' \\t\\n\\r')\"\n    fi\n  fi\n\n  if [[ ${API} -eq 1 ]]; then\n    # Build another header which also contains the previously received nonce and encode it as urlbase64\n    protected='{\"alg\": \"RS256\", \"jwk\": {\"e\": \"'\"${pubExponent64}\"'\", \"kty\": \"RSA\", \"n\": \"'\"${pubMod64}\"'\"}, \"nonce\": \"'\"${nonce}\"'\"}'\n    protected64=\"$(printf '%s' \"${protected}\" | urlbase64)\"\n  else\n    # Build another header which also contains the previously received nonce and url and encode it as urlbase64\n    if [[ -n \"${ACCOUNT_URL:-}\" ]]; then\n      protected='{\"alg\": \"'\"${account_key_sigalgo}\"'\", \"kid\": \"'\"${ACCOUNT_URL}\"'\", \"url\": \"'\"${1}\"'\", \"nonce\": \"'\"${nonce}\"'\"}'\n    else\n      protected='{\"alg\": \"'\"${account_key_sigalgo}\"'\", \"jwk\": '\"${account_key_info}\"', \"url\": \"'\"${1}\"'\", \"nonce\": \"'\"${nonce}\"'\"}'\n    fi\n    protected64=\"$(printf '%s' \"${protected}\" | urlbase64)\"\n  fi\n\n  # Sign header with nonce and our payload with our private key and encode signature as urlbase64\n  if [[ \"${account_key_sigalgo}\" = \"RS256\" ]]; then\n    signed64=\"$(printf '%s' \"${protected64}.${payload64}\" | \"${OPENSSL}\" dgst -sha256 -sign \"${ACCOUNT_KEY}\" | urlbase64)\"\n  else\n    dgstparams=\"$(printf '%s' \"${protected64}.${payload64}\" | \"${OPENSSL}\" dgst -sha${account_key_sigalgo:2} -sign \"${ACCOUNT_KEY}\" | \"${OPENSSL}\" asn1parse -inform DER)\"\n    dgst_parm_1=\"$(echo \"$dgstparams\" | head -n 2 | tail -n 1 | cut -d':' -f4)\"\n    dgst_parm_2=\"$(echo \"$dgstparams\" | head -n 3 | tail -n 1 | cut -d':' -f4)\"\n\n    # zero-padding (doesn't seem to be necessary, but other clients are doing this as well...\n    case \"${account_key_sigalgo}\" in\n      \"ES256\") siglen=64;;\n      \"ES384\") siglen=96;;\n      \"ES512\") siglen=132;;\n    esac\n    while [[ ${#dgst_parm_1} -lt $siglen ]]; do dgst_parm_1=\"0${dgst_parm_1}\"; done\n    while [[ ${#dgst_parm_2} -lt $siglen ]]; do dgst_parm_2=\"0${dgst_parm_2}\"; done\n\n    signed64=\"$(printf \"%s%s\" \"${dgst_parm_1}\" \"${dgst_parm_2}\" | hex2bin | urlbase64)\"\n  fi\n\n  if [[ ${API} -eq 1 ]]; then\n    # Build header with just our public key and algorithm information\n    header='{\"alg\": \"RS256\", \"jwk\": {\"e\": \"'\"${pubExponent64}\"'\", \"kty\": \"RSA\", \"n\": \"'\"${pubMod64}\"'\"}}'\n\n    # Send header + extended header + payload + signature to the acme-server\n    data='{\"header\": '\"${header}\"', \"protected\": \"'\"${protected64}\"'\", \"payload\": \"'\"${payload64}\"'\", \"signature\": \"'\"${signed64}\"'\"}'\n  else\n    # Send extended header + payload + signature to the acme-server\n    data='{\"protected\": \"'\"${protected64}\"'\", \"payload\": \"'\"${payload64}\"'\", \"signature\": \"'\"${signed64}\"'\"}'\n  fi\n\n  output=\"$(http_request post \"${1}\" \"${data}\")\"\n\n  if grep -qE \"^badnonce \" <<< \"${output}\"; then\n    echo \" ! Request failed (badNonce), retrying request...\" >&2\n    signed_request \"${1:-}\" \"${2:-}\" \"$(printf \"%s\" \"${output}\" | cut -d' ' -f2)\"\n  else\n    printf \"%s\" \"${output}\"\n  fi\n}\n\n# Extracts all subject names from a CSR\n# Outputs either the CN, or the SANs, one per line\nextract_altnames() {\n  csr=\"${1}\" # the CSR itself (not a file)\n\n  if ! <<<\"${csr}\" \"${OPENSSL}\" req -verify -noout >/dev/null 2>&1; then\n    _exiterr \"Certificate signing request isn't valid\"\n  fi\n\n  reqtext=\"$( <<<\"${csr}\" \"${OPENSSL}\" req -noout -text )\"\n  if <<<\"${reqtext}\" grep -q '^[[:space:]]*X509v3 Subject Alternative Name:[[:space:]]*$'; then\n    # SANs used, extract these\n    altnames=\"$( <<<\"${reqtext}\" awk '/X509v3 Subject Alternative Name:/{print;getline;print;}' | tail -n1 )\"\n    # split to one per line:\n    # shellcheck disable=SC1003\n    altnames=\"$( <<<\"${altnames}\" _sed -e 's/^[[:space:]]*//; s/, /\\'$'\\n''/g' )\"\n    # we can only get DNS/IP: ones signed\n    if grep -qEv '^(DNS|IP( Address)*|othername):' <<<\"${altnames}\"; then\n      _exiterr \"Certificate signing request contains non-DNS/IP Subject Alternative Names\"\n    fi\n    # strip away the DNS/IP: prefix\n    altnames=\"$( <<<\"${altnames}\" _sed -e 's/^(DNS:|IP( Address)*:|othername:<unsupported>)//' )\"\n    printf \"%s\" \"${altnames}\" | tr '\\n' ' '\n  else\n    # No SANs, extract CN\n    altnames=\"$( <<<\"${reqtext}\" grep '^[[:space:]]*Subject:' | _sed -e 's/.*[ /]CN ?= ?([^ /,]*).*/\\1/' )\"\n    printf \"%s\" \"${altnames}\"\n  fi\n}\n\n# Get last issuer CN in certificate chain\nget_last_cn() {\n  <<<\"${1}\" _sed 'H;/-----BEGIN CERTIFICATE-----/h;$!d;x' | \"${OPENSSL}\" x509 -noout -issuer | head -n1 | _sed -e 's/.*[ /]CN ?= ?([^/,]*).*/\\1/'\n}\n\n# Create certificate for domain(s) and outputs it FD 3\nsign_csr() {\n  csr=\"${1}\" # the CSR itself (not a file)\n\n  if { true >&3; } 2>/dev/null; then\n    : # fd 3 looks OK\n  else\n    _exiterr \"sign_csr: FD 3 not open\"\n  fi\n\n  shift 1 || true\n  export altnames=\"${*}\"\n\n  if [[ ${API} -eq 1 ]]; then\n    if [[ -z \"${CA_NEW_AUTHZ}\" ]] || [[ -z \"${CA_NEW_CERT}\" ]]; then\n      _exiterr \"Certificate authority doesn't allow certificate signing\"\n    fi\n  elif [[ ${API} -eq 2 ]] && [[ -z \"${CA_NEW_ORDER}\" ]]; then\n    _exiterr \"Certificate authority doesn't allow certificate signing\"\n  fi\n\n  if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    local -A challenge_names challenge_uris challenge_tokens authorizations keyauths deploy_args\n  else\n    local -a challenge_names challenge_uris challenge_tokens authorizations keyauths deploy_args\n  fi\n\n  # Initial step: Find which authorizations we're dealing with\n  if [[ ${API} -eq 2 ]]; then\n    # Request new order and store authorization URIs\n    local challenge_identifiers=\"\"\n    for altname in ${altnames}; do\n    if [[ \"${altname}\" =~ ^ip: ]]; then\n      challenge_identifiers+=\"$(printf '{\"type\": \"ip\", \"value\": \"%s\"}, ' \"${altname:3}\")\"\n    else\n       challenge_identifiers+=\"$(printf '{\"type\": \"dns\", \"value\": \"%s\"}, ' \"${altname}\")\"\n    fi\n    done\n    challenge_identifiers=\"[${challenge_identifiers%, }]\"\n\n    echo \" + Requesting new certificate order from CA...\"\n    order_location=\"$(signed_request \"${CA_NEW_ORDER}\" '{\"identifiers\": '\"${challenge_identifiers}\"'}' 4>&1 | grep -i ^Location: | cut -d':' -f2- | tr -d ' \\t\\r\\n')\"\n    result=\"$(signed_request \"${order_location}\" \"\" | jsonsh)\"\n\n    order_authorizations=\"$(echo \"${result}\" | get_json_array_values authorizations)\"\n    finalize=\"$(echo \"${result}\" | get_json_string_value finalize)\"\n\n    local idx=0\n    for uri in ${order_authorizations}; do\n      authorizations[${idx}]=\"${uri}\"\n      idx=$((idx+1))\n    done\n    echo \" + Received ${idx} authorizations URLs from the CA\"\n  else\n    # Copy $altnames to $authorizations (just doing this to reduce duplicate code later on)\n    local idx=0\n    for altname in ${altnames}; do\n      authorizations[${idx}]=\"${altname}\"\n      idx=$((idx+1))\n    done\n  fi\n\n  # Check if authorizations are valid and gather challenge information for pending authorizations\n  local idx=0\n  for authorization in ${authorizations[*]}; do\n    if [[ \"${API}\" -eq 2 ]]; then\n      # Receive authorization ($authorization is authz uri)\n      response=\"$(signed_request \"$(echo \"${authorization}\" | _sed -e 's/\\\"(.*)\".*/\\1/')\" \"\" | jsonsh)\"\n      identifier=\"$(echo \"${response}\" | get_json_string_value -p '\"identifier\",\"value\"')\"\n      identifier_type=\"$(echo \"${response}\" | get_json_string_value -p '\"identifier\",\"type\"')\"\n      echo \" + Handling authorization for ${identifier}\"\n    else\n      # Request new authorization ($authorization is altname)\n      identifier=\"${authorization}\"\n      echo \" + Requesting authorization for ${identifier}...\"\n      response=\"$(signed_request \"${CA_NEW_AUTHZ}\" '{\"resource\": \"new-authz\", \"identifier\": {\"type\": \"dns\", \"value\": \"'\"${identifier}\"'\"}}' | jsonsh)\"\n    fi\n\n    # Check if authorization has already been validated\n    if [ \"$(echo \"${response}\" | get_json_string_value status)\" = \"valid\" ]; then\n      if [ \"${PARAM_FORCE_VALIDATION:-no}\" = \"yes\" ]; then\n        echo \" + A valid authorization has been found but will be ignored\"\n      else\n        echo \" + Found valid authorization for ${identifier}\"\n        continue\n      fi\n    fi\n\n    # Find challenge in authorization\n    challengeindex=\"$(echo \"${response}\" | grep -E '^\\[\"challenges\",[0-9]+,\"type\"\\][[:space:]]+\"'\"${CHALLENGETYPE}\"'\"' | cut -d',' -f2 || true)\"\n\n    if [ -z \"${challengeindex}\" ]; then\n      allowed_validations=\"$(echo \"${response}\" | grep -E '^\\[\"challenges\",[0-9]+,\"type\"\\]' | sed -e 's/\\[[^\\]*\\][[:space:]]*//g' -e 's/^\"//' -e 's/\"$//' | tr '\\n' ' ')\"\n      _exiterr \"Validating this certificate is not possible using ${CHALLENGETYPE}. Possible validation methods are: ${allowed_validations}\"\n    fi\n    challenge=\"$(echo \"${response}\" | get_json_dict_value -p '\"challenges\",'\"${challengeindex}\")\"\n\n    # Gather challenge information\n    if [ \"${identifier_type:-}\" = \"ip\" ] && [ \"${CHALLENGETYPE}\" = \"tls-alpn-01\" ] ; then\n      challenge_names[${idx}]=\"$(echo \"${identifier}\" | ip_to_ptr)\"\n    else\n      challenge_names[${idx}]=\"${identifier}\"\n    fi\n    challenge_tokens[${idx}]=\"$(echo \"${challenge}\" | get_json_string_value token)\"\n\n    if [[ ${API} -eq 2 ]]; then\n      challenge_uris[${idx}]=\"$(echo \"${challenge}\" | get_json_string_value url)\"\n    else\n      if [[ \"$(echo \"${challenge}\" | get_json_string_value type)\" = \"urn:acme:error:unauthorized\" ]]; then\n        _exiterr \"Challenge unauthorized: $(echo \"${challenge}\" | get_json_string_value detail)\"\n      fi\n      challenge_uris[${idx}]=\"$(echo \"${challenge}\" | get_json_dict_value validationRecord | get_json_string_value uri)\"\n    fi\n\n    # Prepare challenge tokens and deployment parameters\n    keyauth=\"${challenge_tokens[${idx}]}.${thumbprint}\"\n\n    case \"${CHALLENGETYPE}\" in\n      \"http-01\")\n        # Store challenge response in well-known location and make world-readable (so that a webserver can access it)\n        printf '%s' \"${keyauth}\" > \"${WELLKNOWN}/${challenge_tokens[${idx}]}\"\n        chmod a+r \"${WELLKNOWN}/${challenge_tokens[${idx}]}\"\n        keyauth_hook=\"${keyauth}\"\n        ;;\n      \"dns-01\")\n        # Generate DNS entry content for dns-01 validation\n        keyauth_hook=\"$(printf '%s' \"${keyauth}\" | \"${OPENSSL}\" dgst -sha256 -binary | urlbase64)\"\n        ;;\n      \"tls-alpn-01\")\n        keyauth_hook=\"$(printf '%s' \"${keyauth}\" | \"${OPENSSL}\" dgst -sha256 -c -hex | awk '{print $NF}')\"\n        generate_alpn_certificate \"${identifier}\" \"${identifier_type}\" \"${keyauth_hook}\"\n        ;;\n    esac\n\n    keyauths[${idx}]=\"${keyauth}\"\n    if [ \"${identifier_type:-}\" = \"ip\" ] && [ \"${CHALLENGETYPE}\" = \"tls-alpn-01\" ]; then\n      deploy_args[${idx}]=\"$(echo \"${identifier}\" | ip_to_ptr) ${challenge_tokens[${idx}]} ${keyauth_hook}\"\n    else\n      deploy_args[${idx}]=\"${identifier} ${challenge_tokens[${idx}]} ${keyauth_hook}\"\n    fi\n\n    idx=$((idx+1))\n  done\n  local num_pending_challenges=${idx}\n  echo \" + ${num_pending_challenges} pending challenge(s)\"\n\n  # Deploy challenge tokens\n  if [[ ${num_pending_challenges} -ne 0 ]]; then\n    echo \" + Deploying challenge tokens...\"\n    if [[ -n \"${HOOK}\" ]] && [[ \"${HOOK_CHAIN}\" = \"yes\" ]]; then\n      # shellcheck disable=SC2068\n      \"${HOOK}\" \"deploy_challenge\" ${deploy_args[@]} || _exiterr 'deploy_challenge hook returned with non-zero exit code'\n    elif [[ -n \"${HOOK}\" ]]; then\n      # Run hook script to deploy the challenge token\n      local idx=0\n      while [ ${idx} -lt ${num_pending_challenges} ]; do\n        # shellcheck disable=SC2086\n        \"${HOOK}\" \"deploy_challenge\" ${deploy_args[${idx}]} || _exiterr 'deploy_challenge hook returned with non-zero exit code'\n        idx=$((idx+1))\n      done\n    fi\n  fi\n\n  # Validate pending challenges\n  local idx=0\n  while [ ${idx} -lt ${num_pending_challenges} ]; do\n    echo \" + Responding to challenge for ${challenge_names[${idx}]} authorization...\"\n\n    # Ask the acme-server to verify our challenge and wait until it is no longer pending\n    if [[ ${API} -eq 1 ]]; then\n      result=\"$(signed_request \"${challenge_uris[${idx}]}\" '{\"resource\": \"challenge\", \"keyAuthorization\": \"'\"${keyauths[${idx}]}\"'\"}' | jsonsh)\"\n    else\n      result=\"$(signed_request \"${challenge_uris[${idx}]}\" '{}' | jsonsh)\"\n    fi\n\n    reqstatus=\"$(echo \"${result}\" | get_json_string_value status)\"\n\n    while [[ \"${reqstatus}\" = \"pending\" ]] || [[ \"${reqstatus}\" = \"processing\" ]]; do\n      sleep 1\n      if [[ \"${API}\" -eq 2 ]]; then\n        result=\"$(signed_request \"${challenge_uris[${idx}]}\" \"\" | jsonsh)\"\n      else\n        result=\"$(http_request get \"${challenge_uris[${idx}]}\" | jsonsh)\"\n      fi\n      reqstatus=\"$(echo \"${result}\" | get_json_string_value status)\"\n    done\n\n    [[ \"${CHALLENGETYPE}\" = \"http-01\" ]] && rm -f \"${WELLKNOWN}/${challenge_tokens[${idx}]}\"\n    [[ \"${CHALLENGETYPE}\" = \"tls-alpn-01\" ]] && rm -f \"${ALPNCERTDIR}/${challenge_names[${idx}]}.crt.pem\" \"${ALPNCERTDIR}/${challenge_names[${idx}]}.key.pem\"\n\n    if [[ \"${reqstatus}\" = \"valid\" ]]; then\n      echo \" + Challenge is valid!\"\n    else\n      [[ -n \"${HOOK}\" ]] && (\"${HOOK}\" \"invalid_challenge\" \"${altname}\" \"${result}\" || _exiterr 'invalid_challenge hook returned with non-zero exit code')\n      break\n    fi\n    idx=$((idx+1))\n  done\n\n  if [[ ${num_pending_challenges} -ne 0 ]]; then\n    echo \" + Cleaning challenge tokens...\"\n\n    # Clean challenge tokens using chained hook\n    # shellcheck disable=SC2068\n    [[ -n \"${HOOK}\" ]] && [[ \"${HOOK_CHAIN}\" = \"yes\" ]] && (\"${HOOK}\" \"clean_challenge\" ${deploy_args[@]} || _exiterr 'clean_challenge hook returned with non-zero exit code')\n\n    # Clean remaining challenge tokens if validation has failed\n    local idx=0\n    while [ ${idx} -lt ${num_pending_challenges} ]; do\n      # Delete challenge file\n      [[ \"${CHALLENGETYPE}\" = \"http-01\" ]] && rm -f \"${WELLKNOWN}/${challenge_tokens[${idx}]}\"\n      # Delete alpn verification certificates\n      [[ \"${CHALLENGETYPE}\" = \"tls-alpn-01\" ]] && rm -f \"${ALPNCERTDIR}/${challenge_names[${idx}]}.crt.pem\" \"${ALPNCERTDIR}/${challenge_names[${idx}]}.key.pem\"\n      # Clean challenge token using non-chained hook\n      # shellcheck disable=SC2086\n      [[ -n \"${HOOK}\" ]] && [[ \"${HOOK_CHAIN}\" != \"yes\" ]] && (\"${HOOK}\" \"clean_challenge\" ${deploy_args[${idx}]} || _exiterr 'clean_challenge hook returned with non-zero exit code')\n      idx=$((idx+1))\n    done\n\n    if [[ \"${reqstatus}\" != \"valid\" ]]; then\n      echo \" + Challenge validation has failed :(\"\n      _exiterr \"Challenge is invalid! (returned: ${reqstatus}) (result: ${result})\"\n    fi\n  fi\n\n  # Finally request certificate from the acme-server and store it in cert-${timestamp}.pem and link from cert.pem\n  echo \" + Requesting certificate...\"\n  csr64=\"$( <<<\"${csr}\" \"${OPENSSL}\" req -config \"${OPENSSL_CNF}\" -outform DER | urlbase64)\"\n  if [[ ${API} -eq 1 ]]; then\n    crt64=\"$(signed_request \"${CA_NEW_CERT}\" '{\"resource\": \"new-cert\", \"csr\": \"'\"${csr64}\"'\"}' | \"${OPENSSL}\" base64 -e)\"\n    crt=\"$( printf -- '-----BEGIN CERTIFICATE-----\\n%s\\n-----END CERTIFICATE-----\\n' \"${crt64}\" )\"\n  else\n    result=\"$(signed_request \"${finalize}\" '{\"csr\": \"'\"${csr64}\"'\"}' | jsonsh)\"\n    while :; do\n      orderstatus=\"$(echo \"${result}\" | get_json_string_value status)\"\n      case \"${orderstatus}\"\n      in\n        \"processing\" | \"pending\")\n          echo \" + Order is ${orderstatus}...\"\n          sleep 2;\n          ;;\n        \"valid\")\n          break;\n          ;;\n        *)\n          _exiterr \"Order in status ${orderstatus}\"\n          ;;\n      esac\n      result=\"$(signed_request \"${order_location}\" \"\" | jsonsh)\"\n    done\n\n    resheaders=\"$(_mktemp)\"\n    certificate=\"$(echo \"${result}\" | get_json_string_value certificate)\"\n    crt=\"$(signed_request \"${certificate}\" \"\" 4>\"${resheaders}\")\"\n\n    if [ -n \"${PREFERRED_CHAIN:-}\" ]; then\n      foundaltchain=0\n      altcn=\"$(get_last_cn \"${crt}\")\"\n      altoptions=\"${altcn}\"\n      if [ \"${altcn}\" = \"${PREFERRED_CHAIN}\" ]; then\n        foundaltchain=1\n      fi\n      if [ \"${foundaltchain}\" = \"0\" ] && (grep -Ei '^link:' \"${resheaders}\" | grep -q -Ei 'rel=\"alternate\"'); then\n        while read -r altcrturl; do\n          if [ \"${foundaltchain}\" = \"0\" ]; then\n            altcrt=\"$(signed_request \"${altcrturl}\" \"\")\"\n            altcn=\"$(get_last_cn \"${altcrt}\")\"\n            altoptions=\"${altoptions}, ${altcn}\"\n            if [ \"${altcn}\" = \"${PREFERRED_CHAIN}\" ]; then\n              foundaltchain=1\n              crt=\"${altcrt}\"\n            fi\n          fi\n        done <<< \"$(grep -Ei '^link:' \"${resheaders}\" | grep -Ei 'rel=\"alternate\"' | cut -d'<' -f2 | cut -d'>' -f1)\"\n      fi\n      if [ \"${foundaltchain}\" = \"0\" ]; then\n        _exiterr \"Alternative chain with CN = ${PREFERRED_CHAIN} not found, available options: ${altoptions}\"\n      fi\n      echo \" + Using preferred chain with CN = ${altcn}\"\n    fi\n    rm -f \"${resheaders}\"\n  fi\n\n  # Try to load the certificate to detect corruption\n  echo \" + Checking certificate...\"\n  _openssl x509 -text <<<\"${crt}\"\n\n  echo \"${crt}\" >&3\n\n  unset challenge_token\n  echo \" + Done!\"\n}\n\n# grep issuer cert uri from certificate\nget_issuer_cert_uri() {\n  certificate=\"${1}\"\n  \"${OPENSSL}\" x509 -in \"${certificate}\" -noout -text | (grep 'CA Issuers - URI:' | cut -d':' -f2-) || true\n}\n\nget_issuer_hash() {\n  certificate=\"${1}\"\n  \"${OPENSSL}\" x509 -in \"${certificate}\" -noout -issuer_hash\n}\n\nget_ocsp_url() {\n  certificate=\"${1}\"\n  \"${OPENSSL}\" x509 -in \"${certificate}\" -noout -ocsp_uri\n}\n\n# walk certificate chain, retrieving all intermediate certificates\nwalk_chain() {\n  local certificate\n  certificate=\"${1}\"\n\n  local issuer_cert_uri\n  issuer_cert_uri=\"${2:-}\"\n  if [[ -z \"${issuer_cert_uri}\" ]]; then issuer_cert_uri=\"$(get_issuer_cert_uri \"${certificate}\")\"; fi\n  if [[ -n \"${issuer_cert_uri}\" ]]; then\n    # create temporary files\n    local tmpcert\n    local tmpcert_raw\n    tmpcert_raw=\"$(_mktemp)\"\n    tmpcert=\"$(_mktemp)\"\n\n    # download certificate\n    http_request get \"${issuer_cert_uri}\" > \"${tmpcert_raw}\"\n\n    # PEM\n    if grep -q \"BEGIN CERTIFICATE\" \"${tmpcert_raw}\"; then mv \"${tmpcert_raw}\" \"${tmpcert}\"\n    # DER\n    elif \"${OPENSSL}\" x509 -in \"${tmpcert_raw}\" -inform DER -out \"${tmpcert}\" -outform PEM 2> /dev/null > /dev/null; then :\n    # PKCS7\n    elif \"${OPENSSL}\" pkcs7 -in \"${tmpcert_raw}\" -inform DER -out \"${tmpcert}\" -outform PEM -print_certs 2> /dev/null > /dev/null; then :\n    # Unknown certificate type\n    else _exiterr \"Unknown certificate type in chain\"\n    fi\n\n    local next_issuer_cert_uri\n    next_issuer_cert_uri=\"$(get_issuer_cert_uri \"${tmpcert}\")\"\n    if [[ -n \"${next_issuer_cert_uri}\" ]]; then\n      printf \"\\n%s\\n\" \"${issuer_cert_uri}\"\n      cat \"${tmpcert}\"\n      walk_chain \"${tmpcert}\" \"${next_issuer_cert_uri}\"\n    fi\n    rm -f \"${tmpcert}\" \"${tmpcert_raw}\"\n  fi\n}\n\n# Generate ALPN verification certificate\ngenerate_alpn_certificate() {\n  local altname=\"${1}\"\n  local identifier_type=\"${2}\"\n  local acmevalidation=\"${3}\"\n\n  local alpncertdir=\"${ALPNCERTDIR}\"\n  if [[ ! -e \"${alpncertdir}\" ]]; then\n    echo \" + Creating new directory ${alpncertdir} ...\"\n    mkdir -p \"${alpncertdir}\" || _exiterr \"Unable to create directory ${alpncertdir}\"\n  fi\n\n  echo \" + Generating ALPN certificate and key for ${1}...\"\n  tmp_openssl_cnf=\"$(_mktemp)\"\n  cat \"${OPENSSL_CNF}\" > \"${tmp_openssl_cnf}\"\n  if [[ \"${identifier_type}\" = \"ip\" ]]; then\n    printf \"\\n[SAN]\\nsubjectAltName=IP:%s\\n\" \"${altname}\" >> \"${tmp_openssl_cnf}\"\n  else\n    printf \"\\n[SAN]\\nsubjectAltName=DNS:%s\\n\" \"${altname}\" >> \"${tmp_openssl_cnf}\"\n  fi\n  printf \"1.3.6.1.5.5.7.1.31=critical,DER:04:20:%s\\n\" \"${acmevalidation}\" >> \"${tmp_openssl_cnf}\"\n  SUBJ=\"/CN=${altname}/\"\n  [[ \"${OSTYPE:0:5}\" = \"MINGW\" ]] && SUBJ=\"/${SUBJ}\"\n  if [[ \"${identifier_type}\" = \"ip\" ]]; then\n    altname=\"$(echo \"${altname}\" | ip_to_ptr)\"\n  fi\n  _openssl req -x509 -new -sha256 -nodes -newkey rsa:2048 -keyout \"${alpncertdir}/${altname}.key.pem\" -out \"${alpncertdir}/${altname}.crt.pem\" -subj \"${SUBJ}\" -extensions SAN -config \"${tmp_openssl_cnf}\"\n  chmod g+r \"${alpncertdir}/${altname}.key.pem\" \"${alpncertdir}/${altname}.crt.pem\"\n  rm -f \"${tmp_openssl_cnf}\"\n}\n\n# Create certificate for domain(s)\nsign_domain() {\n  local certdir=\"${1}\"\n  shift\n  timestamp=\"${1}\"\n  shift\n  domain=\"${1}\"\n  altnames=\"${*}\"\n\n  export altnames\n\n  echo \" + Signing domains...\"\n  if [[ ${API} -eq 1 ]]; then\n    if [[ -z \"${CA_NEW_AUTHZ}\" ]] || [[ -z \"${CA_NEW_CERT}\" ]]; then\n      _exiterr \"Certificate authority doesn't allow certificate signing\"\n    fi\n  elif [[ ${API} -eq 2 ]] && [[ -z \"${CA_NEW_ORDER}\" ]]; then\n    _exiterr \"Certificate authority doesn't allow certificate signing\"\n  fi\n\n  local privkey=\"privkey.pem\"\n  if [[ ! -e \"${certdir}/cert-${timestamp}.csr\" ]]; then\n    # generate a new private key if we need or want one\n    if [[ ! -r \"${certdir}/privkey.pem\" ]] || [[ \"${PRIVATE_KEY_RENEW}\" = \"yes\" ]]; then\n      echo \" + Generating private key...\"\n      privkey=\"privkey-${timestamp}.pem\"\n      local tmp_privkey\n      tmp_privkey=\"$(_mktemp)\"\n      case \"${KEY_ALGO}\" in\n        rsa) _openssl genrsa -out \"${tmp_privkey}\" \"${KEYSIZE}\";;\n        prime256v1|secp384r1) _openssl ecparam -genkey -name \"${KEY_ALGO}\" -out \"${tmp_privkey}\" -noout;;\n      esac\n      cat \"${tmp_privkey}\" > \"${certdir}/privkey-${timestamp}.pem\"\n      rm \"${tmp_privkey}\"\n    fi\n    # move rolloverkey into position (if any)\n    if [[ -r \"${certdir}/privkey.pem\" && -r \"${certdir}/privkey.roll.pem\" && \"${PRIVATE_KEY_RENEW}\" = \"yes\" && \"${PRIVATE_KEY_ROLLOVER}\" = \"yes\" ]]; then\n      echo \" + Moving Rolloverkey into position....  \"\n      mv \"${certdir}/privkey.roll.pem\" \"${certdir}/privkey-tmp.pem\"\n      mv \"${certdir}/privkey-${timestamp}.pem\" \"${certdir}/privkey.roll.pem\"\n      mv \"${certdir}/privkey-tmp.pem\" \"${certdir}/privkey-${timestamp}.pem\"\n    fi\n    # generate a new private rollover key if we need or want one\n    if [[ ! -r \"${certdir}/privkey.roll.pem\" && \"${PRIVATE_KEY_ROLLOVER}\" = \"yes\" && \"${PRIVATE_KEY_RENEW}\" = \"yes\" ]]; then\n      echo \" + Generating private rollover key...\"\n      case \"${KEY_ALGO}\" in\n        rsa) _openssl genrsa -out \"${certdir}/privkey.roll.pem\" \"${KEYSIZE}\";;\n        prime256v1|secp384r1) _openssl ecparam -genkey -name \"${KEY_ALGO}\" -out \"${certdir}/privkey.roll.pem\" -noout;;\n      esac\n    fi\n    # delete rolloverkeys if disabled\n    if [[ -r \"${certdir}/privkey.roll.pem\" && ! \"${PRIVATE_KEY_ROLLOVER}\" = \"yes\" ]]; then\n      echo \" + Removing Rolloverkey (feature disabled)...\"\n      rm -f \"${certdir}/privkey.roll.pem\"\n    fi\n\n    # Generate signing request config and the actual signing request\n    echo \" + Generating signing request...\"\n    SAN=\"\"\n    for altname in ${altnames}; do\n      if [[ \"${altname}\" =~ ^ip: ]]; then\n        SAN=\"${SAN}IP:${altname:3}, \"\n      else\n        SAN=\"${SAN}DNS:${altname}, \"\n      fi\n    done\n    if [[ \"${domain}\" =~ ^ip: ]]; then\n      SUBJ=\"/CN=${domain:3}/\"\n    else\n      SUBJ=\"/CN=${domain}/\"\n    fi\n    SAN=\"${SAN%%, }\"\n    local tmp_openssl_cnf\n    tmp_openssl_cnf=\"$(_mktemp)\"\n    cat \"${OPENSSL_CNF}\" > \"${tmp_openssl_cnf}\"\n    printf \"\\n[SAN]\\nsubjectAltName=%s\" \"${SAN}\" >> \"${tmp_openssl_cnf}\"\n    if [ \"${OCSP_MUST_STAPLE}\" = \"yes\" ]; then\n      printf \"\\n1.3.6.1.5.5.7.1.24=DER:30:03:02:01:05\" >> \"${tmp_openssl_cnf}\"\n    fi\n    if [[ \"${OSTYPE:0:5}\" = \"MINGW\" ]]; then\n      # The subject starts with a /, so MSYS will assume it's a path and convert\n      # it unless we escape it with another one:\n      SUBJ=\"/${SUBJ}\"\n    fi\n    \"${OPENSSL}\" req -new -sha256 -key \"${certdir}/${privkey}\" -out \"${certdir}/cert-${timestamp}.csr\" -subj \"${SUBJ}\" -reqexts SAN -config \"${tmp_openssl_cnf}\"\n    rm -f \"${tmp_openssl_cnf}\"\n  fi\n\n  crt_path=\"${certdir}/cert-${timestamp}.pem\"\n  # shellcheck disable=SC2086\n  sign_csr \"$(< \"${certdir}/cert-${timestamp}.csr\")\" ${altnames} 3>\"${crt_path}\"\n\n  # Create fullchain.pem\n  echo \" + Creating fullchain.pem...\"\n  if [[ ${API} -eq 1 ]]; then\n    cat \"${crt_path}\" > \"${certdir}/fullchain-${timestamp}.pem\"\n    local issuer_hash\n    issuer_hash=\"$(get_issuer_hash \"${crt_path}\")\"\n    if [ -e \"${CHAINCACHE}/${issuer_hash}.chain\" ]; then\n      echo \" + Using cached chain!\"\n      cat \"${CHAINCACHE}/${issuer_hash}.chain\" > \"${certdir}/chain-${timestamp}.pem\"\n    else\n      echo \" + Walking chain...\"\n      local issuer_cert_uri\n      issuer_cert_uri=\"$(get_issuer_cert_uri \"${crt_path}\" || echo \"unknown\")\"\n      (walk_chain \"${crt_path}\" > \"${certdir}/chain-${timestamp}.pem\") || _exiterr \"Walking chain has failed, your certificate has been created and can be found at ${crt_path}, the corresponding private key at ${privkey}. If you want you can manually continue on creating and linking all necessary files. If this error occurs again you should manually generate the certificate chain and place it under ${CHAINCACHE}/${issuer_hash}.chain (see ${issuer_cert_uri})\"\n      cat \"${certdir}/chain-${timestamp}.pem\" > \"${CHAINCACHE}/${issuer_hash}.chain\"\n    fi\n    cat \"${certdir}/chain-${timestamp}.pem\" >> \"${certdir}/fullchain-${timestamp}.pem\"\n  else\n    tmpcert=\"$(_mktemp)\"\n    tmpchain=\"$(_mktemp)\"\n    awk '{print >out}; /----END CERTIFICATE-----/{out=tmpchain}' out=\"${tmpcert}\" tmpchain=\"${tmpchain}\" \"${certdir}/cert-${timestamp}.pem\"\n    mv \"${certdir}/cert-${timestamp}.pem\" \"${certdir}/fullchain-${timestamp}.pem\"\n    cat \"${tmpcert}\" > \"${certdir}/cert-${timestamp}.pem\"\n    cat \"${tmpchain}\" > \"${certdir}/chain-${timestamp}.pem\"\n    rm \"${tmpcert}\" \"${tmpchain}\"\n  fi\n\n  # Wait for hook script to sync the files before creating the symlinks\n  [[ -n \"${HOOK}\" ]] && (\"${HOOK}\" \"sync_cert\" \"${certdir}/privkey-${timestamp}.pem\" \"${certdir}/cert-${timestamp}.pem\" \"${certdir}/fullchain-${timestamp}.pem\" \"${certdir}/chain-${timestamp}.pem\" \"${certdir}/cert-${timestamp}.csr\" || _exiterr 'sync_cert hook returned with non-zero exit code')\n\n  # Update symlinks\n  [[ \"${privkey}\" = \"privkey.pem\" ]] || ln -sf \"privkey-${timestamp}.pem\" \"${certdir}/privkey.pem\"\n\n  ln -sf \"chain-${timestamp}.pem\" \"${certdir}/chain.pem\"\n  ln -sf \"fullchain-${timestamp}.pem\" \"${certdir}/fullchain.pem\"\n  ln -sf \"cert-${timestamp}.csr\" \"${certdir}/cert.csr\"\n  ln -sf \"cert-${timestamp}.pem\" \"${certdir}/cert.pem\"\n\n  # Wait for hook script to clean the challenge and to deploy cert if used\n  [[ -n \"${HOOK}\" ]] && (\"${HOOK}\" \"deploy_cert\" \"${domain}\" \"${certdir}/privkey.pem\" \"${certdir}/cert.pem\" \"${certdir}/fullchain.pem\" \"${certdir}/chain.pem\" \"${timestamp}\" || _exiterr 'deploy_cert hook returned with non-zero exit code')\n\n  unset challenge_token\n  echo \" + Done!\"\n}\n\n# Usage: --version (-v)\n# Description: Print version information\ncommand_version() {\n  load_config noverify\n\n  echo \"Dehydrated by Lukas Schauer\"\n  echo \"https://dehydrated.io\"\n  echo \"\"\n  echo \"Dehydrated version: ${VERSION}\"\n  revision=\"$(cd \"${SCRIPTDIR}\"; git rev-parse HEAD 2>/dev/null || echo \"unknown\")\"\n  echo \"GIT-Revision: ${revision}\"\n  echo \"\"\n  # shellcheck disable=SC1091\n  if [[ \"${OSTYPE}\" =~ (BSD|Darwin) ]]; then\n    echo \"OS: $(uname -sr)\"\n  elif [[ -e /etc/os-release ]]; then\n    ( . /etc/os-release && echo \"OS: $PRETTY_NAME\" )\n  elif [[ -e /usr/lib/os-release ]]; then\n    ( . /usr/lib/os-release && echo \"OS: $PRETTY_NAME\" )\n  else\n    echo \"OS: $(grep -v '^$' /etc/issue | head -n1 | _sed 's/\\\\(r|n|l) .*//g')\"\n  fi\n  echo \"Used software:\"\n  [[ -n \"${BASH_VERSION:-}\" ]] && echo \" bash: ${BASH_VERSION}\"\n  [[ -n \"${ZSH_VERSION:-}\" ]] && echo \" zsh: ${ZSH_VERSION}\"\n  echo \" curl: ${CURL_VERSION}\"\n  if [[ \"${OSTYPE}\" =~ (BSD|Darwin) ]]; then\n    echo \" awk, sed, mktemp, grep, diff: BSD base system versions\"\n  else\n    echo \" awk: $(awk -W version 2>&1 | head -n1)\"\n    echo \" sed: $(sed --version 2>&1 | head -n1)\"\n    echo \" mktemp: $(mktemp --version 2>&1 | head -n1)\"\n    echo \" grep: $(grep --version 2>&1 | head -n1)\"\n    echo \" diff: $(diff --version 2>&1 | head -n1)\"\n  fi\n  echo \" openssl: $(\"${OPENSSL}\" version 2>&1)\"\n\n  exit 0\n}\n\n# Usage: --display-terms\n# Description: Display current terms of service\ncommand_terms() {\n  init_system\n  echo \"The current terms of service: $CA_TERMS\"\n  echo \"+ Done!\"\n  exit 0\n}\n\n# Usage: --register\n# Description: Register account key\ncommand_register() {\n  init_system\n  echo \"+ Done!\"\n  exit 0\n}\n\n# Usage: --account\n# Description: Update account contact information\ncommand_account() {\n  init_system\n  FAILED=false\n\n  NEW_ACCOUNT_KEY_JSON=\"$(_mktemp)\"\n\n  # Check if we have the registration url\n  if [[ -z \"${ACCOUNT_URL}\" ]]; then\n    _exiterr \"Error retrieving registration url.\"\n  fi\n\n  echo \"+ Updating registration url: ${ACCOUNT_URL} contact information...\"\n  if [[ ${API} -eq 1 ]]; then\n    # If an email for the contact has been provided then adding it to the registered account\n    if [[ -n \"${CONTACT_EMAIL}\" ]]; then\n      (signed_request \"${ACCOUNT_URL}\" '{\"resource\": \"reg\", \"contact\":[\"mailto:'\"${CONTACT_EMAIL}\"'\"]}' > \"${NEW_ACCOUNT_KEY_JSON}\") || FAILED=true\n    else\n      (signed_request \"${ACCOUNT_URL}\" '{\"resource\": \"reg\", \"contact\":[]}' > \"${NEW_ACCOUNT_KEY_JSON}\") || FAILED=true\n    fi\n  else\n    # If an email for the contact has been provided then adding it to the registered account\n    if [[ -n \"${CONTACT_EMAIL}\" ]]; then\n      (signed_request \"${ACCOUNT_URL}\" '{\"contact\":[\"mailto:'\"${CONTACT_EMAIL}\"'\"]}' > \"${NEW_ACCOUNT_KEY_JSON}\") || FAILED=true\n    else\n      (signed_request \"${ACCOUNT_URL}\" '{\"contact\":[]}' > \"${NEW_ACCOUNT_KEY_JSON}\") || FAILED=true\n    fi\n  fi\n\n  if [[ \"${FAILED}\" = \"true\" ]]; then\n    rm \"${NEW_ACCOUNT_KEY_JSON}\"\n    _exiterr \"Error updating account information. See message above for more information.\"\n  fi\n  if diff -q \"${NEW_ACCOUNT_KEY_JSON}\" \"${ACCOUNT_KEY_JSON}\" > /dev/null; then\n    echo \"+ Account information was the same after the update\"\n    rm \"${NEW_ACCOUNT_KEY_JSON}\"\n  else\n    ACCOUNT_KEY_JSON_BACKUP=\"${ACCOUNT_KEY_JSON%.*}-$(date +%s).json\"\n    echo \"+ Backup ${ACCOUNT_KEY_JSON} as ${ACCOUNT_KEY_JSON_BACKUP}\"\n    cp -p \"${ACCOUNT_KEY_JSON}\" \"${ACCOUNT_KEY_JSON_BACKUP}\"\n    echo \"+ Populate ${ACCOUNT_KEY_JSON}\"\n    mv \"${NEW_ACCOUNT_KEY_JSON}\" \"${ACCOUNT_KEY_JSON}\"\n  fi\n  echo \"+ Done!\"\n  exit 0\n}\n\n# Parse contents of domains.txt and domains.txt.d\nparse_domains_txt() {\n  # Allow globbing temporarily\n  noglob_set\n  local inputs=(\"${DOMAINS_TXT}\" \"${DOMAINS_TXT}.d\"/*.txt)\n  noglob_clear\n\n  cat \"${inputs[@]}\" |\n    tr -d '\\r' |\n    awk '{print tolower($0)}' |\n    _sed -e 's/^[[:space:]]*//g' -e 's/[[:space:]]*$//g' -e 's/[[:space:]]+/ /g' -e 's/([^ ])>/\\1 >/g' -e 's/> />/g' |\n    (grep -vE '^(#|$)' || true)\n}\n\n# Usage: --cron (-c)\n# Description: Sign/renew non-existent/changed/expiring certificates.\ncommand_sign_domains() {\n  init_system\n  hookscript_bricker_hook\n\n  # Call startup hook\n  [[ -n \"${HOOK}\" ]] && (\"${HOOK}\" \"startup_hook\" || _exiterr 'startup_hook hook returned with non-zero exit code')\n\n  if [ ! -d \"${CHAINCACHE}\" ]; then\n    echo \" + Creating chain cache directory ${CHAINCACHE}\"\n    mkdir \"${CHAINCACHE}\"\n  fi\n\n  if [[ -n \"${PARAM_DOMAIN:-}\" ]]; then\n    DOMAINS_TXT=\"$(_mktemp)\"\n    if [[ -n \"${PARAM_ALIAS:-}\" ]]; then\n      printf \"%s > %s\" \"${PARAM_DOMAIN}\" \"${PARAM_ALIAS}\" > \"${DOMAINS_TXT}\"\n    else\n      printf \"%s\" \"${PARAM_DOMAIN}\" > \"${DOMAINS_TXT}\"\n    fi\n  elif [[ -e \"${DOMAINS_TXT}\" ]]; then\n    if [[ ! -r \"${DOMAINS_TXT}\" ]]; then\n      _exiterr \"domains.txt found but not readable\"\n    fi\n  else\n    _exiterr \"domains.txt not found and --domain not given\"\n  fi\n\n  # Generate certificates for all domains found in domains.txt. Check if existing certificate are about to expire\n  ORIGIFS=\"${IFS}\"\n  IFS=$'\\n'\n  for line in $(parse_domains_txt); do\n    reset_configvars\n    IFS=\"${ORIGIFS}\"\n    alias=\"$(grep -Eo '>[^ ]+' <<< \"${line}\" || true)\"\n    line=\"$(_sed -e 's/>[^ ]+[ ]*//g' <<< \"${line}\")\"\n    aliascount=\"$(grep -Eo '>' <<< \"${alias}\" | awk 'END {print NR}' || true )\"\n    [ \"${aliascount}\" -gt 1 ] && _exiterr \"Only one alias per line is allowed in domains.txt!\"\n\n    domain=\"$(printf '%s\\n' \"${line}\" | cut -d' ' -f1)\"\n    morenames=\"$(printf '%s\\n' \"${line}\" | cut -s -d' ' -f2-)\"\n    [ \"${aliascount}\" -lt 1 ] && alias=\"${domain}\" || alias=\"${alias#>}\"\n    export alias\n\n    if [[ -z \"${morenames}\" ]];then\n      echo \"Processing ${domain}\"\n    else\n      echo \"Processing ${domain} with alternative names: ${morenames}\"\n    fi\n\n    if [ \"${alias:0:2}\" = \"*.\" ]; then\n      _exiterr \"Please define a valid alias for your ${domain} wildcard-certificate. See domains.txt-documentation for more details.\"\n    fi\n\n    local certdir=\"${CERTDIR}/${alias}\"\n    cert=\"${certdir}/cert.pem\"\n    chain=\"${certdir}/chain.pem\"\n\n    force_renew=\"${PARAM_FORCE:-no}\"\n\n    timestamp=\"$(date +%s)\"\n\n    # If there is no existing certificate directory => make it\n    if [[ ! -e \"${certdir}\" ]]; then\n      echo \" + Creating new directory ${certdir} ...\"\n      mkdir -p \"${certdir}\" || _exiterr \"Unable to create directory ${certdir}\"\n    fi\n\n    # read cert config\n    # for now this loads the certificate specific config in a subshell and parses a diff of set variables.\n    # we could just source the config file but i decided to go this way to protect people from accidentally overriding\n    # variables used internally by this script itself.\n    if [[ -n \"${DOMAINS_D}\" ]]; then\n      certconfig=\"${DOMAINS_D}/${alias}\"\n    else\n      certconfig=\"${certdir}/config\"\n    fi\n\n    if [ -f \"${certconfig}\" ]; then\n      echo \" + Using certificate specific config file!\"\n      ORIGIFS=\"${IFS}\"\n      IFS=$'\\n'\n      for cfgline in $(\n        beforevars=\"$(_mktemp)\"\n        aftervars=\"$(_mktemp)\"\n        set > \"${beforevars}\"\n        # shellcheck disable=SC1090\n        . \"${certconfig}\"\n        set > \"${aftervars}\"\n        diff -u \"${beforevars}\" \"${aftervars}\" | grep -E '^\\+[^+]'\n        rm \"${beforevars}\"\n        rm \"${aftervars}\"\n      ); do\n        config_var=\"$(echo \"${cfgline:1}\" | cut -d'=' -f1)\"\n        config_value=\"$(echo \"${cfgline:1}\" | cut -d'=' -f2- | tr -d \"'\")\"\n\t# All settings that are allowed here should also be stored and\n\t# restored in store_configvars() and reset_configvars()\n        case \"${config_var}\" in\n          KEY_ALGO|OCSP_MUST_STAPLE|OCSP_FETCH|OCSP_DAYS|PRIVATE_KEY_RENEW|PRIVATE_KEY_ROLLOVER|KEYSIZE|CHALLENGETYPE|HOOK|PREFERRED_CHAIN|WELLKNOWN|HOOK_CHAIN|OPENSSL_CNF|RENEW_DAYS)\n            echo \"   + ${config_var} = ${config_value}\"\n            declare -- \"${config_var}=${config_value}\"\n            ;;\n          _) ;;\n          *) echo \"   ! Setting ${config_var} on a per-certificate base is not (yet) supported\" >&2\n        esac\n      done\n      IFS=\"${ORIGIFS}\"\n    fi\n    verify_config\n    hookscript_bricker_hook\n    export WELLKNOWN CHALLENGETYPE KEY_ALGO PRIVATE_KEY_ROLLOVER\n\n    skip=\"no\"\n\n    # Allow for external CSR generation\n    local csr=\"\"\n    if [[ -n \"${HOOK}\" ]]; then\n      csr=\"$(\"${HOOK}\" \"generate_csr\" \"${domain}\" \"${certdir}\" \"${domain} ${morenames}\")\" || _exiterr 'generate_csr hook returned with non-zero exit code'\n      if grep -qE \"\\-----BEGIN (NEW )?CERTIFICATE REQUEST-----\" <<< \"${csr}\"; then\n        altnames=\"$(extract_altnames \"${csr}\")\"\n        domain=\"$(cut -d' ' -f1 <<< \"${altnames}\")\"\n        morenames=\"$(cut -s -d' ' -f2- <<< \"${altnames}\")\"\n        echo \" + Using CSR from hook script (real names: ${altnames})\"\n      else\n        csr=\"\"\n      fi\n    fi\n\n    # Check domain names of existing certificate\n    if [[ -e \"${cert}\" && \"${force_renew}\" = \"no\" ]]; then\n      printf \" + Checking domain name(s) of existing cert...\"\n\n      certnames=\"$(\"${OPENSSL}\" x509 -in \"${cert}\" -text -noout | grep -E '(DNS|IP( Address*)):' | _sed 's/(DNS|IP( Address)*)://g' | tr -d ' ' | tr ',' '\\n' | sort -u | tr '\\n' ' ' | _sed 's/ $//')\"\n      givennames=\"$(echo \"${domain}\" \"${morenames}\"| tr ' ' '\\n' | sort -u | tr '\\n' ' ' | _sed 's/ip://g' | _sed 's/ $//' | _sed 's/^ //')\"\n \n      if [[ \"${certnames}\" = \"${givennames}\" ]]; then\n        echo \" unchanged.\"\n      else\n        echo \" changed!\"\n        echo \" + Domain name(s) are not matching!\"\n        echo \" + Names in old certificate: ${certnames}\"\n        echo \" + Configured names: ${givennames}\"\n        echo \" + Forcing renew.\"\n        force_renew=\"yes\"\n      fi\n    fi\n\n    # Check expire date of existing certificate\n    if [[ -e \"${cert}\" ]]; then\n      echo \" + Checking expire date of existing cert...\"\n      valid=\"$(\"${OPENSSL}\" x509 -enddate -noout -in \"${cert}\" | cut -d= -f2- )\"\n\n      printf \" + Valid till %s \" \"${valid}\"\n      if (\"${OPENSSL}\" x509 -checkend $((RENEW_DAYS * 86400)) -noout -in \"${cert}\" > /dev/null 2>&1); then\n        printf \"(Longer than %d days). \" \"${RENEW_DAYS}\"\n        if [[ \"${force_renew}\" = \"yes\" ]]; then\n          echo \"Ignoring because renew was forced!\"\n        else\n          # Certificate-Names unchanged and cert is still valid\n          echo \"Skipping renew!\"\n          [[ -n \"${HOOK}\" ]] && (\"${HOOK}\" \"unchanged_cert\" \"${domain}\" \"${certdir}/privkey.pem\" \"${certdir}/cert.pem\" \"${certdir}/fullchain.pem\" \"${certdir}/chain.pem\" || _exiterr 'unchanged_cert hook returned with non-zero exit code')\n          skip=\"yes\"\n        fi\n      else\n        echo \"(Less than ${RENEW_DAYS} days). Renewing!\"\n      fi\n    fi\n\n    local update_ocsp\n    update_ocsp=\"no\"\n\n    # Sign certificate for this domain\n    if [[ ! \"${skip}\" = \"yes\" ]]; then\n      update_ocsp=\"yes\"\n      [[ -z \"${csr}\" ]] || printf \"%s\" \"${csr}\" > \"${certdir}/cert-${timestamp}.csr\"\n      # shellcheck disable=SC2086\n      if [[ \"${PARAM_KEEP_GOING:-}\" = \"yes\" ]]; then\n        skip_exit_hook=yes\n        sign_domain \"${certdir}\" \"${timestamp}\" \"${domain}\" ${morenames} &\n        wait $! || exit_with_errorcode=1\n        skip_exit_hook=no\n      else\n        sign_domain \"${certdir}\" \"${timestamp}\" \"${domain}\" ${morenames}\n      fi\n    fi\n\n    if [[ \"${OCSP_FETCH}\" = \"yes\" ]]; then\n      local ocsp_url\n      ocsp_url=\"$(get_ocsp_url \"${cert}\")\"\n\n      if [[ ! -e \"${certdir}/ocsp.der\" ]]; then\n        update_ocsp=\"yes\"\n      elif ! (\"${OPENSSL}\" ocsp -no_nonce -issuer \"${chain}\" -verify_other \"${chain}\" -cert \"${cert}\" -respin \"${certdir}/ocsp.der\" -status_age $((OCSP_DAYS*24*3600)) 2>&1 | grep -q \"${cert}: good\"); then\n        update_ocsp=\"yes\"\n      fi\n\n      if [[ \"${update_ocsp}\" = \"yes\" ]]; then\n        echo \" + Updating OCSP stapling file\"\n        ocsp_timestamp=\"$(date +%s)\"\n        if grep -qE \"^(openssl (0|(1\\.0))\\.)|(libressl (1|2|3)\\.)\" <<< \"$(${OPENSSL} version | awk '{print tolower($0)}')\"; then\n          ocsp_log=\"$(\"${OPENSSL}\" ocsp -no_nonce -issuer \"${chain}\" -verify_other \"${chain}\" -cert \"${cert}\" -respout \"${certdir}/ocsp-${ocsp_timestamp}.der\" -url \"${ocsp_url}\" -header \"HOST\" \"$(echo \"${ocsp_url}\" | _sed -e 's/^http(s?):\\/\\///' -e 's/\\/.*$//g')\" 2>&1)\" || _exiterr \"Error while fetching OCSP information: ${ocsp_log}\"\n        else\n          ocsp_log=\"$(\"${OPENSSL}\" ocsp -no_nonce -issuer \"${chain}\" -verify_other \"${chain}\" -cert \"${cert}\" -respout \"${certdir}/ocsp-${ocsp_timestamp}.der\" -url \"${ocsp_url}\" 2>&1)\" || _exiterr \"Error while fetching OCSP information: ${ocsp_log}\"\n        fi\n        ln -sf \"ocsp-${ocsp_timestamp}.der\" \"${certdir}/ocsp.der\"\n        [[ -n \"${HOOK}\" ]] && (altnames=\"${domain} ${morenames}\" \"${HOOK}\" \"deploy_ocsp\" \"${domain}\" \"${certdir}/ocsp.der\" \"${ocsp_timestamp}\" || _exiterr 'deploy_ocsp hook returned with non-zero exit code')\n      else\n        echo \" + OCSP stapling file is still valid (skipping update)\"\n      fi\n    fi\n  done\n  reset_configvars\n\n  # remove temporary domains.txt file if used\n  [[ -n \"${PARAM_DOMAIN:-}\" ]] && rm -f \"${DOMAINS_TXT}\"\n\n  [[ -n \"${HOOK}\" ]] && (\"${HOOK}\" \"exit_hook\" || echo 'exit_hook returned with non-zero exit code!' >&2)\n  if [[ \"${AUTO_CLEANUP}\" == \"yes\" ]]; then\n    echo \"+ Running automatic cleanup\"\n    command_cleanup noinit\n  fi\n\n  exit \"${exit_with_errorcode}\"\n}\n\n# Usage: --signcsr (-s) path/to/csr.pem\n# Description: Sign a given CSR, output CRT on stdout (advanced usage)\ncommand_sign_csr() {\n  init_system\n\n  # redirect stdout to stderr\n  # leave stdout over at fd 3 to output the cert\n  exec 3>&1 1>&2\n\n  # load csr\n  csrfile=\"${1}\"\n  if [ ! -r \"${csrfile}\" ]; then\n    _exiterr \"Could not read certificate signing request ${csrfile}\"\n  fi\n  csr=\"$(cat \"${csrfile}\")\"\n\n  # extract names\n  altnames=\"$(extract_altnames \"${csr}\")\"\n\n  # gen cert\n  certfile=\"$(_mktemp)\"\n  # shellcheck disable=SC2086\n  sign_csr \"${csr}\" ${altnames} 3> \"${certfile}\"\n\n  # print cert\n  echo \"# CERT #\" >&3\n  cat \"${certfile}\" >&3\n  echo >&3\n\n  # print chain\n  if [ -n \"${PARAM_FULL_CHAIN:-}\" ]; then\n    # get and convert ca cert\n    chainfile=\"$(_mktemp)\"\n    tmpchain=\"$(_mktemp)\"\n    http_request get \"$(\"${OPENSSL}\" x509 -in \"${certfile}\" -noout -text | grep 'CA Issuers - URI:' | cut -d':' -f2-)\" > \"${tmpchain}\"\n    if grep -q \"BEGIN CERTIFICATE\" \"${tmpchain}\"; then\n      mv \"${tmpchain}\" \"${chainfile}\"\n    else\n      \"${OPENSSL}\" x509 -in \"${tmpchain}\" -inform DER -out \"${chainfile}\" -outform PEM\n      rm \"${tmpchain}\"\n    fi\n\n    echo \"# CHAIN #\" >&3\n    cat \"${chainfile}\" >&3\n\n    rm \"${chainfile}\"\n  fi\n\n  # cleanup\n  rm \"${certfile}\"\n\n  exit 0\n}\n\n# Usage: --revoke (-r) path/to/cert.pem\n# Description: Revoke specified certificate\ncommand_revoke() {\n  init_system\n\n  [[ -n \"${CA_REVOKE_CERT}\" ]] || _exiterr \"Certificate authority doesn't allow certificate revocation.\"\n\n  cert=\"${1}\"\n  if [[ -L \"${cert}\" ]]; then\n    # follow symlink and use real certificate name (so we move the real file and not the symlink at the end)\n    local link_target\n    link_target=\"$(readlink -n \"${cert}\")\"\n    if [[ \"${link_target}\" =~ ^/ ]]; then\n      cert=\"${link_target}\"\n    else\n      cert=\"$(dirname \"${cert}\")/${link_target}\"\n    fi\n  fi\n  [[ -f \"${cert}\" ]] || _exiterr \"Could not find certificate ${cert}\"\n\n  echo \"Revoking ${cert}\"\n\n  cert64=\"$(\"${OPENSSL}\" x509 -in \"${cert}\" -inform PEM -outform DER | urlbase64)\"\n  if [[ ${API} -eq 1 ]]; then\n    response=\"$(signed_request \"${CA_REVOKE_CERT}\" '{\"resource\": \"revoke-cert\", \"certificate\": \"'\"${cert64}\"'\"}' | clean_json)\"\n  else\n    response=\"$(signed_request \"${CA_REVOKE_CERT}\" '{\"certificate\": \"'\"${cert64}\"'\"}' | clean_json)\"\n  fi\n  # if there is a problem with our revoke request _request (via signed_request) will report this and \"exit 1\" out\n  # so if we are here, it is safe to assume the request was successful\n  echo \" + Done.\"\n  echo \" + Renaming certificate to ${cert}-revoked\"\n  mv -f \"${cert}\" \"${cert}-revoked\"\n}\n\n# Usage: --deactivate\n# Description: Deactivate account\ncommand_deactivate() {\n  init_system\n\n  echo \"Deactivating account ${ACCOUNT_URL}\"\n\n  if [[ ${API} -eq 1 ]]; then\n    echo \"Deactivation for ACMEv1 is not implemented\"\n  else\n    response=\"$(signed_request \"${ACCOUNT_URL}\" '{\"status\": \"deactivated\"}' | clean_json)\"\n    deactstatus=$(echo \"$response\" | jsonsh | get_json_string_value \"status\")\n    if [[ \"${deactstatus}\" = \"deactivated\" ]]; then\n      touch \"${ACCOUNT_DEACTIVATED}\"\n    else\n      _exiterr \"Account deactivation failed!\"\n    fi\n  fi\n\n  echo \" + Done.\"\n}\n\n# Usage: --cleanup (-gc)\n# Description: Move unused certificate files to archive directory\ncommand_cleanup() {\n  if [ ! \"${1:-}\" = \"noinit\" ]; then\n    load_config\n  fi\n\n  if [[ ! \"${PARAM_CLEANUPDELETE:-}\" = \"yes\" ]]; then\n    # Create global archive directory if not existent\n    if [[ ! -e \"${BASEDIR}/archive\" ]]; then\n      mkdir \"${BASEDIR}/archive\"\n    fi\n  fi\n\n  # Allow globbing\n  noglob_set\n\n  # Loop over all certificate directories\n  for certdir in \"${CERTDIR}/\"*; do\n    # Skip if entry is not a folder\n    [[ -d \"${certdir}\" ]] || continue\n\n    # Get certificate name\n    certname=\"$(basename \"${certdir}\")\"\n\n    # Create certificates archive directory if not existent\n    if [[ ! \"${PARAM_CLEANUPDELETE:-}\" = \"yes\" ]]; then\n      archivedir=\"${BASEDIR}/archive/${certname}\"\n      if [[ ! -e \"${archivedir}\" ]]; then\n        mkdir \"${archivedir}\"\n      fi\n    fi\n\n    # Loop over file-types (certificates, keys, signing-requests, ...)\n    for filetype in cert.csr cert.pem chain.pem fullchain.pem privkey.pem ocsp.der; do\n      # Delete all if symlink is broken\n      if [[ -r \"${certdir}/${filetype}\" ]]; then\n        # Look up current file in use\n        current=\"$(basename \"$(readlink \"${certdir}/${filetype}\")\")\"\n      else\n        if [[ -h \"${certdir}/${filetype}\" ]]; then\n          echo \"Removing broken symlink: ${certdir}/${filetype}\"\n          rm -f \"${certdir}/${filetype}\"\n        fi\n        current=\"\"\n      fi\n\n      # Split filetype into name and extension\n      filebase=\"$(echo \"${filetype}\" | cut -d. -f1)\"\n      fileext=\"$(echo \"${filetype}\" | cut -d. -f2)\"\n\n      # Loop over all files of this type\n      for file in \"${certdir}/${filebase}-\"*\".${fileext}\" \"${certdir}/${filebase}-\"*\".${fileext}-revoked\"; do\n        # Check if current file is in use, if unused move to archive directory\n        filename=\"$(basename \"${file}\")\"\n        if [[ ! \"${filename}\" = \"${current}\" ]] && [[ -f \"${certdir}/${filename}\" ]]; then\n          if [[ \"${PARAM_CLEANUPDELETE:-}\" = \"yes\" ]]; then\n            echo \"Deleting unused file: ${certname}/${filename}\"\n            rm \"${certdir}/${filename}\"\n          else\n            echo \"Moving unused file to archive directory: ${certname}/${filename}\"\n            mv \"${certdir}/${filename}\" \"${archivedir}/${filename}\"\n          fi\n        fi\n      done\n    done\n  done\n\n  exit \"${exit_with_errorcode}\"\n}\n\n# Usage: --cleanup-delete (-gcd)\n# Description: Deletes (!) unused certificate files\ncommand_cleanupdelete() {\n  command_cleanup\n}\n\n\n# Usage: --help (-h)\n# Description: Show help text\ncommand_help() {\n  printf \"Usage: %s [-h] [command [argument]] [parameter [argument]] [parameter [argument]] ...\\n\\n\" \"${0}\"\n  printf \"Default command: help\\n\\n\"\n  echo \"Commands:\"\n  grep -e '^[[:space:]]*# Usage:' -e '^[[:space:]]*# Description:' -e '^command_.*()[[:space:]]*{' \"${0}\" | while read -r usage; read -r description; read -r command; do\n    if [[ ! \"${usage}\" =~ Usage ]] || [[ ! \"${description}\" =~ Description ]] || [[ ! \"${command}\" =~ ^command_ ]]; then\n      _exiterr \"Error generating help text.\"\n    fi\n    printf \" %-32s %s\\n\" \"${usage##\"# Usage: \"}\" \"${description##\"# Description: \"}\"\n  done\n  printf -- \"\\nParameters:\\n\"\n  grep -E -e '^[[:space:]]*# PARAM_Usage:' -e '^[[:space:]]*# PARAM_Description:' \"${0}\" | while read -r usage; read -r description; do\n    if [[ ! \"${usage}\" =~ Usage ]] || [[ ! \"${description}\" =~ Description ]]; then\n      _exiterr \"Error generating help text.\"\n    fi\n    printf \" %-32s %s\\n\" \"${usage##\"# PARAM_Usage: \"}\" \"${description##\"# PARAM_Description: \"}\"\n  done\n}\n\n# Usage: --env (-e)\n# Description: Output configuration variables for use in other scripts\ncommand_env() {\n  echo \"# dehydrated configuration\"\n  load_config\n  typeset -p CA CERTDIR ALPNCERTDIR CHALLENGETYPE DOMAINS_D DOMAINS_TXT HOOK HOOK_CHAIN RENEW_DAYS ACCOUNT_KEY ACCOUNT_KEY_JSON ACCOUNT_ID_JSON KEYSIZE WELLKNOWN PRIVATE_KEY_RENEW OPENSSL_CNF CONTACT_EMAIL LOCKFILE\n}\n\n# Main method (parses script arguments and calls command_* methods)\nmain() {\n  exit_with_errorcode=0\n  skip_exit_hook=no\n  COMMAND=\"\"\n  set_command() {\n    [[ -z \"${COMMAND}\" ]] || _exiterr \"Only one command can be executed at a time. See help (-h) for more information.\"\n    COMMAND=\"${1}\"\n  }\n\n  check_parameters() {\n    if [[ -z \"${1:-}\" ]]; then\n      echo \"The specified command requires additional parameters. See help:\" >&2\n      echo >&2\n      command_help >&2\n      exit 1\n    elif [[ \"${1:0:1}\" = \"-\" ]]; then\n      _exiterr \"Invalid argument: ${1}\"\n    fi\n  }\n\n  [[ -z \"${*}\" ]] && eval set -- \"--help\"\n\n  while (( ${#} )); do\n    case \"${1}\" in\n      --help|-h)\n        command_help\n        exit 0\n        ;;\n\n      --env|-e)\n        set_command env\n        ;;\n\n      --cron|-c)\n        set_command sign_domains\n        ;;\n\n      --register)\n        set_command register\n        ;;\n\n      --account)\n        set_command account\n        ;;\n\n      # PARAM_Usage: --accept-terms\n      # PARAM_Description: Accept CAs terms of service\n      --accept-terms)\n        PARAM_ACCEPT_TERMS=\"yes\"\n        ;;\n\n      --display-terms)\n        set_command terms\n        ;;\n\n      --signcsr|-s)\n        shift 1\n        set_command sign_csr\n        check_parameters \"${1:-}\"\n        PARAM_CSR=\"${1}\"\n        ;;\n\n      --revoke|-r)\n        shift 1\n        set_command revoke\n        check_parameters \"${1:-}\"\n        PARAM_REVOKECERT=\"${1}\"\n        ;;\n\n      --deactivate)\n        set_command deactivate\n        ;;\n\n      --version|-v)\n        set_command version\n        ;;\n\n      --cleanup|-gc)\n        set_command cleanup\n        ;;\n\n      --cleanup-delete|-gcd)\n        set_command cleanupdelete\n        PARAM_CLEANUPDELETE=\"yes\"\n        ;;\n\n      # PARAM_Usage: --full-chain (-fc)\n      # PARAM_Description: Print full chain when using --signcsr\n      --full-chain|-fc)\n        PARAM_FULL_CHAIN=\"1\"\n        ;;\n\n      # PARAM_Usage: --ipv4 (-4)\n      # PARAM_Description: Resolve names to IPv4 addresses only\n      --ipv4|-4)\n        PARAM_IP_VERSION=\"4\"\n        ;;\n\n      # PARAM_Usage: --ipv6 (-6)\n      # PARAM_Description: Resolve names to IPv6 addresses only\n      --ipv6|-6)\n        PARAM_IP_VERSION=\"6\"\n        ;;\n\n      # PARAM_Usage: --domain (-d) domain.tld\n      # PARAM_Description: Use specified domain name(s) instead of domains.txt entry (one certificate!)\n      --domain|-d)\n        shift 1\n        check_parameters \"${1:-}\"\n        if [[ -z \"${PARAM_DOMAIN:-}\" ]]; then\n          PARAM_DOMAIN=\"${1}\"\n        else\n          PARAM_DOMAIN=\"${PARAM_DOMAIN} ${1}\"\n         fi\n        ;;\n\n      # PARAM_Usage: --ca url/preset\n      # PARAM_Description: Use specified CA URL or preset\n      --ca)\n        shift 1\n        check_parameters \"${1:-}\"\n        [[ -n \"${PARAM_CA:-}\" ]] && _exiterr \"CA can only be specified once!\"\n        PARAM_CA=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --alias certalias\n      # PARAM_Description: Use specified name for certificate directory (and per-certificate config) instead of the primary domain (only used if --domain is specified)\n      --alias)\n        shift 1\n        check_parameters \"${1:-}\"\n        [[ -n \"${PARAM_ALIAS:-}\" ]] && _exiterr \"Alias can only be specified once!\"\n        PARAM_ALIAS=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --keep-going (-g)\n      # PARAM_Description: Keep going after encountering an error while creating/renewing multiple certificates in cron mode\n      --keep-going|-g)\n        PARAM_KEEP_GOING=\"yes\"\n        ;;\n\n      # PARAM_Usage: --force (-x)\n      # PARAM_Description: Force certificate renewal even if it is not due to expire within RENEW_DAYS\n      --force|-x)\n        PARAM_FORCE=\"yes\"\n        ;;\n\n      # PARAM_Usage: --force-validation\n      # PARAM_Description: Force revalidation of domain names (used in combination with --force)\n      --force-validation)\n        PARAM_FORCE_VALIDATION=\"yes\"\n        ;;\n\n      # PARAM_Usage: --no-lock (-n)\n      # PARAM_Description: Don't use lockfile (potentially dangerous!)\n      --no-lock|-n)\n        PARAM_NO_LOCK=\"yes\"\n        ;;\n\n      # PARAM_Usage: --lock-suffix example.com\n      # PARAM_Description: Suffix lockfile name with a string (useful for with -d)\n      --lock-suffix)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_LOCKFILE_SUFFIX=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --ocsp\n      # PARAM_Description: Sets option in CSR indicating OCSP stapling to be mandatory\n      --ocsp)\n        PARAM_OCSP_MUST_STAPLE=\"yes\"\n        ;;\n\n      # PARAM_Usage: --privkey (-p) path/to/key.pem\n      # PARAM_Description: Use specified private key instead of account key (useful for revocation)\n      --privkey|-p)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_ACCOUNT_KEY=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --domains-txt path/to/domains.txt\n      # PARAM_Description: Use specified domains.txt instead of default/configured one\n      --domains-txt)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_DOMAINS_TXT=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --config (-f) path/to/config\n      # PARAM_Description: Use specified config file\n      --config|-f)\n        shift 1\n        check_parameters \"${1:-}\"\n        CONFIG=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --hook (-k) path/to/hook.sh\n      # PARAM_Description: Use specified script for hooks\n      --hook|-k)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_HOOK=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --preferred-chain issuer-cn\n      # PARAM_Description: Use alternative certificate chain identified by issuer CN\n      --preferred-chain)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_PREFERRED_CHAIN=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --out (-o) certs/directory\n      # PARAM_Description: Output certificates into the specified directory\n      --out|-o)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_CERTDIR=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --alpn alpn-certs/directory\n      # PARAM_Description: Output alpn verification certificates into the specified directory\n      --alpn)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_ALPNCERTDIR=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --challenge (-t) http-01|dns-01|tls-alpn-01\n      # PARAM_Description: Which challenge should be used? Currently http-01, dns-01, and tls-alpn-01 are supported\n      --challenge|-t)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_CHALLENGETYPE=\"${1}\"\n        ;;\n\n      # PARAM_Usage: --algo (-a) rsa|prime256v1|secp384r1\n      # PARAM_Description: Which public key algorithm should be used? Supported: rsa, prime256v1 and secp384r1\n      --algo|-a)\n        shift 1\n        check_parameters \"${1:-}\"\n        PARAM_KEY_ALGO=\"${1}\"\n        ;;\n      *)\n        echo \"Unknown parameter detected: ${1}\" >&2\n        echo >&2\n        command_help >&2\n        exit 1\n        ;;\n    esac\n\n    shift 1\n  done\n\n  case \"${COMMAND}\" in\n    env) command_env;;\n    sign_domains) command_sign_domains;;\n    register) command_register;;\n    account) command_account;;\n    sign_csr) command_sign_csr \"${PARAM_CSR}\";;\n    revoke) command_revoke \"${PARAM_REVOKECERT}\";;\n    deactivate) command_deactivate;;\n    cleanup) command_cleanup;;\n    terms) command_terms;;\n    cleanupdelete) command_cleanupdelete;;\n    version) command_version;;\n    *) command_help; exit 1;;\n  esac\n\n  exit \"${exit_with_errorcode}\"\n}\n\n# Determine OS type\nOSTYPE=\"$(uname)\"\n\nif [[ ! \"${DEHYDRATED_NOOP:-}\" = \"NOOP\" ]]; then\n  # Run script\n  main \"${@:-}\"\nfi\n\n# vi: expandtab sw=2 ts=2\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}