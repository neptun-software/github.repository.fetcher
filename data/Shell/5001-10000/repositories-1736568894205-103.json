{
  "metadata": {
    "timestamp": 1736568894205,
    "page": 103,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "clvv/fasd",
      "stars": 5903,
      "defaultBranch": "master",
      "files": [
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 2.591796875,
          "content": "Fasd is a self-contained posix shell script that can be either sourced or\nexecuted. A Makefile is provided to install `fasd` and `fasd.1` to desired\nplaces.\n\n\nSystem-wide install:\n\n    make install\n\nInstall to $HOME:\n\n    PREFIX=$HOME make install\n\nOr alternatively you can just copy `fasd` to anywhere you like.\n\nTo get fasd working in a shell, some initialization code must be run. Put the\nline below in your shell rc.\n\n    eval \"$(fasd --init auto)\"\n\nThis will setup a command hook that executes on every command and advanced tab\ncompletion for zsh and bash.\n\nIf you want more control over what gets into your shell environment, you can\npass customized set of arguments to `fasd --init`.\n\n    zsh-hook             # define _fasd_preexec and add it to zsh preexec array\n    zsh-ccomp            # zsh command mode completion definitions\n    zsh-ccomp-install    # setup command mode completion for zsh\n    zsh-wcomp            # zsh word mode completion definitions\n    zsh-wcomp-install    # setup word mode completion for zsh\n    bash-hook            # add hook code to bash $PROMPT_COMMAND\n    bash-ccomp           # bash command mode completion definitions\n    bash-ccomp-install   # setup command mode completion for bash\n    posix-alias          # define alias that applies to all posix shells\n    posix-hook           # setup $PS1 hook for shells that's posix compatible\n    tcsh-alias           # define aliases for tcsh\n    tcsh-hook            # setup tcsh precmd alias\n\nExample for a minimal zsh setup (no tab completion):\n\n    eval \"$(fasd --init posix-alias zsh-hook)\"\n\nNote that this method will slightly increase your shell start-up time, since\ncalling binaries has overhead. You can cache fasd init code if you want minimal\noverhead. Example code for bash (to be put into .bashrc):\n\n    fasd_cache=\"$HOME/.fasd-init-bash\"\n    if [ \"$(command -v fasd)\" -nt \"$fasd_cache\" -o ! -s \"$fasd_cache\" ]; then\n      fasd --init posix-alias bash-hook bash-ccomp bash-ccomp-install >| \"$fasd_cache\"\n    fi\n    source \"$fasd_cache\"\n    unset fasd_cache\n\nOptionally, if you can also source `fasd` if you want `fasd` to be a shell\nfunction instead of an executable.\n\nYou can tweak initialization code. For instance, if you want to use \"c\"\ninstead of \"z\" to do directory jumping. You run the code below:\n\n    # function to execute built-in cd\n    fasd_cd() {\n      if [ $# -le 1 ]; then\n        fasd \"$@\"\n      else\n        local _fasd_ret=\"$(fasd -e echo \"$@\")\"\n        [ -z \"$_fasd_ret\" ] && return\n        [ -d \"$_fasd_ret\" ] && cd \"$_fasd_ret\" || echo \"$_fasd_ret\"\n      fi\n    }\n    alias c='fasd_cd -d' # `-d' option present for bash completion\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "Copyright (C) 2011, 2012 by Wei Dai. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.537109375,
          "content": "PREFIX?= /usr/local\nBINDIR?= ${PREFIX}/bin\nMANDIR?= ${PREFIX}/share/man\nINSTALL?= install\nINSTALLDIR= ${INSTALL} -d\nINSTALLBIN= ${INSTALL} -m 755\nINSTALLMAN= ${INSTALL} -m 644\n\nall: fasd.1\n\nuninstall:\n\trm -f ${DESTDIR}${BINDIR}/fasd\n\trm -f ${DESTDIR}${MANDIR}/man1/fasd.1\n\ninstall:\n\t${INSTALLDIR} ${DESTDIR}${BINDIR}\n\t${INSTALLBIN} fasd ${DESTDIR}${BINDIR}\n\t${INSTALLDIR} ${DESTDIR}${MANDIR}/man1\n\t${INSTALLMAN} fasd.1 ${DESTDIR}${MANDIR}/man1\n\nman: fasd.1\n\nfasd.1: fasd.1.md\n\tpandoc -s -w man fasd.1.md -o fasd.1\n\n.PHONY: all install uninstall man\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.720703125,
          "content": "# Fasd\n\nFasd (pronounced similar to \"fast\") is a command-line productivity booster.\nFasd offers quick access to files and directories for POSIX shells. It is\ninspired by tools like [autojump](https://github.com/joelthelion/autojump),\n[z](http://github.com/rupa/z) and [v](https://github.com/rupa/v). Fasd keeps\ntrack of files and directories you have accessed, so that you can quickly\nreference them in the command line.\n\nThe name fasd comes from the default suggested aliases `f`(files),\n`a`(files/directories), `s`(show/search/select), `d`(directories).\n\nFasd ranks files and directories by \"frecency,\" that is, by both \"frequency\" and\n\"recency.\" The term \"frecency\" was first coined by Mozilla and used in Firefox\n([link](https://developer.mozilla.org/en/The_Places_frecency_algorithm)).\n\n# Introduction\n\nIf you use your shell to navigate and launch applications, fasd can help you do\nit more efficiently. With fasd, you can open files regardless of which\ndirectory you are in. Just with a few key strings, fasd can find a \"frecent\"\nfile or directory and open it with command you specify. Below are some\nhypothetical situations, where you can type in the command on the left and fasd\nwill \"expand\" your command into the right side. Pretty magic, huh?\n\n```\n  v def conf       =>     vim /some/awkward/path/to/type/default.conf\n  j abc            =>     cd /hell/of/a/awkward/path/to/get/to/abcdef\n  m movie          =>     mplayer /whatever/whatever/whatever/awesome_movie.mp4\n  o eng paper      =>     xdg-open /you/dont/remember/where/english_paper.pdf\n  vim `f rc lo`    =>     vim /etc/rc.local\n  vim `f rc conf`  =>     vim /etc/rc.conf\n```\n\nFasd comes with some useful aliases by default:\n\n```sh\nalias a='fasd -a'        # any\nalias s='fasd -si'       # show / search / select\nalias d='fasd -d'        # directory\nalias f='fasd -f'        # file\nalias sd='fasd -sid'     # interactive directory selection\nalias sf='fasd -sif'     # interactive file selection\nalias z='fasd_cd -d'     # cd, same functionality as j in autojump\nalias zz='fasd_cd -d -i' # cd with interactive selection\n```\n\nFasd will smartly detect when to display a list of files or just the best\nmatch. For instance, when you call fasd in a subshell with some search\nparameters, fasd will only return the best match. This enables you to do:\n\n```sh\nmv update.html `d www`\ncp `f mov` .\n```\n\n# Install\n\nFasd is available in various package managers. Please check\n[the wiki page](https://github.com/clvv/fasd/wiki/Installing-via-Package-Managers)\nfor an up-to-date list.\n\nYou can also manually obtain a copy of fasd.\n\nDownload fasd 1.0.1 from GitHub:\n[zip](https://github.com/clvv/fasd/zipball/1.0.1),\n[tar.gz](https://github.com/clvv/fasd/tarball/1.0.1).\n\nFasd is a self-contained POSIX shell script that can be either sourced or\nexecuted. A Makefile is provided to install `fasd` and `fasd.1` to desired\nplaces.\n\nSystem-wide install:\n\n    make install\n\nInstall to $HOME:\n\n    PREFIX=$HOME make install\n\nOr alternatively you can just copy `fasd` to anywhere you like (preferably\nunder some directory in `$PATH`).\n\nTo get fasd working in a shell, some initialization code must be run. Put the\nline below in your shell rc.\n\n```sh\neval \"$(fasd --init auto)\"\n```\n\nThis will setup a command hook that executes on every command and advanced tab\ncompletion for zsh and bash.\n\nIf you want more control over what gets into your shell environment, you can\npass customized set of arguments to `fasd --init`.\n\n```\nzsh-hook             # define _fasd_preexec and add it to zsh preexec array\nzsh-ccomp            # zsh command mode completion definitions\nzsh-ccomp-install    # setup command mode completion for zsh\nzsh-wcomp            # zsh word mode completion definitions\nzsh-wcomp-install    # setup word mode completion for zsh\nbash-hook            # add hook code to bash $PROMPT_COMMAND\nbash-ccomp           # bash command mode completion definitions\nbash-ccomp-install   # setup command mode completion for bash\nposix-alias          # define aliases that applies to all posix shells\nposix-hook           # setup $PS1 hook for shells that's posix compatible\ntcsh-alias           # define aliases for tcsh\ntcsh-hook            # setup tcsh precmd alias\n```\n\nExample for a minimal zsh setup (no tab completion):\n\n```sh\neval \"$(fasd --init posix-alias zsh-hook)\"\n```\n\nNote that this method will slightly increase your shell start-up time, since\ncalling binaries has overhead. You can cache fasd init code if you want minimal\noverhead. Example code for bash (to be put into .bashrc):\n\n```sh\nfasd_cache=\"$HOME/.fasd-init-bash\"\nif [ \"$(command -v fasd)\" -nt \"$fasd_cache\" -o ! -s \"$fasd_cache\" ]; then\n  fasd --init posix-alias bash-hook bash-ccomp bash-ccomp-install >| \"$fasd_cache\"\nfi\nsource \"$fasd_cache\"\nunset fasd_cache\n```\n\nOptionally, if you can also source `fasd` if you want `fasd` to be a shell\nfunction instead of an executable.\n\nYou can tweak initialization code. For instance, if you want to use \"c\"\ninstead of \"z\" to do directory jumping, you can use the alias below:\n\n```sh\nalias c='fasd_cd -d'\n# `-d` option present for bash completion\n# function fasd_cd is defined in posix-alias\n```\n\nAfter you first installed fasd, open some files (with any program) or `cd`\naround in your shell. Then try some examples below.\n\n# Examples\n\n```sh\nf foo           # list frecent files matching foo\na foo bar       # list frecent files and directories matching foo and bar\nf js$           # list frecent files that ends in js\nf -e vim foo    # run vim on the most frecent file matching foo\nmplayer `f bar` # run mplayer on the most frecent file matching bar\nz foo           # cd into the most frecent directory matching foo\nopen `sf pdf`   # interactively select a file matching pdf and launch `open`\n```\n\nYou should add your own aliases to fully utilize the power of fasd. Here are\nsome examples to get you started:\n\n```sh\nalias v='f -e vim' # quick opening files with vim\nalias m='f -e mplayer' # quick opening files with mplayer\nalias o='a -e xdg-open' # quick opening files with xdg-open\n```\n\nIf you're using bash, you have to call `_fasd_bash_hook_cmd_complete` to make\ncompletion work. For instance:\n\n    _fasd_bash_hook_cmd_complete v m j o\n\nYou could select an entry in the list of matching files.\n\n# Matching\n\nFasd has three matching modes: default, case-insensitive, and fuzzy.\n\nFor a given set of queries (the set of command-line arguments passed to fasd),\na path is a match if and only if:\n\n1. Queries match the path *in order*.\n2. The last query matches the *last segment* of the path.\n\nIf no match is found, fasd will try the same process ignoring case. If still no\nmatch is found, fasd will allow extra characters to be placed between query\ncharacters for fuzzy matching.\n\nTips:\n\n* If you want your last query not to match the last segment of the path, append\n  `/` as the last query.\n* If you want your last query to match the end of the filename, append `$` to\n  the last query.\n\n# How It Works\n\nWhen you run fasd init code or source `fasd`, fasd adds a hook which will be\nexecuted whenever you execute a command. The hook will scan your commands'\narguments and determine if any of them refer to existing files or directories.\nIf yes, fasd will add them to the database.\n\n# Compatibility\n\nFasd's basic functionalities are POSIX compliant, meaning that you should be\nable to use fasd in all POSIX compliant shells. Your shell need to support\ncommand substitution in `$PS1` in order for fasd to automatically track your\ncommands and files. This feature is not specified by the POSIX standard, but\nit's nonetheless present in many POSIX compliant shells. In shells without\nprompt command or prompt command substitution (csh for instance), you can add\nentries manually with `fasd -A`. You are very welcomed to contribute shell\ninitialization code for not yet supported shells.\n\nFasd has been tested on the following shells: bash, zsh, mksh, pdksh, dash,\nbusybox ash, FreeBSD 9 /bin/sh and OpenBSD /bin/sh.\n\n# Synopsis\n\n    fasd [options] [query ...]\n    [f|a|s|d|z] [options] [query ...]\n      options:\n        -s         list paths with scores\n        -l         list paths without scores\n        -i         interactive mode\n        -e <cmd>   set command to execute on the result file\n        -b <name>  only use <name> backend\n        -B <name>  add additional backend <name>\n        -a         match files and directories\n        -d         match directories only\n        -f         match files only\n        -r         match by rank only\n        -t         match by recent access only\n        -R         reverse listing order\n        -h         show a brief help message\n        -[0-9]     select the nth entry\n\n    fasd [-A|-D] [paths ...]\n        -A    add paths\n        -D    delete paths\n\n# Tab Completion\n\nFasd offers two completion modes, command mode completion and word mode\ncompletion. Command mode completion works in bash and zsh. Word mode\ncompletion only works in zsh.\n\nCommand mode completion is just like completion for any other commands. It is\ntriggered when you hit tab on a `fasd` command or its aliases. Under this mode\nyour queries can be separated by a space. Tip: if you find that the completion\nresult overwrites your queries, type an extra space before you hit tab.\n\nWord mode completion can be triggered on *any* command. Word completion is\ntriggered by any command line argument that starts with `,` (all), `f,`\n(files), or `d,` (directories), or that ends with `,,` (all), `,,f` (files), or\n`,,d` (directories). Examples:\n\n    $ vim ,rc,lo<Tab>\n    $ vim /etc/rc.local\n\n    $ mv index.html d,www<Tab>\n    $ mv index.html /var/www/\n\nThere are also three zle widgets: `fasd-complete`, `fasd-complete-f`,\n`fasd-complete-d`. You can bind them to keybindings you like:\n\n```sh\nbindkey '^X^A' fasd-complete    # C-x C-a to do fasd-complete (files and directories)\nbindkey '^X^F' fasd-complete-f  # C-x C-f to do fasd-complete-f (only files)\nbindkey '^X^D' fasd-complete-d  # C-x C-d to do fasd-complete-d (only directories)\n```\n\n# Backends\n\nFasd can take advantage of different sources of recent / frequent files. Most\ndesktop environments (such as OS X and Gtk) and some editors (such as Vim) keep\na list of accessed files. Fasd can use them as additional backends if the data\ncan be converted into fasd's native format. Below is a list of available\nbackends.\n\n```\n`spotlight`\nOSX spotlight, provides entries that are changed today or opened within the\npast month\n\n`recently-used`\nGTK's recently-used file (Usually available on Linux)\n\n`current`\nProvides everything in $PWD (whereever you are executing `fasd`)\n\n`viminfo`\nVim's editing history, useful if you want to define an alias just for editing\nthings in vim\n```\n\nYou can define your own backend by declaring a function by that name in your\n`.fasdrc`. You can set default backend with `_FASD_BACKENDS` variable in our\n`.fasdrc`.\n\nFasd can mimic [v](http://github.com/rupa/v)'s behavior by this alias:\n\n```sh\nalias v='f -t -e vim -b viminfo'\n```\n\n# Tweaks\n\nSome shell variables that you can set before sourcing `fasd`. You can set them\nin `$HOME/.fasdrc`\n\n```\n$_FASD_DATA\nPath to the fasd data file, default \"$HOME/.fasd\".\n\n$_FASD_BLACKLIST\nList of blacklisted strings. Commands matching them will not be processed.\nDefault is \"--help\".\n\n$_FASD_SHIFT\nList of all commands that needs to be shifted, defaults to \"sudo busybox\".\n\n$_FASD_IGNORE\nList of all commands that will be ignored, defaults to \"fasd ls echo\".\n\n$_FASD_TRACK_PWD\nFasd defaults to track your \"$PWD\". Set this to 0 to disable this behavior.\n\n$_FASD_AWK\nWhich awk to use. Fasd can detect and use a compatible awk.\n\n$_FASD_SINK\nFile to log all STDERR to, defaults to \"/dev/null\".\n\n$_FASD_MAX\nMax total score / weight, defaults to 2000.\n\n$_FASD_SHELL\nWhich shell to execute. Some shells will run faster than others. fasd\nruns faster with dash and ksh variants.\n\n$_FASD_BACKENDS\nDefault backends.\n\n$_FASD_RO\nIf set to any non-empty string, fasd will not add or delete entries from\ndatabase. You can set and export this variable from command line.\n\n$_FASD_FUZZY\nLevel of \"fuzziness\" when doing fuzzy matching. More precisely, the number of\ncharacters that can be skipped to generate a match. Set to empty or 0 to\ndisable fuzzy matching. Default value is 2.\n\n$_FASD_VIMINFO\nPath to .viminfo file for viminfo backend, defaults to \"$HOME/.viminfo\"\n\n$_FASD_RECENTLY_USED_XBEL\nPath to XDG recently-used.xbel file for recently-used backend, defaults to\n\"$HOME/.local/share/recently-used.xbel\"\n\n```\n\n# Debugging\n\nIf fasd does not work as expected, please file a bug report describing the\nunexpected behavior along with your OS version, shell version, awk version, sed\nversion, and a log file.\n\nYou can set `_FASD_SINK` in your `.fasdrc` to obtain a log.\n\n```sh\n_FASD_SINK=\"$HOME/.fasd.log\"\n```\n\n# COPYING\n\nFasd is originally written based on code from [z](https://github.com/rupa/z) by\nrupa deadwyler under the WTFPL license. Most if not all of the code has been\nrewritten. Fasd is licensed under the \"MIT/X11\" license.\n\n"
        },
        {
          "name": "fasd",
          "type": "blob",
          "size": 19.7216796875,
          "content": "#!/usr/bin/env sh\n\n# Fasd (this file) can be sourced or executed by any POSIX compatible shell.\n\n# Fasd is originally written based on code from z (https://github.com/rupa/z)\n# by rupa deadwyler under the WTFPL license. Most if not all of the code has\n# been rewritten.\n\n# Copyright (C) 2011, 2012 by Wei Dai. All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfasd() {\n\n  # make zsh do word splitting inside this function\n  [ \"$ZSH_VERSION\" ] && emulate sh && setopt localoptions\n\n  case $1 in\n  --init) shift\n    while [ \"$1\" ]; do\n      case $1 in\n        env)\n          { # source rc files if present\n          [ -s \"/etc/fasdrc\" ] && . \"/etc/fasdrc\"\n          [ -s \"$HOME/.fasdrc\" ] && . \"$HOME/.fasdrc\"\n\n          # set default options\n          [ -z \"$_FASD_DATA\" ] && _FASD_DATA=\"$HOME/.fasd\"\n          [ -z \"$_FASD_BLACKLIST\" ] && _FASD_BLACKLIST=\"--help\"\n          [ -z \"$_FASD_SHIFT\" ] && _FASD_SHIFT=\"sudo busybox\"\n          [ -z \"$_FASD_IGNORE\" ] && _FASD_IGNORE=\"fasd ls echo\"\n          [ -z \"$_FASD_SINK\" ] && _FASD_SINK=/dev/null\n          [ -z \"$_FASD_TRACK_PWD\" ] && _FASD_TRACK_PWD=1\n          [ -z \"$_FASD_MAX\" ] && _FASD_MAX=2000\n          [ -z \"$_FASD_BACKENDS\" ] && _FASD_BACKENDS=native\n          [ -z \"$_FASD_FUZZY\" ] && _FASD_FUZZY=2\n          [ -z \"$_FASD_VIMINFO\" ] && _FASD_VIMINFO=\"$HOME/.viminfo\"\n          [ -z \"$_FASD_RECENTLY_USED_XBEL\" ] && \\\n            _FASD_RECENTLY_USED_XBEL=\"$HOME/.local/share/recently-used.xbel\"\n\n          if [ -z \"$_FASD_AWK\" ]; then\n            # awk preferences\n            local awk; for awk in mawk gawk original-awk nawk awk; do\n              $awk \"\" && _FASD_AWK=$awk && break\n            done\n          fi\n        } >> \"${_FASD_SINK:-/dev/null}\" 2>&1\n        ;;\n\n      auto) cat <<EOS\n{ if [ \"\\$ZSH_VERSION\" ] && compctl; then # zsh\n    eval \"\\$(fasd --init posix-alias zsh-hook zsh-ccomp zsh-ccomp-install \\\\\n      zsh-wcomp zsh-wcomp-install)\"\n  elif [ \"\\$BASH_VERSION\" ] && complete; then # bash\n    eval \"\\$(fasd --init posix-alias bash-hook bash-ccomp bash-ccomp-install)\"\n  else # posix shell\n    eval \"\\$(fasd --init posix-alias posix-hook)\"\n  fi\n} >> \"$_FASD_SINK\" 2>&1\n\nEOS\n        ;;\n\n      posix-alias) cat <<EOS\nalias a='fasd -a'\nalias s='fasd -si'\nalias sd='fasd -sid'\nalias sf='fasd -sif'\nalias d='fasd -d'\nalias f='fasd -f'\n# function to execute built-in cd\nfasd_cd() {\n  if [ \\$# -le 1 ]; then\n    fasd \"\\$@\"\n  else\n    local _fasd_ret=\"\\$(fasd -e 'printf %s' \"\\$@\")\"\n    [ -z \"\\$_fasd_ret\" ] && return\n    [ -d \"\\$_fasd_ret\" ] && cd \"\\$_fasd_ret\" || printf %s\\\\n \"\\$_fasd_ret\"\n  fi\n}\nalias z='fasd_cd -d'\nalias zz='fasd_cd -d -i'\n\nEOS\n        ;;\n\n      tcsh-alias) cat <<EOS\n;alias a 'fasd -a';\nalias s 'fasd -si';\nalias sd 'fasd -sid';\nalias sf 'fasd -sif';\nalias d 'fasd -d';\nalias f 'fasd -f';\nalias z 'cd \"\\`fasd -d -e printf\\\\ %s \\\\!*\\`\" >& /dev/null || fasd -d';\nEOS\n        ;;\n\n      zsh-hook) cat <<EOS\n# add zsh hook\n_fasd_preexec() {\n  { eval \"fasd --proc \\$(fasd --sanitize \\$2)\"; } >> \"$_FASD_SINK\" 2>&1\n}\nautoload -Uz add-zsh-hook\nadd-zsh-hook preexec _fasd_preexec\n\nEOS\n        ;;\n\n      bash-hook) cat <<EOS\n_fasd_prompt_func() {\n  eval \"fasd --proc \\$(fasd --sanitize \\$(history 1 | \\\\\n    sed \"s/^[ ]*[0-9]*[ ]*//\"))\" >> \"$_FASD_SINK\" 2>&1\n}\n\n# add bash hook\ncase \\$PROMPT_COMMAND in\n  *_fasd_prompt_func*) ;;\n  *) PROMPT_COMMAND=\"_fasd_prompt_func;\\$PROMPT_COMMAND\";;\nesac\n\nEOS\n        ;;\n\n      posix-hook) cat <<EOS\n_fasd_ps1_func() {\n  { eval \"fasd --proc \\$(fasd --sanitize \\$(fc -nl -1))\"; } \\\\\n    >> \"$_FASD_SINK\" 2>&1\n}\ncase \\$PS1 in\n  *_fasd_ps1_func*) ;;\n  *) export PS1=\"\\\\\\$(_fasd_ps1_func)\\$PS1\";;\nesac\n\nEOS\n        ;;\n\n      tcsh-hook) cat <<EOS\n;alias fasd-prev-cmd 'fasd --sanitize \\`history -h 1\\`';\nset pprecmd=\"\\`alias precmd\\`\";\nalias precmd '\\$pprecmd; eval \"fasd --proc \\`fasd-prev-cmd\\`\" >& /dev/null';\nEOS\n\n        ;;\n\n      zsh-ccomp) cat <<EOS\n# zsh command mode completion\n_fasd_zsh_cmd_complete() {\n  local compl\n  read -c compl\n  (( \\$+compstate )) && compstate[insert]=menu # no expand if compsys loaded\n  reply=(\\${(f)\"\\$(fasd --complete \"\\$compl\")\"})\n}\n\nEOS\n        ;;\n\n      zsh-wcomp) cat <<EOS\n(( \\$+functions[compdef] )) && {\n  # zsh word mode completion\n  _fasd_zsh_word_complete() {\n    [ \"\\$2\" ] && local _fasd_cur=\"\\$2\"\n    [ -z \"\\$_fasd_cur\" ] && local _fasd_cur=\"\\${words[CURRENT]}\"\n    local fnd=\"\\${_fasd_cur//,/ }\"\n    local typ=\\${1:-e}\n    fasd --query \\$typ \"\\$fnd\" 2>> \"$_FASD_SINK\" | \\\\\n      sort -nr | sed 's/^[^ ]*[ ]*//' | while read -r line; do\n        compadd -U -V fasd \"\\$line\"\n      done\n    compstate[insert]=menu # no expand\n  }\n  _fasd_zsh_word_complete_f() { _fasd_zsh_word_complete f ; }\n  _fasd_zsh_word_complete_d() { _fasd_zsh_word_complete d ; }\n  _fasd_zsh_word_complete_trigger() {\n    local _fasd_cur=\"\\${words[CURRENT]}\"\n    eval \\$(fasd --word-complete-trigger _fasd_zsh_word_complete \\$_fasd_cur)\n  }\n  # define zle widgets\n  zle -C fasd-complete complete-word _generic\n  zstyle ':completion:fasd-complete:*' completer _fasd_zsh_word_complete\n  zstyle ':completion:fasd-complete:*' menu-select\n\n  zle -C fasd-complete-f complete-word _generic\n  zstyle ':completion:fasd-complete-f:*' completer _fasd_zsh_word_complete_f\n  zstyle ':completion:fasd-complete-f:*' menu-select\n\n  zle -C fasd-complete-d complete-word _generic\n  zstyle ':completion:fasd-complete-d:*' completer _fasd_zsh_word_complete_d\n  zstyle ':completion:fasd-complete-d:*' menu-select\n}\n\nEOS\n        ;;\n\n      zsh-ccomp-install) cat <<EOS\n# enable command mode completion\ncompctl -U -K _fasd_zsh_cmd_complete -V fasd -x 'C[-1,-*e],s[-]n[1,e]' -c - \\\\\n  'c[-1,-A][-1,-D]' -f -- fasd fasd_cd\n\nEOS\n        ;;\n\n      zsh-wcomp-install) cat <<EOS\n(( \\$+functions[compdef] )) && {\n  # enable word mode completion\n  orig_comp=\"\\$(zstyle -L ':completion:\\\\*' completer 2>> \"$_FASD_SINK\")\"\n  if [ \"\\$orig_comp\" ]; then\n    case \\$orig_comp in\n      *_fasd_zsh_word_complete_trigger*);;\n      *) eval \"\\$orig_comp _fasd_zsh_word_complete_trigger\";;\n    esac\n  else\n    zstyle ':completion:*' completer _complete _fasd_zsh_word_complete_trigger\n  fi\n  unset orig_comp\n}\n\nEOS\n        ;;\n\n      bash-ccomp) cat <<EOS\n# bash command mode completion\n_fasd_bash_cmd_complete() {\n  # complete command after \"-e\"\n  local cur=\\${COMP_WORDS[COMP_CWORD]}\n  [[ \\${COMP_WORDS[COMP_CWORD-1]} == -*e ]] && \\\\\n    COMPREPLY=( \\$(compgen -A command \\$cur) ) && return\n  # complete using default readline complete after \"-A\" or \"-D\"\n  case \\${COMP_WORDS[COMP_CWORD-1]} in\n    -A|-D) COMPREPLY=( \\$(compgen -o default \\$cur) ) && return;;\n  esac\n  # get completion results using expanded aliases\n  local RESULT=\\$( fasd --complete \"\\$(alias -p \\$COMP_WORDS \\\\\n    2>> \"$_FASD_SINK\" | sed -n \"\\\\\\$s/^.*'\\\\\\\\(.*\\\\\\\\)'/\\\\\\\\1/p\")\n    \\${COMP_LINE#* }\" | while read -r line; do\n      quote_readline \"\\$line\" 2>/dev/null || \\\\\n        printf %q \"\\$line\" 2>/dev/null  && \\\\\n        printf \\\\\\\\n\n    done)\n  local IFS=\\$'\\\\n'; COMPREPLY=( \\$RESULT )\n}\n_fasd_bash_hook_cmd_complete() {\n  for cmd in \\$*; do\n    complete -F _fasd_bash_cmd_complete \\$cmd\n  done\n}\n\nEOS\n        ;;\n\n      bash-ccomp-install) cat <<EOS\n# enable bash command mode completion\n_fasd_bash_hook_cmd_complete fasd a s d f sd sf z zz\n\nEOS\n        ;;\n      esac; shift\n    done\n    ;;\n\n  # if \"$_fasd_cur\" or \"$2\" is a query, then output shell code to be eval'd\n  --word-complete-trigger)\n    shift; [ \"$2\" ] && local _fasd_cur=\"$2\" || return\n    case $_fasd_cur in\n      ,*) printf %s\\\\n \"$1 e $_fasd_cur\";;\n      f,*) printf %s\\\\n \"$1 f ${_fasd_cur#?}\";;\n      d,*) printf %s\\\\n \"$1 d ${_fasd_cur#?}\";;\n      *,,) printf %s\\\\n \"$1 e $_fasd_cur\";;\n      *,,f) printf %s\\\\n \"$1 f ${_fasd_cur%?}\";;\n      *,,d) printf %s\\\\n \"$1 d ${_fasd_cur%?}\";;\n    esac\n    ;;\n\n  --sanitize) shift; printf %s\\\\n \"$*\" | \\\n      sed 's/\\([^\\]\\)$( *[^ ]* *\\([^)]*\\)))*/\\1\\2/g\n        s/\\([^\\]\\)[|&;<>$`{}]\\{1,\\}/\\1 /g'\n    ;;\n\n  --proc) shift # process commands\n    # stop if we don't own $_FASD_DATA or $_FASD_RO is set\n    [ -f \"$_FASD_DATA\" -a ! -O \"$_FASD_DATA\" ] || [ \"$_FASD_RO\" ] && return\n\n    # blacklists\n    local each; for each in $_FASD_BLACKLIST; do\n      case \" $* \" in *\\ $each\\ *) return;; esac\n    done\n\n    # shifts\n    while true; do\n      case \" $_FASD_SHIFT \" in\n        *\\ $1\\ *) shift;;\n        *) break;;\n      esac\n    done\n\n    # ignores\n    case \" $_FASD_IGNORE \" in\n      *\\ $1\\ *) return;;\n    esac\n\n    shift; fasd --add \"$@\" # add all arguments except command\n    ;;\n\n  --add|-A) shift # add entries\n    # stop if we don't own $_FASD_DATA or $_FASD_RO is set\n    [ -f \"$_FASD_DATA\" -a ! -O \"$_FASD_DATA\" ] || [ \"$_FASD_RO\" ] && return\n\n    # find all valid path arguments, convert them to simplest absolute form\n    local paths=\"$(while [ \"$1\" ]; do\n      [ -e \"$1\" ] && printf %s\\\\n \"$1\"; shift\n    done | sed '/^[^/]/s@^@'\"$PWD\"'/@\n      s@/\\.\\.$@/../@;s@/\\(\\./\\)\\{1,\\}@/@g;:0\n      s@[^/][^/]*//*\\.\\./@/@;t 0\n      s@^/*\\.\\./@/@;s@//*@/@g;s@/\\.\\{0,1\\}$@@;s@^$@/@' 2>> \"$_FASD_SINK\" \\\n      | tr '\\n' '|')\"\n\n    # add current pwd if the option is set\n    [ \"$_FASD_TRACK_PWD\" = \"1\" -a \"$PWD\" != \"$HOME\" ] && paths=\"$paths|$PWD\"\n\n    [ -z \"${paths##\\|}\" ] && return # stop if we have nothing to add\n\n    # maintain the file\n    local tempfile\n    tempfile=\"$(mktemp \"$_FASD_DATA\".XXXXXX)\" || return\n    $_FASD_AWK -v list=\"$paths\" -v now=\"$(date +%s)\" -v max=\"$_FASD_MAX\" -F\"|\" '\n      BEGIN {\n        split(list, files, \"|\")\n        for(i in files) {\n          path = files[i]\n          if(path == \"\") continue\n          paths[path] = path # array for checking\n          rank[path] = 1\n          time[path] = now\n        }\n      }\n      $2 >= 1 {\n        if($1 in paths) {\n          rank[$1] = $2 + 1 / $2\n          time[$1] = now\n        } else {\n          rank[$1] = $2\n          time[$1] = $3\n        }\n        count += $2\n      }\n      END {\n        if(count > max)\n          for(i in rank) print i \"|\" 0.9*rank[i] \"|\" time[i] # aging\n        else\n          for(i in rank) print i \"|\" rank[i] \"|\" time[i]\n      }' \"$_FASD_DATA\" 2>> \"$_FASD_SINK\" >| \"$tempfile\"\n    if [ $? -ne 0 -a -f \"$_FASD_DATA\" ]; then\n      env rm -f \"$tempfile\"\n    else\n      env mv -f \"$tempfile\" \"$_FASD_DATA\"\n    fi\n    ;;\n\n  --delete|-D) shift # delete entries\n    # stop if we don't own $_FASD_DATA or $_FASD_RO is set\n    [ -f \"$_FASD_DATA\" -a ! -O \"$_FASD_DATA\" ] || [ \"$_FASD_RO\" ] && return\n\n    # turn valid arguments into entry-deleting sed commands\n    local sed_cmd=\"$(while [ \"$1\" ]; do printf %s\\\\n \"$1\"; shift; done | \\\n      sed '/^[^/]/s@^@'\"$PWD\"'/@;s@/\\.\\.$@/../@;s@/\\(\\./\\)\\{1,\\}@/@g;:0\n        s@[^/][^/]*//*\\.\\./@/@;t 0\n        s@^/*\\.\\./@/@;s@//*@/@g;s@/\\.\\{0,1\\}$@@\n        s@^$@/@;s@\\([.[\\/*^$]\\)@\\\\\\1@g;s@^\\(.*\\)$@/^\\1|/d@' 2>> \"$_FASD_SINK\")\"\n\n    # maintain the file\n    local tempfile\n    tempfile=\"$(mktemp \"$_FASD_DATA\".XXXXXX)\" || return\n\n    sed \"$sed_cmd\" \"$_FASD_DATA\" 2>> \"$_FASD_SINK\" >| \"$tempfile\"\n\n    if [ $? -ne 0 -a -f \"$_FASD_DATA\" ]; then\n      env rm -f \"$tempfile\"\n    else\n      env mv -f \"$tempfile\" \"$_FASD_DATA\"\n    fi\n    ;;\n\n  --query) shift # query the db, --query [$typ [\"$fnd\" [$mode]]]\n    [ -f \"$_FASD_DATA\" ] || return # no db yet\n    [ \"$1\" ] && local typ=\"$1\"\n    [ \"$2\" ] && local fnd=\"$2\"\n    [ \"$3\" ] && local mode=\"$3\"\n\n    # cat all backends\n    local each _fasd_data; for each in $_FASD_BACKENDS; do\n      _fasd_data=\"$_fasd_data\n$(fasd --backend $each)\"\n    done\n    [ \"$_fasd_data\" ] || _fasd_data=\"$(cat \"$_FASD_DATA\")\"\n\n    # set mode specific code for calculating the prior\n    case $mode in\n      rank) local prior='times[i]';;\n      recent) local prior='sqrt(100000/(1+t-la[i]))';;\n      *) local prior='times[i] * frecent(la[i])';;\n    esac\n\n    if [ \"$fnd\" ]; then # dafault matching\n      local bre=\"$(printf %s\\\\n \"$fnd\" | sed 's/\\([*\\.\\\\\\[]\\)/\\\\\\1/g\n        s@ @[^|]*@g;s/\\$$/|/')\"\n      bre='^[^|]*'\"$bre\"'[^|/]*|'\n      local _ret=\"$(printf %s\\\\n \"$_fasd_data\" | grep \"$bre\")\"\n      [ \"$_ret\" ] && _ret=\"$(printf %s\\\\n \"$_ret\" | while read -r line; do\n        [ -${typ:-e} \"${line%%\\|*}\" ] && printf %s\\\\n \"$line\"\n      done)\"\n      if [ \"$_ret\" ]; then\n        _fasd_data=\"$_ret\"\n      else # no case mathcing\n        _ret=\"$(printf %s\\\\n \"$_fasd_data\" | grep -i \"$bre\")\"\n        [ \"$_ret\" ] && _ret=\"$(printf %s\\\\n \"$_ret\" | while read -r line; do\n          [ -${typ:-e} \"${line%%\\|*}\" ] && printf %s\\\\n \"$line\"\n        done)\"\n        if [ \"$_ret\" ]; then\n          _fasd_data=\"$_ret\"\n        elif [ \"${_FASD_FUZZY:-0}\" -gt 0 ]; then # fuzzy matching\n          local fuzzy_bre=\"$(printf %s\\\\n \"$fnd\" | \\\n            sed 's/\\([*\\.\\\\\\[]\\)/\\\\\\1/g;s/\\$$/|/\n              s@\\(\\\\\\{0,1\\}[^ ]\\)@\\1[^|/]\\\\{0,'\"$_FASD_FUZZY\"'\\\\}@g\n              s@ @[^|]*@g')\"\n          fuzzy_bre='^[^|]*'\"$fuzzy_bre\"'[^|/]*|'\n          _ret=\"$(printf %s\\\\n \"$_fasd_data\" | grep -i \"$fuzzy_bre\")\"\n          [ \"$_ret\" ] && _ret=\"$(printf %s\\\\n \"$_ret\" | while read -r line; do\n            [ -${typ:-e} \"${line%%\\|*}\" ] && printf %s\\\\n \"$line\"\n          done)\"\n          [ \"$_ret\" ] && _fasd_data=\"$_ret\" || _fasd_data=\n        fi\n      fi\n    else # no query arugments\n      _fasd_data=\"$(printf %s\\\\n \"$_fasd_data\" | while read -r line; do\n        [ -${typ:-e} \"${line%%\\|*}\" ] && printf %s\\\\n \"$line\"\n      done)\"\n    fi\n\n    # query the database\n    [ \"$_fasd_data\" ] && printf %s\\\\n \"$_fasd_data\" | \\\n      $_FASD_AWK -v t=\"$(date +%s)\" -F\"|\" '\n      function frecent(time) {\n        dx = t-time\n        if( dx < 3600 ) return 6\n        if( dx < 86400 ) return 4\n        if( dx < 604800 ) return 2\n        return 1\n      }\n      {\n        if(!paths[$1]) {\n          times[$1] = $2\n          la[$1] = $3\n          paths[$1] = 1\n        } else {\n          times[$1] += $2\n          if($3 > la[$1]) la[$1] = $3\n        }\n      }\n      END {\n        for(i in paths) printf \"%-10s %s\\n\", '\"$prior\"', i\n      }' - 2>> \"$_FASD_SINK\"\n    ;;\n\n  --backend)\n    case $2 in\n      native) cat \"$_FASD_DATA\";;\n      viminfo)\n        < \"$_FASD_VIMINFO\" sed -n '/^>/{s@~@'\"$HOME\"'@\n          s/^..//\n          p\n          }' | $_FASD_AWK -v t=\"$(date +%s)\" '{\n            t -= 60\n            print $0 \"|1|\" t\n          }'\n        ;;\n      recently-used)\n        local nl=\"$(printf '\\\\\\nX')\"; nl=\"${nl%X}\" # slash newline for sed\n        tr -d '\\n' < \"$_FASD_RECENTLY_USED_XBEL\" | \\\n          sed 's@file:/@'\"$nl\"'@g;s@count=\"@'\"$nl\"'@g' | sed '1d;s/\".*$//' | \\\n          tr '\\n' '|' | sed 's@|/@'\"$nl\"'@g' | $_FASD_AWK -F'|' '{\n            sum = 0\n            for( i=2; i<=NF; i++ ) sum += $i\n            print $1 \"|\" sum\n          }'\n        ;;\n      current)\n        for path in *; do\n          printf \"$PWD/%s|1\\\\n\" \"$path\"\n        done\n        ;;\n      spotlight)\n        mdfind '(kMDItemFSContentChangeDate >= $time.today) ||\n          kMDItemLastUsedDate >= $time.this_month' \\\n          | sed '/Library\\//d\n            /\\.app$/d\n            s/$/|2/'\n        ;;\n      *) eval \"$2\";;\n    esac\n    ;;\n\n  *) # parsing logic and processing\n    local fnd= last= _FASD_BACKENDS=\"$_FASD_BACKENDS\" _fasd_data= comp= exec=\n    while [ \"$1\" ]; do case $1 in\n      --complete) [ \"$2\" = \"--\" ] && shift; set -- $2; local lst=1 r=r comp=1;;\n      --query|--add|--delete|-A|-D) fasd \"$@\"; return $?;;\n      --version) [ -z \"$comp\" ] && echo \"1.0.1\" && return;;\n      --) while [ \"$2\" ]; do shift; fnd=\"$fnd $1\"; last=\"$1\"; done;;\n      -*) local o=\"${1#-}\"; while [ \"$o\" ]; do case $o in\n          s*) local show=1;;\n          l*) local lst=1;;\n          i*) [ -z \"$comp\" ] && local interactive=1 show=1;;\n          r*) local mode=rank;;\n          t*) local mode=recent;;\n          e*) o=\"${o#?}\"; if [ \"$o\" ]; then # there are characters after \"-e\"\n                local exec=\"$o\" # anything after \"-e\"\n              else # use the next argument\n                local exec=\"${2:?\"-e: Argument needed \"}\"\n                shift\n              fi; break;;\n          b*) o=\"${o#?}\"; if [ \"$o\" ]; then\n                _FASD_BACKENDS=\"$o\"\n              else\n                _FASD_BACKENDS=\"${2:?\"-b: Argument needed\"}\"\n                shift\n              fi; break;;\n          B*) o=\"${o#?}\"; if [ \"$o\" ]; then\n                _FASD_BACKENDS=\"$_FASD_BACKENDS $o\"\n              else\n                _FASD_BACKENDS=\"$_FASD_BACKENDS ${2:?\"-B: Argument needed\"}\"\n                shift\n              fi; break;;\n          a*) local typ=e;;\n          d*) local typ=d;;\n          f*) local typ=f;;\n          R*) local r=r;;\n      [0-9]*) local _fasd_i=\"$o\"; break;;\n          h*) [ -z \"$comp\" ] && echo \"fasd [options] [query ...]\n[f|a|s|d|z] [options] [query ...]\n  options:\n    -s         list paths with scores\n    -l         list paths without scores\n    -i         interactive mode\n    -e <cmd>   set command to execute on the result file\n    -b <name>  only use <name> backend\n    -B <name>  add additional backend <name>\n    -a         match files and directories\n    -d         match directories only\n    -f         match files only\n    -r         match by rank only\n    -t         match by recent access only\n    -R         reverse listing order\n    -h         show a brief help message\n    -[0-9]     select the nth entry\n\nfasd [-A|-D] [paths ...]\n    -A    add paths\n    -D    delete paths\" >&2 && return;;\n        esac; o=\"${o#?}\"; done;;\n      *) fnd=\"$fnd $1\"; last=\"$1\";;\n    esac; shift; done\n\n    # guess whether the last query is selected from tab completion\n    case $last in\n      /?*) if [ -z \"$show$lst\" -a -${typ:-e} \"$last\" -a \"$exec\" ]; then\n             $exec \"$last\"\n             return\n           fi;;\n    esac\n\n    local R; [ -z \"$r\" ] && R=r || R= # let $R be the opposite of $r\n    fnd=\"${fnd# }\"\n\n    local res\n    res=\"$(fasd --query 2>> \"$_FASD_SINK\")\" # query the database\n    [ $? -gt 0 ] && return\n    if [ 0 -lt ${_fasd_i:-0} ] 2>> \"$_FASD_SINK\"; then\n      res=\"$(printf %s\\\\n \"$res\" | sort -n${R} | \\\n        sed -n \"$_fasd_i\"'s/^[^ ]*[ ]*//p')\"\n    elif [ \"$interactive\" ] || [ \"$exec\" -a -z \"$fnd$lst$show\" -a -t 1 ]; then\n      if [ \"$(printf %s \"$res\" | sed -n '$=')\" -gt 1 ]; then\n        res=\"$(printf %s\\\\n \"$res\" | sort -n${R})\"\n        printf %s\\\\n \"$res\" | sed = | sed 'N;s/\\n/\t/' | sort -nr >&2\n        printf \"> \" >&2\n        local i; read i; [ 0 -lt \"${i:-0}\" ] 2>> \"$_FASD_SINK\" || return 1\n      fi\n      res=\"$(printf %s\\\\n \"$res\" | sed -n \"${i:-1}\"'s/^[^ ]*[ ]*//p')\"\n    elif [ \"$lst\" ]; then\n      [ \"$res\" ] && printf %s\\\\n \"$res\" | sort -n${r} | sed 's/^[^ ]*[ ]*//'\n      return\n    elif [ \"$show\" ]; then\n      [ \"$res\" ] && printf %s\\\\n \"$res\" | sort -n${r}\n      return\n    elif [ \"$fnd\" ] && [ \"$exec\" -o ! -t 1 ]; then # exec or subshell\n      res=\"$(printf %s\\\\n \"$res\" | sort -n | sed -n '$s/^[^ ]*[ ]*//p')\"\n    else # no args, show\n      [ \"$res\" ] && printf %s\\\\n \"$res\" | sort -n${r}\n      return\n    fi\n    if [ \"$res\" ]; then\n      fasd --add \"$res\"\n      [ -z \"$exec\" ] && exec='printf %s\\n'\n      $exec \"$res\"\n    fi\n    ;;\n  esac\n}\n\nfasd --init env\n\ncase $- in\n  *i*) ;; # assume being sourced, do nothing\n  *) # assume being executed as an executable\n    if [ -x \"$_FASD_SHELL\" -a -z \"$_FASD_SET\" ]; then\n      _FASD_SET=1 exec $_FASD_SHELL \"$0\" \"$@\"\n    else\n      fasd \"$@\"\n    fi;;\nesac\n\n"
        },
        {
          "name": "fasd.1",
          "type": "blob",
          "size": 10.21875,
          "content": ".TH \"FASD\" \"1\" \"Jul 16, 2012\" \"fasd user manual\" \"\"\n.SH NAME\n.PP\nfasd \\- quick access to files and directories\n.SH SYNOPSIS\n.PP\nfasd [options] [query ...]\n.PP\n[f|a|s|d|z] [options] [query ...]\n.PP\nfasd [\\-A|\\-D] [paths ...]\n.SH OPTIONS\n.IP\n.nf\n\\f[C]\n\\-s\\ \\ \\ \\ \\ \\ \\ \\ \\ list\\ paths\\ with\\ ranks\n\\-l\\ \\ \\ \\ \\ \\ \\ \\ \\ list\\ paths\\ without\\ ranks\n\\-i\\ \\ \\ \\ \\ \\ \\ \\ \\ interactive\\ mode\n\\-e\\ <cmd>\\ \\ \\ set\\ command\\ to\\ execute\\ on\\ the\\ result\\ file\n\\-b\\ <name>\\ \\ only\\ use\\ <name>\\ backend\n\\-B\\ <name>\\ \\ add\\ additional\\ backend\\ <name>\n\\-a\\ \\ \\ \\ \\ \\ \\ \\ \\ match\\ files\\ and\\ directories\n\\-d\\ \\ \\ \\ \\ \\ \\ \\ \\ match\\ directories\\ only\n\\-f\\ \\ \\ \\ \\ \\ \\ \\ \\ match\\ files\\ only\n\\-r\\ \\ \\ \\ \\ \\ \\ \\ \\ match\\ by\\ rank\\ only\n\\-t\\ \\ \\ \\ \\ \\ \\ \\ \\ match\\ by\\ recent\\ access\\ only\n\\-R\\ \\ \\ \\ \\ \\ \\ \\ \\ reverse\\ listing\\ order\n\\-h\\ \\ \\ \\ \\ \\ \\ \\ \\ show\\ a\\ brief\\ help\\ message\n\\-[0\\-9]\\ \\ \\ \\ \\ select\\ the\\ nth\\ entry\n\\f[]\n.fi\n.SH DESCRIPTION\n.PP\nFasd keeps track of files and directories you access in your shell and\ngives you quick access to them.\nYou can use fasd to reference files or directories by just a few key\nidentifying characters.\nYou can use fasd to boost your command line productivity by defining\nyour own aliases to launch programs on files or directories.\nFasd, by default, provides some basic aliases, including a shell\nfunction \"z\" that resembles the functionality of \"z\" and \"autojump.\"\n.PP\nThe name \"fasd\" comes from the default suggested aliases\n\\f[C]f\\f[](files), \\f[C]a\\f[](files/directories),\n\\f[C]s\\f[](show/search/select), \\f[C]d\\f[](directories).\n.PP\nFasd ranks files and directories by \"frecency,\" that is, by both\n\"frequency\" and \"recency.\" The term \"frecency\" was first coined by\nMozilla and used in Firefox.\n.SH EXAMPLES\n.IP\n.nf\n\\f[C]\nz\\ bundle\nf\\ \\-e\\ vim\\ nginx\\ conf\nf\\ \\-i\\ rc$\nvi\\ `f\\ nginx\\ conf`\ncp\\ update.html\\ `d\\ www`\nopen\\ `sf\\ pdf`\n\\f[]\n.fi\n.SH SHELL INITIALIZATION\n.PP\nTo get fasd working in a shell, some initialization code must be run.\nPut lines below in your POSIX compatible shell rc.\n.IP\n.nf\n\\f[C]\neval\\ \"$(fasd\\ \\-\\-init\\ auto)\"\n\\f[]\n.fi\n.PP\nThis will setup a command hook that executes on every command and\nadvanced tab completion for zsh and bash.\n.PP\nIf you want more control over what gets into your shell environment, you\ncan pass customized set of arguments to \\f[C]fasd\\ \\-\\-init\\f[].\n.IP\n.nf\n\\f[C]\nzsh\\-hook\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ define\\ _fasd_preexec\\ and\\ add\\ it\\ to\\ zsh\\ preexec\\ array\nzsh\\-ccomp\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ zsh\\ command\\ mode\\ completion\\ definitions\nzsh\\-ccomp\\-install\\ \\ \\ \\ #\\ setup\\ command\\ mode\\ completion\\ for\\ zsh\nzsh\\-wcomp\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ zsh\\ word\\ mode\\ completion\\ definitions\nzsh\\-wcomp\\-install\\ \\ \\ \\ #\\ setup\\ word\\ mode\\ completion\\ for\\ zsh\nbash\\-hook\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ add\\ hook\\ code\\ to\\ bash\\ $PROMPT_COMMAND\nbash\\-ccomp\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ bash\\ command\\ mode\\ completion\\ definitions\nbash\\-ccomp\\-install\\ \\ \\ #\\ setup\\ command\\ mode\\ completion\\ for\\ bash\nposix\\-alias\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ define\\ aliases\\ that\\ applies\\ to\\ all\\ posix\\ shells\nposix\\-hook\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ setup\\ $PS1\\ hook\\ for\\ shells\\ that\\[aq]s\\ posix\\ compatible\ntcsh\\-alias\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ define\\ aliases\\ for\\ tcsh\ntcsh\\-hook\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ #\\ setup\\ tcsh\\ precmd\\ alias\n\\f[]\n.fi\n.PP\nExample for a minimal zsh setup (no tab completion):\n.IP\n.nf\n\\f[C]\neval\\ \"$(fasd\\ \\-\\-init\\ posix\\-alias\\ zsh\\-hook)\"\n\\f[]\n.fi\n.PP\nNote that this method will slightly increase your shell start\\-up time,\nsince calling binaries has overhead.\nYou can cache fasd init code if you want minimal overhead.\nExample code for bash (to be put into .bashrc):\n.IP\n.nf\n\\f[C]\nfasd_cache=\"$HOME/.fasd\\-init\\-bash\"\nif\\ [\\ \"$(command\\ \\-v\\ fasd)\"\\ \\-nt\\ \"$fasd_cache\"\\ \\-o\\ !\\ \\-s\\ \"$fasd_cache\"\\ ];\\ then\n\\ \\ fasd\\ \\-\\-init\\ posix\\-alias\\ bash\\-hook\\ bash\\-ccomp\\ bash\\-ccomp\\-install\\ >|\\ \"$fasd_cache\"\nfi\nsource\\ \"$fasd_cache\"\nunset\\ fasd_cache\n\\f[]\n.fi\n.PP\nOptionally, if you can also source \\f[C]fasd\\f[] if you want\n\\f[C]fasd\\f[] to be a shell function instead of an executable.\n.PP\nYou can tweak initialization code.\nFor instance, if you want to use \"c\" instead of \"z\" to do directory\njumping, you can use the alias below:\n.IP\n.nf\n\\f[C]\nalias\\ c=\\[aq]fasd_cd\\ \\-d\\[aq]\n#\\ `\\-d\\[aq]\\ option\\ present\\ for\\ bash\\ completion\n#\\ function\\ fasd_cd\\ is\\ defined\\ in\\ posix\\-alias\n\\f[]\n.fi\n.SH MATCHING\n.PP\nFasd has three matching modes: default, case\\-insensitive, and fuzzy.\n.PP\nFor a given set of queries (the set of command\\-line arguments passed to\nfasd), a path is a match if and only if:\n.IP \"1.\" 3\nQueries match the path in order.\n.IP \"2.\" 3\nThe last query matches the last segment of the path.\n.PP\nIf no match is found, fasd will try the same process ignoring case.\nIf still no match is found, fasd will allow extra characters to be\nplaced between query characters for fuzzy matching.\n.PP\nTips:\n.IP \\[bu] 2\nIf you want your last query not to match the last segment of the path,\nappend `/\\[aq] as the last query.\n.IP \\[bu] 2\nIf you want your last query to match the end of the filename, append\n`$\\[aq] to the last query.\n.SH COMPATIBILITY\n.PP\nFasd\\[aq]s basic functionalities are POSIX compliant, meaning that you\nshould be able to use fasd in all POSIX compliant shells.\nYour shell need to support command substitution in $PS1 in order for\nfasd to automatically track your commands and files.\nThis feature is not specified by the POSIX standard, but it\\[aq]s\nnonetheless present in many POSIX compliant shells.\nIn shells without prompt command or prompt command substitution (tcsh\nfor instance), you can add entries manually with \"fasd \\-A\".\nYou are very welcomed to contribute shell initialization code for not\nyet supported shells.\n.SH TAB COMPLETION\n.PP\nFasd offers two completion modes, command mode completion and word mode\ncompletion.\nCommand mode completion works in bash and zsh.\nWord mode completion only works in zsh.\n.PP\nCommand mode completion is just like completion for any other commands.\nIt is triggered when you hit tab on a fasd command or its aliases.\nUnder this mode your queries can be separated by a space.\nTip: if you find that the completion result overwrites your queries,\ntype an extra space before you hit tab.\n.PP\nWord mode completion can be triggered on \\f[I]any\\f[] command.\nWord completion is triggered by any command line argument that starts\nwith \",\" (all), \"f,\" (files), or \"d,\" (directories), or that ends with\n\",,\" (all), \",,f\" (files), or \",,d\" (directories).\nExamples:\n.IP\n.nf\n\\f[C]\n$\\ vim\\ ,rc,lo<Tab>\n$\\ vim\\ /etc/rc.local\n\n$\\ mv\\ index.html\\ d,www<Tab>\n$\\ mv\\ index.html\\ /var/www/\n\\f[]\n.fi\n.PP\nThere are also three zle widgets: \"fasd\\-complete\", \"fasd\\-complete\\-f\",\n\"fasd\\-complete\\-d\".\nYou can bind them to keybindings you like:\n.IP\n.nf\n\\f[C]\nbindkey\\ \\[aq]^X^A\\[aq]\\ fasd\\-complete\\ \\ \\ \\ #\\ C\\-x\\ C\\-a\\ to\\ do\\ fasd\\-complete\\ (files\\ and\\ directories)\nbindkey\\ \\[aq]^X^F\\[aq]\\ fasd\\-complete\\-f\\ \\ #\\ C\\-x\\ C\\-f\\ to\\ do\\ fasd\\-complete\\-f\\ (only\\ files)\nbindkey\\ \\[aq]^X^D\\[aq]\\ fasd\\-complete\\-d\\ \\ #\\ C\\-x\\ C\\-d\\ to\\ do\\ fasd\\-complete\\-d\\ (only\\ directories)\n\\f[]\n.fi\n.SH BACKENDS\n.PP\nFasd can take advantage of different sources of recent / frequent files.\nMost desktop environments (such as OS X and Gtk) and some editors (such\nas Vim) keep a list of accessed files.\nFasd can use them as additional backends if the data can be converted\ninto fasd\\[aq]s native format.\nBelow is a list of available backends.\n.IP \\[bu] 2\nspotlight: OSX spotlight, provides entries that are changed today or\nopened within the past month\n.IP \\[bu] 2\nrecently\\-used: GTK\\[aq]s recently\\-used file (Usually available on\nLinux)\n.IP \\[bu] 2\ncurrent: Provides everything in $PWD (whereever you are executing\n\\f[C]fasd\\f[])\n.IP \\[bu] 2\nviminfo: Vim\\[aq]s editing history, useful if you want to define an\nalias just for editing things in vim\n.PP\nYou can define your own backend by declaring a function by that name in\nyour \\f[C]\\&.fasdrc\\f[].\nYou can set default backend with \\f[C]_FASD_BACKENDS\\f[] variable in our\n\\f[C]\\&.fasdrc\\f[].\n.SH TWEAKS\n.PP\nUpon every execution, fasd will source \"/etc/fasdrc\" and \"$HOME/.fasdrc\"\nif they are present.\nBelow are some variables you can set:\n.IP\n.nf\n\\f[C]\n$_FASD_DATA\nPath\\ to\\ the\\ fasd\\ data\\ file,\\ default\\ \"$HOME/.fasd\".\n\n$_FASD_BLACKLIST\nList\\ of\\ blacklisted\\ strings.\\ Commands\\ matching\\ them\\ will\\ not\\ be\\ processed.\nDefault\\ is\\ \"\\-\\-help\".\n\n$_FASD_SHIFT\nList\\ of\\ all\\ commands\\ that\\ needs\\ to\\ be\\ shifted,\\ defaults\\ to\\ \"sudo\\ busybox\".\n\n$_FASD_IGNORE\nList\\ of\\ all\\ commands\\ that\\ will\\ be\\ ignored,\\ defaults\\ to\\ \"fasd\\ ls\\ echo\".\n\n$_FASD_TRACK_PWD\nFasd\\ defaults\\ to\\ track\\ your\\ \"$PWD\".\\ Set\\ this\\ to\\ 0\\ to\\ disable\\ this\\ behavior.\n\n$_FASD_AWK\nWhich\\ awk\\ to\\ use.\\ fasd\\ can\\ detect\\ and\\ use\\ a\\ compatible\\ awk.\n\n$_FASD_SINK\nFile\\ to\\ log\\ all\\ STDERR\\ to,\\ defaults\\ to\\ \"/dev/null\".\n\n$_FASD_MAX\nMax\\ total\\ score\\ /\\ weight,\\ defaults\\ to\\ 2000.\n\n$_FASD_SHELL\nWhich\\ shell\\ to\\ execute.\\ Some\\ shells\\ will\\ run\\ faster\\ than\\ others.\\ fasd\nruns\\ faster\\ with\\ dash\\ and\\ ksh\\ variants.\n\n$_FASD_BACKENDS\nDefault\\ backends.\n\n$_FASD_RO\nIf\\ set\\ to\\ any\\ non\\-empty\\ string,\\ fasd\\ will\\ not\\ add\\ or\\ delete\\ entries\\ from\ndatabase.\\ You\\ can\\ set\\ and\\ export\\ this\\ variable\\ from\\ command\\ line.\n\n$_FASD_FUZZY\nLevel\\ of\\ \"fuzziness\"\\ when\\ doing\\ fuzzy\\ matching.\\ More\\ precisely,\\ the\\ number\\ of\ncharacters\\ that\\ can\\ be\\ skipped\\ to\\ generate\\ a\\ match.\\ Set\\ to\\ empty\\ or\\ 0\\ to\ndisable\\ fuzzy\\ matching.\\ Default\\ value\\ is\\ 2.\n\n$_FASD_VIMINFO\nPath\\ to\\ .viminfo\\ file\\ for\\ viminfo\\ backend,\\ defaults\\ to\\ \"$HOME/.viminfo\"\n\n$_FASD_RECENTLY_USED_XBEL\nPath\\ to\\ XDG\\ recently\\-used.xbel\\ file\\ for\\ recently\\-used\\ backend,\\ defaults\\ to\n\"$HOME/.local/share/recently\\-used.xbel\"\n\\f[]\n.fi\n.SH DEBUGGING\n.PP\nFasd is hosted on GitHub: https://github.com/clvv/fasd\n.PP\nIf fasd does not work as expected, please file a bug report on GitHub\ndescribing the unexpected behavior along with your OS version, shell\nversion, awk version, sed version, and a log file.\n.PP\nYou can set \\f[C]_FASD_SINK\\f[] in your \\f[C]\\&.fasdrc\\f[] to obtain a\nlog.\n.IP\n.nf\n\\f[C]\n_FASD_SINK=\"$HOME/.fasd.log\"\n\\f[]\n.fi\n.SH COPYING\n.PP\nFasd is originally written based on code from z\n(https://github.com/rupa/z) by rupa deadwyler under the WTFPL license.\nMost if not all of the code has been rewritten.\nFasd is licensed under the \"MIT/X11\" license.\n.SH AUTHORS\nWei Dai <x@wei23.net>.\n"
        },
        {
          "name": "fasd.1.md",
          "type": "blob",
          "size": 9.27734375,
          "content": "% FASD(1) fasd user manual\n% Wei Dai <x@wei23.net>\n% Jul 16, 2012\n\n# NAME\n\nfasd - quick access to files and directories\n\n# SYNOPSIS\n\nfasd [options] [query ...]\n\n[f|a|s|d|z] [options] [query ...]\n\nfasd [-A|-D] [paths ...]\n\n# OPTIONS\n\n    -s         list paths with ranks\n    -l         list paths without ranks\n    -i         interactive mode\n    -e <cmd>   set command to execute on the result file\n    -b <name>  only use <name> backend\n    -B <name>  add additional backend <name>\n    -a         match files and directories\n    -d         match directories only\n    -f         match files only\n    -r         match by rank only\n    -t         match by recent access only\n    -R         reverse listing order\n    -h         show a brief help message\n    -[0-9]     select the nth entry\n\n# DESCRIPTION\n\nFasd keeps track of files and directories you access in your shell and gives you\nquick access to them. You can use fasd to reference files or directories by just\na few key identifying characters. You can use fasd to boost your command line\nproductivity by defining your own aliases to launch programs on files or\ndirectories. Fasd, by default, provides some basic aliases, including a shell\nfunction \"z\" that resembles the functionality of \"z\" and \"autojump.\"\n\nThe name \"fasd\" comes from the default suggested aliases `f`(files),\n`a`(files/directories), `s`(show/search/select), `d`(directories).\n\nFasd ranks files and directories by \"frecency,\" that is, by both \"frequency\"\nand \"recency.\" The term \"frecency\" was first coined by Mozilla and used in\nFirefox.\n\n# EXAMPLES\n\n    z bundle\n    f -e vim nginx conf\n    f -i rc$\n    vi `f nginx conf`\n    cp update.html `d www`\n    open `sf pdf`\n\n# SHELL INITIALIZATION\n\nTo get fasd working in a shell, some initialization code must be run. Put\nlines below in your POSIX compatible shell rc.\n\n    eval \"$(fasd --init auto)\"\n\nThis will setup a command hook that executes on every command and advanced tab\ncompletion for zsh and bash.\n\nIf you want more control over what gets into your shell environment, you can\npass customized set of arguments to `fasd --init`.\n\n    zsh-hook             # define _fasd_preexec and add it to zsh preexec array\n    zsh-ccomp            # zsh command mode completion definitions\n    zsh-ccomp-install    # setup command mode completion for zsh\n    zsh-wcomp            # zsh word mode completion definitions\n    zsh-wcomp-install    # setup word mode completion for zsh\n    bash-hook            # add hook code to bash $PROMPT_COMMAND\n    bash-ccomp           # bash command mode completion definitions\n    bash-ccomp-install   # setup command mode completion for bash\n    posix-alias          # define aliases that applies to all posix shells\n    posix-hook           # setup $PS1 hook for shells that's posix compatible\n    tcsh-alias           # define aliases for tcsh\n    tcsh-hook            # setup tcsh precmd alias\n\nExample for a minimal zsh setup (no tab completion):\n\n    eval \"$(fasd --init posix-alias zsh-hook)\"\n\nNote that this method will slightly increase your shell start-up time, since\ncalling binaries has overhead. You can cache fasd init code if you want\nminimal overhead. Example code for bash (to be put into .bashrc):\n\n    fasd_cache=\"$HOME/.fasd-init-bash\"\n    if [ \"$(command -v fasd)\" -nt \"$fasd_cache\" -o ! -s \"$fasd_cache\" ]; then\n      fasd --init posix-alias bash-hook bash-ccomp bash-ccomp-install >| \"$fasd_cache\"\n    fi\n    source \"$fasd_cache\"\n    unset fasd_cache\n\nOptionally, if you can also source `fasd` if you want `fasd` to be a shell\nfunction instead of an executable.\n\nYou can tweak initialization code. For instance, if you want to use \"c\"\ninstead of \"z\" to do directory jumping, you can use the alias below:\n\n    alias c='fasd_cd -d'\n    # `-d' option present for bash completion\n    # function fasd_cd is defined in posix-alias\n\n# MATCHING\n\nFasd has three matching modes: default, case-insensitive, and fuzzy.\n\nFor a given set of queries (the set of command-line arguments passed to fasd),\na path is a match if and only if:\n\n1. Queries match the path in order.\n2. The last query matches the last segment of the path.\n\nIf no match is found, fasd will try the same process ignoring case. If still no\nmatch is found, fasd will allow extra characters to be placed between query\ncharacters for fuzzy matching.\n\nTips:\n\n* If you want your last query not to match the last segment of the path, append\n  `/' as the last query.\n* If you want your last query to match the end of the filename, append `$' to\n  the last query.\n\n# COMPATIBILITY\n\nFasd's basic functionalities are POSIX compliant, meaning that you should be\nable to use fasd in all POSIX compliant shells. Your shell need to support\ncommand substitution in $PS1 in order for fasd to automatically track your\ncommands and files. This feature is not specified by the POSIX standard, but\nit's nonetheless present in many POSIX compliant shells. In shells without\nprompt command or prompt command substitution (tcsh for instance), you can add\nentries manually with \"fasd -A\". You are very welcomed to contribute shell\ninitialization code for not yet supported shells.\n\n# TAB COMPLETION\n\nFasd offers two completion modes, command mode completion and word mode\ncompletion. Command mode completion works in bash and zsh. Word mode\ncompletion only works in zsh.\n\nCommand mode completion is just like completion for any other commands. It is\ntriggered when you hit tab on a fasd command or its aliases. Under this mode\nyour queries can be separated by a space. Tip: if you find that the completion\nresult overwrites your queries, type an extra space before you hit tab.\n\nWord mode completion can be triggered on *any* command. Word completion is\ntriggered by any command line argument that starts with \",\" (all), \"f,\"\n(files), or \"d,\" (directories), or that ends with \",,\" (all), \",,f\" (files),\nor \",,d\" (directories). Examples:\n\n    $ vim ,rc,lo<Tab>\n    $ vim /etc/rc.local\n\n    $ mv index.html d,www<Tab>\n    $ mv index.html /var/www/\n\nThere are also three zle widgets: \"fasd-complete\", \"fasd-complete-f\",\n\"fasd-complete-d\". You can bind them to keybindings you like:\n\n    bindkey '^X^A' fasd-complete    # C-x C-a to do fasd-complete (files and directories)\n    bindkey '^X^F' fasd-complete-f  # C-x C-f to do fasd-complete-f (only files)\n    bindkey '^X^D' fasd-complete-d  # C-x C-d to do fasd-complete-d (only directories)\n\n# BACKENDS\n\nFasd can take advantage of different sources of recent / frequent files. Most\ndesktop environments (such as OS X and Gtk) and some editors (such as Vim) keep\na list of accessed files. Fasd can use them as additional backends if the data\ncan be converted into fasd's native format. Below is a list of available\nbackends.\n\n* spotlight: OSX spotlight, provides entries that are changed today or opened\n  within the past month\n\n* recently-used: GTK's recently-used file (Usually available on Linux)\n\n* current: Provides everything in $PWD (whereever you are executing `fasd`)\n\n* viminfo: Vim's editing history, useful if you want to define an alias just\n  for editing things in vim\n\nYou can define your own backend by declaring a function by that name in your\n`.fasdrc`. You can set default backend with `_FASD_BACKENDS` variable in our\n`.fasdrc`.\n\n# TWEAKS\n\nUpon every execution, fasd will source \"/etc/fasdrc\" and \"$HOME/.fasdrc\" if\nthey are present. Below are some variables you can set:\n\n    $_FASD_DATA\n    Path to the fasd data file, default \"$HOME/.fasd\".\n\n    $_FASD_BLACKLIST\n    List of blacklisted strings. Commands matching them will not be processed.\n    Default is \"--help\".\n\n    $_FASD_SHIFT\n    List of all commands that needs to be shifted, defaults to \"sudo busybox\".\n\n    $_FASD_IGNORE\n    List of all commands that will be ignored, defaults to \"fasd ls echo\".\n\n    $_FASD_TRACK_PWD\n    Fasd defaults to track your \"$PWD\". Set this to 0 to disable this behavior.\n\n    $_FASD_AWK\n    Which awk to use. fasd can detect and use a compatible awk.\n\n    $_FASD_SINK\n    File to log all STDERR to, defaults to \"/dev/null\".\n\n    $_FASD_MAX\n    Max total score / weight, defaults to 2000.\n\n    $_FASD_SHELL\n    Which shell to execute. Some shells will run faster than others. fasd\n    runs faster with dash and ksh variants.\n\n    $_FASD_BACKENDS\n    Default backends.\n\n    $_FASD_RO\n    If set to any non-empty string, fasd will not add or delete entries from\n    database. You can set and export this variable from command line.\n\n    $_FASD_FUZZY\n    Level of \"fuzziness\" when doing fuzzy matching. More precisely, the number of\n    characters that can be skipped to generate a match. Set to empty or 0 to\n    disable fuzzy matching. Default value is 2.\n\n    $_FASD_VIMINFO\n    Path to .viminfo file for viminfo backend, defaults to \"$HOME/.viminfo\"\n\n    $_FASD_RECENTLY_USED_XBEL\n    Path to XDG recently-used.xbel file for recently-used backend, defaults to\n    \"$HOME/.local/share/recently-used.xbel\"\n\n# DEBUGGING\n\nFasd is hosted on GitHub: https://github.com/clvv/fasd\n\nIf fasd does not work as expected, please file a bug report on GitHub describing\nthe unexpected behavior along with your OS version, shell version, awk version,\nsed version, and a log file.\n\nYou can set `_FASD_SINK` in your `.fasdrc` to obtain a log.\n\n    _FASD_SINK=\"$HOME/.fasd.log\"\n\n# COPYING\n\nFasd is originally written based on code from z (https://github.com/rupa/z) by\nrupa deadwyler under the WTFPL license. Most if not all of the code has been\nrewritten. Fasd is licensed under the \"MIT/X11\" license.\n\n"
        }
      ]
    }
  ]
}