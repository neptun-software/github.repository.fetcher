{
  "metadata": {
    "timestamp": 1736568853473,
    "page": 42,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "testssl/testssl.sh",
      "stars": 8096,
      "defaultBranch": "3.2",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.193359375,
          "content": "# Exclude everything from the Docker build context:\n*\n\n# Except for this content:\n!bin/\n!etc/\n!testssl.sh\n\n# But additionally exclude this nested content:\nbin/openssl.Darwin.*\nbin/openssl.FreeBSD.*\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.095703125,
          "content": "root = true\n\n[*]\nindent_style = space\n\n[*.md]\nindent_size = 2\n\n[*.{t,pl,sh,bash}]\nindent_size = 5\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1708984375,
          "content": "*.sh    eol=lf\n*.bash  eol=lf\n*.md    eol=lf\n*.html  eol=lf\n*.txt   eol=lf\n*.txt   eol=lf\n*.1     eol=lf\n*.t     eol=lf\n*.yml   eol=lf\nDockerfile*  eol=lf\n*.csvfile    eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.240234375,
          "content": ".DS_Store\n._.DS_Store\ntmp.json\ntmp.html\n*_p*-????????-????.html\n*.bak\n*.json\n*.csv\n*.log\n*.xml\n*.iml\n*.script\n*.swp\n*.swo\n*~\n*.orig\n*.org\n.directory\n.idea/\n*.tar.*\n*.patch\n*.diff\n*.rej\n*.asc\n*.crt\n*.pem\n*.der\n*.csr\n*.p12\nthumbs.db\ntodo.md\n2do.md\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 19.7021484375,
          "content": "\n## Change Log\n\n### Features implemented / improvements in 3.2\n\n* Rating (SSL Labs, not complete)\n* Extend Server (cipher) preference: always now in wide mode instead of running all ciphers in the end (per default)\n* Remove \"negotiated cipher / protocol\"\n* Provide a better verdict wrt to server order: Now per protocol and ciphers are weighted for each protocol\n* Switched to multi-stage docker image with opensuse base to avoid musl libc issues, performance gain also\n* Improved compatibility with OpenSSL 3.0\n* Improved compatibility with Open/LibreSSL versions not supporting TLS 1.0-1.1 anymore\n* Renamed PFS/perfect forward secrecy --> FS/forward secrecy\n* Cipher list straightening\n* Improved mass testing\n* Better align colors of ciphers with standard cipherlists\n* Save a few cycles for ROBOT\n* Several ciphers more colorized\n* Percent output char problem fixed\n* Several display/output fixes\n* BREACH check: list all compression methods and add brotli\n* Test for old winshock vulnerability\n* Test for STARTTLS injection vulnerabilities (SMTP, POP3, IMAP)\n* STARTTLS: XMPP server support, plus new set of OpenSSL-bad binaries\n* Several code improvements to STARTTLS, also better detection when no STARTTLS is offered\n* STARTTLS on active directory service support\n* Security fixes: DNS and other input from servers\n* Don't penalize missing trust in rating when CA not in Java store\n* Added support for certificates with EdDSA signatures and public keys\n* Extract CA list shows supported certification authorities sent by the server\n* TLS 1.2 and TLS 1.3 sig algs added\n* Check for ffdhe groups\n* Show server supported signature algorithms\n* --add-ca can also now be a directory with \\*.pem files\n* Warning of 398 day limit for certificates issued after 2020/9/1\n* Added environment variable for amount of attempts for ssl renegotiation check\n* Added --user-agent argument to support using a custom User Agent\n* Added --overwrite argument to support overwriting output files without warning\n* Headerflag X-XSS-Protection is now labeled as INFO\n* Strict parser for HSTS\n* DNS via proxy improvements\n* Client simulation runs in wide mode which is even better readable\n* Added --reqheader to support custom headers in HTTP requests\n* Test for support for RFC 8879 certificate compression\n* Deprecating --fast and --ssl-native (warning but still av)\n* Compatible to GNU grep 3.8\n* Don't use external pwd command anymore\n* Doesn't hang anymore when there's no local resolver\n* Added --mtls feature to support client authentication\n* If a TLS 1.3 host is tested and e.g. /usr/bin/openssl supports it, it'll automagically will switch to it\n\n\n### Features implemented / improvements in 3.0\n\n* Full support of TLS 1.3, shows also drafts supported\n* Extended protocol downgrade checks\n* ROBOT check\n* Better TLS extension support\n* Better OpenSSL 1.1.1 and higher versions support as well as LibreSSL >3\n* More robustness for OpenBSD\n* DNS over Proxy and other proxy improvements\n* Decoding of unencrypted BIG IP cookies\n* Initial client certificate support\n* Warning of 825 day limit for certificates issued after 2018/3/1\n* Socket timeouts (``--connect-timeout``)\n* IDN/IDN2 servername/URI + emoji support, supposed libidn/idn2 is installed and DNS resolver is recent) support\n* Initial support for certificate compression\n* Better JSON output: renamed IDs and findings shorter/better parsable, also includes certificate\n* JSON output now valid also for non-responding servers\n* Testing now per default 370 ciphers\n* Further improving the robustness of TLS sockets (sending and parsing)\n* Support of supplying timeout value for `openssl connect` -- useful for batch/mass scanning\n* File input for serial or parallel mass testing can be also in nmap grep(p)able (-oG) format\n* LOGJAM: now checking also for DH  and FFDHE groups (TLS 1.2)\n* PFS: Display of elliptical curves supported, DH and FFDHE groups (TLS 1.2 + TLS 1.3)\n* Check for session resumption (Ticket, ID)\n* TLS Robustness check GREASE and more\n* Server preference distinguishes between TLS 1.3 and lower protocols\n* Mark TLS 1.0 and TLS 1.1 as deprecated\n* Does a few startup checks which make later tests easier and faster (``determine_optimal_\\*()``)\n* Expect-CT Header Detection\n* `--phone-out` does certificate revocation checks via OCSP (LDAP+HTTP) and with CRL\n* `--phone-out` checks whether the private key has been compromised via https://pwnedkeys.com/\n* Missing SAN warning\n* Added support for private CAs\n* Way better handling of connectivity problems (counting those, if threshold exceeded -> bye)\n* Fixed TCP fragmentation\n* Added `--ids-friendly` switch\n* Exit codes better: 0 for running without error, 1+n for small errors, >240 for major errors.\n* Better error msg suppression (not fully installed OpenSSL)\n* Better parsing of HTTP headers & better output of longer HTTP headers\n* Display more HTTP security headers\n* HTTP Basic Auth support for HTTP header\n* experimental \"eTLS\" detection\n* Dockerfile and repo @ docker hub with that file (see above)\n* Java Root CA store added\n* Better support for XMPP via STARTTLS & faster\n* Certificate check for to-name in stream of XMPP\n* Support for NNTP and LMTP via STARTTLS, fixes for MySQL and PostgresQL\n* Support for SNI and STARTTLS\n* More robustness for any STARTTLS protocol (fall back to plaintext while in TLS caused problems)\n* Renegotiation checks improved, also no false positive for Node.js anymore\n* Major update of client simulations with self-collected up-to-date data\n* Update of CA certificate stores\n* Lots of bug fixes\n* More travis/CI checks -- still place for improvements\n* Man page reviewed\n\n### Features implemented / improvements in 2.9.5\n\n* Way better coverage of ciphers as most checks are done via bash sockets where ever possible\n* Further tests via TLS sockets and improvements (handshake parsing, completeness, robustness)\n* Testing 359 default ciphers (``testssl.sh -e/-E``) with a mixture of sockets and openssl. Same speed as with openssl only but additional ciphers such as post-quantum ciphers, new CHAHA20/POLY1305, CamelliaGCM etc.\n* TLS 1.2 protocol check via sockets in production\n* Finding more TLS extensions via sockets\n* TLS Supported Groups Registry (RFC 7919), key shares extension\n* Non-flat JSON output support\n* File output (CSV, JSON flat, JSON non-flat) supports a minimum severity level (only above supplied level there will be output)\n* Native HTML support instead going through 'aha'\n* LUCKY13 and SWEET32 checks\n* Ticketbleed check\n* LOGJAM: now checking also for known DH parameters\n* Support of supplying timeout value for ``openssl connect`` -- useful for batch/mass scanning\n* Parallel mass testing\n* Check for CAA RR\n* Check for OCSP must staple\n* Check for Certificate Transparency\n* Check for session resumption (Ticket, ID)\n* Better formatting of output (indentation)\n* Choice showing the RFC naming scheme only\n* File input for mass testing can be also in nmap grep(p)able (-oG) format\n* Postgres und MySQL STARTTLS support\n* Man page\n\n### New in 2.8\n\n* Trust chain check against certificate stores from Apple (OS), Linux (OS),\n  Microsoft (OS), Mozilla (Firefox Browser), works for openssl >=1.0.1\n* IPv6 (status: 80% working, details see\n  https://github.com/testssl/testssl.sh/issues/11\n* works now on servers requiring a x509 certificate for authentication\n* extensive CN <--> hostname check\n* SSL Session ID check\n* Avahi/mDNS based name resolution\n* HTTP2/ALPN protocol check\n* Logging to a file / dir\n* Logging to (flat) JSON + CSV\n* HPKP checks now also for Root, intermediate SPKIs\n* Check for multiple server certificates\n* Browser cipher simulation: what client will connect with which cipher + protocol\n* GOST cipher+certificate improvements\n* Assistance for color-blind users\n* Even more compatibility improvements for FreeBSD, NetBSD, Gentoo, RH-ish, F5 and Cisco systems\n* Considerable speed improvements for each cipher runs (-e/-E)\n* More robust SSLv2 + TLS socket interface\n* separate check for curves\n* OpenSSL 1.1.0 compliant\n* check for DROWN\n* Whole number of bugs squashed\n\n### New in 2.6\n\n  * Display matching host key (HPKP)\n  * LOGJAM 1: check DHE_EXPORT cipher\n  * LOGJAM 2: displays DH(/ECDH) bits in wide mode on negotiated ciphers\n  * \"wide mode\" option for checks like RC4, BEAST. PFS. Displays hexcode, kx, strength, DH bits, RFC name\n  * binary directory provides out of the box better binaries (Linux 32+64 Bit, Darwin 64 bit, FreeBSD 64 bit)\n  * OS X binaries (@jvehent, new builds: @jpluimers)\n  * ARM binary (@f-s)\n  * FreeBSD binary\n  * TLS_FALLBACK_SCSV check -- thx @JonnyHightower\n  * (HTTP) proxy support! Also with sockets -- thx @jnewbigin\n  * Extended validation certificate detection\n  * Run in default mode through all ciphers at the end of a default run\n  * will test multiple IP addresses of one supplied server name in one shot, --ip= restricts it accordingly\n  * new mass testing file option --file option where testssl.sh commands are being read from, see https://twitter.com/drwetter/status/627619848344989696\n  * TLS time and HTTP time stamps\n  * TLS time displayed also for STARTTLS protocols\n  * support of sockets for STARTTLS protocols\n  * TLS 1.0-1.1 as socket checks per default in production\n  * further detection of security relevant headers (reverse proxy, IPv4 addresses), proprietary banners (OWA, Liferay etc.)\n  * can scan STARTTLS+XMPP by also supplying the XMPP domain (to-option in XML streams).\n  * quite some LibreSSL fixes, still not recommended to use though (see https://testssl.sh/)\n  * lots of fixes, code improvements, even more robust\n\nFull log @ https://github.com/testssl/testssl.sh/commits/2.6/testssl.sh\n\n### New in 2.4\n  * \"only one cmd line option at a time\" is completely gone\n  * several tuning parameters on the cmd line (only available through environment variables b4): --assuming-http, --ssl-native, --sneaky, --warnings, --color, -- debug, --long\n  * certificate information\n  * more HTTP header infos (cookies+security headers)\n  * protocol check via bash sockets for SSLv2+v3\n  * debug handling significantly improved (verbosity/each function leaves files in $TEMPDIR)\n  * BEAST check\n  * FREAK check\n  * check for Secure Client-Initiated Renegotiation\n  * lots of cosmetic and maintainability code cleanups\n  * bugfixing\n\nFull changelog: https://github.com/testssl/testssl.sh/commits/2.4/testssl.sh\n\n### 2.2. new features:\n  * Works fully under FreeBSD (openssl >=1.0)\n  * single cipher check (-x) with pattern of hexcode/cipher\n  * check for POODLE SSL\n  * HPKP check\n  * OCSP stapling\n  * GOST and CHACHA20 POLY1305 cipher support\n  * service detection (HTTP, IMAP, POP, SMTP)\n  * runs now with all colors, b/w screen, no escape codes at all\n  * protocol check better\n  * job control removes stalling\n  * RFC <---> OpenSSL name space mapping of ciphers everywhere\n  * includes a lot of fixes\n\nFull changelog @  https://github.com/testssl/testssl.sh/commits/2.2/testssl.sh\n\n### 2.0 major release, new features:\n  * SNI\n  * STARTTLS fully supported\n  * RC4 check\n  * (P)FS check\n  * SPDY check\n  * color codes make more sense now\n  * cipher hexcodes are shown\n  * tests ciphers per protocol\n  * HSTS\n  * web and application server banner\n  * server preferences\n  * TLS server extensions\n  * server key size\n  * cipher suite mapping from openssl to RFC\n  * heartbleed check\n  * CCS injection check\n\n### Historical releases\n\n1.112\n- IPv6 display fix\n\n1.111\n- NEW: tested under FreeBSD (works with exception of xxd in CCS)\n- getent now works under Linux and FreeBSD\n- sed -i in hsts sacrificed for compatibility\n- removed query for IP for finishing banner, is now called once in parse_hn_port\n- GOST warning after banner\n- empty build date is not displayed anymore\n- long build date strings minimized\n- FIXED: IPv6 address are displayed again\n\n1.110\n- NEW: adding Russian GOST cipher support by providing a config file on the fly\n- adding the compile date of openssl in the banner\n\n1.109\n- minor IPv6 fixes\n\n1.108\n- NEW: Major rewrite of output functions. Now using printf instead of \"echo -e\" for BSD and MacOSX compatibility\n\n1.107\n- improved IP address stuff\n\n1.106\n- minor fixes\n\n1.105\n- NEW: working prototype for CCS injection\n\n1.104\n- NEW: everywhere *also* RFC style ciphers -- if the mapping file is found\n- unitary calls to display cipher suites\n\n1.103\n- NEW: telnet support for STARTTLS (works only with a patched openssl version)\n  --> not tested (lack of server)\n\n1.102\n- NEW: test for BREACH (experimental)\n\n.101\n- BUGFIX: muted too verbose output of which on CentOS/RHEL\n- BUGFIX: muted too verbose output of netcat/nc on CentOS/RHEL+Debian\n\n1.100\n- further cleanup\n  - starttls now tests allciphers() instead of cipher_per_proto\n      (normal use case makes most sense here)\n  - ENV J_POSITIV --> SHOW_EACH_C\n- finding mapping-rfc.txt is now a bit smarter\n- preparations for ChaCha20-Poly1305 (would have provided binaries but\n  \"openssl s_client -connect\" with that ciphersuite fails currently with\n  a handshake error though client and server hello succeeded!)\n\n1.99\n- BUGFIX: now really really everywhere testing the IP with supplied name\n- locking out openssl < 0.9.8f, new function called \"old_fart\" ;-)\n- FEATURE: displaying PTR record of IP\n- FEATURE: displaying further IPv4/IPv6 addresses\n- bit of a cleanup\n\n1.98\n- http_header is in total only called once\n- better parsing of default protocol (FIXME shouldn't appear anymore)\n\n1.97\n- reduced sleep time for server hello and payload reply (heartbleed)\n\n1.96\n- NEW: (experimental) heartbleed support with bash sockets (shell only SSL handshake!)\n  see also https://testssl.sh/bash-heartbleed.sh\n\n1.95 (2.0rc3)\n- changed cmdline options for CRIME and renego vuln to uppercase\n- NEW: displays server key size now\n- NEW: displays TLS server extensions (might kill old openssl versions)\n- brown warning if HSTS < 180 days\n- brown warning if SSLv3 is offered as default protocol\n\n1.94\n- NEW: prototype of mapping to RFC cipher suite names, needed file mapping-rfc.txt in same dir\n  as of now only used for 'testssl.sh -V'\n- internal renaming: it was supposed to be \"cipherlists\" instead of \"ciphersuites\"\n- additional tests for cipherlists DES, 3DES, ADH\n\n1.93\n- BUGFIX: removed space in Server banner fixed (at the expense of showing just nothing if Server string is empty)\n\n1.92\n- BUGFIX: fixed error of faulty detected empty server string\n\n1.91\n- replaced most lcyan to brown (=not really bad but somehow)\n- empty server string better displayed\n- preferred CBC TLS 1.2 cipher is now brown (lucky13)\n\n1.90\n- fix for netweaver banner (server is lowercase)\n- no server banner is no disadvantage (color code)\n\n1.89\n- reordered! : protocols + cipher come first\n- colorized preferred server preference (e.g. CBC+RC4 is light red now, TLSv1.2 green)\n- SSLv3 is now light cyan\n- NEW: -P|--preference now in help menu\n- light cyan is more appropriate than red for HSTS\n\n1.88\n- NEW: prototype for protocol and cipher preference\n- prototype for session ticket\n\n1.87\n- changed just the version string to rc1\n\n1.86\n - NEW: App banner now production, except 2 liners\n - DEBUG: 1 is now true as everywhere else\n - CRIME+Renego prettier\n - last optical polish for RC4, PFS\n\n1.85\n - NEW: appbanner (also 2 lines like asp.net)\n - OSSL_VER_MAJOR/MINOR/APPENDIX\n - less bold because bold headlines as bold should be reserved for emphasize findings\n - tabbed output also for protocols and cipher classes\n - unify neat printing\n\n1.84\n - NEW: deprecating openssl version <0.98\n - displaying a warning >= 0.98 < 1.0\n - NEW: neat print also for all ciphers (-E,-e)\n\n1.83\n- BUGFIX: results from unit test: logical error in PFS+RC4 fixed\n- headline of -V / PFS+RC4 ciphers unified\n\n1.82\n- NEW: output for -V now better (bits separate, spacing improved)\n\n1.81\n- output for RC4+PFS now better (with headline, bits separate, spacing improved)\n- both also sorted by encr. strength .. umm ..err bits!\n\n1.80\n- order of finding supplied binary extended (first one wins):\n  1. use supplied variable $OPENSSL\n  2. use \"openssl\" in same path as testssl.sh\n  3. use \"openssl.`uname -m`\" in same path as testssl.sh\n  4. use anything in system $PATH (return value of \"which\"\n\n1.79\n- STARTTLS options w/o trailing 's' now (easier)\n- commented code for CRIME SPDY\n- issue a warning for openssl < 0.9.7 ( that version won't work anyway probably)\n\n1.78\n- -E, -e now sorted by encryption strength (note: it's only encr key length)\n- -V now pretty prints all local ciphers\n- -V <pattern> now pretty prints all local ciphers matching pattern (plain string, no regex)\n- bugfix: SSLv2 cipher hex codes has 3 bytes!\n\n1.77\n- removed legacy code (PROD_REL var)\n\n1.76\n- bash was gone!! disaster for Ubuntu, fixed\n- starttls+rc4 check: bottom line was wrong\n- starttls had too much output (certificate) at first a/v check\n\n1.75\n- location is now https://testssl.sh\n- be nice: banner, version, help also works for BSD folks (on dash)\n- bug in server banner fixed\n- sneaky referer and user agent possible\n\n1.74\n- Debian 7 fix\n- ident obsoleted\n\n1.72\n- removed obsolete GREP\n- SWURL/SWCONTACT\n- output for positive RC4 better\n\n1.71\n- workaround for buggy bash (RC4)\n- colors improved\n  - blue is now reserved for headline\n  - magenta for local probs\n  - in RC4 removal of SSL protocol provided by openssl\n\n1.70\n- DEBUG in http_headers now as expected\n- <?xml marker as HTML body understood\n\n1.69\n- HTTP 1.1 header\n- removed in each cipher the proto openssl is returning\n+ NEW: cipher_per_proto\n\n1.68\n- header parser for openssl\n- HSTS\n\n[..]\n\n1.36\n* fixed issue while connecting to non-webservers\n\n1.35\n* fixed portability issue on Ubuntu\n\n1.34\n* ip(v4) address in output, helps to tell different systems apart later on\n* local hostname in output\n\n1.31 (Halloween Release)\n* bugfix: SSLv2 was kind of borken\n* now it works for sure but ssl protocol are kind of ugly\n\n1.30b (25.10.2012)\n* bugfix: TLS 1.1/1.2 may lead to false negatives\n* bugfix: CMDLINE -a/-e was misleading, now similar to help menu\n\n1.3 (10/13/2012)\n* can test now for cipher suites only\n* can test now for protocols suites only\n* tests for tls v1.1/v1.2 of local openssl supports it\n* commandline \"all \"is rename to \"each-cipher\"\n* banner when it's done\n\n1.21a (10/4/2012)\n* tests whether openssl has support for zlib compiled so that it avoids a false negative\n\n1.21 (10/4/2012)\n* CRIME support\n\n1.20b\n* bugfixed release\n\n1.20a\n* code cleanup\n* showciphers variable introduced: only show ciphers if this is set (it is by\n  default now and there's a comment\n* openssl version + path to it in the banner\n\n1.20\n* bugfix (ssl in ssl handshake failure is sometimes too much)\n* date in output\n* autodetection of CVS version removed\n\n1.19\n* bugfix\n1.18\n* Rearrangement of arguments: URL comes now always last!\n* small code cleanups for readability\n* individual cipher test is now with bold headline, not blue\n* NOPARANOID flag tells whether medium grade ciphers are ok. NOW they are (=<1.17 was paranoid)\n\n1.17\n* SSL tests now for renegotiation vulnerability!\n* version detection of testssl.sh\n* program has a banner\n* fixed bug leading to a file named \"1\"\n* comment for 128Bit ciphers\n\n1.16\n* major code cleanups\n* cmd line options: port is now in first argument!!\n* help is more verbose\n* check whether on other server side is ssl server listening\n* https:// can be now supplied also on the command line\n* test all ciphers now\n* new cleanup routine\n* -a does not do standard test afterward, you need to run testssl a second\n  time w/o -a if you want this\n\n1.12\n* tests also medium grade ciphers (which you should NOT use)\n* tests now also high grade ciphers which you SHOULD ONLY use\n* switch for more verbose output of cipher for those cryptographically interested .\n  in rows: SSL version, Key eXchange, Authentication, Encryption and Message Authentication Code\n* this is per default enabled (provide otherwise \"\" as VERB_CLIST)\n* as a courtesy I am providing 64+32 Linux binaries for testing 56 Bit ciphers\n\n1.11\n* Hint for howto enable 56 Bit ciphers for testing\n* possible to specify where openssl is (hardcoded, $ENV, last resort: auto)\n* warns if netcat is not there\n\n1.10\n* somewhat first released version\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.2548828125,
          "content": "\n### Contributions / participation\n\nis always welcome, here @ github or via e-mail.\n\nNote please the following\n\n* Please read at least the [coding convention](https://github.com/testssl/testssl.sh/Coding_Convention.md).\n* One PR per feature or bug fix or improvement. Please do not mix issues.\n* Document your PR, both in the PR and/or commit message and in the code.\n* Please test your changes thoroughly as reliability is important for this project. You may want to check different servers with different settings.\n* Travis runs automatically when anything is committed/PR'd. You should check any complains from Travis. Beforehand you can check with `prove -v`.\n* If it's a new feature please consider writing a unit test for it. You can use e.g. `t/20_baseline_ipv4_http.t` as a template. The general documentation for [Test::More](https://perldoc.perl.org/Test/More.html) is a good start.\n* If it's a new feature it would need to be documented in the appropriate section in `help()` and in `~/doc/testssl.1.md`\n\nFor questions just open an issue or feel free to send me an e-mail.\n\n#### Patches via e-mail\n\nOf course it is fine when you want to send in patches to use e-mail. For the address please grep for SWCONTACT in testssl.sh .\nLet me know how you like them to be attributed.\n"
        },
        {
          "name": "CREDITS.md",
          "type": "blob",
          "size": 4.8642578125,
          "content": "\nFull contribution, see git log.\n\n* Dirk Wetter (creator, maintainer and main contributor)\n  - Everything what's not mentioned below and is included in testssl.sh's git log\n    minus what I probably forgot to mention\n  (too much other things to do at the moment and to list it would be a tough job)\n\n* David Cooper (main contributor)\n  - Major extensions to socket support for all protocols\n  - extended parsing of TLS ServerHello messages\n  - TLS 1.3 support (final and pre-final) with needed en/decryption\n  - add several TLS extensions\n  - Detection + output of multiple certificates\n  - several cleanups of server certificate related stuff\n  - testssl.sh -e/-E: testing with a mixture of openssl + sockets\n  - add more ciphers\n  - coloring of ciphers\n  - extensive CN+SAN <--> hostname check\n  - separate check for curves\n  - RFC 7919, key shares extension\n  - keyUsage extension in certificate\n  - experimental \"eTLS\" detection\n  - parallel mass testing!\n  - RFC <--> OpenSSL cipher name space switches for the command line\n  - better error msg suppression (not fully installed openssl)\n  - GREASE support\n  - Bleichenbacher / ROBOT vulnerability test\n  - several protocol preferences improvements\n  - pwnedkeys.com support\n  - CT support\n  - Extract CA list CertificateRequest message is encountered\n  - RFC 8879, certificate compression\n  - 128 cipher limit, padding\n  - compatibility for LibreSSL and different OpenSSL versions\n  - Check for ffdhe groups\n  - TLS 1.2 and TLS 1.3 sig algs added\n  - Show server supported signature algorithms\n  - Show supported certification authorities sent by the server when client auth is requested\n  - Provide a better verdict wrt to server order: Now per protocol and ciphers are weighted for each protocol\n -  Provide compatibility to every LibreSSL/OpenSSL versions\n  - Lots of fixes and improvements\n\n##### Further credits (in alphabetical order)\n\n* a666\n  - Bugfix\n\n* Christoph Badura\n  - NetBSD fixes\n\n* Jim Blankendaal\n  - maximum certificate lifespan of 398 days\n  - ssl renegotiation amount variable\n  - custom http request headers\n\n* Frank Breedijk\n  - Detection of insecure redirects\n  - JSON and CSV output\n  - CA pinning\n  - Client simulations\n  - CI integration, some test cases for it\n\n* Steven Danneman\n  - Postgres and MySQL STARTTLS support\n  - MongoDB support\n\n* Christian Dresen\n   - Dockerfile\n\n* csett86\n   - some MacOSX and Java client handshake data\n\n* Mark Felder\n  - lots of cleanups\n  - Shellcheck static analysis\n\n* Laine Gholson\n  - avahi/mDNS support\n  - HTTP2/ALPN\n  - bugfixes\n  - former ARM binary support\n\n* Maciej Grela\n  - colorless handling\n\n* Jac2NL\n  - initial support for skipping offensive vulnerability tests\n\n* Scott Johnson\n  - Bugfix F5\n\n* Hubert Kario\n  - helped with avoiding accidental TCP fragmentation\n\n* Brennan Kinney\n  - refactored multistage Dockerfiles: performance gain+address bugs/inconsistencies\n\n* Magnus Larsen\n  - SSL Labs Rating\n\n* Jacco de Leeuw\n  - skip checks which might trigger an IDS ($OFFENSIVE / --ids-friendly)\n\n* Manuel\n  - HTTP basic auth\n\n* Markus Manzke\n  - Fix for HSTS + subdomains\n  - LibreSSL patch\n\n* Jean Marsault\n  - client auth: ideas, code snippets\n\n* Thomas Martens\n  - adding colorblind option\n  - no-rfc mapping\n\n* Peter Mosmans\n  - started way better cmd line parsing\n  - cleanups, fixes\n  - openssl sources support with the \"missing\" features\n\n* John Newbigin\n  - Proxy support (sockets and openssl)\n\n* Oleksandr Nosenko\n  - non-flat JSON support (--json-pretty)\n  - in file output (CSV, JSON flat, JSON non-flat) support of a minimum severity level\n\n* Jonathan Roach\n  - TLS_FALLBACK_SCSV checks\n\n* Jonathon Rossi\n  - fix for bash3 (Darwin)\n  - and other Darwin fixes\n\n* Дилян Палаузов\n  - bug fix for 3des report\n  - reported a tricky STARTTLS bug\n\n* Thomas Patzke:\n  - Support of supplying timeout value for openssl connect\n\n* Olivier Paroz\n  - conversion xxd --> hexdump stuff\n\n* Jeroen Wiert Pluimers\n  - Darwin binaries support\n\n* Joao Poupino\n  - Minimize false positive detection for Renegotiation checks against Node.js etc.\n\n* Rechi\n  - initial MX stuff\n  - fixes\n\n* Gonçalo Ribeiro\n  - --connect-timeout\n\n* Dmitri S\n  - inspiration & help for Darwin port\n\n* Jonas Schäfer\n  - XMPP server patch\n\n* Maurizio Siddu\n  - added --mTLS feature\n\n* Marcin Szychowski\n  - Quick'n'dirty client certificate support\n\n* Viktor Szépe\n  - color function maker\n\n* Julien Vehent\n  - supplied 1st Darwin binary\n\n* Thomas Ward\n  - add initial IDN support\n\n* @typingArtist\n  - improved BEAST detection\n\n* @f-s\n  - ARM binary support\n\n* @nvsofts (NV)\n  - LibreSSL patch for GOST\n\n* @w4ntun\n  - fixed DNS via proxy\n\nProbably more I forgot to mention which did give me feedback, bug reports and helped one way or another.\n\n\n##### Last but not least:\n\n* OpenSSL team for providing openssl.\n\n* Ivan Ristic/Qualys for the liberal license which made it possible to make partly use of the client data\n\n* My family for supporting me doing this work\n"
        },
        {
          "name": "Coding_Convention.md",
          "type": "blob",
          "size": 5.65625,
          "content": "## Coding Style\n\n### PR\n\nYou'd make the life of the maintainers easier if you submit only _one_ patch with _one_ functional change per PR.\n\n### General\n  * Portability is important: Don't use highly system depended binaries (`rpm`, `ip/ifconfig`, ..) as it is not portable. Or it would require lots of efforts (like C's #ifdefs) to be portable plus the code gets ugly.\n  * Don't use additional binaries.\n  * If you really, really need to use an additional binary make sure it's available on the system before calling it. (Example: see `timeout`.)\n  * Keep in mind that binaries might come in different flavors. Especially with ``sed`` you need to be careful as GNU sed is only 80% compatible with BSD sed (`sed -i`,` \\n`, `\\t`, etc.).\n    * Avoid checking for the operating system when using a feature of a binary or an OS. E.g. FreeBSD or MacOSX may or may not have GNU binaries installed, so it's better to check a capability of the binary instead. See how `HAS_*` variables are set.\n\n\n### Documentation\n\nSome people really read that ! New features would need to be documented in the appropriate section in `help()` and in `~/doc/testssl.1.md`.\n\n### Coding\n\n#### Shell / bash\n\nBash is actually quite powerful -- not only with respect to sockets. It's not as mighty as perl or python, but there are a lot of neat features. Here's how you make use of them. Besides those short hints here there's a wealth of information of there. One good resource is the [bash hackers wiki](https://wiki.bash-hackers.org/start).\n\n* Don't use backticks anymore, use `$(..)` instead\n* Use double square `[[]]` brackets (_conditional expressions)_ instead of single square `[]` brackets\n* In double square brackets avoid quoting at the right hand side if not necessary, see [bash hackers wiki](https://wiki.bash-hackers.org/syntax/ccmd/conditional_expression). For regex matching (`=~`) you shouldn't quote at all.\n* The [BashPitfalls](http://mywiki.wooledge.org/BashPitfalls) is a good read!\n* Whenever possible try to avoid `tr` `sed` `awk` and use bash internal functions instead, see e.g. [bash shell parameter substitution](http://www.cyberciti.biz/tips/bash-shell-parameter-substitution-2.html). It slower as it forks, fopens and pipes back the result.\n* `read` often can replace `awk`: `IFS=, read -ra a b c <<< \"$line_with_comma\"`\n* Bash can also deal perfectly with regular expressions, see e.g. [here](https://www.networkworld.com/article/2693361/unix-tip-using-bash-s-regular-expressions.html) and [here](https://unix.stackexchange.com/questions/421460/bash-regex-and-https-regex101-com). You can as well have a look @ `is_ipv4addr()` or `is_ipv6addr()`.\n* If you still need to use any of `tr`, `sed` and `awk`: try to avoid a mix of several external binaries e.g. if you can achieve the same with e.g. `awk`.\n* Be careful with very advanced bash features. Mac OS X is still using bash version 3 ([differences](http://tldp.org/LDP/abs/html/bashver4.html), see also [bash hackers wiki](https://wiki.bash-hackers.org/scripting/bashchanges)).\n* Always use a return value for a function/method. 0 means all is fine.\n* Make use of [shellcheck](https://github.com/koalaman/shellcheck) if possible\n\n\n#### Shell / testssl.sh specific\n* Make use the short functions / methods (code starts from `###### START helper function definitions`) like\n    * `count_words()` / `count_lines()` / `count_ciphers()`\n    * `strip_lf()` / `strip_spaces()`\n    * `toupper()` / `tolower()`\n    * `newline_to_spaces()`\n    * `is_number()` / `is_ipv4addr()`\n    * .. and much more\n* Security:\n    * Watch out for any input especially (but not only) supplied from the server. Input should never be trusted.\n    * Unless you're really sure where the values come from, variables need to be put in quotes.\n    * You can use `safe_echo()` when processing input which does some input validation.\n    * Use ``out()`` or similar output functions when writing something back to the user.\n* Use `$OPENSSL` instead of `openssl`. The latter is highly system depended and also $OPENSSL is a binary which capabilities are checked internally before using it, independent whether the supplied one is being used or another one.\n\n#### Variables\n* Use \"speaking variables\" but don't overdo it with the length\n* No camelCase please. We distinguish between lowercase and uppercase only\n  * Global variables\n    * use them only when really necessary\n    * in CAPS\n    * initialize them\n    * use ``readonly`` and use typing (variable types) if possible\n* Local variables\n    * are lower case\n    * declare them before usage (`local`)\n    * initialize them\n\n### Misc\n\n* If you're implementing a new feature a cmd line switch, there has to be also a global ENV variable which can be used without the switch (see e.g. `SNEAKY`, `ASSUME_HTTP` or `ADDTL_CA_FILES`)\n* Test before doing a PR! Best if you check with two bad and two good examples which should then work as expected. Maybe compare results e.g. with SSLlabs.\n* Unit tests are done automatically done with Perl using Travis. The trigger is `~/.travis.yml`. The general documentation for [Test::More](https://perldoc.perl.org/Test/More.html) is a good start. You are encouraged to write own checks. You can use e.g. `t/20_baseline_ipv4_http.t` as an example.\n* If it's an OpenSSL feature you want to use and it could be not available for older OpenSSL versions testssl.sh needs to find out whether OpenSSL has that feature. Best do this with OpenSSL itself and not by checking the version as some vendors do backports. See the examples for `HAS_SSL2` or proxy option check of OpenSSL in `check_proxy()`.\n* If a feature of OpenSSL is not available you need to tell this the user by using `pr_warning*()`. Or accordingly with `fatal()` if a continuation of the program doesn't make sense anymore.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 2.1298828125,
          "content": "# syntax=docker.io/docker/dockerfile:1\n\nARG LEAP_VERSION=15.6\nARG INSTALL_ROOT=/rootfs\n\nFROM opensuse/leap:${LEAP_VERSION} as builder\nARG CACHE_ZYPPER=/tmp/cache/zypper\nARG INSTALL_ROOT\n\n\n# /etc/os-release provides $VERSION_ID below.\n# We don't need the openh264.repo and the non-oss repos, just costs build time (repo caches).\n# Also we need to remove the util_linux RPM to /really/ make sure busybox-util-linux gets installed.\n# And we need to run zypper update, see all PR #2424.\nRUN source /etc/os-release \\\n  && rm -f /etc/zypp/repos.d/repo-openh264.repo /etc/zypp/repos.d/repo-non-oss.repo \\\n  && export ZYPPER_OPTIONS=( --releasever \"${VERSION_ID}\" --installroot \"${INSTALL_ROOT}\" --cache-dir \"${CACHE_ZYPPER}\" ) \\\n  && zypper \"${ZYPPER_OPTIONS[@]}\" --gpg-auto-import-keys refresh \\\n  && rpm -e util-linux --nodeps \\\n  && zypper \"${ZYPPER_OPTIONS[@]}\" --non-interactive install --download-in-advance --no-recommends \\\n       bash procps grep gawk sed coreutils busybox ldns libidn2-0 socat openssl curl \\\n  && zypper up -y \\\n  && zypper \"${ZYPPER_OPTIONS[@]}\" clean --all\n## Cleanup (reclaim approx 13 MiB):\n# None of this content should be relevant to the container:\nRUN  rm -r \"${INSTALL_ROOT}/usr/share/\"{licenses,man,locale,doc,help,info}\n# Functionality that the container doesn't need:\nRUN  rm    \"${INSTALL_ROOT}/usr/share/misc/termcap\" \\\n  && rm -r \"${INSTALL_ROOT}/usr/lib/sysimage/rpm\"\n\n\n# Create a new image with the contents of $INSTALL_ROOT\nFROM scratch\nARG INSTALL_ROOT\nCOPY --link --from=builder ${INSTALL_ROOT} /\n# Link busybox to tar, see #2403. Create user + (home with SGID set):\nRUN  ln -s /usr/bin/busybox /usr/bin/tar \\\n  && ln -s /usr/bin/busybox /usr/bin/hexdump \\\n  && echo 'testssl:x:1000:1000::/home/testssl:/bin/bash' >> /etc/passwd \\\n  && echo 'testssl:x:1000:' >> /etc/group \\\n  && echo 'testssl:!::0:::::' >> /etc/shadow \\\n  && install --mode 2755 --owner testssl --group testssl --directory /home/testssl \\\n  && ln -s /home/testssl/testssl.sh /usr/local/bin/\n\n# Copy over build context (after filtered by .dockerignore): bin/ etc/ testssl.sh\nCOPY --chown=testssl:testssl . /home/testssl/\nUSER testssl\nENTRYPOINT [\"testssl.sh\"]\nCMD [\"--help\"]\n"
        },
        {
          "name": "Dockerfile.git",
          "type": "blob",
          "size": 0.666015625,
          "content": "# Build using git repo\n\nFROM alpine:3.20\n\nWORKDIR /home/testssl\n\nARG BUILD_VERSION\nARG ARCHIVE_URL=https://github.com/testssl/testssl.sh/archive/\nARG URL=https://github.com/testssl/testssl.sh.git\n\nRUN test -n \"${BUILD_VERSION}\" \\\n    && apk update \\\n    && apk add --no-cache bash procps drill git coreutils libidn curl socat openssl xxd \\\n    && git clone --depth 1 --branch ${BUILD_VERSION} $URL /home/testssl \\\n    && addgroup testssl \\\n    && adduser -G testssl -g \"testssl user\" -s /bin/bash -D testssl \\\n    && ln -s /home/testssl/testssl.sh /usr/local/bin/ \\\n    && mkdir -m 755 -p /home/testssl/etc /home/testssl/bin\n\nUSER testssl\n\nENTRYPOINT [\"testssl.sh\"]\n\nCMD [\"--help\"]\n"
        },
        {
          "name": "Dockerfile.md",
          "type": "blob",
          "size": 1.4482421875,
          "content": "## Usage\n\n### From git directory\n\n```\ndocker build .\n```\n\nCatch is when you run without image tags you need to catch the ID when building\n\n```\n[..]\n---> 889fa2f99933\nSuccessfully built 889fa2f99933\n```\n\nMore comfortable is\n\n```\ndocker build -t mytestssl .\ndocker run --rm -t mytestssl example.com\n```\n\nYou can also supply command line options like:\n\n```\ndocker run -t mytestssl --help\ndocker run --rm -t mytestssl -p --header example.com\n```\n\n### From dockerhub\n\nYou can pull the image from dockerhub and run:\n\n```\ndocker run --rm -t drwetter/testssl.sh --fs example.com\n```\n\nSupported tags are: ``3.2`` and ``latest``, which are the same, i.e. the rolling release. ``3.0`` is the latest stable version from git which might have a few improvements (see git log) over the released version 3.0.X.\n\n``docker run --rm -t drwetter/testssl.sh:stable example.com``.\n\nKeep in mind that any output file (--log, --html, --json etc.) will be created within the container. If you wish to have this created in a local directory on your host you can mount a volume into the container and change the output prefix where the container user has write access to, e.g.:\n\n```\ndocker run --rm -t -v /tmp:/data drwetter/testssl.sh --htmlfile /data/ example.com\n```\n\nwhich writes the HTML output to ``/tmp/example.com_p443-<date>-<time>.html.`` The uid/gid is the one from the docker user. Normally the file is 644. testssl.sh's docker container uses a non-root user (usually with user/groupid 1000:1000).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 7.9951171875,
          "content": "\n## Intro\n\n[![CI tests](https://github.com/testssl/testssl.sh/actions/workflows/unit_tests.yml/badge.svg)](https://github.com/testssl/testssl.sh/actions/workflows/unit_tests.yml)\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/testssl/testssl.sh?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![License](https://img.shields.io/github/license/testssl/testssl.sh)](https://github.com/testssl/testssl.sh/LICENSE)\n[![Docker](https://img.shields.io/docker/pulls/testssl/testssl.sh)](https://github.com/testssl/testssl.sh/blob/3.2/Dockerfile.md)\n\n\n`testssl.sh` is a free command line tool which checks a server's service on\nany port for the support of TLS/SSL ciphers, protocols as well as some\ncryptographic flaws.\n\n### Key features\n\n* Clear output: you can tell easily whether anything is good or bad.\n* Machine readable output (CSV, two JSON formats)\n* No need to install or to configure something.  No gems, CPAN, pip or the like.\n* Works out of the box: Linux, OSX/Darwin, FreeBSD, NetBSD, MSYS2/Cygwin, WSL (bash on Windows). Only OpenBSD needs bash.\n* A Dockerfile is provided, there's also an official container build @ dockerhub.\n* Flexibility: You can test any SSL/TLS enabled and STARTTLS service, not only web servers at port 443.\n* Toolbox: Several command line options help you to run *your* test and configure *your* output.\n* Reliability: features are tested thoroughly.\n* Privacy: It's only you who sees the result, not a third party.\n* Freedom: It's 100% open source. You can look at the code, see what's going on.\n* The development is open (GitHub) and participation is welcome.\n\n### License\n\nThis software is free. You can use it under the terms of GPLv2, see LICENSE.\n\nAttribution is important for the future of this project -- also in the\ninternet. Thus if you're offering a scanner based on testssl.sh as a public and/or\npaid service in the internet you are strongly encouraged to mention to your audience\nthat you're using this program and where to get this program from. That helps us\nto get bugfixes, other feedback and more contributions.\n\n### Compatibility\n\nTestssl.sh is working on every Linux/BSD distribution out of the box. Latest by 2.9dev\nmost of the limitations of disabled features from the openssl client are gone\ndue to bash-socket-based checks. As a result you can also use e.g. LibreSSL or OpenSSL >=\n1.1.1 . testssl.sh also works on other unixoid systems out of the box, supposed they have\n`/bin/bash` >= version 3.2 and standard tools like sed and awk installed. An implicit\n(silent) check for binaries is done when you start testssl.sh . System V needs probably\nto have GNU grep installed. MacOS X and Windows (using MSYS2, Cygwin or WSL) work too.\n\nUpdate notification here or @ [mastodon](https://infosec.exchange/@testssl or [bluesky](https://bsky.app/profile/testssl.bsky.social). Please note the [twitter](https://twitter.com/drwetter) account is not being used anymore.\n\n### Installation\n\nYou can download testssl.sh branch 3.2 just by cloning this git repository:\n\n    git clone --depth 1 https://github.com/testssl/testssl.sh.git\n\n3.2 is now the latest branch which evolved from 3.1dev. It's in the release candidate phase and considered as stable.\nFor the former stable version named oldstable please help yourself by downloading the [ZIP](https://codeload.github.com/testssl/testssl.sh/zip/v3.0.9) or [tar.gz](https://codeload.github.com/testssl/testssl.sh/tar.gz/v3.0.9) archive. Just ``cd`` to the directory created (=INSTALLDIR) and run it off there.\n\n#### Docker\n\nTestssl.sh has minimal requirements. As stated you don't have to install or build anything. You can just run it from the pulled/cloned directory. Still if you don't want to pull the GitHub repo to your directory of choice you can pull a container from dockerhub and run it:\n\n```\ndocker run --rm -ti  drwetter/testssl.sh <your_cmd_line>\n```\n\nOr if you have cloned this repo you also can just ``cd`` to the INSTALLDIR and run\n```\ndocker build . -t imagefoo && docker run --rm -t imagefoo example.com\n```\n\nFor more please consult [Dockerfile.md](https://github.com/testssl/testssl.sh/blob/3.2/Dockerfile.md).\n\n### No Warranty\n\nUsage of the program is without any warranty. Use it at your own risk.\n\nTestssl.sh is intended to be used as a standalone CLI tool. While we tried to apply best practise security measures, we can't guarantee that the program is without any vulnerabilities. Running as a service may pose security risks and you're recommended to apply additional security measures.\n\n### Status\n\nWe're currently in the release candidate phase for version 3.2. You should use it despite the label \"RC\". Bigger features will be developed in a separate branch before merged into a 3.3dev to avoid hiccups or inconsistencies.\n\nVersion 3.0.X receives bugfixes, labeled as 3.0.1, 3.0.2 and so on. This will happen until 3.2 is finally released.\n\nSupport for 2.9.5 has been dropped. Supported is >= 3.0.x only.\n\n### Documentation\n\n* .. it is there for reading. Please do so :-) -- at least before asking questions. See man page in groff, html and markdown format in `~/doc/`.\n* [https://testssl.sh/](https://testssl.sh/) will help to get you started.\n* For the (older) version 2.8, Will Hunt provides a longer [description](https://www.4armed.com/blog/doing-your-own-ssl-tls-testing/), including useful background information.\n\n### Contributing\n\nContributions are welcome! See [CONTRIBUTING.md](https://github.com/testssl/testssl.sh/blob/3.2/CONTRIBUTING.md) for details. Please also have a look at the [Coding Convention](https://github.com/testssl/testssl.sh/blob/3.2/Coding_Convention.md). A lot of contributors already helped to push the project where it currently is, see [CREDITS.md](https://github.com/testssl/testssl.sh/blob/3.2/CREDITS.md). We still you use your help now. A start would be look for issues which are labeled as [good first issue](https://github.com/testssl/testssl.sh/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22), [for grabs](https://github.com/testssl/testssl.sh/issues?q=is%3Aissue+is%3Aopen+label%3A%22for+grabs%22) or [help wanted](https://github.com/testssl/testssl.sh/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22). The latter is more advanced.\n\nIn general there's some maintenance burden, like maintaining handshakes and CA stores, writing unit tests, improving github actions. If you believe you can contribute, speak up.\n\n\n### Bug reports\n\nBug reports are important. It makes this project more robust.\n\nPlease file bugs in the issue tracker @ GitHub. Do not forget to provide detailed information, see template for issue, and further details @\nhttps://github.com/testssl/testssl.sh/wiki/Bug-reporting. Nobody can read your thoughts -- yet. And only agencies your screen ;-)\n\nYou can also debug yourself, see [here](https://github.com/testssl/testssl.sh/wiki/Findings-and-HowTo-Fix-them).\n\n----\n\n### External/related projects\n\nPlease address questions not specifically to the code of testssl.sh to the respective projects below.\n\n#### Web frontend\n* https://github.com/johannesschaefer/webnettools\n* https://github.com/TKCERT/testssl.sh-webfrontend\n\n#### Free to use Web frontend + commercial API\n* https://inspect.rapydblok.com (see also https://inspect.rapydblok.com/about)\n\n#### Mass scanner w parallel scans and elastic searching the results\n* https://github.com/TKCERT/testssl.sh-masscan\n\n#### Privacy checker using testssl.sh\n* https://privacyscore.org\n\n#### Nagios / Icinga Plugins\n* https://github.com/dnmvisser/nagios-testssl (Python 3)\n* https://gitgud.malvager.net/Wazakindjes/icinga2_plugins/src/master/check_testssl.sh (Shell)\n\n#### Brew package\n\n* see [#233](https://github.com/testssl/testssl.sh/issues/233) and\n  [https://github.com/Homebrew/homebrew](https://github.com/Homebrew/homebrew)\n\n#### Daemon for batch execution of testssl.sh command files\n* https://github.com/bitsofinfo/testssl.sh-processor\n\n#### Daemon for batch processing of testssl.sh JSON result files for sending Slack alerts, reactive copying etc\n* https://github.com/bitsofinfo/testssl.sh-alerts\n\n#### GitHub Actions\n* https://github.com/marketplace/actions/testssl-sh-scan\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "etc",
          "type": "tree",
          "content": null
        },
        {
          "name": "openssl-iana.mapping.html",
          "type": "blob",
          "size": 61.111328125,
          "content": "<html lang=\"en\">\n<head>\n\t<title>Mapping OpenSSL cipher suite names to IANA names</title>\n\t<meta charset=\"UTF-8\">\n</head>\n<style type=\"text/css\">\n\ttable { border-collapse:collapse; text-align:left; font-family:Helvetica; table-layout:fixed; width:1000px; position:sticky; top:0px; z-index:10; }\n\ttable th { padding:3px; border:1px solid #000; background-color:#666 ;color:white ;width:100%; }\n\ttable tr:hover { background-color: #dfac20; color: #fff; }\n\ttr { padding:3px; border:1px solid #888; background-color:#FFF; font-size:80%; empty-cells:hide; }\n\ttr:nth-child(odd) { background-color: #CCF; color: #000; }\n\ttd { padding-left:3px; border:1px solid #999; }\n        th.sticky { position:sticky; top:0px; z-index:10; }\n</style>\n\n<body>\n<br>\n<!-- see\n\tssl/ssl2.h\n\tssl/ssl3.h\n\tssl/tls1.h\n\tssl/t1_trce.c\n\n\thttps://github.com/boundary/wireshark/blob/master/epan/dissectors/packet-ssl-utils.c\n\thttps://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml\n-->\n\n<div style=\"position:absolute; top:0px;\">\n<!--        ^^^ try to minimize the offset when scrolling back for Firefox -->\n<table>\n<col width=\"8%\" />\n<col width=\"26%\" />\n<col width=\"10%\" />\n<col width=\"11%\" />\n<col width=\"8%\" />\n<col width=\"37%\" />\n<thead>\n\t<tr><th class=\"sticky\" >Cipher Suite</th><th class=\"sticky\"> Name (OpenSSL)</th><th class=\"sticky\">   KeyExch. </th><th class=\"sticky\"> Encryption </th><th class=\"sticky\"> Bits         </th><th class=\"sticky\">Cipher Suite Name (IANA)</th></tr>\n</thead>\n<tbody>\n<!-- RFC 2246, RFC 4346, RFC 5246 -->\n<tr><td> [0x00]</td><td>                                  </td><td> None     </td><td>   Null    </td><td>  0            </td><td> TLS_NULL_WITH_NULL_NULL                 </td></tr>\n<tr><td> [0x01]</td><td>     NULL-MD5                     </td><td> RSA      </td><td>   Null    </td><td>  0            </td><td> TLS_RSA_WITH_NULL_MD5                   </td></tr>\n<tr><td> [0x02]</td><td>     NULL-SHA                     </td><td> RSA      </td><td>   Null    </td><td>  0            </td><td> TLS_RSA_WITH_NULL_SHA                   </td></tr>\n<tr><td> [0x03]</td><td>     EXP-RC4-MD5                  </td><td> RSA(512) </td><td>   RC4     </td><td>  40, export   </td><td> TLS_RSA_EXPORT_WITH_RC4_40_MD5          </td></tr>\n<tr><td> [0x04]</td><td>     RC4-MD5                      </td><td> RSA      </td><td>   RC4     </td><td>  128          </td><td> TLS_RSA_WITH_RC4_128_MD5                </td></tr>\n<tr><td> [0x05]</td><td>     RC4-SHA                      </td><td> RSA      </td><td>   RC4     </td><td>  128          </td><td> TLS_RSA_WITH_RC4_128_SHA                </td></tr>\n<tr><td> [0x06]</td><td>     EXP-RC2-CBC-MD5              </td><td> RSA(512) </td><td>   RC2     </td><td>  40, export   </td><td> TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5      </td></tr>\n<tr><td> [0x07]</td><td>     IDEA-CBC-SHA                 </td><td> RSA      </td><td>   IDEA    </td><td>  128          </td><td> TLS_RSA_WITH_IDEA_CBC_SHA               </td></tr>\n<tr><td> [0x08]</td><td>     EXP-DES-CBC-SHA              </td><td> RSA(512) </td><td>   DES     </td><td>  40, export    </td><td> TLS_RSA_EXPORT_WITH_DES40_CBC_SHA       </td></tr>\n<tr><td> [0x09]</td><td>     DES-CBC-SHA                  </td><td> RSA      </td><td>   DES     </td><td>  56           </td><td> TLS_RSA_WITH_DES_CBC_SHA                </td></tr>\n<tr><td> [0x0a]</td><td>     DES-CBC3-SHA                 </td><td> RSA      </td><td>   3DES    </td><td>  168          </td><td> TLS_RSA_WITH_3DES_EDE_CBC_SHA           </td></tr>\n<tr><td> [0x0b]</td><td>     EXP-DH-DSS-DES-CBC-SHA       </td><td> DH/DSS   </td><td>   DES     </td><td>  40, export    </td><td> TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA    </td></tr>\n<tr><td> [0x0c]</td><td>     DH-DSS-DES-CBC-SHA           </td><td> DH/DSS   </td><td>   DES     </td><td>  56           </td><td> TLS_DH_DSS_WITH_DES_CBC_SHA             </td></tr>\n<tr><td> [0x0d]</td><td>     DH-DSS-DES-CBC3-SHA          </td><td> DH/DSS   </td><td>   3DES    </td><td>  168          </td><td> TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        </td></tr>\n<tr><td> [0x0e]</td><td>     EXP-DH-RSA-DES-CBC-SHA       </td><td> DH/RSA   </td><td>   DES     </td><td>  40, export    </td><td> TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA    </td></tr>\n<tr><td> [0x0f]</td><td>     DH-RSA-DES-CBC-SHA           </td><td> DH/RSA   </td><td>   DES     </td><td>  56           </td><td> TLS_DH_RSA_WITH_DES_CBC_SHA             </td></tr>\n<tr><td> [0x10]</td><td>     DH-RSA-DES-CBC3-SHA          </td><td> DH/RSA   </td><td>   3DES    </td><td>  168          </td><td> TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        </td></tr>\n<tr><td> [0x11]</td><td>     EXP-EDH-DSS-DES-CBC-SHA      </td><td> DH(512)  </td><td>   DES     </td><td>  40, export    </td><td> TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA   </td></tr>\n<tr><td> [0x12]</td><td>     EDH-DSS-DES-CBC-SHA          </td><td> DH       </td><td>   DES     </td><td>  56           </td><td> TLS_DHE_DSS_WITH_DES_CBC_SHA            </td></tr>\n<tr><td> [0x13]</td><td>     EDH-DSS-DES-CBC3-SHA         </td><td> DH       </td><td>   3DES    </td><td>  168          </td><td> TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       </td></tr>\n<tr><td> [0x14]</td><td>     EXP-EDH-RSA-DES-CBC-SHA      </td><td> DH(512)  </td><td>   DES     </td><td>  40, export    </td><td> TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA   </td></tr>\n<tr><td> [0x15]</td><td>     EDH-RSA-DES-CBC-SHA          </td><td> DH       </td><td>   DES     </td><td>  56           </td><td> TLS_DHE_RSA_WITH_DES_CBC_SHA            </td></tr>\n<tr><td> [0x16]</td><td>     EDH-RSA-DES-CBC3-SHA         </td><td> DH       </td><td>   3DES    </td><td>  168          </td><td> TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       </td></tr>\n<tr><td> [0x17]</td><td>     EXP-ADH-RC4-MD5              </td><td> DH(512)  </td><td>   RC4     </td><td>  40, export    </td><td> TLS_DH_anon_EXPORT_WITH_RC4_40_MD5      </td></tr>\n<tr><td> [0x18]</td><td>     ADH-RC4-MD5                  </td><td> DH       </td><td>   RC4     </td><td>  128          </td><td> TLS_DH_anon_WITH_RC4_128_MD5            </td></tr>\n<tr><td> [0x19]</td><td>     EXP-ADH-DES-CBC-SHA          </td><td> DH(512)  </td><td>   DES     </td><td>  40, export    </td><td> TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA   </td></tr>\n<tr><td> [0x1a]</td><td>     ADH-DES-CBC-SHA              </td><td> DH       </td><td>   DES     </td><td>  56           </td><td> TLS_DH_anon_WITH_DES_CBC_SHA      </td></tr>\n<tr><td> [0x1b]</td><td>     ADH-DES-CBC3-SHA             </td><td> DH       </td><td>   3DES    </td><td>  168          </td><td> TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       </td></tr>\n\n<!-- FORTEZZA, 1E can be disregarded -->\n<tr><td> [0x1c]</td><td>                                  </td><td> FORTEZZA </td><td>   Null    </td><td>  0         </td><td> SSL_FORTEZZA_KEA_WITH_NULL_SHA       </td></tr>\n<tr><td> [0x1d]</td><td>                                  </td><td> FORTEZZA </td><td>FORTEZZA_CBC</td><td> 80           </td><td> SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA        </td></tr>\n<tr><td> [0x1e]</td><td>                                  </td><td> FORTEZZA </td><td>FORTEZZA_RC4</td><td> 128          </td><td> SSL_FORTEZZA_KEA_WITH_RC4_128_SHA        </td></tr>\n\n<!-- RFC 2712 -->\n<tr><td> [0x1e]</td><td>     KRB5-DES-CBC-SHA             </td><td> KRB5     </td><td>   DES     </td><td>  56           </td><td> TLS_KRB5_WITH_DES_CBC_SHA                </td></tr>\n<tr><td> [0x1f]</td><td>     KRB5-DES-CBC3-SHA            </td><td> KRB5     </td><td>   3DES    </td><td>  168          </td><td> TLS_KRB5_WITH_3DES_EDE_CBC_SHA          </td></tr>\n<tr><td> [0x20]</td><td>     KRB5-RC4-SHA                 </td><td> KRB5     </td><td>   RC4     </td><td>  128          </td><td> TLS_KRB5_WITH_RC4_128_SHA               </td></tr>\n<tr><td> [0x21]</td><td>     KRB5-IDEA-CBC-SHA            </td><td> KRB5     </td><td>   IDEA    </td><td>  128          </td><td> TLS_KRB5_WITH_IDEA_CBC_SHA              </td></tr>\n<tr><td> [0x22]</td><td>     KRB5-DES-CBC-MD5             </td><td> KRB5     </td><td>   DES     </td><td>  56           </td><td> TLS_KRB5_WITH_DES_CBC_MD5               </td></tr>\n<tr><td> [0x23]</td><td>     KRB5-DES-CBC3-MD5            </td><td> KRB5     </td><td>   3DES    </td><td>  168          </td><td> TLS_KRB5_WITH_3DES_EDE_CBC_MD5          </td></tr>\n<tr><td> [0x24]</td><td>     KRB5-RC4-MD5                 </td><td> KRB5     </td><td>   RC4     </td><td>  128          </td><td> TLS_KRB5_WITH_RC4_128_MD5               </td></tr>\n<tr><td> [0x25]</td><td>     KRB5-IDEA-CBC-MD5            </td><td> KRB5     </td><td>   IDEA    </td><td>  128          </td><td> TLS_KRB5_WITH_IDEA_CBC_MD5              </td></tr>\n<tr><td> [0x26]</td><td>     EXP-KRB5-DES-CBC-SHA         </td><td> KRB5     </td><td>   DES     </td><td>  40, export    </td><td> TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA     </td></tr>\n<tr><td> [0x27]</td><td>     EXP-KRB5-RC2-CBC-SHA         </td><td> KRB5     </td><td>   RC2     </td><td>  40, export    </td><td> TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA     </td></tr>\n<tr><td> [0x28]</td><td>     EXP-KRB5-RC4-SHA             </td><td> KRB5     </td><td>   RC4     </td><td>  40, export    </td><td> TLS_KRB5_EXPORT_WITH_RC4_40_SHA         </td></tr>\n<tr><td> [0x29]</td><td>     EXP-KRB5-DES-CBC-MD5         </td><td> KRB5     </td><td>   DES     </td><td>  40, export    </td><td> TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5     </td></tr>\n<tr><td> [0x2a]</td><td>     EXP-KRB5-RC2-CBC-MD5         </td><td> KRB5     </td><td>   RC2     </td><td>  40, export    </td><td> TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5     </td></tr>\n<tr><td> [0x2b]</td><td>     EXP-KRB5-RC4-MD5             </td><td> KRB5     </td><td>   RC4     </td><td>  40, export    </td><td> TLS_KRB5_EXPORT_WITH_RC4_40_MD5         </td></tr>\n\n<!-- RFC 4785 -->\n<tr><td> [0x2c]</td><td>     PSK-NULL-SHA                 </td><td> PSK     </td><td>   Null     </td><td>  0        </td><td> TLS_PSK_WITH_NULL_SHA         </td></tr>\n<tr><td> [0x2d]</td><td>     DHE-PSK-NULL-SHA             </td><td> DH/PSK     </td><td>   Null     </td><td> 0      </td><td> TLS_DHE_PSK_WITH_NULL_SHA         </td></tr>\n<tr><td> [0x2e]</td><td>     RSA-PSK-NULL-SHA             </td><td> RSA/PSK     </td><td>   Null     </td><td>   0   </td><td> TLS_RSA_PSK_WITH_NULL_SHA         </td></tr>\n\n<!-- RFC 5246 -->\n<tr><td> [0x2f]</td><td>     AES128-SHA                   </td><td> RSA      </td><td>   AES     </td><td>  128          </td><td> TLS_RSA_WITH_AES_128_CBC_SHA            </td></tr>\n<tr><td> [0x30]</td><td>     DH-DSS-AES128-SHA            </td><td> DH/DSS   </td><td>   AES     </td><td>  128          </td><td> TLS_DH_DSS_WITH_AES_128_CBC_SHA         </td></tr>\n<tr><td> [0x31]</td><td>     DH-RSA-AES128-SHA            </td><td> DH/RSA   </td><td>   AES     </td><td>  128          </td><td> TLS_DH_RSA_WITH_AES_128_CBC_SHA         </td></tr>\n<tr><td> [0x32]</td><td>     DHE-DSS-AES128-SHA           </td><td> DH       </td><td>   AES     </td><td>  128          </td><td> TLS_DHE_DSS_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0x33]</td><td>     DHE-RSA-AES128-SHA           </td><td> DH       </td><td>   AES     </td><td>  128          </td><td> TLS_DHE_RSA_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0x34]</td><td>     ADH-AES128-SHA               </td><td> DH       </td><td>   AES     </td><td>  128          </td><td> TLS_DH_anon_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0x35]</td><td>     AES256-SHA                   </td><td> RSA      </td><td>   AES     </td><td>  256          </td><td> TLS_RSA_WITH_AES_256_CBC_SHA            </td></tr>\n<tr><td> [0x36]</td><td>     DH-DSS-AES256-SHA            </td><td> DH/DSS   </td><td>   AES     </td><td>  256          </td><td> TLS_DH_DSS_WITH_AES_256_CBC_SHA         </td></tr>\n<tr><td> [0x37]</td><td>     DH-RSA-AES256-SHA            </td><td> DH/RSA   </td><td>   AES     </td><td>  256          </td><td> TLS_DH_RSA_WITH_AES_256_CBC_SHA         </td></tr>\n<tr><td> [0x38]</td><td>     DHE-DSS-AES256-SHA           </td><td> DH       </td><td>   AES     </td><td>  256          </td><td> TLS_DHE_DSS_WITH_AES_256_CBC_SHA        </td></tr>\n<tr><td> [0x39]</td><td>     DHE-RSA-AES256-SHA           </td><td> DH       </td><td>   AES     </td><td>  256          </td><td> TLS_DHE_RSA_WITH_AES_256_CBC_SHA        </td></tr>\n<tr><td> [0x3a]</td><td>     ADH-AES256-SHA               </td><td> DH       </td><td>   AES     </td><td>  256          </td><td> TLS_DH_anon_WITH_AES_256_CBC_SHA        </td></tr>\n<tr><td> [0x3b]</td><td>     NULL-SHA256                  </td><td> RSA      </td><td>   Null    </td><td>  0            </td><td> TLS_RSA_WITH_NULL_SHA256                </td></tr>\n<tr><td> [0x3c]</td><td>     AES128-SHA256                </td><td> RSA      </td><td>   AES     </td><td>  128          </td><td> TLS_RSA_WITH_AES_128_CBC_SHA256         </td></tr>\n<tr><td> [0x3d]</td><td>     AES256-SHA256                </td><td> RSA      </td><td>   AES     </td><td>  256          </td><td> TLS_RSA_WITH_AES_256_CBC_SHA256         </td></tr>\n<tr><td> [0x3e]</td><td>     DH-DSS-AES128-SHA256         </td><td> DH/DSS   </td><td>   AES     </td><td>  128          </td><td> TLS_DH_DSS_WITH_AES_128_CBC_SHA256      </td></tr>\n<tr><td> [0x3f]</td><td>     DH-RSA-AES128-SHA256         </td><td> DH/RSA   </td><td>   AES     </td><td>  128          </td><td> TLS_DH_RSA_WITH_AES_128_CBC_SHA256      </td></tr>\n<tr><td> [0x40]</td><td>     DHE-DSS-AES128-SHA256        </td><td> DH       </td><td>   AES     </td><td>  128          </td><td> TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     </td></tr>\n\n<!-- RFC 4132 -->\n<tr><td> [0x41]</td><td>     CAMELLIA128-SHA              </td><td> RSA      </td><td>   Camellia</td><td>  128          </td><td> TLS_RSA_WITH_CAMELLIA_128_CBC_SHA       </td></tr>\n<tr><td> [0x42]</td><td>     DH-DSS-CAMELLIA128-SHA       </td><td> DH/DSS   </td><td>   Camellia</td><td>  128          </td><td> TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA    </td></tr>\n<tr><td> [0x43]</td><td>     DH-RSA-CAMELLIA128-SHA       </td><td> DH/RSA   </td><td>   Camellia</td><td>  128          </td><td> TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA    </td></tr>\n<tr><td> [0x44]</td><td>     DHE-DSS-CAMELLIA128-SHA      </td><td> DH       </td><td>   Camellia</td><td>  128          </td><td> TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA   </td></tr>\n<tr><td> [0x45]</td><td>     DHE-RSA-CAMELLIA128-SHA      </td><td> DH       </td><td>   Camellia</td><td>  128          </td><td> TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA   </td></tr>\n<tr><td> [0x46]</td><td>     ADH-CAMELLIA128-SHA          </td><td> DH       </td><td>   Camellia</td><td>  128          </td><td> TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA   </td></tr>\n\n<tr><td> [0x60]</td><td>     EXP1024-RC4-MD5              </td><td> RSA(1024)</td><td>   RC4     </td><td>  56, export    </td><td> TLS_RSA_EXPORT1024_WITH_RC4_56_MD5</td></tr>\n<tr><td> [0x61]</td><td>     EXP1024-RC2-CBC-MD5          </td><td> RSA(1024)</td><td>   RC2     </td><td>  56, export    </td><td> TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5</td></tr>\n<tr><td> [0x62]</td><td>     EXP1024-DES-CBC-SHA          </td><td> RSA(1024)</td><td>   DES     </td><td>  56, export    </td><td> TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA</td></tr>\n<tr><td> [0x63]</td><td>     EXP1024-DHE-DSS-DES-CBC-SHA  </td><td> DH(1024) </td><td>   DES     </td><td>  56, export    </td><td> TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA</td></tr>\n<tr><td> [0x64]</td><td>     EXP1024-RC4-SHA              </td><td> RSA(1024)</td><td>   RC4     </td><td>  56, export    </td><td> TLS_RSA_EXPORT1024_WITH_RC4_56_SHA</td></tr>\n<tr><td> [0x65]</td><td>     EXP1024-DHE-DSS-RC4-SHA      </td><td> DH(1024) </td><td>   RC4     </td><td>  56, export    </td><td> TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA</td></tr>\n<tr><td> [0x66]</td><td>     DHE-DSS-RC4-SHA              </td><td> DH       </td><td>   RC4     </td><td>  128          </td><td> TLS_DHE_DSS_WITH_RC4_128_SHA</td></tr>\n<tr><td> [0x67]</td><td>     DHE-RSA-AES128-SHA256        </td><td> DH       </td><td>   AES     </td><td>  128          </td><td> TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     </td></tr>\n<tr><td> [0x68]</td><td>     DH-DSS-AES256-SHA256         </td><td> DH/DSS   </td><td>   AES     </td><td>  256          </td><td> TLS_DH_DSS_WITH_AES_256_CBC_SHA256      </td></tr>\n<tr><td> [0x69]</td><td>     DH-RSA-AES256-SHA256         </td><td> DH/RSA   </td><td>   AES     </td><td>  256          </td><td> TLS_DH_RSA_WITH_AES_256_CBC_SHA256      </td></tr>\n<tr><td> [0x6a]</td><td>     DHE-DSS-AES256-SHA256        </td><td> DH       </td><td>   AES     </td><td>  256          </td><td> TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     </td></tr>\n<tr><td> [0x6b]</td><td>     DHE-RSA-AES256-SHA256        </td><td> DH       </td><td>   AES     </td><td>  256          </td><td> TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     </td></tr>\n<tr><td> [0x6c]</td><td>     ADH-AES128-SHA256            </td><td> DH       </td><td>   AES     </td><td>  128          </td><td> TLS_DH_anon_WITH_AES_128_CBC_SHA256     </td></tr>\n<tr><td> [0x6d]</td><td>     ADH-AES256-SHA256            </td><td> DH       </td><td>   AES     </td><td>  256          </td><td> TLS_DH_anon_WITH_AES_256_CBC_SHA256     </td></tr>\n\n<!-- ГОСТ | draft-chudov-cryptopro-cptls-04.txt (expired),  RFC 4357 -->\n<tr><td> [0x80]</td><td>     GOST94-GOST89-GOST89         </td><td> VKO GOST 34.10-94     </td><td>   GOST89  </td><td>  256          </td><td> TLS_GOSTR341094_WITH_28147_CNT_IMIT </td></tr>\n<tr><td> [0x81]</td><td>     GOST2001-GOST89-GOST89       </td><td> VKO GOST 34.10-2001    </td><td>   GOST89  </td><td>  256          </td><td> TLS_GOSTR341001_WITH_28147_CNT_IMIT</td></tr>\n<tr><td> [0x82]</td><td>     GOST94-NULL-GOST94           </td><td> VKO GOST 34.10-94    </td><td>   Null   </td><td>  0         </td><td> TLS_GOSTR341001_WITH_NULL_GOSTR3411</td></tr>\n<tr><td> [0x83]</td><td>     GOST2001-GOST89-GOST89       </td><td> VKO GOST 34.10-2001    </td><td>   Null   </td><td>  0         </td><td> TLS_GOSTR341094_WITH_NULL_GOSTR3411</td></tr>\n\n<!-- RFC 4132 -->\n<tr><td> [0x84]</td><td>     CAMELLIA256-SHA              </td><td> RSA      </td><td>   Camellia</td><td>  256          </td><td> TLS_RSA_WITH_CAMELLIA_256_CBC_SHA       </td></tr>\n<tr><td> [0x85]</td><td>     DH-DSS-CAMELLIA256-SHA       </td><td> DH/DSS   </td><td>   Camellia</td><td>  256          </td><td> TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA    </td></tr>\n<tr><td> [0x86]</td><td>     DH-RSA-CAMELLIA256-SHA       </td><td> DH/RSA   </td><td>   Camellia</td><td>  256          </td><td> TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA    </td></tr>\n<tr><td> [0x87]</td><td>     DHE-DSS-CAMELLIA256-SHA      </td><td> DH       </td><td>   Camellia</td><td>  256          </td><td> TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA   </td></tr>\n<tr><td> [0x88]</td><td>     DHE-RSA-CAMELLIA256-SHA      </td><td> DH       </td><td>   Camellia</td><td>  256          </td><td> TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA   </td></tr>\n<tr><td> [0x89]</td><td>     ADH-CAMELLIA256-SHA          </td><td> DH       </td><td>   Camellia</td><td>  256          </td><td> TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA   </td></tr>\n\n<!-- RFC 4279, PSK -->\n<tr><td> [0x8a]</td><td>     PSK-RC4-SHA                  </td><td> PSK      </td><td>   RC4     </td><td>  128          </td><td> TLS_PSK_WITH_RC4_128_SHA                </td></tr>\n<tr><td> [0x8b]</td><td>     PSK-3DES-EDE-CBC-SHA         </td><td> PSK      </td><td>   3DES    </td><td>  168          </td><td> TLS_PSK_WITH_3DES_EDE_CBC_SHA           </td></tr>\n<tr><td> [0x8c]</td><td>     PSK-AES128-CBC-SHA           </td><td> PSK      </td><td>   AES     </td><td>  128          </td><td> TLS_PSK_WITH_AES_128_CBC_SHA            </td></tr>\n<tr><td> [0x8d]</td><td>     PSK-AES256-CBC-SHA           </td><td> PSK      </td><td>   AES     </td><td>  256          </td><td> TLS_PSK_WITH_AES_256_CBC_SHA            </td></tr>\n<tr><td> [0x8e]</td><td>                                  </td><td> PSK/DHE  </td><td>   RC4     </td><td>  128          </td><td> TLS_DHE_PSK_WITH_RC4_128_SHA            </td></tr>\n<tr><td> [0x8f]</td><td>                                  </td><td> PSK/DHE  </td><td>   3DES    </td><td>  168          </td><td> TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA       </td></tr>\n<tr><td> [0x90]</td><td>                                  </td><td> PSK/DHE  </td><td>   AES     </td><td>  128          </td><td> TLS_DHE_PSK_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0x91]</td><td>                                  </td><td> PSK/DHE  </td><td>   AES     </td><td>  256          </td><td> TLS_DHE_PSK_WITH_AES_256_CBC_SHA        </td></tr>\n<tr><td> [0x92]</td><td>                                  </td><td> PSK/RSA  </td><td>   RC4     </td><td>  128          </td><td> TLS_RSA_PSK_WITH_RC4_128_SHA            </td></tr>\n<tr><td> [0x93]</td><td>                                  </td><td> PSK/RSA  </td><td>   3DES    </td><td>  168          </td><td> TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA       </td></tr>\n<tr><td> [0x94]</td><td>                                  </td><td> PSK/RSA  </td><td>   AES     </td><td>  128          </td><td> TLS_RSA_PSK_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0x95]</td><td>                                  </td><td> PSK/RSA  </td><td>   AES     </td><td>  256          </td><td> TLS_RSA_PSK_WITH_AES_256_CBC_SHA        </td></tr>\n\n<!-- RFC 4162, Korean SEED -->\n<tr><td> [0x96]</td><td>     SEED-SHA                     </td><td> RSA      </td><td>   SEED    </td><td>  128          </td><td> TLS_RSA_WITH_SEED_CBC_SHA               </td></tr>\n<tr><td> [0x97]</td><td>     DH-DSS-SEED-SHA              </td><td> DH/DSS   </td><td>   SEED    </td><td>  128          </td><td> TLS_DH_DSS_WITH_SEED_CBC_SHA            </td></tr>\n<tr><td> [0x98]</td><td>     DH-RSA-SEED-SHA              </td><td> DH/RSA   </td><td>   SEED    </td><td>  128          </td><td> TLS_DH_RSA_WITH_SEED_CBC_SHA            </td></tr>\n<tr><td> [0x99]</td><td>     DHE-DSS-SEED-SHA             </td><td> DH       </td><td>   SEED    </td><td>  128          </td><td> TLS_DHE_DSS_WITH_SEED_CBC_SHA           </td></tr>\n<tr><td> [0x9a]</td><td>     DHE-RSA-SEED-SHA             </td><td> DH       </td><td>   SEED    </td><td>  128          </td><td> TLS_DHE_RSA_WITH_SEED_CBC_SHA           </td></tr>\n<tr><td> [0x9b]</td><td>     ADH-SEED-SHA                 </td><td> DH       </td><td>   SEED    </td><td>  128          </td><td> TLS_DH_anon_WITH_SEED_CBC_SHA           </td></tr>\n\n<!-- RFC 5288 -->\n<tr><td> [0x9c]</td><td>     AES128-GCM-SHA256            </td><td> RSA      </td><td>   AESGCM  </td><td>  128          </td><td> TLS_RSA_WITH_AES_128_GCM_SHA256         </td></tr>\n<tr><td> [0x9d]</td><td>     AES256-GCM-SHA384            </td><td> RSA      </td><td>   AESGCM  </td><td>  256          </td><td> TLS_RSA_WITH_AES_256_GCM_SHA384         </td></tr>\n<tr><td> [0x9e]</td><td>     DHE-RSA-AES128-GCM-SHA256    </td><td> DH       </td><td>   AESGCM  </td><td>  128          </td><td> TLS_DHE_RSA_WITH_AES_128_GCM_SHA256     </td></tr>\n<tr><td> [0x9f]</td><td>     DHE-RSA-AES256-GCM-SHA384    </td><td> DH       </td><td>   AESGCM  </td><td>  256          </td><td> TLS_DHE_RSA_WITH_AES_256_GCM_SHA384     </td></tr>\n<tr><td> [0xa0]</td><td>     DH-RSA-AES128-GCM-SHA256     </td><td> DH/RSA   </td><td>   AESGCM  </td><td>  128          </td><td> TLS_DH_RSA_WITH_AES_128_GCM_SHA256      </td></tr>\n<tr><td> [0xa1]</td><td>     DH-RSA-AES256-GCM-SHA384     </td><td> DH/RSA   </td><td>   AESGCM  </td><td>  256          </td><td> TLS_DH_RSA_WITH_AES_256_GCM_SHA384      </td></tr>\n<tr><td> [0xa2]</td><td>     DHE-DSS-AES128-GCM-SHA256    </td><td> DH       </td><td>   AESGCM  </td><td>  128          </td><td> TLS_DHE_DSS_WITH_AES_128_GCM_SHA256     </td></tr>\n<tr><td> [0xa3]</td><td>     DHE-DSS-AES256-GCM-SHA384    </td><td> DH       </td><td>   AESGCM  </td><td>  256          </td><td> TLS_DHE_DSS_WITH_AES_256_GCM_SHA384     </td></tr>\n<tr><td> [0xa4]</td><td>     DH-DSS-AES128-GCM-SHA256     </td><td> DH/DSS   </td><td>   AESGCM  </td><td>  128          </td><td> TLS_DH_DSS_WITH_AES_128_GCM_SHA256      </td></tr>\n<tr><td> [0xa5]</td><td>     DH-DSS-AES256-GCM-SHA384     </td><td> DH/DSS   </td><td>   AESGCM  </td><td>  256          </td><td> TLS_DH_DSS_WITH_AES_256_GCM_SHA384      </td></tr>\n<tr><td> [0xa6]</td><td>     ADH-AES128-GCM-SHA256        </td><td> DH       </td><td>   AESGCM  </td><td>  128          </td><td> TLS_DH_anon_WITH_AES_128_GCM_SHA256     </td></tr>\n<tr><td> [0xa7]</td><td>     ADH-AES256-GCM-SHA384        </td><td> DH       </td><td>   AESGCM  </td><td>  256          </td><td> TLS_DH_anon_WITH_AES_256_GCM_SHA384     </td></tr>\n\n<!-- RFC 5487 , PSK suites\n\nmissing: a8-b9, see https://github.com/boundary/wireshark/blob/master/epan/dissectors/packet-ssl-utils.c\n\n<tr><td> [0x]</td><td>     </td><td> DH       </td><td>   AESGCM  </td><td>  256          </td><td> </td></tr>\n\nxA8  TLS_PSK_WITH_AES_128_GCM_SHA256\nxA9  TLS_PSK_WITH_AES_256_GCM_SHA384\nxAA  TLS_DHE_PSK_WITH_AES_128_GCM_SHA256\nxAB  TLS_DHE_PSK_WITH_AES_256_GCM_SHA384\nxAC  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256\nxAD  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384\nxAE  TLS_PSK_WITH_AES_128_CBC_SHA256\nxAF  TLS_PSK_WITH_AES_256_CBC_SHA384\nxB0  TLS_PSK_WITH_NULL_SHA256\nxB1  TLS_PSK_WITH_NULL_SHA384\nxB2  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256\nxB3  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384\nxB4  TLS_DHE_PSK_WITH_NULL_SHA256\nxB5  TLS_DHE_PSK_WITH_NULL_SHA384\nxB6  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256\nxB7  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384\nxB8  TLS_RSA_PSK_WITH_NULL_SHA256\nxB9  TLS_RSA_PSK_WITH_NULL_SHA384\n\n\n-->\n\n\n<!-- RFC 5932 -->\n<tr><td> [0xba]</td><td>     CAMELLIA128-SHA256        </td><td> RSA      </td><td>   Camellia  </td><td>  128          </td><td> TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256     </td></tr>\n<tr><td> [0xbb]</td><td>     DH-DSS-CAMELLIA128-SHA256 </td><td> DH/DSS   </td><td>   Camellia  </td><td>  128          </td><td> TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256     </td></tr>\n<tr><td> [0xbc]</td><td>     DH-RSA-CAMELLIA128-SHA256 </td><td> DH/RSA   </td><td>   Camellia  </td><td>  128          </td><td> TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256     </td></tr>\n<tr><td> [0xbd]</td><td>     DHE-DSS-CAMELLIA128-SHA256</td><td> DH       </td><td>   Camellia  </td><td>  128          </td><td> TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256    </td></tr>\n<tr><td> [0xbe]</td><td>     DHE-RSA-CAMELLIA128-SHA256</td><td> DH       </td><td>   Camellia  </td><td>  128          </td><td> TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256    </td></tr>\n<tr><td> [0xbf]</td><td>     ADH-CAMELLIA128-SHA256    </td><td> DH       </td><td>   Camellia  </td><td>  128          </td><td> TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256     </td></tr>\n\n<!-- https://tools.ietf.org/html/rfc5746 -->\n<tr><td> [0x5600]</td><td>   TLS_FALLBACK_SCSV            </td><td>          </td><td>           </td><td>               </td><td> TLS_EMPTY_RENEGOTIATION_INFO_SCSV     </td></tr>\n\n<!-- RFC 8846 -->\n<tr><td> [0x1301]</td><td>   TLS_AES_128_GCM_SHA256       </td><td> ECDH     </td><td> AESGCM    </td><td> 128           </td><td> TLS_AES_128_GCM_SHA256     </td></tr>\n<tr><td> [0x1302]</td><td>   TLS_AES_256_GCM_SHA384       </td><td> ECDH     </td><td> AESGCM    </td><td> 256           </td><td> TLS_AES_256_GCM_SHA384     </td></tr>\n<tr><td> [0x1303]</td><td>   TLS_CHACHA20_POLY1305_SHA256 </td><td> ECDH     </td><td>ChaCha20-Poly1305 </td><td> 256    </td><td> TLS_CHACHA20_POLY1305_SHA256     </td></tr>\n<tr><td> [0x1304]</td><td>   TLS_AES_128_CCM_SHA256       </td><td> ECDH     </td><td> AESCCM    </td><td> 128    </td><td> TLS_AES_128_CCM_SHA256     </td></tr>\n<tr><td> [0x1305]</td><td>   TLS_AES_128_CCM_8_SHA256     </td><td> ECDH     </td><td> AESCCM8  </td><td> 128    </td><td> TLS_AES_128_CCM_8_SHA256   </td></tr>\n\n<!-- RFC 4492 -->\n<tr><td> [0xc001]</td><td>   ECDH-ECDSA-NULL-SHA          </td><td> ECDH/ECDSA</td><td>  Null    </td><td>  0            </td><td> TLS_ECDH_ECDSA_WITH_NULL_SHA            </td></tr>\n<tr><td> [0xc002]</td><td>   ECDH-ECDSA-RC4-SHA           </td><td> ECDH/ECDSA</td><td>  RC4     </td><td>  128          </td><td> TLS_ECDH_ECDSA_WITH_RC4_128_SHA         </td></tr>\n<tr><td> [0xc003]</td><td>   ECDH-ECDSA-DES-CBC3-SHA      </td><td> ECDH/ECDSA</td><td>  3DES    </td><td>  168          </td><td> TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA    </td></tr>\n<tr><td> [0xc004]</td><td>   ECDH-ECDSA-AES128-SHA        </td><td> ECDH/ECDSA</td><td>  AES     </td><td>  128          </td><td> TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA     </td></tr>\n<tr><td> [0xc005]</td><td>   ECDH-ECDSA-AES256-SHA        </td><td> ECDH/ECDSA</td><td>  AES     </td><td>  256          </td><td> TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA     </td></tr>\n<tr><td> [0xc006]</td><td>   ECDHE-ECDSA-NULL-SHA         </td><td> ECDH     </td><td>   Null    </td><td>  0            </td><td> TLS_ECDHE_ECDSA_WITH_NULL_SHA           </td></tr>\n<tr><td> [0xc007]</td><td>   ECDHE-ECDSA-RC4-SHA          </td><td> ECDH     </td><td>   RC4     </td><td>  128          </td><td> TLS_ECDHE_ECDSA_WITH_RC4_128_SHA        </td></tr>\n<tr><td> [0xc008]</td><td>   ECDHE-ECDSA-DES-CBC3-SHA     </td><td> ECDH     </td><td>   3DES    </td><td>  168          </td><td> TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   </td></tr>\n<tr><td> [0xc009]</td><td>   ECDHE-ECDSA-AES128-SHA       </td><td> ECDH     </td><td>   AES     </td><td>  128          </td><td> TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    </td></tr>\n<tr><td> [0xc00a]</td><td>   ECDHE-ECDSA-AES256-SHA       </td><td> ECDH     </td><td>   AES     </td><td>  256          </td><td> TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    </td></tr>\n<tr><td> [0xc00b]</td><td>   ECDH-RSA-NULL-SHA            </td><td> ECDH/RSA </td><td>   Null    </td><td>  0            </td><td> TLS_ECDH_RSA_WITH_NULL_SHA              </td></tr>\n<tr><td> [0xc00c]</td><td>   ECDH-RSA-RC4-SHA             </td><td> ECDH/RSA </td><td>   RC4     </td><td>  128          </td><td> TLS_ECDH_RSA_WITH_RC4_128_SHA           </td></tr>\n<tr><td> [0xc00d]</td><td>   ECDH-RSA-DES-CBC3-SHA        </td><td> ECDH/RSA </td><td>   3DES    </td><td>  168          </td><td> TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA      </td></tr>\n<tr><td> [0xc00e]</td><td>   ECDH-RSA-AES128-SHA          </td><td> ECDH/RSA </td><td>   AES     </td><td>  128          </td><td> TLS_ECDH_RSA_WITH_AES_128_CBC_SHA       </td></tr>\n<tr><td> [0xc00f]</td><td>   ECDH-RSA-AES256-SHA          </td><td> ECDH/RSA </td><td>   AES     </td><td>  256          </td><td> TLS_ECDH_RSA_WITH_AES_256_CBC_SHA       </td></tr>\n<tr><td> [0xc010]</td><td>   ECDHE-RSA-NULL-SHA           </td><td> ECDH     </td><td>   Null    </td><td>  0            </td><td> TLS_ECDHE_RSA_WITH_NULL_SHA             </td></tr>\n<tr><td> [0xc011]</td><td>   ECDHE-RSA-RC4-SHA            </td><td> ECDH     </td><td>   RC4     </td><td>  128          </td><td> TLS_ECDHE_RSA_WITH_RC4_128_SHA          </td></tr>\n<tr><td> [0xc012]</td><td>   ECDHE-RSA-DES-CBC3-SHA       </td><td> ECDH     </td><td>   3DES    </td><td>  168          </td><td> TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     </td></tr>\n<tr><td> [0xc013]</td><td>   ECDHE-RSA-AES128-SHA         </td><td> ECDH     </td><td>   AES     </td><td>  128          </td><td> TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      </td></tr>\n<tr><td> [0xc014]</td><td>   ECDHE-RSA-AES256-SHA         </td><td> ECDH     </td><td>   AES     </td><td>  256          </td><td> TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      </td></tr>\n<tr><td> [0xc015]</td><td>   AECDH-NULL-SHA               </td><td> ECDH     </td><td>   Null    </td><td>  0            </td><td> TLS_ECDH_anon_WITH_NULL_SHA             </td></tr>\n<tr><td> [0xc016]</td><td>   AECDH-RC4-SHA                </td><td> ECDH     </td><td>   RC4     </td><td>  128          </td><td> TLS_ECDH_anon_WITH_RC4_128_SHA          </td></tr>\n<tr><td> [0xc017]</td><td>   AECDH-DES-CBC3-SHA           </td><td> ECDH     </td><td>   3DES    </td><td>  168          </td><td> TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA     </td></tr>\n<tr><td> [0xc018]</td><td>   AECDH-AES128-SHA             </td><td> ECDH     </td><td>   AES     </td><td>  128          </td><td> TLS_ECDH_anon_WITH_AES_128_CBC_SHA      </td></tr>\n<tr><td> [0xc019]</td><td>   AECDH-AES256-SHA             </td><td> ECDH     </td><td>   AES     </td><td>  256          </td><td> TLS_ECDH_anon_WITH_AES_256_CBC_SHA      </td></tr>\n\n<!-- RFC 5054 Secure Remote Password -->\n<tr><td> [0xc01a]</td><td>   SRP-3DES-EDE-CBC-SHA         </td><td> SRP      </td><td>   3DES    </td><td>  168          </td><td> TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA       </td></tr>\n<tr><td> [0xc01b]</td><td>   SRP-RSA-3DES-EDE-CBC-SHA     </td><td> SRP      </td><td>   3DES    </td><td>  168          </td><td> TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA   </td></tr>\n<tr><td> [0xc01c]</td><td>   SRP-DSS-3DES-EDE-CBC-SHA     </td><td> SRP      </td><td>   3DES    </td><td>  168          </td><td> TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA   </td></tr>\n<tr><td> [0xc01d]</td><td>   SRP-AES-128-CBC-SHA          </td><td> SRP      </td><td>   AES     </td><td>  128          </td><td> TLS_SRP_SHA_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0xc01e]</td><td>   SRP-RSA-AES-128-CBC-SHA      </td><td> SRP      </td><td>   AES     </td><td>  128          </td><td> TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA    </td></tr>\n<tr><td> [0xc01f]</td><td>   SRP-DSS-AES-128-CBC-SHA      </td><td> SRP      </td><td>   AES     </td><td>  128          </td><td> TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA    </td></tr>\n<tr><td> [0xc020]</td><td>   SRP-AES-256-CBC-SHA          </td><td> SRP      </td><td>   AES     </td><td>  256          </td><td> TLS_SRP_SHA_WITH_AES_256_CBC_SHA        </td></tr>\n<tr><td> [0xc021]</td><td>   SRP-RSA-AES-256-CBC-SHA      </td><td> SRP      </td><td>   AES     </td><td>  256          </td><td> TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA    </td></tr>\n<tr><td> [0xc022]</td><td>   SRP-DSS-AES-256-CBC-SHA      </td><td> SRP      </td><td>   AES     </td><td>  256          </td><td> TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA    </td></tr>\n\n<!-- RFC 5589 -->\n<tr><td> [0xc023]</td><td>   ECDHE-ECDSA-AES128-SHA256    </td><td> ECDH     </td><td>   AES     </td><td>  128          </td><td> TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 </td></tr>\n<tr><td> [0xc024]</td><td>   ECDHE-ECDSA-AES256-SHA384    </td><td> ECDH     </td><td>   AES     </td><td>  256          </td><td> TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 </td></tr>\n<tr><td> [0xc025]</td><td>   ECDH-ECDSA-AES128-SHA256     </td><td> ECDH/ECDSA</td><td>  AES     </td><td>  128          </td><td> TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256  </td></tr>\n<tr><td> [0xc026]</td><td>   ECDH-ECDSA-AES256-SHA384     </td><td> ECDH/ECDSA</td><td>  AES     </td><td>  256          </td><td> TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384  </td></tr>\n<tr><td> [0xc027]</td><td>   ECDHE-RSA-AES128-SHA256      </td><td> ECDH     </td><td>   AES     </td><td>  128          </td><td> TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc028]</td><td>   ECDHE-RSA-AES256-SHA384      </td><td> ECDH     </td><td>   AES     </td><td>  256          </td><td> TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc029]</td><td>   ECDH-RSA-AES128-SHA256       </td><td> ECDH/RSA </td><td>   AES     </td><td>  128          </td><td> TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256    </td></tr>\n<tr><td> [0xc02a]</td><td>   ECDH-RSA-AES256-SHA384       </td><td> ECDH/RSA </td><td>   AES     </td><td>  256          </td><td> TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384    </td></tr>\n<tr><td> [0xc02b]</td><td>   ECDHE-ECDSA-AES128-GCM-SHA256</td><td> ECDH     </td><td>   AESGCM  </td><td>  128          </td><td> TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 </td></tr>\n<tr><td> [0xc02c]</td><td>   ECDHE-ECDSA-AES256-GCM-SHA384</td><td> ECDH     </td><td>   AESGCM  </td><td>  256          </td><td> TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 </td></tr>\n<tr><td> [0xc02d]</td><td>   ECDH-ECDSA-AES128-GCM-SHA256 </td><td> ECDH/ECDSA</td><td>  AESGCM  </td><td>  128          </td><td> TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256  </td></tr>\n<tr><td> [0xc02e]</td><td>   ECDH-ECDSA-AES256-GCM-SHA384 </td><td> ECDH/ECDSA</td><td>  AESGCM  </td><td>  256          </td><td> TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384  </td></tr>\n<tr><td> [0xc02f]</td><td>   ECDHE-RSA-AES128-GCM-SHA256  </td><td> ECDH     </td><td>   AESGCM  </td><td>  128          </td><td> TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc030]</td><td>   ECDHE-RSA-AES256-GCM-SHA384  </td><td> ECDH     </td><td>   AESGCM  </td><td>  256          </td><td> TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc031]</td><td>   ECDH-RSA-AES128-GCM-SHA256   </td><td> ECDH/RSA </td><td>   AESGCM  </td><td>  128          </td><td> TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256    </td></tr>\n<tr><td> [0xc032]</td><td>   ECDH-RSA-AES256-GCM-SHA384   </td><td> ECDH/RSA </td><td>   AESGCM  </td><td>  256          </td><td> TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384    </td></tr>\n\n<!-- RFC 5489 -->\n<tr><td> [0xc033]</td><td>   ECDHE-PSK-RC4-SHA            </td><td> PSK/ECDHE </td><td>  RC4     </td><td> 128      </td><td>  TLS_ECDHE_PSK_WITH_RC4_128_SHA   </td></tr>\n<tr><td> [0xc034]</td><td>   ECDHE-PSK-3DES-EDE-CBC-SHA   </td><td> PSK/ECDHE </td><td>  3DES    </td><td> 168      </td><td>  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA       </td></tr>\n<tr><td> [0xc035]</td><td>   ECDHE-PSK-AES128-CBC-SHA     </td><td> PSK/ECDHE </td><td>  AES     </td><td> 128      </td><td>  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA        </td></tr>\n<tr><td> [0xc036]</td><td>   ECDHE-PSK-AES256-CBC-SHA     </td><td> PSK/ECDHE </td><td>  AES     </td><td> 256      </td><td>  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA        </td></tr>\n<tr><td> [0xc037]</td><td>   ECDHE-PSK-AES128-CBC-SHA256  </td><td> PSK/ECDHE </td><td>  AES     </td><td> 128      </td><td>  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256     </td></tr>\n<tr><td> [0xc038]</td><td>   ECDHE-PSK-AES256-CBC-SHA384  </td><td> PSK/ECDHE </td><td>  AES     </td><td> 256      </td><td>  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384     </td></tr>\n<tr><td> [0xc039]</td><td>   ECDHE-PSK-NULL-SHA           </td><td> PSK/ECDHE </td><td>  Null    </td><td> 0        </td><td>  TLS_ECDHE_PSK_WITH_NULL_SHA               </td></tr>\n<tr><td> [0xc03A]</td><td>   ECDHE-PSK-NULL-SHA256        </td><td> PSK/ECDHE </td><td>  Null    </td><td> 0        </td><td>  TLS_ECDHE_PSK_WITH_NULL_SHA256            </td></tr>\n<tr><td> [0xc03B]</td><td>   ECDHE-PSK-NULL-SHA384        </td><td> PSK/ECDHE </td><td>  Null    </td><td> 0        </td><td>  TLS_ECDHE_PSK_WITH_NULL_SHA384            </td></tr>\n\n<!-- RFC 6209 -->\n<tr><td> [0xc03C]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc03D]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc03E]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc03F]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc040]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc041]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc042]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc043]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc044]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc045]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc046]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc047]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc048]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc049]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc04A]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc04B]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc04C]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc04D]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc04E]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc04F]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc050]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc051]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc052]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc053]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc054]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc055]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc056]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc057]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc058]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc059]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc05A]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc05B]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc05C]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc05D]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc05E]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc05F]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc060]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc061]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc062]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc063]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc064]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_PSK_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc065]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_PSK_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc066]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc067]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc068]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc069]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc06A]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_PSK_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc06B]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_PSK_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc06C]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc06D]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc06E]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc06F]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc070]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc071]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384   </td></tr>\n\n<!-- RFC 6367 -->\n<tr><td> [0xc072]</td><td> ECDHE-ECDSA-CAMELLIA128-SHA256  </td><td> ECDH       </td><td> Camellia  </td><td> 128 </td><td>  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc073]</td><td> ECDHE-ECDSA-CAMELLIA256-SHA384   </td><td> ECDH       </td><td> Camellia  </td><td> 256 </td><td>  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc074]</td><td> ECDH-ECDSA-CAMELLIA128-SHA256   </td><td> ECDH/ECDSA </td><td> Camellia  </td><td> 128 </td><td>  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc075]</td><td> ECDH-ECDSA-CAMELLIA256-SHA384   </td><td> ECDH/ECDSA </td><td> Camellia  </td><td> 256 </td><td>  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc076]</td><td> ECDHE-RSA-CAMELLIA128-SHA256    </td><td> ECDH       </td><td> Camellia  </td><td> 128 </td><td>  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc077]</td><td> ECDHE-RSA-CAMELLIA256-SHA384    </td><td> ECDH       </td><td> Camellia  </td><td> 256 </td><td>  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc078]</td><td> ECDH-RSA-CAMELLIA128-SHA256     </td><td> ECDH/RSA   </td><td> Camellia  </td><td> 128 </td><td>  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc079]</td><td> ECDH-RSA-CAMELLIA256-SHA384     </td><td> ECDH/RSA   </td><td> Camellia  </td><td> 256 </td><td>  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc07A]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc07B]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc07C]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc07D]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc07E]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc07F]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc080]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc081]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc082]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc083]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc084]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc085]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc086]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc087]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc088]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc089]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc08A]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc08B]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc08C]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc08D]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc08E]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc08F]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc090]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc091]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc092]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256   </td></tr>\n<tr><td> [0xc093]</td><td>          </td><td>      </td><td>  </td><td>       </td><td>  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384   </td></tr>\n<tr><td> [0xc094]</td><td> PSK-CAMELLIA128-SHA256         </td><td> PSK         </td><td> CAMELLIA </td><td> 128      </td><td>  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc095]</td><td> PSK-CAMELLIA256-SHA384         </td><td> PSK         </td><td> CAMELLIA </td><td> 256      </td><td>  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc096]</td><td> DHE-PSK-CAMELLIA128-SHA256     </td><td> PSK/DHE     </td><td> CAMELLIA </td><td> 128      </td><td>  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc097]</td><td> DHE-PSK-CAMELLIA256-SHA384     </td><td> PSK/DHE     </td><td> CAMELLIA </td><td> 256      </td><td>  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc098]</td><td> RSA-PSK-CAMELLIA128-SHA256     </td><td> PSK/RSA     </td><td> CAMELLIA </td><td> 128      </td><td>  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc099]</td><td> RSA-PSK-CAMELLIA256-SHA384     </td><td> PSK/RSA     </td><td> CAMELLIA </td><td> 256      </td><td>  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n<tr><td> [0xc09A]</td><td> ECDHE-PSK-CAMELLIA128-SHA256   </td><td> PSK/ECDHE   </td><td> CAMELLIA </td><td> 128      </td><td>  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256   </td></tr>\n<tr><td> [0xc09B]</td><td> ECDHE-PSK-CAMELLIA256-SHA384   </td><td> PSK/ECDHE   </td><td> CAMELLIA </td><td> 256      </td><td>  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384   </td></tr>\n\n<!-- RFC 6655 -->\n<tr><td> [0xc09c]</td><td>   AES128-CCM                   </td><td> RSA      </td><td>   AESCCM  </td><td>  128          </td><td> TLS_RSA_WITH_AES_128_CCM        </td></tr>\n<tr><td> [0xc09d]</td><td>   AES256-CCM                   </td><td> RSA      </td><td>   AESCCM  </td><td>  256          </td><td> TLS_RSA_WITH_AES_256_CCM        </td></tr>\n<tr><td> [0xc09e]</td><td>   DHE-RSA-AES128-CCM           </td><td> DH       </td><td>   AESCCM  </td><td>  128          </td><td> TLS_DHE_RSA_WITH_AES_128_CCM    </td></tr>\n<tr><td> [0xc09f]</td><td>   DHE-RSA-AES256-CCM           </td><td> DH       </td><td>   AESCCM  </td><td>  256          </td><td> TLS_DHE_RSA_WITH_AES_256_CCM    </td></tr>\n<tr><td> [0xc0a0]</td><td>   AES128-CCM8                  </td><td> RSA      </td><td>   AESCCM8 </td><td>  128          </td><td> TLS_RSA_WITH_AES_128_CCM_8    </td></tr>\n<tr><td> [0xc0a1]</td><td>   AES256-CCM8                  </td><td> RSA      </td><td>   AESCCM8 </td><td>  256          </td><td> TLS_RSA_WITH_AES_256_CCM_8    </td></tr>\n<tr><td> [0xc0a2]</td><td>   DHE-RSA-AES128-CCM8          </td><td> DH       </td><td>   AESCCM8 </td><td>  128          </td><td> TLS_DHE_RSA_WITH_AES_128_CCM_8 </td></tr>\n<tr><td> [0xc0a3]</td><td>   DHE-RSA-AES256-CCM8          </td><td> DH       </td><td>   AESCCM8 </td><td>  256          </td><td> TLS_DHE_RSA_WITH_AES_256_CCM_8 </td></tr>\n<tr><td> [0xc0a4]</td><td>   PSK-AES128-CCM               </td><td> PSK      </td><td>   AESCCM  </td><td>  128          </td><td> TLS_PSK_WITH_AES_128_CCM        </td></tr>\n<tr><td> [0xc0a5]</td><td>   PSK-AES256-CCM               </td><td> PSK      </td><td>   AESCCM  </td><td>  256          </td><td> TLS_PSK_WITH_AES_256_CCM        </td></tr>\n<tr><td> [0xc0a6]</td><td>   DHE-PSK-AES128-CCM           </td><td> PSK/DHE  </td><td>   AESCCM  </td><td>  128          </td><td> TLS_DHE_PSK_WITH_AES_128_CCM    </td></tr>\n<tr><td> [0xc0a7]</td><td>   DHE-PSK-AES256-CCM           </td><td> PSK/DHE  </td><td>   AESCCM  </td><td>  256          </td><td> TLS_DHE_PSK_WITH_AES_256_CCM    </td></tr>\n<tr><td> [0xc0a8]</td><td>   PSK-AES128-CCM8              </td><td> PSK      </td><td>   AESCCM  </td><td>  128          </td><td> TLS_PSK_WITH_AES_128_CCM_8      </td></tr>\n<tr><td> [0xc0a9]</td><td>   PSK-AES256-CCM8              </td><td> PSK      </td><td>   AESCCM  </td><td>  256          </td><td> TLS_PSK_WITH_AES_256_CCM_8      </td></tr>\n<tr><td> [0xc0aa]</td><td>   DHE-PSK-AES128-CCM8          </td><td> PSK/DHE  </td><td>   AESCCM  </td><td>  128          </td><td> TLS_PSK_DHE_WITH_AES_128_CCM_8  </td></tr>\n<tr><td> [0xc0ab]</td><td>   DHE-PSK-AES256-CCM8          </td><td> PSK/DHE  </td><td>   AESCCM  </td><td>  256          </td><td> TLS_PSK_DHE_WITH_AES_256_CCM_8  </td></tr>\n\n<!-- RFC 7251, AES-CCM   -->\n<tr><td> [0xc0ac]</td><td>   ECDHE-ECDSA-AES128-CCM       </td><td> ECDH     </td><td>   AESCCM  </td><td>  128          </td><td> TLS_ECDHE_ECDSA_WITH_AES_128_CCM</td></tr>\n<tr><td> [0xc0ad]</td><td>   ECDHE-ECDSA-AES256-CCM       </td><td> ECDH     </td><td>   AESCCM  </td><td>  256          </td><td> TLS_ECDHE_ECDSA_WITH_AES_256_CCM    </td></tr>\n<tr><td> [0xc0ae]</td><td>   ECDHE-ECDSA-AES128-CCM8      </td><td> ECDH     </td><td>   AESCCM  </td><td>  128          </td><td> TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8  </td></tr>\n<tr><td> [0xc0af]</td><td>   ECDHE-ECDSA-AES256-CCM8      </td><td> ECDH     </td><td>   AESCCM  </td><td>  256          </td><td> TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8  </td></tr>\n\n<!-- RFC 9150 -->\n<tr><td> [0xc0b4]</td><td>   TLS_SHA256_SHA256       </td><td> ECDH     </td><td>   Null  </td><td>  0          </td><td> TLS_SHA256_SHA256</td></tr>\n<tr><td> [0xc0b5]</td><td>   TLS_SHA384_SHA384       </td><td> ECDH     </td><td>   Null  </td><td>  0          </td><td> TLS_SHA384_SHA384</td></tr>\n\n<!-- OLD CHACHA POLY CIPHERS, per agreement with Peter Mosmans we use the names like SSLlabs -->\n<tr><td> [0xcc13]</td><td>   ECDHE-RSA-CHACHA20-POLY1305-OLD  </td><td> ECDH     </td><td>   ChaCha20-Poly1305</td><td>    </td><td> TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256_OLD</td></tr>\n<tr><td> [0xcc14]</td><td>   ECDHE-ECDSA-CHACHA20-POLY1305-OLD</td><td> ECDH     </td><td>   ChaCha20-Poly1305</td><td>    </td><td> TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256_OLD</td></tr>\n<tr><td> [0xcc15]</td><td>   DHE-RSA-CHACHA20-POLY1305-OLD    </td><td> DH       </td><td>   ChaCha20-Poly1305</td><td>    </td><td> TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256_OLD</td></tr>\n\n<!-- RFC7905, ChaCha20-Poly1305 -->\n<tr><td> [0xcca8]</td><td>   ECDHE-RSA-CHACHA20-POLY1305  </td><td> ECDH     </td><td>   ChaCha20-Poly1305</td><td> 256  </td><td> TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n<tr><td> [0xcca9]</td><td>   ECDHE-ECDSA-CHACHA20-POLY1305</td><td> ECDH     </td><td>   ChaCha20-Poly1305</td><td> 256  </td><td> TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n<tr><td> [0xccaa]</td><td>   DHE-RSA-CHACHA20-POLY1305    </td><td> DH       </td><td>   ChaCha20-Poly1305</td><td> 256 </td><td> TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n<tr><td> [0xccab]</td><td>   PSK-CHACHA20-POLY1305        </td><td> PSK      </td><td>   ChaCha20-Poly1305</td><td> 256 </td><td> TLS_PSK_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n<tr><td> [0xccac]</td><td>   ECDHE-PSK-CHACHA20-POLY1305  </td><td> ECDH/PSK </td><td>   ChaCha20-Poly1305</td><td> 256  </td><td> TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n<tr><td> [0xccad]</td><td>   DHE-PSK-CHACHA20-POLY1305    </td><td> DH/PSK   </td><td>   ChaCha20-Poly1305</td><td> 256 </td><td> TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n<tr><td> [0xccae]</td><td>   RSA-PSK-CHACHA20-POLY1305    </td><td> RSA/PSK  </td><td>   ChaCha20-Poly1305</td><td> 256 </td><td> TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256</td></tr>\n\n<tr><td> [0xff00]</td><td>   GOST-MD5                     </td><td> RSA      </td><td>   GOST89  </td><td>  256    </td><td>TLS_GOSTR341094_RSA_WITH_28147_CNT_MD5</td></tr>\n<tr><td> [0xff01]</td><td>   GOST-GOST94                  </td><td> RSA      </td><td>   GOST89  </td><td>  256    </td><td>TLS_RSA_WITH_28147_CNT_GOST94</td></tr>\n<tr><td> [0xff02]</td><td>   GOST-GOST89MAC               </td><td> RSA      </td><td>   GOST89  </td><td>  256    </td></tr>\n<tr><td> [0xff03]</td><td>   GOST-GOST89STREAM            </td><td> RSA      </td><td>   GOST89  </td><td>  256    </td></tr>\n\n<!-- http://www-archive.mozilla.org/projects/security/pki/nss/ssl/fips-ssl-ciphersuites.html -->\n<tr><td> [0xfefe]</td><td>                                </td><td> RSA      </td><td>   DES     </td><td>  56    </td><td>SSL_RSA_FIPS_WITH_DES_CBC_SHA</td></tr>\n<tr><td> [0xfeff]</td><td>                                </td><td> RSA      </td><td>   3DES     </td><td> 168   </td><td>SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA</td></tr>\n<!-- were thought to be of use only \"locally\" to certain specific U.S. government customers. (same as above) -->\n<tr><td> [0xfee0]</td><td>                                </td><td> RSA      </td><td>   3DES     </td><td> 168   </td><td>SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA</td></tr>\n<tr><td> [0xfee1]</td><td>                                </td><td> RSA      </td><td>   DES     </td><td>  56    </td><td>SSL_RSA_FIPS_WITH_DES_CBC_SHA</td></tr>\n\n<!-- from openssl/ssl/ssl2.h follows: -->\n\n<tr><td> [0x010080]</td><td> RC4-MD5                      </td><td> RSA      </td><td>   RC4     </td><td>  128          </td><td> SSL_CK_RC4_128_WITH_MD5              </td></tr>\n<tr><td> [0x020080]</td><td> EXP-RC4-MD5                  </td><td> RSA(512) </td><td>   RC4     </td><td>  40, export    </td><td> SSL_CK_RC4_128_EXPORT40_WITH_MD5     </td></tr>\n<tr><td> [0x030080]</td><td> RC2-CBC-MD5                  </td><td> RSA      </td><td>   RC2     </td><td>  128          </td><td> SSL_CK_RC2_128_CBC_WITH_MD5        </td></tr>\n<tr><td> [0x040080]</td><td> EXP-RC2-CBC-MD5              </td><td> RSA(512) </td><td>   RC2     </td><td>  40, export    </td><td> SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5</td></tr>\n<tr><td> [0x050080]</td><td> IDEA-CBC-MD5                 </td><td> RSA      </td><td>   IDEA    </td><td>  128          </td><td> SSL_CK_IDEA_128_CBC_WITH_MD5       </td></tr>\n<tr><td> [0x060040]</td><td> DES-CBC-MD5                  </td><td> RSA      </td><td>   DES     </td><td>  56           </td><td> SSL_CK_DES_64_CBC_WITH_MD5           </td></tr>\n<tr><td> [0x060140]</td><td> DES-CBC-SHA                  </td><td> RSA      </td><td>   DES     </td><td>  56           </td><td> SSL_CK_DES_64_CBC_WITH_SHA           </td></tr>\n<tr><td> [0x0700c0]</td><td> DES-CBC3-MD5                 </td><td> RSA      </td><td>   3DES    </td><td>  168          </td><td> SSL_CK_DES_192_EDE3_CBC_WITH_MD5  </td></tr>\n<tr><td> [0x0701c0]</td><td> DES-CBC3-SHA                 </td><td> RSA      </td><td>   3DES    </td><td>  168          </td><td> SSL_CK_DES_192_EDE3_CBC_WITH_SHA  </td></tr>\n<tr><td> [0x080080]</td><td> RC4-64-MD5                   </td><td> RSA      </td><td>   RC4     </td><td>  64           </td><td> SSL_CK_RC4_64_WITH_MD5               </td></tr>\n<!-- now the remaining ciphers from openssl/ssl/ssl2.hL\nSSL2_CK_DES_64_CFB64_WITH_MD5_1         0x02ff0800\nSSL2_CK_NULL                            0x02ff0810\n\nThey appeared first in SSLeay (see ssl.h / ssl_lib.c).\n-->\n<tr><td> [0xff0800]</td><td> DES-CFB-M1                   </td><td> RSA      </td><td>   DES     </td><td>  64           </td><td> SSL_CK_DES_64_CFB64_WITH_MD5_1       </td></tr>\n<tr><td> [0xff0810]</td><td> NULL                         </td><td> None     </td><td>   Null    </td><td>  0            </td><td> SSL_CK_NULL                         </td></tr>\n</tbody>\n</table>\n</div>\n</body>\n"
        },
        {
          "name": "t",
          "type": "tree",
          "content": null
        },
        {
          "name": "testssl.sh",
          "type": "blob",
          "size": 1190.9658203125,
          "content": "#!/usr/bin/env bash\n#\n# vim:ts=5:sw=5:expandtab\n# we have a spaces softtab, that ensures readability with other editors too\n\n# testssl.sh is a program for spotting weak SSL/TLS encryption, ciphers, protocols and some\n# vulnerabilities or features. It may or may be not distributed by your distribution.\n# The upstream versions are available (please leave the links intact):\n#\n# Development version       https://github.com/testssl/testssl.sh\n# Stable version            https://testssl.sh\n# File bugs at GitHub       https://github.com/testssl/testssl.sh/issues\n#\n# Project lead and initiator: Dirk Wetter, copyleft: 2007-today, contributions so far see CREDITS.md\n# Main contributions from David Cooper\n# Project lead and initiator: Dirk Wetter, copyleft: 2007-today.\n# Main contributions from David Cooper. Further contributors see CREDITS.md .\n#\n# License: GPLv2, see https://opensource.org/licenses/gpl-2.0.php and\n# accompanying license \"LICENSE.txt\". Redistribution + modification under this\n# license permitted.\n# If you enclose this program or parts of it in your software, it has to be\n# accompanied by the same license (see link). Do not violate the license.\n# If you do not agree to these terms, do not use it in the first place!\n#\n# OpenSSL, which is being used and maybe distributed via one of this projects'\n# web sites, is subject to their licensing: https://www.openssl.org/source/license.txt\n#\n# The client simulation data comes from SSLlabs and is licensed to the 'Qualys SSL Labs\n# Terms of Use' (v2.2), see https://www.ssllabs.com/downloads/Qualys_SSL_Labs_Terms_of_Use.pdf,\n# stating a CC BY 3.0 US license: https://creativecommons.org/licenses/by/3.0/us/\n#\n# Please note:  USAGE WITHOUT ANY WARRANTY, THE SOFTWARE IS PROVIDED \"AS IS\".\n# USE IT AT your OWN RISK!\n# Seriously! The threat is you run this code on your computer and untrusted input e.g.\n# could be supplied from a server you are querying.\n#\n# HISTORY:\n# Back in 2006 it all started with a few openssl commands...\n# That's because openssl is a such a good swiss army knife (see e.g.\n# https://wiki.openssl.org/index.php/Command_Line_Utilities) that it was difficult to resist\n# wrapping some shell commands around it, which I used for my pen tests. This is how\n# everything started.\n# Now it has grown up, it has bash socket support for most features, which has been basically\n# replacing more and more functions of OpenSSL and some sockets functions serve as some kind\n# of central functions.\n#\n# WHY BASH?\n# Cross-platform is one of the three main goals of this script. Second: Ease of installation.\n# No compiling, install gems, go to CPAN, use pip etc. Third: Easy to use and to interpret\n# the results.\n# /bin/bash including the builtin sockets fulfill all that.  The socket checks in bash may sound\n# cool and unique -- they are -- but probably you can achieve e.g. the same result with my favorite\n# interactive shell: zsh (zmodload zsh/net/socket -- checkout zsh/net/tcp) too! Oh, and btw.\n# ksh93 has socket support too.\n# Also bash is quite powerful if you use it appropriately: It can operate on patterns, process lines\n# and deal perfectly with regular expressions -- without external binaries.\n# /bin/bash though is way more often used within Linux and it's perfect for cross platform support.\n# MacOS X has it and also under Windows the MSYS2 extension or Cygwin as well as Bash on Windows (WSL)\n# has /bin/bash.\n#\n# Q: So what's the difference to www.ssllabs.com/ssltest/ or sslcheck.globalsign.com/ ?\n# A: As of now ssllabs only check 1) webservers 2) on standard ports, 3) reachable from the\n#    internet. And those examples above 4) are 3rd parties. If these restrictions are all fine\n#    with you and you need a management compatible rating -- go ahead and use those.\n#\n# But also if your fine with those restrictions: testssl.sh is meant as a tool in your hand\n# and it's way more flexible.  Oh, and did I mention testssl.sh is open source?\n#\n#################### Stop talking, action now ####################\n\n\n########### Definition of error codes\n#\ndeclare -r ERR_BASH=255            # Bash version incorrect\ndeclare -r ERR_CMDLINE=254         # Cmd line couldn't be parsed\ndeclare -r ERR_FCREATE=253         # Output file couldn't be created\ndeclare -r ERR_FNAMEPARSE=252      # Input file couldn't be parsed\ndeclare -r ERR_NOSUPPORT=251       # Feature requested is not supported\ndeclare -r ERR_OSSLBIN=250         # Problem with OpenSSL binary\ndeclare -r ERR_DNSBIN=249          # Problem with DNS lookup binaries\ndeclare -r ERR_OTHERCLIENT=248     # Other client problem\ndeclare -r ERR_DNSLOOKUP=247       # Problem with resolving IP addresses or names\ndeclare -r ERR_CONNECT=246         # Connectivity problem\ndeclare -r ERR_CLUELESS=245        # Weird state, either though user options or testssl.sh\ndeclare -r ERR_RESOURCE=244        # Resources testssl.sh needs couldn't be read\ndeclare -r ERR_CHILD=242           # Child received a signal from master\ndeclare -r ALLOK=0                 # All is fine\n\n\n[ -z \"${BASH_VERSINFO[0]}\" ] && printf \"\\n\\033[1;35m Please make sure you're using \\\"bash\\\"! Bye...\\033[m\\n\\n\" >&2 && exit $ERR_BASH\n[ $(kill -l | grep -c SIG) -eq 0 ] && printf \"\\n\\033[1;35m Please make sure you're calling me without leading \\\"sh\\\"! Bye...\\033[m\\n\\n\"  >&2 && exit $ERR_BASH\n[ ${BASH_VERSINFO[0]} -lt 3 ] && printf \"\\n\\033[1;35m Minimum requirement is bash 3.2. You have $BASH_VERSION \\033[m\\n\\n\"  >&2 && exit $ERR_BASH\n[ ${BASH_VERSINFO[0]} -le 3 ] && [ ${BASH_VERSINFO[1]} -le 1 ] && printf \"\\n\\033[1;35m Minimum requirement is bash 3.2. You have $BASH_VERSION \\033[m\\n\\n\"  >&2 && exit $ERR_BASH\n\n########### Debugging helpers + profiling\n#\ndeclare -r PS4='|${LINENO}> \\011${FUNCNAME[0]:+${FUNCNAME[0]}(): }'\nDEBUGTIME=${DEBUGTIME:-false}                     # https://stackoverflow.com/questions/5014823/how-to-profile-a-bash-shell-script-slow-startup#20855353\nDEBUG_ALLINONE=${DEBUG_ALLINONE:-false}           # true: do debugging in one screen (old behavior for testssl.sh and bash3's default\n                                                  # false: needed for performance analysis or useful for just having an extra file\nDEBUG_ALLINONE=${SETX:-false}                     # SETX as a shortcut for old style debugging, overriding DEBUG_ALLINONE\nif [[ \"$SHELLOPTS\" =~ xtrace ]]; then\n     if \"$DEBUGTIME\"; then\n          # separate debugging, doesn't mess up the screen, $DEBUGTIME determines whether we also do performance analysis\n          exec 42>&2 2> >(tee /tmp/testssl-$$.log | sed -u 's/^.*$/now/' | date -f - +%s.%N >/tmp/testssl-$$.time)\n          # BASH_XTRACEFD=42\n     else\n          if ! \"$DEBUG_ALLINONE\"; then\n               exec 42>| /tmp/testssl-$$.log\n               BASH_XTRACEFD=42\n          fi\n     fi\nfi\n\n########### Traps! Make sure that temporary files are cleaned up after use in ANY case\n#\ntrap \"cleanup\" EXIT\ntrap \"sig_cleanup\" INT QUIT TERM\ntrap \"child_error\" USR1\n\n\n########### Internal definitions\n#\ndeclare -r VERSION=\"3.2rc3\"\ndeclare -r SWCONTACT=\"dirk aet testssl dot sh\"\n[[ \"$VERSION\" =~ dev|rc|beta ]] && \\\n     SWURL=\"https://testssl.sh/dev/\" ||\n     SWURL=\"https://testssl.sh/\"\nif git rev-parse --is-inside-work-tree &>/dev/null; then\n     declare -r GIT_REL=\"$(git log --format='%h %ci' -1 2>/dev/null | awk '{ print $1\" \"$2\" \"$3 }')\"\n     declare -r GIT_REL_SHORT=\"${GIT_REL%% *}\"\n     declare -r REL_DATE_TIME=\"${GIT_REL#* }\"\n     declare -r REL_DATE=\"${REL_DATE_TIME% *}\"\nfi\ndeclare -r PROG_NAME=\"$(basename \"$0\")\"\ndeclare -r RUN_DIR=\"$(dirname \"$0\")\"\ndeclare -r SYSTEM=\"$(uname -s)\"\ndeclare -r SYSTEMREV=\"$(uname -r)\"\nHNAME=\"$(uname -n)\"\nHNAME=\"${HNAME%%.*}\"\ndeclare CMDLINE\nCMDLINE_PARSED=\"\"                                 # This makes sure we don't let early fatal() write into files when files aren't created yet\ndeclare -r -a CMDLINE_ARRAY=(\"$@\")                # When performing mass testing, the child processes need to be sent the\ndeclare -a MASS_TESTING_CMDLINE                   # command line in the form of an array (see #702 and https://mywiki.wooledge.org/BashFAQ/050).\ndeclare -a SKIP_TESTS=()                          # This array hold the checks to be skipped\n\n\n########### Defining (and presetting) variables which can be changed\n#\n# Following variables make use of $ENV and can also be used like \"<VAR>=<value> ./testssl.sh <URI>\"\ndeclare -x OPENSSL\nOPENSSL_TIMEOUT=${OPENSSL_TIMEOUT:-\"\"}  # Default connect timeout with openssl before we call the server side unreachable\nCONNECT_TIMEOUT=${CONNECT_TIMEOUT:-\"\"}  # Default connect timeout with sockets before we call the server side unreachable\nPHONE_OUT=${PHONE_OUT:-false}           # Whether testssl can retrieve CRLs and OCSP\nFAST_SOCKET=${FAST_SOCKET:-false}       # EXPERIMENTAL feature to accelerate sockets -- DO NOT USE it for production\nCOLOR=${COLOR:-2}                       # 3: Extra color (ciphers, curves), 2: Full color, 1: B/W only 0: No ESC at all\nCOLORBLIND=${COLORBLIND:-false}         # if true, swap blue and green in the output\nSHOW_EACH_C=${SHOW_EACH_C:-false}       # where individual ciphers are tested show just the positively ones tested\nSHOW_SIGALGO=${SHOW_SIGALGO:-false}     # \"secret\" switch whether testssl.sh shows the signature algorithm for -E / -e\nSNEAKY=${SNEAKY:-false}                 # is the referer and useragent we leave behind just usual?\nQUIET=${QUIET:-false}                   # don't output the banner. By doing this you acknowledge usage term appearing in the banner\nSSL_NATIVE=${SSL_NATIVE:-false}         # we do per default bash sockets where possible \"true\": switch back to \"openssl native\"\nASSUME_HTTP=${ASSUME_HTTP:-false}       # in seldom cases (WAF, old servers, grumpy SSL) service detection fails. \"True\" enforces HTTP checks\nBASICAUTH=${BASICAUTH:-\"\"}              # HTTP basic auth credentials can be set here like user:pass\nREQHEADER=${REQHEADER:-\"\"}              # HTTP custom request header can be set here like Header: content. Can be used multiple times.\nBUGS=${BUGS:-\"\"}                        # -bugs option from openssl, needed for some BIG IP F5\nWARNINGS=${WARNINGS:-\"\"}                # can be either off or batch\nDEBUG=${DEBUG:-0}                       # 1: normal output the files in /tmp/ are kept for further debugging purposes\n                                        # 2: list more what's going on , also lists some errors of connections\n                                        # 3: slight hexdumps + other info,\n                                        # 4: display bytes sent via sockets\n                                        # 5: display bytes received via sockets\n                                        # 6: whole 9 yards\nFAST=${FAST:-false}                     # preference: show only first cipher, run_allciphers with openssl instead of sockets\nWIDE=${WIDE:-false}                     # whether to display for some options just ciphers or a table w hexcode/KX,Enc,strength etc.\nMASS_TESTING_MODE=${MASS_TESTING_MODE:-serial}    # can be serial or parallel. Subject to change\nLOGFILE=\"${LOGFILE:-\"\"}\"                # logfile if used\nJSONFILE=\"${JSONFILE:-\"\"}\"              # jsonfile if used\nCSVFILE=\"${CSVFILE:-\"\"}\"                # csvfile if used\nHTMLFILE=\"${HTMLFILE:-\"\"}\"              # HTML if used\nFNAME=${FNAME:-\"\"}                      # file name to read commands from\nFNAME_PREFIX=${FNAME_PREFIX:-\"\"}        # output filename prefix, see --outprefix\nAPPEND=${APPEND:-false}                 # append to csv/json/html/log file\nOVERWRITE=${OVERWRITE:-false}           # overwriting csv/json/html/log file\n[[ -z \"$NODNS\" ]] && declare NODNS      # If unset it does all DNS lookups per default. \"min\" only for hosts or \"none\" at all\nNXCONNECT=${NXCONNECT:-invalid.}        # For WSL this helps avoiding DNS requests to \"invalid.\" which windows seem to handle delayed\nHAS_IPv6=${HAS_IPv6:-false}             # if you have OpenSSL with IPv6 support AND IPv6 networking set it to yes\nALL_CLIENTS=${ALL_CLIENTS:-false}       # do you want to run all client simulation form all clients supplied by SSLlabs?\nOFFENSIVE=${OFFENSIVE:-true}            # do you want to include offensive vulnerability tests which may cause blocking by an IDS?\nADDTL_CA_FILES=\"${ADDTL_CA_FILES:-\"\"}\"  # single file with a CA in PEM format or comma separated lists of them\n\n########### Tuning vars which cannot be set by a cmd line switch. Use instead e.g \"HEADER_MAXSLEEP=10 ./testssl.sh <your_args_here>\"\n#\nTESTSSL_INSTALL_DIR=\"${TESTSSL_INSTALL_DIR:-\"\"}\"  # If you run testssl.sh and it doesn't find it necessary file automagically set TESTSSL_INSTALL_DIR\nCA_BUNDLES_PATH=\"${CA_BUNDLES_PATH:-\"\"}\"          # You can have your CA stores some place else\nEXPERIMENTAL=${EXPERIMENTAL:-false}     # a development hook which allows us to disable code\nPROXY_WAIT=${PROXY_WAIT:-20}            # waiting at max 20 seconds for socket reply through proxy\nDNS_VIA_PROXY=${DNS_VIA_PROXY:-false}   # do DNS lookups via proxy. --ip=proxy reverses this\nIGN_OCSP_PROXY=${IGN_OCSP_PROXY:-false} # Also when --proxy is supplied it is ignored when testing for revocation via OCSP via --phone-out\nHEADER_MAXSLEEP=${HEADER_MAXSLEEP:-5}   # we wait this long before killing the process to retrieve a service banner / http header\nMAX_SOCKET_FAIL=${MAX_SOCKET_FAIL:-2}   # If this many failures for TCP socket connects are reached we terminate\nMAX_OSSL_FAIL=${MAX_OSSL_FAIL:-2}       # If this many failures for s_client connects are reached we terminate\nMAX_STARTTLS_FAIL=${MAX_STARTTLS_FAIL:-2}   # max number of STARTTLS handshake failures in plaintext phase\nMAX_HEADER_FAIL=${MAX_HEADER_FAIL:-2}   # If this many failures for HTTP GET are encountered we don't try again to get the header\nMAX_WAITSOCK=${MAX_WAITSOCK:-10}        # waiting at max 10 seconds for socket reply. There shouldn't be any reason to change this.\nCCS_MAX_WAITSOCK=${CCS_MAX_WAITSOCK:-5} # for the two CCS payload (each). There shouldn't be any reason to change this.\nHEARTBLEED_MAX_WAITSOCK=${HEARTBLEED_MAX_WAITSOCK:-8}      # for the heartbleed payload. There shouldn't be any reason to change this.\nSTARTTLS_SLEEP=${STARTTLS_SLEEP:-10}    # max time wait on a socket for STARTTLS. MySQL has a fixed value of 1 which can't be overwritten (#914)\nFAST_STARTTLS=${FAST_STARTTLS:-true}    # at the cost of reliability decrease the handshakes for STARTTLS\nUSLEEP_SND=${USLEEP_SND:-0.1}           # sleep time for general socket send\nUSLEEP_REC=${USLEEP_REC:-0.2}           # sleep time for general socket receive\nHSTS_MIN=${HSTS_MIN:-180}               # >=180 days is ok for HSTS\n     HSTS_MIN=$((HSTS_MIN * 86400))     # correct to seconds\nHPKP_MIN=${HPKP_MIN:-30}                # >=30 days should be ok for HPKP_MIN, practical hints?\n     HPKP_MIN=$((HPKP_MIN * 86400))     # correct to seconds\nDAYS2WARN1=${DAYS2WARN1:-60}            # days to warn before cert expires, threshold 1\nDAYS2WARN2=${DAYS2WARN2:-30}            # days to warn before cert expires, threshold 2\nVULN_THRESHLD=${VULN_THRESHLD:-1}       # if vulnerabilities to check >$VULN_THRESHLD we DON'T show a separate header line in the output each vuln. check\nUNBRACKTD_IPV6=${UNBRACKTD_IPV6:-false} # some versions of OpenSSL (like Gentoo) don't support [bracketed] IPv6 addresses\nNO_ENGINE=${NO_ENGINE:-false}           # if there are problems finding the (external) openssl engine set this to true\ndeclare -r CLIENT_MIN_FS=5              # number of ciphers needed to run a test for FS\nCAPATH=\"${CAPATH:-/etc/ssl/certs/}\"     # Does nothing yet (FC has only a CA bundle per default, ==> openssl version -d)\nSOCAT=\"${SOCAT:-}\"                      # For now we would need this for STARTTLS injection\n\nMEASURE_TIME_FILE=${MEASURE_TIME_FILE:-\"\"}\nif [[ -n \"$MEASURE_TIME_FILE\" ]] && [[ -z \"$MEASURE_TIME\" ]]; then\n     MEASURE_TIME=true\nelse\n     MEASURE_TIME=${MEASURE_TIME:-false}\nfi\nDISPLAY_CIPHERNAMES=\"openssl\"           # display OpenSSL ciphername (but both OpenSSL and RFC ciphernames in wide mode)\ndeclare UA_STD=\"TLS tester from $SWURL\"\ndeclare -r UA_SNEAKY=\"Mozilla/5.0 (X11; Linux x86_64; rv:94.0) Gecko/20100101 Firefox/94.0\"\nSSL_RENEG_ATTEMPTS=${SSL_RENEG_ATTEMPTS:-10}       # number of times to check SSL Renegotiation\nSSL_RENEG_WAIT=${SSL_RENEG_WAIT:-0.25}   # time between SSL Renegotiation checks\n\n########### Initialization part, further global vars just being declared here\n#\nLC_COLLATE=\"\"                           # ensures certain regex patterns work as expected and aren't localized, see setup_lc_collate()\nHAS_LOCALE=false\nSYSTEM2=\"\"                              # currently only being used for WSL = bash on windows\nPRINTF=\"\"                               # which external printf to use. Empty presets the internal one, see #1130\nCIPHERS_BY_STRENGTH_FILE=\"\"\nTLS_DATA_FILE=\"\"                        # mandatory file for socket-based handshakes\nOPENSSL=\"\"                              # ~/bin/openssl.$(uname).$(uname -m) if you run this from GitHub. Linux otherwise probably /usr/bin/openssl\nOPENSSL2=${OPENSSL2:-/usr/bin/openssl}  # This will be openssl version >=1.1.1 (auto determined) as opposed to openssl-bad (OPENSSL)\nOPENSSL2_HAS_TLS_1_3=false              # If we run with supplied binary AND $OPENSSL2 supports TLS 1.3 this will be set to true\nOSSL_SHORTCUT=${OSSL_SHORTCUT:-true}    # If you don't want automagically switch from $OPENSSL to $OPENSSL2 for TLS 1.3-only hosts, set this to false\nOPENSSL_LOCATION=\"\"\nIKNOW_FNAME=false\nFIRST_FINDING=true                      # is this the first finding we are outputting to file?\nJSONHEADER=true                         # include JSON headers and footers in HTML file, if one is being created\nCSVHEADER=true                          # same for CSV\nHTMLHEADER=true                         # same for HTML\nSECTION_FOOTER_NEEDED=false             # kludge for tracking whether we need to close the JSON section object\nGIVE_HINTS=false                        # give an additional info to findings\nSERVER_SIZE_LIMIT_BUG=false             # Some servers have either a ClientHello total size limit or a 128 cipher limit (e.g. old ASAs)\nMULTIPLE_CHECKS=false                   # need to know whether an MX record or a hostname resolves to multiple IPs to check\nCHILD_MASS_TESTING=${CHILD_MASS_TESTING:-false}\nPARENT_LOGFILE=\"\"                       # logfile if mass testing and all output sent to a single file\nPARENT_JSONFILE=\"\"                      # jsonfile if mass testing and all output sent to a single file\nPARENT_CSVFILE=\"\"                       # csvfile if mass testing and all output sent to a single file\nPARENT_HTMLFILE=\"\"                      # HTML if mass testing and all output sent to a single file\nTIMEOUT_CMD=\"\"\nHAD_SLEPT=0\nNR_SOCKET_FAIL=0                        # Counter for socket failures\nNR_OSSL_FAIL=0                          # .. for OpenSSL connects\nNR_STARTTLS_FAIL=0                      # .. for STARTTLS failures\nNR_HEADER_FAIL=0                        # .. for HTTP_GET\nPROTOS_OFFERED=\"\"                       # This keeps which protocol is being offered. See has_server_protocol().\nTLS12_CIPHER_OFFERED=\"\"                 # This contains the hexcode of a cipher known to be supported by the server with TLS 1.2\nCURVES_OFFERED=\"\"                       # This keeps which curves have been detected. Just for error handling\nNO_CIPHER_ORDER_LEVEL=5                 # This is the finding level to report if the server does not enforce a cipher order for one or more protocol versions.\nKNOWN_OSSL_PROB=false                   # We need OpenSSL a few times. This variable is an indicator if we can't connect. Eases handling\nDETECTED_TLS_VERSION=\"\"                 # .. as hex string, e.g. 0300 or 0303\nAPP_TRAF_KEY_INFO=\"\"                    # Information about the application traffic keys for a TLS 1.3 connection.\nTLS13_ONLY=false                        # Does the server support TLS 1.3 ONLY?\nTLS_EXTENSIONS=\"\"\nTLS13_CERT_COMPRESS_METHODS=\"\"\nCERTIFICATE_TRANSPARENCY_SOURCE=\"\"\nV2_HELLO_CIPHERSPEC_LENGTH=0\ndeclare -r NPN_PROTOs=\"spdy/4a2,spdy/3,spdy/3.1,spdy/2,spdy/1,http/1.1\"\n# alpn_protos needs to be space-separated, not comma-separated, including odd ones observed @ facebook and others, old ones like h2-17 omitted as they could not be found\ndeclare -r ALPN_PROTOs=\"h2 spdy/3.1 http/1.1 grpc-exp h2-fb spdy/1 spdy/2 spdy/3 stun.turn stun.nat-discovery webrtc c-webrtc ftp\"\nTEMPDIR=\"\"\nTMPFILE=\"\"\nERRFILE=\"\"\nCLIENT_AUTH=\"none\"\nCLIENT_AUTH_CA_LIST=\"\"\nTLS_TICKETS=false\nNO_SSL_SESSIONID=true\nCERT_COMPRESSION=${CERT_COMPRESSION:-false}  # secret flag to set in addition to --devel for certificate compression\nHOSTCERT=\"\"                                  # File with host certificate, without intermediate certificate\nHEADERFILE=\"\"\nHEADERVALUE=\"\"\nHTTP_STATUS_CODE=\"\"\nDH_GROUP_OFFERED=\"\"\nDH_GROUP_LEN_P=0\nKEY_SHARE_EXTN_NR=\"33\"                  # The extension number for key_share was changed from 40 to 51 in TLSv1.3 draft 23.\n                                        # In order to support draft 23 and later in addition to earlier drafts, need to\n                                        # know which extension number to use. Note that it appears that a single\n                                        # ClientHello cannot advertise both draft 23 and later and earlier drafts.\n                                        # Preset may help to deal with STARTTLS + TLS 1.3 draft 23 and later but not earlier.\nBAD_SERVER_HELLO_CIPHER=false           # reserved for cases where a ServerHello doesn't contain a cipher offered in the ClientHello\nGOST_STATUS_PROBLEM=false\nPATTERN2SHOW=\"\"\nSOCK_REPLY_FILE=\"\"\nNW_STR=\"\"\nLEN_STR=\"\"\nSNI=\"\"\nPOODLE=\"\"                               # keep vulnerability status for TLS_FALLBACK_SCSV\n\n# Initialize OpenSSL variables (and others)\nOSSL_NAME=\"\"                            # openssl name, in case of LibreSSL it's LibreSSL\nOSSL_VER=\"\"                             # openssl version, will be auto-determined\nOSSL_VER_MAJOR=0\nOSSL_VER_MINOR=0\nOSSL_VER_APPENDIX=\"none\"\nOSSL_SHORT_STR=\"\"                       # short string for banner\nCLIENT_PROB_NO=1\n\nGOOD_CA_BUNDLE=\"\"                       # A bundle of CA certificates that can be used to validate the server's certificate\nCERTIFICATE_LIST_ORDERING_PROBLEM=false # Set to true if server sends a certificate list that contains a certificate\n                                        # that does not certify the one immediately preceding it. (See RFC 8446, Section 4.4.2)\nSTAPLED_OCSP_RESPONSE=\"\"\nHAS_DNS_SANS=false                      # Whether the certificate includes a subjectAltName extension with a DNS name or an application-specific identifier type.\nHAS_DH_BITS=${HAS_DH_BITS:-false}       # These are variables which are set by find_openssl_binary()\nHAS_CURVES=false\nOSSL_SUPPORTED_CURVES=\"\"\nHAS_SSL2=false\nHAS_SSL3=false\nHAS_TLS1=false\nHAS_TLS11=false\nHAS_TLS12=false\nHAS_TLS13=false\nHAS_X448=false\nHAS_X25519=false\nHAS_SIGALGS=false\nHAS_PKUTIL=false\nHAS_PKEY=false\nHAS_NO_SSL2=false\nHAS_NOSERVERNAME=false\nHAS_CIPHERSUITES=false\nHAS_SECLEVEL=false\nHAS_COMP=false\nHAS_NO_COMP=false\nHAS_ALPN=false\nHAS_NPN=false\nHAS_FALLBACK_SCSV=false\nHAS_PROXY=false\nHAS_XMPP=false\nHAS_XMPP_SERVER=false\nHAS_POSTGRES=false\nHAS_MYSQL=false\nHAS_LMTP=false\nHAS_SIEVE=false\nHAS_NNTP=false\nHAS_IRC=false\nHAS_CHACHA20=false\nHAS_AES128_GCM=false\nHAS_AES256_GCM=false\nHAS_ZLIB=false\nHAS_UDS=false\nHAS_UDS2=false\nHAS_ENABLE_PHA=false\nHAS_DIG=false\nHAS_DIG_R=true\nDIG_R=\"-r\"\nHAS_HOST=false\nHAS_DRILL=false\nHAS_NSLOOKUP=false\nHAS_IDN=false\nHAS_IDN2=false\nHAS_AVAHIRESOLVE=false\nHAS_DIG_NOIDNOUT=false\nHAS_XXD=false\n\nOSSL_CIPHERS_S=\"\"\nPORT=443                                # unless otherwise auto-determined, see below\nNODE=\"\"\nNODEIP=\"\"\nrDNS=\"\"\nCORRECT_SPACES=\"\"                       # Used for IPv6 and proper output formatting\nIPADDRs=\"\"\nIP46ADDRs=\"\"\nLOCAL_A=false                           # Does the $NODEIP come from /etc/hosts?\nLOCAL_AAAA=false                        # Does the IPv6 IP come from /etc/hosts?\nXMPP_HOST=\"\"\nPROXYIP=\"\"                              # $PROXYIP:$PROXPORT is your proxy if --proxy is defined ...\nPROXYPORT=\"\"                            # ... and openssl has proxy support\nPROXY=\"\"                                # Once check_proxy() executed it contains $PROXYIP:$PROXPORT\nMTLS=\"\"                                 # mTLS authentication with client certificate and private key\nVULN_COUNT=0\nSERVICE=\"\"                              # Is the server running an HTTP server, SMTP, POP or IMAP?\nURI=\"\"\nCERT_FINGERPRINT_SHA2=\"\"\nRSA_CERT_FINGERPRINT_SHA2=\"\"\nSTARTTLS_PROTOCOL=\"\"\nOPTIMAL_PROTO=\"\"                        # Need this for IIS6 (sigh) + OpenSSL 1.0.2, otherwise some handshakes will fail see\n                                        # https://github.com/PeterMosmans/openssl/issues/19#issuecomment-100897892\nSTARTTLS_OPTIMAL_PROTO=\"\"               # Same for STARTTLS, see https://github.com/testssl/testssl.sh/issues/188\nOPTIMAL_SOCKETS_PROTO=\"\"                # Same for tls_sockets(). -- not yet used\nALL_FAILED_SOCKETS=true                 # Set to true if all attempts to connect to server using tls_sockets/sslv2_sockets failed\nTLS_TIME=\"\"                             # To keep the value of TLS server timestamp\nTLS_NOW=\"\"                              # Similar\nTLS_DIFFTIME_SET=false                  # Tells TLS functions to measure the TLS difftime or not\nNOW_TIME=\"\"\nHTTP_TIME=\"\"\nHTTP_AGE=\"\"                             # Age Header, see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age + RFC 7234\nREQHEADERS=()\nGET_REQ11=\"\"\nSTART_TIME=0                            # time in epoch when the action started\nEND_TIME=0                              # .. ended\nSCAN_TIME=0                             # diff of both: total scan time\nLAST_TIME=0                             # only used for performance measurements (MEASURE_TIME=true)\nSERVER_COUNTER=0                        # Counter for multiple servers\nOPEN_MSG=\"\"                             # Null the poor man's implementation of a message stack\n\nTLS_LOW_BYTE=\"\"                         # For \"secret\" development stuff, see -q below\nHEX_CIPHER=\"\"                           #                -- \" --\n\nGRADE_CAP=\"\"                            # Keeps track of the current grading cap\nGRADE_CAP_REASONS=()                    # Keeps track of all the reasons why grades are capped\nGRADE_WARNINGS=()                       # Keeps track of all the grade warnings\nKEY_EXCH_SCORE=100                      # Keeps track of the score for category 2 \"Key Exchange Strength\"\nCIPH_STR_BEST=0                         # Keeps track of the best bit size for category 3 \"Cipher Strength\"\nCIPH_STR_WORST=100000                   # Keeps track of the worst bit size for category 3 \"Cipher Strength\"\n                                        # Intentionally set very high, so it can be set to 0, if necessary\nTRUSTED1ST=\"\"                           # Contains the `-trusted_first` flag, if this version of openssl supports it\n\n########### Global variables for parallel mass testing\n#\ndeclare -r PARALLEL_SLEEP=1               # Time to sleep after starting each test\nMAX_WAIT_TEST=${MAX_WAIT_TEST:-1200}      # Maximum time (in seconds) to wait for a test to complete\nMAX_PARALLEL=${MAX_PARALLEL:-20}          # Maximum number of tests to run in parallel\n                                          # This value may be made larger on systems with faster processors\ndeclare -a -i PARALLEL_TESTING_PID=()     # process id for each child test (or 0 to indicate test has already completed)\ndeclare -a PARALLEL_TESTING_CMDLINE=()    # command line for each child test\ndeclare -i NR_PARALLEL_TESTS=0            # number of parallel tests run\ndeclare -i NEXT_PARALLEL_TEST_TO_FINISH=0 # number of parallel tests that have completed and have been processed\ndeclare FIRST_JSON_OUTPUT=true            # true if no output has been added to $JSONFILE yet.\n\n\n########### Cipher suite information\n#\ndeclare -i TLS_NR_CIPHERS=0\ndeclare TLS_CIPHER_HEXCODE=()\ndeclare TLS_CIPHER_OSSL_NAME=()\ndeclare TLS_CIPHER_RFC_NAME=()\ndeclare TLS_CIPHER_SSLVERS=()\ndeclare TLS_CIPHER_KX=()\ndeclare TLS_CIPHER_AUTH=()\ndeclare TLS_CIPHER_ENC=()\ndeclare TLS_CIPHER_EXPORT=()\ndeclare TLS_CIPHER_OSSL_SUPPORTED=()\ndeclare TLS13_OSSL_CIPHERS=\"TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_CCM_SHA256:TLS_AES_128_CCM_8_SHA256:TLS_SHA256_SHA256:TLS_SHA384_SHA384\"\n\n\n########### Some predefinitions: date, sed (we always use tests for binaries and NOT try to determine\n#   capabilities by querying the OS)\n#\nHAS_GNUDATE=false\nHAS_FREEBSDDATE=false\nHAS_OPENBSDDATE=false\nif date -d @735275209 >/dev/null 2>&1; then\n     if date -r @735275209  >/dev/null 2>&1; then\n          # It can't do any conversion from a plain date output.\n          HAS_OPENBSDDATE=true\n     else\n          HAS_GNUDATE=true\n     fi\nfi\n# FreeBSD and OS X date(1) accept \"-f inputformat\", so do newer OpenBSD versions >~ 6.6.\ndate -j -f '%s' 1234567 >/dev/null 2>&1 && \\\n     HAS_FREEBSDDATE=true\n\necho A | sed -E 's/A//' >/dev/null 2>&1 && \\\n     declare -r HAS_SED_E=true || \\\n     declare -r HAS_SED_E=false\n\n########### Terminal definitions\ntty -s && \\\n     declare -r INTERACTIVE=true || \\\n     declare -r INTERACTIVE=false\n\nif [[ -z $TERM_WIDTH ]]; then                               # No batch file and no otherwise predefined TERM_WIDTH\n     if ! tput cols &>/dev/null || ! \"$INTERACTIVE\";then    # Prevent tput errors if running non interactive\n          export TERM_WIDTH=${COLUMNS:-80}\n     else\n          export TERM_WIDTH=${COLUMNS:-$(tput cols)}        # For custom line wrapping and dashes\n     fi\nfi\nTERM_CURRPOS=0                                              # Custom line wrapping needs alter the current horizontal cursor pos\n\n\n########### Severity functions and globals\n#\nINFO=0\nOK=0\nLOW=1\nMEDIUM=2\nHIGH=3\nCRITICAL=4\nSEVERITY_LEVEL=0\n\nset_severity_level() {\n     local severity=$1\n\n     if [[ \"$severity\" == LOW ]]; then\n          SEVERITY_LEVEL=$LOW\n     elif [[ \"$severity\" == MEDIUM ]]; then\n          SEVERITY_LEVEL=$MEDIUM\n     elif [[ \"$severity\" == HIGH ]]; then\n          SEVERITY_LEVEL=$HIGH\n     elif [[ \"$severity\" == CRITICAL ]]; then\n          SEVERITY_LEVEL=$CRITICAL\n     else\n          # WARN and FATAL will always be logged as the represent scanning problems\n          echo \"Supported severity levels are LOW, MEDIUM, HIGH, CRITICAL!\"\n          help 1\n     fi\n}\n\nshow_finding() {\n     local severity=$1\n\n     [[ \"$severity\" == DEBUG ||\n     ( \"$severity\" == INFO && $SEVERITY_LEVEL -le $INFO ) ||\n     ( \"$severity\" == OK && $SEVERITY_LEVEL -le $OK ) ||\n     ( \"$severity\" == LOW && $SEVERITY_LEVEL -le $LOW ) ||\n     ( \"$severity\" == MEDIUM && $SEVERITY_LEVEL -le $MEDIUM ) ||\n     ( \"$severity\" == HIGH && $SEVERITY_LEVEL -le $HIGH ) ||\n     ( \"$severity\" == CRITICAL && $SEVERITY_LEVEL -le $CRITICAL ) ||\n     \"$severity\" == WARN ||\n     \"$severity\" == FATAL ]]\n}\n\n########### Output functions\n\n# For HTML output, replace any HTML reserved characters with the entity name\nhtml_reserved(){\n     local output\n     \"$do_html\" || return 0\n     output=\"${1//&/$'&'amp;}\"\n     output=\"${output//</$'&'lt;}\"\n     output=\"${output//>/$'&'gt;}\"\n     output=\"${output//\\\"/$'&'quot;}\"\n     output=\"${output//\\'/$'&'apos;}\"\n     printf -- \"%s\" \"$output\"\n     return 0\n}\n\nhtml_out() {\n     local outstr=\"$1\"\n\n     \"$do_html\" || return 0\n     if [[ -n \"$HTMLFILE\" ]] && [[ ! -d \"$HTMLFILE\" ]]; then\n          if [[ \"$outstr\" =~ [[:cntrl:]] ]]; then\n               outstr=\"$(sanitize_fileout \"$outstr\")\"\n          fi\n          printf -- \"%b\" \"$outstr\" >> \"$HTMLFILE\"\n     fi\n}\n\n# Removes non-printable chars in CSV, JSON, HTML, see #2330\nsanitize_fileout() {\n     tr -d '\\000-\\011\\013-\\037' <<< \"$1\"\n}\n\n# Removes non-printable chars in terminal output (log files)\n# We need to keep the color ANSI escape code x1b, o33, see #2330\nsanitize_termout() {\n     tr -d '\\000-\\011\\013-\\032\\034-\\037' <<< \"$1\"\n}\n\n# This is intentionally the same.\nsafe_echo()  { printf -- \"%b\" \"$1\"; }\ntm_out()     { printf -- \"%b\" \"$1\"; }\ntmln_out()   { printf -- \"%b\" \"$1\\n\"; }\n\nout()   { printf -- \"%b\" \"$1\"; html_out \"$(html_reserved \"$1\")\"; }\noutln() { printf -- \"%b\" \"$1\\n\"; html_out \"$(html_reserved \"$1\")\\n\"; }\n\n#TODO: Still no shell injection safe but if just run it from the cmd line: that's fine\n\n# Color print functions, see also https://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html\ntm_liteblue()   { [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && tm_out \"\\033[0;32m$1\" || tm_out \"\\033[0;34m$1\"; } || tm_out \"$1\"; tm_off; }    # not yet used\npr_liteblue()   { tm_liteblue \"$1\"; [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && html_out \"<span style=\\\"color:#008817;\\\">$(html_reserved \"$1\")</span>\" || html_out \"<span style=\\\"color:#0000ee;\\\">$(html_reserved \"$1\")</span>\"; } || html_out \"$(html_reserved \"$1\")\"; }\ntmln_liteblue() { tm_liteblue \"$1\"; tmln_out; }\nprln_liteblue() { pr_liteblue \"$1\"; outln; }\n\ntm_blue()       { [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && tm_out \"\\033[1;32m$1\" || tm_out \"\\033[1;34m$1\"; } || tm_out \"$1\"; tm_off; }    # used for head lines of single tests\npr_blue()       { tm_blue \"$1\"; [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && html_out \"<span style=\\\"color:#008817;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"<span style=\\\"color:#5c5cff;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\"; } || html_out \"$(html_reserved \"$1\")\"; }\ntmln_blue()     { tm_blue \"$1\"; tmln_out; }\nprln_blue()     { pr_blue \"$1\"; outln; }\n\n# we should be able to use aliases here\ntm_warning()    { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[0;35m$1\" || tm_underline \"$1\"; tm_off; }                   # some local problem: one test cannot be done\ntmln_warning()  { tm_warning \"$1\"; tmln_out; }                                                                    # litemagenta\npr_warning()    { tm_warning \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#cd00cd;\\\">$(html_reserved \"$1\")</span>\" || { [[ \"$COLOR\" -eq 1 ]] && html_out \"<u>$(html_reserved \"$1\")</u>\" || html_out \"$(html_reserved \"$1\")\"; }; }\nprln_warning()  { pr_warning \"$1\"; outln; }\n\ntm_magenta()    { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[1;35m$1\" || tm_underline \"$1\"; tm_off; }                   # fatal error: quitting because of this!\ntmln_magenta()  { tm_magenta \"$1\"; tmln_out; }\n# different as warning above?\npr_magenta()    { tm_magenta \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#be32d0;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || { [[ \"$COLOR\" -eq 1 ]] && html_out \"<u>$(html_reserved \"$1\")</u>\" || html_out \"$(html_reserved \"$1\")\"; }; }\nprln_magenta()  { pr_magenta \"$1\"; outln; }\n\ntm_litecyan()   { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[0;36m$1\" || tm_out \"$1\"; tm_off; }                         # not yet used\ntmln_litecyan() { tm_litecyan \"$1\"; tmln_out; }\npr_litecyan()   { tm_litecyan \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#168092;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_litecyan() { pr_litecyan \"$1\"; outln; }\n\ntm_cyan()       { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[1;36m$1\" || tm_out \"$1\"; tm_off; }                         # additional hint\ntmln_cyan()     { tm_cyan \"$1\"; tmln_out; }\npr_cyan()       { tm_cyan \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#0d7ea2;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_cyan()     { pr_cyan \"$1\"; outln; }\n\ntm_litegrey()   { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[0;37m$1\" || tm_out \"$1\"; tm_off; }                         # ... https://github.com/testssl/testssl.sh/pull/600#issuecomment-276129876\ntmln_litegrey() { tm_litegrey \"$1\"; tmln_out; }                                                                   # not really usable on a black background, see ..\nprln_litegrey() { pr_litegrey \"$1\"; outln; }\npr_litegrey()   { tm_litegrey \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<span style=\\\"color:#71767a;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\n\ntm_grey()       { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[1;30m$1\" || tm_out \"$1\"; tm_off; }\npr_grey()       { tm_grey \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<span style=\\\"color:#757575;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\ntmln_grey()     { tm_grey \"$1\"; tmln_out; }\nprln_grey()     { pr_grey \"$1\"; outln; }\n\ntm_svrty_good()   { [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && tm_out \"\\033[0;34m$1\" || tm_out \"\\033[0;32m$1\"; } || tm_out \"$1\"; tm_off; }   # litegreen (liteblue), This is good\ntmln_svrty_good() { tm_svrty_good \"$1\"; tmln_out; }\npr_svrty_good()   { tm_svrty_good \"$1\"; [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && html_out \"<span style=\\\"color:#0000ee;\\\">$(html_reserved \"$1\")</span>\" || html_out \"<span style=\\\"color:#008817;\\\">$(html_reserved \"$1\")</span>\"; } || html_out \"$(html_reserved \"$1\")\"; }\nprln_svrty_good() { pr_svrty_good \"$1\"; outln; }\n\ntm_svrty_best()   { [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && tm_out \"\\033[1;34m$1\" || tm_out \"\\033[1;32m$1\"; } ||  tm_out \"$1\"; tm_off; }  # green (blue), This is the best\ntmln_svrty_best() { tm_svrty_best \"$1\"; tmln_out; }\npr_svrty_best()   { tm_svrty_best \"$1\"; [[ \"$COLOR\" -ge 2 ]] && { \"$COLORBLIND\" && html_out \"<span style=\\\"color:#5c5cff;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"<span style=\\\"color:#008817;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\"; } || html_out \"$(html_reserved \"$1\")\"; }\nprln_svrty_best() { pr_svrty_best \"$1\"; outln; }\n\ntm_svrty_low()     { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[1;33m$1\" || tm_out \"$1\"; tm_off; }         # yellow brown | academic or minor problem\ntmln_svrty_low()   { tm_svrty_low \"$1\"; tmln_out; }\npr_svrty_low()     { tm_svrty_low \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#a86437;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_svrty_low()   { pr_svrty_low \"$1\"; outln; }\n\ntm_svrty_medium()  { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[0;33m$1\" || tm_out \"$1\"; tm_off; }         # brown | it is not a bad problem but you shouldn't do this\npr_svrty_medium()  { tm_svrty_medium \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#c05600;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\ntmln_svrty_medium(){ tm_svrty_medium \"$1\"; tmln_out; }\nprln_svrty_medium(){ pr_svrty_medium \"$1\"; outln; }\n\ntm_svrty_high()    { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[0;31m$1\" || tm_bold \"$1\"; tm_off; }               # litered\npr_svrty_high()    { tm_svrty_high \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#e52207;\\\">$(html_reserved \"$1\")</span>\" || { [[ \"$COLOR\" -eq 1 ]] && html_out \"<span style=\\\"font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }; }\ntmln_svrty_high()  { tm_svrty_high \"$1\"; tmln_out; }\nprln_svrty_high()  { pr_svrty_high \"$1\"; outln; }\n\ntm_svrty_critical()   { [[ \"$COLOR\" -ge 2 ]] && tm_out \"\\033[1;31m$1\" || tm_bold \"$1\"; tm_off; }           # red\npr_svrty_critical()   { tm_svrty_critical \"$1\"; [[ \"$COLOR\" -ge 2 ]] && html_out \"<span style=\\\"color:#e52207;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || { [[ \"$COLOR\" -eq 1 ]] && html_out \"<span style=\\\"font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }; }\ntmln_svrty_critical() { tm_svrty_critical \"$1\"; tmln_out; }\nprln_svrty_critical() { pr_svrty_critical \"$1\"; outln; }\n\ntm_deemphasize()      { tm_out \"$1\"; }                                                                   # hook for a weakened screen output, see #600\npr_deemphasize()      { tm_deemphasize \"$1\"; html_out \"<span style=\\\"color:#71767a;\\\">$(html_reserved \"$1\")</span>\"; }\ntmln_deemphasize()    { tm_deemphasize \"$1\"; tmln_out; }\nprln_deemphasize()    { pr_deemphasize \"$1\"; outln; }\n\n# color=1 functions\ntm_off()        { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[m\"; }\n\ntm_bold()       { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[1m$1\" || tm_out \"$1\"; tm_off; }\ntmln_bold()     { tm_bold \"$1\"; tmln_out; }\npr_bold()       { tm_bold \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<span style=\\\"font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_bold()     { pr_bold \"$1\" ; outln; }\n\nNO_ITALICS=false\nif [[ $TERM == screen ]]; then\n     NO_ITALICS=true\nelif [[ $SYSTEM == OpenBSD ]]; then\n     NO_ITALICS=true\nelif [[ $SYSTEM == FreeBSD ]]; then\n     if [[ ${SYSTEMREV%\\.*} -le 9 ]]; then\n          NO_ITALICS=true\n     fi\nfi\ntm_italic()     { { [[ \"$COLOR\" -ne 0 ]] && ! \"$NO_ITALICS\"; } && tm_out \"\\033[3m$1\" || tm_out \"$1\"; tm_off; }\ntmln_italic()   { tm_italic \"$1\" ; tmln_out; }\npr_italic()     { tm_italic \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<i>$(html_reserved \"$1\")</i>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_italic()   { pr_italic \"$1\"; outln; }\n\ntm_strikethru()   { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[9m$1\" || tm_out \"$1\"; tm_off; }                          # ugly!\ntmln_strikethru() { tm_strikethru \"$1\"; tmln_out; }\npr_strikethru()   { tm_strikethru \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<strike>$(html_reserved \"$1\")</strike>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_strikethru() { pr_strikethru \"$1\" ; outln; }\n\ntm_underline()    { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[4m$1\" || tm_out \"$1\"; tm_off; }\ntmln_underline()  { tm_underline \"$1\"; tmln_out; }\npr_underline()    { tm_underline \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<u>$(html_reserved \"$1\")</u>\" || html_out \"$(html_reserved \"$1\")\"; }\nprln_underline()  { pr_underline \"$1\"; outln; }\n\ntm_reverse()      { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[7m$1\" || tm_out \"$1\"; tm_off; }\ntm_reverse_bold() { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[7m\\033[1m$1\" || tm_out \"$1\"; tm_off; }\npr_reverse()      { tm_reverse \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<span style=\\\"color:white;background-color:black;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\npr_reverse_bold() { tm_reverse_bold \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<span style=\\\"color:white;background-color:black;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\n\n#pr_headline() { pr_blue \"$1\"; }\n#https://misc.flogisoft.com/bash/tip_colors_and_formatting\n\n#pr_headline() { [[ \"$COLOR\" -ge 2 ]] && out \"\\033[1;30m\\033[47m$1\" || out \"$1\"; tm_off; }\ntm_headline()   { [[ \"$COLOR\" -ne 0 ]] && tm_out \"\\033[1m\\033[4m$1\" || tm_out \"$1\"; tm_off; }\ntmln_headline() { tm_headline \"$1\"; tmln_out; }\npr_headline()   { tm_headline \"$1\"; [[ \"$COLOR\" -ne 0 ]] && html_out \"<span style=\\\"text-decoration:underline;font-weight:bold;\\\">$(html_reserved \"$1\")</span>\" || html_out \"$(html_reserved \"$1\")\"; }\npr_headlineln() { pr_headline \"$1\" ; outln; }\n\ntm_squoted() { tm_out \"'$1'\"; }\npr_squoted() { out \"'$1'\"; }\ntm_dquoted() { tm_out \"\\\"$1\\\"\"; }\npr_dquoted() { out \"\\\"$1\\\"\"; }\n\n# either files couldn't be found or openssl isn't good enough (which shouldn't happen anymore)\ntm_local_problem()   { tm_warning \"Local problem: $1\"; }\ntmln_local_problem() { tmln_warning \"Local problem: $1\"; }\npr_local_problem()   { pr_warning \"Local problem: $1\"; }\nprln_local_problem() { prln_warning \"Local problem: $1\"; }\n\n# general failure\ntm_fixme()   { tm_warning \"Fixme: $1\"; }\ntmln_fixme() { tmln_warning \"Fixme: $1\"; }\npr_fixme()   { pr_warning \"Fixme: $1\"; }\nprln_fixme() { prln_warning \"Fixme: $1\"; }\n\npr_url()     { tm_out \"$1\"; html_out \"<a href=\\\"$1\\\" style=\\\"color:black;text-decoration:none;\\\">$1</a>\"; }\npr_boldurl() { tm_bold \"$1\"; html_out \"<a href=\\\"$1\\\" style=\\\"font-weight:bold;color:black;text-decoration:none;\\\">$1</a>\"; }\n\n### color switcher (see e.g. https://linuxtidbits.wordpress.com/2008/08/11/output-color-on-bash-scripts/\n###                          https://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html\n### no output support for HTML!\nset_color_functions() {\n     local ncurses_tput=true\n\n     if [[ $SYSTEM == OpenBSD ]] && [[ \"$TERM\" =~ xterm-256 ]]; then\n          export TERM=xterm\n          # OpenBSD can't handle 256 colors (yet) in xterm which might lead to ugly errors\n          # like \"tput: not enough arguments (3) for capability `AF'\". Not our fault but\n          # before we get blamed we fix it here.\n     fi\n\n     # Empty all vars if we have COLOR=0 equals no escape code -- these are globals:\n     red=\"\"\n     green=\"\"\n     brown=\"\"\n     blue=\"\"\n     magenta=\"\"\n     cyan=\"\"\n     grey=\"\"\n     yellow=\"\"\n     off=\"\"\n     bold=\"\"\n     underline=\"\"\n     italic=\"\"\n\n     type -p tput &>/dev/null || return 0      # Hey wait, do we actually have tput / ncurses ?\n     tput cols &>/dev/null || return 0         # tput under BSDs and GNUs doesn't work either (TERM undefined?)\n     tput sgr0 &>/dev/null || ncurses_tput=false\n     if [[ \"$COLOR\" -ge 2 ]]; then\n          if $ncurses_tput; then\n               red=$(tput setaf 1)\n               green=$(tput setaf 2)\n               brown=$(tput setaf 3)\n               blue=$(tput setaf 4)\n               magenta=$(tput setaf 5)\n               cyan=$(tput setaf 6)\n               grey=$(tput setaf 7)\n               yellow=$(tput setaf 3; tput bold)\n          else                                    # this is a try for old BSD, see terminfo(5)\n               red=$(tput AF 1)\n               green=$(tput AF 2)\n               brown=$(tput AF 3)\n               blue=$(tput AF 4)\n               magenta=$(tput AF 5)\n               cyan=$(tput AF 6)\n               grey=$(tput AF 7)\n               yellow=$(tput AF 3; tput md)\n          fi\n     fi\n     if [[ \"$COLOR\" -ge 1 ]]; then\n          if $ncurses_tput; then\n               bold=$(tput bold)\n               underline=$(tput sgr 0 1 2>/dev/null)\n               italic=$(tput sitm)                # This doesn't work on FreeBSDi (9,10) and OpenBSD ...\n               italic_end=$(tput ritm)            # ... and this, too\n               off=$(tput sgr0)\n          else                                    # this is a try for old BSD, see terminfo(5)\n               bold=$(tput md)\n               underline=$(tput us)\n               italic=$(tput ZH 2>/dev/null)       # This doesn't work on FreeBSDi (9,10) and OpenBSD\n               italic_end=$(tput ZR 2>/dev/null)   # ... probably entry missing in /etc/termcap\n               reverse=$(tput mr)\n               off=$(tput me)\n          fi\n     fi\n     # FreeBSD 10 understands ESC codes like 'echo -e \"\\e[3mfoobar\\e[23m\"', but also no tput for italics\n}\n\n###### START universal helper function definitions ######\n\nif [[ \"${BASH_VERSINFO[0]}\" == 3 ]]; then\n     # older bash can do this only (MacOS X), even SLES 11, see #697\n     toupper() { tr 'a-z' 'A-Z' <<< \"$1\"; }\n     tolower() { tr 'A-Z' 'a-z' <<< \"$1\"; }\nelse\n     toupper() { echo -n \"${1^^}\"; }\n     tolower() { echo -n \"${1,,}\"; }\nfi\n\nget_last_char() {\n     echo \"${1:~0}\"      # \"${string: -1}\" would work too (both also in bash 3.2)\n}\n                         # Checking for last char. If already a separator supplied, we don't need an additional one\ndebugme() {\n     [[ \"$DEBUG\" -ge 2 ]] && \"$@\" >&2\n     return 0\n}\n\ndebugme1() { [[ \"$DEBUG\" -ge 1 ]] && \"$@\" >&2; }\n\nhex2dec() {\n     echo $((16#$1))\n}\n\n# convert decimal number < 256 to hex\ndec02hex() {\n     printf \"x%02x\" \"$1\"\n}\n\n# convert decimal number between 256 and < 256*256 to hex\ndec04hex() {\n     local a=$(printf \"%04x\" \"$1\")\n     printf \"x%02s, x%02s\" \"${a:0:2}\" \"${a:2:2}\"\n}\n\n\n# trim spaces for BSD and old sed\ncount_lines() {\n     echo $(wc -l <<< \"$1\")\n}\n\ncount_words() {\n     echo $(wc -w <<< \"$1\")\n}\n\ncount_ciphers() {\n     echo $(wc -w <<< \"${1//:/ }\")\n}\n\ncount_chars() {\n     echo $(wc -c <<< \"$1\")\n}\n\nnewline_to_spaces() {\n     tr '\\n' ' ' <<< \"$1\" | sed 's/ $//'\n}\n\ncolon_to_spaces() {\n     echo \"${1//:/ }\"\n}\n\nstrip_lf() {\n     tr -d '\\n' <<< \"$1\" | tr -d '\\r'\n}\n\nstrip_spaces() {\n     echo \"${1// /}\"\n}\n\n# https://web.archive.org/web/20121022051228/http://codesnippets.joyent.com/posts/show/1816\nstrip_leading_space() {\n     printf \"%s\" \"${1#\"${1%%[![:space:]]*}\"}\"\n}\nstrip_trailing_space() {\n     printf \"%s\" \"${1%\"${1##*[![:space:]]}\"}\"\n}\n\nis_number() {\n     [[ \"$1\" =~ ^[1-9][0-9]*$ ]] && \\\n          return 0 || \\\n          return 1\n}\n\nstrip_quote() (\n     # Note: parens in function definition here force this into a separate\n     # shell, preventing extglob from affecting the code outside this function\n     shopt -s extglob\n     # Remove color codes\n     OUT=${1//$'\\e['*([0-9;])[a-zA-Z]}\n     # Replace quotes\n     OUT=${OUT//\\\"/\\'}\n     strip_leading_space \"$(\n          strip_trailing_space \"$OUT\"\n     )\"\n)\n\n# Converts a string containing PEM encoded data to one line.\npem_to_one_line() {\n     local pem=\"$1\"\n     local header=\"\" footer=\"\"\n\n     if [[ \"$pem\" =~ .*-+BEGIN\\ [A-Za-z0-9]+-+ ]]; then\n          header=\"$BASH_REMATCH\"\n          pem=\"${pem/$header/}\"\n     fi\n     if [[ \"$pem\" =~ -+END\\ [A-Za-z0-9]+-+.* ]]; then\n          footer=\"$BASH_REMATCH\"\n          pem=\"${pem/$footer/}\"\n     fi\n     pem=\"$(strip_spaces \"$(newline_to_spaces \"$pem\")\")\"\n     [[ -n \"$header\" ]] && pem=\"$header\\\\\\n$pem\"\n     [[ -n \"$footer\" ]] && pem+=\"\\\\\\n$footer\"\n     printf -- \"%s\" \"$pem\"\n     return 0\n}\n\nis_ipv4addr() {\n     local octet=\"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\"\n     local ipv4address=\"$octet\\\\.$octet\\\\.$octet\\\\.$octet\"\n\n     [[ -z \"$1\" ]] && return 1\n\n     # Check that $1 contains an IPv4 address and nothing else\n     [[ \"$1\" =~ $ipv4address ]] && [[ \"$1\" == $BASH_REMATCH ]] && \\\n          return 0 || \\\n          return 1\n}\n\n# See RFC 4291, Section 2.2\nis_ipv6addr() {\n     local ipv6seg=\"[0-9A-Fa-f]{1,4}\"\n     local octet=\"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\"\n     local ipv4address=\"$octet\\\\.$octet\\\\.$octet\\\\.$octet\"\n     local ipv6address\n\n     ipv6address=\"($ipv6seg:){7}(:|$ipv6seg)\"\n     ipv6address+=\"|($ipv6seg:){6}(:|:$ipv6seg|$ipv4address)\"\n     ipv6address+=\"|($ipv6seg:){5}(:|(:$ipv6seg){1,2}|:$ipv4address)\"\n     ipv6address+=\"|($ipv6seg:){4}(:|(:$ipv6seg){1,3}|:($ipv6seg:){0,1}$ipv4address)\"\n     ipv6address+=\"|($ipv6seg:){3}(:|(:$ipv6seg){1,4}|:($ipv6seg:){0,2}$ipv4address)\"\n     ipv6address+=\"|($ipv6seg:){2}(:|(:$ipv6seg){1,5}|:($ipv6seg:){0,3}$ipv4address)\"\n     ipv6address+=\"|($ipv6seg:){1}(:|(:$ipv6seg){1,6}|:($ipv6seg:){0,4}$ipv4address)\"\n     ipv6address+=\"|:((:$ipv6seg){1,7}|:($ipv6seg:){0,5}$ipv4address)\"\n\n     [[ -z \"$1\" ]] && return 1\n\n     # Check that $1 contains an IPv4 address and nothing else\n     [[ \"$1\" =~ $ipv6address ]] && [[ \"$1\" == $BASH_REMATCH ]] && \\\n          return 0 || \\\n          return 1\n}\n\njoin_by() {\n     # joins an array using a custom delimiter https://web.archive.org/web/20201222183540/https://stackoverflow.com/questions/1527049/how-can-i-join-elements-of-an-array-in-bash/17841619#17841619\n     local d=$1\n     shift\n     local f=$1\n     shift\n     printf %s \"$f\" \"${@/#/$d}\";\n}\n\n###### END universal helper function definitions ######\n\n###### START ServerHello/OpenSSL/F5 function definitions ######\n\n#arg1: TLS 1.2 and below ciphers\n#arg2: TLS 1.3 ciphers\n#arg3: options (e.g., -V)\nactually_supported_osslciphers() {\n     local ciphers=\"$1\"\n     local tls13_ciphers=\"$TLS13_OSSL_CIPHERS\"\n     local cipher tls13_supported_ciphers=\"\"\n     local options=\"$3 \"\n\n     [[ \"$2\" != ALL ]] && tls13_ciphers=\"$2\"\n     for cipher in ${tls13_ciphers//:/ }; do\n          [[ \"$TLS13_OSSL_CIPHERS\" =~ $cipher ]] && tls13_supported_ciphers+=\":$cipher\"\n     done\n     tls13_ciphers=\"${tls13_supported_ciphers:1}\"\n     \"$HAS_SECLEVEL\" && [[ -n \"$ciphers\" ]] && ciphers=\"@SECLEVEL=0:$1\"\n     # With OpenSSL 1.0.2 the only way to exclude SSLv2 ciphers is to use the -tls1 option.\n     # However, with newer versions of OpenSSL, the -tls1 option excludes TLSv1.2 ciphers.\n     if \"$HAS_SSL2\"; then\n          options=\"${options//-no_ssl2 /-tls1 }\"\n     else\n          options=\"${options//-no_ssl2 /}\"\n     fi\n     ! \"$HAS_TLS1\" && options=\"${options//-tls1 /}\"\n     if \"$HAS_CIPHERSUITES\"; then\n          $OPENSSL ciphers $options $OSSL_CIPHERS_S -ciphersuites \"$tls13_ciphers\" \"$ciphers\" 2>/dev/null || echo \"\"\n     elif [[ -n \"$tls13_ciphers\" ]]; then\n          $OPENSSL ciphers $options $OSSL_CIPHERS_S \"$tls13_ciphers:$ciphers\" 2>/dev/null || echo \"\"\n     else\n          $OPENSSL ciphers $OSSL_CIPHERS_S $options \"$ciphers\" 2>/dev/null || echo \"\"\n     fi\n}\n\n# Given a protocol (arg1) and a list of ciphers (arg2) that is formatted as\n# \", xx,xx, xx,xx, xx,xx, xx,xx\" remove any TLSv1.3 ciphers if the protocol\n# is less than 04 and remove any TLSv1.2-only ciphers if the protocol is less\n# than 03.\nstrip_inconsistent_ciphers() {\n     local -i proto=0x$1\n     local cipherlist=\"$2\"\n\n     if [[ $proto -lt 4 ]]; then\n          cipherlist=\"${cipherlist//, 13,0[0-9a-fA-F]/}\"\n          cipherlist=\"${cipherlist//, [cC]0,[bB][45]/}\"\n     fi\n     if [[ $proto -lt 3 ]]; then\n          cipherlist=\"${cipherlist//, 00,3[b-fB-F]/}\"\n          cipherlist=\"${cipherlist//, 00,40/}\"\n          cipherlist=\"${cipherlist//, 00,6[7-9a-dA-D]/}\"\n          cipherlist=\"${cipherlist//, 00,9[c-fC-F]/}\"\n          cipherlist=\"${cipherlist//, 00,[abAB][0-9a-fA-F]/}\"\n          cipherlist=\"${cipherlist//, 00,[cC][0-5]/}\"\n          cipherlist=\"${cipherlist//, 16,[bB][7-9aA]/}\"\n          cipherlist=\"${cipherlist//, [cC]0,2[3-9a-fA-F]/}\"\n          cipherlist=\"${cipherlist//, [cC]0,3[01278a-fA-F]/}\"\n          cipherlist=\"${cipherlist//, [cC]0,[4-9aA][0-9a-fA-F]/}\"\n          cipherlist=\"${cipherlist//, [cC][cC],1[345]/}\"\n          cipherlist=\"${cipherlist//, [cC][cC],[aA][89a-eA-E]/}\"\n     fi\n     echo \"$cipherlist\"\n     return 0\n}\n\n# retrieve cipher from ServerHello (via openssl)\nget_cipher() {\n     local cipher=\"\"\n     local server_hello=\"$(cat -v \"$1\")\"\n     # This and two other following instances are not best practice and normally a useless use of \"cat\", see\n     # https://web.archive.org/web/20160711205930/http://porkmail.org/era/unix/award.html#uucaletter\n     # However there seem to be cases where the preferred  $(< \"$1\")  logic has a problem.\n     # Especially with bash 3.2 (Mac OS X) and when on the server side binary chars\n     # are returned, see https://stackoverflow.com/questions/7427262/how-to-read-a-file-into-a-variable-in-shell#22607352\n     # and https://github.com/testssl/testssl.sh/issues/1292\n     # Performance measurements showed no to barely measurable penalty (1s displayed in 9 tries).\n\n     if [[ \"$server_hello\" =~ Cipher\\ *:\\ ([A-Z0-9]+-[A-Za-z0-9\\-]+|TLS_[A-Za-z0-9_]+|SSL_[A-Za-z0-9_]+) ]]; then\n          cipher=\"${BASH_REMATCH##* }\"\n     elif [[ \"$server_hello\" =~ (New|Reused)\", \"(SSLv[23]|TLSv1(\\.[0-3])?(\\/SSLv3)?)\", Cipher is \"([A-Z0-9]+-[A-Za-z0-9\\-]+|TLS_[A-Za-z0-9_]+) ]]; then\n          cipher=\"${BASH_REMATCH##* }\"\n     fi\n     tm_out \"$cipher\"\n}\n\n# retrieve protocol from ServerHello (via openssl)\nget_protocol() {\n     local protocol=\"\"\n     local server_hello=\"$(cat -v \"$1\")\"\n\n     if [[ \"$server_hello\" =~ Protocol\\ *:\\ (SSLv[23]|TLSv1(\\.[0-3])?) ]]; then\n          protocol=\"${BASH_REMATCH##* }\"\n     elif [[ \"$server_hello\" =~ (New|Reused)\", TLSv1.3, Cipher is \"TLS_[A-Z0-9_]+ ]]; then\n          # Note: When OpenSSL prints \"New, <protocol>, Cipher is <cipher>\", <cipher> is the\n          # negotiated cipher, but <protocol> is not the negotiated protocol. Instead, it is\n          # the SSL/TLS protocol that first defined <cipher>. Since the ciphers that were\n          # first defined for TLSv1.3 may only be used with TLSv1.3, this line may be used\n          # to determine whether TLSv1.3 was negotiated, but if another protocol is specified\n          # on this line, then this line does not indicate the actual protocol negotiated. Also,\n          # only TLSv1.3 cipher suites have names that begin with TLS_, which provides additional\n          # assurance that the above match will only succeed if TLSv1.3 was negotiated.\n          protocol=\"TLSv1.3\"\n     fi\n     tm_out \"$protocol\"\n}\n\n# now some function for the integrated BIGIP F5 Cookie detector (see https://github.com/drwetter/F5-BIGIP-Decoder)\n\nf5_hex2ip() {\n     debugme echo \"$1\"\n     echo $((16#${1:0:2})).$((16#${1:2:2})).$((16#${1:4:2})).$((16#${1:6:2}))\n}\nf5_hex2ip6() {\n     debugme echo \"$1\"\n     echo \"[${1:0:4}:${1:4:4}:${1:8:4}:${1:12:4}.${1:16:4}:${1:20:4}:${1:24:4}:${1:28:4}]\"\n}\n\nf5_determine_routeddomain() {\n     local tmp\n     tmp=\"${1%%o*}\"\n     echo \"${tmp/rd/}\"\n}\n\nf5_ip_oldstyle() {\n     local tmp\n     local a b c d\n\n     tmp=\"${1/%.*}\"                     # until first dot\n     tmp=\"$(printf \"%08x\" \"$tmp\")\"      # convert the whole thing to hex, now back to ip (reversed notation:\n     tmp=\"$(f5_hex2ip $tmp)\"            # transform to ip with reversed notation\n     IFS=\".\" read -r a b c d <<< \"$tmp\" # reverse it\n     echo $d.$c.$b.$a\n}\n\nf5_port_decode() {\n     local tmp\n\n     tmp=\"$(strip_lf \"$1\")\"             # remove lf if there is one\n     tmp=\"${tmp/.0000/}\"                # to be sure remove trailing zeros with a dot\n     tmp=\"${tmp#*.}\"                    # get the port\n     tmp=\"$(printf \"%04x\" \"${tmp}\")\"    # to hex\n     if [[ ${#tmp} -eq 4 ]]; then\n          :\n     elif [[ ${#tmp} -eq 3 ]]; then     # fill it up with leading zeros if needed\n          tmp=0${tmp}\n     elif [[ ${#tmp} -eq 2 ]]; then\n          tmp=00${tmp}\n     fi\n     echo $((16#${tmp:2:2}${tmp:0:2}))  # reverse order and convert it from hex to dec\n}\n\n###### END universal helper function definitions ######\n\n\n###### START scoring function definitions ######\n\n# Sets the grade cap to ARG1\n# arg1: A grade to set (\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"M\", or \"T\")\n# arg2: A reason why (e.g. \"Vulnerable to CRIME\")\nset_grade_cap() {\n     \"$do_rating\" || return 0\n     GRADE_CAP_REASONS+=(\"Grade capped to $1. $2\")\n\n     # Always set special attributes. These are hard caps, due to name mismatch or cert being invalid\n     if [[ \"$1\" == T || \"$1\" == M ]]; then\n          GRADE_CAP=\"$1\"\n     # Only keep track of the lowest grade cap, since a higher grade cap won't do anything (F = lowest, A = highest)\n     elif  [[ ! \"$GRADE_CAP\" > \"$1\" ]]; then\n          GRADE_CAP=\"$1\"\n     fi\n     return 0\n}\n\n# Sets a grade warning, as specified by the grade specification\n# arg1: A warning message\nset_grade_warning() {\n     \"$do_rating\" || return 0\n     GRADE_WARNINGS+=(\"$1\")\n     return 0\n}\n\n# Sets the score for Category 2 (Key Exchange Strength)\n# arg1: Short key algorithm (\"EC\", \"DH\", \"RSA\", ...), or \"DHE\" for ephemeral key size\n# arg2: key size (number of bits)\nset_key_str_score() {\n     local type=$1\n     local size=$2\n\n     \"$do_rating\" || return 0\n\n     if [[ $type == EC || $type == EdDSA ]]; then\n          if [[ $size -lt 110 ]] && [[ $KEY_EXCH_SCORE -ge 20 ]]; then\n               KEY_EXCH_SCORE=20\n          elif [[ $size -lt 123 ]] && [[ $KEY_EXCH_SCORE -ge 40 ]]; then\n               KEY_EXCH_SCORE=40\n          elif [[ $size -lt 163 ]] && [[ $KEY_EXCH_SCORE -ge 80 ]]; then\n               KEY_EXCH_SCORE=80\n          elif [[ $size -lt 225 ]] && [[ $KEY_EXCH_SCORE -ge 90 ]]; then\n               KEY_EXCH_SCORE=90\n          fi\n     else\n          if [[ $size -lt 512 ]] && [[ $KEY_EXCH_SCORE -ge 20 ]]; then\n               KEY_EXCH_SCORE=20\n          elif [[ $size -lt 1024 ]] && [[ $KEY_EXCH_SCORE -ge 40 ]]; then\n               KEY_EXCH_SCORE=40\n          elif [[ $size -lt 2048 ]] && [[ $KEY_EXCH_SCORE -ge 80 ]]; then\n               KEY_EXCH_SCORE=80\n          elif [[ $size -lt 4096 ]] && [[ $KEY_EXCH_SCORE -ge 90 ]]; then\n               KEY_EXCH_SCORE=90\n          fi\n     fi\n     return 0\n}\n\n# Sets the best and worst bit size key, used to grade Category 3 (Cipher Strength)\n# This function itself doesn't actually set a score; its just in the name to keep it logical (score == rating function)\n# arg1: a bit size\nset_ciph_str_score() {\n     local size=$1\n\n     \"$do_rating\" || return 0\n\n     [[ $size -gt $CIPH_STR_BEST ]] && CIPH_STR_BEST=$size\n     [[ $size -lt $CIPH_STR_WORST ]] && CIPH_STR_WORST=$size\n\n     [[ $size -lt 112 || $size == None ]] && set_grade_cap \"F\" \"Using cipher suites weaker than 112 bits\"\n\n     return 0\n}\n\n###### END scoring function definitions ######\n\n##################### START output file formatting functions #########################\n#################### START JSON file functions ####################\n\nfileout_json_footer() {\n     if \"$do_json\"; then\n          if [[ \"$SCAN_TIME\" -eq 0 ]]; then\n               fileout_json_finding \"scanTime\" \"WARN\" \"Scan interrupted\" \"\" \"\" \"\"\n          elif [[ $SEVERITY_LEVEL -lt $LOW ]] ; then\n               # no scan time in --severity=low and above, also needed for Travis, hackish...\n               fileout_json_finding \"scanTime\" \"INFO\" $SCAN_TIME \"\" \"\" \"\"\n          fi\n          printf \"]\\n\" >> \"$JSONFILE\"\n     fi\n     if \"$do_pretty_json\"; then\n          if [[ \"$SCAN_TIME\" -eq 0 ]]; then\n               echo -e \"          ],\\n                    \\\"scanTime\\\"  : \\\"Scan interrupted\\\"\\n}\" >> \"$JSONFILE\"\n          else\n               echo -e \"          ],\\n                    \\\"scanTime\\\"  : ${SCAN_TIME}\\n}\" >> \"$JSONFILE\"\n          fi\n     fi\n}\n\nfileout_json_section() {\n     case $1 in\n           0) echo -e    \"                    \\\"pretest\\\"           : [\" ;;\n           1) echo -e    \"                    \\\"singleCipher\\\"      : [\" ;;\n           2) echo -e \",\\n                    \\\"protocols\\\"         : [\" ;;\n           3) echo -e \",\\n                    \\\"grease\\\"            : [\" ;;\n           4) echo -e \",\\n                    \\\"ciphers\\\"           : [\" ;;\n           5) echo -e \",\\n                    \\\"serverPreferences\\\" : [\" ;;\n           6) echo -e \",\\n                    \\\"fs\\\"                : [\" ;;\n           7) echo -e \",\\n                    \\\"serverDefaults\\\"    : [\" ;;\n           8) echo -e \",\\n                    \\\"headerResponse\\\"    : [\" ;;\n           9) echo -e \",\\n                    \\\"vulnerabilities\\\"   : [\" ;;\n          10) echo -e \",\\n                    \\\"cipherTests\\\"       : [\" ;;\n          11) echo -e \",\\n                    \\\"browserSimulations\\\": [\" ;;\n          12) echo -e \",\\n                    \\\"rating\\\"            : [\" ;;\n           *) echo \"invalid section\" ;;\n     esac\n}\n\nfileout_section_header() {\n     local str=\"\"\n     \"$2\" && str=\"$(fileout_section_footer false)\"\n     \"$do_pretty_json\" && FIRST_FINDING=true && (printf \"%s%s\\n\" \"$str\" \"$(fileout_json_section \"$1\")\") >> \"$JSONFILE\"\n     SECTION_FOOTER_NEEDED=true\n}\n\n# arg1: whether to end object too\nfileout_section_footer() {\n     \"$do_pretty_json\" && FIRST_FINDING=false && printf \"\\n                    ]\" >> \"$JSONFILE\"\n     \"$do_pretty_json\" && \"$1\" && echo -e \"\\n          }\" >> \"$JSONFILE\"\n     SECTION_FOOTER_NEEDED=false\n}\n\nfileout_json_print_parameter() {\n     local parameter=\"$1\"\n     local filler=\"$2\"\n     local value=\"$3\"\n     local not_last=\"$4\"\n     local spaces=\"\"\n\n     \"$do_json\" && \\\n          spaces=\"              \" || \\\n          spaces=\"                                \"\n     if [[ -n \"$value\" ]] || [[ \"$parameter\" == finding ]]; then\n          if [[ \"$value\" =~ [[:cntrl:]] ]]; then\n               value=\"$(sanitize_fileout \"$value\")\"\n          fi\n          printf -- \"%b%b%b%b\" \"$spaces\" \"\\\"$parameter\\\"\" \"$filler\" \": \\\"$value\\\"\" >> \"$JSONFILE\"\n          \"$not_last\" && printf \",\\n\" >> \"$JSONFILE\"\n     fi\n}\n\nfileout_json_finding() {\n     local target\n     local finding=\"$3\"\n     local cve=\"$4\"\n     local cwe=\"$5\"\n     local hint=\"$6\"\n\n     if \"$do_json\"; then\n          \"$FIRST_FINDING\" || echo -n \",\" >> \"$JSONFILE\"\n          echo -e \"         {\"  >> \"$JSONFILE\"\n          fileout_json_print_parameter \"id\" \"           \" \"$1\" true\n          fileout_json_print_parameter \"ip\" \"           \" \"$NODE/$NODEIP\" true\n          fileout_json_print_parameter \"port\" \"         \" \"$PORT\" true\n          fileout_json_print_parameter \"severity\" \"     \" \"$2\" true\n          fileout_json_print_parameter \"cve\" \"          \" \"$cve\" true\n          fileout_json_print_parameter \"cwe\" \"          \" \"$cwe\" true\n          \"$GIVE_HINTS\" && fileout_json_print_parameter \"hint\" \"         \" \"$hint\" true\n          fileout_json_print_parameter \"finding\" \"      \" \"$finding\" false\n          echo -e \"\\n          }\" >> \"$JSONFILE\"\n     fi\n     if \"$do_pretty_json\"; then\n          if [[ \"$1\" == service ]]; then\n               if [[ $SERVER_COUNTER -gt 1 ]]; then\n                    echo \"          ,\" >> \"$JSONFILE\"\n               elif ! \"$FIRST_FINDING\"; then\n                    echo -n \",\" >> \"$JSONFILE\"\n               fi\n               target=\"$NODE\"\n               $do_mx_all_ips && target=\"$URI\"\n               echo -e \"          {\n                    \\\"targetHost\\\"      : \\\"$target\\\",\n                    \\\"ip\\\"              : \\\"$NODEIP\\\",\n                    \\\"port\\\"            : \\\"$PORT\\\",\n                    \\\"rDNS\\\"            : \\\"$rDNS\\\",\n                    \\\"service\\\"         : \\\"$finding\\\",\" >> \"$JSONFILE\"\n               $do_mx_all_ips && echo -e \"                    \\\"hostname\\\"        : \\\"$NODE\\\",\"  >> \"$JSONFILE\"\n          else\n               (\"$FIRST_FINDING\" && echo -n \"                            {\" >> \"$JSONFILE\") || echo -n \",{\" >> \"$JSONFILE\"\n               echo -e -n \"\\n\"  >> \"$JSONFILE\"\n               fileout_json_print_parameter \"id\" \"           \" \"$1\" true\n               fileout_json_print_parameter \"severity\" \"     \" \"$2\" true\n               fileout_json_print_parameter \"cve\" \"          \" \"$cve\" true\n               fileout_json_print_parameter \"cwe\" \"          \" \"$cwe\" true\n               \"$GIVE_HINTS\" && fileout_json_print_parameter \"hint\" \"         \" \"$hint\" true\n               fileout_json_print_parameter \"finding\" \"      \" \"$finding\" false\n               echo -e -n \"\\n                           }\" >> \"$JSONFILE\"\n          fi\n     fi\n}\n\nfileout_pretty_json_banner() {\n     local target\n\n     if ! \"$do_mass_testing\"; then\n          [[ -z \"$NODE\" ]] && parse_hn_port \"${URI}\"\n          # NODE, URL_PATH, PORT, IPADDR and IP46ADDR is set now  --> wrong place\n          target=\"$NODE\"\n          $do_mx_all_ips && target=\"$URI\"\n     fi\n\n     echo -e \"          \\\"Invocation\\\"  : \\\"$PROG_NAME $CMDLINE\\\",\n          \\\"at\\\"          : \\\"$HNAME:$OPENSSL_LOCATION\\\",\n          \\\"version\\\"     : \\\"$VERSION $GIT_REL_SHORT\\\",\n          \\\"openssl\\\"     : \\\"$OSSL_NAME $OSSL_VER from $OSSL_BUILD_DATE\\\",\n          \\\"startTime\\\"   : \\\"$START_TIME\\\",\n          \\\"scanResult\\\"  : [\"\n}\n\nfileout_banner() {\n     if \"$JSONHEADER\"; then\n          # \"$do_json\" &&                    # here we maybe should add a banner, too\n          \"$do_pretty_json\" && FIRST_FINDING=true && (printf \"%s\\n\" \"$(fileout_pretty_json_banner)\") >> \"$JSONFILE\"\n     fi\n}\n\nfileout_separator() {\n     if \"$JSONHEADER\"; then\n          \"$do_pretty_json\" && echo \"          ,\" >> \"$JSONFILE\"\n          \"$do_json\" && echo -n \",\" >> \"$JSONFILE\"\n     fi\n}\n\nfileout_footer() {\n     if \"$JSONHEADER\"; then\n          fileout_json_footer\n     fi\n     # CSV: no footer\n     return 0\n}\n\nfileout_insert_warning() {\n     # See #815. Make sure we don't mess up the JSON PRETTY format if we complain with a client side warning.\n     # This should only be called if an *extra* warning will be printed (previously: 'fileout <extra_warning_ID> \"WARN\" '\n     # arg1: json identifier,  arg2: normally \"WARN\",  arg3: finding\n     #\n     # Also, we have to be careful with any form of mass testing so that a warning won't lead to an invalid JSON\n     # file. As any child will do any check as well (to be reconsidered later), we don't need also the parent to issue\n     # warnings upfront, see #1169. As a detection we'll use --file/-iL as in the children jobs it'll be removed:\n     [[ \"$CMDLINE=\" =~ --file ]] && return 0\n     [[ \"$CMDLINE=\" =~ -iL ]] && return 0\n     # Note we still have the message on screen + in HTML which is not as optimal as it could be\n\n     # See #2599. The \"clientProblem\" wrapper should only be added if fileout_insert_warning()\n     # is called before fileout_banner(). The only instance in which this function is called\n     # after fileout_banner() is in the case of a TLS 1.3 only server when $OPENSSL does not\n     # support TLS 1.3.\n     if \"$do_pretty_json\" && \"$JSONHEADER\" && ! \"$TLS13_ONLY\"; then\n          echo -e \"          \\\"clientProblem${CLIENT_PROB_NO}\\\" : [\" >>\"$JSONFILE\"\n          CLIENT_PROB_NO=$((CLIENT_PROB_NO + 1))\n          FIRST_FINDING=true       # make sure we don't have a comma here\n     fi\n     fileout \"$1\" \"$2\" \"$3\"\n     if \"$do_pretty_json\" && ! \"$TLS13_ONLY\"; then\n          if \"$JSONHEADER\"; then\n               echo -e \"\\n          ],\" >>\"$JSONFILE\"\n          else\n               echo -e \", \" >>\"$JSONFILE\"\n          fi\n          FIRST_FINDING=true\n     fi\n}\n\n# args: \"id\" \"fqdn/ip\" \"port\" \"severity\" \"finding\" \"cve\" \"cwe\" \"hint\"\n#\nfileout_csv_finding() {\n     local finding=\"$5\"\n\n     if [[ \"$finding\" =~ [[:cntrl:]] ]]; then\n          finding=\"$(sanitize_fileout \"$finding\")\"\n     fi\n     safe_echo \"\\\"$1\\\",\" >> \"$CSVFILE\"\n     safe_echo \"\\\"$2\\\",\" >> \"$CSVFILE\"\n     safe_echo \"\\\"$3\\\",\" >> \"$CSVFILE\"\n     safe_echo \"\\\"$4\\\",\" >> \"$CSVFILE\"\n     safe_echo \"\\\"$finding\\\",\" >> \"$CSVFILE\"\n     safe_echo \"\\\"$6\\\",\" >> \"$CSVFILE\"\n     if \"$GIVE_HINTS\"; then\n          safe_echo \"\\\"$7\\\",\" >> \"$CSVFILE\"\n          safe_echo \"\\\"$8\\\"\\n\" >> \"$CSVFILE\"\n     else\n          safe_echo \"\\\"$7\\\"\\n\" >> \"$CSVFILE\"\n     fi\n}\n\n\n# ID, SEVERITY, FINDING, CVE, CWE, HINT\nfileout() {\n     local severity=\"$2\"\n     local cve=\"$4\"\n     local cwe=\"$5\"\n     local hint=\"$6\"\n\n     if { \"$do_pretty_json\" && [[ \"$1\" == service ]]; } || show_finding \"$severity\"; then\n          local finding=$(strip_lf \"$(newline_to_spaces \"$(strip_quote \"$3\")\")\")           # additional quotes will mess up screen output\n          [[ -e \"$JSONFILE\" ]] && [[ ! -d \"$JSONFILE\" ]] && fileout_json_finding \"$1\" \"$severity\" \"$finding\" \"$cve\" \"$cwe\" \"$hint\"\n          \"$do_csv\" && [[ -n \"$CSVFILE\" ]] && [[ ! -d \"$CSVFILE\" ]] && \\\n               fileout_csv_finding \"$1\" \"$NODE/$NODEIP\" \"$PORT\" \"$severity\" \"$finding\" \"$cve\" \"$cwe\" \"$hint\"\n          \"$FIRST_FINDING\" && FIRST_FINDING=false\n     fi\n}\n\n\njson_header() {\n     local fname_prefix\n     local filename_provided=false\n\n     if [[ -n \"$PARENT_JSONFILE\" ]]; then\n          [[ -n \"$JSONFILE\" ]] && fatal_cmd_line \"Can't write to both $PARENT_JSONFILE and $JSONFILE\" $ERR_CMDLINE\n          JSONFILE=\"$PARENT_JSONFILE\"\n     fi\n     [[ -n \"$JSONFILE\" ]] && [[ ! -d \"$JSONFILE\" ]] && filename_provided=true\n     # Similar to HTML: Don't create headers and footers in the following scenarios:\n     #  * no JSON/CSV output is being created.\n     #  * mass testing is being performed and each test will have its own file.\n     #  * this is an individual test within a mass test and all output is being placed in a single file.\n     ! \"$do_json\" && ! \"$do_pretty_json\" && JSONHEADER=false && return 0\n     \"$do_mass_testing\" && ! \"$filename_provided\" && JSONHEADER=false && return 0\n     \"$CHILD_MASS_TESTING\" && \"$filename_provided\" && [[ -n \"$PARENT_JSONFILE\" ]] && JSONHEADER=false && return 0\n\n     if \"$do_display_only\"; then\n          fname_prefix=\"local-ciphers\"\n     elif \"$do_mass_testing\"; then\n          :\n     elif \"$do_mx_all_ips\"; then\n          fname_prefix=\"${FNAME_PREFIX}mx-${URI}\"\n     else\n          # ensure NODE, URL_PATH, PORT, IPADDR and IP46ADDR are set\n          ! \"$filename_provided\" && [[ -z \"$NODE\" ]] && parse_hn_port \"${URI}\"\n          fname_prefix=\"${FNAME_PREFIX}${NODE}_p${PORT}\"\n     fi\n     if [[ -z \"$JSONFILE\" ]]; then\n          JSONFILE=\"$fname_prefix-$(date +\"%Y%m%d-%H%M\".json)\"\n     elif [[ -d \"$JSONFILE\" ]]; then\n          JSONFILE=\"$JSONFILE/${fname_prefix}-$(date +\"%Y%m%d-%H%M\".json)\"\n     fi\n     # Silently reset APPEND var if the file doesn't exist as otherwise it won't be created\n     if \"$APPEND\" && [[ ! -s \"$JSONFILE\" ]]; then\n          APPEND=false\n     fi\n     if \"$APPEND\"; then\n          JSONHEADER=false\n     else\n          if [[ -s \"$JSONFILE\" ]]; then\n               \"$OVERWRITE\" || fatal_cmd_line \"non-empty \\\"$JSONFILE\\\" exists. Either use \\\"--append\\\" or (re)move it\" $ERR_FCREATE\n               cp /dev/null \"$JSONFILE\"\n          fi\n          \"$do_json\" && echo \"[\" > \"$JSONFILE\"\n          \"$do_pretty_json\" && echo \"{\" > \"$JSONFILE\"\n     fi\n     return 0\n}\n\n\ncsv_header() {\n     local fname_prefix\n     local filename_provided=false\n\n     if [[ -n \"$PARENT_CSVFILE\" ]]; then\n          [[ -n \"$CSVFILE\" ]] && fatal_cmd_line \"Can't write to both $PARENT_CSVFILE and $CSVFILE\" $ERR_CMDLINE\n          CSVFILE=\"$PARENT_CSVFILE\"\n     fi\n     [[ -n \"$CSVFILE\" ]] && [[ ! -d \"$CSVFILE\" ]] && filename_provided=true\n     # CSV similar to JSON\n     ! \"$do_csv\" && CSVHEADER=false && return 0\n     \"$do_mass_testing\" && ! \"$filename_provided\" && CSVHEADER=false && return 0\n     \"$CHILD_MASS_TESTING\" && \"$filename_provided\" && [[ -n \"$PARENT_CSVFILE\" ]] && CSVHEADER=false && return 0\n\n     if \"$do_display_only\"; then\n          fname_prefix=\"local-ciphers\"\n     elif \"$do_mass_testing\"; then\n          :\n     elif \"$do_mx_all_ips\"; then\n          fname_prefix=\"${FNAME_PREFIX}mx-${URI}\"\n     else\n          # ensure NODE, URL_PATH, PORT, IPADDR and IP46ADDR are set\n          ! \"$filename_provided\" && [[ -z \"$NODE\" ]] && parse_hn_port \"${URI}\"\n          fname_prefix=\"${FNAME_PREFIX}${NODE}_p${PORT}\"\n     fi\n     if [[ -z \"$CSVFILE\" ]]; then\n          CSVFILE=\"${fname_prefix}-$(date +\"%Y%m%d-%H%M\".csv)\"\n     elif [[ -d \"$CSVFILE\" ]]; then\n          CSVFILE=\"$CSVFILE/${fname_prefix}-$(date +\"%Y%m%d-%H%M\".csv)\"\n     fi\n     # Silently reset APPEND var if the file doesn't exist as otherwise it won't be created\n     if \"$APPEND\" && [[ ! -s \"$CSVFILE\" ]]; then\n          APPEND=false\n     fi\n     if \"$APPEND\"; then\n          CSVHEADER=false\n     else\n          if [[ -s \"$CSVFILE\" ]]; then\n               \"$OVERWRITE\" || fatal_cmd_line \"non-empty \\\"$CSVFILE\\\" exists. Either use \\\"--append\\\" or (re)move it\" $ERR_FCREATE\n               cp /dev/null \"$CSVFILE\"\n          fi\n          touch \"$CSVFILE\"\n          if \"$GIVE_HINTS\"; then\n               fileout_csv_finding \"id\" \"fqdn/ip\" \"port\" \"severity\" \"finding\" \"cve\" \"cwe\" \"hint\"\n          else\n               fileout_csv_finding \"id\" \"fqdn/ip\" \"port\" \"severity\" \"finding\" \"cve\" \"cwe\"\n          fi\n     fi\n     return 0\n}\n\n\n################# END JSON file functions. START HTML functions ####################\n\nhtml_header() {\n     local fname_prefix\n     local filename_provided=false\n\n     if [[ -n \"$PARENT_HTMLFILE\" ]]; then\n          [[ -n \"$HTMLFILE\" ]] && fatal_cmd_line \"Can't write to both $PARENT_HTMLFILE and $HTMLFILE\" $ERR_CMDLINE\n          HTMLFILE=\"$PARENT_HTMLFILE\"\n     fi\n     [[ -n \"$HTMLFILE\" ]] && [[ ! -d \"$HTMLFILE\" ]] && filename_provided=true\n     # Don't create HTML headers and footers in the following scenarios:\n     #  * HTML output is not being created.\n     #  * mass testing is being performed and each test will have its own HTML file.\n     #  * this is an individual test within a mass test and all HTML output is being placed in a single file.\n     ! \"$do_html\" && HTMLHEADER=false && return 0\n     \"$do_mass_testing\" && ! \"$filename_provided\" && HTMLHEADER=false && return 0\n     \"$CHILD_MASS_TESTING\" && \"$filename_provided\" && [[ -n \"$PARENT_HTMLFILE\" ]] && HTMLHEADER=false && return 0\n\n     if \"$do_display_only\"; then\n          fname_prefix=\"local-ciphers\"\n     elif \"$do_mass_testing\"; then\n          :\n     elif \"$do_mx_all_ips\"; then\n          fname_prefix=\"${FNAME_PREFIX}mx-${URI}\"\n     else\n          # ensure NODE, URL_PATH, PORT, IPADDR and IP46ADDR are set\n          ! \"$filename_provided\" && [[ -z \"$NODE\" ]] && parse_hn_port \"${URI}\"\n          fname_prefix=\"${FNAME_PREFIX}${NODE}_p${PORT}\"\n     fi\n     if [[ -z \"$HTMLFILE\" ]]; then\n          HTMLFILE=\"$fname_prefix-$(date +\"%Y%m%d-%H%M\".html)\"\n     elif [[ -d \"$HTMLFILE\" ]]; then\n          HTMLFILE=\"$HTMLFILE/$fname_prefix-$(date +\"%Y%m%d-%H%M\".html)\"\n     fi\n     # Silently reset APPEND var if the file doesn't exist as otherwise it won't be created\n     if \"$APPEND\" && [[ ! -s \"$HTMLFILE\" ]]; then\n          APPEND=false\n     fi\n     if \"$APPEND\"; then\n          HTMLHEADER=false\n     else\n          if [[ -s \"$HTMLFILE\" ]]; then\n               \"$OVERWRITE\" || fatal_cmd_line \"non-empty \\\"$HTMLFILE\\\" exists. Either use \\\"--append\\\" or (re)move it\" $ERR_FCREATE\n               cp /dev/null \"$HTMLFILE\"\n          fi\n          html_out \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"\n          html_out \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\\n\"\n          html_out \"<!-- This file was created with testssl.sh. https://testssl.sh -->\\n\"\n          html_out \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n\"\n          html_out \"<head>\\n\"\n          html_out \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"application/xhtml+xml; charset=UTF-8\\\" />\\n\"\n          html_out \"<title>testssl.sh</title>\\n\"\n          html_out \"</head>\\n\"\n          html_out \"<body>\\n\"\n          html_out \"<pre>\\n\"\n     fi\n     return 0\n}\n\nhtml_banner() {\n     if \"$CHILD_MASS_TESTING\" && \"$HTMLHEADER\"; then\n          html_out \"## Scan started as: \\\"$PROG_NAME $CMDLINE\\\"\\n\"\n          html_out \"## at $HNAME:$OPENSSL_LOCATION\\n\"\n          html_out \"## version testssl: $VERSION ${GIT_REL_SHORT} from $REL_DATE\\n\"\n          html_out \"## version openssl: \\\"$OSSL_NAME $OSSL_VER\\\" from \\\"$OSSL_BUILD_DATE\\\")\\n\\n\"\n     fi\n}\n\nhtml_footer() {\n     if \"$HTMLHEADER\"; then\n          html_out \"</pre>\\n\"\n          html_out \"</body>\\n\"\n          html_out \"</html>\\n\"\n     fi\n     return 0\n}\n\n################# END HTML file functions ####################\n\nprepare_logging() {\n     # arg1: for testing mx records name we put a name of logfile in here, otherwise we get strange file names\n     local fname_prefix=\"$1\"\n     local filename_provided=false\n\n     if [[ -n \"$PARENT_LOGFILE\" ]]; then\n          [[ -n \"$LOGFILE\" ]] && fatal_cmd_line \"Can't write to both $PARENT_LOGFILE and $LOGFILE\" $ERR_CMDLINE\n          LOGFILE=\"$PARENT_LOGFILE\"\n     fi\n     [[ -n \"$LOGFILE\" ]] && [[ ! -d \"$LOGFILE\" ]] && filename_provided=true\n\n     # Similar to html_header():\n     ! \"$do_logging\" && return 0\n     \"$do_mass_testing\" && ! \"$filename_provided\" && return 0\n     \"$CHILD_MASS_TESTING\" && \"$filename_provided\" && [[ -n \"$PARENT_LOGFILE\" ]] && return 0\n\n     [[ -z \"$fname_prefix\" ]] && fname_prefix=\"${FNAME_PREFIX}${NODE}_p${PORT}\"\n\n     if [[ -z \"$LOGFILE\" ]]; then\n          LOGFILE=\"$fname_prefix-$(date +\"%Y%m%d-%H%M\".log)\"\n     elif [[ -d \"$LOGFILE\" ]]; then\n          # actually we were instructed to place all files in a DIR instead of the current working dir\n          LOGFILE=\"$LOGFILE/$fname_prefix-$(date +\"%Y%m%d-%H%M\".log)\"\n     else\n          : # just for clarity: a log file was specified, no need to do anything else\n     fi\n\n     if ! \"$APPEND\"; then\n          if [[ -s \"$LOGFILE\" ]]; then\n               \"$OVERWRITE\" || fatal_cmd_line \"non-empty \\\"$LOGFILE\\\" exists. Either use \\\"--append\\\" or (re)move it\" $ERR_FCREATE\n               cp /dev/null \"$LOGFILE\"\n          fi\n     fi\n     tmln_out \"## Scan started as: \\\"$PROG_NAME $CMDLINE\\\"\" >>\"$LOGFILE\"\n     tmln_out \"## at $HNAME:$OPENSSL_LOCATION\" >>\"$LOGFILE\"\n     tmln_out \"## version testssl: $VERSION ${GIT_REL_SHORT} from $REL_DATE\" >>\"$LOGFILE\"\n     tmln_out \"## version openssl: \\\"$OSSL_VER\\\" from \\\"$OSSL_BUILD_DATE\\\")\\n\" >>\"$LOGFILE\"\n     exec > >(tee -a -i \"$LOGFILE\")\n}\n\n################### END all file output functions #########################\n\n# prints a string of n spaces (n < 80)\nprint_n_spaces() {\n     local -i n=\"$1\"\n     local spaces=\"                                                                                \"\n\n     out \"${spaces:0:n}\"\n}\n\n# prints out multiple lines in $1, left aligned by spaces in $2\nout_row_aligned() {\n     local first=true\n\n     while read line; do\n          \"$first\" && \\\n               first=false || \\\n               out \"$2\"\n          outln \"$line\"\n     done <<< \"$1\"\n}\n\n# prints text over multiple lines, trying to make no line longer than $max_width.\n# Each line is indented with $spaces.\nout_row_aligned_max_width() {\n     local text=\"$1\"\n     local spaces=\"$2\"\n     local -i max_width=\"$3\"\n     local -i i len\n     local cr=$'\\n'\n     local line\n     local first=true\n\n     max_width=$max_width-${#spaces}\n     len=${#text}\n     while true; do\n          if [[ $len -lt $max_width ]]; then\n               # If the remaining text to print is shorter than $max_width,\n               # then just print it.\n               i=$len\n          else\n               # Find the final space character in the text that is less than\n               # $max_width characters into the remaining text, and make the\n               # text up to that space character the next line to print.\n               line=\"${text:0:max_width}\"\n               line=\"${line% *}\"\n               i=\"${#line}\"\n               if [[ $i -eq $max_width ]]; then\n                    # If there are no space characters in the first $max_width\n                    # characters of the remaining text, then make the text up\n                    # to the first space the next line to print. If there are\n                    # no space characters in the remaining text, make the\n                    # remaining text the next line to print.\n                    line=\"${text#* }\"\n                    i=$len-${#line}\n                    [[ $i -eq 0 ]] && i=$len\n               fi\n          fi\n          if ! \"$first\"; then\n               tm_out \"${cr}${spaces}\"\n          fi\n          tm_out \"${text:0:i}\"\n          [[ $i -eq $len ]] && break\n          len=$len-$i-1\n          i+=1\n          text=\"${text:i:len}\"\n          first=false\n          [[ $len -eq 0 ]] && break\n     done\n     return 0\n}\n\nout_row_aligned_max_width_by_entry() {\n     local text=\"$1\"\n     local spaces=\"$2\"\n     local -i max_width=\"$3\"\n     local print_function=\"$4\"\n     local resp entry prev_entry=\" \"\n\n     resp=\"$(out_row_aligned_max_width \"$text\" \"$spaces\" \"$max_width\")\"\n     while read -d \" \" entry; do\n          if [[ -n \"$entry\" ]]; then\n               $print_function \"$entry\"\n          elif [[ -n \"$prev_entry\" ]]; then\n               outln; out \" \"\n          fi\n          out \" \"\n          prev_entry=\"$entry\"\n     done <<< \"$resp\"\n}\n\nprint_fixed_width() {\n     local text=\"$1\"\n     local -i len width=\"$2\"\n     local print_function=\"$3\"\n\n     len=${#text}\n     $print_function \"$text\"\n     print_n_spaces \"$((width-len+1))\"\n}\n\n# saves $TMPFILE or file supplied in $2 under name \"$TEMPDIR/$NODEIP.$1\".\n# Note: after finishing $TEMPDIR will be removed unless DEBUG >=1\ntmpfile_handle() {\n     local savefile=\"$2\"\n     [[ -z \"$savefile\" ]] && savefile=$TMPFILE\n#FIXME: make sure/find out if we do not need $TEMPDIR/$NODEIP.$1\" if debug=0. We would save fs access here\n     mv $savefile \"$TEMPDIR/$NODEIP.$1\" 2>/dev/null\n     [[ $ERRFILE =~ dev.null ]] && return 0 || \\\n          mv $ERRFILE \"$TEMPDIR/$NODEIP.${1//.txt/}.errorlog\" 2>/dev/null\n     return 0\n}\n\n# arg1: line with comment sign, tabs and so on\nfilter_input() {\n     sed -e 's/#.*$//' -e '/^$/d' <<< \"$1\" | tr -d '\\n' | tr -d '\\t' | tr -d '\\r'\n}\n\n# Dl's any URL (arg1) via HTTP 1.1 GET from port 80, arg2: file to store http body.\n# Proxy is not honored yet (see cmd line switches) -- except when using curl or wget.\n# There the environment variable is used automatically\n# Currently it is being used by check_revocation_crl() only.\nhttp_get() {\n     local proto z\n     local node=\"\" query=\"\"\n     local dl=\"$2\"\n     local useragent=\"$UA_STD\"\n     local jsonID=\"http_get\"\n\n     \"$SNEAKY\" && useragent=\"$UA_SNEAKY\"\n\n     if type -p curl &>/dev/null; then\n          if [[ -z \"$PROXY\" ]]; then\n               curl -s --noproxy '*' -A $''\"$useragent\"'' -o $dl \"$1\"\n          else\n               # for the sake of simplicity assume the proxy is using http\n               curl -s -x $PROXYIP:$PROXYPORT -A $''\"$useragent\"'' -o $dl \"$1\"\n          fi\n          return $?\n     elif type -p wget &>/dev/null; then\n          # wget has no proxy command line. We need to use http_proxy instead. And for the sake of simplicity\n          # assume the GET protocol we query is using http -- http_proxy is the $ENV not for the connection TO\n          # the proxy, but for the protocol we query THROUGH the proxy\n          if [[ -z \"$PROXY\" ]]; then\n               wget --no-proxy -q -U $''\"$useragent\"'' -O $dl \"$1\"\n          else\n               if [[ -z \"$http_proxy\" ]]; then\n                    http_proxy=http://$PROXYIP:$PROXYPORT wget -q -U $''\"$useragent\"'' -O $dl \"$1\"\n               else\n                    wget -q -U $''\"$useragent\"'' -O $dl \"$1\"\n               fi\n          fi\n          return $?\n     else\n          # Worst option: slower and hiccups with chunked transfers. Workaround for the\n          # latter is using HTTP/1.0. We do not support https here, yet.\n          # First the URL will be split\n          IFS=/ read -r proto z node query <<< \"$1\"\n          proto=${proto%:}\n          if [[ \"$proto\" != http ]]; then\n               pr_warning \"protocol $proto not supported yet\"\n               fileout \"$jsonID\" \"DEBUG\" \"protocol $proto not supported yet\"\n               return 6\n          fi\n          if [[ -n $PROXY ]]; then\n               # PROXYNODE works better than PROXYIP on modern versions of squid. \\\n               # We don't reuse the code in fd_socket() as there's initial CONNECT which makes problems\n               if ! exec 33<> /dev/tcp/${PROXYNODE}/${PROXYPORT}; then\n                    outln\n                    pr_warning \"$PROG_NAME: unable to open a socket to proxy $PROXYNODE:$PROXYPORT\"\n                    fileout \"$jsonID\" \"DEBUG\" \"$PROG_NAME: unable to open a socket to proxy $PROXYNODE:$PROXYPORT\"\n                    return 6\n               else\n                    printf -- \"%b\" \"GET $proto://$node/$query HTTP/1.0\\r\\nUser-Agent: $useragent\\r\\nHost: $node\\r\\nAccept: */*\\r\\n\\r\\n\" >&33\n               fi\n          else\n               IFS=/ read -r proto z node query <<< \"$1\"\n               exec 33<>/dev/tcp/$node/80\n               printf -- \"%b\" \"GET /$query HTTP/1.0\\r\\nUser-Agent: $useragent\\r\\nHost: $node\\r\\nAccept: */*\\r\\n\\r\\n\" >&33\n          fi\n          # Strip HTTP header. When in Debug Mode we leave the raw data in place\n          if [[ $DEBUG -ge 1 ]]; then\n               cat <&33 >${dl}.raw\n               cat ${dl}.raw | sed '1,/^[[:space:]]*$/d' >${dl}\n          else\n               cat <&33 | sed '1,/^[[:space:]]*$/d' >${dl}\n          fi\n          exec 33<&-\n          exec 33>&-\n          [[ -s \"$dl\" ]] && return 0 || return 1\n     fi\n}\n\n# Outputs the headers when downloading any URL (arg1) via HTTP 1.1 GET from port 80.\n# Only works if curl or wget is available.\n# There the environment variable is used automatically\n# Currently it is being used by check_pwnedkeys() only.\nhttp_get_header() {\n     local proto\n     local node=\"\" query=\"\"\n     local dl=\"$2\"\n     local useragent=\"$UA_STD\"\n     local jsonID=\"http_get_header\"\n     local headers\n     local -i ret\n\n     \"$SNEAKY\" && useragent=\"$UA_SNEAKY\"\n\n     if type -p curl &>/dev/null; then\n          if [[ -z \"$PROXY\" ]]; then\n               headers=\"$(curl --head -s  --noproxy '*' -A $''\"$useragent\"'' \"$1\")\"\n          else\n               # for the sake of simplicity assume the proxy is using http\n               headers=\"$(curl --head -s -x $PROXYIP:$PROXYPORT -A $''\"$useragent\"'' \"$1\")\"\n          fi\n          ret=$?\n          [[ $ret -eq 0 ]] && tm_out \"$headers\"\n          return $ret\n     elif type -p wget &>/dev/null; then\n          # wget has no proxy command line. We need to use http_proxy instead. And for the sake of simplicity\n          # assume the GET protocol we query is using http -- http_proxy is the $ENV not for the connection TO\n          # the proxy, but for the protocol we query THROUGH the proxy\n          if [[ -z \"$PROXY\" ]]; then\n               headers=\"$(wget --no-proxy -q -S -U $''\"$useragent\"'' -O /dev/null \"$1\" 2>&1)\"\n          else\n               if [[ -z \"$http_proxy\" ]]; then\n                    headers=\"$(http_proxy=http://$PROXYIP:$PROXYPORT wget -q -S  -U $''\"$useragent\"'' -O /dev/null \"$1\" 2>&1)\"\n               else\n                    headers=\"$(wget -q -S -U $''\"$useragent\"'' -O /dev/null \"$1\" 2>&1)\"\n               fi\n          fi\n          ret=$?\n          [[ $ret -eq 0 ]] && tm_out \"$headers\"\n          # wget(1): \"8: Server issued an error response.\". Happens e.g. when 404 is returned. However also if the call wasn't correct (400)\n          # So we assume for now that everything is submitted correctly. We parse the error code too later\n          [[ $ret -eq 8 ]] && ret=0 && tm_out \"$headers\"\n          return $ret\n     else\n          return 1\n     fi\n}\n\nldap_get() {\n     local ldif\n     local -i success\n     local crl=\"$1\"\n     local tmpfile=\"$2\"\n     local jsonID=\"$3\"\n\n     if type -p curl &>/dev/null; then\n          # proxy handling?\n          ldif=\"$(curl -s \"$crl\")\"\n          [[ $? -eq 0 ]] || return 1\n          awk '/certificateRevocationList/ { print $2 }' <<< \"$ldif\" | $OPENSSL base64 -d -A -out \"$tmpfile\" 2>/dev/null\n          [[ -s \"$tmpfile\" ]] || return 1\n          return 0\n     else\n          pr_litecyan \" (for LDAP CRL check install \\\"curl\\\")\"\n          fileout \"$jsonID\" \"INFO\" \"LDAP CRL revocation check needs \\\"curl\\\"\"\n          return 2\n     fi\n}\n\n# checks whether the public key in arg1 appears in the https://pwnedkeys.com/ database.\n# arg1: file containing certificate\n# arg2: public key algorithm\n# arg3 key size\n# Responses are as follows:\n#     0 - not checked\n#     1 - key not found in database\n#     2 - key found in database\n#     7 - network/proxy failure\ncheck_pwnedkeys() {\n     local cert=\"$1\"\n     local cert_key_algo=\"$2\"\n     local -i cert_keysize=\"$3\"\n     local pubkey curve response\n\n     \"$PHONE_OUT\" || return 0\n\n     # https://pwnedkeys.com only keeps records on 1024 bit and larger RSA keys,\n     # as well as elliptic-curve keys on the P-256, P-384, and P-521 curves.\n     if [[ \"$cert_key_algo\" =~ RSA ]] || [[ \"$cert_key_algo\" =~ rsa ]]; then\n          [[ $cert_keysize -ge 1024 ]] || return 0\n     elif [[ \"$cert_key_algo\" =~ ecdsa ]] || [[ \"$cert_key_algo\" == *ecPublicKey ]]; then\n          [[ $cert_keysize -eq 256 ]] || [[ $cert_keysize -eq 384 ]] || \\\n               [[ $cert_keysize -eq 521 ]] || return 0\n     else\n          return 0\n     fi\n\n     pubkey=\"$($OPENSSL x509 -in \"$cert\" -pubkey -noout 2>/dev/null)\"\n     # If it is an elliptic curve key, check that it is P-256, P-384, or P-521.\n     if [[ \"$cert_key_algo\" =~ ecdsa ]] || [[ \"$cert_key_algo\" == *ecPublicKey ]]; then\n          curve=\"$($OPENSSL ec -pubin -text <<< \"$pubkey\" 2>/dev/null)\"\n          curve=\"${curve#*ASN1 OID: }\"\n          [[ \"$curve\" == prime256v1* ]] || [[ \"$curve\" == secp384r1* ]] || \\\n               [[ \"$curve\" == secp521r1* ]] || return 0\n     fi\n     fingerprint=\"$($OPENSSL pkey -pubin -outform DER <<< \"$pubkey\" 2>/dev/null | $OPENSSL dgst -sha256 -hex 2>/dev/null)\"\n     fingerprint=\"${fingerprint#*= }\"\n     response=\"$(http_get_header \"https://v1.pwnedkeys.com/$fingerprint\")\"\n     # Handle curl's/wget's connectivity exit codes\n     case $? in\n          4|5|7)     return 7 ;;\n          1|2|3|6)   return 0 ;;\n                     # unknown codes we just say \"not checked\"\n     esac\n     if [[ \"$response\" =~ \"404 Not Found\" ]]; then\n          return 1\n     elif [[ \"$response\" =~ \"200 OK\" ]]; then\n          return 2\n     else\n          return 0\n     fi\n}\n\ncheck_revocation_crl() {\n     local crl=\"$1\"\n     local jsonID=\"$2\"\n     local tmpfile=\"\"\n     local scheme retcode\n     local -i success\n\n     \"$PHONE_OUT\" || return 0\n     [[ -n \"$GOOD_CA_BUNDLE\" ]] || return 0\n     scheme=\"$(tolower \"${crl%%://*}\")\"\n     # The code for obtaining CRLs only supports LDAP, HTTP, and HTTPS URLs.\n     [[ \"$scheme\" == http ]] || [[ \"$scheme\" == https ]] || [[ \"$scheme\" == ldap ]] || return 0\n     tmpfile=$TEMPDIR/${NODE}-${NODEIP}.${crl##*\\/} || exit $ERR_FCREATE\n     if [[ \"$scheme\" == ldap ]]; then\n          ldap_get \"$crl\" \"$tmpfile\" \"$jsonID\"\n          success=$?\n     else\n          http_get \"$crl\" \"$tmpfile\"\n          success=$?\n     fi\n     if [[ $success -eq 2 ]]; then\n          return 0\n     elif [[ $success -ne 0 ]]; then\n          out \", \"\n          pr_warning \"retrieval of \\\"$crl\\\" failed\"\n          fileout \"$jsonID\" \"WARN\" \"CRL retrieval from $crl failed\"\n          return 1\n     fi\n     # -crl_download could be more elegant but is supported from 1.0.2 onwards only\n     $OPENSSL crl -inform DER -in \"$tmpfile\" -outform PEM -out \"${tmpfile%%.crl}.pem\" &>$ERRFILE\n     if [[ $? -ne 0 ]]; then\n          if grep -qe 'BEGIN X509 CRL' \"$tmpfile\"; then\n               mv \"$tmpfile\" \"${tmpfile%%.crl}.pem\"\n          else\n               pr_warning \"conversion of \\\"$tmpfile\\\" failed\"\n               fileout \"$jsonID\" \"WARN\" \"conversion of CRL to PEM format failed\"\n               return 1\n          fi\n     fi\n     if grep -qe '-----BEGIN CERTIFICATE-----' $TEMPDIR/intermediatecerts.pem; then\n          $OPENSSL verify -crl_check -CAfile <(cat $ADDTL_CA_FILES \"$GOOD_CA_BUNDLE\" \"${tmpfile%%.crl}.pem\") -untrusted $TEMPDIR/intermediatecerts.pem $HOSTCERT &> \"${tmpfile%%.crl}.err\"\n     else\n          $OPENSSL verify -crl_check -CAfile <(cat $ADDTL_CA_FILES \"$GOOD_CA_BUNDLE\" \"${tmpfile%%.crl}.pem\") $HOSTCERT &> \"${tmpfile%%.crl}.err\"\n     fi\n     if [[ $? -eq 0 ]]; then\n          out \", \"\n          pr_svrty_good \"not revoked\"\n          fileout \"$jsonID\" \"OK\" \"not revoked\"\n     else\n          retcode=$(awk '/error [1-9][0-9]? at [0-9]+ depth lookup:/ { if (!found) {print $2; found=1} }' \"${tmpfile%%.crl}.err\")\n          if [[ \"$retcode\" == 23 ]]; then # see verify_retcode_helper()\n               out \", \"\n               pr_svrty_critical \"revoked\"\n               fileout \"$jsonID\" \"CRITICAL\" \"revoked\"\n               set_grade_cap \"T\" \"Certificate revoked\"\n          else\n               retcode=\"$(verify_retcode_helper \"$retcode\")\"\n               out \" $retcode\"\n               retcode=\"${retcode#(}\"\n               retcode=\"${retcode%)}\"\n               fileout \"$jsonID\" \"WARN\" \"$retcode\"\n               set_grade_cap \"T\" \"Issues with certificate $retcode\"\n               if [[ $DEBUG -ge 2 ]]; then\n                    outln\n                    cat \"${tmpfile%%.crl}.err\"\n               fi\n          fi\n     fi\n     return 0\n}\n\ncheck_revocation_ocsp() {\n     local uri=\"$1\"\n     local stapled_response=\"$2\"\n     local jsonID=\"$3\"\n     local tmpfile=\"\"\n     local -i success=1\n     local response=\"\"\n     local host_header=\"\"\n\n     \"$PHONE_OUT\" || [[ -n \"$stapled_response\" ]] || return 0\n     [[ -n \"$GOOD_CA_BUNDLE\" ]] || return 0\n     if [[ -n \"$PROXY\" ]] && ! \"$IGN_OCSP_PROXY\"; then\n          # see #1106 and https://github.com/openssl/openssl/issues/6965\n          out \", \"\n          pr_warning \"revocation not tested as \\\"openssl ocsp\\\" doesn't support a proxy\"\n          fileout \"$jsonID\" \"WARN\" \"Revocation not tested as openssl ocsp doesn't support a proxy\"\n          return 0\n     fi\n     grep -qe '-----BEGIN CERTIFICATE-----' $TEMPDIR/intermediatecerts.pem || return 0\n     tmpfile=$TEMPDIR/${NODE}-${NODEIP}.${uri##*\\/} || exit $ERR_FCREATE\n     if [[ -n \"$stapled_response\" ]]; then\n          hex2binary \"$stapled_response\" > \"$TEMPDIR/stapled_ocsp_response.dd\"\n          if [[ \"$stapled_response\" =~ 06052[bB]0[eE]03021[aA] ]]; then\n               # Response appears to use SHA-1 in CertID\n               $OPENSSL ocsp -no_nonce -respin \"$TEMPDIR/stapled_ocsp_response.dd\" \\\n                    -issuer $TEMPDIR/hostcert_issuer.pem -verify_other $TEMPDIR/intermediatecerts.pem \\\n                    -CAfile <(cat $ADDTL_CA_FILES \"$GOOD_CA_BUNDLE\") -cert $HOSTCERT -text &> \"$tmpfile\"\n               success=$?\n          fi\n          if [[ $success -ne 0 ]] && [[ \"$stapled_response\" =~ 0609608648016503040201 ]]; then\n               # Response appears to use SHA-256 in CertID\n               $OPENSSL ocsp -sha256 -no_nonce -respin \"$TEMPDIR/stapled_ocsp_response.dd\" \\\n                    -issuer $TEMPDIR/hostcert_issuer.pem -verify_other $TEMPDIR/intermediatecerts.pem \\\n                    -CAfile <(cat $ADDTL_CA_FILES \"$GOOD_CA_BUNDLE\") -cert $HOSTCERT -text &> \"$tmpfile\"\n               success=$?\n          fi\n     else\n          host_header=${uri##http://}\n          host_header=${host_header%%/*}\n          if [[ \"$OSSL_NAME\" =~ LibreSSL ]]; then\n               host_header=\"-header Host ${host_header}\"\n          elif [[ $OSSL_VER_MAJOR.$OSSL_VER_MINOR == 1.1.0* ]] || [[ $OSSL_VER_MAJOR.$OSSL_VER_MINOR == 1.1.1* ]] || \\\n               [[ $OSSL_VER_MAJOR == 3 ]]; then\n               host_header=\"-header Host=${host_header}\"\n          else\n               host_header=\"-header Host ${host_header}\"\n          fi\n          $OPENSSL ocsp -no_nonce ${host_header} -url \"$uri\" \\\n               -issuer $TEMPDIR/hostcert_issuer.pem -verify_other $TEMPDIR/intermediatecerts.pem \\\n               -CAfile <(cat $ADDTL_CA_FILES \"$GOOD_CA_BUNDLE\") -cert $HOSTCERT -text &> \"$tmpfile\"\n          success=$?\n     fi\n     if [[ $success -eq 0 ]] && grep -Fq \"Response verify OK\" \"$tmpfile\"; then\n          response=\"$(grep -F \"$HOSTCERT: \" \"$tmpfile\")\"\n          response=\"${response#$HOSTCERT: }\"\n          response=\"${response%\\.}\"\n          if [[ \"$response\" =~ good ]]; then\n               out \", \"\n               pr_svrty_good \"not revoked\"\n               fileout \"$jsonID\" \"OK\" \"not revoked\"\n          elif [[ \"$response\" =~ revoked ]]; then\n               out \", \"\n               pr_svrty_critical \"revoked\"\n               fileout \"$jsonID\" \"CRITICAL\" \"revoked\"\n               set_grade_cap \"T\" \"Certificate revoked\"\n          else\n               out \", \"\n               pr_warning \"error querying OCSP responder\"\n               fileout \"$jsonID\" \"WARN\" \"$response\"\n               if [[ $DEBUG -ge 2 ]]; then\n                    outln\n                    cat \"$tmpfile\"\n               else\n                    out \" ($response)\"\n               fi\n          fi\n     else\n          [[ -s \"$tmpfile\" ]] || response=\"empty ocsp response\"\n          [[ -z \"$response\" ]] && response=\"$(awk '/Responder Error:/ { print $3 }' \"$tmpfile\")\"\n          [[ -z \"$response\" ]] && grep -Fq \"Response Verify Failure\" \"$tmpfile\" && response=\"unable to verify response\"\n          [[ -z \"$response\" ]] && response=\"$(awk -F':' '/Code/ { print $NF }' $tmpfile)\"\n          out \", \"\n          pr_warning \"error querying OCSP responder\"\n          fileout \"$jsonID\" \"WARN\" \"$response\"\n          if [[ $DEBUG -ge 2 ]]; then\n               outln\n               [[ -s \"$tmpfile\" ]] && cat \"$tmpfile\" || echo \"empty ocsp response\"\n          elif [[ -n \"$response\" ]]; then\n               out \" ($response)\"\n          fi\n     fi\n}\n\nwait_kill(){\n     local pid=$1             # pid we wait for or kill\n     local maxsleep=$2        # how long we wait before killing\n\n     HAD_SLEPT=0\n     while true; do\n          if ! ps $pid >/dev/null ; then\n               return 0       # process terminated before didn't reach $maxsleep\n          fi\n          [[ \"$DEBUG\" -ge 6 ]] && ps $pid\n          sleep 1\n          maxsleep=$((maxsleep - 1))\n          HAD_SLEPT=$((HAD_SLEPT + 1))\n          test $maxsleep -le 0 && break\n     done                     # needs to be killed:\n     kill $pid >&2 2>/dev/null\n     wait $pid 2>/dev/null    # make sure pid terminated, see wait(1p)\n     return 3                 # means killed\n}\n\n# Convert date formats -- we always use GMT=UTC here\n# argv1: source date string\n# argv2: dest date string\nif \"$HAS_GNUDATE\"; then            # Linux and NetBSD\n     parse_date() {\n          LC_ALL=C TZ=GMT date -d \"$1\" \"$2\"\n     }\nelif \"$HAS_FREEBSDDATE\"; then      # FreeBSD, OS X and newer (~6.6) OpenBSD versions\n     parse_date() {\n          LC_ALL=C TZ=GMT date -j -f \"$3\" \"$2\" \"$1\"\n     }\nelif \"$HAS_OPENBSDDATE\"; then\n     # We basically echo it as a conversion as we want it is too difficult. Approach for that would be:\n     #  printf '%s\\n' \"$1\" | awk '{ printf \"%04d%02d%02d\\n\", $4, $2, (index(\"JanFebMarAprMayJunJulAugSepOctNovDec\",$1)+2)/3}'\n     # 4: year, 1: month, 2: day, $3: time  (e.g. \"Dec 8 10:16:13 2016\")\n     # This way we could also kind of convert args to epoch but as newer OpenBSDs \"date\" behave like FreeBSD\n     parse_date() {\n          local tmp=\"\"\n          if [[ $2 == +%s* ]]; then\n               echo \"${1// GMT}\"\n          else\n               tmp=\"$(printf '%s\\n' \"$1\" | awk '{ printf \"%04d-%02d-%02d %08s\\n\", $4, (index(\"JanFebMarAprMayJunJulAugSepOctNovDec\",$1)+2)/3, $2, $3 }')\"\n               echo \"${tmp%:*}\"         # remove seconds, result now is in line with GNU date 2016-12-08 10:16\n          fi\n     }\nelse\n     parse_date() {\n          LC_ALL=C TZ=GMT date -j \"$2\" \"$1\"\n     }\nfi\n\n\n# Print $arg1 in binary format. arg1: An ASCII-HEX string\n# The string represented by $arg1 may be binary data (a certificate or public\n# key) or a text string (e.g., ASCII-encoded text).\nhex2binary() {\n     local s=\"$1\"\n     local -i i len remainder\n\n     len=${#s}\n     [[ $len%2 -ne 0 ]] && return 1\n\n     if \"$HAS_XXD\"; then\n          xxd -r -p <<< \"$s\"\n     else\n          for (( i=0; i <= len-16 ; i+=16 )); do\n               printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\\x${s:$((i+4)):2}\\x${s:$((i+6)):2}\\x${s:$((i+8)):2}\\x${s:$((i+10)):2}\\x${s:$((i+12)):2}\\x${s:$((i+14)):2}\"\n          done\n\n          remainder=$((len-i))\n          case $remainder in\n                2) printf -- \"\\x${s:i:2}\" ;;\n                4) printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\" ;;\n                6) printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\\x${s:$((i+4)):2}\" ;;\n                8) printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\\x${s:$((i+4)):2}\\x${s:$((i+6)):2}\" ;;\n               10) printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\\x${s:$((i+4)):2}\\x${s:$((i+6)):2}\\x${s:$((i+8)):2}\" ;;\n               12) printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\\x${s:$((i+4)):2}\\x${s:$((i+6)):2}\\x${s:$((i+8)):2}\\x${s:$((i+10)):2}\" ;;\n               14) printf -- \"\\x${s:i:2}\\x${s:$((i+2)):2}\\x${s:$((i+4)):2}\\x${s:$((i+6)):2}\\x${s:$((i+8)):2}\\x${s:$((i+10)):2}\\x${s:$((i+12)):2}\" ;;\n          esac\n     fi\n     return 0\n}\n\n# convert 414243 into ABC\nhex2ascii() {\n     hex2binary $1\n}\n\n# arg1: text string\n# Output a comma-separated ASCII-HEX string representation of the input string.\nstring_to_asciihex() {\n     local string=\"$1\"\n     local -i i eos\n     local output=\"\"\n\n     eos=${#string}-1\n     for (( i=0; i<eos; i++ )); do\n          output+=\"$(printf \"%02x,\" \"'${string:i:1}\")\"\n     done\n     [[ -n \"$string\" ]] && output+=\"$(printf \"%02x\" \"'${string:eos:1}\")\"\n     tm_out \"$output\"\n     return 0\n\n}\n\n# Adjust options to $OPENSSL s_client based on OpenSSL version and protocol version\ns_client_options() {\n     local options=\" $1\"\n     local ciphers=\"notpresent\" tls13_ciphers=\"notpresent\"\n     local cipher tls13_supported_ciphers=\"\"\n\n     # Extract the TLSv1.3 ciphers and the non-TLSv1.3 ciphers\n     if [[ \" $options \" =~ \\ -cipher\\  ]]; then\n          ciphers=\"${options#* -cipher }\"\n          ciphers=\"${ciphers%% *}\"\n          options=\"${options//-cipher $ciphers/}\"\n          ciphers=\"${ciphers##\\'}\"\n          ciphers=\"${ciphers%%\\'}\"\n     fi\n     if [[ \" $options \" =~ \\ -ciphersuites\\  ]]; then\n          tls13_ciphers=\"${options#* -ciphersuites }\"\n          tls13_ciphers=\"${tls13_ciphers%% *}\"\n          options=\"${options//-ciphersuites $tls13_ciphers/}\"\n          tls13_ciphers=\"${tls13_ciphers##\\'}\"\n          tls13_ciphers=\"${tls13_ciphers%%\\'}\"\n          [[ \"$tls13_ciphers\" == ALL ]] && tls13_ciphers=\"$TLS13_OSSL_CIPHERS\"\n          for cipher in ${tls13_ciphers//:/ }; do\n               [[ \"$TLS13_OSSL_CIPHERS\" =~ $cipher ]] && tls13_supported_ciphers+=\":$cipher\"\n          done\n          tls13_ciphers=\"${tls13_supported_ciphers:1}\"\n     fi\n\n     # Don't include the -servername option for an SSLv2 or SSLv3 ClientHello.\n     [[ -n \"$SNI\" ]] && [[ \" $options \" =~ \\ -ssl[2|3]\\  ]] && options=\"${options//$SNI/}\"\n\n     # The server_name extension should not be included in the ClientHello unless\n     # the -servername option is provided. However, OpenSSL 1.1.1 will include the\n     # server_name extension unless the -noservername option is provided. So, if\n     # the command line doesn't include -servername and the -noservername option is\n     # supported, then add -noservername to the options.\n     \"$HAS_NOSERVERNAME\" && [[ ! \" $options \" =~ \\ -servername\\  ]] && options+=\" -noservername\"\n\n     # Newer versions of OpenSSL have dropped support for the -no_ssl2 option, so\n     # remove any -no_ssl2 option if the option isn't supported. (Since versions of\n     # OpenSSL that don't support -no_ssl2 also don't support SSLv2, the option\n     # isn't needed for these versions of OpenSSL.)\n     ! \"$HAS_NO_SSL2\" && options=\"${options//-no_ssl2/}\"\n\n     # The -enable_pha option causes the Post-Handshake Authentication extension to be sent.\n     # It is only supported by OpenSSL 1.1.1 and newer.\n     ! \"$HAS_ENABLE_PHA\" && options=\"${options//-enable_pha/}\"\n\n     # At least one server will fail under some circumstances if compression methods are offered.\n     # So, only offer compression methods if necessary for the test. In OpenSSL 1.1.0 and\n     # 1.1.1 compression is only offered if the \"-comp\" option is provided.\n     # OpenSSL 1.0.0, 1.0.1, and 1.0.2 offer compression unless the \"-no_comp\" option is provided.\n     # OpenSSL 0.9.8 does not support either the \"-comp\" or the \"-no_comp\" option.\n     if [[ \" $options \" =~ \\ -comp\\  ]]; then\n          # Compression is needed for the test. So, remove \"-comp\" if it isn't supported, but\n          # otherwise make no changes.\n          ! \"$HAS_COMP\" && options=\"${options//-comp/}\"\n     else\n          # Compression is not needed. So, specify \"-no_comp\" if that option is supported.\n          \"$HAS_NO_COMP\" && options+=\" -no_comp\"\n     fi\n\n     # If $OPENSSL is compiled with TLSv1.3 support and s_client is called without\n     # specifying a protocol, but specifying a list of ciphers that doesn't include\n     # any TLSv1.3 ciphers, then the command will always fail. So, if $OPENSSL supports\n     # TLSv1.3 and a cipher list is provided, but no protocol is specified, then add\n     # -no_tls1_3 if no TLSv1.3 ciphers are provided.\n     if \"$HAS_TLS13\" && [[ \"$ciphers\" != notpresent ]] && \\\n          [[ \"$tls13_ciphers\" == notpresent || -z \"$tls13_ciphers\" ]] && \\\n          [[ ! \" $options \" =~ \\ -ssl[2|3]\\  ]] && \\\n          [[ ! \" $options \" =~ \\ -tls1\\  ]] && \\\n          [[ ! \" $options \" =~ \\ -tls1_[1|2|3]\\  ]]; then\n          options+=\" -no_tls1_3\"\n     fi\n\n     if \"$HAS_SECLEVEL\"; then\n          if [[ \"$ciphers\" == notpresent ]]; then\n               [[ ! \" $options \" =~ \\ -tls1_3\\  ]] && ciphers=\"@SECLEVEL=0:ALL:COMPLEMENTOFALL\"\n               if \"$HAS_CIPHERSUITES\" && [[ \"$tls13_ciphers\" == notpresent ]] &&  \\\n                    [[ ! \" $options \" =~ \\ -ssl[2|3]\\  ]] && \\\n                    [[ ! \" $options \" =~ \\ -tls1\\  ]] && \\\n                    [[ ! \" $options \" =~ \\ -tls1_[1|2]\\  ]] && \\\n                    [[ ! \" $options \" =~ \\ -no_tls1_3\\  ]]; then\n                    tls13_ciphers=\"$TLS13_OSSL_CIPHERS\"\n               fi\n          elif [[ -n \"$ciphers\" ]]; then\n               ciphers=\"@SECLEVEL=0:$ciphers\"\n          fi\n     fi\n     if [[ \"$ciphers\" != notpresent ]] || [[ \"$tls13_ciphers\" != notpresent ]]; then\n          if ! \"$HAS_CIPHERSUITES\"; then\n               [[ \"$ciphers\" == notpresent ]] && ciphers=\"\"\n               [[ \"$tls13_ciphers\" == notpresent ]] && tls13_ciphers=\"\"\n               [[ -n \"$ciphers\" ]] && [[ -n \"$tls13_ciphers\" ]] && ciphers=\":$ciphers\"\n               ciphers=\"$tls13_ciphers$ciphers\"\n               options+=\" -cipher $ciphers\"\n          else\n               if [[ \"$ciphers\" != notpresent ]] && [[ -n \"$ciphers\" ]]; then\n                    options+=\" -cipher $ciphers\"\n               fi\n               if [[ \"$tls13_ciphers\" != notpresent ]] && [[ -n \"$tls13_ciphers\" ]]; then\n                    options+=\" -ciphersuites $tls13_ciphers\"\n               fi\n          fi\n     fi\n\n     # In case of mutual TLS authentication is required by the server\n     # Note: the PEM certificate file must contain: client certificate and key (not encrypted)\n     if [[ -n \"$MTLS\" ]]; then\n          options+=\" -cert $MTLS\"\n     fi\n\n     # OpenSSL's name for secp256r1 is prime256v1. So whenever we encounter this\n     # (e.g. client simulations) we replace it with the name which OpenSSL understands\n     # This shouldn't be needed. We have this here as a last resort\n     if [[ \"$1\" =~ \\ -curves\\  ]]; then\n          ! \"$HAS_CURVES\" && options=\"${options// -curves / -groups }\"\n          [[ \"$1\" =~ secp192r1 ]] && options=\"${options//secp192r1/prime192v1}\"\n          [[ \"$1\" =~ secp256r1 ]] && options=\"${options//secp256r1/prime256v1}\"\n     fi\n     tm_out \"$options\"\n\n}\n\n###### check code starts here ######\n\n# determines whether the port has an HTTP service running or not (plain TLS, no STARTTLS)\n# arg1 could be the protocol determined as \"working\". IIS6 needs that.\n#\nservice_detection() {\n     local -i was_killed\n\n     if [[ \"$CLIENT_AUTH\" != required ]]; then\n          if ! \"$HAS_TLS13\" && \"$TLS13_ONLY\"; then\n               # Using sockets is a lot slower than using OpenSSL, and it is\n               # not as reliable, but if OpenSSL can't connect to the server,\n               # trying with sockets is better than not even trying.\n               tls_sockets \"04\" \"$TLS13_CIPHER\" \"all+\" \"\" \"\" false\n               if [[ $? -eq 0 ]]; then\n                    plaintext=\"$(tm_out \"$GET_REQ11\" | hexdump -v -e '16/1 \"%02X\"')\"\n                    plaintext=\"${plaintext%%[!0-9A-F]*}\"\n                    send_app_data \"$plaintext\"\n                    if [[ $? -eq 0 ]]; then\n                         receive_app_data true\n                         [[ $? -eq 0 ]] || > \"$TMPFILE\"\n                    else\n                         > \"$TMPFILE\"\n                    fi\n                    send_close_notify \"$DETECTED_TLS_VERSION\"\n               else\n                    > \"$TMPFILE\"\n               fi\n          else\n               # SNI is not standardized for !HTTPS but fortunately for other protocols s_client doesn't seem to care\n               tm_out \"$GET_REQ11\" | $OPENSSL s_client $(s_client_options \"$1 -quiet $BUGS -connect $NODEIP:$PORT $PROXY $SNI\") >$TMPFILE 2>$ERRFILE &\n               wait_kill $! $HEADER_MAXSLEEP\n               was_killed=$?\n          fi\n          head $TMPFILE | grep -aq '^HTTP/' && SERVICE=HTTP\n          [[ -z \"$SERVICE\" ]] && head $TMPFILE | grep -Ewaq \"SMTP|ESMTP|Exim|IdeaSmtpServer|Kerio Connect|Postfix\" && SERVICE=SMTP  # I know some overlap here\n          [[ -z \"$SERVICE\" ]] && head $TMPFILE | grep -Ewaq \"POP|POP3|Gpop|OK Dovecot\" && SERVICE=POP                               # I know some overlap here\n          [[ -z \"$SERVICE\" ]] && head $TMPFILE | grep -Ewaqi \"IMAP|IMAP4|Cyrus IMAP4IMAP4rev1|IMAP4rev1|Gimap\" && SERVICE=IMAP      # I know some overlap here\n          [[ -z \"$SERVICE\" ]] && head $TMPFILE | grep -aq FTP && SERVICE=FTP\n          [[ -z \"$SERVICE\" ]] && head $TMPFILE | grep -Eaqi \"jabber|xmpp\" && SERVICE=XMPP\n          [[ -z \"$SERVICE\" ]] && head $TMPFILE | grep -Eaqw \"Jive News|InterNetNews|NNRP|INN|Kerio Connect|NNTP Service|Kerio MailServer|NNTP server\" && SERVICE=NNTP\n          # MongoDB port 27017 will respond to a GET request with a mocked HTTP response\n          [[ \"$SERVICE\" == HTTP ]] && head $TMPFILE | grep -Eaqw \"you are trying to access MongoDB over HTTP\" && SERVICE=MongoDB\n          debugme head -50 $TMPFILE | sed -e '/<HTML>/,$d' -e '/<html>/,$d' -e '/<XML/,$d' -e '/<xml/,$d' -e '/<\\?XML/,$d' -e '/<\\?xml/,$d' -e '/<\\!DOCTYPE/,$d' -e '/<\\!doctype/,$d'\n     fi\n\n     out \" Service detected:      $CORRECT_SPACES\"\n     jsonID=\"service\"\n     case $SERVICE in\n          HTTP)\n               out \" $SERVICE\"\n               fileout \"${jsonID}\" \"INFO\" \"$SERVICE\"\n               ;;\n          IMAP|POP|SMTP|NNTP|MongoDB)\n               out \" $SERVICE, thus skipping HTTP specific checks\"\n               fileout \"${jsonID}\" \"INFO\" \"$SERVICE, thus skipping HTTP specific checks\"\n               ;;\n          *)   if [[ ! -z $MTLS ]]; then\n                    out \" not identified, but mTLS authentication is set ==> trying HTTP checks\"\n                    SERVICE=HTTP\n                    fileout \"${jsonID}\" \"DEBUG\" \"Couldn't determine service -- ASSUME_HTTP set\"\n               elif [[ \"$CLIENT_AUTH\" == required ]] && [[ -z $MTLS ]]; then\n                    out \" certificate-based authentication without providing client certificate and private key => skipping all HTTP checks\"\n                    echo \"certificate-based authentication without providing client certificate and private key  => skipping all HTTP checks\" >$TMPFILE\n                    fileout \"${jsonID}\" \"INFO\" \"certificate-based authentication without providing client certificate and private key  => skipping all HTTP checks\"\n               else\n                    out \" Couldn't determine what's running on port $PORT\"\n                    if \"$ASSUME_HTTP\"; then\n                         SERVICE=HTTP\n                         out \" -- ASSUME_HTTP set though\"\n                         fileout \"${jsonID}\" \"DEBUG\" \"Couldn't determine service -- ASSUME_HTTP set\"\n                    else\n                         out \", assuming no HTTP service => skipping all HTTP checks\"\n                         fileout \"${jsonID}\" \"DEBUG\" \"Couldn't determine service, skipping all HTTP checks\"\n                    fi\n               fi\n               ;;\n     esac\n\n     outln\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\n# 1: counter variable\n# 2: threshold for this variable\n# 3: string for first occurrence of problem\n# 4: string for repeated occurrence of problem\n#\nconnectivity_problem() {\n     if [[ $1 -lt $2 ]]; then\n          if \"$TLS13_ONLY\" && ! \"$HAS_TLS13\"; then\n               :\n          else\n               prln_warning \" Oops: $3\"\n          fi\n          return 0\n     fi\n     if [[ $1 -ge $2 ]]; then\n          if [[ \"$4\" =~ openssl\\ s_client\\ connect ]] ; then\n               fatal \"$4\" $ERR_CONNECT \"Consider increasing MAX_OSSL_FAIL (currently: $2)\"\n          elif [[ \"$4\" =~ repeated\\ TCP\\ connect ]]; then\n               fatal \"$4\" $ERR_CONNECT \"Consider increasing MAX_SOCKET_FAIL (currently: $2)\"\n          fi\n          fatal \"$4\" $ERR_CONNECT\n     fi\n}\n\n\n#problems not handled: chunked\nrun_http_header() {\n     local header\n     local referer useragent\n     local url redirect\n     local jsonID=\"HTTP_status_code\"\n     local spaces=\"                            \"\n\n     HEADERFILE=$TEMPDIR/$NODEIP.http_header.txt\n     if [[ $NR_HEADER_FAIL -eq 0 ]]; then\n          # skip repeating this line if it's 2nd, 3rd,.. try\n          outln; pr_headlineln \" Testing HTTP header response @ \\\"$URL_PATH\\\" \"\n          outln\n     fi\n     if [[ $NR_HEADER_FAIL -ge $MAX_HEADER_FAIL ]]; then\n          # signal to caller we have a problem\n          return 1\n     fi\n\n     pr_bold \" HTTP Status Code           \"\n     [[ -z \"$1\" ]] && url=\"/\" || url=\"$1\"\n\n     tm_out \"$GET_REQ11\" | $OPENSSL s_client $(s_client_options \"$OPTIMAL_PROTO $BUGS -quiet -ign_eof -connect $NODEIP:$PORT $PROXY $SNI\") >$HEADERFILE 2>$ERRFILE &\n     wait_kill $! $HEADER_MAXSLEEP\n     if [[ $? -eq 0 ]]; then\n          # Issue HTTP GET again as it properly finished within $HEADER_MAXSLEEP and didn't hang.\n          # Doing it again in the foreground to get an accurate header time\n          tm_out \"$GET_REQ11\" | $OPENSSL s_client $(s_client_options \"$OPTIMAL_PROTO $BUGS -quiet -ign_eof -connect $NODEIP:$PORT $PROXY $SNI\") >$HEADERFILE 2>$ERRFILE\n          NOW_TIME=$(date \"+%s\")\n          HTTP_TIME=$(awk -F': ' '/^date:/ { print $2 }  /^Date:/ { print $2 }' $HEADERFILE)\n          HTTP_AGE=$(awk -F': ' '/^[aA][gG][eE]: / { print $2 }' $HEADERFILE)\n          HAD_SLEPT=0\n     else\n          # 1st GET request hung and needed to be killed. Check whether it succeeded anyway:\n          if grep -Eiaq \"XML|HTML|DOCTYPE|HTTP|Connection\" $HEADERFILE; then\n               # correct by seconds we slept, HAD_SLEPT comes from wait_kill()\n               NOW_TIME=$(($(date \"+%s\") - HAD_SLEPT))\n               HTTP_TIME=$(awk -F': ' '/^date:/ { print $2 }  /^Date:/ { print $2 }' $HEADERFILE)\n               HTTP_AGE=$(awk -F': ' '/^[aA][gG][eE]: / { print $2 }' $HEADERFILE)\n          else\n               prln_warning \" likely HTTP header requests failed (#lines: $(wc -l $HEADERFILE | awk '{ print $1 }'))\"\n               [[ \"$DEBUG\" -lt 1 ]] && outln \"Rerun with DEBUG>=1 and inspect $HEADERFILE\\n\"\n               fileout \"HTTP_status_code\" \"WARN\" \"HTTP header request failed\"\n               debugme cat $HEADERFILE\n               ((NR_HEADER_FAIL++))\n          fi\n     fi\n     if [[ ! -s $HEADERFILE ]]; then\n          ((NR_HEADER_FAIL++))\n          if [[ $NR_HEADER_FAIL -ge $MAX_HEADER_FAIL ]]; then\n               # Now, try to give a hint whether it would make sense to try with OpenSSL 1.1.0 or 1.1.1 instead\n               if [[ $CURVES_OFFERED == X448 ]] && ! \"$HAS_X448\" ; then\n                    generic_nonfatal \"HTTP header was repeatedly zero due to missing X448 curve.\" \"${spaces}OpenSSL 1.1.1 might help. Skipping complete HTTP header section.\"\n               elif [[ $CURVES_OFFERED == X25519 ]] && ! \"$HAS_X25519\" ; then\n                    generic_nonfatal \"HTTP header was repeatedly zero due to missing X25519 curve.\" \"${spaces}OpenSSL 1.1.0 might help. Skipping complete HTTP header section.\"\n               elif [[ $CURVES_OFFERED =~ X25519 ]] && [[ $CURVES_OFFERED =~ X448 ]] && ! \"$HAS_X25519\" && ! \"$HAS_X448\"; then\n                    generic_nonfatal \"HTTP header was repeatedly zero due to missing X25519/X448 curves.\" \"${spaces}OpenSSL >=1.1.0 might help. Skipping complete HTTP header section.\"\n               else\n                    # we could give more hints but these are the most likely cases\n                    generic_nonfatal \"HTTP header was repeatedly zero.\" \"Skipping complete HTTP header section.\"\n               fi\n               KNOWN_OSSL_PROB=true\n               return 1\n          else\n               pr_warning \"HTTP header reply empty. \"\n               fileout \"$jsonID\" \"WARN\" \"HTTP header reply empty\"\n          fi\n     fi\n\n     # Populate vars for HTTP time\n     [[ -n \"$HTTP_AGE\" ]] && HTTP_AGE=\"$(strip_lf \"$HTTP_AGE\")\"\n     [[ -n \"$HTTP_TIME\" ]] && HTTP_TIME=\"$(strip_lf \"$HTTP_TIME\")\"\n     debugme echo \"NOW_TIME: $NOW_TIME | HTTP_AGE: $HTTP_AGE | HTTP_TIME: $HTTP_TIME\"\n\n     # Quit on first empty line to catch 98% of the cases. Next pattern is there because the SEDs tested\n     # so far seem not to be fine with header containing x0d x0a (CRLF) which is the usual case.\n     # So we also trigger also on any sign on a single line which is not alphanumeric (plus _)\n     #\n     # Also we use tr here to remove any crtl chars which the server side offers --> possible security problem\n     # Only allowed now is LF + CR. See  #2337\n     # awk, see above, doesn't seem to care\n     sed -e '/^$/q' -e '/^[^a-zA-Z_0-9]$/q' $HEADERFILE | tr -d '\\000-\\011\\013\\014\\016-\\037' >$HEADERFILE.tmp\n     # Now to be more sure we delete from '<' or '{' maybe with a leading blank until the end\n     sed -e '/^ *<.*$/d' -e '/^ *{.*$/d' $HEADERFILE.tmp >$HEADERFILE\n     debugme echo -e \"---\\n $(< $HEADERFILE) \\n---\"\n\n     HTTP_STATUS_CODE=$(awk '/^HTTP\\// { print $2 }' $HEADERFILE 2>>$ERRFILE)\n     msg_thereafter=$(awk -F\"$HTTP_STATUS_CODE\" '/^HTTP\\// { print $2 }' $HEADERFILE 2>>$ERRFILE)   # dirty trick to use the status code as a\n     msg_thereafter=$(strip_lf \"$msg_thereafter\")                                                   # field separator, otherwise we need a loop with awk\n     debugme echo \"Status/MSG: $HTTP_STATUS_CODE $msg_thereafter\"\n\n     [[ -n \"$HTTP_STATUS_CODE\" ]] && out \"  $HTTP_STATUS_CODE$msg_thereafter\"\n     case $HTTP_STATUS_CODE in\n          301|302|307|308)\n               redirect=$(grep -a '^Location' $HEADERFILE | sed 's/Location: //' | tr -d '\\r\\n')\n               out \", redirecting to \\\"\"; pr_url \"$redirect\"; out \"\\\"\"\n               if [[ $redirect =~ http:// ]]; then\n                    pr_svrty_high \" -- Redirect to insecure URL (NOT ok)\"\n                    fileout \"insecure_redirect\" \"HIGH\" \"Redirect to insecure URL: \\\"$redirect\\\"\"\n               fi\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_STATUS_CODE$msg_thereafter (\\\"$URL_PATH\\\")\"\n               ;;\n          200|204|403|405)\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_STATUS_CODE$msg_thereafter (\\\"$URL_PATH\\\")\"\n               ;;\n          206)\n               out \" -- WHAT?\"\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_STATUS_CODE$msg_thereafter (\\\"$URL_PATH\\\") -- WHAT?\"\n               # partial content shouldn't happen\n               ;;\n          400)\n               pr_cyan \" (Hint: better try another URL)\"\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_STATUS_CODE$msg_thereafter (\\\"$URL_PATH\\\") -- better try another URL\"\n               ;;\n          401)\n               grep -aq \"^WWW-Authenticate\" $HEADERFILE && out \"  \"; out \"$(strip_lf \"$(grep -a \"^WWW-Authenticate\" $HEADERFILE)\")\"\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_STATUS_CODE$msg_thereafter (\\\"$URL_PATH\\\") -- $(grep -a \"^WWW-Authenticate\" $HEADERFILE)\"\n               ;;\n          404)\n               out \" (Hint: supply a path which doesn't give a \\\"$HTTP_STATUS_CODE$msg_thereafter\\\")\"\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_STATUS_CODE$msg_thereafter (\\\"$URL_PATH\\\")\"\n               ;;\n          \"\")\n               prln_warning \"No HTTP status code.\"\n               fileout \"$jsonID\" \"WARN\" \"No HTTP status code\"\n               return 1\n               ;;\n          *)\n               pr_warning \". Oh, didn't expect \\\"$HTTP_STATUS_CODE$msg_thereafter\\\"\"\n               fileout \"$jsonID\" \"WARN\" \"Unexpected $HTTP_STATUS_CODE$msg_thereafter @ \\\"$URL_PATH\\\"\"\n               ;;\n     esac\n     outln\n\n     # we don't call \"tmpfile_handle ${FUNCNAME[0]}.txt\" as we need the header file in other functions!\n     return 0\n}\n\n# Borrowed from Glenn Jackman, see https://unix.stackexchange.com/users/4667/glenn-jackman\n#\nmatch_ipv4_httpheader() {\n     local octet=\"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\"\n     local ipv4address=\"$octet\\\\.$octet\\\\.$octet\\\\.$octet\"\n     local excluded_header=\"pagespeed|page-speed|^Content-Security-Policy|^MicrosoftSharePointTeamServices|^X-OWA-Version|^Location|^Server: \"\n     local your_ip_msg=\"(check if it's your IP address or e.g. a cluster IP)\"\n     local headers result\n     local first=true\n     local spaces=\"                              \"\n     local jsonID=\"ipv4_in_header\"\n     local cwe=\"CWE-212\"\n     local cve=\"\"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n\n     # Exclude some headers as they are mistakenly identified as ipv4 address. Issues #158, #323.\n     # Also facebook used to have a CSP rule for 127.0.0.1\n     headers=\"$(grep -Evai \"$excluded_header\" $HEADERFILE 2>/dev/null)\"\n     if [[ \"$headers\" =~ $ipv4address ]]; then\n          pr_bold \" IPv4 address in header       \"\n          while read line; do\n               [[ \"$line\" =~ $ipv4address ]] || continue\n               result=$(strip_lf \"$line\")\n               if ! $first; then\n                    out \"$spaces\"\n                    your_ip_msg=\"\"\n               else\n                    first=false\n               fi\n               pr_svrty_medium \"$result\"\n               outln \"\\n$spaces$your_ip_msg\"\n               fileout \"$jsonID\" \"MEDIUM\" \"$result $your_ip_msg\" \"$cve\" \"$cwe\"\n          done <<< \"$headers\"\n     fi\n}\n\n\nrun_http_date() {\n     local difftime\n     local spaces=\"                              \"\n     jsonID=\"HTTP_clock_skew\"\n\n     if [[ $SERVICE != HTTP ]] || { [[ \"$CLIENT_AUTH\" == required ]] && [[ -z \"$MTLS\" ]]; }; then\n          return 0\n     fi\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n     pr_bold \" HTTP clock skew              \"\n     if [[ -n \"$HTTP_TIME\" ]]; then\n          if \"$HAS_OPENBSDDATE\"; then\n               # We won't normalize the date under an OpenBSD thus no subtraction is feasible\n               outln \"remote: $HTTP_TIME\"\n               out \"${spaces}local:  $(LC_ALL=C TZ=GMT date \"+%a, %d %b %Y %T %Z\")\"\n               fileout \"$jsonID\" \"INFO\" \"$HTTP_TIME - $(TZ=GMT date \"+%a, %d %b %Y %T %Z\")\"\n          else\n               # modifying the global from string to a number\n               HTTP_TIME=\"$(parse_date \"$HTTP_TIME\" \"+%s\" \"%a, %d %b %Y %T %Z\" 2>>$ERRFILE)\"\n               difftime=$((HTTP_TIME + HTTP_AGE - NOW_TIME))\n               [[ $difftime != \"-\"* ]] && [[ $difftime != \"0\" ]] && difftime=\"+$difftime\"\n               # process was killed, so we need to add an error\n               [[ $HAD_SLEPT -ne 0 ]] && difftime=\"$difftime (± 1.5)\"\n               out \"$difftime sec from localtime\";\n               fileout \"$jsonID\" \"INFO\" \"$difftime seconds from localtime\"\n          fi\n          if [[ -n \"$HTTP_TIME\" ]]; then\n               # out \" (HTTP header time: $HTTP_TIME)\"\n               fileout \"HTTP_headerTime\" \"INFO\" \"$HTTP_TIME\"\n          fi\n          if [[ -n \"$HTTP_AGE\" ]]; then\n               outln\n               pr_bold \" HTTP Age\"\n               out \" (RFC 7234)          $HTTP_AGE\"\n               fileout \"HTTP_headerAge\" \"INFO\" \"$HTTP_AGE seconds\"\n          fi\n     else\n          out \"Got no HTTP time, maybe try different URL?\";\n          fileout \"$jsonID\" \"INFO\" \"Got no HTTP time, maybe try different URL?\"\n     fi\n     debugme tm_out \", HTTP_TIME + HTTP_AGE in epoch: $HTTP_TIME / $HTTP_AGE\"\n     outln\n     match_ipv4_httpheader \"$1\"\n     return 0\n}\n\n\n# HEADERFILE needs to contain the HTTP header (made sure by invoker)\n# arg1: key=word to match\n# arg2: hint for fileout() if double header\n# arg3: indentation, i.e string w spaces\n# arg4: whether we need a CR before \"misconfiguration\"\n# returns:\n#    0 if header not found\n#    1-n nr of headers found, then in HEADERVALUE the first value from key\n#\nmatch_httpheader_key() {\n     local key=\"$1\"\n     local spaces=\"$3\"\n     local first=$4\n     local -i nr=0\n\n     nr=$(grep -Eaic \"^ *$key:\" $HEADERFILE)\n     if [[ $nr -eq 0 ]]; then\n          HEADERVALUE=\"\"\n          return 0\n     elif [[ $nr -eq 1 ]]; then\n          HEADERVALUE=\"$(grep -Eia \"^ *$key:\" $HEADERFILE)\"\n          HEADERVALUE=\"${HEADERVALUE#*:}\"                        # remove leading part=key to colon\n          HEADERVALUE=\"$(strip_lf \"$HEADERVALUE\")\"\n          HEADERVALUE=\"$(strip_leading_space \"$HEADERVALUE\")\"\n          \"$first\" || out \"$spaces\"\n          return 1\n     else\n          \"$first\" || out \"$spaces\"\n          pr_svrty_medium \"misconfiguration: \"\n          pr_italic \"$key\"\n          pr_svrty_medium \" ${nr}x\"\n          outln \" -- checking first one only\"\n          out \"$spaces\"\n          HEADERVALUE=\"$(grep -Fai \"$key:\" $HEADERFILE | head -1)\"\n          HEADERVALUE=\"${HEADERVALUE#*:}\"\n          HEADERVALUE=\"$(strip_lf \"$HEADERVALUE\")\"\n          HEADERVALUE=\"$(strip_leading_space \"$HEADERVALUE\")\"\n          [[ $DEBUG -ge 2 ]] && tm_italic \"$HEADERVALUE\" && tm_out \"\\n$spaces\"\n          fileout \"${2}_multiple\" \"MEDIUM\" \"Multiple $2 headers. Using first header: $HEADERVALUE\"\n          return $nr\n     fi\n}\n\nincludeSubDomains() {\n     if grep -aiqw includeSubDomains \"$1\"; then\n          pr_svrty_good \", includeSubDomains\"\n          return 0\n     else\n          pr_litecyan \", just this domain\"\n          return 1\n     fi\n}\n\npreload() {\n     if grep -aiqw preload \"$1\"; then\n          pr_svrty_good \", preload\"\n          return 0\n     else\n          return 1\n     fi\n}\n\n\nrun_hsts() {\n     local hsts_age_sec\n     local hsts_age_days\n     local spaces=\"                              \"\n     local jsonID=\"HSTS\"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n     pr_bold \" Strict Transport Security    \"\n     match_httpheader_key \"Strict-Transport-Security\" \"HSTS\" \"$spaces\" \"true\"\n     if [[ $? -ne 0 ]]; then\n          echo \"$HEADERVALUE\" >$TMPFILE\n          # strict parsing now as suggested in #2381\n          hsts_age_sec=\"${HEADERVALUE#*=}\"\n          hsts_age_sec=${hsts_age_sec%%;*}\n          # see #2466\n          hsts_age_sec=$(strip_trailing_space \"$hsts_age_sec\")\n          if [[ $hsts_age_sec =~ \\\" ]]; then\n               # remove first an last \" in $hsts_age_sec (borrowed from strip_trailing_space/strip_leading_space):\n               hsts_age_sec=$(printf \"%s\" \"${hsts_age_sec#\"${hsts_age_sec%%[!\\\"]*}\"}\")\n               hsts_age_sec=$(printf \"%s\" \"${hsts_age_sec%\"${hsts_age_sec##*[!\\\"]}\"}\")\n          fi\n          debugme echo \"hsts_age_sec: $hsts_age_sec\"\n          if ! is_number \"$hsts_age_sec\"; then\n               pr_svrty_medium \"misconfiguration: \\'\"$hsts_age_sec\"\\' is not a valid max-age specification\"\n               fileout \"${jsonID}_time\" \"MEDIUM\" \"misconfiguration, specified not a number for max-age\"\n          else\n               if [[ -n $hsts_age_sec ]]; then\n                    hsts_age_days=$(( hsts_age_sec / 86400))\n               else\n                    hsts_age_days=-1\n               fi\n               if [[ $hsts_age_days -eq -1 ]]; then\n                    pr_svrty_medium \"misconfiguration: HSTS max-age (recommended > $HSTS_MIN seconds = $((HSTS_MIN/86400)) days ) is required but missing\"\n                    fileout \"${jsonID}_time\" \"MEDIUM\" \"misconfiguration, parameter max-age (recommended > $HSTS_MIN seconds = $((HSTS_MIN/86400)) days) missing\"\n                    set_grade_cap \"A\" \"HSTS max-age is misconfigured\"\n               elif [[ $hsts_age_sec -eq 0 ]]; then\n                    pr_svrty_low \"HSTS max-age is set to 0. HSTS is disabled\"\n                    fileout \"${jsonID}_time\" \"LOW\" \"0. HSTS is disabled\"\n                    set_grade_cap \"A\" \"HSTS is disabled\"\n               elif [[ $hsts_age_sec -ge $HSTS_MIN ]]; then\n                    pr_svrty_good \"$hsts_age_days days\" ; out \"=$hsts_age_sec s\"\n                    fileout \"${jsonID}_time\" \"OK\" \"$hsts_age_days days (=$hsts_age_sec seconds) > $HSTS_MIN seconds\"\n               else\n                    pr_svrty_medium \"$hsts_age_sec s = $hsts_age_days days is too short ( >= $HSTS_MIN seconds recommended)\"\n                    fileout \"${jsonID}_time\" \"MEDIUM\" \"max-age too short. $hsts_age_days days (=$hsts_age_sec seconds) < $HSTS_MIN seconds\"\n                    set_grade_cap \"A\" \"HSTS max-age is too short\"\n               fi\n          fi\n          if includeSubDomains \"$TMPFILE\"; then\n               fileout \"${jsonID}_subdomains\" \"OK\" \"includes subdomains\"\n          else\n               fileout \"${jsonID}_subdomains\" \"INFO\" \"only for this domain\"\n          fi\n          if preload \"$TMPFILE\"; then\n               fileout \"${jsonID}_preload\" \"OK\" \"domain IS marked for preloading\"\n          else\n               fileout \"${jsonID}_preload\" \"INFO\" \"domain is NOT marked for preloading\"\n               #FIXME: To be checked against preloading lists,\n               # e.g. https://dxr.mozilla.org/mozilla-central/source/security/manager/boot/src/nsSTSPreloadList.inc\n               #      https://chromium.googlesource.com/chromium/src/+/master/net/http/transport_security_state_static.json\n          fi\n     else\n          pr_svrty_low \"not offered\"\n          fileout \"$jsonID\" \"LOW\" \"not offered\"\n          set_grade_cap \"A\" \"HSTS is not offered\"\n     fi\n     outln\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\n\nrun_hpkp() {\n     local -i hpkp_age_sec\n     local -i hpkp_age_days\n     local -i hpkp_nr_keys\n     local hpkp_spki hpkp_spki_hostcert\n     local -a backup_spki\n     local spaces=\"                             \"\n     local spaces_indented=\"                  \"\n     local certificate_found=false\n     local -i i nrsaved\n     local first_hpkp_header\n     local spki\n     local ca_hashes=\"$TESTSSL_INSTALL_DIR/etc/ca_hashes.txt\"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n     pr_bold \" Public Key Pinning           \"\n     grep -aiw '^Public-Key-Pins' $HEADERFILE >$TMPFILE                    # TMPFILE includes report-only\n     if [[ $? -eq 0 ]]; then\n          if [[ $(grep -aci '^Public-Key-Pins:' $TMPFILE) -gt 1 ]]; then\n               pr_svrty_medium \"Misconfiguration, multiple Public-Key-Pins headers\"\n               outln \", taking first line\"\n               fileout \"HPKP_error\" \"MEDIUM\" \"multiple Public-Key-Pins in header\"\n               first_hpkp_header=\"$(grep -ai '^Public-Key-Pins:' $TMPFILE | head -1)\"\n               # we only evaluate the keys here, unless they a not present\n               out \"$spaces \"\n               set_grade_cap \"A\" \"Problems with HTTP Public Key Pinning (HPKP)\"\n          elif [[ $(grep -aci '^Public-Key-Pins-Report-Only:' $TMPFILE) -gt 1 ]]; then\n               outln \"Multiple HPKP headers (Report-Only), taking first line\"\n               fileout \"HPKP_notice\" \"INFO\" \"multiple Public-Key-Pins-Report-Only in header\"\n               first_hpkp_header=\"$(grep -ai '^Public-Key-Pins-Report-Only:' $TMPFILE | head -1)\"\n               out \"$spaces \"\n          elif [[ $(grep -Eaci '^Public-Key-Pins:|^Public-Key-Pins-Report-Only:' $TMPFILE) -eq 2 ]]; then\n               outln \"Public-Key-Pins + Public-Key-Pins-Report-Only detected. Continue with first one\"\n               first_hpkp_header=\"$(grep -ai '^Public-Key-Pins:' $TMPFILE)\"\n               out \"$spaces \"\n          elif [[ $(grep -aci '^Public-Key-Pins:' $TMPFILE) -eq 1 ]]; then\n               first_hpkp_header=\"$(grep -ai '^Public-Key-Pins:' $TMPFILE)\"\n          else\n               outln \"Public-Key-Pins-Only detected\"\n               first_hpkp_header=\"$(grep -ai '^Public-Key-Pins-Report-Only:' $TMPFILE)\"\n               out \"$spaces \"\n               fileout \"HPKP_SPKIs\" \"INFO\" \"Only Public-Key-Pins-Report-Only\"\n          fi\n\n          # remove leading Public-Key-Pins* and convert it to multiline arg\n          sed -e 's/Public-Key-Pins://g' -e s'/Public-Key-Pins-Report-Only://' <<< \"$first_hpkp_header\" | \\\n               tr ';' '\\n' | sed -e 's/\\\"//g' -e 's/^ //' >$TMPFILE\n\n          hpkp_nr_keys=$(grep -ac pin-sha $TMPFILE)\n          if [[ $hpkp_nr_keys -eq 1 ]]; then\n               pr_svrty_high \"Only one key pinned (NOT ok), means the site may become unavailable in the future, \"\n               fileout \"HPKP_SPKIs\" \"HIGH\" \"Only one key pinned\"\n               set_grade_cap \"A\" \"Problems with HTTP Public Key Pinning (HPKP)\"\n          else\n               pr_svrty_good \"$hpkp_nr_keys\"\n               out \" keys, \"\n               fileout \"HPKP_SPKIs\" \"OK\" \"$hpkp_nr_keys keys pinned in header\"\n          fi\n\n          # print key=value pair with awk, then strip non-numbers, to be improved with proper parsing of key-value with awk\n          if \"$HAS_SED_E\"; then\n               hpkp_age_sec=$(awk -F= '/max-age/{max_age=$2; print max_age}' $TMPFILE | sed -E 's/[^[:digit:]]//g')\n          else\n               hpkp_age_sec=$(awk -F= '/max-age/{max_age=$2; print max_age}' $TMPFILE | sed -r 's/[^[:digit:]]//g')\n          fi\n          hpkp_age_days=$((hpkp_age_sec / 86400))\n          if [[ $hpkp_age_sec -ge $HPKP_MIN ]]; then\n               pr_svrty_good \"$hpkp_age_days days\" ; out \"=$hpkp_age_sec s\"\n               fileout \"HPKP_age\" \"OK\" \"HPKP age is set to $hpkp_age_days days ($hpkp_age_sec sec)\"\n          else\n               out \"$hpkp_age_sec s = \"\n               pr_svrty_medium \"$hpkp_age_days days (< $HPKP_MIN s = $((HPKP_MIN / 86400)) days is not good enough)\"\n               fileout \"HPKP_age\" \"MEDIUM\" \"age is set to $hpkp_age_days days ($hpkp_age_sec sec) < $HPKP_MIN s = $((HPKP_MIN / 86400)) days is not good enough.\"\n               set_grade_cap \"A\" \"Problems with HTTP Public Key Pinning (HPKP)\"\n          fi\n\n          if includeSubDomains \"$TMPFILE\"; then\n               fileout \"HPKP_subdomains\" \"INFO\" \"is valid for subdomains as well\"\n          else\n               fileout \"HPKP_subdomains\" \"INFO\" \"is valid for this domain only\"\n          fi\n          if preload \"$TMPFILE\"; then\n               fileout \"HPKP_preload\" \"INFO\" \"IS marked for browser preloading\"\n          else\n               fileout \"HPKP_preload\" \"INFO\" \"NOT marked for browser preloading\"\n          fi\n\n          # Get the SPKIs first\n          spki=$(tr ';' '\\n' < $TMPFILE | tr -d ' ' | tr -d '\\\"' | awk -F'=' '/pin.*=/ { print $2 }')\n          debugme tmln_out \"\\n$spki\"\n\n          # Look at the host certificate first\n          if [[ ! -s \"$HOSTCERT\" ]]; then\n               get_host_cert || return 1\n               # no host certificate\n          fi\n\n          hpkp_spki_hostcert=\"$($OPENSSL x509 -in $HOSTCERT -pubkey -noout 2>/dev/null | grep -v PUBLIC | \\\n               $OPENSSL base64 -d 2>/dev/null | $OPENSSL dgst -sha256 -binary 2>/dev/null | $OPENSSL base64 2>/dev/null)\"\n          hpkp_ca=\"$($OPENSSL x509 -in $HOSTCERT -issuer -noout 2>/dev/null |sed 's/^.*CN=//' | sed 's/\\/.*$//')\"\n\n          # Get keys/hashes from intermediate certificates\n          $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS $PROXY -showcerts -connect $NODEIP:$PORT $SNI\")  </dev/null >$TMPFILE 2>$ERRFILE\n          # Place the server's certificate in $HOSTCERT and any intermediate\n          # certificates that were provided in $TEMPDIR/intermediatecerts.pem\n          # https://backreference.org/2010/05/09/ocsp-verification-with-openssl/\n          awk -v n=-1 \"/Certificate chain/ {start=1}\n                  /-----BEGIN CERTIFICATE-----/{ if (start) {inc=1; n++} }\n                  inc { print > (\\\"$TEMPDIR/level\\\" n \\\".crt\\\") }\n                  /---END CERTIFICATE-----/{ inc=0 }\" $TMPFILE\n          nrsaved=$(count_words \"$(echo $TEMPDIR/level?.crt 2>/dev/null)\")\n          rm $TEMPDIR/level0.crt 2>/dev/null\n\n          printf \"\"> \"$TEMPDIR/intermediate.hashes\"\n          if [[ $nrsaved -ge 2 ]]; then\n               for cert_fname in $TEMPDIR/level?.crt; do\n                    hpkp_spki_ca=\"$($OPENSSL x509 -in \"$cert_fname\" -pubkey -noout 2>/dev/null | grep -v PUBLIC | $OPENSSL base64 -d 2>/dev/null |\n                         $OPENSSL dgst -sha256 -binary 2>/dev/null | $OPENSSL enc -base64 2>/dev/null)\"\n                    hpkp_name=\"$(get_cn_from_cert $cert_fname)\"\n                    hpkp_ca=\"$($OPENSSL x509 -in $cert_fname -issuer -noout 2>/dev/null |sed 's/^.*CN=//' | sed 's/\\/.*$//')\"\n                    [[ -n $hpkp_name ]] || hpkp_name=$($OPENSSL x509 -in \"$cert_fname\" -subject -noout 2>/dev/null | sed 's/^subject= //')\n                    echo \"$hpkp_spki_ca $hpkp_name\" >> \"$TEMPDIR/intermediate.hashes\"\n               done\n          fi\n\n          # This is where the matching magic starts. First host, intermediate, then root certificate from the supplied stores\n          spki_match=false\n          has_backup_spki=false\n          i=0\n          for hpkp_spki in $spki; do\n               certificate_found=false\n               # compare collected SPKIs against the host certificate\n               if [[ \"$hpkp_spki_hostcert\" == \"$hpkp_spki\" ]] || [[ \"$hpkp_spki_hostcert\" == \"$hpkp_spki=\" ]]; then\n                    certificate_found=true       # We have a match\n                    spki_match=true\n                    out \"\\n$spaces_indented Host cert: \"\n                    pr_svrty_good \"$hpkp_spki\"\n                    fileout \"HPKP_$hpkp_spki\" \"OK\" \"SPKI $hpkp_spki matches the host certificate\"\n               fi\n               debugme tm_out \"\\n  $hpkp_spki | $hpkp_spki_hostcert\"\n\n               # Check for intermediate match\n               if ! \"$certificate_found\"; then\n                    hpkp_matches=$(grep \"$hpkp_spki\" $TEMPDIR/intermediate.hashes 2>/dev/null)\n                    if [[ -n $hpkp_matches ]]; then    # hpkp_matches + hpkp_spki + '='\n                         # We have a match\n                         certificate_found=true\n                         spki_match=true\n                         out \"\\n$spaces_indented Sub CA:    \"\n                         pr_svrty_good \"$hpkp_spki\"\n                         ca_cn=\"$(sed \"s/^[a-zA-Z0-9\\+\\/]*=* *//\" <<< $\"$hpkp_matches\" )\"\n                         pr_italic \" $ca_cn\"\n                         fileout \"HPKP_$hpkp_spki\" \"OK\" \"SPKI $hpkp_spki matches Intermediate CA \\\"$ca_cn\\\" pinned in the HPKP header\"\n                    fi\n               fi\n\n               # we compare now against a precompiled list of SPKIs against the ROOT CAs we have in $ca_hashes\n               if ! \"$certificate_found\"; then\n                    hpkp_matches=$(grep -h \"$hpkp_spki\" $ca_hashes 2>/dev/null | sort -u)\n                    if [[ -n $hpkp_matches ]]; then\n                         certificate_found=true      # root CA found\n                         spki_match=true\n                         if [[ $(count_lines \"$hpkp_matches\") -eq 1 ]]; then\n                              # replace by awk\n                              match_ca=$(sed \"s/[a-zA-Z0-9\\+\\/]*=* *//\" <<< \"$hpkp_matches\")\n                         else\n                              match_ca=\"\"\n\n                         fi\n                         ca_cn=\"$(sed \"s/^[a-zA-Z0-9\\+\\/]*=* *//\" <<< $\"$hpkp_matches\" )\"\n                         if [[ \"$match_ca\" == \"$hpkp_ca\" ]]; then          # part of the chain\n                              out \"\\n$spaces_indented Root CA:   \"\n                              pr_svrty_good \"$hpkp_spki\"\n                              pr_italic \" $ca_cn\"\n                              fileout \"HPKP_$hpkp_spki\" \"INFO\" \"SPKI $hpkp_spki matches Root CA \\\"$ca_cn\\\" pinned. (Root CA part of the chain)\"\n                         else                                              # not part of chain\n                              match_ca=\"\"\n                              has_backup_spki=true                         # Root CA outside the chain --> we save it for unmatched\n                              fileout \"HPKP_$hpkp_spki\" \"INFO\" \"SPKI $hpkp_spki matches Root CA \\\"$ca_cn\\\" pinned. (Root backup SPKI)\"\n                              backup_spki[i]=\"$(strip_lf \"$hpkp_spki\")\"    # save it for later\n                              backup_spki_str[i]=\"$ca_cn\"                  # also the name=CN of the root CA\n                              i=$((i + 1))\n                         fi\n                    fi\n               fi\n\n               # still no success --> it's probably a backup SPKI\n               if ! \"$certificate_found\"; then\n                    # Most likely a backup SPKI, unfortunately we can't tell for what it is: host, intermediates\n                    has_backup_spki=true\n                    backup_spki[i]=\"$(strip_lf \"$hpkp_spki\")\"     # save it for later\n                    backup_spki_str[i]=\"\"                        # no root ca\n                    i=$((i + 1))\n                    fileout \"HPKP_$hpkp_spki\" \"INFO\" \"SPKI $hpkp_spki doesn't match anything. This is ok for a backup for any certificate\"\n                    # CSV/JSON output here for the sake of simplicity, rest we do en bloc below\n               fi\n          done\n\n          # now print every backup spki out we saved before\n          out \"\\n$spaces_indented Backups:   \"\n\n          # for i=0 manually do the same as below as there's other indentation here\n          if [[ -n \"${backup_spki_str[0]}\" ]]; then\n               pr_svrty_good \"${backup_spki[0]}\"\n               #out \" Root CA: \"\n               prln_italic \" ${backup_spki_str[0]}\"\n          else\n               outln \"${backup_spki[0]}\"\n          fi\n          # now for i=1\n          for ((i=1; i < ${#backup_spki[@]} ;i++ )); do\n               if [[ -n \"${backup_spki_str[i]}\" ]]; then\n                    # it's a Root CA outside the chain\n                    pr_svrty_good \"$spaces_indented            ${backup_spki[i]}\"\n                    #out \" Root CA: \"\n                    prln_italic \" ${backup_spki_str[i]}\"\n               else\n                    outln \"$spaces_indented            ${backup_spki[i]}\"\n               fi\n          done\n          if [[ ! -f \"$ca_hashes\" ]] && \"$spki_match\"; then\n               out \"$spaces \"\n               prln_warning \"Attribution of further hashes couldn't be done as $ca_hashes could not be found\"\n               fileout \"HPKP_SPKImatch\" \"WARN\" \"Attribution of further hashes possible as $ca_hashes could not be found\"\n          fi\n\n          # If all else fails...\n          if ! \"$spki_match\"; then\n               \"$has_backup_spki\" && out \"$spaces\"       # we had a few lines with backup SPKIs already\n               prln_svrty_high \" No matching key for SPKI found \"\n               fileout \"HPKP_SPKImatch\" \"HIGH\" \"None of the SPKI match your host certificate, intermediate CA or known root CAs. Bricked site?\"\n               set_grade_cap \"A\" \"Problems with HTTP Public Key Pinning (HPKP)\"\n          fi\n\n          if ! \"$has_backup_spki\"; then\n               prln_svrty_high \" No backup keys found. Loss/compromise of the currently pinned key(s) will lead to bricked site. \"\n               fileout \"HPKP_backup\" \"HIGH\" \"No backup keys found. Loss/compromise of the currently pinned key(s) will lead to bricked site.\"\n               set_grade_cap \"A\" \"Problems with HTTP Public Key Pinning (HPKP)\"\n          fi\n     else\n          outln \"--\"\n          fileout \"HPKP\" \"INFO\" \"No support for HTTP Public Key Pinning\"\n     fi\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\nemphasize_stuff_in_headers(){\n     local html_brown=\"<span style=\\\\\\\"color:#8a7237;\\\\\\\">\"\n     local html_yellow=\"<span style=\\\\\\\"color:#8a7237;font-weight:bold;\\\\\\\">\"\n     local html_off=\"<\\\\/span>\"\n\n# see https://www.grymoire.com/Unix/Sed.html#uh-3\n#    outln \"$1\" | sed \"s/[0-9]*/$brown&${off}/g\"\n     tmln_out \"$1\" | sed -e \"s/\\([0-9]\\)/${brown}\\1${off}/g\" \\\n          -e \"s/Unix/${yellow}Unix${off}/g\" \\\n          -e \"s/Debian/${yellow}Debian${off}/g\" \\\n          -e \"s/Win32/${yellow}Win32${off}/g\" \\\n          -e \"s/Win64/${yellow}Win64${off}/g\" \\\n          -e \"s/Ubuntu/${yellow}Ubuntu${off}/g\" \\\n          -e \"s/ubuntu/${yellow}ubuntu${off}/g\" \\\n          -e \"s/buster/${yellow}buster${off}/g\" \\\n          -e \"s/stretch/${yellow}stretch${off}/g\" \\\n          -e \"s/jessie/${yellow}jessie${off}/g\" \\\n          -e \"s/squeeze/${yellow}squeeze${off}/g\" \\\n          -e \"s/wheezy/${yellow}wheezy${off}/g\" \\\n          -e \"s/lenny/${yellow}lenny${off}/g\" \\\n          -e \"s/SUSE/${yellow}SUSE${off}/g\" \\\n          -e \"s/Red Hat Enterprise Linux/${yellow}Red Hat Enterprise Linux${off}/g\" \\\n          -e \"s/Red Hat/${yellow}Red Hat${off}/g\" \\\n          -e \"s/CentOS/${yellow}CentOS${off}/g\" \\\n          -e \"s/Via/${yellow}Via${off}/g\" \\\n          -e \"s/X-Forwarded/${yellow}X-Forwarded${off}/g\" \\\n          -e \"s/X-TYPO3-Parsetime/${yellow}X-TYPO3-Parsetime${off}/g\" \\\n          -e \"s/Liferay-Portal/${yellow}Liferay-Portal${off}/g\" \\\n          -e \"s/X-Cache-Lookup/${yellow}X-Cache-Lookup${off}/g\" \\\n          -e \"s/X-Cache/${yellow}X-Cache${off}/g\" \\\n          -e \"s/X-Squid/${yellow}X-Squid${off}/g\" \\\n          -e \"s/X-Server/${yellow}X-Server${off}/g\" \\\n          -e \"s/X-Varnish/${yellow}X-Varnish${off}/g\" \\\n          -e \"s/X-OWA-Version/${yellow}X-OWA-Version${off}/g\" \\\n          -e \"s/MicrosoftSharePointTeamServices/${yellow}MicrosoftSharePointTeamServices${off}/g\" \\\n          -e \"s/X-Application-Context/${yellow}X-Application-Context${off}/g\" \\\n          -e \"s/X-Version/${yellow}X-Version${off}/g\" \\\n          -e \"s/X-Powered-By/${yellow}X-Powered-By${off}/g\" \\\n          -e \"s/X-UA-Compatible/${yellow}X-UA-Compatible${off}/g\" \\\n          -e \"s/Link/${yellow}Link${off}/g\" \\\n          -e \"s/X-Rack-Cache/${yellow}X-Rack-Cache${off}/g\" \\\n          -e \"s/X-Runtime/${yellow}X-Runtime${off}/g\" \\\n          -e \"s/X-Pingback/${yellow}X-Pingback${off}/g\" \\\n          -e \"s/X-Permitted-Cross-Domain-Policies/${yellow}X-Permitted-Cross-Domain-Policies${off}/g\" \\\n          -e \"s/X-AspNet-Version/${yellow}X-AspNet-Version${off}/g\" \\\n          -e \"s/x-note/${yellow}x-note${off}/g\" \\\n          -e \"s/x-global-transaction-id/${yellow}x-global-transaction-id${off}/g\" \\\n          -e \"s/X-Global-Transaction-ID/${yellow}X-Global-Transaction-ID${off}/g\" \\\n          -e \"s/Alt-Svc/${yellow}Alt-Svc${off}/g\" \\\n          -e \"s/system-wsgw-management-loopback/${yellow}system-wsgw-management-loopback${off}/g\"\n\n     if \"$do_html\"; then\n          if [[ $COLOR -ge 2 ]]; then\n               html_out \"$(tm_out \"$1\" | sed -e 's/\\&/\\&amp;/g' \\\n                    -e 's/</\\&lt;/g' -e 's/>/\\&gt;/g' -e 's/\"/\\&quot;/g' -e \"s/'/\\&apos;/g\" \\\n                    -e \"s/\\([0-9]\\)/${html_brown}\\1${html_off}/g\" \\\n                    -e \"s/Unix/${html_yellow}Unix${html_off}/g\" \\\n                    -e \"s/Debian/${html_yellow}Debian${html_off}/g\" \\\n                    -e \"s/Win32/${html_yellow}Win32${html_off}/g\" \\\n                    -e \"s/Win64/${html_yellow}Win64${html_off}/g\" \\\n                    -e \"s/Ubuntu/${html_yellow}Ubuntu${html_off}/g\" \\\n                    -e \"s/ubuntu/${html_yellow}ubuntu${html_off}/g\" \\\n                    -e \"s/buster/${html_yellow}buster${html_off}/g\" \\\n                    -e \"s/stretch/${html_yellow}stretch${html_off}/g\" \\\n                    -e \"s/jessie/${html_yellow}jessie${html_off}/g\" \\\n                    -e \"s/squeeze/${html_yellow}squeeze${html_off}/g\" \\\n                    -e \"s/wheezy/${html_yellow}wheezy${html_off}/g\" \\\n                    -e \"s/lenny/${html_yellow}lenny${html_off}/g\" \\\n                    -e \"s/SUSE/${html_yellow}SUSE${html_off}/g\" \\\n                    -e \"s/Red Hat Enterprise Linux/${html_yellow}Red Hat Enterprise Linux${html_off}/g\" \\\n                    -e \"s/Red Hat/${html_yellow}Red Hat${html_off}/g\" \\\n                    -e \"s/CentOS/${html_yellow}CentOS${html_off}/g\" \\\n                    -e \"s/Via/${html_yellow}Via${html_off}/g\" \\\n                    -e \"s/X-Forwarded/${html_yellow}X-Forwarded${html_off}/g\" \\\n                    -e \"s/X-TYPO3-Parsetime/${yellow}X-TYPO3-Parsetime${html_off}/g\" \\\n                    -e \"s/Liferay-Portal/${html_yellow}Liferay-Portal${html_off}/g\" \\\n                    -e \"s/X-Cache-Lookup/${html_yellow}X-Cache-Lookup${html_off}/g\" \\\n                    -e \"s/X-Cache/${html_yellow}X-Cache${html_off}/g\" \\\n                    -e \"s/X-Squid/${html_yellow}X-Squid${html_off}/g\" \\\n                    -e \"s/X-Server/${html_yellow}X-Server${html_off}/g\" \\\n                    -e \"s/X-Varnish/${html_yellow}X-Varnish${html_off}/g\" \\\n                    -e \"s/X-OWA-Version/${html_yellow}X-OWA-Version${html_off}/g\" \\\n                    -e \"s/MicrosoftSharePointTeamServices/${html_yellow}MicrosoftSharePointTeamServices${html_off}/g\" \\\n                    -e \"s/X-Application-Context/${html_yellow}X-Application-Context${html_off}/g\" \\\n                    -e \"s/X-Version/${html_yellow}X-Version${html_off}/g\" \\\n                    -e \"s/X-Powered-By/${html_yellow}X-Powered-By${html_off}/g\" \\\n                    -e \"s/X-UA-Compatible/${html_yellow}X-UA-Compatible${html_off}/g\" \\\n                    -e \"s/Link/${html_yellow}Link${html_off}/g\" \\\n                    -e \"s/X-Runtime/${html_yellow}X-Runtime${html_off}/g\" \\\n                    -e \"s/X-Rack-Cache/${html_yellow}X-Rack-Cache${html_off}/g\" \\\n                    -e \"s/X-Pingback/${html_yellow}X-Pingback${html_off}/g\" \\\n                    -e \"s/X-Permitted-Cross-Domain-Policies/${html_yellow}X-Permitted-Cross-Domain-Policies${html_off}/g\" \\\n                    -e \"s/X-AspNet-Version/${html_yellow}X-AspNet-Version${html_off}/g\")\" \\\n                    -e \"s/x-note/${html_yellow}x-note${html_off}/g\" \\\n                    -e \"s/X-Global-Transaction-ID/${html_yellow}X-Global-Transaction-ID${html_off}/g\" \\\n                    -e \"s/x-global-transaction-id/${html_yellow}x-global-transaction-id${html_off}/g\" \\\n                    -e \"s/Alt-Svc/${html_yellow}Alt-Svc${html_off}/g\" \\\n                    -e \"s/system-wsgw-management-loopback/${html_yellow}system-wsgw-management-loopback${html_off}/g\"\n#FIXME: this is double code. The pattern to emphasize would fit better into\n# one function.\n# Also we need another function like run_other_header as otherwise \"Link\" \"Alt-Svc\" will never be found.\n# And: I matches case sensitive only which might not detect all banners. (sed ignorecase is not possible w/ BSD sed)\n          else\n               html_out \"$(html_reserved \"$1\")\"\n          fi\n          html_out \"\\n\"\n     fi\n}\n\nrun_server_banner() {\n     local serverbanner\n     local jsonID=\"banner_server\"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n     pr_bold \" Server banner                \"\n     grep -ai '^Server' $HEADERFILE >$TMPFILE\n     if [[ $? -eq 0 ]]; then\n          serverbanner=$(sed -e 's/^Server: //' -e 's/^server: //' $TMPFILE)\n          serverbanner=${serverbanner//$'\\r'}\n          serverbanner=${serverbanner//$'\\n'}\n          if [[ -z \"$serverbanner\" ]]; then\n               outln \"exists but empty string\"\n               fileout \"$jsonID\" \"INFO\" \"Server banner is empty\"\n          else\n               emphasize_stuff_in_headers \"$serverbanner\"\n               fileout \"$jsonID\" \"INFO\" \"$serverbanner\"\n               if [[ \"$serverbanner\" == *Microsoft-IIS/6.* ]] && [[ $OSSL_VER == 1.0.2* ]]; then\n                    prln_warning \"                              It's recommended to run another test w/ OpenSSL >= 1.0.1 !\"\n                    # see https://github.com/PeterMosmans/openssl/issues/19#issuecomment-100897892\n                    fileout \"${jsonID}\" \"WARN\" \"IIS6_openssl_mismatch: Recommended to rerun this test w/ OpenSSL >= 1.0.1. See https://github.com/PeterMosmans/openssl/issues/19#issuecomment-100897892\"\n               fi\n          fi\n          # mozilla.github.io/server-side-tls/ssl-config-generator/\n          # https://support.microsoft.com/en-us/kb/245030\n     else\n          outln \"(no \\\"Server\\\" line in header, interesting!)\"\n          fileout \"$jsonID\" \"INFO\" \"No Server banner line in header, interesting!\"\n     fi\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\nrun_appl_banner() {\n     local line\n     local first=true\n     local spaces=\"                              \"\n     local appl_banners=\"\"\n     local jsonID=\"banner_application\"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n     pr_bold \" Application banner           \"\n     grep -Eai '^X-Powered-By|^X-AspNet-Version|^X-Version|^Liferay-Portal|^X-TYPO3-Parsetime|^X-OWA-Version^|^MicrosoftSharePointTeamServices' $HEADERFILE >$TMPFILE\n     if [[ $? -ne 0 ]]; then\n          outln \"--\"\n          fileout \"$jsonID\" \"INFO\" \"No application banner found\"\n     else\n          while IFS='' read -r line; do\n               line=$(strip_lf \"$line\")\n               if ! $first; then\n                    out \"$spaces\"\n                    appl_banners=\"${appl_banners}, ${line}\"\n               else\n                    appl_banners=\"${line}\"\n                    first=false\n               fi\n               emphasize_stuff_in_headers \"$line\"\n          done < \"$TMPFILE\"\n          fileout \"$jsonID\" \"INFO\" \"$appl_banners\"\n     fi\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\nrun_rp_banner() {\n     local line\n     local first=true\n     local spaces=\"                              \"\n     local rp_banners=\"\"\n     local jsonID=\"banner_reverseproxy\"\n     local cwe=\"CWE-200\"\n     local cve=\"\"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n     pr_bold \" Reverse Proxy banner         \"\n     grep -Eai '^Via:|^X-Cache|^X-Squid|^X-Varnish:|^X-Server-Name:|^X-Server-Port:|^x-forwarded|^Forwarded' $HEADERFILE >$TMPFILE\n     if [[ $? -ne 0 ]]; then\n          outln \"--\"\n          fileout \"$jsonID\" \"INFO\" \"--\" \"$cve\" \"$cwe\"\n     else\n          while read line; do\n               line=$(strip_lf \"$line\")\n               if $first; then\n                    first=false\n               else\n                    out \"$spaces\"\n               fi\n               emphasize_stuff_in_headers \"$line\"\n               rp_banners=\"${rp_banners}${line}\"\n          done < $TMPFILE\n          fileout \"$jsonID\" \"INFO\" \"$rp_banners\" \"$cve\" \"$cwe\"\n     fi\n     outln\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\n\n# arg1: multiline string w cookies\n#\nsub_f5_bigip_check() {\n     local allcookies=\"$1\"\n     local ip port cookievalue cookiename\n     local routed_domain offset\n     local savedcookies=\"\"\n     local spaces=\"$2\"\n     local cwe=\"CWE-212\"\n     local cve=\"\"\n\n     # taken from https://github.com/drwetter/F5-BIGIP-Decoder, more details see there\n\n     debugme echo -e \"all cookies: >> $allcookies <<\\n\"\n     while true; do IFS='=' read cookiename cookievalue\n          [[ -z \"$cookievalue\" ]] && break\n          cookievalue=${cookievalue/;/}\n          debugme echo $cookiename : $cookievalue\n          if grep -Eq '[0-9]{8,10}\\.[0-9]{3,5}\\.0000' <<< \"$cookievalue\"; then\n               ip=\"$(f5_ip_oldstyle \"$cookievalue\")\"\n               port=\"$(f5_port_decode $cookievalue)\"\n               out \"${spaces}F5 cookie (default IPv4 pool member): \"; pr_italic \"$cookiename \"; prln_svrty_medium \"${ip}:${port}\"\n               fileout \"cookie_bigip_f5\" \"MEDIUM\" \"Information leakage: F5 cookie $cookiename $cookievalue is default IPv4 pool member ${ip}:${port}\" \"$cve\" \"$cwe\"\n          elif grep -Eq '^rd[0-9]{1,3}o0{20}f{4}[a-f0-9]{8}o[0-9]{1,5}' <<< \"$cookievalue\"; then\n               routed_domain=\"$(f5_determine_routeddomain \"$cookievalue\")\"\n               offset=$(( 2 + ${#routed_domain} + 1 + 24))\n               port=\"${cookievalue##*o}\"\n               ip=\"$(f5_hex2ip \"${cookievalue:$offset:8}\")\"\n               out \"${spaces}F5 cookie (IPv4 pool in routed domain \"; pr_svrty_medium \"$routed_domain\"; out \"): \"; pr_italic \"$cookiename \"; prln_svrty_medium \"${ip}:${port}\"\n               fileout \"cookie_bigip_f5\" \"MEDIUM\" \"Information leakage: F5 cookie $cookiename $cookievalue is IPv4 pool member in routed domain $routed_domain ${ip}:${port}\" \"$cve\" \"$cwe\"\n          elif grep -Eq '^vi[a-f0-9]{32}\\.[0-9]{1,5}' <<< \"$cookievalue\"; then\n               ip=\"$(f5_hex2ip6 ${cookievalue:2:32})\"\n               port=\"${cookievalue##*.}\"\n               port=$(f5_port_decode \"$port\")\n               out \"${spaces}F5 cookie (default IPv6 pool member): \"; pr_italic \"$cookiename \"; prln_svrty_medium \"${ip}:${port}\"\n               fileout \"cookie_bigip_f5\" \"MEDIUM\" \"Information leakage: F5 cookie $cookiename $cookievalue is default IPv6 pool member ${ip}:${port}\" \"$cve\" \"$cwe\"\n          elif grep -Eq '^rd[0-9]{1,3}o[a-f0-9]{32}o[0-9]{1,5}' <<< \"$cookievalue\"; then\n               routed_domain=\"$(f5_determine_routeddomain \"$cookievalue\")\"\n               offset=$(( 2 + ${#routed_domain} + 1 ))\n               port=\"${cookievalue##*o}\"\n               ip=\"$(f5_hex2ip6 ${cookievalue:$offset:32})\"\n               out \"${spaces}F5 cookie (IPv6 pool in routed domain \"; pr_svrty_medium \"$routed_domain\"; out \"): \"; pr_italic \"$cookiename \"; prln_svrty_medium \"${ip}:${port}\"\n               fileout \"cookie_bigip_f5\" \"MEDIUM\" \"Information leakage: F5 cookie $cookiename $cookievalue is IPv6 pool member in routed domain $routed_domain ${ip}:${port}\" \"$cve\" \"$cwe\"\n          elif grep -Eq '^!.*=$' <<< \"$cookievalue\"; then\n               if [[ \"${#cookievalue}\" -eq 81 ]] ; then\n                    savedcookies=\"${savedcookies}     ${cookiename}=${cookievalue:1:79}\"\n                    out \"${spaces}Encrypted F5 cookie named \"; pr_italic \"${cookiename}\"; outln \" detected\"\n                    fileout \"cookie_bigip_f5\" \"INFO\" \"encrypted F5 cookie named ${cookiename}\"\n               fi\n          fi\n     done <<< \"$allcookies\"\n}\n\n\nrun_cookie_flags() {     # ARG1: Path\n     local -i nr_cookies\n     local -i nr_httponly nr_secure\n     local negative_word\n     local msg302=\"\" msg302_=\"\"\n     local spaces=\"                              \"\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n\n     if [[ ! \"$HTTP_STATUS_CODE\" =~ 20 ]]; then\n          if [[ \"$HTTP_STATUS_CODE\" =~ [301|302] ]]; then\n               msg302=\" -- maybe better try target URL of 30x\"\n               msg302_=\" (30x detected, better try target URL of 30x)\"\n          else\n               msg302=\" -- HTTP status $HTTP_STATUS_CODE signals you maybe missed the web application\"\n               msg302_=\" (maybe missed the application)\"\n          fi\n     fi\n\n     pr_bold \" Cookie(s)                    \"\n     grep -ai '^Set-Cookie' $HEADERFILE >$TMPFILE\n     if [[ $? -ne 0 ]]; then\n          outln \"(none issued at \\\"$1\\\")$msg302\"\n          fileout \"cookie_count\" \"INFO\" \"0 at \\\"$1\\\"$msg302_\"\n     else\n          nr_cookies=$(count_lines \"$(cat $TMPFILE)\")\n          out \"$nr_cookies issued: \"\n          fileout \"cookie_count\" \"INFO\" \"$nr_cookies at \\\"$1\\\"$msg302_\"\n          if [[ $nr_cookies -gt 1 ]]; then\n               negative_word=\"NONE\"\n          else\n               negative_word=\"NOT\"\n          fi\n          nr_secure=$(grep -iac secure $TMPFILE)\n          case $nr_secure in\n               0) pr_svrty_medium \"$negative_word\" ;;\n               [123456789]) pr_svrty_good \"$nr_secure/$nr_cookies\";;\n          esac\n          out \" secure, \"\n          if [[ $nr_cookies -eq $nr_secure ]]; then\n               fileout \"cookie_secure\" \"OK\" \"All ($nr_cookies) at \\\"$1\\\" marked as secure\"\n          else\n               fileout \"cookie_secure\" \"INFO\" \"$nr_secure/$nr_cookies at \\\"$1\\\" marked as secure\"\n          fi\n          nr_httponly=$(grep -cai httponly $TMPFILE)\n          case $nr_httponly in\n               0) pr_svrty_medium \"$negative_word\" ;;\n               [123456789]) pr_svrty_good \"$nr_httponly/$nr_cookies\";;\n          esac\n          out \" HttpOnly\"\n          if [[ $nr_cookies -eq $nr_httponly ]]; then\n               fileout \"cookie_httponly\" \"OK\" \"All ($nr_cookies) at \\\"$1\\\" marked as HttpOnly$msg302_\"\n          else\n               fileout \"cookie_httponly\" \"INFO\" \"$nr_secure/$nr_cookies at \\\"$1\\\" marked as HttpOnly$msg302_\"\n          fi\n          outln \"$msg302\"\n          allcookies=\"$(awk '/[Ss][Ee][Tt]-[Cc][Oo][Oo][Kk][Ii][Ee]:/ { print $2 }' \"$TMPFILE\")\"\n          sub_f5_bigip_check \"$allcookies\" \"$spaces\"\n     fi\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\n\nrun_security_headers() {\n     local header header_output svrty header_and_svrty\n     local first=true\n     local spaces=\"                              \"\n     local have_header=false\n\n     if [[ ! -s $HEADERFILE ]]; then\n          run_http_header \"$1\" || return 1\n     fi\n\n     pr_bold \" Security headers             \"\n     # X-XSS-Protection is useless and at worst harmful, see https://news.ycombinator.com/item?id=20472947\n     for header_and_svrty in \"X-Frame-Options OK\" \\\n                             \"X-Content-Type-Options OK\" \\\n                             \"Content-Security-Policy OK\" \\\n                             \"X-Content-Security-Policy OK\" \\\n                             \"X-WebKit-CSP OK\" \\\n                             \"Content-Security-Policy-Report-Only OK\" \\\n                             \"Expect-CT OK\" \\\n                             \"Permissions-Policy OK\" \\\n                             \"X-XSS-Protection INFO\" \\\n                             \"Access-Control-Allow-Origin INFO\" \\\n                             \"Upgrade INFO\" \\\n                             \"X-Served-By INFO\" \\\n                             \"Referrer-Policy INFO\" \\\n                             \"X-UA-Compatible INFO\" \\\n                             \"Cache-Control INFO\" \\\n                             \"Pragma INFO\"; do\n          read header svrty <<< \"${header_and_svrty}\"\n          [[ \"$DEBUG\" -ge 5 ]] &&  echo \"testing \\\"$header\\\" (severity \\\"$svrty\\\")\"\n          match_httpheader_key \"$header\" \"$header\" \"$spaces\" \"$first\"\n          if [[ $? -ge 1 ]]; then\n               have_header=true\n               if \"$first\"; then\n                    first=false\n               fi\n               case \"$svrty\" in\n                    OK) pr_svrty_good \"$header\" ;;\n                    LOW) pr_svrty_low \"$header\" ;;\n                    INFO) out \"$header\" ;;\n               esac\n               # Include $header when determining where to insert line breaks, but print $header\n               # separately.\n               header_output=\"$(out_row_aligned_max_width \"${header:2}: $HEADERVALUE\" \"$spaces  \" $TERM_WIDTH)\"\n               outln \"${header_output#${header:2}}\"\n               fileout \"$header\" \"$svrty\" \"$HEADERVALUE\"\n          fi\n     done\n\n     #TODO: I am not testing for the correctness or anything stupid yet, e.g. \"X-Frame-Options: allowall\" or Access-Control-Allow-Origin: *\n\n     if ! \"$have_header\"; then\n          prln_svrty_medium \"--\"\n          fileout \"security_headers\" \"MEDIUM\" \"--\"\n     fi\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\n\n# #1: string with 2 openssl codes, output is same in NSS/ssllabs terminology\nnormalize_ciphercode() {\n     if [[ \"${1:2:2}\" == \"00\" ]]; then\n          tm_out \"$(tolower \"x${1:7:2}\")\"\n     else\n          tm_out \"$(tolower \"x${1:2:2}${1:7:2}${1:12:2}\")\"\n     fi\n     return 0\n}\n\nprettyprint_local() {\n     local arg line\n     local hexc hexcode dash ciph sslvers kx auth enc mac export\n     local re='^[0-9A-Fa-f]+$'\n\n     if [[ \"$1\" == 0x* ]] || [[ \"$1\" == 0X* ]]; then\n          fatal_cmd_line \"pls supply x<number> instead\" $ERR_CMDLINE\n     fi\n\n     if [[ -z \"$1\" ]]; then\n          pr_headline \" Displaying all $OPENSSL_NR_CIPHERS local ciphers \";\n     else\n          pr_headline \" Displaying all local ciphers \";\n          # pattern provided; which one?\n          [[ $1 =~ $re ]] && \\\n               pr_headline \"matching number pattern \\\"$1\\\" \" || \\\n               pr_headline \"matching word pattern \"\\\"$1\\\"\" (ignore case) \"\n     fi\n     outln \"\\n\"\n     neat_header\n\n     if [[ -z \"$1\" ]]; then\n          while read -r hexcode dash ciph sslvers kx auth enc mac export ; do\n               hexc=\"$(normalize_ciphercode $hexcode)\"\n               outln \"$(neat_list \"$hexc\" \"$ciph\" \"$kx\" \"$enc\" \"$export\")\"\n          done < <(actually_supported_osslciphers 'ALL:COMPLEMENTOFALL:@STRENGTH' 'ALL' \"-V\")  # -V doesn't work with openssl < 1.0\n     else\n          #for arg in $(echo $@ | sed 's/,/ /g'); do\n          for arg in ${*//,/ /}; do\n               while read -r hexcode dash ciph sslvers kx auth enc mac export ; do\n                    hexc=\"$(normalize_ciphercode $hexcode)\"\n                    # for numbers we don't do word matching:\n                    [[ $arg =~ $re ]] && \\\n                         line=\"$(neat_list \"$hexc\" \"$ciph\" \"$kx\" \"$enc\" \"$export\" | grep -ai \"$arg\")\" || \\\n                         line=\"$(neat_list \"$hexc\" \"$ciph\" \"$kx\" \"$enc\" \"$export\" | grep -wai \"$arg\")\"\n                    [[ -n \"$line\" ]] && outln \"$line\"\n               done < <(actually_supported_osslciphers 'ALL:COMPLEMENTOFALL:@STRENGTH' 'ALL' \"-V\") # -V doesn't work with openssl < 1.0\n          done\n     fi\n     outln\n     return 0\n}\n\n\n# Generic function for a rated output, no used yet.\n# arg1: rating from 2 to -4 if available or not\n# arg2: no/yes: decides whether positive or negative logic will be applied and \"not\" will be printed\n# arg3: jsonID\n#\nrated_output() {\n     local jsonID=$3\n     local logic=\"\"\n\n     if [[ $2 == no ]] || [[ $2 == negative ]]; then\n          logic=\"not \"\n     fi\n     case $1 in\n          2)   pr_svrty_best \"${logic}offered (OK)\"\n               fileout \"${jsonID}\" \"OK\" \"${logic}offered\"\n               ;;\n          1)   pr_svrty_good \"${logic}offered (OK)\"\n               fileout \"${jsonID}\" \"OK\" \"${logic}offered\"\n               ;;\n          0)   out \"${logic}offered\"\n               fileout \"${jsonID}\" \"INFO\" \"${logic}offered\"\n               ;;\n          -1)  pr_svrty_low \"${logic}offered\"\n               fileout \"${jsonID}\" \"LOW\" \"${logic}offered\"\n               ;;\n          -2)  pr_svrty_medium \"${logic}offered\"\n               fileout \"${jsonID}\" \"MEDIUM\" \"${logic}offered\"\n               ;;\n          -3)  pr_svrty_high \"${logic}offered (NOT ok)\"\n               fileout \"${jsonID}\" \"HIGH\" \"${logic}offered\"\n               ;;\n          -4)  pr_svrty_critical \"${logic}offered (NOT ok)\"\n               fileout \"${jsonID}\" \"CRITICAL\" \"${logic}offered\"\n               ;;\n          *)   pr_warning \"FIXME: error around $LINENO, (please report this)\"\n               fileout \"${jsonID}\" \"WARN\" \"return condition $2 when $1 unclear\"\n               return 1\n               ;;\n     esac\n     return 0\n}\n\n\nopenssl2rfc() {\n     local rfcname=\"\"\n     local -i i\n\n     for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n          [[ \"$1\" == ${TLS_CIPHER_OSSL_NAME[i]} ]] && rfcname=\"${TLS_CIPHER_RFC_NAME[i]}\" && break\n     done\n     [[ \"$rfcname\" == \"-\" ]] && rfcname=\"\"\n     [[ -n \"$rfcname\" ]] && tm_out \"$rfcname\"\n     return 0\n}\n\nrfc2openssl() {\n     local ossl_name\n     local -i i\n\n     for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n          [[ \"$1\" == ${TLS_CIPHER_RFC_NAME[i]} ]] && ossl_name=\"${TLS_CIPHER_OSSL_NAME[i]}\" && break\n     done\n     [[ \"$ossl_name\" == \"-\" ]] && ossl_name=\"\"\n     [[ -n \"$ossl_name\" ]] && tm_out \"$ossl_name\"\n     return 0\n}\n\nopenssl2hexcode() {\n     local hexc=\"\"\n     local -i i\n\n     if [[ $TLS_NR_CIPHERS -eq 0 ]]; then\n          if \"$HAS_CIPHERSUITES\"; then\n               hexc=\"$($OPENSSL ciphers -V -ciphersuites \"$TLS13_OSSL_CIPHERS\" 'ALL:COMPLEMENTOFALL:@STRENGTH' | awk '/ '\"$1\"' / { print $1 }')\"\n          elif \"$HAS_SSL2\"; then\n               hexc=\"$($OPENSSL ciphers -V -tls1 'ALL:COMPLEMENTOFALL:@STRENGTH' | awk '/ '\"$1\"' / { print $1 }')\"\n          else\n               hexc=\"$($OPENSSL ciphers -V 'ALL:COMPLEMENTOFALL:@STRENGTH' | awk '/ '\"$1\"' / { print $1 }')\"\n          fi\n     else\n          for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n               [[ \"$1\" == ${TLS_CIPHER_OSSL_NAME[i]} ]] && hexc=\"${TLS_CIPHER_HEXCODE[i]}\" && break\n          done\n     fi\n     [[ -z \"$hexc\" ]] && return 1\n     tm_out \"$hexc\"\n     return 0\n}\n\nrfc2hexcode() {\n     local hexc=\"\"\n     local -i i\n\n     for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n          [[ \"$1\" == ${TLS_CIPHER_RFC_NAME[i]} ]] && hexc=\"${TLS_CIPHER_HEXCODE[i]}\" && break\n     done\n     [[ -z \"$hexc\" ]] && return 1\n     tm_out \"$hexc\"\n     return 0\n}\n\nshow_rfc_style(){\n     local rfcname=\"\" hexcode\n     local -i i\n\n     hexcode=\"$(toupper \"$1\")\"\n     case ${#hexcode} in\n          3) hexcode=\"0x00,0x${hexcode:1:2}\" ;;\n          5) hexcode=\"0x${hexcode:1:2},0x${hexcode:3:2}\" ;;\n          7) hexcode=\"0x${hexcode:1:2},0x${hexcode:3:2},0x${hexcode:5:2}\" ;;\n          *) return 1 ;;\n     esac\n     for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n          [[ \"$hexcode\" == ${TLS_CIPHER_HEXCODE[i]} ]] && rfcname=\"${TLS_CIPHER_RFC_NAME[i]}\" && break\n     done\n     [[ \"$rfcname\" == \"-\" ]] && rfcname=\"\"\n     [[ -n \"$rfcname\" ]] && tm_out \"$rfcname\"\n     return 0\n}\n\nneat_header(){\n     if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n          out \"$(printf -- \"Hexcode  Cipher Suite Name (IANA/RFC)                      KeyExch.   Encryption  Bits\")\"\n          [[ \"$DISPLAY_CIPHERNAMES\" != rfc-only ]] && out \"$(printf -- \"     Cipher Suite Name (OpenSSL)\")\"\n          outln\n          out \"$(printf -- \"%s------------------------------------------------------------------------------------------\")\"\n          [[ \"$DISPLAY_CIPHERNAMES\" != rfc-only ]] && out \"$(printf -- \"---------------------------------------\")\"\n          outln\n     else\n          out \"$(printf -- \"Hexcode  Cipher Suite Name (OpenSSL)       KeyExch.   Encryption  Bits\")\"\n          [[ \"$DISPLAY_CIPHERNAMES\" != openssl-only ]] && out \"$(printf -- \"     Cipher Suite Name (IANA/RFC)\")\"\n          outln\n          out \"$(printf -- \"%s--------------------------------------------------------------------------\")\"\n          [[ \"$DISPLAY_CIPHERNAMES\" != openssl-only ]] && out \"$(printf -- \"---------------------------------------------------\")\"\n          outln\n     fi\n}\n\n\n# arg1: hexcode\n# arg2: cipher in openssl notation\n# arg3: keyexchange\n# arg4: encryption (maybe included \"export\")\n# arg5: \"export\" if the cipher is an export-quality cipher, empty otherwise.\n# arg6: not a boolean!\n#       \"true\" : if the cipher's \"quality\" should be highlighted\n#       \"false\": if the line should be printed in light grey\n#       \"\"     : if line should be returned as a string\n\nneat_list(){\n     local hexcode=\"$1\"\n     local ossl_cipher=\"$2\" export=\"$5\" tls_cipher=\"\"\n     local kx enc strength line what_dh bits\n     local -i i len\n     local how2show=\"$6\"\n\n     kx=\"${3//Kx=/}\"\n     kx=\"$(strip_trailing_space \"$kx\")\"\n     enc=\"${4//Enc=/}\"\n     # In two cases LibreSSL uses very long names for encryption algorithms\n     # and doesn't include the number of bits.\n     [[ \"$enc\" == ChaCha20-Poly1305 ]] && enc=\"CHACHA20(256)\"\n     [[ \"$enc\" == GOST-28178-89-CNT ]] && enc=\"GOST(256)\"\n\n     strength=\"${enc//\\)/}\"             # retrieve (). first remove trailing \")\"\n     strength=\"${strength#*\\(}\"         # exfiltrate (VAL\n     enc=\"${enc%%\\(*}\"\n\n     enc=\"${enc//POLY1305/}\"            # remove POLY1305\n     enc=\"${enc//\\//}\"                  # remove \"/\"\n\n     # For rating set bit size but only when cipher is supported by server.\n     if [[ $how2show == true ]]; then\n          set_ciph_str_score $strength\n     fi\n\n     [[ \"$export\" =~ export ]] && strength=\"$strength,exp\"\n\n     [[ \"$DISPLAY_CIPHERNAMES\" != openssl-only ]] && tls_cipher=\"$(show_rfc_style \"$hexcode\")\"\n\n     # global var SHOW_EACH_C determines whether we display all tested ciphers\n     if [[ \"$how2show\" != true ]]; then\n          if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n               line=\"$(printf -- \" %-7s %-49s %-10s %-12s%-8s\" \"$hexcode\" \"$tls_cipher\" \"$kx\" \"$enc\" \"$strength\")\"\n               [[ \"$DISPLAY_CIPHERNAMES\" != rfc-only ]] && line+=\"$(printf -- \" %-33s${SHOW_EACH_C:+  %-0s}\" \"$ossl_cipher\")\"\n          else\n               line=\"$(printf -- \" %-7s %-33s %-10s %-12s%-8s\" \"$hexcode\" \"$ossl_cipher\" \"$kx\" \"$enc\" \"$strength\")\"\n               [[ \"$DISPLAY_CIPHERNAMES\" != openssl-only ]] && line+=\"$(printf -- \" %-49s${SHOW_EACH_C:+  %-0s}\" \"$tls_cipher\")\"\n          fi\n          if [[ -z \"$how2show\" ]]; then\n               tm_out \"$line\"\n          else\n               pr_deemphasize \"$line\"\n          fi\n          return 0\n     fi\n     if [[ \"$kx\" =~ \" \" ]]; then\n          what_dh=\"${kx%% *}\"\n          bits=\"${kx##* }\"\n     else\n          what_dh=\"$kx\"\n          bits=\"\"\n     fi\n     if [[ \"$COLOR\" -le 2 ]]; then\n          if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n               out \"$(printf -- \" %-7s %-49s \" \"$hexcode\" \"$tls_cipher\")\"\n          else\n               out \"$(printf -- \" %-7s %-33s \" \"$hexcode\" \"$ossl_cipher\")\"\n          fi\n     else\n          out \"$(printf -- \" %-7s \" \"$hexcode\")\"\n          if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n               print_fixed_width \"$tls_cipher\" 49 pr_cipher_quality\n          else\n               print_fixed_width \"$ossl_cipher\" 33 pr_cipher_quality\n          fi\n     fi\n     out \"$what_dh\"\n     if [[ -n \"$bits\" ]]; then\n          if [[ $what_dh == DH ]] || [[ $what_dh == EDH ]]; then\n               pr_dh_quality \"$bits\" \" $bits\"\n          elif [[ $what_dh == ECDH ]]; then\n               pr_ecdh_quality \"$bits\" \" $bits\"\n          fi\n     fi\n     len=${#kx}\n     print_n_spaces \"$((10-len))\"\n     out \"$(printf -- \" %-12s%-8s \" \"$enc\" \"$strength\")\"\n     if [[ \"$COLOR\" -le 2 ]]; then\n          if [[ \"$DISPLAY_CIPHERNAMES\" == rfc ]]; then\n               out \"$(printf -- \"%-33s${SHOW_EACH_C:+  %-0s}\" \"$ossl_cipher\")\"\n          elif [[ \"$DISPLAY_CIPHERNAMES\" == openssl ]]; then\n               out \"$(printf -- \"%-49s${SHOW_EACH_C:+  %-0s}\" \"$tls_cipher\")\"\n          fi\n     else\n          if [[ \"$DISPLAY_CIPHERNAMES\" == rfc ]]; then\n               print_fixed_width \"$ossl_cipher\" 32 pr_cipher_quality\n          elif [[ \"$DISPLAY_CIPHERNAMES\" == openssl ]]; then\n               print_fixed_width \"$tls_cipher\" 48 pr_cipher_quality\n          fi\n          out \"$(printf -- \"${SHOW_EACH_C:+  %-0s}\")\"\n     fi\n}\n\nrun_cipher_match(){\n     local hexc n auth ciphers_to_test tls13_ciphers_to_test supported_sslv2_ciphers s\n     local -a hexcode normalized_hexcode ciph sslvers kx enc export2 sigalg\n     local -a ciphers_found ciphers_found2 ciph2 rfc_ciph rfc_ciph2 ossl_supported\n     local -a -i index\n     local -i nr_ciphers=0 nr_ossl_ciphers=0 nr_nonossl_ciphers=0\n     local -i num_bundles bundle_size bundle end_of_bundle\n     local dhlen has_dh_bits=\"$HAS_DH_BITS\"\n     local cipher proto protos_to_try\n     local available\n     local -i sclient_success\n     local re='^[0-9A-Fa-f]+$'\n     local using_sockets=true\n\n     \"$SSL_NATIVE\" && using_sockets=false\n     \"$FAST\" && using_sockets=false\n     [[ $TLS_NR_CIPHERS == 0 ]] && using_sockets=false\n\n     pr_headline \" Testing ciphers with \"\n     if [[ $1 =~ $re ]]; then\n          pr_headline \"matching number pattern \\\"$1\\\" \"\n          tjolines=\"$tjolines matching number pattern \\\"$1\\\"\\n\\n\"\n     else\n          pr_headline \"word pattern \"\\\"$1\\\"\" (ignore case) \"\n          tjolines=\"$tjolines word pattern \\\"$1\\\" (ignore case)\\n\\n\"\n     fi\n     outln\n     if ! \"$using_sockets\"; then\n          [[ $TLS_NR_CIPHERS == 0 ]] && ! \"$SSL_NATIVE\" && ! \"$FAST\" && pr_warning \" Cipher mapping not available, doing a fallback to openssl\"\n          if ! \"$HAS_DH_BITS\"; then\n               [[ $TLS_NR_CIPHERS == 0 ]] && ! \"$SSL_NATIVE\" && ! \"$FAST\" && out \".\"\n               prln_warning \"    (Your $OPENSSL cannot show DH/ECDH bits)\"\n          fi\n     fi\n     outln\n     neat_header\n     #for arg in $(echo $@ | sed 's/,/ /g'); do\n     for arg in ${*//, /}; do\n          if \"$using_sockets\" || [[ $OSSL_VER_MAJOR -lt 1 ]]; then\n               for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n                    hexc=\"${TLS_CIPHER_HEXCODE[i]}\"\n                    if [[ ${#hexc} -eq 9 ]]; then\n                         hexcode[nr_ciphers]=\"${hexc:2:2},${hexc:7:2}\"\n                         if [[ \"${hexc:2:2}\" == 00 ]]; then\n                              normalized_hexcode[nr_ciphers]=\"x${hexc:7:2}\"\n                         else\n                              normalized_hexcode[nr_ciphers]=\"x${hexc:2:2}${hexc:7:2}\"\n                         fi\n                    else\n                         hexc=\"$(tolower \"$hexc\")\"\n                         hexcode[nr_ciphers]=\"${hexc:2:2},${hexc:7:2},${hexc:12:2}\"\n                         normalized_hexcode[nr_ciphers]=\"x${hexc:2:2}${hexc:7:2}${hexc:12:2}\"\n                    fi\n                    if [[ $arg =~ $re ]]; then\n                         neat_list \"${normalized_hexcode[nr_ciphers]}\" \"${TLS_CIPHER_OSSL_NAME[i]}\" \"${TLS_CIPHER_KX[i]}\" \"${TLS_CIPHER_ENC[i]}\" \"${TLS_CIPHER_EXPORT[i]}\" | grep -qai \"$arg\"\n                    else\n                         neat_list \"${normalized_hexcode[nr_ciphers]}\" \"${TLS_CIPHER_OSSL_NAME[i]}\" \"${TLS_CIPHER_KX[i]}\" \"${TLS_CIPHER_ENC[i]}\" \"${TLS_CIPHER_EXPORT[i]}\" | grep -qwai \"$arg\"\n                    fi\n                    if [[ $? -eq 0 ]] && { \"$using_sockets\" || \"${TLS_CIPHER_OSSL_SUPPORTED[i]}\"; }; then    # string matches, so we can ssl to it:\n                         normalized_hexcode[nr_ciphers]=\"$(tolower \"${normalized_hexcode[nr_ciphers]}\")\"\n                         ciph[nr_ciphers]=\"${TLS_CIPHER_OSSL_NAME[i]}\"\n                         rfc_ciph[nr_ciphers]=\"${TLS_CIPHER_RFC_NAME[i]}\"\n                         kx[nr_ciphers]=\"${TLS_CIPHER_KX[i]}\"\n                         enc[nr_ciphers]=\"${TLS_CIPHER_ENC[i]}\"\n                         sslvers[nr_ciphers]=\"${TLS_CIPHER_SSLVERS[i]}\"\n                         export2[nr_ciphers]=\"${TLS_CIPHER_EXPORT[i]}\"\n                         ciphers_found[nr_ciphers]=false\n                         sigalg[nr_ciphers]=\"\"\n                         ossl_supported[nr_ciphers]=\"${TLS_CIPHER_OSSL_SUPPORTED[i]}\"\n                         if \"$using_sockets\" && ! \"$has_dh_bits\" && \\\n                            [[ ${kx[nr_ciphers]} == \"Kx=ECDH\" || ${kx[nr_ciphers]} == \"Kx=DH\" || ${kx[nr_ciphers]} == \"Kx=EDH\" ]]; then\n                              ossl_supported[nr_ciphers]=false\n                         fi\n                         nr_ciphers+=1\n                    fi\n               done\n          else\n               while read hexc n ciph[nr_ciphers] sslvers[nr_ciphers] kx[nr_ciphers] auth enc[nr_ciphers] mac export2[nr_ciphers]; do\n                    hexc=\"$(normalize_ciphercode $hexc)\"\n                    # is argument a number?\n                    if [[ $arg =~ $re ]]; then\n                         neat_list \"$hexc\" \"${ciph[nr_ciphers]}\" \"${kx[nr_ciphers]}\" \"${enc[nr_ciphers]}\" \"${export2[nr_ciphers]}\" | grep -qai \"$arg\"\n                    else\n                         neat_list \"$hexc\" \"${ciph[nr_ciphers]}\" \"${kx[nr_ciphers]}\" \"${enc[nr_ciphers]}\" \"${export2[nr_ciphers]}\" | grep -qwai \"$arg\"\n                    fi\n                    if [[ $? -eq 0 ]]; then    # string matches, so we can ssl to it:\n                         ciphers_found[nr_ciphers]=false\n                         normalized_hexcode[nr_ciphers]=\"$hexc\"\n                         sigalg[nr_ciphers]=\"\"\n                         ossl_supported[nr_ciphers]=true\n                         nr_ciphers+=1\n                    fi\n                    done < <(actually_supported_osslciphers 'ALL:COMPLEMENTOFALL:@STRENGTH' 'ALL' \"-V\")\n          fi\n\n          # Test the SSLv2 ciphers, if any.\n          if \"$using_sockets\"; then\n               ciphers_to_test=\"\"\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    if [[ \"${sslvers[i]}\" == SSLv2 ]]; then\n                         ciphers_to_test+=\", ${hexcode[i]}\"\n                    fi\n               done\n               if [[ -n \"$ciphers_to_test\" ]]; then\n                    sslv2_sockets \"${ciphers_to_test:2}\" \"true\"\n                    if [[ $? -eq 3 ]] && [[ \"$V2_HELLO_CIPHERSPEC_LENGTH\" -ne 0 ]]; then\n                         supported_sslv2_ciphers=\"$(grep \"Supported cipher: \" \"$TEMPDIR/$NODEIP.parse_sslv2_serverhello.txt\")\"\n                         \"$SHOW_SIGALGO\" && s=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n                         for (( i=0 ; i<nr_ciphers; i++ )); do\n                              if [[ \"${sslvers[i]}\" == SSLv2 ]] && [[ \"$supported_sslv2_ciphers\" =~ ${normalized_hexcode[i]} ]]; then\n                                   ciphers_found[i]=true\n                                   \"$SHOW_SIGALGO\" && sigalg[i]=\"$s\"\n                              fi\n                         done\n                    fi\n               fi\n          else\n               ciphers_to_test=\"\"\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    if [[ \"${sslvers[i]}\" == SSLv2 ]]; then\n                         ciphers_to_test+=\":${ciph[i]}\"\n                    fi\n               done\n               if [[ -n \"$ciphers_to_test\" ]]; then\n                    $OPENSSL s_client -cipher \"${ciphers_to_test:1}\" $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY -ssl2 >$TMPFILE 2>$ERRFILE </dev/null\n                    sclient_connect_successful $? \"$TMPFILE\"\n                    if [[ $? -eq 0 ]]; then\n                         supported_sslv2_ciphers=\"$(grep -A 4 \"Ciphers common between both SSL endpoints:\" $TMPFILE)\"\n                         \"$SHOW_SIGALGO\" && s=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n                         for (( i=0 ; i<nr_ciphers; i++ )); do\n                              if [[ \"${sslvers[i]}\" == SSLv2 ]] && [[ \"$supported_sslv2_ciphers\" =~ ${ciph[i]} ]]; then\n                                   ciphers_found[i]=true\n                                   \"$SHOW_SIGALGO\" && sigalg[i]=\"$s\"\n                              fi\n                         done\n                    fi\n               fi\n          fi\n\n          for (( i=0; i < nr_ciphers; i++ )); do\n               if \"${ossl_supported[i]}\" && [[ \"${sslvers[i]}\" != \"SSLv2\" ]]; then\n                    ciphers_found2[nr_ossl_ciphers]=false\n                    ciph2[nr_ossl_ciphers]=\"${ciph[i]}\"\n                    index[nr_ossl_ciphers]=$i\n                    nr_ossl_ciphers+=1\n               fi\n          done\n          if [[ $nr_ossl_ciphers -eq 0 ]]; then\n               num_bundles=0\n          else\n               # Some servers can't handle a handshake with >= 128 ciphers. So,\n               # test cipher suites in bundles of 128 or less.\n               num_bundles=$nr_ossl_ciphers/128\n               [[ $((nr_ossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n               bundle_size=$nr_ossl_ciphers/$num_bundles\n               [[ $((nr_ossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n          fi\n\n          protos_to_try=\"-no_ssl2\"\n          \"$HAS_TLS13\" && \"$HAS_TLS12\" && protos_to_try+=\" -tls1_2\"\n          \"$HAS_TLS11\" && protos_to_try+=\" -tls1_1\"\n          \"$HAS_TLS1\" && protos_to_try+=\" -tls1\"\n          \"$HAS_SSL3\" && protos_to_try+=\" -ssl3\"\n\n          for proto in $protos_to_try; do\n               if [[ \"$proto\" == -tls1_1 ]]; then\n                    num_bundles=1\n                    bundle_size=$nr_ossl_ciphers\n               fi\n               for (( bundle=0; bundle < num_bundles; bundle++ )); do\n                    end_of_bundle=$(( (bundle+1)*bundle_size ))\n                    [[ $end_of_bundle -gt $nr_ossl_ciphers ]] && end_of_bundle=$nr_ossl_ciphers\n                    while true; do\n                         ciphers_to_test=\"\"\n                         tls13_ciphers_to_test=\"\"\n                         for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                              if ! \"${ciphers_found2[i]}\"; then\n                                   if [[ \"${ciph2[i]}\" == TLS13* ]] || [[ \"${ciph2[i]}\" == TLS_* ]] || [[ \"${ciph2[i]}\" == AEAD-* ]]; then\n                                        tls13_ciphers_to_test+=\":${ciph2[i]}\"\n                                   else\n                                        ciphers_to_test+=\":${ciph2[i]}\"\n                                   fi\n                              fi\n                         done\n                         [[ -z \"$ciphers_to_test\" ]] && [[ -z \"$tls13_ciphers_to_test\" ]] && break\n                         $OPENSSL s_client $(s_client_options \"$proto -cipher \"\\'${ciphers_to_test:1}\\'\" -ciphersuites \"\\'${tls13_ciphers_to_test:1}\\'\" $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI\") >$TMPFILE 2>$ERRFILE </dev/null\n                         sclient_connect_successful $? \"$TMPFILE\" || break\n                         cipher=$(get_cipher $TMPFILE)\n                         [[ -z \"$cipher\" ]] && break\n                         for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                              [[ \"$cipher\" == \"${ciph2[i]}\" ]] && ciphers_found2[i]=true && break\n                         done\n                         [[ $i -eq $end_of_bundle ]] && break\n                         i=${index[i]}\n                         ciphers_found[i]=true\n                         if [[ \"$cipher\" == TLS13* ]] || [[ \"$cipher\" == TLS_* ]] || [[ \"$cipher\" == AEAD-* ]]; then\n                              kx[i]=\"$(read_dhtype_from_file $TMPFILE)\"\n                         fi\n                         if [[ ${kx[i]} == \"Kx=ECDH\" ]] || [[ ${kx[i]} == \"Kx=DH\" ]] || [[ ${kx[i]} == \"Kx=EDH\" ]]; then\n                              dhlen=$(read_dhbits_from_file \"$TMPFILE\" quiet)\n                              kx[i]=\"${kx[i]} $dhlen\"\n                         fi\n                         \"$SHOW_SIGALGO\" && grep -qe '-----BEGIN CERTIFICATE-----' $TMPFILE && \\\n                              sigalg[i]=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n                    done\n               done\n          done\n\n          if \"$using_sockets\"; then\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    if ! \"${ciphers_found[i]}\" && [[ \"${sslvers[i]}\" != \"SSLv2\" ]]; then\n                         ciphers_found2[nr_nonossl_ciphers]=false\n                         hexcode2[nr_nonossl_ciphers]=\"${hexcode[i]}\"\n                         rfc_ciph2[nr_nonossl_ciphers]=\"${rfc_ciph[i]}\"\n                         index[nr_nonossl_ciphers]=$i\n                         nr_nonossl_ciphers+=1\n                    fi\n               done\n          fi\n\n          if [[ $nr_nonossl_ciphers -eq 0 ]]; then\n               num_bundles=0\n          else\n               # Some servers can't handle a handshake with >= 128 ciphers. So,\n               # test cipher suites in bundles of 128 or less.\n               num_bundles=$nr_nonossl_ciphers/128\n               [[ $((nr_nonossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n               bundle_size=$nr_nonossl_ciphers/$num_bundles\n               [[ $((nr_nonossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n          fi\n\n          for proto in 04 03 02 01 00; do\n               for (( bundle=0; bundle < num_bundles; bundle++ )); do\n                    end_of_bundle=$(( (bundle+1)*bundle_size ))\n                    [[ $end_of_bundle -gt $nr_nonossl_ciphers ]] && end_of_bundle=$nr_nonossl_ciphers\n                    while true; do\n                         ciphers_to_test=\"\"\n                         for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                              ! \"${ciphers_found2[i]}\" && ciphers_to_test+=\", ${hexcode2[i]}\"\n                         done\n                         [[ -z \"$ciphers_to_test\" ]] && break\n                         [[ \"$proto\" == 04 ]] && [[ ! \"$ciphers_to_test\" =~ ,\\ 13,[0-9a-f][0-9a-f] ]] && [[ ! \"$ciphers_to_test\" =~ ,\\ [cC]0,[bB][45] ]] && break\n                         ciphers_to_test=\"$(strip_inconsistent_ciphers \"$proto\" \"$ciphers_to_test\")\"\n                         [[ -z \"$ciphers_to_test\" ]] && break\n                         if \"$SHOW_SIGALGO\"; then\n                              tls_sockets \"$proto\" \"${ciphers_to_test:2}, 00,ff\" \"all\"\n                         else\n                              tls_sockets \"$proto\" \"${ciphers_to_test:2}, 00,ff\" \"ephemeralkey\"\n                         fi\n                         sclient_success=$?\n                         [[ $sclient_success -ne 0 ]] && [[ $sclient_success -ne 2 ]] && break\n                         cipher=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\n                         for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                              [[ \"$cipher\" == \"${rfc_ciph2[i]}\" ]] && ciphers_found2[i]=true && break\n                         done\n                         [[ $i -eq $end_of_bundle ]] && break\n                         i=${index[i]}\n                         ciphers_found[i]=true\n                         [[ \"${kx[i]}\" == \"Kx=any\" ]] && kx[i]=\"$(read_dhtype_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\"\n                         if [[ ${kx[i]} == \"Kx=ECDH\" ]] || [[ ${kx[i]} == \"Kx=DH\" ]] || [[ ${kx[i]} == \"Kx=EDH\" ]]; then\n                              dhlen=$(read_dhbits_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" quiet)\n                              kx[i]=\"${kx[i]} $dhlen\"\n                         fi\n                         \"$SHOW_SIGALGO\" && [[ -r \"$HOSTCERT\" ]] && \\\n                              sigalg[i]=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n                    done\n               done\n          done\n\n          for (( i=0; i < nr_ciphers; i++ )); do\n               \"${ciphers_found[i]}\" || \"$SHOW_EACH_C\" || continue\n               neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\" \"${ciphers_found[i]}\"\n               available=\"\"\n               if \"$SHOW_EACH_C\"; then\n                    if \"${ciphers_found[i]}\"; then\n                         available=\"available\"\n                         pr_cyan \"available\"\n                    else\n                         available=\"not a/v\"\n                         pr_deemphasize \"not a/v\"\n                    fi\n               fi\n               outln \"${sigalg[i]}\"\n               fileout \"cipher_${normalized_hexcode[i]}\" \"INFO\" \"$(neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\") $available\"\n          done\n          \"$using_sockets\" && HAS_DH_BITS=\"$has_dh_bits\"\n          tmpfile_handle ${FUNCNAME[0]}.txt\n     done\n     outln\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0       # this is a single test for a cipher\n}\n\n\n\n# Test for all ciphers locally configured (w/o distinguishing whether they are good or bad)\n#\nrun_allciphers() {\n     local -i nr_ciphers_tested=0 nr_ciphers=0 nr_ossl_ciphers=0 nr_nonossl_ciphers=0 sclient_success=0\n     local n auth mac hexc sslv2_ciphers=\"\" s\n     local -a normalized_hexcode hexcode ciph sslvers kx enc export2 sigalg ossl_supported\n     local -i i end_of_bundle bundle bundle_size num_bundles\n     local -a ciphers_found ciphers_found2 hexcode2 ciph2 rfc_ciph2\n     local -i -a index\n     local proto protos_to_try\n     local dhlen available ciphers_to_test tls13_ciphers_to_test supported_sslv2_ciphers\n     local has_dh_bits=\"$HAS_DH_BITS\"\n     local using_sockets=true\n\n     \"$SSL_NATIVE\" && using_sockets=false\n     \"$FAST\" && using_sockets=false\n     [[ $TLS_NR_CIPHERS == 0 ]] && using_sockets=false\n\n     # get a list of all the cipher suites to test\n     if \"$using_sockets\" || [[ $OSSL_VER_MAJOR -lt 1 ]]; then\n          for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n               hexc=\"$(tolower \"${TLS_CIPHER_HEXCODE[i]}\")\"\n               ciph[i]=\"${TLS_CIPHER_OSSL_NAME[i]}\"\n               sslvers[i]=\"${TLS_CIPHER_SSLVERS[i]}\"\n               kx[i]=\"${TLS_CIPHER_KX[i]}\"\n               enc[i]=\"${TLS_CIPHER_ENC[i]}\"\n               export2[i]=\"${TLS_CIPHER_EXPORT[i]}\"\n               ciphers_found[i]=false\n               sigalg[i]=\"\"\n               ossl_supported[i]=${TLS_CIPHER_OSSL_SUPPORTED[i]}\n               if \"$using_sockets\" && ! \"$HAS_DH_BITS\" && [[ ${kx[i]} == Kx=ECDH || ${kx[i]} == Kx=DH || ${kx[i]} == Kx=EDH ]]; then\n                    ossl_supported[i]=false\n               fi\n               if [[ ${#hexc} -eq 9 ]]; then\n                    hexcode[i]=\"${hexc:2:2},${hexc:7:2}\"\n                    if [[ \"${hexc:2:2}\" == 00 ]]; then\n                         normalized_hexcode[i]=\"x${hexc:7:2}\"\n                    else\n                         normalized_hexcode[i]=\"x${hexc:2:2}${hexc:7:2}\"\n                    fi\n               else\n                    hexcode[i]=\"${hexc:2:2},${hexc:7:2},${hexc:12:2}\"\n                    normalized_hexcode[i]=\"x${hexc:2:2}${hexc:7:2}${hexc:12:2}\"\n                    sslv2_ciphers=\"$sslv2_ciphers, ${hexcode[i]}\"\n               fi\n               if \"$using_sockets\" || \"${TLS_CIPHER_OSSL_SUPPORTED[i]}\"; then\n                    nr_ciphers_tested+=1\n               fi\n          done\n          nr_ciphers=$TLS_NR_CIPHERS\n     else\n          while read -r hexc n ciph[nr_ciphers] sslvers[nr_ciphers] kx[nr_ciphers] auth enc[nr_ciphers] mac export2[nr_ciphers]; do\n               ciphers_found[nr_ciphers]=false\n               if [[ ${#hexc} -eq 9 ]]; then\n                    if [[ \"${hexc:2:2}\" == 00 ]]; then\n                         normalized_hexcode[nr_ciphers]=\"$(tolower \"x${hexc:7:2}\")\"\n                    else\n                         normalized_hexcode[nr_ciphers]=\"$(tolower \"x${hexc:2:2}${hexc:7:2}\")\"\n                    fi\n               else\n                    normalized_hexcode[nr_ciphers]=\"$(tolower \"x${hexc:2:2}${hexc:7:2}${hexc:12:2}\")\"\n               fi\n               sigalg[nr_ciphers]=\"\"\n               ossl_supported[nr_ciphers]=true\n               nr_ciphers=$nr_ciphers+1\n          done < <(actually_supported_osslciphers 'ALL:COMPLEMENTOFALL:@STRENGTH' 'ALL' \"-V\")\n          nr_ciphers_tested=$nr_ciphers\n     fi\n\n     if \"$using_sockets\"; then\n          sslv2_sockets \"${sslv2_ciphers:2}\" \"true\"\n          if [[ $? -eq 3 ]] && [[ \"$V2_HELLO_CIPHERSPEC_LENGTH\" -ne 0 ]]; then\n               supported_sslv2_ciphers=\"$(grep \"Supported cipher: \" \"$TEMPDIR/$NODEIP.parse_sslv2_serverhello.txt\")\"\n               \"$SHOW_SIGALGO\" && s=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n               for (( i=0 ; i<nr_ciphers; i++ )); do\n                    if [[ \"${sslvers[i]}\" == SSLv2 ]] && [[ \"$supported_sslv2_ciphers\" =~ ${normalized_hexcode[i]} ]]; then\n                         ciphers_found[i]=true\n                         \"$SHOW_SIGALGO\" && sigalg[i]=\"$s\"\n                    fi\n               done\n          fi\n     elif \"$HAS_SSL2\"; then\n          $OPENSSL s_client $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY -ssl2 >$TMPFILE 2>$ERRFILE </dev/null\n          sclient_connect_successful $? \"$TMPFILE\"\n          if [[ $? -eq 0 ]]; then\n               supported_sslv2_ciphers=\"$(grep -A 4 \"Ciphers common between both SSL endpoints:\" $TMPFILE)\"\n               \"$SHOW_SIGALGO\" && s=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n               for (( i=0 ; i<nr_ciphers; i++ )); do\n                    if [[ \"${sslvers[i]}\" == SSLv2 ]] && [[ \"$supported_sslv2_ciphers\" =~ ${ciph[i]} ]]; then\n                         ciphers_found[i]=true\n                         \"$SHOW_SIGALGO\" && sigalg[i]=\"$s\"\n                    fi\n               done\n          fi\n     fi\n\n     outln\n     if \"$using_sockets\"; then\n          pr_headlineln \" Testing $nr_ciphers_tested ciphers via OpenSSL plus sockets against the server, ordered by encryption strength \"\n     else\n          pr_headlineln \" Testing all $nr_ciphers_tested locally available ciphers against the server, ordered by encryption strength \"\n          [[ $TLS_NR_CIPHERS == 0 ]] && ! \"$SSL_NATIVE\" && ! \"$FAST\" && pr_warning \" Cipher mapping not available, doing a fallback to openssl\"\n          outln\n          if ! \"$HAS_DH_BITS\"; then\n               [[ $TLS_NR_CIPHERS == 0 ]] && ! \"$SSL_NATIVE\" && ! \"$FAST\" && out \".\"\n               prln_warning \" Your $OPENSSL cannot show DH/ECDH bits\"\n          fi\n     fi\n     outln\n     neat_header\n\n     for (( i=0; i < nr_ciphers; i++ )); do\n          if \"${ossl_supported[i]}\"; then\n               [[ \"${sslvers[i]}\" == SSLv2 ]] && continue\n               ciphers_found2[nr_ossl_ciphers]=false\n               ciph2[nr_ossl_ciphers]=\"${ciph[i]}\"\n               index[nr_ossl_ciphers]=$i\n               nr_ossl_ciphers+=1\n          fi\n     done\n\n     if [[ $nr_ossl_ciphers -eq 0 ]]; then\n          num_bundles=0\n     else\n          # Some servers can't handle a handshake with >= 128 ciphers. So,\n          # test cipher suites in bundles of 128 or less.\n          num_bundles=$nr_ossl_ciphers/128\n          [[ $((nr_ossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n          bundle_size=$nr_ossl_ciphers/$num_bundles\n          [[ $((nr_ossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n     fi\n\n     protos_to_try=\"-no_ssl2\"\n     \"$HAS_TLS13\" && \"$HAS_TLS12\" && protos_to_try+=\" -tls1_2\"\n     \"$HAS_TLS11\" && protos_to_try+=\" -tls1_1\"\n     \"$HAS_TLS1\" && protos_to_try+=\" -tls1\"\n     \"$HAS_SSL3\" && protos_to_try+=\" -ssl3\"\n\n     for proto in $protos_to_try; do\n          if [[ \"$proto\" == -tls1_1 ]]; then\n               num_bundles=1\n               bundle_size=$nr_ossl_ciphers\n          fi\n\n          [[ \"$proto\" != \"-no_ssl2\" ]] && [[ $(has_server_protocol \"${proto:1}\") -eq 1 ]] && continue\n          for (( bundle=0; bundle < num_bundles; bundle++ )); do\n               end_of_bundle=$(( (bundle+1)*bundle_size ))\n               [[ $end_of_bundle -gt $nr_ossl_ciphers ]] && end_of_bundle=$nr_ossl_ciphers\n               while true; do\n                    ciphers_to_test=\"\"\n                    tls13_ciphers_to_test=\"\"\n                    for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                         if ! \"${ciphers_found2[i]}\"; then\n                              if [[ \"${ciph2[i]}\" == TLS13* ]] || [[ \"${ciph2[i]}\" == TLS_* ]] || [[ \"${ciph2[i]}\" == AEAD-* ]]; then\n                                   tls13_ciphers_to_test+=\":${ciph2[i]}\"\n                              else\n                                   ciphers_to_test+=\":${ciph2[i]}\"\n                              fi\n                         fi\n                    done\n                    [[ -z \"$ciphers_to_test\" ]] && [[ -z \"$tls13_ciphers_to_test\" ]] && break\n                    $OPENSSL s_client $(s_client_options \"$proto -cipher \"\\'${ciphers_to_test:1}\\'\" -ciphersuites \"\\'${tls13_ciphers_to_test:1}\\'\" $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI\") >$TMPFILE 2>$ERRFILE </dev/null\n                    sclient_connect_successful $? \"$TMPFILE\" || break\n                    cipher=$(get_cipher $TMPFILE)\n                    [[ -z \"$cipher\" ]] && break\n                    for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                         [[ \"$cipher\" == \"${ciph2[i]}\" ]] && ciphers_found2[i]=true && break\n                    done\n                    [[ $i -eq $end_of_bundle ]] && break\n                    i=${index[i]}\n                    ciphers_found[i]=true\n                    if [[ \"$cipher\" == TLS13* ]] || [[ \"$cipher\" == TLS_* ]] || [[ \"$cipher\" == AEAD-* ]]; then\n                         kx[i]=\"$(read_dhtype_from_file $TMPFILE)\"\n                    fi\n                    if [[ ${kx[i]} == Kx=ECDH ]] || [[ ${kx[i]} == Kx=DH ]] || [[ ${kx[i]} == Kx=EDH ]]; then\n                         dhlen=$(read_dhbits_from_file \"$TMPFILE\" quiet)\n                         kx[i]=\"${kx[i]} $dhlen\"\n                    fi\n                    \"$SHOW_SIGALGO\" && grep -qe '-----BEGIN CERTIFICATE-----' $TMPFILE && \\\n                         sigalg[i]=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n               done\n          done\n     done\n\n     if \"$using_sockets\"; then\n          for (( i=0; i < nr_ciphers; i++ )); do\n               if ! \"${ciphers_found[i]}\"; then\n                    [[ \"${sslvers[i]}\" == SSLv2 ]] && continue\n                    ciphers_found2[nr_nonossl_ciphers]=false\n                    hexcode2[nr_nonossl_ciphers]=\"${hexcode[i]}\"\n                    rfc_ciph2[nr_nonossl_ciphers]=\"${TLS_CIPHER_RFC_NAME[i]}\"\n                    index[nr_nonossl_ciphers]=$i\n                    nr_nonossl_ciphers+=1\n               fi\n          done\n     fi\n\n     if [[ $nr_nonossl_ciphers -eq 0 ]]; then\n          num_bundles=0\n     else\n          # Some servers can't handle a handshake with >= 128 ciphers. So,\n          # test cipher suites in bundles of 128 or less.\n          num_bundles=$nr_nonossl_ciphers/128\n          [[ $((nr_nonossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n          bundle_size=$nr_nonossl_ciphers/$num_bundles\n          [[ $((nr_nonossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n     fi\n\n     for proto in 04 03 02 01 00; do\n          for (( bundle=0; bundle < num_bundles; bundle++ )); do\n               end_of_bundle=$(( (bundle+1)*bundle_size ))\n               [[ $end_of_bundle -gt $nr_nonossl_ciphers ]] && end_of_bundle=$nr_nonossl_ciphers\n               while true; do\n                    ciphers_to_test=\"\"\n                    for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                         ! \"${ciphers_found2[i]}\" && ciphers_to_test+=\", ${hexcode2[i]}\"\n                    done\n                    [[ -z \"$ciphers_to_test\" ]] && break\n                    [[ \"$proto\" == 04 ]] && [[ ! \"$ciphers_to_test\" =~ ,\\ 13,[0-9a-f][0-9a-f] ]] && [[ ! \"$ciphers_to_test\" =~ ,\\ [cC]0,[bB][45] ]] && break\n                    ciphers_to_test=\"$(strip_inconsistent_ciphers \"$proto\" \"$ciphers_to_test\")\"\n                    [[ -z \"$ciphers_to_test\" ]] && break\n                    if \"$SHOW_SIGALGO\"; then\n                         tls_sockets \"$proto\" \"${ciphers_to_test:2}, 00,ff\" \"all\"\n                    else\n                         tls_sockets \"$proto\" \"${ciphers_to_test:2}, 00,ff\" \"ephemeralkey\"\n                    fi\n                    sclient_success=$?\n                    [[ $sclient_success -ne 0 ]] && [[ $sclient_success -ne 2 ]] && break\n                    cipher=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\n                    for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                         [[ \"$cipher\" == \"${rfc_ciph2[i]}\" ]] && ciphers_found2[i]=true && break\n                    done\n                    [[ $i -eq $end_of_bundle ]] && break\n                    i=${index[i]}\n                    ciphers_found[i]=true\n                    [[ \"${kx[i]}\" == \"Kx=any\" ]] && kx[i]=\"$(read_dhtype_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\"\n                    if [[ ${kx[i]} == \"Kx=ECDH\" ]] || [[ ${kx[i]} == \"Kx=DH\" ]] || [[ ${kx[i]} == \"Kx=EDH\" ]]; then\n                         dhlen=$(read_dhbits_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" quiet)\n                         kx[i]=\"${kx[i]} $dhlen\"\n                    fi\n                    \"$SHOW_SIGALGO\" && [[ -r \"$HOSTCERT\" ]] && sigalg[i]=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n               done\n          done\n     done\n\n     for (( i=0 ; i<nr_ciphers; i++ )); do\n          if \"${ciphers_found[i]}\" || { \"$SHOW_EACH_C\" && { \"$using_sockets\" || \"${ossl_supported[i]}\"; }; }; then\n               neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\" \"${ciphers_found[i]}\"\n               available=\"\"\n               if \"$SHOW_EACH_C\"; then\n                    if ${ciphers_found[i]}; then\n                         available=\"available\"\n                         pr_cyan \"$available\"\n                    else\n                         available=\"not a/v\"\n                         pr_deemphasize \"$available\"\n                    fi\n               fi\n               outln \"${sigalg[i]}\"\n               fileout \"cipher_${normalized_hexcode[i]}\" \"INFO\" \"$(neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\") $available\"\n          fi\n     done\n     \"$using_sockets\" && HAS_DH_BITS=\"$has_dh_bits\"\n\n     outln\n     [[ $sclient_success -ge 6 ]] && return 1\n     return 0\n}\n\n# test for all ciphers per protocol locally configured (w/o distinguishing whether they are good or bad)\n# for the specified protocol, test for all ciphers locally configured (w/o distinguishing whether they\n# are good or bad) and list them in order to encryption strength.\nciphers_by_strength() {\n     local proto=\"$1\" proto_hex=\"$2\" proto_text=\"$3\"\n     local using_sockets=\"$4\" wide=\"$5\" serverpref_known=\"$6\"\n     local ossl_ciphers_proto\n     local -i nr_ciphers nr_ossl_ciphers nr_nonossl_ciphers success\n     local n sslvers auth mac hexc sslv2_ciphers=\"\" cipher\n     local -a hexcode normalized_hexcode ciph rfc_ciph kx enc export2\n     local -a hexcode2 ciph2 rfc_ciph2\n     local -i i bundle end_of_bundle bundle_size num_bundles\n     local -a ciphers_found ciphers_found2 sigalg ossl_supported index\n     local dhlen supported_sslv2_ciphers ciphers_to_test tls13_ciphers_to_test addcmd temp\n     local available proto_supported=false\n     local id\n     local has_dh_bits=\"$HAS_DH_BITS\"\n     local -i quality worst_cipher=8 best_cipher=0 difference_rating=5\n\n     # for local problem if it happens\n     \"$wide\" || out \"  \"\n     if ! \"$using_sockets\" && ! sclient_supported \"$proto\"; then\n          \"$wide\" && outln\n          pr_local_problem \"Your $OPENSSL does not support $proto\"\n          \"$wide\" && outln\n          return 0\n     fi\n\n     if [[ $(has_server_protocol \"${proto:1}\") -eq 1 ]]; then\n          \"$wide\" && outln \"\\n - \"\n          return 0\n     fi\n\n     # get a list of all the cipher suites to test\n     nr_ciphers=0\n     if \"$using_sockets\" || [[ $OSSL_VER_MAJOR -lt 1 ]]; then\n          for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n               hexc=\"${TLS_CIPHER_HEXCODE[i]}\"\n               ciph[nr_ciphers]=\"${TLS_CIPHER_OSSL_NAME[i]}\"\n               rfc_ciph[nr_ciphers]=\"${TLS_CIPHER_RFC_NAME[i]}\"\n               kx[nr_ciphers]=\"${TLS_CIPHER_KX[i]}\"\n               enc[nr_ciphers]=\"${TLS_CIPHER_ENC[i]}\"\n               export2[nr_ciphers]=\"${TLS_CIPHER_EXPORT[i]}\"\n               ciphers_found[nr_ciphers]=false\n               sigalg[nr_ciphers]=\"\"\n               ossl_supported[nr_ciphers]=${TLS_CIPHER_OSSL_SUPPORTED[i]}\n               if \"$using_sockets\" && \"$wide\" && ! \"$has_dh_bits\" && \\\n                    [[ ${kx[nr_ciphers]} == \"Kx=ECDH\" || ${kx[nr_ciphers]} == \"Kx=DH\" || ${kx[nr_ciphers]} == \"Kx=EDH\" ]]; then\n                    ossl_supported[nr_ciphers]=false\n               fi\n               if [[ ${#hexc} -eq 9 ]]; then\n                    hexcode[nr_ciphers]=\"${hexc:2:2},${hexc:7:2}\"\n                    if [[ \"${hexc:2:2}\" == 00 ]]; then\n                         normalized_hexcode[nr_ciphers]=\"x${hexc:7:2}\"\n                    else\n                         normalized_hexcode[nr_ciphers]=\"x${hexc:2:2}${hexc:7:2}\"\n                    fi\n               else\n                    hexc=\"$(tolower \"$hexc\")\"\n                    hexcode[nr_ciphers]=\"${hexc:2:2},${hexc:7:2},${hexc:12:2}\"\n                    normalized_hexcode[nr_ciphers]=\"x${hexc:2:2}${hexc:7:2}${hexc:12:2}\"\n               fi\n               if { \"$using_sockets\" || \"${TLS_CIPHER_OSSL_SUPPORTED[i]}\"; }; then\n                    if [[ ${#hexc} -eq 9 ]] && [[ \"$proto\" != -ssl2 ]]; then\n                         if [[ \"$proto\" == -tls1_3 ]]; then\n                              [[ \"${TLS_CIPHER_SSLVERS[i]}\" == TLSv1.3 ]] && nr_ciphers+=1\n                         elif [[ \"$proto\" == -tls1_2 ]]; then\n                              [[ \"${TLS_CIPHER_SSLVERS[i]}\" != TLSv1.3 ]] && nr_ciphers+=1\n                         elif [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA256 ]] && [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA384 ]] && \\\n                              [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM ]] && [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM_8 ]]; then\n                              nr_ciphers+=1\n                         fi\n                    elif [[ ${#hexc} -eq 14 ]] && [[ \"$proto\" == -ssl2 ]]; then\n                         sslv2_ciphers+=\", ${hexcode[nr_ciphers]}\"\n                         nr_ciphers+=1\n                    fi\n               fi\n          done\n     else # no sockets, openssl!\n          # The OpenSSL ciphers function, prior to version 1.1.0, could only understand -ssl2, -ssl3, and -tls1.\n          if [[ \"$OSSL_NAME\" =~ LibreSSL ]]; then\n               ossl_ciphers_proto=\"\"\n          elif [[ $proto == -ssl2 ]] || [[ $proto == -ssl3 ]] || \\\n               [[ $OSSL_VER_MAJOR.$OSSL_VER_MINOR == 1.1.0* ]] || [[ $OSSL_VER_MAJOR.$OSSL_VER_MINOR == 1.1.1* ]] || \\\n               [[ $OSSL_VER_MAJOR == 3 ]]; then\n               ossl_ciphers_proto=\"$proto\"\n          else\n               ossl_ciphers_proto=\"-tls1\"\n          fi\n          while read hexc n ciph[nr_ciphers] sslvers kx[nr_ciphers] auth enc[nr_ciphers] mac export2[nr_ciphers]; do\n               if [[ \"$proto\" == -tls1_3 ]]; then\n                    [[ \"${ciph[nr_ciphers]}\" == TLS13* ]] || [[ \"${ciph[nr_ciphers]}\" == TLS_* ]] || [[ \"${ciph[nr_ciphers]}\" == AEAD-* ]] || continue\n               elif [[ \"$proto\" == -tls1_2 ]]; then\n                    if [[ \"${ciph[nr_ciphers]}\" == TLS13* ]] || [[ \"${ciph[nr_ciphers]}\" == TLS_* ]] || [[ \"${ciph[nr_ciphers]}\" == AEAD-* ]]; then\n                         continue\n                    fi\n               elif [[ \"${ciph[nr_ciphers]}\" == *-SHA256 ]] || [[ \"${ciph[nr_ciphers]}\" == *-SHA384 ]] || \\\n                    [[ \"${ciph[nr_ciphers]}\" == *-CCM ]] || [[ \"${ciph[nr_ciphers]}\" == *-CCM8 ]] || \\\n                    [[ \"${ciph[nr_ciphers]}\" =~ CHACHA20-POLY1305 ]]; then\n                    continue\n               fi\n               ciphers_found[nr_ciphers]=false\n               normalized_hexcode[nr_ciphers]=\"$(normalize_ciphercode \"$hexc\")\"\n               sigalg[nr_ciphers]=\"\"\n               ossl_supported[nr_ciphers]=true\n               nr_ciphers+=1\n          done < <(actually_supported_osslciphers 'ALL:COMPLEMENTOFALL:@STRENGTH' 'ALL' \"$ossl_ciphers_proto -V\")\n     fi\n\n     if [[ $proto == -ssl2 ]]; then\n          if \"$using_sockets\"; then\n               sslv2_sockets \"${sslv2_ciphers:2}\" \"true\"\n               if [[ $? -eq 3 ]] ; then\n                    add_proto_offered ssl2 yes\n                    if [[ \"$V2_HELLO_CIPHERSPEC_LENGTH\" -ne 0 ]]; then\n                         supported_sslv2_ciphers=\"$(grep \"Supported cipher: \" \"$TEMPDIR/$NODEIP.parse_sslv2_serverhello.txt\")\"\n                         \"$wide\" && \"$SHOW_SIGALGO\" && s=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n                         for (( i=0 ; i<nr_ciphers; i++ )); do\n                              if [[ \"$supported_sslv2_ciphers\" =~ ${normalized_hexcode[i]} ]]; then\n                                   ciphers_found[i]=true\n                                   proto_supported=true\n                                   \"$wide\" && \"$SHOW_SIGALGO\" && sigalg[i]=\"$s\"\n                              fi\n                         done\n                    else\n                         \"$wide\" && outln\n                         outln \" protocol supported with no cipher \"\n                    fi\n               else\n                    add_proto_offered ssl2 no\n                    \"$wide\" && outln \"\\n - \"\n               fi\n          else\n               $OPENSSL s_client $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY -ssl2 >$TMPFILE 2>$ERRFILE </dev/null\n               sclient_connect_successful $? \"$TMPFILE\"\n               if [[ $? -eq 0 ]]; then\n                    add_proto_offered ssl2 yes\n                    supported_sslv2_ciphers=\"$(grep -A 4 \"Ciphers common between both SSL endpoints:\" $TMPFILE)\"\n                    \"$wide\" && \"$SHOW_SIGALGO\" && s=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n                    for (( i=0 ; i<nr_ciphers; i++ )); do\n                         if [[ \"$supported_sslv2_ciphers\" =~ ${ciph[i]} ]]; then\n                              ciphers_found[i]=true\n                              proto_supported=true\n                              \"$wide\" && \"$SHOW_SIGALGO\" && sigalg[i]=\"$s\"\n                         fi\n                    done\n               else\n                    add_proto_offered ssl2 no\n                    \"$wide\" && outln \"\\n - \"\n               fi\n          fi\n     else # no SSLv2\n          nr_ossl_ciphers=0\n          if sclient_supported \"$proto\"; then\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    if \"${ossl_supported[i]}\"; then\n                         ciphers_found2[nr_ossl_ciphers]=false\n                         ciph2[nr_ossl_ciphers]=\"${ciph[i]}\"\n                         index[nr_ossl_ciphers]=$i\n                         nr_ossl_ciphers+=1\n                    fi\n               done\n          fi\n          if [[ $nr_ossl_ciphers -eq 0 ]]; then\n               num_bundles=0\n          else\n               # Some servers can't handle a handshake with >= 128 ciphers. So,\n               # test cipher suites in bundles of 128 or less.\n               num_bundles=$nr_ossl_ciphers/128\n               [[ $((nr_ossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n               bundle_size=$nr_ossl_ciphers/$num_bundles\n               [[ $((nr_ossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n          fi\n\n          for (( bundle=0; bundle < num_bundles; bundle++ )); do\n               end_of_bundle=$(( (bundle+1)*bundle_size ))\n               [[ $end_of_bundle -gt $nr_ossl_ciphers ]] && end_of_bundle=$nr_ossl_ciphers\n               for (( success=0; success==0 ; 1 )); do\n                    ciphers_to_test=\"\"\n                    tls13_ciphers_to_test=\"\"\n                    for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                         if ! \"${ciphers_found2[i]}\"; then\n                              if [[ \"$proto\" == -tls1_3 ]]; then\n                                   tls13_ciphers_to_test+=\":${ciph2[i]}\"\n                              else\n                                   ciphers_to_test+=\":${ciph2[i]}\"\n                              fi\n                         fi\n                    done\n                    success=1\n                    if [[ -n \"$ciphers_to_test\" ]] || [[ -n \"$tls13_ciphers_to_test\" ]]; then\n                         $OPENSSL s_client $(s_client_options \"-cipher \"\\'${ciphers_to_test:1}\\'\" -ciphersuites \"\\'${tls13_ciphers_to_test:1}\\'\" $proto $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI\") >$TMPFILE 2>$ERRFILE </dev/null\n                         sclient_connect_successful $? \"$TMPFILE\"\n                         if [[ $? -eq 0 ]]; then\n                              cipher=$(get_cipher $TMPFILE)\n                              if [[ -n \"$cipher\" ]]; then\n                                   success=0\n                                   for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                                        [[ \"$cipher\" == \"${ciph2[i]}\" ]] && ciphers_found2[i]=true && break\n                                   done\n                                   i=${index[i]}\n                                   ciphers_found[i]=true\n                                   proto_supported=true\n                                   \"$wide\" && [[ \"$proto\" == -tls1_3 ]] && kx[i]=\"$(read_dhtype_from_file $TMPFILE)\"\n                                   if \"$wide\" && [[ ${kx[i]} == Kx=ECDH || ${kx[i]} == Kx=DH || ${kx[i]} == Kx=EDH ]]; then\n                                        dhlen=$(read_dhbits_from_file \"$TMPFILE\" quiet)\n                                        kx[i]=\"${kx[i]} $dhlen\"\n                                   fi\n                                   \"$wide\" && \"$SHOW_SIGALGO\" && grep -qe '-----BEGIN CERTIFICATE-----' $TMPFILE && \\\n                                        sigalg[i]=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n                              fi\n                         fi\n                    fi\n               done\n          done\n\n          if \"$using_sockets\"; then\n               nr_nonossl_ciphers=0\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    if ! \"${ciphers_found[i]}\"; then\n                         ciphers_found2[nr_nonossl_ciphers]=false\n                         hexcode2[nr_nonossl_ciphers]=\"${hexcode[i]}\"\n                         rfc_ciph2[nr_nonossl_ciphers]=\"${rfc_ciph[i]}\"\n                         index[nr_nonossl_ciphers]=$i\n                         nr_nonossl_ciphers+=1\n                    fi\n               done\n          fi\n\n          if [[ $nr_nonossl_ciphers -eq 0 ]]; then\n               num_bundles=0\n          else\n               # Some servers can't handle a handshake with >= 128 ciphers. So,\n               # test cipher suites in bundles of 128 or less.\n               num_bundles=$nr_nonossl_ciphers/128\n               [[ $((nr_nonossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n               bundle_size=$nr_nonossl_ciphers/$num_bundles\n               [[ $((nr_nonossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n          fi\n\n          for (( bundle=0; bundle < num_bundles; bundle++ )); do\n               end_of_bundle=$(( (bundle+1)*bundle_size ))\n               [[ $end_of_bundle -gt $nr_nonossl_ciphers ]] && end_of_bundle=$nr_nonossl_ciphers\n               for (( success=0; success==0 ; 1 )); do\n                    ciphers_to_test=\"\"\n                    for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                         ! \"${ciphers_found2[i]}\" && ciphers_to_test+=\", ${hexcode2[i]}\"\n                    done\n                    success=1\n                    if [[ -n \"$ciphers_to_test\" ]]; then\n                         if \"$wide\" && \"$SHOW_SIGALGO\"; then\n                              tls_sockets \"$proto_hex\" \"${ciphers_to_test:2}, 00,ff\" \"all\"\n                         else\n                              tls_sockets \"$proto_hex\" \"${ciphers_to_test:2}, 00,ff\" \"ephemeralkey\"\n                         fi\n                         if [[ $? -eq 0 ]]; then\n                              success=0\n                              cipher=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\n                              for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                                   [[ \"$cipher\" == \"${rfc_ciph2[i]}\" ]] && ciphers_found2[i]=true && break\n                              done\n                              i=${index[i]}\n                              ciphers_found[i]=true\n                              proto_supported=true\n                              \"$wide\" && [[ \"$proto\" == -tls1_3 ]] && kx[i]=\"$(read_dhtype_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\"\n                              if \"$wide\" && [[ ${kx[i]} == Kx=ECDH || ${kx[i]} == Kx=DH || ${kx[i]} == Kx=EDH ]]; then\n                                   dhlen=$(read_dhbits_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" quiet)\n                                   kx[i]=\"${kx[i]} $dhlen\"\n                              fi\n                              \"$wide\" && \"$SHOW_SIGALGO\" && [[ -r \"$HOSTCERT\" ]] && \\\n                                   sigalg[i]=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n                         fi\n                    fi\n               done\n          done\n     fi\n\n     if \"$wide\" && [[ \"${FUNCNAME[1]}\" == run_server_preference ]] && \"$proto_supported\"; then\n          if ! \"$serverpref_known\"; then\n               outln \" (listed by strength)\"\n          else\n               # Determine the best and worst quality level findings for the supported ciphers\n               for (( i=0 ; i<nr_ciphers; i++ )); do\n                    if \"${ciphers_found[i]}\"; then\n                         if [[ \"${rfc_ciph[i]}\" != - ]]; then\n                              get_cipher_quality \"${rfc_ciph[i]}\"\n                         else\n                              get_cipher_quality ${ciph[i]}\n                         fi\n                         quality=$?\n                         [[ $quality -lt $worst_cipher ]] && worst_cipher=$quality\n                         [[ $quality -gt $best_cipher ]] && best_cipher=$quality\n                    fi\n               done\n               # Assign a rating (severity level) based on the difference between the levels\n               # of the best and worst supported ciphers.\n               if [[ $worst_cipher -ne $best_cipher ]]; then\n                    case $best_cipher in\n                         3|5|6|7)\n                              difference_rating=$worst_cipher\n                              [[ $difference_rating -gt 5 ]] && difference_rating=5\n                              ;;\n                         4)\n                              case $worst_cipher in\n                                   3) difference_rating=4 ;;\n                                   2) difference_rating=2 ;;\n                                   1) difference_rating=1 ;;\n                              esac\n                              ;;\n                         2)\n                              difference_rating=2\n                              ;;\n                    esac\n               fi\n\n               [[ $difference_rating -lt $NO_CIPHER_ORDER_LEVEL ]] && NO_CIPHER_ORDER_LEVEL=$difference_rating\n               id=\"cipher_order${proto}\"\n               case $difference_rating in\n                    5)\n                         outln \" (no server order, thus listed by strength)\"\n                         fileout \"$id\" \"INFO\" \"NOT a cipher order configured\"\n                         ;;\n                    4)\n                         prln_svrty_low \" (no server order, thus listed by strength)\"\n                         fileout \"$id\" \"LOW\" \"NOT a cipher order configured\"\n                         ;;\n                    3)\n                         prln_svrty_medium \" (no server order, thus listed by strength)\"\n                         fileout \"$id\" \"MEDIUM\" \"NOT a cipher order configured\"\n                         ;;\n                    2)\n                         prln_svrty_high \" (no server order, thus listed by strength)\"\n                         fileout \"$id\" \"HIGH\" \"NOT a cipher order configured\"\n                         ;;\n                    1)\n                         prln_svrty_critical \" (no server order, thus listed by strength)\"\n                         fileout \"$id\" \"CRITICAL\" \"NOT a cipher order configured\"\n                         ;;\n               esac\n          fi\n     elif \"$wide\" && \"$proto_supported\" || [[ $proto != -ssl2 ]]; then\n          outln\n     fi\n\n     cipher=\"\"\n     for (( i=0 ; i<nr_ciphers; i++ )); do\n          if \"${ciphers_found[i]}\"; then\n               if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]] && [[ \"${rfc_ciph[i]}\" != - ]]; then\n                    cipher+=\"${rfc_ciph[i]} \"\n               else\n                    cipher+=\"${ciph[i]} \"\n               fi\n          fi\n          if \"$wide\" && { \"${ciphers_found[i]}\" || \"$SHOW_EACH_C\"; }; then\n               normalized_hexcode[i]=\"$(tolower \"${normalized_hexcode[i]}\")\"\n               neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\" \"${ciphers_found[i]}\"\n               available=\"\"\n               if \"$SHOW_EACH_C\"; then\n                    if \"${ciphers_found[i]}\"; then\n                         available=\"available\"\n                         pr_cyan \"$available\"\n                    else\n                         available=\"not a/v\"\n                         pr_deemphasize \"$available\"\n                    fi\n               fi\n               outln \"${sigalg[i]}\"\n               id=\"cipher$proto\"\n               id+=\"_${normalized_hexcode[i]}\"\n               fileout \"$id\" \"$(get_cipher_quality_severity \"${ciph[i]}\")\" \"$proto_text  $(neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\") $available\"\n          fi\n     done\n\n     if [[ $proto != -ssl2 ]]; then\n          # We handled SSLv2 above already\n          if [[ -n \"$cipher\" ]]; then\n               add_proto_offered $proto yes\n          else\n               add_proto_offered $proto no\n               \"$wide\" && outln \" -\"\n          fi\n     fi\n     if ! \"$wide\" && [[ -n \"$cipher\" ]]; then\n          outln\n          out \"$(printf \"    %-10s \" \"$proto_text: \")\"\n          if [[ \"$COLOR\" -le 2 ]]; then\n               out \"$(out_row_aligned_max_width \"$cipher\" \"               \" $TERM_WIDTH)\"\n          else\n               out_row_aligned_max_width_by_entry \"$cipher\" \"               \" $TERM_WIDTH pr_cipher_quality\n          fi\n     fi\n     [[ -n \"$cipher\" ]] && fileout \"supportedciphers_${proto_text//./_}\" \"INFO\" \"$cipher\"\n\n     \"$using_sockets\" && HAS_DH_BITS=\"$has_dh_bits\"\n     tmpfile_handle ${FUNCNAME[0]}${proto}.txt\n     return 0\n#FIXME: no error condition\n}\n\n# Test for all ciphers per protocol locally configured (w/o distinguishing whether they are good or bad)\n#\nrun_cipher_per_proto() {\n     local proto proto_hex proto_text\n     local using_sockets=true\n\n     \"$SSL_NATIVE\" && using_sockets=false\n     \"$FAST\" && using_sockets=false\n     [[ $TLS_NR_CIPHERS == 0 ]] && using_sockets=false\n\n     outln\n     if \"$using_sockets\"; then\n          pr_headlineln \" Testing ciphers per protocol via OpenSSL plus sockets against the server, ordered by encryption strength \"\n     else\n          pr_headlineln \" Testing all locally available ciphers per protocol against the server, ordered by encryption strength \"\n          [[ $TLS_NR_CIPHERS == 0 ]] && ! \"$SSL_NATIVE\" && ! \"$FAST\" && pr_warning \" Cipher mapping not available, doing a fallback to openssl\"\n          outln\n          if ! \"$HAS_DH_BITS\"; then\n               [[ $TLS_NR_CIPHERS == 0 ]] && ! \"$SSL_NATIVE\" && ! \"$FAST\" && out \".\"\n               prln_warning \"    (Your $OPENSSL cannot show DH/ECDH bits)\"\n          fi\n     fi\n     outln\n     neat_header\n     while read proto proto_hex proto_text; do\n          pr_underline \"$(printf -- \"%b\" \"$proto_text\")\"\n          ciphers_by_strength \"$proto\" \"$proto_hex\" \"$proto_text\" \"$using_sockets\" \"true\" \"false\"\n     done <<< \"$(tm_out \" -ssl2 22 SSLv2\\n -ssl3 00 SSLv3\\n -tls1 01 TLS 1\\n -tls1_1 02 TLS 1.1\\n -tls1_2 03 TLS 1.2\\n -tls1_3 04 TLS 1.3\")\"\n     return 0\n#FIXME: no error condition\n}\n\n# arg1 is an ASCII-HEX encoded SSLv3 or TLS ClientHello.\n# arg2: new key_share extension (only present to response to HelloRetryRequest)\n# arg3: cookie extension (if needed for response to HelloRetryRequest)\n#\n# This function may be used to either modify a ClientHello for client simulation\n# or to create a second ClientHello in response to a HelloRetryRequest.\n# If arg2 is present, then this is a response to a HelloRetryRequest, so the\n# function replaces the key_share extension with arg2 and adds the cookie\n# extension, if present.\n# If arg2 is not present, then this is an initial ClientHello for client simulation.\n# In this case, if the provided ClientHello contains a server name extension,\n# then either:\n#  1) replace it with one corresponding to $SNI; or\n#  2) remove it, if $SNI is empty\nmodify_clienthello() {\n     local tls_handshake_ascii=\"$1\"\n     local new_key_share=\"$2\" cookie=\"$3\"\n     local -i len offset tls_handshake_ascii_len len_all len_clienthello\n     local -i len_extensions len_extension\n     local tls_content_type tls_version_reclayer handshake_msg_type tls_clientversion\n     local tls_random tls_sid tls_cipher_suites tls_compression_methods\n     local tls_extensions=\"\" extension_type len_extensions_hex\n     local len_servername hexdump_format_str servername_hexstr\n     local len_servername_hex len_sni_listlen len_sni_ext\n     local tls_client_hello len_clienthello_hex tls_handshake_ascii_len_hex\n     local sni_extension_found=false\n\n     tls_handshake_ascii_len=${#tls_handshake_ascii}\n\n     tls_content_type=\"${tls_handshake_ascii:0:2}\"\n     tls_version_reclayer=\"${tls_handshake_ascii:2:4}\"\n     len_all=$(hex2dec \"${tls_handshake_ascii:6:4}\")\n\n     handshake_msg_type=\"${tls_handshake_ascii:10:2}\"\n     len_clienthello=$(hex2dec \"${tls_handshake_ascii:12:6}\")\n     tls_clientversion=\"${tls_handshake_ascii:18:4}\"\n     tls_random=\"${tls_handshake_ascii:22:64}\"\n     len=2*$(hex2dec \"${tls_handshake_ascii:86:2}\")+2\n     tls_sid=\"${tls_handshake_ascii:86:$len}\"\n     offset=86+$len\n\n     len=2*$(hex2dec \"${tls_handshake_ascii:$offset:4}\")+4\n     tls_cipher_suites=\"${tls_handshake_ascii:$offset:$len}\"\n     offset=$offset+$len\n\n     len=2*$(hex2dec \"${tls_handshake_ascii:$offset:2}\")+2\n     tls_compression_methods=\"${tls_handshake_ascii:$offset:$len}\"\n     offset=$offset+$len\n\n     if [[ $offset -ge $tls_handshake_ascii_len ]]; then\n          # No extensions\n          tm_out \"$tls_handshake_ascii\"\n          return 0\n     fi\n\n     len_extensions=2*$(hex2dec \"${tls_handshake_ascii:$offset:4}\")\n     offset+=4\n     for (( 1; offset < tls_handshake_ascii_len; 1 )); do\n          extension_type=\"${tls_handshake_ascii:$offset:4}\"\n          offset+=4\n          len_extension=2*$(hex2dec \"${tls_handshake_ascii:$offset:4}\")\n\n          if [[ \"$extension_type\" == 0000 ]] && [[ -z \"$new_key_share\" ]]; then\n               # If this is an initial ClientHello, then either remove\n               # the SNI extension or replace it with the correct server name.\n               sni_extension_found=true\n               if [[ -n \"$SNI\" ]]; then\n                    servername=${XMPP_HOST:-${NODE}}\n                    # Create a server name extension that corresponds to $SNI\n                    len_servername=${#servername}\n                    hexdump_format_str=\"$len_servername/1 \\\"%02x\\\"\"\n                    servername_hexstr=$(printf $servername | hexdump -v -e \"${hexdump_format_str}\")\n                    # convert lengths we need to fill in from dec to hex:\n                    len_servername_hex=$(printf \"%02x\\n\" $len_servername)\n                    len_sni_listlen=$(printf \"%02x\\n\" $((len_servername+3)))\n                    len_sni_ext=$(printf \"%02x\\n\" $((len_servername+5)))\n                    tls_extensions+=\"000000${len_sni_ext}00${len_sni_listlen}0000${len_servername_hex}${servername_hexstr}\"\n               fi\n               offset+=$len_extension+4\n          elif [[ \"$extension_type\" != 00$KEY_SHARE_EXTN_NR ]] || [[ -z \"$new_key_share\" ]]; then\n               # If this is in response to a HelloRetryRequest, then do\n               # not copy over the old key_share extension, but\n               # all other extensions should be copied into the new ClientHello.\n               offset=$offset-4\n               len=$len_extension+8\n               tls_extensions+=\"${tls_handshake_ascii:$offset:$len}\"\n               offset+=$len\n          else\n               # This is the key_share extension, and the modified ClientHello\n               # is being created in response to a HelloRetryRequest. Replace\n               # the existing key_share extension with the new one.\n               tls_extensions+=\"$new_key_share\"\n               offset+=$len_extension+4\n          fi\n     done\n     tls_extensions+=\"$cookie\"\n\n     if ! \"$sni_extension_found\" && [[ -z \"$new_key_share\" ]]; then\n          tm_out \"$tls_handshake_ascii\"\n          return 0\n     fi\n\n     len_extensions=${#tls_extensions}/2\n     len_extensions_hex=$(printf \"%02x\\n\" $len_extensions)\n     len2twobytes \"$len_extensions_hex\"\n     tls_extensions=\"${LEN_STR:0:2}${LEN_STR:4:2}${tls_extensions}\"\n\n     tls_client_hello=\"${tls_clientversion}${tls_random}${tls_sid}${tls_cipher_suites}${tls_compression_methods}${tls_extensions}\"\n     len_clienthello=${#tls_client_hello}/2\n     len_clienthello_hex=$(printf \"%02x\\n\" $len_clienthello)\n     len2twobytes \"$len_clienthello_hex\"\n     tls_handshake_ascii=\"${handshake_msg_type}00${LEN_STR:0:2}${LEN_STR:4:2}${tls_client_hello}\"\n\n     tls_handshake_ascii_len=${#tls_handshake_ascii}/2\n     tls_handshake_ascii_len_hex=$(printf \"%02x\\n\" $tls_handshake_ascii_len)\n     len2twobytes \"$tls_handshake_ascii_len_hex\"\n     tls_handshake_ascii=\"${tls_content_type}${tls_version_reclayer}${LEN_STR:0:2}${LEN_STR:4:2}${tls_handshake_ascii}\"\n     tm_out \"$tls_handshake_ascii\"\n     return 0\n}\n\nclient_simulation_sockets() {\n     local -i len i ret=0\n     local -i save=0\n     local lines clienthello data=\"\"\n     local cipher_list_2send=\"\"\n     local sock_reply_file2 sock_reply_file3\n     local tls_hello_ascii next_packet hello_done=0\n     local -i sid_len offset1 offset2\n\n     if [[ \"${1:0:4}\" == 1603 ]]; then\n          clienthello=\"$(modify_clienthello \"$1\")\"\n          TLS_CLIENT_HELLO=\"${clienthello:10}\"\n     else\n          clienthello=\"$1\"\n          TLS_CLIENT_HELLO=\"\"\n     fi\n     len=${#clienthello}\n     for (( i=0; i < len; i+=2 )); do\n          data+=\", ${clienthello:i:2}\"\n     done\n     # same as above. If a CIPHER_SUITES string was provided, then check that it is in the ServerHello\n     # this appeared 1st in yassl + MySQL (https://github.com/testssl/testssl.sh/pull/784) but adds\n     # robustness to the implementation\n     # see also https://github.com/testssl/testssl.sh/pull/797\n     if [[ \"${1:0:4}\" == 1603 ]]; then\n          # Extract list of cipher suites from SSLv3 or later ClientHello\n          sid_len=4*$(hex2dec \"${data:174:2}\")\n          offset1=178+$sid_len\n          offset2=182+$sid_len\n          len=4*$(hex2dec \"${data:offset1:2}${data:offset2:2}\")-2\n          offset1=186+$sid_len\n          code2network \"$(tolower \"${data:offset1:len}\")\"    # convert CIPHER_SUITES to a \"standardized\" format\n     else\n          # Extract list of cipher suites from SSLv2 ClientHello\n          len=2*$(hex2dec \"${clienthello:12:2}\")\n          for (( i=22; i < 22+len; i+=6 )); do\n               offset1=$i+2\n               offset2=$i+4\n               [[ \"${clienthello:i:2}\" == 00 ]] && cipher_list_2send+=\", ${clienthello:offset1:2},${clienthello:offset2:2}\"\n          done\n          code2network \"$(tolower \"${cipher_list_2send:2}\")\" # convert CIPHER_SUITES to a \"standardized\" format\n     fi\n     cipher_list_2send=\"$NW_STR\"\n\n     fd_socket 5 || return 6\n     debugme echo -e \"\\nsending client hello... \"\n     socksend_clienthello \"${data}\"\n     sleep $USLEEP_SND\n\n     sockread 32768\n     tls_hello_ascii=$(hexdump -v -e '16/1 \"%02X\"' \"$SOCK_REPLY_FILE\")\n     tls_hello_ascii=\"${tls_hello_ascii%%[!0-9A-F]*}\"\n\n     # Check if the response is a HelloRetryRequest.\n     resend_if_hello_retry_request \"$clienthello\" \"$tls_hello_ascii\"\n     ret=$?\n     if [[ $ret -eq 2 ]]; then\n          tls_hello_ascii=$(hexdump -v -e '16/1 \"%02X\"' \"$SOCK_REPLY_FILE\")\n          tls_hello_ascii=\"${tls_hello_ascii%%[!0-9A-F]*}\"\n     elif [[ $ret -eq 1 ]] || [[ $ret -eq 6 ]]; then\n          close_socket 5\n          TMPFILE=$SOCK_REPLY_FILE\n          tmpfile_handle ${FUNCNAME[0]}.dd\n          return $ret\n     fi\n\n     if [[ \"${tls_hello_ascii:0:1}\" != \"8\" ]]; then\n          check_tls_serverhellodone \"$tls_hello_ascii\" \"ephemeralkey\"\n          hello_done=$?\n     fi\n\n     for(( 1 ; hello_done==1; 1 )); do\n          if [[ $DEBUG -ge 1 ]]; then\n               sock_reply_file2=${SOCK_REPLY_FILE}.2\n               mv \"$SOCK_REPLY_FILE\" \"$sock_reply_file2\"\n          fi\n\n          debugme echo -n \"requesting more server hello data... \"\n          socksend \"\" $USLEEP_SND\n          sockread 32768\n\n          next_packet=$(hexdump -v -e '16/1 \"%02X\"' \"$SOCK_REPLY_FILE\")\n          next_packet=\"${next_packet%%[!0-9A-F]*}\"\n          if [[ ${#next_packet} -eq 0 ]]; then\n               # This shouldn't be necessary. However, it protects against\n               # getting into an infinite loop if the server has nothing\n               # left to send and check_tls_serverhellodone doesn't\n               # correctly catch it.\n               [[ $DEBUG -ge 1 ]] && mv \"$sock_reply_file2\" \"$SOCK_REPLY_FILE\"\n               hello_done=0\n          else\n               tls_hello_ascii+=\"$next_packet\"\n               if [[ $DEBUG -ge 1 ]]; then\n                    sock_reply_file3=${SOCK_REPLY_FILE}.3\n                    mv \"$SOCK_REPLY_FILE\" \"$sock_reply_file3\"    #FIXME: we moved that already\n                    mv \"$sock_reply_file2\" \"$SOCK_REPLY_FILE\"\n                    cat \"$sock_reply_file3\" >> \"$SOCK_REPLY_FILE\"\n                    rm \"$sock_reply_file3\"\n               fi\n\n               check_tls_serverhellodone \"$tls_hello_ascii\" \"ephemeralkey\"\n               hello_done=$?\n          fi\n     done\n\n     debugme echo \"reading server hello...\"\n     if [[ \"$DEBUG\" -ge 4 ]]; then\n          hexdump -C $SOCK_REPLY_FILE | head -6\n          echo\n     fi\n     if [[ \"${tls_hello_ascii:0:1}\" == 8 ]]; then\n          parse_sslv2_serverhello \"$SOCK_REPLY_FILE\" \"false\"\n          if [[ $? -eq 3 ]] && [[ \"$V2_HELLO_CIPHERSPEC_LENGTH\" -ne 0 ]]; then\n               echo \"Protocol  : SSLv2\" > \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\"\n               DETECTED_TLS_VERSION=\"0200\"\n               ret=0\n          else\n               ret=1\n          fi\n     else\n          parse_tls_serverhello \"$tls_hello_ascii\" \"ephemeralkey\" \"$cipher_list_2send\"\n          save=$?\n\n          if [[ $save -eq 0 ]]; then\n               send_close_notify \"$DETECTED_TLS_VERSION\"\n          fi\n\n          if [[ $DEBUG -ge 2 ]]; then\n               # see https://secure.wand.net.nz/trac/libprotoident/wiki/SSL\n               lines=$(count_lines \"$(hexdump -C \"$SOCK_REPLY_FILE\" 2>$ERRFILE)\")\n               tm_out \"  ($lines lines returned)  \"\n          fi\n\n          # determine the return value for higher level, so that they can tell what the result is\n          if [[ $save -eq 1 ]] || [[ $lines -eq 1 ]]; then\n               ret=1          # NOT available\n          else\n               ret=0\n          fi\n          debugme tmln_out\n     fi\n\n     close_socket 5\n     TMPFILE=$SOCK_REPLY_FILE\n     tmpfile_handle ${FUNCNAME[0]}.dd\n     return $ret\n}\n\nrun_client_simulation() {\n     # Runs browser simulations. Browser capabilities gathered from:\n     # https://www.ssllabs.com/ssltest/clients.html on 10 jan 2016\n     local names=()\n     local short=()\n     local protos=()\n     local ch_ciphers=()\n     local ciphersuites=()\n     local tlsvers=()\n     local ch_sni=()\n     local warning=()\n     local handshakebytes=()\n     local lowest_protocol=()\n     local highest_protocol=()\n     local service=()\n     local minDhBits=()\n     local maxDhBits=()\n     local minRsaBits=()\n     local maxRsaBits=()\n     local minEcdsaBits=()\n     local curves=()\n     local requiresSha2=()\n     local current=()\n     local i=0\n     local name tls proto cipher temp what_dh bits curve supported_curves\n     local has_dh_bits using_sockets=true\n     local client_service\n     local options\n     local -i ret=0\n     local jsonID=\"clientsimulation\"\n     local client_service=\"\"\n\n     # source the external file\n     . \"$TESTSSL_INSTALL_DIR/etc/client-simulation.txt\" 2>/dev/null\n     if [[ $? -ne 0 ]]; then\n          prln_local_problem \"couldn't find client simulation data in $TESTSSL_INSTALL_DIR/etc/client-simulation.txt\"\n          return 1\n     fi\n\n     \"$SSL_NATIVE\" && using_sockets=false\n\n     if [[ $SERVICE != \"\" ]];  then\n          client_service=\"$SERVICE\"\n     elif [[ -n \"$STARTTLS_PROTOCOL\" ]]; then\n          # Can we take the service from STARTTLS?\n          client_service=$(toupper \"${STARTTLS_PROTOCOL%s}\")    # strip trailing 's' in ftp(s), smtp(s), pop3(s), etc\n     elif \"$ASSUME_HTTP\"; then\n          client_service=\"HTTP\"\n     else\n          outln \"Could not determine the protocol, only simulating generic clients.\"\n     fi\n\n     outln\n     pr_headline \" Running client simulations \"\n     [[ \"$client_service\" == HTTP ]] && pr_headline \"($client_service) \"\n     if \"$using_sockets\"; then\n          pr_headlineln \"via sockets \"\n     else\n          pr_headline \"via openssl \"\n          prln_warning \" -- pls note \\\"--ssl-native\\\" will return some false results\"\n          fileout \"$jsonID\" \"WARN\" \"You shouldn't run this with \\\"--ssl-native\\\" as you will get false results\"\n          ret=1\n     fi\n     outln\n     debugme echo\n\n     if [[ \"$DISPLAY_CIPHERNAMES\" =~ openssl ]]; then\n          out \" Browser                      Protocol  Cipher Suite Name (OpenSSL)       \"\n          { \"$using_sockets\" || \"$HAS_DH_BITS\"; } && out \"Forward Secrecy\"\n          outln\n          out \"--------------------------------------------------------------------------\"\n     else\n          out \" Browser                      Protocol  Cipher Suite Name (IANA/RFC)                      \"\n          { \"$using_sockets\" || \"$HAS_DH_BITS\"; } && out \"Forward Secrecy\"\n          outln\n          out \"------------------------------------------------------------------------------------------\"\n     fi\n     { \"$using_sockets\" || \"$HAS_DH_BITS\"; } && out \"----------------------\"\n     outln\n     if ! \"$using_sockets\"; then\n          # We can't use the connectivity checker here as of now the openssl reply is always empty (reason??)\n          save_max_ossl_fail=$MAX_OSSL_FAIL\n          nr_ossl_fail=$NR_OSSL_FAIL\n          MAX_OSSL_FAIL=100\n     fi\n     for name in \"${short[@]}\"; do\n          if \"${current[i]}\" || \"$ALL_CLIENTS\" ; then\n               # for ANY we test this service or if the service we determined from STARTTLS matches\n               if [[ \"${service[i]}\" == ANY ]] || [[ \"${service[i]}\" =~ $client_service ]]; then\n                    out \" $(printf -- \"%-29s\" \"${names[i]}\")\"\n                    if \"$using_sockets\" && [[ -n \"${handshakebytes[i]}\" ]]; then\n                         client_simulation_sockets \"${handshakebytes[i]}\"\n                         sclient_success=$?\n                         if [[ $sclient_success -eq 0 ]]; then\n                              if [[ \"0x${DETECTED_TLS_VERSION}\" -lt ${lowest_protocol[i]} ]] || \\\n                                 [[ \"0x${DETECTED_TLS_VERSION}\" -gt ${highest_protocol[i]} ]]; then\n                                   sclient_success=1\n                              fi\n                              [[ $sclient_success -eq 0 ]] && cp \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" $TMPFILE >$ERRFILE\n                         fi\n                    else\n                         if [[ -n \"${curves[i]}\" ]]; then\n                              # \"$OPENSSL s_client\" will fail if the -curves option includes any unsupported curves.\n                              supported_curves=\"\"\n                              for curve in $(colon_to_spaces \"${curves[i]}\"); do\n                                   # Attention! secp256r1 = prime256v1 and secp192r1 = prime192v1\n                                   # We need to map two curves here as otherwise handshakes will go wrong if \"-curves\" are supplied\n                                   # https://github.com/openssl/openssl/blob/master/apps/ecparam.c#L221 + ./ssl/t1_lib.c\n                                   [[ \"$curve\" =~ secp256r1 ]] && curve=\"${curve//secp256r1/prime256v1}\"\n                                   [[ \"$curve\" =~ secp192r1 ]] && curve=\"${curve//secp192r1/prime192v1}\"\n                                   [[ \"$OSSL_SUPPORTED_CURVES\" =~ \\ $curve\\  ]] && supported_curves+=\":$curve\"\n                              done\n                              curves[i]=\"\"\n                              [[ -n \"$supported_curves\" ]] && curves[i]=\"-curves ${supported_curves:1}\"\n                         fi\n                         options=\"$(s_client_options \"-cipher ${ch_ciphers[i]} -ciphersuites \"\\'${ciphersuites[i]}\\'\" ${curves[i]} ${protos[i]} $STARTTLS $BUGS $PROXY -connect $NODEIP:$PORT ${ch_sni[i]}\")\"\n                         \"$HAS_TLS12\" || options=\"${options//-no_tls1_2 /}\"\n                         \"$HAS_TLS11\" || options=\"${options//-no_tls1_1 /}\"\n                         \"$HAS_TLS1\" || options=\"${options//-no_tls1 /}\"\n                         \"$HAS_SSL3\" || options=\"${options//-no_ssl3 /}\"\n                         debugme echo \"$OPENSSL s_client $options  </dev/null\"\n                         # If \"${protos[i]}\" specifies protocols that aren't supported\n                         # by $OPENSSL, then skip the test.\n                         if [[ ! \"${protos[i]}\" =~ -no_ ]] && [[ ! \"${protos[i]}\" =~ \\  ]] && ! sclient_supported \"${protos[i]}\"; then\n                              pr_local_problem \"${protos[i]} not supported, \"\n                              sclient_success=1\n                         elif ! \"$HAS_SSL3\" && [[ \"${highest_protocol[i]}\" == 0x0300 ]]; then\n                              pr_local_problem \"SSLv3 not supported, \"\n                              sclient_success=1\n                         elif ! \"$HAS_TLS1\" && [[ \"${highest_protocol[i]}\" == 0x0301 ]]; then\n                              pr_local_problem \"TLS 1 not supported, \"\n                              sclient_success=1\n                         elif ! \"$HAS_TLS11\" && [[ \"${highest_protocol[i]}\" == 0x0302 ]]; then\n                              pr_local_problem \"TLS 1.1 not supported, \"\n                              sclient_success=1\n                         elif ! \"$HAS_TLS12\" && [[ \"${highest_protocol[i]}\" == 0x0303 ]]; then\n                              pr_local_problem \"TLS 1.2 not supported, \"\n                              sclient_success=1\n                         elif ! \"$HAS_TLS13\" && [[ \"${highest_protocol[i]}\" == 0x0304 ]]; then\n                              pr_local_problem \"TLS 1.3 not supported, \"\n                              sclient_success=1\n                         elif [[ -z \"$(actually_supported_osslciphers ${ch_ciphers[i]} ${ciphersuites[i]})\" ]]; then\n                              # In some cases $OPENSSL supports the protocol, but none of the ciphers\n                              # offered by the client being simulated. In that case, issue a \"Local problem\"\n                              # rather than having sclient_connect_successful() write \"Oops: openssl s_client connect problem\".\n                              pr_local_problem \"No supported ciphers, \"\n                              sclient_success=1\n                         else\n                              $OPENSSL s_client $options </dev/null >$TMPFILE 2>$ERRFILE\n                              sclient_connect_successful $? $TMPFILE\n                              sclient_success=$?\n                         fi\n                    fi\n                    if [[ $sclient_success -eq 0 ]]; then\n                         # If an ephemeral DH key was used, check that the number of bits is within range.\n                         temp=$(awk -F': ' '/^Server Temp Key/ { print $2 }' \"$TMPFILE\")        # extract line\n                         what_dh=\"${temp%%,*}\"\n                         bits=\"${temp##*, }\"\n                         # formatting\n                         curve=\"${temp#*, }\"\n                         if [[ \"$curve\" == $bits ]]; then\n                              curve=\"\"\n                         else\n                              curve=\"${curve%%,*}\"\n                         fi\n                         bits=\"${bits/bits/}\"\n                         bits=\"${bits// /}\"\n                         if [[ \"$what_dh\" == X25519 ]] || [[ \"$what_dh\" == X448 ]]; then\n                              curve=\"$what_dh\"\n                              what_dh=\"ECDH\"\n                         fi\n                         if [[ \"$what_dh\" == DH ]]; then\n                              [[ ${minDhBits[i]} -ne -1 ]] && [[ $bits -lt ${minDhBits[i]} ]] && sclient_success=1\n                              [[ ${maxDhBits[i]} -ne -1 ]] && [[ $bits -gt ${maxDhBits[i]} ]] && sclient_success=1\n                         fi\n                    fi\n                    if [[ $sclient_success -ne 0 ]]; then\n                         outln \"No connection\"\n                         fileout \"${jsonID}-${short[i]}\" \"INFO\" \"No connection\"\n                    else\n                         proto=$(get_protocol $TMPFILE)\n                         # hack:\n                         [[ \"$proto\" == TLSv1 ]] && proto=\"TLSv1.0\"\n                         [[ \"$proto\" == SSLv3 ]] && proto=\"SSLv3  \"\n                         if [[ \"$proto\" == TLSv1.2 ]] && { ! \"$using_sockets\" || [[ -z \"${handshakebytes[i]}\" ]]; }; then\n                              # OpenSSL reports TLS1.2 even if the connection is TLS1.1 or TLS1.0. Need to figure out which one it is...\n                              for tls in ${tlsvers[i]}; do\n                                   # If the handshake data specifies an unsupported protocol we need to remove it, otherwise the\n                                   # simulation will fail with # 'Oops: openssl s_client connect problem'\n                                   # before/after trying another protocol. We only print a warning it in debug mode\n                                   # as otherwise we would need e.g. handle the curves in a similar fashion -- not\n                                   # to speak about ciphers\n                                   if ! sclient_supported \"$tls\"; then\n                                        debugme pr_local_problem \"$tls not supported, \"\n                                        continue\n                                   fi\n                                   options=\"$(s_client_options \"$tls -cipher ${ch_ciphers[i]} -ciphersuites \"\\'${ciphersuites[i]}\\'\" ${curves[i]} $STARTTLS $BUGS $PROXY -connect $NODEIP:$PORT ${ch_sni[i]}\")\"\n                                   debugme echo \"$OPENSSL s_client $options  </dev/null\"\n                                   $OPENSSL s_client $options  </dev/null >$TMPFILE 2>$ERRFILE\n                                   sclient_connect_successful $? $TMPFILE\n                                   sclient_success=$?\n                                   if [[ $sclient_success -eq 0 ]]; then\n                                        case \"$tls\" in\n                                             \"-tls1_2\") break ;;\n                                             \"-tls1_1\") proto=\"TLSv1.1\"\n                                                        break ;;\n                                             \"-tls1\")   proto=\"TLSv1.0\"\n                                                        break ;;\n                                        esac\n                                   fi\n                              done\n                         fi\n                         cipher=$(get_cipher $TMPFILE)\n                         if [[ \"$DISPLAY_CIPHERNAMES\" =~ openssl ]] && [[ \"$cipher\" == TLS_* || \"$cipher\" == SSL_* ]]; then\n                              cipher=\"$(rfc2openssl \"$cipher\")\"\n                              [[ -z \"$cipher\" ]] && cipher=$(get_cipher $TMPFILE)\n                         elif [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]] && [[ \"$cipher\" != TLS_* ]] && [[ \"$cipher\" != SSL_* ]]; then\n                              cipher=\"$(openssl2rfc \"$cipher\")\"\n                              [[ -z \"$cipher\" ]] && cipher=$(get_cipher $TMPFILE)\n                         fi\n                         out \"$proto   \"\n                         if [[ \"$COLOR\" -le 2 ]]; then\n                              out \"$cipher\"\n                         else\n                              pr_cipher_quality \"$cipher\"\n                         fi\n                         if [[ \"$DISPLAY_CIPHERNAMES\" =~ openssl ]]; then\n                              print_n_spaces \"$((34-${#cipher}))\"\n                         else\n                              print_n_spaces \"$((50-${#cipher}))\"\n                         fi\n                         if [[ -n \"$what_dh\" ]]; then\n                              [[ -n \"$curve\" ]] && curve=\"($curve)\"\n                              if [[ \"$what_dh\" == ECDH ]]; then\n                                   pr_ecdh_quality \"$bits\" \"$(printf -- \"%-12s\" \"$bits bit $what_dh\") $curve\"\n                              else\n                                   pr_dh_quality \"$bits\" \"$(printf -- \"%-12s\" \"$bits bit $what_dh\") $curve\"\n                              fi\n                         else\n                              if \"$HAS_DH_BITS\" || { \"$using_sockets\" && [[ -n \"${handshakebytes[i]}\" ]]; }; then\n                                   out \"No FS\"\n                              fi\n                         fi\n                         outln\n                         if [[ -n \"${warning[i]}\" ]]; then\n                              out \"                            \"\n                              outln \"${warning[i]}\"\n                         fi\n                         fileout \"${jsonID}-${short[i]}\" \"INFO\" \"$proto $cipher  ${warning[i]}\"\n                         debugme cat $TMPFILE\n                    fi\n               fi   # correct service?\n          fi   #current?\n          ((i++))\n     done\n     if ! \"$using_sockets\"; then\n          # restore from above\n          MAX_OSSL_FAIL=$save_max_ossl_fail\n          NR_OSSL_FAIL=$nr_ossl_fail\n     fi\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return $ret\n}\n\n# generic function whether $1 is supported by s_client.\nsclient_supported() {\n     case \"$1\" in\n          -ssl2)\n               \"$HAS_SSL2\" || return 7\n               ;;\n          -ssl3)\n               \"$HAS_SSL3\" || return 7\n               ;;\n          -tls1)\n               \"$HAS_TLS1\" || return 7\n               ;;\n          -tls1_1)\n               \"$HAS_TLS11\" || return 7\n               ;;\n          -tls1_2)\n               \"$HAS_TLS12\" || return 7\n               ;;\n          -tls1_3)\n               \"$HAS_TLS13\" || return 7\n               ;;\n          *)   if $OPENSSL s_client -connect $NXCONNECT \"$1\" </dev/null 2>&1 | grep -aiq \"unknown option\"; then\n                    return 7\n               fi\n               ;;\n     esac\n     return 0\n}\n\n# The protocol check in run_protocols needs to be redone. The using_sockets part there kind of sucks.\n# 1) we need to have a variable where the results are being stored so that every other test doesn't have to do this again\n#   --> we have that but certain information like \"downgraded\" are not being passed. That's not ok for run_protocols()/\n#   for all other functions we can use it\n# 2) the code is old and one can do that way better\n# We should do what's available and faster (openssl vs. sockets). Keep in mind that the socket reply for SSLv2 returns the number # of ciphers!\n#\n# arg1: -ssl2|-ssl3|-tls1|-tls1_1|-tls1_2|-tls1_3\n#\nrun_prototest_openssl() {\n     local -i ret=0\n     local protos proto\n\n     sclient_supported \"$1\" || return 7\n     case \"$1\" in\n          -ssl2) protos=\"-ssl2\" ;;\n          -ssl3) protos=\"-ssl3\" ;;\n          -tls1) protos=\"-no_tls1_2 -no_tls1_1 -no_ssl2\"; \"$HAS_TLS13\" && protos+=\" -no_tls1_3\" ;;\n          -tls1_1) protos=\"-no_tls1_2 -no_ssl2\"; \"$HAS_TLS13\" && protos+=\" -no_tls1_3\" ;;\n          -tls1_2) protos=\"-no_ssl2\"; \"$HAS_TLS13\" && protos+=\" -no_tls1_3\" ;;\n          -tls1_3) protos=\"\" ;;\n     esac\n\n     #FIXME: we have here HAS_SSL(2|3) and more but we don't use that\n     $OPENSSL s_client $(s_client_options \"-state $protos $STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI\") >$TMPFILE 2>&1 </dev/null\n     sclient_connect_successful $? $TMPFILE\n     ret=$?\n     debugme grep -E \"error|failure\" $ERRFILE | grep -Eav \"unable to get local|verify error\"\n     if [[ $ret -ne 0 ]]; then\n          if grep -aq \"no cipher list\" $TMPFILE; then\n               ret=5       # <--- important indicator for SSL2 (maybe others, too)\n          else\n               # try again without $PROXY\n               $OPENSSL s_client $(s_client_options \"-state $protos $STARTTLS $BUGS -connect $NODEIP:$PORT $SNI\") >$TMPFILE 2>&1 </dev/null\n               sclient_connect_successful $? $TMPFILE\n               ret=$?\n               debugme grep -E \"error|failure\" $ERRFILE | grep -Eav \"unable to get local|verify error\"\n               grep -aq \"no cipher list\" $TMPFILE && ret=5       # <--- important indicator for SSL2 (maybe others, too)\n          fi\n     fi\n     if [[ $ret -eq 0 ]]; then\n          proto=\"$(get_protocol \"$TMPFILE\")\"\n          proto=${proto/\\./_}\n          proto=${proto/v/}\n          proto=\"-$(tolower $proto)\"\n          [[ \"$proto\" != $1 ]] && ret=2\n          case \"$proto\" in\n               -ssl3) DETECTED_TLS_VERSION=\"0300\" ;;\n               -tls1) DETECTED_TLS_VERSION=\"0301\" ;;\n               -tls1_1) DETECTED_TLS_VERSION=\"0302\" ;;\n               -tls1_2) DETECTED_TLS_VERSION=\"0303\" ;;\n               -tls1_3) DETECTED_TLS_VERSION=\"0304\" ;;\n          esac\n     fi\n     tmpfile_handle ${FUNCNAME[0]}$1.txt\n     return $ret\n\n     # 0: offered\n     # 1: not offered\n     # 2: downgraded\n     # 5: protocol ok, but no cipher\n     # 7: no local support\n}\n\n# Idempotent function to add SSL/TLS protocols. It should accelerate testing.\n# PROTOS_OFFERED can be e.g. \"ssl2:no ssl3:no tls1_2:yes\" which means that\n# SSLv2 and SSLv3 was tested but not available, TLS 1.2 was tested and available\n# TLS 1.0 and TLS 1.2 not tested yet\n#\n# arg1: protocol\n# arg2: available (yes) or not (no)\nadd_proto_offered() {\n     # the \":\" is mandatory here (and @ other places), otherwise e.g. tls1 will match tls1_2\n     if [[ \"$2\" == yes ]] && [[ \"$PROTOS_OFFERED\" =~ $1:no ]]; then\n          # In rare cases, a protocol may be marked as not available even though it is\n          # (e.g., the connection fails with tls_sockets() but succeeds with $OPENSSL.\n          PROTOS_OFFERED=\"${PROTOS_OFFERED/$1:no/$1:$2}\"\n     elif [[ ! \"$PROTOS_OFFERED\" =~ $1: ]]; then\n          PROTOS_OFFERED+=\"${1}:$2 \"\n     fi\n}\n\n# function which checks whether SSLv2 - TLS 1.2 is being offered, see add_proto_offered()\n# arg1:    protocol string or hex code for TLS protocol\n# echos:   0 if proto known being offered, 1: known not being offered, 2: we don't know yet whether proto is being offered\n# return value is always zero\nhas_server_protocol() {\n     local proto\n     local proto_val_pair\n\n     case \"$1\" in\n          04) proto=\"tls1_3\" ;;\n          03) proto=\"tls1_2\" ;;\n          02) proto=\"tls1_1\" ;;\n          01) proto=\"tls1\" ;;\n          00) proto=\"ssl3\" ;;\n           *) proto=\"$1\" ;;\n     esac\n\n     if [[ \"$PROTOS_OFFERED\" =~ $proto: ]]; then\n          for proto_val_pair in $PROTOS_OFFERED; do\n               if [[ $proto_val_pair =~ $proto: ]]; then\n                    if [[ ${proto_val_pair#*:} == yes ]]; then\n                         echo 0\n                         return 0\n                    else\n                         echo 1\n                         return 0\n                    fi\n               fi\n          done\n     else\n          # if empty echo 2, hinting to the caller to check at additional cost/connect\n          echo 2\n          return 0\n     fi\n}\n\n\n# the protocol check needs to be revamped. It sucks, see above\nrun_protocols() {\n     local using_sockets=true\n     local supported_no_ciph1=\"supported but couldn't detect a cipher (may need debugging)\"\n     local supported_no_ciph2=\"supported but couldn't detect a cipher\"\n     local latest_supported=\"\"  # version.major and version.minor of highest version supported by the server\n     local detected_version_string latest_supported_string\n     local key_share_extn_nr=\"$KEY_SHARE_EXTN_NR\"\n     local lines nr_ciphers_detected\n     local tls13_ciphers_to_test=\"\"\n     local i drafts_offered=\"\"  drafts_offered_str=\"\" supported_versions debug_recomm=\"\"\n     local tls12_detected_version\n     local -i ret=0 ret_val_ssl3 ret_val_tls1 ret_val_tls11 ret_val_tls12=0 ret_val_tls13=0\n     local offers_tls13=false\n     local jsonID=\"SSLv2\"\n\n     outln; pr_headline \" Testing protocols \"\n\n     if \"$SSL_NATIVE\"; then\n          using_sockets=false\n          prln_underline \"via native openssl\"\n     else\n          using_sockets=true\n          if [[ -n \"$STARTTLS\" ]]; then\n               prln_underline \"via sockets \"\n          else\n               prln_underline \"via sockets except NPN+ALPN \"\n          fi\n     fi\n     outln\n     [[ \"$DEBUG\" -le 1 ]] && debug_recomm=\", rerun with DEBUG>=2 or --ssl-native\"\n\n     pr_bold \" SSLv2      \";\n     if ! \"$SSL_NATIVE\"; then\n          sslv2_sockets\n          case $? in\n               6) # couldn't open socket\n                    prln_fixme \"couldn't open socket\"\n                    fileout \"$jsonID\" \"WARN\" \"couldn't be tested, socket problem\"\n                    ((ret++))\n                    ;;\n               7) # strange reply, couldn't convert the cipher spec length to a hex number\n                    pr_cyan \"strange v2 reply \"\n                    outln \"$debug_recomm\"\n                    [[ $DEBUG -ge 3 ]] && hexdump -C \"$TEMPDIR/$NODEIP.sslv2_sockets.dd\" | head -1\n                    fileout \"$jsonID\" \"WARN\" \"received a strange SSLv2 reply (rerun with DEBUG>=2)\"\n                    ;;\n               1) # no sslv2 server hello returned, like in openlitespeed which returns HTTP!\n                    prln_svrty_best \"not offered (OK)\"\n                    fileout \"$jsonID\" \"OK\" \"not offered\"\n                    add_proto_offered ssl2 no\n                    ;;\n               0) # reset\n                    prln_svrty_best \"not offered (OK)\"\n                    fileout \"$jsonID\" \"OK\" \"not offered\"\n                    add_proto_offered ssl2 no\n                    ;;\n               4)   # STARTTLS problem\n                    out \"likely \"; pr_svrty_best \"not offered (OK), \"\n                    fileout \"$jsonID\" \"OK\" \"likely not offered\"\n                    add_proto_offered ssl2 no\n                    pr_warning \"received 4xx/5xx after STARTTLS handshake\"; outln \"$debug_recomm\"\n                    fileout \"$jsonID\" \"WARN\" \"received 4xx/5xx after STARTTLS handshake${debug_recomm}\"\n                    ;;\n               3)   lines=$(count_lines \"$(hexdump -C \"$TEMPDIR/$NODEIP.sslv2_sockets.dd\" 2>/dev/null)\")\n                    [[ \"$DEBUG\" -ge 2 ]] && tm_out \"  ($lines lines)  \"\n                    if [[ \"$lines\" -gt 1 ]]; then\n                         nr_ciphers_detected=$((V2_HELLO_CIPHERSPEC_LENGTH / 3))\n                         add_proto_offered ssl2 yes\n                         set_grade_cap \"F\" \"SSLv2 is offered\"\n                         if [[ 0 -eq \"$nr_ciphers_detected\" ]]; then\n                              prln_svrty_high \"supported but couldn't detect a cipher and vulnerable to CVE-2015-3197 \";\n                              fileout \"$jsonID\" \"HIGH\" \"offered, no cipher\" \"CVE-2015-3197\" \"CWE-310\"\n                         else\n                              pr_svrty_critical \"offered (NOT ok), also VULNERABLE to DROWN attack\";\n                              outln \" -- $nr_ciphers_detected ciphers\"\n                              fileout \"$jsonID\" \"CRITICAL\" \"vulnerable with $nr_ciphers_detected ciphers\"\n                         fi\n                    fi\n                    ;;\n               *)   pr_fixme \"unexpected value around line $((LINENO))\"; outln \"$debug_recomm\"\n                    ((ret++))\n                    ;;\n          esac\n          debugme tmln_out\n     else\n          run_prototest_openssl \"-ssl2\"\n          case $? in\n               0)   prln_svrty_critical   \"offered (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"offered\"\n                    add_proto_offered ssl2 yes\n                    set_grade_cap \"F\" \"SSLv2 is offered\"\n                    ;;\n               1)   prln_svrty_best \"not offered (OK)\"\n                    fileout \"$jsonID\" \"OK\" \"not offered\"\n                    add_proto_offered ssl2 no\n                    ;;\n               5)   prln_svrty_high \"CVE-2015-3197: $supported_no_ciph2\";\n                    fileout \"$jsonID\" \"HIGH\" \"offered, no cipher\" \"CVE-2015-3197\" \"CWE-310\"\n                    add_proto_offered ssl2 yes\n                    set_grade_cap \"F\" \"SSLv2 is offered\"\n                    ;;\n               7)   prln_local_problem \"$OPENSSL doesn't support \\\"s_client -ssl2\\\"\"\n                    fileout \"$jsonID\" \"WARN\" \"not tested due to lack of local support\"\n                    ((ret++))\n                    ;;\n          esac\n     fi\n\n     pr_bold \" SSLv3      \";\n     jsonID=\"SSLv3\"\n     if [[ $(has_server_protocol ssl3) -eq 0 ]]; then\n          ret_val_ssl3=0\n     elif \"$using_sockets\"; then\n          tls_sockets \"00\" \"$TLS_CIPHER\"\n          ret_val_ssl3=$?\n     else\n          run_prototest_openssl \"-ssl3\"\n          ret_val_ssl3=$?\n     fi\n     case $ret_val_ssl3 in\n          0)   prln_svrty_high \"offered (NOT ok)\"\n               fileout \"$jsonID\" \"HIGH\" \"offered\"\n               if \"$using_sockets\" || \"$HAS_SSL3\"; then\n                    latest_supported=\"0300\"\n                    latest_supported_string=\"SSLv3\"\n               fi\n               add_proto_offered ssl3 yes\n               set_grade_cap \"B\" \"SSLv3 is offered\"\n               ;;\n          1)   prln_svrty_best \"not offered (OK)\"\n               fileout \"$jsonID\" \"OK\" \"not offered\"\n               add_proto_offered ssl3 no\n               ;;\n          2)   if [[ \"$DETECTED_TLS_VERSION\" == 03* ]]; then\n                    detected_version_string=\"TLSv1.$((0x$DETECTED_TLS_VERSION-0x0301))\"\n                    prln_svrty_critical \"server responded with higher version number ($detected_version_string) than requested by client (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"server responded with higher version number ($detected_version_string) than requested by client\"\n               else\n                    if [[ ${#DETECTED_TLS_VERSION} -eq 4 ]]; then\n                         prln_svrty_critical \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2} (NOT ok)\"\n                         fileout \"$jsonID\" \"CRITICAL\" \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2}\"\n                    else\n                         prln_svrty_medium \"strange, server ${DETECTED_TLS_VERSION}\"\n                         fileout \"$jsonID\" \"MEDIUM\" \"strange, server ${DETECTED_TLS_VERSION}\"\n                         ((ret++))\n                    fi\n               fi\n               ;;\n          3)   pr_svrty_best \"not offered (OK), \"\n               fileout \"$jsonID\" \"OK\" \"not offered\"\n               add_proto_offered ssl3 no\n               pr_warning \"SSL downgraded to STARTTLS plaintext\"; outln\n               fileout \"$jsonID\" \"WARN\" \"SSL downgraded to STARTTLS plaintext\"\n               ;;\n          4)   out \"likely \"; pr_svrty_best \"not offered (OK), \"\n               fileout \"$jsonID\" \"OK\" \"not offered\"\n               add_proto_offered ssl3 no\n               pr_warning \"received 4xx/5xx after STARTTLS handshake\"; outln \"$debug_recomm\"\n               fileout \"$jsonID\" \"WARN\" \"received 4xx/5xx after STARTTLS handshake${debug_recomm}\"\n               ;;\n          5)   pr_svrty_high \"$supported_no_ciph1\"               # protocol detected but no cipher --> comes from run_prototest_openssl\n               fileout \"$jsonID\" \"HIGH\" \"$supported_no_ciph1\"\n               add_proto_offered ssl3 yes\n               set_grade_cap \"B\" \"SSLv3 is offered\"\n               ;;\n          7)   if \"$using_sockets\" ; then\n                    # can only happen in debug mode\n                    pr_warning \"strange reply, maybe a client side problem with SSLv3\"; outln \"$debug_recomm\"\n               else\n                    prln_local_problem \"$OPENSSL doesn't support \\\"s_client -ssl3\\\"\"\n                    fileout \"$jsonID\" \"WARN\" \"not tested due to lack of local support\"\n               fi\n               ;;\n          *)   pr_fixme \"unexpected value around line $((LINENO))\"; outln \"$debug_recomm\"\n               ((ret++))\n               ;;\n     esac\n\n     pr_bold \" TLS 1      \";\n     jsonID=\"TLS1\"\n     if [[ $(has_server_protocol tls1) -eq 0 ]]; then\n          ret_val_tls1=0\n     elif \"$using_sockets\"; then\n          tls_sockets \"01\" \"$TLS_CIPHER\"\n          ret_val_tls1=$?\n     else\n          run_prototest_openssl \"-tls1\"\n          ret_val_tls1=$?\n     fi\n     case $ret_val_tls1 in\n          0)   pr_svrty_low \"offered\" ; outln \" (deprecated)\"\n               fileout \"$jsonID\" \"LOW\" \"offered (deprecated)\"\n               if \"$using_sockets\" || \"$HAS_TLS1\"; then\n                    latest_supported=\"0301\"\n                    latest_supported_string=\"TLSv1.0\"\n               fi\n               add_proto_offered tls1 yes\n               set_grade_cap \"B\" \"TLS 1.0 offered\"\n               ;;                                                # nothing wrong with it -- per se\n          1)   out \"not offered\"\n               add_proto_offered tls1 no\n               if [[ -z $latest_supported ]]; then\n                    outln\n                    fileout \"$jsonID\" \"INFO\" \"not offered\"       # neither good nor bad\n               else\n                    prln_svrty_critical \" -- connection failed rather than downgrading to $latest_supported_string (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"connection failed rather than downgrading to $latest_supported_string\"\n               fi\n               ;;\n          2)   pr_svrty_medium \"not offered\"\n               add_proto_offered tls1 no\n               if [[ \"$DETECTED_TLS_VERSION\" == 0300 ]]; then\n                    [[ $DEBUG -ge 1 ]] && tm_out \" -- downgraded\"\n                    outln\n                    fileout \"$jsonID\" \"MEDIUM\" \"not offered, and downgraded to SSL\"\n               elif [[ \"$DETECTED_TLS_VERSION\" == 03* ]]; then\n                    detected_version_string=\"TLSv1.$((0x$DETECTED_TLS_VERSION-0x0301))\"\n                    prln_svrty_critical \" -- server responded with higher version number ($detected_version_string) than requested by client (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"server responded with higher version number ($detected_version_string) than requested by client\"\n               else\n                    if [[ ${#DETECTED_TLS_VERSION} -eq 4 ]]; then\n                         prln_svrty_critical \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2} (NOT ok)\"\n                         fileout \"$jsonID\" \"CRITICAL\" \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2}\"\n                    else\n                         prln_svrty_medium \" -- strange, server ${DETECTED_TLS_VERSION}\"\n                         fileout \"$jsonID\" \"MEDIUM\" \"strange, server ${DETECTED_TLS_VERSION}\"\n                    fi\n               fi\n               ;;\n          3)   out \"not offered, \"\n               fileout \"$jsonID\" \"OK\" \"not offered\"\n               add_proto_offered tls1 no\n               pr_warning \"TLS downgraded to STARTTLS plaintext\"; outln\n               fileout \"$jsonID\" \"WARN\" \"TLS downgraded to STARTTLS plaintext\"\n               ;;\n          4)   out \"likely not offered, \"                                  # STARTTLS problem\n               fileout \"$jsonID\" \"INFO\" \"likely not offered\"\n               add_proto_offered tls1 no\n               pr_warning \"received 4xx/5xx after STARTTLS handshake\"; outln \"$debug_recomm\"\n               fileout \"$jsonID\" \"WARN\" \"received 4xx/5xx after STARTTLS handshake${debug_recomm}\"\n               ;;\n          5)   outln \"$supported_no_ciph1\"                                 # protocol detected but no cipher --> comes from run_prototest_openssl\n               fileout \"$jsonID\" \"INFO\" \"$supported_no_ciph1\"\n               add_proto_offered tls1 yes\n               set_grade_cap \"B\" \"TLS 1.0 offered\"\n               ;;\n          7)   if \"$using_sockets\" ; then\n                    # can only happen in debug mode\n                    pr_warning \"strange reply, maybe a client side problem with TLS 1.0\"; outln \"$debug_recomm\"\n               else\n                    prln_local_problem \"$OPENSSL doesn't support \\\"s_client -tls1\\\"\"\n                    fileout \"$jsonID\" \"WARN\" \"not tested due to lack of local support\"\n               fi\n               ((ret++))\n               ;;\n          *)   pr_fixme \"unexpected value around line $((LINENO))\"; outln \"$debug_recomm\"\n               ((ret++))\n               ;;\n     esac\n\n     pr_bold \" TLS 1.1    \";\n     jsonID=\"TLS1_1\"\n     if [[ $(has_server_protocol tls1_1) -eq 0 ]]; then\n          ret_val_tls11=0\n     elif \"$using_sockets\"; then\n          tls_sockets \"02\" \"$TLS_CIPHER\"\n          ret_val_tls11=$?\n     else\n          run_prototest_openssl \"-tls1_1\"\n          ret_val_tls11=$?\n     fi\n     case $ret_val_tls11 in\n          0)   pr_svrty_low \"offered\" ; outln \" (deprecated)\"\n               fileout \"$jsonID\" \"LOW\" \"offered (deprecated)\"\n               if \"$using_sockets\" || \"$HAS_TLS11\"; then\n                    latest_supported=\"0302\"\n                    latest_supported_string=\"TLSv1.1\"\n               fi\n               add_proto_offered tls1_1 yes\n               set_grade_cap \"B\" \"TLS 1.1 offered\"\n               ;;                                                # nothing wrong with it\n          1)   out \"not offered\"\n               add_proto_offered tls1_1 no\n               if [[ -z $latest_supported ]]; then\n                    outln\n                    fileout \"$jsonID\" \"INFO\" \"not offered\"    # neither good nor bad\n               else\n                    prln_svrty_critical \" -- connection failed rather than downgrading to $latest_supported_string\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"connection failed rather than downgrading to $latest_supported_string\"\n               fi\n               ;;\n          2)   out \"not offered\"\n               add_proto_offered tls1_1 no\n               if [[ \"$DETECTED_TLS_VERSION\" == \"$latest_supported\" ]]; then\n                    [[ $DEBUG -ge 1 ]] && tm_out \" -- downgraded\"\n                    outln\n                    fileout \"$jsonID\" \"CRITICAL\" \"TLSv1.1 is not offered, and downgraded to a weaker protocol\"\n               elif [[ \"$DETECTED_TLS_VERSION\" == 0300 ]] && [[ \"$latest_supported\" == 0301 ]]; then\n                    prln_svrty_critical \" -- server supports TLSv1.0, but downgraded to SSLv3 (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"not offered, and downgraded to SSLv3 rather than TLSv1.0\"\n               elif [[ \"$DETECTED_TLS_VERSION\" == 03* ]] && [[ 0x$DETECTED_TLS_VERSION -gt 0x0302 ]]; then\n                    detected_version_string=\"TLSv1.$((0x$DETECTED_TLS_VERSION-0x0301))\"\n                    prln_svrty_critical \" -- server responded with higher version number ($detected_version_string) than requested by client (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"not offered, server responded with higher version number ($detected_version_string) than requested by client\"\n               else\n                    if [[ ${#DETECTED_TLS_VERSION} -eq 4 ]]; then\n                         prln_svrty_critical \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2} (NOT ok)\"\n                         fileout \"$jsonID\" \"CRITICAL\" \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2}\"\n                    else\n                         prln_svrty_medium \" -- strange, server ${DETECTED_TLS_VERSION}\"\n                         fileout \"$jsonID\" \"MEDIUM\" \"strange, server ${DETECTED_TLS_VERSION}\"\n                    fi\n               fi\n               ;;\n          3)   out \"not offered, \"\n               fileout \"$jsonID\" \"OK\" \"not offered\"\n               add_proto_offered tls1_1 no\n               pr_warning \"TLS downgraded to STARTTLS plaintext\"; outln\n               fileout \"$jsonID\" \"WARN\" \"TLS downgraded to STARTTLS plaintext\"\n               ;;\n          4)   out \"likely not offered, \"                        # STARTTLS problem\n               fileout \"$jsonID\" \"INFO\" \"likely not offered\"\n               add_proto_offered tls1_1 no\n               pr_warning \"received 4xx/5xx after STARTTLS handshake\"; outln \"$debug_recomm\"\n               fileout \"$jsonID\" \"WARN\" \"received 4xx/5xx after STARTTLS handshake${debug_recomm}\"\n               ;;\n          5)   outln \"$supported_no_ciph1\"                       # protocol detected but no cipher --> comes from run_prototest_openssl\n               fileout \"$jsonID\" \"INFO\" \"$supported_no_ciph1\"\n               add_proto_offered tls1_1 yes\n               set_grade_cap \"B\" \"TLS 1.1 offered\"\n               ;;\n          7)   if \"$using_sockets\" ; then\n                    # can only happen in debug mode\n                    pr_warning \"strange reply, maybe a client side problem with TLS 1.1\"; outln \"$debug_recomm\"\n               else\n                    prln_local_problem \"$OPENSSL doesn't support \\\"s_client -tls1_1\\\"\"\n                    fileout \"$jsonID\" \"WARN\" \"not tested due to lack of local support\"\n               fi\n               ((ret++))\n               ;;\n          *)   pr_fixme \"unexpected value around line $((LINENO))\"; outln \"$debug_recomm\"\n               ((ret++))\n               ;;\n     esac\n\n     # Now, we are doing a basic/pre test for TLS 1.2 and 1.3 in order not to penalize servers (medium)\n     # running TLS 1.3 only when TLS 1.2 is not offered.  0 and 5 are the return codes for\n     # TLS 1.3 support (kind of, including deprecated pre-versions of TLS 1.3)\n     if [[ $(has_server_protocol tls1_2) -eq 0 ]]; then\n          ret_val_tls12=0\n     elif \"$using_sockets\"; then\n          tls_sockets \"03\" \"$TLS12_CIPHER\"\n          ret_val_tls12=$?\n          tls12_detected_version=\"$DETECTED_TLS_VERSION\"\n     else\n          run_prototest_openssl \"-tls1_2\"\n          ret_val_tls12=$?\n          tls12_detected_version=\"$DETECTED_TLS_VERSION\"\n     fi\n\n     if [[ $(has_server_protocol tls1_3) -eq 0 ]]; then\n          ret_val_tls13=0\n     elif \"$using_sockets\"; then\n          # Need to ensure that at most 128 ciphers are included in ClientHello.\n          # If the TLSv1.2 test in determine_optimal_sockets_params()  was successful,\n          # then use the 5 TLSv1.3 ciphers plus the cipher selected in the TLSv1.2 test.\n          # If the TLSv1.2 test was not successful, then just use the 5 TLSv1.3 ciphers\n          # plus the list of ciphers used in all of the previous tests ($TLS_CIPHER).\n          if [[ -n \"$TLS12_CIPHER_OFFERED\" ]]; then\n               tls13_ciphers_to_test=\"$TLS13_CIPHER, $TLS12_CIPHER_OFFERED, 00,ff\"\n          else\n               tls13_ciphers_to_test=\"$TLS13_CIPHER,$TLS_CIPHER\"\n          fi\n          tls_sockets \"04\" \"$tls13_ciphers_to_test\"\n          ret_val_tls13=$?\n     else\n          run_prototest_openssl \"-tls1_3\"\n          ret_val_tls13=$?\n     fi\n     if [[ $ret_val_tls13 -eq 0 ]] || [[ $ret_val_tls13 -eq 5 ]]; then\n          offers_tls13=true             # This variable comes in handy for further if statements below\n     fi\n     # Done with pretesting TLS 1.2 and 1.3.\n\n     pr_bold \" TLS 1.2    \";\n     jsonID=\"TLS1_2\"\n     case $ret_val_tls12 in\n          0)   prln_svrty_best \"offered (OK)\"\n               fileout \"$jsonID\" \"OK\" \"offered\"\n               if \"$using_sockets\" || \"$HAS_TLS12\"; then\n                    latest_supported=\"0303\"\n                    latest_supported_string=\"TLSv1.2\"\n               fi\n               add_proto_offered tls1_2 yes\n               ;;                                                     # GCM cipher in TLS 1.2: very good!\n          1)   add_proto_offered tls1_2 no\n               if \"$offers_tls13\"; then\n                    out \"not offered\"\n               else\n                    pr_svrty_medium \"not offered\"\n               fi\n               if [[ -z $latest_supported ]]; then\n                    outln\n                    if \"$offers_tls13\"; then\n                         fileout \"$jsonID\" \"INFO\" \"not offered\"\n                    else\n                         fileout \"$jsonID\" \"MEDIUM\" \"not offered\"     # TLS 1.3, no TLS 1.2 --> no GCM, penalty\n                         set_grade_cap \"C\" \"TLS 1.2 or TLS 1.3 are not offered\"\n                    fi\n               else\n                    prln_svrty_critical \" -- connection failed rather than downgrading to $latest_supported_string\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"connection failed rather than downgrading to $latest_supported_string\"\n               fi\n               ;;\n          2)   add_proto_offered tls1_2 no\n               set_grade_cap \"C\" \"TLS 1.2 is not offered\"\n               pr_svrty_medium \"not offered and downgraded to a weaker protocol\"\n               if [[ \"$tls12_detected_version\" == 0300 ]]; then\n                    detected_version_string=\"SSLv3\"\n               elif [[ \"$tls12_detected_version\" == 03* ]]; then\n                    detected_version_string=\"TLSv1.$((0x$tls12_detected_version-0x0301))\"\n               fi\n               if [[ \"$tls12_detected_version\" == \"$latest_supported\" ]]; then\n                    outln\n                    fileout \"$jsonID\" \"MEDIUM\" \"not offered and downgraded to a weaker protocol\"\n               elif [[ \"$tls12_detected_version\" == 03* ]] && [[ 0x$tls12_detected_version -lt 0x$latest_supported ]]; then\n                    prln_svrty_critical \" -- server supports $latest_supported_string, but downgraded to $detected_version_string\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"not offered, and downgraded to $detected_version_string rather than $latest_supported_string\"\n               elif [[ \"$tls12_detected_version\" == 03* ]] && [[ 0x$tls12_detected_version -gt 0x0303 ]]; then\n                    prln_svrty_critical \" -- server responded with higher version number ($detected_version_string) than requested by client (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"not offered, server responded with higher version number ($detected_version_string) than requested by client\"\n               else\n                    if [[ ${#tls12_detected_version} -eq 4 ]]; then\n                         prln_svrty_critical \"server responded with version number ${tls12_detected_version:0:2}.${tls12_detected_version:2:2} (NOT ok)\"\n                         fileout \"$jsonID\" \"CRITICAL\" \"server responded with version number ${tls12_detected_version:0:2}.${tls12_detected_version:2:2}\"\n                    else\n                         prln_svrty_medium \" -- strange, server ${tls12_detected_version}\"\n                         fileout \"$jsonID\" \"MEDIUM\" \"strange, server ${tls12_detected_version}\"\n                    fi\n               fi\n               ;;\n          3)   out \"not offered, \"\n               fileout \"$jsonID\" \"INFO\" \"not offered\"\n               add_proto_offered tls1_2 no\n               set_grade_cap \"C\" \"TLS 1.2 is not offered\"\n               pr_warning \"TLS downgraded to STARTTLS plaintext\"; outln\n               fileout \"$jsonID\" \"WARN\" \"TLS downgraded to STARTTLS plaintext\"\n               ;;\n          4)   out \"likely \"; pr_svrty_medium \"not offered, \"\n               fileout \"$jsonID\" \"MEDIUM\" \"not offered\"\n               add_proto_offered tls1_2 no\n               set_grade_cap \"C\" \"TLS 1.2 is not offered\"\n               pr_warning \"received 4xx/5xx after STARTTLS handshake\"; outln \"$debug_recomm\"\n               fileout \"$jsonID\" \"WARN\" \"received 4xx/5xx after STARTTLS handshake${debug_recomm}\"\n               ;;\n          5)   outln \"$supported_no_ciph1\"                  # protocol detected, but no cipher --> comes from run_prototest_openssl\n               fileout \"$jsonID\" \"INFO\" \"$supported_no_ciph1\"\n               add_proto_offered tls1_2 yes\n               ;;\n          7)   if \"$using_sockets\" ; then\n                    # can only happen in debug mode\n                    pr_warning \"strange reply, maybe a client side problem with TLS 1.2\"; outln \"$debug_recomm\"\n               else\n                    prln_local_problem \"$OPENSSL doesn't support \\\"s_client -tls1_2\\\"\"\n                    fileout \"$jsonID\" \"WARN\" \"not tested due to lack of local support\"\n               fi\n               ((ret++))\n               ;;\n          *)   pr_fixme \"unexpected value around line $((LINENO))\"; outln \"$debug_recomm\"\n               ((ret++))\n               ;;\n     esac\n\n     pr_bold \" TLS 1.3    \";\n     jsonID=\"TLS1_3\"\n     case $ret_val_tls13 in\n          0)   if ! \"$using_sockets\"; then\n                    prln_svrty_best \"offered (OK)\"\n                    fileout \"$jsonID\" \"OK\" \"offered\"\n               else\n                    # If TLS 1.3 is offered, then its support was detected\n                    # by determine_optimal_sockets_params().\n                    if [[ $(has_server_protocol tls1_3_rfc8446) -eq 0 ]]; then\n                         drafts_offered+=\" 0304 \"\n                    else\n                         for i in 1C 1B 1A 19 18 17 16 15 14 13 12; do\n                              if [[ $(has_server_protocol tls1_3_draft$(hex2dec \"$i\")) -eq 0 ]]; then\n                                   drafts_offered+=\" 7F$i \"\n                                   break\n                              fi\n                         done\n                    fi\n                    KEY_SHARE_EXTN_NR=\"28\"\n                    while true; do\n                         supported_versions=\"\"\n                         for i in 16 15 14 13 12; do\n                              [[ \"$drafts_offered\" =~ \\ 7F$i\\  ]] || supported_versions+=\",7f,$i\"\n                         done\n                         [[ -z \"$supported_versions\" ]] && break\n                         supported_versions=\"00, 2b, 00, $(printf \"%02x\" $((${#supported_versions}/3+1))), $(printf \"%02x\" $((${#supported_versions}/3))) $supported_versions\"\n                         tls_sockets \"04\" \"$TLS13_CIPHER\" \"\" \"$supported_versions\"\n                         [[ $? -eq 0 ]] || break\n                         if [[ \"${TLS_SERVER_HELLO:8:3}\" == 7F1 ]]; then\n                              drafts_offered+=\" ${TLS_SERVER_HELLO:8:4} \"\n                         elif [[ \"$TLS_SERVER_HELLO\" =~ 002B00027F1[2-6] ]]; then\n                              drafts_offered+=\" ${BASH_REMATCH:8:4} \"\n                         fi\n                    done\n                    KEY_SHARE_EXTN_NR=\"33\"\n                    while true; do\n                         supported_versions=\"\"\n                         for i in 1C 1B 1A 19 18 17; do\n                              [[ \"$drafts_offered\" =~ \\ 7F$i\\  ]] || supported_versions+=\",7f,$i\"\n                         done\n                         [[ \"$drafts_offered\" =~ \\ 0304\\  ]] || supported_versions+=\",03,04\"\n                         [[ -z \"$supported_versions\" ]] && break\n                         supported_versions=\"00, 2b, 00, $(printf \"%02x\" $((${#supported_versions}/3+1))), $(printf \"%02x\" $((${#supported_versions}/3))) $supported_versions\"\n                         tls_sockets \"04\" \"$TLS13_CIPHER\" \"\" \"$supported_versions\"\n                         [[ $? -eq 0 ]] || break\n                         if [[ \"$TLS_SERVER_HELLO\" =~ 002B00020304 ]]; then\n                              drafts_offered+=\" 0304 \"\n                         elif [[ \"$TLS_SERVER_HELLO\" =~ 002B00027F1[7-9A-C] ]]; then\n                              drafts_offered+=\" ${BASH_REMATCH:8:4} \"\n                         fi\n                    done\n                    KEY_SHARE_EXTN_NR=\"$key_share_extn_nr\"\n                    if [[ -n \"$drafts_offered\" ]]; then\n                         for i in 1C 1B 1A 19 18 17 16 15 14 13 12; do\n                              if [[ \"$drafts_offered\" =~ \\ 7F$i\\  ]]; then\n                                   [[ -n \"$drafts_offered_str\" ]] && drafts_offered_str+=\", \"\n                                   drafts_offered_str+=\"draft $(printf \"%d\" 0x$i)\"\n                              fi\n                         done\n                         if [[ \"$drafts_offered\" =~ \\ 0304\\  ]]; then\n                              [[ -n \"$drafts_offered_str\" ]] && drafts_offered_str+=\", \"\n                              drafts_offered_str+=\"final\"\n                         fi\n                         if [[ \"$drafts_offered\" =~ \\ 0304\\  ]]; then\n                              pr_svrty_best \"offered (OK)\"; outln \": $drafts_offered_str\"\n                              fileout \"$jsonID\" \"OK\" \"offered with $drafts_offered_str\"\n                         else\n                              out \"offered (OK)\"; outln \": $drafts_offered_str\"\n                              fileout \"$jsonID\" \"INFO\" \"offered with $drafts_offered_str\"\n                         fi\n                    else\n                         pr_warning \"Unexpected results\"; outln \"$debug_recomm\"\n                         fileout \"$jsonID\" \"WARN\" \"unexpected results\"\n                    fi\n               fi\n               latest_supported=\"0304\"\n               latest_supported_string=\"TLSv1.3\"\n               add_proto_offered tls1_3 yes\n               ;;\n          1)   pr_svrty_low \"not offered\"\n               if [[ -z $latest_supported ]]; then\n                    outln\n                    fileout \"$jsonID\" \"LOW\" \"not offered\"\n               else\n                    prln_svrty_critical \" -- connection failed rather than downgrading to $latest_supported_string\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"connection failed rather than downgrading to $latest_supported_string\"\n               fi\n               add_proto_offered tls1_3 no\n               ;;\n          2)   if [[ \"$DETECTED_TLS_VERSION\" == 0300 ]]; then\n                    detected_version_string=\"SSLv3\"\n               elif [[ \"$DETECTED_TLS_VERSION\" == 03* ]]; then\n                    detected_version_string=\"TLSv1.$((0x$DETECTED_TLS_VERSION-0x0301))\"\n               fi\n               if [[ \"$DETECTED_TLS_VERSION\" == \"$latest_supported\" ]]; then\n                    outln \"not offered and downgraded to a weaker protocol\"\n                    fileout \"$jsonID\" \"INFO\" \"not offered + downgraded to weaker protocol\"\n               elif [[ \"$DETECTED_TLS_VERSION\" == 03* ]] && [[ 0x$DETECTED_TLS_VERSION -lt 0x$latest_supported ]]; then\n                    out \"not offered\"\n                    prln_svrty_critical \" -- server supports $latest_supported_string, but downgraded to $detected_version_string\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"not offered, and downgraded to $detected_version_string rather than $latest_supported_string\"\n               elif [[ \"$DETECTED_TLS_VERSION\" == 03* ]] && [[ 0x$DETECTED_TLS_VERSION -gt 0x0304 ]]; then\n                    out \"not offered\"\n                    prln_svrty_critical \" -- server responded with higher version number ($detected_version_string) than requested by client (NOT ok)\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"not offered, server responded with higher version number ($detected_version_string) than requested by client\"\n               else\n                    out \"not offered\"\n                    prln_svrty_critical \" -- server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2}\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"server responded with version number ${DETECTED_TLS_VERSION:0:2}.${DETECTED_TLS_VERSION:2:2}\"\n               fi\n               add_proto_offered tls1_3 no\n               ;;\n          3)   out \"not offered  \"\n               fileout \"$jsonID\" \"INFO\" \"not offered\"\n               add_proto_offered tls1_3 no\n               pr_warning \"TLS downgraded to STARTTLS plaintext\"; outln\n               fileout \"$jsonID\" \"WARN\" \"TLS downgraded to STARTTLS plaintext\"\n               ;;\n          4)   out \"likely not offered, \"              # STARTTLS problem\n               fileout \"$jsonID\" \"INFO\" \"likely not offered\"\n               add_proto_offered tls1_3 no\n               pr_warning \"received 4xx/5xx after STARTTLS handshake\"; outln \"$debug_recomm\"\n               fileout \"$jsonID\" \"WARN\" \"received 4xx/5xx after STARTTLS handshake${debug_recomm}\"\n               ;;\n          5)   outln \"$supported_no_ciph1\"             # protocol detected but no cipher --> comes from run_prototest_openssl\n               fileout \"$jsonID\" \"INFO\" \"$supported_no_ciph1\"\n               add_proto_offered tls1_3 yes\n               ;;\n          7)   if \"$using_sockets\" ; then\n                    # can only happen in debug mode\n                    prln_warning \"strange reply, maybe a client side problem with TLS 1.3\"; outln \"$debug_recomm\"\n               else\n                    prln_local_problem \"$OPENSSL doesn't support \\\"s_client -tls1_3\\\"\"\n                    fileout \"$jsonID\" \"WARN\" \"not tested due to lack of local support\"\n               fi\n               ((ret++))\n               ;;\n          *)   pr_fixme \"unexpected value around line $((LINENO))\"; outln \"$debug_recomm\"\n               ((ret++))\n               ;;\n     esac\n\n     debugme echo \"PROTOS_OFFERED: $PROTOS_OFFERED\"\n     if [[ ! \"$PROTOS_OFFERED\" =~ yes ]]; then\n          outln\n          ignore_no_or_lame \"You should not proceed as no protocol was detected. If you still really really want to, say \\\"YES\\\"\" \"YES\"\n          [[ $? -ne 0 ]] && exit $ERR_CLUELESS\n     fi\n\n     return $ret\n}\n\n\n# list ciphers (and makes sure you have them locally configured)\n# arg[1]: non-TLSv1.3 cipher list (or anything else)\n# arg[2]: TLSv1.3 cipher list\n# arg[3]: protocol (e.g., -ssl2)\n#\nlistciphers() {\n     local -i ret\n     local debugname=\"\"\n     local ciphers=\"$1\"\n     local tls13_ciphers=\"$TLS13_OSSL_CIPHERS\" cipher tls13_supported_ciphers=\"\"\n     local options=\"$3 \"\n\n     [[ \"$2\" != ALL ]] && tls13_ciphers=\"$2\"\n     for cipher in ${tls13_ciphers//:/ }; do\n          [[ \"$TLS13_OSSL_CIPHERS\" =~ $cipher ]] && tls13_supported_ciphers+=\":$cipher\"\n     done\n     tls13_ciphers=\"${tls13_supported_ciphers:1}\"\n     \n     \"$HAS_SECLEVEL\" && [[ -n \"$ciphers\" ]] && ciphers=\"@SECLEVEL=0:$1\"\n     ! \"$HAS_TLS1\" && options=\"${options//-tls1 /}\"\n     if \"$HAS_CIPHERSUITES\"; then\n          $OPENSSL ciphers $OSSL_CIPHERS_S $options -ciphersuites \"$tls13_ciphers\" \"$ciphers\" &>$TMPFILE\n     elif [[ -n \"$tls13_ciphers\" ]]; then\n          $OPENSSL ciphers $OSSL_CIPHERS_S $options \"$tls13_ciphers:$ciphers\" &>$TMPFILE\n     else\n          $OPENSSL ciphers $OSSL_CIPHERS_S $options \"$ciphers\" &>$TMPFILE\n     fi\n     ret=$?\n     debugme cat $TMPFILE\n     debugname=\"$(sed -e s'/\\!/not/g' -e 's/\\:/_/g' <<< \"$1\")\"\n     tmpfile_handle ${FUNCNAME[0]}.${debugname}.txt\n     return $ret\n}\n\n\n# argv[1]: non-TLSv1.3 cipher list to test in OpenSSL syntax\n# argv[2]: TLSv1.3 cipher list to test in OpenSSL syntax\n# argv[3]: string on console / HTML or \"finding\"\n# argv[4]: rating whether ok to offer\n# argv[5]: string to be appended for fileout\n# argv[6]: non-SSLv2 cipher list to test (hexcodes), if using sockets\n# argv[7]: SSLv2 cipher list to test (hexcodes), if using sockets\n# argv[8]: true if using sockets, false if not\n# argv[9]: CVE\n# argv[10]: CWE\n#\nsub_cipherlists() {\n     local -i i len sclient_success=1\n     local cipherlist sslv2_cipherlist detected_ssl2_ciphers\n     local singlespaces\n     local proto=\"\"\n     local -i ret=0\n     local jsonID=\"cipherlist\"\n     local using_sockets=\"${8}\"\n     local cve=\"${9}\"\n     local cwe=\"${10}\"\n\n     pr_bold \"$3  \"\n     [[ \"$OPTIMAL_PROTO\" == -ssl2 ]] && proto=\"$OPTIMAL_PROTO\"\n     jsonID=\"${jsonID}_$5\"\n\n     if \"$using_sockets\" || listciphers \"$1\" \"$2\" $proto; then\n          if ! \"$using_sockets\" || { \"$FAST\" && listciphers \"$1\" \"$2\" -tls1; }; then\n               for proto in -no_ssl2 -tls1_2 -tls1_1 -tls1 -ssl3; do\n                    if [[ \"$proto\" == -tls1_2 ]]; then\n                         # If $OPENSSL doesn't support TLSv1.3 or if no TLSv1.3\n                         # ciphers are being tested, then a TLSv1.2 ClientHello\n                         # was tested in the first iteration.\n                         ! \"$HAS_TLS13\" && continue\n                         [[ -z \"$2\" ]] && continue\n                    fi\n                    if [[ \"$proto\" != -no_ssl2 ]]; then\n                         sclient_supported \"$proto\" || continue\n                         \"$FAST\" && continue\n                         [[ $(has_server_protocol \"${proto:1}\") -eq 1 ]] && continue\n                    fi\n                    $OPENSSL s_client $(s_client_options \"-cipher \"$1\" -ciphersuites \"\\'$2\\'\" $BUGS $STARTTLS -connect $NODEIP:$PORT $PROXY $SNI $proto\") 2>$ERRFILE >$TMPFILE </dev/null\n                    sclient_connect_successful $? $TMPFILE\n                    sclient_success=$?\n                    debugme cat $ERRFILE\n                    [[ $sclient_success -eq 0 ]] && break\n               done\n          else\n               for proto in 04 03 02 01 00; do\n                    # If $cipherlist doesn't contain any TLSv1.3 ciphers, then there is\n                    # no reason to try a TLSv1.3 ClientHello.\n                    [[ \"$proto\" == 04 ]] && [[ ! \"$6\" =~ 13,0 ]] && [[ ! \"$6\" =~ [cC]0,[bB][45] ]] && continue\n                    [[ $(has_server_protocol \"$proto\") -eq 1 ]] && continue\n                    cipherlist=\"$(strip_inconsistent_ciphers \"$proto\" \", $6\")\"\n                    cipherlist=\"${cipherlist:2}\"\n                    if [[ -n \"$cipherlist\" ]] && [[ \"$cipherlist\" != 00,ff ]]; then\n                         tls_sockets \"$proto\" \"$cipherlist\"\n                         sclient_success=$?\n                         [[ $sclient_success -eq 2 ]] && sclient_success=0\n                         [[ $sclient_success -eq 0 ]] && break\n                    fi\n               done\n          fi\n          if [[ $sclient_success -ne 0 ]] && [[ 1 -ne $(has_server_protocol ssl2) ]]; then\n               if { [[ -z \"$7\" ]] || \"$FAST\"; } && \"$HAS_SSL2\" && listciphers \"$1\" \"\" -ssl2; then\n                    $OPENSSL s_client -cipher \"$1\" $BUGS $STARTTLS -connect $NODEIP:$PORT $PROXY -ssl2 2>$ERRFILE >$TMPFILE </dev/null\n                    sclient_connect_successful $? $TMPFILE\n                    sclient_success=$?\n                    debugme cat $ERRFILE\n               elif [[ -n \"$7\" ]]; then\n                    sslv2_sockets \"$7\" \"true\"\n                    if [[ $? -eq 3 ]] && [[ \"$V2_HELLO_CIPHERSPEC_LENGTH\" -ne 0 ]]; then\n                         sslv2_cipherlist=\"$(strip_spaces \"${7//,/}\")\"\n                         len=${#sslv2_cipherlist}\n                         detected_ssl2_ciphers=\"$(grep \"Supported cipher: \" \"$TEMPDIR/$NODEIP.parse_sslv2_serverhello.txt\")\"\n                         for (( i=0; i<len; i+=6 )); do\n                              [[ \"$detected_ssl2_ciphers\" =~ x${sslv2_cipherlist:i:6} ]] && sclient_success=0 && break\n                         done\n                    fi\n               fi\n          fi\n          if [[ $sclient_success -ne 0 ]] && $BAD_SERVER_HELLO_CIPHER; then\n               # If server failed with a known error, raise it to the user.\n               if [[ $STARTTLS_PROTOCOL == mysql ]]; then\n                    pr_warning \"SERVER_ERROR: test inconclusive due to MySQL Community Edition (yaSSL) bug.\"\n                    fileout \"$jsonID\" \"WARN\" \"SERVER_ERROR, test inconclusive due to MySQL Community Edition (yaSSL) bug.\" \"$cve\" \"$cwe\"\n               else\n                    pr_warning \"SERVER_ERROR: test inconclusive.\"\n                    fileout \"$jsonID\" \"WARN\" \"SERVER_ERROR, test inconclusive.\" \"$cve\" \"$cwe\"\n               fi\n               ((ret++))\n          else\n               # Otherwise the error means the server doesn't support that cipher list.\n               case $4 in\n                    7)   if [[ $sclient_success -eq 0 ]]; then\n                              # Strong is excellent to offer\n                              pr_svrty_best \"offered (OK)\"\n                              fileout \"$jsonID\" \"OK\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              pr_svrty_medium \"not offered\"\n                              fileout \"$jsonID\" \"MEDIUM\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    6)   if [[ $sclient_success -eq 0 ]]; then\n                              # High is good to offer\n                              pr_svrty_good \"offered (OK)\"\n                              fileout \"$jsonID\" \"OK\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              # FIXME: we don't penalize the absence of high, but perhaps\n                              # we should if there is also no strong encryption (next)\n                              out \"not offered\"\n                              fileout \"$jsonID\" \"INFO\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    5)   if [[ $sclient_success -eq 0 ]]; then\n                              # Neither good nor bad to offer\n                              out \"offered (OK)\"\n                              fileout \"$jsonID\" \"INFO\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              out \"not offered\"\n                              fileout \"$jsonID\" \"INFO\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    4)   if [[ $sclient_success -eq 0 ]]; then\n                              # medium is not that bad\n                              pr_svrty_low \"offered\"\n                              fileout \"$jsonID\" \"LOW\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              out \"not offered\"\n                              fileout \"$jsonID\" \"INFO\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    3)   if [[ $sclient_success -eq 0 ]]; then\n                              pr_svrty_medium \"offered\"\n                              fileout \"$jsonID\" \"MEDIUM\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              out \"not offered\"\n                              fileout \"$jsonID\" \"INFO\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    2)   if [[ $sclient_success -eq 0 ]]; then\n                              # bad but there is worse\n                              pr_svrty_high \"offered (NOT ok)\"\n                              fileout \"$jsonID\" \"HIGH\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              # need a check for -eq 1 here\n                              pr_svrty_good \"not offered (OK)\"\n                              fileout \"$jsonID\" \"OK\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    1)   if [[ $sclient_success -eq 0 ]]; then\n                              # the ugly ones\n                              pr_svrty_critical \"offered (NOT ok)\"\n                              fileout \"$jsonID\" \"CRITICAL\" \"offered\" \"$cve\" \"$cwe\"\n                         else\n                              pr_svrty_best \"not offered (OK)\"\n                              fileout \"$jsonID\" \"OK\" \"not offered\" \"$cve\" \"$cwe\"\n                         fi\n                         ;;\n                    *)   # we shouldn't reach this\n                         pr_warning \"?: $4 (please report this)\"\n                         fileout \"$jsonID\" \"WARN\" \"return condition $4 unclear\" \"$cve\" \"$cwe\"\n                         ((ret++))\n                         ;;\n               esac\n\n               # Not a perfect place here. A new one should be picked in the future\n               [[ $sclient_success -eq 0 && \"$1\" =~ (^|:)EXPORT(:|$) ]] && set_grade_cap \"F\" \"Export suite offered\"\n               [[ $sclient_success -eq 0 && \"$1\" =~ AEAD ]] && set_grade_cap \"B\" \"No AEAD ciphers offered\"\n          fi\n          tmpfile_handle ${FUNCNAME[0]}.${5}.txt\n          [[ $DEBUG -ge 1 ]] && tm_out \" -- $1\"\n          outln\n     else\n          singlespaces=$(sed -e 's/ \\+/ /g' -e 's/^ //' -e 's/ $//g' -e 's/  //g' <<< \"$3\")\n          if [[ \"$OPTIMAL_PROTO\" == -ssl2 ]]; then\n               prln_local_problem \"No $singlespaces for SSLv2 configured in $OPENSSL\"\n          else\n               prln_local_problem \"No $singlespaces configured in $OPENSSL\"\n          fi\n          fileout \"$jsonID\" \"WARN\" \"Cipher $3 ($1) not supported by local OpenSSL ($OPENSSL)\"\n     fi\n     return $ret\n}\n\n#TODO: work with fixed lists here --> atm ok, as sockets are preferred. If there would be a single function for testing: yes.\nrun_cipherlists() {\n     local hexc hexcode strength\n     local -i i\n     local -i ret=0\n     local ossl_null_ciphers ossl_null_ciphersuites null_ciphers sslv2_null_ciphers\n     local ossl_anon_ciphers anon_ciphers sslv2_anon_ciphers\n     local ossl_exp_ciphers exp_ciphers sslv2_exp_ciphers\n     local ossl_low_ciphers low_ciphers sslv2_low_ciphers\n     local ossl_tdes_ciphers tdes_ciphers sslv2_tdes_ciphers\n     local ossl_obsoleted_ciphers obsoleted_ciphers\n     local ossl_good_ciphers good_ciphers\n     local ossl_strong_ciphers ossl_strong_ciphersuites strong_ciphers\n     local cwe=\"CWE-327\"\n     local cwe2=\"CWE-310\"\n     local cve=\"\"\n     local using_sockets=true\n\n     outln\n     pr_headlineln \" Testing cipher categories \"\n     outln\n     \"$SSL_NATIVE\" && using_sockets=false\n\n     # conversion 2 byte ciphers via:  echo \"$@\" | sed -e 's/[[:xdigit:]]\\{2\\},/0x&/g'  -e 's/, /\\n/g' | while read ci; do grep -wi $ci etc/cipher-mapping.txt; done\n\n     ossl_null_ciphers='NULL:eNULL'\n     ossl_null_ciphersuites=\"TLS_SHA256_SHA256:TLS_SHA384_SHA384\"\n     null_ciphers=\"c0,10, c0,06, c0,15, c0,0b, c0,01, c0,3b, c0,3a, c0,39, 00,b9, 00,b8, 00,b5, 00,b4, 00,2e, 00,2d, 00,b1, 00,b0, 00,2c, 00,3b, 00,02, 00,01, 00,82, 00,83, c0,b4, c0,b5, ff,87, 00,ff\"\n     sslv2_null_ciphers=\"FF,80,10, 00,00,00\"\n\n     ossl_anon_ciphers='aNULL:ADH'\n     anon_ciphers=\"c0,19, 00,a7, 00,6d, 00,3a, 00,c5, 00,89, c0,47, c0,5b, c0,85, c0,18, 00,a6, 00,6c, 00,34, 00,bf, 00,9b, 00,46, c0,46, c0,5a, c0,84, c0,16, 00,18, c0,17, 00,1b, 00,1a, 00,19, 00,17, c0,15, 00,ff\"\n     sslv2_anon_ciphers=\"FF,80,10\"\n\n     ossl_exp_ciphers='EXPORT:!ADH:!NULL'\n     # grep -i EXP etc/cipher-mapping.txt\n     exp_ciphers=\"00,63, 00,62, 00,61, 00,65, 00,64, 00,60, 00,14, 00,11, 00,19, 00,08, 00,06, 00,27, 00,26, 00,2a, 00,29, 00,0b, 00,0e, 00,17, 00,03, 00,28, 00,2b, 00,ff\"\n     sslv2_exp_ciphers=\"04,00,80, 02,00,80, 00,00,00\"\n\n     ossl_low_ciphers='LOW:DES:RC2:RC4:MD5:!ADH:!EXP:!NULL:!eNULL:!AECDH'\n     # grep -Ew '64|56|RC2|RC4|MD5' etc/cipher-mapping.txt | grep -Ev 'Au=None|export'\n     low_ciphers=\"00,04, 00,05, 00,09, 00,0C, 00,0F, 00,12, 00,15, 00,1E, 00,20, 00,22, 00, 23, 00,24, 00,25, 00,66, 00,8A, 00,8E, 00,92, C0,02, C0,07, C0,0C, C0,11, C0,33, FF,00, FE,FE, FF,E1, 00,FF\"\n     sslv2_low_ciphers=\"01,00,80, 03,00,80, 05,00,80, 06,00,40, 06,01,40, 07,00,c0, 08,00,80, FF,80,00\"\n\n     ossl_tdes_ciphers='3DES:IDEA:!aNULL:!ADH:!MD5'\n     # grep -Ew '3DES|IDEA' etc/cipher-mapping.txt | grep -Ev \"Au=None|MD5\"\n     tdes_ciphers=\"00,07, 00,0A, 00,0D, 00,10, 00,13, 00,16, 00,1F, 00,21, 00,8B, 00,8F, 00,93, C0,03, C0,08, C0,0D, C0,12, C0,1A, C0,1B, C0,1C, C0,34, FE,FF, FF,E0, 00,FF\"\n     sslv2_tdes_ciphers=\"07,01,c0\"\n\n     # # Now all AES, CAMELLIA, ARIA and SEED CBC ciphers plus GOST\n     ossl_obsoleted_ciphers='HIGH:MEDIUM:AES:CAMELLIA:ARIA:!IDEA:!CHACHA20:!3DES:!RC2:!RC4:!AESCCM8:!AESCCM:!AESGCM:!ARIAGCM:!aNULL:!MD5'\n     # grep -Ew \"256|128\" etc/cipher-mapping.txt | grep -Ev \"Au=None|AEAD|RC2|RC4|IDEA|MD5\"\n     obsoleted_ciphers=\"00,2F, 00,30, 00,31, 00,32, 00,33, 00,35, 00,36, 00,37, 00,38, 00,39, 00,3C, 00,3D, 00,3E, 00,3F, 00,40, 00,41, 00,42, 00,43, 00,44, 00,45, 00,67, 00,68, 00,69, 00,6A, 00,6B, 00,84, 00,85, 00,86, 00,87, 00,88, 00,8C, 00,8D, 00,90, 00,91, 00,94, 00,95, 00,96, 00,97, 00,98, 00,99, 00,9A, 00,AE, 00,AF, 00,B2, 00,B3, 00,B6, 00,B7, 00,BA, 00,BB, 00,BC, 00,BD, 00,BE, 00,C0, 00,C1, 00,C2, 00,C3, 00,C4, C0,04, C0,05, C0,09, C0,0A, C0,0E, C0,0F, C0,13, C0,14, C0,1D, C0,1E, C0,1F, C0,20, C0,21, C0,22, C0,23, C0,24, C0,25, C0,26, C0,27, C0,28, C0,29, C0,2A, C0,35, C0,36, C0,37, C0,38, C0,3C, C0,3D, C0,3E, C0,3F, C0,40, C0,41, C0,42, C0,43, C0,44, C0,45, C0,48, C0,49, C0,4A, C0,4B, C0,4C, C0,4D, C0,4E, C0,4F, C0,64, C0,65, C0,66, C0,67, C0,68, C0,69, C0,70, C0,71, C0,72, C0,73, C0,74, C0,75, C0,76, C0,77, C0,78, C0,79, C0,94, C0,95, C0,96, C0,97, C0,98, C0,99, C0,9A, C0,9B\"\n     # Workaround: If we use sockets and in order not to hit 131+1 ciphers we omit the GOST ciphers if SERVER_SIZE_LIMIT_BUG is true.\n     # This won't be supported by Cisco ACE anyway.\n     \"$SERVER_SIZE_LIMIT_BUG\" || obsoleted_ciphers=\"${obsoleted_ciphers}, 00,80, 00,81, FF,01, FF,02, FF,03, FF,85\"\n     obsoleted_ciphers=\"${obsoleted_ciphers}, 00,FF\"\n\n     ossl_good_ciphers='AESGCM:CHACHA20:CamelliaGCM:AESCCM:ARIAGCM:!kEECDH:!kEDH:!kDHE:!kDHEPSK:!kECDHEPSK:!aNULL'\n     # grep AEAD etc/cipher-mapping.txt | grep -Ev 'Au=None|TLS_ECDHE|TLS_DHE|TLS_PSK_DHE|TLSv1.3'\n     good_ciphers=\"00,9C, 00,9D, 00,A0, 00,A1, 00,A4, 00,A5, 00,A8, 00,A9, 00,AC, 00,AD, C0,2D, C0,2E, C0,31, C0,32, C0,50, C0,51, C0,54, C0,55, C0,58, C0,59, C0,5E, C0,5F, C0,62, C0,63, C0,6A, C0,6B, C0,6E, C0,6F, C0,7A, C0,7B, C0,7E, C0,7F, C0,82, C0,83, C0,88, C0,89, C0,8C, C0,8D, C0,8E, C0,8F, C0,92, C0,93, C0,9C, C0,9D, C0,A0, C0,A1, C0,A4, C0,A5, C0,A8, C0,A9, CC,AB, CC,AE, 00,FF\"\n\n     ossl_strong_ciphers='AESGCM:CHACHA20:CamelliaGCM:AESCCM:ARIAGCM:!kPSK:!kRSAPSK:!kRSA:!kDH:!kECDH:!aNULL'\n     ossl_strong_ciphersuites=\"TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_CCM_SHA256:TLS_AES_128_CCM_8_SHA256\"\n     # grep AEAD etc/cipher-mapping.txt | grep -E 'TLS_ECDHE|TLS_DHE|TLS_PSK_DHE|TLSv1.3'\n     strong_ciphers=\"00,9E, 00,9F, 00,A2, 00,A3, 00,AA, 00,AB, 13,01, 13,02, 13,03, 13,04, 13,05, 16,B7, 16,B8, 16,B9, 16,BA, C0,2B, C0,2C, C0,2F, C0,30, C0,52, C0,53, C0,56, C0,57, C0,5C, C0,5D, C0,60, C0,61, C0,6C, C0,6D, C0,7C, C0,7D, C0,80, C0,81, C0,86, C0,87, C0,8A, C0,8B, C0,90, C0,91, C0,9E, C0,9F, C0,A2, C0,A3, C0,A6, C0,A7, C0,AA, C0,AB, C0,AC, C0,AD, C0,AE, C0,AF, CC,13, CC,14, CC,15, CC,A8, CC,A9, CC,AA, CC,AC, CC,AD, 00,FF\"\n\n     # argv[1]: non-TLSv1.3 cipher list to test in OpenSSL syntax\n     # argv[2]: TLSv1.3 cipher list to test in OpenSSL syntax\n     # argv[3]: string on console / HTML or \"finding\"\n     # argv[4]: rating whether ok to offer\n     # argv[5]: string to be appended for fileout\n     # argv[6]: non-SSLv2 cipher list to test (hexcodes), if using sockets\n     # argv[7]: SSLv2 cipher list to test (hexcodes), if using sockets\n     # argv[8]: true if using sockets, false if not\n     # argv[9]: CVE\n     # argv[10]: CWE\n\n     sub_cipherlists \"$ossl_null_ciphers\"      \"$ossl_null_ciphersuites\" \" NULL ciphers (no encryption)                    \"     1 \"NULL\"      \"$null_ciphers\"    \"$sslv2_null_ciphers\"   \"$using_sockets\" \"$cve\" \"$cwe\"\n     ret=$?\n     sub_cipherlists \"$ossl_anon_ciphers\"      \"\" \" Anonymous NULL Ciphers (no authentication)      \"     1 \"aNULL\"     \"$anon_ciphers\"    \"$sslv2_anon_ciphers\"   \"$using_sockets\" \"$cve\" \"$cwe\"\n     ret=$((ret + $?))\n     sub_cipherlists \"$ossl_exp_ciphers\"       \"\" \" Export ciphers (w/o ADH+NULL)                   \"     1 \"EXPORT\"    \"$exp_ciphers\"     \"$sslv2_exp_ciphers\"    \"$using_sockets\" \"$cve\" \"$cwe\"\n     ret=$((ret + $?))\n     sub_cipherlists \"$ossl_low_ciphers\"       \"\" \" LOW: 64 Bit + DES, RC[2,4], MD5 (w/o export)    \"     2 \"LOW\"       \"$low_ciphers\"     \"$sslv2_low_ciphers\"    \"$using_sockets\" \"$cve\" \"$cwe\"\n     ret=$((ret + $?))\n     sub_cipherlists \"$ossl_tdes_ciphers\"      \"\" \" Triple DES Ciphers / IDEA                       \"     3 \"3DES_IDEA\" \"$tdes_ciphers\"    \"$sslv2_tdes_ciphers\"   \"$using_sockets\" \"$cve\" \"$cwe2\"\n     ret=$((ret + $?))\n     sub_cipherlists \"$ossl_obsoleted_ciphers\" \"\" \" Obsoleted CBC ciphers (AES, ARIA etc.)          \"     4 \"OBSOLETED\"   \"$obsoleted_ciphers\"  \"\"                   \"$using_sockets\" \"$cve\" \"$cwe2\"\n     ret=$((ret + $?))\n     sub_cipherlists \"$ossl_good_ciphers\"      \"\" \" Strong encryption (AEAD ciphers) with no FS     \"     6 \"STRONG_NOFS\"      \"$good_ciphers\"     \"\"                     \"$using_sockets\" \"\"      \"\"\n     ret=$((ret + $?))\n     sub_cipherlists \"$ossl_strong_ciphers\" \"$ossl_strong_ciphersuites\" \" Forward Secrecy strong encryption (AEAD ciphers)\"    7 \"STRONG_FS\"     \"$strong_ciphers\"   \"\"                     \"$using_sockets\" \"\"      \"\"\n     ret=$((ret + $?))\n\n     outln\n     return $ret\n}\n\npr_sigalg_quality() {\n     local sigalg=\"$1\"\n\n     if [[ \"$sigalg\" =~ MD5 ]]; then\n          pr_svrty_high \"$sigalg\"\n     elif [[ \"$sigalg\" =~ SHA1 ]]; then\n          pr_svrty_low \"$sigalg\"\n     else\n          out \"$sigalg\"\n     fi\n}\n\n\n# The return value is an indicator of the quality of the DH key length in $1:\n#   1 = pr_svrty_critical, 2 = pr_svrty_high, 3 = pr_svrty_medium, 4 = pr_svrty_low\n#   5 = neither good nor bad, 6 = pr_svrty_good, 7 = pr_svrty_best\npr_dh_quality() {\n     local bits=\"$1\"\n     local string=\"$2\"\n\n     if [[ \"$bits\" -le 600 ]]; then\n          pr_svrty_critical \"$string\"\n          return 1\n     elif [[ \"$bits\" -le 800 ]]; then\n          pr_svrty_high \"$string\"\n          return 2\n     elif [[ \"$bits\" -le 1280 ]]; then\n          pr_svrty_medium \"$string\"\n          return 3\n     elif [[ \"$bits\" -ge 2048 ]]; then\n          pr_svrty_good \"$string\"\n          return 6\n     else\n          out \"$string\"\n          return 5\n     fi\n}\n\n# prints out dh group=prime and in round brackets DH bits and labels it accordingly\n# arg1: name of dh group, arg2=bit length\npr_dh() {\n     local -i quality=0\n\n     pr_italic \"$1\"\n     out \" (\"\n     pr_dh_quality \"$2\" \"$2 bits\"\n     quality=$?\n     out \")\"\n     return $quality\n}\n\npr_ecdh_quality() {\n     local bits=\"$1\"\n     local string=\"$2\"\n\n     if [[ \"$bits\" -le 80 ]]; then      # has that ever existed?\n          pr_svrty_critical \"$string\"\n     elif [[ \"$bits\" -le 108 ]]; then   # has that ever existed?\n          pr_svrty_high \"$string\"\n     elif [[ \"$bits\" -le 163 ]]; then\n          pr_svrty_medium \"$string\"\n     elif [[ \"$bits\" -le 193 ]]; then   # hmm, according to https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography it should ok\n          pr_svrty_low \"$string\"        # but openssl removed it https://github.com/testssl/testssl.sh/issues/299#issuecomment-220905416\n     elif [[ \"$bits\" -le 224 ]]; then\n          out \"$string\"\n     elif [[ \"$bits\" -gt 224 ]]; then\n          pr_svrty_good \"$string\"\n     else\n          out \"$string\"\n     fi\n}\n\npr_ecdh_curve_quality() {\n     curve=\"$1\"\n     local -i bits=0\n\n     case \"$curve\" in\n          \"sect163k1\") bits=163  ;;\n          \"sect163r1\") bits=162  ;;\n          \"sect163r2\") bits=163  ;;\n          \"sect193r1\") bits=193  ;;\n          \"sect193r2\") bits=193  ;;\n          \"sect233k1\") bits=232  ;;\n          \"sect233r1\") bits=233  ;;\n          \"sect239k1\") bits=238  ;;\n          \"sect283k1\") bits=281  ;;\n          \"sect283r1\") bits=282  ;;\n          \"sect409k1\") bits=407 ;;\n          \"sect409r1\") bits=409  ;;\n          \"sect571k1\") bits=570  ;;\n          \"sect571r1\") bits=570  ;;\n          \"secp160k1\") bits=161  ;;\n          \"secp160r1\") bits=161  ;;\n          \"secp160r2\") bits=161  ;;\n          \"secp192k1\") bits=192  ;;\n          \"prime192v1\") bits=192  ;;\n          \"secp224k1\") bits=225  ;;\n          \"secp224r1\") bits=224  ;;\n          \"secp256k1\") bits=256  ;;\n          \"prime256v1\") bits=256  ;;\n          \"secp384r1\") bits=384  ;;\n          \"secp521r1\") bits=521  ;;\n          \"brainpoolP256r1\"*) bits=256  ;;\n          \"brainpoolP384r1\"*) bits=384  ;;\n          \"brainpoolP512r1\"*) bits=512  ;;\n          \"X25519\") bits=253  ;;\n          \"X448\") bits=448  ;;\n     esac\n     pr_ecdh_quality \"$bits\" \"$curve\"\n}\n\n# Return a value that is an indicator of the quality of the cipher in $1:\n#   0 = $1 is empty\n#   1 = pr_svrty_critical, 2 = pr_svrty_high, 3 = pr_svrty_medium, 4 = pr_svrty_low\n#   5 = neither good nor bad, 6 = pr_svrty_good, 7 = pr_svrty_best\n#\n# Please note this section isn't particular spot on. It needs to be reconsidered/redone\n# SHA1, SSLv3 ciphers are some points which need to be considered.\n# Hint: find out by \"grep <pattern> etc/cipher-mapping.txt\" but it' might be be easier\n# to look out Enc= and Au= or Mac=\n#\nget_cipher_quality() {\n     local cipher=\"$1\"\n     local ossl_cipher\n\n     [[ -z \"$1\" ]] && return 0\n\n     if [[ \"$cipher\" != TLS_* ]] && [[ \"$cipher\" != SSL_* ]]; then\n          # This must be the OpenSSL name for a cipher or for TLS 1.3 ($TLS13_OSSL_CIPHERS)\n          # We can ignore them however as the OpenSSL and RFC names currently match\n          if [[ $TLS_NR_CIPHERS -eq 0 ]]; then\n               # We have an OpenSSL name and can't convert it to the RFC name which is rarely\n               # the case, see \"prepare_arrays()\" and \"./etc/cipher-mapping.txt\"\n               case \"$cipher\" in\n                    *NULL*|EXP*|ADH*|AECDH*|*anon*|TLS_SHA*)\n                         return 1\n                         ;;\n                    *RC4*|*RC2*|*MD5|*M1)\n                         return 2\n                         ;;\n                    AES256-GCM-SHA384|AES128-GCM-SHA256|AES256-CCM*|AES128-CCM*|ARIA256-GCM-SHA384|ARIA128-GCM-SHA256)\n                         # RSA kx and e.g. GCM isn't certainly the best\n                         return 6\n                         ;;\n                    *CBC3*|*3DES*|*IDEA*)\n                         return 3\n                         ;;\n                    *DES*)\n                         return 2\n                         ;;\n                    PSK-*GCM*|PSK-*CCM*|RSA-PSK-*GCM*|RSA-PSK-CHACHA20-POLY1305|PSK-CHACHA20-POLY1305)\n                         # PSK kx and e.g. GCM isn't certainly the best\n                         return 6\n                         ;;\n                    DH-*GCM*|ECDH-*GCM*)\n                         # static DH or ECDH kx and GCM isn't certainly the best\n                         return 6\n                         ;;\n                    *GCM*|*CCM*|*CHACHA20*)\n                         return 7\n                         ;; #best ones\n                    *AES*SHA*|*CAMELLIA*SHA*|*SEED*SHA*|*CBC*|*GOST*)\n                         return 4\n                         ;;\n                    *)\n                         return 5\n                         ;;\n               esac\n          fi\n          ossl_cipher=\"$cipher\"\n          cipher=\"$(openssl2rfc \"$cipher\")\"\n          [[ -z \"$cipher\" ]] && cipher=\"$ossl_cipher\"\n     fi\n\n     # Now we look at the RFC cipher names. The sequence matters - as above.\n     case \"$cipher\" in\n          *NULL*|*EXP*|*_DES40_*|*anon*|TLS_SHA*)\n               return 1\n               ;;\n          *RC4*|*RC2*|*MD5|*MD5_1)\n               return 2\n               ;;\n          *_DES_*)\n               if [[ \"$cipher\" =~ EDE3 ]]; then\n                    return 3\n               fi\n               return 2\n               ;;\n          *CBC3*|*3DES*|*IDEA*)\n               return 3\n               ;;\n          *CBC*|*GOST*)\n               return 4\n               ;;\n          TLS_RSA_*|TLS_DH_*|TLS_ECDH_*|TLS_PSK_WITH_*)\n               # RSA, or static DH, ECDH, or PSK kx and e.g. GCM isn't certainly the best\n               return 6\n               ;;\n          *GCM*|*CCM*|*CHACHA20*)\n               return 7\n               ;;\n          *)\n               return 5\n               ;;\n     esac\n}\n\n# Output the severity level associated with the cipher in $1.\nget_cipher_quality_severity() {\n     local cipher=\"$1\"\n     local -i quality\n\n     [[ -z \"$1\" ]] && return 0\n\n     get_cipher_quality \"$cipher\"\n     quality=$?\n     case $quality in\n          1) tm_out \"CRITICAL\" ;;\n          2) tm_out \"HIGH\" ;;\n          3) tm_out \"MEDIUM\" ;;\n          4) tm_out \"LOW\" ;;\n          5) tm_out \"INFO\" ;;\n          6|7) tm_out \"OK\" ;;\n     esac\n     return $quality\n}\n\n# Print $2 based on the quality of the cipher in $1. If $2 is empty, just print $1.\n# The return value is an indicator of the quality of the cipher in $1:\n#   0 = $1 is empty\n#   1 = pr_svrty_critical, 2 = pr_svrty_high, 3 = pr_svrty_medium, 4 = pr_svrty_low\n#   5 = neither good nor bad, 6 = pr_svrty_good, 7 = pr_svrty_best\n#\npr_cipher_quality() {\n     local cipher=\"$1\"\n     local text=\"$2\"\n     local -i quality\n\n     [[ -z \"$1\" ]] && return 0\n     [[ -z \"$text\" ]] && text=\"$cipher\"\n\n     get_cipher_quality \"$cipher\"\n     quality=$?\n     case $quality in\n          1) pr_svrty_critical \"$text\" ;;\n          2) pr_svrty_high \"$text\" ;;\n          3) pr_svrty_medium \"$text\" ;;\n          4) pr_svrty_low \"$text\" ;;\n          5) out \"$text\" ;;\n          6) pr_svrty_good \"$text\" ;;\n          7) pr_svrty_best \"$text\" ;;\n     esac\n     return $quality\n}\n\n# arg1: file with input for grepping the type of ephemeral DH key (DH ECDH)\nread_dhtype_from_file() {\n     local temp kx\n\n     temp=$(awk -F': ' '/^Server Temp Key/ { print $2 }' \"$1\")        # extract line\n     kx=\"Kx=${temp%%,*}\"\n     [[ \"$kx\" == \"Kx=X25519\" ]] && kx=\"Kx=ECDH\"\n     [[ \"$kx\" == \"Kx=X448\" ]] && kx=\"Kx=ECDH\"\n     tm_out \"$kx\"\n     return 0\n}\n\n# arg1: certificate file\nread_sigalg_from_file() {\n     local sig_alg\n\n     sig_alg=\"$(strip_leading_space \"$($OPENSSL x509 -noout -text -in \"$1\" 2>/dev/null | awk -F':' '/Signature Algorithm/ { print $2; exit; }')\")\"\n     case \"$sig_alg\" in\n          1.3.101.112|ED25519) tm_out \"Ed25519\" ;;\n          1.3.101.113|ED448)   tm_out \"Ed448\" ;;\n          *)                   tm_out \"$sig_alg\" ;;\n     esac\n\n}\n\n\n# arg1: file with input for grepping the bit length for ECDH/DHE\n# arg2: whether to print warning \"old fart\" or not (empty: no)\nread_dhbits_from_file() {\n     local bits what_dh temp curve=\"\"\n     local add=\"\"\n     local old_fart=\" (your $OPENSSL cannot show DH bits)\"\n\n     temp=$(awk -F': ' '/^Server Temp Key/ { print $2 }' \"$1\")        # extract line\n     what_dh=\"${temp%%,*}\"\n     bits=\"${temp##*, }\"\n     curve=\"${temp#*, }\"\n     if [[ \"$curve\" == \"$bits\" ]]; then\n          curve=\"\"\n     else\n          curve=\"${curve%%,*}\"\n     fi\n     bits=\"${bits/bits/}\"\n     bits=\"${bits// /}\"\n\n     if [[ \"$what_dh\" == X25519 ]] || [[ \"$what_dh\" == X448 ]]; then\n          curve=\"$what_dh\"\n          what_dh=\"ECDH\"\n     fi\n     if [[ -z \"$2\" ]]; then\n          if [[ -n \"$curve\" ]]; then\n               debugme echo \">$HAS_DH_BITS|$what_dh($curve)|$bits<\"\n          else\n               debugme echo \">$HAS_DH_BITS|$what_dh|$bits<\"\n          fi\n     fi\n     [[ -n \"$what_dh\" ]] && HAS_DH_BITS=true                            # FIX 190\n     if [[ -z \"$what_dh\" ]] && ! \"$HAS_DH_BITS\"; then\n          if [[ \"$2\" == \"string\" ]]; then\n               tm_out \"$old_fart\"\n          elif [[ -z \"$2\" ]]; then\n               pr_warning \"$old_fart\"\n          fi\n          return 0\n     fi\n     if [[ \"$2\" == quiet ]]; then\n          tm_out \"$bits\"\n          return 0\n     fi\n     [[ -z \"$2\" ]] && [[ -n \"$bits\" ]] && out \", \"\n     if [[ $what_dh == DH ]] || [[ $what_dh == EDH ]]; then\n          add=\"bit DH\"\n          [[ -n \"$curve\" ]] && add+=\" ($curve)\"\n          if [[ \"$2\" == string ]]; then\n               tm_out \", $bits $add\"\n          else\n               pr_dh_quality \"$bits\" \"$bits $add\"\n          fi\n     # https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography, https://www.keylength.com/en/compare/\n     elif [[ $what_dh == ECDH ]]; then\n          add=\"bit ECDH\"\n          [[ -n \"$curve\" ]] && add+=\" ($curve)\"\n          if [[ \"$2\" == string ]]; then\n               tm_out \", $bits $add\"\n          else\n               pr_ecdh_quality \"$bits\" \"$bits $add\"\n          fi\n     fi\n     return 0\n}\n\n\n# arg1: ID or empty. If empty resumption by ticket will be tested, otherwise by ID\n# return: 0: it has resumption, 1:nope, 2: nope (OpenSSL 1.1.1),  6: CLIENT_AUTH --> problem for resumption, 7: can't tell\n#\n# This is basically a short(?) version from Bulletproof SSL and TLS (p386). The version according to that would be e.g.\n#     echo | $OPENSSL s_client -connect testssl.sh:443 -servername testssl.sh -no_ssl2            -reconnect 2>&1 | grep -E 'New|Reused'\n#     echo | $OPENSSL s_client -connect testssl.sh:443 -servername testssl.sh -no_ssl2 -no_ticket -reconnect 2>&1 | grep -E 'New|Reused|Session-ID'\n#\n# FIXME: actually Ivan's version seems faster. Worth to check and since when -reconnect is a/v\n#\nsub_session_resumption() {\n     local ret ret1 ret2\n     local tmpfile=$(mktemp $TEMPDIR/session_resumption.$NODEIP.XXXXXX)\n     local sess_data=$(mktemp $TEMPDIR/sub_session_data_resumption.$NODEIP.XXXXXX)\n     local -a rw_line\n     local protocol=\"$1\"\n\n     if [[ \"$2\" == ID ]]; then\n          local byID=true\n          local addcmd=\"-no_ticket\"\n     else\n          local byID=false\n          local addcmd=\"\"\n          if ! \"$TLS_TICKETS\"; then\n               return 1\n          fi\n     fi\n     # Return 6 if client authentication is required and none PEM file (containing client certificate+private key) is provided\n     [[ \"$CLIENT_AUTH\" == required ]] && [[ -z \"$MTLS\" ]] && return 6\n     if ! \"$HAS_TLS13\" && \"$HAS_NO_SSL2\"; then\n          addcmd+=\" -no_ssl2\"\n     else\n          protocol=${protocol/\\./_}\n          protocol=${protocol/v/}\n          protocol=\"-$(tolower $protocol)\"\n          # In some cases a server will not support session tickets, but will support session resumption\n          # by ID. In such a case, it may be more likely to support session resumption with TLSv1.2 than\n          # with TLSv1.3. So, if testing a server that does not support session tickets and that supports\n          # both TLSv1.3 and TLSv1.2 for session resumption by ID, then use a TLSv1.2 ClientHello. (Note that\n          # the line below assumes that if $protocol is -tls1_3, then the server either supports TLSv1.2 or\n          # is TLSv1.3-only.\n          ! \"$TLS_TICKETS\" && \"$byID\" && [[ $(has_server_protocol \"tls1_2\") -eq 0 ]] && protocol=\"-tls1_2\"\n          addcmd+=\" $protocol\"\n     fi\n\n     $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI $addcmd -sess_out $sess_data\") </dev/null &>$tmpfile\n     ret1=$?\n     if [[ $ret1 -ne 0 ]]; then\n          # MacOS and LibreSSL return 1 here, that's why we need to check whether the handshake contains e.g. a certificate\n          if [[ ! $(<$tmpfile) =~ -----.*\\ CERTIFICATE----- ]]; then\n               debugme echo -n \"Couldn't connect #1  \"\n               return 7\n          fi\n     fi\n     if \"$byID\" && [[ ! \"$OSSL_NAME\" =~ LibreSSL ]] && \\\n        [[ $OSSL_VER_MAJOR.$OSSL_VER_MINOR == 1.1.1* || $OSSL_VER_MAJOR == 3 ]] && \\\n        [[ ! -s \"$sess_data\" ]]; then\n          # it seems OpenSSL indicates no Session ID resumption by just not generating output\n          debugme echo -n \"No session resumption byID (empty file)\"\n          # If we want to check the presence of session data:\n          # [[ ! $(<$sess_data) =~ -----.*\\ SSL\\ SESSION\\ PARAMETERS----- ]]\n          ret=2\n     else\n          $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI $addcmd -sess_in $sess_data\") </dev/null >$tmpfile 2>$ERRFILE\n          ret2=$?\n          if [[ $DEBUG -ge 2 ]]; then\n               echo -n \"$ret1, $ret2, \"\n               [[ -s \"$sess_data\" ]] && echo \"not empty\" || echo \"empty\"\n          fi\n          if [[ $ret2 -ne 0 ]]; then\n               if [[ ! $(<$tmpfile) =~ -----.*\\ CERTIFICATE----- ]]; then\n                    debugme echo -n \"Couldn't connect #2  \"\n                    return 7\n               fi\n          fi\n          # \"Reused\" indicates session material was reused, \"New\": not\n          if grep -aq \"^Reused\" \"$tmpfile\"; then\n               new_sid=false\n          elif grep -aq \"^New\" \"$tmpfile\"; then\n               new_sid=true\n          else\n               debugme echo -n \"Problem with 2nd ServerHello  \"\n          fi\n          # Now get the line and compare the numbers \"read\" and \"written\" as a second criteria.\n          # If the \"read\" number is bigger: a new session ID was probably used.\n          rw_line=\"$(awk '/^SSL handshake has read/ { print $5\" \"$(NF-1) }' \"$tmpfile\" )\"\n          rw_line=($rw_line)\n          if [[ \"${rw_line[0]}\" -gt \"${rw_line[1]}\" ]]; then\n               new_sid2=true\n          else\n               new_sid2=false\n          fi\n          debugme echo \"${rw_line[0]}, ${rw_line[1]}\"\n\n          if \"$new_sid2\" && \"$new_sid\"; then\n               debugme echo -n \"No session resumption \"\n               ret=1\n          elif ! \"$new_sid2\" && ! \"$new_sid\"; then\n               debugme echo -n \"Session resumption \"\n               ret=0\n          else\n               debugme echo -n \"unclear status: $ret1, $ret2, $new_sid, $new_sid2  -- \"\n               ret=5\n          fi\n          if [[ $DEBUG -ge 2 ]]; then\n               \"$byID\" && echo \"byID\" || echo \"by ticket\"\n          fi\n     fi\n     \"$byID\" && \\\n          tmpfile_handle ${FUNCNAME[0]}.byID.log $tmpfile || \\\n          tmpfile_handle ${FUNCNAME[0]}.byticket.log $tmpfile\n     return $ret\n}\n\nrun_server_preference() {\n     local cipher1=\"\" cipher2=\"\" tls13_cipher1=\"\" tls13_cipher2=\"\" default_proto=\"\"\n     local default_cipher=\"\" ciph\n     local limitedsense=\"\" supported_sslv2_ciphers\n     local proto_ossl proto_txt proto_hex cipherlist i\n     local -i ret=0 j sclient_success\n     local list_fwd=\"DHE-RSA-SEED-SHA:SEED-SHA:DES-CBC3-SHA:RC4-MD5:DES-CBC-SHA:RC4-SHA:AES128-SHA:AES128-SHA256:AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:ECDH-RSA-DES-CBC3-SHA:ECDH-RSA-AES128-SHA:ECDH-RSA-AES256-SHA:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:DHE-DSS-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:AES256-SHA256:ECDHE-RSA-DES-CBC3-SHA:ECDHE-RSA-AES128-SHA256:AES256-GCM-SHA384:AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-SHA256:ADH-AES256-GCM-SHA384:AECDH-AES128-SHA:ECDHE-RSA-RC4-SHA:ECDHE-ECDSA-AES128-SHA\"\n     local list_reverse=\"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-RC4-SHA:AECDH-AES128-SHA:ADH-AES256-GCM-SHA384:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-GCM-SHA256:AES128-GCM-SHA256:AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-DES-CBC3-SHA:AES256-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-DSS-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDH-RSA-AES256-SHA:ECDH-RSA-AES128-SHA:ECDH-RSA-DES-CBC3-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-AES128-SHA:AES256-SHA:AES128-SHA256:AES128-SHA:RC4-SHA:DES-CBC-SHA:RC4-MD5:DES-CBC3-SHA:SEED-SHA:DHE-RSA-SEED-SHA\"\n     tls_list_fwd=\"c0,2c, c0,30, 00,9f, cc,a9, cc,a8, cc,aa, c0,2b, c0,2f, 00,9e, c0,24, c0,28, 00,6b, c0,23, c0,27, 00,67, c0,0a, 00,04, 00,05, 00,09, 00,0a, 00,9a, 00,96,\n                   c0,14, 00,39, c0,09, c0,13, 00,33, 00,9d, 00,9c, 13,01, 13,02, 13,03, 13,04, 13,05, 00,3d, 00,3c, 00,35, 00,2f, 00,ff\"\n     tls_list_rev=\"00,2f, 00,35, 00,3c, 00,3d, 13,05, 13,04, 13,03, 13,02, 13,01, 00,9c, 00,9d, 00,33, c0,13, c0,09, 00,39, c0,14, 00,96, 00,9a, 00,0a, 00,09, 00,05, 00,04,\n                   c0,0a, 00,67, c0,27, c0,23, 00,6b, c0,28, c0,24, 00,9e, c0,2f, c0,2b, cc,aa, cc,a8, cc,a9, 00,9f, c0,30, c0,2c, 00,ff\"\n     local has_cipher_order=false has_tls13_cipher_order=false\n     local addcmd=\"\" addcmd2=\"\"\n     local using_sockets=true\n     local jsonID=\"cipher_order\" fileout_msg=\"\" fileout_rating=\"\" terminal_msg=\"\"\n     local cwe=\"CWE-310\"\n     local cve=\"\"\n\n     \"$SSL_NATIVE\" && using_sockets=false\n\n     outln\n     pr_headlineln \" Testing server's cipher preferences \"\n     outln\n\n     if [[ \"$OPTIMAL_PROTO\" == -ssl2 ]]; then\n          addcmd=\"$OPTIMAL_PROTO\"\n     else\n          # the supplied openssl will send an SSLv2 ClientHello if $SNI is empty\n          # and the -no_ssl2 isn't provided.\n          addcmd=\"-no_ssl2 $SNI\"\n     fi\n\n     # Determine negotiated protocol upfront\n     sclient_success=1\n     if \"$using_sockets\" && [[ $(has_server_protocol \"tls1_3\") -ne 1 ]]; then\n          # Send similar list of cipher suites as OpenSSL 1.1.1 does\n          tls_sockets \"04\" \\\n                      \"c0,2c, c0,30, 00,9f, cc,a9, cc,a8, cc,aa, c0,2b, c0,2f, 00,9a, 00,96,\n                       00,9e, c0,24, c0,28, 00,6b, c0,23, c0,27, 00,67, c0,0a,\n                       c0,14, 00,39, c0,09, c0,13, 00,33, 00,9d, 00,9c, 13,02,\n                       13,03, 13,01, 13,04, 13,05, c0,b4, c0,b5, 00,3d, 00,3c, 00,35, 00,2f, 00,ff\" \\\n                      \"ephemeralkey\"\n          sclient_success=$?\n          if [[ $sclient_success -eq 0 ]]; then\n               add_proto_offered tls1_3 yes\n          elif [[ $sclient_success -eq 2 ]]; then\n               sclient_success=0           # 2: downgraded\n               case $DETECTED_TLS_VERSION in\n                    0303) add_proto_offered tls1_2 yes ;;\n                    0302) add_proto_offered tls1_1 yes ;;\n                    0301) add_proto_offered tls1 yes ;;\n                    0300) add_proto_offered ssl3 yes ;;\n               esac\n          fi\n          if [[ $sclient_success -eq 0 ]] ; then\n               cp \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\"\n               cipher0=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\")\n          fi\n     fi\n     if [[ $sclient_success -ne 0 ]]; then\n          $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $addcmd\") </dev/null 2>>$ERRFILE >\"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\"\n          if sclient_connect_successful $? \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\"; then\n               cipher0=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\")\n               debugme tm_out \"0 --> $cipher0\\n\"\n          else\n               # 2 second try with $OPTIMAL_PROTO especially for intolerant IIS6 servers:\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $OPTIMAL_PROTO $BUGS -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>>$ERRFILE >\"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\"\n               if sclient_connect_successful $? \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\"; then\n                    cipher0=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\")\n                    debugme tm_out \"0 --> $cipher0\\n\"\n               else\n                    pr_warning \"Handshake error!\"\n                    ret=1\n               fi\n          fi\n     fi\n     [[ $ret -eq 0 ]] && default_proto=$(get_protocol \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\")\n     [[ \"$default_proto\" == TLSv1.0 ]] && default_proto=\"TLSv1\"\n     # debugme tm_out \" --> $default_proto\\n\"\n\n     # Some servers don't have a TLS 1.3 cipher order, see #1163\n     if [[ \"$default_proto\" == TLSv1.3 ]]; then\n          tls_sockets \"04\" \"c0,b5, c0,b4, 13,05, 13,04, 13,03, 13,02, 13,01, 00,ff\"\n          [[ $? -ne 0 ]] && ret=1 && prln_fixme \"something weird happened around line $((LINENO - 1))\"\n          cp \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" $TMPFILE\n          tls13_cipher1=$(get_cipher $TMPFILE)\n          debugme tm_out \"TLS 1.3: --> $tls13_cipher1\\n\"\n          tls_sockets \"04\" \"13,01, 13,02, 13,03, 13,04, 13,05, c0,b4, c0,b5, 00,ff\"\n          [[ $? -ne 0 ]] && ret=1 && prln_fixme \"something weird happened around line $((LINENO - 1))\"\n          cp \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" $TMPFILE\n          tls13_cipher2=$(get_cipher $TMPFILE)\n          debugme tm_out \"TLS 1.3: --> $tls13_cipher2\\n\"\n\n          [[ $tls13_cipher1 == $tls13_cipher2 ]] && has_tls13_cipher_order=true\n     fi\n     # Check whether the server has a cipher order for SSLv3 - TLSv1.2\n     if [[ $(has_server_protocol \"tls1_2\") -ne 0 ]] && [[ $(has_server_protocol \"tls1_1\") -ne 0 ]] && \\\n        [[ $(has_server_protocol \"tls1\") -ne 0 ]] && [[ $(has_server_protocol \"ssl3\") -ne 0 ]]; then\n          # Based on testing performed by determine_optimal_sockets_params(), it is believed that\n          # this server does not offer SSLv3 - TLSv1.2.\n          has_cipher_order=\"$has_tls13_cipher_order\"\n     elif [[ \"$OPTIMAL_PROTO\" != -ssl2 ]]; then\n          if [[ -n \"$STARTTLS_OPTIMAL_PROTO\" ]]; then\n               [[ ! \"$STARTTLS_OPTIMAL_PROTO\" =~ ssl ]] && addcmd2=\"$SNI\"\n               [[ \"$STARTTLS_OPTIMAL_PROTO\" != -tls1_3 ]] && addcmd2+=\" $STARTTLS_OPTIMAL_PROTO\"\n          else\n               addcmd2=\"-no_ssl2 $SNI\"\n          fi\n          [[ $DEBUG -ge 4 ]] && echo -e \"\\n Forward: ${list_fwd}\"\n          $OPENSSL s_client $(s_client_options \"$STARTTLS -cipher $list_fwd $BUGS -connect $NODEIP:$PORT $PROXY $addcmd2\") </dev/null 2>$ERRFILE >$TMPFILE\n          if ! sclient_connect_successful $? $TMPFILE; then\n               list_fwd=\"$(actually_supported_osslciphers $list_fwd '' '-no_ssl2')\"\n               pr_warning \"no matching cipher in this list found (pls report this): \"\n               outln \"$list_fwd  . \"\n               fileout \"$jsonID\" \"WARN\" \"Could not determine server cipher order, no matching cipher in list found (pls report this): $list_fwd\"\n               ret=1\n               # we assume the problem is with testing here but it could be also the server side\n          else\n               cipher1=$(get_cipher $TMPFILE)               # cipher1 from 1st serverhello\n               debugme tm_out \"1 --> $cipher1\\n\"\n\n               # second client hello with reverse list\n               [[ $DEBUG -ge 4 ]] && echo -e \"\\n Reverse: ${list_reverse}\"\n               $OPENSSL s_client $(s_client_options \"$STARTTLS -cipher $list_reverse $BUGS -connect $NODEIP:$PORT $PROXY $addcmd2\") </dev/null 2>>$ERRFILE >$TMPFILE\n               # first handshake worked above so no error handling here\n               cipher2=$(get_cipher $TMPFILE)               # cipher2 from 2nd serverhello\n               debugme tm_out \"2 --> $cipher2\\n\"\n\n               [[ $cipher1 == $cipher2 ]] && has_cipher_order=true\n          fi\n     fi\n     debugme echo \"has_cipher_order: $has_cipher_order\"\n     debugme echo \"has_tls13_cipher_order: $has_tls13_cipher_order\"\n\n     # restore file from above\n     [[ \"$default_proto\" == TLSv1.3 ]] && cp \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\" $TMPFILE\n     if [[ \"$default_proto\" == TLSv1.3 ]] || [[ -n \"$cipher2\" ]]; then\n          cipher1=$(get_cipher $TMPFILE)\n          tmpfile_handle ${FUNCNAME[0]}.txt\n     fi\n\n     # Sanity check: Handshake with no ciphers and one with forward list didn't overlap\n     if [[ $ret -eq 0 ]] && [[ \"$cipher0\" != $cipher1 ]]; then\n          limitedsense=\" (matching cipher in list missing)\"\n     fi\n\n     if [[ -n \"$cipher1\" ]]; then\n          ciph=\"$cipher1\"\n     else\n          ciph=\"$cipher0\"\n          cp \"$TEMPDIR/$NODEIP.parse_tls13_serverhello.txt\" $TMPFILE\n          tmpfile_handle ${FUNCNAME[0]}.txt\n     fi\n     if [[ \"$DISPLAY_CIPHERNAMES\" =~ openssl ]] && [[ \"$ciph\" == TLS_* || \"$ciph\" == SSL_* ]]; then\n          default_cipher=\"$(rfc2openssl \"$ciph\")\"\n     elif [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]] && [[ \"$ciph\" != TLS_* ]] && [[ \"$ciph\" != SSL_* ]]; then\n          default_cipher=\"$(openssl2rfc \"$ciph\")\"\n     fi\n     [[ -z \"$default_cipher\" ]] && default_cipher=\"$ciph\"\n\n     \"$FAST\" && using_sockets=false\n     [[ $TLS_NR_CIPHERS == 0 ]] && using_sockets=false\n\n     neat_header\n     while read proto_ossl proto_hex proto_txt; do\n          pr_underline \"$(printf -- \"%b\" \"$proto_txt\")\"\n          if [[ $(has_server_protocol \"$proto_ossl\") -eq 1 ]]; then\n               outln \"\\n - \"\n               continue\n          fi\n          # TODO: Also the fact that a protocol is not supported seems not to be saved by cipher_pref_check()\n          # (./testssl.sh --wide -p -P -E  vs ./testssl.sh --wide -P -E )\n          if [[ $proto_ossl == ssl2 ]] || \\\n                    { [[ $proto_ossl != tls1_3 ]] && ! \"$has_cipher_order\"; } || \\\n                    { [[ $proto_ossl == tls1_3 ]] && ! \"$has_tls13_cipher_order\"; }; then\n               if [[ -n \"$cipher2\" ]] && [[ $proto_ossl != ssl2 ]]; then\n                    ciphers_by_strength \"-$proto_ossl\" \"$proto_hex\" \"$proto_txt\" \"$using_sockets\" \"true\" \"true\"\n               else\n                    ciphers_by_strength \"-$proto_ossl\" \"$proto_hex\" \"$proto_txt\" \"$using_sockets\" \"true\" \"false\"\n               fi\n          else\n               cipher_pref_check \"$proto_ossl\" \"$proto_hex\" \"$proto_txt\" \"$using_sockets\" \"true\"\n          fi\n     done <<< \"$(tm_out \" ssl2 22 SSLv2\\n ssl3 00 SSLv3\\n tls1 01 TLSv1\\n tls1_1 02 TLSv1.1\\n tls1_2 03 TLSv1.2\\n tls1_3 04 TLSv1.3\\n\")\"\n     outln\n\n     pr_bold \" Has server cipher order?     \"\n     jsonID=\"cipher_order\"\n     case $NO_CIPHER_ORDER_LEVEL in\n          5) fileout_rating=\"INFO\" ;;\n          4) fileout_rating=\"LOW\" ;;\n          3) fileout_rating=\"MEDIUM\" ;;\n          2) fileout_rating=\"HIGH\" ;;\n          1) fileout_rating=\"CRITICAL\" ;;\n     esac\n     if \"$TLS13_ONLY\" && ! \"$has_tls13_cipher_order\"; then\n          terminal_msg=\"no (TLS 1.3 only)\"\n          limitedsense=\" (limited sense as client will pick)\"\n          fileout_msg=\"not a cipher order for TLS 1.3 configured\"\n     elif ! \"$TLS13_ONLY\" && [[ -z \"$cipher2\" ]]; then\n          pr_warning \"unable to determine\"\n     elif ! \"$has_cipher_order\" && ! \"$has_tls13_cipher_order\"; then\n          # server used the different ends (ciphers) from the client hello\n          terminal_msg=\"no (NOT ok)\"\n          [[ \"$fileout_rating\" == INFO ]] && terminal_msg=\"no\"\n          limitedsense=\" (limited sense as client will pick)\"\n          fileout_msg=\"NOT a cipher order configured\"\n     elif \"$has_cipher_order\" && ! \"$has_tls13_cipher_order\" && [[ \"$default_proto\" == TLSv1.3 ]]; then\n          if [[ $NO_CIPHER_ORDER_LEVEL -eq 5 ]]; then\n               pr_svrty_good \"yes (OK)\"; out \" -- only for < TLS 1.3\"\n               fileout \"$jsonID\" \"OK\" \"server -- TLS 1.3 client determined\"\n          else\n               # The server does not enforce a cipher order for TLS 1.3 and it\n               # accepts some lower quality TLS 1.3 ciphers.\n               terminal_msg=\"only for < TLS 1.3\"\n               fileout_msg=\"server -- TLS 1.3 client determined\"\n          fi\n     elif ! \"$has_cipher_order\" && \"$has_tls13_cipher_order\"; then\n          case \"$fileout_rating\" in\n               \"INFO\")\n                    out \"only for TLS 1.3\"\n                    fileout \"$jsonID\" \"INFO\" \"server -- < TLS 1.3 client determined\"\n                    ;;\n               \"LOW\")\n                    pr_svrty_low \"no (NOT ok)\"; out \" -- only for TLS 1.3\"\n                    fileout \"$jsonID\" \"LOW\" \"server -- < TLS 1.3 client determined\"\n                    ;;\n               \"MEDIUM\")\n                    pr_svrty_medium \"no (NOT ok)\"; out \" -- only for TLS 1.3\"\n                    fileout \"$jsonID\" \"MEDIUM\" \"server -- < TLS 1.3 client determined\"\n                    ;;\n               \"HIGH\")\n                    pr_svrty_high \"no (NOT ok)\"; out \" -- only for TLS 1.3\"\n                    fileout \"$jsonID\" \"HIGH\" \"server -- < TLS 1.3 client determined\"\n                    ;;\n               \"CRITICAL\")\n                    pr_svrty_critical \"no (NOT ok)\"; out \" -- only for TLS 1.3\"\n                    fileout \"$jsonID\" \"CRITICAL\" \"server -- < TLS 1.3 client determined\"\n                    ;;\n          esac\n     else\n          if \"$has_tls13_cipher_order\"; then\n               if \"$TLS13_ONLY\"; then\n                    out \"yes (TLS 1.3 only)\"\n                    fileout \"$jsonID\" \"INFO\" \"server (TLS 1.3)\"\n               else\n                    pr_svrty_best \"yes (OK)\"\n                    out \" -- TLS 1.3 and below\"\n                    fileout \"$jsonID\" \"OK\" \"server\"\n               fi\n          else\n               # we don't have TLS 1.3 at all\n               pr_svrty_best \"yes (OK)\"\n               fileout \"$jsonID\" \"OK\" \"server\"\n          fi\n     fi\n     if [[ -n \"$fileout_msg\" ]]; then\n          case \"$fileout_rating\" in\n               \"INFO\") out \"$terminal_msg\" ;;\n               \"OK\") pr_svrty_good \"$terminal_msg\" ;;\n               \"LOW\") pr_svrty_low \"$terminal_msg\" ;;\n               \"MEDIUM\") pr_svrty_medium \"$terminal_msg\" ;;\n               \"HIGH\") pr_svrty_high \"$terminal_msg\" ;;\n               \"CRITICAL\") pr_svrty_critical \"$terminal_msg\" ;;\n          esac\n          fileout \"$jsonID\" \"$fileout_rating\" \"$fileout_msg\"\n     fi\n     outln\n\n     if [[ \"$cipher0\" != $cipher1 ]]; then\n          pr_warning \" -- inconclusive test, matching cipher in list missing\"\n          outln \", better see above\"\n          #FIXME: This is ugly but the best we can do before rewrite this section\n     else\n          outln \"$limitedsense\"\n     fi\n     return $ret\n     # end of run_server_preference()\n}\n\n# arg1: true if the list that is returned does not need to be ordered by preference.\ncheck_tls12_pref() {\n     local unordered_list_ok=\"$1\"\n     local chacha20_ciphers=\"\" non_chacha20_ciphers=\"\"\n     local batchremoved=\"-CAMELLIA:-IDEA:-KRB5:-PSK:-SRP:-aNULL:-eNULL\"\n     local batchremoved_success=false\n     local tested_cipher=\"\" cipher ciphers_to_test\n     local order=\"\"\n     local -i nr_ciphers_found_r1=0 nr_ciphers_found_r2=0\n\n     # Place ChaCha20 ciphers at the end of the list to avoid accidentally\n     # triggering the server's PrioritizeChaCha setting.\n     ciphers_to_test=\"$(actually_supported_osslciphers \"ALL:$batchremoved\" \"\" \"\")\"\n     for cipher in $(colon_to_spaces \"$ciphers_to_test\"); do\n          [[ \"$cipher\" =~ CHACHA20 ]] && chacha20_ciphers+=\"$cipher:\" || non_chacha20_ciphers+=\"$cipher:\"\n     done\n     ciphers_to_test=\"$non_chacha20_ciphers$chacha20_ciphers\"\n     ciphers_to_test=\"${ciphers_to_test%:}\"\n\n     while true; do\n          $OPENSSL s_client $(s_client_options \"$STARTTLS -tls1_2 $BUGS -cipher \"$ciphers_to_test$tested_cipher\" -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>>$ERRFILE >$TMPFILE\n          if sclient_connect_successful $? $TMPFILE ; then\n               cipher=$(get_cipher $TMPFILE)\n               order+=\" $cipher\"\n               tested_cipher=\"$tested_cipher:-$cipher\"\n               nr_ciphers_found_r1+=1\n               \"$FAST\" && break\n          else\n               debugme tmln_out \"A: $tested_cipher\"\n               break\n          fi\n     done\n     batchremoved=\"${batchremoved//-/}\"\n     while true; do\n          # no ciphers from \"ALL$tested_cipher:$batchremoved\" left\n          # now we check $batchremoved, and remove the minus signs first:\n          $OPENSSL s_client $(s_client_options \"$STARTTLS -tls1_2 $BUGS -cipher \"$batchremoved\" -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>>$ERRFILE >$TMPFILE\n          if sclient_connect_successful $? $TMPFILE ; then\n               batchremoved_success=true               # signals that we have some of those ciphers and need to put everything together later on\n               cipher=$(get_cipher $TMPFILE)\n               order+=\" $cipher\"\n               batchremoved=\"$batchremoved:-$cipher\"\n               nr_ciphers_found_r1+=1\n               debugme tmln_out \"B1: $batchremoved\"\n               \"$FAST\" && break\n          else\n               debugme tmln_out \"B2: $batchremoved\"\n               break\n               # nothing left with batchremoved ciphers, we need to put everything together\n          fi\n     done\n\n     if \"$batchremoved_success\" && ! \"$unordered_list_ok\"; then\n          # now we combine the two cipher sets from both while loops\n\n          # Place ChaCha20 ciphers at the end of the list to avoid accidentally\n          # triggering the server's PrioritizeChaCha setting.\n          chacha20_ciphers=\"\"; non_chacha20_ciphers=\"\"\n          for cipher in $order; do\n               [[ \"$cipher\" =~ CHACHA20 ]] && chacha20_ciphers+=\"$cipher \" || non_chacha20_ciphers+=\"$cipher \"\n          done\n          combined_ciphers=\"$non_chacha20_ciphers$chacha20_ciphers\"\n          order=\"\" ; tested_cipher=\"\"\n          while true; do\n               ciphers_to_test=\"\"\n               for cipher in $combined_ciphers; do\n                    [[ ! \"$tested_cipher:\" =~ :-$cipher: ]] && ciphers_to_test+=\":$cipher\"\n               done\n               [[ -z \"$ciphers_to_test\" ]] && break\n               $OPENSSL s_client $(s_client_options \"$STARTTLS -tls1_2 $BUGS -cipher \"${ciphers_to_test:1}\" -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>>$ERRFILE >$TMPFILE\n               if sclient_connect_successful $? $TMPFILE ; then\n                    cipher=$(get_cipher $TMPFILE)\n                    order+=\" $cipher\"\n                    tested_cipher=\"$tested_cipher:-$cipher\"\n                    nr_ciphers_found_r2+=1\n                    \"$FAST\" && break\n               else\n                    # This shouldn't happen.\n                    break\n               fi\n          done\n          if \"$FAST\" && [[ $nr_ciphers_found_r2 -ne 1 ]]; then\n               prln_fixme \"something weird happened around line $((LINENO - 14))\"\n               return 1\n          elif ! \"$FAST\" && [[ $nr_ciphers_found_r2 -ne $nr_ciphers_found_r1 ]]; then\n               prln_fixme \"something weird happened around line $((LINENO - 16))\"\n               return 1\n          fi\n     fi\n     tm_out \"$order\"\n\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return 0\n}\n\n# At the moment only called from run_server_preference()\ncipher_pref_check() {\n     local proto=\"$1\" proto_hex=\"$2\" proto_text=\"$3\"\n     local using_sockets=\"$4\"\n     local wide=\"$5\"          # at the moment always = true\n     local tested_cipher cipher order=\"\" rfc_cipher rfc_order\n     local -i i nr_ciphers nr_nonossl_ciphers num_bundles bundle_size bundle end_of_bundle success\n     local -i nr_ciphers_found\n     local hexc ciphers_to_test cipher_list=\"\" chacha20_ciphers non_chacha20_ciphers\n     local first_cipher first_chacha_cipher\n     local -a normalized_hexcode ciph kx enc export2 sigalg\n     local -a rfc_ciph hexcode ciphers_found ciphers_found2\n     local -a -i index\n     local ciphers_found_with_sockets=false prioritize_chacha=false\n\n     if ! \"$using_sockets\" && ! sclient_supported \"-$proto\"; then\n          outln\n          prln_local_problem \"$OPENSSL doesn't support \\\"s_client -$proto\\\"\";\n          return 0\n     fi\n\n     if sclient_supported \"-$proto\"; then\n          if [[ $proto == tls1_2 ]] && \"$SERVER_SIZE_LIMIT_BUG\" && \\\n             [[ \"$(count_ciphers \"$(actually_supported_osslciphers \"ALL:COMPLEMENTOFALL\" \"\" \"\")\")\" -gt 127 ]]; then\n               order=\"$(check_tls12_pref \"$wide\")\"\n               [[ \"${order:0:1}\" == \\  ]] && order=\"${order:1}\"\n               cipher_list=\"$order\"\n          fi\n          if \"$wide\" || [[ -z \"$order\" ]]; then\n               # Place ChaCha20 ciphers at the end of the list to avoid accidentally\n               # triggering the server's PrioritizeChaCha setting.\n               chacha20_ciphers=\"\"; non_chacha20_ciphers=\"\"\n               if [[ $proto == tls1_3 ]]; then\n                    cipher_list=\"$(colon_to_spaces \"$TLS13_OSSL_CIPHERS\")\"\n               elif [[ -z \"$cipher_list\" ]]; then\n                    cipher_list=\"$(colon_to_spaces \"$(actually_supported_osslciphers \"ALL:COMPLEMENTOFALL\" \"\" \"\")\")\"\n               fi\n               for cipher in $cipher_list; do\n                    [[ \"$cipher\" =~ CHACHA20 ]] && chacha20_ciphers+=\"$cipher \" || non_chacha20_ciphers+=\"$cipher \"\n               done\n               cipher_list=\"$non_chacha20_ciphers $chacha20_ciphers\"\n\n               tested_cipher=\"\"; order=\"\"; nr_ciphers_found=0\n               while true; do\n                    ciphers_to_test=\"\"\n                    for cipher in $cipher_list; do\n                         [[ ! \"$tested_cipher:\" =~ :-$cipher: ]] && ciphers_to_test+=\":$cipher\"\n                    done\n                    [[ -z \"$ciphers_to_test\" ]] && break\n                    if [[ $proto != tls1_3 ]]; then\n                         ciphers_to_test=\"-cipher ${ciphers_to_test:1}\"\n                    else\n                         ciphers_to_test=\"-ciphersuites ${ciphers_to_test:1}\"\n                    fi\n                    $OPENSSL s_client $(s_client_options \"$STARTTLS -\"$proto\" $BUGS $ciphers_to_test -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>>$ERRFILE >$TMPFILE\n                    sclient_connect_successful $? $TMPFILE || break\n                    cipher=$(get_cipher $TMPFILE)\n                    [[ -z \"$cipher\" ]] && break\n                    order+=\"$cipher \"\n                    tested_cipher+=\":-\"$cipher\n                    \"$FAST\" && break\n                    if \"$wide\"; then\n                         for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n                              [[ \"$cipher\" == ${TLS_CIPHER_OSSL_NAME[i]} ]] && break\n                         done\n                         [[ $i -eq $TLS_NR_CIPHERS ]] && continue\n                         normalized_hexcode[nr_ciphers_found]=\"$(normalize_ciphercode \"${TLS_CIPHER_HEXCODE[i]}\")\"\n                         ciph[nr_ciphers_found]=\"${TLS_CIPHER_OSSL_NAME[i]}\"\n                         kx[nr_ciphers_found]=\"${TLS_CIPHER_KX[i]}\"\n                         [[ $proto == tls1_3 ]] && kx[nr_ciphers_found]=\"$(read_dhtype_from_file $TMPFILE)\"\n                         if [[ ${kx[nr_ciphers_found]} == Kx=ECDH ]] || [[ ${kx[nr_ciphers_found]} == Kx=DH ]] || [[ ${kx[nr_ciphers_found]} == Kx=EDH ]]; then\n                              kx[nr_ciphers_found]+=\" $(read_dhbits_from_file \"$TMPFILE\" quiet)\"\n                         fi\n                         enc[nr_ciphers_found]=\"${TLS_CIPHER_ENC[i]}\"\n                         export2[nr_ciphers_found]=\"${TLS_CIPHER_EXPORT[i]}\"\n                         sigalg[nr_ciphers_found]=\"\"\n                         \"$SHOW_SIGALGO\" && grep -qe '-----BEGIN CERTIFICATE-----' $TMPFILE && \\\n                              sigalg[nr_ciphers_found]=\"$(read_sigalg_from_file \"$TMPFILE\")\"\n                         nr_ciphers_found+=1\n                    fi\n               done\n          fi\n     fi\n\n     nr_nonossl_ciphers=0\n     if \"$using_sockets\"; then\n          for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n               ciphers_found[i]=false\n               hexc=\"${TLS_CIPHER_HEXCODE[i]}\"\n               if [[ ${#hexc} -eq 9 ]]; then\n                    if [[ \" $order \" =~ \\ ${TLS_CIPHER_OSSL_NAME[i]}\\  ]]; then\n                         ciphers_found[i]=true\n                    else\n                         ciphers_found2[nr_nonossl_ciphers]=false\n                         hexcode[nr_nonossl_ciphers]=\"${hexc:2:2},${hexc:7:2}\"\n                         rfc_ciph[nr_nonossl_ciphers]=\"${TLS_CIPHER_RFC_NAME[i]}\"\n                         index[nr_nonossl_ciphers]=$i\n                         # Only test ciphers that are relevant to the protocol.\n                         if [[ $proto == tls1_3 ]]; then\n                              [[ \"${TLS_CIPHER_SSLVERS[i]}\" == TLSv1.3 ]] && nr_nonossl_ciphers+=1\n                         elif [[ $proto == tls1_2 ]]; then\n                              [[ \"${TLS_CIPHER_SSLVERS[i]}\" != TLSv1.3 ]] && nr_nonossl_ciphers+=1\n                         elif [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA256 ]] && \\\n                              [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA384 ]] && \\\n                              [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM ]] && \\\n                              [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM_8 ]]; then\n                              nr_nonossl_ciphers+=1\n                         fi\n                    fi\n               fi\n          done\n     fi\n\n     if [[ $nr_nonossl_ciphers -eq 0 ]]; then\n          num_bundles=0\n     elif [[ $proto != tls1_2 ]] || ! \"$SERVER_SIZE_LIMIT_BUG\"; then\n          num_bundles=1\n          bundle_size=$nr_nonossl_ciphers\n     else\n          num_bundles=$nr_nonossl_ciphers/128\n          [[ $((nr_nonossl_ciphers%128)) -ne 0 ]] && num_bundles+=1\n\n          bundle_size=$nr_nonossl_ciphers/$num_bundles\n          [[ $((nr_nonossl_ciphers%num_bundles)) -ne 0 ]] && bundle_size+=1\n     fi\n\n     for (( bundle=0; bundle < num_bundles; bundle++ )); do\n          end_of_bundle=$(( (bundle+1)*bundle_size ))\n          [[ $end_of_bundle -gt $nr_nonossl_ciphers ]] && end_of_bundle=$nr_nonossl_ciphers\n          while true; do\n               ciphers_to_test=\"\"\n               for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                    ! \"${ciphers_found2[i]}\" && ciphers_to_test+=\", ${hexcode[i]}\"\n               done\n               [[ -z \"$ciphers_to_test\" ]] && break\n               tls_sockets \"$proto_hex\" \"${ciphers_to_test:2}, 00,ff\" \"ephemeralkey\"\n               [[ $? -ne 0 ]] && break\n               cipher=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\n               for (( i=bundle*bundle_size; i < end_of_bundle; i++ )); do\n                    [[ \"$cipher\" == ${rfc_ciph[i]} ]] && ciphers_found2[i]=true && break\n               done\n               i=${index[i]}\n               ciphers_found[i]=true\n               ciphers_found_with_sockets=true\n               if [[ $proto != tls1_2 ]] || ! \"$SERVER_SIZE_LIMIT_BUG\"; then\n                    # Throw out the results found so far and start over using just sockets\n                    bundle=$num_bundles\n                    for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n                         ciphers_found[i]=true\n                    done\n                    break\n               fi\n          done\n     done\n\n     # If additional ciphers were found using sockets and there is no\n     # SERVER_SIZE_LIMIT_BUG, then just use sockets to find the cipher order.\n     # If there is a SERVER_SIZE_LIMIT_BUG, then use sockets to find the cipher\n     # order, but starting with the list of ciphers supported by the server.\n     if \"$ciphers_found_with_sockets\"; then\n          # Create an array of the ciphers to test with any ChaCha20\n          # listed last in order to avoid accidentally triggering the\n          # server's PriorizeChaCha setting.\n          order=\"\"; nr_ciphers=0; nr_ciphers_found=0\n          for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n               [[ \"${TLS_CIPHER_RFC_NAME[i]}\" =~ CHACHA20 ]] && continue\n               [[ \"${TLS_CIPHER_OSSL_NAME[i]}\" =~ CHACHA20 ]] && continue\n               hexc=\"${TLS_CIPHER_HEXCODE[i]}\"\n               if \"${ciphers_found[i]}\" && [[ ${#hexc} -eq 9 ]]; then\n                    ciphers_found2[nr_ciphers]=false\n                    hexcode[nr_ciphers]=\"${hexc:2:2},${hexc:7:2}\"\n                    rfc_ciph[nr_ciphers]=\"${TLS_CIPHER_RFC_NAME[i]}\"\n                    if [[ $proto == tls1_3 ]]; then\n                         [[ \"${TLS_CIPHER_SSLVERS[i]}\" == TLSv1.3 ]] && nr_ciphers+=1\n                    elif [[ $proto == tls1_2 ]]; then\n                         [[ \"${TLS_CIPHER_SSLVERS[i]}\" != TLSv1.3 ]] && nr_ciphers+=1\n                    elif [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA256 ]] && \\\n                         [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA384 ]] && \\\n                         [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM ]] && \\\n                         [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM_8 ]]; then\n                         nr_ciphers+=1\n                    fi\n               fi\n          done\n          for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n               [[ \"${TLS_CIPHER_RFC_NAME[i]}\" =~ CHACHA20 ]] || [[ \"${TLS_CIPHER_OSSL_NAME[i]}\" =~ CHACHA20 ]] || continue\n               hexc=\"${TLS_CIPHER_HEXCODE[i]}\"\n               if \"${ciphers_found[i]}\" && [[ ${#hexc} -eq 9 ]]; then\n                    ciphers_found2[nr_ciphers]=false\n                    hexcode[nr_ciphers]=\"${hexc:2:2},${hexc:7:2}\"\n                    rfc_ciph[nr_ciphers]=\"${TLS_CIPHER_RFC_NAME[i]}\"\n                    if [[ $proto == tls1_3 ]]; then\n                         [[ \"${TLS_CIPHER_SSLVERS[i]}\" == TLSv1.3 ]] && nr_ciphers+=1\n                    elif [[ $proto == tls1_2 ]]; then\n                         [[ \"${TLS_CIPHER_SSLVERS[i]}\" != TLSv1.3 ]] && nr_ciphers+=1\n                    elif [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA256 ]] && \\\n                         [[ ! \"${TLS_CIPHER_RFC_NAME[i]}\" =~ SHA384 ]] && \\\n                         [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM ]] && \\\n                         [[ \"${TLS_CIPHER_RFC_NAME[i]}\" != *_CCM_8 ]]; then\n                         nr_ciphers+=1\n                    fi\n               fi\n          done\n          while true; do\n               ciphers_to_test=\"\"\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    ! \"${ciphers_found2[i]}\" && ciphers_to_test+=\", ${hexcode[i]}\"\n               done\n               [[ -z \"$ciphers_to_test\" ]] && break\n               if \"$wide\" && \"$SHOW_SIGALGO\"; then\n                    tls_sockets \"$proto_hex\" \"${ciphers_to_test:2}, 00,ff\" \"all\"\n               else\n                    tls_sockets \"$proto_hex\" \"${ciphers_to_test:2}, 00,ff\" \"ephemeralkey\"\n               fi\n               [[ $? -ne 0 ]] && break\n               cipher=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\n               for (( i=0; i < nr_ciphers; i++ )); do\n                    [[ \"$cipher\" == ${rfc_ciph[i]} ]] && ciphers_found2[i]=true && break\n               done\n               if \"$wide\"; then\n                    for (( i=0; i < TLS_NR_CIPHERS; i++ )); do\n                         [[ \"$cipher\" == ${TLS_CIPHER_RFC_NAME[i]} ]] && break\n                    done\n                    [[ $i -eq $TLS_NR_CIPHERS ]] && continue\n                    normalized_hexcode[nr_ciphers_found]=\"$(normalize_ciphercode \"${TLS_CIPHER_HEXCODE[i]}\")\"\n                    ciph[nr_ciphers_found]=\"${TLS_CIPHER_OSSL_NAME[i]}\"\n                    kx[nr_ciphers_found]=\"${TLS_CIPHER_KX[i]}\"\n                    [[ $proto == tls1_3 ]] && kx[nr_ciphers_found]=\"$(read_dhtype_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\"\n                    if [[ ${kx[nr_ciphers_found]} == Kx=ECDH ]] || [[ ${kx[nr_ciphers_found]} == Kx=DH ]] || [[ ${kx[nr_ciphers_found]} == Kx=EDH ]]; then\n                         kx[nr_ciphers_found]+=\" $(read_dhbits_from_file \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" quiet)\"\n                    fi\n                    enc[nr_ciphers_found]=\"${TLS_CIPHER_ENC[i]}\"\n                    export2[nr_ciphers_found]=\"${TLS_CIPHER_EXPORT[i]}\"\n                    sigalg[nr_ciphers_found]=\"\"\n                    \"$SHOW_SIGALGO\" && [[ -r \"$HOSTCERT\" ]] && \\\n                         sigalg[nr_ciphers_found]=\"$(read_sigalg_from_file \"$HOSTCERT\")\"\n                    nr_ciphers_found+=1\n               fi\n               if [[ \"$DISPLAY_CIPHERNAMES\" =~ openssl ]] && [[ $TLS_NR_CIPHERS -ne 0 ]]; then\n                    cipher=\"$(rfc2openssl \"$cipher\")\"\n                    # If there is no OpenSSL name for the cipher, then use the RFC name\n                    [[ -z \"$cipher\" ]] && cipher=$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\n               fi\n               order+=\"$cipher \"\n          done\n     elif [[ -n \"$order\" ]] && [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n          rfc_order=\"\"\n          while read -d \" \" cipher; do\n               rfc_cipher=\"$(openssl2rfc \"$cipher\")\"\n               if [[ -n \"$rfc_cipher\" ]]; then\n                    rfc_order+=\"$rfc_cipher \"\n               else\n                    rfc_order+=\"$cipher \"\n               fi\n          done <<< \"$order\"\n          order=\"$rfc_order\"\n     fi\n\n     # If the server supports at least one ChaCha20 cipher that is less\n     # preferred than a non-ChaCha20 cipher, then check if the server is\n     # configured to prioritize ChaCha20 if that cipher is listed first\n     # in the ClientHello.\n     first_cipher=\"\"; first_chacha_cipher=\"\"\n     for cipher in $order; do\n          [[ ! \"$cipher\" =~ CHACHA20 ]] && first_cipher=\"$cipher\" && break\n     done\n     if [[ -n \"$first_cipher\" ]]; then\n          # Search for first ChaCha20 cipher that comes after $first_cipher in $order.\n          for first_chacha_cipher in ${order#*$first_cipher}; do\n               [[ \"$first_chacha_cipher\" =~ CHACHA20 ]] && break\n          done\n     fi\n     [[ ! \"${first_chacha_cipher}\" =~ CHACHA20 ]] && first_chacha_cipher=\"\"\n     if [[ -n \"$first_cipher\" ]] && [[ -n \"$first_chacha_cipher\" ]]; then\n          # $first_cipher is the first non-ChaCha20 cipher in $order and\n          # $first_chacha_cipher is the first ChaCha20 that comes after\n          # $first_cipher in $order. Check to see if the server will select\n          # $first_chacha_cipher if it appears before $first_cipher in the\n          # ClientHello.\n          if \"$ciphers_found_with_sockets\"; then\n               if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n                    first_cipher=\"$(rfc2hexcode \"$first_cipher\")\"\n                    first_chacha_cipher=\"$(rfc2hexcode \"$first_chacha_cipher\")\"\n               else\n                    first_cipher=\"$(openssl2hexcode \"$first_cipher\")\"\n                    first_chacha_cipher=\"$(openssl2hexcode \"$first_chacha_cipher\")\"\n               fi\n               first_cipher=\"${first_cipher:2:2},${first_cipher:7:2}\"\n               first_chacha_cipher=\"${first_chacha_cipher:2:2},${first_chacha_cipher:7:2}\"\n               tls_sockets \"$proto_hex\" \"$first_chacha_cipher, $first_cipher, 00,ff\" \"ephemeralkey\"\n               if [[ $? -eq 0 ]]; then\n                    cipher=\"$(get_cipher \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\"\n                    [[ \"$cipher\" =~ CHACHA20 ]] && prioritize_chacha=true\n               else\n                    pr_fixme \"something weird happened around line $((LINENO - 5)) \"\n               fi\n          else\n               if [[ \"$DISPLAY_CIPHERNAMES\" =~ rfc ]]; then\n                    first_cipher=\"$(rfc2openssl \"$first_cipher\")\"\n                    first_chacha_cipher=\"$(rfc2openssl \"$first_chacha_cipher\")\"\n               fi\n               if [[ $proto != tls1_3 ]]; then\n                    ciphers_to_test=\"-cipher $first_chacha_cipher:$first_cipher\"\n               else\n                    ciphers_to_test=\"-ciphersuites $first_chacha_cipher:$first_cipher\"\n               fi\n               $OPENSSL s_client $(s_client_options \"$STARTTLS -\"$proto\" $BUGS $ciphers_to_test -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>>$ERRFILE >$TMPFILE\n               if sclient_connect_successful $? $TMPFILE; then\n                    cipher=\"$(get_cipher $TMPFILE)\"\n                    [[ \"$cipher\" =~ CHACHA20 ]] && prioritize_chacha=true\n               else\n                    pr_fixme \"something weird happened around line $((LINENO - 5)) \"\n               fi\n          fi\n     fi\n     if \"$prioritize_chacha\"; then\n          outln \" (server order -- server prioritizes ChaCha ciphers when preferred by clients)\"\n          fileout \"cipher_order-${proto}\" \"OK\" \"server -- server prioritizes ChaCha ciphers when preferred by clients\"\n     elif [[ -n \"$order\" ]]; then\n          outln \" (server order)\"\n          fileout \"cipher_order-${proto}\" \"OK\" \"server\"\n     else\n          outln\n     fi\n     if [[ -n \"$order\" ]]; then\n          add_proto_offered \"$proto\" yes\n          if \"$wide\"; then\n               for (( i=0 ; i<nr_ciphers_found; i++ )); do\n                    neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\" \"true\"\n                    outln \"${sigalg[i]}\"\n                    id=\"cipher-${proto}_${normalized_hexcode[i]}\"\n                    fileout \"$id\" \"$(get_cipher_quality_severity \"${ciph[i]}\")\" \"$proto_text  $(neat_list \"${normalized_hexcode[i]}\" \"${ciph[i]}\" \"${kx[i]}\" \"${enc[i]}\" \"${export2[i]}\")\"\n               done\n          else\n               outln\n               out \"$(printf \"    %-10s \" \"$proto_text: \")\"\n               if [[ \"$COLOR\" -le 2 ]]; then\n                    out \"$(out_row_aligned_max_width \"$order\" \"               \" $TERM_WIDTH)\"\n               else\n                    out_row_aligned_max_width_by_entry \"$order\" \"               \" $TERM_WIDTH pr_cipher_quality\n               fi\n          fi\n          fileout \"cipherorder_${proto_text//./_}\" \"INFO\" \"$order\"\n          [[ -n \"$first_cipher\" ]] && [[ -n \"$first_chacha_cipher\" ]] && fileout \"prioritize_chacha_${proto_text//./_}\" \"INFO\" \"$prioritize_chacha\"\n     else\n          # Order doesn't contain any ciphers, so we can safely unset the protocol and put a dash out\n          add_proto_offered \"$proto\" no\n          outln \" -\"\n     fi\n\n     tmpfile_handle ${FUNCNAME[0]}-$proto.txt\n     return 0\n}\n\n\n# arg1 is OpenSSL s_client parameter or empty\n#\nget_host_cert() {\n     local tmpvar=$TEMPDIR/${FUNCNAME[0]}.txt     # change later to $TMPFILE\n\n     $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $SNI $1\") 2>/dev/null </dev/null >$tmpvar\n     if sclient_connect_successful $? $tmpvar; then\n          awk '/-----BEGIN/,/-----END/ { print $0 }' $tmpvar >$HOSTCERT\n          return 0\n     else\n          if [[ -z \"$1\" ]]; then\n               prln_warning \"could not retrieve host certificate!\"\n               fileout \"host_certificate_Problem\" \"WARN\" \"Could not retrieve host certificate!\"\n          fi\n          return 1\n     fi\n     #tmpfile_handle ${FUNCNAME[0]}.txt\n     #return $((${PIPESTATUS[0]} + ${PIPESTATUS[1]}))\n}\n\nverify_retcode_helper() {\n     local ret=0\n     local -i retcode=$1\n\n     case $retcode in\n          # codes from ./doc/apps/verify.pod | verify(1ssl)\n          44) tm_out \"(different CRL scope)\" ;;                    # X509_V_ERR_DIFFERENT_CRL_SCOPE\n          26) tm_out \"(unsupported certificate purpose)\" ;;        # X509_V_ERR_INVALID_PURPOSE\n          24) tm_out \"(certificate unreadable)\" ;;                 # X509_V_ERR_INVALID_CA\n          23) tm_out \"(certificate revoked)\" ;;                    # X509_V_ERR_CERT_REVOKED\n          21) tm_out \"(chain incomplete, only 1 cert provided)\" ;; # X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE\n          20) tm_out \"(chain incomplete)\" ;;                       # X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY\n          19) tm_out \"(self signed CA in chain)\" ;;                # X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN\n          18) tm_out \"(self signed)\" ;;                            # X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT\n          10) tm_out \"(expired)\" ;;                                # X509_V_ERR_CERT_HAS_EXPIRED\n          9)  tm_out \"(not yet valid)\" ;;                          # X509_V_ERR_CERT_NOT_YET_VALID\n          2)  tm_out \"(issuer cert missing)\" ;;                    # X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT\n          *) ret=1 ; tm_out \" (unknown, pls report) $1\" ;;\n     esac\n     return $ret\n}\n\n# arg1: number of certificate if provided >1\ndetermine_trust() {\n     local jsonID=\"$1\"\n     local json_postfix=\"$2\"\n     local -i i=1\n     local -i num_ca_bundles=0\n     local bundle_fname=\"\"\n     local -a certificate_file verify_retcode trust\n     local ok_was=\"\"\n     local notok_was=\"\"\n     local all_ok=true\n     local some_ok=false\n     local code\n     local ca_bundles=\"\"\n     local spaces=\"                              \"\n     local -i certificates_provided=1+$(grep -ce '-----BEGIN CERTIFICATE-----' $TEMPDIR/intermediatecerts.pem)\n     local addtl_warning\n\n     # If $json_postfix is not empty, then there is more than one certificate\n     # and the output should should be indented by two more spaces.\n     [[ -n $json_postfix ]] && spaces=\"                                \"\n\n     case $OSSL_VER_MAJOR.$OSSL_VER_MINOR in\n          1.0.2|1.1.0|1.1.1|2.[1-9].*|3.*|4.*)           # 2.x is LibreSSL. 2.1.1 was tested to work, below is not sure\n               :\n          ;;\n          *)   addtl_warning=\"Your $OPENSSL <= 1.0.2 might be too unreliable to determine trust\"\n               fileout \"${jsonID}${json_postfix}\" \"WARN\" \"$addtl_warning\"\n               addtl_warning=\"(${addtl_warning})\"\n          ;;\n     esac\n     debugme tmln_out\n\n     # if you run testssl.sh from a different path /you can set either TESTSSL_INSTALL_DIR or CA_BUNDLES_PATH to find the CA BUNDLES\n     if [[ -z \"$CA_BUNDLES_PATH\" ]]; then\n          ca_bundles=\"$TESTSSL_INSTALL_DIR/etc/*.pem\"\n     else\n          ca_bundles=\"$CA_BUNDLES_PATH/*.pem\"\n     fi\n     for bundle_fname in $ca_bundles; do\n          certificate_file[i]=$(basename ${bundle_fname//.pem} 2>/dev/null)\n          if [[ ! -r $bundle_fname ]]; then\n               prln_warning \"\\\"$bundle_fname\\\" cannot be found / not readable\"\n               return 1\n          fi\n          debugme printf -- \" %-12s\" \"${certificate_file[i]}\"\n          # Set SSL_CERT_DIR to /dev/null so that $OPENSSL verify will only use certificates in $bundle_fname\n          # in a subshell because that should be valid here only\n          (export SSL_CERT_DIR=\"/dev/null\"; export SSL_CERT_FILE=\"/dev/null\"\n          if [[ $certificates_provided -ge 2 ]]; then\n               $OPENSSL verify $TRUSTED1ST -purpose sslserver -CAfile <(cat $ADDTL_CA_FILES \"$bundle_fname\") -untrusted $TEMPDIR/intermediatecerts.pem $HOSTCERT >$TEMPDIR/${certificate_file[i]}.1 2>$TEMPDIR/${certificate_file[i]}.2\n          else\n               $OPENSSL verify $TRUSTED1ST -purpose sslserver -CAfile <(cat $ADDTL_CA_FILES \"$bundle_fname\") $HOSTCERT >$TEMPDIR/${certificate_file[i]}.1 2>$TEMPDIR/${certificate_file[i]}.2\n          fi)\n          verify_retcode[i]=$(awk '/error [1-9][0-9]? at [0-9]+ depth lookup:/ { if (!found) {print $2; found=1} }' $TEMPDIR/${certificate_file[i]}.1 $TEMPDIR/${certificate_file[i]}.2)\n          [[ -z \"${verify_retcode[i]}\" ]] && verify_retcode[i]=0\n          if [[ ${verify_retcode[i]} -eq 0 ]]; then\n               trust[i]=true\n               some_ok=true\n               [[ -z \"$GOOD_CA_BUNDLE\" ]] && GOOD_CA_BUNDLE=\"$bundle_fname\"\n               debugme tm_svrty_good \"Ok   \"\n               debugme tmln_out \"${verify_retcode[i]}\"\n          else\n               trust[i]=false\n               all_ok=false\n               debugme tm_svrty_high \"not trusted \"\n               debugme tmln_out \"${verify_retcode[i]}\"\n          fi\n          ((i++))\n     done\n     num_ca_bundles=$((i - 1))\n     debugme tm_out \" \"\n     if \"$all_ok\"; then\n          # all stores ok\n          pr_svrty_good \"Ok   \"; pr_warning \"$addtl_warning\"\n          # we did to stdout the warning above already, so we could stay here with OK:\n          fileout \"${jsonID}${json_postfix}\" \"OK\" \"passed. $addtl_warning\"\n     else\n          pr_svrty_critical \"NOT ok\"\n          if ! \"$some_ok\"; then\n               # ALL failed (we assume with the same issue), we're displaying the reason\n               out \" \"\n               code=\"$(verify_retcode_helper \"${verify_retcode[1]}\")\"\n               if [[ \"$code\" =~ \"pls report\" ]]; then\n                    pr_warning \"$code\"\n               else\n                    out \"$code\"\n               fi\n               fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"failed $code. $addtl_warning\"\n               set_grade_cap \"T\" \"Issues with the chain of trust $code\"\n          else\n               # alt least one ok and other(s) not ==> display the culprit store(s)\n               if \"$some_ok\"; then\n                    pr_svrty_critical \":\"\n                    for (( i=1; i<=num_ca_bundles; i++ )); do\n                         if ${trust[i]}; then\n                              ok_was=\"${certificate_file[i]} $ok_was\"\n                         else\n                              pr_svrty_high \" ${certificate_file[i]} \"\n                              code=\"$(verify_retcode_helper \"${verify_retcode[i]}\")\"\n                              if [[ \"$code\" =~ \"pls report\" ]]; then\n                                   pr_warning \"$code\"\n                              else\n                                   out \"$code\"\n                              fi\n                              notok_was=\"${certificate_file[i]} $code $notok_was\"\n                              if ! [[ ${certificate_file[i]} =~ Java ]]; then\n                                   # Exemption for Java AND rating, as this store doesn't seem to be as complete.\n                                   # We won't penalize this but we still need to raise a red flag. See #1648\n                                   set_grade_cap \"T\" \"Issues with chain of trust $code\"\n                              fi\n                         fi\n                    done\n                    outln\n                    # lf + green ones\n                    [[ \"$DEBUG\" -eq 0 ]] && tm_out \"$spaces\"\n                    pr_svrty_good \"OK: $ok_was\"\n               fi\n               fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"Some certificate trust checks failed -> $notok_was $addtl_warning, OK -> $ok_was\"\n          fi\n          [[ -n \"$addtl_warning\" ]] && out \"\\n$spaces\" && pr_warning \"$addtl_warning\"\n     fi\n     outln\n     return 0\n}\n# not handled: Root CA supplied (\"contains anchor\" in SSLlabs terminology)\n\ntls_time() {\n     local difftime\n     local spaces=\"               \"\n     local jsonID=\"TLS_timestamp\"\n\n     pr_bold \" TLS clock skew\" ; out \"$spaces\"\n\n     if [[ \"$STARTTLS_PROTOCOL\" =~ irc ]]; then\n          prln_local_problem \"STARTTLS/$STARTTLS_PROTOCOL and --ssl-native collide here\"\n          return 1\n     fi\n\n     TLS_DIFFTIME_SET=true                                       # this is a switch whether we want to measure the remote TLS_TIME\n     tls_sockets \"01\" \"$TLS_CIPHER\"                              # try first TLS 1.0 (most frequently used protocol)\n     [[ -z \"$TLS_TIME\" ]] && tls_sockets \"03\" \"$TLS12_CIPHER\"    #           TLS 1.2\n     [[ -z \"$TLS_TIME\" ]] && tls_sockets \"02\" \"$TLS_CIPHER\"      #           TLS 1.1\n     [[ -z \"$TLS_TIME\" ]] && tls_sockets \"00\" \"$TLS_CIPHER\"      #           SSL 3\n\n     if [[ -n \"$TLS_TIME\" ]]; then                               # nothing returned a time!\n          difftime=$((TLS_TIME -  TLS_NOW))                      # TLS_NOW has been set in tls_sockets()\n          if [[ \"${#difftime}\" -gt 5 ]]; then\n               # openssl >= 1.0.1f fills this field with random values! --> good for possible fingerprint\n               out \"Random values, no fingerprinting possible \"\n               fileout \"$jsonID\" \"INFO\" \"random\"\n          else\n               [[ $difftime != \"-\"* ]] && [[ $difftime != \"0\" ]] && difftime=\"+$difftime\"\n               out \"$difftime\"; out \" sec from localtime\";\n               fileout \"$jsonID\" \"INFO\" \"off by $difftime seconds from your localtime\"\n          fi\n          debugme tm_out \"$TLS_TIME\"\n          outln\n     else\n          outln \"SSLv3 through TLS 1.2 didn't return a timestamp\"\n          fileout \"$jsonID\" \"INFO\" \"None returned by SSLv3 through TLSv1.2\"\n     fi\n     TLS_DIFFTIME_SET=false                                      # reset the switch to save calls to date and friend in tls_sockets()\n     return 0\n}\n\n# core function determining whether handshake succeeded or not\n# arg1: return value of \"openssl s_client connect\"\n# arg2: temporary file with the server hello\n# returns 0 if connect was successful, 1 if not\n#\nsclient_connect_successful() {\n     local server_hello=\"$(cat -v \"$2\")\"\n     local connect_success=false\n     local re='Master-Key: ([^\\\n]*)'\n\n     [[ $1 -eq 0 ]] && connect_success=true\n     if ! \"$connect_success\" && [[ \"$server_hello\" =~ $re ]]; then\n          [[ -n \"${BASH_REMATCH[1]}\" ]] && connect_success=true\n     fi\n     ! \"$connect_success\" && [[ \"$server_hello\" =~ (New|Reused)\", \"(SSLv[23]|TLSv1(\\.[0-3])?(\\/SSLv3)?)\", Cipher is \"([A-Z0-9]+-[A-Za-z0-9\\-]+|TLS_[A-Za-z0-9_]+) ]] && connect_success=true\n     if \"$connect_success\"; then\n          \"$NO_SSL_SESSIONID\" && [[ \"$server_hello\" =~ Session-ID:\\ [a-fA-F0-9]{2,64} ]] && NO_SSL_SESSIONID=false\n          return 0\n     fi\n     # what's left now is: master key empty and Session-ID not empty\n     # ==> probably client-based auth with x509 certificate. We handle that at other places\n     #\n     # For robustness we also detected here network / server connectivity problems:\n     # Just need to check whether $TMPFILE=$2 is empty\n     if [[ ! -s \"$2\" ]]; then\n          ((NR_OSSL_FAIL++))\n          connectivity_problem $NR_OSSL_FAIL $MAX_OSSL_FAIL \"openssl s_client connect problem\" \"repeated openssl s_client connect problem, doesn't make sense to continue\"\n     fi\n     return 1\n}\n\nextract_new_tls_extensions() {\n     local tls_extensions\n\n     # this is not beautiful (grep+sed)\n     # but maybe we should just get the ids and do a private matching, according to\n     # https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml\n     tls_extensions=$(grep -a 'TLS server extension ' \"$1\" | \\\n          sed -e 's/TLS server extension //g' -e 's/\\\" (id=/\\/#/g' \\\n              -e 's/,.*$/,/g' -e 's/),$/\\\"/g' \\\n              -e 's/elliptic curves\\/#10/supported_groups\\/#10/g')\n     tls_extensions=$(echo $tls_extensions)       # into one line\n\n     if [[ -n \"$tls_extensions\" ]]; then\n          # check to see if any new TLS extensions were returned and add any new ones to TLS_EXTENSIONS\n          while read -d \"\\\"\" -r line; do\n               if [[ $line != \"\" ]] && [[ ! \"$TLS_EXTENSIONS\" =~ \"$line\" ]]; then\n#FIXME: This is a string of quoted strings, so this seems to determine the output format already. Better e.g. would be an array\n                    TLS_EXTENSIONS+=\" \\\"${line}\\\"\"\n               fi\n          done <<<$tls_extensions\n          [[ \"${TLS_EXTENSIONS:0:1}\" == \" \" ]] && TLS_EXTENSIONS=\"${TLS_EXTENSIONS:1}\"\n     fi\n}\n\n# Note that since, at the moment, this function is only called by run_server_defaults()\n# and run_heartbleed(), this function does not look for the status request or NPN\n# extensions. For run_heartbleed(), only the heartbeat extension needs to be detected.\n# For run_server_defaults(), the status request and NPN would already be detected by\n# get_server_certificate(), if they are supported. In the case of the status extension,\n# since including a status request extension in a ClientHello does not work for GOST\n# only servers. In the case of NPN, since a server will not include both the NPN and\n# ALPN extensions in the same ServerHello.\n#\ndetermine_tls_extensions() {\n     local addcmd\n     local -i success=1\n     local line params=\"\" tls_extensions=\"\"\n     local alpn_proto alpn=\"\" alpn_list_len_hex alpn_extn_len_hex\n     local -i alpn_list_len alpn_extn_len\n     local cbc_cipher_list=\"ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA256:DH-RSA-AES256-SHA256:DH-DSS-AES256-SHA256:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:DH-RSA-AES256-SHA:DH-DSS-AES256-SHA:ECDHE-RSA-CAMELLIA256-SHA384:ECDHE-ECDSA-CAMELLIA256-SHA384:DHE-RSA-CAMELLIA256-SHA256:DHE-DSS-CAMELLIA256-SHA256:DH-RSA-CAMELLIA256-SHA256:DH-DSS-CAMELLIA256-SHA256:DHE-RSA-CAMELLIA256-SHA:DHE-DSS-CAMELLIA256-SHA:DH-RSA-CAMELLIA256-SHA:DH-DSS-CAMELLIA256-SHA:ECDH-RSA-AES256-SHA384:ECDH-ECDSA-AES256-SHA384:ECDH-RSA-AES256-SHA:ECDH-ECDSA-AES256-SHA:ECDH-RSA-CAMELLIA256-SHA384:ECDH-ECDSA-CAMELLIA256-SHA384:AES256-SHA256:AES256-SHA:CAMELLIA256-SHA256:CAMELLIA256-SHA:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:DHE-RSA-AES128-SHA256:DHE-DSS-AES128-SHA256:DH-RSA-AES128-SHA256:DH-DSS-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA:DH-RSA-AES128-SHA:DH-DSS-AES128-SHA:ECDHE-RSA-CAMELLIA128-SHA256:ECDHE-ECDSA-CAMELLIA128-SHA256:DHE-RSA-CAMELLIA128-SHA256:DHE-DSS-CAMELLIA128-SHA256:DH-RSA-CAMELLIA128-SHA256:DH-DSS-CAMELLIA128-SHA256:DHE-RSA-SEED-SHA:DHE-DSS-SEED-SHA:DH-RSA-SEED-SHA:DH-DSS-SEED-SHA:DHE-RSA-CAMELLIA128-SHA:DHE-DSS-CAMELLIA128-SHA:DH-RSA-CAMELLIA128-SHA:DH-DSS-CAMELLIA128-SHA:ECDH-RSA-AES128-SHA256:ECDH-ECDSA-AES128-SHA256:ECDH-RSA-AES128-SHA:ECDH-ECDSA-AES128-SHA:ECDH-RSA-CAMELLIA128-SHA256:ECDH-ECDSA-CAMELLIA128-SHA256:AES128-SHA256:AES128-SHA:CAMELLIA128-SHA256:SEED-SHA:CAMELLIA128-SHA:IDEA-CBC-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:EDH-DSS-DES-CBC3-SHA:DH-RSA-DES-CBC3-SHA:DH-DSS-DES-CBC3-SHA:ECDH-RSA-DES-CBC3-SHA:ECDH-ECDSA-DES-CBC3-SHA:DES-CBC3-SHA:EXP1024-DHE-DSS-DES-CBC-SHA:EDH-RSA-DES-CBC-SHA:EDH-DSS-DES-CBC-SHA:DH-RSA-DES-CBC-SHA:DH-DSS-DES-CBC-SHA:EXP1024-DES-CBC-SHA:DES-CBC-SHA:EXP-EDH-RSA-DES-CBC-SHA:EXP-EDH-DSS-DES-CBC-SHA:EXP-DES-CBC-SHA:EXP-RC2-CBC-MD5:EXP-DH-DSS-DES-CBC-SHA:EXP-DH-RSA-DES-CBC-SHA\"\n     local cbc_cipher_list_hex=\"c0,28, c0,24, c0,14, c0,0a, 00,6b, 00,6a, 00,69, 00,68, 00,39, 00,38, 00,37, 00,36, c0,77, c0,73, 00,c4, 00,c3, 00,c2, 00,c1, 00,88, 00,87, 00,86, 00,85, c0,2a, c0,26, c0,0f, c0,05, c0,79, c0,75, 00,3d, 00,35, 00,c0, 00,84, c0,3d, c0,3f, c0,41, c0,43, c0,45, c0,49, c0,4b, c0,4d, c0,4f, c0,27, c0,23, c0,13, c0,09, 00,67, 00,40, 00,3f, 00,3e, 00,33, 00,32, 00,31, 00,30, c0,76, c0,72, 00,be, 00,bd, 00,bc, 00,bb, 00,9a, 00,99, 00,98, 00,97, 00,45, 00,44, 00,43, 00,42, c0,29, c0,25, c0,0e, c0,04, c0,78, c0,74, 00,3c, 00,2f, 00,ba, 00,96, 00,41, 00,07, c0,3c, c0,3e, c0,40, c0,42, c0,44, c0,48, c0,4a, c0,4c, c0,4e, c0,12, c0,08, 00,16, 00,13, 00,10, 00,0d, c0,0d, c0,03, 00,0a, fe,ff, ff,e0, 00,63, 00,15, 00,12, 00,0f, 00,0c, 00,62, 00,09, fe,fe, ff,e1, 00,14, 00,11, 00,08, 00,06, 00,0b, 00,0e\"\n     local using_sockets=true\n\n     [[ \"$OPTIMAL_PROTO\" == -ssl2 ]] && return 0\n     \"$SSL_NATIVE\" && using_sockets=false\n\n     if \"$using_sockets\"; then\n          tls_extensions=\"00,01,00,01,02, 00,02,00,00, 00,04,00,00, 00,12,00,00, 00,16,00,00, 00,17,00,00\"\n          if [[ -z $STARTTLS ]]; then\n               for alpn_proto in $ALPN_PROTOs; do\n                    alpn+=\",$(printf \"%02x\" ${#alpn_proto}),$(string_to_asciihex \"$alpn_proto\")\"\n               done\n               alpn_list_len=${#alpn}/3\n               alpn_list_len_hex=$(printf \"%04x\" $alpn_list_len)\n               alpn_extn_len=$alpn_list_len+2\n               alpn_extn_len_hex=$(printf \"%04x\" $alpn_extn_len)\n               tls_extensions+=\", 00,10,${alpn_extn_len_hex:0:2},${alpn_extn_len_hex:2:2},${alpn_list_len_hex:0:2},${alpn_list_len_hex:2:2}$alpn\"\n          fi\n          if [[ ! \"$TLS_EXTENSIONS\" =~ encrypt-then-mac ]]; then\n               tls_sockets \"03\" \"$cbc_cipher_list_hex, 00,ff\" \"all\" \"$tls_extensions\"\n               success=$?\n          fi\n          if [[ $success -ne 0 ]] && [[ $success -ne 2 ]]; then\n               tls_sockets \"03\" \"$TLS12_CIPHER\" \"all\" \"$tls_extensions\"\n               success=$?\n          fi\n          [[ $success -eq 2 ]] && success=0\n          [[ $success -eq 0 ]] && extract_new_tls_extensions \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\"\n          if [[ -r \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" ]]; then\n               cp \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" $TMPFILE\n               tmpfile_handle ${FUNCNAME[0]}.txt\n          fi\n     else\n          if \"$HAS_ALPN\" && [[ -z $STARTTLS ]]; then\n               params=\"-alpn \\\"${ALPN_PROTOs// /,}\\\"\"  # we need to replace \" \" by \",\"\n          elif \"$HAS_NPN\" && [[ -z $STARTTLS ]]; then\n               params=\"-nextprotoneg \\\"$NPN_PROTOs\\\"\"\n          fi\n          if [[ -z \"$OPTIMAL_PROTO\" ]] && [[ -z \"$SNI\" ]] && \"$HAS_NO_SSL2\"; then\n               addcmd=\"-no_ssl2\"\n          else\n               addcmd=\"$SNI\"\n          fi\n          if [[ ! \"$TLS_EXTENSIONS\" =~ encrypt-then-mac ]]; then\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $addcmd $OPTIMAL_PROTO -tlsextdebug $params -cipher $cbc_cipher_list\") </dev/null 2>$ERRFILE >$TMPFILE\n               sclient_connect_successful $? $TMPFILE\n               success=$?\n          fi\n          if [[ $success -ne 0 ]]; then\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -connect $NODEIP:$PORT $PROXY $addcmd $OPTIMAL_PROTO -tlsextdebug $params\") </dev/null 2>$ERRFILE >$TMPFILE\n               sclient_connect_successful $? $TMPFILE\n               success=$?\n          fi\n          [[ $success -eq 0 ]] && extract_new_tls_extensions $TMPFILE\n          tmpfile_handle ${FUNCNAME[0]}.txt\n     fi\n\n     # Keep it \"on file\" for debugging purposes\n     [[ \"$DEBUG\" -ge 1 ]] && safe_echo \"$TLS_EXTENSIONS\" >\"$TEMPDIR/$NODE.$NODEIP.tls_extensions.txt\"\n\n     return $success\n}\n\n# Return a list of the certificate compression methods supported (RFC 8879)\ndetermine_cert_compression() {\n     #                                          1=zlib, 2=brotli, 3=zstd\n     local -a supported_compression_methods=(\"\" \"false\" \"false\" \"false\")\n     local -i i len nr_compression_methods=3\n     local len1 len2 methods_to_test method_found method_nr methods_found=\"\"\n\n     # Certificate compression is only supported by TLS 1.3.\n     [[ $(has_server_protocol \"tls1_3\") -eq 1 ]] && return 1\n     while true; do\n          methods_to_test=\"\"\n          for (( i=1; i <= nr_compression_methods; i++ )); do\n               ! \"${supported_compression_methods[i]}\" && methods_to_test+=\" ,00,$(printf \"%02x\" $i)\"\n          done\n          len=$((2*${#methods_to_test}/7))\n          # If there are no more compression methods remaining to be tested, then quit.\n          [[ $len -eq 0 ]] && break\n          len1=$(printf \"%02x\" \"$len\")\n          len2=$(printf \"%02x\" \"$((len+1))\")\n          tls_sockets \"04\" \"$TLS13_CIPHER\" \"all+\" \"00,1b, 00,$len2, $len1$methods_to_test\"\n          if [[ $? -ne 0 ]]; then\n               add_proto_offered tls1_3 no\n               return 1\n          fi\n          add_proto_offered tls1_3 yes\n          method_found=\"$(awk '/Certificate Compression Algorithm: / { print $4 $5 }' \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\")\"\n          [[ -z \"$method_found\" ]] && break\n          [[ -z \"$methods_found\" ]] && tmpfile_handle ${FUNCNAME[0]}.txt \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\"\n          method_found=\"${method_found//(//}\"\n          method_found=\"${method_found//)/}\"\n          method_nr=\"${method_found%%/*}\"\n          supported_compression_methods[method_nr]=true\n          methods_found+=\" $method_found\"\n     done\n     if [[ -n \"$methods_found\" ]]; then\n          TLS13_CERT_COMPRESS_METHODS=\"${methods_found:1}\"\n     else\n          TLS13_CERT_COMPRESS_METHODS=\"none\"\n     fi\n     return 0\n}\n\nextract_certificates() {\n     local version=\"$1\"\n     local savedir\n     local -i i success nrsaved=0\n     local issuerDN CAsubjectDN previssuerDN\n\n     # Place the server's certificate in $HOSTCERT and any intermediate\n     # certificates that were provided in $TEMPDIR/intermediatecerts.pem\n     savedir=\"$PWD\"; cd $TEMPDIR\n     # https://backreference.org/2010/05/09/ocsp-verification-with-openssl/\n     if [[ \"$version\" == ssl2 ]]; then\n          awk -v n=-1 '/Server certificate/ {start=1}\n               /-----BEGIN CERTIFICATE-----/{ if (start) {inc=1; n++} }\n               inc { print > (\"level\" n \".crt\") }\n               /---END CERTIFICATE-----/{ inc=0 }' $TMPFILE\n     else\n          awk -v n=-1 '/Certificate chain/ {start=1}\n               /-----BEGIN CERTIFICATE-----/{ if (start) {inc=1; n++} }\n               inc { print > (\"level\" n \".crt\") }\n               /---END CERTIFICATE-----/{ inc=0 }' $TMPFILE\n     fi\n     [[ -s level0.crt ]] && nrsaved=$(count_words \"$(echo level?.crt 2>/dev/null)\")\n     if [[ $nrsaved -eq 0 ]]; then\n          success=1\n     else\n          success=0\n          CERTIFICATE_LIST_ORDERING_PROBLEM=false\n          mv level0.crt $HOSTCERT\n          if [[ $nrsaved -eq 1 ]]; then\n               echo \"\" > $TEMPDIR/intermediatecerts.pem\n          else\n               cat level?.crt > $TEMPDIR/intermediatecerts.pem\n               issuerDN=\"$($OPENSSL x509 -in $HOSTCERT -noout -issuer 2>/dev/null)\"\n               issuerDN=\"${issuerDN:8}\"\n               previssuerDN=\"$issuerDN\"\n               # The second certificate (level1.crt) SHOULD be issued to the CA\n               # that issued the server's certificate. But, according to RFC 8446\n               # clients SHOULD be prepared to handle cases in which the server\n               # does not order the certificates correctly.\n               for (( i=1; i < nrsaved; i++ )); do\n                    CAsubjectDN=\"$($OPENSSL x509 -in \"level$i.crt\" -noout -subject  2>/dev/null)\"\n                    if [[ \"${CAsubjectDN:9}\" == \"$issuerDN\" ]]; then\n                         cp \"level$i.crt\" $TEMPDIR/hostcert_issuer.pem\n                         issuerDN=\"\" # set to empty to prevent further matches\n                    fi\n                    [[ \"${CAsubjectDN:9}\" != \"$previssuerDN\" ]] && CERTIFICATE_LIST_ORDERING_PROBLEM=true\n                    \"$CERTIFICATE_LIST_ORDERING_PROBLEM\" && [[ -z \"$issuerDN\" ]] && break\n                    previssuerDN=\"$($OPENSSL x509 -in \"level$i.crt\" -noout -issuer  2>/dev/null)\"\n                    previssuerDN=\"${previssuerDN:8}\"\n               done\n               # This should never happen, but if more than one certificate was\n               # provided and none of them belong to the CA that issued the\n               # server's certificate, then the extra certificates should just\n               # be deleted. There is code elsewhere that assumes that if\n               # $TEMPDIR/intermediatecerts.pem is non-empty, then\n               # $TEMPDIR/hostcert_issuer.pem is also present.\n               [[ -n \"$issuerDN\" ]] && echo \"\" > $TEMPDIR/intermediatecerts.pem\n               rm level?.crt\n          fi\n     fi\n     cd \"$savedir\"\n     return $success\n}\n\nextract_stapled_ocsp() {\n     local response=\"$(cat $TMPFILE)\"\n     local ocsp tmp\n     local -i ocsp_len\n\n     STAPLED_OCSP_RESPONSE=\"\"\n     if [[ \"$response\" =~ CertificateStatus ]]; then\n          # This is OpenSSL 1.1.0 or 1.1.1 and the response\n          # is TLS 1.2 or earlier.\n          ocsp=\"${response##*CertificateStatus}\"\n          ocsp=\"16${ocsp#*16}\"\n          ocsp=\"${ocsp%%<<<*}\"\n          ocsp=\"$(strip_spaces \"$(newline_to_spaces \"$ocsp\")\")\"\n          ocsp=\"${ocsp:8}\"\n     elif [[ \"$response\" =~ TLS\\ server\\ extension\\ \\\"status\\ request\\\"\\ \\(id=5\\)\\,\\ len=0 ]]; then\n          # This is not OpenSSL 1.1.0 or 1.1.1, and the response\n          # is TLS 1.2 or earlier.\n          ocsp=\"${response%%OCSP response:*}\"\n          ocsp=\"${ocsp##*<<<}\"\n          ocsp=\"16${ocsp#*16}\"\n          ocsp=\"$(strip_spaces \"$(newline_to_spaces \"$ocsp\")\")\"\n          ocsp=\"${ocsp:8}\"\n     elif [[ \"$response\" =~ TLS\\ server\\ extension\\ \\\"status\\ request\\\"\\ \\(id=5\\)\\,\\ len= ]]; then\n          # This is OpenSSL 1.1.1 and the response is TLS 1.3.\n          ocsp=\"${response##*TLS server extension \\\"status request\\\" (id=5), len=}\"\n          ocsp=\"${ocsp%%<<<*}\"\n          tmp=\"${ocsp%%[!0-9]*}\"\n          ocsp=\"${ocsp#$tmp}\"\n          ocsp_len=2*$tmp\n          ocsp=\"$(awk ' { print $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 $17 } ' <<< \"$ocsp\" | sed 's/-//')\"\n          ocsp=\"$(strip_spaces \"$(newline_to_spaces \"$ocsp\")\")\"\n          ocsp=\"${ocsp:0:ocsp_len}\"\n     else\n          return 0\n     fi\n     # Determine whether this is a single OCSP response or a sequence of\n     # responses and then extract just the response for the server's\n     # certificate.\n     if [[ \"${ocsp:0:2}\" == \"01\" ]]; then\n          STAPLED_OCSP_RESPONSE=\"${ocsp:8}\"\n     elif [[ \"${ocsp:0:2}\" == \"02\" ]]; then\n          ocsp_len=2*$(hex2dec \"${tls_certificate_status_ascii:8:6}\")\n          STAPLED_OCSP_RESPONSE=\"${ocsp:14:ocsp_len}\"\n     fi\n     return 0\n}\n\n# arg1 is \"<OpenSSL cipher>\"\n# arg2 is a list of protocols to try (tls1_2, tls1_1, tls1, ssl3) or empty (if all should be tried)\nget_server_certificate() {\n     local protocols_to_try proto\n     local success ret\n     local npn_params=\"\" line\n     local ciphers_to_test=\"\"\n     # Cipher suites that use a certificate with an RSA (signature) public key\n     local -r a_rsa=\"cc,13, cc,15, c0,30, c0,28, c0,14, 00,9f, cc,a8, cc,aa, c0,a3, c0,9f, 00,6b, 00,39, c0,77, 00,c4, 00,88, c0,45, c0,4d, c0,53, c0,61, c0,7d, c0,8b, 16,b7, 16,b9, c0,2f, c0,27, c0,13, 00,9e, c0,a2, c0,9e, 00,67, 00,33, c0,76, 00,be, 00,9a, 00,45, c0,44, c0,4c, c0,52, c0,60, c0,7c, c0,8a, c0,11, c0,12, 00,16, 00,15, 00,14, c0,10\"\n     # Cipher suites that use a certificate with an RSA (encryption) public key\n     local -r e_rsa=\"00,b7, c0,99, 00,ad, cc,ae, 00,9d, c0,a1, c0,9d, 00,3d, 00,35, 00,c0, 00,84, 00,95, c0,3d, c0,51, c0,69, c0,6f, c0,7b, c0,93, ff,01, 00,ac, c0,a0, c0,9c, 00,9c, 00,3c, 00,2f, 00,ba, 00,b6, 00,96, 00,41, c0,98, 00,07, 00,94, c0,3c, c0,50, c0,68, c0,6e, c0,7a, c0,92, 00,05, 00,04, 00,92, 00,0a, 00,93, fe,ff, ff,e0, 00,62, 00,09, 00,61, fe,fe, ff,e1, 00,64, 00,60, 00,08, 00,06, 00,03, 00,b9, 00,b8, 00,2e, 00,3b, 00,02, 00,01, ff,00\"\n     # Cipher suites that use a certificate with a DSA public key\n     local -r a_dss=\"00,a3, 00,6a, 00,38, 00,c3, 00,87, c0,43, c0,57, c0,81, 00,a2, 00,40, 00,32, 00,bd, 00,99, 00,44, c0,42, c0,56, c0,80, 00,66, 00,13, 00,63, 00,12, 00,65, 00,11\"\n     # Cipher suites that use a certificate with a DH public key\n     local -r a_dh=\"00,a5, 00,a1, 00,69, 00,68, 00,37, 00,36, 00,c2, 00,c1, 00,86, 00,85, c0,3f, c0,41, c0,55, c0,59, c0,7f, c0,83, 00,a4, 00,a0, 00,3f, 00,3e, 00,31, 00,30, 00,bc, 00,bb, 00,98, 00,97, 00,43, 00,42, c0,3e, c0,40, c0,54, c0,58, c0,7e, c0,82, 00,10, 00,0d, 00,0f, 00,0c, 00,0b, 00,0e\"\n     # Cipher suites that use a certificate with an ECDH public key\n     local -r a_ecdh=\"c0,32, c0,2e, c0,2a, c0,26, c0,0f, c0,05, c0,79, c0,75, c0,4b, c0,4f, c0,5f, c0,63, c0,89, c0,8d, c0,31, c0,2d, c0,29, c0,25, c0,0e, c0,04, c0,78, c0,74, c0,4a, c0,4e, c0,5e, c0,62, c0,88, c0,8c, c0,0c, c0,02, c0,0d, c0,03, c0,0b, c0,01\"\n     # Cipher suites that use a certificate with an ECDSA public key\n     local -r a_ecdsa=\"cc,14, c0,2c, c0,24, c0,0a, cc,a9, c0,af, c0,ad, c0,73, c0,49, c0,5d, c0,87, 16,b8, 16,ba, c0,2b, c0,23, c0,09, c0,ae, c0,ac, c0,72, c0,48, c0,5c, c0,86, c0,07, c0,08, c0,06\"\n     # Cipher suites that use a certificate with a GOST public key\n     local -r a_gost=\"00,80, 00,81, 00,82, 00,83\"\n     local using_sockets=true\n\n     \"$SSL_NATIVE\" && using_sockets=false\n\n     CERTIFICATE_LIST_ORDERING_PROBLEM=false\n     if [[ \"$1\" =~ tls1_3 ]]; then\n          [[ $(has_server_protocol \"tls1_3\") -eq 1 ]] && return 1\n          if \"$HAS_TLS13\" && \"$HAS_SIGALGS\" && [[ ! \"$1\" =~ tls1_3_EdDSA ]]; then\n               if [[ \"$1\" =~ tls1_3_RSA ]]; then\n                    $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -showcerts -connect $NODEIP:$PORT $PROXY $SNI -tls1_3 -tlsextdebug -status -msg -sigalgs PSS+SHA256:PSS+SHA384:PSS+SHA512:rsa_pss_pss_sha256:rsa_pss_pss_sha384:rsa_pss_pss_sha512\") </dev/null 2>$ERRFILE >$TMPFILE\n               elif [[ \"$1\" =~ tls1_3_ECDSA ]]; then\n                    $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -showcerts -connect $NODEIP:$PORT $PROXY $SNI -tls1_3 -tlsextdebug -status -msg -sigalgs ECDSA+SHA256:ECDSA+SHA384:ECDSA+SHA512\") </dev/null 2>$ERRFILE >$TMPFILE\n               else\n                    return 1\n               fi\n               sclient_connect_successful $? $TMPFILE || return 1\n               DETECTED_TLS_VERSION=\"0304\"\n               extract_certificates \"tls1_3\"\n               extract_stapled_ocsp\n               success=$?\n          else\n               # For STARTTLS protocols not being implemented yet via sockets this is a bypass otherwise it won't be usable at all (e.g. LDAP)\n               if [[ \"$STARTTLS\" =~ irc ]]; then\n                    return 1\n               elif [[ \"$1\" =~ tls1_3_RSA ]]; then\n                    tls_sockets \"04\" \"$TLS13_CIPHER\" \"all+\" \"00,12,00,00, 00,05,00,05,01,00,00,00,00, 00,0d,00,16,00,14,08,04,08,05,08,06,04,01,05,01,06,01,02,01,08,09,08,0a,08,0b\"\n               elif [[ \"$1\" =~ tls1_3_ECDSA ]]; then\n                    tls_sockets \"04\" \"$TLS13_CIPHER\" \"all+\" \"00,12,00,00, 00,05,00,05,01,00,00,00,00, 00,0d,00,0a,00,08,04,03,05,03,06,03,02,03\"\n               elif [[ \"$1\" =~ tls1_3_EdDSA ]]; then\n                    tls_sockets \"04\" \"$TLS13_CIPHER\" \"all+\" \"00,12,00,00, 00,05,00,05,01,00,00,00,00, 00,0d,00,06,00,04,08,07,08,08\"\n               else\n                    return 1\n               fi\n               success=$?\n               [[ $success -eq 0 ]] || return 1\n               cp \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" $TMPFILE\n          fi\n          [[ $success -eq 0 ]] && add_proto_offered tls1_3 yes\n          extract_new_tls_extensions $TMPFILE\n          tmpfile_handle ${FUNCNAME[0]}.txt\n          return $success\n     fi\n\n     \"$HAS_NPN\" && [[ -z \"$STARTTLS\" ]] && npn_params=\"-nextprotoneg \\\"$NPN_PROTOs\\\"\"\n\n     if [[ -n \"$2\" ]]; then\n          protocols_to_try=\"$2\"\n     else\n          protocols_to_try=\"tls1_2 tls1_1 tls1 ssl3\"\n     fi\n\n     # throwing 1st every cipher/protocol at the server to know what works\n     success=7\n\n     if [[ \"$OPTIMAL_PROTO\" == -ssl2 ]]; then\n          success=1\n          sslv2_sockets \"\" \"true\"\n          if [[ $? -eq 3 ]]; then\n               mv $TEMPDIR/$NODEIP.parse_sslv2_serverhello.txt $TMPFILE\n               success=0\n          fi\n          tmpfile_handle ${FUNCNAME[0]}.txt\n          return $success\n     fi\n\n     if \"$using_sockets\"; then\n          protocols_to_try=\"${protocols_to_try/tls1_2/03}\"\n          protocols_to_try=\"${protocols_to_try/tls1_1/02}\"\n          protocols_to_try=\"${protocols_to_try/tls1/01}\"\n          protocols_to_try=\"${protocols_to_try/ssl3/00}\"\n\n          [[ \"$1\" =~ aRSA ]] && ciphers_to_test+=\", $a_rsa\"\n          [[ \"$1\" =~ eRSA ]] && ciphers_to_test+=\", $e_rsa\"\n          [[ \"$1\" =~ aDSS ]] && ciphers_to_test+=\", $a_dss\"\n          [[ \"$1\" =~ aDH ]] && ciphers_to_test+=\", $a_dh\"\n          [[ \"$1\" =~ aECDH ]] && ciphers_to_test+=\", $a_ecdh\"\n          [[ \"$1\" =~ aECDSA ]] && ciphers_to_test+=\", $a_ecdsa\"\n          [[ \"$1\" =~ aGOST ]] && ciphers_to_test+=\", $a_gost\"\n\n          [[ -z \"$ciphers_to_test\" ]] && return 1\n          ciphers_to_test=\"${ciphers_to_test:2}\"\n\n          for proto in $protocols_to_try; do\n               [[ 1 -eq $(has_server_protocol $proto) ]] && continue\n               tls_sockets \"$proto\" \"$ciphers_to_test, 00,ff\" \"all\" \"00,12,00,00, 00,05,00,05,01,00,00,00,00\"\n               ret=$?\n               [[ $ret -eq 0 ]] && success=0 && break\n               [[ $ret -eq 2 ]] && success=0 && break\n          done                          # this loop is needed for IIS6 and others which have a handshake size limitations\n          if [[ $success -eq 7 ]]; then\n               # \"-status\" above doesn't work for GOST only servers, so we do another test without it and see whether that works then:\n               tls_sockets \"$proto\" \"$ciphers_to_test, 00,ff\" \"all\" \"00,12,00,00\"\n               ret=$?\n               [[ $ret -eq 0 ]] && success=0\n               [[ $ret -eq 2 ]] && success=0\n               if [[ $success -eq 7 ]]; then\n                    if [ -z \"$1\" ]; then\n                         prln_warning \"Strange, no SSL/TLS protocol seems to be supported (error around line $((LINENO - 6)))\"\n                    fi\n                    tmpfile_handle ${FUNCNAME[0]}.txt\n                    return 7  # this is ugly, I know\n               else\n                    GOST_STATUS_PROBLEM=true\n               fi\n          fi\n          cp $TEMPDIR/$NODEIP.parse_tls_serverhello.txt $TMPFILE\n\n          # When \"$2\" is empty, get_server_certificate() is being called with SNI=\"\".\n          # In case the extensions returned by the server differ depending on whether\n          # SNI is provided or not, don't collect extensions when SNI=\"\" (unless\n          # no DNS name was provided at the command line).\n          [[ -z \"$2\" ]] && extract_new_tls_extensions $TMPFILE\n     else\n          # no sockets, openssl\n          ciphers_to_test=\"$1\"\n          if [[ \"$1\" =~ aRSA ]] && [[ \"$1\" =~ eRSA ]]; then\n               ciphers_to_test=\"${ciphers_to_test/eRSA/}\"\n          elif [[ \"$1\" =~ aRSA ]]; then\n               ciphers_to_test=\"${ciphers_to_test/aRSA/}\"\n               for ciph in $(colon_to_spaces $(actually_supported_osslciphers \"aRSA\")); do\n                    [[ \"$ciph\" =~ -RSA- ]] && ciphers_to_test+=\":$ciph\"\n               done\n          elif [[ \"$1\" =~ eRSA ]]; then\n               ciphers_to_test=\"${ciphers_to_test/eRSA/}\"\n               for ciph in $(colon_to_spaces $(actually_supported_osslciphers \"aRSA\")); do\n                    [[ ! \"$ciph\" =~ -RSA- ]] && ciphers_to_test+=\":$ciph\"\n               done\n          fi\n          ciphers_to_test=\"${ciphers_to_test/::/:}\"\n          [[ \"${ciphers_to_test:0:1}\" == : ]] &&  ciphers_to_test=\"${ciphers_to_test:1}\"\n          [[ $(count_ciphers $(actually_supported_osslciphers \"$ciphers_to_test\")) -ge 1 ]] || return 1\n\n          for proto in $protocols_to_try; do\n               [[ 1 -eq $(has_server_protocol $proto) ]] && continue\n               sclient_supported \"-$proto\" || continue\n               addcmd=\"\"\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -cipher $ciphers_to_test -showcerts -connect $NODEIP:$PORT $PROXY $SNI -$proto -tlsextdebug $npn_params -status -msg\") </dev/null 2>$ERRFILE >$TMPFILE\n               if sclient_connect_successful $? $TMPFILE; then\n                    success=0\n                    break               # now we have the certificate\n               fi\n          done                          # this loop is needed for IIS6 and others which have a handshake size limitations\n          if [[ $success -eq 7 ]]; then\n               # \"-status\" above doesn't work for GOST only servers, so we do another test without it and see whether that works then:\n               sclient_supported \"-$proto\" || return 7\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -cipher $ciphers_to_test -showcerts -connect $NODEIP:$PORT $PROXY $SNI -$proto -tlsextdebug\") </dev/null 2>>$ERRFILE >$TMPFILE\n               if ! sclient_connect_successful $? $TMPFILE; then\n                    if [ -z \"$1\" ]; then\n                         prln_warning \"Strange, no SSL/TLS protocol seems to be supported (error around line $((LINENO - 6)))\"\n                    fi\n                    tmpfile_handle ${FUNCNAME[0]}.txt\n                    return 7  # this is ugly, I know\n               else\n                    GOST_STATUS_PROBLEM=true\n               fi\n          fi\n          case \"$proto\" in\n               \"tls1_2\") DETECTED_TLS_VERSION=\"0303\" ;;\n               \"tls1_1\") DETECTED_TLS_VERSION=\"0302\" ;;\n               \"tls1\") DETECTED_TLS_VERSION=\"0301\" ;;\n               \"ssl3\") DETECTED_TLS_VERSION=\"0300\" ;;\n          esac\n          # When \"$2\" is empty, get_server_certificate() is being called with SNI=\"\".\n          # In case the extensions returned by the server differ depending on whether\n          # SNI is provided or not, don't collect extensions when SNI=\"\" (unless\n          # no DNS name was provided at the command line).\n          [[ -z \"$2\" ]] && extract_new_tls_extensions $TMPFILE\n\n          extract_certificates \"$proto\"\n          extract_stapled_ocsp\n          success=$?\n     fi\n     tmpfile_handle ${FUNCNAME[0]}.txt\n     return $success\n}\n\n# arg1: path to certificate\n# returns CN\nget_cn_from_cert() {\n     local subject\n\n     # attention! openssl 1.0.2 doesn't properly handle online output from certificates from trustwave.com/github.com\n     #FIXME: use -nameopt oid for robustness\n\n     # for e.g. russian sites -esc_msb,utf8 works in an UTF8 terminal -- any way to check platform independent?\n     # see x509(1ssl):\n     subject=\"$($OPENSSL x509 -in $1 -noout -subject -nameopt multiline,-align,sname,-esc_msb,utf8,-space_eq 2>>$ERRFILE)\"\n     echo \"$(awk -F'=' '/CN=/ { print $2 }' <<< \"$subject\" | tr '\\n' ' ')\"\n     return $?\n}\n\n# Return 0 if the name provided in arg1 is a wildcard name\nis_wildcard()\n{\n     local certname=\"$1\"\n\n     # If the first label in the DNS name begins \"xn--\", then assume it is an\n     # A-label and not a wildcard name (RFC 6125, Section 6.4.3).\n     [[ \"${certname:0:4}\" == \"xn--\" ]] && return 1\n\n     # Remove part of name preceding '*' or '.'. If no \"*\" appears in the\n     # left-most label, then it is not a wildcard name (RFC 6125, Section 6.4.3).\n     basename=\"$(echo -n \"$certname\" | sed 's/^[_a-zA-Z0-9\\-]*//')\"\n     [[ \"${basename:0:1}\" != \"*\" ]] && return 1 # not a wildcard name\n\n     # Check that there are no additional wildcard ('*') characters or any\n     # other characters that do not belong in a DNS name.\n     [[ -n $(echo -n \"${basename:1}\" | sed 's/^[_\\.a-zA-Z0-9\\-]*//') ]] && return 1\n     return 0\n}\n\n# Return 0 if the name provided in arg2 is a wildcard name and it matches the name provided in arg1.\nwildcard_match()\n{\n     local servername=\"$1\"\n     local certname=\"$2\"\n     local basename\n     local -i basename_offset len_certname len_part1 len_basename\n     local -i len_servername len_wildcard\n\n     len_servername=${#servername}\n     len_certname=${#certname}\n\n     # Use rules from RFC 6125 to perform the match.\n\n     # Assume the \"*\" in the wildcard needs to be replaced by one or more\n     # characters, although RFC 6125 is not clear about that.\n     [[ $len_servername -lt $len_certname ]] && return 1\n\n     is_wildcard \"$certname\"\n     [[ $? -ne 0 ]] && return 1\n\n     # Comparisons of DNS names are case insensitive, so convert both names to uppercase.\n     certname=\"$(toupper \"$certname\")\"\n     servername=\"$(toupper \"$servername\")\"\n\n     # Extract part of name that comes after the \"*\"\n     basename=\"$(echo -n \"$certname\" | sed 's/^[_A-Z0-9\\-]*\\*//')\"\n     len_basename=${#basename}\n     len_part1=$len_certname-$len_basename-1\n     len_wildcard=$len_servername-$len_certname+1\n     basename_offset=$len_servername-$len_basename\n\n     # Check that initial part of $servername matches initial part of $certname\n     # and that final part of $servername matches final part of $certname.\n     [[ \"${servername:0:len_part1}\" != \"${certname:0:len_part1}\" ]] && return 1\n     [[ \"${servername:basename_offset:len_basename}\" != \"$basename\" ]] && return 1\n\n     # Check that part of $servername that matches \"*\" is all part of a single\n     # domain label.\n     [[ -n $(echo -n \"${servername:len_part1:len_wildcard}\" | sed 's/^[_A-Z0-9\\-]*//') ]] && return 1\n\n     return 0\n}\n\n# Compare the server name provided in arg1 to the CN and SAN in arg2 and return:\n#    0, if server name provided does not match any of the names in the CN or SAN\n#    1, if the server name provided matches a name in the SAN\n#    2, if the server name provided is a wildcard match against a name in the SAN\n#    4, if the server name provided matches the CN\n#    5, if the server name provided matches the CN AND a name in the SAN\n#    6, if the server name provided matches the CN AND is a wildcard match against a name in the SAN\n#    8, if the server name provided is a wildcard match against the CN\n#    9, if the server name provided matches a name in the SAN AND is a wildcard match against the CN\n#   10, if the server name provided is a wildcard match against the CN AND a name in the SAN\n\ncompare_server_name_to_cert() {\n     local cert=\"$1\"\n     local servername cns cn dns_sans ip_sans san dercert tag\n     local srv_id=\"\" xmppaddr=\"\"\n     local -i i len len1 cn_match=0\n     local -i subret=0             # no error condition, passing results\n\n     HAS_DNS_SANS=false\n     if [[ -n \"$XMPP_HOST\" ]]; then\n          # RFC 6120, Section 13.7.2.1, states that for XMPP the identity that\n          # should appear in the server's certificate is identity that appears\n          # in the the 'to' address that the client communicates in the initial\n          # stream header.\n          servername=\"$(toupper \"$XMPP_HOST\")\"\n     else\n          servername=\"$(toupper \"$NODE\")\"\n     fi\n\n     # Check whether any of the DNS names in the certificate match the servername\n     dns_sans=\"$(get_san_dns_from_cert \"$cert\")\"\n     while read san; do\n          if [[ -n \"$san\" ]]; then\n               HAS_DNS_SANS=true\n               [[ $(toupper \"$san\") == \"$servername\" ]] && subret=1 && break\n          fi\n     done <<< \"$dns_sans\"\n\n     if [[ $subret -eq 0 ]]; then\n          # Check whether any of the IP addresses in the certificate match the servername\n          ip_sans=$($OPENSSL x509 -in \"$cert\" -noout -text 2>>$ERRFILE | grep -A2 \"Subject Alternative Name\" | \\\n                  tr ',' '\\n' | grep \"IP Address:\" | sed -e 's/IP Address://g' -e 's/ //g')\n          while read san; do\n               [[ -n \"$san\" ]] && [[ \"$san\" == \"$servername\" ]] && subret=1 && break\n          done <<< \"$ip_sans\"\n     fi\n\n     if [[ $subret -eq 0 ]] && [[ -n \"$XMPP_HOST\" ]]; then\n          # For XMPP hosts, in addition to checking for a matching DNS name,\n          # should also check for a matching SRV-ID or XmppAddr identifier.\n          dercert=\"$($OPENSSL x509 -in \"$cert\" -outform DER 2>>$ERRFILE | hexdump -v -e '16/1 \"%02X\"')\"\n          # Look for the beginning of the subjectAltName extension. It\n          # will begin with the OID (2.5.29.17 = 0603551D11). After the OID\n          # there may be an indication that the extension is critical (0101FF).\n          # Finally will be the tag indicating that the value of the extension is\n          # encoded as an OCTET STRING (04).\n          if [[ \"$dercert\" =~ 0603551D110101FF04 ]]; then\n               dercert=\"${dercert##*0603551D110101FF04}\"\n          else\n               dercert=\"${dercert##*0603551D1104}\"\n          fi\n          # Skip over the encoding of the length of the OCTET STRING.\n          if [[ \"${dercert:0:1}\" == \"8\" ]]; then\n               i=\"${dercert:1:1}\"\n               i=2*$i+2\n               dercert=\"${dercert:i}\"\n          else\n               dercert=\"${dercert:2}\"\n          fi\n          # Next byte should be a 30 (SEQUENCE).\n          if [[ \"${dercert:0:2}\" == \"30\" ]]; then\n               # Get the length of the subjectAltName extension and then skip\n               # over the encoding of the length.\n               if [[ \"${dercert:2:1}\" == \"8\" ]]; then\n                    case \"${dercert:3:1}\" in\n                         1) len=2*0x${dercert:4:2}; dercert=\"${dercert:6}\" ;;\n                         2) len=2*0x${dercert:4:4}; dercert=\"${dercert:8}\" ;;\n                         3) len=2*0x${dercert:4:6}; dercert=\"${dercert:10}\" ;;\n                         *) len=0 ;;\n                    esac\n               else\n                    len=2*0x${dercert:2:2}\n                    dercert=\"${dercert:4}\"\n               fi\n               if [[ $len -ne 0 ]] && [[ $len -lt ${#dercert} ]]; then\n                    # loop through all the names and extract the SRV-ID and XmppAddr identifiers\n                    for (( i=0; i < len; i+=len_name )); do\n                         tag=\"${dercert:i:2}\"\n                         i+=2\n                         if [[ \"${dercert:i:1}\" == \"8\" ]]; then\n                              i+=1\n                              case \"${dercert:i:1}\" in\n                                   1) i+=1; len_name=2*0x${dercert:i:2}; i+=2 ;;\n                                   2) i+=1; len_name=2*0x${dercert:i:4}; i+=4 ;;\n                                   3) i+=1; len_name=2*0x${dercert:i:6}; i+=4 ;;\n                                   *) len=0 ;;\n                              esac\n                         else\n                              len_name=2*0x${dercert:i:2}\n                              i+=2\n                         fi\n                         if [[ \"$tag\" == \"A0\" ]]; then\n                              # This is an otherName.\n                              if [[ $len_name -gt 18 ]] && [[ \"${dercert:i:20}\" == \"06082B06010505070805\" || \\\n                                   \"${dercert:i:20}\" == \"06082B06010505070807\" ]]; then\n                                   # According to the OID, this is either an SRV-ID or XmppAddr.\n                                   j=$i+20\n                                   if [[ \"${dercert:j:2}\" == \"A0\" ]]; then\n                                        j+=2\n                                        if [[ \"${dercert:j:1}\" == \"8\" ]]; then\n                                             j+=1\n                                             j+=2*0x${dercert:j:1}+1\n                                        else\n                                             j+=2\n                                        fi\n                                        if [[ \"${dercert:i:20}\" == \"06082B06010505070805\" && \"${dercert:j:2}\" == \"0C\" ]] || \\\n                                           [[ \"${dercert:i:20}\" == \"06082B06010505070807\" && \"${dercert:j:2}\" == \"16\" ]]; then\n                                             # XmppAddr should be encoded as UTF8STRING (0C) and\n                                             # SRV-ID should be encoded IA5STRING (16).\n                                             j+=2\n                                             if [[ \"${dercert:j:1}\" == \"8\" ]]; then\n                                                  j+=1\n                                                  case \"${dercert:j:1}\" in\n                                                       1) j+=1; len1=2*0x${dercert:j:2}; j+=2 ;;\n                                                       2) j+=1; len1=2*0x${dercert:j:4}; j+=4 ;;\n                                                       3) j+=1; len1=2*0x${dercert:j:6}; j+=6 ;;\n                                                       4) len1=0 ;;\n                                                  esac\n                                             else\n                                                  len1=2*0x${dercert:j:2}\n                                                  j+=2\n                                             fi\n                                             if [[ $len1 -ne 0 ]]; then\n                                                  san=\"$(hex2binary \"${dercert:j:len1}\")\"\n                                                  if [[ \"${dercert:i:20}\" == \"06082B06010505070805\" ]]; then\n                                                       xmppaddr+=\"$san \"\n                                                  else\n                                                       srv_id+=\"$san \"\n                                                  fi\n                                             fi\n                                        fi\n                                   fi\n                              fi\n                         fi\n                    done\n               fi\n          fi\n          [[ -n \"$srv_id\" ]] && HAS_DNS_SANS=true\n          [[ -n \"$xmppaddr\" ]] && HAS_DNS_SANS=true\n          while read -d \" \" san; do\n               [[ -n \"$san\" ]] && [[ $(toupper \"$san\") == \"_XMPP-SERVER.$servername\" ]] && subret=1 && break\n          done <<< \"$srv_id\"\n          if [[ $subret -eq 0 ]]; then\n               while read -d \" \" san; do\n                    [[ -n \"$san\" ]] && [[ $(toupper \"$san\") == \"$servername\" ]] && subret=1 && break\n               done <<< \"$xmppaddr\"\n          fi\n     fi\n\n     # Check whether any of the DNS names in the certificate are wildcard names\n     # that match the servername\n     if [[ $subret -eq 0 ]]; then\n          while read san; do\n               [[ -n \"$san\" ]] || continue\n               wildcard_match \"$servername\" \"$san\"\n               [[ $? -eq 0 ]] && subret=2 && break\n          done <<< \"$dns_sans\"\n     fi\n\n     # Get every CN from the subject field and compare against the server name.\n     cns=\"$($OPENSSL x509 -in $1 -noout -subject -nameopt multiline,-align,sname,-esc_msb,utf8,-space_eq 2>>$ERRFILE | awk -F'=' '/CN=/ { print $2 }')\"\n     while read cn; do\n          # If the CN contains any characters that are not valid for a DNS name,\n          # then assume it does not contain a DNS name.\n          [[ -n \"${cn//[_\\.a-zA-Z0-9*\\-]/}\" ]] && continue\n\n          # Check whether the CN matches the servername\n          [[ $(toupper \"$cn\") == \"$servername\" ]] && cn_match=4 && break\n\n          # Check whether the CN is a wildcard name that matches the servername\n          # NOTE: Don't stop loop on a wildcard match in case there is another CN\n          # that is an exact match.\n          wildcard_match \"$servername\" \"$cn\"\n          [[ $? -eq 0 ]] && cn_match=8\n     done <<< \"$cns\"\n     subret+=$cn_match\n     return $subret\n}\n\n# This function determines whether the certificate (arg3) contains \"visibility\n# information\" (see Section 4.3.3 of\n# https://www.etsi.org/deliver/etsi_ts/103500_103599/10352303/01.02.01_60/ts_10352303v010201p.pdf.\netsi_ets_visibility_info() {\n     local jsonID=\"$1\"\n     local spaces=\"$2\"\n     local cert=\"$3\"\n     local cert_txt=\"$4\"\n     local dercert tag\n     local -a fingerprint=() access_description=()\n     local -i i j len len1 len_name nr_visnames=0\n\n     # If \"visibility information\" is present, it will appear in the subjectAltName\n     # extension (0603551D11) as an otherName with OID 0.4.0.3523.3.1 (060604009B430301).\n     # OpenSSL 1.1.1 and earlier displays all names of type otherName as \"othername:<unsupported>\".\n     # As certificates will rarely include a name encoded as an otherName, check the\n     # text version of the certificate for \"othername:<unsupported>\" before calling\n     # external functions to obtain the DER encoded certificate.\n     if [[ \"$cert_txt\" =~ X509v3\\ Subject\\ Alternative\\ Name:.*othername:\\<unsupported\\> ]] || \\\n        [[ \"$cert_txt\" =~ X509v3\\ Subject\\ Alternative\\ Name:.*othername:\\ 0.4.0.3523.3.1 ]]; then\n          dercert=\"$($OPENSSL x509 -outform DER 2>>$ERRFILE <<< \"$cert\" | hexdump -v -e '16/1 \"%02X\"')\"\n          if [[ \"$dercert\" =~ 0603551D110101FF04[0-9A-F]*060604009B430301 ]] || \\\n             [[ \"$dercert\" =~ 0603551D1104[0-9A-F]*060604009B430301 ]]; then\n               # Look for the beginning of the subjectAltName extension. It\n               # will begin with the OID (2.5.29.17 = 0603551D11). After the OID\n               # there may be an indication that the extension is critical (0101FF).\n               # Finally will be the tag indicating that the value of the extension is\n               # encoded as an OCTET STRING (04).\n               if [[ \"$dercert\" =~ 0603551D110101FF04 ]]; then\n                    dercert=\"${dercert##*0603551D110101FF04}\"\n               else\n                    dercert=\"${dercert##*0603551D1104}\"\n               fi\n               # Skip over the encoding of the length of the OCTET STRING.\n               if [[ \"${dercert:0:1}\" == 8 ]]; then\n                    i=\"${dercert:1:1}\"\n                    i=2*$i+2\n                    dercert=\"${dercert:i}\"\n               else\n                    dercert=\"${dercert:2}\"\n               fi\n               # Next byte should be a 30 (SEQUENCE).\n               if [[ \"${dercert:0:2}\" == 30 ]]; then\n                    # Get the length of the subjectAltName extension and then skip\n                    # over the encoding of the length.\n                    if [[ \"${dercert:2:1}\" == 8 ]]; then\n                         case \"${dercert:3:1}\" in\n                              1) len=2*0x${dercert:4:2}; dercert=\"${dercert:6}\" ;;\n                              2) len=2*0x${dercert:4:4}; dercert=\"${dercert:8}\" ;;\n                              3) len=2*0x${dercert:4:6}; dercert=\"${dercert:10}\" ;;\n                              *) len=0 ;;\n                         esac\n                    else\n                         len=2*0x${dercert:2:2}\n                         dercert=\"${dercert:4}\"\n                    fi\n                    if [[ $len -ne 0 ]] && [[ $len -lt ${#dercert} ]]; then\n                         # loop through all the names and extract the visibility information\n                         for (( i=0; i < len; i+=len_name )); do\n                              tag=\"${dercert:i:2}\"\n                              i+=2\n                              if [[ \"${dercert:i:1}\" == 8 ]]; then\n                                   i+=1\n                                   case \"${dercert:i:1}\" in\n                                        1) i+=1; len_name=2*0x${dercert:i:2}; i+=2 ;;\n                                        2) i+=1; len_name=2*0x${dercert:i:4}; i+=4 ;;\n                                        3) i+=1; len_name=2*0x${dercert:i:6}; i+=4 ;;\n                                        *) len=0 ;;\n                                   esac\n                              else\n                                   len_name=2*0x${dercert:i:2}\n                                   i+=2\n                              fi\n                              [[ \"$tag\" == A0 ]] || continue\n                              # This is an otherName.\n                              [[ $len_name -gt 16 ]] || continue\n                              [[ \"${dercert:i:16}\" == 060604009B430301 ]] || continue\n                              # According to the OID, this is visibility information.\n                              j=$i+16\n                              # Skip over the tag (A0) and length for the otherName value.\n                              [[ \"${dercert:j:2}\" == A0 ]] || continue\n                              j+=2\n                              if [[ \"${dercert:j:1}\" == 8 ]]; then\n                                   j+=1\n                                   j+=2*0x${dercert:j:1}+1\n                              else\n                                   j+=2\n                              fi\n                              # The value for this otherName is encoded as a SEQUENCE (30):\n                              #    VisibilityInformation ::= SEQUENCE {\n                              #         fingerprint         OCTET STRING (SIZE(10)),\n                              #         accessDescription   UTF8String }\n                              [[ \"${dercert:j:2}\" == 30 ]] || continue\n                              j+=2\n                              if [[ \"${dercert:j:1}\" == 8 ]]; then\n                                   j+=1\n                                   case \"${dercert:j:1}\" in\n                                        1) j+=1; len1=2*0x${dercert:j:2}; j+=2 ;;\n                                        2) j+=1; len1=2*0x${dercert:j:4}; j+=4 ;;\n                                        3) j+=1; len1=2*0x${dercert:j:6}; j+=6 ;;\n                                        4) len1=0 ;;\n                                   esac\n                              else\n                                   len1=2*0x${dercert:j:2}\n                                   j+=2\n                              fi\n                              [[ $len1 -ne 0 ]] || continue\n                              # Next is the 10-byte fingerprint, encoded as an OCTET STRING (04)\n                              [[ \"${dercert:j:4}\" == 040A ]] || continue\n                              j+=4\n                              fingerprint[nr_visnames]=\"$(hex2binary \"${dercert:j:20}\")\"\n                              j+=20\n                              # Finally comes the access description, encoded as a UTF8String (0C).\n                              [[ \"${dercert:j:2}\" == 0C ]] || continue\n                              j+=2\n                              if [[ \"${dercert:j:1}\" == \"8\" ]]; then\n                                   j+=1\n                                   case \"${dercert:j:1}\" in\n                                        1) j+=1; len1=2*0x${dercert:j:2}; j+=2 ;;\n                                        2) j+=1; len1=2*0x${dercert:j:4}; j+=4 ;;\n                                        3) j+=1; len1=2*0x${dercert:j:6}; j+=6 ;;\n                                        4) len1=0 ;;\n                                   esac\n                              else\n                                   len1=2*0x${dercert:j:2}\n                                   j+=2\n                              fi\n                              access_description[nr_visnames]=\"\"$(hex2binary \"${dercert:j:len1}\")\"\"\n                              nr_visnames+=1\n                         done\n                    fi\n               fi\n          fi\n     fi\n     if [[ $nr_visnames -eq 0 ]]; then\n          outln \"not present\"\n          fileout \"$jsonID\" \"INFO\" \"not present\"\n     else\n          for (( i=0; i < nr_visnames; i++ )); do\n               [[ $i -ne 0 ]] && out \"$spaces\"\n               outln \"$(out_row_aligned_max_width \"${fingerprint[i]} / ${access_description[i]}\" \"$spaces\" $TERM_WIDTH)\"\n               fileout \"$jsonID\" \"INFO\" \"${fingerprint[i]} / ${access_description[i]}\"\n          done\n     fi\n     return 0\n}\n\n# NOTE: arg3 must contain the text output of $HOSTCERT.\nmust_staple() {\n     local jsonID=\"cert_mustStapleExtension\"\n     local json_postfix=\"$1\"\n     local provides_stapling=\"$2\"\n     local hostcert_txt=\"$3\"\n     local cert extn\n     local -i extn_len\n     local supported=false\n\n     # Note this function is only looking for status_request (5) and not\n     # status_request_v2 (17), since OpenSSL seems to only include status_request (5)\n     # in its ClientHello when the \"-status\" option is used.\n\n     # OpenSSL 1.1.0 supports pretty-printing the \"TLS Feature extension.\" For any\n     # previous versions of OpenSSL, OpenSSL can only show if the extension OID is present.\n     if grep -A 1 \"TLS Feature:\" <<< \"$hostcert_txt\" | grep -q \"status_request\"; then\n          # FIXME: This will indicate that must staple is supported if the\n          # certificate indicates status_request or status_request_v2. This is\n          # probably okay, since it seems likely that any TLS Feature extension\n          # that includes status_request_v2 will also include status_request.\n          supported=true\n     elif [[ \"$hostcert_txt\" =~ '1.3.6.1.5.5.7.1.24:' ]]; then\n          cert=\"$($OPENSSL x509 -in \"$HOSTCERT\" -outform DER 2>>$ERRFILE | hexdump -v -e '16/1 \"%02X\"')\"\n          extn=\"${cert##*06082B06010505070118}\"\n          # Check for critical bit, and skip over it if present.\n          [[ \"${extn:0:6}\" == \"0101FF\" ]] && extn=\"${extn:6}\"\n          # Next is tag and length of extnValue OCTET STRING. Assume it is less than 128 bytes.\n          extn=\"${extn:4}\"\n          # The TLS Feature is a SEQUENCE of INTEGER. Get the length of the SEQUENCE\n          extn_len=2*$(hex2dec \"${extn:2:2}\")\n          # If the extension include the status_request (5), then it supports must staple.\n          if [[ \"${extn:4:extn_len}\" =~ 020105 ]]; then\n               supported=true\n          fi\n     fi\n\n     if \"$supported\"; then\n          if \"$provides_stapling\"; then\n               prln_svrty_good \"supported\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"supported\"\n          else\n               prln_svrty_high \"requires OCSP stapling (NOT ok)\"\n               fileout \"${jsonID}${json_postfix}\" \"HIGH\" \"extension detected but no OCSP stapling provided\"\n          fi\n     else\n          outln \"--\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"--\"\n     fi\n     return 0\n}\n\n# TODO: This function checks for Certificate Transparency support based on RFC 6962.\n# It will need to be updated to add checks for Certificate Transparency support based on 6962bis.\n# return values are results, no error conditions\ncertificate_transparency() {\n     local cert_txt=\"$1\"\n     local ocsp_response=\"$2\"\n     local -i number_of_certificates=$3\n     local cipher=\"$4\"\n     local sni_used=\"$5\"\n     local tls_version=\"$6\"\n     local sni=\"\"\n     local ciphers=\"\"\n     local extra_extns=\"\"\n     local -i success\n     # Cipher suites that use a certificate with an RSA (signature) public key\n     local -r a_rsa=\"cc,13, cc,15, c0,30, c0,28, c0,14, 00,9f, cc,a8, cc,aa, c0,a3, c0,9f, 00,6b, 00,39, c0,77, 00,c4, 00,88, c0,45, c0,4d, c0,53, c0,61, c0,7d, c0,8b, 16,b7, 16,b9, c0,2f, c0,27, c0,13, 00,9e, c0,a2, c0,9e, 00,67, 00,33, c0,76, 00,be, 00,9a, 00,45, c0,44, c0,4c, c0,52, c0,60, c0,7c, c0,8a, c0,11, c0,12, 00,16, 00,15, 00,14, c0,10\"\n     # Cipher suites that use a certificate with an RSA (encryption) public key\n     local -r e_rsa=\"00,b7, c0,99, 00,ad, cc,ae, 00,9d, c0,a1, c0,9d, 00,3d, 00,35, 00,c0, 00,84, 00,95, c0,3d, c0,51, c0,69, c0,6f, c0,7b, c0,93, ff,01, 00,ac, c0,a0, c0,9c, 00,9c, 00,3c, 00,2f, 00,ba, 00,b6, 00,96, 00,41, c0,98, 00,07, 00,94, c0,3c, c0,50, c0,68, c0,6e, c0,7a, c0,92, 00,05, 00,04, 00,92, 00,0a, 00,93, fe,ff, ff,e0, 00,62, 00,09, 00,61, fe,fe, ff,e1, 00,64, 00,60, 00,08, 00,06, 00,03, 00,b9, 00,b8, 00,2e, 00,3b, 00,02, 00,01, ff,00\"\n     # Cipher suites that use a certificate with a DSA public key\n     local -r a_dss=\"00,a3, 00,6a, 00,38, 00,c3, 00,87, c0,43, c0,57, c0,81, 00,a2, 00,40, 00,32, 00,bd, 00,99, 00,44, c0,42, c0,56, c0,80, 00,66, 00,13, 00,63, 00,12, 00,65, 00,11\"\n     # Cipher suites that use a certificate with a DH public key\n     local -r a_dh=\"00,a5, 00,a1, 00,69, 00,68, 00,37, 00,36, 00,c2, 00,c1, 00,86, 00,85, c0,3f, c0,41, c0,55, c0,59, c0,7f, c0,83, 00,a4, 00,a0, 00,3f, 00,3e, 00,31, 00,30, 00,bc, 00,bb, 00,98, 00,97, 00,43, 00,42, c0,3e, c0,40, c0,54, c0,58, c0,7e, c0,82, 00,10, 00,0d, 00,0f, 00,0c, 00,0b, 00,0e\"\n     # Cipher suites that use a certificate with an ECDH public key\n     local -r a_ecdh=\"c0,32, c0,2e, c0,2a, c0,26, c0,0f, c0,05, c0,79, c0,75, c0,4b, c0,4f, c0,5f, c0,63, c0,89, c0,8d, c0,31, c0,2d, c0,29, c0,25, c0,0e, c0,04, c0,78, c0,74, c0,4a, c0,4e, c0,5e, c0,62, c0,88, c0,8c, c0,0c, c0,02, c0,0d, c0,03, c0,0b, c0,01\"\n     # Cipher suites that use a certificate with an ECDSA public key\n     local -r a_ecdsa=\"cc,14, c0,2c, c0,24, c0,0a, cc,a9, c0,af, c0,ad, c0,73, c0,49, c0,5d, c0,87, 16,b8, 16,ba, c0,2b, c0,23, c0,09, c0,ae, c0,ac, c0,72, c0,48, c0,5c, c0,86, c0,07, c0,08, c0,06\"\n     # Cipher suites that use a certificate with a GOST public key\n     local -r a_gost=\"00,80, 00,81, 00,82, 00,83\"\n\n     CERTIFICATE_TRANSPARENCY_SOURCE=\"\"\n\n     # First check whether signed certificate timestamps (SCT) are included in the\n     # server's certificate. If they aren't, check whether the server provided\n     # a stapled OCSP response with SCTs. If no SCTs were found in the certificate\n     # or OCSP response, check for an SCT TLS extension.\n     if [[ \"$cert_txt\" =~ CT\\ Precertificate\\ SCTs ]] || [[ \"$cert_txt\" =~ '1.3.6.1.4.1.11129.2.4.2' ]]; then\n          CERTIFICATE_TRANSPARENCY_SOURCE=\"certificate extension\"\n          return 0\n     fi\n     if [[ \"$ocsp_response\" =~ CT\\ Certificate\\ SCTs ]] || [[ \"$ocsp_response\" =~ '1.3.6.1.4.1.11129.2.4.5' ]]; then\n          CERTIFICATE_TRANSPARENCY_SOURCE=\"OCSP extension\"\n          return 0\n     fi\n\n     # If the server only has one certificate, then it is sufficient to check whether\n     # determine_tls_extensions() discovered an SCT TLS extension. If the server has more than\n     # one certificate, then it is possible that an SCT TLS extension is returned for some\n     # certificates, but not for all of them.\n     if [[ $number_of_certificates -eq 1 ]] && [[ \"$TLS_EXTENSIONS\" =~ signed\\ certificate\\ timestamps ]]; then\n          CERTIFICATE_TRANSPARENCY_SOURCE=\"TLS extension\"\n          return 0\n     fi\n\n     if [[ $number_of_certificates -gt 1 ]] && ! \"$SSL_NATIVE\"; then\n          if [[ \"$tls_version\" == 0304 ]]; then\n               ciphers=\", 13,01, 13,02, 13,03, 13,04, 13,05, c0,b4, c0,b5\"\n               if [[ \"$cipher\" == tls1_3_RSA ]]; then\n                    extra_extns=\", 00,0d,00,10,00,0e,08,04,08,05,08,06,04,01,05,01,06,01,02,01\"\n               elif [[ \"$cipher\" == tls1_3_ECDSA ]]; then\n                    extra_extns=\", 00,0d,00,0a,00,08,04,03,05,03,06,03,02,03\"\n               else\n                    return 1\n               fi\n          else\n               [[ \"$cipher\" =~ aRSA ]] && ciphers+=\", $a_rsa\"\n               [[ \"$cipher\" =~ eRSA ]] && ciphers+=\", $e_rsa\"\n               [[ \"$cipher\" =~ aDSS ]] && ciphers+=\", $a_dss\"\n               [[ \"$cipher\" =~ aDH ]] && ciphers+=\", $a_dh\"\n               [[ \"$cipher\" =~ aECDH ]] && ciphers+=\", $a_ecdh\"\n               [[ \"$cipher\" =~ aECDSA ]] && ciphers+=\", $a_ecdsa\"\n               [[ \"$cipher\" =~ aGOST ]] && ciphers+=\", $a_gost\"\n\n               [[ -z \"$ciphers\" ]] && return 1\n               ciphers+=\", 00,ff\"\n          fi\n          [[ -z \"$sni_used\" ]] && sni=\"$SNI\" && SNI=\"\"\n          tls_sockets \"${tls_version:2:2}\" \"${ciphers:2}\" \"all\" \"00,12,00,00$extra_extns\"\n          success=$?\n          [[ -z \"$sni_used\" ]] && SNI=\"$sni\"\n          if [[ $success -eq 0 || $success -eq 2 ]] && \\\n             grep -a 'TLS server extension ' \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\" | \\\n             grep -aq \"signed certificate timestamps\"; then\n               CERTIFICATE_TRANSPARENCY_SOURCE=\"TLS extension\"\n               return 0\n          fi\n     fi\n\n     if [[ $SERVICE != HTTP ]] && [[ \"$CLIENT_AUTH\" != required ]]; then\n          # At the moment Certificate Transparency only applies to HTTPS.\n          CERTIFICATE_TRANSPARENCY_SOURCE=\"N/A\"\n     else\n          CERTIFICATE_TRANSPARENCY_SOURCE=\"--\"\n     fi\n     return 0\n}\n\n# Shortcut for $OPENSSL x509 -noout -in $cert $ossl_command\n# arg1 is the certificate\n# arg2 is -serial | -fingerprint -sha1 | -fingerprint -sha256\n# returns the serial or fingerprint as ASCII\n#\ndetermine_cert_fingerprint_serial() {\n     local cert=\"$1\"\n     local ossl_command=\"$2\"\n     local result=\"\"\n\n     result=\"$($OPENSSL x509 -noout $ossl_command 2>>$ERRFILE <<< \"$cert\")\"\n     # remove strings in text output, colon only appear in fingerprints\n     result=\"${result//Fingerprint=}\"\n     result=\"${result//serial=}\"\n     result=\"${result//:/}\"\n     result=\"${result//SHA1 /}\"\n     result=\"${result//sha1 /}\"\n     result=\"${result//SHA256 /}\"\n     result=\"${result//sha256 /}\"\n     # When the serial number is too large we'll get a 0x0a LF after 70 ASCII chars (see #2010).\n     # Thus we clean them here so that it is displayed correctly.\n     result=\"${result/[$'\\n\\r']/}\"\n     result=\"${result//[\\\\]/}\"\n     safe_echo \"$result\"\n}\n\n# Returns startdate, enddate, diffseconds, days2expire as CSVs as strings\n# arg1: human readable text string for certificate (openssl x509 -text -noout)\n#\ndetermine_dates_certificate() {\n     local cert_txt=\"$1\"\n     local startdate enddate yearnow y m d yearstart clockstart yearend clockend\n     local diffseconds=0 days2expire=0\n     local -i secsaday=86400\n\n     startdate=\"${cert_txt#*Validity*Not Before: }\"\n     # FreeBSD + OSX can't swallow the leading blank:\n     startdate=\"${startdate%%GMT*}GMT\"\n     enddate=\"${cert_txt#*Validity*Not Before: *Not After : }\"\n     enddate=\"${enddate%%GMT*}GMT\"\n     # Now we have a normalized enddate and startdate like \"Feb 27 10:03:20 2017 GMT\" -- also for OpenBSD\n     if \"$HAS_OPENBSDDATE\"; then\n          # Best we want to do under old versions of OpenBSD, first just remove the GMT and keep start/endate for later output\n          startdate=\"$(parse_date \"$startdate\" \"+%s\")\"\n          enddate=\"$(parse_date \"$enddate\" \"+%s\")\"\n          # Now we extract a date block and a time block which we need for later output\n          startdate=\"$(parse_date \"$startdate\" +\"%F %H:%M\" \"%b %d %T %Y %Z\")\"\n          enddate=\"$(parse_date \"$enddate\" +\"%F %H:%M\" \"%b %d %T %Y %Z\")\"\n          read -r yearstart clockstart <<< \"$startdate\"\n          read -r yearend clockend <<< \"$enddate\"\n          debugme echo \"$yearstart, $clockstart\"\n          debugme echo \"$yearend, $clockend\"\n          y=$(( ${yearend:0:4} - ${yearstart:0:4} ))\n          m=$(( ${yearend:5:1} - ${yearstart:5:1} + ${yearend:6:1} - ${yearstart:6:1} ))\n          d=$(( ${yearend:8:2} - ${yearstart:8:2} ))\n          # We take the year, month, days here as old OpenBSD's date is too difficult for real conversion\n          # see comment in parse_date(). In diffseconds then we have the estimated absolute validity period\n          diffseconds=$(( d + ((m*30)) + ((y*365)) ))\n          diffseconds=$((diffseconds * secsaday))\n          # Now we estimate the days left plus length of month/year:\n          yearnow=\"$(date -juz GMT \"+%Y-%m-%d %H:%M\")\"\n          y=$(( ${yearend:0:4} - ${yearnow:0:4} ))\n          m=$(( ${yearend:5:1} - ${yearnow:5:1} + ${yearend:6:1} - ${yearnow:6:1} ))\n          d=$(( ${yearend:8:2} - ${yearnow:8:2} ))\n          days2expire=$(( d + ((m*30)) + ((y*365)) ))\n     else\n          startdate=\"$(parse_date \"$startdate\" +\"%F %H:%M\" \"%b %d %T %Y %Z\")\"\n          enddate=\"$(parse_date \"$enddate\" +\"%F %H:%M\" \"%b %d %T %Y %Z\")\"\n          days2expire=$(( $(parse_date \"$enddate\" \"+%s\" $'%F %H:%M') - $(LC_ALL=C date \"+%s\") ))  # first in seconds\n          days2expire=$((days2expire / secsaday))\n          diffseconds=$(( $(parse_date \"$enddate\" \"+%s\" $'%F %H:%M') - $(parse_date \"$startdate\" \"+%s\" $'%F %H:%M') ))\n     fi\n     safe_echo \"$startdate,$enddate,$diffseconds,$days2expire,$yearstart\"\n}\n\n\n\ncertificate_info() {\n     local proto\n     local -i certificate_number=$1\n     local -i number_of_certificates=$2\n     local cert_txt=\"$3\"\n     local intermediates=\"$4\"\n     local cipher=$5\n     local cert_keysize=$6\n     local cert_type=\"$7\"\n     local ocsp_response_binary=\"$8\"\n     local ocsp_response=$9\n     local ocsp_response_status=${10}\n     local sni_used=\"${11}\"\n     local ct=\"${12}\"\n     local certificate_list_ordering_problem=\"${13}\"\n     local cert_sig_algo cert_sig_hash_algo cert_key_algo cert_spki_info\n     local hostcert=\"\"\n     local common_primes_file=\"$TESTSSL_INSTALL_DIR/etc/common-primes.txt\"\n     local -i lineno_matched=0\n     local cert_keyusage cert_ext_keyusage short_keyAlgo\n     local outok=true\n     local days2expire ocsp_uri crl\n     local startdate enddate issuer_CN issuer_C issuer_O issuer sans san all_san=\"\" cn\n     local issuer_DC issuerfinding cn_nosni=\"\"\n     local cert_fingerprint_sha1 cert_fingerprint_sha2 cert_serial cert\n     local -a intermediate_certs_txt=()\n     local policy_oid\n     local spaces=\"\"\n     local -i trust_sni=0 trust_nosni=0 diffseconds=0\n     local has_dns_sans has_dns_sans_nosni\n     local trust_sni_finding\n     local -i i certificates_provided=0\n     local cn_finding trustfinding trustfinding_nosni\n     local cnok=\"OK\"\n     local expfinding expok=\"OK\"\n     local -i ret=0 tmp=0\n     local json_postfix=\"\"                   # string to place at the end of JSON IDs when there is more than one certificate\n     local jsonID=\"\"                         # string to place at beginning of JSON IDs\n     local json_rating json_msg\n     local indent=\"\"\n     local days2warn2=$DAYS2WARN2\n     local days2warn1=$DAYS2WARN1\n     local provides_stapling=false\n     local caa_node=\"\" all_caa=\"\" caa_property_name=\"\" caa_property_value=\"\"\n     local response=\"\"\n     local yearstart\n     local gt_398=false gt_398warn=false\n     local gt_825=false gt_825warn=false\n     local -i secsaday=86400\n     local first=true\n     local badocsp=1\n     local len_cert_serial=0\n\n     if [[ $number_of_certificates -gt 1 ]]; then\n          [[ $certificate_number -eq 1 ]] && outln\n          indent=\"  \"\n          out \"$indent\"\n          pr_headline \"Server Certificate #$certificate_number\"\n          [[ -z \"$sni_used\" ]] && pr_underline \" (in response to request w/o SNI)\"\n          outln\n          json_postfix=\" <hostCert#${certificate_number}>\"\n          spaces=\"                                \"\n     else\n          spaces=\"                              \"\n     fi\n\n     GOOD_CA_BUNDLE=\"\"\n     cert_sig_algo=\"$(awk -F':' '/Signature Algorithm/ { print $2; if (++Match >= 1) exit; }' <<< \"$cert_txt\")\"\n     cert_sig_algo=\"${cert_sig_algo// /}\"\n     case \"$cert_sig_algo\" in\n          1.3.101.112|ED25519) cert_sig_algo=\"Ed25519\" ;;\n          1.3.101.113|ED448)   cert_sig_algo=\"Ed448\" ;;\n     esac\n     cert_key_algo=\"$(awk -F':' '/Public Key Algorithm:/ { print $2; if (++Match >= 1) exit; }' <<< \"$cert_txt\")\"\n     cert_key_algo=\"${cert_key_algo// /}\"\n     case \"$cert_key_algo\" in\n          1.3.101.112|E[Dd]25519) cert_key_algo=\"Ed25519\"; cert_keysize=253 ;;\n          1.3.101.113|E[Dd]448)   cert_key_algo=\"Ed448\"; cert_keysize=456 ;;\n     esac\n\n     out \"$indent\" ; pr_bold \" Signature Algorithm          \"\n     jsonID=\"cert_signatureAlgorithm\"\n     case $cert_sig_algo in\n          sha1WithRSA|sha1WithRSAEncryption)\n               pr_svrty_medium \"SHA1 with RSA\"\n               if [[ \"$SERVICE\" == HTTP ]] || \"$ASSUME_HTTP\"; then\n                    out \" -- besides: users will receive a \"; pr_svrty_high \"strong browser WARNING\"\n               fi\n               outln\n               fileout \"${jsonID}${json_postfix}\" \"MEDIUM\" \"SHA1 with RSA\"\n               set_grade_cap \"T\" \"Uses SHA1 algorithm\"\n               ;;\n          sha224WithRSAEncryption)\n               outln \"SHA224 with RSA\"\n               fileout \"${jsonID}${json_postfix}\" \"INFO\" \"SHA224 with RSA\"\n               ;;\n          sha256WithRSAEncryption)\n               prln_svrty_good \"SHA256 with RSA\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"SHA256 with RSA\"\n               ;;\n          sha384WithRSAEncryption)\n               prln_svrty_good \"SHA384 with RSA\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"SHA384 with RSA\"\n               ;;\n          sha512WithRSAEncryption)\n               prln_svrty_good \"SHA512 with RSA\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"SHA512 with RSA\"\n               ;;\n          ecdsa-with-SHA1)\n               prln_svrty_medium \"ECDSA with SHA1\"\n               fileout \"${jsonID}${json_postfix}\" \"MEDIUM\" \"ECDSA with SHA1\"\n               set_grade_cap \"T\" \"Uses SHA1 algorithm\"\n               ;;\n          ecdsa-with-SHA224)\n               outln \"ECDSA with SHA224\"\n               fileout \"${jsonID}${json_postfix}\" \"INFO\" \"ECDSA with SHA224\"\n               ;;\n          ecdsa-with-SHA256)\n               prln_svrty_good \"ECDSA with SHA256\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"ECDSA with SHA256\"\n               ;;\n          ecdsa-with-SHA384)\n               prln_svrty_good \"ECDSA with SHA384\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"ECDSA with SHA384\"\n               ;;\n          ecdsa-with-SHA512)\n               prln_svrty_good \"ECDSA with SHA512\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"ECDSA with SHA512\"\n               ;;\n          dsaWithSHA1)\n               prln_svrty_medium \"DSA with SHA1\"\n               fileout \"${jsonID}${json_postfix}\" \"MEDIUM\" \"DSA with SHA1\"\n               set_grade_cap \"T\" \"Uses SHA1 algorithm\"\n               ;;\n          dsa_with_SHA224)\n               outln \"DSA with SHA224\"\n               fileout \"${jsonID}${json_postfix}\" \"INFO\" \"DSA with SHA224\"\n               ;;\n          dsa_with_SHA256)\n               prln_svrty_good \"DSA with SHA256\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"DSA with SHA256\"\n               ;;\n          rsassaPss)\n               cert_sig_hash_algo=\"$(awk '/Signature Algorithm/ { getline; print $0; exit }' <<< \"$cert_txt\" | sed 's/^.*Hash Algorithm: //')\"\n               case $cert_sig_hash_algo in\n                    sha1)\n                         prln_svrty_medium \"RSASSA-PSS with SHA1\"\n                         fileout \"${jsonID}${json_postfix}\" \"MEDIUM\" \"RSASSA-PSS with SHA1\"\n                         set_grade_cap \"T\" \"Uses SHA1 algorithm\"\n                         ;;\n                    sha224)\n                         outln \"RSASSA-PSS with SHA224\"\n                         fileout \"${jsonID}${json_postfix}\" \"INFO\" \"RSASSA-PSS with SHA224\"\n                         ;;\n                    sha256)\n                         prln_svrty_good \"RSASSA-PSS with SHA256\"\n                         fileout \"${jsonID}${json_postfix}\" \"OK\" \"RSASSA-PSS with SHA256\"\n                         ;;\n                    sha384)\n                         prln_svrty_good \"RSASSA-PSS with SHA384\"\n                         fileout \"${jsonID}${json_postfix}\" \"OK\" \"RSASSA-PSS with SHA384\"\n                         ;;\n                    sha512)\n                         prln_svrty_good \"RSASSA-PSS with SHA512\"\n                         fileout \"${jsonID}${json_postfix}\" \"OK\" \"RSASSA-PSS with SHA512\"\n                         ;;\n                    *)\n                         out \"RSASSA-PSS with $cert_sig_hash_algo\"\n                         prln_warning \" (Unknown hash algorithm)\"\n                         fileout \"${jsonID}${json_postfix}\" \"DEBUG\" \"RSASSA-PSS with $cert_sig_hash_algo\"\n                    esac\n                    ;;\n          md2*)\n               prln_svrty_critical \"MD2\"\n               fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"MD2\"\n               set_grade_cap \"F\" \"Supports a insecure signature (MD2)\"\n               ;;\n          md4*)\n               prln_svrty_critical \"MD4\"\n               fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"MD4\"\n               ;;\n          md5*)\n               prln_svrty_critical \"MD5\"\n               fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"MD5\"\n               set_grade_cap \"F\" \"Supports a insecure signature (MD5)\"\n               ;;\n          Ed25519|Ed448)\n               prln_svrty_good \"$cert_sig_algo\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"$cert_sig_algo\"\n               ;;\n          *)\n               out \"$cert_sig_algo (\"\n               pr_warning \"FIXME: can't tell whether this is good or not\"\n               outln \")\"\n               fileout \"${jsonID}${json_postfix}\" \"DEBUG\" \"$cert_sig_algo\"\n               ((ret++))\n               ;;\n     esac\n     # old, but still interesting: https://blog.hboeck.de/archives/754-Playing-with-the-EFF-SSL-Observatory.html\n\n     out \"$indent\"; pr_bold \" Server key size              \"\n     jsonID=\"cert_keySize\"\n     if [[ -z \"$cert_keysize\" ]]; then\n          outln \"(couldn't determine)\"\n          fileout \"${jsonID}${json_postfix}\" \"cannot be determined\"\n          ((ret++))\n     else\n          case $cert_key_algo in\n               *RSA*|*rsa*)             short_keyAlgo=\"RSA\";;\n               *ecdsa*|*ecPublicKey)    short_keyAlgo=\"EC\";;\n               *Ed25519*|*Ed448*)       short_keyAlgo=\"EdDSA\";;\n               *DSA*|*dsa*)             short_keyAlgo=\"DSA\";;\n               *GOST*|*gost*)           short_keyAlgo=\"GOST\";;\n               *dh*|*DH*)               short_keyAlgo=\"DH\" ;;\n               *)                       pr_fixme \"don't know $cert_key_algo \"\n                                        ((ret++)) ;;\n          esac\n          out \"$short_keyAlgo \"\n          # https://tools.ietf.org/html/rfc4492,  https://www.keylength.com/en/compare/\n          # https://doi.org/10.1007/s00145-001-0009-4\n          # see https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-4/final\n          # Table 2 @ chapter 5.6.1 (~ p66)\n          if [[ $cert_key_algo =~ ecdsa ]] || [[ $cert_key_algo =~ ecPublicKey ]]; then\n               if [[ \"$cert_keysize\" -le 110 ]]; then       # a guess\n                    pr_svrty_critical \"$cert_keysize\"\n                    json_rating=\"CRITICAL\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 123 ]]; then     # a guess\n                    pr_svrty_high \"$cert_keysize\"\n                    json_rating=\"HIGH\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 163 ]]; then\n                    pr_svrty_medium \"$cert_keysize\"\n                    json_rating=\"MEDIUM\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 224 ]]; then\n                    out \"$cert_keysize\"\n                    json_rating=\"INFO\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 533 ]]; then\n                    pr_svrty_good \"$cert_keysize\"\n                    json_rating=\"OK\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               else\n                    out \"keysize: $cert_keysize (not expected, FIXME)\"\n                    json_rating=\"DEBUG\"; json_msg=\" $short_keyAlgo $cert_keysize bits (not expected)\"\n                    ((ret++))\n               fi\n               out \" bits\"\n\n               set_key_str_score \"$short_keyAlgo\" \"$cert_keysize\"\n          elif [[ $cert_key_algo =~ RSA ]] || [[ $cert_key_algo =~ rsa ]] || [[ $cert_key_algo =~ dsa ]] || \\\n               [[ $cert_key_algo =~ dhKeyAgreement ]] || [[ $cert_key_algo == X9.42\\ DH ]]; then\n               if [[ \"$cert_keysize\" -le 512 ]]; then\n                    pr_svrty_critical \"$cert_keysize\"\n                    out \" bits\"\n                    json_rating=\"CRITICAL\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 768 ]]; then\n                    pr_svrty_high \"$cert_keysize\"\n                    out \" bits\"\n                    json_rating=\"HIGH\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 1024 ]]; then\n                    pr_svrty_medium \"$cert_keysize\"\n                    out \" bits\"\n                    json_rating=\"MEDIUM\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 2048 ]]; then\n                    out \"$cert_keysize bits\"\n                    json_rating=\"INFO\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n               elif [[ \"$cert_keysize\" -le 4096 ]]; then\n                    pr_svrty_good \"$cert_keysize\"\n                    json_rating=\"OK\"; json_msg=\"$short_keyAlgo $cert_keysize bits\"\n                    out \" bits\"\n               else\n                    pr_warning \"weird key size: $cert_keysize bits\"; out \" (could cause compatibility problems)\"\n                    json_rating=\"WARN\"; json_msg=\"$short_keyAlgo $cert_keysize bits (Odd)\"\n                    ((ret++))\n               fi\n\n               set_key_str_score \"$short_keyAlgo\" \"$cert_keysize\"\n          elif [[ $cert_key_algo == Ed* ]]; then\n               pr_svrty_good \"$cert_key_algo\"\n               json_rating=\"OK\"; json_msg=\"$short_keyAlgo $cert_key_algo\"\n               set_key_str_score \"$short_keyAlgo\" \"$cert_keysize\"\n          else\n               out \"$cert_key_algo + $cert_keysize bits (\"\n               pr_warning \"FIXME: can't tell whether this is good or not\"\n               out \")\"\n               json_rating=\"WARN\"; json_msg=\"Server keys $cert_keysize bits, unknown public key algorithm $cert_key_algo\"\n               ((ret++))\n          fi\n     fi\n\n     case \"$short_keyAlgo\" in\n          \"RSA\") cert_spki_info=\"${cert_txt##*Subject Public Key Info:}\"\n                 cert_spki_info=\"${cert_spki_info##*Public Key Algorithm:}\"\n                 cert_spki_info=\"${cert_spki_info#*Exponent:}\"\n                 cert_spki_info=\"$(strip_leading_space \"$cert_spki_info\")\"\n                 cert_spki_info=\"${cert_spki_info%%[[:space:]]*}\"\n                 if [[ -n \"$cert_spki_info\" ]]; then\n                      if [[ $cert_spki_info -eq 1 ]]; then\n                           out \" (exponent is \"; pr_svrty_critical \"$cert_spki_info\"; out \")\"\n                           json_rating=\"CRITICAL\"\n                           set_grade_cap \"F\" \"RSA certificate uses exponent of 1\"\n                      else\n                           out \" (exponent is $cert_spki_info)\"\n                      fi\n                      json_msg+=\" (exponent is $cert_spki_info)\"\n                 fi\n                 ;;\n          \"EC\")  cert_spki_info=\"${cert_txt##*Subject Public Key Info:}\"\n                 cert_spki_info=\"${cert_spki_info##*Public Key Algorithm:}\"\n                 cert_spki_info=\"${cert_spki_info##*ASN1 OID: }\"\n                 [[ \"$cert_spki_info\" =~ NIST\\ CURVE:\\  ]] && cert_spki_info=\"${cert_spki_info##*NIST CURVE: }\"\n                 cert_spki_info=\"${cert_spki_info%%[[:space:]]*}\"\n                 cert_spki_info=\"$(strip_lf \"$(strip_spaces \"$cert_spki_info\")\")\"\n                 if [[ -n \"$cert_spki_info\" ]]; then\n                      out \" (curve $cert_spki_info)\"\n                      json_msg+=\" (curve $cert_spki_info)\"\n                 fi\n                 ;;\n          \"DH\")  if [[ -s \"$common_primes_file\" ]]; then\n                      cert_spki_info=\"${cert_txt##*Subject Public Key Info:}\"\n                      cert_spki_info=\"${cert_spki_info##*Public Key Algorithm:}\"\n                      cert_spki_info=\"$(awk '/prime:|P:/,/generator:|G:/' <<< \"$cert_spki_info\" | grep -Ev \"prime|P:|generator|G:\")\"\n                      cert_spki_info=\"$(strip_spaces \"$(colon_to_spaces \"$(newline_to_spaces \"$cert_spki_info\")\")\")\"\n                      [[ \"${cert_spki_info:0:2}\" == 00 ]] && cert_spki_info=\"${cert_spki_info:2}\"\n                      cert_spki_info=\"$(toupper \"$cert_spki_info\")\"\n                      lineno_matched=$(grep -n \"$cert_spki_info\" \"$common_primes_file\" 2>/dev/null | awk -F':' '{ print $1 }')\n                      if [[ \"$lineno_matched\" -ne 0 ]]; then\n                           cert_spki_info=\"$(awk \"NR == $lineno_matched-1\" \"$common_primes_file\" | awk -F'\"' '{ print $2 }')\"\n                           out \" ($cert_spki_info)\"\n                           json_msg+=\" ($cert_spki_info)\"\n                      fi\n                 fi\n                 ;;\n     esac\n     outln\n     fileout \"${jsonID}${json_postfix}\" \"$json_rating\" \"$json_msg\"\n\n     out \"$indent\"; pr_bold \" Server key usage             \";\n     outok=true\n     jsonID=\"cert_keyUsage\"\n     cert_keyusage=\"$(strip_leading_space \"$(awk '/X509v3 Key Usage:/ { getline; print $0 }' <<< \"$cert_txt\")\")\"\n     if [[ -n \"$cert_keyusage\" ]]; then\n          outln \"$cert_keyusage\"\n          if [[ \" $cert_type \" =~ \\ RSASig\\  || \" $cert_type \" =~ \\ DSA\\  || \" $cert_type \" =~ \\ ECDSA\\  || \" $cert_type \" =~ \\ EdDSA\\  ]] && \\\n             [[ ! \"$cert_keyusage\" =~ Digital\\ Signature ]]; then\n               prln_svrty_high \"$indent                              Certificate incorrectly used for digital signatures\"\n               fileout \"${jsonID}${json_postfix}\" \"HIGH\" \"Certificate incorrectly used for digital signatures: \\\"$cert_keyusage\\\"\"\n               outok=false\n          fi\n          if [[ \" $cert_type \" =~ \\ RSAKMK\\  ]] && [[ ! \"$cert_keyusage\" =~ Key\\ Encipherment ]]; then\n               prln_svrty_high \"$indent                              Certificate incorrectly used for key encipherment\"\n               fileout \"${jsonID}${json_postfix}\" \"HIGH\" \"Certificate incorrectly used for key encipherment: \\\"$cert_keyusage\\\"\"\n               outok=false\n          fi\n          if [[ \" $cert_type \" =~ \\ DH\\  || \" $cert_type \" =~ \\ ECDH\\  ]] && \\\n             [[ ! \"$cert_keyusage\" =~ Key\\ Agreement ]]; then\n               prln_svrty_high \"$indent                              Certificate incorrectly used for key agreement\"\n               fileout \"${jsonID}${json_postfix}\" \"HIGH\" \"Certificate incorrectly used for key agreement: \\\"$cert_keyusage\\\"\"\n               outok=false\n          fi\n     else\n          outln \"--\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"No server key usage information\"\n          outok=false\n     fi\n     if \"$outok\"; then\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$cert_keyusage\"\n     fi\n\n     out \"$indent\"; pr_bold \" Server extended key usage    \";\n     jsonID=\"cert_extKeyUsage\"\n     outok=true\n     cert_ext_keyusage=\"$(strip_leading_space \"$(awk '/X509v3 Extended Key Usage:/ { getline; print $0 }' <<< \"$cert_txt\")\")\"\n     if [[ -n \"$cert_ext_keyusage\" ]]; then\n          outln \"$cert_ext_keyusage\"\n          if [[ ! \"$cert_ext_keyusage\" =~ \"TLS Web Server Authentication\" ]] && [[ ! \"$cert_ext_keyusage\" =~ \"Any Extended Key Usage\" ]]; then\n               prln_svrty_high \"$indent                              Certificate incorrectly used for TLS Web Server Authentication\"\n               fileout \"${jsonID}${json_postfix}\" \"HIGH\" \"Certificate incorrectly used for TLS Web Server Authentication: \\\"$cert_ext_keyusage\\\"\"\n               outok=false\n          fi\n     else\n          outln \"--\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"No server extended key usage information\"\n          outok=false\n     fi\n     if \"$outok\"; then\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$cert_ext_keyusage\"\n     fi\n\n     hostcert=\"$(<$HOSTCERT)\"\n\n     out \"$indent\"; pr_bold \" Serial                       \"\n     cert_serial=\"$(determine_cert_fingerprint_serial \"$hostcert\" \"-serial\")\"\n     fileout \"cert_serialNumber${json_postfix}\" \"INFO\" \"$cert_serial\"\n     out \"$cert_serial\"\n\n     len_cert_serial=${#cert_serial}\n     len_cert_serial=$(( len_cert_serial / 2 ))\n\n     if [[ $len_cert_serial -gt 20 ]]; then\n          # https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.2\n          outln\n          prln_svrty_low \"${spaces}NOT ok: length must not exceed 20 bytes (is: $len_cert_serial bytes)\"\n          fileout \"cert_serialNumberLen${json_postfix}\" \"LOW\" \"$len_cert_serial is too long\"\n     elif [[ $len_cert_serial -lt 8 ]] && [[ $SERVICE == HTTP ]]; then\n          # We only want this check for browsers as this requirement comes from the CA browser forum,\n          # see e.g. https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.8.0.pdf\n          prln_svrty_low \"   NOT ok: length should be >= 64 bits entropy (is: $len_cert_serial bytes)\"\n          fileout \"cert_serialNumberLen${json_postfix}\" \"LOW\" \"$len_cert_serial is not enough entropy\"\n     else\n          outln \" (OK: length $len_cert_serial)\"\n          fileout \"cert_serialNumberLen${json_postfix}\" \"INFO\" \"$len_cert_serial\"\n     fi\n\n     out \"$indent\"; pr_bold \" Fingerprints                 \"\n     cert_fingerprint_sha1=\"$(determine_cert_fingerprint_serial \"$hostcert\" \"-fingerprint -sha1\")\"\n     outln \"SHA1 $cert_fingerprint_sha1\"\n     fileout \"cert_fingerprintSHA1${json_postfix}\" \"INFO\" \"${cert_fingerprint_sha1}\"\n\n     cert_fingerprint_sha2=\"$(determine_cert_fingerprint_serial \"$hostcert\" \"-fingerprint -sha256\")\"\n     fileout \"cert_fingerprintSHA256${json_postfix}\" \"INFO\" \"${cert_fingerprint_sha2}\"\n     outln \"${spaces}SHA256 ${cert_fingerprint_sha2}\"\n\n     fileout \"cert${json_postfix}\" \"INFO\" \"$(pem_to_one_line \"$hostcert\")\"\n\n     [[ -z $CERT_FINGERPRINT_SHA2 ]] && \\\n          CERT_FINGERPRINT_SHA2=\"$cert_fingerprint_sha2\" ||\n          CERT_FINGERPRINT_SHA2=\"$cert_fingerprint_sha2 $CERT_FINGERPRINT_SHA2\"\n     [[ -z $RSA_CERT_FINGERPRINT_SHA2 ]] && \\\n          [[ $cert_key_algo =~ RSA || $cert_key_algo =~ rsa ]] &&\n          RSA_CERT_FINGERPRINT_SHA2=\"$cert_fingerprint_sha2\"\n\n     out \"$indent\"; pr_bold \" Common Name (CN)             \"\n     cn_finding=\"Common Name (CN) : \"\n     cn=\"$(get_cn_from_cert $HOSTCERT)\"\n     if [[ -n \"$cn\" ]]; then\n          pr_italic \"$cn\"\n          cn_finding=\"$cn\"\n     else\n          cn=\"no CN field in subject\"\n          out \"($cn)\"\n          cn_finding=\"$cn\"\n          cnok=\"INFO\"\n     fi\n     fileout \"cert_commonName${json_postfix}\" \"$cnok\" \"$cn_finding\"\n     cn_finding=\"\"\n\n     if [[ -n \"$sni_used\" ]]; then\n          if grep -qe '-----BEGIN' \"$HOSTCERT.nosni\"; then\n               cn_nosni=\"$(get_cn_from_cert \"$HOSTCERT.nosni\")\"\n               [[ -z \"$cn_nosni\" ]] && cn_nosni=\"no CN field in subject\"\n          fi\n          debugme tm_out \"\\\"$NODE\\\" | \\\"$cn\\\" | \\\"$cn_nosni\\\"\"\n     else\n          debugme tm_out \"\\\"$NODE\\\" | \\\"$cn\\\"\"\n     fi\n\n     if [[ -z \"$sni_used\" ]] || [[ \"$(toupper \"$cn_nosni\")\" == \"$(toupper \"$cn\")\" ]]; then\n          outln\n          cn_finding=\"$cn\"\n     elif [[ -z \"$cn_nosni\" ]]; then\n          out \" (request w/o SNI didn't succeed\";\n          cn_finding+=\"request w/o SNI didn't succeed\"\n          if [[ $cert_sig_algo =~ ecdsa ]]; then\n               out \", usual for EC certificates\"\n               cn_finding+=\", usual for EC certificates\"\n          fi\n          outln \")\"\n          cn_finding+=\"\"\n     elif [[ \"$cn_nosni\" == *\"no CN field\"* ]]; then\n          outln \", (request w/o SNI: $cn_nosni)\"\n          cn_finding=\"$cn_nosni\"\n     else\n          out \" (CN in response to request w/o SNI: \"; pr_italic \"$cn_nosni\"; outln \")\"\n          cn_finding=\"$cn_nosni\"\n     fi\n     fileout \"cert_commonName_wo_SNI${json_postfix}\" \"INFO\" \"$cn_finding\"\n\n     sans=$(grep -A2 \"Subject Alternative Name\" <<< \"$cert_txt\" | \\\n          grep -E \"DNS:|IP Address:|email:|URI:|DirName:|Registered ID:\" | tr ',' '\\n' | \\\n          sed -e 's/ *DNS://g' -e 's/ *IP Address://g' -e 's/ *email://g' -e 's/ *URI://g' -e 's/ *DirName://g' \\\n              -e 's/ *Registered ID://g' \\\n              -e 's/ *othername:<unsupported>//g' -e 's/ *X400Name:<unsupported>//g' -e 's/ *EdiPartyName:<unsupported>//g')\n          #           ^^^ CACert\n\n     out \"$indent\"; pr_bold \" subjectAltName (SAN)         \"\n     jsonID=\"cert_subjectAltName\"\n     if [[ -n \"$sans\" ]]; then\n          while read san; do\n               [[ -n \"$san\" ]] && all_san+=\"$san \"\n          done <<< \"$sans\"\n          prln_italic \"$(out_row_aligned_max_width \"$all_san\" \"$indent                              \" $TERM_WIDTH)\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$all_san\"\n     else\n          if [[ $SERVICE == HTTP ]] || \"$ASSUME_HTTP\"; then\n               pr_svrty_high \"missing (NOT ok)\"; outln \" -- Browsers are complaining\"\n               fileout \"${jsonID}${json_postfix}\" \"HIGH\" \"No SAN, browsers are complaining\"\n          else\n               pr_svrty_medium \"missing\"; outln \" -- no SAN is deprecated\"\n               fileout \"${jsonID}${json_postfix}\" \"MEDIUM\" \"Providing no SAN is deprecated\"\n          fi\n     fi\n\n     # Determine the issuer now as we need them for host certificate warning\n     issuer=\"$($OPENSSL x509 -noout -issuer -nameopt multiline,-align,sname,-esc_msb,utf8,-space_eq 2>>$ERRFILE <<< \"$hostcert\")\"\n     issuer_CN=\"$(awk -F'=' '/CN=/ { print $2 }' <<< \"$issuer\")\"\n     issuer_O=\"$(awk -F'=' '/O=/ { print $2 }' <<< \"$issuer\")\"\n     issuer_C=\"$(awk -F'=' '/ C=/ { print $2 }' <<< \"$issuer\")\"\n     issuer_DC=\"$(awk -F'=' '/DC=/ { print $2 }' <<< \"$issuer\")\"\n\n     out \"$indent\"; pr_bold \" Trust (hostname)             \"\n     compare_server_name_to_cert \"$HOSTCERT\"\n     trust_sni=$?\n\n     # Find out if the subjectAltName extension is present and contains\n     # a DNS name, since Section 6.3 of RFC 6125 says:\n     #      Security Warning: A client MUST NOT seek a match for a reference\n     #      identifier of CN-ID if the presented identifiers include a DNS-ID,\n     #      SRV-ID, URI-ID, or any application-specific identifier types\n     #      supported by the client.\n     has_dns_sans=$HAS_DNS_SANS\n\n     case $trust_sni in\n          0) trustfinding=\"certificate does not match supplied URI\"\n             set_grade_cap \"M\" \"Domain name mismatch\"\n             ;;\n          1) trustfinding=\"Ok via SAN\" ;;\n          2) trustfinding=\"Ok via SAN wildcard\" ;;\n          4) if \"$has_dns_sans\"; then\n                  trustfinding=\"via CN, but not SAN\"\n             else\n                  trustfinding=\"via CN only\"\n             fi\n             ;;\n          5) trustfinding=\"Ok via SAN and CN\" ;;\n          6) trustfinding=\"Ok via SAN wildcard and CN\"\n             ;;\n          8) if \"$has_dns_sans\"; then\n                  trustfinding=\"via CN wildcard, but not SAN\"\n             else\n                  trustfinding=\"via CN (wildcard) only\"\n             fi\n             ;;\n          9) trustfinding=\"Ok via CN wildcard and SAN\"\n             ;;\n         10) trustfinding=\"Ok via SAN wildcard and CN wildcard\"\n             ;;\n     esac\n\n     if [[ $trust_sni -eq 0 ]]; then\n          pr_svrty_high \"$trustfinding\"\n          trust_sni_finding=\"HIGH\"\n     elif [[ $trust_sni -eq 4 ]] || [[ $trust_sni -eq 8 ]]; then\n          if [[ $SERVICE == HTTP ]] || \"$ASSUME_HTTP\"; then\n               # https://bugs.chromium.org/p/chromium/issues/detail?id=308330\n               # https://bugzilla.mozilla.org/show_bug.cgi?id=1245280\n               # https://www.chromestatus.com/feature/4981025180483584\n               pr_svrty_high \"$trustfinding\"; out \" -- Browsers are complaining\"\n               trust_sni_finding=\"HIGH\"\n          else\n               pr_svrty_medium \"$trustfinding\"\n               trust_sni_finding=\"MEDIUM\"\n               # we punish CN matching for non-HTTP as it is deprecated https://tools.ietf.org/html/rfc2818#section-3.1\n               ! \"$has_dns_sans\" && out \" -- CN only match is deprecated\"\n          fi\n     else\n          pr_svrty_good \"$trustfinding\"\n          trust_sni_finding=\"OK\"\n     fi\n\n     if [[ -n \"$cn_nosni\" ]]; then\n          compare_server_name_to_cert \"$HOSTCERT.nosni\"\n          trust_nosni=$?\n          has_dns_sans_nosni=$HAS_DNS_SANS\n     fi\n\n     # See issue #733.\n     if [[ -z \"$sni_used\" ]]; then\n          trustfinding_nosni=\"\"\n     elif [[ $trust_sni -eq $trust_nosni && \"$has_dns_sans\" == \"$has_dns_sans_nosni\" ]] || \\\n          [[ $trust_sni -eq 0 && $trust_nosni -eq 0 ]]; then\n          trustfinding_nosni=\" (same w/o SNI)\"\n     elif [[ $trust_nosni -eq 0 ]]; then\n          if [[ $trust_sni -eq 4 ]] || [[ $trust_sni -eq 8 ]]; then\n               trustfinding_nosni=\" (w/o SNI: certificate does not match supplied URI)\"\n          else\n               trustfinding_nosni=\" (SNI mandatory)\"\n          fi\n     elif [[ $trust_nosni -eq 4 ]] || [[ $trust_nosni -eq 8 ]] || [[ $trust_sni -eq 4 ]] || [[ $trust_sni -eq 8 ]]; then\n          case $trust_nosni in\n               1) trustfinding_nosni=\" (w/o SNI: Ok via SAN)\" ;;\n               2) trustfinding_nosni=\" (w/o SNI: Ok via SAN wildcard)\" ;;\n               4) if \"$has_dns_sans_nosni\"; then\n                       trustfinding_nosni=\" (w/o SNI: via CN, but not SAN)\"\n                  else\n                       trustfinding_nosni=\" (w/o SNI: via CN only)\"\n                  fi\n                  ;;\n               5) trustfinding_nosni=\" (w/o SNI: Ok via SAN and CN)\" ;;\n               6) trustfinding_nosni=\" (w/o SNI: Ok via SAN wildcard and CN)\" ;;\n               8) if \"$has_dns_sans_nosni\"; then\n                       trustfinding_nosni=\" (w/o SNI: via CN wildcard, but not SAN)\"\n                  else\n                       trustfinding_nosni=\" (w/o SNI: via CN (wildcard) only)\"\n                  fi\n                  ;;\n               9) trustfinding_nosni=\" (w/o SNI: Ok via CN wildcard and SAN)\" ;;\n              10) trustfinding_nosni=\" (w/o SNI: Ok via SAN wildcard and CN wildcard)\" ;;\n          esac\n     elif [[ $trust_sni -ne 0 ]]; then\n          trustfinding_nosni=\" (works w/o SNI)\"\n     else\n          trustfinding_nosni=\" (however, works w/o SNI)\"\n     fi\n     if [[ -n \"$sni_used\" ]] || [[ $trust_nosni -eq 0 ]] || [[ $trust_nosni -ne 4 && $trust_nosni -ne 8 ]]; then\n          outln \"$trustfinding_nosni\"\n     elif [[ $SERVICE == HTTP ]] || \"$ASSUME_HTTP\"; then\n          prln_svrty_high \"$trustfinding_nosni\"\n     else\n          prln_svrty_medium \"$trustfinding_nosni\"\n     fi\n\n     fileout \"cert_trust${json_postfix}\" \"$trust_sni_finding\" \"${trustfinding}${trustfinding_nosni}\"\n\n     if [[ \"$trust_sni\" =~ ^(2|6|8|9|10)$ ]] || [[ \"$trust_nosni\" =~ ^(2|6|8|9|10)$ ]]; then\n          out \"${spaces}\"\n          pr_svrty_low \"wildcard certificate\" ; outln \" could be problematic, see other hosts at\"\n          outln \"${spaces}https://search.censys.io/search?resource=hosts&virtual_hosts=INCLUDE&q=$cert_fingerprint_sha2\"\n          fileout \"cert_trust${json_postfix}_wildcard\" \"LOW\" \"trust is via wildcard\"\n     fi\n\n\n     out \"$indent\"; pr_bold \" Chain of trust\"; out \"               \"\n     jsonID=\"cert_chain_of_trust\"\n     # Looks for CA's that have their trust removed by the first part of their Organization Name, add multiple with ^(TrustCor Systems|WoSign) etc.\n     if [[ \"$issuer_O\" =~ ^(TrustCor Systems) ]]; then\n          # Shortcut for this special case here. There is a difference between not being in a root store and being removed from a root store.\n          pr_italic \"$issuer_O\"; out \" is \" ; prln_svrty_critical \"actively removed from one or more root stores (NOT ok)\"\n          fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"Issuer removed from one or more root stores ($issuer_O)\"\n          set_grade_cap \"T\" \"Untrusted certificate chain\"\n     else\n          # Also handles fileout, keep error if happened\n          determine_trust \"$jsonID\" \"$json_postfix\" || ((ret++))\n     fi\n\n     # https://fahrplan.events.ccc.de/congress/2010/Fahrplan/attachments/1777_is-the-SSLiverse-a-safe-place.pdf, see p40+\n     out \"$indent\"; pr_bold \" EV cert\"; out \" (experimental)       \"\n     jsonID=\"cert_certificatePolicies_EV\"\n     # only the first one, seldom we have two\n     policy_oid=$(awk '/ .Policy: / { print $2 }' <<< \"$cert_txt\" | awk 'NR < 2')\n     if grep -Eq 'Extended Validation|Extended Validated|EV SSL|EV CA' <<< \"$issuer\" || \\\n          [[ 2.16.840.1.114028.10.1.2 == \"$policy_oid\" ]] || \\\n          [[ 2.16.840.1.114412.1.3.0.2 == \"$policy_oid\" ]] || \\\n          [[ 2.16.840.1.114412.2.1 == \"$policy_oid\" ]] || \\\n          [[ 2.16.578.1.26.1.3.3 == \"$policy_oid\" ]] || \\\n          [[ 1.3.6.1.4.1.17326.10.14.2.1.2 == \"$policy_oid\" ]] || \\\n          [[ 1.3.6.1.4.1.17326.10.8.12.1.2 == \"$policy_oid\" ]] || \\\n          [[ 1.3.6.1.4.1.13177.10.1.3.10 == \"$policy_oid\" ]] ; then\n          out \"yes \"\n          fileout \"${jsonID}${json_postfix}\" \"OK\" \"yes\"\n     else\n          out \"no \"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"no\"\n     fi\n     debugme echo -n \"($(newline_to_spaces \"$policy_oid\"))\"\n     outln\n#TODO: check browser OIDs:\n#         https://dxr.mozilla.org/mozilla-central/source/security/certverifier/ExtendedValidation.cpp\n#         https://chromium.googlesource.com/chromium/chromium/+/master/net/base/ev_root_ca_metadata.cc\n#         https://certs.opera.com/03/ev-oids.xml\n#         see #967\n\n     out \"$indent\"; pr_bold \" Certificate Validity (UTC)   \"\n     IFS=',' read -r startdate enddate diffseconds days2expire yearstart < <(determine_dates_certificate \"$cert_txt\")\n\n     # We adjust the thresholds by %50 for LE certificates, relaxing warnings for those certificates.\n     # . instead of \\' because it does not break syntax highlighting in vim\n     if [[ \"$issuer_O\" =~ ^Let.s\\ Encrypt ]] ; then\n          days2warn2=$((days2warn2 / 2))\n          days2warn1=$((days2warn1 / 2))\n     fi\n\n     debugme echo -n \"(diffseconds: $diffseconds)\"\n     if ! [[ \"$($OPENSSL x509 -checkend 1 2>>$ERRFILE <<< \"$hostcert\")\" =~ \\ not\\  ]]; then\n          pr_svrty_critical \"expired\"\n          expfinding=\"expired\"\n          expok=\"CRITICAL\"\n          set_grade_cap \"T\" \"Certificate expired\"\n     else\n          # low threshold first\n          if [[ \"$($OPENSSL x509 -checkend $((secsaday*days2warn2)) 2>>$ERRFILE <<< \"$hostcert\")\" =~ \\ not\\  ]]; then\n               # high threshold\n               if [[ \"$($OPENSSL x509 -checkend $((secsaday*days2warn1)) 2>>$ERRFILE <<< \"$hostcert\")\" =~ \\ not\\  ]]; then\n                    pr_svrty_good \"$days2expire >= $days2warn1 days\"\n                    expfinding+=\"$days2expire >= $days2warn1 days\"\n               else\n                    pr_svrty_medium \"expires < $days2warn1 days ($days2expire)\"\n                    expfinding+=\"expires < $days2warn1 days ($days2expire)\"\n                    expok=\"MEDIUM\"\n               fi\n          else\n               pr_svrty_high \"expires < $days2warn2 days ($days2expire)\"\n               expfinding+=\"expires < $days2warn2 days ($days2expire)\"\n               expok=\"HIGH\"\n          fi\n     fi\n     outln \" ($startdate --> $enddate)\"\n     fileout \"cert_expirationStatus${json_postfix}\" \"$expok\" \"$expfinding\"\n     fileout \"cert_notBefore${json_postfix}\" \"INFO\" \"$startdate\"      # we assume that the certificate has no start time in the future\n     fileout \"cert_notAfter${json_postfix}\" \"$expok\" \"$enddate\"       # They are in UTC\n\n     # Internal certificates or those from appliances often have too high validity periods.\n     # We check for ~10 years and >~ 5 years\n     if [[ $diffseconds -ge $((secsaday*365*10)) ]]; then\n          out \"$spaces\"\n          prln_svrty_high \">= 10 years is way too long\"\n          fileout \"cert_extlifeSpan${json_postfix}\" \"HIGH\" \"$((diffseconds / secsaday)) days\"\n     elif [[ $diffseconds -ge $((secsaday*365*5)) ]]; then\n          out \"$spaces\"\n          prln_svrty_medium \">= 5 years is too long\"\n          fileout \"cert_extlifeSpan${json_postfix}\" \"MEDIUM\" \"$((diffseconds / secsaday)) days\"\n     elif [[ $diffseconds -ge $((secsaday*398 + 1)) ]]; then\n     # Also \"official\" certificates issued from september 1st 2020 (1598918400) aren't supposed\n     # to be valid longer than 398 days which is 34387200 in epoch seconds\n          gt_398=true\n          if \"$HAS_OPENBSDDATE\"; then\n               if [[ 20200901 -le ${yearstart//-/} ]]; then\n                    gt_398warn=true\n               fi\n          elif [[ $(parse_date \"$startdate\" \"+%s\" $'%F %H:%M') -ge 1598918400 ]]; then\n               gt_398warn=true\n          fi\n          # Now, the verdict, depending on the issuing date\n          out \"$spaces\"\n          if \"$gt_398warn\" && \"$gt_398\"; then\n               prln_svrty_medium \"> 398 days issued after 2020/09/01 is too long\"\n               fileout \"cert_extlifeSpan${json_postfix}\" \"MEDIUM\" \"$((diffseconds / secsaday)) > 398 days\"\n          elif \"$gt_398\"; then\n               outln \">= 398 days certificate life time but issued before 2020/09/01\"\n               fileout \"cert_extlifeSpan${json_postfix}\" \"INFO\" \"$((diffseconds / secsaday)) =< 398 days\"\n          fi\n     elif [[ $diffseconds -ge $((secsaday*825 + 1)) ]]; then\n     # Also \"official\" certificates issued from March 1st, 2018 (1517353200) aren't supposed\n     # to be valid longer than 825 days which is 1517353200 in epoch seconds\n          gt_825=true\n          if \"$HAS_OPENBSDDATE\"; then\n               if [[ 20180301 -le ${yearstart//-/} ]]; then\n                    gt_825warn=true\n               fi\n          elif [[ $(parse_date \"$startdate\" \"+%s\" $'%F %H:%M') -ge 1517353200 ]]; then\n               gt_825warn=true\n          fi\n          # Now, the verdict, depending on the issuing date\n          out \"$spaces\"\n          if \"$gt_825warn\" && \"$gt_825\"; then\n               prln_svrty_medium \"> 825 days issued after 2018/03/01 is too long\"\n               fileout \"cert_extlifeSpan${json_postfix}\" \"MEDIUM\" \"$((diffseconds / secsaday)) > 825 days\"\n          elif \"$gt_825\"; then\n               outln \">= 825 days certificate life time but issued before 2018/03/01\"\n               fileout \"cert_extlifeSpan${json_postfix}\" \"INFO\" \"$((diffseconds / secsaday)) =< 825 days\"\n          fi\n     else\n          # All is fine with validity period\n          # We ignore for now certificates < 2018/03/01. On the screen we only show debug info\n          debugme echo \"${spaces}DEBUG: all is fine with total certificate life time\"\n          fileout \"cert_extlifeSpan${json_postfix}\" \"OK\" \"certificate has no extended life time according to browser forum\"\n     fi\n\n     out \"$indent\"; pr_bold \" ETS/\\\"eTLS\\\"\"\n     out \", visibility info  \"\n     jsonID=\"cert_eTLS\"\n     etsi_ets_visibility_info \"${jsonID}${json_postfix}\" \"$spaces\" \"$hostcert\" \"$cert_txt\"\n     # *Currently* this is even listed as a vulnerability (CWE-310, CVE-2019-919), see\n     # https://nvd.nist.gov/vuln/detail/CVE-2019-9191, https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9191\n     # For now we leave this here. We may want to change that later or add infos to other sections (FS & vulnerability)\n\n     if \"$PHONE_OUT\"; then\n          out \"$indent\"; pr_bold \" In pwnedkeys.com DB          \"\n          check_pwnedkeys \"$HOSTCERT\" \"$cert_key_algo\" \"$cert_keysize\"\n          case \"$?\" in\n               0) outln \"not checked\"; fileout \"pwnedkeys${json_postfix}\" \"INFO\" \"not checked\" ;;\n               1) outln \"not in database\"; fileout \"pwnedkeys${json_postfix}\" \"INFO\" \"not in database\" ;;\n               2) pr_svrty_critical \"NOT ok --\"; outln \" key appears in database\"; fileout \"pwnedkeys${json_postfix}\" \"CRITICAL\" \"private key is known\" ;;\n               7) prln_warning \"error querying https://v1.pwnedkeys.com\"; fileout \"pwnedkeys${json_postfix}\" \"WARN\" \"connection error\" ;;\n          esac\n     fi\n\n     out \"$indent\"; pr_bold \" Certificate Revocation List  \"\n     jsonID=\"cert_crlDistributionPoints\"\n     # ~ get next 50 lines after pattern , strip until Signature Algorithm and retrieve URIs\n     crl=\"$(awk '/X509v3 CRL Distribution/{i=50} i&&i--' <<< \"$cert_txt\" | awk '/^$|^.*Name.*$|^.*Reasons.*$|^.*CRL Issuer.*$/,/^            [a-zA-Z0-9]+|^    Signature Algorithm:/' | awk -F'URI:' '/URI/ { print $2 }')\"\n     if [[ -z \"$crl\" ]] ; then\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"--\"\n          outln \"--\"\n     else\n          if [[ $(count_lines \"$crl\") -eq 1 ]]; then\n               out \"$crl\"\n               if [[ \"$expfinding\" != \"expired\" ]]; then\n                    check_revocation_crl \"$crl\" \"cert_crlRevoked${json_postfix}\"\n                    ret=$((ret +$?))\n               fi\n               outln\n          else # more than one CRL\n               first_crl=true\n               while read -r line; do\n                    if \"$first_crl\"; then\n                         first_crl=false\n                    else\n                         out \"$spaces\"\n                    fi\n                    out \"$line\"\n                    if [[ \"$expfinding\" != expired ]]; then\n                         check_revocation_crl \"$line\" \"cert_crlRevoked${json_postfix}\"\n                         ret=$((ret +$?))\n                    fi\n                    outln\n               done <<< \"$crl\"\n          fi\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$crl\"\n     fi\n\n     out \"$indent\"; pr_bold \" OCSP URI                     \"\n     jsonID=\"cert_ocspURL\"\n     ocsp_uri=\"$($OPENSSL x509 -noout -ocsp_uri 2>>$ERRFILE <<< \"$hostcert\")\"\n     if [[ -z \"$ocsp_uri\" ]]; then\n          outln \"--\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"--\"\n     else\n          if [[ $(count_lines \"$ocsp_uri\") -eq 1 ]]; then\n               out \"$ocsp_uri\"\n               if [[ \"$expfinding\" != expired ]]; then\n                    check_revocation_ocsp \"$ocsp_uri\" \"\" \"cert_ocspRevoked${json_postfix}\"\n               fi\n               ret=$((ret +$?))\n               outln\n          else\n               first_ocsp=true\n               while read -r line; do\n                    if \"$first_ocsp\"; then\n                         first_ocsp=false\n                    else\n                         out \"$spaces\"\n                    fi\n                    out \"$line\"\n                    if [[ \"$expfinding\" != expired ]]; then\n                         check_revocation_ocsp \"$line\" \"\" \"cert_ocspRevoked${json_postfix}\"\n                         ret=$((ret +$?))\n                    fi\n                    outln\n               done <<< \"$ocsp_uri\"\n          fi\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$ocsp_uri\"\n     fi\n     if [[ -z \"$ocsp_uri\" ]] && [[ -z \"$crl\" ]]; then\n          out \"$spaces\"\n          pr_svrty_high \"NOT ok --\"\n          outln \" neither CRL nor OCSP URI provided\"\n          fileout \"cert_revocation${json_postfix}\" \"HIGH\" \"Neither CRL nor OCSP URI provided\"\n     fi\n\n     out \"$indent\"; pr_bold \" OCSP stapling                \"\n     jsonID=\"OCSP_stapling\"\n     if grep -a \"OCSP response\" <<< \"$ocsp_response\" | grep -q \"no response sent\" ; then\n          if [[ -n \"$ocsp_uri\" ]]; then\n               pr_svrty_low \"not offered\"\n               fileout \"${jsonID}${json_postfix}\" \"LOW\" \"not offered\"\n          else\n               out \"not offered\"\n               fileout \"${jsonID}${json_postfix}\" \"INFO\" \"not offered\"\n          fi\n     else\n          if grep -a \"OCSP Response Status\" <<< \"$ocsp_response_status\" | grep -q successful; then\n               pr_svrty_good \"offered\"\n               fileout \"${jsonID}${json_postfix}\" \"OK\" \"offered\"\n               provides_stapling=true\n               check_revocation_ocsp \"\" \"$ocsp_response_binary\" \"cert_ocspRevoked${json_postfix}\"\n          elif [[ \"$ocsp_response\" =~ Responder\\ Error: ]]; then\n               response=\"$(awk '/Responder Error:/ { print $3 }' <<< \"$ocsp_response\")\"\n               pr_warning \"stapled OCSP response contained an error response from OCSP responder: $response\"\n               fileout \"${jsonID}${json_postfix}\" \"WARN\" \"stapled OCSP response contained an error response from OCSP responder: $response\"\n          else\n               if $GOST_STATUS_PROBLEM; then\n                    pr_warning \"(GOST servers make problems here, sorry)\"\n                    fileout \"${jsonID}${json_postfix}\" \"WARN\" \"(The GOST server made a problem here, sorry)\"\n                    ((ret++))\n               else\n                    out \"(response status unknown)\"\n                    fileout \"${jsonID}${json_postfix}\" \"OK\" \" not sure what's going on here, '$ocsp_response'\"\n                    debugme grep -a -A20 -B2 \"OCSP response\" <<< \"$ocsp_response\"\n                    ((ret++))\n               fi\n          fi\n     fi\n     outln\n\n     out \"$indent\"; pr_bold \" OCSP must staple extension   \";\n     must_staple \"$json_postfix\" \"$provides_stapling\" \"$cert_txt\"\n\n     out \"$indent\"; pr_bold \" DNS CAA RR\"; out \" (experimental)    \"\n     jsonID=\"DNS_CAArecord\"\n     caa_node=\"$NODE\"\n     caa=\"\"\n     while [[ -z \"$caa\" ]] &&  [[ -n \"$caa_node\" ]]; do\n          caa=\"$(get_caa_rr_record $caa_node)\"\n          tmp=${PIPESTATUS[@]}\n          [[ $DEBUG -ge 4 ]] && echo \"get_caa_rr_record: $tmp\"\n          [[ $caa_node =~ '.'$ ]] || caa_node+=\".\"\n          caa_node=${caa_node#*.}\n     done\n     if [[ -n \"$caa\" ]]; then\n          pr_svrty_good \"available\"; out \" - please check for match with \\\"Issuer\\\" below\"\n          if [[ $(count_lines \"$caa\") -eq 1 ]]; then\n               out \": \"\n          else\n               outln; out \"$spaces\"\n          fi\n          while read caa; do\n               if [[ -n \"$caa\" ]]; then\n                    all_caa+=\"$caa, \"\n               fi\n          done <<< \"$caa\"\n          all_caa=${all_caa%, }                 # strip trailing comma\n          pr_italic \"$(out_row_aligned_max_width \"$all_caa\" \"$indent                              \" $TERM_WIDTH)\"\n          fileout \"${jsonID}${json_postfix}\" \"OK\" \"$all_caa\"\n     elif [[ -n \"$NODNS\" ]]; then\n          out \"(instructed to minimize/skip DNS queries)\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"check skipped as instructed\"\n     elif \"$DNS_VIA_PROXY\"; then\n          out \"(instructed to use the proxy for DNS only)\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"check skipped as instructed (proxy)\"\n     else\n          pr_svrty_low \"not offered\"\n          fileout \"${jsonID}${json_postfix}\" \"LOW\" \"--\"\n     fi\n     outln\n\n     out \"$indent\"; pr_bold \" Certificate Transparency     \";\n     jsonID=\"certificate_transparency\"\n     if [[ \"$ct\" =~ extension ]]; then\n          pr_svrty_good \"yes\"; outln \" ($ct)\"\n          fileout \"${jsonID}${json_postfix}\" \"OK\" \"yes ($ct)\"\n     else\n          outln \"$ct\"\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$ct\"\n     fi\n\n     out \"$indent\"; pr_bold \" Certificates provided\"\n     certificates_provided=\"$(grep -ace '-----BEGIN CERTIFICATE-----' <<< \"$intermediates\")\"\n     ((certificates_provided++))                  # plus host certificate\n     out \"        $certificates_provided\"\n     fileout \"certs_countServer${json_postfix}\" \"INFO\" \"${certificates_provided}\"\n     if \"$certificate_list_ordering_problem\"; then\n          prln_svrty_low \" (certificate list ordering problem)\"\n          fileout \"certs_list_ordering_problem${json_postfix}\" \"LOW\" \"yes\"\n     else\n          fileout \"certs_list_ordering_problem${json_postfix}\" \"INFO\" \"no\"\n          outln\n     fi\n\n     out \"$indent\"; pr_bold \" Issuer                       \"\n     jsonID=\"cert_caIssuers\"\n\n     if [[ \"$issuer_O\" == issuer= ]] || [[ \"$issuer_O\" == issuer=\\  ]] || [[ \"$issuer_CN\" == \"$cn\" ]]; then\n          prln_svrty_critical \"self-signed (NOT ok)\"\n          fileout \"${jsonID}${json_postfix}\" \"CRITICAL\" \"selfsigned\"\n          set_grade_cap \"T\" \"Self-signed certificate\"\n     else\n          issuerfinding=\"$issuer_CN\"\n          pr_italic \"$issuer_CN\"\n          if [[ -z \"$issuer_O\" ]] && [[ -n \"$issuer_DC\" ]]; then\n               for san in $issuer_DC; do\n                    if [[ -z \"$issuer_O\" ]]; then\n                         issuer_O=\"${san}\"\n                    else\n                         issuer_O=\"${san}.${issuer_O}\"\n                    fi\n               done\n          fi\n          if [[ -n \"$issuer_O\" ]]; then\n               issuerfinding+=\" (\"\n               out \" (\"\n               issuerfinding+=\"$issuer_O\"\n               pr_italic \"$issuer_O\"\n               if [[ -n \"$issuer_C\" ]]; then\n                    issuerfinding+=\" from \"\n                    out \" from \"\n                    issuerfinding+=\"$issuer_C\"\n                    pr_italic \"$issuer_C\"\n               fi\n               issuerfinding+=\")\"\n               out \")\"\n          fi\n          outln\n          fileout \"${jsonID}${json_postfix}\" \"INFO\" \"$issuerfinding\"\n     fi\n\n\n# Now we take care of the intermediate certificates. We basically (should) have them on disk\n# as \"intermediatecerts.pem\" (which could be split into intermediatecert1.crt, intermediatecert2.crt, ..)\n# However we do this in RAM which is better as it was passed to this function.\n# We should keep in mind though this is somewhat redundant code. We do similar stuff elsewhere,\n# e.g. in extract_certificates() and run_hpkp() but don't keep the certificates\n\n     # Store all of the text output of the intermediate certificates in an array so that they can\n     # be used later (e.g., to check their expiration dates).\n     for (( i=1; i < certificates_provided; i++ )); do\n          [[ \"$intermediates\" =~ \\-\\-\\-\\-\\-BEGIN\\ CERTIFICATE\\-\\-\\-\\-\\- ]] || break\n          intermediates=\"${intermediates#*-----BEGIN CERTIFICATE-----}\"\n          cert=\"${intermediates%%-----END CERTIFICATE-----*}\"\n          intermediates=\"${intermediates#${cert}-----END CERTIFICATE-----}\"\n          cert=\"-----BEGIN CERTIFICATE-----${cert}-----END CERTIFICATE-----\"\n\n          fileout \"intermediate_cert <#${i}>${json_postfix}\" \"INFO\" \"$(pem_to_one_line \"$cert\")\"\n          fileout \"intermediate_cert_fingerprintSHA256 <#${i}>${json_postfix}\" \"INFO\" \"$(determine_cert_fingerprint_serial \"$cert\" \"-fingerprint -sha256\")\"\n\n          intermediate_certs_txt[i]=\"$($OPENSSL x509 -text -nameopt utf8 -noout 2>/dev/null <<< \"$cert\")\"\n\n          # We don't need every value here. For the sake of being consistent here we add the rest\n          IFS=',' read -r startdate enddate diffseconds days2expire yearstart < <(determine_dates_certificate \"${intermediate_certs_txt[i]}\")\n          fileout \"intermediate_cert_notBefore <#${i}>${json_postfix}\"  \"INFO\" \"$startdate\"\n\n          if $first; then\n               out \"$indent\"; pr_bold \" Intermediate cert validity   \"\n               first=false\n          else\n               out \"$indent$spaces\"\n          fi\n          out \"#${i}: \"\n          if ! [[ \"$($OPENSSL x509 -checkend 1 2>>$ERRFILE <<< \"$cert\")\" =~ \\ not\\  ]]; then\n               cn_finding=\"expired!\"\n               pr_svrty_critical \"$cn_finding\"\n               expok=\"CRITICAL\"\n          elif ! [[ \"$($OPENSSL x509 -checkend $((secsaday*20)) 2>>$ERRFILE <<< \"$cert\")\" =~ \\ not\\  ]]; then\n               cn_finding=\"expires <= 20 days\"\n               pr_svrty_high \"$cn_finding\"\n               expok=\"HIGH\"\n          elif ! [[ \"$($OPENSSL x509 -checkend $((secsaday*40)) 2>>$ERRFILE <<< \"$cert\")\" =~ \\ not\\  ]]; then\n               cn_finding=\"expires <= 40 days\"\n               pr_svrty_medium \"$cn_finding\"\n               expok=\"MEDIUM\"\n          else\n               cn_finding=\"ok > 40 days\"\n               pr_svrty_good \"$cn_finding\"\n               expok=\"OK\"\n          fi\n          out \" ($enddate). \"\n          cn=\"$(awk -F= '/Subject:.*CN/ { print $NF }' <<< \"${intermediate_certs_txt[i]}\")\"\n          issuer_CN=\"$(awk -F= '/Issuer:.*CN/ { print $NF }' <<< \"${intermediate_certs_txt[i]}\")\"\n          pr_italic \"$(strip_leading_space \"$cn\")\"; out \" <-- \"; prln_italic \"$(strip_leading_space \"$issuer_CN\")\"\n          fileout \"intermediate_cert_notAfter <#${i}>${json_postfix}\" \"$expok\" \"$enddate\"\n          fileout \"intermediate_cert_expiration <#${i}>${json_postfix}\" \"$expok\" \"$cn_finding\"\n          fileout \"intermediate_cert_chain <#${i}>${json_postfix}\" \"INFO\" \"$cn <-- $issuer_CN\"\n     done\n\n     # Courtesy Hanno Böck (see https://github.com/hannob/badocspcert)\n     out \"$indent\"; pr_bold \" Intermediate Bad OCSP\"\n     out \" (exp.) \"\n     jsonID=\"intermediate_cert_badOCSP\"\n\n     for (( i=1; i < certificates_provided; i++ )); do\n          cert_ext_keyusage=\"$(awk '/X509v3 Extended Key Usage:/ { getline; print $0 }' <<< \"${intermediate_certs_txt[i]}\")\"\n          [[ \"$cert_ext_keyusage\" =~ OCSP\\ Signing ]] && badocsp=0 && break\n     done\n     if [[ $badocsp -eq 0 ]]; then\n          prln_svrty_medium \"NOT ok\"\n          fileout \"${jsonID}${json_postfix}\" \"MEDIUM\" \"NOT ok is intermediate certificate ${i}\"\n     else\n          prln_svrty_good \"Ok\"\n          fileout \"${jsonID}${json_postfix}\" \"OK\" \"intermediate certificate(s) is/are ok\"\n     fi\n\n     outln\n     return $ret\n}\n\nrun_server_defaults() {\n     local ciph newhostcert sni\n     local match_found\n     local sessticket_lifetime_hint=\"\" sessticket_proto=\"\" lifetime unit\n     local -i i n\n     local -i certs_found=0\n     local -i ret=0\n     local -a previous_hostcert previous_hostcert_txt previous_hostcert_type\n     local -a previous_hostcert_issuer previous_intermediates previous_ordering_problem keysize tested_cipher\n     local -a ocsp_response_binary ocsp_response ocsp_response_status sni_used tls_version ct\n     local -a ciphers_to_test certificate_type\n     local -a -i success\n     local cn_nosni cn_sni sans_nosni sans_sni san tls_extensions client_auth_ca\n     local using_sockets=true\n\n     \"$SSL_NATIVE\" && using_sockets=false\n\n     # Try each public key type once:\n     # ciphers_to_test[1]: cipher suites using certificates with RSA signature public keys\n     # ciphers_to_test[2]: cipher suites using certificates with RSA key encipherment public keys\n     # ciphers_to_test[3]: cipher suites using certificates with DSA signature public keys\n     # ciphers_to_test[4]: cipher suites using certificates with DH key agreement public keys\n     # ciphers_to_test[5]: cipher suites using certificates with ECDH key agreement public keys\n     # ciphers_to_test[6]: cipher suites using certificates with ECDSA signature public keys\n     # ciphers_to_test[7]: cipher suites using certificates with GOST R 34.10 (either 2001 or 94) public keys\n     ciphers_to_test[1]=\"aRSA:eRSA\"\n     ciphers_to_test[2]=\"\"\n     ciphers_to_test[3]=\"aDSS:aDH:aECDH:aECDSA:aGOST\"\n     ciphers_to_test[4]=\"\"\n     ciphers_to_test[5]=\"\"\n     ciphers_to_test[6]=\"\"\n     ciphers_to_test[7]=\"\"\n     ciphers_to_test[8]=\"tls1_3_RSA\"\n     ciphers_to_test[9]=\"tls1_3_ECDSA\"\n     ciphers_to_test[10]=\"tls1_3_EdDSA\"\n     certificate_type[1]=\"\" ; certificate_type[2]=\"\"\n     certificate_type[3]=\"\"; certificate_type[4]=\"\"\n     certificate_type[5]=\"\" ; certificate_type[6]=\"\"\n     certificate_type[7]=\"\" ; certificate_type[8]=\"RSASig\"\n     certificate_type[9]=\"ECDSA\" ; certificate_type[10]=\"EdDSA\"\n\n     for (( n=1; n <= 17 ; n++ )); do\n          # Some servers use a different certificate if the ClientHello\n          # specifies TLSv1.1 and doesn't include a server name extension.\n          # So, for each public key type for which a certificate was found,\n          # try again, but only with TLSv1.1 and without SNI.\n          if [[ $n -ne 1 ]] && [[ \"$OPTIMAL_PROTO\" == -ssl2 ]]; then\n               ciphers_to_test[n]=\"\"\n          elif [[ $n -ge 11 ]]; then\n               ciphers_to_test[n]=\"\"\n               [[ ${success[n-10]} -eq 0 ]] && [[ $(has_server_protocol \"tls1_1\") -ne 1 ]] && \\\n                    ciphers_to_test[n]=\"${ciphers_to_test[n-10]}\" && certificate_type[n]=\"${certificate_type[n-10]}\"\n          fi\n\n          if [[ -n \"${ciphers_to_test[n]}\" ]]; then\n               if [[ $n -ge 11 ]]; then\n                    sni=\"$SNI\"\n                    SNI=\"\"\n                    get_server_certificate \"${ciphers_to_test[n]}\" \"tls1_1\"\n                    success[n]=$?\n                    SNI=\"$sni\"\n               else\n                    get_server_certificate \"${ciphers_to_test[n]}\"\n                    success[n]=$?\n               fi\n               if [[ ${success[n]} -eq 0 ]] && [[ -s \"$HOSTCERT\" ]]; then\n                    [[ $n -ge 11 ]] && [[ ! -e $HOSTCERT.nosni ]] && cp $HOSTCERT $HOSTCERT.nosni\n                    cp \"$TEMPDIR/$NODEIP.get_server_certificate.txt\" $TMPFILE\n                    >$ERRFILE\n                    if [[ -z \"$sessticket_lifetime_hint\" ]]; then\n                         sessticket_lifetime_hint=$(awk '/session ticket life/ { if (!found) print; found=1 }' $TMPFILE)\n                         sessticket_proto=\"$(get_protocol \"$TMPFILE\")\"\n                    fi\n\n                    if [[ $n -le 7 ]]; then\n                         ciph=\"$(get_cipher $TMPFILE)\"\n                         if [[ \"$ciph\" != TLS_* ]] && [[ \"$ciph\" != SSL_* ]]; then\n                              ciph=\"$(openssl2rfc \"$ciph\")\"\n                         fi\n                         if [[ \"$ciph\" == TLS_DHE_RSA_* ]] || [[ \"$ciph\" == TLS_ECDHE_RSA_* ]] || [[ \"$ciph\" == TLS_CECPQ1_RSA_* ]]; then\n                              certificate_type[n]=\"RSASig\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/aRSA/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"aRSA\"\n                         elif [[ \"$ciph\" == TLS_RSA_* ]] || [[ \"$ciph\" == SSL_* ]] || [[ \"$ciph\" == TLS_GOST*_RSA_* ]]; then\n                              certificate_type[n]=\"RSAKMK\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/eRSA/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"eRSA\"\n                         elif [[ \"$ciph\" == TLS_DHE_DSS_* ]]; then\n                              certificate_type[n]=\"DSA\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/aDSS/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"aDSS\"\n                         elif [[ \"$ciph\" == TLS_DH_* ]]; then\n                              certificate_type[n]=\"DH\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/aDH/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"aDH\"\n                         elif [[ \"$ciph\" == TLS_ECDH_* ]]; then\n                              certificate_type[n]=\"ECDH\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/aECDH/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"aECDH\"\n                         elif [[ \"$ciph\" == TLS_ECDHE_ECDSA_* ]] || [[ \"$ciph\" == TLS_CECPQ1_ECDSA_* ]]; then\n                              certificate_type[n]=\"ECDSA\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/aECDSA/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"aECDSA\"\n                         elif [[ \"$ciph\" == TLS_GOST* ]]; then\n                              certificate_type[n]=\"GOST\"\n                              if [[ -z \"${ciphers_to_test[n+1]}\" ]]; then\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n]/aGOST/}\"\n                                   ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]/::/:}\"\n                                   [[ \"${ciphers_to_test[n+1]:0:1}\" == : ]] && ciphers_to_test[n+1]=\"${ciphers_to_test[n+1]:1}\"\n                              fi\n                              ciphers_to_test[n]=\"aGOST\"\n                         fi\n                    fi\n                    # check whether the host's certificate has been seen before\n                    match_found=false\n                    i=1\n                    newhostcert=$(cat $HOSTCERT)\n                    while [[ $i -le $certs_found ]]; do\n                         if [[ \"$newhostcert\" == \"${previous_hostcert[i]}\" ]]; then\n                              match_found=true\n                              break;\n                         fi\n                         i=$((i + 1))\n                    done\n                    if ! \"$match_found\" && [[ $n -ge 11 ]] && [[ $certs_found -ne 0 ]]; then\n                         # A new certificate was found using TLSv1.1 without SNI.\n                         # Check to see if the new certificate should be displayed.\n                         # It should be displayed if it is either a match for the\n                         # $NODE being tested or if it has the same subject\n                         # (CN and SAN) as other certificates for this host.\n                         compare_server_name_to_cert \"$HOSTCERT\"\n                         [[ $? -ne 0 ]] && success[n]=0 || success[n]=1\n\n                         if [[ ${success[n]} -ne 0 ]]; then\n                              cn_nosni=\"$(toupper \"$(get_cn_from_cert $HOSTCERT)\")\"\n                              sans_nosni=\"$(toupper \"$(get_san_dns_from_cert \"$HOSTCERT\")\")\"\n\n                              echo \"${previous_hostcert[1]}\" > $HOSTCERT\n                              cn_sni=\"$(toupper \"$(get_cn_from_cert $HOSTCERT)\")\"\n\n                              # FIXME: Not sure what the matching rule should be. At\n                              # the moment, the no SNI certificate is considered a\n                              # match if the CNs are the same and the SANs (if\n                              # present) contain at least one DNS name in common.\n                              if [[ \"$cn_nosni\" == \"$cn_sni\" ]]; then\n                                   sans_sni=\"$(toupper \"$(get_san_dns_from_cert \"$HOSTCERT\")\")\"\n                                   if [[ \"$sans_nosni\" == \"$sans_sni\" ]]; then\n                                        success[n]=0\n                                   else\n                                        while read -r san; do\n                                             [[ -n \"$san\" ]] && [[ \" $sans_sni \" =~ \\ $san\\  ]] && success[n]=0 && break\n                                        done <<< \"$sans_nosni\"\n                                   fi\n                              fi\n                         fi\n                         # If the certificate found for TLSv1.1 w/o SNI appears to\n                         # be for a different host, then set match_found to true so\n                         # that the new certificate will not be included in the output.\n                         [[ ${success[n]} -ne 0 ]] && match_found=true\n                    fi\n                    if ! \"$match_found\"; then\n                         certs_found=$(( certs_found + 1))\n                         tested_cipher[certs_found]=${ciphers_to_test[n]}\n                         keysize[certs_found]=$(awk '/Server public key/ { print $(NF-1) }' $TMPFILE)\n                         # If an OCSP response was sent, then get the full\n                         # response so that certificate_info() can determine\n                         # whether it includes a certificate transparency extension.\n                         ocsp_response_binary[certs_found]=\"$STAPLED_OCSP_RESPONSE\"\n                         if grep -a \"OCSP response:\" $TMPFILE | grep -q \"no response sent\"; then\n                              ocsp_response[certs_found]=\"$(grep -a \"OCSP response\" $TMPFILE)\"\n                         else\n                              ocsp_response[certs_found]=\"$(awk -v n=2 '/OCSP response:/ {start=1; inc=2} /======================================/ { if (start) {inc--} } inc' $TMPFILE)\"\n                         fi\n                         ocsp_response_status[certs_found]=$(grep -a \"OCSP Response Status\" $TMPFILE)\n                         previous_hostcert[certs_found]=$newhostcert\n                         previous_hostcert_txt[certs_found]=\"$($OPENSSL x509 -noout -text 2>>$ERRFILE <<< \"$newhostcert\")\"\n                         previous_intermediates[certs_found]=$(cat $TEMPDIR/intermediatecerts.pem)\n                         previous_hostcert_issuer[certs_found]=\"\"\n                         [[ -n \"${previous_intermediates[certs_found]}\" ]] && [[ -r $TEMPDIR/hostcert_issuer.pem ]] && \\\n                              previous_hostcert_issuer[certs_found]=$(cat $TEMPDIR/hostcert_issuer.pem)\n                         previous_ordering_problem[certs_found]=$CERTIFICATE_LIST_ORDERING_PROBLEM\n                         [[ $n -ge 11 ]] && sni_used[certs_found]=\"\" || sni_used[certs_found]=\"$SNI\"\n                         tls_version[certs_found]=\"$DETECTED_TLS_VERSION\"\n                         previous_hostcert_type[certs_found]=\" ${certificate_type[n]}\"\n                         if [[ $DEBUG -ge 1 ]]; then\n                              echo \"${previous_hostcert[certs_found]}\" > $TEMPDIR/host_certificate_$certs_found.pem\n                              echo \"${previous_hostcert_txt[certs_found]}\" > $TEMPDIR/host_certificate_$certs_found.txt\n                         fi\n                    else\n                         previous_hostcert_type[i]+=\" ${certificate_type[n]}\"\n                    fi\n               fi\n          fi\n     done\n\n     determine_tls_extensions\n     if [[ $? -eq 0 ]] && [[ \"$OPTIMAL_PROTO\" != -ssl2 ]]; then\n          cp \"$TEMPDIR/$NODEIP.determine_tls_extensions.txt\" $TMPFILE\n          >$ERRFILE\n          if [[ -z \"$sessticket_lifetime_hint\" ]]; then\n               sessticket_lifetime_hint=$(awk '/session ticket lifetime/ { if (!found) print; found=1 }' $TMPFILE)\n               sessticket_proto=\"$(get_protocol \"$TMPFILE\")\"\n          fi\n     fi\n     TLS13_CERT_COMPRESS_METHODS=\"\"\n     \"$using_sockets\" && determine_cert_compression\n     [[ -n \"$TLS13_CERT_COMPRESS_METHODS\" ]] && [[ \"$TLS13_CERT_COMPRESS_METHODS\" != \"none\" ]] && \\\n          extract_new_tls_extensions \"$TEMPDIR/$NODEIP.determine_cert_compression.txt\"\n\n     if \"$using_sockets\" && ! \"$TLS13_ONLY\" && [[ -z \"$sessticket_lifetime_hint\" ]] && [[ \"$OPTIMAL_PROTO\" != -ssl2 ]]; then\n          if \"$HAS_TLS13\" && [[ -z \"$OPTIMAL_PROTO\" || \"$OPTIMAL_PROTO\" == -tls1_3 ]] ; then\n               # If a session ticket were sent in response to a TLSv1.3 ClientHello, then a session ticket\n               # would have been found by get_server_certificate(). So, try again with a TLSv1.2 ClientHello.\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS -no_tls1_3 -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>$ERRFILE >$TMPFILE\n          else\n               $OPENSSL s_client $(s_client_options \"$STARTTLS $BUGS \"$OPTIMAL_PROTO\" -connect $NODEIP:$PORT $PROXY $SNI\") </dev/null 2>$ERRFILE >$TMPFILE\n          fi\n          if sclient_connect_successful $? $TMPFILE; then\n               sessticket_lifetime_hint=$(awk '/session ticket lifetime/ { if (!found) print; found=1 }' $TMPFILE)\n               sessticket_proto=\"$(get_protocol \"$TMPFILE\")\"\n          fi\n     fi\n     [[ -z \"$sessticket_lifetime_hint\" ]] && TLS_TICKETS=false || TLS_TICKETS=true\n\n     debugme echo \"# certificates found $certs_found\"\n     # Now that all of the server's certificates have been found, determine for\n     # each certificate whether certificate transparency information is provided.\n     for (( i=1; i <= certs_found; i++ )); do\n          certificate_transparency \"${previous_hostcert_txt[i]}\" \"${ocsp_response[i]}\" \"$certs_found\" \"${tested_cipher[i]}\" \"${sni_used[i]}\" \"${tls_version[i]}\"\n          ct[i]=\"$CERTIFICATE_TRANSPARENCY_SOURCE\"\n          # If certificate_transparency() called tls_sockets() and found a \"signed certificate timestamps\" extension,\n          # then add it to $TLS_EXTENSIONS, since it may not have been found by determine_tls_extensions().\n          [[ $certs_found -gt 1 ]] && [[ \"${ct[i]}\" == TLS\\ extension ]] && extract_new_tls_extensions \"$TEMPDIR/$NODEIP.parse_tls_serverhello.txt\"\n     done\n\n     outln\n     pr_headlineln \" Testing server defaults (Server Hello) \"\n     outln\n\n     pr_bold \" TLS extensions (standard)    \"\n     if [[ -z \"$TLS_EXTENSIONS\" ]]; then\n          outln \"(none)\"\n          fileout \"TLS_extensions\" \"INFO\" \"(none)\"\n     else\n#FIXME: we rather want to have the chance to print each ext in italics or another format.\n# Atm is a string of quoted strings -- that needs to be fixed at the root then\n          # out_row_aligned_max_width() places line breaks at space characters.\n          # So, in order to prevent the text for an extension from being broken\n          # across lines, temporarily replace space characters within the text\n          # of an extension with \"}\", and then convert the \"}\" back to space in\n          # the output of out_row_aligned_max_width().\n          tls_extensions=\"${TLS_EXTENSIONS// /{}\"\n          tls_extensions=\"${tls_extensions//\\\"{\\\"/\\\" \\\"}\"\n          tls_extensions=\"$(out_row_aligned_max_width \"$tls_extensions\" \"                              \" $TERM_WIDTH)\"\n          tls_extensions=\"${tls_extensions//{/ }\"\n          outln \"$tls_extensions\"\n          fileout \"TLS_extensions\" \"INFO\" \"$TLS_EXTENSIONS\"\n     fi\n\n     pr_bold \" Session Ticket RFC 5077 hint \"\n     jsonID=\"TLS_session_ticket\"\n     if [[ -z \"$sessticket_lifetime_hint\" ]]; then\n          outln \"no -- no lifetime advertised\"\n          fileout \"${jsonID}\" \"INFO\" \"no -- no lifetime advertised\"\n          # it MAY be given a hint of the lifetime of the ticket, see https://tools.ietf.org/html/rfc5077#section-5.6 .\n          # Sometimes it just does not -- but it then may also support TLS session tickets reuse\n     else\n          lifetime=$(grep -a lifetime <<< \"$sessticket_lifetime_hint\" | sed 's/[A-Za-z:() ]//g')\n          unit=$(grep -a lifetime <<< \"$sessticket_lifetime_hint\" | sed -e 's/^.*'\"$lifetime\"'//' -e 's/[ ()]//g')\n          out \"$lifetime $unit\"\n          if [[ $((3600 * 24)) -lt $lifetime ]]; then\n               prln_svrty_low \" but: FS requires session ticket keys to be rotated < daily !\"\n               fileout \"$jsonID\" \"LOW\" \"valid for $lifetime $unit (>daily)\"\n          else\n               outln \", session tickets keys seems to be rotated < daily\"\n               fileout \"$jsonID\" \"INFO\" \"valid for $lifetime $unit only (<daily)\"\n          fi\n     fi\n\n     pr_bold \" SSL Session ID support       \"\n     jsonID=\"SSL_sessionID_support\"\n     if \"$NO_SSL_SESSIONID\"; then\n          outln \"no\"\n          fileout \"$jsonID\" \"INFO\" \"no\"\n     else\n          outln \"yes\"\n          fileout \"$jsonID\" \"INFO\" \"yes\"\n     fi\n\n     pr_bold \" Session Resumption           \"\n     jsonID=\"sessionresumption_ticket\"\n     sub_session_resumption \"$sessticket_proto\"\n     case $? in\n          0) out \"Tickets: yes, \"\n             fileout \"$jsonID\" \"INFO\" \"supported\"\n          ;;\n          1) out \"Tickets no, \"\n             fileout \"$jsonID\" \"INFO\" \"not supported\"\n             ;;\n          5) pr_warning \"Ticket resumption test failed, pls report / \"\n             fileout \"$jsonID\" \"WARN\" \"check failed, pls report\"\n             ((ret++))\n             ;;\n          6) pr_warning \"Client Auth: Ticket resumption test not supported / \"\n             fileout \"$jsonID\" \"WARN\" \"check couldn't be performed because of client authentication\"\n             ;;\n          7) pr_warning \"Connect problem: Ticket resumption test not possible / \"\n             fileout \"$jsonID\" \"WARN\" \"check failed because of connect problem\"\n             ((ret++))\n             ;;\n     esac\n\n     jsonID=\"sessionresumption_ID\"\n     if \"$NO_SSL_SESSIONID\"; then\n          outln \"ID: no\"\n          fileout \"$jsonID\" \"INFO\" \"No Session ID, no resumption\"\n     else\n          sub_session_resumption \"$sessticket_proto\" ID\n          case $? in\n               0) outln \"ID: yes\"\n                  fileout \"$jsonID\" \"INFO\" \"supported\"\n                  ;;\n               1|2) outln \"ID: no\"\n                  fileout \"$jsonID\" \"INFO\" \"not supported\"\n              "
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}