{
  "metadata": {
    "timestamp": 1736568939143,
    "page": 37,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sindresorhus/pure",
      "stars": 13326,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1708984375,
          "content": "root = true\n\n[*]\nindent_style = tab\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.yml]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "arch",
          "type": "tree",
          "content": null
        },
        {
          "name": "async",
          "type": "blob",
          "size": 0.0087890625,
          "content": "async.zsh"
        },
        {
          "name": "async.zsh",
          "type": "blob",
          "size": 18.8623046875,
          "content": "#!/usr/bin/env zsh\n\n#\n# zsh-async\n#\n# version: v1.8.6\n# author: Mathias Fredriksson\n# url: https://github.com/mafredri/zsh-async\n#\n\ntypeset -g ASYNC_VERSION=1.8.6\n# Produce debug output from zsh-async when set to 1.\ntypeset -g ASYNC_DEBUG=${ASYNC_DEBUG:-0}\n\n# Execute commands that can manipulate the environment inside the async worker. Return output via callback.\n_async_eval() {\n\tlocal ASYNC_JOB_NAME\n\t# Rename job to _async_eval and redirect all eval output to cat running\n\t# in _async_job. Here, stdout and stderr are not separated for\n\t# simplicity, this could be improved in the future.\n\t{\n\t\teval \"$@\"\n\t} &> >(ASYNC_JOB_NAME=[async/eval] _async_job 'command -p cat')\n}\n\n# Wrapper for jobs executed by the async worker, gives output in parseable format with execution time\n_async_job() {\n\t# Disable xtrace as it would mangle the output.\n\tsetopt localoptions noxtrace\n\n\t# Store start time for job.\n\tfloat -F duration=$EPOCHREALTIME\n\n\t# Run the command and capture both stdout (`eval`) and stderr (`cat`) in\n\t# separate subshells. When the command is complete, we grab write lock\n\t# (mutex token) and output everything except stderr inside the command\n\t# block, after the command block has completed, the stdin for `cat` is\n\t# closed, causing stderr to be appended with a $'\\0' at the end to mark the\n\t# end of output from this job.\n\tlocal jobname=${ASYNC_JOB_NAME:-$1} out\n\tout=\"$(\n\t\tlocal stdout stderr ret tok\n\t\t{\n\t\t\tstdout=$(eval \"$@\")\n\t\t\tret=$?\n\t\t\tduration=$(( EPOCHREALTIME - duration ))  # Calculate duration.\n\n\t\t\tprint -r -n - $'\\0'${(q)jobname} $ret ${(q)stdout} $duration\n\t\t} 2> >(stderr=$(command -p cat) && print -r -n - \" \"${(q)stderr}$'\\0')\n\t)\"\n\tif [[ $out != $'\\0'*$'\\0' ]]; then\n\t\t# Corrupted output (aborted job?), skipping.\n\t\treturn\n\tfi\n\n\t# Grab mutex lock, stalls until token is available.\n\tread -r -k 1 -p tok || return 1\n\n\t# Return output (<job_name> <return_code> <stdout> <duration> <stderr>).\n\tprint -r -n - \"$out\"\n\n\t# Unlock mutex by inserting a token.\n\tprint -n -p $tok\n}\n\n# The background worker manages all tasks and runs them without interfering with other processes\n_async_worker() {\n\t# Reset all options to defaults inside async worker.\n\temulate -R zsh\n\n\t# Make sure monitor is unset to avoid printing the\n\t# pids of child processes.\n\tunsetopt monitor\n\n\t# Redirect stderr to `/dev/null` in case unforseen errors produced by the\n\t# worker. For example: `fork failed: resource temporarily unavailable`.\n\t# Some older versions of zsh might also print malloc errors (know to happen\n\t# on at least zsh 5.0.2 and 5.0.8) likely due to kill signals.\n\texec 2>/dev/null\n\n\t# When a zpty is deleted (using -d) all the zpty instances created before\n\t# the one being deleted receive a SIGHUP, unless we catch it, the async\n\t# worker would simply exit (stop working) even though visible in the list\n\t# of zpty's (zpty -L). This has been fixed around the time of Zsh 5.4\n\t# (not released).\n\tif ! is-at-least 5.4.1; then\n\t\tTRAPHUP() {\n\t\t\treturn 0  # Return 0, indicating signal was handled.\n\t\t}\n\tfi\n\n\tlocal -A storage\n\tlocal unique=0\n\tlocal notify_parent=0\n\tlocal parent_pid=0\n\tlocal coproc_pid=0\n\tlocal processing=0\n\n\tlocal -a zsh_hooks zsh_hook_functions\n\tzsh_hooks=(chpwd periodic precmd preexec zshexit zshaddhistory)\n\tzsh_hook_functions=(${^zsh_hooks}_functions)\n\tunfunction $zsh_hooks &>/dev/null   # Deactivate all zsh hooks inside the worker.\n\tunset $zsh_hook_functions           # And hooks with registered functions.\n\tunset zsh_hooks zsh_hook_functions  # Cleanup.\n\n\tclose_idle_coproc() {\n\t\tlocal -a pids\n\t\tpids=(${${(v)jobstates##*:*:}%\\=*})\n\n\t\t# If coproc (cat) is the only child running, we close it to avoid\n\t\t# leaving it running indefinitely and cluttering the process tree.\n\t\tif  (( ! processing )) && [[ $#pids = 1 ]] && [[ $coproc_pid = $pids[1] ]]; then\n\t\t\tcoproc :\n\t\t\tcoproc_pid=0\n\t\tfi\n\t}\n\n\tchild_exit() {\n\t\tclose_idle_coproc\n\n\t\t# On older version of zsh (pre 5.2) we notify the parent through a\n\t\t# SIGWINCH signal because `zpty` did not return a file descriptor (fd)\n\t\t# prior to that.\n\t\tif (( notify_parent )); then\n\t\t\t# We use SIGWINCH for compatibility with older versions of zsh\n\t\t\t# (pre 5.1.1) where other signals (INFO, ALRM, USR1, etc.) could\n\t\t\t# cause a deadlock in the shell under certain circumstances.\n\t\t\tkill -WINCH $parent_pid\n\t\tfi\n\t}\n\n\t# Register a SIGCHLD trap to handle the completion of child processes.\n\ttrap child_exit CHLD\n\n\t# Process option parameters passed to worker.\n\twhile getopts \"np:uz\" opt; do\n\t\tcase $opt in\n\t\t\tn) notify_parent=1;;\n\t\t\tp) parent_pid=$OPTARG;;\n\t\t\tu) unique=1;;\n\t\t\tz) notify_parent=0;;  # Uses ZLE watcher instead.\n\t\tesac\n\tdone\n\n\t# Terminate all running jobs, note that this function does not\n\t# reinstall the child trap.\n\tterminate_jobs() {\n\t\ttrap - CHLD   # Ignore child exits during kill.\n\t\tcoproc :      # Quit coproc.\n\t\tcoproc_pid=0  # Reset pid.\n\n\t\tif is-at-least 5.4.1; then\n\t\t\ttrap '' HUP    # Catch the HUP sent to this process.\n\t\t\tkill -HUP -$$  # Send to entire process group.\n\t\t\ttrap - HUP     # Disable HUP trap.\n\t\telse\n\t\t\t# We already handle HUP for Zsh < 5.4.1.\n\t\t\tkill -HUP -$$  # Send to entire process group.\n\t\tfi\n\t}\n\n\tkilljobs() {\n\t\tlocal tok\n\t\tlocal -a pids\n\t\tpids=(${${(v)jobstates##*:*:}%\\=*})\n\n\t\t# No need to send SIGHUP if no jobs are running.\n\t\t(( $#pids == 0 )) && continue\n\t\t(( $#pids == 1 )) && [[ $coproc_pid = $pids[1] ]] && continue\n\n\t\t# Grab lock to prevent half-written output in case a child\n\t\t# process is in the middle of writing to stdin during kill.\n\t\t(( coproc_pid )) && read -r -k 1 -p tok\n\n\t\tterminate_jobs\n\t\ttrap child_exit CHLD  # Reinstall child trap.\n\t}\n\n\tlocal request do_eval=0\n\tlocal -a cmd\n\twhile :; do\n\t\t# Wait for jobs sent by async_job.\n\t\tread -r -d $'\\0' request || {\n\t\t\t# Unknown error occurred while reading from stdin, the zpty\n\t\t\t# worker is likely in a broken state, so we shut down.\n\t\t\tterminate_jobs\n\n\t\t\t# Stdin is broken and in case this was an unintended\n\t\t\t# crash, we try to report it as a last hurrah.\n\t\t\tprint -r -n $'\\0'\"'[async]'\" $(( 127 + 3 )) \"''\" 0 \"'$0:$LINENO: zpty fd died, exiting'\"$'\\0'\n\n\t\t\t# We use `return` to abort here because using `exit` may\n\t\t\t# result in an infinite loop that never exits and, as a\n\t\t\t# result, high CPU utilization.\n\t\t\treturn $(( 127 + 1 ))\n\t\t}\n\n\t\t# We need to clean the input here because sometimes when a zpty\n\t\t# has died and been respawned, messages will be prefixed with a\n\t\t# carraige return (\\r, or \\C-M).\n\t\trequest=${request#$'\\C-M'}\n\n\t\t# Check for non-job commands sent to worker\n\t\tcase $request in\n\t\t\t_killjobs)    killjobs; continue;;\n\t\t\t_async_eval*) do_eval=1;;\n\t\tesac\n\n\t\t# Parse the request using shell parsing (z) to allow commands\n\t\t# to be parsed from single strings and multi-args alike.\n\t\tcmd=(\"${(z)request}\")\n\n\t\t# Name of the job (first argument).\n\t\tlocal job=$cmd[1]\n\n\t\t# Check if a worker should perform unique jobs, unless\n\t\t# this is an eval since they run synchronously.\n\t\tif (( !do_eval )) && (( unique )); then\n\t\t\t# Check if a previous job is still running, if yes,\n\t\t\t# skip this job and let the previous one finish.\n\t\t\tfor pid in ${${(v)jobstates##*:*:}%\\=*}; do\n\t\t\t\tif [[ ${storage[$job]} == $pid ]]; then\n\t\t\t\t\tcontinue 2\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\n\t\t# Guard against closing coproc from trap before command has started.\n\t\tprocessing=1\n\n\t\t# Because we close the coproc after the last job has completed, we must\n\t\t# recreate it when there are no other jobs running.\n\t\tif (( ! coproc_pid )); then\n\t\t\t# Use coproc as a mutex for synchronized output between children.\n\t\t\tcoproc command -p cat\n\t\t\tcoproc_pid=\"$!\"\n\t\t\t# Insert token into coproc\n\t\t\tprint -n -p \"t\"\n\t\tfi\n\n\t\tif (( do_eval )); then\n\t\t\tshift cmd  # Strip _async_eval from cmd.\n\t\t\t_async_eval $cmd\n\t\telse\n\t\t\t# Run job in background, completed jobs are printed to stdout.\n\t\t\t_async_job $cmd &\n\t\t\t# Store pid because zsh job manager is extremely unflexible (show jobname as non-unique '$job')...\n\t\t\tstorage[$job]=\"$!\"\n\t\tfi\n\n\t\tprocessing=0  # Disable guard.\n\n\t\tif (( do_eval )); then\n\t\t\tdo_eval=0\n\n\t\t\t# When there are no active jobs we can't rely on the CHLD trap to\n\t\t\t# manage the coproc lifetime.\n\t\t\tclose_idle_coproc\n\t\tfi\n\tdone\n}\n\n#\n# Get results from finished jobs and pass it to the to callback function. This is the only way to reliably return the\n# job name, return code, output and execution time and with minimal effort.\n#\n# If the async process buffer becomes corrupt, the callback will be invoked with the first argument being `[async]` (job\n# name), non-zero return code and fifth argument describing the error (stderr).\n#\n# usage:\n# \tasync_process_results <worker_name> <callback_function>\n#\n# callback_function is called with the following parameters:\n# \t$1 = job name, e.g. the function passed to async_job\n# \t$2 = return code\n# \t$3 = resulting stdout from execution\n# \t$4 = execution time, floating point e.g. 2.05 seconds\n# \t$5 = resulting stderr from execution\n#\t$6 = has next result in buffer (0 = buffer empty, 1 = yes)\n#\nasync_process_results() {\n\tsetopt localoptions unset noshwordsplit noksharrays noposixidentifiers noposixstrings\n\n\tlocal worker=$1\n\tlocal callback=$2\n\tlocal caller=$3\n\tlocal -a items\n\tlocal null=$'\\0' data\n\tinteger -l len pos num_processed has_next\n\n\ttypeset -gA ASYNC_PROCESS_BUFFER\n\n\t# Read output from zpty and parse it if available.\n\twhile zpty -r -t $worker data 2>/dev/null; do\n\t\tASYNC_PROCESS_BUFFER[$worker]+=$data\n\t\tlen=${#ASYNC_PROCESS_BUFFER[$worker]}\n\t\tpos=${ASYNC_PROCESS_BUFFER[$worker][(i)$null]}  # Get index of NULL-character (delimiter).\n\n\t\t# Keep going until we find a NULL-character.\n\t\tif (( ! len )) || (( pos > len )); then\n\t\t\tcontinue\n\t\tfi\n\n\t\twhile (( pos <= len )); do\n\t\t\t# Take the content from the beginning, until the NULL-character and\n\t\t\t# perform shell parsing (z) and unquoting (Q) as an array (@).\n\t\t\titems=(\"${(@Q)${(z)ASYNC_PROCESS_BUFFER[$worker][1,$pos-1]}}\")\n\n\t\t\t# Remove the extracted items from the buffer.\n\t\t\tASYNC_PROCESS_BUFFER[$worker]=${ASYNC_PROCESS_BUFFER[$worker][$pos+1,$len]}\n\n\t\t\tlen=${#ASYNC_PROCESS_BUFFER[$worker]}\n\t\t\tif (( len > 1 )); then\n\t\t\t\tpos=${ASYNC_PROCESS_BUFFER[$worker][(i)$null]}  # Get index of NULL-character (delimiter).\n\t\t\tfi\n\n\t\t\thas_next=$(( len != 0 ))\n\t\t\tif (( $#items == 5 )); then\n\t\t\t\titems+=($has_next)\n\t\t\t\t$callback \"${(@)items}\"  # Send all parsed items to the callback.\n\t\t\t\t(( num_processed++ ))\n\t\t\telif [[ -z $items ]]; then\n\t\t\t\t# Empty items occur between results due to double-null ($'\\0\\0')\n\t\t\t\t# caused by commands being both pre and suffixed with null.\n\t\t\telse\n\t\t\t\t# In case of corrupt data, invoke callback with *async* as job\n\t\t\t\t# name, non-zero exit status and an error message on stderr.\n\t\t\t\t$callback \"[async]\" 1 \"\" 0 \"$0:$LINENO: error: bad format, got ${#items} items (${(q)items})\" $has_next\n\t\t\tfi\n\t\tdone\n\tdone\n\n\t(( num_processed )) && return 0\n\n\t# Avoid printing exit value when `setopt printexitvalue` is active.`\n\t[[ $caller = trap || $caller = watcher ]] && return 0\n\n\t# No results were processed\n\treturn 1\n}\n\n# Watch worker for output\n_async_zle_watcher() {\n\tsetopt localoptions noshwordsplit\n\ttypeset -gA ASYNC_PTYS ASYNC_CALLBACKS\n\tlocal worker=$ASYNC_PTYS[$1]\n\tlocal callback=$ASYNC_CALLBACKS[$worker]\n\n\tif [[ -n $2 ]]; then\n\t\t# from man zshzle(1):\n\t\t# `hup' for a disconnect, `nval' for a closed or otherwise\n\t\t# invalid descriptor, or `err' for any other condition.\n\t\t# Systems that support only the `select' system call always use\n\t\t# `err'.\n\n\t\t# this has the side effect to unregister the broken file descriptor\n\t\tasync_stop_worker $worker\n\n\t\tif [[ -n $callback ]]; then\n\t\t\t$callback '[async]' 2 \"\" 0 \"$0:$LINENO: error: fd for $worker failed: zle -F $1 returned error $2\" 0\n\t\tfi\n\t\treturn\n\tfi;\n\n\tif [[ -n $callback ]]; then\n\t\tasync_process_results $worker $callback watcher\n\tfi\n}\n\n_async_send_job() {\n\tsetopt localoptions noshwordsplit noksharrays noposixidentifiers noposixstrings\n\n\tlocal caller=$1\n\tlocal worker=$2\n\tshift 2\n\n\tzpty -t $worker &>/dev/null || {\n\t\ttypeset -gA ASYNC_CALLBACKS\n\t\tlocal callback=$ASYNC_CALLBACKS[$worker]\n\n\t\tif [[ -n $callback ]]; then\n\t\t\t$callback '[async]' 3 \"\" 0 \"$0:$LINENO: error: no such worker: $worker\" 0\n\t\telse\n\t\t\tprint -u2 \"$caller: no such async worker: $worker\"\n\t\tfi\n\t\treturn 1\n\t}\n\n\tzpty -w $worker \"$@\"$'\\0'\n}\n\n#\n# Start a new asynchronous job on specified worker, assumes the worker is running.\n#\n# Note if you are using a function for the job, it must have been defined before the worker was\n# started or you will get a `command not found` error.\n#\n# usage:\n# \tasync_job <worker_name> <my_function> [<function_params>]\n#\nasync_job() {\n\tsetopt localoptions noshwordsplit noksharrays noposixidentifiers noposixstrings\n\n\tlocal worker=$1; shift\n\n\tlocal -a cmd\n\tcmd=(\"$@\")\n\tif (( $#cmd > 1 )); then\n\t\tcmd=(${(q)cmd})  # Quote special characters in multi argument commands.\n\tfi\n\n\t_async_send_job $0 $worker \"$cmd\"\n}\n\n#\n# Evaluate a command (like async_job) inside the async worker, then worker environment can be manipulated. For example,\n# issuing a cd command will change the PWD of the worker which will then be inherited by all future async jobs.\n#\n# Output will be returned via callback, job name will be [async/eval].\n#\n# usage:\n# \tasync_worker_eval <worker_name> <my_function> [<function_params>]\n#\nasync_worker_eval() {\n\tsetopt localoptions noshwordsplit noksharrays noposixidentifiers noposixstrings\n\n\tlocal worker=$1; shift\n\n\tlocal -a cmd\n\tcmd=(\"$@\")\n\tif (( $#cmd > 1 )); then\n\t\tcmd=(${(q)cmd})  # Quote special characters in multi argument commands.\n\tfi\n\n\t# Quote the cmd in case RC_EXPAND_PARAM is set.\n\t_async_send_job $0 $worker \"_async_eval $cmd\"\n}\n\n# This function traps notification signals and calls all registered callbacks\n_async_notify_trap() {\n\tsetopt localoptions noshwordsplit\n\n\tlocal k\n\tfor k in ${(k)ASYNC_CALLBACKS}; do\n\t\tasync_process_results $k ${ASYNC_CALLBACKS[$k]} trap\n\tdone\n}\n\n#\n# Register a callback for completed jobs. As soon as a job is finnished, async_process_results will be called with the\n# specified callback function. This requires that a worker is initialized with the -n (notify) option.\n#\n# usage:\n# \tasync_register_callback <worker_name> <callback_function>\n#\nasync_register_callback() {\n\tsetopt localoptions noshwordsplit nolocaltraps\n\n\ttypeset -gA ASYNC_PTYS ASYNC_CALLBACKS\n\tlocal worker=$1; shift\n\n\tASYNC_CALLBACKS[$worker]=\"$*\"\n\n\t# Enable trap when the ZLE watcher is unavailable, allows\n\t# workers to notify (via -n) when a job is done.\n\tif [[ ! -o interactive ]] || [[ ! -o zle ]]; then\n\t\ttrap '_async_notify_trap' WINCH\n\telif [[ -o interactive ]] && [[ -o zle ]]; then\n\t\tlocal fd w\n\t\tfor fd w in ${(@kv)ASYNC_PTYS}; do\n\t\t\tif [[ $w == $worker ]]; then\n\t\t\t\tzle -F $fd _async_zle_watcher  # Register the ZLE handler.\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\tfi\n}\n\n#\n# Unregister the callback for a specific worker.\n#\n# usage:\n# \tasync_unregister_callback <worker_name>\n#\nasync_unregister_callback() {\n\ttypeset -gA ASYNC_CALLBACKS\n\n\tunset \"ASYNC_CALLBACKS[$1]\"\n}\n\n#\n# Flush all current jobs running on a worker. This will terminate any and all running processes under the worker, use\n# with caution.\n#\n# usage:\n# \tasync_flush_jobs <worker_name>\n#\nasync_flush_jobs() {\n\tsetopt localoptions noshwordsplit\n\n\tlocal worker=$1; shift\n\n\t# Check if the worker exists\n\tzpty -t $worker &>/dev/null || return 1\n\n\t# Send kill command to worker\n\tasync_job $worker \"_killjobs\"\n\n\t# Clear the zpty buffer.\n\tlocal junk\n\tif zpty -r -t $worker junk '*'; then\n\t\t(( ASYNC_DEBUG )) && print -n \"async_flush_jobs $worker: ${(V)junk}\"\n\t\twhile zpty -r -t $worker junk '*'; do\n\t\t\t(( ASYNC_DEBUG )) && print -n \"${(V)junk}\"\n\t\tdone\n\t\t(( ASYNC_DEBUG )) && print\n\tfi\n\n\t# Finally, clear the process buffer in case of partially parsed responses.\n\ttypeset -gA ASYNC_PROCESS_BUFFER\n\tunset \"ASYNC_PROCESS_BUFFER[$worker]\"\n}\n\n#\n# Start a new async worker with optional parameters, a worker can be told to only run unique tasks and to notify a\n# process when tasks are complete.\n#\n# usage:\n# \tasync_start_worker <worker_name> [-u] [-n] [-p <pid>]\n#\n# opts:\n# \t-u unique (only unique job names can run)\n# \t-n notify through SIGWINCH signal\n# \t-p pid to notify (defaults to current pid)\n#\nasync_start_worker() {\n\tsetopt localoptions noshwordsplit noclobber\n\n\tlocal worker=$1; shift\n\tlocal -a args\n\targs=(\"$@\")\n\tzpty -t $worker &>/dev/null && return\n\n\ttypeset -gA ASYNC_PTYS\n\ttypeset -h REPLY\n\ttypeset has_xtrace=0\n\n\tif [[ -o interactive ]] && [[ -o zle ]]; then\n\t\t# Inform the worker to ignore the notify flag and that we're\n\t\t# using a ZLE watcher instead.\n\t\targs+=(-z)\n\n\t\tif (( ! ASYNC_ZPTY_RETURNS_FD )); then\n\t\t\t# When zpty doesn't return a file descriptor (on older versions of zsh)\n\t\t\t# we try to guess it anyway.\n\t\t\tinteger -l zptyfd\n\t\t\texec {zptyfd}>&1  # Open a new file descriptor (above 10).\n\t\t\texec {zptyfd}>&-  # Close it so it's free to be used by zpty.\n\t\tfi\n\tfi\n\n\t# Workaround for stderr in the main shell sometimes (incorrectly) being\n\t# reassigned to /dev/null by the reassignment done inside the async\n\t# worker.\n\t# See https://github.com/mafredri/zsh-async/issues/35.\n\tinteger errfd=-1\n\n\t# Redirect of errfd is broken on zsh 5.0.2.\n\tif is-at-least 5.0.8; then\n\t\texec {errfd}>&2\n\tfi\n\n\t# Make sure async worker is started without xtrace\n\t# (the trace output interferes with the worker).\n\t[[ -o xtrace ]] && {\n\t\thas_xtrace=1\n\t\tunsetopt xtrace\n\t}\n\n\tif (( errfd != -1 )); then\n\t\tzpty -b $worker _async_worker -p $$ $args 2>&$errfd\n\telse\n\t\tzpty -b $worker _async_worker -p $$ $args\n\tfi\n\tlocal ret=$?\n\n\t# Re-enable it if it was enabled, for debugging.\n\t(( has_xtrace )) && setopt xtrace\n\t(( errfd != -1 )) && exec {errfd}>& -\n\n\tif (( ret )); then\n\t\tasync_stop_worker $worker\n\t\treturn 1\n\tfi\n\n\tif ! is-at-least 5.0.8; then\n\t\t# For ZSH versions older than 5.0.8 we delay a bit to give\n\t\t# time for the worker to start before issuing commands,\n\t\t# otherwise it will not be ready to receive them.\n\t\tsleep 0.001\n\tfi\n\n\tif [[ -o interactive ]] && [[ -o zle ]]; then\n\t\tif (( ! ASYNC_ZPTY_RETURNS_FD )); then\n\t\t\tREPLY=$zptyfd  # Use the guessed value for the file desciptor.\n\t\tfi\n\n\t\tASYNC_PTYS[$REPLY]=$worker  # Map the file desciptor to the worker.\n\tfi\n}\n\n#\n# Stop one or multiple workers that are running, all unfetched and incomplete work will be lost.\n#\n# usage:\n# \tasync_stop_worker <worker_name_1> [<worker_name_2>]\n#\nasync_stop_worker() {\n\tsetopt localoptions noshwordsplit\n\n\tlocal ret=0 worker k v\n\tfor worker in $@; do\n\t\t# Find and unregister the zle handler for the worker\n\t\tfor k v in ${(@kv)ASYNC_PTYS}; do\n\t\t\tif [[ $v == $worker ]]; then\n\t\t\t\tzle -F $k\n\t\t\t\tunset \"ASYNC_PTYS[$k]\"\n\t\t\tfi\n\t\tdone\n\t\tasync_unregister_callback $worker\n\t\tzpty -d $worker 2>/dev/null || ret=$?\n\n\t\t# Clear any partial buffers.\n\t\ttypeset -gA ASYNC_PROCESS_BUFFER\n\t\tunset \"ASYNC_PROCESS_BUFFER[$worker]\"\n\tdone\n\n\treturn $ret\n}\n\n#\n# Initialize the required modules for zsh-async. To be called before using the zsh-async library.\n#\n# usage:\n# \tasync_init\n#\nasync_init() {\n\t(( ASYNC_INIT_DONE )) && return\n\ttypeset -g ASYNC_INIT_DONE=1\n\n\tzmodload zsh/zpty\n\tzmodload zsh/datetime\n\n\t# Load is-at-least for reliable version check.\n\tautoload -Uz is-at-least\n\n\t# Check if zsh/zpty returns a file descriptor or not,\n\t# shell must also be interactive with zle enabled.\n\ttypeset -g ASYNC_ZPTY_RETURNS_FD=0\n\t[[ -o interactive ]] && [[ -o zle ]] && {\n\t\ttypeset -h REPLY\n\t\tzpty _async_test :\n\t\t(( REPLY )) && ASYNC_ZPTY_RETURNS_FD=1\n\t\tzpty -d _async_test\n\t}\n}\n\nasync() {\n\tasync_init\n}\n\nasync \"$@\"\n"
        },
        {
          "name": "license",
          "type": "blob",
          "size": 1.0908203125,
          "content": "MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.849609375,
          "content": "{\n\t\"name\": \"pure-prompt\",\n\t\"version\": \"1.23.0\",\n\t\"description\": \"Pretty, minimal and fast ZSH prompt\",\n\t\"license\": \"MIT\",\n\t\"repository\": \"sindresorhus/pure\",\n\t\"funding\": \"https://github.com/sponsors/sindresorhus\",\n\t\"author\": {\n\t\t\"name\": \"Sindre Sorhus\",\n\t\t\"email\": \"sindresorhus@gmail.com\",\n\t\t\"url\": \"https://sindresorhus.com\"\n\t},\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"name\": \"Mathias Fredriksson\",\n\t\t\t\"url\": \"https://github.com/mafredri\"\n\t\t}\n\t],\n\t\"scripts\": {\n\t\t\"postinstall\": \"if [ -e /opt/homebrew/bin/zsh ]; then PURE_DEST=/opt/homebrew/share/zsh/site-functions npm run --silent postinstall-link && exit 0; elif [ -e /usr/local/bin/zsh ]; then PURE_DEST=/usr/local/share/zsh/site-functions npm run --silent postinstall-link && exit 0; elif [ -e /bin/zsh ] || [ -e /usr/bin/zsh ]; then for dest in /usr/share/zsh/site-functions /usr/local/share/zsh/site-functions; do if [ -d $dest ]; then PURE_DEST=$dest npm run --silent postinstall-link && exit 0; fi; done; fi; PURE_DEST=\\\"$PWD/functions\\\" npm run --silent postinstall-link && npm run --silent postinstall-fail-instructions\",\n\t\t\"postinstall-link\": \"mkdir -p \\\"$PURE_DEST\\\" && ln -sf \\\"$PWD/pure.zsh\\\" \\\"$PURE_DEST/prompt_pure_setup\\\" && ln -sf \\\"$PWD/async.zsh\\\" \\\"$PURE_DEST/async\\\"\",\n\t\t\"postinstall-fail-instructions\": \"echo \\\"\\\\nERROR: Could not automagically symlink the prompt. You can either:\\\\n\\\\n1. Add the following to your \\\\`.zshrc\\\\`:\\\\n\\\\n    fpath+=('$PWD/functions')\\\\n\\\\n2. Or check out the readme on how to do it manually: https://github.com/sindresorhus/pure#manually\\\"\",\n\t\t\"version\": \"sed -i '' -e 's/prompt_pure_state\\\\[version\\\\]=.*/prompt_pure_state[version]=\\\"'\\\"$npm_package_version\\\"'\\\"/' pure.zsh && git add pure.zsh\"\n\t},\n\t\"files\": [\n\t\t\"pure.zsh\",\n\t\t\"async.zsh\"\n\t],\n\t\"keywords\": [\n\t\t\"zsh\",\n\t\t\"zshell\",\n\t\t\"sh\",\n\t\t\"shell\",\n\t\t\"bash\",\n\t\t\"pure\",\n\t\t\"prompt\",\n\t\t\"theme\",\n\t\t\"git\",\n\t\t\"async\",\n\t\t\"fast\",\n\t\t\"minimal\",\n\t\t\"pretty\"\n\t]\n}\n"
        },
        {
          "name": "prompt_pure_setup",
          "type": "blob",
          "size": 0.0078125,
          "content": "pure.zsh"
        },
        {
          "name": "pure.plugin.zsh",
          "type": "blob",
          "size": 0.0078125,
          "content": "pure.zsh"
        },
        {
          "name": "pure.zsh",
          "type": "blob",
          "size": 28.59765625,
          "content": "# Pure\n# by Sindre Sorhus\n# https://github.com/sindresorhus/pure\n# MIT License\n\n# For my own and others sanity\n# git:\n# %b => current branch\n# %a => current action (rebase/merge)\n# prompt:\n# %F => color dict\n# %f => reset color\n# %~ => current path\n# %* => time\n# %n => username\n# %m => shortname host\n# %(?..) => prompt conditional - %(condition.true.false)\n# terminal codes:\n# \\e7   => save cursor position\n# \\e[2A => move cursor 2 lines up\n# \\e[1G => go to position 1 in terminal\n# \\e8   => restore cursor position\n# \\e[K  => clears everything after the cursor on the current line\n# \\e[2K => clear everything on the current line\n\n\n# Turns seconds into human readable time.\n# 165392 => 1d 21h 56m 32s\n# https://github.com/sindresorhus/pretty-time-zsh\nprompt_pure_human_time_to_var() {\n\tlocal human total_seconds=$1 var=$2\n\tlocal days=$(( total_seconds / 60 / 60 / 24 ))\n\tlocal hours=$(( total_seconds / 60 / 60 % 24 ))\n\tlocal minutes=$(( total_seconds / 60 % 60 ))\n\tlocal seconds=$(( total_seconds % 60 ))\n\t(( days > 0 )) && human+=\"${days}d \"\n\t(( hours > 0 )) && human+=\"${hours}h \"\n\t(( minutes > 0 )) && human+=\"${minutes}m \"\n\thuman+=\"${seconds}s\"\n\n\t# Store human readable time in a variable as specified by the caller\n\ttypeset -g \"${var}\"=\"${human}\"\n}\n\n# Stores (into prompt_pure_cmd_exec_time) the execution\n# time of the last command if set threshold was exceeded.\nprompt_pure_check_cmd_exec_time() {\n\tinteger elapsed\n\t(( elapsed = EPOCHSECONDS - ${prompt_pure_cmd_timestamp:-$EPOCHSECONDS} ))\n\ttypeset -g prompt_pure_cmd_exec_time=\n\t(( elapsed > ${PURE_CMD_MAX_EXEC_TIME:-5} )) && {\n\t\tprompt_pure_human_time_to_var $elapsed \"prompt_pure_cmd_exec_time\"\n\t}\n}\n\nprompt_pure_set_title() {\n\tsetopt localoptions noshwordsplit\n\n\t# Emacs terminal does not support settings the title.\n\t(( ${+EMACS} || ${+INSIDE_EMACS} )) && return\n\n\tcase $TTY in\n\t\t# Don't set title over serial console.\n\t\t/dev/ttyS[0-9]*) return;;\n\tesac\n\n\t# Show hostname if connected via SSH.\n\tlocal hostname=\n\tif [[ -n $prompt_pure_state[username] ]]; then\n\t\t# Expand in-place in case ignore-escape is used.\n\t\thostname=\"${(%):-(%m) }\"\n\tfi\n\n\tlocal -a opts\n\tcase $1 in\n\t\texpand-prompt) opts=(-P);;\n\t\tignore-escape) opts=(-r);;\n\tesac\n\n\t# Set title atomically in one print statement so that it works when XTRACE is enabled.\n\tprint -n $opts $'\\e]0;'${hostname}${2}$'\\a'\n}\n\nprompt_pure_preexec() {\n\tif [[ -n $prompt_pure_git_fetch_pattern ]]; then\n\t\t# Detect when Git is performing pull/fetch, including Git aliases.\n\t\tlocal -H MATCH MBEGIN MEND match mbegin mend\n\t\tif [[ $2 =~ (git|hub)\\ (.*\\ )?($prompt_pure_git_fetch_pattern)(\\ .*)?$ ]]; then\n\t\t\t# We must flush the async jobs to cancel our git fetch in order\n\t\t\t# to avoid conflicts with the user issued pull / fetch.\n\t\t\tasync_flush_jobs 'prompt_pure'\n\t\tfi\n\tfi\n\n\ttypeset -g prompt_pure_cmd_timestamp=$EPOCHSECONDS\n\n\t# Shows the current directory and executed command in the title while a process is active.\n\tprompt_pure_set_title 'ignore-escape' \"$PWD:t: $2\"\n\n\t# Disallow Python virtualenv from updating the prompt. Set it to 12 if\n\t# untouched by the user to indicate that Pure modified it. Here we use\n\t# the magic number 12, same as in `psvar`.\n\texport VIRTUAL_ENV_DISABLE_PROMPT=${VIRTUAL_ENV_DISABLE_PROMPT:-12}\n}\n\n# Change the colors if their value are different from the current ones.\nprompt_pure_set_colors() {\n\tlocal color_temp key value\n\tfor key value in ${(kv)prompt_pure_colors}; do\n\t\tzstyle -t \":prompt:pure:$key\" color \"$value\"\n\t\tcase $? in\n\t\t\t1) # The current style is different from the one from zstyle.\n\t\t\t\tzstyle -s \":prompt:pure:$key\" color color_temp\n\t\t\t\tprompt_pure_colors[$key]=$color_temp ;;\n\t\t\t2) # No style is defined.\n\t\t\t\tprompt_pure_colors[$key]=$prompt_pure_colors_default[$key] ;;\n\t\tesac\n\tdone\n}\n\nprompt_pure_preprompt_render() {\n\tsetopt localoptions noshwordsplit\n\n\tunset prompt_pure_async_render_requested\n\n\t# Set color for Git branch/dirty status and change color if dirty checking has been delayed.\n\tlocal git_color=$prompt_pure_colors[git:branch]\n\tlocal git_dirty_color=$prompt_pure_colors[git:dirty]\n\t[[ -n ${prompt_pure_git_last_dirty_check_timestamp+x} ]] && git_color=$prompt_pure_colors[git:branch:cached]\n\n\t# Initialize the preprompt array.\n\tlocal -a preprompt_parts\n\n\t# Suspended jobs in background.\n\tif ((${(M)#jobstates:#suspended:*} != 0)); then\n\t\tpreprompt_parts+='%F{$prompt_pure_colors[suspended_jobs]}✦'\n\tfi\n\n\t# Username and machine, if applicable.\n\t[[ -n $prompt_pure_state[username] ]] && preprompt_parts+=($prompt_pure_state[username])\n\n\t# Set the path.\n\tpreprompt_parts+=('%F{${prompt_pure_colors[path]}}%~%f')\n\n\t# Git branch and dirty status info.\n\ttypeset -gA prompt_pure_vcs_info\n\tif [[ -n $prompt_pure_vcs_info[branch] ]]; then\n\t\tpreprompt_parts+=(\"%F{$git_color}\"'${prompt_pure_vcs_info[branch]}'\"%F{$git_dirty_color}\"'${prompt_pure_git_dirty}%f')\n\tfi\n\t# Git action (for example, merge).\n\tif [[ -n $prompt_pure_vcs_info[action] ]]; then\n\t\tpreprompt_parts+=(\"%F{$prompt_pure_colors[git:action]}\"'$prompt_pure_vcs_info[action]%f')\n\tfi\n\t# Git pull/push arrows.\n\tif [[ -n $prompt_pure_git_arrows ]]; then\n\t\tpreprompt_parts+=('%F{$prompt_pure_colors[git:arrow]}${prompt_pure_git_arrows}%f')\n\tfi\n\t# Git stash symbol (if opted in).\n\tif [[ -n $prompt_pure_git_stash ]]; then\n\t\tpreprompt_parts+=('%F{$prompt_pure_colors[git:stash]}${PURE_GIT_STASH_SYMBOL:-≡}%f')\n\tfi\n\n\t# Execution time.\n\t[[ -n $prompt_pure_cmd_exec_time ]] && preprompt_parts+=('%F{$prompt_pure_colors[execution_time]}${prompt_pure_cmd_exec_time}%f')\n\n\tlocal cleaned_ps1=$PROMPT\n\tlocal -H MATCH MBEGIN MEND\n\tif [[ $PROMPT = *$prompt_newline* ]]; then\n\t\t# Remove everything from the prompt until the newline. This\n\t\t# removes the preprompt and only the original PROMPT remains.\n\t\tcleaned_ps1=${PROMPT##*${prompt_newline}}\n\tfi\n\tunset MATCH MBEGIN MEND\n\n\t# Construct the new prompt with a clean preprompt.\n\tlocal -ah ps1\n\tps1=(\n\t\t${(j. .)preprompt_parts}  # Join parts, space separated.\n\t\t$prompt_newline           # Separate preprompt and prompt.\n\t\t$cleaned_ps1\n\t)\n\n\tPROMPT=\"${(j..)ps1}\"\n\n\t# Expand the prompt for future comparision.\n\tlocal expanded_prompt\n\texpanded_prompt=\"${(S%%)PROMPT}\"\n\n\tif [[ $1 == precmd ]]; then\n\t\t# Initial newline, for spaciousness.\n\t\tprint\n\telif [[ $prompt_pure_last_prompt != $expanded_prompt ]]; then\n\t\t# Redraw the prompt.\n\t\tprompt_pure_reset_prompt\n\tfi\n\n\ttypeset -g prompt_pure_last_prompt=$expanded_prompt\n}\n\nprompt_pure_precmd() {\n\tsetopt localoptions noshwordsplit\n\n\t# Check execution time and store it in a variable.\n\tprompt_pure_check_cmd_exec_time\n\tunset prompt_pure_cmd_timestamp\n\n\t# Shows the full path in the title.\n\tprompt_pure_set_title 'expand-prompt' '%~'\n\n\t# Modify the colors if some have changed..\n\tprompt_pure_set_colors\n\n\t# Perform async Git dirty check and fetch.\n\tprompt_pure_async_tasks\n\n\t# Check if we should display the virtual env. We use a sufficiently high\n\t# index of psvar (12) here to avoid collisions with user defined entries.\n\tpsvar[12]=\n\t# Check if a Conda environment is active and display its name.\n\tif [[ -n $CONDA_DEFAULT_ENV ]]; then\n\t\tpsvar[12]=\"${CONDA_DEFAULT_ENV//[$'\\t\\r\\n']}\"\n\tfi\n\t# When VIRTUAL_ENV_DISABLE_PROMPT is empty, it was unset by the user and\n\t# Pure should take back control.\n\tif [[ -n $VIRTUAL_ENV ]] && [[ -z $VIRTUAL_ENV_DISABLE_PROMPT || $VIRTUAL_ENV_DISABLE_PROMPT = 12 ]]; then\n\t\tpsvar[12]=\"${VIRTUAL_ENV:t}\"\n\t\texport VIRTUAL_ENV_DISABLE_PROMPT=12\n\tfi\n\n\t# Nix package manager integration. If used from within 'nix shell' - shell name is shown like so:\n\t# ~/Projects/flake-utils-plus master\n\t# flake-utils-plus ❯\n\tif zstyle -T \":prompt:pure:environment:nix-shell\" show; then\n\t\tif [[ -n $IN_NIX_SHELL ]]; then\n\t\t\tpsvar[12]=\"${name:-nix-shell}\"\n\t\tfi\n\tfi\n\n\t# Make sure VIM prompt is reset.\n\tprompt_pure_reset_prompt_symbol\n\n\t# Print the preprompt.\n\tprompt_pure_preprompt_render \"precmd\"\n\n\tif [[ -n $ZSH_THEME ]]; then\n\t\tprint \"WARNING: Oh My Zsh themes are enabled (ZSH_THEME='${ZSH_THEME}'). Pure might not be working correctly.\"\n\t\tprint \"For more information, see: https://github.com/sindresorhus/pure#oh-my-zsh\"\n\t\tunset ZSH_THEME  # Only show this warning once.\n\tfi\n}\n\nprompt_pure_async_git_aliases() {\n\tsetopt localoptions noshwordsplit\n\tlocal -a gitalias pullalias\n\n\t# List all aliases and split on newline.\n\tgitalias=(${(@f)\"$(command git config --get-regexp \"^alias\\.\")\"})\n\tfor line in $gitalias; do\n\t\tparts=(${(@)=line})           # Split line on spaces.\n\t\taliasname=${parts[1]#alias.}  # Grab the name (alias.[name]).\n\t\tshift parts                   # Remove `aliasname`\n\n\t\t# Check alias for pull or fetch. Must be exact match.\n\t\tif [[ $parts =~ ^(.*\\ )?(pull|fetch)(\\ .*)?$ ]]; then\n\t\t\tpullalias+=($aliasname)\n\t\tfi\n\tdone\n\n\tprint -- ${(j:|:)pullalias}  # Join on pipe, for use in regex.\n}\n\nprompt_pure_async_vcs_info() {\n\tsetopt localoptions noshwordsplit\n\n\t# Configure `vcs_info` inside an async task. This frees up `vcs_info`\n\t# to be used or configured as the user pleases.\n\tzstyle ':vcs_info:*' enable git\n\tzstyle ':vcs_info:*' use-simple true\n\t# Only export four message variables from `vcs_info`.\n\tzstyle ':vcs_info:*' max-exports 3\n\t# Export branch (%b), Git toplevel (%R), action (rebase/cherry-pick) (%a)\n\tzstyle ':vcs_info:git*' formats '%b' '%R' '%a'\n\tzstyle ':vcs_info:git*' actionformats '%b' '%R' '%a'\n\n\tvcs_info\n\n\tlocal -A info\n\tinfo[pwd]=$PWD\n\tinfo[branch]=${vcs_info_msg_0_//\\%/%%}\n\tinfo[top]=$vcs_info_msg_1_\n\tinfo[action]=$vcs_info_msg_2_\n\n\tprint -r - ${(@kvq)info}\n}\n\n# Fastest possible way to check if a Git repo is dirty.\nprompt_pure_async_git_dirty() {\n\tsetopt localoptions noshwordsplit\n\tlocal untracked_dirty=$1\n\tlocal untracked_git_mode=$(command git config --get status.showUntrackedFiles)\n\tif [[ \"$untracked_git_mode\" != 'no' ]]; then\n\t\tuntracked_git_mode='normal'\n\tfi\n\n\t# Prevent e.g. `git status` from refreshing the index as a side effect.\n\texport GIT_OPTIONAL_LOCKS=0\n\n\tif [[ $untracked_dirty = 0 ]]; then\n\t\tcommand git diff --no-ext-diff --quiet --exit-code\n\telse\n\t\ttest -z \"$(command git status --porcelain -u${untracked_git_mode})\"\n\tfi\n\n\treturn $?\n}\n\nprompt_pure_async_git_fetch() {\n\tsetopt localoptions noshwordsplit\n\n\tlocal only_upstream=${1:-0}\n\n\t# Sets `GIT_TERMINAL_PROMPT=0` to disable authentication prompt for Git fetch (Git 2.3+).\n\texport GIT_TERMINAL_PROMPT=0\n\t# Set SSH `BachMode` to disable all interactive SSH password prompting.\n\texport GIT_SSH_COMMAND=\"${GIT_SSH_COMMAND:-\"ssh\"} -o BatchMode=yes\"\n\n\t# If gpg-agent is set to handle SSH keys for `git fetch`, make\n\t# sure it doesn't corrupt the parent TTY.\n\t# Setting an empty GPG_TTY forces pinentry-curses to close immediately rather\n\t# than stall indefinitely waiting for user input.\n\texport GPG_TTY=\n\n\tlocal -a remote\n\tif ((only_upstream)); then\n\t\tlocal ref\n\t\tref=$(command git symbolic-ref -q HEAD)\n\t\t# Set remote to only fetch information for the current branch.\n\t\tremote=($(command git for-each-ref --format='%(upstream:remotename) %(refname)' $ref))\n\t\tif [[ -z $remote[1] ]]; then\n\t\t\t# No remote specified for this branch, skip fetch.\n\t\t\treturn 97\n\t\tfi\n\tfi\n\n\t# Default return code, which indicates Git fetch failure.\n\tlocal fail_code=99\n\n\t# Guard against all forms of password prompts. By setting the shell into\n\t# MONITOR mode we can notice when a child process prompts for user input\n\t# because it will be suspended. Since we are inside an async worker, we\n\t# have no way of transmitting the password and the only option is to\n\t# kill it. If we don't do it this way, the process will corrupt with the\n\t# async worker.\n\tsetopt localtraps monitor\n\n\t# Make sure local HUP trap is unset to allow for signal propagation when\n\t# the async worker is flushed.\n\ttrap - HUP\n\n\ttrap '\n\t\t# Unset trap to prevent infinite loop\n\t\ttrap - CHLD\n\t\tif [[ $jobstates = suspended* ]]; then\n\t\t\t# Set fail code to password prompt and kill the fetch.\n\t\t\tfail_code=98\n\t\t\tkill %%\n\t\tfi\n\t' CHLD\n\n\t# Do git fetch and avoid fetching tags or\n\t# submodules to speed up the process.\n\tcommand git -c gc.auto=0 fetch \\\n\t\t--quiet \\\n\t\t--no-tags \\\n\t\t--recurse-submodules=no \\\n\t\t$remote &>/dev/null &\n\twait $! || return $fail_code\n\n\tunsetopt monitor\n\n\t# Check arrow status after a successful `git fetch`.\n\tprompt_pure_async_git_arrows\n}\n\nprompt_pure_async_git_arrows() {\n\tsetopt localoptions noshwordsplit\n\tcommand git rev-list --left-right --count HEAD...@'{u}'\n}\n\nprompt_pure_async_git_stash() {\n\tgit rev-list --walk-reflogs --count refs/stash\n}\n\n# Try to lower the priority of the worker so that disk heavy operations\n# like `git status` has less impact on the system responsivity.\nprompt_pure_async_renice() {\n\tsetopt localoptions noshwordsplit\n\n\tif command -v renice >/dev/null; then\n\t\tcommand renice +15 -p $$\n\tfi\n\n\tif command -v ionice >/dev/null; then\n\t\tcommand ionice -c 3 -p $$\n\tfi\n}\n\nprompt_pure_async_init() {\n\ttypeset -g prompt_pure_async_inited\n\tif ((${prompt_pure_async_inited:-0})); then\n\t\treturn\n\tfi\n\tprompt_pure_async_inited=1\n\tasync_start_worker \"prompt_pure\" -u -n\n\tasync_register_callback \"prompt_pure\" prompt_pure_async_callback\n\tasync_worker_eval \"prompt_pure\" prompt_pure_async_renice\n}\n\nprompt_pure_async_tasks() {\n\tsetopt localoptions noshwordsplit\n\n\t# Initialize the async worker.\n\tprompt_pure_async_init\n\n\t# Update the current working directory of the async worker.\n\tasync_worker_eval \"prompt_pure\" builtin cd -q $PWD\n\n\ttypeset -gA prompt_pure_vcs_info\n\n\tlocal -H MATCH MBEGIN MEND\n\tif [[ $PWD != ${prompt_pure_vcs_info[pwd]}* ]]; then\n\t\t# Stop any running async jobs.\n\t\tasync_flush_jobs \"prompt_pure\"\n\n\t\t# Reset Git preprompt variables, switching working tree.\n\t\tunset prompt_pure_git_dirty\n\t\tunset prompt_pure_git_last_dirty_check_timestamp\n\t\tunset prompt_pure_git_arrows\n\t\tunset prompt_pure_git_stash\n\t\tunset prompt_pure_git_fetch_pattern\n\t\tprompt_pure_vcs_info[branch]=\n\t\tprompt_pure_vcs_info[top]=\n\tfi\n\tunset MATCH MBEGIN MEND\n\n\tasync_job \"prompt_pure\" prompt_pure_async_vcs_info\n\n\t# Only perform tasks inside a Git working tree.\n\t[[ -n $prompt_pure_vcs_info[top] ]] || return\n\n\tprompt_pure_async_refresh\n}\n\nprompt_pure_async_refresh() {\n\tsetopt localoptions noshwordsplit\n\n\tif [[ -z $prompt_pure_git_fetch_pattern ]]; then\n\t\t# We set the pattern here to avoid redoing the pattern check until the\n\t\t# working tree has changed. Pull and fetch are always valid patterns.\n\t\ttypeset -g prompt_pure_git_fetch_pattern=\"pull|fetch\"\n\t\tasync_job \"prompt_pure\" prompt_pure_async_git_aliases\n\tfi\n\n\tasync_job \"prompt_pure\" prompt_pure_async_git_arrows\n\n\t# Do not perform `git fetch` if it is disabled or in home folder.\n\tif (( ${PURE_GIT_PULL:-1} )) && [[ $prompt_pure_vcs_info[top] != $HOME ]]; then\n\t\tzstyle -t :prompt:pure:git:fetch only_upstream\n\t\tlocal only_upstream=$((? == 0))\n\t\tasync_job \"prompt_pure\" prompt_pure_async_git_fetch $only_upstream\n\tfi\n\n\t# If dirty checking is sufficiently fast,\n\t# tell the worker to check it again, or wait for timeout.\n\tinteger time_since_last_dirty_check=$(( EPOCHSECONDS - ${prompt_pure_git_last_dirty_check_timestamp:-0} ))\n\tif (( time_since_last_dirty_check > ${PURE_GIT_DELAY_DIRTY_CHECK:-1800} )); then\n\t\tunset prompt_pure_git_last_dirty_check_timestamp\n\t\t# Check check if there is anything to pull.\n\t\tasync_job \"prompt_pure\" prompt_pure_async_git_dirty ${PURE_GIT_UNTRACKED_DIRTY:-1}\n\tfi\n\n\t# If stash is enabled, tell async worker to count stashes\n\tif zstyle -t \":prompt:pure:git:stash\" show; then\n\t\tasync_job \"prompt_pure\" prompt_pure_async_git_stash\n\telse\n\t\tunset prompt_pure_git_stash\n\tfi\n}\n\nprompt_pure_check_git_arrows() {\n\tsetopt localoptions noshwordsplit\n\tlocal arrows left=${1:-0} right=${2:-0}\n\n\t(( right > 0 )) && arrows+=${PURE_GIT_DOWN_ARROW:-⇣}\n\t(( left > 0 )) && arrows+=${PURE_GIT_UP_ARROW:-⇡}\n\n\t[[ -n $arrows ]] || return\n\ttypeset -g REPLY=$arrows\n}\n\nprompt_pure_async_callback() {\n\tsetopt localoptions noshwordsplit\n\tlocal job=$1 code=$2 output=$3 exec_time=$4 next_pending=$6\n\tlocal do_render=0\n\n\tcase $job in\n\t\t\\[async])\n\t\t\t# Handle all the errors that could indicate a crashed\n\t\t\t# async worker. See zsh-async documentation for the\n\t\t\t# definition of the exit codes.\n\t\t\tif (( code == 2 )) || (( code == 3 )) || (( code == 130 )); then\n\t\t\t\t# Our worker died unexpectedly, try to recover immediately.\n\t\t\t\t# TODO(mafredri): Do we need to handle next_pending\n\t\t\t\t#                 and defer the restart?\n\t\t\t\ttypeset -g prompt_pure_async_inited=0\n\t\t\t\tasync_stop_worker prompt_pure\n\t\t\t\tprompt_pure_async_init   # Reinit the worker.\n\t\t\t\tprompt_pure_async_tasks  # Restart all tasks.\n\n\t\t\t\t# Reset render state due to restart.\n\t\t\t\tunset prompt_pure_async_render_requested\n\t\t\tfi\n\t\t\t;;\n\t\t\\[async/eval])\n\t\t\tif (( code )); then\n\t\t\t\t# Looks like async_worker_eval failed,\n\t\t\t\t# rerun async tasks just in case.\n\t\t\t\tprompt_pure_async_tasks\n\t\t\tfi\n\t\t\t;;\n\t\tprompt_pure_async_vcs_info)\n\t\t\tlocal -A info\n\t\t\ttypeset -gA prompt_pure_vcs_info\n\n\t\t\t# Parse output (z) and unquote as array (Q@).\n\t\t\tinfo=(\"${(Q@)${(z)output}}\")\n\t\t\tlocal -H MATCH MBEGIN MEND\n\t\t\tif [[ $info[pwd] != $PWD ]]; then\n\t\t\t\t# The path has changed since the check started, abort.\n\t\t\t\treturn\n\t\t\tfi\n\t\t\t# Check if Git top-level has changed.\n\t\t\tif [[ $info[top] = $prompt_pure_vcs_info[top] ]]; then\n\t\t\t\t# If the stored pwd is part of $PWD, $PWD is shorter and likelier\n\t\t\t\t# to be top-level, so we update pwd.\n\t\t\t\tif [[ $prompt_pure_vcs_info[pwd] = ${PWD}* ]]; then\n\t\t\t\t\tprompt_pure_vcs_info[pwd]=$PWD\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t# Store $PWD to detect if we (maybe) left the Git path.\n\t\t\t\tprompt_pure_vcs_info[pwd]=$PWD\n\t\t\tfi\n\t\t\tunset MATCH MBEGIN MEND\n\n\t\t\t# The update has a Git top-level set, which means we just entered a new\n\t\t\t# Git directory. Run the async refresh tasks.\n\t\t\t[[ -n $info[top] ]] && [[ -z $prompt_pure_vcs_info[top] ]] && prompt_pure_async_refresh\n\n\t\t\t# Always update branch, top-level and stash.\n\t\t\tprompt_pure_vcs_info[branch]=$info[branch]\n\t\t\tprompt_pure_vcs_info[top]=$info[top]\n\t\t\tprompt_pure_vcs_info[action]=$info[action]\n\n\t\t\tdo_render=1\n\t\t\t;;\n\t\tprompt_pure_async_git_aliases)\n\t\t\tif [[ -n $output ]]; then\n\t\t\t\t# Append custom Git aliases to the predefined ones.\n\t\t\t\tprompt_pure_git_fetch_pattern+=\"|$output\"\n\t\t\tfi\n\t\t\t;;\n\t\tprompt_pure_async_git_dirty)\n\t\t\tlocal prev_dirty=$prompt_pure_git_dirty\n\t\t\tif (( code == 0 )); then\n\t\t\t\tunset prompt_pure_git_dirty\n\t\t\telse\n\t\t\t\ttypeset -g prompt_pure_git_dirty=\"*\"\n\t\t\tfi\n\n\t\t\t[[ $prev_dirty != $prompt_pure_git_dirty ]] && do_render=1\n\n\t\t\t# When `prompt_pure_git_last_dirty_check_timestamp` is set, the Git info is displayed\n\t\t\t# in a different color. To distinguish between a \"fresh\" and a \"cached\" result, the\n\t\t\t# preprompt is rendered before setting this variable. Thus, only upon the next\n\t\t\t# rendering of the preprompt will the result appear in a different color.\n\t\t\t(( $exec_time > 5 )) && prompt_pure_git_last_dirty_check_timestamp=$EPOCHSECONDS\n\t\t\t;;\n\t\tprompt_pure_async_git_fetch|prompt_pure_async_git_arrows)\n\t\t\t# `prompt_pure_async_git_fetch` executes `prompt_pure_async_git_arrows`\n\t\t\t# after a successful fetch.\n\t\t\tcase $code in\n\t\t\t\t0)\n\t\t\t\t\tlocal REPLY\n\t\t\t\t\tprompt_pure_check_git_arrows ${(ps:\\t:)output}\n\t\t\t\t\tif [[ $prompt_pure_git_arrows != $REPLY ]]; then\n\t\t\t\t\t\ttypeset -g prompt_pure_git_arrows=$REPLY\n\t\t\t\t\t\tdo_render=1\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t97)\n\t\t\t\t\t# No remote available, make sure to clear git arrows if set.\n\t\t\t\t\tif [[ -n $prompt_pure_git_arrows ]]; then\n\t\t\t\t\t\ttypeset -g prompt_pure_git_arrows=\n\t\t\t\t\t\tdo_render=1\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t99|98)\n\t\t\t\t\t# Git fetch failed.\n\t\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\t# Non-zero exit status from `prompt_pure_async_git_arrows`,\n\t\t\t\t\t# indicating that there is no upstream configured.\n\t\t\t\t\tif [[ -n $prompt_pure_git_arrows ]]; then\n\t\t\t\t\t\tunset prompt_pure_git_arrows\n\t\t\t\t\t\tdo_render=1\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\tesac\n\t\t\t;;\n\t\tprompt_pure_async_git_stash)\n\t\t\tlocal prev_stash=$prompt_pure_git_stash\n\t\t\ttypeset -g prompt_pure_git_stash=$output\n\t\t\t[[ $prev_stash != $prompt_pure_git_stash ]] && do_render=1\n\t\t\t;;\n\tesac\n\n\tif (( next_pending )); then\n\t\t(( do_render )) && typeset -g prompt_pure_async_render_requested=1\n\t\treturn\n\tfi\n\n\t[[ ${prompt_pure_async_render_requested:-$do_render} = 1 ]] && prompt_pure_preprompt_render\n\tunset prompt_pure_async_render_requested\n}\n\nprompt_pure_reset_prompt() {\n\tif [[ $CONTEXT == cont ]]; then\n\t\t# When the context is \"cont\", PS2 is active and calling\n\t\t# reset-prompt will have no effect on PS1, but it will\n\t\t# reset the execution context (%_) of PS2 which we don't\n\t\t# want. Unfortunately, we can't save the output of \"%_\"\n\t\t# either because it is only ever rendered as part of the\n\t\t# prompt, expanding in-place won't work.\n\t\treturn\n\tfi\n\n\tzle && zle .reset-prompt\n}\n\nprompt_pure_reset_prompt_symbol() {\n\tprompt_pure_state[prompt]=${PURE_PROMPT_SYMBOL:-❯}\n}\n\nprompt_pure_update_vim_prompt_widget() {\n\tsetopt localoptions noshwordsplit\n\tprompt_pure_state[prompt]=${${KEYMAP/vicmd/${PURE_PROMPT_VICMD_SYMBOL:-❮}}/(main|viins)/${PURE_PROMPT_SYMBOL:-❯}}\n\n\tprompt_pure_reset_prompt\n}\n\nprompt_pure_reset_vim_prompt_widget() {\n\tsetopt localoptions noshwordsplit\n\tprompt_pure_reset_prompt_symbol\n\n\t# We can't perform a prompt reset at this point because it\n\t# removes the prompt marks inserted by macOS Terminal.\n}\n\nprompt_pure_state_setup() {\n\tsetopt localoptions noshwordsplit\n\n\t# Check SSH_CONNECTION and the current state.\n\tlocal ssh_connection=${SSH_CONNECTION:-$PROMPT_PURE_SSH_CONNECTION}\n\tlocal username hostname\n\tif [[ -z $ssh_connection ]] && (( $+commands[who] )); then\n\t\t# When changing user on a remote system, the $SSH_CONNECTION\n\t\t# environment variable can be lost. Attempt detection via `who`.\n\t\tlocal who_out\n\t\twho_out=$(who -m 2>/dev/null)\n\t\tif (( $? )); then\n\t\t\t# Who am I not supported, fallback to plain who.\n\t\t\tlocal -a who_in\n\t\t\twho_in=( ${(f)\"$(who 2>/dev/null)\"} )\n\t\t\twho_out=\"${(M)who_in:#*[[:space:]]${TTY#/dev/}[[:space:]]*}\"\n\t\tfi\n\n\t\tlocal reIPv6='(([0-9a-fA-F]+:)|:){2,}[0-9a-fA-F]+'  # Simplified, only checks partial pattern.\n\t\tlocal reIPv4='([0-9]{1,3}\\.){3}[0-9]+'   # Simplified, allows invalid ranges.\n\t\t# Here we assume two non-consecutive periods represents a\n\t\t# hostname. This matches `foo.bar.baz`, but not `foo.bar`.\n\t\tlocal reHostname='([.][^. ]+){2}'\n\n\t\t# Usually the remote address is surrounded by parenthesis, but\n\t\t# not on all systems (e.g. busybox).\n\t\tlocal -H MATCH MBEGIN MEND\n\t\tif [[ $who_out =~ \"\\(?($reIPv4|$reIPv6|$reHostname)\\)?\\$\" ]]; then\n\t\t\tssh_connection=$MATCH\n\n\t\t\t# Export variable to allow detection propagation inside\n\t\t\t# shells spawned by this one (e.g. tmux does not always\n\t\t\t# inherit the same tty, which breaks detection).\n\t\t\texport PROMPT_PURE_SSH_CONNECTION=$ssh_connection\n\t\tfi\n\t\tunset MATCH MBEGIN MEND\n\tfi\n\n\thostname='%F{$prompt_pure_colors[host]}@%m%f'\n\t# Show `username@host` if logged in through SSH.\n\t[[ -n $ssh_connection ]] && username='%F{$prompt_pure_colors[user]}%n%f'\"$hostname\"\n\n\t# Show `username@host` if inside a container and not in GitHub Codespaces.\n\t[[ -z \"${CODESPACES}\" ]] && prompt_pure_is_inside_container && username='%F{$prompt_pure_colors[user]}%n%f'\"$hostname\"\n\n\t# Show `username@host` if root, with username in default color.\n\t[[ $UID -eq 0 ]] && username='%F{$prompt_pure_colors[user:root]}%n%f'\"$hostname\"\n\n\ttypeset -gA prompt_pure_state\n\tprompt_pure_state[version]=\"1.23.0\"\n\tprompt_pure_state+=(\n\t\tusername \"$username\"\n\t\tprompt\t \"${PURE_PROMPT_SYMBOL:-❯}\"\n\t)\n}\n\n# Return true if executing inside a Docker, OCI, LXC, or systemd-nspawn container.\nprompt_pure_is_inside_container() {\n\tlocal -r cgroup_file='/proc/1/cgroup'\n\tlocal -r nspawn_file='/run/host/container-manager'\n\t[[ -r \"$cgroup_file\" && \"$(< $cgroup_file)\" = *(lxc|docker)* ]] \\\n\t\t|| [[ \"$container\" == \"lxc\" ]] \\\n\t\t|| [[ \"$container\" == \"oci\" ]] \\\n\t\t|| [[ \"$container\" == \"podman\" ]] \\\n\t\t|| [[ -r \"$nspawn_file\" ]]\n}\n\nprompt_pure_system_report() {\n\tsetopt localoptions noshwordsplit\n\n\tlocal shell=$SHELL\n\tif [[ -z $shell ]]; then\n\t\tshell=$commands[zsh]\n\tfi\n\tprint - \"- Zsh: $($shell --version) ($shell)\"\n\tprint -n - \"- Operating system: \"\n\tcase \"$(uname -s)\" in\n\t\tDarwin)\tprint \"$(sw_vers -productName) $(sw_vers -productVersion) ($(sw_vers -buildVersion))\";;\n\t\t*)\tprint \"$(uname -s) ($(uname -r) $(uname -v) $(uname -m) $(uname -o))\";;\n\tesac\n\tprint - \"- Terminal program: ${TERM_PROGRAM:-unknown} (${TERM_PROGRAM_VERSION:-unknown})\"\n\tprint -n - \"- Tmux: \"\n\t[[ -n $TMUX ]] && print \"yes\" || print \"no\"\n\n\tlocal git_version\n\tgit_version=($(git --version))  # Remove newlines, if hub is present.\n\tprint - \"- Git: $git_version\"\n\n\tprint - \"- Pure state:\"\n\tfor k v in \"${(@kv)prompt_pure_state}\"; do\n\t\tprint - \"    - $k: \\`${(q-)v}\\`\"\n\tdone\n\tprint - \"- zsh-async version: \\`${ASYNC_VERSION}\\`\"\n\tprint - \"- PROMPT: \\`$(typeset -p PROMPT)\\`\"\n\tprint - \"- Colors: \\`$(typeset -p prompt_pure_colors)\\`\"\n\tprint - \"- TERM: \\`$(typeset -p TERM)\\`\"\n\tprint - \"- Virtualenv: \\`$(typeset -p VIRTUAL_ENV_DISABLE_PROMPT)\\`\"\n\tprint - \"- Conda: \\`$(typeset -p CONDA_CHANGEPS1)\\`\"\n\n\tlocal ohmyzsh=0\n\ttypeset -la frameworks\n\t(( $+ANTIBODY_HOME )) && frameworks+=(\"Antibody\")\n\t(( $+ADOTDIR )) && frameworks+=(\"Antigen\")\n\t(( $+ANTIGEN_HS_HOME )) && frameworks+=(\"Antigen-hs\")\n\t(( $+functions[upgrade_oh_my_zsh] )) && {\n\t\tohmyzsh=1\n\t\tframeworks+=(\"Oh My Zsh\")\n\t}\n\t(( $+ZPREZTODIR )) && frameworks+=(\"Prezto\")\n\t(( $+ZPLUG_ROOT )) && frameworks+=(\"Zplug\")\n\t(( $+ZPLGM )) && frameworks+=(\"Zplugin\")\n\n\t(( $#frameworks == 0 )) && frameworks+=(\"None\")\n\tprint - \"- Detected frameworks: ${(j:, :)frameworks}\"\n\n\tif (( ohmyzsh )); then\n\t\tprint - \"    - Oh My Zsh:\"\n\t\tprint - \"        - Plugins: ${(j:, :)plugins}\"\n\tfi\n}\n\nprompt_pure_setup() {\n\t# Prevent percentage showing up if output doesn't end with a newline.\n\texport PROMPT_EOL_MARK=''\n\n\tprompt_opts=(subst percent)\n\n\t# Borrowed from `promptinit`. Sets the prompt options in case Pure was not\n\t# initialized via `promptinit`.\n\tsetopt noprompt{bang,cr,percent,subst} \"prompt${^prompt_opts[@]}\"\n\n\tif [[ -z $prompt_newline ]]; then\n\t\t# This variable needs to be set, usually set by promptinit.\n\t\ttypeset -g prompt_newline=$'\\n%{\\r%}'\n\tfi\n\n\tzmodload zsh/datetime\n\tzmodload zsh/zle\n\tzmodload zsh/parameter\n\tzmodload zsh/zutil\n\n\tautoload -Uz add-zsh-hook\n\tautoload -Uz vcs_info\n\tautoload -Uz async && async\n\n\t# The `add-zle-hook-widget` function is not guaranteed to be available.\n\t# It was added in Zsh 5.3.\n\tautoload -Uz +X add-zle-hook-widget 2>/dev/null\n\n\t# Set the colors.\n\ttypeset -gA prompt_pure_colors_default prompt_pure_colors\n\tprompt_pure_colors_default=(\n\t\texecution_time       yellow\n\t\tgit:arrow            cyan\n\t\tgit:stash            cyan\n\t\tgit:branch           242\n\t\tgit:branch:cached    red\n\t\tgit:action           yellow\n\t\tgit:dirty            218\n\t\thost                 242\n\t\tpath                 blue\n\t\tprompt:error         red\n\t\tprompt:success       magenta\n\t\tprompt:continuation  242\n\t\tsuspended_jobs       red\n\t\tuser                 242\n\t\tuser:root            default\n\t\tvirtualenv           242\n\t)\n\tprompt_pure_colors=(\"${(@kv)prompt_pure_colors_default}\")\n\n\tadd-zsh-hook precmd prompt_pure_precmd\n\tadd-zsh-hook preexec prompt_pure_preexec\n\n\tprompt_pure_state_setup\n\n\tzle -N prompt_pure_reset_prompt\n\tzle -N prompt_pure_update_vim_prompt_widget\n\tzle -N prompt_pure_reset_vim_prompt_widget\n\tif (( $+functions[add-zle-hook-widget] )); then\n\t\tadd-zle-hook-widget zle-line-finish prompt_pure_reset_vim_prompt_widget\n\t\tadd-zle-hook-widget zle-keymap-select prompt_pure_update_vim_prompt_widget\n\tfi\n\n\t# If a virtualenv is activated, display it in grey.\n\tPROMPT='%(12V.%F{$prompt_pure_colors[virtualenv]}%12v%f .)'\n\n\t# Prompt turns red if the previous command didn't exit with 0.\n\tlocal prompt_indicator='%(?.%F{$prompt_pure_colors[prompt:success]}.%F{$prompt_pure_colors[prompt:error]})${prompt_pure_state[prompt]}%f '\n\tPROMPT+=$prompt_indicator\n\n\t# Indicate continuation prompt by … and use a darker color for it.\n\tPROMPT2='%F{$prompt_pure_colors[prompt:continuation]}… %(1_.%_ .%_)%f'$prompt_indicator\n\n\t# Store prompt expansion symbols for in-place expansion via (%). For\n\t# some reason it does not work without storing them in a variable first.\n\ttypeset -ga prompt_pure_debug_depth\n\tprompt_pure_debug_depth=('%e' '%N' '%x')\n\n\t# Compare is used to check if %N equals %x. When they differ, the main\n\t# prompt is used to allow displaying both filename and function. When\n\t# they match, we use the secondary prompt to avoid displaying duplicate\n\t# information.\n\tlocal -A ps4_parts\n\tps4_parts=(\n\t\tdepth \t  '%F{yellow}${(l:${(%)prompt_pure_debug_depth[1]}::+:)}%f'\n\t\tcompare   '${${(%)prompt_pure_debug_depth[2]}:#${(%)prompt_pure_debug_depth[3]}}'\n\t\tmain      '%F{blue}${${(%)prompt_pure_debug_depth[3]}:t}%f%F{242}:%I%f %F{242}@%f%F{blue}%N%f%F{242}:%i%f'\n\t\tsecondary '%F{blue}%N%f%F{242}:%i'\n\t\tprompt \t  '%F{242}>%f '\n\t)\n\t# Combine the parts with conditional logic. First the `:+` operator is\n\t# used to replace `compare` either with `main` or an ampty string. Then\n\t# the `:-` operator is used so that if `compare` becomes an empty\n\t# string, it is replaced with `secondary`.\n\tlocal ps4_symbols='${${'${ps4_parts[compare]}':+\"'${ps4_parts[main]}'\"}:-\"'${ps4_parts[secondary]}'\"}'\n\n\t# Improve the debug prompt (PS4), show depth by repeating the +-sign and\n\t# add colors to highlight essential parts like file and function name.\n\tPROMPT4=\"${ps4_parts[depth]} ${ps4_symbols}${ps4_parts[prompt]}\"\n\n\t# Guard against Oh My Zsh themes overriding Pure.\n\tunset ZSH_THEME\n\n\t# Guard against (ana)conda changing the PS1 prompt\n\t# (we manually insert the env when it's available).\n\texport CONDA_CHANGEPS1=no\n}\n\nprompt_pure_setup \"$@\"\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 13.7724609375,
          "content": "# Pure\n\n> Pretty, minimal and fast ZSH prompt\n\n<img src=\"screenshot.png\" width=\"864\">\n\n## Overview\n\nMost prompts are cluttered, ugly and slow. We wanted something visually pleasing that stayed out of our way.\n\n### Why?\n\n- Comes with the perfect prompt character.\n  Author went through the whole Unicode range to find it.\n- Shows `git` branch and whether it's dirty (with a `*`).\n- Indicates when you have unpushed/unpulled `git` commits with up/down arrows. *(Check is done asynchronously!)*\n- Prompt character turns red if the last command didn't exit with `0`.\n- Command execution time will be displayed if it exceeds the set threshold.\n- Username and host only displayed when in an SSH session or a container.\n- Shows the current path in the title and the [current folder & command](screenshot-title-cmd.png) when a process is running.\n- Support VI-mode indication by reverse prompt symbol (Zsh 5.3+).\n- Makes an excellent starting point for your own custom prompt.\n\n## Install\n\nCan be installed with `npm` (not `yarn`) or manually. Requires Git 2.15.2+ and ZSH 5.2+. Older versions of ZSH are known to work, but they are **not** recommended.\n\n### npm\n\n```sh\nnpm install --global pure-prompt\n```\n\nThat's it. Skip to [Getting started](#getting-started).\n\n### [Homebrew](https://brew.sh)\n\n```sh\nbrew install pure\n```\n\nIf you're not using ZSH from Homebrew (`brew install zsh` and `$(brew --prefix)/bin/zsh`), you must also add the site-functions to your `fpath` in `$HOME/.zshrc`:\n\n```sh\nfpath+=(\"$(brew --prefix)/share/zsh/site-functions\")\n```\n\n### Manually\n\n1. Clone this repo somewhere. Here we'll use `$HOME/.zsh/pure`.\n\n```sh\nmkdir -p \"$HOME/.zsh\"\ngit clone https://github.com/sindresorhus/pure.git \"$HOME/.zsh/pure\"\n```\n\n2. Add the path of the cloned repo to `$fpath` in `$HOME/.zshrc`.\n```sh\n# .zshrc\nfpath+=($HOME/.zsh/pure)\n```\n\n## Getting started\n\nInitialize the prompt system (if not so already) and choose `pure`:\n\n```sh\n# .zshrc\nautoload -U promptinit; promptinit\nprompt pure\n```\n\n## Options\n\n| Option                           | Description                                                                                    | Default value  |\n| :------------------------------- | :--------------------------------------------------------------------------------------------- | :------------- |\n| **`PURE_CMD_MAX_EXEC_TIME`**     | The max execution time of a process before its run time is shown when it exits.                | `5` seconds    |\n| **`PURE_GIT_PULL`**              | Prevents Pure from checking whether the current Git remote has been updated.                   | `1`            |\n| **`PURE_GIT_UNTRACKED_DIRTY`**   | Do not include untracked files in dirtiness check. Mostly useful on large repos (like WebKit). | `1`            |\n| **`PURE_GIT_DELAY_DIRTY_CHECK`** | Time in seconds to delay git dirty checking when `git status` takes > 5 seconds.               | `1800` seconds |\n| **`PURE_PROMPT_SYMBOL`**         | Defines the prompt symbol.                                                                     | `❯`            |\n| **`PURE_PROMPT_VICMD_SYMBOL`**   | Defines the prompt symbol used when the `vicmd` keymap is active (VI-mode).                    | `❮`            |\n| **`PURE_GIT_DOWN_ARROW`**        | Defines the git down arrow symbol.                                                             | `⇣`            |\n| **`PURE_GIT_UP_ARROW`**          | Defines the git up arrow symbol.                                                               | `⇡`            |\n| **`PURE_GIT_STASH_SYMBOL`**      | Defines the git stash symbol.                                                                  | `≡`            |\n\n## Zstyle options\n\nShowing git stash status as part of the prompt is not activated by default. To activate this you'll need to opt in via `zstyle`:\n\n`zstyle :prompt:pure:git:stash show yes`\n\nYou can set Pure to only `git fetch` the upstream branch of the current local branch. In some cases, this can result in faster updates for Git arrows, but for most users, it's better to leave this setting disabled. You can enable it with:\n\n`zstyle :prompt:pure:git:fetch only_upstream yes`\n\n`nix-shell` integration adds the shell name to the prompt when used from within a nix shell. It is enabled by default, you can disable it with:\n\n`zstyle :prompt:pure:environment:nix-shell show no`\n\n## Colors\n\nAs explained in ZSH's [manual](http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Character-Highlighting), color values can be:\n- A decimal integer corresponding to the color index of your terminal. If your `$TERM` is `xterm-256color`, see this [chart](https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg).\n- The name of one of the following nine colors: `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white`, and `default` (the terminal’s default foreground)\n- `#` followed by an RGB triplet in hexadecimal format, for example `#424242`. Only if your terminal supports 24-bit colors (true color) or when the [`zsh/nearcolor` module](http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fnearcolor-Module) is loaded.\n\nColors can be changed by using [`zstyle`](http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzutil-Module) with a pattern of the form `:prompt:pure:$color_name` and style `color`. The color names, their default, and what part they affect are:\n- `execution_time` (yellow) - The execution time of the last command when exceeding `PURE_CMD_MAX_EXEC_TIME`.\n- `git:arrow` (cyan) - For `PURE_GIT_UP_ARROW` and `PURE_GIT_DOWN_ARROW`.\n- `git:stash` (cyan) - For `PURE_GIT_STASH_SYMBOL`.\n- `git:branch` (242) - The name of the current branch when in a Git repository.\n- `git:branch:cached` (red) - The name of the current branch when the data isn't fresh.\n- `git:action` (242) - The current action in progress (cherry-pick, rebase, etc.) when in a Git repository.\n- `git:dirty` (218) - The asterisk showing the branch is dirty.\n- `host` (242) - The hostname when on a remote machine.\n- `path` (blue) - The current path, for example, `PWD`.\n- `prompt:error` (red) - The `PURE_PROMPT_SYMBOL` when the previous command has *failed*.\n- `prompt:success` (magenta) - The `PURE_PROMPT_SYMBOL` when the previous command has *succeeded*.\n- `prompt:continuation` (242) - The color for showing the state of the parser in the continuation prompt (PS2). It's the pink part in [this screenshot](https://user-images.githubusercontent.com/147409/70068574-ebc74800-15f8-11ea-84c0-8b94a4b57ff4.png), it appears in the same spot as `virtualenv`. You could for example matching both colors so that Pure has a uniform look.\n- `suspended_jobs` (red) - The `✦` symbol indicates that jobs are running in the background.\n- `user` (242) - The username when on remote machine.\n- `user:root` (default) - The username when the user is root.\n- `virtualenv` (242) - The name of the Python `virtualenv` when in use.\n\nThe following diagram shows where each color is applied on the prompt:\n\n```\n┌────────────────────────────────────────────────────── user\n│      ┌─────────────────────────────────────────────── host\n│      │           ┌─────────────────────────────────── path\n│      │           │          ┌──────────────────────── git:branch\n│      │           │          │     ┌────────────────── git:dirty\n│      │           │          │     │ ┌──────────────── git:action\n│      │           │          │     │ │        ┌─────── git:arrow\n│      │           │          │     │ │        │ ┌───── git:stash\n│      │           │          │     │ │        │ │ ┌─── execution_time\n│      │           │          │     │ │        │ │ │\nzaphod@heartofgold ~/dev/pure master* rebase-i ⇡ ≡ 42s\nvenv ❯\n│    │\n│    └───────────────────────────────────────────────── prompt\n└────────────────────────────────────────────────────── virtualenv (or prompt:continuation)\n```\n\n### RGB colors\n\nThere are two ways to use RGB colors with the hexadecimal format. The correct way is to use a [terminal that support 24-bit colors](https://gist.github.com/XVilka/8346728) and enable this feature as explained in the terminal's documentation.\n\nIf you can't use such terminal, the module [`zsh/nearcolor`](http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fnearcolor-Module) can be useful. It will map any hexadecimal color to the nearest color in the 88 or 256 color palettes of your terminal, but without using the first 16 colors, since their values can be modified by the user. Keep in mind that when using this module you won't be able to display true RGB colors. It only allows you to specify colors in a more convenient way. The following is an example on how to use this module:\n\n```sh\n# .zshrc\nzmodload zsh/nearcolor\nzstyle :prompt:pure:path color '#FF0000'\n```\n\n## Example\n\n```sh\n# .zshrc\n\nautoload -U promptinit; promptinit\n\n# optionally define some options\nPURE_CMD_MAX_EXEC_TIME=10\n\n# change the path color\nzstyle :prompt:pure:path color white\n\n# change the color for both `prompt:success` and `prompt:error`\nzstyle ':prompt:pure:prompt:*' color cyan\n\n# turn on git stash status\nzstyle :prompt:pure:git:stash show yes\n\nprompt pure\n```\n\n## Tips\n\nIn the screenshot you see Pure running in [Hyper](https://hyper.is) with the [hyper-snazzy](https://github.com/sindresorhus/hyper-snazzy) theme and Menlo font.\n\nThe [Tomorrow Night Eighties](https://github.com/chriskempson/tomorrow-theme) theme with the [Droid Sans Mono](https://www.fontsquirrel.com/fonts/droid-sans-mono) font (15pt) is also a [nice combination](https://github.com/sindresorhus/pure/blob/95ee3e7618c6e2162a1e3cdac2a88a20ac3beb27/screenshot.png).<br>\n*Just make sure you have anti-aliasing enabled in your terminal.*\n\nTo have commands colorized as seen in the screenshot, install [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting).\n\n## Integration\n\n### [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n\n1. Set `ZSH_THEME=\"\"` in your `.zshrc` to disable oh-my-zsh themes.\n2. Follow the Pure [Install](#install) instructions.\n3. Do not enable the following (incompatible) plugins: `vi-mode`, `virtualenv`.\n\n**NOTE:** `oh-my-zsh` overrides the prompt so Pure must be activated *after* `source $ZSH/oh-my-zsh.sh`.\n\n### [prezto](https://github.com/sorin-ionescu/prezto)\n\nPure is bundled with Prezto. No need to install it.\n\nAdd `prompt pure` to your `~/.zpreztorc`.\n\n### [zim](https://github.com/Eriner/zim)\n\nAdd `zmodule sindresorhus/pure --source async.zsh --source pure.zsh` to your `.zimrc` and run `zimfw install`.\n\n### [zplug](https://github.com/zplug/zplug)\n\nUpdate your `.zshrc` file with the following two lines:\n\n```sh\nzplug mafredri/zsh-async, from:github\nzplug sindresorhus/pure, use:pure.zsh, from:github, as:theme\n```\n\n### [zinit](https://github.com/zdharma-continuum/zinit)\n\nUpdate your `.zshrc` file with the following two lines (order matters):\n\n```sh\nzinit ice compile'(pure|async).zsh' pick'async.zsh' src'pure.zsh'\nzinit light sindresorhus/pure\n```\n\n### [zi](https://wiki.zshell.dev)\n\nUpdate your `.zshrc` file with the following line:\n\n```sh\nzi light-mode for @sindresorhus/pure\n```\n\nSee the [ZI wiki](https://wiki.zshell.dev/community/gallery/collection/themes#thp-sindresorhuspure) for more.\n\n## FAQ\n\nThere are currently no FAQs.\n\nSee [FAQ Archive](https://github.com/sindresorhus/pure/wiki/FAQ-Archive) for previous FAQs.\n\n## Ports\n\n- **ZSH**\n\t- [therealklanni/purity](https://github.com/therealklanni/purity) - More compact current working directory, important details on the main prompt line, and extra Git indicators.\n \t- [intelfx/pure](https://github.com/intelfx/pure) - Solarized-friendly colors, highly verbose, and fully async Git integration.\n\t- [forivall/pure](https://github.com/forivall/pure) - A minimal fork which highlights the Git repo's root directory in the path.\n\t- [dfurnes/purer](https://github.com/dfurnes/purer) - Compact single-line prompt with built-in Vim-mode indicator.\n\t- [chabou/pure-now](https://github.com/chabou/pure-now) - Fork with [Now](https://zeit.co/now) support.\n\t- [pure10k](https://gist.github.com/romkatv/7cbab80dcbc639003066bb68b9ae0bbf) - Configuration file for [Powerlevel10k](https://github.com/romkatv/powerlevel10k/) that makes it look like Pure.\n- **Bash**\n\t- [sapegin/dotfiles](https://github.com/sapegin/dotfiles) - [Prompt](https://github.com/sapegin/dotfiles/blob/dd063f9c30de7d2234e8accdb5272a5cc0a3388b/includes/bash_prompt.bash) and [color theme](https://github.com/sapegin/dotfiles/tree/master/color) for Terminal.app.\n- **Fish**\n\t- [pure-fish/pure](https://github.com/pure-fish/pure) - Fully tested Fish port aiming for feature parity.\n- **Rust**\n\t- [xcambar/purs](https://github.com/xcambar/purs) - Pure-inspired prompt in Rust.\n- **Go**\n\t- [talal/mimir](https://github.com/talal/mimir) - Pure-inspired prompt in Go with Kubernetes and OpenStack cloud support. Not intended to have feature parity.\n- **PowerShell**\n\t- [nickcox/pure-pwsh](https://github.com/nickcox/pure-pwsh/) - PowerShell/PS Core implementation of the Pure prompt.\n\n## Team\n\n[![Sindre Sorhus](https://github.com/sindresorhus.png?size=100)](https://sindresorhus.com) | [![Mathias Fredriksson](https://github.com/mafredri.png?size=100)](https://github.com/mafredri)\n---|---\n[Sindre Sorhus](https://github.com/sindresorhus) | [Mathias Fredriksson](https://github.com/mafredri)\n"
        },
        {
          "name": "screenshot-title-cmd.png",
          "type": "blob",
          "size": 24.26171875,
          "content": null
        },
        {
          "name": "screenshot.png",
          "type": "blob",
          "size": 70.4306640625,
          "content": null
        }
      ]
    }
  ]
}