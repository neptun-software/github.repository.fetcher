{
  "metadata": {
    "timestamp": 1736568951857,
    "page": 60,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "89luca89/distrobox",
      "stars": 10369,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "tags\n*.vim\nTODO.txt\n"
        },
        {
          "name": ".markdownlint.yaml",
          "type": "blob",
          "size": 0.1376953125,
          "content": "---\nMD013:\n  line_length: 120\n  code_blocks: false\n  tables: false\n  headings: false\n  headers: false\nMD033: false\nMD041: false\nMD045: false\n"
        },
        {
          "name": ".shellcheckrc",
          "type": "blob",
          "size": 1.0166015625,
          "content": "# Overrides the shell detected from the shebang. This is useful for files meant to be included (and thus lacking a shebang), or possibly as a more targeted alternative to 'disable=SC2039'.\nshell=sh\n\n# Always allow ShellCheck to open arbitrary files from 'source' statements.\nexternal-sources=true\n\n# Enable all optional checks\nenable=all\n\n# This function is invoked in an 'if' condition so set -e will be disabled. Invoke separately if failures should cause the script to exit.\n# - We don't want to exit if errors happen inside a check, that's why we have a check...\ndisable=SC2310\n\n# Bash implicitly disabled set -e for this function invocation because it's inside a command substitution. Add set -e; before it or enable inherit_errexit.\n# - Don't care if we inherit errexit inside substitutions, we do checks for that.\ndisable=SC2311\n\n# Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore).\n# - We already check errors and adding \"|| true\" everywhere hinders readability.\ndisable=SC2312\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.2412109375,
          "content": "# Code of Conduct\n\nLet's just all be nice to each other and ourselves. Do we really need this?\n\nJust follow them:\n\n![wholesome](https://i.kym-cdn.com/photos/images/newsfeed/001/407/983/841.jpg)\n\n## Let's just all be wholesome to each other please\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.236328125,
          "content": "# Contributing to Distrobox\n\nWe greatly appreciate your input! We want to make contributing to this project\nas easy and transparent as possible, whether it's:\n\n- Reporting a bug\n- Discussing the current state of the code\n- Submitting a fix\n- Proposing new features\n\n## Creating a Pull Requests\n\nPull requests are the best way to propose changes to the codebase.  \nWe actively welcome your pull requests:\n\n1. Fork the repo and create your branch from `main`.\n2. If you've added code that should be tested, add tests.\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code lints.\n6. Issue that pull request!\n\n## Any contributions you make will be under the GPLv3 Software License\n\nIn short, when you submit code changes, your submissions are understood to be\nunder the same [GPLv3 License](https://choosealicense.com/licenses/gpl-3.0/) that\ncovers the project.\nFeel free to contact the maintainers if that's a concern.\n\n## Suggestions\n\nSuggestions are welcome, be sure:\n\n- It is not already being discussed in the [issue tracker](https://github.com/89luca89/distrobox/issues)\n  - If it has and is marked as OPEN, go ahead and share your own\n    thoughts about the topic!\n  - If it has and is marked as CLOSED, please read the ticket and depending on\n    whether the suggestion was accepted consider if it is worth opening\n    a new issue or not.\n- Consider if the suggestion is not too out of scope of the project.\n- Mark them with a [Suggestion] in the title.\n\n## Report bugs using GitHub's [issues](https://github.com/89luca89/distrobox/issues)\n\nWe use GitHub issues to track public bugs.\nReport a bug by\n[opening a new issue](https://github.com/89luca89/distrobox/issues); it's that easy!\n\n### Write bug reports with detail, background, and sample code\n\n**A good bug report** should have:\n\n- Check that the bug is not already discussed in the [issue tracker](https://github.com/89luca89/distrobox/issues)\n- See our [documentation](https://github.com/89luca89/distrobox/tree/main/docs)\n  if there are some steps that could help you solve your issue\n- Mark them with an [Error] in the title\n- A quick summary and/or background\n- Steps to reproduce\n  - Be specific!\n  - Provide logs (terminal output, runs with verbose mode)\n- What you expected would happen\n- What actually happens\n- Notes (possibly including why you think this might be happening, or stuff you\n  tried that didn't work)\n\n## Use a Consistent Coding Style\n\n- check if files have some problems with POSIX using the following:\n\n```shell\nfor file in $(find . -type f -not -path \"*.git*\"); do\n    if file \"$file\" | grep -qi shell; then\n      echo \"### Checking file $file...\"\n      dash -n $file\n      result=$(( result + $? ))\n      echo \"Result: $result\"\n    fi\ndone\n```\n\n  Here we're using `dash` to verify if there are any non-POSIX code inside the\n  scripts. Distrobox aims to be POSIX compliant so it's important to use a\n  strict POSIX compliant shell to verify. `dash` is available in all major distributions'\n  repositories.\n\n- use `shellcheck` to check for posix compliance and bashisms using:\n  - install from: [HERE](https://github.com/koalaman/shellcheck)\n    following [this](https://github.com/koalaman/shellcheck#installing)\n  - `shellcheck -s sh -a -o all -Sstyle -Calways -x -e SC2310,SC2311,SC2312`\n- use `shfmt` to style the code using:\n  - install from [HERE](https://github.com/mvdan/sh) using `go install mvdan.cc/sh/v3/cmd/shfmt@latest`\n  - `shfmt shfmt -d -s -ci -sr -kp`\n- use `bashate` to check the code:\n  - install using `pip3 install bashate`\n  - `bashate -i E002,E003,E010,E011 --max-line-length 120`\n- use `markdownlint`\n  - install using `npm -i -g markdownlint-cli`\n  - run `markdownlint $(find . -name '*.md' | grep -vF './.git')`\n- Legibility of the code is more important than code golfing, try to be\n  expressive in the code\n- Try to **follow the happy path**:\n  - [This guide](https://maelvls.dev/go-happy-line-of-sight/) is for golang,\n    but it's a very insightful source to follow\n- Error checking is important! Ensure to LBYL (Look Before You Leap), check for\n  variables and for code success exit codes\n- If a command or function can fail, ensure you check the outcome:\n  - `if ! my_function; then ...`\n    this is important to handle errors gracefully and to potentially warn users\n    of what's happening\n- Use snake_case for variable naming. Keep variable names lowercase if they are\n  not an environment variable\n- Don't hesitate to comment your code! We're placing high importance on this to\n  maintain the code readable and understandeable\n- Update documentation to reflect your changes - Manual pages can be found in\n  directory `docs`\n\nIf you are using Visual Studio Code, there are [plugins](https://marketplace.visualstudio.com/items?itemName=timonwong.shellcheck)\nthat include all this functionality and throw a warning if you're doing\nsomething wrong.\nIf you are using Vim or Emacs there are plenty of linters and checkers that will\nintegrate with the 2 tools listed above.\n\n## License\n\nBy contributing, you agree that your contributions will be licensed under\nits GPLv3 License.\n\n## References\n\nThis document was adapted from the open-source contribution guidelines\nfor [Facebook's Draft](https://github.com/facebook/draft-js/blob/a9316a723f9e918afde44dea68b5f9f39b7d9b00/CONTRIBUTING.md).\n"
        },
        {
          "name": "COPYING.md",
          "type": "blob",
          "size": 34.0478515625,
          "content": "# GNU GENERAL PUBLIC LICENSE\n\nVersion 3, 29 June 2007\n\nCopyright (C) 2007 Free Software Foundation, Inc.\n<https://fsf.org/>\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n## Preamble\n\nThe GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\nThe licenses for most software and other practical works are designed\nto take away your freedom to share and change the works. By contrast,\nthe GNU General Public License is intended to guarantee your freedom\nto share and change all versions of a program--to make sure it remains\nfree software for all its users. We, the Free Software Foundation, use\nthe GNU General Public License for most of our software; it applies\nalso to any other work released this way by its authors. You can apply\nit to your programs, too.\n\nWhen we speak of free software, we are referring to freedom, not\nprice. Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\nTo protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights. Therefore, you\nhave certain responsibilities if you distribute copies of the\nsoftware, or if you modify it: responsibilities to respect the freedom\nof others.\n\nFor example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received. You must make sure that they, too, receive\nor can get the source code. And you must show them these terms so they\nknow their rights.\n\nDevelopers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\nFor the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software. For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\nSome devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the\nmanufacturer can do so. This is fundamentally incompatible with the\naim of protecting users' freedom to change the software. The\nsystematic pattern of such abuse occurs in the area of products for\nindividuals to use, which is precisely where it is most unacceptable.\nTherefore, we have designed this version of the GPL to prohibit the\npractice for those products. If such problems arise substantially in\nother domains, we stand ready to extend this provision to those\ndomains in future versions of the GPL, as needed to protect the\nfreedom of users.\n\nFinally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish\nto avoid the special danger that patents applied to a free program\ncould make it effectively proprietary. To prevent this, the GPL\nassures that patents cannot be used to render the program non-free.\n\nThe precise terms and conditions for copying, distribution and\nmodification follow.\n\n### TERMS AND CONDITIONS\n\n#### 0. Definitions\n\n\"This License\" refers to version 3 of the GNU General Public License.\n\n\"Copyright\" also means copyright-like laws that apply to other kinds\nof works, such as semiconductor masks.\n\n\"The Program\" refers to any copyrightable work licensed under this\nLicense. Each licensee is addressed as \"you\". \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\nTo \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of\nan exact copy. The resulting work is called a \"modified version\" of\nthe earlier work or a work \"based on\" the earlier work.\n\nA \"covered work\" means either the unmodified Program or a work based\non the Program.\n\nTo \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy. Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\nTo \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies. Mere interaction with a user\nthrough a computer network, with no transfer of a copy, is not\nconveying.\n\nAn interactive user interface displays \"Appropriate Legal Notices\" to\nthe extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License. If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n#### 1. Source Code\n\nThe \"source code\" for a work means the preferred form of the work for\nmaking modifications to it. \"Object code\" means any non-source form of\na work.\n\nA \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\nThe \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form. A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\nThe \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities. However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work. For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\nThe Corresponding Source need not include anything that users can\nregenerate automatically from other parts of the Corresponding Source.\n\nThe Corresponding Source for a work in source code form is that same\nwork.\n\n#### 2. Basic Permissions\n\nAll rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met. This License explicitly affirms your unlimited\npermission to run the unmodified Program. The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work. This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\nYou may make, run and propagate covered works that you do not convey,\nwithout conditions so long as your license otherwise remains in force.\nYou may convey covered works to others for the sole purpose of having\nthem make modifications exclusively for you, or provide you with\nfacilities for running those works, provided that you comply with the\nterms of this License in conveying all material for which you do not\ncontrol copyright. Those thus making or running the covered works for\nyou must do so exclusively on your behalf, under your direction and\ncontrol, on terms that prohibit them from making any copies of your\ncopyrighted material outside their relationship with you.\n\nConveying under any other circumstances is permitted solely under the\nconditions stated below. Sublicensing is not allowed; section 10 makes\nit unnecessary.\n\n#### 3. Protecting Users' Legal Rights From Anti-Circumvention Law\n\nNo covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\nWhen you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such\ncircumvention is effected by exercising rights under this License with\nrespect to the covered work, and you disclaim any intention to limit\noperation or modification of the work as a means of enforcing, against\nthe work's users, your or third parties' legal rights to forbid\ncircumvention of technological measures.\n\n#### 4. Conveying Verbatim Copies\n\nYou may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\nYou may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n#### 5. Conveying Modified Source Versions\n\nYou may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these\nconditions:\n\n- a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n- b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under\n    section 7. This requirement modifies the requirement in section 4\n    to \"keep intact all notices\".\n- c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy. This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged. This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n- d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\nA compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit. Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n#### 6. Conveying Non-Source Forms\n\nYou may convey a covered work in object code form under the terms of\nsections 4 and 5, provided that you also convey the machine-readable\nCorresponding Source under the terms of this License, in one of these\nways:\n\n- a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n- b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the Corresponding\n    Source from a network server at no charge.\n- c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source. This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n- d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge. You need not require recipients to copy the\n    Corresponding Source along with the object code. If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source. Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n- e) Convey the object code using peer-to-peer transmission,\n    provided you inform other peers where the object code and\n    Corresponding Source of the work are being offered to the general\n    public at no charge under subsection 6d.\n\nA separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\nA \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal,\nfamily, or household purposes, or (2) anything designed or sold for\nincorporation into a dwelling. In determining whether a product is a\nconsumer product, doubtful cases shall be resolved in favor of\ncoverage. For a particular product received by a particular user,\n\"normally used\" refers to a typical or common use of that class of\nproduct, regardless of the status of the particular user or of the way\nin which the particular user actually uses, or expects or is expected\nto use, the product. A product is a consumer product regardless of\nwhether the product has substantial commercial, industrial or\nnon-consumer uses, unless such uses represent the only significant\nmode of use of the product.\n\n\"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to\ninstall and execute modified versions of a covered work in that User\nProduct from a modified version of its Corresponding Source. The\ninformation must suffice to ensure that the continued functioning of\nthe modified object code is in no case prevented or interfered with\nsolely because modification has been made.\n\nIf you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information. But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\nThe requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or\nupdates for a work that has been modified or installed by the\nrecipient, or for the User Product in which it has been modified or\ninstalled. Access to a network may be denied when the modification\nitself materially and adversely affects the operation of the network\nor violates the rules and protocols for communication across the\nnetwork.\n\nCorresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n#### 7. Additional Terms\n\n\"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law. If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\nWhen you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit. (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.) You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\nNotwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders\nof that material) supplement the terms of this License with terms:\n\n- a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n- b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n- c) Prohibiting misrepresentation of the origin of that material,\n    or requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n- d) Limiting the use for publicity purposes of names of licensors\n    or authors of the material; or\n- e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n- f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions\n    of it) with contractual assumptions of liability to the recipient,\n    for any liability that these contractual assumptions directly\n    impose on those licensors and authors.\n\nAll other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10. If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term. If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\nIf you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\nAdditional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions; the\nabove requirements apply either way.\n\n#### 8. Termination\n\nYou may not propagate or modify a covered work except as expressly\nprovided under this License. Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\nHowever, if you cease all violation of this License, then your license\nfrom a particular copyright holder is reinstated (a) provisionally,\nunless and until the copyright holder explicitly and finally\nterminates your license, and (b) permanently, if the copyright holder\nfails to notify you of the violation by some reasonable means prior to\n60 days after the cessation.\n\nMoreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\nTermination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License. If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n#### 9. Acceptance Not Required for Having Copies\n\nYou are not required to accept this License in order to receive or run\na copy of the Program. Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance. However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work. These actions infringe copyright if you do\nnot accept this License. Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n#### 10. Automatic Licensing of Downstream Recipients\n\nEach time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License. You are not responsible\nfor enforcing compliance by third parties with this License.\n\nAn \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations. If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\nYou may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License. For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n#### 11. Patents\n\nA \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based. The\nwork thus licensed is called the contributor's \"contributor version\".\n\nA contributor's \"essential patent claims\" are all patent claims owned\nor controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version. For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\nEach contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\nIn the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement). To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\nIf you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients. \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\nIf, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\nA patent license is \"discriminatory\" if it does not include within the\nscope of its coverage, prohibits the exercise of, or is conditioned on\nthe non-exercise of one or more of the rights that are specifically\ngranted under this License. You may not convey a covered work if you\nare a party to an arrangement with a third party that is in the\nbusiness of distributing software, under which you make payment to the\nthird party based on the extent of your activity of conveying the\nwork, and under which the third party grants, to any of the parties\nwho would receive the covered work from you, a discriminatory patent\nlicense (a) in connection with copies of the covered work conveyed by\nyou (or copies made from those copies), or (b) primarily for and in\nconnection with specific products or compilations that contain the\ncovered work, unless you entered into that arrangement, or that patent\nlicense was granted, prior to 28 March 2007.\n\nNothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n#### 12. No Surrender of Others' Freedom\n\nIf conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License. If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under\nthis License and any other pertinent obligations, then as a\nconsequence you may not convey it at all. For example, if you agree to\nterms that obligate you to collect a royalty for further conveying\nfrom those to whom you convey the Program, the only way you could\nsatisfy both those terms and this License would be to refrain entirely\nfrom conveying the Program.\n\n#### 13. Use with the GNU Affero General Public License\n\nNotwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work. The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n#### 14. Revised Versions of this License\n\nThe Free Software Foundation may publish revised and/or new versions\nof the GNU General Public License from time to time. Such new versions\nwill be similar in spirit to the present version, but may differ in\ndetail to address new problems or concerns.\n\nEach version is given a distinguishing version number. If the Program\nspecifies that a certain numbered version of the GNU General Public\nLicense \"or any later version\" applies to it, you have the option of\nfollowing the terms and conditions either of that numbered version or\nof any later version published by the Free Software Foundation. If the\nProgram does not specify a version number of the GNU General Public\nLicense, you may choose any version ever published by the Free\nSoftware Foundation.\n\nIf the Program specifies that a proxy can decide which future versions\nof the GNU General Public License can be used, that proxy's public\nstatement of acceptance of a version permanently authorizes you to\nchoose that version for the Program.\n\nLater license versions may give you additional or different\npermissions. However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n#### 15. Disclaimer of Warranty\n\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT\nWARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND\nPERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE\nDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR\nCORRECTION.\n\n#### 16. Limitation of Liability\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR\nCONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES\nARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT\nNOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR\nLOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM\nTO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER\nPARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n#### 17. Interpretation of Sections 15 and 16\n\nIf the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\nEND OF TERMS AND CONDITIONS\n\n### How to Apply These Terms to Your New Programs\n\nIf you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these\nterms.\n\nTo do so, attach the following notices to the program. It is safest to\nattach them to the start of each source file to most effectively state\nthe exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n        <one line to give the program's name and a brief idea of what it does.>\n        Copyright (C) <year>  <name of author>\n\n        This program is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        This program is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper\nmail.\n\nIf the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n        <program>  Copyright (C) <year>  <name of author>\n        This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n        This is free software, and you are welcome to redistribute it\n        under certain conditions; type `show c' for details.\n\nThe hypothetical commands \\`show w' and \\`show c' should show the\nappropriate parts of the General Public License. Of course, your\nprogram's commands might be different; for a GUI interface, you would\nuse an \"about box\".\n\nYou should also get your employer (if you work as a programmer) or\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary. For more information on this, and how to apply and follow\nthe GNU GPL, see <https://www.gnu.org/licenses/>.\n\nThe GNU General Public License does not permit incorporating your\nprogram into proprietary programs. If your program is a subroutine\nlibrary, you may consider it more useful to permit linking proprietary\napplications with the library. If this is what you want to do, use the\nGNU Lesser General Public License instead of this License. But first,\nplease read <https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "Containerfile",
          "type": "blob",
          "size": 0.068359375,
          "content": "FROM  docker.io/mgoltzsche/podman:latest\n\nCOPY ./distrobox* /usr/bin/\n"
        },
        {
          "name": "completions",
          "type": "tree",
          "content": null
        },
        {
          "name": "distrobox",
          "type": "blob",
          "size": 2.2158203125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\nset -o errexit\nset -o nounset\n\nversion=\"1.8.0\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nChoose one of the available commands:\n\tassemble\n\tcreate\n\tenter\n\tlist | ls\n\trm\n\tstop\n\tupgrade\n\tephemeral\n\tgenerate-entry\n\tversion\n\thelp\nEOF\n}\n\nif [ $# -eq 0 ]; then\n\tshow_help\n\texit\nfi\n\ndistrobox_path=\"$(dirname \"${0}\")\"\ndistrobox_command=\"${1}\"\nshift\n\n# Simple wrapper to the distrobox utilities.\n# We just detect the 1st argument and launch the matching distrobox utility.\ncase \"${distrobox_command}\" in\n\tassemble)\n\t\t\"${distrobox_path}\"/distrobox-assemble \"$@\"\n\t\t;;\n\tcreate)\n\t\t\"${distrobox_path}\"/distrobox-create \"$@\"\n\t\t;;\n\tenter)\n\t\t\"${distrobox_path}\"/distrobox-enter \"$@\"\n\t\t;;\n\tls | list)\n\t\t\"${distrobox_path}\"/distrobox-list \"$@\"\n\t\t;;\n\tstop)\n\t\t\"${distrobox_path}\"/distrobox-stop \"$@\"\n\t\t;;\n\trm)\n\t\t\"${distrobox_path}\"/distrobox-rm \"$@\"\n\t\t;;\n\tupgrade)\n\t\t\"${distrobox_path}\"/distrobox-upgrade \"$@\"\n\t\t;;\n\tgenerate-entry)\n\t\t\"${distrobox_path}\"/distrobox-generate-entry \"$@\"\n\t\t;;\n\tephemeral)\n\t\t\"${distrobox_path}\"/distrobox-ephemeral \"$@\"\n\t\t;;\n\t-V | --version | version)\n\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\texit 0\n\t\t;;\n\thelp | --help | -h)\n\t\tshow_help\n\t\texit 0\n\t\t;;\n\t*) # Default case: If no more options then break out of the loop.\n\t\tprintf >&2 \"Error: invalid command\\n\"\n\t\tshow_help\n\t\texit 1\n\t\t;;\nesac\n"
        },
        {
          "name": "distrobox-assemble",
          "type": "blob",
          "size": 16.53125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# POSIX\n#\ndefault_input_file=\"./distrobox.ini\"\ndelete=-1\ndistrobox_path=\"$(dirname \"${0}\")\"\ndryrun=0\nboxname=\"\"\ninput_file=\"\"\nreplace=0\nroot_flag=\"\"\n# tmpfile will be used as a little buffer to pass variables without messing up\n# quoting and escaping\ntmpfile=\"$(mktemp -u)\"\ntmp_download_file=\"$(mktemp -u)\"\nverbose=0\nversion=\"1.8.0\"\n# initializing block of variables used in the manifest\nadditional_flags=\"\"\nadditional_packages=\"\"\nentry=\"\"\nhome=\"\"\nhostname=\"\"\nimage=\"\"\ninit=\"\"\ninit_hooks=\"\"\nnvidia=\"\"\npre_init_hooks=\"\"\npull=\"\"\nroot=\"\"\nstart_now=\"\"\nunshare_ipc=\"\"\nunshare_netns=\"\"\nunshare_process=\"\"\nunshare_devsys=\"\"\nunshare_all=\"\"\nvolume=\"\"\nexported_apps=\"\"\nexported_bins=\"\"\nexported_bins_path=\"${HOME}/.local/bin\"\n\n# Cleanup tmpfiles on exit\ntrap 'rm -f ${tmpfile} ${tmp_download_file}' EXIT\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif [ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported.\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"Instead, please try using root=true property in the distrobox.ini file.\\n\"\n\texit 1\nfi\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: string distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox assemble create\n\tdistrobox assemble rm\n\tdistrobox assemble create --file /path/to/file.ini\n\tdistrobox assemble rm --file /path/to/file.ini\n\tdistrobox assemble create --replace --file /path/to/file.ini\n\nOptions:\n\n\t--file:\t\t\tpath or URL to the distrobox manifest/ini file\n\t--name/-n:\t\trun against a single entry in the manifest/ini file\n\t--replace/-R:\t\treplace already existing distroboxes with matching names\n\t--dry-run/-d:\t\tonly print the container manager command generated\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\tcreate)\n\t\t\tdelete=0\n\t\t\tshift\n\t\t\t;;\n\t\trm)\n\t\t\tdelete=1\n\t\t\tshift\n\t\t\t;;\n\t\t--file)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tinput_file=\"${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-n | --name)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tboxname=\"${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-d | --dry-run)\n\t\t\tshift\n\t\t\tdryrun=1\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-R | --replace)\n\t\t\treplace=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tinput_file=\"$1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# check if we're getting the right inputs\nif [ \"${delete}\" -eq -1 ]; then\n\tprintf >&2 \"Please specify create or rm.\\n\"\n\tshow_help\n\texit 1\nfi\n\n# Fallback to distrobox.ini if no file is passed\nif [ -z \"${input_file}\" ]; then\n\tinput_file=\"${default_input_file}\"\nfi\n\n# Check if file effectively exists\nif [ ! -e \"${input_file}\" ]; then\n\n\tif command -v curl > /dev/null 2>&1; then\n\t\tdownload=\"curl --connect-timeout 3 --retry 1 -sLo\"\n\telif command -v wget > /dev/null 2>&1; then\n\t\tdownload=\"wget --timeout=3 --tries=1 -qO\"\n\tfi\n\n\tif ! ${download} - \"${input_file}\" > \"${tmp_download_file}\"; then\n\t\tprintf >&2 \"File %s does not exist.\\n\" \"${input_file}\"\n\t\texit 1\n\telse\n\t\tinput_file=\"${tmp_download_file}\"\n\tfi\nfi\n\n# run_distrobox will create distrobox with parameters parsed from ini file.\n# Arguments:\n#   name: name of the distrobox.\n# Expected global variables:\n#   boxname: string name of the target container\n#   tmpfile: string name of the tmpfile to read\n#   delete:  bool delete container\n#   replace: bool replace container\n#   dryrun:  bool dryrun (only print, no execute)\n#   verbose: bool verbose\n# Expected env variables:\n#   None\n# Outputs:\n#   execution of the proper distrobox-create command.\nrun_distrobox()\n{\n\tname=\"${1}\"\n\tadditional_flags=\"\"\n\tadditional_packages=\"\"\n\tentry=\"\"\n\thome=\"\"\n\thostname=\"\"\n\timage=\"\"\n\tinit=\"\"\n\tinit_hooks=\"\"\n\tnvidia=\"\"\n\tpre_init_hooks=\"\"\n\tpull=\"\"\n\troot=\"\"\n\tstart_now=\"\"\n\tunshare_ipc=\"\"\n\tunshare_netns=\"\"\n\tunshare_process=\"\"\n\tunshare_devsys=\"\"\n\tunshare_all=\"\"\n\tvolume=\"\"\n\texported_apps=\"\"\n\texported_bins=\"\"\n\texported_bins_path=\"${HOME}/.local/bin\"\n\n\t# Skip item if --name used and no match is found\n\tif [ \"${boxname}\" != \"\" ] && [ \"${boxname}\" != \"${name}\" ]; then\n\t\trm -f \"${tmpfile}\"\n\t\treturn\n\tfi\n\n\t# Source the current block variables\n\tif [ -e \"${tmpfile}\" ]; then\n\t\t# shellcheck disable=SC1090\n\t\t. \"${tmpfile}\" && rm -f \"${tmpfile}\"\n\tfi\n\n\tif [ -n \"${root}\" ] && [ \"${root}\" -eq 1 ]; then\n\t\troot_flag=\"--root\"\n\tfi\n\n\t# We're going to delete, not create!\n\tif [ \"${delete}\" -ne 0 ] || [ \"${replace}\" -ne 0 ]; then\n\t\tprintf \" - Deleting %s...\\n\" \"${name}\"\n\n\t\tif [ \"${dryrun}\" -eq 0 ]; then\n\t\t\t# shellcheck disable=SC2086,2248\n\t\t\t\"${distrobox_path}\"/distrobox rm ${root_flag} -f \"${name}\" > /dev/null || :\n\t\tfi\n\n\t\tif [ \"${delete}\" -ne 0 ]; then\n\t\t\treturn\n\t\tfi\n\tfi\n\n\t# We're going to create!\n\tprintf \" - Creating %s...\\n\" \"${name}\"\n\n\t# If distrobox already exist, and we have replace enabled, destroy the container\n\t# we have to recreate it.\n\t# shellcheck disable=SC2086,2248\n\tif \"${distrobox_path}\"/distrobox-list ${root_flag} | grep -qw \" ${name} \" && [ \"${dryrun}\" -eq 0 ]; then\n\t\tprintf >&2 \"%s already exists\\n\" \"${name}\"\n\t\treturn 0\n\tfi\n\n\t# Now we dynamically generate the distrobox-create command based on the\n\t# declared flags.\n\tresult_command=\"${distrobox_path}/distrobox-create --yes\"\n\tif [ \"${verbose}\" -ne 0 ]; then\n\t\tresult_command=\"${result_command} -v\"\n\tfi\n\tif [ -n \"${name}\" ]; then\n\t\tresult_command=\"${result_command} --name $(sanitize_variable \"${name}\")\"\n\tfi\n\tif [ -n \"${image}\" ]; then\n\t\tresult_command=\"${result_command} --image $(sanitize_variable \"${image}\")\"\n\tfi\n\tif [ -n \"${init}\" ] && [ \"${init}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --init\"\n\tfi\n\tif [ -n \"${root}\" ] && [ \"${root}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --root\"\n\tfi\n\tif [ -n \"${pull}\" ] && [ \"${pull}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --pull\"\n\tfi\n\tif [ -n \"${entry}\" ] && [ \"${entry}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command} --no-entry\"\n\tfi\n\tif [ -n \"${nvidia}\" ] && [ \"${nvidia}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --nvidia\"\n\tfi\n\tif [ -n \"${unshare_netns}\" ] && [ \"${unshare_netns}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --unshare-netns\"\n\tfi\n\tif [ -n \"${unshare_ipc}\" ] && [ \"${unshare_ipc}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --unshare-ipc\"\n\tfi\n\tif [ -n \"${unshare_process}\" ] && [ \"${unshare_process}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --unshare-process\"\n\tfi\n\tif [ -n \"${unshare_devsys}\" ] && [ \"${unshare_devsys}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --unshare-devsys\"\n\tfi\n\tif [ -n \"${unshare_all}\" ] && [ \"${unshare_all}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command} --unshare-all\"\n\tfi\n\tif [ -n \"${home}\" ]; then\n\t\tresult_command=\"${result_command} --home $(sanitize_variable \"${home}\")\"\n\tfi\n\tif [ -n \"${hostname}\" ]; then\n\t\tresult_command=\"${result_command} --hostname $(sanitize_variable \"${hostname}\")\"\n\tfi\n\tif [ -n \"${init_hooks}\" ]; then\n\t\tIFS=\"\"\n\t\targs=\": ;\"\n\t\tseparator=\"\"\n\t\tfor arg in ${init_hooks}; do\n\t\t\tif [ -z \"${arg}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\t# Convert back from base64\n\t\t\targ=\"$(echo \"${arg}\" | base64 -d)\"\n\t\t\targs=\"${args} ${separator} ${arg}\"\n\n\t\t\t# Prepare for the next line, if we already have a ';' or '&&', do nothing\n\t\t\t# else prefer adding '&&'\n\t\t\tif ! echo \"${arg}\" | grep -qE ';[[:space:]]{0,1}$' &&\n\t\t\t\t! echo \"${arg}\" | grep -qE '&&[[:space:]]{0,1}$'; then\n\t\t\t\tseparator=\"&&\"\n\t\t\telse\n\t\t\t\tseparator=\"\"\n\t\t\tfi\n\t\tdone\n\t\tresult_command=\"${result_command} --init-hooks $(sanitize_variable \"${args}\")\"\n\tfi\n\t# Replicable flags\n\tif [ -n \"${pre_init_hooks}\" ]; then\n\t\tIFS=\"\"\n\t\targs=\": ;\"\n\t\tseparator=\"\"\n\t\tfor arg in ${pre_init_hooks}; do\n\t\t\tif [ -z \"${arg}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\t# Convert back from base64\n\t\t\targ=\"$(echo \"${arg}\" | base64 -d)\"\n\t\t\targs=\"${args} ${separator} ${arg}\"\n\n\t\t\t# Prepare for the next line, if we already have a ';' or '&&', do nothing\n\t\t\t# else prefer adding '&&'\n\t\t\tif ! echo \"${arg}\" | grep -qE ';[[:space:]]{0,1}$' &&\n\t\t\t\t! echo \"${arg}\" | grep -qE '&&[[:space:]]{0,1}$'; then\n\t\t\t\tseparator=\"&&\"\n\t\t\telse\n\t\t\t\tseparator=\"\"\n\t\t\tfi\n\t\tdone\n\t\tresult_command=\"${result_command} --pre-init-hooks $(sanitize_variable \"${args}\")\"\n\tfi\n\tif [ -n \"${additional_packages}\" ]; then\n\t\tIFS=\"\"\n\t\targs=\"\"\n\t\tfor packages in ${additional_packages}; do\n\t\t\tif [ -z \"${packages}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\targs=\"${args} ${packages}\"\n\t\tdone\n\t\tresult_command=\"${result_command} --additional-packages $(sanitize_variable \"${args}\")\"\n\tfi\n\tif [ -n \"${volume}\" ]; then\n\t\tIFS=\"\"\n\t\tfor vol in ${volume}; do\n\t\t\tif [ -z \"${vol}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\tresult_command=\"${result_command} --volume $(sanitize_variable \"${vol}\")\"\n\t\tdone\n\tfi\n\tif [ -n \"${additional_flags}\" ]; then\n\t\tIFS=\"\"\n\t\tfor flag in ${additional_flags}; do\n\t\t\tif [ -z \"${flag}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\tresult_command=\"${result_command} --additional-flags $(sanitize_variable \"${flag}\")\"\n\t\tdone\n\tfi\n\n\t# Execute the distrobox-create command\n\tif [ \"${dryrun}\" -ne 0 ]; then\n\t\techo \"${result_command}\"\n\t\treturn\n\tfi\n\teval \"${result_command}\"\n\n\t# If we need to start immediately, do it, so that the container\n\t# is ready to be entered.\n\tif [ -n \"${start_now}\" ] && [ \"${start_now}\" -eq 1 ]; then\n\t\t# shellcheck disable=SC2086,2248\n\t\t\"${distrobox_path}\"/distrobox enter ${root_flag} \"${name}\" -- touch /dev/null\n\tfi\n\n\t# if there are exported bins and apps declared, let's export them\n\tif [ -n \"${exported_apps}\" ] || [ -n \"${exported_bins}\" ]; then\n\t\t# First we start the container\n\t\t# shellcheck disable=SC2086,2248\n\t\t\"${distrobox_path}\"/distrobox enter ${root_flag} \"${name}\" -- touch /dev/null\n\n\t\tIFS=\"\"\n\t\tfor apps in ${exported_apps}; do\n\t\t\t# Split the string by spaces\n\t\t\tIFS=\" \"\n\t\t\tfor app in ${apps}; do\n\t\t\t\t# Export the app\n\t\t\t\t# shellcheck disable=SC2086,2248\n\t\t\t\t\"${distrobox_path}\"/distrobox enter ${root_flag} \"${name}\" -- distrobox-export --app \"${app}\"\n\t\t\tdone\n\t\tdone\n\n\t\tIFS=\"\"\n\t\tfor bins in ${exported_bins}; do\n\t\t\t# Split the string by spaces\n\t\t\tIFS=\" \"\n\t\t\tfor bin in ${bins}; do\n\t\t\t\t# Export the bin\n\t\t\t\t# shellcheck disable=SC2086,2248\n\t\t\t\t\"${distrobox_path}\"/distrobox enter ${root_flag} \"${name}\" -- distrobox-export --bin \"${bin}\" --export-path \"${exported_bins_path}\"\n\t\t\tdone\n\t\tdone\n\tfi\n}\n\n# encode_variable will encode an input in base64, removing surrounding single/double quotes.\n# Arguments:\n#   variable: string\n# Expected global variables:\n#   None\n# Expected env variables:\n#   None\n# Outputs:\n#   a value string encoded in base64\nencode_variable()\n{\n\tvariable=\"${1}\"\n\t# remove surrounding quotes possibly added by the user\n\tif echo \"${variable}\" | grep -qE '^\"'; then\n\t\tvariable=\"$(echo \"${variable}\" | sed -e 's/^\"//' -e 's/\"$//')\"\n\telif echo \"${variable}\" | grep -qE \"^'\"; then\n\t\tvariable=\"$(echo \"${variable}\" | sed -e \"s/^'//\" -e \"s/'$//\")\"\n\tfi\n\n\techo \"${variable}\" | base64 -w 0\n}\n\n# sanitize_variable will sanitize an input, add single/double quotes and escapes\n# Arguments:\n#   variable: string\n# Expected global variables:\n#   None\n# Expected env variables:\n#   None\n# Outputs:\n#   a value string sanitized\nsanitize_variable()\n{\n\tvariable=\"${1}\"\n\n\t# If there are spaces but no quotes, let's add them\n\tif echo \"${variable}\" | grep -q \" \" &&\n\t\t! echo \"${variable}\" | grep -Eq \"^'|^\\\"\"; then\n\n\t\t# if we have double quotes we should wrap the whole line in single quotes\n\t\t# in order to not \"undo\" them\n\t\tif echo \"${variable}\" | grep -q '\"'; then\n\t\t\tvariable=\"'${variable}'\"\n\t\telse\n\t\t\tvariable=\"\\\"${variable}\\\"\"\n\t\tfi\n\tfi\n\n\t# Return\n\techo \"${variable}\"\n}\n\n# parse_file will read and parse input file and call distrobox-create accordingly\n# Arguments:\n#   file: string path of the manifest file to parse\n# Expected global variables:\n#   tmpfile: string name of the tmpfile to read\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nparse_file()\n{\n\tfile=\"${1}\"\n\tname=\"\"\n\n\tIFS='\n\t'\n\t# shellcheck disable=SC2013\n\tfor line in $(cat \"${file}\"); do\n\t\t# Remove comments and trailing spaces\n\t\tline=\"$(echo \"${line}\" |\n\t\t\tsed 's/\\t/ /g' |\n\t\t\tsed 's/^#.*//g' |\n\t\t\tsed 's/].*#.*//g' |\n\t\t\tsed 's/ #.*//g' |\n\t\t\tsed 's/\\s*$//g')\"\n\n\t\tif [ -z \"${line}\" ]; then\n\t\t\t# blank line, skip\n\t\t\tcontinue\n\t\tfi\n\n\t\t# Detect start of new section\n\t\tif [ \"$(echo \"${line}\" | cut -c 1)\" = '[' ]; then\n\t\t\t# We're starting a new section\n\t\t\tif [ -n \"${name}\" ]; then\n\t\t\t\t# We've finished the previous section, so this is the time to\n\t\t\t\t# perform the distrobox command, before going to the new section.\n\t\t\t\trun_distrobox \"${name}\"\n\t\t\tfi\n\n\t\t\t# Remove brackets and spaces\n\t\t\tname=\"$(echo \"${line}\" | tr -d '][ ')\"\n\t\t\tcontinue\n\t\tfi\n\n\t\t# Get key-values from the file\n\t\tkey=\"$(echo \"${line}\" | cut -d'=' -f1 | tr -d ' ')\"\n\t\tvalue=\"$(echo \"${line}\" | cut -d'=' -f2-)\"\n\n\t\t# Normalize true|false to 0|1\n\t\t[ \"${value}\" = \"true\" ] && value=1\n\t\t[ \"${value}\" = \"false\" ] && value=0\n\n\t\t# Sanitize value, by whitespaces, quotes and escapes\n\t\tif [ \"${key}\" = \"init_hooks\" ] || [ \"${key}\" = \"pre_init_hooks\" ]; then\n\t\t\t# in case of shell commands (so the hooks) we prefer to pass the variable\n\t\t\t# around encoded, so that we don't accidentally execute stuff\n\t\t\t# and, we will execute sanitize_variable on the final string flag at the\n\t\t\t# end, instead of key/value base.\n\t\t\tvalue=\"$(encode_variable \"${value}\")\"\n\t\telse\n\t\t\tvalue=\"$(sanitize_variable \"${value}\")\"\n\t\tfi\n\n\t\t# Save options to tempfile, to source it later\n\t\ttouch \"${tmpfile}\"\n\t\tif [ -n \"${key}\" ] && [ -n \"${value}\" ]; then\n\t\t\tif grep -q \"^${key}=\" \"${tmpfile}\"; then\n\t\t\t\t# make keys cumulative\n\t\t\t\tvalue=\"\\${${key}}${value}\"\n\t\t\tfi\n\t\t\techo \"${key}=${value}\" >> \"${tmpfile}\"\n\t\tfi\n\tdone\n\t# Execute now one last time for the last block\n\trun_distrobox \"${name}\"\n}\n\n# Exec\nparse_file \"${input_file}\"\n"
        },
        {
          "name": "distrobox-create",
          "type": "blob",
          "size": 36.8193359375,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Expected env variables:\n#\tHOME\n#\tUSER\n# Optional env variables:\n#\tDBX_CONTAINER_ALWAYS_PULL\n#\tDBX_CONTAINER_CUSTOM_HOME\n#\tDBX_CONTAINER_HOME_PREFIX\n#\tDBX_CONTAINER_IMAGE\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_CONTAINER_NAME\n#\tDBX_CONTAINER_HOSTNAME\n#\tDBX_CONTAINER_GENERATE_ENTRY\n#\tDBX_NON_INTERACTIVE\n#\tDBX_VERBOSE\n#\tDBX_SUDO_PROGRAM\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# Defaults\ncontainer_additional_packages=\"\"\ncontainer_additional_volumes=\"\"\ncontainer_always_pull=0\ncontainer_clone=\"\"\ncontainer_generate_entry=1\ncontainer_home_prefix=\"\"\ncontainer_image=\"\"\ncontainer_image_default=\"registry.fedoraproject.org/fedora-toolbox:latest\"\ncontainer_init_hook=\"\"\ncontainer_manager=\"autodetect\"\ncontainer_manager_additional_flags=\"\"\ncontainer_name=\"\"\ncontainer_name_default=\"my-distrobox\"\ncontainer_hostname=\"\"\ncontainer_pre_init_hook=\"\"\ncontainer_user_custom_home=\"\"\ncontainer_user_gid=\"$(id -rg)\"\ncontainer_user_home=\"${HOME:-\"/\"}\"\ncontainer_user_name=\"${USER}\"\ncontainer_user_uid=\"$(id -ru)\"\ndryrun=0\ninit=0\nnon_interactive=0\nnvidia=0\nnopasswd=0\nunshare_ipc=0\nunshare_groups=0\nunshare_netns=0\nunshare_process=0\nunshare_devsys=0\n\n# Use cd + dirname + pwd so that we do not have relative paths in mount points\n# We're not using \"realpath\" here so that symlinks are not resolved this way\n# \"realpath\" would break situations like Nix or similar symlink based package\n# management.\ndistrobox_entrypoint_path=\"$(cd \"$(dirname \"${0}\")\" && pwd)/distrobox-init\"\ndistrobox_export_path=\"$(cd \"$(dirname \"${0}\")\" && pwd)/distrobox-export\"\ndistrobox_genentry_path=\"$(cd \"$(dirname \"${0}\")\" && pwd)/distrobox-generate-entry\"\ndistrobox_hostexec_path=\"$(cd \"$(dirname \"${0}\")\" && pwd)/distrobox-host-exec\"\n# In case some of the scripts are not in the same path as create, let's search\n# in PATH for them.\n[ ! -e \"${distrobox_entrypoint_path}\" ] && distrobox_entrypoint_path=\"$(command -v distrobox-init)\"\n[ ! -e \"${distrobox_export_path}\" ] && distrobox_export_path=\"$(command -v distrobox-export)\"\n[ ! -e \"${distrobox_genentry_path}\" ] && distrobox_genentry_path=\"$(command -v distrobox-generate-entry)\"\n[ ! -e \"${distrobox_hostexec_path}\" ] && distrobox_hostexec_path=\"$(command -v distrobox-host-exec)\"\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"${container_user_uid}\" -eq 0 ] && rootful=1 || rootful=0\nverbose=0\nversion=\"1.8.0\"\n\napp_cache_dir=${XDG_CACHE_HOME:-\"${HOME}/.cache\"}/distrobox\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n# If we're running this script as root -- as in logged in in the shell as root\n# user, and not via SUDO/DOAS --, we don't need to set distrobox_sudo_program\n# as it's meaningless for this use case.\nif [ \"${container_user_uid}\" -ne 0 ]; then\n\t# If the DBX_SUDO_PROGRAM/distrobox_sudo_program variable was set by the\n\t# user, use its value instead of \"sudo\". But only if not running the script\n\t# as root (UID 0).\n\tdistrobox_sudo_program=${DBX_SUDO_PROGRAM:-${distrobox_sudo_program:-\"sudo\"}}\nfi\n\n[ -n \"${DBX_CONTAINER_ALWAYS_PULL}\" ] && container_always_pull=\"${DBX_CONTAINER_ALWAYS_PULL}\"\n[ -n \"${DBX_CONTAINER_CUSTOM_HOME}\" ] && container_user_custom_home=\"${DBX_CONTAINER_CUSTOM_HOME}\"\n[ -n \"${DBX_CONTAINER_HOME_PREFIX}\" ] && container_home_prefix=\"${DBX_CONTAINER_HOME_PREFIX}\"\n[ -n \"${DBX_CONTAINER_IMAGE}\" ] && container_image=\"${DBX_CONTAINER_IMAGE}\"\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n[ -n \"${DBX_CONTAINER_NAME}\" ] && container_name=\"${DBX_CONTAINER_NAME}\"\n[ -n \"${DBX_CONTAINER_HOSTNAME}\" ] && container_hostname=\"${DBX_CONTAINER_HOSTNAME}\"\n[ -n \"${DBX_CONTAINER_GENERATE_ENTRY}\" ] && container_generate_entry=\"${DBX_CONTAINER_GENERATE_ENTRY}\"\n[ -n \"${DBX_NON_INTERACTIVE}\" ] && non_interactive=\"${DBX_NON_INTERACTIVE}\"\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${non_interactive}\" = \"true\" ] && non_interactive=1\n[ \"${non_interactive}\" = \"false\" ] && non_interactive=0\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: string distrobox version\n#   container_image_default: string default container image to use\n#   container_name_default:  string default container name to use\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox create --image alpine:latest --name test --init-hooks \"touch /var/tmp/test1 && touch /var/tmp/test2\"\n\tdistrobox create --image fedora:39 --name test --additional-flags \"--env MY_VAR-value\"\n\tdistrobox create --image fedora:39 --name test --volume /opt/my-dir:/usr/local/my-dir:rw --additional-flags \"--pids-limit 100\"\n\tdistrobox create -i docker.io/almalinux/8-init --init --name test --pre-init-hooks \"dnf config-manager --enable powertools && dnf -y install epel-release\"\n\tdistrobox create --clone fedora-39 --name fedora-39-copy\n\tdistrobox create --image alpine my-alpine-container\n\tdistrobox create --image registry.fedoraproject.org/fedora-toolbox:latest --name fedora-toolbox-latest\n\tdistrobox create --pull --image centos:stream9 --home ~/distrobox/centos9\n\tdistrobox create --image alpine:latest --name test2 --additional-packages \"git tmux vim\"\n\tdistrobox create --image ubuntu:22.04 --name ubuntu-nvidia --nvidia\n\n\tDBX_NON_INTERACTIVE=1 DBX_CONTAINER_NAME=test-alpine DBX_CONTAINER_IMAGE=alpine distrobox-create\n\nOptions:\n\n\t--image/-i:\t\timage to use for the container\tdefault: ${container_image_default}\n\t--name/-n:\t\tname for the distrobox          default: ${container_name_default}\n\t--hostname:\t\thostname for the distrobox      default: $(uname -n)\n\t--pull/-p:\t\tpull the image even if it exists locally (implies --yes)\n\t--yes/-Y:\t\tnon-interactive, pull images without asking\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--clone/-c:\t\tname of the distrobox container to use as base for a new container\n\t\t\t\tthis will be useful to either rename an existing distrobox or have multiple copies\n\t\t\t\tof the same environment.\n\t--home/-H:\t\tselect a custom HOME directory for the container. Useful to avoid host's home littering with temp files.\n\t--volume:\t\tadditional volumes to add to the container\n\t--additional-flags/-a:\tadditional flags to pass to the container manager command\n\t--additional-packages/-ap:\tadditional packages to install during initial container setup\n\t--init-hooks:\t\tadditional commands to execute at the end of container initialization\n\t--pre-init-hooks:\tadditional commands to execute at the start of container initialization\n\t--init/-I:\t\tuse init system (like systemd) inside the container.\n\t\t\t\tthis will make host's processes not visible from within the container. (assumes --unshare-process)\n\t\t\t\tmay require additional packages depending on the container image: https://github.com/89luca89/distrobox/blob/main/docs/useful_tips.md#using-init-system-inside-a-distrobox\n\t--nvidia:\t\ttry to integrate host's nVidia drivers in the guest\n\t--unshare-devsys:          do not share host devices and sysfs dirs from host\n\t--unshare-groups:          do not forward user's additional groups into the container\n\t--unshare-ipc:          do not share ipc namespace with host\n\t--unshare-netns:        do not share the net namespace with host\n\t--unshare-process:          do not share process namespace with host\n\t--unshare-all:          activate all the unshare flags below\n\t--compatibility/-C:\tshow list of compatible images\n\t--help/-h:\t\tshow this message\n\t--no-entry:\t\tdo not generate a container entry in the application list\n\t--dry-run/-d:\t\tonly print the container manager command generated\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\n\n\t--absolutely-disable-root-password-i-am-really-positively-sure:    when setting up a rootful distrobox, this will skip user password setup, leaving it blank.  \n\nCompatibility:\n\n\tfor a list of compatible images and container managers, please consult the man page:\n\t\tman distrobox-compatibility\n\tor run\n\t\tdistrobox create --compatibility\n\tor consult the documentation page on: https://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\nEOF\n}\n\n# show_compatibility will print the list of compatible images to stdout, caching locally in a file.\n# Arguments:\n#   None\n# Expected global variables:\n#   app_cache_dir: cache dir to write to\n#   version:       distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_compatibility()\n{\n\tif [ ! -e \"${app_cache_dir}/distrobox-compatibility-${version}\" ] ||\n\t\t[ ! -s \"${app_cache_dir}/distrobox-compatibility-${version}\" ]; then\n\t\tmkdir -p \"${app_cache_dir}\"\n\n\t\t# If we don't have a cache file, we need connectivity. Ensure we have\n\t\t# one and return error if not.\n\t\tif ! curl -s \"https://github.com\" > /dev/null; then\n\t\t\tprintf >&2 \"ERROR: no cache file and no connectivity found, cannot retrieve compatibility list.\\n\"\n\t\t\texit 1\n\t\tfi\n\t\t# We want to download the correspondent version of the compatibility table and extract a list from it.\n\t\t# Always use the docs as source of truth for this.\n\t\tcurl -s \\\n\t\t\t\"https://raw.githubusercontent.com/89luca89/distrobox/${version}/docs/compatibility.md\" |\n\t\t\tsed -n -e '/| Alma/,/| Void/ p' |\n\t\t\tcut -d '|' -f 4 |\n\t\t\tsed 's|<br>|\\n|g' |\n\t\t\ttr -d ' ' |\n\t\t\tsort -u > \"${app_cache_dir}/distrobox-compatibility-${version}\"\n\tfi\n\tcat \"${app_cache_dir}/distrobox-compatibility-${version}\"\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t--no-entry)\n\t\t\tshift\n\t\t\tcontainer_generate_entry=0\n\t\t\t;;\n\t\t-d | --dry-run)\n\t\t\tshift\n\t\t\tdryrun=1\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t--absolutely-disable-root-password-i-am-really-positively-sure)\n\t\t\tshift\n\t\t\tnopasswd=1\n\t\t\t;;\n\t\t-I | --init)\n\t\t\tshift\n\t\t\tinit=1\n\t\t\tunshare_groups=1\n\t\t\tunshare_process=1\n\t\t\t;;\n\t\t--unshare-ipc)\n\t\t\tshift\n\t\t\tunshare_ipc=1\n\t\t\t;;\n\t\t--unshare-groups)\n\t\t\tshift\n\t\t\tunshare_groups=1\n\t\t\t;;\n\t\t--unshare-netns)\n\t\t\tshift\n\t\t\tunshare_netns=1\n\t\t\t;;\n\t\t--unshare-process)\n\t\t\tshift\n\t\t\tunshare_process=1\n\t\t\t;;\n\t\t--unshare-devsys)\n\t\t\tshift\n\t\t\tunshare_devsys=1\n\t\t\t;;\n\t\t--unshare-all)\n\t\t\tshift\n\t\t\tunshare_devsys=1\n\t\t\tunshare_groups=1\n\t\t\tunshare_ipc=1\n\t\t\tunshare_netns=1\n\t\t\tunshare_process=1\n\t\t\t;;\n\t\t-C | --compatibility)\n\t\t\tshow_compatibility\n\t\t\texit 0\n\t\t\t;;\n\t\t-i | --image)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_image=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-n | --name)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--hostname)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_hostname=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-c | --clone)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_clone=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-H | --home)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\t# Remove trailing slashes\n\t\t\t\tcontainer_user_custom_home=\"$(echo \"$2\" | sed 's:/*$::')\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-p | --pull)\n\t\t\tcontainer_always_pull=1\n\t\t\tshift\n\t\t\t;;\n\t\t--nvidia)\n\t\t\tshift\n\t\t\tnvidia=1\n\t\t\t;;\n\t\t-Y | --yes)\n\t\t\tnon_interactive=1\n\t\t\tshift\n\t\t\t;;\n\t\t--volume)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_additional_volumes=\"${container_additional_volumes} ${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-a | --additional-flags)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_manager_additional_flags=\"${container_manager_additional_flags} ${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-ap | --additional-packages)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_additional_packages=\"${container_additional_packages} ${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--init-hooks)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_init_hook=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--pre-init-hooks)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_pre_init_hook=\"${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcontainer_name=\"$1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# If no clone option and no container image, let's choose a default image to use.\n# Fedora toolbox is a sensitive default\nif [ -z \"${container_clone}\" ] && [ -z \"${container_image}\" ]; then\n\tcontainer_image=\"${container_image_default}\"\nfi\n\n# If no name is specified and we're using the default container_image, then let's\n# set a default name for the container, that is distinguishable from the default\n# toolbx one. This will avoid problems when using both toolbx and distrobox on\n# the same system.\nif [ -z \"${container_name}\" ] && [ \"${container_image}\" = \"${container_image_default}\" ]; then\n\tcontainer_name=\"${container_name_default}\"\nfi\n\n# If no container_name is declared, we build our container name starting from the\n# container image specified.\n#\n# Examples:\n#\talpine -> alpine\n#\tubuntu:20.04 -> ubuntu-20.04\n#\tregistry.fedoraproject.org/fedora-toolbox:39 -> fedora-toolbox-39\n#\tghcr.io/void-linux/void-linux:latest-full-x86_64 -> void-linux-latest-full-x86_64\nif [ -z \"${container_name}\" ]; then\n\tcontainer_name=\"$(basename \"${container_image}\" | sed -E 's/[:.]/-/g')\"\nfi\n\n# set the container hostname to default value\nif [ -z \"${container_hostname}\" ]; then\n\tcontainer_hostname=\"$(uname -n)\"\n\n\tif [ \"${unshare_netns}\" -eq 1 ]; then\n\t\tcontainer_hostname=\"${container_name}.${container_hostname}\"\n\tfi\nfi\n\n# check if container hostname is less than 64 chars to prevent issues\nif [ \"$(printf \"%s\" \"${container_hostname}\" | wc -m)\" -gt 64 ]; then\n\tprintf >&2 \"ERROR: Invalid hostname '%s', longer than 64 characters\\n\" \"${container_hostname}\"\n\tprintf >&2 \"ERROR: Use use --hostname argument to set it manually\\n\"\n\texit 1\nfi\n\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null && [ \"${dryrun}\" -eq 0 ]; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman,  docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n# add  verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\tcontainer_manager=\"${distrobox_sudo_program-} ${container_manager}\"\nfi\n\n# if nopasswd, then let the init know via a mountpoint\nif [ \"${nopasswd}\" -ne 0 ]; then\n\tcontainer_manager_additional_flags=\"${container_manager_additional_flags}\n\t\t\t--volume /dev/null:/run/.nopasswd:ro\"\nfi\n\n# inject additional volumes if specified\nif [ -n \"${container_additional_volumes}\" ]; then\n\tfor volume in ${container_additional_volumes}; do\n\t\tcontainer_manager_additional_flags=\"${container_manager_additional_flags}\n\t\t\t--volume ${volume}\"\n\tdone\nfi\n\n# Check that we have a complete distrobox installation or\n# entrypoint and export will not work.\nif [ -z \"${distrobox_entrypoint_path}\" ] || [ -z \"${distrobox_export_path}\" ]; then\n\tprintf >&2 \"Error: no distrobox-init found in %s\\n\" \"${PATH}\"\n\texit 127\nfi\n\n# get_clone_image will return the image name of a cloned existing container taken\n# as input.\n# Arguments:\n#   None\n# Expected global variables:\n#   container_manager: string container manager to use\n#   container_clone: string container name to clone\n# Expected env variables:\n#   None\n# Outputs:\n#   prints the image name of the newly cloned container\nget_clone_image()\n{\n\t# We need to clone a container.\n\t# to do this we will commit the container and create a new tag. Then use it\n\t# as image for the new container.\n\t#\n\t# to perform this we first ensure the source container exists and that the\n\t# source container is stopped, else the clone will not work,\n\tcontainer_source_status=\"$(${container_manager} inspect --type container \\\n\t\t--format '{{.State.Status}}' \"${container_clone}\")\"\n\t# If the container is not already running, we need to start if first\n\tif [ \"${container_source_status}\" = \"running\" ]; then\n\t\tprintf >&2 \"Container %s is running.\\nPlease stop it first.\\n\" \"${container_clone}\"\n\t\tprintf >&2 \"Cannot clone a running container.\\n\"\n\t\treturn 1\n\tfi\n\n\t# Now we can extract the container ID and commit it to use as source image\n\t# for the new container.\n\tcontainer_source_id=\"$(${container_manager} inspect --type container \\\n\t\t--format '{{.ID}}' \"${container_clone}\")\"\n\tcontainer_commit_tag=\"$(echo \"${container_clone}:$(date +%F)\" | tr '[:upper:]' '[:lower:]')\"\n\n\t# Commit current container state to a new image tag\n\tprintf >&2 \"Duplicating %s...\\n\" \"${container_clone}\"\n\tif ! ${container_manager} container commit \\\n\t\t\"${container_source_id}\" \"${container_commit_tag}\" > /dev/null; then\n\n\t\tprintf >&2 \"Cannot clone container: %s\\n\" \"${container_clone}\"\n\t\treturn 1\n\tfi\n\n\t# Return the image tag to use for the new container creation.\n\tprintf \"%s\" \"${container_commit_tag}\"\n\treturn 0\n}\n\n# generate_create_command will produce a Podman or Docker command to execute.\n# Arguments:\n#   None\n# Expected global variables:\n#   container_manager: string container manager to use\n#   container_name: string container name\n#   container_image: string container image\n#   container_manager_additional_flags: string container manager additional flags to use\n#   container_hostname: string container hostname\n#   container_additional_packages: string additional packages\n#   container_pre_init_hook: string pre init hooks\n#   container_init_hook: string init hooks\n#   container_user_home: string user's home path\n#   container_user_name: string user's username\n#   container_user_uid: string user's UID\n#   container_user_gid: string user's GID\n#   container_home_prefix: string container's custom home prefix\n#   container_user_custom_home: string container's custom home path\n#   init: bool initful\n#   nvidia: bool nvidia integration\n#   rootful: bool rootful\n#   unshare_devsys: bool unshare devsys\n#   unshare_groups: bool unshare groups\n#   unshare_ipc: bool unshare ipc\n#   unshare_netns: bool unshare netns\n#   unshare_process: bool unshare proc\n# Expected env variables:\n#   None\n# Outputs:\n#   prints the podman, docker or lilipod command to create the distrobox container\ngenerate_create_command()\n{\n\t# Set the container hostname the same as the container name.\n\tresult_command=\"${container_manager} create\"\n\t# use the host's namespace for ipc, network, pid, ulimit\n\tresult_command=\"${result_command}\n\t\t--hostname \\\"${container_hostname}\\\"\n\t\t--name \\\"${container_name}\\\"\n\t\t--privileged\n\t\t--security-opt label=disable\n\t\t--security-opt apparmor=unconfined\n\t\t--pids-limit=-1\n\t\t--user root:root\"\n\n\tif [ \"${unshare_ipc}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--ipc host\"\n\tfi\n\n\tif [ \"${unshare_netns}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--network host\"\n\tfi\n\n\tif [ \"${unshare_process}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--pid host\"\n\tfi\n\t# Mount useful stuff inside the container.\n\t# We also mount host's root filesystem to /run/host, to be able to syphon\n\t# dynamic configurations from the host.\n\t#\n\t# Mount user home, dev and host's root inside container.\n\t# This grants access to external devices like usb webcams, disks and so on.\n\t#\n\t# Mount also the distrobox-init utility as the container entrypoint.\n\t# Also mount in the container the distrobox-export and distrobox-host-exec\n\t# utilities.\n\tresult_command=\"${result_command}\n\t\t--label \\\"manager=distrobox\\\"\n\t\t--label \\\"distrobox.unshare_groups=${unshare_groups}\\\"\n\t\t--env \\\"SHELL=$(basename \"${SHELL:-\"/bin/bash\"}\")\\\"\n\t\t--env \\\"HOME=${container_user_home}\\\"\n\t\t--env \\\"container=${container_manager}\\\"\n\t\t--env \\\"TERMINFO_DIRS=/usr/share/terminfo:/run/host/usr/share/terminfo\\\"\n\t\t--env \\\"CONTAINER_ID=${container_name}\\\"\n\t\t--volume /tmp:/tmp:rslave\n\t\t--volume \\\"${distrobox_entrypoint_path}\\\":/usr/bin/entrypoint:ro\n\t\t--volume \\\"${distrobox_export_path}\\\":/usr/bin/distrobox-export:ro\n\t\t--volume \\\"${distrobox_hostexec_path}\\\":/usr/bin/distrobox-host-exec:ro\n\t\t--volume \\\"${container_user_home}\\\":\\\"${container_user_home}\\\":rslave\"\n\n\t# Due to breaking change in https://github.com/opencontainers/runc/commit/d4b670fca6d0ac606777376440ffe49686ce15f4\n\t# now we cannot mount /:/run/host as before, as it will try to mount RO partitions as RW thus breaking things.\n\t# This will ensure we will mount directories one-by-one thus avoiding this problem.\n\t#\n\t# This happens ONLY with podman+runc, docker and lilipod are unaffected, so let's do this only if we have podman AND runc.\n\tif echo \"${container_manager}\" | grep -q \"podman\" && ${container_manager} info | grep -q runc; then\n\t\tfor rootdir in /*; do\n\n\t\t\t# Skip symlinks\n\t\t\tif [ -L \"${rootdir}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\t# Find if the directory belongs to a RO mount, if do, mount it as RO+Rslave\n\t\t\tif findmnt --notruncate --noheadings --list --output OPTIONS --target \"${rootdir}\" |\n\t\t\t\ttr ',' '\\n' | grep -q \"^ro$\"; then\n\n\t\t\t\tresult_command=\"${result_command}\n\t\t\t\t--volume ${rootdir}:/run/host${rootdir}:ro,rslave\"\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\t# Else we mount it RW+Rslave\n\t\t\tresult_command=\"${result_command}\n\t\t\t\t--volume ${rootdir}:/run/host${rootdir}:rslave\"\n\t\tdone\n\telse\n\t\t# We're either on podman+crun, docker or lilipod, let's keep old behaviour\n\t\tresult_command=\"${result_command}\n\t\t\t--volume /:/run/host/:rslave\"\n\n\tfi\n\n\tif [ \"${unshare_devsys}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--volume /dev:/dev:rslave\n\t\t\t--volume /sys:/sys:rslave\"\n\tfi\n\n\t# In case of initful containers, we implement a series of mountpoint in order\n\t# for systemd to work properly inside a container.\n\t# The following are a flag-based implementation of what podman's --systemd flag\n\t# does under the hood, as explained in their docs here:\n\t#   https://docs.podman.io/en/latest/markdown/options/systemd.html\n\t#\n\t# set the default stop signal to SIGRTMIN+3.\n\t# mount tmpfs file systems on the following directories\n\t#\t/run\n\t#\t/run/lock\n\t#\t/tmp\n\t#\t/var/lib/journal\n\t#\t/sys/fs/cgroup/systemd <- this one is done by cgroupns=host\n\tif [ \"${init}\" -eq 1 ] && echo \"${container_manager}\" | grep -q \"docker\"; then\n\t\t# In case of docker we're actually rootful, so we need to use hosts cgroups\n\t\tresult_command=\"${result_command}\n\t\t\t--cgroupns host\"\n\tfi\n\tif [ \"${init}\" -eq 1 ] && echo \"${container_manager}\" | grep -vq \"podman\"; then\n\t\t# In case of all other non-podman container managers, we can do this\n\t\tresult_command=\"${result_command}\n\t\t\t--stop-signal SIGRTMIN+3\n\t\t\t--mount type=tmpfs,destination=/run\n\t\t\t--mount type=tmpfs,destination=/run/lock\n\t\t\t--mount type=tmpfs,destination=/var/lib/journal\"\n\tfi\n\n\t# This fix is needed so that the container can have a separate devpts instance\n\t# inside\n\t# This will mount an empty /dev/pts, and the init will take care of mounting\n\t# a new devpts with the proper flags set\n\t# Mounting an empty volume there, is needed in order to ensure that no package\n\t# manager tries to fiddle with /dev/pts/X that would not be writable by them\n\t#\n\t# This implementation is done this way in order to be compatible with both\n\t# docker and podman\n\tif [ \"${unshare_devsys}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--volume /dev/pts\n\t\t\t--volume /dev/null:/dev/ptmx\"\n\tfi\n\n\t# This fix is needed as on Selinux systems, the host's selinux sysfs directory\n\t# will be mounted inside the rootless container.\n\t#\n\t# This works around this and allows the rootless container to work when selinux\n\t# policies are installed inside it.\n\t#\n\t# Ref. Podman issue 4452:\n\t#    https://github.com/containers/podman/issues/4452\n\tif [ -e \"/sys/fs/selinux\" ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--volume /sys/fs/selinux\"\n\tfi\n\n\t# This fix is needed as systemd (or journald) will try to set ACLs on this\n\t# path. For now overlayfs and fuse.overlayfs are not compatible with ACLs\n\t#\n\t# This works around this using an unnamed volume so that this path will be\n\t# mounted with a normal non-overlay FS, allowing ACLs and preventing errors.\n\t#\n\t# This work around works in conjunction with distrobox-init's package manager\n\t# setups.\n\t# So that we can use pre/post hooks for package managers to present to the\n\t# systemd install script a blank path to work with, and mount the host's\n\t# journal path afterwards.\n\tresult_command=\"${result_command}\n\t\t\t--volume /var/log/journal\"\n\n\t# In some systems, for example using sysvinit, /dev/shm is a symlink\n\t# to /run/shm, instead of the other way around.\n\t# Resolve this detecting if /dev/shm is a symlink and mount original\n\t# source also in the container.\n\tif [ -L \"/dev/shm\" ] && [ \"${unshare_ipc}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--volume $(realpath /dev/shm):$(realpath /dev/shm)\"\n\tfi\n\n\t# Ensure that both all container managers (not only podman) support forwarding of RedHat subscription-manager\n\t# This is needed in order to have a working subscription forwarded into the container,\n\t# this will ensure that rhel-9-for-x86_64-appstream-rpms and rhel-9-for-x86_64-baseos-rpms repos\n\t# will be available in the container, so that distrobox-init will be able to\n\t# install properly all the dependencies like mesa drivers.\n\t#\n\t# /run/secrets is a standard location for RHEL containers, that is being pointed by\n\t# /etc/rhsm-host by default.\n\tRHEL_SUBSCRIPTION_FILES=\"\n\t\t/etc/pki/entitlement/:/run/secrets/etc-pki-entitlement:ro\n\t\t/etc/rhsm/:/run/secrets/rhsm:ro\n\t\t/etc/yum.repos.d/redhat.repo:/run/secrets/redhat.repo:ro\n\t\"\n\tfor rhel_file in ${RHEL_SUBSCRIPTION_FILES}; do\n\t\tif [ -e \"$(echo \"${rhel_file}\" | cut -d':' -f1)\" ]; then\n\t\t\tresult_command=\"${result_command}\n\t\t\t\t--volume ${rhel_file}\"\n\t\tfi\n\tdone\n\n\t# If we have a home prefix to use, ano no custom home set, then we set\n\t# the custom home to be PREFIX/CONTAINER_NAME\n\tif [ -n \"${container_home_prefix}\" ] && [ -z \"${container_user_custom_home}\" ]; then\n\t\tcontainer_user_custom_home=\"${container_home_prefix}/${container_name}\"\n\tfi\n\n\t# If we have a custom home to use,\n\t#\t1- override the HOME env variable\n\t#\t2- export the DISTROBOX_HOST_HOME env variable pointing to original HOME\n\t# \t3- mount the custom home inside the container.\n\tif [ -n \"${container_user_custom_home}\" ]; then\n\t\tif [ ! -d \"${container_user_custom_home}\" ]; then\n\t\t\tif ! mkdir -p \"${container_user_custom_home}\"; then\n\t\t\t\tprintf >&2 \"Do you have permission to write to %s?\\n\" \"${container_user_custom_home}\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\tfi\n\t\tresult_command=\"${result_command}\n\t\t\t--env \\\"HOME=${container_user_custom_home}\\\"\n\t\t\t--env \\\"DISTROBOX_HOST_HOME=${container_user_home}\\\"\n\t\t\t--volume \\\"${container_user_custom_home}:${container_user_custom_home}:rslave\\\"\"\n\tfi\n\n\t# Mount also the /var/home dir on ostree based systems\n\t# do this only if $HOME was not already set to /var/home/username\n\tif [ \"${container_user_home}\" != \"/var/home/${container_user_name}\" ] &&\n\t\t[ -d \"/var/home/${container_user_name}\" ]; then\n\n\t\tresult_command=\"${result_command}\n\t\t\t--volume \\\"/var/home/${container_user_name}\\\":\\\"/var/home/${container_user_name}\\\":rslave\"\n\tfi\n\n\t# Mount also the XDG_RUNTIME_DIR to ensure functionality of the apps.\n\t# This is skipped in case of initful containers, so that a dedicated\n\t# systemd user session can be used.\n\tif [ -d \"/run/user/${container_user_uid}\" ] && [ \"${init}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--volume /run/user/${container_user_uid}:/run/user/${container_user_uid}:rslave\"\n\tfi\n\n\t# These are dynamic configs needed by the container to function properly\n\t# and integrate with the host\n\t#\n\t# We're doing this now instead of inside the init because some distros will\n\t# have symlinks places for these files that use absolute paths instead of\n\t# relative paths.\n\t# This is the bare minimum to ensure connectivity inside the container.\n\t# These files, will then be kept updated by the main loop every 15 seconds.\n\tif [ \"${unshare_netns}\" -eq 0 ]; then\n\t\tNET_FILES=\"\n\t\t\t/etc/hosts\n\t\t\t/etc/resolv.conf\n\t\t\"\n\n\t\t# If container_hostname is custom, we skip mounting /etc/hostname, else\n\t\t# we want to keep it in sync\n\t\tif [ \"${container_hostname}\" = \"$(uname -n)\" ]; then\n\t\t\tNET_FILES=\"${NET_FILES} /etc/hostname\"\n\t\tfi\n\n\t\tfor net_file in ${NET_FILES}; do\n\t\t\tif [ -e \"${net_file}\" ]; then\n\t\t\t\tresult_command=\"${result_command}\n\t\t\t\t\t--volume ${net_file}:${net_file}:ro\"\n\t\t\tfi\n\t\tdone\n\tfi\n\n\t# These flags are not supported by docker, so we use them only if our\n\t# container manager is podman.\n\tif echo \"${container_manager}\" | grep -q \"podman\"; then\n\t\tresult_command=\"${result_command}\n\t\t\t--annotation run.oci.keep_original_groups=1\n\t\t\t--ulimit host\"\n\n\t\tif [ \"${init}\" -eq 1 ]; then\n\t\t\tresult_command=\"${result_command}\n\t\t\t\t--systemd=always\"\n\t\tfi\n\n\t\t# Use keep-id only if going rootless.\n\t\tif [ \"${rootful}\" -eq 0 ]; then\n\t\t\tresult_command=\"${result_command}\n\t\t\t\t--userns keep-id\"\n\t\tfi\n\tfi\n\n\t# Add additional flags\n\tresult_command=\"${result_command}\n\t\t${container_manager_additional_flags}\"\n\n\t# Now execute the entrypoint, refer to `distrobox-init -h` for instructions\n\t#\n\t# Be aware that entrypoint corresponds to distrobox-init, the copying of it\n\t# inside the container is moved to distrobox-enter, in the start phase.\n\t# This is done to make init, export and host-exec location independent from\n\t# the host, and easier to upgrade.\n\t#\n\t# We set the entrypoint _before_ running the container image so that\n\t# we can override any user provided entrypoint if need be\n\tresult_command=\"${result_command}\n\t--entrypoint /usr/bin/entrypoint\n\t${container_image}\n\t\t--verbose\n\t\t--name \\\"${container_user_name}\\\"\n\t\t--user ${container_user_uid}\n\t\t--group ${container_user_gid}\n\t\t--home \\\"${container_user_custom_home:-\"${container_user_home}\"}\\\"\n\t\t--init \\\"${init}\\\"\n\t\t--nvidia \\\"${nvidia}\\\"\n\t\t--pre-init-hooks \\\"${container_pre_init_hook}\\\"\n\t\t--additional-packages \\\"${container_additional_packages}\\\"\n\t\t-- '${container_init_hook}'\n\t\"\n\t# use container_user_custom_home if defined, else fallback to normal home.\n\n\t# Return generated command.\n\tprintf \"%s\" \"${result_command}\"\n}\n\n# dry run mode, just generate the command and print it. No creation.\nif [ \"${dryrun}\" -ne 0 ]; then\n\tif [ -n \"${container_clone}\" ]; then\n\t\tcontainer_image=\"${container_clone}\"\n\tfi\n\tcmd=\"$(generate_create_command)\"\n\tcmd=\"$(echo \"${cmd}\" | sed 's/\\t//g')\"\n\tprintf \"%s\\n\" \"${cmd}\"\n\texit 0\nfi\n\n# Check if the container already exists.\n# If it does, notify the user and exit.\nif ${container_manager} inspect --type container \"${container_name}\" > /dev/null 2>&1; then\n\tprintf \"Distrobox named '%s' already exists.\\n\" \"${container_name}\"\n\tprintf \"To enter, run:\\n\\n\"\n\t# If it's a rootful container AND user is not logged as root.\n\tif [ \"${rootful}\" -eq 1 ] && [ \"${container_user_uid}\" -ne 0 ]; then\n\t\tprintf \"distrobox enter --root %s\\n\\n\" \"${container_name}\"\n\t# If user is logged as root OR it's a rootless container.\n\telif [ \"${container_user_uid}\" -eq 0 ] || [ \"${rootful}\" -eq 0 ]; then\n\t\tprintf \"distrobox enter %s\\n\\n\" \"${container_name}\"\n\tfi\n\texit 0\nfi\n\n# if we are using the clone flag, let's set the image variable\n# to the output of container duplication\nif [ -n \"${container_clone}\" ]; then\n\tif ! echo \"${container_manager}\" | grep -Eq \"podman|docker\"; then\n\t\tprintf >&2 \"ERROR: clone is only supported with docker and podman\\n\"\n\t\texit 127\n\tfi\n\tcontainer_image=\"$(get_clone_image)\"\nfi\n\n# First, check if the image exists in the host or auto-pull is enabled\n# If not prompt to download it.\nif [ \"${container_always_pull}\" -eq 1 ] ||\n\t! ${container_manager} inspect --type image \"${container_image}\" > /dev/null 2>&1; then\n\n\t# If we do auto-pull, don't ask questions\n\tif [ \"${non_interactive}\" -eq 1 ] || [ \"${container_always_pull}\" -eq 1 ]; then\n\t\tresponse=\"yes\"\n\telse\n\t\t# Prompt to download it.\n\t\tprintf >&2 \"Image %s not found.\\n\" \"${container_image}\"\n\t\tprintf >&2 \"Do you want to pull the image now? [Y/n]: \"\n\t\tread -r response\n\t\tresponse=\"${response:-\"Y\"}\"\n\tfi\n\n\t# Accept only y,Y,Yes,yes,n,N,No,no.\n\tcase \"${response}\" in\n\t\ty | Y | Yes | yes | YES)\n\t\t\t# Pull the image\n\t\t\t${container_manager} pull \"${container_image}\"\n\t\t\t;;\n\t\tn | N | No | no | NO)\n\t\t\tprintf >&2 \"next time, run this command first:\\n\"\n\t\t\tprintf >&2 \"\\t%s pull %s\\n\" \"${container_manager}\" \"${container_image}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tprintf >&2 \"Invalid input.\\n\"\n\t\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\nfi\n\n# Generate the create command and run it\nprintf >&2 \"Creating '%s' using image %s\\t\" \"${container_name}\" \"${container_image}\"\ncmd=\"$(generate_create_command)\"\n# Eval the generated command. If successful display an helpful message.\n# shellcheck disable=SC2086\nif eval ${cmd} > /dev/null; then\n\tprintf >&2 \"\\033[32m [ OK ]\\n\\033[0mDistrobox '%s' successfully created.\\n\" \"${container_name}\"\n\tprintf >&2 \"To enter, run:\\n\\n\"\n\t# If it's a rootful container AND user is not logged as root.\n\tif [ \"${rootful}\" -eq 1 ] && [ \"${container_user_uid}\" -ne 0 ]; then\n\t\tprintf \"distrobox enter --root %s\\n\\n\" \"${container_name}\"\n\t# If user is logged as root OR it's a rootless container.\n\telif [ \"${container_user_uid}\" -eq 0 ] || [ \"${rootful}\" -eq 0 ]; then\n\t\tprintf \"distrobox enter %s\\n\\n\" \"${container_name}\"\n\tfi\n\n\t# We've created the box, let's also create the entry\n\tif [ \"${rootful}\" -eq 0 ]; then\n\t\tif [ \"${container_generate_entry}\" -ne 0 ]; then\n\t\t\t\"${distrobox_genentry_path}\" \"${container_name}\"\n\t\tfi\n\tfi\nelse\n\terror=\"$?\"\n\tprintf >&2 \"\\033[31m [ ERR ]\\033[0m failed to create container.\\n\"\n\texit \"${error}\"\nfi\n"
        },
        {
          "name": "distrobox-enter",
          "type": "blob",
          "size": 23.9736328125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Expected env variables:\n#\tHOME\n#\tUSER\n# Optional env variables:\n#\tDBX_CONTAINER_ALWAYS_PULL\n#\tDBX_CONTAINER_CUSTOM_HOME\n#\tDBX_CONTAINER_GENERATE_ENTRY\n#\tDBX_CONTAINER_HOME_PREFIX\n#\tDBX_CONTAINER_HOSTNAME\n#\tDBX_CONTAINER_IMAGE\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_CONTAINER_NAME\n#\tDBX_CONTAINER_CLEAN_PATH\n#\tDBX_NON_INTERACTIVE\n#\tDBX_VERBOSE\n#\tDBX_SKIP_WORKDIR\n#\tDBX_SUDO_PROGRAM\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\napp_cache_dir=${XDG_CACHE_HOME:-\"${HOME}/.cache\"}/distrobox\n\ntrap cleanup TERM INT HUP EXIT\n\n# cleanup will remove fifo and temp files, and print to stdout\n# container's logs in case of error and verbose.\n# Arguments:\n#   None\n# Expected global variables:\n#   container_manager: string container manager to use\n#   container_name: string container name\n#   app_cache_dir: string cache dire to write file into\n#   logs_pid: string pid of the podman/docker logs process\n#   verbose: bool verbose\n# Expected env variables:\n#   None\n# Outputs:\n#   None\ncleanup()\n{\n\trm -f \"${app_cache_dir}/.${container_name}.fifo\"\n\tif [ -n \"${logs_pid:-}\" ]; then\n\t\tkill \"${logs_pid:-}\" 2> /dev/null || :\n\tfi\n\tif [ \"${verbose}\" -eq 1 ]; then\n\t\t${container_manager} logs \"${container_name}\"\n\tfi\n}\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Defaults\n# by default we use getent to get the login shell of the user and use that\ncontainer_custom_command=0\ncontainer_command_user=\"$(echo \"${USER}\" | sed 's|\\\\|\\\\\\\\|g')\"\ncontainer_image_default=\"registry.fedoraproject.org/fedora-toolbox:latest\"\ncontainer_manager=\"autodetect\"\ncontainer_manager_additional_flags=\"\"\ncontainer_name=\"\"\ncontainer_name_default=\"my-distrobox\"\nnon_interactive=0\n\n# Use cd + dirname + pwd so that we do not have relative paths in mount points\n# We're not using \"realpath\" here so that symlinks are not resolved this way\n# \"realpath\" would break situations like Nix or similar symlink based package\n# management.\ndistrobox_enter_path=\"$(cd \"$(dirname \"$0\")\" && pwd)/distrobox-enter\"\ndryrun=0\nheadless=0\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"$(id -ru)\" -eq 0 ] && rootful=1 || rootful=0\nskip_workdir=0\nverbose=0\nclean_path=0\nversion=\"1.8.0.1\"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n# If we're running this script as root -- as in, logged in in the shell as root\n# user, and not via SUDO/DOAS --, we don't need to set distrobox_sudo_program\n# as it's meaningless for this use case.\nif [ \"$(id -ru)\" -ne 0 ]; then\n\t# If the DBX_SUDO_PROGRAM/distrobox_sudo_program variable was set by the\n\t# user, use its value instead of \"sudo\". But only if not running the script\n\t# as root (UID 0).\n\tdistrobox_sudo_program=${DBX_SUDO_PROGRAM:-${distrobox_sudo_program:-\"sudo\"}}\nfi\n\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n[ -n \"${DBX_CONTAINER_NAME}\" ] && container_name=\"${DBX_CONTAINER_NAME}\"\n[ -n \"${DBX_CONTAINER_CLEAN_PATH}\" ] && clean_path=1\n[ -n \"${DBX_SKIP_WORKDIR}\" ] && skip_workdir=\"${DBX_SKIP_WORKDIR}\"\n[ -n \"${DBX_NON_INTERACTIVE}\" ] && non_interactive=\"${DBX_NON_INTERACTIVE}\"\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${non_interactive}\" = \"true\" ] && non_interactive=1\n[ \"${non_interactive}\" = \"false\" ] && non_interactive=0\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-enter --name fedora-39 -- bash -l\n\tdistrobox-enter my-alpine-container -- sh -l\n\tdistrobox-enter --additional-flags \"--preserve-fds\" --name test -- bash -l\n\tdistrobox-enter --additional-flags \"--env MY_VAR=value\" --name test -- bash -l\n\tMY_VAR=value distrobox-enter --additional-flags \"--preserve-fds\" --name test -- bash -l\n\nOptions:\n\n\t--name/-n:\t\tname for the distrobox\t\t\t\t\t\tdefault: my-distrobox\n\t--/-e:\t\t\tend arguments execute the rest as command to execute at login\tdefault: default ${USER}'s shell\n\t--clean-path:\t\treset PATH inside container to FHS standard\n\t--no-tty/-T:\t\tdo not instantiate a tty\n\t--no-workdir/-nw:\talways start the container from container's home directory\n\t--additional-flags/-a:\tadditional flags to pass to the container manager command\n\t--help/-h:\t\tshow this message\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--dry-run/-d:\t\tonly print the container manager command generated\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tshift\n\t\t\tverbose=1\n\t\t\t;;\n\t\t-T | -H | --no-tty)\n\t\t\tshift\n\t\t\theadless=1\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-d | --dry-run)\n\t\t\tshift\n\t\t\tdryrun=1\n\t\t\t;;\n\t\t-nw | --no-workdir)\n\t\t\tshift\n\t\t\tskip_workdir=1\n\t\t\t;;\n\t\t-n | --name)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-a | --additional-flags)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tif [ -z \"${container_manager_additional_flags=}\" ]; then\n\t\t\t\t\tcontainer_manager_additional_flags=\"${2}\"\n\t\t\t\telse\n\t\t\t\t\tcontainer_manager_additional_flags=\"${container_manager_additional_flags}\n\t\t\t\t\t${2}\"\n\t\t\t\tfi\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-Y | --yes)\n\t\t\tnon_interactive=1\n\t\t\tshift\n\t\t\t;;\n\t\t-e | --exec | --)\n\t\t\tcontainer_custom_command=1\n\t\t\tshift\n\t\t\t# We pass the rest of arguments as $@ at the end\n\t\t\tbreak\n\t\t\t;;\n\t\t--clean-path)\n\t\t\tshift\n\t\t\tclean_path=1\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcontainer_name=\"$1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\nif [ -z \"${container_name}\" ]; then\n\tcontainer_name=\"${container_name_default}\"\nfi\n\nif [ ! -t 0 ] || [ ! -t 1 ]; then\n\theadless=1\nfi\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null && [ \"${dryrun}\" -eq 0 ]; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman, docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n\n# add  verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\tcontainer_manager=\"${distrobox_sudo_program-} ${container_manager}\"\nfi\n\n# generate_enter_command will produce a Podman, Docker or Lilipod command to execute to enter the container.\n# Arguments:\n#   None\n# Expected global variables:\n#   container_manager: string container manager to use\n#   container_name: string container name\n#   container_manager_additional_flags: string container manager additional flags to use\n#   container_home: string container's home path\n#   container_path: string container's default PATH variable\n#   headless: bool headless mode\n#   skip_workdir: bool skip workdir\n#   verbose: bool verbose\n#   unshare_groups\n#   distrobox_enter_path\n# Expected env variables:\n#   PATH\n#   USER\n#   PWD\n#   XDG_DATA_DIRS\n#   XDG_CONFIG_DIRS\n# Outputs:\n#   prints the podman, docker or lilipod command to enter the distrobox container\ngenerate_enter_command()\n{\n\tresult_command=\"exec\"\n\tresult_command=\"${result_command}\n\t\t--interactive\"\n\tresult_command=\"${result_command}\n\t\t--detach-keys=\"\n\n\t# In case of initful systems or unshared groups, we don't enter directly\n\t# as our user, but we instead enter as root, and then su $USER, in order\n\t# to trigger a proper login\n\tif [ \"${unshare_groups:-0}\" -eq 1 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--user=root\"\n\telse\n\t\tresult_command=\"${result_command}\n\t\t\t--user ${USER}\"\n\tfi\n\n\t# For some usage, like use in service, or launched by non-terminal\n\t# eg. from desktop files, TTY can fail to instantiate, and fail to enter\n\t# the container.\n\t# To work around this, --headless let's you skip the --tty flag and make it\n\t# work in tty-less situations.\n\t# Disable tty also if we're NOT in a tty (test -t 0, test -t 1).\n\tif [ \"${headless}\" -eq 0 ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t--tty\"\n\tfi\n\n\t# Entering container using our user and workdir.\n\t# Start container from working directory. Else default to home. Else do /.\n\t# Since we are entering from host, drop at workdir through '/run/host'\n\t# which represents host's root inside container. Any directory on host\n\t# even if not explicitly mounted is bound to exist under /run/host.\n\t# Since user $HOME is very likely present in container, enter there directly\n\t# to avoid confusing the user about shifted paths.\n\t# pass distrobox-enter path, it will be used in the distrobox-export tool.\n\tif [ \"${skip_workdir}\" -eq 0 ]; then\n\t\tworkdir=\"${PWD:-${container_home:-\"/\"}}\"\n\t\tif [ -n \"${workdir##*\"${container_home}\"*}\" ]; then\n\t\t\tworkdir=\"/run/host${workdir}\"\n\t\tfi\n\telse\n\t\t# Skipping workdir we just enter $HOME of the container.\n\t\tworkdir=\"${container_home}\"\n\tfi\n\n\tresult_command=\"${result_command}\n\t\t--workdir ${workdir}\"\n\tresult_command=\"${result_command}\n\t\t--env CONTAINER_ID=${container_name}\"\n\tresult_command=\"${result_command}\n\t\t--env DISTROBOX_ENTER_PATH=${distrobox_enter_path}\"\n\n\t# Loop through all the environment vars\n\t# and export them to the container.\n\tset +o xtrace\n\t# disable logging for this snippet, or it will be too talkative.\n\tfor i in $(printenv | grep '=' | grep -Ev ' |\"|`|\\$' |\n\t\tgrep -Ev '^(CONTAINER_ID|HOST|HOSTNAME|HOME|PATH|PROFILEREAD|SHELL|XDG_SEAT|XDG_VTNR|XDG_.*_DIRS|^_)'); do\n\t\t# We filter the environment so that we do not have strange variables,\n\t\t# multiline or containing spaces.\n\t\t# We also NEED to ignore the HOME variable, as this is set at create time\n\t\t# and needs to stay that way to use custom home dirs.\n\t\tresult_command=\"${result_command}\n\t\t\t--env ${i}\"\n\tdone\n\n\t# Start with the $PATH set in the container's config\n\tcontainer_paths=\"${container_path:-\"\"}\"\n\t# Ensure the standard FHS program paths are in PATH environment\n\tstandard_paths=\"/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin\"\n\n\tif [ \"${clean_path}\" -eq 1 ]; then\n\t\t# only add the standard paths\n\t\tfor standard_path in ${standard_paths}; do\n\t\t\tif [ -z \"${container_paths}\" ]; then\n\t\t\t\tcontainer_paths=\"${standard_path}\"\n\t\t\telse\n\t\t\t\tcontainer_paths=\"${container_paths}:${standard_path}\"\n\t\t\tfi\n\t\tdone\n\telse\n\t\t# collect standard paths not existing from host PATH\n\t\tfor standard_path in ${standard_paths}; do\n\t\t\tpattern=\"(:|^)${standard_path}(:|$)\"\n\t\t\tif ! echo \"${PATH}\" | grep -Eq \"${pattern}\"; then\n\t\t\t\tif [ -z \"${container_paths}\" ]; then\n\t\t\t\t\tcontainer_paths=\"${standard_path}\"\n\t\t\t\telse\n\t\t\t\t\tcontainer_paths=\"${container_paths}:${standard_path}\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\t\t# append additional standard paths to host PATH to get final container_paths\n\t\tif [ -n \"${container_paths}\" ]; then\n\t\t\tcontainer_paths=\"${PATH}:${container_paths}\"\n\t\telse\n\t\t\tcontainer_paths=\"${PATH}\"\n\t\tfi\n\tfi\n\n\tresult_command=\"${result_command}\n\t\t--env PATH=${container_paths}\"\n\n\t# Ensure the standard FHS program paths are in XDG_DATA_DIRS environment\n\tstandard_paths=\"/usr/local/share /usr/share\"\n\tcontainer_paths=\"${XDG_DATA_DIRS:-}\"\n\t# add to the XDG_DATA_DIRS only after the host's paths, and only if not already present.\n\tfor standard_path in ${standard_paths}; do\n\t\tpattern=\"(:|^)${standard_path}(:|$)\"\n\t\tif [ -z \"${container_paths}\" ]; then\n\t\t\tcontainer_paths=\"${standard_path}\"\n\t\telif ! echo \"${container_paths}\" | grep -Eq \"${pattern}\"; then\n\t\t\tcontainer_paths=\"${container_paths}:${standard_path}\"\n\t\tfi\n\tdone\n\tresult_command=\"${result_command}\n\t\t--env XDG_DATA_DIRS=${container_paths}\"\n\n\t# This correctly sets the XDG_* dirs to the container_home\n\t# it will be $HOME if using regular home dirs\n\t# if will be $container_home if using a custom home during create\n\tresult_command=\"${result_command}\n\t\t--env XDG_CACHE_HOME=${container_home}/.cache\n\t\t--env XDG_CONFIG_HOME=${container_home}/.config\n\t\t--env XDG_DATA_HOME=${container_home}/.local/share\n\t\t--env XDG_STATE_HOME=${container_home}/.local/state\"\n\n\t# Ensure the standard FHS program paths are in XDG_CONFIG_DIRS environment\n\tstandard_paths=\"/etc/xdg\"\n\tcontainer_paths=\"${XDG_CONFIG_DIRS:-}\"\n\t# add to the XDG_CONFIG_DIRS only after the host's paths, and only if not already present.\n\tfor standard_path in ${standard_paths}; do\n\t\tpattern=\"(:|^)${standard_path}(:|$)\"\n\t\tif [ -z \"${container_paths}\" ]; then\n\t\t\tcontainer_paths=\"${standard_path}\"\n\t\telif ! echo \"${container_paths}\" | grep -Eq \"${pattern}\"; then\n\t\t\tcontainer_paths=\"${container_paths}:${standard_path}\"\n\t\tfi\n\tdone\n\tresult_command=\"${result_command}\n\t\t--env XDG_CONFIG_DIRS=${container_paths}\"\n\n\t# re-enable logging if it was enabled previously.\n\tif [ \"${verbose}\" -ne 0 ]; then\n\t\tset -o xtrace\n\tfi\n\n\t# Add additional flags\n\tif [ -n \"${container_manager_additional_flags}\" ]; then\n\t\tresult_command=\"${result_command}\n\t\t\t${container_manager_additional_flags}\"\n\tfi\n\n\t# Run selected container with specified command.\n\tresult_command=\"${result_command}\n\t\t${container_name}\"\n\n\t# Return generated command.\n\t# here we remove tabs as an artifact of using indentation in code to improve\n\t# readability\n\tprintf \"%s\\n\" \"${result_command}\" | tr -d '\\t'\n}\n\ncontainer_home=\"${HOME}\"\ncontainer_path=\"${PATH}\"\nunshare_groups=0\n# Now inspect the container we're working with.\ncontainer_status=\"unknown\"\neval \"$(${container_manager} inspect --type container --format \\\n\t'container_status={{.State.Status}};\n\tunshare_groups={{ index .Config.Labels \"distrobox.unshare_groups\" }};\n\t{{range .Config.Env}}{{if and (ge (len .) 5) (eq (slice . 0 5) \"HOME=\")}}container_home={{slice . 5 | printf \"%q\"}}{{end}}{{end}};\n\t{{range .Config.Env}}{{if and (ge (len .) 5) (eq (slice . 0 5) \"PATH=\")}}container_path={{slice . 5 | printf \"%q\"}}{{end}}{{end}}' \\\n\t\"${container_name}\")\"\n\n# dry run mode, just generate the command and print it. No execution.\nif [ \"${dryrun}\" -ne 0 ]; then\n\tcmd=\"$(generate_enter_command | sed 's/\\t//g')\"\n\tprintf \"%s %s\\n\" \"${cmd}\" \"$*\"\n\texit 0\nfi\n\n# Check if the container is even there\nif [ \"${container_status}\" = \"unknown\" ]; then\n\t# If not, prompt to create it first\n\t# If we're not-interactive, just don't ask questions\n\tif [ \"${non_interactive}\" -eq 1 ]; then\n\t\tresponse=\"yes\"\n\telse\n\t\tprintf >&2 \"Create it now, out of image %s? [Y/n]: \" \"${container_image_default}\"\n\t\tread -r response\n\t\tresponse=\"${response:-\"Y\"}\"\n\tfi\n\n\t# Accept only y,Y,Yes,yes,n,N,No,no.\n\tcase \"${response}\" in\n\t\ty | Y | Yes | yes | YES)\n\t\t\t# Ok, let's create the container with just 'distrobox create $container_name\n\t\t\tcreate_command=\"$(dirname \"${0}\")/distrobox-create\"\n\t\t\tif [ \"${rootful}\" -ne 0 ]; then\n\t\t\t\tcreate_command=\"${create_command} --root\"\n\t\t\tfi\n\n\t\t\tcreate_command=\"${create_command} --yes -i ${container_image_default} -n ${container_name}\"\n\n\t\t\tprintf >&2 \"Creating the container %s\\n\" \"${container_name}\"\n\n\t\t\tif [ \"${dryrun}\" -ne 1 ]; then\n\t\t\t\t${create_command}\n\t\t\tfi\n\t\t\t;;\n\t\tn | N | No | no | NO)\n\t\t\tprintf >&2 \"Ok. For creating it, run this command:\\n\"\n\t\t\tprintf >&2 \"\\tdistrobox create <name-of-container> --image <remote>/<docker>:<tag>\\n\"\n\t\t\texit 0\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tprintf >&2 \"Invalid input.\\n\"\n\t\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\nfi\n\n# If the container is not already running, we need to start if first\nif [ \"${container_status}\" != \"running\" ]; then\n\t# If container is not running, start it first\n\t#\n\t# Here, we save the timestamp before launching the start command, so we can\n\t# be sure we're working with this very same session of logs later.\n\tlog_timestamp=\"$(date -u +%FT%T).000000000+00:00\"\n\t${container_manager} start \"${container_name}\" > /dev/null\n\t#\n\t# Check if the container is going in error status earlier than the\n\t# entrypoint\n\tif [ \"$(${container_manager} inspect \\\n\t\t--type container \\\n\t\t--format \"{{.State.Status}}\" \"${container_name}\")\" != \"running\" ]; then\n\n\t\tprintf >&2 \"\\033[31m Error: could not start entrypoint.\\n\\033[0m\"\n\t\tcontainer_manager_log=\"$(${container_manager} logs \"${container_name}\")\"\n\t\tprintf >&2 \"%s\\n\" \"${container_manager_log}\"\n\t\texit 1\n\tfi\n\n\tprintf >&2 \"%-40s\\t\" \"Starting container...\"\n\tmkdir -p \"${app_cache_dir}\"\n\trm -f \"${app_cache_dir}/.${container_name}.fifo\"\n\tmkfifo \"${app_cache_dir}/.${container_name}.fifo\"\n\twhile true; do\n\t\t# Exit early in case of crashed/stopped container during setup\n\t\tif [ \"$(${container_manager} inspect --type container --format '{{.State.Status}}' \"${container_name}\")\" != \"running\" ]; then\n\t\t\tprintf >&2 \"\\nContainer Setup Failure!\\n\"\n\t\t\texit 1\n\t\tfi\n\t\t# save starting loop timestamp in temp variable, we'll use it\n\t\t# after to let logs command minimize possible holes\n\t\t${container_manager} logs --since \"${log_timestamp}\" -f \"${container_name}\" \\\n\t\t\t> \"${app_cache_dir}/.${container_name}.fifo\" 2>&1 &\n\t\tlogs_pid=\"$!\"\n\n\t\t# read logs from log_timestamp to now, line by line\n\t\twhile IFS= read -r line; do\n\t\t\tcase \"${line}\" in\n\t\t\t\t\"+\"*)\n\t\t\t\t\t# Ignoring logging commands\n\t\t\t\t\t;;\n\t\t\t\t\"Error:\"*)\n\t\t\t\t\tprintf >&2 \"\\033[31m %s\\n\\033[0m\" \"${line}\"\n\t\t\t\t\texit 1\n\t\t\t\t\t;;\n\t\t\t\t\"Warning:\"*)\n\t\t\t\t\tprintf >&2 \"\\n\\033[33m %s\\033[0m\" \"${line}\"\n\t\t\t\t\t;;\n\t\t\t\t\"distrobox:\"*)\n\t\t\t\t\tcurrent_line=\"$(echo \"${line}\" | cut -d' ' -f2-)\"\n\t\t\t\t\t# Save current line in the status, to avoid printing the same line multiple times\n\t\t\t\t\tprintf >&2 \"\\033[32m [ OK ]\\n\\033[0m%-40s\\t\" \"${current_line}\"\n\t\t\t\t\t;;\n\t\t\t\t\"container_setup_done\"*)\n\t\t\t\t\tprintf >&2 \"\\033[32m [ OK ]\\n\\033[0m\"\n\t\t\t\t\tkill \"${logs_pid}\" > /dev/null 2>&1\n\t\t\t\t\tbreak 2\n\t\t\t\t\t;;\n\t\t\t\t*) ;;\n\t\t\tesac\n\t\tdone < \"${app_cache_dir}/.${container_name}.fifo\"\n\tdone\n\t# cleanup fifo\n\trm -f \"${app_cache_dir}/.${container_name}.fifo\"\n\tprintf >&2 \"\\nContainer Setup Complete!\\n\"\nfi\n\n################################################################################\n# Execution section, in this section we will manipulate the positional parameters\n# in order to generate our long docker/podman/lilipod command to execute.\n#\n# We use positional parameters in order to have the shell manage escaping and spaces\n# so we remove the problem of we having to handle them.\n#\n# 1 - handle absence of custom command, we will need to add a getent command to\n#     execute the right container's user's shell\n# 2 - in case of unshared groups (or initful) we need to trigger a proper login\n#     using `su`, so we will need to manipulate these arguments accorodingly\n# 3 - prepend our generated command\n#     to do this, we use `tac` so we reverse loop it and prepend each argument.\n# 4 - now that we're done, we can prepend our container_command\n#     we will need to use `rev` to reverse it as we reverse loop and prepend each\n#     argument\n################################################################################\n#\n# Setup default commands if none are specified\n# execute a getent command using the /bin/sh shell\n# to find out the default shell of the user, and\n# do a login shell with it (eg: /bin/bash -l)\nif [ \"${container_custom_command}\" -eq 0 ]; then\n\tset - \"$@\" \"/bin/sh\" \"-c\" \"\\$(getent passwd '${container_command_user}' | cut -f 7 -d :) -l\"\nfi\n\n# If we have a command and we're unsharing groups, we need to execute those\n# command using su $container_command_user\n# if we're in a tty, also allocate one\nif [ \"${unshare_groups:-0}\" -eq 1 ]; then\n\t# shellcheck disable=SC2089,SC2016\n\tset -- \"-c\" '\"$0\" \"$@\"' -- \"$@\"\n\tset -- \"-s\" \"/bin/sh\" \"$@\"\n\tif [ \"${headless}\" -eq 0 ]; then\n\t\tset -- \"--pty\" \"$@\"\n\tfi\n\tset -- \"${container_command_user}\" \"$@\"\n\tset -- \"su\" \"$@\"\nfi\n\n# Generate the exec command and run it\ncmd=\"$(generate_enter_command | tac)\"\n# Reverse it with tac so we can reverse loop and prepend the command's arguments\n# to our positional parameters\nIFS='\n'\nfor arg in ${cmd}; do\n\tif echo \"${arg}\" | grep -q \" \"; then\n\t\tset - \"$(echo \"${arg}\" | cut -d' ' -f1)\" \"$(echo \"${arg}\" | cut -d' ' -f2-)\" \"$@\"\n\telse\n\t\tset - \"${arg}\" \"$@\"\n\tfi\ndone\n\n# Prepend the container manager command\n# reverse it first, so we can loop backward as we're prepending not appending\nIFS=' '\nfor arg in $(echo \"${container_manager}\" | rev); do\n\targ=\"$(echo \"${arg}\" | rev)\"\n\tset - \"${arg}\" \"$@\"\ndone\n\nexec \"$@\"\n"
        },
        {
          "name": "distrobox-ephemeral",
          "type": "blob",
          "size": 7.8642578125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Optional env variables:\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_CONTAINER_NAME\n#\tDBX_VERBOSE\n#\tDBX_SUDO_PROGRAM\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\ntrap cleanup TERM INT HUP\n\nname=$(mktemp -u distrobox-XXXXXXXXXX)\ncontainer_command=\"\"\ncreate_flags=\"\"\ndistrobox_path=\"$(dirname \"${0}\")\"\nextra_flags=\"\"\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"$(id -ru)\" -eq 0 ] && rootful=1 || rootful=0\nverbose=0\nversion=\"1.8.0\"\ncontainer_additional_packages=\"\"\ncontainer_init_hook=\" \"\ncontainer_manager_additional_flags=\"\"\ncontainer_pre_init_hook=\" \"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-ephemeral [--root/-r]\n\nOptions:\n\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--verbose/-v:\t\tshow more verbosity\n\t--help/-h:\t\tshow this message\n\t--/-e:\t\t\tend arguments execute the rest as command to execute at login\tdefault: default ${USER}'s shell\n\t--version/-V:\t\tshow version\n\nSee also:\n\n\tdistrobox-ephemeral also inherits all the flags from distrobox-create:\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\t\"${distrobox_path}\"/distrobox-create --help | tail -n +2\n\t\t\texit 0\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-e | --exec | --)\n\t\t\tshift\n\t\t\tcontainer_command=\"-- $*\"\n\t\t\tbreak\n\t\t\t;;\n\t\t-n | --name)\n\t\t\t# Ignore --name on ephemeral\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tname=\"${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-a | --additional-flags)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_manager_additional_flags=\"${container_manager_additional_flags} ${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-ap | --additional-packages)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_additional_packages=\"${container_additional_packages} ${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--init-hooks)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_init_hook=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--pre-init-hooks)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_pre_init_hook=\"${2}\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcreate_flags=\"${create_flags} $1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\n\textra_flags=\"${extra_flags} --verbose\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\textra_flags=\"${extra_flags} --root\"\nfi\n\n# generate_ephemeral_create_command will produce a distrobox-create command to execute.\n# Arguments:\n#   None\n# Expected global variables:\n#   distrobox_path = string distrobox path\n#   name         = string container name\n#   extra_flags  = string extra flags to inject\n#   create_flags = string create extra flags to inject\n# Expected env variables:\n#   None\n# Outputs:\n#   prints the distrobox-create command handling special flags\ngenerate_ephemeral_create_command()\n{\n\tresult_command=\"${distrobox_path}/distrobox-create\"\n\tif [ -n \"${container_manager_additional_flags}\" ]; then\n\t\tresult_command=\"${result_command} \\\n\t\t\t--additional-flags \\\"${container_manager_additional_flags}\\\"\"\n\tfi\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\tresult_command=\"${result_command} \\\n\t\t\t--additional-packages \\\"${container_additional_packages}\\\"\"\n\tfi\n\tif [ -n \"${container_init_hook}\" ]; then\n\t\tresult_command=\"${result_command} \\\n\t\t\t--init-hooks \\\"${container_init_hook}\\\"\"\n\tfi\n\tif [ -n \"${container_pre_init_hook}\" ]; then\n\t\tresult_command=\"${result_command} \\\n\t\t\t--pre-init-hooks \\\"${container_pre_init_hook}\\\"\"\n\tfi\n\tresult_command=\"${result_command} \\\n\t\t${extra_flags} ${create_flags} --yes --name ${name}\"\n\n\t# Return generated command.\n\tprintf \"%s\" \"${result_command}\"\n}\n\n# cleanup will ensure we remove the ephemeral container\n# Arguments:\n#   None\n# Expected global variables:\n#   name: string the name of the container\n#   extra_flags: string extra flags to append to the distrobox command\n#   distrobox_path: string path to the distrobox script\n# Expected env variables:\n#   None\n# Outputs:\n#   None\ncleanup()\n{\n\ttrap - TERM INT HUP\n\t# shellcheck disable=SC2086\n\t\"${distrobox_path}\"/distrobox-rm ${extra_flags} --force \"${name}\" --yes\n}\n\ncmd=\"$(generate_ephemeral_create_command)\"\n# shellcheck disable=SC2086\neval ${cmd}\n# shellcheck disable=SC2086\n\"${distrobox_path}\"/distrobox-enter ${extra_flags} \"${name}\" ${container_command}\nexit_code=\"$?\"\n\ncleanup\n\nexit \"${exit_code}\"\n"
        },
        {
          "name": "distrobox-export",
          "type": "blob",
          "size": 21.591796875,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Expected env variables:\n#\tHOME\n#\tUSER\n#\tDISTROBOX_ENTER_PATH\n#\tDISTROBOX_HOST_HOME\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# Defaults\ncontainer_name=\"${CONTAINER_ID:-}\"\n[ -z \"${container_name}\" ] && container_name=\"$(grep \"name=\" /run/.containerenv | cut -d'=' -f2- | tr -d '\"')\"\nexport_action=\"\"\nexported_app=\"\"\nexported_app_label=\"\"\nexported_bin=\"\"\nexported_delete=0\nextra_flags=\"\"\nenter_flags=\"\"\n# Use DBX_HOST_HOME if defined, else fallback to HOME\n#\tDBX_HOST_HOME is set in case container is created\n#\twith custom --home directory\nhost_home=\"${DISTROBOX_HOST_HOME:-\"${HOME}\"}\"\ndest_path=\"${DISTROBOX_EXPORT_PATH:-${host_home}/.local/bin}\"\nis_sudo=0\nrootful=\"\"\nsudo_prefix=\"\"\nverbose=0\nversion=\"1.8.0\"\n\nsudo_askpass_path=\"${dest_path}/distrobox_sudo_askpass\"\nsudo_askpass_script=\"#!/bin/sh\nif command -v zenity 2>&1 > /dev/null; then\n\tzenity --password\nelif command -v kdialog 2>&1 > /dev/null; then\n\tkdialog --password 'A password is required...'\nelse\n\texit 127\nfi\"\n\n# We depend on some commands, let's be sure we have them\nbase_dependencies=\"basename find grep sed\"\nfor dep in ${base_dependencies}; do\n\tif ! command -v \"${dep}\" > /dev/null; then\n\t\tprintf >&2 \"Missing dependency: %s\\n\" \"${dep}\"\n\t\texit 127\n\tfi\ndone\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-export --app mpv [--extra-flags \"flags\"] [--enter-flags \"flags\"] [--delete] [--sudo]\n\tdistrobox-export --bin /path/to/bin [--export-path ~/.local/bin] [--extra-flags \"flags\"] [--enter-flags \"flags\"] [--delete] [--sudo]\n\nOptions:\n\n\t--app/-a:\t\tname of the application to export or absolute path to desktopfile to export\n\t--bin/-b:\t\tabsolute path of the binary to export\n\t--list-apps:\t\tlist applications exported from this container\n\t--list-binaries:\tlist binaries exported from this container, use -ep to specify custom paths to search\n\t--delete/-d:\t\tdelete exported application or binary\n\t--export-label/-el:\tlabel to add to exported application name.\n\t\t\t\tUse \"none\" to disable.\n\t\t\t\tDefaults to (on \\$container_name)\n\t--export-path/-ep:\tpath where to export the binary\n\t--extra-flags/-ef:\textra flags to add to the command\n\t--enter-flags/-nf:\tflags to add to distrobox-enter\n\t--sudo/-S:\t\tspecify if the exported item should be run as sudo\n\t--help/-h:\t\tshow this message\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tshift\n\t\t\tverbose=1\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-a | --app)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\texport_action=\"app\"\n\t\t\t\texported_app=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-b | --bin)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\texport_action=\"bin\"\n\t\t\t\texported_bin=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--list-apps)\n\t\t\texport_action=\"list-apps\"\n\t\t\texported_bin=\"null\"\n\t\t\tshift\n\t\t\t;;\n\t\t--list-binaries)\n\t\t\texport_action=\"list-binaries\"\n\t\t\texported_bin=\"null\"\n\t\t\tshift\n\t\t\t;;\n\t\t-S | --sudo)\n\t\t\tis_sudo=1\n\t\t\tshift\n\t\t\t;;\n\t\t-el | --export-label)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\texported_app_label=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-ep | --export-path)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tdest_path=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-ef | --extra-flags)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\textra_flags=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-nf | --enter-flags)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tenter_flags=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-d | --delete)\n\t\t\texported_delete=1\n\t\t\tshift\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tbreak ;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# Ensure we can write stuff there\nif [ ! -e \"${dest_path}\" ]; then\n\tmkdir -p \"${dest_path}\"\nfi\n\n# Check we're running inside a container and not on the host.\nif [ ! -f /run/.containerenv ] && [ ! -f /.dockerenv ] && [ -z \"${container:-}\" ]; then\n\tprintf >&2 \"You must run %s inside a container!\\n\" \" $(basename \"$0\")\"\n\texit 126\nfi\n\n# Check if we're in a rootful or rootless container.\nif grep -q \"rootless=0\" /run/.containerenv 2> /dev/null; then\n\trootful=\"--root\"\n\n\t# We need an askpass script for SUDO_ASKPASS, to launch graphical apps\n\t# from the drawer\n\tif [ ! -e \"${sudo_askpass_path}\" ]; then\n\t\techo \"${sudo_askpass_script}\" > \"${sudo_askpass_path}\"\n\t\tchmod +x \"${sudo_askpass_path}\"\n\tfi\nfi\n\n# We're working with HOME, so we must run as USER, not as root.\nif [ \"$(id -u)\" -eq 0 ]; then\n\tprintf >&2 \"You must not run %s as root!\\n\" \" $(basename \"$0\")\"\n\texit 1\nfi\n\n# Ensure we're not receiving more than one action at time.\nif [ -n \"${exported_app}\" ] && [ -n \"${exported_bin}\" ]; then\n\tprintf >&2 \"Error: Invalid arguments, choose only one action below.\\n\"\n\tprintf >&2 \"Error: You can only export one thing at time.\\n\"\n\texit 2\nfi\n\n# Filter enter_flags and remove redundant options\nif [ -n \"${enter_flags}\" ]; then\n\t# shellcheck disable=SC2086\n\tset -- ${enter_flags}\n\tfiltered_flags=\"\"\n\t# Inform user that certain flags are redundant\n\twhile [ $# -gt 0 ]; do\n\t\tcase \"$1\" in\n\t\t\t--root | -r)\n\t\t\t\tprintf >&2 \"Warning: %s argument will be set automatically and should be removed.\\n\" \"${1}\"\n\t\t\t\t;;\n\t\t\t--name | -n)\n\t\t\t\tprintf >&2 \"Warning: %s argument will be set automatically and should be removed.\\n\" \"${1}\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tfiltered_flags=\"${filtered_flags} $1\"\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\tenter_flags=\"${filtered_flags}\"\nfi\n\n# Command to execute\ncontainer_command_suffix=\"'${exported_bin}' ${extra_flags} \\\"\\$@\\\"\"\n\n# Check if exported application/binary should be run with sudo privileges\nif [ \"${is_sudo}\" -ne 0 ]; then\n\tsudo_prefix=\"sudo -S\"\n\n\t# Edge case for systems without sudo\n\tif command -v su-exec > /dev/null >&1; then\n\t\tsudo_prefix=\"su-exec root\"\n\t\tcontainer_command_suffix=\"sh -l -c \\\"'${exported_bin}' ${extra_flags} \\$@\\\"\"\n\tfi\nfi\n\n# Prefix to add to an existing command to work through the container\ncontainer_command_prefix=\"${DISTROBOX_ENTER_PATH:-\"distrobox-enter\"} ${rootful} -n ${container_name} ${enter_flags} -- ${sudo_prefix} \"\n\nif [ -n \"${rootful}\" ]; then\n\tcontainer_command_prefix=\"env SUDO_ASKPASS=\\\"${sudo_askpass_path}\\\" DBX_SUDO_PROGRAM=\\\"sudo --askpass\\\" ${container_command_prefix}\"\nfi\n\nif [ -z \"${exported_app_label}\" ]; then\n\texported_app_label=\" (on ${container_name})\"\nelif [ \"${exported_app_label}\" = \"none\" ]; then\n\texported_app_label=\"\"\nelse\n\t# Add a leading space so that we can have \"NAME LABEL\" in the entry\n\texported_app_label=\" ${exported_app_label}\"\nfi\n\n# generate_script will generate a script from template. This script will wrap the\n# exported binary in order to ensure it will be executed in the right container.\n# Arguments:\n#\tNone\n# Expected global variables:\n#   CONTAINER_ID: id of the current container\n#   container_command_suffix: string to postpone to the command to launch\n#   container_name:  string name of this container\n#   dest_path: string path where to export the binary\n#   enter_flags:  string extra flags to append to the distrobox enter command\n#   exported_bin: string path to the binary to export\n#   exported_delete: bool delete the binary exported\n#   extra_flags:  string extra flags to append to the exported app command\n#   rootful: bool if this is a rootful container\n#   sudo_prefix: string sudo command to prepend to the exported command\n# Expected env variables:\n#   None\n# Outputs:\n#\tprint generated script.\ngenerate_script()\n{\n\tcat << EOF\n#!/bin/sh\n# distrobox_binary\n# name: ${container_name}\nif [ -z \"\\${CONTAINER_ID}\" ]; then\n\texec \"${DISTROBOX_ENTER_PATH:-\"distrobox-enter\"}\" ${rootful} -n ${container_name} ${enter_flags} -- ${sudo_prefix} ${container_command_suffix}\nelif [ -n \"\\${CONTAINER_ID}\" ] && [ \"\\${CONTAINER_ID}\" != \"${container_name}\" ]; then\n\texec distrobox-host-exec '${dest_path}/$(basename \"${exported_bin}\")' \"\\$@\"\nelse\n\texec '${exported_bin}' \"\\$@\"\nfi\nEOF\n\treturn $?\n}\n\n# export_binary will export selected binary to destination directory.\n# the following function will use generate_script to create a shell script in\n# dest_path that will execute the exported binary in the selected distrobox.\n#\n# Arguments:\n#\tNone\n# Expected global variables:\n#   CONTAINER_ID: id of the current container\n#   container_name: string name of this container\n#   dest_path: string path where to export the binary\n#   exported_bin: string path to the binary to export\n#   exported_delete: bool delete the binary exported\n# Expected env variables:\n#   None\n# Outputs:\n#\ta generated_script in dest_path\n#\tor error code.\nexport_binary()\n{\n\t# Ensure the binary we're exporting is installed\n\tif [ ! -f \"${exported_bin}\" ]; then\n\t\tprintf >&2 \"Error: cannot find %s.\\n\" \"${exported_bin}\"\n\t\treturn 127\n\tfi\n\t# generate dest_file path\n\tdest_file=\"${dest_path}/$(basename \"${exported_bin}\")\"\n\n\t# create the binary destination path if it doesn't exist\n\tmkdir -p \"${dest_path}\"\n\n\t# If we're deleting it, just do it and exit\n\tif [ \"${exported_delete}\" -ne 0 ]; then\n\t\t# ensure it's a distrobox exported binary\n\t\tif ! grep -q \"distrobox_binary\" \"${dest_file}\"; then\n\t\t\tprintf >&2 \"Error: %s is not exported.\\n\" \"${exported_bin}\"\n\t\t\treturn 1\n\t\tfi\n\n\t\tif rm -f \"${dest_file}\"; then\n\t\t\tprintf \"%s from %s removed successfully from %s.\\nOK!\\n\" \\\n\t\t\t\t\"${exported_bin}\" \"${container_name}\" \"${dest_path}\"\n\t\t\treturn 0\n\t\tfi\n\t\treturn 1\n\tfi\n\n\t# test if we have writing rights on the file\n\tif ! touch \"${dest_file}\"; then\n\t\tprintf >&2 \"Error: cannot create destination file %s.\\n\" \"${dest_file}\"\n\t\treturn 1\n\tfi\n\n\t# create the script from template and write to file\n\tif generate_script > \"${dest_file}\"; then\n\t\tchmod +x \"${dest_file}\"\n\t\tprintf \"%s from %s exported successfully in %s.\\nOK!\\n\" \\\n\t\t\t\"${exported_bin}\" \"${container_name}\" \"${dest_path}\"\n\t\treturn 0\n\tfi\n\t# Unknown error.\n\treturn 3\n}\n\n# export_application will export input graphical application to the host.\n# the following function will scan the distrobox for desktop and icon files for\n# the selected application. It will then put the needed icons in the host's icons\n# directory and create a new .desktop file that will execute the selected application\n# in the distrobox.\n#\n# Arguments:\n#\tNone\n# Expected global variables:\n#   CONTAINER_ID: id of the current container\n#   container_command_prefix: string to prepend to the command to launch\n#   container_name:  string name of this container\n#   exported_app:   string name of the app to export\n#   exported_app_label: string label to use to mark the exported app\n#   exported_delete:  bool if we want to delete or not\n#   extra_flags:  string extra flags to append to the exported app command\n#   host_home: home path ofr the host, where to search desktop files\n# Expected env variables:\n#   None\n# Outputs:\n#\tneeded icons in /run/host/$host_home/.local/share/icons\n#\tneeded desktop files in /run/host/$host_home/.local/share/applications\n#\tor error code.\nexport_application()\n{\n\tcanon_dirs=\"\"\n\n\t# In case we're explicitly going for a full desktopfile path\n\tif [ -e \"${exported_app}\" ]; then\n\t\tdesktop_files=\"${exported_app}\"\n\telse\n\t\tIFS=\":\"\n\t\tif [ -n \"${XDG_DATA_DIRS}\" ]; then\n\t\t\tfor xdg_data_dir in ${XDG_DATA_DIRS}; do\n\t\t\t\t[ -d \"${xdg_data_dir}/applications\" ] && canon_dirs=\"${canon_dirs} ${xdg_data_dir}/applications\"\n\t\t\tdone\n\t\telse\n\t\t\t[ -d /usr/share/applications ] && canon_dirs=\"/usr/share/applications\"\n\t\t\t[ -d /usr/local/share/applications ] && canon_dirs=\"${canon_dirs} /usr/local/share/applications\"\n\t\t\t[ -d /var/lib/flatpak/exports/share/applications ] && canon_dirs=\"${canon_dirs} /var/lib/flatpak/exports/share/applications\"\n\t\tfi\n\t\tif [ -n \"${XDG_DATA_HOME}\" ]; then\n\t\t\t[ -d \"${XDG_DATA_HOME}/applications\" ] && canon_dirs=\"${canon_dirs} ${XDG_DATA_HOME}/applications\"\n\t\telse\n\t\t\t[ -d \"${HOME}/.local/share/applications\" ] && canon_dirs=\"${canon_dirs} ${HOME}/.local/share/applications\"\n\t\tfi\n\t\tunset IFS\n\n\t\t# In this phase we search for applications to export.\n\t\t# First find command will grep through all files in the canonical directories\n\t\t# and only list files that contain the $exported_app, excluding those that\n\t\t# already contains a distrobox-enter command. So skipping already exported apps.\n\t\t# Second find will list all files that contain the name specified, so that\n\t\t# it is possible to export an app not only by its executable name but also\n\t\t# by its launcher name.\n\t\tdesktop_files=$(\n\t\t\t# shellcheck disable=SC2086\n\t\t\tfind ${canon_dirs} -type f -print -o -type l -print | sed 's/./\\\\&/g' |\n\t\t\t\txargs -I{} grep -l -e \"Exec=.*${exported_app}.*\" -e \"Name=.*${exported_app}.*\" \"{}\" | sed 's/./\\\\&/g' |\n\t\t\t\txargs -I{} grep -L -e \"Exec=.*${DISTROBOX_ENTER_PATH:-\"distrobox.*enter\"}.*\" \"{}\" | sed 's/./\\\\&/g' |\n\t\t\t\txargs -I{} printf \"%s\" \"{}\"\n\t\t)\n\tfi\n\n\t# Ensure the app we're exporting is installed\n\t# Check that we found some desktop files first.\n\tif [ -z \"${desktop_files}\" ]; then\n\t\tprintf >&2 \"Error: cannot find any desktop files.\\n\"\n\t\tprintf >&2 \"Error: trying to export a non-installed application.\\n\"\n\t\treturn 127\n\tfi\n\n\t# Find icons by using the Icon= specification. If it's only a name, we'll\n\t# search for the file, if it's already a path, just grab it.\n\ticon_files=\"\"\n\tIFS=\"\"\n\tfor desktop_file in ${desktop_files}; do\n\t\tif [ -z \"${desktop_file}\" ]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\ticon_name=\"$(grep Icon= \"${desktop_file}\" | cut -d'=' -f2- | paste -sd \"\" -)\"\n\n\t\tfor icon in ${icon_name}; do\n\t\t\tif case \"${icon_name}\" in \"/\"*) true ;; *) false ;; esac &&\n\t\t\t\t[ -e \"${icon_name}\" ]; then\n\t\t\t\t# In case it's an hard path, conserve it and continue\n\t\t\t\ticon_files=\"${icon_files}${icon_name}\"\n\t\t\telse\n\t\t\t\t# If it's not an hard path, find all files in the canonical paths.\n\t\t\t\ticon_files=\"${icon_files}$(find \\\n\t\t\t\t\t/usr/share/icons \\\n\t\t\t\t\t/usr/share/pixmaps \\\n\t\t\t\t\t/var/lib/flatpak/exports/share/icons -iname \"*${icon}*\" \\\n\t\t\t\t\t-printf \"%p\" 2> /dev/null || :)\"\n\t\t\tfi\n\t\tdone\n\n\t\t# remove leading delimiter\n\t\ticon_files=${icon_files#}\n\tdone\n\n\t# create applications dir if not existing\n\tmkdir -p \"/run/host${host_home}/.local/share/applications\"\n\n\t# copy icons in home directory\n\ticon_file_absolute_path=\"\"\n\tIFS=\"\"\n\tfor icon_file in ${icon_files}; do\n\t\tif [ -z \"${icon_file}\" ]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\t# replace canonical paths with equivalent paths in HOME\n\t\ticon_home_directory=\"$(dirname \"${icon_file}\" |\n\t\t\tsed \"s|/usr/share/|\\/run\\/host\\/${host_home}/.local/share/|g\" |\n\t\t\tsed \"s|/var/lib/flatpak/exports/share|\\/run\\/host\\/${host_home}/.local/share/|g\" |\n\t\t\tsed \"s|pixmaps|icons|g\")\"\n\n\t\t# check if we're exporting an icon which is not in a canonical path\n\t\tif [ \"${icon_home_directory}\" = \"$(dirname \"${icon_file}\")\" ]; then\n\t\t\ticon_home_directory=\"${host_home}/.local/share/icons/\"\n\t\t\ticon_file_absolute_path=\"${icon_home_directory}$(basename \"${icon_file}\")\"\n\t\tfi\n\n\t\t# check if we're exporting or deleting\n\t\tif [ \"${exported_delete}\" -ne 0 ]; then\n\t\t\t# we need to remove, not export\n\t\t\trm -rf \"${icon_home_directory:?}\"/\"$(basename \"${icon_file:?}\")\"\n\t\t\tcontinue\n\t\tfi\n\n\t\t# we wanto to export the application's icons\n\t\tmkdir -p \"${icon_home_directory}\"\n\t\tif [ ! -e \"${icon_home_directory}/$(basename \"${icon_file}\")\" ] && [ -e \"$(realpath \"${icon_file}\")\" ]; then\n\t\t\tcp -rf \"$(realpath \"${icon_file}\")\" \"${icon_home_directory}\"\n\t\tfi\n\tdone\n\n\t# create desktop files for the distrobox\n\tIFS=\"\"\n\tfor desktop_file in ${desktop_files}; do\n\t\tif [ -z \"${desktop_file}\" ]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\tdesktop_original_file=\"$(basename \"${desktop_file}\")\"\n\t\tdesktop_home_file=\"${container_name}-$(basename \"${desktop_file}\")\"\n\n\t\t# check if we're exporting or deleting\n\t\tif [ \"${exported_delete}\" -ne 0 ]; then\n\t\t\trm -f \"/run/host${host_home}/.local/share/applications/${desktop_original_file}\"\n\t\t\trm -f \"/run/host${host_home}/.local/share/applications/${desktop_home_file}\"\n\t\t\t# we're done, go to next\n\t\t\tcontinue\n\t\tfi\n\n\t\t# Add command_prefix\n\t\t# Add extra flags\n\t\t# Add closing quote\n\t\t# If a TryExec is present, we have to fake it as it will not work\n\t\t# through the container separation\n\t\tsed \"s|^Exec=\\(.*\\)|Exec=${container_command_prefix} \\1 |g\" \"${desktop_file}\" |\n\t\t\tsed \"s|\\(%.*\\)|${extra_flags} \\1|g\" |\n\t\t\tsed \"/^TryExec=.*/d\" |\n\t\t\tsed \"/^DBusActivatable=true/d\" |\n\t\t\tsed \"s|Name.*|&${exported_app_label}|g\" \\\n\t\t\t\t> \"/run/host${host_home}/.local/share/applications/${desktop_home_file}\"\n\t\t# in the end we add the final quote we've opened in the \"container_command_prefix\"\n\n\t\tif ! grep -q \"StartupWMClass\" \"/run/host${host_home}/.local/share/applications/${desktop_home_file}\"; then\n\t\t\tprintf \"StartupWMClass=%s\\n\" \"${exported_app}\" >> \"\\\n/run/host${host_home}/.local/share/applications/${desktop_home_file}\"\n\t\tfi\n\t\t# In case of an icon in a non canonical path, we need to replace the path\n\t\t# in the desktop file.\n\t\tif [ -n \"${icon_file_absolute_path}\" ]; then\n\t\t\tsed -i \"s|Icon=.*|Icon=${icon_file_absolute_path}|g\" \\\n\t\t\t\t\"/run/host${host_home}/.local/share/applications/${desktop_home_file}\"\n\t\t\t# we're done, go to next\n\t\t\tcontinue\n\t\tfi\n\n\t\t# In case of an icon in a canonical path, but specified as an absolute\n\t\t# we need to replace the path in the desktop file.\n\t\tsed -i \"s|Icon=/usr/share/|Icon=/run/host${host_home}/.local/share/|g\" \\\n\t\t\t\"/run/host${host_home}/.local/share/applications/${desktop_home_file}\"\n\t\tsed -i \"s|pixmaps|icons|g\" \\\n\t\t\t\"/run/host${host_home}/.local/share/applications/${desktop_home_file}\"\n\tdone\n\n\t# Update the desktop files database to ensure exported applications will\n\t# show up in the taskbar/desktop menu/whatnot right after running this\n\t# script.\n\t/usr/bin/distrobox-host-exec --yes update-desktop-database \"${host_home}/.local/share/applications\" > /dev/null 2>&1 || :\n\n\tif [ \"${exported_delete}\" -ne 0 ]; then\n\t\tprintf \"Application %s successfully un-exported.\\nOK!\\n\" \"${exported_app}\"\n\t\tprintf \"%s will disappear from your applications list in a few seconds.\\n\" \"${exported_app}\"\n\telse\n\t\tprintf \"Application %s successfully exported.\\nOK!\\n\" \"${exported_app}\"\n\t\tprintf \"%s will appear in your applications list in a few seconds.\\n\" \"${exported_app}\"\n\tfi\n}\n\n# list_exported_applications will print all exported applications in canonical directories.\n# the following function will list exported desktop files from this container.\n#\n# Arguments:\n#\tNone\n# Expected global variables:\n#   host_home: home path ofr the host, where to search desktop files\n#   CONTAINER_ID: id of the current container\n# Expected env variables:\n#   None\n# Outputs:\n#\ta list of exported apps\n#\tor error code.\nlist_exported_applications()\n{\n\t# In this phase we search for applications exported.\n\t# First find command will grep through all files in the canonical directories\n\t# and only list files that contain the $DISTROBOX_ENTER_PATH.\n\tdesktop_files=$(\n\t\t# shellcheck disable=SC2086\n\t\tfind \"/run/host${host_home}/.local/share/applications\" -type f -print -o -type l -print 2> /dev/null | sed 's/./\\\\&/g' |\n\t\t\txargs -I{} grep -l -e \"Exec=.*${DISTROBOX_ENTER_PATH:-\"distrobox.*enter\"}.*\" \"{}\" | sed 's/./\\\\&/g' |\n\t\t\txargs -I{} printf \"%s\" \"{}\"\n\t)\n\n\t# Then we try to pretty print them.\n\tIFS=\"\"\n\tfor i in ${desktop_files}; do\n\t\tif [ -z \"${i}\" ]; then\n\t\t\tcontinue\n\t\tfi\n\t\t# Get app name, and remove label\n\t\tname=\"$(grep -Eo 'Name=.*' \"${i}\" | head -n 1 | cut -d'=' -f2- | sed 's|(.*)||g')\"\n\t\t# Print only stuff we exported from this box!\n\t\tif echo \"${i}\" | grep -q \"${CONTAINER_ID}\"; then\n\t\t\tprintf \"%-20s | %-30s\\n\" \"${name}\" \"${i}\"\n\t\tfi\n\tdone\n\tunset IFS\n}\n\n# list_exported_binaries will print all exported binaries.\n# the following function will list exported desktop files from this container.\n# If no export-path is specified, it searches in the default path.\n#\n# Arguments:\n#\tNone\n# Expected global variables:\n#   dest_path: destination path where to search binaries\n#   CONTAINER_ID: id of the current container\n# Expected env variables:\n#\tNone\n# Outputs:\n#\ta list of exported apps\n#\tor error code.\nlist_exported_binaries()\n{\n\t# In this phase we search for binaries exported.\n\t# First find command will grep through all files in the canonical directories\n\t# and only list files that contain the comment \"# distrobox_binary\".\n\tbinary_files=$(\n\t\tfind \"${dest_path}\" -type f -print 2> /dev/null | sed 's/./\\\\&/g' |\n\t\t\txargs -I{} grep -l -e \"^# distrobox_binary\" \"{}\" | sed 's/./\\\\&/g' |\n\t\t\txargs -I{} printf \"%s\" \"{}\"\n\t)\n\n\t# Then we try to pretty print them.\n\tIFS=\"\"\n\tfor i in ${binary_files}; do\n\t\tif [ -z \"${i}\" ]; then\n\t\t\tcontinue\n\t\tfi\n\t\t# Get original binary name\n\t\tname=\"$(grep -B1 \"fi\" \"${i}\" | grep exec | cut -d' ' -f2)\"\n\t\t# Print only stuff we exported from this box!\n\t\tif grep \"^# name:.*\" \"${i}\" | grep -q \"${CONTAINER_ID}\"; then\n\t\t\tprintf \"%-20s | %-30s\\n\" \"${name}\" \"${i}\"\n\t\tfi\n\tdone\n\tunset IFS\n}\n\n# Main routine\ncase \"${export_action}\" in\n\tapp)\n\t\texport_application\n\t\t;;\n\tbin)\n\t\texport_binary\n\t\t;;\n\tlist-apps)\n\t\tlist_exported_applications\n\t\t;;\n\tlist-binaries)\n\t\tlist_exported_binaries\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid arguments, choose an action below.\\n\"\n\t\tshow_help\n\t\texit 2\n\t\t;;\nesac\n"
        },
        {
          "name": "distrobox-generate-entry",
          "type": "blob",
          "size": 12.984375,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Optional env variables:\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_VERBOSE\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"$(id -ru)\" -eq 0 ] && rootful=1 || rootful=0\nextra_flags=\"\"\nall=0\ncontainer_manager=\"autodetect\"\ncontainer_name_default=\"my-distrobox\"\ndelete=0\nicon=\"auto\"\nicon_default=\"${XDG_DATA_HOME:-${HOME}/.local/share}/icons/terminal-distrobox-icon.svg\"\nverbose=0\nonline=0\nversion=\"1.8.0\"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-generate-entry container-name [--delete] [--icon [auto,/path/to/icon]]\n\nOptions:\n\n\t--help/-h:\t\tshow this message\n\t--all/-a:\t\tperform for all distroboxes\n\t--delete/-d:\t\tdelete the entry\n\t--icon/-i:\t\tspecify a custom icon [/path/to/icon] (default auto)\n\t--root/-r:\t\tperform on rootful distroboxes\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-d | --delete)\n\t\t\tdelete=1\n\t\t\tshift\n\t\t\t;;\n\t\t-a | --all)\n\t\t\tall=1\n\t\t\tshift\n\t\t\t;;\n\t\t-i | --icon)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\ticon=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcontainer_name=\"$1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\nif [ -z \"${container_name:-}\" ]; then\n\tcontainer_name=\"${container_name_default}\"\nfi\n\nif [ \"${all}\" -ne 0 ]; then\n\tcontainer_names=\"$(distrobox list --no-color | tail -n +2 | cut -d'|' -f2 | tr -d ' ')\"\n\tfor container_name in ${container_names}; do\n\t\tif [ \"${delete}\" -ne 0 ]; then\n\t\t\t\"${0}\" \"${container_name}\" --delete\n\t\t\tcontinue\n\t\tfi\n\t\t\"${0}\" \"${container_name}\"\n\tdone\n\texit\nfi\n\n# If we delete, just ask confirmation and exit.\nif [ \"${delete}\" -ne 0 ]; then\n\trm -f \"${XDG_DATA_HOME:-${HOME}/.local/share}/applications/${container_name}.desktop\"\n\texit\nfi\n\nif ! command -v curl > /dev/null && ! command -v wget > /dev/null; then\n\tprintf >&2 \"Icon generation depends on either curl or wget\\n\"\n\tprintf >&2 \"Fallbacking to default icon.\\n\"\n\tdownload=\"null\"\nfi\n\nif command -v curl > /dev/null 2>&1; then\n\tdownload=\"curl --connect-timeout 3 --retry 1 -sLo\"\nelif command -v wget > /dev/null 2>&1; then\n\tdownload=\"wget --timeout=3 --tries=1 -qO\"\nfi\n\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\t\tcontainer_manager_cp_command=\"podman cp\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\t\tcontainer_manager_cp_command=\"podman-launcher cp\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\t\tcontainer_manager_cp_command=\"docker cp -L\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\t\tcontainer_manager_cp_command=\"lilipod cp\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\tcontainer_manager_cp_command=\"podman cp\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\tcontainer_manager_cp_command=\"podman-launcher cp\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\tcontainer_manager_cp_command=\"lilipod cp\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\tcontainer_manager_cp_command=\"docker cp -L\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman,  docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n\n# add verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\n\tcontainer_manager_cp_command=\"${container_manager_cp_command} --log-level debug\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\textra_flags=\"${extra_flags} --root\"\n\tcontainer_manager=\"${distrobox_sudo_program:-\"sudo\"} ${container_manager}\"\n\tcontainer_manager_cp_command=\"${distrobox_sudo_program:-\"sudo\"} ${container_manager_cp_command}\"\nfi\n\nif ! ${container_manager} inspect --type container \"${container_name}\" > /dev/null; then\n\tprintf >&2 \"Cannot find container %s. Please create it first.\\n\" \"${container_name}\"\n\texit 1\nfi\n\n# Ensure the destination dir exists.\nmkdir -p \"${XDG_DATA_HOME:-${HOME}/.local/share}/applications\"\nmkdir -p \"${XDG_DATA_HOME:-${HOME}/.local/share}/icons/distrobox\"\n\ndistrobox_path=\"$(dirname \"$(realpath \"${0}\")\")\"\nentry_name=\"$(echo \"${container_name}\" | cut -c1 | tr \"[:lower:]\" \"[:upper:]\")$(echo \"${container_name}\" | cut -c2-)\"\n\nif [ \"${icon}\" = \"auto\" ]; then\n\t# Set icon to the generic terminal as a fallback.\n\ticon=\"${icon_default}\"\n\t# This is a NON comprehensive list of logos of the most popular distributions. If you find logos for\n\t# other supported distros, add it here.\n\tDISTRO_ICON_MAP=\"\n\t\talma:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/alma-distrobox.png\n\t\talpine:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/alpine-distrobox.png\n\t\tarch:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/arch-distrobox.png\n\t\tcentos:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/centos-distrobox.png\n\t\tclear--os:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/clear-distrobox.png\n\t\tdebian:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/debian-distrobox.png\n\t\tdeepin:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/deepin-distrobox.png\n\t\tfedora:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/fedora-distrobox.png\n\t\tgentoo:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/gentoo-distrobox.png\n\t\tkali:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/kali-distrobox.png\n\t\tkdeneon:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/kdeneon-distrobox.png\n\t\topensuse-leap:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/opensuse-distrobox.png\n\t\topensuse-tumbleweed:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/opensuse-distrobox.png\n\t\trhel:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/redhat-distrobox.png\n\t\trocky:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/rocky-distrobox.png\n\t\tubuntu:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/ubuntu-distrobox.png\n\t\tvanilla:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/vanilla-distrobox.png\n\t\tvoid:https://raw.githubusercontent.com/89luca89/distrobox/main/docs/assets/png/distros/void-distrobox.png\n\t\"\n\t# Try to detect container's distribution by using /etc/os-release\n\t${container_manager_cp_command} \"${container_name}\":/etc/os-release /tmp/\"${container_name}\".os-release\n\tcontainer_distro=\"$(grep \"^ID=\" /tmp/\"${container_name}\".os-release |\n\t\tcut -d'=' -f2- |\n\t\tsed \"s|linux||g\" |\n\t\ttr -d ' ' |\n\t\ttr -d '\"')\"\n\n\tif [ \"${rootful}\" -ne 0 ]; then\n\t\t${distrobox_sudo_program:-\"sudo\"} rm -f /tmp/\"${container_name}\".os-release\n\telse\n\t\trm -f /tmp/\"${container_name}\".os-release\n\tfi\n\n\ticon_url=\"$(echo \"${DISTRO_ICON_MAP}\" | grep \"${container_distro}:\" | cut -d':' -f2-)\"\n\n\t# Distro not found in our map, fallback to generic icon\n\tif [ -z \"${icon_url}\" ]; then\n\t\ticon_url=\"https://raw.githubusercontent.com/89luca89/distrobox/main/icons/terminal-distrobox-icon.svg\"\n\t\tcontainer_distro=\"terminal-distrobox-icon\"\n\tfi\n\n\tif [ -n \"${icon_url}\" ] && [ \"${download}\" != \"null\" ]; then\n\t\ticon_extension=\"${icon_url##*.}\"\n\n\t\tif [ \"${online}\" -lt 1 ] && ${download} - \"${icon_url}\" > \"${XDG_DATA_HOME:-${HOME}/.local/share}/icons/distrobox/${container_distro}.${icon_extension}\"; then\n\t\t\ticon=\"${XDG_DATA_HOME:-${HOME}/.local/share}/icons/distrobox/${container_distro}.${icon_extension}\"\n\t\telse\n\t\t\t# Wget failed for some reasons. Default to generic terminal icon as declared at the beginning.\n\t\t\tprintf >&2 \"Warning: Failed to download icon. Defaulting to generic one.\\n\"\n\t\tfi\n\telse\n\t\t# Distribution not found in the list. Default to generic terminal icon as declared at the beginning.\n\t\tprintf >&2 \"Warning: Distribution not found in default icon set. Defaulting to generic one.\\n\"\n\tfi\nfi\n\ncat << EOF > \"${XDG_DATA_HOME:-${HOME}/.local/share}/applications/${container_name}.desktop\"\n[Desktop Entry]\nName=${entry_name}\nGenericName=Terminal entering ${entry_name}\nComment=Terminal entering ${entry_name}\nCategories=Distrobox;System;Utility\nExec=${distrobox_path}/distrobox enter ${extra_flags} ${container_name}\nIcon=${icon}\nKeywords=distrobox;\nNoDisplay=false\nTerminal=true\nTryExec=${distrobox_path}/distrobox\nType=Application\nActions=Remove;\n\n[Desktop Action Remove]\nName=Remove ${entry_name} from system\nExec=${distrobox_path}/distrobox rm ${extra_flags} ${container_name}\nEOF\n"
        },
        {
          "name": "distrobox-host-exec",
          "type": "blob",
          "size": 6.6533203125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2022 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# Defaults\nhost_command=\"\"\nnon_interactive=0\n# If we're in a non-interactive shell, let's act accordingly\nif [ ! -t 1 ] ||\n\t! tty > /dev/null 2>&1; then\n\tnon_interactive=1\nfi\ndistrobox_host_exec_default_command=\"${SHELL:-/bin/sh}\"\nhost_spawn_version=\"v1.6.0\"\ndownload_command=\"\"\nsudo_command=\"\"\nverbose=0\nversion=\"1.8.0\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-host-exec [command [arguments]]\n\tdistrobox-host-exec ls\n\tdistrobox-host-exec bash -l\n\tdistrobox-host-exec flatpak run org.mozilla.firefox\n\tdistrobox-host-exec podman ps -a\n\n\nOptions:\n\n\t--help/-h:\t\tshow this message\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\n\t--yes/-Y:\t\tAutomatically answer yes to prompt:\n                                host-spawn will be installed on the guest system\n                                if host-spawn is not detected.\n                                This behaviour is default when running in a non-interactive shell.\nEOF\n}\n\n# If we're a symlink to a command, use that as command to exec, and skip arg parsing.\nif [ \"$(basename \"${0}\")\" != \"distrobox-host-exec\" ]; then\n\thost_command=\"$(basename \"${0}\")\"\nfi\n# Parse arguments\nif [ -z \"${host_command}\" ]; then\n\t# Skip argument parsing if we're a symlink\n\twhile :; do\n\t\tcase $1 in\n\t\t\t-h | --help)\n\t\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\t\tshow_help\n\t\t\t\texit 0\n\t\t\t\t;;\n\t\t\t-v | --verbose)\n\t\t\t\tverbose=1\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t-V | --version)\n\t\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\t\tprintf \"host-spawn: %s\\n\" \"${host_spawn_version}\"\n\t\t\t\texit 0\n\t\t\t\t;;\n\t\t\t-Y | --yes)\n\t\t\t\tnon_interactive=1\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--) # End of all options.\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t-*) # Invalid options.\n\t\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\t\tshow_help\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\t\thost_command=$1\n\t\t\t\t\tshift\n\t\t\t\tfi\n\t\t\t\tbreak\n\t\t\t\t;;\n\t\tesac\n\tdone\nfi\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# Check we're running inside a container and not on the host\nif [ ! -f /run/.containerenv ] && [ ! -f /.dockerenv ] && [ -z \"${container:-}\" ]; then\n\tprintf >&2 \"You must run %s inside a container!\\n\" \" $(basename \"$0\")\"\n\texit 126\nfi\n\nif [ -z \"${host_command}\" ]; then\n\thost_command=\"${distrobox_host_exec_default_command}\"\nfi\n\nif [ \"$(id -ru)\" -ne 0 ]; then\n\tif command -v sudo 2> /dev/null > /dev/null; then\n\t\tsudo_command=\"sudo\"\n\telse\n\t\tsudo_command=\"su -l -c\"\n\tfi\nfi\n\nif  command -v curl > /dev/null 2>&1; then\n\tdownload_command=\"curl -sLo\"\nelif  command -v wget > /dev/null 2>&1; then\n\tdownload_command=\"wget -qO\"\nfi\n\n# Normalize architecture name to comply to golang/release naming\narchitecture=\"$(uname -m)\"\nif echo \"${architecture}\" | grep -q armv; then\n\tarchitecture=\"$(echo \"${architecture}\" | grep -Eo \"armv[0-9]+\")\"\nfi\n\n# Setup host-spawn as a way to execute commands back on the host\nif ! command -v host-spawn > /dev/null ||\n\t[ \"$(printf \"%s\\n%s\\n\" \"${host_spawn_version}\" \"$(host-spawn --version)\" |\n\t\tsort -V | head -n 1)\" != \"${host_spawn_version}\" ]; then\n\n\t# if non-interactive flag flag hasn't been set\n\tif [ \"${non_interactive}\" -eq 0 ]; then\n\t\t# Prompt to download it.\n\t\tprintf \"Warning: host-spawn not found or version is too old!\\n\"\n\t\tprintf \"Do you want to install host-spawn utility? [Y/n] \"\n\t\tread -r response\n\t\tresponse=${response:-\"Y\"}\n\telse\n\t\tresponse=\"yes\"\n\tfi\n\t# Accept only y,Y,Yes,yes,n,N,No,no.\n\tcase \"${response}\" in\n\t\ty | Y | Yes | yes | YES)\n\t\t\t# Download matching version with current distrobox\n\t\t\tif ! ${download_command} /tmp/host-spawn \\\n\t\t\t\t\"https://github.com/1player/host-spawn/releases/download/${host_spawn_version}/host-spawn-${architecture}\"; then\n\n\t\t\t\tprintf \"Error: Cannot download host-spawn\\n\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tif [ -e /tmp/host-spawn ]; then\n\t\t\t\t${sudo_command} sh -c \"mv /tmp/host-spawn /usr/bin/\"\n\t\t\t\t${sudo_command} sh -c \"chmod +x /usr/bin/host-spawn\"\n\t\t\tfi\n\t\t\t;;\n\t\tn | N | No | no | NO)\n\t\t\tprintf \"Installation aborted, please install host-spawn.\\n\"\n\t\t\texit 0\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tprintf >&2 \"Invalid input.\\n\"\n\t\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\nfi\n\n# This makes host-spawn work on initful containers, where the dbus session is\n# separate from the host, we point the dbus session straight to the host's socket\n# in order to talk with the org.freedesktop.Flatpak.Development.HostCommand on the host\n[ -z \"${XDG_RUNTIME_DIR:-}\" ] && XDG_RUNTIME_DIR=\"/run/user/$(id -ru)\"\n[ -z \"${DBUS_SESSION_BUS_ADDRESS:-}\" ] && DBUS_SESSION_BUS_ADDRESS=\"unix:path=/run/user/$(id -ru)/bus\"\nXDG_RUNTIME_DIR=\"/run/host/${XDG_RUNTIME_DIR}\"\nDBUS_SESSION_BUS_ADDRESS=\"unix:path=/run/host/$(echo \"${DBUS_SESSION_BUS_ADDRESS}\" | cut -d '=' -f2-)\"\n\n###\n# This workaround is needed because of a bug in gio (used by xdg-open) where\n# a race condition happens when allocating a pty, leading to the command\n# being killed before having time to be executed.\n#\n# https://gitlab.gnome.org/GNOME/glib/-/issues/2695\n# https://github.com/1player/host-spawn/issues/7\n#\n# As an (ugly) workaround, we will not allocate a pty for those commands.\n###\n# Also, we don't initialize a pty, if we're not in a tty.\nif [ \"$(basename \"${host_command}\")\" = \"xdg-open\" ] ||\n\t[ \"$(basename \"${host_command}\")\" = \"gio\" ] ||\n\t[ \"$(basename \"${host_command}\")\" = \"flatpak\" ] ||\n\t[ ! -t 1 ] ||\n\t! tty > /dev/null 2>&1; then\n\n\thost-spawn --no-pty \"${host_command}\" \"$@\"\n\t# Exit here, we don't continue execution\n\texit $?\nfi\n\nhost-spawn \"${host_command}\" \"$@\"\n# Exit here, we don't continue execution\nexit $?\n"
        },
        {
          "name": "distrobox-init",
          "type": "blob",
          "size": 77.693359375,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Expected env variables:\n#\tHOME\n#\tUSER\n#\tSHELL\n\ntrap '[ \"$?\" -ne 0 ] && printf \"Error: An error occurred\\n\"' EXIT\n\n# Redirect stderr to stdout as podman by default logs stderr as priority 3 journald errors.\n# Github issue: https://github.com/containers/podman/issues/20728\nexec 2>&1\n\n# We'll also bind mount READ-WRITE useful mountpoints to pass external drives and libvirt from\n# the host to the container\nHOST_MOUNTS=\"\n\t/etc/host.conf\n\t/etc/machine-id\n\t/media\n\t/mnt\n\t/run/libvirt\n\t/run/media\n\t/run/netconfig/\n\t/run/systemd/journal\n\t/run/systemd/resolve/\n\t/run/systemd/seats\n\t/run/systemd/sessions\n\t/run/systemd/users\n\t/run/udev\n\t/var/lib/libvirt\n\t/var/mnt\"\n\n# We'll also bind mount in READ-ONLY useful directories from the host\nHOST_MOUNTS_RO=\"\n\t/etc/localtime\n\t/var/lib/systemd/coredump\n\t/var/log/journal\"\n\nHOST_MOUNTS_RO_INIT=\"\n\t/etc/localtime\n\t/run/systemd/journal\n\t/run/systemd/resolve\n\t/run/systemd/seats\n\t/run/systemd/sessions\n\t/run/systemd/users\n\t/var/lib/systemd/coredump\n\t/var/log/journal\"\n\n# Defaults\ncontainer_additional_packages=\"\"\ninit=0\ninit_hook=\"\"\nnvidia=0\npre_init_hook=\"\"\nrootful=0\nupgrade=0\nverbose=0\nversion=\"1.8.0\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   USER\n#   HOME\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-init --name ${USER} --user $(id -ru) --group $(id -rg) --home ${HOME}\n\nOptions:\n\n\t--name/-n:\t\tuser name\n\t--user/-u:\t\tuid of the user\n\t--group/-g:\t\tgid of the user\n\t--home/-d:\t\tpath/to/home of the user\n\t--help/-h:\t\tshow this message\n\t--additional-packages:\tpackages to install in addition\n\t--init/-I:\t\twhether to use or not init\n\t--pre-init-hooks:\tcommands to execute prior to init\n\t--nvidia:\t\ttry to integrate host's nVidia drivers in the guest\n\t--upgrade/-U:\t\trun init in upgrade mode\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\n\t--:\t\t\tend arguments execute the rest as command to execute during init\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tshift\n\t\t\tverbose=1\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-U | --upgrade)\n\t\t\tshift\n\t\t\tupgrade=1\n\t\t\t;;\n\t\t-n | --name)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_user_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-i | --init)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tinit=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-d | --home)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_user_home=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-u | --user)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_user_uid=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-g | --group)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_user_gid=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--pre-init-hooks)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tpre_init_hook=\"$2\"\n\t\t\tfi\n\t\t\tshift\n\t\t\tshift\n\t\t\t;;\n\t\t--additional-packages)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tcontainer_additional_packages=\"$2\"\n\t\t\tfi\n\t\t\tshift\n\t\t\tshift\n\t\t\t;;\n\t\t--nvidia)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tnvidia=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tinit_hook=$*\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"Error: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tbreak ;;\n\tesac\ndone\n\n# Check we're running inside a container and not on the host\nif [ ! -f /run/.containerenv ] && [ ! -f /.dockerenv ] && [ -z \"${container:-}\" ]; then\n\tprintf >&2 \"You must run %s inside a container!\\n\" \" $(basename \"$0\")\"\n\tprintf >&2 \"distrobox-init should only be used as an entrypoint for a distrobox!\\n\\n\"\n\tprintf >&2 \"This is not intended to be used manually, but instead used by distrobox-enter\\n\"\n\tprintf >&2 \"to set up the container's entrypoint.\\n\"\n\texit 126\nfi\n\n# Ensure the foundamental variables are set and not empty, we will not proceed if\n# they are not all set.\nif [ \"${upgrade}\" -eq 0 ]; then\n\t[ -z \"${container_user_gid}\" ] && printf \"Error: Invalid arguments, missing user gid\\n\" && exit 2\n\t[ -z \"${container_user_home}\" ] && printf \"Error: Invalid argument, missing user home\\n\" && exit 2\n\t[ -z \"${container_user_name}\" ] && printf \"Error: Invalid arguments, missing username\\n\" && exit 2\n\t[ -z \"${container_user_uid}\" ] && printf \"Error: Invalid arguments, missing user uid\\n\" && exit 2\nfi\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# Determine if we're in a rootful container, generally if we're able to read\n# host's /etc/shadow, it means we're really root!\n#\n# if /run/.nopasswd is present, let's treat the init as rootless, this is not\n# a good thing, users behold!\nif stat /run/host/etc/shadow > /dev/null &&\n\t[ \"$(stat -c \"%u\" /run/host/etc/shadow)\" = \"0\" ] &&\n\t[ ! -e /run/.nopasswd ]; then\n\trootful=1\nfi\n\n# Get host $LANG\nif [ -f \"/run/host/etc/locale.conf\" ]; then\n\tHOST_LOCALE=$(grep -e '^LANG=' /run/host/etc/locale.conf | sed 's/LANG=//' | sed 's/\"//g')\n\tHOST_LOCALE_ENCODING=$(echo \"${HOST_LOCALE}\" | sed -n 's/^[^.]*\\.\\(.*\\)$/\\1/p')\n\tHOST_LOCALE_LANG=$(echo \"${HOST_LOCALE}\" | sed -n 's/^\\([^.]*\\)\\..*$/\\1/p')\nelif [ -f \"/run/host/etc/default/locale\" ]; then\n\tHOST_LOCALE=$(grep -e '^LANG=' /run/host/etc/default/locale | sed 's/LANG=//' | sed 's/\"//g')\n\tHOST_LOCALE_ENCODING=$(echo \"${HOST_LOCALE}\" | sed -n 's/^[^.]*\\.\\(.*\\)$/\\1/p')\n\tHOST_LOCALE_LANG=$(echo \"${HOST_LOCALE}\" | sed -n 's/^\\([^.]*\\)\\..*$/\\1/p')\nfi\n# Add fallback values in case host's locale is not set correctly\nif [ -z \"${HOST_LOCALE:-}\" ] || [ \"${HOST_LOCALE:-}\" = \"C.UTF-8\" ]; then\n\tHOST_LOCALE=\"en_US.UTF-8\"\n\tHOST_LOCALE_ENCODING=\"UTF-8\"\n\tHOST_LOCALE_LANG=\"en_US\"\nfi\n\n# get_locked_mount_flags will print mount flags considered \"locked\".\n# Arguments:\n# \tsrc: path to the file/directory\n# Expected env variables:\n#\tNone\n# Expected global variables:\n#\tNone\n# Outputs:\n# \tComma-separated list of locked mount flags\nget_locked_mount_flags()\n{\n\tsrc=\"$1\"\n\tprev=\"\"\n\tlocked_flags=\"\"\n\n\t# If findmnt does not exist, exit\n\tif ! command -v findmnt 2> /dev/null > /dev/null; then\n\t\treturn 0\n\tfi\n\n\t# If we can't read the file/directory, exit\n\tif ! ls \"${src}\" 2> /dev/null > /dev/null; then\n\t\treturn 0\n\tfi\n\n\t# Get mount flags of given file/directory, using nearest mountpoint.\n\t# Earlier versions of findmnt did not check parents until it found a mountpoint,\n\t# so we use a workaround with dirname.\n\twhile true; do\n\t\tflags=\"$(findmnt --noheadings --output OPTIONS --target \"${src}\" || :)\"\n\t\t# shellcheck disable=SC2181\n\t\tif [ -n \"${flags}\" ]; then\n\t\t\tbreak\n\t\tfi\n\t\tprev=\"${src}\"\n\t\tsrc=\"$(dirname \"${src}\")\"\n\t\t[ \"${src}\" = \"${prev}\" ] && return 1\n\tdone\n\n\tfor flag in nodev noexec nosuid; do\n\t\tif printf \"%s\" \"${flags}\" | grep -q \"${flag}\"; then\n\t\t\t# Locked flag found, append to list while avoiding leading/trailing commas\n\t\t\tlocked_flags=\"${locked_flags:+${locked_flags},}${flag}\"\n\t\tfi\n\tdone\n\n\tprintf \"%s\" \"${locked_flags}\"\n}\n\n# init_readlink is a simplistic implementation for\n# readlink -fm\n# we use this as readlink -fm does not work on\n# busybox systems, and we need the path even for broken links.\n# Arguments:\n#\tsource file\n# Expected env variables:\n#\tNone\n# Expected global variables:\n#\tNone\n# Outputs:\n#\toriginal path the link is pointing\ninit_readlink()\n{\n\t# shellcheck disable=SC2010\n\tls -l \"${1}\" | grep -Eo '\\->.*' | cut -d' ' -f2- | sed 's|\\.\\./|/|g'\n}\n\n# mount_bind will perform a bind mount for inputs or error\n# Arguments:\n#   source_dir: string what to mount\n#\ttarget_dir: string where to mount\n#\tmount_flags: list of mount flags -> optional\n# Expected env variables:\n#\tNone\n# Expected global variables:\n#\tNone\n# Outputs:\n#   No output if all ok\n#\tError if not\nmount_bind()\n{\n\tsource_dir=\"$1\"\n\ttarget_dir=\"$2\"\n\tmount_flags=\"\"\n\tif [ \"$#\" -gt 2 ]; then\n\t\tmount_flags=\"$3\"\n\tfi\n\n\t# Adjust source_dir in order to point to /run/host if it's a symlink\n\tif [ -L \"${source_dir}\" ]; then\n\t\tsource_dir=\"$(init_readlink \"${source_dir}\")\"\n\t\tif ! printf \"%s\" \"${source_dir}\" | grep -q \"/run/host\"; then\n\t\t\tsource_dir=\"/run/host${source_dir}\"\n\t\tfi\n\tfi\n\n\t# if source dir doesn't exist, just exit\n\tif [ ! -d \"${source_dir}\" ] && [ ! -f \"${source_dir}\" ]; then\n\t\treturn 0\n\tfi\n\n\t# if target_dir exists, check if it is a mountpoint and umount it.\n\tif [ -e \"${target_dir}\" ] && findmnt \"${target_dir}\" > /dev/null; then\n\t\tumount \"${target_dir}\"\n\tfi\n\n\t# if target_dir exists, and is a symlink, remove it\n\tif [ -L \"${target_dir}\" ]; then\n\t\trm -f \"${target_dir}\"\n\tfi\n\n\t# if the source_dir exists, then create the target_dir\n\tif [ -d \"${source_dir}\" ]; then\n\t\tif ! mkdir -p \"${target_dir}\"; then\n\t\t\tprintf \"Warning: cannot create mount target directory: %s\\n\" \"${target_dir}\"\n\t\t\treturn 1\n\t\tfi\n\t# if instead it's a file, create it with touch\n\telif [ -f \"${source_dir}\" ]; then\n\t\tif [ ! -d \"$(dirname \"${target_dir}\")\" ]; then\n\t\t\tmkdir -p \"$(dirname \"${target_dir}\")\"\n\t\tfi\n\t\t# if we encounter a broken link, and we touch it\n\t\t# then remove the broken link, the next touch\n\t\t# will cover it.\n\t\tif ! touch \"${target_dir}\"; then\n\t\t\tprintf \"Warning: cannot create mount target file: %s\\n\" \"${target_dir}\"\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\t# Add mountflags if needed, if no are specified, use rslave as default.\n\t# bind mount source_dir to target_dir, return error if not successful\n\tif [ \"${mount_flags}\" = \"\" ]; then\n\t\tif ! mount --rbind \"${source_dir}\" \"${target_dir}\"; then\n\t\t\tprintf \"Warning: failed to bind mount %s to %s\\n\" \"${source_dir}\" \"${target_dir}\"\n\t\t\treturn 1\n\t\tfi\n\t\tif ! mount --make-rslave \"${target_dir}\"; then\n\t\t\tprintf \"Warning: failed to make rslave to %s\\n\" \"${target_dir}\"\n\t\t\treturn 1\n\t\tfi\n\telif ! mount --rbind -o \"${mount_flags}\" \"${source_dir}\" \"${target_dir}\"; then\n\t\tprintf \"Warning: failed to bind mount %s to %s using option %s\\n\" \"${source_dir}\" \"${target_dir}\" \"${mount_flags}\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nif [ -n \"${pre_init_hook}\" ]; then\n\tprintf \"distrobox: Executing pre-init hooks...\\n\"\n\t# execute pre-init hooks if specified\n\t# shellcheck disable=SC2086\n\teval ${pre_init_hook}\nfi\n\n###############################################################################\nprintf \"distrobox: Installing basic packages...\\n\"\n# Extract shell name from the $SHELL environment variable\n# If not present as package in the container, we want to install it.\nshell_pkg=\"$(basename \"${SHELL:-\"bash\"}\")\"\n# Ash shell is an exception, it is not a standalone package, but part of busybox.\n# for this reason, use this quirk to adjust the package name to standard bash.\nif [ \"${shell_pkg}\" = \"ash\" ]; then\n\tshell_pkg=\"bash\"\nfi\n\n# setup_pkg_manager_hooks will create umount/remount hooks script for a package\n# manager. Mainly used by apt and pacman.\n# Arguments:\n#   None\n# Expected global variables:\n#   init: if this is an initful container\n#   HOST_MOUNTS_RO_INIT: list of mountpoints of an initful system, to avoid\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_pkg_manager_hooks()\n{\n\tif {\n\t\t[ -d \"/etc/dpkg/dpkg.cfg.d/\" ] || [ -d \"/usr/share/libalpm/scripts\" ]\n\t} && [ \"${init}\" -eq 0 ]; then\n\t\tcat << EOF > /etc/distrobox-pre-hook.sh\n#!/bin/sh\nmounts=\"${HOST_MOUNTS_RO_INIT}\"\nfor mount in \\$mounts; do\n\tif findmnt \\$mount >/dev/null; then\n\t\tumount -l \\$mount\n\tfi\ndone\nEOF\n\t\tcat << EOF > /etc/distrobox-post-hook.sh\n#!/bin/sh\nmounts=\"${HOST_MOUNTS_RO_INIT}\"\nfor mount in \\$mounts; do\n\tif [ -e /run/host/\\$mount ] || [ -e /run/host/\\$(readlink -fm /run/host/\\$mount) ]; then\n\t\tif [ ! -d /run/host/\\$mount ]; then\n\t\t\trm -f \\$mount && touch \\$mount\n\t\tfi\n\t\tif ! mount --rbind \\$(readlink -fm /run/host/\\$mount) \\$mount; then\n\t\t\tmount --rbind /run/host/\\$(readlink -fm /run/host/\\$mount) \\$mount\n\t\tfi\n\tfi\ndone\nEOF\n\t\tchmod +x /etc/distrobox-pre-hook.sh /etc/distrobox-post-hook.sh\n\tfi\n}\n\n# setup_deb_exceptions will create path-excludes for host mounts, dpkg/apt only.\n# Arguments:\n#   None\n# Expected global variables:\n#   init: if this is an initful container\n#   HOST_MOUNTS_RO: list of readonly mountpoints, to avoid\n#   HOST_MOUNTS: list of readwrite mountpoints, to avoid\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_deb_exceptions()\n{\n\tsetup_pkg_manager_hooks\n\n\t# In case of an DEB distro, we can specify that our bind_mount directories\n\t# have to be ignored. This prevents conflicts during package installations.\n\tif [ \"${init}\" -eq 0 ]; then\n\t\t# Loop through all the environment vars\n\t\t# and export them to the container.\n\t\tmkdir -p /etc/dpkg/dpkg.cfg.d/\n\t\tprintf \"\" > /etc/dpkg/dpkg.cfg.d/00_distrobox\n\t\tfor net_mount in ${HOST_MOUNTS_RO} ${HOST_MOUNTS}; do\n\t\t\tprintf \"path-exclude %s/*\\n\" \"${net_mount}\" >> /etc/dpkg/dpkg.cfg.d/00_distrobox\n\t\tdone\n\n\t\t# Also we put a hook to clear some critical paths that do not play well\n\t\t# with read only filesystems, like Systemd.\n\t\tif [ -d \"/etc/apt/apt.conf.d/\" ]; then\n\t\t\tprintf 'DPkg::Pre-Invoke {/etc/distrobox-pre-hook.sh};\\n' > /etc/apt/apt.conf.d/00_distrobox\n\t\t\tprintf 'DPkg::Post-Invoke {/etc/distrobox-post-hook.sh};\\n' >> /etc/apt/apt.conf.d/00_distrobox\n\t\tfi\n\tfi\n}\n\n# setup_pacman_exceptions will set pre/post transaction hooks to avoid host's mounts, pacman only.\n# Arguments:\n#   None\n# Expected global variables:\n#   init: if this is an initful container\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_pacman_exceptions()\n{\n\tsetup_pkg_manager_hooks\n\n\t# Workarounds for pacman. We need to exclude the paths by using a pre-hook to umount them and a\n\t# post-hook to remount them. Additionally we neutralize the systemd-post-hooks as they do not\n\t# work on a rootless container system.\n\tif [ -d \"/usr/share/libalpm/scripts\" ] && [ \"${init}\" -eq 0 ]; then\n\t\t# in case we're not using an init image, neutralize systemd post installation hooks\n\t\t# so that we do not encounter problems along the way.\n\t\t# This will be removed if we're using --init.\n\t\tcat << EOF > /usr/share/libalpm/scripts/distrobox_post_hook.sh\n#!/bin/sh\necho -e '#!/bin/sh\\nexit 0' > /usr/share/libalpm/scripts/systemd-hook;\nEOF\n\t\tchmod +x /usr/share/libalpm/scripts/distrobox_post_hook.sh\n\n\t\t# create hooks files for them\n\t\tfind /usr/share/libalpm/hooks/*distrobox* -delete || :\n\t\tfor hook in /etc/distrobox-pre-hook.sh /etc/distrobox-post-hook.sh /usr/share/libalpm/scripts/distrobox_post_hook.sh; do\n\t\t\twhen=\"PostTransaction\"\n\t\t\t[ -z \"${hook##*pre*}\" ] && when=\"PreTransaction\"\n\t\t\tcat << EOF > \"/usr/share/libalpm/hooks/$(basename \"${hook}\").hook\"\n[Trigger]\nOperation = Install\nOperation = Upgrade\nType = Package\nTarget = *\n[Action]\nDescription = Distrobox hook ${hook}...\nWhen = ${when}\nExec = ${hook}\nEOF\n\t\tdone\n\tfi\n\n}\n\n# setup_rpm_exceptions will create path-excludes for host mounts, rpm only (dnf, yum, zypper, microdnf).\n# Arguments:\n#   None\n# Expected global variables:\n#   init: if this is an initful container\n#   HOST_MOUNTS_RO: list of readonly mountpoints, to avoid\n#   HOST_MOUNTS: list of readwrite mountpoints, to avoid\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_rpm_exceptions()\n{\n\t# In case of an RPM distro, we can specify that our bind_mount directories\n\t# are in fact net shares. This prevents conflicts during package installations.\n\tif [ \"${init}\" -eq 0 ]; then\n\t\tmkdir -p /usr/lib/rpm/macros.d/\n\t\t# Loop through all the environment vars\n\t\t# and export them to the container.\n\t\tnet_mounts=\"\"\n\t\tfor net_mount in \\\n\t\t\t${HOST_MOUNTS_RO} ${HOST_MOUNTS} \\\n\t\t\t'/dev' '/proc' '/sys' '/tmp' \\\n\t\t\t'/etc/hosts' '/etc/resolv.conf' '/etc/passwd' '/etc/shadow'; do\n\n\t\t\tnet_mounts=\"${net_mount}:${net_mounts}\"\n\t\tdone\n\t\tnet_mounts=${net_mounts%?}\n\t\tcat << EOF > /usr/lib/rpm/macros.d/macros.distrobox\n%_netsharedpath ${net_mounts}\nEOF\n\tfi\n}\n\n# setup_xbps_exceptions will create path-excludes for host mounts, xbps only.\n# Arguments:\n#   None\n# Expected global variables:\n#   None\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_xbps_exceptions()\n{\n\t# We have to lock this paths from xbps extraction, as it's incompatible with distrobox's\n\t# mount process.\n\tcat << EOF > /etc/xbps.d/distrobox-ignore.conf\nnoextract=/etc/passwd\nnoextract=/etc/hosts\nnoextract=/etc/host.conf\nnoextract=/etc/hostname\nnoextract=/etc/localtime\nnoextract=/etc/machine-id\nnoextract=/etc/resolv.conf\nEOF\n}\n\n# setup_apk will upgrade or setup all packages for apk based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_apk()\n{\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tapk update\n\t\tapk upgrade\n\t\texit\n\tfi\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! apk add \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tif apk add wolfi-base; then\n\t\tdeps=\"\n\t\t\tbusybox\n\t\t\tgnutar\n\t\t\tman-db\n\t\t\tmesa\n\t\t\topenssh-client\n\t\t\tposix-libc-utils\n\t\t\"\n\telif apk add alpine-base; then\n\t\tdeps=\"\n\t\t\tbash-completion\n\t\t\tdocs\n\t\t\tgcompat\n\t\t\tlibc-utils\n\t\t\tlsof\n\t\t\tman-pages\n\t\t\tmandoc\n\t\t\tmusl-utils\n\t\t\topenssh-client-default\n\t\t\tpinentry\n\t\t\ttar\n\t\t\tvte3\n\t\t\twhich\n\t\t\t$(apk search -q mesa-dri)\n\t\t\t$(apk search -q mesa-vulkan)\n\t\t\"\n\tfi\n\tdeps=\"${deps:-}\n\t\t${shell_pkg}\n\t\tbash\n\t\tbc\n\t\tbzip2\n\t\tcoreutils\n\t\tcurl\n\t\tdiffutils\n\t\tfindmnt\n\t\tfindutils\n\t\tgnupg\n\t\tgpg\n\t\tiproute2\n\t\tiputils\n\t\tkeyutils\n\t\tless\n\t\tlibcap\n\t\tmount\n\t\tncurses\n\t\tncurses-terminfo\n\t\tnet-tools\n\t\tpigz\n\t\trsync\n\t\tshadow\n\t\tsudo\n\t\ttcpdump\n\t\ttree\n\t\ttzdata\n\t\tumount\n\t\tunzip\n\t\tutil-linux\n\t\tutil-linux-login\n\t\tutil-linux-misc\n\t\tvulkan-loader\n\t\twget\n\t\txauth\n\t\txz\n\t\tzip\n\t\t$(apk search -qe procps)\n\t\"\n\t# shellcheck disable=SC2086\n\tfound_deps=\"$(apk search -qe ${deps} | tr '\\n' ' ')\"\n\tinstall_pkg=\"\"\n\tfor dep in ${deps}; do\n\t\t# shellcheck disable=SC2249\n\t\tcase \" ${found_deps} \" in\n\t\t\t*\" ${dep} \"*)\n\t\t\t\tinstall_pkg=\"${install_pkg} ${dep}\"\n\t\t\t\t;;\n\t\tesac\n\tdone\n\t# shellcheck disable=SC2086\n\tapk add --force-overwrite ${install_pkg}\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\tapk del tzdata\n\t\tapk add tzdata\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tapk add --force-overwrite ${container_additional_packages}\n\tfi\n}\n\n# setup_apt will upgrade or setup all packages for apt based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_apt()\n{\n\texport DEBIAN_FRONTEND=noninteractive\n\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tapt-get update\n\t\tapt-get upgrade -o Dpkg::Options::=\"--force-confold\" -y\n\t\texit\n\tfi\n\t# In Ubuntu official images, dpkg is configured to ignore locale and docs\n\t# This however, results in a rather poor out-of-the-box experience\n\t# So, let's enable them.\n\trm -f /etc/dpkg/dpkg.cfg.d/excludes\n\n\tapt-get update\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! apt-get install -y \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tapt-utils\n\t\tbash-completion\n\t\tbc\n\t\tbzip2\n\t\tcurl\n\t\tdialog\n\t\tdiffutils\n\t\tfindutils\n\t\tgnupg\n\t\tgnupg2\n\t\tgpgsm\n\t\thostname\n\t\tiproute2\n\t\tiputils-ping\n\t\tkeyutils\n\t\tlanguage-pack-en\n\t\tless\n\t\tlibcap2-bin\n\t\tlibkrb5-3\n\t\tlibnss-mdns\n\t\tlibnss-myhostname\n\t\tlibvte-2.9*-common\n\t\tlibvte-common\n\t\tlocales\n\t\tlsof\n\t\tman-db\n\t\tmanpages\n\t\tmtr\n\t\tncurses-base\n\t\topenssh-client\n\t\tpasswd\n\t\tpigz\n\t\tpinentry-curses\n\t\tprocps\n\t\trsync\n\t\tsudo\n\t\ttcpdump\n\t\ttime\n\t\ttraceroute\n\t\ttree\n\t\ttzdata\n\t\tunzip\n\t\tutil-linux\n\t\twget\n\t\txauth\n\t\txz-utils\n\t\tzip\n\t\tlibgl1\n\t\tlibegl-mesa0\n\t\tlibegl1-mesa\n\t\tlibgl1-mesa-glx\n\t\tlibegl1\n\t\tlibglx-mesa0\n\t\tlibvulkan1\n\t\tmesa-vulkan-drivers\n\t\"\n\t# shellcheck disable=SC2086,2046\n\tapt-get install -y $(apt-cache show ${deps} 2> /dev/null | grep \"Package:\" | sort -u | cut -d' ' -f2-)\n\n\t# Setup hooks\n\tsetup_deb_exceptions\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif [ -e /etc/locale.gen ] && {\n\t\t! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"\n\t}; then\n\t\tsed -i \"s|#.*en_US.UTF-8|en_US.UTF-8|g\" /etc/locale.gen\n\t\tsed -i \"s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g\" /etc/locale.gen\n\t\tlocale-gen\n\t\tupdate-locale LC_ALL=\"${HOST_LOCALE}\" LANG=\"${HOST_LOCALE}\"\n\t\tdpkg-reconfigure locales\n\tfi\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\tapt-get --reinstall install tzdata\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tapt-get install -y ${container_additional_packages}\n\tfi\n}\n\n# setup_dnf will upgrade or setup all packages for dnf/yum based systems.\n# Arguments:\n#   manager: yum or dnf\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_dnf()\n{\n\tsetup_rpm_exceptions\n\n\tmanager=$1\n\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\t${manager} upgrade -y\n\t\texit\n\tfi\n\t# In dnf family official images, dnf is configured to ignore locale and docs\n\t# This however, results in a rather poor out-of-the-box experience\n\t# So, let's enable them.\n\t[ -e /etc/dnf/dnf.conf ] && sed -i '/tsflags=nodocs/d' /etc/dnf/dnf.conf\n\t[ -e /etc/yum.conf ] && sed -i '/tsflags=nodocs/d' /etc/yum.conf\n\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! ${manager} install -y \"${shell_pkg}\" 2> /dev/null; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tflags=\"\"\n\tif [ \"${manager}\" = \"dnf\" ]; then\n\t\tflags=\"--allowerasing\"\n\tfi\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tbash-completion\n\t\tbc\n\t\tbzip2\n\t\tcracklib-dicts\n\t\tcurl\n\t\tdiffutils\n\t\tdnf-plugins-core\n\t\tfindutils\n\t\tglibc-all-langpacks\n\t\tglibc-common\n\t\tglibc-locale-source\n\t\tgnupg2\n\t\tgnupg2-smime\n\t\thostname\n\t\tiproute\n\t\tiputils\n\t\tkeyutils\n\t\tkrb5-libs\n\t\tless\n\t\tlsof\n\t\tman-db\n\t\tman-pages\n\t\tmtr\n\t\tncurses\n\t\tnss-mdns\n\t\topenssh-clients\n\t\tpam\n\t\tpasswd\n\t\tpigz\n\t\tpinentry\n\t\tprocps-ng\n\t\trsync\n\t\tshadow-utils\n\t\tsudo\n\t\ttcpdump\n\t\ttime\n\t\ttraceroute\n\t\ttree\n\t\ttzdata\n\t\tunzip\n\t\tutil-linux\n\t\tvte-profile\n\t\twget\n\t\twhich\n\t\twhois\n\t\twords\n\t\txorg-x11-xauth\n\t\txz\n\t\tzip\n\t\tmesa-dri-drivers\n\t\tmesa-vulkan-drivers\n\t\tvulkan\n\t\"\n\t# shellcheck disable=SC2086,2046,2248\n\t${manager} install ${flags} -y $(${manager} list -q ${deps} |\n\t\tgrep -v \"Packages\" |\n\t\tgrep \"$(uname -m)\" |\n\t\tcut -d' ' -f1)\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif [ ! -e /usr/share/i18n/charmaps ]; then\n\t\t${manager} reinstall -y glibc-common\n\tfi\n\tif ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"; then\n\t\tLANG=\"${HOST_LOCALE}\" localedef -i \"${HOST_LOCALE_LANG}\" -f \"${HOST_LOCALE_ENCODING}\" \"${HOST_LOCALE}\"\n\tfi\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\t${manager} reinstall -y tzdata\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\t${manager} install -y ${container_additional_packages}\n\tfi\n}\n\n# setup_emerge will upgrade or setup all packages for gentoo based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_emerge()\n{\n\t# Check if the container we are using has a ::gentoo repo defined,\n\t# if it is defined and it is empty, then synchroznize it.\n\tgentoo_repo=\"$(portageq get_repo_path / gentoo)\"\n\tif [ -n \"${gentoo_repo}\" ] && [ ! -e \"${gentoo_repo}\" ]; then\n\t\temerge-webrsync\n\tfi\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\temerge --sync\n\t\texit\n\tfi\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! emerge --ask=n --autounmask-continue --noreplace --quiet-build \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tdeps=\"\n\t\tapp-shells/${shell_pkg}\n\t\tapp-crypt/gnupg\n\t\tapp-shells/bash-completion\n\t\tsys-apps/diffutils\n\t\tsys-apps/findutils\n\t\tsys-apps/less\n\t\tsys-libs/ncurses\n\t\tnet-misc/curl\n\t\tapp-crypt/pinentry\n\t\tsys-process/procps\n\t\tsys-apps/shadow\n\t\tapp-admin/sudo\n\t\tsys-devel/bc\n\t\tsys-process/lsof\n\t\tsys-apps/util-linux\n\t\tnet-misc/wget\n\t\"\n\tinstall_pkg=\"\"\n\tfor dep in ${deps}; do\n\t\tif [ \"$(emerge --ask=n --search \"${dep}\" | grep \"Applications found\" | grep -Eo \"[0-9]\")\" -gt 0 ]; then\n\t\t\t# shellcheck disable=SC2086\n\t\t\tinstall_pkg=\"${install_pkg} ${dep}\"\n\t\tfi\n\tdone\n\t# shellcheck disable=SC2086\n\temerge --ask=n --autounmask-continue --noreplace --quiet-build ${install_pkg}\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"; then\n\t\tsed -i \"s|#.*en_US.UTF-8|en_US.UTF-8|g\" /etc/locale.gen\n\t\tsed -i \"s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g\" /etc/locale.gen\n\t\tlocale-gen\n\t\tcat << EOF > /etc/env.d/02locale\nLANG=${HOST_LOCALE}\nLC_CTYPE=${HOST_LOCALE}\nEOF\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\temerge --ask=n --autounmask-continue --noreplace --quiet-build \\\n\t\t\t${container_additional_packages}\n\tfi\n}\n\n# setup_microdnf will upgrade or setup all packages for microdnf based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_microdnf()\n{\n\tsetup_rpm_exceptions\n\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tmicrodnf upgrade -y\n\t\texit\n\tfi\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! microdnf install -y \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tbash-completion\n\t\tbc\n\t\tbzip2\n\t\tcracklib-dicts\n\t\tdiffutils\n\t\tdnf-plugins-core\n\t\tfindutils\n\t\tglibc-all-langpacks\n\t\tglibc-common\n\t\tglibc-locale-source\n\t\tgnupg2\n\t\tgnupg2-smime\n\t\thostname\n\t\tiproute\n\t\tiputils\n\t\tkeyutils\n\t\tkrb5-libs\n\t\tless\n\t\tlsof\n\t\tman-db\n\t\tman-pages\n\t\tmtr\n\t\tncurses\n\t\tnss-mdns\n\t\topenssh-clients\n\t\tpam\n\t\tpasswd\n\t\tpigz\n\t\tpinentry\n\t\tprocps-ng\n\t\trsync\n\t\tshadow-utils\n\t\tsudo\n\t\ttcpdump\n\t\ttime\n\t\ttraceroute\n\t\ttree\n\t\ttzdata\n\t\tunzip\n\t\tutil-linux\n\t\tvte-profile\n\t\twget\n\t\twhich\n\t\twhois\n\t\twords\n\t\txorg-x11-xauth\n\t\txz\n\t\tzip\n\t\tmesa-dri-drivers\n\t\tmesa-vulkan-drivers\n\t\tvulkan\n\t\"\n\tinstall_pkg=\"\"\n\tfor dep in ${deps}; do\n\t\tif [ \"$(microdnf repoquery \"${dep}\" | wc -l)\" -gt 0 ]; then\n\t\t\tinstall_pkg=\"${install_pkg} ${dep}\"\n\t\tfi\n\tdone\n\t# shellcheck disable=SC2086,SC2046\n\tmicrodnf install -y ${install_pkg}\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\tmicrodnf reinstall -y tzdata || microdnf install -y glibc-common\n\tfi\n\tif ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"; then\n\t\tLANG=\"${HOST_LOCALE}\" localedef -i \"${HOST_LOCALE_LANG}\" -f \"${HOST_LOCALE_ENCODING}\" \"${HOST_LOCALE}\"\n\tfi\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\tmicrodnf reinstall -y tzdata || microdnf install -y tzdata\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tmicrodnf install -y ${container_additional_packages}\n\tfi\n}\n\n# setup_pacman will upgrade or setup all packages for pacman based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_pacman()\n{\n\t# Update the package repository cache exactly once before installing packages.\n\tpacman -S -y -y\n\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tpacman -S -u --noconfirm\n\t\texit\n\tfi\n\t# In archlinux official images, pacman is configured to ignore locale and docs\n\t# This however, results in a rather poor out-of-the-box experience\n\t# So, let's enable them.\n\tsed -i \"s|NoExtract.*||g\" /etc/pacman.conf\n\tsed -i \"s|NoProgressBar.*||g\" /etc/pacman.conf\n\n\tpacman -S -u --noconfirm\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! pacman -S --needed --noconfirm \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tbash-completion\n\t\tbc\n\t\tcurl\n\t\tdiffutils\n\t\tfindutils\n\t\tglibc\n\t\tgnupg\n\t\tiputils\n\t\tinetutils\n\t\tkeyutils\n\t\tless\n\t\tlsof\n\t\tman-db\n\t\tman-pages\n\t\tmlocate\n\t\tmtr\n\t\tncurses\n\t\tnss-mdns\n\t\topenssh\n\t\tpigz\n\t\tpinentry\n\t\tprocps-ng\n\t\trsync\n\t\tshadow\n\t\tsudo\n\t\ttcpdump\n\t\ttime\n\t\ttraceroute\n\t\ttree\n\t\ttzdata\n\t\tunzip\n\t\tutil-linux\n\t\tutil-linux-libs\n\t\tvte-common\n\t\twget\n\t\twords\n\t\txorg-xauth\n\t\tzip\n\t\tmesa\n\t\tvulkan-intel\n\t\tvulkan-radeon\n\t\"\n\t# shellcheck disable=SC2086,2046\n\tpacman -S --needed --noconfirm $(pacman -Ssq | grep -E \"^($(echo ${deps} | tr ' ' '|'))$\")\n\n\tif [ ! -e \"/usr/share/i18n/locales${HOST_LOCALE}\" ]; then\n\t\tpacman -S --noconfirm glibc glibc-locales\n\tfi\n\n\t# Setup hooks\n\tsetup_pacman_exceptions\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\tpacman -S --noconfirm tzdata\n\tfi\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"; then\n\t\tsed -i \"s|#.*en_US.UTF-8|en_US.UTF-8|g\" /etc/locale.gen\n\t\tsed -i \"s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g\" /etc/locale.gen\n\t\tlocale-gen -a\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tpacman -S --needed --noconfirm ${container_additional_packages}\n\tfi\n}\n\n# setup_slackpkg will upgrade or setup all packages for slackware based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_slackpkg()\n{\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tyes | slackpkg upgrade-all -default_answer=yes -batch=yes\n\t\texit\n\tfi\n\tslackpkg update\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! yes | slackpkg install -default_answer=yes -batch=yes \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tbash-completion\n\t\tbc\n\t\tcurl\n\t\tdiffutils\n\t\tfindutils\n\t\tglew\n\t\tglibc\n\t\tglu\n\t\tgnupg2\n\t\tiputils\n\t\tless\n\t\tlibX11\n\t\tlibXau\n\t\tlibXdamage\n\t\tlibXdmcp\n\t\tlibXext\n\t\tlibXfixes\n\t\tlibXxf86vm\n\t\tlibdrm\n\t\tlibvte-2\n\t\tlibxcb\n\t\tlibxcb-dri2\n\t\tlibxcb-dri3\n\t\tlibxcb-glx\n\t\tlibxcb-present\n\t\tlibxcb-randr\n\t\tlibxcb-render\n\t\tlibxcb-shape\n\t\tlibxcb-sync\n\t\tlibxcb-xfixes\n\t\tlibxshmfence\n\t\tlsof\n\t\tman\n\t\tmesa\n\t\tncurses\n\t\topenssh\n\t\tpinentry\n\t\tprocps\n\t\trsync\n\t\tshadow\n\t\tssh\n\t\tsudo\n\t\ttime\n\t\twget\n\t\txauth\n\t\"\n\tinstall_pkg=\"\"\n\tdep=\"\"\n\tfor dep in ${deps}; do\n\t\tif ! slackpkg search \"${dep}\" | grep -q \"No package name matches the pattern\"; then\n\t\t\tinstall_pkg=\"${install_pkg} ${dep}\"\n\t\tfi\n\tdone\n\n\trm -f /var/lock/slackpkg.*\n\n\t# shellcheck disable=SC2086\n\tyes | slackpkg install -default_answer=yes -batch=yes ${install_pkg}\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tyes | slackpkg install -default_answer=yes -batch=yes \\\n\t\t\t${container_additional_packages}\n\tfi\n}\n\n# setup_swupd will upgrade or setup all packages for clearlinux based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_swupd()\n{\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tswupd update\n\t\texit\n\tfi\n\n\tswupd bundle-add os-core-search\n\n\tdeps=\"\n\t\tbc\n\t\tcryptography\n\t\tcurl\n\t\tnetwork-basic\n\t\tprocps-ng\n\t\trsync\n\t\tshells\n\t\tsysadmin-basic\n\t\tunzip\n\t\twget\n\t\tx11-tools\n\t\tzip\n\t\tdevpkg-Vulkan-Loader\n\t\tlib-opengl\n\t\"\n\tinstall_pkg=\"\"\n\tfor dep in ${deps}; do\n\t\tif swupd search \"${dep}\" > /dev/null; then\n\t\t\tinstall_pkg=\"${install_pkg} ${dep}\"\n\t\tfi\n\tdone\n\t# shellcheck disable=SC2086\n\tswupd bundle-add ${install_pkg}\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tswupd bundle-add ${container_additional_packages}\n\tfi\n}\n\n# setup_xbps will upgrade or setup all packages for xbps based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_xbps()\n{\n\tsetup_xbps_exceptions\n\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\txbps-install -Syu\n\t\texit\n\tfi\n\t# Ensure we avoid errors by keeping xbps updated\n\txbps-install -Syu xbps\n\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tif ! xbps-install -Sy \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tbash-completion\n\t\tbc\n\t\tbzip2\n\t\tcurl\n\t\tdiffutils\n\t\tfindutils\n\t\tgnupg2\n\t\tinetutils-ping\n\t\tiproute2\n\t\tless\n\t\tlsof\n\t\tman-db\n\t\tmit-krb5-client\n\t\tmit-krb5-libs\n\t\tmtr\n\t\tncurses-base\n\t\tnss\n\t\topenssh\n\t\tpigz\n\t\tpinentry-tty\n\t\tprocps-ng\n\t\trsync\n\t\tshadow\n\t\tsudo\n\t\ttime\n\t\ttraceroute\n\t\ttree\n\t\ttzdata\n\t\tunzip\n\t\tutil-linux\n\t\txauth\n\t\txz\n\t\tzip\n\t\twget\n\t\tvte3\n\t\tmesa-dri\n\t\tvulkan-loader\n\t\tmesa-vulkan-intel\n\t\tmesa-vulkan-radeon\n\t\"\n\t# shellcheck disable=SC2086,2046\n\txbps-install -Sy $(xbps-query -Rs '*' | awk '{print $2}' | sed 's/-[^-]*$//' | grep -E \"^($(echo ${deps} | tr ' ' '|'))$\")\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif command -v locale && {\n\t\t! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"\n\t}; then\n\t\tsed -i \"s|#.*en_US.UTF-8|en_US.UTF-8|g\" /etc/default/libc-locales\n\t\tsed -i \"s|#.*${HOST_LOCALE}|${HOST_LOCALE}|g\" /etc/default/libc-locales\n\t\txbps-reconfigure --force glibc-locales\n\tfi\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\txbps-install --force -y tzdata\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\txbps-install -Sy ${container_additional_packages}\n\tfi\n}\n\n# setup_zypper will upgrade or setup all packages for zypper based systems.\n# Arguments:\n#   None\n# Expected global variables:\n#   upgrade: if we need to upgrade or not\n#   container_additional_packages: additional packages to install during this phase\n# Expected env variables:\n#   None\n# Outputs:\n#   None\nsetup_zypper()\n{\n\tsetup_rpm_exceptions\n\n\t# If we need to upgrade, do it and exit, no further action required.\n\tif [ \"${upgrade}\" -ne 0 ]; then\n\t\tzypper dup -y\n\t\texit\n\tfi\n\tif ! zypper install -y \"${shell_pkg}\"; then\n\t\tshell_pkg=\"bash\"\n\tfi\n\n\t# In openSUSE official images, zypper is configured to ignore recommended\n\t# packages (i.e., weak dependencies). This however, results in a rather\n\t# poor out-of-the-box experience (e.g., when trying to run GUI apps).\n\t# So, let's enable them. For the same reason, we make sure we install\n\t# docs.\n\tsed -i 's/.*solver.onlyRequires.*/solver.onlyRequires = false/g' /etc/zypp/zypp.conf\n\tsed -i 's/.*rpm.install.excludedocs.*/rpm.install.excludedocs = no/g' /etc/zypp/zypp.conf\n\t# With recommended packages, something might try to pull in\n\t# parallel-printer-support which can't be installed in rootless containers.\n\t# Since we very much likely never need it, just lock it\n\tzypper al parallel-printer-support\n\t# Check if shell_pkg is available in distro's repo. If not we\n\t# fall back to bash, and we set the SHELL variable to bash so\n\t# that it is set up correctly for the user.\n\tdeps=\"\n\t\t${shell_pkg}\n\t\tbash-completion\n\t\tbc\n\t\tbzip2\n\t\tcurl\n\t\tdiffutils\n\t\tfindutils\n\t\tglibc-locale\n\t\tglibc-locale-base\n\t\tgnupg\n\t\thostname\n\t\tiputils\n\t\tkeyutils\n\t\tless\n\t\tlibvte-2*\n\t\tlsof\n\t\tman\n\t\tman-pages\n\t\tmtr\n\t\tncurses\n\t\tnss-mdns\n\t\topenssh-clients\n\t\tpam\n\t\tpam-extra\n\t\tpigz\n\t\tpinentry\n\t\tprocps\n\t\trsync\n\t\tshadow\n\t\tsudo\n\t\tsystem-group-wheel\n\t\tsystemd\n\t\ttime\n\t\ttimezone\n\t\ttree\n\t\tunzip\n\t\tutil-linux\n\t\tutil-linux-systemd\n\t\twget\n\t\twords\n\t\txauth\n\t\tzip\n\t\tMesa-dri\n\t\tlibvulkan1\n\t\tlibvulkan_intel\n\t\tlibvulkan_radeon\n\t\"\n\t# Mark gpg errors (exit code 106) as non-fatal, but don't pull anything from unverified repos\n\t# shellcheck disable=SC2086,SC2046\n\tzypper -n install -y $(zypper -n -q se --match-exact ${deps} | grep -e 'package$' | cut -d'|' -f2) || [ ${?} = 106 ]\n\n\t# In case the locale is not available, install it\n\t# will ensure we don't fallback to C.UTF-8\n\tif ! locale -a | grep -qi en_us.utf8 || ! locale -a | grep -qi \"${HOST_LOCALE}\"; then\n\t\tLANG=\"${HOST_LOCALE}\" localedef -i \"${HOST_LOCALE_LANG}\" -f \"${HOST_LOCALE_ENCODING}\" \"${HOST_LOCALE}\" || true\n\tfi\n\n\t# Ensure we have tzdata installed and populated, sometimes container\n\t# images blank the zoneinfo directory, so we reinstall the package to\n\t# ensure population\n\tif [ ! -e /usr/share/zoneinfo/UTC ]; then\n\t\tzypper install -f -y timezone\n\tfi\n\n\t# Install additional packages passed at distrbox-create time\n\tif [ -n \"${container_additional_packages}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tzypper install -y ${container_additional_packages}\n\tfi\n}\n\n# Check dependencies in a list, and install all if one is missing\nmissing_packages=0\ndependencies=\"\n\tbc\n\tbzip2\n\tchpasswd\n\tcurl\n\tdiff\n\tfind\n\tfindmnt\n\tgpg\n\thostname\n\tless\n\tlsof\n\tman\n\tmount\n\tpasswd\n\tpigz\n\tpinentry\n\tping\n\tps\n\trsync\n\tscript\n\tssh\n\tsudo\n\ttime\n\ttree\n\tumount\n\tunzip\n\tuseradd\n\twc\n\twget\n\txauth\n\tzip\n\t${shell_pkg}\n\"\nfor dep in ${dependencies}; do\n\t! command -v \"${dep}\" > /dev/null && missing_packages=1 && break\ndone\n\n# Ensure we have the least minimal path of standard Linux File System set\nPATH=\"${PATH}:/bin:/sbin:/usr/bin:/usr/sbin\"\n\n# Check if dependencies are met for the script to run.\nif [ \"${upgrade}\" -ne 0 ] ||\n\t[ \"${missing_packages}\" -ne 0 ] ||\n\t{\n\t\t[ -n \"${container_additional_packages}\" ] && [ ! -e /.containersetupdone ]\n\t}; then\n\n\t# Detect the available package manager\n\t# install minimal dependencies needed to bootstrap the container:\n\t#\tthe same shell that's on the host + ${dependencies}\n\tif command -v apk; then\n\t\tsetup_apk\n\telif command -v apt-get; then\n\t\tsetup_apt\n\telif command -v emerge; then\n\t\tsetup_emerge\n\telif command -v pacman; then\n\t\tsetup_pacman\n\telif command -v slackpkg; then\n\t\tsetup_slackpkg\n\telif command -v swupd; then\n\t\tsetup_swupd\n\telif command -v xbps-install; then\n\t\tsetup_xbps\n\telif command -v zypper; then\n\t\tsetup_zypper\n\telif command -v dnf; then\n\t\tsetup_dnf dnf\n\telif command -v microdnf; then\n\t\tsetup_microdnf\n\telif command -v yum; then\n\t\tsetup_dnf yum\n\telse\n\t\tprintf \"Error: could not find a supported package manager.\\n\"\n\t\tprintf \"Error: could not set up base dependencies.\\n\"\n\t\t# Exit as command not found\n\t\texit 127\n\tfi\n\n\ttouch /.containersetupdone\nfi\n\n# Set SHELL to the install path inside the container\nSHELL=\"$(command -v \"${shell_pkg}\")\"\n\n# Attempt to download host-spawn during init, we don't care if it fails, so let's\n# continue in that case\n/usr/bin/distrobox-host-exec -Y test 2> /dev/null > /dev/null || :\n\n# If xdg-open is not present, do a link of it. This is handy to handle opening of\n# links, files and apps from inside the container into the host.\nif ! command -v xdg-open; then\n\tmkdir -p /usr/local/bin/\n\tln -sf /usr/bin/distrobox-host-exec /usr/local/bin/xdg-open\nfi\n\n# If flatpak is not present, do a link of it. This is handy to handle opening of\n# links, files and apps from inside the container into the host.\n# Note: we're using /usr/bin instead of /usr/local/bin because xdg-open will read\n# the desktopfile, which will contain an absolute path of /usr/bin/flatpak\nif ! command -v flatpak; then\n\tln -sf /usr/bin/distrobox-host-exec /usr/bin/flatpak\nfi\n\n###############################################################################\n\n# Ensure compatibility with older versions of su, this will allow to specify\n# the --pty flag\n#\n# This won't work well on very old distros with no flag support, but will give\n# an usable shell nonetheless\nif ! su --help | grep -q pty; then\n\tcat << EOF > /usr/local/bin/su\n#!/bin/sh\n\nfor i do\n  [ \"\\$i\" = --pty ] || set -- \"\\$@\" \"\\$i\"\n  shift\ndone\n\n/bin/su \"\\$@\"\nEOF\n\tchmod +x /usr/local/bin/su\nfi\n\n###############################################################################\nprintf \"distrobox: Setting up devpts mounts...\\n\"\n\n# First we need to ensure we have a tty group to assign /dev/pts to\nif ! grep -q tty /etc/group; then\n\tprintf \"%s\" 'tty:x:5:' >> /etc/group\nfi\n\n# Instantiate a new /dev/pts mount, this will ensure pseudoterminals are container-scoped\n# and make easier in case of initful containers to have a separate /dev/console\n#\n# Podman supports a mount option to do this at creation time, but we're doing it\n# here to support also other container rmanagers which does not support that flag\nmount -t devpts devpts -o noexec,nosuid,newinstance,ptmxmode=0666,mode=0620,gid=tty /dev/pts/\nmount --bind /dev/pts/ptmx /dev/ptmx\n\n# Change mount propagation to shared to make the environment more similar to a\n# modern Linux system, e.g. with Systemd as PID 1.\nmount --make-rshared /\n###############################################################################\n\n###############################################################################\nprintf \"distrobox: Setting up read-only mounts...\\n\"\n\nfor host_mount_ro in ${HOST_MOUNTS_RO}; do\n\t# Mounting read-only in a user namespace will trigger a check to see if certain\n\t# \"locked\" flags (line noexec,nodev,nosuid) are changed. This ensures we explicitly reuse those flags.\n\tlocked_flags=\"$(get_locked_mount_flags /run/host\"${host_mount_ro}\")\"\n\tif ! mount_bind /run/host\"${host_mount_ro}\" \"${host_mount_ro}\" ro\"${locked_flags:+,${locked_flags}}\"; then\n\t\tprintf \"Warning: %s integration with the host failed, runtime sync for %s disabled.\\n\" \"${host_mount_ro}\" \"${host_mount_ro}\"\n\t\t# Fallback options for files, we do a hard copy of it\n\t\tif [ -f /run/host\"${host_mount_ro}\" ]; then\n\t\t\trm -f \"${host_mount_ro}\"\n\t\t\tcp -f /run/host\"${host_mount_ro}\" \"${host_mount_ro}\"\n\t\tfi\n\tfi\ndone\n###############################################################################\n\n###############################################################################\nprintf \"distrobox: Setting up read-write mounts...\\n\"\n\n# On some ostree systems, home is in /var/home, but most of the software expects\n# it to be in /home. In the hosts systems this is fixed by using a symlink.\n# Do something similar here with a bind mount.\nif [ -e \"/var/home/${container_user_name}\" ]; then\n\tif ! mount_bind \"/run/host/var/home/${container_user_name}\" \"/home/${container_user_name}\"; then\n\t\tprintf \"Warning: Cannot bind mount %s to /run/host%s\\n\" \"/var/home\" \"/home\"\n\tfi\nfi\n\nfor host_mount in ${HOST_MOUNTS}; do\n\tif ! mount_bind /run/host\"${host_mount}\" \"${host_mount}\"; then\n\t\tprintf \"Warning: Cannot bind mount %s to /run/host%s\\n\" \"${host_mount}\" \"${host_mount}\"\n\tfi\ndone\n###############################################################################\n\n###############################################################################\nprintf \"distrobox: Setting up host's sockets integration...\\n\"\n# Find all the user's socket and mount them inside the container\n# this will allow for continuity of functionality between host and container\n#\n# for example using `podman --remote` to control the host's podman from inside\n# the container or accessing docker and libvirt sockets.\nhost_sockets=\"$(find /run/host/run \\\n\t-path /run/host/run/media -prune -o \\\n\t-path /run/host/run/timeshift -prune -o \\\n\t-name 'user' -prune -o \\\n\t-name 'bees' -prune -o \\\n\t-name 'nscd' -prune -o \\\n\t-name 'system_bus_socket' -prune -o \\\n\t-type s -print \\\n\t2> /dev/null || :)\"\n\n# we're excluding system dbus socket and nscd socket here. Including them will\n# create many problems with package managers thinking they have access to\n# system dbus or user auth cache misused.\nfor host_socket in ${host_sockets}; do\n\tcontainer_socket=\"$(printf \"%s\" \"${host_socket}\" | sed 's|/run/host||g')\"\n\t# Check if the socket already exists or the symlink already exists\n\tif [ ! -S \"${container_socket}\" ] && [ ! -L \"${container_socket}\" ]; then\n\t\t# link it.\n\t\trm -f \"${container_socket}\"\n\t\tmkdir -p \"$(dirname \"${container_socket}\")\"\n\t\tif ! ln -s \"${host_socket}\" \"${container_socket}\"; then\n\t\t\tprintf \"Warning: Cannot link socket %s to %s\\n\" \"${host_socket}\" \"${container_socket}\"\n\t\tfi\n\tfi\ndone\n###############################################################################\n\n# If --nvidia, we try to integrate host's nvidia drivers in to the guest\nif [ \"${nvidia}\" -eq 1 ]; then\n\tprintf \"distrobox: Setting up host's nvidia integration...\\n\"\n\n\t# Refresh ldconfig cache, also detect if there are empty files remaining\n\t# and clean them.\n\t# This could happen when upgrading drivers and changing versions.\n\tempty_libs=\"$(ldconfig 2>&1 | grep -Eo \"File.*is empty\" | cut -d' ' -f2)\"\n\tif [ -n \"${empty_libs}\" ]; then\n\t\t# shellcheck disable=SC2086\n\t\tfind ${empty_libs} -exec sh -c 'rm -rf \"$1\" || umount \"$1\" && rm -rf \"$1\"' sh {} ';' || :\n\t\tfind /usr/ /etc/ -empty -iname \"*nvidia*\" -exec sh -c 'rm -rf \"$1\" || umount \"$1\" && rm -rf \"$1\"' sh {} ';' || :\n\tfi\n\n\t# Find where the system expects libraries to be put\n\tlib32_dir=\"/usr/lib/\"\n\tlib64_dir=\"/usr/lib/\"\n\tif [ -e \"/usr/lib/x86_64-linux-gnu\" ]; then\n\t\tlib64_dir=\"/usr/lib/x86_64-linux-gnu/\"\n\telif [ -e \"/usr/lib64\" ]; then\n\t\tlib64_dir=\"/usr/lib64/\"\n\tfi\n\tif [ -e \"/usr/lib/i386-linux-gnu\" ]; then\n\t\tlib32_dir=\"/usr/lib/i386-linux-gnu/\"\n\telif [ -e \"/usr/lib32\" ]; then\n\t\tlib32_dir=\"/usr/lib32/\"\n\tfi\n\n\t# First we find all non-lib files we need, this includes\n\t#\t- binaries\n\t#\t- confs\n\t#\tExcluding here the libs, we will threat them later specifically\n\tNVIDIA_FILES=\"$(find /run/host/etc/ /run/host/usr/ \\\n\t\t-path \"/run/host/usr/lib/i386-linux-gnu/*\" -prune -o \\\n\t\t-path \"/run/host/usr/lib/x86_64-linux-gnu/*\" -prune -o \\\n\t\t-path \"/run/host/usr/lib32/*\" -prune -o \\\n\t\t-path \"/run/host/usr/lib64/*\" -prune -o \\\n\t\t-path \"/run/host/usr/lib/*\" -prune -o \\\n\t\t-path \"/run/host/usr/share/*\" -prune -o \\\n\t\t-path \"/run/host/usr/src/*\" -prune -o \\\n\t\t-path \"/run/host/usr/include/*\" -prune -o \\\n\t\t-path \"*.png\" -prune -o \\\n\t\t-path \"*.svg\" -prune -o \\\n\t\t-path \"*.repo\" -prune -o \\\n\t\t-iname \"*nvidia*\" -not -type d -print 2> /dev/null || :)\"\n\tfor nvidia_file in ${NVIDIA_FILES}; do\n\t\tdest_file=\"$(printf \"%s\" \"${nvidia_file}\" | sed 's|/run/host||g')\"\n\n\t\t# Mounting read-only in a user namespace will trigger a check to see if certain\n\t\t# \"locked\" flags (line noexec,nodev,nosuid) are changed. This ensures we explicitly reuse those flags.\n\t\tlocked_flags=\"$(get_locked_mount_flags \"${nvidia_file}\")\"\n\t\tmount_bind \"${nvidia_file}\" \"${dest_file}\" ro\"${locked_flags:+,${locked_flags}}\"\n\tdone\n\n\t# First we find all non-lib files we need, this includes\n\t#\t- egl files\n\t#\t- icd files\n\t#\t- doc files\n\t#\t- src files\n\t#\tExcluding here the libs, we will threat them later specifically\n\tNVIDIA_FILES=\"$(find \\\n\t\t/run/host/usr/share/*nvidia* \\\n\t\t/run/host/usr/share/*vulkan* \\\n\t\t/run/host/usr/share/doc/*nvidia* \\\n\t\t/run/host/usr/src/*nvidia* \\\n\t\t-not -type d -print 2> /dev/null || :)\"\n\tfor nvidia_file in ${NVIDIA_FILES}; do\n\t\tdest_file=\"$(printf \"%s\" \"${nvidia_file}\" | sed 's|/run/host||g')\"\n\n\t\t# Mounting read-only in a user namespace will trigger a check to see if certain\n\t\t# \"locked\" flags (line noexec,nodev,nosuid) are changed. This ensures we explicitly reuse those flags.\n\t\tlocked_flags=\"$(get_locked_mount_flags \"${nvidia_file}\")\"\n\t\tmount_bind \"${nvidia_file}\" \"${dest_file}\" ro\"${locked_flags:+,${locked_flags}}\"\n\tdone\n\n\t# Then we find all directories with nvidia in the name and just mount them\n\tNVIDIA_DIRS=\"$(find /run/host/etc /run/host/usr -iname \"*nvidia*\" -type d 2> /dev/null || :)\"\n\tfor nvidia_dir in ${NVIDIA_DIRS}; do\n\t\t# /usr/lib64 is common in Arch or RPM based distros, while /usr/lib/x86_64-linux-gnu is\n\t\t# common on Debian derivatives, so we need to adapt between the two nomenclatures.\n\t\tif printf \"%s\" \"${nvidia_dir}\" | grep -Eq \"lib32|lib64|x86_64-linux-gnu|i386-linux-gnu\"; then\n\n\t\t\t# Remove origin so we plug our own\n\t\t\tdest_dir=\"$(printf \"%s\" \"${nvidia_dir}\" |\n\t\t\t\tsed \"s|/run/host/usr/lib/x86_64-linux-gnu/|${lib64_dir}|g\" |\n\t\t\t\tsed \"s|/run/host/usr/lib/i386-linux-gnu/|${lib32_dir}|g\" |\n\t\t\t\tsed \"s|/run/host/usr/lib64/|${lib64_dir}|g\" |\n\t\t\t\tsed \"s|/run/host/usr/lib32/|${lib32_dir}|g\")\"\n\t\telse\n\t\t\tdest_dir=\"$(printf \"%s\" \"${nvidia_dir}\" | sed 's|/run/host||g')\"\n\t\tfi\n\n\t\t# Mounting read-only in a user namespace will trigger a check to see if certain\n\t\t# \"locked\" flags (line noexec,nodev,nosuid) are changed. This ensures we explicitly reuse those flags.\n\t\tlocked_flags=\"$(get_locked_mount_flags \"${nvidia_dir}\")\"\n\t\tmount_bind \"${nvidia_dir}\" \"${dest_dir}\" ro\"${locked_flags:+,${locked_flags}}\"\n\tdone\n\n\t# Then we find all the \".so\" libraries, there are searched separately\n\t# because we need to extract the relative path to mount them in the\n\t# correct path based on the guest's setup\n\t#\n\t# /usr/lib64 is common in Arch or RPM based distros, while /usr/lib/x86_64-linux-gnu is\n\t# common on Debian derivatives, so we need to adapt between the two nomenclatures.\n\tNVIDIA_LIBS=\"$(find \\\n\t\t/run/host/usr/lib/i386-linux-gnu/ \\\n\t\t/run/host/usr/lib/x86_64-linux-gnu/ \\\n\t\t/run/host/usr/lib/ \\\n\t\t/run/host/usr/lib32/ \\\n\t\t/run/host/usr/lib64/ \\\n\t\t-iname \"*nvidia*.so*\" \\\n\t\t-o -iname \"libcuda*.so*\" \\\n\t\t-o -iname \"libnvcuvid*.so*\" \\\n\t\t-o -iname \"libnvoptix*.so*\" 2> /dev/null || :)\"\n\tfor nvidia_lib in ${NVIDIA_LIBS}; do\n\t\tdest_file=\"$(printf \"%s\" \"${nvidia_lib}\" |\n\t\t\tsed \"s|/run/host/usr/lib/x86_64-linux-gnu/|${lib64_dir}|g\" |\n\t\t\tsed \"s|/run/host/usr/lib/i386-linux-gnu/|${lib32_dir}|g\" |\n\t\t\tsed \"s|/run/host/usr/lib64/|${lib64_dir}|g\" |\n\t\t\tsed \"s|/run/host/usr/lib32/|${lib32_dir}|g\" |\n\t\t\tsed \"s|/run/host/usr/lib/|${lib32_dir}|g\")\"\n\n\t\t# If file exists, just continue\n\t\t# this may happen for directories like /usr/lib/nvidia/xorg/foo.so\n\t\t# where the directory is already bind mounted (ro) and we don't need\n\t\t# to mount further files in it.\n\t\tif [ -e \"${dest_file}\" ]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\ttype=\"file\"\n\t\tif [ -L \"${nvidia_lib}\" ]; then\n\t\t\ttype=\"link\"\n\t\tfi\n\n\t\tif [ \"${type}\" = \"link\" ]; then\n\t\t\tmkdir -p \"$(dirname \"${dest_file}\")\"\n\t\t\tif [ \"$(md5sum \"${nvidia_lib}\" | cut -d ' ' -f 1)\" != \"$(md5sum \"${dest_file}\" | cut -d ' ' -f 1)\" ]; then\n\t\t\t\tcp -d \"${nvidia_lib}\" \"${dest_file}\"\n\t\t\tfi\n\t\t\tcontinue\n\t\tfi\n\n\t\t# Mounting read-only in a user namespace will trigger a check to see if certain\n\t\t# \"locked\" flags (line noexec,nodev,nosuid) are changed. This ensures we explicitly reuse those flags.\n\t\tlocked_flags=\"$(get_locked_mount_flags \"${nvidia_lib}\")\"\n\t\tmount_bind \"${nvidia_lib}\" \"${dest_file}\" ro\"${locked_flags:+,${locked_flags}}\"\n\tdone\n\n\t# Refresh ldconfig cache\n\tldconfig 2>&1 /dev/null\n\nfi\n\n###############################################################################\nprintf \"distrobox: Integrating host's themes, icons, fonts...\\n\"\n# Themes and icons integration works using a bind mount inside the container\n# of the host's themes and icons directory. This ensures that the host's home will\n# not be littered with files and directories and broken symlinks.\nif ! mount_bind \"/run/host/usr/share/themes\" \"/usr/local/share/themes\"; then\n\tprintf \"Warning: Cannot bind mount /run/host/usr/share/themes to /usr/local/share/themes\\n\"\n\tprintf \"Warning: Themes integration with the host is disabled.\\n\"\nfi\nif ! mount_bind \"/run/host/usr/share/icons\" \"/usr/local/share/icons\"; then\n\tprintf \"Warning: Cannot bind mount /run/host/usr/share/icons to /usr/local/share/icons\\n\"\n\tprintf \"Warning: Icons integration with the host is disabled.\\n\"\nfi\nif ! mount_bind \"/run/host/usr/share/fonts\" \"/usr/local/share/fonts\"; then\n\tprintf \"Warning: Cannot bind mount /run/host/usr/share/fonts to /usr/local/share/fonts\\n\"\n\tprintf \"Warning: Fonts integration with the host is disabled.\\n\"\nfi\n###############################################################################\n\nprintf \"distrobox: Setting up distrobox profile...\\n\"\n\n# This ensures compatibility with prompts and tools between toolbx and distrobox\ntouch /run/.toolboxenv\n\n# Ensure we have some basic env variables and prompt as base if /etc/profile.d is missing\nif [ ! -d /etc/profile.d ]; then\n\trcfiles=\"\n\t\t/etc/profile\n\t\t/etc/bash.bashrc\n\t\t/etc/bashrc\n\t\t/etc/zshrc\n\t\"\n\tfor rcfile in ${rcfiles}; do\n\t\tif [ -e \"${rcfile}\" ] && ! grep -q 'distrobox_profile.sh' \"${rcfile}\"; then\n\t\t\techo \"[ -e /etc/profile.d/distrobox_profile.sh ] && . /etc/profile.d/distrobox_profile.sh\" >> \"${rcfile}\"\n\t\tfi\n\tdone\n\tmkdir -p /etc/profile.d\nfi\ncat << EOF > /etc/profile.d/distrobox_profile.sh\ntest -z \"\\$USER\" && export USER=\"\\$(id -un 2> /dev/null)\"\ntest -z \"\\$UID\"  && readonly UID=\"\\$(id -ur 2> /dev/null)\"\ntest -z \"\\$EUID\" && readonly EUID=\"\\$(id -u  2> /dev/null)\"\nexport SHELL=\"\\$(getent passwd \"\\${USER}\" | cut -f 7 -d :)\"\n\ntest -z \"\\${XDG_RUNTIME_DIR:-}\" && export XDG_RUNTIME_DIR=\"/run/user/\\$(id -ru)\"\ntest -z \"\\${DBUS_SESSION_BUS_ADDRESS:-}\" && export DBUS_SESSION_BUS_ADDRESS=\"unix:path=/run/user/\\$(id -ru)/bus\"\n\n# Ensure we have these two variables from the host, so that graphical apps\n# also work in case we use a login session\nif [ -z \"\\$XAUTHORITY\" ]; then\n    export XAUTHORITY=\"\\$(host-spawn sh -c \"printf \"%s\" \\\\\\$XAUTHORITY\")\"\n    # if the variable is still empty, unset it, because empty it could be harmful\n    [ -z \"\\$XAUTHORITY\" ] && unset XAUTHORITY\nfi\nif [ -z \"\\$XAUTHLOCALHOSTNAME\" ]; then\n    export XAUTHLOCALHOSTNAME=\"\\$(host-spawn sh -c \"printf \"%s\" \\\\\\$XAUTHLOCALHOSTNAME\")\"\n    [ -z \"\\$XAUTHLOCALHOSTNAME\" ] && unset XAUTHLOCALHOSTNAME\nfi\nif [ -z \"\\$WAYLAND_DISPLAY\" ]; then\n    export WAYLAND_DISPLAY=\"\\$(host-spawn sh -c \"printf \"%s\" \\\\\\$WAYLAND_DISPLAY\")\"\n    [ -z \"\\$WAYLAND_DISPLAY\" ] && unset WAYLAND_DISPLAY\nfi\nif [ -z \"\\$DISPLAY\" ]; then\n    export DISPLAY=\"\\$(host-spawn sh -c \"printf \"%s\" \\\\\\$DISPLAY\")\"\n    [ -z \"\\$DISPLAY\" ] && unset DISPLAY\nfi\n\n# This will ensure a default prompt for a container, this will be remineshent of\n# toolbx prompt: https://github.com/containers/toolbox/blob/main/profile.d/toolbox.sh#L47\n# this will ensure greater compatibility between the two implementations\nif [ -f /run/.toolboxenv ]; then\n    [ \"\\${BASH_VERSION:-}\" != \"\" ] && export PS1=\"[\\u@\\$CONTAINER_ID \\W]\\$ \"\n    [ \"\\${ZSH_VERSION:-}\" != \"\" ] && export PS1=\"[%n@\\$CONTAINER_ID]%~%# \"\nfi\n\n# This will ensure we have a first-shell password setup for an user if needed.\n# We're going to use this later in case of rootful containers\nif [ -e /var/tmp/.\\$USER.passwd.initialize ]; then\n\techo \"  First time user password setup  \"\n\ttrap \"echo; exit\" INT\n\tpasswd && rm -f /var/tmp/.\\$USER.passwd.initialize\n\ttrap - INT\nfi\nEOF\n\n# It's also importanto to keep this working on fish shells\nif [ -e \"/etc/fish/config.fish\" ]; then\n\tmkdir -p /etc/fish/conf.d\n\tcat << EOF > /etc/fish/conf.d/distrobox_config.fish\nif status --is-interactive\n\ttest -z \"\\$USER\" && set -gx USER (id -un 2> /dev/null)\n\ttest -z \"\\$UID\"  && set -gx UID (id -ur 2> /dev/null)\n\ttest -z \"\\$EUID\" && set -gx EUID (id -u  2> /dev/null)\n\tset -gx SHELL (getent passwd \"\\$USER\" | cut -f 7 -d :)\n\n\ttest -z \"\\$XDG_RUNTIME_DIR && set -gx XDG_RUNTIME_DIR /run/user/(id -ru)\n\ttest -z \"\\$DBUS_SESSION_BUS_ADDRESS && set -gx DBUS_SESSION_BUS_ADDRESS unix:path=/run/user/(id -ru)/bus\n\n\t# Ensure we have these two variables from the host, so that graphical apps\n\t# also work in case we use a login session\n\tif test -z \\$XAUTHORITY\n\t\tset -gx XAUTHORITY (host-spawn sh -c \"printf \"%s\" \\\\\\$XAUTHORITY\")\n\t\t# if the variable is still empty, unset it, because empty it could be harmful\n\t\ttest -z \\$XAUTHORITY ; and set -e XAUTHORITY\n\tend\n\tif test -z \\$XAUTHLOCALHOSTNAME\n\t\tset -gx XAUTHLOCALHOSTNAME (host-spawn sh -c \"printf \"%s\" \\\\\\$XAUTHLOCALHOSTNAME\")\n\t\ttest -z \\$XAUTHLOCALHOSTNAME ; and set -e XAUTHLOCALHOSTNAME\n\tend\n\tif test -z \\$WAYLAND_DISPLAY\n\t\tset -gx WAYLAND_DISPLAY (host-spawn sh -c \"printf \"%s\" \\\\\\$WAYLAND_DISPLAY\")\n\t\ttest -z \\$WAYLAND_DISPLAY ; and set -e WAYLAND_DISPLAY\n\tend\n\tif test -z \\$DISPLAY\n\t\tset -gx DISPLAY (host-spawn sh -c \"printf \"%s\" \\\\\\$DISPLAY\")\n\t\ttest -z \\$DISPLAY ; and set -e DISPLAY\n\tend\n\n\t# This will ensure we have a first-shell password setup for an user if needed.\n\t# We're going to use this later in case of rootful containers\n\tif test -e /var/tmp/.\\$USER.passwd.initialize\n\t\techo \"  First time user password setup  \"\n\t\ttrap \"echo; exit\" INT\n\t\tpasswd && rm -f /var/tmp/.\\$USER.passwd.initialize\n\t\ttrap - INT\n\tend\n\tfunction fish_prompt\n\t\tset current_dir (basename (pwd))\n\t\techo \"[\\$USER@\\$CONTAINER_ID \\$current_dir]> \"\n\tend\nend\nEOF\nfi\n###############################################################################\n\n###############################################################################\nprintf \"distrobox: Setting up sudo...\\n\"\nmkdir -p /etc/sudoers.d\n# Ensure we're using the user's password for sudo, not root\nif [ -e /etc/sudoers ]; then\n\tsed -i \"s|^Defaults targetpw.*||g\" /etc/sudoers\nfi\n\n# Do not check fqdn when doing sudo, it will not work anyways\n# Also allow canonical groups to use sudo\ncat << EOF > /etc/sudoers.d/sudoers\nDefaults !targetpw\nDefaults !fqdn\n%wheel ALL=(ALL:ALL) ALL\n%sudo ALL=(ALL:ALL) ALL\n%root ALL=(ALL:ALL) ALL\nEOF\n\n# PAM config for \"su\" command\nif [ ! -e /etc/pam.d/su ]; then\n\tmkdir -p /etc/pam.d\n\tcat << EOF > /etc/pam.d/su\nauth            sufficient      pam_rootok.so\nauth            required        pam_unix.so\naccount\t        required        pam_unix.so\nsession         required        pam_unix.so\n-session        optional        pam_systemd.so\nEOF\nfi\n\nif ! grep -q \"pam_systemd.so\" /etc/pam.d/su; then\n\tprintf \"%s\" '-session   optional   pam_systemd.so' >> /etc/pam.d/su\nfi\n\n# If we're running this script as root in a login shell (sudoless), we don't\n# have to bother setting up sudo.\n#\n# Also if we're in a rootful container, we will setup user's password,\n# so let's skip passwordless sudo too\nif [ \"${container_user_uid}\" -ne 0 ] && [ \"${rootful}\" -eq 0 ]; then\n\t# Ensure passwordless sudo is set up for user\n\tprintf \"\\\"%s\\\" ALL = (root) NOPASSWD:ALL\\n\" \"${container_user_name}\" >> /etc/sudoers.d/sudoers\nfi\n###############################################################################\n\n###############################################################################\n# If not existing, ensure we have a group for our user.\nif ! grep -q \"^${container_user_name}:\" /etc/group; then\n\tprintf \"distrobox: Setting up user groups...\\n\"\n\n\tif ! groupadd --force --gid \"${container_user_gid}\" \"${container_user_name}\"; then\n\t\t# It may occur that we have users with unsupported user name (eg. on LDAP or AD)\n\t\t# So let's try and force the group creation this way.\n\t\tprintf \"%s:x:%s:\" \"${container_user_name}\" \"${container_user_gid}\" >> /etc/group\n\tfi\nfi\n###############################################################################\n\n###############################################################################\n\n# Setup kerberos integration with the host\nif [ -d \"/run/host/var/kerberos\" ] &&\n\t[ -d \"/etc/krb5.conf.d\" ] &&\n\t[ ! -e \"/etc/krb5.conf.d/kcm_default_ccache\" ]; then\n\n\tprintf \"distrobox: Setting up kerberos integration...\\n\"\n\n\tcat << EOF > /etc/krb5.conf.d/kcm_default_ccache\n# # To disable the KCM credential cache, comment out the following lines.\n[libdefaults]\n    default_ccache_name = KCM:\nEOF\nfi\n\nprintf \"distrobox: Setting up user's group list...\\n\"\n# If we have sudo/wheel groups, let's add the user to them.\n# and ensure that user's in those groups can effectively sudo\nadditional_groups=\"\"\nif grep -q \"^sudo\" /etc/group; then\n\tadditional_groups=\"sudo\"\nelif grep -q \"^wheel\" /etc/group; then\n\tadditional_groups=\"wheel\"\nelif grep -q \"^root\" /etc/group; then\n\tadditional_groups=\"root\"\nfi\n\n# If we're rootful, search for host's groups, if we're not in anyone, let's not\n# add the current user to any sudoers group, so that host's sudo settings are\n# respected\nif [ \"${rootful}\" -eq 1 ] &&\n\t! grep -q \"^wheel.*${container_user_name}\" /run/host/etc/group &&\n\t! grep -q \"^wheel.*${container_user_name}\" /run/host/etc/group &&\n\t! grep -q \"^sudo.*${container_user_name}\" /run/host/etc/group; then\n\tadditional_groups=\"\"\nfi\n\n# Let's add our user to the container. if the user already exists, enforce properties.\n#\n# In case of AD or LDAP usernames, it is possible we will have a backslach in the name.\n# In that case grep would fail, so we replace the backslash with a point to make the regex work.\n# shellcheck disable=SC1003\nif ! grep -q \"^$(printf '%s' \"${container_user_name}\" | tr '\\\\' '.'):\" /etc/passwd &&\n\t! getent passwd \"${container_user_uid}\"; then\n\tprintf \"distrobox: Adding user...\\n\"\n\tif ! useradd \\\n\t\t--home-dir \"${container_user_home}\" \\\n\t\t--no-create-home \\\n\t\t--groups \"${additional_groups}\" \\\n\t\t--shell \"${SHELL:-\"/bin/bash\"}\" \\\n\t\t--uid \"${container_user_uid}\" \\\n\t\t--gid \"${container_user_gid}\" \\\n\t\t\"${container_user_name}\"; then\n\n\t\tprintf \"Warning: There was a problem setting up the user with usermod, trying manual addition\\n\"\n\n\t\tprintf \"%s:x:%s:%s:%s:%s:%s\" \\\n\t\t\t\"${container_user_name}\" \"${container_user_uid}\" \\\n\t\t\t\"${container_user_gid}\" \"${container_user_name}\" \\\n\t\t\t\"${container_user_home}\" \"${SHELL:-\"/bin/bash\"}\" >> /etc/passwd\n\t\tprintf \"%s::1::::::\" \"${container_user_name}\" >> /etc/shadow\n\tfi\n# Ensure we're not using the specified SHELL. Run it only once, so that future\n# user's preferences are not overwritten at each start.\nelif [ ! -e /etc/passwd.done ]; then\n\t# This situation is presented when podman or docker already creates the user\n\t# for us inside container. We should modify the user's prepopulated shadowfile\n\t# entry though as per user's active preferences.\n\n\t# If the user was there with a different username, get that username so\n\t# we can modify it\n\tif ! grep -q \"^$(printf '%s' \"${container_user_name}\" | tr '\\\\' '.'):\" /etc/passwd; then\n\t\tuser_to_modify=$(getent passwd \"${container_user_uid}\" | cut -d: -f1)\n\tfi\n\n\tprintf \"distrobox: Setting up existing user...\\n\"\n\tif ! usermod \\\n\t\t--home \"${container_user_home}\" \\\n\t\t--shell \"${SHELL:-\"/bin/bash\"}\" \\\n\t\t--groups \"${additional_groups}\" \\\n\t\t--uid \"${container_user_uid}\" \\\n\t\t--gid \"${container_user_gid}\" \\\n\t\t--login \"${container_user_name}\" \\\n\t\t\"${user_to_modify:-\"${container_user_name}\"}\"; then\n\n\t\tprintf \"Warning: There was a problem setting up the user with usermod, trying manual addition\\n\"\n\n\t\t# Modify the user\n\t\tprintf \"distrobox: Setting up existing user: /etc/passwd...\\n\"\n\t\tsed -i \"s|^${container_user_name}.*||g\" /etc/passwd\n\t\tprintf \"%s:x:%s:%s:%s:%s:%s\" \\\n\t\t\t\"${container_user_name}\" \"${container_user_uid}\" \\\n\t\t\t\"${container_user_gid}\" \"${container_user_name}\" \\\n\t\t\t\"${container_user_home}\" \"${SHELL:-\"/bin/bash\"}\" >> /etc/passwd\n\n\t\t# Add or modify the default group\n\t\t# and add or modify the additional groups\n\t\tprintf \"distrobox: Setting up existing user: /etc/group...\\n\"\n\t\tfor group in ${container_user_name} ${additional_groups}; do\n\t\t\t# Check if we have the user in the group\n\t\t\tif ! grep -q \"^${group}.*${container_user_name}.*\" /etc/group; then\n\t\t\t\tgroup_line=\"$(grep \"^${group}.*\" /etc/group)\"\n\t\t\t\t# If no users in the group just add it\n\t\t\t\tif grep -q \"^${group}.*:$\" /etc/group; then\n\t\t\t\t\tsed -i \"s|${group_line}|${group_line}${container_user_name}|g\" /etc/group\n\t\t\t\telse\n\t\t\t\t\tsed -i \"s|${group_line}|${group_line},${container_user_name}|g\" /etc/group\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\nfi\n\n# Ensure we have our home correctly set, in case of cloned containers or whatnot\nif [ \"$(getent passwd \"${container_user_name}\" | cut -d: -f6)\" != \"${container_user_home}\" ]; then\n\tprintf \"distrobox: Setting up user home...\\n\"\n\n\tif ! usermod -d \"${container_user_home}\" \"${container_user_name}\"; then\n\t\tsed -i \"s|^${container_user_name}.*|${container_user_name}:x:${container_user_uid}:${container_user_gid}::${container_user_home}:${SHELL:-\"/bin/bash\"}|g\" /etc/passwd\n\tfi\nfi\n\n# If we're rootless, delete password for root and user\nif [ ! -e /etc/passwd.done ]; then\n\tprintf \"distrobox: Ensuring user's access...\\n\"\n\n\ttemporary_password=\"$(md5sum < /proc/sys/kernel/random/uuid | cut -d' ' -f1)\"\n\t# We generate a random password to initialize the entry for the user.\n\tchpasswd_failed=0\n\tprintf \"%s:%s\" \"${container_user_name}\" \"${temporary_password}\" | chpasswd -e || chpasswd_failed=1\n\tprintf \"%s:\" \"${container_user_name}\" | chpasswd -e || chpasswd_failed=1\n\n\tif [ \"${chpasswd_failed}\" -eq 1 ]; then\n\t\tprintf \"Warning: There was a problem setting up the user, trying manual addition\\n\"\n\t\tif grep -q \"${container_user_name}\" /etc/shadow; then\n\t\t\tsed -i \"s|^${container_user_name}.*|${container_user_name}::::::::|g\" /etc/shadow\n\t\telse\n\t\t\techo \"${container_user_name}::::::::\" >> /etc/shadow\n\t\tfi\n\tfi\n\n\tif [ \"${rootful}\" -eq 0 ]; then\n\t\t# We're rootless so we don't care about account password, so we remove it\n\t\tpasswd_cmd=passwd\n\t\tif passwd --help 2>&1 | grep -q -- --stdin; then\n\t\t\tpasswd_cmd=\"passwd --stdin\"\n\t\tfi\n\t\tprintf \"%s\\n%s\\n\" \"${temporary_password}\" \"${temporary_password}\" | ${passwd_cmd} root\n\t\tprintf \"%s:\" \"root\" | chpasswd -e\n\telse\n\t\t# We're rootful, so we don't want passwordless accounts, so we lock them\n\t\t# down by default.\n\n\t\t# lock out root user\n\t\tif ! usermod -L root; then\n\t\t\tsed -i 's|^root.*|root:!:1::::::|g' /etc/shadow\n\t\tfi\n\tfi\nfi\n\n# If we are in a rootful container, let's setup a first-shell password setup\n# so that sudo, and su has a password\n#\n# else we fallback to the usual setup with passwordless sudo/su user. This is\n# likely because we're in a rootless setup, so privilege escalation is not a concern.\nif [ \"${rootful}\" -eq 1 ] &&\n\t{\n\t\t[ \"$(grep \"${container_user_name}\" /etc/shadow | cut -d':' -f2)\" = '!!' ] ||\n\t\t\t[ \"$(grep \"${container_user_name}\" /etc/shadow | cut -d':' -f2)\" = \"\" ]\n\t}; then\n\n\t# force setup of user's password on first shell\n\tif [ ! -e /var/tmp ]; then\n\t\tmkdir -p /var/tmp\n\t\tchmod 0777 /var/tmp\n\tfi\n\ttouch /var/tmp/.\"${container_user_name}\".passwd.initialize\n\tchown \"${container_user_name}:${container_user_gid}\" /var/tmp/.\"${container_user_name}\".passwd.initialize\nfi\n\n# Now we're done\ntouch /etc/passwd.done\n###############################################################################\n\n###############################################################################\nif [ -n \"${DISTROBOX_HOST_HOME-}\" ] && [ -d \"/etc/skel\" ]; then\n\tprintf \"distrobox: Setting up skel...\\n\"\n\n\t# If we do not have profile files in the home, we should copy the\n\t# skeleton files, if present.\n\t# Ensure we copy only if the dotfile is not already present.\n\tskel_files=\"$(find /etc/skel/ -type f || :)\"\n\tfor skel_file in ${skel_files}; do\n\t\tbase_file_name=$(basename \"${skel_file}\")\n\t\tskel_file_path=$(dirname \"${skel_file}\")\n\t\tfile_path_for_home=${skel_file_path#/etc/skel}\n\n\t\tif [ -n \"${file_path_for_home}\" ] &&\n\t\t\t[ ! -d \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"}\" ]; then\n\t\t\tmkdir -p \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"/}\"\n\t\t\tchown \"${container_user_uid}\":\"${container_user_gid}\" \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"/}\"\n\t\tfi\n\n\t\tif [ ! -f \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"/}${base_file_name}\" ] &&\n\t\t\t[ ! -L \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"/}${base_file_name}\" ]; then\n\t\t\tcp \"${skel_file}\" \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"/}${base_file_name}\"\n\t\t\tchown \"${container_user_uid}\":\"${container_user_gid}\" \"${container_user_home}/${file_path_for_home:+\"${file_path_for_home}\"/}${base_file_name}\"\n\t\tfi\n\n\tdone\nfi\n###############################################################################\n\n###############################################################################\nif [ -n \"${init_hook}\" ]; then\n\tprintf \"distrobox: Executing init hooks...\\n\"\n\t# execute eventual init hooks if specified\n\t# shellcheck disable=SC2086\n\teval ${init_hook}\nfi\n###############################################################################\n\n###############################################################################\n# If init support is disabled, let's do our routine to keep the container\n# up, running and in sync with host.\n#\n# For non-init containers, the init will stop here\nif [ \"${init}\" -eq 0 ]; then\n\tprintf \"container_setup_done\\n\"\n\t# Keepalive loop\n\tHOST_WATCH=\"\n\t\t/etc/hostname\n\t\t/etc/hosts\n\t\t/etc/localtime\n\t\t/etc/resolv.conf\n\t\"\n\n\tid=\"${CONTAINER_ID:-}\"\n\tif [ -e /run/.containerenv ]; then\n\t\t# shellcheck disable=SC1091,SC2034\n\t\t. /run/.containerenv\n\telif [ -e /.dockerenv ]; then\n\t\tid=\"$(curl -s --unix-socket /run/docker.sock http://docker/containers/\"${CONTAINER_ID:-$(hostname | cut -d'.' -f1)}\"/json |\n\t\t\tgrep -Eo '\"Id\":\"[a-zA-Z0-9]{64}\",' | cut -d '\"' -f4)\"\n\tfi\n\n\t# disable verbose logging for this phase.\n\tset +x\n\twhile true; do\n\t\t# Let's check for changes every 15 seconds.\n\t\t# This way we can dynamically keep hosts, dns and timezone setups\n\t\t# in sync with host, without having permissions problems:\n\t\t#\t- symlink will fail with \"Device or Resource busy\"\n\t\t#\t- bindmount will need a container restart on changes\n\t\tfor file_watch in ${HOST_WATCH}; do\n\t\t\t# do stuff, only if the file is a mountpoint, and if the mountpoint is NOT containing the\n\t\t\t# container id, because if it does, it is because it's part of the podman/docker setup\n\t\t\t# The mount point might not exist, either because it's umounted or it doesn't exist on\n\t\t\t# host in some cases like /etc/localtime, so ignore findmnt errors\n\t\t\tmount_source=\"$(findmnt -no SOURCE \"${file_watch}\")\" || :\n\t\t\tif [ -n \"${mount_source}\" ] && ! echo \"${mount_source}\" | grep -q \"${id}\"; then\n\t\t\t\tfile_watch_src=\"/run/host${file_watch}\"\n\t\t\t\t# check if the target file exists\n\t\t\t\tif ls -l \"${file_watch_src}\" 2> /dev/null > /dev/null; then\n\t\t\t\t\t# if it's a symlink and take the source\n\t\t\t\t\tif [ -L \"${file_watch_src}\" ]; then\n\t\t\t\t\t\tfile_watch_src=\"$(init_readlink \"/run/host${file_watch}\")\"\n\t\t\t\t\t\t# if it's an absolute link, we need to append /run/host ourselves.\n\t\t\t\t\t\tif ! printf \"%s\" \"${file_watch_src}\" | grep -q \"/run/host\"; then\n\t\t\t\t\t\t\tfile_watch_src=\"/run/host${file_watch_src}\"\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\t\tif ! diff \"${file_watch}\" \"${file_watch_src}\" > /dev/null; then\n\t\t\t\t\t\t# We only do this, if the file is actually different\n\t\t\t\t\t\tumount \"${file_watch}\" &&\n\t\t\t\t\t\t\tmount_bind \"${file_watch_src}\" \"${file_watch}\"\n\n\t\t\t\t\t\t# Let's keep in sync host's hostname and container's hostname\n\t\t\t\t\t\tif [ \"${file_watch}\" = \"/etc/hostname\" ]; then\n\t\t\t\t\t\t\thostname \"$(cat /etc/hostname)\"\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\t\tsleep 15\n\tdone\nfi\n###############################################################################\n\n###############################################################################\n# If we're here, the init support has been enabled.\nprintf \"distrobox: Setting up init system...\\n\"\n\n# some of this directories are needed by\n# the init system. If they're mounts, there might\n# be problems. Let's unmount them.\nfor host_mount in ${HOST_MOUNTS_RO_INIT}; do\n\tif findmnt \"${host_mount}\" > /dev/null; then umount \"${host_mount}\"; fi\ndone\n\n# Remove symlinks\nrm -f /run/systemd/coredump\nrm -f /run/systemd/io.system.ManagedOOM\nrm -f /run/systemd/notify\nrm -f /run/systemd/private\n\n# Restore the symlink if it's an empty file\nif [ -f /etc/localtime ]; then\n\trm -f /etc/localtime\n\tln -sf /usr/share/zoneinfo/UCT /etc/localtime\nfi\n\n# Remove /dev/console when using init systems, this will confuse host system if\n# we use rootful containers\n# Instantiate a new pty to mount over /dev/console\n# this way we will have init output right of the logs\n[ -e /dev/console ] || touch /dev/console\nrm -f /var/console\nmkfifo /var/console\nscript -c \"cat /var/console\" /dev/null &\n\n# Ensure the pty is created\nsleep 0.5\n\n# Mount the created pty over /dev/console in order to have systemd logs\n# right into container logs\nif ! mount --bind /dev/pts/0 /dev/console; then\n\t# Fallback to older behaviour or fake plaintext file in case it fails\n\t# this ensures rootful + initful boxes do not interfere with host's /dev/console\n\trm -f /var/console\n\ttouch /var/console\n\tmount --bind /var/console /dev/console\nfi\n\nif [ -e /etc/inittab ]; then\n\t# Cleanup openrc to not interfere with the host\n\tsed -i 's/^\\(tty\\d\\:\\:\\)/#\\1/g' /etc/inittab\nfi\n\nif [ -e /etc/rc.conf ]; then\n\tsed -i \\\n\t\t-e 's/#rc_env_allow=\".*\"/rc_env_allow=\"\\*\"/g' \\\n\t\t-e 's/#rc_crashed_stop=.*/rc_crashed_stop=NO/g' \\\n\t\t-e 's/#rc_crashed_start=.*/rc_crashed_start=YES/g' \\\n\t\t-e 's/#rc_provide=\".*\"/rc_provide=\"loopback net\"/g' \\\n\t\t/etc/rc.conf\nfi\n\nif [ -e /etc/init.d ]; then\n\trm -f /etc/init.d/hwdrivers \\\n\t\t/etc/init.d/hwclock \\\n\t\t/etc/init.d/hwdrivers \\\n\t\t/etc/init.d/modules \\\n\t\t/etc/init.d/modules-load \\\n\t\t/etc/init.d/modloop\nfi\n\nif command -v systemctl 2> /dev/null; then\n\t# Cleanup Systemd to not interfere with the host\n\tUNIT_TARGETS=\"\n\t\t/usr/lib/systemd/system/*.mount\n\t\t/usr/lib/systemd/system/console-getty.service\n\t\t/usr/lib/systemd/system/getty@.service\n\t\t/usr/lib/systemd/system/systemd-machine-id-commit.service\n\t\t/usr/lib/systemd/system/systemd-binfmt.service\n\t\t/usr/lib/systemd/system/systemd-tmpfiles*\n\t\t/usr/lib/systemd/system/systemd-udevd.service\n\t\t/usr/lib/systemd/system/systemd-udev-trigger.service\n\t\t/usr/lib/systemd/system/systemd-update-utmp*\n\t\t/usr/lib/systemd/user/pipewire*\n\t\t/usr/lib/systemd/user/wireplumber*\n\t\t/usr/lib/systemd/system/suspend.target\n\t\t/usr/lib/systemd/system/hibernate.target\n\t\t/usr/lib/systemd/system/hybrid-sleep.target\n\t\"\n\t# shellcheck disable=SC2086,SC2044\n\tfor unit in $(find ${UNIT_TARGETS} 2> /dev/null); do\n\t\tsystemctl mask \"$(basename \"${unit}\")\" || :\n\tdone\nfi\n\n# Let's do a minimal user-integration for the user when using system\n# as the user@.service will trigger the user-runtime-dir@.service which will\n# undo all the integration we did at the start of the script\n#\n# This will ensure the basic integration for x11/wayland/pipewire/keyring\nif [ -e /usr/lib/systemd/system/user@.service ]; then\n\tcat << EOF > /usr/local/bin/user-integration\n#!/bin/sh\nsleep 1\nln -sf /run/host/run/user/\\$(id -ru)/wayland-* /run/user/\\$(id -ru)/\nln -sf /run/host/run/user/\\$(id -ru)/pipewire-* /run/user/\\$(id -ru)/\nfind /run/host/run/user/\\$(id -ru)/ -maxdepth 1 -type f -exec sh -c 'grep -qlE COOKIE \\$0 && ln -sf \\$0 /run/user/\\$(id -ru)/\\$(basename \\$0)' {} \\;\nmkdir -p /run/user/\\$(id -ru)/app && ln -sf /run/host/run/user/\\$(id -ru)/app/* /run/user/\\$(id -ru)/app/\nmkdir -p /run/user/\\$(id -ru)/at-spi && ln -sf /run/host/run/user/\\$(id -ru)/at-spi/* /run/user/\\$(id -ru)/at-spi/\nmkdir -p /run/user/\\$(id -ru)/dbus-1 && ln -sf /run/host/run/user/\\$(id -ru)/dbus-1/* /run/user/\\$(id -ru)/dbus-1/\nmkdir -p /run/user/\\$(id -ru)/dconf && ln -sf /run/host/run/user/\\$(id -ru)/dconf/* /run/user/\\$(id -ru)/dconf/\nmkdir -p /run/user/\\$(id -ru)/gnupg && ln -sf /run/host/run/user/\\$(id -ru)/gnupg/* /run/user/\\$(id -ru)/gnupg/\nmkdir -p /run/user/\\$(id -ru)/keyring && ln -sf /run/host/run/user/\\$(id -ru)/keyring/* /run/user/\\$(id -ru)/keyring/\nmkdir -p /run/user/\\$(id -ru)/p11-kit && ln -sf /run/host/run/user/\\$(id -ru)/p11-kit/* /run/user/\\$(id -ru)/p11-kit/\nmkdir -p /run/user/\\$(id -ru)/pulse && ln -sf /run/host/run/user/\\$(id -ru)/pulse/* /run/user/\\$(id -ru)/pulse/\nfind /run/user/\\$(id -ru) -maxdepth 2 -xtype l -delete\nEOF\n\n\tchmod +x /usr/local/bin/user-integration\n\n\tcat << EOF > /usr/lib/systemd/system/user-integration@.service\n[Unit]\nDescription=User runtime integration for UID %i\nAfter=user@%i.service\nRequires=user-runtime-dir@%i.service\n\n[Service]\nUser=%i\nType=oneshot\nExecStart=/usr/local/bin/user-integration\n\nSlice=user-%i.slice\nEOF\nfi\n\n# Now we can launch init\nprintf \"distrobox: Firing up init system...\\n\"\n\nif [ -e /usr/lib/systemd/systemd ] || [ -e /lib/systemd/systemd ]; then\n\t# Start user Systemd unit, this will attempt until Systemd is ready\n\tsh -c \"\tsleep 1 && while true; do \\\n\t    systemctl is-system-running | grep -E 'running|degraded' && break; \\\n\t    echo 'waiting for systemd to come up...\\n' && sleep 1; \\\n\tdone && \\\n\tsystemctl start user@${container_user_name}.service && \\\n\tsystemctl start user-integration@${container_user_name}.service && \\\n\tloginctl enable-linger ${container_user_name} || : && \\\n\techo container_setup_done\" &\n\n\t[ -e /usr/lib/systemd/systemd ] && exec /usr/lib/systemd/systemd --system --log-target=console --unit=multi-user.target\n\t[ -e /lib/systemd/systemd ] && exec /lib/systemd/systemd --system --log-target=console --unit=multi-user.target\n\nelif [ -e /sbin/init ]; then\n\tprintf \"container_setup_done\\n\"\n\n\t# Fallback to standard init path, this is useful in case of non-Systemd containers\n\t# like an openrc alpine\n\texec /sbin/init\nelse\n\tprintf \"Error: could not set up init system, no init found! Consider using an image that ships with an init system, or add it with \\\"--additional-packages\\\" during creation.!\\n\"\n\texit 1\nfi\n"
        },
        {
          "name": "distrobox-list",
          "type": "blob",
          "size": 8.509765625,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Optional env variables:\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_VERBOSE\n#\tDBX_SUDO_PROGRAM\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# Defaults\nno_color=0\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"$(id -ru)\" -eq 0 ] && rootful=1 || rootful=0\nverbose=0\nversion=\"1.8.0\"\ncontainer_manager=\"autodetect\"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# If we're running this script as root -- as in logged in in the shell as root\n# user, and not via SUDO/DOAS --, we don't need to set distrobox_sudo_program\n# as it's meaningless for this use case.\nif [ \"$(id -ru)\" -ne 0 ]; then\n\t# If the DBX_SUDO_PROGRAM/distrobox_sudo_program variable was set by the\n\t# user, use its value instead of \"sudo\". But only if not running the script\n\t# as root (UID 0).\n\tdistrobox_sudo_program=${DBX_SUDO_PROGRAM:-${distrobox_sudo_program:-\"sudo\"}}\nfi\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-list\n\nOptions:\n\n\t--help/-h:\t\tshow this message\n\t--no-color:\t\tdisable color formatting\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t--no-color)\n\t\t\tshift\n\t\t\tno_color=1\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tbreak ;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman,  docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n# add verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\tcontainer_manager=\"${distrobox_sudo_program-} ${container_manager}\"\nfi\n\n# List containers using custom format that included MOUNTS\n# we do this as we can detect the custom mounts done by distrobox to distringuish\n# between a normal container and a distrobox one.\ncontainer_list=$(${container_manager} ps -a --no-trunc --format \\\n\t\"{{.ID}}|{{.Image}}|{{.Names}}|{{.Status}}|{{.Labels}}{{.Mounts}}\")\nprintf \"%-12s | %-20s | %-18s | %-30s\\n\" \\\n\t\"ID\" \"NAME\" \"STATUS\" \"IMAGE\"\nIFS='\n'\n\n# if we're in not a tty, don't use colors\nGREEN=\"\"\nYELLOW=\"\"\nCLEAR=\"\"\nif [ -t 0 ] && [ -t 1 ] && [ \"${no_color}\" -ne 1 ]; then\n\t# we're in a tty, use colors\n\tGREEN='\\033[32m'\n\tYELLOW='\\033[33m'\n\tCLEAR='\\033[0m'\nfi\n# Header of the output\nfor container in ${container_list}; do\n\t# Check if the current container has a custom mount point for distrobox.\n\tif [ -z \"${container##*distrobox*}\" ]; then\n\n\t\t# Extract the information for the single container to pretty print it\n\t\tcontainer_id=\"$(printf \"%s\" \"${container}\" | cut -d'|' -f1 | cut -c1-12)\"\n\t\tcontainer_image=\"$(printf \"%s\" \"${container}\" | cut -d'|' -f2)\"\n\t\tcontainer_name=\"$(printf \"%s\" \"${container}\" | cut -d'|' -f3)\"\n\t\tcontainer_status=\"$(printf \"%s\" \"${container}\" | cut -d'|' -f4)\"\n\n\t\tIFS=' '\n\n\t\t# If the container is Up and Running, print it in green and go next.\n\t\tif [ -z \"${container_status##*Up*}\" ] || [ -z \"${container_status##*running*}\" ]; then\n\t\t\t# echo -e is not defined in posix, and printing with %s will not work\n\t\t\t# for colors, so we're disabling this lint for color prints.\n\t\t\t# shellcheck disable=SC2059\n\t\t\tprintf \"${GREEN}\"\n\t\telse\n\t\t\t# shellcheck disable=SC2059\n\t\t\tprintf \"${YELLOW}\"\n\t\tfi\n\t\t# print it in yellow if not Running\n\t\tprintf \"%-12s | %-20s | %-18s | %-30s\" \\\n\t\t\t\"${container_id}\" \"${container_name}\" \"${container_status}\" \"${container_image}\"\n\n\t\t# shellcheck disable=SC2059\n\t\tprintf \"${CLEAR}\\n\"\n\tfi\ndone\n"
        },
        {
          "name": "distrobox-rm",
          "type": "blob",
          "size": 14.0283203125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Optional env variables:\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_CONTAINER_NAME\n#\tDBX_CONTAINER_RM_CUSTOM_HOME\n#\tDBX_NON_INTERACTIVE\n#\tDBX_VERBOSE\n#\tDBX_SUDO_PROGRAM\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# Defaults\nall=0\ncontainer_manager=\"autodetect\"\ndistrobox_flags=\"\"\ndistrobox_path=\"$(dirname \"$(realpath \"${0}\")\")\"\nforce=0\nforce_flag=\"\"\nnon_interactive=0\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"$(id -ru)\" -eq 0 ] && rootful=1 || rootful=0\nverbose=0\nrm_home=0\nresponse_rm_home=\"N\"\nversion=\"1.8.0\"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n[ -n \"${DBX_CONTAINER_RM_CUSTOM_HOME}\" ] && rm_home=\"${DBX_CONTAINER_RM_CUSTOM_HOME}\"\n[ -n \"${DBX_NON_INTERACTIVE}\" ] && non_interactive=\"${DBX_NON_INTERACTIVE}\"\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${non_interactive}\" = \"true\" ] && non_interactive=1\n[ \"${non_interactive}\" = \"false\" ] && non_interactive=0\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# If we're running this script as root - as in logged in in the shell as root\n# user, and not via SUDO/DOAS -, we don't need to set distrobox_sudo_program\n# as it's meaningless for this use case.\nif [ \"$(id -ru)\" -ne 0 ]; then\n\t# If the DBX_SUDO_PROGRAM/distrobox_sudo_program variable was set by the\n\t# user, use its value instead of \"sudo\". But only if not running the script\n\t# as root (UID 0).\n\tdistrobox_sudo_program=${DBX_SUDO_PROGRAM:-${distrobox_sudo_program:-\"sudo\"}}\nfi\n\n# Declare it AFTER config sourcing because we do not want a default name set for rm.\ncontainer_name_default=\"my-distrobox\"\ncontainer_name_list=\"\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-rm [-f/--force] container-name [container-name1 container-name2 ...]\n\nOptions:\n\n\t--all/-a:\t\tdelete all distroboxes\n\t--force/-f:\t\tforce deletion\n\t--rm-home:\t\tremove the mounted home if it differs from the host user's one\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--help/-h:\t\tshow this message\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-a | --all)\n\t\t\tshift\n\t\t\tall=1\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t--rm-home)\n\t\t\tshift\n\t\t\trm_home=1\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-f | --force)\n\t\t\tforce=1\n\t\t\tnon_interactive=1\n\t\t\tshift\n\t\t\t;;\n\t\t-Y | --yes)\n\t\t\tnon_interactive=1\n\t\t\tshift\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcontainer_name_list=\"${container_name_list} $1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman,  docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n\n# add verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\nfi\n\n# add -f if force is specified\nif [ \"${force}\" -ne 0 ]; then\n\tforce_flag=\"--force\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\tcontainer_manager=\"${distrobox_sudo_program-} ${container_manager}\"\n\tdistrobox_flags=\"--root\"\nfi\n\n# If all, just set container_name to the list of names in distrobox-list\nif [ \"${all}\" -ne 0 ]; then\n\t# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\n\t# shellcheck disable=SC2086,2248\n\tcontainer_name_list=\"$(\"${distrobox_path}\"/distrobox-list ${distrobox_flags} --no-color |\n\t\ttail -n +2 | cut -d'|' -f2 | tr -d ' ' | tr '\\n' ' ')\"\nfi\n\nif [ -z \"${container_name_list}\" ] && [ \"${all}\" -ne 0 ]; then\n\tprintf >&2 \"No containers found.\\n\"\n\texit 0\nfi\n\n# check if we have containers to delete\nif [ -z \"${container_name_list}\" ]; then\n\tcontainer_name_list=\"${container_name_default}\"\nfi\n\n# cleanup_exports will remove exported apps and bins for container to delete.\n# Arguments:\n#   container_name: string container name\n# Expected global variables:\n#   distrobox_flags: string additional distrobox flags to use\n# Expected env variables:\n#   None\n# Outputs:\n#   None\ncleanup_exports()\n{\n\tcontainer_name=\"$1\"\n\tIFS=''\n\tprintf \"Removing exported binaries...\\n\"\n\tbinary_files=\"$(grep -rl \"# distrobox_binary\" \"${HOME}/.local/bin\" 2> /dev/null | sed 's/./\\\\&/g' |\n\t\txargs -I{} grep -le \"# name: ${container_name}$\" \"{}\" | sed 's/./\\\\&/g' |\n\t\txargs -I{} printf \"%s\" \"{}\" 2> /dev/null || :)\"\n\tfor file in ${binary_files}; do\n\t\tprintf \"Removing exported binary %s...\\n\" \"${file}\"\n\t\trm -f \"${file}\"\n\tdone\n\n\t# Remove exported gui apps from this container in default path\n\t# shellcheck disable=SC2086,SC2038\n\tdesktop_files=\"$(find \"${HOME}/.local/share/applications/${container_name}\"* -type f -o -type l 2> /dev/null | sed 's/./\\\\&/g' |\n\t\txargs -I{} grep -le \"Exec=.*${container_name} \" \"{}\" | sed 's/./\\\\&/g' |\n\t\txargs -I{} printf \"%s\" \"{}\" 2> /dev/null || :)\"\n\tfor file in ${desktop_files}; do\n\t\tif [ -e \"${file}\" ]; then\n\t\t\tapp=\"$(grep -Eo \"Name=.*\" \"${file}\" | head -n 1 | cut -d'=' -f2)\"\n\t\t\ticon=\"$(grep -Eo \"Icon=.*\" \"${file}\" | head -n 1 | cut -d'=' -f2)\"\n\n\t\t\tprintf \"Removing exported app %s...\\n\" \"${app}\"\n\t\t\trm -f \"${file}\"\n\t\t\tfind \"${HOME}/.local/share/icons\" -name \"${icon}.*\" -delete\n\t\tfi\n\tdone\n\tunset IFS\n}\n\n# delete_container will remove input container\n# Arguments:\n#   container_name: string container name\n# Expected global variables:\n#   container_manager: string container manager to use\n#   distrobox_flags: string distrobox additional flags\n#   non_interactive: bool non interactive mode\n#   force_flag: bool force mode\n#   rm_home: bool remove home\n#   verbose: bool verbose\n# Expected env variables:\n#   None\n# Outputs:\n#   None\ndelete_container()\n{\n\tcontainer_name=\"$1\"\n\t# Inspect the container we're working with.\n\tcontainer_status=\"$(${container_manager} inspect --type container \\\n\t\t--format '{{.State.Status}}' \"${container_name}\" || :)\"\n\t# Does the container exist? check if inspect reported errors\n\tif [ -z \"${container_status}\" ]; then\n\t\t# If not, prompt to create it first\n\t\tprintf >&2 \"Cannot find container %s.\\n\" \"${container_name}\"\n\t\treturn\n\tfi\n\n\t# Retrieve container's HOME, and check if it's different from host's one. In\n\t# this case we prompt for deletion of the custom home.\n\tcontainer_home=$(${container_manager} inspect --type container --format \\\n\t\t'{{range .Config.Env}}{{if and (ge (len .) 5) (eq (slice . 0 5) \"HOME=\")}}{{slice . 5 | printf \"%q\"}}{{end}}{{end}}' \"${container_name}\")\n\t# Prompt for confirmation\n\tif [ \"${container_home}\" != \"${HOME}\" ]; then\n\t\tif [ \"${non_interactive}\" -eq 0 ] &&\n\t\t\t[ \"${rm_home}\" -eq 1 ]; then\n\n\t\t\tprintf \"Do you want to remove custom home of container %s (%s)? [y/N]: \" \"${container_name}\" \"${container_home}\"\n\t\t\tread -r response_rm_home\n\t\t\tresponse_rm_home=\"${response_rm_home:-\"N\"}\"\n\t\tfi\n\tfi\n\n\t# Validate home response\n\t# Accept only y,Y,Yes,yes,n,N,No,no.\n\tcase \"${response_rm_home}\" in\n\t\ty | Y | Yes | yes | YES)\n\t\t\trm_home_local=1\n\t\t\t;;\n\t\tn | N | No | no | NO)\n\t\t\trm_home_local=0\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tprintf >&2 \"Invalid input.\\n\"\n\t\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\n\t# Remove the container\n\tprintf \"Removing container...\\n\"\n\t# shellcheck disable=SC2086,SC2248\n\t${container_manager} rm ${force_flag} --volumes \"${container_name}\"\n\n\t# Remove exported apps and bins\n\tcleanup_exports \"${container_name}\"\n\n\t# We're going to delete the box, let's also delete the entry\n\tverbose_arg=\"\"\n\tif [ \"${verbose}\" -ne 0 ]; then\n\t\tverbose_arg=\"--verbose\"\n\tfi\n\t\"$(dirname \"$(realpath \"${0}\")\")/distrobox-generate-entry\" \"${container_name}\" --delete \"${verbose_arg}\"\n\n\t# Remove custom home\n\tif [ \"${rm_home_local}\" -eq 1 ]; then\n\t\trm -r \"${container_home}\"\n\t\tprintf \"Successfully removed %s\\n\" \"${container_home}\"\n\tfi\n}\n\n# Prompt for confirmation\nif [ \"${non_interactive}\" -eq 0 ] && [ \"${force}\" -eq 0 ]; then\n\tprintf \"Do you really want to delete containers:%s? [Y/n]: \" \"${container_name_list}\"\n\tread -r response\n\tresponse=\"${response:-\"Y\"}\"\nelse\n\tresponse=\"yes\"\nfi\n\nfor container in ${container_name_list}; do\n\tif [ \"$(${container_manager} inspect --type container --format '{{.State.Status}}' \"${container}\")\" = \"running\" ]; then\n\t\tif [ \"${non_interactive}\" -eq 0 ] && [ \"${force}\" -eq 0 ]; then\n\t\t\tprintf \"Container %s running, do you want to force delete them? [Y/n]: \" \"${container_name_list}\"\n\t\t\tread -r response_force\n\t\t\tresponse_force=\"${response_force:-\"Y\"}\"\n\t\telse\n\t\t\tresponse_force=\"yes\"\n\t\tfi\n\tfi\n\n\t# Accept only y,Y,Yes,yes,n,N,No,no.\n\tcase \"${response_force:-\"N\"}\" in\n\t\ty | Y | Yes | yes | YES)\n\t\t\tforce=1\n\t\t\tforce_flag=\"--force\"\n\t\t\tbreak\n\t\t\t;;\n\t\tn | N | No | no | NO) ;;\n\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tprintf >&2 \"Invalid input.\\n\"\n\t\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\t\t;;\n\tesac\ndone\n\n# Accept only y,Y,Yes,yes,n,N,No,no.\ncase \"${response}\" in\n\ty | Y | Yes | yes | YES)\n\t\tfor container in ${container_name_list}; do\n\t\t\tdelete_container \"${container}\"\n\t\tdone\n\t\t;;\n\tn | N | No | no | NO)\n\t\tprintf \"Aborted.\\n\"\n\t\texit 0\n\t\t;;\n\t*) # Default case: If no more options then break out of the loop.\n\t\tprintf >&2 \"Invalid input.\\n\"\n\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\texit 1\n\t\t;;\nesac\n"
        },
        {
          "name": "distrobox-stop",
          "type": "blob",
          "size": 9.1748046875,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n# Optional env variables:\n#\tDBX_CONTAINER_MANAGER\n#\tDBX_CONTAINER_NAME\n#\tDBX_NON_INTERACTIVE\n#\tDBX_VERBOSE\n#\tDBX_SUDO_PROGRAM\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\n# Defaults\nall=0\ncontainer_manager=\"autodetect\"\ndistrobox_flags=\"\"\ndistrobox_path=\"$(dirname \"$(realpath \"${0}\")\")\"\ncontainer_name=\"\"\ncontainer_name_default=\"my-distrobox\"\ncontainer_name_list=\"\"\nnon_interactive=0\n# If the user runs this script as root in a login shell, set rootful=1.\n# There's no need for them to pass the --root flag option in such cases.\n[ \"$(id -ru)\" -eq 0 ] && rootful=1 || rootful=0\nverbose=0\nversion=\"1.8.0\"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n[ -n \"${DBX_CONTAINER_NAME}\" ] && container_name=\"${DBX_CONTAINER_NAME}\"\n[ -n \"${DBX_NON_INTERACTIVE}\" ] && non_interactive=\"${DBX_NON_INTERACTIVE}\"\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n[ \"${non_interactive}\" = \"true\" ] && non_interactive=1\n[ \"${non_interactive}\" = \"false\" ] && non_interactive=0\n\n# If we're running this script as root - as in logged in in the shell as root\n# user, and not via SUDO/DOAS -, we don't need to set distrobox_sudo_program\n# as it's meaningless for this use case.\nif [ \"$(id -ru)\" -ne 0 ]; then\n\t# If the DBX_SUDO_PROGRAM/distrobox_sudo_program variable was set by the\n\t# user, use its value instead of \"sudo\". But only if not running the script\n\t# as root (UID 0).\n\tdistrobox_sudo_program=${DBX_SUDO_PROGRAM:-${distrobox_sudo_program:-\"sudo\"}}\nfi\n\n[ -n \"${DBX_SUDO_PROGRAM}\" ] && distrobox_sudo_program=\"${DBX_SUDO_PROGRAM}\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-stop --name container-name\n\tdistrobox-stop container-name\n\nOptions:\n\n\t--all/-a:\t\tstop all distroboxes\n\t--yes/-Y:\t\tnon-interactive, stop without asking\n\t--help/-h:\t\tshow this message\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-a | --all)\n\t\t\tshift\n\t\t\tall=1\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-Y | --yes)\n\t\t\tnon_interactive=1\n\t\t\tshift\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcontainer_name_list=\"${container_name_list} $1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\nif [ -z \"${container_name}\" ]; then\n\tcontainer_name=\"${container_name_default}\"\nfi\n\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman,  docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n# add  verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\tcontainer_manager=\"${distrobox_sudo_program-} ${container_manager}\"\n\tdistrobox_flags=\"--root\"\nfi\n\n# If all, just set container_name to the list of names in distrobox-list\nif [ \"${all}\" -ne 0 ]; then\n\t# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\n\t# shellcheck disable=SC2086,2248\n\tcontainer_name_list=\"$(\"${distrobox_path}\"/distrobox-list ${distrobox_flags} --no-color |\n\t\ttail -n +2 | cut -d'|' -f2 | tr -d ' ' | tr '\\n' ' ')\"\nfi\n\nif [ -z \"${container_name_list}\" ] && [ \"${all}\" -ne 0 ]; then\n\tprintf >&2 \"No containers found.\\n\"\n\texit 0\nfi\n\n# check if we have containers to delete\nif [ -z \"${container_name_list}\" ]; then\n\tcontainer_name_list=\"${container_name_default}\"\nelse\n\t# strip leading whitespace from container name\n\tcontainer_name_list=\"$(echo \"${container_name_list}\" | sed -E 's/^[[:space:]]+//')\"\nfi\n\nif [ \"${non_interactive}\" -eq 0 ]; then\n\t# Prompt to stop the container.\n\tprintf \"Do you really want to stop %s? [Y/n]: \" \"${container_name_list}\"\n\tread -r response\n\tresponse=\"${response:-\"Y\"}\"\nelse\n\tresponse=\"yes\"\nfi\n\n# Accept only y,Y,Yes,yes,n,N,No,no.\ncase \"${response}\" in\n\ty | Y | Yes | yes | YES)\n\t\t# Stop the container\n\t\tfor container_name in ${container_name_list}; do\n\t\t\t${container_manager} stop \"${container_name}\"\n\t\tdone\n\t\t;;\n\tn | N | No | no | NO)\n\t\tprintf \"Aborted.\\n\"\n\t\texit 0\n\t\t;;\n\t*) # Default case: If no more options then break out of the loop.\n\t\tprintf >&2 \"Invalid input.\\n\"\n\t\tprintf >&2 \"The available choices are: y,Y,Yes,yes,YES or n,N,No,no,NO.\\nExiting.\\n\"\n\t\texit 1\n\t\t;;\nesac\n"
        },
        {
          "name": "distrobox-upgrade",
          "type": "blob",
          "size": 8.2255859375,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project:\n#    https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# Despite of running this script via SUDO/DOAS being not supported (the\n# script itself will call the appropriate tool when necessary), we still want\n# to allow people to run it as root, logged in in a shell, and create rootful\n# containers.\n#\n# SUDO_USER is a variable set by SUDO and can be used to check whether the script was called by it. Same thing for DOAS_USER, set by DOAS.\nif {\n\t[ -n \"${SUDO_USER}\" ] || [ -n \"${DOAS_USER}\" ]\n} && [ \"$(id -ru)\" -eq 0 ]; then\n\tprintf >&2 \"Running %s via SUDO/DOAS is not supported. Instead, please try running:\\n\" \"$(basename \"${0}\")\"\n\tprintf >&2 \"  %s --root %s\\n\" \"$(basename \"${0}\")\" \"$*\"\n\texit 1\nfi\n\n# Ensure we have our env variables correctly set\n[ -z \"${USER}\" ] && USER=\"$(id -run)\"\n[ -z \"${HOME}\" ] && HOME=\"$(getent passwd \"${USER}\" | cut -d':' -f6)\"\n[ -z \"${SHELL}\" ] && SHELL=\"$(getent passwd \"${USER}\" | cut -d':' -f7)\"\n\nall=0\nrunning=0\ncontainer_manager=\"autodetect\"\ndistrobox_flags=\"\"\ndistrobox_path=\"$(dirname \"$(realpath \"${0}\")\")\"\nrootful=0\nverbose=0\nversion=\"1.8.0\"\n\n# Source configuration files, this is done in an hierarchy so local files have\n# priority over system defaults\n# leave priority to environment variables.\n#\n# On NixOS, for the distrobox derivation to pick up a static config file shipped\n# by the package maintainer the path must be relative to the script itself.\nself_dir=\"$(dirname \"$(realpath \"$0\")\")\"\nnix_config_file=\"${self_dir}/../share/distrobox/distrobox.conf\"\n\nconfig_files=\"\n\t${nix_config_file}\n\t/usr/share/distrobox/distrobox.conf\n\t/usr/share/defaults/distrobox/distrobox.conf\n\t/usr/etc/distrobox/distrobox.conf\n\t/usr/local/share/distrobox/distrobox.conf\n\t/etc/distrobox/distrobox.conf\n\t${XDG_CONFIG_HOME:-\"${HOME}/.config\"}/distrobox/distrobox.conf\n\t${HOME}/.distroboxrc\n\"\nfor config_file in ${config_files}; do\n\t# Shellcheck will give error for sourcing a variable file as it cannot follow\n\t# it. We don't care so let's disable this linting for now.\n\t# shellcheck disable=SC1090\n\t[ -e \"${config_file}\" ] && . \"$(realpath \"${config_file}\")\"\ndone\n\n[ -n \"${DBX_CONTAINER_MANAGER}\" ] && container_manager=\"${DBX_CONTAINER_MANAGER}\"\n[ -n \"${DBX_VERBOSE}\" ] && verbose=\"${DBX_VERBOSE}\"\n\n# Fixup variable=[true|false], in case we find it in the config file(s)\n[ \"${verbose}\" = \"true\" ] && verbose=1\n[ \"${verbose}\" = \"false\" ] && verbose=0\n\n# If we're running this script as root - as in logged in in the shell as root\n# user, and not via SUDO/DOAS -, we don't need to set distrobox_sudo_program\n# as it's meaningless for this use case.\nif [ \"$(id -ru)\" -ne 0 ]; then\n\t# If the DBX_SUDO_PROGRAM/distrobox_sudo_program variable was set by the\n\t# user, use its value instead of \"sudo\". But only if not running the script\n\t# as root (UID 0).\n\tdistrobox_sudo_program=${DBX_SUDO_PROGRAM:-${distrobox_sudo_program:-\"sudo\"}}\nfi\n\n# Declare it AFTER config sourcing because we do not want a default name set.\ncontainer_name=\"\"\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Expected global variables:\n#   version: distrobox version\n# Expected env variables:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ndistrobox version: ${version}\n\nUsage:\n\n\tdistrobox-upgrade container-name\n\tdistrobox-upgrade --all\n\nOptions:\n\n\t--help/-h:\t\tshow this message\n\t--all/-a:\t\tperform for all distroboxes\n\t--running:\t\tperform only for running distroboxes\n\t--root/-r:\t\tlaunch podman/docker/lilipod with root privileges. Note that if you need root this is the preferred\n\t\t\t\tway over \"sudo distrobox\" (note: if using a program other than 'sudo' for root privileges is necessary,\n\t\t\t\tspecify it through the DBX_SUDO_PROGRAM env variable, or 'distrobox_sudo_program' config variable)\n\t--verbose/-v:\t\tshow more verbosity\n\t--version/-V:\t\tshow version\nEOF\n}\n\nif [ $# -eq 0 ]; then\n\tshow_help\n\texit\nfi\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit 0\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tverbose=1\n\t\t\tshift\n\t\t\t;;\n\t\t-V | --version)\n\t\t\tprintf \"distrobox: %s\\n\" \"${version}\"\n\t\t\texit 0\n\t\t\t;;\n\t\t-a | --all)\n\t\t\tall=1\n\t\t\tshift\n\t\t\t;;\n\t\t--running)\n\t\t\trunning=1\n\t\t\tshift\n\t\t\t;;\n\t\t-r | --root)\n\t\t\tshift\n\t\t\trootful=1\n\t\t\t;;\n\t\t--) # End of all options.\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*) # Invalid options.\n\t\t\tprintf >&2 \"ERROR: Invalid flag '%s'\\n\\n\" \"$1\"\n\t\t\tshow_help\n\t\t\texit 1\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\t# If we have a flagless option and container_name is not specified\n\t\t\t# then let's accept argument as container_name\n\t\t\tif [ -n \"$1\" ]; then\n\t\t\t\tcontainer_name=\"${container_name} $1\"\n\t\t\t\tshift\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\t;;\n\tesac\ndone\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\nif [ -z \"${container_name}\" ] && [ \"${all}\" -eq 0 ] && [ \"${running}\" -eq 0 ]; then\n\tprintf >&2 \"Please specify the name of the container.\\n\"\n\texit 1\nfi\n\n# We depend on a container manager let's be sure we have it\n# First we use podman, else docker, else lilipod\ncase \"${container_manager}\" in\n\tautodetect)\n\t\tif command -v podman > /dev/null; then\n\t\t\tcontainer_manager=\"podman\"\n\t\telif command -v podman-launcher > /dev/null; then\n\t\t\tcontainer_manager=\"podman-launcher\"\n\t\telif command -v docker > /dev/null; then\n\t\t\tcontainer_manager=\"docker\"\n\t\telif command -v lilipod > /dev/null; then\n\t\t\tcontainer_manager=\"lilipod\"\n\t\tfi\n\t\t;;\n\tpodman)\n\t\tcontainer_manager=\"podman\"\n\t\t;;\n\tpodman-launcher)\n\t\tcontainer_manager=\"podman-launcher\"\n\t\t;;\n\tlilipod)\n\t\tcontainer_manager=\"lilipod\"\n\t\t;;\n\tdocker)\n\t\tcontainer_manager=\"docker\"\n\t\t;;\n\t*)\n\t\tprintf >&2 \"Invalid input %s.\\n\" \"${container_manager}\"\n\t\tprintf >&2 \"The available choices are: 'autodetect', 'podman', 'docker', 'lilipod'\\n\"\n\t\t;;\nesac\n\n# Be sure we have a container manager to work with.\nif ! command -v \"${container_manager}\" > /dev/null; then\n\t# Error: we need at least one between docker, podman or lilipod.\n\tprintf >&2 \"Missing dependency: we need a container manager.\\n\"\n\tprintf >&2 \"Please install one of podman,  docker or lilipod.\\n\"\n\tprintf >&2 \"You can follow the documentation on:\\n\"\n\tprintf >&2 \"\\tman distrobox-compatibility\\n\"\n\tprintf >&2 \"or:\\n\"\n\tprintf >&2 \"\\thttps://github.com/89luca89/distrobox/blob/main/docs/compatibility.md\\n\"\n\texit 127\nfi\n\n# add  verbose if -v is specified\nif [ \"${verbose}\" -ne 0 ]; then\n\tcontainer_manager=\"${container_manager} --log-level debug\"\nfi\n\n# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\nif [ \"${rootful}\" -ne 0 ]; then\n\tcontainer_manager=\"${distrobox_sudo_program} ${container_manager}\"\n\tdistrobox_flags=\"--root\"\nfi\n\n# If all, just set container_name to the list of names in distrobox-list\nif [ \"${all}\" -ne 0 ]; then\n\n\t# prepend sudo (or the specified sudo program) if we want our container manager to be rootful\n\t# shellcheck disable=SC2086,2248\n\tcontainer_name=\"$(\"${distrobox_path}\"/distrobox-list ${distrobox_flags} --no-color |\n\t\ttail -n +2 | cut -d'|' -f2 | tr -d ' ')\"\n\n\t# If running, set container_name to the list of names of running instances\n\tif [ \"${running}\" -ne 0 ]; then\n\t\t# shellcheck disable=SC2086,2248\n\t\tcontainer_name=\"$(\"${distrobox_path}\"/distrobox-list ${distrobox_flags} --no-color |\n\t\t\ttail -n +2 | grep -iE '\\| running|up' | cut -d'|' -f2 | tr -d ' ')\"\n\tfi\nfi\n\n# Launch the entrypoint in upgrade mode\nfor container in ${container_name}; do\n\tprintf >&2 \"\\033[1;31m Upgrading %s...\\n\\033[0m\" \"${container}\"\n\t# shellcheck disable=SC2086,SC2248\n\t\"${distrobox_path}\"/distrobox-enter \\\n\t\t${distrobox_flags} ${container} -- sh -c \\\n\t\t\"command -v su-exec 2>/dev/null && su-exec root /usr/bin/entrypoint --upgrade || sudo -S /usr/bin/entrypoint --upgrade\"\ndone\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "extras",
          "type": "tree",
          "content": null
        },
        {
          "name": "icons",
          "type": "tree",
          "content": null
        },
        {
          "name": "install",
          "type": "blob",
          "size": 7.0908203125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project: https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n\nnext=0\nverbose=0\nversion=1.8.0\n\n# show_help will print usage to stdout.\n# Arguments:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\ninstall --prefix /usr/local\n\nOptions:\n\t--prefix/-P:\t\tbase bath where all files will be deployed (default /usr/local if root, ~/.local if not)\n\t--next/-N:\t\tinstall latest development version from git, instead of the latest stable release.\n\t--help/-h:\t\tshow this message\n\t-v:\t\t\tshow more verbosity\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tshift\n\t\t\tverbose=1\n\t\t\t;;\n\t\t-N | --next)\n\t\t\tshift\n\t\t\tnext=1\n\t\t\t;;\n\t\t-P | --prefix)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tprefix=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tbreak ;;\n\tesac\ndone\n\nif  [ -z \"${prefix}\" ]; then\n\tprefix=\"/usr/local\"\n\t# in case we're not root, just default to the home directory\n\tif [ \"$(id -u)\" -ne 0 ]; then\n\t\tprefix=\"${HOME}/.local\"\n\tfi\nfi\ndest_path=\"${prefix}/bin\"\nman_dest_path=\"${prefix}/share/man/man1\"\nicon_dest_path=\"${prefix}/share/icons/hicolor\"\ncompletion_bash_dest_path=\"${prefix}/share/bash-completion/completions/\"\ncompletion_zsh_dest_path=\"${prefix}/share/zsh/site-functions/\"\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n# get current dir\ncurr_dir=$(dirname \"$0\")\ncd \"${curr_dir}\" || exit 1\n\n# if files are available, install files in dest directory\n# else download targz and uncompress it\nif [ -e \"${curr_dir}/distrobox-enter\" ]; then\n\tif ! install -d \"${dest_path}\" \"${man_dest_path}\" \"${completion_bash_dest_path}\" \\\n\t\t\"${completion_zsh_dest_path}\" \"${icon_dest_path}/scalable/apps\"; then\n\t\tprintf >&2 \"Do you have permission to write to %s?\\n\" \"${prefix}\"\n\t\texit 1\n\tfi\n\tfor file in distrobox*; do\n\t\tif ! install -m 0755 \"${file}\" \"${dest_path}\"; then\n\t\t\tprintf >&2 \"Do you have permission to write to %s?\\n\" \"${dest_path}\"\n\t\t\texit 1\n\t\tfi\n\tdone\n\tif [ -e \"man\" ]; then\n\t\tfor file in man/man1/*; do\n\t\t\tinstall -m 0644 \"${file}\" \"${man_dest_path}\"\n\t\tdone\n\tfi\n\tif [ -e \"completions\" ]; then\n\t\tfor file in completions/bash/*; do\n\t\t\tinstall -m 0644 \"${file}\" \"${completion_bash_dest_path}\"\n\t\tdone\n\tfi\n\tif [ -e \"completions\" ]; then\n\t\tfor file in completions/zsh/*; do\n\t\t\tinstall -m 0644 \"${file}\" \"${completion_zsh_dest_path}\"\n\t\tdone\n\tfi\n\tif [ -e icons/terminal-distrobox-icon.svg ]; then\n\t\tinstall -m 0644 icons/terminal-distrobox-icon.svg \"${icon_dest_path}/scalable/apps\"\n\t\tfor sz in 16 22 24 32 36 48 64 72 96 128 256; do\n\t\t\tinstall -d \"${icon_dest_path}/${sz}x${sz}/apps\"\n\t\t\tinstall -m 0644 icons/hicolor/\"${sz}x${sz}\"/apps/terminal-distrobox-icon.png \\\n\t\t\t\t\"${icon_dest_path}/${sz}x${sz}/apps\"\n\t\tdone\n\tfi\nelse\n\tprintf >&2 \"\\033[1;31m Checking dependencies...\\n\\033[0m\"\n\t# check that we have base dependencies\n\tif ! {\n\t\tcommand -v curl > /dev/null || command -v wget > /dev/null\n\t} || ! command -v tar > /dev/null; then\n\t\tprintf >&2 \"Online install depends on tar and either curl or wget\\n\"\n\t\tprintf >&2 \"Ensure you have all dependencies installed.\\n\"\n\t\texit 1\n\tfi\n\n\tif command -v curl > /dev/null 2>&1; then\n\t\tdownload=\"curl -sLo\"\n\telif command -v wget > /dev/null 2>&1; then\n\t\tdownload=\"wget -qO\"\n\tfi\n\n\tprintf >&2 \"\\033[1;31m Downloading...\\n\\033[0m\"\n\tif [ \"${next}\" -eq 0 ]; then\n\t\trelease_ver=\"89luca89/distrobox/archive/refs/tags/${version}.tar.gz\"\n\t\trelease_name=$(basename \"${release_ver}\")\n\telse\n\t\trelease_ver=\"89luca89/distrobox/archive/refs/heads/main.tar.gz\"\n\t\trelease_name=\"main\"\n\tfi\n\t# go in tmp\n\ttmp_dir=\"$(mktemp -d)\"\n\tcd \"${tmp_dir}\"\n\t# download our target\n\t${download} \"${release_name}\" \"https://github.com/${release_ver}\"\n\t# uncompress\n\tprintf >&2 \"\\033[1;31m Unpacking...\\n\\033[0m\"\n\tif [ \"${verbose}\" -ne 0 ]; then\n\t\ttar xvf \"${release_name}\"\n\telse\n\t\ttar xf \"${release_name}\"\n\tfi\n\t# deploy our files\n\tif ! install -d \"${dest_path}\" \"${man_dest_path}\" \"${completion_bash_dest_path}\" \\\n\t\t\"${completion_zsh_dest_path}\" \"${icon_dest_path}/scalable/apps\"; then\n\t\tprintf >&2 \"Do you have permission to write to %s?\\n\" \"${prefix}\"\n\t\texit 1\n\tfi\n\tfor file in \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')\"/distrobox*; do\n\t\tif ! install -m 0755 \"${file}\" \"${dest_path}\"; then\n\t\t\tprintf >&2 \"Do you have permission to write to %s?\\n\" \"${dest_path}\"\n\t\t\texit 1\n\t\tfi\n\tdone\n\tif [ -e \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')/man/\" ]; then\n\t\tfor file in \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')\"/man/man1/*; do\n\t\t\tinstall -m 0644 \"${file}\" \"${man_dest_path}\"\n\t\tdone\n\tfi\n\tif [ -e \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')/completions/bash/\" ]; then\n\t\tfor file in \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')\"/completions/bash/*; do\n\t\t\tinstall -m 0644 \"${file}\" \"${completion_bash_dest_path}\"\n\t\tdone\n\tfi\n\tif [ -e \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')/completions/zsh/\" ]; then\n\t\tfor file in \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')\"/completions/zsh/*; do\n\t\t\tinstall -m 0644 \"${file}\" \"${completion_zsh_dest_path}\"\n\t\tdone\n\tfi\n\tif [ -e \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')\"/icons/terminal-distrobox-icon.svg ]; then\n\t\tinstall -m 0644 \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')\"/icons/terminal-distrobox-icon.svg \\\n\t\t\t\"${icon_dest_path}/scalable/apps\"\n\t\tfor sz in 16 22 24 32 36 48 64 72 96 128 256; do\n\t\t\tinstall -d \"${icon_dest_path}/${sz}x${sz}/apps\"\n\t\t\tinstall -m 0644 \"distrobox-$(echo \"${release_name}\" | sed 's/.tar.gz//g')/icons/hicolor/${sz}x${sz}/apps/terminal-distrobox-icon.png\" \\\n\t\t\t\t\"${icon_dest_path}/${sz}x${sz}/apps\"\n\t\tdone\n\tfi\n\n\t# securely delete unneeded files\n\tcd\n\tif [ -n \"${tmp_dir}\" ] && [ -e \"${tmp_dir}\" ]; then\n\t\trm -rf \"${tmp_dir}\"\n\tfi\nfi\n\n[ ! -w \"${dest_path}\" ] && printf >&2 \"Cannot write into %s, permission denied.\\n\" \"${dest_path}\" && exit 1\n[ ! -w \"${man_dest_path}\" ] && printf >&2 \"Cannot write into %s, permission denied.\\n\" \"${man_dest_path}\" && exit 1\n\nprintf >&2 \"\\033[1;32m Installation successful!\\n\\033[0m\"\nprintf >&2 \"\\033[0m Shell scripts are located in \\033[1;31m%s\\n\\033[0m\" \"${dest_path}\"\nprintf >&2 \"\\033[0m Manpages are located in \\033[1;31m%s\\n\\033[0m\" \"${man_dest_path}\"\n\nif ! echo \"${PATH}\" | grep -q \"${dest_path}\"; then\n\tprintf >&2 \"\\033[0m Be sure that \\033[1;31m%s\\033[0m is in your \\033[1;31m\\$PATH\\033[0m environment variable to be able to use distrobox without specifying the full path.\\n\\033[0m\" \"${dest_path}\"\nfi\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "uninstall",
          "type": "blob",
          "size": 2.8837890625,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n#\n# This file is part of the distrobox project: https://github.com/89luca89/distrobox\n#\n# Copyright (C) 2021 distrobox contributors\n#\n# distrobox is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License version 3\n# as published by the Free Software Foundation.\n#\n# distrobox is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with distrobox; if not, see <http://www.gnu.org/licenses/>.\n\n# POSIX\n\nverbose=0\n\n# Print usage to stdout.\n# Arguments:\n#   None\n# Outputs:\n#   print usage with examples.\nshow_help()\n{\n\tcat << EOF\nuninstall --prefix /usr/local\n\nOptions:\n\t--prefix/-P:\t\tbase bath where all files will be deployed (default /usr/local if root, ~/.local if not)\n\t--help/-h:\t\tshow this message\n\t-v:\t\t\tshow more verbosity\nEOF\n}\n\n# Parse arguments\nwhile :; do\n\tcase $1 in\n\t\t-h | --help)\n\t\t\t# Call a \"show_help\" function to display a synopsis, then exit.\n\t\t\tshow_help\n\t\t\texit\n\t\t\t;;\n\t\t-v | --verbose)\n\t\t\tshift\n\t\t\tverbose=1\n\t\t\t;;\n\t\t-p | --path)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tdest_path=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t-P | --prefix)\n\t\t\tif [ -n \"$2\" ]; then\n\t\t\t\tprefix=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\tfi\n\t\t\t;;\n\t\t*) # Default case: If no more options then break out of the loop.\n\t\t\tbreak ;;\n\tesac\ndone\n\nif  [ -z \"${prefix}\" ]; then\n\tprefix=\"/usr/local\"\n\t# in case we're not root, just default to the home directory\n\tif [ \"$(id -u)\" -ne 0 ]; then\n\t\tprefix=\"${HOME}/.local\"\n\tfi\nfi\ndest_path=\"${prefix}/bin\"\nman_dest_path=\"${prefix}/share/man/man1\"\nicon_dest_path=\"${prefix}/share/icons\"\ncompletion_dest_path=\"${prefix}/share/bash-completion/completions/\"\n\nset -o errexit\nset -o nounset\n# set verbosity\nif [ \"${verbose}\" -ne 0 ]; then\n\tset -o xtrace\nfi\n\n[ ! -w \"${dest_path}\" ] && printf >&2 \"Cannot write into %s, permission denied.\\n\" \"${dest_path}\" && exit 1\n[ ! -w \"${man_dest_path}\" ] && printf >&2 \"Cannot write into %s, permission denied.\\n\" \"${man_dest_path}\" && exit 1\n\n# uninstall\nfor file in \"${dest_path}/distrobox\"*; do\n\t[ -e \"${file}\" ] && rm \"${file}\"\ndone\nfor file in \"${man_dest_path}/distrobox\"*; do\n\t[ -e \"${file}\" ] && rm \"${file}\"\ndone\nfor file in \"${completion_dest_path}/distrobox\"*; do\n\t[ -e \"${file}\" ] && rm \"${file}\"\ndone\n[  -e \"${icon_dest_path}\"/terminal-distrobox-icon.svg ] && rm \"${icon_dest_path}\"/terminal-distrobox-icon.svg\n[  -e \"${icon_dest_path}\"/distrobox ] && rm -rf \"${icon_dest_path}\"/distrobox\n\nprintf >&2 \"\\033[1;32m Thank you for using Distrobox. Uninstall complete.\\n\\033[0m\"\nprintf >&2 \"\\033[0m Removed shell scripts located in \\033[1;31m%s\\n\\033[0m\" \"${dest_path}\"\nprintf >&2 \"\\033[0m Removed manpages located in \\033[1;31m%s\\n\\033[0m\" \"${man_dest_path}\"\n"
        }
      ]
    }
  ]
}