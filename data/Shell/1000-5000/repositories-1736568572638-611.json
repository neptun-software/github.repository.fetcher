{
  "metadata": {
    "timestamp": 1736568572638,
    "page": 611,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYxOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "elasticdog/transcrypt",
      "stars": 1499,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2294921875,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.md]\nindent_size = 2\nindent_style = space\ntrim_trailing_whitespace = false\n\n[transcrypt]\nindent_style = tab\ntab_width = 4\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.05078125,
          "content": "sensitive_file  filter=crypt diff=crypt merge=crypt\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 12.60546875,
          "content": "# Changelog for transcrypt\n\nAll notable changes to the project will be documented in this file.\n\nThe format is based on [Keep a Changelog][1], and this project adheres to\n[Semantic Versioning][2].\n\n[1]: https://keepachangelog.com/en/1.0.0/\n[2]: https://semver.org/spec/v2.0.0.html\n\n## Steps to Upgrade\n\nTo upgrade _transcrypt_ it is not enough to have a newer version on your\nsystem, you must also run the `--upgrade` command in each repository:\n\n1. Check the version of _transcrypt_ on your system:\n\n   ```bash\n   $ transcrypt --version\n   ```\n\n2. Check the version of _transcrypt_ in your Git repository, which may be\n   different:\n\n   ```bash\n   $ .git/crypt/transcrypt --version\n   ```\n\n3. Upgrade the version of _transcrypt_ in your Git repository:\n\n   ```\n   $ transcrypt --upgrade\n   ```\n\n## [Unreleased]\n\n### Fixed\n\n- Fix handling of double-quotes in encrypted file names (#173)\n- Make --upgrade safer by failing fast if transcrypt config cannot be read\n  (#189)\n- Fail with error when an empty password is provided to the -p or --password\n  options #188\n- Fix --export-gpg command to properly include cipher in exported .asc file\n\n## [2.3.0] - 2024-09-10\n\n### Added\n\n- Add contexts feature that lets you encrypt different sets of files with\n  different passwords for a different audience, such as super-users versus\n  normal repository users. See `--context=` / `-C` / `--list-context` arguments\n  and documentation for this advanced feature.\n- When transcrypt refuses to do work in a dirty repository, print a list of\n  changed files to help the user understand and fix the issue.\n\n### Fixed\n\n- Prevent `cd` commands printing out excess details when `CDPATH` is set (#156)\n- Fix `--flush` command to work with contexts (#175)\n- Fix unbound variable error using `$GIT_REFLOG_ACTION` (issue #150)\n\n### Changed\n\n- Remove hard dependency on `xxd` which is often a heavy requirement because it\n  is only available with Vim on some platforms. Fall back to `printf` with full\n  %b support or `perl` when either of these are available, and only require\n  `xxd` when it is the only viable option (#181)\n- Prevent global options set in `GREP_OPTIONS` enviroment variable from\n  breaking transcrypt's use of grep (#166)\n- If `CDPATH` is set then cd will print the path (#156)\n- Centralise load and save of password into functions (#141)\n\n## [2.2.3] - 2023-03-09\n\n### Fixed\n\n- Revert faulty automatic fix for mistakenly double-salted encrypted files,\n  which caused more problems than it solved by preventing decryption of some\n  files on some systems #158\n\n### Changed\n\n- The `hexdump` command is no longer required by Transcrypt.\n\n## [2.2.2] - 2023-03-01\n\n### Changed\n\n- The `hexdump` command is now required by Transcrypt. It will be installed\n  already on many systems, or comes with the `bsdmainutils` package on\n  Ubuntu/Debian that was already required to get the `column` command.\n\n### Fixed\n\n- Avoid null byte warnings when decrypting certain files, caused by a work-\n  around in 2.2.1 to repair files that could have been incorrectly encrypted\n  with 2.2.0 due to issue #147\n\n## [2.2.1] - 2023-02-11\n\n### Fixed\n\n- Compatibility fix for LibreSSL versions 3 (and above) especially for MacOS\n  13 Ventura, to more carefully apply a work-around required for OpenSSL 3+\n  that isn't required for LibreSSL 3+ (#147 #133)\n- Fix errors applying a stash containing a secret file that needs to be merged\n  with staged changes to the same file (#150)\n\n## [2.2.0] - 2022-07-09\n\n### Added\n\n- Add `--set-openssl-path` option to configure transcrypt to use a specific\n  openssl version instead of the default version found in `$PATH`. This will be\n  most useful to macOS users who might want to use a newer version of OpenSSL.\n  This option can be used on init, on upgrade, or by itself.\n- Add support for an optional `transcrypt.crypt-dir` setting for advanced users\n  to override the path of the _.git/crypt/_ directory to permit things like\n  installing transcrypt in a repository on a device without execute\n  permissions (#104)\n\n### Changed\n\n- No longer need stand-alone scripts for git operations `clean`, `smudge`,\n  `textconv`, and `merge` in the repository's _crypt/_ directory; the single\n  consolidated `transcrypt` script is stored there instead.\n\n### Fixed\n\n- Remain compatible with OpenSSL versions 3 and above which changes the way\n  explicit salt values are expressed in ciphertext, requires `xxd` command (#133)\n- Ensure Git index is up-to-date before checking for dirty repo, to avoid\n  failures seen in CI systems where the repo seems dirty when it isn't. (#37)\n- Respect Git `core.hooksPath` setting when installing the pre-commit hook. (#104)\n- Zsh completion. (#107)\n- Fix salt generation for partial (patch) commits (#118)\n- Improve command hint to fix secret files not encrypted in index (#120)\n- Fix handling of files with null in first 8 bytes (#116)\n\n## [2.1.0] - 2020-09-07\n\nThis release includes features to make it easier and safer to use transcrypt, in\nparticular: fix merge of encrypted files with conflicts, preventing accidental\ncommit of plain text files by incompatible Git tools, and upgrade easily with\n`--upgrade`.\n\n### Steps to Upgrade\n\n1. Make sure you are running the latest version of _transcrypt_:\n\n   ```\n   $ transcrypt --version\n   ```\n\n2. Upgrade a repository:\n\n   ```\n   $ transcrypt --upgrade\n   ```\n\n3. Enable the merge handling fix by adding `merge=crypt` to the end of each\n   _transcrypt_ pattern in `.gitattribute`, to look like this:\n\n   ```\n   sensitive_file  filter=crypt diff=crypt merge=crypt\n   ```\n\n### Added\n\n- Add `--upgrade` command to apply the latest transcrypt scripts in an already\n  configured repository without the need to re-apply existing settings.\n- Install a Git pre-commit hook to reject accidental commit of unencrypted plain\n  text version of sensitive files, which could otherwise happen if a tool does\n  not respect the `.gitattribute` filters Transcrypt needs to do its job.\n\n### Changed\n\n- Add a functional test suite built on\n  [bats-core](https://github.com/bats-core/bats-core#installation).\n- Apply Continuous Integration: run functional tests with GitHub Actions.\n- Fix [EditorConfig](https://editorconfig.org/) file config for Markdown files.\n- Add [CHANGELOG.md](CHANGELOG.md) file to make it easier to find notes about\n  project changes (see also Release)\n\n### Fixed\n\n- Fix handling of branch merges with conflicts in encrypted files, which would\n  previously leave the user to manually merge files with a mix of encrypted and\n  unencrypted content. (#69, #8, #23, #67)\n- Remove any cached unencrypted files from Git's object database when\n  credentials are removed from a repository with a flush or uninstall, so\n  sensitive file data does not remain accessible in a surprising way. (#74)\n- Fix handling of sensitive files with non-ASCII file names, such as extended\n  Unicode characters. (#78)\n- transcrypt `--version` and `--help` commands now work when run outside a Git\n  repository. (#68)\n- The `--list` command now works in a repository that has not yet been init-ed.\n\n## [2.0.0] - 2019-07-20\n\n**\\*\\*\\* WARNING: Re-encryption will be required when updating to version 2.0.0!\n\\*\\*\\***\n\nThis is not a security issue, but the result of a\n[bug fix](https://github.com/elasticdog/transcrypt/pull/57) to ensure that the\nsalt generation is consistent across all operating systems. Once someone on your\nteam updates to version 2.0.0, it will manifest as the encrypted files in your\nrepository showing as _changed_. You should ensure that all users upgrade at the\nsame time...since `transcrypt` itself is small, it may make sense to commit the\nscript directly into your repo to maintain consistency moving forward.\n\n### Steps to Re-encrypt\n\nAfter you've upgraded to v2.0.0...\n\n1. Display the current config so you can reference the command to re-initialize\n   things:\n\n   ```\n   $ transcrypt --display\n   The current repository was configured using transcrypt version 1.1.0\n   and has the following configuration:\n\n     GIT_WORK_TREE:  /home/elasticdog/src/transcrypt\n     GIT_DIR:        /home/elasticdog/src/transcrypt/.git\n     GIT_ATTRIBUTES: /home/elasticdog/src/transcrypt/.gitattributes\n\n     CIPHER:   aes-256-cbc\n     PASSWORD: correct horse battery staple\n\n   Copy and paste the following command to initialize a cloned repository:\n\n     transcrypt -c aes-256-cbc -p 'correct horse battery staple'\n   ```\n\n2. Flush the credentials and re-configure the repo with the same settings as\n   above:\n\n   ```\n   $ transcrypt --flush-credentials\n   $ transcrypt -c aes-256-cbc -p 'correct horse battery staple'\n   ```\n\n3. Now that all of the appropriate files have been re-encrypted, add them and\n   commit the changes:\n   ```\n   $ git add -- $(transcrypt --list)\n   $ git commit --message=\"Re-encrypt files protected by transcrypt using new salt value\"\n   ```\n\n### Changed\n\n- Add an [EditorConfig](https://editorconfig.org/) file to help with consistency\n  in formatting (#51)\n- Use\n  [unofficial Bash strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)\n  for safety (#53)\n- Reformat files using the automated formatting tools\n  [Prettier](https://prettier.io/) and [shfmt](https://github.com/mvdan/sh)\n- Ensure that `transcrypt` addresses all\n  [ShellCheck](https://github.com/koalaman/shellcheck) static analysis warnings\n\n### Fixed\n\n- Force the use of macOS's system `sed` binary to prevent errors (#50)\n- Fix cross-platform compatibility by making salt generation logic consistent\n  (#57)\n\n## [1.1.0] - 2018-05-26\n\n### Fixed\n\n- Fix broken cipher validation safety check when running with OpenSSL v1.1.0+.\n  (#48)\n\n## [1.0.3] - 2017-08-21\n\n### Fixed\n\n- Explicitly set digest hash function to match default settings before OpenSSL\n  v1.1.0. (#41)\n\n## [1.0.2] - 2017-04-06\n\n### Fixed\n\n- Ensure realpath function does not incorrectly return the current directory for\n  certain inputs. (#38)\n\n## [1.0.1] - 2017-01-06\n\n### Fixed\n\n- Correct the behavior of `mktemp` when running on OS X versions 10.10 Yosemite\n  and earlier.\n- Prevent unexpected error output when running transcrypt outside of a Git\n  repository.\n\n## [1.0.0] - 2017-01-02\n\nSince the v0.9.9 release, these are the notable improvements made to transcrypt:\n\n- properly handle file names with spaces\n- adjust usage of `mktemp` utility to be more cross-platform\n- additional safety checks for all required cli utility dependencies\n\n## [0.9.9] - 2016-09-05\n\nSince the v0.9.7 release, these are the notable improvements made to transcrypt:\n\n- support for use of a\n  [wildcard](https://github.com/elasticdog/transcrypt/commit/a0b7d4ec0296e83974cb02be640747149b23ef54)\n  with `--show-raw` to dump the raw commit objects for _all_ encrypted files\n- GPG import/export of repository configuration\n- more\n  [strict filter script behavior](https://github.com/elasticdog/transcrypt/pull/29)\n  to adhere to upstream recommendations\n- automatic caching of the decrypted content for faster Git operations like\n  `git log -p`\n- ability to configure bare repositories\n- ability to configure \"fake bare\" repositories for use through\n  [vcsh](https://github.com/RichiH/vcsh)\n- ability configure multiple worktrees via\n  [git-workflow](https://github.com/blog/2042-git-2-5-including-multiple-worktrees-and-triangular-workflows)\n- support for unencrypted archive exporting via\n  [git-archive](https://git-scm.com/docs/git-archive)\n\n## [0.9.8] - 2016-09-05\n\n## [0.9.7] - 2015-03-23\n\n## [0.9.6] - 2014-08-30\n\n## [0.9.5] - 2014-08-23\n\n## [0.9.4] - 2014-03-03\n\n[unreleased]: https://github.com/elasticdog/transcrypt/compare/v2.3.0...HEAD\n[2.3.0]: https://github.com/elasticdog/transcrypt/compare/v2.2.3...v2.3.0\n[2.2.3]: https://github.com/elasticdog/transcrypt/compare/v2.2.2...v2.2.3\n[2.2.2]: https://github.com/elasticdog/transcrypt/compare/v2.2.1...v2.2.2\n[2.2.1]: https://github.com/elasticdog/transcrypt/compare/v2.2.0...v2.2.1\n[2.2.0]: https://github.com/elasticdog/transcrypt/compare/v2.1.0...v2.2.0\n[2.1.0]: https://github.com/elasticdog/transcrypt/compare/v2.0.0...v2.1.0\n[2.0.0]: https://github.com/elasticdog/transcrypt/compare/v1.1.0...v2.0.0\n[1.1.0]: https://github.com/elasticdog/transcrypt/compare/v1.0.3...v1.1.0\n[1.0.3]: https://github.com/elasticdog/transcrypt/compare/v1.0.2...v1.0.3\n[1.0.2]: https://github.com/elasticdog/transcrypt/compare/v1.0.1...v1.0.2\n[1.0.1]: https://github.com/elasticdog/transcrypt/compare/v1.0.0...v1.0.1\n[1.0.0]: https://github.com/elasticdog/transcrypt/compare/v0.9.9...v1.0.0\n[0.9.9]: https://github.com/elasticdog/transcrypt/compare/v0.9.8...v0.9.9\n[0.9.8]: https://github.com/elasticdog/transcrypt/compare/v0.9.7...v0.9.8\n[0.9.7]: https://github.com/elasticdog/transcrypt/compare/v0.9.6...v0.9.7\n[0.9.6]: https://github.com/elasticdog/transcrypt/compare/v0.9.5...v0.9.6\n[0.9.5]: https://github.com/elasticdog/transcrypt/compare/v0.9.4...v0.9.5\n[0.9.4]: https://github.com/elasticdog/transcrypt/releases/tag/v0.9.4\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 2.216796875,
          "content": "# Install transcrypt\n\nThe requirements to run transcrypt are minimal:\n\n- Bash\n- Git\n- OpenSSL\n- `column` command (on Ubuntu/Debian install `bsdmainutils`)\n- if using OpenSSL 3+ one of: `xxd` (on Ubuntu/Debian is included with `vim`)\n  or `printf` command (with %b directive) or `perl`\n\n...and optionally:\n\n- GnuPG - for secure configuration import/export\n\nYou also need access to the _transcrypt_ script itself...\n\n## Manual Installation\n\nYou can add transcrypt directly to your repository, or just put it somewhere in\nyour $PATH:\n\n    $ git clone https://github.com/elasticdog/transcrypt.git\n    $ cd transcrypt/\n    $ sudo ln -s ${PWD}/transcrypt /usr/local/bin/transcrypt\n\n## Installation via Packages\n\nA number of packages are available for installing transcrypt directly on your\nsystem via its native package manager. Some of these packages also include man\npage documentation as well as shell auto-completion scripts.\n\n### Arch Linux\n\nIf you're on Arch Linux, you can build/install transcrypt using the\n[provided PKGBUILD](https://github.com/elasticdog/transcrypt/blob/main/contrib/packaging/pacman/PKGBUILD):\n\n    $ git clone https://github.com/elasticdog/transcrypt.git\n    $ cd transcrypt/contrib/packaging/pacman/\n    $ makepkg -sic\n\n### Heroku\n\nIf you're running software on Heroku, you can integrate transcrypt into your\nslug compilation phase by using the\n[transcrypt buildpack](https://github.com/perplexes/heroku-buildpack-transcrypt),\ndeveloped by [Colin Curtin](https://github.com/perplexes).\n\n### NixOS\n\nIf you're on NixOS, you can install transcrypt directly via\n[Nix](https://nixos.org/nix/):\n\n    $ nix-env -iA nixos.gitAndTools.transcrypt\n\n> _**Note:**\n> The [transcrypt derivation](https://github.com/NixOS/nixpkgs/blob/main/pkgs/applications/version-management/git-and-tools/transcrypt/default.nix)\n> was added in Oct 2015, so it is not available on the 15.09 channel._\n\n### OS X\n\nIf you're on OS X, you can install transcrypt directly via\n[Homebrew](http://brew.sh/):\n\n    $ brew install transcrypt\n\n### FreeBSD\n\nIf you're on FreeBSD, you can install transcrypt directly via the Ports\ncollection:\n\n    # `cd /usr/ports/security/transcrypt && make install clean distclean`\n\nor via the packages system:\n\n    # `pkg install -y security/transcrypt`\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.119140625,
          "content": "Copyright (c) 2014-2019, Aaron Bull Schaefer <aaron@elasticdog.com>\nCopyright (c) 2011, Woody Gilk <woody.gilk@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.5595703125,
          "content": "# transcrypt\n\nA script to configure transparent encryption of sensitive files stored in a Git\nrepository. Files that you choose will be automatically encrypted when you\ncommit them, and automatically decrypted when you check them out. The process\nwill degrade gracefully, so even people without your encryption password can\nsafely commit changes to the repository's non-encrypted files.\n\ntranscrypt protects your data when it's pushed to remotes that you may not\ndirectly control (e.g., GitHub, Dropbox clones, etc.), while still allowing you\nto work normally on your local working copy. You can conveniently store things\nlike passwords and private keys within your repository and not have to share\nthem with your entire team or complicate your workflow.\n\n![Tests](https://github.com/elasticdog/transcrypt/workflows/Tests/badge.svg)\n\n## Overview\n\ntranscrypt is in the same vein as existing projects like\n[git-crypt](https://github.com/AGWA/git-crypt) and\n[git-encrypt](https://github.com/shadowhand/git-encrypt), which follow Git's\ndocumentation regarding the use of clean/smudge filters for encryption. In\ncomparison to those other projects, transcrypt makes substantial improvements in\nthe areas of usability and safety.\n\n- transcrypt is just a Bash script and does not require compilation\n- transcrypt uses OpenSSL's symmetric cipher routines rather than implementing\n  its own crypto\n- transcrypt does not have to remain installed after the initial repository\n  configuration\n- transcrypt generates a unique salt for each encrypted file\n- transcrypt uses safety checks to avoid clobbering or duplicating configuration\n  data\n- transcrypt facilitates setting up additional clones as well as rekeying\n- transcrypt adds an alias `git ls-crypt` to list all encrypted files\n\n### Salt Generation\n\nThe _decryption -> encryption_ process on an unchanged file must be\ndeterministic for everything to work transparently. To do that, the same salt\nmust be used each time we encrypt the same file. Rather than use a static salt\ncommon to all files, transcrypt first has OpenSSL generate an HMAC-SHA256\ncryptographic hash-based message authentication code for each decrypted file\n(keyed with a combination of the filename and transcrypt password), and then\nuses the last 16 bytes of that HMAC for the file's unique salt. When the content\nof the file changes, so does the salt. Since an\n[HMAC has been proven to be a PRF](http://cseweb.ucsd.edu/~mihir/papers/hmac-new.html),\nthis method of salt selection does not leak information about the original\ncontents, but is still deterministic.\n\n## Usage\n\nThe requirements to run transcrypt are minimal:\n\n- Bash\n- Git\n- OpenSSL\n- `column` and `hexdump` commands (on Ubuntu/Debian install `bsdmainutils`)\n- if using OpenSSL 3+ one of: `xxd` (on Ubuntu/Debian is included with `vim`)\n  or `printf` command (with %b directive) or `perl`\n\n...and optionally:\n\n- GnuPG - for secure configuration import/export\n\nYou also need access to the _transcrypt_ script itself. You can add it directly\nto your repository, or just put it somewhere in your \\$PATH:\n\n    $ git clone https://github.com/elasticdog/transcrypt.git\n    $ cd transcrypt/\n    $ sudo ln -s ${PWD}/transcrypt /usr/local/bin/transcrypt\n\n#### Installation via Packages\n\nA number of packages are available for installing transcrypt directly on your\nsystem via its native package manager. Some of these packages also include man\npage documentation as well as shell auto-completion scripts.\n\n- Arch Linux\n- Heroku (via [Buildpacks](https://devcenter.heroku.com/articles/buildpacks))\n- NixOS\n- OS X (via [Homebrew](http://brew.sh/))\n\n...see the [INSTALL document](INSTALL.md) for more details.\n\n### Initialize an Unconfigured Repository\n\ntranscrypt will interactively prompt you for the required information, all you\nhave to do run the script within a Git repository:\n\n    $ cd <path-to-your-repo>/\n    $ transcrypt\n\nIf you already know the values you want to use, you can specify them directly\nusing the command line options. Run `transcrypt --help` for more details.\n\n### Designate a File to be Encrypted\n\nOnce a repository has been configured with transcrypt, you can designate for\nfiles to be encrypted by applying the \"crypt\" filter, diff, and merge to a\n[pattern](https://www.kernel.org/pub/software/scm/git/docs/gitignore.html#_pattern_format)\nin the top-level _[.gitattributes](http://git-scm.com/docs/gitattributes)_\nconfig. If that pattern matches a file in your repository, the file will be\ntransparently encrypted once you stage and commit it:\n\n    $ cd <path-to-your-repo>/\n    $ echo 'sensitive_file  filter=crypt diff=crypt merge=crypt' >> .gitattributes\n    $ git add .gitattributes sensitive_file\n    $ git commit -m 'Add encrypted version of a sensitive file'\n\nThe _.gitattributes_ file should be committed and tracked along with everything\nelse in your repository so clones will be aware of what is encrypted. Make sure\nyou don't accidentally add a pattern that would encrypt this file :-)\n\n> For your reference, if you find the above description confusing, you'll find\n> that this repository has been configured following these exact steps.\n\n### Listing the Currently Encrypted Files\n\nFor convenience, transcrypt also adds a Git alias to allow you to list all of\nthe currently encrypted files in a repository:\n\n    $ git ls-crypt\n    sensitive_file\n\nAlternatively, you can use the `--list` command line option:\n\n    $ transcrypt --list\n    sensitive_file\n\nYou can also use this to verify your _.gitattributes_ patterns when designating\nnew files to be encrypted, as the alias will list pattern matches as long as\neverything has been staged (via `git add`).\n\nAfter committing things, but before you push to a remote repository, you can\nvalidate that files are encrypted as expected by viewing them in their raw form:\n\n    $ git show HEAD:<path-to-file> --no-textconv\n\nThe `<path-to-file>` in the above command must be relative to the _top-level_ of\nthe repository. Alternatively, you can use the `--show-raw` command line option\nand provide a path relative to your current directory:\n\n    $ transcrypt --show-raw sensitive_file\n\n### Initialize a Clone of a Configured Repository\n\nIf you have just cloned a repository containing files that are encrypted, you'll\nwant to configure transcrypt with the same cipher and password as the origin\nrepository. The owner of the origin repository can dump the credentials for you\nby running the `--display` command line option:\n\n    $ transcrypt --display\n    The current repository was configured using transcrypt v0.2.0\n    and has the following configuration:\n\n      CONTEXT:  default\n      CIPHER:   aes-256-cbc\n      PASSWORD: correct horse battery staple\n\n    Copy and paste the following command to initialize a cloned repository:\n\n      transcrypt -c aes-256-cbc -p 'correct horse battery staple'\n\nOnce transcrypt has stored the matching credentials, it will force a checkout of\nany exising encrypted files in order to decrypt them.\n\n### Rekeying\n\nPeriodically, you may want to change the encryption cipher or password used to\nencrypt the files in your repository. You can do that easily with transcrypt's\nrekey option:\n\n    $ transcrypt --rekey\n\n> As a warning, rekeying will remove your ability to see historical diffs of the\n> encrypted files in plain text. Changes made with the new key will still be\n> visible, and you can always see the historical diffs in encrypted form by\n> disabling the text conversion filters:\n>\n>     $ git log --patch --no-textconv\n\nAfter rekeying, all clones of your repository should flush their transcrypt\ncredentials, fetch and merge the new encrypted files via Git, and then\nre-configure transcrypt with the new credentials.\n\n    $ transcrypt --flush-credentials\n    $ git fetch origin\n    $ git merge origin/main\n    $ transcrypt -c aes-256-cbc -p 'the-new-password'\n\n### Command Line Options\n\nCompletion scripts for both Bash and Zsh are included in the _contrib/_\ndirectory.\n\n    transcrypt [option...]\n\n      -c, --cipher=CIPHER\n             the symmetric cipher to utilize for encryption;\n             defaults to aes-256-cbc\n\n      -p, --password=PASSWORD\n             the password to derive the key from;\n             defaults to 30 random base64 characters\n\n      --set-openssl-path=PATH_TO_OPENSSL\n             use OpenSSL at this path; defaults to 'openssl' in $PATH\n\n      -y, --yes\n             assume yes and accept defaults for non-specified options\n\n      -d, --display\n             display the current repository's cipher and password\n\n      -r, --rekey\n             re-encrypt all encrypted files using new credentials\n\n      -f, --flush-credentials\n             remove the locally cached encryption credentials and  re-encrypt\n             any files that had been previously decrypted\n\n      -F, --force\n             ignore whether the git directory is clean, proceed with the\n             possibility that uncommitted changes are overwritten\n\n      -u, --uninstall\n             remove  all  transcrypt  configuration  from  the repository and\n             leave files in the current working copy decrypted\n\n       --upgrade\n             uninstall and re-install transcrypt configuration in the repository\n             to apply the newest scripts and .gitattributes configuration\n\n      -l, --list\n             list all of the transparently encrypted files in the repository,\n             relative to the top-level directory\n\n      -s, --show-raw=FILE\n             show  the  raw file as stored in the git commit object; use this\n             to check if files are encrypted as expected\n\n      -e, --export-gpg=RECIPIENT\n             export  the  repository's cipher and password to a file encrypted\n             for a gpg recipient\n\n      -i, --import-gpg=FILE\n             import the password and cipher from a gpg encrypted file\n\n      -C, --context=CONTEXT_NAME\n             name for a context  with a different passphrase  and cipher from\n             the  'default' context;   use this  advanced option  to  encrypt\n             different files with different passphrases\n\n      --list-contexts\n             list all contexts configured in the  repository,  and warn about\n             incompletely configured contexts\n\n      -v, --version\n             print the version information\n\n      -h, --help\n             view this help message\n\n## Caveats\n\n### Overhead\n\nThe method of using filters to selectively encrypt/decrypt files does add some\noverhead to Git by regularly forking OpenSSL processes and removing Git's\nability to efficiently cache file changes. That said, it's not too different\nfrom tracking binary files, and when used as intended, transcrypt should not\nnoticeably impact performance. There are much better options if your goal is to\nencrypt the entire repository.\n\n### Localhost\n\nNote that the configuration and encryption information is stored in plain text\nwithin the repository's _.git/config_ file. This prevents them from being\ntransferred to remote clones, but they are not protected from inquisitive users\non your local machine.\n\nFor safety, you may prefer to only have the credentials stored when actually\nupdating encrypted files, and then flush them with `--flush-credentials` once\nyou're done (make sure you have the credentials backed up elsewhere!). This will\nalso revert any decrypted files back to their encrypted form in your local\nworking copy.\n\n### Cipher Selection\n\nLast up, regarding the default cipher choice of `aes-256-cbc`...there aren't any\nfantastic alternatives without pulling in outside dependencies. Ideally, we\nwould use an authenticated cipher mode like `id-aes256-GCM` by default, but\nthere are a couple of issues:\n\n1. I'd like to support OS X out of the box, and unfortunately they are the\n   lowest common denominator when it comes to OpenSSL. For whatever reason, they\n   still include OpenSSL 0.9.8y rather than a newer release. Unfortunately,\n   GCM-based ciphers weren't added until OpenSSL 1.0.1 (back in early 2012).\n\n2. Even with newer versions of OpenSSL, the authenticated cipher modes\n   [don't work exactly right](http://openssl.6102.n7.nabble.com/id-aes256-GCM-command-line-encrypt-decrypt-fail-td27187.html)\n   when utilizing the command line `openssl enc`.\n\nI'm contemplating if transcrypt should append an HMAC to the `aes-256-cbc`\nciphertext to provide authentication, or if we should live with the\n[malleability issues](http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/)\nas a known limitation. Essentially, malicious comitters without the transcrypt\npassword could potentially manipulate the plaintext in limited ways (given that\nthe attacker knows the original plaintext). Honestly, I'm not sure if the added\ncomplexity here would be worth it given transcrypt's use case.\n\n## Advanced\n\n### Contexts\n\nContext names let you encrypt some files with different passwords for a\ndifferent audience, such as super-users. The 'default' context applies unless\nyou set a context name.\n\nAdd a context by reinitialising transcrypt with a context name then add a\npattern with crypt-<CONTEXT*NAME> attributes to *.gitattributes*. For example,\nto encrypt a file \\_top-secret* in a \"super\" context:\n\n    # Initialise a new \"super\" context, and set a different password\n    $ transcrypt --context=super\n\n    # Add a pattern to .gitattributes with \"crypt-super\" values\n    $ echo >> .gitattributes \\\\\n      'top-secret filter=crypt-super diff=crypt-super merge=crypt-super'\n\n    # Add and commit your top-secret and .gitattribute files\n    $ git add .gitattributes top-secret\n    $ git commit -m \"Add top secret file for super-users only\"\n\n    # List all contexts\n    $ transcrypt --list-contexts\n\n    # Display the cipher and password for the \"super\" context\n    $ transcrypt --context=super --display\n\n## License\n\ntranscrypt is provided under the terms of the\n[MIT License](https://en.wikipedia.org/wiki/MIT_License).\n\nCopyright &copy; 2014-2020, [Aaron Bull Schaefer](mailto:aaron@elasticdog.com).\n\n## Contributing\n\n### Linting and formatting\n\nPlease use:\n\n- the [shellcheck](https://www.shellcheck.net) tool to check for subtle bash\n  scripting errors in the _transcrypt_ file, and apply the recommendations when\n  possible. E.g: `shellcheck transcrypt`\n- the [shfmt](https://github.com/mvdan/sh) tool to apply consistent formatting\n  to the _transcrypt_ file, e.g: `shfmt -w transcrypt`\n- the [Prettier](https://prettier.io) tool to apply consistent formatting to the\n  _README.md_ file, e.g: `prettier --write README.md`\n\n### Tests\n\nTests are written using [bats-core](https://github.com/bats-core/bats-core)\nversion of \"Bash Automated Testing System\" and stored in the _tests/_ directory.\n\nTo run the tests:\n\n- [install bats-core](https://github.com/bats-core/bats-core#installation)\n- run all tests with: `bats tests/`\n- run an individual test with e.g: `bats tests/test_crypt.bats`\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "sensitive_file",
          "type": "blob",
          "size": 2.5,
          "content": "U2FsdGVkX1//6vyAEUROfUrBgZuXaA15WddyGnu4qyMwDAzBjDpLwEqdK+lGuahk\nzcurTKIJ36gmdZSd5f2928EQaHGdusIRGzjWfWQ720UUTYzERPuJxGVQSXZIA7a4\no7t2LdFOloWw5g3SRWn+cPBt8lvLkuVuA4x+B4MuzBR0qq7qsk5Qvywfuk2In4Fh\ngWMWnUFDpdO/dUPefgZ1okXwWmb2bna7hr7j7Q1Qz+X8/ZPV7epZfonTOCvILVDy\nqJlhhH+qrkUwpS8qKMBwyfsNEdKFm60fhPCjWZxyS475Pc3DcG9CQX+AkQqG0frA\naViFCpUkUClSJtoFCg+PaUHPbiN4g/OG7rUcIfVuFDH3Stz3CuqtzJSNkPKNX0Zm\n4xgViApifWvPIijXl/VIHQ7SdzaYiWo2u1G5dCXQw39VnTikx+HWn85wgy0F9IoR\nc6FiowxnGsl3ErIwyvuFOqeI8/Xge/7bgWmzqVZSLrpFMPjM/JNO7htRslByo0LD\nh5+ngarmfzhI8fspFkmUJWN7YulBRKe4Zh5mohPLhXp/+27KdHC/kBWJtuWUTBx9\nRV8cp/g/uIQ6hr/qAnWLdxHgANExGXuf/1zVJYacfnP5cKEqmhYq4gyjs04n8w3a\ngjpINQ8bUVzl3rEEv47nlT7o6ZYCxVL4WjWqcCB75KYvDtkDG+lIbu5SBQ1GwW8q\nuvcdpV1l9UdXrVuPJvcXLn28xL2KItyfoa/T8rGERrSu875/hwunNmArclvv1UCW\nZRzOhZYMGTHQY5TDC7H05Lwx1wiwRoKJnd+iaE9pw80WnSyarkFkokoHjoBBIO6W\nIn+mUDJWSg+VTcJxsT91OmKQyfqGYSm3NRshcvhDgyX/Nle2ixtk1KbBM1+06Cyg\nzWQ2My4uYJtQAU3RYsC3fIPw9QYfwpyrChVzFVImQwGixInNCm3hilEju9MuwKkT\n9yU7oKnZO5027UrwYb7nn8tUab92R3qpfwkR+ZXspTi5CjBZnU61/yw+7Klv8yBQ\nrXfRXVncM2tdcVWlrq7GaRwN3byeo87EQ6/QqyzwHOpNWomk6MHcIAy6pTY6ZIDs\nhDrBwUkBDrIyQYntHDAR4LICepnrkouWydW6A5jqR5ySpchsSPSHdR41UcouPtmA\nhKk1iYMS9TNu3eG69KiKAZ3djYb2GQl8Z1r/1SGAtKj263nUjazWBUkGuzdNX0ny\nyuqXYgXd+lh4YOuL7Dn8JyW5s0IctFj6D4gUnvG4lV/rZYOusIG5rxZn9+c88Did\nVWrMzIuAzbWQXweHA8EVZVb+ntqVKpYKixrLdmjNTt21oYW6LgFdxio8gyq6YGMT\nvjG6G/5ZM30WOsso4XFp+8i7GzVKNXQrZSEZKbEqrD/+RICVUxzXLRVXm66nfW0r\nxEhbuO9v6khlhM6Px1e1seyPZekvBskrB4n8CYsrTTqYww136r/WHZ8/VO+Xu0iN\n1Bt+73pln+PjxiEkIcoHFaCqkqbzHjgGLXeWkfy+0tK/Yr8sTVOrzqNccDg5os98\nUyZG3psbOjuw8JOj2TgLVBIDJWejQLBdewflRviinAzM3jcfAS/GejhMK4NQrdm2\nSAXhMU+32lnJUfqEzkT3LY1PUxBWFwU0IHTQuqp23v23lFOUt4xKo9+TvbDu7V/W\n8BzmtXMZl2PPTOvuEbpu8AfzzvUFkuOktKrlAGNIijx39fabFr+46rra46BeT1XG\nyP3LQcXB5pkjQnwl10BKOGXE014R5BmiAkcyEZiF4ZLhHFpmCJP7U/xDA4g5H4AX\n7WLNu1Mn/IvM7U2Y4AwTJy1GFLCufxL5MRjmAlMwhwebwRvhi3Pamh/StzjssQ1h\n2jgJ+z86DndYpeqg9A7KAMX2FBAry9YbyTT28LNnZRjSRAOWqwRFkFBHryTFgwA2\nIKbR/mA/BFavB7UoxBEmijPTs/IbAoXGgQUN6g3DKCfaHbeTJPI8GPemmkA6AYgb\ngDE/nVNe8ajQvzktXcM27ivLhjeHVjtCJYjsC3p6GFAMu6/LxKE0hWFRRnMw3RbR\nBmx8n5DWfRCJVgF+pbOah0tPL7iYa4+lprBBGClLpGP4/1KWmSCkxPa2l6QenY0D\nC7m0hPUpL99PoAQCvCGssfLzdpDHdb0ZK808CwLnypBd52mSROpHk/4RQ3S0v68R\nLpLRdEL0aDBQgHWD374YihPM0dYG7pCghTxuKSZXouQkscQ6xoqxVxyWhTRMcTBz\n9ggEdI0dRV8AY+HSkpOW2Ixca1Opn3UIfznQe7JaPXzpk2j3oRR9A2uXcif+zfp2\nIRIqhSa+oP/1wo9RxLybnoheMPZftRqpabjR9AnOzt9KLt/9mu7/lF8YWhALLu6h\ndLukBe1mEeVsQQ8CNcKqFK80jNCx7sR6QZCWyaxcgqw6YtOQ7ZszPRSHtCLgcGHc\nBY9xgAUe3FaJszt5bed9Cxh/FvY7lQwWkLvVscS/IDtA+sq8Ww3D4/JyqEMaaZcY\nL/aeTVBw2BnDs2K48meuFw==\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "transcrypt",
          "type": "blob",
          "size": 52.525390625,
          "content": "#!/usr/bin/env bash\nset -euo pipefail\n\n#\n# transcrypt - https://github.com/elasticdog/transcrypt\n#\n# A script to configure transparent encryption of sensitive files stored in\n# a Git repository. It utilizes OpenSSL's symmetric cipher routines and follows\n# the gitattributes(5) man page regarding the use of filters.\n#\n# Copyright (c) 2014-2019 Aaron Bull Schaefer <aaron@elasticdog.com>\n# This source code is provided under the terms of the MIT License\n# that can be be found in the LICENSE file.\n#\n\n##### OVERRIDES\n\n# Disable any global grep options, to avoid problems like '--colors=always'\n# shellcheck disable=SC2034\nGREP_OPTIONS=\"\"\n\n##### CONSTANTS\n\n# the release version of this script\nreadonly VERSION='2.3.1-pre'\n\n# the default cipher to utilize\nreadonly DEFAULT_CIPHER='aes-256-cbc'\n\n# context name must match this regexp to ensure it is safe for git config and attrs\nreadonly CONTEXT_REGEX='[a-z](-?[a-z0-9])*'\n\n##### FUNCTIONS\n\n# load encryption password\n# by default is stored in git config, modify this function to move elsewhere\nload_password() {\n\tlocal context_config_group=${1:-}\n\tlocal password\n\tpassword=$(git config --get --local \"transcrypt${context_config_group}.password\")\n\techo \"$password\"\n}\n\n# save encryption password\n# by default is stored in git config, modify this function to move elsewhere\nsave_password() {\n\tlocal password=$1\n\tlocal context_config_group=${2:-}\n\tgit config \"transcrypt${context_config_group}.password\" \"$password\"\n}\n\n# print a canonicalized absolute pathname\nrealpath() {\n\tlocal path=$1\n\n\t# make path absolute\n\tlocal abspath=$path\n\tif [[ -n ${abspath##/*} ]]; then\n\t\tabspath=$(pwd -P)/$abspath\n\tfi\n\n\t# canonicalize path\n\tlocal dirname=\n\tif [[ -d $abspath ]]; then\n\t\tdirname=$(cd \"$abspath\" >/dev/null && pwd -P)\n\t\tabspath=$dirname\n\telif [[ -e $abspath ]]; then\n\t\tdirname=$(cd \"${abspath%/*}/\" >/dev/null 2>/dev/null && pwd -P)\n\t\tabspath=$dirname/${abspath##*/}\n\tfi\n\n\tif [[ -d $dirname && -e $abspath ]]; then\n\t\tprintf '%s\\n' \"$abspath\"\n\telse\n\t\tprintf 'invalid path: %s\\n' \"$path\" >&2\n\t\texit 1\n\tfi\n}\n\n# establish repository metadata and directory handling\n# shellcheck disable=SC2155\ngather_repo_metadata() {\n\t# whether or not transcrypt is already configured\n\treadonly INSTALLED_VERSION=$(git config --get --local transcrypt.version 2>/dev/null)\n\n\t# the current git repository's top-level directory\n\treadonly REPO=$(git rev-parse --show-toplevel 2>/dev/null)\n\n\t# whether or not a HEAD revision exists\n\treadonly HEAD_EXISTS=$(git rev-parse --verify --quiet HEAD 2>/dev/null)\n\n\t# https://github.com/RichiH/vcsh\n\t# whether or not the git repository is running under vcsh\n\treadonly IS_VCSH=$(git config --get --local --bool vcsh.vcsh 2>/dev/null)\n\n\t# whether or not the git repository is bare\n\treadonly IS_BARE=$(git rev-parse --is-bare-repository 2>/dev/null || printf 'false')\n\n\t# the current git repository's .git directory\n\treadonly RELATIVE_GIT_DIR=$(git rev-parse --git-dir 2>/dev/null || printf '')\n\treadonly GIT_DIR=$(realpath \"$RELATIVE_GIT_DIR\" 2>/dev/null)\n\n\t# Respect transcrypt.crypt-dir if present. Default to crypt/ in Git dir\n\treadonly CRYPT_DIR=$(git config transcrypt.crypt-dir 2>/dev/null || printf '%s/crypt' \"${RELATIVE_GIT_DIR}\")\n\n\t# respect core.hooksPath setting, without trailing slash. Fall back to default hooks dir\n\treadonly GIT_HOOKS=$(git config core.hooksPath | sed 's:/*$::' 2>/dev/null || printf \"%s/hooks\" \"${RELATIVE_GIT_DIR}\")\n\n\t# the current git repository's gitattributes file\n\tlocal CORE_ATTRIBUTES\n\tCORE_ATTRIBUTES=$(git config --get --local --path core.attributesFile 2>/dev/null || git config --get --path core.attributesFile 2>/dev/null || printf '')\n\tif [[ $CORE_ATTRIBUTES ]]; then\n\t\treadonly GIT_ATTRIBUTES=$CORE_ATTRIBUTES\n\telif [[ $IS_BARE == 'true' ]] || [[ $IS_VCSH == 'true' ]]; then\n\t\treadonly GIT_ATTRIBUTES=\"${GIT_DIR}/info/attributes\"\n\telse\n\t\treadonly GIT_ATTRIBUTES=\"${REPO}/.gitattributes\"\n\tfi\n\n\t# fetch list of context names already configured or in .gitattributes\n\treadonly CONFIGURED_CONTEXTS=$(get_contexts_from_git_config)\n\treadonly GITATTRIBUTES_CONTEXTS=$(get_contexts_from_git_attributes)\n}\n\n# print a message to stderr\nwarn() {\n\tlocal fmt=\"$1\"\n\tshift\n\t# shellcheck disable=SC2059\n\tprintf \"transcrypt: $fmt\\n\" \"$@\" >&2\n}\n\n# print a message to stderr and exit with either\n# the given status or that of the most recent command\ndie() {\n\tlocal st=\"$?\"\n\tif [[ \"$1\" != *[^0-9]* ]]; then\n\t\tst=\"$1\"\n\t\tshift\n\tfi\n\twarn \"$@\"\n\texit \"$st\"\n}\n\n# return context name if $1 has format 'context=name-of-context' else empty string\nextract_context_name_from_name_value_arg() {\n\tlocal before_last_equals=${1%=*}\n\tlocal after_first_equals=${1#*=}\n\tif [[ \"$before_last_equals\" == \"context\" ]]; then\n\t\techo \"$after_first_equals\"\n\tfi\n\techo ''\n}\n\nderive_context_config_group() {\n\tlocal context=${1:-}\n\tif [[ ! $context ]] || [[ $context == 'default' ]]; then\n\t\techo ''\n\telse\n\t\techo \".$context\" # Note leading period\n\tfi\n}\n\n# Internal function that returns a list of filenames for encrypted files in the\n# repo, where the filenames are verbatim and not quoted in any way even if they\n# contain unusual characters like double-quotes, backslash and control\n# characters. We must avoid quoting of filenames to support names containing\n# double quotes. #173\n_list_encrypted_files() {\n\tlocal strict_context=${1:-}\n\n\tIFS=$'\\n'\n\t# List files with -z option to disable quoting of filenames, then\n\t# immediately convert NUL-delimited filenames to be newline-delimited to be\n\t# compatibility with bash variables\n\tfor file in $(git ls-files -z | tr '\\0' '\\n'); do\n\t\t# Check for the suffix ': filter: crypt' that identifies encrypted file\n\t\tlocal check\n\t\tcheck=$(git check-attr filter \"$file\" 2>/dev/null)\n\n\t\t# Only output names of encrypted files matching the context, either\n\t\t# strictly (if $1 = \"true\") or loosely (if $1 is false or unset)\n\t\tif [[ \"$strict_context\" == \"true\" ]] &&\n\t\t\t[[ \"$check\" == *\": filter: crypt${CONTEXT_CRYPT_SUFFIX:-}\" ]]; then\n\t\t\techo \"$file\"\n\t\telif [[ \"$check\" == *\": filter: crypt${CONTEXT_CRYPT_SUFFIX:-}\"* ]]; then\n\t\t\techo \"$file\"\n\t\tfi\n\tdone\n}\n\n# Detect OpenSSL major version 3 or later which requires a compatibility\n# work-around to include the prefix 'Salted__' and salt value when encrypting.\n#\n# Note that the LibreSSL project's version of the openssl command does NOT\n# require this work-around for major version 3.\n#\n# See #133 #147\nis_salt_prefix_workaround_required() {\n\topenssl_path=$(git config --get --local transcrypt.openssl-path 2>/dev/null || printf '%s' \"$openssl_path\")\n\n\topenssl_project=$($openssl_path version | cut -d' ' -f1)\n\topenssl_major_version=$($openssl_path version | cut -d' ' -f2 | cut -d'.' -f1)\n\n\tif [ \"$openssl_project\" == \"OpenSSL\" ] && [ \"$openssl_major_version\" -ge \"3\" ]; then\n\t\techo 'true'\n\telse\n\t\techo ''\n\tfi\n}\n\n# The `decryption -> encryption` process on an unchanged file must be\n# deterministic for everything to work transparently. To do that, the same\n# salt must be used each time we encrypt the same file. An HMAC has been\n# proven to be a PRF, so we generate an HMAC-SHA256 for each decrypted file\n# (keyed with a combination of the filename and transcrypt password), and\n# then use the last 16 bytes of that HMAC for the file's unique salt.\n\n# shellcheck disable=SC2155\nreadonly IS_PRINTF_BIN_SUPPORTED=$([[ \"$(echo -n \"41\" | sed \"s/../\\\\\\\\x&/g\" | xargs -0 printf \"%b\")\" == \"A\" ]] && echo 'true' || echo 'false')\n\n# Apply one of three methods to convert a hex string to binary data, or\nhex_to_bin() {\n\t# alternative 1 but xxd often only comes with a vim install\n\tif command -v \"xxd\" >/dev/null; then\n\t\txxd -r -p\n\t# alternative 2, but requires printf that supports \"%b\"\n\t# (macOS /usr/bin/printf doesn't)\n\telif $IS_PRINTF_BIN_SUPPORTED; then\n\t\tsed \"s/../\\\\\\\\x&/g\" | xargs -0 printf \"%b\"\n\t# alternative 3 as perl is fairly common\n\telif command -v \"perl\" >/dev/null; then\n\t\tperl -pe \"s/([0-9A-Fa-f]{2})/chr(hex(\\$1))/eg\"\n\telse\n\t\tdie 'required command not found: xxd, or printf that supports \"%%b\", or perl'\n\tfi\n}\n\ngit_clean() {\n\tcontext=$(extract_context_name_from_name_value_arg \"$1\")\n\t[[ \"$context\" ]] && shift\n\n\tfilename=$1\n\t# ignore empty files\n\tif [[ ! -s $filename ]]; then\n\t\treturn\n\tfi\n\t# cache STDIN to test if it's already encrypted\n\ttempfile=$(mktemp 2>/dev/null || mktemp -t tmp)\n\ttrap 'rm -f \"$tempfile\"' EXIT\n\ttee \"$tempfile\" &>/dev/null\n\t# the first bytes of an encrypted file are always \"Salted\" in Base64\n\t# The `head + LC_ALL=C tr` command handles binary data in old and new Bash (#116)\n\tfirstbytes=$(head -c8 \"$tempfile\" | LC_ALL=C tr -d '\\0')\n\tif [[ $firstbytes == \"U2FsdGVk\" ]]; then\n\t\tcat \"$tempfile\"\n\telse\n\t\tcontext_config_group=$(derive_context_config_group \"$context\")\n\t\tcipher=$(git config --get --local \"transcrypt${context_config_group}.cipher\")\n\t\tpassword=$(load_password \"$context_config_group\")\n\t\topenssl_path=$(git config --get --local transcrypt.openssl-path)\n\t\tsalt=$(\"${openssl_path}\" dgst -hmac \"${filename}:${password}\" -sha256 \"$tempfile\" | tr -d '\\r\\n' | tail -c16)\n\n\t\tif [ \"$(is_salt_prefix_workaround_required)\" == \"true\" ]; then\n\t\t\t# Encrypt the file to base64, ensuring it includes the prefix 'Salted__' with the salt. #133\n\t\t\t(\n\t\t\t\techo -n \"Salted__\" && echo -n \"$salt\" | hex_to_bin &&\n\t\t\t\t\t# Encrypt file to binary ciphertext\n\t\t\t\t\tENC_PASS=$password \"$openssl_path\" enc -e \"-${cipher}\" -md MD5 -pass env:ENC_PASS -S \"$salt\" -in \"$tempfile\"\n\t\t\t) |\n\t\t\t\topenssl base64\n\t\telse\n\t\t\t# Encrypt file to base64 ciphertext\n\t\t\tENC_PASS=$password \"$openssl_path\" enc -e -a \"-${cipher}\" -md MD5 -pass env:ENC_PASS -S \"$salt\" -in \"$tempfile\"\n\t\tfi\n\tfi\n}\n\ngit_smudge() {\n\ttempfile=$(mktemp 2>/dev/null || mktemp -t tmp)\n\ttrap 'rm -f \"$tempfile\"' EXIT\n\tcontext=$(extract_context_name_from_name_value_arg \"$1\")\n\tcontext_config_group=$(derive_context_config_group \"$context\")\n\tcipher=$(git config --get --local \"transcrypt${context_config_group}.cipher\")\n\tpassword=$(load_password \"$context_config_group\")\n\topenssl_path=$(git config --get --local transcrypt.openssl-path)\n\ttee \"$tempfile\" | ENC_PASS=$password \"$openssl_path\" enc -d \"-${cipher}\" -md MD5 -pass env:ENC_PASS -a 2>/dev/null || cat \"$tempfile\"\n}\n\ngit_textconv() {\n\tcontext=$(extract_context_name_from_name_value_arg \"$1\")\n\t[[ \"$context\" ]] && shift\n\n\tfilename=$1\n\t# ignore empty files\n\tif [[ ! -s $filename ]]; then\n\t\treturn\n\tfi\n\n\tcontext_config_group=$(derive_context_config_group \"$context\")\n\tcipher=$(git config --get --local \"transcrypt${context_config_group}.cipher\")\n\tpassword=$(load_password \"$context_config_group\")\n\topenssl_path=$(git config --get --local transcrypt.openssl-path)\n\tENC_PASS=$password \"$openssl_path\" enc -d \"-${cipher}\" -md MD5 -pass env:ENC_PASS -a -in \"$filename\" 2>/dev/null || cat \"$filename\"\n}\n\n# shellcheck disable=SC2005,SC2002,SC2181\ngit_merge() {\n\tcontext=$(extract_context_name_from_name_value_arg \"$1\")\n\t[[ \"$context\" ]] && shift\n\n\t# Get path to transcrypt in this script's directory\n\tTRANSCRYPT_PATH=\"$(dirname \"$0\")/transcrypt\"\n\t# Look up name of local branch/ref to which changes are being merged\n\tOURS_LABEL=$(git rev-parse --abbrev-ref HEAD)\n\t# Look up name of the incoming \"theirs\" branch/ref being merged in.\n\t# TODO There must be a better way of doing this than relying on this reflog\n\t#      action environment variable, but I don't know what it is\n\tif [[ \"${GIT_REFLOG_ACTION:-}\" = \"merge \"* ]]; then\n\t\tTHEIRS_LABEL=$(echo \"$GIT_REFLOG_ACTION\" | awk '{print $2}')\n\tfi\n\tif [[ ! \"${THEIRS_LABEL:-}\" ]]; then\n\t\tTHEIRS_LABEL=\"theirs\"\n\tfi\n\t# Decrypt BASE $1, LOCAL $2, and REMOTE $3 versions of file being merged\n\techo \"$(cat \"$1\" | \"${TRANSCRYPT_PATH}\" smudge context=\"$context\")\" >\"$1\"\n\techo \"$(cat \"$2\" | \"${TRANSCRYPT_PATH}\" smudge context=\"$context\")\" >\"$2\"\n\techo \"$(cat \"$3\" | \"${TRANSCRYPT_PATH}\" smudge context=\"$context\")\" >\"$3\"\n\t# Merge the decrypted files to the temp file named by $2\n\tgit merge-file --marker-size=\"$4\" -L \"$OURS_LABEL\" -L base -L \"$THEIRS_LABEL\" \"$2\" \"$1\" \"$3\"\n\t# If the merge was not successful (has conflicts) exit with an error code to\n\t# leave the partially-merged file in place for a manual merge.\n\tif [[ \"$?\" != \"0\" ]]; then\n\t\texit 1\n\tfi\n\t# If the merge was successful (no conflicts) re-encrypt the merged temp file $2\n\t# which git will then update in the index in a following \"Auto-merging\" step.\n\t# We must explicitly encrypt/clean the file, rather than leave Git to do it,\n\t# because we can otherwise trigger safety check failure errors like:\n\t#     error: add_cacheinfo failed to refresh for path 'FILE'; merge aborting.\n\t# To re-encrypt we must first copy the merged file to $5 (the name of the\n\t# working-copy file) so the crypt `clean` script can generate the correct hash\n\t# salt based on the file's real name, instead of the $2 temp file name.\n\tcp \"$2\" \"$5\"\n\t# Now we use the `clean` script to encrypt the merged file contents back to the\n\t# temp file $2 where Git expects to find the merge result content.\n\tcat \"$5\" | \"${TRANSCRYPT_PATH}\" clean context=\"$context\" \"$5\" >\"$2\"\n}\n\n# shellcheck disable=SC2155\ngit_pre_commit() {\n\t# Transcrypt pre-commit hook: fail if secret file in staging lacks the magic prefix \"Salted\" in B64\n\ttmp=$(mktemp)\n\tIFS=$'\\n'\n\tslow_mode_if_failed() {\n\t\tfor secret_file in $(_list_encrypted_files); do\n\t\t\t# Skip symlinks, they contain the linked target file path not plaintext\n\t\t\tif [[ -L $secret_file ]]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\t# Get prefix of raw file in Git's index using the :FILENAME revision syntax\n\t\t\tlocal firstbytes=$(git show :\"${secret_file}\" | head -c8)\n\t\t\t# An empty file does not need to be, and is not, encrypted\n\t\t\tif [[ $firstbytes == \"\" ]]; then\n\t\t\t\t: # Do nothing\n\t\t\t# The first bytes of an encrypted file must be \"Salted\" in Base64\n\t\t\telif [[ $firstbytes != \"U2FsdGVk\" ]]; then\n\t\t\t\tprintf 'Transcrypt managed file is not encrypted in the Git index: %s\\n' \"$secret_file\" >&2\n\t\t\t\tprintf '\\n' >&2\n\t\t\t\tprintf 'You probably staged this file using a tool that does not apply' >&2\n\t\t\t\tprintf ' .gitattribute filters as required by Transcrypt.\\n' >&2\n\t\t\t\tprintf '\\n' >&2\n\t\t\t\tprintf 'Fix this by re-staging the file with a compatible tool or with'\n\t\t\t\tprintf ' Git on the command line:\\n' >&2\n\t\t\t\tprintf '\\n' >&2\n\t\t\t\tprintf '    git rm --cached -- %s\\n' \"$secret_file\" >&2\n\t\t\t\tprintf '    git add %s\\n' \"$secret_file\" >&2\n\t\t\t\tprintf '\\n' >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\tdone\n\t}\n\n\t# validate file to see if it failed or not, We don't care about the filename currently for speed, we only care about pass/fail, slow_mode_if_failed() is for what failed.\n\tvalidate_file() {\n\t\tsecret_file=${1}\n\t\t# Skip symlinks, they contain the linked target file path not plaintext\n\t\tif [[ -L $secret_file ]]; then\n\t\t\treturn\n\t\tfi\n\t\t# Get prefix of raw file in Git's index using the :FILENAME revision syntax\n\t\t# The first bytes of an encrypted file are always \"Salted\" in Base64\n\t\tlocal firstbytes=$(git show :\"${secret_file}\" | head -c8)\n\t\tif [[ $firstbytes != \"U2FsdGVk\" ]]; then\n\t\t\techo \"true\" >>\"${tmp}\"\n\t\tfi\n\t}\n\n\t# if bash version is 4.4 or greater than fork to number of threads otherwise run normally\n\tif [[ \"${BASH_VERSINFO[0]}\" -ge 4 ]] && [[ \"${BASH_VERSINFO[1]}\" -ge 4 ]]; then\n\t\tnum_procs=$(nproc)\n\t\tnum_jobs=\"\\j\"\n\t\tfor secret_file in $(_list_encrypted_files); do\n\t\t\twhile ((${num_jobs@P} >= num_procs)); do\n\t\t\t\twait -n\n\t\t\tdone\n\t\t\tvalidate_file \"${secret_file}\" &\n\t\tdone\n\t\twait\n\t\tif [[ -s ${tmp} ]]; then\n\t\t\tslow_mode_if_failed\n\t\t\trm -f \"${tmp}\"\n\t\t\texit 1\n\t\tfi\n\telse\n\t\tslow_mode_if_failed\n\tfi\n\n\trm -f \"${tmp}\"\n\tunset IFS\n}\n\n# verify that all requirements have been met\nrun_safety_checks() {\n\t# validate that we're in a git repository\n\t[[ $GIT_DIR ]] || die 'you are not currently in a git repository; did you forget to run \"git init\"?'\n\n\t# Check the context name provided (or 'default') is valid\n\tfull_context_regex=\"^${CONTEXT_REGEX}$\"\n\tif [[ ! $CONTEXT =~ $full_context_regex ]]; then\n\t\twarn \"context name '${CONTEXT}' is invalid\"\n\t\techo \"Must be lowercase ASCII, start with a letter, then zero or more letters or numbers. A hyphen (-) seperator is allowed\"\n\t\techo \"Examples: admin  admins-only  super-user  staging  production  top-secret  abc-123-xyz\"\n\t\texit 1\n\tfi\n\n\t# exit if transcrypt is not in the required state\n\tif [[ $requires_existing_config ]] && [[ ! $CONFIGURED_CONTEXTS ]]; then\n\t\tdie 1 'the current repository is not configured'\n\tfi\n\n\t# check for dependencies\n\tfor cmd in {column,grep,mktemp,\"${openssl_path}\",sed,tee}; do\n\t\tcommand -v \"$cmd\" >/dev/null || die 'required command \"%s\" was not found' \"$cmd\"\n\tdone\n\n\t# check for a working method to convert a hex string to binary data\n\tif [ \"$(is_salt_prefix_workaround_required)\" == \"true\" ]; then\n\t\techo -n \"41\" | hex_to_bin >/dev/null\n\tfi\n\n\t# ensure the repository is clean (if it has a HEAD revision) so we can force\n\t# checkout files without the destruction of uncommitted changes\n\tif [[ $requires_clean_repo ]] && [[ $HEAD_EXISTS ]] && [[ $IS_BARE == 'false' ]]; then\n\t\t# ensure index is up-to-date before dirty check\n\t\tgit update-index -q --really-refresh\n\t\t# check if the repo is dirty\n\t\tif ! git diff-index --quiet HEAD --; then\n\t\t\twarn 'the repo is dirty; commit or stash your changes before running transcrypt\\n'\n\t\t\t# Output a human friendly summary of dirty files, with fallback to\n\t\t\t# less friendly output formats if nicer ones aren't supported\n\t\t\tgit diff-index --name-status HEAD -- 2>/dev/null ||\n\t\t\t\tgit diff-index --stat HEAD -- 2>/dev/null ||\n\t\t\t\tgit diff-index HEAD --\n\t\t\texit 1\n\t\tfi\n\tfi\n}\n\n# unset the cipher variable if it is not supported by openssl\nvalidate_cipher() {\n\tlocal list_cipher_commands\n\tif \"${openssl_path}\" list-cipher-commands &>/dev/null; then\n\t\t# OpenSSL < v1.1.0\n\t\tlist_cipher_commands=\"${openssl_path} list-cipher-commands\"\n\telse\n\t\t# OpenSSL >= v1.1.0\n\t\tlist_cipher_commands=\"${openssl_path} list -cipher-commands\"\n\tfi\n\n\tlocal supported\n\tsupported=$($list_cipher_commands | tr -s ' ' '\\n' | grep -Fx \"$cipher\") || true\n\tif [[ ! $supported ]]; then\n\t\tif [[ $interactive ]]; then\n\t\t\tprintf '\"%s\" is not a valid cipher; choose one of the following:\\n\\n' \"$cipher\"\n\t\t\t$list_cipher_commands | column -c 80\n\t\t\tprintf '\\n'\n\t\t\tcipher=''\n\t\telse\n\t\t\t# shellcheck disable=SC2016\n\t\t\tdie 1 '\"%s\" is not a valid cipher; see `%s`' \"$cipher\" \"$list_cipher_commands\"\n\t\tfi\n\tfi\n}\n\n# ensure we have a cipher to encrypt with\nget_cipher() {\n\twhile [[ ! $cipher ]]; do\n\t\tlocal answer=\n\t\tif [[ $interactive ]]; then\n\t\t\tprintf 'Encrypt using which cipher? [%s] ' \"$DEFAULT_CIPHER\"\n\t\t\tread -r answer\n\t\tfi\n\n\t\t# use the default cipher if the user gave no answer;\n\t\t# otherwise verify the given cipher is supported by openssl\n\t\tif [[ ! $answer ]]; then\n\t\t\tcipher=$DEFAULT_CIPHER\n\t\telse\n\t\t\tcipher=$answer\n\t\t\tvalidate_cipher\n\t\tfi\n\tdone\n}\n\n# ensure we have a password to encrypt with\nget_password() {\n\twhile [[ ! $password ]]; do\n\t\tlocal answer=\n\t\tif [[ $interactive ]]; then\n\t\t\tprintf 'Generate a random password? [Y/n] '\n\t\t\tread -r -n 1 -s answer\n\t\t\tprintf '\\n'\n\t\tfi\n\n\t\t# generate a random password if the user answered yes;\n\t\t# otherwise prompt the user for a password\n\t\tif [[ $answer =~ $YES_REGEX ]] || [[ ! $answer ]]; then\n\t\t\tlocal password_length=30\n\t\t\tlocal random_base64\n\t\t\trandom_base64=$(${openssl_path} rand -base64 $password_length)\n\t\t\tpassword=$random_base64\n\t\telse\n\t\t\tprintf 'Password: '\n\t\t\tread -r password\n\t\t\t[[ $password ]] || printf 'no password was specified\\n'\n\t\tfi\n\tdone\n}\n\n# confirm the transcrypt configuration\nconfirm_configuration() {\n\tlocal answer=\n\n\tprintf '\\nRepository metadata:\\n\\n'\n\t[[ ! $REPO ]] || printf '  GIT_WORK_TREE:  %s\\n' \"$REPO\"\n\tprintf '  GIT_DIR:        %s\\n' \"$GIT_DIR\"\n\tprintf '  GIT_ATTRIBUTES: %s\\n\\n' \"$GIT_ATTRIBUTES\"\n\tprintf 'The following configuration will be saved:\\n\\n'\n\tprintf '  CONTEXT:  %s\\n' \"$CONTEXT\"\n\tprintf '  CIPHER:   %s\\n' \"$cipher\"\n\tprintf '  PASSWORD: %s\\n\\n' \"$password\"\n\tprintf 'Does this look correct? [Y/n] '\n\tread -r -n 1 -s answer\n\n\t# exit if the user did not confirm\n\tif [[ $answer =~ $YES_REGEX ]] || [[ ! $answer ]]; then\n\t\tprintf '\\n\\n'\n\telse\n\t\tprintf '\\n'\n\t\tdie 1 'configuration has been aborted'\n\tfi\n}\n\n# confirm the rekey configuration\nconfirm_rekey() {\n\tlocal answer=\n\n\tprintf '\\nRepository metadata:\\n\\n'\n\t[[ ! $REPO ]] || printf '  GIT_WORK_TREE:  %s\\n' \"$REPO\"\n\tprintf '  GIT_DIR:        %s\\n' \"$GIT_DIR\"\n\tprintf '  GIT_ATTRIBUTES: %s\\n\\n' \"$GIT_ATTRIBUTES\"\n\tprintf 'The following configuration will be saved:\\n\\n'\n\tprintf '  CONTEXT:  %s\\n' \"$CONTEXT\"\n\tprintf '  CIPHER:   %s\\n' \"$cipher\"\n\tprintf '  PASSWORD: %s\\n\\n' \"$password\"\n\tprintf 'You are about to re-encrypt all encrypted files using new credentials.\\n'\n\tprintf 'Once you do this, their historical diffs will no longer display in plain text.\\n\\n'\n\tprintf 'Proceed with rekey? [y/N] '\n\tread -r answer\n\n\t# only rekey if the user explicitly confirmed\n\tif [[ $answer =~ $YES_REGEX ]]; then\n\t\tprintf '\\n'\n\telse\n\t\tdie 1 'rekeying has been aborted'\n\tfi\n}\n\n# automatically stage rekeyed files in preparation for the user to commit them\nstage_rekeyed_files() {\n\tlocal encrypted_files\n\tencrypted_files=$(git ls-crypt)\n\tif [[ $encrypted_files ]] && [[ $IS_BARE == 'false' ]]; then\n\t\t# touch all encrypted files to prevent stale stat info\n\t\tcd \"$REPO\" >/dev/null || die 1 'could not change into the \"%s\" directory' \"$REPO\"\n\t\t# shellcheck disable=SC2086\n\t\ttouch $encrypted_files\n\t\t# shellcheck disable=SC2086\n\t\tgit update-index --add -- $encrypted_files\n\n\t\tprintf '***  rekeyed files have been staged  ***\\n'\n\t\tprintf '*** COMMIT THESE CHANGES RIGHT AWAY! ***\\n\\n'\n\tfi\n}\n\n# save helper scripts under the repository's git directory\nsave_helper_scripts() {\n\tmkdir -p \"${CRYPT_DIR}\"\n\n\tlocal current_transcrypt\n\tcurrent_transcrypt=$(realpath \"$0\" 2>/dev/null)\n\tcp \"$current_transcrypt\" \"${CRYPT_DIR}/transcrypt\"\n\n\t# make scripts executable\n\tfor script in {transcrypt,}; do\n\t\tchmod 0755 \"${CRYPT_DIR}/${script}\"\n\tdone\n}\n\n# save helper hooks under the repository's git directory\nsave_helper_hooks() {\n\tif [[ $rekey ]]; then\n\t\treturn 0 # Bypass helper hook installation on rekey\n\tfi\n\n\t# Install pre-commit-crypt hook script\n\t[[ ! -d \"${GIT_HOOKS}\" ]] && mkdir -p \"${GIT_HOOKS}\"\n\tpre_commit_hook_installed=\"${GIT_HOOKS}/pre-commit-crypt\"\n\tcat <<-'EOF' >\"$pre_commit_hook_installed\"\n\t\t#!/usr/bin/env bash\n\t\t# Transcrypt pre-commit hook: fail if secret file in staging lacks the magic prefix \"Salted\" in B64\n\t\tRELATIVE_GIT_DIR=$(git rev-parse --git-dir 2>/dev/null || printf '')\n\t\tCRYPT_DIR=$(git config transcrypt.crypt-dir 2>/dev/null || printf '%s/crypt' \"${RELATIVE_GIT_DIR}\")\n\t\t\"${CRYPT_DIR}/transcrypt\" pre_commit\n\tEOF\n\n\t# Activate hook by copying it to the pre-commit script name, but only if\n\t# the global pre-commit hook is not already present\n\tpre_commit_hook=\"${GIT_HOOKS}/pre-commit\"\n\tif [[ -f \"$pre_commit_hook\" ]]; then\n\t\t# Nothing to do if our pre-commit hook is already installed\n\t\thook_md5=$(\"${openssl_path}\" md5 -hex <\"$pre_commit_hook\")\n\t\tinstalled_md5=$(\"${openssl_path}\" md5 -hex <\"$pre_commit_hook_installed\")\n\t\tif [[ \"$hook_md5\" = \"$installed_md5\" ]]; then\n\t\t\t: # no-op\n\t\telse\n\t\t\tprintf 'WARNING:\\n' >&2\n\t\t\tprintf 'Cannot install Git pre-commit hook script because file already exists: %s\\n' \"$pre_commit_hook\" >&2\n\t\t\tprintf 'Please manually install the pre-commit script saved as: %s\\n' \"$pre_commit_hook_installed\" >&2\n\t\t\tprintf '\\n'\n\t\tfi\n\telse\n\t\tcp \"$pre_commit_hook_installed\" \"$pre_commit_hook\"\n\t\tchmod 0755 \"$pre_commit_hook\"\n\tfi\n}\n\n# write the configuration to the repository's git config\nsave_configuration() {\n\t# prevent clobbering existing configuration\n\t# shellcheck disable=SC2086\n\tif [[ $upgrade ]]; then\n\t\t: # Bypass safety check on upgrade; we know we just called uninstall_transcrypt\n\telif [[ $rekey ]]; then\n\t\t: # Bypass safety check on rekey\n\telif is_item_in_array \"$CONTEXT\" ${CONFIGURED_CONTEXTS}; then\n\t\tif [[ \"$CONTEXT\" = 'default' ]]; then\n\t\t\tdie 1 \"the current repository is already configured; see 'transcrypt --display'\"\n\t\telse\n\t\t\tdie 1 \"the current repository is already configured${CONTEXT_DESCRIPTION}; see 'transcrypt --context=$CONTEXT --display'\"\n\t\tfi\n\tfi\n\n\tsave_helper_scripts\n\tsave_helper_hooks\n\n\t# write the encryption info\n\tgit config transcrypt.version \"$VERSION\"\n\tgit config \"transcrypt${CONTEXT_CONFIG_GROUP}.cipher\" \"$cipher\"\n\tsave_password \"$password\" \"$CONTEXT_CONFIG_GROUP\"\n\tgit config transcrypt.openssl-path \"$openssl_path\"\n\n\t# write the filter settings. Sorry for the horrific quote escaping below...\n\t# shellcheck disable=SC2016\n\ttranscrypt_path='\"$(git config transcrypt.crypt-dir 2>/dev/null || printf %s/crypt \"\"$(git rev-parse --git-dir)\"\")\"/transcrypt'\n\n\t# Ensure filter attributes are always set for the default (unspecified) context\n\tgit config filter.crypt.clean \"$transcrypt_path clean context=default %f\"\n\tgit config filter.crypt.smudge \"$transcrypt_path smudge context=default\"\n\tgit config diff.crypt.textconv \"$transcrypt_path textconv context=default\"\n\tgit config merge.crypt.driver \"$transcrypt_path merge context=default %O %A %B %L %P\"\n\n\t# Also set filter attributes for a non-default context, if necessary\n\tif [[ ! \"$CONTEXT\" = 'default' ]]; then\n\t\tgit config filter.crypt\"${CONTEXT_CRYPT_SUFFIX}\".clean \"$transcrypt_path clean context=$CONTEXT %f\"\n\t\tgit config filter.crypt\"${CONTEXT_CRYPT_SUFFIX}\".smudge \"$transcrypt_path smudge context=$CONTEXT\"\n\t\tgit config diff.crypt\"${CONTEXT_CRYPT_SUFFIX}\".textconv \"$transcrypt_path textconv context=$CONTEXT\"\n\t\tgit config merge.crypt\"${CONTEXT_CRYPT_SUFFIX}\".driver \"$transcrypt_path merge context=$CONTEXT %O %A %B %L %P\"\n\tfi\n\n\tgit config filter.crypt.required 'true'\n\tgit config diff.crypt.cachetextconv 'true'\n\tgit config diff.crypt.binary 'true'\n\tgit config merge.renormalize 'true'\n\tgit config merge.crypt.name 'Merge transcrypt secret files'\n\n\t# add git alias for listing ALL encrypted files regardless of context\n\tgit config alias.ls-crypt \"!$transcrypt_path --list\"\n\n\t# add a git alias for listing encrypted files in specific context, including 'default'\n\tif [[ \"$CONTEXT\" = 'default' ]]; then\n\t\t# List files with gitattribute 'filter=crypt'\n\t\tgit config alias.ls-crypt-default \"!$transcrypt_path --list\"\n\telse\n\t\t# List files with gitattribute 'filter=crypt-<CONTEXT>'\n\t\tgit config \"alias.ls-crypt-${CONTEXT}\" \"!$transcrypt_path --context=${CONTEXT} --list\"\n\tfi\n}\n\n# display the current configuration settings\ndisplay_configuration() {\n\tlocal current_cipher\n\tcurrent_cipher=$(git config --get --local \"transcrypt${CONTEXT_CONFIG_GROUP}.cipher\")\n\tlocal current_password\n\tcurrent_password=$(load_password \"$CONTEXT_CONFIG_GROUP\")\n\tlocal escaped_password=${current_password//\\'/\\'\\\\\\'\\'}\n\n\tcontexts_count=\"$(count_items_in_list \"$CONFIGURED_CONTEXTS\")\"\n\n\tprintf 'The current repository was configured using transcrypt version %s\\n' \"$INSTALLED_VERSION\"\n\tprintf \"and has the following configuration%s:\\n\\n\" \"$CONTEXT_DESCRIPTION\"\n\t[[ ! $REPO ]] || printf '  GIT_WORK_TREE:  %s\\n' \"$REPO\"\n\tprintf '  GIT_DIR:        %s\\n' \"$GIT_DIR\"\n\tprintf '  GIT_ATTRIBUTES: %s\\n\\n' \"$GIT_ATTRIBUTES\"\n\tprintf '  CONTEXT:  %s\\n' \"$CONTEXT\"\n\tprintf '  CIPHER:   %s\\n' \"$current_cipher\"\n\tprintf '  PASSWORD: %s\\n\\n' \"$current_password\"\n\tif [[ \"$contexts_count\" -gt \"1\" ]]; then\n\t\tprintf 'The repository has %s contexts: %s\\n\\n' \"$contexts_count\" \"$CONFIGURED_CONTEXTS\"\n\tfi\n\tprintf \"Copy and paste the following command to initialize a cloned repository%s:\\n\\n\" \"$CONTEXT_DESCRIPTION\"\n\tif [[ $CONTEXT != 'default' ]]; then\n\t\tprintf \"  transcrypt -C $CONTEXT -c %s -p '%s'\\n\" \"$current_cipher\" \"$escaped_password\"\n\telse\n\t\tprintf \"  transcrypt -c %s -p '%s'\\n\" \"$current_cipher\" \"$escaped_password\"\n\tfi\n}\n\n# remove transcrypt-related settings from the repository's git config\nclean_gitconfig() {\n\tgit config --remove-section transcrypt\"${CONTEXT_CONFIG_GROUP}\" 2>/dev/null || true\n\n\tgit config --remove-section filter.crypt\"${CONTEXT_CRYPT_SUFFIX}\" 2>/dev/null || true\n\tgit config --remove-section diff.crypt\"${CONTEXT_CRYPT_SUFFIX}\" 2>/dev/null || true\n\tgit config --remove-section merge.crypt\"${CONTEXT_CRYPT_SUFFIX}\" 2>/dev/null || true\n}\n\n# Remove from the local Git DB any objects containing the cached plaintext of\n# secret files, created due to the setting diff.crypt.cachetextconv='true'\nremove_cached_plaintext() {\n\t# Delete ref to cached plaintext objects, to leave these objects\n\t# unreferenced and available for removal\n\tgit update-ref -d refs/notes/textconv/crypt\n\n\t# Remove ANY unreferenced objects in Git's object DB (packed or unpacked),\n\t# to ensure that cached plaintext objects are also removed.\n\t# The vital sub-commands equivalents we require this `gc` command to do are:\n\t# `git prune`, `git repack -ad`\n\tgit gc --prune=now --quiet\n}\n\n# force the checkout of any files with the crypt filter applied to them;\n# this will decrypt existing encrypted files if you've just cloned a repository,\n# or it will encrypt locally decrypted files if you've just flushed the credentials\nforce_checkout() {\n\t# make sure a HEAD revision exists\n\tif [[ $HEAD_EXISTS ]] && [[ $IS_BARE == 'false' ]]; then\n\t\t# this would normally delete uncommitted changes in the working directory,\n\t\t# but we already made sure the repo was clean during the safety checks\n\t\tlocal encrypted_files\n\t\tencrypted_files=$(git \"ls-crypt-${CONTEXT}\")\n\t\tcd \"$REPO\" >/dev/null || die 1 'could not change into the \"%s\" directory' \"$REPO\"\n\t\tIFS=$'\\n'\n\t\tfor file in $encrypted_files; do\n\t\t\trm -f \"$file\"\n\t\t\tgit checkout --force HEAD -- \"$file\" >/dev/null\n\t\tdone\n\t\tunset IFS\n\tfi\n}\n\n# remove the locally cached encryption credentials and\n# re-encrypt any files that had been previously decrypted\nflush_credentials() {\n\tlocal answer=\n\n\tif [[ $interactive ]]; then\n\t\tprintf 'You are about to flush the local credentials; make sure you have saved them elsewhere.\\n'\n\t\tprintf 'All previously decrypted files will revert to their encrypted form, and your\\n'\n\t\tprintf 'repo will be garbage collected to remove any cached plaintext of secret files.\\n\\n'\n\t\tprintf 'Proceed with credential flush? [y/N] '\n\t\tread -r answer\n\t\tprintf '\\n'\n\telse\n\t\t# although destructive, we should support the --yes option\n\t\tanswer='y'\n\tfi\n\n\t# only flush if the user explicitly confirmed\n\tif [[ $answer =~ $YES_REGEX ]]; then\n\t\tclean_gitconfig\n\n\t\tremove_cached_plaintext\n\n\t\t# re-encrypt any files that had been previously decrypted\n\t\tforce_checkout\n\n\t\t# Unset the ls-crypt alias for the current context\n\t\t# We must do this after the force checkout, which relies on ls-crypt\n\t\tgit config --unset alias.ls-crypt\"${CONTEXT_CRYPT_SUFFIX}\" 2>/dev/null || true\n\n\t\t# Also remove ls-crypt-default alias when removing default context\n\t\tif [[ \"$CONTEXT\" = 'default' ]]; then\n\t\t\tgit config --unset alias.ls-crypt-default 2>/dev/null || true\n\t\tfi\n\n\t\tprintf 'The local transcrypt credentials have been successfully flushed.\\n'\n\telse\n\t\tdie 1 'flushing of credentials has been aborted'\n\tfi\n}\n\n# remove all transcrypt configuration from the repository\nuninstall_transcrypt() {\n\tlocal answer=\n\n\tif [[ $interactive ]]; then\n\t\tprintf 'You are about to remove all transcrypt configuration from your repository.\\n'\n\t\tprintf 'All previously encrypted files will remain decrypted in this working copy, but your\\n'\n\t\tprintf 'repo will be garbage collected to remove any cached plaintext of secret files.\\n\\n'\n\t\tif [[ $(count_items_in_list \"$CONFIGURED_CONTEXTS\") -gt \"1\" ]]; then\n\t\t\tprintf 'Proceed with uninstall of all contexts (%s)? [y/N] ' \"$CONFIGURED_CONTEXTS\"\n\t\telse\n\t\t\tprintf 'Proceed with uninstall? [y/N] '\n\t\tfi\n\t\tread -r answer\n\t\tprintf '\\n'\n\telse\n\t\t# although destructive, we should support the --yes option\n\t\tanswer='y'\n\tfi\n\n\t# only uninstall if the user explicitly confirmed\n\tif [[ $answer =~ $YES_REGEX ]]; then\n\t\tclean_gitconfig\n\n\t\tif [[ ! $upgrade ]]; then\n\t\t\tremove_cached_plaintext\n\t\tfi\n\n\t\t# touch all encrypted files to prevent stale stat info\n\t\tlocal encrypted_files\n\t\tencrypted_files=$(git ls-crypt)\n\t\tif [[ $encrypted_files ]] && [[ $IS_BARE == 'false' ]]; then\n\t\t\tcd \"$REPO\" >/dev/null || die 1 'could not change into the \"%s\" directory' \"$REPO\"\n\t\t\t# shellcheck disable=SC2086\n\t\t\ttouch $encrypted_files\n\t\tfi\n\n\t\t# remove helper scripts\n\t\t# Keep obsolete clean,smudge,textconv,merge refs here to remove them on upgrade\n\t\tfor script in {transcrypt,clean,smudge,textconv,merge}; do\n\t\t\t[[ ! -f \"${CRYPT_DIR}/${script}\" ]] || rm \"${CRYPT_DIR}/${script}\"\n\t\tdone\n\t\t[[ ! -d \"${CRYPT_DIR}\" ]] || rmdir \"${CRYPT_DIR}\"\n\n\t\t# rename helper hooks (don't delete, in case user has custom changes)\n\t\tpre_commit_hook=\"${GIT_HOOKS}/pre-commit\"\n\t\tpre_commit_hook_installed=\"${GIT_HOOKS}/pre-commit-crypt\"\n\t\tif [[ -f \"$pre_commit_hook\" ]]; then\n\t\t\thook_md5=$(\"${openssl_path}\" md5 -hex <\"$pre_commit_hook\")\n\t\t\tinstalled_md5=$(\"${openssl_path}\" md5 -hex <\"$pre_commit_hook_installed\")\n\t\t\tif [[ \"$hook_md5\" = \"$installed_md5\" ]]; then\n\t\t\t\trm \"$pre_commit_hook\"\n\t\t\telse\n\t\t\t\tprintf 'WARNING: Cannot safely disable Git pre-commit hook %s please check it yourself\\n' \"$pre_commit_hook\"\n\t\t\tfi\n\t\tfi\n\t\t[[ -f \"$pre_commit_hook_installed\" ]] && rm \"$pre_commit_hook_installed\"\n\n\t\t# remove context settings: cipher & password config, ls-crypt alias variant,\n\t\t# crypt filter/diff/merge attributes. We do it here instead of `clean_gitconfig`\n\t\t# to avoid interfering with flushing of credentials\n\t\tfor context in $CONFIGURED_CONTEXTS; do\n\t\t\tgit config --unset alias.ls-crypt-\"${context}\" 2>/dev/null || true\n\n\t\t\tgit config --remove-section transcrypt.\"${context}\" 2>/dev/null || true\n\n\t\t\tgit config --remove-section filter.crypt-\"${context}\" 2>/dev/null || true\n\t\t\tgit config --remove-section diff.crypt-\"${context}\" 2>/dev/null || true\n\t\t\tgit config --remove-section merge.crypt-\"${context}\" 2>/dev/null || true\n\t\tdone\n\n\t\t# remove the `git ls-crypt` global alias. We must do this late, because\n\t\t# we need it to list the files to touch above.\n\t\tgit config --unset alias.ls-crypt 2>/dev/null || true\n\n\t\t# remove the alias section if it's now empty\n\t\tlocal alias_values\n\t\talias_values=$(git config --get-regex --local 'alias\\..*') || true\n\t\tif [[ ! $alias_values ]]; then\n\t\t\tgit config --remove-section alias 2>/dev/null || true\n\t\tfi\n\n\t\t# unset merge.renormalize if all transcrypt configs are now removed\n\t\tlocal transcrypt_values\n\t\ttranscrypt_values=$(git config --get-regex --local 'transcrypt\\..*') || true\n\t\tif [[ ! $transcrypt_values ]]; then\n\t\t\tgit config --unset merge.renormalize\n\t\tfi\n\n\t\t# remove the merge section if it's now empty\n\t\tlocal merge_values\n\t\tmerge_values=$(git config --get-regex --local 'merge\\..*') || true\n\t\tif [[ ! $merge_values ]]; then\n\t\t\tgit config --remove-section merge 2>/dev/null || true\n\t\tfi\n\n\t\t# remove any defined crypt patterns in gitattributes\n\t\tcase $OSTYPE in\n\t\tdarwin*)\n\t\t\t/usr/bin/sed -i '' \"/filter=crypt/d\" \"$GIT_ATTRIBUTES\"\n\t\t\t;;\n\t\tlinux*)\n\t\t\tsed -i \"/filter=crypt/d\" \"$GIT_ATTRIBUTES\"\n\t\t\t;;\n\t\tesac\n\n\t\tif [[ ! $upgrade ]]; then\n\t\t\tprintf 'The transcrypt configuration has been completely removed from the repository.\\n'\n\t\tfi\n\telse\n\t\tdie 1 'uninstallation has been aborted'\n\tfi\n}\n\n# uninstall and re-install transcrypt to upgrade scripts and update configuration\nupgrade_transcrypt() {\n\t# Fail with an error if we cannot read the existing config\n\tif [[ ! $INSTALLED_VERSION ]]; then\n\t\tdie 1 'no existing transcrypt configuration found'\n\tfi\n\n\tif [[ $interactive ]]; then\n\t\tprintf 'You are about to upgrade the transcrypt scripts in your repository.\\n'\n\t\tprintf 'Your configuration settings will not be changed.\\n\\n'\n\t\tprintf ' Current version: %s\\n' \"$INSTALLED_VERSION\"\n\t\tprintf 'Upgraded version: %s\\n\\n' \"$VERSION\"\n\t\tprintf 'Proceed with upgrade? [y/N] '\n\t\tread -r answer\n\t\tprintf '\\n'\n\n\t\tif [[ $answer =~ $YES_REGEX ]]; then\n\t\t\t# User confirmed, don't prompt again\n\t\t\tinteractive=''\n\t\telse\n\t\t\t# User did not confirm, exit\n\t\t\t# Exit if user did not confirm\n\t\t\tdie 1 'upgrade has been aborted'\n\t\tfi\n\tfi\n\n\t# Keep current cipher and password\n\tcipher=$(git config --get --local \"transcrypt${CONTEXT_CONFIG_GROUP}.cipher\")\n\tpassword=$(load_password \"$CONTEXT_CONFIG_GROUP\")\n\t# Keep current openssl-path, or set to default if no existing value\n\topenssl_path=$(git config --get --local transcrypt.openssl-path 2>/dev/null || printf '%s' \"$openssl_path\")\n\n\t# Keep contents of .gitattributes\n\tORIG_GITATTRIBUTES=$(cat \"$GIT_ATTRIBUTES\")\n\n\t# Keep current cipher and password for each context\n\tORIG_CONFIGS=()\n\tfor context_name in $CONFIGURED_CONTEXTS; do\n\t\tif [[ \"$context_name\" = 'default' ]]; then\n\t\t\tcipher=$(git config --get --local transcrypt.cipher)\n\t\t\tpassword=$(git config --get --local transcrypt.password)\n\t\telse\n\t\t\tcipher=$(git config --get --local transcrypt.\"${context_name}\".cipher)\n\t\t\tpassword=$(git config --get --local transcrypt.\"${context_name}\".password)\n\t\tfi\n\t\tORIG_CONFIGS+=(\"${context_name}|${cipher}|${password}\")\n\tdone\n\n\tuninstall_transcrypt\n\n\t# Reconfigure cipher and password for each context\n\tfor orig_config_line in \"${ORIG_CONFIGS[@]}\"; do\n\t\tcontext=$(echo \"$orig_config_line\" | awk 'BEGIN { FS = \"|\" }; { print $1 }')\n\t\tcipher=$(echo \"$orig_config_line\" | awk 'BEGIN { FS = \"|\" }; { print $2 }')\n\t\tpassword=$(echo \"$orig_config_line\" | awk 'BEGIN { FS = \"|\" }; { print $3 }')\n\n\t\tset_context_globals # This prepares all the variables needed to save config\n\t\tsave_configuration\n\tdone\n\n\t# Re-instate contents of .gitattributes\n\techo \"$ORIG_GITATTRIBUTES\" >\"$GIT_ATTRIBUTES\"\n\n\t# Update .gitattributes for transcrypt'ed files to include \"merge=crypt\" config\n\tcase $OSTYPE in\n\tdarwin*)\n\t\t/usr/bin/sed -i '' 's/diff=crypt$/diff=crypt merge=crypt/' \"$GIT_ATTRIBUTES\"\n\t\t;;\n\tlinux*)\n\t\tsed -i 's/diff=crypt$/diff=crypt merge=crypt/' \"$GIT_ATTRIBUTES\"\n\t\t;;\n\tesac\n\n\tprintf 'Upgrade is complete\\n'\n\n\tLATEST_GITATTRIBUTES=$(cat \"$GIT_ATTRIBUTES\")\n\tif [[ \"$LATEST_GITATTRIBUTES\" != \"$ORIG_GITATTRIBUTES\" ]]; then\n\t\tprintf '\\nYour gitattributes file has been updated with the latest recommended values.\\n'\n\t\tprintf 'Please review and commit the new values in:\\n'\n\t\tprintf '%s\\n' \"$GIT_ATTRIBUTES\"\n\tfi\n}\n\n# list all of the currently encrypted files in the repository\nlist_files() {\n\tif [[ $IS_BARE == 'false' ]]; then\n\t\tcd \"$REPO\" >/dev/null || die 1 'could not change into the \"%s\" directory' \"$REPO\"\n\t\t_list_encrypted_files true\n\tfi\n}\n\n# show the raw file as stored in the git commit object\nshow_raw_file() {\n\tif [[ -f $show_file ]]; then\n\t\t# ensure the file is currently being tracked\n\t\tlocal escaped_file=${show_file//\\//\\\\\\/}\n\t\tfile_paths=$(_list_encrypted_files | grep \"$escaped_file\")\n\t\tif [[ -z \"$file_paths\" ]]; then\n\t\t\tdie 1 'the file \"%s\" is not currently being tracked by git' \"$show_file\"\n\t\tfi\n\telif [[ $show_file == '*' ]]; then\n\t\tfile_paths=$(_list_encrypted_files)\n\telse\n\t\tdie 1 'the file \"%s\" does not exist' \"$show_file\"\n\tfi\n\n\tIFS=$'\\n'\n\tfor file in $file_paths; do\n\t\tprintf '==> %s <==\\n' \"$file\" >&2\n\t\tgit --no-pager show HEAD:\"$file\" --no-textconv\n\t\tprintf '\\n' >&2\n\tdone\n\tunset IFS\n}\n\n# export password and cipher to a gpg encrypted file\nexport_gpg() {\n\t# check for dependencies\n\tcommand -v gpg >/dev/null || die 'required command \"gpg\" was not found'\n\n\t# ensure the recipient key exists\n\tif ! gpg --list-keys \"$gpg_recipient\" 2>/dev/null; then\n\t\tdie 1 'GPG recipient key \"%s\" does not exist' \"$gpg_recipient\"\n\tfi\n\n\tlocal current_cipher\n\tcurrent_cipher=$(git config --get --local \"transcrypt${CONTEXT_CONFIG_GROUP}.cipher\")\n\tlocal current_password\n\tcurrent_password=$(load_password \"$CONTEXT_CONFIG_GROUP\")\n\tmkdir -p \"${CRYPT_DIR}\"\n\n\tlocal gpg_encrypt_cmd=\"gpg --batch --recipient $gpg_recipient --trust-model always --yes --armor --quiet --encrypt -\"\n\tprintf 'password=%s\\ncipher=%s\\n' \"$current_password\" \"$current_cipher\" | $gpg_encrypt_cmd >\"${CRYPT_DIR}/${gpg_recipient}.asc\"\n\tprintf \"The transcrypt configuration has been encrypted and exported to:\\n%s/crypt/%s.asc\\n\" \"$GIT_DIR\" \"$gpg_recipient\"\n}\n\n# import password and cipher from a gpg encrypted file\nimport_gpg() {\n\t# check for dependencies\n\tcommand -v gpg >/dev/null || die 'required command \"gpg\" was not found'\n\n\tlocal path\n\tif [[ -f \"${CRYPT_DIR}/${gpg_import_file}\" ]]; then\n\t\tpath=\"${CRYPT_DIR}/${gpg_import_file}\"\n\telif [[ -f \"${CRYPT_DIR}/${gpg_import_file}.asc\" ]]; then\n\t\tpath=\"${CRYPT_DIR}/${gpg_import_file}.asc\"\n\telif [[ ! -f $gpg_import_file ]]; then\n\t\tdie 1 'the file \"%s\" does not exist' \"$gpg_import_file\"\n\telse\n\t\tpath=\"$gpg_import_file\"\n\tfi\n\n\tlocal configuration=''\n\tlocal safety_counter=0 # fix for intermittent 'no secret key' decryption failures\n\twhile [[ ! $configuration ]]; do\n\t\tconfiguration=$(gpg --batch --quiet --decrypt \"$path\")\n\n\t\tsafety_counter=$((safety_counter + 1))\n\t\tif [[ $safety_counter -eq 3 ]]; then\n\t\t\tdie 1 'unable to decrypt the file \"%s\"' \"$path\"\n\t\tfi\n\tdone\n\n\tcipher=$(printf '%s' \"$configuration\" | grep '^cipher' | cut -d'=' -f 2-)\n\tpassword=$(printf '%s' \"$configuration\" | grep '^password' | cut -d'=' -f 2-)\n}\n\n# Echo space-delimited list of context names defined in the git config\nget_contexts_from_git_config() {\n\tconfig_names=$(git config --local --name-only --list | grep transcrypt)\n\textract_context_name_regex=\"transcrypt\\.(${CONTEXT_REGEX}).password\"\n\tcontexts=()\n\tfor name in $config_names; do\n\t\tif [[ \"$name\" = \"transcrypt.password\" ]]; then\n\t\t\tcontexts+=('default')\n\t\telif [[ $name =~ $extract_context_name_regex ]]; then\n\t\t\tcontexts+=(\"${BASH_REMATCH[1]}\")\n\t\tfi\n\tdone\n\tif [[ \"${contexts:-}\" ]]; then\n\t\ttrim \"$(printf \"%q \" \"${contexts[@]}\")\"\n\tfi\n}\n\n# Echo space-delimited list of context names defined in the .gitattributes file\nget_contexts_from_git_attributes() {\n\tif [[ -f $GIT_ATTRIBUTES ]]; then\n\t\t# Capture contents of .gitattributes without comments (leading # hash)\n\t\tattr_lines=$(sed '/^.*#/d' <\"$GIT_ATTRIBUTES\")\n\t\textract_context_name_regex=\"filter=crypt-(${CONTEXT_REGEX})\"\n\t\trecognise_crypt_regex=\"filter=crypt\"\n\t\tcontexts=()\n\t\tIFS=$'\\n'\n\t\tfor attr_line in ${attr_lines}; do\n\t\t\tif [[ $attr_line =~ $extract_context_name_regex ]]; then\n\t\t\t\tcontexts+=(\"${BASH_REMATCH[1]}\")\n\t\t\telif [[ $attr_line =~ $recognise_crypt_regex ]]; then\n\t\t\t\tcontexts+=('default')\n\t\t\tfi\n\t\tdone\n\t\tunset IFS\n\t\tif [[ \"${contexts:-}\" ]]; then\n\t\t\ttrim \"$(printf \"%q \" \"${contexts[@]}\")\"\n\t\tfi\n\tfi\n}\n\n# Echo all context names, sorted and distinct, from the git config or .gitattributes\nget_contexts() {\n\tcombined_contexts=\"$CONFIGURED_CONTEXTS $GITATTRIBUTES_CONTEXTS\"\n\tsorted_contexts=$(echo \"$combined_contexts\" | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\n\tif [[ \"${sorted_contexts:-}\" ]]; then\n\t\ttrim \"$sorted_contexts\"\n\tfi\n}\n\n# Echo the number of items in a space-delimited list given as $1\ncount_items_in_list() {\n\tlocal trimmed\n\ttrimmed=$(trim \"$1\")\n\tif [[ ! \"$trimmed\" ]]; then\n\t\treturn 0\n\tfi\n\tlocal just_spaces=\"${trimmed//[^ ]/}\"\n\techo $((${#just_spaces} + 1))\n}\n\n# Utility function returns a truthy value if value $1 is in bash list or array $2\n# Based on https://stackoverflow.com/a/8574392/4970\nis_item_in_array() {\n\tlocal e match=\"$1\"\n\tshift\n\tfor e; do [[ \"$e\" == \"$match\" ]] && return 0; done\n\treturn 1\n}\n\n# Trim leading and trailing whitespace from $1\n# From https://stackoverflow.com/a/3352015/4970\ntrim() {\n\tlocal var=\"$*\"\n\t# remove leading whitespace characters\n\tvar=\"${var#\"${var%%[![:space:]]*}\"}\"\n\t# remove trailing whitespace characters\n\tvar=\"${var%\"${var##*[![:space:]]}\"}\"\n\tprintf '%s' \"$var\"\n}\n\nlist_contexts() {\n\tfor context in $(get_contexts); do\n\t\t# shellcheck disable=SC2086\n\t\tif ! is_item_in_array \"$context\" ${CONFIGURED_CONTEXTS}; then\n\t\t\techo \"$context (not initialised)\"\n\t\telif ! is_item_in_array \"$context\" ${GITATTRIBUTES_CONTEXTS}; then\n\t\t\techo \"$context (no patterns in .gitattributes)\"\n\t\telse\n\t\t\techo \"$context\"\n\t\tfi\n\tdone\n}\n\n# print this script's usage message to stderr\nusage() {\n\tcat <<-EOF >&2\n\t\tusage: transcrypt [-c CIPHER] [-p PASSWORD] [-h]\n\tEOF\n}\n\n# print this script's help message to stdout\nhelp() {\n\tcat <<-EOF\n\t\tNAME\n\t\t     transcrypt -- transparently encrypt files within a git repository\n\n\t\tSYNOPSIS\n\t\t     transcrypt [options...]\n\n\t\tDESCRIPTION\n\n\t\t     transcrypt  will  configure a Git repository to support the transparent\n\t\t     encryption/decryption of files by utilizing OpenSSL's symmetric  cipher\n\t\t     routines  and  Git's  built-in clean/smudge filters. It will also add a\n\t\t     Git alias \"ls-crypt\" to list all transparently encrypted  files  within\n\t\t     the repository.\n\n\t\t     The  transcrypt  source  code  and full documentation may be downloaded\n\t\t     from https://github.com/elasticdog/transcrypt.\n\n\t\tOPTIONS\n\t\t     -c, --cipher=CIPHER\n\t\t            the symmetric cipher to utilize for encryption;\n\t\t            defaults to aes-256-cbc\n\n\t\t     -p, --password=PASSWORD\n\t\t            the password to derive the key from;\n\t\t            defaults to 30 random base64 characters\n\n\t\t     --set-openssl-path=PATH_TO_OPENSSL\n\t\t            use OpenSSL at this path; defaults to 'openssl' in \\$PATH\n\n\t\t     -y, --yes\n\t\t            assume yes and accept defaults for non-specified options\n\n\t\t     -d, --display\n\t\t            display the current repository's cipher and password\n\n\t\t     -r, --rekey\n\t\t            re-encrypt all encrypted files using new credentials\n\n\t\t     -f, --flush-credentials\n\t\t            remove the locally cached encryption credentials and  re-encrypt\n\t\t            any files that had been previously decrypted\n\n\t\t     -F, --force\n\t\t            ignore whether the git directory is clean, proceed with the\n\t\t            possibility that uncommitted changes are overwritten\n\n\t\t     -u, --uninstall\n\t\t            remove  all  transcrypt  configuration  from  the repository and\n\t\t            leave files in the current working copy decrypted\n\n\t\t     --upgrade\n\t\t            apply the  latest transcrypt scripts  in the  repository without\n\t\t            changing your configuration settings\n\n\t\t     -l, --list\n\t\t            list all of the transparently encrypted files in the repository,\n\t\t            relative to the top-level directory\n\n\t\t     -s, --show-raw=FILE\n\t\t            show  the  raw file as stored in the git commit object; use this\n\t\t            to check if files are encrypted as expected\n\n\t\t     -e, --export-gpg=RECIPIENT\n\t\t            export  the  repository's cipher and password to a file encrypted\n\t\t            for a gpg recipient\n\n\t\t     -i, --import-gpg=FILE\n\t\t            import the password and cipher from a gpg encrypted file\n\n\t\t     -C, --context=CONTEXT_NAME\n\t\t            name for a context  with a different passphrase  and cipher from\n\t\t            the  'default' context;   use this  advanced option  to  encrypt\n\t\t            different files with different passphrases\n\n\t\t     --list-contexts\n\t\t            list all contexts configured in the  repository,  and warn about\n\t\t            incompletely configured contexts\n\n\t\t     -v, --version\n\t\t            print the version information\n\n\t\t     -h, --help\n\t\t            view this help message\n\n\t\tEXAMPLES\n\n\t\t     To initialize a Git repository to support transparent encryption,  just\n\t\t     change  into  the  repo  and run the transcrypt script. transcrypt will\n\t\t     prompt you interactively for all required  information  if  the  corre-\n\t\t     sponding option flags were not given.\n\n\t\t         $ cd <path-to-your-repo>/\n\t\t         $ transcrypt\n\n\t\t     Once  a  repository has been configured with transcrypt, you can trans-\n\t\t     parently encrypt files by applying the \"crypt\" filter,  diff and  merge\n\t\t     to a pattern in the  top-level .gitattributes config.  If that  pattern\n\t\t     matches  a file in your  repository,  the file  will  be  transparently\n\t\t     encrypted once you stage and commit it:\n\n\t\t         $ echo >> .gitattributes \\\\\n\t\t         'sensitive_file  filter=crypt diff=crypt merge=crypt'\n\n\t\t         $ git add .gitattributes sensitive_file\n\t\t         $ git commit -m 'Add encrypted version of a sensitive file'\n\n\t\t     See the gitattributes(5) man page for more information.\n\n\t\t     If  you  have  just  cloned  a  repository  containing  files  that are\n\t\t     encrypted, you'll want to configure transcrypt with the same cipher and\n\t\t     password  as  the  origin  repository.  Once  transcrypt has stored the\n\t\t     matching  credentials,  it  will  force  a  checkout  of  any  existing\n\t\t     encrypted files in order to decrypt them.\n\n\t\t     If  the  origin  repository  has  just rekeyed, all clones should flush\n\t\t     their transcrypt credentials, fetch and merge the new  encrypted  files\n\t\t     via Git, and then re-configure transcrypt with the new credentials.\n\n\t\tADVANCED\n\n\t\t     Context names let you encrypt some files with different passwords for a\n\t\t     different audience, such as super-users. The 'default'  context applies\n\t\t     unless you set a context name.\n\n\t\t     Add a context by reinitialising transcrypt with a context name then add\n\t\t\t a pattern with crypt-<CONTEXT_NAME> attributes to .gitattributes.\n\t\t     For example, to encrypt a file 'top-secret' in a \"super\" context:\n\n\t\t         # Initialise a new \"super\" context, and set a different password\n\t\t         $ transcrypt --context=super\n\n\t\t         # Add a pattern to .gitattributes with \"crypt-super\" values\n\t\t         $ echo >> .gitattributes \\\\\n\t\t           'top-secret filter=crypt-super diff=crypt-super merge=crypt-super'\n\n\t\t         # Add and commit your top-secret and .gitattribute files\n\t\t         $ git add .gitattributes top-secret\n\t\t         $ git commit -m \"Add top secret file for super-users only\"\n\n\t\t         # List all contexts\n\t\t         $ transcrypt --list-contexts\n\n\t\t         # Display the cipher and password for the \"super\" context\n\t\t         $ transcrypt --context=super --display\n\n\t\tAUTHOR\n\t\t     Aaron Bull Schaefer <aaron@elasticdog.com>\n\n\t\tSEE ALSO\n\t\t     enc(1), gitattributes(5)\n\tEOF\n}\n\n##### MAIN\n\n# reset all variables that might be set\ncontext=''\ncipher=''\ndisplay_config=''\nlist_contexts_command=''\nflush_creds=''\ngpg_import_file=''\ngpg_recipient=''\ninteractive='true'\nlist=''\npassword=''\nrekey=''\nshow_file=''\nuninstall=''\nupgrade=''\nopenssl_path='openssl'\n\n# used to bypass certain safety checks\nrequires_existing_config=''\nrequires_clean_repo='true'\n\n# parse command line options\nwhile [[ \"${1:-}\" != '' ]]; do\n\tcase $1 in\n\tclean)\n\t\tshift\n\t\tgit_clean \"$@\"\n\t\texit $?\n\t\t;;\n\tsmudge)\n\t\tshift\n\t\tgit_smudge \"$@\"\n\t\texit $?\n\t\t;;\n\ttextconv)\n\t\tshift\n\t\tgit_textconv \"$@\"\n\t\texit $?\n\t\t;;\n\tmerge)\n\t\tshift\n\t\tgit_merge \"$@\"\n\t\texit $?\n\t\t;;\n\tpre_commit)\n\t\tshift\n\t\tgit_pre_commit \"$@\"\n\t\texit $?\n\t\t;;\n\t-c | --cipher)\n\t\tcipher=$2\n\t\tshift\n\t\t;;\n\t--cipher=*)\n\t\tcipher=${1#*=}\n\t\t;;\n\t-p | --password)\n\t\tpassword=$2\n\t\t[[ $password ]] || die 1 'empty password'\n\t\tshift\n\t\t;;\n\t--password=*)\n\t\tpassword=${1#*=}\n\t\t[[ $password ]] || die 1 'empty password'\n\t\t;;\n\t-C | --context)\n\t\tcontext=$2\n\t\tshift\n\t\t;;\n\t--context=*)\n\t\tcontext=${1#*=}\n\t\t;;\n\t--set-openssl-path=*)\n\t\topenssl_path=${1#*=}\n\t\t# Immediately apply config setting\n\t\tgit config transcrypt.openssl-path \"$openssl_path\"\n\t\t;;\n\t-y | --yes)\n\t\tinteractive=''\n\t\t;;\n\t-d | --display)\n\t\tdisplay_config='true'\n\t\trequires_existing_config='true'\n\t\trequires_clean_repo=''\n\t\t;;\n\t-r | --rekey)\n\t\trekey='true'\n\t\trequires_existing_config='true'\n\t\t;;\n\t-f | --flush-credentials)\n\t\tflush_creds='true'\n\t\trequires_existing_config='true'\n\t\t;;\n\t-F | --force)\n\t\trequires_clean_repo=''\n\t\t;;\n\t-u | --uninstall)\n\t\tuninstall='true'\n\t\trequires_existing_config='true'\n\t\trequires_clean_repo=''\n\t\t;;\n\t--upgrade)\n\t\tupgrade='true'\n\t\trequires_existing_config='true'\n\t\trequires_clean_repo=''\n\t\t;;\n\t-l | --list)\n\t\tlist='true'\n\t\trequires_clean_repo=''\n\t\t;;\n\t--list-contexts)\n\t\tlist_contexts_command='true'\n\t\trequires_clean_repo=''\n\t\t;;\n\t-s | --show-raw)\n\t\tshow_file=$2\n\t\tshow_raw_file\n\t\texit 0\n\t\t;;\n\t--show-raw=*)\n\t\tshow_file=${1#*=}\n\t\tshow_raw_file\n\t\texit 0\n\t\t;;\n\t-e | --export-gpg)\n\t\tgpg_recipient=$2\n\t\trequires_existing_config='true'\n\t\trequires_clean_repo=''\n\t\tshift\n\t\t;;\n\t--export-gpg=*)\n\t\tgpg_recipient=${1#*=}\n\t\trequires_existing_config='true'\n\t\trequires_clean_repo=''\n\t\t;;\n\t-i | --import-gpg)\n\t\tgpg_import_file=$2\n\t\tshift\n\t\t;;\n\t--import-gpg=*)\n\t\tgpg_import_file=${1#*=}\n\t\t;;\n\t-v | --version)\n\t\tprintf 'transcrypt %s\\n' \"$VERSION\"\n\t\texit 0\n\t\t;;\n\t-h | --help | -\\?)\n\t\thelp\n\t\texit 0\n\t\t;;\n\t--*)\n\t\twarn 'unknown option -- %s' \"${1#--}\"\n\t\tusage\n\t\texit 1\n\t\t;;\n\t*)\n\t\twarn 'unknown option -- %s' \"${1#-}\"\n\t\tusage\n\t\texit 1\n\t\t;;\n\tesac\n\tshift\ndone\n\n# Multi-context support, triggered by optional --context / -C command line option\nset_context_globals() {\n\tif [[ \"$context\" ]] && [[ ! \"$context\" = 'default' ]]; then\n\t\tCONTEXT=\"$context\"\n\t\tCONTEXT_CONFIG_GROUP=\".${CONTEXT}\" # Note leading period\n\t\tCONTEXT_CRYPT_SUFFIX=\"-${CONTEXT}\" # Note leading dash\n\t\tCONTEXT_DESCRIPTION=\" for context '$CONTEXT'\"\n\telse\n\t\tCONTEXT='default'\n\t\t# Empty values for default/unset context\n\t\tCONTEXT_CONFIG_GROUP=\"\"\n\t\tCONTEXT_CRYPT_SUFFIX=\"\"\n\t\tCONTEXT_DESCRIPTION=\"\"\n\tfi\n}\nset_context_globals\n\ngather_repo_metadata\n\n# always run our safety checks\nrun_safety_checks\n\n# regular expression used to test user input\nreadonly YES_REGEX='^[Yy]$'\n\n# in order to keep behavior consistent no matter what order the options were\n# specified in, we must run these here rather than in the case statement above\nif [[ $list ]]; then\n\tlist_files\n\texit 0\nelif [[ $uninstall ]]; then\n\tuninstall_transcrypt\n\texit 0\nelif [[ $upgrade ]]; then\n\tupgrade_transcrypt\n\texit 0\nelif [[ $display_config ]] && [[ $flush_creds ]]; then\n\tdisplay_configuration\n\tprintf '\\n'\n\tflush_credentials\n\texit 0\nelif [[ $display_config ]]; then\n\tdisplay_configuration\n\texit 0\nelif [[ $list_contexts_command ]]; then\n\tlist_contexts\n\texit 0\nelif [[ $flush_creds ]]; then\n\tflush_credentials\n\texit 0\nelif [[ $gpg_recipient ]]; then\n\texport_gpg\n\texit 0\nelif [[ $gpg_import_file ]]; then\n\timport_gpg\nelif [[ $cipher ]]; then\n\tvalidate_cipher\nfi\n\n# perform function calls to configure transcrypt\nget_cipher\nget_password\n\nif [[ $rekey ]] && [[ $interactive ]]; then\n\tconfirm_rekey\nelif [[ $interactive ]]; then\n\tconfirm_configuration\nfi\n\nsave_configuration\n\nif [[ $rekey ]]; then\n\tstage_rekeyed_files\nelse\n\tforce_checkout\nfi\n\n# ensure the git attributes file exists\nif [[ ! -f $GIT_ATTRIBUTES ]]; then\n\tmkdir -p \"${GIT_ATTRIBUTES%/*}\"\n\tprintf '#pattern  filter=crypt diff=crypt merge=crypt\\n' >\"$GIT_ATTRIBUTES\"\nfi\n\nprintf 'The repository has been successfully configured by transcrypt%s.\\n' \"$CONTEXT_DESCRIPTION\"\n\nexit 0\n"
        }
      ]
    }
  ]
}