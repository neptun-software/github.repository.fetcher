{
  "metadata": {
    "timestamp": 1736568204798,
    "page": 49,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dylanaraps/fff",
      "stars": 4099,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2099609375,
          "content": "language: bash\nsudo: required\n\nos:\n    - linux\n\nscript:\n    - shellcheck fff -e 2254 -e 2244 -e 1090 -e 1091\n    # Check for lines longer than 80 chars.\n    - if grep '.\\{81\\}' fff; then (exit 1); else (exit 0); fi\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0576171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016-2018 Dylan Araps\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.50390625,
          "content": "PREFIX ?= /usr\nMANDIR ?= $(PREFIX)/share/man\nDOCDIR ?= $(PREFIX)/share/doc/fff\n\nall:\n\t@echo Run \\'make install\\' to install fff.\n\ninstall:\n\t@mkdir -p $(DESTDIR)$(PREFIX)/bin\n\t@mkdir -p $(DESTDIR)$(MANDIR)/man1\n\t@mkdir -p $(DESTDIR)$(DOCDIR)\n\t@cp -p fff $(DESTDIR)$(PREFIX)/bin/fff\n\t@cp -p fff.1 $(DESTDIR)$(MANDIR)/man1\n\t@cp -p README.md $(DESTDIR)$(DOCDIR)\n\t@chmod 755 $(DESTDIR)$(PREFIX)/bin/fff\n\nuninstall:\n\t@rm -rf $(DESTDIR)$(PREFIX)/bin/fff\n\t@rm -rf $(DESTDIR)$(MANDIR)/man1/fff.1\n\t@rm -rf $(DESTDIR)$(DOCDIR)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.9521484375,
          "content": "# fff (*Fucking Fast File-Manager*)\n\n<a href=\"https://asciinema.org/a/qvNlrFrGB3xKZXb6GkremjZNp\" target=\"_blank\"><img src=\"https://asciinema.org/a/qvNlrFrGB3xKZXb6GkremjZNp.svg\" alt=\"img\" height=\"210px\" align=\"right\"/></a>\n\nA simple file manager written in `bash`.\n\n<a href=\"https://travis-ci.org/dylanaraps/fff\"><img src=\"https://travis-ci.org/dylanaraps/fff.svg?branch=master\"></a>\n<a href=\"https://github.com/dylanaraps/fff/releases\"><img src=\"https://img.shields.io/github/release/dylanaraps/fff.svg\"></a>\n<a href=\"https://repology.org/metapackage/fff\"><img src=\"https://repology.org/badge/tiny-repos/fff.svg\" alt=\"Packaging status\"></a>\n\n- It's Fucking Fast ðŸš€\n- Minimal (*only requires **bash** and coreutils*)\n- Smooth Scrolling (*using **vim** keybindings*)\n- Works on **Linux**, **BSD**, **macOS**, **Haiku** etc.\n- Supports `LS_COLORS`!\n- File Operations (*copy, paste, cut, **ranger style bulk rename**, etc*) <img src=\"https://i.imgur.com/tjIWUjf.jpg\" alt=\"img\" height=\"213px\" align=\"right\"/>\n- Instant as you type search\n- Tab completion for all commands!\n- Automatic CD on exit (*see [setup](#cd-on-exit)*)\n- Works as a **file picker** in `vim`/`neovim` ([**link**](https://github.com/dylanaraps/fff.vim))!\n- **Display images with w3m-img!**\n- Supports `$CDPATH`.\n\n\n## Table of Contents\n\n<!-- vim-markdown-toc GFM -->\n\n* [Dependencies](#dependencies)\n* [Installation](#installation)\n    * [Distros](#distros)\n    * [Manual](#manual)\n    * [CD on Exit](#cd-on-exit)\n        * [Bash and Zsh](#bash-and-zsh)\n        * [Fish](#fish)\n* [Usage](#usage)\n* [Customization](#customization)\n* [Customizing the keybindings.](#customizing-the-keybindings)\n    * [Keybindings](#keybindings)\n    * [Disabling keybindings.](#disabling-keybindings)\n    * [Dealing with conflicting keybindings.](#dealing-with-conflicting-keybindings)\n    * [How to figure out special keys.](#how-to-figure-out-special-keys)\n* [Using `fff` in vim/neovim as a file picker](#using-fff-in-vimneovim-as-a-file-picker)\n* [Why?](#why)\n\n<!-- vim-markdown-toc -->\n\n\n## Dependencies\n\n- `bash 3.2+`\n- `coreutils`\n    - File operations.\n- `xdg-utils` (*optional*)\n    - Program handling (*non-text*).\n    - *Not needed on macos and Haiku.*\n    - *Customizable (if not using `xdg-open`): `$FFF_OPENER`.*\n\n**Dependencies for image display**\n\n- `w3m-img`\n- `xdotool` for X.\n- `fbset` for the framebuffer.\n\n\n## Installation\n\n### Distros\n\n- KISS Linux (based): `kiss b fff`\n- FreeBSD: `pkg install fff`\n- Haiku: `pkgman install fff`\n- macOS: `brew install fff`\n- Nix: `nix-env -iA fff`\n- Void Linux: `xbps-install -S fff`\n- Arch Linux: `pacman -S fff`\n\n### Manual\n\n1. Download `fff`.\n    - Release: https://github.com/dylanaraps/fff/releases/latest\n    - Git: `git clone https://github.com/dylanaraps/fff`\n2. Change working directory to `fff`.\n    - `cd fff`\n3. Run `make install` inside the script directory to install the script.\n    - **El Capitan**: `make PREFIX=/usr/local install`\n    - **Haiku**: `make PREFIX=\"$(finddir B_USER_NONPACKAGED_DIRECTORY)\" MANDIR='$(PREFIX)/documentation/man' DOCDIR='$(PREFIX)/documentation/fff' install`\n    - **OpenIndiana**: `gmake install`\n    - **MinGW/MSys**: `make -i install`\n    - **NOTE**: You may have to run this as root.\n\n**NOTE:** `fff` can be uninstalled easily using `make uninstall`. This removes all of files from your system.\n\n### CD on Exit\n#### Bash and Zsh\n```sh\n# Add this to your .bashrc, .zshrc or equivalent.\n# Run 'fff' with 'f' or whatever you decide to name the function.\nf() {\n    fff \"$@\"\n    cd \"$(cat \"${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d\")\"\n}\n```\n#### Fish\n```sh\n# Add this to you config.fish or equivalent.\n# Fish don't support recursive calls so use f function\nfunction f\n    fff $argv\n    set -q XDG_CACHE_HOME; or set XDG_CACHE_HOME $HOME/.cache\n    cd (cat $XDG_CACHE_HOME/fff/.fff_d)\nend\n```\n\n## Usage\n\n```sh\nj: scroll down\nk: scroll up\nh: go to parent dir\nl: go to child dir\n\nenter: go to child dir\nbackspace: go to parent dir\n\n-: Go to previous dir.\n\ng: go to top\nG: go to bottom\n\n:: go to a directory by typing.\n\n.: toggle hidden files\n/: search\nt: go to trash\n~: go to home\ne: refresh current dir\n!: open shell in current dir\n\nx: view file/dir attributes\ni: display image with w3m-img\n\ndown:  scroll down\nup:    scroll up\nleft:  go to parent dir\nright: go to child dir\n\nf: new file\nn: new dir\nr: rename\nX: toggle executable\n\ny: mark copy\nm: mark move\nd: mark trash (~/.local/share/fff/trash/)\ns: mark symbolic link\nb: mark bulk rename\n\nY: mark all for copy\nM: mark all for move\nD: mark all for trash (~/.local/share/fff/trash/)\nS: mark all for symbolic link\nB: mark all for bulk rename\n\np: execute paste/move/delete/bulk_rename\nc: clear file selections\n\n[1-9]: favourites/bookmarks (see customization)\n\nq: exit with 'cd' (if enabled).\nCtrl+C: exit without 'cd'.\n```\n\n## Customization\n\n```sh\n# Show/Hide hidden files on open.\n# (Off by default)\nexport FFF_HIDDEN=1\n\n# Use LS_COLORS to color fff.\n# (On by default if available)\n# (Ignores FFF_COL1)\nexport FFF_LS_COLORS=1\n\n# Directory color [0-9]\nexport FFF_COL1=2\n\n# Status background color [0-9]\nexport FFF_COL2=7\n\n# Selection color [0-9] (copied/moved files)\nexport FFF_COL3=6\n\n# Cursor color [0-9]\nexport FFF_COL4=1\n\n# Status foreground color [0-9]\nexport FFF_COL5=0\n\n# Text Editor\nexport EDITOR=\"vim\"\n\n# File Opener\nexport FFF_OPENER=\"xdg-open\"\n\n# File Attributes Command\nexport FFF_STAT_CMD=\"stat\"\n\n# Enable or disable CD on exit.\n# (On by default)\nexport FFF_CD_ON_EXIT=0\n\n# CD on exit helper file\n# Default: '${XDG_CACHE_HOME}/fff/fff.d'\n#          If not using XDG, '${HOME}/.cache/fff/fff.d' is used.\nexport FFF_CD_FILE=~/.fff_d\n\n# Trash Directory\n# Default: '${XDG_DATA_HOME}/fff/trash'\n#          If not using XDG, '${HOME}/.local/share/fff/trash' is used.\nexport FFF_TRASH=~/.local/share/fff/trash\n\n# Trash Command\n# Default: 'mv'\n#          Define a custom program to use to trash files.\n#          The program will be passed the list of selected files\n#          and directories.\nexport FFF_TRASH_CMD=\"mv\"\n\n# Favourites (Bookmarks) (keys 1-9) (dir or file)\nexport FFF_FAV1=~/projects\nexport FFF_FAV2=~/.bashrc\nexport FFF_FAV3=~/Pictures/Wallpapers/\nexport FFF_FAV4=/usr/share\nexport FFF_FAV5=/\nexport FFF_FAV6=\nexport FFF_FAV7=\nexport FFF_FAV8=\nexport FFF_FAV9=\n\n# w3m-img offsets.\nexport FFF_W3M_XOFFSET=0\nexport FFF_W3M_YOFFSET=0\n\n# File format.\n# Customize the item string.\n# Format ('%f' is the current file): \"str%fstr\"\n# Example (Add a tab before files): FFF_FILE_FORMAT=\"\\t%f\"\nexport FFF_FILE_FORMAT=\"%f\"\n\n# Mark format.\n# Customize the marked item string.\n# Format ('%f' is the current file): \"str%fstr\"\n# Example (Add a ' >' before files): FFF_MARK_FORMAT=\"> %f\"\nexport FFF_MARK_FORMAT=\" %f*\"\n```\n\n## Customizing the keybindings.\n\n### Keybindings\n\nThis is the list of full keybindings along with their default values. You only need to modify the keybindings that you'd like to change from the default. `fff` will run perfectly fine without any of these defined.\n\n```sh\n### Moving around.\n\n# Go to child directory.\nexport FFF_KEY_CHILD1=\"l\"\nexport FFF_KEY_CHILD2=$'\\e[C' # Right Arrow\nexport FFF_KEY_CHILD3=\"\"      # Enter / Return\n\n# Go to parent directory.\nexport FFF_KEY_PARENT1=\"h\"\nexport FFF_KEY_PARENT2=$'\\e[D' # Left Arrow\nexport FFF_KEY_PARENT3=$'\\177' # Backspace\nexport FFF_KEY_PARENT4=$'\\b'   # Backspace (Older terminals)\n\n# Go to previous directory.\nexport FFF_KEY_PREVIOUS=\"-\"\n\n# Search.\nexport FFF_KEY_SEARCH=\"/\"\n\n# Spawn a shell.\nexport FFF_KEY_SHELL=\"!\"\n\n# Scroll down.\nexport FFF_KEY_SCROLL_DOWN1=\"j\"\nexport FFF_KEY_SCROLL_DOWN2=$'\\e[B' # Down Arrow\n\n# Scroll up.\nexport FFF_KEY_SCROLL_UP1=\"k\"\nexport FFF_KEY_SCROLL_UP2=$'\\e[A'   # Up Arrow\n\n# Go to top and bottom.\nexport FFF_KEY_TO_TOP=\"g\"\nexport FFF_KEY_TO_BOTTOM=\"G\"\n\n# Go to dirs.\nexport FFF_KEY_GO_DIR=\":\"\nexport FFF_KEY_GO_HOME=\"~\"\nexport FFF_KEY_GO_TRASH=\"t\"\nexport FFF_KEY_REFRESH=\"e\"\n\n### File operations.\n\nexport FFF_KEY_YANK=\"y\"\nexport FFF_KEY_MOVE=\"m\"\nexport FFF_KEY_TRASH=\"d\"\nexport FFF_KEY_LINK=\"s\"\nexport FFF_KEY_BULK_RENAME=\"b\"\n\nexport FFF_KEY_YANK_ALL=\"Y\"\nexport FFF_KEY_MOVE_ALL=\"M\"\nexport FFF_KEY_TRASH_ALL=\"D\"\nexport FFF_KEY_LINK_ALL=\"S\"\nexport FFF_KEY_BULK_RENAME_ALL=\"B\"\n\nexport FFF_KEY_PASTE=\"p\"\nexport FFF_KEY_CLEAR=\"c\"\n\nexport FFF_KEY_RENAME=\"r\"\nexport FFF_KEY_MKDIR=\"n\"\nexport FFF_KEY_MKFILE=\"f\"\nexport FFF_KEY_IMAGE=\"i\" # display image with w3m-img\n\n### Miscellaneous\n\n# Show file attributes.\nexport FFF_KEY_ATTRIBUTES=\"x\"\n\n# Toggle executable flag.\nexport FFF_KEY_EXECUTABLE=\"X\"\n\n# Toggle hidden files.\nexport FFF_KEY_HIDDEN=\".\"\n```\n\n### Disabling keybindings.\n\nYou can't unset keybindings by making their value `''`. What you need to do is change their value to `off`.\n\nExample:\n\n```sh\n# KEY_GO_TRASH was bound to 't', now its unset.\nexport FFF_KEY_GO_TRASH=\"off\"\n\n# KEY_MKFILE is now set to 't' and its original\n# keybinding is also unset 'f'.\nexport FFF_KEY_MKFILE=\"t\"\n```\n\n### Dealing with conflicting keybindings.\n\nWhen rebinding a key in `fff` make sure you don't have two bindings with the same value. You can avoid this by setting the other conflicting key-binding to something else or by changing its value to `off`.\n\n\n### How to figure out special keys.\n\nBelow is a tiny script I've written which will tell you the exact value to use. It automates the deciphering of special key escape sequences to the exact value `fff` needs. Save this to a file and run it. Give it a key-press and it'll spit out the exact value needed.\n\n```sh\n#!/usr/bin/env bash\n# Output the key-binding values for 'fff'.\nkey() {\n    case \"$1\" in\n        # Backspace.\n        $'\\b'|$'\\177')\n            printf '%s\\n' \"key: \\$'\\\\b' or \\$'\\\\177'\"\n        ;;\n\n        # Escape Sequences.\n        $'\\e')\n            read -rsn 2\n            printf '%s %q\\n' \"key:\" \"${1}${REPLY}\"\n        ;;\n\n        # Return / Enter.\n        \"\")\n            printf '%s\\n' \"key: \\\" \\\"\"\n        ;;\n\n        # Everything else.\n        *)\n            printf '%s %q\\n' \"key:\" \"$1\"\n        ;;\n    esac\n}\n\nread -srn 1 && key \"$REPLY\"\n```\n\n## Using `fff` in vim/neovim as a file picker\n\nSee: [**`fff.vim`**](https://github.com/dylanaraps/fff.vim)\n\n\n## Why?\n\nÂ¯\\\\_(ãƒ„)_/Â¯\n\n<sup><sub>dont touch my shrug</sub></sup>\n"
        },
        {
          "name": "fff",
          "type": "blob",
          "size": 32.4072265625,
          "content": "#!/usr/bin/env bash\n#\n# fff - fucking fast file-manager.\n\nget_os() {\n    # Figure out the current operating system to set some specific variables.\n    # '$OSTYPE' typically stores the name of the OS kernel.\n    case $OSTYPE in\n        # Mac OS X / macOS.\n        darwin*)\n            opener=open\n            file_flags=bIL\n        ;;\n\n        haiku)\n            opener=open\n\n            [[ -z $FFF_TRASH_CMD ]] &&\n                FFF_TRASH_CMD=trash\n\n            [[ $FFF_TRASH_CMD == trash ]] && {\n                FFF_TRASH=$(finddir -v \"$PWD\" B_TRASH_DIRECTORY)\n                mkdir -p \"$FFF_TRASH\"\n            }\n        ;;\n    esac\n}\n\nsetup_terminal() {\n    # Setup the terminal for the TUI.\n    # '\\e[?1049h': Use alternative screen buffer.\n    # '\\e[?7l':    Disable line wrapping.\n    # '\\e[?25l':   Hide the cursor.\n    # '\\e[2J':     Clear the screen.\n    # '\\e[1;Nr':   Limit scrolling to scrolling area.\n    #              Also sets cursor to (0,0).\n    printf '\\e[?1049h\\e[?7l\\e[?25l\\e[2J\\e[1;%sr' \"$max_items\"\n\n    # Hide echoing of user input\n    stty -echo\n}\n\nreset_terminal() {\n    # Reset the terminal to a useable state (undo all changes).\n    # '\\e[?7h':   Re-enable line wrapping.\n    # '\\e[?25h':  Unhide the cursor.\n    # '\\e[2J':    Clear the terminal.\n    # '\\e[;r':    Set the scroll region to its default value.\n    #             Also sets cursor to (0,0).\n    # '\\e[?1049l: Restore main screen buffer.\n    printf '\\e[?7h\\e[?25h\\e[2J\\e[;r\\e[?1049l'\n\n    # Show user input.\n    stty echo\n}\n\nclear_screen() {\n    # Only clear the scrolling window (dir item list).\n    # '\\e[%sH':    Move cursor to bottom of scroll area.\n    # '\\e[9999C':  Move cursor to right edge of the terminal.\n    # '\\e[1J':     Clear screen to top left corner (from cursor up).\n    # '\\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).\n    # '\\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.\n    #              Also sets cursor to (0,0).\n    printf '\\e[%sH\\e[9999C\\e[1J%b\\e[1;%sr' \\\n           \"$((LINES-2))\" \"${TMUX:+\\e[2J}\" \"$max_items\"\n}\n\nsetup_options() {\n    # Some options require some setup.\n    # This function is called once on open to parse\n    # select options so the operation isn't repeated\n    # multiple times in the code.\n\n    # Format for normal files.\n    [[ $FFF_FILE_FORMAT == *%f* ]] && {\n        file_pre=${FFF_FILE_FORMAT/'%f'*}\n        file_post=${FFF_FILE_FORMAT/*'%f'}\n    }\n\n    # Format for marked files.\n    # Use affixes provided by the user or use defaults, if necessary.\n    if [[ $FFF_MARK_FORMAT == *%f* ]]; then\n        mark_pre=${FFF_MARK_FORMAT/'%f'*}\n        mark_post=${FFF_MARK_FORMAT/*'%f'}\n    else\n        mark_pre=\" \"\n        mark_post=\"*\"\n    fi\n\n    # Find supported 'file' arguments.\n    file -I &>/dev/null || : \"${file_flags:=biL}\"\n}\n\nget_term_size() {\n    # Get terminal size ('stty' is POSIX and always available).\n    # This can't be done reliably across all bash versions in pure bash.\n    read -r LINES COLUMNS < <(stty size)\n\n    # Max list items that fit in the scroll area.\n    ((max_items=LINES-3))\n}\n\nget_ls_colors() {\n    # Parse the LS_COLORS variable and declare each file type\n    # as a separate variable.\n    # Format: ':.ext=0;0:*.jpg=0;0;0:*png=0;0;0;0:'\n    [[ -z $LS_COLORS ]] && {\n        FFF_LS_COLORS=0\n        return\n    }\n\n    # Turn $LS_COLORS into an array.\n    IFS=: read -ra ls_cols <<< \"$LS_COLORS\"\n\n    for ((i=0;i<${#ls_cols[@]};i++)); {\n        # Separate patterns from file types.\n        [[ ${ls_cols[i]} =~ ^\\*[^\\.] ]] &&\n            ls_patterns+=\"${ls_cols[i]/=*}|\"\n\n        # Prepend 'ls_' to all LS_COLORS items\n        # if they aren't types of files (symbolic links, block files etc.)\n        [[ ${ls_cols[i]} =~ ^(\\*|\\.) ]] && {\n            ls_cols[i]=${ls_cols[i]#\\*}\n            ls_cols[i]=ls_${ls_cols[i]#.}\n        }\n    }\n\n    # Strip non-ascii characters from the string as they're\n    # used as a key to color the dir items and variable\n    # names in bash must be '[a-zA-z0-9_]'.\n    ls_cols=(\"${ls_cols[@]//[^a-zA-Z0-9=\\\\;]/_}\")\n\n    # Store the patterns in a '|' separated string\n    # for use in a REGEX match later.\n    ls_patterns=${ls_patterns//\\*}\n    ls_patterns=${ls_patterns%?}\n\n    # Define the ls_ variables.\n    # 'declare' can't be used here as variables are scoped\n    # locally. 'declare -g' is not available in 'bash 3'.\n    # 'export' is a viable alternative.\n    export \"${ls_cols[@]}\" &>/dev/null\n}\n\nget_w3m_path() {\n    # Find the path to the w3m-img library.\n    w3m_paths=(/usr/{pkg/,}{local/,}{bin,lib,libexec,lib64,libexec64}/w3m/w3mi*)\n    read -r w3m _ < <(type -p \"$FFF_W3M_PATH\" w3mimgdisplay \"${w3m_paths[@]}\")\n}\n\nget_mime_type() {\n    # Get a file's mime_type.\n    mime_type=$(file \"-${file_flags:-biL}\" \"$1\" 2>/dev/null)\n}\n\nstatus_line() {\n    # Status_line to print when files are marked for operation.\n    local mark_ui=\"[${#marked_files[@]}] selected (${file_program[*]}) [p] ->\"\n\n    # Escape the directory string.\n    # Remove all non-printable characters.\n    PWD_escaped=${PWD//[^[:print:]]/^[}\n\n    # '\\e7':       Save cursor position.\n    #              This is more widely supported than '\\e[s'.\n    # '\\e[%sH':    Move cursor to bottom of the terminal.\n    # '\\e[30;41m': Set foreground and background colors.\n    # '%*s':       Insert enough spaces to fill the screen width.\n    #              This sets the background color to the whole line\n    #              and fixes issues in 'screen' where '\\e[K' doesn't work.\n    # '\\r':        Move cursor back to column 0 (was at EOL due to above).\n    # '\\e[m':      Reset text formatting.\n    # '\\e[H\\e[K':  Clear line below status_line.\n    # '\\e8':       Restore cursor position.\n    #              This is more widely supported than '\\e[u'.\n    printf '\\e7\\e[%sH\\e[3%s;4%sm%*s\\r%s %s%s\\e[m\\e[%sH\\e[K\\e8' \\\n           \"$((LINES-1))\" \\\n           \"${FFF_COL5:-0}\" \\\n           \"${FFF_COL2:-1}\" \\\n           \"$COLUMNS\" \"\" \\\n           \"($((scroll+1))/$((list_total+1)))\" \\\n           \"${marked_files[*]:+${mark_ui}}\" \\\n           \"${1:-${PWD_escaped:-/}}\" \\\n           \"$LINES\"\n}\n\nread_dir() {\n    # Read a directory to an array and sort it directories first.\n    local dirs\n    local files\n    local item_index\n\n    # Set window name.\n    printf '\\e]2;fff: %s\\e'\\\\ \"$PWD\"\n\n    # If '$PWD' is '/', unset it to avoid '//'.\n    [[ $PWD == / ]] && PWD=\n\n    for item in \"$PWD\"/*; do\n        if [[ -d $item ]]; then\n            dirs+=(\"$item\")\n\n            # Find the position of the child directory in the\n            # parent directory list.\n            [[ $item == \"$OLDPWD\" ]] &&\n                ((previous_index=item_index))\n            ((item_index++))\n        else\n            files+=(\"$item\")\n        fi\n    done\n\n    list=(\"${dirs[@]}\" \"${files[@]}\")\n\n    # Indicate that the directory is empty.\n    [[ -z ${list[0]} ]] &&\n        list[0]=empty\n\n    ((list_total=${#list[@]}-1))\n\n    # Save the original dir in a second list as a backup.\n    cur_list=(\"${list[@]}\")\n}\n\nprint_line() {\n    # Format the list item and print it.\n    local file_name=${list[$1]##*/}\n    local file_ext=${file_name##*.}\n    local format\n    local suffix\n\n    # If the dir item doesn't exist, end here.\n    if [[ -z ${list[$1]} ]]; then\n        return\n\n    # Directory.\n    elif [[ -d ${list[$1]} ]]; then\n        format+=\\\\e[${di:-1;3${FFF_COL1:-2}}m\n        suffix+=/\n\n    # Block special file.\n    elif [[ -b ${list[$1]} ]]; then\n        format+=\\\\e[${bd:-40;33;01}m\n\n    # Character special file.\n    elif [[ -c ${list[$1]} ]]; then\n        format+=\\\\e[${cd:-40;33;01}m\n\n    # Executable file.\n    elif [[ -x ${list[$1]} ]]; then\n        format+=\\\\e[${ex:-01;32}m\n\n    # Symbolic Link (broken).\n    elif [[ -h ${list[$1]} && ! -e ${list[$1]} ]]; then\n        format+=\\\\e[${mi:-01;31;7}m\n\n    # Symbolic Link.\n    elif [[ -h ${list[$1]} ]]; then\n        format+=\\\\e[${ln:-01;36}m\n\n    # Fifo file.\n    elif [[ -p ${list[$1]} ]]; then\n        format+=\\\\e[${pi:-40;33}m\n\n    # Socket file.\n    elif [[ -S ${list[$1]} ]]; then\n        format+=\\\\e[${so:-01;35}m\n\n    # Color files that end in a pattern as defined in LS_COLORS.\n    # 'BASH_REMATCH' is an array that stores each REGEX match.\n    elif [[ $FFF_LS_COLORS == 1 &&\n            $ls_patterns &&\n            $file_name =~ ($ls_patterns)$ ]]; then\n        match=${BASH_REMATCH[0]}\n        file_ext=ls_${match//[^a-zA-Z0-9=\\\\;]/_}\n        format+=\\\\e[${!file_ext:-${fi:-37}}m\n\n    # Color files based on file extension and LS_COLORS.\n    # Check if file extension adheres to POSIX naming\n    # standard before checking if it's a variable.\n    elif [[ $FFF_LS_COLORS == 1 &&\n            $file_ext != \"$file_name\" &&\n            $file_ext =~ ^[a-zA-Z0-9_]*$ ]]; then\n        file_ext=ls_${file_ext}\n        format+=\\\\e[${!file_ext:-${fi:-37}}m\n\n    else\n        format+=\\\\e[${fi:-37}m\n    fi\n\n    # If the list item is under the cursor.\n    (($1 == scroll)) &&\n        format+=\"\\\\e[1;3${FFF_COL4:-6};7m\"\n\n    # If the list item is marked for operation.\n    [[ ${marked_files[$1]} == \"${list[$1]:-null}\" ]] && {\n        format+=\\\\e[3${FFF_COL3:-1}m${mark_pre}\n        suffix+=${mark_post}\n    }\n\n    # Escape the directory string.\n    # Remove all non-printable characters.\n    file_name=${file_name//[^[:print:]]/^[}\n\n    printf '\\r%b%s\\e[m\\r' \\\n        \"${file_pre}${format}\" \\\n        \"${file_name}${suffix}${file_post}\"\n}\n\ndraw_dir() {\n    # Print the max directory items that fit in the scroll area.\n    local scroll_start=$scroll\n    local scroll_new_pos\n    local scroll_end\n\n    # When going up the directory tree, place the cursor on the position\n    # of the previous directory.\n    ((find_previous == 1)) && {\n        ((scroll_start=previous_index))\n        ((scroll=scroll_start))\n\n        # Clear the directory history. We're here now.\n        find_previous=\n    }\n\n    # If current dir is near the top of the list, keep scroll position.\n    if ((list_total < max_items || scroll < max_items/2)); then\n        ((scroll_start=0))\n        ((scroll_end=max_items))\n        ((scroll_new_pos=scroll+1))\n\n    # If current dir is near the end of the list, keep scroll position.\n    elif ((list_total - scroll < max_items/2)); then\n        ((scroll_start=list_total-max_items+1))\n        ((scroll_new_pos=max_items-(list_total-scroll)))\n        ((scroll_end=list_total+1))\n\n    # If current dir is somewhere in the middle, center scroll position.\n    else\n        ((scroll_start=scroll-max_items/2))\n        ((scroll_end=scroll_start+max_items))\n        ((scroll_new_pos=max_items/2+1))\n    fi\n\n    # Reset cursor position.\n    printf '\\e[H'\n\n    for ((i=scroll_start;i<scroll_end;i++)); {\n        # Don't print one too many newlines.\n        ((i > scroll_start)) &&\n            printf '\\n'\n\n        print_line \"$i\"\n    }\n\n    # Move the cursor to its new position if it changed.\n    # If the variable 'scroll_new_pos' is empty, the cursor\n    # is moved to line '0'.\n    printf '\\e[%sH' \"$scroll_new_pos\"\n    ((y=scroll_new_pos))\n}\n\ndraw_img() {\n    # Draw an image file on the screen using w3m-img.\n    # We can use the framebuffer; set win_info_cmd as appropriate.\n    [[ $(tty) == /dev/tty[0-9]* && -w /dev/fb0 ]] &&\n        win_info_cmd=fbset\n\n    # X isn't running and we can't use the framebuffer, do nothing.\n    [[ -z $DISPLAY && $win_info_cmd != fbset ]] &&\n        return\n\n    # File isn't an image file, do nothing.\n    get_mime_type \"${list[scroll]}\"\n    [[ $mime_type != image/* ]] &&\n        return\n\n    # w3m-img isn't installed, do nothing.\n    type -p \"$w3m\" &>/dev/null || {\n        cmd_line \"error: Couldn't find 'w3m-img', is it installed?\"\n        return\n    }\n\n    # $win_info_cmd isn't installed, do nothing.\n    type -p \"${win_info_cmd:=xdotool}\" &>/dev/null || {\n        cmd_line \"error: Couldn't find '$win_info_cmd', is it installed?\"\n        return\n    }\n\n    # Get terminal window size in pixels and set it to WIDTH and HEIGHT.\n    if [[ $win_info_cmd == xdotool ]]; then\n        IFS=$'\\n' read -d \"\" -ra win_info \\\n            < <(xdotool getactivewindow getwindowgeometry --shell)\n\n        declare \"${win_info[@]}\" &>/dev/null || {\n            cmd_line \"error: Failed to retrieve window size.\"\n            return\n        }\n    else\n        [[ $(fbset --show) =~ .*\\\"([0-9]+x[0-9]+)\\\".* ]]\n        IFS=x read -r WIDTH HEIGHT <<< \"${BASH_REMATCH[1]}\"\n    fi\n\n    # Get the image size in pixels.\n    read -r img_width img_height < <(\"$w3m\" <<< \"5;${list[scroll]}\")\n\n    # Subtract the status_line area from the image size.\n    ((HEIGHT=HEIGHT-HEIGHT*5/LINES))\n\n    ((img_width > WIDTH)) && {\n        ((img_height=img_height*WIDTH/img_width))\n        ((img_width=WIDTH))\n    }\n\n    ((img_height > HEIGHT)) && {\n        ((img_width=img_width*HEIGHT/img_height))\n        ((img_height=HEIGHT))\n    }\n\n    clear_screen\n    status_line \"${list[scroll]}\"\n\n    # Add a small delay to fix issues in VTE terminals.\n    ((BASH_VERSINFO[0] > 3)) &&\n        read \"${read_flags[@]}\" -srn 1\n\n    # Display the image.\n    printf '0;1;%s;%s;%s;%s;;;;;%s\\n3;\\n4\\n' \\\n        \"${FFF_W3M_XOFFSET:-0}\" \\\n        \"${FFF_W3M_YOFFSET:-0}\" \\\n        \"$img_width\" \\\n        \"$img_height\" \\\n        \"${list[scroll]}\" | \"$w3m\" &>/dev/null\n\n    # Wait for user input.\n    read -ern 1\n\n    # Clear the image.\n    printf '6;%s;%s;%s;%s\\n3;' \\\n        \"${FFF_W3M_XOFFSET:-0}\" \\\n        \"${FFF_W3M_YOFFSET:-0}\" \\\n        \"$WIDTH\" \\\n        \"$HEIGHT\" | \"$w3m\" &>/dev/null\n\n    redraw\n}\n\nredraw() {\n    # Redraw the current window.\n    # If 'full' is passed, re-fetch the directory list.\n    [[ $1 == full ]] && {\n        read_dir\n        scroll=0\n    }\n\n    clear_screen\n    draw_dir\n    status_line\n}\n\nmark() {\n    # Mark file for operation.\n    # If an item is marked in a second directory,\n    # clear the marked files.\n    [[ $PWD != \"$mark_dir\" ]] &&\n        marked_files=()\n\n    # Don't allow the user to mark the empty directory list item.\n    [[ ${list[0]} == empty && -z ${list[1]} ]] &&\n        return\n\n    if [[ $1 == all ]]; then\n        if ((${#marked_files[@]} != ${#list[@]})); then\n            marked_files=(\"${list[@]}\")\n            mark_dir=$PWD\n        else\n            marked_files=()\n        fi\n\n        redraw\n    else\n        if [[ ${marked_files[$1]} == \"${list[$1]}\" ]]; then\n            unset 'marked_files[scroll]'\n\n        else\n            marked_files[$1]=\"${list[$1]}\"\n            mark_dir=$PWD\n        fi\n\n        # Clear line before changing it.\n        printf '\\e[K'\n        print_line \"$1\"\n    fi\n\n    # Find the program to use.\n    case \"$2\" in\n        ${FFF_KEY_YANK:=y}|${FFF_KEY_YANK_ALL:=Y}) file_program=(cp -iR) ;;\n        ${FFF_KEY_MOVE:=m}|${FFF_KEY_MOVE_ALL:=M}) file_program=(mv -i)  ;;\n        ${FFF_KEY_LINK:=s}|${FFF_KEY_LINK_ALL:=S}) file_program=(ln -s)  ;;\n\n        # These are 'fff' functions.\n        ${FFF_KEY_TRASH:=d}|${FFF_KEY_TRASH_ALL:=D})\n            file_program=(trash)\n        ;;\n\n        ${FFF_KEY_BULK_RENAME:=b}|${FFF_KEY_BULK_RENAME_ALL:=B})\n            file_program=(bulk_rename)\n        ;;\n    esac\n\n    status_line\n}\n\ntrash() {\n    # Trash a file.\n    cmd_line \"trash [${#marked_files[@]}] items? [y/n]: \" y n\n\n    [[ $cmd_reply != y ]] &&\n        return\n\n    if [[ $FFF_TRASH_CMD ]]; then\n        # Pass all but the last argument to the user's\n        # custom script. command is used to prevent this function\n        # from conflicting with commands named \"trash\".\n        command \"$FFF_TRASH_CMD\" \"${@:1:$#-1}\"\n\n    else\n        cd \"$FFF_TRASH\" || cmd_line \"error: Can't cd to trash directory.\"\n\n        if cp -alf \"$@\" &>/dev/null; then\n            rm -r \"${@:1:$#-1}\"\n        else\n            mv -f \"$@\"\n        fi\n\n        # Go back to where we were.\n        cd \"$OLDPWD\" ||:\n    fi\n}\n\nbulk_rename() {\n    # Bulk rename files using '$EDITOR'.\n    rename_file=${XDG_CACHE_HOME:=${HOME}/.cache}/fff/bulk_rename\n    marked_files=(\"${@:1:$#-1}\")\n\n    # Save marked files to a file and open them for editing.\n    printf '%s\\n' \"${marked_files[@]##*/}\" > \"$rename_file\"\n    \"${EDITOR:-vi}\" \"$rename_file\"\n\n    # Read the renamed files to an array.\n    IFS=$'\\n' read -d \"\" -ra changed_files < \"$rename_file\"\n\n    # If the user deleted a line, stop here.\n    ((${#marked_files[@]} != ${#changed_files[@]})) && {\n        rm \"$rename_file\"\n        cmd_line \"error: Line mismatch in rename file. Doing nothing.\"\n        return\n    }\n\n    printf '%s\\n%s\\n' \\\n        \"# This file will be executed when the editor is closed.\" \\\n        \"# Clear the file to abort.\" > \"$rename_file\"\n\n    # Construct the rename commands.\n    for ((i=0;i<${#marked_files[@]};i++)); {\n        [[ ${marked_files[i]} != \"${PWD}/${changed_files[i]}\" ]] && {\n            printf 'mv -i -- %q %q\\n' \\\n                \"${marked_files[i]}\" \"${PWD}/${changed_files[i]}\"\n            local renamed=1\n        }\n    } >> \"$rename_file\"\n\n    # Let the user double-check the commands and execute them.\n    ((renamed == 1)) && {\n        \"${EDITOR:-vi}\" \"$rename_file\"\n\n        source \"$rename_file\"\n        rm \"$rename_file\"\n    }\n\n    # Fix terminal settings after '$EDITOR'.\n    setup_terminal\n}\n\nopen() {\n    # Open directories and files.\n    if [[ -d $1/ ]]; then\n        search=\n        search_end_early=\n        cd \"${1:-/}\" ||:\n        redraw full\n\n    elif [[ -f $1 ]]; then\n        # Figure out what kind of file we're working with.\n        get_mime_type \"$1\"\n\n        # Open all text-based files in '$EDITOR'.\n        # Everything else goes through 'xdg-open'/'open'.\n        case \"$mime_type\" in\n            text/*|*x-empty*|*json*)\n                # If 'fff' was opened as a file picker, save the opened\n                # file in a file called 'opened_file'.\n                ((file_picker == 1)) && {\n                    printf '%s\\n' \"$1\" > \\\n                        \"${XDG_CACHE_HOME:=${HOME}/.cache}/fff/opened_file\"\n                    exit\n                }\n\n                clear_screen\n                reset_terminal\n                \"${VISUAL:-${EDITOR:-vi}}\" \"$1\"\n                setup_terminal\n                redraw\n            ;;\n\n            *)\n                # 'nohup':  Make the process immune to hangups.\n                # '&':      Send it to the background.\n                # 'disown': Detach it from the shell.\n                nohup \"${FFF_OPENER:-${opener:-xdg-open}}\" \"$1\" &>/dev/null &\n                disown\n            ;;\n        esac\n    fi\n}\n\ncmd_line() {\n    # Write to the command_line (under status_line).\n    cmd_reply=\n\n    # '\\e7':     Save cursor position.\n    # '\\e[?25h': Unhide the cursor.\n    # '\\e[%sH':  Move cursor to bottom (cmd_line).\n    printf '\\e7\\e[%sH\\e[?25h' \"$LINES\"\n\n    # '\\r\\e[K': Redraw the read prompt on every keypress.\n    #           This is mimicking what happens normally.\n    while IFS= read -rsn 1 -p $'\\r\\e[K'\"${1}${cmd_reply}\" read_reply; do\n        case $read_reply in\n            # Backspace.\n            $'\\177'|$'\\b')\n                cmd_reply=${cmd_reply%?}\n\n                # Clear tab-completion.\n                unset comp c\n            ;;\n\n            # Tab.\n            $'\\t')\n                comp_glob=\"$cmd_reply*\"\n\n                # Pass the argument dirs to limit completion to directories.\n                [[ $2 == dirs ]] &&\n                    comp_glob=\"$cmd_reply*/\"\n\n                # Generate a completion list once.\n                [[ -z ${comp[0]} ]] &&\n                    IFS=$'\\n' read -d \"\" -ra comp < <(compgen -G \"$comp_glob\")\n\n                # On each tab press, cycle through the completion list.\n                [[ -n ${comp[c]} ]] && {\n                    cmd_reply=${comp[c]}\n                    ((c=c >= ${#comp[@]}-1 ? 0 : ++c))\n                }\n            ;;\n\n            # Escape / Custom 'no' value (used as a replacement for '-n 1').\n            $'\\e'|${3:-null})\n                read \"${read_flags[@]}\" -rsn 2\n                cmd_reply=\n                break\n            ;;\n\n            # Enter/Return.\n            \"\")\n                # If there's only one search result and its a directory,\n                # enter it on one enter keypress.\n                [[ $2 == search && -d ${list[0]} ]] && ((list_total == 0)) && {\n                    # '\\e[?25l': Hide the cursor.\n                    printf '\\e[?25l'\n\n                    open \"${list[0]}\"\n                    search_end_early=1\n\n                    # Unset tab completion variables since we're done.\n                    unset comp c\n                    return\n                }\n\n                break\n            ;;\n\n            # Custom 'yes' value (used as a replacement for '-n 1').\n            ${2:-null})\n                cmd_reply=$read_reply\n                break\n            ;;\n\n            # Replace '~' with '$HOME'.\n            \"~\")\n                cmd_reply+=$HOME\n            ;;\n\n            # Anything else, add it to read reply.\n            *)\n                cmd_reply+=$read_reply\n\n                # Clear tab-completion.\n                unset comp c\n            ;;\n        esac\n\n        # Search on keypress if search passed as an argument.\n        [[ $2 == search ]] && {\n            # '\\e[?25l': Hide the cursor.\n            printf '\\e[?25l'\n\n            # Use a greedy glob to search.\n            list=(\"$PWD\"/*\"$cmd_reply\"*)\n            ((list_total=${#list[@]}-1))\n\n            # Draw the search results on screen.\n            scroll=0\n            redraw\n\n            # '\\e[%sH':  Move cursor back to cmd-line.\n            # '\\e[?25h': Unhide the cursor.\n            printf '\\e[%sH\\e[?25h' \"$LINES\"\n        }\n    done\n\n    # Unset tab completion variables since we're done.\n    unset comp c\n\n    # '\\e[2K':   Clear the entire cmd_line on finish.\n    # '\\e[?25l': Hide the cursor.\n    # '\\e8':     Restore cursor position.\n    printf '\\e[2K\\e[?25l\\e8'\n}\n\nkey() {\n    # Handle special key presses.\n    [[ $1 == $'\\e' ]] && {\n        read \"${read_flags[@]}\" -rsn 2\n\n        # Handle a normal escape key press.\n        [[ ${1}${REPLY} == $'\\e\\e['* ]] &&\n            read \"${read_flags[@]}\" -rsn 1 _\n\n        local special_key=${1}${REPLY}\n    }\n\n    case ${special_key:-$1} in\n        # Open list item.\n        # 'C' is what bash sees when the right arrow is pressed\n        # ('\\e[C' or '\\eOC').\n        # '' is what bash sees when the enter/return key is pressed.\n        ${FFF_KEY_CHILD1:=l}|\\\n        ${FFF_KEY_CHILD2:=$'\\e[C'}|\\\n        ${FFF_KEY_CHILD3:=\"\"}|\\\n        ${FFF_KEY_CHILD4:=$'\\eOC'})\n            open \"${list[scroll]}\"\n        ;;\n\n        # Go to the parent directory.\n        # 'D' is what bash sees when the left arrow is pressed\n        # ('\\e[D' or '\\eOD').\n        # '\\177' and '\\b' are what bash sometimes sees when the backspace\n        # key is pressed.\n        ${FFF_KEY_PARENT1:=h}|\\\n        ${FFF_KEY_PARENT2:=$'\\e[D'}|\\\n        ${FFF_KEY_PARENT3:=$'\\177'}|\\\n        ${FFF_KEY_PARENT4:=$'\\b'}|\\\n        ${FFF_KEY_PARENT5:=$'\\eOD'})\n            # If a search was done, clear the results and open the current dir.\n            if ((search == 1 && search_end_early != 1)); then\n                open \"$PWD\"\n\n            # If '$PWD' is '/', do nothing.\n            elif [[ $PWD && $PWD != / ]]; then\n                find_previous=1\n                open \"${PWD%/*}\"\n            fi\n        ;;\n\n        # Scroll down.\n        # 'B' is what bash sees when the down arrow is pressed\n        # ('\\e[B' or '\\eOB').\n        ${FFF_KEY_SCROLL_DOWN1:=j}|\\\n        ${FFF_KEY_SCROLL_DOWN2:=$'\\e[B'}|\\\n        ${FFF_KEY_SCROLL_DOWN3:=$'\\eOB'})\n            ((scroll < list_total)) && {\n                ((scroll++))\n                ((y < max_items)) && ((y++))\n\n                print_line \"$((scroll-1))\"\n                printf '\\n'\n                print_line \"$scroll\"\n                status_line\n            }\n        ;;\n\n        # Scroll up.\n        # 'A' is what bash sees when the up arrow is pressed\n        # ('\\e[A' or '\\eOA').\n        ${FFF_KEY_SCROLL_UP1:=k}|\\\n        ${FFF_KEY_SCROLL_UP2:=$'\\e[A'}|\\\n        ${FFF_KEY_SCROLL_UP3:=$'\\eOA'})\n            # '\\e[1L': Insert a line above the cursor.\n            # '\\e[A':  Move cursor up a line.\n            ((scroll > 0)) && {\n                ((scroll--))\n\n                print_line \"$((scroll+1))\"\n\n                if ((y < 2)); then\n                    printf '\\e[L'\n                else\n                    printf '\\e[A'\n                    ((y--))\n                fi\n\n                print_line \"$scroll\"\n                status_line\n            }\n        ;;\n\n        # Go to top.\n        ${FFF_KEY_TO_TOP:=g})\n            ((scroll != 0)) && {\n                scroll=0\n                redraw\n            }\n        ;;\n\n        # Go to bottom.\n        ${FFF_KEY_TO_BOTTOM:=G})\n            ((scroll != list_total)) && {\n                ((scroll=list_total))\n                redraw\n            }\n        ;;\n\n        # Show hidden files.\n        ${FFF_KEY_HIDDEN:=.})\n            # 'a=a>0?0:++a': Toggle between both values of 'shopt_flags'.\n            #                This also works for '3' or more values with\n            #                some modification.\n            shopt_flags=(u s)\n            shopt -\"${shopt_flags[((a=${a:=$FFF_HIDDEN}>0?0:++a))]}\" dotglob\n            redraw full\n        ;;\n\n        # Search.\n        ${FFF_KEY_SEARCH:=/})\n            cmd_line \"/\" \"search\"\n\n            # If the search came up empty, redraw the current dir.\n            if [[ -z ${list[*]} ]]; then\n                list=(\"${cur_list[@]}\")\n                ((list_total=${#list[@]}-1))\n                redraw\n                search=\n            else\n                search=1\n            fi\n        ;;\n\n        # Spawn a shell.\n        ${FFF_KEY_SHELL:=!})\n            reset_terminal\n\n            # Make fff aware of how many times it is nested.\n            export FFF_LEVEL\n            ((FFF_LEVEL++))\n\n            cd \"$PWD\" && \"$SHELL\"\n            setup_terminal\n            redraw full\n        ;;\n\n        # Mark files for operation.\n        ${FFF_KEY_YANK:=y}|\\\n        ${FFF_KEY_MOVE:=m}|\\\n        ${FFF_KEY_TRASH:=d}|\\\n        ${FFF_KEY_LINK:=s}|\\\n        ${FFF_KEY_BULK_RENAME:=b})\n            mark \"$scroll\" \"$1\"\n        ;;\n\n        # Mark all files for operation.\n        ${FFF_KEY_YANK_ALL:=Y}|\\\n        ${FFF_KEY_MOVE_ALL:=M}|\\\n        ${FFF_KEY_TRASH_ALL:=D}|\\\n        ${FFF_KEY_LINK_ALL:=S}|\\\n        ${FFF_KEY_BULK_RENAME_ALL:=B})\n            mark all \"$1\"\n        ;;\n\n        # Do the file operation.\n        ${FFF_KEY_PASTE:=p})\n            [[ ${marked_files[*]} ]] && {\n                [[ ! -w $PWD ]] && {\n                    cmd_line \"warn: no write access to dir.\"\n                    return\n                }\n\n                # Clear the screen to make room for a prompt if needed.\n                clear_screen\n                reset_terminal\n\n                stty echo\n                printf '\\e[1mfff\\e[m: %s\\n' \"Running ${file_program[0]}\"\n                \"${file_program[@]}\" \"${marked_files[@]}\" .\n                stty -echo\n\n                marked_files=()\n                setup_terminal\n                redraw full\n            }\n        ;;\n\n        # Clear all marked files.\n        ${FFF_KEY_CLEAR:=c})\n            [[ ${marked_files[*]} ]] && {\n                marked_files=()\n                redraw\n            }\n        ;;\n\n        # Rename list item.\n        ${FFF_KEY_RENAME:=r})\n            [[ ! -e ${list[scroll]} ]] &&\n                return\n\n            cmd_line \"rename ${list[scroll]##*/}: \"\n\n            [[ $cmd_reply ]] &&\n                if [[ -e $cmd_reply ]]; then\n                    cmd_line \"warn: '$cmd_reply' already exists.\"\n\n                elif [[ -w ${list[scroll]} ]]; then\n                    mv \"${list[scroll]}\" \"${PWD}/${cmd_reply}\"\n                    redraw full\n\n                else\n                    cmd_line \"warn: no write access to file.\"\n                fi\n        ;;\n\n        # Create a directory.\n        ${FFF_KEY_MKDIR:=n})\n            cmd_line \"mkdir: \" \"dirs\"\n\n            [[ $cmd_reply ]] &&\n                if [[ -e $cmd_reply ]]; then\n                    cmd_line \"warn: '$cmd_reply' already exists.\"\n\n                elif [[ -w $PWD ]]; then\n                    mkdir -p \"${PWD}/${cmd_reply}\"\n                    redraw full\n\n                else\n                    cmd_line \"warn: no write access to dir.\"\n                fi\n        ;;\n\n        # Create a file.\n        ${FFF_KEY_MKFILE:=f})\n            cmd_line \"mkfile: \"\n\n            [[ $cmd_reply ]] &&\n                if [[ -e $cmd_reply ]]; then\n                    cmd_line \"warn: '$cmd_reply' already exists.\"\n\n                elif [[ -w $PWD ]]; then\n                    : > \"$cmd_reply\"\n                    redraw full\n\n                else\n                    cmd_line \"warn: no write access to dir.\"\n                fi\n        ;;\n\n        # Show file attributes.\n        ${FFF_KEY_ATTRIBUTES:=x})\n            [[ -e \"${list[scroll]}\" ]] && {\n                clear_screen\n                status_line \"${list[scroll]}\"\n                \"${FFF_STAT_CMD:-stat}\" \"${list[scroll]}\"\n                read -ern 1\n                redraw\n            }\n        ;;\n\n        # Toggle executable flag.\n        ${FFF_KEY_EXECUTABLE:=X})\n            [[ -f ${list[scroll]} && -w ${list[scroll]} ]] && {\n                if [[ -x ${list[scroll]} ]]; then\n                    chmod -x \"${list[scroll]}\"\n                    status_line \"Unset executable.\"\n                else\n                    chmod +x \"${list[scroll]}\"\n                    status_line \"Set executable.\"\n                fi\n            }\n        ;;\n\n        # Show image in terminal.\n        ${FFF_KEY_IMAGE:=i})\n            draw_img\n        ;;\n\n        # Go to dir.\n        ${FFF_KEY_GO_DIR:=:})\n            cmd_line \"go to dir: \" \"dirs\"\n\n            # Let 'cd' know about the current directory.\n            cd \"$PWD\" &>/dev/null ||:\n\n            [[ $cmd_reply ]] &&\n                cd \"${cmd_reply/\\~/$HOME}\" &>/dev/null &&\n                    open \"$PWD\"\n        ;;\n\n        # Go to '$HOME'.\n        ${FFF_KEY_GO_HOME:='~'})\n            open ~\n        ;;\n\n        # Go to trash.\n        ${FFF_KEY_GO_TRASH:=t})\n            get_os\n            open \"$FFF_TRASH\"\n        ;;\n\n        # Go to previous dir.\n        ${FFF_KEY_PREVIOUS:=-})\n            open \"$OLDPWD\"\n        ;;\n\n        # Refresh current dir.\n        ${FFF_KEY_REFRESH:=e})\n            open \"$PWD\"\n        ;;\n\n        # Directory favourites.\n        [1-9])\n            favourite=\"FFF_FAV${1}\"\n            favourite=\"${!favourite}\"\n\n            [[ $favourite ]] &&\n                open \"$favourite\"\n        ;;\n\n        # Quit and store current directory in a file for CD on exit.\n        # Don't allow user to redefine 'q' so a bad keybinding doesn't\n        # remove the option to quit.\n        q)\n            : \"${FFF_CD_FILE:=${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d}\"\n\n            [[ -w $FFF_CD_FILE ]] &&\n                rm \"$FFF_CD_FILE\"\n\n            [[ ${FFF_CD_ON_EXIT:=1} == 1 ]] &&\n                printf '%s\\n' \"$PWD\" > \"$FFF_CD_FILE\"\n\n            exit\n        ;;\n    esac\n}\n\nmain() {\n    # Handle a directory as the first argument.\n    # 'cd' is a cheap way of finding the full path to a directory.\n    # It updates the '$PWD' variable on successful execution.\n    # It handles relative paths as well as '../../../'.\n    #\n    # '||:': Do nothing if 'cd' fails. We don't care.\n    cd \"${2:-$1}\" &>/dev/null ||:\n\n    [[ $1 == -v ]] && {\n        printf '%s\\n' \"fff 2.2\"\n        exit\n    }\n\n    [[ $1 == -h ]] && {\n        man fff\n        exit\n    }\n\n    # Store file name in a file on open instead of using 'FFF_OPENER'.\n    # Used in 'fff.vim'.\n    [[ $1 == -p ]] &&\n        file_picker=1\n\n    # bash 5 and some versions of bash 4 don't allow SIGWINCH to interrupt\n    # a 'read' command and instead wait for it to complete. In this case it\n    # causes the window to not redraw on resize until the user has pressed\n    # a key (causing the read to finish). This sets a read timeout on the\n    # affected versions of bash.\n    # NOTE: This shouldn't affect idle performance as the loop doesn't do\n    # anything until a key is pressed.\n    # SEE: https://github.com/dylanaraps/fff/issues/48\n    ((BASH_VERSINFO[0] > 3)) &&\n        read_flags=(-t 0.05)\n\n    ((${FFF_LS_COLORS:=1} == 1)) &&\n        get_ls_colors\n\n    ((${FFF_HIDDEN:=0} == 1)) &&\n        shopt -s dotglob\n\n    # Create the trash and cache directory if they don't exist.\n    mkdir -p \"${XDG_CACHE_HOME:=${HOME}/.cache}/fff\" \\\n             \"${FFF_TRASH:=${XDG_DATA_HOME:=${HOME}/.local/share}/fff/trash}\"\n\n    # 'nocaseglob': Glob case insensitively (Used for case insensitive search).\n    # 'nullglob':   Don't expand non-matching globs to themselves.\n    shopt -s nocaseglob nullglob\n\n    # Trap the exit signal (we need to reset the terminal to a useable state.)\n    trap 'reset_terminal' EXIT\n\n    # Trap the window resize signal (handle window resize events).\n    trap 'get_term_size; redraw' WINCH\n\n    get_os\n    get_term_size\n    get_w3m_path\n    setup_options\n    setup_terminal\n    redraw full\n\n    # Vintage infinite loop.\n    for ((;;)); {\n        read \"${read_flags[@]}\" -srn 1 && key \"$REPLY\"\n\n        # Exit if there is no longer a terminal attached.\n        [[ -t 1 ]] || exit 1\n    }\n}\n\nmain \"$@\"\n"
        },
        {
          "name": "fff.1",
          "type": "blob",
          "size": 5.169921875,
          "content": ".\n.TH FFF \"1\" \"January 2019\" \"fff\" \"User Commands\"\n.SH NAME\nfff \\- :file_folder: A simple file manager written in bash\n.SH SYNOPSIS\n.B fff\n.SH DESCRIPTION\nA simple file manager written in bash.\n.PP\n.SH \"Usage\"\n.\n.nf\n\nj: scroll down\nk: scroll up\nh: go to parent dir\nl: go to child dir\n\nenter: go to child dir\nbackspace: go to parent dir\n\n\\-: Go to previous dir\\.\n\ng: go to top\nG: go to bottom\n\n:: go to a directory by typing.\n\n\\.: toggle hidden files\n/: search\nt: go to trash\n~: go to home\ne: refresh current dir\n!: open shell in current dir\n\nx: view file/dir attributes\ni: display image with w3m-img\n\ndown:  scroll down\nup:    scroll up\nleft:  go to parent dir\nright: go to child dir\n\nf: new file\nn: new dir\nr: rename\nX: toggle executable\n\ny: mark copy\nm: mark move\nd: mark trash (~/.local/share/fff/trash/)\ns: mark symbolic link\nb: mark bulk rename\n\nY: mark all for copy\nM: mark all for move\nD: mark all for trash (~/.local/share/fff/trash/)\nS: mark all for symbolic link\nB: mark all for bulk rename\n\np: paste/move/delete/bulk_rename\nc: clear file selections\n\n[1-9]: favourites/bookmarks (see customization)\n\nq: exit with 'cd' (if enabled).\nCtrl+C: exit without 'cd'.\n.\n.fi\n.\n.SH \"Customization\"\n.\n.nf\n\n# Use LS_COLORS to color fff.\n# (On by default if available)\n# (Ignores FFF_COL1)\nexport FFF_LS_COLORS=1\n\n# Show/Hide hidden files on open.\n# (On by default)\nexport FFF_HIDDEN=0\n\n# Directory color [0\\-9]\nexport FFF_COL1=2\n\n# Status background color [0\\-9]\nexport FFF_COL2=7\n\n# Selection color [0\\-9] (copied/moved files)\nexport FFF_COL3=6\n\n# Cursor color [0\\-9]\nexport FFF_COL4=1\n\n# Status foreground color [0\\-9]\nexport FFF_COL5=0\n\n# Text Editor\nexport EDITOR=\"vim\"\n\n# File Opener\nexport FFF_OPENER=\"xdg\\-open\"\n\n# File Attributes Command\nexport FFF_STAT_CMD=\"stat\"\n\n# Enable or disable CD on exit.\n# Default: '1'\nexport FFF_CD_ON_EXIT=1\n\n# CD on exit helper file\n# Default: '${XDG_CACHE_HOME}/fff/fff.d'\n#          If not using XDG, '${HOME}/.cache/fff/fff.d' is used.\nexport FFF_CD_FILE=~/.fff_d\n\n# Trash Directory\n# Default: '${XDG_DATA_HOME}/fff/trash'\n#          If not using XDG, '${XDG_DATA_HOME}/fff/trash' is used.\nexport FFF_TRASH=~/.local/share/fff/trash\n\n# Trash Command\n# Default: 'mv'\n#          Define a custom program to use to trash files.\n#          The program will be passed the list of selected files\n#          and directories.\nexport FFF_TRASH_CMD=\"mv\"\n\n# Favourites (Bookmarks) (keys 1-9) (dir or file)\nexport FFF_FAV1=~/projects\nexport FFF_FAV2=~/.bashrc\nexport FFF_FAV3=~/Pictures/Wallpapers/\nexport FFF_FAV4=/usr/share\nexport FFF_FAV5=/\nexport FFF_FAV6=\nexport FFF_FAV7=\nexport FFF_FAV8=\nexport FFF_FAV9=\n\n# w3m-img offsets.\nexport FFF_W3M_XOFFSET=0\nexport FFF_W3M_YOFFSET=0\n\n# File format.\n# Customize the item string.\n# Format ('%f' is the current file): \"str%fstr\"\n# Example (Add a tab before files): FFF_FILE_FORMAT=\"\\t%f\"\nexport FFF_FILE_FORMAT=\"%f\"\n\n# Mark format.\n# Customize the marked item string.\n# Format ('%f' is the current file): \"str%fstr\"\n# Example (Add a ' >' before files): FFF_MARK_FORMAT=\"> %f\"\nexport FFF_MARK_FORMAT=\" %f*\"\n.\n.fi\n.\n.SH \"Keybindings\"\n.\n.nf\nFor more information see:\n    https://github.com/dylanaraps/fff#customizing-the-keybindings\n\n### Moving around.\n\n# Go to child directory.\nexport FFF_KEY_CHILD1=\"l\"\nexport FFF_KEY_CHILD2=$'\\e[C' # Right Arrow\nexport FFF_KEY_CHILD3=\"\"      # Enter / Return\n\n# Go to parent directory.\nexport FFF_KEY_PARENT1=\"h\"\nexport FFF_KEY_PARENT2=$'\\e[D' # Left Arrow\nexport FFF_KEY_PARENT3=$'\\177' # Backspace\nexport FFF_KEY_PARENT4=$'\\\\b'   # Backspace (Older terminals)\n\n# Go to previous directory.\nexport FFF_KEY_PREVIOUS=\"-\"\n\n# Search.\nexport FFF_KEY_SEARCH=\"/\"\n\n# Spawn a shell.\nexport FFF_KEY_SHELL=\"!\"\n\n# Scroll down.\nexport FFF_KEY_SCROLL_DOWN1=\"j\"\nexport FFF_KEY_SCROLL_DOWN2=$'\\e[B' # Down Arrow\n\n# Scroll up.\nexport FFF_KEY_SCROLL_UP1=\"k\"\nexport FFF_KEY_SCROLL_UP2=$'\\e[A'   # Up Arrow\n\n# Go to top and bottom.\nexport FFF_KEY_TO_TOP=\"g\"\nexport FFF_KEY_TO_BOTTOM=\"G\"\n\n# Go to dirs.\nexport FFF_KEY_GO_DIR=\":\"\nexport FFF_KEY_GO_HOME=\"~\"\nexport FFF_KEY_GO_TRASH=\"t\"\n\n### File operations.\n\nexport FFF_KEY_YANK=\"y\"\nexport FFF_KEY_MOVE=\"m\"\nexport FFF_KEY_TRASH=\"d\"\nexport FFF_KEY_LINK=\"s\"\nexport FFF_KEY_BULK_RENAME=\"b\"\n\nexport FFF_KEY_YANK_ALL=\"Y\"\nexport FFF_KEY_MOVE_ALL=\"M\"\nexport FFF_KEY_TRASH_ALL=\"D\"\nexport FFF_KEY_LINK_ALL=\"S\"\nexport FFF_KEY_BULK_RENAME_ALL=\"B\"\n\nexport FFF_KEY_PASTE=\"p\"\nexport FFF_KEY_CLEAR=\"c\"\n\nexport FFF_KEY_RENAME=\"r\"\nexport FFF_KEY_MKDIR=\"n\"\nexport FFF_KEY_MKFILE=\"f\"\n\n### Miscellaneous\n\n# Show file attributes.\nexport FFF_KEY_ATTRIBUTES=\"x\"\n\n# Toggle executable flag.\nexport FFF_KEY_EXECUTABLE=\"X\"\n\n# Toggle hidden files.\nexport FFF_KEY_HIDDEN=\".\"\n\n.\n.fi\n\n.SH \"Disabling keybindings\"\n.\n.nf\n\nYou can't unset keybindings by making their value `''`.\nWhat you need to do is change their value to `off`.\n\nExample:\n\n# KEY_GO_TRASH was bound to 't', now its unset.\nexport FFF_KEY_GO_TRASH=\"off\"\n\n# KEY_MKFILE is now set to 't' and its original\n# keybinding is also unset 'f'.\nexport FFF_KEY_MKFILE=\"t\"\n.\n.fi\n\n.SH \"Dealing with conflicting keybindings\"\n.\n.nf\n\nWhen rebinding a key in `fff` make sure you don't have two bindings\nwith the same value. You can avoid this by setting the other\nconflicting key-binding to something else or by changing its value to `off`.\n\n.\n.fi\n"
        }
      ]
    }
  ]
}