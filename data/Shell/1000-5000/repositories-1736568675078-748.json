{
  "metadata": {
    "timestamp": 1736568675078,
    "page": 748,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "raspberrypi/rpi-eeprom",
      "stars": 1291,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": "*.swp\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 5.8173828125,
          "content": "Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\nUpstream-Name: rpi-eeprom\nSource: https://github.com/raspberrypi/rpi-eeprom\n\nFiles: *\nCopyright: 2019, Raspberry Pi (Trading) Ltd.\nLicense: BSD-3\n\nFiles: firmware/*\nCopyright: 2019, Raspberry Pi (Trading) Ltd.\nLicense: custom\n\nLicense: BSD-3\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions\n are met:\n .\n * Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the\n   distribution.\n * Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\n .\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT\n HOLDER> BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nLicense: custom\n All rights reserved.\n .\n Redistribution.  Redistribution and use in binary form, without\n modification, are permitted provided that the following conditions are\n met:\n .\n * This software may only be used for the purposes of developing for,\n   running or using a Raspberry Pi device.\n * Redistributions must reproduce the above copyright notice and the\n   following disclaimer in the documentation and/or other materials\n   provided with the distribution.\n * Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\n .\n DISCLAIMER.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n DAMAGE.\n\nLicense: uIP\n Copyright (c) 2006, Swedish Institute of Computer Science.\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions\n are met:\n 1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n 3. Neither the name of the Institute nor the names of its contributors\n    may be used to endorse or promote products derived from this software\n    without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n SUCH DAMAGE.\n \nLicense: MIT\n QR Code generator library (C)\n \n Copyright (c) Project Nayuki. (MIT License)\n https://www.nayuki.io/page/qr-code-generator-library\n \n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \"Software\"), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n the Software, and to permit persons to whom the Software is furnished to do so,\n subject to the following conditions:\n - The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n - The Software is provided \"as is\", without warranty of any kind, express or\n   implied, including but not limited to the warranties of merchantability,\n   fitness for a particular purpose and noninfringement. In no event shall the\n   authors or copyright holders be liable for any claim, damages or other\n   liability, whether in an action of contract, tort or otherwise, arising from,\n   out of or in connection with the Software or the use or other dealings in the\n   Software.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.1787109375,
          "content": "# rpi-eeprom\nThis repository contains the scripts and pre-compiled binaries used to create the `rpi-eeprom` package which is used to update the Raspberry Pi 4 and Raspberry Pi 5 bootloaders EEPROM images.\n\n# Support\nPlease check the Raspberry Pi [general discussion forum](https://forums.raspberrypi.com/viewforum.php?f=63) if you have a support question.\n\n# Reset to factory defaults\nTo reset the bootloader back to factory defaults use [Raspberry Pi Imager](https://www.raspberrypi.com/software/) to write an EEPROM update image to a spare SD card. Select `Misc utility images` under the `Operating System` tab.\n\n# Bootloader documentation\n* [Config.txt boot options](https://www.raspberrypi.com/documentation/computers/config_txt.html#boot-options)\n* [Bootloader EEPROM](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#raspberry-pi-boot-eeprom)\n* [Bootloader configuration](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#raspberry-pi-bootloader-configuration)\n* [Updating the Compute Module 4 bootloader](https://www.raspberrypi.com/documentation/computers/compute-module.html#update-the-compute-module-bootloader)\n* [Releases and release notes](releases.md)\n"
        },
        {
          "name": "firmware-2711",
          "type": "tree",
          "content": null
        },
        {
          "name": "firmware-2712",
          "type": "tree",
          "content": null
        },
        {
          "name": "imager",
          "type": "tree",
          "content": null
        },
        {
          "name": "releases.md",
          "type": "blob",
          "size": 1.2587890625,
          "content": "# Raspberry Pi 4 and Raspberry Pi 5 bootloader EEPROM releases.\nThis page provides links to the production and development release images for the bootloader EEPROM on BCM2711 and BCM2712 based Raspberry Pi computers. Normally, the \nbootloader is automatically updated after an APT update via the [rpi-eeprom-update](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#automatic-updates) utility.\n\n## Release notes\n* [BCM2711 release notes](https://github.com/raspberrypi/rpi-eeprom/blob/master/firmware-2711/release-notes.md).\n* [BCM2712 release notes](https://github.com/raspberrypi/rpi-eeprom/blob/master/firmware-2712/release-notes.md).\n\n## USB MSD boot\nPlease see the [USB mass storage boot](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#usb-mass-storage-boot) guide.\n\nFor support or hardware interoperability discussions please use the Raspberry Pi [general discussion](https://forums.raspberrypi.com/viewforum.php?f=63) forum.\n\n## Old EEPROM images\nOld bootloader images are periodically removed from the APT package to reduce the disk space but are still available via Github \n* Old [BCM2711 releases](https://github.com/raspberrypi/rpi-eeprom/tree/master/firmware-2711/old).\n\n**Old releases may fail to boot on newer hardware revisions.**\n"
        },
        {
          "name": "rpi-eeprom-config",
          "type": "blob",
          "size": 23.3564453125,
          "content": "#!/usr/bin/env python3\n\n\"\"\"\nrpi-eeprom-config\n\"\"\"\n\nimport argparse\nimport atexit\nimport os\nimport subprocess\nimport string\nimport struct\nimport sys\nimport tempfile\nimport time\n\nVALID_IMAGE_SIZES = [512 * 1024, 2 * 1024 * 1024]\n\nBOOTCONF_TXT = 'bootconf.txt'\nBOOTCONF_SIG = 'bootconf.sig'\nPUBKEY_BIN = 'pubkey.bin'\nCACERT_DER = 'cacert.der'\nBOOTCODE_BIN = 'bootcode.bin'\n\n# Each section starts with a magic number followed by a 32 bit offset to the\n# next section (big-endian).\n# The number, order and size of the sections depends on the bootloader version\n# but the following mask can be used to test for section headers and skip\n# unknown data.\n#\n# The last 4KB of the EEPROM image is reserved for internal use by the\n# bootloader and may be overwritten during the update process.\nMAGIC = 0x55aaf00f\nPAD_MAGIC = 0x55aafeef\nMAGIC_MASK = 0xfffff00f\nFILE_MAGIC = 0x55aaf11f # id for modifiable files\nFILE_HDR_LEN = 20\nFILENAME_LEN = 12\nTEMP_DIR = None\n\n# Modifiable files are stored in a single 4K erasable sector.\n# The max content 4076 bytes because of the file header.\nERASE_ALIGN_SIZE = 4096\nMAX_FILE_SIZE = ERASE_ALIGN_SIZE - FILE_HDR_LEN\n\nDEBUG = False\ndef debug(s):\n    if DEBUG:\n        sys.stderr.write(s + '\\n')\n\ndef rpi4():\n    compatible_path = \"/sys/firmware/devicetree/base/compatible\"\n    if os.path.exists(compatible_path):\n        with open(compatible_path, \"rb\") as f:\n            compatible = f.read().decode('utf-8')\n            if \"bcm2711\" in compatible:\n                return True\n    return False\n\ndef rpi5():\n    compatible_path = \"/sys/firmware/devicetree/base/compatible\"\n    if os.path.exists(compatible_path):\n        with open(compatible_path, \"rb\") as f:\n            compatible = f.read().decode('utf-8')\n            if \"bcm2712\" in compatible:\n                return True\n    return False\n\ndef exit_handler():\n    \"\"\"\n    Delete any temporary files.\n    \"\"\"\n    if TEMP_DIR is not None and os.path.exists(TEMP_DIR):\n        tmp_image = os.path.join(TEMP_DIR, 'pieeprom.upd')\n        if os.path.exists(tmp_image):\n            os.remove(tmp_image)\n        tmp_conf = os.path.join(TEMP_DIR, 'boot.conf')\n        if os.path.exists(tmp_conf):\n            os.remove(tmp_conf)\n        os.rmdir(TEMP_DIR)\n\ndef create_tempdir():\n    global TEMP_DIR\n    if TEMP_DIR is None:\n        TEMP_DIR = tempfile.mkdtemp()\n\ndef pemtobin(infile):\n    \"\"\"\n    Converts an RSA public key into the format expected by the bootloader.\n    \"\"\"\n    # Import the package here to make this a weak dependency.\n    from Cryptodome.PublicKey import RSA\n\n    arr = bytearray()\n    f = open(infile,'r')\n    key = RSA.importKey(f.read())\n\n    if key.size_in_bits() != 2048:\n        raise Exception(\"RSA key size must be 2048\")\n\n    # Export N and E in little endian format\n    arr.extend(key.n.to_bytes(256, byteorder='little'))\n    arr.extend(key.e.to_bytes(8, byteorder='little'))\n    return arr\n\ndef exit_error(msg):\n    \"\"\"\n    Trapped a fatal error, output message to stderr and exit with non-zero\n    return code.\n    \"\"\"\n    sys.stderr.write(\"ERROR: %s\\n\" % msg)\n    sys.exit(1)\n\ndef shell_cmd(args, timeout=10, echo=False):\n    \"\"\"\n    Executes a shell command waits for completion returning STDOUT. If an\n    error occurs then exit and output the subprocess stdout, stderr messages\n    for debug.\n    \"\"\"\n    start = time.time()\n    arg_str = ' '.join(args)\n    bufsize = 0 if echo else -1\n    result = subprocess.Popen(args, bufsize=bufsize, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    while time.time() - start < timeout:\n        if echo:\n            s = result.stdout.read(80).decode('utf-8')\n            if s != \"\":\n                sys.stdout.write(s)\n        if result.poll() is not None:\n            break\n\n    if result.poll() is None:\n        exit_error(\"%s timeout\" % arg_str)\n\n    if result.returncode != 0:\n        exit_error(\"%s failed: %d\\n %s\\n %s\\n\" %\n                   (arg_str, result.returncode, result.stdout.read().decode('utf-8'), result.stderr.read().decode('utf-8')))\n    elif not echo:\n        return result.stdout.read().decode('utf-8')\n\ndef get_latest_eeprom():\n    \"\"\"\n    Returns the path of the latest EEPROM image file if it exists.\n    \"\"\"\n    latest = shell_cmd(['rpi-eeprom-update', '-l']).rstrip()\n    if not os.path.exists(latest):\n        exit_error(\"EEPROM image '%s' not found\" % latest)\n    return latest\n\ndef apply_update(config, eeprom=None, config_src=None):\n    \"\"\"\n    Applies the config file to the latest available EEPROM image and spawns\n    rpi-eeprom-update to schedule the update at the next reboot.\n    \"\"\"\n    if eeprom is not None:\n        eeprom_image = eeprom\n    else:\n        eeprom_image = get_latest_eeprom()\n    create_tempdir()\n\n    # Replace the contents of bootconf.txt with the contents of the config file\n    tmp_update = os.path.join(TEMP_DIR, 'pieeprom.upd')\n    image = BootloaderImage(eeprom_image, tmp_update)\n    image.update_file(config, BOOTCONF_TXT)\n    image.write()\n\n    config_str = open(config).read()\n    if config_src is None:\n        config_src = ''\n    sys.stdout.write(\"Updating bootloader EEPROM\\n image: %s\\nconfig_src: %s\\nconfig: %s\\n%s\\n%s\\n%s\\n\" %\n                     (eeprom_image, config_src, config, '#' * 80, config_str, '#' * 80))\n\n    # Ignore APT package checksums so that this doesn't fail when used\n    # with EEPROMs with configs delivered outside of APT.\n    # The checksums are really just a safety check for automatic updates.\n    args = ['rpi-eeprom-update', '-d', '-i', '-f', tmp_update]\n\n    # If flashrom is used then the command will not return until the EEPROM\n    # has been updated so use a larger timeout.\n    shell_cmd(args, timeout=180, echo=True)\n\ndef edit_config(eeprom=None):\n    \"\"\"\n    Implements something like 'git commit' for editing EEPROM configs.\n    \"\"\"\n    # Default to nano if $EDITOR is not defined.\n    editor = 'nano'\n    if 'EDITOR' in os.environ:\n        editor = os.environ['EDITOR']\n\n    config_src = ''\n    # If there is a pending update then use the configuration from\n    # that in order to support incremental updates. Otherwise,\n    # use the current EEPROM configuration.\n    bootfs = shell_cmd(['rpi-eeprom-update', '-b']).rstrip()\n    pending = os.path.join(bootfs, 'pieeprom.upd')\n    if os.path.exists(pending):\n        config_src = pending\n        image = BootloaderImage(pending)\n        current_config = image.get_file(BOOTCONF_TXT).decode('utf-8')\n    else:\n        current_config, config_src = read_current_config()\n\n    create_tempdir()\n    tmp_conf = os.path.join(TEMP_DIR, 'boot.conf')\n    out = open(tmp_conf, 'w')\n    out.write(current_config)\n    out.close()\n    cmd = \"\\'%s\\' \\'%s\\'\" % (editor, tmp_conf)\n    result = os.system(cmd)\n    if result != 0:\n        exit_error(\"Aborting update because \\'%s\\' exited with code %d.\" % (cmd, result))\n\n    new_config = open(tmp_conf, 'r').read()\n    if len(new_config.splitlines()) < 2:\n        exit_error(\"Aborting update because \\'%s\\' appears to be empty.\" % tmp_conf)\n    apply_update(tmp_conf, eeprom, config_src)\n\ndef read_current_config():\n    \"\"\"\n    Reads the configuration used by the current bootloader.\n    \"\"\"\n    fw_base = \"/sys/firmware/devicetree/base/\"\n    nvmem_base = \"/sys/bus/nvmem/devices/\"\n\n    if os.path.exists(fw_base + \"/aliases/blconfig\"):\n        with open(fw_base + \"/aliases/blconfig\", \"rb\") as f:\n            nvmem_ofnode_path = fw_base + f.read().decode('utf-8')\n            for d in os.listdir(nvmem_base):\n                if os.path.realpath(nvmem_base + d + \"/of_node\") in os.path.normpath(nvmem_ofnode_path):\n                    return (open(nvmem_base + d + \"/nvmem\", \"rb\").read().decode('utf-8'), \"blconfig device\")\n\n    return (shell_cmd(['vcgencmd', 'bootloader_config']), \"vcgencmd bootloader_config\")\n\nclass ImageSection:\n    def __init__(self, magic, offset, length, filename=''):\n        self.magic = magic\n        self.offset = offset\n        self.length = length\n        self.filename = filename\n        debug(\"ImageSection %x offset %d length %d %s\" % (magic, offset, length, filename))\n\nclass BootloaderImage(object):\n    def __init__(self, filename, output=None):\n        \"\"\"\n        Instantiates a Bootloader image writer with a source eeprom (filename)\n        and optionally an output filename.\n        \"\"\"\n        self._filename = filename\n        self._sections = []\n        self._image_size = 0\n        try:\n            self._bytes = bytearray(open(filename, 'rb').read())\n        except IOError as err:\n            exit_error(\"Failed to read \\'%s\\'\\n%s\\n\" % (filename, str(err)))\n        self._out = None\n        if output is not None:\n            self._out = open(output, 'wb')\n\n        self._image_size = len(self._bytes)\n        if self._image_size not in VALID_IMAGE_SIZES:\n            exit_error(\"%s: Expected size %d bytes actual size %d bytes\" %\n                       (filename, self._image_size, len(self._bytes)))\n        self.parse()\n\n    def parse(self):\n        \"\"\"\n        Builds a table of offsets to the different sections in the EEPROM.\n        \"\"\"\n        offset = 0\n        magic = 0\n        while offset < self._image_size:\n            magic, length = struct.unpack_from('>LL', self._bytes, offset)\n            if magic == 0x0 or magic == 0xffffffff:\n                break # EOF\n            elif (magic & MAGIC_MASK) != MAGIC:\n                raise Exception('EEPROM is corrupted %x %x %x' % (magic, magic & MAGIC_MASK, MAGIC))\n\n            filename = ''\n            if magic == FILE_MAGIC: # Found a file\n                # Discard trailing null characters used to pad filename\n                filename = self._bytes[offset + 8: offset + FILE_HDR_LEN].decode('utf-8').replace('\\0', '')\n            debug(\"section at %d length %d magic %08x %s\" % (offset, length, magic, filename))\n            self._sections.append(ImageSection(magic, offset, length, filename))\n\n            offset += 8 + length # length + type\n            offset = (offset + 7) & ~7\n\n    def find_file(self, filename):\n        \"\"\"\n        Returns the offset, length and whether this is the last section in the\n        EEPROM for a modifiable file within the image.\n        \"\"\"\n        offset = -1\n        length = -1\n        is_last = False\n\n        if filename == BOOTCODE_BIN:\n            next_offset = 0\n            dst_filename = filename\n            i = 0\n            s = self._sections[i]\n            offset = s.offset\n            length = s.length\n        else:\n            next_offset = self._image_size - ERASE_ALIGN_SIZE # Don't create padding inside the bootloader scratch page\n            for i in range(0, len(self._sections)):\n                s = self._sections[i]\n                if s.magic == FILE_MAGIC and s.filename == filename:\n                    is_last = (i == len(self._sections) - 1)\n                    offset = s.offset\n                    length = s.length\n                    break\n\n        # Find the start of the next non padding section\n        i += 1\n        while i < len(self._sections):\n            if self._sections[i].magic == PAD_MAGIC:\n                i += 1\n            else:\n                next_offset = self._sections[i].offset\n                break\n        ret = (offset, length, is_last, next_offset)\n        debug('%s offset %d length %d is-last %d next %d' % (filename, ret[0], ret[1], ret[2], ret[3]))\n        return ret\n\n    def update(self, src_bytes, dst_filename, bootcode = False):\n        \"\"\"\n        Replaces a modifiable file with specified byte array.\n        \"\"\"\n        if bootcode:\n            hdr_offset, length, is_last, next_offset = self.find_file(dst_filename)\n            struct.pack_into('>L', self._bytes, hdr_offset + 4, len(src_bytes))\n            struct.pack_into((\"%ds\" % len(src_bytes)), self._bytes, hdr_offset + 8, src_bytes)\n            pad_start = hdr_offset + len(src_bytes) + 8\n            is_last = False\n            debug(\"bootcode padded to %d\" % next_offset);\n            if next_offset < 128 * 1024:\n                raise Exception(\"update-bootcode: Can't update image - 128K must be reserved for bootcode\")\n            if next_offset < 0:\n                raise Exception(\"update-bootcode: Failed to find next section\")\n\n        else:\n            hdr_offset, length, is_last, next_offset = self.find_file(dst_filename)\n            update_len = len(src_bytes) + FILE_HDR_LEN\n\n            if hdr_offset + update_len > self._image_size - ERASE_ALIGN_SIZE:\n                raise Exception('No space available - image past EOF.')\n\n            if hdr_offset < 0:\n                raise Exception('Update target %s not found' % dst_filename)\n\n            if hdr_offset + update_len > next_offset:\n                raise Exception('Update %d bytes is larger than section size %d' % (update_len, next_offset - hdr_offset))\n\n            new_len = len(src_bytes) + FILENAME_LEN + 4\n            struct.pack_into('>L', self._bytes, hdr_offset + 4, new_len)\n            struct.pack_into((\"%ds\" % len(src_bytes)), self._bytes,\n                             hdr_offset + 4 + FILE_HDR_LEN, src_bytes)\n\n            # If the new file is smaller than the old file then set any old\n            # data which is now unused to all ones (erase value)\n            pad_start = hdr_offset + 4 + FILE_HDR_LEN + len(src_bytes)\n\n        # Add padding up to 8-byte boundary\n        while pad_start % 8 != 0:\n            struct.pack_into('B', self._bytes, pad_start, 0xff)\n            pad_start += 1\n\n        # Create a padding section unless the padding size is smaller than the\n        # size of a section head. Padding is allowed in the last section but\n        # by convention bootconf.txt is the last section and there's no need to\n        # pad to the end of the sector. This also ensures that the loopback\n        # config read/write tests produce identical binaries.\n        pad_bytes = next_offset - pad_start\n        if pad_bytes > 8 and not is_last:\n            pad_bytes -= 8\n            struct.pack_into('>i', self._bytes, pad_start, PAD_MAGIC)\n            pad_start += 4\n            struct.pack_into('>i', self._bytes, pad_start, pad_bytes)\n            pad_start += 4\n\n        debug(\"pad %d\" % pad_bytes)\n        pad = 0\n        while pad < pad_bytes:\n            struct.pack_into('B', self._bytes, pad_start + pad, 0xff)\n            pad = pad + 1\n\n    def update_key(self, src_pem, dst_filename):\n        \"\"\"\n        Replaces the specified public key entry with the public key values extracted\n        from the source PEM file.\n        \"\"\"\n        pubkey_bytes = pemtobin(src_pem)\n        self.update(pubkey_bytes, dst_filename)\n\n    def update_file(self, src_filename, dst_filename):\n        \"\"\"\n        Replaces the contents of dst_filename in the EEPROM with the contents of src_file.\n        \"\"\"\n        src_bytes = open(src_filename, 'rb').read()\n        bootcode = dst_filename == BOOTCODE_BIN\n        if not bootcode and len(src_bytes) > MAX_FILE_SIZE:\n            raise Exception(\"src file %s is too large (%d bytes). The maximum size is %d bytes.\"\n                            % (src_filename, len(src_bytes), MAX_FILE_SIZE))\n        self.update(src_bytes, dst_filename, bootcode)\n\n    def set_timestamp(self, timestamp):\n        \"\"\"\n        Sets the self-update timestamp in an EEPROM image file. This is useful when\n        using flashrom to write to SPI flash instead of using the bootloader self-update mode.\n        \"\"\"\n        ts = int(timestamp)\n        struct.pack_into('<L', self._bytes, len(self._bytes) - 4, ts)\n        struct.pack_into('<L', self._bytes, len(self._bytes) - 8, ~ts & 0xffffffff)\n\n    def write(self):\n        \"\"\"\n        Writes the updated EEPROM image to stdout or the specified output file.\n        \"\"\"\n        if self._out is not None:\n            self._out.write(self._bytes)\n            self._out.close()\n        else:\n            if hasattr(sys.stdout, 'buffer'):\n                sys.stdout.buffer.write(self._bytes)\n            else:\n                sys.stdout.write(self._bytes)\n\n    def get_file(self, filename):\n        hdr_offset, length, is_last, next_offset = self.find_file(filename)\n        if filename == BOOTCODE_BIN:\n            offset = hdr_offset + 8\n            file_bytes = self._bytes[offset:offset+length]\n        else:\n            offset = hdr_offset + 4 + FILE_HDR_LEN\n            file_bytes = self._bytes[offset:offset+length-FILENAME_LEN-4]\n\n        return file_bytes\n\n    def extract_files(self):\n        for i in range(0, len(self._sections)):\n            s = self._sections[i]\n            if s.magic == MAGIC and s.offset == 0:\n                file_bytes = self.get_file(BOOTCODE_BIN)\n                open(BOOTCODE_BIN, 'wb').write(file_bytes)\n            elif s.magic == FILE_MAGIC:\n                file_bytes = self.get_file(s.filename)\n                open(s.filename, 'wb').write(file_bytes)\n\n    def read(self):\n        config_bytes = self.get_file('bootconf.txt')\n        if self._out is not None:\n            self._out.write(config_bytes)\n            self._out.close()\n        else:\n            if hasattr(sys.stdout, 'buffer'):\n                sys.stdout.buffer.write(config_bytes)\n            else:\n                sys.stdout.write(config_bytes)\n\ndef main():\n    global DEBUG\n    \"\"\"\n    Utility for reading and writing the configuration file in the\n    Raspberry Pi bootloader EEPROM image.\n    \"\"\"\n    description = \"\"\"\\\nBootloader EEPROM configuration tool for the Raspberry Pi 4 and Raspberry Pi 5.\nOperating modes:\n\n1. Outputs the current bootloader configuration to STDOUT if no arguments are\n   specified OR the given output file if --out is specified.\n\n   rpi-eeprom-config [--out boot.conf]\n\n2. Extracts the configuration file from the given 'eeprom' file and outputs\n   the result to STDOUT or the output file if --output is specified.\n\n   rpi-eeprom-config pieeprom.bin [--out boot.conf]\n\n3. Writes a new EEPROM image replacing the configuration file with the contents\n   of the file specified by --config.\n\n   rpi-eeprom-config --config boot.conf --out newimage.bin pieeprom.bin\n\n   The new image file can be installed via rpi-eeprom-update\n   sudo rpi-eeprom-update -d -f newimage.bin\n\n4. Applies a given config file to an EEPROM image and invokes rpi-eeprom-update\n   to schedule an update of the bootloader when the system is rebooted.\n\n   Since this command launches rpi-eeprom-update to schedule the EEPROM update\n   it must be run as root.\n\n   sudo rpi-eeprom-config --apply boot.conf [pieeprom.bin]\n\n   If the 'eeprom' argument is not specified then the latest available image\n   is selected by calling 'rpi-eeprom-update -l'.\n\n5. The '--edit' parameter behaves the same as '--apply' except that instead of\n   applying a predefined configuration file a text editor is launched with the\n   contents of the current EEPROM configuration.\n\n   Since this command launches rpi-eeprom-update to schedule the EEPROM update\n   it must be run as root.\n\n   The configuration file will be taken from:\n       * The blconfig reserved memory nvmem device\n       * The cached bootloader configuration 'vcgencmd bootloader_config'\n       * The current pending update - typically /boot/firmware/pieeprom.upd\n\n   sudo -E rpi-eeprom-config --edit [pieeprom.bin]\n\n   To cancel the pending update run 'sudo rpi-eeprom-update -r'\n\n   The default text editor is nano and may be overridden by setting the 'EDITOR'\n   environment variable and passing '-E' to 'sudo' to preserve the environment.\n\n6. Signing the bootloader config file.\n   Updates an EEPROM binary with a signed config file (created by rpi-eeprom-digest) plus\n   the corresponding RSA public key.\n\n   Requires Python Cryptodomex libraries and OpenSSL. To install on Raspberry Pi OS run:-\n   sudo apt install python3-pycryptodome\n\n   rpi-eeprom-digest -k private.pem -i bootconf.txt -o bootconf.sig\n   rpi-eeprom-config --config bootconf.txt --digest bootconf.sig --pubkey public.pem --out pieeprom-signed.bin pieeprom.bin\n\n   Currently, the signing process is a separate step so can't be used with the --edit or --apply modes.\n\n\nSee 'rpi-eeprom-update -h' for more information about the available EEPROM images.\n\"\"\"\n    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,\n                                     description=description)\n\n    parser.add_argument('-a', '--apply', required=False,\n                        help='Updates the bootloader to the given config plus latest available EEPROM release.')\n    parser.add_argument('-c', '--config', help='Name of bootloader configuration file', required=False)\n    parser.add_argument('-e', '--edit', action='store_true', default=False, help='Edit the current EEPROM config')\n    parser.add_argument('-o', '--out', help='Name of output file', required=False)\n    parser.add_argument('-d', '--digest', help='Signed boot only. The name of the .sig file generated by rpi-eeprom-digest for config.txt ', required=False)\n    parser.add_argument('-p', '--pubkey', help='Signed boot only. The name of the RSA public key file to store in the EEPROM', required=False)\n    parser.add_argument('-x', '--extract', action='store_true', default=False, help='Extract the modifiable files (boot.conf, pubkey, signature)', required=False)\n    parser.add_argument('-b', '--bootcode', help='Signed boot 2712 only. The name of the customer signed bootcode.bin file to store in the EEPROM', required=False)\n    parser.add_argument('-t', '--timestamp', help='Set the timestamp in the EEPROM image file', required=False)\n    parser.add_argument('--cacertder', help='The name of a CA Certificate DER encoded file to store in the EEPROM', required=False)\n    parser.add_argument('--debug', help='Debug logging for this tool', action='store_true', required=False)\n    parser.add_argument('eeprom', nargs='?', help='Name of EEPROM file to use as input')\n    args = parser.parse_args()\n    DEBUG = args.debug\n\n    if (args.edit or args.apply is not None) and os.getuid() != 0:\n        exit_error(\"--edit/--apply must be run as root\")\n\n    if (args.edit or args.apply is not None) and not rpi4() and not rpi5():\n        exit_error(\"--edit/--apply must run on a Raspberry Pi 4 or Raspberry Pi 5\")\n\n    if args.edit:\n        edit_config(args.eeprom)\n    elif args.eeprom is not None and args.extract:\n        image = BootloaderImage(args.eeprom, args.out)\n        image.extract_files()\n    elif args.apply is not None:\n        if not os.path.exists(args.apply):\n            exit_error(\"config file '%s' not found\" % args.apply)\n        apply_update(args.apply, args.eeprom, args.apply)\n    elif args.eeprom is not None:\n        image = BootloaderImage(args.eeprom, args.out)\n        if args.timestamp is not None:\n            image.set_timestamp(args.timestamp)\n\n        if args.bootcode is not None:\n            image.update_file(args.bootcode, BOOTCODE_BIN)\n\n        if args.cacertder is not None:\n            image.update_file(args.cacertder, CACERT_DER)\n\n        if args.config is not None:\n            # The public key, EEPROM config and signature should be set together\n            if not os.path.exists(args.config):\n                exit_error(\"config file '%s' not found\" % args.config)\n            image.update_file(args.config, BOOTCONF_TXT)\n            if args.digest is not None:\n                image.update_file(args.digest, BOOTCONF_SIG)\n            if args.pubkey is not None:\n                image.update_key(args.pubkey, PUBKEY_BIN)\n\n        if args.config is not None or args.timestamp is not None or args.bootcode is not None or args.cacertder is not None:\n            debug(\"Writing image\")\n            image.write()\n        else:\n            image.read()\n    elif args.config is None and args.eeprom is None:\n        current_config, config_src = read_current_config()\n        if args.out is not None:\n            open(args.out, 'w').write(current_config)\n        else:\n            sys.stdout.write(current_config)\n\nif __name__ == '__main__':\n    atexit.register(exit_handler)\n    main()\n"
        },
        {
          "name": "rpi-eeprom-digest",
          "type": "blob",
          "size": 4.087890625,
          "content": "#!/bin/sh\n\n# Helper script to generate .sig files for use with the Raspberry Pi bootloader.\n\n# This has been implemented in a separate script in order to have avoid having\n# a hard dependency on OpenSSL.\n\nset -e\n\nOPENSSL=${OPENSSL:-openssl}\n\ndie() {\n   echo \"$@\" >&2\n   exit 1\n}\n\nTMP_DIR=\"\"\ncleanup() {\n   if [ -d \"${TMP_DIR}\" ]; then\n      rm -rf \"${TMP_DIR}\"\n   fi\n}\n\ncheckDependencies() {\n   if ! command -v sha256sum > /dev/null; then\n      die \"sha256sum not found. Try installing the coreutilities package.\"\n   fi\n\n   if [ -n \"${KEY}\" ] || [ \"${VERIFY}\" = 1 ]; then\n       if ! command -v openssl > /dev/null; then\n          die \"openssl not found. Try installing the openssl package.\"\n       fi\n\n       if ! command -v xxd > /dev/null; then\n          die \"xxd not found. Try installing the xxd package.\"\n       fi\n   fi\n}\n\nusage() {\ncat <<EOF\nrpi-eeprom-digest [-k RSA_KEY] -i IMAGE -o OUTPUT\n\nTool to generate .sig files containing the SHA256 digest and optional\nRSA signature. Typically this tool is used by rpi-eeprom-update to\ngenerate a hash to guard against file-system corruption for EEPROM updates\nOR for signing OS images (boot.img) for secure-boot.\n\nThis tool CANNOT be used directly to sign an bootloader EEPROM image\nfor secure-boot because the signed data is bootloader configuration file\nrather than the entire flash image.\nTo create signed bootloader images please see\nhttps://github.com/raspberrypi/usbboot/tree/master/secure-boot-recovery/README.md\n\n\nOptions:\n   -i The source image e.g. boot.img\n   -o The name of the digest/signature file.\n   -k Optional RSA private key.\n\nRSA signing\nIf a private key in PEM format is supplied then the RSA signature of the\nsha256 digest is included in the .sig file. Currently, the bootloader only\nsupports sha256 digests signed with a 2048bit RSA key.\nThe bootloader only verifies RSA signatures in signed boot mode\nand only for the EEPROM config file and the signed image.\n\nExamples:\n\n# Generate the normal sha256 hash to guard against file-system corruption\nrpi-eeprom-digest -i pieeprom.bin -o pieeprom.sig\nrpi-eeprom-digest -i vl805.bin -o vl805.sig\n\n# Generate a signed OS ramdisk image for secure-boot\nrpi-eeprom-digest -k private.pem -i boot.img -o boot.sig\n\n# Generate RSA signature for the EEPROM config file\n# As used by update-pieeprom.sh in usbboot/secure-boot-recovery\nrpi-eeprom-digest -k private.pem -i bootconf.txt  -o bootconf.sig\n\n# To verify the signature of an existing .sig file using the public key.\n# N.B The key file must be the PUBLIC key in PEM format.\nrpi-eeprom-digest -k public.pem -i boot.bin -v boot.sig\n\nEOF\nexit 0\n}\n\nwriteSig() {\n   TMP_DIR=$(mktemp -d)\n   SIG_TMP=\"${TMP_DIR}/tmp.sig\"\n   sha256sum \"${IMAGE}\" | awk '{print $1}' > \"${OUTPUT}\"\n\n   # Include the update-timestamp\n   if [ -n \"${SOURCE_DATE_EPOCH}\" ] ; then\n       echo \"ts: ${SOURCE_DATE_EPOCH}\" >> \"${OUTPUT}\"\n   else\n       echo \"ts: $(date -u +%s)\" >> \"${OUTPUT}\"\n   fi\n\n   if [ -n \"${KEY}\" ]; then\n      [ -f \"${KEY}\" ] || die \"RSA private \\\"${KEY}\\\" not found\"\n      \"${OPENSSL}\" dgst -sign \"${KEY}\" -keyform PEM -sha256 -out \"${SIG_TMP}\" \"${IMAGE}\"\n      echo \"rsa2048: $(xxd -c 4096 -p < \"${SIG_TMP}\")\" >> \"${OUTPUT}\"\n   fi\n}\n\nverifySig() {\n   TMP_DIR=$(mktemp -d)\n   sig_file=\"${1}\"\n   [ -f \"${sig_file}\" ] || die \"Signature file ${sig_file} not found\"\n   sig_hex=\"$(grep rsa2048 \"${sig_file}\" | cut -f 2 -d ' ')\"\n   [ -n \"${sig_hex}\" ] || die \"No RSA signature in ${sig_file}\"\n\n   echo ${sig_hex} | xxd -c 4096 -p -r > \"${TMP_DIR}/sig.bin\"\n   \"${OPENSSL}\" dgst -verify \"${KEY}\" -signature \"${TMP_DIR}/sig.bin\" \"${IMAGE}\" || die \"${IMAGE} not verified\"\n}\n\nOUTPUT=\"\"\nVERIFY=0\nwhile getopts i:k:ho:v: option; do\n   case \"${option}\" in\n   i) IMAGE=\"${OPTARG}\"\n      ;;\n   k) KEY=\"${OPTARG}\"\n      ;;\n   o) OUTPUT=\"${OPTARG}\"\n      ;;\n   v) SIGNATURE=\"${OPTARG}\"\n      VERIFY=1\n      ;;\n   h) usage\n      ;;\n   *) echo \"Unknown argument \\\"${option}\\\"\"\n      usage\n      ;;\n   esac\ndone\n\ntrap cleanup EXIT\ncheckDependencies\n\n[ -n \"${IMAGE}\" ] || usage\n[ -f \"${IMAGE}\" ] || die \"Source image \\\"${IMAGE}\\\" not found\"\nif [ \"${VERIFY}\" = 1 ]; then\n   verifySig \"${SIGNATURE}\"\nelse\n   [ -n \"${OUTPUT}\" ] || usage\n   writeSig\nfi\n\n"
        },
        {
          "name": "rpi-eeprom-update",
          "type": "blob",
          "size": 35.8974609375,
          "content": "#!/bin/sh\n\n# Raspberry Pi bootloader EEPROM updater.\n\nset -e\n\nscript_dir=$(cd \"$(dirname \"$0\")\" && pwd)\n\nif [ -f /etc/default/rpi-eeprom-update ]; then\n   . /etc/default/rpi-eeprom-update\nfi\n\nLOCAL_MODE=0\nif [ -n \"$FIRMWARE_ROOT\" ]; then\n   # Provided by environment\n   true\nelif [ -d /lib/firmware/raspberrypi/bootloader ] || [ -d /lib/firmware/raspberrypi/bootloader-2711 ] || [ -d /lib/firmware/raspberrypi/bootloader-2712 ]; then\n   FIRMWARE_ROOT=/lib/firmware/raspberrypi/bootloader\nelse\n   # Work from local git checkout\n   LOCAL_MODE=1\n   IGNORE_DPKG_CHECKSUMS=1\n   FIRMWARE_ROOT=\"${script_dir}/firmware\"\nfi\n\n# Selects the release sub-directory\nFIRMWARE_RELEASE_STATUS=${FIRMWARE_RELEASE_STATUS:-default}\nFIRMWARE_BACKUP_DIR=${FIRMWARE_BACKUP_DIR:-/var/lib/raspberrypi/bootloader/backup}\nENABLE_VL805_UPDATES=${ENABLE_VL805_UPDATES:-1}\nCM4_ENABLE_RPI_EEPROM_UPDATE=${CM4_ENABLE_RPI_EEPROM_UPDATE:-0}\nRPI_EEPROM_UPDATE_CONFIG_TOOL=\"${RPI_EEPROM_UPDATE_CONFIG_TOOL:-raspi-config}\"\n\n# Self-update is preferred to using recovery.bin because it avoids modifiy the\n# boot partition in order to rename recovery.bin after use. Since the 2711 ROM\n# does not support network or USB MSD loading of recovery.bin self-update has to\n# be used with other boot modes anyway.\n\n# If RPI_EEPROM_SELF_UPDATE=1 then avoid installing recovery.bin so long as the\n# current bootloader version supports self-update from SD/MMC and that doesn't\n# look as though SELF_UPDATE has been disable in the EEPROM config or config.txt.\nRPI_EEPROM_SELF_UPDATE=\"${RPI_EEPROM_SELF_UPDATE:-0}\"\nRPI_EEPROM_SELF_UPDATE_MIN_VER=1650968668\n\nDT_BOOTLOADER_TS=${DT_BOOTLOADER_TS:-/proc/device-tree/chosen/bootloader/build-timestamp}\n\nEXIT_SUCCESS=0\nEXIT_UPDATE_REQUIRED=1\nEXIT_FAILED=2\nEXIT_EEPROM_FROZEN=3\n# Reserved\n# EXIT_PREVIOUS_UPDATE_FAILED=4\n\nOVERWRITE_CONFIG=0\n# Timestamp for first release which doesn't have a timestamp field\nBOOTLOADER_FIRST_VERSION=1557513636\nEEPROM_SIZE=524288\nBOARD_INFO=\nBOARD_REVISION=\nBOARD_TYPE=\nBCM_CHIP=\n\n# Newer board revisions embed the VLI firmware in the bootloader EEPROM and\n# there is no way to separately update the VLI firmware. Consequently,\n# standalone vl805 update files do not trigger automatic updates.\n# recovery.bin and the SPI bootloader ignore vl805.bin files on boards\n# without a dedicated VL805 EEPROM.\nHAVE_VL805_EEPROM=0\n\nTMP_EEPROM_IMAGE=\"\"\nTMP_BOOTFS_MNT=\"\"\n\nVL805_CURRENT_VERSION=\nVL805_UPDATE_VERSION=\n\n# The update actions selected by the version check\nACTION_UPDATE_BOOTLOADER=0\nACTION_UPDATE_VL805=0\nCHECKSUMS=''\n\ncleanup() {\n   if [ -f \"${CHECKSUMS}\" ]; then\n      rm -f \"${CHECKSUMS}\"\n   fi\n   if [ -f \"${TMP_EEPROM_IMAGE}\" ]; then\n      rm -f \"${TMP_EEPROM_IMAGE}\"\n   fi\n   if [ -f \"${TMP_EEPROM_CONFIG}\" ]; then\n      rm -f \"${TMP_EEPROM_CONFIG}\"\n   fi\n   if [ -f \"${NEW_EEPROM_CONFIG}\" ]; then\n      rm -f \"${NEW_EEPROM_CONFIG}\"\n   fi\n   if [ -f \"${FLASHROM_LOG}\" ]; then\n      rm -f \"${FLASHROM_LOG}\"\n   fi\n   if [ -d \"${TMP_BOOTFS_MNT}\" ]; then\n      umount \"${TMP_BOOTFS_MNT}\"\n      rmdir \"${TMP_BOOTFS_MNT}\"\n   fi\n   TMP_BOOTFS_MNT=\n   TMP_EEPROM_IMAGE=\n   TMP_EEPROM_CONFIG=\n   NEW_EEPROM_CONFIG=\n   FLASHROM_LOG=\n}\ntrap cleanup EXIT\n\ndie() {\n   echo \"$@\" >&2\n   exit ${EXIT_FAILED}\n}\n\nwarn() {\n   echo \"$@\" >&2\n}\n\ngetBootloaderConfig() {\n   # Prefer extracting bootloader's config from DT.\n   #\n   # In order to find the right nvmem device, we build the sysfs path of the\n   # bootloader reserved memory DT node to then match that path against all\n   # nvmem device's ofnode path.\n   #\n   # If the path isn't there, default to using vcgencmd.\n\n   local blconfig_alias=\"/sys/firmware/devicetree/base/aliases/blconfig\"\n   local blconfig_nvmem_path=\"\"\n\n   if [ -f \"${blconfig_alias}\" ]; then\n      local blconfig_ofnode_path=\"/sys/firmware/devicetree/base\"$(strings \"${blconfig_alias}\")\"\"\n      local blconfig_ofnode_link=$(find -L /sys/bus/nvmem -maxdepth 3 -samefile \"${blconfig_ofnode_path}\" 2>/dev/null)\n\n      if [ -e \"${blconfig_ofnode_link}\" ]; then\n         blconfig_nvmem_path=$(dirname \"${blconfig_ofnode_link}\")\n      fi\n   fi\n\n   if [ -n \"${blconfig_nvmem_path}\" ]; then\n      cat \"${blconfig_nvmem_path}\"/nvmem\n   else\n      vcgencmd bootloader_config\n   fi\n}\n\nprepareImage()\n{\n   [ -f \"${BOOTLOADER_UPDATE_IMAGE}\" ] || die \"EEPROM image '${BOOTLOADER_UPDATE_IMAGE}' not found\"\n   TMP_EEPROM_IMAGE=\"$(mktemp)\"\n   TMP_EEPROM_CONFIG=\"$(mktemp)\"\n   NEW_EEPROM_CONFIG=\"$(mktemp)\"\n\n   mkdir -p \"${FIRMWARE_BACKUP_DIR}\"\n\n   # Backup the configuration of the currently loaded bootloader\n   getBootloaderConfig > \"${TMP_EEPROM_CONFIG}\"\n   backup=\"${FIRMWARE_BACKUP_DIR}/pieeprom-backup-$(date +%Y%m%d-%H%M%S).conf\"\n   cp -f \"${TMP_EEPROM_CONFIG}\" \"${backup}\"\n\n   if [ -x \"${EEPROM_CONFIG_HOOK}\" ]; then\n      echo \"Running EEPROM config hook ${EEPROM_CONFIG_HOOK}\"\n      if ! \"${EEPROM_CONFIG_HOOK}\" -u \"${BOOTLOADER_UPDATE_IMAGE}\" < \"${TMP_EEPROM_CONFIG}\" > \"${NEW_EEPROM_CONFIG}\"; then\n         echo \"EEPROM config hook \\\"${EEPROM_CONFIG_HOOK}\\\"  failed. Using original configuration\"\n         cp -f \"${TMP_EEPROM_CONFIG}\" \"${NEW_EEPROM_CONFIG}\"\n      fi\n   else\n      cp -f \"${TMP_EEPROM_CONFIG}\" \"${NEW_EEPROM_CONFIG}\"\n   fi\n\n   if [ \"$(wc -l \"${NEW_EEPROM_CONFIG}\" | awk '{print $1}')\" -lt 3 ]; then\n      # Don't propagate empty EEPROM config files and also prevent the initial\n      # bootloader config with WAKE_ON_GPIO=0 propgating to newer versions by\n      # accident.\n      OVERWRITE_CONFIG=1\n   fi\n\n   cp -f \"${BOOTLOADER_UPDATE_IMAGE}\" \"${TMP_EEPROM_IMAGE}\"\n\n   if [ \"${OVERWRITE_CONFIG}\" = 0 ]; then\n      \"${script_dir}/rpi-eeprom-config\" \\\n         --out \"${TMP_EEPROM_IMAGE}\" \\\n         --config \"${NEW_EEPROM_CONFIG}\" \\\n         --timestamp \"$(date -u +%s)\" \\\n         \"${BOOTLOADER_UPDATE_IMAGE}\"\n   else\n      \"${script_dir}/rpi-eeprom-config\" \\\n         --out \"${TMP_EEPROM_IMAGE}\" \\\n         --timestamp \"$(date -u +%s)\" \\\n         \"${BOOTLOADER_UPDATE_IMAGE}\"\n   fi\n}\n\nrunFlashrom()\n{\n   attempts=5\n   freq=16000\n\n   # If flashrom fails then retry at a lower speed.\n   while [ ${attempts} -gt 0 ]; do\n      echo \"flashrom -p linux_spi:dev=${SPIDEV},spispeed=${freq} -w ${BOOTFS}/pieeprom.upd\"\n      if flashrom -p linux_spi:dev=${SPIDEV},spispeed=${freq} -w \"${BOOTFS}/pieeprom.upd\" >> \"${FLASHROM_LOG}\"; then\n         echo \"Verifying update\"\n         if flashrom -p linux_spi:dev=${SPIDEV},spispeed=${freq} -v \"${BOOTFS}/pieeprom.upd\" >> \"${FLASHROM_LOG}\"; then\n            echo \"VERIFY: SUCCESS\"\n            return 0\n         else\n            echo \"VERIFY: FAIL\"\n         fi\n      fi\n      freq=8000\n      attempts=$((attempts - 1))\n      if [ ${attempts} -gt 0 ]; then\n         echo \"Failed to update bootloader using flashrom. Retrying.\"\n      fi\n   done\n   return 1\n}\n\napplyRecoveryUpdate()\n{\n   [ -n \"${BOOTLOADER_UPDATE_IMAGE}\" ] || [ -n \"${VL805_UPDATE_IMAGE}\" ] || die \"No update images specified\"\n\n   getBootloaderCurrentVersion\n   BOOTLOADER_UPDATE_VERSION=$(strings \"${BOOTLOADER_UPDATE_IMAGE}\" | grep BUILD_TIMESTAMP | sed 's/.*=//g')\n   if [ \"${BOOTLOADER_CURRENT_VERSION}\" -gt \"${BOOTLOADER_UPDATE_VERSION}\" ]; then\n      warn \"   WARNING: Installing an older bootloader version.\"\n      warn \"            Update the rpi-eeprom package to fetch the latest bootloader images.\"\n      warn\n   fi\n   echo \"   CURRENT: $(date -u \"-d@${BOOTLOADER_CURRENT_VERSION}\") (${BOOTLOADER_CURRENT_VERSION})\"\n   echo \"    UPDATE: $(date -u \"-d@${BOOTLOADER_UPDATE_VERSION}\") (${BOOTLOADER_UPDATE_VERSION})\"\n\n   findBootFS\n   echo \"    BOOTFS: ${BOOTFS}\"\n\n   if [ -n \"${BOOTLOADER_UPDATE_IMAGE}\" ]; then\n        [ -f \"${BOOTLOADER_UPDATE_IMAGE}\" ] || die \"${BOOTLOADER_UPDATE_IMAGE} not found\"\n\n        TMP_EEPROM_IMAGE=\"$(mktemp)\"\n        prepareImage\n\n        # Generate a .sig file containing the sha256 hash of the EEPROM image\n        # and the current timestamp.\n        rpi-eeprom-digest -i \"${TMP_EEPROM_IMAGE}\" -o \"${BOOTFS}/pieeprom.sig\"\n\n        cp -fv \"${TMP_EEPROM_IMAGE}\" \"${BOOTFS}/pieeprom.upd\" \\\n                || die \"Failed to copy ${TMP_EEPROM_IMAGE} to ${BOOTFS}\"\n\n        # For NFS mounts ensure that the files are readable to the TFTP user\n        chmod -f go+r \"${BOOTFS}/pieeprom.upd\" \"${BOOTFS}/pieeprom.sig\" \\\n                || die \"Failed to set permissions on eeprom update files\"\n   fi\n\n   if [ -n \"${VL805_UPDATE_IMAGE}\" ]; then\n        rpi-eeprom-digest -i \"${VL805_UPDATE_IMAGE}\" -o \"${BOOTFS}/vl805.sig\"\n\n        cp -f \"${VL805_UPDATE_IMAGE}\" \"${BOOTFS}/vl805.bin\" \\\n                || die \"Failed to copy ${VL805_UPDATE_IMAGE} to ${BOOTFS}/vl805.bin\"\n\n        # For NFS mounts ensure that the files are readable to the TFTP user\n        chmod -f go+r \"${BOOTFS}/vl805.bin\" \"${BOOTFS}/vl805.sig\" \\\n                || die \"Failed to set permissions on eeprom update files\"\n   fi\n\n   if getBootloaderConfig | grep -q ENABLE_SELF_UPDATE=0; then\n      # Self update has been disabled in the EEPROM config so recovery.bin\n      # must be used to clear this.\n      RPI_EEPROM_SELF_UPDATE=0\n   fi\n\n   # Setting bootloader_update=0 was really intended for use with network-boot with shared\n   # config.txt files. However, if it looks as though self-update has been disabled then\n   # assume recovery.bin is required.\n   config_txt=\"${BOOTFS}/config.txt\"\n   if [ -f \"${config_txt}\" ]; then\n      if grep -q \"bootloader_update=0\" \"${config_txt}\"; then\n         RPI_EEPROM_SELF_UPDATE=0\n      fi\n   fi\n\n   [ \"${BOOTLOADER_CURRENT_VERSION}\" -ge \"${RPI_EEPROM_SELF_UPDATE_MIN_VER}\" ] || RPI_EEPROM_SELF_UPDATE=0\n\n   # For immediate updates via flash the recovery.bin update is created and then discarded if the\n   # flashrom update was successful. For SD boot (most common) this provides a rollback in the event\n   # of power loss.\n   if [ \"${RPI_EEPROM_USE_FLASHROM}\" = 1 ]; then\n      echo\n      echo \"UPDATING bootloader. This could take up to a minute. Please wait\"\n      echo\n      echo \"*** Do not disconnect the power until the update is complete ***\"\n      echo\n      echo \"If a problem occurs then the Raspberry Pi Imager may be used to create\"\n      echo \"a bootloader rescue SD card image which restores the default bootloader image.\"\n      echo\n      FLASHROM_LOG=\"$(mktemp)\"\n      if runFlashrom; then\n         # Success - remove update files from the boot partition\n         removePreviousUpdates\n         echo \"UPDATE SUCCESSFUL\"\n      else\n         # Leave the recovery files in case the EEPROM has been partially updated\n         cat \"${FLASHROM_LOG}\"\n         die \"UPDATE FAILED\"\n      fi\n      return\n   elif [ \"${RPI_EEPROM_SELF_UPDATE}\" = \"1\" ]; then\n      echo \"Using self-update\"\n   else\n      echo \"Copying recovery.bin to ${BOOTFS} for EEPROM update\"\n      cp -f \"${RECOVERY_BIN}\" \"${BOOTFS}/recovery.bin\" || die \"Failed to copy ${RECOVERY_BIN} to ${BOOTFS}\"\n   fi\n\n   echo \"\"\n   echo \"EEPROM updates pending. Please reboot to apply the update.\"\n\n   if [ \"${RPI_EEPROM_USE_FLASHROM}\" = 0 ]; then\n      echo \"To cancel a pending update run \\\"sudo rpi-eeprom-update -r\\\".\"\n   fi\n}\n\napplyUpdate() {\n   [ \"$(id -u)\" = \"0\" ] || die \"* Must be run as root - try 'sudo rpi-eeprom-update'\"\n\n   if [ \"${IGNORE_DPKG_CHECKSUMS}\" = 0 ]; then\n      (\n         package_checksums_file=\"${PACKAGE_INFO_DIR}/rpi-eeprom.md5sums\"\n\n         if ! grep -qE '\\.bin$' \"${PACKAGE_INFO_DIR}/rpi-eeprom.md5sums\"; then\n            # Try the old rpi-eeprom-images package\n            package_checksums_file=\"${PACKAGE_INFO_DIR}/rpi-eeprom-images.md5sums\"\n         fi\n\n         CHECKSUMS=$(mktemp)\n         grep -E '\\.bin$' \"${package_checksums_file}\" > \"${CHECKSUMS}\"\n         cd /\n         if ! md5sum -c \"${CHECKSUMS}\" > /dev/null 2>&1; then\n            md5sum -c \"${CHECKSUMS}\"\n            die \"rpi-eeprom checksums failed - try reinstalling this package\"\n         fi\n      ) || die \"Unable to validate EEPROM image package checksums\"\n   fi\n\n   # Disable flashrom if the SPI device is not found\n   if [ \"${RPI_EEPROM_USE_FLASHROM}\" = 1 ]; then\n      flashrom_probe_ok=0\n      if ! [ -e \"${SPIDEV}\" ]; then\n         warn \"WARNING: SPI device ${SPIDEV} not found. Setting RPI_EEPROM_USE_FLASHROM to 0\"\n      fi\n\n      if ! flashrom -p linux_spi:dev=${SPIDEV},spispeed=16000 > /dev/null 2>&1; then\n         warn \"WARNING: Flashrom probe of ${SPIDEV} failed\"\n      else\n         flashrom_probe_ok=1\n      fi\n      if [ \"${flashrom_probe_ok}\" != 1 ]; then\n         echo \"Setting RPI_EEPROM_USE_FLASHROM to 0\"\n         echo\n         export RPI_EEPROM_USE_FLASHROM=0\n      fi\n   fi\n\n   applyRecoveryUpdate\n}\n\nBOOTLOADER_CURRENT_VERSION=\ngetBootloaderCurrentVersion() {\n   if [ -f \"${DT_BOOTLOADER_TS}\" ]; then\n      # Prefer device-tree to vcgencmd\n      BOOTLOADER_CURRENT_VERSION=$(printf \"%d\" \"0x$(od \"${DT_BOOTLOADER_TS}\" -v -An -t x1 | tr -d ' ' )\")\n   elif vcgencmd bootloader_version | grep -q timestamp; then\n      BOOTLOADER_CURRENT_VERSION=$(vcgencmd bootloader_version | grep timestamp | awk '{print $2}')\n      if [ \"${BOOTLOADER_CURRENT_VERSION}\" = \"0\" ]; then\n         # If a timestamp of zero is returned then it's new firmware but an\n         # old bootloader. Assume bootloader v0\n         BOOTLOADER_CURRENT_VERSION=\"${BOOTLOADER_FIRST_VERSION}\"\n      fi\n   else\n      # New bootloader / old firmware ? Try to parse the date\n      BOOTLOADER_CURRENT_VERSION=$(date -u +%s --date \"$(vcgencmd bootloader_version | head -n1)\" 2>/dev/null || true)\n   fi\n\n   # Failed to parse the version. Default to the initial production release.\n   if [ -z \"${BOOTLOADER_CURRENT_VERSION}\" ]; then\n      BOOTLOADER_CURRENT_VERSION=\"${BOOTLOADER_FIRST_VERSION}\"\n   fi\n}\n\n# Find latest applicable update version\nBOOTLOADER_UPDATE_IMAGE=\"\"\nBOOTLOADER_UPDATE_VERSION=0\ngetBootloaderUpdateVersion() {\n   BOOTLOADER_UPDATE_VERSION=0\n   match=\".*/pieeprom-[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9].bin\"\n   latest=\"$(find \"${FIRMWARE_IMAGE_DIR}/\" -maxdepth 1 -type f -follow -size \"${EEPROM_SIZE}c\" -regex \"${match}\" | sort -r | head -n1)\"\n   if [ -f \"${latest}\" ]; then\n      BOOTLOADER_UPDATE_VERSION=$(strings \"${latest}\" | grep BUILD_TIMESTAMP | sed 's/.*=//g')\n      BOOTLOADER_UPDATE_IMAGE=\"${latest}\"\n   fi\n}\n\nchipNotSupported() {\n   echo \"Device does not a have a Raspberry Pi bootloader EEPROM (e.g. Pi 4 or Pi 5). Skipping bootloader update.\"\n   exit ${EXIT_SUCCESS}\n}\n\ncheckDependencies() {\n\n   if [ -f \"/sys/firmware/devicetree/base/system/linux,revision\" ]; then\n      BOARD_INFO=\"$(od -v -An -t x1 /sys/firmware/devicetree/base/system/linux,revision | tr -d ' \\n')\"\n   elif grep -q Revision /proc/cpuinfo; then\n      BOARD_INFO=\"$(sed -n '/^Revision/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo)\"\n   elif command -v vcgencmd > /dev/null; then\n      BOARD_INFO=\"$(vcgencmd otp_dump | grep '30:' | sed 's/.*://')\"\n   else\n      echo \"No Raspberry Pi board info found\"\n      exit ${EXIT_SUCCESS}\n   fi\n\n   if [ $(((0x$BOARD_INFO >> 23) & 1)) = 0 ]; then\n      chipNotSupported\n   fi\n\n   if [ $(((0x$BOARD_INFO >> 12) & 15)) = 3 ]; then\n      BCM_CHIP=2711\n      EEPROM_SIZE=524288\n      BOOTLOADER_AUTO_UPDATE_MIN_VERSION=\"${BOOTLOADER_AUTO_UPDATE_MIN_VERSION:-1599135103}\"\n\n      SPIDEV=/dev/spidev0.0\n   elif [ $(((0x$BOARD_INFO >> 12) & 15)) = 4 ]; then\n      BCM_CHIP=2712\n      EEPROM_SIZE=2097152\n      BOOTLOADER_AUTO_UPDATE_MIN_VERSION=\"${BOOTLOADER_AUTO_UPDATE_MIN_VERSION:-1725975630}\"\n      SPIDEV=/dev/spidev10.0\n      # Default is to use flashrom if availableon BCM2712\n      RPI_EEPROM_USE_FLASHROM=${RPI_EEPROM_USE_FLASHROM:-1}\n   else\n      chipNotSupported\n   fi\n\n   # Default to off - in the future Raspberry Pi 5 may default to using flashrom if\n   # flashrom is available.\n   if [ \"${AUTO_UPDATE_BOOTLOADER}\" = 1 ] || [ -n \"${BOOTLOADER_UPDATE_IMAGE}\" ]; then\n      [ -z \"${RPI_EEPROM_USE_FLASHROM}\" ] && RPI_EEPROM_USE_FLASHROM=0\n      if [ \"${RPI_EEPROM_USE_FLASHROM}\" -eq 1 ] && ! command -v flashrom > /dev/null; then\n         warn \"WARNING: flashrom not found. Setting RPI_EEPROM_USE_FLASHROM to 0\"\n         RPI_EEPROM_USE_FLASHROM=0\n      fi\n   fi\n\n   FIRMWARE_IMAGE_DIR=\"${FIRMWARE_ROOT}-${BCM_CHIP}/${FIRMWARE_RELEASE_STATUS}\"\n   if ! [ -d \"${FIRMWARE_IMAGE_DIR}\" ]; then\n      # Use unadorned name for backwards compatiblity\n      FIRMWARE_IMAGE_DIR=\"${FIRMWARE_ROOT}/${FIRMWARE_RELEASE_STATUS}\"\n   fi\n   RECOVERY_BIN=${RECOVERY_BIN:-${FIRMWARE_IMAGE_DIR}/recovery.bin}\n\n   BOARD_TYPE=$(((0x$BOARD_INFO >> 4) & 0xff))\n   BOARD_REVISION=$((0x$BOARD_INFO & 0xf))\n\n   if [ ${BOARD_TYPE} -eq 20 ] && [ \"${CM4_ENABLE_RPI_EEPROM_UPDATE}\" != '1' ]; then\n      # For CM4, USB device boot is the recommended method for EEPROM updates.\n      echo \"rpi-eeprom-update is not enabled by default on CM4.\"\n      echo \"The recommended method for flashing the EEPROM is rpiboot.\"\n      echo \"See: https://github.com/raspberrypi/usbboot/blob/master/Readme.md\"\n      echo \"Run with -h for more information.\"\n      echo\n      echo \"To enable flashrom programming of the EEPROM\"\n      echo \"Add these the following entries to /etc/default/rpi-eeprom-update\"\n      echo \"RPI_EEPROM_USE_FLASHROM=1\"\n      echo \"CM4_ENABLE_RPI_EEPROM_UPDATE=1\"\n      echo \n      echo \"and these entries to config.txt and reboot\"\n      echo \"[cm4]\"\n      echo \"dtparam=spi=on\"\n      echo \"dtoverlay=audremap\"\n      echo \"dtoverlay=spi-gpio40-45\"\n      echo\n      exit ${EXIT_SUCCESS}\n   fi\n\n   if [ ${BOARD_TYPE} -eq 17 ] && [ ${BOARD_REVISION} -lt 4 ]; then\n      HAVE_VL805_EEPROM=1\n   else\n      HAVE_VL805_EEPROM=0\n   fi\n\n   if ! command -v rpi-eeprom-digest > /dev/null; then\n      die \"rpi-eeprom-digest not found. Try re-installing the rpi-eeprom package\"\n   fi\n\n   if ! command -v lspci > /dev/null; then\n      die \"lspci not found. Try installing the pciutils package.\"\n   fi\n\n   if ! command -v strings > /dev/null; then\n      die \"strings not found. Try installing the binutils package.\"\n   fi\n\n   # vcgencmd bootloader_version is deprecated. Use device-tree if available to\n   # reduce the number of dependencies on VCHI.\n   if ! [ -f \"${DT_BOOTLOADER_TS}\" ]; then\n      if ! command -v vcgencmd > /dev/null; then\n         die \"vcgencmd not found. Try installing the raspi-utils package.\"\n      fi\n   fi\n\n   if [ ! -e \"${FIRMWARE_IMAGE_DIR}\" ]; then\n      die \"EEPROM updates directory ${FIRMWARE_IMAGE_DIR} not found.\"\n   fi\n\n   # If a board revision specific firmware directory is defined then use that\n   # in preference to the generic directory.\n   if [ -e \"${FIRMWARE_IMAGE_DIR}-${BOARD_INFO}\" ]; then\n      FIRMWARE_IMAGE_DIR=\"${FIRMWARE_IMAGE_DIR}-${BOARD_INFO}\"\n   fi\n\n   if ! getBootloaderConfig > /dev/null; then\n      die \"Unable to get bootloader config, please update VC firmware and reboot.\"\n   fi\n\n   if ! command -v sha256sum > /dev/null; then\n      die \"sha256sum not found. Try installing the coreutils package.\"\n   fi\n\n   if [ \"${BCM_CHIP}\" = 2711 ] && [ ! -f \"${RECOVERY_BIN}\" ]; then\n      die \"${RECOVERY_BIN} not found.\"\n   fi\n}\n\nusage() {\ncat <<EOF\nrpi-eeprom-update [options]... [FILE]\n\nBootloader EEPROM update tool for the Raspberry Pi 4 and Raspberry Pi 5.\n\nThis script also updates the SPI EEPROM image for the VL805 USB HC\nfirmware on early Pi4B boards where the USB firmware is stored in \na dedicated SPI EEPROM instead of embedding it in the bootloader\nEEPROM. Raspberry Pi 5 uses the RP1.\n\nThe default update mechanism writes recovery.bin and the EEPROM update\nimage(s) (pieeprom.upd and vl805.bin (if required)) to the boot partition.\nThe SHA256 hash of the corresponding images are written to pieeprom.sig\nand/or vl805.sig. This guards against file system corruption which could\ncause the EEPROM to be flashed with an invalid image. This is not a\nsecurity check.\n\nAt the next reboot the ROM runs recovery.bin which updates EEPROM(s).\nIf the update was successful recovery.bin renames itself to recovery.000\nto prevent it from running a second time then resets the system.\nThe system should then boot normally.\n\nIf /boot does not correspond to the boot partition and this\nis not a NOOBS system, then the mount point for BOOTFS should be defined\nin /etc/default/rpi-eeprom-update by defining the BOOTFS variable.\n\nA backup of the current EEPROM config file is written to ${FIRMWARE_BACKUP_DIR}\nbefore applying the update.\n\nUnless the -d flag is specified, the current bootloader configuration is\nretained.\n\nOptions:\n   -a Automatically install bootloader and USB (VLI) EEPROM updates.\n   -A Specify which type of EEPROM to automatically update (vl805 or bootloader)\n   -b Outputs the path that pending EEPROM updates will be written to.\n   -d Use the default bootloader config, or if a file is specified using the -f\n      flag use the config in that file. This option only applies when a\n      bootloader EEPROM update is needed; if the bootloader EEPROM is up to date\n      then its config will not be changed.\n   -f Install the given file instead of the latest applicable update\n      Ignores the FREEZE_VERSION flag in bootloader and is intended for manual\n      firmware updates.\n   -h Display help text and exit\n   -j Write status information using JSON notation (requires -m option)\n   -l Returns the full path to the latest available EEPROM image file according\n      to the FIRMWARE_RELEASE_STATUS and FIRMWARE_IMAGE_DIR settings.\n   -m Write status information to the given file when run without -a or -f\n   -r Removes temporary EEPROM update files from the boot partition. This also\n      cancels a pending update.\n   -s Skips silent, automatic upgrades for default releases if the current\n      bootloader release is newer than the version specified by\n      BOOTLOADER_AUTO_UPDATE_MIN_VERSION ${BOOTLOADER_AUTO_UPDATE_MIN_VERSION}\n   -u Install the specified VL805 (USB EEPROM) image file.\n\nEnvironment:\nEnvironment variables should be defined in /etc/default/rpi-eeprom-update\n\nEEPROM_CONFIG_HOOK\n\nSpecifies the path of an optional script which post-processes the\nconfiguration file before it is applied to the new image. The modified\noutput must contain at least 3 lines and should contain WAKE_ON_GPIO\nand POWER_OFF_ON_HALT settings.\n\nFIRMWARE_RELEASE_STATUS\n\nSpecifies the release status of the firmware to apply.\n\nBefore selecting a firmware release directory this script checks whether there\nis a board revision specific variant e.g. default-c03111. If present then the\nboard-revision specific version is used in preference.\n\nRelease status:\nBootloader releases follow a pipeline where images are released to the 'latest'\ndirectory first. The binaries are then promoted to 'default' once this\nbecomes the recommended minimum version and has been proven over time \nto be stable.\n\ndefault:\nThe default bootloader image which supports all current models and hardware\nrevisions. If there is an important bug fix or hardware change that could\naffect most users then the BOOTLOADER_AUTO_UPDATE_MIN_VERSION is updated\ncausing the update to be applied the next time the rpi-eeprom APT package is\nupdated.\n\nlatest:\nContains new features, bug fixes and performance improvements.\n\nAs far as rpi-eeprom-update is concerned FIRMWARE_RELEASE_STATUS is just\nthe subdirectory mapping under ${FIRMWARE_ROOT}. Therefore, custom release\ndirectories are supported by creating the relevant directory and changing\nthe FIRMWARE_RELEASE_STATUS environment variable.\n\nThe 'default' and 'latest' release names are symlinks to the old directory\nnames of 'critical' / 'stable'.\n\nExamples:\nTo extract the configuration file from an EEPROM image:\n   rpi-eeprom-config pieeprom.bin --out bootconf.txt\n\nTo update the configuration file in an EEPROM image:\n   rpi-eeprom-config pieeprom.bin --config bootconf.txt --out pieeprom-new.bin\n\nTo flash the new image:\n   sudo rpi-eeprom-update -d -f ./pieeprom-new.bin\n\nThe syntax is the same as config.txt See online documentation for the list of parameters.\n\nThe official documentation for the Raspberry Pi bootloader EEPROM is available at\n   https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#raspberry-pi-4-boot-eeprom\n\nCompute Module 4 (CM4):\n\nCM4 is designed to support embedded applications where physical access to the CM4\nmay be limited.  An invalid bootloader configuration or software bug could\ncause the system to fail to boot so automatic updates are disabled. We also\nrecommend write-protecting the SPI EPPROM after flashing it using usbboot.\n\nCM4 bootloader and EEPROM update instructions:\n   https://www.raspberrypi.com/documentation/computers/compute-module.html#cm4bootloader\n\nThe CM4 ROM does not support running recovery.bin from the EMMC on CM4 so this service\nis disabled by default. SELF_UPDATE from USB or Network boot is supported but this\nmust first be enabled by removing ENABLE_SELF_UPDATE=0 from the EEPROM config\nvia usbboot.\n\nAfter enabling self-update set the CM4_ENABLE_RPI_EEPROM_UPDATE=1 environment\nvariable or define it in /etc/default/rpi-eeprom-update.\n\nN.B. If there is a power failure during SELF_UPDATE the EEPROM write may fail and\nusbboot must be used to flash the bootloader EEPROM. SELF_UPDATE is not recommended\nfor updating the bootloader on remote systems.\n\nFLASHROM:\n\nIf the RPI_EEPROM_USE_FLASHROM variable is set to 1 then flashrom is used to perform\nan immediate update to the SPI flash rather than installing the recovery.bin plus\npieeprom.upd files. The power must not be disconnected during this update otherwise the\nEEPROM will need to be re-flashed using the Rasberry Pi Imager bootloader restore feature.\n\nOn Raspberry Pi 4, CM4, CM4-S and Pi400 flashrom updates are not enabled by default\nbecause the SPI GPIOs are shared with analog audio. To enable this add the following\nentries to config.txt. This moves analog audio to GPIO pins 12,13 and may not be\ncompatible with some HATS / CM4 IO boards.\n\ndtparam=spi=on\ndtoverlay=audremap\ndtoverlay=spi-gpio40-45\n\nEOF\n  exit ${EXIT_SUCCESS}\n}\n\nprintVersions()\n{\n   if [ \"${ACTION_UPDATE_BOOTLOADER}\" = 1 ]; then\n      echo \"BOOTLOADER: update available\"\n   else\n      echo \"BOOTLOADER: up to date\"\n   fi\n\n   echo \"   CURRENT: $(date -u \"-d@${BOOTLOADER_CURRENT_VERSION}\") (${BOOTLOADER_CURRENT_VERSION})\"\n   echo \"    LATEST: $(date -u \"-d@${BOOTLOADER_UPDATE_VERSION}\") (${BOOTLOADER_UPDATE_VERSION})\"\n   echo \"   RELEASE: ${FIRMWARE_RELEASE_STATUS} (${FIRMWARE_IMAGE_DIR})\"\n   echo \"            Use ${RPI_EEPROM_UPDATE_CONFIG_TOOL} to change the release.\"\n\n   if [ \"${BCM_CHIP}\" = 2711 ]; then\n      echo \"\"\n      if [ \"${HAVE_VL805_EEPROM}\" = 1 ]; then\n         echo \"  VL805_FW: Dedicated VL805 EEPROM\"\n      else\n         echo \"  VL805_FW: Using bootloader EEPROM\"\n      fi\n      if [ \"${ACTION_UPDATE_VL805}\" = 1 ]; then\n         echo \"   VL805: update available\"\n      else\n         if [ \"$(id -u)\" = \"0\" ]; then\n            echo \"     VL805: up to date\"\n         else\n            echo \"     VL805: version unknown. Try sudo rpi-eeprom-update\"\n         fi\n      fi\n\n      echo \"   CURRENT: ${VL805_CURRENT_VERSION}\"\n      echo \"    LATEST: ${VL805_UPDATE_VERSION}\"\n   fi\n}\n\nfindBootFS()\n{\n   # recovery.bin is loaded by the ROM from the boot partition, this is normally\n   # ${BOOTFS} but on NOOBS this is /dev/mmcblk0p1 with volume label RECOVERY\n   # If ${BOOTFS} is not writable OR is not on /dev/mmcblk0 then error because the ROM\n   # can only load recovery.bin from the on-board SD-CARD slot or the EEPROM.\n\n   if blkid | grep -qE \"/dev/mmcblk0p1.*LABEL_FATBOOT.*RECOVERY.*TYPE.*vfat\"; then\n      TMP_BOOTFS_MNT=\"$(mktemp -d)\"\n      mount /dev/mmcblk0p1 \"${TMP_BOOTFS_MNT}\"\n      BOOTFS=\"${TMP_BOOTFS_MNT}\"\n   elif [ -z \"$BOOTFS\" ]; then\n      if ! BOOTFS=$(/usr/lib/raspberrypi-sys-mods/get_fw_loc 2> /dev/null); then\n         for BOOTFS in /boot/firmware /boot; do\n            if [ -f \"${BOOTFS}/config.txt\" ]; then\n               break\n            elif findmnt --fstab \"$BOOTFS\" > /dev/null; then\n               break\n            fi\n         done\n      fi\n   fi\n\n   # If BOOTFS is not a directory or doesn't contain any .elf files then\n   # it's probably not the boot partition.\n   [ -d \"${BOOTFS}\" ] || die \"BOOTFS: \\\"${BOOTFS}\\\" is not a directory\"\n\n   if [ \"${BCM_CHIP}\" = 2712 ]; then\n      if ! [ -e \"${BOOTFS}/config.txt\" ]; then\n         warn \"WARNING: BOOTFS: \\\"${BOOTFS}/config.txt\\\" not found. Please check boot directory\"\n      fi\n   else\n      if [ \"$(find \"${BOOTFS}/\" -name \"*.elf\" | wc -l)\" = 0 ]; then\n         warn \"WARNING: BOOTFS: \\\"${BOOTFS}\\\" contains no .elf files. Please check boot directory\"\n      fi\n   fi\n}\n\ngetVL805CurrentVersion()\n{\n   # The version number is obtained by examing a section of PCI config\n   # space which is only accessible as root. If the command is not run as\n   # root then treat the version as unknown and skip VLI updates.\n   VL805_CURRENT_VERSION=\"\"\n\n   if [ \"${BCM_CHIP}\" = 2711 ]; then\n      if [ \"$(id -u)\" = \"0\" ]; then\n            vlver=\"$(lspci -d 1106:3483 -xxx | awk '/^50:/ { print \"VL805 FW version: \" $5 $4 $3 $2 }')\"\n         if [ -n \"${vlver}\" ]; then\n            VL805_CURRENT_VERSION=\"${vlver#*: }\"\n         fi\n      fi\n   fi\n}\n\ngetVL805UpdateVersion()\n{\n   # The VL805 version number is an eight character hex string. Select the\n   # largest number for the newest version.\n   # The vl805.latest version is retained for backwards compatibility with\n   # thirdparty scripts (are there any?) but it not used by this script and\n   # is deprecated.\n   VL805_UPDATE_VERSION=\"\"\n   match='.*/vl805-.*.bin'\n   ver=$(find \"${FIRMWARE_IMAGE_DIR}\" -maxdepth 1 -type f -follow -regex \"${match}\" | sed 's/.*\\/vl805-\\([0-9a-f]*\\)\\.bin/\\1/' | sort -r | head -n1)\n   if [ -f \"${FIRMWARE_IMAGE_DIR}/vl805-${ver}.bin\" ]; then\n      VL805_UPDATE_VERSION=\"${ver}\"\n      VL805_UPDATE_IMAGE=\"${FIRMWARE_IMAGE_DIR}/vl805-${ver}.bin\"\n   fi\n}\n\n# Retrieve the version information and determine whether newer\n# versions are available.\nlookupVersionInfo()\n{\n   getBootloaderCurrentVersion\n   getBootloaderUpdateVersion\n\n   getVL805CurrentVersion\n\n   ACTION_UPDATE_BOOTLOADER=0\n   ACTION_UPDATE_VL805=0\n\n   if [ \"${BOOTLOADER_UPDATE_VERSION}\" -gt \"${BOOTLOADER_CURRENT_VERSION}\" ]; then\n      ACTION_UPDATE_BOOTLOADER=1\n   else\n      BOOTLOADER_UPDATE_IMAGE=\"\"\n   fi\n\n   # If the '-s' flag for silent updates is specified then only update the\n   # bootloader if the current version is older than the minimum version.\n   if [ \"${SILENT_UPDATE}\" = 1 ] && [ -n \"${BOOTLOADER_AUTO_UPDATE_MIN_VERSION}\" ] && [ \"${ACTION_UPDATE_BOOTLOADER}\" = 1 ]; then\n      if [ \"${FIRMWARE_RELEASE_STATUS}\" = \"critical\" ] || [ \"${FIRMWARE_RELEASE_STATUS}\" = \"default\" ]; then\n         if [ \"${BOOTLOADER_CURRENT_VERSION}\" -ge \"${BOOTLOADER_AUTO_UPDATE_MIN_VERSION}\" ]; then\n            echo \"Skipping automatic bootloader upgrade. current ${BOOTLOADER_CURRENT_VERSION} >= min ${BOOTLOADER_AUTO_UPDATE_MIN_VERSION}\"\n            echo \"\"\n\n            # Clear the update requried flag\n            ACTION_UPDATE_BOOTLOADER=0\n            BOOTLOADER_UPDATE_IMAGE=\"\"\n         fi\n      fi\n   fi\n\n   if [ \"${HAVE_VL805_EEPROM}\" = 1 ]; then\n      getVL805UpdateVersion\n      if [ -n \"${VL805_CURRENT_VERSION}\" ] && [ -n \"${VL805_UPDATE_VERSION}\" ]; then\n         if [ \"$((0x${VL805_CURRENT_VERSION}))\" -lt \"$((0x${VL805_UPDATE_VERSION}))\" ];  then\n            ACTION_UPDATE_VL805=1\n         else\n            VL805_UPDATE_IMAGE=\"\"\n         fi\n      fi\n   else\n      VL805_UPDATE_VERSION=\"${VL805_CURRENT_VERSION}\"\n      ACTION_UPDATE_VL805=0\n   fi\n}\n\ncheckAndApply()\n{\n   lookupVersionInfo\n   removePreviousUpdates\n\n   # Restrict the automatic updates to the EEPROM types selected by the -A option.\n   if [ \"${AUTO_UPDATE_VL805}\" != 1 ]; then\n      ACTION_UPDATE_VL805=0\n      VL805_UPDATE_IMAGE=\"\"\n   fi\n   if [ \"${AUTO_UPDATE_BOOTLOADER}\" != 1 ]; then\n      ACTION_UPDATE_BOOTLOADER=0\n      BOOTLOADER_UPDATE_IMAGE=\"\"\n   fi\n\n   if [ \"${ACTION_UPDATE_BOOTLOADER}\" = 1 ] || [ \"${ACTION_UPDATE_VL805}\" = 1 ]; then\n      echo \"*** PREPARING EEPROM UPDATES ***\"\n      echo \"\"\n\n      printVersions\n      applyUpdate\n   else\n      printVersions\n   fi\n}\n\nfileUpdate()\n{\n   removePreviousUpdates\n   echo \"*** CREATED UPDATE ${BOOTLOADER_UPDATE_IMAGE} ${VL805_UPDATE_IMAGE} ***\"\n   echo\n\n   if [ -n \"${BOOTLOADER_UPDATE_IMAGE}\" ]; then\n      [ -f \"${BOOTLOADER_UPDATE_IMAGE}\" ] || die \"Bootloader image \\\"${BOOTLOADER_UPDATE_IMAGE}\\\" not found\"\n   fi\n\n   if [ -n \"${VL805_UPDATE_IMAGE}\" ]; then\n      [ -f \"${VL805_UPDATE_IMAGE}\" ] || die \"VL805 image \\\"${VL805_UPDATE_IMAGE}\\\" not found\"\n   fi\n\n   applyUpdate\n}\n\nremovePreviousUpdates()\n{\n   if [ \"$(id -u)\" = \"0\" ]; then\n      findBootFS\n\n      (\n         # Remove any stale recovery.bin files or EEPROM images\n         # N.B. recovery.bin is normally ignored by the ROM if is not a valid\n         # executable but it's best to not have the file at all.\n         rm -f \"${BOOTFS}/recovery.bin\"\n         rm -f \"${BOOTFS}/pieeprom.bin\" \"${BOOTFS}/pieeprom.upd\" \"${BOOTFS}/pieeprom.sig\"\n         rm -f \"${BOOTFS}/vl805.bin\" \"${BOOTFS}/vl805.sig\"\n         # Case insensitive for FAT bootfs\n         find \"${BOOTFS}\" -maxdepth 1 -type f -follow -iname \"recovery.*\" -regex '.*\\.[0-9][0-9][0-9]$' -exec rm -f {} \\;\n      ) || die \"Failed to remove previous update files\"\n   fi\n}\n\ncheckVersion()\n{\n   lookupVersionInfo\n\n   if [ \"${ACTION_UPDATE_BOOTLOADER}\" = 1 ] || [ \"${ACTION_UPDATE_VL805}\" = 1 ]; then\n      echo \"*** UPDATE AVAILABLE ***\"\n      echo \"\"\n      echo \"Run \\\"sudo rpi-eeprom-update -a\\\" to install this update now.\"\n      echo\n      echo \"To configure the bootloader update policy run \\\"sudo ${RPI_EEPROM_UPDATE_CONFIG_TOOL}\\\"\"\n      echo \"\"\n      printVersions\n      write_status_info \"EXIT_UPDATE_REQUIRED\"\n      exit ${EXIT_UPDATE_REQUIRED}\n   else\n      printVersions\n      write_status_info \"EXIT_SUCCESS\"\n      exit ${EXIT_SUCCESS}\n   fi\n}\n\nwrite_status_info()\n{\n   [ -z \"${MACHINE_OUTPUT}\" ] && return 0\n\n   exit_code=\"${1:-EXIT_FAILED}\"\n   bootloader_cur=\"${BOOTLOADER_CURRENT_VERSION:-0}\"\n   bootloader_new=\"${BOOTLOADER_UPDATE_VERSION:-0}\"\n   vl805_cur=\"${VL805_CURRENT_VERSION}\"\n   vl805_new=\"${VL805_UPDATE_VERSION}\"\n   min_ver=${BOOTLOADER_AUTO_UPDATE_MIN_VERSION:-0}\n\n    if [ \"${JSON_OUTPUT}\" = \"no\" ]; then\n      [ \"${HAVE_VL805_EEPROM}\" = \"0\" ] && vl805_eeprom=\"no\" || vl805_eeprom=\"yes\"\n      cat > \"${MACHINE_OUTPUT}\" <<EOF\nEXITCODE=\"${exit_code}\"\nBOOTLOADER_AUTO_UPDATE_MIN_VERSION=${min_ver}\nBOOTLOADER_CURRENT=${bootloader_cur}\nBOOTLOADER_LATEST=${bootloader_new}\nVL805_CURRENT=\"${vl805_cur}\"\nVL805_LATEST=\"${vl805_new}\"\nVL805_EEPROM=\"${vl805_eeprom}\"\nEOF\n   else\n      [ \"${HAVE_VL805_EEPROM}\" = \"0\" ] && vl805_eeprom=\"false\" || vl805_eeprom=\"true\"\n      cat > \"${MACHINE_OUTPUT}\" <<EOF\n{\n  \"EXITCODE\": \"${exit_code}\",\n  \"BOOTLOADER_AUTO_UPDATE_MIN_VERSION\": ${min_ver},\n  \"BOOTLOADER_CURRENT\": ${bootloader_cur},\n  \"BOOTLOADER_LATEST\": ${bootloader_new},\n  \"VL805_CURRENT\": \"${vl805_cur}\",\n  \"VL805_LATEST\": \"${vl805_new}\",\n  \"VL805_EEPROM\": ${vl805_eeprom}\n}\nEOF\n   fi\n   return 0\n}\n\nAUTO_UPDATE_BOOTLOADER=0\nAUTO_UPDATE_VL805=0\nSILENT_UPDATE=0\nMACHINE_OUTPUT=\"\"\nJSON_OUTPUT=\"no\"\n# Ignore dpkg checksums by default so that rpi-update can install new binaries into /lib/firmware\nIGNORE_DPKG_CHECKSUMS=${IGNORE_DPKG_CHECKSUMS:-1}\nPACKAGE_INFO_DIR=\"/var/lib/dpkg/info/\"\nif [ ! -d \"${PACKAGE_INFO_DIR}\" ]; then\n   IGNORE_DPKG_CHECKSUMS=1\nfi\n\n\nwhile getopts A:abdhilf:m:ju:rs option; do\n   case \"${option}\" in\n   A)\n      if [ \"${OPTARG}\" = \"bootloader\" ]; then\n         AUTO_UPDATE_BOOTLOADER=1\n      elif [ \"${OPTARG}\" = \"vl805\" ]; then\n         AUTO_UPDATE_VL805=1\n      else\n         die \"Unknown update mode: ${OPTARG}\"\n      fi\n      ;;\n   a) AUTO_UPDATE_BOOTLOADER=1\n      AUTO_UPDATE_VL805=1\n      ;;\n   b)\n      findBootFS\n      echo \"${BOOTFS}\"\n      exit 0\n      ;;\n   d) OVERWRITE_CONFIG=1\n      ;;\n   f) BOOTLOADER_UPDATE_IMAGE=\"${OPTARG}\"\n      ;;\n   i)\n      # Script default is 1 but this could have been set to zero in the defaults file\n      IGNORE_DPKG_CHECKSUMS=1\n      ;;\n   j) JSON_OUTPUT=\"yes\"\n      ;;\n   l)\n      checkDependencies\n      getBootloaderUpdateVersion\n      echo \"${BOOTLOADER_UPDATE_IMAGE}\"\n      exit 0\n      ;;\n   m) MACHINE_OUTPUT=\"${OPTARG}\"\n      ;;\n   h) usage\n      ;;\n   r) [ \"$(id -u)\" = \"0\" ] || die \"* Must be run as root - try 'sudo rpi-eeprom-update -r'\"\n      echo \"Removing temporary files from previous EEPROM update\"\n      checkDependencies\n      removePreviousUpdates\n      exit 0\n      ;;\n   s) SILENT_UPDATE=1\n      ;;\n   u) VL805_UPDATE_IMAGE=\"${OPTARG}\"\n      ;;\n   *) echo \"Unknown argument \\\"${option}\\\"\"\n      usage\n      ;;\n   esac\ndone\n\ncheckDependencies\nif [ \"${AUTO_UPDATE_BOOTLOADER}\" = 1 ] || [ \"${AUTO_UPDATE_VL805}\" = 1 ]; then\n   if getBootloaderConfig | grep FREEZE_VERSION=1; then\n      echo \"EEPROM version is frozen. Skipping automatic update\"\n      exit ${EXIT_EEPROM_FROZEN}\n   else\n      checkAndApply\n   fi\nelif [ -n \"${BOOTLOADER_UPDATE_IMAGE}\" ] || [ -n \"${VL805_UPDATE_IMAGE}\" ]; then\n   fileUpdate\nelse\n   checkVersion\nfi\n"
        },
        {
          "name": "rpi-eeprom-update-default",
          "type": "blob",
          "size": 0.3623046875,
          "content": "\nFIRMWARE_ROOT=/lib/firmware/raspberrypi/bootloader\nFIRMWARE_RELEASE_STATUS=\"default\"\nFIRMWARE_BACKUP_DIR=\"/var/lib/raspberrypi/bootloader/backup\"\nEEPROM_CONFIG_HOOK=\n\n# BOOTFS can be set here to override auto-detection in rpi-eeprom-update\n#BOOTFS=/boot\n\n# Use flashrom if available to update the bootloader without rebooting - Raspberry Pi 5\n#RPI_EEPROM_USE_FLASHROM=1\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}