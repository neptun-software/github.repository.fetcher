{
  "metadata": {
    "timestamp": 1736568505701,
    "page": 499,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "discourse/discourse_docker",
      "stars": 1707,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.306640625,
          "content": "shared/*\n*.swp\n*~\n\\#*\\#\ncontainers/*\ncids/*\nbin/*\nimage/.build.out\nimage/.build.hash\nimage/.docker_temp_*\nimage/img.tar\nimage/squash.tar\nimage/nsenter/nsenter\nimage/docker-squash\nimage/docker-squash.tar.gz\nimage/discourse_dev/postgres.template.yml\nimage/discourse_dev/redis.template.yml\n.gc-state/*\n.vagrant/\ntmp/*"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0732421875,
          "content": "MIT License\n\nCopyright (c) 2018 Civilized Discourse Construction Kit, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.27734375,
          "content": "# Discourse Docker images\n\n## About\n\n- [Docker](https://docker.com/) is an open source project to pack, ship and run any Linux application in a lighter weight, faster container than a traditional virtual machine.\n\n- Docker makes it much easier to deploy [a Discourse forum](https://github.com/discourse/discourse) on your servers and keep it updated. For background, see [Sam's blog post](http://samsaffron.com/archive/2013/11/07/discourse-in-a-docker-container).\n\n- The templates and base image configure Discourse with the Discourse team's recommended optimal defaults.\n\n## Getting Started\n\nThe simplest way to get started is via the **standalone** template, which can be installed in 30 minutes or less. For detailed install instructions, see\n\nhttps://github.com/discourse/discourse/blob/main/docs/INSTALL-cloud.md\n\n## Directory Structure\n\n### `/cids`\n\nContains container ids for currently running Docker containers. cids are Docker's \"equivalent\" of pids. Each container will have a unique git like hash.\n\n### `/containers`\n\nThis directory is for container definitions for your various Discourse containers. You are in charge of this directory, it ships empty.\n\n### `/samples`\n\nSample container definitions you may use to bootstrap your environment. You can copy templates from here into the containers directory.\n\n### `/shared`\n\nPlaceholder spot for shared volumes with various Discourse containers. You may elect to store certain persistent information outside of a container, in our case we keep various logfiles and upload directory outside. This allows you to rebuild containers easily without losing important information. Keeping uploads outside of the container allows you to share them between multiple web instances.\n\n### `/templates`\n\n[pups](https://github.com/discourse/pups)-managed templates you may use to bootstrap your environment.\n\n### `/image`\n\nDockerfiles for Discourse; see [the README](image/README.md) for further details.\n\nThe Docker repository will always contain the latest built version at: https://hub.docker.com/r/discourse/base/, you should not need to build the base image.\n\n## Launcher\n\nThe base directory contains a single bash script which is used to manage containers. You can use it to \"bootstrap\" a new container, enter, start, stop and destroy a container.\n\n```\nUsage: launcher COMMAND CONFIG [--skip-prereqs] [--docker-args STRING]\nCommands:\n    start:       Start/initialize a container\n    stop:        Stop a running container\n    restart:     Restart a container\n    destroy:     Stop and remove a container\n    enter:       Open a shell to run commands inside the container\n    logs:        View the Docker logs for a container\n    bootstrap:   Bootstrap a container for the config based on a template\n    run:         Run the given command with the config in the context of the last bootstrapped image\n    rebuild:     Rebuild a container (destroy old, bootstrap, start new)\n    cleanup:     Remove all containers that have stopped for > 24 hours\n    start-cmd:   Generate docker command used to start container\n```\n\nIf the environment variable \"SUPERVISED\" is set to true, the container won't be detached, allowing a process monitoring tool to manage the restart behaviour of the container.\n\n## Container Configuration\n\nThe beginning of the container definition can contain the following \"special\" sections:\n\n### templates:\n\n```yaml\ntemplates:\n  - 'templates/cron.template.yml'\n  - 'templates/postgres.template.yml'\n```\n\nThis template is \"composed\" out of all these child templates, this allows for a very flexible configuration structure. Furthermore you may add specific hooks that extend the templates you reference.\n\n### expose:\n\n```yaml\nexpose:\n  - '2222:22'\n  - '127.0.0.1:20080:80'\n```\n\nPublish port 22 inside the container on port 2222 on ALL local host interfaces. In order to bind to only one interface, you may specify the host's IP address as `([<host_interface>:[host_port]])|(<host_port>):<container_port>[/udp]` as defined in the [docker port binding documentation](http://docs.docker.com/userguide/dockerlinks/). To expose a port without publishing it, specify only the port number (e.g., `80`).\n\n### volumes:\n\n```yaml\nvolumes:\n  - volume:\n    host: /var/discourse/shared\n    guest: /shared\n```\n\nExpose a directory inside the host to the container.\n\n### links:\n\n```yaml\nlinks:\n  - link:\n    name: postgres\n    alias: postgres\n```\n\nLinks another container to the current container. This will add `--link postgres:postgres`\nto the options when running the container.\n\n### environment variables:\n\nSetting environment variables to the current container.\n\n```yaml\nenv:\n  DISCOURSE_DB_HOST: some-host\n  DISCOURSE_DB_NAME: '{{config}}_discourse'\n```\n\nThe above will add `-e DISCOURSE_DB_HOST=some-host -e DISCOURSE_DB_NAME=app_discourse` to the options when running the container.\n\n### labels:\n\n```yaml\nlabels:\n  monitor: 'true'\n  app_name: '{{config}}_discourse'\n```\n\nAdd labels to the current container. The above will add `--l monitor=true -l app_name=dev_discourse` to the options\nwhen running the container\n\n## Upgrading Discourse\n\nThe Docker setup gives you multiple upgrade options:\n\n1. Use the front end at http://yoursite.com/admin/upgrade to upgrade an already running image.\n\n2. Create a new base image manually by running:\n   `./launcher rebuild my_image`\n\n## Single Container vs. Multiple Containers\n\nThe samples directory contains a standalone template. This template bundles all of the software required to run Discourse into a single container. The advantage is that it is easy.\n\nThe multiple container configuration setup is far more flexible and robust, however it is also more complicated to set up. A multiple container setup allows you to:\n\n- Minimize downtime when upgrading to new versions of Discourse. You can bootstrap new web processes while your site is running and only after it is built, switch the new image in.\n- Scale your forum to multiple servers.\n- Add servers for redundancy.\n- Have some required services (e.g. the database) run on beefier hardware.\n\nIf you want a multiple container setup, see the `data.yml` and `web_only.yml` templates in the samples directory. To ease this process, `launcher` will inject an env var called `DISCOURSE_HOST_IP` which will be available inside the image.\n\nWARNING: In a multiple container configuration, _make sure_ you setup iptables or some other firewall to protect various ports (for postgres/redis).\nOn Ubuntu, install the `ufw` or `iptables-persistent` package to manage firewall rules.\n\n## Email\n\nFor a Discourse instance to function properly Email must be set up. Use the `SMTP_URL` env var to set your SMTP address, see sample templates for an example. The Docker image does not contain postfix, exim or another MTA, it was omitted because it is very tricky to set up correctly.\n\n## Troubleshooting\n\nView the container logs: `./launcher logs my_container`\n\nSpawn a shell inside your container using `./launcher enter my_container`. This is the most foolproof method if you have host root access.\n\nIf you see network errors trying to retrieve code from `github.com` or `rubygems.org` try again - sometimes there are temporary interruptions and a retry is all it takes.\n\nBehind a proxy network with no direct access to the Internet? Add proxy information to the container environment by adding to the existing `env` block in the `container.yml` file:\n\n```yaml\nenv:\n  …existing entries…\n  HTTP_PROXY: http://proxyserver:port/\n  http_proxy: http://proxyserver:port/\n  HTTPS_PROXY: http://proxyserver:port/\n  https_proxy: http://proxyserver:port/\n```\n\n## Security\n\nDirectory permissions in Linux are UID/GID based, if your numeric IDs on the\nhost do not match the IDs in the guest, permissions will mismatch. On clean\ninstalls you can ensure they are in sync by looking at `/etc/passwd` and\n`/etc/group`, the Discourse account will have UID 1000.\n\n## Advanced topics\n\n- [Setting up SSL with Discourse Docker](https://meta.discourse.org/t/allowing-ssl-for-your-discourse-docker-setup/13847)\n- [Multisite configuration with Docker](https://meta.discourse.org/t/multisite-configuration-with-docker/14084)\n- [Linking containers for a multiple container setup](https://meta.discourse.org/t/linking-containers-for-a-multiple-container-setup/20867)\n- [Using Rubygems mirror to improve connection problem in China](https://meta.discourse.org/t/replace-rubygems-org-with-taobao-mirror-to-resolve-network-error-in-china/21988/1)\n\n## License\n\nMIT\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "cids",
          "type": "tree",
          "content": null
        },
        {
          "name": "containers",
          "type": "tree",
          "content": null
        },
        {
          "name": "discourse-doctor",
          "type": "blob",
          "size": 11.705078125,
          "content": "#!/usr/bin/env bash\nLOG_FILE=\"/tmp/discourse-debug.txt\"\nWORKING_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n\nlog() {\n  if [ \"$1\" == \"-e\" ]\n  then\n    shift\n    echo -e \"$*\" | tee -a \"$LOG_FILE\"\n  else\n    echo \"$*\" | tee -a \"$LOG_FILE\"\n  fi\n}\n\ncheck_root() {\n  if [[ $EUID -ne 0 ]]; then\n    log \"This script must be run as root. Please sudo or log in as root first.\" 1>&2\n    exit 1\n  fi\n}\n\n##\n## Check whether a connection to HOSTNAME ($1) on PORT ($2) is possible\n##\nconnect_to_port() {\n  HOST=\"$1\"\n  PORT=\"$2\"\n  VERIFY=$(date +%s | sha256sum | base64 | head -c 20)\n  echo -e \"HTTP/1.1 200 OK\\n\\n $VERIFY\" | nc -w 4 -l -p $PORT >/dev/null 2>&1 &\n  if curl --proto =http -s $HOST:$PORT --connect-timeout 3 | grep $VERIFY >/dev/null 2>&1 &\n  then\n    return 0\n  else\n    return 1\n  fi\n}\n\ncheck_ip_match() {\n  HOST=\"$1\"\n  log\n  log Checking your domain name . . .\n  if connect_to_port $HOST 443\n  then\n    log\n    log \"Connection to $HOST succeeded.\"\n  else\n    log WARNING:: This server does not appear to be accessible at $HOST:443.\n    log\n    if connect_to_port $HOST 80\n    then\n\tlog A connection to port 80 succeeds, however.\n\tlog This suggests that your DNS settings are correct,\n\tlog but something is keeping traffic to port 443 from getting to your server.\n\tlog Check your networking configuration to see that connections to port 443 are allowed.\n    else\n      log \"A connection to http://$HOST (port 80) also fails.\"\n      log\n      log This suggests that $HOST resolves to the wrong IP address\n      log or that traffic is not being routed to your server.\n    fi\n    log\n    log Google: \\\"open ports YOUR CLOUD SERVICE\\\" for information for resolving this problem.\n    log\n    log This test might not work for all situations,\n    log so if you can access Discourse at http://$HOST, this might not indicate a problem.\n    sleep 3\n  fi\n}\n\ncheck_docker_is_installed() {\n  log -e \"\\n==================== DOCKER INFO ====================\"\n  docker_path=\"$(which docker.io || which docker)\"\n  if [ -z $docker_path ]; then\n    log \"Docker is not installed. Have you installed Discourse at all?\"\n    log \"Perhaps you're looking for ./discourse-setup .\"\n    log \"There is no point in continuing.\"\n    exit\n  else\n    log -e \"DOCKER VERSION: $(docker --version)\"\n    log -e \"\\nDOCKER PROCESSES (docker ps -a)\\n\\n$(sudo docker ps -a)\\n\"\n  fi\n}\n\nget_OS() {\n  log -e \"OS: $(uname -s)\"\n}\n\ncheck_disk_and_memory() {\n  log -e \"\\n\\n==================== MEMORY INFORMATION ====================\"\n  os_type=$(get_OS)\n  if [ \"$os_type\" == \"Darwin\" ]; then\n    log -e \"RAM: $( free -m | awk '/Mem:/ {print $2}' ) \\n\"\n  else\n    log -e \"RAM (MB): $( free -m --si | awk ' /Mem:/  {print $2} ')\\n\"\n  fi\n  log \"$(free -m)\"\n\n  log -e \"\\n==================== DISK SPACE CHECK ====================\"\n  log \"---------- OS Disk Space ----------\"\n  log \"$(df -h / /var/discourse /var/lib/docker /var/lib/docker/* | uniq)\"\n\n  if [ \"$version\" != \"NOT FOUND\" ]\n  then\n    log\n    log \"---------- Container Disk Space ----------\"\n    log \"$(sudo docker exec -w /var/www/discourse -i $app_name df -h / /shared/ /shared/postgres_data /shared/redis_data /shared/backups /var/log | uniq)\"\n  fi\n\n  log -e \"\\n==================== DISK INFORMATION ====================\"\n  log \"$( fdisk -l )\"\n  log -e \"\\n==================== END DISK INFORMATION ====================\"\n\n  free_disk=\"$(df /var | tail -n 1 | awk '{print $4}')\"\n  # Arguably ./launcher is doing this so discourse-doctor does not need to . . .\n  if [ \"$free_disk\" -lt 5000 ]; then\n  log \"\\n\\n==================== DISK SPACE PROBLEM ====================\"\n    log  \"WARNING: you appear to have very low disk space.\"\n    log \"This could be the cause of problems running your site.\"\n    log \"Please free up some space, or expand your disk, before continuing.\"\n    log\n    log \"Run \\'apt-get autoremove && apt-get autoclean\\' to clean up unused\"\n    log \"packages and \\'./launcher cleanup\\' to remove stale Docker containers.\"\n    exit 1\n  fi\n}\n\nget_discourse_version() {\n  version=\"\"\n  version=$(wget -q --timeout=3 https://$VERSION_HOSTNAME/privacy  -O -|grep generator|head -1 |cut -d \"=\" -f 3|cut -d '-' -f 1 |cut -d '\"' -f 2)  &> /dev/null\n  if ! echo $version | grep Discourse\n  then\n    version=$(wget -q --timeout=3 http://$VERSION_HOSTNAME/privacy  -O -|grep generator|head -1 |cut -d \"=\" -f 3|cut -d '-' -f 1 |cut -d '\"' -f 2) &> /dev/null\n  fi\n  if [ -z \"$version\" ]\n  then\n    version=\"NOT FOUND\"\n  fi\n  log \"Discourse version at $VERSION_HOSTNAME: $version\"\n}\n\ncheck_if_hostname_resolves_here() {\n  log \"========================================\"\n  VERSION_HOSTNAME=$DISCOURSE_HOSTNAME\n  get_discourse_version\n  DISCOURSE_VERSION=\"$version\"\n  VERSION_HOSTNAME=localhost\n  get_discourse_version\n  LOCALHOST_VERSION=\"$version\"\n  if [ \"$DISCOURSE_VERSION\" != \"$LOCALHOST_VERSION\" ]\n  then\n    log \"==================== DNS PROBLEM ====================\"\n    log \"This server reports $LOCALHOST_VERSION, but $DISCOURSE_HOSTNAME reports $DISCOURSE_VERSION.\"\n    log \"This suggests that you have a DNS problem or that an intermediate proxy is to blame.\"\n    log \"If you are using Cloudflare, or a CDN, it may be improperly configured.\"\n  fi\n}\n\n##\n## get discourse configuration values from YML file\n##\nget_discourse_config() {\n  log -e \"\\n==================== YML SETTINGS ====================\"\n  read_config \"DISCOURSE_HOSTNAME\"\n  DISCOURSE_HOSTNAME=$read_config_result\n  log DISCOURSE_HOSTNAME=$DISCOURSE_HOSTNAME\n  read_config \"DISCOURSE_SMTP_ADDRESS\"\n  SMTP_ADDRESS=$read_config_result\n  log SMTP_ADDRESS=$SMTP_ADDRESS\n  read_config \"DISCOURSE_DEVELOPER_EMAILS\"\n  DEVELOPER_EMAILS=$read_config_result\n  log DEVELOPER_EMAILS=$DEVELOPER_EMAILS\n  read_config \"DISCOURSE_SMTP_PASSWORD\"\n  SMTP_PASSWORD=$read_config_result\n  log SMTP_PASSWORD=$read_config_result\n  read_config \"DISCOURSE_SMTP_PORT\"\n  SMTP_PORT=$read_config_result\n  log SMTP_PORT=$read_config_result\n  read_config \"DISCOURSE_SMTP_USER_NAME\"\n  SMTP_USER_NAME=$read_config_result\n  log SMTP_USER_NAME=$read_config_result\n  read_config \"LETSENCRYPT_ACCOUNT_EMAIL\"\n  letsencrypt_account_email=$read_config_result\n  log \"LETSENCRYPT_ACCOUNT_EMAIL=$letsencrypt_account_email\"\n}\n\ncheck_plugins() {\n  log -e \"\\n\\n==================== PLUGINS ====================\"\n  log -e \"$(grep 'git clone' containers/$app_name.yml)\"\n  grep git containers/$app_name.yml > /tmp/$PPID.grep\n\n  if grep -cv \"github.com/discourse\" /tmp/$PPID.grep > /dev/null\n  then\n    log -e \"\\nWARNING:\"\n    log You have what appear to be non-official plugins.\n    log \"If you are having trouble, you should disable them and try rebuilding again.\"\n  else\n    log -e \"\\nNo non-official plugins detected.\"\n  fi\n  log -e \"\\nSee https://github.com/discourse/discourse/blob/main/lib/plugin/metadata.rb for the official list.\\n\"\n}\n\ndump_yaml() {\n  log -e \"\\n\\n==================== YML DUMP ====================\"\n  log Dumping $app_name.yml\n  log -e \"\\n\\n\"\n}\n\n##\n## read a variable from the config file and stick it in read_config_result\n##\nread_config() {\n  config_line=$(grep -E \"^  #?$1:\" $web_file)\n  read_config_result=$(echo $config_line | awk  -F \":\" '{print $2}')\n  read_config_result=$(echo $read_config_result | sed \"s/^\\([\\\"']\\)\\(.*\\)\\1\\$/\\2/g\")\n}\n\n##\n## call rake emails:test inside the container\n##\ncheck_email() {\n  log -e \"\\n==================== MAIL TEST ====================\"\n  log \"For a robust test, get an address from http://www.mail-tester.com/\"\n  echo \"Or just send a test message to yourself.\"\n  EMAIL=$(echo $DEVELOPER_EMAILS |cut -d , -f 1)\n  read -p \"Email address for mail test? ('n' to skip) [$EMAIL]: \" new_value\n  if [ ! -z \"$new_value\" ]\n  then\n    EMAIL=\"$new_value\"\n  fi\n  if [ \"$new_value\" != \"n\" ] && [ \"$new_value\" != \"N\" ]\n  then\n    log \"Sending mail to $EMAIL. . . \"\n    log \"$(sudo docker exec -w /var/www/discourse -i $app_name rake emails:test[$EMAIL])\"\n  else\n    log \"Mail test skipped.\"\n  fi\n}\n\nget_yml_file() {\n  app_name=\"\"\n  if [ -f containers/app.yml ]\n  then\n    app_name=\"app\"\n    web_file=containers/$app_name.yml\n    log \"Found $web_file\"\n  elif [ -f containers/web_only.yml ]\n  then\n    log \"YML=web_only.yml\"\n    app_name=\"web_only\"\n    web_file=containers/$app_name.yml\n    log \"Found $web_file\"\n  else\n    log \"Can't find app.yml or web_only.yml.\"\n    log \"Giving up.\"\n    exit\n  fi\n}\n\ncheck_docker() {\n  docker ps | tail -n +2 > /tmp/$UUID-docker.txt\n\n  if grep $app_name /tmp/$UUID-docker.txt\n  then\n    log -e \"\\nDiscourse container $app_name is running\"\n  else\n    log \"==================== SERIOUS PROBLEM!!!! ====================\"\n    log \"$app_name not running!\"\n    log \"Attempting to rebuild\"\n    log \"==================== REBUILD LOG ====================\"\n    # too hard to pass STDERR of ./launcher to log()\n    ./launcher rebuild $app_name 2>&1 | tee -a $LOG_FILE\n    log \"==================== END REBUILD LOG ====================\"\n    docker ps | tail -n +2 > /tmp/$UUID-docker.txt\n    if grep $app_name /tmp/$UUID-docker.txt\n    then\n      log -e \"\\nDiscourse container $app_name is now running.\"\n      log \". . . waiting 30 seconds for container to crank up. . . \"\n      sleep 30\n    else\n      log \"Failed to rebuild $app_name.\"\n      # check_ip_match checks if curl to $DISCOURSE_HOSTNAME gets to this server\n      # It works only if ports 80 and 443 are free\n      check_ip_match $DISCOURSE_HOSTNAME\n      log \"You should probably remove any non-standard plugins and rebuild.\"\n      NO_CONTAINER='y'\n      log \"Attempting to restart existing container. . . \"\n      ./launcher start $app_name 2>&1 | tee -a $LOG_FILE\n      docker ps | tail -n +2 > /tmp/$UUID-docker.txt\n      if grep $app_name /tmp/$UUID-docker.txt\n      then\n        log \"Restarted the container.\"\n        NO_CONTAINER='n'\n      else\n        log \"Failed to restart the container.\"\n      fi\n    fi\n  fi\n}\n\n##\n## redact passwords and email addresses from log file\n##\nclean_up_log_file() {\n  for VAR\n  in SMTP_PASSWORD LETSENCRYPT_ACCOUNT_EMAIL DEVELOPER_EMAILS DISCOURSE_DB_PASSWORD 'Sending mail to'\n  do\n    echo \"Replacing: $VAR\"\n    sed -i -e 's/'\"$VAR\"'\\([=: ]\\)\\S*/'\"$VAR\"'\\1REDACTED /g' $LOG_FILE\n  done\n}\n\nprint_done() {\n  log\n  log \"==================== DONE! ====================\"\n  DOCTOR_FILE=$(date +%s | sha256sum | base64 | head -c 20).txt\n\n  if [ $app_name == 'app' ] && [ \"$NO_CONTAINER\" != 'y' ]; then\n    read -p \"Would you like to serve a publicly available version of this file? (Y/n) \" serve\n    case \"${serve:-Y}\" in\n      y*|Y*)\n        cp $LOG_FILE shared/standalone/log/var-log/$DOCTOR_FILE\n        sudo docker exec -w /var/www/discourse -i $app_name cp /var/log/$DOCTOR_FILE  public\n        log \"The output of this program may be available at http://$DISCOURSE_HOSTNAME/$DOCTOR_FILE\"\n        log \"You should inspect that file carefully before sharing the URL.\"\n        ;;\n      *)\n        log \"Publicly available log not generated.\"\n        ;;\n    esac\n  fi\n  # The following is not in the web log file since it was copied above, which seems correct\n  log\n  log \"You can examine the output of this script with \"\n  log \"LESS=-Ri less $LOG_FILE\"\n  log\n  log \"BUT FIRST, make sure that you know the first three commands below!!!\"\n  log\n  log \"Commands to know when viewing the file with the above command (called 'less'): \"\n  log \"q              -- quit\"\n  log \"/error<ENTER>  -- search for the word 'error'\"\n  log \"n              -- search for the next occurrence\"\n  log \"g              -- go to the beginning of the file\"\n  log \"f              -- go forward a page\"\n  log \"b              -- go back a page\"\n  log \"G              -- go to the end of the file\"\n}\n\ninitialize_log_file() {\n  rm -f $LOG_FILE\n  touch $LOG_FILE\n  log DISCOURSE DOCTOR $(date)\n  log -e \"OS: $(uname -a)\\n\\n\"\n}\n\n##\n## END FUNCTION DECLARATION\n##\n\ncheck_root\ncd $WORKING_DIR || exit\ninitialize_log_file\nget_yml_file\nget_discourse_config\ncheck_docker_is_installed\ncheck_docker\ncheck_plugins\ncheck_if_hostname_resolves_here\ncheck_disk_and_memory\ncheck_email\nclean_up_log_file\nprint_done\n"
        },
        {
          "name": "discourse-setup",
          "type": "blob",
          "size": 28.0419921875,
          "content": "#!/usr/bin/env bash\nexport LC_ALL=C  # lscpu output is localized.\n\nDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\ncd $DIR\n\nif [ \"$1\" == \"2container\" ]\nthen\n  TWO_CONTAINER=\"1\"\n  echo \"2container argument is deprecated. Use --two-container\"\n  shift 1\nfi\n\nwhile [ ${#} -gt 0 ]; do\n  case \"${1}\" in\n  --debug)\n    DEBUG=\"1\"\n    SKIP_REBUILD=\"1\"\n    ;;\n  --skip-rebuild)\n    SKIP_REBUILD=\"1\"\n    ;;\n  --two-container)\n    TWO_CONTAINER=\"1\"\n    ;;\n  --skip-connection-test)\n    SKIP_CONNECTION_TEST=\"1\"\n    echo \"skipping connection test\"\n    ;;\n  esac\n\n  shift 1\ndone\n\n##\n## Make sure only root can run our script\n##\ncheck_root() {\n  if [[ $EUID -ne 0 ]]; then\n    echo \"This script must be run as root. Please sudo or log in as root first.\" 1>&2\n    exit 1\n  fi\n}\n\n##\n## Check whether a connection to HOSTNAME ($1) on PORT ($2) is possible\n##\nconnect_to_port () {\n  HOST=\"$1\"\n  PORT=\"$2\"\n  VERIFY=$(date +%s | sha256sum | base64 | head -c 20)\n  if ! [ -x \"$(command -v nc)\" ]; then\n    echo \"In order to check the connection to $HOST:$PORT we need to open a socket using netcat.\"\n    echo However netcat is not installed on your system. You can continue without this check\n    echo or abort the setup, install netcat and try again.\n    while true; do\n      read -p \"Would you like to continue without this check? [yn] \" yn\n      case $yn in\n        [Yy]*) return 2 ;;\n        [Nn]*) exit ;;\n        *) echo \"Please answer y or n.\" ;;\n      esac\n    done\n  else\n    echo -e \"HTTP/1.1 200 OK\\n\\n $VERIFY\" | nc -w 4 -l -p $PORT >/dev/null 2>&1 &\n    if curl --proto =http -s $HOST:$PORT --connect-timeout 3 | grep $VERIFY >/dev/null 2>&1; then\n      return 0\n    else\n      curl --proto =http -s localhost:$PORT >/dev/null 2>&1\n      return 1\n    fi\n  fi\n}\n\ncheck_IP_match() {\n  HOST=\"$1\"\n  echo\n  if [ \"$SKIP_CONNECTION_TEST\" == 1 ]\n  then\n    echo \"Setting EC to 2\"\n    ec=2\n  else\n    echo Checking your domain name . . .\n    connect_to_port $HOST 443; ec=$?\n  fi\n  case $ec in\n    0)\n      echo \"Connection to $HOST succeeded.\"\n      ;;\n    1)\n      echo \"WARNING: Port 443 of computer does not appear to be accessible using hostname:  $HOST.\"\n      if connect_to_port $HOST 80; then\n        echo\n        echo SUCCESS: A connection to port 80 succeeds!\n        echo This suggests that your DNS settings are correct,\n        echo but something is keeping traffic to port 443 from getting to your server.\n        echo Check your networking configuration to see that connections to port 443 are allowed.\n      else\n        echo \"WARNING: Connection to http://$HOST (port 80) also fails.\"\n        echo\n        echo \"This suggests that $HOST resolves to some IP address that does not reach this \"\n        echo machine where you are installing discourse.\n      fi\n      echo\n      echo \"The first thing to do is confirm that $HOST resolves to the IP address of this server.\"\n      echo You usually do this at the same place you purchased the domain.\n      echo\n      echo If you are sure that the IP address resolves correctly, it could be a firewall issue.\n      echo A web search for  \\\"open ports YOUR CLOUD SERVICE\\\" might help.\n      echo\n      echo This tool is designed only for the most standard installations. If you cannot resolve\n      echo the issue above, you will need to edit containers/app.yml yourself and then type\n      echo\n      echo                   ./launcher rebuild app\n      echo\n      exit 1\n      ;;\n    2)\n      echo \"Skipping port check.\"\n      ;;\n  esac\n}\n\n##\n## Do we have docker?\n##\n\ncheck_docker() {\n  (which docker || which docker.io) &>/dev/null\n}\n\ncheck_and_install_docker() {\n  if ! check_docker; then\n    echo Failed to find docker or docker.io on your PATH.\n    read -p \"Enter to install Docker from https://get.docker.com/ or Ctrl+C to exit\"\n    curl https://get.docker.com/ | sh\n\n    if ! check_docker; then\n      echo Still failed to find docker or docker.io on your PATH.\n      echo Docker install failed. Quitting.\n      exit\n    fi\n  fi\n}\n\n##\n## What are we running on\n##\ncheck_OS() {\n  echo `uname -s`\n}\n\n##\n## macOS available memory\n##\ncheck_macos_memory() {\n  echo $(($(memory_pressure | head -n 1 | awk '{ print $4 }') / 1024 / 1024 / 1024))\n}\n\n##\n## Linux available memory\n##\ncheck_linux_memory() {\n  ## some VMs report just under 1GB of RAM, so\n  ## make an exception and allow those with more\n  ## than 989MB\n  mem=`free -m --si | awk ' /Mem:/ {print $2}'`\n  if [ \"$mem\" -ge 990 -a \"$mem\" -lt 1000 ]; then\n    echo 1\n  else\n    echo `free -g --si | awk ' /Mem:/  {print $2} '`\n  fi\n}\n\n##\n## Do we have enough memory and disk space for Discourse?\n##\ncheck_disk_and_memory() {\n  os_type=$(check_OS)\n  avail_mem=0\n  if [ \"$os_type\" == \"Darwin\" ]; then\n    avail_mem=$(check_macos_memory)\n  else\n    avail_mem=$(check_linux_memory)\n  fi\n\n  if [ \"$avail_mem\" -lt 1 ]; then\n    echo \"WARNING: Discourse requires 1GB RAM to run. This system does not appear\"\n    echo \"to have sufficient memory.\"\n    echo\n    echo \"Your site may not work properly, or future upgrades of Discourse may not\"\n    echo \"complete successfully.\"\n    exit 1\n  fi\n\n  if [ \"$avail_mem\" -le 2 ]; then\n    total_swap=`free -g --si | awk ' /Swap:/  {print $2} '`\n\n    if [ \"$total_swap\" -lt 2 ]; then\n      echo \"WARNING: Discourse requires at least 2GB of swap when running with 2GB of RAM\"\n      echo \"or less. This system does not appear to have sufficient swap space.\"\n      echo\n      echo \"Without sufficient swap space, your site may not work properly, and future\"\n      echo \"upgrades of Discourse may not complete successfully.\"\n      echo\n      echo \"Ctrl+C to exit or wait 5 seconds to have a 2GB swapfile created.\"\n      sleep 5\n\n      ##\n      ## derived from https://meta.discourse.org/t/13880\n      ##\n      install -o root -g root -m 0600 /dev/null /swapfile\n      fallocate -l 2G /swapfile\n      mkswap /swapfile\n      swapon /swapfile\n      echo \"/swapfile       swap    swap    auto      0       0\" | tee -a /etc/fstab\n      sysctl -w vm.swappiness=10\n      echo 'vm.swappiness = 10' > /etc/sysctl.d/30-discourse-swap.conf\n\n      total_swap=`free -g --si | awk ' /Swap:/ {print $2} '`\n      if [ \"$total_swap\" -lt 2 ]; then\n        echo \"Failed to create swap: are you root? Are you running on real hardware, or a fully virtualized server?\"\n        exit 1\n      fi\n\n    fi\n  fi\n\n  free_disk=\"$(df /var | tail -n 1 | awk '{print $4}')\"\n  if [ \"$free_disk\" -lt 5000 ]; then\n    echo \"WARNING: Discourse requires at least 5GB free disk space. This system\"\n    echo \"does not appear to have sufficient disk space.\"\n    echo\n    echo \"Insufficient disk space may result in problems running your site, and\"\n    echo \"may not even allow Discourse installation to complete successfully.\"\n    echo\n    echo \"Please free up some space, or expand your disk, before continuing.\"\n    echo\n    echo \"Run \\`apt-get autoremove && apt-get autoclean\\` to clean up unused\"\n    echo \"packages and \\`./launcher cleanup\\` to remove stale Docker containers.\"\n    exit 1\n  fi\n\n}\n\n\n##\n## If we have lots of RAM or lots of CPUs, bump up the defaults to scale better\n##\nscale_ram_and_cpu() {\n\n  local changelog=/tmp/changelog.$PPID\n  # grab info about total system ram and physical (NOT LOGICAL!) CPU cores\n  avail_gb=0\n  avail_cores=0\n  os_type=$(check_OS)\n  if [ \"$os_type\" == \"Darwin\" ]; then\n    avail_gb=$(check_macos_memory)\n    avail_cores=`sysctl hw.ncpu | awk '/hw.ncpu:/ {print $2}'`\n  else\n    avail_gb=$(check_linux_memory)\n    threads_per_core=$(lscpu | awk 'BEGIN {FS=\":\"} /Thread\\(s\\) per core/ {print $2}')\n    avail_cores=$((`lscpu | awk '/^CPU\\(s\\):[[:blank:]]+[0-9]+[[:blank:]]*$/ {print $2; exit}'`*${threads_per_core}))\n  fi\n  echo \"Found ${avail_gb}GB of memory and $avail_cores physical CPU cores\"\n\n  # db_shared_buffers: 128MB for 1GB, 256MB for 2GB, or 256MB * GB, max 4096MB\n  if [ \"$avail_gb\" -eq \"1\" ]\n  then\n    db_shared_buffers=128\n  else\n    if [ \"$avail_gb\" -eq \"2\" ]\n    then\n      db_shared_buffers=256\n    else\n      db_shared_buffers=$(( 256 * $avail_gb ))\n    fi\n  fi\n  db_shared_buffers=$(( db_shared_buffers < 4096 ? db_shared_buffers : 4096 ))\n\n  sed -i -e \"s/^  #\\?db_shared_buffers:.*/  db_shared_buffers: \\\"${db_shared_buffers}MB\\\"/w $changelog\" $data_file\n  if [ -s $changelog ]\n  then\n    echo \"setting db_shared_buffers = ${db_shared_buffers}MB\"\n    rm $changelog\n  fi\n\n  # UNICORN_WORKERS: 2 * GB for 2GB or less, or 2 * CPU, max 8\n  if [ \"$avail_gb\" -le \"2\" ]\n  then\n    unicorn_workers=$(( 2 * $avail_gb ))\n  else\n    unicorn_workers=$(( 2 * $avail_cores ))\n  fi\n  unicorn_workers=$(( unicorn_workers < 8 ? unicorn_workers : 8 ))\n\n  sed -i -e \"s/^  #\\?UNICORN_WORKERS:.*/  UNICORN_WORKERS: ${unicorn_workers}/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    echo \"setting UNICORN_WORKERS = ${unicorn_workers}\"\n    rm $changelog\n  fi\n\n  echo $data_file memory parameters updated.\n}\n\n\n##\n## standard http / https ports must not be occupied\n##\ncheck_ports() {\n  check_port \"80\"\n  check_port \"443\"\n  echo \"Ports 80 and 443 are free for use\"\n}\n\n\n##\n## check a port to see if it is already in use\n##\ncheck_port() {\n\n  local valid=$(lsof -i:${1} | grep \"LISTEN\")\n\n  if [ -n \"$valid\" ]; then\n    echo \"Port ${1} appears to already be in use.\"\n    echo\n    echo \"This will show you what command is using port ${1}\"\n    lsof -i tcp:${1} -s tcp:listen\n    echo\n    echo \"If you are trying to run Discourse simultaneously with another web\"\n    echo \"server like Apache or nginx, you will need to bind to a different port\"\n    echo\n    echo \"See https://meta.discourse.org/t/17247\"\n    echo\n    echo \"If you are reconfiguring an already-configured Discourse, use \"\n    echo\n    echo \"./launcher stop app\"\n    echo\n    echo \"to stop Discourse before you reconfigure it and try again.\"\n    exit 1\n  fi\n}\n\n##\n## read a variable from the config file\n##\nread_config() {\n  config_line=`grep -E \"^  #?$1:\" $web_file`\n  read_config_result=`echo $config_line | awk  -F\":\" '{print $2}'`\n  read_config_result=`echo $read_config_result | sed \"s/^\\([\\\"']\\)\\(.*\\)\\1\\$/\\2/g\"`\n}\n\nread_default() {\n  config_line=`grep -E \"^  #?$1:\" samples/standalone.yml`\n  read_default_result=`echo $config_line | awk  -F\":\" '{print $2}'`\n  read_default_result=`echo $read_config_result | sed \"s/^\\([\\\"']\\)\\(.*\\)\\1\\$/\\2/g\"`\n}\n\nassert_maxmind_envs() {\n  if  ! grep DISCOURSE_MAXMIND_LICENSE_KEY $web_file >/dev/null 2>&1\n  then\n    echo \"Adding MAXMIND_LICENSE_KEY placeholder to $web_file\"\n    sed -i '/^.*LETSENCRYPT_ACCOUNT_EMAIL.*/a \\ \\ #DISCOURSE_MAXMIND_LICENSE_KEY: 1234567890123456' $web_file\n  fi\n\n  if  ! grep DISCOURSE_MAXMIND_ACCOUNT_ID $web_file >/dev/null 2>&1\n  then\n    echo \"Adding MAXMIND_ACCOUNT_ID placeholder to $web_file\"\n    sed -i '/^.*LETSENCRYPT_ACCOUNT_EMAIL.*/a \\ \\ #DISCOURSE_MAXMIND_ACCOUNT_ID: 123456' $web_file\n  fi\n\n\n  if ! grep -e DISCOURSE_MAXMIND_LICENSE_KEY -e DISCOURSE_MAXMIND_ACCOUNT_ID $web_file >/dev/null 2>&1\n  then\n    cat <<EOF\n\n    Adding DISCOURSE_MAXMIND_ACCOUNT_ID and DISCOURSE_MAXMIND_LICENSE_KEY to\n    $web_file has failed! This indicates either that your $web_file is very\n    old or otherwise not what the script expects or that there is a bug in\n    this script. The best solution for a novice is to delete $web_file and\n    start over. An expert might prefer to edit $web_file by hand.\n\nEOF\n    read -p \"Press return to continue or control-c to quit...\"\n  fi\n}\n\nassert_smtp_domain() {\n  if  ! grep DISCOURSE_SMTP_DOMAIN $web_file >/dev/null 2>&1\n  then\n    echo \"Adding SMTP_DOMAIN placeholder to $web_file\"\n    sed -i '/^.*DISCOURSE_SMTP_PASSWORD.*/a \\ \\ #DISCOURSE_SMTP_DOMAIN: discourse.example.com    # (required by some providers)' $web_file\n  fi\n  if  ! grep DISCOURSE_SMTP_DOMAIN $web_file >/dev/null 2>&1\n  then\n    cat <<EOF\n\n    Adding DISCOURSE_SMTP_DOMAIN to $web_file has failed! This\n    indicates either that your $web_file is very old or otherwise not\n    what the script expects or that there is a bug in this script. The\n    best solution for a novice is to delete $web_file and start over.\n    An expert might prefer to edit $web_file by hand.\n\nEOF\n    read -p \"Press return to continue or control-c to quit...\"\n  fi\n}\n\n\nassert_notification_email() {\n  if  ! grep DISCOURSE_NOTIFICATION_EMAIL $web_file >/dev/null 2>&1\n  then\n    echo \"Adding DISCOURSE_NOTIFICATION_EMAIL placeholder to $web_file\"\n    sed -i '/^.*DISCOURSE_SMTP_PASSWORD.*/a \\ \\ #DISCOURSE_NOTIFICATION_EMAIL: nobody@discourse.example.com    # (address to send notifications from)' $web_file\n  fi\n  if  ! grep DISCOURSE_NOTIFICATION_EMAIL $web_file >/dev/null 2>&1\n  then\n    cat <<EOF\n\n    Adding DISCOURSE_NOTIFICATION_EMAIL to $web_file has failed! This\n    indicates either that your $web_file is very old or otherwise not\n    what the script expects or that there is a bug in this script. The\n    best solution for a novice is to delete $web_file and start over.\n    An expert might prefer to edit $web_file by hand.\n\nEOF\n    read -p \"Press return to continue or control-c to quit...\"\n  fi\n}\n\n\n##\n## prompt user for typical Discourse config file values\n##\nask_user_for_config() {\n\n  # NOTE: Defaults now come from standalone.yml\n\n  read_config \"DISCOURSE_HOSTNAME\"\n  hostname=$read_config_result\n  local changelog=/tmp/changelog.$PPID\n  read_config \"DISCOURSE_SMTP_ADDRESS\"\n  local smtp_address=$read_config_result\n  # NOTE: if there are spaces between emails, this breaks, but a human should be paying attention\n  read_config \"DISCOURSE_DEVELOPER_EMAILS\"\n  local developer_emails=$read_config_result\n  read_config \"DISCOURSE_SMTP_PASSWORD\"\n  local smtp_password=$read_config_result\n  read_config \"DISCOURSE_SMTP_PORT\"\n  local smtp_port=$read_config_result\n  read_config \"DISCOURSE_SMTP_USER_NAME\"\n  local smtp_user_name=$read_config_result\n  if [ \"$smtp_password\" = \"pa\\$\\$word\" ]\n  then\n    smtp_password=\"\"\n  fi\n  read_config \"DISCOURSE_NOTIFICATION_EMAIL\"\n  local notification_email=$read_config_result\n  read_config \"DISCOURSE_SMTP_DOMAIN\"\n  local discourse_smtp_domain=$read_config_result\n\n  read_config \"LETSENCRYPT_ACCOUNT_EMAIL\"\n  local letsencrypt_account_email=$read_config_result\n  if [ -z $letsencrypt_account_email ]\n  then\n    letsencrypt_account_email=\"me@example.com\"\n  fi\n  if [ \"$letsencrypt_account_email\" = \"me@example.com\" ]\n  then\n    local letsencrypt_status=\"ENTER to skip\"\n  else\n    local letsencrypt_status=\"Enter 'OFF' to disable.\"\n  fi\n\n  read_config \"DISCOURSE_MAXMIND_ACCOUNT_ID\"\n  local maxmind_account_id=$read_config_result\n  if [ -z $maxmind_account_id ]\n  then\n    maxmind_account_id=\"123456\"\n  fi\n\n  if [ \"$maxmind_account_id\" == \"123456\" ]\n  then\n    local maxmind_status=\"ENTER to continue without MAXMIND GeoLite2 geolocation database\"\n  fi\n\n  read_config \"DISCOURSE_MAXMIND_LICENSE_KEY\"\n  local maxmind_license_key=$read_config_result\n  if [ -z $maxmind_license_key ]\n  then\n    maxmind_license_key=\"1234567890123456\"\n  fi\n\n  local new_value=\"\"\n  local config_ok=\"n\"\n  local update_ok=\"y\"\n\n  echo \"\"\n\n  while [[ \"$config_ok\" == \"n\" ]]\n  do\n    if [ ! -z \"$hostname\" ]\n    then\n      read -p \"Hostname for your Discourse? [$hostname]: \" new_value\n      if [ ! -z \"$new_value\" ]\n      then\n        hostname=\"$new_value\"\n      fi\n      if [[ $hostname =~ ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$ ]]\n      then\n        echo\n        echo \"Discourse requires a DNS hostname. IP addresses are unsupported and will not work.\"\n        echo\n        hostname=\"discourse.example.com\"\n      fi\n    fi\n\n    check_IP_match $hostname\n\n    if [ ! -z \"$developer_emails\" ]\n    then\n      local email_valid=\"n\"\n      until [ \"$email_valid\" == \"y\" ]\n      do\n        read -p \"Email address for admin account(s)? [$developer_emails]: \" new_value\n        if [ ! -z \"$new_value\" ]\n        then\n          if [[ ${#new_value} -ge 7 && $new_value == *@* ]]\n          then\n            developer_emails=\"$new_value\"\n            email_valid=\"y\"\n          else\n            echo\n            echo \"[Error] Invalid email address\"\n            echo\n          fi\n        else\n          email_valid=\"y\"\n        fi\n      done\n    fi\n\n    if [ ! -z \"$smtp_address\" ]\n    then\n      read -p \"SMTP server address? [$smtp_address]: \" new_value\n      if [ ! -z \"$new_value\" ]\n      then\n        smtp_address=\"$new_value\"\n      fi\n    fi\n\n    if [ ! -z \"$smtp_port\" ]\n    then\n      read -p \"SMTP port? [$smtp_port]: \" new_value\n      if [ ! -z \"$new_value\" ]\n      then\n        smtp_port=\"$new_value\"\n      fi\n    fi\n\n    ##\n    ## automatically set correct user name based on common mail providers unless it's been set\n    ##\n    if [ \"$smtp_user_name\" == \"user@example.com\" ]\n    then\n      if [ \"$smtp_address\" == \"smtp.sparkpostmail.com\" ]\n      then\n        smtp_user_name=\"SMTP_Injection\"\n      fi\n      if [ \"$smtp_address\" == \"smtp.sendgrid.net\" ]\n      then\n        smtp_user_name=\"apikey\"\n      fi\n      if [ \"$smtp_address\" == \"smtp.mailgun.org\" ]\n      then\n        smtp_user_name=\"postmaster@$hostname\"\n      fi\n    fi\n\n    if [ ! -z \"$smtp_user_name\" ]\n    then\n      read -p \"SMTP user name? [$smtp_user_name]: \" new_value\n      if [ ! -z \"$new_value\" ]\n      then\n        smtp_user_name=\"$new_value\"\n      fi\n    fi\n\n    read -p \"SMTP password? [$smtp_password]: \" new_value\n    if [ ! -z \"$new_value\" ]\n    then\n      smtp_password=\"$new_value\"\n    fi\n\n    if [[ \"$notification_email\" == \"noreply@discourse.example.com\"* ]]\n    then\n      notification_email=\"noreply@$hostname\"\n    fi\n\n    read -p \"notification email address? [$notification_email]: \" new_value\n    if [ ! -z \"$new_value\" ]\n    then\n      notification_email=\"$new_value\"\n    fi\n\n    # set smtp_domain default value here rather than use Rails default of localhost\n    default_smtp_domain=${notification_email#*@}\n    # if DISCOURSE_SMTP_DOMAIN is in the config use that instead\n    smtp_domain=${discourse_smtp_domain:-${default_smtp_domain}}\n\n    if [ ! -z $letsencrypt_account_email ]\n    then\n      read -p \"Optional email address for Let's Encrypt warnings? ($letsencrypt_status) [$letsencrypt_account_email]: \" new_value\n      if [ ! -z \"$new_value\" ]\n      then\n        letsencrypt_account_email=\"$new_value\"\n        if [ \"${new_value,,}\" = \"off\" ]\n        then\n          letsencrypt_status=\"ENTER to skip\"\n        else\n          letsencrypt_status=\"Enter 'OFF' to disable.\"\n        fi\n      fi\n    fi\n\n    read_config \"DISCOURSE_MAXMIND_ACCOUNT_ID\"\n    local maxmind_account_id=$read_config_result\n    read -p \"Optional MaxMind Account ID ($maxmind_status) [$maxmind_account_id]: \" new_value\n    if [ ! -z \"$new_value\" ]\n    then\n      maxmind_account_id=\"$new_value\"\n\n      read_config \"DISCOURSE_MAXMIND_LICENSE_KEY\"\n      local maxmind_license_key=$read_config_result\n      read -p \"MaxMind License key [$maxmind_license_key]: \" new_value\n\n      if [ ! -z \"$new_value\" ]\n      then\n        maxmind_license_key=\"$new_value\"\n      fi\n    fi\n\n    echo -e \"\\nDoes this look right?\\n\"\n    echo \"Hostname          : $hostname\"\n    echo \"Email             : $developer_emails\"\n    echo \"SMTP address      : $smtp_address\"\n    echo \"SMTP port         : $smtp_port\"\n    echo \"SMTP username     : $smtp_user_name\"\n    echo \"SMTP password     : $smtp_password\"\n    echo \"Notification email: $notification_email\"\n\n    if [ \"$letsencrypt_status\" == \"Enter 'OFF' to disable.\" ]\n    then\n      echo \"Let's Encrypt : $letsencrypt_account_email\"\n    fi\n\n    if [ \"$maxmind_account_id\" != \"123456\" ]\n    then\n      echo \"MaxMind account ID: $maxmind_account_id\"\n    else\n      echo \"MaxMind account ID: (unset)\"\n    fi\n\n    if [ \"$maxmind_license_key\" != \"1234567890123456\" ]\n    then\n      echo \"MaxMind license key: $maxmind_license_key\"\n    else\n      echo \"MaxMind license key: (unset)\"\n    fi\n\n    echo \"\"\n    read -p \"ENTER to continue, 'n' to try again, Ctrl+C to exit: \" config_ok\n  done\n\n  sed -i -e \"s/^  DISCOURSE_HOSTNAME:.*/  DISCOURSE_HOSTNAME: $hostname/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_HOSTNAME change failed.\"\n    update_ok=\"n\"\n  fi\n\n  sed -i -e \"s/^  DISCOURSE_DEVELOPER_EMAILS:.*/  DISCOURSE_DEVELOPER_EMAILS: \\'$developer_emails\\'/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_DEVELOPER_EMAILS change failed.\"\n    update_ok=\"n\"\n  fi\n\n  sed -i -e \"s/^  DISCOURSE_SMTP_ADDRESS:.*/  DISCOURSE_SMTP_ADDRESS: $smtp_address/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_SMTP_ADDRESS change failed.\"\n    update_ok=\"n\"\n  fi\n\n  sed -i -e \"s/^  #\\?DISCOURSE_SMTP_PORT:.*/  DISCOURSE_SMTP_PORT: $smtp_port/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_SMTP_PORT change failed.\"\n    update_ok=\"n\"\n  fi\n\n  sed -i -e \"s/^  #\\?DISCOURSE_SMTP_USER_NAME:.*/  DISCOURSE_SMTP_USER_NAME: $smtp_user_name/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_SMTP_USER_NAME change failed.\"\n    update_ok=\"n\"\n  fi\n\n  sed -i -e \"s/^  #\\?DISCOURSE_NOTIFICATION_EMAIL:.*/  DISCOURSE_NOTIFICATION_EMAIL: $notification_email/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_NOTIFICATION_EMAIL change failed.\"\n    update_ok=\"n\"\n  fi\n\n  sed -i -e \"s/^  #\\?DISCOURSE_SMTP_DOMAIN:.*/  DISCOURSE_SMTP_DOMAIN: $smtp_domain/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"DISCOURSE_SMTP_DOMAIN change failed.\"\n    update_ok=\"n\"\n  fi\n\n  if [[ \"$smtp_password\" == *\"\\\"\"* ]]\n  then\n    SLASH=\"BROKEN\"\n    echo \"========================================\"\n    echo \"WARNING!!!\"\n    echo \"Your password contains a quote (\\\")\"\n    echo \"Your SMTP Password will not be set. You will need to edit app.yml to enter it.\"\n    echo \"========================================\"\n    update_ok=\"n\"\n  else\n    SLASH=\"|\"\n    if [[ \"$smtp_password\" == *\"$SLASH\"* ]]\n    then SLASH=\"+\"\n         if [[ \"$smtp_password\" == *\"$SLASH\"* ]]\n         then\n           SLASH=\"Q\"\n           if [[ \"$smtp_password\" == *\"$SLASH\"* ]]\n           then\n             SLASH=\"BROKEN\"\n             echo \"========================================\"\n             echo \"WARNING!!!\"\n             echo \"Your password contains all available delimiters (+, |, and Q). \"\n             echo \"Your SMTP Password will not be set. You will need to edit app.yml to enter it.\"\n             echo \"========================================\"\n             update_ok=\"n\"\n           fi\n         fi\n    fi\n  fi\n  if [[ \"$SLASH\" != \"BROKEN\" ]]\n  then\n    sed -i -e \"s${SLASH}^  #\\?DISCOURSE_SMTP_PASSWORD:.*${SLASH}  DISCOURSE_SMTP_PASSWORD: \\\"${smtp_password}\\\"${SLASH}w $changelog\" $web_file\n\n    if [ -s $changelog ]\n    then\n      rm $changelog\n    else\n      echo \"DISCOURSE_SMTP_PASSWORD change failed.\"\n      update_ok=\"n\"\n    fi\n  fi\n\n  if ! [ -z $DEBUG ]\n  then\n    echo \"Enabling Let's Encrypt\"\n  fi\n  sed -i -e \"s/^  #\\?LETSENCRYPT_ACCOUNT_EMAIL:.*/  LETSENCRYPT_ACCOUNT_EMAIL: $letsencrypt_account_email/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    rm $changelog\n  else\n    echo \"LETSENCRYPT_ACCOUNT_EMAIL change failed.\"\n    update_ok=\"n\"\n  fi\n  local src='^  #\\?- \"templates\\/web.ssl.template.yml\"'\n  local dst='  \\- \"templates\\/web.ssl.template.yml\"'\n  sed -i -e \"s/$src/$dst/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n  if ! [ -z $DEBUG ]\n    then\n      echo \"web.ssl.template.yml enabled\"\n    fi\n  else\n    update_ok=\"n\"\n    echo \"web.ssl.template.yml NOT ENABLED--was it on already?\"\n  fi\n  local src='^  #\\?- \"templates\\/web.letsencrypt.ssl.template.yml\"'\n  local dst='  - \"templates\\/web.letsencrypt.ssl.template.yml\"'\n\n  sed -i -e \"s/$src/$dst/w $changelog\" $web_file\n  if [ -s $changelog ]\n  then\n    echo \"letsencrypt.ssl.template.yml enabled\"\n  else\n    update_ok=\"n\"\n    echo \"letsencrypt.ssl.template.yml NOT ENABLED -- was it on already?\"\n  fi\n\n  echo\n\n  if [ $maxmind_account_id != \"123456\" ]\n  then\n    sed -i -e \"s/^.*DISCOURSE_MAXMIND_ACCOUNT_ID:.*/  DISCOURSE_MAXMIND_ACCOUNT_ID: $maxmind_account_id/w $changelog\" $web_file\n    if [ -s $changelog ]\n    then\n      rm $changelog\n    else\n      echo \"DISCOURSE_MAXMIND_ACCOUNT_ID change failed.\"\n      update_ok=\"n\"\n    fi\n  fi\n\n  if [ $maxmind_license_key != \"1234567890123456\" ]\n  then\n    sed -i -e \"s/^.*DISCOURSE_MAXMIND_LICENSE_KEY:.*/  DISCOURSE_MAXMIND_LICENSE_KEY: $maxmind_license_key/w $changelog\" $web_file\n    if [ -s $changelog ]\n    then\n      rm $changelog\n    else\n      echo \"DISCOURSE_MAXMIND_LICENSE_KEY change failed.\"\n      update_ok=\"n\"\n    fi\n  fi\n\n  if [ \"$update_ok\" == \"y\" ]\n  then\n    echo -e \"\\nConfiguration file at $web_file updated successfully!\\n\"\n  else\n    echo -e \"\\nUnfortunately, there was an error changing $web_file\\n\"\n    echo -e \"This may happen if you have made unexpected changes.\"\n    exit 1\n  fi\n}\n\n##\n## is our config file valid? Does it have the required fields set?\n##\nvalidate_config() {\n\n  valid_config=\"y\"\n\n  for x in DISCOURSE_SMTP_ADDRESS DISCOURSE_SMTP_USER_NAME DISCOURSE_SMTP_PASSWORD \\\n                                  DISCOURSE_DEVELOPER_EMAILS DISCOURSE_HOSTNAME\n  do\n    read_config $x\n    local result=$read_config_result\n    read_default $x\n    local default=$read_default_result\n\n    if [ ! -z \"$result\" ]\n    then\n      if [[ \"$config_line\" = *\"$default\"* ]]\n      then\n        echo \"$x left at incorrect default of $default\"\n        valid_config=\"n\"\n      fi\n      config_val=`echo $config_line | awk '{print $2}'`\n      if [ -z $config_val ]\n      then\n        echo \"$x was not configured\"\n        valid_config=\"n\"\n      fi\n    else\n      echo \"$x not present\"\n      valid_config=\"n\"\n    fi\n  done\n\n  if [ \"$valid_config\" != \"y\" ]; then\n    echo -e \"\\nSorry, these $web_file settings aren't valid -- can't continue!\"\n    echo \"If you have unusual requirements, edit $web_file and then: \"\n    echo \"./launcher bootstrap $app_name\"\n    exit 1\n  fi\n}\n\n\n##\n## template file names\n##\n\nif [ \"$TWO_CONTAINER\" ] || [ -f containers/web_only.yml ]\nthen\n  app_name=web_only\n  data_name=data\n  web_template=samples/web_only.yml\n  data_template=samples/data.yml\n  web_file=containers/$app_name.yml\n  data_file=containers/$data_name.yml\nelse\n  app_name=app\n  data_name=app\n  web_template=samples/standalone.yml\n  data_template=\"\"\n  web_file=containers/$app_name.yml\n  data_file=containers/$app_name.yml\nfi\nchangelog=/tmp/changelog\n\n##\n## Check requirements before creating a copy of a config file we won't edit\n##\ncheck_root\ncheck_and_install_docker\ncheck_disk_and_memory\n\nif [ -a \"$web_file\" ]\nthen\n  echo \"The configuration file $web_file already exists!\"\n  echo\n  echo \". . . reconfiguring . . .\"\n  echo\n  echo\n  DATE=`date +\"%Y-%m-%d-%H%M%S\"`\n  BACKUP=$app_name.yml.$DATE.bak\n  echo Saving old file as $BACKUP\n  install -m0600 $web_file containers/$BACKUP\n  if [ \"$DEBUG\" != \"1\" ]\n  then\n    echo \"Stopping existing container in 5 seconds or Control-C to cancel.\"\n    sleep 5\n    ./launcher stop $app_name\n  else\n    echo \"DEBUG MODE ON. Not stopping the container.\"\n  fi\n  assert_maxmind_envs\n  assert_notification_email\n  assert_smtp_domain\n  echo\nelse\n  if [ \"$SKIP_CONNECTION_TEST\" != 1 ]\n  then\n    check_ports\n  fi\n  install -v -m0600 $web_template $web_file\n  if [ \"$data_name\" == \"data\" ]\n  then\n    echo \"--------------------------------------------------\"\n    echo \"This two container setup is currently unsupported. Use at your own risk!\"\n    echo \"--------------------------------------------------\"\n    DISCOURSE_DB_PASSWORD=`date +%s | sha256sum | base64 | head -c 20`\n\n    sed -i -e \"s/DISCOURSE_DB_PASSWORD: SOME_SECRET/DISCOURSE_DB_PASSWORD: $DISCOURSE_DB_PASSWORD/w $changelog\" $web_file\n    if  [ -s $changelog ]\n    then\n      rm $changelog\n    else\n      echo \"Problem changing DISCOURSE_DB_PASSWORD\" in $web_file\n    fi\n\n    install -v -m0600 $data_template $data_file\n    quote=\\'\n    sed -i -e \"s/password ${quote}SOME_SECRET${quote}/password '$DISCOURSE_DB_PASSWORD'/w $changelog\" $data_file\n    if  [ -s $changelog ]\n    then\n      rm $changelog\n    else\n      echo \"Problem changing DISCOURSE_DB_PASSWORD\" in $data_file\n    fi\n  fi\nfi\n\nscale_ram_and_cpu\nask_user_for_config\nvalidate_config\n\n##\n## if we reach this point without exiting, OK to proceed\n## rebuild won't fail if there's nothing to rebuild and does the restart\n##\nif [ \"$SKIP_REBUILD\" ]\nthen\n  echo \"Updates successful. --skip-rebuild requested. Exiting.\"\n  exit\nfi\n\necho \"Updates successful. Rebuilding in 5 seconds.\"\nsleep 5 # Just a chance to ^C in case they were too fast on the draw\n\nif [ \"$data_name\" == \"$app_name\" ]\nthen\n  echo Building $app_name\n  ./launcher rebuild $app_name\nelse\n  echo Building $data_name now . . .\n  ./launcher rebuild $data_name\n  echo Building $app_name now . . .\n  ./launcher rebuild $app_name\nfi\n"
        },
        {
          "name": "image",
          "type": "tree",
          "content": null
        },
        {
          "name": "launcher",
          "type": "blob",
          "size": 23.5751953125,
          "content": "#!/usr/bin/env bash\n\nusage () {\n  echo \"Usage: launcher COMMAND CONFIG [--skip-prereqs] [--docker-args STRING]\"\n  echo \"Commands:\"\n  echo \"    start:       Start/initialize a container\"\n  echo \"    stop:        Stop a running container\"\n  echo \"    restart:     Restart a container\"\n  echo \"    destroy:     Stop and remove a container\"\n  echo \"    enter:       Open a shell to run commands inside the container\"\n  echo \"    logs:        View the Docker logs for a container\"\n  echo \"    bootstrap:   Bootstrap a container for the config based on a template\"\n  echo \"    run:         Run the given command with the config in the context of the last bootstrapped image\"\n  echo \"    rebuild:     Rebuild a container (destroy old, bootstrap, start new)\"\n  echo \"    cleanup:     Remove all containers that have stopped for > 24 hours\"\n  echo \"    start-cmd:   Generate docker command used to start container\"\n  echo\n  echo \"Options:\"\n  echo \"    --skip-prereqs             Don't check launcher prerequisites\"\n  echo \"    --docker-args              Extra arguments to pass when running docker\"\n  echo \"    --skip-mac-address         Don't assign a mac address\"\n  echo \"    --run-image                Override the image used for running the container\"\n  exit 1\n}\n\n# for potential re-exec later\nSAVED_ARGV=(\"$@\")\n\ncommand=$1\nconfig=$2\n\n# user_args_argv is assigned once when the argument vector is parsed.\nuser_args_argv=\"\"\n# user_args is mutable:  its value may change when templates are parsed.\n# Superset of user_args_argv.\nuser_args=\"\"\n\nuser_run_image=\"\"\n\nif [[ $command == \"run\" ]]; then\n  run_command=$3\nfi\n\nwhile [ ${#} -gt 0 ]; do\n  case \"${1}\" in\n  --debug)\n    DEBUG=\"1\"\n    ;;\n  --skip-prereqs)\n    SKIP_PREREQS=\"1\"\n    ;;\n  --skip-mac-address)\n    SKIP_MAC_ADDRESS=\"1\"\n    ;;\n  --docker-args)\n    user_args_argv=\"$2\"\n    user_args=\"$user_args_argv\"\n    shift\n    ;;\n  --run-image)\n    user_run_image=\"$2\"\n    shift\n    ;;\n  esac\n\n  shift 1\ndone\n\nif [ -z \"$command\" -o -z \"$config\" -a \"$command\" != \"cleanup\" ]; then\n  usage\nfi\n\n# Docker doesn't like uppercase characters, spaces or special characters, catch it now before we build everything out and then find out\nre='[[:upper:]/ !@#$%^&*()+~`=]'\nif [[ $config =~ $re ]];\n  then\n    echo\n    echo \"ERROR: Config name '$config' must not contain upper case characters, spaces or special characters. Correct config name and rerun $0.\"\n    echo\n    exit 1\nfi\n\ncd \"$(dirname \"$0\")\"\n\npups_version='v1.0.3'\ndocker_min_version='20.10.0'\ndocker_rec_version='24.0.7'\ngit_min_version='1.8.0'\ngit_rec_version='1.8.0'\nkernel_min_version='4.4.0'\n\nconfig_file=containers/\"$config\".yml\ncidbootstrap=cids/\"$config\"_bootstrap.cid\nlocal_discourse=local_discourse\nimage=\"discourse/base:2.0.20250105-0017\"\ndocker_path=`which docker.io 2> /dev/null || which docker`\ngit_path=`which git`\n\nif [ \"${SUPERVISED}\" = \"true\" ]; then\n  restart_policy=\"--restart=no\"\n  attach_on_start=\"-a\"\n  attach_on_run=\"-a stdout -a stderr\"\nelse\n  attach_on_run=\"-d\"\nfi\n\nif [ -n \"$DOCKER_HOST\" ]; then\n  docker_ip=`sed -e 's/^tcp:\\/\\/\\(.*\\):.*$/\\1/' <<< \"$DOCKER_HOST\"`\nelif [ -x \"$(which ip 2>/dev/null)\" ]; then\n  docker_ip=`ip addr show docker0 | \\\n                  grep 'inet ' | \\\n                  awk '{ split($2,a,\"/\"); print a[1] }';`\nelse\n  docker_ip=`ifconfig | \\\n                  grep -B1 \"inet addr\" | \\\n                  awk '{ if ( $1 == \"inet\" ) { print $2 } else if ( $2 == \"Link\" ) { printf \"%s:\" ,$1 } }' | \\\n                  grep docker0 | \\\n                  awk -F: '{ print $3 }';`\nfi\n\n# From https://stackoverflow.com/a/44660519/702738\ncompare_version() {\n    if [[ $1 == $2 ]]; then\n        return 1\n    fi\n    local IFS=.\n    local i a=(${1%%[^0-9.]*}) b=(${2%%[^0-9.]*})\n    local arem=${1#${1%%[^0-9.]*}} brem=${2#${2%%[^0-9.]*}}\n    for ((i=0; i<${#a[@]} || i<${#b[@]}; i++)); do\n        if ((10#${a[i]:-0} < 10#${b[i]:-0})); then\n            return 1\n        elif ((10#${a[i]:-0} > 10#${b[i]:-0})); then\n            return 0\n        fi\n    done\n    if [ \"$arem\" '<' \"$brem\" ]; then\n        return 1\n    elif [ \"$arem\" '>' \"$brem\" ]; then\n        return 0\n    fi\n    return 1\n}\n\nfatal () {\n  echo -e \"\\n$1\\n\"\n  exit \"${2:-1}\"\n}\n\ninstall_docker() {\n  echo \"Docker is not installed, you will need to install Docker in order to run Launcher\"\n  echo \"See https://docs.docker.com/installation/\"\n  exit 1\n}\n\npull_image() {\n  # Add a single retry to work around dockerhub TLS errors\n  $docker_path pull $image || $docker_path pull $image\n}\n\ncheck_prereqs() {\n\n  if [ -z $docker_path ]; then\n    install_docker\n  fi\n\n  # 1. docker daemon running?\n  # we send stderr to /dev/null cause we don't care about warnings,\n  # it usually complains about swap which does not matter\n  test=`$docker_path info 2> /dev/null`\n  if [[ $? -ne 0 ]] ; then\n    echo \"Cannot connect to the docker daemon - verify it is running and you have access\"\n    exit 1\n  fi\n\n  # 2. running an approved storage driver?\n  if ! $docker_path info 2> /dev/null | grep -E -q 'Storage Driver: (btrfs|aufs|zfs|overlay2)$'; then\n    echo \"Your Docker installation is not using a supported storage driver.  If we were to proceed you may have a broken install.\"\n    echo \"overlay2 is the recommended storage driver, although zfs and aufs may work as well.\"\n    echo \"Other storage drivers are known to be problematic.\"\n    echo \"You can tell what filesystem you are using by running \\\"docker info\\\" and looking at the 'Storage Driver' line.\"\n    echo\n    echo \"If you wish to continue anyway using your existing unsupported storage driver,\"\n    echo \"read the source code of launcher and figure out how to bypass this check.\"\n    exit 1\n  fi\n\n  # 3. running recommended docker version\n  test=($($docker_path --version))  # Get docker version string\n  test=${test[2]//,/}  # Get version alone and strip comma if exists\n\n  # At least minimum docker version\n  if compare_version \"${docker_min_version}\" \"${test}\"; then\n    echo \"ERROR: Docker version ${test} not supported, please upgrade to at least ${docker_min_version}, or recommended ${docker_rec_version}\"\n    exit 1\n  fi\n\n  # Recommend newer docker version\n  if compare_version \"${docker_rec_version}\" \"${test}\"; then\n    echo \"WARNING: Docker version ${test} deprecated, recommend upgrade to ${docker_rec_version} or newer.\"\n  fi\n\n  arm=false\n  case $(uname -m) in\n    armv7l)\n      echo \"ERROR: 32bit arm is not supported. Check if your hardware support arm64, which is supported in experimental capacity.\"\n      exit 1\n      ;;\n    aarch64 | arm64)\n      echo \"WARNING: Support for aarch64 is experimental at the moment. Please report any problems at https://meta.discourse.org/tag/arm\"\n      image=\"discourse/base:aarch64\"\n      arm=true\n      ;;\n    x86_64)\n      echo \"x86_64 arch detected.\"\n      ;;\n    *)\n      echo \"ERROR: unknown arch detected.\"\n      exit 1\n      ;;\n  esac\n\n\n  # 4. discourse docker image is downloaded\n  test=`$docker_path images | awk '{print $1 \":\" $2 }' | grep \"$image\"`\n\n  # arm experimental support is on a fixed tag, always pull\n  if [ -z \"$test\" ] || [ $arm = true ]; then\n    echo\n    echo \"WARNING: We are about to start downloading the Discourse base image\"\n    echo \"This process may take anywhere between a few minutes to an hour, depending on your network speed\"\n    echo\n    echo \"Please be patient\"\n    echo\n\n    pull_image\n  fi\n\n  # 5. running recommended git version\n  test=($($git_path --version))  # Get git version string\n  test=${test[2]//,/}  # Get version alone and strip comma if exists\n\n  # At least minimum version\n  if compare_version \"${git_min_version}\" \"${test}\"; then\n    echo \"ERROR: Git version ${test} not supported, please upgrade to at least ${git_min_version}, or recommended ${git_rec_version}\"\n    exit 1\n  fi\n\n  # Recommend best version\n  if compare_version \"${git_rec_version}\" \"${test}\"; then\n    echo \"WARNING: Git version ${test} deprecated, recommend upgrade to ${git_rec_version} or newer.\"\n  fi\n\n  # Check minimum kernel version due to https://bugs.ruby-lang.org/issues/13885\n  test=($(uname -r))\n\n  # At least minimum version\n  if compare_version \"${kernel_min_version}\" \"${test}\"; then\n    echo \"ERROR: Kernel version ${test} not supported, please upgrade to at least ${kernel_min_version}\"\n    exit 1\n  fi\n\n  # 6. able to attach stderr / out / tty\n  test=`$docker_path run $user_args -i --rm -a stdout -a stderr $image echo working`\n  if [[ \"$test\" =~ \"working\" ]] ; then : ; else\n    echo \"Your Docker installation is not working correctly\"\n    echo\n    echo \"See: https://meta.discourse.org/t/docker-error-on-bootstrap/13657/18?u=sam\"\n    exit 1\n  fi\n\n  # 7. enough space for the bootstrap on docker folder\n  folder=`$docker_path info --format '{{.DockerRootDir}}'`\n  safe_folder=${folder:-/var/lib/docker}\n  if [[ -d $safe_folder && $(stat -f --format=\"%a*%S\" $safe_folder)/1024**3 -lt 5 ]] ; then\n    echo \"You have less than 5GB of free space on the disk where $safe_folder is located. You will need more space to continue\"\n    df -h $safe_folder\n    echo\n    if tty >/dev/null; then\n      read -p \"Would you like to attempt to recover space by cleaning docker images and containers in the system? (y/N)\" -n 1 -r\n      echo\n      if [[ $REPLY =~ ^[Yy]$ ]]\n      then\n        $docker_path container prune --force --filter until=24h >/dev/null\n        $docker_path image prune --all --force --filter until=24h >/dev/null\n        echo \"If the cleanup was successful, you may try again now\"\n      fi\n    fi\n    exit 1\n  fi\n\n  # 8. container definition file is accessible and is not insecure (world-readable)\n  if [[ ! -e \"$config_file\" || ! -r \"$config_file\" ]]; then\n    echo \"ERROR: $config_file does not exist or is not readable.\"\n    echo\n    echo \"Available configs ( `cd containers && ls -dm *.yml | tr -s '\\n' ' ' | awk '{ gsub(/\\.yml/, \"\"); print }'`)\"\n    exit 1\n  elif [[ \"$(find $config_file -perm -004)\" ]]; then\n    echo \"WARNING: $config_file file is world-readable. You can secure this file by running: chmod o-rwx $config_file\"\n  fi\n}\n\n\nif [ -z \"$SKIP_PREREQS\" ] && [ \"$command\" != \"cleanup\" ]; then\n  check_prereqs\nfi\n\nset_volumes() {\n  volumes=`cat $config_file | $docker_path run $user_args --rm -i -a stdout -a stdin $image ruby -e \\\n        \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['volumes'].map{|v| '-v ' << v['volume']['host'] << ':' << v['volume']['guest'] << ' '}.join\"`\n}\n\nset_links() {\n    links=`cat $config_file | $docker_path run $user_args --rm -i -a stdout -a stdin $image ruby -e \\\n        \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['links'].map{|l| '--link ' << l['link']['name'] << ':' << l['link']['alias'] << ' '}.join\"`\n}\n\nfind_templates() {\n    local templates=`cat $1 | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \\\n      \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['templates']\"`\n\n    local arrTemplates=${templates// / }\n\n    if [ ! -z \"$templates\" ]; then\n      echo $templates\n    else\n      echo \"\"\n    fi\n}\n\nset_template_info() {\n    templates=$(find_templates $config_file)\n\n    arrTemplates=(${templates// / })\n    config_data=$(cat $config_file)\n\n    input=\"hack: true\"\n\n    for template in \"${arrTemplates[@]}\"\n    do\n      [ ! -z $template ] && {\n        input=\"$input _FILE_SEPERATOR_ $(cat $template)\"\n      }\n    done\n\n    # we always want our config file last so it takes priority\n    input=\"$input _FILE_SEPERATOR_ $config_data\"\n\n    read -r -d '' env_ruby << 'RUBY'\n    require 'yaml'\n\n    input=STDIN.readlines.join\n    # default to UTF-8 for the dbs sake\n    env = {'LANG' => 'en_US.UTF-8'}\n    input.split('_FILE_SEPERATOR_').each do |yml|\n       yml.strip!\n       begin\n         env.merge!(YAML.load(yml)['env'] || {})\n       rescue Psych::SyntaxError => e\n        puts e\n        puts \"*ERROR.\"\n       rescue => e\n        puts yml\n        p e\n       end\n    end\n    env.each{|k,v| puts \"*ERROR.\" if v.is_a?(Hash)}\n    puts env.map{|k,v| \"-e\\n#{k}=#{v}\" }.join(\"\\n\")\nRUBY\n\n    tmp_input_file=$(mktemp)\n\n    echo \"$input\" > \"$tmp_input_file\"\n    raw=`exec cat \"$tmp_input_file\" | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \"$env_ruby\"`\n\n    rm -f \"$tmp_input_file\"\n\n    env=()\n    ok=1\n    while read i; do\n      if [ \"$i\" == \"*ERROR.\" ]; then\n        ok=0\n      elif [ -n \"$i\" ]; then\n        env[${#env[@]}]=\"${i//\\{\\{config\\}\\}/${config}}\"\n      fi\n    done <<< \"$raw\"\n\n    if [ \"$ok\" -ne 1 ]; then\n      echo \"${env[@]}\"\n      echo \"YAML syntax error. Please check your containers/*.yml config files.\"\n      exit 1\n    fi\n\n    # labels\n    read -r -d '' labels_ruby << 'RUBY'\n    require 'yaml'\n\n    input=STDIN.readlines.join\n    labels = {}\n    input.split('_FILE_SEPERATOR_').each do |yml|\n       yml.strip!\n       begin\n         labels.merge!(YAML.load(yml)['labels'] || {})\n       rescue Psych::SyntaxError => e\n        puts e\n        puts \"*ERROR.\"\n       rescue => e\n        puts yml\n        p e\n       end\n    end\n    puts labels.map{|k,v| \"-l\\n#{k}=#{v}\" }.join(\"\\n\")\nRUBY\n\n    tmp_input_file=$(mktemp)\n\n    echo \"$input\" > \"$tmp_input_file\"\n    raw=`exec cat \"$tmp_input_file\" | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \"$labels_ruby\"`\n\n    rm -f \"$tmp_input_file\"\n\n    labels=()\n    ok=1\n    while read i; do\n      if [ \"$i\" == \"*ERROR.\" ]; then\n        ok=0\n      elif [ -n \"$i\" ]; then\n        labels[${#labels[@]}]=$(echo $i | sed s/{{config}}/${config}/g)\n      fi\n    done <<< \"$raw\"\n\n    if [ \"$ok\" -ne 1 ]; then\n      echo \"${labels[@]}\"\n      echo \"YAML syntax error. Please check your containers/*.yml config files.\"\n      exit 1\n    fi\n\n    # expose\n    read -r -d '' ports_ruby << 'RUBY'\n    require 'yaml'\n\n    input=STDIN.readlines.join\n    ports = []\n    input.split('_FILE_SEPERATOR_').each do |yml|\n       yml.strip!\n       begin\n         ports += (YAML.load(yml)['expose'] || [])\n       rescue Psych::SyntaxError => e\n        puts e\n        puts \"*ERROR.\"\n       rescue => e\n        puts yml\n        p e\n       end\n    end\n    puts ports.map { |p| p.to_s.include?(':') ? \"-p\\n#{p}\" : \"--expose\\n#{p}\" }.join(\"\\n\")\nRUBY\n\n    tmp_input_file=$(mktemp)\n\n    echo \"$input\" > \"$tmp_input_file\"\n    raw=`exec cat \"$tmp_input_file\" | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \"$ports_ruby\"`\n\n    rm -f \"$tmp_input_file\"\n\n    ports=()\n    ok=1\n    while read i; do\n      if [ \"$i\" == \"*ERROR.\" ]; then\n        ok=0\n      elif [ -n \"$i\" ]; then\n        ports[${#ports[@]}]=$i\n      fi\n    done <<< \"$raw\"\n\n    if [ \"$ok\" -ne 1 ]; then\n      echo \"${ports[@]}\"\n      echo \"YAML syntax error. Please check your containers/*.yml config files.\"\n      exit 1\n    fi\n\n   merge_user_args\n}\n\nif [ -z $docker_path ]; then\n  install_docker\nfi\n\n[ \"$command\" == \"cleanup\" ] && {\n  $docker_path container prune --filter until=1h\n  $docker_path image prune --all --filter until=1h\n\n  if [ -d /var/discourse/shared/standalone/postgres_data_old ]; then\n    echo\n    echo \"Old PostgreSQL backup data cluster detected taking up $(du -hs /var/discourse/shared/standalone/postgres_data_old | awk '{print $1}') detected\"\n    read -p \"Would you like to remove it? (y/N): \" -n 1 -r && echo\n\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      echo \"removing old PostgreSQL data cluster at /var/discourse/shared/standalone/postgres_data_old...\"\n      rm -rf /var/discourse/shared/standalone/postgres_data_old*\n    else\n      exit 1\n    fi\n  fi\n\n  exit 0\n}\n\ndocker_version=($($docker_path --version))\ndocker_version=${test[2]//,/}\nrestart_policy=${restart_policy:---restart=always}\n\nset_existing_container(){\n  existing=`$docker_path ps -a | awk '{ print $1, $(NF) }' | grep \" $config$\" | awk '{ print $1 }'`\n}\n\nrun_stop() {\n\n  set_existing_container\n\n  if [ ! -z $existing ]\n     then\n       (\n        set -x\n        $docker_path stop -t 600 $config\n       )\n     else\n       echo \"$config was not started !\"\n       echo \"./discourse-doctor may help diagnose the problem.\"\n       exit 1\n  fi\n}\n\nset_run_image() {\n  run_image=`cat $config_file | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \\\n    \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['run_image']\"`\n\n  if [ -n \"$user_run_image\" ]; then\n    run_image=$user_run_image\n  elif [ -z \"$run_image\" ]; then\n    run_image=\"$local_discourse/$config\"\n  fi\n}\n\nset_boot_command() {\n  boot_command=`cat $config_file | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \\\n    \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['boot_command']\"`\n\n  if [ -z \"$boot_command\" ]; then\n\n    no_boot_command=`cat $config_file | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \\\n      \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['no_boot_command']\"`\n\n    if [ -z \"$no_boot_command\" ]; then\n      boot_command=\"/sbin/boot\"\n    fi\n  fi\n}\n\nmerge_user_args() {\n  local docker_args\n\n  docker_args=`cat $config_file | $docker_path run $user_args --rm -i -a stdout -a stdin $image ruby -e \\\n          \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['docker_args']\"`\n\n  if [[ -n \"$docker_args\" ]]; then\n    user_args=\"$user_args_argv $docker_args\"\n  fi\n}\n\nrun_start() {\n\n   if [ -z \"$START_CMD_ONLY\" ]\n   then\n     existing=`$docker_path ps | awk '{ print $1, $(NF) }' | grep \" $config$\" | awk '{ print $1 }'`\n     echo $existing\n     if [ ! -z $existing ]\n     then\n       echo \"Nothing to do, your container has already started!\"\n       exit 0\n     fi\n\n     existing=`$docker_path ps -a | awk '{ print $1, $(NF) }' | grep \" $config$\" | awk '{ print $1 }'`\n     if [ ! -z $existing ]\n     then\n       echo \"starting up existing container\"\n       (\n         set -x\n         $docker_path start $config\n       )\n       exit 0\n     fi\n   fi\n\n   set_template_info\n   set_volumes\n   set_links\n   set_run_image\n   set_boot_command\n\n   # get hostname and settings from container configuration\n   for envar in \"${env[@]}\"\n   do\n     if [[ $envar == DOCKER_USE_HOSTNAME* ]] || [[ $envar == DISCOURSE_HOSTNAME* ]]\n     then\n       # use as environment variable\n       eval $envar\n     fi\n   done\n\n   (\n     hostname=`hostname -s`\n     # overwrite hostname\n     if [ \"$DOCKER_USE_HOSTNAME\" = \"true\" ]\n     then\n       hostname=$DISCOURSE_HOSTNAME\n     else\n       hostname=$hostname-$config\n     fi\n\n     # we got to normalize so we only have allowed strings, this is more comprehensive but lets see how bash does first\n     # hostname=`$docker_path run $user_args --rm $image ruby -e 'print ARGV[0].gsub(/[^a-zA-Z-]/, \"-\")' $hostname`\n     # docker added more hostname rules\n     hostname=${hostname//_/-}\n\n\n     if [ -z \"$SKIP_MAC_ADDRESS\" ] ; then\n      mac_address=\"--mac-address $($docker_path run $user_args -i --rm -a stdout -a stderr $image /bin/sh -c \"echo $hostname | md5sum | sed 's/^\\(..\\)\\(..\\)\\(..\\)\\(..\\)\\(..\\).*$/02:\\1:\\2:\\3:\\4:\\5/'\")\"\n     fi\n\n     if [ ! -z \"$START_CMD_ONLY\" ] ; then\n       docker_path=\"true\"\n     fi\n\n     set -x\n\n     $docker_path run --shm-size=512m $links $attach_on_run $restart_policy \"${env[@]}\" \"${labels[@]}\" -h \"$hostname\" \\\n        -e DOCKER_HOST_IP=\"$docker_ip\" --name $config -t \"${ports[@]}\" $volumes $mac_address $user_args \\\n        $run_image $boot_command\n\n   )\n   exit 0\n\n}\n\nrun_run() {\n  set_template_info\n  set_volumes\n  set_links\n  set_run_image\n\n  unset ERR\n  (exec $docker_path run --rm --shm-size=512m $user_args $links \"${env[@]}\" -e DOCKER_HOST_IP=\"$docker_ip\" -i -a stdin -a stdout -a stderr $volumes $run_image \\\n    /bin/bash -c \"$run_command\") || ERR=$?\n\n  if [[ $ERR > 0 ]]; then\n    exit 1\n  fi\n}\n\nrun_bootstrap() {\n  set_template_info\n\n  base_image=`cat $config_file | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \\\n    \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['base_image']\"`\n\n  update_pups=`cat $config_file | $docker_path run $user_args --rm -i -a stdin -a stdout $image ruby -e \\\n    \"require 'yaml'; puts YAML.load(STDIN.readlines.join)['update_pups']\"`\n\n  if [[ ! X\"\" = X\"$base_image\" ]]; then\n    image=$base_image\n  fi\n\n  # the base_image may not always be discourse/base,\n  # let's ensure we always build from the latest\n  pull_image\n\n  set_volumes\n  set_links\n\n  if $docker_path run $user_args --rm -i $image gem which pups; then\n    pups_command=\"/usr/local/bin/pups --stdin\"\n  else\n    # Fallback to git pull method here if `pups` was not installed by gem in base image\n    pups_command=\"cd /pups &&\"\n    if [[ ! \"false\" =  $update_pups ]]; then\n      pups_command=\"$pups_command git pull && git checkout $pups_version &&\"\n    fi\n    pups_command=\"$pups_command /pups/bin/pups --stdin\"\n  fi\n\n  echo $pups_command\n\n  declare -i BOOTSTRAP_EXITCODE\n  rm -f $cidbootstrap\n\n  echo \"$input\" | $docker_path run --shm-size=512m $user_args $links \"${env[@]}\" -e DOCKER_HOST_IP=\"$docker_ip\" --cidfile \"$cidbootstrap\" -i -a stdin -a stdout -a stderr $volumes $image \\\n    /bin/bash -c \"$pups_command\"\n  BOOTSTRAP_EXITCODE=$?\n\n  CONTAINER_ID=$(cat \"$cidbootstrap\")\n  rm -f \"$cidbootstrap\"\n\n  # magic exit code that indicates a retry\n  if [[ $BOOTSTRAP_EXITCODE -eq 77 ]]; then\n    $docker_path rm \"$CONTAINER_ID\"\n    exit 77\n  elif [[ $BOOTSTRAP_EXITCODE -gt 0 ]]; then\n    echo \"bootstrap failed with exit code $BOOTSTRAP_EXITCODE\"\n    echo \"** FAILED TO BOOTSTRAP ** please scroll up and look for earlier error messages, there may be more than one.\"\n    echo \"./discourse-doctor may help diagnose the problem.\"\n\n    if [[ -n \"$DEBUG\" ]]; then\n      if $docker_path commit \"$CONTAINER_ID\" $local_discourse/$config-debug; then\n        echo \"** DEBUG ** Maintaining image for diagnostics $local_discourse/$config-debug\"\n      else\n        echo \"** DEBUG ** Failed to commit container $CONTAINER_ID for diagnostics\"\n      fi\n    fi\n\n    $docker_path rm \"$CONTAINER_ID\"\n    exit 1\n  fi\n\n  sleep 5\n\n  $docker_path commit \\\n    -c \"LABEL org.opencontainers.image.created=\\\"$(TZ=UTC date -Iseconds)\\\"\" \\\n    \"$CONTAINER_ID\" \\\n    $local_discourse/$config || fatal \"FAILED TO COMMIT $CONTAINER_ID\"\n  $docker_path rm \"$CONTAINER_ID\"\n}\n\ncase \"$command\" in\n  bootstrap)\n      run_bootstrap\n      echo \"Successfully bootstrapped, to startup use ./launcher start $config\"\n      exit 0\n      ;;\n\n  run)\n      run_run\n      exit 0\n      ;;\n\n  enter)\n      exec $docker_path exec -it $config /bin/bash --login\n      ;;\n\n  stop)\n      run_stop\n      exit 0\n      ;;\n\n  logs)\n\n      $docker_path logs $config\n      exit 0\n      ;;\n\n  restart)\n      run_stop\n      run_start\n      exit 0\n      ;;\n\n  start-cmd)\n    START_CMD_ONLY=\"1\"\n    run_start\n    exit 0;\n    ;;\n\n  start)\n      run_start\n      exit 0\n      ;;\n\n  rebuild)\n      if [ \"$(git symbolic-ref --short HEAD)\" == \"master\" ]; then\n        git branch -m master main\n        git fetch origin\n        git branch -u origin/main main\n        git remote set-head origin -a\n      fi\n\n      if [ \"$(git symbolic-ref --short HEAD)\" == \"main\" ]; then\n        echo \"Ensuring launcher is up to date\"\n\n        git remote update\n\n        LOCAL=$(git rev-parse HEAD)\n        REMOTE=$(git rev-parse @{u})\n        BASE=$(git merge-base HEAD @{u})\n\n        if [ $LOCAL = $REMOTE ]; then\n          echo \"Launcher is up-to-date\"\n\n        elif [ $LOCAL = $BASE ]; then\n          echo \"Updating Launcher...\"\n          git pull || (echo 'failed to update' && exit 1)\n\n          echo \"Launcher updated, restarting...\"\n          exec \"$0\" \"${SAVED_ARGV[@]}\"\n\n        elif [ $REMOTE = $BASE ]; then\n          echo \"Your version of Launcher is ahead of origin\"\n\n        else\n          echo \"Launcher has diverged source, this is only expected in Dev mode\"\n        fi\n\n      fi\n\n      set_existing_container\n\n      if [ ! -z $existing ]\n        then\n          echo \"Stopping old container\"\n          (\n            set -x\n            $docker_path stop -t 600 $config\n          )\n      fi\n\n      run_bootstrap\n\n      if [ ! -z $existing ]\n        then\n          echo \"Removing old container\"\n          (\n            set -x\n            $docker_path rm $config\n          )\n      fi\n\n      run_start\n      exit 0\n      ;;\n\n\n  destroy)\n      (set -x; $docker_path stop -t 600 $config && $docker_path rm $config) || (echo \"$config was not found\" && exit 0)\n      exit 0\n      ;;\nesac\n\nusage\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "shared",
          "type": "tree",
          "content": null
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}