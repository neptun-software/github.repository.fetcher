{
  "metadata": {
    "timestamp": 1736568647046,
    "page": 733,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "frameable/aviary.sh",
      "stars": 1311,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2020 David Chester\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.92578125,
          "content": "<img alt=\"aviary.sh\" src=\"aviary.svg\" height=48>\n\n***\n###\n\nMinimal distributed configuration management in bash.  Tiny alternative to ansible / chef / puppet / etc.  Made with :heart: by the friendly folks at https://frameableinc.com\n\n```\n$ sudo av apply\nFetching inventory...\nApplying module nginx\nApplying module memcached\nDone\n```\n\n## How it works\n\n<img src=\"diagram.png\" width=\"100%\">\n\nAviary.sh follows some guiding principles:\n\n- bash is just fine (yes, it is)\n- minimize levels of abstraction\n- each host takes care of itself\n\nEach host periodically fetches the latest version of the inventory to see what roles should it be performing.  Given whatever roles, the inventory also describes modules (services, programs, etc) that need to be installed and running in order to fulfill the role, and the host configures itself accordingly.  The inventory is a git repo with a specific directory structure and idempotent scripts to apply modules.\n\n\n\n## Getting started\n\n#### Installation\n\nInstall from the command line, on a box to be managed by aviary.sh:\n\n```bash\ncurl https://aviary.sh/install | sudo bash\n```\n\n\n#### Inventory setup\n\nConfigure your inventory if you don't have one yet:\n\n```bash\nmkdir inventory\ncd inventory\nmkdir {hosts,modules,roles,directives}\ntouch {hosts,modules,roles,directives}/.gitkeep\ngit init\ngit add .\ngit commit -m \"initial commit\"\n```\n\nConfigure and push your repo to an origin:\n\n```bash\ngit remote add origin $my_origin_url\ngit push -u origin master\n```\n\nSet your inventory url in config:\n\n```bash\necho inventory_git_url=$my_origin_url >> /var/lib/aviary/config\n```\nOf course the dealings with git will be non-interactive, so you need to either set up ssh keys or access tokens in order to make that work.  In GitHub for example, find \"Personal Access Tokens\" under your account settings.  Once you have an access token, you can include it in the git url, e.g., `https://<username>:<access_token>@github.com/organization/aviary-inventory.git`\n\n\n#### Modules\n\nIn the `inventory` directory we created above, add our first module:\n\n```bash\nmkdir modules/motd\n```\n\nCreate an idempotent script to configure the message-of-the-day that users will see when they log in to this box.  In the inventory, create `modules/motd/apply` with these contents:\n\n```bash\n# inventory/modules/motd/apply\ncat <<EOF > /etc/motd\n\"Ever make mistakes in life? Let’s make them birds. Yeah, they’re birds now.\"\n--Bob Ross\nEOF\n```\n\nNow create this host in the inventory, and add the motd module to be applied:\n\n```bash\nmkdir hosts/$(hostname)\necho motd > hosts/$(hostname)/modules\n```\n\nIt's usually better practice to apply roles (sets of modules) to hosts, but you can also apply ad-hoc modules directly if you like, as we're doing here.\n\nNow check in these contents and push them up to the inventory repo.\n\n#### Running `av`\n\nTo apply our module, run `av apply`.\n\n```bash\n# av apply\nFetching inventory...\nApplying motd...\nDone.\n```\n\nInspect `/etc/motd` to see that our motd module has in fact been applied.\n\nRunning `av status` (or just `av`) tells us how the host is configured and what is its status:\n\n```bash\n# av status\nSTATUS OK\n```\n\n#### Templates and variables\n\nIn order to make configuration files dynamic, we can use template files and variable interpolation.  Templates are {{ moustache }} style, and variables can be configured at various levels of the inventory directory hierarchy in `variables` bash files containing variable assignments.\n\nLet's spruce up our `motd` module.  In the inventory, let's add a template in `modules/motd`:\n\n```bash\n# inventory/modules/motd/motd.template\n\nWelcome to {{ hostname }}\n\n\"Ever make mistakes in life? Let’s make them birds. Yeah, they’re birds now.\"\n--Bob Ross\n```\n\nSet the `hostname` variable in a `variables` file:\n\n```bash\n# inventory/modules/motd/variables\n\nhostname=$(hostname)\n```\n\nSet the `apply` script to interpolate the template:\n\n```bash\n# inventory/modules/motd/apply\n\nsource template\nsource variables\n\ntemplate $(dirname $0)/motd.template > /etc/motd\n```\n\nLooking at our inventory directory structure, we should see something like this:\n\n```\ninventory\n├── hosts\n│   └── my-host-01\n│       └── modules\n├── modules\n│   └── motd\n│       ├── apply\n│       ├── motd.template\n│       └── variables\n├── roles\n└── directives\n```\n\nFrom here, add more modules, group modules into roles, and apply roles to your hosts, similarly to how we did with this first module.\n\n\n## Concepts\n\n**Inventory** - Git repository where you keep configuration about your servers and what-all they should be doing.  Consists of hosts, roles, and modules.\n\n**Host** - Server virtual or not with a hostname.\n\n**Role** - High-level function that you define (e.g., \"application server\", or \"database server\") to be assumed by the host.  Multiple roles may be applied to a host.\n\n**Module** - Service or program (e.g., \"node\", or \"postgres\") required to fulfill a role.  A role will usually be comprised of many modules.\n\n**Directive** - One-time set of commands to be executed immediately.\n\n## Inventory\n\nThe inventory is the git repository where you keep configuration about your servers -- what roles they play, what services they run, etc.  \n\nThere are four top-level directories: `hosts`, `roles`, `modules`, and `directives`.  Files in each directory are newline-delimited text files, unless specified otherwise\n\n### Hosts\n\nThe hosts directory contains a directory for each host.  In each host directory live the files:\n  - `roles` - a list of roles to be fulfilled by the host\n  - `modules` - a list of ad-hoc modules to be applied on the host\n  - `variables` - list of bash variable assignments local to the host. These take priority over role variables\n\n### Roles\n\nThe roles directory contains a directory for each role.  In each role directory live the files:\n  - `modules` - a list of modules required to fulfill the given role\n  - `variables` - list of bash variable assignments to be supplied when assuming a role. Host variables can overwrite these\n\n### Modules\n\nThe modules directory contains a directory for each module.  In each module directory live the files:\n  - `apply` - idempotent bash script that will ensure the given service or program is installed and running\n  - `variables` - list of bash variable assignments local to the module\n  - `test` - bash script to assert that all looks well after we've run `apply`\n  - any other files (templates, configuration files, etc) necessary to support the `apply` script\n\n### Directives\n\nThe directives directory contains bash scripts to be executed once on each host, immediately when they are discovered.  Only directive scripts with modification times within the most recent 24 hours will be considered for execution.\n\n\n## av\n\nThe command line tool is called `av`.  \n\n```\nav - manage configuration for your hosts\n\nUsage:\n  av [options] [command] [command-args]\n\nOptions:\n  --help                   Show this help message\n  --version                Show version\n  --log-level <level>      Set the log level (trace,debug,info,warn,critical) [default: info]\n  --force                  Run even if a pause or run lock is set\n  --no-fetch               Don't fetch the inventory\n\nCommands:\n  status                   Report the status of the last run of `apply` [default]\n  host <action>            Perform actions specific to the current host; more below\n  apply                    Apply roles and their associated modules on this host \n  fetch                    Update local database by fetching from upstream\n  directive                Run any outstanding directives from the inventory\n  recover                  Reset run lock file after a failure\n  pause                    Set the pause lock to avoid periodic runs while debugging\n  resume                   Resume periodic runs after a pause\n\nHost actions:\n  host add                      Add the current host to the inventory\n  host add-module <module>      Add the module to this host in the inventory\n  host remove-module <module>   Remove the module from this host in the inventory\n  host add-role <role>          Add the role to this host in the inventory\n  host remove-role <role>       Remove the role from this host in the inventory\n  host diff                     See what has changed in the local inventory\n  host push                     Push local inventory changes up to the git origin\n```\n\n## Why Bash?\n\nFor just about three decades, bash has been standard issue on the vast majority of computers serving traffic on the Internet.  Other languages have come and gone, each with their own story and arc, while bash has just been there.\n\nIn addition to it consistently being there, it is good / good-enough at most everything we want to do while configuring a machine.  If we were using some other language half the time we'd end up shelling out anyway, so let's just stick in the shell to begin with and revel in the ease and consistency...\n\nBut it's too _funky_ you say.  Well, yes, bash can have its quirks.  But we need some funk every now and then.  Let's just embrace it!\n"
        },
        {
          "name": "av",
          "type": "blob",
          "size": 12.83984375,
          "content": "#!/usr/bin/env bash\n\nset -euo pipefail\nset -E\n\nexport LOG_LEVEL=${LOG_LEVEL:-info}\nexport GIT_TERMINAL_PROMPT=0\n\nlib=$(dirname $(readlink -f $0))\n\nsource $lib/config\nsource $lib/log\n\nlog_level info\n\nversion=1.4.0\nlock_file=$lib/.lock\npause_file=$lib/.pause\n\ndata_dir=$lib/data\nstatus_file=$data_dir/status\n\nforce=\"\"\ncommand=\"\"\ncommand_arg=\"\"\nno_fetch=\"\"\nlocal_inventory=\"\"\n\ninventory_git_url=${inventory_git_url:-}\nvalid_name='^[a-z0-9_\\-]+$'\n\nfunction usage {\n  cat <<EOF\nav - manage configuration for your hosts\n\nUsage:\n  av [options] [command] [command-args]\n\nOptions:\n  --help                   Show this help message\n  --version                Show version\n  --log-level <level>      Set the log level (trace,debug,info,warn,critical) [default: info]\n  --inventory <path>       Use a local inventory at the specified path\n  --no-fetch               Don't fetch the inventory before running the command\n  --force                  Run even if a pause or run lock is set\n  --quiet|-q               Suppress log messages\n\nCommands:\n  status                   Report the status of the last run of \\`apply\\` [default]\n  host <host> <action>     Perform actions specific to a given host; more below\n  apply                    Apply roles and their associated modules on this host \n  fetch                    Update local database by fetching from upstream\n  directive                Run any outstanding directives from the inventory\n  recover                  Reset run lock file after a failure\n  pause                    Set the pause lock to avoid periodic runs while debugging\n  resume                   Resume periodic runs after a pause\n  list-hosts [filter]      List hosts with an optional filter (e.g. role=web)\n  list-modules             List all available modules\n  list-roles               List all available roles\n\nHost actions:\n  host <host> [host...]                Show attributes for the host(s)\n  host <host> add                      Add the host to the inventory\n  host <host> remove                   Remove the host from the inventory\n  host <host> add-module <module>      Add the module to the host in the inventory\n  host <host> remove-module <module>   Remove the module from the host in the inventory\n  host <host> add-role <role>          Add the role to the host in the inventory\n  host <host> remove-role <role>       Remove the role from the host in the inventory\nEOF\n}\n\nfunction version {\n  echo $version\n}\n\nfunction handle_err {\n  local _ec=\"$?\"\n  local _cmd=\"${BASH_COMMAND:-unknown}\"\n  log_error \"The command \\`${_cmd}\\` exited with exit code ${_ec}\"\n}\n\nfunction handle_exit {\n  if (($? != 0)); then\n    log_error Failed\n    status FAIL\n  fi \n}\n\nfunction status {\n  local date=$(date +'%Y-%m-%d %H:%M:%S')\n  mkdir -p $(dirname $status_file)\n  echo $date STATUS $1 > $status_file \n}\n\nfunction apply_module {\n  local module=$1\n  log_info Applying module $module\n  local opts=$([[ $LOG_LEVEL == 'trace' ]] && echo '-x')\n\n  # eval to not include quote characters in values\n  eval export $(host_variables $(hostname))\n  bash $opts $inventory_dir/modules/$module/apply\n\n  mkdir -p $data_dir/applied_modules\n  echo OK > $data_dir/applied_modules/$module\n}\n\nfunction test_module {\n  local module=$1\n  [[ -e $inventory_dir/modules/$module/test ]] || return 0\n  log_info Testing module $module\n  local opts=$([[ $LOG_LEVEL == 'trace' ]] && echo '-x')\n  if ! bash $opts $inventory_dir/modules/$module/test > /dev/null; then\n    log_error Test failed for module $module\n    exit 1\n  else\n    log_info Tests passed for module $module\n  fi\n}\n\nfunction drop_module {\n  local module=$1\n  log_info Dropping module $module\n  local opts=$([[ $LOG_LEVEL == 'trace' ]] && echo '-x')\n  bash $opts $inventory_dir/modules/$module/drop\n  unlink $data_dir/applied_modules/$module\n}\n\n# parse command line arguments\nwhile [[ \"$#\" -gt 0 ]]; do\n  case $1 in\n    --force) force=1;;\n    --no-fetch) no_fetch=1;;\n    --quiet|-q) log_quiet;;\n    --help) usage && exit;;\n    --version) version && exit;;\n    --log-level) shift && log_level $1;;\n    --inventory) shift && no_fetch=1 && local_inventory=$(readlink -f $1);;\n\n    *)\n      if [[ -z \"$command\" ]]; then \n        command=$1\n      elif [[ -z \"$command_arg\" ]]; then\n        command_arg=$@\n      fi\n      ;;\n  esac\n  shift\ndone\n\ncd $aviary_root\n[[ ! -z \"$local_inventory\" ]] && inventory_dir=$local_inventory\n[[ -z \"$command\" ]] && command=status\n\nfunction host_roles {\n  local host=${1:-$(hostname)}\n  roles=$(grep -hs ^ $inventory_dir/hosts/$host/roles || true)\n  echo \"$roles\"\n}\n\nfunction host_modules {\n  local host=${1:-$(hostname)}\n  # identify our roles\n  roles=$(grep -hs ^ $inventory_dir/hosts/$host/roles || true)\n  roles_pattern={${roles//$'\\n'/,},}\n  modules=$(eval \"{ grep -hs ^ $inventory_dir/hosts/$host/modules $inventory_dir/roles/$roles_pattern/modules || true; }\" | awk '!x[$0]++')\n  echo \"$modules\"\n}\n\nfunction host_variables {\n  local host=${1:-$(hostname)}\n  roles=$(grep -hs ^ $inventory_dir/hosts/$host/roles || true)\n  roles_pattern={${roles//$'\\n'/,},}\n\n  variables=$(eval \"{ grep -hs ^ $inventory_dir/roles/$roles_pattern/variables $inventory_dir/hosts/$host/variables || true; }\" | awk '!x[$0]++')\n  echo \"$variables\"\n}\n\nfunction identify {\n\n  if [[ ! -d $inventory_dir/hosts/$(hostname) ]]; then\n    log_error \"Couldn't find host $(hostname) in inventory\"\n    exit 1\n  fi\n\n  # identify our roles and modules\n  roles=$(host_roles)\n  modules=$(host_modules)\n\n  # find applied modules no longer in the inventory\n  mkdir -p $data_dir/applied_modules\n  applied_modules=$(ls $data_dir/applied_modules)\n  droppable_modules=$(comm -13 <(echo \"$modules\" | sort) <(echo \"$applied_modules\" | sort))\n}\n\nfunction check_inventory {\n  if [[ -z \"$inventory_git_url\" ]]; then\n    log_error \"No inventory_git_url configured in $lib/config\"\n    exit 1\n  fi\n\n  if [[ ! -e $inventory_dir ]]; then\n    log_error \"Couldn't find inventory at $inventory_dir\"\n    exit 1\n  fi\n}\n\nfunction execute_directives {\n\n  if [[ -d $inventory_dir/directives ]]; then\n\n    # find directives from within the last day which have not been executed\n    inventory_directives=$(find $inventory_dir/directives -type f -mtime 0 -exec ls -1rt {} + | xargs -n1 basename)\n    mkdir -p $data_dir/executed_directives\n\n    for directive in $inventory_directives; do\n      mtime=$(stat -c \"%Y\" $inventory_dir/directives/$directive)\n      if ! grep -qhs $mtime $data_dir/executed_directives/$directive; then\n        log_info Executing directive $directive\n        echo $mtime > $data_dir/executed_directives/$directive\n        bash $inventory_dir/directives/$directive\n      fi\n    done\n  fi\n}\n\nfunction fetch_inventory {\n  if [[ ! -z \"$local_inventory\" ]]; then\n    log_info \"Using local inventory $(readlink -f $local_inventory)\"\n  elif [[ ! -z \"$no_fetch\" ]]; then\n    log_info \"Not fetching inventory\"\n  else\n    check_inventory\n    log_info \"Fetching inventory\"\n    if [[ -e $inventory_dir/.git ]]; then\n      if [[ -n $(git -C $inventory_dir status --porcelain) ]]; then\n        log_error \"Local inventory checkout is dirty; try --no-fetch or reset\"\n        exit 1\n      fi\n      git -C $inventory_dir reset --hard > /dev/null\n      git -C $inventory_dir clean -fd > /dev/null\n    fi\n    (timeout 60 git -C $inventory_dir pull > /dev/null) || (timeout 60 git clone $inventory_git_url $inventory_dir > /dev/null)\n  fi\n}\n\nfunction host_entry {\n  variables=$(host_variables $host)\n\n  roles=$((grep -hs ^ $inventory_dir/hosts/$host/roles || true) | sed 's/^/role=/g')\n  modules=$(host_modules $host | sed 's/^/module=/g')\n  entries=\"host=${host} \"$(echo $roles $modules $variables | paste -s)$'\\n'\n  echo \"$entries\"\n}\n\nfunction host_remove_module {\n  local host=$1\n  local module=$2\n  local modules_file=$inventory_dir/hosts/$host/modules\n  echo \"$((grep -hs ^ $modules_file || true) | grep -v $module)\" > $modules_file\n  #cp $modules_file /var/tmp/m1\n  #grep -v '^$' $modules_file || true > $modules_file\n}\n\nfunction host_add_module {\n  local host=$1\n  local module=$2\n  local modules_file=$inventory_dir/hosts/$host/modules\n\n  if [[ -z \"$(ls $inventory_dir/modules | grep $module)\" ]]; then\n    log_error \"couldn't find module $module\"\n    exit 1\n  fi\n\n  mkdir -p $inventory_dir/hosts/$host\n  host_remove_module $host $module\n  echo $module >> $modules_file\n}\n\nfunction host_remove_role {\n  local host=$1\n  local role=$2\n  local roles_file=$inventory_dir/hosts/$host/roles\n  echo \"$(cat $roles_file | grep -v $subcommand_arg)\" > $roles_file\n}\n\nfunction host_add_role {\n  local host=$1\n  local role=$2\n  local roles_file=$inventory_dir/hosts/$host/roles\n\n  if [[ -z \"$(ls $inventory_dir/roles | grep $role)\" ]]; then\n    log_error \"Couldn't find module $role\"\n    exit 1\n  fi\n\n  mkdir -p $inventory_dir/hosts/$host\n  host_remove_module $host $role\n  echo $role >> $roles_file\n}\n\nfunction check_roles {\n  for role in $(ls -1 $inventory_dir/roles); do\n    if [[ ! -e $inventory_dir/roles/$role/modules ]]; then\n      log_warn \"No modules file for role \\`$role\\`\"\n    fi\n    malformed_modules=$(grep -sPv $valid_name $inventory_dir/roles/$role/modules || true);\n    if [[ ! -z $malformed_modules ]]; then\n      log_error Malformed role modules: $malformed_modules\n    fi\n    for module in $(grep -hs ^ $inventory_dir/roles/$role/modules || true); do\n      if [[ ! -e $inventory_dir/modules/$module ]]; then\n        log_warn \"Role \\`$role\\` module \\`$module\\` does not exist\"\n      fi\n    done\n  done\n}\n\nfunction check_modules {\n  for module in $(ls -1 $inventory_dir/modules); do\n    if [[ ! -e $inventory_dir/modules/$module/apply ]]; then\n      log_warn \"No apply script for module \\`$module\\`\"\n    fi\n  done\n}\n\nfunction check_hosts {\n  for host in $(ls -1 $inventory_dir/hosts); do\n    if [[ -z $(ls -1 $inventory_dir/hosts/$host/{modules,roles}) ]]; then\n      log_warn \"No roles for host $host\"\n    fi\n  done\n}\n\ncase $command in\n\n  version)\n    echo $version\n  ;;\n\n  apply)\n    trap handle_err ERR\n    trap handle_exit EXIT\n\n    fetch_inventory\n    identify\n\n    # consult pause file\n    if [[ -e $pause_file && ! $force ]]; then\n      log_warn 'Bailing for pause lock file; try `av resume`'\n      exit 1 \n    fi\n\n    # set up our lock file\n    if [[ -e $lock_file && ! $force ]]; then\n      log_error 'Bailing for run lock file; try `av recover`'\n      exit 1\n    else\n      touch $lock_file\n    fi\n\n    # apply modules\n    log_info Running apply\n    for module in $modules; do\n      apply_module $module\n      test_module $module\n    done\n\n    # drop obsolete modules\n    for droppable_module in $droppable_modules; do\n      drop_module $droppable_module\n    done\n\n    rm $lock_file\n    status OK\n    log_info 'Done'\n    ;;\n\n  status)\n    # list out what we would do\n    fetch_inventory\n    identify\n\n    echo Using inventory $inventory_dir\n    echo\n    echo hostname: $(hostname)\n    echo roles: ${roles:-'<none>'}\n    echo modules: ${modules:-'<none>'}\n    echo\n    [[ ! -e $status_file ]] && echo 'STATUS UNKNOWN' > $status_file\n    cat $status_file\n    echo \n    [[ -e $lock_file ]] && echo '-- Run lock is set; clear with `av recover` --'\n    [[ -e $pause_file ]] && echo '-- Pause lock is set; clear with `av resume` --'\n    ;;\n\n  directive)\n    fetch_inventory\n    execute_directives\n    ;;\n\n  list-hosts)\n    filters=$command_arg\n    fetch_inventory\n    entries=\"\"\n    hosts=$(ls -1 $inventory_dir/hosts)\n    for host in $hosts; do\n      host_entry=$(host_entry $host)\n      entries=${entries}$host$'\\t'${host_entry}$'\\n'\n    done\n\n    log_debug $'\\n'\"$entries\"\n\n    for filter in $filters; do\n      entries=$(echo \"$entries\" | grep -P $filter)\n    done\n\n    echo \"$entries\" | grep -v '^$' | cut -f1\n    ;;\n\n  list-modules)\n    fetch_inventory\n    ls -1 $inventory_dir/modules\n    ;;\n\n  list-roles)\n    fetch_inventory\n    ls -1 $inventory_dir/roles\n    ;;\n\n  check)\n    check_modules\n    check_roles\n    check_hosts\n    ;;\n\n  inventory)\n    read subcommand subcommand_arg <<< $command_arg\n    case $subcommand in\n      diff)\n        git -C $inventory_dir diff\n        ;;\n      push)\n        git -C $inventory_dir push\n        ;;\n    esac\n    ;;\n\n  host)\n    read host subcommand subcommand_arg <<< $command_arg\n\n    case $subcommand in\n      add)\n        mkdir $inventory_dir/hosts/$host\n        touch $inventory_dir/hosts/$host/.gitkeep\n        ;;\n      remove)\n        rm -rf $inventory_dir/hosts/$host\n        ;;\n      add-module)\n        host_add_module $host $subcommand_arg\n        ;;\n      remove-module)\n        host_remove_module $host $subcommand_arg\n        ;;\n      add-role)\n        host_add_role $host $subcommand_arg\n        ;;\n      remove-role)\n        host_remove_role $host $subcommand_arg\n        ;;\n      *)\n        for host in $command_arg; do\n          entry=$(host_entry $host)\n          echo -e \"$entry\" | sed 's/ /\\n/g'\n        done\n        ;;\n    esac\n    ;;\n\n  fetch)\n    # get our repo updated\n    fetch_inventory\n    ;;\n\n  recover)\n    # get our repo updated\n    rm $lock_file\n    ;;\n\n  resume)\n    # get our repo updated\n    rm $pause_file\n    ;;\n\n  pause)\n    # get our repo updated\n    touch $pause_file\n    ;;\n\n  *)\n    log_error unknown command $command\n    ;;\n\nesac\n"
        },
        {
          "name": "aviary.svg",
          "type": "blob",
          "size": 12.3828125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   version=\"1.1\"\n   id=\"svg6936\"\n   viewBox=\"0 0 952.78931 198.47632\"\n   height=\"56.014427mm\"\n   width=\"268.89832mm\">\n  <defs\n     id=\"defs6938\" />\n  <metadata\n     id=\"metadata6941\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     transform=\"translate(139.20661,-370.26691)\"\n     id=\"layer1\">\n    <path\n       id=\"path5872-3\"\n       d=\"m 60.532654,432.8288 c -12.329365,3.47559 -25.714963,3.10028 -37.83021,-1.0607 -14.4880957,-4.97593 -27.0308776,-15.388 -34.61819,-28.6958 -2.678227,-4.69749 -4.764765,-9.74215 -7.839591,-14.19015 -1.537414,-2.224 -3.324965,-4.29426 -5.448939,-5.96715 -2.123974,-1.67289 -4.59679,-2.94084 -7.24761,-3.4728 -2.62314,-0.5264 -5.375409,-0.31857 -7.926662,0.48708 -2.551254,0.80565 -4.902434,2.19909 -6.912603,3.96464 -4.020339,3.53111 -6.612896,8.46337 -8.131307,13.59428 -3.061796,10.34622 -1.991289,21.58128 1.27207,31.8657 6.664347,21.00258 22.675301,38.84679 42.835432,47.7401\"\n       style=\"opacity:1;fill:none;fill-rule:evenodd;stroke:#b4c4cf;stroke-width:13.80000019;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n    <path\n       id=\"path5868-8\"\n       d=\"m 166.50992,399.6912 c -8.72442,-3.12358 -18.03482,-4.60171 -27.29768,-4.3338 -3.36262,0.0973 -6.73454,0.42515 -9.98876,1.27764 -3.25422,0.85249 -6.39656,2.24448 -9.03863,4.32682 -2.64207,2.08234 -4.76656,4.88067 -5.78666,8.0863 -1.02009,3.20564 -0.87773,6.81949 0.64916,9.81704 0.92048,1.80707 2.31908,3.3599 3.98761,4.51263 1.66853,1.15273 3.602,1.90817 5.60088,2.25058 3.99777,0.68481 8.18089,-0.29969 11.70152,-2.31371 4.57906,-2.61951 8.11293,-6.96993 9.86895,-11.94447 1.75602,-4.97453 1.74679,-10.53008 0.10603,-15.54382 -1.64075,-5.01373 -4.88389,-9.46831 -9.0671,-12.6824 -4.18321,-3.21409 -9.28154,-5.192 -14.5239,-5.78131 -7.29659,-0.82023 -14.75081,1.03223 -21.21947,4.50634 -6.468661,3.4741 -12.003702,8.50771 -16.719038,14.13608 -9.430672,11.25675 -15.662501,24.81146 -24.061488,36.85758 -14.339911,20.5668 -35.093764,36.51255 -58.5000004,45.5 -32.7267376,12.56631 -71.0304526,11.04945 -101.6837816,-5.9601 -3.020122,-1.67587 -5.977002,-3.49879 -9.187002,-4.77377 -3.20999,-1.27497 -6.74456,-1.98364 -10.13443,-1.32153 -3.45341,0.67452 -6.55018,2.76025 -8.75739,5.50053 -2.20722,2.74029 -3.56372,6.1013 -4.23741,9.55487 -1.37465,7.04696 0.0558,14.48896 3.32994,20.87875 3.27412,6.38979 8.30986,11.77132 14.05923,16.0718 11.49873,8.60094 25.541243,12.89153 38.952802,18.02255 26.000561,9.94734 51.352382,23.74498 79.1442016,25.3554 20.2437684,1.17304 40.8578074,-4.51292 57.5138404,-16.0785 13.854967,-9.62059 24.911795,-23.22224 31.5,-38.75\"\n       style=\"fill:none;fill-rule:evenodd;stroke:#1d456c;stroke-width:13.80000019;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" />\n    <path\n       id=\"path8200\"\n       d=\"m 560.4621,545.75274 c -3.16661,-1.71818 -2.8291,-3.03957 3.00207,-11.75332 4.91768,-7.34867 10.51853,-17.29322 15.61239,-27.72048 l 2.00681,-4.10799 -4.93608,-4.59325 c -2.71485,-2.52628 -5.76987,-5.21097 -6.78895,-5.96598 -1.01908,-0.75501 -2.798,-2.55393 -3.95316,-3.99762 -1.15517,-1.4437 -3.52777,-3.89771 -5.27246,-5.45336 -1.74469,-1.55566 -5.18768,-5.85498 -7.65109,-9.55405 -5.04302,-7.57264 -5.44987,-9.28062 -2.92536,-12.28083 3.28933,-3.90915 6.65168,-1.86182 15.04977,9.16377 2.55228,3.3508 6.54408,8.22194 8.87069,10.82476 4.28205,4.79041 11.33738,11.16985 12.35329,11.16985 0.77635,0 2.43555,-3.4191 6.00641,-12.37735 1.69371,-4.24902 4.36696,-10.69592 5.94055,-14.32643 1.57359,-3.63052 3.04217,-7.58751 3.26351,-8.79332 0.4017,-2.18835 0.82161,-2.53996 4.26368,-3.57015 2.661,-0.79643 5.41921,0.31742 6.34989,2.56427 1.1914,2.87628 -0.1597,7.99929 -4.56264,17.30026 -2.10922,4.45563 -4.122,9.45134 -4.47284,11.10157 -1.42649,6.70972 -3.9494,11.78975 -12.15137,24.46752 -2.94098,4.54588 -6.16924,10.08166 -7.17392,12.30175 -1.00466,2.22009 -2.35627,4.7831 -3.00357,5.69559 -0.64729,0.91249 -2.70839,4.35583 -4.58023,7.65187 -1.87183,3.29604 -4.75352,7.5975 -6.40376,9.55881 -2.60461,3.09558 -3.2775,3.56728 -5.10072,3.57569 -1.15517,0.005 -2.83947,-0.39137 -3.74291,-0.88158 z m 135.76162,-35.41267 c -2.8054,-0.8038 -6.89427,-1.8797 -9.08638,-2.39087 -4.77846,-1.11428 -9.33508,-3.8325 -9.84759,-5.87449 -0.47923,-1.90939 1.16011,-5.04622 3.09884,-5.92956 1.12968,-0.51472 2.06636,-0.51642 3.72167,-0.007 11.87064,3.6548 16.94856,4.99238 20.7396,5.46304 8.43024,1.04662 13.21723,-0.94369 16.6343,-6.91611 2.27831,-3.98207 2.31935,-5.41327 0.25619,-8.9338 -2.09447,-3.57394 -6.77066,-6.47303 -13.4867,-8.36132 -9.56225,-2.68855 -15.58586,-6.40336 -17.77687,-10.96315 -1.35626,-2.82258 -1.55187,-11.50172 -0.32483,-14.41221 0.71039,-1.68498 4.40416,-6.29467 11.17323,-8.67703 6.76907,-2.38236 15.94333,-2.03022 22.80249,0.13617 3.30047,1.05448 6.36843,2.26893 6.8177,2.69877 0.44926,0.42983 0.95464,2.00399 1.12305,3.49813 0.26338,2.33669 0.0922,2.93059 -1.22388,4.24669 -1.50799,1.50799 -1.57187,1.51704 -4.42352,0.6267 -7.81999,-2.44155 -10.11881,-2.81045 -15.79485,-2.53469 -8.41336,0.40874 -10.80194,1.96999 -10.80194,7.06044 0,4.88231 2.05079,6.93774 8.40119,8.42015 12.19437,2.84662 21.016,8.70692 24.64088,16.36919 2.92016,6.17265 2.24776,9.27639 -3.92892,18.13558 -3.57743,5.13109 -4.17982,5.7065 -7.12937,6.81006 -4.42037,1.65387 -12.36311,3.09089 -16.79933,3.03936 -2.02633,-0.0235 -5.97957,-0.70045 -8.78496,-1.50427 z m -200.56876,-2.0961 c -1.93772,-1.12903 -2.80816,-6.2673 -3.14415,-18.55998 -0.38226,-13.98562 -1.24187,-26.88837 -2.03894,-30.60434 -0.66746,-3.11173 -0.31139,-5.65964 0.93557,-6.69453 0.47755,-0.39632 2.18838,-0.73993 3.80186,-0.76356 2.68128,-0.0393 3.1636,0.18269 5.60795,2.5809 l 2.67436,2.62387 5.00311,-3.59349 c 2.7517,-1.97642 5.92102,-3.89977 7.04292,-4.27411 2.89871,-0.96719 9.00337,-0.84232 14.04402,0.28728 5.66517,1.26955 6.41935,1.98073 6.41935,6.05337 0,2.6343 -0.27341,3.50814 -1.47294,4.70767 -1.84483,1.84484 -4.25171,1.90154 -9.04935,0.21319 -6.33957,-2.23097 -9.79546,-1.09778 -16.72426,5.48391 l -4.38005,4.16062 -0.37219,9.45955 c -0.24292,6.17412 -0.10231,11.96054 0.40484,16.66056 0.8543,7.91727 0.51297,10.52674 -1.56757,11.98401 -1.47726,1.03471 -5.60927,1.19292 -7.18453,0.27508 z m 151.00766,-0.60385 c -5.90141,-1.71301 -7.37132,-8.98739 -2.89178,-14.31102 2.9215,-3.47202 8.68531,-3.53942 11.73436,-0.13723 1.4938,1.66682 2.91316,6.1931 2.91316,9.28996 0,4.26741 -5.90244,6.85734 -11.75574,5.15829 z M 304.6071,507.10063 c -2.31871,-0.93723 -6.11645,-6.69222 -11.29532,-17.1166 -3.97918,-8.00954 -6.12953,-14.30229 -6.66446,-19.50277 -0.22067,-2.1453 -0.91308,-5.61245 -1.53869,-7.70478 -1.46154,-4.88809 -2.45459,-11.1103 -1.97334,-12.36442 0.52669,-1.37252 3.40381,-2.73573 5.75091,-2.72484 3.71295,0.0172 4.26468,1.00751 6.52523,11.71209 1.0399,4.92431 2.8283,11.66006 3.97421,14.96833 1.91126,5.51786 6.84034,15.79424 8.90637,18.56844 0.84311,1.13211 0.87931,1.13229 2.11861,0.0107 2.52404,-2.28422 5.53774,-7.01401 7.16205,-11.24032 6.69734,-17.4259 13.73618,-32.54964 17.14844,-36.84535 3.00591,-3.78415 10.30327,0.18938 8.9004,4.84642 -0.21057,0.69901 -3.04033,6.8357 -6.28837,13.63708 -3.24803,6.80138 -6.72939,14.44014 -7.73636,16.97502 -2.19978,5.53765 -5.11635,11.40315 -6.8942,13.86495 -0.71506,0.99015 -1.82485,2.82732 -2.46621,4.08261 -3.42729,6.70806 -10.70761,10.82278 -15.62927,8.8334 z m 501.01674,-0.13691 c -2.21089,-1.05851 -3.26578,-4.89669 -3.92444,-14.27931 -0.33592,-4.78568 -0.56582,-10.32146 -0.51085,-12.30174 0.15242,-5.49391 -0.90793,-11.49449 -2.66618,-15.08827 -3.11636,-6.36964 -8.83298,-7.22317 -17.97622,-2.68398 -2.64614,1.31369 -5.73272,3.34268 -6.85907,4.50887 -2.57877,2.66999 -2.84267,4.43464 -3.41222,22.81649 -0.41233,13.30786 -0.47568,13.83971 -1.80694,15.17097 -1.60531,1.60531 -4.27971,1.80085 -6.80063,0.49724 -3.25523,-1.68336 -3.61482,-6.56846 -1.86379,-25.32025 0.3441,-3.68492 0.75589,-12.19113 0.91509,-18.90268 0.1592,-6.71155 0.57296,-14.36312 0.91947,-17.0035 0.3465,-2.64037 0.86935,-8.71623 1.16188,-13.50191 0.29252,-4.78568 0.83107,-10.0071 1.19676,-11.60316 0.85862,-3.74749 2.73053,-7.39329 4.19973,-8.17958 1.99226,-1.06623 5.32059,-0.73782 6.72163,0.66322 1.18219,1.18219 1.25605,1.71445 0.93681,6.75096 -0.19061,3.00717 -1.17318,11.53451 -2.1835,18.94965 -1.82882,13.42249 -2.1962,18.0224 -1.43941,18.0224 0.21864,0 1.63881,-0.79653 3.15593,-1.77007 5.53168,-3.54966 8.23906,-4.38745 14.41878,-4.46184 8.51468,-0.10249 12.71833,1.72464 16.63191,7.22913 3.94934,5.55483 4.8356,10.34763 6.7821,36.67464 0.53437,7.22772 0.49639,8.83277 -0.24286,10.26235 -1.51347,2.92671 -5.07012,4.6438 -7.35398,3.55037 z m -582.50878,-2.28684 c -4.74795,-0.83528 -15.22199,-8.87788 -16.95102,-13.01601 -1.12121,-2.68345 -1.03178,-12.10144 0.16088,-16.94067 1.97482,-8.01287 7.03201,-16.95891 12.62534,-22.33388 2.51954,-2.42117 3.78454,-3.07149 9.50717,-4.88746 3.63051,-1.15208 7.54607,-2.28663 8.70123,-2.52123 1.15517,-0.23459 2.81277,-1.09482 3.68358,-1.91161 0.89945,-0.84367 2.6024,-1.62178 3.94289,-1.80157 2.08835,-0.28011 2.53912,-0.10318 3.9209,1.53897 2.26467,2.69141 4.02076,7.81909 5.36864,15.67614 0.65112,3.79554 1.55115,8.11615 2.00006,9.60136 0.4489,1.48521 1.13397,4.32062 1.52236,6.3009 1.14957,5.86126 2.7746,8.61877 8.16728,13.85911 5.98994,5.82073 6.2603,6.92395 2.59504,10.58921 -2.03942,2.03941 -2.67436,2.34995 -4.18655,2.04751 -5.13262,-1.02652 -10.70835,-7.37022 -13.5018,-15.36145 l -0.74566,-2.13311 -2.74337,5.85398 c -3.08972,6.59307 -7.84623,12.19459 -12.04849,14.18899 -3.0036,1.4255 -8.04379,1.95006 -12.01848,1.25082 z m 9.07705,-10.76904 c 3.1914,-1.44875 6.01315,-5.69971 9.56934,-14.4162 3.47174,-8.50947 3.57771,-9.74324 1.54715,-18.01165 l -1.69475,-6.90098 -3.87783,0.20619 c -2.1328,0.1134 -4.99103,0.69056 -6.35162,1.28258 -7.22156,3.14222 -13.77681,13.16477 -15.20461,23.24683 -0.51037,3.60386 -0.43419,4.17464 0.89473,6.70424 2.01869,3.84257 2.60964,4.49165 6.30541,6.9256 3.68878,2.42936 5.21525,2.59624 8.81218,0.96339 z m 192.46567,10.71291 c -2.37867,-0.46133 -4.27503,-1.54889 -8.8445,-5.07229 -7.7205,-5.95308 -8.49831,-7.41233 -8.4566,-15.86532 0.0271,-5.48812 0.28551,-7.05511 2.00337,-12.14784 2.20703,-6.54293 6.23581,-13.48924 10.7273,-18.49572 2.85016,-3.17695 3.29834,-3.43107 9.19778,-5.21526 3.4109,-1.03157 7.41681,-2.18573 8.90202,-2.56481 1.48521,-0.37907 3.24046,-1.17141 3.90055,-1.76074 2.92046,-2.60741 6.60169,-3.20993 8.28016,-1.35525 1.88303,2.08074 4.1143,7.9928 5.31125,14.07293 2.65121,13.46743 4.94081,22.50276 6.39409,25.23276 0.83936,1.57673 3.6699,4.90139 6.29008,7.38813 4.43506,4.20916 4.73871,4.65343 4.39784,6.43452 -0.41221,2.15391 -3.20088,4.99785 -5.45562,5.56375 -1.94127,0.48723 -5.93837,-1.82377 -8.98276,-5.19355 -1.96573,-2.17583 -4.68894,-7.19086 -5.99802,-11.04586 -0.31252,-0.92034 -1.12297,0.29542 -3.60515,5.40815 -4.76879,9.82262 -10.06122,14.26513 -17.78087,14.9254 -1.78917,0.15303 -4.61558,0.014 -6.28092,-0.309 z m 8.90736,-10.34674 c 3.68644,-1.54029 7.06199,-6.55825 10.85538,-16.13721 2.72092,-6.87077 2.81957,-8.54474 0.96472,-16.36915 -0.90427,-3.81448 -1.7461,-7.0365 -1.87074,-7.16004 -0.12465,-0.12355 -2.12467,-0.0158 -4.44449,0.23939 -6.8515,0.75375 -10.78998,3.32817 -15.21655,9.94644 -3.25213,4.86233 -5.32561,10.29417 -5.86533,15.36517 -0.3148,2.95771 -0.14886,3.76322 1.33799,6.49505 1.67803,3.0831 4.263,5.55568 7.75946,7.42207 2.232,1.19144 3.97496,1.24477 6.47956,0.19828 z m -65.75373,9.662 c -2.36203,-1.7802 -3.07187,-5.14211 -3.00917,-14.25202 0.0826,-12.00798 3.173,-33.25991 5.11959,-35.20649 1.38695,-1.38695 5.02312,-1.68958 6.74498,-0.56137 2.08245,1.36447 2.07619,1.73151 -0.36932,21.66586 -0.52785,4.30277 -0.9167,13.21711 -1.1071,25.38087 -0.007,0.42756 -0.67499,1.4402 -1.48511,2.25031 -1.61384,1.61386 -4.27811,1.9406 -5.89387,0.72284 z m 4.26581,-66.60001 c -1.14372,-1.14372 -2.4358,-2.9397 -2.87129,-3.99107 -0.68212,-1.64678 -0.65191,-2.22038 0.21808,-4.14071 2.17089,-4.79187 2.65754,-5.0996 7.28133,-4.60444 3.38787,0.36281 4.43496,0.74401 5.80389,2.11294 1.91685,1.91686 2.20353,4.72544 0.82026,8.03608 -1.06608,2.5515 -2.96574,3.81591 -6.45069,4.29358 -2.52837,0.34655 -2.8701,0.22511 -4.80158,-1.70638 z\"\n       style=\"fill:#0e2033;fill-opacity:1\" />\n  </g>\n</svg>\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 0.142578125,
          "content": "#inventory_git_url=https://access-token@github.com/organization/aviary-inventory\naviary_root=/var/lib/aviary\ninventory_dir=$aviary_root/inventory\n"
        },
        {
          "name": "diagram.png",
          "type": "blob",
          "size": 184.6376953125,
          "content": null
        },
        {
          "name": "log",
          "type": "blob",
          "size": 4.2255859375,
          "content": "#!/bin/bash\n# Logging library for Bash\n# Copyright (c) 2012 Yu-Jie Lin\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy of\n# this software and associated documentation files (the \"Software\"), to deal in\n# the Software without restriction, including without limitation the rights to\n# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n# of the Software, and to permit persons to whom the Software is furnished to do\n# so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nLS_VERSION=0.3\nLS_OUTPUT=${LS_OUTPUT:-/dev/stderr}\n\n# XXX need more flexible templating, currently manual padding for level names\nLS_DEFAULT_FMT=${LS_DEFAULT_FMT:-'$TS | $_LS_LEVEL_STR |'}\n\nLS_TRACE_LEVEL=0\nLS_DEBUG_LEVEL=10\nLS_INFO_LEVEL=20\nLS_WARNING_LEVEL=30\nLS_ERROR_LEVEL=40\nLS_CRITICAL_LEVEL=50\n\nLS_LEVEL=${LS_LEVEL:-$LS_WARNING_LEVEL}\n\nfunction log_quiet {\n  LS_LEVEL=100\n}\n\nfunction log_level {\n  LOG_LEVEL=$1\n  case $LOG_LEVEL in\n    trace)\n      LS_LEVEL=$LS_TRACE_LEVEL\n      ;;\n    debug)\n      LS_LEVEL=$LS_DEBUG_LEVEL\n      ;;\n    info)\n      LS_LEVEL=$LS_INFO_LEVEL\n      ;;\n    warn)\n      LS_LEVEL=$LS_WARNING_LEVEL\n      ;;\n    error)\n      LS_LEVEL=$LS_ERROR_LEVEL\n      ;;\n    critical)\n      LS_LEVEL=$LS_CRITICAL_LEVEL\n      ;;\n  esac\n}\n\n# LS_LEVELS structure:\n# Level, Level Name, Level Format, Before Log Entry, After Log Entry\nLS_LEVELS=(\n  $LS_DEBUG_LEVEL    'DEBUG' \"$LS_DEFAULT_FMT\" \"\\e[34m\"    \"\\e[0m\"\n  $LS_INFO_LEVEL     'INFO' \"$LS_DEFAULT_FMT\" \"\\e[32m\"    \"\\e[0m\"\n  $LS_WARNING_LEVEL  'WARN' \"$LS_DEFAULT_FMT\" \"\\e[33m\"    \"\\e[0m\"\n  $LS_ERROR_LEVEL    'ERROR' \"$LS_DEFAULT_FMT\" \"\\e[31m\"    \"\\e[0m\"\n  $LS_CRITICAL_LEVEL 'CRIT' \"$LS_DEFAULT_FMT\" \"\\e[37;41m\" \"\\e[0m\"\n)\n\n_LS_FIND_LEVEL_STR () {\n  local LEVEL=$1\n  local i\n  _LS_LEVEL_STR=\"$LEVEL\"\n  for ((i=0; i<${#LS_LEVELS[@]}; i+=5)); do\n    if [[ \"$LEVEL\" == \"${LS_LEVELS[i]}\" ]]; then\n      _LS_LEVEL_STR=\"${LS_LEVELS[i+1]}\"\n      _LS_LEVEL_FMT=\"${LS_LEVELS[i+2]}\"\n      _LS_LEVEL_BEGIN=\"${LS_LEVELS[i+3]}\"\n      _LS_LEVEL_END=\"${LS_LEVELS[i+4]}\"\n      return 0\n    fi\n  done\n  _LS_LEVEL_FMT=\"$LS_DEFAULT_FMT\"\n  _LS_LEVEL_BEGIN=\"\"\n  _LS_LEVEL_END=\"\"\n  return 1\n}\n\n# General logging function\n# $1: Level\nLSLOG () {\n  local LEVEL=$1\n  shift\n  (( LEVEL < LS_LEVEL )) && return 0\n  local TS=$(date +'%Y-%m-%d %H:%M:%S.%N')\n  # Keep digits only up to milliseconds\n  TS=${TS%??????}\n  _LS_FIND_LEVEL_STR $LEVEL\n  local OUTPUT\n  eval \"OUTPUT=\\\"$_LS_LEVEL_FMT\\\"\"\n  # if no message was passed, read it from STDIN\n  local _MSG\n  [[ $# -ne 0 ]] && _MSG=\"$@\" || _MSG=\"$(cat)\"\n  if [[ \"$LS_OUTPUT\" = \"/dev/stdout\" ]] ; then\n    echo -ne \"$_LS_LEVEL_BEGIN$OUTPUT \"\n    echo -n  \"$_MSG\"\n    echo -e \"$_LS_LEVEL_END\"\n  elif [[ \"$LS_OUTPUT\" = \"/dev/stderr\" ]] ; then\n    echo -ne \"$_LS_LEVEL_BEGIN$OUTPUT \" >&2\n    echo -n  \"$_MSG\" >&2\n    echo -e \"$_LS_LEVEL_END\" >&2\n  else\n    echo -ne \"$_LS_LEVEL_BEGIN$OUTPUT \" >> \"$LS_OUTPUT\"\n    echo -n  \"$_MSG\"                    >> \"$LS_OUTPUT\"\n    echo -e \"$_LS_LEVEL_END\" >> \"$LS_OUTPUT\"\n  fi\n}\n\nshopt -s expand_aliases\nalias log_debug='LSLOG 10'\nalias log_info='LSLOG 20'\nalias log_warn='LSLOG 30'\nalias log_error='LSLOG 40'\nalias log_critical='LSLOG 50'\nalias log_stack='LSDEBUG Traceback ; LSCALLSTACK'\n\n# Log Call Stack\nLSCALLSTACK () {\n  local i=0\n  local FRAMES=${#BASH_LINENO[@]}\n  # FRAMES-2 skips main, the last one in arrays\n  for ((i=FRAMES-2; i>=0; i--)); do\n    echo '  File' \\\"${BASH_SOURCE[i+1]}\\\", line ${BASH_LINENO[i]}, in ${FUNCNAME[i+1]}\n    # Grab the source code of the line\n    sed -n \"${BASH_LINENO[i]}{s/^/    /;p}\" \"${BASH_SOURCE[i+1]}\"\n    # TODO extract arugments from \"${BASH_ARGC[@]}\" and \"${BASH_ARGV[@]}\"\n    # It requires `shopt -s extdebug'\n  done\n}\n"
        },
        {
          "name": "template",
          "type": "blob",
          "size": 31.060546875,
          "content": "#!/usr/bin/env bash\n#\n#/ Mo is a mustache template rendering software written in bash.  It inserts\n#/ environment variables into templates.\n#/\n#/ Simply put, mo will change {{VARIABLE}} into the value of that\n#/ environment variable.  You can use {{#VARIABLE}}content{{/VARIABLE}} to\n#/ conditionally display content or iterate over the values of an array.\n#/\n#/ Learn more about mustache templates at https://mustache.github.io/\n#/\n#/ Simple usage:\n#/\n#/    mo [OPTIONS] filenames...\n#/\n#/ Options:\n#/\n#/    -u, --fail-not-set\n#/          - Fail upon expansion of an unset variable.\n#/    -e, --false\n#/          - Treat the string \"false\" as empty for conditionals.\n#/    -h, --help\n#/          - This message.\n#/    -s=FILE, --source=FILE\n#/          - Load FILE into the environment before processing templates.\n#\n# Mo is under a MIT style licence with an additional non-advertising clause.\n# See LICENSE.md for the full text.\n#\n# This is open source!  Please feel free to contribute.\n#\n# https://github.com/tests-always-included/mo\n\n\n# Public: Template parser function.  Writes templates to stdout.\n#\n# $0             - Name of the mo file, used for getting the help message.\n# --allow-function-arguments\n#                - Permit functions in templates to be called with additional\n#                  arguments. This puts template data directly in to the path\n#                  of an eval statement. Use with caution. Not listed in the\n#                  help because it only makes sense when mo is sourced.\n# -u, --fail-not-set\n#                - Fail upon expansion of an unset variable.  Default behavior\n#                  is to silently ignore and expand into empty string.\n# -e, --false    - Treat \"false\" as an empty value.  You may set the\n#                  MO_FALSE_IS_EMPTY environment variable instead to a non-empty\n#                  value to enable this behavior.\n# -h, --help     - Display a help message.\n# -s=FILE, --source=FILE\n#                - Source a file into the environment before processint\n#                  template files.\n# --             - Used to indicate the end of options.  You may optionally\n#                  use this when filenames may start with two hyphens.\n# $@             - Filenames to parse.\n#\n# Mo uses the following environment variables:\n#\n# MO_ALLOW_FUNCTION_ARGUMENTS\n#                     - When set to a non-empty value, this allows functions\n#                       referenced in templates to receive additional\n#                       options and arguments. This puts the content from the\n#                       template directly into an eval statement. Use with\n#                       extreme care.\n# MO_FUNCTION_ARGS    - Arguments passed to the function\n# MO_FAIL_ON_UNSET    - When set to a non-empty value, expansion of an unset\n#                       env variable will be aborted with an error.\n# MO_FALSE_IS_EMPTY   - When set to a non-empty value, the string \"false\"\n#                       will be treated as an empty value for the purposes\n#                       of conditionals.\n# MO_ORIGINAL_COMMAND - Used to find the `mo` program in order to generate\n#                       a help message.\n#\n# Returns nothing.\ntemplate() (\n    # This function executes in a subshell so IFS is reset.\n    # Namespace this variable so we don't conflict with desired values.\n    local moContent f2source files doubleHyphens\n\n    IFS=$' \\n\\t'\n    files=()\n    doubleHyphens=false\n\n    if [[ $# -gt 0 ]]; then\n        for arg in \"$@\"; do\n            if $doubleHyphens; then\n                # After we encounter two hyphens together, all the rest\n                # of the arguments are files.\n                files=(\"${files[@]}\" \"$arg\")\n            else\n                case \"$arg\" in\n                    -h|--h|--he|--hel|--help|-\\?)\n                        moUsage \"$0\"\n                        exit 0\n                        ;;\n\n                    --allow-function-arguments)\n                        # shellcheck disable=SC2030\n                        MO_ALLOW_FUNCTION_ARGUMENTS=true\n                        ;;\n\n                    -u | --fail-not-set)\n                        # shellcheck disable=SC2030\n                        MO_FAIL_ON_UNSET=true\n                        ;;\n\n                    -e | --false)\n                        # shellcheck disable=SC2030\n                        MO_FALSE_IS_EMPTY=true\n                        ;;\n\n                    -s=* | --source=*)\n                        if [[ \"$arg\" == --source=* ]]; then\n                            f2source=\"${arg#--source=}\"\n                        else\n                            f2source=\"${arg#-s=}\"\n                        fi\n\n                        if [[ -f \"$f2source\" ]]; then\n                            # shellcheck disable=SC1090\n                            . \"$f2source\"\n                        else\n                            echo \"No such file: $f2source\" >&2\n                            exit 1\n                        fi\n                        ;;\n\n                    --)\n                        # Set a flag indicating we've encountered double hyphens\n                        doubleHyphens=true\n                        ;;\n\n                    *)\n                        # Every arg that is not a flag or a option should be a file\n                        files=(${files[@]+\"${files[@]}\"} \"$arg\")\n                        ;;\n                esac\n            fi\n        done\n    fi\n\n    moGetContent moContent \"${files[@]}\" || return 1\n    moParse \"$moContent\" \"\" true\n)\n\n\n# Internal: Call a function.\n#\n# $1 - Function to call\n# $2 - Content to pass\n# $3 - Additional arguments as a single string\n#\n# This can be dangerous, especially if you are using tags like\n# {{someFunction ; rm -rf / }}\n#\n# Returns nothing.\nmoCallFunction() {\n    local moArgs moFunctionArgs\n\n    moArgs=()\n    moTrimWhitespace moFunctionArgs \"$3\"\n\n    # shellcheck disable=SC2031\n    if [[ -n \"${MO_ALLOW_FUNCTION_ARGUMENTS-}\" ]]; then\n        moArgs=$3\n    fi\n\n    echo -n \"$2\" | MO_FUNCTION_ARGS=\"$moFunctionArgs\" eval \"$1\" \"$moArgs\"\n}\n\n\n# Internal: Scan content until the right end tag is found.  Creates an array\n# with the following members:\n#\n#   [0] = Content before end tag\n#   [1] = End tag (complete tag)\n#   [2] = Content after end tag\n#\n# Everything using this function uses the \"standalone tags\" logic.\n#\n# $1 - Name of variable for the array\n# $2 - Content\n# $3 - Name of end tag\n# $4 - If -z, do standalone tag processing before finishing\n#\n# Returns nothing.\nmoFindEndTag() {\n    local content remaining scanned standaloneBytes tag\n\n    #: Find open tags\n    scanned=\"\"\n    moSplit content \"$2\" '{{' '}}'\n\n    while [[ \"${#content[@]}\" -gt 1 ]]; do\n        moTrimWhitespace tag \"${content[1]}\"\n\n        #: Restore content[1] before we start using it\n        content[1]='{{'\"${content[1]}\"'}}'\n\n        case $tag in\n            '#'* | '^'*)\n                #: Start another block\n                scanned=\"${scanned}${content[0]}${content[1]}\"\n                moTrimWhitespace tag \"${tag:1}\"\n                moFindEndTag content \"${content[2]}\" \"$tag\" \"loop\"\n                scanned=\"${scanned}${content[0]}${content[1]}\"\n                remaining=${content[2]}\n                ;;\n\n            '/'*)\n                #: End a block - could be ours\n                moTrimWhitespace tag \"${tag:1}\"\n                scanned=\"$scanned${content[0]}\"\n\n                if [[ \"$tag\" == \"$3\" ]]; then\n                    #: Found our end tag\n                    if [[ -z \"${4-}\" ]] && moIsStandalone standaloneBytes \"$scanned\" \"${content[2]}\" true; then\n                        #: This is also a standalone tag - clean up whitespace\n                        #: and move those whitespace bytes to the \"tag\" element\n                        standaloneBytes=( $standaloneBytes )\n                        content[1]=\"${scanned:${standaloneBytes[0]}}${content[1]}${content[2]:0:${standaloneBytes[1]}}\"\n                        scanned=\"${scanned:0:${standaloneBytes[0]}}\"\n                        content[2]=\"${content[2]:${standaloneBytes[1]}}\"\n                    fi\n\n                    local \"$1\" && moIndirectArray \"$1\" \"$scanned\" \"${content[1]}\" \"${content[2]}\"\n                    return 0\n                fi\n\n                scanned=\"$scanned${content[1]}\"\n                remaining=${content[2]}\n                ;;\n\n            *)\n                #: Ignore all other tags\n                scanned=\"${scanned}${content[0]}${content[1]}\"\n                remaining=${content[2]}\n                ;;\n        esac\n\n        moSplit content \"$remaining\" '{{' '}}'\n    done\n\n    #: Did not find our closing tag\n    scanned=\"$scanned${content[0]}\"\n    local \"$1\" && moIndirectArray \"$1\" \"${scanned}\" \"\" \"\"\n}\n\n\n# Internal: Find the first index of a substring.  If not found, sets the\n# index to -1.\n#\n# $1 - Destination variable for the index\n# $2 - Haystack\n# $3 - Needle\n#\n# Returns nothing.\nmoFindString() {\n    local pos string\n\n    string=${2%%$3*}\n    [[ \"$string\" == \"$2\" ]] && pos=-1 || pos=${#string}\n    local \"$1\" && moIndirect \"$1\" \"$pos\"\n}\n\n\n# Internal: Generate a dotted name based on current context and target name.\n#\n# $1 - Target variable to store results\n# $2 - Context name\n# $3 - Desired variable name\n#\n# Returns nothing.\nmoFullTagName() {\n    if [[ -z \"${2-}\" ]] || [[ \"$2\" == *.* ]]; then\n        local \"$1\" && moIndirect \"$1\" \"$3\"\n    else\n        local \"$1\" && moIndirect \"$1\" \"${2}.${3}\"\n    fi\n}\n\n\n# Internal: Fetches the content to parse into a variable.  Can be a list of\n# partials for files or the content from stdin.\n#\n# $1   - Variable name to assign this content back as\n# $2-@ - File names (optional)\n#\n# Returns nothing.\nmoGetContent() {\n    local content filename target\n\n    target=$1\n    shift\n    if [[ \"${#@}\" -gt 0 ]]; then\n        content=\"\"\n\n        for filename in \"$@\"; do\n            #: This is so relative paths work from inside template files\n            content=\"$content\"'{{>'\"$filename\"'}}'\n        done\n    else\n        moLoadFile content /dev/stdin || return 1\n    fi\n\n    local \"$target\" && moIndirect \"$target\" \"$content\"\n}\n\n\n# Internal: Indent a string, placing the indent at the beginning of every\n# line that has any content.\n#\n# $1 - Name of destination variable to get an array of lines\n# $2 - The indent string\n# $3 - The string to reindent\n#\n# Returns nothing.\nmoIndentLines() {\n    local content fragment len posN posR result trimmed\n\n    result=\"\"\n\n    #: Remove the period from the end of the string.\n    len=$((${#3} - 1))\n    content=${3:0:$len}\n\n    if [[ -z \"${2-}\" ]]; then\n        local \"$1\" && moIndirect \"$1\" \"$content\"\n\n        return 0\n    fi\n\n    moFindString posN \"$content\" $'\\n'\n    moFindString posR \"$content\" $'\\r'\n\n    while [[ \"$posN\" -gt -1 ]] || [[ \"$posR\" -gt -1 ]]; do\n        if [[ \"$posN\" -gt -1 ]]; then\n            fragment=\"${content:0:$posN + 1}\"\n            content=${content:$posN + 1}\n        else\n            fragment=\"${content:0:$posR + 1}\"\n            content=${content:$posR + 1}\n        fi\n\n        moTrimChars trimmed \"$fragment\" false true \" \" $'\\t' $'\\n' $'\\r'\n\n        if [[ -n \"$trimmed\" ]]; then\n            fragment=\"$2$fragment\"\n        fi\n\n        result=\"$result$fragment\"\n\n        moFindString posN \"$content\" $'\\n'\n        moFindString posR \"$content\" $'\\r'\n\n        # If the content ends in a newline, do not indent.\n        if [[ \"$posN\" -eq ${#content} ]]; then\n            # Special clause for \\r\\n\n            if [[ \"$posR\" -eq \"$((posN - 1))\" ]]; then\n                posR=-1\n            fi\n\n            posN=-1\n        fi\n\n        if [[ \"$posR\" -eq ${#content} ]]; then\n            posR=-1\n        fi\n    done\n\n    moTrimChars trimmed \"$content\" false true \" \" $'\\t'\n\n    if [[ -n \"$trimmed\" ]]; then\n        content=\"$2$content\"\n    fi\n\n    result=\"$result$content\"\n\n    local \"$1\" && moIndirect \"$1\" \"$result\"\n}\n\n\n# Internal: Send a variable up to the parent of the caller of this function.\n#\n# $1 - Variable name\n# $2 - Value\n#\n# Examples\n#\n#   callFunc () {\n#       local \"$1\" && moIndirect \"$1\" \"the value\"\n#   }\n#   callFunc dest\n#   echo \"$dest\"  # writes \"the value\"\n#\n# Returns nothing.\nmoIndirect() {\n    unset -v \"$1\"\n    printf -v \"$1\" '%s' \"$2\"\n}\n\n\n# Internal: Send an array as a variable up to caller of a function\n#\n# $1   - Variable name\n# $2-@ - Array elements\n#\n# Examples\n#\n#   callFunc () {\n#       local myArray=(one two three)\n#       local \"$1\" && moIndirectArray \"$1\" \"${myArray[@]}\"\n#   }\n#   callFunc dest\n#   echo \"${dest[@]}\" # writes \"one two three\"\n#\n# Returns nothing.\nmoIndirectArray() {\n    unset -v \"$1\"\n\n    # IFS must be set to a string containing space or unset in order for\n    # the array slicing to work regardless of the current IFS setting on\n    # bash 3.  This is detailed further at\n    # https://github.com/fidian/gg-core/pull/7\n    eval \"$(printf \"IFS= %s=(\\\"\\${@:2}\\\") IFS=%q\" \"$1\" \"$IFS\")\"\n}\n\n\n# Internal: Determine if a given environment variable exists and if it is\n# an array.\n#\n# $1 - Name of environment variable\n#\n# Be extremely careful.  Even if strict mode is enabled, it is not honored\n# in newer versions of Bash.  Any errors that crop up here will not be\n# caught automatically.\n#\n# Examples\n#\n#   var=(abc)\n#   if moIsArray var; then\n#      echo \"This is an array\"\n#      echo \"Make sure you don't accidentally use \\$var\"\n#   fi\n#\n# Returns 0 if the name is not empty, 1 otherwise.\nmoIsArray() {\n    # Namespace this variable so we don't conflict with what we're testing.\n    local moTestResult\n\n    moTestResult=$(declare -p \"$1\" 2>/dev/null) || return 1\n    [[ \"${moTestResult:0:10}\" == \"declare -a\" ]] && return 0\n    [[ \"${moTestResult:0:10}\" == \"declare -A\" ]] && return 0\n\n    return 1\n}\n\n\n# Internal: Determine if the given name is a defined function.\n#\n# $1 - Function name to check\n#\n# Be extremely careful.  Even if strict mode is enabled, it is not honored\n# in newer versions of Bash.  Any errors that crop up here will not be\n# caught automatically.\n#\n# Examples\n#\n#   moo () {\n#       echo \"This is a function\"\n#   }\n#   if moIsFunction moo; then\n#       echo \"moo is a defined function\"\n#   fi\n#\n# Returns 0 if the name is a function, 1 otherwise.\nmoIsFunction() {\n    local functionList functionName\n\n    functionList=$(declare -F)\n    functionList=( ${functionList//declare -f /} )\n\n    for functionName in \"${functionList[@]}\"; do\n        if [[ \"$functionName\" == \"$1\" ]]; then\n            return 0\n        fi\n    done\n\n    return 1\n}\n\n\n# Internal: Determine if the tag is a standalone tag based on whitespace\n# before and after the tag.\n#\n# Passes back a string containing two numbers in the format \"BEFORE AFTER\"\n# like \"27 10\".  It indicates the number of bytes remaining in the \"before\"\n# string (27) and the number of bytes to trim in the \"after\" string (10).\n# Useful for string manipulation:\n#\n# $1 - Variable to set for passing data back\n# $2 - Content before the tag\n# $3 - Content after the tag\n# $4 - true/false: is this the beginning of the content?\n#\n# Examples\n#\n#   moIsStandalone RESULT \"$before\" \"$after\" false || return 0\n#   RESULT_ARRAY=( $RESULT )\n#   echo \"${before:0:${RESULT_ARRAY[0]}}...${after:${RESULT_ARRAY[1]}}\"\n#\n# Returns nothing.\nmoIsStandalone() {\n    local afterTrimmed beforeTrimmed char\n\n    moTrimChars beforeTrimmed \"$2\" false true \" \" $'\\t'\n    moTrimChars afterTrimmed \"$3\" true false \" \" $'\\t'\n    char=$((${#beforeTrimmed} - 1))\n    char=${beforeTrimmed:$char}\n\n    # If the content before didn't end in a newline\n    if [[ \"$char\" != $'\\n' ]] && [[ \"$char\" != $'\\r' ]]; then\n        # and there was content or this didn't start the file\n        if [[ -n \"$char\" ]] || ! $4; then\n            # then this is not a standalone tag.\n            return 1\n        fi\n    fi\n\n    char=${afterTrimmed:0:1}\n\n    # If the content after doesn't start with a newline and it is something\n    if [[ \"$char\" != $'\\n' ]] && [[ \"$char\" != $'\\r' ]] && [[ -n \"$char\" ]]; then\n        # then this is not a standalone tag.\n        return 2\n    fi\n\n    if [[ \"$char\" == $'\\r' ]] && [[ \"${afterTrimmed:1:1}\" == $'\\n' ]]; then\n        char=\"$char\"$'\\n'\n    fi\n\n    local \"$1\" && moIndirect \"$1\" \"$((${#beforeTrimmed})) $((${#3} + ${#char} - ${#afterTrimmed}))\"\n}\n\n\n# Internal: Join / implode an array\n#\n# $1    - Variable name to receive the joined content\n# $2    - Joiner\n# $3-$* - Elements to join\n#\n# Returns nothing.\nmoJoin() {\n    local joiner part result target\n\n    target=$1\n    joiner=$2\n    result=$3\n    shift 3\n\n    for part in \"$@\"; do\n        result=\"$result$joiner$part\"\n    done\n\n    local \"$target\" && moIndirect \"$target\" \"$result\"\n}\n\n\n# Internal: Read a file into a variable.\n#\n# $1 - Variable name to receive the file's content\n# $2 - Filename to load\n#\n# Returns nothing.\nmoLoadFile() {\n    local content len\n\n    # The subshell removes any trailing newlines.  We forcibly add\n    # a dot to the content to preserve all newlines.\n    # As a future optimization, it would be worth considering removing\n    # cat and replacing this with a read loop.\n\n    content=$(cat -- \"$2\" && echo '.') || return 1\n    len=$((${#content} - 1))\n    content=${content:0:$len}  # Remove last dot\n\n    local \"$1\" && moIndirect \"$1\" \"$content\"\n}\n\n\n# Internal: Process a chunk of content some number of times.  Writes output\n# to stdout.\n#\n# $1   - Content to parse repeatedly\n# $2   - Tag prefix (context name)\n# $3-@ - Names to insert into the parsed content\n#\n# Returns nothing.\nmoLoop() {\n    local content context contextBase\n\n    content=$1\n    contextBase=$2\n    shift 2\n\n    while [[ \"${#@}\" -gt 0 ]]; do\n        moFullTagName context \"$contextBase\" \"$1\"\n        moParse \"$content\" \"$context\" false\n        shift\n    done\n}\n\n\n# Internal: Parse a block of text, writing the result to stdout.\n#\n# $1 - Block of text to change\n# $2 - Current name (the variable NAME for what {{.}} means)\n# $3 - true when no content before this, false otherwise\n#\n# Returns nothing.\nmoParse() {\n    # Keep naming variables mo* here to not overwrite needed variables\n    # used in the string replacements\n    local moArgs moBlock moContent moCurrent moIsBeginning moNextIsBeginning moTag\n\n    moCurrent=$2\n    moIsBeginning=$3\n\n    # Find open tags\n    moSplit moContent \"$1\" '{{' '}}'\n\n    while [[ \"${#moContent[@]}\" -gt 1 ]]; do\n        moTrimWhitespace moTag \"${moContent[1]}\"\n        moNextIsBeginning=false\n\n        case $moTag in\n            '#'*)\n                # Loop, if/then, or pass content through function\n                # Sets context\n                moStandaloneAllowed moContent \"${moContent[@]}\" \"$moIsBeginning\"\n                moTrimWhitespace moTag \"${moTag:1}\"\n\n                # Split arguments from the tag name. Arguments are passed to\n                # functions.\n                moArgs=$moTag\n                moTag=${moTag%% *}\n                moTag=${moTag%%$'\\t'*}\n                moArgs=${moArgs:${#moTag}}\n                moFindEndTag moBlock \"$moContent\" \"$moTag\"\n                moFullTagName moTag \"$moCurrent\" \"$moTag\"\n\n                if moTest \"$moTag\"; then\n                    # Show / loop / pass through function\n                    if moIsFunction \"$moTag\"; then\n                        #: Consider piping the output to moGetContent\n                        #: so the lambda does not execute in a subshell?\n                        moContent=$(moCallFunction \"$moTag\" \"${moBlock[0]}\" \"$moArgs\")\n                        moParse \"$moContent\" \"$moCurrent\" false\n                        moContent=\"${moBlock[2]}\"\n                    elif moIsArray \"$moTag\"; then\n                        eval \"moLoop \\\"\\${moBlock[0]}\\\" \\\"$moTag\\\" \\\"\\${!${moTag}[@]}\\\"\"\n                    else\n                        moParse \"${moBlock[0]}\" \"$moCurrent\" true\n                    fi\n                fi\n\n                moContent=\"${moBlock[2]}\"\n                ;;\n\n            '>'*)\n                # Load partial - get name of file relative to cwd\n                moPartial moContent \"${moContent[@]}\" \"$moIsBeginning\" \"$moCurrent\"\n                moNextIsBeginning=${moContent[1]}\n                moContent=${moContent[0]}\n                ;;\n\n            '/'*)\n                # Closing tag - If hit in this loop, we simply ignore\n                # Matching tags are found in moFindEndTag\n                moStandaloneAllowed moContent \"${moContent[@]}\" \"$moIsBeginning\"\n                ;;\n\n            '^'*)\n                # Display section if named thing does not exist\n                moStandaloneAllowed moContent \"${moContent[@]}\" \"$moIsBeginning\"\n                moTrimWhitespace moTag \"${moTag:1}\"\n                moFindEndTag moBlock \"$moContent\" \"$moTag\"\n                moFullTagName moTag \"$moCurrent\" \"$moTag\"\n\n                if ! moTest \"$moTag\"; then\n                    moParse \"${moBlock[0]}\" \"$moCurrent\" false \"$moCurrent\"\n                fi\n\n                moContent=\"${moBlock[2]}\"\n                ;;\n\n            '!'*)\n                # Comment - ignore the tag content entirely\n                # Trim spaces/tabs before the comment\n                moStandaloneAllowed moContent \"${moContent[@]}\" \"$moIsBeginning\"\n                ;;\n\n            .)\n                # Current content (environment variable or function)\n                moStandaloneDenied moContent \"${moContent[@]}\"\n                moShow \"$moCurrent\" \"$moCurrent\"\n                ;;\n\n            '=')\n                # Change delimiters\n                # Any two non-whitespace sequences separated by whitespace.\n                # This tag is ignored.\n                moStandaloneAllowed moContent \"${moContent[@]}\" \"$moIsBeginning\"\n                ;;\n\n            '{'*)\n                # Unescaped - split on }}} not }}\n                moStandaloneDenied moContent \"${moContent[@]}\"\n                moContent=\"${moTag:1}\"'}}'\"$moContent\"\n                moSplit moContent \"$moContent\" '}}}'\n                moTrimWhitespace moTag \"${moContent[0]}\"\n                moArgs=$moTag\n                moTag=${moTag%% *}\n                moTag=${moTag%%$'\\t'*}\n                moArgs=${moArgs:${#moTag}}\n                moFullTagName moTag \"$moCurrent\" \"$moTag\"\n                moContent=${moContent[1]}\n\n                # Now show the value\n                # Quote moArgs here, do not quote it later.\n                moShow \"$moTag\" \"$moCurrent\" \"$moArgs\"\n                ;;\n\n            '&'*)\n                # Unescaped\n                moStandaloneDenied moContent \"${moContent[@]}\"\n                moTrimWhitespace moTag \"${moTag:1}\"\n                moFullTagName moTag \"$moCurrent\" \"$moTag\"\n                moShow \"$moTag\" \"$moCurrent\"\n                ;;\n\n            *)\n                # Normal environment variable or function call\n                moStandaloneDenied moContent \"${moContent[@]}\"\n                moArgs=$moTag\n                moTag=${moTag%% *}\n                moTag=${moTag%%$'\\t'*}\n                moArgs=${moArgs:${#moTag}}\n                moFullTagName moTag \"$moCurrent\" \"$moTag\"\n\n                # Quote moArgs here, do not quote it later.\n                moShow \"$moTag\" \"$moCurrent\" \"$moArgs\"\n                ;;\n        esac\n\n        moIsBeginning=$moNextIsBeginning\n        moSplit moContent \"$moContent\" '{{' '}}'\n    done\n\n    echo -n \"${moContent[0]}\"\n}\n\n\n# Internal: Process a partial.\n#\n# Indentation should be applied to the entire partial.\n#\n# This sends back the \"is beginning\" flag because the newline after a\n# standalone partial is consumed. That newline is very important in the middle\n# of content. We send back this flag to reset the processing loop's\n# `moIsBeginning` variable, so the software thinks we are back at the\n# beginning of a file and standalone processing continues to work.\n#\n# Prefix all variables.\n#\n# $1 - Name of destination variable. Element [0] is the content, [1] is the\n#      true/false flag indicating if we are at the beginning of content.\n# $2 - Content before the tag that was not yet written\n# $3 - Tag content\n# $4 - Content after the tag\n# $5 - true/false: is this the beginning of the content?\n# $6 - Current context name\n#\n# Returns nothing.\nmoPartial() {\n    # Namespace variables here to prevent conflicts.\n    local moContent moFilename moIndent moIsBeginning moPartial moStandalone moUnindented\n\n    if moIsStandalone moStandalone \"$2\" \"$4\" \"$5\"; then\n        moStandalone=( $moStandalone )\n        echo -n \"${2:0:${moStandalone[0]}}\"\n        moIndent=${2:${moStandalone[0]}}\n        moContent=${4:${moStandalone[1]}}\n        moIsBeginning=true\n    else\n        moIndent=\"\"\n        echo -n \"$2\"\n        moContent=$4\n        moIsBeginning=$5\n    fi\n\n    moTrimWhitespace moFilename \"${3:1}\"\n\n    # Execute in subshell to preserve current cwd and environment\n    (\n        # It would be nice to remove `dirname` and use a function instead,\n        # but that's difficult when you're only given filenames.\n        cd \"$(dirname -- \"$moFilename\")\" || exit 1\n        moUnindented=\"$(\n            moLoadFile moPartial \"${moFilename##*/}\" || exit 1\n            moParse \"${moPartial}\" \"$6\" true\n\n            # Fix bash handling of subshells and keep trailing whitespace.\n            # This is removed in moIndentLines.\n            echo -n \".\"\n        )\" || exit 1\n        moIndentLines moPartial \"$moIndent\" \"$moUnindented\"\n        echo -n \"$moPartial\"\n    ) || exit 1\n\n    # If this is a standalone tag, the trailing newline after the tag is\n    # removed and the contents of the partial are added, which typically\n    # contain a newline. We need to send a signal back to the processing\n    # loop that the moIsBeginning flag needs to be turned on again.\n    #\n    # [0] is the content, [1] is that flag.\n    local \"$1\" && moIndirectArray \"$1\" \"$moContent\" \"$moIsBeginning\"\n}\n\n\n# Internal: Show an environment variable or the output of a function to\n# stdout.\n#\n# Limit/prefix any variables used.\n#\n# $1 - Name of environment variable or function\n# $2 - Current context\n# $3 - Arguments string if $1 is a function\n#\n# Returns nothing.\nmoShow() {\n    # Namespace these variables\n    local moJoined moNameParts\n\n    if moIsFunction \"$1\"; then\n        CONTENT=$(moCallFunction \"$1\" \"\" \"$3\")\n        moParse \"$CONTENT\" \"$2\" false\n        return 0\n    fi\n\n    moSplit moNameParts \"$1\" \".\"\n\n    if [[ -z \"${moNameParts[1]-}\" ]]; then\n        if moIsArray \"$1\"; then\n            eval moJoin moJoined \",\" \"\\${$1[@]}\"\n            echo -n \"$moJoined\"\n        else\n            # shellcheck disable=SC2031\n            if moTestVarSet \"$1\"; then\n                echo -n \"${!1}\"\n            elif [[ -n \"${MO_FAIL_ON_UNSET-}\" ]]; then\n                echo \"Env variable not set: $1\" >&2\n                exit 1\n            fi\n        fi\n    else\n        # Further subindexes are disallowed\n        eval \"echo -n \\\"\\${${moNameParts[0]}[${moNameParts[1]%%.*}]}\\\"\"\n    fi\n}\n\n\n# Internal: Split a larger string into an array.\n#\n# $1 - Destination variable\n# $2 - String to split\n# $3 - Starting delimiter\n# $4 - Ending delimiter (optional)\n#\n# Returns nothing.\nmoSplit() {\n    local pos result\n\n    result=( \"$2\" )\n    moFindString pos \"${result[0]}\" \"$3\"\n\n    if [[ \"$pos\" -ne -1 ]]; then\n        # The first delimiter was found\n        result[1]=${result[0]:$pos + ${#3}}\n        result[0]=${result[0]:0:$pos}\n\n        if [[ -n \"${4-}\" ]]; then\n            moFindString pos \"${result[1]}\" \"$4\"\n\n            if [[ \"$pos\" -ne -1 ]]; then\n                # The second delimiter was found\n                result[2]=\"${result[1]:$pos + ${#4}}\"\n                result[1]=\"${result[1]:0:$pos}\"\n            fi\n        fi\n    fi\n\n    local \"$1\" && moIndirectArray \"$1\" \"${result[@]}\"\n}\n\n\n# Internal: Handle the content for a standalone tag.  This means removing\n# whitespace (not newlines) before a tag and whitespace and a newline after\n# a tag.  That is, assuming, that the line is otherwise empty.\n#\n# $1 - Name of destination \"content\" variable.\n# $2 - Content before the tag that was not yet written\n# $3 - Tag content (not used)\n# $4 - Content after the tag\n# $5 - true/false: is this the beginning of the content?\n#\n# Returns nothing.\nmoStandaloneAllowed() {\n    local bytes\n\n    if moIsStandalone bytes \"$2\" \"$4\" \"$5\"; then\n        bytes=( $bytes )\n        echo -n \"${2:0:${bytes[0]}}\"\n        local \"$1\" && moIndirect \"$1\" \"${4:${bytes[1]}}\"\n    else\n        echo -n \"$2\"\n        local \"$1\" && moIndirect \"$1\" \"$4\"\n    fi\n}\n\n\n# Internal: Handle the content for a tag that is never \"standalone\".  No\n# adjustments are made for newlines and whitespace.\n#\n# $1 - Name of destination \"content\" variable.\n# $2 - Content before the tag that was not yet written\n# $3 - Tag content (not used)\n# $4 - Content after the tag\n#\n# Returns nothing.\nmoStandaloneDenied() {\n    echo -n \"$2\"\n    local \"$1\" && moIndirect \"$1\" \"$4\"\n}\n\n\n# Internal: Determines if the named thing is a function or if it is a\n# non-empty environment variable.  When MO_FALSE_IS_EMPTY is set to a\n# non-empty value, then \"false\" is also treated is an empty value.\n#\n# Do not use variables without prefixes here if possible as this needs to\n# check if any name exists in the environment\n#\n# $1                - Name of environment variable or function\n# $2                - Current value (our context)\n# MO_FALSE_IS_EMPTY - When set to a non-empty value, this will say the\n#                     string value \"false\" is empty.\n#\n# Returns 0 if the name is not empty, 1 otherwise.  When MO_FALSE_IS_EMPTY\n# is set, this returns 1 if the name is \"false\".\nmoTest() {\n    # Test for functions\n    moIsFunction \"$1\" && return 0\n\n    if moIsArray \"$1\"; then\n        # Arrays must have at least 1 element\n        eval \"[[ \\\"\\${#${1}[@]}\\\" -gt 0 ]]\" && return 0\n    else\n        # If MO_FALSE_IS_EMPTY is set, then return 1 if the value of\n        # the variable is \"false\".\n        # shellcheck disable=SC2031\n        [[ -n \"${MO_FALSE_IS_EMPTY-}\" ]] && [[ \"${!1-}\" == \"false\" ]] && return 1\n\n        # Environment variables must not be empty\n        [[ -n \"${!1-}\" ]] && return 0\n    fi\n\n    return 1\n}\n\n# Internal: Determine if a variable is assigned, even if it is assigned an empty\n# value.\n#\n# $1 - Variable name to check.\n#\n# Returns true (0) if the variable is set, 1 if the variable is unset.\nmoTestVarSet() {\n    [[ \"${!1-a}\" == \"${!1-b}\" ]]\n}\n\n\n# Internal: Trim the leading whitespace only.\n#\n# $1   - Name of destination variable\n# $2   - The string\n# $3   - true/false - trim front?\n# $4   - true/false - trim end?\n# $5-@ - Characters to trim\n#\n# Returns nothing.\nmoTrimChars() {\n    local back current front last target varName\n\n    target=$1\n    current=$2\n    front=$3\n    back=$4\n    last=\"\"\n    shift 4 # Remove target, string, trim front flag, trim end flag\n\n    while [[ \"$current\" != \"$last\" ]]; do\n        last=$current\n\n        for varName in \"$@\"; do\n            $front && current=\"${current/#$varName}\"\n            $back && current=\"${current/%$varName}\"\n        done\n    done\n\n    local \"$target\" && moIndirect \"$target\" \"$current\"\n}\n\n\n# Internal: Trim leading and trailing whitespace from a string.\n#\n# $1 - Name of variable to store trimmed string\n# $2 - The string\n#\n# Returns nothing.\nmoTrimWhitespace() {\n    local result\n\n    moTrimChars result \"$2\" true true $'\\r' $'\\n' $'\\t' \" \"\n    local \"$1\" && moIndirect \"$1\" \"$result\"\n}\n\n\n# Internal: Displays the usage for mo.  Pulls this from the file that\n# contained the `mo` function.  Can only work when the right filename\n# comes is the one argument, and that only happens when `mo` is called\n# with `$0` set to this file.\n#\n# $1 - Filename that has the help message\n#\n# Returns nothing.\nmoUsage() {\n    grep '^#/' \"${MO_ORIGINAL_COMMAND}\" | cut -c 4-\n    echo \"\"\n    set | grep ^MO_VERSION=\n}\n\n\nMO_VERSION=\"2.0.4\"\n\n# If sourced, load all functions.\n# If executed, perform the actions as expected.\nif [[ \"$0\" == \"${BASH_SOURCE[0]}\" ]] || [[ -z \"${BASH_SOURCE[0]}\" ]]; then\n    mo \"$@\"\nfi\n"
        },
        {
          "name": "variables",
          "type": "blob",
          "size": 0.3994140625,
          "content": "# read global variables\n[[ -e $inventory_dir/variables ]] && source $inventory_dir/variables\n\n# read caller variables from the module\nread -r _ caller_path <<< $(caller)\ncaller_variables=$(dirname $caller_path)/variables\n[ -e $caller_variables ] && source $caller_variables\n\n# read host variables\nmachine_variables=inventory/hosts/$(hostname)/variables\n[ -e $machine_variables ] && source $machine_variables\n\n"
        }
      ]
    }
  ]
}