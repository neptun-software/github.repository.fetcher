{
  "metadata": {
    "timestamp": 1736568705053,
    "page": 798,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "liquanzhou/ops_doc",
      "stars": 1225,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.1611328125,
          "content": "## ops_doc\n\n  文档制作: 雪松\n  \n  更新日期: 2016-04-28\n  \n  本文档手册希望可以达到通俗易懂，方便运维人员使用，错误在所难免，还望指正！\n\n  github更新下载地址:  https://github.com/liquanzhou/ops_doc\n  \n  请勿删除信息，转载请说明出处，抵制不道德行为\n  \n  \n  \n  \n  \n  \n### 一.总是听到有说: \n  \n#### 1.运维累，背锅，薪资低?\n\n运维没做好，没有核心技能，肯定是累且背锅，薪资涨不上去。各行各业皆是如此，最底层都是一滩烂泥，不仅仅是运维行业。小事(运维处理个磁盘，处理个内存报警)其实就能体现出来能力. 太多运维都是处理表面问题，根本不去真正了解需求，也不去思考解决办法，不用心去把事情做漂亮，成长也基本止步，指望这类人去搞点创新，解决点难题，基本不可能，反过来想这种人怎么可能高工资?\n做任何行业都一样，重要的是思考: 怎么差异化，怎么脱颖而出，做出与众不同，怎么做到核心精英.\n\n#### 2.运维开发的自动化取代运维?\n\n运维开发只是运维的一个技能分支，不需要神话运维开发。大多是培训招生鼓吹，运维开发淘汰运维。只做运维开发，不了解运维业务，做的系统平台怎么可能好用？\n不了解业务，平台实现无法统一标准，统一流程。\n\n#### 3.云平台取代运维?\n\n云商资源是工具，业务问题是云商无法解决干预的，需要专业运维人员使用拼接。\n\n#### 4.人工智能取代运维?\n\n人工智能类似GPT取代运维更是不可能，只会更好的帮助运维工作。高级运维要在架构能力，主导能力，灵活运用，解决各种复杂难题，并不是人工智能直接给出的建议就能解决。\n  \n\n\n### 二.做好本职工作:\n\n坚持本心，切勿浮躁，避免被他人干扰。\n\n不了解运维痛点，不解决业务难题，无论运维，SRE，运维开发都是做不好的。\n\n干活前多统计，多准备，多思考规避问题，多考虑简化方案。干的时候先挑大块的标准化的方式搞\n\n见过运维技术好，搭建各种服务效率，各种参数都知道，可唯独没有任何标准化思维，导致工作累，业务又频繁故障。\n\n运维岗位比其他技术岗位更了解技术架构全链路，很多开发和架构解决不了的问题只能依靠运维。\n\n做运维部门核心技术人员，核心技术能力才能让自己不可替代。不要区分运维和运维开发，两方面能力都重要。\n\n\n \n \n\n\n### 三.针对运维岗位的一点经验看法:\n  \n##### 做好技术，技术到了一定程度，多考虑业务。核心是用技术解决业务上的难题，想办法从根本原因解决问题。不能只解决表面问题。少一些花里胡哨的技术和流程。\n##### 多花心思考虑实用性，稳定性，运维可协同维护，开发的用户体验等。\n##### 多梳理业务，没什么解决不了的难题。\n##### 多主导业务，技术和能力才能提高质变。\n##### 监控(三层兜底监控和多维度的监控)和发布(打包，发布，服务注册，平滑上线，流量接入，自动扩容)是最核心重要的工作，需要反复打磨，简单好用，好协同。\n##### 工作标准要高，不能只搞表面，才能不被其他部门骂。\n\n\n统一业务标准化: 环境一致，数据一致，流程一致。最后才是自动化的实现。\n  \n业务可观测: 故障第一时间可以报警，链路可追踪，监控图表可事后分析。减少无用信息，快捷有效。\n  \n业务稳定性: 稳定是核心标准，处理故障后，多分析原因始末，多和业务方和架构师探讨交流，积累架构经验。\n  \n  \n  \n### 四.针对k8s使用的一点经验看法:\n\n\n好多公司运维部门都是积极使用k8s，但没有规划的使用又会引起好多不易维护的难点痛点:\n\n\n1.缺少自动化，导致繁重的人肉维护大量yaml文件\n\n\n如果可以，k8s内部的yaml尽量规避任何人肉改动，全部发布系统标准化生成(deployment，service，hpa，inrgess，vs等等全部统一与模板一致).规避复杂的7层路由策略在k8s中做.尽可能对外入口统一，k8s流量接入与deployment一一对应，就可以实现k8s内部全部标准化自动生成\n\n\n2.无法统一注册中心，每组k8s有各自的etcd注册，两组k8s中服务互联就会有麻烦，开发可能更喜欢服务框架依赖的各自注册发现方式.导致流量接入混乱.流量平滑，维护复杂，多语言服务互联障碍.\n\n\n这个情况，要看实际业务场景，多与开发架构师沟通方案，如何推动统一注册发现机制，让开发互调流量和运维的流量接入统一\n\n\n\n\n### 五.新工作环境梳理工作思路:\n\n\n1.优先解决棘手的业务稳定问题\n\n\n2.多维度监控，确保第一时间发现问题，定位问题根因\n\n\n3.多与架构交流，沟通稳定性解决方案\n\n\n4.统一打包和发布，定好标准的全流程，拒绝开发各异的方式，但还能支持开发多种合理的需求，有足够的扩展能力\n\n\n5.提升自动化工作范围\n\n\n6.成本控制\n\n\n7.精准报警，清理无用大量报警\n\n\n8.清理无用5xx错误，程序error干扰\n\n\n\n### 六.中小公司做到如下标准,就能解决大部分运维痛点:\n\n##### 运维标准:\n\n1.服务全部标准化,统一打包和部署方式\n\n2.监控图精准易用\n\n3.监控报警灵敏,避免重复检查次数,触发即报警\n\n4.报警维度健全\n\n5.尽可能自动化\n\n6.自动扩容(需要服务上下线平滑)\n\n7.cdn和存储主备自动切换\n\n8.跨境质量\n\n\n##### 开发标准:\n\n1.程序日志级别可靠,通过error数量报警\n\n2.程序状态码标准,通过5xx状态码报警\n\n3.核心服务降级\n\n\n##### 架构标准:\n\n1.统一健康检查接口\n\n2.统一下线接口\n\n3.全局服务统一注册,不区分语言和服务类型\n\n4.注册有权重\n\n5.调用方可根据5xx错误次数进行权重熔断\n\n6.发布过程平滑,启动预热(可基于权重小流量)\n\n7.服务调用打点,调用服务名,被调用服务名,uri,状态\n\n8.日志规范可收集\n\n9.链路跟踪,前后端串联\n\n10.限流,应对雪崩场景\n\n11.响应时间\n\n12.mysql限制全局兜底limit\n\n13.ABtest能力\n\n"
        },
        {
          "name": "Service",
          "type": "tree",
          "content": null
        },
        {
          "name": "python实例手册.py",
          "type": "blob",
          "size": 287.8330078125,
          "content": "    python实例手册\n\n#encoding:utf8\n# 设定编码-支持中文\n\n0 说明\n\n    手册制作: 雪松 littlepy www.51reboot.com\n    更新日期: 2020-03-06\n\n    欢迎系统运维加入Q群: 198173206  # 加群请回答问题\n    欢迎运维开发加入Q群: 365534424  # 不定期技术分享\n\n    请使用\"notepad++\"或其它编辑器打开此文档, \"alt+0\"将函数折叠后方便查阅\n    请勿删除信息, 转载请说明出处, 抵制不道德行为\n    错误在所难免, 还望指正！\n\n    [python实例手册] [shell实例手册] [LazyManage运维批量管理(shell/python两个版本)]\n    github更新下载地址:  https://github.com/liquanzhou/ops_doc\n\n1 基础\n\n    安装python2.7\n\n        wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz\n\n        tar xvf Python-2.7.9.tgz\n        cd Python-2.7.9\n        ./configure --prefix=/usr/local/python27\n        make\n        make install\n        mv /usr/bin/python /usr/bin/python_old\n        ln -s /usr/local/python27/bin/python /usr/bin/python\n        python          # 查看版本\n\n    解决YUM无法使用的问题\n\n       vim /usr/bin/yum\n       vim /usr/bin/repoquery\n       两文件首行#!/usr/bin/python 替换为老版本python  #!/usr/bin/python2.6  注意可能为2.4\n\n    pip模块安装\n\n        yum install python-pip            # centos安装pip\n        sudo apt-get install python-pip   # ubuntu安装pip\n        pip官方安装脚本\n            wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py\n            python get-pip.py\n        pip编译安装\n            # https://pypi.python.org/pypi/setuptools\n            wget http://pypi.python.org/packages/source/s/setuptools/setuptools.tar.gz\n            tar zxvf setuptools.tar.gz\n            cd setuptools/\n            python setup.py build\n            python setup.py install\n            # https://pypi.python.org/pypi/ez_setup\n            tar zxvf ez_setup.tar.gz\n            cd ez_setup/\n            python setup.py build\n            python setup.py install\n            # https://pypi.python.org/pypi/pip\n            tar zxvf pip.tar.gz\n            cd pip/\n            python setup.py build\n            python setup.py install\n        加载环境变量\n            vim /etc/profile\n            export PATH=/usr/local/python27/bin:$PATH\n            . /etc/profile\n\n        pip freeze                      # 查看包版本\n        pip install -r file             # 安装包文件列表\n        pip install Package             # 安装包 pip install requests\n        pip show --files Package        # 查看安装包时安装了哪些文件\n        pip show --files Package        # 查看哪些包有更新\n        pip install --upgrade Package   # 更新一个软件包\n        pip uninstall Package           # 卸载软件包\n        pip list                        # 查看pip安装的包及版本\n        pip install django==1.5         # 指定版本安装\n        pip install  kafka-python -i http://pypi.douban.com/simple --trusted-host pypi.douban.com\n\n\n    python3安装\n        yum install python36.x86_64 python36-pip\n\n    查看帮助\n\n        python -c \"help('modules')\"     # 查看python所有模块\n        import os\n        for i in dir(os):\n            print i         # 模块的方法\n        help(os.path)       # 方法的帮助\n\n    python中关键字\n\n        import keyword\n        keyword.iskeyword(str)       # 字符串是否为python关键字\n        keyword.kwlist               # 返回pytho所有关键字\n        ['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n    调试\n\n        python -m trace -t aaaaaa.py\n        strace -p pid       # 用系统命令跟踪系统调用\n\n    变量\n\n        r=r'\\n'          # 输出时原型打印\n        u=u'中文'        # 定义为unicode编码\n        global x         # 全局变量\n        a = 0 or 2 or 1  # 布尔运算赋值,a值为True既不处理后面,a值为2.  None、字符串''、空元组()、空列表[],空字典{}、0、空字符串都是false\n        name = raw_input(\"input:\").strip()        # 输入字符串变量\n        num = int(raw_input(\"input:\").strip())    # 输入字符串str转为int型\n        locals()                                  # 所有局部变量组成的字典\n        locals().values()                         # 所有局部变量值的列表\n        os.popen(\"date -d @{0} +'%Y-%m-%d %H:%M:%S'\".format(12)).read()    # 特殊情况引用变量 {0} 代表第一个参数\n\n        基于字典的字符串格式化\n            params = {\"server\":\"mpilgrim\", \"database\":\"master\", \"uid\":\"sa\", \"pwd\":\"secret\"}\n            \"%(pwd)s\" % params                                         # 'secret'\n            \"%(pwd)s is not a good password for %(uid)s\" % params      # 'secret is not a good password for sa'\n            \"%(database)s of mind, %(database)s of body\" % params      # 'master of mind, master of body'\n\n    打印\n\n        # 字符串 %s  整数 %d  浮点 %f  原样打印 %r\n        print '字符串: %s 整数: %d 浮点: %f 原样打印: %r' % ('aa',2,1.0,'r')\n        print 'abc',      # 有逗号,代表不换行打印,在次打印会接着本行打印\n\t\tprint '%-10s %s' % ('aaa','bbb')    # 左对齐 占10个字符\n\t\tprint '%10s %s' % ('aaa','bbb')     # 右对齐 占10个字符\n\n    列表\n\n        # 列表元素的个数最多 536870912\n        shoplist = ['apple', 'mango', 'carrot', 'banana']\n        shoplist[2] = 'aa'\n        del shoplist[0]\n        shoplist.insert(4,'www')\n        shoplist.append('aaa')\n        shoplist[::-1]    # 倒着打印 对字符翻转串有效\n        shoplist[2::3]    # 从第二个开始每隔三个打印\n        shoplist[:-1]     # 排除最后一个\n        '\\t'.join(li)     # 将列表转字符串 用字表符分割\n        sys.path[1:1]=[5] # 在位置1前面插入列表中一个值\n        list(set(['qwe', 'as', '123', '123']))   # 将列表通过集合去重复\n        eval(\"['1','a']\")                        # 将字符串当表达式求值,得到列表\n\n        # enumerate 可得到每个值的对应位置\n        for i, n in enumerate(['a','b','c']):\n            print i,n\n\n    元组\n\n        # 不可变\n        zoo = ('wolf', 'elephant', 'penguin')\n\n    字典\n\n        ab = {       'Swaroop'   : 'swaroopch@byteofpython.info',\n                     'Larry'     : 'larry@wall.org',\n             }\n        ab['c'] = 80      # 添加字典元素\n        del ab['Larry']   # 删除字典元素\n        ab.keys()         # 查看所有键值\n        ab.values()       # 打印所有值\n        ab.has_key('a')   # 查看键值是否存在\n        ab.items()        # 返回整个字典列表\n\n        复制字典\n            a = {1: {1: 2, 3: 4}}\n            b = a\n            b[1][1] = 8888                # a和b都为 {1: {1: 8888, 3: 4}}\n            import copy\n            c = copy.deepcopy(a)          # 再次赋值 b[1][1] = 9999 拷贝字典为新的字典,互不干扰\n\n            a[2] = copy.deepcopy(a[1])    # 复制出第二个key，互不影响  {1: {1: 2, 3: 4},2: {1: 2, 3: 4}}\n\n    迭代器\n\n        # 创建迭代接口，而不是原来的对象 支持字符串、列表和字典等序列对象\n        i = iter('abcd')\n        print i.next()\n\n        s = {'one':1,'two':2,'three':3}\n        m = iter(s)\n        print m.next()                     # 迭代key\n\n    流程结构\n\n        if判断\n\n            # 布尔值操作符 and or not 实现多重判断\n            if a == b:\n                print '=='\n            elif a < b:\n                print b\n            else:\n                print a\n\n        while循环\n\n            while True:\n                if a == b:\n                    print \"==\"\n                    break\n                print \"!=\"\n            else:\n                print 'over'\n\n            count=0\n            while(count<9):\n                print count\n                count += 1\n\n        for循环\n\n            sorted()           # 返回一个序列(列表)\n            zip()              # 返回一个序列(列表)\n            enumerate()        # 返回循环列表序列 for i,v in enumerate(['a','b']):\n            reversed()         # 反序迭代器对象\n            dict.iterkeys()    # 通过键迭代\n            dict.itervalues()  # 通过值迭代\n            dict.iteritems()   # 通过键-值对迭代\n            readline()         # 文件迭代\n            iter(obj)          # 得到obj迭代器 检查obj是不是一个序列\n            iter(a,b)          # 重复调用a,直到迭代器的下一个值等于b\n            for i in range(1, 5):\n                print i\n            else:\n                print 'over'\n\n            list = ['a','b','c','b']\n            for i in range(len(list)):\n                print list[i]\n            for x, Lee in enumerate(list):\n                print \"%d %s Lee\" % (x+1,Lee)\n\n            # enumerate 使用函数得到索引值和对应值\n            for i, v in enumerate(['tic', 'tac', 'toe']):\n                print(i, v)\n\n        流程结构简写\n\n            [ i * 2 for i in [8,-2,5]]\n            [16,-4,10]\n            [ i for i in range(8) if i %2 == 0 ]\n            [0,2,4,6]\n\n    tab补全\n\n        # vim /usr/lib/python2.7/dist-packages/tab.py\n        # python startup file\n        import sys\n        import readline\n        import rlcompleter\n        import atexit\n        import os\n        # tab completion\n        readline.parse_and_bind('tab: complete')\n        # history file\n        histfile = os.path.join(os.environ['HOME'], '.pythonhistory')\n\n    函数\n\n        def printMax(a, b = 1):\n            if a > b:\n                print a\n                return a\n            else:\n                print b\n                return b\n        x = 5\n        y = 7\n        printMax(x, y)\n\n        def update(*args,**kwargs):\n            p=''\n            for i,t in kwargs.items():\n                    p = p+ '%s=%s,' %(i,str(t))\n            sql = \"update  'user' set (%s) where (%s)\" %(args[0],p)\n            print sql\n\n        update('aaa',uu='uu',id=3)\n\n    模块\n\n        # Filename: mymodule.py\n        def sayhi():\n            print 'mymodule'\n        version = '0.1'\n\n        # 使用模块中方法\n        import mymodule\n        from mymodule import sayhi, version\n        mymodule.sayhi()   # 使用模块中函数方法\n\n    装饰器\n\n        # 为已存在的功能添加额外的功能,只在初始化脚本的时候执行一次\n\n        #!/usr/bin/env python\n\n        def deco(func):\n            def wrapper(*args, **kwargs):\n                print \"Wrap start\"\n                func(*args, **kwargs)\n                func(*args, **kwargs)\n                print \"Wrap end\\n\"\n            return wrapper\n\n        @deco\n        def foo(x):\n            print \"In foo():\"\n            print \"I have a para: %s\" % x\n        @deco\n        def foo_dict(x,z='dict_para'):\n            print \"In foo_dict:\"\n            print \"I have two para, %s and %s\" % (x, z)\n\n        if __name__ == \"__main__\":\n            # 装饰器 @deco  等价于 foo = deco(foo)\n            foo('x')\n            foo_dict('x', z='dict_para')\n\n        结果\n\n            Wrap start\n            In foo():\n            I have a para: x\n            In foo():\n            I have a para: x\n            Wrap end\n\n            Wrap start\n            In foo_dict:\n            I have two para, x and dict_para\n            In foo_dict:\n            I have two para, x and dict_para\n            Wrap end\n\n    类对象的方法\n\n        __xxx__               # 系统定义名字\n        __init__              # 实例化初始化类的方法\n        __all__ = ['xs']      # __all__ 用于模块import导入时限制,定义了只有all内指定的属性、方法、类可被导入,没定义则模块内的所有将被导入\n        _xxx                  # _开头的为私有类,只有类对象和子类对象自己能访问到这些变量  不能用 from module import * 导入  class _status:\n        __xxx                 # __开头的为类中的私有变量名,只有类对象自己能访问,连子类对象也不能访问到这个数据\n\n        class Person:\n            # 实例化初始化的方法\n            def __init__(self, name ,age):\n                self.name = name\n                self.age = age\n                print self.name\n            # 有self此函数为方法\n            def sayHi(self):\n                print 'Hello, my name is', self.name\n            # 对象消逝的时候被调用\n            def __del__(self):\n                print 'over'\n        # 实例化对象\n        p = Person('Swaroop',23)\n        # 使用对象方法\n        p.sayHi()\n        # 继承\n        class Teacher(Person):\n            def __init__(self, name, age, salary):\n                Person.__init__(self, name, age)\n                self.salary = salary\n                print '(Initialized Teacher: %s)' % self.name\n            def tell(self):\n                Person.tell(self)\n                print 'Salary: \"%d\"' % self.salary\n        t = Teacher('Mrs. Shrividya', 40, 30000)\n\n        getattr(object,name,default)\n\n            # 返回object的名称为name的属性的属性值,如果属性name存在,则直接返回其属性值.如果属性name不存在,则触发AttribetError异常或当可选参数default定义时返回default值\n\n            class A:\n                def __init__(self):\n                    self.name = 'zhangjing'\n                def method(self):\n                    print\"method print\"\n\n            Instance = A()\n            print getattr(Instance, 'name',   'not find')          # 如果Instance 对象中有属性name则打印self.name的值，否则打印'not find'\n            print getattr(Instance, 'age',    'not find')          # 如果Instance 对象中有属性age则打印self.age的值，否则打印'not find'\n            print getattr(Instance, 'method', 'default')           # 如果有方法method，否则打印其地址，否则打印default\n            print getattr(Instance, 'method', 'default')()         # 如果有方法method，运行函数并打印None否则打印default\n\n        setattr(object,name,value)\n\n            # 设置object的名称为name(type：string)的属性的属性值为value，属性name可以是已存在属性也可以是新属性。\n\n            #等同多次 self.name = name 赋值 在外部可以直接把变量和值对应关系传进去\n            #class Person:\n            #    def __init__(self, name ,age):\n            #        self.name = name\n            #        self.age = age\n\n            config = {'name':'name','age','age'}\n            class Configure(object):\n                def __init__(self, config):\n                    self.register(config)\n\n                def register(self, config):\n                    for key, value in config.items():\n                        if key.upper() == key:\n                            setattr(self, key, value)\n\n    模块包\n\n        # 文件 ops/fileserver/__init__.py\n        import readers\n        import writers\n\n        # 每个模块的包中，都有一个 __init__.py 文件，有了这个文件，才能导入这个目录下的module，在导入一个包时 import ops.fileserver ，实际上是导入了它的 __init__.py 文件，可以再 __init__.py 文件中再导入其他的包，或者模块。就不需要将所有的import语句写在一个文件里了，也可以减少代码量，不需要一个个去导入module了。\n        # __init__.py 有一个重要的变量 __all__ 。有时会需要全部导入，from PackageName import *   ，这时 import 就会把注册在包 __init__.py 文件中 __all__ 列表中的子模块和子包导入到当前作用域中来。如：\n        __all__ = [\"Module1\", \"Module2\", \"subPackage1\", \"subPackage2\"]\n\n    执行模块类中的所有方法\n\n        # moniItems.py\n        import sys, time\n        import inspect\n\n        class mon:\n            def __init__(self):\n                self.data = dict()\n            def run(self):\n                return self.runAllGet()\n            def getDisk(self):\n                return 222\n            def getCpu(self):\n                return 111\n            def runAllGet(self):\n                for fun in inspect.getmembers(self, predicate=inspect.ismethod):\n                    print fun[0], fun[1]\n                    if fun[0][:3] == 'get':\n                        self.data[fun[0][3:]] = fun[1]()\n                print self.data\n                return self.data\n\n        # 模块导入使用\n        from moniItems import mon\n        m = mon()\n        m.runAllGet()\n\n    文件处理\n\n        # 模式: 读'r'  写[清空整个文件]'w' 追加[文件需要存在]'a' 读写'r+' 二进制文件'b'  'rb','wb','rb+'\n\n        写文件\n            i={'ddd':'ccc'}\n            f = file('poem.txt', 'a')\n            f.write(\"string\")\n            f.write(str(i))\n            f.flush()\n            f.close()\n\n        读文件\n            f = file('/etc/passwd','r')\n            c = f.read().strip()        # 读取为一个大字符串，并去掉最后一个换行符\n            for i in c.split('\\n'):     # 用换行符切割字符串得到列表循环每行\n                print i\n            f.close()\n\n        读文件1\n            f = file('/etc/passwd','r')\n            while True:\n                line = f.readline()    # 返回一行\n                if len(line) == 0:\n                    break\n                x = line.split(\":\")                  # 冒号分割定义序列\n                #x = [ x for x in line.split(\":\") ]  # 冒号分割定义序列\n                #x = [ x.split(\"/\") for x in line.split(\":\") ]  # 先冒号分割,在/分割 打印x[6][1]\n                print x[6],\"\\n\",\n            f.close()\n\n        读文件2\n            f = file('/etc/passwd')\n            c = f.readlines()       # 读入所有文件内容,可反复读取,大文件时占用内存较大\n            for line in c:\n                print line.rstrip(),\n            f.close()\n\n        读文件3\n            for i in open('b.txt'):   # 直接读取也可迭代,并有利于大文件读取,但不可反复读取\n                print i,\n\n        追加日志\n            log = open('/home/peterli/xuesong','a')\n            print >> log,'faaa'\n            log.close()\n\n        with读文件\n\n            # 自动关闭文件、线程锁的自动获取和释放等\n            with open('a.txt') as f:\n                for i in f:\n                    print i\n                print f.read()        # 打印所有内容为字符串\n                print f.readlines()   # 打印所有内容按行分割的列表\n\n        文件随机读写\n\n            # 文件本没有换行,一切都是字符,文件也没有插入功能\n            f.tell()       # 当前读写位置\n            f.read(5)      # 读取5个字符并改变指针\n            f.seek(5)      # 改变用户态读写指针偏移位置,可做随机写\n            f.seek(p,0)    # 移动当文件第p个字节处，绝对位置\n            f.seek(p,1)    # 移动到相对于当前位置之后的p个字节\n            f.seek(p,2)    # 移动到相对文件尾之后的p个字节\n            f.seek(0,2)    # 指针指到尾部\n            # 改变指针超出文件尾部,会造成文件洞,ll看占用较大，但du -sh却非常小\n            f.read(65535)  # 读取64K字节\n            f.write(\"str\") # 写会覆盖当前指针后的响应字符,无插入功能\n\n    内建函数\n\n        dir(sys)            # 显示对象的属性\n        help(sys)           # 交互式帮助\n        int(obj)            # 转型为整形\n        str(obj)            # 转为字符串\n        len(obj)            # 返回对象或序列长度\n        open(file,mode)     # 打开文件 #mode (r 读,w 写, a追加)\n        range(0,3)          # 返回一个整形列表\n        raw_input(\"str:\")   # 等待用户输入\n        type(obj)           # 返回对象类型\n        abs(-22)            # 绝对值\n        random              # 随机数\n        choice()            # 随机返回给定序列的一个元素\n        divmod(x,y)         # 函数完成除法运算，返回商和余数。\n        round(x[,n])        # 函数返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数\n        strip()             # 是去掉字符串两端多于空格,该句是去除序列中的所有字串两端多余的空格\n        del                 # 删除列表里面的数据\n        cmp(x,y)            # 比较两个对象    #根据比较结果返回一个整数，如果x<y，则返回-1；如果x>y，则返回1,如果x==y则返回0\n        max()               # 字符串中最大的字符\n        min()               # 字符串中最小的字符\n        sorted()            # 对序列排序\n        reversed()          # 对序列倒序\n        enumerate()         # 返回索引位置和对应的值\n        sum()               # 总和\n        list()              # 变成列表可用于迭代\n        eval('3+4')         # 将字符串当表达式求值 得到7\n        exec 'a=100'        # 将字符串按python语句执行\n        exec(a+'=new')      # 将变量a的值作为新的变量\n        tuple()             # 变成元组可用于迭代   #一旦初始化便不能更改的数据结构,速度比list快\n        zip(s,t)            # 返回一个合并后的列表  s = ['11','22']  t = ['aa','bb']  [('11', 'aa'), ('22', 'bb')]\n        isinstance(object,int)    # 测试对象类型 int\n        xrange([lower,]stop[,step])            # 函数与range()类似，但xrnage()并不创建列表，而是返回一个xrange对象\n\n    列表类型内建函数\n\n        list.append(obj)                 # 向列表中添加一个对象obj\n        list.count(obj)                  # 返回一个对象obj在列表中出现的次数\n        list.extend(seq)                 # 把序列seq的内容添加到列表中\n        list.index(obj,i=0,j=len(list))  # 返回list[k] == obj 的k值,并且k的范围在i<=k<j;否则异常\n        list.insert(index.obj)           # 在索引量为index的位置插入对象obj\n        list.pop(index=-1)               # 删除并返回指定位置的对象,默认是最后一个对象\n        list.remove(obj)                 # 从列表中删除对象obj\n        list.reverse()                   # 原地翻转列表\n        list.sort(func=None,key=None,reverse=False)  # 以指定的方式排序列表中成员,如果func和key参数指定,则按照指定的方式比较各个元素,如果reverse标志被置为True,则列表以反序排列\n\n    序列类型操作符\n\n        seq[ind]              # 获取下标为ind的元素\n        seq[ind1:ind2]        # 获得下标从ind1到ind2的元素集合\n        seq * expr            # 序列重复expr次\n        seq1 + seq2           # 连接seq1和seq2\n        obj in seq            # 判断obj元素是否包含在seq中\n        obj not in seq        # 判断obj元素是否不包含在seq中\n\n    字符串类型内建方法\n\n        string.expandtabs(tabsize=8)                  # tab符号转为空格 #默认8个空格\n        string.endswith(obj,beg=0,end=len(staring))   # 检测字符串是否已obj结束,如果是返回True #如果beg或end指定检测范围是否已obj结束\n        string.count(str,beg=0,end=len(string))       # 检测str在string里出现次数  f.count('\\n',0,len(f)) 判断文件行数\n        string.find(str,beg=0,end=len(string))        # 检测str是否包含在string中\n        string.index(str,beg=0,end=len(string))       # 检测str不在string中,会报异常\n        string.isalnum()                              # 如果string至少有一个字符并且所有字符都是字母或数字则返回True\n        string.isalpha()                              # 如果string至少有一个字符并且所有字符都是字母则返回True\n        string.isnumeric()                            # 如果string只包含数字字符,则返回True\n        string.isspace()                              # 如果string包含空格则返回True\n        string.isupper()                              # 字符串都是大写返回True\n        string.islower()                              # 字符串都是小写返回True\n        string.lower()                                # 转换字符串中所有大写为小写\n        string.upper()                                # 转换字符串中所有小写为大写\n        string.lstrip()                               # 去掉string左边的空格\n        string.rstrip()                               # 去掉string字符末尾的空格\n        string.replace(str1,str2)                     # 把string中的str1替换成str2,如果num指定,则替换不超过num次\n        string.startswith(obj,beg=0,end=len(string))  # 检测字符串是否以obj开头\n        string.zfill(width)                           # 返回字符长度为width的字符,原字符串右对齐,前面填充0\n        string.isdigit()                              # 只包含数字返回True\n        string.split(\"/\")                             # 把string切片成一个列表\n        \":\".join(string.split())                      # 以:作为分隔符,将所有元素合并为一个新的字符串\n\n    字典内建方法\n\n        dict.clear()                            # 删除字典中所有元素\n        dict copy()                             # 返回字典(浅复制)的一个副本\n        dict.fromkeys(seq,val=None)             # 创建并返回一个新字典,以seq中的元素做该字典的键,val做该字典中所有键对的初始值\n        dict.get(key,default=None)              # 对字典dict中的键key,返回它对应的值value,如果字典中不存在此键,则返回default值\n        dict.has_key(key)                       # 如果键在字典中存在,则返回True 用in和not in代替\n        dict.items()                            # 返回一个包含字典中键、值对元组的列表\n        dict.keys()                             # 返回一个包含字典中键的列表\n        dict.iter()                             # 方法iteritems()、iterkeys()、itervalues()与它们对应的非迭代方法一样,不同的是它们返回一个迭代子,而不是一个列表\n        dict.pop(key[,default])                 # 和方法get()相似.如果字典中key键存在,删除并返回dict[key]\n        dict.setdefault(key,default=None)       # 和set()相似,但如果字典中不存在key键,由dict[key]=default为它赋值\n        dict.update(dict2)                      # 将字典dict2的键值对添加到字典dict\n        dict.values()                           # 返回一个包含字典中所有值得列表\n\n        dict([container])     # 创建字典的工厂函数。提供容器类(container),就用其中的条目填充字典\n        len(mapping)          # 返回映射的长度(键-值对的个数)\n        hash(obj)             # 返回obj哈希值,判断某个对象是否可做一个字典的键值\n\n    集合方法\n\n        s.update(t)                         # 用t中的元素修改s,s现在包含s或t的成员   s |= t\n        s.intersection_update(t)            # s中的成员是共用属于s和t的元素          s &= t\n        s.difference_update(t)              # s中的成员是属于s但不包含在t中的元素    s -= t\n        s.symmetric_difference_update(t)    # s中的成员更新为那些包含在s或t中,但不是s和t共有的元素  s ^= t\n        s.add(obj)                          # 在集合s中添加对象obj\n        s.remove(obj)                       # 从集合s中删除对象obj;如果obj不是集合s中的元素(obj not in s),将引发KeyError错误\n        s.discard(obj)                      # 如果obj是集合s中的元素,从集合s中删除对象obj\n        s.pop()                             # 删除集合s中的任意一个对象,并返回它\n        s.clear()                           # 删除集合s中的所有元素\n        s.issubset(t)                       # 如果s是t的子集,则返回True   s <= t\n        s.issuperset(t)                     # 如果t是s的超集,则返回True   s >= t\n        s.union(t)                          # 合并操作;返回一个新集合,该集合是s和t的并集   s | t\n        s.intersection(t)                   # 交集操作;返回一个新集合,该集合是s和t的交集   s & t\n        s.difference(t)                     # 返回一个新集合,改集合是s的成员,但不是t的成员  s - t\n        s.symmetric_difference(t)           # 返回一个新集合,该集合是s或t的成员,但不是s和t共有的成员   s ^ t\n        s.copy()                            # 返回一个新集合,它是集合s的浅复制\n        obj in s                            # 成员测试;obj是s中的元素 返回True\n        obj not in s                        # 非成员测试:obj不是s中元素 返回True\n        s == t                              # 等价测试 是否具有相同元素\n        s != t                              # 不等价测试\n        s < t                               # 子集测试;s!=t且s中所有元素都是t的成员\n        s > t                               # 超集测试;s!=t且t中所有元素都是s的成员\n\n    序列化\n\n        #!/usr/bin/python\n        import cPickle\n        obj = {'1':['4124','1241','124'],'2':['12412','142','1241']}\n\n        pkl_file = open('account.pkl','wb')\n        cPickle.dump(obj,pkl_file)\n        pkl_file.close()\n\n        pkl_file = open('account.pkl','rb')\n        account_list = cPickle.load(pkl_file)\n        pkl_file.close()\n\n    文件对象方法\n\n        file.close()                     # 关闭文件\n        file.fileno()                    # 返回文件的描述符\n        file.flush()                     # 刷新文件的内部缓冲区\n        file.isatty()                    # 判断file是否是一个类tty设备\n        file.next()                      # 返回文件的下一行,或在没有其他行时引发StopIteration异常\n        file.read(size=-1)               # 从文件读取size个字节,当未给定size或给定负值的时候,读取剩余的所有字节,然后作为字符串返回\n        file.readline(size=-1)           # 从文件中读取并返回一行(包括行结束符),或返回最大size个字符\n        file.readlines(sizhint=0)        # 读取文件的所有行作为一个列表返回\n        file.xreadlines()                # 用于迭代,可替换readlines()的一个更高效的方法\n        file.seek(off, whence=0)         # 在文件中移动文件指针,从whence(0代表文件起始,1代表当前位置,2代表文件末尾)偏移off字节\n        file.tell()                      # 返回当前在文件中的位置\n        file.truncate(size=file.tell())  # 截取文件到最大size字节,默认为当前文件位置\n        file.write(str)                  # 向文件写入字符串\n        file.writelines(seq)             # 向文件写入字符串序列seq;seq应该是一个返回字符串的可迭代对象\n\n    文件对象的属性\n\n        file.closed          # 表示文件已被关闭,否则为False\n        file.encoding        # 文件所使用的编码  当unicode字符串被写入数据时,它将自动使用file.encoding转换为字节字符串;若file.encoding为None时使用系统默认编码\n        file.mode            # Access文件打开时使用的访问模式\n        file.name            # 文件名\n        file.newlines        # 未读取到行分隔符时为None,只有一种行分隔符时为一个字符串,当文件有多种类型的行结束符时,则为一个包含所有当前所遇到的行结束符的列表\n        file.softspace       # 为0表示在输出一数据后,要加上一个空格符,1表示不加\n\n    异常处理\n\n        # try 中使用 sys.exit(2) 会被捕获,无法退出脚本,可使用 os._exit(2) 退出脚本\n\n        class ShortInputException(Exception):  # 继承Exception异常的类,定义自己的异常\n            def __init__(self, length, atleast):\n                Exception.__init__(self)\n                self.length = length\n                self.atleast = atleast\n        try:\n            s = raw_input('Enter something --> ')\n            if len(s) < 3:\n                raise ShortInputException(len(s), 3)    # 触发异常\n        except EOFError:\n            print '\\nWhy did you do an EOF on me?'\n        except ShortInputException, x:      # 捕捉指定错误信息\n            print 'ShortInputException:  %d | %d' % (x.length, x.atleast)\n        except Exception as err:            # 捕捉所有其它错误信息内容\n            print str(err)\n        #except urllib2.HTTPError as err:   # 捕捉外部导入模块的错误\n        #except:                            # 捕捉所有其它错误 不会看到错误内容\n        #        print 'except'\n        finally:                            # 无论什么情况都会执行 关闭文件或断开连接等\n               print 'finally'\n        else:                               # 无任何异常 无法和finally同用\n            print 'No exception was raised.'\n\n        不可捕获的异常\n\n            NameError:              # 尝试访问一个未申明的变量\n            ZeroDivisionError:      # 除数为零\n            SyntaxErrot:            # 解释器语法错误\n            IndexError:             # 请求的索引元素超出序列范围\n            KeyError:               # 请求一个不存在的字典关键字\n            IOError:                # 输入/输出错误\n            AttributeError:         # 尝试访问未知的对象属性\n            ImportError             # 没有模块\n            IndentationError        # 语法缩进错误\n            KeyboardInterrupt       # ctrl+C\n            SyntaxError             # 代码语法错误\n            ValueError              # 值错误\n            TypeError               # 传入对象类型与要求不符合\n\n        内建异常\n\n            BaseException                # 所有异常的基类\n            SystemExit                   # python解释器请求退出\n            KeyboardInterrupt            # 用户中断执行\n            Exception                    # 常规错误的基类\n            StopIteration                # 迭代器没有更多的值\n            GeneratorExit                # 生成器发生异常来通知退出\n            StandardError                # 所有的内建标准异常的基类\n            ArithmeticError              # 所有数值计算错误的基类\n            FloatingPointError           # 浮点计算错误\n            OverflowError                # 数值运算超出最大限制\n            AssertionError               # 断言语句失败\n            AttributeError               # 对象没有这个属性\n            EOFError                     # 没有内建输入,到达EOF标记\n            EnvironmentError             # 操作系统错误的基类\n            IOError                      # 输入/输出操作失败\n            OSError                      # 操作系统错误\n            WindowsError                 # windows系统调用失败\n            ImportError                  # 导入模块/对象失败\n            KeyboardInterrupt            # 用户中断执行(通常是ctrl+c)\n            LookupError                  # 无效数据查询的基类\n            IndexError                   # 序列中没有此索引(index)\n            KeyError                     # 映射中没有这个键\n            MemoryError                  # 内存溢出错误(对于python解释器不是致命的)\n            NameError                    # 未声明/初始化对象(没有属性)\n            UnboundLocalError            # 访问未初始化的本地变量\n            ReferenceError               # 若引用试图访问已经垃圾回收了的对象\n            RuntimeError                 # 一般的运行时错误\n            NotImplementedError          # 尚未实现的方法\n            SyntaxError                  # python语法错误\n            IndentationError             # 缩进错误\n            TabError                     # tab和空格混用\n            SystemError                  # 一般的解释器系统错误\n            TypeError                    # 对类型无效的操作\n            ValueError                   # 传入无效的参数\n            UnicodeError                 # Unicode相关的错误\n            UnicodeDecodeError           # Unicode解码时的错误\n            UnicodeEncodeError           # Unicode编码时的错误\n            UnicodeTranslateError        # Unicode转换时错误\n            Warning                      # 警告的基类\n            DeprecationWarning           # 关于被弃用的特征的警告\n            FutureWarning                # 关于构造将来语义会有改变的警告\n            OverflowWarning              # 旧的关于自动提升为长整形的警告\n            PendingDeprecationWarning    # 关于特性将会被废弃的警告\n            RuntimeWarning               # 可疑的运行时行为的警告\n            SyntaxWarning                # 可疑的语法的警告\n            UserWarning                  # 用户代码生成的警告\n\n        触发异常\n\n            raise exclass            # 触发异常,从exclass生成一个实例(不含任何异常参数)\n            raise exclass()          # 触发异常,但现在不是类;通过函数调用操作符(function calloperator:\"()\")作用于类名生成一个新的exclass实例,同样也没有异常参数\n            raise exclass, args      # 触发异常,但同时提供的异常参数args,可以是一个参数也可以是元组\n            raise exclass(args)      # 触发异常,同上\n            raise exclass, args, tb  # 触发异常,但提供一个跟踪记录(traceback)对象tb供使用\n            raise exclass,instance   # 通过实例触发异常(通常是exclass的实例)\n            raise instance           # 通过实例触发异常;异常类型是实例的类型:等价于raise instance.__class__, instance\n            raise string             # 触发字符串异常\n            raise string, srgs       # 触发字符串异常,但触发伴随着args\n            raise string,args,tb     # 触发字符串异常,但提供一个跟踪记录(traceback)对象tb供使用\n            raise                    # 重新触发前一个异常,如果之前没有异常,触发TypeError\n\n        跟踪异常栈\n\n            # traceback 获取异常相关数据都是通过sys.exc_info()函数得到的\n            import traceback\n            import sys\n            try:\n                s = raw_input()\n                print int(s)\n            except ValueError:\n                # sys.exc_info() 返回值是元组，第一个exc_type是异常的对象类型，exc_value是异常的值，exc_tb是一个traceback对象，对象中包含出错的行数、位置等数据\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                print \"\\n%s \\n %s \\n %s\\n\" %(exc_type, exc_value, exc_tb )\n                traceback.print_exc()        # 打印栈跟踪信息\n\n        抓取全部错误信息存如字典\n\n            import sys, traceback\n\n            try:\n                s = raw_input()\n                int(s)\n            except:\n                exc_type, exc_value, exc_traceback = sys.exc_info()\n                traceback_details = {\n                                     'filename': exc_traceback.tb_frame.f_code.co_filename,\n                                     'lineno'  : exc_traceback.tb_lineno,\n                                     'name'    : exc_traceback.tb_frame.f_code.co_name,\n                                     'type'    : exc_type.__name__,\n                                     'message' : exc_value.message,\n                                    }\n\n                del(exc_type, exc_value, exc_traceback)\n                print traceback_details\n                f = file('test1.txt', 'a')\n                f.write(\"%s %s %s %s %s\\n\" %(traceback_details['filename'],traceback_details['lineno'],traceback_details['name'],traceback_details['type'],traceback_details['message'], ))\n                f.flush()\n                f.close()\n\n    调试log\n\n        # cgitb覆盖了默认sys.excepthook全局异常拦截器\n        def func(a, b):\n            return a / b\n        if __name__ == '__main__':\n            import cgitb\n            cgitb.enable(format='text')\n            func(1, 0)\n\n    函数式编程的内建函数\n\n        apply(func[,nkw][,kw])          # 用可选的参数来调用func,nkw为非关键字参数,kw为关键字参数;返回值是函数调用的返回值\n        filter(func,seq)                # 调用一个布尔函数func来迭代遍历每个seq中的元素;返回一个使func返回值为true的元素的序列\n        map(func,seq1[,seq2])           # 将函数func作用于给定序列(s)的每个元素,并用一个列表来提供返回值;如果func为None,func表现为一个身份函数,返回一个含有每个序列中元素集合的n个元组的列表\n        reduce(func,seq[,init])         # 将二元函数作用于seq序列的元素,每次携带一堆(先前的结果以及下一个序列元素),连续地将现有的结果和下一个值作用在获得的随后的结果上,最后减少我们的序列为一个单一的返回值;如果初始值init给定,第一个比较会是init和第一个序列元素而不是序列的头两个元素\n        lambda x,y:x+y                  # 创建一个匿名函数 可用于上面几种方法中直接创建匿名函数式\n\n        # filter 即通过函数方法只保留结果为真的值组成列表\n        def f(x): return x % 2 != 0 and x % 3 != 0\n        f(3)     # 函数结果是False  3被filter抛弃\n        f(5)     # 函数结果是True   5被加入filter最后的列表结果\n        filter(f, range(2, 25))\n        [5, 7, 11, 13, 17, 19, 23]\n\n        # map 通过函数对列表进行处理得到新的列表\n        def cube(x): return x*x*x\n        map(cube, range(1, 11))\n        [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n\n        # reduce 通过函数会先接收初始值和序列的第一个元素，然后是返回值和下一个元素，依此类推\n        def add(x,y): return x+y\n        reduce(add, range(1, 11))              # 结果55  是1到10的和  x的值是上一次函数返回的结果，y是列表中循环的值\n        reduce(lambda x,y:x+y, range(1,11))    # 等同上面两条  lambda来创建匿名函数[ lambda x,y:x+y ] ,后面跟可迭代的对象\n\n    编码转换\n\n        a='中文'                    # 编码未定义按输入终端utf8或gbk\n        u=u'中文'                   # 定义为unicode编码  u值为 u'\\u4e2d\\u6587'\n        u.encode('utf8')            # 转为utf8格式 u值为 '\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n        print u                     # 结果显示 中文\n        print u.encode('utf8')      # 转为utf8格式,当显示终端编码为utf8  结果显示 中文  编码不一致则乱码\n        print u.encode('gbk')       # 当前终端为utf8 故乱码\n        ord('4')                    # 字符转ASCII码\n        chr(52)                     # ASCII码转字符\n\n        设置读取编码为utf8 避免转换出错\n\n            #!/usr/bin/env python\n            # -*- coding: utf-8 -*-\n\n            import sys\n            reload(sys)\n            sys.setdefaultencoding('utf-8')\n\n    遍历递归\n\n        [os.path.join(x[0],y) for x in os.walk('/root/python/5') for y in x[2]]\n\n        for i in os.walk('/root/python/5/work/server'):\n            print i\n\n    元类\n\n        # 实现动态curd类的或者实例中的方法属性\n\n        #!/usr/bin/env python\n        # -*- coding:utf-8 -*-\n        # Name:        metaclass.py\n        # Author:      ZhiPeng Wang.\n        # Created:     15/8/12\n        # Copyright:   (c) TigerJoys-SA 2015\n        # -----------------------------------------------------------------------------\n\n        \"\"\"首先检查__metaclass__属性, 如果设置了此属性, 如果设置了此属性则调用对应Metaclass,\n        Metaclass本身也是Class 当调用时先调用自身的__new__方法新建一个Instance然后Instance调\n        用__init__返回一个新对象(MyClss), 然后正常执行原Class\n        \"\"\"\n\n        ext_attr = {\n            'wzp': 'wzp',\n            'test': 'test',\n        }\n\n        class CustomMeta(type):\n            build_in_attr = ['name', ]\n\n            def __new__(cls, class_name, bases, attributes):\n                # 获取`Meta` Instance\n                attr_meta = attributes.pop('Meta', None)\n                if attr_meta:\n                    for attr in cls.build_in_attr:      # 遍历内置属性\n                        # 自省, 获取Meta Attributes 不是build_in_attr的属性不处理\n                        print \"Meta:\", getattr(attr_meta, attr, False)\n                # 扩展属性\n                attributes.update(ext_attr)\n                return type.__new__(cls, class_name, bases, attributes)\n\n            def __init__(cls, class_name, bases, attributes):\n                super(CustomMeta, cls).__init__(class_name, bases, attributes)\n\n        class MyClass(object):\n            __metaclass__ = CustomMeta  # metaclass\n            class Meta:\n                name = 'Meta attr'\n\n        if __name__ == '__main__':\n\n            # TODO 此处返回一个类｀Instance｀对象\n            print MyClass()\n\n            # TODO 此处返回一个类对象, 并不是｀Instance｀\n            print type(\"MyClass\", (), {})\n\n2 常用模块\n\n    sys             [系统操作模块]\n\n        sys.argv              # 取参数列表\n        sys.exit(2)           # 退出脚本返回状态 会被try截取\n        sys.exc_info()        # 获取当前正在处理的异常类\n        sys.version           # 获取Python解释程序的版本信息\n        sys.maxint            # 最大的Int值  9223372036854775807\n        sys.maxunicode        # 最大的Unicode值\n        sys.modules           # 返回系统导入的模块字段，key是模块名，value是模块\n        sys.path              # 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值\n        sys.platform          # 返回操作系统平台名称\n        sys.stdout            # 标准输出\n        sys.stdin             # 标准输入\n        sys.stderr            # 错误输出\n        sys.exec_prefix       # 返回平台独立的python文件安装的位置\n        sys.stdin.readline()  # 从标准输入读一行\n        sys.stdout.write(\"a\") # 屏幕输出a\n        sys.path.insert(1, os.path.join(sys.path[0], '/opt/script/'))     # 将/opt/script/目录加入环境变量，可导入相应模块\n    commands        [执行系统操作]\n\n        (status, output) = commands.getstatusoutput('cat /proc/cpuinfo')\n        print status, output\n\n    os              [系统模块]\n\n        # 相对sys模块 os模块更为底层 os._exit() try无法抓取\n        os.popen('id').read()      # 执行系统命令得到返回结果\n        os.system()                # 得到返回状态 返回无法截取\n        os.name                    # 返回系统平台 Linux/Unix用户是'posix'\n        os.getenv()                # 读取环境变量\n        os.environ['A']='1'        # 设置环境变量\n        os.getcwd()                # 当前工作路径\n        os.chdir()                 # 改变当前工作目录\n        os.walk('/root/')          # 递归路径\n        os.environ['HOME']         # 查看系统环境变量\n        os.statvfs(\"/\")            # 获取磁盘信息\n\n        文件处理\n            mkfifo()/mknod()       # 创建命名管道/创建文件系统节点\n            remove()/unlink()      # 删除文件\n            rename()/renames()     # 重命名文件\n            stat()                 # 返回文件信息\n            symlink()              # 创建符号链接\n            utime()                # 更新时间戳\n            tmpfile()              # 创建并打开('w+b')一个新的临时文件\n            walk()                 # 遍历目录树下的所有文件名\n\n            oct(os.stat('th1.py').st_mode)[-3:]      # 查看目录权限\n\n        目录/文件夹\n            chdir()/fchdir()       # 改变当前工作目录/通过一个文件描述符改变当前工作目录\n            chroot()               # 改变当前进程的根目录\n            listdir()              # 列出指定目录的文件\n            getcwd()/getcwdu()     # 返回当前工作目录/功能相同,但返回一个unicode对象\n            mkdir()/makedirs()     # 创建目录/创建多层目录\n            rmdir()/removedirs()   # 删除目录/删除多层目录\n\n        访问/权限\n            saccess()                    # 检验权限模式\n            chmod('txt',eval(\"0777\"))    # 改变权限模式\n            chown()/lchown()             # 改变owner和groupID功能相同,但不会跟踪链接\n            umask()                      # 设置默认权限模式\n\n        文件描述符操作\n            open()                 # 底层的操作系统open(对于稳健,使用标准的内建open()函数)\n            read()/write()         # 根据文件描述符读取/写入数据 按大小读取文件部分内容\n            dup()/dup2()           # 复制文件描述符号/功能相同,但是复制到另一个文件描述符\n\n        设备号\n            makedev()              # 从major和minor设备号创建一个原始设备号\n            major()/minor()        # 从原始设备号获得major/minor设备号\n\n        os.path模块\n\n            os.path.expanduser('~/.ssh/key')   # 家目录下文件的全路径\n\n            分隔\n                os.path.basename()         # 去掉目录路径,返回文件名\n                os.path.dirname()          # 去掉文件名,返回目录路径\n                os.path.join()             # 将分离的各部分组合成一个路径名\n                os.path.spllt()            # 返回(dirname(),basename())元组\n                os.path.splitdrive()       # 返回(drivename,pathname)元组\n                os.path.splitext()         # 返回(filename,extension)元组\n\n            信息\n                os.path.getatime()         # 返回最近访问时间\n                os.path.getctime()         # 返回文件创建时间\n                os.path.getmtime()         # 返回最近文件修改时间\n                os.path.getsize()          # 返回文件大小(字节)\n\n            查询\n                os.path.exists()           # 指定路径(文件或目录)是否存在\n                os.path.isabs()            # 指定路径是否为绝对路径\n                os.path.isdir()            # 指定路径是否存在且为一个目录\n                os.path.isfile()           # 指定路径是否存在且为一个文件\n                os.path.islink()           # 指定路径是否存在且为一个符号链接\n                os.path.ismount()          # 指定路径是否存在且为一个挂载点\n                os.path.samefile()         # 两个路径名是否指向同一个文件\n\n        子进程\n            os.fork()    # 创建子进程,并复制父进程所有操作  通过判断pid = os.fork() 的pid值,分别执行父进程与子进程操作，0为子进程\n            os.wait()    # 等待子进程结束\n\n        跨平台os模块属性\n\n            linesep         # 用于在文件中分隔行的字符串\n            sep             # 用来分隔文件路径名字的字符串\n            pathsep         # 用于分割文件路径的字符串\n            curdir          # 当前工作目录的字符串名称\n            pardir          # 父目录字符串名称\n\n        磁盘空间\n\n            import os\n            disk = os.statvfs(\"/\")\n            # disk.f_bsize       块大小\n            # disk.f_blocks      块总数\n            # disk.f_bfree       剩余块总数\n            # disk.f_bavail      非root用户的剩余块数  由于权限小会比root的剩余块总数小 用这个做报警会更准确\n            # disk.f_files       总节点数\n            # disk.f_ffree       剩余节点数\n            # disk.f_favail      非root用户的剩余节点数\n\n            disk.f_bsize * disk.f_bavail / 1024 / 1024 / 1024   # 非root用户剩余空间大小G\n            disk.f_bsize * disk.f_blocks / 1024 / 1024 / 1024   # 分区空间总大小\n\n    commands        [执行系统命令]\n\n        (status, output) = commands.getstatusoutput('cat /proc/cpuinfo')\n        print status, output\n        commands.getstatusoutput('id')       # 返回元组(状态,标准输出)\n        commands.getoutput('id')             # 只返回执行的结果, 忽略返回值\n        commands.getstatus('file')           # 返回ls -ld file执行的结果\n\n    re              [perl风格正则]\n\n        compile(pattern,flags=0)          # 对正则表达式模式pattern进行编译,flags是可选标识符,并返回一个regex对象\n        match(pattern,string,flags=0)     # 尝试用正则表达式模式pattern匹配字符串string,flags是可选标识符,如果匹配成功,则返回一个匹配对象;否则返回None\n        search(pattern,string,flags=0)    # 在字符串string中搜索正则表达式模式pattern的第一次出现,flags是可选标识符,如果匹配成功,则返回一个匹配对象;否则返回None\n        findall(pattern,string[,flags])   # 在字符串string中搜索正则表达式模式pattern的所有(非重复)出现:返回一个匹配对象的列表  # pattern=u'\\u4e2d\\u6587' 代表UNICODE\n        finditer(pattern,string[,flags])  # 和findall()相同,但返回的不是列表而是迭代器;对于每个匹配,该迭代器返回一个匹配对象\n        split(pattern,string,max=0)       # 根据正则表达式pattern中的分隔符把字符string分割为一个列表,返回成功匹配的列表,最多分割max次(默认所有)\n        sub(pattern,repl,string,max=0)    # 把字符串string中所有匹配正则表达式pattern的地方替换成字符串repl,如果max的值没有给出,则对所有匹配的地方进行替换(subn()会返回一个表示替换次数的数值)\n        group(num=0)                      # 返回全部匹配对象(或指定编号是num的子组)\n        groups()                          # 返回一个包含全部匹配的子组的元组(如果没匹配成功,返回一个空元组)\n\n        零宽断言\n            str = 'aaa111aaa , bbb222&, 333ccc'\n            re.compile('\\d+(?=[a-z]+)').findall(str)          # 前向界定 (?=exp) 找出连续的数字并且最后一个数字跟着至少一个a-z ['111', '333']\n            re.compile(r\"\\d+(?![a-z]+)\").findall(str)         # 前向否定界定 (?!exp)  找出连续数字，且最后一个数字后不能跟a-z  ['11', '222', '33']\n            re.compile(r\"(?<=[a-z])\\d+\").findall(str)         # 反向界定 (?<=exp) 逆序环视 找出连续的数字，且第一个数字前面是a-z  ['111', '222']\n            re.compile(r\"(?<![a-z])\\d+\").findall(str)         # 反向否定界定 (?<!exp) 否定逆序环视  找出连续的数字，且第一个数字前不能是a-z  ['11', '22', '333']\n            re.compile(r\"(?:\\d+)\").findall(str)               # 无捕获的匹配 (?:exp)\n            s= 'Tom:9527 , Sharry:0003 '\n            re.match( r'(?P<name>\\w+):(?P<num>\\d+)' , s).group(0)   # 捕获组 <num>第二个标签变量[9527] 获取 group(\"num\") 等同 group(2)[9527], group(0)全部[Tom:9527]\n\n        例子\n            re.findall(r'a[be]c','123abc456eaec789')         # 返回匹配对象列表 ['abc', 'aec']\n            re.findall(\"(.)12[34](..)\",a)                    # 取出匹配括号中内容   a='qedqwe123dsf'\n            re.search(\"(.)123\",a ).group(1)                  # 搜索匹配的取第1个标签\n            re.match(\"^(1|2) *(.*) *abc$\", str).group(2)     # 取第二个标签\n            re.match(\"^(1|2) *(.*) *abc$\", str).groups()     # 取所有标签\n            re.sub('[abc]','A','alex')                       # 替换\n            for i in re.finditer(r'\\d+',s):                  # 迭代\n                print i.group(),i.span()                     #\n\n        搜索网页中UNICODE格式的中文\n            QueryAdd='http://www.anti-spam.org.cn/Rbl/Query/Result'\n            Ip='222.129.184.52'\n            s = requests.post(url=QueryAdd, data={'IP':Ip})\n            re.findall(u'\\u4e2d\\u56fd', s.text, re.S)\n\n    csv             [访问csv逗号分隔的文件]\n\n        csv读配置文件\n\n            192.168.1.5,web # 配置文件按逗号分割\n            list = csv.reader(file('a.csv'))\n            for line in list:\n                print line              #  ['192.168.1.5', 'web']\n\n        csv配合with读文件\n\n            import csv\n            with open('some.csv', 'rb') as f:\n                reader = csv.reader(f)\n                for row in reader:\n                    print row\n\n        csv配合with写文件\n\n            import csv\n            with open('some.csv', 'wb') as f:\n                writer = csv.writer(f)\n                writer.writerow(['Column1', 'Column2', 'Column3'])    # 写单行 列表\n                writer.writerows([range(3) for i in range(5)])        # 写多行 列表套列表\n\n    shutil          [提供高级文件访问功能]\n\n        import shutil\n        shutil.copyfile('data.db', 'archive.db')             # 拷贝文件\n        shutil.move('/build/executables', 'installdir')      # 移动文件或目录\n\n    dircache        [目录文件列表缓存]\n\n        import dircache\n        a = dircache.listdir('/data/xuesong')        # 列出目录下所有的文件和目录\n        dircache.annotate('/data/xuesong', a)        # 判断指定目录下的是文件还是目录,目录则后面加/ 文件或不存在则不改变\n\n    glob            [文件通配符]\n\n        import glob\n        glob.glob('*.py')    # 查找当前目录下py结尾的文件\n\n    random          [随机模块]\n\n        import random\n        random.choice(['apple', 'pear', 'banana'])   # 随机取列表一个参数\n        random.sample(xrange(100), 10)  # 不重复抽取10个\n        random.random()                 # 随机浮点数\n        random.randrange(6)             # 随机整数范围\n\n    tempfile        [创建临时文件]\n\n        import os\n        import tempfile\n         \n        temp = tempfile.TemporaryFile()                # 定义一个临时文件对象\n        try:\n            temp.write('Some data')                    # 写入数据\n            temp.writelines(['first\\n', 'second\\n'])   # 写入多行\n            temp.seek(0)                               # 写入\n             \n            print temp.read()                          # 读取\n\n            for line in temp:                          # 循环读取每一行\n                print line.rstrip()\n        finally:\n            temp.close()                               # 关闭后删除临时文件\n\n\n\n        # 创建临时目录\n        import os\n        import tempfile\n         \n        directory_name = tempfile.mkdtemp()\n        print directory_name                            # 打印临时目录地址 /var/folders...\n        # Clean up the directory yourself\n        os.removedirs(directory_name)                   # 创建临时目录需要手动删除\n\n\n        # 控制临时文件名\n        import tempfile\n         \n        temp = tempfile.NamedTemporaryFile(suffix='_suffix',  prefix='prefix_',  dir='/tmp')\n        try:\n            print 'temp:', temp\n            print 'temp.name:', temp.name\n        finally:\n            temp.close()\n\n    email           [发送邮件]\n\n        发送邮件内容\n\n            #!/usr/bin/python\n            #encoding:utf8\n            # 导入 smtplib 和 MIMEText\n            import smtplib\n            from email.mime.text import MIMEText\n\n            # 定义发送列表\n            mailto_list=[\"272121935@qq.com\",\"272121935@163.com\"]\n\n            # 设置服务器名称、用户名、密码以及邮件后缀\n            mail_host = \"smtp.163.com\"\n            mail_user = \"mailuser\"\n            mail_pass = \"password\"\n            mail_postfix=\"163.com\"\n\n            # 发送邮件函数\n            def send_mail(to_list, sub):\n                me = mail_user + \"<\"+mail_user+\"@\"+mail_postfix+\">\"\n                fp = open('context.txt')\n                msg = MIMEText(fp.read(),_charset=\"utf-8\")\n                fp.close()\n                msg['Subject'] = sub\n                msg['From'] = me\n                msg['To'] = \";\".join(to_list)\n                try:\n                    send_smtp = smtplib.SMTP()\n                    send_smtp.connect(mail_host)\n                    send_smtp.login(mail_user+\"@\"+mail_postfix, mail_pass)\n                    send_smtp.sendmail(me, to_list, msg.as_string())\n                    send_smtp.close()\n                    return True\n                except Exception, e:\n                    print str(e)\n                    return False\n\n            if send_mail(mailto_list,\"标题\"):\n                print \"测试成功\"\n            else:\n                print \"测试失败\"\n\n        发送附件\n\n            #!/usr/bin/python\n            #encoding:utf8\n            import smtplib\n            from email.mime.multipart import MIMEMultipart\n            from email.mime.base import MIMEBase\n            from email import encoders\n\n            def send_mail(to_list, sub, filename):\n                me = mail_user + \"<\"+mail_user+\"@\"+mail_postfix+\">\"\n                msg = MIMEMultipart()\n                msg['Subject'] = sub\n                msg['From'] = me\n                msg['To'] = \";\".join(to_list)\n                submsg = MIMEBase('application', 'x-xz')\n                submsg.set_payload(open(filename,'rb').read())\n                encoders.encode_base64(submsg)\n                submsg.add_header('Content-Disposition', 'attachment', filename=filename)\n                msg.attach(submsg)\n                try:\n                    send_smtp = smtplib.SMTP()\n                    send_smtp.connect(mail_host)\n                    send_smtp.login(mail_user, mail_pass)\n                    send_smtp.sendmail(me, to_list, msg.as_string())\n                    send_smtp.close()\n                    return True\n                except Exception, e:\n                    print str(e)[1]\n                    return False\n\n            # 设置服务器名称、用户名、密码以及邮件后缀\n            mail_host = \"smtp.163.com\"\n            mail_user = \"xuesong\"\n            mail_pass = \"mailpasswd\"\n            mail_postfix = \"163.com\"\n            mailto_list = [\"272121935@qq.com\",\"quanzhou722@163.com\"]\n            title = 'check'\n            filename = 'file_check.html'\n            if send_mail(mailto_list,title,filename):\n                print \"发送成功\"\n            else:\n                print \"发送失败\"\n\n    gzip            [解压缩gzip 删除原文件]\n\n        #压缩gzip\n        import gzip\n        f_in = open('file.log', 'rb')\n        f_out = gzip.open('file.log.gz', 'wb')\n        f_out.writelines(f_in)\n        f_out.close()\n        f_in.close()\n\n        #压缩gzip\n        File = 'xuesong_18.log'\n        g = gzip.GzipFile(filename=\"\", mode='wb', compresslevel=9, fileobj=open((r'%s.gz' %File),'wb'))\n        g.write(open(r'%s' %File).read())\n        g.close()\n\n        #解压gzip\n        g = gzip.GzipFile(mode='rb', fileobj=open((r'xuesong_18.log.gz'),'rb'))\n        open((r'xuesong_18.log'),'wb').write(g.read())\n\n    tarfile         [归档压缩tar.gz 保留原文件]\n\n        # 压缩tar.gz\n        import os\n        import tarfile\n        tar = tarfile.open(\"/tmp/tartest.tar.gz\",\"w:gz\")   # 创建压缩包名\n        for path,dir,files in os.walk(\"/tmp/tartest\"):     # 递归文件目录\n            for file in files:\n                fullpath = os.path.join(path,file)\n                tar.add(fullpath)                          # 创建压缩包\n        tar.close()\n\n        # 解压tar.gz\n        import tarfile\n        tar = tarfile.open(\"/tmp/tartest.tar.gz\")\n        #tar.extract(\"/tmp\")                               # 全部解压到指定路径\n        names = tar.getnames()                             # 包内文件名\n        for name in names:\n            tar.extract(name,path=\"./\")                    # 解压指定文件\n        tar.close()\n\n    zipfile         [解压缩zip 最大2G]\n\n        # 压缩zip\n        import zipfile,os\n        f = zipfile.ZipFile('filename.zip', 'w' ,zipfile.ZIP_DEFLATED)    # ZIP_STORE 为默认表不压缩. ZIP_DEFLATED 表压缩\n        #f.write('file1.txt')                              # 将文件写入压缩包\n        for path,dir,files in os.walk(\"tartest\"):          # 递归压缩目录\n            for file in files:\n                f.write(os.path.join(path,file))           # 将文件逐个写入压缩包\n        f.close()\n\n        # 解压zip\n        if zipfile.is_zipfile('filename.zip'):             # 判断一个文件是不是zip文件\n            f = zipfile.ZipFile('filename.zip')\n            for file in f.namelist():                      # 返回文件列表\n                f.extract(file, r'/tmp/')                  # 解压指定文件\n            #f.extractall()                                # 解压全部\n            f.close()\n\n    time/datetime   [时间]\n\n        import time\n        time.strftime('%Y%m%d_%H%M')         # 格式化时间\n        time.time()                          # 时间戳[浮点]\n        int(time.time())                     # 时间戳[整s]\n        time.localtime()[1] - 1              # 上个月\n        time.strftime('%Y-%m-%d_%X',time.localtime( time.time() ) )              # 时间戳转日期\n        time.mktime(time.strptime('2012-03-28 06:53:40', '%Y-%m-%d %H:%M:%S'))   # 日期转时间戳\n\n        最近的周五\n\n            from datetime import datetime\n            from dateutil.relativedelta import relativedelta, FR\n            (datetime.now() + relativedelta(weekday=FR(-1))).strftime('%Y%m%d')\n\n        获取本周一\n            import  datetime\n            datetime.date.today() - datetime.timedelta(days=datetime.date.today().weekday())\n\n        判断输入时间格式是否正确\n\n            #encoding:utf8\n            import time\n            while 1:\n                atime=raw_input('输入格式如[14.05.13 13:00]:')\n                try:\n                    btime=time.mktime(time.strptime('%s:00' %atime, '%y.%m.%d %H:%M:%S'))\n                    break\n                except:\n                    print '时间输入错误,请重新输入，格式如[14.05.13 13:00]'\n\n        上一个月最后一天\n            import datetime\n            lastMonth=datetime.date(datetime.date.today().year,datetime.date.today().month,1)-datetime.timedelta(1)\n            lastMonth.strftime(\"%Y/%m\")\n\n        前一天\n            (datetime.datetime.now() + datetime.timedelta(days=-1) ).strftime('%Y%m%d')\n\n        两日期相差天数\n\n            import datetime\n            d1 = datetime.datetime(2005, 2, 16)\n            d2 = datetime.datetime(2004, 12, 31)\n            (d1 - d2).days\n\n        向后加10个小时\n\n            import datetime\n            d1 = datetime.datetime.now()\n            d3 = d1 + datetime.timedelta(hours=10)\n            d3.ctime()\n\n    optparse        [解析参数及标准提示]\n\n        import os, sys\n        import time\n        import optparse\n        # python aaa.py -t file -p /etc/opt -o aaaaa\n\n        def do_fiotest( type, path, output,):\n            print type, path, output,\n\n        def main():\n            parser = optparse.OptionParser()\n            parser.add_option('-t', '--type', dest = 'type', default = None, help = 'test type[file, device]')\n            parser.add_option('-p', '--path', dest = 'path', default = None, help = 'test file path or device path')\n            parser.add_option('-o', '--output', dest = 'output', default = None, help = 'result dir path')\n\n            (o, a) = parser.parse_args()\n\n            if None == o.type or None == o.path or None == o.output:\n                print \"No device or file or output dir\"\n                return -1\n\n            if 'file' != o.type and 'device' != o.type:\n                print \"You need specify test type ['file' or 'device']\"\n                return -1\n\n            do_fiotest(o.type, o.path, o.output)\n            print \"Test done!\"\n\n\n        if __name__ == '__main__':\n            main()\n\n    getopt          [解析参数]\n\n        import sys,os\n        import getopt\n\n        try:\n            options,argsErr = getopt.getopt(sys.argv[1:],\"hu:c:\",[\"help\",\"user=\",\"cmd=\"])    # 中间短参数，后面长参数对应. 不带:或=代表不带参数\n        except getopt.GetoptError:\n            print \"Unknown parameters,More info with: %s -h\" %(sys.argv[0])\n            sys.exit(2)\n        if argsErr != []:\n            print \"Unknown parameters,More info with: %s -h\" %(sys.argv[0])\n            sys.exit(2)\n\n        for o,a in  options:\n            if o in (\"-h\",\"--help\"):\n                print '''Usage: python te.py -u user -c \"cmd -options\" '''\n                sys.exit(2)\n            if o in (\"-u\",\"--user\"):\n                user = a\n            if o in (\"-c\",\"--cmd\"):\n                cmd = a\n        print user,cmd\n\n    argparse        [命令行选项和参数解析库]\n\n        import argparse\n        parser = argparse.ArgumentParser( prog='usage_name', description='开头打印', epilog=\"结束打印\")\n        parser.add_argument('-f', '--foo', help='foo help', action='append')      # 可选参数,如使用此参数必须传值 action='store_true' 不加参数为True  action='append' 多个参数可叠加为列表\n        parser.add_argument('--aa', type=int, default=42, help='aa!')             # type规定参数类型,default设置默认值\n        parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')     # 位置参数 必须传递  nargs=2 需要传递2个参数\n        parser.add_argument('args', nargs=argparse.REMAINDER)                     # 剩余参数收集到列表\n        parser.print_help()                                                       # 打印使用帮助\n        #parser.parse_args('BAR --foo FOO'.split())                               # 设置位置参数\n        args = parser.parse_args()                                                # 全部的值\n        parser.get_default('foo')                                                 # 获取\n\n        python a.py --foo ww  --aa 40 xuesong 27                                  # 执行此脚本\n\n    subprocess      [子进程管理]\n\n        import subprocess\n        s=subprocess.Popen('sleep 20', shell=True, \\\n                stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE)\n        print s.wait()         # 阻塞等待子进程完成并返回状态码 shell 0为正确  但管道内容过多会造成死锁可以用 communicate()\n        print s.stdout.read()\n        print s.stderr.read()\n\n        print s.communicate()     # 返回元组 (stdout, stderr)  会阻塞等待进程完成 推荐使用\n        print s.returncode        # 返回执行状态码\n\n    base64          [编码]\n\n        # 简单但容易被直接破解\n        import base64\n        s1 = base64.encodestring('hello world')\n        s2 = base64.decodestring(s1)\n\n    uu              [对文件uu编码]\n\n        import uu\n        uu.encode('in_file','out_file')       # 编码\n        uu.decode('in_file','out_file')       # 解码\n\n    binascii        [ascii和二进制编码转换]\n\n    md5             [单向MD5加密]\n\n        import md5\n        m = md5.new('123456').hexdigest()\n\n    hashlib         [hash算法库]\n\n        import hashlib\n        m = hashlib.md5()\n        m.update(\"Nobody inspects\")    # 使用update方法对字符串md5加密\n        m.digest()                     # 加密后二进制结果\n        m.hexdigest()                  # 加密后十进制结果\n        hashlib.new(\"md5\", \"string\").hexdigest()               # 对字符串加密\n        hashlib.new(\"md5\", open(\"file\").read()).hexdigest()    # 查看文件MD5值\n\n        hashlib.sha224(\"Nobody inspects the spammish repetition\").hexdigest()       # 几种hash算法 sha1  sha224  sha256  sha384  ha512\n\n    crypt           [单向加密]\n\n        import crypt\n        import random,string\n\n        def getsalt(chars = string.letters+string.digits):\n            return random.choice(chars)+random.choice(chars)\n        salt = getsalt()\n        print salt\n        print crypt.crypt('bananas',salt)\n\n    pycrypto        [加密]\n\n        # https://github.com/dlitz/pycrypto\n        SHA256  # 不可逆散列算法加密\n            from Crypto.Hash import SHA256\n            hash = SHA256.new()\n            hash.update('message')\n            hash.digest()\n\n        AES     # 可逆加密,需要密钥\n            from Crypto.Cipher import AES\n            obj = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')\n            message = \"The answer is no\"\n            ciphertext = obj.encrypt(message)\n            ciphertext\n            '\\xd6\\x83\\x8dd!VT\\x92\\xaa`A\\x05\\xe0\\x9b\\x8b\\xf1'\n            obj2 = AES.new('This is a key123', AES.MODE_CBC, 'This is an IV456')\n            obj2.decrypt(ciphertext)\n            'The answer is no'\n\n    rsa             [公钥加密算法]\n\n        http://www.heikkitoivonen.net/m2crypto/api/M2Crypto.RSA.RSA-class.html\n\n        pip install M2Crypto\n\n        from M2Crypto import RSA,BIO                         # help(RSA)\n        rsa = RSA.gen_key(2048, 'sha1')                      # 设置生成密钥为2048位,1024较不安全,默认算法sha1\n        rsa.save_key('rsa.priv.pem', None )                  # 生成私钥pem文件\n        rsa.save_pub_key('rsa.pub.pem')                      # 生成公钥pem文件\n        rsa.save_key_bio()                                   # 私钥保存到pem格式的M2Crypto.BIO.BIO对象\n        rsa.save_pub_key_bio()                               # 公钥保存到pem格式的M2Crypto.BIO.BIO对象\n        priv=RSA.load_key('rsa.priv.pem')                    # 加载私钥文件\n        pub=RSA.load_pub_key('rsa.pub.pem')                  # 加载公钥文件\n        rsa.check_key()                                      # 检查key是否初始化\n        pub_key.public_encrypt('data',RSA.pkcs1_padding)     # 公钥加密\n        priv_key.private_decrypt('密文',RSA.pkcs1_padding)   # 私钥解密\n\n        from M2Crypto import RSA,BIO\n\n        rsa = RSA.gen_key(2048, 3, lambda *agr:None)\n        pub_bio = BIO.MemoryBuffer()\n        priv_bio = BIO.MemoryBuffer()\n\n        rsa.save_pub_key_bio(pub_bio)\n        rsa.save_key_bio(priv_bio, None)\n\n        # print pub_bio.read_all()\n        pub_key = RSA.load_pub_key_bio(pub_bio)\n        priv_key = RSA.load_key_bio(priv_bio)\n\n        message = 'i am luchanghong'\n\n        encrypted = pub_key.public_encrypt(message, RSA.pkcs1_padding)        # 加密\n        decrypted = priv_key.private_decrypt(encrypted, RSA.pkcs1_padding)    # 解密\n\n        print decrypted\n\n    getpass         [隐藏输入密码]\n\n        import getpass\n        passwd=getpass.getpass()\n\n    string          [字符串类]\n\n        import string\n        string.ascii_letters   # a-zA-Z  ascii的不受语言系统环境变化\n        string.ascii_lowercase # a-z\n        string.letters         # a-zA-Z  受系统语言环境变化影响\n        string.lowercase       # a-z\n        string.uppercase       # A-Z大小\n        string.digits          # 0-9\n        string.printable       # 所有字符\n        string.whitespace      # 空白字符\n\n    Gittle          [python的git库]\n\n        pip install gittle\n        from gittle import Gittle\n        repo_path = '/tmp/gittle_bare'\n        repo_url = 'git://github.com/FriendCode/gittle.git'\n        repo = Gittle.clone(repo_url, repo_path)\n        auth = GittleAuth(pkey=key)                           # 认证\n        Gittle.clone(repo_url, repo_path, auth=auth)\n        repo = Gittle.clone(repo_url, repo_path, bare=True)   # 克隆仓库没有目录的\n        repo = Gittle.init(path)                     # 初始化\n        repo.commits                                 # 获取提交列表\n        repo.branches                                # 获取分支列表\n        repo.modified_files                          # 被修改的文件列表\n        repo.diff('HEAD', 'HEAD~1')                  # 获取最新提交差异\n        repo.stage('file.txt')                       # 提交文件\n        repo.stage(['other1.txt', 'other2.txt'])     # 提交文件列表\n        repo.commit(name=\"Samy Pesse\", email=\"samy@friendco.de\", message=\"This is a commit\")  # 更新信息\n\n        repo = Gittle(repo_path, origin_uri=repo_url)\n        key_file = open('/Users/Me/keys/rsa/private_rsa')\n        repo.auth(pkey=key_file)\n        repo.push()                                   # 远端push提交操作\n\n        repo = Gittle(repo_path, origin_uri=repo_url)\n        key_file = open('/Users/Me/keys/rsa/private_rsa')\n        repo.auth(pkey=key_file)\n        repo.pull()                                   # 拉取最新分支\n\n        repo.create_branch('dev', 'master')           # 创建分支\n        repo.switch_branch('dev')                     # 切换到分支\n        repo.create_orphan_branch('NewBranchName')    # 创建一个空的分支\n        repo.remove_branch('dev')                     # 删除分支\n\n\n    paramiko        [ssh客户端]\n\n        安装\n            sudo apt-get install python-setuptools\n            easy_install\n            sudo apt-get install python-all-dev\n            sudo apt-get install build-essential\n\n        paramiko实例(账号密码登录执行命令)\n\n            #!/usr/bin/python\n            #ssh\n            import paramiko\n            import sys,os\n\n            host = '10.152.15.200'\n            user = 'peterli'\n            password = '123456'\n\n            s = paramiko.SSHClient()                                 # 绑定实例\n            s.load_system_host_keys()                                # 加载本地HOST主机文件\n            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许连接不在know_hosts文件中的主机\n            s.connect(host,22,user,password,timeout=5)               # 连接远程主机\n            while True:\n                    cmd=raw_input('cmd:')\n                    stdin,stdout,stderr = s.exec_command(cmd)        # 执行命令\n                    cmd_result = stdout.read(),stderr.read()         # 读取命令结果\n                    for line in cmd_result:\n                            print line,\n            s.close()\n\n        paramiko实例(传送文件)\n\n            #!/usr/bin/evn python\n            import os\n            import paramiko\n            host='127.0.0.1'\n            port=22\n            username = 'peterli'\n            password = '123456'\n            ssh=paramiko.Transport((host,port))\n            privatekeyfile = os.path.expanduser('~/.ssh/id_rsa')\n            mykey = paramiko.RSAKey.from_private_key_file( os.path.expanduser('~/.ssh/id_rsa'))   # 加载key 不使用key可不加\n            ssh.connect(username=username,password=password)           # 连接远程主机\n            # 使用key把 password=password 换成 pkey=mykey\n            sftp=paramiko.SFTPClient.from_transport(ssh)               # SFTP使用Transport通道\n            sftp.get('/etc/passwd','pwd1')                             # 下载 两端都要指定文件名\n            sftp.put('pwd','/tmp/pwd')                                 # 上传\n            sftp.close()\n            ssh.close()\n\n        paramiko实例(密钥执行命令)\n\n            #!/usr/bin/python\n            #ssh\n            import paramiko\n            import sys,os\n            host = '10.152.15.123'\n            user = 'peterli'\n            s = paramiko.SSHClient()\n            s.load_system_host_keys()\n            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            privatekeyfile = os.path.expanduser('~/.ssh/id_rsa')             # 定义key路径\n            mykey = paramiko.RSAKey.from_private_key_file(privatekeyfile)\n            # mykey=paramiko.DSSKey.from_private_key_file(privatekeyfile,password='061128')   # DSSKey方式 password是key的密码\n            s.connect(host,22,user,pkey=mykey,timeout=5)\n            cmd=raw_input('cmd:')\n            stdin,stdout,stderr = s.exec_command(cmd)\n            cmd_result = stdout.read(),stderr.read()\n            for line in cmd_result:\n                    print line,\n            s.close()\n\n        ssh并发(Pool控制最大并发)\n\n            #!/usr/bin/env python\n            #encoding:utf8\n            #ssh_concurrent.py\n\n            import multiprocessing\n            import sys,os,time\n            import paramiko\n\n            def ssh_cmd(host,port,user,passwd,cmd):\n                msg = \"-----------Result:%s----------\" % host\n\n                s = paramiko.SSHClient()\n                s.load_system_host_keys()\n                s.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n                try:\n                    s.connect(host,22,user,passwd,timeout=5)\n                    stdin,stdout,stderr = s.exec_command(cmd)\n\n                    cmd_result = stdout.read(),stderr.read()\n                    print msg\n                    for line in cmd_result:\n                            print line,\n\n                    s.close()\n                except paramiko.AuthenticationException:\n                    print msg\n                    print 'AuthenticationException Failed'\n                except paramiko.BadHostKeyException:\n                    print msg\n                    print \"Bad host key\"\n\n            result = []\n            p = multiprocessing.Pool(processes=20)\n            cmd=raw_input('CMD:')\n            f=open('serverlist.conf')\n            list = f.readlines()\n            f.close()\n            for IP in list:\n                print IP\n                host=IP.split()[0]\n                port=int(IP.split()[1])\n                user=IP.split()[2]\n                passwd=IP.split()[3]\n                result.append(p.apply_async(ssh_cmd,(host,port,user,passwd,cmd)))\n\n            p.close()\n\n            for res in result:\n                res.get(timeout=35)\n\n        ssh并发(取文件状态并发送邮件)\n\n            #!/usr/bin/python\n            #encoding:utf8\n            #config file: ip.list\n\n            import paramiko\n            import multiprocessing\n            import smtplib\n            import sys,os,time,datetime,socket,re\n            from email.mime.text import MIMEText\n\n            # 配置文件(IP列表)\n            Conf = 'ip.list'\n            user_name = 'peterli'\n            user_pwd = 'passwd'\n            port = 22\n            PATH = '/home/peterli/'\n\n            # 设置服务器名称、用户名、密码以及邮件后缀\n            mail_host = \"smtp.163.com\"\n            mail_user = \"xuesong\"\n            mail_pass = \"mailpasswd\"\n            mail_postfix = \"163.com\"\n            mailto_list = [\"272121935@qq.com\",\"quanzhou722@163.com\"]\n            title = 'file check'\n\n            DATE1=(datetime.datetime.now() + datetime.timedelta(days=-1) ).strftime('%Y%m%d')\n            file_path = '%s%s' %(PATH,DATE1)\n\n            def Ssh_Cmd(file_path,host_ip,user_name,user_pwd,port=22):\n\n                s = paramiko.SSHClient()\n                s.load_system_host_keys()\n                s.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n                try:\n                    s.connect(hostname=host_ip,port=port,username=user_name,password=user_pwd)\n                    stdin,stdout,stderr = s.exec_command('stat %s' %file_path)\n                    stat_result = '%s%s' %(stdout.read(),stderr.read())\n                    if stat_result.find('No such file or directory') == -1:\n                        file_status = 'OK\\t'\n                        stdin,stdout,stderr = s.exec_command('du -sh %s' %file_path)\n                        cmd1_result = '%s_%s' %(stat_result.split()[32],stat_result.split()[33].split('.')[0])\n                        cmd2_result = ('%s%s' %(stdout.read(),stderr.read())).split()[0]\n                    else:\n                        file_status = '未生成\\t'\n                        cmd1_result = 'null'\n                        cmd2_result = 'null'\n                    q.put(['Login successful'])\n                    s.close()\n                except socket.error:\n                    file_status = '主机或端口错误'\n                    cmd1_result = '-'\n                    cmd2_result = '-'\n                except paramiko.AuthenticationException:\n                    file_status = '用户或密码错误'\n                    cmd1_result = '-'\n                    cmd2_result = '-'\n                except paramiko.BadHostKeyException:\n                    file_status = 'Bad host key'\n                    cmd1_result = '-'\n                    cmd2_result = '-'\n                except:\n                    file_status = 'ssh异常'\n                    cmd1_result = '-'\n                    cmd2_result = '-'\n                r.put('%s\\t-\\t%s\\t%s\\t%s\\t%s\\n' %(time.strftime('%Y-%m-%d_%H:%M'),host_ip,file_status,cmd2_result,cmd1_result))\n\n            def Concurrent(Conf,file_path,user_name,user_pwd,port):\n                # 执行总计\n                total = 0\n                # 读取配置文件\n                f=open(Conf)\n                list = f.readlines()\n                f.close()\n                # 并发执行\n                process_list = []\n                log_file = file('file_check.log', 'w')\n                log_file.write('检查时间\\t\\t业务\\tIP\\t\\t文件状态\\t大小\\t生成时间\\n')\n                for host_info in list:\n                    # 判断配置文件中注释行跳过\n                    if host_info.startswith('#'):\n                        continue\n                    # 取变量,其中任意变量未取到就跳过执行\n                    try:\n                        host_ip=host_info.split()[0].strip()\n                        #user_name=host_info.split()[1]\n                        #user_pwd=host_info.split()[2]\n                    except:\n                        log_file.write('Profile error: %s\\n' %(host_info))\n                        continue\n                    #try:\n                    #    port=int(host_info.split()[3])\n                    #except:\n                    #    port=22\n                    total +=1\n                    p = multiprocessing.Process(target=Ssh_Cmd,args=(file_path,host_ip,user_name,user_pwd,port))\n                    p.start()\n                    process_list.append(p)\n                for j in process_list:\n                    j.join()\n                for j in process_list:\n                    log_file.write(r.get())\n\n                successful = q.qsize()\n                log_file.write('执行完毕。 总执行:%s 登录成功:%s 登录失败:%s\\n' %(total,successful,total - successful))\n                log_file.flush()\n                log_file.close()\n\n            def send_mail(to_list, sub):\n                me = mail_user + \"<\"+mail_user+\"@\"+mail_postfix+\">\"\n                fp = open('file_check.log')\n                msg = MIMEText(fp.read(),_charset=\"utf-8\")\n                fp.close()\n                msg['Subject'] = sub\n                msg['From'] = me\n                msg['To'] = \";\".join(to_list)\n                try:\n                    send_smtp = smtplib.SMTP()\n                    send_smtp.connect(mail_host)\n                    send_smtp.login(mail_user, mail_pass)\n                    send_smtp.sendmail(me, to_list, msg.as_string())\n                    send_smtp.close()\n                    return True\n                except Exception, e:\n                    print str(e)[1]\n                    return False\n\n            if __name__ == '__main__':\n                q = multiprocessing.Queue()\n                r = multiprocessing.Queue()\n                Concurrent(Conf,file_path,user_name,user_pwd,port)\n                if send_mail(mailto_list,title):\n                    print \"发送成功\"\n                else:\n                    print \"发送失败\"\n\n    pysnmp          [snmp客户端]\n\n        #!/usr/bin/python\n        from pysnmp.entity.rfc3413.oneliner import cmdgen\n\n        cg = cmdgen.CommandGenerator()\n\n        # 注意IP 端口 组默认public  oid值\n        varBinds = cg.getCmd( cmdgen.CommunityData('any-agent', 'public',0 ), cmdgen.UdpTransportTarget(('10.10.76.42', 161)),    (1,3,6,1,4,1,2021,10,1,3,1), )\n\n        print varBinds[3][0][1]\n\n    PDB             [单步调试]\n\n        # 很多程序因为被try了,看不到具体报错的地方, 用这个模块就很清晰可以看到错误的位置\n        # http://docs.python.org/2/library/pdb.html\n\n        (Pdb) h              # 帮助\n        # 断点设置\n        (Pdb)b 10            # 断点设置在本py的第10行\n        (Pdb)b ots.py:20     # 断点设置到 ots.py第20行\n        (Pdb)b               # 查看断点编号\n        (Pdb)cl 2            # 删除第2个断点\n\n        # 运行\n        (Pdb)n               # 单步运行\n        (Pdb)s               # 细点运行 也就是会下到，方法\n        (Pdb)c               # 跳到下个断点\n        # 查看\n        (Pdb)p param         # 查看当前 变量值\n        (Pdb)l               # 查看运行到某处代码\n        (Pdb)a               # 查看全部栈内变量\n        !a = 100             # 直接赋值\n\n        python -m pdb myscript.py   # 直接对脚本单步调试\n\n        # 在程序里面加单步调试\n        import pdb\n        def tt():\n            pdb.set_trace()\n            for i in range(1, 5):\n                print i\n        >>> tt()\n        > <stdin>(3)tt()\n        (Pdb) n              #这里支持 n p c 而已\n\n    pstats          [源码性能分析测试]\n\n        import profile\n        import pstats\n\n        profile.run(\"run()\", \"prof.txt\")\n        p = pstats.Stats(\"prof.txt\")\n        p.sort_stats(\"time\").print_stats()\n\n    apscheduler     [任务调度]\n\n        # 安装   pip install apscheduler\n        # 例子   https://bitbucket.org/agronholm/apscheduler/src/e6298f953a68/tests/?at=master\n\n        scheduler.start()                                                   # 启动任务\n        job = scheduler.add_job(myfunc, 'interval', minutes=2)              # 添加任务\n        job.remove()                                                        # 删除任务\n        scheduler.add_job(myfunc, 'interval', minutes=2, id='my_job_id')    # 添加任务\n        scheduler.remove_job('my_job_id')                                   # 删除任务\n        job.modify(max_instances=6, name='Alternate name')                  # 修改工作\n        scheduler.shutdown()                                                # 关闭调度\n        scheduler.shutdown(wait=False)                                      # 关闭调度  不等待\n        # 暂停\n        apscheduler.job.Job.pause()\n        apscheduler.schedulers.base.BaseScheduler.pause_job()\n        # 恢复\n        apscheduler.job.Job.resume()\n        apscheduler.schedulers.base.BaseScheduler.resume_job()\n\n        定时任务\n            from pytz import utc\n            from apscheduler.schedulers.background import BackgroundScheduler\n            from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor\n            import time\n\n            executors = {\n                'default': ThreadPoolExecutor(20),\n                'processpool': ProcessPoolExecutor(5)\n            }\n            job_defaults = {\n                'coalesce': False,\n                'max_instances': 3\n            }\n            scheduler = BackgroundScheduler( executors=executors, job_defaults=job_defaults, timezone=utc)\n\n            def myfunc():\n                print 'test'\n\n            scheduler.add_job(myfunc, 'interval', minutes=1, id='myworkid')\n            scheduler.start()\n\n            try:\n                while True:\n                    time.sleep(2)\n                    # add_job\n            except (KeyboardInterrupt, SystemExit):\n                scheduler.shutdown()\n\n    logging         [日志记录]\n\n        # 日志级别大小关系为: critical > error > warning > info > debug > notset  也可自定义日志级别\n        import logging\n        logging.debug('debug')                 # 默认日志级别为 warning ,故debug日志不做打印\n        logging.warning('warning')             # 达到默认日志级别为WARNING,打印到屏幕 warning\n        logging.basicConfig                    # 通过logging.basicConfig函数对日志的输出格式及方式做相关配置\n            # basicConfig 相关参数帮助\n            filename               # 指定日志文件名\n            filemode               # 和file函数意义相同，指定日志文件的打开模式，'w'或'a'\n            datefmt                # 指定时间格式，同time.strftime()\n            level                  # 设置日志级别，默认为logging.WARNING\n            stream                 # 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略\n            format                 # 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:\n                %(levelno)s        # 打印日志级别的数值\n                %(levelname)s      # 打印日志级别名称\n                %(pathname)s       # 打印当前执行程序的路径，其实就是sys.argv[0]\n                %(filename)s       # 打印当前执行程序名\n                %(funcName)s       # 打印日志的当前函数\n                %(lineno)d         # 打印日志的当前行号\n                %(asctime)s        # 打印日志的时间\n                %(thread)d         # 打印线程ID\n                %(threadName)s     # 打印线程名称\n                %(process)d        # 打印进程ID\n                %(message)s        # 打印日志信息\n\n\n        logging.config.fileConfig(\"logger.conf\")        # 加载配置文件\n        logger = logging.getLogger(\"example02\")         # 使用已定义的日志记录器\n        logger.conf                                     # 配置文件\n            ###############################################\n            [loggers]\n            keys=root,example01,example02    # 设置三种日志记录器\n            [logger_root]                    # 针对单一种设置\n            level=DEBUG\n            handlers=hand01,hand02\n            [logger_example01]\n            handlers=hand01,hand02           # 使用2中处理方式 应该是根据不同级别区分的\n            qualname=example01\n            propagate=0\n            [logger_example02]\n            handlers=hand01,hand03\n            qualname=example02\n            propagate=0\n            ###############################################\n            [handlers]                      # 不同的处理方式\n            keys=hand01,hand02,hand03       # 三种方式的名字\n            [handler_hand01]                # 第一种方式配置\n            class=StreamHandler             # 发送错误信息到流\n            level=INFO                      # 日志级别\n            formatter=form02                # 日志的格式方式\n            args=(sys.stderr,)\n            [handler_hand02]\n            class=FileHandler               # FileHandler写入磁盘文件\n            level=DEBUG\n            formatter=form01\n            args=('myapp.log', 'a')         # 追加到日志文件\n            [handler_hand03]\n            class=handlers.RotatingFileHandler\n            level=INFO\n            formatter=form02\n            args=('myapp.log', 'a', 10*1024*1024, 5)    # 追加日志并切割日志\n            ###############################################\n            [formatters]                                # 针对不同处理日志方式设置具体的日志格式\n            keys=form01,form02\n            [formatter_form01]\n            format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s    # 日志列\n            datefmt=%a, %d %b %Y %H:%M:%S               # 时间格式\n            [formatter_form02]\n            format=%(name)-12s: %(levelname)-8s %(message)s\n            datefmt=\n\n\n        通用日志记录\n            import logging\n\n            logging.basicConfig(level=logging.DEBUG,\n                            format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',\n                            datefmt='%Y-%m-%d %H:%M:%S',\n                            filename='/var/log/myapp.log',\n                            filemode='a')\n            # 日志级别DEBUG或高于DEBUG的会写入文件 myapp.log 中\n            logging.debug('debug message')\n            logging.info('info message')\n            logging.warning('warning message')\n\n\n    ConfigParser    [配置解析]\n\n        写入配置文件\n\n            import ConfigParser\n            config = ConfigParser.RawConfigParser()\n            config.add_section('Section1')                          # 添加配置文件的块 [name]\n            config.set('Section1', 'an_int', '15')                  # 针对块设置配置参数和值\n            config.set('Section1', 'a_bool', 'true')\n            config.set('Section1', 'a_float', '3.1415')\n            config.set('Section1', 'baz', 'fun')\n            config.set('Section1', 'bar', 'Python')\n            config.set('Section1', 'foo', '%(bar)s is %(baz)s!')\n            with open('example.cfg', 'wb') as configfile:           # 指定配置文件路径\n                config.write(configfile)                            # 写入配置文件\n\n        读取配置文件\n\n            import ConfigParser\n            config = ConfigParser.RawConfigParser()\n            config.read('example.cfg')                              # 读取配置文件\n            a_float = config.getfloat('Section1', 'a_float')        # 获取配置文件参数对应的浮点值,如参数值类型不对则报ValueError\n            an_int = config.getint('Section1', 'an_int')            # 获取配置文件参数对应的整数值,可直接进行计算\n            print a_float + an_int\n            if config.getboolean('Section1', 'a_bool'):             # 根据配置文件参数值是否为真\n                print config.get('Section1', 'foo')                 # 再获取依赖的配置参数 get获取后值为字符串\n            print config.get('Section1', 'foo', 0)                  # 获取配置文件参数的同时加载变量[配置文件中的参数]\n            print config.get('Section1', 'foo', 1)                  # 获取配置文件参数 原始值不做任何改动 不使用变量\n            config.remove_option('Section1', 'bar')                 # 删除读取配置文件获取bar的值\n            config.remove_option('Section1', 'baz')\n            print config.get('Section1', 'foo', 0, {'bar': 'str1', 'baz': 'str1'})    # 读取配置参数的同时设置变量的值\n\n\n        import ConfigParser\n        import io\n\n        sample_config = \"\"\"\n        [mysqld]\n        user = mysql\n        pid-file = /var/run/mysqld/mysqld.pid\n        skip-external-locking\n        old_passwords = 1\n        skip-bdb\n        skip-innodb\n        \"\"\"\n        config = ConfigParser.RawConfigParser(allow_no_value=True)\n        config.readfp(io.BytesIO(sample_config))\n        config.get(\"mysqld\", \"user\")\n\n    ftplib          [ftp客户端]\n\n        from ftplib import FTP\n        ftp = FTP('ftp.debian.org')     # 连接ftp地址   FTP(host,port,timeout)\n        ftp.login()                     # 使用默认anonymous登录  login(user,passwd)\n        ftp.cwd('debian')               # 切换到目录debian\n        ftp.retrlines('LIST')           # 打印目录列表\n        ftp.retrbinary('RETR README', open('README', 'wb').write)       # 下载文件写到本地\n        ftp.delete('filename')          # 删除ftp中文件\n        ftp.mkd('dirname')              # 在ftp上创建目录\n        ftp.size('filename')            # 查看文件大小\n        ftp.quit()\n\n    difflib         [对象比较]\n\n        import difflib\n        s1 = ['bacon\\n', 'eggs\\n', 'ham\\n', 'guido\\n']\n        s2 = ['python\\n', 'eggy\\n', 'hamster\\n', 'guido\\n']\n        for line in difflib.context_diff(s1, s2, fromfile='txt-s1', tofile='txt-s2'):    # 两字列表比较差异\n            sys.stdout.write(line)\n\n        difflib.get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])           # 模糊匹配 匹配列表与字符串相似的值，越相似越靠前\n\n    heapq           [优先队列算法]\n\n        from heapq import *\n        h = []\n        heappush(h, (5, 'write code'))          # 放入队列\n        heappush(h, (7, 'release product'))\n        heappush(h, (1, 'write spec'))\n        heappush(h, (3, 'create tests'))\n        heappop(h)                              # 从队列取出 第一次是1\n\n        from heapq import *\n        def heapsort(iterable):\n            h = []\n            for value in iterable:\n                heappush(h, value)\n            return [heappop(h) for i in range(len(h))]\n\n        heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\n\n    linecache       [随机读取指定行]\n\n        import linecache\n        linecache.getline('/etc/passwd', 4)\n\n    json            [数据交换格式]\n\n        #!/usr/bin/python\n        import json\n\n        #json file temp.json\n        #{ \"name\":\"00_sample_case1\", \"description\":\"an example.\"}\n\n        f = file(\"temp.json\");\n        s = json.load(f)        # 直接读取json文件\n        print s\n        f.close\n\n        d = {\"a\":1}\n        j=json.dumps(d)  # 字典转json\n        json.loads(j)    # json转字典\n\n        s = json.loads('{\"name\":\"test\", \"type\":{\"name\":\"seq\", \"parameter\":[\"1\", \"2\"]}}')\n        print type(s)    # dic\n        print s\n        print s.keys()\n        print s[\"type\"][\"parameter\"][1]\n\n        json.dumps({'ret':'cmd_ret0', 'out':'cmd_ret1'}, separators=(',', ':'))    # 紧凑的json格式,去掉空格\n\n    filecmp         [文件目录比较]\n\n        filecmp.cmp('/etc/passwd', '/etc/passwd')     # 比较两文件是否一致\n\n        # 比较两目录下文件是否一致\n        from filecmp import dircmp\n        def print_diff_files(dcmp):\n            for name in dcmp.diff_files:\n                print \"diff_file %s found in %s and %s\" % (name, dcmp.left, dcmp.right)\n            for sub_dcmp in dcmp.subdirs.values():\n                print_diff_files(sub_dcmp)\n\n        dcmp = dircmp('dir1', 'dir2')\n        print_diff_files(dcmp)\n\n    errno           [符号错误码]\n\n        https://docs.python.org/2/library/errno.html#module-errno\n\n        import errno\n\n        try:\n            fp = open(\"no.such.file\")\n        except IOError, (error, message):\n            if error == errno.ENOENT:\n                print \"no such file\"\n            elif error == errno.EPERM:\n                print \"permission denied\"\n            else:\n                print message\n\n    Exceptions      [标准异常类]\n\n        # 详见官网 不需要导入\n        https://docs.python.org/2/library/exceptions.html#module-exceptions\n\n    ctypes          [调用C的动态库]\n\n        提供和C语言兼容的数据类型,也可调用C的动态库\n\n        http://blog.csdn.net/linda1000/article/details/12623527\n        http://www.cnblogs.com/wuchang/archive/2010/04/04/1704456.html\n        http://www.ibm.com/developerworks/cn/linux/l-cn-pythonandc/\n\n    daemon          [守护进程]\n\n        daemon.py\n\n            # 创建守护进程的模块\n            #!/usr/bin/env python\n\n            import sys, os, time, atexit\n            from signal import SIGTERM\n\n            class Daemon:\n                \"\"\"\n                A generic daemon class.\n\n                Usage: subclass the Daemon class and override the run() method\n                \"\"\"\n                def __init__(self, pidfile='nbMon.pid', stdin='/dev/null', stdout='nbMon.log', stderr='nbMon.log'):\n                    self.stdin = stdin\n                    self.stdout = stdout\n                    self.stderr = stderr\n                    self.pidfile = pidfile\n\n                def daemonize(self):\n                    \"\"\"\n                    do the UNIX double-fork magic, see Stevens' \"Advanced\n                    Programming in the UNIX Environment\" for details (ISBN 0201563177)\n                    http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16\n                    \"\"\"\n                    try:\n                        pid = os.fork()\n                        if pid > 0:\n                            # exit first parent\n                            sys.exit(0)\n                    except OSError, e:\n                        sys.stderr.write(\"fork #1 failed: %d (%s)\\n\" % (e.errno, e.strerror))\n                        sys.exit(1)\n\n                    # decouple from parent environment\n                    #os.chdir(\"/\")\n                    os.setsid()\n                    os.umask(0)\n\n                    # do second fork\n                    try:\n                        pid = os.fork()\n                        if pid > 0:\n                            # exit from second parent\n                            sys.exit(0)\n                    except OSError, e:\n                        sys.stderr.write(\"fork #2 failed: %d (%s)\\n\" % (e.errno, e.strerror))\n                        sys.exit(1)\n\n                    # redirect standard file descriptors\n                    sys.stdout.flush()\n                    sys.stderr.flush()\n                    si = file(self.stdin, 'r')\n                    so = file(self.stdout, 'a+')\n                    se = file(self.stderr, 'a+', 0)\n                    os.dup2(si.fileno(), sys.stdin.fileno())\n                    os.dup2(so.fileno(), sys.stdout.fileno())\n                    os.dup2(se.fileno(), sys.stderr.fileno())\n\n                    # write pidfile\n                    atexit.register(self.delpid)\n                    pid = str(os.getpid())\n                    file(self.pidfile,'w+').write(\"%s\\n\" % pid)\n\n                def delpid(self):\n                    os.remove(self.pidfile)\n\n                def start(self):\n                    \"\"\"\n                    Start the daemon\n                    \"\"\"\n                    # Check for a pidfile to see if the daemon already runs\n                    try:\n                        pf = file(self.pidfile,'r')\n                        pid = int(pf.read().strip())\n                        pf.close()\n                    except IOError:\n                        pid = None\n\n                    if pid:\n                        message = \"pidfile %s already exist. Daemon already running?\\n\"\n                        sys.stderr.write(message % self.pidfile)\n                        sys.exit(1)\n\n                    # Start the daemon\n                    self.daemonize()\n                    self.run()\n\n                def stop(self):\n                    \"\"\"\n                    Stop the daemon\n                    \"\"\"\n                    # Get the pid from the pidfile\n                    try:\n                        pf = file(self.pidfile,'r')\n                        pid = int(pf.read().strip())\n                        pf.close()\n                    except IOError:\n                        pid = None\n\n                    if not pid:\n                        message = \"pidfile %s does not exist. Daemon not running?\\n\"\n                        sys.stderr.write(message % self.pidfile)\n                        return # not an error in a restart\n\n                    # Try killing the daemon process\n                    try:\n                        while 1:\n                            os.kill(pid, SIGTERM)\n                            time.sleep(0.1)\n                    except OSError, err:\n                        err = str(err)\n                        if err.find(\"No such process\") > 0:\n                            if os.path.exists(self.pidfile):\n                                os.remove(self.pidfile)\n                        else:\n                            print str(err)\n                            sys.exit(1)\n\n                def restart(self):\n                    \"\"\"\n                    Restart the daemon\n                    \"\"\"\n                    self.stop()\n                    self.start()\n\n                def run(self):\n                    \"\"\"\n                    You should override this method when you subclass Daemon. It will be called after the process has been\n                    daemonized by start() or restart().\n                    \"\"\"\n\n        run_daemon.py\n\n            # 启动脚本,倒入需要后台启动的模块,继承Daemon类,覆盖run函数\n            # 启动方式  python run_daemon.py start\n\n            #!/usr/bin/env python\n            import Queue\n            import threading\n            import sys, time\n            import urllib2\n            import json\n            import framework\n            from moniItems import mon\n            from daemon import Daemon\n\n            class MyDaemon(Daemon):\n                def run(self):\n                    print 'start'\n                    framework.startTh()\n                    print 'stop2'\n\n            if __name__ == \"__main__\":\n                daemon = MyDaemon()\n                if len(sys.argv) == 2:\n                    if 'start' == sys.argv[1]:\n                        daemon.start()\n                    elif 'stop' == sys.argv[1]:\n                        daemon.stop()\n                    elif 'restart' == sys.argv[1]:\n                        daemon.restart()\n                    else:\n                        print \"Unknown command\"\n                        sys.exit(2)\n                    sys.exit(0)\n                else:\n                    print \"usage: %s start|stop|restart\" % sys.argv[0]\n                    sys.exit(2)\n\n    psutil          [获取系统信息]\n\n        pip install psutil                     # 安装\n\n        import psutil\n        dir(psutil)\n        psutil.boot_time()                     # 开机时间\n        psutil.virtual_memory()                # 内存详细信息\n        psutil.virtual_memory().total          # 内存总大小\n        psutil.disk_partitions()               # 获取磁盘信息\n        psutil.disk_io_counters()              # 磁盘IO信息\n        psutil.net_io_counters()               # 获取网络IO信息\n\n        psutil.pids()                          # 返回所有进程PID\n        psutil.Process(PID)                    # 获取进程信息\n        psutil.Process(PID).name()             # 指定进程的进程名\n        psutil.Process(PID).exe()              # 进程的路径\n        psutil.Process(PID).cwd()              # 进程工作路径\n        psutil.Process(PID).status()           # 进程状态\n        psutil.Process(PID).create_time()      # 进程创建时间\n        psutil.Process(PID).memory_percent()   # 进程内存使用率\n        psutil.Process(PID).io_counters()      # 进程IO信息\n        psutil.Process(PID).num_threads()      # 进程线程数\n\n    ldap            [统一认证]\n        yum install openldap  openldap-clients openldap-devel openssl-devel setuptools==30.1.0\n        sudo pip uninstall ldap ldap3\n        pip install python-ldap\n        import ldap\n        con = ldap.initialize(\"ldap://10.10.10.156:389\")\n        con.simple_bind_s(\"cn=admin,ou=People,dc=gt,dc=com\", \"pwd\")\n        res = con.search_s(\"dc=gt,dc=com\", ldap.SCOPE_SUBTREE, '(uid=*)', ['*', '+'], 0)\n\n    watchdog        [监视文件实时写入]\n\n        https://pypi.python.org/pypi/watchdog\n        pip install watchdog\n\n        import sys\n        import time\n        import logging\n        from watchdog.observers import Observer\n        from watchdog.events import LoggingEventHandler\n\n        if __name__ == \"__main__\":\n            logging.basicConfig(level=logging.INFO,\n                                format='%(asctime)s - %(message)s',\n                                datefmt='%Y-%m-%d %H:%M:%S')\n            path = sys.argv[1] if len(sys.argv) > 1 else '.'\n            event_handler = LoggingEventHandler()\n            observer = Observer()\n            observer.schedule(event_handler, path, recursive=True)\n            observer.start()\n            try:\n                while True:\n                    time.sleep(1)\n            except KeyboardInterrupt:\n                observer.stop()\n            observer.join()\n\n    yaml            [标记语言]\n\n        pip  install  pyyaml\n\n        import yaml\n\n        a = yaml.load(\"\"\"\n        name: Vorlin Laruknuzum\n        sex: Male\n        class: Priest\n        title: Acolyte\n        hp: [32, 71]\n        sp: [1, 13]\n        gold: 423\n        inventory:\n        - a Holy Book of Prayers (Words of Wisdom)\n        - an Azure Potion of Cure Light Wounds\n        - a Silver Wand of Wonder\n        \"\"\")\n\n        print a['inventory'][1]     # 字典\n        print yaml.dump(a)          # 把字典生成yaml文件\n        yaml.load_all               # 生成迭代器\n\n        print yaml.dump({'name': \"The Cloak 'Colluin'\", 'depth': 5, 'rarity': 45,\n            'weight': 10, 'cost': 50000, 'flags': ['INT', 'WIS', 'SPEED', 'STEALTH']})\n\n    itertools       [迭代功能函数]\n\n        import itertools\n        # 全排序\n        print list(itertools.permutations(['a', 'b', 'c', 'd'],4))\n\n        # 无限迭代\n        ns = itertools.count(1)\n        for n in ns:\n            print n\n\n        # 指定次数循环\n        ns = itertools.repeat('A', 10)\n        for n in ns:\n            print n\n\n3 socket\n\n    socket.gethostname()     # 获取主机名\n    from socket import *     # 避免 socket.socket()\n    s=socket()\n    s.bind()                 # 绑定地址到套接字\n    s.listen()               # 开始TCP监听\n    s.accept()               # 被动接受TCP客户端连接，等待连接的到来\n    s.connect()              # 主动初始化TCP服务器连接\n    s.connect_ex()           # connect()函数的扩展版本，出错时返回出错码，而不是跑出异常\n    s.recv()                 # 接收TCP数据\n    s.send()                 # 发送TCP数据\n    s.sendall()              # 完整发送TCP数据\n    s.recvfrom()             # 接收UDP数据\n    s.sendto()               # 发送UDP数据\n    s.getpeername()          # 连接到当前套接字的远端的地址(TCP连接)\n    s.getsockname()          # 当前套接字的地址\n    s.getsockopt()           # 返回指定套接字的参数\n    s.setsockopt()           # 设置指定套接字的参数\n    s.close()                # 关闭套接字\n    s.setblocking()          # 设置套接字的阻塞与非阻塞模式\n    s.settimeout()           # 设置阻塞套接字操作的超时时间\n    s.gettimeout()           # 得到阻塞套接字操作的超时时间\n    s.makefile()             # 创建一个与该套接字关联的文件对象\n    s.fileno()               # 套接字获取对应的文件描述符fd\n\n    socket.AF_UNIX           # 只能够用于单一的Unix系统进程间通信\n    socket.AF_INET           # 服务器之间网络通信\n    socket.AF_INET6          # IPv6\n\n    socket.SOCK_STREAM       # 流式socket , for TCP\n    socket.SOCK_DGRAM        # 数据报式socket , for UDP\n    socket.SOCK_RAW          # 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。\n\n    socket.SOCK_RDM          # 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。\n\n    socket.SOCK_SEQPACKET    # 可靠的连续数据包服务\n\n    socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)   # 关闭server后马上释放端口,避免被TIME_WAIT占用\n\n    select          [IO多路复用的机制]\n\n        # select每次遍历都需要把fd集合从用户态拷贝到内核态,开销较大,受系统限制最大1024\n        select.select(rlist, wlist, xlist[, timeout])\n        # poll和select很像 通过一个pollfd数组向内核传递需要关注的事件,没有描述符1024限制\n        select.poll()\n        # 创建epoll句柄,注册监听事件,通过回调函数等待事件产生,不做主动扫描,整个过程对fd只做一次拷贝.打开最大文件数后,不受限制,1GB内存大约是10万链接\n        select.epoll([sizehint=-1])\n\n        select.epoll\n\n            EPOLLIN                # 监听可读事件\n            EPOLLET                # 高速边缘触发模式,即触发后不会再次触发直到新接收数据\n            EPOLLOUT               # 监听写事件\n\n            epoll.poll([timeout=-1[, maxevents=-1]]) # 等待事件,未指定超时时间[毫秒]则为一直阻塞等待\n            epoll.register(fd,EPOLLIN)               # 向epoll句柄中注册,新来socket链接,监听可读事件\n            epoll.modify(fd, EPOLLET | EPOLLOUT)     # 改变监听事件为边缘触发,监听写事件\n            epoll.fileno()                           # 通过链接对象得到fd\n            epoll.unregister(fd)                     # 取消fd监听事件\n\n    SocketServer\n\n        #!/usr/bin/python\n        #server.py\n        import SocketServer\n        import os\n        class MyTCP(SocketServer.BaseRequestHandler):\n            def handle(self):\n                # 应该已经封装好了 不需要这层while了 可能会引起大量 close_wait\n                while True:\n                    self.data=self.request.recv(1024).strip()\n                    if self.data == 'quit' or not self.data:break\n\n                    cmd=os.popen(self.data).read()\n                    if cmd == '':cmd= self.data + ': Command not found'\n                    self.request.sendall(cmd)\n        if __name__ == '__main__':\n            HOST,PORT = '10.0.0.119',50007\n            server = SocketServer.ThreadingTCPServer((HOST,PORT),MyTCP)\n            server.serve_forever()\n\n    SocketClient\n\n        #!/usr/bin/python\n        #client.py\n        import socket\n\n        HOST='10.0.0.119'\n        PORT=50007\n        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n        s.connect((HOST,PORT))\n\n        while True:\n            while True:\n                cmd=raw_input('CMD:').strip()\n                if cmd != '':break\n            s.sendall(cmd)\n            data=s.recv(1024).split('\\n')\n            print 'cmd:'\n            for line in data:print line\n        s.close()\n\n    ftp\n\n        ftpserver\n\n            #!/usr/bin/python\n            #ftpserver.py\n\n            import SocketServer\n            import os\n            import cPickle\n            import md5\n            from time import sleep\n\n            def filer(file1):\n                try:\n                    f = file(file1,'rb')\n                    return cPickle.load(f)\n                except IOError:\n                    return {}\n                except EOFError:\n                    return {}\n                f.close()\n\n            def filew(file1,content):\n                f = file(file1,'wb')\n                cPickle.dump(content,f)\n                f.close()\n\n            class MyTCP(SocketServer.BaseRequestHandler):\n                def handle(self):\n                    i = 0\n                    while i<3:\n                        user=self.request.recv(1024).strip()\n                        userinfo=filer('user.pkl')\n                        if userinfo.has_key(user.split()[0]):\n                            if md5.new(user.split()[1]).hexdigest() == userinfo[user.split()[0]]:\n                                results='login successful'\n                                self.request.sendall(results)\n                                login='successful'\n                                break\n                            else:\n                                i = i + 1\n                                results='Error:password not correct'\n                                self.request.sendall(results)\n                                continue\n                        else:\n                            i = i + 1\n                            results='Error:password not correct'\n                            self.request.sendall(results)\n                            continue\n                        break\n                    else:\n                        results = 'Error:Wrong password too many times'\n                        self.request.sendall(results)\n                        login='failure'\n                    home_path = os.popen('pwd').read().strip() + '/' + user.split()[0]\n                    current_path = '/'\n                    print home_path\n                    while True:\n                        if login == 'failure':\n                            break\n                        print 'home_path:%s=current_path:%s' %(home_path,current_path)\n                        cmd=self.request.recv(1024).strip()\n                        print cmd\n                        if cmd == 'quit':\n                            break\n                        elif cmd == 'dir':\n                            list=os.listdir('%s%s' %(home_path,current_path))\n                            if list:\n                                dirlist,filelist = '',''\n                                for i in list:\n                                    if os.path.isdir('%s%s%s' %(home_path,current_path,i)):\n                                        dirlist = dirlist + '\\033[32m' + i + '\\033[m\\t'\n                                    else:\n                                        filelist = filelist + i + '\\t'\n                                results = dirlist + filelist\n                            else:\n                                results = '\\033[31mnot find\\033[m'\n                            self.request.sendall(results)\n                        elif cmd == 'pdir':\n                            self.request.sendall(current_path)\n                        elif cmd.split()[0] == 'mdir':\n                            if cmd.split()[1].isalnum():\n                                tmppath='%s%s%s' %(home_path,current_path,cmd.split()[1])\n                                os.makedirs(tmppath)\n                                self.request.sendall('\\033[32mcreating successful\\033[m')\n                            else:\n                                self.request.sendall('\\033[31mcreate failure\\033[m')\n                        elif cmd.split()[0] == 'cdir':\n                            if cmd.split()[1] == '/':\n                                tmppath='%s%s' %(home_path,cmd.split()[1])\n                                if os.path.isdir(tmppath):\n                                    current_path = cmd.split()[1]\n                                    self.request.sendall(current_path)\n                                else:\n                                    self.request.sendall('\\033[31mnot_directory\\033[m')\n                            elif cmd.split()[1].startswith('/'):\n                                tmppath='%s%s' %(home_path,cmd.split()[1])\n                                if os.path.isdir(tmppath):\n                                    current_path = cmd.split()[1] + '/'\n                                    self.request.sendall(current_path)\n                                else:\n                                    self.request.sendall('\\033[31mnot_directory\\033[m')\n                            else:\n                                tmppath='%s%s%s' %(home_path,current_path,cmd.split()[1])\n                                if os.path.isdir(tmppath):\n                                    current_path = current_path + cmd.split()[1] + '/'\n                                    self.request.sendall(current_path)\n                                else:\n                                    self.request.sendall('\\033[31mnot_directory\\033[m')\n                        elif cmd.split()[0] == 'get':\n                            if os.path.isfile('%s%s%s' %(home_path,current_path,cmd.split()[1])):\n                                f = file('%s%s%s' %(home_path,current_path,cmd.split()[1]),'rb')\n                                self.request.sendall('ready_file')\n                                sleep(0.5)\n                                self.request.send(f.read())\n                                f.close()\n                                sleep(0.5)\n                            elif os.path.isdir('%s%s%s' %(home_path,current_path,cmd.split()[1])):\n                                self.request.sendall('ready_dir')\n                                sleep(0.5)\n                                for dirpath in os.walk('%s%s%s' %(home_path,current_path,cmd.split()[1])):\n                                    dir=dirpath[0].replace('%s%s' %(home_path,current_path),'',1)\n                                    self.request.sendall(dir)\n                                    sleep(0.5)\n                                    for filename in dirpath[2]:\n                                        self.request.sendall(filename)\n                                        sleep(0.5)\n                                        f = file('%s/%s' %(dirpath[0],filename),'rb')\n                                        self.request.send(f.read())\n                                        f.close()\n                                        sleep(0.5)\n                                        self.request.sendall('file_get_done')\n                                        sleep(0.5)\n                                    else:\n                                        self.request.sendall('dir_get_done')\n                                    sleep(0.5)\n                            else:\n                                self.request.sendall('get_failure')\n                                continue\n                            self.request.sendall('get_done')\n\n                        elif cmd.split()[0] == 'send':\n                            if os.path.exists('%s%s%s' %(home_path,current_path,cmd.split()[1])):\n                                self.request.sendall('existing')\n                                action=self.request.recv(1024)\n                                if action == 'cancel':\n                                    continue\n                            self.request.sendall('ready')\n                            msg=self.request.recv(1024)\n                            if msg == 'ready_file':\n                                f = file('%s%s%s' %(home_path,current_path,cmd.split()[1]),'wb')\n                                while True:\n                                    data=self.request.recv(1024)\n                                    if data == 'file_send_done':break\n                                    f.write(data)\n                                f.close()\n\n                            elif msg == 'ready_dir':\n                                os.system('mkdir -p %s%s%s' %(home_path,current_path,cmd.split()[1]))\n                                while True:\n                                    dir=self.request.recv(1024)\n                                    if dir == 'get_done':break\n                                    os.system('mkdir -p %s%s%s' %(home_path,current_path,dir))\n                                    while True:\n                                        filename=self.request.recv(1024)\n                                        if filename == 'dir_send_done':break\n                                        f = file('%s%s%s/%s' %(home_path,current_path,dir,filename),'wb')\n                                        while True:\n                                            data=self.request.recv(1024)\n                                            if data == 'file_send_done':break\n                                            f.write(data)\n                                        f.close()\n                                        self.request.sendall('%s/%s\\t\\033[32mfile_done\\033[m' %(dir,filename))\n                                    self.request.sendall('%s\\t\\033[32mdir_done\\033[m' %(dir))\n                            elif msg == 'unknown_file':\n                                continue\n\n                        else:\n                            results = cmd.split()[0] + ': Command not found'\n                            self.request.sendall(results)\n\n            if __name__ == '__main__':\n                HOST,PORT = '10.152.14.85',50007\n                server = SocketServer.ThreadingTCPServer((HOST,PORT),MyTCP)\n                server.serve_forever()\n\n        ftpmanage\n\n            #!/usr/bin/python\n            #manage_ftp.py\n            import cPickle\n            import sys\n            import md5\n            import os\n            import getpass\n\n            def filer(file1):\n                try:\n                    f = file(file1,'rb')\n                    return cPickle.load(f)\n                except IOError:\n                    return {}\n                except EOFError:\n                    return {}\n                f.close()\n\n            def filew(file1,content):\n                f = file(file1,'wb')\n                cPickle.dump(content,f)\n                f.close()\n\n            while True:\n                print '''\n                1.add user\n                2.del user\n                3.change password\n                4.query user\n                0.exit\n                '''\n                i = raw_input(':').strip()\n                userinfo=filer('user.pkl')\n                if i == '':\n                    continue\n                elif i == '1':\n                    while True:\n                        user=raw_input('user name:').strip()\n                        if user.isalnum():\n                            i = 0\n                            while i<3:\n                                passwd=getpass.getpass('passwd:').strip()\n                                if passwd == '':\n                                    continue\n                                else:\n                                    passwd1=getpass.getpass('Confirm password:').strip()\n                                    if passwd == passwd1:\n                                        mpasswd = md5.new(passwd).hexdigest()\n                                        userinfo[user] = mpasswd\n                                        os.system('mkdir -p %s' %user)\n                                        print '%s creating successful ' %user\n                                        break\n                                    else:\n                                        print \"Passwords don't match \"\n                                        i = i + 1\n                                        continue\n                            else:\n                                print 'Too many wrong'\n                                continue\n                            break\n                        else:\n                            print 'user not legal'\n                            continue\n                elif i == '2':\n                    user=raw_input('user name:').strip()\n                    if userinfo.has_key(user):\n                        del userinfo[user]\n                        print 'Delete users successfully'\n                    else:\n                        print 'user not exist'\n                        continue\n                elif i == '3':\n                    user=raw_input('user name:').strip()\n                    if userinfo.has_key(user):\n                        i = 0\n                        while i<3:\n                            passwd=getpass.getpass('passwd:').strip()\n                            if passwd == '':\n                                continue\n                            else:\n                                passwd1=getpass.getpass('Confirm password:').strip()\n                                if passwd == passwd1:\n                                    mpasswd = md5.new(passwd).hexdigest()\n                                    userinfo[user] = mpasswd\n                                    print '%s password is changed' %user\n                                    break\n                                else:\n                                    print \"Passwords don't match \"\n                                    i = i + 1\n                                    continue\n                        else:\n                            print 'Too many wrong'\n                            continue\n                    else:\n                        print 'user not exist'\n                        continue\n                elif i == '4':\n                    print userinfo.keys()\n                elif i == '0':\n                    sys.exit()\n                else:\n                    print 'select error'\n                    continue\n                filew('user.pkl',content=userinfo)\n\n        ftpclient\n\n            #!/usr/bin/python\n            #ftpclient.py\n\n            import socket\n            import os\n            import getpass\n            from time import sleep\n\n            HOST='10.152.14.85'\n            PORT=50007\n            s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n            s.connect((HOST,PORT))\n\n            while True:\n                user = raw_input('user:').strip()\n                if user.isalnum():\n                    while True:\n                        passwd = getpass.getpass('passwd:').strip()\n                        s.sendall(user + ' ' + passwd)\n                        servercmd=s.recv(1024)\n                        if servercmd == 'login successful':\n                            print '\\033[32m%s\\033[m' %servercmd\n                            break\n                        else:\n                            print servercmd\n\n                    while True:\n                        cmd=raw_input('FTP>').strip()\n                        if cmd == '':\n                            continue\n                        if cmd.split()[0] == 'get':\n                            if cmd == 'get':continue\n                            for i in cmd.split()[1:]:\n                                if os.path.exists(i):\n                                    confirm = raw_input(\"\\033[31mPlease confirm whether the cover %s(Y/N):\\033[m\" %(i)).upper().startswith('Y')\n                                    if not confirm:\n                                        print '%s cancel' %i\n                                        continue\n                                s.sendall('get ' + i)\n                                servercmd=s.recv(1024)\n                                if servercmd == 'inexistence':\n                                    print '%s \\t\\033[32minexistence\\033[m' %i\n                                    continue\n                                elif servercmd == 'ready_file':\n                                    f = file(i,'wb')\n                                    while True:\n                                        data=s.recv(1024)\n                                        if data == 'get_done':break\n                                        f.write(data)\n                                    f.close()\n                                    print '%s \\t\\033[32mfile_done\\033[m' %(i)\n                                elif servercmd == 'ready_dir':\n                                    try:\n                                        os.makedirs(i)\n                                    except:\n                                        pass\n                                    while True:\n                                        serverdir=s.recv(1024)\n                                        if serverdir == 'get_done':break\n                                        os.system('mkdir -p %s' %serverdir)\n                                        print '%s \\t\\033[32mdir_done\\033[m' %(serverdir)\n                                        while True:\n                                            serverfile=s.recv(1024)\n                                            if serverfile == 'dir_get_done':break\n                                            f = file('%s/%s' %(serverdir,serverfile),'wb')\n                                            while True:\n                                                data=s.recv(1024)\n                                                if data == 'file_get_done':break\n                                                f.write(data)\n                                            f.close()\n                                            print '%s/%s \\t\\033[32mfile_done\\033[m' %(serverdir,serverfile)\n\n                        elif cmd.split()[0] == 'send':\n\n                            if cmd == 'send':continue\n                            for i in cmd.split()[1:]:\n                                if not os.path.exists(i):\n                                    print '%s\\t\\033[31minexistence\\033[m' %i\n                                    continue\n\n                                s.sendall('send ' + i)\n                                servercmd=s.recv(1024)\n                                if servercmd == 'existing':\n                                    confirm = raw_input(\"\\033[31mPlease confirm whether the cover %s(Y/N):\\033[m\" %(i)).upper().startswith('Y')\n                                    if confirm:\n                                        s.sendall('cover')\n                                        servercmd=s.recv(1024)\n                                    else:\n                                        s.sendall('cancel')\n                                        print '%s\\tcancel' %i\n                                        continue\n\n                                if os.path.isfile(i):\n                                    s.sendall('ready_file')\n                                    sleep(0.5)\n                                    f = file(i,'rb')\n                                    s.send(f.read())\n                                    sleep(0.5)\n                                    s.sendall('file_send_done')\n                                    print '%s\\t\\033[32mfile done\\033[m' %(cmd.split()[1])\n                                    f.close()\n                                elif os.path.isdir(i):\n                                    s.sendall('ready_dir')\n                                    sleep(0.5)\n                                    for dirpath in os.walk(i):\n                                        dir=dirpath[0].replace('%s/' %os.popen('pwd').read().strip(),'',1)\n                                        s.sendall(dir)\n                                        sleep(0.5)\n                                        for filename in dirpath[2]:\n                                            s.sendall(filename)\n                                            sleep(0.5)\n                                            f = file('%s/%s' %(dirpath[0],filename),'rb')\n                                            s.send(f.read())\n                                            f.close()\n                                            sleep(0.5)\n                                            s.sendall('file_send_done')\n                                            msg=s.recv(1024)\n                                            print msg\n\n                                        else:\n                                            s.sendall('dir_send_done')\n                                            msg=s.recv(1024)\n                                            print msg\n\n                                else:\n                                    s.sendall('unknown_file')\n                                    print '%s\\t\\033[31munknown type\\033[m' %i\n                                    continue\n                                sleep(0.5)\n                                s.sendall('get_done')\n\n                        elif cmd.split()[0] == 'cdir':\n                            if cmd == 'cdir':continue\n                            s.sendall(cmd)\n                            data=s.recv(1024)\n                            print data\n                            continue\n                        elif cmd == 'ls':\n                            list=os.popen(cmd).read().strip().split('\\n')\n                            if list:\n                                dirlist,filelist = '',''\n                                for i in list:\n                                    if os.path.isdir(i):\n                                        dirlist = dirlist + '\\033[32m' + i + '\\033[m\\t'\n                                    else:\n                                        filelist = filelist + i + '\\t'\n                                results = dirlist + filelist\n                            else:\n                                results = '\\033[31mnot find\\033[m'\n                            print results\n                            continue\n                        elif cmd == 'pwd':\n                            os.system(cmd)\n                        elif cmd.split()[0] == 'cd':\n                            try:\n                                os.chdir(cmd.split()[1])\n                            except:\n                                print '\\033[31mcd failure\\033[m'\n                        elif cmd == 'dir':\n                            s.sendall(cmd)\n                            data=s.recv(1024)\n                            print data\n                            continue\n                        elif cmd == 'pdir':\n                            s.sendall(cmd)\n                            data=s.recv(1024)\n                            print data\n                            continue\n                        elif cmd.split()[0] == 'mdir':\n                            if cmd == 'mdir':continue\n                            s.sendall(cmd)\n                            data=s.recv(1024)\n                            print data\n                            continue\n                        elif cmd.split()[0] == 'help':\n                            print '''\n                get [file] [dir]\n                send [file] [dir]\n\n                dir\n                mdir\n                cdir\n                pdir\n\n                pwd\n                md\n                cd\n                ls\n\n                help\n                quit\n                '''\n                            continue\n                        elif cmd == 'quit':\n                            break\n                        else:\n                            print '\\033[31m%s: Command not found,Please see the \"help\"\\033[m' %cmd\n                else:\n                    continue\n                break\n            s.close()\n\n    扫描主机开放端口\n        #!/usr/bin/env python\n\n        import socket\n\n        def check_server(address,port):\n            s=socket.socket()\n            try:\n                s.connect((address,port))\n                return True\n            except socket.error,e:\n                return False\n\n        if __name__=='__main__':\n            from optparse import OptionParser\n            parser=OptionParser()\n            parser.add_option(\"-a\",\"--address\",dest=\"address\",default='localhost',help=\"Address for server\",metavar=\"ADDRESS\")\n            parser.add_option(\"-s\",\"--start\",dest=\"start_port\",type=\"int\",default=1,help=\"start port\",metavar=\"SPORT\")\n            parser.add_option(\"-e\",\"--end\",dest=\"end_port\",type=\"int\",default=1,help=\"end port\",metavar=\"EPORT\")\n            (options,args)=parser.parse_args()\n            print 'options: %s, args: %s' % (options, args)\n            port=options.start_port\n            while(port<=options.end_port):\n                check = check_server(options.address, port)\n                if (check):\n                    print 'Port  %s is on' % port\n                port=port+1\n\n    zmq [网络通讯库]\n\n        # https://github.com/zeromq/pyzmq\n        # pip install pyzmq\n        # ZMQ是一个开源的、跨语言的、非常简洁的、非常高性能、非常灵活的网络通讯库\n\n        服务端程序\n            import zmq\n            context = zmq.Context()\n            socket = context.socket(zmq.REP)\n            socket.bind(\"tcp://127.0.0.1:1234\")   # 提供传输协议  INPROC  IPC  MULTICAST  TCP\n\n            while True :\n                msg = socket.recv()\n                socket.send(msg)\n\n        客户端端程序\n            import zmq\n            context = zmq.Context()\n            socket = context.socket(zmq.REQ)\n            socket.connect(\"tcp://127.0.0.1:1234\")\n            # socket.connect(\"tcp://127.0.0.1:6000\")    # 设置2个可以均衡负载请求到2个监听的server\n            msg_send = \"xxx\"socket.send(msg_send)\n            print \"Send:\", msg_send\n            msg_recv = socket.recv()\n            print \"Receive:\", msg_recv\n\n    epoll\n        https://docs.python.org/2/library/select.html    # python官网\n\n        epoll短链接server\n            # 原文  http://my.oschina.net/moooofly/blog/147297\n            # 此代码还有改进地方，在接收数据和发送数据都是阻塞死循环处理，必须等待全部接收完毕才会继续操作\n            server端代码：\n\n                #!/usr/bin/python\n                #-*- coding:utf-8 -*-\n\n                import socket, logging\n                import select, errno\n\n                logger = logging.getLogger(\"network-server\")\n\n                def InitLog():\n                    logger.setLevel(logging.DEBUG)\n\n                    fh = logging.FileHandler(\"network-server.log\")\n                    fh.setLevel(logging.DEBUG)\n                    ch = logging.StreamHandler()\n                    ch.setLevel(logging.ERROR)\n\n                    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n                    ch.setFormatter(formatter)\n                    fh.setFormatter(formatter)\n\n                    logger.addHandler(fh)\n                    logger.addHandler(ch)\n\n                if __name__ == \"__main__\":\n                    InitLog()\n\n                    try:\n                        # 创建 TCP socket 作为监听 socket\n                        listen_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n                    except socket.error, msg:\n                        logger.error(\"create socket failed\")\n\n                    try:\n                        # 设置 SO_REUSEADDR 选项\n                        listen_fd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                    except socket.error, msg:\n                        logger.error(\"setsocketopt SO_REUSEADDR failed\")\n\n                    try:\n                        # 进行 bind -- 此处未指定 ip 地址，即 bind 了全部网卡 ip 上\n                        listen_fd.bind(('', 2003))\n                    except socket.error, msg:\n                        logger.error(\"bind failed\")\n\n                    try:\n                        # 设置 listen 的 backlog 数\n                        listen_fd.listen(10)\n                    except socket.error, msg:\n                        logger.error(msg)\n\n                    try:\n                        # 创建 epoll 句柄\n                        epoll_fd = select.epoll()\n                        # 向 epoll 句柄中注册 监听 socket 的 可读 事件\n                        epoll_fd.register(listen_fd.fileno(), select.EPOLLIN)\n                    except select.error, msg:\n                        logger.error(msg)\n\n                    connections = {}\n                    addresses = {}\n                    datalist = {}\n                    while True:\n                        # epoll 进行 fd 扫描的地方 -- 未指定超时时间则为阻塞等待\n                        epoll_list = epoll_fd.poll()\n\n                        for fd, events in epoll_list:\n                            # 若为监听 fd 被激活\n                            if fd == listen_fd.fileno():\n                                # 进行 accept -- 获得连接上来 client 的 ip 和 port，以及 socket 句柄\n                                conn, addr = listen_fd.accept()\n                                logger.debug(\"accept connection from %s, %d, fd = %d\" % (addr[0], addr[1], conn.fileno()))\n                                # 将连接 socket 设置为 非阻塞\n                                conn.setblocking(0)\n                                # 向 epoll 句柄中注册 连接 socket 的 可读 事件\n                                epoll_fd.register(conn.fileno(), select.EPOLLIN | select.EPOLLET)\n                                # 将 conn 和 addr 信息分别保存起来\n                                connections[conn.fileno()] = conn\n                                addresses[conn.fileno()] = addr\n                            elif select.EPOLLIN & events:\n                                # 有 可读 事件激活\n                                datas = ''\n                                while True:\n                                    try:\n                                        # 从激活 fd 上 recv 10 字节数据\n                                        data = connections[fd].recv(10)\n                                        # 若当前没有接收到数据，并且之前的累计数据也没有\n                                        if not data and not datas:\n                                            # 从 epoll 句柄中移除该 连接 fd\n                                            epoll_fd.unregister(fd)\n                                            # server 侧主动关闭该 连接 fd\n                                            connections[fd].close()\n                                            logger.debug(\"%s, %d closed\" % (addresses[fd][0], addresses[fd][1]))\n                                            break\n                                        else:\n                                            # 将接收到的数据拼接保存在 datas 中\n                                            datas += data\n                                    except socket.error, msg:\n                                        # 在 非阻塞 socket 上进行 recv 需要处理 读穿 的情况\n                                        # 这里实际上是利用 读穿 出 异常 的方式跳到这里进行后续处理\n                                        if msg.errno == errno.EAGAIN:\n                                            logger.debug(\"%s receive %s\" % (fd, datas))\n                                            # 将已接收数据保存起来\n                                            datalist[fd] = datas\n                                            # 更新 epoll 句柄中连接d 注册事件为 可写\n                                            epoll_fd.modify(fd, select.EPOLLET | select.EPOLLOUT)\n                                            break\n                                        else:\n                                            # 出错处理\n                                            epoll_fd.unregister(fd)\n                                            connections[fd].close()\n                                            logger.error(msg)\n                                            break\n                            elif select.EPOLLHUP & events:\n                                # 有 HUP 事件激活\n                                epoll_fd.unregister(fd)\n                                connections[fd].close()\n                                logger.debug(\"%s, %d closed\" % (addresses[fd][0], addresses[fd][1]))\n                            elif select.EPOLLOUT & events:\n                                # 有 可写 事件激活\n                                sendLen = 0\n                                # 通过 while 循环确保将 buf 中的数据全部发送出去\n                                while True:\n                                    # 将之前收到的数据发回 client -- 通过 sendLen 来控制发送位置\n                                    sendLen += connections[fd].send(datalist[fd][sendLen:])\n                                    # 在全部发送完毕后退出 while 循环\n                                    if sendLen == len(datalist[fd]):\n                                        break\n                                # 更新 epoll 句柄中连接 fd 注册事件为 可读\n                                epoll_fd.modify(fd, select.EPOLLIN | select.EPOLLET)\n                            else:\n                                # 其他 epoll 事件不进行处理\n                                continue\n\n            client 端代码\n\n                import socket\n                import time\n                import logging\n\n                logger = logging.getLogger(\"network-client\")\n                logger.setLevel(logging.DEBUG)\n\n                fh = logging.FileHandler(\"network-client.log\")\n                fh.setLevel(logging.DEBUG)\n                ch = logging.StreamHandler()\n                ch.setLevel(logging.ERROR)\n\n                formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n                ch.setFormatter(formatter)\n                fh.setFormatter(formatter)\n\n                logger.addHandler(fh)\n                logger.addHandler(ch)\n\n                if __name__ == \"__main__\":\n                    try:\n                        connFd = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n                    except socket.error, msg:\n                        logger.error(msg)\n\n                    try:\n                        connFd.connect((\"127.0.0.1\", 2003))\n                        logger.debug(\"connect to network server success\")\n                    except socket.error,msg:\n                        logger.error(msg)\n\n                    for i in range(1, 11):\n                        data = \"The Number is %d\" % i\n                        if connFd.send(data) != len(data):\n                            logger.error(\"send data to network server failed\")\n                            break\n                        readData = connFd.recv(1024)\n                        print readData\n                        time.sleep(1)\n\n                    connFd.close()\n\n4 mysql\n\n    # yum install mysql-devel python-tools gcc openssl-devel\n    pip install MySQL-python\n    # yum install python-MySQLdb MySQL-python\n\n    help(MySQLdb.connections.Connection)      # 查看链接参数\n\n    conn=MySQLdb.connect(host='localhost',user='root',passwd='123456',db='fortress',port=3306)    # 定义连接\n    #conn=MySQLdb.connect(unix_socket='/var/run/mysqld/mysqld.sock',user='root',passwd='123456')   # 使用socket文件链接\n    conn.autocommit(True)                                        # 自动提交\n    cur=conn.cursor()                                            # 定义游标\n    conn.select_db('fortress')                                   # 选择数据库\n    sqlcmd = 'insert into user(name,age) value(%s,%s)'           # 定义sql命令\n    cur.executemany(sqlcmd,[('aa',1),('bb',2),('cc',3)])         # 插入多条值\n    cur.execute('delete from user where id=20')                  # 删除一条记录\n    cur.execute(\"update user set name='a' where id=20\")          # 更细数据\n    sqlresult = cur.fetchall()                                   # 接收全部返回结果\n    conn.commit()                                                # 提交\n    cur.close()                                                  # 关闭游标\n    conn.close()                                                 # 关闭连接\n\n    import MySQLdb\n    def mydb(dbcmdlist):\n        try:\n            conn=MySQLdb.connect(host='localhost',user='root',passwd='123456',db='fortress',port=3306)\n            conn.autocommit(True)\n            cur=conn.cursor()\n\n            cur.execute('create database if not exists fortress;')  # 创建数据库\n            conn.select_db('fortress')                              # 选择数据库\n            cur.execute('drop table if exists log;')                # 删除表\n            cur.execute('CREATE TABLE log ( id BIGINT(20) NOT NULL AUTO_INCREMENT, loginuser VARCHAR(50) DEFAULT NULL, remoteip VARCHAR(50) DEFAULT NULL, PRIMARY KEY (id) );')  # 创建表\n\n            result=[]\n            for dbcmd in dbcmdlist:\n                cur.execute(dbcmd)           # 执行sql\n                sqlresult = cur.fetchall()   # 接收全部返回结果\n                result.append(sqlresult)\n            conn.commit()                    # 提交\n            cur.close()\n            conn.close()\n            return result\n        except MySQLdb.Error,e:\n            print 'mysql error msg: ',e\n    sqlcmd=[]\n    sqlcmd.append(\"insert into log (loginuser,remoteip)values('%s','%s');\" %(loginuser,remoteip))\n    mydb(sqlcmd)\n\n    sqlcmd=[]\n    sqlcmd.append(\"select * from log;\")\n    result = mydb(sqlcmd)\n    for i in result[0]:\n        print i\n\n\n\n    mysql链接失败重试\n\n        import MySQLdb as mysql\n        import time\n\n        class my():\n            def executeSQL(self, sql=\"select * from `serverinfo` limit 1;\"):\n                while True:\n                    try:\n                        self.conn.ping()\n                        break\n                    except Exception,e:\n                        print('warning: mysql test ping fail')\n                        print(str(e))\n                    try:\n                        self.conn = mysql.connect(user=\"opsdeploy\", passwd=\"123456\", host='172.222.50.50', port=3306, db=\"ops_deploy\", connect_timeout=10, compress=True, charset=\"utf8\")\n                        self.cursor = self.conn.cursor()\n                        break\n                    except Exception,e:\n                        print(\"mysql reconnect fail ...\")\n                        print(str(e))\n                        time.sleep(2)\n                try:\n                    self.cursor.execute(sql)\n                    self.conn.commit()\n                    print self.cursor.fetchall()\n                except Exception,e:\n                    print(str(e))\n        m=my()\n        m.executeSQL()\n\n\n5 处理信号\n\n    信号的概念\n\n        信号(signal): 进程之间通讯的方式，是一种软件中断。一个进程一旦接收到信号就会打断原来的程序执行流程来处理信号。\n        发送信号一般有两种原因:\n            1(被动式)  内核检测到一个系统事件.例如子进程退出会像父进程发送SIGCHLD信号.键盘按下control+c会发送SIGINT信号\n            2(主动式)  通过系统调用kill来向指定进程发送信号\n        操作系统规定了进程收到信号以后的默认行为，可以通过绑定信号处理函数来修改进程收到信号以后的行为，有两个信号是不可更改的 SIGTOP 和 SIGKILL\n        如果一个进程收到一个SIGUSR1信号，然后执行信号绑定函数，第二个SIGUSR2信号又来了，第一个信号没有被处理完毕的话，第二个信号就会丢弃。\n        进程结束信号 SIGTERM 和 SIGKILL 的区别:  SIGTERM 比较友好，进程能捕捉这个信号，根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。在某些情况下，假如进程正在进行作业而且不能中断，那么进程可以忽略这个SIGTERM信号。\n\n    常见信号\n        kill -l      # 查看linux提供的信号\n\n        SIGHUP  1          A     # 终端挂起或者控制进程终止\n        SIGINT  2          A     # 键盘终端进程(如control+c)\n        SIGQUIT 3          C     # 键盘的退出键被按下\n        SIGILL  4          C     # 非法指令\n        SIGABRT 6          C     # 由abort(3)发出的退出指令\n        SIGFPE  8          C     # 浮点异常\n        SIGKILL 9          AEF   # Kill信号  立刻停止\n        SIGSEGV 11         C     # 无效的内存引用\n        SIGPIPE 13         A     # 管道破裂: 写一个没有读端口的管道\n        SIGALRM 14         A     # 闹钟信号 由alarm(2)发出的信号\n        SIGTERM 15         A     # 终止信号,可让程序安全退出 kill -15\n        SIGUSR1 30,10,16   A     # 用户自定义信号1\n        SIGUSR2 31,12,17   A     # 用户自定义信号2\n        SIGCHLD 20,17,18   B     # 子进程结束自动向父进程发送SIGCHLD信号\n        SIGCONT 19,18,25         # 进程继续（曾被停止的进程）\n        SIGSTOP 17,19,23   DEF   # 终止进程\n        SIGTSTP 18,20,24   D     # 控制终端（tty）上按下停止键\n        SIGTTIN 21,21,26   D     # 后台进程企图从控制终端读\n        SIGTTOU 22,22,27   D     # 后台进程企图从控制终端写\n\n        缺省处理动作一项中的字母含义如下:\n            A  缺省的动作是终止进程\n            B  缺省的动作是忽略此信号，将该信号丢弃，不做处理\n            C  缺省的动作是终止进程并进行内核映像转储(dump core),内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。\n            D  缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）\n            E  信号不能被捕获\n            F  信号不能被忽略\n\n    Python提供的信号\n        import signal\n        dir(signal)\n        ['NSIG', 'SIGABRT', 'SIGALRM', 'SIGBUS', 'SIGCHLD', 'SIGCLD', 'SIGCONT', 'SIGFPE', 'SIGHUP', 'SIGILL', 'SIGINT', 'SIGIO', 'SIGIOT', 'SIGKILL', 'SIGPIPE', 'SIGPOLL', 'SIGPROF', 'SIGPWR', 'SIGQUIT', 'SIGRTMAX', 'SIGRTMIN', 'SIGSEGV', 'SIGSTOP', 'SIGSYS', 'SIGTERM', 'SIGTRAP', 'SIGTSTP', 'SIGTTIN', 'SIGTTOU', 'SIGURG', 'SIGUSR1', 'SIGUSR2', 'SIGVTALRM', 'SIGWINCH', 'SIGXCPU', 'SIGXFSZ', 'SIG_DFL', 'SIG_IGN', '__doc__', '__name__', 'alarm', 'default_int_handler', 'getsignal', 'pause', 'signal']\n\n    绑定信号处理函数\n        #encoding:utf8\n        import os,signal\n        from time import sleep\n        def onsignal_term(a,b):\n            print 'SIGTERM'      # kill -15\n        signal.signal(signal.SIGTERM,onsignal_term)     # 接收信号,执行相应函数\n\n        def onsignal_usr1(a,b):\n            print 'SIGUSR1'      # kill -10\n        signal.signal(signal.SIGUSR1,onsignal_usr1)\n\n        while 1:\n            print 'ID',os.getpid()\n            sleep(10)\n\n    通过另外一个进程发送信号\n        import os,signal\n        os.kill(16175,signal.SIGTERM)    # 发送信号，16175是绑定信号处理函数的进程pid，需要自行修改\n        os.kill(16175,signal.SIGUSR1)\n\n    父进程接收子进程结束发送的SIGCHLD信号\n        #encoding:utf8\n        import os,signal\n        from time import sleep\n\n        def onsigchld(a,b):\n            print '收到子进程结束信号'\n        signal.signal(signal.SIGCHLD,onsigchld)\n\n        pid = os.fork()                # 创建一个子进程,复制父进程所有资源操作\n        if pid == 0:                   # 通过判断子进程os.fork()是否等于0,分别同时执行父进程与子进程操作\n           print '我是子进程,pid是',os.getpid()\n           sleep(2)\n        else:\n            print '我是父进程,pid是',os.getpid()\n            os.wait()      # 等待子进程结束\n\n    接收信号的程序，另外一端使用多线程向这个进程发送信号，会遗漏一些信号\n        #encoding:utf8\n        import os\n        import signal\n        from time import sleep\n        import Queue\n        QCOUNT = Queue.Queue()  # 初始化队列\n        def onsigchld(a,b):\n            '''收到信号后向队列中插入一个数字1'''\n            print '收到SIGUSR1信号'\n            sleep(1)\n            QCOUNT.put(1)       # 向队列中写入\n        signal.signal(signal.SIGUSR1,onsigchld)   # 绑定信号处理函数\n        while 1:\n            print '我的pid是',os.getpid()\n            print '现在队列中元素的个数是',QCOUNT.qsize()\n            sleep(2)\n\n    多线程发信号端的程序\n        #encoding:utf8\n        import threading\n        import os\n        import signal\n        def sendusr1():\n            print '发送信号'\n            os.kill(17788, signal.SIGUSR1)     # 这里的进程id需要写前一个程序实际运行的pid\n        WORKER = []\n        for i in range(1, 7):                  # 开启6个线程\n            threadinstance = threading.Thread(target = sendusr1)\n            WORKER.append(threadinstance)\n        for i in WORKER:\n            i.start()\n        for i in WORKER:\n            i.join()\n        print '主线程完成'\n\n6 缓存数据库\n\n    python使用memcache\n\n        easy_install python-memcached   # 安装(python2.7+)\n        import memcache\n        mc = memcache.Client(['10.152.14.85:12000'],debug=True)    # 也可以使用socket直接连接IP端口\n        mc.set('name','luo',60)\n        mc.get('name')\n        mc.delete('name1')\n\n        # 豆瓣的python-memcache模块，大于1M自动切割 性能是纯python的3倍+\n        https://code.google.com/p/python-libmemcached/\n\n        保存数据\n\n            set(key,value,timeout)      # 把key映射到value，timeout指的是什么时候这个映射失效\n            add(key,value,timeout)      # 仅当存储空间中不存在键相同的数据时才保存\n            replace(key,value,timeout)  # 仅当存储空间中存在键相同的数据时才保存\n\n        获取数据\n\n            get(key)                    # 返回key所指向的value\n            get_multi(key1,key2,key3)   # 可以非同步地同时取得多个键值， 比循环调用get快数十倍\n\n    python使用mongodb\n\n        # 新版本\n        http://api.mongodb.org/python/2.7.2/tutorial.html\n        http://api.mongodb.org/python/current/examples/custom_type.html\n\n        easy_install pymongo      # 安装\n\n        import pymongo\n\n        cl = pymongo.MongoClient(\"127.0.0.1\", 27017)\n        db = cl.ops             # 选择库\n        db.name                 # 查看库名\n        db.collection_names()   # 查看所有文档\n        db.project              # 选择文档\n        db.project.insert({'name':'live','group':'a'})\n        db.project.insert({'name':'news','group':'b'})\n        db.project.find_one({'group':'a'})\n        for post in db.project.find():\n           print post['name']\n        db.project.remove()\n\n        # 执行mongo命令\n        # https://api.mongodb.com/python/current/api/pymongo/database.html\n        db.command(\"filemd5\", object_id, root=file_root)\n        db.command(\"dropUser\", \"user\")\n        db.command(\"createUser\", \"admin\", pwd=\"password\", roles=[\"root\"])\n        for x,y in db.command(\"currentOp\").items():\n            print x,y\n\n        # currentOp在mongo3.9废弃,建议使用 aggregate()\n        with client.admin.aggregate([{\"$currentOp\": {}}]) as cursor:\n            for operation in cursor:\n                print(operation)\n\n    python使用redis\n\n        https://pypi.python.org/pypi/redis                  # redis的python官网\n        pip install redis  OR easy_install redis            # 安装\n        http://redis.readthedocs.org/en/latest/index.html   # redis命令详解\n        http://redis.readthedocs.org/en/2.4/index.html\n\n        import redis\n        rds = redis.Redis(host=host, port=port, password=passwd, socket_timeout=10,db=0)\n        rds.info()                           # redis信息\n        rds.set(key, value)                  # 将值value关联到key\n        rds.get(key)                         # 取key值\n        rds.delete(key1,key2)                # 删除key\n        rds.rename(key,new_key2)             # 将key改名 存在覆盖\n        rds.seten(key,value)                 # 将值value关联到key,如果key存在不做任何动作\n        rds.setex(key, value, 10800)         # 将值value关联到key,并设置key的过期时间\n        rds.mset()                           # 同时设置一个或多个key-value对  如果key存在则覆盖\n        rds.msetnx()                         # 同时设置一个或多个key-value对  如果有key存在则失败\n        rds.mget(key1, key2, key3)           # 取多个key值   不存在返回nil\n        rds.expire(key seconds)              # 设置key的过期时间\n        rds.persist(key)                     # 移除key的过期时间\n        rds.ttl(key)                         # 查看超时时间 -1为不过期\n        rds.sadd(key,value1)                 # 将value1加入集合中  集合不重复\n        rds.smembers(key)                    # 返回key中所有成员\n        rds.scard(key)                       # 集合中元素的数量\n        rds.srandmember(key)                 # 对集合随机返回一个元素 而不对集合改动  当key不存在或key是空集时，返回nil\n        rds.sinter(key1,key2)                # 两个集合的交集\n        rds.sdiff(key1,key2)                 # 两个集合的差集\n        rds.sismember(key,value)             # 判断value元素是否是集合key的成员 1存在 0不存在\n        rds.lpush(key,value1)                # 将value1加入列表中  从左到右\n        rds.lpop(key,value1)                 # 移除并返回列表key的头元素\n        rds.llen(key)                        # 返回列表长度\n        rds.sort(key)                        # 对列表、集合、有序集合排序[大列表排序非常影响性能，甚至把redis拖死]\n        rds.append(key,value)                # 字符串拼接为新的value\n        rds.ltrim(key, 0, -10)               # 保留指定区间内的元素，不在都被删除 0第一个 -1最后一个\n        rds.incr(key , amount=1)             # 计数加1 默认1或请先设置key的数值\n        rds.decr(key)                        # 计数减1 请先设置key的数值\n        rds.save()                           # 保存数据\n\n    python使用kestrel队列\n\n        # pykestrel\n        import kestrel\n\n        q = kestrel.Client(servers=['127.0.0.1:22133'],queue='test_queue')\n        q.add('some test job')\n        job = q.get()    # 从队列读取工作\n        job = q.peek()   # 读取下一份工作\n        # 读取一组工作\n        while True:\n            job = q.next(timeout=10) # 完成工作并获取下一个工作，如果没有工作，则等待10秒\n            if job is not None:\n                try:\n                    # 流程工作\n                except:\n                    q.abort() # 标记失败工作\n\n        q.finish()  # 完成最后工作\n        q.close()   # 关闭连接\n\n        kestrel状态检查\n            # kestrel支持memcache协议客户端\n            #!/usr/local/bin/python\n            # 10.13.81.125 22133  10000\n\n            import memcache\n            import sys\n            import traceback\n\n            ip=\"%s:%s\" % (sys.argv[1],sys.argv[2])\n            try:\n                mc = memcache.Client([ip,])\n                st=mc.get_stats()\n            except:\n                print \"kestrel connection exception\"\n                sys.exit(2)\n\n            if st:\n                for s in st[0][1].keys():\n                    if s.startswith('queue_') and s.endswith('_mem_items'):\n                        num = int(st[0][1][s])\n                        if num > int(sys.argv[3]):\n                            print \"%s block to %s\" %(s[6:-6],num)\n                            sys.exit(2)\n                print \"kestrel ok!\"\n                sys.exit(0)\n            else:\n                print \"kestrel down\"\n                sys.exit(2)\n\n    python使用tarantool\n\n        # pip install tarantool-queue\n\n        from tarantool_queue import Queue\n        queue = Queue(\"localhost\", 33013, 0)     # 连接读写端口 空间0\n        tube = queue.tube(\"name_of_tube\")        #\n        tube.put([1, 2, 3])\n\n        task = tube.take()\n        task.data     # take task and read data from it\n        task.ack()    # move this task into state DONE\n\n    python-etcd\n\n        http://python-etcd.readthedocs.io/en/latest/\n\n        pip install python-etcd\n        import etcd\n        client = etcd.Client(host='etcd-01', port=2379)\n        client = etcd.Client( (('etcd-01', 2379), ('etcd-02', 2379), ('etcd-03', 2379)) ,allow_reconnect=True)   # 集群多IP  allow_reconnect 允许重连\n\n        # 增加 目录必须存在 # 目录: /v1/xuesong/\n        client.write('/v1/xuesong/10.10.10.10:8080', 'test')\n        # 获取指定路径的值\n        r = client.read('/v1/xuesong/10.10.10.10:8080' , recursive=True, sorted=True)\n        r.value\n        # 删除指定路径\n        client.delete('/v1/xuesong/10.10.10.10:8080')\n\n        # with ttl\n        client.write('/nodes/n2', 2, ttl=4)  # sets the ttl to 4 seconds\n        # create only\n        client.write('/nodes/n3', 'test', prevExist=False)\n        # Compare and swap values atomically\n        client.write('/nodes/n3', 'test2', prevValue='test1')    #this fails to write\n        client.write('/nodes/n3', 'test2', prevIndex=10)         #this fails to write\n        # mkdir\n        client.write('/nodes/queue', None, dir=True)\n        # Append a value to a queue dir\n        client.write('/nodes/queue', 'test', append=True)        #will write i.e. /nodes/queue/11\n        client.write('/nodes/queue', 'test2', append=True)       #will write i.e. /nodes/queue/12\n\n        client.read('/nodes/n2').value                           # 获取单个键值\n        r = client.read('/nodes', recursive=True, sorted=True)   # 递归查询目录\n        for i in r.children:\n            if not i.dir:\n                print(\"%s: %s\" % (child.key,child.value))\n\n        client.read('/nodes/n2', wait=True) #Waits for a change in value in the key before returning.\n        client.read('/nodes/n2', wait=True, waitIndex=10)\n\n        try:\n            client.read('/invalid/path')\n        except etcd.EtcdKeyNotFound:\n            print \"error\"\n\n        client.delete('/nodes/n1')\n        client.delete('/nodes', dir=True)             #spits an error if dir is not empty\n        client.delete('/nodes', recursive=True)       #this works recursively\n\n        client.watch('/nodes/n1', recursive=True,timeout=0)        # 递归获取改变值 阻塞直到有改变\n\n        # watch只会阻塞监视之后的一次改动，所以必须先递归read下所有路径，然后根据每次的watch进行更改\n        # 第一次read的时候，需要记录 etcd_index+1作为下一次watch的索引\n        index = client.read('/nodes/n1', recursive=True).etcd_index\n        while 1:\n            # watch后的索引是 modifiedIndex+1传给下一次的watch\n            index = client.watch('/nodes/n1', recursive=True, timeout=0, index=index+1).modifiedIndex\n\n\n    python操作zookeeper\n        https://kazoo.readthedocs.io/en/latest/basic_usage.html\n\n        pip install kazoo\n        from kazoo.client import KazooClient\n\n        zk = KazooClient(hosts='127.0.0.1:2181', read_only=True)\n        zk.start()\n        zk.get_children('/')\n        zk.stop()\n\n\n    python操作elasticsearch\n\n        http://elasticsearch-py.readthedocs.io/en/master/\n\n        from datetime import datetime\n        from elasticsearch import Elasticsearch\n\n        es = Elasticsearch([\"host1\", \"host2\"])\n\n        doc = {\n            'author': 'kimchy',\n            'text': 'Elasticsearch: cool. bonsai cool.',\n            'timestamp': datetime.now(),\n        }\n\n        res = es.index(index=\"live-\", doc_type='tweet', id=1, body=doc)\n        print(res['created'])\n\n        res = es.get(index=\"live-\", doc_type='tweet', id=1)\n        print(res['_source'])\n\n        es.indices.refresh(index=\"live-\")\n\n        res = es.search(index=\"live-\", body={\"query\": {\"match_all\": {}}})\n\n\n7 http客户端\n\n    urllib2        [网络资源访问]\n\n        import urllib2\n        response = urllib2.urlopen('http://baidu.com')\n        print response.geturl()       # url\n        headers = response.info()\n        print headers                 # web页面头部信息\n        print headers['date']         # 头部信息中的时间\n        date = response.read()        # 返回页面所有信息[字符串]\n        # date = response.readlines() # 返回页面所有信息[列表]\n\n        for i in urllib2.urlopen('http://qq.com'):    # 可直接迭代\n            print i,\n\n        下载文件\n\n            #!/usr/bin/env python\n            #encoding:utf8\n            import urllib2\n\n            url = 'http://www.01happy.com/wp-content/uploads/2012/09/bg.png'\n            file(\"./pic/%04d.png\" % i, \"wb\").write(urllib2.urlopen(url).read())\n\n        抓取网页解析指定内容\n\n            #!/usr/bin/env python\n            #encoding:utf8\n\n            import urllib2\n            import urllib\n            import random\n            from bs4 import BeautifulSoup\n\n            url='http://www.aaammm.com/aaa/'\n\n            ua=[\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\",\n            \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\",\n            \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E)\",\n            \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36\",\n            \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36\",\n            \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36\",\n            \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36\",\n            \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36\",\n            \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36\",\n            \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36\",\n            \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36\",\n            \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20100101 Firefox/31.0\",\n            \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36\"]\n\n            browser = random.choice(ua)\n\n            req_header = {'User-Agent':browser,\n            'Accept':'text/html;q=0.9,*/*;q=0.8',\n            'Cookie':'BAIDUID=4C8274B52CFB79DEB4FBA9A7EC76A1BC:FG=1; BDUSS=1dCdU1WNFdxUll0R09XcnBZTkRrVVVNbWVnSkRKSVRPeVljOUswclBoLUNzVEpVQVFBQUFBJCQAAAAAAAAAAAEAAADEuZ8BcXVhbnpob3U3MjIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIIIkC1SCJAtUY; BD_UPN=123143; BD_HOME=1',    # 添真实登陆后的Cookie 谷歌浏览器[F12  Network  Documents  Headers]\n            'Accept-Charset':'ISO-8859-1,utf-8;q=0.7,*;q=0.3',\n            'Connection':'close',\n            }\n            #data = urllib.urlencode({'name':'xuesong','id':'30' })          # urllib 的处理参数的方法，可以再urllib2中使用\n            data = urllib2.quote(\"pgv_ref=im.perinfo.perinfo.icon&rrr=pppp\")\n            req_timeout = 10\n            try:\n                req = urllib2.Request(url,data=data,headers=req_header)      # data为None 则方法为get，有date为post方法\n                html = urllib2.urlopen(req,data=None,req_timeout).read()\n            except urllib2.HTTPError as err:\n                print str(err)\n            except:\n                print \"timeout\"\n            print(html)\n\n            # 百度带Cookie后查看自己的用户\n            #for i in html.split('\\n'):\n            #    if 'bds.comm.user=' in i:\n            #        print i\n\n            soup = BeautifulSoup(html)\n            for i in  soup.find_all(target=\"_blank\",attrs={\"class\": \"usr-pic\"}):   # 条件看情况选择\n                if i.img:\n                    print(i.get('href'))\n\n        模拟浏览器访问web页面 python3\n            #! /usr/bin/env python\n            # -*- coding=utf-8 -*-\n            import urllib.request\n\n            url = \"http://www.baidu.com\"\n            # AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\n            headers = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1)',\n            'Accept':'text/html;q=0.9,*/*;q=0.8',\n            'Accept-Charset':'ISO-8859-1,utf-8;q=0.7,*;q=0.3',\n            'Connection':'close',\n            'Referer':None #注意如果依然不能抓取的话，这里可以设置抓取网站的host\n            }\n\n            opener = urllib.request.build_opener()\n            opener.addheaders = [headers]\n            data = opener.open(url).read()\n\n            print(data)\n\n    requests       [替代urllib2]\n\n        # Requests是一个Python的HTTP客户端库\n        # 官方中文文档 http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#id2\n        # 安装: sudo pip install requests\n        import requests\n\n        # 使用 logging 库时忽略 requests 库的日志\n        logging.getLogger(\"requests\").setLevel(logging.WARNING)\n        logging.getLogger(\"urllib3\").setLevel(logging.WARNING)\n\n        # get方法提交表单\n        url = r'http://dict.youdao.com/search?le=eng&q={0}'.format(word.strip())\n        r = requests.get(url,timeout=2)\n\n        # get方法带参数 http://httpbin.org/get?key=val\n        payload = {'key1': 'value1', 'key2': 'value2'}\n        r = requests.get(\"http://httpbin.org/get\", params=payload)\n\n        # post方法提交表单\n        QueryAdd='http://www.anti-spam.org.cn/Rbl/Query/Result'\n        r = requests.post(url=QueryAdd, data={'IP':'211.211.54.54'})\n\n        # 定制请求头post请求\n        payload = {'some': 'data'}\n        headers = {'content-type': 'application/json'}\n        r = requests.post(url, data=json.dumps(payload), headers=headers)\n\n        # https 需登录加auth\n        r = requests.get('https://baidu.com', auth=('user', 'pass'))\n\n        if r.ok:    # 判断请求是否正常\n            print r.url             # u'http://httpbin.org/get?key2=value2&key1=value1'\n            print r.status_code     # 状态码\n            print r.content         # 获取到的原始内容  可使用 BeautifulSoup4 解析处理判定结果\n            print r.text            # 把原始内容转unicode编码\n            print r.headers         # 响应头\n            print r.headers['content-type']          # 网页头信息 不存在为None\n            print r.cookies['example_cookie_name']   # 查看cookie\n            print r.history         # 追踪重定向 [<Response [301]>]  开启重定向 allow_redirects=True\n\n        获取JSON\n            r = requests.get('https://github.com/timeline.json')\n            r.json()\n\n        获取图片\n            from PIL import Image\n            from StringIO import StringIO\n            i = Image.open(StringIO(r.content))\n\n        发送cookies到服务器\n            url = 'http://httpbin.org/cookies'\n            cookies = dict(cookies_are='working')\n            r = requests.get(url, cookies=cookies)\n            r.text         '{\"cookies\": {\"cookies_are\": \"working\"}}'\n\n        在同一个Session实例发出的所有请求之间保持cookies\n            s = requests.Session()\n            s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')\n            r = s.get(\"http://httpbin.org/cookies\")\n            print r.text\n\n        会话对象能够跨请求保持某些参数\n            s = requests.Session()\n            s.auth = ('user', 'pass')\n            s.headers.update({'x-test': 'true'})\n            s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})  # both 'x-test' and 'x-test2' are sent\n\n        ssl证书验证\n            requests.get('https://github.com', verify=True)\n            requests.get('https://kennethreitz.com', verify=False)   # 忽略证书验证\n            requests.get('https://kennethreitz.com', cert=('/path/server.crt', '/path/key'))   # 本地指定一个证书 正确 <Response [200]>  错误 SSLError\n\n        流式上传\n            with open('massive-body') as f:\n                requests.post('http://some.url/streamed', data=f)\n\n        流式请求\n            import requests\n            import json\n\n            r = requests.post('https://stream.twitter.com/1/statuses/filter.json',\n                data={'track': 'requests'}, auth=('username', 'password'), stream=True)\n\n            for line in r.iter_lines():\n                if line: # filter out keep-alive new lines\n                    print json.loads(line)\n\n        自定义身份验证\n            from requests.auth import AuthBase\n            class PizzaAuth(AuthBase):\n                \"\"\"Attaches HTTP Pizza Authentication to the given Request object.\"\"\"\n                def __init__(self, username):\n                    # setup any auth-related data here\n                    self.username = username\n                def __call__(self, r):\n                    # modify and return the request\n                    r.headers['X-Pizza'] = self.username\n                    return r\n            requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))\n\n        基本身份认证\n            from requests.auth import HTTPBasicAuth\n            requests.get('https://api.github.com/user', auth=HTTPBasicAuth('user', 'pass'))\n\n        摘要式身份认证\n            from requests.auth import HTTPDigestAuth\n            url = 'http://httpbin.org/digest-auth/auth/user/pass'\n            requests.get(url, auth=HTTPDigestAuth('user', 'pass'))\n\n        代理\n            import requests\n            proxies = {\n              \"http\": \"http://10.10.1.10:3128\",\n              # \"http\": \"http://user:pass@10.10.1.10:3128/\",  # 用户名密码\n              \"https\": \"http://10.10.1.10:1080\",\n            }\n            requests.get(\"http://example.org\", proxies=proxies)\n            #也可以设置环境变量之间访问\n            export HTTP_PROXY=\"http://10.10.1.10:3128\"\n            export HTTPS_PROXY=\"http://10.10.1.10:1080\"\n\n\n        requests.session\n            import requests\n            import time\n            from bs4 import BeautifulSoup\n\n            session = requests.session()\n\n            login_url = \"http://deploy.ixiaochuan.cn/login\"\n            res_start = session.get(url=login_url)\n            bs = BeautifulSoup(res_start.text, \"html.parser\")\n            a = bs.select(\"#csrf_token\")[0]\n            token = a.attrs.get(\"value\")\n\n            login_data = {\"username\": (None, \"weiqiang\"), \"password\": (None, \"Onei\"), \"submit\": (None, \"Login\"),\n                          \"csrf_token\": (None, token)}\n            res = session.post(url=login_url, files=login_data, allow_redirects=False)\n            print(\"login success\")\n\n\n    BeautifulSoup  [html\\xml解析器]\n\n        # BeautifulSoup中文官方文档\n        # http://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html\n        # http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\n        # Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment\n\n        导入模块\n            from BeautifulSoup import BeautifulSoup          # For processing HTML  版本3.0 已停止更新\n            from BeautifulSoup import BeautifulStoneSoup     # For processing XML\n            import BeautifulSoup                             # To get everything\n            from bs4 import BeautifulSoup                    # 版本4.0 bs4 安装: pip install BeautifulSoup4\n\n        from bs4 import BeautifulSoup\n        soup = BeautifulSoup(html_doc)         # 解析html文本 可以是 requests 提交返回的页面 results.content\n        print(soup.prettify())                 # 输出解析后的结构\n        print(soup.title)                      # 指定标签内容\n        print(soup.title.name)                 # 标签名\n        print(soup.title.string)               # 标签内容\n        print(soup.title.parent.name)          # 上层标签名\n        print(soup.p)                          # <p class=\"title\"><b>The Dormouse's story</b></p>\n        print(soup.p['class'])                 # u'title'  class属性值\n        print(soup.a)                          # 找到第一个a标签的标签行\n        print(soup.find_all('a',limit=2))      # 找到a标签的行,最多为limit个\n        print(soup.find(id=\"link3\"))           # 标签内id为link3的标签行\n        print(soup.get_text())                 # 从文档中获取所有文字内容\n        soup.find_all(\"a\", text=\"Elsie\")       # 从文档中搜索关键字\n        soup.find(text=re.compile(\"sisters\"))  # 从文档中正则搜索关键字\n        soup.find_all(\"a\", class_=\"sister\")    # 按CSS搜索\n        soup.find_all(id='link2',\"table\",attrs={\"class\": \"status\"},href=re.compile(\"elsie\"))   # 搜索方法\n        for i in  soup.find_all('a',attrs={\"class\": \"usr-pic\"}):    # 循环所有a标签的标签行\n                if i.a.img:\n                        print(i.a.img.get(\"src\"))                   # 取出当前a标签中的连接\n        Tag\n            # find_all 后循环的值是 Tag 不是字符串 不能直接截取\n            tag.text                     # 文本\n            tag.name\n            tag.name = \"blockquote\"      # 查找name为 blockquote 的\n            tag['class']\n            tag.attrs                    # 按熟悉查找\n            tag['class'] = 'verybold'\n\n            del tag['class']             # 删除\n            print(tag.get('class'))      # 打印属性值\n            print(i.get('href'))         # 打印连接\n\n    cookielib      [保留cookie登录页面]\n\n        ck = cookielib.CookieJar()   # 通过 这个就可以实现请求带过去的COOKIE与发送回来的COOKIE值了。\n        opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(ck))   # 获取到COOKIE\n        urllib2.install_opener(opener)   # 此句设置urllib2的全局opener\n        content = urllib2.urlopen(url).read()\n\n        登录cacti取图片\n            #encoding:utf8\n            import urllib2\n            import urllib\n            import cookielib\n            def renrenBrower(url,user,password):\n                #查找form标签中的action提交地址\n                login_page = \"http://10.10.10.19/cacti/index.php\"\n                try:\n                    #获得一个cookieJar实例\n                    cj = cookielib.CookieJar()\n                    #cookieJar作为参数，获得一个opener的实例\n                    opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))\n                    #伪装成一个正常的浏览器，避免有些web服务器拒绝访问\n                    opener.addheaders = [('User-agent','Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)')]\n                    #生成Post数据,含有登陆用户名密码,所有表单内的input中name值\n                    data = urllib.urlencode({\"action\":\"login\",\"login_username\":user,\"login_password\":password})\n                    #以post的方法访问登陆页面，访问之后cookieJar会自定保存cookie\n                    opener.open(login_page,data)\n                    #以带cookie的方式访问页面\n                    op=opener.open(url)\n                    #读取页面源码\n                    data=op.read()\n                    #将图片写到本地\n                    #file(\"1d.png\" , \"wb\").write(data)\n                    return data\n                except Exception,e:\n                    print str(e)\n            print renrenBrower(\"http://10.10.10.19/cacti/graph_image.php?local_graph_id=1630&rra_id=0&view_type=tree&graph_start=1397525517&graph_end=1397611917\",\"admin\",\"admin\")\n\n        例子2\n            import urllib, urllib2, cookielib\n            import os, time\n\n            headers = []\n\n            def login():\n                cj = cookielib.CookieJar()\n                opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))\n                login_url = r'http://zhixing.bjtu.edu.cn/member.php?mod=logging&action=login&loginsubmit=yes&infloat=yes&lssubmit=yes&inajax=1'\n                login_data = urllib.urlencode({'cookietime': '2592000', 'handlekey': 'ls', 'password': 'xxx',\n                        'quickforward': 'yes', 'username': 'GuoYuan'})\n                opener.addheaders = [('Host', 'zhixing.bjtu.edu.cn'),\n                                   ('User-Agent', 'Mozilla/5.0 (Ubuntu; X11; Linux i686; rv:8.0) Gecko/20100101 Firefox/8.0'),\n                                   ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'),\n                                   ('Accept-Language', 'en-us,en;q=0.5'),\n                                   ('Accept-Encoding', 'gzip, deflate'),\n                                   ('Accept-Charset', 'ISO-8859-1,utf-8;q=0.7,*;q=0.7'),\n                                   ('Connection', 'keep-alive'),\n                                   ('Referer', 'http://zhixing.bjtu.edu.cn/forum.php'),]\n                opener.open(login_url, login_data)\n                return opener\n\n            if __name__ == '__main__':\n                opener = login()\n\n                url = r'http://zhixing.bjtu.edu.cn/forum.php?mod=topicadmin&action=moderate&optgroup=2&modsubmit=yes&infloat=yes&inajax=1'\n                data = {'fid': '601', 'formhash': '0cdd1596', 'frommodcp': '', 'handlekey': 'mods',\n                         'listextra': 'page%3D62', 'moderate[]': '496146', 'operations[]': 'type', 'reason': '...',\n                         'redirect': r'http://zhixing.bjtu.edu.cn/thread-496146-1-1.html', 'typeid': '779'}\n                data2 = [(k, v) for k,v in data.iteritems()]\n\n                cnt = 0\n                for tid in range(493022, 496146 + 1):\n                    cnt += 1\n                    if cnt % 20 == 0: print\n                    print tid,\n\n                    data2.append(('moderate[]', str(tid)))\n                    if cnt % 40 == 0 or cnt == 496146:\n                        request = urllib2.Request(url=url, data=urllib.urlencode(data2))\n                        print opener.open(request).read()\n                        data2 = [(k, v) for k,v in data.iteritems()]\n\n    httplib        [http协议的客户端]\n\n        import httplib\n        conn3 = httplib.HTTPConnection('www.baidu.com',80,True,10)\n\n    aiohttp        [检索网页的客户端]\n\n        # 需要python3.3+\n        # http://aiohttp.readthedocs.org/en/v0.12.0/\n\n        import aiohttp\n\n        def get_body(url):\n            response = yield from aiohttp.request('GET', url)\n            return (yield from response.read())\n\n        response = yield from aiohttp.request('GET', 'http://python.org')\n        body = yield from response.read()\n        print(body)\n\n        # 用 asyncio 配合协程抓取页面\n        yield from asyncio.wait_for(request('GET', url), 10)\n\n        http_server\n\n            import asyncio\n            from aiohttp import web\n\n            @asyncio.coroutine\n            def handle(request):\n                name = request.match_info.get('name', \"Anonymous\")\n                text = \"Hello, \" + name\n                return web.Response(body=text.encode('utf-8'))\n\n            @asyncio.coroutine\n            def init(loop):\n                app = web.Application(loop=loop)\n                app.router.add_route('GET', '/{name}', handle)\n\n                srv = yield from loop.create_server(app.make_handler(),\n                                                    '127.0.0.1', 8080)\n                print(\"Server started at http://127.0.0.1:8080\")\n                return srv\n\n            loop = asyncio.get_event_loop()\n            loop.run_until_complete(init(loop))\n            loop.run_forever()\n\n    查看网页图片尺寸类型\n\n        #将图片读入内存\n        #!/usr/bin/env python\n        #encoding=utf-8\n        import cStringIO, urllib2, Image\n        url = 'http://www.01happy.com/wp-content/uploads/2012/09/bg.png'\n        file = urllib2.urlopen(url)\n        tmpIm = cStringIO.StringIO(file.read())\n        im = Image.open(tmpIm)\n        print im.format, im.size, im.mode\n\n    爬虫\n\n        #!/usr/bin/env python\n        #encoding:utf-8\n        #sudo pip install BeautifulSoup\n\n        import requests\n        from BeautifulSoup import BeautifulSoup\n        import re\n\n        baseurl = 'http://blog.sina.com.cn/s/articlelist_1191258123_0_1.html'\n\n        r = requests.get(baseurl)\n\n        for url in re.findall('<a.*?</a>', r.content, re.S):\n            if url.startswith('<a title='):\n                with open(r'd:/final.txt', 'ab') as f:\n                    f.write(url + '\\n')\n\n        linkfile = open(r'd:/final.txt', 'rb')\n        soup = BeautifulSoup(linkfile)\n        for link in soup.findAll('a'):\n            #print link.get('title') + ':    ' + link.get('href')\n            ss = requests.get(link.get('href'))\n            for content in re.findall('<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">.*?</div>', ss.content, re.S):\n                with open(r'd:/myftp/%s.txt'%link.get('title').strip('<>'), 'wb') as f:\n                    f.write(content)\n                    print '%s   has been copied.' % link.get('title')\n\n    反垃圾邮件提交申诉\n\n        #很遗憾，反垃圾邮件联盟改版后加了验证码\n\n        #!/usr/bin/env python\n        #encoding:utf-8\n        import requests\n        import re\n\n        IpList=['113.212.91.25','113.212.91.23']\n        QueryAdd='http://www.anti-spam.org.cn/Rbl/Query/Result'\n        ComplaintAdd='http://www.anti-spam.org.cn/Rbl/Getout/Submit'\n        data = {\n        'CONTENT':'''我们是一家正规的XXX。xxxxxxx。恳请将我们的发送服务器IP移出黑名单。谢谢！\n        处理措施：\n        1.XXXX。\n        2.XXXX。''',\n        'CORP':'abc.com',\n        'WWW':'www.abc.cm',\n        'NAME':'def',\n        'MAIL':'def@163.com.cn',\n        'TEL':'010-50000000',\n        'LEVEL':'0',\n        }\n\n        for Ip in IpList:\n            query = requests.post(url=QueryAdd, data={'IP':Ip})                   # 黑名单查询\n            if query.ok:\n                if re.findall(u'\\u7533\\u8bc9\\u8131\\u79bb', query.text, re.S):     # 查找关键字 申诉脱离 既表明在黑名单中\n                    data['IP']=Ip\n                    complaint = requests.post(url=ComplaintAdd, data=data)        # 提交申诉\n                    if complaint.ok:\n                        if re.findall(u'\\u60a8\\u7684\\u9ed1\\u540d\\u5355\\u8131\\u79bb\\u7533\\u8bf7\\u5df2\\u63d0\\u4ea4', complaint.text, re.S):\n                            status='申请提交'\n                        elif re.findall(u'\\u8131\\u79bb\\u7533\\u8bf7\\u5df2\\u88ab\\u4ed6\\u4eba\\u63d0\\u4ea4', complaint.text, re.S):\n                            status='重复提交'\n                        elif re.findall(u'\\u7533\\u8bf7\\u7531\\u4e8e\\u8fd1\\u671f\\u5185\\u6709\\u88ab\\u62d2\\u7edd\\u7684\\u8bb0\\u5f55', complaint.text, re.S):\n                            status='近期拒绝'\n                        else:\n                            status='异常'\n                else:\n                    status='正常'\n                print '%s  %s' %(Ip,status)\n\n    有道词典\n\n        #!/usr/bin/env python\n        import requests\n        from bs4 import BeautifulSoup\n        # bs4安装: pip install BeautifulSoup4\n\n        def youdao(word):\n            url = r'http://dict.youdao.com/search?le=eng&q={0}'.format(word.strip())\n            r = requests.get(url)\n            if r.ok:\n                soup = BeautifulSoup(r.content)\n                div = soup.find_all('div', class_='trans-container')[:1]    # find_all是bs4的方法\n                ul = BeautifulSoup(str(div[0]))\n                li = ul.find_all('li')\n                for mean in li:\n                    print mean.text\n\n        def query():\n            print('Created by @littlepy, QQ:185635687')\n            while True:\n                word = raw_input('>>>')\n                youdao(word)\n\n        if __name__ == '__main__':\n            query()\n\n    python启动http服务提供访问或下载\n\n        python -m SimpleHTTPServer  9900\n\n8 并发\n\n    #线程安全/竞争条件,锁/死锁检测,线程池,生产消费模型,伪并发,微线程,协程\n    #Stackless Python 是Python编程语言的一个增强版本，它使程序员从基于线程的编程方式中获得好处，并避免传统线程所带来的性能与复杂度问题。Stackless为 Python带来的微线程扩展，是一种低开销、轻量级的便利工具\n\n    Queue队列\n        import Queue\n        q = = Queue.Queue(3)\n        \n        q.put('a', True, 5)              # True等待超时时间, False不等待\n        if q.full():                     # 队列满了返回True,反之False\n            q.qsize()                    # 队列长度\n            workQueue.queue.clear()      # 清空队列\n        q.get(True,5)                    # True等待超时时间, False不等待\n\n    threading多线程\n\n        thread\n            start_new_thread(function,args kwargs=None)    # 产生一个新的线程\n            allocate_lock()                                # 分配一个LockType类型的锁对象\n            exit()                                         # 让线程退出\n            acquire(wait=None)                             # 尝试获取锁对象\n            locked()                                       # 如果获取了锁对象返回True\n            release()                                      # 释放锁\n\n        thread例子\n\n            #!/usr/bin/env python\n            #thread_test.py\n            #不支持守护进程\n            import thread\n            from time import sleep,ctime\n\n            loops = [4,2]\n\n            def loop(nloop,nsec,lock):\n                print 'start loop %s at:%s' % (nloop,ctime())\n                sleep(nsec)\n                print 'loop %s done at: %s' % (nloop, ctime())\n                lock.release()              # 分配已获得的锁,操作结束后释放相应的锁通知主线程\n\n            def main():\n                print 'starting at:',ctime()\n                locks = []\n                nloops = range(len(loops))\n\n                for i in nloops:\n                    lock = thread.allocate_lock()     # 创建一个锁\n                    lock.acquire()                    # 调用各个锁的acquire()函数获得锁\n                    locks.append(lock)                # 把锁放到锁列表locks中\n                for i in nloops:\n                    thread.start_new_thread(loop,(i,loops[i],locks[i]))   # 创建线程\n                for i in nloops:\n                    while locks[i].locked():pass      # 等待全部解锁才继续运行\n                print 'all DONE at:',ctime()\n\n            if __name__ == '__main__':\n                main()\n\n        thread例子1\n\n            #coding=utf-8\n            import thread,time,os\n\n            def f(name):\n                    i =3\n                    while i:\n                            time.sleep(1)\n                            print name\n                            i -= 1\n                    # os._exit()   会把整个进程关闭\n                    os._exit(22)\n\n            if __name__ == '__main__':\n                    thread.start_new_thread(f,(\"th1\",))\n                    while 1:\n                            pass\n                    os._exit(0)\n\n        threading\n            Thread                   # 表示一个线程的执行的对象\n                start()              # 开始线程的执行\n                run()                # 定义线程的功能的函数(一般会被子类重写)\n                join(timeout=None)   # 允许主线程等待线程结束,程序挂起,直到线程结束;如果给了timeout,则最多等待timeout秒.\n                getName()            # 返回线程的名字\n                setName(name)        # 设置线程的名字\n                isAlive()            # 布尔标志,表示这个线程是否还在运行中\n                isDaemon()           # 返回线程的daemon标志\n                setDaemon(daemonic)  # 后台线程,把线程的daemon标志设置为daemonic(一定要在调用start()函数前调用)\n                # 默认主线程在退出时会等待所有子线程的结束。如果希望主线程不等待子线程，而是在退出时自动结束所有的子线程，就需要设置子线程为后台线程(daemon)\n            Lock              # 锁原语对象\n            Rlock             # 可重入锁对象.使单线程可以在此获得已获得了的锁(递归锁定)\n            Condition         # 条件变量对象能让一个线程停下来,等待其他线程满足了某个条件.如状态改变或值的改变\n            Event             # 通用的条件变量.多个线程可以等待某个事件的发生,在事件发生后,所有的线程都会被激活\n            Semaphore         # 为等待锁的线程提供一个类似等候室的结构\n            BoundedSemaphore  # 与Semaphore类似,只是不允许超过初始值\n            Time              # 与Thread相似,只是他要等待一段时间后才开始运行\n            activeCount()     # 当前活动的线程对象的数量\n            currentThread()   # 返回当前线程对象\n            enumerate()       # 返回当前活动线程的列表\n            settrace(func)    # 为所有线程设置一个跟踪函数\n            setprofile(func)  # 为所有线程设置一个profile函数\n\n        threading例子1\n\n            #!/usr/bin/env python\n            #encoding:utf8\n            import threading\n            from Queue import Queue\n            from time import sleep,ctime\n\n            class ThreadFunc(object):\n                    def __init__(self,func,args,name=''):\n                            self.name=name\n                            self.func=func                    # loop\n                            self.args=args                    # (i,iplist[i],queue)\n                    def __call__(self):\n                            apply(self.func,self.args)        # 函数apply() 执行loop函数并传递元组参数\n            def loop(nloop,ip,queue):\n                    print 'start',nloop,'at:',ctime()\n                    queue.put(ip)\n                    sleep(2)\n                    print 'loop',nloop,'done at:',ctime()\n            if __name__ == '__main__':\n                    threads = []\n                    queue = Queue()\n                    iplist = ['192.168.1.2','192.168.1.3','192.168.1.4','192.168.1.5','192.168.1.6','192.168.1.7','192.168.1.8']\n                    nloops = range(len(iplist))\n\n                    for i in nloops:\n                            t = threading.Thread(target=ThreadFunc(loop,(i,iplist[i],queue),loop.__name__))\n                            threads.append(t)\n                    for i in nloops:\n                            threads[i].start()\n                    for i in nloops:\n                            threads[i].join()\n                    for i in nloops:\n                            print queue.get()\n\n        threading例子2\n\n            #!/usr/bin/env python\n            #encoding:utf8\n            from Queue import Queue\n            import random,time,threading\n\n            class Producer(threading.Thread):\n                def __init__(self, t_name, queue):\n                    threading.Thread.__init__(self, name=t_name)\n                    self.data=queue\n                def run(self):\n                    for i in range(5):\n                        print \"%s: %s is producing %d to the queue!\\n\" %(time.ctime(), self.getName(), i)\n                        self.data.put(i)\n                        self.data.put(i*i)\n                        time.sleep(2)\n                    print \"%s: %s finished!\" %(time.ctime(), self.getName())\n\n            class Consumer(threading.Thread):\n                def __init__(self, t_name, queue):\n                    threading.Thread.__init__(self, name=t_name)\n                    self.data=queue\n                def run(self):\n                    for i in range(10):\n                        val = self.data.get()\n                        print \"%s: %s is consuming. %d in the queue is consumed!\\n\" %(time.ctime(), self.getName(), val)\n                    print \"%s: %s finished!\" %(time.ctime(), self.getName())\n\n            if __name__ == '__main__':\n                queue = Queue()\n                producer = Producer('Pro.', queue)\n                consumer = Consumer('Con.', queue)\n                producer.start()\n                consumer.start()\n                producer.join()\n                consumer.join()\n\n        threading例子3\n\n            # 启动线程后自动执行 run函数其他不可以\n            import threading\n            import time\n\n            class Th(threading.Thread):\n                def __init__(self,name):\n                    threading.Thread.__init__(self)\n                    self.t_name=name\n                    self.daemon = True     # 默认为false，让主线程等待处理完成\n                def run(self):\n                    time.sleep(1)\n                    print \"this is \" + self.t_name\n\n            if __name__ == '__main__':\n                thread1 = Th(\"Th_1\")\n                thread1.start()\n\n        threading例子4\n\n            import threading\n            import time\n            class Th(threading.Thread):\n                def __init__(self,thread_name):\n                    threading.Thread.__init__(self)\n                    self.setName(thread_name)\n                def run(self):\n                    threadLock.acquire()\n                    print self.getName()\n                    for i in range(3):\n                        time.sleep(1)\n                        print str(i)\n                    print self.getName() +  \" is over\"\n                    threadLock.release()\n\n            if __name__ == '__main__':\n                threadLock = threading.Lock()\n                thread1 = Th(\"Th_1\")\n                thread2 = Th(\"Th_2\")\n                thread1.start()\n                thread2.start()\n\n        后台线程\n\n            import threading\n            import time,random\n\n            class MyThread(threading.Thread):\n                def run(self):\n                    wait_time=random.randrange(1,10)\n                    print \"%s will wait %d seconds\" % (self.name, wait_time)\n                    time.sleep(wait_time)\n                    print \"%s finished!\" % self.name\n\n            if __name__==\"__main__\":\n                for i in range(5):\n                    t = MyThread()\n                    t.setDaemon(True)    # 设置为后台线程,主线程完成时不等待子线程完成就结束\n                    t.start()\n\n        threading控制最大并发_查询日志中IP信息\n\n            #!/usr/bin/env python\n            #coding:utf-8\n            import urllib2\n            import json\n            import threading\n            import time\n\n            '''\n            by:某大牛\n            QQ:185635687\n            这个是多线程并发控制. 如果要改成多进程，只需把threading 换成 mulitprocessing.Process ， 对， 就是换个名字而已.\n            '''\n\n            #获取ip 及其出现次数\n            def ip_dic(file_obj, dic):\n                for i in file_obj:\n                    if i:\n                        ip=i.split('-')[0].strip()\n                        if ip in dic.keys():\n                            dic[ip]=dic[ip] + 1\n                        else:\n                            dic[ip]=1\n                return dic.iteritems()\n\n            #目标函数\n            def get_data(url, ipcounts):\n                data=urllib2.urlopen(url).read()\n                datadict=json.loads(data)\n                fdata = u\"ip:%s---%s,%s,%s,%s,%s\" %(datadict[\"data\"][\"ip\"],ipcounts,datadict[\"data\"][\"country\"],datadict[\"data\"][\"region\"],datadict[\"data\"][\"city\"],datadict[\"data\"][\"isp\"])\n                print fdata\n\n            #多线程\n            def threads(iters):\n                thread_pool = []\n                for k in iters:\n                    url = \"http://ip.taobao.com/service/getIpInfo.php?ip=\"\n                    ipcounts = k[1]\n                    url = (url + k[0]).strip()\n                    t = threading.Thread(target=get_data, args=(url, ipcounts))\n                    thread_pool.append(t)\n                return thread_pool\n\n            #控制多线程\n            def startt(t_list, max,second):\n                l = len(t_list)\n                n = max\n                while l > 0:\n                    if l > max:\n                        nl = t_list[:max]\n                        t_list = t_list[max:]\n                        for t in nl:\n                            t.start()\n                        time.sleep(second)\n                        for t in nl:\n                            t.join()\n                        print '*'*15,  str(n)+ ' ip has been queried'+'*'*15\n                        n += max\n                        l = len(t_list)\n                        continue\n                    elif l <= max:\n                        nl = t_list\n                        for t in nl:\n                            t.start()\n                        for t in nl:\n                            t.join()\n                        print '>>> Totally ' + str(n+l ) + ' ip has been queried'\n                        l = 0\n\n            if __name__ ==\"__main__\":\n                dic={}\n                with open('access.log') as file_obj:\n                    it = ip_dic(file_obj, dic)\n                    t_list= threads(it)\n                    startt(t_list, 15, 1)\n\n        多线程取队列\n\n            #!/usr/bin/python\n\n            import Queue\n            import threading\n            import time\n\n            exitFlag = 0\n\n            class myThread(threading.Thread):\n                def __init__(self, threadID, name, q):\n                    threading.Thread.__init__(self)\n                    self.threadID = threadID\n                    self.name = name\n                    self.q = q\n                def run(self):\n                    print \"Starting \" + self.name\n                    process_data(self.name, self.q)\n                    print \"Exiting \" + self.name\n\n            def process_data(threadName, q):\n                while not exitFlag:      # 死循环等待\n                    queueLock.acquire()\n                    if not q.empty():    # 判断队列是否为空\n                        data = q.get()\n                        print \"%s processing %s\" % (threadName, data)\n                    queueLock.release()\n                    time.sleep(1)\n\n            nameList = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]\n            queueLock = threading.Lock()     # 锁与队列并无任何关联，其他线程也进行取锁操作的时候就会检查是否有被占用，有就阻塞等待解锁为止\n            workQueue = Queue.Queue(10)\n            threads = []\n            threadID = 1\n\n            # Create new threads\n            for threadID in range(100):\n                thread = myThread(threadID, 'tName%s' % threadID, workQueue)\n                thread.start()\n                threads.append(thread)\n                threadID += 1\n\n            # Fill the queue\n            queueLock.acquire()\n            for word in nameList:\n                workQueue.put(word)\n            queueLock.release()\n\n            # Wait for queue to empty\n            while not workQueue.empty():   # 死循环判断队列被处理完毕\n                pass\n\n            # Notify threads it's time to exit\n            exitFlag = 1\n\n            # Wait for all threads to complete\n            for t in threads:\n                t.join()\n            print \"Exiting Main Thread\"\n\n    Queue通用队列\n\n        q=Queue(size)       # 创建大小size的Queue对象\n        qsize()             # 返回队列的大小(返回时候,可能被其他进程修改,近似值)\n        empty()             # 如果队列为空返回True，否则False\n        full()              # 如果队列已满返回True，否则False\n        put(item,block0)    # 把item放到队列中,如果给了block(不为0),函数会一直阻塞到队列中有空间为止\n        get(block=0)        # 从队列中取一个对象,如果给了block(不为0),函数会一直阻塞到队列中有对象为止\n        get_nowait          # 默认get阻塞，这个不阻塞\n\n    multiprocessing [多进程并发]\n\n        线程池\n\n            import urllib2\n            from multiprocessing.dummy import Pool as ThreadPool\n\n            urls=['http://www.baidu.com','http://www.sohu.com']\n\n            pool=ThreadPool(4)   # 线程池\n            results=pool.map(urllib2.urlopen,urls)\n            pool.close()\n            pool.join()\n\n        进程并发\n\n            #!/usr/bin/env python\n            #encoding:utf8\n            from multiprocessing import Process\n            import time,os\n            def f(name):\n                time.sleep(1)\n                print 'hello ',name\n                print os.getppid()   # 取得父进程ID\n                print os.getpid()    # 取得进程ID\n            process_list = []\n\n            for i in range(10):\n                p = Process(target=f,args=(i,))\n                p.start()\n                process_list.append(p)\n            for j in process_list:\n                j.join()\n\n        进程池\n\n            #!/usr/bin/env python\n            #encoding:utf8\n            from multiprocessing import Pool\n            import time,os\n            def f(name):\n                time.sleep(1)\n                print 'hello ',name\n                print os.getppid()\n                print os.getpid()\n            process_list = []\n\n            pool = Pool(4)\n            res = pool.map(f, range(1,10))\n            pool.close()\n            pool.join()\n\n        Queue进程间通信\n\n            from multiprocessing import Process,Queue\n            import time\n            def f(name):\n                time.sleep(1)\n                q.put(['hello'+str(name)])\n            process_list = []\n            q = Queue()\n            if __name__ == '__main__':\n                for i in range(10):\n                    p = Process(target=f,args=(i,))\n                    p.start()\n                    process_list.append(p)\n                for j in process_list:\n                    j.join()\n                for i in range(10):\n                    print q.get()\n\n        Pipe管道 # 单项通信\n\n            from multiprocessing import Process,Pipe\n            import time\n            import os\n\n            def f(conn,name):\n                time.sleep(1)\n                conn.send(['hello'+str(name)])\n                print os.getppid(),'-----------',os.getpid()\n            process_list = []\n            parent_conn,child_conn = Pipe()\n            if __name__ == '__main__':\n                for i in range(10):\n                    p = Process(target=f,args=(child_conn,i))\n                    p.start()\n                    process_list.append(p)\n                for j in process_list:\n                    j.join()\n                for p in range(10):\n                    print parent_conn.recv()\n\n        进程间同步\n            #加锁,使某一时刻只有一个进程,其他在调用同一个锁就会被阻塞\n            from multiprocessing import Process,Lock\n            import time\n            import os\n\n            def f(name):\n                lock.acquire()\n                time.sleep(1)\n                print 'hello--'+str(name)\n                print os.getppid(),'-----------',os.getpid()\n                lock.release()\n            process_list = []\n            lock = Lock()\n            if __name__ == '__main__':\n                for i in range(10):\n                    p = Process(target=f,args=(i,))\n                    p.start()\n                    process_list.append(p)\n                for j in process_list:\n                    j.join()\n\n        共享内存 # 双向通信\n\n            # 通过使用Value或者Array把数据存储在一个共享的内存表中\n            # 'd'和'i'参数是num和arr用来设置类型，d表示一个双精浮点类型，i表示一个带符号的整型。\n            from multiprocessing import Process,Value,Array\n            import time\n            import os\n\n            def f(n,a,name):\n                time.sleep(1)\n                n.value = name * name\n                for i in range(len(a)):\n                    a[i] = -i\n            process_list = []\n            if __name__ == '__main__':\n                num = Value('d',0.0)\n                arr = Array('i',range(10))\n                for i in range(10):\n                    p = Process(target=f,args=(num,arr,i))\n                    p.start()\n                    process_list.append(p)\n                for j in process_list:\n                    j.join()\n                print num.value\n                print arr[:]\n\n        manager\n\n            # 比共享内存灵活,但缓慢\n            # 支持list,dict,Namespace,Lock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Ｖalue,Array\n            from multiprocessing import Process,Manager\n            import time\n            import os\n\n            def f(d,name):\n                time.sleep(1)\n                d[name] = name * name\n                print d\n            process_list = []\n            if __name__ == '__main__':\n                manager = Manager()\n                d = manager.dict()\n                for i in range(10):\n                    p = Process(target=f,args=(d,i))\n                    p.start()\n                    process_list.append(p)\n                for j in process_list:\n                    j.join()\n                    print d\n\n        最大并发数\n\n            import multiprocessing\n            import time,os\n\n            result = []\n            def run(h):\n                print 'threading:' ,h,os.getpid()\n            p = multiprocessing.Pool(processes=20)\n\n            for i in range(100):\n                result.append(p.apply_async(run,(i,)))\n            p.close()\n\n            for res in result:\n                res.get(timeout=5)\n\n    gevent          [轻量级协程]\n\n        # 在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。\n        # http://xlambda.com/gevent-tutorial/\n\n        锁的使用\n\n            # 同时允许多个协程操作对象的锁,通过互斥访问,保证资源只在程序上下文被单次使用\n            from gevent import sleep\n            from gevent.pool import Pool\n            from gevent.coros import BoundedSemaphore\n\n            sem = BoundedSemaphore(2)        # 超过2就会阻塞等待\n\n            def worker1(n):\n                sem.acquire()\n                print('Worker %i acquired semaphore' % n)\n                sleep(0)\n                sem.release()\n                print('Worker %i released semaphore' % n)\n\n            def worker2(n):\n                with sem:\n                    print('Worker %i acquired semaphore' % n)\n                    sleep(0)\n                print('Worker %i released semaphore' % n)\n\n            pool = Pool()\n            pool.map(worker1, xrange(0,2))\n            pool.map(worker2, xrange(3,6))\n\n        事件\n\n            # Event 阻塞事件\n            import gevent\n            from gevent.event import Event\n\n            evt = Event()\n\n            def setter():\n                '''After 3 seconds, wake all threads waiting on the value of evt'''\n                print('A: Hey wait for me, I have to do something')\n                gevent.sleep(3)\n                print(\"Ok, I'm done\")\n                evt.set()                 # 表示事件完成\n\n            def waiter():\n                '''After 3 seconds the get call will unblock'''\n                print(\"I'll wait for you\")\n                evt.wait()                # 阻塞等待事件完成\n                print(\"It's about time\")\n\n            gevent.joinall([\n                gevent.spawn(setter),\n                gevent.spawn(waiter),\n                gevent.spawn(waiter),\n                gevent.spawn(waiter),\n                gevent.spawn(waiter),\n                gevent.spawn(waiter)\n            ])\n\n            # AsyncResult 可传值的事件\n            import gevent\n            from gevent.event import AsyncResult\n            a = AsyncResult()\n\n            def setter():\n                gevent.sleep(3)\n                a.set('Hello!')            # 事件传值\n\n            def waiter():\n                \"\"\"\n                After 3 seconds the get call will unblock after the setter\n                puts a value into the AsyncResult.\n                \"\"\"\n                print(a.get())             # 获取时间值\n\n            gevent.joinall([\n                gevent.spawn(setter),\n                gevent.spawn(waiter),\n            ])\n\n        队列\n\n            #/usr/local/python\n            #encoding:utf8\n            import gevent\n            from gevent.pool import Pool\n            from gevent.coros import BoundedSemaphore\n            from gevent.queue import Queue, Empty\n            import os\n\n            tasks = Queue(maxsize=30)         # 队列 超过30引发 gevent.hub.LoopExit\n            tasks1 = Queue()\n\n            def boss():\n                print '放队列任务'\n                for i in xrange(1,25):\n                    tasks.put(i)\n\n            def worker1(n):\n                print len(pool)\n                while not tasks.empty():      # 判断队列是否为空\n                    task = tasks.get()        # 获取队列内容\n                    tasks1.put(os.popen('id').read())\n                    print('Worker %s got task %s' % (n, task))\n                    gevent.sleep(0)           # 放弃当前任务\n\n            def worker2(name):\n                try:\n                    while True:\n                        task = tasks1.get(timeout=2)\n                        print '获取后释放:%s' % task\n                        gevent.sleep(0)\n                except Empty:                 # 等待超时报错完成\n                    print('Quitting time!')\n\n            gevent.spawn(boss).join()         # 执行单次协程任务\n\n            pool = Pool(5)                    # 协程池大小\n            pool.map(worker1, xrange(0,20))   # 通过map方法把多个任务分发给池中的5个协程\n\n            gevent.joinall([                  # 同时执行多个协程任务\n                gevent.spawn(worker2, 'steve'),\n                gevent.spawn(worker2, 'john'),\n                gevent.spawn(worker2, 'nancy'),\n            ])\n\n9 框架\n\n    flask           [微型网络开发框架]\n\n        # http://dormousehole.readthedocs.org/en/latest/\n        # http://www.pythonhosted.org/Flask-Bootstrap/basic-usage.html#templates\n        # html放在 ./templates/   js放在 ./static/\n\n        #pip install Flask-Login\n        #pip install Flask-OpenID\n        #pip install Flask-WTF\n        #pip install flask-bootstrap\n        #pip install flask-sqlalchemy\n        #pip install flask-script\n        #pip install flask-migrate\n\n        request.args.get('page', 1)          # 获取参数 ?page=1\n        request.json                         # 获取传递的整个json数据\n        request.form.get(\"host\",'127')       # 获取表单值\n        request.form.getlist('client')       # 获取表单列表\n\n        简单实例 # 接收数据和展示\n\n            import MySQLdb as mysql\n            from flask import Flask, request\n\n            app = Flask(__name__)\n            db.autocommit(True)\n            c = db.cursor()\n\n            \"\"\"\n            CREATE TABLE `statusinfo` (\n              `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n              `hostname` varchar(32) NOT NULL,\n              `load` float(10) NOT NULL DEFAULT 0.00,\n              `time` int(15) NOT NULL,\n              `memtotal` int(15) NOT NULL,\n              `memusage` int(15) NOT NULL,\n              `memfree` int(15) NOT NULL,\n              PRIMARY KEY (`id`)\n            ) ENGINE=InnoDB AUTO_INCREMENT=161 DEFAULT CHARSET=utf8;\n            \"\"\"\n\n            @app.route(\"/collect\", methods=[\"GET\", \"POST\"])\n            def collect():\n                sql = \"\"\n                if request.method == \"POST\":\n                    data = request.json                      # 获取传递的json\n                    hostname = data[\"Host\"]\n                    load = data[\"LoadAvg\"]\n                    time = data[\"Time\"]\n                    memtotal = data[\"MemTotal\"]\n                    memusage = data[\"MemUsage\"]\n                    memfree = data[\"MemFree\"]\n\n                    try:\n                        sql = \"INSERT INTO `statusinfo` (`hostname`,`load`,`time`,`memtotal`,`memusage`,`memfree`) VALUES('%s', %s, %s, %s, %s, %s);\" % (hostname, load,time,memtotal,memusage,memfree)\n                        ret = c.execute(sql)\n                        return 'ok'\n                    except mysql.IntegrityError:\n                        return 'errer'\n\n            @app.route(\"/show\", methods=[\"GET\", \"POST\"])\n            def show():\n                try:\n                    hostname = request.form.get(\"hostname\")     # 获取表单方式的变量值\n                    sql = \"SELECT `load` FROM `statusinfo` WHERE hostname = '%s';\" % (hostname)\n                    c.execute(sql)\n                    ones = c.fetchall()\n                    return render_template(\"sysstatus.html\", data=ones, sql = sql)\n                except:\n                    print 'hostname null'\n\n            from flask import render_template\n            @app.route(\"/xxx/<name>\")\n            def hello_xx(name):\n                return render_template(\"sysstatus.html\", name='teach')\n\n            if __name__ == \"__main__\":\n                app.run(host=\"0.0.0.0\", port=50000, debug=True)\n\n        Flask-SQLAlchemy\n\n            http://www.pythondoc.com/flask-sqlalchemy/queries.html#id2\n            http://docs.jinkan.org/docs/flask-sqlalchemy/models.html#id2\n            https://www.cnblogs.com/mosson/p/6257147.html\n\n            db.create_all()   # 创建表\n\n            增加\n                admin = User('admin', 'admin@example.com')\n                db.session.add(admin)\n                db.session.add(guest)\n                db.session.commit()\n\n            查询\n                # 返回数组\n                users = User.query.all()\n                # 条件过滤 返回一个对象  不存在返回 返回none  像python传参数\n                peter = User.query.filter_by(username = 'peter').first()\n                # 条件过滤 像sql 可使用 ><\n                peter = User.query.filter(username == 'peter').first()\n                # 获取指定列的值\n                print peter.username\n                # 复杂查询 返回列表对象\n                User.query.filter(User.email.endswith('@example.com')).all()\n                # 对查询结果按指定列排序\n                User.query.order_by(User.username)\n                # 取前面的指定条数\n                User.query.limit(1).all()\n                # 通过主键来获取对象\n                User.query.get(1)\n                # 通配查询 ilike 忽略大小写\n                User.query.filter(User.username.ilike('online_%')).all()\n                User.query.filter(User.username.notilike('online_%')).all()\n\n            删除\n                user = User.query.get(id)\n                db.session.delete(user)\n                db.session.commit()\n                User.query.filter_by(id=123).delete()\n                User.query.filter(User.id == 123).delete()\n\n            改\n                db.session.query(Users).filter(Users.id > 2).update({\"name\" : \"099\"})\n                db.session.commit()\n\n\n                q = db.session.query(Toner)\n                q = q.filter(Toner.toner_id==1)\n                record = q.one()\n                record.toner_color = 'Azure Radiance'\n                db.session.flush()\n\n            连表\n                ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()\n                ret = session.query(Person).join(Favor).all()\n                ret = session.query(Person).join(Favor, isouter=True).all()\n\n            通配符\n                ret = session.query(Users).filter(Users.name.like('e%')).all()\n                ret = session.query(Users).filter(~Users.name.like('e%')).all()\n\n            排序\n                ret = session.query(Users).order_by(Users.name).all()                          # 正序\n                ret = session.query(Users).order_by(Users.name.desc()).all()                   # 倒序\n                ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()\n\n\n\n    twisted         [非阻塞异步服务器框架]\n\n        # 较老 推荐使用 协程框架 或 微线程框架\n        # 用来进行网络服务和应用程序的编程。虽然 Twisted Matrix 中有大量松散耦合的模块化组件，但该框架的中心概念还是非阻塞异步服务器这一思想。对于习惯于线程技术或分叉服务器的开发人员来说，这是一种新颖的编程风格，但它却能在繁重负载的情况下带来极高的效率。\n        pip install twisted\n\n        from twisted.internet import protocol, reactor, endpoints\n\n        class Echo(protocol.Protocol):\n            def dataReceived(self, data):\n                self.transport.write(data)\n        class EchoFactory(protocol.Factory):\n            dDescribeInstanceStatusef buildProtocol(self, addr):\n                return Echo()\n\n        endpoints.serverFromString(reactor, \"tcp:1234\").listen(EchoFactory())\n        reactor.run()\n\n        服务端\n\n            #!/usr/bin/env python\n\n            from twisted.application import service, internet\n            from txjsonrpc.netstring import jsonrpc\n\n            class Example(jsonrpc.JSONRPC):\n                \"\"\"An example object to be published.\"\"\"\n                def jsonrpc_echo(self,  x):\n                    \"\"\"Return all passed args.\"\"\"\n                    return x\n                def jsonrpc_add(self, a, b):\n                    \"\"\"Return sum of arguments.\"\"\"\n                    print \"add\", a, b\n                    return a + b\n\n            factory = jsonrpc.RPCFactory(Example())\n            application = service.Application(\"Example JSON-RPC Server\")\n            jsonrpcServer = internet.TCPServer(7080, factory)\n            jsonrpcServer.setServiceParent(application)\n\n\n        客户端\n            #!/usr/bin/env python\n\n            import os\n            import sys\n            sys.path.insert(0, os.getcwd())\n            from twisted.internet import reactor\n            from txjsonrpc.netstring.jsonrpc import Proxy\n\n            def printValue(value):\n                print \"Result: %s\" % str(value)\n                reactor.stop()\n\n            def printError(error):\n                print 'error', error\n                reactor.stop()\n\n            proxy = Proxy('127.0.0.1', 7080)\n            proxy.callRemote('add', 3, 5).addCallbacks(printValue, printError)\n            reactor.run()\n\n    Celery          [分布式任务队列]\n\n        # http://docs.jinkan.org/docs/celery/getting-started/introduction.html\n        pip install -U Celery\n\n    tornado         [极轻量级Web服务器框架]\n\n        # 高可伸缩性和epoll非阻塞IO,响应快速,可处理数千并发连接,特别适用用于实时的Web服务 底层是gevent协程\n        # http://www.tornadoweb.cn/documentation\n        # http://old.sebug.net/paper/books/tornado/#_2\n        # http://demo.pythoner.com/itt2zh/ch5.html\n        # 非阻塞方式生成子进程\n        # https://github.com/vukasin/tornado-subprocess\n\n        pip install tornado\n\n        self.get_argument()           # 方法来获取查询字符串参数，以及解析 POST 的内容\n        self.request.arguments        # 所有的 GET 或 POST 的参数\n        self.request.files            # 所有通过 multipart/form-data POST 请求上传的文件\n        self.request.path             # 请求的路径（ ? 之前的所有内容）\n        self.request.headers          # 请求的开头信息\n        callback                      # 执行完成后执行回调函数\n\n        @tornado.web.asynchronous     # 非阻塞异步装饰器\n        self.finish()                 # 使用非阻塞异步 必须调用 self.finish() 已完成 HTTTP 请求\n        # 异步 HTTP 客户端 两种模式 默认 SimpleAsyncHTTPClient  如果要修改为 CurlAsyncHTTPClient\n        AsyncHTTPClient.configure('tornado.curl_httpclient.CurlAsyncHTTPClient')\n\n\n        import tornado.ioloop\n        import tornado.web\n        import tornado.httpclient\n        import json\n\n\n        class MainHandler(tornado.web.RequestHandler):\n            def get(self):\n                self.write(\"Hello, world\")\n\n            def post(self):\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.write(\"You wrote \" + self.get_argument(\"message\"))\n\n        class Template(tornado.web.RequestHandler):\n            def get(self):\n                items = [\"Item 1\", \"Item 2\", \"Item 3\"]\n                self.render(\"template.html\", title=\"My title\", items=items)\n\n        class urlhttp(tornado.web.RequestHandler):\n            @tornado.web.asynchronous\n            def get(self):\n                http = tornado.httpclient.AsyncHTTPClient()\n                http.fetch(\"http://friendfeed-api.com/v2/feed/bret\", callback=self.on_response)\n\n            def on_response(self, response):\n                if response.error: raise tornado.web.HTTPError(500)\n                jsondata = tornado.escape.json_decode(response.body)\n                print type(jsondata)\n                self.write(json.dumps(jsondata))\n                self.finish()\n\n        class StoryHandler(tornado.web.RequestHandler):\n            def get(self, story_id):\n                self.write(\"You requested the story \" + story_id)\n\n        def make_app():\n            return tornado.web.Application([\n                (r\"/\", MainHandler),\n                (r\"/template\", Template),\n                (r\"/story/([0-9]+)\", StoryHandler),\n                (r\"/tapi\", urlhttp),\n            ])\n\n        if __name__ == \"__main__\":\n            app = make_app()\n            app.listen(8888)\n            tornado.ioloop.IOLoop.current().start()\n\n\n    Scrapy          [web抓取框架]\n\n        # Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。\n        pip install scrapy\n\n        from scrapy import Spider, Item, Field\n\n        class Post(Item):\n            title = Field()\n\n        class BlogSpider(Spider):\n            name, start_urls = 'blogspider', ['http://blog.scrapinghub.com']\n\n            def parse(self, response):\n                return [Post(title=e.extract()) for e in response.css(\"h2 a::text\")]\n\n        scrapy runspider myspider.py\n\n    django          [重量级web框架]\n\n    bottle          [轻量级的Web框架]\n\n    stackless       [增强版python]\n\n        微线程扩展，是一种低开销、轻量级的便利工具  避免传统线程所带来的性能与复杂度问题\n\n    greenlet        [微线程/协程框架]\n\n        # 更加原始的微线程的概念,没有调度,或者叫做协程。这在你需要控制你的代码时很有用。你可以自己构造微线程的 调度器；也可以使用\"greenlet\"实现高级的控制流。例如可以重新创建构造器；不同于Python的构造器，我们的构造器可以嵌套的调用函数，而被嵌套的函数也可以 yield 一个值。\n        pip install greenlet\n\n    asyncio         [异步I/O协同]\n\n        # https://docs.python.org/3/library/asyncio.html\n        需要python3.4+\n        asyncio: 协同程序和事件循环。协同程序像是方法，但是它们可以在代码中的特定点暂停和继续。当在等待一个IO（比如一个HTTP请求），同时执行另一个请求的时候，可以用来暂停一个协同程序。我们使用关键字yield from来设定一个状态，表明我们需要一个协同程序的返回值。而事件循环则被用来安排协同程序的执行。\n\n10例子\n\n    小算法\n\n        斐波那契\n            #将函数结果作为列表可用于循环\n            def fab(max):\n            n, a, b = 0, 0, 1\n            while n < max:\n                yield b\n                a, b = b, a + b\n                n = n + 1\n            for n in fab(5):\n                print n\n\n        乘法口诀\n\n            #!/usr/bin/python\n            for i in range(1,10):\n                for j in range(1,i+1):\n                    print j,'*',i,'=',j*i,\n                else:\n                    print ''\n\n        最小公倍数\n\n            # 1-70的最小公倍数\n            def c(m,n):\n                    a1=m\n                    b1=n\n                    r=n%m\n                    while r!=0:\n                            n=m\n                            m=r\n                            r=n%m\n                    return (a1*b1)/m\n            d=1\n            for i in range(3,71,2):\n                    d = c(d,i)\n            print d\n\n        排序算法\n\n            插入排序\n                def insertion_sort(sort_list):\n                    iter_len = len(sort_list)\n                    if iter_len < 2:\n                        return sort_list\n                    for i in range(1, iter_len):\n                        key = sort_list[i]\n                        j = i - 1\n                        while j>=0 and sort_list[j]>key:\n                            sort_list[j+1] = sort_list[j]\n                            j -= 1\n                        sort_list[j+1] = key\n                    return sort_list\n\n            选择排序\n                def selection_sort(sort_list):\n                    iter_len = len(sort_list)\n                    if iter_len < 2:\n                        return sort_list\n                    for i in range(iter_len-1):\n                        smallest = sort_list[i]\n                        location = i\n                        for j in range(i, iter_len):\n                            if sort_list[j] < smallest:\n                                smallest = sort_list[j]\n                                location = j\n                        if i != location:\n                            sort_list[i], sort_list[location] = sort_list[location], sort_list[i]\n                    return sort_list\n\n            冒泡排序\n                def bubblesort(numbers):\n                    for j in range(len(numbers)-1,-1,-1):\n                        for i in range(j):\n                            if numbers[i]>numbers[i+1]:\n                                numbers[i],numbers[i+1] = numbers[i+1],numbers[i]\n                            print(i,j)\n                            print(numbers)\n\n            快速排序\n\n                # 先从数列中取出一个数作为基准数。\n                # 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。\n                # 再对左右区间重复第二步，直到各区间只有一个数。\n                #!/usr/bin/python\n                # -*- coding: utf-8 -*-\n\n                def sub_sort(array,low,high):\n                    key = array[low]\n                    while low < high:\n                        while low < high and array[high] >= key:\n                            high -= 1\n                        while low < high and array[high] < key:\n                            array[low] = array[high]\n                            low += 1\n                            array[high] = array[low]\n                    array[low] = key\n                    return low\n\n                def quick_sort(array,low,high):\n                     if low < high:\n                        key_index = sub_sort(array,low,high)\n                        quick_sort(array,low,key_index)\n                        quick_sort(array,key_index+1,high)\n\n                if __name__ == '__main__':\n                    array = [8,10,9,6,4,16,5,13,26,18,2,45,34,23,1,7,3]\n                    print array\n                    quick_sort(array,0,len(array)-1)\n                    print array\n\n        二分算法\n\n            #python 2f.py 123456789 4\n            # list('123456789')  =  ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n            #!/usr/bin/env python\n            import sys\n\n            def search2(a,m):\n                low = 0\n                high = len(a) - 1\n                while(low <= high):\n                    mid = (low + high)/2\n                    midval = a[mid]\n\n                    if midval < m:\n                        low = mid + 1\n                    elif midval > m:\n                        high = mid - 1\n                    else:\n                        print mid\n                        return mid\n                print -1\n                return -1\n\n            if __name__ == \"__main__\":\n                a = [int(i) for i in list(sys.argv[1])]\n                m = int(sys.argv[2])\n                search2(a,m)\n\n        全排序\n\n            def Mideng(li):\n                if(type(li)!=list):\n                    return\n                if(len(li)==1):\n                    return [li]\n                result=[]\n                for i in range(0,len(li[:])):\n                    bak=li[:]\n                    head=bak.pop(i)\n                    for j in Mideng(bak):\n                        j.insert(0,head)\n                        result.append(j)\n                return result\n            def MM(n):\n                if(type(n)!=int or n<2):\n                    return\n                return Mideng(list(range(1,n)))\n\n            MM(6)\n\n    嵌套复杂排序\n\n        字典排序\n\n            按照键值(value)排序\n                # a = {'a': 'China', 'c': 'USA', 'b': 'Russia', 'd': 'Canada'}\n                b = sorted(a.items(), key=lambda x: x[1], reverse=True)\n                #[('c', 'USA'), ('b', 'Russia'), ('a', 'China'), ('d', 'Canada')]\n\n            按照键名(key)排序\n                #a = {'a': 'China', 'c': 'USA', 'b': 'Russia', 'd': 'Canada'}\n                b = sorted(a.items(), key=lambda x: x[0], reverse=True)\n                #[('d', 'Canada'), ('c', 'USA'), ('b', 'Russia'), ('a', 'China')]\n\n            嵌套字典, 按照字典键名(key)排序\n                #a = {'a': {'b':  'China'}, 'c': {'d': 'USA'}, 'b': {'c': 'Russia'}, 'd': {'a': 'Canada'}}\n                b = sorted(a.items(), key=lambda x: x[1], reverse=True)\n                #[('c', {'d': 'USA'}), ('b', {'c': 'Russia'}), ('a', {'b': 'China'}), ('d', {'a': 'Canada'})]\n\n            嵌套列表, 针对列表第一个元素排序( 其实直接写 x: x[1] 就是按照第一个值排序. )\n                #a = {'a': [1, 3], 'c': [3, 4], 'b': [0, 2], 'd': [2, 1]}\n                b = sorted(a.items(), key=lambda x: x[1][0], reverse=True)\n                #[('c', [3, 4]), ('d', [2, 1]), ('a', [1, 3]), ('b', [0, 2])]\n\n            嵌套列表, 按照列表其他元素排序  只需要修改列表对应的下标\n                # a = {'a': [1, 3], 'c': [3, 4], 'b': [0, 2], 'd': [2, 1]}\n                b = sorted(a.items(), key=lambda x: x[1][1], reverse=True)\n                # [('c', [3, 4]), ('a', [1, 3]), ('b', [0, 2]), ('d', [2, 1])]\n\n            # 总结:  此处使用lambda方法, x: x[1][1] 就可以看做是在访问字典的值, 想要按照哪个数值排序, 用相应的坐标对应即可, 但当字典过于复杂后, 应该选择用元组存储, 简化排序过程.\n\n\n        列表排序\n\n            1: 按照字母排序\n                # a = ['USA', 'China', 'Canada', 'Russia']\n                a.sort(reverse=True)\n                # ['USA', 'Russia', 'China', 'Canada']\n\n            2: 嵌套列表的排序, 按照子列表的其他值排序雷系, 修改x[0] 这里的下标即可\n                # a = [['USA', 'b'], ['China', 'c'], ['Canada', 'd'], ['Russia', 'a']]\n                a.sort(key=lambda x: x[0], reverse=True)\n                # [['USA', 'b'], ['Russia', 'a'], ['China', 'c'], ['Canada', 'd']]\n\n            3: 嵌套字典, 按照字典值(value) 排序\n                # a = [{'letter': 'b'}, {'letter': 'c'}, {'letter': 'd'}, {'letter': 'a'}]\n                a.sort(key=lambda x: x['letter'], reverse=True)\n                # [{'letter': 'd'}, {'letter': 'c'}, {'letter': 'b'}, {'letter': 'a'}]\n\n            4: 当字典值也是字典时, 这时候会优先按照键名排序, 再按照键值排序. 例子如下\n                # a = [{'letter': {'a': 'b'}}, {'letter': {'a': 'c'}}, {'letter': {'a': 'd'}}, {'letter': {'a': 'a'}}]\n                a.sort(key=lambda x: x['letter'], reverse=True)\n                # [{'letter': {'a': 'd'}}, {'letter': {'a': 'c'}}, {'letter': {'a': 'b'}}, {'letter': {'a': 'a'}}]\n\n            方法2:\n                # a = [{'letter': {'a': 'b'}}, {'letter': {'b': 'c'}}, {'letter': {'c': 'd'}}, {'letter': {'d': 'a'}}]\n                a.sort(key=lambda x: x['letter'], reverse=True)\n                #[{'letter': {'d': 'a'}}, {'letter': {'c': 'd'}}, {'letter': {'b': 'c'}}, {'letter': {'a': 'b'}}]\n\n\n    1000以内是3或者是5的倍数的值的和\n\n        sum([ num for num in range(1, 1000) if num % 3 == 0 or num % 5 == 0 ])\n\n    打印如下列表\n        1\n        2 1\n        3 2 1\n        4 3 2 1\n        5 4 3 2 1\n        6 5 4 3 2 1\n\n        #!/usr/local/python\n\n        i=1\n        while i < 7:\n            a = \"\"\n            n=1\n            while n <= i:\n                a = \"%s %s\" %(n, a)\n                n = n + 1\n\n            print a\n            i = i + 1\n\n    将字典中所有time去掉\n\n        a={'version01': {'nba': {'timenba': 'valuesasdfasdf', 'nbanbac': 'vtimefasdf', 'userasdf': 'vtimasdf'}}}\n        eval(str(a).replace(\"time\",\"\"))\n\n\n    阿里云oss\n\n        https://help.aliyun.com/document_detail/32027.html?spm=5176.doc32026.6.674.AXf7Lw\n        pip install oss2\n\n        # -*- coding: utf-8 -*-\n        import oss2\n\n        auth = oss2.Auth('AccessKeyId', 'AccessKeySecret')\n        # 注意内外网域名 不带bucket\n        service = oss2.Service(auth, 'oss-cn-shanghai-internal.aliyuncs.com')\n\n        print([b.name for b in oss2.BucketIterator(service)])        # 查看存在的bucket\n\n        bucket = oss2.Bucket(auth, 'http://oss-cn-shanghai-internal.aliyuncs.com', 'ec-share')\n        # bucket.create_bucket(oss2.models.BUCKET_ACL_PRIVATE)       # 创建bucket\n        bucket.put_object_from_file('remote.txt','/tmp/local.txt')   # 上传文件\n        bucket.get_object_to_file('remote.txt', 'local-backup.txt')  # 下载文件\n        bucket.delete_object('remote.txt')                           # 删除文件\n\n\n    阿里云ecs\n        https://help.aliyun.com/document_detail/67117.html?spm=a2c4g.11186623.6.543.390360e41Cfpqm\n        pip install aliyun-python-sdk-core     # 安装阿里云SDK核心库\n        pip install aliyun-python-sdk-ecs      # 安装管理ECS的库\n\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.acs_exception.exceptions import ClientException\n        from aliyunsdkcore.acs_exception.exceptions import ServerException\n        from aliyunsdkecs.request.v20140526 import DescribeInstancesRequest\n        from aliyunsdkecs.request.v20140526 import StopInstanceRequest\n        client = AcsClient(\n           \"your-access-key-id\", \n           \"your-access-key-secret\",\n           \"your-region-id\"\n        );\n        request = DescribeInstancesRequest.DescribeInstancesRequest()\n        request.set_PageSize(10)\n        try:\n            response = client.do_action_with_exception(request)\n            print response\n        except ServerException as e:\n            print e\n        except ClientException as e:\n        print e\n\n\n        # 使用CommonRequest的方式调用ECS的 DescribeInstanceStatus 接口\n\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.request import CommonRequest\n        client = AcsClient('your_access_key_id', 'your_access_key_secret', 'your_region_id')\n        request = CommonRequest()\n        request.set_domain('ecs.aliyuncs.com')\n        request.set_version('2014-05-26')\n        request.set_action_name('DescribeInstanceStatus')\n        request.add_query_param('PageNumber', '1')\n        request.add_query_param('PageSize', '30')\n        request.add_query_param('ZoneId', 'cn-shanghai-d')\n        response = client.do_action_with_exception(request)\n\n\n        # 接口列表\n        https://help.aliyun.com/document_detail/25506.html?spm=a2c4g.11186623.6.1084.2f672eafMskx7S\n        # 调用DescribeInstances查询一台或多台实例的详细信息\n        DescribeInstances\n        # 调用CreateInstance创建一台ECS实例\n        CreateInstance\n        # 调用StartInstance启动一台实例\n        StartInstance\n        # 调用StopInstance停止运行一台实例\n        StopInstance\n        # 调用DescribeInstanceStatus获取一台或多台ECS实例的状态信息\n        DescribeInstanceStatus\n\n\n        # 创建ecs, CreateInstance, stop状态\n        # 参数列表\n        # https://help.aliyun.com/document_detail/25499.html?spm=a2c4g.11186623.6.1095.4347431djUtw2v\n\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.request import CommonRequest\n        client = AcsClient('LTAIzeBZre', 'fLJOBweE8qHKxrEOnc2FIF', 'cn-shanghai')\n        request = CommonRequest()\n        request.set_domain('ecs.aliyuncs.com')\n        request.set_version('2014-05-26')\n        request.set_action_name('CreateInstance')\n\n        request.add_query_param('ImageId', 'm-uf67jei1pul0xpfsfpfv')\n        request.add_query_param('InstanceType', 'ecs.c5.large')\n        request.add_query_param('RegionId', 'cn-shanghai')\n        request.add_query_param('ZoneId', 'cn-shanghai-f')\n        request.add_query_param('SecurityGroupId', 'sg-uf6i53pjsi11yuyrwyqs')\n        request.add_query_param('VSwitchId', 'vsw-uf630eqh0edoe9n3ig7lz')\n        request.add_query_param('Period', '1')\n        request.add_query_param('InstanceChargeType', 'PrePaid')\n        request.add_query_param('AutoRenew', 'true')\n        request.add_query_param('AutoRenewPeriod', '1')\n        request.add_query_param('InstanceName', 'xuesong-test1')\n        request.add_query_param('HostName', 'xuesong-test1')\n        request.add_query_param('Password', 'azuDa9nee6aiHaey')\n        request.add_query_param('SystemDisk.Size', '200')\n        request.add_query_param('SystemDisk.Category', 'cloud_efficiency')\n        request.add_query_param('SystemDisk.DiskName', 'xuesong-test1')\n\n        response = client.do_action_with_exception(request)\n        # InstanceId               # 实例ID，是访问实例的唯一标识\n        # RequestId                # 无论调用接口成功与否，都会返回请求ID\n\n        # 启动ecs   StartInstance\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.request import CommonRequest\n        client = AcsClient('LTAIzeBZre', 'fLJOBweE8qHKxrEOnc2FIF', 'cn-shanghai')\n        request = CommonRequest()\n        request.set_domain('ecs.aliyuncs.com')\n        request.set_version('2014-05-26')\n        request.set_action_name('StartInstance')\n\n        request.add_query_param('InstanceId', 'i-uf69e821lkybxke6yyno')\n        response = client.do_action_with_exception(request)\n\n\n        # 查询ecs信息 DescribeInstances\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.request import CommonRequest\n        import json\n\n        client = AcsClient('LTAIzeBZre', 'fLJOBweE8qHKxrEOnc2FIF', 'cn-shanghai')\n        request = CommonRequest()\n        request.set_domain('ecs.aliyuncs.com')\n        request.set_version('2014-05-26')\n        request.set_action_name('DescribeInstances')\n\n        request.add_query_param('InstanceIds', ['i-uf69e821lkybxke6yyno'])\n        response = client.do_action_with_exception(request)\n        jresponse = json.loads(response)\n        ip = jresponse['Instances']['Instance'][0]['NetworkInterfaces']['NetworkInterface'][0]['PrimaryIpAddress']\n        status = jresponse['Instances']['Instance'][0]['Status']\n        # Stopped  Stopping  Starting  Running \n\n\n        # 停止ecs StopInstance\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.request import CommonRequest\n\n        client = AcsClient('LTAIzeBZre', 'fLJOBweE8qHKxrEOnc2FIF', 'cn-shanghai')\n        request = CommonRequest()\n        request.set_domain('ecs.aliyuncs.com')\n        request.set_version('2014-05-26')\n        request.set_action_name('StopInstance')\n\n        request.add_query_param('InstanceId', 'i-uf69e821lkybxke6yyno')\n        response = client.do_action_with_exception(request)\n\n\n\n        # 删除ecs DeleteInstance  释放一台按量付费实例或者到期的预付费（包年包月）实例\n        from aliyunsdkcore.client import AcsClient\n        from aliyunsdkcore.request import CommonRequest\n\n        client = AcsClient('LTAIzeBZre', 'fLJOBweE8qHKxrEOnc2FIF', 'cn-shanghai')\n        request = CommonRequest()\n        request.set_domain('ecs.aliyuncs.com')\n        request.set_version('2014-05-26')\n        request.set_action_name('DeleteInstance')\n\n        request.add_query_param('InstanceId', 'i-uf69e821lkybxke6yyno')\n        request.add_query_param('Force', 'true')\n\n        response = client.do_action_with_exception(request)\n\n\n\n    PIL图像处理\n\n        import Image\n        im = Image.open(\"j.jpg\")            # 打开图片\n        print im.format, im.size, im.mode   # 打印图像格式、像素宽和高、模式\n        # JPEG (440, 330) RGB\n        im.show()                           # 显示最新加载图像\n        box = (100, 100, 200, 200)\n        region = im.crop(box)               # 从图像中提取出某个矩形大小的图像\n\n    图片等比缩小\n\n        # -*- coding: cp936 -*-\n        import Image\n        import glob, os\n\n        #图片批处理\n        def timage():\n            for files in glob.glob('D:\\\\1\\\\*.JPG'):\n                filepath,filename = os.path.split(files)\n                filterame,exts = os.path.splitext(filename)\n                #输出路径\n                opfile = r'D:\\\\22\\\\'\n                #判断opfile是否存在，不存在则创建\n                if (os.path.isdir(opfile)==False):\n                    os.mkdir(opfile)\n                im = Image.open(files)\n                w,h = im.size\n                #im_ss = im.resize((400,400))\n                #im_ss = im.convert('P')\n                im_ss = im.resize((int(w*0.12), int(h*0.12)))\n                im_ss.save(opfile+filterame+'.jpg')\n\n        if __name__=='__main__':\n            timage()\n\n    取系统返回值赋给序列\n\n        cmd = os.popen(\"df -Ph|awk 'NR!=1{print $5}'\").readlines();\n        cmd = os.popen('df -h').read().split('\\n')\n        cmd = os.popen('lo 2>&1').read()\n\n        #取磁盘使用空间\n        import commands\n        df = commands.getoutput(\"df -hP\")\n        [ x.split()[4] for x in df.split(\"\\n\") ]\n        [ (x.split()[0],x.split()[4]) for x in df.split(\"\\n\") if x.split()[4].endswith(\"%\") ]\n\n    切片获取星星\n\n        def getRating(rating):\n            return '★★★★★☆☆☆☆☆'.decode('utf8')[5-rating:10-rating]\n        print getRating(1)\n        print getRating(3)\n\n    打印表格\n\n        map = [[\"a\",\"b\",\"c\"],\n               [\"d\",\"e\",\"f\"],\n               [\"g\",\"h\",\"i\"]]\n        def print_board():\n            for i in range(0,3):\n                for j in range(0,3):\n                    print \"|\",map[i][j],\n                    #if j != 2:\n                print '|'\n\n\n    井字游戏\n\n        #!/usr/bin/python\n        # http://www.admin10000.com/document/2506.html\n        def print_board():\n            for i in range(0,3):\n                for j in range(0,3):\n                    print map[2-i][j],\n                    if j != 2:\n                        print \"|\",\n                print \"\"\n\n        def check_done():\n            for i in range(0,3):\n                if map[i][0] == map[i][1] == map[i][2] != \" \" \\\n                or map[0][i] == map[1][i] == map[2][i] != \" \":\n                    print turn, \"won!!!\"\n                    return True\n\n            if map[0][0] == map[1][1] == map[2][2] != \" \" \\\n            or map[0][2] == map[1][1] == map[2][0] != \" \":\n                print turn, \"won!!!\"\n                return True\n\n            if \" \" not in map[0] and \" \" not in map[1] and \" \" not in map[2]:\n                print \"Draw\"\n                return True\n\n            return False\n\n        turn = \"X\"\n        map = [[\" \",\" \",\" \"],\n               [\" \",\" \",\" \"],\n               [\" \",\" \",\" \"]]\n        done = False\n\n        while done != True:\n            print_board()\n\n            print turn, \"'s turn\"\n            print\n\n            moved = False\n            while moved != True:\n                print \"Please select position by typing in a number between 1 and 9, see below for which number that is which position...\"\n                print \"7|8|9\"\n                print \"4|5|6\"\n                print \"1|2|3\"\n                print\n\n                try:\n                    pos = input(\"Select: \")\n                    if pos <=9 and pos >=1:\n                        Y = pos/3\n                        X = pos%3\n                        if X != 0:\n                            X -=1\n                        else:\n                             X = 2\n                             Y -=1\n\n                        if map[Y][X] == \" \":\n                            map[Y][X] = turn\n                            moved = True\n                            done = check_done()\n\n                            if done == False:\n                                if turn == \"X\":\n                                    turn = \"O\"\n                                else:\n                                    turn = \"X\"\n\n                except:\n                    print \"You need to add a numeric value\"\n\n    网段划分\n\n        题目\n            192.168.1\n            192.168.3\n            192.168.2\n            172.16.3\n            192.16.1\n            192.16.2\n            192.16.3\n            10.0.4\n\n            输出结果：\n            192.16.1-192.16.3\n            192.168.1-192.168.3\n            172.16.3\n            10.0.4\n\n        答案\n            #!/usr/bin/python\n\n            f = file('a.txt')\n            c = f.readlines()\n            dic={}\n\n            for i in c:\n                a=i.strip().split('.')\n                if a[0]+'.'+a[1] in dic.keys():\n                    key=dic[\"%s.%s\" %(a[0],a[1])]\n                else:\n                    key=[]\n                key.append(a[2])\n                dic[a[0]+'.'+a[1]]=sorted(key)\n\n            for x,y in dic.items():\n                if y[0] == y[-1]:\n                    print '%s.%s' %(x,y[0])\n                else:\n                    print '%s.%s-%s.%s' %(x,y[0],x,y[-1])\n\n    统计日志IP\n        # 打印出独立IP，并统计独立IP数\n        219.140.190.130 - - [23/May/2006:08:57:59 +0800] \"GET /fg172.exe HTTP/1.1\" 200 2350253\n        221.228.143.52 - - [23/May/2006:08:58:08 +0800] \"GET /fg172.exe HTTP/1.1\" 206 719996\n        221.228.143.52 - - [23/May/2006:08:58:08 +0800] \"GET /fg172.exe HTTP/1.1\" 206 713242\n\n        #!/usr/bin/python\n        dic={}\n        a=open(\"a\").readlines()\n        for i in a:\n            ip=i.strip().split()[0]\n            if ip in dic.keys():\n                dic[ip] = dic[ip] + 1\n            else:\n                dic[ip] = 1\n        for x,y in dic.items():\n            print x,\" \",y\n\n    多线程下载http\n\n        # 先从文件头中或取content-length的值,即文件大小,在用header中指定Range范围来下载文件中一段字符串\n        # 'Range':'bytes=0-499'           # 表示头500个字节\n        # 'Range':'bytes=-500'            # 表示最后500个字节\n        # 'Range':'bytes=500-'            # 表示500字节以后的范围\n        # 'Range':'bytes=0-0,-1'          # 第一个和最后一个字节\n        # 'Range':'bytes=50-60,61-99'     # 同时指定几个范围\n\n        #!/usr/bin/env python\n        #encoding:utf8\n        import urllib2\n        import threading\n\n\n        class myThread(threading.Thread):\n\n            def __init__(self, url_file, scope, url):\n                threading.Thread.__init__(self)\n                self.url_file = url_file\n                self.scope = scope\n                self.url = url\n\n            def run(self):\n\n                req_header = {'User-Agent':\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\",\n                'Accept':'text/html;q=0.9,*/*;q=0.8',\n                'Range':'bytes=%s' % self.scope,\n                'Accept-Charset':'ISO-8859-1,utf-8;q=0.7,*;q=0.3',\n                'Connection':'close',\n                }\n\n                req = urllib2.Request(self.url, headers=req_header)\n                data = urllib2.urlopen(req, data=None).read()\n                start_value = int(self.scope.split('-')[0])\n\n                threadLock.acquire()\n\n                self.url_file.seek(start_value)\n                self.url_file.write(data)\n                self.url_file.flush()\n                threadLock.release()\n\n        if __name__ == '__main__':\n\n            url = 'http://dldir1.qq.com/qqfile/qq/QQ7.1/14522/QQ7.1.exe'\n            size=int(urllib2.urlopen(url).info()['content-length'])\n            print size\n            threadnum = 4\n            len = size / threadnum\n            current = 0\n\n            url_file = file(url.split('/')[-1],'wb+')\n            threadLock = threading.Lock()\n            threads = []\n            for tName in range(1, threadnum + 1):\n\n                if tName < threadnum:\n                    scope = \"%d-%d\" %(current,len * tName - 1)\n                    current = len * tName\n                elif tName == threadnum:\n                        scope = \"%d-\" %(current)\n                print scope\n                thread = myThread(url_file, scope, url)\n                thread.start()\n                threads.append(thread)\n\n            for t in threads:\n                t.join()\n\n            url_file.flush()\n            url_file.close()\n\n    获取网卡流量\n\n        #!/usr/bin/env python\n\n        net = []\n        f = open(\"/proc/net/dev\")\n        lines = f.readlines()\n        f.close()\n        for line in lines[3:]:\n            con = line.split()\n            intf = dict(\n                zip(\n                    ( 'interface', 'ReceiveBytes', 'ReceivePackets', 'TransmitBytes', 'TransmitPackets',),\n                    ( con[0].split(\":\")[0], con[0].split(\":\")[1], int(con[1]), int(con[8]), int(con[9]),)\n                )\n            )\n            net.append(intf)\n        print net\n\n\n    阿里云sdk接口\n\n        # 阿里云接口列表\n        https://develop.aliyun.com/tools/sdk?#/python\n\n        # python sdk模块\n        https://help.aliyun.com/document_detail/30003.html?spm=5176.doc29995.2.1.htCtSa\n\n        # 接口参数详解\n        https://help.aliyun.com/document_detail/25500.html?spm=5176.doc25499.6.691.lWwhc0\n\n        pip install aliyun-python-sdk-core aliyun-python-sdk-ecs\n\n        dir(aliyunsdkecs.request)\n        v20140526\n        aliyunsdkecs.request.v20140526\n\n        #!/usr/bin/env python\n        from aliyunsdkcore import client\n        from aliyunsdkecs.request.v20140526 import DescribeRegionsRequest\n\n        clt = client.AcsClient('SFAW************','Nc2nZ6dQoiqck0*************',\n        'cn-hangzhou')\n\n        request=DescribeRegionsRequest.DescribeRegionsRequest()\n\n        print dir(request)\n\n        request.set_accept_format('json')\n        request.set_action_name(\"CreateInstance\")\n\n        print(clt.do_action(request))\n\n\n    获取系统监控信息\n\n        #!/usr/bin/env python\n        import inspect\n        import os,time,socket\n\n        class mon:\n            def __init__(self):\n                self.data = {}\n            def getLoadAvg(self):\n                with open('/proc/loadavg') as load_open:\n                    a = load_open.read().split()[:3]\n                    #return \"%s %s %s\" % (a[0],a[1],a[2])\n                    return   float(a[0])\n            def getMemTotal(self):\n                with open('/proc/meminfo') as mem_open:\n                    a = int(mem_open.readline().split()[1])\n                    return a / 1024\n            def getMemUsage(self, noBufferCache=True):\n                if noBufferCache:\n                    with open('/proc/meminfo') as mem_open:\n                        T = int(mem_open.readline().split()[1]) #Total\n                        F = int(mem_open.readline().split()[1]) #Free\n                        B = int(mem_open.readline().split()[1]) #Buffer\n                        C = int(mem_open.readline().split()[1]) #Cache\n                        return (T-F-B-C)/1024\n                else:\n                    with open('/proc/meminfo') as mem_open:\n                        a = int(mem_open.readline().split()[1]) - int(mem_open.readline().split()[1])\n                        return a / 1024\n            def getMemFree(self, noBufferCache=True):\n                if noBufferCache:\n                    with open('/proc/meminfo') as mem_open:\n                        T = int(mem_open.readline().split()[1])\n                        F = int(mem_open.readline().split()[1])\n                        B = int(mem_open.readline().split()[1])\n                        C = int(mem_open.readline().split()[1])\n                        return (F+B+C)/1024\n                else:\n                    with open('/proc/meminfo') as mem_open:\n                        mem_open.readline()\n                        a = int(mem_open.readline().split()[1])\n                        return a / 1024\n            def getDiskTotal(self):\n                disk = os.statvfs(\"/\")\n                Total = disk.f_bsize * disk.f_blocks / 1024 / 1024\n                return Total\n            def getDiskFree(self):\n                disk = os.statvfs(\"/\")\n                Free = disk.f_bsize * disk.f_bavail / 1024 / 1024\n                return Free\n            def getTraffic(self):\n                traffic = {}\n                f = open(\"/proc/net/dev\")\n                lines = f.readlines()\n                f.close()\n                for line in lines[3:]:\n                    con = line.split()\n                    intf = dict(\n                        zip(\n                            ('ReceiveBytes', 'TransmitBytes',),\n                            (con[0].split(\":\")[1], int(con[8]),)\n                        )\n                    )\n                    traffic[con[0].split(\":\")[0]] = intf\n                return traffic\n            def getHost(self):\n                #return ['host1', 'host2', 'host3', 'host4', 'host5'][int(time.time() * 1000.0) % 5]\n                return socket.gethostname()\n            def getTime(self):\n                return int(time.time())\n            def runAllGet(self):\n                for fun in inspect.getmembers(self, predicate=inspect.ismethod):\n                    if fun[0][:3] == 'get':\n                        self.data[fun[0][3:]] = fun[1]()\n                return self.data\n\n        if __name__ == \"__main__\":\n            print mon().runAllGet()\n\n\n    nginx_5xx钉钉报警\n        import os\n        import sys\n        import datetime\n        import time\n        import requests\n        import json\n\n        mtime = (datetime.datetime.now()-datetime.timedelta(minutes=1)).strftime(\"%Y-%m-%dT%H:%M\")\n\n        num = int(os.popen('''tail -n 100000 /app/nginx/logs/*_access.log | grep %s |grep 'status\": 5'  |wc -l  ''' % mtime ).read().strip())\n        print num\n\n        if num > 20:\n            print 'baojing'\n            Robot = 'https://oapi.dingtalk.com/robot/send?access_token=e80aa431d237d97217827524'\n            headers = {'content-type': 'application/json'}\n            content = \"lite nginx dmz01 5XX: %s\" % num\n\n            dingdata = {\n                \"msgtype\": \"text\",\n                \"text\": {\n                    \"content\": content\n                }\n            }\n\n            try:\n                r = requests.post(url=Robot, data=json.dumps(dingdata), headers=headers, timeout=2).json()\n            except Exception as err:\n                print 'ERROR: notice dingding api error'\n                print str(err)\n\n\n    获取主机名\n\n        #!/usr/bin/env python\n        # -*- coding: utf8 -*-\n        #python network.py --host\n\n        import os\n        import socket\n\n        \"\"\"\n        copy from:\n        http://stackoverflow.com/questions/11735821/python-get-localhost-ip\n        \"\"\"\n\n        if os.name != \"nt\":\n            import fcntl\n            import struct\n\n            def get_interface_ip(ifname):\n                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', ifname[:15]))[20:24])\n\n        def lan_ip():\n            ip = socket.gethostbyname(socket.gethostname())\n            if ip.startswith(\"127.\") and os.name != \"nt\":\n                interfaces = [\n                    \"eth0\",\n                    \"eth1\",\n                    \"eth2\",\n                    \"wlan0\",\n                    \"wlan1\",\n                    \"wifi0\",\n                    \"ath0\",\n                    \"ath1\",\n                    \"ppp0\",\n                ]\n                for ifname in interfaces:\n                    try:\n                        ip = get_interface_ip(ifname)\n                        break\n                    except IOError:\n                        pass\n            return ip\n\n        if __name__ == '__main__':\n            import sys\n            if len(sys.argv) > 1:\n                print socket.gethostname()\n                sys.exit(0)\n            print lan_ip()\n\n    LazyManage并发批量操作(判断非root交互到root操作)\n\n        #!/usr/bin/python\n        #encoding:utf8\n        # LzayManage.py\n        # config file: serverlist.conf\n\n        import paramiko\n        import multiprocessing\n        import sys,os,time,socket,re\n\n        def Ssh_Cmd(host_ip,Cmd,user_name,user_pwd,port=22):\n            s = paramiko.SSHClient()\n            s.load_system_host_keys()\n            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            s.connect(hostname=host_ip,port=port,username=user_name,password=user_pwd)\n            stdin,stdout,stderr = s.exec_command(Cmd)\n            Result = '%s%s' %(stdout.read(),stderr.read())\n            q.put('successful')\n            s.close()\n            return Result.strip()\n\n        def Ssh_Su_Cmd(host_ip,Cmd,user_name,user_pwd,root_name,root_pwd,port=22):\n            s = paramiko.SSHClient()\n            s.load_system_host_keys()\n            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            s.connect(hostname=host_ip,port=port,username=user_name,password=user_pwd)\n            ssh = s.invoke_shell()\n            time.sleep(0.1)\n            ssh.send('su - %s\\n' %(root_name))\n            buff = ''\n            while not buff.endswith('Password: '):\n                resp = ssh.recv(9999)\n                buff +=resp\n            ssh.send('%s\\n' %(root_pwd))\n            buff = ''\n            while True:\n                resp = ssh.recv(9999)\n                buff +=resp\n                if ': incorrect password' in buff:\n                    su_correct='passwd_error'\n                    break\n                elif buff.endswith('# '):\n                    su_correct='passwd_correct'\n                    break\n            if su_correct == 'passwd_correct':\n                ssh.send('%s\\n' %(Cmd))\n                buff = ''\n                while True:\n                    resp = ssh.recv(9999)\n                    if resp.endswith('# '):\n                        buff +=re.sub('\\[.*@.*\\]# $','',resp)\n                        break\n                    buff +=resp\n                Result = buff.lstrip('%s' %(Cmd))\n                q.put('successful')\n            elif su_correct == 'passwd_error':\n                Result = \"\\033[31mroot密码错误\\033[m\"\n            s.close()\n            return Result.strip()\n\n        def Send_File(host_ip,PathList,user_name,user_pwd,Remote='/tmp',port=22):\n            s=paramiko.Transport((host_ip,port))\n            s.connect(username=user_name,password=user_pwd)\n            sftp=paramiko.SFTPClient.from_transport(s)\n            for InputPath in PathList:\n                LocalPath = re.sub('^\\./','',InputPath.rstrip('/'))\n                RemotePath = '%s/%s' %( Remote , os.path.basename( LocalPath ))\n                try:\n                    sftp.rmdir(RemotePath)\n                except:\n                    pass\n                try:\n                    sftp.remove(RemotePath)\n                except:\n                    pass\n                if os.path.isdir(LocalPath):\n                    sftp.mkdir(RemotePath)\n                    for path,dirs,files in os.walk(LocalPath):\n                        for dir in dirs:\n                            dir_path = os.path.join(path,dir)\n                            sftp.mkdir('%s/%s' %(RemotePath,re.sub('^%s/' %LocalPath,'',dir_path)))\n                        for file in files:\n                            file_path = os.path.join(path,file)\n                            sftp.put( file_path,'%s/%s' %(RemotePath,re.sub('^%s/' %LocalPath,'',file_path)))\n                else:\n                    sftp.put(LocalPath,RemotePath)\n            q.put('successful')\n            sftp.close()\n            s.close()\n            Result = '%s  \\033[32m传送完成\\033[m' % PathList\n            return Result\n\n        def Ssh(host_ip,Operation,user_name,user_pwd,root_name,root_pwd,Cmd=None,PathList=None,port=22):\n            msg = \"\\033[32m-----------Result:%s----------\\033[m\" % host_ip\n            try:\n                if Operation == 'Ssh_Cmd':\n                    Result = Ssh_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,port=port)\n                elif Operation == 'Ssh_Su_Cmd':\n                    Result = Ssh_Su_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,port=port)\n                elif Operation == 'Ssh_Script':\n                    Send_File(host_ip=host_ip,PathList=PathList,user_name=user_name,user_pwd=user_pwd,port=port)\n                    Script_Head = open(PathList[0]).readline().strip()\n                    LocalPath = re.sub('^\\./','',PathList[0].rstrip('/'))\n                    Cmd = '%s /tmp/%s' %( re.sub('^#!','',Script_Head), os.path.basename( LocalPath ))\n                    Result = Ssh_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,port=port)\n                elif Operation == 'Ssh_Su_Script':\n                    Send_File(host_ip=host_ip,PathList=PathList,user_name=user_name,user_pwd=user_pwd,port=port)\n                    Script_Head = open(PathList[0]).readline().strip()\n                    LocalPath = re.sub('^\\./','',PathList[0].rstrip('/'))\n                    Cmd = '%s /tmp/%s' %( re.sub('^#!','',Script_Head), os.path.basename( LocalPath ))\n                    Result = Ssh_Su_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,port=port)\n                elif Operation == 'Send_File':\n                    Result = Send_File(host_ip=host_ip,PathList=PathList,user_name=user_name,user_pwd=user_pwd,port=port)\n                else:\n                    Result = '操作不存在'\n\n            except socket.error:\n                Result = '\\033[31m主机或端口错误\\033[m'\n            except paramiko.AuthenticationException:\n                Result = '\\033[31m用户名或密码错误\\033[m'\n            except paramiko.BadHostKeyException:\n                Result = '\\033[31mBad host key\\033[m['\n            except IOError:\n                Result = '\\033[31m远程主机已存在非空目录或没有写权限\\033[m'\n            except:\n                Result = '\\033[31m未知错误\\033[m'\n            r.put('%s\\n%s\\n' %(msg,Result))\n\n        def Concurrent(Conf,Operation,user_name,user_pwd,root_name,root_pwd,Cmd=None,PathList=None,port=22):\n            # 读取配置文件\n            f=open(Conf)\n            list = f.readlines()\n            f.close()\n            # 执行总计\n            total = 0\n            # 并发执行\n            for host_info in list:\n                # 判断配置文件中注释行跳过\n                if host_info.startswith('#'):\n                    continue\n                # 取变量,其中任意变量未取到就跳过执行\n                try:\n                    host_ip=host_info.split()[0]\n                    #user_name=host_info.split()[1]\n                    #user_pwd=host_info.split()[2]\n                except:\n                    print('Profile error: %s' %(host_info) )\n                    continue\n                try:\n                    port=int(host_info.split()[3])\n                except:\n                    port=22\n                total +=1\n                p = multiprocessing.Process(target=Ssh,args=(host_ip,Operation,user_name,user_pwd,root_name,root_pwd,Cmd,PathList,port))\n                p.start()\n            # 打印执行结果\n            for j in range(total):\n                print(r.get() )\n            if Operation == 'Ssh_Script' or Operation == 'Ssh_Su_Script':\n                successful = q.qsize() / 2\n            else:\n                successful = q.qsize()\n            print('\\033[32m执行完毕[总执行:%s 成功:%s 失败:%s]\\033[m' %(total,successful,total - successful) )\n            q.close()\n            r.close()\n\n        def Help():\n            print('''    1.执行命令\n            2.执行脚本      \\033[32m[位置1脚本(必须带脚本头),后可带执行脚本所需要的包\\文件\\文件夹路径,空格分隔]\\033[m\n            3.发送文件      \\033[32m[传送的包\\文件\\文件夹路径,空格分隔]\\033[m\n            退出: 0\\exit\\quit\n            帮助: help\\h\\?\n            注意: 发送文件默认为/tmp下,如已存在同名文件会被强制覆盖,非空目录则中断操作.执行脚本先将本地脚本及包发送远程主机上,发送规则同发送文件\n            ''')\n\n        if __name__=='__main__':\n            # 定义root账号信息\n            root_name = 'root'\n            root_pwd = 'peterli'\n            user_name='peterli'\n            user_pwd='<++(3Ie'\n            # 配置文件\n            Conf='serverlist.conf'\n            if not os.path.isfile(Conf):\n                print('\\033[33m配置文件 %s 不存在\\033[m' %(Conf) )\n                sys.exit()\n            Help()\n            while True:\n                i = raw_input(\"\\033[35m[请选择操作]: \\033[m\").strip()\n                q = multiprocessing.Queue()\n                r = multiprocessing.Queue()\n                if i == '1':\n                    if user_name == root_name:\n                        Operation = 'Ssh_Cmd'\n                    else:\n                        Operation = 'Ssh_Su_Cmd'\n                    Cmd = raw_input('CMD: ').strip()\n                    if len(Cmd) == 0:\n                        print('\\033[33m命令为空\\033[m')\n                        continue\n                    Concurrent(Conf=Conf,Operation=Operation,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,Cmd=Cmd)\n                elif i == '2':\n                    if user_name == root_name:\n                        Operation = 'Ssh_Script'\n                    else:\n                        Operation = 'Ssh_Su_Script'\n                    PathList = raw_input('\\033[36m本地脚本路径: \\033[m').strip().split()\n                    if len(PathList) == 0:\n                        print('\\033[33m路径为空\\033[m')\n                        continue\n                    if not os.path.isfile(PathList[0]):\n                        print('\\033[33m本地路径 %s 不存在或不是文件\\033[m' %(PathList[0]) )\n                        continue\n                    for LocalPath in PathList[1:]:\n                        if not os.path.exists(LocalPath):\n                            print('\\033[33m本地路径 %s 不存在\\033[m' %(LocalPath) )\n                            break\n                    else:\n                        Concurrent(Conf=Conf,Operation=Operation,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,PathList=PathList)\n                elif i == '3':\n                    Operation = 'Send_File'\n                    PathList = raw_input('\\033[36m本地路径: \\033[m').strip().split()\n                    if len(PathList) == 0:\n                        print('\\033[33m路径为空\\033[m')\n                        continue\n                    for LocalPath in PathList:\n                        if not os.path.exists(LocalPath):\n                            print('\\033[33m本地路径 %s 不存在\\033[m' %(LocalPath) )\n                            break\n                    else:\n                        Concurrent(Conf=Conf,Operation=Operation,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,PathList=PathList)\n                elif i == '0' or i == 'exit' or i == 'quit':\n                    print(\"\\033[34m退出LazyManage脚本\\033[m\")\n                    sys.exit()\n                elif i == 'help' or i == 'h' or i == '?':\n                    Help()\n\n    epoll非阻塞长链接\n\n        server\n\n            #!/usr/bin/python\n            #-*- coding:utf-8 -*-\n\n            import socket, select, logging, errno\n            import os, sys, json\n\n            def cmdRunner(input):\n                import commands\n                cmd_ret = commands.getstatusoutput(input)\n                return json.dumps({'ret':cmd_ret[0], 'out':cmd_ret[1]}, separators=(',', ':'))\n\n            class _State:\n                def __init__(self):\n                    self.state = \"read\"\n                    self.have_read = 0\n                    self.need_read = 10\n                    self.have_write = 0\n                    self.need_write = 0\n                    self.data = \"\"\n\n            __all__ = ['nbNet']\n\n            class nbNet:\n\n                def __init__(self, host, port, logic):\n                    self.host = host\n                    self.port = port\n                    self.logic = logic\n                    self.sm = {\n                        \"read\":self.aread,\n                        \"write\":self.awrite,\n                        \"process\":self.aprocess,\n                        \"closing\":self.aclose,\n                    }\n\n                def run(self):\n\n                    try:\n                        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n                    except socket.error, msg:\n                        print(\"create socket failed\")\n\n                    try:\n                        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                    except socket.error, msg:\n                        print(\"setsocketopt SO_REUSEADDR failed\")\n\n                    try:\n                        self.sock.bind((self.host, self.port))\n                    except socket.error, msg:\n                        print(\"bind failed\")\n\n                    try:\n                        self.sock.listen(10)\n                    except socket.error, msg:\n                        print(msg)\n\n                    try:\n                        self.epoll_fd = select.epoll()\n                        # 向 epoll 句柄中注册 新来socket链接，监听可读事件\n                        self.epoll_fd.register(self.sock.fileno(), select.EPOLLIN )\n                    except select.error, msg:\n                        print(msg)\n\n                    self.STATE = {}\n\n                    while True:\n                        print self.STATE\n                        # epoll 等待事件回调收发数据\n                        epoll_list = self.epoll_fd.poll()\n                        for fd, events in epoll_list:\n                            if select.EPOLLHUP & events:\n                                print 'EPOLLHUP'\n                                self.STATE[fd][2].state = \"closing\"\n                            elif select.EPOLLERR & events:\n                                print 'EPOLLERR'\n                                self.STATE[fd][2].state = \"closing\"\n                            self.state_machine(fd)\n                def state_machine(self, fd):\n                    if fd == self.sock.fileno():\n                        print \"state_machine fd %s accept\" % fd\n                        # fd与初始监听的fd一致,新创建一个连接\n                        conn, addr = self.sock.accept()\n                        # 设置为非阻塞\n                        conn.setblocking(0)\n                        self.STATE[conn.fileno()] = [conn, addr, _State()]\n                        # 将新建立的链接注册在epoll句柄中,监听可读事件,并设置为EPOLLET高速边缘触发,即触发后不会再次触发直到新接收数据\n                        self.epoll_fd.register(conn.fileno(), select.EPOLLET | select.EPOLLIN )\n                    else:\n                        # 否则为历史已存在的fd，调用对应的状态方法\n                        print \"state_machine fd %s %s\" % (fd,self.STATE[fd][2].state)\n                        stat = self.STATE[fd][2].state\n                        self.sm[stat](fd)\n                def aread(self, fd):\n                    try:\n                        # 接收当前fd的可读事件中的数据\n                        one_read = self.STATE[fd][0].recv(self.STATE[fd][2].need_read)\n                        if len(one_read) == 0:\n                            # 接收错误改变状态为关闭\n                            self.STATE[fd][2].state = \"closing\"\n                            self.state_machine(fd)\n                            return\n                        # 将历史接收的数据叠加\n                        self.STATE[fd][2].data += one_read\n                        self.STATE[fd][2].have_read += len(one_read)\n                        self.STATE[fd][2].need_read -= len(one_read)\n                        # 接收协议的10个字符\n                        if self.STATE[fd][2].have_read == 10:\n                            # 通过10个字符得知下次应该具体接收多少字节,存入状态字典中\n                            self.STATE[fd][2].need_read += int(self.STATE[fd][2].data)\n                            self.STATE[fd][2].data = ''\n                            # 调用状态机重新处理\n                            self.state_machine(fd)\n                        elif self.STATE[fd][2].need_read == 0:\n                            # 当接全部收完毕,改变状态,去执行具体服务\n                            self.STATE[fd][2].state = 'process'\n                            self.state_machine(fd)\n                    except socket.error, msg:\n                        self.STATE[fd][2].state = \"closing\"\n                        print(msg)\n                        self.state_machine(fd)\n                        return\n\n                def aprocess(self, fd):\n                    # 执行具体执行方法 cmdRunner 得到符合传输协议的返回结果\n                    response = self.logic(self.STATE[fd][2].data)\n                    self.STATE[fd][2].data = \"%010d%s\"%(len(response), response)\n                    self.STATE[fd][2].need_write = len(self.STATE[fd][2].data)\n                    # 改变为写的状态\n                    self.STATE[fd][2].state = 'write'\n                    # 改变监听事件为写\n                    self.epoll_fd.modify(fd, select.EPOLLET | select.EPOLLOUT)\n                    self.state_machine(fd)\n\n                def awrite(self, fd):\n                    try:\n                        last_have_send = self.STATE[fd][2].have_write\n                        # 发送返回给客户端的数据\n                        have_send = self.STATE[fd][0].send(self.STATE[fd][2].data[last_have_send:])\n                        self.STATE[fd][2].have_write += have_send\n                        self.STATE[fd][2].need_write -= have_send\n                        if self.STATE[fd][2].need_write == 0 and self.STATE[fd][2].have_write != 0:\n                            # 发送完成,重新初始化状态,并将监听写事件改回读事件\n                            self.STATE[fd][2] = _State()\n                            self.epoll_fd.modify(fd, select.EPOLLET | select.EPOLLIN)\n                    except socket.error, msg:\n                        self.STATE[fd][2].state = \"closing\"\n                        self.state_machine(fd)\n                        print(msg)\n                        return\n\n                def aclose(self, fd):\n                    try:\n                        print 'Error: %s:%d' %(self.STATE[fd][1][0] ,self.STATE[fd][1][1])\n                        # 取消fd的事件监听\n                        self.epoll_fd.unregister(fd)\n                        # 关闭异常链接\n                        self.STATE[fd][0].close()\n                        # 删除fd的状态信息\n                        self.STATE.pop(fd)\n                    except:\n                        print 'Close the abnormal'\n\n            if __name__ == \"__main__\":\n                HOST = '0.0.0.0'\n                PORT = 50005\n                nb = nbNet(HOST, PORT, cmdRunner)\n                nb.run()\n\n        client\n\n            #!/usr/bin/env python\n\n            import socket, sys, os\n\n            HOST = '0.0.0.0'\n            PORT = 50005\n\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((HOST, PORT))\n\n            cmd = sys.argv[1]\n            while True:\n                s.sendall(\"%010d%s\"%(len(cmd), cmd))\n                print cmd\n                count = s.recv(10)\n                if not count:\n                    print '-----------'\n                    print count\n                    sys.exit()\n                count = int(count)\n                buf = s.recv(count)\n                print buf\n\n\n\n不定期更新下载地址：\nhttps://github.com/liquanzhou/ops_doc\n\n请勿删除信息, 植入广告, 抵制不道德行为\n"
        },
        {
          "name": "shell实例手册.sh",
          "type": "blob",
          "size": 223.4287109375,
          "content": "    shell实例手册\n\n0 说明{\n\n    手册制作: 雪松\n    更新日期: 2020-03-06\n\n    欢迎系统运维加入Q群: 198173206  # 加群请回答问题\n    欢迎运维开发加入Q群: 365534424  # 不定期技术分享\n\n    请使用\"notepad++\"或其它编辑器打开此文档, \"alt+0\"将函数折叠后方便查阅\n    请勿删除信息, 转载请说明出处, 抵制不道德行为\n    错误在所难免, 还望指正！\n\n    [python实例手册] [shell实例手册] [LazyManage运维批量管理(shell/python两个版本)]\n    github更新下载地址:  https://github.com/liquanzhou/ops_doc\n\n}\n\n1 文件{\n\n    ls -rtl                                    # 按时间倒叙列出所有目录和文件 ll -rt\n    touch file                                 # 创建空白文件\n    rm -rf dirname                             # 不提示删除非空目录(-r:递归删除 -f强制)\n    dos2unix                                   # windows文本转linux文本\n    unix2dos                                   # linux文本转windows文本\n    enca filename                              # 查看编码  安装 yum install -y enca\n    md5sum                                     # 查看md5值\n    ln sourcefile newfile                      # 硬链接\n    ln -s sourcefile newfile                   # 符号连接\n    readlink -f /data                          # 查看连接真实目录\n    cat file | nl |less                        # 查看上下翻页且显示行号  q退出\n    head                                       # 查看文件开头内容\n    head -c 10m                                # 截取文件中10M内容\n    split -C 10M                               # 将文件切割大小为10M -C按行\n    tail -f file                               # 查看结尾 监视日志文件\n    tail -F file                               # 监视日志并重试, 针对文件被mv的情况可以持续读取\n    file                                       # 检查文件类型\n    umask                                      # 更改默认权限\n    uniq                                       # 删除重复的行\n    uniq -c                                    # 重复的行出现次数\n    uniq -u                                    # 只显示不重复行\n    paste a b                                  # 将两个文件合并用tab键分隔开\n    paste -d'+' a b                            # 将两个文件合并指定'+'符号隔开\n    paste -s a                                 # 将多行数据合并到一行用tab键隔开\n    chattr +i /etc/passwd                      # 不得任意改变文件或目录 -i去掉锁 -R递归\n    more                                       # 向下分面器\n    locate aaa                                 # 搜索\n    wc -l file                                 # 查看行数\n    cp filename{,.bak}                         # 快速备份一个文件\n    \\cp a b                                    # 拷贝不提示 既不使用别名 cp -i\n    rev                                        # 将行中的字符逆序排列\n    comm -12 2 3                               # 行和行比较匹配\n    echo \"10.45aa\" |cksum                      # 字符串转数字编码，可做校验，也可用于文件校验\n    iconv -f gbk -t utf8 source.txt > new.txt  # 转换编码\n    xxd /boot/grub/stage1                      # 16进制查看\n    hexdump -C /boot/grub/stage1               # 16进制查看\n    rename source new file                     # 重命名 可正则\n    watch -d -n 1 'df; ls -FlAt /path'         # 实时某个目录下查看最新改动过的文件\n    cp -v  /dev/dvd  /rhel4.6.iso9660          # 制作镜像\n    diff suzu.c suzu2.c  > sz.patch            # 制作补丁\n    patch suzu.c < sz.patch                    # 安装补丁\n\n    sort排序{\n\n        -t                                     # 指定排序时所用的栏位分隔字符\n        -n                                     # 依照数值的大小排序\n        -r                                     # 以相反的顺序来排序\n        -f                                     # 排序时，将小写字母视为大写字母\n        -d                                     # 排序时，处理英文字母、数字及空格字符外，忽略其他的字符\n        -c                                     # 检查文件是否已经按照顺序排序\n        -b                                     # 忽略每行前面开始处的空格字符\n        -M                                     # 前面3个字母依照月份的缩写进行排序\n        -k                                     # 指定域\n        -m                                     # 将几个排序好的文件进行合并\n        -T                                     # 指定临时文件目录,默认在/tmp\n        -o                                     # 将排序后的结果存入指定的文        \n\n        sort -n                                # 按数字排序\n        sort -nr                               # 按数字倒叙\n        sort -u                                # 过滤重复行\n        sort -m a.txt c.txt                    # 将两个文件内容整合到一起\n        sort -n -t' ' -k 2 -k 3 a.txt          # 第二域相同，将从第三域进行升降处理\n        sort -n -t':' -k 3r a.txt              # 以:为分割域的第三域进行倒叙排列\n        sort -k 1.3 a.txt                      # 从第三个字母起进行排序\n        sort -t\" \" -k 2n -u  a.txt             # 以第二域进行排序，如果遇到重复的，就删除\n\n    }\n\n    find查找{\n\n        # linux文件无创建时间\n        # Access 使用时间\n        # Modify 内容修改时间\n        # Change 状态改变时间(权限、属主)\n        # 时间默认以24小时为单位,当前时间到向前24小时为0天,向前48-72小时为2天\n        # -and 且 匹配两个条件 参数可以确定时间范围 -mtime +2 -and -mtime -4\n        # -or 或 匹配任意一个条件\n\n        find /etc -name \"*http*\"                                # 按文件名查找\n        find . -type f                                          # 查找某一类型文件\n        find / -perm                                            # 按照文件权限查找\n        find / -user                                            # 按照文件属主查找\n        find / -group                                           # 按照文件所属的组来查找文件\n        find / -atime -n                                        # 文件使用时间在N天以内\n        find / -atime +n                                        # 文件使用时间在N天以前\n        find / -mtime +n                                        # 文件内容改变时间在N天以前\n        find / -ctime +n                                        # 文件状态改变时间在N天前\n        find / -mmin +30                                        # 按分钟查找内容改变\n        find / -size +1000000c -print                           # 查找文件长度大于1M字节的文件\n        find /etc -name \"*passwd*\" -exec grep \"xuesong\" {} \\;   # 按名字查找文件传递给-exec后命令\n        find . -name 't*' -exec basename {} \\;                  # 查找文件名,不取路径\n        find . -type f -name \"err*\" -exec  rename err ERR {} \\; # 批量改名(查找err 替换为 ERR {}文件\n        find path -name *name1* -or -name *name2*               # 查找任意一个关键字\n\n    }\n\n    vim编辑器{\n\n        # 常用配置\n        set smartindent\n        set tabstop=4\n        set shiftwidth=4\n        set expandtab\n        set softtabstop=4\n        set noautoindent\n        set nosmartindent\n        set paste\n        set clipboard=unnamed\n\n        gconf-editor           # 配置编辑器\n        /etc/vimrc             # 配置文件路径\n        vim +24 file           # 打开文件定位到指定行\n        vim file1 file2        # 打开多个文件\n        vim  -r file           # 恢复上次异常关闭的文件 .file.swp \n        vim -O2 file1 file2    # 垂直分屏\n        vim -on file1 file2    # 水平分屏\n        Ctrl+ U                # 向前翻页\n        Ctrl+ D                # 向后翻页\n        Ctrl+ww                # 在窗口间切换\n        Ctrl+w +or-or=         # 增减高度\n        :sp filename           # 上下分割打开新文件\n        :vs filename           # 左右分割打开新文件\n        :set nu                # 打开行号\n        :set nonu              # 取消行号\n        :nohl                  # 取消高亮\n        :set paste             # 取消缩进\n        :set autoindent        # 设置自动缩进\n        :set ff                # 查看文本格式\n        :set binary            # 改为unix格式\n        :%s/str/newstr/g       # 全部替换\n        :200                   # 跳转到200  1 文件头\n        G                      # 跳到行尾\n        dd                     # 删除当前行 并复制 可直接p粘贴\n        11111dd                # 删除11111行，可用来清空文件\n        r                      # 替换单个字符\n        R                      # 替换多个字符\n        u                      # 撤销上次操作\n        *                      # 全文匹配当前光标所在字符串\n        $                      # 行尾\n        0                      # 行首\n        X                      # 文档加密\n        v =                    # 自动格式化代码\n        Ctrl+v                 # 可视模式\n        Ctrl+v I ESC           # 多行操作\n        Ctrl+v s ESC           # 批量取消注释\n\n    }\n\n    归档解压缩{\n\n        tar zxvpf gz.tar.gz  dir                         # 解包指定tar.gz中的内容  不指定目录则全解压\n        tar zcvpf /$path/gz.tar.gz *                     # 打包gz 注意*最好用相对路径\n        tar zcf /$path/gz.tar.gz *                       # 打包正确不提示\n        tar ztvpf gz.tar.gz                              # 查看gz\n        tar xvf 1.tar -C dir                             # 解包tar 放到指定目录\n        tar -cvf 1.tar *                                 # 打包tar\n        tar tvf 1.tar                                    # 查看tar\n        tar -rvf 1.tar filename                          # 给tar追加文件\n        tar --exclude=/home/dmtsai --exclude=*.tar -zcvf myfile.tar.gz /home/* /etc      # 打包/home, /etc ，但排除 /home/dmtsai\n        tar -N \"2005/06/01\" -zcvf home.tar.gz /home      # 在 /home 当中，比 2005/06/01 新的文件才备份\n        tar -zcvfh home.tar.gz /home                     # 打包目录中包括连接目录\n        tar zcf - ./ | ssh root@IP \"tar zxf - -C /xxxx\"  # 一边压缩一边解压\n        zgrep str 1.gz                                   # 查看压缩包中文件字符行\n        bzip2  -dv 1.tar.bz2                             # 解压bzip2\n        bzip2 -v 1.tar                                   # bzip2压缩\n        bzcat                                            # 查看bzip2\n        gzip file                                        # 直接压缩文件 # 压缩后源文件消失\n        gunzip file.gz                                   # 直接解压文件 # 解压后源文件消失\n        gzip -r dir/                                     # 递归压缩目录\n        gzip  -r -d dir/                                 # 递归解压目录\n        gzip -dv 1.tar.gz                                # 解压gzip到tar\n        gzip -v 1.tar                                    # 压缩tar到gz\n        unzip zip.zip                                    # 解压zip\n        zip zip.zip *                                    # 压缩zip\n        rar a rar.rar *.jpg                              # 压缩文件为rar包\n        unrar x rar.rar                                  # 解压rar包\n\n    }\n\n    文件ACL权限控制{\n\n        getfacl 1.test                      # 查看文件ACL权限\n        setfacl -R -m u:xuesong:rw- 1.test  # 对文件增加用户的读写权限 -R 递归\n\n    }\n\n    svn{\n\n        --force # 强制覆盖\n        /usr/bin/svn --username user --password passwd co  $Code  ${SvnPath}src/                 # 检出整个项目\n        /usr/bin/svn --username user --password passwd up  $Code  ${SvnPath}src/                 # 更新项目\n        /usr/bin/svn --username user --password passwd export  $Code$File ${SvnPath}src/$File    # 导出个别文件\n        /usr/bin/svn --username user --password passwd export -r 版本号 svn路径 本地路径 --force   # 导出指定版本\n\n    }\n\n    git{\n\n        git clone git@10.10.10.10:gittest.git  ./gittest/  # 克隆项目到指定目录\n        git clone  -b develop --depth=1 http://git.a.com/d.git   # 克隆指定分支 克隆一层\n        git status                                         # Show the working tree(工作树) status\n        git log -n 1 --stat                                # 查看最后一次日志文件\n        git branch -a                                      # 列出远程跟踪分支(remote-tracking branches)和本地分支\n        git checkout developing                            # 切换到developing分支\n        git checkout -b release                            # 切换分支没有从当前分支创建\n        git checkout -b release origin/master              # 从远程分支创建本地镜像分支\n        git push origin --delete release                   # 从远端删除分区，服务端有可能设置保护不允许删除\n        git push origin release                            # 把本地分支提交到远程\n        git pull                                           # 更新项目 需要cd到项目目录中\n        git fetch -f -p                                    # 抓取远端代码但不合并到当前\n        git reset --hard origin/master                     # 和远端同步分支\n        git add .                                          # 更新所有文件\n        git commit -m \"gittest up\"                         # 提交操作并添加备注\n        git push                                           # 正式提交到远程git服务器\n        git push [-u origin master]                        # 正式提交到远程git服务器(master分支)\n        git tag [-a] dev-v-0.11.54 [-m 'fix #67']          # 创建tag,名为dev-v-0.11.54,备注fix #67\n        git tag -l dev-v-0.11.54                           # 查看tag(dev-v-0.11.5)\n        git push origin --tags                             # 提交tag\n        git reset --hard                                   # 本地恢复整个项目\n        git rm -r -n --cached  ./img                       # -n执行命令时,不会删除任何文件,而是展示此命令要删除的文件列表预览\n        git rm -r --cached  ./img                          # 执行删除命令 需要commit和push让远程生效\n        git init --bare smc-content-check.git              # 初始化新git项目  需要手动创建此目录并给git用户权限 chown -R git:git smc-content-check.git\n        git config --global credential.helper store        # 记住密码\n        git config [--global] user.name \"your name\"        # 设置你的用户名, 希望在一个特定的项目中使用不同的用户或e-mail地址, 不要--global选项\n        git config [--global] user.email \"your email\"      # 设置你的e-mail地址, 每次Git提交都会使用该信息\n        git config [--global] user.name                    # 查看用户名\n        git config [--global] user.email                   # 查看用户e-mail\n        git config --global --edit                         # 编辑~/.gitconfig(User-specific)配置文件, 值优先级高于/etc/gitconfig(System-wide)\n        git config --edit                                  # 编辑.git/config(Repository specific)配置文件, 值优先级高于~/.gitconfig\n        git cherry-pick  <commit id>                       # 用于把另一个本地分支的commit修改应用到当前分支 需要push到远程\n        git log --pretty=format:'%h: %s' 9378b62..HEAD     # 查看指定范围更新操作 commit id\n        git config --global core.ignorecase false          # 设置全局大小写敏感\n        git ls-remote --heads origin refs/heads/test       # 查看\n\n        从远端拉一份新的{\n            # You have not concluded your merge (MERGE_HEAD exists)  git拉取失败\n            git fetch --hard origin/master\n            git reset --hard origin/master\n        }\n\n        删除远程分支并新建{\n            git checkout master\n            git branch -r -d origin/test       # 删除远程分支  但有时候并没有删除 可以尝试使用下面的语句\n            git push origin :test              # 推送一个空分支到远程分支，相当于删除远程分支\n            git branch -d test                 # 删除本地test分支, -D 强制\n            git branch -a |grep test\n            git checkout -b test\n            git push origin test\n\n            git reset --hard origin/test \n        }\n\n        迁移git项目{\n            git branch -r | grep -v '\\->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done\n            git fetch --all\n            git pull --all\n            git remote set-url origin git@git.github.cn:server/gw.git\n            git push --all\n        }\n    }\n\n    恢复rm删除的文件{\n\n        # debugfs针对 ext2   # ext3grep针对 ext3   # extundelete针对 ext4\n        df -T   # 首先查看磁盘分区格式\n        umount /data/     # 卸载挂载,数据丢失请首先卸载挂载,或重新挂载只读\n        ext3grep /dev/sdb1 --ls --inode 2         # 记录信息继续查找目录下文件inode信息\n        ext3grep /dev/sdb1 --ls --inode 131081    # 此处是inode\n        ext3grep /dev/sdb1 --restore-inode 49153  # 记录下inode信息开始恢复目录\n\n    }\n\n    openssl{\n\n        openssl rand 15 -base64            # 口令生成\n        openssl sha1 filename              # 哈希算法校验文件\n        openssl md5 filename               # MD5校验文件\n        openssl base64   filename.txt      # base64编码/解码文件(发送邮件附件之类功能会可以使用)\n        openssl base64 -d   filename.bin   # base64编码/解码二进制文件\n        openssl enc -aes-128-cbc   filename.aes-128-cbc                  # 加密文档\n        # 推荐使用的加密算法是bf(Blowfish)和-aes-128-cbc(运行在CBC模式的128位密匙AES加密算法)，加密强度有保障\n        openssl enc -d -aes-128-cbc -in filename.aes-128-cbc > filename  # 解密文档\n\n    }\n\n}\n\n2 软件{\n\n    rpm{\n\n        rpm -ivh lynx          # rpm安装\n        rpm -e lynx            # 卸载包\n        rpm -e lynx --nodeps   # 强制卸载\n        rpm -qa                # 查看所有安装的rpm包\n        rpm -qa | grep lynx    # 查找包是否安装\n        rpm -ql                # 软件包路径\n        rpm -Uvh               # 升级包\n        rpm --test lynx        # 测试\n        rpm -qc                # 软件包配置文档\n        rpm --initdb           # 初始化rpm 数据库\n        rpm --rebuilddb        # 重建rpm数据库  在rpm和yum无响应的情况使用 先 rm -f /var/lib/rpm/__db.00* 在重建\n\n    }\n\n    yum{\n\n        yum list                 # 所有软件列表\n        yum install 包名          # 安装包和依赖包\n        yum -y update            # 升级所有包版本,依赖关系，系统版本内核都升级\n        yum -y update 软件包名    # 升级指定的软件包\n        yum -y upgrade           # 不改变软件设置更新软件，系统版本升级，内核不改变\n        yum search mail          # yum搜索相关包\n        yum grouplist            # 软件包组\n        yum -y groupinstall \"Virtualization\"   # 安装软件包组\n        repoquery -ql gstreamer  # 不安装软件查看包含文件\n        yum clean all            # 清除var下缓存\n\n    }\n\n    yum使用epel源{\n\n        # 包下载地址: http://download.fedoraproject.org/pub/epel   # 选择版本5\\6\\7\n        rpm -Uvh  http://mirrors.hustunique.com/epel//6/x86_64/epel-release-6-8.noarch.rpm\n\n        # 自适配版本\n        yum install epel-release\n\n    }\n\n    自定义yum源{\n\n        find /etc/yum.repos.d -name \"*.repo\" -exec mv {} {}.bak \\;\n\n        vim /etc/yum.repos.d/yum.repo\n        [yum]\n        #http\n        baseurl=http://10.0.0.1/centos5.5\n        #挂载iso\n        #mount -o loop CentOS-5.8-x86_64-bin-DVD-1of2.iso /data/iso/\n        #本地\n        #baseurl=file:///data/iso/\n        enable=1\n\n        #导入key\n        rpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5\n\n    }\n\n    编译{\n\n        源码安装{\n\n            ./configure --help                   # 查看所有编译参数\n            ./configure  --prefix=/usr/local/    # 配置参数\n            make                                 # 编译\n            # make -j 8                          # 多线程编译,速度较快,但有些软件不支持\n            make install                         # 安装包\n            make clean                           # 清除编译结果\n\n        }\n\n        perl程序编译{\n\n            perl Makefile.PL\n            make\n            make test\n            make install\n\n        }\n\n        python程序编译{\n\n            python file.py\n\n            # 源码包编译安装\n            python setup.py build\n            python setup.py install\n\n        }\n\n        编译c程序{\n\n            gcc -g hello.c -o hello\n\n        }\n\n    }\n\n}\n\n3 系统{\n\n    wall                                          # 给其它用户发消息\n    whereis ls                                    # 搜索程序名，而且只搜索二进制文件\n    which                                         # 查找命令是否存在,及存放位置\n    locate                                        # 不是实时查找，查找的结果不精确，但查找速度很快 每天更新 /var/lib/locatedb\n    clear                                         # 清空整个屏幕\n    reset                                         # 重新初始化屏幕\n    cal                                           # 显示月历\n    echo -n 123456 | md5sum                       # md5加密\n    mkpasswd                                      # 随机生成密码   -l位数 -C大小 -c小写 -d数字 -s特殊字符\n    netstat -ntupl | grep port                    # 是否打开了某个端口\n    ntpdate cn.pool.ntp.org                       # 同步时间, pool.ntp.org: public ntp time server for everyone(http://www.pool.ntp.org/zh/)\n    tzselect                                      # 选择时区 #+8=(5 9 1 1) # (TZ='Asia/Shanghai'; export TZ)括号内写入 /etc/profile\n    /sbin/hwclock -w                              # 时间保存到硬件\n    /etc/shadow                                   # 账户影子文件\n    LANG=en                                       # 修改语言\n    vim /etc/sysconfig/i18n                       # 修改编码  LANG=\"en_US.UTF-8\"\n    export LC_ALL=C                               # 强制字符集\n    vi /etc/hosts                                 # 查询静态主机名\n    alias                                         # 别名\n    watch uptime                                  # 监测命令动态刷新 监视\n    ipcs -a                                       # 查看Linux系统当前单个共享内存段的最大值\n    ldconfig                                      # 动态链接库管理命令\n    ldd `which cmd`                               # 查看命令的依赖库\n    dist-upgrade                                  # 会改变配置文件,改变旧的依赖关系，改变系统版本\n    /boot/grub/grub.conf                          # grub启动项配置\n    ps -mfL <PID>                                 # 查看指定进程启动的线程 线程数受 max user processes 限制\n    ps uxm |wc -l                                 # 查看当前用户占用的进程数 [包括线程]  max user processes\n    top -p  PID -H                                # 查看指定PID进程及线程\n    lsof |wc -l                                   # 查看当前文件句柄数使用数量  open files\n    lsof |grep /lib                               # 查看加载库文件\n    sysctl -a                                     # 查看当前所有系统内核参数\n    sysctl -p                                     # 修改内核参数/etc/sysctl.conf，让/etc/rc.d/rc.sysinit读取生效\n    strace -p pid                                 # 跟踪系统调用\n    ps -eo \"%p %C  %z  %a\"|sort -k3 -n            # 把进程按内存使用大小排序\n    strace uptime 2>&1|grep open                  # 查看命令打开的相关文件\n    grep Hugepagesize /proc/meminfo               # 内存分页大小\n    mkpasswd -l 8  -C 2 -c 2 -d 4 -s 0            # 随机生成指定类型密码\n    echo 1 > /proc/sys/net/ipv4/tcp_syncookies    # 使TCP SYN Cookie 保护生效  # \"SYN Attack\"是一种拒绝服务的攻击方式\n    grep Swap  /proc/25151/smaps |awk '{a+=$2}END{print a}'    # 查询某pid使用的swap大小\n    redir --lport=33060 --caddr=10.10.10.78 --cport=3306       # 端口映射 yum安装 用supervisor守护\n\n    开机启动脚本顺序{\n\n        /etc/profile\n        /etc/profile.d/*.sh\n        ~/bash_profile\n        ~/.bashrc\n        /etc/bashrc\n\n    }\n\n    进程管理{\n\n        ps -eaf               # 查看所有进程\n        kill -9 PID           # 强制终止某个PID进程\n        kill -15 PID          # 安全退出 需程序内部处理信号\n        cmd &                 # 命令后台运行\n        nohup cmd &           # 后台运行不受shell退出影响\n        ctrl+z                # 将前台放入后台(暂停)\n        jobs                  # 查看后台运行程序\n        bg 2                  # 启动后台暂停进程\n        fg 2                  # 调回后台进程\n        pstree                # 进程树\n        vmstat 1 9            # 每隔一秒报告系统性能信息9次\n        sar                   # 查看cpu等状态\n        lsof file             # 显示打开指定文件的所有进程\n        lsof -i:32768         # 查看端口的进程\n        renice +1 180         # 把180号进程的优先级加1\n        exec sh a.sh          # 子进程替换原来程序的pid， 避免supervisor无法强制杀死进程\n\n        ps{\n\n            ps aux |grep -v USER | sort -nk +4 | tail       # 显示消耗内存最多的10个运行中的进程，以内存使用量排序.cpu +3\n            # USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n            %CPU     # 进程的cpu占用率\n            %MEM     # 进程的内存占用率\n            VSZ      # 进程虚拟大小,单位K(即总占用内存大小,包括真实内存和虚拟内存)\n            RSS      # 进程使用的驻留集大小即实际物理内存大小\n            START    # 进程启动时间和日期\n            占用的虚拟内存大小 = VSZ - RSS\n\n            ps -eo pid,lstart,etime,args         # 查看进程启动时间\n\n        }\n\n        top{\n\n            前五行是系统整体的统计信息。\n            第一行: 任务队列信息，同 uptime 命令的执行结果。内容如下：\n                01:06:48 当前时间\n                up 1:22 系统运行时间，格式为时:分\n                1 user 当前登录用户数\n                load average: 0.06, 0.60, 0.48 系统负载，即任务队列的平均长度。\n                三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。\n\n            第二、三行:为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：\n                Tasks: 29 total 进程总数\n                1 running 正在运行的进程数\n                28 sleeping 睡眠的进程数\n                0 stopped 停止的进程数\n                0 zombie 僵尸进程数\n                Cpu(s): 0.3% us 用户空间占用CPU百分比\n                1.0% sy 内核空间占用CPU百分比\n                0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比\n                98.7% id 空闲CPU百分比\n                0.0% wa 等待输入输出的CPU时间百分比\n                0.0% hi\n                0.0% si\n\n            第四、五行:为内存信息。内容如下：\n                Mem: 191272k total 物理内存总量\n                173656k used 使用的物理内存总量\n                17616k free 空闲内存总量\n                22052k buffers 用作内核缓存的内存量\n                Swap: 192772k total 交换区总量\n                0k used 使用的交换区总量\n                192772k free 空闲交换区总量\n                123988k cached 缓冲的交换区总量。\n                内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，\n                该数值即为这些内容已存在于内存中的交换区的大小。\n                相应的内存再次被换出时可不必再对交换区写入。\n\n            进程信息区,各列的含义如下:  # 显示各个进程的详细信息\n\n            序号 列名    含义\n            a   PID      进程id\n            b   PPID     父进程id\n            c   RUSER    Real user name\n            d   UID      进程所有者的用户id\n            e   USER     进程所有者的用户名\n            f   GROUP    进程所有者的组名\n            g   TTY      启动进程的终端名。不是从终端启动的进程则显示为 ?\n            h   PR       优先级\n            i   NI       nice值。负值表示高优先级，正值表示低优先级\n            j   P        最后使用的CPU，仅在多CPU环境下有意义\n            k   %CPU     上次更新到现在的CPU时间占用百分比\n            l   TIME     进程使用的CPU时间总计，单位秒\n            m   TIME+    进程使用的CPU时间总计，单位1/100秒\n            n   %MEM     进程使用的物理内存百分比\n            o   VIRT     进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\n            p   SWAP     进程使用的虚拟内存中，被换出的大小，单位kb。\n            q   RES      进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\n            r   CODE     可执行代码占用的物理内存大小，单位kb\n            s   DATA     可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb\n            t   SHR      共享内存大小，单位kb\n            u   nFLT     页面错误次数\n            v   nDRT     最后一次写入到现在，被修改过的页面数。\n            w   S        进程状态。\n                D=不可中断的睡眠状态\n                R=运行\n                S=睡眠\n                T=跟踪/停止\n                Z=僵尸进程 父进程在但并不等待子进程\n            x   COMMAND  命令名/命令行\n            y   WCHAN    若该进程在睡眠，则显示睡眠中的系统函数名\n            z   Flags    任务标志，参考 sched.h\n\n        }\n\n        列出正在占用swap的进程{\n\n            #!/bin/bash\n            echo -e \"PID\\t\\tSwap\\t\\tProc_Name\"\n            # 拿出/proc目录下所有以数字为名的目录（进程名是数字才是进程，其他如sys,net等存放的是其他信息）\n            for pid in `ls -l /proc | grep ^d | awk '{ print $9 }'| grep -v [^0-9]`\n            do\n                # 让进程释放swap的方法只有一个：就是重启该进程。或者等其自动释放。放\n                # 如果进程会自动释放，那么我们就不会写脚本来找他了，找他都是因为他没有自动释放。\n                # 所以我们要列出占用swap并需要重启的进程，但是init这个进程是系统里所有进程的祖先进程\n                # 重启init进程意味着重启系统，这是万万不可以的，所以就不必检测他了，以免对系统造成影响。\n                if [ $pid -eq 1 ];then continue;fi\n                grep -q \"Swap\" /proc/$pid/smaps 2>/dev/null\n                if [ $? -eq 0 ];then\n                    swap=$(grep Swap /proc/$pid/smaps \\\n                        | gawk '{ sum+=$2;} END{ print sum }')\n                    proc_name=$(ps aux | grep -w \"$pid\" | grep -v grep \\\n                        | awk '{ for(i=11;i<=NF;i++){ printf(\"%s \",$i); }}')\n                    if [ $swap -gt 0 ];then\n                        echo -e \"${pid}\\t${swap}\\t${proc_name}\"\n                    fi\n                fi\n            done | sort -k2 -n | awk -F'\\t' '{\n                pid[NR]=$1;\n                size[NR]=$2;\n                name[NR]=$3;\n            }\n            END{\n                for(id=1;id<=length(pid);id++)\n                {\n                    if(size[id]<1024)\n                        printf(\"%-10s\\t%15sKB\\t%s\\n\",pid[id],size[id],name[id]);\n                    else if(size[id]<1048576)\n                        printf(\"%-10s\\t%15.2fMB\\t%s\\n\",pid[id],size[id]/1024,name[id]);\n                    else\n                        printf(\"%-10s\\t%15.2fGB\\t%s\\n\",pid[id],size[id]/1048576,name[id]);\n                }\n            }'\n\n        }\n\n        linux操作系统提供的信号{\n\n            kill -l                    # 查看linux提供的信号\n            trap \"echo aaa\"  2 3 15    # shell使用 trap 捕捉退出信号\n\n            # 发送信号一般有两种原因:\n            #   1(被动式)  内核检测到一个系统事件.例如子进程退出会像父进程发送SIGCHLD信号.键盘按下control+c会发送SIGINT信号\n            #   2(主动式)  通过系统调用kill来向指定进程发送信号\n            # 进程结束信号 SIGTERM 和 SIGKILL 的区别:  SIGTERM 比较友好，进程能捕捉这个信号，根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。在某些情况下，假如进程正在进行作业而且不能中断，那么进程可以忽略这个SIGTERM信号。\n            # 如果一个进程收到一个SIGUSR1信号，然后执行信号绑定函数，第二个SIGUSR2信号又来了，第一个信号没有被处理完毕的话，第二个信号就会丢弃。\n\n            SIGHUP  1          A     # 终端挂起或者控制进程终止\n            SIGINT  2          A     # 键盘终端进程(如control+c)\n            SIGQUIT 3          C     # 键盘的退出键被按下\n            SIGILL  4          C     # 非法指令\n            SIGABRT 6          C     # 由abort(3)发出的退出指令\n            SIGFPE  8          C     # 浮点异常\n            SIGKILL 9          AEF   # Kill信号  立刻停止\n            SIGSEGV 11         C     # 无效的内存引用\n            SIGPIPE 13         A     # 管道破裂: 写一个没有读端口的管道\n            SIGALRM 14         A     # 闹钟信号 由alarm(2)发出的信号\n            SIGTERM 15         A     # 终止信号,可让程序安全退出 kill -15\n            SIGUSR1 30,10,16   A     # 用户自定义信号1\n            SIGUSR2 31,12,17   A     # 用户自定义信号2\n            SIGCHLD 20,17,18   B     # 子进程结束自动向父进程发送SIGCHLD信号\n            SIGCONT 19,18,25         # 进程继续（曾被停止的进程）\n            SIGSTOP 17,19,23   DEF   # 终止进程\n            SIGTSTP 18,20,24   D     # 控制终端（tty）上按下停止键\n            SIGTTIN 21,21,26   D     # 后台进程企图从控制终端读\n            SIGTTOU 22,22,27   D     # 后台进程企图从控制终端写\n\n            缺省处理动作一项中的字母含义如下:\n                A  缺省的动作是终止进程\n                B  缺省的动作是忽略此信号，将该信号丢弃，不做处理\n                C  缺省的动作是终止进程并进行内核映像转储(dump core),内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。\n                D  缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）\n                E  信号不能被捕获\n                F  信号不能被忽略\n        }\n\n        系统性能状态{\n\n            vmstat 1 9\n\n            r      # 等待执行的任务数。当这个值超过了cpu线程数，就会出现cpu瓶颈。\n            b      # 等待IO的进程数量,表示阻塞的进程。\n            swpd   # 虚拟内存已使用的大小，如大于0，表示机器物理内存不足，如不是程序内存泄露，那么该升级内存。\n            free   # 空闲的物理内存的大小\n            buff   # 已用的buff大小，对块设备的读写进行缓冲\n            cache  # cache直接用来记忆我们打开的文件,给文件做缓冲，(把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)\n            inact  # 非活跃内存大小，即被标明可回收的内存，区别于free和active -a选项时显示\n            active # 活跃的内存大小 -a选项时显示\n            si   # 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露，要查找耗内存进程解决掉。\n            so   # 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。\n            bi   # 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte\n            bo   # 块设备每秒发送的块数量，例如读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。\n            in   # 每秒CPU的中断次数，包括时间中断。in和cs这两个值越大，会看到由内核消耗的cpu时间会越多\n            cs   # 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用。\n            us   # 用户进程执行消耗cpu时间(user time)  us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施\n            sy   # 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。\n            id   # 空闲 CPU时间，一般来说，id + us + sy = 100,一般认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。\n            wt   # 等待IOCPU时间。Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。\n\n            如果 r 经常大于4，且id经常少于40，表示cpu的负荷很重。\n            如果 pi po 长期不等于0，表示内存不足。\n            如果 b 队列经常大于3，表示io性能不好。\n\n        }\n\n    }\n\n    日志管理{\n\n        history                      # 历时命令默认1000条\n        HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S \"   # 让history命令显示具体时间\n        history  -c                  # 清除记录命令\n        cat $HOME/.bash_history      # 历史命令记录文件\n        lastb -a                     # 列出登录系统失败的用户相关信息  清空二进制日志记录文件 echo > /var/log/btmp\n        last                         # 查看登陆过的用户信息  清空二进制日志记录文件 echo > /var/log/wtmp   默认打开乱码\n        who /var/log/wtmp            # 查看登陆过的用户信息\n        lastlog                      # 用户最后登录的时间\n        tail -f /var/log/messages    # 系统日志\n        tail -f /var/log/secure      # ssh日志\n\n    }\n\n    man{\n        man 2 read   # 查看read函数的文档\n        1 使用者在shell中可以操作的指令或可执行档\n        2 系统核心可呼叫的函数与工具等\n        3 一些常用的函数(function)与函数库(library),大部分是C的函数库(libc)\n        4 装置档案的说明，通常在/dev下的档案\n        5 设定档或者是某些档案的格式\n        6 游戏games\n        7 惯例与协定等，例如linux档案系统、网络协定、ascll code等说明\n        8 系统管理员可用的管理指令\n        9 跟kernel有关的文件\n    }\n\n    selinux{\n\n        sestatus -v                    # 查看selinux状态\n        getenforce                     # 查看selinux模式\n        setenforce 0                   # 设置selinux为宽容模式(可避免阻止一些操作)\n        semanage port -l               # 查看selinux端口限制规则\n        semanage port -a -t http_port_t -p tcp 8000  # 在selinux中注册端口类型\n        vi /etc/selinux/config         # selinux配置文件\n        SELINUX=enfoceing              # 关闭selinux 把其修改为  SELINUX=disabled\n\n    }\n\n    查看剩余内存{\n\n        free -m\n        #-/+ buffers/cache:       6458       1649\n        #6458M为真实使用内存  1649M为真实剩余内存(剩余内存+缓存+缓冲器)\n        #linux会利用所有的剩余内存作为缓存，所以要保证linux运行速度，就需要保证内存的缓存大小\n\n    }\n\n    系统信息{\n\n        uname -a              # 查看Linux内核版本信息\n        cat /proc/version     # 查看内核版本\n        cat /etc/issue        # 查看系统版本\n        lsb_release -a        # 查看系统版本  需安装 centos-release\n        locale -a             # 列出所有语系\n        locale                # 当前环境变量中所有编码\n        hwclock               # 查看时间\n        who                   # 当前在线用户\n        w                     # 当前在线用户\n        whoami                # 查看当前用户名\n        logname               # 查看初始登陆用户名\n        uptime                # 查看服务器启动时间\n        sar -n DEV 1 10       # 查看网卡网速流量\n        dmesg                 # 显示开机信息\n        lsmod                 # 查看内核模块\n\n    }\n\n    硬件信息{\n\n        more /proc/cpuinfo                                       # 查看cpu信息\n        lscpu                                                    # 查看cpu信息\n        cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c    # 查看cpu型号和逻辑核心数\n        getconf LONG_BIT                                         # cpu运行的位数\n        cat /proc/cpuinfo | grep 'physical id' |sort| uniq -c    # 物理cpu个数\n        cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l     # 结果大于0支持64位\n        cat /proc/cpuinfo|grep flags                             # 查看cpu是否支持虚拟化   pae支持半虚拟化  IntelVT 支持全虚拟化\n        more /proc/meminfo                                       # 查看内存信息\n        dmidecode                                                # 查看全面硬件信息\n        dmidecode | grep \"Product Name\"                          # 查看服务器型号\n        dmidecode | grep -P -A5 \"Memory\\s+Device\" | grep Size | grep -v Range       # 查看内存插槽\n        cat /proc/mdstat                                         # 查看软raid信息\n        cat /proc/scsi/scsi                                      # 查看Dell硬raid信息(IBM、HP需要官方检测工具)\n        lspci                                                    # 查看硬件信息\n        lspci|grep RAID                                          # 查看是否支持raid\n        lspci -vvv |grep Ethernet                                # 查看网卡型号\n        lspci -vvv |grep Kernel|grep driver                      # 查看驱动模块\n        modinfo tg2                                              # 查看驱动版本(驱动模块)\n        ethtool -i em1                                           # 查看网卡驱动版本\n        ethtool em1                                              # 查看网卡带宽\n\n    }\n\n    终端快捷键{\n\n        Ctrl+A        　    # 行前\n        Ctrl+E        　    # 行尾\n        Ctrl+S        　    # 终端锁屏\n        Ctrl+Q        　　  # 解锁屏\n        Ctrl+D      　　    # 退出\n\n    }\n\n    开机启动模式{\n\n        vi /etc/inittab\n        id:3:initdefault:    # 3为多用户命令\n        #ca::ctrlaltdel:/sbin/shutdown -t3 -r now   # 注释此行 禁止 ctrl+alt+del 关闭计算机\n\n    }\n\n    终端提示显示{\n\n        echo $PS1                   # 环境变量控制提示显示\n        PS1='[\\u@ \\H \\w \\A \\@#]\\$'\n        PS1='[\\u@\\h \\W]\\$'\n        export PS1='[\\[\\e[32m\\]\\[\\e[31m\\]\\u@\\[\\e[36m\\]\\h \\w\\[\\e[m\\]]\\$ '     # 高亮显示终端\n\n    }\n\n    定时任务{\n\n        at 5pm + 3 days /bin/ls  # 单次定时任务 指定三天后下午5:00执行/bin/ls\n\n        crontab -e               # 编辑周期任务\n        #分钟  小时    天  月  星期   命令或脚本\n        1,30  1-3/2    *   *   *      命令或脚本  >> file.log 2>&1\n        echo \"40 7 * * 2 /root/sh\">>/var/spool/cron/work    # 普通用户可直接写入定时任务\n        crontab -l                                          # 查看自动周期性任务\n        crontab -r                                          # 删除自动周期性任务\n        cron.deny和cron.allow                               # 禁止或允许用户使用周期任务\n        service crond start|stop|restart                    # 启动自动周期性服务\n        * * * * *  echo \"d\" >>d$(date +\\%Y\\%m\\%d).log       # 让定时任务直接生成带日期的log  需要转义%\n\n    }\n\n    date{\n\n        星期日[SUN] 星期一[MON] 星期二[TUE] 星期三[WED] 星期四[THU] 星期五[FRI] 星期六[SAT]\n        一月[JAN] 二月[FEB] 三月[MAR] 四月[APR] 五月[MAY] 六月[JUN] 七月[JUL] 八月[AUG] 九月[SEP] 十月[OCT] 十一月[NOV] 十二月[DEC]\n\n        date -s 20091112                     # 设日期\n        date -s 18:30:50                     # 设时间\n        date -d \"7 days ago\" +%Y%m%d         # 7天前日期\n        date -d \"5 minute ago\" +%H:%M        # 5分钟前时间\n        date -d \"1 month ago\" +%Y%m%d        # 一个月前\n        date -d '1 days' +%Y-%m-%d           # 一天后\n        date -d '1 hours' +%H:%M:%S          # 一小时后\n        date +%Y-%m-%d -d '20110902'         # 日期格式转换\n        date +%Y-%m-%d_%X                    # 日期和时间\n        date +%N                             # 纳秒\n        date -d \"2012-08-13 14:00:23\" +%s    # 换算成秒计算(1970年至今的秒数)\n        date -d \"@1363867952\" +%Y-%m-%d-%T   # 将时间戳换算成日期\n        date -d \"1970-01-01 UTC 1363867952 seconds\" +%Y-%m-%d-%T  # 将时间戳换算成日期\n        date -d \"`awk -F. '{print $1}' /proc/uptime` second ago\" +\"%Y-%m-%d %H:%M:%S\"    # 格式化系统启动时间(多少秒前)\n\n    }\n\n    limits.conf{\n\n        ulimit -SHn 65535  # 临时设置文件描述符大小 进程最大打开文件柄数 还有socket最大连接数, 等同配置 nofile\n        ulimit -SHu 65535  # 临时设置用户最大进程数\n        ulimit -a          # 查看\n\n        /etc/security/limits.conf\n\n        # 文件描述符大小  open files\n        # lsof |wc -l   查看当前文件句柄数使用数量\n        * soft nofile 16384         # 设置太大，进程使用过多会把机器拖死\n        * hard nofile 32768\n\n        # 用户最大进程数  max user processes\n        # echo $((`ps uxm |wc -l`-`ps ux |wc -l`))  查看当前用户占用的进程数 [包括线程]\n        user soft nproc 16384\n        user hard nproc 32768\n\n        # 如果/etc/security/limits.d/有配置文件，将会覆盖/etc/security/limits.conf里的配置\n        # 即/etc/security/limits.d/的配置文件里就不要有同样的参量设置\n        /etc/security/limits.d/90-nproc.conf    # centos6.3的默认这个文件会覆盖 limits.conf\n        user soft nproc 16384\n        user hard nproc 32768\n\n        sysctl -p    # 修改配置文件后让系统生效\n\n    }\n\n    随机分配端口范围{\n\n        # 本机连其它端口用的\n        echo \"10000 65535\" > /proc/sys/net/ipv4/ip_local_port_range\n\n    }\n\n    百万长链接设置{\n\n        # 内存消耗需要较大\n        vim /root/.bash_profile\n        # 添加如下2行,退出bash重新登陆\n        # 一个进程不能使用超过NR_OPEN文件描述符\n        echo 20000500 > /proc/sys/fs/nr_open\n        # 当前用户最大文件数\n        ulimit -n 10000000\n\n    }\n\n    core崩溃文件查看{\n\n        gdb  core.13844\n        bt   # 查看函数调用信息(堆栈)\n\n    }\n\n\n    libc.so故障修复{\n\n        # 由于升级glibc导致libc.so不稳定,突然报错,幸好还有未退出的终端\n        grep: error while loading shared libraries: /lib64/libc.so.6: ELF file OS ABI invalid\n\n        # 看看当前系统有多少版本 libc.so\n        ls /lib64/libc-[tab]\n\n        # 更改环境变量指向其他 libc.so 文件测试\n        export LD_PRELOAD=/lib64/libc-2.7.so    # 如果不改变LD_PRELOAD变量,ln不能用,需要使用 /sbin/sln 命令做链接\n\n        # 当前如果好使了，在执行下面强制替换软链接。如不好使，测试其他版本的libc.so文件\n        ln -f -s /lib64/libc-2.7.so /lib64/libc.so.6\n\n    }\n\n    无法分配内存 {\n    \n        fork: Cannot allocate memory\n    \n        # 报错不一定是内存不够用，进程数或者线程数满了也会报这个错误， 可以适当增加 kernel.pid_max 的值，\n        cat /proc/sys/kernel/pid_max  # 默认3.2w\n    \n    }\n\n    sudo{\n\n        echo myPassword | sudo -S ls /tmp  # 直接输入sudo的密码非交互,从标准输入读取密码而不是终端设备\n        visudo                             # sudo命令权限添加  /etc/sudoers\n        用户  别名(可用all)=NOPASSWD:命令1,命令2\n        user  ALL=NOPASSWD:/bin/su         # 免root密码切换root身份\n        wangming linuxfan=NOPASSWD:/sbin/apache start,/sbin/apache restart\n        UserName ALL=(ALL) ALL\n        UserName ALL=(ALL) NOPASSWD: ALL\n        peterli        ALL=(ALL)       NOPASSWD:/sbin/service\n        Defaults requiretty                # sudo不允许后台运行,注释此行既允许\n        Defaults !visiblepw                # sudo不允许远程,去掉!既允许\n\n    }\n\n    grub开机启动项添加{\n\n        vim /etc/grub.conf\n        title ms-dos\n        rootnoverify (hd0,0)\n        chainloader +1\n\n    }\n\n    stty{\n\n        #stty时一个用来改变并打印终端行设置的常用命令\n\n        stty iuclc          # 在命令行下禁止输出大写\n        stty -iuclc         # 恢复输出大写\n        stty olcuc          # 在命令行下禁止输出小写\n        stty -olcuc         # 恢复输出小写\n        stty size           # 打印出终端的行数和列数\n        stty eof \"string\"   # 改变系统默认ctrl+D来表示文件的结束\n        stty -echo          # 禁止回显\n        stty echo           # 打开回显\n        stty -echo;read;stty echo;read  # 测试禁止回显\n        stty igncr          # 忽略回车符\n        stty -igncr         # 恢复回车符\n        stty erase '#'      # 将#设置为退格字符\n        stty erase '^?'     # 恢复退格字符\n\n        定时输入{\n\n            timeout_read(){\n                timeout=$1\n                old_stty_settings=`stty -g`　　# save current settings\n                stty -icanon min 0 time 100　　# set 10seconds,not 100seconds\n                eval read varname　　          # =read $varname\n                stty \"$old_stty_settings\"　　  # recover settings\n            }\n\n            read -t 10 varname    # 更简单的方法就是利用read命令的-t选项\n\n        }\n\n        检测用户按键{\n\n            #!/bin/bash\n            old_tty_settings=$(stty -g)   # 保存老的设置(为什么?).\n            stty -icanon\n            Keypress=$(head -c1)          # 或者使用$(dd bs=1 count=1 2> /dev/null)\n            echo \"Key pressed was \\\"\"$Keypress\"\\\".\"\n            stty \"$old_tty_settings\"      # 恢复老的设置.\n            exit 0\n\n        }\n\n    }\n\n    iptables{\n\n        内建三个表：nat mangle 和 filter\n        filter预设规则表，有INPUT、FORWARD 和 OUTPUT 三个规则链\n        vi /etc/sysconfig/iptables    # 配置文件\n        INPUT    # 进入\n        FORWARD  # 转发\n        OUTPUT   # 出去\n        ACCEPT   # 将封包放行\n        REJECT   # 拦阻该封包\n        DROP     # 丢弃封包不予处理\n        -A       # 在所选择的链(INPUT等)末添加一条或更多规则\n        -D       # 删除一条\n        -E       # 修改\n        -p       # tcp、udp、icmp    0相当于所有all    !取反\n        -P       # 设置缺省策略(与所有链都不匹配强制使用此策略)\n        -s       # IP/掩码    (IP/24)    主机名、网络名和清楚的IP地址 !取反\n        -j       # 目标跳转，立即决定包的命运的专用内建目标\n        -i       # 进入的（网络）接口 [名称] eth0\n        -o       # 输出接口[名称]\n        -m       # 模块\n        --sport  # 源端口\n        --dport  # 目标端口\n\n        iptables -F                        # 将防火墙中的规则条目清除掉  # 注意: iptables -P INPUT ACCEPT\n        iptables-restore < 规则文件        # 导入防火墙规则\n        /etc/init.d/iptables save          # 保存防火墙设置\n        /etc/init.d/iptables restart       # 重启防火墙服务\n        iptables -L -n                     # 查看规则\n        iptables -t nat -nL                # 查看转发\n\n        iptables实例{\n\n            iptables -L INPUT                   # 列出某规则链中的所有规则\n            iptables -X allowed                 # 删除某个规则链 ,不加规则链，清除所有非内建的\n            iptables -Z INPUT                   # 将封包计数器归零\n            iptables -N allowed                 # 定义新的规则链\n            iptables -P INPUT DROP              # 定义过滤政策\n            iptables -A INPUT -s 192.168.1.1    # 比对封包的来源IP   # ! 192.168.0.0/24  ! 反向对比\n            iptables -A INPUT -d 192.168.1.1    # 比对封包的目的地IP\n            iptables -A INPUT -i eth0           # 比对封包是从哪片网卡进入\n            iptables -A FORWARD -o eth0         # 比对封包要从哪片网卡送出 eth+表示所有的网卡\n            iptables -A INPUT -p tcp            # -p ! tcp 排除tcp以外的udp、icmp。-p all所有类型\n            iptables -D INPUT 8                 # 从某个规则链中删除一条规则\n            iptables -D INPUT --dport 80 -j DROP         # 从某个规则链中删除一条规则\n            iptables -R INPUT 8 -s 192.168.0.1 -j DROP   # 取代现行规则\n            iptables -I INPUT 8 --dport 80 -j ACCEPT     # 插入一条规则\n            iptables -A INPUT -i eth0 -j DROP            # 其它情况不允许\n            iptables -A INPUT -p tcp -s IP -j DROP       # 禁止指定IP访问\n            iptables -A INPUT -p tcp -s IP --dport port -j DROP               # 禁止指定IP访问端口\n            iptables -A INPUT -s IP -p tcp --dport port -j ACCEPT             # 允许在IP访问指定端口\n            iptables -A INPUT -p tcp --dport 22 -j DROP                       # 禁止使用某端口\n            iptables -A INPUT -i eth0 -p icmp -m icmp --icmp-type 8 -j DROP   # 禁止icmp端口\n            iptables -A INPUT -i eth0 -p icmp -j DROP                         # 禁止icmp端口\n            iptables -t filter -A INPUT -i eth0 -p tcp --syn -j DROP                  # 阻止所有没有经过你系统授权的TCP连接\n            iptables -A INPUT -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT   # IP包流量限制\n            iptables -A INPUT -i eth0 -s 192.168.62.1/32 -p icmp -m icmp --icmp-type 8 -j ACCEPT  # 除192.168.62.1外，禁止其它人ping我的主机\n            iptables -A INPUT -p tcp -m tcp --dport 80 -m state --state NEW -m recent --update --seconds 5 --hitcount 20 --rttl --name WEB --rsource -j DROP  # 可防御cc攻击(未测试)\n\n        }\n\n        iptables配置实例文件{\n\n            # Generated by iptables-save v1.2.11 on Fri Feb  9 12:10:37 2007\n            *filter\n            :INPUT ACCEPT [637:58967]\n            :FORWARD DROP [0:0]\n            :OUTPUT ACCEPT [5091:1301533]\n            # 允许的IP或IP段访问 建议多个\n            -A INPUT -s 127.0.0.1 -p tcp -j ACCEPT\n            -A INPUT -s 192.168.0.0/255.255.0.0 -p tcp -j ACCEPT\n            # 开放对外开放端口\n            -A INPUT -p tcp --dport 80 -j ACCEPT\n            # 指定某端口针对IP开放\n            -A INPUT -s 192.168.10.37 -p tcp --dport 22 -j ACCEPT\n            # 拒绝所有协议(INPUT允许)\n            -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,URG RST -j DROP\n            # 允许已建立的或相关连的通行\n            -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n            # 拒绝ping\n            -A INPUT -p tcp -m tcp -j REJECT --reject-with icmp-port-unreachable\n            COMMIT\n            # Completed on Fri Feb  9 12:10:37 2007\n\n        }\n\n        iptables配置实例{\n\n            # 允许某段IP访问任何端口\n            iptables -A INPUT -s 192.168.0.3/24 -p tcp -j ACCEPT\n            # 设定预设规则 (拒绝所有的数据包，再允许需要的,如只做WEB服务器.还是推荐三个链都是DROP)\n            iptables -P INPUT DROP\n            iptables -P FORWARD DROP\n            iptables -P OUTPUT ACCEPT\n            # 注意: 直接设置这三条会掉线\n            # 开启22端口\n            iptables -A INPUT -p tcp --dport 22 -j ACCEPT\n            # 如果OUTPUT 设置成DROP的，要写上下面一条\n            iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT\n            # 注:不写导致无法SSH.其他的端口一样,OUTPUT设置成DROP的话,也要添加一条链\n            # 如果开启了web服务器,OUTPUT设置成DROP的话,同样也要添加一条链\n            iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT\n            # 做WEB服务器,开启80端口 ,其他同理\n            iptables -A INPUT -p tcp --dport 80 -j ACCEPT\n            # 做邮件服务器,开启25,110端口\n            iptables -A INPUT -p tcp --dport 110 -j ACCEPT\n            iptables -A INPUT -p tcp --dport 25 -j ACCEPT\n            # 允许icmp包通过,允许ping\n            iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话)\n            iptables -A INPUT -p icmp -j ACCEPT  (INPUT设置成DROP的话)\n            # 允许loopback!(不然会导致DNS无法正常关闭等问题)\n            IPTABLES -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP)\n            IPTABLES -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP)\n\n        }\n\n        centos6的iptables基本配置{\n            *filter\n            :INPUT ACCEPT [0:0]\n            :FORWARD ACCEPT [0:0]\n            :OUTPUT ACCEPT [0:0]\n            -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n            -A INPUT -p icmp -j ACCEPT\n            -A INPUT -i lo -j ACCEPT\n            -A INPUT -s 222.186.135.61 -p tcp -j ACCEPT\n            -A INPUT -p tcp  --dport 80 -j ACCEPT\n            -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n            -A INPUT -j REJECT --reject-with icmp-host-prohibited\n            -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,URG RST -j DROP\n            -A FORWARD -j REJECT --reject-with icmp-host-prohibited\n            COMMIT\n        }\n\n        添加网段转发{\n\n            # 例如通过vpn上网\n            echo 1 > /proc/sys/net/ipv4/ip_forward       # 在内核里打开ip转发功能\n            iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE  # 添加网段转发\n            iptables -t nat -A POSTROUTING -s 10.0.0.0/255.0.0.0 -o eth0 -j SNAT --to 192.168.10.158  # 原IP网段经过哪个网卡IP出去\n            iptables -t nat -nL                # 查看转发\n\n        }\n\n        端口映射{\n\n            # 内网通过有外网IP的机器映射端口\n            # 内网主机添加路由\n            route add -net 10.10.20.0 netmask 255.255.255.0 gw 10.10.20.111     # 内网需要添加默认网关，并且网关开启转发\n            # 网关主机\n            echo 1 > /proc/sys/net/ipv4/ip_forward       # 在内核里打开ip转发功能\n            iptables -t nat -A PREROUTING -d 外网IP  -p tcp --dport 9999 -j DNAT --to 10.10.20.55:22    # 进入\n            iptables -t nat -A POSTROUTING -s 10.10.20.0/24 -j SNAT --to 外网IP                         # 转发回去\n            iptables -t nat -nL                # 查看转发\n\n        }\n\n    }\n\n}\n\n4 服务{\n\n    /etc/init.d/sendmail start                   # 启动服务\n    /etc/init.d/sendmail stop                    # 关闭服务\n    /etc/init.d/sendmail status                  # 查看服务当前状态\n    /date/mysql/bin/mysqld_safe --user=mysql &   # 启动mysql后台运行\n    /bin/systemctl restart  mysqld.service       # centos7启动服务\n    vi /etc/rc.d/rc.local                        # 开机启动执行  可用于开机启动脚本\n    /etc/rc.d/rc3.d/S55sshd                      # 开机启动和关机关闭服务连接    # S开机start  K关机stop  55级别 后跟服务名\n    ln -s -f /date/httpd/bin/apachectl /etc/rc.d/rc3.d/S15httpd   # 将启动程序脚本连接到开机启动目录\n    ipvsadm -ln                                  # lvs查看后端负载机并发\n    ipvsadm -C                                   # lvs清除规则\n    xm list                                      # 查看xen虚拟主机列表\n    virsh                                        # 虚拟化(xen\\kvm)管理工具  yum groupinstall Virtual*\n    ./bin/httpd -M                               # 查看httpd加载模块\n    httpd -t -D DUMP_MODULES                     # rpm包httpd查看加载模块\n    echo 内容| /bin/mail -s \"标题\" 收件箱 -f 发件人       # 发送邮件\n    \"`echo \"内容\"|iconv -f utf8 -t gbk`\" | /bin/mail -s \"`echo \"标题\"|iconv -f utf8 -t gbk`\" 收件箱     # 解决邮件乱码\n    /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg   # 检测nagios配置文件\n\n    chkconfig{\n\n        chkconfig service on|off|set             # 设置非独立服务启状态\n        chkconfig --level 35   httpd   off       # 让服务不自动启动\n        chkconfig --level 35   httpd   on        # 让服务自动启动 35指的是运行级别\n        chkconfig --list                         # 查看所有服务的启动状态\n        chkconfig --list |grep httpd             # 查看某个服务的启动状态\n        chkconfig –-list [service]               # 查看服务的状态\n\n    }\n\n    systemctl{\n\n        systemctl is-active *.service      # 查看服务是否运行\n        systemctl is-enabled *.service     # 查询服务是否开机启动\n        systemctl mask *.service           # 注销指定服务\n        systemctl unmask cups.service      # 取消注销cups服务\n        systemctl enable *.service         # 开机运行服务\n        systemctl disable *.service        # 取消开机运行\n        systemctl start *.service          # 启动服务\n        systemctl stop *.service           # 停止服务\n        systemctl restart *.service        # 重启服务\n        systemctl reload *.service         # 重新加载服务配置文件\n        systemctl status *.service         # 查询服务运行状态\n        systemctl --failed                 # 显示启动失败的服务\n        systemctl poweroff                 # 系统关机\n        systemctl reboot                   # 重新启动\n        systemctl rescue                   # 强制进入救援模式\n        systemctl emergency                # 强制进入紧急救援模式\n        systemctl list-dependencies        # 查看当前运行级别target(mult-user)启动了哪些服务\n        systemctl list-unit-files          # 查看开机启动的状态\n        journalctl -r -u elasticsearch.service  # 查看日志 r倒序 u服务名\n        /etc/systemd/system/falcon-agent.service\n            [Unit]\n            Description=This is zuiyou monitor agent\n            After=network.target remote-fs.target nss-lookup.target\n\n            [Service]\n            User= root\n            Type=simple\n            PIDFile=/opt/falcon-agent/var/app.pid\n            ExecStartPre=/usr/bin/rm -f /opt/falcon-agent/var/app.pid\n            ExecStart=/opt/falcon-agent/control start\n            ExecReload=/bin/kill -s HUP $MAINPID\n            KillMode=process\n            KillSignal=SIGQUIT\n            TimeoutStopSec=5\n            PrivateTmp=true\n            Restart=always\n            LimitNOFILE=infinity\n\n            [Install]\n            WantedBy=multi-user.target\n\n        systemctl daemon-reload           # 加载配置\n\n    }\n\n\n    nginx{\n\n        yum install -y make gcc  openssl-devel pcre-devel  bzip2-devel libxml2 libxml2-devel curl-devel libmcrypt-devel libjpeg libjpeg-devel libpng libpng-devel openssl\n\n        groupadd nginx\n        useradd nginx -g nginx -M -s /sbin/nologin\n\n        mkdir -p /opt/nginx-tmp\n\n        wget http://labs.frickle.com/files/ngx_cache_purge-1.6.tar.gz\n        tar fxz ngx_cache_purge-1.6.tar.gz\n        # ngx_cache_purge 清除指定url缓存\n        # 假设一个URL为 http://192.168.12.133/test.txt\n        # 通过访问      http://192.168.12.133/purge/test.txt  就可以清除该URL的缓存。\n\n        tar zxvpf nginx-1.4.4.tar.gz\n        cd nginx-1.4.4\n\n        # ./configure --help\n        # --with                 # 默认不加载 需指定编译此参数才使用\n        # --without              # 默认加载，可用此参数禁用\n        # --add-module=path      # 添加模块的路径\n        # --add-module=/opt/ngx_module_upstream_check \\         # nginx 代理状态页面\n        # ngx_module_upstream_check  编译前需要打对应版本补丁 patch -p1 < /opt/nginx_upstream_check_module/check_1.2.6+.patch\n        # --add-module=/opt/ngx_module_memc \\                   # 将请求页面数据存放在 memcached中\n        # --add-module=/opt/ngx_module_lua \\                    # 支持lua脚本 yum install lua-devel lua\n\n        ./configure \\\n        --user=nginx \\\n        --group=nginx \\\n        --prefix=/usr/local/nginx \\\n        --with-http_ssl_module \\\n        --with-http_realip_module \\\n        --with-http_gzip_static_module \\\n        --with-http_stub_status_module \\\n        --add-module=/opt/ngx_cache_purge-1.6 \\\n        --http-client-body-temp-path=/opt/nginx-tmp/client \\\n        --http-proxy-temp-path=/opt/nginx-tmp/proxy \\\n        --http-fastcgi-temp-path=/opt/nginx-tmp/fastcgi \\\n        --http-uwsgi-temp-path=/opt/nginx-tmp/uwsgi \\\n        --http-scgi-temp-path=/opt/nginx-tmp/scgi\n\n        make && make install\n\n        /usr/local/nginx/sbin/nginx –t             # 检查Nginx配置文件 但并不执行\n        /usr/local/nginx/sbin/nginx -t -c /opt/nginx/conf/nginx.conf  # 检查Nginx配置文件\n        /usr/local/nginx/sbin/nginx                # 启动nginx\n        /usr/local/nginx/sbin/nginx -s reload      # 重载配置\n        /usr/local/nginx/sbin/nginx -s stop        # 关闭nginx服务\n\n    }\n\n    elasticsearch{\n\n        vim /etc/sysctl.conf\n        vm.max_map_count = 262144\n\n        vim /etc/security/limits.conf\n        * soft memlock unlimited\n        * hard memlock unlimited\n        sysctl -p\n\n        curl 'localhost:9200/_cat/health?v'                    # 健康检查\n        curl 'localhost:9200/_cat/nodes?v'                     # 获取集群的节点列表\n        curl 'localhost:9200/_cat/indices?v'                   # 列出所有索引\n        curl 127.0.0.1:9200/indexname -XDELETE                 # 删除索引\n        curl -XGET http://localhost:9200/_cat/shards           # 查看分片\n        curl '127.0.0.1:9200/_cat/indices'                     # 查分片同步  unassigned_shards  # 没同步完成\n\n    }\n\n\n    mysql常用命令{\n\n        # mysql 可视化工具 MySQL Workbench\n\n        mysqlcheck -uroot -p -S mysql.sock --optimize --databases account       # 检查、修复、优化MyISAM表\n        mysqlbinlog slave-relay-bin.000001              # 查看二进制日志\n        mysqladmin -h myhost -u root -p create dbname   # 创建数据库\n\n        flush privileges;             # 刷新\n        show databases;               # 显示所有数据库\n        use dbname;                   # 打开数据库\n        show tables;                  # 显示选中数据库中所有的表\n        desc tables;                  # 查看表结构\n        drop database name;           # 删除数据库\n        drop table name;              # 删除表\n        create database name;         # 创建数据库\n        select column from table;     # 查询\n        show processlist;             # 查看mysql进程\n        show full processlist;        # 显示进程全的语句\n        select user();                # 查看所有用户\n        show slave status\\G;          # 查看主从状态\n        show variables;               # 查看所有参数变量\n        show status;                  # 运行状态\n        show table status             # 查看表的引擎状态\n        show grants for user@'%'                                    # 查看用户权限\n        drop table if exists user                                   # 表存在就删除\n        create table if not exists user                             # 表不存在就创建\n        select host,user,password from user;                        # 查询用户权限 先use mysql\n        create table ka(ka_id varchar(6),qianshu int);              # 创建表\n        show variables like 'character_set_%';                      # 查看系统的字符集和排序方式的设定\n        show variables like '%timeout%';                            # 查看超时相关参数\n        delete from user where user='';                             # 删除空用户\n        delete from user where user='sss' and host='localhost' ;    # 删除用户\n        drop user 'sss'@'localhost';                                # 使用此方法删除用户更为靠谱\n        ALTER TABLE mytable ENGINE = MyISAM ;                       # 改变现有的表使用的存储引擎\n        SHOW TABLE STATUS from  dbname  where Name='tablename';     # 查询表引擎\n        mysql -uroot -p -A -ss -h10.10.10.5 -e \"show databases;\"    # shell中获取数据不带表格 -ss参数\n        CREATE TABLE innodb (id int, title char(20)) ENGINE = INNODB                     # 创建表指定存储引擎的类型(MyISAM或INNODB)\n        grant replication slave on *.* to 'user'@'%' identified by 'pwd';                # 创建主从复制用户\n        ALTER TABLE player ADD INDEX weekcredit_faction_index (weekcredit, faction);     # 添加索引\n        alter table name add column accountid(column)  int(11) NOT NULL(column);         # 插入字段\n        update host set monitor_state='Y',hostname='xuesong' where ip='192.168.1.1';     # 更新数据\n        select * from information_schema.processlist where command!='sleep';             # 查看当前进程\n        select * from atable where name='on' AND t<15 AND host LIKE '10%' limit 1,10;    # 多条件查询\n        show create database ops_deploy;                                                 # 查看数据库编码\n        show create table updatelog;                                                     # 查看数据库表编码\n        alter database ops_deploy CHARACTER SET utf8;                                    # 修改数据库编码\n        alter table `updatelog` default character set utf8;                              # 修改表编码\n        alter table `updatelog` convert to character set utf8;                           # 修改一张表的所有字段的编码格式\n\n        自增表{\n\n            create table xuesong  (id INTEGER  PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NOT NULL, age integer , sex CHAR(15) );  # 创建自增表\n            insert into xuesong(name,age,sex) values(%s,%s,%s)  # 自增插入数据\n\n        }\n\n        登录mysql的命令{\n\n            # 格式： mysql -h 主机地址 -u 用户名 -p 用户密码\n            mysql -h110.110.110.110 -P3306 -uroot -p\n            mysql -uroot -p -S /data1/mysql5/data/mysql.sock -A  --default-character-set=GBK\n\n        }\n\n        shell执行mysql命令{\n\n            mysql -u root -p'123' xuesong < file.sql   # 针对指定库执行sql文件中的语句,好处不需要转义特殊符号,一条语句可以换行.不指定库执行时语句中需要先use\n            mysql -u$username -p$passwd -h$dbhost -P$dbport -A -e \"\n            use $dbname;\n            delete from data where date=('$date1');\n            \"    # 执行多条mysql命令\n            mysql -uroot -p -S mysql.sock -e \"use db;alter table gift add column accountid  int(11) NOT NULL;flush privileges;\"  2>&1 |grep -v Warning    # 不登陆mysql插入字段\n\n        }\n\n\n        mysql字符集相关{\n\n            show variables like '%character%';      # 查看数据库中设置字符集的参数\n            # character_set_client、character_set_connection 以及 character_set_results 这几个参数都是客户端的设置\n            # character_set_system、character_set_server 以及 character_set_database 是指服务器端的设置。\n            # 而对于这三个服务器端的参数来说的优先级是:\n            # 列级字符集 > 表级字符集 > character_set_database > character_set_server > character_set_system\n\n            show global variables like '%char%';                                 #查看RDS实例字符集相关参数设置\n            show global variables like 'coll%';                                  #查看当前会话字符序相关参数设置\n            show character set;                                                  #查看实例支持的字符集\n            show collation;                                                      #查看实例支持的字符序\n            show create table table_name \\G                                      #查看表字符集设置\n            show create database database_name \\G                                #查看数据库字符集设置\n            show create procedure procedure_name \\G                              #查看存储过程字符集设置\n            show procedure status \\G                                             #查看存储过程字符集设置\n            alter database db_name default charset utf8;                         #修改数据库的字符集 \n            create database db_name character set utf8;                          #创建数据库时指定字符集\n            alter table tab_name default charset utf8 collate utf8_general_ci;   #修改表字符集和字符序\n\n            # 下面三条sql 分别将库 dbsdq , 表 tt2 , 表 tt2 中的 c2 列修改为utf8mb4 字符集\n            alter database dbsdq character set utf8mb4 collate utf8mb4_unicode_ci;\n            use dbsdq;\n            alter table tt2 character set utf8mb4 collate utf8mb4_unicode_ci;\n            alter table tt2 modify c2  varchar(10) character set utf8mb4;\n            # 修改列时,当前列中的所有行都会立即转化为新的字符集;\n            # alter table 会对表加元数据锁\n\n        }\n\n        备份数据库{\n\n            mysqldump -h host -u root -p --default-character-set=utf8 dbname >dbname_backup.sql               # 不包括库名，还原需先创建库，在use\n            mysqldump -h host -u root -p --database --default-character-set=utf8 dbname >dbname_backup.sql    # 包括库名，还原不需要创建库\n            /bin/mysqlhotcopy -u root -p    # mysqlhotcopy只能备份MyISAM引擎\n            mysqldump -u root -p -S mysql.sock --default-character-set=utf8 dbname table1 table2  > /data/db.sql    # 备份表\n            mysqldump -uroot -p123  -d database > database.sql    # 备份数据库结构\n\n            # 最小权限备份\n            grant select on db_name.* to dbbackup@\"localhost\" Identified by \"passwd\";\n            # --single-transaction  InnoDB有时间戳 只备份开始那一刻的数据,备份过程中的数据不会备份\n            mysqldump -hlocalhost -P 3306 -u dbbackup --single-transaction  -p\"passwd\" --database dbname >dbname.sql\n\n            # xtrabackup备份需单独安装软件 优点: 速度快,压力小,可直接恢复主从复制\n            innobackupex --user=root --password=\"\" --defaults-file=/data/mysql5/data/my_3306.cnf --socket=/data/mysql5/data/mysql.sock --slave-info --stream=tar --tmpdir=/data/dbbackup/temp /data/dbbackup/ 2>/data/dbbackup/dbbackup.log | gzip 1>/data/dbbackup/db50.tar.gz\n\n        }\n\n        还原数据库{\n\n            mysql -h host -u root -p dbname < dbname_backup.sql\n            source 路径.sql   # 登陆mysql后还原sql文件\n\n        }\n\n        赋权限{\n\n            # 指定IP: $IP  本机: localhost   所有IP地址: %   # 通常指定多条\n            grant all on zabbix.* to user@\"$IP\";             # 对现有账号赋予权限\n            grant select on database.* to user@\"%\" Identified by \"passwd\";     # 赋予查询权限(没有用户，直接创建)\n            grant all privileges on database.* to user@\"$IP\" identified by 'passwd';         # 赋予指定IP指定用户所有权限(不允许对当前库给其他用户赋权限)\n            grant all privileges on database.* to user@\"localhost\" identified by 'passwd' with grant option;   # 赋予本机指定用户所有权限(允许对当前库给其他用户赋权限)\n            grant select, insert, update, delete on database.* to user@'ip'identified by \"passwd\";   # 开放管理操作指令\n            revoke all on *.* from user@localhost;     # 回收权限\n            GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, EXECUTE, CREATE ROUTINE, ALTER ROUTINE ON `storemisc_dev`.* TO 'user'@'192.168.%'\n\n        }\n\n        更改密码{\n\n            update user set password=password('passwd') where user='root'\n            mysqladmin -u root password 'xuesong'\n\n        }\n\n        mysql忘记密码后重置{\n\n            cd /data/mysql5\n            /data/mysql5/bin/mysqld_safe --user=mysql --skip-grant-tables --skip-networking &\n            use mysql;\n            update user set password=password('123123') where user='root';\n\n        }\n\n        mysql主从复制失败恢复{\n\n            slave stop;\n            reset slave;\n            change master to master_host='10.10.10.110',master_port=3306,master_user='repl',master_password='repl',master_log_file='master-bin.000010',master_log_pos=107,master_connect_retry=60;\n            slave start;\n\n        }\n\n        sql语句使用变量{\n\n            use xuesong;\n            set @a=concat('my',weekday(curdate()));    # 组合时间变量\n            set @sql := concat('CREATE TABLE IF NOT EXISTS ',@a,'( id INT(11) NOT NULL )');   # 组合sql语句\n            select @sql;                    # 查看语句\n            prepare create_tb from @sql;    # 准备\n            execute create_tb;              # 执行\n\n        }\n\n        检测mysql主从复制延迟{\n\n            1、在从库定时执行更新主库中的一个timeout数值\n            2、同时取出从库中的timeout值对比判断从库与主库的延迟\n\n        }\n\n        死锁{\n\n            show OPEN TABLES where In_use > 0;                  # 查看当前锁信息\n            show variables like 'innodb_print_all_deadlocks';   # 查看当前死锁参数\n            set global innodb_print_all_deadlocks = 1;          # 设置死锁信息保存到错误日志\n            innodb_print_all_deadlocks = 1                      # conf配置\n\n        }\n\n        mysql慢查询{\n\n            select * from information_schema.processlist where command in ('Query') and time >5\\G      # 查询操作大于5S的进程\n\n            开启慢查询日志{\n\n                # 配置文件 /etc/my.conf\n                [mysqld]\n                log-slow-queries=/var/lib/mysql/slowquery.log         # 指定日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log\n                long_query_time=5                                     # 记录超过的时间，默认为10s 建议0.5S\n                log-queries-not-using-indexes                         # log下来没有使用索引的query,可以根据情况决定是否开启  可不加\n                log-long-format                                       # 如果设置了，所有没有使用索引的查询也将被记录    可不加\n                # 直接修改生效\n                show variables like \"%slow%\";                         # 查看慢查询状态\n                set global slow_query_log='ON';                       # 开启慢查询日志 变量可能不同，看上句查询出来的变量\n\n            }\n\n            mysqldumpslow慢查询日志查看{\n\n                -s  # 是order的顺序，包括看了代码，主要有 c,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒序\n                -t  # 是top n的意思，即为返回前面多少条的数据\n                -g  # 后边可以写一个正则匹配模式，大小写不敏感的\n\n                mysqldumpslow -s c -t 20 host-slow.log                # 访问次数最多的20个sql语句\n                mysqldumpslow -s r -t 20 host-slow.log                # 返回记录集最多的20个sql\n                mysqldumpslow -t 10 -s t -g \"left join\" host-slow.log # 按照时间返回前10条里面含有左连接的sql语句\n\n                show global status like '%slow%';                     # 查看现在这个session有多少个慢查询\n                show variables like '%slow%';                         # 查看慢查询日志是否开启，如果slow_query_log和log_slow_queries显示为on，说明服务器的慢查询日志已经开启\n                show variables like '%long%';                         # 查看超时阀值\n                desc select * from wei where text='xishizhaohua'\\G;   # 扫描整张表 tepe:ALL  没有使用索引 key:NULL\n                create index text_index on wei(text);                 # 创建索引\n\n            }\n\n            Percona Toolkit 慢日志分析工具\n\n        }\n\n        mysql操作次数查询{\n\n            select * from information_schema.global_status;\n\n            com_select\n            com_delete\n            com_insert\n            com_update\n\n        }\n\n    }\n\n    mongodb{\n\n        # mongo可视管理工具 studio 3t  \n\n        一、启动{\n\n            # 不启动认证\n            ./mongod --port 27017 --fork --logpath=/opt/mongodb/mongodb.log --logappend --dbpath=/opt/mongodb/data/\n            # 启动认证\n            ./mongod --port 27017 --fork --logpath=/opt/mongodb/mongodb.log --logappend --dbpath=/opt/mongodb/data/ --auth\n\n            # 配置文件方式启动\n            cat /opt/mongodb/mongodb.conf\n              port=27017                       # 端口号\n              fork=true                        # 以守护进程的方式运行，创建服务器进程\n              auth=true                        # 开启用户认证\n              logappend=true                   # 日志采用追加方式\n              logpath=/opt/mongodb/mongodb.log # 日志输出文件路径\n              dbpath=/opt/mongodb/data/        # 数据库路径\n              shardsvr=true                    # 设置是否分片\n              maxConns=600                     # 数据库的最大连接数\n            ./mongod -f /opt/mongodb/mongodb.conf\n\n            # 其他参数\n            bind_ip         # 绑定IP  使用mongo登录需要指定对应IP\n            journal         # 开启日志功能,降低单机故障的恢复时间,取代dur参数\n            syncdelay       # 系统同步刷新磁盘的时间,默认60秒\n            directoryperdb  # 每个db单独存放目录,建议设置.与mysql独立表空间类似\n            repairpath      # 执行repair时的临时目录.如果没开启journal,出现异常重启,必须执行repair操作\n            # mongodb没有参数设置内存大小.使用os mmap机制缓存数据文件,在数据量不超过内存的情况下,效率非常高.数据量超过系统可用内存会影响写入性能\n\n        }\n\n        二、关闭{\n\n            # 方法一:登录mongodb\n            ./mongo\n            use admin\n            db.shutdownServer()\n\n            # 方法:kill传递信号  两种皆可\n            kill -2 pid\n            kill -15 pid\n\n        }\n\n        三、开启认证与用户管理{\n\n            ./mongo                      # 先登录\n            use admin                    # 切换到admin库\n            db.addUser(\"root\",\"123456\")                     # 创建用户\n            db.addUser('zhansan','pass',true)               # 如果用户的readOnly为true那么这个用户只能读取数据，添加一个readOnly用户zhansan\n            ./mongo 127.0.0.1:27017/mydb -uroot -p123456    # 再次登录,只能针对用户所在库登录\n            #虽然是超级管理员，但是admin不能直接登录其他数据库，否则报错\n            #Fri Nov 22 15:03:21.886 Error: 18 { code: 18, ok: 0.0, errmsg: \"auth fails\" } at src/mongo/shell/db.js:228\n            show collections                                # 查看链接状态 再次登录使用如下命令,显示错误未经授权\n            db.system.users.find();                         # 查看创建用户信息\n            db.system.users.remove({user:\"zhansan\"})        # 删除用户\n\n            #恢复密码只需要重启mongodb 不加--auth参数\n\n        }\n\n        四、登录{\n\n            192.168.1.5:28017      # http登录后可查看状态\n            mongo                  # 默认登录后打开 test 库\n            mongo 192.168.1.5:27017/databaseName      # 直接连接某个库 不存在则创建  启动认证需要指定对应库才可登录\n\n        }\n\n        五、查看状态{\n\n            #登录后执行命令查看状态\n            db.runCommand({\"serverStatus\":1})\n                globalLock         # 表示全局写入锁占用了服务器多少时间(微秒)\n                mem                # 包含服务器内存映射了多少数据,服务器进程的虚拟内存和常驻内存的占用情况(MB)\n                indexCounters      # 表示B树在磁盘检索(misses)和内存检索(hits)的次数.如果这两个比值开始上升,就要考虑添加内存了\n                backgroudFlushing  # 表示后台做了多少次fsync以及用了多少时间\n                opcounters         # 包含每种主要擦撞的次数\n                asserts            # 统计了断言的次数\n\n            #状态信息从服务器启动开始计算,如果过大就会复位,发送复位，所有计数都会复位,asserts中的roolovers值增加\n\n            #mongodb自带的命令\n            ./mongostat\n                insert     #每秒插入量\n                query      #每秒查询量\n                update     #每秒更新量\n                delete     #每秒删除量\n                locked     #锁定量\n                qr|qw      #客户端查询排队长度(读|写)\n                ar|aw      #活跃客户端量(读|写)\n                conn       #连接数\n                time       #当前时间\n\n            mongostat -h 127.0.0.1 --port 27047 --authenticationDatabase admin -u zadmin -p Keaphh9e    # 查看mongo状态\n            mongotop  -h 127.0.0.1 --port 27047 --authenticationDatabase admin -u zadmin -p Keaphh9e    # 查看mongo集合的统计数据\n\n        }\n\n        六、常用命令{\n\n            db.listCommands()     # 当前MongoDB支持的所有命令（同样可通过运行命令db.runCommand({\"listCommands\" : `1})来查询所有命令）\n\n            db.runCommand({\"buildInfo\" : 1})                                  # 返回MongoDB服务器的版本号和服务器OS的相关信息\n            db.runCommand({\"collStats\" : tablename})                          # 返回该集合的统计信息，包括数据大小，已分配存储空间大小，索引的大小等\n            db.runCommand({\"dropDatabase\" : 1})                               # 清空当前数据库的信息，包括删除所有的集合和索引\n            db.runCommand({\"isMaster\" : 1})                                   # 检查本服务器是主服务器还是从服务器\n            db.runCommand({\"ping\" : 1})                                       # 检查服务器链接是否正常。即便服务器上锁，该命令也会立即返回\n            db.runCommand({\"repaireDatabase\" : 1})                            # 对当前数据库进行修复并压缩，如果数据库特别大，这个命令会非常耗时\n            db.runCommand({\"serverStatus\" : 1})                               # 查看这台服务器的管理统计信息\n            # 某些命令必须在admin数据库下运行，如下两个命令：\n            db.runCommand({\"renameCollection\" : 集合名, \"to\"：集合名})          # 对集合重命名，注意两个集合名都要是完整的集合命名空间，如foo.bar, 表示数据库foo下的集合bar。\n            db.runCommand({\"listDatabases\" : 1})                              # 列出服务器上所有的数据库\n\n            mongo  172.20.20.1:27072/mdb --eval \"db.tb.count();\"              # shell执行mongo语句\n            mongo --host  172.20.20.1 --port 27049\n\n            rs.config();                                                      # 查看集群配置\n            rs.status();                                                      # 查看集群节点的状态\n            db.currentOp()                                                    # 获取当前正在执行的操作,可对应命令链接到ip:port\n            db.runCommand( { logRotate : 1 } )                                # 日志轮转\n            rs.slaveOk()                                                      # 设置从库shell可读\n            rs.addArb(\"172.16.10.199:27020\");                                 # 添加仲裁节点\n            rs.add({host: \"10.2.2.2:27047\", priority: 0, hidden: true})       # 添加从节点 hidden true隐藏节点[priority必须为0]  false不隐藏\n            rs.remove(\"172.20.80.216:27047\");                                 # 删除节点\n            rs.stepDown(120)                                                  # 主库上执行切换为从,120秒后切换回主\n            show dbs                                                          # 查询db\n            use post                                                          # 选择db\n            show tables                                                       # 查看文档列表\n            db.tb.drop()                                                      # 删除集合 需要权限\n            db.tb.remove({})                                                  # 删除所有数据\n            db.tb.count()                                                     # 查询文档条数\n            db.tb.find()                                                      # 查看文档内容\n            db.tb.find({_id:37530555})                                        # 查询指定id\n            db.tb.find().sort({_id:-1}).limit(1)                              # 查询文档最后一条\n            db.tb.find({\"processed\" : {\"$ne\" : true}}).limit(1);              # 字段不为 true\n            db.tb.find({\"processed\" : {\"$eq\" : true}}).limit(1);              # 字段为 true\n            db.tb.find({\"processed\" : {\"$exists\" : false}}).limit(1);         # 字段不存在\n\n            db.tb.ensureIndex({\"status\":1}, {background:true})                # 后台加索引\n            db.tb.getIndexes()                                                # 查看索引\n            db.tb.ensureIndex({\"c_type\":1},{backgrounnd:true})                # 后台添加索引  1正向  -1反向\n            db.tb.dropIndex({\"c_type\":1});                                    # 删除索引\n\n        }\n\n        七、进程控制{\n\n            db.currentOp()                  # 查看活动进程\n            db.$cmd.sys.inprog.findOne()    # 查看活动进程 与上面一样\n                opid      # 操作进程号\n                op        # 操作类型(查询\\更新)\n                ns        # 命名空间,指操作的是哪个对象\n                query     # 如果操作类型是查询,这里将显示具体的查询内容\n                lockType  # 锁的类型,指明是读锁还是写锁\n\n            db.killOp(opid值)                         # 结束进程\n            db.$cmd.sys.killop.findOne({op:opid值})   # 结束进程\n\n        }\n\n        八、备份还原{\n            # mongodump 虽然能不停机备份,但是为了获取实时数据视图的能力,使用fsync命令能在运行时复制数据目录并且不会损坏数据\n            # fsync会强制服务器将所有缓冲区的数据写入磁盘.配合lock还阻止对数据库的进一步写入,知道释放锁为止\n            db.runCommand({\"fsync\":1,\"lock\":1})   # 执行强制更新与写入锁\n            db.$cmd.sys.unlock.findOne()          # 解锁\n            db.currentOp()                        # 查看解锁是否正常\n\n            mongoexport -d test -c t1 -o t1.dat                 # 导出JSON格式\n                -c         # 指明导出集合\n                -d         # 使用库\n            mongoexport -d test -c t1 -csv -f num -o t1.dat     # 导出csv格式\n                -csv       # 指明导出csv格式\n                -f         # 指明需要导出那些例\n\n            mongoimport -d test -c t1 -file t1.dat                           # mongoimport还原JSON格式\n            mongoimport -d test -c t1 -type csv --headerline -file t1.dat    # mongoimport还原csv格式数据\n                --headerline                # 指明不导入第一行 因为第一行是列名\n\n            mongodump -d test -o /bak/mongodump                # mongodump数据备份\n            mongorestore -d test --drop /bak/mongodump/*       # mongorestore恢复\n                --drop      # 恢复前先删除\n                --gzip      # 压缩\n\n            # 备份一个表\n            # --excludeCollection string # 排除指定的集合 要排除多个，使用多个\n            mongodump --host 127.0.0.1:27080 -d dbname  -c tablename  -o /data/reports/\n            mongodump --host 127.0.0.1:27080 -d dbname  -c tablename  -o /data/reports/reports  -u root -p tAvaa5yNUE --authenticationDatabase admin\n\n            # 恢复一个表\n            mongorestore --host 127.0.0.1:27080 -d dbname  -c tablename --drop --dir=/data/reports/tablename.bson\n\n            # 在线拷贝一个库\n            db.copyDatabase(fromdb, todb, fromhost, username, password, mechanism)\n            db.copyDatabase('mate','mate', '172.16.255.176:27047')\n\n        }\n\n        九、修复{\n\n            # 当停电或其他故障引起不正常关闭时,会造成部分数据损坏丢失\n            mongod --repair      # 修复操作:启动时候加上 --repair\n            # 修复过程:将所有文档导出,然后马上导入,忽略无效文档.完成后重建索引。时间较长,会丢弃损坏文档\n            # 修复数据还能起到压缩数据库的作用\n            db.repairDatabase()    # 运行中的mongodb可使用 repairDatabase 修复当前使用的数据库\n            {\"repairDatabase\":1}   # 通过驱动程序\n\n        }\n\n        十、python使用mongodb{\n\n            原文: http://blog.nosqlfan.com/html/2989.html\n\n            easy_install pymongo      # python2.7+\n            import pymongo\n            connection=pymongo.Connection('localhost',27017)   # 创建连接\n            db = connection.test_database                      # 切换数据库\n            collection = db.test_collection                    # 获取collection\n            # db和collection都是延时创建的，在添加Document时才真正创建\n\n            文档添加, _id自动创建\n                import datetime\n                post = {\"author\": \"Mike\",\n                    \"text\": \"My first blog post!\",\n                    \"tags\": [\"mongodb\", \"python\", \"pymongo\"],\n                    \"date\": datetime.datetime.utcnow()}\n                posts = db.posts\n                posts.insert(post)\n                ObjectId('...')\n\n            批量插入\n                new_posts = [{\"author\": \"Mike\",\n                    \"text\": \"Another post!\",\n                    \"tags\": [\"bulk\", \"insert\"],\n                    \"date\": datetime.datetime(2009, 11, 12, 11, 14)},\n                    {\"author\": \"Eliot\",\n                    \"title\": \"MongoDB is fun\",\n                    \"text\": \"and pretty easy too!\",\n                    \"date\": datetime.datetime(2009, 11, 10, 10, 45)}]\n                posts.insert(new_posts)\n                [ObjectId('...'), ObjectId('...')]\n\n            获取所有collection\n                db.collection_names()    # 相当于SQL的show tables\n\n            获取单个文档\n                posts.find_one()\n\n            查询多个文档\n                for post in posts.find():\n                    post\n\n            加条件的查询\n                posts.find_one({\"author\": \"Mike\"})\n\n            高级查询\n                posts.find({\"date\": {\"$lt\": \"d\"}}).sort(\"author\")\n\n            统计数量\n                posts.count()\n\n            加索引\n                from pymongo import ASCENDING, DESCENDING\n                posts.create_index([(\"date\", DESCENDING), (\"author\", ASCENDING)])\n\n            查看查询语句的性能\n                posts.find({\"date\": {\"$lt\": \"d\"}}).sort(\"author\").explain()[\"cursor\"]\n                posts.find({\"date\": {\"$lt\": \"d\"}}).sort(\"author\").explain()[\"nscanned\"]\n\n        }\n\n    }\n\n    JDK安装{\n\n        vim /etc/profile.d/jdk.sh\n        export JAVA_HOME=/usr/local/jdk1.8.0_151\n        export PATH=$JAVA_HOME/bin:$PATH\n\n        . /etc/profile         # 加载新的环境变量\n        jps -ml                # 查看java进程\n        jstat -gc 18381 1s 30  # 查看java进程gc情况\n    }\n\n    redis动态加内存{\n\n        ./redis-cli -h 10.10.10.11 -p 6401\n        save                                # 保存当前快照\n        config get *                        # 列出所有当前配置\n        config get maxmemory                # 查看指定配置\n        config set maxmemory  15360000000   # 动态修改最大内存配置参数\n\n    }\n\n    nfs{\n\n        # 依赖rpc服务通信 portmap[centos5] 或 rpcbind[centos6]\n        yum install nfs-utils portmap    # centos5安装\n        yum install nfs-utils rpcbind    # centos6安装\n\n        vim /etc/exports                 # 配置文件\n        # sync                           # 同步写入\n        # async                          # 暂存并非直接写入\n        # no_root_squash                 # 开放用户端使用root身份操作\n        # root_squash                    # 使用者身份为root则被压缩成匿名使用,即nobody,相对安全\n        # all_squash                     # 所有NFS的使用者身份都被压缩为匿名\n        /data/images 10.10.10.0/24(rw,sync,no_root_squash)\n\n        service  portmap restart         # 重启centos5的nfs依赖的rpc服务\n        service  rpcbind restart         # 重启centos6的nfs依赖的rpc服务\n        service  nfs restart             # 重启nfs服务  确保依赖 portmap 或 rpcbind 服务已启动\n        service  nfs reload              # 重载NFS服务配置文件\n        showmount -e                     # 服务端查看自己共享的服务\n        showmount -a                     # 显示已经与客户端连接上的目录信息\n        showmount -e 10.10.10.3          # 列出服务端可供使用的NFS共享  客户端测试能否访问nfs服务\n        mount -t nfs 10.10.10.3:/data/images/  /data/img   # 挂载nfs  如果延迟影响大加参数 noac\n\n        # 服务端的 portmap 或 rpcbind 被停止后，nfs仍然工作正常，但是umout财会提示： not found / mounted or server not reachable  重启服务器的portmap 或 rpcbind 也无济于事。 nfs也要跟着重启，否则nfs工作仍然是不正常的。\n        # 同时已挂载会造成NFS客户端df卡住和挂载目录无法访问。请先用 mount 查看当前挂载情况，记录挂载信息，在强制卸载挂载目录，重新挂载\n        umount -f /data/img/             # 强制卸载挂载目录  如还不可以  umount -l /data/img/\n\n        nfsstat -c                       # 客户机发送和拒绝的RPC和NFS调用数目的信息\n        nfsstat -cn                      # 显示和打印与客户机NFS调用相关的信息\n        nfsstat -r                       # 显示和打印客户机和服务器的与RPC调用相关的信息\n        nfsstat –s                       # 显示关于服务器接收和拒绝的RPC和NFS调用数目的信息\n\n    }\n\n    hdfs{\n        hdfs --help                  # 所有参数\n\n        hdfs dfs -help               # 运行文件系统命令在Hadoop文件系统\n        hdfs dfs -ls /logs           # 查看\n        hdfs dfs -ls /user/          # 查看用户\n        hdfs dfs -cat\n        hdfs dfs -df\n        hdfs dfs -du\n        hdfs dfs -rm\n        hdfs dfs -tail\n        hdfs dfs –put localSrc dest  # 上传文件\n\n        hdfs dfsadmin -help          # hdfs集群节点管理\n        hdfs dfsadmin -report        # 基本的文件系统统计信息\n    }\n\n}\n\n5 网络{\n\n    rz                                                                    # 通过ssh上传小文件\n    sz                                                                    # 通过ssh下载小文件\n    ifconfig eth0 down                                                    # 禁用网卡\n    ifconfig eth0 up                                                      # 启用网卡\n    ifup eth0:0                                                           # 启用网卡\n    mii-tool em1                                                          # 查看网线是否连接\n    traceroute www.baidu.com                                              # 测试跳数\n    vi /etc/resolv.conf                                                   # 设置DNS  nameserver IP 定义DNS服务器的IP地址\n    nslookup www.moon.com                                                 # 解析域名IP\n    dig -x www.baidu.com                                                  # 解析域名IP\n    dig +trace -t A domainname                                            # 跟踪dns\n    dig +short txt hacker.wp.dg.cx                                        # 通过 DNS 来读取 Wikipedia 的hacker词条\n    host -t txt hacker.wp.dg.cx                                           # 通过 DNS 来读取 Wikipedia 的hacker词条\n    lynx                                                                  # 文本上网\n    wget -P path -O name url                                              # 下载  包名:wgetrc   -q 安静 -c 续传\n    dhclient eth1                                                         # 自动获取IP\n    mtr -r www.baidu.com                                                  # 测试网络链路节点响应时间 # trace ping 结合\n    ipcalc -m \"$ip\" -p \"$num\"                                             # 根据IP和主机最大数计算掩码\n    curl -I www.baidu.com                                                 # 查看网页http头\n    curl -s www.baidu.com                                                 # 不显示进度\n    queryperf -d list -s DNS_IP -l 2                                      # BIND自带DNS压力测试  [list 文件格式:www.turku.fi A]\n    telnet ip port                                                        # 测试端口是否开放,有些服务可直接输入命令得到返回状态\n    echo \"show \" |nc $ip $port                                            # 适用于telnet一类登录得到命令返回\n    nc -l -p port                                                         # 监听指定端口\n    nc -nv -z 10.10.10.11 1080 |grep succeeded                            # 检查主机端口是否开放\n    curl -o /dev/null -s -m 10 --connect-timeout 10 -w %{http_code} $URL  # 检查页面状态\n    curl -X POST -d \"user=xuesong&pwd=123\" http://www.abc.cn/Result       # 提交POST请求\n    curl -s http://20140507.ip138.com/ic.asp                              # 通过IP138取本机出口外网IP\n    curl http://IP/ -H \"X-Forwarded-For: ip\" -H \"Host: www.ttlsa.com\"     # 连到指定IP的响应主机,HTTPserver只看 Host字段\n    ifconfig eth0:0 192.168.1.221 netmask 255.255.255.0                   # 增加逻辑IP地址\n    echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all                      # 禁ping\n    net rpc shutdown -I IP_ADDRESS -U username%password                   # 远程关掉一台WINDOWS机器\n    wget --random-wait -r -p -e robots=off -U Mozilla www.example.com     # 递归方式下载整个网站\n    sshpass -p \"$pwd\" rsync -avzP /dir  user@$IP:/dir/                    # 指定密码避免交互同步目录\n    rsync -avzP --delete /dir/ user@$IP:/dir/                             # 无差同步目录 可以快速清空大目录,末尾带/同步目录\n    rsync -avzP -e \"ssh -p 22 -e -o StrictHostKeyChecking=no\" /dir user@$IP:/dir         # 指定ssh参数同步\n\n    抓包{\n\n        -i eth1                             # 只抓经过接口eth1的包\n        -t                                  # 不显示时间戳\n        -s 0                                # 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包\n        -c 100                              # 只抓取100个数据包\n        dst port ! 22                       # 不抓取目标端口是22的数据包\n        tcpdump tcp port 22                 # 抓包\n        tcpdump -n -vv udp port 53          # 抓udp的dns包 并显示ip\n        tcpdump port 10001 -A -s0           # 完整显示ascii数据包\n        tcpdump -i any  host x.x.x.x -s 0 -w /tmp/cap.pcap   # 对端ip\n        tcpdump -i any -s 0 host 172.20.81.107 or host 172.16.3.72 -C 50 -W 5 -w /tmp/20190122ng.cap\n\n    }\n\n\n    一次短链接失败故障定位{\n\n        # php和python程序调用接口,通过阿里云slb,到后端nginx,偶尔超时,后端nginx无请求,怀疑没到nginx,但通过检查,无法与nginx建立tcp链接\n        ss -nl |grep :80  # 查看 accept 队列值,短连接应该大一点\n        watch -n 1 'nstat -z -t 1 | grep -e TcpActiveOpens -e TcpExtListenOverflows -e TcpAttemptFails -e TcpPassiveOpen -e TcpExtTCPSynRetrans -e TcpRetransSegs  -e TcpOutSegs -e TcpInSegs'\n\n        TcpAttemptFails         TCP建立链接失败,包括前后端\n        TcpExtTCPSynRetrans     TCP向后端建立链接失败\n\n\n        # nginx 和内核都需要调整才生效,程序监听端口,需要加socket参数\n        listen 10.87.128.29:51528 default_server backlog=4096;\n\n\n        https://m.aliyun.com/yunqi/articles/118472?spm=5176.8091938.0.0.11e86ccF4oOeZ\n    }\n\n    网卡流量查看{\n\n        watch more /proc/net/dev    # 实时监控流量文件系统 累计值\n        iptraf                      # 网卡流量查看工具\n        nethogs -d 5 eth0 eth1      # 按进程实时统计网络流量 epel源nethogs\n        iftop -i eth0 -n -P         # 实时流量监控\n\n        sar {\n            -n参数有6个不同的开关: DEV | EDEV | NFS | NFSD | SOCK | ALL\n            DEV显示网络接口信息\n            EDEV显示关于网络错误的统计数据\n            NFS统计活动的NFS客户端的信息\n            NFSD统计NFS服务器的信息\n            SOCK显示套 接字信息\n            ALL显示所有5个开关\n\n            sar -n DEV 1 10\n\n            rxpck/s   # 每秒钟接收的数据包\n            txpck/s   # 每秒钟发送的数据包\n            rxbyt/s   # 每秒钟接收的字节数\n            txbyt/s   # 每秒钟发送的字节数\n            rxcmp/s   # 每秒钟接收的压缩数据包\n            txcmp/s   # 每秒钟发送的压缩数据包\n            rxmcst/s  # 每秒钟接收的多播数据包\n\n        }\n\n    }\n\n    netstat{\n\n        # 几十万并发的情况下netstat会没有响应，建议使用 ss 命令\n        -a     # 显示所有连接中的Socket\n        -t     # 显示TCP连接\n        -u     # 显示UDP连接\n        -n     # 显示所有已建立的有效连接\n        netstat -anlp           # 查看链接\n        netstat -tnlp           # 只查看tcp监听端口\n        netstat -r              # 查看路由表\n    }\n\n    ss{\n\n        # netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多\n        ss -s                          # 列出当前socket详细信息\n        ss -l                          # 显示本地打开的所有端口\n        ss -tnlp                       # 显示每个进程具体打开的socket\n        ss -ant                        # 显示所有TCP socket\n        ss -u -a                       # 显示所有UDP Socekt\n        ss dst 192.168.119.113         # 匹配远程地址\n        ss dst 192.168.119.113:http    # 匹配远程地址和端口号\n        ss dst 192.168.119.113:3844    # 匹配远程地址和端口号\n        ss src 192.168.119.103:16021   # 匹配本地地址和端口号\n        ss -o state established '( dport = :smtp or sport = :smtp )'        # 显示所有已建立的SMTP连接\n        ss -o state established '( dport = :http or sport = :http )'        # 显示所有已建立的HTTP连接\n        ss -x src /tmp/.X11-unix/*         # 找出所有连接X服务器的进程\n\n    }\n\n    并发数查看{\n\n        netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'\n        SYN_RECV     # 正在等待处理的请求\n        ESTABLISHED  # 正常数据传输状态,既当前并发数\n        TIME_WAIT    # 处理完毕，等待超时结束的请求\n        CLOSE_WAIT   # 客户端异常关闭,没有完成4次挥手  如大量可能存在攻击行为\n\n    }\n\n    ssh{\n\n        ssh -p 22 user@192.168.1.209                            # 从linux ssh登录另一台linux\n        ssh -p 22 root@192.168.1.209 CMD                        # 利用ssh操作远程主机\n        scp -P 22 file root@ip:/dir                             # 把本地文件拷贝到远程主机\n        scp -l 100000  file root@ip:/dir                        # 传输文件到远程，限制速度100M\n        sshpass -p 'pwd' ssh -n root@$IP \"echo hello\"           # 指定密码远程操作\n        ssh -o StrictHostKeyChecking=no $IP                     # ssh连接不提示yes\n        ssh -t \"su -\"                                           # 指定伪终端 客户端以交互模式工作\n        scp root@192.168.1.209:/RemoteDir /localDir             # 把远程指定文件拷贝到本地\n        pscp -h host.ip /a.sh /opt/sbin/                        # 批量传输文件\n        ssh -N -L2001:remotehost:80 user@somemachine            # 用SSH创建端口转发通道\n        ssh -t host_A ssh host_B                                # 嵌套使用SSH\n        ssh -t -p 22 $user@$Ip /bin/su - root -c {$Cmd};        # 远程su执行命令 Cmd=\"\\\"/sbin/ifconfig eth0\\\"\"\n        ssh-keygen -t rsa                                       # 生成密钥\n        ssh-copy-id -i xuesong@10.10.10.133                     # 传送key\n        vi $HOME/.ssh/authorized_keys                           # 公钥存放位置\n        sshfs name@server:/path/to/folder /path/to/mount/point  # 通过ssh挂载远程主机上的文件夹\n        fusermount -u /path/to/mount/point                      # 卸载ssh挂载的目录\n        ssh user@host cat /path/to/remotefile | diff /path/to/localfile -                # 用DIFF对比远程文件跟本地文件\n        su - user -c \"ssh user@192.168.1.1 \\\"echo -e aa |mail -s test mail@163.com\\\"\"    # 切换用户登录远程发送邮件\n        pssh -h ip.txt -i uptime                                # 批量执行ssh yum install pssh\n\n        SSH反向连接{\n\n            # 外网A要控制内网B\n\n            ssh -NfR 1234:localhost:2223 user1@123.123.123.123 -p22    # 将A主机的1234端口和B主机的2223端口绑定，相当于远程端口映射\n            ss -ant   # 这时在A主机上sshd会listen本地1234端口\n            # LISTEN     0    128    127.0.0.1:1234       *:*\n            ssh localhost -p1234    # 在A主机连接本地1234端口\n\n        }\n    }\n\n    网卡配置文件{\n\n        vi /etc/sysconfig/network-scripts/ifcfg-eth0\n\n        DEVICE=eth0\n        BOOTPROTO=none\n        BROADCAST=192.168.1.255\n        HWADDR=00:0C:29:3F:E1:EA\n        IPADDR=192.168.1.55\n        NETMASK=255.255.255.0\n        NETWORK=192.168.1.0\n        ONBOOT=yes\n        TYPE=Ethernet\n        GATEWAY=192.168.1.1\n        #ARPCHECK=no     # 进制arp检查\n\n    }\n\n    route {\n\n        route                           # 查看路由表\n        route add default  gw 192.168.1.1  dev eth0                        # 添加默认路由\n        route add -net 172.16.0.0 netmask 255.255.0.0 gw 10.39.111.254     # 添加静态路由网关\n        route del -net 172.16.0.0 netmask 255.255.0.0 gw 10.39.111.254     # 删除静态路由网关\n\n    }\n\n    静态路由{\n\n        vim /etc/sysconfig/static-routes\n        any net 192.168.12.0/24 gw 192.168.0.254\n        any net 192.168.13.0/24 gw 192.168.0.254\n\n    }\n\n    解决ssh链接慢{\n\n        sed -i 's/GSSAPIAuthentication yes/GSSAPIAuthentication no/' /etc/ssh/sshd_config\n        sed -i '/#UseDNS yes/a\\UseDNS no' /etc/ssh/sshd_config\n        /etc/init.d/sshd reload\n\n    }\n\n    nmap{\n\n        nmap -PT 192.168.1.1-111             # 先ping在扫描主机开放端口\n        nmap -O 192.168.1.1                  # 扫描出系统内核版本\n        nmap -sV 192.168.1.1-111             # 扫描端口的软件版本\n        nmap -sS 192.168.1.1-111             # 半开扫描(通常不会记录日志)\n        nmap -P0 192.168.1.1-111             # 不ping直接扫描\n        nmap -d 192.168.1.1-111              # 详细信息\n        nmap -D 192.168.1.1-111              # 无法找出真正扫描主机(隐藏IP)\n        nmap -p 20-30,139,60000-             # 端口范围  表示：扫描20到30号端口，139号端口以及所有大于60000的端口\n        nmap -P0 -sV -O -v 192.168.30.251    # 组合扫描(不ping、软件版本、内核版本、详细信息)\n\n        # 不支持windows的扫描(可用于判断是否是windows)\n        nmap -sF 192.168.1.1-111\n        nmap -sX 192.168.1.1-111\n        nmap -sN 192.168.1.1-111\n\n    }\n\n    流量切分线路{\n\n        # 程序判断进入IP线路，设置服务器路由规则控制返回\n        vi /etc/iproute2/rt_tables\n        #添加一条策略\n        252   bgp2  #注意策略的序号顺序\n        ip route add default via 第二个出口上线IP(非默认网关) dev eth1 table bgp2\n        ip route add from 本机第二个ip table bgp2\n        #查看\n        ip route list table 252\n        ip rule list\n        #成功后将语句添加开机启动\n\n    }\n\n    snmp{\n\n        snmptranslate .1.3.6.1.2.1.1.3.0    # 查看映射关系\n            DISMAN-EVENT-MIB::sysUpTimeInstance\n        snmpdf -v 1 -c public localhost                            # SNMP监视远程主机的磁盘空间\n        snmpnetstat -v 2c -c public -a 192.168.6.53                # SNMP获取指定IP的所有开放端口状态\n        snmpwalk -v 2c -c public 10.152.14.117 .1.3.6.1.2.1.1.3.0  # SNMP获取主机启动时间\n        # MIB安装(ubuntu)\n        # sudo apt-get install snmp-mibs-downloader\n        # sudo download-mibs\n        snmpwalk -v 2c -c public 10.152.14.117 sysUpTimeInstance   # SNMP通过MIB库获取主机启动时间\n\n    }\n\n    TC流量控制{\n\n        # 针对ip段下载速率控制\n        tc qdisc del dev eth0 root handle 1:                                                              # 删除控制1:\n        tc qdisc add dev eth0 root handle 1: htb r2q 1                                                    # 添加控制1:\n        tc class add dev eth0 parent 1: classid 1:1 htb rate 12mbit ceil 15mbit                           # 设置速率\n        tc filter add dev eth0 parent 1: protocol ip prio 16 u32 match ip dst 10.10.10.1/24 flowid 1:1    # 指定ip段控制规则\n\n        # 检查命令\n        tc -s -d qdisc show dev eth0\n        tc class show dev eth0\n        tc filter show dev eth0\n\n        限制上传下载{\n\n            tc qdisc del dev tun0 root\n            tc qdisc add dev tun0 root handle 2:0 htb\n            tc class add dev tun0 parent 2:1 classid 2:10 htb rate 30kbps\n            tc class add dev tun0 parent 2:2 classid 2:11 htb rate 30kbps\n            tc qdisc add dev tun0 parent 2:10 handle 1: sfq perturb 1\n            tc filter add dev tun0 protocol ip parent 2:0 u32 match ip dst 10.18.0.0/24 flowid 2:10\n            tc filter add dev tun0 parent ffff: protocol ip u32 match ip src 10.18.0.0/24 police rate 30kbps burst 10k drop flowid 2:11\n\n\n            tc qdisc del dev tun0 root                                     # 删除原有策略\n            tc qdisc add dev tun0 root handle 2:0 htb                      # 定义最顶层(根)队列规则，并指定 default 类别编号，为网络接口 eth1 绑定一个队列，类型为 htb，并指定了一个 handle 句柄 2:0 用于标识它下面的子类\n            tc class add dev tun0 parent 2:1 classid 2:10 htb rate 30kbps  # 设置一个规则速度是30kbps\n            tc class add dev tun0 parent 2:2 classid 2:11 htb rate 30kbps\n            tc qdisc add dev tun0 parent 2:10 handle 1: sfq perturb 1      # 调用随机公平算法\n            tc filter add dev tun0 protocol ip parent 2:0 u32 match ip dst 10.18.0.0/24 flowid 2:10  # 规则2:10应用在目标地址上，即下载\n            tc filter add dev tun0 parent ffff: protocol ip u32 match ip src 10.18.0.0/24 police rate 30kbps burst 10k drop flowid 2:11 # 上传限速\n\n        }\n\n    }\n\n}\n\n6 磁盘{\n\n    df -Ph                                          # 查看硬盘容量\n    df -T                                           # 查看磁盘分区格式\n    df -i                                           # 查看inode节点   如果inode用满后无法创建文件\n    du -h dir                                       # 检测目录下所有文件大小\n    du -sh *                                        # 显示当前目录中子目录的大小\n    mount -l                                        # 查看分区挂载情况\n    fdisk -l                                        # 查看磁盘分区状态\n    fdisk /dev/hda3                                 # 分区\n    mkfs -t ext4  /dev/hda3                         # 格式化分区\n    fsck -y /dev/sda6                               # 对文件系统修复\n    lsof |grep delete                               # 释放进程占用磁盘空间  列出进程后，查看文件是否存在，不存在则kill掉此进程\n    tmpwatch -afv 10   /tmp                         # 删除10小时内未使用的文件  勿在重要目录使用\n    cat /proc/filesystems                           # 查看当前系统支持文件系统\n    mount -o remount,rw /                           # 修改只读文件系统为读写\n    iotop                                           # 进程占用磁盘IO情况   yum install iotop\n    smartctl -H /dev/sda                            # 检测硬盘状态  # yum install smartmontools\n    smartctl -i /dev/sda                            # 检测硬盘信息\n    smartctl -a /dev/sda                            # 检测所有信息\n    e2label /dev/sda5                               # 查看卷标\n    e2label /dev/sda5 new-label                     # 创建卷标\n    ntfslabel -v /dev/sda8 new-label                # NTFS添加卷标\n    tune2fs -j /dev/sda                             # ext2分区转ext3分区\n    tune2fs -l /dev/sda                             # 查看文件系统信息\n    mke2fs -b 2048 /dev/sda5                        # 指定索引块大小\n    dumpe2fs -h /dev/sda5                           # 查看超级块的信息\n    mount -t iso9660 /dev/dvd  /mnt                 # 挂载光驱\n    mount -t ntfs-3g /dev/sdc1 /media/yidong        # 挂载ntfs硬盘\n    mount -t nfs 10.0.0.3:/opt/images/  /data/img   # 挂载nfs 需要重载 /etc/init.d/nfs reload  重启需要先启动 portmap 服务\n    mount -o loop  /software/rhel4.6.iso   /mnt/    # 挂载镜像文件\n\n    磁盘IO性能检测{\n\n        iostat -x 1 10\n\n        % user       # 显示了在用户级(应用程序)执行时生成的 CPU 使用率百分比。\n        % system     # 显示了在系统级(内核)执行时生成的 CPU 使用率百分比。\n        % idle       # 显示了在 CPU 空闲并且系统没有未完成的磁盘 I/O 请求时的时间百分比。\n        % iowait     # 显示了 CPU 空闲期间系统有未完成的磁盘 I/O 请求时的时间百分比。\n\n        rrqm/s       # 每秒进行 merge 的读操作数目。即 delta(rmerge)/s\n        wrqm/s       # 每秒进行 merge 的写操作数目。即 delta(wmerge)/s\n        r/s          # 每秒完成的读 I/O 设备次数。即 delta(rio)/s\n        w/s          # 每秒完成的写 I/O 设备次数。即 delta(wio)/s\n        rsec/s       # 每秒读扇区数。即 delta(rsect)/s\n        wsec/s       # 每秒写扇区数。即 delta(wsect)/s\n        rkB/s        # 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)\n        wkB/s        # 每秒写K字节数。是 wsect/s 的一半。(需要计算)\n        avgrq-sz     # 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)\n        avgqu-sz     # 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。\n        await        # 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)\n        svctm        # 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)\n        %util        # 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)\n\n        IO性能衡量标准{\n\n            1、 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。\n            2、 idle 小于70% IO压力就较大了,一般读取速度有较多的wait.\n            3、 同时可以结合 vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)\n            4、 svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了),svctm 的大小一般和磁盘性能有关,CPU/内存的负荷也会对其有影响,请求过多也会间接导致 svctm 的增加. await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式. 如果 svctm 比较接近 await,说明 I/O 几乎没有等待时间;如果 await 远大于 svctm,说明 I/O 队列太长,应用得到的响应时间变慢,如果响应时间超过了用户可以容许的范围,这时可以考虑更换更快的磁盘,调整内核 elevator 算法,优化应用,或者升级 CPU\n            5、 队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。\n\n        }\n\n    }\n\n    iotop{\n\n        # 监视进程磁盘I/O\n\n        yum install iotop\n\n        -o        # 只显示有io操作的进程\n        -b        # 批量显示，无交互，主要用作记录到文件。\n        -n NUM    # 显示NUM次，主要用于非交互式模式。\n        -d SEC    # 间隔SEC秒显示一次。\n        -p PID    # 监控的进程pid。\n        -u USER   # 监控的进程用户。\n\n        # 左右箭头：改变排序方式，默认是按IO排序。\n        r         # 改变排序顺序。\n        o         # 只显示有IO输出的进程。\n        p         # 进程/线程的显示方式的切换。\n        a         # 显示累积使用量。\n        q         # 退出。\n\n    }\n\n    创建swap文件方法{\n\n        dd if=/dev/zero of=/swap bs=1024 count=4096000            # 创建一个足够大的文件\n        # count的值等于1024 x 你想要的文件大小, 4096000是4G\n        mkswap /swap                      # 把这个文件变成swap文件\n        swapon /swap                      # 启用这个swap文件\n        /swap swap swap defaults 0 0      # 在每次开机的时候自动加载swap文件, 需要在 /etc/fstab 文件中增加一行\n        cat /proc/swaps                   # 查看swap\n        swapoff -a                        # 关闭swap\n        swapon -a                         # 开启swap\n\n    }\n\n    新硬盘挂载{\n\n        fdisk /dev/sdc\n        p    #  打印分区\n        d    #  删除分区\n        n    #  创建分区，（一块硬盘最多4个主分区，扩展占一个主分区位置。p主分区 e扩展）\n        w    #  保存退出\n        mkfs.ext4 -L 卷标  /dev/sdc1            # 格式化相应分区\n        mount /dev/sdc1  /mnt                  # 挂载\n        vi /etc/fstab                          # 添加开机挂载分区\n        LABEL=/data            /data                   ext4    defaults        1 2      # 用卷标挂载\n        /dev/sdb1              /data4                  ext4    defaults        1 2      # 用真实分区挂载\n        /dev/sdb2              /data4                  ext4    noatime,defaults        1 2\n\n        第一个数字\"1\"该选项被\"dump\"命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储就设置该字段为0\n        第二个数字\"2\"该字段被fsck命令用来决定在启动时需要被扫描的文件系统的顺序，根文件系统\"/\"对应该字段的值应该为1，其他文件系统应该为2。若该文件系统无需在启动时扫描则设置该字段为0\n        当以 noatime 选项加载（mount）文件系统时，对文件的读取不会更新文件属性中的atime信息。设置noatime的重要性是消除了文件系统对文件的写操作，文件只是简单地被系统读取。由于写操作相对读来说要更消耗系统资源，所以这样设置可以明显提高服务器的性能.wtime信息仍然有效，任何时候文件被写，该信息仍被更新。\n\n        mount -a    # 自动加载 fstab 文件挂载，避免配置错误，系统无法重启\n\n    }\n\n    大磁盘2T和16T分区{\n\n        parted /dev/sdb                # 针对磁盘分区\n        (parted) mklabel gpt           # 设置为 gpt\n        (parted) print\n        (parted) mkpart  primary 0KB 22.0TB        # 指定分区大小\n        Is this still acceptable to you?\n        Yes/No? Yes\n        Ignore/Cancel? Ignore\n        (parted) print\n        Model: LSI MR9271-8i (scsi)\n        Disk /dev/sdb: 22.0TB\n        Sector size (logical/physical): 512B/512B\n        Partition Table: gpt\n        Number  Start   End     Size    File system  Name     Flags\n         1      17.4kB  22.0TB  22.0TB               primary\n        (parted) quit\n\n        mkfs.ext4 /dev/sdb1        # e2fsprogs升级后支持大于16T硬盘\n\n        # 大于16T的单个分区ext4格式化报错，需要升级e2fsprogs\n        Size of device /dev/sdb1 too big to be expressed in 32 bits using a blocksize of 4096.\n\n        yum -y install xfsprogs\n        mkfs.xfs -f /dev/sdb1              # 大于16T单个分区也可以使用XFS分区,但inode占用很大,对大量的小文件支持不太好\n\n    }\n\n    阿里云扩容磁盘{\n\n        # 进入ECS 本实例磁盘，勾选在线扩容, 选择扩容磁盘\n        yum install cloud-utils-growpart\n        yum install xfsprogs\n        df -h    # 查看目前分区大小\n        fdisk -l # 查看磁盘设备\n        growpart /dev/vda 1         # 扩容分区 如果没有分区,默认整块,不需要执行\n        resize2fs /dev/vda1         # 扩容文件系统 ext4文件系统 \n        xfs_growfs /dev/vda1        # 扩容文件系统 xfs文件系统\n        df -h                       # 再查看分区大小,是否扩容\n\n    }\n\n    raid原理与区别{\n\n        raid0至少2块硬盘.吞吐量大,性能好,同时读写,但损坏一个就完蛋\n        raid1至少2块硬盘.相当镜像,一个存储,一个备份.安全性比较高.但是性能比0弱\n        raid5至少3块硬盘.分别存储校验信息和数据，坏了一个根据校验信息能恢复\n        raid6至少4块硬盘.两个独立的奇偶系统,可坏两块磁盘,写性能非常差\n\n    }\n\n}\n\n7 用户{\n\n    users                                      # 显示所有的登录用户\n    groups                                     # 列出当前用户和他所属的组\n    who -q                                     # 显示所有的登录用户\n    groupadd                                   # 添加组\n    useradd user                               # 建立用户\n    passwd username                            # 修改密码\n    userdel -r                                 # 删除帐号及家目录\n    chown -R user:group                        # 修改目录拥有者(R递归)\n    chown y\\.li:mysql                          # 修改所有者用户中包含点\".\"\n    umask                                      # 设置用户文件和目录的文件创建缺省屏蔽值\n    chgrp                                      # 修改用户组\n    finger                                     # 查找用户显示信息\n    echo \"xuesong\" | passwd user --stdin       # 非交互修改密码\n    useradd -g www -M  -s /sbin/nologin  www   # 指定组并不允许登录的用户,nologin允许使用服务\n    useradd -g www -M  -s /bin/false  www      # 指定组并不允许登录的用户,false最为严格\n    useradd -d /data/song -g song song         # 创建用户并指定家目录和组\n    usermod -l newuser olduser                 # 修改用户名\n    usermod -g user group                      # 修改用户所属组\n    usermod -d dir -m user                     # 修改用户家目录\n    usermod -G group user                      # 将用户添加到附加组\n    gpasswd -d user group                      # 从组中删除用户\n    su - user -c \" #cmd1; \"                    # 切换用户执行\n\n    恢复密码{\n\n        # 即进入单用户模式: 在linux出现grub后，在安装的系统上面按\"e\"，然后出现grub的配置文件，按键盘移动光标到第二行\"Ker……\"，再按\"e\"，然后在这一行的结尾加上：空格 single或者空格1回车，然后按\"b\"重启，就进入了\"单用户模式\"\n    }\n\n    特殊权限{\n\n        s或 S （SUID）：对应数值4\n        s或 S （SGID）：对应数值2\n        t或 T ：对应数值1\n        大S：代表拥有root权限，但是没有执行权限\n        小s：拥有特权且拥有执行权限，这个文件可以访问系统任何root用户可以访问的资源\n        T或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件\n\n    }\n\n}\n\n8 脚本{\n\n    #!/bin/sh                             # 在脚本第一行脚本头 # sh为当前系统默认shell,可指定为bash等shell\n    shopt                                 # 显示和设置shell中的行为选项\n    sh -x                                 # 执行过程\n    sh -n                                 # 检查语法\n    set -e                                # 若指令传回值不等于0，则立即退出shell\n    (a=bbk)                               # 括号创建子shell运行\n    basename /a/b/c                       # 从全路径中保留最后一层文件名或目录\n    dirname                               # 取路径\n    $RANDOM                               # 随机数\n    $$                                    # 进程号\n    source FileName                       # 在当前bash环境下读取并执行FileName中的命令  # 等同 . FileName\n    sleep 5                               # 间隔睡眠5秒\n    trap                                  # 在接收到信号后将要采取的行动\n    trap \"\" 2 3                           # 禁止ctrl+c\n    $PWD                                  # 当前目录\n    $HOME                                 # 家目录\n    $OLDPWD                               # 之前一个目录的路径\n    cd -                                  # 返回上一个目录路径\n    local ret                             # 局部变量\n    yes                                   # 重复打印\n    yes |rm -i *                          # 自动回答y或者其他\n    ls -p /home                           # 区分目录和文件夹\n    ls -d /home/                          # 查看匹配完整路径\n    time a.sh                             # 测试程序执行时间\n    echo -n aa;echo bb                    # 不换行执行下一句话 将字符串原样输出\n    echo -e \"s\\tss\\n\\n\\n\"                 # 使转义生效\n    echo $a | cut -c2-6                   # 取字符串中字元\n    echo {a,b,c}{a,b,c}{a,b,c}            # 排列组合(括号内一个元素分别和其他括号内元素组合)\n    echo $((2#11010))                     # 二进制转10进制\n    echo aaa | tee file                   # 打印同时写入文件 默认覆盖 -a追加\n    echo {1..10}                          # 打印10个字符\n    printf '%10s\\n'|tr \" \" a              # 打印10个字符\n    pwd | awk -F/ '{ print $2 }'          # 返回目录名\n    tac file |sed 1,3d|tac                # 倒置读取文件  # 删除最后3行\n    tail -3 file                          # 取最后3行\n    outtmp=/tmp/$$`date +%s%N`.outtmp     # 临时文件定义\n    :(){ :|:& };:                         # fork炸弹,系统执行海量的进程,直到系统僵死\n    echo -e \"\\e[32mcolour\\e[0m\"           # 打印颜色\n    echo -e \"\\033[32mcolour\\033[m\"        # 打印颜色\n    echo -e \"\\033[0;31mL\\033[0;32mO\\033[0;33mV\\033[0;34mE\\t\\033[0;35mY\\033[0;36mO\\033[0;32mU\\e[m\"    # 打印颜色\n\n    正则表达式{\n\n        ^                       # 行首定位\n        $                       # 行尾定位\n        .                       # 匹配除换行符以外的任意字符\n        *                       # 匹配0或多个重复字符\n        +                       # 重复一次或更多次\n        ?                       # 重复零次或一次\n        ?                       # 结束贪婪因子 .*? 表示最小匹配\n        []                      # 匹配一组中任意一个字符\n        [^]                     # 匹配不在指定组内的字符\n        \\                       # 用来转义元字符\n        <                       # 词首定位符(支持vi和grep)  <love\n        >                       # 词尾定位符(支持vi和grep)  love>\n        x\\{m\\}                  # 重复出现m次\n        x\\{m,\\}                 # 重复出现至少m次\n        x\\{m,n\\}                # 重复出现至少m次不超过n次\n        X?                      # 匹配出现零次或一次的大写字母 X\n        X+                      # 匹配一个或多个字母 X\n        ()                      # 括号内的字符为一组\n        (ab|de)+                # 匹配一连串的（最少一个） abc 或 def；abc 和 def 将匹配\n        [[:alpha:]]             # 代表所有字母不论大小写\n        [[:lower:]]             # 表示小写字母\n        [[:upper:]]             # 表示大写字母\n        [[:digit:]]             # 表示数字字符\n        [[:digit:][:lower:]]    # 表示数字字符加小写字母\n\n        元字符{\n\n            \\d       # 匹配任意一位数字\n            \\D       # 匹配任意单个非数字字符\n            \\w       # 匹配任意单个字母数字下划线字符，同义词是 [:alnum:]\n            \\W       # 匹配非数字型的字符\n\n        }\n\n        字符类:空白字符{\n\n            \\s       # 匹配任意的空白符\n            \\S       # 匹配非空白字符\n            \\b       # 匹配单词的开始或结束\n            \\n       # 匹配换行符\n            \\r       # 匹配回车符\n            \\t       # 匹配制表符\n            \\b       # 匹配退格符\n            \\0       # 匹配空值字符\n\n        }\n\n        字符类:锚定字符{\n\n            \\b       # 匹配字边界(不在[]中时)\n            \\B       # 匹配非字边界\n            \\A       # 匹配字符串开头\n            \\Z       # 匹配字符串或行的末尾\n            \\z       # 只匹配字符串末尾\n            \\G       # 匹配前一次m//g离开之处\n\n        }\n\n        捕获{\n\n            (exp)                # 匹配exp,并捕获文本到自动命名的组里\n            (?<name>exp)         # 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)\n            (?:exp)              # 匹配exp,不捕获匹配的文本，也不给此分组分配组号\n\n        }\n\n        零宽断言{\n\n            (?=exp)              # 匹配exp前面的位置\n            (?<=exp)             # 匹配exp后面的位置\n            (?!exp)              # 匹配后面跟的不是exp的位置\n            (?<!exp)             # 匹配前面不是exp的位置\n            (?#comment)          # 注释不对正则表达式的处理产生任何影响，用于注释\n\n        }\n\n        特殊字符{\n\n            http://en.wikipedia.org/wiki/Ascii_table\n            ^H  \\010 \\b\n            ^M  \\015 \\r\n            匹配特殊字符: ctrl+V ctrl不放在按H或M 即可输出^H,用于匹配\n\n        }\n\n    }\n\n    流程结构{\n\n        if判断{\n\n            if [ $a == $b ]\n            then\n                echo \"等于\"\n            else\n                echo \"不等于\"\n            fi\n\n        }\n\n        case分支选择{\n\n            case $xs in\n            0) echo \"0\" ;;\n            1) echo \"1\" ;;\n            *) echo \"其他\" ;;\n            esac\n\n        }\n\n        while循环{\n\n            # while true  等同   while :\n            # 读文件为整行读入\n            num=1\n            while [ $num -lt 10 ]\n            do\n            echo $num\n            ((num=$num+2))\n            done\n            ###########################\n            grep a  a.txt | while read a\n            do\n                echo $a\n            done\n            ###########################\n            while read a\n            do\n                echo $a\n            done < a.txt\n\n        }\n\n        for循环{\n\n            # 读文件已空格分隔\n            w=`awk -F \":\" '{print $1}' c`\n            for d in $w\n            do\n                $d\n            done\n            ###########################\n            for ((i=0;i<${#o[*]};i++))\n            do\n            echo ${o[$i]}\n            done\n\n        }\n\n        until循环{\n\n            #  当command不为0时循环\n            until command\n            do\n                body\n            done\n\n        }\n\n        流程控制{\n\n            break N     #  跳出几层循环\n            continue N  #  跳出几层循环，循环次数不变\n            continue    #  重新循环次数不变\n\n        }\n\n    }\n\n    变量{\n\n        A=\"a b c def\"           # 将字符串复制给变量\n        A=`cmd`                 # 将命令结果赋给变量\n        A=$(cmd)                # 将命令结果赋给变量\n        eval a=\\$$a             # 间接调用\n        i=2&&echo $((i+3))      # 计算后打印新变量结果\n        i=2&&echo $[i+3]        # 计算后打印新变量结果\n        a=$((2>6?5:8))          # 判断两个值满足条件的赋值给变量\n        $1  $2  $*              # 位置参数 *代表所有\n        env                     # 查看环境变量\n        env | grep \"name\"       # 查看定义的环境变量\n        set                     # 查看环境变量和本地变量\n        read name               # 输入变量\n        readonly name           # 把name这个变量设置为只读变量,不允许再次设置\n        readonly                # 查看系统存在的只读文件\n        export name             # 变量name由本地升为环境\n        export name=\"RedHat\"    # 直接定义name为环境变量\n        export Stat$nu=2222     # 变量引用变量赋值\n        unset name              # 变量清除\n        export -n name          # 去掉只读变量\n        shift                   # 用于移动位置变量,调整位置变量,使$3的值赋给$2.$2的值赋予$1\n        name + 0                # 将字符串转换为数字\n        number \" \"              # 将数字转换成字符串\n        a='ee';b='a';echo ${!b} # 间接引用name变量的值\n        : ${a=\"cc\"}             # 如果a有值则不改变,如果a无值则赋值a变量为cc\n\n        数组{\n\n            A=(a b c def)         # 将变量定义为数組\n            ${#A[*]}              # 数组个数\n            ${A[*]}               # 数组所有元素,大字符串\n            ${A[@]}               # 数组所有元素,类似列表可迭代\n            ${A[2]}               # 脚本的一个参数或数组第三位\n\n        }\n\n        定义变量类型{\n\n            declare 或 typeset\n            -r 只读(readonly一样)\n            -i 整形\n            -a 数组\n            -f 函数\n            -x export\n            declare -i n=0\n\n        }\n\n        系统变量{\n\n            $0   #  脚本启动名(包括路径)\n            $n   #  第n个参数,n=1,2,…9\n            $*   #  所有参数列表(不包括脚本本身)\n            $@   #  所有参数列表(独立字符串)\n            $#   #  参数个数(不包括脚本本身)\n            $$   #  当前程式的PID\n            $!   #  执行上一个指令的PID\n            $?   #  执行上一个指令的返回值\n\n        }\n\n        变量引用技巧{\n\n            ${name:+value}        # 如果设置了name,就把value显示,未设置则为空\n            ${name:-value}        # 如果设置了name,就显示它,未设置就显示value\n            ${name:?value}        # 未设置提示用户错误信息value \n            ${name:=value}        # 如未设置就把value设置并显示<写入本地中>\n            ${#A}                 # 可得到变量中字节\n            ${A:4:9}              # 取变量中第4位到后面9位\n            ${A:(-1)}             # 倒叙取最后一个字符\n            ${A/www/http}         # 取变量并且替换每行第一个关键字\n            ${A//www/http}        # 取变量并且全部替换每行关键字\n\n            定义了一个变量： file=/dir1/dir2/dir3/my.file.txt\n            ${file#*/}     # 去掉第一条 / 及其左边的字串：dir1/dir2/dir3/my.file.txt\n            ${file##*/}    # 去掉最后一条 / 及其左边的字串：my.file.txt\n            ${file#*.}     # 去掉第一个 .  及其左边的字串：file.txt\n            ${file##*.}    # 去掉最后一个 .  及其左边的字串：txt\n            ${file%/*}     # 去掉最后条 / 及其右边的字串：/dir1/dir2/dir3\n            ${file%%/*}    # 去掉第一条 / 及其右边的字串：(空值)\n            ${file%.*}     # 去掉最后一个 .  及其右边的字串：/dir1/dir2/dir3/my.file\n            ${file%%.*}    # 去掉第一个 .  及其右边的字串：/dir1/dir2/dir3/my\n            #   # 是去掉左边(在键盘上 # 在 $ 之左边)\n            #   % 是去掉右边(在键盘上 % 在 $ 之右边)\n            #   单一符号是最小匹配﹔两个符号是最大匹配\n\n        }\n\n    }\n\n    test条件判断{\n\n        # 符号 [ ] 等同  test命令\n\n        expression为字符串操作{\n\n            -n str   # 字符串str是否不为空\n            -z str   # 字符串str是否为空\n\n        }\n\n        expression为文件操作{\n\n            -a     # 并且，两条件为真\n            -b     # 是否块文件\n            -p     # 文件是否为一个命名管道\n            -c     # 是否字符文件\n            -r     # 文件是否可读\n            -d     # 是否一个目录\n            -s     # 文件的长度是否不为零\n            -e     # 文件是否存在\n            -S     # 是否为套接字文件\n            -f     # 是否普通文件\n            -x     # 文件是否可执行，则为真\n            -g     # 是否设置了文件的 SGID 位\n            -u     # 是否设置了文件的 SUID 位\n            -G     # 文件是否存在且归该组所有\n            -w     # 文件是否可写，则为真\n            -k     # 文件是否设置了的粘贴位\n            -t fd  # fd 是否是个和终端相连的打开的文件描述符（fd 默认为 1）\n            -o     # 或，一个条件为真\n            -O     # 文件是否存在且归该用户所有\n            !      # 取反\n\n        }\n\n        expression为整数操作{\n\n            expr1 -a expr2   # 如果 expr1 和 expr2 评估为真，则为真\n            expr1 -o expr2   # 如果 expr1 或 expr2 评估为真，则为真\n\n        }\n\n        两值比较{\n\n            整数     字符串\n            -lt      <         # 小于\n            -gt      >         # 大于\n            -le      <=        # 小于或等于\n            -ge      >=        # 大于或等于\n            -eq      ==        # 等于\n            -ne      !=        # 不等于\n\n        }\n\n        test 10 -lt 5       # 判断大小\n        echo $?             # 查看上句test命令返回状态  # 结果0为真,1为假\n        test -n \"hello\"     # 判断字符串长度是否为0\n        [ $? -eq 0 ] && echo \"success\" || exit　　　# 判断成功提示,失败则退出\n\n    }\n\n    重定向{\n\n        #  标准输出 stdout 和 标准错误 stderr  标准输入stdin\n        cmd 1> fiel              # 把 标准输出 重定向到 file 文件中\n        cmd > file 2>&1          # 把 标准输出 和 标准错误 一起重定向到 file 文件中\n        cmd 2> file              # 把 标准错误 重定向到 file 文件中\n        cmd 2>> file             # 把 标准错误 重定向到 file 文件中(追加)\n        cmd >> file 2>&1         # 把 标准输出 和 标准错误 一起重定向到 file 文件中(追加)\n        cmd < file >file2        # cmd 命令以 file 文件作为 stdin(标准输入)，以 file2 文件作为 标准输出\n        cat <>file               # 以读写的方式打开 file\n        cmd < file cmd           # 命令以 file 文件作为 stdin\n        cmd << delimiter\n        cmd; #从 stdin 中读入，直至遇到 delimiter 分界符\ndelimiter\n\n        >&n    # 使用系统调用 dup (2) 复制文件描述符 n 并把结果用作标准输出\n        <&n    # 标准输入复制自文件描述符 n\n        <&-    # 关闭标准输入（键盘）\n        >&-    # 关闭标准输出\n        n<&-   # 表示将 n 号输入关闭\n        n>&-   # 表示将 n 号输出关闭\n\n    }\n\n    运算符{\n\n        $[]等同于$(())  # $[]表示形式告诉shell求中括号中的表达式的值\n        ~var            # 按位取反运算符,把var中所有的二进制为1的变为0,为0的变为1\n        var\\<<str       # 左移运算符,把var中的二进制位向左移动str位,忽略最左端移出的各位,最右端的各位上补上0值,每做一次按位左移就有var乘2\n        var>>str        # 右移运算符,把var中所有的二进制位向右移动str位,忽略最右移出的各位,最左的各位上补0,每次做一次右移就有实现var除以2\n        var&str         # 与比较运算符,var和str对应位,对于每个二进制来说,如果二都为1,结果为1.否则为0\n        var^str         # 异或运算符,比较var和str对应位,对于二进制来说如果二者互补,结果为1,否则为0\n        var|str         # 或运算符,比较var和str的对应位,对于每个二进制来说,如二都该位有一个1或都是1,结果为1,否则为0\n\n        运算符优先级{\n            级别      运算符                                  说明\n            1      =,+=,-=,/=,%=,*=,&=,^=,|=,<<=,>>=      # 赋值运算符\n            2         ||                                  # 逻辑或 前面不成功执行\n            3         &&                                  # 逻辑与 前面成功后执行\n            4         |                                   # 按位或\n            5         ^                                   # 按位异或\n            6         &                                   # 按位与\n            7         ==,!=                               # 等于/不等于\n            8         <=,>=,<,>                           # 小于或等于/大于或等于/小于/大于\n            9        \\<<,>>                               # 按位左移/按位右移 (无转意符号)\n            10        +,-                                 # 加减\n            11        *,/,%                               # 乘,除,取余\n            12        ! ,~                                # 逻辑非,按位取反或补码\n            13        -,+                                 # 正负\n        }\n\n    }\n\n    数学运算{\n\n        $(( ))        # 整数运算\n        + - * / **    # 分別为 \"加、減、乘、除、密运算\"\n        & | ^ !       # 分別为 \"AND、OR、XOR、NOT\" 运算\n        %             # 余数运算\n\n        let{\n\n            let # 运算\n            let x=16/4\n            let x=5**5\n\n        }\n\n        expr{\n\n            expr 14 % 9                    # 整数运算\n            SUM=`expr 2 \\* 3`              # 乘后结果赋值给变量\n            LOOP=`expr $LOOP + 1`          # 增量计数(加循环即可) LOOP=0\n            expr length \"bkeep zbb\"        # 计算字串长度\n            expr substr \"bkeep zbb\" 4 9    # 抓取字串\n            expr index \"bkeep zbb\" e       # 抓取第一个字符数字串出现的位置\n            expr 30 / 3 / 2                # 运算符号有空格\n            expr bkeep.doc : '.*'          # 模式匹配(可以使用expr通过指定冒号选项计算字符串中字符数)\n            expr bkeep.doc : '\\(.*\\).doc'  # 在expr中可以使用字符串匹配操作，这里使用模式抽取.doc文件附属名\n\n            数值测试{\n\n                #如果试图计算非整数，则会返回错误\n                rr=3.4\n                expr $rr + 1\n                expr: non-numeric argument\n                rr=5\n                expr $rr + 1\n                6\n\n            }\n\n        }\n\n        bc{\n\n            echo \"m^n\"|bc            # 次方计算\n            seq -s '+' 1000 |bc      # 从1加到1000\n            seq 1 1000 |tr \"\\n\" \"+\"|sed 's/+$/\\n/'|bc   # 从1加到1000\n        }\n\n    }\n\n    grep{\n\n        -c    # 显示匹配到得行的数目，不显示内容\n        -h    # 不显示文件名\n        -i    # 忽略大小写\n        -l    # 只列出匹配行所在文件的文件名\n        -n    # 在每一行中加上相对行号\n        -s    # 无声操作只显示报错，检查退出状态\n        -v    # 反向查找\n        -e    # 使用正则表达式\n        -w    # 精确匹配\n        -wc   # 精确匹配次数\n        -o    # 查询所有匹配字段\n        -P    # 使用perl正则表达式\n        -A3   # 打印匹配行和下三行\n        -B3   # 打印匹配行和上三行\n        -C3   # 打印匹配行和上下三行\n\n        grep -v \"a\" txt                              # 过滤关键字符行\n        grep -w 'a\\>' txt                            # 精确匹配字符串\n        grep -i \"a\" txt                              # 大小写敏感\n        grep  \"a[bB]\" txt                            # 同时匹配大小写\n        grep '[0-9]\\{3\\}' txt                        # 查找0-9重复三次的所在行\n        grep -E \"word1|word2|word3\"   file           # 任意条件匹配\n        grep word1 file | grep word2 |grep word3     # 同时匹配三个\n        echo quan@163.com |grep -Po '(?<=@.).*(?=.$)'                           # 零宽断言截取字符串  #　63.co\n        echo \"I'm singing while you're dancing\" |grep -Po '\\b\\w+(?=ing\\b)'      # 零宽断言匹配\n        echo 'Rx Optical Power: -5.01dBm, Tx Optical Power: -2.41dBm' |grep -Po '(?<=:).*?(?=d)'           # 取出d前面数字 # ?为最小匹配\n        echo 'Rx Optical Power: -5.01dBm, Tx Optical Power: -2.41dBm' | grep -Po '[-0-9.]+'                # 取出d前面数字 # ?为最小匹配\n        echo '[\"mem\",ok],[\"hardware\",false],[\"filesystem\",false]' |grep -Po '[^\"]+(?=\",false)'             # 取出false前面的字母\n        echo '[\"mem\",ok],[\"hardware\",false],[\"filesystem\",false]' |grep -Po '\\w+\",false'|grep -Po '^\\w+'   # 取出false前面的字母\n\n        grep用于if判断{\n\n            if echo abc | grep \"a\"  > /dev/null 2>&1\n            then\n                echo \"abc\"\n            else\n                echo \"null\"\n            fi\n\n        }\n\n    }\n\n    tr{\n\n        -c          # 用字符串1中字符集的补集替换此字符集，要求字符集为ASCII\n        -d          # 删除字符串1中所有输入字符\n        -s          # 删除所有重复出现字符序列，只保留第一个:即将重复出现字符串压缩为一个字符串\n        [a-z]       # a-z内的字符组成的字符串\n        [A-Z]       # A-Z内的字符组成的字符串\n        [0-9]       # 数字串\n        \\octal      # 一个三位的八进制数，对应有效的ASCII字符\n        [O*n]       # 表示字符O重复出现指定次数n。因此[O*2]匹配OO的字符串\n\n        tr中特定控制字符表达方式{\n\n            \\a Ctrl-G    \\007    # 铃声\n            \\b Ctrl-H    \\010    # 退格符\n            \\f Ctrl-L    \\014    # 走行换页\n            \\n Ctrl-J    \\012    # 新行\n            \\r Ctrl-M    \\015    # 回车\n            \\t Ctrl-I    \\011    # tab键\n            \\v Ctrl-X    \\030\n\n        }\n\n        tr A-Z a-z                             # 将所有大写转换成小写字母\n        tr \" \" \"\\n\"                            # 将空格替换为换行\n        tr -s \"[\\012]\" < plan.txt              # 删除空行\n        tr -s [\"\\n\"] < plan.txt                # 删除空行\n        tr -s \"[\\015]\" \"[\\n]\" < file           # 删除文件中的^M，并代之以换行\n        tr -s \"[\\r]\" \"[\\n]\" < file             # 删除文件中的^M，并代之以换行\n        tr -s \"[:]\" \"[\\011]\" < /etc/passwd     # 替换passwd文件中所有冒号，代之以tab键\n        tr -s \"[:]\" \"[\\t]\" < /etc/passwd       # 替换passwd文件中所有冒号，代之以tab键\n        echo $PATH | tr \":\" \"\\n\"               # 增加显示路径可读性\n        1,$!tr -d '\\t'                         # tr在vi内使用，在tr前加处理行范围和感叹号('$'表示最后一行)\n        tr \"\\r\" \"\\n\"<macfile > unixfile        # Mac -> UNIX\n        tr \"\\n\" \"\\r\"<unixfile > macfile        # UNIX -> Mac\n        tr -d \"\\r\"<dosfile > unixfile          # DOS -> UNIX  Microsoft DOS/Windows 约定，文本的每行以回车字符(\\r)并后跟换行符(\\n)结束\n        awk '{ print $0\"\\r\" }'<unixfile > dosfile   # UNIX -> DOS：在这种情况下，需要用awk，因为tr不能插入两个字符来替换一个字符\n\n    }\n\n    seq{\n\n        # 不指定起始数值，则默认为 1\n        -s   # 选项主要改变输出的分格符, 预设是 \\n\n        -w   # 等位补全，就是宽度相等，不足的前面补 0\n        -f   # 格式化输出，就是指定打印的格式\n\n        seq 10 100               # 列出10-100\n        seq 1 10 |tac            # 倒叙列出\n        seq -s '+' 90 100 |bc    # 从90加到100\n        seq -f 'dir%g' 1 10 | xargs mkdir     # 创建dir1-10\n        seq -f 'dir%03g' 1 10 | xargs mkdir   # 创建dir001-010\n\n    }\n\n    trap{\n\n        信号         说明\n        HUP(1)     # 挂起，通常因终端掉线或用户退出而引发\n        INT(2)     # 中断，通常因按下Ctrl+C组合键而引发\n        QUIT(3)    # 退出，通常因按下Ctrl+\\组合键而引发\n        ABRT(6)    # 中止，通常因某些严重的执行错误而引发\n        ALRM(14)   # 报警，通常用来处理超时\n        TERM(15)   # 终止，通常在系统关机时发送\n\n        trap捕捉到信号之后，可以有三种反应方式：\n            1、执行一段程序来处理这一信号\n            2、接受信号的默认操作\n            3、忽视这一信号\n\n        第一种形式的trap命令在shell接收到 signal list 清单中数值相同的信号时，将执行双引号中的命令串：\n        trap 'commands' signal-list   # 单引号，要在shell探测到信号来的时候才执行命令和变量的替换，时间一直变\n        trap \"commands\" signal-list   # 双引号，shell第一次设置信号的时候就执行命令和变量的替换，时间不变\n\n    }\n\n    awk{\n\n        # 默认是执行打印全部 print $0\n        # 1为真 打印$0\n        # 0为假 不打印\n\n        -F   # 改变FS值(分隔符)\n        ~    # 域匹配\n        ==   # 变量匹配\n        !~   # 匹配不包含\n        =    # 赋值\n        !=   # 不等于\n        +=   # 叠加\n\n        \\b   # 退格\n        \\f   # 换页\n        \\n   # 换行\n        \\r   # 回车\n        \\t   # 制表符Tab\n        \\c   # 代表任一其他字符\n\n        -F\"[ ]+|[%]+\"  # 多个空格或多个%为分隔符\n        [a-z]+         # 多个小写字母\n        [a-Z]          # 代表所有大小写字母(aAbB...zZ)\n        [a-z]          # 代表所有大小写字母(ab...z)\n        [:alnum:]      # 字母数字字符\n        [:alpha:]      # 字母字符\n        [:cntrl:]      # 控制字符\n        [:digit:]      # 数字字符\n        [:graph:]      # 非空白字符(非空格、控制字符等)\n        [:lower:]      # 小写字母\n        [:print:]      # 与[:graph:]相似，但是包含空格字符\n        [:punct:]      # 标点字符\n        [:space:]      # 所有的空白字符(换行符、空格、制表符)\n        [:upper:]      # 大写字母\n        [:xdigit:]     # 十六进制的数字(0-9a-fA-F)\n        [[:digit:][:lower:]]    # 数字和小写字母(占一个字符)\n\n\n        内建变量{\n            $n            # 当前记录的第 n 个字段，字段间由 FS 分隔\n            $0            # 完整的输入记录\n            ARGC          # 命令行参数的数目\n            ARGIND        # 命令行中当前文件的位置 ( 从 0 开始算 )\n            ARGV          # 包含命令行参数的数组\n            CONVFMT       # 数字转换格式 ( 默认值为 %.6g)\n            ENVIRON       # 环境变量关联数组\n            ERRNO         # 最后一个系统错误的描述\n            FIELDWIDTHS   # 字段宽度列表 ( 用空格键分隔 )\n            FILENAME      # 当前文件名\n            FNR           # 同 NR ，但相对于当前文件\n            FS            # 字段分隔符 ( 默认是任何空格 )\n            IGNORECASE    # 如果为真（即非 0 值），则进行忽略大小写的匹配\n            NF            # 当前记录中的字段数(列)\n            NR            # 当前行数\n            OFMT          # 数字的输出格式 ( 默认值是 %.6g)\n            OFS           # 输出字段分隔符 ( 默认值是一个空格 )\n            ORS           # 输出记录分隔符 ( 默认值是一个换行符 )\n            RLENGTH       # 由 match 函数所匹配的字符串的长度\n            RS            # 记录分隔符 ( 默认是一个换行符 )\n            RSTART        # 由 match 函数所匹配的字符串的第一个位置\n            SUBSEP        # 数组下标分隔符 ( 默认值是 /034)\n            BEGIN         # 先处理(可不加文件参数)\n            END           # 结束时处理\n        }\n\n        内置函数{\n            gsub(r,s)          # 在整个$0中用s替代r   相当于 sed 's///g'\n            gsub(r,s,t)        # 在整个t中用s替代r\n            index(s,t)         # 返回s中字符串t的第一位置\n            length(s)          # 返回s长度\n            match(s,r)         # 测试s是否包含匹配r的字符串\n            split(s,a,fs)      # 在fs上将s分成序列a\n            sprint(fmt,exp)    # 返回经fmt格式化后的exp\n            sub(r,s)           # 用$0中最左边最长的子串代替s   相当于 sed 's///'\n            substr(s,p)        # 返回字符串s中从p开始的后缀部分\n            substr(s,p,n)      # 返回字符串s中从p开始长度为n的后缀部分\n        }\n\n        awk判断{\n            awk '{print ($1>$2)?\"第一排\"$1:\"第二排\"$2}'      # 条件判断 括号代表if语句判断 \"?\"代表then \":\"代表else\n            awk '{max=($1>$2)? $1 : $2; print max}'          # 条件判断 如果$1大于$2,max值为为$1,否则为$2\n            awk '{if ( $6 > 50) print $1 \" Too high\" ;\\\n            else print \"Range is OK\"}' file\n            awk '{if ( $6 > 50) { count++;print $3 } \\\n            else { x+5; print $2 } }' file\n        }\n\n        awk循环{\n            awk '{i = 1; while ( i <= NF ) { print NF, $i ; i++ } }' file\n            awk '{ for ( i = 1; i <= NF; i++ ) print NF,$i }' file\n        }\n\n        awk '/Tom/' file               # 打印匹配到得行\n        awk '/^Tom/{print $1}'         # 匹配Tom开头的行 打印第一个字段\n        awk '$1 !~ /ly$/'              # 显示所有第一个字段不是以ly结尾的行\n        awk '$3 <40'                   # 如果第三个字段值小于40才打印\n        awk '$4==90{print $5}'         # 取出第四列等于90的第五列\n        awk '/^(no|so)/' test          # 打印所有以模式no或so开头的行\n        awk '$3 * $4 > 500'            # 算术运算(第三个字段和第四个字段乘积大于500则显示)\n        awk '{print NR\" \"$0}'          # 加行号\n        awk '/tom/,/suz/'              # 打印tom到suz之间的行\n        awk '{a+=$1}END{print a}'      # 列求和\n        awk 'sum+=$1{print sum}'       # 将$1的值叠加后赋给sum\n        awk '{a+=$1}END{print a/NR}'   # 列求平均值\n        awk '!s[$1 $3]++' file         # 根据第一列和第三列过滤重复行\n        awk -F'[ :\\t]' '{print $1,$2}'           # 以空格、:、制表符Tab为分隔符\n        awk '{print \"'\"$a\"'\",\"'\"$b\"'\"}'          # 引用外部变量\n        awk '{if(NR==52){print;exit}}'           # 显示第52行\n        awk '/关键字/{a=NR+2}a==NR {print}'      # 取关键字下第几行\n        awk 'gsub(/liu/,\"aaaa\",$1){print $0}'    # 只打印匹配替换后的行\n        ll | awk -F'[ ]+|[ ][ ]+' '/^$/{print $8}'             # 提取时间,空格不固定\n        awk '{$1=\"\";$2=\"\";$3=\"\";print}'                        # 去掉前三列\n        echo aada:aba|awk '/d/||/b/{print}'                    # 匹配两内容之一\n        echo aada:abaa|awk -F: '$1~/d/||$2~/b/{print}'         # 关键列匹配两内容之一\n        echo Ma asdas|awk '$1~/^[a-Z][a-Z]$/{print }'          # 第一个域匹配正则\n        echo aada:aaba|awk '/d/&&/b/{print}'                   # 同时匹配两条件\n        awk 'length($1)==\"4\"{print $1}'                        # 字符串位数\n        awk '{if($2>3){system (\"touch \"$1)}}'                  # 执行系统命令\n        awk '{sub(/Mac/,\"Macintosh\",$0);print}'                # 用Macintosh替换Mac\n        awk '{gsub(/Mac/,\"MacIntosh\",$1); print}'              # 第一个域内用Macintosh替换Mac\n        awk -F '' '{ for(i=1;i<NF+1;i++)a+=$i  ;print a}'      # 多位数算出其每位数的总和.比如 1234， 得到 10\n        awk '{ i=$1%10;if ( i == 0 ) {print i}}'               # 判断$1是否整除(awk中定义变量引用时不能带 $ )\n        awk 'BEGIN{a=0}{if ($1>a) a=$1 fi}END{print a}'        # 列求最大值  设定一个变量开始为0，遇到比该数大的值，就赋值给该变量，直到结束\n        awk 'BEGIN{a=11111}{if ($1<a) a=$1 fi}END{print a}'    # 求最小值\n        awk '{if(A)print;A=0}/regexp/{A=1}'                    # 查找字符串并将匹配行的下一行显示出来，但并不显示匹配行\n        awk '/regexp/{print A}{A=$0}'                          # 查找字符串并将匹配行的上一行显示出来，但并不显示匹配行\n        awk '{if(!/mysql/)gsub(/1/,\"a\");print $0}'             # 将1替换成a，并且只在行中未出现字串mysql的情况下替换\n        awk 'BEGIN{srand();fr=int(100*rand());print fr;}'      # 获取随机数\n        awk '{if(NR==3)F=1}{if(F){i++;if(i%7==1)print}}'       # 从第3行开始，每7行显示一次\n        awk '{if(NF<1){print i;i=0} else {i++;print $0}}'      # 显示空行分割各段的行数\n        echo +null:null  |awk -F: '$1!~\"^+\"&&$2!=\"null\"{print $0}'       # 关键列同时匹配\n        awk -v RS=@ 'NF{for(i=1;i<=NF;i++)if($i) printf $i;print \"\"}'    # 指定记录分隔符\n        awk '{b[$1]=b[$1]$2}END{for(i in b){print i,b[i]}}'              # 列叠加\n        awk '{ i=($1%100);if ( $i >= 0 ) {print $0,$i}}'                 # 求余数\n        awk '{b=a;a=$1; if(NR>1){print a-b}}'                            # 当前行减上一行\n        awk '{a[NR]=$1}END{for (i=1;i<=NR;i++){print a[i]-a[i-1]}}'      # 当前行减上一行\n        awk -F: '{name[x++]=$1};END{for(i=0;i<NR;i++)print i,name[i]}'   # END只打印最后的结果,END块里面处理数组内容\n        awk '{sum2+=$2;count=count+1}END{print sum2,sum2/count}'         # $2的总和  $2总和除个数(平均值)\n        awk -v a=0 -F 'B' '{for (i=1;i<NF;i++){ a=a+length($i)+1;print a  }}'     # 打印所以B的所在位置\n        awk 'BEGIN{ \"date\" | getline d; split(d,mon) ; print mon[2]}' file        # 将date值赋给d，并将d设置为数组mon，打印mon数组中第2个元素\n        awk 'BEGIN{info=\"this is a test2010test!\";print substr(info,4,10);}'      # 截取字符串(substr使用)\n        awk 'BEGIN{info=\"this is a test2010test!\";print index(info,\"test\")?\"ok\":\"no found\";}'      # 匹配字符串(index使用)\n        awk 'BEGIN{info=\"this is a test2010test!\";print match(info,/[0-9]+/)?\"ok\":\"no found\";}'    # 正则表达式匹配查找(match使用)\n        awk '{for(i=1;i<=4;i++)printf $i\"\"FS; for(y=10;y<=13;y++)  printf $y\"\"FS;print \"\"}'        # 打印前4列和后4列\n        awk 'BEGIN{for(n=0;n++<9;){for(i=0;i++<n;)printf i\"x\"n\"=\"i*n\" \";print \"\"}}'                # 乘法口诀\n        awk 'BEGIN{info=\"this is a test\";split(info,tA,\" \");print length(tA);for(k in tA){print k,tA[k];}}'             # 字符串分割(split使用)\n        awk '{if (system (\"grep \"$2\" tmp/* > /dev/null 2>&1\") == 0 ) {print $1,\"Y\"} else {print $1,\"N\"} }' a            # 执行系统命令判断返回状态\n        awk  '{for(i=1;i<=NF;i++) a[i,NR]=$i}END{for(i=1;i<=NF;i++) {for(j=1;j<=NR;j++) printf a[i,j] \" \";print \"\"}}'   # 将多行转多列\n        netstat -an|awk -v A=$IP -v B=$PORT 'BEGIN{print \"Clients\\tGuest_ip\"}$4~A\":\"B{split($5,ip,\":\");a[ip[1]]++}END{for(i in a)print a[i]\"\\t\"i|\"sort -nr\"}'    # 统计IP连接个数\n        cat 1.txt|awk -F\" # \" '{print \"insert into user (user,password,email)values(\"\"'\\''\"$1\"'\\'\\,'\"\"'\\''\"$2\"'\\'\\,'\"\"'\\''\"$3\"'\\'\\)\\;'\"}' >>insert_1.txt     # 处理sql语句\n        awk 'BEGIN{printf \"what is your name?\";getline name < \"/dev/tty\" } $1 ~name {print \"FOUND\" name \" on line \", NR \".\"} END{print \"see you,\" name \".\"}' file  # 两文件匹配\n\n        取本机IP{\n            /sbin/ifconfig |awk -v RS=\"Bcast:\" '{print $NF}'|awk -F: '/addr/{print $2}'\n            /sbin/ifconfig |awk '/inet/&&$2!~\"127.0.0.1\"{split($2,a,\":\");print a[2]}'\n            /sbin/ifconfig |awk -v RS='inet addr:' '$1!=\"eth0\"&&$1!=\"127.0.0.1\"{print $1}'|awk '{printf\"%s|\",$0}'\n            /sbin/ifconfig |awk  '{printf(\"line %d,%s\\n\",NR,$0)}'         # 指定类型(%d数字,%s字符)\n        }\n\n        查看磁盘空间{\n            df -h|awk -F\"[ ]+|%\" '$5>14{print $5}'\n            df -h|awk 'NR!=1{if ( NF == 6 ) {print $5} else if ( NF == 5) {print $4} }'\n            df -h|awk 'NR!=1 && /%/{sub(/%/,\"\");print $(NF-1)}'\n            df -h|sed '1d;/ /!N;s/\\n//;s/ \\+/ /;'    #将磁盘分区整理成一行   可直接用 df -P\n        }\n\n        排列打印{\n            awk 'END{printf \"%-10s%-10s\\n%-10s%-10s\\n%-10s%-10s\\n\",\"server\",\"name\",\"123\",\"12345\",\"234\",\"1234\"}' txt\n            awk 'BEGIN{printf \"|%-10s|%-10s|\\n|%-10s|%-10s|\\n|%-10s|%-10s|\\n\",\"server\",\"name\",\"123\",\"12345\",\"234\",\"1234\"}'\n            awk 'BEGIN{\n            print \"   *** 开 始 ***   \";\n            print \"+-----------------+\";\n            printf \"|%-5s|%-5s|%-5s|\\n\",\"id\",\"name\",\"ip\";\n            }\n            $1!=1 && NF==4{printf \"|%-5s|%-5s|%-5s|\\n\",$1,$2,$3\" \"$11}\n            END{\n            print \"+-----------------+\";\n            print \"   *** 结 束 ***   \"\n            }' txt\n        }\n\n        awk经典题{\n            分析图片服务日志，把日志（每个图片访问次数*图片大小的总和）排行，也就是计算每个url的总访问大小\n            说明：本题生产环境应用：这个功能可以用于IDC网站流量带宽很高，然后通过分析服务器日志哪些元素占用流量过大，进而进行优化或裁剪该图片，压缩js等措施。\n            本题需要输出三个指标： 【被访问次数】    【访问次数*单个被访问文件大小】   【文件名（带URL）】\n            测试数据\n            59.33.26.105 - - [08/Dec/2010:15:43:56 +0800] \"GET /static/images/photos/2.jpg HTTP/1.1\" 200 11299\n\n            awk '{array_num[$7]++;array_size[$7]+=$10}END{for(i in array_num) {print array_num[i]\" \"array_size[i]\" \"i}}'\n        }\n\n        awk练习题{\n\n            wang     4\n            cui      3\n            zhao     4\n            liu      3\n            liu      3\n            chang    5\n            li       2\n\n            1 通过第一个域找出字符长度为4的\n            2 当第二列值大于3时，创建空白文件，文件名为当前行第一个域$1 (touch $1)\n            3 将文档中 liu 字符串替换为 hong\n            4 求第二列的和\n            5 求第二列的平均值\n            6 求第二列中的最大值\n            7 将第一列过滤重复后，列出每一项，每一项的出现次数，每一项的大小总和\n\n            1、字符串长度\n                awk 'length($1)==\"4\"{print $1}'\n            2、执行系统命令\n                awk '{if($2>3){system (\"touch \"$1)}}'\n            3、gsub(/r/,\"s\",域) 在指定域(默认$0)中用s替代r  (sed 's///g')\n                awk '{gsub(/liu/,\"hong\",$1);print $0}' a.txt\n            4、列求和\n                awk '{a+=$2}END{print a}'\n            5、列求平均值\n                awk '{a+=$2}END{print a/NR}'\n                awk '{a+=$2;b++}END{print a,a/b}'\n            6、列求最大值\n                awk 'BEGIN{a=0}{if($2>a) a=$2 }END{print a}'\n            7、将第一列过滤重复列出每一项，每一项的出现次数，每一项的大小总和\n                awk '{a[$1]++;b[$1]+=$2}END{for(i in a){print i,a[i],b[i]}}'\n        }\n\n        awk处理复杂日志{\n            6.19：\n            DHB_014_号百总机服务业务日报：广州 到达数异常！\n            DHB_023_号百漏话提醒日报：珠海 到达数异常！\n            6.20：\n            DHB_014_号百总机服务业务日报：广州 到达数异常！到\n\n            awk -F '[_ ：]+' 'NF>2{print $4,$1\"_\"$2,b |\"sort\";next}{b=$1}'\n\n            # 当前行NF小于等于2 只针对{print $4,$1\"_\"$2,b |\"sort\";next} 有效 即 6.19：行跳过此操作,  {b=$1} 仍然执行\n            # 当前行NF大于2 执行到 next 强制跳过本行，即跳过后面的 {b=$1}\n\n            广州 DHB_014 6.19\n        }\n    }\n\n    sed{\n\n        # 先读取资料、存入模式空间、对其进行编辑、再输出、再用下一行替换模式空间内容\n        # 调试工具sedsed (参数 -d)   http://aurelio.net/sedsed/sedsed-1.0\n\n        -n   # 输出由编辑指令控制(取消默认的输出,必须与编辑指令一起配合)\n        -i   # 直接对文件操作\n        -e   # 多重编辑\n        -r   # 正则可不转移特殊字符\n\n        b    # 跳过匹配的行\n        p    # 打印\n        d    # 删除\n        s    # 替换\n        g    # 配合s全部替换\n        i    # 行前插入\n        a    # 行后插入\n        r    # 读\n        y    # 转换\n        q    # 退出\n\n        &    # 代表查找的串内容\n        *    # 任意多个 前驱字符(前导符)\n        ?    # 0或1个 最小匹配 没加-r参数需转义 \\?\n        $    # 最后一行\n        .*   # 匹配任意多个字符\n        \\(a\\)   # 保存a作为标签1(\\1)\n\n        模式空间{\n\n            # 模式空间(两行两行处理) 模式匹配的范围，一般而言，模式空间是输入文本中某一行，但是可以通过使用N函数把多于一行读入模式空间\n            # 暂存空间里默认存储一个空行\n            n   # 读入下一行(覆盖上一行)\n            h   # 把模式空间里的行拷贝到暂存空间\n            H   # 把模式空间里的行追加到暂存空间\n            g   # 用暂存空间的内容替换模式空间的行\n            G   # 把暂存空间的内容追加到模式空间的行后\n            x   # 将暂存空间的内容于模式空间里的当前行互换\n            ！  # 对其前面的要匹配的范围取反\n            D   # 删除当前模式空间中直到并包含第一个换行符的所有字符(/.*/匹配模式空间中所有内容，匹配到就执行D,没匹配到就结束D)\n            N   # 追加下一个输入行到模式空间后面并在第二者间嵌入一个换行符，改变当前行号码,模式匹配可以延伸跨域这个内嵌换行\n            p   # 打印模式空间中的直到并包含第一个换行的所有字符\n\n        }\n\n        标签函数{\n\n            : lable # 建立命令标记，配合b，t函数使用跳转\n            b lable # 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。\n            t labe  # 判断分支，从最后一行开始，条件一旦满足或者T,t命令，将导致分支到带有标号的命令出，或者到脚本末尾。与b函数不同在于t在执行跳转前会先检查其前一个替换命令是否成功，如成功，则执行跳转。\n\n            sed -e '{:p1;/A/s/A/AA/;/B/s/B/BB/;/[AB]\\{10\\}/b;b p1;}'     # 文件内容第一行A第二行B:建立标签p1;两个替换函数(A替换成AA,B替换成BB)当A或者B达到10个以后调用b,返回\n            echo 'sd  f   f   [a    b      c    cddd    eee]' | sed ':n;s#\\(\\[[^ ]*\\)  *#\\1#;tn'  # 标签函数t使用方法,替换[]里的空格\n            echo \"198723124.03\"|sed -r ':a;s/([0-9]+)([0-9]{3})/\\1,\\2/;ta'  # 每三个字符加一个逗号\n\n        }\n\n        引用外部变量{\n\n            sed -n ''$a',10p'\n            sed -n \"\"$a\",10p\"\n\n        }\n\n        sed 10q                                       # 显示文件中的前10行 (模拟\"head\")\n        sed -n '$='                                   # 计算行数(模拟 \"wc -l\")\n        sed -n '5,/^no/p'                             # 打印从第5行到以no开头行之间的所有行\n        sed -i \"/^$f/d\" a     　　                  　 # 删除匹配行\n        sed -i '/aaa/,$d'                             # 删除匹配行到末尾\n        sed -i \"s/=/:/\" c                             # 直接对文本替换\n        sed -i \"/^pearls/s/$/j/\"                      # 找到pearls开头在行尾加j\n        sed '/1/,/3/p' file                           # 打印1和3之间的行\n        sed -n '1p' file                              # 取出指定行\n        sed '5i\\aaa' file                             # 在第5行之前插入行\n        sed '5a\\aaa' file                             # 在第5行之后抽入行\n        echo a|sed -e '/a/i\\b'                        # 在匹配行前插入一行\n        echo a|sed -e '/a/a\\b'                        # 在匹配行后插入一行\n        echo a|sed 's/a/&\\nb/g'                       # 在匹配行后插入一行\n        seq 10| sed -e{1,3}'s/./a/'                   # 匹配1和3行替换\n        sed -n '/regexp/!p'                           # 只显示不匹配正则表达式的行\n        sed '/regexp/d'                               # 只显示不匹配正则表达式的行\n        sed '$!N;s/\\n//'                              # 将每两行连接成一行\n        sed '/baz/s/foo/bar/g'                        # 只在行中出现字串\"baz\"的情况下将\"foo\"替换成\"bar\"\n        sed '/baz/!s/foo/bar/g'                       # 将\"foo\"替换成\"bar\"，并且只在行中未出现字串\"baz\"的情况下替换\n        echo a|sed -e 's/a/#&/g'                      # 在a前面加#号\n        sed 's/foo/bar/4'                             # 只替换每一行中的第四个字串\n        sed 's/\\(.*\\)foo/\\1bar/'                      # 替换每行最后一个字符串\n        sed 's/\\(.*\\)foo\\(.*foo\\)/\\1bar\\2/'           # 替换倒数第二个字符串\n        sed 's/[0-9][0-9]$/&5'                        # 在以[0-9][0-9]结尾的行后加5\n        sed -n ' /^eth\\|em[01][^:]/{n;p;}'            # 匹配多个关键字\n        sed -n -r ' /eth|em[01][^:]/{n;p;}'           # 匹配多个关键字\n        echo -e \"1\\n2\"|xargs -i -t sed 's/^/1/' {}    # 同时处理多个文件\n        sed '/west/,/east/s/$/*VACA*/'                # 修改west和east之间的所有行，在结尾处加*VACA*\n        sed  's/[^1-9]*\\([0-9]\\+\\).*/\\1/'             # 取出第一组数字，并且忽略掉开头的0\n        sed -n '/regexp/{g;1!p;};h'                   # 查找字符串并将匹配行的上一行显示出来，但并不显示匹配行\n        sed -n ' /regexp/{n;p;}'                      # 查找字符串并将匹配行的下一行显示出来，但并不显示匹配行\n        sed -n 's/\\(mar\\)got/\\1ianne/p'               # 保存\\(mar\\)作为标签1\n        sed -n 's/\\([0-9]\\+\\).*\\(t\\)/\\2\\1/p'          # 保存多个标签\n        sed -i -e '1,3d' -e 's/1/2/'                  # 多重编辑(先删除1-3行，在将1替换成2)\n        sed -e 's/@.*//g' -e '/^$/d'                  # 删除掉@后面所有字符，和空行\n        sed -n -e \"{s/^ *[0-9]*//p}\"                  # 打印并删除正则表达式的那部分内容\n        echo abcd|sed 'y/bd/BE/'                      # 匹配字符替换\n        sed '/^#/b;y/y/P/' 2                          # 非#号开头的行替换字符\n        sed '/suan/r readfile'                        # 找到含suan的行，在后面加上读入的文件内容\n        sed -n '/no/w writefile'                      # 找到含no的行，写入到指定文件中\n        sed '/regex/G'                                # 在匹配式样行之后插入一空行\n        sed '/regex/{x;p;x;G;}'                       # 在匹配式样行之前和之后各插入一空行\n        sed 'n;d'                                     # 删除所有偶数行\n        sed 'G;G'                                     # 在每一行后面增加两空行\n        sed '/^$/d;G'                                 # 在输出的文本中每一行后面将有且只有一空行\n        sed 'n;n;n;n;G;'                              # 在每5行后增加一空白行\n        sed -n '5~5p'                                 # 只打印行号为5的倍数\n        seq 1 30|sed  '5~5s/.*/a/'                    # 倍数行执行替换\n        sed -n '3,${p;n;n;n;n;n;n;}'                  # 从第3行开始，每7行显示一次\n        sed -n 'h;n;G;p'                              # 奇偶调换\n        seq 1 10|sed '1!G;h;$!d'                      # 倒叙排列\n        ls -l|sed -n '/^.rwx.*/p'                     # 查找属主权限为7的文件\n        sed = filename | sed 'N;s/\\n/\\t/'             # 为文件中的每一行进行编号(简单的左对齐方式)\n        sed 's/^[ \\t]*//'                             # 将每一行前导的\"空白字符\"(空格，制表符)删除,使之左对齐\n        sed 's/^[ \\t]*//;s/[ \\t]*$//'                 # 将每一行中的前导和拖尾的空白字符删除\n        sed '/{abc,def\\}\\/\\[111,222]/s/^/00000/'      # 匹配需要转行的字符: } / [\n        echo abcd\\\\nabcde |sed 's/\\\\n/@/g' |tr '@' '\\n'        # 将换行符转换为换行\n        cat tmp|awk '{print $1}'|sort -n|sed -n '$p'           # 取一列最大值\n        sed -n '{s/^[^\\/]*//;s/\\:.*//;p}' /etc/passwd          # 取用户家目录(匹配不为/的字符和匹配:到结尾的字符全部删除)\n        sed = filename | sed 'N;s/^/      /; s/ *\\(.\\{6,\\}\\)\\n/\\1   /'   # 对文件中的所有行编号(行号在左，文字右端对齐)\n        /sbin/ifconfig |sed 's/.*inet addr:\\(.*\\) Bca.*/\\1/g' |sed -n '/eth/{n;p}'   # 取所有IP\n\n        修改keepalive配置剔除后端服务器{\n\n            sed -i '/real_server.*10.0.1.158.*8888/,+8 s/^/#/' keepalived.conf\n            sed -i '/real_server.*10.0.1.158.*8888/,+8 s/^#//' keepalived.conf\n\n        }\n\n        模仿rev功能{\n\n            echo 123 |sed '/\\n/!G;s/\\(.\\)\\(.*\\n\\)/&\\2\\1/;//D;s/.//;'\n            /\\n/!G;         　　　　　　# 没有\\n换行符，要执行G,因为保留空间中为空，所以在模式空间追加一空行\n            s/\\(.\\)\\(.*\\n\\)/&\\2\\1/;     # 标签替换 &\\n23\\n1$ (关键在于& ,可以让后面//匹配到空行)\n            //D;            　　　　　　# D 命令会引起循环删除模式空间中的第一部分，如果删除后，模式空间中还有剩余行，则返回 D 之前的命令，重新执行，如果 D 后，模式空间中没有任何内容，则将退出。  //D 匹配空行执行D,如果上句s没有匹配到,//也无法匹配到空行, \"//D;\"命令结束\n            s/.//;          　　　　　　# D结束后,删除开头的 \\n\n\n        }\n\n    }\n\n    xargs{\n\n        # 命令替换\n        -t 先打印命令，然后再执行\n        -i 用每项替换 {}\n        find / -perm +7000 | xargs ls -l                    # 将前面的内容，作为后面命令的参数\n        seq 1 10 |xargs  -i date -d \"{} days \" +%Y-%m-%d    # 列出10天日期\n\n    }\n\n    dialog菜单{\n\n        # 默认将所有输出用 stderr 输出，不显示到屏幕   使用参数  --stdout 可将选择赋给变量\n        # 退出状态  0正确  1错误\n\n        窗体类型{\n            --calendar          # 日历\n            --checklist         # 允许你显示一个选项列表，每个选项都可以被单独的选择 (复选框)\n            --form              # 表单,允许您建立一个带标签的文本字段，并要求填写\n            --fselect           # 提供一个路径，让你选择浏览的文件\n            --gauge             # 显示一个表，呈现出完成的百分比，就是显示出进度条。\n            --infobox           # 显示消息后，（没有等待响应）对话框立刻返回，但不清除屏幕(信息框)\n            --inputbox          # 让用户输入文本(输入框)\n            --inputmenu         # 提供一个可供用户编辑的菜单（可编辑的菜单框）\n            --menu              # 显示一个列表供用户选择(菜单框)\n            --msgbox(message)   # 显示一条消息,并要求用户选择一个确定按钮(消息框)\n            --password          # 密码框，显示一个输入框，它隐藏文本\n            --pause             # 显示一个表格用来显示一个指定的暂停期的状态\n            --radiolist         # 提供一个菜单项目组，但是只有一个项目，可以选择(单选框)\n            --tailbox           # 在一个滚动窗口文件中使用tail命令来显示文本\n            --tailboxbg         # 跟tailbox类似，但是在background模式下操作\n            --textbox           # 在带有滚动条的文本框中显示文件的内容  (文本框)\n            --timebox           # 提供一个窗口，选择小时，分钟，秒\n            --yesno(yes/no)     # 提供一个带有yes和no按钮的简单信息框\n        }\n\n        窗体参数{\n            --separate-output          # 对于chicklist组件,输出结果一次输出一行,得到结果不加引号\n            --ok-label \"提交\"          # 确定按钮名称\n            --cancel-label \"取消\"      # 取消按钮名称\n            --title \"标题\"             # 标题名称\n            --stdout                   # 将所有输出用 stdout 输出\n            --backtitle \"上标\"         # 窗体上标\n            --no-shadow                # 去掉窗体阴影\n            --menu \"菜单名\" 20 60 14   # 菜单及窗口大小\n            --clear                    # 完成后清屏操作\n            --no-cancel                # 不显示取消项\n            --insecure                 # 使用星号来代表每个字符\n            --begin <y> <x>            # 指定对话框左上角在屏幕的上的做坐标\n            --timeout <秒>             # 超时,返回的错误代码255,如果用户在指定的时间内没有给出相应动作,就按超时处理\n            --defaultno                # 使选择默认为no\n            --default-item <str>       # 设置在一份清单，表格或菜单中的默认项目。通常在框中的第一项是默认\n            --sleep 5                  # 在处理完一个对话框后静止(延迟)的时间(秒)\n            --max-input size           # 限制输入的字符串在给定的大小之内。如果没有指定，默认是2048\n            --keep-window              # 退出时不清屏和重绘窗口。当几个组件在同一个程序中运行时，对于保留窗口内容很有用的\n        }\n\n        dialog --title \"Check me\" --checklist \"Pick Numbers\" 15 25 3 1 \"one\" \"off\" 2 \"two\" \"on\"         # 多选界面[方括号]\n        dialog --title \"title\" --radiolist \"checklist\" 20 60 14 tag1 \"item1\" on tag2 \"item2\" off        # 单选界面(圆括号)\n        dialog --title \"title\" --menu \"MENU\" 20 60 14 tag1 \"item1\" tag2 \"item2\"                         # 单选界面\n        dialog --title \"Installation\" --backtitle \"Star Linux\" --gauge \"Linux Kernel\"  10 60 50         # 进度条\n        dialog --title \"标题\" --backtitle \"Dialog\" --yesno \"说明\" 20 60                                 # 选择yes/no\n        dialog --title \"公告标题\" --backtitle \"Dialog\" --msgbox \"内容\" 20 60                            # 公告\n        dialog --title \"hey\" --backtitle \"Dialog\" --infobox \"Is everything okay?\" 10 60                 # 显示讯息后立即离开\n        dialog --title \"hey\" --backtitle \"Dialog\" --inputbox \"Is okay?\" 10 60 \"yes\"                     # 输入对话框\n        dialog --title \"Array 30\" --backtitle \"All \" --textbox /root/txt 20 75                          # 显示文档内容\n        dialog --title \"Add\" --form \"input\" 12 40 4 \"user\" 1 1 \"\" 1 15 15 0 \"name\" 2 1 \"\" 2 15 15 0     # 多条输入对话框\n        dialog --title  \"Password\"  --insecure  --passwordbox  \"请输入密码\"  10  35                     # 星号显示输入--insecure\n        dialog --stdout --title \"日历\"  --calendar \"请选择\" 0 0 9 1 2010                                # 选择日期\n        dialog --title \"title\" --menu \"MENU\" 20 60 14 tag1 \"item1\" tag2 \"item2\" 2>tmp                   # 取到结果放到文件中(以标准错误输出结果)\n        a=`dialog --title \"title\"  --stdout --menu \"MENU\" 20 60 14 tag1 \"item1\" tag2 \"item2\"`           # 选择操作赋给变量(使用标准输出)\n\n        dialog菜单实例{\n            while :\n            do\n            clear\n            menu=`dialog --title \"title\"  --stdout --menu \"MENU\" 20 60 14 1 system 2 custom`\n            [ $? -eq 0 ] && echo \"$menu\" || exit         # 判断dialog执行,取消退出\n                while :\n                do\n                    case $menu in\n                    1)\n                        list=\"1a \"item1\" 2a \"item2\"\"     # 定义菜单列表变量\n                    ;;\n                    2)\n                        list=\"1b \"item3\" 2b \"item4\"\"\n                    ;;\n                    esac\n                    result=`dialog --title \"title\"  --stdout --menu \"MENU\" 20 60 14 $list`\n                    [ $? -eq 0 ] && echo \"$result\" || break    # 判断dialog执行,取消返回菜单,注意:配合上层菜单循环\n                    read\n                done\n            done\n        }\n\n    }\n\n    select菜单{\n\n        # 输入项不在菜单自动会提示重新输入\n        select menuitem in pick1 pick2 pick3 退出\n        do\n            echo $menuitem\n            case $menuitem in\n            退出)\n                exit\n            ;;\n            *)\n                select area in area1 area2 area3 返回\n                do\n                    echo $area\n                    case $area in\n                    返回)\n                        break\n                    ;;\n                    *)\n                        echo \"对$area操作\"\n                    ;;\n                    esac\n                done\n            ;;\n            esac\n        done\n\n    }\n\n    shift{\n\n        ./cs.sh 1 2 3\n        #!/bin/sh\n        until [ $# -eq 0 ]\n        do\n            echo \"第一个参数为: $1 参数个数为: $#\"\n            #shift 命令执行前变量 $1 的值在shift命令执行后不可用\n            shift\n        done\n\n    }\n\n    getopts给脚本加参数{\n\n        #!/bin/sh\n        while getopts :ab: name\n        do\n            case $name in\n            a)\n                aflag=1\n            ;;\n            b)\n                bflag=1\n                bval=$OPTARG\n            ;;\n            \\?)\n                echo \"USAGE:`basename $0` [-a] [-b value]\"\n                exit  1\n            ;;\n            esac\n        done\n        if [ ! -z $aflag ] ; then\n            echo \"option -a specified\"\n            echo \"$aflag\"\n            echo \"$OPTIND\"\n        fi\n        if [ ! -z $bflag ] ; then\n            echo  \"option -b specified\"\n            echo  \"$bflag\"\n            echo  \"$bval\"\n            echo  \"$OPTIND\"\n        fi\n        echo \"here  $OPTIND\"\n        shift $(($OPTIND -1))\n        echo \"$OPTIND\"\n        echo \" `shift $(($OPTIND -1))`  \"\n\n    }\n\n    tclsh{\n\n        set foo \"a bc\"                   # 定义变量\n        set b {$a};                      # 转义  b的值为\" $a \" ,而不是变量结果\n        set a 3; incr a 3;               # 数字的自增.  将a加3,如果要减3,则为 incr a –3;\n        set c [expr 20/5];               # 计算  c的值为4\n        puts $foo;                       # 打印变量\n        set qian(123) f;                 # 定义数组\n        set qian(1,1,1) fs;              # 多维数组\n        parray qian;                     # 打印数组的所有信息\n        string length $qian;             # 将返回变量qian的长度\n        string option string1 string2;   # 字符相关串操作\n        # option 的操作选项:\n        # compare           按照字典的排序方式进行比较。根据string1 <,=,>string2分别返回-1,0,1\n        # first             返回string2中第一次出现string1的位置，如果没有出现string1则返回-1\n        # last              和first相反\n        # trim              从string1中删除开头和结尾的出现在string2中的字符\n        # tolower           返回string1中的所有字符被转换为小写字符后的新字符串\n        # toupper           返回string1中的所有字符串转换为大写后的字符串\n        # length            返回string1的长度\n        set a 1;while {$a < 3} { set a [incr a 1;]; };puts $a    # 判断变量a小于3既循环\n        for {initialization} {condition} {increment} {body}      # 初始化变量,条件,增量,具体操作\n        for {set i 0} {$i < 10} {incr i} {puts $i;}              # 将打印出0到9\n        if { 表达式 } {\n             #运算;\n        } else {\n             #其他运算;\n        }\n        switch $x {\n            字符串1 { 操作1 ;}\n            字符串2 { 操作2 ;}\n        }\n        foreach element {0 m n b v} {\n        # 将在一组变元中进行循环，并且每次都将执行他的循环体\n               switch $element {\n                     # 判断element的值\n             }\n        }\n\n        expect交互{\n\n            exp_continue         # 多个spawn命令时并行\n            interact             # 执行完成后保持交互状态，把控制权交给控制台\n            expect \"password:\"   # 判断关键字符\n            send \"passwd\\r\"      # 执行交互动作，与手工输入密码的动作等效。字符串结尾加\"\\r\"\n\n            ssh后sudo{\n\n                #!/bin/bash\n                #sudo注释下行允许后台运行\n                #Defaults requiretty\n                #sudo去掉!允许远程\n                #Defaults !visiblepw\n\n                /usr/bin/expect -c '\n                set timeout 5\n                spawn ssh -o StrictHostKeyChecking=no xuesong1@192.168.42.128 \"sudo grep xuesong1 /etc/passwd\"\n                expect {\n                    \"passphrase\" {\n                        send_user \"sshkey\\n\"\n                        send \"xuesong\\r\";\n                        expect {\n                            \"sudo\" {\n                            send_user \"sudo\\n\"\n                            send \"xuesong\\r\"\n                            interact\n                            }\n                            eof {\n                            send_user \"sudo eof\\n\"\n                            }\n                        }\n                    }\n                    \"password:\" {\n                        send_user \"ssh\\n\"\n                        send \"xuesong\\r\";\n                        expect {\n                            \"sudo\" {\n                            send_user \"sudo\\n\"\n                            send \"xuesong\\r\"\n                            interact\n                            }\n                            eof {\n                            send_user \"sudo eof\\n\"\n                            }\n                        }\n                    }\n                    \"sudo\" {\n                            send_user \"sudo\\n\"\n                            send \"xuesong\\r\"\n                            interact\n                            }\n                    eof {\n                        send_user \"ssh eof\\n\"\n                    }\n                }\n                '\n\n            }\n\n            ssh执行命令操作{\n\n                /usr/bin/expect -c \"\n                proc jiaohu {} {\n                    send_user expect_start\n                    expect {\n                        password {\n                            send ${RemotePasswd}\\r;\n                            send_user expect_eof\n                            expect {\n                                \\\"does not exist\\\" {\n                                    send_user expect_failure\n                                    exit 10\n                                }\n                                password {\n                                    send_user expect_failure\n                                    exit 5\n                                }\n                                Password {\n                                    send ${RemoteRootPasswd}\\r;\n                                    send_user expect_eof\n                                    expect {\n                                        incorrect {\n                                            send_user expect_failure\n                                            exit 6\n                                        }\n                                        eof\n                                    }\n                                }\n                                eof\n                            }\n                        }\n                        passphrase {\n                            send ${KeyPasswd}\\r;\n                            send_user expect_eof\n                            expect {\n                                \\\"does not exist\\\" {\n                                    send_user expect_failure\n                                    exit 10\n                                }\n                                passphrase{\n                                    send_user expect_failure\n                                    exit 7\n                                }\n                                Password {\n                                    send ${RemoteRootPasswd}\\r;\n                                    send_user expect_eof\n                                    expect {\n                                        incorrect {\n                                            send_user expect_failure\n                                            exit 6\n                                        }\n                                        eof\n                                    }\n                                }\n                                eof\n                            }\n                        }\n                        Password {\n                            send ${RemoteRootPasswd}\\r;\n                            send_user expect_eof\n                            expect {\n                                incorrect {\n                                    send_user expect_failure\n                                    exit 6\n                                }\n                                eof\n                            }\n                        }\n                        \\\"No route to host\\\" {\n                            send_user expect_failure\n                            exit 4\n                        }\n                        \\\"Invalid argument\\\" {\n                            send_user expect_failure\n                            exit 8\n                        }\n                        \\\"Connection refused\\\" {\n                            send_user expect_failure\n                            exit 9\n                        }\n                        \\\"does not exist\\\" {\n                            send_user expect_failure\n                            exit 10\n                        }\n\n                        \\\"Connection timed out\\\" {\n                            send_user expect_failure\n                            exit 11\n                        }\n                        timeout {\n                            send_user expect_failure\n                            exit 3\n                        }\n                        eof\n                    }\n                }\n                set timeout $TimeOut\n                switch $1 {\n                    Ssh_Cmd {\n                        spawn ssh -t -p $Port -o StrictHostKeyChecking=no $RemoteUser@$Ip /bin/su - root -c \\\\\\\"$Cmd\\\\\\\"\n                        jiaohu\n                    }\n                    Ssh_Script {\n                        spawn scp -P $Port -o StrictHostKeyChecking=no $ScriptPath $RemoteUser@$Ip:/tmp/${ScriptPath##*/};\n                        jiaohu\n                        spawn ssh -t -p $Port -o StrictHostKeyChecking=no $RemoteUser@$Ip /bin/su - root -c  \\\\\\\"/bin/sh /tmp/${ScriptPath##*/}\\\\\\\" ;\n                        jiaohu\n                    }\n                    Scp_File {\n                        spawn scp -P $Port -o StrictHostKeyChecking=no -r $ScpPath $RemoteUser@$Ip:${ScpRemotePath};\n                        jiaohu\n                    }\n                }\n                \"\n                state=`echo $?`\n\n            }\n\n            交互双引号引用较长变量{\n\n                #!/bin/bash\n                RemoteUser=xuesong12\n                Ip=192.168.1.2\n                RemotePasswd=xuesong\n                Cmd=\"/bin/echo \"$PubKey\" > \"$RemoteKey\"/authorized_keys\"\n\n                /usr/bin/expect -c \"\n                set timeout 10\n                spawn ssh -o StrictHostKeyChecking=no $RemoteUser@$Ip {$Cmd};\n                expect {\n                    password: {\n                        send_user RemotePasswd\\n\n                        send ${RemotePasswd}\\r;\n                        interact;\n                    }\n                    eof {\n                        send_user eof\\n\n                    }\n                }\n                \"\n\n            }\n\n            telnet交互{\n\n                #!/bin/bash\n                Ip=\"10.0.1.53\"\n                a=\"\\{\\'method\\'\\:\\'doLogin\\'\\,\\'params\\'\\:\\{\\'uName\\'\\:\\'bobbietest\\'\\}\"\n                /usr/bin/expect -c\"\n                        set timeout 15\n                        spawn telnet ${Ip} 8000\n                        expect \"Escape\"\n                        send \"${a}\\\\r\"\n                        expect {\n                                -re \"\\\"err.*none\\\"\" {\n                                        exit 0\n                                }\n                                timeout {\n                                        exit 1\n                                }\n                                eof {\n                                        exit 2\n                                }\n                        }\n                \"\n                echo $?\n\n            }\n\n            模拟ssh登录{\n                #好处:可加载环境变量\n\n                #!/bin/bash\n                Ip='192.168.1.6'            # 循环就行\n                RemoteUser='user'           # 普通用户\n                RemotePasswd='userpasswd'   # 普通用户的密码\n                RemoteRootPasswd='rootpasswd'\n                /usr/bin/expect -c \"\n                set timeout -1\n                spawn ssh -t -p $Port -o StrictHostKeyChecking=no $RemoteUser@$Ip\n                expect {\n                    password {\n                        send_user RemotePasswd\n                        send ${RemotePasswd}\\r;\n                        expect {\n                            \\\"does not exist\\\" {\n                                send_user \\\"root user does not exist\\n\\\"\n                                exit 10\n                            }\n                            password {\n                                send_user \\\"user passwd error\\n\\\"\n                                exit 5\n                            }\n                            Last {\n                                send \\\"su - batch\\n\\\"\n                                expect {\n                                    Password {\n                                        send_user RemoteRootPasswd\n                                        send ${RemoteRootPasswd}\\r;\n                                        expect {\n                                            \\\"]#\\\" {\n                                                send \\\"sh /tmp/update.sh update\\n \\\"\n                                                expect {\n                                                    \\\"]#\\\" {\n                                                        send_user ${Ip}_Update_Done\\n\n                                                    }\n                                                    eof\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    \\\"No route to host\\\" {\n                        send_user \\\"host not found\\n\\\"\n                        exit 4\n                    }\n                    \\\"Invalid argument\\\" {\n                        send_user \\\"incorrect parameter\\n\\\"\n                        exit 8\n                    }\n                    \\\"Connection refused\\\" {\n                        send_user \\\"invalid port parameters\\n\\\"\n                        exit 9\n                    }\n                    \\\"does not exist\\\" {\n                        send_user \\\"root user does not exist\\\"\n                        exit 10\n                    }\n                    timeout {\n                        send_user \\\"connection timeout \\n\\\"\n                        exit 3\n                    }\n                    eof\n                }\n                \"\n                state=`echo $?`\n\n            }\n\n        }\n\n    }\n\n}\n\n9 实例{\n\n    从1叠加到100{\n\n        echo $[$(echo +{1..100})]\n        echo $[(100+1)*(100/2)]\n        seq -s '+' 100 |bc\n\n    }\n\n    判断参数是否为空-空退出并打印null{\n\n        #!/bin/sh\n        echo $1\n        name=${1:?\"null\"}\n        echo $name\n\n    }\n\n    循环数组{\n\n        for ((i=0;i<${#o[*]};i++))\n        do\n            echo ${o[$i]}\n        done\n\n    }\n\n    判断路径{\n\n        if [ -d /root/Desktop/text/123 ];then\n            echo \"找到了123\"\n            if [ -d /root/Desktop/text ]\n            then echo \"找到了text\"\n            else echo \"没找到text\"\n            fi\n        else echo \"没找到123文件夹\"\n        fi\n\n    }\n\n    找出出现次数最多{\n\n        awk '{print $1}' file|sort |uniq -c|sort -k1r\n\n    }\n\n    判断脚本参数是否正确{\n\n        ./test.sh  -p 123 -P 3306 -h 127.0.0.1 -u root\n        #!/bin/sh\n        if [ $# -ne 8 ];then\n            echo \"USAGE: $0 -u user -p passwd -P port -h host\"\n            exit 1\n        fi\n\n        while getopts :u:p:P:h: name\n        do\n            case $name in\n            u)\n                mysql_user=$OPTARG\n            ;;\n            p)\n                mysql_passwd=$OPTARG\n            ;;\n            P)\n                mysql_port=$OPTARG\n            ;;\n            h)\n                mysql_host=$OPTARG\n            ;;\n            *)\n                echo \"USAGE: $0 -u user -p passwd -P port -h host\"\n                exit 1\n            ;;\n            esac\n        done\n\n        if [ -z $mysql_user ] || [ -z $mysql_passwd ] || [ -z $mysql_port ] || [ -z $mysql_host ]\n        then\n            echo \"USAGE: $0 -u user -p passwd -P port -h host\"\n            exit 1\n        fi\n\n        echo $mysql_user $mysql_passwd $mysql_port  $mysql_host\n        #结果 root 123 3306 127.0.0.1\n\n    }\n\n    正则匹配邮箱{\n\n        ^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*(\\.[a-z]{2,4})$\n\n    }\n\n    打印表格{\n\n        #!/bin/sh\n        clear\n        awk 'BEGIN{\n        print \"+--------------------+--------------------+\";\n        printf \"|%-20s|%-20s|\\n\",\"Name\",\"Number\";\n        print \"+--------------------+--------------------+\";\n        }'\n        a=`grep \"^[A-Z]\" a.txt |sort +1 -n |awk '{print $1\":\"$2}'`\n        #cat a.txt |sort +1 -n |while read list\n        for list in $a\n        do\n            name=`echo $list |awk -F: '{print $1}'`\n            number=`echo $list |awk -F: '{print $2}'`\n            awk 'BEGIN{printf \"|%-20s|%-20s|\\n\",\"'\"$name\"'\",\"'\"$number\"'\";\n            print \"+--------------------+--------------------+\";\n            }'\n        done\n        awk 'BEGIN{\n        print \"              *** The End ***              \"\n        print \"                                           \"\n        }'\n\n    }\n\n    判断日期是否合法{\n\n        #!/bin/sh\n        while read a\n        do\n          if echo $a | grep -q \"-\" && date -d $a +%Y%m%d > /dev/null 2>&1\n          then\n            if echo $a | grep -e '^[0-9]\\{4\\}-[01][0-9]-[0-3][0-9]$'\n            then\n                break\n            else\n                echo \"您输入的日期不合法，请从新输入！\"\n            fi\n          else\n            echo \"您输入的日期不合法，请从新输入！\"\n          fi\n        done\n        echo \"日期为$a\"\n\n    }\n\n    打印日期段所有日期{\n\n        #!/bin/bash\n        qsrq=20010101\n        jsrq=20010227\n        n=0\n        >tmp\n        while :;do\n        current=$(date +%Y%m%d -d\"$n day $qsrq\")\n        if [[ $current == $jsrq ]];then\n            echo $current >>tmp;break\n        else\n            echo $current >>tmp\n            ((n++))\n        fi\n        done\n        rq=`awk 'NR==1{print}' tmp`\n\n    }\n\n    数学计算的小算法{\n\n        #!/bin/sh\n        A=1\n        B=1\n        while [ $A -le 10 ]\n        do\n            SUM=`expr $A \\* $B`\n            echo \"$SUM\"\n            if [ $A = 10 ]\n            then\n                B=`expr $B + 1`\n                A=1\n            fi\n            A=`expr $A + 1`\n        done\n\n    }\n\n    多行合并{\n\n        sed '{N;s/\\n//}' file                   # 将两行合并一行(去掉换行符)\n        awk '{printf(NR%2!=0)?$0\" \":$0\" \\n\"}'   # 将两行合并一行\n        awk '{printf\"%s \",$0}'                  # 将所有行合并\n        awk '{if (NR%4==0){print $0} else {printf\"%s \",$0}}' file    # 将4行合并为一行(可扩展)\n\n    }\n\n    横竖转换{\n\n        cat a.txt | xargs           # 列转行\n        cat a.txt | xargs -n1       # 行转列\n\n    }\n\n    竖行转横行{\n\n        cat file|tr '\\n' ' '\n        echo $(cat file)\n\n        #!/bin/sh\n        for i in `cat file`\n        do\n              a=${a}\" \"${i}\n        done\n        echo $a\n\n    }\n\n    取用户的根目录{\n\n        #! /bin/bash\n        while read name pass uid gid gecos home shell\n        do\n            echo $home\n        done < /etc/passwd\n\n    }\n\n    远程打包{\n\n        ssh -n $ip 'find '$path' /data /opt -type f  -name \"*.sh\" -or -name \"*.py\" -or -name \"*.pl\" |xargs tar zcvpf /tmp/data_backup.tar.gz'\n\n    }\n\n    把汉字转成encode格式{\n\n        echo 论坛 | tr -d \"\\n\" | xxd -i | sed -e \"s/ 0x/%/g\" | tr -d \" ,\\n\"\n        %c2%db%cc%b3\n        echo 论坛 | tr -d \"\\n\" | xxd -i | sed -e \"s/ 0x/%/g\" | tr -d \" ,\\n\" | tr \"[a-f]\" \"[A-F]\"  # 大写的\n        %C2%DB%CC%B3\n\n    }\n\n    把目录带有大写字母的文件名改为全部小写{\n\n        #!/bin/bash\n        for f in *;do\n            mv $f `echo $f |tr \"[A-Z]\" \"[a-z]\"`\n        done\n\n    }\n\n    查找连续多行，在不连续的行前插入{\n\n        #/bin/bash\n        lastrow=null\n        i=0\n        cat incl|while read line\n        do\n        i=`expr $i + 1`\n        if echo \"$lastrow\" | grep \"#include <[A-Z].h>\"\n        then\n            if echo \"$line\" | grep -v  \"#include <[A-Z].h>\"\n            then\n                sed -i ''$i'i\\\\/\\/All header files are include' incl\n                i=`expr $i + 1`\n            fi\n        fi\n        lastrow=\"$line\"\n        done\n\n    }\n\n    查询数据库其它引擎{\n\n        #/bin/bash\n        path1=/data/mysql/data/\n        dbpasswd=db123\n        #MyISAM或InnoDB\n        engine=InnoDB\n\n        if [ -d $path1 ];then\n\n        dir=`ls -p $path1 |awk '/\\/$/'|awk -F'/' '{print $1}'`\n            for db in $dir\n            do\n            number=`mysql -uroot -p$dbpasswd -A -S \"$path1\"mysql.sock -e \"use ${db};show table status;\" |grep -c $engine`\n                if [ $number -ne 0 ];then\n                echo \"${db}\"\n                fi\n            done\n        fi\n\n    }\n\n    批量修改数据库引擎{\n\n        #/bin/bash\n        for db in test test1 test3\n        do\n            tables=`mysql -uroot -pdb123 -A -S /data/mysql/data/mysql.sock -e \"use $db;show tables;\" |awk 'NR != 1{print}'`\n\n            for table in $tables\n            do\n                mysql -uroot -pdb123 -A -S /data/mysql/data/mysql.sock -e \"use $db;alter table $table engine=MyISAM;\"\n            done\n        done\n\n    }\n\n    将shell取到的数据插入mysql数据库{\n\n        mysql -u$username -p$passwd -h$dbhost -P$dbport -A -e \"\n        use $dbname;\n        insert into data values ('','$ip','$date','$time','$data')\n        \"\n\n    }\n\n    两日期间隔天数{\n\n        D1=`date -d '20070409' +\"%s\"`\n        D2=`date -d '20070304 ' +\"%s\"`\n        D3=$(($D1 - $D2))\n        echo $(($D3/60/60/24))\n\n    }\n\n    while执行ssh只循环一次{\n\n        cat -    # 让cat读连接文件stdin的信息\n        seq 10 | while read line; do ssh localhost \"cat -\"; done        # 显示的9次是被ssh吃掉的\n        seq 10 | while read line; do ssh -n localhost \"cat -\"; done     # ssh加上-n参数可避免只循环一次\n\n    }\n\n    ssh批量执行命令{\n\n        #版本1\n        #!/bin/bash\n        while read line\n        do\n        Ip=`echo $line|awk '{print $1}'`\n        Passwd=`echo $line|awk '{print $2}'`\n        ssh -n localhost \"cat -\"\n        sshpass -p \"$Passwd\" ssh -n -t -o StrictHostKeyChecking=no root@$Ip \"id\"\n        done<iplist.txt\n\n        #版本2\n        #!/bin/bash\n        Iplist=`awk '{print $1}' iplist.txt`\n        for Ip in $Iplist\n        do\n        Passwd=`awk '/'$Ip'/{print $2}' iplist.txt`\n        sshpass -p \"$Passwd\" ssh -n -t -o StrictHostKeyChecking=no root@$Ip \"id\"\n        done\n\n    }\n\n    在同一位置打印字符{\n\n        #!/bin/bash\n        echo -ne \"\\t\"\n        for i in `seq -w 100 -1 1`\n        do\n            echo -ne \"$i\\b\\b\\b\";      # 关键\\b退格\n            sleep 1;\n        done\n\n    }\n\n    多进程后台并发简易控制{\n\n        #!/bin/bash\n        test () {\n            echo $a\n            sleep 5\n        }\n        for a in `seq 1 30`\n        do\n            test &\n            echo $!\n            ((num++))\n            if [ $num -eq 6 ];then\n            echo \"wait...\"\n            wait\n            num=0\n            fi\n        done\n        wait\n\n    }\n\n    shell并发{\n\n        #!/bin/bash\n        tmpfile=$$.fifo   # 创建管道名称\n        mkfifo $tmpfile   # 创建管道\n        exec 4<>$tmpfile  # 创建文件标示4，以读写方式操作管道$tmpfile\n        rm $tmpfile       # 将创建的管道文件清除\n        thred=4           # 指定并发个数\n        seq=(1 2 3 4 5 6 7 8 9 21 22 23 24 25 31 32 33 34 35) # 创建任务列表\n\n        # 为并发线程创建相应个数的占位\n        {\n        for (( i = 1;i<=${thred};i++ ))\n        do\n            echo;  # 因为read命令一次读取一行，一个echo默认输出一个换行符，所以为每个线程输出一个占位换行\n        done\n        } >&4      # 将占位信息写入管道\n\n        for id in ${seq}  # 从任务列表 seq 中按次序获取每一个任务\n        do\n          read  # 读取一行，即fd4中的一个占位符\n          (./ur_command ${id};echo >&4 ) &   # 在后台执行任务ur_command 并将任务 ${id} 赋给当前任务；任务执行完后在fd4种写入一个占位符\n        done <&4    # 指定fd4为整个for的标准输入\n        wait        # 等待所有在此shell脚本中启动的后台任务完成\n        exec 4>&-   # 关闭管道\n\n    }\n\n    shell并发函数{\n\n        function ConCurrentCmd()\n        {\n            #进程数\n            Thread=30\n\n            #列表文件\n            CurFileName=iplist.txt\n\n            #定义fifo文件\n            FifoFile=\"$$.fifo\"\n\n            #新建一个fifo类型的文件\n            mkfifo $FifoFile\n\n            #将fd6与此fifo类型文件以读写的方式连接起来\n            exec 6<>$FifoFile\n            rm $FifoFile\n\n            #事实上就是在文件描述符6中放置了$Thread个回车符\n            for ((i=0;i<=$Thread;i++));do echo;done >&6\n\n            #此后标准输入将来自fd5\n            exec 5<$CurFileName\n\n            #开始循环读取文件列表中的行\n            Count=0\n            while read -u5 line\n            do\n                read -u6\n                let Count+=1\n                # 此处定义一个子进程放到后台执行\n                # 一个read -u6命令执行一次,就从fd6中减去一个回车符，然后向下执行\n                # fd6中没有回车符的时候,就停在这了,从而实现了进程数量控制\n                {\n                    echo $Count\n\n                    #这段代码框就是执行具体的操作了\n                    function\n\n                    echo >&6\n                    #当进程结束以后,再向fd6中追加一个回车符,即补上了read -u6减去的那个\n                } &\n            done\n\n            #等待所有后台子进程结束\n            wait\n\n            #关闭fd6\n            exec 6>&-\n\n            #关闭fd5\n            exec 5>&-\n        }\n\n        并发例子{\n\n            #!/bin/bash\n\n            pnum=3\n\n            task () {\n                echo \"$u start\"\n                sleep 5\n                echo \"$u done\"\n            }\n\n            FifoFile=\"$$.fifo\"\n            mkfifo $FifoFile\n            exec 6<>$FifoFile\n            rm $FifoFile\n            \n            for ((i=0;i<=$pnum;i++));do echo;done >&6\n\n            for u in `seq 1 20`\n            do\n                read -u6\n                {\n                    task\n                    [ $? -eq 0 ] && echo \"${u} 次成功\" || echo \"${u} 次失败\"\n                    echo >&6\n                } &\n            done\n            wait\n            exec 6>&-\n\n        }\n    }\n\n    函数{\n\n        ip(){\n            echo \"a 1\"|awk '$1==\"'\"$1\"'\"{print $2}'\n        }\n        web=a\n        ip $web\n\n    }\n\n    检测软件包是否存在{\n\n        rpm -q dialog >/dev/null\n        if [ \"$?\" -ge 1 ];then\n            echo \"install dialog,Please wait...\"\n            yum -y install dialog\n            rpm -q dialog >/dev/null\n            [ $? -ge 1 ] && echo \"dialog installation failure,exit\" && exit\n            echo \"dialog done\"\n            read\n        fi\n\n    }\n\n    游戏维护菜单-修改配置文件{\n\n        #!/bin/bash\n\n        conf=serverlist.xml\n        AreaList=`awk -F '\"' '/<s/{print $2}' $conf`\n\n        select area in $AreaList 全部 退出\n        do\n            echo \"\"\n            echo $area\n            case $area in\n            退出)\n                exit\n            ;;\n            *)\n                select operate in \"修改版本号\" \"添加维护中\" \"删除维护中\" \"返回菜单\"\n                do\n                    echo \"\"\n                    echo $operate\n                    case $operate in\n                    修改版本号)\n                        echo 请输入版本号\n                        while read version\n                        do\n                            if echo $version | grep -w 10[12][0-9][0-9][0-9][0-9][0-9][0-9]\n                            then\n                                break\n                            fi\n                            echo 请从新输入正确的版本号\n                        done\n                        case $area in\n                        全部)\n                            case $version in\n                            101*)\n                                echo \"请确认操作对 $area 体验区 $operate\"\n                                read\n                                sed -i 's/101[0-9][0-9][0-9][0-9][0-9][0-9]/'$version'/' $conf\n                            ;;\n                            102*)\n                                echo \"请确认操作对 $area 正式区 $operate\"\n                                read\n                                sed -i 's/102[0-9][0-9][0-9][0-9][0-9][0-9]/'$version'/' $conf\n                            ;;\n                            esac\n                        ;;\n                        *)\n                            type=`awk -F '\"' '/'$area'/{print $14}' $conf |cut -c1-3`\n                            readtype=`echo $version |cut -c1-3`\n                            if [ $type != $readtype ]\n                            then\n                                echo \"版本号不对应，请从新操作\"\n                                continue\n                            fi\n\n                            echo \"请确认操作对 $area 区 $operate\"\n                            read\n\n                            awk -F '\"' '/'$area'/{print $12}' $conf |xargs -i sed -i '/'{}'/s/10[12][0-9][0-9][0-9][0-9][0-9][0-9]/'$version'/' $conf\n                        ;;\n                        esac\n                    ;;\n                    添加维护中)\n                        case $area in\n                        全部)\n                            echo \"请确认操作对 $area 区 $operate\"\n                            read\n                            awk -F '\"' '/<s/{print $2}' $conf |xargs -i sed -i 's/'{}'/&维护中/' $conf\n                        ;;\n                        *)\n                            echo \"请确认操作对 $area 区 $operate\"\n                            read\n                            sed -i 's/'$area'/&维护中/' $conf\n                        ;;\n                        esac\n                    ;;\n                    删除维护中)\n                        case $area in\n                        全部)\n                            echo \"请确认操作对 $area 区 $operate\"\n                            read\n                            sed -i 's/维护中//' $conf\n                        ;;\n                        *)\n                            echo \"请确认操作对 $area 区 $operate\"\n                            read\n                            sed -i '/'$area'/s/维护中//' $conf\n                        ;;\n                        esac\n                    ;;\n                    返回菜单)\n                        break\n                    ;;\n                    esac\n                done\n            ;;\n            esac\n            echo \"回车重新选择区\"\n        done\n\n    }\n\n    keepalive剔除后端服务{\n\n        #!/bin/bash\n        #行数请自定义,默认8行\n        if [ X$2 == X ];then\n            echo \"error: IP null\"\n            read\n            exit\n        fi\n        case $1 in\n        del)\n            sed -i '/real_server.*'$2'.*8888/,+8 s/^/#/' /etc/keepalived/keepalived.conf\n            /etc/init.d/keepalived reload\n        ;;\n        add)\n            sed -i '/real_server.*'$2'.*8888/,+8 s/^#//' /etc/keepalived/keepalived.conf\n            /etc/init.d/keepalived reload\n        ;;\n        *)\n            echo \"Parameter error\"\n        ;;\n        esac\n\n    }\n\n    抓取系统中负载最高的进程{\n\n        #!/bin/bash\n        LANG=C\n        PATH=/sbin:/usr/sbin:/bin:/usr/bin\n        interval=1\n        length=86400\n        for i in $(seq 1 $(expr ${length} / ${interval}));do\n        date\n        LANG=C ps -eT -o%cpu,pid,tid,ppid,comm | grep -v CPU | sort -n -r | head -20\n        date\n        LANG=C cat /proc/loadavg\n        { LANG=C ps -eT -o%cpu,pid,tid,ppid,comm | sed -e 's/^ *//' | tr -s ' ' | grep -v CPU | sort -n -r | cut -d ' ' -f 1 | xargs -I{} echo -n \"{} + \" && echo ' 0'; } | bc -l\n        sleep ${interval}\n        done\n        fuser -k $0\n\n    }\n\n    申诉中国反垃圾邮件联盟黑名单{\n\n        #!/bin/bash\n\n        IpList=`awk '$1!~\"^#\"&&$1!=\"\"{print $1}' host.list`\n\n        QueryAdd='http://www.anti-spam.org.cn/Rbl/Query/Result'\n        ComplaintAdd='http://www.anti-spam.org.cn/Rbl/Getout/Submit'\n\n        CONTENT='我们是一家正规的XXX。xxxxxxx。恳请将我们的发送服务器IP移出黑名单。谢谢！\n        处理措施：\n        1.XXXX。\n        2.XXXX。'\n        CORP='abc.com'\n        WWW='www.abc.cm'\n        NAME='def'\n        MAIL='def@163.com.cn'\n        TEL='010-50000000'\n        LEVEL='0'\n\n        for Ip in $IpList\n        do\n            Status=`curl -d \"IP=$Ip\" $QueryAdd |grep 'Getout/ShowForm?IP=' |grep -wc '申诉脱离'`\n            if [ $Status -ge 1 ];then\n                IpStatus=\"黑名单中\"\n                results=`curl -d \"IP=${Ip}&CONTENT=${CONTENT}&CORP=${CORP}&WWW=${WWW}&NAME=${NAME}&MAIL=${MAIL}&TEL=${TEL}&LEVEL=${LEVEL}\" $ComplaintAdd |grep -E '您的黑名单脱离申请已提交|该IP的脱离申请已被他人提交|申请由于近期内有被拒绝的记录'`\n                echo $results\n                if echo $results | grep '您的黑名单脱离申请已提交'  > /dev/null 2>&1\n                then\n                    complaint='申诉成功'\n                elif echo $results | grep '该IP的脱离申请已被他人提交'  > /dev/null 2>&1\n                then\n                    complaint='申诉重复'\n                elif echo $results | grep '申请由于近期内有被拒绝的记录'  > /dev/null 2>&1\n                then\n                    complaint='申诉拒绝'\n                else\n                    complaint='异常'\n                fi\n            else\n                IpStatus='正常'\n                complaint='无需申诉'\n            fi\n            echo \"$Ip    $IpStatus    $complaint\" >> $(date +%Y%m%d_%H%M%S).log\n        done\n\n}\n\n    Web Server in Awk{\n\n        #gawk -f file\n        BEGIN {\n          x        = 1                         # script exits if x < 1\n          port     = 8080                      # port number\n          host     = \"/inet/tcp/\" port \"/0/0\"  # host string\n          url      = \"http://localhost:\" port  # server url\n          status   = 200                       # 200 == OK\n          reason   = \"OK\"                      # server response\n          RS = ORS = \"\\r\\n\"                    # header line terminators\n          doc      = Setup()                   # html document\n          len      = length(doc) + length(ORS) # length of document\n          while (x) {\n             if ($1 == \"GET\") RunApp(substr($2, 2))\n             if (! x) break\n             print \"HTTP/1.0\", status, reason |& host\n             print \"Connection: Close\"        |& host\n             print \"Pragma: no-cache\"         |& host\n             print \"Content-length:\", len     |& host\n             print ORS doc                    |& host\n             close(host)     # close client connection\n             host |& getline # wait for new client request\n          }\n          # server terminated...\n          doc = Bye()\n          len = length(doc) + length(ORS)\n          print \"HTTP/1.0\", status, reason |& host\n          print \"Connection: Close\"        |& host\n          print \"Pragma: no-cache\"         |& host\n          print \"Content-length:\", len     |& host\n          print ORS doc                    |& host\n          close(host)\n        }\n\n        function Setup() {\n          tmp = \"<html>\\\n          <head><title>Simple gawk server</title></head>\\\n          <body>\\\n          <p><a href=\" url \"/xterm>xterm</a>\\\n          <p><a href=\" url \"/xcalc>xcalc</a>\\\n          <p><a href=\" url \"/xload>xload</a>\\\n          <p><a href=\" url \"/exit>terminate script</a>\\\n          </body>\\\n          </html>\"\n          return tmp\n        }\n\n        function Bye() {\n          tmp = \"<html>\\\n          <head><title>Simple gawk server</title></head>\\\n          <body><p>Script Terminated...</body>\\\n          </html>\"\n          return tmp\n        }\n\n        function RunApp(app) {\n          if (app == \"xterm\")  {system(\"xterm&\"); return}\n          if (app == \"xcalc\" ) {system(\"xcalc&\"); return}\n          if (app == \"xload\" ) {system(\"xload&\"); return}\n          if (app == \"exit\")   {x = 0}\n        }\n\n    }\n\n}\n\n10 经验{\n    1.服务上线,在启动注册流量时大量报错, 下游服务摘除,重启后, 上游还用原有的链接去链接, 导致请求失败.\n    2.systemd守护的进程,在tmp下找不到对应文件, 配置安全tmp项PrivateTmp改为false PrivateTmp=false\n    3.统一服务内部调用关系,一个服务对应一个域名\n    4.统一服务服务返回的状态码,报警只需要针对5xx就可以发现问题.\n    5.在服务雪崩后,恢复服务,用户可能有大量重试,所以放流量也要小比例放流量,逐步恢复\n}\n\n\n不定期更新下载地址：\nhttps://github.com/liquanzhou/ops_doc\n\n请勿删除信息, 植入广告, 抵制不道德行为\n"
        }
      ]
    }
  ]
}