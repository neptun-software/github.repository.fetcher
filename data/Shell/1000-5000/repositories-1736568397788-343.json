{
  "metadata": {
    "timestamp": 1736568397788,
    "page": 343,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ryanmjacobs/c",
      "stars": 2108,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0576171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2023 Ryan Jacobs\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.515625,
          "content": "# c\n\n<!--\n[![Build Status](https://travis-ci.org/ryanmjacobs/c.svg)](https://travis-ci.org/ryanmjacobs/c)\n-->\n\n> \"There isn't much that's special about C. That's one of the reasons why it's\nfast.\"\n\nI love C for its raw speed (although it does have its drawbacks). We should\nall write more C.\n\nWith this shell script, you can compile and execute C \"scripts\" in one go!\n\n(Oh yeah, and it works for C++ too.)\n\n![GIF Demo](http://i.imgur.com/aWnG03r.gif)\n\nHere's a simple example:\n```c\n#include <stdio.h>\n\nint main(void) {\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n```\n\nRun it by typing:\n```bash\n$ c hello.c\nHello World!\n```\n\nOr, call it from the shebang!\n```c\n#!/usr/bin/c\n#include <stdio.h>\n\nint main(void) {\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n```\n```bash\n$ chmod +x hello.c\n$ ./hello.c\nHello World!\n```\n\n## Hooked? Here's how to install it:\nUse a package manager? [Check here](https://github.com/ryanmjacobs/c#packages).\n\nFor the entire system:\n```bash\n$ wget https://raw.githubusercontent.com/ryanmjacobs/c/master/c\n$ sudo install -m 755 c /usr/bin/c\n\n# Or... for systems that prefer /usr/local/bin (e.g. macOS)\n$ sudo install -m 755 c /usr/local/bin/c\n```\n\nFor your local user only:\n```bash\n$ wget https://raw.githubusercontent.com/ryanmjacobs/c/master/c\n$ sudo install -Dm 755 c ~/.bin/c\n$ echo 'PATH=$PATH:$HOME/.bin' >> ~/.bashrc\n```\n\nNote: if you install it somewhere other than `/usr/bin/c`, then your shebang\nwill be different. For example it may be something more similar to\n`#!/home/ryan/.bin/c`.\n\n## Okay, how do I use it?\nc will use whatever `$CC` is set to. You can change this with:\n```bash\n$ export CC=clang\n$ export CC=tcc\n$ # etc...\n```\n## CLI\n### Multiple Files - CLI\nAnything you want passed to the compiler, put in quotes as the first argument.\nWhether they're flags (`-Wall`, `-O2`, etc.) or file names (`file.c`,\n`main.c`, etc.).\n\n```bash\n$ c \"main.c other.c\" arg1 arg2\n$ c \"main.c other.c -O3 -Wall -lncurses\" arg1 arg2\n```\n### Single File - CLI\nWith only one file, omit the quotes:\n```bash\n$ c hello.c\n$ c main.c arg1 arg2\n```\n\n## Shebang!\nAfter adding a shebang, just set the file to executable and it's ready to run.\n```bash\n$ chmod +x file.c\n$ ./file.c\n```\n\n### Single File - Shebang\nAdd this to the top of your C file:\n```c\n#!/usr/bin/c\n```\n\n### Multiple Files - Shebang\nJust tack on any extra flags, options, or files you want passed to the compiler.\nThen be sure to add the terminating `--` characters.\n```c\n#!/usr/bin/c file1.c file2.c -lncurses -lm --\n```\n\n## Caching\nThe default cache size is set to 5 MB. You can change this with:\n```bash\n$ export C_CACHE_SIZE=$((10*1024)) # 10 MB\n```\nThe default cache path is set to `$TMPDIR/c.cache`. You can change this with:\n```bash\n$ export C_CACHE_PATH=\"/tmp/the_cache\"\n```\n\n### Clear cache\nYou can clear the cache with the `--clear-cache` flag:\n```bash\n$ c --clear-cache\n```\n\n# Contributing\nFeel free to submit any ideas, questions, or problems by reporting an issue.\nOr, if you're feeling a bit brave, submit a pull request. :grimacing:\n\nJust hack away and make sure that all the tests pass.\n```bash\n$ cd tests\n$ ./test.sh\n```\n\n## Why?\nFirst of all, I want to clarify why this is **not** the same as `tcc -run`.\nTCC is a compiler. We all know that. TCC will perform its own set of\noptimizations, just as GCC will perform its own and Clang will perform its\nown. The purpose of this script is to give a simple front-end to your favorite\ncompiler.\n\nWhether it's GCC, Clang, or something else entirely, **you** get to choose\nyour compiler.\n\nSecond reason: it's simply satisfying to type `c hello.c` and see it run instantly.\n\nThird reason: I'm a fan of speed, and C definitely offers it. Being able to\nwrite a small, fast, and portable C \"script\" is great. You can pass around a\nC \"script\" just like you would a BASH script.\n\n## zsh\nIf you're using `zsh`, then you can take advantage of `zsh`'s suffix aliases:\n```bash\n$ alias -s c='c'\n$ alias -s cc='c'\n$ alias -s cpp='c'\n```\nThen you can run files with `./file.c` without `chmod +x`.\n\n## Packages\nUse a package manager? You've come to the right place.\n\nAUR: https://aur.archlinux.org/packages/c/<br>\nbpkg: `bpkg install ryanmjacobs/c`<br>\nbrew: `brew install c`\n(shebang will be `#!/usr/local/bin/c` for Intel-based Macs or `#!/opt/homebrew/bin/c` for Apple Silicon)<br>\n\n## Todo\n~~Maybe later we can implement caching.~~ Done!\n\n## License\n[MIT License](https://raw.githubusercontent.com/ryanmjacobs/c/master/LICENSE).\n\nBasically, you can do whatever you want provided that you include\nthe LICENSE notice in any copy of the source. Also, I am not liable\nif the script breaks anything.\n"
        },
        {
          "name": "c",
          "type": "blob",
          "size": 6.01953125,
          "content": "#!/usr/bin/env bash\n## repository at https://github.com/ryanmjacobs/c\nVERSION=v0.15-dev\n\n# max cachesize in kilobytes (default=5MB)\n[[ -z \"$C_CACHE_SIZE\" ]] && C_CACHE_SIZE=$((5*1024))\nif ! [[ \"$C_CACHE_SIZE\" =~ ^[0-9]*$ ]]; then\n    C_CACHE_SIZE=$((5*1024))\n    >&2 echo 'warning: $C_CACHE_SIZE should be a positive integer'\nfi\n\nhelp_msg() {\n    >&$1 echo \"Usage: $(basename \"$0\") <file.c ... | compiler_options ...> [program_arguments]\"\n    >&$1 echo \"       $(basename \"$0\") --clear-cache\"\n    >&$1 echo 'Execute C programs from the command line.'\n    >&$1 echo\n    >&$1 echo '  Ex: c main.c'\n    >&$1 echo '  Ex: c main.c arg1 arg2'\n    >&$1 echo \"  Ex: c 'main.c other.c' arg1 arg2\"\n    >&$1 echo \"  Ex: c 'main.c -lncurses' arg1 arg2\"\n    >&$1 echo\n}\n\ncleanup() {\n    # remove temporary source directory\n    rm -rf \"$tmpdir\"\n\n    # remove cache files until we are under $cachesize\n    if [ \"$(uname -s)\" == \"SunOS\" ] ; then ducmd=\"du -ks\" ; else ducmd=\"du -kc\" ; fi\n    while [[ \"$($ducmd \"$tmproot\" | tail -1 | cut -f1)\" -gt \"$C_CACHE_SIZE\" ]]; do\n        [[ -z \"$(ls -A \"$tmproot\")\" ]] && break\n        rm -rf \"$(find \"$tmproot\" | tail -n1)\"\n    done\n}\n\n# Handle --help, -h, and zero args\n[[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]] && { help_msg 1; exit 0; }\n[[ \"$#\" -lt 1 ]] && { help_msg 2; exit 2; }\n\n# get cache location\nif [[ -n \"$C_CACHE_PATH\" ]]; then\n    tmproot=\"$C_CACHE_PATH\"\nelse\n    [[ -z \"$TMPDIR\" ]] && TMPDIR=\"/tmp\"\n    tmproot=\"$TMPDIR/c.cache.$USER\"\nfi\n\n# Hadle --clear-cache\n[[ \"$1\" == \"--clear-cache\" ]] && exec rm -rf \"$tmproot\"\n\n# ensure our $CC and $CXX variables are set\n[[ -z \"$CC\" ]]  && CC=cc\n[[ -z \"$FC\" ]]  && FC=gfortran\n[[ -z \"$CXX\" ]] && CXX=c++\nif ! hash \"$CC\" &>/dev/null; then\n    >&2 echo \"error: \\$CC ($CC) not found\"\n    exit 1\nfi\n\n# $comp holds the files and options that will be passed to the compiler\n# $fname will become the program's argv[0]\nif [ -f \"$1\" ]; then\n    # given only one file, so that must be our source file\n    comp=(\"$1\")\n    fname=\"$1\"\nelse\n    # capture all of our source files,\n    # use the first file as our fname\n    for arg in $1; do\n        if [[ \"$arg\" == \"--\" ]]; then\n            fname=\"$2\"\n            comp=(\"$2\" \"${comp[@]}\")\n            shift\n        else\n            comp+=(\"$arg\")\n        fi\n    done\n\n    # if we don't have an fname yet, pick one out of $comp\n    # that doesn't start with a '-'\n    if [[ -z \"$fname\" ]]; then\n        for arg in $1; do\n            if [[ \"$arg\" != -* ]]; then\n                fname=\"$arg\"\n                break\n            fi\n        done\n    fi\nfi\n\n# create cache location\nmkdir -p \"$tmproot\"\nchmod 700 \"$tmproot\"\n\n# decide on a hash function by using the first one we find\npotential_hashes=(md5sum sha256sum sha1sum shasum)\nhash_func=:\nfor hf in \"${potential_hashes[@]}\"; do\n    hash \"$hf\" &>/dev/null && { hash_func=\"$hf\"; break; }\ndone\n\n# disable caching if we don't locate a hashing function\n[ \"$hash_func\" == : ] && C_CACHE_SIZE=0\n\n# determine if we are C, C++ or Fortran, then use appropriate flags\nis_cpp=false\nis_fortran=false\nfor f in \"$fname\" \"${comp[@]}\"; do\n    # only examine files\n    [[ ! -f \"$f\" ]] && continue\n\n    # if one file has a C++ extension, then the whole set is C++\n    if [[ \"$f\" =~ \\.(cc|c\\+\\+|cpp|cxx)$ ]]; then\n        is_cpp=true\n\n        if hash \"$CXX\" &>/dev/null; then\n            # found $CXX, we will use that\n            CC=\"$CXX\"\n            comp+=(\"$CXXFLAGS\")\n        else\n            # couldn't find $CXX, so we make do with $CC and -lstdc++\n            comp+=(\"$CFLAGS -lstdc++\")\n        fi\n\n        break\n    fi\n\n    # if one file has a Fortran extension, then the whole set is Fortran\n    # We have to check case insensitive because many fortran suffixes are\n    # uppercase\n    shopt -s nocasematch\n    if [[ \"$f\" =~ \\.(f|f95|f77|f90|f03|f15|for)$ ]]; then\n      is_fortran=true\n      CC=\"${FC}\"\n      comp+=(${FCFLAGS})\n    fi\n    shopt -u nocasematch\n\ndone\n\n# add $CFLAGS if and only if we are not C++\nif [[ \"$is_cpp\" == false && \"${is_fortran}\" == false ]]; then\n    comp+=($CFLAGS)\nfi\n\n# add preprocessor flags\ncomp+=(\"$CPPFLAGS\")\n\n# hash all of our data\nprehash=\"$CC ${comp[*]}\" # compiler + flags and files\nfor f in \"${comp[@]}\"; do\n    [ -f \"$f\" ] && prehash+=\"$f $(cpp \"$f\" 2>&1)\"\ndone\n\n# hash everything into one unique identifier, for caching purposes\nid=\"c$(\"$hash_func\" <<< \"$prehash\" | cut -d' ' -f1)\"\ntmpdir=\"$tmproot/$id.src\"\nbinname=\"$tmproot/$id.bin\"\n\n# run binary\nrun() {\n    trap cleanup SIGINT\n\n    if [ -x \"$binname\" ]; then\n      shift\n      (exec -a \"$fname\" \"$binname\" \"$@\")\n      ret=$?\n    else\n      echo\n      ret=4\n    fi\n\n    trap - SIGINT\n    cleanup\n    exit $ret\n}\n\n# run cached file if it exists\nif [[ -f \"$binname\" ]]; then\n    run \"$@\"\nelse\n    mkdir -p \"$tmpdir\"\nfi\n\n# assemble our includes, based on the original file locations\nincludes=(\"-I'$PWD'\")\nfor f in \"${comp[@]}\"; do\n    [[ -f \"$f\" ]] && includes+=(\"-I'$(dirname \"$f\")'\")\ndone\n\ni=0\n# copy source files to $tmpdir\nfor f in \"${comp[@]}\"; do\n    if [[ -f \"$f\" && \"$f\" != $tmpdir* ]]; then\n        mkdir -p \"$tmpdir/$(dirname \"$f\")\"\n        cp \"$f\" \"$tmpdir/$f\"\n\n        # assume language is C, if no extension is given\n        base=\"$(basename \"$f\")\"\n        ext=\"${base##*.}\"\n        if [[ \"$ext\" == \"$base\" ]]; then\n            comp[$i]=\"-x c $tmpdir/$f -x none\"\n        else\n            comp[$i]=\"$tmpdir/$f\"\n        fi\n\n        # remove shebangs from every source file\n        if [[ \"$(head -n1 \"$tmpdir/$f\")\" == \\#\\!* ]]; then\n            echo \"$(tail -n +2 \"$tmpdir/$f\")\" > \"$tmpdir/$f\"\n        fi\n    fi\n    let i++\ndone\n\n# final operations before compilation\nrest=()\nflags=()\nfor f in \"${comp[@]}\"; do\n    # skip empty elements\n    [[ -z \"$f\" ]] && break\n\n    # separate the flags from other arguments\n    [[ \"$f\" =~ ^- ]] &&\\\n        flags+=(\"$f\") ||\\\n        rest+=(\"$f\")\ndone\n\n# compile and run\n\n# kludgey fix for gcc arguments\nout=\"$(\"$CC\" -O2 -o \"$binname\" ${flags[@]} \"${includes[@]}\" \"${rest[@]}\" 2>&1)\"\nif [ $? -ne 0 ]; then\n    eval \"$CC\" -O2 -o \"$binname\" ${flags[@]} \"${includes[@]}\" \"${rest[@]}\"\nelse\n    echo -n \"$out\"\nfi\n\nif [ $? -eq 0 ]; then\n    run \"$@\"\nelse\n    cleanup\n    exit 1\nfi\n"
        },
        {
          "name": "c.rb",
          "type": "blob",
          "size": 0.388671875,
          "content": "class C < Formula\n  homepage \"https://github.com/ryanmjacobs/c\"\n  url \"https://github.com/ryanmjacobs/c/archive/v0.14.tar.gz\"\n  sha256 \"2b66d79d0d5c60b8e6760dac734b8ec9a7d6a5e57f033b97086821b1985a870b\"\n  head \"https://github.com/ryanmjacobs/c.git\"\n\n  def install\n    bin.install \"c\"\n  end\n\n  test do\n    #system \"#{bin}/c\", \"\")\n    pipe_output(\"#{bin}/c\", \"int main(void){return 0;}\", 0)\n  end\nend\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.228515625,
          "content": "{\n  \"name\": \"c\",\n  \"version\": \"v0.15-dev\",\n  \"description\": \"Compile and execute C \\'scripts\\' in one go!\",\n  \"global\": \"true\",\n  \"install\": \"mkdir -p ${PREFIX:-/usr}/bin; install -m 775 c ${PREFIX:-/usr}/bin\",\n  \"scripts\": [ \"c\" ]\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}