{
  "metadata": {
    "timestamp": 1736568824913,
    "page": 993,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjk5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Supervisor/initscripts",
      "stars": 1017,
      "defaultBranch": "main",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.76953125,
          "content": "# Init Scripts\n\nThis repository contains user-contributed scripts for running \n[Supervisor](https://github.com/supervisor/supervisor) under\nvarious operating systems.  If a script is not available for\nyour favorite system, consider writing one.\n\n## Contributing\n\nFork the repository, add your well-tested script, then send a \npull request.  Please include your contact information in the\nscript and clearly indicate what system(s) your script supports. \n\n## Maintainers\n\nThe Supervisor maintainers will occasionally merge pull requests but\nin general do not have enough bandwidth to test or maintain the scripts \nin this repository.  \n\nIf you are modifying an existing script, please make an attempt to\ndiscuss your change with the script's original author before opening\na pull request.\n"
        },
        {
          "name": "centos-systemd-etcs",
          "type": "blob",
          "size": 0.3583984375,
          "content": "# supervisord service for systemd (CentOS 7.0+)\n# by ET-CS (https://github.com/ET-CS)\n[Unit]\nDescription=Supervisor daemon\n\n[Service]\nType=forking\nExecStart=/usr/bin/supervisord\nExecStop=/usr/bin/supervisorctl $OPTIONS shutdown\nExecReload=/usr/bin/supervisorctl $OPTIONS reload\nKillMode=process\nRestart=on-failure\nRestartSec=42s\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "debian-norrgard",
          "type": "blob",
          "size": 4.3955078125,
          "content": "#! /bin/sh\n### BEGIN INIT INFO\n# Provides:          supervisord\n# Required-Start:    $local_fs $remote_fs $networking\n# Required-Stop:     $local_fs $remote_fs $networking\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: Starts supervisord - see http://supervisord.org\n# Description:       Starts and stops supervisord as needed - see http://supervisord.org\n### END INIT INFO\n\n# Author: Leonard Norrgard <leonard.norrgard@refactor.fi>\n# Version 1.0-alpha\n# Based on the /etc/init.d/skeleton script in Debian.\n\n# Please note: This script is not yet well tested. What little testing\n# that actually was done was only on supervisor 2.2b1.\n\n# Do NOT \"set -e\"\n\n# PATH should only include /usr/* if it runs after the mountnfs.sh script\nPATH=/sbin:/usr/sbin:/bin:/usr/bin\nDESC=\"Run a set of applications as daemons.\"\nNAME=supervisord\nDAEMON=/usr/bin/$NAME   # Supervisord is installed in /usr/bin by default, but /usr/sbin would make more sense.\nSUPERVISORCTL=/usr/bin/supervisorctl\nPIDFILE=/var/run/$NAME.pid\nDAEMON_ARGS=\"--pidfile ${PIDFILE}\"\nSCRIPTNAME=/etc/init.d/$NAME\n\n# Exit if the package is not installed\n[ -x \"$DAEMON\" ] || exit 0\n\n# Read configuration variable file if it is present\n[ -r /etc/default/$NAME ] && . /etc/default/$NAME\n\n# Load the VERBOSE setting and other rcS variables\n. /lib/init/vars.sh\n\n# Define LSB log_* functions.\n# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.\n. /lib/lsb/init-functions\n\n#\n# Function that starts the daemon/service\n#\ndo_start()\n{\n\t# Return\n\t#   0 if daemon has been started\n\t#   1 if daemon was already running\n\t#   2 if daemon could not be started\n        [ -e $PIDFILE ] && return 1\n\n\tstart-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \\\n\t\t$DAEMON_ARGS \\\n\t\t|| return 2\n\t# Add code here, if necessary, that waits for the process to be ready\n\t# to handle requests from services started subsequently which depend\n\t# on this one.  As a last resort, sleep for some time.\n}\n\n#\n# Function that stops the daemon/service\n#\ndo_stop()\n{\n\t# Return\n\t#   0 if daemon has been stopped\n\t#   1 if daemon was already stopped\n\t#   2 if daemon could not be stopped\n\t#   other if a failure occurred\n        [ -e $PIDFILE ] || return 1\n\n\t# Stop all processes under supervisord control.\n\t$SUPERVISORCTL stop all\n\n\tstart-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME\n\tRETVAL=\"$?\"\n\t[ \"$RETVAL\" = 2 ] && return 2\n\t# Wait for children to finish too if this is a daemon that forks\n\t# and if the daemon is only ever run from this initscript.\n\t# If the above conditions are not satisfied then add some other code\n\t# that waits for the process to drop all resources that could be\n\t# needed by services started subsequently.  A last resort is to\n\t# sleep for some time.\n\tstart-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON\n\t[ \"$?\" = 2 ] && return 2\n\t# Many daemons don't delete their pidfiles when they exit.\n\trm -f $PIDFILE\n\treturn \"$RETVAL\"\n}\n\n#\n# Function that sends a SIGHUP to the daemon/service\n#\ndo_reload() {\n\t#\n\t# If the daemon can reload its configuration without\n\t# restarting (for example, when it is sent a SIGHUP),\n\t# then implement that here.\n\t#\n\tstart-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME\n\treturn 0\n}\n\ncase \"$1\" in\n  start)\n\t[ \"$VERBOSE\" != no ] && log_daemon_msg \"Starting $DESC\" \"$NAME\"\n\tdo_start\n\tcase \"$?\" in\n\t\t0|1) [ \"$VERBOSE\" != no ] && log_end_msg 0 ;;\n\t\t2) [ \"$VERBOSE\" != no ] && log_end_msg 1 ;;\n\tesac\n\t;;\n  stop)\n\t[ \"$VERBOSE\" != no ] && log_daemon_msg \"Stopping $DESC\" \"$NAME\"\n\tdo_stop\n\tcase \"$?\" in\n\t\t0|1) [ \"$VERBOSE\" != no ] && log_end_msg 0 ;;\n\t\t2) [ \"$VERBOSE\" != no ] && log_end_msg 1 ;;\n\tesac\n\t;;\n  #reload|force-reload)\n\t#\n\t# If do_reload() is not implemented then leave this commented out\n\t# and leave 'force-reload' as an alias for 'restart'.\n\t#\n\t#log_daemon_msg \"Reloading $DESC\" \"$NAME\"\n\t#do_reload\n\t#log_end_msg $?\n\t#;;\n  restart|force-reload)\n\t#\n\t# If the \"reload\" option is implemented then remove the\n\t# 'force-reload' alias\n\t#\n\tlog_daemon_msg \"Restarting $DESC\" \"$NAME\"\n\tdo_stop\n\tcase \"$?\" in\n\t  0|1)\n\t\tdo_start\n\t\tcase \"$?\" in\n\t\t\t0) log_end_msg 0 ;;\n\t\t\t1) log_end_msg 1 ;; # Old process is still running\n\t\t\t*) log_end_msg 1 ;; # Failed to start\n\t\tesac\n\t\t;;\n\t  *)\n\t  \t# Failed to stop\n\t\tlog_end_msg 1\n\t\t;;\n\tesac\n\t;;\n  *)\n\t#echo \"Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}\" >&2\n\techo \"Usage: $SCRIPTNAME {start|stop|restart|force-reload}\" >&2\n\texit 3\n\t;;\nesac\n\n:\n"
        },
        {
          "name": "fedora-bmbouter",
          "type": "blob",
          "size": 1.4189453125,
          "content": "#!/bin/bash\n#\n#       /etc/rc.d/init.d/supervisord\n# supervisord   This shell script takes care of starting and stopping\n#               supervisord.  Tested on Fedora 11.\n#\n# Author: Brian Bouterse bmbouter@gmail.com\n#\n# chkconfig: 345 80 80\n# description: supervisord is a client/server process control system. \\\n# processname: supervisord\n# pidfile: /var/run/supervisord.pid\n\n# Source function library.\n. /etc/init.d/functions\n\nDAEMON=/usr/bin/supervisord\nPIDFILE=/var/run/supervisord.pid\n\n# Exit if the package is not installed\n[ -x \"$DAEMON\" ] || exit 0\n\nstart() {\n        echo -n \"Starting supervisord: \"\n        if [ -f $PIDFILE ]; then\n                PID=`cat $PIDFILE`\n                echo supervisord already running: $PID\n                exit 2;\n        else\n                daemon  $DAEMON --pidfile=$PIDFILE\n                RETVAL=$?\n                echo\n                [ $RETVAL -eq 0 ] && touch /var/lock/subsys/supervisord\n                return $RETVAL\n        fi\n\n}\n\nstop() {\n        echo -n \"Shutting down supervisord: \"\n        echo\n        killproc -p $PIDFILE supervisord\n        echo\n        rm -f /var/lock/subsys/supervisord\n        return 0\n}\n\ncase \"$1\" in\n    start)\n        start\n        ;;\n    stop)\n        stop\n        ;;\n    status)\n        status supervisord\n        ;;\n    restart)\n        stop\n        start\n        ;;\n    *)\n        echo \"Usage:  {start|stop|status|restart}\"\n        exit 1\n        ;;\nesac\nexit $?\n"
        },
        {
          "name": "gentoo-matagus",
          "type": "blob",
          "size": 1.5078125,
          "content": "#!/sbin/runscript\n# Copyright 1999-2005 Gentoo Foundation\n# Distributed under the terms of the GNU General Public License v2\n#\n# Author: Agustin Mendez (matagus@gmail.com)\n#\n\nopts=\"${opts} \"\npidfile=\"/var/run/supervisord/supervisord.pid\"\n\nfromcron=\"0\"\n# this next comment is important, don't remove it - it has to be somewhere in\n# the init script to kill off a warning that doesn't apply to us\n# svc_start svc_stop\ncheckconfig() {\n    if [[ -f \"${pidfile}\" ]] ; then\n        kill -0 $(< ${pidfile}) 2>/dev/null\n        if [[ $? -eq 0 ]] ; then\n            # the process exist, we have a problem\n            if  [[ $fromcron -eq \"0\" ]] ; then\n                eerror \"\\\"${pidfile}\\\" is still present and the process is running.\"\n                eerror \"Please stop it \\\"kill $(< ${pidfile})\\\" maybe ?\"\n            fi\n            return 1\n        else\n            rm -f \"${pidfile}\"\n        fi\n    fi\n    return 0\n}\n\nstart() {\n        checkconfig || return 1\n        ebegin \"Starting Supervisor Daemon\"\n        /usr/bin/supervisord\n        eend $?\n}\n\nstop() {\n        ebegin \"Stopping Supervisor Daemon\"\n    local PID timeout=${STOPTIMEOUT:-\"120\"}\n    PID=$(< \"${pidfile}\" )\n    start-stop-daemon --quiet --stop --pidfile \"${pidfile}\" &\n    while [[ -n \"$PID\" ]] \\\n        && $( ps -Ao pid | grep -q \"^ *$PID$\" ) \\\n        && [[ \"${timeout}\" -ge 1 ]]\n    do\n        timeout=$(($timeout - 1))\n        sleep 1\n    done\n    [[ \"${timeout}\" -lt 1 ]] && retstatus=1\n    sleep 1\n    [[ \"$retstatus\" -eq 0 ]] && rm -f \"$pidfile\"\n    eend ${retstatus}\n}\n"
        },
        {
          "name": "opensuse-garymonson",
          "type": "blob",
          "size": 1.705078125,
          "content": "#!/bin/bash\n#\n# /etc/init.d/supervisord\n# Handles starting and stopping supervisord.\n#\n# Tested on OpenSUSE 12.1, SLES 11 SP2\n# Author: Gary Monson gary.monson@gmail.com\n#\n### BEGIN INIT INFO\n# Provides:          supervisord\n# Required-Start:    $local_fs $remote_fs $network\n# Required-Stop:     $local_fs $remote_fs $network\n# Default-Start:     3 5\n# Default-Stop:      0 1 2 6\n# Description:       Provides supervisord service\n### END INIT INFO\n\nDAEMON=/usr/local/bin/supervisord\nBASE=`basename $DAEMON`\nPIDFILE=/var/run/$BASE.pid\nCONFIGFILE=/etc/$BASE.conf\nLOGFILE=/var/log/$BASE/$BASE.log\n\n# Exit if the package is not installed\n[ -x \"$DAEMON\" ] || exit 0\n\nstart() {\n    echo -n \"Starting supervisord: \"\n    if [ -f $PIDFILE ]; then\n        PID=`cat $PIDFILE`\n        echo supervisord already running: $PID\n        exit 2;\n    else\n        mkdir -p `dirname $LOGFILE`\n        $DAEMON --pidfile $PIDFILE --configuration $CONFIGFILE --logfile $LOGFILE\n        RETVAL=$?\n        return $RETVAL\n    fi\n}\n\nstop() {\n    echo \"Shutting down supervisord:\"\n    killproc -p $PIDFILE supervisord\n    return 0\n}\n\nstatus() {\n    if [ -f $PIDFILE ]; then\n        PID=`cat $PIDFILE`\n        ps -p $PID >/dev/null 2>&1\n        if [ \"$?\" = 0 ]; then\n            echo \"supervisord running\"\n            exit 0\n        else\n            echo \"pidfile exists ($PID), but supervisord not running\"\n            exit 2\n        fi\n    else\n        echo \"supervisord not running\"\n        exit 1\n    fi\n}\n\ncase \"$1\" in\n    start)\n        start\n        ;;\n    stop)\n        stop\n        ;;\n    restart)\n        stop\n        start\n        ;;\n    status)\n        status\n        ;;\n    *)\n        echo \"Usage:  {start|stop|restart}\"\n        exit 1\n        ;;\nesac\n\nexit $?\n"
        },
        {
          "name": "redhat-init-equeffelec",
          "type": "blob",
          "size": 3.0908203125,
          "content": "#!/bin/bash\n#\n# supervisord   Startup script for the Supervisor process control system\n#\n# Author:       Mike McGrath <mmcgrath@redhat.com> (based off yumupdatesd)\n#               Jason Koppe <jkoppe@indeed.com> adjusted to read sysconfig,\n#                   use supervisord tools to start/stop, conditionally wait\n#                   for child processes to shutdown, and startup later\n#               Erwan Queffelec <erwan.queffelec@gmail.com>\n#                   make script LSB-compliant\n#               Greg Smethells <gsmethells@mgmail.com>\n#.                  Allow supervisorctl to be overridden\n#\n# chkconfig:    345 83 04\n# description: Supervisor is a client/server system that allows \\\n#   its users to monitor and control a number of processes on \\\n#   UNIX-like operating systems.\n# processname: supervisord\n# config: /etc/supervisord.conf\n# config: /etc/sysconfig/supervisord\n# pidfile: /var/run/supervisord.pid\n#\n### BEGIN INIT INFO\n# Provides: supervisord\n# Required-Start: $all\n# Required-Stop: $all\n# Short-Description: start and stop Supervisor process control system\n# Description: Supervisor is a client/server system that allows\n#   its users to monitor and control a number of processes on\n#   UNIX-like operating systems.\n### END INIT INFO\n\n# Source function library\n. /etc/rc.d/init.d/functions\n\n# Source system settings\nif [ -f /etc/sysconfig/supervisord ]; then\n    . /etc/sysconfig/supervisord\nfi\n\n# Path to the supervisorctl script, server binary,\n# and short-form for messages.\nsupervisorctl=${SUPERVISORCTL-/usr/bin/supervisorctl}\nsupervisord=${SUPERVISORD-/usr/bin/supervisord}\nprog=supervisord\npidfile=${PIDFILE-/var/run/supervisord.pid}\nlockfile=${LOCKFILE-/var/lock/subsys/supervisord}\nsockfile=${SOCKFILE-/var/run/supervisord.sock}\nSTOP_TIMEOUT=${STOP_TIMEOUT-60}\nOPTIONS=\"${OPTIONS--c /etc/supervisord.conf}\"\nRETVAL=0\n\nstart() {\n    echo -n $\"Starting $prog: \"\n    daemon --pidfile=${pidfile} $supervisord $OPTIONS\n    RETVAL=$?\n    echo\n    if [ $RETVAL -eq 0 ]; then\n        touch ${lockfile}\n        $supervisorctl $OPTIONS status\n    fi\n    return $RETVAL\n}\n\nstop() {\n    echo -n $\"Stopping $prog: \"\n    killproc -p ${pidfile} -d ${STOP_TIMEOUT} $supervisord\n    RETVAL=$?\n    echo\n    [ $RETVAL -eq 0 ] && rm -rf ${lockfile} ${pidfile} ${sockfile}\n}\n\nreload() {\n    echo -n $\"Reloading $prog: \"\n    LSB=1 killproc -p $pidfile $supervisord -HUP\n    RETVAL=$?\n    echo\n    if [ $RETVAL -eq 7 ]; then\n        failure $\"$prog reload\"\n    else\n        $supervisorctl $OPTIONS status\n    fi\n}\n\nrestart() {\n    stop\n    start\n}\n\ncase \"$1\" in\n    start)\n        start\n        ;;\n    stop)\n        stop\n        ;;\n    status)\n        status -p ${pidfile} $supervisord\n        RETVAL=$?\n        [ $RETVAL -eq 0 ] && $supervisorctl $OPTIONS status\n        ;;\n    restart)\n        restart\n        ;;\n    condrestart|try-restart)\n        if status -p ${pidfile} $supervisord >&/dev/null; then\n          stop\n          start\n        fi\n        ;;\n    force-reload|reload)\n        reload\n        ;;\n    *)\n        echo $\"Usage: $prog {start|stop|restart|condrestart|try-restart|force-reload|reload}\"\n        RETVAL=2\nesac\n\nexit $RETVAL\n"
        },
        {
          "name": "redhat-init-jkoppe",
          "type": "blob",
          "size": 3.4150390625,
          "content": "#!/bin/bash\n#\n# supervisord   This scripts turns supervisord on\n#\n# Author:       Mike McGrath <mmcgrath@redhat.com> (based off yumupdatesd)\n#               Jason Koppe <jkoppe@indeed.com> adjusted to read sysconfig,\n#                   use supervisord tools to start/stop, conditionally wait\n#                   for child processes to shutdown, and startup later\n#               Cameron Kerr <cameron.kerr.nz@gmail.com> adjusted 'status'\n#                   to return an LSB-compliant return code so things like\n#                   Ansible will be able to idempotently ensure service is\n#                   up or down as desired.\n#\n# chkconfig:    345 83 04\n#\n# description:  supervisor is a process control utility.  It has a web based\n#               xmlrpc interface as well as a few other nifty features.\n# processname:  supervisord\n# config: /etc/supervisord.conf\n# pidfile: /var/run/supervisord.pid\n#\n\n# Treat unset variables as error\nset -o nounset\n\n# source function library\n. /etc/rc.d/init.d/functions\n\n# source system settings\n[ -e /etc/sysconfig/supervisord ] && . /etc/sysconfig/supervisord\n\nRETVAL=0\n\nstart() {\n    echo \"Starting supervisord: \"\n\tif [ -e $PIDFILE ]; then \n\t\techo \"ALREADY STARTED\"\n\t\treturn 1\n\tfi\n\n\t# start supervisord with options from sysconfig (stuff like -c)\n    /usr/bin/supervisord $OPTIONS\n\t\n\t# show initial startup status\n\t/usr/bin/supervisorctl $OPTIONS status\n\t\n\t# only create the subsyslock if we created the PIDFILE\n    [ -e $PIDFILE ] && touch /var/lock/subsys/supervisord\n}\n\nstop() {\n    echo -n \"Stopping supervisord: \"\n    /usr/bin/supervisorctl $OPTIONS shutdown\n\tif [ -n \"$WAIT_FOR_SUBPROCESSES\" ]; then \n        echo \"Waiting roughly 60 seconds for $PIDFILE to be removed after child processes exit\"\n        for sleep in  2 2 2 2 4 4 4 4 8 8 8 8 last; do\n            if [ ! -e $PIDFILE ] ; then\n                echo \"Supervisord exited as expected in under $total_sleep seconds\"\n                break\n            else\n                if [[ $sleep -eq \"last\" ]] ; then\n                    echo \"Supervisord still working on shutting down. We've waited roughly 60 seconds, we'll let it do its thing from here\"\n                    return 1\n                else\n                    sleep $sleep\n                    total_sleep=$(( $total_sleep + $sleep ))\n                fi\n\n            fi\n        done\n    fi\n\n    # always remove the subsys.  we might have waited a while, but just remove it at this point.\n    rm -f /var/lock/subsys/supervisord\n}\n\nrestart() {\n        stop\n        start\n}\n\ncase \"$1\" in\n    start)\n        start\n        RETVAL=$?\n        ;;\n    stop)\n        stop\n        RETVAL=$?\n        ;;\n    restart|force-reload)\n        restart\n        RETVAL=$?\n        ;;\n    reload)\n        /usr/bin/supervisorctl $OPTIONS reload\n        RETVAL=$?\n        ;;\n    condrestart)\n        [ -f /var/lock/subsys/supervisord ] && restart\n        RETVAL=$?\n        ;;\n    status)\n        /usr/bin/supervisorctl $OPTIONS status\n        status -p $PIDFILE supervisord\n        # The 'status' option should return one of the LSB-defined return-codes,\n        # in particular, return-code 3 should mean that the service is not\n        # currently running. This is particularly important for Ansible's 'service'\n        # module, as without this behaviour it won't know if a service is up or down.\n        RETVAL=$?\n        ;;\n    *)\n        echo $\"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart}\"\n        exit 1\nesac\n\nexit $RETVAL\n"
        },
        {
          "name": "redhat-init-mingalevme",
          "type": "blob",
          "size": 4.015625,
          "content": "#!/bin/bash\n#\n# supervisord   This scripts turns supervisord on\n#\n# Author:       Mike McGrath <mmcgrath@redhat.com> (based off yumupdatesd)\n#               Jason Koppe <jkoppe@indeed.com> adjusted to read sysconfig,\n#                   use supervisord tools to start/stop, conditionally wait\n#                   for child processes to shutdown, and startup later\n#               Mikhail Mingalev <mingalevme@gmail.com> Merged\n#                   redhat-init-jkoppe and redhat-sysconfig-jkoppe, and\n#                   made the script \"simple customizable\".\n#               Brendan Maguire <maguire.brendan@gmail.com> Added OPTIONS to\n#                   SUPERVISORCTL status call\n#\n# chkconfig:    345 83 04\n#\n# description:  supervisor is a process control utility.  It has a web based\n#               xmlrpc interface as well as a few other nifty features.\n#               Script was originally written by Jason Koppe <jkoppe@indeed.com>.\n#\n\n# source function library\n. /etc/rc.d/init.d/functions\n\nset -a\n\nPREFIX=/usr\n\nSUPERVISORD=$PREFIX/bin/supervisord\nSUPERVISORCTL=$PREFIX/bin/supervisorctl\n\nPIDFILE=/var/run/supervisord.pid\nLOCKFILE=/var/lock/subsys/supervisord\n\nOPTIONS=\"-c /etc/supervisord.conf\"\n\n# unset this variable if you don't care to wait for child processes to shutdown before removing the $LOCKFILE-lock\nWAIT_FOR_SUBPROCESSES=yes\n\n# remove this if you manage number of open files in some other fashion\nulimit -n 96000\n\nRETVAL=0\n\n\nrunning_pid()\n{\n    # Check if a given process pid's cmdline matches a given name\n    pid=$1\n    name=$2\n    [ -z \"$pid\" ] && return 1\n    [ ! -d /proc/$pid ] && return 1\n    (cat /proc/$pid/cmdline | tr \"\\000\" \"\\n\"|grep -q $name) || return 1\n    return 0\n}\n\nrunning()\n{\n# Check if the process is running looking at /proc\n# (works for all users)\n\n    # No pidfile, probably no daemon present\n    [ ! -f \"$PIDFILE\" ] && return 1\n    # Obtain the pid and check it against the binary name\n    pid=`cat $PIDFILE`\n    running_pid $pid $SUPERVISORD || return 1\n    return 0\n}\n\nstart() {\n        echo \"Starting supervisord: \"\n\t\n        if [ -e $PIDFILE ]; then \n\t\techo \"ALREADY STARTED\"\n\t\treturn 1\n\tfi\n\n\t# start supervisord with options from sysconfig (stuff like -c)\n        $SUPERVISORD $OPTIONS\n\t\n\t# show initial startup status\n\t$SUPERVISORCTL $OPTIONS status\n\t\n\t# only create the subsyslock if we created the PIDFILE\n        [ -e $PIDFILE ] && touch $LOCKFILE\n}\n\nstop() {\n        echo -n \"Stopping supervisord: \"\n        $SUPERVISORCTL $OPTIONS shutdown\n\tif [ -n \"$WAIT_FOR_SUBPROCESSES\" ]; then \n            echo \"Waiting roughly 60 seconds for $PIDFILE to be removed after child processes exit\"\n            for sleep in  2 2 2 2 4 4 4 4 8 8 8 8 last; do\n                if [ ! -e $PIDFILE ] ; then\n                    echo \"Supervisord exited as expected in under $total_sleep seconds\"\n                    break\n                else\n                    if [[ $sleep -eq \"last\" ]] ; then\n                        echo \"Supervisord still working on shutting down. We've waited roughly 60 seconds, we'll let it do its thing from here\"\n                        return 1\n                    else\n                        sleep $sleep\n                        total_sleep=$(( $total_sleep + $sleep ))\n                    fi\n\n                fi\n            done\n        fi\n\n        # always remove the subsys. We might have waited a while, but just remove it at this point.\n        rm -f $LOCKFILE\n}\n\nrestart() {\n        stop\n        start\n}\n\ncase \"$1\" in\n    start)\n        start\n        RETVAL=$?\n        ;;\n    stop)\n        stop\n        RETVAL=$?\n        ;;\n    restart|force-reload)\n        restart\n        RETVAL=$?\n        ;;\n    reload)\n        $SUPERVISORCTL $OPTIONS reload\n        RETVAL=$?\n        ;;\n    condrestart)\n        [ -f $LOCKFILE ] && restart\n        RETVAL=$?\n        ;;\n    status)\n        $SUPERVISORCTL $OPTIONS status\n        if running ; then\n            RETVAL=0\n        else\n            RETVAL=1\n        fi\n        ;;\n    *)\n        echo $\"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart}\"\n        exit 1\nesac\n\nexit $RETVAL\n"
        },
        {
          "name": "redhat-sysconfig-equeffelec",
          "type": "blob",
          "size": 0.7060546875,
          "content": "# Configuration file for the supervisord service\n#\n# Author: Jason Koppe <jkoppe@indeed.com>\n#             orginal work\n#         Erwan Queffelec <erwan.queffelec@gmail.com>\n#             adjusted to new LSB-compliant init script\n\n# WARNING: change these wisely! for instance, adding -d, --nodaemon\n# here will lead to a very undesirable (blocking) behavior\n#OPTIONS=\"-c /etc/supervisord.conf\"\n#PIDFILE=/var/run/supervisord.pid\n#LOCKFILE=/var/lock/subsys/supervisord.pid\n\n# Path to the supervisord binary\n#SUPERVISORD=/usr/bin/supervisord\n\n# How long should we wait before forcefully killing the supervisord process ?\n#STOP_TIMEOUT=60\n\n# Remove this if you manage number of open files in some other fashion\nulimit -n 96000\n"
        },
        {
          "name": "redhat-sysconfig-jkoppe",
          "type": "blob",
          "size": 0.451171875,
          "content": "# this is sourced by the supervisord init script\n# written by jkoppe\n\nset -a \n\n# should probably put both of these options as runtime arguments \nOPTIONS=\"-c /etc/supervisord.conf\"\nPIDFILE=/var/run/supervisord.pid\n\n# unset this variable if you don't care to wait for child processes to shutdown before removing the /var/lock/subsys/supervisord lock\nWAIT_FOR_SUBPROCESSES=yes\n\n# remove this if you manage number of open files in some other fashion\nulimit -n 96000\n"
        },
        {
          "name": "slackware",
          "type": "blob",
          "size": 2.01953125,
          "content": "#!/bin/sh\n# /etc/rc.d/rc.supervisord\n#\n# AUTHOR: Josh Jaques <jjaques@gmail.com>\n#\n# Start/stop/restart supervisor in slackware.\n# Specfically tested in v13.37\n#\n# To make Supervisor start automatically at boot, make this\n# file executable:  chmod 755 /etc/rc.d/rc.supervisord\n\n# Time to wait between stop/start on a restart\nSHUTDOWN_TIME=5\n\n# Time to wait after a start before reporting success/fail\nSTARTUP_TIME=1\n\n# Location of the pid file\nPIDFILE=/var/run/supervisord.pid\n\n# Config of supervisor\nCONFIG=/etc/supervisord.conf\n\n# Daemon to start\nDAEMON=supervisord\n\nsupervisord_start()\n{\n    $DAEMON -c $CONFIG -j $PIDFILE\n}\n\n\nsupervisord_status()\n{\n    if [ -f $PIDFILE ]\n    then\n        pgrep $DAEMON | grep -f $PIDFILE > /dev/null 2>/dev/null\n        if [ $? -eq 0 ]\n        then\n            return 0\n        else\n            return 1\n        fi\n    else\n        return 1\n    fi\n}\n\n\nsupervisord_stop()\n{\n    kill $(cat $PIDFILE)\n}\n\ncase \"$1\" in\n  'start')\n      echo -n \"Starting...\"\n      supervisord_start\n      sleep $STARTUP_TIME\n      supervisord_status && echo \"DONE [PID: $(cat $PIDFILE)]\" || echo \"ERROR\"\n  ;;\n\n  'status')\n      supervisord_status && echo \"RUNNING [PID: $(cat $PIDFILE)]\" || echo \"STOPPED\"\n  ;;\n\n\n  'stop')\n      supervisord_status && {\n        echo -n \"Stopping $(cat $PIDFILE)...\"\n        supervisord_stop\n        sleep $SHUTDOWN_TIME\n        supervisord_status && echo \"Failed\" || echo \"Success\"\n      } || {\n        echo \"Not Running...\"\n        exit 1\n    }\n  ;;\n\n  'restart')\n      supervisord_status && {\n        echo -n \"Stopping $(cat $PIDFILE)...\"\n        supervisord_stop\n        sleep $SHUTDOWN_TIME\n        supervisord_status && {\n            echo \"Failed\"\n            exit 1 \n        } || {\n            echo \"Success\"\n        }\n      } || {\n        echo \"Not Running...\"\n        exit 1\n      }\n      echo -n \"Starting...\"\n      supervisord_start\n      sleep $STARTUP_TIME\n      supervisord_status && echo \"DONE [PID: $(cat $PIDFILE)]\" || echo \"ERROR\"\n  ;;\n\n  *)\n    echo \"Usage: $0 {start|stop|restart|status}\"\n  ;;\nesac\n\n"
        },
        {
          "name": "ubuntu",
          "type": "blob",
          "size": 4.67578125,
          "content": "#! /bin/sh\n#\n# Downloaded from:\n# http://bazaar.launchpad.net/~ubuntu-branches/ubuntu/trusty/supervisor/trusty/view/head:/debian/supervisor.init\n#\n# skeleton\texample file to build /etc/init.d/ scripts.\n#\t\tThis file should be used to construct scripts for /etc/init.d.\n#\n#\t\tWritten by Miquel van Smoorenburg <miquels@cistron.nl>.\n#\t\tModified for Debian\n#\t\tby Ian Murdock <imurdock@gnu.ai.mit.edu>.\n#               Further changes by Javier Fernandez-Sanguino <jfs@debian.org>\n#               Modified by sbilly <superli.1980@gmail.com> Added supervisorctl to status\n#\n# Version:\t@(#)skeleton  1.9  26-Feb-2001  miquels@cistron.nl\n#\n### BEGIN INIT INFO\n# Provides:          supervisor\n# Required-Start:    $remote_fs $network $named\n# Required-Stop:     $remote_fs $network $named\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: Start/stop supervisor\n# Description:       Start/stop supervisor daemon and its configured\n#                    subprocesses.\n### END INIT INFO\n\n. /lib/lsb/init-functions\n\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\nDAEMON=/usr/bin/supervisord\nSUPERVISORCTL=/usr/bin/supervisorctl\nNAME=supervisord\nDESC=supervisor\n\ntest -x $DAEMON || exit 0\n\nLOGDIR=/var/log/supervisor\nPIDFILE=/var/run/$NAME.pid\nDODTIME=5                   # Time to wait for the server to die, in seconds\n                            # If this value is set too low you might not\n                            # let some servers to die gracefully and\n                            # 'restart' will not work\n\n# Include supervisor defaults if available\nif [ -f /etc/default/supervisor ] ; then\n\t. /etc/default/supervisor\nfi\nDAEMON_OPTS=\"-c /etc/supervisor/supervisord.conf $DAEMON_OPTS\"\n\nset -e\n\nrunning_pid()\n{\n    # Check if a given process pid's cmdline matches a given name\n    pid=$1\n    name=$2\n    [ -z \"$pid\" ] && return 1\n    [ ! -d /proc/$pid ] &&  return 1\n    (cat /proc/$pid/cmdline | tr \"\\000\" \"\\n\"|grep -q $name) || return 1\n    return 0\n}\n\nrunning()\n{\n# Check if the process is running looking at /proc\n# (works for all users)\n\n    # No pidfile, probably no daemon present\n    [ ! -f \"$PIDFILE\" ] && return 1\n    # Obtain the pid and check it against the binary name\n    pid=`cat $PIDFILE`\n    running_pid $pid $DAEMON || return 1\n    return 0\n}\n\nforce_stop() {\n# Forcefully kill the process\n    [ ! -f \"$PIDFILE\" ] && return\n    if running ; then\n        kill -15 $pid\n        # Is it really dead?\n        [ -n \"$DODTIME\" ] && sleep \"$DODTIME\"s\n        if running ; then\n            kill -9 $pid\n            [ -n \"$DODTIME\" ] && sleep \"$DODTIME\"s\n            if running ; then\n                echo \"Cannot kill $NAME (pid=$pid)!\"\n                exit 1\n            fi\n        fi\n    fi\n    rm -f $PIDFILE\n    return 0\n}\n\ncase \"$1\" in\n  start)\n\techo -n \"Starting $DESC: \"\n\tstart-stop-daemon --start --quiet --pidfile $PIDFILE \\\n\t\t--startas $DAEMON -- $DAEMON_OPTS\n\ttest -f $PIDFILE || sleep 1\n        if running ; then\n            echo \"$NAME.\"\n        else\n            echo \" ERROR.\"\n        fi\n\t;;\n  stop)\n\techo -n \"Stopping $DESC: \"\n\tstart-stop-daemon --stop --quiet --oknodo --pidfile $PIDFILE\n\techo \"$NAME.\"\n\t;;\n  force-stop)\n\techo -n \"Forcefully stopping $DESC: \"\n        force_stop\n        if ! running ; then\n            echo \"$NAME.\"\n        else\n            echo \" ERROR.\"\n        fi\n\t;;\n  #reload)\n\t#\n\t#\tIf the daemon can reload its config files on the fly\n\t#\tfor example by sending it SIGHUP, do it here.\n\t#\n\t#\tIf the daemon responds to changes in its config file\n\t#\tdirectly anyway, make this a do-nothing entry.\n\t#\n\t# echo \"Reloading $DESC configuration files.\"\n\t# start-stop-daemon --stop --signal 1 --quiet --pidfile \\\n\t#\t/var/run/$NAME.pid --exec $DAEMON\n  #;;\n  force-reload)\n\t#\n\t#\tIf the \"reload\" option is implemented, move the \"force-reload\"\n\t#\toption to the \"reload\" entry above. If not, \"force-reload\" is\n\t#\tjust the same as \"restart\" except that it does nothing if the\n\t#   daemon isn't already running.\n\t# check wether $DAEMON is running. If so, restart\n\tstart-stop-daemon --stop --test --quiet --pidfile $PIDFILE \\\n        --startas $DAEMON \\\n\t&& $0 restart \\\n\t|| exit 0\n\t;;\n  restart)\n    echo -n \"Restarting $DESC: \"\n    start-stop-daemon --stop --quiet --oknodo --pidfile $PIDFILE\n\t[ -n \"$DODTIME\" ] && sleep $DODTIME\n\tstart-stop-daemon --start --quiet --pidfile $PIDFILE \\\n\t\t--startas $DAEMON -- $DAEMON_OPTS\n\techo \"$NAME.\"\n\t;;\n  status)\n    echo -n \"$NAME is \"\n    if running ;  then\n        echo \"running\"\n    else\n        echo \" not running.\"\n        exit 1\n    fi\n    $SUPERVISORCTL $DAEMON_OPTS status\n    ;;\n  *)\n\tN=/etc/init.d/$NAME\n\t# echo \"Usage: $N {start|stop|restart|reload|force-reload}\" >&2\n\techo \"Usage: $N {start|stop|restart|force-reload|status|force-stop}\" >&2\n\texit 1\n\t;;\nesac\n\nexit 0\n"
        }
      ]
    }
  ]
}