{
  "metadata": {
    "timestamp": 1736568702024,
    "page": 793,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "aleskxyz/reality-ezpz",
      "stars": 1232,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.4033203125,
          "content": "# reality-ezpz\nInstall and configure vless with reality or TLS on your linux server by executing a single command!\n\nTUIC and hysteria2 on sing-box is also supported!\n\nThis script:\n* Installs docker with compose plugin in your server\n* Generates docker-compose.yml and sing-box/xray configuration for vless protocol for reality and tls\n* Generates docker-compose.yml and sing-box configuration for TUIC protocol with tls\n* Generates docker-compose.yml and sing-box configuration for hysteria2 protocol with tls\n* Create Cloudflare warp account and configure warp as outbound\n* Generates client configuration string and QRcode\n* Gets and renews valid certificate from Letsencrypt for TLS encryption\n* Fine-tunes kernel tunables\n* Is designed by taking security considerations into account  to make the server undetectable\n* Provides a Telegram bot to manage users from Telegram\n\nFeatures:\n* Generates client configuration string\n* Generates client configuration QRcode\n* You can choose between xray or sing-box core\n* You can choose between reality or TLS security protocol\n* You can use a Text-based user interface (TUI)\n* You can create multiple user accounts\n* You can regenerate configuration and keys\n* You can change SNI domain\n* You can change transport protocol (tcp, http, grpc, ws)\n* You can change tunneling protocol (vless, TUIC, hysteria2, shadowtls)\n* You can get valid TLS certificate with Letsencrypt\n* You can block malware and adult contents\n* Merges your custom advanced configuration\n* Use Cloudflare WARP to hide your outbound traffic\n* Supports Cloudflare warp+\n* Install with a single command\n* Telegram bot for user management\n* Create backup from users and configuration\n* Restore users and configuration from backup\n\nSupported OS:\n* Ubuntu 22.04\n* Ubuntu 20.04\n* Ubuntu 18.04\n* Debian 11\n* Debian 10\n* CentOS Stream 9\n* CentOS Stream 8\n* CentOS 7\n* Fedora 37\n\n## Quick Start\nYou can start using this script with default configuration by copy and paste the line below in terminal.\n\nThis command will configure `sing-box` with `reality` security protocol over `tcp` transport protocol on port `443` for `www.google.com` SNI domain by default:\n```\nbash <(curl -sL https://bit.ly/realityez)\n```\nor (if the above command dosen't work):\n```\nbash <(curl -sL https://raw.githubusercontent.com/aleskxyz/reality-ezpz/master/reality-ezpz.sh)\n```\nAfter a while you will get configuration string and QR code:\n![image](https://user-images.githubusercontent.com/39186039/232563871-0140e10a-22b4-4653-9bc9-cdba519a8b41.png)\n\nYou can run TUI with `-m` or `--menu` option:\n```\nbash <(curl -sL https://bit.ly/realityez) -m\n```\nAnd then you will see management menu in your terminal:\n![image](https://github.com/aleskxyz/reality-ezpz/assets/39186039/a727148c-1a11-4702-80f3-ab8b46d916af)\n\nYou can also enable Telegram bot with `--enable-tgbot` option and manage users from with your Telegram bot ([More Info](#telegram-bot))\n<p align=\"center\">\n<img src=\"https://github.com/aleskxyz/reality-ezpz/assets/39186039/7e31383a-e00b-426e-9324-6d58f36e7da0\" width=\"300\">\n</p>\n\nHelp message of the script:\n```\n\nUsage: reality-ezpz.sh [-t|--transport=tcp|http|grpc|ws|tuic|hysteria2|shadowtls] [-d|--domain=<domain>] [--server=<server>]\n  [--regenerate] [--default] [-r|--restart] [--enable-safenet=true|false] [--port=<port>] [-c|--core=xray|sing-box]\n  [--enable-warp=true|false] [--warp-license=<license>] [--security=reality|letsencrypt|selfsigned] [-m|--menu]\n  [--show-server-config] [--add-user=<username>] [--lists-users] [--show-user=<username>] [--delete-user=<username>]\n  [--backup] [--restore=<url|file>] [--backup-password=<password>] [-u|--uninstall]\n\n  -t, --transport <tcp|http|grpc|ws|tuic|hysteria2|shadowtls> Transport protocol (tcp, http, grpc, ws, tuic, hysteria2, shadowtls default: tcp)\n  -d, --domain <domain>     Domain to use as SNI (default: www.google.com)\n      --server <server>     IP address or domain name of server (Must be a valid domain if using letsencrypt security)\n      --regenerate          Regenerate public and private keys\n      --default             Restore default configuration\n  -r  --restart             Restart services\n  -u, --uninstall           Uninstall reality\n      --enable-safenet <true|false> Enable or disable safenet (blocking malware and adult content)\n      --port <port>         Server port (default: 443)\n      --enable-warp <true|false> Enable or disable Cloudflare warp\n      --warp-license <warp-license> Add Cloudflare warp+ license\n  -c  --core <sing-box|xray> Select core (xray, sing-box, default: sing-box)\n      --security <reality|letsencrypt|selfsigned> Select type of TLS encryption (reality, letsencrypt, selfsigned, default: reality)\n  -m  --menu                Show menu\n      --enable-tgbot <true|false> Enable Telegram bot for user management\n      --tgbot-token <token> Token of Telegram bot\n      --tgbot-admins <telegram-username> Usernames of telegram bot admins (Comma separated list of usernames without leading '@')\n      --show-server-config  Print server configuration\n      --add-user <username> Add new user\n      --list-users          List all users\n      --show-user <username> Shows the config and QR code of the user\n      --delete-user <username> Delete the user\n      --backup              Backup users and configuration and upload it to temp.sh\n      --restore <url|file>  Restore backup from URL or file\n      --backup-password <password> Create/Restore password protected backup file\n  -h, --help                Display this help message\n```\n\n## Clients\n- Android\n  - [v2rayNG](https://github.com/2dust/v2rayNg/releases)\n  - [NekoBox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases)\n- iOS\n  - [FoXray](https://apps.apple.com/app/foxray/id6448898396)\n  - [Shadowrocket](https://apps.apple.com/app/shadowrocket/id932747118)\n  - [Stash](https://apps.apple.com/app/stash/id1596063349)\n- Windows\n  - [v2rayN](https://github.com/2dust/v2rayN/releases)\n- Windows, Linux, macOS\n  - [NekoRay](https://github.com/MatsuriDayo/nekoray/releases)\n  - [Furious](https://github.com/LorenEteval/Furious/releases)\n\n## Security Options\nThis script can configure the service with 3 types of security options:\n- reality\n- letsencrypt\n- selfsigned\n\nBy default `reality` is configured but you can change the security protocol with `--security` option.\n\nThe `letsencrypt` option will use Letsencrypt to get a valid certificate for you server. So you have to assign a valid domain or subdomain to your server with `--server <domain>` option.\n\nThe `selfsigned` option is same as `letsencrypt` but the certificates are self-signed and you don't need to assign a domain or subdomain to your server.\n\n## Compatibility and recommendation\nCDN compatibility table:\n\n|   | Cloudflare | ArvanCloud |\n| ------------ | ------------ | ------------ |\n| reality | :x: | :x: |\n| selfsigned | :heavy_check_mark: | :heavy_check_mark: |\n| letsencrypt | :heavy_check_mark: | :heavy_check_mark: |\n| tcp  | :x:  | :x:  |\n| http  | :x:  | :heavy_check_mark:  |\n| grpc  | :heavy_check_mark:  | :heavy_check_mark:  |\n| ws  | :heavy_check_mark:  | :heavy_check_mark:  |\n| tuic  | :x:  | :x:  |\n| hysteria2  | :x:  | :x:  |\n| shadowtls  | :x:  | :x:  |\n\n- You need to enable `grpc` or `websocket` in Cloudflare if you want to use the corresponding transport protocols.\n- You have to configure CDN provider to use HTTPS for connecting to your server.\n- The `ws` transport protocol is not compatible with `reality` security option.\n- The `tuic` tunneling protocol is not compatible with `reality` security option.\n- The `tuic` tunneling protocol is only compatible with `sing-box` core option.\n- The `hysteria2` tunneling protocol is not compatible with `reality` security option.\n- The `hysteria2` tunneling protocol is only compatible with `sing-box` core option.\n- The `shadowtls` tunneling protocol is only compatible with `sing-box` core option.\n- Avoid using `tcp` transport protocol with `letsencrypt` or `selfsigned` security options.\n- Avoid using `selfsigned` security option. Get a domain and use `letsencrypt` option.\n- Do not change the port to something other than `443`.\n- The `sing-box` core has better performance.\n- Using [NekoBox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases) for Android is recommended.\n\n## User Management\nYou can add, view and delete multiple user account with this script easily!\n\n### Add User\nYou can add additional user by using `--add-user` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --add-user user1\n```\nThis command will create `test1` as a new user.\n\nNotice: Username can only contains A-Z, a-z and 0-9\n\n### List Users\nYou can view a list of all users by using `--list-users` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --list-users\n```\n\n### Show User Configuration\nYou can get config string and QR code of the user for importing by using `--show-user` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --show-user user1\n```\nThis command will print config string and QR code of `user1`\n\n### Delete User\nYou can delete a user by using `--delete-user` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --delete-user user1\n```\nThis command will delete `user1`\n\n## Advanced Configuration\nYou can change script defaults by using different arguments.\n\nYour configuration will be saved and restored in each execution. So You can run the script multiple time with out any problem.\n\n### Change SNI domain\nReality protocol will use the public certificate of SNI domain.\n\nDefault SNI domain is `www.google.com`.\n\nYou can change it by using `--domain` or `-d` options:\n```\nbash <(curl -sL https://bit.ly/realityez) -d yahoo.com\n```\n### Change transport protocol\nDefault transport protocol is `tcp`.\n\nYou can change it by using `--transport` or `-t` options:\n```\nbash <(curl -sL https://bit.ly/realityez) -t http\n```\nValid options are `tcp`,`http`, `grpc`, `ws`, `tuic`, `hysteria2` and `shadowtls`.\n\n`ws` is not compatible with reality protocol. You have to use `letsencrypt` or `selfsigned` with it.\n\n`tuic` is not compatible with reality protocol. You have to use `letsencrypt` or `selfsigned` with it.\n\n`tuic` is compatible with sing-box core only.\n\n`hysteria2` is not compatible with reality protocol. You have to use `letsencrypt` or `selfsigned` with it.\n\n`hysteria2` is compatible with sing-box core only.\n\n`shadowtls` is compatible with sing-box core only.\n\n#### ShadowTLS\nShadowTLS is a TLS disguise proxy that can use someone else's trusted certificate. It is similar to \"Reality,\" but in transport, it uses Shadowsocks. So you need to assign a working SNI to it.\n\nWhen you enable ShadowTLS, you will configure two proxies: ShadowTLS and Shadowsocks.\n\nYou need to configure your client to use both proxies in chain mode.\n\nFirst, ShadowTLS will establish a secure connection with the server, then Shadowsocks will use the connection created by ShadowTLS.\n\n### Block malware and adult contents\nYou can block malware and adult contents by using `--enable-safenet` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --enable-safenet true\n```\nYou can disable this feature with `--enable-safenet false` option.\n\n### Get runnig configuration\nYou can get the running configuration with `--show-server-config` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --show-server-config\n```\n\n### Regenerate configuration keys\nYou can regenerate keys by using `--regenerate` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --regenerate\n```\nAll other configuration will be same as before.\n\n### Restart services\nYou can restart the service by using `-r` or `--restart` options:\n```\nbash <(curl -sL https://bit.ly/realityez) -r\n```\n\n### Restore default configuration\nYou can restore default configuration by using `--default` option.\n```\nbash <(curl -sL https://bit.ly/realityez) --default\n```\nUser account will not change with this option.\n\n### Uninstall\nYou can delete configuration and services by using `--uninstall` or `-u` options:\n```\nbash <(curl -sL https://bit.ly/realityez) -u\n```\n\n### Change port\nNotice: Do not change default port. This may block your IP!\n\nDefault port is `443`.\n\nIn case of using `letsencrypt` security option, port `80` has to be available for Letsencrypt challenge.\n\nYou can change it by using `--port` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --port 8443\n```\n\n### Change engine core\nDefault engine core is sing-box but you can also switch to xray by using `--core` or `-c` options:\n```\nbash <(curl -sL https://bit.ly/realityez) -c xray\n```\nValid options are `xray` and `sing-box`.\n\n### Create backup\nYou can create a backup from users and configuration and upload it to https://temp.sh/ by using `--backup` option.\n\nThe `--backup-password` option allows you to protect the backup zip file with the specified password. (Optional)\n```\nbash <(curl -sL https://bit.ly/realityez) --backup --backup-password \"P@ssw0rd\"\n```\nThis command will give you a URL to download you backup file. The URL is only valid for 3 days.\n\n### Restore backup\nYou can restore a previously created backup file with `--restore` option.\n\nYou need to give the path or URL of the backup file to restore.\n\nThe `--backup-password` option allows you to restore the password protected backup zip file.\n```\nbash <(curl -sL https://bit.ly/realityez) --restore /path/to/backup.zip --backup-password \"P@ssw0rd\"\n```\nor\n```\nbash <(curl -sL https://bit.ly/realityez) --restore \"https://www.example.com/backup.zip\" --backup-password \"P@ssw0rd\"\n```\n\nYou can migrate users and configuration from one server to another by:\n\n1. Create backup in the old server and copy the URL of backup file\n1. Restore the URL of backup file in the new server\n\n### Text-based user interface (TUI)\nYou can also use the TUI for changing the configuration of the service.\n\nTo access to TUI you can use `-m` or `--menu` options:\n```\nbash <(curl -sL https://bit.ly/realityez) -m\n```\n\n## Telegram Bot\nYou can manage users with Telegram Bot.\n\nYou should get a Telegram bot token from `@BotFather` Telegram account.\n\nThen you can enable Telegram bot by using this command as an example:\n```\nbash <(curl -sL https://bit.ly/realityez) --enable-tgbot true --tgbot-token <telegram-bot-token> --tgbot-admins=<your-telegram-username>\n```\nIn the command above you have to provide a comma separated list of Telegram usernames (without leading '@') which are authorized to use Telegram bot.\n\nYou can disable Telegram bot with this command:\n```\nbash <(curl -sL https://bit.ly/realityez) --enable-tgbot false\n```\n\n## Cloudflare WARP\nThis script uses official Cloudflare WARP client for connecting to Cloudflare network and send all outbound traffic to Cloudflare server. So your servers address will be masked by Cloudflare IPs. This gives you a better web surffing experience due to less captcha challenges and also resolves some websites limitations on your servers IP.\n\nYou can enable Cloudflare WARP by using `--enable-warp true` option. This script will create and register a free WAPR account and use it.\n```\nbash <(curl -sL https://bit.ly/realityez) --enable-warp true\n```\nFree account has traffic limitation and lower performance in comparison with WARP+ account which needs license.\n\nYou can either buy an WARP+ Unlimited license or get a free WARP+ license from this telegram bot: https://t.me/generatewarpplusbot\n\nAfter getting a license from that telegram bot, you can use the license for your server with `--warp-license` option:\n```\nbash <(curl -sL https://bit.ly/realityez) --warp-license aaaaaaaa-bbbbbbbb-cccccccc\n```\nYou can use each warp+ license on 4 devices only.\n\nYou can disable Cloudflare WARP with `--enable-warp false`:\n```\nbash <(curl -sL https://bit.ly/realityez) --enable-warp false\n```\n\n## Example\nYou can combine different options together.\n\nWe want to setup a server with these configurations:\n* `grpc` transport protocol\n* `www.wikipedia.org` as SNI domain\n* Block adult contents\n* Enable Cloudflare WARP\n* Set Cloudflare WARP+ license\n\nSo we need to execute this command:\n```\nbash <(curl -sL https://bit.ly/realityez) --transport=grpc --domain=www.wikipedia.com --enable-safenet=true --enable-warp=true --warp-license=26z9i0ld-WG0wy324-rA703nZ2\n```\n## Custom Configuration\nUse this feature only if you know exactly what you are doing!\n\nYou can override the configuration generated by the script and add your own custom configuration to it.\n\nWrite your custom configuration in one of these files based on the engine that you are using:\n\n```\n/opt/reality-ezpz/sing-box.patch\n```\nor\n```\n/opt/reality-ezpz/xray.patch\n```\nAnd run script to apply your changes.\n\nFor example if you want to increase the debug level of sing-box engine, you can create `/opt/reality-ezpz/sing-box.patch` with this content:\n```\n{\n  \"log\": {\n    \"level\": \"debug\",\n    \"timestamp\": true\n  }\n}\n```"
        },
        {
          "name": "reality-ezpz.sh",
          "type": "blob",
          "size": 88.7802734375,
          "content": "#!/bin/bash\n\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n# \n#   http://www.apache.org/licenses/LICENSE-2.0\n# \n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\nset -e\ndeclare -A defaults\ndeclare -A config_file\ndeclare -A args\ndeclare -A config\ndeclare -A users\ndeclare -A path\ndeclare -A service\ndeclare -A md5\ndeclare -A regex\ndeclare -A image\n\nconfig_path=\"/opt/reality-ezpz\"\ncompose_project='reality-ezpz'\ntgbot_project='tgbot'\nBACKTITLE=RealityEZPZ\nMENU=\"Select an option:\"\nHEIGHT=30\nWIDTH=60\nCHOICE_HEIGHT=20\n\nimage[xray]=\"teddysun/xray:1.8.4\"\nimage[sing-box]=\"gzxhwq/sing-box:1.8.14\"\nimage[nginx]=\"nginx:1.24.0\"\nimage[certbot]=\"certbot/certbot:v2.6.0\"\nimage[haproxy]=\"haproxy:2.8.0\"\nimage[python]=\"python:3.11-alpine\"\nimage[wgcf]=\"virb3/wgcf:2.2.18\"\n\ndefaults[transport]=tcp\ndefaults[domain]=www.google.com\ndefaults[port]=443\ndefaults[safenet]=OFF\ndefaults[warp]=OFF\ndefaults[warp_license]=\"\"\ndefaults[warp_private_key]=\"\"\ndefaults[warp_token]=\"\"\ndefaults[warp_id]=\"\"\ndefaults[warp_client_id]=\"\"\ndefaults[warp_interface_ipv4]=\"\"\ndefaults[warp_interface_ipv6]=\"\"\ndefaults[core]=sing-box\ndefaults[security]=reality\ndefaults[server]=$(curl -fsSL --ipv4 https://cloudflare.com/cdn-cgi/trace | grep ip | cut -d '=' -f2)\ndefaults[tgbot]=OFF\ndefaults[tgbot_token]=\"\"\ndefaults[tgbot_admins]=\"\"\n\nconfig_items=(\n  \"core\"\n  \"security\"\n  \"service_path\"\n  \"public_key\"\n  \"private_key\"\n  \"short_id\"\n  \"transport\"\n  \"domain\"\n  \"server\"\n  \"port\"\n  \"safenet\"\n  \"warp\"\n  \"warp_license\"\n  \"warp_private_key\"\n  \"warp_token\"\n  \"warp_id\"\n  \"warp_client_id\"\n  \"warp_interface_ipv4\"\n  \"warp_interface_ipv6\"\n  \"tgbot\"\n  \"tgbot_token\"\n  \"tgbot_admins\"\n)\n\nregex[domain]=\"^[a-zA-Z0-9]+([-.][a-zA-Z0-9]+)*\\.[a-zA-Z]{2,}$\"\nregex[port]=\"^[1-9][0-9]*$\"\nregex[warp_license]=\"^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{8}-[a-zA-Z0-9]{8}$\"\nregex[username]=\"^[a-zA-Z0-9]+$\"\nregex[ip]=\"^([0-9]{1,3}\\.){3}[0-9]{1,3}$\"\nregex[tgbot_token]=\"^[0-9]{8,10}:[a-zA-Z0-9_-]{35}$\"\nregex[tgbot_admins]=\"^[a-zA-Z][a-zA-Z0-9_]{4,31}(,[a-zA-Z][a-zA-Z0-9_]{4,31})*$\"\nregex[domain_port]=\"^[a-zA-Z0-9]+([-.][a-zA-Z0-9]+)*\\.[a-zA-Z]{2,}(:[1-9][0-9]*)?$\"\nregex[file_path]=\"^[a-zA-Z0-9_/.-]+$\"\nregex[url]=\"^(http|https)://([a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}|[0-9]{1,3}(\\.[0-9]{1,3}){3})(:[0-9]{1,5})?(/.*)?$\"\n\nfunction show_help {\n  echo \"\"\n  echo \"Usage: reality-ezpz.sh [-t|--transport=tcp|http|grpc|ws|tuic|hysteria2|shadowtls] [-d|--domain=<domain>] [--server=<server>] [--regenerate] [--default]\n  [-r|--restart] [--enable-safenet=true|false] [--port=<port>] [-c|--core=xray|sing-box] [--enable-warp=true|false]\n  [--warp-license=<license>] [--security=reality|letsencrypt|selfsigned] [-m|--menu] [--show-server-config] [--add-user=<username>] [--lists-users]\n  [--show-user=<username>] [--delete-user=<username>] [--backup] [--restore=<url|file>] [--backup-password=<password>] [-u|--uninstall]\"\n  echo \"\"\n  echo \"  -t, --transport <tcp|http|grpc|ws|tuic|hysteria2|shadowtls> Transport protocol (tcp, http, grpc, ws, tuic, hysteria2, shadowtls, default: ${defaults[transport]})\"\n  echo \"  -d, --domain <domain>     Domain to use as SNI (default: ${defaults[domain]})\"\n  echo \"      --server <server>     IP address or domain name of server (Must be a valid domain if using letsencrypt security)\"\n  echo \"      --regenerate          Regenerate public and private keys\"\n  echo \"      --default             Restore default configuration\"\n  echo \"  -r  --restart             Restart services\"\n  echo \"  -u, --uninstall           Uninstall reality\"\n  echo \"      --enable-safenet <true|false> Enable or disable safenet (blocking malware and adult content)\"\n  echo \"      --port <port>         Server port (default: ${defaults[port]})\"\n  echo \"      --enable-warp <true|false> Enable or disable Cloudflare warp\"\n  echo \"      --warp-license <warp-license> Add Cloudflare warp+ license\"\n  echo \"  -c  --core <sing-box|xray> Select core (xray, sing-box, default: ${defaults[core]})\"\n  echo \"      --security <reality|letsencrypt|selfsigned> Select type of TLS encryption (reality, letsencrypt, selfsigned, default: ${defaults[security]})\" \n  echo \"  -m  --menu                Show menu\"\n  echo \"      --enable-tgbot <true|false> Enable Telegram bot for user management\"\n  echo \"      --tgbot-token <token> Token of Telegram bot\"\n  echo \"      --tgbot-admins <telegram-username> Usernames of telegram bot admins (Comma separated list of usernames without leading '@')\"\n  echo \"      --show-server-config  Print server configuration\"\n  echo \"      --add-user <username> Add new user\"\n  echo \"      --list-users          List all users\"\n  echo \"      --show-user <username> Shows the config and QR code of the user\"\n  echo \"      --delete-user <username> Delete the user\"\n  echo \"      --backup              Backup users and configuration and upload it to temp.sh\"\n  echo \"      --restore <url|file>  Restore backup from URL or file\"\n  echo \"      --backup-password <password> Create/Restore password protected backup file\"\n  echo \"  -h, --help                Display this help message\"\n  return 1\n}\n\nfunction parse_args {\n  local opts\n  opts=$(getopt -o t:d:ruc:mh --long transport:,domain:,server:,regenerate,default,restart,uninstall,enable-safenet:,port:,warp-license:,enable-warp:,core:,security:,menu,show-server-config,add-user:,list-users,show-user:,delete-user:,backup,restore:,backup-password:,enable-tgbot:,tgbot-token:,tgbot-admins:,help -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    return 1\n  fi\n  eval set -- \"$opts\"\n  while true; do\n    case $1 in\n      -t|--transport)\n        args[transport]=\"$2\"\n        case ${args[transport]} in\n          tcp|http|grpc|ws|tuic|hysteria2|shadowtls)\n            shift 2\n            ;;\n          *)\n            echo \"Invalid transport protocol: ${args[transport]}\"\n            return 1\n            ;;\n        esac\n        ;;\n      -d|--domain)\n        args[domain]=\"$2\"\n        if ! [[ ${args[domain]} =~ ${regex[domain_port]} ]]; then\n          echo \"Invalid domain: ${args[domain]}\"\n          return 1\n        fi\n        shift 2\n        ;;\n      --server)\n        args[server]=\"$2\"\n        if ! [[ ${args[server]} =~ ${regex[domain]} || ${args[server]} =~ ${regex[ip]} ]]; then\n          echo \"Invalid server: ${args[domain]}\"\n          return 1\n        fi\n        shift 2\n        ;;\n      --regenerate)\n        args[regenerate]=true\n        shift\n        ;;\n      --default)\n        args[default]=true\n        shift\n        ;;\n      -r|--restart)\n        args[restart]=true\n        shift\n        ;;\n      -u|--uninstall)\n        args[uninstall]=true\n        shift\n        ;;\n      --enable-safenet)\n        case \"$2\" in\n          true|false)\n            $2 && args[safenet]=ON || args[safenet]=OFF\n            shift 2\n            ;;\n          *)\n            echo \"Invalid safenet option: $2\"\n            return 1\n            ;;\n        esac\n        ;;\n      --enable-warp)\n        case \"$2\" in\n          true|false)\n            $2 && args[warp]=ON || args[warp]=OFF\n            shift 2\n            ;;\n          *)\n            echo \"Invalid warp option: $2\"\n            return 1\n            ;;\n        esac\n        ;;\n      --port)\n        args[port]=\"$2\"\n        if ! [[ ${args[port]} =~ ${regex[port]} ]]; then\n          echo \"Invalid port number: ${args[port]}\"\n          return 1\n        elif ((args[port] < 1 || args[port] > 65535)); then\n          echo \"Port number out of range: ${args[port]}\"\n          return 1\n        fi\n        shift 2\n        ;;\n      --warp-license)\n        args[warp_license]=\"$2\"\n        if ! [[ ${args[warp_license]} =~ ${regex[warp_license]} ]]; then\n          echo \"Invalid warp license: ${args[warp_license]}\"\n          return 1\n        fi\n        shift 2\n        ;;\n      -c|--core)\n        args[core]=\"$2\"\n        case ${args[core]} in\n          xray|sing-box)\n            shift 2\n            ;;\n          *)\n            echo \"Invalid core: ${args[core]}\"\n            return 1\n            ;;\n        esac\n        ;;\n      --security)\n        args[security]=\"$2\"\n        case ${args[security]} in\n          reality|letsencrypt|selfsigned)\n            shift 2\n            ;;\n          *)\n            echo \"Invalid TLS security option: ${args[security]}\"\n            return 1\n            ;;\n        esac\n        ;;\n      -m|--menu)\n        args[menu]=true\n        shift\n        ;;\n      --enable-tgbot)\n        case \"$2\" in\n          true|false)\n            $2 && args[tgbot]=ON || args[tgbot]=OFF\n            shift 2\n            ;;\n          *)\n            echo \"Invalid enable-tgbot option: $2\"\n            return 1\n            ;;\n        esac\n        ;;\n      --tgbot-token)\n        args[tgbot_token]=\"$2\"\n        if [[ ! ${args[tgbot_token]} =~ ${regex[tgbot_token]} ]]; then\n          echo \"Invalid Telegram Bot Token: ${args[tgbot_token]}\"\n          return 1\n        fi \n        if ! curl -sSfL -m 3 \"https://api.telegram.org/bot${args[tgbot_token]}/getMe\" >/dev/null 2>&1; then\n          echo \"Invalid Telegram Bot Token: Telegram Bot Token is incorrect. Check it again.\"\n          return 1\n        fi\n        shift 2\n        ;;\n      --tgbot-admins)\n        args[tgbot_admins]=\"$2\"\n        if [[ ! ${args[tgbot_admins]} =~ ${regex[tgbot_admins]} || $tgbot_admins =~ .+_$ || $tgbot_admins =~ .+_,.+ ]]; then\n          echo \"Invalid Telegram Bot Admins Username: ${args[tgbot_admins]}\\nThe usernames must separated by ',' without leading '@' character or any extra space.\"\n         return 1\n        fi\n        shift 2\n        ;;\n      --show-server-config)\n        args[server-config]=true\n        shift\n        ;;\n      --add-user)\n        args[add_user]=\"$2\"\n        if ! [[ ${args[add_user]} =~ ${regex[username]} ]]; then\n          echo \"Invalid username: ${args[add_user]}\\nUsername can only contains A-Z, a-z and 0-9\"\n          return 1\n        fi\n        shift 2\n        ;;\n      --list-users)\n        args[list_users]=true\n        shift\n        ;;\n      --show-user)\n        args[show_config]=\"$2\"\n        shift 2\n        ;;\n      --delete-user)\n        args[delete_user]=\"$2\"\n        shift 2\n        ;;\n      --backup)\n        args[backup]=true\n        shift\n        ;;\n      --restore)\n        args[restore]=\"$2\"\n        if [[ ! ${args[restore]} =~ ${regex[file_path]} ]] && [[ ! ${args[restore]} =~ ${regex[url]} ]]; then\n          echo \"Invalid: Backup file path or URL is not valid.\"\n          return 1\n        fi\n        shift 2\n        ;;\n      --backup-password)\n        args[backup_password]=\"$2\"\n        shift 2\n        ;;\n      -h|--help)\n        return 1\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        echo \"Unknown option: $1\"\n        return 1\n        ;;\n    esac\n  done\n\n  if [[ ${args[uninstall]} == true ]]; then\n    uninstall\n  fi\n\n  if [[ -n ${args[warp_license]} ]]; then\n    args[warp]=ON\n  fi\n}\n\nfunction backup {\n  local backup_name\n  local backup_password=\"$1\"\n  local backup_file_url\n  local exit_code\n  backup_name=\"reality-ezpz-backup-$(date +%Y-%m-%d_%H-%M-%S).zip\"\n  cd \"${config_path}\"\n  if [ -z \"${backup_password}\" ]; then\n    zip -r \"/tmp/${backup_name}\" . > /dev/null\n  else\n    zip -P \"${backup_password}\" -r \"/tmp/${backup_name}\" . > /dev/null\n  fi\n  if ! backup_file_url=$(curl -fsS -m 30 -F \"file=@/tmp/${backup_name}\" \"https://temp.sh/upload\"); then\n    rm -f \"/tmp/${backup_name}\"\n    echo \"Error in uploading backup file\" >&2\n    return 1\n  fi\n  rm -f \"/tmp/${backup_name}\"\n  echo \"${backup_file_url}\"\n}\n\nfunction restore {\n  local backup_file=\"$1\"\n  local backup_password=\"$2\"\n  local temp_file\n  local unzip_output\n  local unzip_exit_code\n  local current_state\n  if [[ ! -r ${backup_file} ]]; then\n    temp_file=$(mktemp -u)\n    if [[ \"${backup_file}\" =~ ^https?://temp\\.sh/ ]]; then\n      if ! curl -fSsL -m 30 -X POST \"${backup_file}\" -o \"${temp_file}\"; then\n        echo \"Cannot download or find backup file\" >&2\n        return 1\n      fi\n    else\n      if ! curl -fSsL -m 30 \"${backup_file}\" -o \"${temp_file}\"; then\n        echo \"Cannot download or find backup file\" >&2\n        return 1\n      fi\n    fi\n    backup_file=\"${temp_file}\"\n  fi\n  current_state=$(set +o)\n  set +e\n  if [[ -z \"${backup_password}\" ]]; then\n    unzip_output=$(unzip -P \"\" -t \"${backup_file}\" 2>&1)\n  else\n    unzip_output=$(unzip -P \"${backup_password}\" -t \"${backup_file}\" 2>&1)\n  fi\n  unzip_exit_code=$?\n  eval \"$current_state\"\n  if [[ ${unzip_exit_code} -eq 0 ]]; then\n    if ! echo \"${unzip_output}\" | grep -q 'config'; then\n      echo \"The provided file is not a reality-ezpz backup file.\" >&2\n      rm -f \"${temp_file}\"\n      return 1\n    fi\n  else\n    if echo \"${unzip_output}\" | grep -q 'incorrect password'; then\n      echo \"The provided password for backup file is incorrect.\" >&2\n    else\n      echo \"An error occurred during zip file verification: ${unzip_output}\" >&2\n    fi\n    rm -f \"${temp_file}\"\n    return 1\n  fi\n  rm -rf \"${config_path}\"\n  mkdir -p \"${config_path}\"\n  set +e\n  if [[ -z \"${backup_password}\" ]]; then\n    unzip_output=$(unzip -d \"${config_path}\" \"${backup_file}\" 2>&1)\n  else\n    unzip_output=$(unzip -P \"${backup_password}\" -d \"${config_path}\" \"${backup_file}\" 2>&1)\n  fi\n  unzip_exit_code=$?\n  eval \"$current_state\"\n  if [[ ${unzip_exit_code} -ne 0 ]]; then\n    echo \"Error in backup restore: ${unzip_output}\" >&2\n    rm -f \"${temp_file}\"\n    return 1\n  fi\n  rm -f \"${temp_file}\"\n  return\n}\n\nfunction dict_expander {\n  local -n dict=$1\n  for key in \"${!dict[@]}\"; do\n    echo \"${key} ${dict[$key]}\"\n  done\n}\n\nfunction parse_config_file {\n  if [[ ! -r \"${path[config]}\" ]]; then\n    generate_keys\n    return 0\n  fi\n  while IFS= read -r line; do\n    if [[ \"${line}\" =~ ^\\s*# ]] || [[ \"${line}\" =~ ^\\s*$ ]]; then\n      continue\n    fi\n    key=$(echo \"$line\" | cut -d \"=\" -f 1)\n    value=$(echo \"$line\" | cut -d \"=\" -f 2-)\n    config_file[\"${key}\"]=\"${value}\"\n  done < \"${path[config]}\"\n  if [[ -z \"${config_file[public_key]}\" || \\\n        -z \"${config_file[private_key]}\" || \\\n        -z \"${config_file[short_id]}\" || \\\n        -z \"${config_file[service_path]}\" ]]; then\n    generate_keys\n  fi\n  return 0\n}\n\nfunction parse_users_file {\n  mkdir -p \"$config_path\"\n  touch \"${path[users]}\"\n  while read -r line; do\n    if [[ \"${line}\" =~ ^\\s*# ]] || [[ \"${line}\" =~ ^\\s*$ ]]; then\n      continue\n    fi\n    IFS=\"=\" read -r key value <<< \"${line}\"\n    users[\"${key}\"]=\"${value}\"\n  done < \"${path[users]}\"\n  if [[ -n ${args[add_user]} ]]; then\n    if [[ -z \"${users[\"${args[add_user]}\"]}\" ]]; then\n      users[\"${args[add_user]}\"]=$(cat /proc/sys/kernel/random/uuid)\n    else\n      echo 'User \"'\"${args[add_user]}\"'\" already exists.'\n    fi\n  fi\n  if [[ -n ${args[delete_user]} ]]; then\n    if [[ -n \"${users[\"${args[delete_user]}\"]}\" ]]; then\n      if [[ ${#users[@]} -eq 1 ]]; then\n        echo -e \"You cannot delete the only user.\\nAt least one user is needed.\\nCreate a new user, then delete this one.\"\n        exit 1\n      fi\n      unset users[\"${args[delete_user]}\"]\n    else\n      echo \"User \"${args[delete_user]}\" does not exists.\"\n      exit 1\n    fi\n  fi\n  if [[ ${#users[@]} -eq 0 ]]; then\n    users[RealityEZPZ]=$(cat /proc/sys/kernel/random/uuid)\n    echo \"RealityEZPZ=${users[RealityEZPZ]}\" >> \"${path[users]}\"\n    return 0\n  fi\n  return 0\n}\n\nfunction restore_defaults {\n  local defaults_items=(\"${!defaults[@]}\")\n  local keep=false\n  local exclude_list=(\n    \"warp_license\"\n    \"tgbot_token\"\n  )\n  if [[ -n ${config[warp_id]} && -n ${config[warp_token]} ]]; then\n    warp_delete_account \"${config[warp_id]}\" \"${config[warp_token]}\"\n  fi\n  for item in \"${defaults_items[@]}\"; do\n    keep=false\n    for i in \"${exclude_list[@]}\"; do\n      if [[ \"${i}\" == \"${item}\" ]]; then\n        keep=true\n        break\n      fi\n    done\n    if [[ ${keep} == true ]]; then\n      continue\n    fi\n    config[\"${item}\"]=\"${defaults[${item}]}\"\n  done\n}\n\nfunction build_config {\n  local free_80=true\n  if [[ ${args[regenerate]} == true ]]; then\n    generate_keys\n  fi\n  for item in \"${config_items[@]}\"; do\n    if [[ -n ${args[\"${item}\"]} ]]; then\n      config[\"${item}\"]=\"${args[${item}]}\"\n    elif [[ -n ${config_file[\"${item}\"]} ]]; then\n      config[\"${item}\"]=\"${config_file[${item}]}\"\n    else\n      config[\"${item}\"]=\"${defaults[${item}]}\"\n    fi\n  done\n  if [[ ${args[default]} == true ]]; then\n    restore_defaults\n    return 0\n  fi\n  if [[ ${config[tgbot]} == 'ON' && -z ${config[tgbot_token]} ]]; then\n    echo 'To enable Telegram bot, you have to give the token of bot with --tgbot-token option.'\n    exit 1\n  fi\n  if [[ ${config[tgbot]} == 'ON' && -z ${config[tgbot_admins]} ]]; then\n    echo 'To enable Telegram bot, you have to give the list of authorized Telegram admins username with --tgbot-admins option.'\n    exit 1\n  fi\n  if [[ ${config[warp]} == 'ON' && -z ${config[warp_license]} ]]; then\n    echo 'To enable WARP+, you have to give WARP+ license with --warp-license option.'\n    exit 1\n  fi\n  if [[ ! ${config[server]} =~ ${regex[domain]} && ${config[security]} == 'letsencrypt' ]]; then\n    echo 'You have to assign a domain to server with \"--server <domain>\" option if you want to use \"letsencrypt\" as TLS certifcate.'\n    exit 1\n  fi\n  if [[ ${config[transport]} == 'ws' && ${config[security]} == 'reality' ]]; then\n    echo 'You cannot use \"ws\" transport with \"reality\" TLS certificate. Use other transports or change TLS certifcate to letsencrypt or selfsigned'\n    exit 1\n  fi\n  if [[ ${config[transport]} == 'tuic' && ${config[security]} == 'reality' ]]; then\n    echo 'You cannot use \"tuic\" transport with \"reality\" TLS certificate. Use other transports or change TLS certifcate to letsencrypt or selfsigned'\n    exit 1\n  fi\n  if [[ ${config[transport]} == 'tuic' && ${config[core]} == 'xray' ]]; then\n    echo 'You cannot use \"tuic\" transport with \"xray\" core. Use other transports or change core to sing-box'\n    exit 1\n  fi\n  if [[ ${config[transport]} == 'hysteria2' && ${config[security]} == 'reality' ]]; then\n    echo 'You cannot use \"hysteria2\" transport with \"reality\" TLS certificate. Use other transports or change TLS certifcate to letsencrypt or selfsigned'\n    exit 1\n  fi\n  if [[ ${config[transport]} == 'hysteria2' && ${config[core]} == 'xray' ]]; then\n    echo 'You cannot use \"hysteria2\" transport with \"xray\" core. Use other transports or change core to sing-box'\n    exit 1\n  fi\n  if [[ ${config[transport]} == 'shadowtls' && ${config[core]} == 'xray' ]]; then\n    echo 'You cannot use \"shadowtls\" transport with \"xray\" core. Use other transports or change core to sing-box'\n    exit 1\n  fi\n  if [[ ${config[security]} == 'letsencrypt' && ${config[port]} -ne 443 ]]; then\n    if lsof -i :80 >/dev/null 2>&1; then\n      free_80=false\n      for container in $(${docker_cmd} -p ${compose_project} ps -q); do\n        if docker port \"${container}\"| grep '0.0.0.0:80' >/dev/null 2>&1; then\n          free_80=true\n          break\n        fi\n      done\n    fi\n    if [[ ${free_80} != 'true' ]]; then\n      echo 'Port 80 must be free if you want to use \"letsencrypt\" as the security option.'\n      exit 1\n    fi\n  fi\n  if [[ (-n \"${args[security]}\" || -n \"${args[transport]}\") && (\"${args[security]}\" == 'reality' || \"${args[transport]}\" == 'shadowtls') && (\"${config_file[security]}\" != 'reality' && \"${config_file[transport]}\" != 'shadowtls') ]]; then\n    config[domain]=\"${defaults[domain]}\"\n  fi\n  if [[ (-n \"${args[security]}\" || -n \"${args[transport]}\") && (\"${args[security]}\" != 'reality' && \"${args[transport]}\" != 'shadowtls') && (\"${config_file[security]}\" == 'reality' || \"${config_file[transport]}\" == 'shadowtls') ]]; then\n    config[domain]=\"${config[server]}\"\n  fi\n  if [[ -n \"${args[server]}\" && (\"${config[security]}\" != 'reality' && \"${config[transport]}\" != 'shadowtls') ]]; then\n    config[domain]=\"${config[server]}\"\n  fi\n  if [[ -n \"${args[warp]}\" && \"${args[warp]}\" == 'OFF' && \"${config_file[warp]}\" == 'ON' ]]; then\n    if [[ -n ${config[warp_id]} && -n ${config[warp_token]} ]]; then\n      warp_delete_account \"${config[warp_id]}\" \"${config[warp_token]}\"\n    fi\n  fi\n  if { [[ -n \"${args[warp]}\" && \"${args[warp]}\" == 'ON' && \"${config_file[warp]}\" == 'OFF' ]] || \\\n       [[ \"${config[warp]}\" == 'ON' && ( -z ${config[warp_private_key]} || \\\n                                         -z ${config[warp_token]} || \\\n                                         -z ${config[warp_id]} || \\\n                                         -z ${config[warp_client_id]} || \\\n                                         -z ${config[warp_interface_ipv4]} || \\\n                                         -z ${config[warp_interface_ipv6]} ) ]]; }; then\n    config[warp]='OFF'\n    warp_create_account || exit 1\n    warp_add_license \"${config[warp_id]}\" \"${config[warp_token]}\" \"${config[warp_license]}\" || exit 1\n    config[warp]='ON'\n  fi\n  if [[ -n ${args[warp_license]} && -n ${config_file[warp_license]} && \"${args[warp_license]}\" != \"${config_file[warp_license]}\" ]]; then\n    if ! warp_add_license \"${config[warp_id]}\" \"${config[warp_token]}\" \"${args[warp_license]}\"; then\n      config[warp]='OFF'\n      config[warp_license]=\"\"\n      warp_delete_account \"${config[warp_id]}\" \"${config[warp_token]}\"\n      echo \"WARP has been disabled due to the license error.\"\n    fi \n  fi\n}\n\nfunction update_config_file {\n  mkdir -p \"${config_path}\"\n  touch \"${path[config]}\"\n  for item in \"${config_items[@]}\"; do\n    if grep -q \"^${item}=\" \"${path[config]}\"; then\n      sed -i \"s|^${item}=.*|${item}=${config[${item}]}|\" \"${path[config]}\"\n    else\n      echo \"${item}=${config[${item}]}\" >> \"${path[config]}\"\n    fi\n  done\n  check_reload\n}\n\nfunction update_users_file {\n  rm -f \"${path[users]}\"\n  for user in \"${!users[@]}\"; do\n    echo \"${user}=${users[${user}]}\" >> \"${path[users]}\"\n  done\n  check_reload\n}\n\nfunction generate_keys {\n  local key_pair\n  key_pair=$(docker run --rm ${image[xray]} xray x25519)\n  config_file[public_key]=$(echo \"${key_pair}\" | grep 'Public key:' | awk '{print $3}')\n  config_file[private_key]=$(echo \"${key_pair}\" | grep 'Private key:' | awk '{print $3}')\n  config_file[short_id]=$(openssl rand -hex 8)\n  config_file[service_path]=$(openssl rand -hex 4)\n}\n\nfunction uninstall {\n  if docker compose >/dev/null 2>&1; then\n    docker compose --project-directory \"${config_path}\" down --timeout 2 || true\n    docker compose --project-directory \"${config_path}\" -p ${compose_project} down --timeout 2 || true\n    docker compose --project-directory \"${config_path}/tgbot\" -p ${tgbot_project} down --timeout 2 || true\n  elif which docker-compose >/dev/null 2>&1; then\n    docker-compose --project-directory \"${config_path}\" down --timeout 2 || true\n    docker-compose --project-directory \"${config_path}\" -p ${compose_project} down --timeout 2 || true\n    docker-compose --project-directory \"${config_path}/tgbot\" -p ${tgbot_project} down --timeout 2 || true\n  fi\n  rm -rf \"${config_path}\"\n  echo \"Reality-EZPZ uninstalled successfully.\"\n  exit 0\n}\n\nfunction install_packages {\n  if [[ -n $BOT_TOKEN ]]; then \n    return 0\n  fi\n  if ! which qrencode whiptail jq xxd zip unzip >/dev/null 2>&1; then\n    if which apt >/dev/null 2>&1; then\n      apt update\n      DEBIAN_FRONTEND=noninteractive apt install qrencode whiptail jq xxd zip unzip -y\n      return 0\n    fi\n    if which yum >/dev/null 2>&1; then\n      yum makecache\n      yum install epel-release -y || true\n      yum install qrencode newt jq vim-common zip unzip -y\n      return 0\n    fi\n    echo \"OS is not supported!\"\n    return 1\n  fi\n}\n\nfunction install_docker {\n  if ! which docker >/dev/null 2>&1; then\n    curl -fsSL -m 5 https://get.docker.com | bash\n    systemctl enable --now docker\n    docker_cmd=\"docker compose\"\n    return 0\n  fi\n  if docker compose >/dev/null 2>&1; then\n    docker_cmd=\"docker compose\"\n    return 0\n  fi\n  if which docker-compose >/dev/null 2>&1; then\n    docker_cmd=\"docker-compose\"\n    return 0\n  fi\n  curl -fsSL -m 30 https://github.com/docker/compose/releases/download/v2.28.0/docker-compose-linux-$(uname -m) -o /usr/local/bin/docker-compose\n  chmod +x /usr/local/bin/docker-compose\n  docker_cmd=\"docker-compose\"\n  return 0\n}\n\nfunction generate_docker_compose {\n  cat >\"${path[compose]}\" <<EOF\nversion: \"3\"\nnetworks:\n  reality:\n    driver: bridge\n    enable_ipv6: true\n    ipam:\n      config:\n      - subnet: fc11::1:0/112\nservices:\n  engine:\n    image: ${image[${config[core]}]}\n    $([[ ${config[security]} == 'reality' || ${config[transport]} == 'shadowtls' ]] && echo \"ports:\" || true)\n    $([[ (${config[security]} == 'reality' || ${config[transport]} == 'shadowtls') && ${config[port]} -eq 443 ]] && echo '- 80:8080' || true)\n    $([[ ${config[security]} == 'reality' || ${config[transport]} == 'shadowtls' ]] && echo \"- ${config[port]}:8443\" || true)\n    $([[ ${config[transport]} == 'tuic' || ${config[transport]} == 'hysteria2' ]] && echo \"ports:\" || true)\n    $([[ ${config[transport]} == 'tuic' || ${config[transport]} == 'hysteria2' ]] && echo \"- ${config[port]}:8443/udp\" || true)\n    $([[ ${config[security]} != 'reality' && ${config[transport]} != 'shadowtls' ]] && echo \"expose:\" || true)\n    $([[ ${config[security]} != 'reality' && ${config[transport]} != 'shadowtls' ]] && echo \"- 8443\" || true)\n    restart: always\n    environment:\n      TZ: Etc/UTC\n    volumes:\n    - ./${path[engine]#${config_path}/}:/etc/${config[core]}/config.json\n    $([[ ${config[security]} != 'reality' ]] && { [[ ${config[transport]} == 'http' ]] || [[ ${config[transport]} == 'tcp' ]] || [[ ${config[transport]} == 'tuic' ]] || [[ ${config[transport]} == 'hysteria2' ]]; } && echo \"- ./${path[server_crt]#${config_path}/}:/etc/${config[core]}/server.crt\" || true)\n    $([[ ${config[security]} != 'reality' ]] && { [[ ${config[transport]} == 'http' ]] || [[ ${config[transport]} == 'tcp' ]] || [[ ${config[transport]} == 'tuic' ]] || [[ ${config[transport]} == 'hysteria2' ]]; } && echo \"- ./${path[server_key]#${config_path}/}:/etc/${config[core]}/server.key\" || true)\n    networks:\n    - reality\n$(if [[ ${config[security]} != 'reality' && ${config[transport]} != 'shadowtls' ]]; then\necho \"\n  nginx:\n    image: ${image[nginx]}\n    expose:\n    - 80\n    restart: always\n    volumes:\n    - ./website:/usr/share/nginx/html\n    networks:\n    - reality\n  haproxy:\n    image: ${image[haproxy]}\n    ports:\n    $([[ ${config[security]} == 'letsencrypt' || ${config[port]} -eq 443 ]] && echo '- 80:8080' || true)\n    - ${config[port]}:8443\n    restart: always\n    volumes:\n    - ./${path[haproxy]#${config_path}/}:/usr/local/etc/haproxy/haproxy.cfg\n    - ./${path[server_pem]#${config_path}/}:/usr/local/etc/haproxy/server.pem\n    networks:\n    - reality\"\nfi)\n$(if [[ ${config[security]} == 'letsencrypt' && ${config[transport]} != 'shadowtls' ]]; then\necho \"\n  certbot:\n    build:\n      context: ./certbot\n    expose:\n    - 80\n    restart: always\n    volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n    - ./certbot/data:/etc/letsencrypt\n    - ./$(dirname \"${path[server_pem]#${config_path}/}\"):/certificate\n    - ./${path[certbot_deployhook]#${config_path}/}:/deployhook.sh\n    - ./${path[certbot_startup]#${config_path}/}:/startup.sh\n    - ./website:/website\n    networks:\n    - reality\n    entrypoint: /bin/sh\n    command: /startup.sh\"\nfi)\nEOF\n}\n\nfunction generate_tgbot_compose {\n  cat >\"${path[tgbot_compose]}\" <<EOF\nversion: \"3\"\nnetworks:\n  tgbot:\n    driver: bridge\n    enable_ipv6: true\n    ipam:\n      config:\n      - subnet: fc11::2:0/112\nservices:\n  tgbot:\n    build: ./\n    restart: always\n    environment:\n      BOT_TOKEN: ${config[tgbot_token]}\n      BOT_ADMIN: ${config[tgbot_admins]}\n    volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n    - ../:${config_path}\n    - /etc/docker/:/etc/docker/\n    networks:\n    - tgbot\nEOF\n}\n\nfunction generate_haproxy_config {\necho \"\nglobal\n  ssl-default-bind-options ssl-min-ver TLSv1.2\ndefaults\n  option http-server-close\n  timeout connect 5s\n  timeout client 50s\n  timeout client-fin 1s\n  timeout server-fin 1s\n  timeout server 50s\n  timeout tunnel 50s\n  timeout http-keep-alive 1s\n  timeout queue 15s\nfrontend http\n  mode http\n  bind :::8080 v4v6\n$(if [[ ${config[security]} == 'letsencrypt' ]]; then echo \"\n  use_backend certbot if { path_beg /.well-known/acme-challenge }\n  acl letsencrypt-acl path_beg /.well-known/acme-challenge\n  redirect scheme https if !letsencrypt-acl\n\"; fi)\n  use_backend default\nfrontend tls\n$(if [[ ${config[transport]} != 'tcp' ]]; then echo \"\n  bind :::8443 v4v6 ssl crt /usr/local/etc/haproxy/server.pem alpn h2,http/1.1\n  mode http\n  http-request set-header Host ${config[server]}\n$(if [[ ${config[security]} == 'letsencrypt' ]]; then echo \"\n  use_backend certbot if { path_beg /.well-known/acme-challenge }\n\"; fi)\n$(if [[ ${config[transport]} != 'tuic' && ${config[transport]} != 'hysteria2' ]]; then echo \"\n  use_backend engine if { path_beg /${config[service_path]} }\n\"; fi)\n  use_backend default\n\"; else echo \"\n  bind :::8443 v4v6\n  mode tcp\n  use_backend engine\n\"; fi)\n$(if [[ ${config[transport]} != 'tuic' && ${config[transport]} != 'hysteria2' ]]; then echo \"\nbackend engine\n  retry-on conn-failure empty-response response-timeout\n$(if [[ ${config[transport]} != 'tcp' ]]; then echo \"\n  mode http\n\"; else echo \"\n  mode tcp\n\"; fi)\n$(if [[ ${config[transport]} == 'grpc' ]]; then echo \"\n  server engine engine:8443 check tfo proto h2\n\"; elif [[ ${config[transport]} == 'http' && ${config[core]} == 'sing-box' ]]; then echo \"\n  server engine engine:8443 check tfo proto h2 ssl verify none\n\"; elif [[ ${config[transport]} == 'http' && ${config[core]} != 'sing-box' ]]; then echo \"\n  server engine engine:8443 check tfo ssl verify none\n\"; else echo \"\n  server engine engine:8443 check tfo\n\"; fi)\n\"; fi)\n$(if [[ ${config[security]} == 'letsencrypt' ]]; then echo \"\nbackend certbot\n  mode http\n  server certbot certbot:80\n\"; fi)\nbackend default\n  mode http\n  server nginx nginx:80\n\" | grep -vE '^\\s*$' > \"${path[haproxy]}\"\n}\n\nfunction generate_certbot_script {\n  cat >\"${path[certbot_startup]}\" << EOF\n#!/bin/sh\ntrap exit TERM\nfullchain_path=/etc/letsencrypt/live/${config[server]}/fullchain.pem\nif [[ -r \"\\${fullchain_path}\" ]]; then\n  fullchain_fingerprint=\\$(openssl x509 -noout -fingerprint -sha256 -in \"\\${fullchain_path}\" 2>/dev/null |\\\nawk -F= '{print \\$2}' | tr -d : | tr '[:upper:]' '[:lower:]')\n  installed_fingerprint=\\$(openssl x509 -noout -fingerprint -sha256 -in /certificate/server.pem 2>/dev/null |\\\nawk -F= '{print \\$2}' | tr -d : | tr '[:upper:]' '[:lower:]')\n  if [[ \\$fullchain_fingerprint != \\$installed_fingerprint ]]; then\n    /deployhook.sh /certificate ${compose_project} ${config[server]} ${service[server_crt]} $([[ ${config[transport]} != 'tcp' ]] && echo \"${service[server_pem]}\" || true)\n  fi\nfi\nwhile true; do\n  ls -d /website/* | grep -E '^/website/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\$'|xargs rm -f\n  uuid=\\$(uuidgen)\n  echo \"\\$uuid\" > \"/website/\\$uuid\"\n  response=\\$(curl -skL --max-time 3 http://${config[server]}/\\$uuid)\n  if echo \"\\$response\" | grep \\$uuid >/dev/null; then\n    break\n  fi\n  echo \"Domain ${config[server]} is not pointing to the server\"\n  sleep 5\ndone\nls -d /website/* | grep -E '^/website/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\$'|xargs rm -f\nwhile true; do\n  certbot certonly -n \\\\\n    --standalone \\\\\n    --key-type ecdsa \\\\\n    --elliptic-curve secp256r1 \\\\\n    --agree-tos \\\\\n    --register-unsafely-without-email \\\\\n    -d ${config[server]} \\\\\n    --deploy-hook \"/deployhook.sh /certificate ${compose_project} ${config[server]} ${service[server_crt]} $([[ ${config[transport]} != 'tcp' ]] && echo \"${service[server_pem]}\" || true)\"\n  sleep 1h &\n  wait \\${!}\ndone\nEOF\n}\n\nfunction generate_certbot_deployhook {\n  cat >\"${path[certbot_deployhook]}\" << EOF\n#!/bin/sh\ncert_path=\\$1\ncompose_project=\\$2\ndomain=\\$3\nrenewed_path=/etc/letsencrypt/live/\\$domain\ncat \"\\$renewed_path/fullchain.pem\" > \"\\$cert_path/server.crt\"\ncat \"\\$renewed_path/privkey.pem\" > \"\\$cert_path/server.key\"\ncat \"\\$renewed_path/fullchain.pem\" \"\\$renewed_path/privkey.pem\" > \"\\$cert_path/server.pem\"\ni=4\nwhile [ \\$i -le \\$# ]; do\n  eval service=\\\\\\${\\$i}\n  docker compose -p \"${compose_project}\" restart --timeout 2 \"\\$service\"\n  i=\\$((i+1))\ndone\nEOF\n  chmod +x \"${path[certbot_deployhook]}\"\n}\n\nfunction generate_certbot_dockerfile {\n  cat >\"${path[certbot_dockerfile]}\" << EOF\nFROM ${image[certbot]}\nRUN apk add --no-cache docker-cli-compose curl uuidgen\nEOF\n}\n\nfunction generate_tgbot_dockerfile {\n  cat >\"${path[tgbot_dockerfile]}\" << EOF\nFROM ${image[python]}\nWORKDIR ${config_path}/tgbot\nRUN apk add --no-cache docker-cli-compose curl bash newt libqrencode-tools sudo openssl jq zip unzip\nRUN pip install --no-cache-dir python-telegram-bot==13.5 qrcode[pil]==7.4.2\nCMD [ \"python\", \"./tgbot.py\" ]\nEOF\n}\n\nfunction download_tgbot_script {\n  curl -fsSL -m 3 https://raw.githubusercontent.com/aleskxyz/reality-ezpz/master/tgbot.py -o \"${path[tgbot_script]}\"\n}\n\nfunction generate_selfsigned_certificate {\n  openssl ecparam -name prime256v1 -genkey -out \"${path[server_key]}\"\n  openssl req -new -key \"${path[server_key]}\" -out /tmp/server.csr -subj \"/CN=${config[server]}\"\n  openssl x509 -req -days 365 -in /tmp/server.csr -signkey \"${path[server_key]}\" -out \"${path[server_crt]}\"\n  cat \"${path[server_key]}\" \"${path[server_crt]}\" > \"${path[server_pem]}\"\n  rm -f /tmp/server.csr\n}\n\nfunction generate_engine_config {\n  local type=\"vless\"\n  local users_object=\"\"\n  local reality_object=\"\"\n  local tls_object=\"\"\n  local warp_object=\"\"\n  local reality_port=443\n  local temp_file\n  if [[ ${config[transport]} == 'tuic' ]]; then\n    type='tuic'\n  elif [[ ${config[transport]} == 'hysteria2' ]]; then\n    type='hysteria2'\n  elif [[ ${config[transport]} == 'shadowtls' ]]; then\n    type='shadowtls'\n  else\n    type='vless'\n  fi\n  if [[ (${config[security]} == 'reality' || ${config[transport]} == 'shadowtls') && ${config[domain]} =~ \":\" ]]; then\n    reality_port=\"${config[domain]#*:}\"\n  fi\n  if [[ ${config[core]} == 'sing-box' ]]; then\n    reality_object='\"tls\": {\n      \"enabled\": true,\n      \"server_name\": \"'\"${config[domain]%%:*}\"'\",\n      \"alpn\": [],\n      \"reality\": {\n        \"enabled\": true,\n        \"handshake\": {\n          \"server\": \"'\"${config[domain]%%:*}\"'\",\n          \"server_port\": '\"${reality_port}\"'\n        },\n        \"private_key\": \"'\"${config[private_key]}\"'\",\n        \"short_id\": [\"'\"${config[short_id]}\"'\"],\n        \"max_time_difference\": \"1m\"\n      }\n    }'\n    tls_object='\"tls\": {\n      \"enabled\": true,\n      \"certificate_path\": \"/etc/sing-box/server.crt\",\n      \"key_path\": \"/etc/sing-box/server.key\"\n    }'\n    if [[ ${config[warp]} == 'ON' ]]; then\n      warp_object='{\n        \"type\": \"wireguard\",\n        \"tag\": \"warp\",\n        \"server\": \"engage.cloudflareclient.com\",\n        \"server_port\": 2408,\n        \"system_interface\": false,\n        \"local_address\": [\n          \"'\"${config[warp_interface_ipv4]}\"'/32\",\n          \"'\"${config[warp_interface_ipv6]}\"'/128\"\n        ],\n        \"private_key\": \"'\"${config[warp_private_key]}\"'\",\n        \"peer_public_key\": \"bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo=\",\n        \"reserved\": '\"$(warp_decode_reserved \"${config[warp_client_id]}\")\"',\n        \"mtu\": 1280\n      },'\n    fi\n    for user in \"${!users[@]}\"; do\n      if [ -n \"$users_object\" ]; then\n        users_object=\"${users_object},\"$'\\n'\n      fi\n      if [[ ${config[transport]} == 'tuic' ]]; then\n        users_object=${users_object}'{\"uuid\": \"'\"${users[${user}]}\"'\", \"password\": \"'\"$(echo -n \"${user}${users[${user}]}\" | sha256sum | cut -d ' ' -f 1 | head -c 16)\"'\", \"name\": \"'\"${user}\"'\"}'\n      elif [[ ${config[transport]} == 'hysteria2' ]]; then\n        users_object=${users_object}'{\"password\": \"'\"$(echo -n \"${user}${users[${user}]}\" | sha256sum | cut -d ' ' -f 1 | head -c 16)\"'\", \"name\": \"'\"${user}\"'\"}'\n      elif [[ ${config[transport]} == 'shadowtls' ]]; then\n        users_object=${users_object}'{\"password\": \"'\"${users[${user}]}\"'\", \"name\": \"'\"${user}\"'\"}'\n      else\n        users_object=${users_object}'{\"uuid\": \"'\"${users[${user}]}\"'\", \"flow\": \"'\"$([[ ${config[transport]} == 'tcp' ]] && echo 'xtls-rprx-vision' || true)\"'\", \"name\": \"'\"${user}\"'\"}'\n      fi\n    done\n    cat >\"${path[engine]}\" <<EOF\n{\n  \"log\": {\n    \"level\": \"error\",\n    \"timestamp\": true\n  },\n  \"dns\": {\n    \"servers\": [\n    $([[ ${config[safenet]} == ON ]] && echo '{\"address\": \"tcp://1.1.1.3\", \"detour\": \"internet\"},{\"address\": \"tcp://1.0.0.3\", \"detour\": \"internet\"}' || echo '{\"address\": \"tcp://1.1.1.1\", \"detour\": \"internet\"},{\"address\": \"tcp://1.0.0.1\", \"detour\": \"internet\"}')\n    ],\n    \"strategy\": \"prefer_ipv4\"\n  },\n  \"inbounds\": [\n    {\n      \"type\": \"direct\",\n      \"listen\": \"::\",\n      \"listen_port\": 8080,\n      \"network\": \"tcp\",\n      \"override_address\": \"${config[domain]%%:*}\",\n      \"override_port\": 80\n    },\n    {\n      \"type\": \"${type}\",\n      \"listen\": \"::\",\n      \"listen_port\": 8443,\n      \"sniff\": true,\n      \"sniff_override_destination\": true,\n      \"domain_strategy\": \"prefer_ipv4\",\n      \"users\": [${users_object}],\n      $(if [[ ${config[security]} == 'reality' && ${config[transport]} != 'shadowtls' ]]; then\n        echo \"${reality_object}\"\n      elif [[ ${config[transport]} == 'http' || ${config[transport]} == 'tcp' || ${config[transport]} == 'tuic' || ${config[transport]} == 'hysteria2' ]]; then\n        echo \"${tls_object}\"\n      elif [[ ${config[transport]} == 'shadowtls' ]]; then\n        :\n      else\n        echo '\"tls\":{\"enabled\": false}'\n      fi)\n      $(if [[ ${config[transport]} == http ]]; then\n      echo ',\"transport\": {\"type\": \"http\", \"host\": [\"'\"${config[server]}\"'\"], \"path\": \"/'\"${config[service_path]}\"'\"}'\n      fi\n      if [[ ${config[transport]} == grpc ]]; then\n      echo ',\"transport\": {\"type\": \"grpc\",\"service_name\": \"'\"${config[service_path]}\"'\"}'\n      fi \n      if [[ ${config[transport]} == ws ]]; then\n      echo ',\"transport\": {\"type\": \"ws\", \"headers\": {\"Host\": \"'\"${config[server]}\"'\"}, \"path\": \"/'\"${config[service_path]}\"'\"}'\n      fi\n      if [[ ${config[transport]} == tuic ]]; then\n      echo ',\"congestion_control\": \"bbr\", \"auth_timeout\": \"3s\", \"zero_rtt_handshake\": false, \"heartbeat\": \"10s\"'\n      fi\n      if [[ ${config[transport]} == hysteria2 ]]; then\n      echo ',\"obfs\": {\"type\": \"salamander\", \"password\": \"'\"${config[service_path]}\"'\"}, \"ignore_client_bandwidth\": true, \"masquerade\": \"https://'\"${config[server]}:${config[port]}\"'\"'\n      fi\n      if [[ ${config[transport]} == shadowtls ]]; then\n      echo '\"version\": 3, \"strict_mode\": false, \"detour\": \"shadowsocks\", \"handshake\": {\"server\": \"'\"${config[domain]%%:*}\"'\", \"server_port\": '\"${reality_port}\"'}'\n      fi\n      )\n    }\n    $(if [[ ${config[transport]} == 'shadowtls' ]]; then\n    echo ', {\n      \"type\": \"shadowsocks\",\n      \"tag\": \"shadowsocks\",\n      \"listen\": \"127.0.0.1\",\n      \"listen_port\": 8444,\n      \"sniff\": true,\n      \"sniff_override_destination\": true,\n      \"domain_strategy\": \"prefer_ipv4\",\n      \"method\": \"chacha20-ietf-poly1305\",\n      \"password\": \"'\"${config[private_key]}\"'\",\n      \"users\": ['\"${users_object}\"']\n    }'\n    fi )\n  ],\n  \"outbounds\": [\n    {\n      \"type\": \"direct\",\n      \"tag\": \"internet\"\n    },\n    $([[ ${config[warp]} == ON ]] && echo \"${warp_object}\" || true)\n    {\n      \"type\": \"block\",\n      \"tag\": \"block\"\n    }\n  ],\n  \"route\": {\n    \"final\": \"$([[ ${config[warp]} == ON ]] && echo \"warp\" || echo \"internet\")\",\n    \"rule_set\": [\n      {\n        \"tag\": \"block\",\n        \"type\": \"remote\",\n        \"format\": \"binary\",\n        \"url\": \"https://raw.githubusercontent.com/aleskxyz/sing-box-rules/refs/heads/rule-set/block.srs\",\n        \"download_detour\": \"internet\"\n      },\n      {\n        \"tag\": \"nsfw\",\n        \"type\": \"remote\",\n        \"format\": \"binary\",\n        \"url\": \"https://raw.githubusercontent.com/aleskxyz/sing-box-rules/refs/heads/rule-set/geosite-nsfw.srs\",\n        \"download_detour\": \"internet\"\n      },\n      {\n        \"tag\": \"geoip-private\",\n        \"type\": \"remote\",\n        \"format\": \"binary\",\n        \"url\": \"https://raw.githubusercontent.com/aleskxyz/sing-box-rules/refs/heads/rule-set/geoip-private.srs\",\n        \"download_detour\": \"internet\"\n      },\n      {\n        \"tag\": \"geosite-private\",\n        \"type\": \"remote\",\n        \"format\": \"binary\",\n        \"url\": \"https://raw.githubusercontent.com/aleskxyz/sing-box-rules/refs/heads/rule-set/geosite-private.srs\",\n        \"download_detour\": \"internet\"\n      },\n      {\n        \"tag\": \"bypass\",\n        \"type\": \"remote\",\n        \"format\": \"binary\",\n        \"url\": \"https://raw.githubusercontent.com/aleskxyz/sing-box-rules/refs/heads/rule-set/bypass.srs\",\n        \"download_detour\": \"internet\"\n      }\n    ],\n    \"rules\": [\n      {\n        \"rule_set\": [\n          \"block\",\n          \"geoip-private\",\n          \"geosite-private\"\n          $([[ ${config[safenet]} == ON ]] && echo ',\"nsfw\"' || true)\n          $([[ ${config[warp]} == OFF ]] && echo ',\"bypass\"')\n        ],\n        \"outbound\": \"block\"\n      },\n      {\n        \"network\": \"tcp\",\n        \"port\": [\n          25,\n          587,\n          465,\n          2525\n        ],\n        \"outbound\": \"block\"\n      }\n    ]\n  },\n  \"experimental\": {\n    \"cache_file\": {\n      \"enabled\": true\n    }\n  }\n}\nEOF\n  fi\n  if [[ ${config[core]} == 'xray' ]]; then\n    reality_object='\"security\":\"reality\",\n    \"realitySettings\":{\n      \"show\": false,\n      \"dest\": \"'\"${config[domain]%%:*}\"':'\"${reality_port}\"'\",\n      \"xver\": 0,\n      \"serverNames\": [\"'\"${config[domain]%%:*}\"'\"],\n      \"privateKey\": \"'\"${config[private_key]}\"'\",\n      \"maxTimeDiff\": 60000,\n      \"shortIds\": [\"'\"${config[short_id]}\"'\"]\n    }'\n    tls_object='\"security\": \"tls\",\n    \"tlsSettings\": {\n      \"certificates\": [{\n        \"oneTimeLoading\": true,\n        \"certificateFile\": \"/etc/xray/server.crt\",\n        \"keyFile\": \"/etc/xray/server.key\"\n      }]\n    }'\n    if [[ ${config[warp]} == 'ON' ]]; then\n      warp_object='{\n        \"protocol\": \"wireguard\",\n        \"tag\": \"warp\",\n        \"settings\": {\n          \"secretKey\": \"'\"${config[warp_private_key]}\"'\",\n          \"address\": [\n            \"'\"${config[warp_interface_ipv4]}\"'/32\",\n            \"'\"${config[warp_interface_ipv6]}\"'/128\"\n          ],\n          \"peers\": [\n            {\n              \"endpoint\": \"engage.cloudflareclient.com:2408\",\n              \"publicKey\": \"bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo=\"\n            }\n          ],\n          \"mtu\": 1280\n        }\n      },'\n    fi\n    for user in \"${!users[@]}\"; do\n      if [ -n \"$users_object\" ]; then\n        users_object=\"${users_object},\"$'\\n'\n      fi\n      users_object=${users_object}'{\"id\": \"'\"${users[${user}]}\"'\", \"flow\": \"'\"$([[ ${config[transport]} == 'tcp' ]] && echo 'xtls-rprx-vision' || true)\"'\", \"email\": \"'\"${user}\"'\"}'\n    done\n    cat >\"${path[engine]}\" <<EOF\n{\n  \"log\": {\n    \"loglevel\": \"error\"\n  },\n  \"dns\": {\n    \"servers\": [$([[ ${config[safenet]} == ON ]] && echo '\"tcp+local://1.1.1.3\",\"tcp+local://1.0.0.3\"' || echo '\"tcp+local://1.1.1.1\",\"tcp+local://1.0.0.1\"')]\n  },\n  \"inbounds\": [\n    {\n      \"listen\": \"0.0.0.0\",\n      \"port\": 8080,\n      \"protocol\": \"dokodemo-door\",\n      \"settings\": {\n        \"address\": \"${config[domain]%%:*}\",\n        \"port\": 80,\n        \"network\": \"tcp\"\n      }\n    },\n    {\n      \"listen\": \"0.0.0.0\",\n      \"port\": 8443,\n      \"protocol\": \"vless\",\n      \"tag\": \"inbound\",\n      \"settings\": {\n        \"clients\": [${users_object}],\n        \"decryption\": \"none\"\n      },\n      \"streamSettings\": {\n        $([[ ${config[transport]} == 'grpc' ]] && echo '\"grpcSettings\": {\"serviceName\": \"'\"${config[service_path]}\"'\"},' || true)\n        $([[ ${config[transport]} == 'ws' ]] && echo '\"wsSettings\": {\"headers\": {\"Host\": \"'\"${config[server]}\"'\"}, \"path\": \"/'\"${config[service_path]}\"'\"},' || true)\n        $([[ ${config[transport]} == 'http' ]] && echo '\"httpSettings\": {\"host\":[\"'\"${config[server]}\"'\"], \"path\": \"/'\"${config[service_path]}\"'\"},' || true)\n        \"network\": \"${config[transport]}\",\n        $(if [[ ${config[security]} == 'reality' ]]; then\n          echo \"${reality_object}\"\n        elif [[ ${config[transport]} == 'http' || ${config[transport]} == 'tcp' ]]; then\n          echo \"${tls_object}\"\n        else\n          echo '\"security\":\"none\"'\n        fi)\n      },\n      \"sniffing\": {\n        \"enabled\": true,\n        \"destOverride\": [\n          \"http\",\n          \"tls\"\n        ]\n      }\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"protocol\": \"freedom\",\n      \"tag\": \"internet\"\n    },\n    $([[ ${config[warp]} == ON ]] && echo \"${warp_object}\" || true)\n    {\n      \"protocol\": \"blackhole\",\n      \"tag\": \"block\"\n    }\n  ],\n  \"routing\": {\n    \"domainStrategy\": \"IPIfNonMatch\",\n    \"rules\": [\n      {\n        \"type\": \"field\",\n        \"ip\": [\n          $([[ ${config[warp]} == OFF ]] && echo '\"geoip:cn\", \"geoip:ir\",')\n          \"0.0.0.0/8\",\n          \"10.0.0.0/8\",\n          \"100.64.0.0/10\",\n          \"127.0.0.0/8\",\n          \"169.254.0.0/16\",\n          \"172.16.0.0/12\",\n          \"192.0.0.0/24\",\n          \"192.0.2.0/24\",\n          \"192.168.0.0/16\",\n          \"198.18.0.0/15\",\n          \"198.51.100.0/24\",\n          \"203.0.113.0/24\",\n          \"::1/128\",\n          \"fc00::/7\",\n          \"fe80::/10\",\n          \"geoip:private\"\n        ],\n        \"outboundTag\": \"block\"\n      },\n      {\n        \"type\": \"field\",\n        \"port\": \"25, 587, 465, 2525\",\n        \"network\": \"tcp\",\n        \"outboundTag\": \"block\"\n      },\n      {\n        \"type\": \"field\",\n        \"protocol\": [\"bittorrent\"],\n        \"outboundTag\": \"block\"\n      },\n      {\n        \"type\": \"field\",\n        \"outboundTag\": \"block\",\n        \"domain\": [\n          $([[ ${config[safenet]} == ON ]] && echo '\"geosite:category-porn\",' || true)\n          \"geosite:category-ads-all\",\n          \"domain:pushnotificationws.com\",\n          \"domain:sunlight-leds.com\",\n          \"domain:icecyber.org\"\n        ]\n      },\n      {\n        \"type\": \"field\",\n        \"inboundTag\": \"inbound\",\n        \"outboundTag\": \"$([[ ${config[warp]} == ON ]] && echo \"warp\" || echo \"internet\")\"\n      }\n    ]\n  },\n  \"policy\": {\n    \"levels\": {\n      \"0\": {\n        \"handshake\": 2,\n        \"connIdle\": 120\n      }\n    }\n  }\n}\nEOF\n  fi\n  if [[ -r ${config_path}/${config[core]}.patch ]]; then\n    if ! jq empty ${config_path}/${config[core]}.patch; then\n      echo \"${config[core]}.patch is not a valid json file. Fix it or remove it!\"\n      exit 1\n    fi\n    temp_file=$(mktemp)\n    jq -s add ${path[engine]} ${config_path}/${config[core]}.patch > ${temp_file}\n    mv ${temp_file} ${path[engine]}\n  fi\n}\n\nfunction generate_config {\n  generate_docker_compose\n  generate_engine_config\n  if [[ ${config[security]} != \"reality\" && ${config[transport]} != 'shadowtls' ]]; then\n    mkdir -p \"${config_path}/certificate\"\n    generate_haproxy_config\n    if [[ ! -r \"${path[server_pem]}\" || ! -r \"${path[server_crt]}\" || ! -r \"${path[server_key]}\" ]]; then\n      generate_selfsigned_certificate\n    fi\n  fi\n  if [[ ${config[security]} == \"letsencrypt\" && ${config[transport]} != 'shadowtls' ]]; then\n    mkdir -p \"${config_path}/certbot\"\n    generate_certbot_deployhook\n    generate_certbot_dockerfile\n    generate_certbot_script\n  fi\n  if [[ ${config[tgbot]} == \"ON\" ]]; then\n    mkdir -p \"${config_path}/tgbot\"\n    generate_tgbot_compose\n    generate_tgbot_dockerfile\n    download_tgbot_script\n  fi\n}\n\nfunction get_ipv6 {\n  curl -fsSL -m 3 --ipv6 https://cloudflare.com/cdn-cgi/trace 2> /dev/null | grep ip | cut -d '=' -f2\n}\n\nfunction print_client_configuration {\n  local username=$1\n  local client_config\n  local ipv6\n  local client_config_ipv6\n  if [[ ${config[transport]} == 'tuic' ]]; then\n    client_config=\"tuic://\"\n    client_config=\"${client_config}${users[${username}]}\"\n    client_config=\"${client_config}:$(echo -n \"${username}${users[${username}]}\" | sha256sum | cut -d ' ' -f 1 | head -c 16)\"\n    client_config=\"${client_config}@${config[server]}\"\n    client_config=\"${client_config}:${config[port]}\"\n    client_config=\"${client_config}/?congestion_control=bbr&udp_relay_mode=quic\"\n    client_config=\"${client_config}$([[ ${config[security]} == 'selfsigned' ]] && echo \"&allow_insecure=1\" || true)\"\n    client_config=\"${client_config}#${username}\"\n  elif [[ ${config[transport]} == 'hysteria2' ]]; then\n    client_config=\"hy2://\"\n    client_config=\"${client_config}$(echo -n \"${username}${users[${username}]}\" | sha256sum | cut -d ' ' -f 1 | head -c 16)\"\n    client_config=\"${client_config}@${config[server]}\"\n    client_config=\"${client_config}:${config[port]}\"\n    client_config=\"${client_config}/?obfs=salamander&obfs-password=${config[service_path]}\"\n    client_config=\"${client_config}$([[ ${config[security]} == 'selfsigned' ]] && echo \"&insecure=1\" || true)\"\n    client_config=\"${client_config}#${username}\"\n  elif [[ ${config[transport]} == 'shadowtls' ]]; then\n    client_config='{\"dns\":{\"independent_cache\":true,\"rules\":[{\"domain\":[\"dns.google\"],\"server\":\"dns-direct\"}],\"servers\":[{\"address\":\"https://dns.google/dns-query\",\"address_resolver\":\"dns-direct\",\"strategy\":\"ipv4_only\",\"tag\":\"dns-remote\"},{\"address\":\"local\",\"address_resolver\":\"dns-local\",\"detour\":\"direct\",\"strategy\":\"ipv4_only\",\"tag\":\"dns-direct\"},{\"address\":\"local\",\"detour\":\"direct\",\"tag\":\"dns-local\"},{\"address\":\"rcode://success\",\"tag\":\"dns-block\"}]},\"inbounds\":[{\"listen\":\"127.0.0.1\",\"listen_port\":6450,\"override_address\":\"8.8.8.8\",\"override_port\":53,\"tag\":\"dns-in\",\"type\":\"direct\"},{\"domain_strategy\":\"\",\"endpoint_independent_nat\":true,\"inet4_address\":[\"172.19.0.1/28\"],\"mtu\":9000,\"sniff\":true,\"sniff_override_destination\":false,\"stack\":\"mixed\",\"tag\":\"tun-in\",\"auto_route\":true,\"type\":\"tun\"},{\"domain_strategy\":\"\",\"listen\":\"127.0.0.1\",\"listen_port\":2080,\"sniff\":true,\"sniff_override_destination\":false,\"tag\":\"mixed-in\",\"type\":\"mixed\"}],\"log\":{\"level\":\"warning\"},\"outbounds\":[{\"method\":\"chacha20-ietf-poly1305\",\"password\":\"'\"${users[${username}]}\"'\",\"server\":\"127.0.0.1\",\"server_port\":1080,\"type\":\"shadowsocks\",\"udp_over_tcp\":true,\"domain_strategy\":\"\",\"tag\":\"proxy\",\"detour\":\"shadowtls\"},{\"password\":\"'\"${users[${username}]}\"'\",\"server\":\"'\"${config[server]}\"'\",\"server_port\":'\"${config[port]}\"',\"tls\":{\"enabled\":true,\"insecure\":false,\"server_name\":\"'\"${config[domain]%%:*}\"'\",\"utls\":{\"enabled\":true,\"fingerprint\":\"chrome\"}},\"version\":3,\"type\":\"shadowtls\",\"domain_strategy\":\"\",\"tag\":\"shadowtls\"},{\"tag\":\"direct\",\"type\":\"direct\"},{\"tag\":\"bypass\",\"type\":\"direct\"},{\"tag\":\"block\",\"type\":\"block\"},{\"tag\":\"dns-out\",\"type\":\"dns\"}],\"route\":{\"auto_detect_interface\":true,\"rule_set\":[],\"rules\":[{\"outbound\":\"dns-out\",\"port\":[53]},{\"inbound\":[\"dns-in\"],\"outbound\":\"dns-out\"},{\"ip_cidr\":[\"224.0.0.0/3\",\"ff00::/8\"],\"outbound\":\"block\",\"source_ip_cidr\":[\"224.0.0.0/3\",\"ff00::/8\"]}]}}'\n  else\n    client_config=\"vless://\"\n    client_config=\"${client_config}${users[${username}]}\"\n    client_config=\"${client_config}@${config[server]}\"\n    client_config=\"${client_config}:${config[port]}\"\n    client_config=\"${client_config}?security=$([[ ${config[security]} == 'reality' ]] && echo reality || echo tls)\"\n    client_config=\"${client_config}&encryption=none\"\n    client_config=\"${client_config}&alpn=$([[ ${config[transport]} == 'ws' ]] && echo 'http/1.1' || echo 'h2,http/1.1')\"\n    client_config=\"${client_config}&headerType=none\"\n    client_config=\"${client_config}&fp=chrome\"\n    client_config=\"${client_config}&type=${config[transport]}\"\n    client_config=\"${client_config}&flow=$([[ ${config[transport]} == 'tcp' ]] && echo 'xtls-rprx-vision' || true)\"\n    client_config=\"${client_config}&sni=${config[domain]%%:*}\"\n    client_config=\"${client_config}$([[ ${config[transport]} == 'ws' || ${config[transport]} == 'http' ]] && echo \"&host=${config[server]}\" || true)\"\n    client_config=\"${client_config}$([[ ${config[security]} == 'reality' ]] && echo \"&pbk=${config[public_key]}\" || true)\"\n    client_config=\"${client_config}$([[ ${config[security]} == 'reality' ]] && echo \"&sid=${config[short_id]}\" || true)\"\n    client_config=\"${client_config}$([[ ${config[transport]} == 'ws' || ${config[transport]} == 'http' ]] && echo \"&path=%2F${config[service_path]}\" || true)\"\n    client_config=\"${client_config}$([[ ${config[transport]} == 'grpc' ]] && echo '&mode=gun' || true)\"\n    client_config=\"${client_config}$([[ ${config[transport]} == 'grpc' ]] && echo \"&serviceName=${config[service_path]}\" || true)\"\n    client_config=\"${client_config}#${username}\"\n  fi\n  echo \"\"\n  echo \"==================================================\"\n  echo \"Client configuration:\"\n  echo \"\"\n  echo \"$client_config\"\n  echo \"\"\n  echo \"Or you can scan the QR code:\"\n  echo \"\"\n  qrencode -t ansiutf8 \"${client_config}\"\n  ipv6=$(get_ipv6)\n  if [[ -n $ipv6 ]]; then\n    if [[ ${config[transport]} != 'shadowtls' ]]; then\n      client_config_ipv6=$(echo \"$client_config\" | sed \"s/@${config[server]}:/@[${ipv6}]:/\" | sed \"s/#${username}/#${username}-ipv6/\")\n    else\n      client_config_ipv6=$(echo \"$client_config\" | sed \"s/\\\"server\\\":\\\"${config[server]}\\\"/\\\"server\\\":\\\"${ipv6}\\\"/\")\n    fi\n    echo \"\"\n    echo \"==================IPv6 Config======================\"\n    echo \"Client configuration:\"\n    echo \"\"\n    echo \"$client_config_ipv6\"\n    echo \"\"\n    echo \"Or you can scan the QR code:\"\n    echo \"\"\n    qrencode -t ansiutf8 \"${client_config_ipv6}\"\n  fi\n}\n\nfunction upgrade {\n  local uuid\n  local warp_token\n  local warp_id\n  if [[ -e \"${HOME}/reality/config\" ]]; then\n    ${docker_cmd} --project-directory \"${HOME}/reality\" down --remove-orphans --timeout 2\n    mv -f \"${HOME}/reality\" ${config_path}\n  fi\n  uuid=$(grep '^uuid=' \"${path[config]}\" 2>/dev/null | cut -d= -f2 || true)\n  if [[ -n $uuid ]]; then\n    sed -i '/^uuid=/d' \"${path[users]}\"\n    echo \"RealityEZPZ=${uuid}\" >> \"${path[users]}\"\n    sed -i 's|=true|=ON|g; s|=false|=OFF|g' \"${path[users]}\"\n  fi\n  rm -f \"${config_path}/xray.conf\"\n  rm -f \"${config_path}/singbox.conf\"\n  if ! ${docker_cmd} ls | grep ${compose_project} >/dev/null && [[ -r ${path[compose]} ]]; then\n    ${docker_cmd} --project-directory ${config_path} down --remove-orphans --timeout 2\n  fi\n  if [[ -r ${path[config]} ]]; then\n    sed -i 's|transport=h2|transport=http|g' \"${path[config]}\"\n    sed -i 's|core=singbox|core=sing-box|g' \"${path[config]}\"\n    sed -i 's|security=tls-invalid|security=selfsigned|g' \"${path[config]}\"\n    sed -i 's|security=tls-valid|security=letsencrypt|g' \"${path[config]}\"\n  fi\n  for key in \"${!path[@]}\"; do\n    if [[ -d \"${path[$key]}\" ]]; then\n      rm -rf \"${path[$key]}\"\n    fi\n  done\n  if [[ -d \"${config_path}/warp\" ]]; then\n    ${docker_cmd} --project-directory ${config_path} -p ${compose_project} down --remove-orphans --timeout 2 || true\n    warp_token=$(cat ${config_path}/warp/reg.json | jq -r '.api_token')\n    warp_id=$(cat ${config_path}/warp/reg.json | jq -r '.registration_id')\n    warp_api \"DELETE\" \"/reg/${warp_id}\" \"\" \"${warp_token}\" >/dev/null 2>&1 || true\n    rm -rf \"${config_path}/warp\"\n  fi\n}\n\nfunction main_menu {\n  local selection\n  while true; do\n    selection=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Server Management\" \\\n      --menu \"$MENU\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      --ok-button \"Select\" \\\n      --cancel-button \"Exit\" \\\n      \"1\" \"Add New User\" \\\n      \"2\" \"Delete User\" \\\n      \"3\" \"View User\" \\\n      \"4\" \"View Server Config\" \\\n      \"5\" \"Configuration\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    case $selection in\n      1 )\n        add_user_menu\n        ;;\n      2 )\n        delete_user_menu\n        ;;\n      3 )\n        view_user_menu\n        ;;\n      4 )\n        view_config_menu\n        ;;\n      5 )\n        configuration_menu\n        ;;\n    esac\n  done\n}\n\nfunction add_user_menu {\n  local username\n  local message\n  while true; do\n    username=$(whiptail \\\n      --clear \\\n      --backtitle \"$BACKTITLE\" \\\n      --title \"Add New User\" \\\n      --inputbox \"Enter username:\" \\\n      $HEIGHT $WIDTH \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ! $username =~ ${regex[username]} ]]; then\n      message_box \"Invalid Username\" \"Username can only contains A-Z, a-z and 0-9\"\n      continue\n    fi\n    if [[ -n ${users[$username]} ]]; then\n      message_box \"Invalid Username\" '\"'\"${username}\"'\" already exists.'\n      continue\n    fi\n    users[$username]=$(cat /proc/sys/kernel/random/uuid)\n    update_users_file\n    whiptail \\\n      --clear \\\n      --backtitle \"$BACKTITLE\" \\\n      --title \"Add New User\" \\\n      --yes-button \"View User\" \\\n      --no-button \"Return\" \\\n      --yesno 'User \"'\"${username}\"'\" has been created.' \\\n      $HEIGHT $WIDTH \\\n      3>&1 1>&2 2>&3\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    view_user_menu \"${username}\"\n  done\n}\n\nfunction delete_user_menu {\n  local username\n  while true; do\n    username=$(list_users_menu \"Delete User\")\n    if [[ $? -ne 0 ]]; then\n      return 0\n    fi\n    if [[ ${#users[@]} -eq 1 ]]; then\n      message_box \"Delete User\" \"You cannot delete the only user.\\nAt least one user is needed.\\nCreate a new user, then delete this one.\"\n      continue\n    fi\n    whiptail \\\n      --clear \\\n      --backtitle \"$BACKTITLE\" \\\n      --title \"Delete User\" \\\n      --yesno \"Are you sure you want to delete $username?\" \\\n      $HEIGHT $WIDTH \\\n      3>&1 1>&2 2>&3\n    if [[ $? -ne 0 ]]; then\n      continue\n    fi\n    unset users[\"${username}\"]\n    update_users_file\n    message_box \"Delete User\" 'User \"'\"${username}\"'\" has been deleted.'\n  done\n}\n\nfunction view_user_menu {\n  local username\n  local user_config\n  while true; do\n    if [[ $# -gt 0 ]]; then\n      username=$1\n    else\n      username=$(list_users_menu \"View User\")\n      if [[ $? -ne 0 ]]; then\n        return 0\n      fi\n    fi\n    if [[ ${config[transport]} == 'tuic' ]]; then\n      user_config=$(echo \"\nProtocol: tuic\nRemarks: ${username}\nAddress: ${config[server]}\nPort: ${config[port]}\nUUID: ${users[$username]}\nPassword: $(echo -n \"${username}${users[${username}]}\" | sha256sum | cut -d ' ' -f 1 | head -c 16)\nUDP Relay Mode: quic\nCongestion Control: bbr\n      \" | tr -s '\\n')\n    elif [[ ${config[transport]} == 'hysteria2' ]]; then\n      user_config=$(echo \"\nProtocol: hysteria2\nRemarks: ${username}\nAddress: ${config[server]}\nPort: ${config[port]}\nPassword: $(echo -n \"${username}${users[${username}]}\" | sha256sum | cut -d ' ' -f 1 | head -c 16)\nOBFS Type: salamander\nOBFS Password: ${config[service_path]}\n      \" | tr -s '\\n')\n    elif [[ ${config[transport]} == 'shadowtls' ]]; then\n      user_config=$(echo \"\n=== First item of the chain proxy ===\nProtocol: shadowtls\nRemarks: ${username}-shadowtls\nAddress: ${config[server]}\nPort: ${config[port]}\nPassword: ${users[$username]}\nProtocol Version: 3\nSNI: ${config[domain]%%:*}\nFingerprint: chrome\n=== Second item of the chain proxy ===\nProtocol: shadowsocks\nRemarks: ${username}-shadowsocks\nAddress: 127.0.0.1\nPort: 1080\nPassword: ${users[$username]}\nEncryption Method: chacha20-ietf-poly1305\nUDP over TCP: true\n\n      \" | tr -s '\\n')\n    else\n      user_config=$(echo \"\nProtocol: vless\nRemarks: ${username}\nAddress: ${config[server]}\nPort: ${config[port]}\nID: ${users[$username]}\nFlow: $([[ ${config[transport]} == 'tcp' ]] && echo 'xtls-rprx-vision' || true)\nNetwork: ${config[transport]}\n$([[ ${config[transport]} == 'ws' || ${config[transport]} == 'http' ]] && echo \"Host Header: ${config[server]}\" || true)\n$([[ ${config[transport]} == 'ws' || ${config[transport]} == 'http' ]] && echo \"Path: /${config[service_path]}\" || true)\n$([[ ${config[transport]} == 'grpc' ]] && echo 'gRPC mode: gun' || true)\n$([[ ${config[transport]} == 'grpc' ]] && echo 'gRPC serviceName: '\"${config[service_path]}\" || true)\nTLS: $([[ ${config[security]} == 'reality' ]] && echo 'reality' || echo 'tls')\nSNI: ${config[domain]%%:*}\nALPN: $([[ ${config[transport]} == 'ws' ]] && echo 'http/1.1' || echo 'h2,http/1.1')\nFingerprint: chrome\n$([[ ${config[security]} == 'reality' ]] && echo \"PublicKey: ${config[public_key]}\" || true)\n$([[ ${config[security]} == 'reality' ]] && echo \"ShortId: ${config[short_id]}\" || true)\n      \" | tr -s '\\n')\n    fi\n    whiptail \\\n      --clear \\\n      --backtitle \"$BACKTITLE\" \\\n      --title \"${username} details\" \\\n      --yes-button \"View QR\" \\\n      --no-button \"Return\" \\\n      --yesno \"${user_config}\" \\\n      $HEIGHT $WIDTH \\\n      3>&1 1>&2 2>&3\n    if [[ $? -eq 0 ]]; then\n      clear\n      print_client_configuration \"${username}\"\n      echo\n      echo \"Press Enter to return ...\"\n      read\n      clear\n    fi\n    if [[ $# -gt 0 ]]; then\n      return 0\n    fi\n  done\n}\n\nfunction list_users_menu {\n  local title=$1\n  local options\n  local selection\n  options=$(dict_expander users)\n  selection=$(whiptail --clear --noitem --backtitle \"$BACKTITLE\" --title \"$title\" \\\n    --menu \"Select the user\" $HEIGHT $WIDTH $CHOICE_HEIGHT $options \\\n    3>&1 1>&2 2>&3)\n  if [[ $? -ne 0 ]]; then\n    return 1\n  fi\n  echo \"${selection}\"\n}\n\nfunction show_server_config {\n  local server_config\n  server_config=\"Core: ${config[core]}\"\n  server_config=$server_config$'\\n'\"Server Address: ${config[server]}\"\n  server_config=$server_config$'\\n'\"Domain SNI: ${config[domain]}\"\n  server_config=$server_config$'\\n'\"Port: ${config[port]}\"\n  server_config=$server_config$'\\n'\"Transport: ${config[transport]}\"\n  server_config=$server_config$'\\n'\"Security: ${config[security]}\"\n  server_config=$server_config$'\\n'\"Safenet: ${config[safenet]}\"\n  server_config=$server_config$'\\n'\"WARP: ${config[warp]}\"\n  server_config=$server_config$'\\n'\"WARP License: ${config[warp_license]}\"\n  server_config=$server_config$'\\n'\"Telegram Bot: ${config[tgbot]}\"\n  server_config=$server_config$'\\n'\"Telegram Bot Token: ${config[tgbot_token]}\"\n  server_config=$server_config$'\\n'\"Telegram Bot Admins: ${config[tgbot_admins]}\"\n  echo \"${server_config}\"\n}\n\nfunction view_config_menu {\n  local server_config\n  server_config=$(show_server_config)\n  message_box \"Server Configuration\" \"${server_config}\"\n}\n\nfunction restart_menu {\n  whiptail \\\n    --clear \\\n    --backtitle \"$BACKTITLE\" \\\n    --title \"Restart Services\" \\\n    --yesno \"Are you sure to restart services?\" \\\n    $HEIGHT $WIDTH \\\n    3>&1 1>&2 2>&3\n  if [[ $? -ne 0 ]]; then\n    return\n  fi\n  restart_docker_compose\n  if [[ ${config[tgbot]} == 'ON' ]]; then\n    restart_tgbot_compose\n  fi\n}\n\nfunction regenerate_menu {\n  whiptail \\\n    --clear \\\n    --backtitle \"$BACKTITLE\" \\\n    --title \"Regenrate keys\" \\\n    --yesno \"Are you sure to regenerate keys?\" \\\n    $HEIGHT $WIDTH \\\n    3>&1 1>&2 2>&3\n  if [[ $? -ne 0 ]]; then\n    return\n  fi\n  generate_keys\n  config[public_key]=${config_file[public_key]}\n  config[private_key]=${config_file[private_key]}\n  config[short_id]=${config_file[short_id]}\n  update_config_file\n  message_box \"Regenerate keys\" \"All keys has been regenerated.\"\n}\n\nfunction restore_defaults_menu {\n  whiptail \\\n    --clear \\\n    --backtitle \"$BACKTITLE\" \\\n    --title \"Restore Default Config\" \\\n    --yesno \"Are you sure to restore default configuration?\" \\\n    $HEIGHT $WIDTH \\\n    3>&1 1>&2 2>&3\n  if [[ $? -ne 0 ]]; then\n    return\n  fi\n  restore_defaults\n  update_config_file\n  message_box \"Restore Default Config\" \"All configurations has been restored to their defaults.\"\n}\n\nfunction configuration_menu {\n  local selection\n  while true; do\n    selection=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Configuration\" \\\n      --menu \"Select an option:\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      \"1\" \"Core\" \\\n      \"2\" \"Server Address\" \\\n      \"3\" \"Transport\" \\\n      \"4\" \"SNI Domain\" \\\n      \"5\" \"Security\" \\\n      \"6\" \"Port\" \\\n      \"7\" \"Safe Internet\" \\\n      \"8\" \"WARP\" \\\n      \"9\" \"Telegram Bot\" \\\n      \"10\" \"Restart Services\" \\\n      \"11\" \"Regenerate Keys\" \\\n      \"12\" \"Restore Defaults\" \\\n      \"13\" \"Create Backup\" \\\n      \"14\" \"Restore Backup\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    case $selection in\n      1 )\n        config_core_menu\n        ;;\n      2 )\n        config_server_menu\n        ;;\n      3 )\n        config_transport_menu\n        ;;\n      4 )\n        config_sni_domain_menu\n        ;;\n      5 )\n        config_security_menu\n        ;;\n      6 )\n        config_port_menu\n        ;;\n      7 )\n        config_safenet_menu\n        ;;\n      8 )\n        config_warp_menu\n        ;;\n      9 )\n        config_tgbot_menu\n        ;;\n      10 )\n        restart_menu\n        ;;\n      11 )\n        regenerate_menu\n        ;;\n      12 )\n        restore_defaults_menu\n        ;;\n      13 )\n        backup_menu\n        ;;\n      14 )\n        restore_backup_menu\n        ;;\n    esac\n  done\n}\n\nfunction config_core_menu {\n  local core\n  while true; do\n    core=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Core\" \\\n      --radiolist --noitem \"Select a core engine:\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      \"xray\" \"$([[ \"${config[core]}\" == 'xray' ]] && echo 'on' || echo 'off')\" \\\n      \"sing-box\" \"$([[ \"${config[core]}\" == 'sing-box' ]] && echo 'on' || echo 'off')\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ${core} == 'xray' && ${config[transport]} == 'tuic' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"xray\" core with \"tuic\" transport. Change core to \"sing-box\" or use other transports'\n      continue\n    fi\n    if [[ ${core} == 'xray' && ${config[transport]} == 'hysteria2' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"xray\" core with \"hysteria2\" transport. Change core to \"sing-box\" or use other transports'\n      continue\n    fi\n    if [[ ${core} == 'xray' && ${config[transport]} == 'shadowtls' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"xray\" core with \"shadowtls\" transport. Change core to \"sing-box\" or use other transports'\n      continue\n    fi\n    config[core]=$core\n    update_config_file\n    break\n  done\n}\n\nfunction config_server_menu {\n  local server\n  while true; do\n    server=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Server Address\" \\\n      --inputbox \"Enter Server IP or Domain:\" $HEIGHT $WIDTH \"${config[\"server\"]}\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ! ${server} =~ ${regex[domain]} && ${config[security]} == 'letsencrypt' ]]; then\n      message_box 'Invalid Configuration' 'You have to assign a valid domain to server if you want to use \"letsencrypt\" certificate.'\n      continue\n    fi\n    if [[ -z ${server} ]]; then\n      server=\"${defaults[server]}\"\n    fi\n    config[server]=\"${server}\"\n    if [[ ${config[security]} != 'reality' && ${config[transport]} != 'shadowtls' ]]; then\n      config[domain]=\"${server}\"\n    fi\n    update_config_file\n    break\n  done\n}\n\nfunction config_transport_menu {\n  local transport\n  while true; do\n    transport=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Transport\" \\\n      --radiolist --noitem \"Select a transport protocol:\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      \"tcp\" \"$([[ \"${config[transport]}\" == 'tcp' ]] && echo 'on' || echo 'off')\" \\\n      \"http\" \"$([[ \"${config[transport]}\" == 'http' ]] && echo 'on' || echo 'off')\" \\\n      \"grpc\" \"$([[ \"${config[transport]}\" == 'grpc' ]] && echo 'on' || echo 'off')\" \\\n      \"ws\" \"$([[ \"${config[transport]}\" == 'ws' ]] && echo 'on' || echo 'off')\" \\\n      \"tuic\" \"$([[ \"${config[transport]}\" == 'tuic' ]] && echo 'on' || echo 'off')\" \\\n      \"hysteria2\" \"$([[ \"${config[transport]}\" == 'hysteria2' ]] && echo 'on' || echo 'off')\" \\\n      \"shadowtls\" \"$([[ \"${config[transport]}\" == 'shadowtls' ]] && echo 'on' || echo 'off')\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ${transport} == 'ws' && ${config[security]} == 'reality' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"ws\" transport with \"reality\" TLS certificate. Use other transports or change TLS certifcate to \"letsencrypt\" or \"selfsigned\"'\n      continue\n    fi\n    if [[ ${transport} == 'tuic' && ${config[security]} == 'reality' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"tuic\" transport with \"reality\" TLS certificate. Use other transports or change TLS certifcate to \"letsencrypt\" or \"selfsigned\"'\n      continue\n    fi\n    if [[ ${transport} == 'tuic' && ${config[core]} == 'xray' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"tuic\" transport with \"xray\" core. Use other transports or change core to \"sing-box\"'\n      continue\n    fi\n    if [[ ${transport} == 'hysteria2' && ${config[security]} == 'reality' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"hysteria2\" transport with \"reality\" TLS certificate. Use other transports or change TLS certifcate to \"letsencrypt\" or \"selfsigned\"'\n      continue\n    fi\n    if [[ ${transport} == 'hysteria2' && ${config[core]} == 'xray' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"hysteria2\" transport with \"xray\" core. Use other transports or change core to \"sing-box\"'\n      continue\n    fi\n    if [[ ${transport} == 'shadowtls' && ${config[core]} == 'xray' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"shadowtls\" transport with \"xray\" core. Use other transports or change core to \"sing-box\"'\n      continue\n    fi\n    config[transport]=$transport\n    update_config_file\n    break\n  done\n}\n\nfunction config_sni_domain_menu {\n  local sni_domain\n  while true; do\n    sni_domain=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"SNI Domain\" \\\n      --inputbox \"Enter SNI domain:\" $HEIGHT $WIDTH \"${config[domain]}\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ! $sni_domain =~ ${regex[domain_port]} ]]; then\n      message_box \"Invalid Domain\" '\"'\"${sni_domain}\"'\" in not a valid domain.'\n      continue\n    fi\n    config[domain]=$sni_domain\n    update_config_file\n    break\n  done\n}\n\nfunction config_security_menu {\n  local security\n  local free_80=true\n  while true; do\n    security=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Security Type\" \\\n      --radiolist --noitem \"Select a security type:\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      \"reality\" \"$([[ \"${config[security]}\" == 'reality' ]] && echo 'on' || echo 'off')\" \\\n      \"letsencrypt\" \"$([[ \"${config[security]}\" == 'letsencrypt' ]] && echo 'on' || echo 'off')\" \\\n      \"selfsigned\" \"$([[ \"${config[security]}\" == 'selfsigned' ]] && echo 'on' || echo 'off')\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ! ${config[server]} =~ ${regex[domain]} && ${security} == 'letsencrypt' ]]; then\n      message_box 'Invalid Configuration' 'You have to assign a valid domain to server if you want to use \"letsencrypt\" as security type'\n      continue\n    fi\n    if [[ ${config[transport]} == 'ws' && ${security} == 'reality' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"reality\" TLS certificate with \"ws\" transport protocol. Change TLS certifcate to \"letsencrypt\" or \"selfsigned\" or use other transport protocols'\n      continue\n    fi\n    if [[ ${config[transport]} == 'tuic' && ${security} == 'reality' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"reality\" TLS certificate with \"tuic\" transport. Change TLS certifcate to \"letsencrypt\" or \"selfsigned\" or use other transports'\n      continue\n    fi\n    if [[ ${config[transport]} == 'hysteria2' && ${security} == 'reality' ]]; then\n      message_box 'Invalid Configuration' 'You cannot use \"reality\" TLS certificate with \"hysteria2\" transport. Change TLS certifcate to \"letsencrypt\" or \"selfsigned\" or use other transports'\n      continue\n    fi\n    if [[ ${security} == 'letsencrypt' && ${config[port]} -ne 443 ]]; then\n      if lsof -i :80 >/dev/null 2>&1; then\n        free_80=false\n        for container in $(${docker_cmd} -p ${compose_project} ps -q); do\n          if docker port \"${container}\" | grep '0.0.0.0:80' >/dev/null 2>&1; then\n            free_80=true\n            break\n          fi\n        done\n      fi\n      if [[ ${free_80} != 'true' ]]; then\n        message_box 'Port 80 must be free if you want to use \"letsencrypt\" as the security option.'\n        continue\n      fi\n    fi\n    if [[ ${security} != 'reality' && ${config[transport]} != 'shadowtls' ]]; then\n      config[domain]=\"${config[server]}\"\n    fi\n    if [[ ${security} == 'reality' || ${config[transport]} == 'shadowtls' ]]; then\n      config[domain]=\"${defaults[domain]}\"\n    fi\n    config[security]=\"${security}\"\n    update_config_file\n    break\n  done\n}\n\nfunction config_port_menu {\n  local port\n  while true; do\n    port=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Port\" \\\n      --inputbox \"Enter port number:\" $HEIGHT $WIDTH \"${config[port]}\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ! $port =~ ${regex[port]} ]]; then\n      message_box \"Invalid Port\" \"Port must be an integer\"\n      continue\n    fi\n    if ((port < 1 || port > 65535)); then\n      message_box \"Invalid Port\" \"Port must be between 1 to 65535\"\n      continue\n    fi\n    config[port]=$port\n    update_config_file\n    break\n  done\n}\n\nfunction config_safenet_menu {\n  local safenet\n  safenet=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Safe Internet\" \\\n    --radiolist --noitem \"Enable blocking malware and adult content\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n    \"Enable\" \"$([[ \"${config[safenet]}\" == 'ON' ]] && echo 'on' || echo 'off')\" \\\n    \"Disable\" \"$([[ \"${config[safenet]}\" == 'OFF' ]] && echo 'on' || echo 'off')\" \\\n    3>&1 1>&2 2>&3)\n  if [[ $? -ne 0 ]]; then\n    return\n  fi\n  config[safenet]=$([[ $safenet == 'Enable' ]] && echo ON || echo OFF)\n  update_config_file\n}\n\nfunction config_warp_menu {\n  local warp\n  local warp_license\n  local error\n  local temp_file\n  local exit_code\n  local old_warp=${config[warp]}\n  local old_warp_license=${config[warp_license]}\n  while true; do\n    warp=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"WARP\" \\\n      --radiolist --noitem \"Enable WARP:\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      \"Enable\" \"$([[ \"${config[warp]}\" == 'ON' ]] && echo 'on' || echo 'off')\" \\\n      \"Disable\" \"$([[ \"${config[warp]}\" == 'OFF' ]] && echo 'on' || echo 'off')\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ $warp == 'Disable' ]]; then\n      config[warp]=OFF\n      if [[ -n ${config[warp_id]} && -n ${config[warp_token]} ]]; then\n        warp_delete_account \"${config[warp_id]}\" \"${config[warp_token]}\"\n      fi\n      return\n    fi\n    if [[ -z ${config[warp_private_key]} || \\\n          -z ${config[warp_token]} || \\\n          -z ${config[warp_id]} || \\\n          -z ${config[warp_client_id]} || \\\n          -z ${config[warp_interface_ipv4]} || \\\n          -z ${config[warp_interface_ipv6]} ]]; then\n      temp_file=$(mktemp)\n      warp_create_account > \"${temp_file}\"\n      exit_code=$?\n      error=$(< \"${temp_file}\")\n      rm -f \"${temp_file}\"\n      if [[ ${exit_code} -ne 0 ]]; then\n        message_box \"WARP account creation error\" \"${error}\"\n        continue\n      fi\n    fi\n    config[warp]=ON\n    while true; do\n      warp_license=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"WARP+ License\" \\\n        --inputbox \"Enter WARP+ License:\" $HEIGHT $WIDTH \"${config[warp_license]}\" \\\n        3>&1 1>&2 2>&3)\n      if [[ $? -ne 0 ]]; then\n        break\n      fi\n      if [[ ! $warp_license =~ ${regex[warp_license]} ]]; then\n        message_box \"Invalid Input\" \"Invalid WARP+ License\"\n        continue\n      fi\n      temp_file=$(mktemp)\n      warp_add_license \"${config[warp_id]}\" \"${config[warp_token]}\" \"${warp_license}\" > \"${temp_file}\"\n      exit_code=$?\n      error=$(< \"${temp_file}\")\n      rm -f \"${temp_file}\"\n      if [[ ${exit_code} -ne 0 ]]; then\n        message_box \"WARP license error\" \"${error}\"\n        continue\n      fi\n      return\n    done\n  done\n  config[warp]=$old_warp\n  config[warp_license]=$old_warp_license\n}\n\nfunction config_tgbot_menu {\n  local tgbot\n  local tgbot_token\n  local tgbot_admins\n  local old_tgbot=${config[tgbot]}\n  local old_tgbot_token=${config[tgbot_token]}\n  local old_tgbot_admins=${config[tgbot_admins]}\n  while true; do\n    tgbot=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Enable Telegram Bot\" \\\n      --radiolist --noitem \"Enable Telegram Bot:\" $HEIGHT $WIDTH $CHOICE_HEIGHT \\\n      \"Enable\" \"$([[ \"${config[tgbot]}\" == 'ON' ]] && echo 'on' || echo 'off')\" \\\n      \"Disable\" \"$([[ \"${config[tgbot]}\" == 'OFF' ]] && echo 'on' || echo 'off')\" \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ $tgbot == 'Disable' ]]; then\n      config[tgbot]=OFF\n      update_config_file\n      return\n    fi\n    config[tgbot]=ON\n    while true; do\n      tgbot_token=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Telegram Bot Token\" \\\n        --inputbox \"Enter Telegram Bot Token:\" $HEIGHT $WIDTH \"${config[tgbot_token]}\" \\\n        3>&1 1>&2 2>&3)\n      if [[ $? -ne 0 ]]; then\n        break\n      fi\n      if [[ ! $tgbot_token =~ ${regex[tgbot_token]} ]]; then\n        message_box \"Invalid Input\" \"Invalid Telegram Bot Token\"\n        continue\n      fi \n      if ! curl -sSfL -m 3 \"https://api.telegram.org/bot${tgbot_token}/getMe\" >/dev/null 2>&1; then\n        message_box \"Invalid Input\" \"Telegram Bot Token is incorrect. Check it again.\"\n        continue\n      fi\n      config[tgbot_token]=$tgbot_token\n      while true; do\n        tgbot_admins=$(whiptail --clear --backtitle \"$BACKTITLE\" --title \"Telegram Bot Admins\" \\\n          --inputbox \"Enter Telegram Bot Admins (Seperate multiple admins by comma ',' without leading '@'):\" $HEIGHT $WIDTH \"${config[tgbot_admins]}\" \\\n          3>&1 1>&2 2>&3)\n        if [[ $? -ne 0 ]]; then\n          break\n        fi\n        if [[ ! $tgbot_admins =~ ${regex[tgbot_admins]} || $tgbot_admins =~ .+_$ || $tgbot_admins =~ .+_,.+ ]]; then\n          message_box \"Invalid Input\" \"Invalid Username\\nThe usernames must separated by ',' without leading '@' character or any extra space.\"\n          continue\n        fi\n        config[tgbot_admins]=$tgbot_admins\n        update_config_file\n        return\n      done\n    done\n  done\n  config[tgbot]=$old_tgbot\n  config[tgbot_token]=$old_tgbot_token\n  config[tgbot_admins]=$old_tgbot_admins\n}\n\nfunction backup_menu {\n  local backup_password\n  local result\n  backup_password=$(whiptail \\\n    --clear \\\n    --backtitle \"$BACKTITLE\" \\\n    --title \"Backup\" \\\n    --inputbox \"Choose a password for the backup file.\\nLeave blank if you do not wish to set a password for the backup file.\" \\\n    $HEIGHT $WIDTH \\\n    3>&1 1>&2 2>&3)\n  if [[ $? -ne 0 ]]; then\n    return\n  fi\n  if result=$(backup \"${backup_password}\" 2>&1); then\n    clear\n    echo \"Backup has been create and uploaded successfully.\"\n    echo \"You can download the backup file from here:\"\n    echo \"\"\n    echo \"${result}\"\n    echo \"\"\n    echo \"The URL is valid for 3 days.\"\n    echo\n    echo \"Press Enter to return ...\"\n    read\n    clear\n  else\n    message_box \"Backup Failed\" \"${result}\"\n  fi\n}\n\nfunction restore_backup_menu {\n  local backup_file\n  local backup_password\n  local result\n  while true; do\n    backup_file=$(whiptail \\\n      --clear \\\n      --backtitle \"$BACKTITLE\" \\\n      --title \"Restore Backup\" \\\n      --inputbox \"Enter backup file path or URL\" \\\n      $HEIGHT $WIDTH \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      break\n    fi\n    if [[ ! $backup_file =~ ${regex[file_path]} ]] && [[ ! $backup_file =~ ${regex[url]} ]]; then\n      message_box \"Invalid Backup path of URL\" \"Backup file path or URL is not valid.\"\n      continue\n    fi\n    backup_password=$(whiptail \\\n      --clear \\\n      --backtitle \"$BACKTITLE\" \\\n      --title \"Restore Backup\" \\\n      --inputbox \"Enter backup file password.\\nLeave blank if there is no password.\" \\\n      $HEIGHT $WIDTH \\\n      3>&1 1>&2 2>&3)\n    if [[ $? -ne 0 ]]; then\n      continue\n    fi\n    if result=$(restore \"${backup_file}\" \"${backup_password}\" 2>&1); then\n      parse_config_file\n      parse_users_file\n      build_config\n      update_config_file\n      update_users_file\n      message_box \"Backup Restore Successful\" \"Backup has been restored successfully.\"\n      args[restart]=true\n      break\n    else\n      message_box \"Backup Restore Failed\" \"${result}\"\n    fi\n  done\n}\n\nfunction restart_docker_compose {\n  ${docker_cmd} --project-directory ${config_path} -p ${compose_project} down --remove-orphans --timeout 2 || true\n  ${docker_cmd} --project-directory ${config_path} -p ${compose_project} up --build -d --remove-orphans --build\n}\n\nfunction restart_tgbot_compose {\n  ${docker_cmd} --project-directory ${config_path}/tgbot -p ${tgbot_project} down --remove-orphans --timeout 2 || true\n  ${docker_cmd} --project-directory ${config_path}/tgbot -p ${tgbot_project} up --build -d --remove-orphans --build\n}\n\nfunction restart_container {\n  if [[ -z \"$(${docker_cmd} ls | grep \"${path[compose]}\" | grep running || true)\" ]]; then\n    restart_docker_compose\n    return\n  fi\n  if ${docker_cmd} --project-directory ${config_path} -p ${compose_project} ps --services \"$1\" | grep \"$1\"; then\n    ${docker_cmd} --project-directory ${config_path} -p ${compose_project} restart --timeout 2 \"$1\"\n  fi\n}\n\nfunction warp_api {\n  local verb=$1\n  local resource=$2\n  local data=$3\n  local token=$4\n  local team_token=$5\n  local endpoint=https://api.cloudflareclient.com/v0a2158\n  local temp_file\n  local error\n  local command\n  local headers=(\n    \"User-Agent: okhttp/3.12.1\"\n    \"CF-Client-Version: a-6.10-2158\"\n    \"Content-Type: application/json\"\n  )\n  temp_file=$(mktemp)\n  if [[ -n ${token} ]]; then\n    headers+=(\"Authorization: Bearer ${token}\")\n  fi\n  if [[ -n ${team_token} ]]; then\n    headers+=(\"Cf-Access-Jwt-Assertion: ${team_token}\")\n  fi\n  command=\"curl -sLX ${verb} -m 3 -w '%{http_code}' -o ${temp_file} ${endpoint}${resource}\"\n  for header in \"${headers[@]}\"; do\n    command+=\" -H '${header}'\"\n  done\n  if [[ -n ${data} ]]; then\n    command+=\" -d '${data}'\"\n  fi\n  response_code=$(( $(eval \"${command}\" || true) ))\n  response_body=$(cat \"${temp_file}\")\n  rm -f \"${temp_file}\"\n  if [[ response_code -eq 0 ]]; then\n    return 1\n  fi\n  if [[ response_code -gt 399 ]]; then\n    error=$(echo \"${response_body}\" | jq -r '.errors[0].message' 2> /dev/null || true)\n    if [[ ${error} != 'null' ]]; then\n      echo \"${error}\"\n    fi\n    return 2\n  fi\n  echo \"${response_body}\"\n}\n\nfunction warp_create_account {\n  local response\n  docker run --rm -it -v \"${config_path}\":/data \"${image[wgcf]}\" register --config /data/wgcf-account.toml --accept-tos\n  if [[ $? -ne 0 || ! -r ${config_path}/wgcf-account.toml ]]; then\n    echo \"WARP account creation has been failed!\"\n    return 1\n  fi\n  config[warp_token]=$(cat ${config_path}/wgcf-account.toml | grep 'access_token' | cut -d \"'\" -f2)\n  config[warp_id]=$(cat ${config_path}/wgcf-account.toml | grep 'device_id' | cut -d \"'\" -f2)\n  config[warp_private_key]=$(cat ${config_path}/wgcf-account.toml | grep 'private_key' | cut -d \"'\" -f2)\n  rm -f ${config_path}/wgcf-account.toml\n  response=$(warp_api \"GET\" \"/reg/${config[warp_id]}\" \"\" \"${config[warp_token]}\")\n  if [[ $? -ne 0 ]]; then\n    if [[ -n ${response} ]]; then\n      echo \"${response}\"\n    fi\n    return 1\n  fi\n  config[warp_client_id]=$(echo \"${response}\" | jq -r '.config.client_id')\n  config[warp_interface_ipv4]=$(echo \"${response}\" | jq -r '.config.interface.addresses.v4')\n  config[warp_interface_ipv6]=$(echo \"${response}\" | jq -r '.config.interface.addresses.v6')\n  update_config_file\n}\n\nfunction warp_add_license {\n  local id=$1\n  local token=$2\n  local license=$3\n  local data\n  local response\n  data='{\"license\": \"'$license'\"}'\n  response=$(warp_api \"PUT\" \"/reg/${id}/account\" \"${data}\" \"${token}\")\n  if [[ $? -ne 0 ]]; then\n    if [[ -n ${response} ]]; then\n      echo \"${response}\"\n    fi\n    return 1\n  fi\n  config[warp_license]=${license}\n  update_config_file\n}\n\nfunction warp_delete_account {\n  local id=$1\n  local token=$2\n  warp_api \"DELETE\" \"/reg/${id}\" \"\" \"${token}\" >/dev/null 2>&1 || true\n  config[warp_private_key]=\"\"\n  config[warp_token]=\"\"\n  config[warp_id]=\"\"\n  config[warp_client_id]=\"\"\n  config[warp_interface_ipv4]=\"\"\n  config[warp_interface_ipv6]=\"\"\n  update_config_file\n}\n\nfunction warp_decode_reserved {\n  client_id=$1\n  reserved=$(echo \"${client_id}\" | base64 -d | xxd -p | fold -w2 | while read HEX; do printf '%d ' \"0x${HEX}\"; done | awk '{print \"[\"$1\", \"$2\", \"$3\"]\"}')\n  echo \"${reserved}\"\n}\n\nfunction check_reload {\n  declare -A restart\n  generate_config\n  for key in \"${!path[@]}\"; do\n    if [[ \"${md5[\"$key\"]}\" != $(get_md5 \"${path[$key]}\") ]]; then\n      restart[\"${service[\"$key\"]}\"]='true'\n      md5[\"$key\"]=$(get_md5 \"${path[$key]}\")\n    fi\n  done\n  if [[ \"${restart[tgbot]}\" == 'true' && \"${config[tgbot]}\" == 'ON' ]]; then\n    restart_tgbot_compose\n  fi\n  if [[ \"${config[tgbot]}\" == 'OFF' ]]; then\n    ${docker_cmd} --project-directory ${config_path}/tgbot -p ${tgbot_project} down --remove-orphans --timeout 2 >/dev/null 2>&1 || true\n  fi\n  if [[ \"${restart[compose]}\" == 'true' ]]; then\n    restart_docker_compose\n    return\n  fi\n  for key in \"${!restart[@]}\"; do\n    if [[ $key != 'none' && $key != 'tgbot' ]]; then\n      restart_container \"${key}\"\n    fi\n  done\n}\n\nfunction message_box {\n  local title=$1\n  local message=$2\n  whiptail \\\n    --clear \\\n    --backtitle \"$BACKTITLE\" \\\n    --title \"$title\" \\\n    --msgbox \"$message\" \\\n    $HEIGHT $WIDTH \\\n    3>&1 1>&2 2>&3\n}\n\nfunction get_md5 {\n  local file_path\n  file_path=$1\n  md5sum \"${file_path}\" 2>/dev/null | cut -f1 -d' ' || true\n}\n\nfunction generate_file_list {\n  path[config]=\"${config_path}/config\"\n  path[users]=\"${config_path}/users\"\n  path[compose]=\"${config_path}/docker-compose.yml\"\n  path[engine]=\"${config_path}/engine.conf\"\n  path[haproxy]=\"${config_path}/haproxy.cfg\"\n  path[certbot_deployhook]=\"${config_path}/certbot/deployhook.sh\"\n  path[certbot_dockerfile]=\"${config_path}/certbot/Dockerfile\"\n  path[certbot_startup]=\"${config_path}/certbot/startup.sh\"\n  path[server_pem]=\"${config_path}/certificate/server.pem\"\n  path[server_key]=\"${config_path}/certificate/server.key\"\n  path[server_crt]=\"${config_path}/certificate/server.crt\"\n  path[tgbot_script]=\"${config_path}/tgbot/tgbot.py\"\n  path[tgbot_dockerfile]=\"${config_path}/tgbot/Dockerfile\"\n  path[tgbot_compose]=\"${config_path}/tgbot/docker-compose.yml\"\n\n  service[config]='none'\n  service[users]='none'\n  service[compose]='compose'\n  service[engine]='engine'\n  service[haproxy]='haproxy'\n  service[certbot_deployhook]='certbot'\n  service[certbot_dockerfile]='compose'\n  service[certbot_startup]='certbot'\n  service[server_pem]='haproxy'\n  service[server_key]='engine'\n  service[server_crt]='engine'\n  service[tgbot_script]='tgbot'\n  service[tgbot_dockerfile]='compose'\n  service[tgbot_compose]='tgbot'\n\n  for key in \"${!path[@]}\"; do\n    md5[\"$key\"]=$(get_md5 \"${path[$key]}\")\n  done\n}\n\nfunction tune_kernel {\n  cat >/etc/sysctl.d/99-reality-ezpz.conf <<EOF\nfs.file-max = 200000\nnet.core.rmem_max = 67108864\nnet.core.wmem_max = 67108864\nnet.core.netdev_max_backlog = 250000\nnet.core.somaxconn = 4096\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_fin_timeout = 10\nnet.ipv4.tcp_keepalive_time = 600\nnet.ipv4.ip_local_port_range = 10000 65000\nnet.ipv4.tcp_max_syn_backlog = 8192\nnet.ipv4.tcp_max_tw_buckets = 5000\nnet.ipv4.tcp_fastopen = 3\nnet.ipv4.tcp_mem = 25600 51200 102400\nnet.ipv4.tcp_rmem = 4096 65536 67108864\nnet.ipv4.tcp_wmem = 4096 65536 67108864\nnet.ipv4.tcp_mtu_probing = 1\nnet.core.default_qdisc=fq\nnet.ipv4.tcp_congestion_control=bbr\nnet.netfilter.nf_conntrack_max=1000000\nEOF\n  sysctl -qp /etc/sysctl.d/99-reality-ezpz.conf >/dev/null 2>&1 || true\n}\n\nfunction configure_docker {\n  local docker_config=\"/etc/docker/daemon.json\"\n  local config_modified=false\n  local temp_file\n  temp_file=$(mktemp)\n  if [[ ! -f \"${docker_config}\" ]] || [[ ! -s \"${docker_config}\" ]]; then\n    echo '{\"experimental\": true, \"ip6tables\": true}' | jq . > \"${docker_config}\"\n    config_modified=true\n  else\n    if ! jq . \"${docker_config}\" &> /dev/null; then\n      echo '{\"experimental\": true, \"ip6tables\": true}' | jq . > \"${docker_config}\"\n      config_modified=true\n    else\n      if jq 'if .experimental != true or .ip6tables != true then .experimental = true | .ip6tables = true else . end' \"${docker_config}\" | jq . > \"${temp_file}\"; then\n        if ! cmp --silent \"${docker_config}\" \"${temp_file}\"; then\n          mv \"${temp_file}\" \"${docker_config}\"\n          config_modified=true\n        fi\n      fi\n    fi\n  fi\n  rm -f \"${temp_file}\"\n  if [[ \"${config_modified}\" = true ]] || ! systemctl is-active --quiet docker; then\n    sudo systemctl restart docker || true\n  fi\n}\n\nparse_args \"$@\" || show_help\nif [[ $EUID -ne 0 ]]; then\n    echo \"This script must be run as root.\"\n    exit 1\nfi\nif [[ ${args[backup]} == true ]]; then\n  if [[ -n ${args[backup_password]} ]]; then\n    backup_url=$(backup \"${args[backup_password]}\")\n  else\n    backup_url=$(backup)\n  fi\n  if [[ $? -eq 0 ]]; then\n    echo \"Backup created successfully. You can download the backup file from this address:\"\n    echo \"${backup_url}\"\n    echo \"The URL is valid for 3 days.\"\n    exit 0\n  fi\nfi\nif [[ -n ${args[restore]} ]]; then\n  if [[ -n ${args[backup_password]} ]]; then\n    restore \"${args[restore]}\" \"${args[backup_password]}\"\n  else\n    restore \"${args[restore]}\"\n  fi\n  if [[ $? -eq 0 ]]; then\n    args[restart]=true\n    echo \"Backup has been restored successfully.\"\n  fi\n  echo \"Press Enter to continue ...\"\n  read\n  clear\nfi\ngenerate_file_list\ninstall_packages\ninstall_docker\nconfigure_docker\nupgrade\nparse_config_file\nparse_users_file\nbuild_config\nupdate_config_file\nupdate_users_file\ntune_kernel\n\nif [[ ${args[menu]} == 'true' ]]; then\n  set +e\n  main_menu\n  set -e\nfi\nif [[ ${args[restart]} == 'true' ]]; then\n  restart_docker_compose\n  if [[ ${config[tgbot]} == 'ON' ]]; then\n    restart_tgbot_compose\n  fi\nfi\nif [[ -z \"$(${docker_cmd} ls | grep \"${path[compose]}\" | grep running || true)\" ]]; then\n  restart_docker_compose\nfi\nif [[ -z \"$(${docker_cmd} ls | grep \"${path[tgbot_compose]}\" | grep running || true)\" && ${config[tgbot]} == 'ON' ]]; then\n  restart_tgbot_compose\nfi\nif [[ ${args[server-config]} == true ]]; then\n  show_server_config\n  exit 0\nfi\nif [[ -n ${args[list_users]} ]]; then\n  for user in \"${!users[@]}\"; do\n    echo \"${user}\"\n  done\n  exit 0\nfi\nif [[ ${#users[@]} -eq 1 ]]; then\n  username=\"${!users[@]}\"\nfi\nif [[ -n ${args[show_config]} ]]; then\n  username=\"${args[show_config]}\"\n  if [[ -z \"${users[\"${username}\"]}\" ]]; then\n    echo 'User \"'\"$username\"'\" does not exists.'\n    exit 1\n  fi\nfi\nif [[ -n ${args[add_user]} ]]; then\n  username=\"${args[add_user]}\"\nfi\nif [[ -n $username ]]; then\n  print_client_configuration \"${username}\"\nfi\necho \"Command has been executed successfully!\"\nexit 0\n"
        },
        {
          "name": "tgbot.py",
          "type": "blob",
          "size": 7.1923828125,
          "content": "import os\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, MessageHandler, Filters, ConversationHandler\nimport re\nimport subprocess\nimport io\nimport qrcode\n\ntoken = os.environ['BOT_TOKEN']\nadmin = os.environ['BOT_ADMIN']\nupdater = Updater(token)\nusername_regex = re.compile(\"^[a-zA-Z0-9]+$\")\ncommand = 'bash <(curl -sL https://raw.githubusercontent.com/aleskxyz/reality-ezpz/master/reality-ezpz.sh) '\ndef get_users_ezpz():\n  local_command = command + '--list-users'\n  return run_command(local_command).split('\\n')[:-1]\ndef get_config_ezpz(username):\n  local_command = command + f\"--show-user {username} | grep -E '://|^\\\\{{\\\"dns\\\"'\"\n  return run_command(local_command).split('\\n')[:-1]\ndef delete_user_ezpz(username):\n  local_command = command + f'--delete-user {username}'\n  run_command(local_command)\n  return\ndef add_user_ezpz(username):\n  local_command = command + f'--add-user {username}'\n  run_command(local_command)\n  return\n\ndef run_command(command):\n  process = subprocess.Popen(['/bin/bash', '-c', command], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n  output, _ = process.communicate()\n  return output.decode()\n\ndef restricted(func):\n  def wrapped(update, context, *args, **kwargs):\n    username = None\n    if update.message:\n      username = update.message.chat.username\n    elif update.callback_query and update.callback_query.message:\n      username = update.callback_query.message.chat.username\n    admin_list = admin.split(',')\n    if username in admin_list:\n      return func(update, context, *args, **kwargs)\n    else:\n      context.bot.send_message(chat_id=update.effective_chat.id, text='You are not authorized to use this bot.')\n  return wrapped\n\n@restricted\ndef start(update, context):\n  commands_text = \"Reality-EZPZ User Management Bot\\n\\nChoose an option:\"\n  keyboard = [\n    [InlineKeyboardButton('Show User', callback_data='show_user')],\n    [InlineKeyboardButton('Add User', callback_data='add_user')],\n    [InlineKeyboardButton('Delete User', callback_data='delete_user')],\n  ]\n  reply_markup = InlineKeyboardMarkup(keyboard)\n  context.bot.send_message(chat_id=update.effective_chat.id, text=commands_text, reply_markup=reply_markup)\n\n@restricted\ndef users_list(update, context, text, callback):\n  keyboard = []\n  for user in get_users_ezpz():\n    keyboard.append([InlineKeyboardButton(user, callback_data=f'{callback}!{user}')])\n  keyboard.append([InlineKeyboardButton('Back', callback_data='start')])\n  reply_markup = InlineKeyboardMarkup(keyboard)\n  context.bot.send_message(chat_id=update.effective_chat.id, text=text, reply_markup=reply_markup)\n\n@restricted\ndef show_user(update, context, username):\n    keyboard = [[InlineKeyboardButton('Back', callback_data='show_user')]]\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    context.bot.send_message(chat_id=update.effective_chat.id, text=f'Config for \"{username}\":', parse_mode='HTML')\n    config_list = get_config_ezpz(username)\n    ipv6_pattern = r'\"server\":\"[0-9a-fA-F:]+\"'\n    \n    for config in config_list:\n        if config.endswith(\"-ipv6\") or re.search(ipv6_pattern, config):\n            config_text = f\"IPv6 Config:\\n<pre>{config}</pre>\"\n        else:\n            config_text = f\"<pre>{config}</pre>\"\n        \n        qr_img = qrcode.make(config)\n        bio = io.BytesIO()\n        qr_img.save(bio, 'PNG')\n        bio.seek(0)\n        \n        context.bot.send_photo(chat_id=update.effective_chat.id, photo=bio, caption=config_text, parse_mode='HTML', reply_markup=reply_markup)\n\n@restricted\ndef delete_user(update, context, username):\n  keyboard = []\n  if len(get_users_ezpz()) == 1:\n    text = 'You cannot delete the only user.\\nAt least one user is needed.\\nCreate a new user, then delete this one.'\n    keyboard.append([InlineKeyboardButton('Back', callback_data='start')])\n    reply_markup = InlineKeyboardMarkup(keyboard)\n    context.bot.send_message(chat_id=update.effective_chat.id, text=text, reply_markup=reply_markup)\n    return\n  text = f'Are you sure to delete \"{username}\"?'\n  keyboard.append([InlineKeyboardButton('Delete', callback_data=f'approve_delete!{username}')])\n  keyboard.append([InlineKeyboardButton('Cancel', callback_data='delete_user')])\n  reply_markup = InlineKeyboardMarkup(keyboard)\n  context.bot.send_message(chat_id=update.effective_chat.id, text=text, reply_markup=reply_markup)\n\n@restricted\ndef add_user(update, context):\n  text = 'Enter the username:'\n  keyboard = []\n  keyboard.append([InlineKeyboardButton('Cancel', callback_data='cancel')])\n  reply_markup = InlineKeyboardMarkup(keyboard)\n  context.user_data['expected_input'] = 'username'\n  context.bot.send_message(chat_id=update.effective_chat.id, text=text, reply_markup=reply_markup)\n\n@restricted\ndef approve_delete(update, context, username):\n  delete_user_ezpz(username)\n  text = f'User {username} has been deleted.'\n  keyboard = []\n  keyboard.append([InlineKeyboardButton('Back', callback_data='start')])\n  reply_markup = InlineKeyboardMarkup(keyboard)\n  context.bot.send_message(chat_id=update.effective_chat.id, text=text, reply_markup=reply_markup)\n\n@restricted\ndef cancel(update, context):\n  if 'expected_input' in context.user_data:\n    del context.user_data['expected_input']\n  start(update, context)\n\n@restricted\ndef button(update, context):\n  query = update.callback_query\n  query.answer()\n  response = query.data.split('!')\n  if len(response) == 1:\n    if response[0] == 'start':\n      start(update, context)\n    elif response[0] == 'cancel':\n      cancel(update, context)\n    elif response[0] == 'show_user':\n      users_list(update, context, 'Select user to view config:', 'show_user')\n    elif response[0] == 'delete_user':\n      users_list(update, context, 'Select user to delete:', 'delete_user')\n    elif response[0] == 'add_user':\n      add_user(update, context)\n    else:\n      context.bot.send_message(chat_id=update.effective_chat.id, text='Button pressed: {}'.format(response[0]))\n  if len(response) > 1:\n    if response[0] == 'show_user':\n      show_user(update, context, response[1])\n    if response[0] == 'delete_user':\n      delete_user(update, context, response[1])\n    if response[0] == 'approve_delete':\n      approve_delete(update, context, response[1])\n\n@restricted\ndef user_input(update, context):\n  if 'expected_input' in context.user_data:\n    expected_input = context.user_data['expected_input']\n    del context.user_data['expected_input']\n    if expected_input == 'username':\n      username = update.message.text\n      if username in get_users_ezpz():\n        update.message.reply_text(f'User \"{username}\" exists, try another username.')\n        add_user(update, context)\n        return\n      if not username_regex.match(username):\n        update.message.reply_text('Username can only contains A-Z, a-z and 0-9, try another username.')\n        add_user(update, context)\n        return\n      add_user_ezpz(username)\n      update.message.reply_text(f'User \"{username}\" is created.')\n      show_user(update, context, username)\n\nstart_handler = CommandHandler('start', start)\nbutton_handler = CallbackQueryHandler(button)\n\nupdater.dispatcher.add_handler(start_handler)\nupdater.dispatcher.add_handler(button_handler)\nupdater.dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, user_input))\n\nupdater.start_polling()\nupdater.idle()\n"
        }
      ]
    }
  ]
}