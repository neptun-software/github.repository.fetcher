{
  "metadata": {
    "timestamp": 1736568285321,
    "page": 181,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "21y4d/nmapAutomator",
      "stars": 2776,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.345703125,
          "content": "# Contributing Guidelines\n\n## Coding Standards\n\n`nmapAutomator` is 100% POSIX compatible, and should run with `/bin/sh`. To keep it compatible, please try to follow these Coding Standards:\n- Keep the current indentation and code structure. *You can use VSCode to automatically format it.*\n- For any variables/functions added, please use Camel Casing 'e.g. `newVariable`'.\n- For any output files, please use underscores `_` instead of spaces, and include the `${HOST}` in the name.\n- Enclose all variables in `${}` 'e.g. `${myVar}`'\n- Always quote the variables 'e.g. `echo \"${my_var}\"`', *unless you're doing shell-splitting.*\n- Always add a comment describing the general purpose of the code \n- Use POSIX commands where possible 'i.e. `awk`/`sed`', as some commands may not work with `sh` or older shells. *You may open an issue if you don't know how to write the command you need.*\n\nYou can check the POSIX tools (and the parameters and syntax they accept) in the [IEEE Std 1003.1-2017 Utilities specification](https://pubs.opengroup.org/onlinepubs/9699919799/idx/utilities.html), and the [IEEE Std 1003.1-2017 Built-ins specification](https://pubs.opengroup.org/onlinepubs/9699919799/idx/sbi.html).\n\nFurthermore, you can always re-use existing code, by looking for adding new recon options, by basing your pull request on existing options in the `reconRecommend()` function.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) 2021 21y4d\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.7861328125,
          "content": "# nmapAutomator\n\nA script you can run in the background!\n  \n![nmapAutomator](https://i.imgur.com/3cMJIPr.gif)\n  \n## Summary\n\nThe main goal for this script is to automate the process of enumeration & recon that is run every time, and instead focus our attention on real pentesting.  \n  \nThis will ensure two things:  \n1. Automate nmap scans. \n2. Always have some recon running in the background. \n\nOnce initial ports are found '*in 5-10 seconds*', we can start manually looking into those ports, and let the rest run in the background with no interaction from our side whatsoever.  \n\n## Features\n\n### Scans\n1. **Network** : Shows all live hosts in the host's network (~15 seconds)\n2. **Port**    : Shows all open ports (~15 seconds)\n3. **Script**  : Runs a script scan on found ports (~5 minutes)\n4. **Full**    : Runs a full range port scan, then runs a thorough scan on new ports (~5-10 minutes)\n5. **UDP**     : Runs a UDP scan \"requires sudo\" (~5 minutes)\n6. **Vulns**   : Runs CVE scan and nmap Vulns scan on all found ports (~5-15 minutes)\n7. **Recon**   : Suggests recon commands, then prompts to automatically run them\n8. **All**     : Runs all the scans (~20-30 minutes)\n\n*Note: This is a reconnaissance tool, and it does not perform any exploitation.*\n\n### Automatic Recon\nWith the `recon` option, nmapAutomator will automatically recommend and run the best recon tools for each found port.  \nIf a recommended tool is missing from your machine, nmapAutomator will suggest how to install it.\n\n### Runs on any shell\nnmapAutomator is 100% POSIX compatible, so it can run on any `sh` shell, and on any unix-based machine (*even a 10 YO router!*), which makes nmapAutomator ideal for lateral movement recon.\n\nIf you want to run nmapAutomator on a remote machine, simply download a static nmap binary from [this link](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/nmap), or with [static-get](https://github.com/minos-org/minos-static), and transfer it to the remote machine. You can then use `-s/--static-nmap` to specify the path to the static nmap binary.\n\n### Remote Mode (Beta)\nWith the `-r/--remote` flag nmapAutomator will run in Remote Mode, which is designed to run using POSIX shell commands only, without relying on any external tools.  \nRemote Mode is still under development. Only following scans currently work with `-r`:\n- [x] Network Scan (currently ping only)\n- [ ] Port Scan\n- [ ] Full Scan\n- [ ] UDP Scan\n- [ ] Recon Scan\n\n### Output\nnmapAutomator saves the output of each type of scan is saved into a separate file, under the output directory.  \nThe entire script output is also saved, which you can view with `less -r outputDir/nmapAutomator_host_type.txt`, or you can simply `cat` it.\n\n-----\n  \n## Requirements:\n[ffuf](https://github.com/ffuf/ffuf), which we can install with:\n```bash\nsudo apt update\nsudo apt install ffuf -y\n```\n\nOr [Gobuster](https://github.com/OJ/gobuster) '*v3.0 or higher*', which we can install with:  \n```bash\nsudo apt update\nsudo apt install gobuster -y\n```\n\nOther recon tools used within the script include:\n|[nmap Vulners](https://github.com/vulnersCom/nmap-vulners)|[sslscan](https://github.com/rbsec/sslscan)|[nikto](https://github.com/sullo/nikto)|[joomscan](https://github.com/rezasp/joomscan)|[wpscan](https://github.com/wpscanteam/wpscan)|\n|:-:|:-:|:-:|:-:|:-:|\n|[droopescan](https://github.com/droope/droopescan)|[smbmap](https://github.com/ShawnDEvans/smbmap)|[enum4linux](https://github.com/portcullislabs/enum4linux)|[dnsrecon](https://github.com/darkoperator/dnsrecon)|[odat](https://github.com/quentinhardy/odat)|\n|[smtp-user-enum](https://github.com/pentestmonkey/smtp-user-enum)|snmp-check|snmpwalk|ldapsearch||\n\n  \nMost of these should be installed by default in [Parrot OS](https://www.parrotsec.org) and [Kali Linux](https://www.kali.org).  \n*If any recon recommended tools are found to be missing, they will be automatically omitted, and the user will be notified.*\n  \n## Installation:\n```bash\ngit clone https://github.com/21y4d/nmapAutomator.git\nsudo ln -s $(pwd)/nmapAutomator/nmapAutomator.sh /usr/local/bin/\n```\n\n-----\n\n## Usage:\n```\n./nmapAutomator.sh -h\nUsage: nmapAutomator.sh -H/--host <TARGET-IP> -t/--type <TYPE>\nOptional: [-r/--remote <REMOTE MODE>] [-d/--dns <DNS SERVER>] [-o/--output <OUTPUT DIRECTORY>] [-s/--static-nmap <STATIC NMAP PATH>]\n\nScan Types:\n\tNetwork : Shows all live hosts in the host's network (~15 seconds)\n\tPort    : Shows all open ports (~15 seconds)\n\tScript  : Runs a script scan on found ports (~5 minutes)\n\tFull    : Runs a full range port scan, then runs a thorough scan on new ports (~5-10 minutes)\n\tUDP     : Runs a UDP scan \"requires sudo\" (~5 minutes)\n\tVulns   : Runs CVE scan and nmap Vulns scan on all found ports (~5-15 minutes)\n\tRecon   : Suggests recon commands, then prompts to automatically run them\n\tAll     : Runs all the scans (~20-30 minutes)\n```\n\n**Example scans**:\n```\n./nmapAutomator.sh --host 10.1.1.1 --type All\n./nmapAutomator.sh -H 10.1.1.1 -t Basic\n./nmapAutomator.sh -H academy.htb -t Recon -d 1.1.1.1\n./nmapAutomator.sh -H 10.10.10.10 -t network -s ./nmap\n```\n\n------\n\n## Upcoming Features\n- [x] Support URL/DNS - Thanks @KatsuragiCSL\n- [x] Add extensions fuzzing for http recon\n- [x] Add an nmap progress bar\n- [x] List missing tools in recon\n- [x] Add option to change output folder\n- [x] Save full script output to a file\n- [x] Improve performance and efficiency of the script - Thanks @caribpa\n- [x] Make nmapAutomater 100% POSIX compatible. - Massive Thanks to @caribpa\n- [x] Add network scanning type, so nmapAutomator can discover live hosts on the network.\n- [ ] Enable usage of multiple scan types in one scan.\n- [ ] Enable scanning of multiple hosts in one scan.\n- [ ] Fully implement Remote Mode on all scans\n\n\n**Feel free to send your pull requests :)**  \n*For any pull requests, please try to follow these [Contributing Guidelines](CONTRIBUTING.md).*\n"
        },
        {
          "name": "nmapAutomator.sh",
          "type": "blob",
          "size": 34.7255859375,
          "content": "#!/bin/sh\n#by @21y4d\n\n# Define ANSI color variables\nRED='\\033[0;31m'\nYELLOW='\\033[0;33m'\nGREEN='\\033[0;32m'\nNC='\\033[0m'\norigIFS=\"${IFS}\"\n\n# Start timer\nelapsedStart=\"$(date '+%H:%M:%S' | awk -F: '{print $1 * 3600 + $2 * 60 + $3}')\"\nREMOTE=false\n\n# Parse flags\nwhile [ $# -gt 0 ]; do\n        key=\"$1\"\n\n        case \"${key}\" in\n        -H | --host)\n                HOST=\"$2\"\n                shift\n                shift\n                ;;\n        -t | --type)\n                TYPE=\"$2\"\n                shift\n                shift\n                ;;\n        -d | --dns)\n                DNS=\"$2\"\n                shift\n                shift\n                ;;\n        -o | --output)\n                OUTPUTDIR=\"$2\"\n                shift\n                shift\n                ;;\n        -s | --static-nmap)\n                NMAPPATH=\"$2\"\n                shift\n                shift\n                ;;\n        -r | --remote)\n                REMOTE=true\n                shift\n                ;;\n        *)\n                POSITIONAL=\"${POSITIONAL} $1\"\n                shift\n                ;;\n        esac\ndone\nset -- ${POSITIONAL}\n\n# Legacy flags support, if run without -H/-t\nif [ -z \"${HOST}\" ]; then\n        HOST=\"$1\"\nfi\n\nif [ -z \"${TYPE}\" ]; then\n        TYPE=\"$2\"\nfi\n\n# Legacy types support, if quick/basic used\nif expr \"${TYPE}\" : '^\\([Qq]uick\\)$' >/dev/null; then\n        TYPE=\"Port\"\nelif expr \"${TYPE}\" : '^\\([Bb]asic\\)$' >/dev/null; then\n        TYPE=\"Script\"\nfi\n\n# Set DNS or default to system DNS\nif [ -n \"${DNS}\" ]; then\n        DNSSERVER=\"${DNS}\"\n        DNSSTRING=\"--dns-server=${DNSSERVER}\"\nelse\n        DNSSERVER=\"$(grep 'nameserver' /etc/resolv.conf | grep -v '#' | head -n 1 | awk {'print $NF'})\"\n        DNSSTRING=\"--system-dns\"\nfi\n\n# Set output dir or default to host-based dir\nif [ -z \"${OUTPUTDIR}\" ]; then\n        OUTPUTDIR=\"${HOST}\"\nfi\n\n# Set path to nmap binary or default to nmap in $PATH, or resort to --remote mode\nif [ -z \"${NMAPPATH}\" ] && type nmap >/dev/null 2>&1; then\n        NMAPPATH=\"$(type nmap | awk {'print $NF'})\"\nelif [ -n \"${NMAPPATH}\" ]; then\n        NMAPPATH=\"$(cd \"$(dirname ${NMAPPATH})\" && pwd -P)/$(basename ${NMAPPATH})\"\n        # Ensure static binary is executable and is nmap\n        if [ ! -x $NMAPPATH ]; then\n                printf \"${RED}\\nFile is not executable! Attempting chmod +x...${NC}\\n\"\n                chmod +x $NMAPPATH 2>/dev/null || (printf \"${RED}Could not chmod. Running in Remote mode...${NC}\\n\\n\" && REMOTE=true)\n        elif [ $($NMAPPATH -h | head -c4) != \"Nmap\" ]; then\n                printf \"${RED}\\nStatic binary does not appear to be Nmap! Running in Remote mode...${NC}\\n\\n\" && REMOTE=true\n        fi\n        printf \"${GREEN}\\nUsing static nmap binary at ${NMAPPATH}${NC}\\n\"\nelse\n        printf \"${RED}\\nNmap is not installed and -s is not used. Running in Remote mode...${NC}\\n\\n\" && REMOTE=true\nfi\n\n# Print usage menu and exit. Used when issues are encountered\n# No args needed\nusage() {\n        echo\n        printf \"${RED}Usage: $(basename $0) -H/--host ${NC}<TARGET-IP>${RED} -t/--type ${NC}<TYPE>${RED}\\n\"\n        printf \"${YELLOW}Optional: [-r/--remote ${NC}<REMOTE MODE>${YELLOW}] [-d/--dns ${NC}<DNS SERVER>${YELLOW}] [-o/--output ${NC}<OUTPUT DIRECTORY>${YELLOW}] [-s/--static-nmap ${NC}<STATIC NMAP PATH>${YELLOW}]\\n\\n\"\n        printf \"Scan Types:\\n\"\n        printf \"${YELLOW}\\tNetwork : ${NC}Shows all live hosts in the host's network ${YELLOW}(~15 seconds)\\n\"\n        printf \"${YELLOW}\\tPort    : ${NC}Shows all open ports ${YELLOW}(~15 seconds)\\n\"\n        printf \"${YELLOW}\\tScript  : ${NC}Runs a script scan on found ports ${YELLOW}(~5 minutes)\\n\"\n        printf \"${YELLOW}\\tFull    : ${NC}Runs a full range port scan, then runs a script scan on new ports ${YELLOW}(~5-10 minutes)\\n\"\n        printf \"${YELLOW}\\tUDP     : ${NC}Runs a UDP scan \\\"requires sudo\\\" ${YELLOW}(~5 minutes)\\n\"\n        printf \"${YELLOW}\\tVulns   : ${NC}Runs CVE scan and nmap Vulns scan on all found ports ${YELLOW}(~5-15 minutes)\\n\"\n        printf \"${YELLOW}\\tRecon   : ${NC}Suggests recon commands, then prompts to automatically run them\\n\"\n        printf \"${YELLOW}\\tAll     : ${NC}Runs all the scans ${YELLOW}(~20-30 minutes)\\n\"\n        printf \"${NC}\\n\"\n        exit 1\n}\n\n# Print initial header and set initial variables before scans start\n# No args needed\nheader() {\n        echo\n\n        # Print scan type\n        if expr \"${TYPE}\" : '^\\([Aa]ll\\)$' >/dev/null; then\n                printf \"${YELLOW}Running all scans on ${NC}${HOST}\"\n        else\n                printf \"${YELLOW}Running a ${TYPE} scan on ${NC}${HOST}\"\n        fi\n\n        if expr \"${HOST}\" : '^\\(\\([[:alnum:]-]\\{1,63\\}\\.\\)*[[:alpha:]]\\{2,6\\}\\)$' >/dev/null; then\n                urlIP=\"$(host -4 -W 1 ${HOST} ${DNSSERVER} 2>/dev/null | grep ${HOST} | head -n 1 | awk {'print $NF'})\"\n                if [ -n \"${urlIP}\" ]; then\n                        printf \"${YELLOW} with IP ${NC}${urlIP}\\n\\n\"\n                else\n                        printf \".. ${RED}Could not resolve IP of ${NC}${HOST}\\n\\n\"\n                fi\n        else\n                printf \"\\n\"\n        fi\n\n        if $REMOTE; then\n                printf \"${YELLOW}Running in Remote mode! Some scans will be limited.\\n\"\n        fi\n\n        # Set $subnet variable\n        if expr \"${HOST}\" : '^\\([0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\)$' >/dev/null; then\n                subnet=\"$(echo \"${HOST}\" | cut -d \".\" -f 1,2,3).0\"\n        fi\n\n        # Set $nmapType variable based on ping\n        kernel=\"$(uname -s)\"\n        checkPing=\"$(checkPing \"${urlIP:-$HOST}\")\"\n        nmapType=\"$(echo \"${checkPing}\" | head -n 1)\"\n\n        # Set if host is pingable 'for ping scans'\n        if expr \"${nmapType}\" : \".*-Pn$\" >/dev/null; then\n                pingable=false\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}No ping detected.. Will not use ping scans!\\n\"\n                printf \"${NC}\\n\"\n        else\n                pingable=true\n\n        fi\n\n        # OS Detection\n        ttl=\"$(echo \"${checkPing}\" | tail -n 1)\"\n        if [ \"${ttl}\" != \"nmap -Pn\" ]; then\n                osType=\"$(checkOS \"${ttl}\")\"\n                printf \"${NC}\\n\"\n                printf \"${GREEN}Host is likely running ${osType}\\n\"\n        fi\n\n        echo\n        echo\n}\n\n# Used Before and After each nmap scan, to keep found ports consistent across the script\n# $1 is $HOST\nassignPorts() {\n        # Set $commonPorts based on Port scan\n        if [ -f \"nmap/Port_$1.nmap\" ]; then\n                commonPorts=\"$(awk -vORS=, -F/ '/^[0-9]/{print $1}' \"nmap/Port_$1.nmap\" | sed 's/.$//')\"\n        fi\n\n        # Set $allPorts based on Full scan or both Port and Full scans\n        if [ -f \"nmap/Full_$1.nmap\" ]; then\n                if [ -f \"nmap/Port_$1.nmap\" ]; then\n                        allPorts=\"$(awk -vORS=, -F/ '/^[0-9]/{print $1}' \"nmap/Port_$1.nmap\" \"nmap/Full_$1.nmap\" | sed 's/.$//')\"\n                else\n                        allPorts=\"$(awk -vORS=, -F/ '/^[0-9]/{print $1}' \"nmap/Full_$1.nmap\" | sed 's/.$//')\"\n                fi\n        fi\n\n        # Set $udpPorts based on UDP scan\n        if [ -f \"nmap/UDP_$1.nmap\" ]; then\n                udpPorts=\"$(awk -vORS=, -F/ '/^[0-9]/{print $1}' \"nmap/UDP_$1.nmap\" | sed 's/.$//')\"\n                if [ \"${udpPorts}\" = \"Al\" ]; then\n                        udpPorts=\"\"\n                fi\n        fi\n}\n\n# Test whether the host is pingable, and return $nmapType and $ttl\n# $1 is $HOST\ncheckPing() {\n        # If ping is not returned within a second, then ping scan is disabled with -Pn\n        if [ $kernel = \"Linux\" ]; then TW=\"W\"; else TW=\"t\"; fi\n        pingTest=\"$(ping -c 1 -${TW} 1 \"$1\" 2>/dev/null | grep ttl)\"\n        if [ -z \"${pingTest}\" ]; then\n                echo \"${NMAPPATH} -Pn\"\n        else\n                echo \"${NMAPPATH}\"\n                if expr \"$1\" : '^\\([0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\)$' >/dev/null; then\n                        ttl=\"$(echo \"${pingTest}\" | cut -d \" \" -f 6 | cut -d \"=\" -f 2)\"\n                else\n                        ttl=\"$(echo \"${pingTest}\" | cut -d \" \" -f 7 | cut -d \"=\" -f 2)\"\n                fi\n                echo \"${ttl}\"\n        fi\n}\n\n# Detect OS based on $ttl\n# $1 is $ttl\ncheckOS() {\n        case \"$1\" in\n        25[456]) echo \"OpenBSD/Cisco/Oracle\" ;;\n        12[78]) echo \"Windows\" ;;\n        6[34]) echo \"Linux\" ;;\n        *) echo \"Unknown OS!\" ;;\n        esac\n}\n\n# Add any extra ports found in Full scan\n# No args needed\ncmpPorts() {\n        extraPorts=\"$(echo \",${allPorts},\" | sed 's/,\\('\"$(echo \"${commonPorts}\" | sed 's/,/,\\\\|/g')\"',\\)\\+/,/g; s/^,\\|,$//g')\"\n}\n\n# Print nmap progress bar\n# $1 is $scanType, $2 is $percent, $3 is $elapsed, $4 is $remaining\nprogressBar() {\n        [ -z \"${2##*[!0-9]*}\" ] && return 1\n        [ \"$(stty size | cut -d ' ' -f 2)\" -le 120 ] && width=50 || width=100\n        fill=\"$(printf \"%-$((width == 100 ? $2 : ($2 / 2)))s\" \"#\" | tr ' ' '#')\"\n        empty=\"$(printf \"%-$((width - (width == 100 ? $2 : ($2 / 2))))s\" \" \")\"\n        printf \"In progress: $1 Scan ($3 elapsed - $4 remaining)   \\n\"\n        printf \"[${fill}>${empty}] $2%% done   \\n\"\n        printf \"\\e[2A\"\n}\n\n# Calculate current progress bar status based on nmap stats (with --stats-every)\n# $1 is nmap command to be run, $2 is progress bar $refreshRate\nnmapProgressBar() {\n        refreshRate=\"${2:-1}\"\n        outputFile=\"$(echo $1 | sed -e 's/.*-oN \\(.*\\).nmap.*/\\1/').nmap\"\n        tmpOutputFile=\"${outputFile}.tmp\"\n\n        # Run the nmap command\n        if [ ! -e \"${outputFile}\" ]; then\n                $1 --stats-every \"${refreshRate}s\" >\"${tmpOutputFile}\" 2>&1 &\n        fi\n\n        # Keep checking nmap stats and calling progressBar() every $refreshRate\n        while { [ ! -e \"${outputFile}\" ] || ! grep -q \"Nmap done at\" \"${outputFile}\"; } && { [ ! -e \"${tmpOutputFile}\" ] || ! grep -i -q \"quitting\" \"${tmpOutputFile}\"; }; do\n                scanType=\"$(tail -n 2 \"${tmpOutputFile}\" 2>/dev/null | sed -ne '/elapsed/{s/.*undergoing \\(.*\\) Scan.*/\\1/p}')\"\n                percent=\"$(tail -n 2 \"${tmpOutputFile}\" 2>/dev/null | sed -ne '/% done/{s/.*About \\(.*\\)\\..*% done.*/\\1/p}')\"\n                elapsed=\"$(tail -n 2 \"${tmpOutputFile}\" 2>/dev/null | sed -ne '/elapsed/{s/Stats: \\(.*\\) elapsed.*/\\1/p}')\"\n                remaining=\"$(tail -n 2 \"${tmpOutputFile}\" 2>/dev/null | sed -ne '/remaining/{s/.* (\\(.*\\) remaining.*/\\1/p}')\"\n                progressBar \"${scanType:-No}\" \"${percent:-0}\" \"${elapsed:-0:00:00}\" \"${remaining:-0:00:00}\"\n                sleep \"${refreshRate}\"\n        done\n        printf \"\\033[0K\\r\\n\\033[0K\\r\\n\"\n\n        # Print final output, remove extra nmap noise\n        if [ -e \"${outputFile}\" ]; then\n                sed -n '/PORT.*STATE.*SERVICE/,/^# Nmap/H;${x;s/^\\n\\|\\n[^\\n]*\\n# Nmap.*//gp}' \"${outputFile}\" | awk '!/^SF(:|-).*$/' | grep -v 'service unrecognized despite'\n        else\n                cat \"${tmpOutputFile}\"\n        fi\n        rm -f \"${tmpOutputFile}\"\n}\n\n# Nmap scan for live hosts\nnetworkScan() {\n        printf \"${GREEN}---------------------Starting Network Scan---------------------\\n\"\n        printf \"${NC}\\n\"\n\n        origHOST=\"${HOST}\"\n        HOST=\"${urlIP:-$HOST}\"\n        if [ $kernel = \"Linux\" ]; then TW=\"W\"; else TW=\"t\"; fi\n\n        if ! $REMOTE; then\n                # Discover live hosts with nmap\n                nmapProgressBar \"${nmapType} -T4 --max-retries 1 --max-scan-delay 20 -n -sn -oN nmap/Network_${HOST}.nmap ${subnet}/24\"\n                printf \"${YELLOW}Found the following live hosts:${NC}\\n\\n\"\n                cat nmap/Network_${HOST}.nmap | grep -v '#' | grep \"$(echo $subnet | sed 's/..$//')\" | awk {'print $5'}\n        elif $pingable; then\n                # Discover live hosts with ping\n                echo >\"nmap/Network_${HOST}.nmap\"\n                for ip in $(seq 0 254); do\n                        (ping -c 1 -${TW} 1 \"$(echo $subnet | sed 's/..$//').$ip\" 2>/dev/null | grep 'stat' -A1 | xargs | grep -v ', 0.*received' | awk {'print $2'} >>\"nmap/Network_${HOST}.nmap\") &\n                done\n                wait\n                sed -i '/^$/d' \"nmap/Network_${HOST}.nmap\"\n                sort -t . -k 3,3n -k 4,4n \"nmap/Network_${HOST}.nmap\"\n        else\n                printf \"${YELLOW}No ping detected.. TCP Network Scan is not implemented yet in Remote mode.\\n${NC}\"\n        fi\n\n        HOST=\"${origHOST}\"\n\n        echo\n        echo\n        echo\n}\n\n# Port Nmap port scan\nportScan() {\n        printf \"${GREEN}---------------------Starting Port Scan-----------------------\\n\"\n        printf \"${NC}\\n\"\n\n        if ! $REMOTE; then\n                nmapProgressBar \"${nmapType} -T4 --max-retries 1 --max-scan-delay 20 --open -oN nmap/Port_${HOST}.nmap ${HOST} ${DNSSTRING}\"\n                assignPorts \"${HOST}\"\n        else\n                printf \"${YELLOW}Port Scan is not implemented yet in Remote mode.\\n${NC}\"\n        fi\n\n        echo\n        echo\n        echo\n}\n\n# Nmap version and default script scan on found ports\nscriptScan() {\n        printf \"${GREEN}---------------------Starting Script Scan-----------------------\\n\"\n        printf \"${NC}\\n\"\n\n        if ! $REMOTE; then\n                if [ -z \"${commonPorts}\" ]; then\n                        printf \"${YELLOW}No ports in port scan.. Skipping!\\n\"\n                else\n                        nmapProgressBar \"${nmapType} -sCV -p${commonPorts} --open -oN nmap/Script_${HOST}.nmap ${HOST} ${DNSSTRING}\" 2\n                fi\n\n                # Modify detected OS if Nmap detects a different OS\n                if [ -f \"nmap/Script_${HOST}.nmap\" ] && grep -q \"Service Info: OS:\" \"nmap/Script_${HOST}.nmap\"; then\n                        serviceOS=\"$(sed -n '/Service Info/{s/.* \\([^;]*\\);.*/\\1/p;q}' \"nmap/Script_${HOST}.nmap\")\"\n                        if [ \"${osType}\" != \"${serviceOS}\" ]; then\n                                osType=\"${serviceOS}\"\n                                printf \"${NC}\\n\"\n                                printf \"${NC}\\n\"\n                                printf \"${GREEN}OS Detection modified to: ${osType}\\n\"\n                                printf \"${NC}\\n\"\n                        fi\n                fi\n        else\n                printf \"${YELLOW}Script Scan is not supported in Remote mode.\\n${NC}\"\n        fi\n\n        echo\n        echo\n        echo\n}\n\n# Nmap scan on all ports\nfullScan() {\n        printf \"${GREEN}---------------------Starting Full Scan------------------------\\n\"\n        printf \"${NC}\\n\"\n\n        if ! $REMOTE; then\n                nmapProgressBar \"${nmapType} -p- --max-retries 1 --max-rate 500 --max-scan-delay 20 -T4 -v --open -oN nmap/Full_${HOST}.nmap ${HOST} ${DNSSTRING}\" 3\n                assignPorts \"${HOST}\"\n\n                # Nmap version and default script scan on found ports if Script scan was not run yet\n                if [ -z \"${commonPorts}\" ]; then\n                        echo\n                        echo\n                        printf \"${YELLOW}Making a script scan on all ports\\n\"\n                        printf \"${NC}\\n\"\n                        nmapProgressBar \"${nmapType} -sCV -p${allPorts} --open -oN nmap/Full_Extra_${HOST}.nmap ${HOST} ${DNSSTRING}\" 2\n                        assignPorts \"${HOST}\"\n                # Nmap version and default script scan if any extra ports are found\n                else\n                        cmpPorts\n                        if [ -z \"${extraPorts}\" ]; then\n                                echo\n                                echo\n                                allPorts=\"\"\n                                printf \"${YELLOW}No new ports\\n\"\n                                printf \"${NC}\\n\"\n                        else\n                                echo\n                                echo\n                                printf \"${YELLOW}Making a script scan on extra ports: $(echo \"${extraPorts}\" | sed 's/,/, /g')\\n\"\n                                printf \"${NC}\\n\"\n                                nmapProgressBar \"${nmapType} -sCV -p${extraPorts} --open -oN nmap/Full_Extra_${HOST}.nmap ${HOST} ${DNSSTRING}\" 2\n                                assignPorts \"${HOST}\"\n                        fi\n                fi\n        else\n                printf \"${YELLOW}Full Scan is not implemented yet in Remote mode.\\n${NC}\"\n        fi\n\n        echo\n        echo\n        echo\n}\n\n# Nmap UDP scan\nUDPScan() {\n        printf \"${GREEN}----------------------Starting UDP Scan------------------------\\n\"\n        printf \"${NC}\\n\"\n\n        if ! $REMOTE; then\n                # Ensure UDP scan runs with root priviliges\n                if [ \"${USER}\" != 'root' ]; then\n                        echo \"UDP needs to be run as root, running with sudo...\"\n                        sudo -v\n                        echo\n                fi\n\n                nmapProgressBar \"sudo ${nmapType} -sU --max-retries 1 --open --open -oN nmap/UDP_${HOST}.nmap ${HOST} ${DNSSTRING}\" 3\n                assignPorts \"${HOST}\"\n\n                # Nmap version and default script scan on found UDP ports\n                if [ -n \"${udpPorts}\" ]; then\n                        echo\n                        echo\n                        printf \"${YELLOW}Making a script scan on UDP ports: $(echo \"${udpPorts}\" | sed 's/,/, /g')\\n\"\n                        printf \"${NC}\\n\"\n                        if [ -f /usr/share/nmap/scripts/vulners.nse ]; then\n                                sudo -v\n                                nmapProgressBar \"sudo ${nmapType} -sCVU --script vulners --script-args mincvss=7.0 -p${udpPorts} --open -oN nmap/UDP_Extra_${HOST}.nmap ${HOST} ${DNSSTRING}\" 2\n                        else\n                                sudo -v\n                                nmapProgressBar \"sudo ${nmapType} -sCVU -p${udpPorts} --open -oN nmap/UDP_Extra_${HOST}.nmap ${HOST} ${DNSSTRING}\" 2\n                        fi\n                else\n                        echo\n                        echo\n                        printf \"${YELLOW}No UDP ports are open\\n\"\n                        printf \"${NC}\\n\"\n                fi\n        else\n                printf \"${YELLOW}UDP Scan is not implemented yet in Remote mode.\\n${NC}\"\n        fi\n\n        echo\n        echo\n        echo\n}\n\n# Nmap vulnerability detection script scan\nvulnsScan() {\n        printf \"${GREEN}---------------------Starting Vulns Scan-----------------------\\n\"\n        printf \"${NC}\\n\"\n\n        if ! $REMOTE; then\n                # Set ports to be scanned (common or all)\n                if [ -z \"${allPorts}\" ]; then\n                        portType=\"common\"\n                        ports=\"${commonPorts}\"\n                else\n                        portType=\"all\"\n                        ports=\"${allPorts}\"\n                fi\n\n                # Ensure the vulners script is available, then run it with nmap\n                if [ ! -f /usr/share/nmap/scripts/vulners.nse ]; then\n                        printf \"${RED}Please install 'vulners.nse' nmap script:\\n\"\n                        printf \"${RED}https://github.com/vulnersCom/nmap-vulners\\n\"\n                        printf \"${RED}\\n\"\n                        printf \"${RED}Skipping CVE scan!\\n\"\n                        printf \"${NC}\\n\"\n                else\n                        printf \"${YELLOW}Running CVE scan on ${portType} ports\\n\"\n                        printf \"${NC}\\n\"\n                        nmapProgressBar \"${nmapType} -sV --script vulners --script-args mincvss=7.0 -p${ports} --open -oN nmap/CVEs_${HOST}.nmap ${HOST} ${DNSSTRING}\" 3\n                        echo\n                fi\n\n                # Nmap vulnerability detection script scan\n                echo\n                printf \"${YELLOW}Running Vuln scan on ${portType} ports\\n\"\n                printf \"${YELLOW}This may take a while, depending on the number of detected services..\\n\"\n                printf \"${NC}\\n\"\n                nmapProgressBar \"${nmapType} -sV --script vuln -p${ports} --open -oN nmap/Vulns_${HOST}.nmap ${HOST} ${DNSSTRING}\" 3\n        else\n                printf \"${YELLOW}Vulns Scan is not supported in Remote mode.\\n${NC}\"\n        fi\n\n        echo\n        echo\n        echo\n}\n\n# Run reconRecommend(), ask user for tools to run, then run runRecon()\nrecon() {\n        IFS=\"\n\"\n\n        # Run reconRecommend()\n        reconRecommend \"${HOST}\" | tee \"nmap/Recon_${HOST}.nmap\"\n        allRecon=\"$(grep \"${HOST}\" \"nmap/Recon_${HOST}.nmap\" | cut -d \" \" -f 1 | sort | uniq)\"\n\n        # Detect any missing tools\n        for tool in ${allRecon}; do\n                if ! type \"${tool}\" >/dev/null 2>&1; then\n                        missingTools=\"$(echo ${missingTools} ${tool} | awk '{$1=$1};1')\"\n                fi\n        done\n\n        # Exclude missing tools, and print help for installing them\n        if [ -n \"${missingTools}\" ]; then\n                printf \"${RED}Missing tools: ${NC}${missingTools}\\n\"\n                printf \"\\n${RED}You can install with:\\n\"\n                printf \"${YELLOW}sudo apt install ${missingTools} -y\\n\"\n                printf \"${NC}\\n\\n\"\n\n                availableRecon=\"$(echo \"${allRecon}\" | tr \" \" \"\\n\" | awk -vORS=', ' '!/'\"$(echo \"${missingTools}\" | tr \" \" \"|\")\"'/' | sed 's/..$//')\"\n        else\n                availableRecon=\"$(echo \"${allRecon}\" | tr \"\\n\" \" \" | sed 's/\\ /,\\ /g' | sed 's/..$//')\"\n        fi\n\n        secs=30\n        count=0\n\n        # Ask user for which recon tools to run, default to All if no answer is detected in 30s\n        if [ -n \"${availableRecon}\" ]; then\n                while [ \"${reconCommand}\" != \"!\" ]; do\n                        printf \"${YELLOW}\\n\"\n                        printf \"Which commands would you like to run?${NC}\\nAll (Default), ${availableRecon}, Skip <!>\\n\\n\"\n                        while [ ${count} -lt ${secs} ]; do\n                                tlimit=$((secs - count))\n                                printf \"\\033[2K\\rRunning Default in (${tlimit})s: \"\n\n                                # Waits 1 second for user's input - POSIX read -t\n                                reconCommand=\"$(sh -c '{ { sleep 1; kill -sINT $$; } & }; exec head -n 1')\"\n                                count=$((count + 1))\n                                [ -n \"${reconCommand}\" ] && break\n                        done\n                        if expr \"${reconCommand}\" : '^\\([Aa]ll\\)$' >/dev/null || [ -z \"${reconCommand}\" ]; then\n                                runRecon \"${HOST}\" \"All\"\n                                reconCommand=\"!\"\n                        elif expr \" ${availableRecon},\" : \".* ${reconCommand},\" >/dev/null; then\n                                runRecon \"${HOST}\" \"${reconCommand}\"\n                                reconCommand=\"!\"\n                        elif [ \"${reconCommand}\" = \"Skip\" ] || [ \"${reconCommand}\" = \"!\" ]; then\n                                reconCommand=\"!\"\n                                echo\n                                echo\n                                echo\n                        else\n                                printf \"${NC}\\n\"\n                                printf \"${RED}Incorrect choice!\\n\"\n                                printf \"${NC}\\n\"\n                        fi\n                done\n        else\n                printf \"${YELLOW}No Recon Recommendations found...\\n\"\n                printf \"${NC}\\n\\n\\n\"\n        fi\n\n        IFS=\"${origIFS}\"\n}\n\n# Recommend recon tools/commands to be run on found ports\nreconRecommend() {\n        printf \"${GREEN}---------------------Recon Recommendations---------------------\\n\"\n        printf \"${NC}\\n\"\n\n        IFS=\"\n\"\n\n        # Set $ports and $file variables\n        if [ -f \"nmap/Full_Extra_${HOST}.nmap\" ]; then\n                ports=\"${allPorts}\"\n                file=\"$(cat \"nmap/Script_${HOST}.nmap\" \"nmap/Full_Extra_${HOST}.nmap\" | grep \"open\" | grep -v \"#\" | sort | uniq)\"\n        elif [ -f \"nmap/Script_${HOST}.nmap\" ]; then\n                ports=\"${commonPorts}\"\n                file=\"$(grep \"open\" \"nmap/Script_${HOST}.nmap\" | grep -v \"#\")\"\n\n        fi\n\n        # SMTP recon\n        if echo \"${file}\" | grep -q \"25/tcp\"; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}SMTP Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"smtp-user-enum -U /usr/share/wordlists/metasploit/unix_users.txt -t \\\"${HOST}\\\" | tee \\\"recon/smtp_user_enum_${HOST}.txt\\\"\"\n                echo\n        fi\n\n        # DNS Recon\n        if echo \"${file}\" | grep -q \"53/tcp\" && [ -n \"${DNSSERVER}\" ]; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}DNS Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"host -l \\\"${HOST}\\\" \\\"${DNSSERVER}\\\" | tee \\\"recon/hostname_${HOST}.txt\\\"\"\n                echo \"dnsrecon -r \\\"${subnet}/24\\\" -n \\\"${DNSSERVER}\\\" | tee \\\"recon/dnsrecon_${HOST}.txt\\\"\"\n                echo \"dnsrecon -r 127.0.0.0/24 -n \\\"${DNSSERVER}\\\" | tee \\\"recon/dnsrecon-local_${HOST}.txt\\\"\"\n                echo \"dig -x \\\"${HOST}\\\" @${DNSSERVER} | tee \\\"recon/dig_${HOST}.txt\\\"\"\n                echo\n        fi\n\n        # Web recon\n        if echo \"${file}\" | grep -i -q http; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}Web Servers Recon:\\n\"\n                printf \"${NC}\\n\"\n\n                # HTTP recon\n                for line in ${file}; do\n                        if echo \"${line}\" | grep -i -q http; then\n                                port=\"$(echo \"${line}\" | cut -d \"/\" -f 1)\"\n                                if echo \"${line}\" | grep -q ssl/http; then\n                                        urlType='https://'\n                                        echo \"sslscan \\\"${HOST}\\\" | tee \\\"recon/sslscan_${HOST}_${port}.txt\\\"\"\n                                        echo \"nikto -host \\\"${urlType}${HOST}:${port}\\\" -ssl | tee \\\"recon/nikto_${HOST}_${port}.txt\\\"\"\n                                else\n                                        urlType='http://'\n                                        echo \"nikto -host \\\"${urlType}${HOST}:${port}\\\" | tee \\\"recon/nikto_${HOST}_${port}.txt\\\"\"\n                                fi\n                                if type ffuf >/dev/null 2>&1; then\n                                        extensions=\"$(echo 'index' >./index && ffuf -s -w ./index:FUZZ -mc '200,302' -e '.asp,.aspx,.html,.jsp,.php' -u \"${urlType}${HOST}:${port}/FUZZ\" 2>/dev/null | awk -vORS=, -F 'index' '{print $2}' | sed 's/.$//' && rm ./index)\"\n                                        echo \"ffuf -ic -w /usr/share/wordlists/dirb/common.txt -e '${extensions}' -u \\\"${urlType}${HOST}:${port}/FUZZ\\\" | tee \\\"recon/ffuf_${HOST}_${port}.txt\\\"\"\n                                else\n                                        extensions=\"$(echo 'index' >./index && gobuster dir -w ./index -t 30 -qnkx '.asp,.aspx,.html,.jsp,.php' -s '200,302' -u \"${urlType}${HOST}:${port}\" 2>/dev/null | awk -vORS=, -F 'index' '{print $2}' | sed 's/.$//' && rm ./index)\"\n                                        echo \"gobuster dir -w /usr/share/wordlists/dirb/common.txt -t 30 -ekx '${extensions}' -u \\\"${urlType}${HOST}:${port}\\\" -o \\\"recon/gobuster_${HOST}_${port}.txt\\\"\"\n                                fi\n                                echo\n                        fi\n                done\n                # CMS recon\n                if [ -f \"nmap/Script_${HOST}.nmap\" ]; then\n                        cms=\"$(grep http-generator \"nmap/Script_${HOST}.nmap\" | cut -d \" \" -f 2)\"\n                        if [ -n \"${cms}\" ]; then\n                                for line in ${cms}; do\n                                        port=\"$(sed -n 'H;x;s/\\/.*'\"${line}\"'.*//p' \"nmap/Script_${HOST}.nmap\")\"\n\n                                        # case returns 0 by default (no match), so ! case returns 1\n                                        if ! case \"${cms}\" in Joomla | WordPress | Drupal) false ;; esac then\n                                                printf \"${NC}\\n\"\n                                                printf \"${YELLOW}CMS Recon:\\n\"\n                                                printf \"${NC}\\n\"\n                                        fi\n                                        case \"${cms}\" in\n                                        Joomla!) echo \"joomscan --url \\\"${HOST}:${port}\\\" | tee \\\"recon/joomscan_${HOST}_${port}.txt\\\"\" ;;\n                                        WordPress) echo \"wpscan --url \\\"${HOST}:${port}\\\" --enumerate p | tee \\\"recon/wpscan_${HOST}_${port}.txt\\\"\" ;;\n                                        Drupal) echo \"droopescan scan drupal -u \\\"${HOST}:${port}\\\" | tee \\\"recon/droopescan_${HOST}_${port}.txt\\\"\" ;;\n                                        esac\n                                done\n                        fi\n                fi\n        fi\n\n        # SNMP recon\n        if [ -f \"nmap/UDP_Extra_${HOST}.nmap\" ] && grep -q \"161/udp.*open\" \"nmap/UDP_Extra_${HOST}.nmap\"; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}SNMP Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"snmp-check \\\"${HOST}\\\" -c public | tee \\\"recon/snmpcheck_${HOST}.txt\\\"\"\n                echo \"snmpwalk -Os -c public -v1 \\\"${HOST}\\\" | tee \\\"recon/snmpwalk_${HOST}.txt\\\"\"\n                echo\n        fi\n\n        # LDAP recon\n        if echo \"${file}\" | grep -q \"389/tcp\"; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}ldap Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"ldapsearch -x -h \\\"${HOST}\\\" -s base | tee \\\"recon/ldapsearch_${HOST}.txt\\\"\"\n                echo \"ldapsearch -x -h \\\"${HOST}\\\" -b \\\"\\$(grep rootDomainNamingContext \\\"recon/ldapsearch_${HOST}.txt\\\" | cut -d ' ' -f2)\\\" | tee \\\"recon/ldapsearch_DC_${HOST}.txt\\\"\"\n                echo \"nmap -Pn -p 389 --script ldap-search --script-args 'ldap.username=\\\"\\$(grep rootDomainNamingContext \\\"recon/ldapsearch_${HOST}.txt\\\" | cut -d \\\\\" \\\\\" -f2)\\\"' \\\"${HOST}\\\" -oN \\\"recon/nmap_ldap_${HOST}.txt\\\"\"\n                echo\n        fi\n\n        # SMB recon\n        if echo \"${file}\" | grep -q \"445/tcp\"; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}SMB Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"smbmap -H \\\"${HOST}\\\" | tee \\\"recon/smbmap_${HOST}.txt\\\"\"\n                echo \"smbclient -L \\\"//${HOST}/\\\" -U \\\"guest\\\"% | tee \\\"recon/smbclient_${HOST}.txt\\\"\"\n                if [ \"${osType}\" = \"Windows\" ]; then\n                        echo \"nmap -Pn -p445 --script vuln -oN \\\"recon/SMB_vulns_${HOST}.txt\\\" \\\"${HOST}\\\"\"\n                elif [ \"${osType}\" = \"Linux\" ]; then\n                        echo \"enum4linux -a \\\"${HOST}\\\" | tee \\\"recon/enum4linux_${HOST}.txt\\\"\"\n                fi\n                echo\n        elif echo \"${file}\" | grep -q \"139/tcp\" && [ \"${osType}\" = \"Linux\" ]; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}SMB Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"enum4linux -a \\\"${HOST}\\\" | tee \\\"recon/enum4linux_${HOST}.txt\\\"\"\n                echo\n        fi\n\n        # Oracle DB recon\n        if echo \"${file}\" | grep -q \"1521/tcp\"; then\n                printf \"${NC}\\n\"\n                printf \"${YELLOW}Oracle Recon:\\n\"\n                printf \"${NC}\\n\"\n                echo \"odat sidguesser -s \\\"${HOST}\\\" -p 1521\"\n                echo \"odat passwordguesser -s \\\"${HOST}\\\" -p 1521 -d XE --accounts-file accounts/accounts-multiple.txt\"\n                echo\n        fi\n\n        IFS=\"${origIFS}\"\n\n        echo\n        echo\n        echo\n}\n\n# Run chosen recon commands\nrunRecon() {\n        echo\n        echo\n        echo\n        printf \"${GREEN}---------------------Running Recon Commands--------------------\\n\"\n        printf \"${NC}\\n\"\n\n        IFS=\"\n\"\n\n        mkdir -p recon/\n\n        if [ \"$2\" = \"All\" ]; then\n                reconCommands=\"$(grep \"${HOST}\" \"nmap/Recon_${HOST}.nmap\")\"\n        else\n                reconCommands=\"$(grep \"${HOST}\" \"nmap/Recon_${HOST}.nmap\" | grep \"$2\")\"\n        fi\n\n        # Run each line\n        for line in ${reconCommands}; do\n                currentScan=\"$(echo \"${line}\" | cut -d ' ' -f 1)\"\n                fileName=\"$(echo \"${line}\" | awk -F \"recon/\" '{print $2}')\"\n                if [ -n \"${fileName}\" ] && [ ! -f recon/\"${fileName}\" ]; then\n                        printf \"${NC}\\n\"\n                        printf \"${YELLOW}Starting ${currentScan} scan\\n\"\n                        printf \"${NC}\\n\"\n                        eval \"${line}\"\n                        printf \"${NC}\\n\"\n                        printf \"${YELLOW}Finished ${currentScan} scan\\n\"\n                        printf \"${NC}\\n\"\n                        printf \"${YELLOW}=========================\\n\"\n                fi\n        done\n\n        IFS=\"${origIFS}\"\n\n        echo\n        echo\n        echo\n}\n\n# Print footer with total elapsed time\nfooter() {\n\n        printf \"${GREEN}---------------------Finished all scans------------------------\\n\"\n        printf \"${NC}\\n\\n\"\n\n        elapsedEnd=\"$(date '+%H:%M:%S' | awk -F: '{print $1 * 3600 + $2 * 60 + $3}')\"\n        elapsedSeconds=$((elapsedEnd - elapsedStart))\n\n        if [ ${elapsedSeconds} -gt 3600 ]; then\n                hours=$((elapsedSeconds / 3600))\n                minutes=$(((elapsedSeconds % 3600) / 60))\n                seconds=$(((elapsedSeconds % 3600) % 60))\n                printf \"${YELLOW}Completed in ${hours} hour(s), ${minutes} minute(s) and ${seconds} second(s)\\n\"\n        elif [ ${elapsedSeconds} -gt 60 ]; then\n                minutes=$(((elapsedSeconds % 3600) / 60))\n                seconds=$(((elapsedSeconds % 3600) % 60))\n                printf \"${YELLOW}Completed in ${minutes} minute(s) and ${seconds} second(s)\\n\"\n        else\n                printf \"${YELLOW}Completed in ${elapsedSeconds} seconds\\n\"\n        fi\n        printf \"${NC}\\n\"\n}\n\n# Choose run type based on chosen flags\nmain() {\n        assignPorts \"${HOST}\"\n\n        header\n\n        case \"${TYPE}\" in\n        [Nn]etwork) networkScan \"${HOST}\" ;;\n        [Pp]ort) portScan \"${HOST}\" ;;\n        [Ss]cript)\n                [ ! -f \"nmap/Port_${HOST}.nmap\" ] && portScan \"${HOST}\"\n                scriptScan \"${HOST}\"\n                ;;\n        [Ff]ull) fullScan \"${HOST}\" ;;\n        [Uu]dp) UDPScan \"${HOST}\" ;;\n        [Vv]ulns)\n                [ ! -f \"nmap/Port_${HOST}.nmap\" ] && portScan \"${HOST}\"\n                vulnsScan \"${HOST}\"\n                ;;\n        [Rr]econ)\n                [ ! -f \"nmap/Port_${HOST}.nmap\" ] && portScan \"${HOST}\"\n                [ ! -f \"nmap/Script_${HOST}.nmap\" ] && scriptScan \"${HOST}\"\n                recon \"${HOST}\"\n                ;;\n        [Aa]ll)\n                portScan \"${HOST}\"\n                scriptScan \"${HOST}\"\n                fullScan \"${HOST}\"\n                UDPScan \"${HOST}\"\n                vulnsScan \"${HOST}\"\n                recon \"${HOST}\"\n                ;;\n        esac\n\n        footer\n}\n\n# Ensure host and type are passed as arguments\nif [ -z \"${TYPE}\" ] || [ -z \"${HOST}\" ]; then\n        usage\nfi\n\n# Ensure $HOST is an IP or a URL\nif ! expr \"${HOST}\" : '^\\([0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\)$' >/dev/null && ! expr \"${HOST}\" : '^\\(\\([[:alnum:]-]\\{1,63\\}\\.\\)*[[:alpha:]]\\{2,6\\}\\)$' >/dev/null; then\n        printf \"${RED}\\n\"\n        printf \"${RED}Invalid IP or URL!\\n\"\n        usage\nfi\n\n# Ensure selected scan type is among available choices, then run the selected scan\nif ! case \"${TYPE}\" in [Nn]etwork | [Pp]ort | [Ss]cript | [Ff]ull | UDP | udp | [Vv]ulns | [Rr]econ | [Aa]ll) false ;; esac then\n        mkdir -p \"${OUTPUTDIR}\" && cd \"${OUTPUTDIR}\" && mkdir -p nmap/ || usage\n        main | tee \"nmapAutomator_${HOST}_${TYPE}.txt\"\nelse\n        printf \"${RED}\\n\"\n        printf \"${RED}Invalid Type!\\n\"\n        usage\nfi\n"
        }
      ]
    }
  ]
}