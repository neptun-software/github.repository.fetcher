{
  "metadata": {
    "timestamp": 1736568796720,
    "page": 937,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk0OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rehiy/dnspod-shell",
      "stars": 1066,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "*.log\n.DS_Store\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.955078125,
          "content": "# ArDNSPod\n\n基于 DNSPod 用户 API 实现的纯 Shell 动态域名客户端。\n\n- IPv4 优先适配网卡地址，无法获得合法外网地址则从*第三方*接口获取地址，依然失败则使用`DNSPod`接口自动更新\n- IPv6 优先适配网卡地址，无法获得合法外网地址则从*第三方*接口获取地址，依然失败则退出\n- IP地址接口项目源码参见 https://github.com/rehiy/docker-geoip-api\n\n**官方DDNS接口已支持设置IPv6，如有兼容问题请使用`v6.1`分支版本**\n\n# 使用方法\n\n- 编辑`ddnspod.sh`，分别修改`/your_real_path/ardnspod`、`arToken`和`arDdnsCheck`为真实信息\n\n- 运行`ddnspod.sh`，开启循环更新任务；建议将此脚本支持添加到计划任务；\n\n- 成功运行后，结果如下所示：\n\n```\n=== Check test.rehi.org ===\nFetching Host Ip\n> Host Ip: Auto\n> Record Type: A\nFetching RecordId\n> Record Id: 998534425\nUpdating Record value\n> arDdnsUpdate - 1.2.3.4\n```\n\n### 小提示\n\n- 如需单文件运行，参考`ddnspod.sh`中的配置项，添加到`ardnspod`底部，直接运行`ardnspod`即可\n\n```\necho \"arToken=12345,7676f344eaeaea9074c123451234512d\" >> ./ardnspod\necho \"arDdnsCheck test.org subdomain\" >> ./ardnspod\n```\n\n# 最近更新\n\n2023/8/5\n\n- 根据记录Id缓存本地IP\n\n2023/7/22\n\n- Bug fix: 当需要替换根域名时, 如果传入 @ `(如 @.domain.xx)`, 会错误得到 `*.domain.xx` 的结果 `(A记录设置了*的话)`, 导致更新失败. 修改后在传入 `@` 作为子域名时, 直接请求根域名的结果\n\n2023/5/24\n\n- 恢复支持变更检测\n\n2022/11/24\n\n- 支持指定网卡\n- 增加 arRequest 方法，实现 curl/wget 封装\n\n2022/03/11\n\n- 改用ddns接口更新数据\n- ipv4 先从本机获取，若没有合法地址，则使用dnspod接口填充IP\n- ipv6 本机获取难度太大，且错误率高，改为直接从外部接口获取地址\n\n2021/11/25\n\n- 优先选择剩余时间最长的ipv6地址 [@kaedeair](https://github.com/kaedeair/dnspod-shell)\n\n2021/3/3\n\n- 强化获取IP结果检测\n- 优化部分判断逻辑\n- 优化消息输出\n\n2021/2/8\n\n- 添加 IPv6 支持\n- 优化流程，减少 API 调用次数\n- 完善出错提示\n\n2020/8/5\n\n- 修复 `get the wrong recordID` @C-Y-X\n\n2020/1/1\n\n- 适配新版 API（2019-11-26）\n- 当`wget`不存在时，尝试使用`curl`提交\n- 由于`readlink`不可靠，更改为手动设置路径\n- 当无法从本地网卡获得外网 ip 时，尝试从外部 api 获取\n\n2015/2/24\n\n- 增加 token 鉴权方式 (by wbchn)\n\n2015/7/7\n\n- 使用 D+服务获取域名解析\n\n2016/2/25\n\n- 增加配置文件，分离脚本与配置，适配内网。\n- 加入 Mac 支持\n- sed 脚本 POSIX 化，可跨平台\n\n2016/3/23\n\n- 进一步 POSIX 化，支持 Mac 和大部分 Linux 发行版\n- 更改配置文件格式\n\n2015/7/23\n\n- 代码托管到 github\n\n2013/03/28\n\n- 稳定版发布，同时被收录到官方插件列表\n\n2011/07/03\n\n- 小范围测试版发布\n\n# 共同维护者\n\n请参阅 <https://github.com/rehiy/dnspod-shell/graphs/contributors>\n"
        },
        {
          "name": "ardnspod",
          "type": "blob",
          "size": 11.3974609375,
          "content": "#!/bin/sh\n#\n\n###################################################################\n# AnripDdns v6.4.0\n#\n# Dynamic DNS using DNSPod API\n#\n# Author: Rehiy, https://github.com/rehiy\n#                https://www.rehiy.com/?s=dnspod\n#\n# Collaborators: https://github.com/rehiy/dnspod-shell/graphs/contributors\n#\n# Usage: please refer to `ddnspod.sh`\n#\n################################################################### params ##\n\nexport arToken\n\n# The url to be used for querying public ip address.\n\nexport arIp4QueryUrl=\"http://ipv4.rehi.org/ip\"\nexport arIp6QueryUrl=\"http://ipv6.rehi.org/ip\"\n\n# The temp file to store the last record ip\n\nexport arLastRecordFile=/tmp/ardnspod_last_record\n\n# The error code to return when a ddns record is not changed\n# By default, report unchanged event as success\n\nexport arErrCodeUnchanged=0\n\n################################################################### logger ##\n\n# Output log to stderr\n\narLog() {\n\n    >&2 echo \"$@\"\n\n}\n\n################################################################### http client ##\n\n# Use curl or wget open url\n# Args: url postdata\n\narRequest() {\n\n    local url=\"$1\"\n    local data=\"$2\"\n\n    local params=\"\"\n    local agent=\"AnripDdns/6.4.0(wang@rehiy.com)\"\n\n    if type curl >/dev/null 2>&1; then\n        if echo $url | grep -q https; then\n            params=\"$params -k\"\n        fi\n        if [ -n \"$data\" ]; then\n            params=\"$params -d $data\"\n        fi\n        curl -s -A \"$agent\" $params $url\n        return $?\n    fi\n\n    if type wget >/dev/null 2>&1; then\n        if echo $url | grep -q https; then\n            params=\"$params --no-check-certificate\"\n        fi\n        if [ -n \"$data\" ]; then\n            params=\"$params --post-data $data\"\n        fi\n        wget -qO- -U \"$agent\" $params $url\n        return $?\n    fi\n\n    return 1\n\n}\n\n################################################################### ipv4 util ##\n\n# Get regular expression for IPv4 LAN addresses\n\narLanIp4() {\n\n    local lanIps=\"^$\"\n\n    lanIps=\"$lanIps|(^10\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"            # RFC1918\n    lanIps=\"$lanIps|(^100\\.(6[4-9]|[7-9][0-9])\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"  # RFC6598 100.64.x.x - 100.99.x.x\n    lanIps=\"$lanIps|(^100\\.1([0-1][0-9]|2[0-7])\\.[0-9]{1,3}\\.[0-9]{1,3}$)\" # RFC6598 100.100.x.x - 100.127.x.x\n    lanIps=\"$lanIps|(^127\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"           # RFC1122\n    lanIps=\"$lanIps|(^169\\.254\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"                  # RFC3927\n    lanIps=\"$lanIps|(^172\\.(1[6-9]|2[0-9]|3[0-1])\\.[0-9]{1,3}\\.[0-9]{1,3}$)\" # RFC1918\n    lanIps=\"$lanIps|(^192\\.0\\.2\\.[0-9]{1,3}$)\"                             # RFC5737\n    lanIps=\"$lanIps|(^192\\.168\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"                  # RFC1918\n    lanIps=\"$lanIps|(^198\\.1[8-9]\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"               # RFC2544\n    lanIps=\"$lanIps|(^198\\.51\\.100\\.[0-9]{1,3}$)\"                          # RFC5737\n    lanIps=\"$lanIps|(^203\\.0\\.113\\.[0-9]{1,3}$)\"                           # RFC5737\n    lanIps=\"$lanIps|(^2[4-5][0-9]\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$)\"   # RFC1112\n\n    echo $lanIps\n\n}\n\n# Get IPv4 by ip route or network\n\narWanIp4() {\n\n    local hostIp\n    local lanIps=$(arLanIp4)\n\n    case $(uname) in\n        'Linux')\n            hostIp=$(ip -o -4 route get 100.64.0.1 | grep -oE 'src [0-9\\.]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n        ;;\n        Darwin|FreeBSD)\n            hostIp=$(ifconfig | grep \"inet \" | grep -v 127.0.0.1 | awk '{print $2}' | grep -Ev \"$lanIps\")\n        ;;\n    esac\n\n    if [ -z \"$hostIp\" ]; then\n        hostIp=$(arRequest $arIp4QueryUrl)\n    fi\n\n    if [ -z \"$hostIp\" ]; then\n        return 2\n    fi\n\n    if [ -z \"$(echo $hostIp | grep -E '^[0-9\\.]+$')\" ]; then\n        arLog \"> arWanIp4 - Invalid ip address\"\n        return 1\n    fi\n\n    echo $hostIp\n\n}\n\n# Get IPv4 from a specific interface\n# Args: interface\n\narDevIp4() {\n\n    local hostIp\n    local lanIps=$(arLanIp4)\n\n    case $(uname) in\n        'Linux')\n            hostIp=$(ip -o -4 addr show dev $1 primary | grep -oE 'inet [0-9.]+' | awk '{print $2}' | grep -Ev \"$lanIps\" | head -n 1)\n        ;;\n    esac\n\n    if [ -z \"$hostIp\" ]; then\n        arLog \"> arDevIp4 - Can't get ip address\"\n        return 1\n    fi\n\n    if [ -z \"$(echo $hostIp | grep -E '^[0-9\\.]+$')\" ]; then\n        arLog \"> arDevIp4 - Invalid ip address\"\n        return 1\n    fi\n\n    echo $hostIp\n\n}\n\n################################################################### ipv6 util ##\n\n# Get regular expression for IPv6 LAN addresses\n\narLanIp6() {\n\n    local lanIps=\"(^$)\"\n\n    lanIps=\"$lanIps|(^::1$)\"                            # RFC4291\n    lanIps=\"$lanIps|(^64:[fF][fF]9[bB]:)\"               # RFC6052, RFC8215\n    lanIps=\"$lanIps|(^100::)\"                           # RFC6666\n    lanIps=\"$lanIps|(^2001:2:0?:)\"                      # RFC5180\n    lanIps=\"$lanIps|(^2001:[dD][bB]8:)\"                 # RFC3849\n    lanIps=\"$lanIps|(^[fF][cdCD][0-9a-fA-F]{2}:)\"       # RFC4193 Unique local addresses\n    lanIps=\"$lanIps|(^[fF][eE][8-9a-bA-B][0-9a-fA-F]:)\" # RFC4291 Link-local addresses\n\n    echo $lanIps\n\n}\n\n# Get IPv6 by ip route or network\n\narWanIp6() {\n\n    local hostIp\n    local lanIps=$(arLanIp6)\n\n    case $(uname) in\n        'Linux')\n            hostIp=$(ip -o -6 route get 100::1 | grep -oE 'src [0-9a-fA-F:]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n        ;;\n    esac\n\n    if [ -z \"$hostIp\" ]; then\n        hostIp=$(arRequest $arIp6QueryUrl)\n    fi\n\n    if [ -z \"$hostIp\" ]; then\n        arLog \"> arWanIp6 - Can't get ip address\"\n        return 1\n    fi\n\n    if [ -z \"$(echo $hostIp | grep -E '^[0-9a-fA-F:]+$')\" ]; then\n        arLog \"> arWanIp6 - Invalid ip address\"\n        return 1\n    fi\n\n    echo $hostIp\n\n}\n\n# Get IPv6 from a specific interface\n# Args: interface\n\narDevIp6() {\n\n    local hostIp\n    local lanIps=$(arLanIp6)\n\n    case $(uname) in\n        'Linux')\n            # Try obtain home address (a speical permanent address for mobile devices)\n            hostIp=$(ip -o -6 addr show dev $1 scope global home | grep -oE 'inet6 [0-9a-fA-F:]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n            if [ -z \"$hostIp\" ]; then # Try obtain permanent address\n                hostIp=$(ip -o -6 addr show dev $1 scope global permanent | grep -oE 'inet6 [0-9a-fA-F:]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n            fi\n            if [ -z \"$hostIp\" ]; then # Try obtain non-deprecated primary (non-temporary) non-mngtmpaddr (mngtmpaddr is template for temporary address creation) address then\n                hostIp=$(ip -o -6 addr show dev $1 scope global -deprecated primary | grep -v mngtmpaddr | grep -oE 'inet6 [0-9a-fA-F:]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n            fi\n            if [ -z \"$hostIp\" ]; then # Try obtain non-deprecated primary address then\n                hostIp=$(ip -o -6 addr show dev $1 scope global -deprecated primary | grep -oE 'inet6 [0-9a-fA-F:]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n            fi\n            if [ -z \"$hostIp\" ]; then # Try obtain non-deprecated address any at last\n                hostIp=$(ip -o -6 addr show dev $1 scope global -deprecated | grep -oE 'inet6 [0-9a-fA-F:]+' | awk '{print $2}' | grep -Ev \"$lanIps\")\n            fi\n            hostIp=$(echo \"$hostIp\" | head -n 1) # Fetch at most one address\n        ;;\n    esac\n\n    if [ -z \"$hostIp\" ]; then\n        arLog \"> arDevIp6 - Can't get ip address\"\n        return 1\n    fi\n\n    if [ -z \"$(echo $hostIp | grep -E '^[0-9a-fA-F:]+$')\" ]; then\n        arLog \"> arDevIp6 - Invalid ip address\"\n        return 1\n    fi\n\n    echo $hostIp\n\n}\n\n################################################################### dnspod api ##\n\n# Dnspod Bridge\n# Args: interface data\n\narDdnsApi() {\n\n    local dnsapi=\"https://dnsapi.cn/${1:?'Info.Version'}\"\n    local params=\"login_token=$arToken&format=json&lang=en&$2\"\n\n    arRequest \"$dnsapi\" \"$params\"\n\n}\n\n# Fetch Record Id\n# Args: domain subdomain recordType\n\narDdnsLookup() {\n\n    local errMsg\n\n    local recordId\n\n    if [ \"$2\" != \"@\" ]; then\n        # No sub_domain for root domain\n        subDomainRule=\"&sub_domain=$2\"\n    fi\n\n    # Get Record Id\n    recordId=$(arDdnsApi \"Record.List\" \"domain=$1${subDomainRule}&record_type=$3\")\n    recordId=$(echo $recordId | sed 's/.*\"id\":\"\\([0-9]*\\)\".*/\\1/')\n\n    if ! [ \"$recordId\" -gt 0 ] 2>/dev/null ;then\n        errMsg=$(echo $recordId | sed 's/.*\"message\":\"\\([^\\\"]*\\)\".*/\\1/')\n        arLog \"> arDdnsLookup - $errMsg\"\n        return 1\n    fi\n\n    echo $recordId\n}\n\n# Update Record Value\n# Args: domain subdomain recordId recordType [hostIp]\n\narDdnsUpdate() {\n\n    local errMsg\n\n    local recordRs\n    local recordCd\n    local recordIp\n\n    local lastRecordIp\n    local lastRecordIpFile=\"$arLastRecordFile.$3\"\n\n    # fetch last ip\n    if [ -f $lastRecordIpFile ]; then\n        lastRecordIp=$(cat $lastRecordIpFile)\n    fi\n\n    # fetch from api\n    if [ -z \"$lastRecordIp\" ]; then\n        recordRs=$(arDdnsApi \"Record.Info\" \"domain=$1&record_id=$3\")\n        recordCd=$(echo $recordRs | sed 's/.*{\"code\":\"\\([0-9]*\\)\".*/\\1/')\n        lastRecordIp=$(echo $recordRs | sed 's/.*,\"value\":\"\\([0-9a-fA-F\\.\\:]*\\)\".*/\\1/')\n    fi\n\n    # update ip\n    if [ -z \"$5\" ]; then\n        recordRs=$(arDdnsApi \"Record.Ddns\" \"domain=$1&sub_domain=$2&record_id=$3&record_type=$4&record_line=%e9%bb%98%e8%ae%a4\")\n    else\n        if [ \"$5\" = \"$lastRecordIp\" ]; then\n            arLog \"> arDdnsUpdate - unchanged: $lastRecordIp\" # unchanged event\n            return $arErrCodeUnchanged\n        fi\n        recordRs=$(arDdnsApi \"Record.Ddns\" \"domain=$1&sub_domain=$2&record_id=$3&record_type=$4&value=$5&record_line=%e9%bb%98%e8%ae%a4\")\n    fi\n\n    # parse result\n    recordCd=$(echo $recordRs | sed 's/.*{\"code\":\"\\([0-9]*\\)\".*/\\1/')\n    recordIp=$(echo $recordRs | sed 's/.*,\"value\":\"\\([0-9a-fA-F\\.\\:]*\\)\".*/\\1/')\n\n    # check result\n    if [ \"$recordCd\" != \"1\" ]; then\n        errMsg=$(echo $recordRs | sed 's/.*,\"message\":\"\\([^\"]*\\)\".*/\\1/')\n        arLog \"> arDdnsUpdate - error: $errMsg\"\n        return 1\n    elif [ \"$recordIp\" = \"$lastRecordIp\" ]; then\n        arLog \"> arDdnsUpdate - unchanged: $recordIp\" # unchanged event\n        return $arErrCodeUnchanged\n    else\n        arLog \"> arDdnsUpdate - updated: $recordIp\" # updated event\n        if [ -n \"$lastRecordIpFile\" ]; then\n            echo $recordIp > $lastRecordIpFile\n        fi\n        return 0\n    fi\n\n}\n\n################################################################### task hub ##\n\n# DDNS Check\n# Args: domain subdomain [6|4] interface\n\narDdnsCheck() {\n\n    local errCode\n\n    local hostIp\n\n    local recordId\n    local recordType\n\n    arLog \"=== Check $2.$1 ===\"\n    arLog \"Fetching Host Ip\"\n\n    if   [ \"$3\" = \"6\" ] && [ -n \"$4\" ]; then\n        recordType=AAAA\n        hostIp=$(arDevIp6 \"$4\")\n    elif [ \"$3\" = \"4\" ] && [ -n \"$4\" ]; then\n        recordType=A\n        hostIp=$(arDevIp4 \"$4\")\n    elif [ \"$3\" = \"6\" ]; then\n        recordType=AAAA\n        hostIp=$(arWanIp6)\n    else\n        recordType=A\n        hostIp=$(arWanIp4)\n    fi\n\n    errCode=$?\n    if [ $errCode -eq 0 ]; then\n        arLog \"> Host Ip: $hostIp\"\n        arLog \"> Record Type: $recordType\"\n    elif [ $errCode -eq 2 ]; then\n        arLog \"> Host Ip: Auto\"\n        arLog \"> Record Type: $recordType\"\n    else\n        arLog \"$hostIp\"\n        return $errCode\n    fi\n\n    arLog \"Fetching RecordId\"\n    recordId=$(arDdnsLookup \"$1\" \"$2\" \"$recordType\")\n\n    errCode=$?\n    if [ $errCode -eq 0 ]; then\n        arLog \"> Record Id: $recordId\"\n    else\n        arLog \"$recordId\"\n        return $errCode\n    fi\n\n    arLog \"Updating Record value\"\n    arDdnsUpdate \"$1\" \"$2\" \"$recordId\" \"$recordType\" \"$hostIp\"\n\n}\n\n################################################################### end ##\n"
        },
        {
          "name": "ddnspod.sh",
          "type": "blob",
          "size": 0.8037109375,
          "content": "#!/bin/sh\n\ncd \"$(dirname \"$0\")\"\n\n# Import ardnspod functions\n. ardnspod\n\n# Combine your token ID and token together as follows\n\narToken=\"12345,7676f344eaeaea9074c123451234512d\"\n\n# Web endpoint to be used for querying the public IPv6 address\n# Set this to override the default url provided by ardnspod\n\narIp4QueryUrl=\"http://ipv4.rehi.org/ip\"\narIp6QueryUrl=\"http://ipv6.rehi.org/ip\"\n\n# The temp file to store the last record ip\n\narLastRecordFile=/tmp/ardnspod_last_record\n\n# Return code when the last record IP is same as current host IP\n# Set this to a value other than 0 to distinguish with a successful ddns update\n\narErrCodeUnchanged=0\n\n# Place each domain you want to check as follows\n# you can have multiple arDdnsCheck blocks\n\n# IPv4:\narDdnsCheck \"test.org\" \"subdomain\"\n\n# IPv6:\narDdnsCheck \"test.org\" \"subdomain6\" 6\n"
        }
      ]
    }
  ]
}