{
  "metadata": {
    "timestamp": 1736568697485,
    "page": 785,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc4OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "themattrix/bash-concurrent",
      "stars": 1240,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codeclimate.yml",
          "type": "blob",
          "size": 0.08203125,
          "content": "---\nengines:\n  shellcheck:\n    enabled: true\nratings:\n  paths: []\nexclude_paths: []\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.044921875,
          "content": "# VIM swap files\n.*.swp\n\n# Log output\n/.logs/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.216796875,
          "content": "language: bash\nsudo: required\ndist: trusty\n\nbefore_install:\n  - sudo apt-get update -q\n  - sudo apt-get install cabal-install -y\n  - cabal update\n  - cabal install shellcheck-0.4.3\nscript:\n  - ~/.cabal/bin/shellcheck *.sh\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Matthew Tardiff\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.7978515625,
          "content": "# Concurrent ![version: 2.4.0](https://img.shields.io/badge/version-2.4.0-green.svg?style=flat-square) ![language: bash](https://img.shields.io/badge/language-bash-blue.svg?style=flat-square) ![license: MIT](https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square) [![Travis](https://img.shields.io/travis/themattrix/bash-concurrent.svg?style=flat-square)](https://travis-ci.org/themattrix/bash-concurrent)\n\nA Bash function to run tasks in parallel and display pretty output as they complete.\n\n[![asciicast](https://asciinema.org/a/34219.png)](https://asciinema.org/a/34219)\n\n\n## Examples\n\nRun three tasks concurrently:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1\n```\n\nRun three tasks sequentially:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1  \\\n    --sequential\n```\n\nStart the medium task *after* the short task succeeds:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1  \\\n    --require 'My short task'   \\\n    --before  'My medium task'\n```\n\nStart the short task after *both* other tasks succeed:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1  \\\n    --require 'My long task'    \\\n    --require 'My medium task'  \\\n    --before  'My short task'\n```\n\nSame as above, but shorter:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1  \\\n    --require-all --before 'My short task'\n```\n\nStart the medium task *and* the long task after the short task succeeds:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1  \\\n    --require 'My short task'   \\\n    --before  'My medium task'  \\\n    --before  'My long task'\n```\n\nSame as above, but shorter:\n\n```bash\nconcurrent \\\n    - 'My long task'   sleep 10 \\\n    - 'My medium task' sleep 5  \\\n    - 'My short task'  sleep 1  \\\n    --require 'My short task' --before-all\n```\n\nRun the first two tasks concurrently,\n*and then* the second two tasks concurrently,\n*and then* the final three tasks concurrently.\n\n```bash\nconcurrent \\\n    - 'Task 1'  sleep 3 \\\n    - 'Task 2'  sleep 3 \\\n    --and-then \\\n    - 'Task 3'  sleep 3 \\\n    - 'Task 4'  sleep 3 \\\n    --and-then \\\n    - 'Task 5'  sleep 3 \\\n    - 'Task 6'  sleep 3 \\\n    - 'Task 7'  sleep 3\n```\n\nIf your command has a `-` argument, you can use a different task delimiter:\n\n```bash\nconcurrent \\\n    + 'My long task'   wget -O - ... \\\n    + 'My medium task' sleep 5  \\\n    + 'My short task'  sleep 1\n```\n\nYou can display extra information at the end of each task's status line by\nechoing to `fd 3`.\n\n```bash\nmy_task() {\n    ...\n    echo \"(extra info)\" >&3\n    ...\n}\n```\n\nTake a look at [`demo.sh`](demo.sh) for more involved examples.\n\n\n## Dry Run\n\nIf you have a lot of dependencies between tasks, it's generally a good idea to\nperform a dry-run to ensure that the tasks are ordered as expected. Set the\n`CONCURRENT_DRY_RUN` environment variable to perform a dry-run.\n\n\n## Forking Limit\n\nBy default, `concurrent` allows up to 50 concurrently-running tasks.\nSet the `CONCURRENT_LIMIT` environment variable to override this limit.\n\nA neat trick is to set the limit to 1, essentially forcing a `--sequential`\nrun, but with existing tasks between dependencies taken into account.\n\nA limit less than 1 is treated as no limit.\n\n\n## Compact Display\n\nIf the number of tasks exceed the terminal height, the \"compact display\" will\nbe activated. It can also be explicitly activated by setting the\n`CONCURRENT_COMPACT` environment variable to anything other than `0`.\n\nIn this mode, each task is represented by a single character instead of an\nentire line. An execution summary is displayed above the tasks.\n\n[![asciicast](https://asciinema.org/a/37290.png)](https://asciinema.org/a/37290)\n\n\n## Non-Interactive Mode\n\nIf the output is not attached to a tty, the \"non-interactive\" mode will be\nactivated. It can also be explicitly activated by setting the\n`CONCURRENT_NONINTERACTIVE` environment variable to anything other than `0`.\n\nIn this mode, each task is displayed as soon as it completes. Colors are\nalso disabled.\n\n\n## Logging\n\nBy default, logs for each task will be created in `./logs/<timestamp>/`.\nFor example:\n\n    $ ls .logs/2016-02-02@00:09:07\n    0. Creating VM (0).log\n    1. Creating ramdisk (0).log\n    2. Enabling swap (0).log\n    3. Populating VM with world data (1).log\n    4. Spigot: Pulling docker image for build (1).log\n    5. Spigot: Building JAR (skip).log\n    6. Pulling remaining docker images (skip).log\n    7. Launching services (skip).log\n\n\nTo change this directory, set `CONCURRENT_LOG_DIR` before calling `concurrent`.\n\n\n## Failure Demo\n\n[![asciicast](https://asciinema.org/a/34217.png)](https://asciinema.org/a/34217)\n\n\n## Interrupted Demo\n\n[![asciicast](https://asciinema.org/a/34218.png)](https://asciinema.org/a/34218)\n\n\n## Requirements\n\n- bash >= 4.2 (for `declare -g`)\n- cat\n- cp\n- date\n- mkdir\n- mkfifo\n- mktemp\n- mv\n- sed\n- tail\n- tput\n\n\n## Change Log\n\n- **2.4.0**\n  - *New:* Gracefully switches to non-interactive mode when a tty is not present or if `CONCURRENT_NONINTERACTIVE` is non-zero.\n- **2.3.3**\n  - *Fix:* Cursor no longer hidden when running nested.\n- **2.3.2**\n  - *Fix:* Failing tasks with no output now exit with the correct status (credit: @uluyol).\n- **2.3.1**\n  - *Fix:* Now clearing to end of line when printing extra status info after a task (credit: @fragmede).\n- **2.3.0**\n  - *New:* Concurrency limit defaults to 50, unless overridden by `CONCURRENT_LIMIT`.\n  - *New:* If the number of tasks exceed the terminal height (or `CONCURRENT_COMPACT` is set), each task will be displayed as a single character instead of a taking up an entire line.\n  - *New:* Cursor now hidden while running.\n  - *Fix:* Greatly improved speed of event loop. Especially noticeable for large numbers of tasks.\n  - *Fix:* Namespaced `command_*` and `prereq_*` arrays so that they don't carry into the tasks.\n- **2.2.1**\n  - *Fix:* Tasks not allowed to read from stdin.\n- **2.2.0**\n  - *New:* Instances of concurrent can be nested without breaking.\n  - *New:* Set custom log dir with `CONCURRENT_LOG_DIR`.\n  - *Fix:* Works under Cygwin (special thanks to @FredDeschenes).\n  - *Fix:* No longer requires GNU sed (gsed) on OS X.\n  - *Fix:* Animation now uses a single process.\n  - *Fix:* Extra status info is now merely bold instead of bold/white, which should be more visible on light terminal backgrounds.\n- **2.1.0**\n  - *New:* New `--and-then` flag for dividing tasks into groups. All tasks in a group run concurrently, but all must complete before the next group may start (inspiration: [fooshards on Reddit](https://www.reddit.com/r/programming/comments/42n64o/concurrent_bash_function_to_run_tasks_in_parallel/czbxnrh)).\n  - *Fix:* Removed extra backslashes in README (credit: [bloody-albatross on Reddit](https://www.reddit.com/r/programming/comments/42n64o/concurrent_bash_function_to_run_tasks_in_parallel/czbrtjg))\n- **2.0.1**\n  - *Fix:* `kill` is a bash builtin (credit: @ScoreUnder)\n  - *Fix:* Require GNU sed on OS X (credit: @kumon)\n  - *Fix:* Static analysis with shellcheck on push via Travis CI (credit: @xzovy)\n  - *Fix:* Cleaner signal handling.\n  - *Fix:* Simplified event loop.\n- **2.0.0**\n  - *New:* Tasks can now display status updates by echoing to fd 3.\n- **1.6.0**\n  - *New:* `CONCURRENT_DRY_RUN` environment variable runs `sleep 3` instead of actual commands (and prints message).\n- **1.5.2**\n  - *Fix:* Requirement loops disallowed.\n- **1.5.1**\n  - *Fix:* Task is not allowed to require itself directly.\n- **1.5.0**\n  - *New:* First argument is now the task delimiter.\n- **1.4.1**\n  - *Fix:* Namespaced previously-missed function.\n- **1.4.0**\n  - *New:* New `--require-all` and `--before-all` flags.\n  - *Fix:* Namespaced all concurrent-related functions and variables.\n  - *Fix:* Unsetting all concurrent-related functions and variables in the task's context.\n  - *Fix:* Enforcing foreground in an interactive shell.\n- **1.3.0**\n  - *New:* New `--sequential` flag, for when each task requires the previous.\n- **1.2.0**\n  - *New:* Running tasks have an animated cursor.\n  - *Fix:* Enforcing bash version 4.3.\n  - *Fix:* Echo is re-enabled even if an internal error occurs.\n- **1.1.6**\n  - *Fix:* Enforcing bash version 4.\n- **1.1.5**\n  - *Fix:* Tasks now use original `$PWD` and `$OLDPWD`.\n- **1.1.4**\n  - *Fix:* Tasks now use original `$SHELLOPTS` and `$BASHOPTS`.\n- **1.1.3**\n  - *Fix:* Sanitizing forward slashes from log names.\n- **1.1.2**\n  - *Fix:* Ensuring task status file exists even if an internal error occurs.\n- **1.1.1**\n  - *Fix:* Task command may now have arguments starting with `-`.\n- **1.1.0**\n  - *New:* Gracefully handling SIGINT.\n  - *Fix:* Works on OS X too.\n- **1.0.0**\n  - Initial working release.\n"
        },
        {
          "name": "concurrent.lib.sh",
          "type": "blob",
          "size": 37.3583984375,
          "content": "#!/usr/bin/env bash\n\nconcurrent() (\n    #\n    # General Utilities\n    #\n\n    __crt__error() {\n        echo \"ERROR (concurrent): ${1}\" 1>&2\n        exit 1\n    }\n\n    __crt__is_dry_run() {\n        [[ -n \"${CONCURRENT_DRY_RUN}\" ]]\n    }\n\n    __crt__hide_failure() {\n        \"${@}\" 2> /dev/null || :\n    }\n\n    #\n    # Compatibility Check\n    #\n\n    if ! declare -g >/dev/null 2>&1; then\n        __crt__error \"Requires at least Bash version 4.2 for 'declare -g' (you have ${BASH_VERSION:-a different shell})\"\n    fi\n\n    #\n    # Help and Usage\n    #\n\n    __crt__help__version='concurrent 2.4.0'\n\n    __crt__help__usage=\"concurrent - Run tasks in parallel and display pretty output as they complete.\n\n        Usage:\n          concurrent \\\\\n              (- TASK COMMAND [ARGS...] | --and-then)... \\\\\n              [--sequential | [(--require-all | (--require TASK)...) \\\\\n                               ( --before-all | ( --before TASK)...)...]]\n          concurrent -h | --help\n          concurrent --version\n\n        Options:\n          -h --help                 Show this help.\n          --version                 Show version.\n          - TASK COMMAND [ARGS...]  Define a task named TASK for running COMMAND with ARGS.\n          --and-then                Insert between tasks to create groups of concurrent tasks.\n          --sequential              Each task requires the previous task.\n          --require TASK            Require a TASK to complete successfully...\n          --before TASK             ...before another TASK.\n          --require-all             Shortcut for requiring all tasks.\n          --before-all              Given tasks are prerequisites to all others.\n\n        Failed Tasks:\n          If a task fails, all dependent tasks (and their dependent tasks, and so on) are\n          immediately marked 'SKIP'. The status and output of all failed and skipped tasks\n          are displayed at the end. The exit status will be 1.\n\n        Examples:\n          # Run three tasks concurrently.\n          concurrent \\\\\n              - 'My long task'   sleep 10 \\\\\n              - 'My medium task' sleep 5  \\\\\n              - 'My short task'  sleep 1\n\n          # Run three tasks sequentially.\n          concurrent \\\\\n              - 'My long task'   sleep 10 \\\\\n              - 'My medium task' sleep 5  \\\\\n              - 'My short task'  sleep 1  \\\\\n              --sequential\n\n          # Start the medium task *after* the short task succeeds.\n          concurrent \\\\\n              - 'My long task'   sleep 10 \\\\\n              - 'My medium task' sleep 5  \\\\\n              - 'My short task'  sleep 1  \\\\\n              --require 'My short task'   \\\\\n              --before  'My medium task'\n\n          # Start the short task after *both* other tasks succeed.\n              ...\n              --require 'My long task'    \\\\\n              --require 'My medium task'  \\\\\n              --before  'My short task'\n\n          # Start the medium task *and* the long task after the short task succeeds.\n              ...\n              --require 'My short task'   \\\\\n              --before  'My medium task'  \\\\\n              --before  'My long task'\n\n          # If your command has a '-' argument, you can use a different task delimiter.\n          concurrent \\\\\n              + 'My long task'   wget -O - ... \\\\\n              + 'My medium task' sleep 5  \\\\\n              + 'My short task'  sleep 1\n\n        Settable Environment Variables:\n          CONCURRENT_DRY_RUN (default: unset)\n            Setting this to any non-empty value causes 'dry-run' mode to be enabled.\n            In this mode, all task commands are replaced with 'sleep 3'. This is useful\n            for testing that the dependencies between tasks are correctly specified.\n\n          CONCURRENT_LIMIT (default: 50)\n            Specifies the number of tasks which are allowed to be actively running at\n            any time. For unlimited concurrency, set this to an integer less than 1.\n\n          CONCURRENT_COMPACT (default: 0)\n            Setting this to a non-zero value causes the 'compact display' mode to be\n            activated. In this mode, each task is represented by a single character\n            instead of an entire line. This mode is automatically activated if the\n            number of tasks exceed the terminal height.\n\n          CONCURRENT_NONINTERACTIVE (default: 0)\n            Setting this to a non-zero value causes the 'non-interactive' mode to be\n            activated. In this mode, tasks are displayed in the order they finish\n            and colors are disabled. This mode is automatically activated if the\n            output is not to a tty.\n\n          CONCURRENT_LOG_DIR (default: \\$PWD/.logs/\\$(date +'%F@%T'))\n            Optionally change the directory in which all tasks are logged.\n\n        Informational Environment Variables:\n          CONCURRENT_DEPTH\n            The current nesting depth of this 'concurrent' instance, starting at 0.\n\n          CONCURRENT_COMMAND\n            An array of the arguments being run for a task.\n\n          CONCURRENT_TASK_NAME\n            The name of the task being run.\n\n        Requirements:\n          bash >= 4.2, cat, cp, date, mkdir, mkfifo, mktemp, mv, sed, tail, tput\n\n        Author:\n          Matthew Tardiff <mattrix@gmail.com>\n\n        License:\n          MIT\n\n        Version:\n          ${__crt__help__version}\n\n        URL:\n          https://github.com/themattrix/bash-concurrent\"\n\n    __crt__help__display_usage_and_exit() {\n       sed 's/^        //' <<< \"${__crt__help__usage}\"\n       exit 0\n    }\n\n    __crt__help__display_version_and_exit() {\n       echo \"${__crt__help__version}\"\n       exit 0\n    }\n\n    if [[ -z \"${1}\" ]] || [[ \"${1}\" == '-h' ]] || [[ \"${1}\" == '--help' ]]; then\n        __crt__help__display_usage_and_exit\n    elif [[ \"${1}\" == '--version' ]]; then\n        __crt__help__display_version_and_exit\n    fi\n\n    __crt__unset_env() {\n        # Unset all concurrent-related configuration environment variables.\n        unset CONCURRENT_DRY_RUN\n    }\n\n    __crt__unset() {\n        local sub_namespace=${1}\n        if [[ -n \"${sub_namespace}\" ]]; then\n            local namespace=\"__crt__${sub_namespace}__\"\n        else\n            local namespace=\"__crt__\"\n        fi\n        # shellcheck disable=SC2046\n        unset -f $(compgen -A function \"${namespace}\")\n        # shellcheck disable=SC2046\n        unset $(compgen -v \"${namespace}\")\n    }\n\n    __crt__unset 'help'\n\n    #\n    # Settings\n    #\n\n    __crt__ORIG_PWD=${PWD}\n    __crt__ORIG_OLDPWD=${OLDPWD}\n    __crt__ORIG_BASHOPTS=${BASHOPTS}\n    __crt__ORIG_SHELLOPTS=${SHELLOPTS}\n\n    __crt__set_original_pwd() {\n        cd \"${__crt__ORIG_PWD}\"\n        export OLDPWD=${__crt__ORIG_OLDPWD}\n    }\n\n    __crt__set_our_shell_options() {\n        set -o errexit      # Exit on a failed command...\n        set -o pipefail     # ...even if that command is in a pipeline.\n        shopt -s nullglob   # Empty glob evaluates to nothing instead of itself\n    }\n\n    __crt__set_original_shell_options() {\n        __crt__set_our_shell_options\n        [[ \"${__crt__ORIG_SHELLOPTS}\" == *errexit*  ]] || set +o errexit\n        [[ \"${__crt__ORIG_SHELLOPTS}\" == *pipefail* ]] || set +o pipefail\n        [[ \"${__crt__ORIG_BASHOPTS}\"  == *nullglob* ]] || shopt -u nullglob\n    }\n\n    __crt__set_our_shell_options\n\n    #\n    # Task Management\n    #\n\n    __crt__is_task_started() {\n        [[ -z \"${__crt__pending[${1}]}\" ]]\n    }\n\n    __crt__is_task_done() {\n        [[ -n \"${__crt__codes[${1}]}\" ]]\n    }\n\n    __crt__are_all_tasks_done() {\n        [[ \"${__crt__running_task_count}\" -eq 0 ]]\n    }\n\n    __crt__is_task_running() {\n        __crt__is_task_started \"${1}\" && ! __crt__is_task_done \"${1}\"\n    }\n\n    __crt__is_under_concurrent_limit() {\n        [[ \"${CONCURRENT_LIMIT}\" -lt 1 || \"${__crt__running_task_count}\" -lt \"${CONCURRENT_LIMIT}\" ]]\n    }\n\n    __crt__clear_event_pipe() {\n        > \"${__crt__event_pipe}\"\n    }\n\n    __crt__name_index() {\n        local name=${1}\n        local i\n        for i in \"${!__crt__names[@]}\"; do\n            if [[ \"${__crt__names[${i}]}\" == \"${name}\" ]]; then\n                printf '%s' \"${i}\"\n                return\n            fi\n        done\n        __crt__error \"Failed to find task named '${name}'\"\n    }\n\n    __crt__is_task_allowed_to_start() {\n        # A task is allowed to start if:\n        #   1. it has not already started, and if\n        #   2. all prereq tasks have succeeded, and if\n        #   3. the process has not been interrupted.\n        # If any prereqs have failed or have been skipped, then this task will\n        # be skipped.\n\n        local task=${1}\n        if __crt__is_task_started \"${task}\"; then\n            return 1  # cannot start again\n        fi\n\n        local requires\n        local prereqs=\"__crt__prereqs_${task}[@]\"\n        for requires in \"${!prereqs}\"; do\n            if [[ -z \"${__crt__codes[${requires}]}\" ]]; then\n                return 1\n            elif [[ \"${__crt__codes[${requires}]}\" != \"0\" ]]; then\n                __crt__skip_task \"${task}\" \"${__crt__names[${requires}]}\"\n                return 1\n            fi\n        done\n\n        if [[ \"${__crt__interrupted}\" -eq 1 ]]; then\n            __crt__mark_task_as_interrupted \"${task}\"\n            return 1\n        fi\n\n        # All prereqs succeeded! This task can be started.\n    }\n\n    __crt__mark_task_with_code() {\n        local task=${1}\n        local code=${2}\n        echo \"task:${task}:${code}\" >> \"${__crt__event_pipe}\"\n    }\n\n    __crt__task_runner() (\n        # Do not create real variables for these so that they do not override\n        # names from the parent script.\n        # $1: task index\n        # $2: command args array\n        # $3: status dir\n        # $4: event pipe\n        set -- \"${1}\" \"__crt__command_${1}[@]\" \"${__crt__status_dir}\" \"${__crt__event_pipe}\"\n\n        # Copy the command over since we're unsetting the __crt__ variables.\n        CONCURRENT_COMMAND=(\"${!2}\")\n\n        # Reset any existing signal handlers.\n        trap -- - INT EXIT\n\n        # Allow nested tasks to refer to parent tasks.\n        CONCURRENT_TASK_NAME+=(\"${__crt__names[${1}]}\")\n        export CONCURRENT_TASK_NAME\n\n        set +o errexit  # a failure of the command should not exit the task\n        (\n            __crt__set_original_pwd\n            __crt__set_original_shell_options\n            __crt__unset_env\n            __crt__unset\n\n            \"${CONCURRENT_COMMAND[@]}\" 3>&1 &> \"${3}/${1}\" < /dev/null |\n            while read -r meta; do\n                printf \"meta:%d:%s\\n\" \"${1}\" \"${meta}\" >> \"${4}\"\n            done\n            exit \"${PIPESTATUS[0]}\"\n        )\n        code=$?\n        set -o errexit  # ...but other failures should\n\n        __crt__mark_task_with_code \"${1}\" \"${code}\"\n    )\n\n    __crt__mark_task_as_started() {\n        if [[ -n \"${__crt__pending[${1}]}\" ]]; then\n            unset \"__crt__pending[${1}]\"\n            (( __crt__running_task_count++ )) || :\n        fi\n    }\n\n    __crt__mark_task_as_stopped() {\n        local index=${1}\n        local code=${2}\n\n        if [[ -z \"${__crt__codes[${index}]}\" ]]; then\n            (( __crt__running_task_count-- )) || :\n            if   [[ \"${code}\" == '0'    ]]; then (( __crt__success_task_count++ ))     || :\n            elif [[ \"${code}\" == 'skip' ]]; then (( __crt__skipped_task_count++ ))     || :\n            elif [[ \"${code}\" == 'int'  ]]; then (( __crt__interrupted_task_count++ )) || :\n            else                                 (( __crt__failure_task_count++ ))     || :\n            fi\n        fi\n    }\n\n    __crt__start_task() {\n        __crt__task_runner \"${1}\" &\n        __crt__mark_task_as_started \"${1}\"\n        __crt__draw_status \"${1}\" running\n    }\n\n    __crt__start_all_tasks() {\n        __crt__draw_initial_tasks\n        __crt__move_cursor_to_top\n        __crt__start_allowed_tasks\n    }\n\n    __crt__mark_task_as_interrupted() {\n        __crt__mark_task_as_started \"${1}\"\n        printf '[INTERRUPTED]\\n' >> \"${__crt__status_dir}/${1}\"\n        printf 'task:%d:int\\n' \"${1}\" >> \"${__crt__event_pipe}\"\n    }\n\n    __crt__mark_all_running_tasks_as_interrupted() {\n        local i\n        for (( i = 0; i < __crt__task_count; i++ )); do\n            if __crt__is_task_running \"${i}\"; then\n                __crt__mark_task_as_interrupted \"${i}\"\n            fi\n        done\n    }\n\n    __crt__skip_task() {\n        __crt__mark_task_as_started \"${1}\"\n        echo \"[SKIPPED] Prereq '${2}' failed or was skipped\" > \"${__crt__status_dir}/${1}\"\n        __crt__mark_task_with_code \"${1}\" skip\n    }\n\n    __crt__start_allowed_tasks() {\n        local __crt__i\n        for __crt__i in \"${__crt__pending[@]}\"; do\n            __crt__is_under_concurrent_limit || break\n            if __crt__is_task_allowed_to_start \"${__crt__i}\"; then\n                __crt__start_task \"${__crt__i}\"\n            fi\n        done\n    }\n\n    __crt__save_stdin_stream() {\n        exec 4<&0  # duplicate stdin stream to fd 4\n    }\n\n    __crt__restore_stdin_stream() {\n        exec 0<&4  # restore original stdin stream from fd 4\n    }\n\n    __crt__wait_for_all_tasks() {\n        __crt__start_animation\n        __crt__save_stdin_stream\n        __crt__run_event_loop\n        __crt__status_cleanup\n        __crt__stop_animation\n        wait  # wait for all (completed) tasks\n        __crt__restore_stdin_stream\n    }\n\n    __crt__run_event_loop() {\n        # Main event loop! Each line read from the event pipe is an event to\n        # handle. We can exit the loop once all tasks have completed.\n        local __crt__event\n        local __crt__tail_pipe=\"${__crt__status_dir}/tail-pipe\"\n\n        rm -f  \"${__crt__tail_pipe}\"\n        mkfifo \"${__crt__tail_pipe}\"\n\n        tail -n +0 -f \"${__crt__event_pipe}\" >> \"${__crt__tail_pipe}\" &\n        __crt__tail_pid=$!\n\n        while read -r __crt__event; do\n            if [[ \"${__crt__event}\" == task:* ]]; then\n                __crt__handle_done_task \"${__crt__event#task:}\"\n                if __crt__are_all_tasks_done; then\n                    break\n                fi\n            elif [[ \"${__crt__event}\" == anim:* ]]; then\n                __crt__update_running_status_frames\n            elif [[ \"${__crt__event}\" == meta:* ]]; then\n                __crt__manage_meta \"${__crt__event#meta:}\"\n            fi\n        done < \"${__crt__tail_pipe}\"\n\n        __crt__cleanup_event_loop\n    }\n\n    __crt__cleanup_event_loop() {\n        if [[ -n \"${__crt__tail_pid}\" ]]; then\n            __crt__hide_failure kill \"${__crt__tail_pid}\"\n            __crt__hide_failure wait \"${__crt__tail_pid}\"\n        fi\n    }\n\n    __crt__handle_done_task() {\n        local index=${1%%:*}\n        local code=${1#*:}\n        __crt__mark_task_as_stopped \"${index}\" \"${code}\"\n        __crt__codes[\"${index}\"]=${code}\n        __crt__draw_status \"${index}\" \"${code}\"\n        cp -- \"${__crt__status_dir}/${index}\" \"${CONCURRENT_LOG_DIR}/${index}. ${__crt__names[${index}]//\\//-} (${code}).log\"\n        if [[ \"${code}\" != \"0\" ]]; then\n            __crt__final_status=1\n        fi\n        __crt__start_allowed_tasks\n    }\n\n    __crt__manage_meta() {\n        local index=${1%%:*}\n        local meta=${1#*:}\n        __crt__meta[\"${index}\"]=${meta}\n        __crt__draw_meta \"${index}\"\n    }\n\n    #\n    # Argument Parsing\n    #\n\n    __crt__names=()        # task names by index\n    __crt__meta=()         # metadata strings by index\n    __crt__pending=()      # indexes of tasks which haven't been started yet\n    __crt__codes=()        # task exit codes (unset, 0-255, 'skip', or 'int') by index\n    __crt__groups=()       # array of task indexes before which --and-then flags were specified\n    __crt__task_count=0    # total number of tasks\n    __crt__final_status=0  # 0 if all tasks succeeded, 1 otherwise\n    __crt__interrupted=0   # 1 if script has been interrupted, 0 otherwise\n\n    # Only allow this many tasks running at a time.\n    export CONCURRENT_LIMIT=${CONCURRENT_LIMIT:-50}\n    __crt__running_task_count=0\n\n    __crt__success_task_count=0\n    __crt__failure_task_count=0\n    __crt__skipped_task_count=0\n    __crt__interrupted_task_count=0\n\n    # Arrays of command arguments by task index <T>:\n    #   __crt__command_<T>=(...)\n    #\n    # Arrays of prerequisite task indices by task index <T>:\n    #   __crt__prereqs_<T>=(...)\n    #\n    # These are dynamically created during argument parsing since bash doesn't\n    # have a concept of nested lists.\n\n    __crt__args__task_delimiter=${1}\n\n    __crt__args__is_task_flag()        { [[ \"${1}\" == \"${__crt__args__task_delimiter}\" ]]; }\n    __crt__args__is_group_flag()       { [[ \"${1}\" == \"--and-then\"    ]]; }\n    __crt__args__is_require_flag()     { [[ \"${1}\" == \"--require\"     ]]; }\n    __crt__args__is_require_all_flag() { [[ \"${1}\" == \"--require-all\" ]]; }\n    __crt__args__is_before_flag()      { [[ \"${1}\" == \"--before\"      ]]; }\n    __crt__args__is_before_all_flag()  { [[ \"${1}\" == \"--before-all\"  ]]; }\n    __crt__args__is_sequential_flag()  { [[ \"${1}\" == \"--sequential\"  ]]; }\n\n    __crt__args__is_flag_starting_section() {\n        __crt__args__is_task_flag \"${1}\" ||\n        __crt__args__is_group_flag \"${1}\" ||\n        __crt__args__is_require_flag \"${1}\" ||\n        __crt__args__is_require_all_flag \"${1}\" ||\n        __crt__args__is_sequential_flag \"${1}\"\n    }\n\n    __crt__args__is_item_in_array() {\n        local item_to_find=${1}\n        local array_name=\"${2}[@]\"\n        local i\n        for i in \"${!array_name}\"; do\n            if [[ \"${i}\" == \"${item_to_find}\" ]]; then return 0; fi\n        done\n        return 1\n    }\n\n    __crt__args__get_tasks_not_in() {\n        local these_tasks=${1}\n        local other_tasks=()\n        local i\n\n        for (( i = 0; i < __crt__task_count; i++ )); do\n            __crt__args__is_item_in_array \"${i}\" \"${these_tasks}\" || other_tasks=(${other_tasks[@]} ${i})\n        done\n\n        __crt__args__fn_result=(\"${other_tasks[@]}\")\n    }\n\n    __crt__args__assign_sequential_prereqs() {\n        local i\n        for (( i = 1; i < __crt__task_count; i++ )); do\n            declare -g -a \"__crt__prereqs_${i}=($(( i - 1 )))\"\n        done\n    }\n\n    __crt__args__handle_task_flag() {\n        set -- \"${remaining_args[@]}\"\n\n        shift; (( $# )) || __crt__error \"expected task name after '-'\"\n        __crt__names+=(\"${1}\")\n        shift; (( $# )) || __crt__error \"expected command after task name\"\n        local args=()\n        while (( $# )) && ! __crt__args__is_flag_starting_section \"${1}\"; do\n            args+=(\"${1}\")\n            shift\n        done\n        if __crt__is_dry_run; then\n            args=(sleep 3)  # DRY RUN: Sleep for 3 seconds instead of running a real command.\n        fi\n        declare -g -a \"__crt__command_${__crt__task_count}=(\\\"\\${args[@]}\\\")\"\n        __crt__pending+=(\"${__crt__task_count}\")\n        (( __crt__task_count++ )) || :\n\n        remaining_args=(\"${@}\")\n    }\n\n    __crt__args__handle_group_flag() {\n        set -- \"${remaining_args[@]}\"\n        shift\n        __crt__groups+=(\"${__crt__task_count}\")\n        remaining_args=(\"${@}\")\n    }\n\n    __crt__args__handle_sequential_flag() {\n        set -- \"${remaining_args[@]}\"\n        shift\n        __crt__args__assign_sequential_prereqs\n        remaining_args=(\"${@}\")\n    }\n\n    __crt__args__handle_require_flag() {\n        set -- \"${remaining_args[@]}\"\n\n        local require\n        local before\n\n        while (( $# )) && __crt__args__is_require_flag \"${1}\"; do\n            shift; (( $# )) || __crt__error \"expected task name after '--require'\"\n            require=(${require[@]} $(__crt__name_index \"${1}\"))\n            shift\n        done\n\n        if __crt__args__is_before_all_flag \"${1}\"; then\n            shift\n            __crt__args__get_tasks_not_in 'require'; before=(\"${__crt__args__fn_result[@]}\")\n            local b\n            for b in \"${before[@]}\"; do\n                declare -g -a \"__crt__prereqs_${b}=(\\${require[@]})\"\n            done\n        elif __crt__args__is_before_flag \"${1}\"; then\n            while (( $# )) && __crt__args__is_before_flag \"${1}\"; do\n                shift; (( $# )) || __crt__error \"expected task name after '--before'\"\n                before=$(__crt__name_index \"${1}\")\n                shift\n                if __crt__args__is_item_in_array \"${before}\" \"require\"; then\n                    __crt__error \"task cannot require itself\"\n                fi\n                declare -g -a \"__crt__prereqs_${before}=(\\${__crt__prereqs_${before}[@]} \\${require[@]})\"\n            done\n        else\n            __crt__error \"expected '--before' or '--before-all' after '--require-all'\"\n        fi\n\n        remaining_args=(\"${@}\")\n    }\n\n    __crt__args__handle_require_all_flag() {\n        set -- \"${remaining_args[@]}\"\n\n        local require\n        local before\n\n        shift\n        if __crt__args__is_before_all_flag \"${1}\"; then\n            shift\n            __crt__args__assign_sequential_prereqs  # --require-all --before-all is the same as --sequential\n        elif __crt__args__is_before_flag \"${1}\"; then\n            before=()\n            while (( $# )) && __crt__args__is_before_flag \"${1}\"; do\n                shift; (( $# )) || __crt__error \"expected task name after '--before'\"\n                before=(${before[@]} $(__crt__name_index \"${1}\"))\n                shift\n            done\n            __crt__args__get_tasks_not_in 'before'; require=(\"${__crt__args__fn_result[@]}\")\n            local b\n            for b in \"${before[@]}\"; do\n                declare -g -a \"__crt__prereqs_${b}=(\\${require[@]})\"\n            done\n        else\n            __crt__error \"expected '--before' or '--before-all' after '--require-all'\"\n        fi\n\n        remaining_args=(\"${@}\")\n    }\n\n    __crt__args__resolve_group_prereqs() {\n        local curr_index\n        local task_index\n        local curr_group\n        local next_group\n        local prev_group=0\n\n        # All tasks in group N are prereqs for all tasks in group N+1. If N+1\n        # does not exist, use the task count instead.\n        for (( curr_index = 0; curr_index < ${#__crt__groups[@]}; curr_index++ )); do\n            curr_group=${__crt__groups[${curr_index}]}\n            next_group=${__crt__groups[$(( curr_index + 1 ))]:-${__crt__task_count}}\n            for (( task_index = curr_group; task_index < next_group; task_index++ )); do\n                declare -g -a \"__crt__prereqs_${task_index}=(\\${__crt__prereqs_${task_index}[@]} {${prev_group}..$(( curr_group - 1 ))})\"\n            done\n            prev_group=${curr_group}\n        done\n\n        # No longer need this array up in our business.\n        unset __crt__groups\n    }\n\n    __crt__args__ensure_no_requirement_loops() (\n        # We will do a lightweight dry-run through all of the tasks and make sure we\n        # do not get stuck anywhere.\n        tasks_started=0\n\n        is_task_allowed_to_start() {\n            local task=${1}\n            [[ -n \"${__crt__pending[${task}]}\" ]] || return 1\n            local requires\n            local prereqs=\"__crt__prereqs_${task}[@]\"\n            for requires in \"${!prereqs}\"; do\n                [[ -z \"${__crt__pending[${requires}]}\" ]] || return 1\n            done\n        }\n\n        start_allowed_tasks() {\n            tasks_started=0\n            local i\n            for i in \"${__crt__pending[@]}\"; do\n                if is_task_allowed_to_start \"${i}\"; then\n                    start_task \"${i}\"\n                    (( tasks_started++ )) || :\n                fi\n            done\n        }\n\n        start_task() {\n            unset \"__crt__pending[${1}]\"\n        }\n\n        while true; do\n            start_allowed_tasks\n            [[ \"${#__crt__pending[@]}\" != 0 ]] || break\n            [[ \"${tasks_started}\" -gt 0 ]] || __crt__error \"detected requirement loop\"\n        done\n    )\n\n    __crt__args__parse() {\n        local remaining_args=(\"${@}\")\n\n        while (( ${#remaining_args} )); do\n            if __crt__args__is_task_flag \"${remaining_args[0]}\"; then\n                __crt__args__handle_task_flag\n            elif __crt__args__is_group_flag \"${remaining_args[0]}\"; then\n                __crt__args__handle_group_flag\n            elif __crt__args__is_require_flag \"${remaining_args[0]}\"; then\n                __crt__args__handle_require_flag\n            elif __crt__args__is_require_all_flag \"${remaining_args[0]}\"; then\n                __crt__args__handle_require_all_flag\n            elif __crt__args__is_sequential_flag \"${remaining_args[0]}\"; then\n                __crt__args__handle_sequential_flag\n            else\n                __crt__error \"unexpected argument '${remaining_args[0]}'\"\n            fi\n        done\n\n        __crt__args__resolve_group_prereqs\n        __crt__args__ensure_no_requirement_loops\n        __crt__unset 'args'\n    }\n\n    __crt__args__parse \"${@}\"\n\n    #\n    # Status Updates\n    #\n\n    # Default to an interactive status display.\n    export CONCURRENT_NONINTERACTIVE=${CONCURRENT_NONINTERACTIVE:-0}\n\n    # If the terminal isn't attached to a tty, disable the interactive display.\n    [[ -t 1 ]] || export CONCURRENT_NONINTERACTIVE=1\n\n    # Keep track of how far we're nested inside concurrent instances.\n    export CONCURRENT_DEPTH=${CONCURRENT_DEPTH:--1}\n    (( CONCURRENT_DEPTH++ )) || :\n\n    # Default versions of these functions which can be overwritten later.\n    __crt__draw_meta                () { :; }\n    __crt__start_animation          () { :; }\n    __crt__stop_animation           () { :; }\n    __crt__enable_echo              () { :; }\n    __crt__disable_echo             () { :; }\n    __crt__draw_initial_tasks       () { :; }\n    __crt__move_cursor_to_top       () { :; }\n    __crt__move_cursor_below_status () { :; }\n    __crt__draw_status              () { :; }\n    __crt__hide_cursor              () { :; }\n    __crt__show_cursor              () { :; }\n\n    if [[ \"${CONCURRENT_NONINTERACTIVE}\" != \"0\" ]]; then\n\n        __crt__draw_status() {\n            # ${1} (index) is irrelevant\n            local code=${2}\n            __crt__draw_task \"${code}\"\n        }\n\n        __crt__draw_task() {\n            local code=${1}\n            if   [[ \"${code}\" == \"running\" ]]; then return 0\n            elif [[ \"${code}\" == \"int\"     ]]; then printf \" %s \" 'SIGINT'\n            elif [[ \"${code}\" == \"skip\"    ]]; then printf \" %s \" ' SKIP '\n            elif [[ \"${code}\" == \"0\"       ]]; then printf \" %s \" '  OK  '\n            else                                    printf \" %s \" 'FAILED'\n            fi\n            printf \"%s %s\\n\" \"${__crt__names[${index}]}\" \"${__crt__meta[${index}]}\"\n        }\n\n    elif [[ \"${CONCURRENT_DEPTH}\" -le 0 ]]; then\n\n        __crt__disable_echo() {\n            # Disable local echo so the user can't mess up the pretty display.\n            stty -echo\n        }\n\n        __crt__enable_echo() {\n            # Enable local echo so user can type again. (Simply exiting the subshell\n            # is not sufficient to reset this, which is surprising.)\n            stty echo\n        }\n\n        __crt__hide_cursor() {\n            tput civis\n        }\n\n        __crt__show_cursor() {\n            tput cnorm\n        }\n\n        __crt__txtred='\\e[0;31m' # Red\n        __crt__txtgrn='\\e[0;32m' # Green\n        __crt__txtylw='\\e[0;33m' # Yellow\n        __crt__txtblu='\\e[0;34m' # Blue\n        __crt__txtbld='\\e[1m'    # Bold\n        __crt__txtrst='\\e[0m'    # Text Reset\n        __crt__txtclr='\\e[0K'    # Clear to end of line\n\n        export CONCURRENT_COMPACT=${CONCURRENT_COMPACT:-0}\n\n        __crt__use_compact_status() {\n            [[ \"${CONCURRENT_COMPACT}\" != \"0\" || \"${__crt__task_count}\" -ge \"$(tput lines)\" ]]\n        }\n\n        if __crt__use_compact_status; then\n            __crt__cols=$(tput cols)\n\n            __crt__draw_initial_tasks() {\n                # task lines + most recent update lines + summary lines\n                local rows=$(( __crt__task_count / __crt__cols + 4 ))\n                local row\n                for (( row = 0; row < rows; row++ )); do echo; done\n                tput cuu \"${rows}\"\n                tput sc\n            }\n\n            __crt__move_cursor_to_top() {\n                tput rc\n            }\n\n            __crt__move_cursor_to_first_task() {\n                __crt__move_cursor_to_top\n                tput cud 2\n            }\n\n            __crt__requires_newline_after_tasks() {\n                [[ $(( __crt__task_count % __crt__cols )) -ne 0 ]]\n            }\n\n            if __crt__requires_newline_after_tasks; then\n                __crt__move_cursor_below_tasks() {\n                    __crt__move_cursor_to_index \"${__crt__task_count}\"\n                    echo\n                }\n            else\n                __crt__move_cursor_below_tasks() {\n                    __crt__move_cursor_to_index \"${__crt__task_count}\"\n                }\n            fi\n\n            __crt__move_cursor_below_status() {\n                __crt__move_cursor_below_tasks\n                echo\n                tput el\n                tput cuu 1\n            }\n\n            __crt__move_cursor_to_index() {\n                local index=${1}\n                local col=$(( index % __crt__cols ))\n                local row=$(( index / __crt__cols ))\n                __crt__move_cursor_to_first_task\n                [[ \"${col}\" -eq 0 ]] || tput cuf \"${col}\"\n                [[ \"${row}\" -eq 0 ]] || tput cud \"${row}\"\n            }\n\n            __crt__draw_status() {\n                local index=${1}\n                local code=${2}\n                __crt__move_cursor_to_top\n                __crt__draw_summary\n                __crt__move_cursor_to_index \"${index}\"\n                __crt__draw_task \"${code}\"\n                __crt__move_cursor_below_tasks\n                [[ \"${code}\" == \"running\" ]] || __crt__draw_recent_verbose_task \"${index}\" \"${code}\"\n                __crt__move_cursor_to_top\n            }\n\n            __crt__draw_task() {\n                local code=${1}\n                if   [[ \"${code}\" == \"int\"     ]]; then printf \"${__crt__txtred}%c${__crt__txtrst}\" '!'\n                elif [[ \"${code}\" == \"skip\"    ]]; then printf \"${__crt__txtylw}%c${__crt__txtrst}\" '-'\n                elif [[ \"${code}\" == \"running\" ]]; then printf \"${__crt__txtblu}%c${__crt__txtrst}\" '>'\n                elif [[ \"${code}\" == \"0\"       ]]; then printf '.'\n                else                                    printf \"${__crt__txtred}%c${__crt__txtrst}\" 'X'\n                fi\n            }\n\n            __crt__draw_recent_verbose_task() {\n                local index=${1}\n                local code=${2}\n                local meta=${__crt__meta[${index}]}\n                if   [[ \"${code}\" == \"int\"     ]]; then printf \"\\n ${__crt__txtred}%s${__crt__txtrst} \" 'SIGINT'\n                elif [[ \"${code}\" == \"skip\"    ]]; then printf \"\\n ${__crt__txtylw}%s${__crt__txtrst} \" ' SKIP '\n                elif [[ \"${code}\" == \"0\"       ]]; then printf \"\\n ${__crt__txtgrn}%s${__crt__txtrst} \" '  OK  '\n                else                                    printf \"\\n ${__crt__txtred}%s${__crt__txtrst} \" 'FAILED'\n                fi\n                printf \"%s\" \"${__crt__names[${index}]}\"\n                if [[ -n \"${meta}\" ]]; then printf \" ${__crt__txtbld}%s${__crt__txtrst}\" \"${meta}\"\n                fi\n                tput el  # clear to the end of the line in case the task previously displayed was longer\n            }\n\n            __crt__draw_summary() {\n                local percent=$(( ${#__crt__codes[@]} * 100 / __crt__task_count ))\n                local success=\"  ${__crt__success_task_count} passed\"\n                local failure\n                local skipped\n                local interrupted\n                [[ \"${__crt__failure_task_count}\"     -eq 0 ]] || failure=\"  ${__crt__failure_task_count} failed\"\n                [[ \"${__crt__skipped_task_count}\"     -eq 0 ]] || skipped=\"  ${__crt__skipped_task_count} skipped\"\n                [[ \"${__crt__interrupted_task_count}\" -eq 0 ]] || interrupted=\"  ${__crt__interrupted_task_count} interrupted\"\n                printf \" %3d%% %s%s%s%s\\n\\n\" \\\n                    \"${percent}\" \\\n                    \"${success}\" \\\n                    \"${failure}\" \\\n                    \"${skipped}\" \\\n                    \"${interrupted}\"\n            }\n        else\n            __crt__seconds_between_frames=1.0\n            __crt__running_status_current_frame=0\n            __crt__running_status_frames=(\n                \" ${__crt__txtblu}    =>${__crt__txtrst} \"\n                \" ${__crt__txtblu}     >${__crt__txtrst} \"\n            )\n\n            __crt__start_animation() {\n                __crt__update_running_status_frames\n                while true; do\n                    sleep \"${__crt__seconds_between_frames}\"\n                    echo \"anim:\" >> \"${__crt__event_pipe}\"\n                done &\n                __crt__animation_pid=$!\n            }\n\n            __crt__stop_animation() {\n                __crt__hide_failure kill \"${__crt__animation_pid}\"\n                __crt__hide_failure wait \"${__crt__animation_pid}\"\n            }\n\n            __crt__move_cursor_to_top() {\n                tput cuu \"${__crt__task_count}\"\n                tput sc\n            }\n\n            __crt__move_cursor_below_tasks() {\n                tput cud \"${__crt__task_count}\"\n                tput sc\n            }\n\n            __crt__move_cursor_below_status() {\n                __crt__move_cursor_below_tasks\n            }\n\n            __crt__draw_initial_tasks() {\n                local i\n                for (( i = 0; i < __crt__task_count; i++ )); do\n                    echo \"        ${__crt__names[${i}]}\"\n                done\n            }\n\n            __crt__move_cursor_to_index() {\n                local index=${1}\n                [[ \"${index}\" -eq 0 ]] || tput cud \"${index}\"\n            }\n\n            __crt__draw_status() {\n                local index=${1}\n                local code=${2}\n                tput rc\n                __crt__move_cursor_to_index \"${index}\"\n                __crt__draw_task \"${code}\"\n                tput rc\n            }\n\n            __crt__draw_task() {\n                local code=${1}\n                if   [[ \"${code}\" == \"running\" ]]; then __crt__draw_running_status\n                elif [[ \"${code}\" == \"int\"     ]]; then printf \" ${__crt__txtred}%s${__crt__txtrst} \" 'SIGINT'\n                elif [[ \"${code}\" == \"skip\"    ]]; then printf \" ${__crt__txtylw}%s${__crt__txtrst} \" ' SKIP '\n                elif [[ \"${code}\" == \"0\"       ]]; then printf \" ${__crt__txtgrn}%s${__crt__txtrst} \" '  OK  '\n                else                                    printf \" ${__crt__txtred}%s${__crt__txtrst} \" 'FAILED'\n                fi\n            }\n\n            __crt__draw_running_status() {\n                # shellcheck disable=SC2059\n                printf \"${__crt__running_status_frames[${__crt__running_status_current_frame}]}\"\n            }\n\n            __crt__draw_meta() {\n                local index=${1}\n                tput rc\n                __crt__move_cursor_to_index \"${index}\"\n                tput cuf 8  # move past status\n                printf \"%s ${__crt__txtbld}%s${__crt__txtrst}${__crt__txtclr}\" \"${__crt__names[${index}]}\" \"${__crt__meta[${index}]}\"\n                tput rc\n            }\n\n            __crt__update_running_status_frames() {\n                local i\n                for (( i = 0; i < __crt__task_count; i++ )); do\n                    if __crt__is_task_running \"${i}\"; then\n                        __crt__draw_status \"${i}\" running\n                    fi\n                done\n                __crt__running_status_current_frame=$((\n                    (__crt__running_status_current_frame + 1) % ${#__crt__running_status_frames[@]}\n                ))\n            }\n        fi\n    fi\n\n    __crt__indent() {\n        sed 's/^/    /' \"${@}\"\n    }\n\n    __crt__print_failures() {\n        cd \"${__crt__status_dir}\"\n        local i\n        for (( i = 0; i < __crt__task_count; i++ )); do\n            if [[ \"${__crt__codes[${i}]}\" != '0' ]]; then\n                printf \"\\n['%s' failed with exit status %s]\\n\" \"${__crt__names[${i}]}\" \"${__crt__codes[${i}]}\"\n                __crt__indent \"${i}\"\n            fi\n        done\n    }\n\n    __crt__print_log_location() {\n        if [[ \"${__crt__final_status}\" != \"0\" && \"${CONCURRENT_DEPTH}\" -eq 0 ]]; then\n            printf '\\nLogs for all tasks can be found in:\\n    %s\\n' \"${CONCURRENT_LOG_DIR}/\"\n        fi\n    }\n\n    __crt__status_cleanup() {\n        trap -- - INT  # no longer need special sigint handling\n        __crt__move_cursor_below_status\n        __crt__print_failures\n        __crt__print_log_location\n    }\n\n    #\n    # Signal Handling/General Cleanup\n    #\n\n    __crt__exit_by_signal() {\n        # Proper sigint handling: http://www.cons.org/cracauer/sigint.html\n        local signal=${1}\n        # shellcheck disable=SC2064\n        trap -- - \"${signal}\"    # reset the signal\n        kill \"-${signal}\" -- $$  # re-raise the signal\n        exit 255                 # don't resume the script\n    }\n\n    __crt__handle_exit() {\n        rm -rf \"${__crt__status_dir}\"\n        __crt__hide_failure __crt__restore_stdin_stream\n        __crt__hide_failure __crt__enable_echo\n        __crt__hide_failure __crt__show_cursor\n    }\n\n    __crt__handle_sigint() {\n        CONCURRENT_LIMIT=-1\n        __crt__interrupted=1\n        __crt__clear_event_pipe\n        __crt__cleanup_event_loop\n        __crt__mark_all_running_tasks_as_interrupted\n        __crt__run_event_loop\n        __crt__status_cleanup\n        __crt__stop_animation\n        __crt__hide_failure wait\n        __crt__exit_by_signal INT\n    }\n\n    export CONCURRENT_LOG_DIR=${CONCURRENT_LOG_DIR:-${PWD}/.logs/$(date +'%F@%T')}\n    mkdir -p \"${CONCURRENT_LOG_DIR}\"\n\n    __crt__disable_echo || __crt__error 'Must be run in the foreground of an interactive shell!'\n    __crt__status_dir=$(mktemp -d \"${TMPDIR:-/tmp}/concurrent.lib.sh.XXXXXXXXXXX\")\n    __crt__event_pipe=\"${__crt__status_dir}/event-pipe\"\n    __crt__clear_event_pipe\n\n    trap -- __crt__handle_exit EXIT\n    trap -- __crt__handle_sigint INT\n\n    if __crt__is_dry_run; then\n        # shellcheck disable=SC2016\n        echo '>>> DRY RUN (concurrent): The \"$CONCURRENT_DRY_RUN\" environment variable is set. <<<'\n    fi\n\n    __crt__hide_cursor\n    __crt__start_all_tasks\n    __crt__wait_for_all_tasks\n    __crt__show_cursor\n\n    exit ${__crt__final_status}\n)\n"
        },
        {
          "name": "demo.sh",
          "type": "blob",
          "size": 4.30078125,
          "content": "#!/usr/bin/env bash\n\nset -e -o pipefail\n\n# shellcheck source=concurrent.lib.sh\nsource \"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)/concurrent.lib.sh\"\n\nsuccess() {\n    local args=(\n        - \"Creating VM\"                                         create_vm    3.0\n        - \"Creating ramdisk\"                                    my_sleep     0.1\n        - \"Enabling swap\"                                       my_sleep     0.1\n        - \"Populating VM with world data\"                       restore_data 5.0\n        - \"Spigot: Pulling docker image for build\"              my_sleep     0.5\n        - \"Spigot: Building JAR\"                                my_sleep     6.0\n        - \"Pulling remaining docker images\"                     my_sleep     2.0\n        - \"Launching services\"                                  my_sleep     0.2\n\n        --require \"Creating VM\"\n        --before  \"Creating ramdisk\"\n        --before  \"Enabling swap\"\n\n        --require \"Creating ramdisk\"\n        --before  \"Populating VM with world data\"\n        --before  \"Spigot: Pulling docker image for build\"\n\n        --require \"Spigot: Pulling docker image for build\"\n        --before  \"Spigot: Building JAR\"\n        --before  \"Pulling remaining docker images\"\n\n        --require \"Populating VM with world data\"\n        --require \"Spigot: Building JAR\"\n        --require \"Pulling remaining docker images\"\n        --before  \"Launching services\"\n    )\n\n    concurrent \"${args[@]}\"\n}\n\nfailure() {\n    local args=(\n        - \"Creating VM\"                                         create_vm    3.0\n        - \"Creating ramdisk\"                                    my_sleep     0.1\n        - \"Enabling swap\"                                       my_sleep     0.1\n        - \"Populating VM with world data\"                       restore_data 0.0 64\n        - \"Spigot: Pulling docker image for build\"              my_sleep     0.5 128\n        - \"Spigot: Building JAR\"                                my_sleep     6.0\n        - \"Pulling remaining docker images\"                     my_sleep     2.0\n        - \"Launching services\"                                  my_sleep     0.2\n\n        --require \"Creating VM\"\n        --before  \"Creating ramdisk\"\n        --before  \"Enabling swap\"\n\n        --require \"Creating ramdisk\"\n        --before  \"Populating VM with world data\"\n        --before  \"Spigot: Pulling docker image for build\"\n\n        --require \"Spigot: Pulling docker image for build\"\n        --before  \"Spigot: Building JAR\"\n        --before  \"Pulling remaining docker images\"\n\n        --require \"Populating VM with world data\"\n        --require \"Spigot: Building JAR\"\n        --require \"Pulling remaining docker images\"\n        --before  \"Launching services\"\n    )\n\n    concurrent \"${args[@]}\"\n}\n\nnesting_success() {\n    local args=(\n        - \"Task A1\"               my_sleep 2.0\n        - \"Task A2\"               concurrent\n            -- \"Task B1\"          concurrent\n                --- \"Task C1\"     my_sleep 1.0\n                --- \"Task C2\"     my_sleep 2.0\n            -- \"Task B2\"          my_sleep 3.0\n        - \"Task A3\"               my_sleep 4.0\n    )\n\n    concurrent \"${args[@]}\"\n}\n\nnesting_failure() {\n    local args=(\n        - \"Task A1\"               my_sleep 2.0\n        - \"Task A2\"               concurrent\n            -- \"Task B1\"          concurrent\n                --- \"Task C1\"     my_sleep 1.0\n                --- \"Task C2\"     my_sleep 2.0 1\n            -- \"Task B2\"          my_sleep 3.0\n        - \"Task A3\"               my_sleep 4.0\n    )\n\n    concurrent \"${args[@]}\"\n}\n\nmany() {\n    local args=()\n    local i\n\n    for (( i = 0; i < 300; i++ )); do\n        args+=(- \"Task ${i}\" my_sleep $(( RANDOM % 5 + 1 )))\n    done\n\n    concurrent \"${args[@]}\"\n}\n\ncreate_vm() {\n    local provider=digitalocean\n    echo \"(on ${provider})\" >&3\n    my_sleep \"${@}\"\n}\n\nrestore_data() {\n    local data_source=dropbox\n    echo \"(with ${data_source})\" >&3\n    my_sleep \"${@}\"\n}\n\nmy_sleep() {\n    local seconds=${1}\n    local code=${2:-0}\n    echo \"Yay! Sleeping for ${seconds} second(s)!\"\n    sleep \"${seconds}\"\n    if [ \"${code}\" -ne 0 ]; then\n        echo \"Oh no! Terrible failure!\" 1>&2\n    fi\n    return \"${code}\"\n}\n\nmain() {\n    if [[ -n \"${1}\" ]]; then\n        \"${1}\"\n    else\n        echo\n        echo \"[SUCCESS EXAMPLE]\"\n        success\n        echo\n        echo \"[FAILURE EXAMPLE]\"\n        failure\n    fi\n}\n\nmain \"${@}\"\n"
        }
      ]
    }
  ]
}