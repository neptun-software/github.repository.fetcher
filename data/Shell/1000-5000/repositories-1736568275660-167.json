{
  "metadata": {
    "timestamp": 1736568275660,
    "page": 167,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "akinomyoga/ble.sh",
      "stars": 2870,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.041015625,
          "content": "/make/.git-archive-export.mk export-subst\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.65234375,
          "content": "# output files\n/out\n/ble.sh\n/dist\n/wiki\n/ext\n/a.func.txt\n/a.line.txt\n\n# edit files\n/COMMIT\n/[a-zA-Z0-9].txt\n/[a-zA-Z0-9].sh\n/\\*scratch\\*\n/refact.sh\n\n/[A-Z]\n/[a-zA-Z].sh\n\n# test\n/test\n/bashrc\n\n# memo\n/memo/*.exe\n/memo/D0702.HISTFILE*\n/memo/D0727/D0727.bind.*\n/memo/D0857/D0857.unbind\n/memo/D0857/D0857.bind\n/memo/D0857/D0857.pipe\n/memo/D0857/D0857.stderr\n/memo/D1881/pr227.*.txt\n/memo/D1881/pr227.*.hist\n/memo/D1881/pr227-sleep-delay.pdf\n/memo/D2014\n/memo/D2165/?.txt\n/memo/D2207.*.txt\n/memo/D2207.*.bk\n\n# make\n/make/*.exe\n/make/canvas.c2w.wcwidth.txt\n/make/*.o\n\n# files for unresolved GitHub Issues\n/gh???.*\n/gh????.*\n/X????.*\n/gh???/\n/gh????/\n\n# experiment\n/lib/*.so\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.060546875,
          "content": "[submodule \"contrib\"]\n\tpath = contrib\n\turl = ../blesh-contrib\n"
        },
        {
          "name": ".srcoption",
          "type": "blob",
          "size": 0.224609375,
          "content": "-x md:bash\n--exclude=./{out,dist,tmp,ext}\n--exclude=./?.sh\n--exclude=./test/install\n--exclude=./ble.sh\n--exclude=./gh[0-9][0-9][0-9][0-9]{,.*}\nGNUmakefile\nble.pp\nblerc.template\nlib/core-syntax-ctx.def\nlib/core-decode.*-rlfunc.txt\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 10.0400390625,
          "content": "# -*- mode: makefile-gmake -*-\n\nall:\n.PHONY: all\n\n# git version\nGIT_VERSION = $(shell LANG=C git --version)\n\n# check GNU Make\nifeq ($(.FEATURES),)\n  $(error Sorry, please use a newer version (3.81 or later) of gmake (GNU Make).)\nendif\nMAKE_VERSION := $(shell LANG=C $(MAKE) --version | head -1)\n\n# check gawk\nGAWK := $(shell which gawk 2>/dev/null || bash -c 'builtin type -P gawk' 2>/dev/null)\nifneq ($(GAWK),)\n  GAWK_VERSION := $(shell LANG=C $(GAWK) --version 2>/dev/null | sed -n '1{/[Gg][Nn][Uu] [Aa][Ww][Kk]/p;}')\n  ifeq ($(GAWK_VERSION),)\n    $(error Sorry, gawk is found but does not seem to work. Please install a proper version of gawk (GNU Awk).)\n  endif\nelse\n  GAWK := $(shell which awk 2>/dev/null || bash -c 'builtin type -P awk' 2>/dev/null)\n  ifeq ($(GAWK),)\n    $(error Sorry, gawk/awk could not be found. Please check your PATH environment variable.)\n  endif\n  GAWK_VERSION := $(shell LANG=C $(GAWK) --version 2>/dev/null | sed -n '1{/[Gg][Nn][Uu] [Aa][Ww][Kk]/p;}')\n  ifeq ($(GAWK_VERSION),)\n    $(error Sorry, gawk could not be found. Please install gawk (GNU Awk).)\n  endif\nendif\n\nMWGPP := $(GAWK) -f make/mwg_pp.awk\n\n# Note (#D2058): we had used \"cp -p xxx out/xxx\" to copy files to the build\n# directory, but some filesystem (ecryptfs) has a bug that the subsecond\n# timestamps are truncated causing an issue: make every time copies all the\n# files into the subdirectory `out`.  We give up using `cp -p` and instead copy\n# the file with `cp` with the timestamps being the copy time.\nCP := cp\n\n#------------------------------------------------------------------------------\n# ble.sh\n\nFULLVER := 0.4.0-devel4\n\nBLE_GIT_COMMIT_ID :=\nBLE_GIT_BRANCH :=\nifneq ($(wildcard .git),)\n  BLE_GIT_COMMIT_ID := $(shell git show -s --format=%h)\n  BLE_GIT_BRANCH := $(shell git rev-parse --abbrev-ref HEAD)\nelse ifneq ($(wildcard make/.git-archive-export.mk),)\n  ifeq ($(shell grep '\\$$Format:.*\\$$' make/.git-archive-export.mk),)\n    include make/.git-archive-export.mk\n  endif\nendif\nifeq ($(BLE_GIT_COMMIT_ID),)\n  $(error Failed to determine the commit id of the current tree.  The .git directory is required to build ble.sh.)\nendif\n\nOUTDIR:=out\n\noutdirs += $(OUTDIR)\n\noutfiles+=$(OUTDIR)/ble.sh\n-include $(OUTDIR)/ble.dep\n$(OUTDIR)/ble.sh: ble.pp GNUmakefile | $(OUTDIR)\n\tDEPENDENCIES_PHONY=1 DEPENDENCIES_OUTPUT=\"$(@:%.sh=%.dep)\" DEPENDENCIES_TARGET=\"$@\" \\\n\t  FULLVER=$(FULLVER) \\\n\t  BLE_GIT_COMMIT_ID=\"$(BLE_GIT_COMMIT_ID)\" \\\n\t  BLE_GIT_BRANCH=\"$(BLE_GIT_BRANCH)\" \\\n\t  BUILD_GIT_VERSION=\"$(GIT_VERSION)\" \\\n\t  BUILD_MAKE_VERSION=\"$(MAKE_VERSION)\" \\\n\t  BUILD_GAWK_VERSION=\"$(GAWK_VERSION)\" \\\n\t  $(MWGPP) $< >/dev/null\n.DELETE_ON_ERROR: $(OUTDIR)/ble.sh\n\nGENTABLE := bash make/canvas.c2w.generate-table.sh\n\nsrc/canvas.c2w.sh:\n\t$(GENTABLE) c2w\nsrc/canvas.c2w.musl.sh: make/canvas.c2w.wcwidth.cpp make/canvas.c2w.wcwidth-musl.cpp\n\t+make -C make canvas.c2w.wcwidth.exe\n\tmake/canvas.c2w.wcwidth.exe table_musl2014 | $(GENTABLE) convert-custom-c2w _ble_util_c2w_musl > $@\nsrc/canvas.emoji.sh:\n\t$(GENTABLE) emoji\nsrc/canvas.GraphemeClusterBreak.sh:\n\t$(GENTABLE) GraphemeClusterBreak\n\n# Note: the following line is a workaround for the missing\n#   DEPENDENCIES_PHONY option for mwg_pp in older Makefile\nble-form.sh:\n\n#------------------------------------------------------------------------------\n# lib\n\noutdirs += $(OUTDIR)/lib\n\n# keymap\noutfiles += $(OUTDIR)/lib/keymap.emacs.sh\noutfiles += $(OUTDIR)/lib/keymap.vi.sh\noutfiles += $(OUTDIR)/lib/keymap.vi_digraph.sh\noutfiles += $(OUTDIR)/lib/keymap.vi_digraph.txt\n\n# init\noutfiles += $(OUTDIR)/lib/init-term.sh\noutfiles += $(OUTDIR)/lib/init-bind.sh\noutfiles += $(OUTDIR)/lib/init-cmap.sh\noutfiles += $(OUTDIR)/lib/init-msys1.sh\n\n# core\noutfiles += $(OUTDIR)/lib/core-complete.sh\noutfiles += $(OUTDIR)/lib/core-syntax.sh\noutfiles += $(OUTDIR)/lib/core-test.sh\noutfiles += $(OUTDIR)/lib/core-cmdspec.sh\noutfiles += $(OUTDIR)/lib/core-debug.sh\noutfiles += $(OUTDIR)/lib/core-edit.ignoreeof-messages.txt\noutfiles += $(OUTDIR)/lib/core-decode.emacs-rlfunc.txt\noutfiles += $(OUTDIR)/lib/core-decode.vi_imap-rlfunc.txt\noutfiles += $(OUTDIR)/lib/core-decode.vi_nmap-rlfunc.txt\n\n# vim\noutfiles += $(OUTDIR)/lib/vim-surround.sh\noutfiles += $(OUTDIR)/lib/vim-arpeggio.sh\noutfiles += $(OUTDIR)/lib/vim-airline.sh\n\n# test\noutfiles += $(OUTDIR)/lib/test-bash.sh\noutfiles += $(OUTDIR)/lib/test-main.sh\noutfiles += $(OUTDIR)/lib/test-util.sh\noutfiles += $(OUTDIR)/lib/test-canvas.sh\noutfiles += $(OUTDIR)/lib/test-decode.sh\noutfiles += $(OUTDIR)/lib/test-edit.sh\noutfiles += $(OUTDIR)/lib/test-syntax.sh\noutfiles += $(OUTDIR)/lib/test-complete.sh\noutfiles += $(OUTDIR)/lib/test-keymap.vi.sh\noutfiles += $(OUTDIR)/lib/util.bgproc.sh\n\n$(OUTDIR)/lib/%.sh: lib/%.sh | $(OUTDIR)/lib\n\t$(CP) $< $@\n$(OUTDIR)/lib/%.txt: lib/%.txt | $(OUTDIR)/lib\n\t$(CP) $< $@\n$(OUTDIR)/lib/core-syntax.sh: lib/core-syntax.sh lib/core-syntax-ctx.def | $(OUTDIR)/lib\n\t$(MWGPP) $< > $@\n$(OUTDIR)/lib/init-msys1.sh: lib/init-msys1.sh lib/init-msys1-helper.c | $(OUTDIR)/lib\n\t$(MWGPP) $< > $@\n$(OUTDIR)/lib/test-canvas.sh: lib/test-canvas.sh lib/test-canvas.GraphemeClusterTest.sh | $(OUTDIR)/lib\n\t$(MWGPP) $< > $@\n\noutfiles += $(OUTDIR)/lib/benchmark.ksh\n$(OUTDIR)/lib/benchmark.ksh: lib/benchmark.ksh src/benchmark.sh\n\t$(MWGPP) $< > $@\n\n#outfiles += $(OUTDIR)/lib/init-msleep.sh\n#$(OUTDIR)/lib/init-msleep.sh: lib/init-msleep.sh lib/init-msleep.c | $(OUTDIR)/lib\n#\t$(MWGPP) $< > $@\n\n# いつか削除する\nremovedfiles += \\\n  keymap/emacs.rlfunc.txt \\\n  keymap/emacs.sh \\\n  keymap/isearch.sh \\\n  keymap/vi.sh \\\n  keymap/vi_digraph.sh \\\n  keymap/vi_digraph.txt \\\n  keymap/vi_imap.rlfunc.txt \\\n  keymap/vi_nmap.rlfunc.txt \\\n  keymap/vi_test.sh \\\n  lib/keymap.vi_test.sh\n\n#------------------------------------------------------------------------------\n# licenses and documents\n\noutdirs += $(OUTDIR)/licenses $(OUTDIR)/doc\noutfiles-license += $(OUTDIR)/licenses/LICENSE.md\nifneq ($(USE_DOC),no)\n  outfiles-doc += $(OUTDIR)/doc/README.md\n  outfiles-doc += $(OUTDIR)/doc/README-ja_JP.md\n  outfiles-doc += $(OUTDIR)/doc/CONTRIBUTING.md\n  outfiles-doc += $(OUTDIR)/doc/ChangeLog.md\n  outfiles-doc += $(OUTDIR)/doc/Release.md\nendif\n\n# Workaround for make-3.81 (#D2065)\n#\n# We want to do something like the following:\n#\n#   $(OUTDIR)/license/%.md: %.md | $(OUTDIR)/license\n#   \t$(CP) $< $@\n#   $(OUTDIR)/doc/%.md: %.md | $(OUTDIR)/doc\n#   \t$(CP) $< $@\n#\n# However, because of a bug in make-3.81, this rule overrides all the other\n# more detailed patterns such as $(OUTDIR)/doc/contrib/%.md.  As a result, even\n# when we want to apply preprocessing to specific file patterns under\n# $(OUTDIR)/doc/%, $(CP) is always is used to install the files.  To work\n# around this problem in make-3.81, we need to manually filter the target files\n# whose source files are at the top level in the source tree.\n#\noutfiles-doc-toplevel := \\\n  $(filter $(outfiles-doc),$(patsubst %,$(OUTDIR)/doc/%,$(wildcard *.md)))\n$(outfiles-doc-toplevel): $(OUTDIR)/doc/%.md: %.md | $(OUTDIR)/doc\n\t$(CP) $< $@\noutfiles-license-toplevel := \\\n  $(filter $(outfiles-license),$(patsubst %,$(OUTDIR)/licenses/%,$(wildcard *.md)))\n$(outfiles-license-toplevel): $(OUTDIR)/licenses/%.md: %.md | $(OUTDIR)/licenses\n\t$(CP) $< $@\n\n$(OUTDIR)/doc/%: docs/% | $(OUTDIR)/doc\n\t$(CP) $< $@\n\n#------------------------------------------------------------------------------\n# contrib\n\n.PHONY: update-contrib\nupdate-contrib contrib/contrib.mk:\n\tgit submodule update --init --recursive\n\ninclude contrib/contrib.mk\n\n#------------------------------------------------------------------------------\n# target \"all\"\n\n$(outdirs):\n\tmkdir -p $@\n\nbuild: contrib/contrib.mk $(outfiles) $(outfiles-doc) $(outfiles-license)\n.PHONY: build\n\nall: build\n\n#------------------------------------------------------------------------------\n# target \"install\"\n\n# Users can specify make variables INSDIR, INSDIR_LICENSE, and INSDIR_DOC to\n# control the install locations.  Instead of INSDIR, users may specify DESTDIR\n# and/or PREFIX to automatically set up these variables.\n\nifneq ($(INSDIR),)\n  INSDIR_LICENSE := $(INSDIR)/licenses\n  INSDIR_DOC     := $(INSDIR)/doc\nelse\n  ifneq ($(DESTDIR),)\n    DATADIR := $(abspath $(DESTDIR)/$(PREFIX)/share)\n  else ifneq ($(PREFIX),)\n    DATADIR := $(abspath $(PREFIX)/share)\n  else ifneq ($(XDG_DATA_HOME),)\n    DATADIR := $(abspath $(XDG_DATA_HOME))\n  else\n    DATADIR := $(abspath $(HOME)/.local/share)\n  endif\n\n  INSDIR         := $(DATADIR)/blesh\n  INSDIR_LICENSE := $(DATADIR)/blesh/licenses\n  INSDIR_DOC     := $(DATADIR)/doc/blesh\nendif\n\nifneq ($(strip_comment),)\n  opt_strip_comment := --strip-comment=$(strip_comment)\nelse\n  opt_strip_comment :=\nendif\n\ninsfiles         := $(outfiles:$(OUTDIR)/%=$(INSDIR)/%)\ninsfiles-license := $(outfiles-license:$(OUTDIR)/licenses/%=$(INSDIR_LICENSE)/%)\ninsfiles-doc     := $(outfiles-doc:$(OUTDIR)/doc/%=$(INSDIR_DOC)/%)\n\ninstall-files := \\\n  $(insfiles) $(insfiles-license) $(insfiles-doc) \\\n  $(INSDIR)/cache.d $(INSDIR)/run\ninstall: $(install-files)\nuninstall:\n\tbash make_command.sh uninstall $(install-files)\n.PHONY: install uninstall\n\n$(insfiles): $(INSDIR)/%: $(OUTDIR)/%\n\tbash make_command.sh install $(opt_strip_comment) \"$<\" \"$@\"\n$(insfiles-license): $(INSDIR_LICENSE)/%: $(OUTDIR)/licenses/%\n\tbash make_command.sh install \"$<\" \"$@\"\n$(insfiles-doc): $(INSDIR_DOC)/%: $(OUTDIR)/doc/%\n\tbash make_command.sh install \"$<\" \"$@\"\n$(INSDIR)/cache.d $(INSDIR)/run:\n\tmkdir -p $@ && chmod a+rwxt $@\n\nclean:\n\t-rm -rf $(outfiles) $(outfiles-doc) $(outfiles-license) $(OUTDIR)/ble.dep\n.PHONY: clean\n\ndist: $(outfiles) $(outfiles-doc) $(outfiles-license)\n\tFULLVER=$(FULLVER) bash make_command.sh dist $^\n.PHONY: dist\n\ndist_excludes= \\\n\t--exclude=./ble/backup \\\n\t--exclude=*~ \\\n\t--exclude=./ble/.git \\\n\t--exclude=./ble/out \\\n\t--exclude=./ble/dist \\\n\t--exclude=./ble/ble.sh\ndist.date:\n\tcd .. && tar cavf \"$$(date +ble.%Y%m%d.tar.xz)\" ./ble $(dist_excludes)\n.PHONY: dist.date\n\n#------------------------------------------------------------------------------\n\ndefine DeclareMakeCommand\n$1: $2\n\tbash make_command.sh $1\n.PHONY: $1\nendef\n\n$(eval $(call DeclareMakeCommand,ignoreeof-messages,))\n$(eval $(call DeclareMakeCommand,scan,))\n$(eval $(call DeclareMakeCommand,check,build))\n$(eval $(call DeclareMakeCommand,check-all,build))\n$(eval $(call DeclareMakeCommand,list-functions,))\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.4931640625,
          "content": "Copyright (c) 2013, 2015-2023, K. Murase @akinomyoga <myoga.murase@gmail.com>,\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.560546875,
          "content": "# -*- mode: makefile-bsdmake -*-\n\nall:\n.PHONY: all install\n\n.warning \u001b[1;31mThis is not GNU make. Plaese use GNU make (gmake).\u001b[m\n.warning \u001b[1mTrying to redirect to gmake...\u001b[m\n\n.ifdef INSDIR\nassign_insdir := INSDIR=\"$(INSDIR)\"\n.endif\n\n.ifdef INSDIR_DOC\nassign_insdir_doc := INSDIR_DOC=\"$(INSDIR_DOC)\"\n.endif\n\n.ifdef PREFIX\nassign_prefix := PREFIX=\"$(PREFIX)\"\n.endif\n\n.ifdef DESTDIR\nassign_destdir := DESTDIR=\"$(DESTDIR)\"\n.endif\n\nall:\n\tgmake -f GNUmakefile all\ninstall:\n\tgmake -f GNUmakefile install $(assign_insdir) $(assign_insdir_doc) $(assign_prefix) $(assign_destdir)\n\n"
        },
        {
          "name": "README-ja_JP.md",
          "type": "blob",
          "size": 49.5576171875,
          "content": "[ Languages: [English](README.md) (英語) | **日本語** ]\n\n<h1 align=\"center\"><ruby>ble.sh<rp> (</rp><rt>/blɛʃ/</rt><rp>)</rp></ruby> ―Bash Line Editor―</h1>\n<p align=\"center\">\n[ <b>README</b> | <a href=\"https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A71-%E5%9F%BA%E6%9C%AC\">説明書</a> |\n<a href=\"https://github.com/akinomyoga/ble.sh/wiki/%E8%B3%AA%E5%95%8F%E3%81%A8%E5%9B%9E%E7%AD%94\">Q&A</a> |\n<a href=\"https://github.com/akinomyoga/blesh-contrib\"><code>contrib</code></a> |\n<a href=\"https://github.com/akinomyoga/ble.sh/wiki/%E9%80%86%E5%BC%95%E3%81%8D%E3%83%AC%E3%82%B7%E3%83%94\">逆引き</a> ]\n</p>\n\n`ble.sh`<sup><a href=\"#discl-pronun\">†1</a></sup> (*Bash Line Editor*)\nはピュア Bash<sup><a href=\"#discl-pure\">†2</a></sup>\nスクリプトで書かれたコマンドラインエディタで、標準の GNU Readline を置き換える形で動作します。\n\n現在の開発バージョンは 0.4 です。\nこのスクリプトは Bash 3.0 以降で利用できますが、速度・機能などの観点から 4.0 以降のリリース版 Bash でお使い頂くことがお薦めです。\nまた POSIX の基本的なコマンドが存在することも想定しています。\n現時点では、文字コードとして `UTF-8` のみの対応です。\nこのスクリプトは [**BSD License**](LICENSE.md) (3条項 BSD ライセンス) の下で提供されます。\n\n## 簡単設定\n\n<!-- 但し、macOS では附属の `/usr/bin/awk` (awk-32 以降) でマルチバイト文字セットの問題があるため、`gawk`, `nawk`, または `mawk` を別途インストールする必要があるかもしれません。 -->\n`ble.sh` を取得するには主に2つの方法があります: `git` を用いてソースを取得しビルドする方法と、\n`curl` または `wget` を用いて [nightly ビルド](https://github.com/akinomyoga/ble.sh/releases/tag/nightly)をダウンロードする方法です。\n試用とインストール方法の詳細に関しては [節1.1](#get-from-source) と [節1.2](#get-from-tarball) を、\n`~/.bashrc` の設定の詳細に関しては [節1.3](#set-up-bashrc) を御覧ください。\n\n> [!NOTE]\n> `fzf` を `ble.sh` と組み合わせてお使いの場合は [節2.8](#fzf-integration) を必ず御覧ください。\n\n<details open><summary><b><code>git</code> を用いてソースを取得し <code>ble.sh</code> を生成</b></summary>\n\nこの方法では `git`, `make` (GNU make), 及び `gawk` が必要です。\n以下、GNU make が `gmake` として提供されているシステム (BSD など) では、`make` を `gmake` に置き換えて実行してください。\n\n```bash\n# 簡単お試し (インストールせずにお試しいただけます)\n\ngit clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git\nmake -C ble.sh\nsource ble.sh/out/ble.sh\n\n# インストール & .bashrc 簡単設定 (動かない場合は節1.3を御参照下さい)\n\ngit clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git\nmake -C ble.sh install PREFIX=~/.local\necho 'source ~/.local/share/blesh/ble.sh' >> ~/.bashrc\n```\n\n生成過程では、複数のBashスクリプトファイルを前処理・結合することで `ble.sh` を生成し、\n他の関連ファイルを正しく配置し、またソースコード中のコードコメントを削除してロードを最適化します。\n\n※生成過程は、C/C++ のコンパイルも伴わずバイナリも生成しませんので、コンパイラを準備していただく必要はありません。\n</details>\n\n<details><summary><b><code>curl</code> を用いて nightly ビルドをダウンロード</b></summary>\n\nこの方法では `curl`, `tar` (オプション `J` に対応), 及び `xz` (XZ Utils) が必要です。\n\n```bash\n# 簡単お試し (インストールせずにお試しいただけます)\n\ncurl -L https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nsource ble-nightly/ble.sh\n\n# インストール & .bashrc 簡単設定 (動かない場合は節1.3を御参照下さい)\n\ncurl -L https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nbash ble-nightly/ble.sh --install ~/.local/share\necho 'source ~/.local/share/blesh/ble.sh' >> ~/.bashrc\n```\n\nインストール後はディレクトリ `ble-nightly` は削除して問題ありません。\n</details>\n\n<details><summary><b><code>wget</code> を用いて nightly ビルドをダウンロード</b></summary>\n\nこの方法では `wget`, `tar` (オプション `J` に対応), 及び `xz` (XZ Utils) が必要です。\n\n```bash\n# 簡単お試し (インストールせずにお試しいただけます)\n\nwget -O - https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nsource ble-nightly/ble.sh\n\n# インストール & .bashrc 簡単設定 (動かない場合は節1.3を御参照下さい)\n\nwget -O - https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nbash ble-nightly/ble.sh --install ~/.local/share\necho 'source ~/.local/share/blesh/ble.sh' >> ~/.bashrc\n```\n\nインストール後はディレクトリ `ble-nightly` は削除して問題ありません。\n</details>\n\n<details open><summary><b>パッケージ管理システムを通じてパッケージをインストール</b> (現在限られたパッケージのみ)</summary>\n\nこの方法では対応するパッケージ管理ツールのみが必要です。\n\n- [AUR (Arch Linux)](https://github.com/akinomyoga/ble.sh/wiki/Manual-A1-Installation#user-content-AUR) `blesh-git` (devel), `blesh` (stable 0.3.4)\n- [NixOS (nixpkgs)](https://github.com/akinomyoga/ble.sh/wiki/Manual-A1-Installation#user-content-nixpkgs) `blesh` (devel)\n- [Guix](https://packages.guix.gnu.org/packages/blesh/0.4.0-devel2/) `blesh` (0.4.0-devel2)\n</details>\n\n<details open><summary><b>既存の <code>ble.sh</code> を更新</b></summary>\n\n```bash\n# 更新 (ble.sh をロードした状態で)\n\nble-update\n\n# 更新 (ble.sh 外部から)\n\nbash /path/to/ble.sh --update\n```\n</details>\n\n<details><summary><b><code>ble.sh</code> のパッケージ作成</b></summary>\n\n`ble.sh` は単にシェルスクリプトの集合ですので環境に依存せずにお使いいただけます (いわゆる \"`noarch`\") ので、\n単にリリースページからビルド済みの tarball をダウンロードし中身を `/tmp/blesh-package/usr/local` など所定の位置に配置するだけで問題ありません。\nそれでも何らかの理由により自前でビルドする必要がある場合には以下のコマンドをお使いください。\nビルドの為には git リポジトリ (`.git`) が必要になることにご注意ください。\n\n```bash\n# ビルド & パッケージ作成用コマンド\n\ngit clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git\nmake -C ble.sh install DESTDIR=/tmp/blesh-package PREFIX=/usr/local\n```\n\nスクリプトファイル、ライセンスファイル。ドキュメントファイルのインストール場所を詳細に指定する方法については、\n後ろの節 [インストール](#install) and [パッケージ作成](#package) を御参照ください。\n\nスクリプトファイル `_package.bash` を `${prefix}/share/blesh/lib/_package.bash` に配置することで、\n`ble-update` で用いるパッケージ更新方法を指定することができます。\n詳細については節 [`_package.bash`](#_packagebash) を御参照ください。\n\n```bash\n# ${prefix}/share/blesh/lib/_package.bash\n\n_ble_base_package_type=XXX\nfunction ble/base/package:XXX/update {\n  update-the-package-in-a-proper-way\n}\n```\n</details>\n\n## 機能概要\n\n- **構文着色**: `fish` や `zsh-syntax-highlighting` のような文法構造に従った着色を行います。\n  `zsh-syntax-highlighting` のような単純な着色ではなく、構文の入れ子構造や複数のヒアドキュメントなども正しく解析して着色します。\n  着色は[全て設定可能](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A72-%E6%8F%8F%E7%94%BB)です。\n- **補完増強**: [補完](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A77-%E8%A3%9C%E5%AE%8C)を大幅に増強します。\n  **文法構造に応じた補完**、クォートやパラメータ展開を展開した上でのプログラム補完、**曖昧補完**に対応しています。\n  また、候補をカーソルキーや <kbd>TAB</kbd>, <kbd>S-TAB</kbd> で選択できる\n  [**メニュー補完**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A77-%E8%A3%9C%E5%AE%8C#user-content-sec-menu-complete)、\n  `fish` や `zsh-autosuggestions` のような\n  [**自動補完**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A77-%E8%A3%9C%E5%AE%8C#user-content-sec-auto-complete)\n  (Bash 4.0 以上) の機能もあります。\n  更に、従来 `peco` や `fzf` を呼び出さなければならなかった補完候補の絞り込みも\n  [**メニュー絞り込み**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A77-%E8%A3%9C%E5%AE%8C#user-content-sec-menu-filter)\n  (Bash 4.0 以上) として自然な形で組み込んでいます。\n  他に、[**動的略語展開**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A77-%E8%A3%9C%E5%AE%8C#user-content-sec-dabbrev)\n  や、[*zsh abbreviations*](https://unix.stackexchange.com/questions/6152/zsh-alias-expansion)・[`zsh-abbr`](https://github.com/olets/zsh-abbr) のような\n  [**静的略語展開**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A77-%E8%A3%9C%E5%AE%8C#user-content-sec-sabbrev)\n  にも対応しています。\n- **Vim編集モード**: `set -o vi` による編集モードを増強します。\n  挿入・ノーマルモードの他に(行・矩形)ビジュアルモード、置換モードなどの各種モードに対応しています。\n  テキストオブジェクト・各種レジスタ・オペレータ・キーボードマクロなどにも対応しています。\n  拡張として `vim-surround` も提供しています。\n- 他にも\n  [**ステータス行**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A74-%E7%B7%A8%E9%9B%86#user-content-bleopt-prompt_status_line),\n  [**コマンド履歴共有**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A74-%E7%B7%A8%E9%9B%86#user-content-bleopt-history_share),\n  [**右プロンプト**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A74-%E7%B7%A8%E9%9B%86#user-content-bleopt-prompt_rps1),\n  [**過渡的プロンプト**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A74-%E7%B7%A8%E9%9B%86#user-content-bleopt-prompt_ps1_transient),\n  [**xterm タイトル**](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A74-%E7%B7%A8%E9%9B%86#user-content-bleopt-prompt_xterm_title),\n  など様々な機能に対応しています。\n\n注意: `ble.sh` は、(プロンプト (`PS1`)、エイリアス、関数などを提供する) 典型的な Bash 設定集と異なります。\n`ble.sh` はより低層の基盤を提供するもので、ユーザは自分でプロンプトやエイリアスを設定する必要があります。\n勿論 [`bash-it`](https://github.com/Bash-it/bash-it) や [`oh-my-bash`](https://github.com/ohmybash/oh-my-bash) の様な他の Bash 設定と一緒に使っていただくことも可能です。\n\n> デモ\n>\n> ![ble.sh demo gif](https://github.com/akinomyoga/ble.sh/wiki/images/trial1.gif)\n\n## 来し方行く末\n\nこのプロジェクトは初めは `.bashrc` の片隅で行われた小さな実験からスタートしました。\n2013年5月に `zsh-syntax-highlighting` のとある記事に触発されたのがきっかけでした。\n初めは数百行のコードを書けば構文着色が簡単に実現できるのではないかと思って始めた実験ですが、\nすぐに行エディタを根本から書き直さなければ実現できないのではないかということが分かり、\n独立したファイルにコードを移動した後に `ble.sh` という名前を与えました。\nこの名前は Zsh の行エディタ (*ZLE* (*Zsh Line Editor*)) を真似て、\n但しシェルで書かれているという事を意識して `.sh` という拡張子にしたように記憶しています。\n`ble.sh` の読み方について屡々訊かれるのですが、最初に書いたように特に定まった読み方はありません。\n最初の実験は2週間程コードを弄って原理的に行エディタを作れるという事を結論づけて終わりました。\n本格的な実装が始まったのは2015年2月の事で12月には公開しました。\nその時点で行エディタとしては普段遣いに堪える程度に完成していました。\nVimモードの実装は2017年9月に始まり2018年3月に一先ず完成としました。\n続いて補完の拡張は2018年8月に始まり2019年2月には一通り完成しました。\n現在は漫然とメンテナンスしている所でいつになるかは分かりませんが、以下に挙げるような機能も加えたいと何となく考えています。\n\n- 2013-06 v0.0 -- 実験\n- 2015-12 v0.1 -- 構文着色 [[v0.1.15](https://github.com/akinomyoga/ble.sh/releases/tag/v0.1.15)]\n- 2018-03 v0.2 -- Vim モード [[v0.2.7](https://github.com/akinomyoga/ble.sh/releases/tag/v0.2.7)]\n- 2019-02 v0.3 -- 拡張補完 [[v0.3.4](https://github.com/akinomyoga/ble.sh/releases/tag/v0.3.4)]\n- 20xx-xx v0.4 (plan) -- プログラム着色 [[nightly build](https://github.com/akinomyoga/ble.sh/releases/tag/nightly)]\n- 20xx-xx v0.5 (plan) -- TUI設定画面\n- 20xx-xx v0.6 (plan) -- エラー診断?\n\n## 制限および前提\n\n`ble.sh` の実装形態から来る制限があります。\nユーザー設定や他の Bash の枠組みとの干渉によって問題が起こる可能性があります。\n\n- 既定では、実行コストの都合上、`ble.sh` は前回のコマンドライン実行後の `PIPESTATUS` を設定しません。代わりに `BLE_PIPESTATUS` を参照することができます。\n  もし本当に `PIPESTATUS` 経由でこれらの値を利用する必要がある場合には設定 `bleopt exec_restore_pipestatus=1` を使用して下さい。\n- 既定では、よりなめらかな描画の為に、`ble.sh` は `PROMPT_COMMAND` および `PRECMD` フックが端末内のカーソル位置およびレイアウトを変更しないことを想定します。\n  `PROMPT_COMMAND` および `PRECMD` で出力を行うまたはカーソル位置を変更する設定をお持ちの場合は、設定 `bleopt prompt_command_changes_layout=1` を使用してください。\n- `ble.sh` は一般的な変数名のシェル変数や環境変数 (`LC_*` など) がグローバルで読み込み専用変数になっていないことを想定します。\n  Bash ではグローバル変数の読み込み専用属性は関数のローカルスコープに於いても制限を与えます。\n  つまり、同名の異なるローカル変数さえ定義することができません。\n  この問題は `ble.sh` 固有の制限ではなく、あらゆる Bash の枠組みがグローバルの読み込み専用変数に影響を受けます。\n  一般的にグローバルスコープに読み込み変数を設定することはセキュリティ的な理由がない限りは非推奨と考えられています (参照 [[1]](https://lists.gnu.org/archive/html/bug-bash/2019-03/threads.html#00150), [[2]](https://lists.gnu.org/archive/html/bug-bash/2020-04/threads.html#00200), [[3]](https://mywiki.wooledge.org/BashProgramming?highlight=%28%22readonly%22%20flag,%20or%20an%20%22integer%22%20flag,%20but%20these%20are%20mostly%20useless,%20and%20serious%20scripts%20shouldn%27t%20be%20using%20them%29#Variables))。\n  また、`ble.sh` はビルトインコマンド `readonly` をシェル関数で置き換え、グローバル変数を読み込み専用にするのをブロックします。\n  例外として、全て大文字の変数 (`ble.sh` が内部使用するものを除く) および `_*` の形の変数 (`_ble_*` および `__ble_*` を除く) を読み込み専用にすることは可能です。\n- `ble.sh` は Bash のビルトインコマンド (`trap`, `readonly`, `bind`, `history`, `read`, `exit`) をシェル関数で上書きし、`ble.sh` と干渉しないようにその振る舞いを調整します。\n  ユーザーまたは他の枠組みが元のビルトインを直接呼び出した場合、または `ble.sh` の定義したシェル関数を別のシェル関数で上書きした場合、正しい動作を保証できません。\n- シェル及び端末の設定はラインエディタ用とコマンド実行用で異なります。`ble.sh`\n  はラインエディタ向けに必要な調整を行い、ユーザが指定したコマンド実行用の設定\n  をできるだけ復元します。但し、様々な理由により、一部の設定については意図的に\n  復元しない場合や復元することができない場合があります。詳細については\n  [wiki](https://github.com/akinomyoga/ble.sh/wiki/Internals#internal-and-external)\n  (英語) に情報があります。\n\n## 批判\n\n- <sup><a id=\"discl-pronun\" href=\"#discl-pronun\">†1</a></sup>Q. \"ble.sh の読み方が分からない\"---\n  A. `ble.sh` はお好きな様に読んでいただいて問題ありませんが、一番短いのは標記の /blɛʃ/ になりましょう。\n  しかし個人的には脳裡で /biːɛliː/ または /biːɛliː dɑt ɛseɪtʃ/ と読んでいるものですから、\n  標記の読み方は飽くまで参考と受け止めていただければ幸いです。\n- <sup><a id=\"discl-pure\" href=\"#discl-pure\">†2</a></sup>Q. \"コマンドを実行するのだからピュアBashのはずがない。\n  ピュアBashとは何たることか\"---\n  A. ラインエディタ本体がピュア Bashで書かれているという意味です。\n  勿論、ユーザーが外部コマンドを入力・実行した場合にはその外部コマンドが呼び出されます。\n  更に、ユーザーコマンド実行前後には TTY を適切に設定する為に `stty` (POSIX) が呼び出されます。\n  他にも処理の高速化の為に、初期化・終了処理、\n  巨大なデータの処理 (補完、貼り付けなど) の局面でPOSIX 標準コマンドを利用しています。\n  `ble.sh` 実装における本来の目標はピュアBashで実装することではなく、\n  POSIX環境におけるBashの互換性を保った範囲で高速な動作を実現することです。\n  ピュアBashによって大抵の場合は `fork` &amp; `exec` コストを削減することができますが、\n  個々のケースで外部コマンドによる実装の方が効率的な場合には、\n  `ble.sh`はピュアBash実装よりも外部コマンドによる実装を優先します。\n\n# 1 使い方\n\n## 1.1 ソースからのビルド方法<sup><a id=\"get-from-source\" href=\"#get-from-source\">†</a></sup>\n\n### ble.sh 生成\n\n`ble.sh` を生成する為には `gawk` (GNU awk) と `gmake` (GNU make) が必要です。\n以下のコマンドで生成できます。\nGNU make が `gmake` という名前でインストールされている場合は、`make` の代わりに `gmake` として下さい。\n```console\n$ git clone --recursive https://github.com/akinomyoga/ble.sh.git\n$ cd ble.sh\n$ make\n```\nスクリプトファイル `ble.sh` がサブディレクトリ `ble.sh/out` 内に生成されます。\n\n### 試用\n\n生成された `ble.sh` は `source` コマンドを用いてお試しいただけます。\n\n```console\n$ source out/ble.sh\n```\n\n### インストール<sup><a id=\"package\" href=\"#install\">†</a></sup>\n\n指定したディレクトリにインストールするには `make install` コマンドを使用します。\n\n```bash\n# ~/.local/share/blesh にインストール\nmake install\n\n# 指定したディレクトリにインストール\nmake install INSDIR=/path/to/blesh\n```\n\nメインファイル `ble.sh` 及び関連スクリプトファイルのインストール先ディレクトリは Make 変数 `INSDIR` を用いて指定できます。\nライセンス及びドキュメントのインストール先は Make 変数 `INSDIR_LICENSE` と `INSDIR_DOC` を用いて指定できます。\n`INSDIR` が指定されている時、`INSDIR_LICENSE` と `INSDIR_DOC` の既定値はそれぞれ `$INSDIR/licenses` と `$INSDIR/doc` です。\n`INSDIR` および後述の `DESTDIR`/`PREFIX` が指定されていない時、`INSDIR`, `INSDIR_LICENSE`, `INSDIR_DOC` の規定値は\nそれぞれ `$data/blesh`, `$data/blesh/licenses`, `$data/doc/blesh` になります。\n但し、`data` は `${XDG_DATA_HOME:-$HOME/.local/share}` を指します。\n\nMake 変数 `USE_DOC=no` が指定されている時、ドキュメントファイルの処理が無効化されます。\n\n既定ではコード中のコメント行や空行はインストール時に自動で削除されます。\nコメントや空行を保持したい場合は `strip_comment=no` を `make` の引数に指定して下さい。\n\n`.bashrc` の設定に関しては[節1.3](#set-up-bashrc)を御覧ください。\n\n### パッケージ作成<sup><a id=\"package\" href=\"#package\">†</a></sup>\n\nパッケージ作成者は Make 変数 `DESTDIR` 及び `PREFIX` を用いて `INSDIR`,\n`INSDIR_LICENSE`, `INSDIR_DOC` の既定値を一括で設定することができます。\n\n```\n# パッケージ作成 - 例1\nmake install DESTDIR=/tmp/blesh-package PREFIX=/usr/local\n\n# パッケージ作成 - 例2\nmake install DESTDIR=\"$build\" PREFIX=\"$prefix\" \\\n  INSDIR_LICENSE=\"$build/$prefix/share/licenses/blesh\"\n\n# パッケージ作成 - 例3\nmake install DESTDIR=\"$build\" PREFIX=\"$prefix\" \\\n  INSDIR_LICENSE=\"$build/$prefix/share/blesh/doc\" \\\n  INSDIR_DOC=\"$build/$prefix/share/blesh/doc\"\n\n# パッケージ作成 - 例4\nmake install USE_DOC=no DESTDIR=\"$build\" PREFIX=\"$prefix\"\n```\n\n`INSDIR` の代わりに Make 変数 `DESTDIR` または `PREFIX` が指定されている時、 \n`INSDIR` の値は `$DESTDIR/$PREFIX/share/blesh` に設定され、\nライセンス及びドキュメントファイルの場所 `INSDIR_LICENSE` と `INSDIR_DOC` の既定値は `$DESTDIR/$PREFIX/share/doc/blesh` になります。\n\n#### `_package.bash`\n\nスクリプトファイル `_package.bash` を `${prefix}/share/blesh/lib/_package.bash` に配置することで、\n`ble-update` で用いるパッケージ更新方法を指定することができます。\nスクリプトファイル `_package.bash` では、次で示すような変数と関数を定義します。\n但し `XXX` はパッケージ管理システムの名前に置き換えてください。\n\n```bash\n# ${prefix}/share/blesh/lib/_package.bash\n\n_ble_base_package_type=XXX\n\nfunction ble/base/package:XXX/update {\n  update-the-package-in-a-proper-way\n  return 0\n}\n```\n\nシェル関数の終了ステータス 0 は更新が成功したことを表し、更新処理完了後に `ble.sh` が自動的にリロードされます。\nシェル関数がステータス 6 で終了した場合、更新処理完了後に `ble.sh` のタイムスタンプが確認され、`ble.sh` が現セッションの開始時刻よりも新しい時に限りリロードが行われます。\nシェル関数がステータス 125 で終了した場合、`ble.sh` に組み込みの更新処理が試みられます。\nそれ以外の場合には更新処理が中断されます。この場合、シェル関数が状況を説明するメッセージを出力するようにして下さい。\n具体例として `AUR` パッケージの [`_package.bash`](https://aur.archlinux.org/cgit/aur.git/tree/blesh-update.sh?h=blesh-git) も参考にしていただければ幸いです。\n\n## 1.2 tarball のダウンロード<sup><a id=\"get-from-tarball\" href=\"#get-from-tarball\">†</a></sup>\n\nGitHub Releases から `ble.sh` の tarball をダウンロードすることもできます。\nダウンロード・試用・インストールの方法については各リリースページの説明を御覧ください。\n現在、安定版は開発版に比べてかなり古いので様々な機能が欠けていることにご注意下さい。\n\n- 開発版 [v0.4.0-devel3](https://github.com/akinomyoga/ble.sh/releases/tag/v0.4.0-devel3) (2023-04), [nightly build](https://github.com/akinomyoga/ble.sh/releases/tag/nightly)\n- 安定版 [v0.3.4](https://github.com/akinomyoga/ble.sh/releases/tag/v0.3.4) (2019-02 fork) 拡張補完\n- 安定版 [v0.2.7](https://github.com/akinomyoga/ble.sh/releases/tag/v0.2.7) (2018-03 fork) Vim モード\n- 安定版 [v0.1.15](https://github.com/akinomyoga/ble.sh/releases/tag/v0.1.15) (2015-12 fork) 構文着色\n\n## 1.3 `.bashrc` の設定<sup><a id=\"set-up-bashrc\" href=\"#set-up-bashrc\">†</a></sup>\n\n対話シェルで常用する場合には `.bashrc` に設定を行います。\n単に `ble.sh` を `source` して頂くだけでも大抵の場合動作しますが、\nより確実に動作させる為には以下の様にコードを記述します。\n```bash\n# bashrc\n\n# .bashrc の先頭近くに以下を追加して下さい。\n[[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach\n\n# 間に通常の bashrc の内容を既述します。\n\n# .bashrc の末端近くに以下を追加して下さい。\n[[ ! ${BLE_VERSION-} ]] || ble-attach\n```\n\n`source /path/to/ble.sh` 及び `ble-attach` を呼び出す時は、\n標準ストリーム (`stdin`, `stdout`, `stderr`) が現在のセッションの制御端末とは別の物にリダイレクトされていない様にして下さい。\n`source /path/to/ble.sh` をシェル関数の中から実行するのは避けて下さい。\nこの「より確実な設定」が必要になる詳細な条件については [Discussion #254 への回答 (英語)](https://github.com/akinomyoga/ble.sh/discussions/254#discussioncomment-4284757) で説明されています。\n\n## 1.4 初期化スクリプト `~/.blerc`\n\nユーザー設定は初期化スクリプト `~/.blerc` (またはもし `~/.blerc` が見つからなければ `${XDG_CONFIG_HOME:-$HOME/.config}/blesh/init.sh`) に記述します。\nテンプレートとしてリポジトリの [`blerc.template`](https://github.com/akinomyoga/ble.sh/blob/master/blerc.template) というファイルを利用できます。\n初期化スクリプトは `ble.sh` ロード時に自動で読み込まれる Bash スクリプトなので、Bash で使えるコマンドを初期化スクリプトの中で利用できます。\n初期化スクリプトの位置を変更する場合には、`source ble.sh` 時に `--rcfile INITFILE` を指定します。以下に例を挙げます。\n\n```bash\n# in bashrc\n\n# Example 1: ~/.blerc will be used by default\n[[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach\n\n# Example 2: /path/to/your/blerc will be used\n[[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach --rcfile /path/to/your/blerc\n```\n\n## 1.5 アップデート\n\nGit (`git'), GNU awk (`gawk`), 及び GNU make (`make`) が必要になります。\n`ble-0.3` 以上をお使いの場合は `ble.sh` をロードした状態で `ble-update` を実行して下さい。\n\n```bash\n$ ble-update\n```\n\n`ble-0.4` 以上をお使いの場合は `ble.sh` をロードしなくても以下のコマンドで更新可能です。\n\n```bash\n$ bash /path/to/ble.sh --update\n```\n\nそれ以外の場合には、以下のように `git pull` で最新版を入手・インストールできます。\n\n```bash\ncd ble.sh   # ※既に持っている git リポジトリに入る\ngit pull\ngit submodule update --recursive --remote\nmake\nmake INSDIR=\"$HOME/.local/share/blesh\" install\n```\n\n## 1.6 アンインストール\n\n基本的に `ble.sh` ディレクトリとユーザの追加した設定を単に削除していただければ問題ありません。\n\n- 全ての `ble.sh` セッション (`ble.sh` をロードしている Bash 対話セッション) を終了します。\n- 関連するユーザーデータを削除します。これらのデータを保持しておきたい場合は必要に応じてスキップしてください。\n  - `.bashrc` に追加した行があれば削除します。\n  - `blerc` 設定ファイル (`~/.blerc` または `~/.config/blesh/init.sh`) があれば削除します。\n  - 状態ディレクトリ `~/.cache/blesh` が生成されていればそれを削除します。\n- `ble.sh` をインストールしたディレクトリを削除します。git リポジトリ内の\n  `out/ble.sh` を直接ご使用の場合はインストールしたディレクトリは、git リポジト\n  リ自体です。`make intall` を用いてインストールした場合は、インストールしたディ\n  レクトリは `<PREFIX>/share/blesh` です。但し、`<PREFIX>` (既定値: `~/.local`)\n  は `make install` に指定した `PREFIX` の値です。生成済み tarball をご利用の際\n  には、インストールしたディレクトリは tarball を展開して得られたディレクトリを\n  配置した場所です。\n- キャッシュディレクトリ `~/.cache/blesh` が生成されていればそれを削除します。\n- 一時ディレクトリ `/tmp/blesh` が生成されていればそれを削除します。これは `/tmp` の内容が自動的にクリアされないシステムで必要です。\n\n## 1.7 トラブルシューティング\n\n- [Performance](https://github.com/akinomyoga/ble.sh/wiki/Performance) (英語)\n  では `ble.sh` の動作速度の改善に関する情報について説明しています。\n- [Reportin Issues](https://github.com/akinomyoga/ble.sh/wiki/Reporting-Issues)\n  (英語) では問題報告をする前に確認しておくと良い情報を説明しています。\n\n# 2 基本設定\n\nここでは `~/.blerc` に記述する基本的な設定を幾つか紹介します。\n[質問と回答](https://github.com/akinomyoga/ble.sh/wiki/%E8%B3%AA%E5%95%8F%E3%81%A8%E5%9B%9E%E7%AD%94)、\n[逆引きレシピ](https://github.com/akinomyoga/ble.sh/wiki/%E9%80%86%E5%BC%95%E3%81%8D%E3%83%AC%E3%82%B7%E3%83%94)、\n[`contrib` リポジトリ](https://github.com/akinomyoga/blesh-contrib/blob/master/README-ja.md) にも便利な設定があります。\nその他の全ての設定項目はテンプレート [`blerc.template`](https://github.com/akinomyoga/ble.sh/blob/master/blerc.template) に含まれています。\n詳細な説明に関しては[説明書](https://github.com/akinomyoga/ble.sh/wiki/%E7%9B%AE%E6%AC%A1)を参照して下さい。\n\n## 2.1 Vim モード\n\nVim モードについては [Wiki の説明ページ](https://github.com/akinomyoga/ble.sh/wiki/Vi-(Vim)-editing-mode) を御覧ください。\n\n## 2.2 各機能の無効化\n\nよくお尋ね頂くご質問の一つにそれぞれの機能をどのように無効化すれば良いのかというものが御座います。\n各機能の無効化方法を以下にまとめます。\n\n```bash\n# 構文着色を無効化\nbleopt highlight_syntax=\n\n# ファイル名に基づく構文着色を無効化\nbleopt highlight_filename=\n\n# 変数の種類に基づく構文着色の無効化\nbleopt highlight_variable=\n\n# 自動補完の無効化 (自動補完は Bash 4.0 以降にて既定で有効です)\nbleopt complete_auto_complete=\n# Tip: 代わりに自動補完の起動遅延をミリ秒単位でご指定いただくこともできます。\nbleopt complete_auto_delay=300\n\n# コマンド履歴に基づく自動補完の無効化\nbleopt complete_auto_history=\n\n# 曖昧補完の無効化\nbleopt complete_ambiguous=\n\n# TAB によるメニュー補完の無効化\nbleopt complete_menu_complete=\n\n# メニュー自動絞り込みの無効化 (Bash 4.0 以降にて既定で有効化されます)\nbleopt complete_menu_filter=\n\n# 行末マーカー \"[ble: EOF]\" の無効化\nbleopt prompt_eol_mark=''\n# Tip: 代わりに他の文字列をご指定頂くこともできます。\nbleopt prompt_eol_mark='⏎'\n\n# 終了ステータスマーカー \"[ble: exit %d]\" の無効化\nbleopt exec_errexit_mark=\n# Tip: 代わりに他の文字列をご指定頂くこともできます。\nbleopt exec_errexit_mark=$'\\e[91m[error %d]\\e[m'\n\n# コマンド実行時間マーカー \"[ble: elapsed 1.203s (CPU 0.4%)]\" の無効化\nbleopt exec_elapsed_mark=\n# Tip: 代わりに別の文字列をご指定いただくこともできます。\nbleopt exec_elapsed_mark=$'\\e[94m[%ss (%s %%)]\\e[m'\n# Tip: マーカーを表示する条件を変更することも可能です。\nbleopt exec_elapsed_enabled='sys+usr>=10*60*1000' # 例: 合計CPU時間が 10 分以上の時に表示\n\n# 終了マーカー \"[ble: exit]\" の無効化\nbleopt exec_exit_mark=\n\n# その他のマーカー \"[ble: ...]\" の無効化\nbleopt edit_marker=\nbleopt edit_marker_error=\n```\n\n## 2.3 曖昧文字幅\n\n設定 `char_width_mode` を用いて、曖昧文字幅を持つ文字 (Unicode 参考特性 `East_Asian_Width` が `A` (Ambiguous) の文字) の幅を制御できます。\n現在は 4 つの選択肢 `emacs`, `west`, `east`, `auto` が用意されています。\n設定値 `emacs` を指定した場合、GNU Emacs における既定の文字幅と同じ物を使います。\n設定値 `west` を指定した場合、全ての曖昧文字幅を 1 (半角) と解釈します。\n設定値 `east` を指定した場合、全ての曖昧文字幅を 2 (全角) と解釈します。\n設定値 `auto` を指定した場合、`west` か `east` かを端末とのやり取りに基づいて自動判定します。\n既定値は `auto` です。この設定項目は、利用している端末の振る舞いに応じて適切に設定する必要があります。\n例えば `west` に設定する場合は以下の様にします:\n\n```bash\nbleopt char_width_mode='west'\n```\n\n## 2.4 文字コード\n\n設定 `input_encoding` は入力の文字コードを制御するのに使います。現在 `UTF-8` と `C` のみに対応しています。\n設定値 `C` を指定した場合は、受信したバイト値が直接文字コードであると解釈されます。\n既定値は `UTF-8` です。`C` に設定を変更する場合には以下の様にします:\n\n```bash\nbleopt input_encoding='C'\n```\n\n## 2.5 ベル\n\n設定 `edit_bell` は編集関数 `bell` の振る舞いを制御するコロン区切りのリストです。\n値 `abell`, `vbell`, `visual` はそれぞれ対応するベルの提示方法を有効化します。\n値 `abell` は音による通知に対応し、制御文字の <kbd>BEL</kbd> (0x07) を `stderr` に出力します。\n値 `vbell` は画面での通知に対応し、端末画面上にメッセージを表示します。\n値 `visual` は画面の反転に対応し、<kbd>DECSCNM</kbd> を用いて端末画面を瞬間的に反転します。\n既定では音による通知のみが有効になっています。\n\n設定 `vbell_default_message` は画面での通知で使用するメッセージ文字列を指定します。既定値は `' Wuff, -- Wuff!! '` です。\n設定 `vbell_duration` は画面での通知を表示する時間の長さを指定します。単位はミリ秒です。既定値は `2000` です。\n設定 `vbell_align` は画面での通知の表示位置を指定します。`left`, `center`, `right` が指定できます。\n\n例えば、以下の設定によって、音による通知を無効化して画面での通知を設定・有効化できます。\n\n```bash\nbleopt edit_bell=vbell vbell_{default_message=' BEL ',duration=3000,align=right}\n```\n\n## 2.6 着色の設定\n\n構文に従った着色で使用される、各文法要素の色と属性は `ble-face` シェル関数で設定します。\n既定の設定は以下のコードに対応します:\n```bash\n# 編集に関連する着色の設定\nble-face -s region                    bg=60,fg=231\nble-face -s region_target             bg=153,fg=black\nble-face -s region_match              bg=55,fg=231\nble-face -s region_insert             fg=27,bg=254\nble-face -s disabled                  fg=242\nble-face -s overwrite_mode            fg=black,bg=51\nble-face -s vbell                     reverse\nble-face -s vbell_erase               bg=252\nble-face -s vbell_flash               fg=green,reverse\nble-face -s prompt_status_line        fg=231,bg=240\n\n# 構文着色の設定\nble-face -s syntax_default            none\nble-face -s syntax_command            fg=brown\nble-face -s syntax_quoted             fg=green\nble-face -s syntax_quotation          fg=green,bold\nble-face -s syntax_escape             fg=magenta\nble-face -s syntax_expr               fg=33\nble-face -s syntax_error              bg=203,fg=231\nble-face -s syntax_varname            fg=202\nble-face -s syntax_delimiter          bold\nble-face -s syntax_param_expansion    fg=133\nble-face -s syntax_history_expansion  bg=94,fg=231\nble-face -s syntax_function_name      fg=99,bold\nble-face -s syntax_comment            fg=242\nble-face -s syntax_glob               fg=198,bold\nble-face -s syntax_brace              fg=37,bold\nble-face -s syntax_tilde              fg=63,bold\nble-face -s syntax_document           fg=100\nble-face -s syntax_document_begin     fg=100,bold\nble-face -s command_builtin_dot       fg=red,bold\nble-face -s command_builtin           fg=red\nble-face -s command_alias             fg=teal\nble-face -s command_function          fg=99\nble-face -s command_file              fg=green\nble-face -s command_keyword           fg=blue\nble-face -s command_jobs              fg=red\nble-face -s command_directory         fg=33,underline\nble-face -s command_suffix            fg=231,bg=28\nble-face -s command_suffix_new        fg=231,bg=124\nble-face -s filename_directory        underline,fg=33\nble-face -s filename_directory_sticky underline,fg=231,bg=26\nble-face -s filename_link             underline,fg=teal\nble-face -s filename_orphan           underline,fg=16,bg=224\nble-face -s filename_executable       underline,fg=green\nble-face -s filename_setuid           underline,fg=black,bg=220\nble-face -s filename_setgid           underline,fg=black,bg=191\nble-face -s filename_other            underline\nble-face -s filename_socket           underline,fg=cyan,bg=black\nble-face -s filename_pipe             underline,fg=lime,bg=black\nble-face -s filename_character        underline,fg=231,bg=black\nble-face -s filename_block            underline,fg=yellow,bg=black\nble-face -s filename_warning          underline,fg=red\nble-face -s filename_url              underline,fg=blue\nble-face -s filename_ls_colors        underline\nble-face -s varname_array             fg=orange,bold\nble-face -s varname_empty             fg=31\nble-face -s varname_export            fg=200,bold\nble-face -s varname_expr              fg=99,bold\nble-face -s varname_hash              fg=70,bold\nble-face -s varname_new               fg=34\nble-face -s varname_number            fg=64\nble-face -s varname_readonly          fg=200\nble-face -s varname_transform         fg=29,bold\nble-face -s varname_unset             fg=245\nble-face -s argument_option           fg=teal\nble-face -s argument_error            fg=black,bg=225\n\n# 補完の着色\nble-face -s auto_complete             fg=238,bg=254\nble-face -s menu_complete_match       bold\nble-face -s menu_complete_selected    reverse\nble-face -s menu_desc_default         none\nble-face -s menu_desc_type            ref:syntax_delimiter\nble-face -s menu_desc_quote           ref:syntax_quoted\nble-face -s menu_filter_fixed         bold\nble-face -s menu_filter_input         fg=16,bg=229\n```\n\n現在の描画設定の一覧は以下のコマンドでも確認できます (`ble-face` を無引数で呼び出す)。\n```console\n$ ble-face\n```\n\n色コードはシェル関数 `ble-color-show` (`ble.sh` 内で定義) で確認できます。\n```console\n$ ble-color-show\n```\n\n## 2.7 キーバインディング\n\nキーバインディングはシェル関数 `ble-bind` を使って変更できます。\n例えば <kbd>C-x h</kbd> を入力した時に \"Hello, world!\" と挿入させたければ以下のようにします。\n```bash\nble-bind -f 'C-x h' 'insert-string \"Hello, world!\"'\n```\n\n上記の <kbd>C-x h</kbd> の様なキー表記については\n[マニュアル §3.1](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A73-%E3%82%AD%E3%83%BC%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0#user-content-sec-kspecs) で詳細に説明されています。\nスペース・タブ・エンター・バックスペース・エスケープなどの特殊キーの表記については\n[マニュアル §3.1.1](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A73-%E3%82%AD%E3%83%BC%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0#user-content-sec-kspecs-ret) で説明されています:\nスペースは <kbd>SP</kbd> と表現します。\nタブキーは端末によって <kbd>C-i</kbd> または <kbd>TAB</kbd> と表現します。\nエンター・リターンキーは端末によって <kbd>C-m</kbd> または <kbd>RET</kbd> と表現します。\nバックスペースは端末によって <kbd>C-?</kbd>, <kbd>DEL</kbd>, <kbd>C-h</kbd>, または <kbd>BS</kbd> 等様々な表現があります。\n<kbd>Ctrl+Return</kbd> や <kbd>Shift+Return</kbd> などの修飾された特殊キーの取り扱いについては\n[マニュアル §3.6.4](https://github.com/akinomyoga/ble.sh/wiki/%E8%AA%AC%E6%98%8E%E6%9B%B8-%C2%A73-%E3%82%AD%E3%83%BC%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0#user-content-sec-modifyOtherKeys-manual) で説明されています。\nお使いの端末が `modifyOtherKeys` に対応していない場合、手動で各キーの組み合わせに対応するエスケープシーケンスを設定する必要があります。\n\n\n<kbd>M-c</kbd> を入力した時にコマンドを実行するには以下のようにします。\n\n```bash\nble-bind -c 'M-c' 'my-command'\n```\n\n<kbd>C-r</kbd> を入力した時に、ユーザー定義編集関数 (Bash の `bind -x` で指定するのと同様の物) を実行するには以下のようにします。\n\n```bash\nble-bind -x 'C-r' 'my-edit-function'\n```\n\n既存のキーバインディングは以下のコマンドで確認できます。\n```console\n$ ble-bind -P\n```\n\n以下のコマンドでキーバインディングに使える編集関数一覧を確認できます。\n```console\n$ ble-bind -L\n```\n\nそれぞれの編集関数の説明は wiki のマニュアルを参照して下さい。\n\n一つのキーで複数の編集関数を呼び出したい場合は、以下の例の様に、\n`ble/widget/編集関数の名前` という名前のシェル関数を通して新しい編集関数を定義できます。\n既存の標準の編集関数と名前が重複しない様に、\n編集関数の名前は `ユーザー名/`, `my/`, `blerc/`, `dotfiles/` などで始める事が強く推奨されます。\n\n```bash\n# C-t で複数の操作を行う例\nfunction ble/widget/my/example1 {\n  ble/widget/beginning-of-logical-line\n  ble/widget/insert-string 'echo $('\n  ble/widget/end-of-logical-line\n  ble/widget/insert-string ')'\n}\nble-bind -f C-t my/example1\n```\n\n## 2.8 fzf との統合<sup><a id=\"fzf-integration\" href=\"#fzf-integration\">†</a></sup>\n\n`fzf` を `ble.sh` と一緒にお使いいただく場合には、[`contrib/fzf` 統合機能](https://github.com/akinomyoga/blesh-contrib#pencil-fzf-integration) を用いて `fzf` を設定していただく必要があります。\n詳細についてはリンク先の説明を御覧ください。\n\n```bash\n# blerc\n\n# 注意: fzf を bash_completion と組み合わせて使用する場合は、fzf-completion よ\n# りも先に bash_completion をロードしておく必要があります。これは ble.sh と関係\n# なく必要です。\nsource /etc/profile.d/bash_completion.sh\n\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\n```\n\n上記 `ble-import` に指定されているオプション `-d` は指定したファイルの読み込み\nを遅延させます。このように設定した場合、指定したファイルはプロンプトが表示され\nた後にバックグランドで読み込まれます。詳細に関しては [`ble-import` - 説明書\n§8](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A78-Miscellaneous#user-content-fn-ble-import)\nを御覧ください。\n\n### fzf に対する追加設定がある場合\n\n`fzf` の設定を読み込んだ後に追加の設定コードを実行したい場合、上記の fzf 設定の遅延読み込みのために、\n単に設定コードを上記の設定に続けて記述しても動きません。\nこの場合、四つの方法がございます。\n最も単純な方法はオプション `-d` を指定せずに遅延読み込みを無効化する方法 [1] です。\n\n```bash\n# [1] オプション -d を使用しない\nble-import integration/fzf-completion\nble-import integration/fzf-key-bindings\n<settings>\n```\n\nしかし上の方法を用いると初期化時間が長くなります。別の方法として、\n`ble-import -d` [2] または `ble/util/idle.push` [3] を用いて追加設定も同様に遅\n延させることができます。または、fzf 設定ファイルの読み込み完了に対して\n`ble-import -C` [4] を用いてフックを設定することもできます。\n\n```bash\n# [2] 追加設定も ble-import -d を使う\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\nble-import -d '<filename containing the settings>'\n\n# [3] 追加設定を ble/util/idle.push で登録\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\nble/util/idle.push '<settings>'\n\n# [4] 追加設定を ble-import -C で登録\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\nble-import -C '<settings>' integration/fzf-key-bindings\n```\n\n# 3 ヒント\n\n## 3.1 複数行モード\n\nコマンドラインに改行が含まれている場合、複数行モード (MULTILINE モード) になります。\n\n<kbd>C-v C-j</kbd> または <kbd>C-q C-j</kbd> とすると改行をコマンドラインの一部として入力できます。\n複数行モードでは、<kbd>RET</kbd> (<kbd>C-m</kbd>) はコマンドの実行ではなく新しい改行の挿入になります。\n複数行モードでは、<kbd>C-j</kbd> を用いてコマンドを実行して下さい。\n\n`shopt -s cmdhist` が設定されているとき (既定)、もし <kbd>RET</kbd> (<kbd>C-m</kbd>) を押した時にコマンドラインが構文的に閉じていなければ、コマンドの実行ではなく改行の挿入を行います。\n\n## 3.2 Vim モード\n\n`.bashrc` に `set -o vi` が設定されているとき、または `.inputrc` に `set editing-mode vi` が設定されているとき、vim モードが有効になります。\nVim モードの詳細な設定については [Wiki のページ (英語)](https://github.com/akinomyoga/ble.sh/wiki/Vi-(Vim)-editing-mode) を御覧ください。\n\n## 3.3 自動補完\n\nBash 4.0 以降では自動補完が有効になり、予測候補が表示されます。\n候補を確定するには <kbd>S-RET</kbd> を入力します (編集文字列の末尾にいる時は <kbd>right</kbd>, <kbd>C-f</kbd> または <kbd>end</kbd> でも確定できます)。\n表示されている候補の初めの単語だけ部分的に確定する時は <kbd>M-f</kbd> または <kbd>M-right</kbd> を入力します。\n現在の候補で確定しそのままコマンドを実行する場合には <kbd>C-RET</kbd> (※お使いの端末が対応している時) を入力します。\nお使いの端末が対応していない時は [マニュアル §3.6.4](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A73-Key-Binding#user-content-sec-modifyOtherKeys-manual) を参照して下さい。\n\n\n## 3.4 静的略語展開\n\n特定の単語を静的略語展開に登録することで好きな文字列に展開することができます。\n登録済み単語に一致する単語の直後で <kbd>SP</kbd> を入力した時に静的略語展開が起きます。\n例えば、以下の設定をしておくと `command L` まで入力した状態で <kbd>SP</kbd> を押した時に、コマンドラインが `command | less` に展開されます。\n\n```bash\n# blerc\nble-sabbrev L='| less'\n```\n\n実際に実行したいコマンドに含まれる可能性の低い単語として、`\\` で始まる単語を静的略語展開に登録することもお薦めです。\n\n```bash\n# blerc\nble-sabbrev '\\L'='| less'\n```\n\n`~` で始まる静的略語展開は <kbd>/</kbd> でも展開されます。これは Zsh の名前付きディレクトリ (named directories) に模した使い方ができます。\n例えば、以下の設定の下で `~mybin/` と入力すると、`/home/user/bin/` など (`HOME=/home/user` の場合) に展開されます。\n\n```bash\n# blerc\n\nble-sabbrev \"~mybin=$HOME/bin\"\n```\n\n# 4 謝辞\n\nGitHub の Issue/PR を通して多くの方からフィードバックを頂き、皆様に本当に感謝しております。\n特に以下の方には大きな寄与を受けたので言及させていただきます。\n\n- [`@cmplstofB`](https://github.com/cmplstofB) 様には vim モードの実装において初期よりテスト及び様々な提案をしていただきました。\n- [`@dylankb`](https://github.com/dylankb) 様には `fzf` との互換性や `ble.sh` 初期化に関連して様々な問題報告をいただきました。\n- [`@rux616`](https://github.com/rux616) 様には幾つかの問題報告および `.blerc` の既定パス解決のバグ修正をいただきました。\n- [`@timjrd`](https://github.com/timjrd) 様には補完の枠組みの高速化に関する PR をいただきました。\n- [`@3ximus`](https://github.com/3ximus) 様には広範囲に渡る様々な問題について報告いただきました。\n- [`@SuperSandro2000`](https://github.com/SuperSandro2000) 様には NixOS 関係を始め様々なご報告をいただきました。\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 43.630859375,
          "content": "[ Languages: **English** | [日本語](README-ja_JP.md) (Japanese) ]\n\n<h1 align=\"center\"><ruby>ble.sh<rp> (</rp><rt>/blɛʃ/</rt><rp>)</rp></ruby> ―Bash Line Editor―</h1>\n<p align=\"center\">\n[ <b>README</b> | <a href=\"https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A71-Introduction\">Manual</a> |\n<a href=\"https://github.com/akinomyoga/ble.sh/wiki/Q&A\">Q&A</a> |\n<a href=\"https://github.com/akinomyoga/blesh-contrib\"><code>contrib</code></a> |\n<a href=\"https://github.com/akinomyoga/ble.sh/wiki/Recipes\">Recipes</a> ]\n</p>\n\n*Bash Line Editor* (`ble.sh`<sup><a href=\"#discl-pronun\">†1</a></sup>) is a command line editor written in pure Bash<sup><a href=\"#discl-pure\">†2</a></sup> which replaces the default GNU Readline.\n\nThe current devel version is 0.4.\nThis script supports Bash 3.0 or higher although we recommend using `ble.sh` with release versions of **Bash 4.0 or higher**.\nThe POSIX standard utilities are also required.\nCurrently, only `UTF-8` encoding is supported for non-ASCII characters.\nThis script is provided under the [**BSD License**](LICENSE.md) (3-clause BSD license).\n\n## Quick instructions\n\n<!-- In macOS, you might additionally need to install `gawk`, `nawk`, or `mawk` since macOS `/usr/bin/awk` (awk-32 and later) seems to have a problem with some multibyte charsets. -->\nThere are two ways to get `ble.sh`: to get the source using `git` and build\n`ble.sh`, or to download the [nightly build](https://github.com/akinomyoga/ble.sh/releases/tag/nightly) using `curl` or `wget`.\nSee [Sec 1.1](#get-from-source) and [Sec 1.2](#get-from-tarball) for the details of trial and installation.\nSee [Sec 1.3](#set-up-bashrc) for the details of the setup of your `~/.bashrc`.\n\n> [!NOTE]\n> If you want to **use fzf with `ble.sh`**, you need to check [Sec\n> 2.8](#fzf-integration).\n\n<details open><summary><b>Download source using <code>git</code> and make <code>ble.sh</code></b></summary>\n\nThis requires the commands `git`, `make` (GNU make), and `gawk` (GNU awk)<sup><a href=\"#discl-pronun\">†3</a></sup>.\nIn the following, please replace `make` with `gmake` if your system provides GNU make as `gmake` (such as in BSD).\n\n```bash\n# TRIAL without installation\n\ngit clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git\nmake -C ble.sh\nsource ble.sh/out/ble.sh\n\n# Quick INSTALL to BASHRC (If this doesn't work, please follow Sec 1.3)\n\ngit clone --recursive --depth 1 --shallow-submodules https://github.com/akinomyoga/ble.sh.git\nmake -C ble.sh install PREFIX=~/.local\necho 'source ~/.local/share/blesh/ble.sh' >> ~/.bashrc\n```\n\nThe build process integrates multiple Bash script files into a single Bash script `ble.sh` with pre-processing.\nIt also places other module files in appropriate places and strips code comments for a shorter initialization time.\nThe build process does not involve any C/C++/Fortran compilations and generating binaries, so C/C++/Fortran compilers are not needed.\n</details>\n\n<details><summary><b>Download the nightly build with <code>curl</code></b></summary>\n\nThis requires the commands `curl`, `tar` (with the support for the `J` flag), and `xz` (XZ Utils).\n\n```bash\n# TRIAL without installation\n\ncurl -L https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nsource ble-nightly/ble.sh\n\n# Quick INSTALL to BASHRC (If this doesn't work, please follow Sec 1.3)\n\ncurl -L https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nbash ble-nightly/ble.sh --install ~/.local/share\necho 'source ~/.local/share/blesh/ble.sh' >> ~/.bashrc\n```\n\nAfter the installation, the directory `ble-nightly` can be removed.\n</details>\n\n<details><summary><b>Download the nightly build with <code>wget</code></b></summary>\n\nThis requires the commands `wget`, `tar` (with the support for the `J` flag), and `xz` (XZ Utils).\n\n```bash\n# TRIAL without installation\n\nwget -O - https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nsource ble-nightly/ble.sh\n\n# Quick INSTALL to BASHRC (If this doesn't work, please follow Sec 1.3)\n\nwget -O - https://github.com/akinomyoga/ble.sh/releases/download/nightly/ble-nightly.tar.xz | tar xJf -\nbash ble-nightly/ble.sh --install ~/.local/share\necho 'source ~/.local/share/blesh/ble.sh' >> ~/.bashrc\n```\n\nAfter the installation, the directory `ble-nightly` can be removed.\n</details>\n\n<details open><summary><b>Install a package using a package manager</b> (currently only a few packages)</summary>\n\nThis only requires the corresponding package manager.\n\n- [AUR (Arch Linux)](https://github.com/akinomyoga/ble.sh/wiki/Manual-A1-Installation#user-content-AUR) `blesh-git` (devel), `blesh` (stable 0.3.4)\n- [NixOS (nixpkgs)](https://github.com/akinomyoga/ble.sh/wiki/Manual-A1-Installation#user-content-nixpkgs) `blesh` (devel)\n- [Guix](https://packages.guix.gnu.org/packages/blesh) `blesh` (devel)\n</details>\n\n<details open><summary><b>Update an existing copy of <code>ble.sh</code></b></summary>\n\n```bash\n# UPDATE (in a ble.sh session)\n\nble-update\n\n# UPDATE (outside ble.sh sessions)\n\nbash /path/to/ble.sh --update\n```\n</details>\n\n<details><summary><b>Create a package of <code>ble.sh</code></b></summary>\n\nSince `ble.sh` is just a set of shell scripts and do not contain any binary (i.e., \"`noarch`\"),\nyou may just download the pre-built tarball from a release page and put the extracted contents in e.g. `/tmp/blesh-package/usr/local`.\nNevertheless, if you need to build the package from the source, please use the following commands.\nNote that the git repository (`.git`) is required for the build.\n\n```bash\n# BUILD & PACKAGE (for package maintainers)\n\ngit clone --recursive https://github.com/akinomyoga/ble.sh.git\nmake -C ble.sh install DESTDIR=/tmp/blesh-package PREFIX=/usr/local\n```\n\nFor a detailed control of the install locations of the main files, the license\nfiles, and the documentation files, please also check the later sections\n[Install](#install) and [Package](#package).\n\nIf you want to tell `ble.sh` the way to update the package for `ble-update`,\nyou can place `_package.bash` at `${prefix}/share/blesh/lib/_package.bash`.\nPlease check [`_package.bash`](#_packagebash) for the details.\n\n```bash\n# ${prefix}/share/blesh/lib/_package.bash\n\n_ble_base_package_type=XXX\nfunction ble/base/package:XXX/update {\n  update-the-package-in-a-proper-way\n}\n```\n</details>\n\n## Features\n\n- **Syntax highlighting**: Highlight command lines input by users as in `fish` and `zsh-syntax-highlighting`.\n  Unlike the simple highlighting in `zsh-syntax-highlighting`, `ble.sh` performs syntactic analysis\n  to enable the correct highlighting of complex structures such as nested command substitutions, multiple here documents, etc.\n  Highlighting colors and styles are [fully configurable](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A72-Graphics).\n- **Enhanced completion**:\n  Extend [completion](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A77-Completion)\n  by **syntax-aware completion**, completion with quotes and parameter expansions in prefix texts, **ambiguous candidate generation**, etc.\n  Also, [**menu-complete**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A77-Completion#user-content-sec-menu-complete)\n  supports the selection of candidates in the menu (candidate list) by cursor keys, <kbd>TAB</kbd>, and <kbd>S-TAB</kbd>.\n  The feature [**auto-complete**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A77-Completion#user-content-sec-auto-complete)\n  supports the automatic suggestion of completed texts as in `fish` and `zsh-autosuggestions` (with Bash 4.0+).\n  The feature [**menu-filter**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A77-Completion#user-content-sec-menu-filter)\n  integrates automatic filtering of candidates into menu completion (with Bash 4.0+).\n  There are other functionalities such as\n  [**dabbrev**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A77-Completion#user-content-sec-dabbrev) and\n  [**sabbrev**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A77-Completion#user-content-sec-sabbrev) like\n  [*zsh abbreviations*](https://unix.stackexchange.com/questions/6152/zsh-alias-expansion) or [`zsh-abbr`](https://github.com/olets/zsh-abbr).\n- **Vim editing mode**: Enhance `readline`'s vi editing mode available with `set -o vi`.\n  Vim editing mode supports various vim modes such as char/line/block visual/select mode, replace mode,\n  command mode, operator pending mode as well as insert mode and normal mode.\n  Vim editing mode supports various operators, text objects, registers, keyboard macros, marks, etc.\n  It also provides `vim-surround` as an option.\n- Other interesting features include\n  [**status line**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A74-Editing#user-content-bleopt-prompt_status_line),\n  [**history share**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A74-Editing#user-content-bleopt-history_share),\n  [**right prompt**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A74-Editing#user-content-bleopt-prompt_rps1),\n  [**transient prompt**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A74-Editing#user-content-bleopt-prompt_ps1_transient),\n  [**xterm title**](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A74-Editing#user-content-bleopt-prompt_xterm_title), etc.\n\nNote: ble.sh does not provide specific settings of the prompt, aliases, functions, etc.\nble.sh provides a more fundamental infrastructure so that users can set up their own prompt, aliases, functions, etc.\nOf course ble.sh can be used in combination with other Bash configurations such as [`bash-it`](https://github.com/Bash-it/bash-it) and [`oh-my-bash`](https://github.com/ohmybash/oh-my-bash).\n\n> Demo (version 0.2)\n>\n> ![ble.sh demo gif](https://github.com/akinomyoga/ble.sh/wiki/images/trial1.gif)\n\n## History and roadmap\n\nMy little experiment took place in one corner of my `bashrc` at the end of May 2013 after I enjoyed an article on `zsh-syntax-highlighting`.\nI initially thought something could be achieved by writing a few hundred lines of code\nbut soon realized that everything needs to be re-implemented for the authentic support of syntax highlighting in Bash.\nI decided to make it as an independent script `ble.sh`.\nThe name stemmed from that of Zsh's line editor, *ZLE* (*Zsh Line Editor*), but suffixed with `.sh` for the implication of being written in a shell script.\nI'm occasionally asked about the pronunciation of `ble.sh`, but you can pronounce it as you like.\nAfter the two-week experiment, I was satisfied with my conclusion that it is *possible* to implement a full-featured line editor in Bash that satisfies the actual daily uses.\nThe real efforts to improve the prototype implementation for real uses started in February 2015.\nI released the initial version in the next December. Until then, the basic part of the line editor was completed.\nThe implementation of vim mode was started in September 2017 and completed in the next March.\nI started working on the enhancement of the completion in August 2018 and released it in the next February.\n\n- 2013-06 v0.0 -- prototype\n- 2015-12 v0.1 -- Syntax highlighting [[v0.1.15](https://github.com/akinomyoga/ble.sh/releases/tag/v0.1.15)]\n- 2018-03 v0.2 -- Vim mode [[v0.2.7](https://github.com/akinomyoga/ble.sh/releases/tag/v0.2.7)]\n- 2019-02 v0.3 -- Enhanced completion [[v0.3.4](https://github.com/akinomyoga/ble.sh/releases/tag/v0.3.4)]\n- 20xx-xx v0.4 (plan) -- programmable highlighting [[nightly build](https://github.com/akinomyoga/ble.sh/releases/tag/nightly)]\n- 20xx-xx v0.5 (plan) -- TUI configuration\n- 20xx-xx v0.6 (plan) -- error diagnostics?\n\n## Limitations and assumptions\n\nThere are some limitations due to the way `ble.sh` is implemented.\nAlso, some user configurations or other Bash frameworks may conflict with ble.sh.\nFor example,\n\n- By default, `ble.sh` does not set `PIPESTATUS` for the previous command line\n  because it adds extra execution costs.  Instead, the array `BLE_PIPESTATUS`\n  contains the values of `PIPESTATUS` of the previous command line.  If you\n  need to access the values directly through the variable `PIPESTATUS`, please\n  set the option `bleopt exec_restore_pipestatus=1`.\n- By default, `ble.sh` assumes that `PROMPT_COMMAND` and `PRECMD` hooks do not\n  change the cursor position and the layout in the terminal display to offer\n  smooth rendering.  If you have settings that output texts or changes the\n  cursor position in `PROMPT_COMMAND` and `PRECMD`, please set the option\n  `bleopt prompt_command_changes_layout=1`.\n- `ble.sh` assumes that common variable names and environment variables (such as `LC_*`) are not used for the global readonly variables.\n  In Bash, global readonly variables take effect in any scope including the local scope of the function, which means that we cannot even define a local variable that has the same name as a global readonly variable.\n  This is not the problem specific to `ble.sh`, but any Bash framework may suffer from the global readonly variables.\n  It is generally not recommended to define global readonly variables in Bash except for the security reasoning\n  (Refs. [[1]](https://lists.gnu.org/archive/html/bug-bash/2019-03/threads.html#00150), [[2]](https://lists.gnu.org/archive/html/bug-bash/2020-04/threads.html#00200), [[3]](https://mywiki.wooledge.org/BashProgramming?highlight=%28%22readonly%22%20flag,%20or%20an%20%22integer%22%20flag,%20but%20these%20are%20mostly%20useless,%20and%20serious%20scripts%20shouldn%27t%20be%20using%20them%29#Variables)).\n  Also, `ble.sh` overrides the builtin `readonly` with a shell function to prevent it from making global variables readonly.\n  It allows only uppercase global variables and `_*` to become readonly except `_ble_*`, `__ble_*`, and some special uppercase variables.\n- `ble.sh` overrides Bash's built-in commands (`trap`, `readonly`, `bind`, `history`, `read`, and `exit`) with shell functions to adjust the behavior of each built-in command and prevent them from interfering with `ble.sh`.\n  If the user or another framework directly calls the original builtins through `builtin BUILTIN`, or if the user or another framework replaces the shell functions, the behavior is undefined.\n- The shell and terminal settings for the line editor and the command execution\n  are different.  `ble.sh` adjusts them for the line editor and try to restore\n  the settings for the command execution.  However, there are settings that\n  cannot be restored or are intentionally not restored for various reasons.\n  Some of them are summarized on [a wiki\n  page](https://github.com/akinomyoga/ble.sh/wiki/Internals#internal-and-external).\n\n## Criticism\n\n- <sup><a id=\"discl-pronun\" href=\"#discl-pronun\">†1</a></sup>Q. *It is hard to\n  pronounce \"ble-sh\". How should I pronounce it?* --- A. The easiest\n  pronunciation of `ble.sh` that users use is /blɛʃ/, but you can pronounce it\n  as you like.  I do not specify the canonical way of pronouncing `ble.sh`.  In\n  fact, I personally call it simply /biːɛliː/ or verbosely read it as /biːɛliː\n  dɑt ɛseɪtʃ/ in my head.\n- <sup><a id=\"discl-pure\" href=\"#discl-pure\">†2</a></sup>Q. *It cannot be pure\n  Bash because the user should be able to input and run external commands.\n  What does the pure Bash mean?* --- A. It means that the core part of the line\n  editor is written in pure Bash.  Of course, the external commands will be run\n  when the user inputs them and requests the execution of them.  In addition,\n  before and after the execution of user commands, `ble.sh` relies on POSIX\n  `stty` to set up the correct TTY states for user commands.  It also uses\n  other POSIX utilities for acceleration in some parts of initialization and\n  cleanup code, processing of large data in completions, pasting large data,\n  etc.  The primary goal of the `ble.sh` implementation is not being pure Bash,\n  but the performance in the Bash implementation with the POSIX environment.\n  Being pure Bash is usually useful for reducing the `fork`/`exec` cost, but if\n  implementation by external commands is more efficient in specific parts,\n  `ble.sh` will use the external commands there.\n- <sup><a id=\"discl-make\" href=\"#discl-make\">†3</a></sup>Q. *Why does `ble.sh`\n  use `make` to generate the script files? You should not use `make` for a\n  script framework.* --- A. Because it is not a good idea to directly edit a\n  large script file of tens of thousands of lines.  I split the codebase of\n  `ble.sh` into source files of reasonable sizes and edit the source files.  In\n  the build process, some source files are combined to form the main script\n  `ble.sh`, and some other files are arranged in appropriate places.  The\n  reason for combining the files into one file instead of sourcing the related\n  files in runtime is to minimize the shell startup time, which has a large\n  impact on the shell experience.  Opening and reading many files can take a\n  long time.  Some people seem to be angry about `ble.sh` using `make` to build\n  and arrange script files.  They seem to believe that one always needs to use\n  `make` with C/C++/Fortran compilers to generate binaries.  They complain\n  about `ble.sh`'s make process, but it comes from the lack of knowledge on the\n  general principle of `make`.  Some people seem to be angry about `ble.sh`\n  having C/C++ source codes in the repository, but they are used to update the\n  Unicode character table from the Unicode database when a new Unicode standard\n  appears.  The generated table is included in the repository:\n  [`canvas.GraphemeClusterBreak.sh`](https://github.com/akinomyoga/ble.sh/blob/master/src/canvas.GraphemeClusterBreak.sh),\n  [`canvas.c2w.musl.sh`](https://github.com/akinomyoga/ble.sh/blob/master/src/canvas.c2w.musl.sh),\n  [`canvas.c2w.sh`](https://github.com/akinomyoga/ble.sh/blob/master/src/canvas.c2w.sh),\n  and\n  [`canvas.emoji.sh`](https://github.com/akinomyoga/ble.sh/blob/master/src/canvas.emoji.sh),\n  so there is no need to run these C/C++ programs in the build process.\n  Another C file is used as an adapter in an old system MSYS1, which is used\n  with an old compiler toolchain in Windows, but it will never be used in\n  Unix-like systems.  Each file used in the build process is explained in\n  [`make/README.md`](make/README.md).\n\n# 1 Usage\n\n## 1.1 Build from source<sup><a id=\"get-from-source\" href=\"#get-from-source\">†</a></sup>\n\n### Generate\n\nTo generate `ble.sh`, `gawk` (GNU awk) and `gmake` (GNU make) (in addition to Bash and POSIX standard utilities) are required.\nThe file `ble.sh` can be generated using the following commands.\nIf you have GNU make installed on `gmake`, please use `gmake` instead of `make`.\n```bash\ngit clone --recursive https://github.com/akinomyoga/ble.sh.git\ncd ble.sh\nmake\n```\n\nA script file `ble.sh` will be generated in the directory `ble.sh/out`.\n\n### Try\n\nThen, you can load `ble.sh` in the Bash session using the `source` command:\n```bash\nsource out/ble.sh\n```\n\n### Install\n\nTo install `ble.sh` in a specified directory, use `make install`.\n\n```\n# INSTALL to ~/.local/share/blesh and ~/.local/share/doc/blesh\nmake install\n\n# INSTALL into a specified directory\nmake install INSDIR=/path/to/blesh\n```\n\nThe install locations of `ble.sh` and related script files can be specified by\nmake variable `INSDIR`.  The locations of the license files and the\ndocumentation files can be specified by make variables `INSDIR_LICENSE` and\n`INSDIR_DOC`, respectively.  When `INSDIR` is specified, the default values of\n`INSDIR_LICENSE` and `INSDIR_DOC` are `$INSDIR/licenses` and `$INSDIR/doc`.\nWhen `INSDIR` and the below-mentioned `DESTDIR`/`PREFIX` are not specified, the\ndefault values of `INSDIR`, `INSDIR_LICENSES`, and `INSDIR_DOC` are\n`$data/blesh`, `$data/blesh/licenses`, and `$data/doc/blesh`, respectively,\nwhere `$data` represents `${XDG_DATA_HOME:-$HOME/.local/share}/blesh`.\n\nWhen `USE_DOC=no` is specified, the documentation files are disabled.\n\nBy default, the comment lines and blank lines in the script files are stripped\nin the installation process.  If you would like to keep these lines in the\nscript files, please specify the argument `strip_comment=no` to `make`.\n\nTo set up `.bashrc` see [Sec. 1.3](#set-up-bashrc).\n\n### Package\n\nPackage maintainers may use make variables `DESTDIR` and `PREFIX` to quickly\nset up the default values for `INSDIR`, `INSDIR_LICENSE`, and `INSDIR_DOC`.\n\n```bash\n# PACKAGE - Example 1\nmake install DESTDIR=/tmp/blesh-package PREFIX=/usr/local\n\n# PACKAGE - Example 2\nmake install DESTDIR=\"$build\" PREFIX=\"$prefix\" \\\n  INSDIR_LICENSE=\"$build/$prefix/share/licenses/blesh\"\n\n# PACKAGE - Example 3\nmake install DESTDIR=\"$build\" PREFIX=\"$prefix\" \\\n  INSDIR_LICENSE=\"$build/$prefix/share/blesh/doc\" \\\n  INSDIR_DOC=\"$build/$prefix/share/blesh/doc\"\n\n# PACKAGE - Example 4\nmake install USE_DOC=no DESTDIR=\"$build\" PREFIX=\"$prefix\"\n```\n\nIf make variable `DESTDIR` or `PREFIX` is specified instead of `INSDIR`, the\nvalue of `INSDIR` is set to `$DESTDIR/$PREFIX/share/blesh`, and the default\ninstall locations of the license and documentation files, `INSDIR_LICENSE` and\n`INSDIR_DOC`, will be `$DESTDIR/$PREFIX/share/doc/blesh`.\n\n#### `_package.bash`\n\nWhen you want to tell `ble.sh` the way to update the package for `ble-update`,\nyou can place `_package.bash` at `${prefix}/share/blesh/lib/_package.bash`.\nThe file `_package.bash` is supposed to define a shell variable and a shell\nfunction as illustrated in the following example (please replace `XXX` with a\nname representing the package management system):\n\n```bash\n# ${prefix}/share/blesh/lib/_package.bash\n\n_ble_base_package_type=XXX\n\nfunction ble/base/package:XXX/update {\n  update-the-package-in-a-proper-way\n  return 0\n}\n```\n\nWhen the shell function returns exit status 0, it means that the update has been successfully completed, and `ble.sh` will be reloaded automatically.\nWhen the shell function returns exit status 6, the timestamp of `ble.sh` will be checked so `ble.sh` is reloaded only when `ble.sh` is actually updated.\nWhen the shell function returns exit status 125, the default `ble.sh` update procedure is attempted.\nOtherwise, the updating procedure is canceled, where any message explaining situation should be output by the shell function.\nAn example `_package.bash` for `AUR` can be found [here](https://aur.archlinux.org/cgit/aur.git/tree/blesh-update.sh?h=blesh-git).\n\n## 1.2 Download a tarball<sup><a id=\"get-from-tarball\" href=\"#get-from-tarball\">†</a></sup>\n\nYou can also download a tarball of `ble.sh` from GitHub releases.\nSee each release page for the description of downloading, trial and installation.\nMany features are unavailable in the stable versions since they are significantly old compared to the devel version.\n\n- Devel [v0.4.0-devel3](https://github.com/akinomyoga/ble.sh/releases/tag/v0.4.0-devel3) (2023-04), [nightly build](https://github.com/akinomyoga/ble.sh/releases/tag/nightly)\n- Stable [v0.3.4](https://github.com/akinomyoga/ble.sh/releases/tag/v0.3.4) (2019-02 fork) Enhanced completions\n- Stable [v0.2.7](https://github.com/akinomyoga/ble.sh/releases/tag/v0.2.7) (2018-03 fork) Vim mode\n- Stable [v0.1.15](https://github.com/akinomyoga/ble.sh/releases/tag/v0.1.15) (2015-12 fork) Syntax highlighting\n\n## 1.3 Set up `.bashrc`<sup><a id=\"set-up-bashrc\" href=\"#set-up-bashrc\">†</a></sup>\n\nIf you want to load `ble.sh` in interactive sessions of `bash` by default, usually one can just source `ble.sh` in `~/.bashrc`,\nbut a more reliable way is to add the following codes to your `.bashrc` file:\n\n```bash\n# bashrc\n\n# Add this lines at the top of .bashrc:\n[[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach\n\n# your bashrc settings come here...\n\n# Add this line at the end of .bashrc:\n[[ ! ${BLE_VERSION-} ]] || ble-attach\n```\n\nBasically, when `source /path/to/ble.sh` and `ble-attach` are performed,\nstandard streams (`stdin`, `stdout`, and `stderr`) should not be redirected but should be connected to the controlling TTY of the current session.\nAlso, please avoid calling `source /path/to/ble.sh` in shell functions.\nThe detailed conditions where the above *more reliable setup* is needed are explained in [an answer in Discussion #254](https://github.com/akinomyoga/ble.sh/discussions/254#discussioncomment-4284757).\n\n## 1.4 User settings `~/.blerc`\n\nUser settings can be placed in the init script `~/.blerc` (or `${XDG_CONFIG_HOME:-$HOME/.config}/blesh/init.sh` if `~/.blerc` is not available)\nwhose template is available as the file [`blerc.template`](https://github.com/akinomyoga/ble.sh/blob/master/blerc.template) in the repository.\nThe init script is a Bash script that is sourced during the load of `ble.sh`, so any shell commands can be used in `~/.blerc`.\nIf you want to change the default path of the init script, you can add the option `--rcfile INITFILE` to `source ble.sh` as the following example:\n\n```bash\n# in bashrc\n\n# Example 1: ~/.blerc will be used by default\n[[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach\n\n# Example 2: /path/to/your/blerc will be used\n[[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach --rcfile /path/to/your/blerc\n```\n\n## 1.5 Update\n\nYou need Git (`git`), GNU awk (`gawk`) and GNU make (`make`).\nFor `ble-0.3+`, you can run `ble-update` in the session with `ble.sh` loaded:\n\n```bash\n$ ble-update\n```\n\nFor `ble.0.4+`, you can also update it outside the `ble.sh` session using\n\n```bash\n$ bash /path/to/ble.sh --update\n```\n\nYou can instead download the latest version by `git pull` and install it:\n\n```bash\ncd ble.sh   # <-- enter the git repository you already have\ngit pull\ngit submodule update --recursive --remote\nmake\nmake INSDIR=\"$HOME/.local/share/blesh\" install\n```\n\n## 1.6 Uninstall\n\nBasically you can simply delete the installed directory and the settings that the user added.\n\n- Close all the `ble.sh` sessions (the Bash interactive sessions with `ble.sh`)\n- Remove related user data. If you would like to keep them, you can skip these steps.\n  - Remove the added lines in `.bashrc`.\n  - Remove `blerc` files (`~/.blerc` or `~/.config/blesh/init.sh`) if any.\n  - Remove the state directory `~/.local/state/blesh` if any.\n- Remove the directory where `ble.sh` is installed.  When you use `out/ble.sh`\n  inside the working tree of the git repository, the installed directory is the\n  directory of the repository.  When you use `ble.sh` installed by `make\n  install`, the installed directory is `<PREFIX>/share/blesh` where `<PREFIX>`\n  (default: `~/.local`) is the prefix specified to `make install` in the\n  installation stage.  When you use the version extracted from a tarball, the\n  directory created by extracting the tarball is the installed directory.\n- Remove the cache directory `~/.cache/blesh` if any.\n- Remove the temporary directory `/tmp/blesh` if any [ Only needed when your system does not automatically clear `/tmp` ].\n\n## 1.7 Troubleshooting\n\n- [Performance](https://github.com/akinomyoga/ble.sh/wiki/Performance)\n  describes hints for perfomance issue.\n- [Reportin Issues](https://github.com/akinomyoga/ble.sh/wiki/Reporting-Issues)\n  describes information that you may check before reporting an issue.\n\n# 2 Basic settings\n\nHere, some of the settings for `~/.blerc` are picked up.\nYou can find useful settings also in [Q\\&A](https://github.com/akinomyoga/ble.sh/wiki/Q&A),\n[Recipes](https://github.com/akinomyoga/ble.sh/wiki/Recipes),\nand [`contrib` repository](https://github.com/akinomyoga/blesh-contrib).\nThe complete list of setting items can be found in the file [`blerc.template`](https://github.com/akinomyoga/ble.sh/blob/master/blerc.template).\nFor detailed explanations please refer to [Manual](https://github.com/akinomyoga/ble.sh/wiki).\n\n## 2.1 Vim mode\n\nFor the vi/vim mode, check [the wiki page](https://github.com/akinomyoga/ble.sh/wiki/Vi-(Vim)-editing-mode).\n\n## 2.2 Disable features\n\nOne of frequently asked questions is the way to disable a specific feature that `ble.sh` adds.\nHere the settings for disabling features are summarized.\n\n```bash\n# Disable syntax highlighting\nbleopt highlight_syntax=\n\n# Disable highlighting based on filenames\nbleopt highlight_filename=\n\n# Disable highlighting based on variable types\nbleopt highlight_variable=\n\n# Disable auto-complete (Note: auto-complete is enabled by default in bash-4.0+)\nbleopt complete_auto_complete=\n# Tip: you may instead specify the delay of auto-complete in millisecond\nbleopt complete_auto_delay=300\n\n# Disable auto-complete based on the command history\nbleopt complete_auto_history=\n\n# Disable ambiguous completion\nbleopt complete_ambiguous=\n\n# Disable menu-complete by TAB\nbleopt complete_menu_complete=\n\n# Disable menu filtering (Note: auto-complete is enabled by default in bash-4.0+)\nbleopt complete_menu_filter=\n\n# Disable EOF marker like \"[ble: EOF]\"\nbleopt prompt_eol_mark=''\n# Tip: you may instead specify another string:\nbleopt prompt_eol_mark='⏎'\n\n# Disable error exit marker like \"[ble: exit %d]\"\nbleopt exec_errexit_mark=\n# Tip: you may instead specify another string:\nbleopt exec_errexit_mark=$'\\e[91m[error %d]\\e[m'\n\n# Disable elapsed-time marker like \"[ble: elapsed 1.203s (CPU 0.4%)]\"\nbleopt exec_elapsed_mark=\n# Tip: you may instead specify another string\nbleopt exec_elapsed_mark=$'\\e[94m[%ss (%s %%)]\\e[m'\n# Tip: you may instead change the threshold of showing the mark\nbleopt exec_elapsed_enabled='sys+usr>=10*60*1000' # e.g. ten minutes for total CPU usage\n\n# Disable exit marker like \"[ble: exit]\"\nbleopt exec_exit_mark=\n\n# Disable some other markers like \"[ble: ...]\"\nbleopt edit_marker=\nbleopt edit_marker_error=\n```\n\n## 2.3 CJK Width\n\nThe option `char_width_mode` controls the width of the Unicode characters with `East_Asian_Width=A` (Ambiguous characters).\nCurrently, four values `emacs`, `west`, `east`, and `auto` are supported. With the value `emacs`, the default width in emacs is used.\nWith `west`, all the ambiguous characters have width 1 (Hankaku). With `east`, all the ambiguous characters have width 2 (Zenkaku).\nWith `auto`, the width mode `west` or `east` is automatically chosen based on the terminal behavior.\nThe default value is `auto`. The appropriate value should be chosen in accordance with your terminal behavior.\nFor example, the value can be changed to `west` as:\n\n```bash\nbleopt char_width_mode='west'\n```\n\n## 2.4 Input Encoding\n\nThe option `input_encoding` controls the encoding scheme used in the decode of input. Currently `UTF-8` and `C` are available. With the value `C`, byte values are directly interpreted as character codes. The default value is `UTF-8`. For example, the value can be changed to `C` as:\n\n```bash\nbleopt input_encoding='C'\n```\n\n## 2.5 Bell\n\nThe option `edit_bell` controls the behavior of the edit function (widget)\ncalled `bell`.  It is a colon-separated list of the values `vbell`, `abell`,\nand `visual`.  When a value is contained, the corresponding type of the bell is\nenabled.  The value `abell` corresponds to the audible bell, which prints ASCII\nControl Character <kbd>BEL</kbd> (0x07) will be written to `stderr`.  The value\n`vbell` corresponds to the visible bell, which shows the message in the\nterminal display.  The value `visual` corresponds to the visual bell, which\nflashes the terminal screen by turning on the <kbd>DECSCNM</kbd> mode for a\nshort moment.  By default, only the audible bell is enabled.\n\nThe option `vbell_default_message` specifies the default message shown by the\nvisual bell. The default value of this setting is `' Wuff, -- Wuff!! '`. The\noption `vbell_duration` specifies the display duration of the visual-bell\nmessage. The unit is a millisecond. The default value is `2000`.  The option\n`vbell_align` specifies the position of `vbell` by `left`, `center`, or\n`right`.\n\nFor example, the audible bell can be disabled, and the visual bell can be set\nup as:\n\n```bash\nbleopt edit_bell=vbell vbell_{default_message=' BEL ',duration=3000,align=right}\n```\n\n## 2.6 Highlight Colors\n\nThe colors and attributes used in the syntax highlighting are controlled by the function `ble-face`. The following code reproduces the default configuration:\n```bash\n# highlighting related to editing\nble-face -s region                    bg=60,fg=231\nble-face -s region_target             bg=153,fg=black\nble-face -s region_match              bg=55,fg=231\nble-face -s region_insert             fg=27,bg=254\nble-face -s disabled                  fg=242\nble-face -s overwrite_mode            fg=black,bg=51\nble-face -s vbell                     reverse\nble-face -s vbell_erase               bg=252\nble-face -s vbell_flash               fg=green,reverse\nble-face -s prompt_status_line        fg=231,bg=240\n\n# syntax highlighting\nble-face -s syntax_default            none\nble-face -s syntax_command            fg=brown\nble-face -s syntax_quoted             fg=green\nble-face -s syntax_quotation          fg=green,bold\nble-face -s syntax_escape             fg=magenta\nble-face -s syntax_expr               fg=33\nble-face -s syntax_error              bg=203,fg=231\nble-face -s syntax_varname            fg=202\nble-face -s syntax_delimiter          bold\nble-face -s syntax_param_expansion    fg=133\nble-face -s syntax_history_expansion  bg=94,fg=231\nble-face -s syntax_function_name      fg=99,bold\nble-face -s syntax_comment            fg=242\nble-face -s syntax_glob               fg=198,bold\nble-face -s syntax_brace              fg=37,bold\nble-face -s syntax_tilde              fg=63,bold\nble-face -s syntax_document           fg=100\nble-face -s syntax_document_begin     fg=100,bold\nble-face -s command_builtin_dot       fg=red,bold\nble-face -s command_builtin           fg=red\nble-face -s command_alias             fg=teal\nble-face -s command_function          fg=99\nble-face -s command_file              fg=green\nble-face -s command_keyword           fg=blue\nble-face -s command_jobs              fg=red\nble-face -s command_directory         fg=33,underline\nble-face -s command_suffix            fg=231,bg=28\nble-face -s command_suffix_new        fg=231,bg=124\nble-face -s filename_directory        underline,fg=33\nble-face -s filename_directory_sticky underline,fg=231,bg=26\nble-face -s filename_link             underline,fg=teal\nble-face -s filename_orphan           underline,fg=16,bg=224\nble-face -s filename_executable       underline,fg=green\nble-face -s filename_setuid           underline,fg=black,bg=220\nble-face -s filename_setgid           underline,fg=black,bg=191\nble-face -s filename_other            underline\nble-face -s filename_socket           underline,fg=cyan,bg=black\nble-face -s filename_pipe             underline,fg=lime,bg=black\nble-face -s filename_character        underline,fg=231,bg=black\nble-face -s filename_block            underline,fg=yellow,bg=black\nble-face -s filename_warning          underline,fg=red\nble-face -s filename_url              underline,fg=blue\nble-face -s filename_ls_colors        underline\nble-face -s varname_array             fg=orange,bold\nble-face -s varname_empty             fg=31\nble-face -s varname_export            fg=200,bold\nble-face -s varname_expr              fg=99,bold\nble-face -s varname_hash              fg=70,bold\nble-face -s varname_new               fg=34\nble-face -s varname_number            fg=64\nble-face -s varname_readonly          fg=200\nble-face -s varname_transform         fg=29,bold\nble-face -s varname_unset             fg=245\nble-face -s argument_option           fg=teal\nble-face -s argument_error            fg=black,bg=225\n\n# highlighting for completions\nble-face -s auto_complete             fg=238,bg=254\nble-face -s menu_complete_match       bold\nble-face -s menu_complete_selected    reverse\nble-face -s menu_desc_default         none\nble-face -s menu_desc_type            ref:syntax_delimiter\nble-face -s menu_desc_quote           ref:syntax_quoted\nble-face -s menu_filter_fixed         bold\nble-face -s menu_filter_input         fg=16,bg=229\n```\n\nThe current list of faces can be obtained by the following command (`ble-face` without arguments):\n```console\n$ ble-face\n```\n\nThe color codes can be checked in output of the function `ble-color-show` (defined in `ble.sh`):\n```console\n$ ble-color-show\n```\n\n## 2.7 Key Bindings\n\nKey bindings can be controlled with the shell function, `ble-bind`.\nFor example, with the following setting, \"Hello, world!\" will be inserted on typing <kbd>C-x h</kbd>\n```bash\nble-bind -f 'C-x h' 'insert-string \"Hello, world!\"'\n```\n\nThe details on the key representation, such as <kbd>C-x h</kbd> in the above example,\nare described in [Manual §3.1](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A73-Key-Binding#user-content-sec-kspecs).\nThe representations of <kbd>Space</kbd>, <kbd>Tab</kbd>, <kbd>Enter</kbd>, <kbd>Backspace</kbd>, <kbd>Escape</kbd>, etc. are described\nin [Manual §3.1.1](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A73-Key-Binding#user-content-sec-kspecs-ret):\nThe space is represented as <kbd>SP</kbd>,\nthe tab key is represented as <kbd>C-i</kbd> or <kbd>TAB</kbd> depending on the terminal,\nthe enter/return key is represented as <kbd>C-m</kbd> or <kbd>RET</kbd> depending on the terminal,\nand the backspace key is represented as <kbd>C-?</kbd>, <kbd>DEL</kbd>, <kbd>C-h</kbd>, or <kbd>BS</kbd> depending on the terminal.\nThe representations of modified special keys such as <kbd>Ctrl+Return</kbd> and <kbd>Shift+Return</kbd> are described\nin [Manual §3.6.4](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A73-Key-Binding#user-content-sec-modifyOtherKeys-manual):\nIf your terminal does not support `modifyOtherKeys`, you need to manually configure the escape sequences of modified special keys.\n\n\nFor another example, if you want to invoke a command on typing <kbd>M-c</kbd>, you can write it as follows:\n\n```bash\nble-bind -c 'M-c' 'my-command'\n```\n\nOr, if you want to invoke a edit function (designed for Bash `bind -x`) on typing <kbd>C-r</kbd>, you can write it as follows:\n\n```bash\nble-bind -x 'C-r' 'my-edit-function'\n```\n\nThe existing key bindings are shown by the following command:\n```console\n$ ble-bind -P\n```\n\nThe list of widgets is shown by the following command:\n```console\n$ ble-bind -L\n```\n\nDescriptions of widgets can be found in the manual on the wiki.\n\nIf you want to run multiple widgets with a key, you can define your own widget by creating a function of the name `ble/widget/YOUR_WIDGET_NAME`\nas illustrated in the following example.\nIt is highly recommended to prefix the widget name with `YOUR_NAME/`, `my/`, `blerc/`, `dotfiles/`, etc.\nin order not to conflict with the names of the existing standard widgets.\n\n```bash\n# Example of calling multiple widgets with the key C-t\nfunction ble/widget/my/example1 {\n  ble/widget/beginning-of-logical-line\n  ble/widget/insert-string 'echo $('\n  ble/widget/end-of-logical-line\n  ble/widget/insert-string ')'\n}\nble-bind -f C-t my/example1\n```\n\n## 2.8 fzf integration<sup><a id=\"fzf-integration\" href=\"#fzf-integration\">†</a></sup>\n\nIf you would like to use `fzf` in combination with `ble.sh`, you need to configure `fzf` using [the `contrib/fzf` integration](https://github.com/akinomyoga/blesh-contrib#pencil-fzf-integration).\nPlease follow the instructions in the link for the detailed description.\n\n```bash\n# blerc\n\n# Note: If you want to combine fzf-completion with bash_completion, you need to\n# load bash_completion earlier than fzf-completion.  This is required\n# regardless of whether to use ble.sh or not.\nsource /etc/profile.d/bash_completion.sh\n\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\n```\n\nThe option `-d` of `ble-import` delays the initialization.  In this way, the\nfzf settings are loaded in background after the prompt is shown.  See\n[`ble-import` - Manual §8](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A78-Miscellaneous#user-content-fn-ble-import)\nfor details.\n\n### When you have additional configuration for fzf\n\nWhen you want to run codes of the additional configuration after the fzf\nsettings are loaded, you cannot simply write them after the above settings\nbecause of the delayed loading of the fzf settings.  In this case, there are\nfour options.  The easiest way is to drop the `-d` option (Option 1 below) to\ndisable the delayed loading:\n\n```bash\n# [1] Drop -d\nble-import integration/fzf-completion\nble-import integration/fzf-key-bindings\n<settings>\n```\n\nHowever, the above setting may make the initialization time longer.  As another\noption, you may also delay the additional settings with `ble-import -d` [2] or\n`ble/util/idle.push` [3].  Or, you can hook into the loading of the fzf\nsettings by `ble-import -C` [4].\n\n```bash\n# [2] Use ble-import -d for additional settings\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\nble-import -d '<filename containing the settings>'\n\n# [3] Use \"ble/util/idle.push\" for additional settings\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\nble/util/idle.push '<settings>'\n\n# [4] Use \"ble-import -C\" for additional settings\nble-import -d integration/fzf-completion\nble-import -d integration/fzf-key-bindings\nble-import -C '<settings>' integration/fzf-key-bindings\n```\n\n# 3 Tips\n\n## 3.1 Use multiline mode\n\nWhen the command line string contains a newline character, `ble.sh` enters the MULTILINE mode.\n\nBy typing <kbd>C-v C-j</kbd> or <kbd>C-q C-j</kbd>, you can insert a newline character in the command line string.\nIn the MULTILINE mode, <kbd>RET</kbd> (<kbd>C-m</kbd>) causes the insertion of a new newline character.\nIn the MULTILINE mode, the command can be executed by typing <kbd>C-j</kbd>.\n\nWhen the shell option `shopt -s cmdhist` is set (which is the default),\n<kbd>RET</kbd> (<kbd>C-m</kbd>) inserts a newline if the current command line string is syntactically incomplete.\n\n## 3.2 Use vim editing mode\n\nIf `set -o vi` is specified in `.bashrc` or `set editing-mode vi` is specified in `.inputrc`, the vim mode is enabled.\nFor details, please check [the wiki page](https://github.com/akinomyoga/ble.sh/wiki/Vi-(Vim)-editing-mode).\n\n## 3.3 Use `auto-complete`\n\nThe feature `auto-complete` is available in Bash 4.0 or later. `auto-complete` automatically suggests a possible completion on user input.\nThe suggested contents can be inserted by typing <kbd>S-RET</kbd>\n(when the cursor is at the end of the command line, you can also use <kbd>right</kbd>, <kbd>C-f</kbd>, or <kbd>end</kbd> to insert the suggestion).\nIf you want to insert only the first word of the suggested contents, you can use <kbd>M-right</kbd> or <kbd>M-f</kbd>.\nIf you want to accept the suggestion and immediately run the command, you can use <kbd>C-RET</kbd>\n(if your terminal does not support special key combinations like <kbd>C-RET</kbd>, please check\n[Manual §3.6.4](https://github.com/akinomyoga/ble.sh/wiki/Manual-%C2%A73-Key-Binding#user-content-sec-modifyOtherKeys-manual)).\n\n## 3.4 Use `sabbrev` (static abbrev expansions)\n\nBy registering words to `sabbrev`, the words can be expanded to predefined strings.\nWhen the cursor is just after a registered word, typing <kbd>SP</kbd> causes the `sabbrev` expansion.\nFor example, with the following settings, when you type <kbd>SP</kbd> after the string `command L`, the command line will be expanded to `command | less`.\n\n```bash\n# blerc\nble-sabbrev L='| less'\n```\n\nThe sabbrev names that start with `\\` plus alphabetical letters are also recommended since it is unlikely to conflict with real words that are a part of the executed command.\n\n```bash\n# blerc\nble-sabbrev '\\L'='| less'\n```\n\nThe sabbrevs starting with `~` can be expanded also by <kbd>/</kbd>.  This can be used to approximate Zsh's named directories.\nFor example, with the following settings, typing `~mybin/` expands it to e.g. `/home/user/bin/` (where we assumed `HOME=/home/user`).\n\n```bash\n# blerc\n\nble-sabbrev \"~mybin=$HOME/bin\"\n```\n\n# 4 Contributors\n\nI received much feedback from many people in GitHub Issues/PRs.\nI thank all such people for supporting the project.\nAmong them, the following people have made particularly significant contributions.\n\n- [`@cmplstofB`](https://github.com/cmplstofB) helped me implement vim-mode by testing it and giving me a lot of suggestions.\n- [`@dylankb`](https://github.com/dylankb) reported many issues with the fzf integration, initialization, etc.\n- [`@rux616`](https://github.com/rux616) reported several issues and created a PR for fixing the default path of `.blerc`\n- [`@timjrd`](https://github.com/timjrd) suggested and contributed to performance improvements in completion.\n- [`@3ximus`](https://github.com/3ximus) reported many issues for a wide variety of problems.\n- [`@SuperSandro2000`](https://github.com/SuperSandro2000) reported many issues related to NixOS and others\n"
        },
        {
          "name": "archive",
          "type": "tree",
          "content": null
        },
        {
          "name": "ble.pp",
          "type": "blob",
          "size": 108.1806640625,
          "content": "#!/bin/bash\n#%$> out/ble.sh\n#%[release = 0]\n#%[measure_load_time = 0]\n#%[debug_keylogger = 1]\n#%[leakvar = \"\"]\n#%#----------------------------------------------------------------------------\n#%if measure_load_time\n_ble_init_measure_prev=\n_ble_init_measure_section=\nfunction ble/init/measure/section {\n  local now=${EPOCHREALTIME:-$(date +'%s.%N')}\n\n  local s=${now%%[!0-9]*} u=000000\n  if [[ $s != \"$now\" ]]; then\n    u=${now##*[!0-9]}000000\n    u=${u::6}\n  fi\n  local stime=$s.$u time=$((s*1000000+10#0$u))\n\n  if [[ $_ble_init_measure_section ]]; then\n    local elapsed=$((time-_ble_init_measure_prev))\n    s=$((elapsed/1000))\n    u=00$((elapsed%1000))\n    u=${u:${#u}-3}\n    elapsed=$s.${u}ms\n    builtin printf '[ble.sh init %s] %s done (%s)\\n' \"$stime\" \"$_ble_init_measure_section\" \"$elapsed\" >&2\n  else\n    builtin printf '[ble.sh init %s] start\\n' \"$stime\" >&2\n  fi\n\n  _ble_init_measure_section=$1\n  _ble_init_measure_prev=$time\n}\n_ble_debug_measure_fork_count=$(echo $BASHPID)\nTIMEFORMAT='  [Elapsed %Rs; CPU U:%Us S:%Ss (%P%%)]'\nfunction ble/debug/measure-set-timeformat {\n  local title=$1 opts=$2\n  local new=$(echo $BASHPID)\n  local fork=$(((new-_ble_debug_measure_fork_count-1)&0xFFFF))\n  _ble_debug_measure_fork_count=$new\n  TIMEFORMAT=\"  [Elapsed %Rs; CPU U:%Us S:%Ss (%P%%)] $title\"\n  [[ :$opts: != *:nofork:* ]] &&\n    TIMEFORMAT=$TIMEFORMAT\" ($fork forks)\"\n}\n#%end\n#%if leakvar\n#%%expand\n$\"leakvar\"=__t1wJltaP9nmow__\n#%%end.i\nfunction ble/bin/grep { command grep \"$@\"; }\nfunction ble/util/print { printf '%s\\n' \"$1\"; }\nsource \"${BASH_SOURCE%/*}/lib/core-debug.sh\"\n#%end\n#%define inc\n#%%[guard_name = \"@_included\".replace(\"[^_a-zA-Z0-9]\", \"_\")]\n#%%expand\n#%%%if $\"guard_name\" != 1\n#%%%%[$\"guard_name\" = 1]\n###############################################################################\n# Included from @.sh\n\n#%%%%if leakvar\nble/debug/leakvar#check $\"leakvar\" \"[before include @.sh]\"\n#%%%%end.i\n#%%%%if measure_load_time\ntime {\n#%%%%%include @.sh\nble/debug/measure-set-timeformat '@.sh'\n}\n#%%%%else\n#%%%%%include @.sh\n#%%%%end\n#%%%%if leakvar\nble/debug/leakvar#check $\"leakvar\" \"[after include @.sh]\"\n#%%%%end.i\n#%%%end\n#%%end.i\n#%end\n#%#----------------------------------------------------------------------------\n# ble.sh -- Bash Line Editor (https://github.com/akinomyoga/ble.sh)\n#\n#   Bash configuration designed to be sourced in interactive bash sessions.\n#\n#   Copyright: 2013, 2015-2019, Koichi Murase <myoga.murase@gmail.com>\n#\n\n#%if measure_load_time\nble/init/measure/section 'parse'\ntime {\nble/init/measure/section 'source'\n# load_time (2015-12-03)\n#   core           12ms\n#   decode         10ms\n#   color           2ms\n#   edit            9ms\n#   syntax          5ms\n#   ble-initialize 14ms\ntime {\n#%end\n#------------------------------------------------------------------------------\n# check --help or --version\n\n{\n  #%[commit_hash = getenv(\"BLE_GIT_COMMIT_ID\")]\n  #%[ble_version = getenv(\"FULLVER\") + \"+\" + commit_hash]\n  #%expand\n  ##%if commit_hash != \"\"\n  _ble_init_version=$\"ble_version\"\n  ##%else\n  ###%error Failed to get the commit id (version = $\"ble_version\").\n  ##%end\n  #%end.i\n  _ble_init_exit=\n  _ble_init_command=\n  for _ble_init_arg; do\n    case $_ble_init_arg in\n    --version)\n      _ble_init_exit=0\n      echo \"ble.sh (Bash Line Editor), version $_ble_init_version\" ;;\n    --help)\n      _ble_init_exit=0\n      printf '%s\\n' \\\n             \"# ble.sh (Bash Line Editor), version $_ble_init_version\" \\\n             'usage: source ble.sh [OPTION...]' \\\n             '' \\\n             'OPTION' \\\n             '' \\\n             '  --help' \\\n             '    Show this help and exit' \\\n             '  --version' \\\n             '    Show version and exit' \\\n             '  --test' \\\n             '    Run test and exit' \\\n             '  --update' \\\n             '    Update ble.sh and exit' \\\n             '  --clear-cache' \\\n             '    Clear ble.sh cache and exit' \\\n             '  --install PREFIX' \\\n             '    Install ble.sh and exit' \\\n             '' \\\n             '  --rcfile=BLERC' \\\n             '  --init-file=BLERC' \\\n             '    Specify the ble init file. The default is ~/.blerc if any, or' \\\n             '    ~/.config/blesh/init.sh.' \\\n             '' \\\n             '  --norc' \\\n             '    Do not load the ble init file.' \\\n             '' \\\n             '  --attach=ATTACH' \\\n             '  --noattach' \\\n             '    The option \"--attach\" selects the strategy of \"ble-attach\" from the list:' \\\n             '    ATTACH = \"attach\" | \"prompt\" | \"none\". The default strategy is \"prompt\".' \\\n             '    When \"attach\" is specified, ble.sh immediately attaches to the session in' \\\n             '    \"source ble.sh\".  When \"prompt\" is specified, ble.sh attaches to the' \\\n             '    session before the first prompt using PROMPT_COMMAND.  When \"none\" is' \\\n             '    specified, ble.sh does not attach to the session automatically, so' \\\n             '    ble-attach needs to be called explicitly.  The option \"--noattach\" is a' \\\n             '    synonym for \"--attach=none\".' \\\n             '' \\\n             '  --inputrc=TYPE' \\\n             '  --noinputrc' \\\n             '    The option \"--inputrc\" selects the strategy of reconstructing user' \\\n             '    keybindings from the list: \"auto\" (default), \"diff\", \"all\", \"user\", \"none\".' \\\n             '    When \"diff\" is specified, user keybindings are extracted by the diff of the' \\\n             '    outputs of the \"bind\" builtin between the current session and the plain' \\\n             '    Bash.  When \"all\" is specified, the user keybindings are extracted from' \\\n             '    /etc/inputrc and ${INPUTRC:-~/.inputrc*}.  When \"user\" is specified, the' \\\n             '    user keybindings are extracted from ${INPUTRC:-~/.inputrc*}.  When \"none\"' \\\n             '    is specified, the user keybindings are not reconstructed from the state of' \\\n             '    Readline, and only the bindings by \"ble-bind\" are applied.  The option' \\\n             '    \"--noinputrc\" is a synonym for \"--inputrc=none\".' \\\n             '' \\\n             '  --keep-rlvars' \\\n             '    Do not change readline settings for ble.sh' \\\n             '' \\\n             '  --bash-debug-version=TYPE' \\\n             '    This controls the warning mesage for the debug version of Bash.  When' \\\n             '    \"full\" is specified to TYPE, ble.sh prints the full message to the terminal' \\\n             '    when it is loaded in a debug version of Bash.  This is the default.  When' \\\n             '    \"short\" is specified, a short version of the message is printed.  When' \\\n             '    \"once\" is specified, the full message is printed only once for a specific' \\\n             '    version of debug Bash.  When \"ignore\" is specified, the message is not' \\\n             '    printed even when ble.sh is loaded in a debug version of Bash.' \\\n             '' \\\n             '  -o BLEOPT=VALUE' \\\n             '    Set a value for the specified bleopt option.' \\\n             '  --debug-bash-output' \\\n             '    Internal settings for debugging' \\\n             '' ;;\n    --test | --update | --clear-cache | --lib | --install) _ble_init_command=1 ;;\n    esac\n  done\n  unset _ble_init_arg\n  if [ -n \"$_ble_init_exit\" ]; then\n    unset _ble_init_exit\n    unset _ble_init_command\n    unset _ble_init_version\n    return 0 2>/dev/null || exit 0\n  fi\n} 2>/dev/null # set -x 対策 #D0930\n\n#------------------------------------------------------------------------------\n# check shell\n\nif [ -z \"${BASH_VERSION-}\" ]; then\n  echo \"ble.sh: This shell is not Bash. Please use this script with Bash.\" >&3\n  unset _ble_init_exit\n  unset _ble_init_command\n  unset _ble_init_version\n  return 1 2>/dev/null || exit 1\nfi 3>&2 >/dev/null 2>&1 # set -x 対策 #D0930\n\nif [ -z \"${BASH_VERSINFO-}\" ] || [ \"${BASH_VERSINFO-0}\" -lt 3 ]; then\n  echo \"ble.sh: Bash with a version under 3.0 is not supported.\" >&3\n  unset -v _ble_init_exit _ble_init_command _ble_init_version\n  return 1 2>/dev/null || exit 1\nfi 3>&2 >/dev/null 2>&1 # set -x 対策 #D0930\n\nif [[ ! $_ble_init_command ]]; then\n  # We here check the cases where we do not want a line editor.  We first check\n  # the cases that Bash provides.  We also check the cases where other\n  # frameworks try to do a hack using an interactive Bash.  We honestly do not\n  # want to add exceptions for every random framework that tries to do a naive\n  # hack using interactive sessions, but it is easier than instructing users to\n  # add a proper workaround/check by themselves.\n  if [[ ${BASH_EXECUTION_STRING+set} ]]; then\n    # builtin echo \"ble.sh: ble.sh will not be activated for Bash started with '-c' option.\" >&3\n    _ble_init_exit=1\n  elif ((BASH_SUBSHELL)); then\n    builtin echo \"ble.sh: ble.sh cannot be loaded into a subshell.\" >&3\n    _ble_init_exit=1\n  elif [[ $- != *i* ]]; then\n    case \" ${BASH_SOURCE[*]##*/} \" in\n    (*' .bashrc '* | *' .bash_profile '* | *' .profile '* | *' bashrc '* | *' profile '*) ((0)) ;;\n    esac &&\n      builtin echo \"ble.sh: This is not an interactive session.\" >&3 || ((1))\n    _ble_init_exit=1\n  elif ! [[ -t 4 && -t 5 ]] && ! { [[ ${bleopt_connect_tty-} ]] && >/dev/tty; }; then\n    if [[ ${bleopt_connect_tty-} ]]; then\n      builtin echo \"ble.sh: cannot find a controlling TTY/PTY in this session.\" >&3\n    else\n      builtin echo \"ble.sh: stdout/stdin are not connected to TTY/PTY.\" >&3\n    fi\n    _ble_init_exit=1\n  elif [[ ${NRF_CONNECT_VSCODE-} && ! -t 3 ]]; then\n    # Note #D2129: VS Code Extension \"nRF Connect\" tries to extract an\n    # interactive setting by sending multiline commands to an interactive\n    # session.  We may turn off accept_line_threshold for an nRF Connect\n    # session as we do for Midnight Commander, but we do not need to enable the\n    # line editor for nRF Connect in the first place.\n    _ble_init_exit=1\n  fi\n\n  if [[ $_ble_init_exit ]]; then\n    builtin unset -v _ble_init_exit _ble_init_command _ble_init_version\n    return 1 2>/dev/null || builtin exit 1\n  fi\nfi 3>&2 4<&0 5>&1 &>/dev/null # set -x 対策 #D0930\n\n{\n  _ble_bash=$((BASH_VERSINFO[0]*10000+BASH_VERSINFO[1]*100+BASH_VERSINFO[2]))\n\n  ## @var _ble_bash_POSIXLY_CORRECT_adjusted\n  ##   現在 POSIXLY_CORRECT 状態を待避した状態かどうかを保持します。\n  ## @var _ble_bash_POSIXLY_CORRECT_set\n  ##   待避した POSIXLY_CORRECT の設定・非設定状態を保持します。\n  ## @var _ble_bash_POSIXLY_CORRECT_set\n  ##   待避した POSIXLY_CORRECT の値を保持します。\n  _ble_bash_POSIXLY_CORRECT_adjusted=1\n  _ble_bash_POSIXLY_CORRECT_set=${POSIXLY_CORRECT+set}\n  _ble_bash_POSIXLY_CORRECT=${POSIXLY_CORRECT-}\n\n  POSIXLY_CORRECT=y\n\n  # 暫定対策 expand_aliases (ble/base/adjust-bash-options を呼び出す迄の暫定)\n  _ble_bash_expand_aliases=\n  \\shopt -q expand_aliases &&\n    _ble_bash_expand_aliases=1 &&\n    \\shopt -u expand_aliases || ((1))\n\n  # 対策 FUNCNEST\n  _ble_bash_FUNCNEST_adjusted=\n  _ble_bash_FUNCNEST=\n  _ble_bash_FUNCNEST_set=\n  _ble_bash_FUNCNEST_adjust='\n    if [[ ! $_ble_bash_FUNCNEST_adjusted ]]; then\n      _ble_bash_FUNCNEST_adjusted=1\n      _ble_bash_FUNCNEST_set=${FUNCNEST+set}\n      _ble_bash_FUNCNEST=${FUNCNEST-}\n      \\builtin unset -v FUNCNEST\n    fi 2>/dev/null'\n  _ble_bash_FUNCNEST_restore='\n    if [[ $_ble_bash_FUNCNEST_adjusted ]]; then\n      _ble_bash_FUNCNEST_adjusted=\n      if [[ $_ble_bash_FUNCNEST_set ]]; then\n        FUNCNEST=$_ble_bash_FUNCNEST\n      else\n        \\builtin unset -v FUNCNEST\n      fi\n    fi 2>/dev/null'\n  _ble_bash_FUNCNEST_local_adjust='\n    \\local _ble_local_FUNCNEST _ble_local_FUNCNEST_set\n    _ble_local_FUNCNEST_set=${FUNCNEST+set}\n    _ble_local_FUNCNEST=${FUNCNEST-}\n    if [[ $_ble_local_FUNCNEST_set ]]; then\n      \\local FUNCNEST\n      \\builtin unset -v FUNCNEST\n    fi'\n  _ble_bash_FUNCNEST_local_leave='\n    if [[ $_ble_local_FUNCNEST_set ]]; then\n      FUNCNEST=$_ble_local_FUNCNEST\n    fi'\n  \\builtin eval -- \"$_ble_bash_FUNCNEST_adjust\"\n\n  \\builtin unset -v POSIXLY_CORRECT\n\n  _ble_bash_POSIXLY_CORRECT_adjust='\n    if [[ ! ${_ble_bash_POSIXLY_CORRECT_adjusted-} ]]; then\n      _ble_bash_POSIXLY_CORRECT_adjusted=1\n      _ble_bash_POSIXLY_CORRECT_set=${POSIXLY_CORRECT+set}\n      _ble_bash_POSIXLY_CORRECT=${POSIXLY_CORRECT-}\n      if [[ $_ble_bash_POSIXLY_CORRECT_set ]]; then\n        \\builtin unset -v POSIXLY_CORRECT\n      fi\n\n      # ユーザが触ったかもしれないので何れにしても workaround を呼び出す。\n      ble/base/workaround-POSIXLY_CORRECT\n    fi'\n  _ble_bash_POSIXLY_CORRECT_unset='\n    if [[ ${POSIXLY_CORRECT+set} ]]; then\n      \\builtin unset -v POSIXLY_CORRECT\n      ble/base/workaround-POSIXLY_CORRECT\n    fi'\n  _ble_bash_POSIXLY_CORRECT_local_adjust='\n    \\builtin local _ble_local_POSIXLY_CORRECT _ble_local_POSIXLY_CORRECT_set\n    _ble_local_POSIXLY_CORRECT_set=${POSIXLY_CORRECT+set}\n    _ble_local_POSIXLY_CORRECT=${POSIXLY_CORRECT-}\n    '$_ble_bash_POSIXLY_CORRECT_unset\n  _ble_bash_POSIXLY_CORRECT_local_leave='\n    if [[ $_ble_local_POSIXLY_CORRECT_set ]]; then\n      POSIXLY_CORRECT=$_ble_local_POSIXLY_CORRECT\n    fi'\n  _ble_bash_POSIXLY_CORRECT_local_enter='\n    _ble_local_POSIXLY_CORRECT_set=${POSIXLY_CORRECT+set}\n    _ble_local_POSIXLY_CORRECT=${POSIXLY_CORRECT-}\n    '$_ble_bash_POSIXLY_CORRECT_unset\n  _ble_bash_POSIXLY_CORRECT_local_return='\n    \\builtin local _ble_local_POSIXLY_CORRECT_ext=$?\n    if [[ $_ble_local_POSIXLY_CORRECT_set ]]; then\n      POSIXLY_CORRECT=$_ble_local_POSIXLY_CORRECT\n    fi\n    \\return \"$_ble_local_POSIXLY_CORRECT_ext\"'\n} 2>/dev/null\n\nfunction ble/base/workaround-POSIXLY_CORRECT {\n  # This function will be overwritten by ble-decode\n  true\n}\nfunction ble/base/restore-POSIXLY_CORRECT {\n  if [[ ! $_ble_bash_POSIXLY_CORRECT_adjusted ]]; then return 0; fi # Note: set -e の為 || は駄目\n  _ble_bash_POSIXLY_CORRECT_adjusted=\n  if [[ $_ble_bash_POSIXLY_CORRECT_set ]]; then\n    POSIXLY_CORRECT=$_ble_bash_POSIXLY_CORRECT\n  else\n    builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_unset\"\n  fi\n}\n## @fn ble/base/is-POSIXLY_CORRECT\n##   Check if the POSIX mode is enabled in the user context.  This function is\n##   assumed to be called in the adjusted state.\nfunction ble/base/is-POSIXLY_CORRECT {\n  [[ $_ble_bash_POSIXLY_CORRECT_adjusted && $_ble_bash_POSIXLY_CORRECT_set ]]\n}\n\nfunction ble/variable#load-user-state/variable:FUNCNEST {\n  if [[ $_ble_bash_FUNCNEST_adjusted ]]; then\n    __ble_var_set=$_ble_bash_FUNCNEST_set\n    __ble_var_val=$_ble_bash_FUNCNEST\n    return 0\n  elif [[ ${_ble_local_FUNCNEST_set-} ]]; then\n    __ble_var_set=$_ble_local_FUNCNEST_set\n    __ble_var_set=$_ble_local_FUNCNEST\n    return 0\n  else\n    return 1\n  fi\n}\n\nfunction ble/variable#load-user-state/variable:POSIXLY_CORRECT {\n  if [[ $_ble_bash_POSIXLY_CORRECT_adjusted ]]; then\n    __ble_var_set=$_ble_bash_POSIXLY_CORRECT_set\n    __ble_var_val=$_ble_bash_POSIXLY_CORRECT\n    return 0\n  elif [[ ${_ble_local_POSIXLY_CORRECT_set-} ]]; then\n    __ble_var_set=$_ble_local_POSIXLY_CORRECT_set\n    __ble_var_set=$_ble_local_POSIXLY_CORRECT\n    return 0\n  else\n    return 1\n  fi\n}\n\n## @fn ble/base/list-shopt names...\n##   @var[out] shopt\nif ((_ble_bash>=40100)); then\n  function ble/base/list-shopt { shopt=$BASHOPTS; }\nelse\n  function ble/base/list-shopt {\n    shopt=\n    local name\n    for name; do\n      shopt -q \"$name\" 2>/dev/null && shopt=$shopt:$name\n    done\n  }\nfi 2>/dev/null # set -x 対策\nfunction ble/base/evaldef {\n  local shopt\n  ble/base/list-shopt extglob expand_aliases\n  shopt -s extglob\n  shopt -u expand_aliases\n  builtin eval -- \"$1\"; local ext=$?\n  [[ :$shopt: == *:extglob:* ]] || shopt -u extglob\n  [[ :$shopt: != *:expand_aliases:* ]] || shopt -s expand_aliases\n  return \"$ext\"\n}\n\n# will be overwritten by src/util.sh\nif ((_ble_bash>=50300)); then\n  function ble/util/assign { builtin eval -- \"$1=\\${ builtin eval -- \\\"\\$2\\\"; }\"; }\nelse\n  function ble/util/assign { builtin eval -- \"$1=\\$(builtin eval -- \\\"\\$2\\\")\"; }\nfi\n\n{\n  _ble_bash_builtins_adjusted=\n  _ble_bash_builtins_save=\n} 2>/dev/null # set -x 対策\nfunction ble/base/adjust-builtin-wrappers/.impl1 {\n  # Note: 何故か local POSIXLY_CORRECT の効果が\n  #   builtin unset -v POSIXLY_CORRECT しても残存するので関数に入れる。\n  # Note: set -o posix にしても read, type, builtin, local 等は上書き\n  #   された儘なので難しい。unset -f builtin さえすれば色々動く様になる\n  #   ので builtin は unset -f builtin してしまう。\n  unset -f builtin\n  builtin local builtins1 keywords1\n  builtins1=(builtin unset enable unalias return break continue declare local typeset eval exec set)\n  keywords1=(if then elif else case esac while until for select do done '{' '}' '[[' function)\n  if [[ ! $_ble_bash_builtins_adjusted ]]; then\n    _ble_bash_builtins_adjusted=1\n\n    builtin local defs\n    ble/util/assign defs '\n      \\builtin declare -f \"${builtins1[@]}\" || ((1))\n      \\builtin alias \"${builtins1[@]}\" \"${keywords1[@]}\" || ((1))' # set -e 対策\n    _ble_bash_builtins_save=$defs\n  fi\n  builtin local POSIXLY_CORRECT=y\n  builtin unset -f \"${builtins1[@]}\"\n  builtin unalias \"${builtins1[@]}\" \"${keywords1[@]}\" || ((1)) # set -e 対策\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_unset\"\n}\nfunction ble/base/adjust-builtin-wrappers/.impl2 {\n  # Workaround (bash-3.0..4.3) #D0722\n  #\n  #   builtin unset -v POSIXLY_CORRECT でないと unset -f : できないが、bash-3.0\n  #   -- 4.3 のバグで、local POSIXLY_CORRECT の時、builtin unset -v\n  #   POSIXLY_CORRECT しても POSIXLY_CORRECT が有効であると判断されるので、\n  #   \"unset -f :\" (非POSIX関数名) は別関数で実行する事にする。呼び出し元で既に\n  #   builtin unset -v POSIXLY_CORRECT されている事を前提とする。\n\n  # function :, alias : の保存\n  local defs\n  ble/util/assign defs 'LC_ALL= LC_MESSAGES=C builtin type :; alias :' || ((1)) # set -e 対策\n  defs=${defs#$': is a shell builtin\\n'}\n  _ble_bash_builtins_save=$_ble_bash_builtins_save$'\\n'$defs\n\n  builtin unset -f :\n  builtin unalias : || ((1)) # set -e 対策\n}\n## @fn ble/base/adjust-builtin-wrappers\n##\n##   Note: This function needs to be called after adjusting POSIXLY_CORRECT by\n##   calling « builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_adjust\" »\n##\n##   Note (#D2221) We have been delayed the execution of \"unset -f :\"\n##   (adjust-builtin-wrappers-2) until POSIXLY_CORRECT is unset.  However, .\n##   we can now call \"ble/base/adjust-builtin-wrappers/.impl2\" immediately\n##   after \"ble/base/adjust-builtin-wrappers/.impl1\" because we now unset\n##   POSIXLY_CORRECT earlier.  We combine those two functions again.\n##\nfunction ble/base/adjust-builtin-wrappers {\n  ble/base/adjust-builtin-wrappers/.impl1\n\n  # Note (#D2221): In Bash 3.0 and 3.1, when \"local POSIXLY_CORRECT\" is used in\n  # a function, the POSIX mode remains effective even after the function\n  # returns.  This can be fixed by calling \"unset -v POSIXLY_CORRECT\".\n  builtin unset -v POSIXLY_CORRECT\n\n  ble/base/adjust-builtin-wrappers/.impl2\n} 2>/dev/null\nfunction ble/base/restore-builtin-wrappers {\n  if [[ $_ble_bash_builtins_adjusted ]]; then\n    _ble_bash_builtins_adjusted=\n    ble/base/evaldef \"$_ble_bash_builtins_save\"\n    return 0\n  fi\n}\n{\n  ble/base/adjust-builtin-wrappers\n\n  # 対策 expand_aliases (暫定) 終了\n  if [[ $_ble_bash_expand_aliases ]]; then\n    shopt -s expand_aliases\n  fi\n} 2>/dev/null # set -x 対策\n\n# From src/util.sh\nfunction ble/variable#copy-state {\n  local src=$1 dst=$2\n  if [[ ${!src+set} ]]; then\n    builtin eval -- \"$dst=\\${$src}\"\n  else\n    builtin unset -v \"$dst[0]\" 2>/dev/null || builtin unset -v \"$dst\"\n  fi\n}\n\n# BASH_XTRACEFD は書き換えると勝手に元々設定されていた fd を閉じてしまうので、\n# 元々の fd を dup しておくなど特別な配慮が必要。\n{\n  _ble_bash_xtrace=()\n  _ble_bash_xtrace_debug_enabled=\n  _ble_bash_xtrace_debug_filename=\n  _ble_bash_xtrace_debug_fd=\n  _ble_bash_XTRACEFD=\n  _ble_bash_XTRACEFD_set=\n  _ble_bash_XTRACEFD_dup=\n  _ble_bash_PS4=\n} 2>/dev/null # set -x 対策\n# From src/util.sh (ble/fd#is-open and ble/fd#alloc/.nextfd)\nfunction ble/base/xtrace/.fdcheck { >&\"$1\"; } 2>/dev/null\nfunction ble/base/xtrace/.fdnext {\n  local _ble_local_init=${_ble_util_openat_nextfd:=${bleopt_openat_base:-30}}\n  for (($1=_ble_local_init;$1<_ble_local_init+1024;$1++)); do\n    ble/base/xtrace/.fdcheck \"${!1}\" || break\n  done\n  (($1<_ble_local_init+1024)) ||\n    { (($1=_ble_local_init,_ble_util_openat_nextfd++)); builtin eval \"exec ${!1}>&-\"; } ||\n    ((1))\n}\nfunction ble/base/xtrace/.log {\n  local open=---- close=----\n  if ((_ble_bash>=40200)); then\n    builtin printf '%s [%(%F %T %Z)T] %s %s\\n' \"$open\" -1 \"$1\" \"$close\"\n  else\n    local date\n    ble/util/assign date 'date 2>/dev/null'\n    builtin printf '%s [%s] %s %s\\n' \"$open\" \"$date\" \"$1\" \"$close\"\n  fi >&\"${BASH_XTRACEFD:-2}\"\n}\nfunction ble/base/xtrace/adjust {\n  local level=${#_ble_bash_xtrace[@]} IFS=$' \\t\\n'\n  if [[ $- == *x* ]]; then\n    _ble_bash_xtrace[level]=1\n  else\n    _ble_bash_xtrace[level]=\n  fi\n  set +x\n\n  ((_ble_bash>=40000&&level==0)) || return 0\n  _ble_bash_xtrace_debug_enabled=\n  if [[ ${bleopt_debug_xtrace:-/dev/null} == /dev/null ]]; then\n    if [[ $_ble_bash_xtrace_debug_fd ]]; then\n      builtin eval \"exec $_ble_bash_xtrace_debug_fd>&-\" || return 0 # disable=#D2164 (here bash4+)\n      _ble_bash_xtrace_debug_filename=\n      _ble_bash_xtrace_debug_fd=\n    fi\n  else\n    if [[ $_ble_bash_xtrace_debug_filename != \"$bleopt_debug_xtrace\" ]]; then\n      _ble_bash_xtrace_debug_filename=$bleopt_debug_xtrace\n      [[ $_ble_bash_xtrace_debug_fd ]] || ble/base/xtrace/.fdnext _ble_bash_xtrace_debug_fd\n      builtin eval \"exec $_ble_bash_xtrace_debug_fd>>\\\"$bleopt_debug_xtrace\\\"\" || return 0\n    fi\n\n    _ble_bash_XTRACEFD=${BASH_XTRACEFD-}\n    _ble_bash_XTRACEFD_set=${BASH_XTRACEFD+set}\n    if [[ ${BASH_XTRACEFD-} =~ ^[0-9]+$ ]] && ble/base/xtrace/.fdcheck \"$BASH_XTRACEFD\"; then\n      ble/base/xtrace/.fdnext _ble_bash_XTRACEFD_dup\n      builtin eval \"exec $_ble_bash_XTRACEFD_dup>&$BASH_XTRACEFD\" || return 0\n      builtin eval \"exec $BASH_XTRACEFD>&$_ble_bash_xtrace_debug_fd\" || return 0\n    else\n      _ble_bash_XTRACEFD_dup=\n      local newfd; ble/base/xtrace/.fdnext newfd\n      builtin eval \"exec $newfd>&$_ble_bash_xtrace_debug_fd\" || return 0\n      BASH_XTRACEFD=$newfd\n    fi\n\n    ble/variable#copy-state PS4 _ble_base_PS4\n    PS4=${bleopt_debug_xtrace_ps4:-'+ '}\n\n    _ble_bash_xtrace_debug_enabled=1\n    ble/base/xtrace/.log \"$FUNCNAME\"\n    set -x\n  fi\n}\nfunction ble/base/xtrace/restore {\n  local level=$((${#_ble_bash_xtrace[@]}-1)) IFS=$' \\t\\n'\n  ((level>=0)) || return 0\n  if [[ ${_ble_bash_xtrace[level]-} ]]; then\n    set -x\n  else\n    set +x\n  fi\n  builtin unset -v '_ble_bash_xtrace[level]'\n\n  ((_ble_bash>=40000&&level==0)) || return 0\n  if [[ $_ble_bash_xtrace_debug_enabled ]]; then\n    ble/base/xtrace/.log \"$FUNCNAME\"\n    _ble_bash_xtrace_debug_enabled=\n\n    # Note: ユーザーの BASH_XTRACEFD にごみが混入しない様にする為、\n    # BASH_XTRACEFD を書き換える前に先に PS4 を戻す。\n    ble/variable#copy-state _ble_base_PS4 PS4\n\n    if [[ $_ble_bash_XTRACEFD_dup ]]; then\n      # BASH_XTRACEFD の fd を元の出力先に繋ぎ直す\n      builtin eval \"exec $BASH_XTRACEFD>&$_ble_bash_XTRACEFD_dup\" &&\n        builtin eval \"exec $_ble_bash_XTRACEFD_dup>&-\" || ((1)) # disable=#D2164 (here bash4+)\n    else\n      # BASH_XTRACEFD の fd は新しく割り当てた fd なので値上書きで閉じて良い\n      if [[ $_ble_bash_XTRACEFD_set ]]; then\n        BASH_XTRACEFD=$_ble_bash_XTRACEFD\n      else\n        builtin unset -v BASH_XTRACEFD\n      fi\n    fi\n  fi\n}\n\n## @fn ble/base/.adjust-bash-options vset vshopt\n##   @var[out] $vset\n##   @var[out] $vshopt\nfunction ble/base/.adjust-bash-options {\n  builtin eval -- \"$1=\\$-\"\n  set +evukT -B\n  ble/base/xtrace/adjust\n\n  [[ $2 == shopt ]] || local shopt\n  # Note: nocasematch は bash-3.1 以上\n  ble/base/list-shopt extdebug nocasematch\n  [[ $2 == shopt ]] || builtin eval -- \"$2=\\$shopt\"\n  shopt -u extdebug\n  shopt -u nocasematch 2>/dev/null\n  return 0\n} 2>/dev/null # set -x 対策\n## @fn ble/base/.restore-bash-options var_set var_shopt\n##   @param[out] var_set var_shopt\nfunction ble/base/.restore-bash-options {\n  local set=${!1} shopt=${!2}\n  [[ :$shopt: == *:nocasematch:* ]] && shopt -s nocasematch\n  [[ :$shopt: == *:extdebug:* ]] && shopt -s extdebug\n  ble/base/xtrace/restore\n  [[ $set == *B* ]] || set +B\n  [[ $set == *T* ]] && set -T\n  [[ $set == *k* ]] && set -k\n  [[ $set == *u* ]] && set -u\n  [[ $set == *v* ]] && set -v\n  [[ $set == *e* ]] && set -e # set -e は最後\n  return 0\n} 2>/dev/null # set -x 対策\n\n{\n  : \"${_ble_bash_options_adjusted=}\"\n  _ble_bash_set=$-\n  _ble_bash_shopt=${BASHOPTS-}\n} 2>/dev/null # set -x 対策\nfunction ble/base/adjust-bash-options {\n  [[ $_ble_bash_options_adjusted ]] && return 1 || ((1)) # set -e 対策\n  _ble_bash_options_adjusted=1\n\n  ble/base/.adjust-bash-options _ble_bash_set _ble_bash_shopt\n\n  # Note: expand_aliases はユーザー設定を復元する為に記録する\n  _ble_bash_expand_aliases=\n  shopt -q expand_aliases 2>/dev/null &&\n    _ble_bash_expand_aliases=1\n\n  # locale 待避\n  # Note #D1854: ble/widget/display-shell-version で此処で待避した変数を参照す\n  #   る事に注意する。此処に新しい変数を追加する時は display-shell-version の方\n  #   にも処理スキップを追加する必要がある。\n  ble/variable#copy-state LC_ALL _ble_bash_LC_ALL\n  if [[ ${LC_ALL-} ]]; then\n    ble/variable#copy-state LC_CTYPE    _ble_bash_LC_CTYPE\n    ble/variable#copy-state LC_MESSAGES _ble_bash_LC_MESSAGES\n    ble/variable#copy-state LC_NUMERIC  _ble_bash_LC_NUMERIC\n    ble/variable#copy-state LC_TIME     _ble_bash_LC_TIME\n    ble/variable#copy-state LANG        _ble_bash_LANG\n    [[ ${LC_CTYPE-}    ]] && LC_CTYPE=$LC_ALL\n    [[ ${LC_MESSAGES-} ]] && LC_MESSAGES=$LC_ALL\n    [[ ${LC_NUMERIC-}  ]] && LC_NUMERIC=$LC_ALL\n    [[ ${LC_TIME-}     ]] && LC_TIME=$LC_ALL\n    LANG=$LC_ALL\n    LC_ALL=\n  fi\n  ble/variable#copy-state LC_COLLATE _ble_bash_LC_COLLATE\n  LC_COLLATE=C\n\n  # TMOUT 確認 #D1630 WA readonly TMOUT\n  if local TMOUT= 2>/dev/null; then # #D1630 WA\n    _ble_bash_tmout_wa=()\n  else\n    _ble_bash_tmout_wa=(-t 2147483647)\n  fi\n} 2>/dev/null # set -x 対策 #D0930 / locale 変更\nfunction ble/base/restore-bash-options {\n  [[ $_ble_bash_options_adjusted ]] || return 1\n  _ble_bash_options_adjusted=\n\n  # locale 復元\n  ble/variable#copy-state _ble_bash_LC_COLLATE LC_COLLATE\n  if [[ $_ble_bash_LC_ALL ]]; then\n    ble/variable#copy-state _ble_bash_LC_CTYPE    LC_CTYPE\n    ble/variable#copy-state _ble_bash_LC_MESSAGES LC_MESSAGES\n    ble/variable#copy-state _ble_bash_LC_NUMERIC  LC_NUMERIC\n    ble/variable#copy-state _ble_bash_LC_TIME     LC_TIME\n    ble/variable#copy-state _ble_bash_LANG        LANG\n  fi\n  ble/variable#copy-state _ble_bash_LC_ALL LC_ALL\n\n  [[ $_ble_bash_nocasematch ]] && shopt -s nocasematch\n\n  ble/base/.restore-bash-options _ble_bash_set _ble_bash_shopt\n} 2>/dev/null # set -x 対策 #D0930 / locale 変更\nfunction ble/base/recover-bash-options {\n  # bind -x が終わる度に設定が復元されてしまうので毎回設定し直す #D1526 #D1574\n  if [[ $_ble_bash_expand_aliases ]]; then\n    shopt -s expand_aliases\n  else\n    shopt -u expand_aliases\n  fi\n}\n\nfunction ble/variable#load-user-state/variable:LC_ALL/.impl {\n  local __ble_save=_ble_bash_$1\n  __ble_var_set=${!__ble_save+set}\n  __ble_var_val=${!__ble_save-}\n  [[ $__ble_var_set ]] && ble/variable#get-attr -v __ble_var_att \"$1\"\n  return 0\n}\nfunction ble/variable#load-user-state/variable:LC_COLLATE {\n  ble/variable#load-user-state/variable:LC_ALL/.impl LC_COLLATE\n}\nfunction ble/variable#load-user-state/variable:LC_ALL {\n  ble/variable#load-user-state/variable:LC_ALL/.impl LC_ALL\n}\nfunction ble/variable#load-user-state/variable:LC_CTYPE {\n  [[ $_ble_bash_LC_ALL ]] && ble/variable#load-user-state/variable:LC_ALL/.impl LC_CTYPE\n}\nfunction ble/variable#load-user-state/variable:LC_MESSAGES {\n  [[ $_ble_bash_LC_ALL ]] && ble/variable#load-user-state/variable:LC_ALL/.impl LC_MESSAGES\n}\nfunction ble/variable#load-user-state/variable:LC_NUMERIC {\n  [[ $_ble_bash_LC_ALL ]] && ble/variable#load-user-state/variable:LC_ALL/.impl LC_NUMERIC\n}\nfunction ble/variable#load-user-state/variable:LC_TIME {\n  [[ $_ble_bash_LC_ALL ]] && ble/variable#load-user-state/variable:LC_ALL/.impl LC_TIME\n}\nfunction ble/variable#load-user-state/variable:LANG {\n  [[ $_ble_bash_LC_ALL ]] && ble/variable#load-user-state/variable:LC_ALL/.impl LANG\n}\n\n{ ble/base/adjust-bash-options; } &>/dev/null # set -x 対策 #D0930\n\nfunction ble/init/force-load-inputrc {\n  builtin unset -f \"$FUNCNAME\"\n\n  builtin bind &>/dev/null # force to load .inputrc\n\n  # WA #D1534 workaround for msys2 .inputrc\n  if [[ $OSTYPE == msys* ]]; then\n    local bind_emacs\n    ble/util/assign bind_emacs 'builtin bind -m emacs -p 2>/dev/null'\n    [[ $'\\n'$bind_emacs$'\\n' == *$'\\n\"\\\\C-?\": backward-kill-line\\n' ]] &&\n      builtin bind -m emacs '\"\\C-?\": backward-delete-char' 2>/dev/null\n  fi\n}\nble/init/force-load-inputrc\n\nif [[ ! -o emacs && ! -o vi && ! $_ble_init_command ]]; then\n  builtin echo \"ble.sh: ble.sh is not intended to be used with the line-editing mode disabled (--noediting).\" >&2\n  ble/base/restore-bash-options\n  ble/base/restore-builtin-wrappers\n  ble/base/restore-POSIXLY_CORRECT\n  builtin eval -- \"$_ble_bash_FUNCNEST_restore\"\n  builtin unset -v _ble_bash\n  return 1 2>/dev/null || builtin exit 1\nfi\n\nif shopt -q restricted_shell; then\n  builtin echo \"ble.sh: ble.sh is not intended to be used in restricted shells (--restricted).\" >&2\n  ble/base/restore-bash-options\n  ble/base/restore-builtin-wrappers\n  ble/base/restore-POSIXLY_CORRECT\n  builtin eval -- \"$_ble_bash_FUNCNEST_restore\"\n  builtin unset -v _ble_bash\n  return 1 2>/dev/null || builtin exit 1\nfi\n\n#--------------------------------------\n# save IFS / BASH_REMATCH\n\nfunction ble/init/adjust-IFS {\n  _ble_init_original_IFS_set=${IFS+set}\n  _ble_init_original_IFS=$IFS\n  IFS=$' \\t\\n'\n}\nfunction ble/init/restore-IFS {\n  if [[ $_ble_init_original_IFS_set ]]; then\n    IFS=$_ble_init_original_IFS\n  else\n    builtin unset -v IFS\n  fi\n  builtin unset -v _ble_init_original_IFS_set\n  builtin unset -v _ble_init_original_IFS\n}\n\nfunction ble/variable#load-user-state/variable:IFS {\n  __ble_var_set=${_ble_init_original_IFS_set-}\n  __ble_var_val=${_ble_init_original_IFS-}\n  ble/variable#get-attr -v __ble_var_att IFS\n  return 0\n}\n\nif ((_ble_bash>=50100)); then\n  _ble_bash_BASH_REMATCH_level=0\n  _ble_bash_BASH_REMATCH=()\n  function ble/base/adjust-BASH_REMATCH {\n    ((_ble_bash_BASH_REMATCH_level++==0)) || return 0\n    _ble_bash_BASH_REMATCH=(\"${BASH_REMATCH[@]}\")\n  }\n  function ble/base/restore-BASH_REMATCH {\n    ((_ble_bash_BASH_REMATCH_level>0&&\n        --_ble_bash_BASH_REMATCH_level==0)) || return 0\n    BASH_REMATCH=(\"${_ble_bash_BASH_REMATCH[@]}\")\n  }\n\nelse\n  _ble_bash_BASH_REMATCH_level=0\n  _ble_bash_BASH_REMATCH=()\n  _ble_bash_BASH_REMATCH_rex=none\n\n  ## @fn ble/base/adjust-BASH_REMATCH/increase delta\n  ##   @param[in] delta\n  ##   @var[in,out] i rex\n  function ble/base/adjust-BASH_REMATCH/increase {\n    local delta=$1\n    ((delta)) || return 1\n    ((i+=delta))\n    if ((delta==1)); then\n      rex=$rex.\n    else\n      rex=$rex.{$delta}\n    fi\n  }\n  function ble/base/adjust-BASH_REMATCH/is-updated {\n    local i n=${#_ble_bash_BASH_REMATCH[@]}\n    ((n!=${#BASH_REMATCH[@]})) && return 0\n    for ((i=0;i<n;i++)); do\n      [[ ${_ble_bash_BASH_REMATCH[i]} != \"${BASH_REMATCH[i]}\" ]] && return 0\n    done\n    return 1\n  }\n  # This is a simplified version of ble/string#index-of text sub\n  function ble/base/adjust-BASH_REMATCH/.find-substr {\n    local t=${1#*\"$2\"}\n    ((ret=${#1}-${#t}-${#2},ret<0&&(ret=-1),ret>=0))\n  }\n  function ble/base/adjust-BASH_REMATCH {\n    ((_ble_bash_BASH_REMATCH_level++==0)) || return 0\n    ble/base/adjust-BASH_REMATCH/is-updated || return 1\n\n    local size=${#BASH_REMATCH[@]}\n    if ((size==0)); then\n      _ble_bash_BASH_REMATCH=()\n      _ble_bash_BASH_REMATCH_rex=none\n      return 0\n    fi\n\n    local rex= i=0\n    local text=$BASH_REMATCH sub ret isub\n\n    local -a rparens=()\n    local isub rex i=0 count=0\n    for ((isub=1;isub<size;isub++)); do\n      local sub=${BASH_REMATCH[isub]}\n\n      # 既存の子一致の孫一致になるか確認\n      while ((count>=1)); do\n        local end=${rparens[count-1]}\n        if ble/base/adjust-BASH_REMATCH/.find-substr \"${text:i:end-i}\" \"$sub\"; then\n          ble/base/adjust-BASH_REMATCH/increase \"$ret\"\n          ((rparens[count++]=i+${#sub}))\n          rex=$rex'('\n          break\n        else\n          ble/base/adjust-BASH_REMATCH/increase \"$((end-i))\"\n          rex=$rex')'\n          builtin unset -v 'rparens[--count]'\n        fi\n      done\n\n      ((count>0)) && continue\n\n      # 新しい子一致\n      if ble/base/adjust-BASH_REMATCH/.find-substr \"${text:i}\" \"$sub\"; then\n        ble/base/adjust-BASH_REMATCH/increase \"$ret\"\n        ((rparens[count++]=i+${#sub}))\n        rex=$rex'('\n      else\n        break # 復元失敗\n      fi\n    done\n\n    while ((count>=1)); do\n      local end=${rparens[count-1]}\n      ble/base/adjust-BASH_REMATCH/increase \"$((end-i))\"\n      rex=$rex')'\n      builtin unset -v 'rparens[--count]'\n    done\n\n    ble/base/adjust-BASH_REMATCH/increase \"$((${#text}-i))\"\n\n    _ble_bash_BASH_REMATCH=(\"${BASH_REMATCH[@]}\")\n    _ble_bash_BASH_REMATCH_rex=$rex\n  }\n  function ble/base/restore-BASH_REMATCH {\n    ((_ble_bash_BASH_REMATCH_level>0&&\n        --_ble_bash_BASH_REMATCH_level==0)) || return 0\n    [[ ${_ble_bash_BASH_REMATCH-} =~ $_ble_bash_BASH_REMATCH_rex ]]\n  }\nfi\n\nfunction ble/variable#load-user-state/variable:BASH_REMATCH {\n  if ((_ble_bash_BASH_REMATCH_level)); then\n    __ble_var_set=${BASH_REMATCH+set}\n    __ble_var_val=(\"${_ble_bash_BASH_REMATCH[@]}\")\n    ble/variable#get-attr -v __ble_var_att BASH_REMATCH\n    return 0\n  else\n    return 1\n  fi\n}\n\nble/init/adjust-IFS\nble/base/adjust-BASH_REMATCH\n\n## @fn ble/init/clean-up [opts]\nfunction ble/init/clean-up {\n  local ext=$? opts=$1 # preserve exit status\n\n  # 一時グローバル変数消去\n  builtin unset -v _ble_init_version\n  builtin unset -v _ble_init_exit\n  builtin unset -v _ble_init_command\n  builtin unset -v _ble_init_attached\n\n  # 状態復元\n  ble/base/restore-BASH_REMATCH\n  ble/init/restore-IFS\n  if [[ :$opts: != *:check-attach:* || ! $_ble_attached ]]; then\n    ble/base/restore-bash-options\n    ble/base/restore-POSIXLY_CORRECT\n    ble/base/restore-builtin-wrappers\n    builtin eval -- \"$_ble_bash_FUNCNEST_restore\"\n  fi\n  return \"$ext\"\n}\n\n#------------------------------------------------------------------------------\n# read arguments\n\nfunction ble/util/put { builtin printf '%s' \"$1\"; }\nfunction ble/util/print { builtin printf '%s\\n' \"$1\"; }\nfunction ble/util/print-lines { builtin printf '%s\\n' \"$@\"; }\n\n_ble_base_arguments_opts=\n_ble_base_arguments_attach=\n_ble_base_arguments_rcfile=\n## @fn ble/base/read-blesh-arguments args\n##   @var[out] _ble_base_arguments_opts\n##   @var[out] _ble_base_arguments_attach\n##   @var[out] _ble_base_arguments_rcfile\nfunction ble/base/read-blesh-arguments {\n  local opts=\n  local opt_attach=prompt\n  local opt_inputrc=auto\n\n  builtin unset -v _ble_init_command # 再解析\n  while (($#)); do\n    local arg=$1; shift\n    case $arg in\n    (--noattach|noattach)\n      opt_attach=none ;;\n    (--attach=*) opt_attach=${arg#*=} ;;\n    (--attach)\n      if (($#)); then\n        opt_attach=$1; shift\n      else\n        opt_attach=attach\n        opts=$opts:E\n        ble/util/print \"ble.sh ($arg): an option argument is missing.\" >&2\n      fi ;;\n\n    (--noinputrc)\n      opt_inputrc=none ;;\n    (--inputrc=*) opt_inputrc=${arg#*=} ;;\n    (--inputrc)\n      if (($#)); then\n        opt_inputrc=$1; shift\n      else\n        opt_inputrc=inputrc\n        opts=$opts:E\n        ble/util/print \"ble.sh ($arg): an option argument is missing.\" >&2\n      fi ;;\n\n    (--rcfile=*|--init-file=*|--rcfile|--init-file)\n      if [[ $arg != *=* ]]; then\n        local rcfile=$1; shift\n      else\n        local rcfile=${arg#*=}\n      fi\n\n      _ble_base_arguments_rcfile=${rcfile:-/dev/null}\n      if [[ ! $rcfile || ! -e $rcfile ]]; then\n        ble/util/print \"ble.sh ($arg): '$rcfile' does not exist.\" >&2\n        opts=$opts:E\n      elif [[ ! -r $rcfile ]]; then\n        ble/util/print \"ble.sh ($arg): '$rcfile' is not readable.\" >&2\n        opts=$opts:E\n      fi ;;\n    (--norc)\n      _ble_base_arguments_rcfile=/dev/null ;;\n    (--keep-rlvars)\n      opts=$opts:keep-rlvars ;;\n    (--bash-debug-version=*|--bash-debug-version)\n      local value=\n      if [[ $arg == *=* ]]; then\n        value=${arg#*=}\n      elif (($#)); then\n        value=$1; shift\n      else\n        opts=$opts:E\n        ble/util/print \"ble.sh ($arg): an option argument is missing.\" >&2\n        continue\n      fi\n      case $value in\n      (full|short|once|ignore)\n        opts=$opts:bash-debug-version=$value ;;\n      (*)\n        opts=$opts:E\n        ble/util/print \"ble.sh ($arg): unrecognized value '$value'.\" >&2\n      esac ;;\n    (--debug-bash-output)\n      bleopt_internal_suppress_bash_output= ;;\n    (--test | --update | --clear-cache | --lib | --install)\n      if [[ $_ble_init_command ]]; then\n        ble/util/print \"ble.sh ($arg): the option '--$_ble_init_command' has already been specified.\" >&2\n        opts=$opts:E\n      else\n        _ble_init_command=${arg#--}\n      fi ;;\n    (--*)\n      ble/util/print \"ble.sh: unrecognized long option '$arg'\" >&2\n      opts=$opts:E ;;\n    (-?*)\n      local i c\n      for ((i=1;i<${#arg};i++)); do\n        c=${arg:i:1}\n        case -$c in\n        (-o)\n          if ((i+1<${#arg})); then\n            local oarg=${arg:i+1}\n            i=${#arg}\n          elif (($#)); then\n            local oarg=$1; shift\n          else\n            opts=$opts:E\n            i=${#arg}\n            continue\n          fi\n          local rex='^[_a-zA-Z][_a-zA-Z0-9]*='\n          if [[ $oarg =~ $rex ]]; then\n            builtin eval -- \"bleopt_${oarg%%=*}=\\${oarg#*=}\"\n          else\n            ble/util/print \"ble.sh: unrecognized option '-o $oarg'\" >&2\n            opts=$opts:E\n          fi ;;\n        (-*)\n          ble/util/print \"ble.sh: unrecognized option '-$c'\" >&2\n          opts=$opts:E ;;\n        esac\n      done\n      ;;\n    (*)\n      if [[ ${_ble_init_command-} ]]; then\n        _ble_init_command[${#_ble_init_command[@]}]=$arg\n      else\n        ble/util/print \"ble.sh: unrecognized argument '$arg'\" >&2\n        opts=$opts:E\n      fi ;;\n    esac\n  done\n\n  _ble_base_arguments_opts=$opts\n  _ble_base_arguments_attach=$opt_attach\n  _ble_base_arguments_inputrc=$opt_inputrc\n  [[ :$opts: != *:E:* ]]\n}\nif ! ble/base/read-blesh-arguments \"$@\"; then\n  builtin echo \"ble.sh: cancel initialization.\" >&2\n  ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n  builtin unset -v _ble_bash\n  return 2 2>/dev/null || builtin exit 2\nfi\n\nif [[ ${_ble_base-} ]]; then\n  [[ $_ble_init_command ]] && _ble_init_attached=$_ble_attached\n  if ! _ble_bash=$_ble_bash ble/base/unload-for-reload; then\n    builtin echo \"ble.sh: an old version of ble.sh seems to be already loaded.\" >&2\n    ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n    return 1 2>/dev/null || builtin exit 1\n  fi\nfi\n\n#------------------------------------------------------------------------------\n# Initialize version information\n\n_ble_bash_loaded_in_function=0\nlocal _ble_local_test 2>/dev/null && _ble_bash_loaded_in_function=1\n\n_ble_version=0\nBLE_VERSION=$_ble_init_version\nfunction ble/base/initialize-version-variables {\n  local version=$BLE_VERSION\n\n  local hash=\n  if [[ $version == *+* ]]; then\n    hash=${version#*+}\n    version=${version%%+*}\n  fi\n\n  local status=release\n  if [[ $version == *-* ]]; then\n    status=${version#*-}\n    version=${version%%-*}\n  fi\n\n  local major=${version%%.*}; version=${version#*.}\n  local minor=${version%%.*}; version=${version#*.}\n  local patch=${version%%.*}\n  ((_ble_version=major*10000+minor*100+patch))\n  BLE_VERSINFO=(\"$major\" \"$minor\" \"$patch\" \"$hash\" \"$status\" noarch)\n  BLE_VER=$_ble_version\n}\nfunction ble/base/clear-version-variables {\n  builtin unset -v _ble_bash _ble_version BLE_VERSION BLE_VERSINFO BLE_VER\n}\nble/base/initialize-version-variables\n\n#------------------------------------------------------------------------------\n# workarounds for builtin read\n\nfunction ble/bash/read {\n  local TMOUT= 2>/dev/null # #D1630 WA readonly TMOUT\n  builtin read \"${_ble_bash_tmout_wa[@]}\" -r \"$@\"\n}\nfunction ble/bash/read-timeout { builtin read -t \"$@\"; }\n\n# WA for bash-5.2 nested read by WINCH causes corrupted \"running_trap\" (#D1982)\n_ble_bash_read_winch=\nif ((50200<=_ble_bash&&_ble_bash<50300)); then\n  function ble/bash/read/.process-winch {\n    if [[ $_ble_bash_read_winch != - ]]; then\n      local _ble_local_handler=$_ble_bash_read_winch\n      local _ble_bash_read_winch=\n      builtin eval -- \"$_ble_local_handler\"\n    fi\n  }\n  function ble/bash/read {\n    local TMOUT= 2>/dev/null # #D1630 WA readonly TMOUT\n    local _ble_bash_read_winch=-\n    builtin read \"${_ble_bash_tmout_wa[@]}\" -r \"$@\"; local _ble_local_ext=$?\n    ble/bash/read/.process-winch\n    return \"$_ble_local_ext\"\n  }\n  function ble/bash/read-timeout {\n    local _ble_bash_read_winch=-\n    builtin read -t \"$@\"; local _ble_local_ext=$?\n    ble/bash/read/.process-winch\n    return \"$_ble_local_ext\"\n  }\nfi\n\n#------------------------------------------------------------------------------\n# check environment\n\n# ble/bin\n\nif ((_ble_bash>=40000)); then\n  function ble/bin#has { builtin type -t -- \"$@\" &>/dev/null; }\nelse\n  function ble/bin#has {\n    local cmd\n    for cmd; do builtin type -t -- \"$cmd\" || return 1; done &>/dev/null\n    return 0\n  }\nfi\n\n## @fn ble/bin#get-path command\n##   @var[out] path\nfunction ble/bin#get-path {\n  local cmd=$1\n  ble/util/assign path 'builtin type -P -- \"$cmd\" 2>/dev/null' && [[ $path ]]\n}\n\n## @fn ble/bin/.default-utility-path commands...\n##   取り敢えず ble/bin/* からコマンドを呼び出せる様にします。\nfunction ble/bin/.default-utility-path {\n  local cmd\n  for cmd; do\n    builtin eval \"function ble/bin/$cmd { command $cmd \\\"\\$@\\\"; }\"\n  done\n}\n## @fn ble/bin#freeze-utility-path [-n] commands...\n##   PATH が破壊された後でも ble が動作を続けられる様に、\n##   現在の PATH で基本コマンドのパスを固定して ble/bin/* から使える様にする。\n##\n##   実装に ble/util/assign を使用しているので ble-core 初期化後に実行する必要がある。\n##\nfunction ble/bin#freeze-utility-path {\n  local cmd path q=\\' Q=\"'\\''\" fail= flags=\n  for cmd; do\n    if [[ $cmd == -n ]]; then\n      flags=n$flags\n      continue\n    fi\n    [[ $flags == *n* ]] && ble/bin#has ble/bin/\"$cmd\" && continue\n    ble/bin#has ble/bin/.frozen:\"$cmd\" && continue\n    if ble/bin#get-path \"$cmd\"; then\n      [[ $path == ./* || $path == ../* ]] && path=$PWD/$path\n      builtin eval \"function ble/bin/$cmd { '${path//$q/$Q}' \\\"\\$@\\\"; }\"\n    else\n      fail=1\n    fi\n  done\n  ((!fail))\n}\n\n# POSIX utilities\n\n_ble_init_posix_command_list=(sed date rm mkdir mkfifo sleep stty tty sort awk chmod grep cat wc mv sh od cp ps)\nfunction ble/init/check-environment {\n  if ! ble/bin#has \"${_ble_init_posix_command_list[@]}\"; then\n    local cmd commandMissing=\n    for cmd in \"${_ble_init_posix_command_list[@]}\"; do\n      if ! type \"$cmd\" &>/dev/null; then\n        commandMissing=\"$commandMissing\\`$cmd', \"\n      fi\n    done\n    ble/util/print \"ble.sh: insane environment: The command(s), ${commandMissing}not found. Check your environment variable PATH.\" >&2\n\n    # try to fix PATH\n    local default_path\n    ble/util/assign default_path 'command -p getconf PATH 2>/dev/null'\n    [[ $default_path ]] || return 1\n\n    local original_path=$PATH\n    export PATH=${default_path}${PATH:+:}${PATH}\n    [[ :$PATH: == *:/bin:* ]] || PATH=/bin${PATH:+:}$PATH\n    [[ :$PATH: == *:/usr/bin:* ]] || PATH=/usr/bin${PATH:+:}$PATH\n    if ! ble/bin#has \"${_ble_init_posix_command_list[@]}\"; then\n      PATH=$original_path\n      return 1\n    fi\n    ble/util/print \"ble.sh: modified PATH=${PATH::${#PATH}-${#original_path}}\\$PATH\" >&2\n  fi\n\n  if [[ ! ${USER-} ]]; then\n    ble/util/print \"ble.sh: insane environment: \\$USER is empty.\" >&2\n    if ble/util/assign USER 'id -un 2>/dev/null' && [[ $USER ]]; then\n      export USER\n      ble/util/print \"ble.sh: modified USER=$USER\" >&2\n    fi\n  fi\n  _ble_base_env_USER=$USER\n\n  if [[ ! ${HOSTNAME-} ]]; then\n    ble/util/print \"ble.sh: suspicious environment: \\$HOSTNAME is empty.\"\n    if ble/util/assign HOSTNAME 'uname -n 2>/dev/null' && [[ $HOSTNAME ]]; then\n      export HOSTNAME\n      ble/util/print \"ble.sh: fixed HOSTNAME=$HOSTNAME\" >&2\n    fi\n  fi\n  _ble_base_env_HOSTNAME=$HOSTNAME\n\n  if [[ ! ${HOME-} ]]; then\n    ble/util/print \"ble.sh: insane environment: \\$HOME is empty.\" >&2\n    local home\n    if ble/util/assign home 'getent passwd 2>/dev/null | awk -F : -v UID=\"$UID\" '\\''$3 == UID {print $6}'\\''' && [[ $home && -d $home ]] ||\n        { [[ $USER && -d /home/$USER && -O /home/$USER ]] && home=/home/$USER; } ||\n        { [[ $USER && -d /Users/$USER && -O /Users/$USER ]] && home=/Users/$USER; } ||\n        { [[ $home && ! ( -e $home && -h $home ) ]] && ble/bin/mkdir -p \"$home\" 2>/dev/null; }\n    then\n      export HOME=$home\n      ble/util/print \"ble.sh: modified HOME=$HOME\" >&2\n    fi\n  fi\n\n  if [[ ! ${LANG-} ]]; then\n    ble/util/print \"ble.sh: suspicious environment: \\$LANG is empty.\" >&2\n  fi\n\n  # Check locale and work around `convert-meta on' in bash >= 5.2\n  if ((_ble_bash>=50200)); then\n    # Note #D2069: In bash >= 5.2, when the specified locale does not exist,\n    # the readline setting `convert-meta' is automatically turned on when\n    # Readline is first initialized.  This interferes with ble.sh's trick to\n    # distinguish isolated ESCs from meta ESCs, i.e., the combination \"ESC [\"\n    # is converted to \"<C0> <9B> [\" by ble.sh's macro, <C0> is converted to\n    # \"ESC @\" by `convert-meta', and \"ESC @\" is again converted to \"<C0> <9B>\n    # @\".  This forms an infinite loop.  ble.sh tries to adjust `convert-meta',\n    # but Readline's adjustment takes place at a random timing which is not\n    # controllable.  To work around this, we need to forcibly initialize\n    # Readline before ble.sh adjusts `convert-meta'.\n\n    local error\n    # Note: We check if the current locale setting produces an error message.\n    # We try the workaround only when the locale appears to be broken because\n    # the workaround may have a side effect of consuming user's input.\n    ble/util/assign error '{ LC_ALL= LC_CTYPE=C ble/util/put; } 2>&1'\n    if [[ $error ]]; then\n      ble/util/print \"$error\" >&2\n      ble/util/print \"ble.sh: please check the locale settings (LANG and LC_*).\" >&2\n\n      # Note: Somehow, the workaround of using \"read -et\" only works after\n      # running `LC_ALL= LC_CTYPE=C cmd'.  In bash < 5.3, ble/util/assign at\n      # this point is executed under a subshell, so we need to run `LC_ALL=\n      # LC_CTYPE=C ble/util/put' again in the main shell\n      ((_ble_bash>=50300)) || { LC_ALL= LC_CTYPE=C ble/util/put; } 2>/dev/null\n\n      # We here forcibly initialize locales of Readline to make Readline's\n      # adjustment of convert-meta take place here.\n      local dummy\n      builtin read -et 0.000001 dummy </dev/tty\n    fi\n  fi\n\n  # 暫定的な ble/bin/$cmd 設定\n  ble/bin/.default-utility-path \"${_ble_init_posix_command_list[@]}\"\n\n  return 0\n}\nif ! ble/init/check-environment; then\n  ble/util/print \"ble.sh: failed to adjust the environment. canceling the load of ble.sh.\" >&2\n  ble/base/clear-version-variables\n  ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n  return 1\nfi\n\n# Note: src/util.sh で ble/util/assign を定義した後に呼び出される。\n_ble_bin_awk_type=\nfunction ble/bin/awk/.instantiate {\n  local path q=\\' Q=\"'\\''\" ext=1\n\n  if ble/bin#get-path nawk; then\n    [[ $path == ./* || $path == ../* ]] && path=$PWD/$path\n    # Note: Some distribution (like Ubuntu) provides gawk as \"nawk\" by\n    # default. To avoid wrongly picking up gawk as nawk, we need to check the\n    # version output from the command.  2024-12-10 In KaKi87's server [1],\n    # Debian 12 provided mawk as \"nawk\".\n    # [1] https://github.com/akinomyoga/ble.sh/issues/535#issuecomment-2528258996\n    local version\n    ble/util/assign version '\"$path\" -W version' 2>/dev/null </dev/null\n    if [[ $version != *'GNU Awk'* && $version != *mawk* ]]; then\n      builtin eval \"function ble/bin/nawk { '${path//$q/$Q}' -v AWKTYPE=nawk \\\"\\$@\\\"; }\"\n      if [[ ! $_ble_bin_awk_type ]]; then\n        _ble_bin_awk_type=nawk\n        builtin eval \"function ble/bin/awk { '${path//$q/$Q}' -v AWKTYPE=nawk \\\"\\$@\\\"; }\" && ext=0\n      fi\n    fi\n  fi\n\n  if ble/bin#get-path mawk; then\n    [[ $path == ./* || $path == ../* ]] && path=$PWD/$path\n    builtin eval \"function ble/bin/mawk { '${path//$q/$Q}' -v AWKTYPE=mawk \\\"\\$@\\\"; }\"\n    if [[ ! $_ble_bin_awk_type ]]; then\n      _ble_bin_awk_type=mawk\n      builtin eval \"function ble/bin/awk { '${path//$q/$Q}' -v AWKTYPE=mawk \\\"\\$@\\\"; }\" && ext=0\n    fi\n  fi\n\n  if ble/bin#get-path gawk; then\n    [[ $path == ./* || $path == ../* ]] && path=$PWD/$path\n    builtin eval \"function ble/bin/gawk { '${path//$q/$Q}' -v AWKTYPE=gawk \\\"\\$@\\\"; }\"\n    if [[ ! $_ble_bin_awk_type ]]; then\n      _ble_bin_awk_type=gawk\n      builtin eval \"function ble/bin/awk { '${path//$q/$Q}' -v AWKTYPE=gawk \\\"\\$@\\\"; }\" && ext=0\n    fi\n  fi\n\n  if [[ ! $_ble_bin_awk_type ]]; then\n    if [[ $OSTYPE == solaris* ]] && type /usr/xpg4/bin/awk >/dev/null; then\n      # Solaris の既定の awk は全然駄目なので /usr/xpg4 以下の awk を使う。\n      _ble_bin_awk_type=xpg4\n      function ble/bin/awk { /usr/xpg4/bin/awk -v AWKTYPE=xpg4 \"$@\"; } && ext=0\n    elif ble/bin#get-path awk; then\n      [[ $path == ./* || $path == ../* ]] && path=$PWD/$path\n      local version\n      ble/util/assign version '\"$path\" -W version' 2>/dev/null </dev/null && [[ $version ]] ||\n        ble/util/assign version '\"$path\" --version' 2>/dev/null </dev/null\n      if [[ $version == *'GNU Awk'* ]]; then\n        _ble_bin_awk_type=gawk\n      elif [[ $version == *mawk* ]]; then\n        _ble_bin_awk_type=mawk\n      elif [[ $version == 'awk version '[12][0-9][0-9][0-9][01][0-9][0-3][0-9] ]]; then\n        _ble_bin_awk_type=nawk\n      else\n        _ble_bin_awk_type=unknown\n      fi\n      builtin eval \"function ble/bin/awk { '${path//$q/$Q}' -v AWKTYPE=$_ble_bin_awk_type \\\"\\$@\\\"; }\" && ext=0\n      if [[ $OSTYPE == darwin* && $path == /usr/bin/awk && $_ble_bin_awk_type == nawk ]]; then\n        # Note #D1974: macOS の awk-32 の multibyte character support が怪しい。\n        #   問題は GitHub Actions の上では再現できていないが特別の入力で失敗す\n        #   るのかもしれない。または、報告者の環境が壊れているだけの可能性もあ\n        #   る。テスト不可能だが、そもそも nawk は UTF-8 に対応していない前提な\n        #   ので、取り敢えず LC_CTYPE=C で実行する。\n        function ble/bin/awk {\n          local -x LC_ALL= LC_CTYPE=C LC_COLLATE=C 2>/dev/null\n          /usr/bin/awk -v AWKTYPE=nawk \"$@\"; local ext=$?\n          ble/util/unlocal LC_ALL LC_CTYPE LC_COLLATE 2>/dev/null\n          return \"$ext\"\n        }\n      elif [[ $_ble_bin_awk_type == [gmn]awk ]] && ! ble/is-function ble/bin/\"$_ble_bin_awk_type\" ; then\n        builtin eval \"function ble/bin/$_ble_bin_awk_type { '${path//$q/$Q}' -v AWKTYPE=$_ble_bin_awk_type \\\"\\$@\\\"; }\"\n      fi\n    fi\n  fi\n  return \"$ext\"\n}\n\n# Note: ble//bin/awk/.instantiate が実行される前に使おうとした時の為の暫定実装\nfunction ble/bin/awk {\n  if ble/bin/awk/.instantiate; then\n    ble/bin/awk \"$@\"\n  else\n    awk \"$@\"\n  fi\n}\n\n# Do not overwrite by ble/bin#freeze-utility-path\nfunction ble/bin/.frozen:awk { return 0; }\nfunction ble/bin/.frozen:nawk { return 0; }\nfunction ble/bin/.frozen:mawk { return 0; }\nfunction ble/bin/.frozen:gawk { return 0; }\n\nif [[ $OSTYPE == darwin* ]]; then\n  function ble/bin/sed/.instantiate {\n    local path=\n    ble/bin#get-path sed || return 1\n\n    if [[ $path == /usr/bin/sed ]]; then\n      # macOS sed seems to have the same issue as macOS awk.  In macOS, we\n      # always run \"sed\" in the C locale.\n      function ble/bin/sed {\n        local -x LC_ALL= LC_CTYPE=C LC_COLLATE=C 2>/dev/null\n        /usr/bin/sed \"$@\"; local ext=$?\n        ble/util/unlocal LC_ALL LC_CTYPE LC_COLLATE 2>/dev/null\n        return \"$ext\"\n      }\n    else\n      [[ $path == ./* || $path == ../* ]] && path=$PWD/$path\n      local q=\\' Q=\"'\\''\"\n      builtin eval \"function ble/bin/sed { '${path//$q/$Q}' \\\"\\$@\\\"; }\"\n    fi\n    return 0\n  }\n  function ble/bin/sed {\n    if ble/bin/sed/.instantiate; then\n      ble/bin/sed \"$@\"\n    else\n      command sed \"$@\"\n    fi\n  }\n  function ble/bin/.frozen:sed { return 0; }\nelse\n  function ble/bin/sed/.instantiate { return 0; }\nfi\n\n## @fn ble/bin/awk0\n##   awk implementation that supports NUL record separator\n## @fn ble/bin/awk0.available\n##   initialize ble/bin/awk0 and returns whether ble/bin/awk0 is available\nfunction ble/bin/awk0.available/test {\n  local count=0 cmd_awk=$1 awk_script='BEGIN { RS = \"\\0\"; } { count++; } END { print count; }'\n  ble/util/assign count 'printf \"a\\0b\\0\" | \"$cmd_awk\" \"$awk_script\"'\n  ((count==2))\n}\nfunction ble/bin/awk0.available {\n  local awk\n  for awk in mawk gawk; do\n    if ble/bin#freeze-utility-path -n \"$awk\" &&\n        ble/bin/awk0.available/test ble/bin/\"$awk\" &&\n        builtin eval -- \"function ble/bin/awk0 { ble/bin/$awk -v AWKTYPE=$awk \\\"\\$@\\\"; }\"; then\n      function ble/bin/awk0.available { return 0; }\n      return 0\n    fi\n  done\n\n  if ble/bin/awk0.available/test ble/bin/awk &&\n      function ble/bin/awk0 { ble/bin/awk \"$@\"; }; then\n    function ble/bin/awk0.available { return 0; }\n    return 0\n  fi\n\n  function ble/bin/awk0.available { return 1; }\n  return 1\n}\n\nfunction ble/base/is-msys1 {\n  local cr; cr=$'\\r'\n  [[ $OSTYPE == msys && ! $cr ]]\n}\n\nfunction ble/base/is-wsl {\n  local kernel_version\n  if [[ -d /usr/lib/wsl/lib && -r /proc/version ]] &&\n       ble/bash/read kernel_version < /proc/version &&\n       [[ $kernel_version == *-microsoft-* ]]\n  then\n    function ble/base/is-wsl { return 0; }\n    return 0\n  else\n    function ble/base/is-wsl { return 1; }\n    return 1\n  fi\n}\n\nfunction ble/util/mkd {\n  local dir\n  for dir; do\n    [[ -d $dir ]] && continue\n    [[ -e $dir || -L $dir ]] && ble/bin/rm -f \"$dir\"\n    ble/bin/mkdir -p \"$dir\"\n  done\n}\n\n#------------------------------------------------------------------------------\n# readlink -f (Originally taken from akinomyoga/mshex.git)\n\n## @fn ble/util/readlink path\n##   @var[out] ret\n\nif ((_ble_bash>=40000)); then\n  _ble_util_readlink_visited_init='local -A visited=()'\n  function ble/util/readlink/.visited {\n    [[ ${visited[$1]+set} ]] && return 0\n    visited[$1]=1\n    return 1\n  }\nelse\n  _ble_util_readlink_visited_init=\"local -a visited=()\"\n  function ble/util/readlink/.visited {\n    local key\n    for key in \"${visited[@]}\"; do\n      [[ $1 == \"$key\" ]] && return 0\n    done\n    visited=(\"$1\" \"${visited[@]}\")\n    return 1\n  }\nfi\n\n## @fn ble/util/readlink/.readlink path\n##   @var[out] link\nfunction ble/util/readlink/.readlink {\n  local path=$1\n  if ble/bin#has ble/bin/readlink; then\n    ble/util/assign link 'ble/bin/readlink -- \"$path\"'\n    [[ $link ]]\n  elif ble/bin#has ble/bin/ls; then\n    ble/util/assign link 'ble/bin/ls -ld -- \"$path\"' &&\n      [[ $link == *\" $path -> \"?* ]] &&\n      link=${link#*\" $path -> \"}\n  else\n    false\n  fi\n} 2>/dev/null\n## @fn  ble/util/readlink/.resolve-physical-directory\n##   @var[in,out] path\nfunction ble/util/readlink/.resolve-physical-directory {\n  [[ $path == */?* ]] || return 0\n  local PWD=$PWD OLDPWD=$OLDPWD CDPATH=\n  if builtin cd -L .; then\n    local pwd=$PWD\n    builtin cd -P \"${path%/*}/\" &&\n      path=${PWD%/}/${path##*/}\n\n    # Note #D1849: 現在ディレクトリが他者により改名されている場合や PWD がユー\n    #   ザーに書き換えられている場合にも元のディレクトリに戻る為、cd -L . した\n    #   後のパスに cd する。但し pwd の結果はこの関数の呼び出し前と変わってしま\n    #   う (が実際にはこの方が良いだろう)。PWD は local にして元の値に戻すので\n    #   変わらない。\n    builtin cd \"$pwd\"\n  fi\n  return 0\n}\nfunction ble/util/readlink/.resolve-loop {\n  local path=$ret\n  while [[ $path == ?*/ ]]; do path=${path%/}; done\n  builtin eval -- \"$_ble_util_readlink_visited_init\"\n  while [[ -h $path ]]; do\n    local link\n    ble/util/readlink/.visited \"$path\" && break\n    ble/util/readlink/.readlink \"$path\" || break\n    if [[ $link == /* || $path != */* ]]; then\n      path=$link\n    else\n      # 相対パス ../ は物理ディレクトリ構造に従って遡る。\n      ble/util/readlink/.resolve-physical-directory\n      path=${path%/*}/$link\n    fi\n    while [[ $path == ?*/ ]]; do path=${path%/}; done\n  done\n  ret=$path\n}\nfunction ble/util/readlink/.resolve {\n  # 初回呼び出し時に実装を選択\n  _ble_util_readlink_type=\n\n  # より効率的な実装が可能な場合は ble/util/readlink/.resolve を独自定義。\n  case $OSTYPE in\n  (cygwin | msys | linux-gnu)\n    # これらのシステムの標準 readlink では readlink -f が使える。\n    #\n    # Note: 例えば NixOS では標準の readlink を使おうとすると問題が起こるらしい\n    #   ので、見えている readlink を使う。見えている readlink が非標準の時は -f\n    #   が使えるか分からないので readlink -f による実装は有効化しない。\n    #\n    local readlink\n    ble/util/assign readlink 'type -P readlink'\n    case $readlink in\n    (/bin/readlink | /usr/bin/readlink)\n      _ble_util_readlink_type=readlink-f\n      builtin eval \"function ble/util/readlink/.resolve { ble/util/assign ret '$readlink -f -- \\\"\\$ret\\\"'; }\" ;;\n    esac ;;\n  esac\n\n  if [[ ! $_ble_util_readlink_type ]]; then\n    _ble_util_readlink_type=loop\n    ble/bin#freeze-utility-path readlink ls\n    function ble/util/readlink/.resolve { ble/util/readlink/.resolve-loop; }\n  fi\n\n  ble/util/readlink/.resolve\n}\nfunction ble/util/readlink {\n  ret=$1\n  if [[ -h $ret ]]; then ble/util/readlink/.resolve; fi\n}\n\n#---------------------------------------\n\n_ble_bash_path=\nfunction ble/bin/.load-builtin {\n  local name=$1 path=$2\n  if [[ ! $_ble_bash_path ]]; then\n    local ret; ble/util/readlink \"$BASH\"\n    _ble_bash_path=$ret\n  fi\n\n  if [[ ! $path ]]; then\n    local bash_prefix=${ret%/*/*}\n    path=$bash_prefix/lib/bash/$name\n    [[ -s $path ]] || return 1\n  fi\n\n  if (enable -f \"$path\" \"$name\") &>/dev/null; then\n    enable -f \"$path\" \"$name\"\n    builtin eval -- \"function ble/bin/$name { builtin $name \\\"\\$@\\\"; }\"\n    return 0\n  else\n    return 1\n  fi\n}\n# ble/bin/.load-builtin mkdir\n# ble/bin/.load-builtin mkfifo\n# ble/bin/.load-builtin rm\n\n#------------------------------------------------------------------------------\n\nfunction ble/base/.create-user-directory {\n  local var=$1 dir=$2\n  if [[ ! -d $dir ]]; then\n    # dangling symlinks are silently removed\n    [[ ! -e $dir && -h $dir ]] && ble/bin/rm -f \"$dir\"\n    if [[ -e $dir || -h $dir ]]; then\n      ble/util/print \"ble.sh: cannot create a directory '$dir' since there is already a file.\" >&2\n      return 1\n    fi\n    if ! (umask 077; ble/bin/mkdir -p \"$dir\" && [[ -O $dir ]]); then\n      ble/util/print \"ble.sh: failed to create a directory '$dir'.\" >&2\n      return 1\n    fi\n  elif ! [[ -r $dir && -w $dir && -x $dir ]]; then\n    ble/util/print \"ble.sh: permission of '$dir' is not correct.\" >&2\n    return 1\n  elif [[ ! -O $dir ]]; then\n    ble/util/print \"ble.sh: owner of '$dir' is not correct.\" >&2\n    return 1\n  fi\n  builtin eval \"$var=\\$dir\"\n}\n\n##\n## @var _ble_base\n## @var _ble_base_blesh\n## @var _ble_base_blesh_raw\n##\n##   ble.sh のインストール先ディレクトリ。\n##   読み込んだ ble.sh の実体があるディレクトリとして解決される。\n##\nfunction ble/base/initialize-base-directory {\n  local src=$1\n  local defaultDir=${2-}\n\n  # resolve symlink\n  _ble_base_blesh_raw=$src\n  if [[ -h $src ]]; then\n    local ret; ble/util/readlink \"$src\"; src=$ret\n  fi\n  _ble_base_blesh=$src\n\n  if [[ -s $src && $src != */* ]]; then\n    _ble_base=$PWD\n  elif [[ $src == */* ]]; then\n    local dir=${src%/*}\n    if [[ ! $dir ]]; then\n      _ble_base=/\n    elif [[ $dir != /* ]]; then\n      _ble_base=$PWD/$dir\n    else\n      _ble_base=$dir\n    fi\n  else\n    _ble_base=${defaultDir:-$HOME/.local/share/blesh}\n  fi\n\n  [[ -d $_ble_base ]]\n}\nif ! ble/base/initialize-base-directory \"${BASH_SOURCE[0]}\"; then\n  ble/util/print \"ble.sh: ble base directory not found!\" >&2\n  ble/base/clear-version-variables\n  ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n  return 1\nfi\n\n##\n## @var _ble_base_run\n##\n##   実行時の一時ファイルを格納するディレクトリ。以下の手順で決定する。\n##\n##   1. ${XDG_RUNTIME_DIR:=/run/user/$UID} が存在すればその下に blesh を作成して使う。\n##   2. /tmp/blesh/$UID を作成可能ならば、それを使う。\n##   3. $_ble_base/tmp/$UID を使う。\n##\nfunction ble/base/initialize-runtime-directory/.xdg {\n  local runtime_dir=\n  if [[ $XDG_RUNTIME_DIR ]]; then\n    if [[ ! -d $XDG_RUNTIME_DIR ]]; then\n      ble/util/print \"ble.sh: XDG_RUNTIME_DIR='$XDG_RUNTIME_DIR' is not a directory.\" >&2\n      return 1\n    elif [[ -O $XDG_RUNTIME_DIR ]]; then\n      runtime_dir=$XDG_RUNTIME_DIR\n    else\n      # When XDG_RUNTIME_DIR is not owned by the current user, maybe \"su\" is\n      # used to enter this session keeping the environment variables of the\n      # original user.  We just ignore XDG_RUNTIME_DIR (without issueing\n      # warnings) for such a case.\n      false\n    fi\n  fi\n  if [[ ! $runtime_dir ]]; then\n    runtime_dir=/run/user/$UID\n    [[ -d $runtime_dir && -O $runtime_dir ]] || return 1\n  fi\n\n  # Note: Some versions of WSL around 2023-09 seem to have an issue with the\n  # permission of /run/user/*, so we avoid to use them in WSL.\n  [[ $runtime_dir == /run/user/* ]] && ble/base/is-wsl && return 1\n\n  if ! [[ -r $runtime_dir && -w $runtime_dir && -x $runtime_dir ]]; then\n    [[ $runtime_dir == \"$XDG_RUNTIME_DIR\" ]] &&\n      ble/util/print \"ble.sh: XDG_RUNTIME_DIR='$XDG_RUNTIME_DIR' doesn't have a proper permission.\" >&2\n    return 1\n  fi\n\n  ble/base/.create-user-directory _ble_base_run \"$runtime_dir/blesh\"\n}\nfunction ble/base/initialize-runtime-directory/.tmp {\n  [[ -r /tmp && -w /tmp && -x /tmp ]] || return 1\n\n  # Note: WSL seems to clear /tmp after the first instance of Bash starts,\n  # which causes a problem of missing /tmp after blesh's initialization.\n  # https://github.com/microsoft/WSL/issues/8441#issuecomment-1139434972\n  # https://github.com/akinomyoga/ble.sh/discussions/462\n  ble/base/is-wsl && return 1\n\n  local tmp_dir=/tmp/blesh\n  if [[ ! -d $tmp_dir ]]; then\n    [[ ! -e $tmp_dir && -h $tmp_dir ]] && ble/bin/rm -f \"$tmp_dir\"\n    if [[ -e $tmp_dir || -h $tmp_dir ]]; then\n      ble/util/print \"ble.sh: cannot create a directory '$tmp_dir' since there is already a file.\" >&2\n      return 1\n    fi\n    ble/bin/mkdir -p \"$tmp_dir\" || return 1\n    ble/bin/chmod a+rwxt \"$tmp_dir\" || return 1\n  elif ! [[ -r $tmp_dir && -w $tmp_dir && -x $tmp_dir ]]; then\n    ble/util/print \"ble.sh: permission of '$tmp_dir' is not correct.\" >&2\n    return 1\n  fi\n\n  ble/base/.create-user-directory _ble_base_run \"$tmp_dir/$UID\"\n}\nfunction ble/base/initialize-runtime-directory/.base {\n  local tmp_dir=$_ble_base/run\n  if [[ ! -d $tmp_dir ]]; then\n    ble/bin/mkdir -p \"$tmp_dir\" || return 1\n    ble/bin/chmod a+rwxt \"$tmp_dir\" || return 1\n  fi\n  ble/base/.create-user-directory _ble_base_run \"$tmp_dir/${USER:-$UID}@$HOSTNAME\"\n}\nfunction ble/base/initialize-runtime-directory/.home {\n  local cache_dir=${XDG_CACHE_HOME:-$HOME/.cache}\n  if [[ ! -d $cache_dir ]]; then\n    if [[ $XDG_CACHE_HOME ]]; then\n      ble/util/print \"ble.sh: XDG_CACHE_HOME='$XDG_CACHE_HOME' is not a directory.\" >&2\n      return 1\n    else\n      ble/bin/mkdir -p \"$cache_dir\" || return 1\n    fi\n  fi\n  if ! [[ -r $cache_dir && -w $cache_dir && -x $cache_dir ]]; then\n    if [[ $XDG_CACHE_HOME ]]; then\n      ble/util/print \"ble.sh: XDG_CACHE_HOME='$XDG_CACHE_HOME' doesn't have a proper permission.\" >&2\n    else\n      ble/util/print \"ble.sh: '$cache_dir' doesn't have a proper permission.\" >&2\n    fi\n    return 1\n  fi\n  ble/base/.create-user-directory _ble_base_run \"$cache_dir/blesh/run\"\n}\nfunction ble/base/initialize-runtime-directory {\n  ble/base/initialize-runtime-directory/.xdg && return 0\n  ble/base/initialize-runtime-directory/.tmp && return 0\n  ble/base/initialize-runtime-directory/.base && return 0\n  ble/base/initialize-runtime-directory/.home\n}\nif ! ble/base/initialize-runtime-directory; then\n  ble/util/print \"ble.sh: failed to initialize \\$_ble_base_run.\" >&2\n  ble/base/clear-version-variables\n  ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n  return 1\nfi\n\n# ロード時刻の記録 (ble-update で使う為)\n>| \"$_ble_base_run/$$.load\"\n\n## @fn ble/base/clean-up-runtime-directory [opts]\n##   既に存在しないプロセスに属する実行時ファイルを削除します。*.pid のファイル\n##   名を持つ実行時ファイルはについては、子バックグラウンドプロセスのプロセスID\n##   を含むと見做し、ファイルの内容を読み取ってそれが整数であればその整数に対し\n##   て kill を実行します。\n##\n##   @param[in,opt] opts\n##     finalize ... 自プロセス $$ に関連するファイルも削除します。現セッション\n##       における ble.sh の終了処理時に呼び出される事を想定しています。\n##\nfunction ble/base/clean-up-runtime-directory {\n  local opts=$1 failglob= noglob=\n  if [[ $- == *f* ]]; then\n    noglob=1\n    set +f\n  fi\n  if shopt -q failglob &>/dev/null; then\n    failglob=1\n    shopt -u failglob\n  fi\n\n  local -a alive=() removed=() bgpids=()\n  [[ :$opts: == *:finalize:* ]] && alive[$$]=0\n\n  local file pid iremoved=0 ibgpid=0\n  for file in \"$_ble_base_run\"/[1-9]*.*; do\n    [[ -e $file || -h $file ]] || continue\n\n    # extract pid (skip if it is not a number)\n    pid=${file##*/}; pid=${pid%%.*}\n    [[ $pid && ! ${pid//[0-9]} ]] || continue\n\n    if [[ ! ${alive[pid]+set} ]]; then\n      builtin kill -0 \"$pid\" &>/dev/null\n      ((alive[pid]=$?==0))\n    fi\n    ((alive[pid])) && continue\n\n    # kill process specified by the pid file\n    if [[ $file == *.pid && -s $file ]]; then\n      local run_pid IFS=\n      ble/bash/read run_pid < \"$file\"\n      if ble/string#match \"$run_pid\" '^-?[0-9]+$' && kill -0 \"$run_pid\" &>/dev/null; then\n        if ((pid==$$)); then\n          # 現セッションの背景プロセスの場合は遅延させる\n          bgpids[ibgpid++]=$run_pid\n        else\n          builtin kill -- \"$run_pid\" &>/dev/null\n          ble/util/msleep 50\n          builtin kill -0 \"$run_pid\" &>/dev/null &&\n            (ble/util/nohup \"ble/util/conditional-sync '' '((1))' 100 progressive-weight:pid=$run_pid:no-wait-pid:timeout=3000:SIGKILL\")\n        fi\n      fi\n    fi\n\n    removed[iremoved++]=$file\n  done\n  ((iremoved)) && ble/bin/rm -rf \"${removed[@]}\" 2>/dev/null\n  ((ibgpid)) && (ble/util/nohup 'ble/bin/sleep 3; builtin kill -- \"${bgpids[@]}\" &>/dev/null')\n\n  [[ $failglob ]] && shopt -s failglob\n  [[ $noglob ]] && set -f\n  return 0\n}\n\n##\n## @var _ble_base_cache\n##\n##   環境毎の初期化ファイルを格納するディレクトリ。以下の手順で決定する。\n##\n##   1. ${XDG_CACHE_HOME:=$HOME/.cache} が存在すればその下に blesh を作成して使う。\n##   2. $_ble_base/cache.d/$UID を使う。\n##\nfunction ble/base/initialize-cache-directory/.xdg {\n  [[ $_ble_base != */out ]] || return 1\n\n  local cache_dir=${XDG_CACHE_HOME:-$HOME/.cache}\n  if [[ ! -d $cache_dir ]]; then\n    [[ $XDG_CACHE_HOME ]] &&\n      ble/util/print \"ble.sh: XDG_CACHE_HOME='$XDG_CACHE_HOME' is not a directory.\" >&2\n    return 1\n  fi\n  if ! [[ -r $cache_dir && -w $cache_dir && -x $cache_dir ]]; then\n    [[ $XDG_CACHE_HOME ]] &&\n      ble/util/print \"ble.sh: XDG_CACHE_HOME='$XDG_CACHE_HOME' doesn't have a proper permission.\" >&2\n    return 1\n  fi\n\n  local ver=${BLE_VERSINFO[0]}.${BLE_VERSINFO[1]}\n  ble/base/.create-user-directory _ble_base_cache \"$cache_dir/blesh/$ver\"\n}\nfunction ble/base/initialize-cache-directory {\n  ble/base/initialize-cache-directory/.xdg && return 0\n\n  # fallback\n  local cache_dir=$_ble_base/cache.d\n  if [[ ! -d $cache_dir ]]; then\n    ble/bin/mkdir -p \"$cache_dir\" || return 1\n    ble/bin/chmod a+rwxt \"$cache_dir\" || return 1\n\n    # relocate an old cache directory if any\n    local old_cache_dir=$_ble_base/cache\n    if [[ -d $old_cache_dir && ! -h $old_cache_dir ]]; then\n      mv \"$old_cache_dir\" \"$cache_dir/$UID\"\n      ln -s \"$cache_dir/$UID\" \"$old_cache_dir\"\n    fi\n  fi\n  ble/base/.create-user-directory _ble_base_cache \"$cache_dir/$UID\"\n}\nfunction ble/base/migrate-cache-directory/.move {\n  local old=$1 new=$2\n  [[ -e $old ]] || return 0\n  if [[ -e $new || -L $old ]]; then\n    ble/bin/rm -rf \"$old\"\n  else\n    ble/bin/mv \"$old\" \"$new\"\n  fi\n}\nfunction ble/base/migrate-cache-directory/.check-old-prefix {\n  local old_prefix=$_ble_base_cache/$1\n  local new_prefix=$_ble_base_cache/$2\n  local file\n  for file in \"$old_prefix\"*; do\n    local old=$file\n    local new=$new_prefix${file#\"$old_prefix\"}\n    ble/base/migrate-cache-directory/.move \"$old\" \"$new\"\n  done\n}\nfunction ble/base/migrate-cache-directory {\n  local failglob=\n  shopt -q failglob && { failglob=1; shopt -u failglob; }\n\n  ble/base/migrate-cache-directory/.check-old-prefix cmap+default.binder-source decode.cmap.allseq\n  ble/base/migrate-cache-directory/.check-old-prefix cmap+default decode.cmap\n  ble/base/migrate-cache-directory/.check-old-prefix ble-decode-bind decode.bind\n\n  local file\n  for file in \"$_ble_base_cache\"/*.term; do\n    local old=$file\n    local new=$_ble_base_cache/term.${file#\"$_ble_base_cache/\"}; new=${new%.term}\n    ble/base/migrate-cache-directory/.move \"$old\" \"$new\"\n  done\n\n  ble/base/migrate-cache-directory/.move \"$_ble_base_cache/man\" \"$_ble_base_cache/complete.mandb\"\n\n  [[ $failglob ]] && shopt -s failglob\n}\nif ! ble/base/initialize-cache-directory; then\n  ble/util/print \"ble.sh: failed to initialize \\$_ble_base_cache.\" >&2\n  ble/base/clear-version-variables\n  ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n  return 1\nfi\nble/base/migrate-cache-directory\n\n##\n## @var _ble_base_state\n##\n##   環境毎の初期化ファイルを格納するディレクトリ。以下の手順で決定する。\n##\n##   1. ${XDG_STATE_HOME:=$HOME/.state} (存在しなくても強制的に作成) の下に blesh を作成して使う。\n##   2. (1. に失敗した時) $_ble_base/state.d/$UID を使う。\n##\nfunction ble/base/initialize-state-directory/.xdg {\n  local state_dir=${XDG_STATE_HOME:-$HOME/.local/state}\n  if [[ -e $state_dir || -L $state_dir ]]; then\n    if [[ ! -d $state_dir ]]; then\n      if [[ $XDG_STATE_HOME ]]; then\n        ble/util/print \"ble.sh: XDG_STATE_HOME='$XDG_STATE_HOME' is not a directory.\" >&2\n      else\n        ble/util/print \"ble.sh: '$state_dir' is not a directory.\" >&2\n      fi\n      return 1\n    fi\n    if ! [[ -r $state_dir && -w $state_dir && -x $state_dir ]]; then\n      if [[ $XDG_STATE_HOME ]]; then\n        ble/util/print \"ble.sh: XDG_STATE_HOME='$XDG_STATE_HOME' doesn't have a proper permission.\" >&2\n      else\n        ble/util/print \"ble.sh: '$state_dir' doesn't have a proper permission.\" >&2\n      fi\n      return 1\n    fi\n  fi\n\n  ble/base/.create-user-directory _ble_base_state \"$state_dir/blesh\"\n}\nfunction ble/base/initialize-state-directory {\n  ble/base/initialize-state-directory/.xdg && return 0\n\n  # fallback\n  local state_dir=$_ble_base/state.d\n  if [[ ! -d $state_dir ]]; then\n    ble/bin/mkdir -p \"$state_dir\" || return 1\n    ble/bin/chmod a+rwxt \"$state_dir\" || return 1\n\n    # relocate an old state directory if any\n    local old_state_dir=$_ble_base/state\n    if [[ -d $old_state_dir && ! -h $old_state_dir ]]; then\n      mv \"$old_state_dir\" \"$state_dir/$UID\"\n      ln -s \"$state_dir/$UID\" \"$old_state_dir\"\n    fi\n  fi\n  ble/util/print \"ble.sh: using the non-standard position of the state directory: '$state_dir/$UID'\" >&2\n  ble/base/.create-user-directory _ble_base_state \"$state_dir/$UID\"\n}\nif ! ble/base/initialize-state-directory; then\n  ble/util/print \"ble.sh: failed to initialize \\$_ble_base_state.\" >&2\n  ble/base/clear-version-variables\n  ble/init/clean-up 2>/dev/null # set -x 対策 #D0930\n  return 1\nfi\n\n\nfunction ble/base/print-usage-for-no-argument-command {\n  local name=${FUNCNAME[1]} desc=$1; shift\n  ble/util/print-lines \\\n    \"usage: $name\" \\\n    \"$desc\" >&2\n  [[ $1 != --help ]] && return 2\n  return 0\n}\nfunction ble-reload {\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_adjust\"\n  local -a _ble_local_options=()\n\n  [[ ! -e $_ble_base_rcfile ]] ||\n    ble/array#push _ble_local_options --rcfile=\"${_ble_base_rcfile:-/dev/null}\"\n  [[ $_ble_base_arguments_inputrc == auto ]] ||\n    ble/array#push _ble_local_options --inputrc=\"$_ble_base_arguments_inputrc\"\n\n  local name\n  for name in keep-rlvars; do\n    if [[ :$_ble_base_arguments_opts: == *:\"$name\":* ]]; then\n      ble/array#push _ble_local_options \"--$name\"\n    fi\n  done\n  ble/util/unlocal name\n\n  ble/array#push _ble_local_options '--bash-debug-version=ignore'\n\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_leave\"\n  source \"$_ble_base/ble.sh\" \"${_ble_local_options[@]}\"\n}\n\n#%[quoted_repository   = \"'\" + getenv(\"PWD\"               ).replace(\"'\", \"'\\\\''\") + \"'\"]\n#%[quoted_branch       = \"'\" + getenv(\"BLE_GIT_BRANCH\"    ).replace(\"'\", \"'\\\\''\") + \"'\"]\n#%[quoted_git_version  = \"'\" + getenv(\"BUILD_GIT_VERSION\" ).replace(\"'\", \"'\\\\''\") + \"'\"]\n#%[quoted_make_version = \"'\" + getenv(\"BUILD_MAKE_VERSION\").replace(\"'\", \"'\\\\''\") + \"'\"]\n#%[quoted_gawk_version = \"'\" + getenv(\"BUILD_GAWK_VERSION\").replace(\"'\", \"'\\\\''\") + \"'\"]\n#%expand\n_ble_base_repository=$\"quoted_repository\"\n_ble_base_branch=$\"quoted_branch\"\n_ble_base_repository_url=https://github.com/akinomyoga/ble.sh\n_ble_base_build_git_version=$\"quoted_git_version\"\n_ble_base_build_make_version=$\"quoted_make_version\"\n_ble_base_build_gawk_version=$\"quoted_gawk_version\"\n#%end.i\nfunction ble-update/.check-install-directory-ownership {\n  if [[ ! -O $_ble_base ]]; then\n    ble/util/print 'ble-update: install directory is owned by another user:' >&2\n    ls -ld \"$_ble_base\"\n    return 1\n  elif [[ ! -r $_ble_base || ! -w $_ble_base || ! -x $_ble_base ]]; then\n    ble/util/print 'ble-update: install directory permission denied:' >&2\n    ls -ld \"$_ble_base\"\n    return 1\n  fi\n}\nfunction ble-update/.make {\n  local sudo=\n  if [[ $1 == --sudo ]]; then\n    sudo=1\n    shift\n  fi\n\n  if ! \"$make\" -q \"$@\"; then\n    if [[ $sudo ]]; then\n      sudo \"$make\" \"$@\"\n    else\n      \"$make\" \"$@\"\n    fi\n  else\n    # インストール先に更新がなくても現在の session でロードされている ble.sh が\n    # 古いかもしれないのでチェックしてリロードする。\n    return 6\n  fi\n}\nfunction ble-update/.reload {\n  local ext=$1\n  if [[ $ext -eq 0 || $ext -eq 6 && $_ble_base/ble.sh -nt $_ble_base_run/$$.load ]]; then\n    if [[ ! -e $_ble_base/ble.sh ]]; then\n      ble/util/print \"ble-update: new ble.sh not found at '$_ble_base/ble.sh'.\" >&2\n      return 1\n    elif [[ ! -s $_ble_base/ble.sh ]]; then\n      ble/util/print \"ble-update: new ble.sh '$_ble_base/ble.sh' is empty.\" >&2\n      return 1\n    elif [[ $- == *i* && $_ble_attached ]] && ! ble/util/is-running-in-subshell; then\n      builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_leave\"\n      ble-reload\n      ext=$?\n      builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_enter\"\n      return \"$ext\"\n    fi\n    return 0\n  fi\n  ((ext==6)) && ext=0\n  return \"$ext\"\n}\nfunction ble-update/.download-nightly-build {\n  if ! ble/bin#has tar xz; then\n    local command\n    for command in tar xz; do\n      ble/bin#has \"$command\" ||\n        ble/util/print \"ble-update (nightly): '$command' command is not available.\" >&2\n    done\n    return 1\n  fi\n\n  if ((EUID!=0)) && ! ble-update/.check-install-directory-ownership; then\n    # _ble_base が自分の物でない時は sudo でやり直す\n    sudo \"$BASH\" \"$_ble_base/ble.sh\" --update &&\n      ble-update/.reload 6\n    return \"$?\"\n  fi\n\n  local tarname=ble-nightly.tar.xz\n  local url_tar=$_ble_base_repository_url/releases/download/nightly/$tarname\n  (\n    ble/util/joblist/__suppress__\n    set +f\n    shopt -u failglob nullglob\n\n    # mkcd \"$_ble_base/src\"\n    if ! ble/bin/mkdir -p \"$_ble_base/src\"; then\n      ble/util/print \"ble-update (nightly): failed to create the directory '$_ble_base/src'\" >&2\n      return 1\n    fi\n    if ! builtin cd \"$_ble_base/src\"; then\n      ble/util/print \"ble-update (nightly): failed to enter the directory '$_ble_base/src'\" >&2\n      return 1\n    fi\n\n    local ret\n    ble/file#hash \"$tarname\"; local ohash=$ret\n\n    # download \"$url_tar\" \"$tarname\"\n    # Note: アップロードした直後は暫く 404 Not Found になるようなので何回か再試\n    # 行する。\n    local retry max_retry=5\n    for ((retry=0;retry<=max_retry;retry++)); do\n      if ((retry>0)); then\n        local wait=$((retry<3?retry*10:30))\n        ble/util/print \"ble-update (nightly): retry downloading in $wait seconds... ($retry/$max_retry)\" >&2\n        ble/util/sleep \"$wait\"\n      fi\n\n      if ble/bin#has wget; then\n        wget -N \"$url_tar\" && break\n      elif ble/bin#has curl; then\n        curl -LRo \"$tarname\" -z \"$tarname\" \"$url_tar\" && break\n      else\n        ble/util/print \"ble-update (nightly): command 'wget' nor 'curl' is available.\" >&2\n        return 1\n      fi\n    done\n    if ((retry>max_retry)); then\n      ble/util/print \"ble-update (nightly): failed to download the archive from '$url_tar'.\" >&2\n      return 7\n    fi\n\n    # 前回ダウンロードした物と同じ場合は省略\n    ble/file#hash \"$tarname\"; local nhash=$ret\n    [[ $ohash == \"$nhash\" ]] && return 6\n\n    # tar xJf \"$tarname\"\n    ble/bin/rm -rf ble-nightly*/\n    if ! tar xJf \"$tarname\"; then\n      ble/util/print 'ble-update (nightly): failed to extract the tarball. Removing possibly broken tarball.' >&2\n      ble/bin/rm -rf \"$tarname\"\n      return 1\n    fi\n\n    # cp -T ble-nightly* \"$_ble_base\"\n    local extracted_dir=ble-nightly\n    if [[ ! -d $extracted_dir ]]; then\n      ble/util/print \"ble-update (nightly): the directory 'ble-nightly' not found in the tarball '$PWD/$tarname'.\" >&2\n      return 1\n    fi\n    ble/bin/cp -Rf \"$extracted_dir\"/* \"$_ble_base/\" || return 1\n    ble/bin/rm -rf \"$extracted_dir\"\n  ) &&\n    ble-update/.reload\n}\n## @fn ble-update/.check-build-dependencies\n##   @var[out] make\nfunction ble-update/.check-build-dependencies {\n  # check make\n  make=\n  if ble/bin#has gmake; then\n    make=gmake\n  elif ble/bin#has make && make --version 2>&1 | ble/bin/grep -qiF 'GNU Make'; then\n    make=make\n  else\n    ble/util/print \"ble-update: GNU Make is not available.\" >&2\n    return 1\n  fi\n\n  # check git, gawk\n  if ! ble/bin#has git gawk; then\n    local command\n    for command in git gawk; do\n      ble/bin#has \"$command\" ||\n        ble/util/print \"ble-update: '$command' command is not available.\" >&2\n    done\n    return 1\n  fi\n  return 0\n}\n## @fn ble-update/.check-repository\nfunction ble-update/.check-repository {\n  if [[ ${_ble_base_repository-} && $_ble_base_repository != release:* ]]; then\n    if [[ ! -e $_ble_base_repository/.git ]]; then\n      ble/util/print \"ble-update: git repository not found at '$_ble_base_repository'.\" >&2\n    elif [[ ! -O $_ble_base_repository ]]; then\n      ble/util/print \"ble-update: git repository is owned by another user:\" >&2\n      ls -ld \"$_ble_base_repository\"\n    elif [[ ! -r $_ble_base_repository || ! -w $_ble_base_repository || ! -x $_ble_base_repository ]]; then\n      ble/util/print 'ble-update: git repository permission denied:' >&2\n      ls -ld \"$_ble_base_repository\"\n    else\n      return 0\n    fi\n  fi\n  return 1\n}\nfunction ble-update/.impl {\n  if (($#)); then\n    ble/base/print-usage-for-no-argument-command 'Update and reload ble.sh.' \"$@\"\n    return \"$?\"\n  fi\n\n  if [[ ${_ble_base_package_type-} ]] && ble/is-function ble/base/package:\"$_ble_base_package_type\"/update; then\n    ble/util/print \"ble-update: delegate to '$_ble_base_package_type' package manager...\" >&2\n    ble/base/package:\"$_ble_base_package_type\"/update; local ext=$?\n    if ((ext==125)); then\n      ble/util/print 'ble-update: fallback to the default update process.' >&2\n    else\n      ble-update/.reload \"$ext\"\n      return \"$?\"\n    fi\n  fi\n\n  if [[ ${_ble_base_repository-} == release:nightly-* ]]; then\n    if ble-update/.download-nightly-build; local ext=$?; ((ext==0||ext==6||ext==7)); then\n      if ((ext==6)); then\n        ble/util/print 'ble-update (nightly): Already up to date.' >&2\n      elif ((ext==7)); then\n        ble/util/print 'ble-update (nightly): Remote temporarily unavailable. Try it again later.' >&2\n      fi\n      return 0\n    fi\n  fi\n\n  local make\n  ble-update/.check-build-dependencies || return 1\n\n  local insdir_doc=$_ble_base/doc\n  [[ ! -d $insdir_doc && -d ${_ble_base%/*}/doc/blesh ]] &&\n    insdir_doc=${_ble_base%/*}/doc/blesh\n\n  if ble-update/.check-repository; then\n    ( ble/util/print \"cd into $_ble_base_repository...\" >&2 &&\n        builtin cd \"$_ble_base_repository\" &&\n        git pull && git submodule update --recursive --remote &&\n        if [[ $_ble_base == \"$_ble_base_repository\"/out ]]; then\n          ble-update/.make all\n        elif ((EUID!=0)) && ! ble-update/.check-install-directory-ownership; then\n          ble-update/.make all\n          ble-update/.make --sudo INSDIR=\"$_ble_base\" INSDIR_DOC=\"$insdir_doc\" install\n        else\n          ble-update/.make INSDIR=\"$_ble_base\" INSDIR_DOC=\"$insdir_doc\" install\n        fi )\n    ble-update/.reload \"$?\"\n    return \"$?\"\n  fi\n\n  if ((EUID!=0)) && ! ble-update/.check-install-directory-ownership; then\n    # _ble_base が自分の物でない時は sudo でやり直す\n    sudo \"$BASH\" \"$_ble_base/ble.sh\" --update &&\n      ble-update/.reload 6\n    return \"$?\"\n  else\n    # _ble_base/src 内部に clone して make install\n    local branch=${_ble_base_branch:-master}\n    ( ble/bin/mkdir -p \"$_ble_base/src\" && builtin cd \"$_ble_base/src\" &&\n        git clone --recursive --depth 1 \"$_ble_base_repository_url\" \"$_ble_base/src/ble.sh\" -b \"$branch\" &&\n        builtin cd ble.sh && \"$make\" all &&\n        \"$make\" INSDIR=\"$_ble_base\" INSDIR_DOC=\"$insdir_doc\" install ) &&\n      ble-update/.reload\n    return \"$?\"\n  fi\n  return 1\n}\nfunction ble-update {\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_adjust\"\n  ble-update/.impl \"$@\"\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_return\"\n}\n#%if measure_load_time\nble/debug/measure-set-timeformat ble.pp/prologue\n}\n#%end\n\n\n#------------------------------------------------------------------------------\n_ble_attached=\nBLE_ATTACHED=\n\n#%x inc.r|@|src/def|\n#%x inc.r|@|src/util|\n\nbleopt/declare -v debug_xtrace ''\nbleopt/declare -v debug_xtrace_ps4 '+ '\n\nble/bin#freeze-utility-path \"${_ble_init_posix_command_list[@]}\" # <- this uses ble/util/assign.\nble/bin#freeze-utility-path man\nble/bin#freeze-utility-path groff nroff mandoc gzip bzcat lzcat xzcat # used by core-complete.sh\nble/bin/sed/.instantiate\n\nble/function#trace trap ble/builtin/trap ble/builtin/trap/finalize\nble/function#trace ble/builtin/trap/.handler ble/builtin/trap/invoke ble/builtin/trap/invoke.sandbox\nble/builtin/trap/install-hook EXIT\nble/builtin/trap/install-hook INT\nble/builtin/trap/install-hook ERR inactive\nble/builtin/trap/install-hook RETURN inactive\n\n# @var _ble_base_session\n# @var BLE_SESSION_ID\nfunction ble/base/initialize-session {\n  local ret\n  ble/string#split ret / \"${_ble_base_session-}\"\n  [[ ${ret[1]} == \"$$\" ]] && return 0\n\n  ble/util/timeval; local start_time=$ret\n  ((start_time-=SECONDS*1000000))\n\n  _ble_base_session=${start_time::${#start_time}-6}.${start_time:${#start_time}-6}/$$\n  export BLE_SESSION_ID=$_ble_base_session\n}\nble/base/initialize-session\n\n# DEBUG version の Bash では遅いという通知\nfunction ble/base/check-bash-debug-version {\n  case ${BASH_VERSINFO[4]} in\n  (alp*|bet*|dev*|rc*|releng*|maint*) ;;\n  (*) return 0 ;;\n  esac\n\n  local type=check ret\n  ble/opts#extract-last-optarg \"$_ble_base_arguments_opts\" bash-debug-version check && type=$ret\n  [[ $type == ignore ]] && return 0\n\n  local file=$_ble_base_cache/base.bash-debug-version-checked.txt\n  local -a checked=()\n  [[ ! -d $file && -r $file && -s $file ]] && ble/util/mapfile checked < \"$file\"\n  if ble/array#index checked \"$BASH_VERSION\"; then\n    [[ $type == once ]] && return 0\n  else\n    ble/util/print \"$BASH_VERSION\" >> \"$file\"\n  fi\n\n  local sgr0=$_ble_term_sgr0\n  local sgr1=${_ble_term_setaf[4]}\n  local sgr2=${_ble_term_setaf[6]}\n  local sgr3=${_ble_term_setaf[2]}\n  local sgrC=${_ble_term_setaf[8]}\n  local bold=$_ble_term_bold\n  if [[ $type == short || $_ble_init_command ]]; then\n    ble/util/print-lines \\\n      \"Note: ble.sh can be very slow in a debug version of Bash: $sgr3$BASH_VERSION$sgr0\"\n  else\n    ble/util/print-lines \\\n      \"$bold# ble.sh with debug version of Bash$sgr0\" \\\n      '' \\\n      'ble.sh may become very slow because this is a debug version of Bash (version' \\\n      \"\\`$sgr3$BASH_VERSION$sgr0', release status: \\`$sgr3${BASH_VERSINFO[4]}$sgr0').  We recommend using\" \\\n      'ble.sh with a release version of Bash.  If you want to use ble.sh with a' \\\n      'non-release version of Bash, it is highly recommended to build Bash with the' \\\n      \"configure option \\`$sgr2--with-bash-malloc=no$sgr0' for practical performance:\" \\\n      '' \\\n      \"  $sgr1./configure $bold--with-bash-malloc=no$sgr0\" \\\n      '' \\\n      'To suppress this startup warning message, please specify the option' \\\n      \"\\`$sgr2--bash-debug-version=short$sgr0' or \\`${sgr2}once$sgr0' or \\`${sgr2}ignore$sgr0' to \\`ble.sh':\" \\\n      '' \\\n      \"  ${sgrC}# Show a short version of the message$sgr0\" \\\n      \"  ${sgr1}source /path/to/ble.sh $bold--bash-debug-version=short$sgr0\" \\\n      '' \\\n      \"  ${sgrC}# Do not print the warning message more than once$sgr0\" \\\n      \"  ${sgr1}source /path/to/ble.sh $bold--bash-debug-version=once$sgr0\" \\\n      '' \\\n      \"  ${sgrC}# Show the warning message only once for each debug version of Bash$sgr0\" \\\n      \"  ${sgr1}source /path/to/ble.sh $bold--bash-debug-version=ignore$sgr0\" \\\n      ''\n  fi\n}\nble/base/check-bash-debug-version\n\n#%x inc.r|@|src/decode|\n#%x inc.r|@|src/color|\n#%x inc.r|@|src/canvas|\n#%x inc.r|@|src/history|\n#%x inc.r|@|src/edit|\n#%x inc.r|@|lib/core-cmdspec-def|\n#%x inc.r|@|lib/core-syntax-def|\n#%x inc.r|@|lib/core-complete-def|\n#%x inc.r|@|lib/core-debug-def|\n#%x inc.r|@|contrib/integration/bash-preexec-def|\n\n# initialization time = 9ms (for 70 files)\nble/function#try ble/util/idle.push ble/base/clean-up-runtime-directory\n\nbleopt -I\n#------------------------------------------------------------------------------\n#%if measure_load_time\ntime {\n#%end\n\n## @fn ble [SUBCOMMAND]\n##\n##   無引数で呼び出した時、現在 ble.sh の内部空間に居るかどうかを判定します。\n##\n# Bluetooth Low Energy のツールが存在するかもしれない\nble/bin#freeze-utility-path ble\nfunction ble/dispatch/.help {\n  ble/util/print-lines \\\n    'usage: ble [SUBCOMMAND [ARGS...]]' \\\n    '' \\\n    'SUBCOMMAND' \\\n    '  # Manage ble.sh' \\\n    '  attach  ... alias of ble-attach' \\\n    '  detach  ... alias of ble-detach'  \\\n    '  update  ... alias of ble-update' \\\n    '  reload  ... alias of ble-reload' \\\n    '  help    ... Show this help' \\\n    '  version ... Show version' \\\n    '  check   ... Run unit tests' \\\n    '' \\\n    '  # Configuration' \\\n    '  opt     ... alias of bleopt' \\\n    '  bind    ... alias of ble-bind' \\\n    '  face    ... alias of ble-face' \\\n    '  hook    ... alias of blehook' \\\n    '  sabbrev ... alias of ble-sabbrev' \\\n    '  palette ... alias of ble-color-show' \\\n    '' \\\n    '  # Diagnostics' \\\n    '  summary ... Summarize the current shell setup' \\\n    ''\n}\nfunction ble/dispatch:summary {\n  ble/widget/display-shell-version\n}\n\nfunction ble/dispatch {\n  if (($#==0)); then\n    [[ $_ble_attached && ! $_ble_edit_exec_inside_userspace ]]\n    return \"$?\"\n  fi\n\n  # import autoload measure assert stackdump color-show decode-{byte,char,key}\n  local cmd=$1; shift\n  case $cmd in\n  (attach)  ble-attach \"$@\" ;;\n  (detach)  ble-detach \"$@\" ;;\n  (update)  ble-update \"$@\" ;;\n  (reload)  ble-reload \"$@\" ;;\n  (face)    ble-face \"$@\" ;;\n  (bind)    ble-bind \"$@\" ;;\n  (opt)     bleopt \"$@\" ;;\n  (hook)    blehook \"$@\" ;;\n  (sabbrev) ble-sabbrev \"$@\" ;;\n  (palette) ble-palette \"$@\" ;;\n  (help|--help) ble/dispatch/.help \"$@\" ;;\n  (version|--version) ble/util/print \"ble.sh, version $BLE_VERSION (noarch)\" ;;\n  (check|--test) ble/base/sub:test \"$@\" ;;\n  (*)\n    if ble/string#match \"$cmd\" '^[-a-zA-Z0-9]+$'; then\n      if ble/is-function ble/dispatch:\"$cmd\"; then\n        ble/dispatch:\"$cmd\" \"$@\"\n        return \"$?\"\n      elif ble/is-function \"ble-$cmd\"; then\n        \"ble-$cmd\" \"$@\"\n        return \"$?\"\n      fi\n    fi\n\n    if ble/is-function ble/bin/ble; then\n      # There seems to be an existing command \"ble\" for BLE (Bluetooth Low\n      # Energy) which has the following subcommands [1]: abort, begin,\n      # callback, characteristics, close, connect, descriptors, disable,\n      # disconnect, dread, dwrite, enable, equal, execute, expand, getrssi,\n      # info, mtu, pair, read, reconnect, scanner, services, shorten, start,\n      # stop, unpair, userdata, write.  If we receive an unknown subcommand and\n      # an external command \"ble\" exists, we redirect the call to the external\n      # command \"ble\".\n      #\n      # [1] https://www.androwish.org/home/wiki?name=ble+command\n      ble/bin/ble \"$cmd\" \"$@\"\n      return \"$?\"\n    fi\n\n    ble/util/print \"ble (ble.sh): unrecognized subcommand '$cmd'.\" >&2\n    return 2\n  esac\n}\nfunction ble {\n  case ${1-} in\n  (attach|detach|update|reload)\n    # These subcommands can affect the POSIX mode, so we need to call them\n    # without the adjustment of the POSIX mode.\n    \"ble-$@\" ;;\n  (*)\n    builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_adjust\"\n    ble/dispatch \"$@\"\n    builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_return\" ;;\n  esac\n}\n\n\n# blerc\n_ble_base_rcfile=\n_ble_base_rcfile_initialized=\nfunction ble/base/load-rcfile {\n  [[ $_ble_base_rcfile_initialized ]] && return 0\n  _ble_base_rcfile_initialized=1\n\n  # blerc\n  if [[ ! $_ble_base_rcfile ]]; then\n    { _ble_base_rcfile=$HOME/.blerc; [[ -f $_ble_base_rcfile ]]; } ||\n      { _ble_base_rcfile=${XDG_CONFIG_HOME:-$HOME/.config}/blesh/init.sh; [[ -f $_ble_base_rcfile ]]; } ||\n      _ble_base_rcfile=$HOME/.blerc\n  fi\n  if [[ -s $_ble_base_rcfile ]]; then\n    source \"$_ble_base_rcfile\"\n    blehook/.compatibility-ble-0.3/check\n  fi\n}\n\n## @fn ble-attach [opts]\nfunction ble-attach {\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A1-begin\n#%end.i\n  if (($# >= 2)); then\n    # Note: We may not use \"ble/util/print-lines\" because it can be in the\n    # POSIX mode.\n    builtin printf '%s\\n' \\\n      'usage: ble-attach [opts]' \\\n      'Attach to ble.sh.' >&2\n    [[ $1 != --help ]] && return 2\n    return 0\n  fi\n\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A2-arg\n#%end.i\n  # when detach flag is present\n  if [[ $_ble_edit_detach_flag ]]; then\n    case $_ble_edit_detach_flag in\n    (exit) return 0 ;;\n    (*) _ble_edit_detach_flag= ;; # cancel \"detach\"\n    esac\n  fi\n\n  [[ ! $_ble_attached ]] || return 0\n#%if measure_load_time\n  ble/init/measure/section 'prompt'\n#%end\n  _ble_attached=1\n  BLE_ATTACHED=1\n\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A3-guard\n#%end.i\n  # 特殊シェル設定を待避\n  builtin eval -- \"$_ble_bash_FUNCNEST_adjust\"\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_adjust\"\n  ble/base/adjust-builtin-wrappers\n  ble/base/adjust-bash-options\n  ble/base/adjust-BASH_REMATCH\n\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A4-adjust\n#%end.i\n  if [[ ${IN_NIX_SHELL-} ]]; then\n    # nix-shell rc の中から実行している時は強制的に prompt-attach にする\n    if [[ \"${BASH_SOURCE[*]}\" == */rc && $1 != *:force:* ]]; then\n      ble/base/install-prompt-attach\n      _ble_attached=\n      BLE_ATTACHED=\n      ble/base/restore-BASH_REMATCH\n      ble/base/restore-bash-options\n      ble/base/restore-builtin-wrappers\n      ble/base/restore-POSIXLY_CORRECT\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A4b1\n#%end.i\n      builtin eval -- \"$_ble_bash_FUNCNEST_restore\"\n      return 0\n    fi\n\n    # nix-shell は BASH を誤った値に書き換えるので上書きする。\n    local ret\n    ble/util/readlink \"/proc/$$/exe\"\n    [[ -x $ret ]] && BASH=$ret\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A4b2\n#%end.i\n  fi\n\n  # reconnect standard streams\n  ble/fd/save-external-standard-streams\n  exec 0<&\"$_ble_util_fd_tui_stdin\"\n  exec 1>&\"$_ble_util_fd_tui_stdout\"\n  exec 2>&\"$_ble_util_fd_tui_stderr\"\n\n  # Terminal initialization and Terminal requests (5.0ms)\n  #   The round-trip communication will take time, so we first adjust the\n  #   terminal state and send requests.  We then calculate the first prompt,\n  #   which takes about 50ms, while waiting for the responses from the\n  #   terminal.\n  ble/util/notify-broken-locale\n  ble/term/initialize     # 0.4ms\n  ble/term/attach noflush # 2.5ms (起動時のずれ防止の為 stty -echo は早期に)\n  ble/canvas/attach       # 1.8ms (requests for char_width_mode=auto)\n  ble/util/buffer.flush   # 0.3ms\n\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A5-term/init\n#%end.i\n\n  # Show the first prompt (44.7ms)\n  ble-edit/initialize       # 0.3ms\n  ble-edit/attach           # 2.1ms (_ble_edit_PS1 他の初期化)\n  ble_attach_first_prompt=1 \\\n    ble/canvas/panel/render # 42ms\n  ble/util/buffer.flush     # 0.2ms\n#%if measure_load_time\n  ble/util/print >&2\n  ble/init/measure/section 'bind'\n#%end\n\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A6-edit\n#%end.i\n\n  # keymap 初期化\n  local IFS=$_ble_term_IFS\n  ble/decode/initialize # 7ms\n  ble/decode/reset-default-keymap # 264ms (keymap/vi.sh)\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A7-decode\n#%end.i\n  if ! ble/decode/attach; then # 53ms\n    _ble_attached=\n    BLE_ATTACHED=\n    ble-edit/detach\n    ble/term/leave\n    ble/base/restore-BASH_REMATCH\n    ble/base/restore-bash-options\n    ble/base/restore-builtin-wrappers\n    ble/base/restore-POSIXLY_CORRECT\n    builtin eval -- \"$_ble_bash_FUNCNEST_restore\"\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A7b1\n#%end.i\n    return 1\n  fi\n\n  ble/history:bash/reset # 27s for bash-3.0\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A8-history\n#%end.i\n\n  # We here temporarily restore PS1 and PROMPT_COMMAND for the user hooks\n  # registered to ATTACH.  Note that in this context, ble-edit/adjust-PS1 is\n  # already performed by the above ble-edit/attach.\n  ble-edit/restore-PS1\n  blehook/invoke ATTACH\n  ble-edit/adjust-PS1\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A9-ATTACH\n#%end.i\n\n  # Note: 再描画 (初期化中のエラーメッセージ・プロンプト変更等の為)\n  ble/textarea#redraw\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A10-redraw\n#%end.i\n\n  # Note: ble-decode/{initialize,reset-default-keymap} 内で\n  #   info を設定する事があるので表示する。\n  ble/edit/info/default\n#%if measure_load_time\n  ble/init/measure/section 'idle'\n#%end\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A11-info\n#%end.i\n  ble-edit/bind/.tail\n#%if leakvar\nble/debug/leakvar#check $\"leakvar\" A12-tail\n#%end.i\n}\n\nfunction ble-detach {\n  if (($#)); then\n    builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_adjust\"\n    ble/base/print-usage-for-no-argument-command 'Detach from ble.sh.' \"$@\"\n    builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_leave\"\n    return 2\n  fi\n\n  [[ $_ble_attached && ! $_ble_edit_detach_flag ]] || return 1\n\n  # Note: 実際の detach 処理は ble-edit/bind/.check-detach で実行される\n  _ble_edit_detach_flag=${1:-detach} # schedule detach\n}\nfunction ble-detach/impl {\n  [[ $_ble_attached ]] || return 1\n  _ble_attached=\n  BLE_ATTACHED=\n  blehook/invoke DETACH\n\n  ble-edit/detach\n  ble/decode/detach\n  READLINE_LINE='' READLINE_POINT=0\n}\nfunction ble-detach/message {\n  ble/util/buffer.print-lines \"$@\"\n  ble/util/buffer.flush\n  ble/edit/info/clear\n  ble/textarea#render\n  ble/util/buffer.flush\n}\n\nfunction ble/base/unload-for-reload {\n  if [[ $_ble_attached ]]; then\n    ble-detach/impl\n    local ret\n    ble/edit/marker#instantiate 'reload' &&\n      ble/util/print \"$ret\" >&\"$_ble_util_fd_tui_stderr\"\n    [[ $_ble_edit_detach_flag ]] ||\n      _ble_edit_detach_flag=reload\n  fi\n\n  # We here localize \"_ble_bash\" to avoid overwriting _ble_bash, which is\n  # already initialized by the new instance of ble.sh.\n  local _ble_bash=$_ble_bash\n  ble/base/unload reload\n  return 0\n}\n## @fn ble/base/unload [opts]\nfunction ble/base/unload {\n  ble/util/is-running-in-subshell && return 1\n\n  # Adjust environment\n  local IFS=$_ble_term_IFS\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_adjust\"\n  ble/base/adjust-builtin-wrappers\n  ble/base/adjust-bash-options\n  ble/base/adjust-BASH_REMATCH\n\n  # src/edit.sh\n  ble-edit/bind/clear-keymap-definition-loader\n  ble/widget/.bell/.clear-DECSCNM\n\n  # decode.sh\n  ble/decode/keymap#unload\n\n  # src/util.sh\n  ble/term/stty/TRAPEXIT \"$1\"\n  ble/term/leave\n  ble/util/buffer.flush\n  blehook/invoke unload\n  ble/builtin/trap/finalize \"$1\"\n  ble/util/import/finalize\n\n  # main\n  ble/base/clean-up-runtime-directory finalize\n  ble/fd#finalize # this is used by the above function\n  ble/base/clear-version-variables\n  return 0\n} 0<&\"$_ble_util_fd_tui_stdin\" 1>&\"$_ble_util_fd_tui_stdout\" 2>&\"$_ble_util_fd_tui_stderr\"\n\n## @var _ble_base_attach_from_prompt\n##   非空文字列の時、PROMPT_COMMAND 経由の ble-attach を現在試みている最中です。\n##\n## @arr _ble_base_attach_PROMPT_COMMAND\n##   PROMPT_COMMAND 経由の ble-attach をする時、元々の PROMPT_COMMAND の値を保\n##   持する配列です。複数回 ble.sh をロードした時に、各ロード時に待避した\n##   PROMPT_COMMAND の値を配列の各要素に保持します。\n##\n##   Note #D1851: 以前の ble.sh ロード時に設定された値を保持したいので、既に要\n##   素がある場合にはクリアしない。\n_ble_base_attach_from_prompt=\n((${#_ble_base_attach_PROMPT_COMMAND[@]})) ||\n  _ble_base_attach_PROMPT_COMMAND=()\n## @fn ble/base/install-prompt-attach\nfunction ble/base/install-prompt-attach {\n  [[ ! $_ble_base_attach_from_prompt ]] || return 0\n  _ble_base_attach_from_prompt=1\n  if ((_ble_bash>=50100)); then\n    ((${#PROMPT_COMMAND[@]})) || PROMPT_COMMAND[0]=\n\n    local prompt_command=ble/base/attach-from-PROMPT_COMMAND\n    if ((_ble_bash>=50300)); then\n      local prompt_command_new=ble::base::attach-from-PROMPT_COMMAND\n      ble/function#copy \"$prompt_command\" \"$prompt_command_new\" &&\n        prompt_command=$prompt_command_new\n    fi\n    ble/array#push PROMPT_COMMAND \"$prompt_command\"\n\n    if [[ $_ble_edit_detach_flag == reload ]]; then\n      _ble_edit_detach_flag=prompt-attach\n      blehook internal_PRECMD!=ble/base/attach-from-PROMPT_COMMAND\n    fi\n  else\n    local save_index=${#_ble_base_attach_PROMPT_COMMAND[@]}\n    _ble_base_attach_PROMPT_COMMAND[save_index]=${PROMPT_COMMAND-}\n    # Note: We adjust FUNCNEST and POSIXLY_CORRECT but do not need to be\n    # restore them here because \"ble/base/attach-from-PROMPT_COMMAND\" fails\n    # only when \"ble-attach\" fails, in such a case \"ble-attach\" already restore\n    # them.\n    ble/function#lambda PROMPT_COMMAND '\n      local _ble_local_lastexit=$? _ble_local_lastarg=$_\n      builtin eval -- \"$_ble_bash_FUNCNEST_adjust\"\n      builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_adjust\"\n      ble/util/setexit \"$_ble_local_lastexit\" \"$_ble_local_lastarg\"\n      ble/base/attach-from-PROMPT_COMMAND '\"$save_index\"' \"'\"$FUNCNAME\"'\"'\n    ble/function#trace \"$PROMPT_COMMAND\"\n    if [[ $_ble_edit_detach_flag == reload ]]; then\n      _ble_edit_detach_flag=prompt-attach\n      blehook internal_PRECMD!=\"$PROMPT_COMMAND\"\n    fi\n  fi\n}\n_ble_base_attach_from_prompt_lastexit=\n_ble_base_attach_from_prompt_lastarg=\n_ble_base_attach_from_prompt_PIPESTATUS=()\n## @fn ble/base/attach-from-PROMPT_COMMAND prompt_command lambda\nfunction ble/base/attach-from-PROMPT_COMMAND {\n  # 後続の設定によって PROMPT_COMMAND が置換された場合にはそれを保持する\n  {\n    # save $?, $_ and ${PIPE_STATUS[@]}\n    _ble_base_attach_from_prompt_lastexit=$? \\\n      _ble_base_attach_from_prompt_lastarg=$_ \\\n      _ble_base_attach_from_prompt_PIPESTATUS=(\"${PIPESTATUS[@]}\")\n\n    builtin eval -- \"$_ble_bash_FUNCNEST_adjust\"\n\n#%if measure_load_time\n    ble/util/print \"ble.sh: $EPOCHREALTIME start prompt-attach\" >&2\n#%end\n    if ((BASH_LINENO[${#BASH_LINENO[@]}-1]>=1)); then\n      # 既にコマンドを実行している時にはそのコマンドの結果を記録する\n      _ble_edit_exec_lastexit=$_ble_base_attach_from_prompt_lastexit\n      _ble_edit_exec_lastarg=$_ble_base_attach_from_prompt_lastarg\n      _ble_edit_exec_PIPESTATUS=(\"${_ble_base_attach_from_prompt_PIPESTATUS[@]}\")\n      # Note: 本当は一つ前のコマンドを知りたいが確実な方法がないのでこの関数の名前を入れておく。\n      _ble_edit_exec_BASH_COMMAND=$FUNCNAME\n    fi\n\n    local is_last_PROMPT_COMMAND=1\n    if (($#==0)); then\n      if local ret; ble/array#index PROMPT_COMMAND \"$FUNCNAME\"; then\n        local keys; keys=(\"${!PROMPT_COMMAND[@]}\")\n        ((ret==keys[${#keys[@]}-1])) || is_last_PROMPT_COMMAND=\n        ble/idict#replace PROMPT_COMMAND \"$FUNCNAME\"\n      fi\n      blehook internal_PRECMD-=\"$FUNCNAME\" || ((1)) # set -e 対策\n    else\n      local save_index=$1 lambda=$2\n\n      # 待避していた内容を復元・実行\n      local PROMPT_COMMAND=${_ble_base_attach_PROMPT_COMMAND[save_index]}\n      local ble_base_attach_from_prompt_command=processing\n      ble/prompt/update/.eval-prompt_command 2>&\"$_ble_util_fd_tui_stderr\"\n      ble/util/unlocal ble_base_attach_from_prompt_command\n      _ble_base_attach_PROMPT_COMMAND[save_index]=$PROMPT_COMMAND\n      ble/util/unlocal PROMPT_COMMAND\n\n      # 可能なら自身を各 hook から除去\n      blehook internal_PRECMD-=\"$lambda\" || ((1)) # set -e 対策\n      if [[ $PROMPT_COMMAND == \"$lambda\" ]]; then\n        PROMPT_COMMAND=${_ble_base_attach_PROMPT_COMMAND[save_index]}\n      else\n        is_last_PROMPT_COMMAND=\n      fi\n\n      # #D1354: 入れ子の ble/base/attach-from-PROMPT_COMMAND の時は一番外側で\n      #   ble-attach を実行する様にする。2>/dev/null のリダイレクトにより\n      #   stdout.off の効果が巻き戻されるのを防ぐ為。\n      [[ ${ble_base_attach_from_prompt_command-} != processing ]] || return 0\n    fi\n\n    # 既に attach 状態の時は処理はスキップ\n    [[ $_ble_base_attach_from_prompt ]] || return 0\n    _ble_base_attach_from_prompt=\n\n    # Note #D1778: この attach-from-PROMPT_COMMAND が PROMPT_COMMAND\n    #   処理の最後と見做せる場合、この時点で PROMPT_COMMAND は一通り終\n    #   わったと見做せるので、ble-attach 内部で改めて PROMPT_COMMAND\n    #   を実行する必要はなくなる。それを伝える為に中間状態の\n    #   _ble_prompt_hash の値を設定する。\n    # Note #D1778: bash-preexec 経由でプロンプトを設定しようとしている\n    #   場合は、この時点で既に PRECMD に hook が移動している可能性があ\n    #   るので PRECMD も発火しておく (PROMPT_COMMAND と PRECMD の順序\n    #   が逆になるが仕方がない。問題になれば後で考える)。\n    if [[ $is_last_PROMPT_COMMAND ]]; then\n      ble-edit/exec:gexec/invoke-hook-with-setexit internal_PRECMD\n      ble-edit/exec:gexec/invoke-hook-with-setexit PRECMD\n      _ble_prompt_hash=$COLUMNS:$_ble_edit_lineno:prompt_attach\n    fi\n  } 2>/dev/null # set -x 対策 #D0930\n\n  ble-attach force; local ext=$?\n\n  # Note: When POSIXLY_CORRECT is adjusted outside this function, and when\n  # \"ble-attach force\" fails, the adjusted POSIXLY_CORRECT may be restored.\n  # For such a case, we need to locally adjust POSIXLY_CORRECT to work around\n  # 5.3 function names with a slash.\n  builtin eval -- \"$_ble_bash_FUNCNEST_local_adjust\"\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_adjust\"\n\n  # Note: 何故か分からないが PROMPT_COMMAND から ble-attach すると\n  # ble/bin/stty や ble/bin/mkfifo や tty 2>/dev/null などが\n  # ジョブとして表示されてしまう。joblist.flush しておくと平気。\n  # これで取り逃がすジョブもあるかもしれないが仕方ない。\n  ble/util/joblist.flush &>/dev/null\n  ble/util/joblist.check\n#%if measure_load_time\n  ble/util/print \"ble.sh: $EPOCHREALTIME end prompt-attach\" >&2\n#%end\n\n  builtin eval -- \"$_ble_bash_POSIXLY_CORRECT_local_leave\"\n  builtin eval -- \"$_ble_bash_FUNCNEST_local_leave\"\n  return \"$?\"\n}\n\nfunction ble/base/process-blesh-arguments {\n  local opts=$_ble_base_arguments_opts\n  local attach=$_ble_base_arguments_attach\n  local inputrc=$_ble_base_arguments_inputrc\n\n  _ble_base_rcfile=$_ble_base_arguments_rcfile\n\n  # reconstruction type of user-bindings\n  _ble_decode_initialize_inputrc=$inputrc\n\n#%if measure_load_time\ntime {\n#%end\n  ble/base/load-rcfile # blerc\n#%if measure_load_time\nble/debug/measure-set-timeformat \"blerc: '$_ble_base_rcfile'\"; }\n#%end\n  ble/util/invoke-hook BLE_ONLOAD\n\n  # attach\n  case $attach in\n  (attach) ble-attach ;;\n  (prompt) ble/base/install-prompt-attach ;;\n  (none) ;;\n  (*) ble/util/print \"ble.sh: unrecognized attach method --attach='$attach'.\" ;;\n  esac\n}\n\nfunction ble/base/sub:test {\n  local error= logfile=\n\n  [[ ${LANG-} ]] || local LANG=en_US.UTF-8\n\n  ble-import lib/core-test\n\n  if (($#==0)); then\n    set -- bash main util canvas decode edit syntax complete keymap.vi\n    local timestamp\n    ble/util/strftime -v timestamp '%Y%m%d.%H%M%S'\n    logfile=$_ble_base_cache/test.$timestamp.log\n    >| \"$logfile\"\n    ble/test/log#open \"$logfile\"\n  fi\n\n  if ((!_ble_make_command_check_count)); then\n    ble/test/log \"MACHTYPE: $MACHTYPE\"\n    ble/test/log \"BLE_VERSION: $BLE_VERSION\"\n  fi\n  ble/test/log \"BASH_VERSION: $BASH_VERSION\"\n  local line='locale:' var ret\n  for var in LANG \"${!LC_@}\"; do\n    ble/string#quote-word \"${!var}\"\n    line=\"$line $var=$ret\"\n  done\n  ble/test/log \"$line\"\n\n  local _ble_test_section_failure_count=0\n  local section\n  for section; do\n    local file=$_ble_base/lib/test-$section.sh\n    if [[ -f $file ]]; then\n      source \"$file\"\n    else\n      ble/test/log \"ERROR: Test '$section' is not defined.\"\n      error=1\n    fi\n  done\n  ((_ble_test_section_failure_count)) && error=1\n\n  if [[ $logfile ]]; then\n    ble/test/log#close\n    ble/util/print \"ble.sh: The test log was saved to '${_ble_term_setaf[4]}$logfile$_ble_term_sgr0'.\"\n  fi\n  [[ ! $error ]]\n}\nfunction ble/base/sub:update { ble-update; }\nfunction ble/base/sub:clear-cache {\n  (shopt -u failglob; ble/bin/rm -rf \"$_ble_base_cache\"/*)\n}\nfunction ble/base/sub:install {\n  local insdir=${1:-${XDG_DATA_HOME:-$HOME/.local/share}}/blesh\n\n  local dir=$insdir sudo=\n  [[ $dir == /* ]] || dir=./$dir\n  while [[ $dir && ! -d $dir ]]; do\n    dir=${dir%/*}\n  done\n  [[ $dir ]] || dir=/\n  if ! [[ -r $dir && -w $dir && -x $dir ]]; then\n    if ((EUID!=0)) && [[ ! -O $dir ]] && ble/bin#has sudo; then\n      sudo=1\n    else\n      ble/util/print \"ble.sh --install: $dir: permission denied\" >&2\n      return 1\n    fi\n  fi\n\n  if [[ ${_ble_base_repository-} == release:nightly-* ]]; then\n    if [[ $insdir == \"$_ble_base\" ]]; then\n      ble/util/print \"ble.sh --install: already installed\" >&2\n      return 1\n    fi\n    local ret\n    ble/string#quote-word \"$insdir\"; local qinsdir=$ret\n    ble/string#quote-word \"$_ble_base\"; local qbase=$ret\n    if [[ $sudo ]]; then\n      ble/util/print \"\\$ sudo mkdir -p $qinsdir\"\n      sudo mkdir -p \"$insdir\"\n      ble/util/print \"\\$ sudo cp -Rf $qbase/* $qinsdir/\"\n      sudo cp -Rf \"$_ble_base\"/* \"$insdir/\"\n      ble/util/print \"\\$ sudo rm -rf $qinsdir/{cache.d,run}\"\n      sudo rm -rf \"$insdir\"/{cache.d,run}\n    else\n      ble/util/print \"\\$ mkdir -p $qinsdir\"\n      ble/bin/mkdir -p \"$insdir\"\n      ble/util/print \"\\$ cp -Rf $qbase/* $qinsdir/\"\n      ble/bin/cp -Rf \"$_ble_base\"/* \"$insdir/\"\n      ble/util/print \"\\$ rm -rf $qinsdir/cache.d/*\"\n      ble/bin/rm -rf \"$insdir/cache.d\"/*\n    fi\n  elif local make; ble-update/.check-build-dependencies && ble-update/.check-repository; then\n    ( ble/util/print \"cd into $_ble_base_repository...\" >&2 &&\n        builtin cd \"$_ble_base_repository\" &&\n        ble-update/.make ${sudo:+--sudo} install INSDIR=\"$insdir\" )\n  else\n    ble/util/print \"ble.sh --install: not supported.\" >&2\n    return 1\n  fi\n}\nfunction ble/base/sub:lib { return 0; } # do nothing\n\n#%if measure_load_time\nble/debug/measure-set-timeformat ble.pp/epilogue; }\n#%end\n\n# Note: ble-attach 及びそれを呼び出す可能性がある物には DEBUG trap を\n#   継承させる。これはユーザーの設定した user trap を正しく抽出する為\n#   に必要。現在は ble-attach から呼び出される ble-edit/attach で処理\n#   している。\nble/function#trace ble-attach\nble/function#trace ble\nble/function#trace ble/dispatch\nble/function#trace ble/base/attach-from-PROMPT_COMMAND\n\n# Note #D1775: 以下は ble/base/unload 時に元の trap または ble.sh 有効時にユー\n#   ザーが設定した trap を復元する為に用いる物。ble/base/unload は中で\n#   ble/builtin/trap/finalize を呼び出す。ble/builtin/trap/finalize は別の箇所\n#   で ble/function#trace されている。\nble/function#trace ble/base/unload\n\nble-import -f lib/_package\nif [[ $_ble_init_command ]]; then\n  ble/base/sub:\"${_ble_init_command[@]}\"; _ble_init_exit=$?\n  [[ $_ble_init_attached ]] && ble-attach\n  ble/util/setexit \"$_ble_init_exit\"\nelse\n  ble/base/process-blesh-arguments \"$@\"\nfi\n\n#%if measure_load_time\nble/debug/measure-set-timeformat 'Total' nofork; }\n_ble_init_exit=$?\n[[ ${BLE_ATTACHED-} ]] || ble/init/measure/section 'wait'\nble/util/setexit \"$_ble_init_exit\"\n#%end\n\nble/init/clean-up check-attach 2>/dev/null # set -x 対策 #D0930\n{ builtin eval \"return $? || exit $?\"; } 2>/dev/null # set -x 対策 #D0930\n###############################################################################\n"
        },
        {
          "name": "blerc.template",
          "type": "blob",
          "size": 61.0107421875,
          "content": "# -*- mode: sh; mode: sh-bash -*-\n\n## This is a template for \"~/.blerc\".\n##\n## To use ble.sh in bash, please set up \"~/.bashrc\" as follows:\n##\n## ```bash\n## # bashrc\n##\n## # Please put the following line in the beginning of .bashrc\n## # Note: Please replace $HOME/.local/share/blesh with the path to your ble.sh\n## [[ $- == *i* ]] && source \"$HOME/.local/share/blesh/ble.sh\" --noattach\n##\n## # Your bashrc contents should come between the two lines.\n##\n## # Please put the following line in the end of .bashrc\n## [[ ! ${BLE_VERSION-} ]] || ble-attach\n## ```\n##\n\n##-----------------------------------------------------------------------------\n## Basic settings\n\n\n## The following setting specifies the input encoding. Currently only \"UTF-8\"\n## and \"C\" is available.\n\n#bleopt input_encoding=UTF-8\n\n\n## The following setting specifies the pager used by ble.sh.  This is used to\n## show the help of commands (f1).\n\n#bleopt pager=less\n\n## The following setting specifies the editor used by ble.sh.  This is used for\n## the widget edit-and-execute (C-x C-e) and editor for a large amount of\n## command line texts.  Possible values include, for example, \"vim\", \"emacs\n## -nw\" and \"nano\".\n\n#bleopt editor=vim\n\n\n## The following settings sets the behavior of visible bells (vbell).  The\n## option \"vbell_duration\" sets the time duration to show the vbell.  The\n## option \"vbell_align\" controls the position of vbell with a colon-separated\n## fields. The fields \"left\", \"center\", and \"right\" specify that the vbell\n## should be shown up on the left, center, and right, respectively, in the\n## terminal display.  The default is \"right\".  The field \"panel\" specify that\n## vbell should be shown below the command line within the line editor\n## interface (as far as the line editor is currently active).  The faces\n## \"vbell\", \"vbell_erase\", and \"vbell_flash\" specify the graphic style of the\n## vbell, the one after vbell is erased, and the one used to blink the vbell,\n## respectively.\n\n#bleopt vbell_default_message=' Wuff, -- Wuff!! '\n#bleopt vbell_duration=2000\n#bleopt vbell_align=right\n#ble-face vbell='reverse'\n#ble-face vbell_erase='bg=252'\n#ble-face vbell_flash='fg=green,reverse'\n\n\n##-----------------------------------------------------------------------------\n## Line editor settings\n\n\n## This option controls the behavior of the bell in the line editing by\n## colon-separated values.  When \"abell\", \"vbell\", and \"visual\" are contained,\n## the audible bells, the visible bells, and the visual bells are enabled.  The\n## audible bell sends BEL to the terminal.  The visible bell shows the message\n## on the terminal display.  The visual bell is the GNU-Screen style bell that\n## flashes the terminal display by turning on DECSCNM in a short moment.  Old\n## settings \"edit_vbell\" and \"edit_abell\" should be updated to use \"edit_bell\".\n\n#bleopt edit_bell=abell\n\n\n## The following setting turns on the delayed load of history when an non-empty\n## value is set.\n\n#bleopt history_lazyload=1\n\n\n## The following setting turns on the delete selection mode when an non-empty\n## value is set. When the mode is turned on the selection is removed when a\n## user inserts a character.\n\n#bleopt delete_selection_mode=1\n\n\n## The following settings control the indentation. \"indent_offset\" sets the\n## indent width. \"indent_tabs\" controls if tabs can be used for indentation or\n## not. If \"indent_tabs\" is set to 0, tabs will never be used. Otherwise\n## indentation is made with tabs and spaces.\n\n#bleopt indent_offset=4\n#bleopt indent_tabs=1\n\n\n## \"undo_point\" controls the cursor position after \"undo\".  When \"beg\" and\n## \"end\" are specified, the cursor will be moved to the beginning and the end,\n## respectively, of the dirty section.  When \"first\" and \"last\" are specified,\n## the cursor position will be the first and last positions, respectively, for\n## which the resulting line content is recorded.  When \"near\" is specified, it\n## behaves like \"last\" for undo and \"first\" for redo.  Otherwise, it behaves\n## like \"beg\" for vi command modes and \"near\" for the other modes.  The default\n## is \"auto\".\n\n#bleopt undo_point=near\n\n\n## The following setting controls forced layout calculations before graphical\n## operations. When a non-empty value is specified, the forced calculations are\n## enabled. When an empty string is set, the operations are switched to logical\n## ones.\n\n#bleopt edit_forced_textmap=1\n\n\n## The following option controls the interpretation of lines when going to the\n## beginning or the end of the current line.  When the value `logical` is\n## specified, the logical line is used, i.e., the beginning and the end of the\n## line is determined based on the newline characters in the edited text.  When\n## the value `graphical` is specified, the graphical line is used, i.e., the\n## beginning and the end of the displayed line in the terminal is used.\n\n#bleopt edit_line_type=graphical\n\n\n## The following option specifies the set of expansions performed by\n## magic-space with a colon-separated list of expansion types. \"history\",\n## \"sabbrev\", \"alias\", and \"autocd\" can be specified.\n\n#bleopt edit_magic_expand=history:sabbrev\n\n\n## This option configures the detailed behavior of the widget \"magic-space\"\n## with a colon-separated list.  If the field \"inline-sabbrev-no-insert\" is\n## specified, the insertion of \"SP\" is skipped when the inline sabbrev is\n## performed by \"magic-space\".\n\n#bleopt edit_magic_opts=\n\n\n## This option specifies the expansions performed on accept-line by a\n## colon-separated list.  The expansion is performed in a similar way as Bash's\n## history expansion.  When \"sabbrev\", \"alias\", \"autocd\", and \"history\" is\n## specified, the respective expansions are attempted on the command line.\n## When \"verify\" is specified, if sabbrev, alias, or autocd expansions changed\n## the command line, the execution of the command line is canceled so the user\n## can examine or continue to edit the expanded line.  The history expansion\n## can be controlled by \"shopt -s histverify\" in a similar manner.  When\n## \"verify-syntax\" is specified and any expansions change the command string, a\n## syntax check is performed.  The command execution is canceled when the\n## command string is not syntactically complete.  When \"history-line\" is\n## specified, the history expansion replaces the command line instead of just\n## printing the expansion result.  The default value of this option is empty.\n\n#bleopt edit_magic_accept=sabbrev\n\n\n## The following option controls the position of the info pane where completion\n## menu, mode names, and other information are shown.  When the value \"top\" is\n## specified, the info pane is shown just below the command line.  When the\n## value \"bottom\" is specified, the info pane is shown at the bottom of the\n## terminal.  The default is \"top\".\n\n#bleopt info_display=top\n\n\n## The following settings controls the prompt after the cursor left the command\n## line.  \"prompt_ps1_final\" contains a prompt string.  \"prompt_ps1_transient\"\n## is a colon-separated list of fields \"always\", \"same-dir\" and \"trim\".  The\n## prompt is replaced by \"prompt_ps1_final\" if it has a non-empty value.\n## Otherwise, the prompt is trimmed leaving the last line if\n## \"prompt_ps1_transient\" has a field \"trim\".  Otherwise, the prompt vanishes\n## if \"prompt_ps1_transient\" has a non-empty value.  When\n## \"prompt_ps1_transient\" contains a field \"same-dir\", the setting of\n## \"prompt_ps1_transient\" is effective only when the current working directory\n## did not change since the last command line.\n\n#bleopt prompt_ps1_final=\n#bleopt prompt_ps1_transient=trim\n\n\n## The following settings controls the right prompt. \"prompt_rps1\" specifies\n## the contents of the right prompt in the format of PS1.  When the cursor\n## leaves the current command line, the right prompt is replaced by\n## \"prompt_rps1_final\" if it has a non-empty value, or otherwise, the right\n## prompt vanishes if \"prompt_rps1_transient\" is set to a non-empty value,\n\n#bleopt prompt_rps1='\\w'\n#bleopt prompt_rps1_final=\n#bleopt prompt_rps1_transient=''\n\n\n## The following settings specify the content of terminal titles and status\n## lines.  \"prompt_xterm_title\" specifies the terminal title which can be set\n## by \"OSC 0 ; ... BEL\".  \"prompt_screen_title\" is effective inside terminal\n## multiplexers such as GNU screen and tmux and specifies the window title of\n## the terminal multiplexer which can be set by \"ESC k ... ST\".\n## \"prompt_term_status\" is only effective when terminfo entries \"tsl\" and \"fsl\"\n## (or termcap entries \"ts\" and \"ds\") are available, and specifies the content\n## of the status line which can be set by the terminfo entries.  When each\n## setting has non-empty value, the content of corresponding title or status\n## line is replaced just before PS1 is shown.\n\n#bleopt prompt_xterm_title=\n#bleopt prompt_screen_title=\n#bleopt prompt_term_status=\n\n\n## The following settings control the status line.  \"prompt_status_line\"\n## specifies the content of the status line.  If its value is empty, the status\n## line is not shown.  \"prompt_status_align\" controls the position of the\n## content in the status line.  The face \"prompt_status_line\" specifies the\n## default graphic style of the status line.\n\n#bleopt prompt_status_line=\n#bleopt prompt_status_align=left\n#ble-face prompt_status_line='fg=231,bg=240'\n\n\n## \"prompt_eol_mark\" specifies the contents of the mark used to indicate the\n## command output is not ended with newlines. The value can contain ANSI escape\n## sequences.\n\n#bleopt prompt_eol_mark=$'\\e[94m[ble: EOF]\\e[m'\n\n\n## \"prompt_ruler\" specifies the ruler between the previous command and the\n## prompt (like powerlevel10k\n## \"POWERLEVEL9K_PROMPT_{ADD_NEWLINE,SHOW_RULER,RULER_*}\").  When the empty\n## value is specified, the ruler is disabled.  This is the default.  When the\n## value \"empty-line\" is specified, an empty line is inserted between the\n## command and the prompt.  When the other values are specified, the value is\n## interpreted as an ANSI sequences, and the result is repeated to fill a line.\n\n#bleopt prompt_ruler=            # no ruler (default)\n#bleopt prompt_ruler=empty-line  # empty line\n#bleopt prompt_ruler=$'\\e[94m-'  # blue line\n\n\n## \"prompt_command_changes_layout\" specifies whether the commands called from\n## the blehook PRECMD or the variable PROMPT_COMMAND output texts to the\n## terminal and changes the layout.  When a non-empty value is specified,\n## ble.sh resets the layout before running the hooks PRECMD and PROMPT_COMMAND\n## and restores the layout after running the hooks.  When a empty value is\n## specified, ble.sh assumes that these hooks do not output texts to the\n## terminal and do not changes the cursor positions and skip the special\n## treatment.\n\n#bleopt prompt_command_changes_layout=   # PRECMD/PROMPT_COMMAND not output\n#bleopt prompt_command_changes_layout=1  # PRECMD/PROMPT_COMMAND may output\n\n\n## \"exec_restore_pipestatus\" controls whether ble.sh restores PIPESTATUS of the\n## previous user command.  When this option is set to a non-empty value,\n## PIPESTATUS is restored.  This feature is turned off by default because it\n## adds extra execution costs.  Note that the values of PIPESTATUS of the\n## previous command are always available with the array BLE_PIPESTATUS\n## regardless of this setting.\n\n#bleopt exec_restore_pipestatus=1  # restores PIPESTATUS\n\n\n## \"edit_marker\" and \"edit_marker_error\" define the default styles of the\n## markers [ble: ...] used by ble.sh.  \"edit_marker\" is used for the normal\n## notifications, and \"edit_marker_error\" is used for the error information.\n## When they are set to an empty string, those markers are disabled (unless\n## additional information other than the markers needs to be output after the\n## markers).  Those default styles can be overridden by specific mark settings,\n## such as `exec_errexit_mark`, `exec_elapsed_mark`, and `exec_exit_mark`.\n\n#bleopt edit_marker=$'\\e[94m[ble: %s]\\e[m'\n#bleopt edit_marker_error=$'\\e[91m[ble: %s]\\e[m'\n\n\n## \"exec_errexit_mark\" specifies the format of the mark to show the exit status\n## of the command when it is non-zero.  If this setting is an empty string, the\n## exit status will not be shown.  The value can contain ANSI escape sequences.\n\n#bleopt exec_errexit_mark=$'\\e[91m[ble: exit %d]\\e[m'\n\n\n## \"exec_elapsed_mark\" specifies the format of the command execution time\n## report.  It takes two arguments: the first is the string that explains the\n## elapsed time, and the second is a number that represents the percentage of\n## CPU core usage.  \"exec_elapsed_enabled\" specifies the condition that the\n## command execution time report is displayed after the command execution.  The\n## condition is expressed by an arithmetic expression, where a non-zero result\n## causes displaying the report.  In the arithmetic expression, variables\n## \"real\", \"{usr,sys}{,_self,_child}\", and \"cpu\" can be used.  \"real\"\n## represents the elapsed time.  \"usr\" and \"sys\" represent the user and system\n## time, respectively.  The suffixes \"_self\" and \"_child\" represent the part\n## consumed in the main shell process and the other child processes including\n## subshells and external programs, respectively.  \"cpu\" represents the\n## percentage of the CPU core usage in integer, which can be calculated by\n## \"(usr+sys)*100/real\".  The other values are all in unit of milliseconds.\n\n#bleopt exec_elapsed_mark=$'\\e[94m[ble: elapsed %s (CPU %s%%)]\\e[m'\n#bleopt exec_elapsed_enabled='usr+sys>=10000'\n\n\n## \"exec_exit_mark\" specifies the marker printed when the bash session ends.\n## When an empty string is specified, the marker is disabled.\n\n#bleopt exec_exit_mark=$'\\e[94m[ble: exit]\\e[m'\n\n\n## The following setting controls the exit when jobs are remaining. When an\n## empty string is set, the shell will never exit with remaining jobs through\n## widgets. When an non-empty value is set, the shell will exit when exit is\n## attempted twice consecutively.\n\n#bleopt allow_exit_with_jobs=\n\n\n## The following setting controls the default cursor position after moving to\n## another history entry.  When \"preserve\" is specified, ble.sh tries to\n## preserve the cursor position before moving the history entry.  When \"begin\"\n## and \"end\" are specified, the cursor is placed at the beginning and end,\n## respectively, of the entry.  When \"near\" is specified, when we move to an\n## older (newer) history entry, the cursor is placed at the end (beginning) of\n## the text.  When \"far\" is specified, when we move to an older (newer) history\n## entry, the cursor is palced at the beginning (end) of the text.  When\n## \"beginning-of-{,graphical-,logical-}line\" is specified, the cursor is placed\n## at the beginning of the last (first) line when we move to an older (newer)\n## history entry.  When \"end-of-{,graphical-,logical-}line\" is specified, the\n## cursor is placed at the end of the last (first) line when we move to an\n## older (newer) history entry.  When \"preserve-{,graphical-,logical-}-column\"\n## is specified, te cursor is placed at the same column as before moving the\n## history entry.  When the versions without \"graphical\" or \"logical\" is used,\n## a logical or graphical line is used based on \"bleopt edit_line_type\".  The\n## default is \"end-of-line\".  When \"auto\" is specified, the behavior is \"end\"\n## by default, but it becomes similar to \"near\" when called by vi motion.\n\n#bleopt history_default_point=auto\n\n\n## The following setting controls the history sharing. If it has non-empty\n## value, the history sharing is enabled. With the history sharing, the command\n## history is shared with the other Bash ble.sh sessions with the history\n## sharing turned on.\n\n#bleopt history_share=\n\n\n## This option controls the target range in the command history for\n## \"erasedups\", which is performed when it is specified in \"HISTCONTROL\".  When\n## this option has an empty value, the target range is the entire history as in\n## the plain Bash.  When this option evaluates to a positive integer \"count\",\n## the target range is the last \"n\" entries in the command history.  When this\n## option evaluates to a non-positive integer \"offset\", \"offset\" specifies the\n## beginning of the target range relative to the history count at the session\n## start.  The end of the target range is always the end of the command\n## history.\n\n#bleopt history_erasedups_limit=       # entire history\n#bleopt history_erasedups_limit=0      # only new items added in this session\n#bleopt history_erasedups_limit=-1000  # new items and 1000 prev-session items\n#bleopt history_erasedups_limit=1000   # last 1000 items\n\n\n## The following setting controls the behavior of the widget\n## \"accept-single-line-or-newline\" in the single-line editing mode. The value\n## is a subject of arithmetic evaluation. When it evaluates to negative\n## integers, the line is always accepted. When it evaluates to 0, it enters the\n## multiline editing mode when there is any unprocessed user inputs, or\n## otherwise the line is accepted. When it evaluates to a positive integer \"n\",\n## it enters the multiline editing mode when there is more than \"n\"unprocessed\n## user inputs.\n\n#bleopt accept_line_threshold=5\n\n\n## The following option controls the behavior when the number of characters\n## exceeds the capacity specified by `line_limit_length`.  The value `none`\n## means that the number of characters will not be checked.  The value\n## `discard` means that the characters cannot be inserted when the number of\n## characters exceeds the capacity.  The value `truncate` means that the\n## command line is truncated from its end to fit into the capacity.  The value\n## `editor` means that the widget `edit-and-execute` will be invoked to open an\n## editor to edit the command line contents.  When the value `editor` is\n## specified, `bleopt history_limit_length` is recommended to be less than or\n## equal to `bleopt line_limit_length`.  Otherwise, the text editor may be\n## unexpectedly executed in navigating through the history.\n\n#bleopt line_limit_type=none\n\n\n## The following option specifies the capacity of the command line in the\n## number of characters.  The number 0 or negative numbers means the unlimited\n## capacity.\n\n#bleopt line_limit_length=10000\n\n\n## The following option specifies the maximal number of characters which can be\n## appended into the history.  When this option has a positive value, commands\n## with the length longer than the value is not appended to the history.  When\n## this option has a non-positive value, commands are always appended to the\n## history regardless of their length.\n\n#bleopt history_limit_length=10000\n\n\n##-----------------------------------------------------------------------------\n## Terminal state control\n\n\n## When the follwoing setting is set to a non-empty value, ble.sh saves the TTY\n## state at the end of the command executation and restores it before the next\n## command execution.  This adds a slight overload of running an extra call of\n## stty.  If this is enabled, when a command breaks the TTY state, the effect\n## remains in later commands.\n\n#bleopt term_stty_restore=1\n\n\n## The following setting specifies the cursor type when commands are executed.\n## The cursor type is specified by the argument of the control function\n## DECSCUSR.\n\n#bleopt term_cursor_external=0\n\n\n## The following settings, external and internal, specify the \"modifyOtherKeys\"\n## states [the control function SM(>4)] when commands are executed and when\n## ble.sh has control, respectively.\n\n#bleopt term_modifyOtherKeys_external=auto\n#bleopt term_modifyOtherKeys_internal=auto\n\n\n## The following setting controls whether the kitty-keyboard-protocol sequences\n## should pass-through the terminal multiplexers when the outermost terminal is\n## kitty.  When this option has a non-empty string, the pass-through kitty\n## protocol sequences are enabled.\n##\n## * This is intended to be used with tmux-3.4+.  This works with tmux-3.3a and\n##   below as far as the user does not enable CapsLock or NumLock.  Note that\n##   this might cause problems of keyboard inputs after detaching from tmux;\n##   You might lose the control of the terminal applications that do not\n##   support extended keys outside the terminal multiplexers.\n##\n## * This will cause the same problems when used with multiple windows in GNU\n##   screen.  You will lose the control of the terminal applications without\n##   the support for extended keys when there are more than one ble.sh session\n##   or when there is at least one foreground ble.sh session in GNU screen.\n\n#bleopt term_modifyOtherKeys_passthrough_kitty_protocol=1\n\n##-----------------------------------------------------------------------------\n## Rendering options\n\n\n## \"tab_width\" specifies the width of TAB on the command line. When an empty\n## value is specified, the width in terminfo (tput it) is used.\n\n#bleopt tab_width=\n\n\n## \"char_width_mode\" specifies the width of East_Asian_Width=A characters.\n## When the value \"east\" is specified, the width is 2. When the value \"west\" is\n## specified, the width is 1.  When the value \"emacs\" is specified, the width\n## table (depending on characters) used in Emacs is used.  When the value\n## \"musl\" is specified, the table for \"wcwidth\" of the musl C library in 2014\n## is used [Note: recent versions of musl library is more conforming to Unicode\n## so favor \"west\" or \"east\"].  When \"auto\" is specified, the character width\n## mode is automatically selected based on interactions with the terminal.\n\n#bleopt char_width_mode=auto\n\n\n## \"char_width_version\" specifies the Unicode version that char width\n## determination bases on.  When \"auto\" is specified, ble.sh automatically\n## tests the behavior of the terminal on startup and try to determine the\n## appropriate version.  Supported versions are \"4.1\", \"5.0\", \"5.2\", \"6.0\",\n## \"6.1\", \"6.2\", \"6.3\", \"7.0\", \"8.0\", \"9.0\", \"10.0\", \"11.0\", \"12.0\", \"12.1\",\n## \"13.0\", \"14.0\", \"15.0\", and \"15.1\".  The default value is \"auto\".\n\n#bleopt char_width_version=auto\n\n\n## \"emoji_width\" specifies the width of emoji characters.  If an empty value is\n## specified, special treatment of emoji is disabled.\n\n#bleopt emoji_width=2\n\n\n## \"emoji_version\" specifies the version of Unicode Emoji.  Available values\n## are 0.6, 0.7, 1.0, 2.0, 3.0, 4.0, 5.0, 11.0, 12.0, 12.1, 13.0, 13.1, 14.0,\n## 15.0, and 15.1.\n\n#bleopt emoji_version=13.1\n\n\n## \"emoji_opts\" is a colon-separated list that represents the terminal\n## capability for emojis.  When \"tpvs\" and \"epvs\" are specified, TPVS and EPVS\n## (text/emoji presentation variation selectors), respectively, can be used to\n## change he representation of emoji characters.  When \"zwj\" is specified, the\n## emoji ZWJ sequences are supported.  When \"ri\" is specified, the flag emojis\n## formed by two Regional_Indicators are supported.  When \"unqualified\" is\n## specified, unqualified emojis are treated as emojis as well as the qualified\n## emojis.\n\n#bleopt emoji_opts=ri\n\n\n## This option specifies the type of the supported grapheme cluster of the\n## terminal.  The empty string indicates that the terminal does not support the\n## grapheme clusters.  The values \"extended\" and \"legacy\" indicate that the\n## terminal supports the extended and legacy grapheme clusters, respectively.\n\n#bleopt grapheme_cluster=extended\n\n\n## This option controls the behavior when ble.sh receives SIGWINCH.\n## * When the value \"redraw-safe\" is specified, ble.sh redraws the new prompt\n##   starting from the line of the current cursor position.\n## * When the value \"redraw-prev\" is specified, ble.sh tries to go to the\n##   beginning of the current prompt and overwrite the current one.  This is\n##   similar to the behavior of GNU Readline.  This possibly erase the output\n##   of the previous command because ble.sh tries to go to the beginning of the\n##   current prompt assuming that the number of lines in the prompt does not\n##   change by the terminal resizing.\n## * When the value \"redraw-here\" is specified, ble.sh tries to determine the\n##   number of lines that can be safely erased and go to the beginning of the\n##   safe lines before the redraw.  This is the default behavior.  In\n##   principle, this can also erase the previous outputs, but it would be\n##   supposed to be rarely happen as far as the text reflowing of the terminal\n##   behaves in a reasonable way.\n## * When the value \"clear\" is specified, the terminal content is erased and\n##   the new prompt will be drawn at the top of the terminal.  The previous\n##   terminal contents including the command outputs will be lost.\n\n#bleopt canvas_winch_action=redraw-here\n\n##-----------------------------------------------------------------------------\n## User input settings\n\n## The following setting sets the default keymap. The value \"emacs\" specifies\n## that the emacs keymap should be used. The value \"vi\" specifies that the vi\n## keymap (insert mode) should be used as the default. The value \"auto\"\n## specifies that the keymap should be automatically selected from \"emacs\" or\n## \"vi\" according to the current readline state \"set -o emacs\" or \"set -o vi\".\n\n#bleopt default_keymap=auto\n\n\n## The following setting controls the treatment of isolated ESCs.  The value\n## \"esc\" indicates that it should be treated as ESC.  The value \"meta\"\n## indicates that it should be treated as Meta modifier.  The value \"auto\"\n## indicates that the behavior will be switched to an appropriate side of \"esc\"\n## or \"meta\" depending on the current keymap.\n\n#bleopt decode_isolated_esc=esc\n\n\n## The following setting specifies the byte code used to abort the currently\n## processed inputs. The default value 28 corresponds to \"C-\\\".\n\n#bleopt decode_abort_char=28\n\n\n## The following settings sets up the behavior for errors while user input\n## decoding. \"error_char\" is the decoding error for the current character\n## encoding. \"error_cseq\" indicates the unrecognized CSI sequences.\n## \"error_kseq\" indicates the unbound key sequences. \"abell\" and \"vbell\" turn\n## on/off the audible bells and visible bells on errors. If the variable is\n## empty the bells are turned off, or otherwise turned on. \"discard\" controls\n## if the chars/sequences will be discarded or processed in later stage. If a\n## non-empty value is given, chars/sequences are discarded.\n\n#bleopt decode_error_char_abell=\n#bleopt decode_error_char_vbell=1\n#bleopt decode_error_char_discard=\n#bleopt decode_error_cseq_abell=\n#bleopt decode_error_cseq_vbell=1\n#bleopt decode_error_cseq_discard=1\n#bleopt decode_error_kseq_abell=1\n#bleopt decode_error_kseq_vbell=1\n#bleopt decode_error_kseq_discard=1\n\n\n## This variable sets the limit to the count of recursive calls of keyboard\n## macros.\n\n#bleopt decode_macro_limit=1024\n\n\n## When a non-empty value is specified to this settings, the terminal's\n## Bracketed Paste Mode (DEC mode 2004) is enabled.  This setting is\n## synchronized with the readline variable \"enable-bracketed-paste\".\n\n#bleopt term_bracketed_paste_mode=on\n\n##-----------------------------------------------------------------------------\n## Settings for completion\n\n\n## The following settings turn on/off the corresponding functionalities. When\n## non-empty strings are set, the functionality is enabled. Otherwise, the\n## functionality is inactive.\n\n#bleopt complete_auto_complete=1\n#bleopt complete_menu_complete=1\n#bleopt complete_menu_filter=1\n\n\n## If \"complete_ambiguous\" has non-empty values, ambiguous completion\n## candidates are generated for completion.\n\n#bleopt complete_ambiguous=1\n\n\n## If \"complete_contract_function_names\" has non-empty values, the function\n## name candidates are grouped by prefixes of the directory-like form \"*/\".\n\n#bleopt complete_contract_function_names=1\n\n\n## By default, ble.sh does not allow rewriting the existing text if non-unique\n## candidates does not contain the existing text.  If this setting has\n## non-empty values, ble.sh rewrites the existing text.\n\n#bleopt complete_allow_reduction=1\n\n\n## This option specifies the threshold to simplify the quotation type of the\n## inserted word.  This option is evaluated as an arithmetic expression.  When\n## this option evaluates to a negative value, the simplification of the\n## quotation is disabled.  Otherwise, when the number of characters will be\n## reduced by at least the specified value, the quotation is simplified.  The\n## default is 0, which means that the quotation is simplified unless the number\n## of characters increases by the simplification.\n\n#bleopt complete_requote_threshold=0\n\n\n## If \"complete_auto_history\" has non-empty values, auto-complete searches\n## matching command lines from history.\n\n#bleopt complete_auto_history=1\n\n\n## The following setting controls the delay of auto-complete after the last\n## user input. The unit is millisecond.\n\n#bleopt complete_auto_delay=100\n\n\n## The face \"auto_complete\" can be used to specify the graphic style of the\n## suggestion by auto-complete.  The default style is choosed just to make it\n## work in both the terminals with light and dark backgrounds.  A better style\n## can be specified based on the user's preference.\n\n#ble-face auto_complete='fg=238,bg=254'           # default\n#ble-face auto_complete='fg=231,bg=69'            # blue background\n#ble-face auto_complete='fg=240,underline,italic' # darker background\n\n\n## The setting \"complete_auto_wordbreaks\" is used as the delimiters for\n## identifying words for M-right (auto-complete/insert-word).  The default\n## value is $' \\t\\n'.  If the empty value is set, the default value is used.\n\n#bleopt complete_auto_wordbreaks=$' \\t\\n/'\n\n\n## The setting \"complete_auto_complete_opts\" is a colon-separated list of\n## options:\n##\n## - The option \"suppress-after-complete\" controls whether auto-complete is\n##   enabled after TAB completions.  If \"suppress-after-complete\" is included,\n##   auto-complete is enabled after TAB completions.  Otherwise, auto-complete\n##   is disabled after TAB completions.\n\n#bleopt complete_auto_complete_opts=suppress-after-complete\n\n\n## The faces \"menu_filter_fixed\" and \"menu_filter_input\" can be used to specify\n## the graphic styles of the part of the text that is used to filter the menu\n## items by the menu-filter feature.\n\n#ble-face menu_filter_fixed='bold'\n#ble-face menu_filter_input='fg=16,bg=229'\n\n\n## The setting \"complete_auto_menu\" controls the delay of \"auto-menu\".  When a\n## non-empty string is set, auto-menu is enabled.  The string is evaluated as\n## an arithmetic expression to give the delay in milliseconds.  ble.sh will\n## automatically show the menu of completions after the idle time (for which\n## user input does not arrive) reaches the delay.\n\n#bleopt complete_auto_menu=500\n\n\n## When there are user inputs while generating completion candidates, the\n## candidates generation will be canceled to process the user inputs. The\n## following setting controls the interval of checking user inputs while\n## generating completion candidates.\n\n#bleopt complete_polling_cycle=50\n\n\n## A hint on the maximum acceptable size of any data structure generated during\n## the completion process, beyond which the completion may be prematurely\n## aborted to avoid excessive processing time.  \"complete_limit\" is used for\n## TAB completion.  When its value is empty, the size checks are disabled.\n## \"complete_limit_auto\" is used for auto-completion.  When its value is empty,\n## the setting \"complete_limit\" is used instead. \"complete_limit_auto_menu\" is\n## used for auto-menu.\n\n#bleopt complete_limit=500\n#bleopt complete_limit_auto=200\n#bleopt complete_limit_auto_menu=100\n\n\n## The following setting controls the timeout for the pathname expansions\n## performed in auto-complete.  When the word contains a glob pattern that\n## takes a long time to evaluate the pathname expansion, auto-complete based on\n## the filename is canceled based on the timeout setting.  The value specifies\n## the timeout duration in milliseconds.  When the value is empty, the\n## timeout is disabled.\n\n#bleopt complete_timeout_auto=5000\n\n\n## The following setting controls the timeout for the pathname expansions to\n## prepare COMP_WORDS and COMP_LINE for progcomp.  When the word contains a\n## glob pattern that takes a long time to evaluate, the pathname expansion is\n## canceled, and a noglob expansion is used to construct COMP_WORDS and\n## COMP_LINE.  The value specifies ## the timeout duration in milliseconds.\n## When the value is empty, the timeout is disabled.\n\n#bleopt complete_timeout_compvar=200\n\n\n## The following setting specifies the style of the menu to show completion\n## candidates. The value \"dense\" and \"dense-nowrap\" shows candidates separated\n## by spaces. \"dense-nowrap\" is different from \"dense\" in the behavior that it\n## inserts a new line before the candidates that does not fit into the\n## remaining part of the current line. The value \"align\" and \"align-nowrap\"\n## aligns the candidates. The value \"linewise\" shows a candidate per line.  The\n## value \"desc\" and \"desc-text\" shows a candidate per line with description for\n## each. \"desc-text\" is different from \"desc\" in the behavior that it does not\n## interprets ANSI escape sequences in the descriptions.\n\n#bleopt complete_menu_style=align-nowrap\n\n\n## When a non-empty value is specified to this setting, the matching text on\n## the right of the cursor is removed on the insertion of the completion.  This\n## setting is synchronized with the readline variable \"skip-completed-text\".\n\n#bleopt complete_skip_matched=on\n\n\n## The following setting controls the detailed behavior of menu-complete with a\n## colon-separated list of options.  When the option \"insert-selection\" is\n## specified, the currently selected menu item is temporarily inserted in the\n## command line.  When \"hidden\" is specified, \"insert-selection\" is enabled,\n## and additionally, the completion menu is hidden by default.  The default is\n## \"insert-selection\".\n\n#bleopt complete_menu_complete_opts=insert-selection\n\n\n## When a non-empty value is specified to this setting, the highlighting of the\n## menu items is enabled.  This setting is synchronized with the readline\n## variable \"colored-stats\".\n\n#bleopt complete_menu_color=on\n\n\n## When a non-empty value is specified to this setting, the part of the menu\n## items matching with the already input text is highlighted.  This setting is\n## synchronized with the readline variable \"colored-completion-prefix\".\n\n#bleopt complete_menu_color_match=on\n\n\n## The following settings specify the maximal and minimal align widths for\n## complete_menu_style=\"align\" and \"align-nowrap\".\n\n#bleopt menu_align_min=4\n#bleopt menu_align_max=20\n\n\n## The following setting specifies the maximal height of the menu.  When this\n## value is evaluated to be a positive integer, the maximal line number of the\n## menu is limited to that value.\n\n#bleopt complete_menu_maxlines=10\n\n\n## The following settings specify the prefix of the menu items.  \"menu_prefix\"\n## specifies the default prefix for any menu-style.\n## \"menu_{align,desc,linewise,dense}_prefix\" specify the prefixes in the\n## respective menu-styles.  The value is specified by a printf format, where\n## the first argument is the index of the candidate.  ANSI escape sequences can\n## also be used.  For example, the candidate index can be shown by setting the\n## value '%d '.  The default value is empty.\n\n#bleopt menu_align=\n#bleopt menu_align_prefix='\\e[1m%d:\\e[m '\n#bleopt menu_desc_prefix='\\e[1m%d.\\e[m '\n#bleopt menu_linewise_prefix='\\e[1;36m%d:\\e[m '\n#bleopt menu_dense_prefix='\\e[1;32m>\\e[m '\n\n\n## The following setting specifies the minimum column width for the multicolumn\n## description for `complete_menu_style=desc'.  When the empty value is\n## specified, the multicolumn mode is disabled.\n\n#bleopt menu_desc_multicolumn_width=65\n\n\n## These faces specifies additional graphic styles used to highlight completion\n## candidates.  Face \"menu_complete_match\" specifies the additional style for\n## the candidate parts matching the filtering text.  Face\n## \"menu_complete_selected\" specifies the additional style for the selected\n## candidate.\n\n#ble-face menu_complete_match=bold\n#ble-face menu_complete_selected=reverse\n\n\n## These faces control graphic styles used in the menu descriptions.  Face\n## \"menu_desc_default\" is used as a default highlighting of the description.\n## Face \"menu_desc_type\" is used for the prefix string \"(type) \" to indicate\n## the type of the menu item.  Face \"menu_desc_quote\" is used to quote strings\n## embedded in the descriptions.\n\n#ble-face menu_desc_default=none\n#ble-face menu_desc_type=ref:syntax_delimiter\n#ble-face menu_desc_quote=ref:syntax_quoted\n\n\n## When this Readline setting is enabled, the cases of alphabets are ignored on\n## completion generation.\n\n#bind 'set completion-ignore-case off'\n\n\n## When this Readline setting is turned on, suffixes are added to the filename\n## completions in the menu.  The characters \"@\", \"/\" and \"*\" are added to\n## symbolic links, directories and executables, respectively.\n\n#bind 'set visible-stats off'\n\n\n## When this Readline setting is turned on, the suffix \"/\" is inserted after\n## the insertion of directory names.\n\n#bind 'set mark-directories on'\n\n\n## When this Readline setting is turned on, the suffix \"/\" is inserted after\n## symbolic links pointing to directories.\n\n#bind 'set mark-symlinked-directories on'\n\n\n## When this Readline setting is turned on, the filenames starting with \".\" is\n## also generated as possible completions.\n\n#bind 'set match-hidden-files on'\n\n\n## By default, when filenames of the form \"dir/file*\" is shown in the menu, the\n## part of the directory name \"dir/\" is omitted.  When this Readline setting is\n## turned on, the directory name of filename completions are not omitted.\n\n#bind 'set menu-complete-display-prefix off'\n\n\n## This option specifies a colon-separated list of glob patterns of sabbrev\n## names ignored in generating the sabbrev completion candidates.\n\n#bleopt complete_source_sabbrev_ignore=\n\n\n## This is a colon-separated list of options.  When the field\n## `no-empty-completion` is specified, the sabbrev completion candidates are\n## not generated when the word to complete is empty.\n\n#bleopt complete_source_sabbrev_opts=no-empty-completion\n\n##-----------------------------------------------------------------------------\n## Color settings\n\n## The setting \"term_index_colors\" specifies the number of index colors used to\n## specify colors in the terminal.  The value \"auto\" means that the use of\n## index colors are determined based on the terminfo database and the value of\n## TERM shell variable.  Otherwise, the value is evaluated as an arithmetic\n## expression.  When it is evaluated to 256, the index colors are assumed to be\n## xterm 256-color palette (16 basic + 6x6x6 color cube + 24 gray scale).  When\n## it is evaluated to 88, the index colors are assumed to be xterm 88-color\n## palette (16 basic + 4x4x4 color cube + 8 gray scale).  When it is evaluated\n## to 0, ble.sh will never use the index colors to set colors.  When it is\n## evaluated to other integers, the value specifies the maximum available\n## index.\n\n#bleopt term_index_colors=256\n\n\n## The setting \"term_true_colors\" specifies the format of 24-bit color escape\n## sequences supported by your terminal.  The value \"semicolon\" indicates the\n## format \"CSI 3 8 ; 2 ; R ; G ; B m\".  The value \"colon\" indicates the format\n## \"CSI 3 8 : 2 : R : G : B m\".  The other value implies that the terminal does\n## not support 24-bit color sequences.  In this case, ble.sh tries to output\n## indexed color sequences or basic color sequences with properly reduced\n## colors.\n\n#bleopt term_true_colors=semicolon\n\n\n## The setting \"filename_ls_colors\" can be used to import the filename coloring\n## scheme by the environment variable LS_COLORS.\n\n#bleopt filename_ls_colors=\"$LS_COLORS\"\n\n\n## The following settings enable or disable the syntax highlighting.  When the\n## setting \"highlight_syntax\" has a non-empty value, the syntax highlighting is\n## enabled.  When the setting \"highlight_filename\" has a non-empty value, the\n## highlighting based on the filename and the command name is enabled during\n## the process of the syntax highlighting.  Similarly, when the setting\n## \"highlight_variable\" has a non-empty value, the highlighting based on the\n## variable type is enabled.  All of these settings have non-empty values by\n## default.\n\n#bleopt highlight_syntax=\n#bleopt highlight_filename=\n#bleopt highlight_variable=\n\n\n## The following settings control the timeout and user-input cancellation of\n## the pathname expansions performed in the syntax highlighting.  When the word\n## contains a glob pattern that takes a long time to evaluate the pathname\n## expansion, the syntax highlighting based on the filename is canceled based\n## on the timeouts specified by these settings.  \"highlight_timeout_sync\" /\n## \"highlight_timeout_async\" specify the timeout durations in milliseconds to\n## be used for the foreground / background syntax highlighting, respectively.\n## When the timeout occurred in the foreground, the syntax highlighting will be\n## deferred to the background syntax highlighting.  When the timeout occurred\n## in the background, the syntax highlighting for the filename is canceled.\n## When the value is empty, the corresponding timeout is disabled.\n## \"syntax_eval_polling_interval\" specifies the maximal interval between the\n## user-input checking.\n\n#bleopt highlight_timeout_sync=500\n#bleopt highlight_timeout_async=5000\n#bleopt syntax_eval_polling_interval=50\n\n\n## The following setting limits the number of expanded words to process in\n## highlighting a single grammatical word.  When this setting is set to an\n## empty string, the number of expanded words to process is unlimited.\n\n#bleopt highlight_eval_word_limit=200\n\n\n## If set to a non-empty value, the setting \"color_scheme\" specifies a preset\n## graphic styles for basic faces.  The supported schemes are found in the\n## subdirectory \"contrib/scheme\".  The default value is \"default\".\n\n#bleopt color_scheme=base16\n\n\n## The following settings specify graphic styles of corresponding faces.  Faces\n## used for specific features are described in the respective sections.\n\n#ble-face -s region                    fg=231,bg=60\n#ble-face -s region_insert             fg=27,bg=254\n#ble-face -s region_match              fg=231,bg=55\n#ble-face -s region_target             fg=black,bg=153\n#ble-face -s disabled                  fg=242\n#ble-face -s overwrite_mode            fg=black,bg=51\n\n#ble-face -s syntax_default            none\n#ble-face -s syntax_command            fg=brown\n#ble-face -s syntax_quoted             fg=green\n#ble-face -s syntax_quotation          fg=green,bold\n#ble-face -s syntax_escape             fg=magenta\n#ble-face -s syntax_expr               fg=63\n#ble-face -s syntax_error              bg=203,fg=231\n#ble-face -s syntax_varname            fg=202\n#ble-face -s syntax_delimiter          bold\n#ble-face -s syntax_param_expansion    fg=133\n#ble-face -s syntax_history_expansion  bg=94,fg=231\n#ble-face -s syntax_function_name      fg=99,bold\n#ble-face -s syntax_comment            fg=gray\n#ble-face -s syntax_glob               fg=198,bold\n#ble-face -s syntax_brace              fg=37,bold\n#ble-face -s syntax_tilde              fg=63,bold\n#ble-face -s syntax_document           fg=100\n#ble-face -s syntax_document_begin     fg=100,bold\n#ble-face -s command_builtin_dot       fg=red,bold\n#ble-face -s command_builtin           fg=red\n#ble-face -s command_alias             fg=teal\n#ble-face -s command_function          fg=99 # fg=133\n#ble-face -s command_file              fg=green\n#ble-face -s command_keyword           fg=blue\n#ble-face -s command_jobs              fg=red,bold\n#ble-face -s command_directory         fg=63,underline\n#ble-face -s command_suffix            fg=231,bg=28\n#ble-face -s command_suffix_new        fg=231,bg=124\n#ble-face -s argument_option           fg=teal\n#ble-face -s argument_option           fg=black,bg=225\n#ble-face -s filename_directory        underline,fg=33\n#ble-face -s filename_directory_sticky underline,fg=231,bg=26\n#ble-face -s filename_link             underline,fg=teal\n#ble-face -s filename_orphan           underline,fg=16,bg=224\n#ble-face -s filename_setuid           underline,fg=black,bg=220\n#ble-face -s filename_setgid           underline,fg=black,bg=191\n#ble-face -s filename_executable       underline,fg=green\n#ble-face -s filename_other            underline\n#ble-face -s filename_socket           underline,fg=cyan,bg=black\n#ble-face -s filename_pipe             underline,fg=lime,bg=black\n#ble-face -s filename_character        underline,fg=231,bg=black\n#ble-face -s filename_block            underline,fg=yellow,bg=black\n#ble-face -s filename_warning          underline,fg=red\n#ble-face -s filename_url              underline,fg=blue\n#ble-face -s filename_ls_colors        underline\n#ble-face -s varname_array             fg=orange,bold\n#ble-face -s varname_empty             fg=31\n#ble-face -s varname_export            fg=200,bold\n#ble-face -s varname_expr              fg=99,bold\n#ble-face -s varname_hash              fg=70,bold\n#ble-face -s varname_new               fg=34\n#ble-face -s varname_number            fg=64\n#ble-face -s varname_readonly          fg=200\n#ble-face -s varname_transform         fg=29,bold\n#ble-face -s varname_unset             fg=245\n\n#ble-face -s cmdinfo_cd_cdpath         fg=26,bg=155\n\n##-----------------------------------------------------------------------------\n## Keybindings\n\n\n## The default mapping of <SP> in ble.sh is magic-space which performs history\n## and sabbrev expansion before inserting a space.  If you want to insert just\n## a space without expansions as Bash's default, use the following setting:\n\n#ble-bind -f 'SP' 'self-insert'\n\n\n## The default mapping of `/' (<slash>) in ble.sh is magic-slash which performs\n## sabbrev expansions of the name ` ~*'.  If you want to insert just a slash\n## without expansions as Bash's default, use the following setting:\n\n#ble-bind -f '/' 'self-insert'\n\n\n## If you want to search the already input string using <up> and <down> keys,\n## use the following setting:\n\n#ble-bind -f up 'history-search-backward'\n#ble-bind -f down 'history-search-forward'\n\n\n## If you want to immediately run the matched command by RET, you can specify\n## the option \"immediate-accept\" to nsearch widgets:\n\n#ble-bind -f up 'history-search-backward immediate-accept'\n#ble-bind -f down 'history-search-forward immediate-accept'\n\n\n## If you want to kill/copy words including the spaces preceding them, you can\n## use the following keybindings:\n\n#ble-bind -f C-w 'kill-region-or kill-uword'\n#ble-bind -f M-w 'copy-region-or copy-uword'\n\n\n## The following keybindings can be used to execute the command by RET even in\n## the multiline mode.\n\n# # For emacs editing mode\n# ble-bind -m emacs -f 'C-m' 'accept-line'\n# ble-bind -m emacs -f 'RET' 'accept-line'\n\n# # For vim editing mode\n# ble-bind -m vi_imap -f 'C-m' 'accept-line'\n# ble-bind -m vi_imap -f 'RET' 'accept-line'\n# ble-bind -m vi_nmap -f 'C-m' 'accept-line'\n# ble-bind -m vi_nmap -f 'RET' 'accept-line'\n\n\n## If you want to accept the suggestion by auto-complete using TAB, please use\n## the following keybindings.  By default, <right> key can be used to accept\n## the suggestion, and <TAB> is assigned to the normal TAB completion which is\n## independent of auto-complete.\n\n# ble-bind -m auto_complete -f C-i auto_complete/insert\n# ble-bind -m auto_complete -f TAB auto_complete/insert\n\n##-----------------------------------------------------------------------------\n## Settings for Emacs mode\n\nfunction blerc/emacs-load-hook {\n  #----------------------------------------------------------------------------\n  # Settings for the mode indicator\n\n  ## The following option specifies the content of the mode indicator shown in\n  ## the info line as a prompt sequence.\n\n  #bleopt prompt_emacs_mode_indicator='\\q{keymap:emacs/mode-indicator}'\n\n\n  ## The following option specifies the multiline mode name used in the prompt\n  ## sequence \\q{keymap:emacs/mode-indicator} in the multiline editing mode.\n\n  # default\n  #bleopt keymap_emacs_mode_string_multiline=$'\\e[1m-- MULTILINE --\\e[m'\n  # do not show the mode name\n  #bleopt keymap_emacs_mode_string_multiline=\n\n  #----------------------------------------------------------------------------\n  # Keybindings\n\n  ## The default mapping of RET and C-m inserts newline with multiline commands\n  ## or incomplete commands.  With the following setting, RET and C-m always\n  ## causes the execution of the command even in the multiline mode or when the\n  ## command is not syntactically completed.\n\n  #ble-bind -f 'C-m' accept-line\n  #ble-bind -f 'RET' accept-line\n\n\n  ## With the following settings, M-backspace (whose actual key sequence\n  ## depends on your terminal) will kill the backward word as in the default\n  ## readline.\n\n  #ble-bind -f 'M-C-?' kill-backward-cword\n  #ble-bind -f 'M-DEL' kill-backward-cword\n  #ble-bind -f 'M-C-h' kill-backward-cword\n  #ble-bind -f 'M-BS'  kill-backward-cword\n\n  return 0\n}\nblehook/eval-after-load keymap_emacs blerc/emacs-load-hook\n\n##-----------------------------------------------------------------------------\n## Settings for Vim mode\n\nfunction blerc/vim-load-hook {\n  ((_ble_bash>=40300)) && builtin bind 'set keyseq-timeout 1'\n\n  #----------------------------------------------------------------------------\n  # Settings for the mode indicator\n\n  ## The following option specifies the content of the mode indicator shown in\n  ## the info line as a prompt sequence.\n\n  #bleopt prompt_vi_mode_indicator='\\q{keymap:vi/mode-indicator}'\n\n\n  ## The following option controls whether the prompt sequence\n  ## \\q{keymap:vi/mode-indicator} is activated.  When this option has a\n  ## non-empty value, \\q{keymap:vi/mode-indicator} is expanded to the mode\n  ## indicator. Otherwise, \\q{keymap:vi/mode-indicator} is expanded to the\n  ## empty string.\n\n  #bleopt keymap_vi_mode_show=1\n\n\n  ## The following options specify the name of modes in\n  ## \\q{keymap:vi/mode-indicator}.\n\n  #bleopt keymap_vi_mode_name_insert=INSERT\n  #bleopt keymap_vi_mode_name_replace=REPLACE\n  #bleopt keymap_vi_mode_name_vreplace=VREPLACE\n  #bleopt keymap_vi_mode_name_visual=VISUAL\n  #bleopt keymap_vi_mode_name_select=SELECT\n  #bleopt keymap_vi_mode_name_linewise=LINE\n  #bleopt keymap_vi_mode_name_blockwise=BLOCK\n\n\n  ## This option specifies the result of \\q{keymap:vi/mode-indicator} in the\n  ## normal mode.  For example, if you want to show an explicit name of the\n  ## normal mode like in other modes, please use the following setting:\n\n  #bleopt keymap_vi_mode_string_nmap:=$'\\e[1m-- NORMAL --\\e[m'\n\n\n  ## This option specifies that all the prompts should be recalculated on the\n  ## mode change.  When this option has a non-empty value, the prompt will be\n  ## recalculated.\n\n  #bleopt keymap_vi_mode_update_prompt=\n\n  #----------------------------------------------------------------------------\n  # Keybindings\n\n  ## The following setting sets up the keymap settings with Meta modifiers.\n  ## With this setting, M-RET can be used to insert a newline in the\n  ## commandline.\n\n  #ble-decode/keymap:vi_imap/define-meta-bindings\n\n  ## In this case, C-RET can be optionally configured so that it forcibly\n  ## executes the command.\n\n  #ble-bind -m vi_imap -f 'C-RET' 'accept-line'\n\n  ## The default mapping of <M-backspace> (whose actual key sequence depends on\n  ## your terminal) copies the previous shell word in the kill ring.  Instead,\n  ## the following settings will kill the backward word as in the default\n  ## readline.\n\n  #ble-bind -m vi_imap -f 'M-C-?' kill-backward-cword\n  #ble-bind -m vi_imap -f 'M-DEL' kill-backward-cword\n  #ble-bind -m vi_imap -f 'M-C-h' kill-backward-cword\n  #ble-bind -m vi_imap -f 'M-BS'  kill-backward-cword\n\n\n  ## The default mapping of RET and C-m in the insert mode inserts newline with\n  ## multiline commands or incomplete commands.  They moves the cursor position\n  ## to the next line in the normal mode.  Instead, with the following setting,\n  ## RET and C-m always causes the execution of the command even in the\n  ## multiline mode or when the command is not syntactically completed.\n\n  #ble-bind -m vi_imap -f 'C-m' accept-line\n  #ble-bind -m vi_imap -f 'RET' accept-line\n  #ble-bind -m vi_nmap -f 'C-m' accept-line\n  #ble-bind -m vi_nmap -f 'RET' accept-line\n\n\n  ## The default mapping of C-o is vi_imap/single-command-mode.  If you want to\n  ## execute the current command line and load the next history entry with\n  ## <C-o>, use the following setting:\n\n  #ble-bind -m vi_imap -f 'C-o' 'accept-and-next'\n\n\n  ## The default mapping of C-k is kill-forward-line.  If you want to input\n  ## digraphs with <C-k>{char1}{char2}, use the following setting:\n\n  #ble-bind -m vi_imap -f 'C-k' 'vi_imap/insert-digraph'\n\n\n  ## The default mapping of C-c is vi_imap/normal-mode-without-insert-leave\n  ## (imap), vi-command/cancel (nmap).  If you instead want to discard the\n  ## current line and go to the next line, you can bind C-c to 'discard-line':\n\n  #ble-bind -m vi_imap -f 'C-c' discard-line\n  #ble-bind -m vi_nmap -f 'C-c' discard-line\n\n\n  ## The default mapping of 'g g' and G moves the current position in the\n  ## command history.  If you would like to move the cursor position in the\n  ## current command entry, you can overwrite the bindings as follows.\n\n  #ble-bind -m vi_nmap -f 'g g' vi-command/first-nol\n  #ble-bind -m vi_omap -f 'g g' vi-command/first-nol\n  #ble-bind -m vi_xmap -f 'g g' vi-command/first-nol\n  #ble-bind -m vi_nmap -f 'G' vi-command/last-line\n  #ble-bind -m vi_omap -f 'G' vi-command/last-line\n  #ble-bind -m vi_xmap -f 'G' vi-command/last-line\n\n\n  ## The default mapping of 'C-r' in the normal mode is \"vi_nmap/redo\".  If you\n  ## want to use the incremental search mode from Emacs in the Vim mode (as in\n  ## Readline), please use the following keybinding.\n\n  #ble-bind -m vi_nmap -f 'C-r' history-isearch-backward\n\n  #----------------------------------------------------------------------------\n  # Cursor shapes and other terminal settings\n\n  ## Cursor settings\n\n  #ble-bind -m vi_nmap --cursor 2\n  #ble-bind -m vi_imap --cursor 5\n  #ble-bind -m vi_omap --cursor 4\n  #ble-bind -m vi_xmap --cursor 2\n  #ble-bind -m vi_smap --cursor 2\n  #ble-bind -m vi_cmap --cursor 0\n\n  ## DECSCUSR setting\n  ##\n  ##   If you don't have the entry Ss in terminfo, yet your terminal supports\n  ##   DECSCUSR, please comment out the following line to enable DECSCUSR.\n  ##\n  #_ble_term_Ss=$'\\e[@1 q'\n\n  ## Control sequences that will be output on entering each mode\n  #bleopt term_vi_nmap=\n  #bleopt term_vi_imap=\n  #bleopt term_vi_omap=\n  #bleopt term_vi_xmap=\n  #bleopt term_vi_smap=\n  #bleopt term_vi_cmap=\n\n  #----------------------------------------------------------------------------\n  # Miscellaneous settings\n\n  ## This option controls the frequency of recording \"undo\".  When the value\n  ## \"more\" is specified, \"undo\" will be recorded for various operations in\n  ## \"vi_imap\".\n\n  #bleopt keymap_vi_imap_undo=\n\n\n  ## This option controls the behavior of motion in select mode.  The value is\n  ## a list of words separated by commas.  When the word \"stopsel\" is contained\n  ## in this option, ble.sh exits the select mode with a motion in select mode.\n\n  #bleopt keymap_vi_keymodel=\n\n\n  ## This option sets the upper limit of the maximal depth of recurrence of\n\n  ## replaying keyboard macros.\n  #bleopt keymap_vi_macro_depth=64\n\n\n  ## This option specifies the operator name when the user input \"g@\" in normal\n  ## mode.  The function \"ble/keymap:vi/operator:$value\", where \"$value\" is the\n  ## value of this setting, is used as the implementation of the operator.\n\n  #bleopt keymap_vi_operatorfunc=\n\n\n  ## When this option has a non-empty value, \"/\", \"?\", \"n\", \"N\" search the word\n  ## on the current position.  When this option has the empty value, these keys\n  ## follows the behavior of `vim`.\n\n  #bleopt keymap_vi_search_match_current=\n\n  #----------------------------------------------------------------------------\n  # plugins\n\n  ## vim-surround\n\n  #ble-import vim-surround\n  #bleopt vim_surround_45:=$'$( \\r )'\n  #bleopt vim_surround_61:=$'$(( \\r ))'\n\n  ## vim-arpeggio\n\n  #ble-import vim-arpeggio\n  #bleopt vim_arpeggio_timeoutlen=10\n  #ble/lib/vim-arpeggio.sh/bind -s jk 'hello'\n\n  ## vim-airline\n\n  #ble-import vim-airline\n  #bleopt vim_airline_theme=light\n  #bleopt vim_airline_section_a='\\e[1m\\q{lib/vim-airline/mode}'\n  #bleopt vim_airline_section_b='\\q{lib/vim-airline/gitstatus}'\n  #bleopt vim_airline_section_c='\\w'\n  #bleopt vim_airline_section_x='bash'\n  #bleopt vim_airline_section_y='$_ble_util_locale_encoding[unix]'\n  #bleopt vim_airline_section_z=' \\q{history-percentile} \\e[1m!\\q{history-index}/\\!\\e[22m \\q{position}'\n  #bleopt vim_airline_left_sep=$'\\uE0B0'\n  #bleopt vim_airline_left_alt_sep=$'\\uE0B1'\n  #bleopt vim_airline_right_sep=$'\\uE0B2'\n  #bleopt vim_airline_right_alt_sep=$'\\uE0B3'\n  #bleopt vim_airline_symbol_branch=$'\\uE0A0'\n  #bleopt vim_airline_symbol_dirty=$'\\u26A1'\n}\nblehook/eval-after-load keymap_vi blerc/vim-load-hook\n\n##-----------------------------------------------------------------------------\n## Internal settings\n\n\n## When the option \"connect_tty\" is set to a non-empty value, ble.sh in the\n## child interactive Bash processes tries to connect to /dev/tty for its user\n## interface when the initial standard streams of Bash are redirected to\n## non-TTY streams.  The standard streams for the user command executions are\n## kept to be the original ones.  This does not affect the behavior of the\n## current session.  If it is set to the value \"inherit\", ble.sh tries to\n## export the TTY for the child ble.sh sessions.  This might cause an issue in\n## non-closing terminal window when a background process starts in the session.\n## The default value is \"1\".\n\n#bleopt connect_tty=\n\n\n## This option sets the interval of checking new user inputs.  The value is\n## evaluated as an arithmetic expression.  On the evaluation, a shell variable\n## \"ble_util_idle_elapsed\" is provided for the time since the last user input\n## in millisecond.  This option is used for the polling for the background\n## execution when there is no user inputs.\n\n#bleopt idle_interval='ble_util_idle_elapsed>600000?500:(ble_util_idle_elapsed>60000?200:(ble_util_idle_elapsed>5000?100:20))'\n\n\n## This option specifies a colon-separated list of custom search paths of \"ble-import\".\n\n#bleopt import_path=\"${XDG_DATA_HOME:-$HOME/.local/share}/blesh/local\"\n\n\n## When a non-empty value is specified to this option, displays the internal\n## syntax analysis information and the syntax tree.  This is only effective in\n## devel versions.\n\n#bleopt syntax_debug=\n\n\n## When the option \"debug_xtrace\" contains a non-empty value, xtrace (set -x)\n## is enabled for the internal processing of ble.sh.  The value is used for the\n## xtrace output log filename. [ Caution: The file size of the log file can\n## soon grow up to hundred megabytes or to gigabytes. ]  The option\n## \"debug_xtrace_ps4\" specifies the value of PS4 for xtrace enabled by\n## \"debug_xtrace\".\n\n#bleopt debug_xtrace=~/blesh.xtrace\n#bleopt debug_xtrace_ps4='+ '\n\n\n## When the option \"debug_idle\" contains a non-empty value, the background\n## tasks currently running are shown in the info panel.\n\n#bleopt debug_idle=1\n\n\n## [The setting \"openat_base\" needs to be set before ble.sh is loaded or\n## specified in the source options.  Therefore the value should be assigned\n## directly to the shell variable \"bleopt_openat_base\" instead of using\n## \"bleopt\" command.]\n##\n## This setting \"openat_base\" specifies the starting number of the file\n## descriptors which ble.sh internally uses in Bash 4.0 or lower.  The value of\n## this setting is used as the number for the first file descriptor of internal\n## use, and the next value is used for the second file descriptor, and so on.\n## When you want to use the default value 30 and succeeding number 31, 32,\n## etc. for other purposes, please set to this settings another value which\n## does not conflict with file descriptors of other purposes.\n\n# echo \"usage: e.g. source out/ble.sh -o openat_base=30\"\n\n\n## This option specifies the context of the command execution.  The value\n## \"gexec\" specifies that the user command is evaluated in global contexts.\n## The value \"exec\" (ble-0.3 and before) specified that the user command is\n## evaluated in a function, but the support is removed in ble-0.4 because this\n## is only remained for a debugging purpose and not tested well.\n\n#bleopt internal_exec_type=gexec\n\n\n## If this option has a non-empty value, when the execution of a shell function\n## is interrupted by SIGINT, the processing of SIGINT by the DEBUG trap is\n## printed to stderr.  The default is empty.\n\n#bleopt internal_exec_int_trace=1\n\n\n## This option sets the message that Bash outputs when \"C-d\" is input by user.\n## This value is used to detect that the user inputs \"C-d\" in Bash 3.\n\n#bleopt internal_ignoreeof_trap='Use \"exit\" to leave the shell.'\n\n\n## This option controls the output of stack dump when assertion is failed in\n## ble.sh.  When the value is evaluated to be non-zero, the stack dump is\n## printed for assertion failures.\n\n#bleopt internal_stackdump_enabled=0\n\n\n## When a non-empty value is specified to this option, the standard output and\n## standard error from Bash is not output to the terminal.  When the value is\n## empty, ble.sh tries to realize the line editing allowing Bash to output its\n## own standard output and error.  This setting has a flickering problem and\n## only left for debugging purpose, so it is not tested.  Normally a non-empty\n## value should be specified so as to suppress the standard output and error\n## from Bash.\n\n#bleopt internal_suppress_bash_output=1\n\n\n## This is a colon-separated list of fields to control the behavior of\n## ble/debug/profiler.  When the field \"line\" and \"func\" are specified,\n## statistics for lines and function calls, respectively, are enabled.  When\n## the field \"tree\" is specified, function-call trees are saved.  Optional\n## parameter \"html\" can be specified to \"line\" and \"func\" separated by the\n## equal sign, i.e., \"line=html\" and \"func=html\".  In such a case, the results\n## are also saved in the .html format.\n\n#bleopt debug_profiler_opts=line:func\n\n\n## This option specifies the threshold time in milliseconds to determine\n## whether to include a command in the tree generated by \"bleopt\n## debug_profiler_opts=tree\".  The commands that took less than this time in\n## execution will be skipped.  The default value is 5.0 msec.\n\n#bleopt debug_profiler_tree_threshold=5.0\n"
        },
        {
          "name": "contrib",
          "type": "commit",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "make",
          "type": "tree",
          "content": null
        },
        {
          "name": "make_command.sh",
          "type": "blob",
          "size": 33.34375,
          "content": "#!/usr/bin/env bash\n\numask 022\nshopt -s nullglob\nLC_ALL= LC_COLLATE=C\n\nfunction mkd {\n  [[ -d $1 ]] || mkdir -p \"$1\"\n}\n\nfunction download {\n  local url=$1 dst=$2\n  if [[ ! -s $dst ]]; then\n    [[ $dst == ?*/* ]] && mkd \"${dst%/*}\"\n    if type wget &>/dev/null; then\n      wget \"$url\" -O \"$dst.part\" && mv \"$dst.part\" \"$dst\"\n    else\n      echo \"make_command: 'wget' not found.\" >&2\n      exit 2\n    fi\n  fi\n}\n\nfunction ble/array#push {\n  while (($#>=2)); do\n    builtin eval \"$1[\\${#$1[@]}]=\\$2\"\n    set -- \"$1\" \"${@:3}\"\n  done\n}\n\nfunction sub:help {\n  printf '%s\\n' \\\n         'usage: make_command.sh SUBCOMMAND args...' \\\n         '' 'SUBCOMMAND' ''\n  local sub\n  for sub in $(declare -F | sed -n 's|^declare -[fx]* sub:\\([^/]*\\)$|\\1|p'); do\n    if declare -f sub:\"$sub\"/help &>/dev/null; then\n      sub:\"$sub\"/help\n    else\n      printf '  %s\\n' \"$sub\"\n    fi\n  done\n  printf '\\n'\n}\n\n#------------------------------------------------------------------------------\n\nfunction sub:install {\n  # read options\n  local flag_error= flag_release=\n  local opt_strip_comment=\n  while [[ $1 == -* ]]; do\n    local arg=$1; shift\n    case $arg in\n    (--release)\n      flag_release=1 ;;\n    (--strip-comment=*)\n      opt_strip_comment=${arg#*=} ;;\n    (--)\n      break ;;\n    (*)\n      echo \"install: unknown option $arg\" >&2\n      flag_error=1 ;;\n    esac\n  done\n  [[ $flag_error ]] && return 1\n\n  local src=$1\n  local dst=$2\n  mkd \"${dst%/*}\"\n  if [[ $src == *.sh ]]; then\n    local nl=$'\\n' q=\\'\n\n    # header comment\n    local script='1i\\\n# Copyright 2015 Koichi Murase <myoga.murase@gmail.com>. All rights reserved.\\\n# This script is a part of blesh (https://github.com/akinomyoga/ble.sh)\\\n# provided under the BSD-3-Clause license.  Do not edit this file because this\\\n# is not the original source code: Various pre-processing has been applied.\\\n# Also, the code comments and blank lines are stripped off in the installation\\\n# process.  Please find the corresponding source file(s) in the repository\\\n# \"akinomyoga/ble.sh\".'\n    if [[ $src == out/ble.sh ]]; then\n      script=$script'\\\n#\\\n# Source: /ble.pp'\n      if [[ -s out/ble.dep ]]; then\n        script=$script'\\\n'$(awk 'sub(/^  /, \"\") { sub(/ \\\\$/, \"\\\\\"); print \"# Source: /\" $0; }' out/ble.dep)\n      else\n        local file\n        for file in $(git ls-files src); do\n          [[ $file == *.sh ]] || continue\n          script=$script\"\\\\\n# Source: /$file\"\n        done\n      fi\n    else\n      script=$script'\\\n#\\\n# Source: /'\"${src#out/}\"\n    fi\n\n    # strip comments\n    if [[ $opt_strip_comment != no ]]; then\n      script=$script'\n/<<[[:blank:]]*EOF/,/^[[:blank:]]*EOF/{p;d;}\n/^[[:blank:]]*#/d\n/^[[:blank:]]*$/d'\n    else\n      script=$script'\\\n#------------------------------------------------------------------------------'\n    fi\n\n    [[ $flag_release ]] &&\n      script=$script$nl's/^\\([[:blank:]]*_ble_base_repository=\\)'$q'.*'$q'\\([[:blank:]]*\\)$/\\1'${q}release:$dist_git_branch$q'/'\n    sed \"$script\" \"$src\" >| \"$dst.part\" && mv \"$dst.part\" \"$dst\"\n  else\n    cp \"$src\" \"$dst\"\n  fi\n}\nfunction sub:install/help {\n  printf '  install src dst\\n'\n}\n\nfunction sub:uninstall {\n  rm -rf \"$@\"\n\n  local file children\n  for file; do\n    while\n      file=${file%/*}\n      [[ -d $file ]] || break\n      children=(\"$file\"/* \"$file\"/.*)\n      ((${#children[@]} == 0))\n    do\n      rmdir \"$file\"\n    done\n  done\n}\n\nfunction sub:dist {\n  local dist_git_branch=$(git rev-parse --abbrev-ref HEAD)\n  local tmpdir=ble-$FULLVER\n  local src\n  for src in \"$@\"; do\n    local dst=$tmpdir${src#out}\n    sub:install --release \"$src\" \"$dst\"\n  done\n  [[ -d dist ]] || mkdir -p dist\n  tar caf \"dist/$tmpdir.$(date +'%Y%m%d').tar.xz\" \"$tmpdir\" && rm -r \"$tmpdir\"\n}\n\nfunction sub:ignoreeof-messages {\n  (\n    cd ~/local/build/bash-4.3/po\n    sed -nr '/msgid \"Use \\\\\"%s\\\\\" to leave the shell\\.\\\\n\"/{n;s/^[[:blank:]]*msgstr \"(.*)\"[^\"]*$/\\1/p;}' *.po | while builtin read -r line || [[ $line ]]; do\n      [[ $line ]] || continue\n      echo $(printf \"$line\" exit) # $() は末端の改行を削除するため\n    done\n  ) >| lib/core-edit.ignoreeof-messages.new\n}\n\n#------------------------------------------------------------------------------\n# sub:check\n# sub:check-all\n\nfunction sub:check {\n  local bash=${1-bash}\n  \"$bash\" out/ble.sh --test\n}\nfunction sub:check-all {\n  local -x _ble_make_command_check_count=0\n  local bash rex_version='^bash-([0-9]+)\\.([0-9]+)$'\n  for bash in $(compgen -c -- bash- | grep -E '^bash-(dev|[0-9]+\\.[0-9]+)$' | sort -Vr); do\n    [[ $bash =~ $rex_version && ${BASH_REMATCH[1]} -ge 3 ]] || continue\n    \"$bash\" out/ble.sh --test || return 1\n    ((_ble_make_command_check_count++))\n  done\n}\n\n#------------------------------------------------------------------------------\n# sub:scan\n\n_make_rex_escseq='(\u001b\\[[ -?]*[@-~])*'\n\nfunction sub:scan/.mark {\n  local mark=$1\n  sed -E '/'\"$mark\"'($|[^0-9])/d;s/^/\\x1b[1;95m'\"$mark\"'\\x1b[m /'\n}\n\nfunction sub:scan/grc-source {\n  local -a options=(--color --exclude=./{test,memo,ext,wiki,contrib,[TD]????.*} --exclude=\\*.{md,awk} --exclude=./{GNUmakefile,make_command.sh})\n  grc \"${options[@]}\" \"$@\"\n}\nfunction sub:scan/list-command {\n  local -a options=(--color --exclude=./{test,memo,ext,wiki,[TD]????.*} --exclude=\\*.{md,awk})\n\n  # read arguments\n  local flag_exclude_this= flag_error=\n  local command=\n  while (($#)); do\n    local arg=$1; shift\n    case $arg in\n    (--exclude-this)\n      flag_exclude_this=1 ;;\n    (--exclude=*)\n      ble/array#push options \"$arg\" ;;\n    (--)\n      [[ $1 ]] && command=$1\n      break ;;\n    (-*)\n      echo \"check: unknown option '$arg'\" >&2\n      flag_error=1 ;;\n    (*)\n      command=$arg ;;\n    esac\n  done\n  if [[ ! $command ]]; then\n    echo \"check: command name is not specified.\" >&2\n    flag_error=1\n  fi\n  [[ $flag_error ]] && return 1\n\n  [[ $flag_exclude_this ]] && ble/array#push options --exclude=./make_command.sh\n  grc \"${options[@]}\" \"(^|[^-./\\${}=#])\\b$command\"'\\b([[:blank:]|&;<>()`\"'\\'']|$)'\n}\n\nfunction sub:scan/builtin {\n  echo \"--- $FUNCNAME $1 ---\"\n  local command=$1 esc=$_make_rex_escseq\n  local b=\"(\\b|$esc)\" ; [[ $command == [_a-zA-Z0-9]* ]] || b=\"($esc)\"\n  sub:scan/list-command --exclude-this --exclude={generate-release-note.sh,lib/test-*.sh,make,ext} \"$command\" \"${@:2}\" |\n    grep -Ev \"$rex_grep_head([[:blank:]]*|[[:alnum:][:blank:]]*[[:blank:]])#|$b(builtin|function)$esc([[:blank:]]$esc)+$command$b\" |\n    grep -Ev \"$command$b=\" |\n    grep -Ev \"ble\\.sh $esc\\($esc$command$esc\\)$esc\" |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g\n        \\Z^\\./lib/test-[^:]+\\.sh:[0-9]+:.*ble/test Zd\n      s/^[^:]*:[0-9]+:[[:blank:]]*//\n        \\Z(\\.awk|push|load|==|#(push|pop)) \\b'\"$command\"'\\bZd\n      g'\n}\n\nfunction sub:scan/check-todo-mark {\n  echo \"--- $FUNCNAME ---\"\n  grc --color --exclude=./make_command.sh '@@@'\n}\nfunction sub:scan/a.txt {\n  echo \"--- $FUNCNAME ---\"\n  grc --color --exclude={test,ext,./lib/test-\\*.sh,./make_command.sh,\\*.md} --exclude=check-mem.sh '[/[:blank:]<>\"'\\''][a-z]\\.txt|/dev/(pts/|pty)[0-9]*|/dev/tty' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g\n      \\Z^\\./memo/Zd\n      \\Zgithub302-perlre-server\\.bashZd\n      \\Z^\\./contrib/integration/fzf-git.bash:[0-9]+:Zd\n    s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z^[[:blank:]]*#Zd\n      \\ZDEBUG_LEAKVARZd\n      \\Z\\[\\[ -t 4 && -t 5 ]]Zd\n      \\Z^if ble/fd#alloc .*Zd\n      \\Zbuiltin read -et 0.000001 dummy </dev/ttyZd\n      g'\n}\n\nfunction sub:scan/bash300bug {\n  echo \"--- $FUNCNAME ---\"\n  # bash-3.0 では local arr=(1 2 3) とすると\n  # local arr='(1 2 3)' と解釈されてしまう。\n  grc '(local|declare|typeset) [_a-zA-Z]+=\\(' --exclude=./{test,ext} --exclude=./make_command.sh --exclude=ChangeLog.md --color |\n    sub:scan/.mark '#D0184'\n\n  # bash-3.0 では local -a arr=(\"$hello\") とすると\n  # クォートしているにも拘らず $hello の中身が単語分割されてしまう。\n  grc '(local|declare|typeset) -a [[:alnum:]_]+=\\([^)]*[\\\"'\\''`]' --exclude=./{test,ext} --exclude=./make_command.sh --color |\n    sub:scan/.mark '#D0525'\n\n  # bash-3.0 では \"${scalar[@]/xxxx}\" は全て空になる\n  grc '\\$\\{[_a-zA-Z0-9]+\\[[*@]\\]/' --exclude=./{text,ext} --exclude=./make_command.sh --exclude=\\*.md --color |\n    sub:scan/.mark '#D1570'\n\n  # bash-3.0 では \"..${var-$'hello'}..\" は (var が存在しない時) \"..'hello'...\" になる。\n  grc '\".*\\$\\{[^{}]*\\$'\\''([^\\\\'\\'']|\\\\.)*'\\''\\}.*\"' --exclude={./make_command.sh,memo,\\*.md} --color |\n    sub:scan/.mark '#D1774'\n\n}\n\nfunction sub:scan/bash301bug {\n  echo \"--- $FUNCNAME ---\"\n  # bash-3.1, 3.2 では 10 以上の fd は既に使われている場合、リダイレクトに失敗\n  # する。\n  grc ' [0-9]{2}&?[<>]' --exclude=./{test,ext} --exclude=./make_command.sh --exclude=ChangeLog.md --color |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      /^#/d\n      /#D0857/d\n      / [0-9]{2}[<>]&-/d\n      g'\n\n  # bash-3.1 では 10 以上の fd は >&- 等で閉じる事ができない。\n  grc ' ([0-9]{2}|\\$[a-zA-Z_0-9]+)&?[<>]&-' --exclude=./{test,ext} --exclude=./make_command.sh --exclude=ChangeLog.md --color |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      /^#/d\n      /#D2164/d\n      g'\n\n  # array-element-length\n  # bash-3.1 で ${#arr[index]} を用いると、\n  # 日本語の文字数が変になる。\n  grc '\\$\\{#[[:alnum:]]+\\[[^@*]' --exclude={test,ChangeLog.md} --color |\n    grep -Ev '^([^#]*[[:blank:]])?#' |\n    sub:scan/.mark '#D0182'\n}\n\nfunction sub:scan/bash400bug {\n  echo \"--- $FUNCNAME ---\"\n\n  # bash-3.0..4.0 で $'' 内に \\' を入れていると '' の入れ子状態が反転して履歴展\n  # 開が '' の内部で起こってしまう。\n  grc '\\$'\\''([^\\'\\'']|\\\\[^'\\''])*\\\\'\\''([^\\'\\'']|\\\\.|'\\''([^\\'\\'']|\\\\*)'\\'')*![^=[:blank:]]' --exclude={test,ChangeLog.md} --color |\n    grep -v '9f0644470'\n}\n\nfunction sub:scan/bash401-histexpand-bgpid {\n  echo \"--- $FUNCNAME ---\"\n  grc '\"\\$!\"' --exclude={test,ChangeLog.md} --color |\n    sub:scan/.mark '#D2028'\n}\n\nfunction sub:scan/bash404-no-argument-return {\n  echo \"--- $FUNCNAME ---\"\n  grc --color 'return[[:blank:]]*($|[;|&<>])' --exclude={test,wiki,ChangeLog.md,make,docs,make_command.sh} |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n\n      \\Z@returnZd\n      \\Z\\) return;Zd\n      \\Zreturn;[[:blank:]]*$Zd\n      \\Zif \\(REQ == \"[A-Z]+\"\\)Zd\n      \\Z\\(return\\|ret\\)Zd\n      \\Z_ble_trap_done=return$Zd\n      \\Z\\bwe return\\bZd\n\n      g'\n}\n\nfunction sub:scan/bash501-arith-base {\n  echo \"--- $FUNCNAME ---\"\n  # bash-5.1 で $((10#)) の取り扱いが変わった。\n  grc '\\b10#\\$' --exclude={test,ChangeLog.md}\n}\n\nfunction sub:scan/bash502-patsub_replacement {\n  echo \"--- $FUNCNAME ---\"\n  # bash-5.2 patsub_replacement で ${var/pat/string} の string 中の & が特別な\n  # 意味を持つ様になったので、特に意識する場合を除いては quote が必要になった。\n  grc --color '\\$\\{[[:alnum:]_]+(\\[[^][]*\\])?//?([^{}]|\\{[^{}]*\\})+/[^{}\"'\\'']*([&$]|\\\\)' --exclude=./test |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z//?\\$q/\\$Q\\}Zd\n      \\Z//?\\$q/\\$qq\\}Zd\n      \\Z//?\\$qq/\\$q\\}Zd\n      \\Z//?\\$__ble_q/\\$__ble_Q\\}Zd\n      \\Z//?\\$_ble_local_q/\\$_ble_local_Q\\}Zd\n      \\Z/\\$\\(\\([^()]+\\)\\)\\}Zd\n      \\Z/\\$'\\''([^\\\\]|\\\\.)+'\\''\\}Zd\n\n      \\Z\\$\\{[_a-zA-Z0-9]+//(ARR|DICT|PREFIX|NAME|LAYER)/\\$([_a-zA-Z0-9]+|\\{[_a-zA-Z0-9#:-]+\\})\\}Zd\n      \\Z\\$\\{[_a-zA-Z0-9]+//'\\''%[dlcxy]'\\''/\\$[_a-zA-Z0-9]+\\}Zd # src/canvas.sh\n\n      \\Z#D1738Zd\n      \\Z\\$\\{_ble_edit_str//\\$'\\''\\\\n'\\''/\\$'\\''\\\\n'\\''\"\\$comment_begin\"\\}Zd # edit.sh\n      g'\n\n  grc --color '\"[^\"]*\\$\\{[[:alnum:]_]+(\\[[^][]*\\])?//?([^{}]|\\{[^{}]*\\})+/[^{}\"'\\'']*\"[^\"]*([&$]|\\\\)' --exclude=./test |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z#D1751Zd\n      g'\n}\n\nfunction sub:scan/gawk402bug-regex-check {\n  echo \"--- $FUNCNAME ---\"\n  grc --color '\\[\\^?\\][^]]*\\[:[^]]*:\\].[^]]*\\]' --exclude={test,ext,\\*.md} | grep -Ev '#D1709 safe'\n}\nfunction sub:scan/nawk-bug {\n  echo \"--- $FUNCNAME ---\"\n  # Note (#D2162): nawk in Solaris 2.11 does not support regular expression\n  # starting with \"=\" in the form /=.../.  This is probably because the lexer\n  # in Solaris 2.11 nawk is confused with the division-assignment operator\n  # \"/=\".\n  grc --color --exclude={test,ext,\\*.md} '(g?sub|match)\\(.*/=| !?~ /='\n}\n\nfunction sub:scan/assign {\n  echo \"--- $FUNCNAME ---\"\n  local command=\"$1\"\n  grc --color --exclude=./test --exclude=./memo '\\$\\([^()]' |\n    grep -Ev \"$rex_grep_head#|[[:blank:]]#\"\n}\n\nfunction sub:scan/memo-numbering {\n  echo \"--- $FUNCNAME ---\"\n\n  grep -ao '\\[#D....\\]' note.txt memo/done.txt | awk '\n    function report_error(message) {\n      printf(\"memo-numbering: \\x1b[1;31m%s\\x1b[m\\n\", message) > \"/dev/stderr\";\n    }\n    !/\\[#D[0-9]{4}\\]/ {\n      report_error(\"invalid  number \\\"\" $0 \"\\\".\");\n      next;\n    }\n    {\n      num = $0;\n      gsub(/^\\[#D0+|\\]$/, \"\", num);\n      if (prev != \"\" && num != prev - 1) {\n        if (prev < num) {\n          report_error(\"reverse ordering \" num \" has come after \" prev \".\");\n        } else if (prev == num) {\n          report_error(\"duplicate number \" num \".\");\n        } else {\n          for (i = prev - 1; i > num; i--) {\n            report_error(\"memo-numbering: missing number \" i \".\");\n          }\n        }\n      }\n      prev = num;\n    }\n    END {\n      if (prev != 1) {\n        for (i = prev - 1; i >= 1; i--)\n          report_error(\"memo-numbering: missing number \" i \".\");\n      }\n    }\n  '\n  cat note.txt memo/done.txt | sed -n '0,/^[[:blank:]]\\{1,\\}Done/d;/  \\* .*\\[#D....\\]$/d;/^  \\* /p'\n}\n\n# 誤って ((${#arr[@]})) を ((${arr[@]})) などと書いてしまうミス。\nfunction sub:scan/array-count-in-arithmetic-expression {\n  echo \"--- $FUNCNAME ---\"\n  grc --exclude=./make_command.sh '\\(\\([^[:blank:]]*\\$\\{[[:alnum:]_]+\\[[@*]\\]\\}'\n}\n\n# unset 変数名 としていると誤って関数が消えることがある。\nfunction sub:scan/unset-variable {\n  echo \"--- $FUNCNAME ---\"\n  sub:scan/list-command unset --exclude-this |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Zunset[[:blank:]]-[vf]Zd\n      \\Z^[[:blank:]]*#Zd\n      \\Zunset _ble_init_(version|arg|exit|command)\\bZd\n      \\Zbuiltins1=\\(.* unset .*\\)Zd\n      \\Zfunction unsetZd\n      \\Zreadonly -f unsetZd\n      \\Z'\\''\\(unset\\)'\\''Zd\n      \\Z\"\\$__ble_proc\" \"\\$__ble_name\" unsetZd\n      \\Zulimit umask unalias unset waitZd\n      \\ZThe variable will be unset initiallyZd\n      g'\n}\nfunction sub:scan/eval-literal {\n  echo \"--- $FUNCNAME ---\"\n  sub:scan/grc-source 'builtin eval \"\\$' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Zeval \"(\\$[[:alnum:]_]+)+(\\[[^][\"'\\''\\$`]+\\])?\\+?=Zd\n      g'\n}\n\nfunction sub:scan/WA-localvar_inherit {\n  echo \"--- $FUNCNAME ---\"\n  grc 'local [^;&|()]*\"\\$\\{[_a-zA-Z0-9]+\\[@*\\]\\}\"' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Ztest_command='\\''ble/bin/stty -echo -nl -icrnl -icanon \"\\$\\{_ble_term_stty_flags_enter\\[@]}\" size'\\''Zd\n      /#D1566/d\n      g'\n}\n\nfunction sub:scan/command-layout {\n  echo \"--- $FUNCNAME ---\"\n  grc '(/enter-command-layout|ble/edit/\\.relocate-textarea|/\\.newline)([[:blank:]]|$)' --exclude=./{text,ext} --exclude=./make_command.sh --exclude=\\*.md --color |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z^[[:blank:]]*#Zd\n      \\Z^[[:blank:]]*function [^[:blank:]]* \\{$Zd\n      \\Z[: ]keep-infoZd\n      \\Z#D1800Zd\n      g'\n}\n\nfunction sub:scan/word-splitting-number {\n  echo \"--- $FUNCNAME ---\"\n  # #D1835 一般には IFS に整数が含まれるている場合もあるので ${#...} や\n  # $((...)) や >&$fd であってもちゃんと quote する必要がある。\n  grc '[<>]&\\$|([[:blank:]]|=\\()\\$(\\(\\(|\\{#|\\?)' --exclude={docs,mwg_pp.awk,memo} |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z^[^#]*(^|[[:blank:]])#Zd\n      \\Z^([^\"]|\"[^\\#]*\")*\"[^\"]*([& (]\\$)Zd\n      \\Z^[^][]*\\[\\[[^][]*([& (]\\$)Zd\n      \\Z\\(\\([_a-zA-Z0-9]+=\\(\\$Zd\n      \\Z\\$\\{#[_a-zA-Z0-9]+\\}[<>?&]Zd\n      \\Z \\$\\{\\#[_a-zA-Z0-9]+\\[@\\]\\} -gt 0 \\]\\]Zd\n      \\Zcase \\$\\? inZd\n      \\Zcase \\$\\(\\(.*\\)\\) inZd\n      \\Z#D1835Zd\n      g'\n}\n\nfunction sub:scan/check-readonly-unsafe {\n  echo \"--- $FUNCNAME ---\"\n  local rex_varname='\\b(_[_a-zA-Z0-9]+|[_A-Z][_A-Z0-9]+)\\b'\n  grc -Wg,-n -Wg,--color=always -o \"$rex_varname\"'\\+?=\\b|(/assign|/assign-array|#split) '\"$rex_varname\"'| -v '\"$rex_varname\"' ' \\\n      --exclude={memo,wiki,test,make,'*.md',make_command.sh,GNUmakefile,'gh????.*.'{sh,bash}} |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g\n\n      # Exceptions in each file\n      /^\\.\\/ble.pp:[0-9]*:BLEOPT=$/d\n      /^\\.\\/ble.pp:[0-9]*:\\/assign (USER|HOSTNAME)/d\n      /^\\.\\/lib\\/core-complete.sh:[0-9]+:KEY=$/d\n      /^\\.\\/lib\\/core-syntax.sh:[0-9]+:VAR=$/d\n      /^\\.\\/lib\\/init-(cmap|term).sh:[0-9]+:TERM=$/d\n      /^\\.\\/src\\/edit.sh:[0-9]+:_dirty=$/d\n      /^\\.\\/src\\/history.sh:[0-9]+:_history_index=$/d\n      /^\\.\\/src\\/util.sh:[0-9]+:(NAMEI|OPEN|TERM)=$/d\n      /^\\.\\/lib\\/core-cmdspec.sh:[0-9]+:OLD=$/d\n\n      # (extract only variable names)\n      s/^[^:]*:[0-9]+:[[:blank:]]*//;\n      s/^-v (.*) $/\\1/;s/\\+?=$//;s/^.+ //;\n\n      # other frameworks & integrations\n      /^__bp_blesh_invoking_through_blesh$/d\n      /^__bp_imported$/d\n      /^__bp_inside_pre(cmd|exec)$/d\n      /^BP_PROMPT_COMMAND_.*$/d\n\n      # common variables\n      /^__?ble[_a-zA-Z0-9]*$/d\n      /^[A-Z]$/d\n      /^BLE_[_A-Z0-9]*$/d\n      /^ADVICE_[_A-Z0-9]*$/d\n      /^COMP_[_A-Z0-9]*$/d\n      /^COMPREPLY$/d\n      /^READLINE_[_A-Z0-9]*$/d\n      /^LC_[_A-Z0-9]*$/d\n      /^LANG$/d\n\n      # other uppercase variables that ble.sh is allowed to use.\n      /^(FUNCNEST|IFS|IGNOREEOF|POSIXLY_CORRECT|TMOUT)$/d\n      /^(PWD|OLDPWD|CDPATH)$/d\n      /^(BASHPID|GLOBIGNORE|MAPFILE|REPLY)$/d\n      /^INPUTRC$/d\n      /^(LINES|COLUMNS)$/d\n      /^HIST(CONTROL|IGNORE|SIZE|TIMEFORMAT)$/d\n      /^(PROMPT_COMMAND|PS1)$/d\n      /^(BASH_COMMAND|BASH_REMATCH|HISTCMD|LINENO|PIPESTATUS|TIMEFORMAT)$/d\n      /^(BASH_XTRACEFD|PS4)$/d\n      /^(CC|LESS|MANOPT|MANPAGER|PAGER|PATH|MANPATH)$/d\n      /^(BUFF|KEYS|KEYMAP|WIDGET|LASTWIDGET|DRAW_BUFF)$/d\n      /^(D(MIN|MAX|MAX0)|(HIGHLIGHT|PREV)_(BUFF|UMAX|UMIN)|LEVEL|LAYER_(UMAX|UMIN))$/d\n      /^(HISTINDEX_NEXT|FILE|LINE|INDEX|INDEX_FILE)$/d\n      /^(ARG|FLAG|REG)$/d\n      /^(COMP[12SV]|ACTION|CAND|DATA|INSERT|PREFIX_LEN)$/d\n      /^(PRETTY_NAME|NAME|VERSION)$/d\n\n      # variables in awk/comments/etc\n      /^AWKTYPE$/d\n      /^FOO$/d\n      g'\n}\n\nfunction sub:scan/mistake-_ble_bash {\n  echo \"--- $FUNCNAME ---\"\n  sub:scan/grc-source '\\(\\(.*\\b_ble_base\\b.*\\)\\)'\n}\n\nfunction sub:scan/mistake-bleopt-declare {\n  echo \"--- $FUNCNAME ---\"\n  sub:scan/grc-source 'bleopt/declare (-[nv] )?[_a-zA-Z0-9]+='\n}\n\nfunction sub:scan/mistake-typo {\n  echo \"--- $FUNCNAME ---\"\n  grc --color --exclude=./make_command.sh 'copmgen|comgpen|inetgration|\\buti/'\n}\n\nfunction sub:scan {\n  if ! type grc >/dev/null; then\n    echo 'blesh check: grc not found. grc can be found in github.com:akinomyoga/mshex.git/' >&2\n    exit\n  fi\n\n  local esc=$_make_rex_escseq\n  local rex_grep_head=\"^$esc[[:graph:]]+$esc:$esc[[:digit:]]*$esc:$esc\"\n\n  # builtin return break continue : eval echo unset は unset しているので大丈夫のはず\n\n  #sub:scan/builtin 'history'\n  sub:scan/builtin 'echo' --exclude=./ble.pp |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z\\bstty[[:blank:]]+echoZd\n      \\Zecho \\$PPIDZd\n      \\Zble/keymap:vi_test/check Zd\n      \\Zmandb-help=%'\\''help echo'\\''Zd\n      \\Zalias aaa4='\\''echo'\\''Zd\n      g'\n  #sub:scan/builtin '(compopt|type|printf)'\n  sub:scan/builtin 'bind' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Zinvalid bind typeZd\n      \\Zline = \"bind\"Zd\n      \\Z'\\''  bindZd\n      \\Z\\(bind\\)    ble-bindZd\n      \\Z^alias bind cd command compgenZd\n      \\Zoutputs of the \"bind\" builtinZd\n      \\Zif ble/string#match \"\\$_ble_edit_str\" '\\''bindZd\n      \\Z\\(ble/builtin/bind\\|ble/builtin/bind/\\*\\|bind\\|ble/decode/read-inputrc/test\\)Zd\n      \\Ztitle=['\\''\"]([^\"]*: )?bind \\(ble\\.sh\\)['\\''\"]Zd\n      \\Zwarning: readline \\\\\"bind -x\\\\\" does not supportZd\n      \\Zble/init/measure/section '\\''bind'\\''Zd\n      g'\n  sub:scan/builtin 'read' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\ZDo not read Zd\n      \\Zfailed to read Zd\n      \\Zpushd read readonly set shoptZd\n      g'\n  sub:scan/builtin 'exit' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Zble.pp.*return 1 2>/dev/null || exit 1Zd\n      \\Z^[-[:blank:][:alnum:]_./:=$#*]+('\\''[^'\\'']*|\"[^\"()`]*|([[:blank:]]|^)#.*)\\bexit\\bZd\n      \\Z\\(exit\\) ;;Zd\n      \\Zprint NR; exit;Zd;g'\n  sub:scan/builtin 'eval' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z\\('\\''eval'\\''\\)Zd\n      \\Z\\(eval\\)Zd\n      \\Zbuiltins1=\\(.* eval .*\\)Zd\n      \\Z\\^eval --Zd\n      \\Zt = \"eval -- \\$\"Zd\n      \\Ztext = \"eval -- \\$'\\''Zd\n      \\Zcmd '\\''eval -- %q'\\''Zd\n      \\Z\\$\\(eval \\$\\(call .*\\)\\)Zd\n      \\Z^[[:blank:]]*local rex_[_a-zA-Z0-9]+='\\''[^'\\'']*'\\''[[:blank:]]*$Zd\n      \\ZLINENO='\\''\\$lineno'\\'' evalZd\n      \\Z'\\''argument eval'\\''Zd\n      \\Z^ble/cmdspec/opts Zd\n      g'\n  sub:scan/builtin 'unset' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Zunset (-v )?_ble_init_(version|arg|exit|command)\\bZd\n      \\Zreadonly -f unsetZd\n      \\Zunset -f builtinZd\n      \\Z'\\''\\(unset\\)'\\''Zd\n      \\Z\"\\$__ble_proc\" \"\\$__ble_name\" unsetZd\n      \\Zumask unalias unset wait$Zd\n      \\ZThe variable will be unset initiallyZd\n      g'\n  sub:scan/builtin 'unalias' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Zbuiltins1=\\(.* unalias .*\\)Zd\n      \\Zumask unalias unset wait$Zd\n      g'\n\n  #sub:scan/assign\n  sub:scan/builtin 'trap' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g\n\n      # Exceptions in each file\n      \\Z^\\./contrib/integration/bash-preexec\\.bash:[0-9]+:.*\\btrap -p? DEBUG\\bZd\n      \\Z^\\./contrib/integration/bash-preexec\\.bash:[0-9]+:.*\\[\\[ \\$trap_string == \"trap -- Zd\n      \\Z^\\./contrib/snake\\.sh:[0-9]+:Zd\n\n    s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z_ble_trap_handler=\"trap -- '\\''\\$\\{_ble_trap_handler//\\$q/\\$Q}'\\'' \\$nZd\n      \\Zline = \"bind\"Zd\n      \\Ztrap_command=[\"'\\'']trap -- Zd\n      \\Z_ble_builtin_trap_handlers_reload\\[sig\\]=\"trap -- Zd\n      \\Zlocal trap$Zd\n      \\Z\"trap -- '\\''\"Zd\n      \\Z\\('\\'' trap '\\''\\*Zd\n      \\Z\\(trap \\| ble/builtin/trap\\) .*;;Zd\n      \\Zble/function#trace trap Zd\n      \\Z# EXIT trapZd\n      \\Zread readonly set shopt trapZd\n      \\Zble/util/print \"custom trap\"Zd\n      g'\n\n  sub:scan/builtin 'readonly' |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      \\Z^[[:blank:]]*#Zd\n      \\ZWA readonlyZd\n      \\Z\\('\\''declare'\\''(\\|'\\''[a-z]+'\\'')+\\)Zd\n      \\Z readonly was blocked\\.Zd\n      \\Z\\[\\[ \\$\\{FUNCNAME\\[i]} == \\*readonly ]]Zd\n      \\Zread readonly set shopt trapZd\n      g'\n  sub:scan/builtin ':' --exclude=./ble.pp |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g;s/^[^:]*:[0-9]+:[[:blank:]]*//\n      g'\n  sub:scan/builtin 'type' --exclude=./ble.pp |\n    sed -E 'h;s/'\"$_make_rex_escseq\"'//g\n\n      \\Zgh0358\\.copilot\\.bashZd\n\n    s/^[^:]*:[0-9]+:[[:blank:]]*//\n\n      \\Zble/util/type type Zd\n      \\Zble/util/print \"[^\"].* type\\bZd\n      \\Z\\blocal( [_a-zA-Z0-9]+)* typeZd\n      \\Z # .*\\btype\\bZd\n      \\Z # .*\\btype\\bZd\n      \\Z\\bfor type in Zd\n\n      \\Z keys type\\bZd\n      \\Ztrap type ulimitZd\n      \\Zevent typeZd\n      \\Z\"unrecognized fzf-complete type Zd\n\n      # awk scripts\n      \\Zif \\(typeZd\n      \\Z\\btype ==? Zd\n      \\Z = type\\bZd\n      \\Z\\b, type\\)Zd\n\n      \\Zble/fun:type\\bZd\n      g'\n\n  sub:scan/a.txt\n  sub:scan/check-todo-mark\n  sub:scan/bash300bug\n  sub:scan/bash301bug\n  sub:scan/bash400bug\n  sub:scan/bash401-histexpand-bgpid\n  sub:scan/bash404-no-argument-return\n  sub:scan/bash501-arith-base\n  sub:scan/bash502-patsub_replacement\n  sub:scan/gawk402bug-regex-check\n  sub:scan/nawk-bug\n  sub:scan/array-count-in-arithmetic-expression\n  sub:scan/unset-variable\n  sub:scan/eval-literal\n  sub:scan/WA-localvar_inherit\n  sub:scan/command-layout\n  sub:scan/word-splitting-number\n  sub:scan/check-readonly-unsafe\n\n  sub:scan/mistake-_ble_bash\n  sub:scan/mistake-bleopt-declare\n  sub:scan/mistake-typo\n\n  sub:scan/memo-numbering\n}\n\nfunction sub:show-contrib/canonicalize {\n  sed 's/, /\\n/g;s/ and /\\n/g' | sed 's/[[:blank:]]/_/g' | LANG=C sort\n}\nfunction sub:show-contrib/count {\n  LANG=C sort | uniq -c | LANG=C sort -rnk1 |\n    awk 'function xflush() {if(c!=\"\"){printf(\"%4d %s\\n\",c,n);}} {if($1!=c){xflush();c=$1;n=$2}else{n=n\", \"$2;}}END{xflush()}' |\n    ifold -w 131 -s --indent=' +[0-9] +'\n}\nfunction sub:show-contrib {\n  local cache_contrib_github=out/contrib-github.txt\n  if [[ ! ( $cache_contrib_github -nt .git/refs/remotes/origin/master ) ]]; then\n    {\n      wget 'https://api.github.com/repos/akinomyoga/ble.sh/issues?state=all&per_page=100&pulls=true' -O -\n      wget 'https://api.github.com/repos/akinomyoga/ble.sh/issues?state=all&per_page=100&pulls=true&page=2' -O -\n      wget 'https://api.github.com/repos/akinomyoga/blesh-contrib/issues?state=all&per_page=100&pulls=true' -O -\n    } |\n      sed -n 's/^[[:blank:]]*\"login\": \"\\(.*\\)\",$/\\1/p' |\n      sub:show-contrib/canonicalize > \"$cache_contrib_github\"\n  fi\n\n  echo \"Contributions (from GitHub Issues/PRs)\"\n  < \"$cache_contrib_github\" sub:show-contrib/count\n\n  echo \"Contributions (from memo.txt)\"\n  sed -En 's/^  \\* .*\\([^()]+ by ([^()]+)\\).*/\\1/p' memo/done.txt note.txt | sub:show-contrib/canonicalize | sub:show-contrib/count\n\n  echo \"Contributions (from ChangeLog.md)\"\n  sed -n 's/.*([^()]* by \\([^()]*\\)).*/\\1/p' docs/ChangeLog.md | sub:show-contrib/canonicalize | sub:show-contrib/count\n\n  echo \"Σ: Issues/PRs + max(memo.txt,ChangeLog)\"\n\n  LANG=C join -j 2 -e 0 \\\n      <(sed -En 's/^  \\* .*\\([^()]+ by ([^()]+)\\).*/\\1/p' memo/done.txt note.txt | sub:show-contrib/canonicalize | uniq -c | LANG=C sort -k2) \\\n      <(sed -n 's/.*([^()]* by \\([^()]*\\)).*/\\1/p' docs/ChangeLog.md | sub:show-contrib/canonicalize | uniq -c | LANG=C sort -k2) |\n    LANG=C join -e 0 -1 1 - -2 2 <(uniq -c \"$cache_contrib_github\" | LANG=C sort -k2) |\n    awk 'function max(x,y){return x<y?y:x;}{printf(\"%4d %s\\n\",max($2,$3)+$4,$1)}' |\n    sort -rnk1 |\n    awk 'function xflush() {if(c!=\"\"){printf(\"%4d %s\\n\",c,n);}} {if($1!=c){xflush();c=$1;n=$2}else{n=n\", \"$2;}}END{xflush()}' |\n    ifold -w 131 -s --indent=' +[0-9] +'\n  echo\n}\n\n#------------------------------------------------------------------------------\n# sub:release-note\n#\n# 使い方\n# ./make_command.sh release-note v0.3.2..v0.3.3\n\nfunction sub:release-note/help {\n  printf '  release-note v0.3.2..v0.3.3 [--changelog CHANGELOG]\\n'\n}\n\nfunction sub:release-note/read-arguments {\n  flags=\n  fname_changelog=memo/ChangeLog.md\n  while (($#)); do\n    local arg=$1; shift 1\n    case $arg in\n    (--changelog)\n      if (($#)); then\n        fname_changelog=$1; shift\n      else\n        flags=E$flags\n        echo \"release-note: missing option argument for '$arg'.\" >&2\n      fi ;;\n    esac\n  done\n}\n\nfunction sub:release-note/.find-commit-pairs {\n  {\n    echo __MODE_HEAD__\n    git log --format=format:'%h\u001c%s' --date-order --abbrev-commit \"$1\"; echo\n    echo __MODE_MASTER__\n    git log --format=format:'%h\u001c%s' --date-order --abbrev-commit master; echo\n  } | awk -F '\u001c' '\n    /^__MODE_HEAD__$/ {\n      mode = \"head\";\n      nlist = 0;\n      next;\n    }\n    /^__MODE_MASTER__$/ { mode = \"master\"; next; }\n\n    function reduce_title(str) {\n      str = $2;\n      #if (match(str, /^.*\\[(originally: )?(.+: .+)\\]$/, m)) str = m[2];\n      gsub(/[\"`]/, \"\", str);\n      #print str >\"/dev/stderr\";\n      return str;\n    }\n\n    mode == \"head\" {\n      i = nlist++;\n      titles[i] = $2;\n      commit_head[i] = $1;\n      title2index[reduce_title($2)] = i;\n    }\n    mode == \"master\" && (i = title2index[reduce_title($2)]) != \"\" && commit_master[i] == \"\" {\n      commit_master[i] = $1;\n    }\n\n    END {\n      for (i = 0; i < nlist; i++) {\n        print commit_head[i] \":\" commit_master[i] \":\" titles[i];\n      }\n    }\n  '\n}\n\nfunction sub:release-note {\n  local flags fname_changelog\n  sub:release-note/read-arguments \"$@\"\n\n  ## @arr commits\n  ##   この配列は after:before の形式の要素を持つ。\n  ##   但し after は前の version から release までに加えられた変更の commit である。\n  ##   そして before は after に対応する master における commit である。\n  local -a commits\n  IFS=$'\\n' eval 'commits=($(sub:release-note/.find-commit-pairs \"$@\"))'\n\n  local commit_pair\n  for commit_pair in \"${commits[@]}\"; do\n    local hash=${commit_pair%%:*}\n    commit_pair=${commit_pair:${#hash}+1}\n    local hash_base=${commit_pair%%:*}\n    local title=${commit_pair#*:}\n\n    local rex_hash_base=$hash_base\n    if ((${#hash_base} == 7)); then\n      rex_hash_base=$hash_base[0-9a-f]?\n    elif ((${#hash_base} == 8)); then\n      rex_hash_base=$hash_base?\n    fi\n\n    local result=\n    [[ $hash_base ]] && result=$(awk '\n        sub(/^##+ +/, \"\") { heading = \"[\" $0 \"] \"; next; }\n        sub(/\\y'\"$rex_hash_base\"'\\y/, \"'\"$hash (master: $hash_base)\"'\") {print heading $0;}\n      ' \"$fname_changelog\")\n    if [[ $result ]]; then\n      echo \"$result\"\n    elif [[ $title ]]; then\n      echo \"- $title $hash (master: ${hash_base:-N/A}) ■NOT-FOUND■\"\n    else\n      echo \"■not found $hash\"\n    fi\n  done | tac\n}\n\n# 以下の様な形式のファイルをセクション毎に分けて出力します。\n#\n# [Fixes] - foo bar\n# [New features] - foo bar\n# [Fixes] - foo bar\n# [Fixes] - foo bar\n# ...\nfunction sub:release-note-sort {\n  local file=$1\n  awk '\n    match($0, /\\[[^][]+\\]/) {\n      key = substr($0, 1, RLENGTH);\n      gsub(/^\\[|]$/, \"\", key);\n\n      line = substr($0, RLENGTH + 1);\n      gsub(/^[[:blank:]]+|[[:blank:]]+$/, \"\", line);\n      if (line == \"\") next;\n      if (line !~ /^- /) line = \"- \" line;\n\n      if (sect[key] == \"\")\n        keys[nkey++] = key;\n      sect[key] = sect[key] line \"\\n\"\n      next;\n    }\n    {print}\n\n    END {\n      for (i=0;i<nkey;i++) {\n        key = keys[i];\n        print \"## \" key;\n        print sect[key];\n      }\n    }\n  ' \"$file\"\n}\n\n#------------------------------------------------------------------------------\n\nfunction sub:list-functions/help {\n  printf '  list-functions [-p] files...\\n'\n}\nfunction sub:list-functions {\n  local -a files; files=()\n  local opt_literal=\n  local i=0 N=$# args; args=(\"$@\")\n  while ((i<N)); do\n    local arg=${args[i++]}\n    if [[ ! $opt_literal && $arg == -* ]]; then\n      if [[ $arg == -- ]]; then\n        opt_literal=1\n      elif [[ $arg == --* ]]; then\n        printf 'list-functions: unknown option \"%s\"\\n' \"$arg\" >&2\n        opt_error=1\n      elif [[ $arg == -* ]]; then\n        local j\n        for ((j=1;j<${#arg};j++)); do\n          local o=${arg:j:1}\n          case $o in\n          (p) opt_public=1 ;;\n          (*) printf 'list-functions: unknown option \"-%c\"\\n' \"$o\" >&2\n              opt_error=1 ;;\n          esac\n        done\n      fi\n    else\n      files+=(\"$arg\")\n    fi\n  done\n\n  if ((${#files[@]}==0)); then\n    files=($(find out -name \\*.sh -o -name \\*.bash))\n  fi\n\n  if [[ $opt_public ]]; then\n    local rex_function_name='[^[:blank:]()/]*'\n  else\n    local rex_function_name='[^[:blank:]()]*'\n  fi\n  sed -n 's/^[[:blank:]]*function \\('\"$rex_function_name\"'\\)[[:blank:]].*/\\1/p' \"${files[@]}\" | sort -u\n}\n\nfunction sub:first-defined {\n  local name dir\n  for name; do\n    for dir in ../ble-0.{1..3} ../ble.sh; do\n      (cd \"$dir\"; grc \"$name\" &>/dev/null) || continue\n      echo \"$name $dir\"\n      return 0\n    done\n  done\n  echo \"$name not found\"\n  return 1\n}\nfunction sub:first-defined/help {\n  printf '  first-defined ERE...\\n'\n}\n\n#------------------------------------------------------------------------------\n\nfunction sub:scan-words {\n  # sed -E \"s/'[^']*'//g;s/(^| )[[:blank:]]*#.*/ /g\" $(findsrc --exclude={wiki,test,\\*.md}) |\n  #   grep -hoE '\\$\\{?[_a-zA-Z][_a-zA-Z0-9]*\\b|\\b[_a-zA-Z][-:._/a-zA-Z0-9]*\\b' |\n  #   sed -E 's/^\\$\\{?//g;s.^ble/widget/..;\\./.!d;/:/d' |\n  #   sort | uniq -c | sort -n\n  sed -E \"s/(^| )[[:blank:]]*#.*/ /g\" $(findsrc --exclude={memo,wiki,test,\\*.md}) |\n    grep -hoE '\\b[_a-zA-Z][_a-zA-Z0-9]{3,}\\b' |\n    sed -E 's/^bleopt_//' |\n    sort | uniq -c | sort -n | less\n}\nfunction sub:scan-varnames {\n  sed -E \"s/(^| )[[:blank:]]*#.*/ /g\" $(findsrc --exclude={wiki,test,\\*.md}) |\n    grep -hoE '\\$\\{?[_a-zA-Z][_a-zA-Z0-9]*\\b|\\b[_a-zA-Z][_a-zA-Z0-9]*=' |\n    sed -E 's/^\\$\\{?(.*)/\\1$/g;s/[$=]//' |\n    sort | uniq -c | sort -n | less\n}\n\nfunction sub:check-dependency/identify-funcdef {\n  local funcname=$1\n  grep -En \"\\bfunction $funcname +\\{\" ble.pp src/*.sh | awk -F : -v funcname=\"$funcname\" '\n    {\n      if ($1 == \"ble.pp\") {\n        if (funcname ~ /^ble\\/util\\/assign$|^ble\\/bin\\/grep$/) next;\n        if (funcname == \"ble/util/print\" && $2 < 30) next;\n      } else if ($1 == \"src/benchmark.sh\") {\n        if (funcname ~ /^ble\\/util\\/(unlocal|print|print-lines)$/) next;\n      }\n      print $1 \":\" $2;\n      exit\n    }\n  '\n}\n\nfunction sub:check-dependency {\n  local file=$1\n  grep -Eo '\\bble(hook|opt|-[[:alnum:]]+)?/[^();&|[:blank:]'\\''\"]+' \"$file\" | sort -u |\n    grep -Fvx \"$(grep -Eo '\\bfunction [^();&|[:blank:]'\\''\"]+ +\\{' \"$file\" | sed -E 's/^function | +\\{$//g' | sort -u)\" |\n    while read -r funcname; do\n      location=$(sub:check-dependency/identify-funcdef \"$funcname\")\n      echo \"${location:-unknown:0}:$funcname\"\n    done | sort -t : -Vk 1,2 | less -FSXR\n}\n\n#------------------------------------------------------------------------------\n# sub:check-readline-bindable\n\nfunction sub:check-readline-bindable {\n  join -v1 <(\n    for bash in bash $(compgen -c -- bash-); do\n      [[ $bash == bash-[12]* ]] && continue\n      \"$bash\" -c 'bind -l' 2>/dev/null\n    done | sort -u\n  ) <(sort lib/core-decode.emacs-rlfunc.txt)\n}\n\n#------------------------------------------------------------------------------\n\nif (($#==0)); then\n  sub:help\nelif declare -f sub:\"$1\" &>/dev/null; then\n  sub:\"$@\"\nelse\n  echo \"unknown subcommand '$1'\" >&2\n  builtin exit 1\nfi\n"
        },
        {
          "name": "memo",
          "type": "tree",
          "content": null
        },
        {
          "name": "note.txt",
          "type": "blob",
          "size": 1239.091796875,
          "content": "# -*- coding: utf-8; fill-column: 79 -*-\n\n拡張\n\n  * compopt -o ble/filter-by-prefix\n    プログラム補完に於いて補完関数内で指定した場合、\n    生成される候補を接頭辞が一致するものだけに絞り込む。\n\n  * compopt -o ble/syntax-raw\n  * compopt -o ble/no-mark-directories\n  * compopt -o ble/prog-trim\n  * compopt -o ble/no-default\n  * HISTCONTROL=strip\n\n制限\n\n  * ble.sh を attach しているとき builtin read -e は動かない。\n    代わりに ble.sh が定義したシェル関数 read (組み込みコマンドを上書き)\n    を用いて read -e を呼び出す必要がある。\n\n  * bash-3 C-d について\n\n    今は何とか C-d を処理する事に成功しているが完全ではない。\n\n    1 C-d を押した時に bash が出力するエラーメッセージを使って捕捉している。\n      このエラーメッセージは言語や設定によって異なると思われる。\n      現在は以下のメッセージを調べている。\n      - 'Use \"exit\" to leave the shell.'\n      - 'ログアウトする為には exit を入力して下さい'\n      - 'シェルから脱出するには \"exit\" を使用してください。'\n      自分の bash が異なるメッセージを出力する時は\n      それを bleopt_ignoreeof_message に設定する。\n    2 連続で沢山 C-d を押すと \"^D\" が echo されて表示が乱れるかもしれない。\n      最悪の場合 C-d によって bash プロセスが落ちる可能性もあるかもしれない。\n      (未だ落ちた事はないが)。\n    3 C-d を処理する為に SIGUSR1 を使用している。\n      その為 SIGUSR1 を別の目的で使用する事は出来ない。\n\n  * 文字コードについて\n\n    現在は基本的に UTF-8 を想定している。\n    それ以外の環境のためには少なくとも以下の修正が必要になる。\n\n    - ble.sh 自体を iconv で変換する事。或いは日本語を完全に排除する事。\n\n      現在のところは日本語はコメント中にしか含まれていないはずである。\n      コメントさえ削除すれば何処でも動くようになっていると良い。\n\n    - 使いたい文字コード → unicode のデコーダを自分でかく事:\n      これは \"function ble-decode-byte+文字コード\" を実装すれば良い。\n\n    - Unicode → 文字のコードが正しく動作する様にする事:\n      これは .ble-text.c2s (ble-core.sh) の辺りを直せばよい。\n      \"ble-text-c2b+文字コード\"\n      \"ble-text-b2c+文字コード\"\n      も実装する必要がある。\n\n    - ble/encoding:$bleopt_input_encoding/generate-binder\n\n      現在 \"C-@\", \"ESC\" 及び \"ESC *\" を bind する為に、\n      その符号化形式の非正規な符号に変換している。\n      この変換はシェル関数 ble/encoding:$bleopt_input_encoding/generate-binder\n      において文字符号化方式毎に (UTF-8 前提の設定を上書きする形で) 定義する。\n\n      また bind を記録したキャッシュは $bleopt_input_encoding 毎に保持するが、\n      このキャッシュの更新は bind.sh のタイムスタンプしか見ていない (ble-decode/bind 内)。\n      新しい符号化方式を定義する時には、タイムスタンプを参照するファイル\n      (ble/encoding:$bleopt_input_encoding/generate-binder を定義するファイル) を決める必要がある。\n\n\n    他の文字コードは未だ一回も実装していないので上記以外にも必要な作業が出て来る可能性がある。\n\n    + 2015-11-30 Note: ble-decode.sh (generate-source-to-unbind-default)\n\n      文字コード実装時に問題があるかも。\n\n      現在、bind -sp が出力する中途半端なバイトを解釈する為に、LANG=C で awk を起動している。\n      UTF-8 の場合には複数バイト文字を構成するバイトは ASCII 文字と被らないので問題ないが、\n      Shift_JIS 等の場合には ASCII 文字、特に \\ や \" を含む可能性がある。\n      この場合には LANG=C にしていると問題が生じる。\n      というか、bind -sp の出力する中途半端な文字と、複数バイト文字の一部を本質的に区別する方法はない様に思われる。\n\n      ただし、救いは、もし ble.sh を plain な bash の上で起動するとすれば\n      日本語で bind -sp に登録がなされていることはないだろうということである。\n      つまり、ユーザが手で (或いは .inputrc に) bind '\"日本語\":\"にほんご\"' などとしない限りは問題は生じない。\n\n  * bash-4.0, 4.1 において特殊シェル変数 FUNCNAME をユーザが unset した上で、\n    関数内から ble.sh を source すると ble の使う連想配列がローカルに定義され問題になる。\n\n    - bash-4.0 以降では連想配列を用いるが bash-4.2 未満では、\n      連想配列を明示的にグローバルに配置することができない。\n\n    - FUNCNAME がユーザによって削除されていなければ、\n      この変数を用いて関数内から source されたことを検知できるので、\n      その時には配列実装に fallback する。\n      FUNCNAME が削除されていると fallback に正しく切り替わらずに問題になる。\n\n  * bash-4.3 では C-x は、次の文字が来るまでは受信できない。\n    bash-4.0 - 4.4 の他の version では遅延はないのでこれは bash-4.3 特有の問題である。\n\n  * 構文に従った着色の中には bash の不自然な振る舞いや、\n    複雑な振る舞いのために正確さを諦めた物がある。\n\n    - bash の最初の [@()] の構文解析とパス名展開時の解析の齟齬\n\n      echo [@(echo|[...])]\n\n      恐らく bash は最初の単語の切り出しで @() を一単位として読み取り、\n      [\"@(echo|[...])\"] の様に読み取る。その上で、改めてパス名展開を適用するが、\n      その時には [\"@(echo|[..\"]\")]\" の様に解釈する。\n      つまり、初めの構文解析とパス名展開の適用の間に齟齬がある。\n\n      ble.sh では構文解析に従った解析・着色をすることにしたので、\n      実際のパス名展開の適用結果が着色と異なることがあることに注意する。\n\n    - bash echo {@(,)}\n\n      これについても上と同様のことが起こる。\n      単語の切り出しは {\"@(,)\"} となり、構文エラーは発生しない。\n      後のブレース展開では {\"@(\",\")\"} と解釈されて分割される。\n      単語が分断されてしまうのでパス名展開は起こらない。\n\n    - bash のブレース展開時の ${var:-...}{,} の解析とパラメータ展開時の解析の齟齬\n\n      echo ${var:-{a,b}{a,b}\n\n      恐らく bash は最初にブレース展開を試みる時に、\n      ${} の中については {} の入れ子を数えてスキップする。\n      従って、上のコマンドの時は ${} が終端しないのでブレース展開は試みられない。\n      しかし、パラメータ展開が実施される時には {} の入れ子は考慮に入れられず、\n      最初に現れた \"}\" で終端するので、${var:-\"{a,b\"}\"{a,b}\" という解釈になる。\n\n      [予定]\n      ble.sh ではどの様に着色するか微妙である。\n      理想的には最終的な解釈の ${var:-\"{a,b\"}\"{a,b}\" に応じた着色にしたいが、\n      後半の {a,b} の部分が {} の入れ子のアンバランスによって\n      無効化されている事を検出するのは困難である。\n      仕方がないので、ブレース展開の {} の入れ子の勘定はバグとして無視する事にする。\n      つまり、echo ${var:-\"{a,b\"}{a,b} という解釈で着色する。\n\n    - bash のチルダ展開の時の echo a[]b]=~ の解析と、パス名展開の時の解析\n\n      チルダ展開の時には a[\"]b\"]=~ とはならず a[]\"b]=\"~ という解釈になるので、チルダ展開は起こらない。\n      一方で、パス名展開のときには a[\"]b\"]\"=~\" という解釈になり、'ab=~' などのファイル名に一致する。\n      ble.sh ではパス名展開の規則の方を優先させる。\n\n    - ble.sh では [[ @({a,b}) ]] のブレース展開が有効であるかの様に着色される。\n\n      実際には、条件コマンドの中ではブレース展開は無効になる。\n      これに正確に対応する為には \"条件コマンドの中の extglob\"\n      に対応する文脈値を定義する必要があるが、煩雑になるので対応していない。\n\n    - ble.sh では echo [{@(a|b),[abc]}] の内部の extglob や [...] が有効であるかの様に着色される。\n\n      しかし、実際にはブレース展開を実行したとしても [] の内部なので、\n      extglob や [...] は不活性化しているはずである。\n      しかし、これも解析が無意味に複雑になるので対応はしない。\n\n    - ble.sh では echo {~user,~user} の内部のチルダ展開に反応しない。\n\n      bash ではブレース展開された後にチルダ展開が実行されるので有効。\n\n    - ble.sh はブレース展開が含まれる変数代入形式単語でも、\n      ブレース展開より前のチルダ展開は有効である。\n\n      bash では変数代入形式の単語の右辺でチルダ展開が起こる。\n      しかし、ブレース展開が含まれている場合には例外としてチルダ展開が起こらない様だ。\n\n      $ a=~:{a,b}:~:echo      → ブレース展開は起こらず、チルダ展開は起こる。\n      $ echo a=~:{a,b}:~:echo → ブレース展開が起こり、チルダ展開は起こらない\n                                 ble.sh では一つ目のチルダ展開の解析時点では、\n                                 次にブレース展開が来ることを知らないので、\n                                 一つ目の ~ はチルダ展開として着色する。\n\n      規則がよく分からないが、取り敢えず ble.sh ではブレース展開が現れたら、\n      それ以降はチルダ展開が無効になるようにしている。\n      具体的には _ble_syntax_bash_command_IsAssign[ctx] の設定されている文脈は、\n      ブレース展開が現れたときに、変数代入形式前の文脈値に戻すようにしている。\n\n    - echo [a[!b\n\n      echo [! の組み合わせは履歴展開にはならない。\n      echo [a[!b] の場合にも履歴展開にはならない。\n      しかし、echo [!a[!b の場合には履歴展開になる。\n      違いは bracket expressions が閉じているか閉じていないかである。\n      然し、それを判定する為には先読みをして単語の最後まで見ないといけない。\n      それは実装上困難なのでこれは諦める。\n\n      (bash の parser がここでどう動作しているのかは不思議ではある。\n      例えば echo [a[!echo\"\"] は無効で [a[!echo\"\" は有効である。)\n\n    - echo $((echo)>/dev/null)\n      よく考えたらこの有名なパターンに対応するのを忘れていた。\n\n    - echo $(case A in A) echo B;; esac)\n      実はこのパターン。Bash-4.0 以降では大丈夫だが、\n      Bash-3.2 以降では構文エラーになる。ble.sh は bash-4.0 以降の振る舞いしかしない。\n\n    - ${#var[...]修飾}\n      この形式は Bash 的には構文エラーになるが、[...] の中身を相当先読みしないと\n      修飾があるかないかを見る事ができないので諦めている。\n\n    - set +H; echo ${!!修飾}\n      これは Bash では構文エラーだが何故かが分からない。\n\n    - {$v,$w}xxx これは $vxxx $wxxx に展開される。\n      つまり、v と xxx がくっついて新しい変数名になる。\n      これは分かりにくい動作だが、これを逆に使う人もあるのかもしれない。\n      実の所、ブレース展開も文法レベルで実施されるべきなのかもしれない。\n\n    - $((a[\\10])) $((a[\"10\"])) ${v:a[\\10]} (bash <= 4.3)\n\n      Bash では最初の解析で a[\\10] の部分が抜き出されて、その後で a[\\10] が処理\n      される。最初の解析では [] の入れ子は考慮されない。一方で \\10 が有効かどう\n      かを判定する為には [] の入れ子を追跡する必要がある (bash-4.3 以下では \\10\n      は [] の外では使えないが中では使える)。ble.sh の実装ではこの場合には []\n      の入れ子は追跡しないことにする。つまり、bash-4.3 以下では $((a[\\10])) が\n      許される筈なのにエラー着色になる。\n\n      Bash-4.4 以上では上記の文脈では [] の内外で振る舞いが一貫しているので実際\n      上の問題は出ない。他にも ((expr)) や ${v:expr} でも同様の入れ子追跡の処理\n      の問題があるが、これらの場合には [] 内部と外部の振る舞いは一貫しているの\n      で実際上の問題にはならない。\n\n    - ${v:a[\"10\"]} に関しても上と同様の問題がある。これは bash-5.1 以下で問題になる。\n\n  * 2019-02-04 プログラム補完関数の中で標準入力は使えない。\n    どうしてもユーザからの入力を得たい場合には、\n    現在の補完が自動補完でない事を確認してから /dev/tty から直接取る事。\n\nbash 実装上で注意するべき事\n\n  * 3.0以上 [Note: これは regcomp の問題かもしれない]:\n    正規表現 '.^' や $'\\n^' は文字列の先頭ではなく行頭に一致する。\n\n    その他の場合 (.*^ など) にはちゃんと文字列の先頭にしか一致しない様だ。\n\n    Ref. #D1869\n\n  * bash-5.2 以上の patsub_replacement に注意する。\n\n    任意の文字列に置換する場合は & が勝手に解釈されない様に \"${var/x/\"$s\"}\" の\n    様に quote すると良い。但し、bash-4.2 では \"${var/x/\"$s\"}\" の \" は literal\n    に解釈されてしまう事に注意する。一番安全なのは一旦変数に代入するという事。\n\n  * 変数の代入は基本的に quote は必要ないが、\n\n    1 チルダで始まる時はチルダ展開を防ぐ為に quote が必要。\n      (変数展開の中にあるチルダは quote しなくても大丈夫)\n\n    2 配列要素を空文字列で連結するときは quote が必要。\n      つまり、IFS= eval 'declare var=${arr[*]}' とすると空白区切りになる。\n      IFS= eval 'declare var=\"${arr[*]}\"' とする必要がある。\n      また IFS が中身のある場合には問題は起こらない。\n\n      - bash-4.3 以降では IFS= eval 'var=${arr[*]}' なら OK\n\n    関係あるか分からないが\n    http://lists.gnu.org/archive/html/bug-bash/2017-04/msg00001.html\n    において以下のような例が紹介されている。これは bash-4.5 で修正されるらしい。\n\n    | bash-4.2$ unset IFS; set ' '; a=$*; printf '<%s>' \"$a\"\n    | < >\n    | bash-4.3$ unset IFS; set ' '; a=$*; printf '<%s>' \"$a\"\n    | <>\n\n  * コマンドをつなぐ && と || の優先順位は同じで左結合である\n    但し、算術式や [[ ]] に登場する && と || はC言語と同じ優先順位である。\n\n  * unset の引数は quote しないとパス名展開の対象である。\n    特に配列要素を消す場合には [...] を quote する必要がある。\n\n  * unset -v または unset -f と明示的に指定しないと、\n    意図せず同名の関数または同名の変数を消去してしまう可能性がある。\n    変数を消す場合でも unset -v と明示する必要がある (ref #D0893)。\n\n  * コマンドの単語中のパラメータ展開は \"\" でクォートする必要がある\n    (ref #D0943)\n\n    特に値として以下の物が含まれている可能性がある時は絶対必要である。\n    先ず始めに IFS に含まれる文字がある場合は意図しない単語分割を抑制する為に \"\" で囲む。\n    次に、グロブの特殊文字 *?[ が含まれている場合にも注意する。\n    shopt -s extglob の時には @( や !( の並びにも注意する必要がある。\n    更に、'\\' が含まれる場合もグロブ特殊文字のクォートに何故か影響を与える様なので注意する。\n    これは例えば shopt -s failglob において、a='\\'; echo $a'*' がエラーメッセージを出す事で分かる。\n\n  [complete 仕様について]\n\n  * compgen -f はクォート除去、チルダ展開を実行する\n    理解できないのはクォート除去した後にチルダ展開をするという事。\n    compgen -f \"'~/'\" としても '~' というディレクトリには決して一致しない。\n    compgen -f \"'\\~/'\" 等とクォートした上に backslash も指定しないと行けない。\n    結局どういう規則なのか分からないので、寧ろ arr=('~/'*) 等の様にするべき。\n\n    Note: ~ だとちゃんと現在のディレクトリ以下のファイルに一致するようだ?\n    Note: compgen -W でも似たような quote 除去・ブレース展開などを行う様だが、\n      それでも理解できる振る舞いになっている。\n    Note: bash --norc で echo \\~/ から補完を実際に実行してみると echo ~/... に書き換わってしまう。\n      何処かで quote が消えてしまっている。これはバグと見做すべきであろう。\n\n  * $ complete -F foo -C bar command と登録すると foo, bar の両方が foo bar の順に実行される。\n    $ complete -C bar -F foo command と登録すると bar foo の順に実行される。\n    しかし、complete -p とすると両者とも\n    complete -C 'bar' -F foo\n    と表示され登録順・実行順についての情報を取り出す事ができない。\n\n    →今試すと必ず foo bar の順序でしか呼び出されない。compgen でも同様に見える。\n\n  * $ complete -F hoge1 -F hoge2 command とすると、-F hoge2 だけ有効になる\n    (complete -p による表示もそうだし、実際に実行されるのも hoge2 だけであった)。\n    -F オプションは後からものによって上書きされるという事の様だ。\n\n  * shopt -q は通常の出力はやめてもエラーメッセージは出す。\n    つまり未実装のオプション (compat* や autocd) について\n    shopt -q をするとエラーメッセージが出力されるので\n    結局 &>/dev/null にリダイレクトしなければならない。\n\n  * locale の環境変数 LC_*/LANG を設定する時は &>/dev/null する必要がある。\n    ref #D1205 #D1341 #D1355\n\n    元々入っていた値が不正な値である場合、\n    元の値を復元した時にエラーメッセージが意図されず出力される。\n\n    ローカル変数として設定する場合は、\n    - 値の復元はどうやら関数の本体を完全に実行し終わった後に起こる様なので、\n      関数の本体自体を &>/dev/null で囲んでも意味はない。\n    - 関数の中で unset を行っても意味はない。\n    - 関数の中でもとの値を設定しても意味はない。\n      関数が抜ける時に改めて設定される様だ。\n\n    IFS= LC_ALL=C read -t 0 &>/dev/null\n    としても復元時のメッセージは何故か抑制できなかった。\n\n    * #D1341 更に、bash-4.1 以下では LC_ALL= LC_COLLATE=C func 等の形式にしても\n      効果が現れない。local LC_ALL= LC_COLLATE=C としないと効かない様である。\n\n      外部コマンドを呼び出す時には問題は起こらない。関数経由でも大丈夫。\n      逆に外部コマンドの時には \"LC_ALL=C awk\" の形式にする必要がある。\n      もしくは \"local -x LC_ALL= LC_COLLATE=C\" とする。\n\n      ng$ aaa() { echo ${#1}; }; LC_CTYPE=C aaa あいうえお\n      ok$ echo あいうえお | LC_CTYPE=C awk '{print length($0)}'\n      ok$ echo あいうえお | LC_CTYPE=C ble/bin/awk '{print length($0)}'\n\n    * 2021-01-15 aaa() { local LC_ALL= LC_CTYPE=C; ... ; } 2>/dev/null の形式でも\n      駄目だという事が判明した。ちゃんとする為には関数内で unlocal までする必要がある?\n\n  * Bash 正規表現はシステムの <regex.h> を使用するので環境依存である。\n\n    Linux においては bash 正規表現の POSIX 文字クラス ([[:alpha:]] など) は\n    ロケールによって何にでも一致するので信用できない。\n    例えば GNU/Linux (Fedora 25) では ja_JP.UTF-8 で [[:alpha:]] は漢字・仮名にも一致する。\n\n  * bind 関数の中で set +o emacs などをして編集モードを無効にすると、\n\n    編集関数の実行自体が中断されるようである。\n    具体的には set +o emacs を含む行だけ実行されて、次の行以降は実行されない。\n    set +o emacs が eval に含まれる場合は eval が終わると共に中断される。\n    また関数内に set +o emacs がある場合は、その関数は最後まで実行されるようだ。\n\n    従って set +o emacs が実行されたことを検知して適切な後処理を実行するのは難しい。\n    更にその後で set -o emacs に戻ってくると変な状態になる。\n    bind -p ではちゃんと hook された状態になっているが、\n    実際に操作してみると keymap はリセットされているように見受けられる。\n    この辺りはもう少し詳しく調べてみないと具体的に何が起こっているかはわからない。\n\n    例: 以下の3行のコマンドを実行しようとすると途中で中断され元の状態には戻らなくなる。\n\n    $ set +o emacs\n    > echo hello\n    > set -o emacs\n\n    直接 readline で実行している場合にはこの問題は起こらない。\n\n  * ble.sh では変数の -i は積極的には使用しないことにした ref #D0894\n\n    関数引数に使用する場合は、そもそも -i の機能を使う機会の方が少ないので\n    全ての関数の引数に適用するのは非効率であり、一部の関数の引数にだけ適用するのは\n    関数の仕様として分かりにくくバグの元である。そもそも算術式展開が必要化どうかは\n    呼び出し元が知っていることのはずなので呼び出し元で算術式展開をするべきである。\n\n    関数内で使用する場合についても明示的に算術式展開を実行すれば良い。\n\n  * bind 関数中の set +v は揮発性 ref #D0930 (Bash 3.0--5.0)\n\n    bind 関数中で set +v 等としてもその状態は\n    次の bind 関数の呼び出しの際には元に戻ってしまう。\n    この振る舞いは試した全ての bash version で共通だった。\n\nbashbug: 実装上で注意するべき事・バグ\n\n  * bash-5.0 -- 4.4 (ref #D1334)\n    trap handler が実行中に return を無引数で呼び出すと、\n    無条件に trap handler 起動直前の $? が関数の終了ステータスになる。\n    POSIX に要求されていると書かれているが解釈に難がある。\n    特に trap handler を抜ける時の戻り値だけに影響を与えるのが自然に思われる。\n\n  * bash-5.0 -- 3.0 (全 version) バグ (ref #D0943)\n\n    $ shopt -s failglob\n    $ a='\\'; echo $a'*'\n\n    これで failglob になる。\\* に一致するファイルは存在しませんのエラーメッセージ。\n    ファイルとして '*', '\\*', '\\a', 'a' 等があっても決して一致しない。\n    これを防ぐ為には、パラメータ展開は必ず \"\" でクォートする様にすれば良い。\n\n  * bash-5.0 -- 3.0 (全 version) バグ\n\n    history -p をコマンド実行中に呼び出すと呼び出す度に履歴項目が減る。\n    これは例えば f1() { history | tail -1; history -p '!!'; history | tail; } として、\n    f1 を実行すると分かる。f1;f1;f1 等とすると一回で3件消える。\n    更に bash-3.0 では bind -x の関数の中であっても history -p を呼び出す度に履歴項目が減る。\n\n  * bash-4.4 -- 4.3 バグ\n\n    \\C-@ 関係に bind -x すると正しく動かない\n    bash-4.4 での動作については未だ確認していない。\n    → bash-4.4 でもやはり動かない。\n\n    これは修正した http://lists.gnu.org/archive/html/bug-bash/2018-03/msg00165.html\n\n  * bash-4.4 -- 3.2, etc\n\n    rex=\"^([^\\$]|\\\\'[^\\\\']*\\\\')+\\$\" && [[ 'i$' =~ $rex ]] && echo hello\n    が一致する。\\' の解釈が謎である。単に ' とすれば問題ない。\n\n    rex=$'^([^$]|\\\\\\'.\\\\\\')+$' でも一致する。\n    rex=$'^([^$]|\\\\\\')+$' だと一致しない。\n    \\' は何らかのアンカーとして解釈されるという事だろうか。\n    或いは単純に無視されているのか。\n\n  * bash-4.2\n\n    declare -g -r var とした時に、\n    グローバル変数が定義されていなければローカルに新しく変数を作る様だ。\n    bash-4.3 で直っている。\n\n  * bash-4.2 以下\n    bash-4.2 ～ bash-3.0\n\n    \\C-x 単体に bind -x して C-x に続けて何か打つと segfault する。\n    $ bind -x '\"\\C-x\":echo' → 続けて C-x a 等と入力\n\n  * bash-4.1 以下: LC_CTYPE=C eval 'echo ${#var}' としても\n    ${#var} が元のロケールで計算される。\"変数代入 コマンド\"\n    の形式だとロケールの初期化が間に合わないのだろうか。\n\n  * bash-4.0 segfault\n\n    以下で segfault を起こすことが分かった。bash-4.1 以降では直っている。\n\n    bash-4.0 -c 'function f1 { COMPREPLY=(alpha); }; compgen -F f1 2>/dev/null'\n\n    但し、ble.sh の使用中に実際に compgen -F を通して segfault になることはなかった。\n    もしかすると何らかの条件が整うと segfault するかもしれないので、\n    念のためここに記録に残しておく。\n\n  * bash-3.2 以下ではプロセス置換に含まれるブレース展開は\n    プロセス置換ごと複製してしまう。\n    例えば echo <(echo {1..3}) は、\n    echo <(echo 1 2 3) ではなくて、\n    echo <(echo 1) <(echo 2) <(echo 3) に展開されてしまう。\n\n  * bash-3.2 以下では declare a としただけで空の値で初期化される。\n    unset 状態になるという事はないので注意を要する。\n\n  * bash-3.2, bash-3.1 では source にプロセス置換を渡しても読み取ってくれない。\n    つまり source <( ... ) としても何も起こらない。\n    代わりに eval -- \"$( ... )\" すると良い。\n\n  * bash-3.2 -- 3.1\n\n    ref #D0857\n    10 以上のファイルディスクリプタで使用されている物に対して\n    リダイレクションで新しい出力先を設定しようとしても失敗する。\n    これは fd>&- として一旦閉じてからリダイレクションすれば良い。\n\n    bash-3.1 では一度開いた fd を改めて開き直したり、\n    或いは閉じたりすることができない。\n    exec 34>/dev/null とすると、exec 34>&- としても閉じれないし、\n    exec 34>a.txt としても /dev/null に繋がったままになってしまう。\n\n  * bash-3.1 では declare -f funcname の funcname に + 等の文字を含める事ができない。\n    一応 declare -F 等とすれば名前は列挙される様ではある。\n    bash-3.2 未満では declare -f ではなく type -t で関数かどうかの確認を行う。\n\n  * bash-3.1 での bind -r について\n    bind -sp とすると \"\\M-[C\" 等と表示されるがそれに従って bind -r '\\M-[C'\n    としても削除する事は出来ない。代わりに bind -r '\\e[C' とすれば削除できる。\n\n    eval -- \"$(bind -sp | awk '/M-\\[/{sub(/:$/,\"\",$1);gsub(/\\\\M-/,\"\\\\e\");print \"bind -r \" $1}')\"\n\n  * msys1, msys2: var='^M' とすると CR が消えてなくなる。\n    msys2 では var=$'\\r' とすれば大丈夫。また変数に入っている物も大丈夫。\n    例えば var=$_ble_term_CR はOKである。\n    msys1 ではそれでも駄目。local var=$'\\r' とすれば大丈夫。\n    変数に入っている物でも local を付けないと消滅してしまう。\n\n    Ref #D1270\n\n  * msys1 では named pipe が未対応。従ってプロセス置換も使えない。\n\nbashbug 算術式周りのバグと注意点\n\n  * bash-3.0 - 4.4.7 算術式:\n\n    条件分岐で実行されない部分でも配列の添字は 0 以上でなければならない。\n    例えば以下はエラーになる @ bash-3.0, 3.1, 3.2, 4.0, 4.2, 4.3\n    ((a=-1,a>=0?b[a]:0))\n\n    もっと調べてみると配列の添字に限らず分岐しない所で式が評価されている様だ:\n\n    + 三項条件式で起こる。true/false branches のどちらでも起こる。&& や || では起こらない。\n\n      $ echo 'x=a=1; ((a=0,0?x:0)); echo $a' | bash      1 (bash-3.0 - 4.3)\n      $ echo 'x=a=1; ((a=0,1?0:x)); echo $a' | bash      1 (bash-3.0 - 4.3)\n      $ echo 'x=a=1; ((a=0,0&&x)); echo $a' | bash       0 (bash-3.0 - 4.3)\n      $ echo 'x=a=1; ((a=0,1||x)); echo $a' | bash       0 (bash-3.0 - 4.3)\n\n      $ echo 'x=a=1; ((a=0,0?b[x]:0)); echo $a' | bash   1\n      $ echo 'x=a=1; ((a=0,0&&b[x])); echo $a' | bash    0 (bash-3.0, 3.1, 4.2+ / bash-3.2, 4.0, 4.1 は別の bug で 1)\n\n    + 括弧で囲めば何も起こらない様だ。\n\n      $ echo 'x=a=1; ((a=0,0?(x):0)); echo $a' | bash    0 (bash-3.0 - 4.3)\n      $ echo 'x=a=1; ((a=0,1?0:(x))); echo $a' | bash    0 (bash-3.0 - 4.3)\n\n      $ echo 'x=a=1; ((a=0,0?(b[x]):0)); echo $a' | bash 0 (bash-3.0, 3.1, 4.2+ / bash-3.2, 4.0, 4.1 は別の bug で 1)\n\n  * bash-4.2 算術式 seg fault\n\n    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00036.html\n    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00042.html\n    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00043.html\n\n    算術式の中で配列要素の参照に関係して特定の式構造になると segfault する。\n    多分、配列要素の読み出しの次の token が整数または代入式の左辺だと落ちる。\n    配列要素を参照したら一旦算術式を閉じるのが良い。\n    $ ((a=b[0],c=0))\n\n    以下でも segmentation fault が起こった。\n    $ (((klen=node[nofs+k])<0||(kbeg=j-klen)>end0))\n    $ (((a=node[1])<2||(b=3)))\n    $ (((a=node[1])||(b=3)))\n    $ (((a=node[1])<2||b)) # OK\n    $ (((a=node[1])||b))   # OK\n    $ (((node[1])||(b=3))) # OK\n    やはり起こる条件が良く分からない。\n    代入式の右辺に配列が来て、\n    その後に代入式の左辺に token があると駄目なのか?\n\n  * bash-4.1, 4.0, 3.2: 算術式分岐内配列参照\n\n    bash-3.2.48 で以下の評価に失敗する。\n    bash-3.1 以下は大丈夫。bash-4.2, bash-4.3 も大丈夫。bash-4.0 は駄目。\n\n    dbg=()\n    ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))) # NG\n    配列添字で値を参照 (代入はOK) すると、その部分以降が必ず実行される。\n    複合代入であっても駄目である。\n\n    bash-4.0 bash-4.1 でも以下の式で必ず _pos[1]++ が実行されていた。\n    ((_eoc[2]&&(_pos[0]=0,_pos[1]++)))\n\n\n    $ ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))); echo $a $b               → 0 1\n    $ expr=\"a=1,x=dbg[0],b=1\"; ((a=0,b=0,0&&expr)); echo $a $b    → 0 1\n    $ expr=\"a=1,x=dbg[0],b=1\"; ((a=0,b=0,0&&(expr))); echo $a $b  → 0 1\n\n    更に配列添字も必ず評価されてしまう。\n    ((i>=0&&a[i])) は i が負であっても参照される。\n    そして、((i>=0&&a[i--])) をすると更に副作用も起こる。\n\n  * bash-4.1 以下 (bash-3.0 ～ bash-4.1)\n\n    配列要素に対して修飾付きのパラメータ展開を実行すると、\n    配列添字に指定した算術式が2回評価される。\n    例えば \"${arr[i++]#a}\" を実行すると i が 2 増える。\n\n  * bash-4.0 他 算術式を使って値を計算する時の注意\n\n    算術式の中に初期化されていない変数…例えば ret 等がある場合、\n    ret の中身に不正な数式的な物が入っていたりコマンド置換が入っていたりすると、\n    文法エラーになったりこれが eval されてしまう。\n    実際に 4.0 では 'あ' という文字列が入っているだけでエラーになる。\n    (より上の version では識別子名と解釈されているからなのかエラーにはならない。\n    しかし、今迄は毎回「あ」等という変数を探していたのだろう。\n\n  * bash-3.1, 3.0\n\n    ?: 演算子の中身は全てカッコで囲まないと構文エラーになる。例えば、\n    $ bash-3.1 -c '((a?(b=123):c?(d=321):1))'\n    bash-3.1: ((: a?(b=123):c?(d=321):1: syntax error in expression (error token is \"?(d=321):1\")\n\nbash 配列の宣言に関する注意点\n\n  * arr=(1 2 3) func の形式で配列をシェル関数に渡そうとすると、\n    export arr='(1 2 3)' で渡されてしまう。\n\n  * 既に配列変数になっている物に対して\n    export var=value や typeset -x var=value をしても、\n    呼び出された別コマンドからは環境変数として見えない。\n\n    $ a=(1 2 3)\n    $ (export a=1; bash -c 'declare -p a')\n    bash: 0 行: declare: a: 見つかりません\n\n    新しい変数として導入すれば良い。\n    例えば関数内で新しく local -x var=value とするか、\n    var=value command の形式で呼び出すようにすれば良い。\n\n    $ (a=1 bash -c 'declare -p a')\n    declare -x a=\"1\"\n\nその他のバグ\n\n  * BUG gawk-4.0.2 正規表現 [][:space:]] や [^][:space:]] に対して警告メッセー\n    ジを出力する。実際には正しく解釈して正しく動作する様である。また、他の gawk\n    version では問題はない。\n\n    これは scan チェックに含める事にする。\n\nbash_features\n\n  * time -- について。\n    bash-5.1 以降で time -- command が可能。\n    bash-4.2 以降で time -p -- command が可能。\n    (bash-4.1 以前では time には -- を指定できない)\n\n  * bash-5.0 以降: EPOCHREALTIME, EPOCHSECONDS\n    ref #D0925\n\n  * Bash-5.0 では POSIX に倣ってパラメータ展開結果に \\ が含まれる場合に\n    グロブパターンと見做す様に変更されたが、\n    これにより問題が起こり POSIX が記述に誤りがあることを認めて修正した。\n    結局 Bash-5.1 で 4.4 と同じ動作に戻すつもりらしい。\n    https://lists.gnu.org/archive/html/bug-bash/2020-03/msg00051.html\n\n  * ${param@a} (attributes) 及び他の transformation は bash-4.4 より\n\n  * read -t timeout\n\n    * -t オプションの対応は 2.04 である。\n    * TMOUT 変数の対応は 2.05b-alpha1 以降である。\n    * 小数を指定できる様になったのは 4.0-alpha 以降である。\n    * `-t 0' で次の文字を読み取り可能かどうかチェックできるのは 4.0 以降である。\n    * 4.3 以下では timeout した時に読み取った入力は失われてしまう。\n      4.4 以降では timeout するまでに読み取った内容が指定した変数に格納される。\n\n  * グローバル変数に対する属性指定 declare -g は bash-4.2 から\n\n    更に bash-4.3 には declare -gA を二度行うとクラッシュするバグがあったらしい。\n    現在の最新版ではそのような振る舞いは見られない?\n\n    2021-02-10 #D1470 どうも bash-4.2 の declare -g にはバグがある。declare -gA\n    とすると属性は global まで適用されるが、代入された値は関数を抜けると共に消\n    滅する。2021-05-20 追記。declare -gA a=() とすると関数を抜けると共に値が消\n    滅するが、declare -gA a; a=() とすると特に問題は生じない。\n\n  * 連想配列 declare -A は bash-4.0 から\n\n  * BASHPID 何と Bash 4.0 以降の機能らしい ref #D1200\n\n    ------------------------------------------------------------------------------\n    This document details the changes between this version, bash-4.0-alpha,\n    and the previous version, bash-3.2-release.\n\n    c.  There is a new variable, $BASHPID, which always returns the process id of\n        the current shell.\n    ------------------------------------------------------------------------------\n\n    と思ったら既にソースコードの一部にも Bash 4.0 以降であるとの注記があった。\n\n  * command |& command は Bash 4.0 以降なので使えない。\n\n  * printf -v var %s value\n\n    bash-3.1 以降で使える。\n    bash-4.1 以降で var として配列要素 (arr[123] 等) を指定できる。\n\n  * printf %(...)T は bash-4.2 以降から。但し、bash-4.2 では -1 を明示的に指定\n    しないと現在時刻になってくれずに 0 になってしまう。bash-4.3 以降では省略し\n    た場合は現在時刻になる。\n\n  * ${!arr[@]} は bash-3.0 より\n\nbash_tips\n\n  * swap の仕方\n    local a=$b b=$a\n    local や declare などは必要である。\n\n  * [[ ]] の中で =~ で設定された BASH_REMATCH は直後の式で参照できる。\n    つまり [[ $text =~ $rex && $BASH_REMATCH == ... ]] の様にできる。\n\n    bash-3.0 から bash-4.4 までで以下のコマンドで確かめた。\n\n    [[ \"\" =~ ^ ]]; [[ $BASH_REMATCH ]]; [[ a =~ a && $BASH_REMATCH ]]\n\n  * 構文関係でマニュアルに載っていないものが色々ある。\n\n    * }, fi, done, esac の直後に }, fi, done, esac, do, else, elif, then が来る場合はセミコロンは省略できる。\n\n    * for ((expr1; expr2; expr3)) [ ; ] { list; } は比較的有名だが、\n      for name [in name]; { list; }\n      select name [in name]; { list; } も使える様だ。\n\n    * select name [ [ in word ... ] ; ] do ...; done\n      ※in word ... がない場合、do の前のセミコロンは省略可能である。\n\n  * \"$(case *) ;; esac)\" に対応する可能性があるかと思ったが動きはない\n    ref http://lists.gnu.org/archive/html/bug-bash/2017-11/msg00002.html, #D0928\n\n  * function @() { ...; } は成功するが実際には関数は作られない\n    ref http://lists.gnu.org/archive/html/bug-bash/2017-03/msg00220.html, #D0927\n\n  * declare -c var という隠し属性がある。Capitalize する。Bash 4.0+\n    変数の値の各単語について適用するのではなく本当に最初の文字にしか適用されない。\n    この中途半端な機能の為に恐らくマニュアルに載っていないのだろう。\n\n    ソースコードを確認すると他にも declare -G var という謎機能が存在する。\n    同じ文脈に局所変数があればそれに設定してそれ以外ならば大局変数に設定する。\n    これは丁度他の言語のレキシカルスコープを真似た物という事だろうか。\n\n  * nameref & extra expansion\n    気付いたのだが declare -n ref='arr[...]' の ... に任意の式を記述できる。\n    これによって新しい乱数変数も定義できるのでは。例えば。\n\n    declare -n var='var_[var_=RANDOM*RANDOM,0]'\n\n    但し、算術式なので整数以外は代入できない。\n    更に、$() でプログラムを実行することすらできる。\n    然し、任意の文字列という訳には行かないのが問題。\n    $() はサブシェルで実行されるので副作用を残す事ができない。\n\n  * let & brace expansion\n    これは算術式のページに既に書いた。\n\n  * rcfile を処理している間は\n\n    * 関数内で FUNCNAME, BASH_SOURCE, BASH_LINENO を確認するとFUNCNAME\n      の最後の要素は \"source\" であり、BASH_LINENO の最後の要素は 0 に\n      なっている。BASH_SOURCE の最後の要素がファイル名である。\n\n    * bash-4.4 以降では $- に s (標準入力から読み取り中) が含まれない\n      事で確かめられる。bashrc を抜けてPROMPT_COMMAND を実行する時には\n      s が含まれる様になる。bash-4.4 未満では s は決して含まれない事に\n      注意する。\n\n    まとめると以下の様な関数で rcfile 中で走っているかどうかを判定できるのではないか。\n\n    function ble/util/is-running-in-rcfile {\n      [[ $- == *i* && ( _ble_bash -lt 40400 || $- != *s* ) ]] || return 1\n      local nstack=${#BASH_LINENO}\n      [[ ${BASH_LINENO[nstack-1]} == 0 && ${FUNCNAME[nstack-1]} == source ]]\n    }\n\n\f\n*******************************************************************************\n    Memo\n-------------------------------------------------------------------------------\n\n2023-01-31\n\n  * review: direnv [#M0023]\n\n    direnv は .envrc を bash で評価して、環境変数の変更を調べて、それを各シェル\n    の変数に反映させるらしい。これにより使うシェルに依存せず一つの .envrc で同\n    時に対応できる。然し一方でこれが意味する所は、環境変数だけしか親シェルに反\n    映させる事ができないのだろうという事。ローカルな関数やエイリアスは引き継が\n    れない (或いはエイリアスであれば可能であろう)? また環境変数に制限する事によっ\n    てディレクトリに入る前の環境変数のセットをそのまま保存する事によって\n    push/pop を自前で実装しなくて済む様になっている。\n\n    .envrc は direnv allow しないと有効にならない。このallow/unallowedの情報は\n    どこに記録しているのだろうか。うーん。別の箇所にディレクトリを作成している\n    様にも見える。うーん。\n\n    https://github.com/bbugyi200/funky これは各ディレクトリの中にデータベースファ\n    イルを作って local functions を保存する事によって動く。グローバルに使える関\n    数も定義できる (が .bashrc で定義するのと比べて何が違うのか謎)。\n\n    https://github.com/cxreg/smartcd これは機能的になかなか参考になる気がする。\n    README の see also のまとめが参考になる。\n    https://github.com/cxreg/smartcd#see-also\n\n    https://github.com/Tarrasch/zsh-autoenv ... smartcd SEE ALSO による\n    と、~/.autoenv_authorized に実行して良い env ファイルが記録されているそうだ。\n\n    https://github.com/hyperupcall/autoenv ... これは bash にも対応している。記\n    録ファイル ~/.autoenv_authorized は zsh-autoenv と同じ様である。\n\n    https://github.com/jamesob/desk ... これも似たような事を実装しているが、恐\n    らく予め設定した内容だけでなく現在のディレクトリやコマンド履歴などの動的な\n    情報も「セッション」として記録している気がする。然しここまで来ると screen\n    で良いのではないかという気がしてくる。\n\n2021-12-31\n\n  * \"function f {}\" vs \"f() {}\" [#M0022]\n\n    function f は元々は ksh functions で、POSIX functions f() とは局所変数の取\n    り扱いが異なる。ksh では f() の形式の関数では局所変数を定義できない。ksh\n    functions ではその関数で宣言したローカル変数またはグローバル変数しか見えな\n    い。この背景から function f() という両方を組み合わせた形で書くと鬼の首を撮っ\n    たかの様に指摘してくる人がいる (Greg Wooledge だったか)。\n\n    f() の形式の場合には f の部分は alias 展開の対象である。例えば alias\n    die=std::die 等として名前空間を import している時に、関数を上書きしたい時に\n    それが alias されているという事を意識せずに直接 die() { ... } 等として上書\n    きする事ができる。\n\n    function ... の場合には、f() の形式では定義できない、特別な文字を含んだ関数\n    も定義する事ができる。POSIXLY_CORRECT の時には結局どちらの形式を使ったとし\n    ても、識別子以外の名前で関数を定義する事はできないのであるが。\n\n    Bash 5.0 以前では function hello の直後にはサブシェル () を本体とした定義は\n    置けない。文法的にはこれが当たり前の様な気もするが、Bash 5.1 以降では直後に\n    サブシェルを置ける様である。例えば function f(echo) など。\n\n2021-05-16\n\n  * Linux パッケージのチェック (by killermoehre) [#M0021]\n    どの Linux にどのパッケージのどの version が入っているかを調べられるサイト\n    https://pkgs.org/search/?q=groff\n\n2021-05-15\n\n  * PKGBUILD の説明は此処にある [#M0020]\n    https://wiki.archlinux.org/title/VCS_package_guidelines\n    https://wiki.archlinux.jp/index.php/PKGBUILD\n    https://wiki.archlinux.jp/index.php/%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E4%BD%9C%E6%88%90#.E9.96.A2.E6.95.B0_pkgver.28.29\n\n    PKGBUILD と一緒に.SRCINFO も更新すること。\n\n    $ makepkg --printsrcinfo > .SRCINFO\n\n    pkgrel は新しい pkgver に変わったら一緒に 1 に変更する。\n\n    blesh-git の最新の pkgver は以下の様にして取得する\n\n    $ (cd ~/.mwg/src; source ble.sh/ext/aur.blesh-git/PKGBUILD; pkgver)\n\n    PKGBUILD のチェックは以下で行う\n\n    $ namcap PKGBUILD\n\n2021-05-03\n\n  * awk の互換性に関する注意点 [#M0019]\n\n    * 正規表現 {m,n} は gawk-4 以降でしか既定で使えない。gawk-3 も nawk も mawk\n      も駄目。\n\n      POSIXに反しているが過去の互換性の為という事らしく gawk-3 では\n      POSIXLY_CORRECT またはオプション --posix または --re-interval を指定すれ\n      ば利用できる様になるが、nawk/mawk はそういうオプションすらない。\n\n    * 正規表現 A?A? は mawk では最初の A? しか一致しない。\n\n      これは明らかにバグの気がするがどうなのだろうか。\n\n    * 16進リテラル 0xHHHH は gawk でしか使えない。\n\n2021-05-01\n\n  * ble.sh 初期化時の Bash 設定に対する対策 [#M0018]\n\n    ble.sh が set -euxv -o posix や FUNCNEST=0 等特殊な状況で呼び出される事がある。\n    この様な環境ではまともに動作する事ができないので設定を適切な順序で解除してい\n    く必要がある。\n\n    set -eu に関しては適切な記述方法を取れば回避する事ができるので後回しにする。\n    set -xv に関しても標準エラー出力を適当な物に繋いで置けば回避できる。set -o\n    posix が設定されていると関数を定義できない。その他の振る舞いにも注意が必要だ\n    ろう。alias も何が定義されているか分からないので出来るだけ expand_aliases を\n    off にする方向で考えたい。\n\n    現在の実装では以下の順にチェック・対策を行っている。\n\n    1 最初の引数解析 (POSIX shell 準拠): この部分は別のシェルで起動した場合などで\n      も引数解析の結果などを表示する為に対策よりも前に処理する。alias で { や if\n      が書き換えられている事によって失敗しても、シェルが全く操作できなくなるとい\n      う事はないだろうし、ユーザー側の責任とする。\n\n    2 Bash のバージョンチェック。これをしないとそもそも対策コード自体動くか怪しく\n      なってくるので先にチェックする必要がある。これもシェルが全く操作できなくな\n      るという事はないだろうという事で、ユーザー側の責任とする。\n\n    3 expand_aliases\n    4 FUNCNEST\n    5 set +o posix\n\n      この三つを設定すれば取り敢えず安全に関数を定義して実行できる。\n\n    6 reset-builtins\n\n      builtin が上書きされてしまうのを防ぐ為。\n\n    7 adjust-options (set +euxv; shopt -u nocaseglob; shopt -u expand_aliases)\n\n2020-05-11\n\n  * Bash の HISTTIMEFORMAT 振る舞いのまとめ [#M0017]\n\n    ref #D1351\n\n    * Bash は、HISTTIMEFORMAT の値に関係なく、コマンドの時刻を常に内部\n      的に管理している (#0x10 の件を考えると文字列で記録している疑いが\n      ある)。HISTTIMEFORMAT が設定されている時、history コマンドで出力\n      されるコマンド履歴に時刻が出力される。\n\n    * 変数 HISTTIMEFORMAT が存在する時 (空文字列や unset も含む)、Bash\n      は履歴ファイルに #%s の形式で時刻を保存する。\n\n    * 履歴ファイルからコマンドを読み取る時、直前に #%s があればそれを\n      コマンドの時刻とする。それ以外の時はコマンドの時刻は bash の起動\n      時刻とする。これは HISTTIMEFORMAT の状態に関係ない。\n\n      履歴ファイルから読み取る時には単一行モードと複数行モードがある様\n      だ。変数 HISTTIMEFORAMAT が存在 (空文字列や unset も含む) してか\n      つファイルの先頭行が #%s の時に複数行モードになる。\n\n      時刻行は \"#数字\" で始まっているかどうかで判定する。先頭または #\n      と数字の間に余分な空白が含まれている場合は時刻行ではない。\"#整数\n      \" の後に別の文字列があったとしてもそれは無視される。但し、\"#0\"\n      で始まっている時だけは行全体を時刻と見做すようで、余分な文字列が\n      あると history で出力する際にエラーになる。\n\n    * history コマンドの出力は HISTTIMEFORMAT が非空文字列の時にタイム\n      スタンプが出力される。\n\n      HISTTIMEFORMAT が設定されていても空文字列の時には処理は行われな\n      い。これは通常の見た目の振る舞いでは区別がつかない (処理していて\n      も処理していなくても出力に違いは出ない) が、履歴ファイルに #0xxx\n      の様な無効なタイムスタンプが含まれていた時の振る舞いで分かる。\n\n    * shopt -s lithist は、for 等の文法的に複数行に跨るコマンドについ\n      て、そのままの形でコマンド履歴に登録する。単にコマンドラインで複\n      数行を入力して実行しても改行で分割してコマンド履歴に登録される。\n\n      これはコマンドを実行した時に Bash プロセスの内部のコマンド履歴に\n      登録する際に影響を与える物であって、履歴ファイルへの書出しや履歴\n      ファイルからの読み出しには影響を与えない様である。\n\n    現在の ble.sh サポートの制限について。\n\n    * mlfix: bash-4.4 以降では複数行コマンドを history -r で読み出せるが、\n      bash-4.3 以前では複数行コマンドは history -s で構築せざるを得ない。\n      従って複数行コマンドに関しては正しくコマンド時刻を復元できない。\n\n2020-05-06\n\n  * trap: DEBUG/RETURN trap のまとめ [#M0016]\n\n    DEBUG trap は設置した関数内で有効。set -o functrace (set -T) が設\n    置されている時または呼び出される関数に declare -tf を設定している\n    時にのみ呼び出される関数に継承される。trap -p の出力は現在処理して\n    いる関数毎に異なる (継承しない場合は DEBUG/RETURN trap に対しては\n    何も出力されない)。\n\n    DEBUG: bash-4.3 以下では設置した関数の呼び出し元には影響はないが、\n    bash-4.4 以降では呼び出し元の DEBUG trap も上書きする。DEBUG trap\n    を削除した場合には、呼び出し元には影響は与えない。DEBUG trap の中\n    では DEBUG trap は発火しない。\n\n    RETURN:\n\n    * BASH_COMMAND には最後に関数内で実行したコマンドが入っている。\n      return を使った場合にはそれが、関数の末端で終わった場合には最後\n      のコマンドが入っている。\n    * RETURN trap は関数内部で実行されるので、return を呼び出して終了\n      ステータスを変更する事ができる。但し、条件をつけないと、RETURN\n      trap の return に対して再び RETURN trap が発火して無限ループにな\n      るので注意する。\n    * RETURN trap の中では RETURN trap は発火しない。それ以外の trap\n      では発火する。\n\n    BASH_LINENO, BASH_SOURCE, FUNCNAME についてはまだ詳しく調べていない。\n\n2020-04-14\n\n  * ${###} 等のパラメータ展開・変数展開について [#M0015]\n\n    Bash のパラメータ展開 #D1330\n\n    <param>\n\n    - 位置パラメータ: 1 2 ...\n    - 特殊パラメータ: * @ # ? - $ ! 0 _\n    - 変数名: /_[[:alpha:]][[:alnum:]]*/ の形式\n    - 配列名[添字]\n      添字はシェル展開の対象で配列の時は算術式の対象\n    - 配列名[@], 配列名[*]\n\n    <modifier>\n\n    - @A 変数の定義\n    - @a 変数の属性\n    - @Q @E @P 値を加工する\n      これらの ops は展開の対象ではない。つまりvar=A として ${xxx@$var} とはできない。\n    - #, ##, %, %%\n    - /, //, /#, /% (クォートとの兼ね合い)\n    - ^ ^^ , ,, ~ ~~\n      Note: ~ については https://qiita.com/t_nakayama0714/items/80b4c94de43643f4be51 に書いてあった。\n    - = + - ? := :+ :- :?\n    - :offset, :offset:length\n\n    * $<param>\n      Note: 配列, 2桁以上の位置パラメータは使えない。\n\n    * ${...} の例外規則\n\n      * ${#<param>}\n        ${#@}, ${#*}, ${#a[@]}, ${#a[*]} は要素の数。\n        それ以外については文字の数。\n\n      * ${!var@} ${!var*}\n\n      * ${!arr[@]} ${!var[*]}\n\n    * ${<param><modifier>}\n    * ${!<param><modifier>}\n\n      * ! で始まる物については ${<param>} を変数名とする。\n\n        Note: <param> は !, $ 以外でなければならない様だ。\n\n        $@ $* ${arr[@]} ${arr[*]} の時には \"$*\" などを変数名と見做す。\n        つまり、普通に ${!arr[*]##} 等とすると要素が1個の時以外はエラーになる。\n        (arr=(a b c); IFS=; abc=4321; echo \"${!arr[*]##}\") 等とすると動く。\n        (arr=(a b c); IFS=; abc=4321; echo \"${!arr[@]##}\") は動かない。\n\n    ★${!#} で最後の引数を取れる。${@:$#} でも行ける。\n      但し、引数がない場合は $0 に展開される事に注意する。\n\n2020-04-07\n\n  * bashrc に於ける history の操作について [#M0014]\n    初回の history -nrs の実行時に \"未初期化\" であれば初期化を行う。\n    \"未初期化\" の判定は履歴がその時に空であるかどうかによる。\n\n    * \"未初期化\" の時に history -awcd を呼び出した時は何も実行しない。\n    * \"未初期化\" の時に history -nrs を呼び出した時は、\n      履歴ファイル (HISTFILE) を読み取って初期化した後に要求された操作を実行する。\n      これは bash の動作とは異なる。bash は履歴ファイルを読まずに操作を実行する。\n      その後で何らかの条件で履歴ファイルの読み取りを最初のプロンプト表示の前に行う。\n    * history -p に関しては \"未初期化\" かどうかに関係なく、そのまま実行する。\n\n    bashrc の中で history -r を実行すると履歴の倍加が発生する。\n    但し、実行時だけで記録される履歴ファイルは倍加しない。\n\n2019-06-10\n\n  * history -na の動作に就いて [#M0013]\n\n    * どのコマンド以降を新しいものとして取り扱うのか。という事について。\n      特に他の Bash が bash_history に書き込んだ新しいコマンドを読み取った時、\n      次に自分が history -a する時にどの範囲のコマンドを追加するのだろうかという事など。\n\n      まとめると Bash の動作は恐らく以下の様になっている。\n      先ず Bash は2つの変数を使っている。ここでは read_index と write_index と呼ぶ事にする。\n      read_index は history -n で HISTFILE から次に読み出すべきコマンドの行番号を保持する。\n      write_index は history -a で次に HISTFILE に書き込むべき history 内のコマンドの番号を保持する。\n      Bash の起動時には read_index も write_index も同じ値に初期化される。\n      history -n を実行すると read_index は HISTFILE の行数に再設定される。\n      write_index は読み取った行数だけ増加する。\n      history -a を実行すると write_index は history の項目数に再設定される。\n      read_index は書き込んだ行数だけ増加する。\n\n      この動作に従うと history -n; history -a や\n      history -a; history -n を実行すると問題が生じる事になる。\n      書き込み済みのデータ・読み取り済みのデータが混ざった時に正しく範囲を表現できない。\n      この事が理由で巷にある同期の設定では history -a; history -cr を実行しているのである。\n\n    * HISTCONTROL=erasedups\n      試してみたが erasedups が設定されていたとしても history -n で新しく読み取った\n      コマンドと同じ名前のコマンドを削除するとかそういう事は別にしない様である。\n\n2019-02-13\n\n  * keymap: 以下のキーについては既定では同じ動作になる様に設定する事にする [#M0012]\n    ref #D0929, #D0752\n\n    - DEL C-? / BS C-h\n    - NUL C-@ C-SP\n    - RET C-m\n    - TAB C-i\n    - C-_ C-DEL C-BS\n\n2019-01-01\n\n  * vi: inclusive/exclusive motion の実装に関して [#M0011]\n\n    exclusive な motion は exclusive-goto.impl を呼び出す。\n    inclusive な motion は inclusive-goto.impl を呼び出す。\n    何れの場合も範囲を修正の後に exclustive-range.impl に委譲する。\n\n2018-08-31\n\n  * decode: 端末の送信するキーシーケンスについて [#M0010]\n\n    * back (BackSpace)\n      xterm は back に対して BS (C-h) を送る。\n      C-back に対して DEL (C-?) を送る。\n      一方で、mintty, RLogin では back に対して DEL (C-?) を送る。\n      C-back に対して C-_ を送る。\n\n    * modifyOtherKeys(2)\n\n2018-08-05\n\n  * compgen に指定した単語のクォート除去に関して [#M0009]\n\n    参考: #D0714\n\n    生成するコマンドの種類と、バージョンによってクォート除去されたりされなかったりする。\n    以下に、クォート除去されることを期待してクォートしても問題がないかをまとめる。\n\n      compgen -A command   クォート不可\n      compgen -A directory クォート不可 (Bash-4.3 以降でクォート除去されない※1)\n      compgen -A file      クォート不可 (Bash-4.0, 4.1 でクォート除去されない※2)\n      compgen -A function  クォート可\n      compgen -A variable  クォート可\n      compgen -A arrayvar  クォート可\n\n    ※1 バグと思われる。ble をロードしていると何故かクォート除去されている。\n      然し、--norc や ble ロードなしで実行するとクォート除去されない。\n      クォート除去が実行されなくなってしまう条件が分からないのでこれは使わない。\n\n    ※2 バグと思われる。\n\n2017-10-31\n\n  * ble 関数の典型的な終了ステータスについて [#M0008]\n\n    127 適切な widget が見つからなかった:\n      (由来: Bash でコマンドが見つからなかった時の値)\n\n    126 処理をキャンセルするとき:\n\n      install-hook した trap に関して、blehook internal_NAME 経由で trap の発火\n      をキャンセルする時に返す値。\n\n      廃止: widget を呼び出すことができなかった (未使用)\n\n    125 widget を呼び出したが適切な処理が見つからなかった:\n\n      __defchar__ に登録した widget がこれを返したとき\n      次のハンドラを用いる。具体的には __default__ の呼び出しを試みる。\n\n    147 ユーザの入力を非同期に待つ為に一時停止した:\n\n      ble/util/idle の処理に於いて条件待ち状態に入る時や、widget に於いてユーザ\n      の入力を待つ為に、自発的に一時中断した時に返す値。\n\n    148 ble/util/idle や isearch や complete に於いて、ユーザ入力を処理する為に\n      一旦現在の処理を中断する時に返す値。vi-mode のオペレータが 148 を返したと\n      き後処理を実行せずにそのまま抜ける (由来: 128+SIGTSTP)\n\n    124 プログラム補完において補完の再実行を要求する\n      (由来: これは Bash の仕様に倣った)\n\n    27 widget の動作がユーザによってキャンセルされた (由来: ESC = 27)\n\n    6 ble-update で更新の必要がなかった時に内部的に使用 (由来: ACK = 6)\n\n    2 コマンドの使い方が異なる\n\n    3 ble/util/bgproc は named pipes がシステムでサポートされていない時に 3 を返す。\n\n2017-10-18\n\n  * ble-decode: widget に関して [#M0007]\n\n    __defchar__ および __default__ に登録された widget が 125 を返した時、\n    その入力に対する適切な処理が見つからなかったことを表します。\n    この時、次のハンドラの探索が行われます。\n    次のハンドラがない場合には対応するものが見つからなかったというエラーになります。\n\n2017-09-24\n\n  * vi-mode 以下は現在のところ対応しない予定である [#M0006]\n\n    * 2017-09-24 vi-mode: % で用いる matchpairs には現在対応しない\n\n    * 2017-09-17 vi-mode (insert mode/newline):\n      インデントを挿入するが何もしなかった時にそれを削除することには対応していない。\n\n      これは実際の所、挿入モードにおける移動と抜ける時の処理において、\n      細工を行えば対応できる。現在の挿入モードの操作の繰り返しの記録の仕組みも使えるが、\n      もっと別の仕組みを用意しても良い気がする。\n\n    * 2017-09-12 vi-mode: タブ文字上にカーソルがある時のカーソルの表示位置\n\n      後、気付いたことはタブ文字に居る時のカーソル位置は、\n      ノーマルモードにいるときはタブ文字の最後の位置である。\n      要するに p で挿入される位置を示しているとも言える。\n      でも全角文字の場合にはちゃんと全角文字の先頭にカーソルが来る。\n      この動作は分かりにくいし更に言うと現状の ble.sh の描画コードでは対応していない。\n      これには取り敢えず対応しないことにする。\n\n    以下は積極的に対応する予定はない。\n    将来的に対応する場合の注意点がある場合も含む。\n\n    * 2017-10-11 M ( ) [[ ]] { } :s :tag\n      これらのコマンドは \"ジャンプ\" なので、$flag なしで実際にジャンプに成功する場合には\n      set-local-mark 96 をする必要がある。\n\n    * done: 2017-10-09 取り敢えず今の所はスクロール (C-b C-d C-e C-u C-y など) には対応しない\n      →これは #D0886 で対応した。\n\n2017-09-08\n\n  * vi-mode: 以下のリンクで重要そうなコマンドの一覧が見られる [#M0005]\n\n    http://qiita.com/sfuta/items/0de4ead865c15e9e9b68 ?\n    http://qiita.com/sfuta/items/2d646396a6117c8e53e5 g? z?\n    http://qiita.com/sfuta/items/fd78f3ece8861f8142ee C-w? [? ]?\n    http://vim-jp.org/vimdoc-ja/vimindex.html\n    http://vim-jp.org/vimdoc-en/vimindex.html\n\n2015-11-28\n\n  * デモ画像の作り方 [#M0004]\n\n    * ble-0.2 のデモ画像はキャプチャソフトを使った (ref #D0926)\n\n      - Cygwin の mintty を用いた。\n        画面の幅は56列にし文字の大きさは14程度が良い。\n      - キャプチャソフトには LICEcap というソフトウェアを使った。\n      - キー入力を表示するソフトには KeyCastOW を改造した物を用いた\n        https://github.com/akinomyoga/KeyCastOW\n\n      ble-0.1 の時に行った基本的な操作に加えて、\n      ble をダウンロード・展開して試してみるところも含めた。\n\n    * ble-0.1 のデモ画像は ttyrec & seq2gif を用いて作成した\n\n      準備\n      $ # PS1=$'[\\e[4;38;5;202mfoo@bar\\e[m \\\\j \\\\W]\\\\$ '\n      $ TTYREC=1\n      $ ttyrec demo.tty\n\n      echo hello, world\n      printf hello\n      [[ a == b ]]\n      echo \"hello $(echo bash $(echo world))\"\n      C-r for\n      echo 'select, copy and paste' コピーする\n      echo insert mode -> overwrite mode\n      ls\n      echo complete ble-TABdTAB histexpand !#:2\n      echo \"$HIST[TAB]\"\n\n      $ seq2gif -f 0 -b 15 -h 14 --render-interval=10 -p rosa --play-speed=1.5 < demo.tty > demo2.gif\n\n      gif のフォーマット的には 0.01s よりも小さな遅延は設定できない。\n      また、現実のブラウザでは 0.02s (50fps) よりも小さな遅延にすると強制的に 0.10 になってしまう。\n      更に、Safari や Internet Explorer では 0.06 (16.67fps) よりも小さな遅延は 0.10 になってしまう。\n      更に、Windows に附属している viewer では 0.10 よりも小さな遅延は全部 0.10 になってしまう。\n\n      [[Frame Delay Times for Animated GIFs by humpy77 on DeviantArt>http://humpy77.deviantart.com/journal/Frame-Delay-Times-for-Animated-GIFs-214150546]]\n      [[How to match animation rate of gif files accross browsers (Fenrir Developer's Blog)>http://blog.fenrir-inc.com/us/2012/02/theyre-different-how-to-match-the-animation-rate-of-gif-files-accross-browsers.html]]\n      [[Nullsleep | Jeremiah Johnson - Animated GIF Minimum Frame Delay Browser Compatibility Study>http://nullsleep.tumblr.com/post/16524517190/animated-gif-minimum-frame-delay-browser]]\n\n\n2015-08-14\n\n  * [memo] builtin check [#M0003]\n\n    eval \"grc --color --exclude=./test '\\b(builtin[[:space:]]+)?$command\\b' | grep -Ev '\\bbuiltin[[:space:]]+$command\\b'\"\n\n  * [memo] leak variables check [#M0002]\n\n    ble/debug/leakvar#list を実行する。\n\n    ble/debug/leakvar#reset var\n    ...\n    ble/debug/leakvar#check var tag1\n    ...\n    ble/debug/leakvar#check var tag2\n\n  * [memo] 解析(ble-syntax/parse)の際の原則 [#M0001]\n\n    データ配列とは _ble_syntax_stat, _ble_syntax_nest, _ble_syntax_tree を指すとする。\n    或る点 p1 から或る点 p2 に解析を進める場合を考える。\n\n    1 この時データ配列に対する変更は p1-p2 (exclusive) の間にだけ行われる。\n      これは解析状態の復元と再開が適切に動作する為に必要である。\n\n    2 解析の過程でデータ配列に格納されている情報は使用しない。\n      これは解析状態の一致チェックの為に必要である。\n      データ配列の内容に依存して動作が代わる場合、\n      解析状態が一致しても解析結果が異なってしまう可能性があり、不整合を生む。\n\n      但し、_ble_syntax_nest については専用の関数を通して 0-p2 の任意の場所を参照しうる。\n      これ(専用の関数を通して得られる情報)については\n      解析状態の一致チェックの対象に含まれているからである。\n      (_ble_syntax_nest の任意の情報を参照して良いという意味ではない。)\n\n    tree-append および nest-pop に対する制限\n\n      tree-append は _ble_syntax_tree[i-1] に格納を行う。\n      従って上記の条件1から p1<=i-1 つまり p1+1 <= i である必要がある。\n      これは少なくとも 1 文字 i を進めてからでないと tree-append を呼び出せないという事である。\n      nest-pop も内部的にそのまま tree-append を呼び出しているので同じ制限がある。\n\n\f\n*******************************************************************************\n    bug-bash, third-party bugs & reviews\n-------------------------------------------------------------------------------\n\n2024-04-22\n\n  * 以下で内部エラーになる\n\n    $ bash-2.05b -c 'f() { exit; }; a=1 eval \"f | :\"'\n    $ bash-dev -c 'f() { exit; }; a=1 eval \"f | :\"'\n\n    これは以前に発見している tempenv のエラーと同根だろう。builtin eval を使っ\n    た時には発生しない。\n\n2023-02-20\n\n  * review: completion 自動生成\n\n    argument-parser と一緒に completion を自動生成する試みがある。\n\n    - spf13/cobra や rsteube/carapace 等の仕組み。\n\n    - https://github.com/adoyle-h/bash-completor\n\n    - ble.sh でも最初期に getopts interface を実装して、これだけで引数パーサー\n      と同時にそれと consistent なコマンド依存単語着色を実装しようと試みた。結\n      局、これは argument parsing 速度が遅いという事で放棄されて\n      archive/getopt1.sh に眠っているが、直接実行するのではなくて、事前に関数を\n      生成して置くという方式にすればそれは気にしなくても良いのかもしれない (但\n      しその分だけ footprint が大きくなる)。実のところ ble-face だとか ble-bind\n      の様に初期化時に大量に呼び出される物でなければ、別に其処まで速度を気にす\n      る必要はない気もする。\n\n    - 最近もシェルで getopts と同時にヘルプ等も自動的に生成しようという試みがあ\n      る。これである。\n\n      https://github.com/ko1nksm/getoptions\n\n    - 他にも類似の物が定期的に github 上に現れる気がするが忘れた。\n\n    ble.sh 的には以下の物を同時に全てしてくれるととても良い。\n\n    - 引数解析器\n    - 引数補完候補生成\n    - 単語着色\n    - 引数指定方法のエラーの検知、診断情報の取得、修正候補の生成\n\n    一般的な枠組みとしては更に以下の様な物もあると便利なのだろう\n\n    - ヘルプ自動生成\n    - 引数に関する単体テストの自動生成 (特殊ファイル名、巨大数、etc.) →でも正\n      しく動作しているかどうかの判定は別で書かなければならないのでは?\n\n\n2023-02-14\n\n  * bug-bash: bash-5.2 で -u extquote しても ${var//[$'\\n']} が改行を削除する。\n\n2023-02-06\n\n  * bug-bash: 実は colored-stats は本来 LS_COLORS を反映するらしい。然し、\n    readline 初期化前に設定されている必要がある。colored-stats も bind 等ではな\n    くて inputrc 経由で有効にしなければならない様だ。\n\n2023-01-31\n\n  * review: bash libraries\n\n    https://blog.fascode.net/2022/05/05/fasbashlib/\n    https://github.com/Hayao0819/FasBashLib ... これはライブラリ構成としてある\n    べき形を一通り備えている様に思える。具体的な関数としてどれだけ非自明なもの\n    が用意されているのかは余り確認していない。Common.sh を見ると悪しき set -Eeu\n    -o pipefail を前提としている。GNU toolchain を要求している。fork を減らすな\n    どの効率化については余り意識されていない気がする。結構 trivial なものまで関\n    数として定義されている。うーん。ForEach だとか Array.Length だとか、既に\n    bash に機能的に存在している物まで関数で wrap したり pipe 化したりと、syntax\n    sugar 的な関数が多く、実践志向ではない。或いは minimalism 的潔さはない。ラ\n    イブラリ構成としてメタ的な機能(naming convention 変換, etc)を揃えているので\n    良さそうと思ったが、それも namespace の模倣のために整えられた枠組みの副産物\n    と見るのが良い気がする。\n\n    FasCode project の一部? で、これは何かと検索すると Alter Linux という日本産\n    Linux distribution を有志で作っている集まりだろうか? Arch based. Issues を\n    見ると日本語メインのコミュニティーで 373 stars. 他に Serene Linux というの\n    も作っていて Ubuntu-based -> Fedora-based に変更したと書いている。作ってい\n    るのは学生の集団らしい。\n\n2023-01-26\n\n  * review: コマンド履歴データベースの設計\n\n    fish はファイル名に一致する引数を覚えている。これにより autosuggestions で\n    は、コマンドライン中のファイル名が現在していない時にはそのコマンドはスキッ\n    プするという具合の振る舞いをする。\n\n    https://github.com/ellie/atuin ... 暗号化・ホスト間共有・C-r拡張・各種統計\n\n    https://github.com/jcsalterego/historian ... 単に .bash_history を検索するだけ\n\n    https://github.com/ddworken/hishtory ... custom column として git_remote が\n    紹介されている。git remote 単体が便利かどうかは分からない。sqlite3 だと\n    column を dynamical に追加するのは難しそう。一方で git の commit id を一緒\n    に記録するというのは一つの可能性である。\n\n    https://github.com/larkery/zsh-histdb ... 実は同じ名前で zsh にもその様な\n    plugin が存在している様である。中を除いてみたら実装はかなり近い形になってい\n    る。履歴を表示するコマンドも用意しているが、余り細かい操作を実行できる訳で\n    もない様だ。\n\n2022-06-26\n\n  * またもや tempenv=... builtin eval ':;echo $tempenv' のバグに引っ掛かった。\n    これはやはり直して貰いたい。\n\n2022-02-15\n\n  * tmpenv builtin eval vs DEBUG trap\n    Ref #D1772\n\n    function print { echo \"v=${v:-(not found)}\"; }\n    function trapdebug { echo \"$FUNCNAME:1:v=($v)\"; }\n    builtin trap 'trapdebug' DEBUG\n    v=xxxx eval print\n    v=xxxx builtin eval print\n\n    以上に於いて builtin eval print で実行される print に対する DEBUG trap の中\n    から v=xxxx が見えない。eval print の時にはちゃんと見えているので意図的な振\n    る舞いとも思われない。\n\n2022-01-23\n\n  * wezterm, bash-preexec に対する patch を終結させる。\n\n    * bash-preexec に API 安定化のお願いをする → これは PR を出したが返事がない。\n      時々活動はあるみたいなので少しでも反応があった時に改めてお願いする事にする。\n\n  * bash-preexec は既存の DEBUG trap を正しく実行できていない様に思われる\n\n    $ trap 'echo XXX' DEBUG\n    $ echo 1; echo 2; echo 3\n    XXX\n    1\n    XXX\n    2\n    XXX\n    3\n    $ source bash-preexec.sh\n    XXX\n    XXX\n    XXX\n    $ echo 1; echo 2; echo 3\n    XXX\n    1\n    2\n    3\n\n    これは意図的な物なのだろうか。。と思ったら以下に議論がある。\n\n    https://github.com/rcaloras/bash-preexec/issues/52\n    https://github.com/rcaloras/bash-preexec/pull/54\n    https://github.com/rcaloras/bash-preexec/pull/109\n\n    o ユーザーが trap DEBUG etc を実行しても破壊されない。\n    o DEBUG trap の overhead がない。\n    o 他の枠組みが DEBUG trap を設定・削除しても問題が起こらない。\n\n2021-12-11\n\n  * bash-completion\n\n    2022-02-02\n\n    * [DraftPR で修正済み] _services が failglob で問題を起こしている。\n\n      _comp_init_set_up_service_completions も駄目。うーん。failglob ではある\n      がこれは自分が修正している途中の物ではない新しい物だろうか? →これは既に\n      fix-failglob　の中に含まれていた。\n\n    * [修正済み] rsync で *-from が云々という failglob が発生している\n      →これは最新版では既に修正されている。\n\n      結局ロードして欲しい bash-completion が全然ロードされない。何故 → 結局ロー\n      カルの場所ではなくて其処で make install されている物が読み出されている様だ\n      が、make install しても何故かずっと古いままという状態になっている様だった。\n      autoreconf -i をし直して実行したらちゃんと新しい物に置き換えられた。make 自\n      体がちゃんと動いていなかったという事になるのだろうか。何れにしてもこれでちゃ\n      んと動く様になった。\n\n    2022-01-23\n\n    683 にも unresolved patch suggestion がある。\n    https://github.com/scop/bash-completion/pull/687#discussion_r790203991 : IFS=$'\\0' in mount\n    https://github.com/scop/bash-completion/pull/687#discussion_r790203132 : mechanism of save/restore shopt\n\n    2022-01-11\n\n    * bash-completion: curl　の抽出オプションが極端に少ないのは何故か→これは\n      curl --help は最低限のオプションしか表示しないから。そして --help all を\n      呼び出せば全部表示される。確認すると --help all は指定されているが、quote\n      されていない。\n\n      類似の問題が過去にあったがその時に一緒に直されなかったのかと思ったが、こ\n      れが正にその時の問題であって、test などが用意されていなかった為に未だマー\n      ジされていないのだった。\n\n      https://github.com/scop/bash-completion/pull/560\n\n    2021-12-22\n\n    * fixed: man の中で _expand を呼び出しているが意味ないのでは? info も同様。\n\n    * man の _expand の直後にある eval は危ない気がする。\n      →これは別項目で議論する。\n\n      info にも同様の問題が存在する。\n\n    * grc '&& [^[:space:]]+ \\|\\|'\n      →何故 SC2015 で検出されないのだろうか? 変数代入の場合には許されるのだろうか。\n\n    * command ls $... となっている部分が幾つかある。 -- を付加するべき。\n      他にも色々とあるのではないかと思われる。\n\n    2021-12-11\n\n    * curl --http0, --http1, --proxy1 等存在しないオプションが生成されている\n    * printf -v varname\n    * test, [ の引数の文法に従った補完\n\n2021-12-08\n\n  * space\n\n    https://space.sh/\n    https://github.com/space-sh/space (7k LoC)\n    https://github.com/space-sh/space/blob/master/completion/init_autocompletion.sh\n\n  * bashible というフレームワークでは関数名は ble_ で始まる様だ。\n\n  * bash-dev: \"help test\" の -n の引数に STRING が二回登場している。\n\n    →と思ったが、これは分かった。 [[ -n STRING ]] と [[ STRING ]] の二種類の指定の仕方を\n    両方載せているというだけの話である。\n\n2021-09-22\n\n  * bash-it で気になる事\n\n    * bash-it disable alias を実行すると何も表示されず何も実行されない。\n    * bash-it --help もしくは bash-it で色々表示されるが、明らかに表示されてい\n      ないコマンドが存在している。\n    * bash-it update に外部から登録できる機能?\n    * bash-it に自動でインストールする機能もつける可能性について\n\n  * bash-5.2\n\n    $ i=0; b=$(< \"file${a[i++]}\"); echo \"$i\"\n    1\n\n    $ f=; b=$(< \"${f:=file}\"); echo \"$f\"\n    file\n\n    $ i=0; b=$(< \"file$((i=123))\"); echo \"$i\"\n    123\n\n    $ RANDOM=0; echo \"$RANDOM\"\n    20814\n    $ RANDOM=0; b=$(< \"$RANDOM\"); echo \"$RANDOM\"\n    24386\n\n    うーん。これに関しては zsh も ksh も副作用を残す形に実装している様だ。つま\n    り、$(< ...) は特別な構文として同じシェルで評価するものとしているという事。\n\n2021-09-07\n\n  * segv: bash-dev -c \"declare -A A; unset 'A[\\${v[0]}]'\"\n\n2021-09-01\n\n  * review: bash-raytracer\n    https://github.com/aneeshdurg/bash-raytracer\n\n    固定小数点で実装している。Issue 1 で遅いから inline 化して微妙に改善したと\n    いう話をしているが、その改善したコードは push されていない。\n\n2021-08-30\n\n  * review: bash-timestamping-sqlite\n    https://github.com/csdvrx/bash-timestamping-sqlite\n\n    - typo: synthax -> syntax\n\n    - 行末に改行が抜けている事を示すマーカーを表示している。然しこれは CPR を使っ\n      ている気がする。実装を見ると __notbottom という関数で判定していてこの関数\n      では CPR を使っている。\n\n    何れにしてもこれは他の人が組み込んで使える様な plugin ではなくて、一つの完\n    結した設定になっている。コードも綺麗ではない。現段階では単に個人用の設定に\n    説明がついているものと見るべきの気がする。これに対して色々と他の人が使える\n    様に改善の提案をするのは違う気がする。\n\n2021-08-19\n\n  * st: st 2>&- で開始しようとすると何も表示されない。st 2>&- 0>&- で開始しよう\n    とした場合にはちゃんと動く。これは以下の様に修正するべき。後で送る。\n\n    $ NOBLE=1 ./st.master 0>&- 1>&- 2>&-\n    $ ./st.master 0>&- 1>&- 2>&-\n\n    | diff --git a/st.c b/st.c\n    | index ebdf360..a9338e1 100644\n    | --- a/st.c\n    | +++ b/st.c\n    | @@ -793,14 +793,15 @@ ttynew(const char *line, char *cmd, const char *out, char **args)\n    |                 break;\n    |         case 0:\n    |                 close(iofd);\n    | +               close(m);\n    |                 setsid(); /* create a new process group */\n    |                 dup2(s, 0);\n    |                 dup2(s, 1);\n    |                 dup2(s, 2);\n    |                 if (ioctl(s, TIOCSCTTY, NULL) < 0)\n    |                         die(\"ioctl TIOCSCTTY failed: %s\\n\", strerror(errno));\n    | -               close(s);\n    | -               close(m);\n    | +               if (s > 2)\n    | +                       close(s);\n    |  #ifdef __OpenBSD__\n    |                 if (pledge(\"stdio getpw proc exec\", NULL) == -1)\n    |                         die(\"pledge\\n\");\n\n    メールを投稿してみたが全然以下のページに反映されない。\n    ブロックされているのだろうか。或いは初回は手動承認が必要になるという事か。\n    maintainer は数日に一回しか返信しない様なので取り敢えず一週間待ってみようと思う。\n\n    https://lists.suckless.org/hackers/2108/index.html\n\n2021-07-20\n\n  * bashbug: ${text//$'\\n'+( )/$'\\n'} が滅茶苦茶遅い\n    https://www.reddit.com/r/bash/comments/m4ts7j/why_is_this_spacereplacing_parameter_expansion/\n\n    この記事では bash はそういう用途に使う物ではないだの何だのと言って別の手法\n    を使えと書いているが、明らかにこれは bash のバグである。修正するべきだし修\n    正は難しくない筈である。後で観察する事にする。\n\n2021-06-09\n\n  * complete: contra x screen-4.99 で auto-menu を有効にしていると、\n\n    $ cd .mwg/src/ble.sh/wiki\n    $ l backup/[TAB][C-u]\n\n    とした以降にコマンド1文字目を入力した時点で glitch が生じる。\n    contra がどういうデータを受信しているのか確認する必要がある。\n\n    通常の screen では問題は生じない様だ。また contra の代わりに mintty を使っ\n    ても問題は生じない。変な文字幅モードが関係している可能性もある。\n\n2021-05-30\n\n  * https://github.com/dnmfarrell/jp\n    https://www.reddit.com/r/bash/comments/nmzans/jp_a_real_json_processor_in_bash\n\n    何か変な事をしている。プロセス置換で読みだした fd に対して読み書きを実行している。\n    一体どういう事だろうか…。\n\n    $ exec 3< <(:)\n    $ echo hello >&3 # これはエラーになる\n    $ echo hello >/dev/fd/3 # これは行ける\n    $ read -u 3\n    $ echo $REPLY # 読める\n    $ yes | head -1000000 > /dev/fd/3 # これはやはりブロックする C-c で中止\n    $ mapfile -t arr < /dev/fd/3\n    $ echo ${#arr[@]} # 32768要素 (\"y\" + LF)x32768 = 64kB つまりパイプバッファのサイズ\n\n2021-05-27\n\n  * declare -p -A として見たら contra の状態が壊れた。何だろうか。\n\n2021-05-23\n\n  * bash: いつの間にかに日本語の文字幅の計算がおかしくなっている\n\n    [現象]\n\n    | ble/util/c2w 及び ble/util/c2w-edit の計算は正しい。新しい bash セッショ\n    | ンを開始した時には何も問題は発生しない。つまり、reload を通して壊れるとい\n    | う事だろうか。然しそうだとしても不思議な壊れ方である。\n    |\n    | 何かが変わってしまっているという事なのだろうと思うが新しい bash セッション\n    | で発生しない様なので取り敢えずこれの解決は後回しにする事にする。\n    |\n    | うーん。textmap が可笑しくなっている気がする。\n    |\n    | と思ったら ble/util/s2c で日に対して 230 が返って来ている。何故だろうか。\n    | 実装を確認すると単に printf %d \"'日\" を実行しているだけである。実際に\n    | builtin printf の出力結果がおかしくなっている事を確認した。うーん。不思議\n    | な事である。\n\n    builtin printf %d \"'あ\" が正しい値を返さなくなっている。一文字目の文字コー\n    ドを返している。実装を見ると mbtowc を呼び出している。失敗したら一文字目の\n    コードを返す実装になっている。これにより ble/util/s2c が誤った文字コードを\n    返し、そして文字幅計算が間違って textmap に間違いが入る。というのが表示が乱\n    れる原因であった。\n\n    [再現条件?]\n\n    a 新しい bash で ble-reload をしても特に問題は発生しない。\n\n    b 一度でも LANG を C 辺りに変更すると問題が発生する様になる可能性? 特に再現\n      はしない。LANG を元に戻せば元通りになる。また、問題の発生しているセッショ\n      ンで LANG=C して LANG=ja_JP.UTF-8 にして見ても問題は治らない。\n\n    ? 或いは設定が異なるのか。bind -v の結果を比較しても shopt の結果\n      を比較しても $SHELLOPTS:$BASHOPTS の結果を比較しても同じである。dotglob,\n      nullglob の設定の違いはあったがこれを解除しても振る舞いは変わらなかった。\n\n    ? 或いは LANG 辺りを unset した痕跡があるだろうか。コマンド履歴を探したが\n      unset でも LC でも LANG でも怪しい物は見つからない。実際に unset するなど\n      しても特に問題は発生しない。\n\n    ? よく分からないので bash を見に行くと builtins/printf.def で mbtowc を呼び\n      出して文字を一文字抽出している。この mbtowc の文字コードの設定ができなく\n      なっているのが問題なのだろう。うーん。やはり setlocale の問題の気がする。\n\n    ? うーん。不思議である ble-detach しても状況は変わらない。然し何故か\n      readline の文字幅判定等はちゃんと正しく動作している様である。printf\n      \\u3042 等もちゃんと動いている。\n\n    ? うーん。実際にこのセッションで実行したコマンドの一覧を作って観察して見た\n      が特に問題がある様には思われない。特に locale を破壊する様な事が起こると\n      は思えない。怪しい物に setsid があるがこれで全てのシェルが駄目になるとい\n      う事があるのだろうか。うーん。特に問題は発生しない。\n\n    もう全然分からないので exec bash してみる事にする→exec bash したら治った。\n    結局どういう事だったのか分からず終いである。結局不明である。C標準ライブラリ\n    か Linux のバグなのだろうか。\n\n2021-05-21\n\n  * bash: fix a problem that \"set -e; builtin eval false || true\" exits the shell\n    false || true # OK\n    eval false || true # OK\n    builtin false || true # OK\n    builtine eval false || true # 駄目\n\n2021-05-08\n\n  * bash: Cygwin でも mapfile/read で unbuffered read に変更できないだろうか。\n\n2021-05-06\n\n  * bash: complete -p の -F はやはり quote するべきなのではないか。\n    $var となっている場合、!! となっている場合、{1..10} となっている場合。\n\n  * bug-bash localvar_inherit: dynamic variables の性質も継承されるのは意図的か。\n    Ref #D1532\n\n    例:\n\n      shopt -s localvar_inherit\n      local BASH_COMMAND='xxxx'\n      local LINENO='xxxx'\n      local RANDOM='xxxx'\n\n    * PS1 を評価する為に BASH_COMMAND を一時的に別の物に置き換えたい。\n      localvar_inherit を一時的に off にしたり或いは tempvar を通して\n      BASH_COMMAND を変更する等すれば一応 BASH_COMMAND を置き換える事は可能だが\n      非自明である。\n\n    * localvar_inherit は local variable という形で初期化を行わなかった時の振る\n      舞いを制御する物と思っていたが、実際には上記の様にした場合に影響が出てく\n      る。つまり、localvar_inherit の下で上を実行すると set/get がコピーされた\n      上で代入が行われる様で、動的変数としての性質が継承される。振る舞いが変わっ\n      てしまって困る。特に代入した値が消滅してしまう。\n\n    * また、マニュアルを見ても attr 及び value が継承されるとは書かれているが\n      dynamic variable としての性質が継承されるとまでは書かれていない (?)。\n\n      > info bash より (man bash は本質的に同じ)\n      >\n      >   localvar_inherit\n      >\n      >         If set, local variables inherit the value and attributes of a\n      >         variable of the same name that exists at a previous scope before\n      >         any new value is assigned.  The 'nameref' attribute is not\n      >         inherited.\n      >\n      >   declare\n      >\n      >         The '-I' option causes local variables to inherit the attributes\n      >         (except the 'nameref' attribute) and value of any existing variable\n      >         with the same NAME at a surrounding scope.  If there is no existing\n      >         variable, the local variable is initially unset.\n      >\n      > declare --help より\n      >\n      >   -I    if creating a local variable, inherit the attributes and value of a\n      >         variable with the same name at a previous scope\n\n    * 他の実装はどうだろうかと思って zsh で RANDOM, LINENO を試してみたが、\n      RANDOM に関しては local にしても何も振る舞いの変化は見られず、LINENO に関\n      してはそもそも代入不可能だった。そもそも zsh は local var; とすると前のス\n      コープの値は保持される単に unset になる。\n\n    * 実際にこの継承を行っているのは variables.c:2738 の以下の部分である\n\n      variables.c L2738\n      > if (localvar_inherit || (flags & MKLOC_INHERIT))\n      >   {\n      >     /* It doesn't make sense to inherit the nameref attribute */\n      >     new_var->attributes = old_var->attributes & ~att_nameref;\n      >     new_var->dynamic_value = old_var->dynamic_value;\n      >     new_var->assign_func = old_var->assign_func;\n      >   }\n\n    2021-06-09 SECONDS も影響を受けるだろうか。\n\n    より現実的な例として以下の様な場合を考える事ができる。\n\n    evaluate_prompt() {\n      local BASH_COMMAND=$(HISTTIMEFORMAT=x history 1 | sed '1s/^[[:space:]0-9]*x//')\n      result=${PS1@P}\n    }\n\n    Note: 実は上記の BASH_COMMAND 抽出方法は正確ではない。複数コマンドがある場\n    合、本来 BASH_COMMAND は一番最後のコマンドだけを含む。また、HISTCONTROL 等\n    によって履歴にコマンドが登録されなかった場合にも結果がずれる事になる。例示\n    するならば具体的に結果を無理に模倣しようとせずに、何か適当に内容を書く事に\n    するのが良い気がする。例えば、\n\n    evaluate_prompt() {\n      local BASH_COMMAND='echo \"Hello, world!\"'\n      result=${PS1@P}\n    }\n\n2021-05-04\n\n  * empty associative array subscripts: これは結局返事がないが ToDo リストに入っ\n    ているのかもしれない。或いはそうでもないのかもしれない。何れにしても、今少\n    しずつ associative array subscripts の取り扱いの変更が行われているので、そ\n    れらが済んでから処理されるのではないか。\n\n  * return without arguments in trap handlers. これは結局強い理由がないと変更さ\n    れない雰囲気になっている。\n\n2020-12-19\n\n  * bug-bash: jobs in trap handlers\n\n    以下を実行して端末を resize すると (true) の偽ジョブ情報が出力される\n\n      trap '(true); jobs' WINCH\n\n    SIGWINCH に限らない。以下を実行して C-c を押しても同様の問題が発生する。\n\n      trap '(true); jobs' INT\n\n    実は直後の bind -x の中で jobs を実行しても同様。\n    一度でもユーザーコマンドを実行すれば偽情報は消える。\n\n      trap '(true)' INT\n      bind -x '\"\\C-t\": jobs'\n\n    2022-07-11 以下でも同様の問題が発生した。これは PROMPT_COMMAND 実\n    行中に発生する事である。\n    https://github.com/petobens/trueline/pull/46#issuecomment-1179853850\n\n2020-04-25\n\n  * starship コマンド実行時間の計測\n    preexec と precmd を使っている?\n    https://github.com/starship/starship/blob/master/src/init/starship.bash\n\n    追記 2022-02-17 これは ble.sh でも類似の物を実装した。\n\n  * pipexec という物があるそうだ。と思ったが調べたら C で書かれている。\n    https://github.com/flonatel/pipexec\n\n  * zsh のテーマである powerlevel10k は実は結構複雑な処理を実装している。\n    ごちゃごちゃとした雑多の設定の寄せ集めではない。\n    ble.sh 程ではないが単にプロンプトと呼べるレベルを超えている。\n    * https://github.com/romkatv/powerlevel10k\n    * https://github.com/Powerlevel9k/powerlevel9k\n      p9k と initial commit が同じなので再実装というよりは fork の気がする。\n\n  * https://github.com/aristocratos/bashtop\n    これは最近現れた物で pure bash で色々な UI を実装している。\n    オプション引数はなく設定は直接編集する様になっている。\n    背景が明るい時の配色に対応していない。256色要求。\n\n    * 実用性よりも見た目重視。これはツールの性格による。\n      ble.sh 自体は他のプログラムを呼び出す為の物なので主張は控え目。\n      然し、宣伝の為には見た目を派手にした物も必要なのかもしれない。\n    * 何故か現れたばかりなのに 6.3k も集まっているし、\n      一体何が起こるとこのように話題になるのだろうか。不思議である。\n      HN にも reddit にも大して人気になった物は見られない。\n      何処から広まってどう人気になったのか不明である。\n    * freebsd, aur, debian, fedora/centos にまでパッケージが在る。\n\n\n\f@todo\n*******************************************************************************\n    ToDo\n-------------------------------------------------------------------------------\n\n* bump 時にする事\n  - version up in README\n  - Copyright year\n  - Acknowledgments\n  - todo 項目の整理\n  - leakvars\n  - version up in GNUmakefile\n  - note.txt に含まれるログの移動 -> done.txt\n  - keymap の移動 (これは別 commit にする?)\n  - make_command.sh の整理 (scan 分離, char_width 分離)\n  - note.txt -> memo.txt\n\n2024-12-24\n\n  * vscode における初期化問題\n    https://github.com/akinomyoga/ble.sh/discussions/524\n\n    [ble-attach の問題]\n\n    ble-attach を呼び出すと venv が初期化されない。どうも変だと思ったら vscode\n    は .bashrc を shellIntegration-bash.sh 云々から読み込まれている様だ。単に\n    PS1 が反映されていないという事だった様である。これの対策についてはまた考え\n    なければならないだろうか。或いは、ユーザーに ble-attach ではなくそのまま書\n    く方式を試す様にお願いするか。wiki に記述しても良い。\n\n    或いは、既に VS Code の何かの Extension に対する対策を含めているのだから、\n    VS Code Python Extension に対する workaround も ble.sh の中に含めるべき? し\n    かしそうするとしてもどの様に処理したら良いか分からない。\n\n    a ble-attach を無効化するにしても、ble-attach をわざわざ記述した理由がある\n      のかもしれない。\n\n    b 或いは、ble-attach の時点で VSCODE_* の環境変数が存在して未処理の場合には\n      それを ble.sh の側で自前で処理して、その後で ble-attach する? 然し、そう\n      するにしても shellIntegration-bash.sh が変更されたらそれで動かなくなって\n      しまう。upstream を追跡するのは大変だし、追跡したとしてもどの version の\n      shellIntegration-bash.sh を使っているのかまで検出しなければならない。\n\n    c 或いは、呼び出し元が shellIntegration-bash.sh だと分かった時点で、それを\n      自前で呼び出してそれから ble-attach を実施する?\n\n    [source .venv/bin/activate の問題]\n\n    一方で、これは結局報告者の問題とは関係ない様だ。報告者のビデオによると\n    source .venv/bin/activate が書き込まれてその後に C-c が送信されて、それから\n    実行スべきコマンドが書き込まれて実行されている様だ。然し、source ... C-c は\n    自分の環境では実行されている気配が全くない。そもそも .venv/bin/activate は\n    全く読み込まれていない様に見える。\n\n2024-12-23\n\n  * vi_cmap: :marks の対応。ないと marks のデバグの時に不便\n\n  * vi_nmap: pu をした時のカーソル位置が vim と一致しない\n    Ref #D2304\n\n    vim では、例えば \"insert\" がクリップボードにある状態で @echo で p を押すと\n    einser@tcho になる。其処で u を押して元に戻すと e@cho になりそうな物なのに\n    @echo になる。ble.sh の実装では e@cho になる。\n\n    そもそも何故 vim がこの様に振る舞うのか分からない。vim の動作を確認する限り\n    は、undo を実行した時の変更範囲の先頭にカーソルを移動する様に見えるが、pu\n    に限っては u によって消去された範囲の先頭ではなくて u を押した時のカーソル\n    位置に戻っている。\n\n2024-12-09\n\n  * highlight: cd を bind -x 経由で実行するとコマンドキャッシュがクリアされないので\n    ./docker.sh などの着色がエラー着色のまま or 存在しないのに存在するかのよう\n    になってしまう。ディレクトリを記録して変更があればキャッシュをクリアするべき。\n\n2024-12-06\n\n  * edit: url-quote-magic (requested by Bluey26):\n    https://github.com/akinomyoga/ble.sh/issues/533\n\n    magic-space 等に追加の処理を自分で登録できる枠組みを作るのが良い気がする。\n    そして、提案された機能は contrib　に実装例を追加するという形にする。\n\n  * README: シェルで実装する理由、ble.sh の目的\n\n    * Criticism にシェルで commandline editor を実装するべきではないという批判。\n      これについても何回か何処かで返信した様な気がする。うーん。これは README\n      の中で書くよりかは wiki の中に書くべきだろうか? うーん。\n\n      恐らくこのあたりだろうか。これは結局 performance に関係しての言及であって、\n      複雑なプログラムをシェルで書く事にういての議論ではない。\n\n      https://github.com/akinomyoga/ble.sh/issues/214#issuecomment-1193390781\n\n    * そもそも何故 ble.sh を現在の形に作ったのかという事を何処にも書いていない\n      気がする。これは何処かに書いても良い気がする。その議論は以下に書かれてい\n      る。\n\n      https://github.com/akinomyoga/ble.sh/issues/422#issuecomment-1986840459\n\n  * wiki: Questions-for-bug-reports.md は Reporting-Issue.md に統合する\n\n2024-11-26\n\n  * read PS1: read -e の内部で PROMPT_COMMAND によって PS1 が書き換わる\n    https://github.com/akinomyoga/ble.sh/discussions/528#discussioncomment-11339978\n\n  * menu-style: 複数行 description\n    https://github.com/akinomyoga/ble.sh/discussions/532#discussioncomment-11372936\n\n    これは preview pane 付きの menu-style と同時なのではないか。\n\n  * nsearch: nop search が無限に stack する\n    https://github.com/akinomyoga/ble.sh/issues/531#issuecomment-2499092693\n\n    同じ位置のゼロ幅一致は連続で発生しない様にするべきである\n\n  * contrib/fzf-menu: util-linux >= 2.39 を requirements に追加する\n    https://github.com/akinomyoga/ble.sh/issues/530\n\n  * wiki: bleopt line_limit_type=editor\n    https://github.com/akinomyoga/ble.sh/issues/520#issuecomment-2423335161\n\n    history_limit_length > line_limit_length\n\n  * wiki: Unresolved Issues を拾ってまとめる\n\n    既に閉じたものもそうだが、昔から開きっぱなしになっている issues の幾つかは\n    もう閉じてしまっても良いと思われる物や、解決・再現の見込みのないものがある。\n    これらは Unresolved-Issues に移動して閉じることにする。\n\n    また、閉じた物でも Information Needed ラベルのついた物も同様に確認する。\n\n  * wiki: ble/function#advice の説明を何処かに記述する。他の関数についても記述する\n    ことにする。\n\n    Functions.md という名前の wiki ページでも作成することにする。\n\n    うーん。これはまた新しいファイルを作る事になる。stuck しているので取り敢え\n    ず分割してこれは後で記述する事にする。\n\n  * complete: contrib に completion-util.bash 等を導入してそれを使って progcomp\n    設定の振る舞いを調整できる様にする。opts 経由でどのような調整を行うかを指定\n    できる様にしたい。\n\n    - timeout=MSEC\n    - timeout-auto=MSEC\n    - disable-auto\n    - subshell\n    - term-leave\n\n    等、様々な調整を追加する。\n\n    * また実装したら wiki/{Performance.md,Reporting-Issue.md} の auto-complete\n      の項目でそれぞれ引用する。\n\n  * wiki/Reporting-Issues: keylog の使い方について記述する。syntax_debug や、\n    leavar や、debug_xtrace など。\n\n    物によっては CONTRIBUTING の方に記述するべきかもしれない。特に自分で何か実\n    装しながらチェックするべきもの (make scan など)。print-variables 等もこれに\n    該当するのでは。\n\n  * wiki/Questions-for-bug-reports: Reporting Issues に統合する\n\n  * wiki/Performance.md: より詳細な設定 with contrib\n\n    * auto-complete: contrib: auto-complete/ TAB completion 用の timeout を設定\n      する関数も用意して良いのでは。\n\n    * profiler, is-stdin-ready, conditional-sync, assign 等の関数について説明を\n      用意する。下の Functions.md の項目にも注意する。\n\n    * completion setting に対して個別に set -x 及び profiling を有効にする機\n      能があっても良いのではないかという気がする。コマンドの実行結果 (入力の\n      COMP_* および出力の COMPREPLY, exit status, etc.) も記録して良いのでは。\n      それをユーザーに提供してもらう。然し、これはまた一つの大きな課題になる。\n\n      うーん。その様に考えると無限に記述することが増えるので適当な所で議論を切\n      り分ける必要がある。\n\n    * 指定した関数の時間を計測する関数? これは core-debug か\n      contrib/debug-utils 的な場所に関数を定義してそれを読んでもらう事にする。\n\n  * wiki: describe wiki page\n    https://github.com/akinomyoga/ble.sh/issues/531\n\n    empty=emulate-readline について記述する。\n\n  * wiki: Functions.md: 自動生成・抽出\n\n    本当はソースコードの記述を自動的に集める関数を作りたい気もするが、うーん。\n    沢山ある関数を全て含めるのは現実的でないし、説明も日本語の物と英語の物があ\n    る。現状では取り敢えず別々に記述することにして、必要があれば指定した関数に\n    ついてだけ抽出する機能を実装する\n\n    * reject: マニュアルに含める関数のコメントに含めるマークアップを定義する?\n      @export-doc など? と思ったがその様にしたとしてもどういう順番でマニュアル\n      に含めるのかという問題が生じる。そう思うと結局マニュアルの側でコメントを\n      参照するのが現実的ではないか。\n\n2024-10-19\n\n  * [保留] complete: menu-complete の背景色\n\n    Ref #D2291 fish には pager_background や pager_secondary_background がある。\n    各項目の文字列の pager_background は必要ない気がするが、各項目の領域の背景\n    色を指定できるようにしても良い気はする。\n\n    ただし、pager_secondary_background (交互に背景色を変える) などによって項目\n    の配置ごとに背景色が異なる様にすると実装上の問題が生じる。現在の実装では\n    esc 生成と出力サイズの計測を行って、それを元にして配置を決定している。背景\n    色を配置を決定した後に決める様にすると、esc を再生成しなければならないので\n    無駄に処理を二回しなければならなくなる。其処までの需要があるとは思われない\n    ので、fish の pager_secondary_background は対応しなくて良い気がする。\n\n2024-09-25\n\n  * complete: ble/complete/candidates/filter#test 候補毎の COMPV の評価方法\n    Ref #D2288\n\n    [背景]\n\n    現在の実装では候補毎に絞り込みに使う COMPV の値が異なる可能性がある。(1) 例\n    えば或る候補が simple-word/eval によって得られた COMPV (既定) に合致する候\n    補名として生成された場合は、その候補は新しい COMPS から生成された COMPV を\n    用いて絞り込むべきである。(2) 或いは、別の候補が COMPS に直接合致する物とし\n    て生成された場合には絞り込みも COMPS を用いて実施するべきである。(3) 或いは\n    更に別の候補が COMPS を別の方法で評価した結果として得られた my_compv を用い\n    て生成された場合は、その絞り込みも新しい COMPS から同じ方法で得られた新しい\n    my_compv を用いて実施されるべきである。この様な事はシェルとは別の言語が途中\n    に含まれるコマンドラインで発生しうる。或いは、引用符の中の一部の単語に対し\n    て補完を試みた場合 (例 \"hello \\\"wor[TAB] \") 等も、通常の simple-word/eval\n    とは異なる単語評価の方法を用いる必要がある。\n\n    既に fzf による compopt -o ble/syntax-raw で生成された候補や、\n    execute-named-command の入力プロンプトにおける COMPS による候補生成などにお\n    いて、menu-filter のフィルタリングの仕方を調整するべきだが、現状ちゃんと実\n    装されていない物がある。これらの特別な取り扱いが必要になるかどうかというの\n    は、候補の生成者 (source) が関知している。従って、cand_pack の内部に \"compv\n    生成方法\" に関する情報を埋め込むのが自然と思われる。\n\n    [修正項目]\n\n    * compv 生成方法 (word-eval) に対して番号 iWE を割り当てる。`0` は `COMPS`\n      をそのまま使うものとし、`1` は `COMPS` から\n      `ble/syntax:bash/simple-word/eval` を用いて `COMPV` に変換するものとする。\n      `2` 以降は新しい word-eval の方法が現れる度に追加して管理することにする。\n\n    * cand_pack の中に word-eval の種類を記録できる様にする。データ形式について\n      はよく考える必要がある。\n\n      _ble_complete_cand_varnames には新しい変数を追加する。これまで大文字を使っ\n      て来たがグローバル読み取り専用変数と衝突したら嫌なのでそろそろ prefix つ\n      きの小文字の変数に少しずつ移行したい。或いは以降のデータについては配列に\n      して、無駄に変数を増やさなくて良い様にする。\n\n      cand_pack の形式については ble/complete/cand/yield が定義していると思って\n      良い。PREFIX_LEN の次に整数を追加すれば良い気がする。\n\n    * comp_filter_pattern は配列に拡張し comp_filter_pattern[iWE] とする。\n\n      ble/complete/candidates/filter#init filter_type COMPS [COMPV...] は\n      filter_type を記録する。COMPS は comp_filter_type[1] 等に格納する。それを\n      用いて作られたパターンを comp_filter_pattern[0] に格納して良い (或いは必\n      要になった時に使い手の側で comp_filter_type[1] を使って\n      comp_filter_pattern[0] を初期化して良い)。追加で COMPV... が指定されてい\n      る時には、それらの文字列を使って生成したパターンを\n      comp_filter_pattern[1]... に格納する。これは遅延しない。\n\n      ble/complete/candidates/filter#test str [iWE] はテストを行う。iWE が省略\n      された場合は 1 とみなす。comp_fitler_pattern[iWE] に対応するパターンが未\n      だ初期化されていない場合には、記録していた COMPS を元にしてその場でパター\n      ンを生成する。\n\n    * menu-filter や ble/complete/menu-filter/.filter-candidates 等では\n      ble/complete/candidates/filter#init や\n      ble/complete/candidates/filter#test の呼び出しを適切に更新して、候補毎に\n      正しい種類の word-eval を用いて候補をフィルタリングできる様にする。その他\n      の ble/complete/candidates/filter#test 呼び出しについても一つ一つ確認を行\n      う。\n\n2024-09-22\n\n  * complete: bash-completion のコマンド名生成も WSL2 PATH に対して調整が必要では\n\n    Ref #D2280\n\n    うーん。bash-completion が内部で compgen -c を呼び出している場合にはこれで\n    は対応できていないがどうするのか? 或いは手動で bash-completion の関数を上書\n    きする?\n\n    調べてみると compgen -c を呼び出しているのは _comp_compgen_commands だけの\n    気がする。後 completions/complete で compgen -A command が呼び出されている。\n    なのでこれらの関数だけ上書きすれば良い?\n\n  * segment ベースのプロンプトの為の枠組み?\n    https://github.com/akinomyoga/ble.sh/discussions/503\n    https://github.com/akinomyoga/ble.sh/discussions/282\n\n    airline と同様に縮んで来た時に長さを調整する機能? airline ではどの様に実行\n    していたか確認する。基本的にはそれと同様に実行すれば良い。但し、その為には\n    単純に自分の一つ左の要素を使って境界の文字を生成すれば良いという訳ではない。\n\n    境界の種類についても幾つかから選択できる様にしたい。全体で一括で決めるので\n    はなくて個別に選べる様にする?\n\n    segment 毎に関数を定義できる様にする。ユーザーが定義できる様にする。と思っ\n    たが、単に配列に prompt sequence を記述する様にすれば良いのではないか。境界\n    についてもそれを指定する専用の prompt sequence を定義して、その中で変数に値\n    を指定するなどすれば良いのではないか。\n\n    sbp や liquidprompt や powerline などの構造を参考にする。それらの既存の\n    segments を最小限の変更で再利用できる様にする?\n\n2024-09-13\n\n  * https://github.com/akinomyoga/ble.sh/discussions/500\n    bashrc で多重にロードしている時に警告を出すべきでは。\n\n    警告を出すにしてもどの様にして検出すれば良いのか。例えば BASH_SOURCE を見て\n    .bashrc からどの様に呼び出されているかを記録する (source ble.sh を実行して\n    いる行数も特定しておく)。その呼出パターンが複数種類ある場合に警告を発する?\n\n    x 然し、例えばループの中で重複して呼び出している場合等には呼び出しパターン\n      は同じになるのでこの方法だと検出できない。\n\n    x また状況に応じて異なる経路で source ble.sh を実行するような設定になってい\n      る場合には、改めてユーザーが source ~/.bashrc 等をした場合に、初回と異な\n      る呼び出しのされ方をして、それに対して警告を発してしまう事になる。\n\n    例えば ble.sh が source されてから PROMPT_COMMAND が実行される迄に次の\n    source ble.sh が実行されたら警告を発する様にする? コマンドの実行回数・行番\n    号については初期化時には小さな数になっている筈である。その情報も用いて最初\n    のプロンプトよりも前に ble.sh が複数回呼び出されているという事は検出可能で\n    ある。\n\n2024-09-02\n\n  * contra に ?5h のバグがあるかも。ちょっとした拍子に反転が戻っておかしな事に\n    なる? 或いは screen の方かもしれない。と思ったがそもそも screen の中では反\n    転できないという事が分かった。これは関係ない。\n\n2024-08-25\n\n  * [保留] build 時に network がないと怒られるという話 (reported by pallaswept)\n    https://github.com/akinomyoga/ble.sh/issues/488\n\n    それで commit hash が決定できないという話。何故?\n\n    もしかすると shallow clone だと駄目ということ?\n\n2024-08-23\n\n  * menu-complete: ページ構築途中で中断すると現在位置がクリアされる\n\n    最近の ble/util/is-stdin-ready の変更で動かなくなったのかと思ったが前から動\n    かなかった様だ。と思ったが動作確認をミスしたかもしれない。また後でどの時点\n    で発生する様になったのかを確認する。何故?\n\n    ble/widget/menu/forward-line は ble/complete/menu#select を呼び出して、これ\n    は ble/complete/menu/show を呼び出して、更に ble/complete/menu#construct が\n    呼び出されている。そして、この関数は最初に menu_items や現在位置等の情報を\n    設定している…あたかも新しい menu を開始する時の様に。必要なのは新しいメニュー\n    を開始する時の処理と、別のページの内容を構築する処理を分離する事なのではな\n    いか。\n\n2024-08-21\n\n  * [保留] decode: function name slash workaround 後にキーボード入力ができない (reported by teutat3s)\n    https://github.com/akinomyoga/ble.sh/issues/484\n\n  * histdb: 様々の種類の履歴についても個別に記録するべき? 全てコマンド履歴とし\n    て記録していると異なる場所で異なる物を提案する様になって余り好ましくない。\n\n  * history: 様々の種類の履歴についてもファイルに記録する。単純なファイル形式で\n    良い。というか、実は通常のコマンド履歴についても bash によって一々消去され\n    る .bash_history ではなくて、それとは別の場所に記録しても良いのではないか?\n\n    それが histdb であるという考え方もあるかもしれないが、histdb は sqlite3 を\n    要求している。もっと簡単で追加の依存性を要求しない物もあるべきである。\n\n2024-06-05\n\n  * 何処かの時点で ret -> REPLY に書き換えたい [#T0009]\n    Ref #D2300\n\n    既存ユーザーの設定で使われている場合にはどうするか。declare -n ret=REPLY を\n    設定しようと思っていたが、local ret とした時点でそれが上書きされてしまうか\n    ら駄目の気がする。逆に declare -n REPLY=ret としていたらどうなるか。これは\n    逆にble.sh の内部で local REPLY=xxx とした時点で駄目になってしまう気がする?\n    と思ったがその場合は REPLY は通常変数として問題ない気がする。\n\n    自動で変換する時に気にするべきは ret=$? の様な別の用途で使っている物を除外\n    する事。また、REPLY が使われている箇所があったらそれが batting しない様にす\n    るという事。これについては全く使っていなければ問題ない気がする。\n\n  * debug: debug_profiler_opts=flame\n\n    flame graph にも対応する? 然し flame graph はインターフェイスが難しい気がす\n    る。取り敢えず少なくとも等価な統計は出す事にする。percentage, 呼び出し回数,\n    etc 等について統計を取る。\n\n    既存のデータの読み取りにも対応する。\n\n2024-04-17\n\n  * highlight sabbrev\n\n    inline sabbrev / line sabbrev 等は後回しで良い。\n\n2024-03-19\n\n  * isearch してから up をした時に選択解除してから上に行くという振る舞いに変わっ\n    ている。これも何だか不自然な気がする。元々 set-mark でなかったのであれば up\n    で普通に前の項目に移動するべきである。\n\n    そもそも shift selection の時に up をした時に上の項目に移動せずに選択解除す\n    る振る舞いになっていて、これは変である。\n\n2024-02-22\n\n  * histdb: calendar で実行時間等についても calendar を作れる様にしたい。現在は\n    単に count しているだけ。\n\n  * histdb: calendar やその他のコマンドについても -x 等でコマンドをフィルタでき\n    る様にする。フィルタ演算子については atuin で使っている物を参考にする。\n\n  * histdb: zsh-histdb の様に diff driver や merge strategy を提供する? 然し\n    merge の瞬間には完全 lock が必要になるのではないか?\n\n  * histdb: default palette を bleopt で指定できる様にする\n\n2024-02-21\n\n  * face 継承。これは設定を整理する上で役立つ。\n\n    実装するべきでは。どうせキャッシュしているので速度には影響はない筈。一方で、\n    face の値を変更する時に、影響がある face 全てのキャッシュをクリアするべきで\n    は? と思ったがよく考えたら g -> sgr はキャッシュしているが、face -> g はキャッ\n    シュしていない。ここでの疑問は合成を実装したとしてその算術式による合成がど\n    の程度大変かという事。因みに現時点で再帰的な参照に関しては実装している。\n    ref:... である。それとは独立にした方が良い気がする。\n\n    うーん。\n\n    * base=face にする。\n\n    ? 循環参照の検出は行う? 或いは local をして無効化すれば良い? と思ったが算術\n      式のレベルでは local を定義する事はできない。或いは複雑なことをすれば算術\n      式でも index をずらしたりして回避できるかもしれないが其処までする事かは分\n      からない。\n\n      循環参照の検出は動的に行うのではなくて設定時に判定すれば良い。\n\n    * 複数の base に対応するか?\n\n      原理的には対応可能である。先ず base が一つの場合には b1,g,merge とすれば\n      良い。base が二つの場合には b1,b2,g,merg,merge とすれば良い? と思ったが\n      stack 指向ではないのでこの考え方は変だ。associatvity が成立するのだとした\n      ら、g=xxx,b=b2,merge,b=b1,merge,...,ret とすれば良い。associativity は何\n      処から出てくるか? (1) xor (revert) については自明 (2) 上書き型についても\n      自明。その他の種類はない気がするので気にしなくて良い。\n\n    * 基本的に合成というと足し算である。でも引き算的な物もないと困るのではない\n      か? 分からないが取り敢えずは気にしない事にする。\n\n  * bug-bash: bash-3.1..dev exec fd1<&\"$var\"- で $var の fd が存在しない時のエ\n    ラーメッセージが fd1 が存在しない、という物になっている。\n\n2024-02-14\n\n  * complete: / の入った関数名で曖昧補完できていない?\n\n  * selection: dispatch を実行した後に選択範囲を抜けているかどうか確かめる様に\n    したが、2キー以上の組み合わせで何かする場合には結局現在の selection では駄\n    目なのでは。\n\n    もっとちゃんと対応しようと思ったら次の widget が呼び出された後に何か処理を\n    入れる必要がある。然し、それでも arg などの widget の場合にはやはり駄目であ\n    る。やはり設計を元に戻した方が良い様な気がしてきた。但し、@marked を経由し\n    ない場合には clear-arg または get-arg 辺りで自動で clear する様にするのが良\n    い様な気がする。\n\n  * histdb: cpu は 100 倍したい。現在の実装だと微妙。これは何処かの段階で\n    version up すれば良い。セッションを一旦すべて閉じてから処理する。\n\n  * progcomp: fullquote を既定で指定して +o fullquote で解除できる様にする?\n\n    その場合には複雑な bash の振る舞いを調べて模倣する必要があるが其処までする\n    意味があるかは分からない。\n\n2024-02-08\n\n  * history: command history 以外についても永続的な履歴が欲しい気がする。state\n    に沢山放り込めば良い。history.vi_filter, etc. これらはテキストファイルで良\n    い。\n\n2024-02-05\n\n  * M-q による buffer stack\n\n    CUA における C-s (保存) はコマンドラインではどの様な機能に対応するだろうか\n    という事を考えて、或いはブックマーク的な使い方ができたら良いのかもしれない\n    と思った。\n\n    そう思うと zsh にあるらしきコマンドスタック (M-q) という物が気になる。少し\n    考えると、順番に取り出すしかないというのは不便そうだし、中身を確認する方法\n    もよく分からないし、本当に便利なのか分からないと思っていたが、C-o (開く) で\n    例えばメニューを開いて選択することができるのだとすれば、それは便利である。\n\n    そう思って検索してみると以下の記事がある。そもそもコマンドスタックという名\n    前ではなくて buffer stack という名前の様だ。それで、自分の思っていたのと似\n    たような不便さを感じている様である。但し、一つ前のコマンドを表示するという\n    所に留まっていて、メニューを表示するとかそういう所までは考えていない様だ。\n\n    https://kei-q.hatenadiary.org/entry/20110308/1299594629\n\n    一応 M-q は fill-paragraph と conflict するがそもそもコマンドラインで fill\n    paragraph を使う機会は存在しないだろう。\n\n    * reject: zsh には POSTDISPLAY という物がある様だ。\n\n      これは ble.sh における info に似たような物だろうか。と思って調べてみたが\n      単に zsh-autosuggestions 用に用意された、suggestion を表示する為の物の様\n      である。しかも編集文字列の末端にしか表示する事ができない。という事は\n      zsh-autosuggestions はコマンドの途中では動かないという事か?\n      zsh-autosuggestions を入れていないので分からない。fish については試してみ\n      た所、やはりカーソルが末端にある時にしか autosuggestions は働かないみたい\n      だ。というか、そもそも履歴からの補完にしか対応してない (恐らくカスタマイ\n      ズはできるのだろうが)。\n\n      更に調べると POSTDISPLAY を使おうとするプラグインが複数あるとおかしな事に\n      なるという報告ばかり見つかる。まあ、それはそうだろう。\n\n      後気になるのは、zle のページによると zle が呼び出される度に POSTDISPLAY\n      はクリアされるという事。つまり、buffer stack の表示はその時にしか為されな\n      いのでは? でも他にも設定を真似ている人が Qiita にいる様だから、ちゃんと持\n      続的に表示される様にできるのだろう。\n\n      何れにしても便利そうな機能ではない。\n\n    ? 履歴項目の編集中に M-q を実行した場合には何が起こるのか。履歴位置が最初に\n      戻るのか、それとも現在の位置にいるままで push が起こるのか → どうも現在\n      位置にいるままで push が起こっている。何だか変な感じがする。\n\n    ? 現在の内容を破棄して pop するにはどうしたら良いのか? →\n\n      * M-g (get-line) らしい。\n\n      zsh のマニュアルを見ると他にも沢山 buffer stack 関係の widget が存在して\n      いる。\n\n      * M-a (accept-and-hold) はpush&実行\n\n      * C-o (accept-line-and-down-history) は次の履歴項目を buffer stack に読み\n        込むと書いてあるがこれは bash の C-o と等価? 少なくとも動かした限りは別\n        に push している訳ではなく top level に読み込んでいるだけの気がする。\n\n        accept-and-infer-next-history はより面白い機能の気がする。履歴から完全\n        に一致する項目を検索して次のコマンドを推測する機能? 但し、既定で\n        binding を持たないので ble.sh に実装するかどうかは微妙。或いは、C-o の\n        オプションとして実装するべきかもしれない。\n\n      * push-input は push-line (M-q) の multiline 版の様だが ble.sh 的には行毎\n        に確定はしないのでどっちも同じである。\n\n      * run-help (M-h), which-command (M-?) は ble.sh では f1 に相当する。然も、\n        buffer stack とは言っているがこれはそのままコマンドを実行してまた戻って\n        きた時に元のコマンドをロードするというだけの話なので、余り buffer stack\n        特有の使い方という訳でもない。\n\n        一方で ble.sh 的には M-? 的な binding が存在しても良いかもしれないとは\n        思う。但し、M-? は既に readline 由来の complete show_menu なので別の\n        binding を探さなければならない。或いは M-f1?\n\n  * keymap: 他のエディターモード\n\n    ? 対応する keybinding が分からない物が沢山ある。それらについては emacs\n      binding と同じキーで良いのだろうか? 或いは、\n\n    * nano bindings: nano はもっと普通の keybinding によるエディターかと思って\n      いたがそうではないみたいだ。確認してみると色々と独創的な操作体系になって\n      いる。nano は名前から想像するに余り keybinding はないのではないか。と思っ\n      たが syntax highlighting にも対応しているし、微妙なのでは?\n\n    * notepad bindings: もしくは vs もしくは vscode もしくは Windows 系統の\n      keybindings。現実的にはこれが便利の気がする。\n\n      C-x C-v C-c, C-a, C-z C-y, C-f, 等様々である。新しい機能として置換(C-h)や\n      ブックマーク(C-s)に対応したいという感じも出てくる。\n\n    * これらの binding をどの様に選択するべきか? set -o vi 的なオプションはない\n      ので bleopt で指定して貰う事になる。default_keymap\n\n2024-02-01\n\n  * Konsole MR !951 はどうなった?\n\n  * bash_profile\n\n    以下の謎のメッセージが頻繁に表示される。\n\n    [1]   終了                  . \"$HOME/.cargo/env\"\n\n    declare で関数などを表示してもこれを引き起こす様な物があるようには思われな\n    い。trap や keybinding に含まれているかもしれないとも思ったがそれも declare\n    の出力の中に含まれる筈である。或いは、/etc/profile.d の中で設定されている何\n    かかもしれないと思ったが /etc/profile.d の中を見ても関係ありそうな物は存在\n    しない。そもそも bg で source する事に何の意味があるのか。\n\n    と思ったら .bash_profile に記述が追加されていた。然し、それでもこれが bg\n    jobs として表示される理由が分からない。うーん。これは background job じゃな\n    くて、foreground dead job で、ble.sh の実行環境的に残ってしまっているのが見\n    えているという事か。然し、そうだとすると今度は何故 .bash_profile が同じシェ\n    ルの中で読み込まれているのかという話になる。よく分からないので\n    .bash_profile で記録する事にする。\n\n    % 頻繁に表示されると思ったがもう表示されない。或いは或る瞬間に何かが起こっ\n    % て全ての screen window の中でこれが開始されて、でもその後でそれぞれの\n    % screen window に初めて触った時に少しずつ表示されたという事なのかもしれな\n    % い。\n\n    →2024-02-07 やはり発生した。また、screen の各 window の中でそれぞれ同時に\n    発生したというのも再現している。また、emacs 等を開いていた window では何も\n    発生していない。また debug.bash_profile.txt には何も記録されていない。\n\n    a SHLVL>=2 で出力する様にしたが SHLVL 1 つまり、現在のシェルの中で実行され\n      ているという可能性もある。どうも bind の中だと foreground job であっても\n      jobs に現れる様だから。と思ったが本当だろうか? jobs になる為には少なくと\n      も subshell にはならなければならない筈で、親シェルでは起こらない筈である。\n      と思ったが subshell でも SHLVL は増加する様だ。\n\n      また、よく考えたら screen の中のシェルは既に SHLVL 2 以上なので SHLVL 1\n      以下のプロセスが入ってくるとは考えにくい。\n\n    b 或いは .bash_profile ではなくて .profile にも似たようなコードがある? と思っ\n      て見てみたらそうだった。勝手に .profile が作成されている。.profile にも同\n      様にログを出力する様にした。\n\n    c 実は他のセッションで生成されたメッセージが screen 内部の各端末に書き込ま\n      れている? でもそういう訳では無い。ble.sh がプロンプトを更新する時のチェッ\n      クで発生しているので。或いは、screen が何か作用している? と思ったが、これ\n      も同じ理由で違うと思われる。\n\n    * 然し、何故一度に同時に全ての端末で bg が発生したのかは謎である。或いは\n      broadcast 機能を使って bash_profile が開始されたとかそういう事なのだろうか。\n\n    うーん。調べてみたが別に message.post に何か変な物があるという訳でもない。\n\n    2024-02-13 問題が再び発生したが何も bash_profile は通過していない気がする。\n\n    ? 或いは winsz 関係かもしれない。attach した時のジョブが残留していて window\n      size の変更があった時に何らかの拍子にそれが思い出されている? と思ったが、\n      それでも変は変だ。それだと job entry を session の開始時からずっと専有し\n      ていたという事になるが、jobs の時に [1] として表示されるので他のプロセス\n      が [1] に来ないという事になってしまう。然し実際には emacs は [1] の上で動\n      いている。\n\n      もっと全然別の所で . \"$HOME\"/.cargo/env を呼び出している物があるのだろう\n      か?\n\n    2024-02-16 未だ現れると思ったら .bashrc の最後にテストの為に追加されている\n    事に気づいた。呼び出されているのは bash_profile ではなくて .bashrc だったと\n    いう事では?\n\n    2024-02-17 再び発生した。然し該当するプロセスはやはり見つからない。そもそも\n    本当に bashrc から呼び出されている物なのか? 其処から特定しなければならない\n    気がする。コマンドに引数を与えて識別できないか試す事にする。\n\n    確かに bashrc で発生している様だ。然し、発生した段階では bashrc を通過して\n    いない様だ。またシェルの開始時刻によって出力したログの形式が異なる (bashrc\n    で出力する際の形式を変えたのに伴い)。なのでもっと前 (恐らく bash の開始時)\n    に通過した時の job がずっと残っていて最終的に出力されているという事だろうか。\n    然し、そうだとすると jobs の count がずっと 1 でなければならない筈の気がし\n    て、然しそうはなっていないので不思議だ。また一つのシェルセッションで同じジョ\n    ブ番号 [1] で何度も起こる。もし、最初にできたジョブエントリーがずっと残って\n    いるのだとすると何度も同じジョブが終了するのは変だ。また、自分で background\n    コマンドを実行するとちゃんと [1] に割り当てられるので [1] がずっと埋まって\n    いるという事もない。\n\n    つまり、実際に [1] に新しいジョブが割り当てられて何かが終了しているがそのジョ\n    ブの名前が attach 前に実行した最後のコマンドになってしまっている、という事?\n\n    2024-02-24 関連するか分からないが関数内で ^C を受け取って INT/DEBUG が発生\n    すると BASH_COMMAND の中身が常に . \"$HOME\"/.cargo/env になってしまって、ジョ\n    ブ名も全てこれで固定されてしまう。bash-5.1 以降で発生する。\n\n    x 何か分かった気がする。sleep 1 & を実行すると . \"$HOME\"/.cargo/env という\n      コマンド名に置き換わっている。と思ったが再現しない。と思ったら次の項目で\n      述べている関数内で ^C を実行した後に起こる現象の一つだった。\n\n    x BASH_COMMAND の中身が常に . \"$HOME\"/.cargo/env になってしまう。\n\n      あと top-level での BASH_COMMAND の内容が更新されていない? C-c すると常に\n      BASH_COMMAND に . \"$HOME\"/.cargo/env という文字列が入っている。然し、条件\n      がある様にも思う。関数の中で呼び出している限りは大丈夫? うーん。自分で\n      declare -p BASH_COMMAND 等を実行する限りは BASH_COMMAND の中身は常に\n      . \"$HOME\"/.cargo/env になっている。\n\n      普通に新しい session を始めると問題はない様だ。然し、関数内で ^C が起こる\n      と BASH_COMMAND が常に同じ値になってしまう。bash-5.0 以下では発生しない。\n      bash-5.1 以上で発生する。bash-dev でも発生する。\n\n      $ bash-5.2\n      $ func() { for ((i=0;i<100000000;i++)); do :; done; }\n      $ func\n      ^C^C\n      [SIGINT] main:1 (func)\n      [SIGINT] global: ((i<100000000))\n      [ble: SIGINT (130)]\n      [ble: elapsed 1.084s, CPU 99.9% (self)usr1.077/sys7ms] func\n      $ declare -p BASH_COMMAND\n      declare -- BASH_COMMAND=\". \\\"\\$HOME/.cargo/env\\\" \\\"(bashrc) \\$BASHPID\\\"\"\n\n      一旦 ble-detach して ble-attach したら直るかと思ったら直らない。うーん。\n      だとすると、再現コードはそんなに難しくないかもしれない? と思ったが適当に\n      打ち込むだけでは再現できない様だ。\n\n      うーんこれはまた独立な問題の気がする。cargo/env のメッセージが出るセッショ\n      ンで sleep 1 & を実行してもちゃんと sleep 1 が表示されるので、\n      BASH_COMMAND は少なくとも壊れてはいない。分かる事は bash は何処かに\n      .bashrc の最後のコマンドを覚えていて、それが何かの拍子に表に出てくる事が\n      あるという事。\n\n    * TODO: bug-bash で報告する? 最小再現コードを作成しなければならないが面倒そ\n      うだ。\n\n    2024-02-25 取り敢えず普通に .bashrc を実行した時に末尾にあるコマンドを拾っ\n    ているだけの様な気がするので、以下のテスト用のコードは .bashrc から削除する\n    事にする。\n\n    if ((BASH_VERSINFO[0]>=4)); then\n      printf '%079d\\n' 0\n      printf '[%(%F %T %Z)T] %s\\n' -1 \"PID=$$ BASHPID=$BASHPID SHLVL=$SHLVL\"\n      declare -p FUNCNAME BASH_LINENO BASH_SOURCE\n    fi >> ~/debug.bashrc.txt 2>&1\n\n2024-01-06\n\n  * complete: blesh completion source のAPI整理および定義方法の docs\n    https://github.com/akinomyoga/ble.sh/issues/157#issuecomment-1867622494\n\n    そもそも API 自体も再考する可能性がある。既に yield などは使っているプロジェ\n    クトやユーザーが幾つかある様な気もする (rsteube/carapace など) が、それに関\n    しては個別に GitHub 上で探索して報告する事にする。それと同時に後方互換性は\n    できるだけ保つ。\n\n2024-01-05\n\n  * mc 的な TUI を自前で実装しても良いのではないか? どうも mc を使っている人は\n    結構いるようである。更に、dylanaraps/fff 等の機能も参考にしても良いのかもし\n    れない。と思ったが、fff はデモを見る限りは大した機能はないのではないのかと\n    いう気がする。ranger/ranger も参考になるかもしれない。何れにしても自分的に\n    は余り使わない気がする。\n\n    報告があったので ranger を使ってみた。インターフェイス的には単純明快。ファ\n    イルの中身をプレビューする事ができる。nnn というファイルマネージャも存在す\n    る様だ。\n\n2023-12-10\n\n  * main: ble-update, ble-reload, bleopt, ble-sabbrev, ble-palette の adjust-bash-options\n\n    もしくは全部 ble 経由で呼び出してもらうことにして ble の側で待避を行えば良\n    いのかもしれない。\n\n    ble-reload に関しては内部で source するのだとしたら無理やり状態を復元保存し\n    ようとするのは問題がある気がする。特に ble-reload で adjust した後の状態を\n    グローバル変数に記録してしまうのではないか。そう思うと ble-reload は待避の\n    対象ではない気がする。そういう場合もあるという事を考えると ble で一括で待避\n    するというのも実は柔軟性に書けるという事になるのかもしれない。\n\n2023-10-04\n\n  * {,dir/}*.* が failglob エラー着色になる。本来は *.* に対して一致が試みられ\n    て failglob にはならない筈。どうも / で先に split するので /}*/* というパター\n    ンに対して一致が試みられている気がする。本来は先に {} について処理するべき。\n\n2023-09-13\n\n  * bash-5.2 \"\\e[\\000\"\n    Ref #D2069\n\n    * bash-5.2 で \"\\e[\\000\": \"<C0><9B>[\" という macro になっているのが気になる。\n      本来此処には \\000 は存在するべきではない。これは実際に内部的に \\000 があ\n      るのかそれとも出力する時の問題で \\000 となっているのか。然し、これは既に\n      bash-dev では修正されているし、またそれにもかかわらず bash-dev でも今回の\n      問題が起こっているので、これは今回の問題には関係ない。\n\n      これは以前にも気付いていた事の気がする。探してみたら 2021-11-05 に項目が\n      あってしかも放置されている。何れにしても 5.3 では修正されている。実際の振\n      る舞いに影響があるのかどうかは不明である。\n\n      うーん。これは bash-5.2 のソースコードを使って何が起こっているか確認する\n      べきなのかもしれない。或いは bisect を実行する。bind に使っているスクリプ\n      トはどこかに出力する事ができる筈である。或いはキャッシュになっている →\n      キャッシュにあった。確認すると builtin bind '\"\\e[\":\"\\xC0\\x9B[\"' で bind\n      しているので実行するコマンド自体が壊れていたとかそういう事ではないはず。\n\n    * どうやら単に以下を実行しただけで既に再現する。\n\n      $ bash-5.2 --norc\n      $ bind '\"\\e[\":\"abcd\"'\n      $ bind -s\n\n      そして M-[ を押すと (多少の keymap delay の後に) abcd が入力される。つま\n      り、実際に \\e[\\000 が束縛されているというよりは表示の際に変な表示になって\n      しまっているという事の気がする。\n\n      これが実際に何らかの問題を具体的に引き起こす事はあるだろうか。そもそも通\n      常は \\e[ は単独では bind しない。なので、例えば ble-detach の時に復元する\n      対象にはなっていないと考えられる。\n\n2023-09-03\n\n  * complete: copilot\n    https://github.com/akinomyoga/ble.sh/issues/358\n\n    * reject: AWS Copilog CLI (copilot completion bash)\n      https://aws.github.io/copilot-cli/ja/docs/commands/completion/ これは公式\n      の copilot for shell の様な気がする。一番初めにチェックするべきはこれの気\n      がする。copilot バイナリは何処で手に入るのかと思ったが standalone binary\n      がある。\n      https://github.com/aws/copilot-cli/releases/latest/download/copilot-linux\n\n      →うーん。上記の例は単に copilot コマンドのコマンド引数を補完する為の補完\n      設定だった。更に、試してみた所 github-copilot-cli と互換なサブコマンドは\n      提供されていない。そもそも AWS Copilot CLI は AI とは何も関係ない、AWS の\n      コンテナ等を管理する為のコマンド? の様だ。\n\n      全く関係ない物だった。\n\n    * これは GPT に質問をしてコマンドを生成させるという事をしている。\n      https://github.com/tom-doerr/zsh_codex/tree/main\n\n      現在の文脈情報について含めることができるのだろうか。例えば、現在のディレ\n      クトリの内容は云々だとか、README の内容は云々だとか。README の内容を普通\n      に書き込むとその中に書かれていることも直接 GPT に対する司令だと勘違いして\n      しまう可能性もあるのではないか。具体的にどのようにしたら良いのかの例はあ\n      るのだろうか。\n\n    * GitHub Copilot CLI\n\n      * github-copilot-cli (fish)\n        https://zenn.dev/tunefs/articles/b284d532ed5460\n        これは github-copilot-cli というのを呼び出しているみたいがだが、\n        github-copilot-cli は入力中のプロンプトの編集を手伝ってくれるのではなくて、\n        呼び出すと独自のインターフェイスに入ってコマンドを実行してくれるだけである。\n        https://www.npmjs.com/package/@githubnext/github-copilot-cli\n\n      * 取り敢えず以下の頁を参考にして登録してみる事にした。\n\n        https://zenn.dev/k9i/articles/56920952ce9644\n\n      waitlist で待たなければならない。\n\n2023-08-17\n\n  * ext: Android OS コンパイル環境での問題\n    https://github.com/akinomyoga/ble.sh/issues/353\n\n    Android OS をコンパイルする時に応答がなくなると言っている。これは Android\n    OS のバグなのではないか。調べてみると Android OS をコンパイルするのには4コ\n    ア使って数時間かかるとか言っている。仮想マシンの中で実行しようと思うとます\n    ます時間がかかるのではないか。しかも 18.04 LTS とかいう古い Ubuntu の OS で\n    やっている。\n\n    応答がない。\n\n2023-07-31\n\n  * bash <= 4.4 & contra & mercury で矢印キーが動かない\n\n    bash-4.4 で矢印キーが動かなくなっている。bash-3.2..4.4 の全てで動かなくなっ\n    ている。\n\n    % contra では起こるが xterm では起こらない。mintty でも起こらない。contra\n    % 特有の可能性もある。bash-5.0 以上では動いているので contra が悪いという事\n    % ではない気がする。 ESC O A 等の形式でキーを送信する端末において発生してい\n    % る。これは bind の問題の様な気がする。\n    %\n    % と思ったら再現しなくなった。どうも、一旦 mercury にログインした事のある\n    % contra の仮想端末でなければ再現しないという事だろうか。再現しない時には\n    % ESC [ A が送信されているが問題が再現する時は ESC O A が送信されている。うー\n    % ん。ESC O をその場で処理するかどうかが関係している気がする。然し試してみ\n    % たところ mercury にログインしても front1 にログインしても再現しない。再現\n    % 条件が分からない。こうなると xterm や mintty で起こらなかったのも偶々の可\n    % 能性がある。\n    %\n    % chat 経由で mercury に入っても再現しない。screen の中から mercury に入っ\n    % ても再現しない。chat の中の screen の中の mercury でも再現しない。\n\n    分かっている事: 端末が矢印キーに対して ESC O A を送信する状態になると\n    bash-4.4 以下で問題が発生する。然し、どのようにしたら端末が ESC O A を送信\n    する状態になるのかの再現方法は不明。\n\n    2023-08-02 再現方法が分かった。screen に入った状態で接続が切れたりして抜け\n    ると中途半端な状態になって ESC [ A の代わりに ESC O A が送信される状態にな\n    る。更に、この状態では bash-5.0 以降であっても矢印キーの振る舞いが変である。\n    複数行コマンドラインに於いて上下キーで行の間を移動したいが、ESC O A になっ\n    ている時には履歴項目の間の移動になっている。何故この様な違いが出るのかはよ\n    く分からない。kpup などに翻訳されているという事だろうか。また再現した時に\n    keylog でどのような受信・翻訳になっているかを確認する事にする。\n\n2023-06-21\n\n  * menu for history entries (requested by auwsom)\n    https://github.com/akinomyoga/ble.sh/issues/258#issuecomment-1599945461\n\n2023-05-19\n\n  * osh のテスト上で bash が失敗している。何故だろう。\n    http://travis-ci.oilshell.org/github-jobs/\n    http://travis-ci.oilshell.org/github-jobs/4035/app-tests.wwz/_tmp/soil/logs/ble-test-bash.txt\n\n    * 先ず mawk が正規表現を正しく処理できていない。然し手元の mawk では特に問\n      題がある様には見えない。arch 等でも問題が見られた記憶はない。最新の mawk\n      で試してみる価値はある。\n\n      > mawk: line 37: regular expression compile failed (missing operand)\n      > ^('[^']*'|\\$'([^\\\\']|\\\\.)*'|\\$?\"([^\\\\\"]|\\\\.)*\"|\\\\.|[^[:space:]\"'`;&|()])*\n\n      確認してみたが少なくとも Fedora に載っている mawk は Debian の最新の mawk\n      と同じである。という事は最新の mawk で問題があるという訳では無い様に思わ\n      れる。では逆に古い mawk で問題があるという可能性?\n\n      と思ったが mawk のページには最近幾つかの新しい version が公開されている。\n      これらを試す価値はある。改めて最新の物を試してみたが問題は再現しない。\n      2010 の物を試してみたが再現しない。念の為、最も古い物を試してみる。と思っ\n      たら再現した。2008 の物である。これは mawk のバグだと思って良いだろう。\n\n    もしかしたらテストの失敗もこの mawk によって引き起こされているのかもしれな\n    い。mawk を上書きした状態でテストを実行したらどうなるかについて確認する。うー\n    ん。実際にやってみるとテストに新しく2箇所失敗する。然しながら oilshell ci\n    上で見られたエラーは確認されていない。これはまた別の古い awk 実装によって問\n    題が発生している可能性があるだろうか。更に試してみるとこの2個のエラーは正規\n    表現のエラーとは関係ない様だ。\n\n\n    ? mawk の version check をする? テスト上で問題が発生しないのは 20090705 以\n      降である。また初期化時の正規表現のエラーが発生しないのは 20090710 以降で\n      ある。\n\n      ところが mawk が現在のバージョン表記に切り替えたのは mawk 1.3.3 20090721\n      以降の様である。それ以前は \"mawk 1.3.3 Nov 1996\" という文字列固定で表示さ\n      れている。バージョン表記に関しては mawk 1.3.4 以降であるか、または mawk\n      1.3.3 20?????? 的な形式をしていれば良いという事にする?\n\n      然し、このチェックを行う為だけでも初期化コストがかかる。そもそもこの様な\n      古い mawk を使っている場合というのは限られているのでそもそも判定しなくて\n      も良いのではないか。\n\n    todo: mawk のテストも test-bash に追加する事にする。\n\n2023-05-13\n\n  * complete: sed コマンドの補完\n    [1] https://github.com/akinomyoga/ble.sh/issues/326\n\n    zsh は sed -r[TAB] に対してちゃんと short flags を提示するし、\"sed\n    -re[TAB]\" に対して sed expression の説明を提示する。これらをbash-completion\n    と協力して実装する事はできない物だろうか。と思っていたら [1] でも要求された。\n\n2023-04-13\n\n  * bash は実は補完で pathname expansions の結果を候補として出す\n    https://github.com/scop/bash-completion/issues/444\n\n2023-04-10\n\n  * gnuplot 実装を真面目に考える?\n\n  * complete: here documents の補完\n\n    よく考えてみたらそんなに実装は簡単ではないかもしれない。素朴に考えると\n    completion-context にて here documents の中にいる時には here documents 全体\n    を補完対象としてい補完 source を生成すれば良い気がする。然しそれだと here\n    documents 全体が補完の置換対象となって着色が巨大になって自然ではない。\n\n    実はこれは長い文法的単語の中に含まれるファイル名などの補完の場合にも問題に\n    なる。実際にどの位置から補完を開始するのかが動的に変化する場合についても考\n    慮に入れるべきの気がする。そしてそれは source 毎に設定できる様にする?\n\n    a 然しそうすると補完開始位置が混在する事になる。或いは表示している時の着色\n      だけが問題という事であれば単に着色開始位置を各候補に記録させれば良いだけ\n      の気もする。\n\n    b 或いは source 毎に補完開始位置は固定にして異なる補完開始位置の source が\n      ある場合には、より前の位置から補完を開始した物を削除する?\n\n      これを実装する為には動的に COMP1 を変更する仕組みが必要になる気がする。果\n      たして source の生成途中で COMP1 を変更しても問題が起こらない様になってい\n      たのだったか。現在の実装だと source の呼び出しの時点で COMP1 が決定されて\n      いると考えて良い。なので、source の中で未だ候補を生成していない限りは\n      COMP1 は他に影響を与えていないので問題はないのではないかという気がする。\n\n      一方で既に述べた様に異なる source が異なる COMP1 を設定した時にどうするの\n      かという問題が生じる。\n\n      a これだと source 毎に補完を生成してから merge するという操作が必要になっ\n        てしまうのではないか。\n\n        然しその方が却って良いのかもしれないとも思う。現在の実装だと毎回一々\n        old_cand_count 等を記録したり部分的にfilter をかけたりと非自明な操作が\n        入っているので。然し、この様にしたとしても内部的に入れ子で source を呼\n        び出している実装の場合には結局毎回チェックは行う必要がある事に違いはな\n        い\n\n        集計を行うとしたら source に登録してもらう配列名 (cand_*) と、それらを\n        集めた結果の配列名 (merge_cand_*) を変える必要が出てくる。既存の実装の\n        全ての cand_* に対する参照を書き換えるのは大変なのではないか→取り敢え\n        ず数えると 104 個ある。其処まで多くはない。或いは、変数名はこれまでの儘\n        にしておいて、source を呼び出している関数で合成を行う?\n\n        また COMP1 についても各 source に対して用意して最後に統一するという手が\n        ある。\n\n        うーん。調べた所、cand_* に作用する関数は色々ある。source の内部でも\n        source の外側でも呼び出す可能性がある物を考えたらやはり変数名は変更せず\n        に generate-with-filter の側で切り替えを行う方が良いだろうか?\n\n        * 先ず使用実態を調査しなければならない。\n\n      b 或いは、以前の source が生成した物よりも後に開始位置をずらしたい場合に\n        は既に生成した補完候補は削除する事にして、また、一旦開始位置が後ろにず\n        らされたら後続のの補完 source はそもそも呼び出さないという仕組みにする?\n\n        x この方法だと補完候補生成が source の順番に依存する様になってしまう。\n\n      c 或いは、各 source の先頭で現在のずらされた状況を調べてもしずらされてい\n        たら補完候補を生成しない、もしくは補完候補を生成しないなどの対策を行う。\n        然し、この実装はそれぞれの source で細かい事を考える必要があるので余り\n        望ましくない。\n\n\n    c 或いは completion-context の決定の時点でコマンド毎に補完の開始位置をカス\n      タム計算できる様にする? しかしこの方法だと、最初に「単語全体の補完を試み\n      てその後で部分単語について補完を試みる」という段階的な補完を実行すること\n      ができない。\n\n2023-04-09\n\n  * contrib: (source snake.sh) して C-c C-c で停止させようとすると read が壊れる\n\n    read にて -u が変数名ではないというエラーメッセージが出て止まらくなる。\n    と思ったら再現しなくなった。よく分からない。\n\n2023-04-02\n\n  * set -o posix で起動すると keymap が見つからないというエラーが発生する\n\n  * history (bash 3.0): 履歴が重複して記録される\n\n    bash-3.1 以降では問題ない様だ。つまり bash-3.0 だけで起きている問題である。\n    これの優先度は低い。或いはもしかすると既知の問題である可能性?\n\n  * prompt: 右プロンプトの範囲に合わせて textarea の横幅を途中で切り替える?\n    https://github.com/akinomyoga/ble.sh/discussions/310\n\n    これはこれまでにも考えた事があるはずだと思ったが todo 項目が見つからない。\n    もしかすると頭の中で思っていただけかもしれない。\n\n    * scroll 機能との兼ね合い → rps1 も一緒に scroll する事にすれば良い。\n\n      少し考えてみたがどうも scroll 機能と conflict する気がする。scroll する毎\n      に各行の折返を実行し直すというのは well-defined なのか。というかそもそも\n      他のアプリケーションでもその様な変な形の枠の中で scroll しながら枠に合わ\n      せて折返を実行し直すという実装は見た事がない。\n\n      或いは、scroll する場合にはそれに応じて rps も一緒に scroll するという可\n      能性? その様にすれば変な事は気にしなくて良い。rps1 を途中で切断しなければ\n      ならないかもしれないがそれに関しては clip すれば良い気がする。\n\n      然し長いコマンドラインを実行した後に rps1 が表示されない状態で次のプロン\n      プトに行くという事にならないか。或いは長いコマンドラインの時には全体を一\n      旦出力して次に進むという事にすれば良いのだろうか。新しいコマンドラインに\n      移動する直前であればターミナルを溢れてしまっても問題ない筈なので。下手に\n      削られて記録が消えるよりはそちらの方が自然の気がする。\n\n      と思ったがスクロール範囲はプロンプトの最終行から始まる。なので、右プロン\n      プトもプロンプトの最終行以降に被っている部分だけスクロールする事になるの\n      だろうか。何だか複雑である。然し、そもそも右プロンプトもプロンプトの高さ\n      で範囲を制限していて非自明な事をしているのでその程度の事は寧ろ自然の気も\n      する。\n\n2023-03-27\n\n  * menu-complete: 長い候補を表示した後の再配置\n    Ref #D2025\n\n    これは WINCH 後の振る舞いにも関係している。WINCH があったら menu を閉じるか\n    或いは再配置を行う必要がある。現在は開きっぱなしになっている気がする。或い\n    は…何か変な状態になっている。info panel の高さはクリアされているけれども描\n    画されていない状態? の気がする。\n\n    本当は info に関係する winch の callback も欲しいという事。或いは panel\n    height 決定で要求したのと異なる高さになった時に呼び出す hook? というか単に\n    panel height change に対する hook で良い気がする。そして既にその仕組は\n    onHeightChange で実装されている。現状では info#panel::onHeightChange は実装\n    されていない。此処で info#panel::onHeightChange に際して現在の選択項目が範\n    囲外になっていたら再描画を発生させる hook を登録できる様にする。現在表示し\n    ている内容が menu なのかどうかの情報を何処に記録するのかはよく分からない。\n\n    どうも winch を実行すると瞬間的に高さが縮む様である。その後で続きを処理しよ\n    うとすると高さがまた元の高さに戻る。うーん。と思ったがそうでも無いような気\n    がする。前回と同じ高さであっても onHeightChange が呼び出されている。何故だ\n    ろうか。内容がクリアされてなくなってしまった場合にも呼び出されるという事と\n    思って良いか。\n\n    →うーん。どうやら潰れて見えなくなった時には onHeightChange は呼び出されな\n    い様だ。その後で最初に有限の高さに戻った時に onHeightChange が呼び出される。\n\n    然し height change を受け取ったとしてもその場で再描画する訳には行かない。既\n    に描画の途中でその処理の途中に height change が起こっているかもしれないから\n    である。\n\n    a うーん。onHeightChange に於いて invalidate を設定する? でもこれだと現状で\n      潰れた時に onHeightChange を呼び出していないので、潰れた事を検知できない。\n\n    b もしくは info#panell::render に於いて高さを毎回チェックすれば良いのかもし\n      れない。と思ったが、これも潰れた時に一度も呼び出されないので潰れてまた拡\n      大した時に検知できないのではないか。\n\n    取り敢えず menu-complete 中に長い行が選択されて info が縮まった後にもちゃん\n    と onHeightChange は呼び出される様だ。但し、onHeightChange が呼び出された後\n    に果たして render が呼び出されるのかは保証できない。上の枠組みで高さが変化\n    したら render を改めて呼び出すという事を処理する様にしてしまうと今度は無限\n    ループになるのではないかという懸念が生じる。\n\n    現状の canvas panel の枠組みにおける問題点は以下の二つである。\n\n    * onHeightChange が潰れた時に呼び出されない。潰れた時にも呼び出す様に変更し\n      たいが、既存の onHeightChange の処理がどうなっているか気になる。\n\n      更に潰れたという事が command-layout 等の都合で一時的に潰れる (後で全体を\n      再描画する予定) という事なのか、それとも他の panel が大きくて潰れざるを得\n      なかった (後で再描画はしない。より小さい領域に fit する様に処理する必要が\n      ある可能性はある) という事なのかで振る舞いが違っても良い。\n\n      一時的に潰れているだけなのであれば現状の様に onHeightChange は呼び出さず\n      に別の種類の処理を呼び出すべきの気がする。\n\n    * 一つの描画処理の中で既に描画し終わった panel の size change が発生した時\n      に、その panel を改めて再描画する様に処理するか?\n\n      然しそもそも描画処理の途中に高さが変わるという事があるのかというのは疑問\n      である。調べてみるとどの panel も途中で reallocate-height.draw を呼び出し\n      ている。そもそもこの段階で処理を再考するべきなのではないか?\n\n      最初の処理の段階で希望の高さを提出しておいて reallocate-height を実行した\n      後に各 panel の描画を開始する。各 panel は与えられた高さの中で表示する様\n      にする。もし足りない場合には fallback するか collapse する (減る分には問\n      題はない筈)。\n\n    * invalidate は panel 側でも管理するべき? 但し、分からない。\n\n2023-03-09\n\n  * complete: 末尾に不完全な \\ がある候補の specialchars フィルタリング?\n\n    最後に中途半端な \\ がある時には実はフィルターする時にも \\ で quote する必要\n    性のある文字が続いている物だけにするべきなのではないか。と思ったが処理的に\n    複雑になるのではないか? 取り敢えず末端に中途半端な \\ があるかどうかは\n    comps_flags に B が含まれているかどうかで分かる。\n\n    その上でその事実を用いて生成するファイル名を制限するかどうかというのが問題。\n    然しその制限を適用する事によって候補がなくなってしまっては変な気もする。\n\n    a 全ての候補を生成してから、生成候補を制限しても候補が残るようであれば制限\n      をかける事にしようと思ったがそうしたとしても異なる種類の候補が混ざってい\n      る時に不用意にフィルタできない。例えば sabbrev 候補は絞り込みの為に cand\n      には quote を処理した後の値を入れている。\n\n    b と思ったが quote の必要のない候補ばかりの時には生成候補がなくなっても良い\n      気がしてきた。\n\n    そうは言っても問題になるのが bash-completion によって生成される候補を制限す\n    るかしないかという事。実際に生成している側でないとその意図は分からない。\n\n2023-03-08\n\n  * :name: に対して emoji 変換を実装する?\n\n    https://www.webfx.com/tools/emoji-cheat-sheet/ に一覧がある。\n    然し、emoji リストの難点は思い出すのが大変という事。リストを表示できたら良いのだが。\n    例えば sabbrev -m 経由で挿入するというのが良いかもしれない。:: を使う。\n\n  * [保留] canvas/panel: 一旦 scroll buffer に行ったものを元に戻す可能性? (motivated by mozirilla213)\n\n    https://github.com/akinomyoga/ble.sh/discussions/288#discussioncomment-5226973\n    > (And the completion words fill and cut the previous output when scrolling\n    > up the terminal which I think is a known limitation which is fine,\n\n    panel の set-height で行が消えてなくなる? うーん。然し報告者の使っているら\n    しき konsole では特に内容が失われるということはない様である。ちゃんと\n    scroll buffer に内容が残っている。\n\n    恐らく scroll buffer に行って一旦画面から見えなくなるという事を言っているの\n    だろう。或いは、一旦 scroll buffer に行った物を、menu が閉じた後にある程度\n    回復するという事。端末によっては何かそういう様な拡張をしていた様な気がする\n    のでそれを有効にする可能性はある。\n\n2023-03-02\n\n  * menu-complete: C-TAB を連続で押すと仮挿入をそのままに新しい補完が始まる\n\n    menu-complete の外側の keymap で menu-complete が設定されている時には単に\n    menu_complete/forward にしたりなどした方が良いのではないか。\n\n    と思ったが menu_complete に対して引数が指定されている時などにどのように対処\n    するべきかわからない。例えば insert_all や insert_brances や context=* が指\n    定されている場合には単に移動するのではなくて今の補完を明示的にキャンセルし\n    て新しく補完し直すべきなのではないか。然し、単なる complete や\n    menu-completion や menu-complete backward 等の時には改めて開始するのではな\n    くて内部での補完候補の移動を行いたい気もする。\n\n    然しチェックするにしても全ての文字をチェックしていると大変である。と思った\n    が、UTF-8 decode や key decode 等の処理の重さなどを考えたら大した事ないとい\n    えば大したことない。\n\n  * menu-complete: suffix もメニュー選択時に表示する機能?\n    https://github.com/akinomyoga/ble.sh/discussions/297#discussioncomment-5159146\n\n    然しこれは最後の確定時にならないと計算されない。メニューを選択した時にそれ\n    も計算する? 然しそうするとしてもrequote だとか前方の文字列の吸収だとかその\n    他の処理についてはどうするのか。\n\n    特に前方の文字列の吸収に関しては実際に実行してしまうと元々の内容が消滅して\n    しまうので駄目である。或いは前方の文字列に一致する物がある場合には単に挿入\n    部分の方を短くすれば良いのかもしれないが、それはそれで着色範囲が変になって\n    しまって見にくい。更に前方に完全に一致する場合には挿入文字列の幅が 0 になっ\n    てしまって見えなくなる。また確定した時に何処にカーソルが移動するのかという\n    のも分かりにくい。\n\n  * wiki: Design Widget の翻訳?\n    https://github.com/akinomyoga/ble.sh/discussions/272#discussioncomment-5013253\n    https://github.com/akinomyoga/ble.sh/discussions/294\n    https://github.com/akinomyoga/ble.sh/discussions/301\n\n    何やら色々変な事を試そうとしている人がいるみたいなので。\n\n2023-03-01\n\n  * [保留] decode: M-S-o と M-O のどちらか一方に強制的に揃える?\n\n    現状では二つの形式に同じ binding を与える様に設定しているがわざわざ両方設定\n    するのは大変である。一方で、CapsLock 等を考慮に入れると両者は実は互換ではな\n    い。更に端末によって CapsLock がある時の振る舞いや、S を付加している時に\n    Shift 前の文字を底字にするのか Shift 後の文字を底字にするのか振る舞いが異な\n    る。なので正確に判定するのは難しい。\n\n  * [保留] ble/builtin/readonly などの上書きを function#push で行う?\n\n    ユーザーが独自に定義していた時などにそれを保持する為。また、ユーザーコマン\n    ドを実行した直後にユーザーが上書きしていたら改めて push を行う。その時には\n    既に push chain の中に登録済みであればそれを削除する等の仕組みが欲しい気が\n    する (opts 引数で指定)。\n\n    これはわざわざ表示しなくて良い気がする。\n\n2023-02-27\n\n  * [保留] complete: compopt -o filenames が指定された時に末尾の空白を除去する?\n    bash の振る舞いを確認する。\n\n2023-02-20\n\n  * autoenv 実装\n\n    既存の物と同じ設定ファイルを使い回す事を検討するべきだろうか。zsh-autoenv\n    は .autoenv.zsh を使っている。これに倣うのであれば .autoenv.blesh という物\n    を用意するのが便利である。\n\n    * authorized 的なファイルの形式はどうするか。何処に記録するか。sha256sum を\n      呼び出せば良い。然し、sha256sum が存在しなかった時にどうするのかや、前に\n      無かったのに新しくインストールされた場合にどうするのか等が非自明である。\n      取り敢えず cksum は存在すると思っておくべき? あと、前にはあったけれどもな\n      くなってしまったという場合にもどうするのか困る。うーん。ファイルには hash\n      の形式も一緒に記録する事にするのが良い気がする。\n\n    * bleopt push/pop の機能を実装するべき。bleopt --push ... 等とする? 或いは\n      全ての設定を一斉に push するという手もあるだろうか。或いは、bleopt 自体に\n      hook して .autoenv を実行中の変更を全て track する。これが楽の気がする。\n\n    * function については ble/function#push/pop を使ってもらう。alias は ble.sh\n      側で追跡する。adjust の中で定義して大丈夫なのか? 抜ける時には特に今まであっ\n      たものを敢えて削除する事はしないので一応使える? 然し、以前の alias が退避\n      されていた場合にそれが restore される時に上書きされて昔の物に戻ってしまう\n      という事が起こるのでは。という事を考えると alias に関しては adjust を一旦\n      restore しておく必要があるのではないか。他にも FUNCNAME 等が気になる。\n\n2023-02-12\n\n  * syntax: 5.0 以降では関数名として function `xxx` 等も実は許されている。5.3\n    以降では更に <(...) も関数名として使える。しかもこれらは `xxx`() や\n    <(...)() の形式でも定義できる。\n\n    現在の実装では関数名を function NAME まで一回の解析で進むようにしている。何\n    故だったか。何か理由があった気がするが、この取扱になっている限りはちゃんと\n    対応するのは難しい。過去の記録を調べる必要がある。\n\n  * complete: shopt -s extglob failglob で @(aa)() { echo; } という関数を作成し\n    て置くと screen -dr の補完の途中でエラーメッセージが表示される。何処から表\n    示されているのだろうか? 関数名を拾って更にその上でそれをパス名展開に晒して\n    いる箇所があるのだろうか? simple-word ではないので ble.sh の内部ではないの\n    ではないか…という気がするが分からない。\n\n2023-02-06\n\n  * auto-complete: cd 等簡単に成否が分かる物については判定して除外する可能性\n\n    然し cd を上書きしている場合等にはやはり問題になる。またコマンド毎に対応す\n    るのは大変なのでこれも progcomp, chroma の様に判定するシェル関数を用意する\n    可能性。ただ、問題なのは、単純コマンドでない時にコマンドの位置などの判定を\n    行う必要があるという事。そしてその為には構文解析を各項目に対して回す必要が\n    ある。という事を考えると重くて現実的でない気がする。\n\n2023-02-03\n\n  * contrib: ble-import で contrib/ は不要なのではないか?\n\n2023-01-26\n\n  * histdb: history の中から情報を取り出してそれを使って何かする機能\n\n    これができなければそもそも実装する意味がない。例えば auto-complete で単語を\n    表示する等。\n\n    * done: wiki: BLE_SESSION_ID, BLE_COMMAND_ID\n\n    * 履歴を操作・編集(削除)する機能も欲しい。\n\n      histdb [list]                 コマンド一覧\n      histdb list-session [options] セッション一覧\n      histdb delete [OPTIONS]       コマンド削除\n      histdb -s [.|session]         セッション指定\n      histdb -d [.|dir]             ディレクトリ指定\n      histdb -t [.|dir]             ディレクトリ指定(サブディレクトリも含める)\n      histdb -g glob                コマンドをパターンで絞り込み\n      histdb -c command_id          コマンドIDによる指定\n\n2023-01-25\n\n  * complete: 英単語の曖昧補間やスペルミスの検出など\n\n    この場合には一意確定だとしても挿入はしない方が良い。コマンド引数\n    (source:argument) についてその他の候補生成が全て生成に失敗した時にこれを実\n    行するのが良い気がする。そしてその場合には勝手に挿入しない事を表す flag か\n    何かを設定する事にすれば良い。\n\n    英単語辞書は bash で処理すると遅いので awk か或いは外部コマンドを呼び出すべ\n    き。或いはこれまでに実行したコマンドから拾ってくる? これまでに実行したコマ\n    ンドに関しては変な切り取り方をしても仕方がないので、\n\n    a 予めコマンド実行時の文法解析結果を元に単語を抽出してファイルに記録してお\n      く。これは comps との一致対象。記録は state ディレクトリの中にファイルを\n      作成すれば良い。~/.local/state/blesh/history.xword.txt 等。\n\n    b 同様に単語がファイル名に一致する場合にはそのファイル名を記録する\n      (history.filename)。現在ディレクトリとの組にして記録するとより良いかもし\n      れない。これは compv に対して一致を試みる。\n\n      x 現在ディレクトリとの組にするのだとしたら結局現在ディレクトリで普通にファ\n        イル名補完をするので十分なのではないか。逆にディレクトリに関係なくファ\n        イル名を記録するとしても何か用途はあるだろうか。結局単語補完と実質同じ\n        なのではないか。\n\n    c 更に、simple-word の時には展開結果を記録する (history.vword.txt)?\n\n      x 展開結果が長大になる可能性がある。\n\n    d 更に c をスペース等で分割して単語を記録する (history.eword.txt)?  然しこ\n      れも変な物を記録しても仕方がないので bash special chars に関しては含めな\n      い様にする。もしくはそれらも分割子として取り扱う。これも compv に対して一\n      致を試みる (特にスペース等で分割した後の直近の文字列に対して判定する)。\n\n    history に関しては ToDo 2021-05-17 に関連項目がある。\n\n2022-12-09\n\n  * edit,complete: alias expansion で alias sudo='sudo ' 等による引数の展開に対応?\n\n2022-12-03\n\n  * declare -f の出力は特殊関数名には使えないのではないか?\n    https://lists.gnu.org/archive/html/bug-bash/2022-12/msg00010.html\n    https://lists.gnu.org/archive/html/bug-bash/2022-12/msg00011.html\n\n    取り敢えず、これは evaldef の時点で function を prefix すれば良い気がする。\n    今後の Bash の振る舞いの変更で function が追加されるかもしれないので、その\n    時にはそれを避ける様にする。\n\n    更に変数代入の形の関数名は declare -f &>/dev/null でテストする事もできない。\n\n  * colorglass: face から読み取る時に作用する色設定?\n\n    現在は全ての出力に対して色を変更しているが、プロンプトのテーマを別に指定し\n    ている場合などを考えると、プロンプトの色には作用して欲しくない気がする。一\n    方で元々の colorglass のアイディアでは全ての色に対して作用する事を考えてい\n    た。両方の種類のオプションを提供するという手が考えられる。例えば、現在のオ\n    プションはそのままにして、colorglass_face_* という物も提供する。\n\n    インターフェイスは別として実装は考える必要がある。\n\n    a 現在は face は全くキャッシュしていないので、face 読み取り部分に filter を\n      挟むとなると遅くなる。或いはキャッシュするか。キャッシュするとしても将来\n      的に face 間に依存性を持たせる実装を考えると個別にキャッシュできない。\n\n    b 或いは、別の colorglass domain の区分けとしてプロンプトを処理する時とそれ\n      以外で分けるという事も考えられるだろうか。しかしそれだと vim-airline の設\n      定は prompt に含まれるので既定の色を抑える等の調整ができなくなる。\n\n2022-09-15\n\n  * vim terminal や neovim terminal における keymap-timeout に対応する設定は何\n    か。調べてみると ttimeoutlen や timeoutlen という物がある様だが、これの設定\n    を変更しても振る舞いに変化はない気がする。後でちゃんと調べる必要がある。\n\n2022-09-11\n\n  * 何らかの拍子に P[0 q の様な謎の文字列がユーザーコマンドの実行後に出力される\n    様になる。\n\n    これは DECSCUSR に関係しているのは確かだと思われるが、どうやって起こるのか\n    分からない。例えば _ble_term_Ss 関係の変数が変な値になっているのが原因かと\n    も思われたが別にこれらの変数に問題はない。P[0 q の様な文字列が含まれている\n    変数も存在しない様に見える。\n\n    * bleopt term_cursor_external=1 を設定してみたらコマンドが始まる前にも変な\n      メッセージが出力される様になった。つまりやはり cursor-state の管理の部分\n      で起こっている問題なのだろうと思われる。\n\n    * 新しい bash を開始すると別に問題は生じない。また、そもそも表示幅も狂って\n      いる気がする、と思ったがこれは本来端末に文字列として表示されない物が表示\n      されている事によって位置がずれているだけなので、元の問題を解決すればこれ\n      も解決する筈。\n\n    コードを確認してみたら分かった気がする。quote-passthrough によって付加され\n    た P が表示されてしまっているのである。そして、端末の入れ子情報が壊れている。\n    実際に問題が生じている端末で C-xC-v で端末情報を出力してみた所、どうやら\n    screen が三重に入れ子になっていると勘違いしているようである。\n\n    terminal: TERM=screen.xterm-256color wcwidth=14.0-emacs, screen:49900\n    (83;49900;0), screen:49900 (83;49900;0), screen:49900 (83;49900;0),\n    contra:0 (99;0)\n\n    何故後になってこの様な変な状態になるのか分からないが、ble.sh を reload した\n    らちゃんと端末の入れ子状態の情報も正しくなって問題も起こらなくなった。\n\n2022-08-31\n\n  * complete: 'a b c' というファイルがある状態で 'b [TAB] すると変な事になる。\n\n    →今試してみると再現しない。bash-completion をロードしていてもしていなくて\n    も問題なく補完される。\n\n  * complete: ~/b/c/スペースを含むファイル[TAB] としても requote されない。\n\n  * complete: 変数名の曖昧補完が効かない。一旦候補を生成したら menu-filter によ\n    る曖昧絞り込みはできている。\n\n2022-08-29\n\n  * DEBUG trap についても関数呼び出しの階層を再現する?\n\n    user-handler#{load,has} がそれぞれの文脈で \"現在の文脈での handler\" を取得\n    しようとしているのか、或いは \"何れかの文脈で handler があるか\" を取得しよう\n    としているかをちゃんと区別する必要がある (というか関数を二種類作るべき?)\n\n    また \"現在の文脈\" を正しく取得できているかどうかについてもちゃんと確認する。\n\n    install-hook については top-level での hook があるかどうかを確認したい。結\n    局 trap - DEBUG されない限りは何処かの stackframe で定義されている DEBUG\n    trap が top-level に適用されると考えると、何れかの階層の handler があればそ\n    れで判定していると思って良い。但し、install-hook については、初期化時に\n    user が builtin trap で既に設定しているかどうかを判定する為に用いていて使い\n    方が特別である。何れにしても、何処かの階層で既に定義があればユーザーの設定\n    した builtin trap は無視するというので良い。[ しかし実はそもそも DEBUG は\n    install-hook 内に継承されないので extdebug/functrace が設定されていない限り\n    判定できないしその様に条件で弾いている ]\n\n2022-07-10\n\n  * syntax: posix syntax check in posix mode?\n\n    対応が面倒そう。本当にエラーになる訳では無いので普通のエラー着色とは少し異\n    なる着色にする?\n\n  * complete: - で始まるファイル名には ./ をつける?\n\n    * コマンドによっては + で始まるファイルについても ./ をつける必要がある事も\n      ある。そもそも + で始まるファイル名は普通ではないという事を考えると、+ で\n      始まるファイル名についても - で始まるファイル名と同様に一律で ./ をつける\n      様にしてしまって良い気がする。\n\n    * './' を前置するという事は遡って書き換えるという事を意味する。どの様に取り\n      扱うべきか。\n\n      a うーん。INSERT 時に suffix を付加するのと同じ要領で ./ を挿入するという\n        事にする? ./ は shell special characters を含んでいないので quote の状\n        態がどうであれ勝手に挿入してしまって良い。\n\n      b オプション名及びファイル名の両方の候補がある場合に menu-complete で両方\n        選択肢を表示したい時にどうするのか。という事を考えると CAND の時点で ./\n        をつけてしまって独立な二つの候補にする必要がある。という事を考えると元\n        より CAND の時点で ./ をつけるべきなのかもしれない。\n\n        然しこれだと実は filter されてしまうのでは?\n\n      c a と b の両方を行うのが良い気がする。曖昧補間 (部分一致) の場合には b\n        の方法だと filter されてしまって出て来ないので、最終段階で ./ を挿入す\n        る様にすれば良い。一方で、先頭一致の場合にはオプション名候補と区別する\n        為に ./ は CAND の時点で付けておく事にする。\n\n    * --prefix=filename の様に生成した場合には --prefix の前に ./ を付加してし\n        まわない様に、ちゃんと prefix 部分を認識して戦闘の [-+] 判定を行うべき。\n\n    ble.sh builtin filename generation で ./ を付けるのは良いとして、progcomp\n    で生成された - で始まる単語で同名のファイルが存在する場合にどうするか?\n    progcomp で生成された物でファイル名に一致する物があった時に、それがオプショ\n    ンを意図した物なのか或いはファイル名を意図したものなのかを区別する手段はな\n    い。\n\n    a bash-completion の _filedir 等に介入して ./ を付加する? 一方で、これでは\n      もっと細かい補間関数で個別に生成している物や、bash-completion ではない設\n      定に関しては対応できない。\n\n    b 或いは同名のファイルがある場合には問答無用で ./ を付加する事にする?\n\n  * complete: 空白で終わる alias の対応?\n\n    空白で終わる alias は次の単語の alias 展開も引き起こす。然し一方でコマンド\n    さえ確定してしまえば後はそのコマンドの補完によって対応するべきという考え方\n    もある。うーん。それでも alias を設定するのはユーザーであり、そのコマンド自\n    身ではないと考えるのであれば、やはり ble.sh の側でその辺りを解決して補完を\n    呼び出すべきではないだろうか。\n\n2022-07-06\n\n  * complete: func() TAB 及び function func TAB で関数定義を挿入する。\n\n    bash-completion では function func [TAB] でこれに対応しているので。現在は\n    function aaa の時 aaa には単語を設置していないが必要があれば登録しても良い。\n\n2022-07-04\n\n  * [保留] debug_xtrace を bash-4.0 以下でも対応する?\n\n    debug_xtrace が bash-3.2 で動いていない。と思ったらそもそも BASH_XTRACEFD\n    は bash-4.1 以降の機能だったのだ。bash-4.0 以下では 2 を redirect する事に\n    よって実現する? と思ったが 2 は ble.sh が出力するのに使っている気がする。特\n    に ble/util/buffer.flush で使っている。更に他にも様々なエラーメッセージが 2\n    に出力されるのではないか。という事を考えると 2 を xtrace に使うのは余り良い\n    ことではない様な気がする。取り敢えず保留という事にする。\n\n  * ext: trueline と組み合わせた時に問題が起こるとのこと。\n    https://github.com/lecramyajiv/Emptydeeds/commit/b57e8354cc350d71c655d93c32112427ec8addda#diff-0a1c1083789380c5f4b4aaebd19b6a4b2431ae808f8b456cf865825cfb93b9dfR2527\n\n2022-06-19\n\n  * 履歴番号を検索やプロンプトで表示しているが、これは history の最初が 1 でな\n    い時にはずれるのではないか。後で確認する必要がある気がする。\n\n2022-06-14\n\n  * cygwin: bash --norc, source すると C-xC-v 等の keybinding が動かない\n    bash_execute_unix_command のエラーが出る。\n\n    これは元々存在している inputrc か何かが悪さをしている可能性? 然しそうだとし\n    ても普通に attach したら問題は生じない。なのでやはり違うのだろうか。\n\n2022-06-02\n\n  * bash-4.4 crash (reported by notmike-5)\n    https://github.com/akinomyoga/ble.sh/issues/195\n\n    source した瞬間に crash するという事だろうか?\n\n    一方で別の問題を発見した。bash-completion scp の補完で 4.4 がcrash する。こ\n    れは ble.sh なしでも再現する。また、bash-5.0 以降では発生しない。\n    bash-4.2..4.4 の全てで再現する。これは後で bash-completion の側で対処が必要。\n\n2022-05-12\n\n  * isearch: 現在行と全く同じ内容の行には一致しないというオプション\n\n2022-03-19\n\n  * 編集文字列に含まれる制御文字の反転表示の可能性\n\n    現在は見た目には区別がつかない。プロンプトシーケンス \\w, \\W, etc に含まれる\n    制御文字については反転の toggle で対処している。\n\n    一方で、現在の実装だと単純に編集文字列に含まれる制御文字の反転状態を変更す\n    る事はできない。着色に関係なく制御文字の表現を決めている、つまり地の反転状\n    態に関係ない escape sequence を決める必要があるが、地の反転状態が分からなけ\n    れば制御文字が終わった位置で正しく反転状態を復元することができなくなる。\n\n    これについてはまた今後必要性を感じた時に実装すれば良い気がする。\n\n2022-03-03\n\n  * 起動時の fork について\n\n    * ble/base/adjust-builtin-wrappers/.assign (2 fork) ... 此処で builtin,\n      alias を保存する為に2回に分けて defs=$(...) を実行している。この時点では\n      初期化が終わっていないので ble/util/assign は使えない。\n\n      これはそもそも勝手に上書きした builtin や alias を保持する必要があるのか\n      という事を考えるとスキップしても良い様な気がする。起動の高速化の為にこう\n      いった物を省略するオプションを用意して良い様な気はする。\n\n    * ble/util/msleep/.check-builtin-sleep ... これはロードに失敗した時の事を考\n      えて subshell 内部で実行している。\n\n      これも sleep の方法を予め引数等で指定する仕組みを用意しておけばスキップす\n      る事は可能である。また builtin sleep に頼り切るのも問題の気がする。という\n      か builtin sleep だと C-c が効かない等の問題がある。\n\n      改めて plain Bash に builtin sleep を読み込んで動作を調べてみる。と思った\n      が再現しない。というよりそもそも ble.sh をロードしていても bash-5.0 でし\n      か再現しない。つまり bash-5.0 & ble.sh の時にだけ bultin sleep 3 で C-c\n      に対して即座に実行が中止されない。ble-detach していてもこの問題は発生する。\n      plain Bash で直接 enable -f /path/to/sleep sleep して sleep 3 に対して\n      C-c した時にはちゃんとすぐに終了する。\n\n    * ble/builtin/bind/read-user-settings/.reconstruct ... これは記録されている\n      default bash の binding と、現在の binding を比較してユーザーが設定した\n      keybinding を抽出する為に awk を呼び出している。\n\n      これは既存の readline 設定を読み取らない事にすればスキップはできる。実際、\n      ble.sh の読み込み時に --noinputrc を指定すればこれは実行されない。\n\n    以上の物は何れもユーザーオプションで省略できる様な機能ではある。然し一方で\n    ロードのボトルネックは実は fork ではない。少なくとも Linux では。但し、\n    Cygwin では 50ms/fork かかるので 4 fork 省略できるだけで 200ms も時間を短縮\n    できるので大きい。\n\n2022-02-20\n\n  * より一般の補完 framework に向けたインターフェイスについて\n    https://github.com/rsteube/carapace/issues/431\n\n  * compopt 実装: 現在の実装では \"name\" や -DEI が与えられた場合には何もせずに\n    戻る様になっているが、本来現在の設定を変更するべきなのではないか。また、丁\n    度変更対象の補完が現在の補完と一致している時には現在の補完の振る舞いに影響\n    を与えるべきなのではないか。これについては実際の Bash の振る舞いを確認する\n    必要がある。\n\n  * rsteube の記事\n    https://dev.to/rsteube/a-pragmatic-approach-to-shell-completion-4gp0\n\n    filtering を description に対しても適用するという事が書かれている。それは確\n    かに便利そうである。現状の実装では対応が難しい様には思われるが。これは fzf\n    の様に一旦絞り込み専用の入力欄に移動するなどの事がないと使いにくいだろう。\n\n  * trap (lastarg): 一応 heredoc 等を使えば eval の中から複数行の lastarg を設\n    定する事ができるのではないか。他に複数行で、eval されても余分な実行が起こら\n    ない様な方法はあるだろうか。不完全な引用符の場合には結局エラーが出力されて\n    しまう。\n\n    Ref #D1853\n\n  * [保留] exec: builtin sleep に対して C-c が効かない\n\n    % 現在の実装だと bash-5.0 以下で C-c でループ中に走っている外部コマンドを止\n    % めた時に応答がなくなってしまう。bash-5.1 以上では一旦実行が停止するものの\n    % 一応応答はする。\n\n    と思ったらこの問題は外部コマンドではなくて builtin sleep を呼び出している時\n    特有の問題だった。trap INT を設定しているのは問題なのだろうか。\n\n  * edit: 現在の TRAPDEBUG の枠組みを拡張して try/catch/finally を実装できるのでは\n    Ref #D1783\n\n    もしその枠組がちゃんとできるのであれば edit.sh から util.sh に移動する。\n\n2022-02-14\n\n  * 全ての ble.sh session にコマンドを送る機能があれば screen に再 attach した\n    時の再調整等に役立つのでは。\n\n    _ble_term_TERM の最初期かもできるし、或いは DISPLAY 環境変数の再設定もでき\n    る。チェックの頻度は history-share と同様で良い気がする。\n\n  * ble/builtin/trap DEBUG は関数の入れ子や trace 属性などは考慮していない。こ\n    の事によって問題が起こる可能性もある。\n\n2022-02-12\n\n  * highlight: ls -l ~/.c{onfig,a/b}\n    ブレース展開の中に / が含まれているとディレクトリパス着色が動かない。\n\n    うーん。そもそも highlight の仕組み的に / が含まれているとどうしたら着色で\n    きるか謎という可能性がある? と思ったが恐らくそういう事ではない。何れにして\n    も全体を一番最初に一致した PATH に対する色で同じ色で着色する様になっている\n    筈。但し、その着色を実行する上で / で分割してから各 segment に対して着色す\n    る様になっている為に、brace 展開中に / があると / で分断されてしまって正し\n    く着色できないという事になるのだろう。\n\n    ちゃんと対応する為には、\"ブレース展開に対して最初の要素で着色をする\" のでは\n    なくて、ちゃんと各要素に対して着色をするという方向に改める必要があるのかも\n    しれない。然し、それは実際の所面倒だし、そこまでする必要があるのかというの\n    も謎である。これは優先度は低いがもし実装できたら面白いだろうという事である。\n\n2022-02-08\n\n  * [保留] compat: bind -x 実行後の再描画はプロンプト最後の行以降\n    https://lists.gnu.org/archive/html/help-bash/2022-02/msg00023.html\n    https://lists.gnu.org/archive/html/help-bash/2022-02/msg00031.html\n\n    どうも bash で試して見た所 に於いてはプロンプトの一番最後の行以降だけが再描\n    画の対象らしい。現在の ble.sh の実装だと全体を再描画している。これだと\n    help-bash に投稿した様な hack が使えなくなる。\n\n    a Bash と同様に途中から出力する様に調整すれば良い。と思ったが、よく考えたら\n      現在の実装では prompt は一気に出力する事になっているので一番最後の行だけ\n      出力するという話はない。\n\n    b うーん。その場で clip すれば良いのかもしれない。然しそれは処理として重く\n      なる。また、clip した場合には結局描画する時にはカーソルを相対移動させる事\n      によってカーソルが本来の位置に戻ってしまう。つまり、hack は結局使えない。\n\n    そもそも hack を使える様にするという発想がおかしいのだとも言える。特に件の\n    hack に関しては ps1_final で代用できる。それ以外の目的で描画を乱すとしたら\n    それはやはり対応外であるし、もしそういった描画に対する介入を想定しないので\n    あれば、結局全体を描画するという現在の振る舞いで特に問題は生じない筈である。\n\n2022-02-05\n\n  * syntax: a=(%{1..10}) の % を '\\x' に書き換える時文法構造が破壊 (?)\n\n    $ bash\n    $ rep=(%{25,08,0A,2{0..2},24,2{6..9},3B,3C,3E,5C,5E,60,7C})\n\n    として起動した直後に上記の文字列を貼り付けて、それから先頭の % を削除して\n    '\\x' と入力したら文法構造が壊れてしまった。然し二度と再現しない。問題は '\\x\n    迄入力した時点で発生していた。もしかすると ' か \\ を入力した時点で既におか\n    しくなっていたのかもしれない。\n\n2022-02-03\n\n  * キャッシュの判定でファイルを使って判定しているが、よく考えたら現在ロードさ\n    れているコードとファイルに含まれているコードが同じとは限らないのではないか。\n    もし、現在のシェルの起動時刻よりも比較に使っているファイルのほうが新しい時\n    は、ble.sh 自体を reload した方が良いのではないか。と思ったがそれによって失\n    われる設定も考えられる。という事から勝手に reload する訳にも行かない。\n\n    起動時刻(というよりble.shロード時刻)を示す一時ファイルを使うという手も考え\n    られるが、それだと後になってロードした module の場合には不正確になる。と思っ\n    たが、古いコードを使って更新を実行してしまうよりは、新しいコードなのに古い\n    情報を更新せずに利用するという位の方が未だましである。\n\n    実はロード時刻は $_ble_base_run/$$.load に既に存在しているのでそれを使えば\n    良い。\n\n    検索してみると結構影響のありそうな箇所は沢山ある。一方で具体的にどの様に直\n    すのか。load time だけで判定すると毎回キャッシュを更新する事になってしまっ\n    て意味がない。(キャッシュが最新でない) & (load time よりも前に元のファイル\n    が更新されている) という条件で判定するのが良い気がする。\n\n    * キャッシュが最新でないというのは必須の条件である。そうでなければそもそも\n      更新を実行する意味がない。load time が元ファイルより最近の場合にも何も問\n      題は生じないので今迄通りに何も気にせずに更新すれば良い。\n\n    * 従って、特に判断が難しいのは (キャッシュ),(LoadTime) > (元ファイル) の場\n      合である。更に元ファイルを source した時刻は実は元ファイルよりも後の可能\n      性もある。その時にはメモリ上には最新版があるのでそれに従ってキャッシュを\n      更新しても問題ない。\n\n    * よく考えたらここで対策をしても問題は生じるのではないか。元々キャッシュファ\n      イルが存在しなくて、メモリ上に古い version の関数があって、それに基づいて\n      新しくキャッシュを作成した場合、古い version のキャッシュがずっと残ってし\n      まう。\n\n      うーん。load time で time stamp を書き換える様にすれば良いのだろうか。\n\n2022-01-23\n\n  * \"for ((i=0;i<10;i++)); do sleep 1; done\" で C-c すると ble.sh 全体がその場で停止する\n\n    これは外部コマンドを実行中にそのコマンドが SIGINT で終了した場合、trap INT\n    に登録されたハンドラーを介さずに即座に実行全体が終了してしまうのが原因であ\n    る。\n\n    もしそれがトップレベルのコマンドであれば ERR を用いて捕まえる事はできる。但\n    し、それが SIGINT によって引き起こされたものなのか、普通のエラーとして返さ\n    れたのかを判定する方法はない。\n\n    更に関数内で実行された場合には ERR でも INT でも捉えられない。RETURN を使っ\n    ても捕まえられない。これを解決する方法はない気がする。\n\n2022-01-08\n\n  * mandb: echo のオプションの抽出 (help echo) がおかしい at fc35 vm\n    chatoyancy では問題は発生していない\n\n2021-12-22\n\n  * ディレクトリ固有の local commands & aliases を可能にする?\n\n    一方で、勝手に設定をロードする様にしてしまうと怪しいディレクトリに入っただ\n    けでそれが有効になってしまうという事が発生する。なので、一旦は enable する\n    操作を求めるべきだし、また内容が変更されたらその都度承認を求めるべきである\n    (過去に承認したものは hash か或いは実体を記録しておいて再度尋ねはしない様に\n    できる)。\n\n    →direnv が丁度同じ事を目的としたプロジェクトの様である。\n\n    2023-01-30 direnv が一体どういう事をしているのかについて調べる → #M0023 に\n    纏める事にした。\n\n2021-12-20\n\n  * git-prompt, git-status 等の機能の模倣?\n\n2021-12-18\n\n  * contrib/git: dirty で rps1 が更新された瞬間にカーソル位置がずれた。これは後\n    で調べる必要がある。\n\n  * deprecated functions の枠組みを整える。\n\n    散発的に deprecate して行くと毎回設定を変更しなければならず面倒なので、\n    version を指定して特定の version 以降になった時に限り初回だけ警告を表示する\n    様にするのが良い。\n\n    ((_ble_version>=500)) && ..... と言った具合。\n\n    ? reject: deprecation は version ではなくて独立な番号付を使う可能性?\n\n      →omb において考えていたが、これは特定のバージョンを予め指定するよりは\n      deprecation level の様な 1 個ずつ増える整数にするのが良い。というのも、そ\n      もそもどの version で完全廃止するのかというのは廃止を決定した瞬間には分か\n      らないという事。そして、実際に廃止する瞬間には基本的には全て一度に廃止す\n      るのであって、機能によって廃止したり廃止しなかったりという事はない。なの\n      で基本的には、新しく廃止をマークする時には次の deprecation level を指定し\n      ておいて、deprecation level が上がる時に一斉に廃止するのが良いと思われる。\n\n      一方で、もしかすると緊急で廃止したいという状況が現れるかもしれないので、\n      deprecation level は基本的には 100 の倍数にして置いて、細かい廃止を実行し\n      たい時に限って 1 ずつ上げる様にするというのも手である。と思ったがその様に\n      考えると結局それは _ble_version と同じになるのではないかという気もする。\n      但し、基本的に廃止等は master でしか起こらない気がするので patch level と\n      deprecation level に関してはずれが生じるだろう。\n\n      また minor version とは無関係に廃止するという事があるのかも分からない。と\n      いう事を考えるとやはりその意味に於いても ble.sh に於いては deprecation\n      level と version は一致させて良いのではないか。という気がしてきた。\n\n  * complete: FIGNORE と -o filenames\n\n    どうやら元の bash では -o filenames が指定された時にのみ FIGNORE が使われる\n    様である。一方で、現在の ble.sh では FIGNORE が設定されている時には強制的に\n    fignore が実行される様になっている気がする。と思ったらこれは shopt -s\n    force_fignore の設定を参照しての事だった。よく分からないのは bash は\n    force_fignore が設定されていても、-o filenames が指定されていなければ\n    FIGNORE が有効にならない様だという事。\n\n    * FIGNORE で全て候補が消えた場合には FIGNORE を無効化して全て採択するべきで\n      は? と思ったが元の bash ではその様な取り扱いはしていない。\n\n    * Note: bash FIGNORE は glob は解釈しない。bash FIGNORE はそれが実際には存\n      在しないファイル名だったとしても、FIGNORE に一致すれば候補削除する。bash\n      FIGNORE は候補が FIGNORE で全滅してもそのまま。bash FIGNORE は単一候補だっ\n      た時にも FIGNORE を適用して候補を消す。\n\n2021-12-14\n\n  * compat: RLogin で ble-detach した後に modifyOtherKeys の状態がおかしい。\n    bash --norc してもおかしい。RLogin である事は検出できている。\n\n  * compat: terminator で status_line で表示が崩れる\n    →これは今確認した所再現しない。terminator ではなく terminology の可能性?\n    或いは古い vte の問題だった可能性もあるかもしれない。\n\n  * compat: mlterm 起動時に表示が乱れる with statusline\n\n    →これは単純に初期の char_width_mode,char_width_version が一致していない事\n    による問題だった。始めから east にしておけば乱れは生じないという事は確かめ\n    た。然し、auto で幅を判定する迄の表示の乱れは一般の問題ではないだろうか。\n\n    乱れを最小限にするには文字幅を大きめに取るという意味で east で始めるという\n    手もあるかもしれないが、実際には west の端末の方が多いという事を考えると別\n    の問題が出てくる可能性がある。また、CPR に応答しない端末の場合ずっと east\n    という事になってしまって問題である。起動して暫くは east にしてそれから west\n    になるという様な感じの物を auto で判定中の幅にするべきだろうか?\n\n  * C-backspace の問題 (端末自動判定?)\n    https://github.com/akinomyoga/ble.sh/issues/94\n    https://github.com/akinomyoga/ble.sh/issues/104\n    https://github.com/msys2/MSYS2-packages/pull/2490\n    https://github.com/microsoft/terminal/issues/755\n\n    以前に色々の端末の動作を調べたと思ったが記録が全く残っていない。辛うじて上\n    記の MSYS2 にどのようなパターンがあったかが記されているが、それぞれどの端末\n    がどう振る舞っていたかの情報はない。改めて調べる。→ wiki にまとめた。\n\n    うーん。^? と ^H が異なる形に bind されているという事は。。。どうしようもな\n    い。既定では両方とも backspace だと思って置くしかない。ユーザーが自分で設定\n    をする時にちゃんと判定するのが良い。\n\n    もしくは端末を自動的に判定して C-h, C-_, etc を C-BS に置き換える設定を行う\n    という事も考えられる。\n\n2021-12-11\n\n  * declare の引数チェックをもっと真面目に実装する。chroma のインターフェイス\n    設計の足がかりにする。\n\n    * wattr=- (未着色) の時にのみ着色しているが、実際には一つでも未着色があった\n     らそれ以降の引数に対して与える影響を考慮に入れなければならない。但し、これ\n     を実行すると毎回ファイル名着色が全て計算されるなどの様な形になりとても遅く\n     なると思われるので、未だ実装しない。\n\n      これは一般の問題なので別項目で議論するべき気がする。mandb_opts 等を用いて\n      指定する可能性。\n\n    * declare: -f, -F が含まれる場合には関数名として任意の名前を含む事ができる。\n      というかオプション名も含む事ができる? (declare -F -f とした時の解釈はどちら\n      になるのだろうか?)\n\n    * 変数代入の形式をしていない引数に関しては中身によってOKかもしれないし駄目\n      かもしれない。\n\n  * refactor: highlight-variable というインターフェイスを作る。\n\n    と、思ったが quote 等も考えるとそういった関数を提供する事に意味があるのか\n    分からなくなってくる。先に quote 除去した時の対応関係について解決する枠組\n    みが必要になるのではないかという気もする。\n\n  * cmdspec: cd 関連の cmdinfo は core-cmdspec ではなくて contrib/cmdspec/* 辺\n    りに移動する?\n\n  * PROMPT_COMMAND / trap DEBUG で問題が起こる? (found by rashad-moves)\n    https://github.com/rashad-moves/HomeConfigurationFiles/commit/efbac4153fd5021f1bc00d42c618fd9d6f4090b9\n\n    2022-03-03 うーん。どうもこの問題は以下で報告されている物と同じの気がする。\n    timer_show が含まれている。\n    https://github.com/akinomyoga/ble.sh/issues/176\n\n    実行時間の表示について Q&A にでも書いておくべきだろうか。\n\n  * complete (source:rhs): 変数名依存の補完に対応しても良いのでは。\n\n  * complete: ARGEX (eval 文脈) の補完\n\n    現在は \"variable:=, command:D, file\" で生成しているが、本来は一番先頭の引数\n    を元にして argument (including progcomp, etc.) を呼び出すべきなのではないか。\n\n  * complete: [[ の中の文法も考慮した補完。これは [[ の中の文法にちゃんと対応し\n    た後で考える事の気がする。\n\n2021-12-06\n\n  * mandb: コマンドの名称を抽出して保持して置けば binary の呼び出し時に使える。\n    dnf や apt 等に問い合わせても良いのかもしれない。或いは、含まれているパッケー\n    ジを見るという手もある。\n\n    然し各コマンドについて man 等を呼び出すのは高価である。\n\n    rpm, dnf でファイルの所属する package と含まれるファイルを抽出するには。\n    https://linux-audit.com/determine-file-and-related-package/\n\n    $ dnf -C repoquery --installed -f /usr/bin/git-lfs --qf '%{summary}'\n\n    等の様にすれば良い。\n\n    * resolved: しかしこれを呼び出すと package 一覧のダウンロード等を実行し始め\n      るので問題がある気がする。或いは、更新を無効化した状態で呼び出す事ができ\n      るだろうか →どうやら dnf -C とオプションを指定する事で cache から情報を\n      取得できる様だ。\n\n    * background で生成するにしても時間がかかるので、複数の bash session で同時\n      に更新が実行されない様に注意が必要である。*.part.$$ に書き込んで、その後\n      でそれを mv するという形にすると良い。更に、他の session が既に生成を試み\n      ている場合には、background 生成を止める事にする。\n\n    うーん。以下の結果を加工すれば一挙に全てのコマンドについて情報を抜き出せるのでは。\n       $ dnf -C repoquery --installed --whatprovides /usr/bin/\\* --nvr\n       $ LANG=C dnf -C provides -q /usr/bin/\\*\n\n    * man -f ...\n\n      というか man -s 1:6:8 -f command... を呼び出せばよいらしい。\n\n      * linux では man -s 1:6:8 -f command 等として結果を得られる。whatis -s\n        1:6:8 command としても同じ出力結果である。というか whatis 自体が man に\n        よって実装されている疑惑 (-s オプションなどがあるので)。\n\n      * cygwin で実行したら駄目だった。whatis sed awk とした時と全く同じ出力結\n        果になったので、whatis を使っているのだろう。\n\n      * solaris では man -f sed は表示されるが、man -f sed awk や man -f sed -f\n        awk 等の様にして複数の結果を取得しようとすると何も表示されなくなる。1行\n        目は空行で、2行目に man ファイルの情報があって、3行目にようやく説明が表\n        示される。\n\n      * minix では man -f sed で whatis を間接的に呼び出そうとしている。そして\n        whatis はデータベースがない等の文句を言って動かない。\n\n      * freebsd でも whatis を呼び出している様だ。警告が出ているが、複数指定し\n        たら複数の説明をちゃんと出力してくれる。, 区切りで一行に複数の名称を出\n        す事もある。例えば man -f awk とすると \"awk, nawk (1) - <説明>\" という\n        具合の行を出力する。\n\n  * complete: 文字列引数の中にファイル名を含めたい事もあるのでは。つまり \"add\n    a.sh\" の様な。特に complete -m '...' の編集で欲しくなる。\n\n  * bash-completion: awk - で long option だけが生成される。調べてみると\n    complete -F _longopt が割り当てられているコマンドについては全てこのパターン\n    の様である。\n\n  * bash-completion: 空文字列に対して最初からオプションも生成して欲しい。\n    そうしないと絞り込みの際に都合が悪い。\n\n    うーん。bash-completion や他の補完の事を考えると一文字目に - が入力された時\n    点で候補を再生成するべきの気がする。或いは - から始まる候補も追加する? 追加\n    する場合には以前にあった物と重複する候補を削除しなければならない事に注意する。\n\n  * syntax: for $(echo hello) に対しては着色しない。もしくはエラーとする。\n\n    これは heredoc 単語と同様の問題である。因みに heredoc の単語に $() を含めた\n    場合には、終端位置判定が正しくできなくなっている。普通に入力すると終端位置\n    を逃す。終端を書いてから heredoc の中身を編集すると位置を正しく特定できる。\n\n2021-11-23\n\n  * kitty shell-integration (requested by kovidgoyal)\n    https://github.com/akinomyoga/ble.sh/issues/110#issuecomment-976182311\n    https://github.com/kovidgoyal/kitty/issues/3948\n\n    | [Check default shell-integration]\n    |\n    | * ok: 前のコマンドの内容を less で見る: C-S-g\n    |\n    |   vim-airline を表示している時に問題が生じる。中途半端に切れたりする。\n    |\n    | * ok: プロンプト移動(scrollback): C-S-{z,x}\n    |\n    | * マウスによるプロンプト内の移動:\n    |\n    |   遅い、vi_nmap の中にいると変な事になる。うーん。これはまた後で確認する。\n    |\n    | * xterm-title で現在ディレクトリを表示する。\n    |\n    |   これは別に何か新しい機能という訳でもないだろう。敢えて ble.sh で対応する\n    |   とするのであれば、bleopt prompt_xterm_title を用いるぐらいの事である。\n    |\n    | * これも特に変な事はない。但し、ble.sh 側でユーザーが何か設定している場合に\n    |   は、kitty integration の設定は off にすれば良い。\n    |\n    | * ok: winch glitch の解決。これは綺麗に動いている。\n    |\n    | * Sophisticated completion for the kitty command in the shell. これは\n    |   core-complete の領分であるが何か特別な事が起こるとも思われない。\n    |\n    | 結局 vim-airline を実行した事による問題点は C-S-g で閲覧する内容の切り取り\n    | 以外では特に問題になっていない様に見える。以下の三点を報告する。\n    |\n    | x subshell の中でちゃんと動作していない。従って tmux の内部でも動作しない。\n    |\n    | x 複数行コマンド編集時に vi_nmap で位置がずれる。他の keymap では問題は生じ\n    |   ない。\n    |\n    | x vim-airline を使っていると時々コマンド内容が切れる\n\n    最初の項目については意図的なのだという返信が来た。だとしても tmux で空にな\n    るというのは変である。後で patch を作っても良い。問題にしているのは\n    invasive という事だったので SHLVL, SUBSHELL, $- 辺りを参照して本当に kitty\n    の中にいる時にだけ有効にするというのが良いのかもしれない。(と思ったが、元々\n    の kitty.bash でも kitty かどうかをチェックしているのではないか?)\n\n    2つ目の項目に関しては仕方のない制限だという事。up/down を有効化する\n    sequence について提案した所、patch が送られてきたら見るとの事。これは忙しい\n    ので今は未だ。\n\n    3つ目は調査中。\n\n2021-11-21\n\n  * complete: インラインでヘルプ・次に期待する引数の種類を表示するという話\n    https://www.reddit.com/r/bash/comments/qrm3s2/hints_for_argument_types_in_bash/\n    https://github.com/fish-shell/fish-shell/issues/2201\n\n  * やはりメモリを使うという事は明記するべきである。\n\n    bash-3.2 16MB 19MB\n    bash-4.3 26MB 31MB\n    bash-5.1 33MB 40MB\n\n2021-11-05\n\n  * vim の :term 内部で実行すると振る舞いが変だ\n\n    * 先ず最初のロード時に行が一行ずれる。それ以降は発生しない。modifyOtherKeys\n      もしくは文字幅判定の為に出力している何かが問題を起こしているのかもしれな\n      い。\n\n      →どうもこのずれは status_line に関係している様だ。\n\n    * うーん vim :term の中だと NUL (C-@, C-SP) を入力することができない。C-wは\n      vim の側での操作に使われている様だ。これらは ble.sh の外側でも同様である\n      事から、ble.sh の問題ではない。寧ろ vim term の仕様と見るべきである。\n\n  * bash-5.2 で builtin bind -Xs を観察するとところどころ \\000 が余分に挿入され\n    ている。これは何か。bash-5.1 では問題はない。\n\n2021-10-26\n\n  * winch: Window サイズを変化した時に menu の座標計算がずれる\n    (menu_style=dense)そもそも resize した時点で menu の再配置を実行しなければ\n    ならない筈である。\n\n    或いはサイズが変わった時には menu-complete はキャンセルするべきなのではない\n    か? 特に大量の WINCH を送ってくる端末があって、大量のメニュー項目の後ろの方\n    のページを表示しているとすると、ほぼフリーズした様な形になってしまう。\n\n    或いは次に TAB を押して他の項目を移動しようとした時点で改めて配置計算を実行\n    する? 例えば、WINCH を受け取った時点では info を単に非表示にしておいて、次\n    にメニューに対して表示の変更等を行う必要が生じた時に改めて計算を実行する。\n\n    2022-03-04 そもそも ble/edit/info 自体が WINCH の時に再計算するべきなのでは\n    ないか。特に高さだけでなく幅についても考えて再計算しないと内容が乱れてしま\n    う。\n\n  * スタートしてから数秒間は user input detection for C-m を off にした方が良い\n    のでは。スタートした直後にペーストを実行する事があるとは思われない…。\n\n    と思ったが bash を含む大量のテキストを入力した場合にどうなるのかというのは\n    疑問である。とは言いつつも、その場合には親シェルの側でちゃんと paste\n    detection ができているべきではないかという気がする。\n\n2021-10-04\n\n  * fzf を直接読み込んだ時に動かない問題について\n    https://github.com/akinomyoga/ble.sh/issues/126\n\n    ble-update を実行すると動く様になるが最初から source ble.sh すると動かない。\n    ble-import contrib/fzf-key-bindings をすると動く様になる。\n\n    というか改めて説明を読むが一体どういう操作をしようとして問題が生じているの\n    か謎である。C-r, C-s をしようとした時に問題が生じているという事だろうか。現\n    在の実装では補完については contrib/fzf を自動でロードする様にしている。\n    widget に関しては contrib/fzf-key-bindings 経由で呼び出さなければ駄目である。\n\n    うーん。自動的に検出して補正する様にしようと考えたがそんなに単純ではない様\n    に見える。\n\n    a 例えば bind する瞬間に fzf 関連であるかどうかを調べて fzf 関連であると分\n      かった時点で fzf-key-bindings を呼び出すという方法。\n\n      x ユーザーが実行したい binding が fzf-key-bindings と同じかどうか分からな\n        い。ユーザーが自分で調整して binding のキーを変更しているかもしれない。\n        この場合には勝手に fzf-key-bindings を読んでしまうとユーザーの予期しな\n        い binding が定義される事になり問題である。\n\n        一方で、諸々の関数は fzf/shell/key-bindings.bash に定義されているのだか\n        ら、そこに含まれている関数を使おうとしている時点で其処にある binding が\n        そのまま使われていると仮定して良いのではないか。もし、ユーザーが\n        fzf/shell/key-bindings.bash を自分でコピー・編集して使っているのだとし\n        たら、やはり contrib/fzf-key-bindings.bash についても同様に自分の設定に\n        合わせて編集するべきなのではないか。\n\n      o bind で -x に fzf 関連を指定した場合に関数の中身を差し替える等の事をし\n        ようとしても、例えば inputrc キャッシュで初期化を誘導する等の事までは\n        キャッシュできない気がする。\n\n        →これに関しては fzf-key-bindings では関数の中身を差し替えるのではなく\n        て、別名の関数を定義してそれに差し替える様にして、更にその別名の関数に\n        ついての autoload を def.sh 辺りに記述する事にすれば良い。\n\n        x この方法だと __fzf_cd__ や __fzf_history__ をユーザーが直接自分で\n        bind した時に対策できない。\n\n    b 或いは、bind -x を実行する時にコマンド名が __fzf_history__ または\n      fzf-file-widget だった場合にこれらの関数を上書きするという手法。\n\n      x この方法だと __fzf_cd__ の検出ができない。__fzf_cd__ は、\n        fzf/shell/key-bindings.bash だとマクロ経由で呼び出される様になっている。\n        つまり bind -x ではないという事。かと言って accept-line に作用して、コ\n        マンド実行前にコマンド内容を調べて関数を上書きするというのも非現実的な\n        気がする。\n\n      うーん。やっぱり現状の様に設定するべきなのではないだろうか。\n\n2021-09-28\n\n  * fast-syntax-highlighting\n\n    https://www.reddit.com/r/zsh/comments/oyege0/is_completionaware_syntax_highlighting_possible/\n    https://github.com/zdharma/fast-syntax-highlighting/tree/master/%E2%86%92chroma\n    https://github.com/Valodim/zsh-capture-completion\n\n    どうやら programmable highlighting に相当する機能は\n    fast-syntax-highlighting で既に実装されていて \"chroma\" と呼ばれているらしい。\n    然し実のところそれ程沢山の実装がある訳でもない。\n\n    他に zsh-capture-completion というモジュールに含まれる関数で capture.zsh\n    'command' を実行すると 'command[TAB]' とした時の補完結果を取得できるらしい。\n    これは ble.sh の上で作成する事も可能である。補完機能のテストで使うのに便利\n    な気がする。\n\n    bash-completion のテストをコピーできたら良い気がする…。でも全て python で\n    定義されているというのは難点である。うーん。結局、その場で補完を実行する機\n    能を実装したとしても使う機会がないからテストされずに残って意味のない機能に\n    なりそうな気がする。\n\n  * https://www.reddit.com/r/commandline/comments/pv1fm8/what_are_the_main_advantages_of_the_various_shells/\n\n    fish の便利な機能について紹介している。\n\n    * M-{right,left} でディレクトリ移動。これについては異なる keybinding で提供しても良い気がする。\n\n      iswitchb の如く C-x C-b 等で探索するのもありではないか?\n      その際には menu の機能を有効活用できる気がする。\n\n    * fish の Abbreviations の振る舞いが気になる。\n      zsh の zsh-abbr も気になる。\n\n    然し、実際に ble.sh をロードさせてテストするというのは有効の気がする。\n\n  * menu: C-x C-d で今迄に訪れたディレクトリの一覧。\n\n    iswitchb と同様に絞り込みをしたいが入力した文字列は何処に表示するのが良いのか。\n    panel に表示するのが良いだろうか。或いは、そもそも表示しなくても良いのかもしれない。\n    何れにせよ太字で表示されるのであるから。\n\n    太字ではなくてより強調した形にしても良いのかもしれない。これは face 経由で\n    設定できる様にするのが良い様な気がする。現在は太字固定になっているが。\n\n  * menu: C-x C-j で job 制御用の TUI メニューを表示しても良いのかもしれないとも思う。\n\n2021-09-26\n\n  * bash-5.2: array が sparse でない ./configure option が追加された。\n\n    もしかすると sparse arrays に declare -gA を指定する必要があるかもしれない。\n    sparse かつ ordered な配列については簡単な workaround は存在しない。唯、そ\n    の様な配列を実際に使っているかは分からない。なければ気にしなくて良い。\n\n2021-09-22\n\n  * edit: 複数行モードの時は prior/next でページ移動?\n\n  * plug: git clone 用の判定:\n\n    これは\n\n    $ grep -q '^github\\.com' ~/.ssh/known_hosts\n    $ grep -qEi '[[:space:]]*HostName[[:space:]]+([^[:space:]]+[[:space:]]+)*github\\.com' ~/.ssh/config\n\n  * 実は local rex=... [[ a =~ $rex ]] は関数に纏めたら良いのでは。\n\n    速度的にはどうだろうと思って比較してみると4倍位遅くなる。もしくは 0.014ms\n    だけ遅くなる。70回の評価で1ms, 1400回の評価で20ms, 7000回の評価で100msの差\n    が出る。\n\n    $ ble-measure \"local rex=':point=([^:]*):'; [[ alpha:beta:point=end:b = \\$rex ]]\"\n         3.618 usec/eval\n    $ function ble/regex#match { [[ $1 =~ $2 ]]; }\n    $ ble-measure \"ble/regex#match alpha:beta:point=end:b ':point=([^:]*):'\"\n        17.402 usec/eval\n\n    うーん。一般的には気にする速度低下ではないが、構文解析などの中心部では控え\n    た方が良いかもしれないというぐらいである。通常の場所ではどんどん使って問題\n    ないのではないか。\n\n    →検索してみたが実は意外とそんなに沢山あるという訳でもない様だ。少しずつ置\n    き換えていけば数日で終わるぐらいの箇所しか無い。概算で140箇所程度である。然\n    し、そもそも其処までして置き換える必要があるのかという疑問もある。現状で動\n    いているのであればそれで良いのではないか。一応他のシェルに移植する時に一括\n    で動作を変更するのが楽という可能性はなくはない。\n\n    2021-12-11 ble/string#match という関数名で追加した。\n\n2021-09-15\n\n  * haiku: ble/builtin/bind/.reconstruct-user-settings の gawk が無限ループになっ\n    ている? 或いは滅茶苦茶遅くなっている。gawk 4.2 である。bash-4.4.23 から呼び\n    出している。変な事が起こる様な余地はない様な気がするが…或いは正規表現エン\n    ジンなどが壊れているという事なのかもしれない。\n\n  * solaris: ble-bind を bashrc 内部で呼び出した時点で未だ attach していないの\n    に色々と info を表示してしまっている。\n    $_ble_base_cache/decode.cmap.gdict.*.dump を削除した時に再現する。\n\n  * grapheme: SpacingMark, Prepend の幅は一体どうなっているのだろうか [#T0008]\n\n    現在の実装では幅を全く考慮に入れていないが、入れるべきの気がする。c2w で\n    combining に対して 0 を返す様にしたら Extend や Prepend に対しても c2w で値\n    を計算して加算する様にすれば良いだろうか。然し、絵文字の Emoji_Modifier な\n    ど組み合わせた時と単体の時で幅の異なる物も存在する。\n\n2021-09-06\n\n  * menu: メニューの詳細表示を toggle できる様にするべきではないか。\n\n    表示するか表示しないか完全に固定するのは微妙な気がする。\n\n    後、desc-raw しか実際には使わない様な気がする。二種類の表示方法を用意したと\n    しても、そもそも説明を生成する側で二種類を分けて生成する訳にも行かないので、\n    どちらかに統一するべきではないか。速度が気になるというのはあるが、もしテキ\n    ストだと解釈するとしても、全角文字などが含まれる場合には結局位置計算は省略\n    できない。逆に ascii 文字だけで構成されているのであれば esc を解釈するとし\n    てもそんなに速度低下なく処理する事ができる。\n\n    表示の toggle は各メニューが表示される度に行うか或いは一回変更したら暫くそ\n    の設定を保持するか。ユーザーの指定した設定を既定値として各 menu が表示され\n    る度に toggle を行うという事を考えたがそれは如何にも面倒である。それよりは\n    toggle は永続的な変更を引き起こすとした方が分かりやすい様な気がする。その場\n    合には、bleopt の設定を永続的に設定してしまっても良いのではないか。\n\n    然し、それだと desc モードになっている時に align 等を設定した時にどの様に振\n    る舞えば良いのか分からない。一つの手は一旦完全に toggle 状態を clear して、\n    改めて既定の style として align を設定するというのが自然な気がする。\n\n    * toggle するとしたらその表示切り替えのキーボード操作はどうするのか。C-m と\n      思ったがそれだと確定と同じ。C-d だと削除みたいな感じがする。insert は確か\n      に toggle だがやはり直感的ではない気がする。 ScrLk や CapsLock NumLock 等\n      も同様である (というか OS 側のキーボードの状態が変わってしまったりして大\n      変である)。\n\n      後、実際に menu-complete に入らなくても切り替えられた方が良い様な気がする。\n      その場合には他と被らない様な操作にする必要がある。他で使われていない\n      single-key の操作はそうそう残っていない気がするし、残っているとしてもそれ\n      をたかが menu toggle に割り当てるべきなのかという問題もある。或いは、2\n      keys による操作としても良い様な気はしている。\n\n      例えば C-x | 等。特に C-x は menu-complete やその他の complete に色々割り\n      当てているから丁度良い気がする。\n\n      - \"C-x d\" は emacs では dired,\n      - \"C-x ?\" は emacs では keybinding 一覧,\n      - \"C-x h\" は emacs では全選択に割り当てられている。\n      - \"C-x |\" は emacs では割り当てがない。\n      - \"C-x C-h\" は前の文を削除する。\n      - \"C-x C-t\" は行の入れ替え。\n\n      若干操作しにくい気がするが、うーん。一旦 menu-complete に入ってしまえば\n      \"|\" で入力できるようにすれば良いと思ったが…普通に \"|\" を入力したいという\n      時があるのでそれは駄目だ。やはり C-? の形の方が良い。\n\n  * menu: preview 機能をつけても良い。preview に表示する中身は候補の種類に応じて色々。\n\n    そもそも desc の内容自体その場に表示するのではなくて preview 的な小さな窓の中に\n    選択した時にだけ表示するという形式でも良いのではないかという気がする。\n\n2021-09-02\n\n  * 改めて確認した所また Windows Terminal で動かなくなっている\n\n    調べると Cygwin 経由で接続した時だけの問題の様である。\n    これは Cygwin の側の conpty の副作用という可能性もある。\n    というか最新版の Cygwin で直っている可能性もある。\n\n    ? wt を path に加えて実行もできるのにも関わらず構文着色で赤になっている。不思議だ。\n      type wt とするとちゃんと成功する。\n\n    ? Cygwin から起動した時とスタートメニューから起動した時で、Windows\n      Terminal の中で Cygwin タブを開いた時のプロンプトに含まれるシー\n      ケンスが異なっている気がする。と思ったが、これは Cygwin の\n      screen の中から起動すると、Windows Terminal の中の Cygwin も\n      screen の中にいると勘違いするからであろう。気にしなくて良い。\n\n      取り敢えず環境変数が継承される事は確認したし、\n      CYGWIN=disable_pcon を指定していても指定していなくても Windows\n      Termianl - Cygwin では座標計算がずれるという事が確認できた。やは\n      り pcon は関係ないのかもしれない。\n\n  * 起動時間を計測しているようだ\n\n    ble.sh でかなり時間がかかっている様だという事。\n\n    * ble.sh は background 処理を行う。特に ble-attach の末尾で行っている気がす\n      る。なので、ユーザーが何も入力しない限り background 処理を完全に終えるま\n      で ble-attach から抜けないのではないか。逆に、ユーザーが何か入力している\n      時にはより早く初期化できるのではないか。と思って試してみたがそうでもない。\n      というか殆ど変化がない。どういう事だろうか。\n\n      ユーザー入力の検出ができていない? 或いはそもそも background 処理は最初は\n      行っていない? 後者の様な気もするが後で確認する必要がある。\n\n      letsnote でも試してみたがやはりユーザー入力があっても殆ど変化はない。\n      GNU/LInux でも Cygwin でも同様にユーザー入力があっても変化はない様だ。\n\n      実装を確認してみると確かに ble-attach の末尾で .tail を呼び出してい\n      て、.tail は idle.do を呼び出している。うーん。不思議だ。或いは .tail の\n      前後だけに注目すればより短くなっているかもしれない。\n\n    * MSYS2 環境では ble.sh のロード及び attach にはかなり時間がかかる様だ。と\n      いうかこれは fork の回数に直結しているという気もする。MSYS2 で調べると\n      spawn が 10/s だった。\n\n      一方で Cygwin だと 23/s 程度である。実は Cygwin の方が軽量である。或いは\n      最適化が施されていると見るべきか。或いは whitelite に入れていただろうか。\n\n2021-08-31\n\n  * msys2 での ble-update で変な動きをした。。\n\n2021-08-30\n\n  * complete: overridden builtin 及び他の framework\n\n    | * https://github.com/csdvrx/bash-timestamping-sqlite\n    |\n    |   この実装では history コマンドを上書きしている様な気がする。然し同時に\n    |   ble.sh との併用を推奨している。うーん。この時 ble.sh が history を上書きす\n    |   る、もしくはble.sh の history がこの枠組に上書きされるという事があったら何\n    |   が起こるのだろうか。何か悪い事が起きる気がする。\n    |   ble/function#push とかを使って何とかすれば良いのだろうか。\n    |   その場合にはこの interface を固定する必要がある。\n    |\n    |   と思って実際にコードを確認したが history を上書きしている訳でもない様だ。\n\n    何れにしてもこれは注意点として README に記述しておくべきなのではないか。\n\n  * complete: そもそも遡って書き換える補完候補と純粋な意味での補完候補は区別す\n    るべきなのかもしれない。TAB 補完では後者に基づいて補完を実行するが、メニュー\n    の表示には両方を表示するという手がある。その場合にはメニューの内部で\n    section を分けると良いだろうか。ページング等をちゃんと考慮に入れる必要があ\n    る。\n\n2021-08-29\n\n  * bashrc に直接設定を書く方法についても説明する。\n\n    但しこの場合には ble-reload をした時に設定が消えるという事に注意する。→うー\n    ん。この様な面倒な事が起こるのであればやはり記述しないほうが良いのではない\n    か。\n\n    よく考えてみたら source ble.sh と ble-attach の間に書いた bind にも同様の問\n    題があるのではないか? と思ったが、ble-attach よりも前に書いているのであれば\n    ちゃんと readline の側にも反映されている筈で問題はない筈。\n\n    ユーザーがコマンドラインから設定した設定は消えてなくなってしまうという事に\n    注意する。これらを記録して後で拾える様にするという手もあるかもしれないとは\n    思う。\n\n2021-08-26\n\n  * CPU 100% in macOS (reported by killermoehre)\n    https://github.com/akinomyoga/ble.sh/issues/131\n\n    CPU 100% になっている時に同時に gawk が待機している様である。\n    100% になっている時の gawk の引数について尋ねたら返答が来た。\n\n    二つの bash について異なる gawk が呼び出されている。前者は\n    ble/history:bash/resolve-multiline/.awk で、後者は\n    ble/history:bash/load/.background-initialize である。両方とも\n    history に関係している。\n\n    Q というかどちらの bash が CPU 100% になっているのだろうか。或いは両方?\n\n    Q bash が起動した時に暫く 100% になるのか起動した後もずっと 100% のままなの\n      か。もし暫くしたら収まるのだとしたらどれぐらいの間 100% でいるのだろうか。\n      これがそんなに長くなければ少なくとも見た目の動作に影響がない限りはそのま\n      まにしておいても良い様な気がする。\n\n    Q CPU 100% になっている間 bash は応答するだろうか。応答するとしたら\n\n    Q いつでも現象は再現するだろうか。或いは確率的に発生するだろうか。\n\n    ----\n\n    取り敢えずやはり巨大な history が問題であるという事までは分かった。\n    自分の手許の linux では同じぐらいの巨大な history を用意したとしても\n    そんなに遅くはない。\n\n    ? 一方で向こうの報告によると builtin history を実行しているプロセスが重いと\n      いうことの様である。自分の手許で確認しようとしているがすぐに処理が終わっ\n      てしまうので確認できない。\n\n    * 終了時にもかなり待たされる。\n\n      終了時の nawk が滅茶苦茶遅くなる。gawk だと遅くないとかあるのだろうか。と\n      思って改めて観察してみると最初に bash が 100% になって、その次に nawk が\n      100% になるという具合に処理が進行している。\n\n      ble/builtin/history/.write で時間を消費している。\n\n      A:1630043056.816931\n      B:1630043056.936962 0.12s ... history/.get-min\n      C:1630043056.942516 0.06s ... history/.get-max\n      D:1630043079.487224 13s ... builtin history >> file\n      E:1630043092.465937 13s ... nawk の処理\n\n    Q hang と slow は区別しているのだろうか。自分的には hang というのは待っても\n      絶対に終わらないという意味である。然し、向こうは有限時間で終わるという事\n      を確認しているのにも関わらず hang と言っている可能性がある。よく分からな\n      い。\n\n2021-08-23\n\n  * bash-4.2 では [[ ${arr[*]} == *\" 2 \"* ]] (where arr=(1 2 '')) が駄目\n\n    一応該当しそうな物を検索すると以下の様な物がある。\n    何れも空白には関係なさそうなので問題は起こらなそうな気がする。\n\n    $ grc '\\[\\[ \\$\\{.*\\[[*@]\\].*\\} [!=]= .* \\]\\]'\n    ./ble.pp:145:    { ((${#BASH_SOURCE[@]})) && [[ ${BASH_SOURCE[${#BASH_SOURCE[@]}-1]} == *bashrc ]]; } ||\n    ./src/decode.sh:3632:    [[ ${keys[*]} != \"$bind_keys\" ]] &&\n\n2021-07-14\n\n  * bash-it によるプロンプト設定が prompt attach で反映されない。\n\n    PROMPT_COMMAND 経由で PS1 を設定していると反映されないのだろうかと思ったが\n    そういう訳でもない様だ。\n\n    powerline-multiline で発生するとの事だが再現しない。\n    というか powerline-multiline で発生する固有の問題なのか、\n    それとも他の theme でも動作するのかの情報についても書いていない。\n\n2021-07-13\n\n  * auto-menu: 一旦 (no items) が表示されるとそれ以降 auto-menu が動作しない\n\n    auto-menu が有効になっている時に一旦 (no items) が表示されるとそれがそのま\n    まになって二度と auto-menu が起動しなくなる。\n\n    またこの時に C-l で再描画すると info に何も表示されなくなる。実はこれは\n    menu が表示されている時には常に再現する問題である。\n\n2021-06-21\n\n  * auto-menu が有効になっている時に複数行編集で座標が変になる\n\n    2021-07-13 今試しても問題は再現しない。\n\n    2021-07-18 再現した。履歴に複数行の項目が含まれている時に、その履歴が呼び出\n    されると問題が発生する。ble-bind ... と入力した時に発生した。というかこれは\n    本当に auto-menu の問題なのかどうか分からない。取り敢えず、textmap を再確認\n    する必要がある気がする。ずれの量的にも前回の textmap の時と似たような振る舞\n    いの様に見える。\n\n    2021-07-19 chatoyancy の上では再現しない? vaiio2016 の上でも再現しない。\n\n2021-06-18\n\n  * grapheme: ble/canvas/trace の lc lg の grapheme cluster 対応について\n    Ref #D1619\n\n    基底文字だけを指定しても、最後の Extend を指定しても端末によって左の書記素\n    クラスターが破壊される可能性がある。書記素クラスター全体で出力する必要があ\n    る。lc lg の組ではなくて lcs lw lg の組で結果を返さなければならない。lc lg\n    はデバグ用なので其処まで配慮する意義は薄い。\n\n    そもそも lc lg の枠組みはそろそろ削除しても良いのではないかという気すらする。\n\n  * grapheme: 私用文字で置き換える事により書記素クラスター単位での編集を可能にする可能性\n    Ref #D1619\n\n    現在の所その必要性は限りなく低いと考えられる。\n\n  * grapheme: Unicode version 毎の振る舞いの違い?\n    Ref #D1619\n\n    emoji_version と同様に grapheme_cluster についても version 毎の違いを考えて\n    も良いのかもしれない。\n\n  * emoji: Emoji 対応状況自動判定\n    Ref #D1619\n\n    | これも自動検出の対象にしても良いのでは。という気がする。というかそうする\n    | べきである。所で Zle は実は内部的にそういう事をしている可能性がある。\n    |\n    | と思ったが端末によって unqualified の取り扱いもばらばらだろうし ZWJ に対\n    | 応しているのかどうかも不明だし、という事を考えていくと単に\n    | legacy/extended を区別すれば良いという訳ではない。場合によっては ZWJ シー\n    | ケンスに対応しているかどうかと言ったフラグまで管理しなければならないかも\n    | しれない。とは言いつつ実際にそのように振る舞う端末が存在するのかどうかも\n    | 不明である。なので、これは実際の端末の振る舞いを整理しながら考える必要が\n    | ある。\n    |\n    | 端末ごとの絵文字の振る舞いについて調べる必要がある気がする。kitty/vte は\n    | unqualified はテキスト表示で EPVS によって絵文字になる。RLogin は\n    | unqualified は半角で表示される? 幅は VS で変化しないように見える。mintty\n    | は試した限りでは Emoji に対応していない。既定で off になっているという事\n    | だろうか。\n    |\n    | 以下の振る舞いも端末の対応状況に応じて実装する。\n    |\n    | * EPVS の時には emoji_width または 2 になる様にしている。然し、絵文字の表示\n    |   ができない端末では 2 にせずに普通の文字として求めた方が良い可能性もある。\n\n    * legacy vs extended\n    * unqualified をどう取り扱うか。EPVS 及び TPVS がどう作用するか\n    * ZWJ sequence に対応しているかどうか\n\n    現実の端末に於いてそれぞれどう対応されているか、そして三つの対応状況の組み\n    合わせはどうなっているかについても調べる必要がある。\n\n  * test: ログを何処かに保存する機能? その場合には着色等は除外する\n\n  * syntax_debug の時にコマンド実行すると実行位置が変だ\n\n    うーん。info　を削除する時のシーケンスが間違っている? menu の表示時には何も\n    問題がない。menu に関しては消去してから実行するからだろうか。或いは、変なタ\n    イミングで info が更新されて info が表示されてはいけないタイミングで表示さ\n    れているという事だろうか。\n\n  * progcomp の出力に関する議論 (reported by oc1024)\n    https://github.com/akinomyoga/ble.sh/issues/121\n\n    うーん。どうするのが良いのか微妙。Bash と同じ様に動作するべきなのか、或いは\n    出力を抑制するべきなのか。関連する議論が幾つかあった様な気がする。というか\n    最近抑制する様に変更した様な気がするが何故再発しているのだろう。実際に確認\n    してみた所、歴史的には常に出力を許している様にも見える。不思議だ。\n\n    うーん。実は progcomp-helper-func ではなくて、compgen の時点で出力を抑制し\n    ていたのだったろうか。\n\n    * 98835b5 2021-05-17 これは _ble_util_fd_stderr 等に保存した fd を使う様に\n      する変更。本質的には tty を使う様になっている。元から helper-func で tty\n      にリダイレクトしていた。\n\n    * 9d4ad56 2021-05-06 うーん。以前の報告が見つかった。よく見たらこれも\n      oc1024 による報告である。この commit では stderr に関連する変更はない。\n\n      https://github.com/akinomyoga/ble.sh/issues/97\n\n      どうもこの時は個別にバグのある関数を置き換えたのだった。修正は 9d4ad56 で\n      ある。stderr/stdout に対しては全く変更していないし細かい議論もしていない。\n\n    * 4fc51ae 2021-03-10 fzf に対する対策。これについては明示的に tty にリダイ\n      レクトしている。これより前は compgen 呼び出しの stderr への redirect の為\n      に stderr は抑制されていた。\n\n    * 68f8077a 2020-04-06 これは compgen 呼び出しに builtin を付加しただけ。\n\n    * 1ca53868 2019-01-01 これは complete -p の解析に機能を追加した物。この時点\n      で compgen の stderr は抑制している。\n\n2021-06-13\n\n  * menu-complete: 末尾一致 (skip-completed-text) が考慮に入っていない\n\n    これは最終的な挿入時に処理するべきか、或いはメニュー項目を一時挿入している\n    時から処理するべきか。メニュー項目を一時挿入している時から処理しないと振る\n    舞いとして不自然になる気がする。\n\n  * 終了ステータスが 2 の時に前回のコマンドを再ロードするというのは面白い試みかもしれない\n\n    最近人気らしい thefuck により修正後のコマンドが取得できればなお良い。\n\n2021-05-29\n\n  * syntax: 単語が sabbrev に一致する場合には着色するのが親切だ\n\n    これは sabbrev に対する仕様拡張を行ってからでも遅くないのではないか。\n    ble/syntax/progcolor/word:default 辺りに修正を加えれば良い。\n    本来は progcolor よりも上の枠組みで着色したい気もするが\n    それだと layer を増やす必要がある。処理が重くなりそうである。\n\n    check-sabbrev 的な感じで付加的な処理として実装できれば良い。\n    そうすれば custom な着色関数からでも呼び出せる。\n    と思ったがちゃんと忘れずに呼び出すのも面倒である。\n    やはりもっと下の枠組みで提供するべきだろうか。\n    例えば、最終的に着色を格納する部分に介入してしまうという手もある。\n\n2021-05-27\n\n  * wiki の更新\n    * done: \\g{...} について記述する (2021-06-13)\n    * wiki: ble-import の -f オプション\n    * wiki: bleopt の wildcard, -r, -u\n    * wiki: blehook の -a\n    * 2021-06-12 wiki: bleopt -I\n    * 2021-05-24 airline: 使い方を説明に書く\n\n  * やはり source_if() { source \"$@\"; } 等とすると引数が一つしかない場合に、自\n    分自身が引数であると誤認してロードがキャンセルされる。\n\n    % これは実は簡単に判定できるのではないだろうか。つまり引数が唯一つでしかも\n    % 自分自身を指している場合には関数内で無引数でsource されたのであると判定で\n    % きる。と思ったが違う。これで見えているのは外側の関数の引数なのだから、必\n    % ずしもそういう形になっている訳ではない。\n\n2021-05-23\n\n  * menu-complete: SIGWINCH による info#panel::invalidate の際にメニュー項目の\n    再配置を実行するべきである。\n\n    * info 拡張: というか info の表示を担っている class を動的に変更するべきな\n      のではないか。現在の実装だと内容を変更する時には必ず info の関数を即時で\n      呼び出さなければならない仕組みになっている。然し、そうではなくて機に応じ\n      て丸ごと制御を移すなどの事をした方が良いのではないか。然し、一方でどの内\n      容が一番上に来るべきかなどの制御も必要になる。現在は default/non-default\n      の二層構造になっているがそれをもっと動的に変化できる様に改良するという手\n      も考えられる。\n\n2021-05-21\n\n  * progcolor: 取り敢えず builtin から始めるのが良いのではないかという気がする。\n\n    ble.sh の関数についても着色及び補完関数を定義して行きたい。\n\n2021-05-19\n\n  * complete: [TAB] 補完の場合には、ユーザー入力があった時に即座にキャンセルす\n    るのではなくて timeout があっても良いのかもしれない。\n\n2021-05-17\n\n  * 此処で思ったのだが nawk は Unicode の対象を取り扱えるのだろうか。。。UTF-8\n    ならば通常の制御文字はそのままなので問題は生じないのではないかという気もす\n    るが。文字数を数えて何かする様な処理では何か変な事が起こるかもしれないが、\n    そうでなければ大丈夫の気がする。\n\n    問題が起こるかもしれないのは brace expansion の形式でファイル名一覧を挿入す\n    る処理。これに関しては UTF-8 だと例えば平仮名の途中で分断されたりして変な事\n    が起こる可能性がある。\n\n  * global: /dev/null を $_ble_util_fd_null に置き換える?\n\n    #D1552 で議論した。毎回 open するよりも dup した方が高速である。一方で\n    _ble_util_fd_null が上書きされたりした時は /dev/null の方が頑健である。\n\n  * syntax: redirection が正しく解析できていない気がする\n    以下の手順で編集した時に着色が間違っている。\n\n    $ exec {fd}>/dev/null\n    $ exec {}>/dev/null\n    $ exec {_ble_base_fd_null}>/dev/null\n\n  * 色見本について探した\n\n    多くのサイトは微妙である。そもそも sRGB とかの概念があるのかないのか不明で\n    ある。単純に RGB #XXXXXX の値を線形で CMYK に変換していたりしてかなり怪しい。\n    色用語の場所にも sRGB やガンマ補正などの単語は見られない。\n\n    https://www.color-sample.com/popular/jiscolor/ja/\n\n    このサイトはちゃんと sRGB/Adobe RGB 等について載っているので少なくともちゃ\n    んとその辺りの事を認識した上で作られたサイトであろうと思われる。然し権利関\n    係の記述もないし、連絡先もない。メールボタンがあると思って押したら単に \"友\n    達にこのサイトを紹介する\" メールを送る為のボタンだった。© 2021\n    Color-Sample.com. All Rights Reserved. という表記の右にあるアイコンがリン\n    クになっていたので押して見たが、単純にトップに跳ぶだけだった。Twitter アカ\n    ウントは https://twitter.com/color_sample で見に行ったら 2014 で更新が止まっ\n    ている。著作権が 2021 になっているのは機械的に置き換えているだけという事だ\n    ろうか。何だかよく分からない。というかよく見たらブラウザサポートというアイ\n    コンも古いブラウザが並んでいたりして更新が止まっている事を示唆している。\n\n    https://triple-underscore.github.io/css-color-ja.html#rgb-to-lab\n\n    w3 の CSS の仕様の翻訳。ここにちゃんと色々の知識が書かれている。この文書は\n    最初から最後まで読むべき。\n\n    http://mezala.la.coocan.jp/pc/jiscolor/jiscolor.html\n\n    このページは複数の情報源からの差異について見せているがそもそも CMYK, RGB の\n    変換式として異なるサイトから二種類持ってきていて (どちらかが間違っているの\n    に違いない) 更に、Wikipedia からの数値も比較していて、どれだけ見た目が変わっ\n    てくるかを見せているが。色には絶対的な基準はないのだとか色々言って納得して\n    いるが、これらは単に sRGB と RGB の解釈を間違えて変換しているから起こってい\n    る間違いのような気がする。(とはいいつつ画面の輝度やその他の要因もあるだろう\n    から一概には言えないのかもしれないが、少なくともどういう条件の元での変換を\n    行っているのか明示した上で、その差異について議論していなければ情報としては\n    使い物にならない)\n\n    https://www.colordic.org/w\n\n    このサイトは和色大辞典と言って 460 色掲載しているそうで一番大きい気がする。\n    然し、その RGB 値が sRGB なのかどうかとかも分からない。Q&A には再利用・再頒\n    布可能性などについては述べられていないし、各色の出典についても書かれていな\n    い。このサイトの RGB 値が実際に sRGB なのか何なのか確認して、その上で他の色\n    についても変換を確認するのが良い気がする。\n\n2021-05-15\n\n  * AUR blesh-git のカスタム update について\n    https://aur.archlinux.org/packages/blesh-git/\n    https://aur.archlinux.org/cgit/aur.git/tree/blesh-update.sh?h=blesh-git\n\n    * {PRE,POST}_VERSION を local で宣言する\n      これはもう既に修正してもらった。\n\n    * _package.sh の属性は 644\n      これに関しては結局指摘する機会がなかったからそのままだが、まあ大して問題\n      はないだろう。\n\n  * syntax\n\n    1>&$fd- は使えない\n    1>&./- もエラーになる\n\n    もっとちゃんと調べる必要がある。\n\n2021-05-09\n\n  * Fedora の package にするには結構面倒な手続きが要りそうな感じである。\n    https://blog.jwf.io/2017/11/first-rpm-package-fedora/\n\n    何れにしても ble.sh は頻繁に変更が加わっているし未だ 0.* の version の段階\n    なので未だ公式に提出はしない事にする。1.0 を出す時に一緒に提出を考えるのが\n    良いだろうと思われる。\n\n  * v1.0 を出す迄に何か目玉の機能を実装したい所であるが、実の所、他のシェルに全\n    くない様な機能で便利そうな物は存在しない。\n\n    * syntax-highlighting ... 文法もちゃんと追跡した物\n\n    * error message ... これは他のシェルにはない機能である。fish にあったりする\n      かもしれないが。\n\n    * vim mode ... これは highlighting も含めてなかなか気に入っている。\n\n    * complete\n      * sabbrev ... 個人的にこれは結構便利だと考えている。\n      * auto-complete ... これは別に他のシェルと比べて何か良い訳でもない。\n      * auto-menu ... これはちょっと煩い。けれど他のシェルにもあるので。\n\n    * bottom panel ... 一つは bottom panel かもしれないがそんなに便利なのかとい\n      うと微妙な所である。tmux の方の設定で似たような物を表示できる筈だし特に便\n      利でもない。見た目に派手なので最初は喜んで使う人がいるかもしれないという\n      位。\n\n    * enhanced history ... 相対パスでファイル名を参照しているのを記録したい。そ\n      れを auto-complete の実装に役立てたい。\n\n    * TUI configuration?\n\n    逆に欠けている物。ex mode の :cmd が全然対応できていない。\n\n2021-05-06\n\n  * progcomp: complete -C completer で改行のエスケープに対応していない\n\n    man bash によると completer の出力した結果は行志向であるが \\ によるエスケー\n    プで改行を含める事ができるらしい。然し、\\ が特別な意味を持つのだとすれば行\n    末に \\ を置きたい時にはどうすれば良いのか。行内全体に於いてエスケープが意味\n    を持つのだろうか。よく分からない事が多い。実際に試してみないと分からない。\n\n    或いは read line で読み込む事ができる形式だろうか。\n\n    →実際に動作を確認したところ、エスケープの除去は行われず \\ も含まて補完文字\n    列とされる様だ。よく考えてみれば、実際に挿入した時に複数の単語として解釈さ\n    れてしまっては困る訳だから、確かにこの動作でなければならない。\n\n    ? 末尾に \\\\ があったらどうなるだろうか → \\\\ であってもその後の改行は候補の\n      一部と見做される様だ。\n\n    さて、具体的にどの様に実装するのが良いか…という事を考えようと思ったが難し\n    い。先ず標準出力を勝手に自分で COMPREPLY に代入するのは違う様に思われる。と\n    いうのも、呼び出し元の compgen で -S suffix 等の加工をしてもらわなければな\n    らないからである。だとすると、最終的な compgen の出力結果を解釈する時に行末\n    の '\\' で行を繋げる様に処理しなければならないのだろうか。\n\n    そもそも改行を含むファイル名があった時に compgen はどの様な出力をするのか。\n    うーん。普通にエスケープせずに改行を出力した様な気がする→確認した。確かに\n    そうなっている。なので '\\' が行末にあるからと言って勝手に振る舞いを変更する\n    のも憚られる。\n\n    或いは compgen の全ての機能を自前で模倣するという手もなくはない。その場合には区切りは全て制御下にある。\n\n  * progcomp: -F もしくは -C で生成した候補に対しても dir/ 等の suffix を付ける\n    必要はあるのか。もし付けたければ completion 側で付けるべきなのではないかと\n    いう気がする。\n\n2021-05-04\n\n  * robustness: ble.sh では exit を上書きしているが set -o posix の時にはそれが\n    無効になる。\n\n  * util: builtins 復元、function#advice, etc. において functrace 属性は復元し\n    なくて良いのだろうか。復元という事を考えるとやはり declare -pf を使う必要が\n    あるのかもしれない。\n\n    bash version, posix mode も含めてどういう方法があってそれぞれどの様に振る舞\n    うのか調べる必要がある。\n\n    取り敢えず問題が起こらない事を確かめた上で getdef 自体を更新するのが良いの\n    ではないか\n\n    →と思ったが実際は複雑である。getdef を使って関数を別名にコピーするのに使っ\n    たりしているが、その時に先頭部分だけを置換している。しかし declare -ft の部\n    分についても関数名を置換しなければならない。そういう事になるぐらいであれば、\n    個別に declare -ft かどうかを判定して、改めて declare -ft で属性を付加し直\n    す様にしないと行けない筈である。\n\n2021-05-03\n\n  * rlfunc: fetch-history\n    8f485ff8 - new readline \"fetch-history\" bindable command\n  * rlfunc: C-x s, spell-correct-word\n    6be3a741\n  * rlvar: enable-active-region\n    b1965836 new \"enable-active-region\" readline variable\n  * rlbind: prior, next\n    65822e50 - alias expansion fix in case statements\n  * vi-undo\n\n  * 5.2: LS_COLORS *.readline-colored-completion-prefix (bash e59452c7)\n\n    rlvar colored-completion-prefix が on でかつ LS_COLORS の中に\n    *.readline-colored-completion-prefix という項目がある時、共通一致部分の着色\n    をそれに書き換える。\n\n    実際に bash の振る舞いを調べてみようとしたがどうも有効にならない。調べてみ\n    ると、_rl_color_ext_list が初期化されていない。これを初期化する為には何かす\n    る必要があるのだろうか。_rl_parse_colors という関数で初期化しているようだが、\n    この関数はどこから呼び出されているのだろうか。\n\n    うーん。分かった。readline.c:1327 で呼び出している。これは初期化部分である。\n    つまり、readline を初期化するよりも先に LS_COLORS を設定しておく必要がある。\n    更に言うと、bind 'set ... on' も事前にやって置かないと駄目。というか\n    colored-stats の時点で同じ問題があったのではないか?\n\n    これは単純に _rl_color_ext_list が空だったらその場で _rl_parse_colors の呼\n    び出しを試みるという事と、それから LS_COLORS の値が変更される時に\n    _rl_color_ext_list をクリアする。と思ったが、これだと LS_COLORS が空の時に、\n    毎回 _rl_parse_colors が試みられて非効率的である。\n\n    * 後、_rl_colored_stats = 0 が _rl_parse_colors の中で設定されている。\n\n2021-04-30\n\n  * ble-reload: blerc 外のユーザー設定の保持\n\n    外部のツールが呼び出した blehook PREEXEC+=... 等は別枠で保存しておくべきで\n    はないか。そうしないと ble-reload した時に設定が消えてなくなってしまう。或\n    いは、blerc の中から呼び出したか外から呼び出したかで取り扱いを変える。blerc\n    の中で呼び出した設定は消えてしまっても仕方がない。一方で、blerc の外側で実\n    行した物については保持しておくのが自然なのではないか。\n\n2021-04-29\n\n  * robustness: main/init: readonly POSIXLY_CORRECT されていたらどうするのか。\n\n    少なくともどちらの側の設定であっても ble.sh 的には困る。\n\n    然し、readonly まで気にし始めるとあらゆる変数名で問題が起こるので気にしても仕\n    方がないのかも知れない。せめて全て大文字の変数だけが readonly になっていると\n    いう事を要請するのが妥当だろうか。ローカル変数で大文字を使っているというと\n    KEYS WIDGET ARG FLAG REG 辺りは危ないかもしれない。\n\n    然し、ここまで行くと「ユーザーが自分で変な事をしたのだから責任は持てない」と\n    いうレベルの事の様な気がする。\n\n  * robustness: main/init: 最初の bash version 判定も alias 対策可能かもしれない?\n    然し、return/exit が上書きされる場合等も考えると難しいかも知れない?\n\n  * robustness: \"builtin read -e\" 対策?\n\n    これは今迄考えて来なかったが関連する考察 #D1520 があったので記録として残し\n    ておく。但し、纏めた物を眺めるに総じて困難である様に思われる。\n\n    a set -o emacs / set -o vi の切り替えを利用して read が使える様にする。つま\n      り、ble.sh は裏側の keymap に bind して、ユーザーコマンドを実行する時に反\n      転させるという方法。この方法には問題が多い。\n\n      x 全てのユーザー関数 (補完関数、プロンプト、trap、blehook 等) で keymap\n        を反転する必要があるのではないか。\n\n      x ユーザーが emacs/vi keymap を切り替える rl bindable function を実行する\n        と結局 ble.sh の bind している keymap が表に出てきてその時点で制御不能\n        になってしまう。勝手にそういった binding を削除するのも非現実的な気がす\n        る。\n\n      x bash の version によっては keymap を切り替えると bind -x が中断した様な\n        気もする。\n\n    b trap DEBUG 等を使って builtin read -e が呼び出されるのを検出して、ble.sh\n      で wrap した処理を行ってからそのコマンドの実行をスキップする。この方法に\n      も色々の問題がつきまとう。ちゃんと透過的に対応できるかというと困難の気が\n      する。\n\n      x DEBUG のコストがある。\n\n      x ユーザの設定した DEBUG の管理が面倒。結局 trap DEBUG を透過的に利用でき\n        る様にする枠組みは完成していない。(これはその枠組さえ完成すれば余り気に\n        しなくても良いのかもしれない)\n\n      x 本当に実行するコマンドを入れ替える事が可能なのだろうか。例えば builtin\n        read -e の呼び出し元から見て、本当に関数実行が入れ替わった様に見えるの\n        か。exit status はどうなるのか。これは実際に実験してみないと分からない。\n\n      x DEBUG の BASH_COMMAND を用いて元のコマンドを本当に再現できるのか。例え\n        ば $1 等が使われていた時にその内容を取得する事は可能なのか (BASH_ARGV\n        を有効にしておかなければならないのか? ユーザーが設定を変更してしまった\n        らどうなるのか)。また、引数の境界等もちゃんと BASH_COMMAND を見ただけで\n        分かる様になっているのか。これも色々実験しないと分からない。\n\n    c builtin read -e に入った後で ble.sh の widget が呼び出されたら良い様に\n      状態を adjust して widget の振る舞いを変更できないだろうか。\n\n      x C-c に明示的に対応して、C-c が呼び出された時には設定を restore して抜け\n        る様にする。これは面倒なだけで処理としては十分可能である様な気がする。\n        但し、外側に SIGINT を伝播する必要はあるのかもしれない。\n\n    d ユーザーがコマンドを実行する度に realine 設定を完全 unbind して、終わったら\n      再度 bind し直す。でも、これは文法エラー等によってコマンド実行が中断された\n      時に、ble.sh session に復帰せずに通常の readline の状態に落ちてしまう。\n\n2021-04-06\n\n  * logout も exit と同様に置き換えるべきなのではないか。\n\n  * prompt を評価する時に $var が local 変数に被覆されている。\n\n    然し $var だけならば良いが $() で呼び出された関数が更に内部で変数を使用して\n    いる可能性等を考えると下手に変な調整はしない方が良いかもしれない。PS1 に直\n    接 $var と記述するかしないかで $() の内部でも変数が見えるかどうかが切り替わ\n    るというのは不自然すぎる。それならば ble.sh 自体が変数を定義するのでそれに\n    よって被覆されてしまうと説明した方が自然である。\n\n    グローバルでない変数を列挙する方法は存在するだろうか。\n\n2021-04-26\n\n  * keymap/vi: vi における既定の keymap を imap ではなく nmap にするオプション\n\n    現在の振る舞いではコマンド実行後に nmap であれば insert-mode に戻すという操\n    作をしていた筈である。その箇所を書き換えて、オプションに応じて変更先のモー\n    ドを切り替える様にすれば良い。それと ble-attach した時の最初の設定を行った\n    直後に、自動的に nmap に移動する様にする処理を加えれば良い。\n\n  * ble-bind: ble-bind -P で、他のオプションで指定したタイプの binding だけを出力する?\n\n    % -T を指定すれば -T の設定を出力する。--cursor を指定すれば --cursor の設\n    % 定を出力する。cmap 関連のオプションを指定すればそれに関連する設定を出力す\n    % る。と思ったが、-T, --cursor, --csi, -k, etc. はそれぞれオプション引数を\n    % 取るので、引数読み取りの段階で -P の後で振る舞いを変更する様にしなければ\n    % ならない。これはコマンドライン引数の解釈として不自然である。\n\n    別のオプションを使って dump する内容を選別するのが良い。例えば、\n    --filter=timeout:cursor:csi:cmap:etc 等である。\n\n  * decode: [refactor] _ble_decode_KEYMAP_kmap_@ ?\n\n    いきなり KEYMAP ではなくてその前に何か挟みたい。例えば\n    _ble_decode_kmap_KEYMAP_@ に変更する等。この場合には KEYMAP の名称として紛\n    らわしい物が定義された時に問題になるのではないか。前の実装で KEYMAP の直後\n    に固定の文字列を挿入していたのは、末尾から KEYMAP 以外の部分を一意に切り取\n    る事ができる様にする為の設計だったのではないか。\n\n    現在の実装は末尾からの一意性が保証される様になっている。_kmap_ が他で使われ\n    ていない限りに於いて、ちゃんと一意になっている。然し、名前空間として変であ\n    るというのも分かりにくい。なので、 _ble_decode_kmap_KEYMAP_xxxx_yyyy にして、\n    xxxx には yyyy に絶対に現れない文字列を指定すれば良い。例えば data 等。\n\n2021-04-04\n\n  * history auto-save\n\n2021-03-21\n\n  * robustness: 様々な基本的な変数が readonly でグローバルに固定されていたらど\n    うするのか。ロードした瞬間に様々な良くない事が起こる気がする。然し、それを\n    言い出すと、bash-completion や他のフレームワークにも強い影響が出てくるので、\n    ble.sh だけが対応しても仕方がないという考え方もできる。\n\n2021-03-07\n\n  * edit: キーボードマクロで \"M-d\" が \"M-d d\" と記録されてしまっている\n    vi でも emacs でも同様に記録されてしまう。\n\n2021-02-28\n\n  * canvas/trace: wordwrap に対応する。つまり、単語の途中で改行しない様にする。\n\n    これは今の所具体的な用途もないので取り敢えずこの儘にしておく。\n\n  * canvas/trace: より詳しい justify の仕様について設定できる様にする。\n\n    #D1494 の案では \"SEP*WEIGHT FILL SEP\" を単位として指定するという話だったが、\n    これはやはり不自然な感じで分かりにくいのでもっと分かりやすい指定方法を考え\n    るべき。\n\n    例えば、最低幅1重み2 '%1.2S{FILL}' という具合にするなど。こうすると % を\n    SEP に指定できないし } を FILL に指定できないが使う機会があるとも思えない\n    ので気にしない。或いは '%{1.2SFILL}' とする? うーん余計に分かりづらい。或\n    いは printf strftime を真似て '%1.2(FILL)S' という具合にする。\n\n    空白は既定で '%1.0( ) ' に相当する。その他の文字は '%0.0()X' に相当する物\n    とする。\n\n    2021-03-08 というより、各 sep の性質として登録するよりも、\\q{...}  を通して\n    設定できた方が自然なのではないか。\n\n    \\q{hfill w=2 fill=...}... という具合に。その場合には \\1\\2 と同様に特別なシー\n    ケンスで fill を表現する必要はある。OSC か其処らを使えば良い気がする。或い\n    は ANSI seq に何かあった気がしないでもない。\n\n2021-02-27\n\n  * /dev/tcp/... についても特別に着色を行いたい。\n\n    例えば < /dev/tcp/.../.. において正しいパスであるのにも拘らず、存在しないファ\n    イルとしてエラーが検出される。\n\n2021-02-24\n\n  * canvas/trace: trace の g0 は後で合成するのではなくて \\e[m の段階で設定する\n    べきなのではないか。\n\n    後、g0 という名前も余りよくない気がする。他の x0 y0 からの連想で初期の g の\n    値という雰囲気が出てしまう。然し一方で sgr0 からの連想で背景色という雰囲気\n    もある。実際に別の場所では sgr0 を指定する事によって背景色を設定できる様に\n    なっている。\n\n    名前はさておきどの様に振る舞うのが良いのか。例えば \\e[39m で既定色に戻すと\n    いう操作の場合は本当に端末既定色に戻すべきなのか、或いは g0 で指定した色に\n    するべきなのかというのは微妙な所である。g0 で指定した色にするべきの気がする。\n\n    一方で、下線などの属性に関しては g0 で指定したものから解除できる様にするの\n    が自然な気もするし、或いは g0 で指定した物は常に設定されているのが自然の様\n    な気もする。どちらが良いのかは分からない。やはり現状の実装で良い様な気もす\n    る。\n\n    うーん。単に設定のあるなしという捉え方ではなくて下線ありと下線なしという独\n    立したスタイルがそれぞれあるのだと思えば、やはり g0 を毎回上書きするのでは\n    なくて、\\e[m 等に対応する操作の時にだけ g0 の値に設定するというのが正解の気\n    がする。\n\n2021-02-23\n\n  * util: カーソルが bottom-dock にいる時の vbell の座標計算\n    Ref #D1495 ... 取り敢えずの対策\n\n    現在の実装は vbell が sc..rc を自由に使える前提になっている。しかしカーソル\n    が bottom-dock に停泊している時に vbell が来るとvbell によって floating\n    panels の位置が分からなくなってしまい、表示がずれてしまう事になる。\n\n    同じプロセス (親シェル) の中で vbell を処理している場合には、一旦 floating\n    panel の位置に戻ってから sc..rc をしてそれから再び bottom-dock に戻るという\n    手順を踏む事によって問題を回避できる。然し、サブシェルの中にいる場合には現\n    在の最新の配置情報にアクセスできないのでこの方法は取れない。\n\n    現在は取り敢えずカーソルが bottom-dock に停泊している事はないとの想定で\n    sc..rc を実行しているが、例えば info_display=bottom にして vi_cmap を使って\n    いる時などにこの前提が破れてしまう。\n\n    [解決方法]\n\n    ちゃんと実装する為には、親シェルで全ての描画を行う様にする必要がある。その\n    時に問題になるのがどうやって visible-bell の消去のタイミングを親側で決める\n    かという事。idle を使う方法は bash-4 以降でしか使えない。シグナルを使う方法\n    には余り頼りたくないが、現実的にはそうするしかないのだろうか。bash-3 と\n    bash-4 で実装を切り替えても良い。何れにしてもサブシェルと通信を行う枠組みを\n    整える必要がある気がする。\n\n2021-02-22\n\n  * cavnas: 描画の最中で status が高さを取得する時に textarea の内容を削り取る可能性がある\n\n    現在の render 中に配置を決定する仕組みは問題があるので再考する必要がある。\n\n  * cygwin: 下部での IL が動かない旨を報告する?\n\n    後 DA2 応答をしてくれないか頼みたい。\n\n    $ printf 'Line %s\\n' {0..100}; /bin/sleep 1; printf '\\e[L'; /bin/sleep 1\n\n    最下部で DL を実行した時にも何か変な事が起こる。\n\n    $ printf 'Line %s\\n' {0..100}; /bin/sleep 1; printf '\\e[M'; /bin/sleep 1\n\n2021-02-13\n\n  * edit: C-x e に続いて e を連続して押した時にマクロ実行を繰り返す様にしたい\n\n  * 実は bash の read -e は C-r でコマンド履歴を参照できる。ble.sh では read 専\n    用の履歴を独立に管理しているが、コマンド履歴にもアクセスできる様にするべき\n    なのでは。と思ったがやはり何だか微妙な気がする。\n\n    read 専用の履歴を別に管理するというのもありなのではないかという気がする。\n    その場合には保存場所は何処にするべきだろうか。\n    ~/.local/share/blesh\n    ~/.config/blesh\n    ~/.cache/blesh\n\n    https://github.com/fish-shell/fish-shell/issues/744\n\n    fish は過去に config に置いていてユーザの文句によって local/share に移動し\n    た様だ。然し、local/share はそれはそれで何だか変な気もする。\n\n  * gnuplot など他のコマンドに対して ble.sh によって編集機能を提供する事は可能\n    だろうか。少なくとも pty を自分で開いてその中で gnuplot を起動する必要があ\n    る? 或いは、gnuplot のリンク先の readline library を勝手に書き換えて bash\n    を起動させて、更にその中で ble.sh を使って readline 関数の振る舞いを模倣す\n    る?\n\n    rlwrap 等を使うという手もある? rlwrap のじっそうはやはり pty を開くという物\n    のようである。rlfe という物もあるようである。\n\n    どうも gnuplot の場合には普通に gnuplot & で起動しても操作できる様\n    な気がする。ble.sh で _ble_syntax_lang=gnuplot として更に\n    exec:gnuplot を提供したらそれだけで普通に動く様な気がする。\n\n    - ble-edit/is-single-complete-line で syntax:bash を呼び出している\n      のをsyntax:$_ble_syntax_lang として呼び出す様に変更する必要があ\n      る。他にも accept-line が is-complete を呼び出している。\n\n    * shell-expand 系統の widget は gnuplot モードでは無効にしたい。\n    * command-help 系統の widget も gnuplot モードでは別の実装にする。\n\n2021-02-10\n\n  * main: 関数内で引数なしで source すると関数の引数がそのまま source の中から\n    見える。これらを区別する方法はあるだろうか。\n\n    うーん。shopt -u extdebug であれば BASH_ARGC の数が二種類の source の仕方で\n    異なるようである (但しその具体的な数は bash-5 から変わっている。更に入れ子\n    source や関数呼び出しなどが絡んできた時にどうなるかは不明である)。然し、\n    shopt -s extdebug の時には両者は同じになる。\n\n2021-02-06\n\n  * tui: TreeView\n\n    以下の様な物があるのを見つけた。\n    https://gitlab.com/TheDalaiAlpaca/saturnon/-/blob/master/saturnon\n\n    実際どんな物かは確かめていないが、TUI 要素としてファイルピッカーは定番である。\n\n    その基礎として先ず TreeView を実装するというのは一つの方向性。TreeView は\n    List の拡張として作成するのが自然であろう。List の各要素の高さを変えられる\n    様にして、更に中にそれぞれリストを保持するようにしたものと解釈できる。問題\n    になるのはリスト項目が増えてきた時に高さの累積計算が重くなるという事。シェ\n    ルで実装すると成ると重み付きB木の様な複雑なデータ構造にもしにくい。或いは、\n    本気で重み付きB木をBash上で実装するという方向性もあるのかもしれない。\n\n    Midnight Commander と同等の機能を ble.sh の内部で実装するというのも\n    demonstration として良いのではないかという気がする。\n\n2021-02-05\n\n  * 他の bash プログラム\n\n    * https://stackoverflow.com/q/41043916/4908404\n      history 候補を自動的に表示する可能性について議論している\n\n      上記 StackOverflow の質問で提案されている。Google Chrome の search bar の様に、\n      幾つか文字を入力した時点でもう履歴から項目を拾って幾つか表示し始めるという可能性。\n      これは fzf の領分である様な気もするが shell integration を考えるとなかなか非自明である。\n\n      というか普通の検索でも複数の候補を表示した方が分かりやすいのではないかという気がする。\n      例えば或る一定以上の時間が経ったら一致する候補を列挙するなど。\n      更に待っていると曖昧一致も列挙してくれる、という具合にする。\n\n      2021-02-09 hstr が同様の機能を提供している。hstr の動作も参考にした方が良いのではないか。\n\n    * https://github.com/dylanaraps/shfm/blob/master/shfm (file manager in POSIX shell)\n      これは dylanaraps の fff の再実装\n\n    * これは README に乗せるバッジの話\n      https://img.shields.io/github/downloads/akinomyoga/ble.sh/total\n      ダウンロード数の画像を生成できる様だ\n\n    * Incremental parsing:\n\n      ble.sh で行っている構文解析は特殊な物であるが如何にも既存の例がありそうである。\n\n      検索したら以下の様な物があった。\n\n      [Tree-sitter｜Introduction](https://tree-sitter.github.io/tree-sitter/)\n\n      参考にしている論文を見てみると state matching で skip と書いているので、\n      やはり単に途中から始めるというだけでなく途中で解析を中断するという考えも\n      ある。寧ろ、完全に一致していなくても局所的な一致であれば解析を跳ばすとい\n      う事を実行していると思われ、より積極的な最適化である。\n\n      恐らく先にこれを見つけていたら ble.sh の構文解析の実装ももっと複雑になっ\n      て、更になかなか完成しない日々が続いたのではないかという気がする。何事に\n      も一長一短があるのであって既存の研究だって参考にできる部分と捨て置いて良\n      い部分がある筈だが調べてしまうと完全に対応したく成るのが問題である。なの\n      で、取り敢えず持てる範囲の知識で何かやってみるというのは大切な事なのであ\n      る。\n\n      oil 等は沢山調べすぎて行き詰まっているのではないかという気もする。或いは\n      逆に何だか Python -> C++ translator を開発するなど変な方向に走っていて、\n      それで余計に時間を取られているのではないか等等。やはりメンテナンス等を考\n      えると、Python は prototype として捨て置いて、C++ で完全に書き直した方が\n      得策なのではないか。Python -> C++ をずっと使う事にしていると、少しの機能\n      追加で毎回 translator にも大幅に手をいれなければならず、結局メンテナンス\n      が困難になる。特に第三者がコードに手を入れるのが極度に難しい。この構造を\n      保持したまま続けるには最初に完全なる translator を作って、その後は\n      translator の改良を行わないという決断が必要である (状況に応じて最適な翻訳\n      が異なりうる事まで考えていたら完成した translator があってもきりがない)。\n\n2021-02-05\n\n  * evaluate-path-spec (by 3ximus)\n\n    evaluate-path-spec の改良に挑戦してみるという事なので。先ずは説明が必要である。\n\n    * notilde に関しては eval の側で処理するべきではないか\n    * 後で全体 path 以外については single を加える様にお願いする\n\n    2021-12-31 詳細は以下にある。\n    https://github.com/akinomyoga/ble.sh/issues/82#issuecomment-773487368\n\n    83.sh に実装を入れて試してみる事にする。\n\n    と思ったが具体的にどの様に実装すれば良いのだろうか。先ず初めに短い物から長\n    い物まで順番にパスを構築する。その後に一番長い物から順番に一致を試みる。一\n    番長い物が一致すれば、後はその得られたパスを既存のパターンに当て嵌めれば良\n    い。と思ったのだが、どうやって当て嵌めるのだろうか。\n\n    * extglob まで絡んで来ると余計に分からなくなる。と思ったが extglob は\n      simple-word の要件を外れるのでここでは考えなくて良い。\n\n    うーん。glob を解釈して正規表現に変換すれば行けるかもしれない。或いは、\n    ${path#$pattern} または ${path%$pattern} 等として削って行けば良いのでは? と\n    思ったが、$pattern の場合には * も一致してしまうのではないか。。\n\n2021-02-03\n\n  * edit: 例えばファイル一覧を表示する機能を付けても良いのではないだろうか。\n\n2021-02-01\n\n  * complete: complete_timeout_compvar でタイムアウトした単語の glob 文字を quote しない?\n    Ref #D1457\n\n    現在はグロブ文字も quote して COMP_WORDS と COMP_LINE を構築している。例え\n    ば **/*.txt に時間がかかった時に COMP_WORDS には \"'**/*.txt'\" という文字列\n    が格納されるが、これは本来 \"**'/'*'.txt'\" であるべきなのではないかという事。\n\n    * 一方で、補完関数の方が複雑な quote に対応しているかという問題もある。\n\n    * また、ここで quote しないと結局補完関数の方でも時間がかかってしまうのでは\n      ないかという恐れがある。\n\n    という事など考えると、取り敢えずは完全に quote する実装にしておく。後で気が\n    向いたらまた考える。\n\n  * highlight: failglob の時の a/b*/c/d.txt の着色が最後のファイル名になっている。\n    本来はどの時点で failglob になるか判定して着色するべきなのではないだろうか。\n\n2021-01-28\n\n  * progcolor: ble/syntax/progcolor/eval-word を着色を跨いでキャッシュできないか\n\n    特に展開結果を何処かに保存しておきたい。新しい配列を用意するか、或いは hash\n    にして記録するか。\n\n    a hash にして記録すると一度評価した単語を再評価する機会が失われる。ファイル\n      が追加・削除された時に更新されなくなってしまう。\n\n      やはり、単語単位でやはりキャッシュしたい。そうすると shift にも耐えうる仕\n      組みにしたい、という事で新しい配列を用意するか、或いは既存の配列に格納す\n      るという方法になる。\n\n    b 新しい配列を追加する\n\n      また shift 等の操作が増える。面倒である。\n\n    c 既存の配列に要素を追加する\n\n      既存の配列に格納する場合には任意の文字列を含める事ができないので、補助配\n      列にデータを格納する事にしてその添字を既存の配列に入れるという手がある。\n      特に単語に id を振っておけば今後の word に関するデータ拡張にも使う事がで\n      きる。\n\n    →これに関しては ble/syntax:bash/simple-word/eval の側でキャッシュする様に\n    したので、今の所はここでは対応しなくて良い気がする。当初は simple-word/eval\n    では非常に短期のキャッシュしかしない方向を考えていたが、ファイルシステムが\n    そう頻繁に変わる訳でもないので、取り敢えずは行毎にキャッシュを保持する事に\n    した。なので、simple-word/eval のキャッシュは単語よりも寿命が長いので単語毎\n    のキャッシュは今の所は考えない事にする。\n\n    * 但し、やはりファイルシステムの変化に追随したいという事であれば、適当にキャッ\n      シュを更新する必要がある気がする。或いは、globpat を含む様な場合にのみキャッ\n      シュを行うというのでも良い様な気がしている。\n\n    * また、ここでの実装手法は例えばエラーメッセージの記録等の場合にも使えるの\n      ではないだろうか。という気がする。\n\n2021-01-22\n\n  * highlight: 引数が沢山あると cygwin で滅茶苦茶遅い\n\n    これは様々な種類のパス名展開を試そうとするのが原因だろうか。\n    command 名と同様にキャッシュする様にしても良いのではないだろうか。\n    でも少しずつ微妙に異なる引数が沢山ある場合には結局遅い。\n    それよりは着色自体の高速化について考えた方が良いのではないか。\n\n    * chat でも遅くなるかどうかについて確認する。\n      やはり微妙に遅い様な気がする。\n\n    何が遅くなっている原因化について確認する必要がある。\n    例えば fork している可能性はあるだろうか。\n\n2021-01-08\n\n  * syntax: 算術式の quote が変である\n\n    x echo $((a['$hello'])) の $hello は展開対象なのに着色されない。\n      →然しこれは文法上の問題なので寧ろ着色しない方が自然である様に思われる。\n      (これは eval の引数を着色するのかという問題にも通じる)\n\n    x ((a[\"$index\"])) がエラー着色になっている\n      →どうもこれは bash-5.0 から振る舞いが変わったという事の様である。\n\n    x bash-5.1 からは (()) でも ' は quote ではない。\n\n    x 更に言うと a['...'] の ' は a が連想配列の時には必ずしもエラーではない。\n      現在はエラー着色になっているがこれは修正するべきの気がする。\n\n2020-12-19\n\n  * Note (#D1435): blehook WINCH を処理している最中に終了したユーザのジョブがあ\n    るとその通知が画面に表示されない可能性がある。これは実際に起こりうるのかど\n    うか確認していない。\n\n2020-12-14\n\n  * progcomp: progcomp で生成された補完候補を現在 quote している。\n\n    * 生成された候補が既に quote されている場合や展開を含む場合に、\n      意図したのと異なる結果になってしまう問題がある。\n    * 更に既に入力済みの部分に一致しなくなるので遡って書き換わる可能性もある。\n    * 生成された候補が複数の単語に分かれる場合に、\n      それが blesh の quote によって一つに結合されてしまう問題もある。\n\n    理想的には生成された候補を改めて simple-word/eval して、\n    その結果に基づいて単語を再度挿入し直すという事が考えられるが、\n    x 全ての候補に対してこれを実行する事を考えると処理が重くなってしまう。\n    x また、\\**\\* 等を展開すると *** になってしまうので\n      その quote を復元する方法についてもちゃんと考えなければならない。\n\n    或いは simple-word element を一つずつ抽出して処理すれば良いのかもしれない。\n\n2020-11-30\n\n  * tui: face editor の TUI の様な物を作っても良いのかもしれない [#T0007]\n    というより fish の Web interface の様な物を TUI で提供しても良いのでは。\n\n    2021-04-25 @Alyetama から似たような提案を受けた。\n    https://github.com/akinomyoga/ble.sh/issues/80#issuecomment-826194833これは\n    初期設定 wizard の様な物を想定している様だが、TUI config ではもっと自由にい\n    つでもどの設定でも選んで設定できるのでより自由度は高い。そう言った物でも良\n    いかという事を一応確認はしてみる。\n\n    作るとしたら先ずは Color Picker?\n    その前に layout engine? 或いは画面の切り替え?\n\n    Window system がどうのこうのという計画があったような。window system に関し\n    ては内部バッファだとかスクロールだとか textarea だとか様々の物を内包する物\n    であった筈で、此処で必要になる物は其処まで複雑な物ではない。でも一緒に実装\n    してしまっても良い様な気もする。\n\n    - Windows system に必要な物。control, window, layout-engine,\n      background-buffer, redraw, resize, etc.\n\n      既にある panel, textarea 等を拡張する感じに考えても良いのかもしれない。但\n      し、これ以上の ble.sh の肥大化を避ける為に canvas ではなくて新しく\n      lib/core-forms.sh 的な物を追加して其処で実装するのが良いのではないか。\n      textarea に関しては、forms が或る程度形になってから対応するという形で良い\n      気がする。\n\n      control に属する変数の記録方法? これは textarea と同様にしたいが、\n      textarea の方も forms に対応しようとすると調整が必要になると考えられるの\n      で、最初は既存の枠組みに捕われずに実装するので良い気がする。\n\n    - window: overlay を実現する方法として二つの可能性が考えられる。\n\n      a redraw 関数の方で clip 等を処理する方法。\n\n        これは各 control の実装が複雑になってしまう。というより任意の clip\n        region の形状に対応しようとしたら非現実的な実装になってしまう。\n\n      b もう一つは Window の側で buffer を内部に保持し、最終的な描画の際にそれ\n        を適当に clip して出力する方法。\n\n        これに関しては内部 buffer の表現方法に工夫が必要になる。\n\n    取り敢えず何も考えず少し実装してみた。clip に関しては redraw の側で適当に処\n    理する事にした。また、trace に於いても clip 機能を実装した (#D1493)\n\n    invalidate 範囲を記録できる様にしたい。\n\n    更に、要素のサイズが変更された時、移動した時には親の該当範囲も一緒に\n    invalidate する必要がある。\n\n\n    自身の内容が変化した時、自身に被っている別の要素も一緒に更新する必要が出て\n    くる事に注意する。\n\n    a 上に物が被っていない時には clip 領域を勝手に広げて描画しても良いのではな\n      いか。描画範囲を広げても良いかどうかについては render.draw の呼び出し元か\n      ら指定できる様にすると良いのかもしれない。\n\n    c 或いは、そもそも被らない様にするか、被っている時には更新しない様にすると\n      いう手もある。\n\n    d 或いは、render.draw の呼び出し元で一旦シーケンスを取り出して、その上でそ\n      れを再度 trace によって clip するという手もあるかもしれない。然し、これは\n      描画内容が大量にある場合にとても遅いので実は避けたい。\n\n2020-11-20\n\n  * bash: declare -c や ${var~} 等は 5.2 で削除するとしているが本当だろうか\n\n2020-11-13\n\n  * complete: bash progcomp と ble.sh progcomp の競合問題\n\n    現在は complete:* の方が builtin complete の設定よりも優先される様になって\n    いる。これは ble.sh がロードされていない時はbash-completion を使い、ロード\n    されている時は ble.sh 様に特化した補完設定を使うという状況を考えると自然で\n    ある。\n\n    然し一方でユーザーが自分の好きな設定を builtin complete で設定してもそれが\n    反映されないという問題が生じる。やはり builtin complete の方を優先させるべ\n    きだろうか。或いは、complete:cd は既定ではロードしない様にして、contrib か\n    何かに入れてユーザにロードさせる様にするのが良いのではないかという気もする。\n    然し、ユーザにロードさせるとしてもコマンドを一つ一つロードするのではなくて、\n    まとめてロードするという状況も考えられる。その場合には、やはり builtin\n    complete と complete:* の競合が起こってしまいどちらを優先させたら良いのか分\n    からなくなる。\n\n    或いは ble.sh に特化した設定も builtin complete 経由で呼び出す様にする?\n    しかしそうすると ble.sh から ble-detach した時に動作しなくなってしまう。\n\n    attach/detach の際に設定を保存・復元するという方向性も考えられる。\n\n    complete を上書きして両方の設定を行える様にするという手もある。この場合には\n    attach/detach する時に既に設定した内容を読み取る等の工夫が必要になる?\n\n2020-11-11\n\n  * syntax: $HOME 等の変数展開があるパスに対して simple-word/eval が重い問題\n\n    中でグローバル変数の復元等の複雑な処理をしている。一回呼び出すだけならば良い\n    が $HOME/.mwg/src/ble.sh/archive/layers ... 等の様なパスの着色で各ディレクト\n    リの階層で展開を試みている場合に、何度も呼び出す事になると遅さがかなり目立つ\n    ようになる。\n\n    単語着色では determine-separated-path -> locate-filename ->\n    highlight-pathspec という具合に三段で処理していて各段で毎回 eval しているの\n    で特に重い。これは処理を統合して高速化する余地もある。コードが汚くなるという\n    問題はある。よく考えたら現在の実装では locate-filename は特に eval は実施し\n    ていない。単に : で区切っているだけである。なので locate-filename に関しては\n    気にしなくても良い。\n\n    或いは複数のパスを一度に eval する機能があっても良いのかもしれない。その場合\n    に結果をどの様に返すのかは難しい。複数単語に展開される事を考えて既に一つの\n    eval の時点で ret が配列だからである。各パスの最初の単語だけを返す事にするか、\n    或いは全ての単語を全部混ぜて一つの配列に返すか。一つの配列に格納する場合には\n    各パスに対応する index の範囲を返す事ができるがインターフェイスとしては分か\n    りにくい。\n\n  * bashbug: builtin で while という名前の builtin を load すると他の builtin が\n    使えなくなる。\n\n    ? 使えなくなるのは、同じ dll の中の物のみなのか或いは全ての dll の loadable\n      builtin が使えなくなるのか。\n\n    ? while 以外にも問題を起こす名前は存在するか。\n\n    ? 影響を受ける builtin はキーワードと一致する名前の物のみか或いは全てか。\n\n2020-11-07\n\n  * complete: PATH=path1:path2:path3 の補完\n\n    PATH=path1:path2:path3 の時に着色が最後の要素にしか適用されないし、また補完\n    は全然働かない。全く動かないのならばまだしも中途半端に動くのは変なのでちゃん\n    と対応したい。\n\n    →着色に関しては #D1409 で議論する。\n\n    complete に関しては元の bash ではちゃんと動いているので尚の事問題である。\n\n  * highlight: 条件コマンドの中での着色が効かない。着色しても良いのではないだろうか。\n    今まで実装していなかったのは正しい文法解析や入れ子などの処理が面倒だったから。\n\n    今確認してみると 条件コマンドの中でも ( && || ) などは特別な意味を持つ様であ\n    る。更に & や | を使うとエラーになる。<< 等のリダイレクトもエラーである。必\n    ずしも空白で単語が区切られる訳ではない様なので、これに関しては文法解釈のレベ\n    ルで修正が必要になる。\n\n    今試すと ; も途中に現れると区切りとして取り扱われてエラーになる。\n\n    * |&;<>() は特別に取り扱う必要があるという事。単体の < と > に関しても正し\n      い演算子の文脈に現れれば大丈夫だが、二項演算子の現れない場所で使うと構文\n      エラーになる。この様な構文エラーまでチェックする必要があるだろうか。或い\n      は演算子の結合まではチェックしない事にするか。\n\n    * 括弧の途中で ]] が現れた場合にもエラーになる。\n\n2020-11-06\n\n  * complete/mandb: progcomp で生成したオプションに関してもできれば desc を表示する様にしたい。\n    progcomp に候補を生成させてもしオプションが含まれていて、\n    かつそれが mandb の中に含まれているという事が分かった時に desc-raw を表示する。\n\n    * git 等の場合には man git で得られるオプションと\n      サブコマンドで得られるオプションは異なるので注意する。\n\n  * complete/mandb: bash の場合にはビルトインコマンドのオプションまで混ざって列\n    挙されてしまって駄目。bash 固有のオプションについてまとめたファイルを用意し\n    ておくべきである。\n\n    bash builtins のオプションに関しては builtin ... --help を使用すれば取得でき\n    る。これはこれでまた解析の為のコードを書かなければならないが、bash の\n    builtin に限れば形式が定まっているので解析のコードを書くのは難しくはない。\n\n  * complete/mandb: 何と man git は .PP ... .RE 4 ... .RS でオプションを説明している。\n    この様に .TP を用いない様な場合にも対応するべきなのだろうか。\n\n  * complete/mandb: 同じ意味を持つオプションについて。\n    同じ意味を持つ複数のオプションを分ける時に、\n    分けてから sort するのではなくて sort してから分けるべきではないか。\n    同じ意味を持つオプションは連続されて表示されて欲しい。\n\n2020-09-07\n\n  * complete: メニュー絞り込みが働いている状態で単一確定ができない場合がある\n\n2020-09-03\n\n  * main: attach 戦略再考 [#T0004]\n\n    attach の戦略に関する議論は以下にある。\n      #D1382, #D1124, #D0940, #D0737\n\n    | a 即attach。PS1 表示\n    |   x PS1 が後で変更された時に問題。\n    |   x 後の設定の出力が消滅する\n    |\n    | b 即attach。PS1表示はする。出力抑制はしない\n    |   x PS1 が後で変更された時に問題。\n    |   x 後の設定の出力と混ざる\n    |\n    | c 即attach。PS1表示はpromptまで遅延\n    |   x keymap初期化に時間がかかる\n    |\n    | d 即attach。PS1表示する。出力は記録して後でdump\n    |   x 後の設定が対話的なインターフェイスを起動した時に問題\n    |   x 後の設定が /dev/tty に対して出力したら防げない\n    |   x 後の設定が初期化進捗などを出力するとそれが実時間で反映されない\n    |\n    | e PROMPT_COMMAND。trap DEBUG/RETURN を用いて変更検知\n    |   関連: #D1124, #D0737\n    |   x DEBUG はコマンド直前の実行なので最終行での書き換えは防げない\n    |   x RETURN は rcfile 末尾では発生しない\n    |\n    | f PROMPT_COMMAND の読み書きを hook する(非ネイティブな)手法はあるか?\n    |   x ない\n    |\n    | g 他の hook/trap を用いて適切なタイミングを検出?\n    |\n    |   a EXIT はシェルが終了する時なので使えない\n    |   b command_not_found も使えない\n    |   c kill -USR2 $$ によるハンドラは?\n    |     x 試すと rcfile 終了を待たずに次のコマンドですぐに実行される\n    |     x kill ... & として別プロセスから投稿しても同様\n    |   d bash (execute_prompt_command) を確認したが介入点は他になさそう\n    |   e PS1 に kill 等を埋め込んで通知させる\n    |     x これは PROMPT_COMMAND よりも信頼できない\n    |\n    | h PROMPT_COMMAND の中の最初のコマンドを DEBUG で検出?\n\n    可能性があるとすれば h の手法である\n\n    * trap DEBUG/RETURN の性質を熟知していないとユーザの設定した\n      DEBUG/RETURN と干渉しない様にするのは難しいと考えられる。\n      これは DEBUG/RETURN の枠組みを整えてからにする必要がある。\n\n    rcfile で ble.sh をロードした時には rcfile を抜けた後の\n    PROMPT_COMMAND 直前でアタッチを行う。\n\n    * \"PROMPT_COMMAND の最初のコマンド\" は恐らく判定可能である。\n\n      rcfile 及び最初の PROMPT_COMMAND 内にいる時は BASH_LINENO の最後の\n      要素は0 になっている。rcfile 内にいる時は FUNCNAME の最後の要素は\n      \"source\" になっている。更に bash-4.4 以降では rcfile から\n      PROMPT_COMMAND に移る時に $- に s が追加される。\n\n      PROMPT_COMMAND で何か実行するならば、最初のコマンドは必ず\n      FUNCNAME[-1] != source になっている筈である。\n\n    対話シェルで ble.sh をロードした時は \"bashrc を抜けた直後\" という戦\n    略は使えないが、HISTCMD, ${_histcmd@P} を用いてユーザコマンドか\n    PROMPT_COMMAND かの判定が可能である。\n\n    * HISTCMD は ユーザコマンドを実行している時には $(history 1) の最初\n      の要素に一致する。PROMPT_COMMAND を実行している時には常に 1 になる。\n\n    * HISTCMD が unset されている場合には代わりに _histcmd='\\!';\n      \"${_histcmd@P}\" が使える (bash 4.4)。HISTCMD が unset されているか\n      どうかは HISTCMD=A して値が変化するかどうかで判定できる。\n\n2020-08-27\n\n  * 真面目に宣伝など考えるべきなのかもしれない。\n\n2020-08-03\n\n  * README: bashrc 設定方法の更新\n    関連: #D1382, #T0004\n\n    最終的には bashrc の何処に ble.sh を記述しても動くようにしたい。取\n    り敢えず、比較的信頼できる手法が確立するまでは README の load 方法\n    はそのままにしておく。\n\n  * macOS で遅いという話 (reported by tigger04)\n    https://github.com/akinomyoga/ble.sh/issues/58\n\n    チェック項目は…\n\n    * complete -r の代わりに\n      shopt -u progcomp を指定したら改善するか?\n\n    問題になっている可能性がある処理は\n    ble/complete/progcomp/.compgen の builtin compgen 経由で呼び出される。\n    特にユーザの定義した関数・コマンドは以下の関数経由で呼び出される。\n    - ble/complete/progcomp/.compgen-helper-func\n    - ble/complete/progcomp/.compgen-helper-prog\n\n    上記の関数に benchmark を設定して stackdump なり何なりを計測する?\n\n    ble/function#advice \\\n      around ble/complete/progcomp/.compgen-helper-prog \\\n      ''\n\n    * 対策としては auto_complete の時には progcomp を実行しない\n      というオプションを追加するというのが一つの可能性。\n      bleopt complete_auto_progcomp=1 という事にするのが良い。\n\n      実現可能性について。\n      現在の呼び出し文脈が auto_complete かどうかを判定する必要がある。\n      確認してみると comp_type に auto を含めている様である。\n      実際にそうなっているのか確認する。\n\n    情報をメールで貰った。\n    メールではどの期間だけ complete -r を除いていたか分からないとしているが。\n\n    2020-08-05 05:12:50 IST\n    2020-08-05 05:13:27 IST\n    2020-08-05 08:43:54 IST\n    2020-08-05 08:43:57 IST\n    2020-08-05 11:02:53 IST\n\n    まあ、どの期間だけ有効になっていたのかという情報は実はそんなに重要ではない。\n\n    眺めていて気づいた事。\n\n    最後にユーザが入力を行ってから auto-complete が起動するまでに一定の時間がかかっている。\n    大体 200ms の様な気がするが、しかし時間帯によって変わっている気もする。\n    TAB 補完の場合にはこの delay が存在していない (0.06s) 事を考えると、\n    これは history 補完にかかる時間という事だろうか。\n    history 補完を無効にしたらこの delay は少なくなると判断して良いだろうか。\n\n    補完が走らずに入力できている部分は history に match している入力であろう。\n\n    どうも後半で時間がかかっているのは history の様に思われる。\n    TAB 補完の時には 150ms 程度の遅延だが自動補完の時には 600ms に増えている。\n    然し、その後で 200ms 程度に減少したりもしている。\n    うーん。或いは単語の展開に時間がかかっているのかもしれない。\n\n    * reject: 取り敢えず history 展開について高速化できないか確認する。\n\n      | search-history-heavy について改善できないか考える。\n      |\n      | a 特に bash-5.0 以降では history -d range を用いて削除した上で\n      |   history -p を実行すれば高速に過去の履歴を読み出す事ができるのではないか。\n      |   →と思ったがよく考えたらどの範囲を削除したら良いのか不明である。\n      |\n      |   !string で一致させてその後その候補が当て嵌まらないと分かったとする。\n      |   この時その候補以降の履歴項目を全て削除してから再度 !string で\n      |   一致させれば良い様に思うが、最初に一致した候補が何番目の履歴項目か\n      |   という情報がないのでどの範囲を削除したら良いのかが分からない。\n      |\n      |   a 例えば二分法で探索する? と思ったがこれだと二分の一の確率で\n      |     サブシェルを生成しなければならない。明らかに非効率的である。\n      |     或いは履歴展開に履歴番号も一緒に展開させる方法があったろうか。\n      |     ない気がする。\n      |   b やはり履歴番号を抽出できないかと思ったが、その様な履歴展開はやはりない。\n      |     !string で一致させて単語指示子で履歴番号に置換できれば良かったが\n      |     その様な単語指示子は存在しない。\n      |   c 或いは、番号を指定しなくても一致した項目以降を削除する方法があれば良い?\n      |     然し、history -d の引数はやはり数値であって履歴展開ではない。\n      |\n      |   この方針は難しいのではないかと思われる。\n      |\n      | b 或いは、history | grep を用いて最後に一致した項目を取り出す事ができるのではないか。\n      |   但し、grep の時の問題は行区切りをどうするのかという事。\n      |\n      |   grep -z を用いれば NUL 区切りで判定する事が可能。\n      |   然し、これは GNU extension である。安易には使えない。\n\n      →うーん。調べてみたがちゃんと history search を呼び出す時に\n      stop_check を指定しているのでユーザの入力があった瞬間に復帰する筈である。\n      つまりこれ自体に時間がかかっていたとしても動きが遅くなる事はない筈?\n\n      そもそも complete -r で解決したという事を考えると明らかに history は関係ない。\n\n      然し、実際に timing log を見るとユーザの入力が待機されている…という事はない様な気がする。\n      やはり現在の情報では history からの自動補完が問題になっていると考える根拠がない。\n      従って、(不自然な方法を取ってでも) history 展開の高速化方法について考えるのは不毛である。\n\n    * 再び報告があった。コンピュータ自体の処理が重くなっている時に動かなくなるという事らしい。\n      普通に bash を動かしている時には問題ないという事を考えるとファイルアクセスが怪しい。\n      ファイルアクセスしている箇所は沢山ある。特に着色のためのパス名展開である。\n\n2020-06-04\n\n  * 行数が極端に少ない時の動作 (横スクロール)\n    bash-5.1 では横スクロールモードに移行するそうだ。\n\n    そもそも現状で一行しか使える行がない時に何が起こるか。\n    実際に試してみると (line 1) という表示だけになって\n    更にその上に何か表示しようとするのでまともに表示できない。\n    2行の場合にもまともに動かない。vi-mode の mode name で 1 行消費している為である。\n    3行の場合にようやくまともに動く様になるが、それでも vbell が上に被ってしまう。\n\n    横スクロールまで実装しないとしてもまともに動作する様にはしたい。\n    そもそも (line N) という表示を省略する様にする?\n    現状の実装ではプロンプトは必ず表示する様になっている。\n    然し、プロンプトを表示するからこそ変な事になっているのである。\n\n    a 行数が 1 になった時にはそもそもプロンプトを表示しない?\n      然し、それだとプロンプトが何も表示されなくなってしまってそれはそれで変だ。\n\n    b プロンプトは固定で残りの部分で文字列を編集する?\n      これだとプロンプトが画面よりも長い時に何もできなくなる。\n\n    c プロンプトも一緒に横スクロールする?\n\n      | これに対応する為にはプロンプトの内部の各文字の配置を追跡する必要\n      | が出てくる。\n      |\n      | Bash native でも \\[...\\] を使っている場合にどうやって数えるのだ\n      | ろう? という疑問が残る。\n      | →bash の動作を見たところ、prompt も一緒にスクロールする。しかし\n      | prompt の途中位置でスクロールが止まる事はない。つまり、prompt は\n      | 全体が表示されるか全く表示されないかのどちらかである。\n      | →prompt 自体の長さが画面の横幅よりも大きい時には、常に横スクロー\n      | ルした状態になってしまい、コマンドの1文字目は常に '<' に隠れて表\n      | 示されない状態になる。また表示の乱れも発生する。\n\n      Bash は横スクロールによってプロンプトが表示されるか、全く表示さ\n      れないかのどちらかの状態になる。中途半端にプロンプトが表示されて\n      いる状態はない。プロンプトの長さが画面の長さよりも大きい場合は対\n      応しきれていない。\n\n    * プロンプトが範囲内に収まらない場合には何が起こるのか?\n      プロンプトの trace の時に高さを制限していただろうか。\n      →駄目。制限はしていない。そもそも制限する事自体が自然な動作なのかも分からない。\n      リサイズした時に上に流れた情報を参照したいという場合を考えれば、\n      プロンプトは制限せずに上に流れてしまうという振る舞いが自然の気がする。\n\n    現在のスクロールの実装はプロンプト行の次以降で実施する前提になっている。\n    つまり画面の高さが1行しかない場合には色々弄らなければならない。\n    プロンプトが複数行ある場合にはそれだけ多く画面の高さが必要になる。\n\n    * プロンプトの出力は気にせずに実施する。画面がスクロールしても気にしない。\n      →これを実行するとその他の panel の描画位置もずれてしまう事になる。\n      他のpanelの内容を上書きしないように事前に空行を挿入しようにも、\n      空行を挿入した時点で他の panel の内容が反対側の端から流れてしまう。\n      という事を考えると、行数が厳しい時には他の panel は全て潰すのが現実的。\n\n      潰す条件がプロンプトの高さが一行に収まりきらない場合、というのは\n      プロンプトとして変な物を指定する場合を考えると制限が強い気もするが、\n      その様な場合は余りないと考えればそれでも良い気もする。\n\n      因みにプロンプトの高さが1行に収まらない状況としては、\n      プロンプト自体に改行が含まれている場合以外にも、\n      プロンプト内に長い文字列が含まれていて何度も折り返す場合を含む。\n\n  * util: ble/dict#* を用意する可能性?\n\n    設定ファイルの自動アップデートの実装に関連して\n    ble/dict#* という物を作成しても良いのかもしれないとも思う。\n    既に辞書的な構造は ble.sh の各所で個別に実装して使用している。\n\n    辞書の bash-4.0 未満における最適の実装は何だろうか。\n    任意の key を取り扱える様にする必要性を考えると、\n    : 等を区切りにして scalar に key を格納する訳には行かない。\n    そうすると配列に key を格納する必要が出てくる。\n    配列が巨大になってくると重くなってくる。\n\n    a 簡単な hash を作るという手もあるだろうか?\n      例えば配列サイズが小さい時には最初のバイトだけを使って、\n      要素が増えてきたら n 番目のバイトまで使って hash を生成する。\n      と思ったがそれだと共通の接頭辞を持つ key が沢山ある時に hash が衝突する。\n      例えば /home/murase/... という物が沢山ある場合。\n\n    b 或いは全ての文字を用いて hash を計算する?\n      という事にすると今度は長い文字列に対して各文字について文字コードを取得する手間がかかる。\n      特に bash-4.0 未満では色々面倒な事をする。何れにしても ble/util/assign を使うので遅い。\n      (実際にこれでキャッシュをしていないのは下手にキャッシュするよりも ble/util/assign\n      を実行した方が高速であるという事からであろうという気がする。)\n\n    c key の sorted list を管理する。\n      文字列で辞書順でどちらが速いかについては [[ str < str ]] で判定できる。\n      後はアクセスの度に二分探索を実施すれば良いのである。\n      挿入には結構時間がかかりそうな気もするが、まあ、大丈夫。\n      然し、よく考えたら bash-4.0 未満の配列はアクセスが線形時間だった気がする。\n      という事を考えると二分探索よりも線形探索の方が実は良いのかもしれない。\n\n    使用ケースによって色々なので汎用的な実装はやはり難しい気がする。\n\n    * key が整数の場合には普通に配列を使えば良い。\n\n    * key が有限の単語 (識別子) の集合であれば、\n      local apple=1 banana=2 pineapple=3 orange=4 等の様にして、\n      普通に arr[apple]=red 等とという風にすれば良い。\n\n      或いは普通に変数に保存すれば良い。\n      eval \"arr_$key=red\" という具合である。\n      この場合大量の変数が散らかってしまうが、\n      それが気にならなければ最良の気がする。\n\n    * key に \":\" が含まれない場合には\n      keys にコロン区切りの key の集合を保存しておいて、\n      head=${keys%%:$key:*} head=${head//[!:]} 等とすれば\n      key が何番目の要素であるかというのを取得する事ができる。\n\n    * key が文字である場合も同様にして\n      head=${keys##\"$key\"*} 等としてから ${#head} で文字数を見れば\n      それが何番目の要素であるかというのを判定する事ができる。\n\n    * 辞書をメモ化に用いている場合には実は関数自体の計算時間が\n      bash による辞書の模倣よりも速い可能性を考えるべき。\n      例えば ble/util/s2c については ble/util/assign printf %d '$c の方が\n      下手な辞書よりも高速なのである。\n\n    * key の種類がそんなに沢山でない場合には、\n      key を配列に格納して線形探索するというので良い。\n      これが最も単純で自然な実装になる。\n\n      key を sorted list に入れて二分探索するという可能性もあるが、\n      Bash-4.0 未満の配列のランダムアクセスは線形なので、\n      それよりは普通に線形探索で舐めた方が良い気がする (実測すると違うかもしれない)。\n\n    結局使用ケースによって最適な実装方法が異なるという事から統合は難しい。\n    ble.sh の内部で使わない以上は用意しても仕方がない様に思われる。\n    そもそも ble/dict#... の形式による配列アクセスは文法的にそんなに綺麗でもない。\n    等の事を色々考えると、ユーザの為に用意する程でもない。\n\n2020-05-20\n\n  * 破壊的変更と後方互換性\n\n    * done: keymap_vi_nmap_name は keymap_vi_mode_nmap_string 等に改名するかもしれない。\n      或いはもっと別の名前? やはり keymap_vi_mode_normal で良いだろうか。\n      改名するとしたら complete_stdin_frequency と同様に別名に書き換える様にする。\n      実はオプションの改名について枠組みにしてしまっても良いのかもしれないという気がする。\n\n    * 勝手に古い設定を書き換える機能を作っても良いかもしれない。\n      毎回一行ずつ書き換えを実行するのではなくて、\n      書き換えを実行する sed スクリプトを貯めておいて、一括で書き換えを実行する。\n      cp a a.bk && sed \"$script\" a.bk > a 等の様に実行する。\n\n      sed スクリプトは何処に貯めて於けば良いのだろうか。\n      書き換え対象のファイル名と一対一に対応するファイル名にする必要がある。\n\n      a 辞書にファイル名を記録するか或いは hash を用意するか。\n        hash は計算に時間がかかるので辞書にファイル名を記録するのが良い気がする。\n        然し、bash-4.0 未満ではどの様にするのが良いのか微妙である。\n\n      b 或いは、別に辞書など作らなくても直接ファイルシステム上に書き出しても良い気がする。\n        つまり、 \"$file.sed\" に書き出して置いて、それを適用して削除する。という具合にする。\n        問題はファイル名が被らない様にするという事。乱数で決定する事にすると駄目。\n        \"$file.__BLE_REWRITE__.sed\" 的なファイル名にするのが良いのではないか。\n\n    * ble{-edit => }/prompt/{print,process-prompt-string,backslash} についても\n      警告を表示する様にする仕組みが必要になる気がする。\n\n2020-05-16\n\n  * TERM=alacritty で何か変な事が起きるらしい。\n    https://github.com/rux616/init/commit/b03e7ef3dab5171d1f60aa61323ef823401217d5#diff-0af95dc8119f1c458b7a0fd76dfe8042R37-R39\n\n    調べてみると alacritty:extra/alacritty.info が terminfo らしい。tic -x extra/alacritty.info で入れる。\n    然し、何も問題は起きていない様に見える。256color もちゃんと動いている。ずっと使っていると発生する問題だろうか。\n    これは時間があれば rux616 に何が起こるのか尋ねても良い。\n    所で、いつの間にかに alacritty は jwilm/alacritty から alacritty/alacritty に移動したらしい。\n\n    →cache/alacritty.term を確認した所 ich, ech, dch が空になっている。\n    然し、ble.sh は ich, dch は使っていない。ech を使う場合でも、\n    [[ $_ble_term_ech ]] の時にのみ有効になる様になっている。\n\n    他に気付いたのは 8-15 の着色が 0-7 と同じになっているという事。\n    然し実際に tput で tput setaf 15 とすると CSI 9 7 m になる。\n    何かが間違っている。再度実行してみた所、問題なく初期化された。\n    と思ったら alacritty.term と xterm-256color.term の内容が同一になった変だ。\n\n    続けて何度試しても問題は発生しない。何が起こったかは謎である。\n\n2020-04-25\n\n  * trap: DEBUG trap を用いて DEBUG trap を再現できるか? [#T0003]\n    参考: #M0016\n\n    つまり関数呼び出し毎に DEBUG trap が設定されるというのを実装する必要がある。\n    ble.sh が使っていなければ特に問題は発生しないが、\n    INT を受信した時に ble.sh が DEBUG trap を設置する事になっている。\n    従って、実装できれば実装するのが良いという様に考える。\n\n    要件は以下の通り\n\n    * 何も DEBUG trap が設定されていない時には overhead 0 にする。\n      つまり builtin trap で何も設定されていない状態にする。\n      ユーザか ble.sh のどちらかが何か設定している時に有効にする。\n\n      実のところ、ble.sh の使い方は一時的な物なのでユーザの trap と\n      同レベルの取り扱いで良いという気がする。唯単に trap で列挙されない、\n      ユーザの設定した trap も保持する、という事が異なるだけ。\n\n    * 関数呼び出しでの継承・非継承を再現する。\n      実はこれはそのまま bash の継承・非継承に従うだけで良い気がする。\n\n    * 呼び出し元への影響についても再現する。\n      これは新しく trap DEBUG が呼び出される時に、\n      builtin trap DEBUG もやり直せば良い?\n      と思ったがそもそもそんな事をする必要もない気がする。\n      現在のフレームに既に何か設定してあるという事は\n      呼び出し元ではそれが必ず有効という事だから。\n\n      bash-4.3 以下では何れにしても呼び出し元に影響を与える事はできない。\n      うーん。bash-4.3 以下では trap DEBUG で保存した trap handler を\n      関数が抜ける時に削除する必要があるという気もする。\n      これについては実装時に注意深く実装すれば良いだけ。\n\n    * DEBUG trap の中で DEBUG trap は設定できるが発火しない。\n      BASH_COMMAND は書き換わらない。\n\n    実の所、DEBUG は C-c の時にしか設定していないので、\n    取り敢えず気にしない事にする。\n\n    先ず試験的な実装を作成して見るのが良い気がする。\n\n  * trap: INT\n    現在の実装ではユーザの設定した INT で握りつぶしても、\n    ble.sh の設定したハンドラによって実行が中断される。\n    ユーザが INT を設定している時には握りつぶさない様にするという手もある。\n\n  * [保留] bash-4.4 trap 内無引数 return の修正\n\n    ref #D1350\n\n    bash-4.4 以降では trap 内の無引数 return は trap handler が開始する直前の $? を返す。\n    強制的に trap handler の内部での直前の $? を返す様にする方法はあるだろうか。\n\n    * return() { builtin return $?; } とする案\n      x 本来の return を実行する方法がない。\n        RETURN trap を使って return 関数呼び出し後に builtin return できないか?\n        x RETURN trap は抑も終了しようとしている関数内の文脈で実行される。\n        x RETURN trap 内部では RETURN は発火しない。\n    * alias return で何とか無引数の場合を $? に置き換える事は可能か。\n      x 引数がある場合とない場合の両方に alias で対応するのは難しそう。\n\n2020-04-19\n\n  * history: 履歴の管理の枠組みで欲しい物\n\n    1 実行したコマンドを追記で記録する仕組み (勝手に編集したりしない)\n      他のシェルと同様に追加の情報も記録する?\n\n      * 実行したディレクトリ。実行した時刻。$$.$LINENO\n\n      * コマンドラインに含まれる有効なファイルパスの集合\n\n        | fish はこの情報を用いて history autosuggestions の時に\n        | コマンド履歴のフィルタリングを実行する様だ。\n        | 然し疑問なのは echo > a.txt で a.txt など出力ファイルが元から存在していた時には、\n        | 新しくファイルを作成したいという時にその履歴が候補に出てこない、\n        | という事態になってしまうのではないかという事。\n        |\n        | その様に考えるとやはり実は個別のコマンド毎に判定した方が良いのではないか。\n        | 例えば cd の場合には使い方が決まっているので、\n        | 実際にそのコマンドラインを実行した時に成功するか失敗するかはすぐに判定できる。\n\n        自動補完のフィルタリングに関しては完全な判定はできないので\n        取り敢えず core でサポートしなくても良い。\n\n      * zsh は実行にかかった時間も記録する様である。\n\n        | 然し、これは微妙。何故ならば bash ではコマンドの実行開始前に履歴を追加するから。\n        | 実行後に書き換える仕組みが必要になる。或いは開始の記録と終了の記録を別々にする?\n        | そうすると複数のセッションで実行している時に互い違いになってしまう。\n        | なので実行するコマンド毎に ID を設定する必要がある気がする。\n        | と思ったが ID は $$.$LINENO 等で良い気がする?\n        | x と思ったが同じ PID でシェルが起動する事もあるのでは?\n        |   o と思ったが同じ PID で複数のコマンドを同時に走らせるという事はないので問題ない。\n\n        開始と終了をそれぞれ記録する。$$.$LINNO でコマンド毎に ID を設定して対応を取る。\n\n    2 記録されたコマンドとは別に bash の履歴で遡れるコマンドのリストを管理する仕組み。\n      こちらは長いコマンドを自由に削除したりできる様にする。\n      倍加したりすると嫌なので枠組み 1 で得た差分に基づいて更新する?\n      差分を取る方法を気をつけないと結局倍加するので、\n      ちゃんと同期して差分を取れる様な枠組みを整理する。\n\n2020-04-09\n\n  * 別の bash の枠組みについて\n    https://github.com/sio/bash-complete-partial-path\n    https://github.com/mgalgs/fuzzy_bash_completion\n    https://github.com/brujoand/sbp\n\n2020-04-02\n\n  * test: テストフレームワークの追加機能\n\n    * 単体テストの機能\n      * テストを直接本体の関数の近くに書き込める様にする?\n        これは mwg_pp.awk の枠組みを用いた対応が必要である。というか出力\n        先が ble.osh と分かれている場合を考えると、#%$> の右辺に変数を指\n        定するべき? と思ったが #%$> を含む行自体をマクロに入れれば良い。\n\n    * テスト集合の管理\n      * 集計・サブシェルで実行した結果も扱える様に。\n      * テスト結果のキャッシュ\n      * 並列テスト\n      * 様々な bash の version の結果を集計\n\n    * 他のフレームワークの機能を確認\n      * bats\n      * oil/test\n      * shellspec\n        kcov を用いて coverage が計測できる\n        skip を設定できる。前回成功したものをスキップできる。\n\n    * GitHub 用に Travis を設定する。\n\n2020-03-22\n\n  * read -t や read line の戻り値が変だ\n    →今試してみると別に変な事はない。-e が入っていても入っていなくても。\n\n    一応 C-c で read -e を止めた時の終了ステータスは 130 の所が\n    ble.sh の実装では単に 1 になっているという違いはある。\n\n  * bash-3.0 が malloc array.c botched というエラーが出てクラッシュした。\n    これは bash のバグである。そして古いバグなので治りそうにない。\n    更に言うと再現性もあるのかどうか微妙である。\n\n  * oilshell で色々説明を行った。\n    それらの説明へのリンクを作成して後で纏めるのが良い気がする。\n    これは後で実行する。\n\n  * decode: 大量の貼り付けの高速化4 (report by dylankb)\n\n    現状の ble.sh の枠組みの中では大幅に改善した。\n    然し、やはり decode を自前でやっている。\n    そもそも decode の結果を整数の列にする時点で遅い。\n\n    bracketed paste だと分かった時点で、\n    stdin から文字列として読み取って、\n    文字列としてそのまま挿入する等の事が可能な筈なのではないか。\n    そうすれば無駄な処理をする事なく即座にエディタを起動できる。\n\n    現在の nonblocking-read の実装に\n    bracketed paste を検出する機能をつけて\n    bracketed paste の処理中にはそれを使って\n    良い感じに実行すれば良いのだろうか。\n\n2020-03-11\n\n  * __line_limit__ の実装の制限\n\n    1 replace-limited を直接呼び出している箇所については確認したが、\n      replace-limited が .replace-range を通して呼び出している時、\n      外側で ind, mark を設定していると計算がずれて範囲外になる可能性がある。\n      特に vi で .replace-range を多用しているが面倒なので細かくチェックしていない。\n\n    2 容量超過でもコマンドラインが短縮されていない場合\n      (これは isearch の途中などで起こりうる)\n      複数のキーから為るキーシーケンスが間に入る __line_limit__\n      によって無効化される。\n\n      これの対処方法として mouse_move と同様に特別に\n      __line_limit__ を keyseq に属さないキーとして取り扱う方法がある。\n      然し、現在ではチェックが非効率になるので対応していない。\n      或いは keyseq に属さない keycode の範囲を定義して、\n      その範囲で判定できる様にするのが良い気がする。\n      (その様なキーは実は沢山ある)\n\n  * history: fish の autosuggestions はファイルが存在しない履歴項目はスキップする (suggested by cole-h)\n    https://oilshell.zulipchat.com/#narrow/stream/121540-oil-discuss/topic/autosuggestions\n\n    うーん。どうやら fish は履歴を保存する時にその時に使った有効なパスも一緒に記録する様だ。\n    Bash はそれを記録しない。という事は ble.sh が代わりに記録する等の工夫をする必要がある。\n    然し、ble.sh が代わりに記録するという事になると履歴の一貫性を保つ為に工夫が必要になる。\n    或いは、ble.sh の履歴を本体として bash の history は全部それを元に再構築する?\n    その様にするしかない気がする。\n\n    或いは cmdinfo:color の実装が完全であれば、わざわざ履歴を見て\n    ファイルパスかどうかを判定しなくても、それが有効な履歴かどうかを判定する事が\n    可能になる。特に cd に関しては簡単に判定する事ができる筈である。\n    という事を考えるとわざわざ実装する必要はないのかもしれないとも思う。\n\n2020-02-02\n\n  * vi mode の時は read も vi mode になっているべきではないのか?\n    と思ったが vi mode にはコマンド実行等の色々と\n    危ない機能も沢山ついているので、寧ろ cmap を使うべきで、\n    然し、cmap を使うのだとしたらそれは殆ど現状の read の様な物だ。\n\n    これはその内に request があるかもしれない。その時に対応する。\n\n    と思ったが既定の readline では vi-map が使える様になっている。\n    コマンド実行等はどの keymap に定義されているだろうか。\n    或いは accept-line や edit-and-execute-command の意味を差し替えられる様にするか。\n    そちらの方が現実的である様な気がする。\n\n2020-01-26\n\n  * progcolor: 非同期で実行できる様にする可能性?\n    場合によっては重い計算が必要になるかもしれないし、\n    実は非同期で実行しても良いのではないかという事。\n\n  * progcolor: redirect の場合にも対応したい\n    実は補完の時にも redirect をプログラム補完しても良いのでは。\n    但し、補完と着色で違うのは補完は一つの単語について呼び出されるのに対して、\n    着色は一度に複数の単語を着色する事があるという事。\n    補完に関しては引数とリダイレクトを別々に処理すれば良いが、\n    着色の場合には一度に処理できる様にしたい。\n\n  * progcolor: here document にも対応したい。\n    here document に対応するコマンドを抽出する事は可能か?\n    →here document は開始部分に対する参照を確か持っていたのでできる筈。\n\n    実際にユーザは何を提供すれば良いのか。\n    ble/cmdinfo/color:XXX を呼び出す様にするのか。\n    然し、それだとそのコマンドの引数が変更される度に、\n    対応する heredoc を抽出する必要が出てくる。それは面倒だ。\n    或いは、heredoc に変更があった時に着色するだけで良いのでは。\n\n    というか heredoc は単語ではない。でも一つの nest ではある。\n    うーん。然し wrange に登録しているかは謎。\n    その辺りも整理しつつ実装すると良い。\n\n  * progcolor: コマンド自身が書き換えられた時には\n    全ての引数について再度着色の確認が必要になるのではないか。\n\n2020-01-23\n\n  * 前々から発生していたが曖昧補完などを実行すると時々ごみが残る。\n    これは何故だろうか。そもそもカーソルよりも右に何か文字列が入るはずがないのに?\n\n    再現させようとしても再現できない。\n    これは実際に起った時に再度確かめる必要があるのである。\n\n2020-01-21\n\n  * lmorg/murex という新しいシェルの対話環境\n\n    https://github.com/lmorg/murex\n\n    このシェルは POSIX 互換でないので微妙。\n    パス名展開をするのに面倒な指定をしなければならない。\n    既存の様々なツールと相性が良いかというと微妙な気がする。\n    しかし fish や PowerShell よりは unix shell よりである。\n\n    一方で対話インターフェイスに関しては色々工夫している。\n    入力していくと一行下に現在入力しているコマンドの説明が表示される。\n    何も入力していない場合は git リポジトリの情報を表示している。\n    (然し、なにか入力するとすぐに消えてしまうので何処まで使いやすいかは分からない)\n    kill まで入力すると補完候補としてプロセス ID を表示してくれる。\n    プロセス ID に対してコマンドラインを説明として表示している。\n\n    * 所で ble.sh ではメニューの形式は事前にユーザの側で指定する事になっている。\n      然し、これは微妙な気がしてきた。というのも説明文があるかどうかの情報は\n      補完生成側が知っている事である。なので、補完候補生成器の側で、\n      メニューの表示形式を上書きできる様にするべきなのではないかという気がする。\n\n2020-01-17\n\n  * Minix で無限ループになっている?\n\n    echo と入力しようとすると確率的に無限ループになる。\n    (それでも可也高い確率で無限ループになる。)\n    auto-complete を off にしても発生する。\n    menu-filter を off にしても発生する。\n    という事は着色か或いは。。\n\n    調べてみると暴走しているプロセスは別の Bash だという事が分かった。\n    恐らく子プロセスで暴走している。何が悪いのだろうか。履歴?\n    →履歴はちゃんとロードできている。その後で暴走する。\n    →再度確かめたらやはり子プロセスの暴走としか思えない。\n      と思ったがよく見ると親プロセスの暴走だった。両方で起こる?\n\n    2020-02-03 新しい ble.sh を実行しているが固まるという現象が再現しない。\n    これは新しい ble.sh のお陰だろうか、それとも偶だろうか。\n    →暫く使っていたが全く再現しないので以前の ble.sh の問題と思って良いだろう。\n\n    と思っていたら実は裏でちゃんと無限ループになっていた。\n    どうも ssh が予期せず切断すると無限ループになる?\n\n    気になるのは暴走していたプロセスは stderr にリアルタイムで\n    データを出力し続けていたという事。\n\n    | -rw-r--r--  1 murase  users  14174140 Feb  3 21:58 5726.stderr\n    | -rw-r--r--  1 murase  users  14324924 Feb  3 21:59 5726.stderr\n    | -rw-r--r--  1 murase  users  14504088 Feb  3 22:01 5726.stderr\n    |\n    | 出力内容は以下の通り 0d 1b 5b 4b の 4B を繰り返し出力している。\n    |   $ < $_ble_base_run/5726.stderr od -t x1\n    |   0000000   0d  1b  5b  4b  0d  1b  5b  4b  0d  1b  5b  4b  0d  1b  5b  4b\n    |   *\n    |   67250220   0d  1b  5b  4b  0d  1b  5b  4b\n    |   67250230\n    |\n    | 0d 1b 5b 4b とは何か? \\r\\e[K である。CR EL である。うーん。\n    | ble.sh の該当しそうな部分を調べてみる。\n    |\n    | * canvas:344 (negative cup:el)\n    |   ble/canvas/put-cup.draw 1 $((x0+1))\n    |   ble/canvas/put.draw \"$_ble_term_el\"\n    | * canvas:1928 (negative sgr0:cr:el)\n    |   ble/canvas/panel#goto.draw \"$index\" \"$x\" \"$y\"\n    |   ble/canvas/put.draw \"$_ble_term_el\"\n    | * edit:1520 (negative sgr0:cr:el)\n    |   ble/canvas/panel#goto.draw \"$_ble_textarea_panel\" \"$fminx\" $((fminy-new_scroll))\n    |   ((new_scroll==0)) &&\n    |     x=$fminx ble/textarea#render/.erase-forward-line.draw # ... を消す\n    | * edit:1680 (negative sgr0:cr:el)\n    |   ble/canvas/panel#goto.draw \"$_ble_textarea_panel\" $((cols+1)) \"$y\"\n    |   ble/canvas/put.draw \"$_ble_term_el\"\n    | * edit:1696 (negative sgr0:cr:el)\n    |   ble/canvas/panel#goto.draw \"$_ble_textarea_panel\" \"${pos[0]}\" \"${pos[1]}\"\n    |   ble/canvas/put.draw \"$_ble_term_el\"\n    | * edit:3869 (negative cuf:sp:sp:el)\n    |   ble/canvas/put-cuf.draw \"$advance\"\n    |   ble/canvas/put.draw \"  $_ble_term_cr$_ble_term_el\"\n    | * edit:7322 (negative cr:el:sgr)\n    |   ble/canvas/put.draw \"$_ble_term_cr$_ble_term_el${_ble_term_setaf[9]}\"\n    |\n    | うーん。何れも関係なさそうな気がする。\n    | もしかして _ble_term_el2 に CR EL が入っている?→確認したがそうでもない。\n    | 上の中で一番怪しいのは panel#goto.draw だと思ったが、\n    | sgr0 が消滅している理由が分からないし、\n    | 一度 CR を出したら _ble_canvas_x=0 になるのだから、\n    | 何度も CR を出力し続けるのは変だ。\n\n    暴走した bash は何れも console ではなくて pty だった。\n    接続が途中で落ちると無限ループになるのだろうか。\n    hp2019 側及び vmminix 側で nc/sshd を kill -9 しても再現しない。\n\n  * 英語圏のニュースサイトに投稿する可能性 (suggestion by dylankb)\n    Hacker News を紹介されたがここが適切なんだろうか?\n\n    reddit に投稿した話がある。\n    https://rcmdnk.com/blog/2014/02/23/computer-bash-zsh/\n\n    単にリンクを貼るというのでも良いけれども。\n    やはり様々な機能を惜しげもなく紹介する\n    長い記事を書くのが良い気がする。\n\n    →返信で自分の作品を投稿する時のルールの頁があった。\n      なるほど。やはりルールがあったのである。危ない所である。\n      https://news.ycombinator.com/showhn.html\n\n      これによると作品の紹介は一度きりしかできないとの事。\n      > The community is comfortable with work that's at an early stage.\n      と書かれているがまさかこれは初期の作品でなければならないという訳でもあるまい。\n      > Blog posts, sign-up pages, and other reading material can't be tried out\n      と書かれているが…。使い方の説明記事の様でも駄目なのだろうか。\n      Blog posts でなければ良い? 或いは README を派手に改造してしまうという手もある。\n\n    https://news.ycombinator.com/shownew\n    ここを観察していると \"Show HN: 作品名 ― 説明\" という名前の物が多いが、\n    実は \"Show HN: 今〇〇なのを作っているんだけど\" というタイトルの物の方が upvote が多い。\n    \"作品名 - 説明\" だといかにも宣伝という感じで入る余地がない気がする。\n    一方で \"〇〇なんだけど\" みたいに書くと \"自分も何か貢献できるんではないか\" と錯覚して人がたくさん来る。\n    そういう仕組になっているんだろうという気がする。\n\n    * reject: \"Show HN: Bash Line Editor -- syntax highlighting, autosuggestions, etc. in Bash\"\n      これは普通。つまらない\n\n    * \"Show HN: I am developing a line editor in pure Bash script. I'd like to hear your comments!\"\n      これだと面白そうとは思ってくれるかもしれないけれど使ってくれる人は少なそう。\n      後 explicit にコメントが欲しい! という事をタイトルに書いても良いのだろうか?\n      眺めてみるとそういう投稿はない。やはり雰囲気が分からないのである。\n\n    * reject: \"Show HN: I made syntax highlighting, autosuggestions, etc. in Bash\"\n      これも普通。つまらない\n\n    * \"Show HN: \"Bash Line Editor\" with syntax highlighting, autosuggestions, ... written in pure Bash!\"\n      やはり宣伝っぽい。\n\n    * \"Show HN: Bash Line Editor -- syntax-highlighting, autosuggestions and vim emulation written in pure Bash\"\n      vim と書くと他のエディタを使っている人やシェルでは別に vim は使わないという人が敬遠してしまわないか?\n      然し話題に乗るという事だけであればその辺りを無視して投稿しても良い気がする。\n\n    * reject: \"Show HN: I wrote a line editor (syntax highlighting, autosuggestions, vim amulation, etc.) in pure Bash script\"\n    * reject: \"Show HN: I wrote a line editor in pure Bash script which provides syntax highlighting, autosuggestions, vim emulation, etc. to Bash\"\n    * reject: \"Show HN: Bash Line Editor written in pure Bash script for syntax highlighting, autosuggestions, vim emulation...\"\n      長い\n    * \"Show HN: Bash Line Editor totally written in pure Bash script\"\n      案外これぐらいの方が気を引けるのかもしれないと思う。\n    * \"Show HN: Bash Line Editor -- a next-generation Bash configuration\"\n      或いはこんな感じに煽った感じのタイトルにしても良い。zplug の真似\n      でも技術的に面白いのは pure Bash script であるという事。\n\n      \"with syntax highlighting, autosuggestions, vim emulation\" 等は書かなくてよい。\n      書かない方が煽りになるのである。本当か? と思ってみんなリンクを開く。\n      そしてどんな機能があるのかとみんな確認する。\n      少なくともこれだけの物があるのだからがっかりする事はないだろう。\n\n      でも落ち着かなければならない。Bash configuration と書くと、\n      従来の PS1 や aliases や functions を包含する物と考えられてしまう。\n      その様に考えると、Bash plugin と書いた方が良いか?\n      或いは、plugin manager として突貫で他の物を取り込める様にするか、\n      或いは README に強調しておくことにするか。\n\n      というか Bash configuration というのが良くない。違う。\n      もっと土台になるものなのである。\n      実のところ \"a next-generation Bash Line Editor\" なのだ。\n      然し line editor という意味では全然 next-generation ではない。普通だ。\n      つまり Bash の設定にしては next-generation なのであって、\n      line editor として next-generation な訳ではない。\n\n      a next-generation Bash interface/infrastructure/extension/framework\n\n      Framework としての側面も強調してよいのかもしれない。\n      (或いは真面目にライブラリとして独立させても良い。\n      decode 部分に関しては大幅に手を入れる必要があるかもしれない?)\n\n    * \"Show HN: I wrote a featureful line editor in pure Bash scripts\"\n      みたいな単純な物の方が気を引けるのではないかという気がする。\n\n    調べるとスタートアップという文字が頻りに見える。\n    投稿してみた感想を観察してみるとやはり何かのお誘いがある様である。\n    タイトルに文字数制限は在るのだろうか。\n\n    何れにしても今は忙しいので沢山の要望などが来てしまっては困る。\n    従って暫くはこのまま放置するというので良い気がする。\n\n2020-01-05\n\n  * Homebrew の設定を作成する?\n\n    先ず Linuxbrew (Homebrew for Linux) を ~/opt/linuxbrew に入れた。\n    普通と違う場所に入れようとしたので色々問題が起こって時間を食ってしまった。\n\n    * brew tap について調べてみる事にする。\n\n      % brew tap akinomyoga/ble.sh を実行すると https でダウンロードしようとする。\n      % brew tap akinomyoga/ble.sh git@github.com:akinomyoga/ble.sh.git とすれば良い様だ。\n      % それから brew install を試そうとするがどうやっても動かない。\n      % どれをやってもそんな formula は見つかりませんのエラーになってしまう。\n      % もしくは tap を確認すらしない場合もある。不思議だ。\n      % $ brew install akinomyoga/ble.sh\n      % $ brew install akinomyogable.sh\n      % $ brew install akinomyoga/homebrew-ble.sh\n      % $ brew install homebrew-ble.sh\n      % $ brew install brew-ble.sh\n      %\n      % $ brew tap\n      % を実行してみると。自分が登録した物の他に homebrew/core がある。\n      % homebrew/core は中に formula を沢山入れた repo の筈である。\n      % もしやと思って調べてみる。\n      %\n      % https://qiita.com/wkentaro/items/d4981582e08b134f1e1d\n\n      どうも user/name に対応して github.com:user/homebrew-name を作成して、\n      その中に formula.rb を入れて置くという事になっている様だ。\n      面倒なのでそれよりは直接 core に取り入れてもらった方が楽だ。\n\n    * 自分で formula を作ってみるのを試す\n\n      仕方がないので自分で formula を作ってみるのを試す事にした。\n      $ brew create --set-name blesh\n\n      全て自分で記入しなければならない様だ。適当に formula を作成してみる。\n      sha256 は何の sha256 を記入すれば良いのか分からないのでコメントアウトする。\n      結局分からないので以下を参考にして埋めてみる事にする。\n      https://github.com/10sr/homebrew-pkg/blob/813de30c121e8dea970f11e7c1e63e57d3a6a0ed/Formula/ble-sh.rb_\n      * ビルドは gawk に依存しているので gawk に依存させてみる。\n      * gmake については調べてみた所 macOS ではデフォルトで GNU make だそうなので不要?\n        然し、mac ではデフォルトで make が入っているのだろうか。\n        或いは自分で追加で入れる必要があったりするのだろうか。よく分からない。\n\n      と思ったが何処にも *.rb が作られていない。\n      $ find ~/opt/linuxbrew/ | grep blesh\n      で調べてみたら ~/opt/linuxbrew/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/blesh.rb\n      に新しく blesh.rb が作成されていた。これを使う事にする。\n      試しに $ brew install blesh としてみたら動き出した。\n      gawk を入れるためにその依存関係まで全てダウンロードしてインストールしようとしている。\n\n    ? brew では自分で何処かで入手した formula を使うにはどうすればよいのか?\n\n    * homebrew-core に登録する為には test を用意しなければならないようだ。\n\n2019-12-31\n\n  * progcolor: 引数の中の着色 (zsh -c '...' の ... の部分)。\n\n    いつか実装しようと思っていたら fast-syntax-highlighting が既に実装している。\n\n    | fast-syntax-highlighting\n    | →引数の中も着色すると思ったら '$(...)' の中も着色を行っている。\n    | 然し、zsh -c '...' に関してはちゃんと zsh や -c を認識して着色している様だ。\n    | 調べてみると awk もちゃんと文法的なチェックを行っている。\n    | (→ うーん gawk --source '...' で文法チェックをできる様だ。)\n    | sed に関しては行っていない。何れにしてもコマンド毎の着色を実現している。\n\n    * コマンド毎の着色設定を指定できる様にした #D1245\n\n    | 次に例えば awk に対応する事を考える?\n    | 或いはそれよりは sh もしくは bash に対応する方が楽?\n    | 色々考えてみたがちゃんと対応するのは可也大変である。\n    | 先ず単語が単純単語でない場合にどの様に実装するか。\n    | 等、色々難しい。既にある文法構造を利用して何とかできる可能性はある。\n    |\n    | awk に対応するとしても awk の様々な実装によってオプションなど異なる。\n    | このオプションが異なっていると異なった着色になって、\n    | ユーザに混乱を齎す。従って対応するとしたら完全に対応している時にだけ有効にする。\n    | 何れにしても面倒である。awk よりは先に bash で対応した方が懸命ではないか。\n    | awk の対応に関しては自分の blerc の中だけに留めておく。\n    | その自分の blerc の中での awk の着色の設定で必要になると\n    | 思われる補助機能をble.sh の方で実装する。\n\n    * awk の着色対応を通じて ble.sh 側で支援の必要な機能を実装する。\n\n    * 単純単語に関して。評価値を求める方法。\n      評価値の各文字が元の単純単語のどの位置に対応するか。\n      或いはその逆? どちらの方が適切だろうか。\n\n      例えば引用符等に関しては対応する文字はないのでそのままの色が良い。\n      従って評価後の文字に対応する評価前の範囲を取得すると良い気がする。\n      然し、逆に評価前の $a が評価後に沢山の文字列になる事もある。\n      その場合には評価後の各文字の色を評価前に割り当てるのは難しい気がする。\n\n    * 対応する物がない文字をそのままの (下の層の) 色にする事は可能だろうか。\n      恐らく getg 等で取得しなければならない。面倒である。\n      或いは ble/highlight/layer:syntax では少し違う様に処理していた気もする。\n\n    * 複雑な単語に関しては文法構造を利用する事も考える。\n\n    * 現在の layer:syntax の枠組みでは一旦着色情報を wattr に格納してから、\n      それを word table に対して適用するという仕組みにしている。\n      この様にする事に何の意味があったのだったか?\n\n      直接 word table に適用した方が早いのではないか?\n      →これは何度も単語着色を求め直すのを省略する為である。\n      つまり、単語着色を決定する部分と実際に適用する部分を分けて、\n      前者をできるだけ省略する様にしている。\n\n      実際に適用する必要がある場合でも前回求めた値を\n      そのまま使えば良い場合があるという事なのである。\n\n  * fast-syntax-highlighting の機能を確認する\n    https://github.com/zdharma/fast-syntax-highlighting\n\n    * コマンド毎の着色。オプションや引数が正しいかのチェックも行う。\n      これは丁度 ble.sh で将来的に対応したいと思っている機能である。\n    * 括弧の対応に応じた着色\n    * gawk --source による文法チェック?\n\n  * theme: 流石に theme を作った方が良い気がしてきた。\n    少なくとも枠組みだけでも作って置くと良い気がする。\n    と思ったが実際に例がないと枠組みの良い設計も分からない。\n    zsh-syntax-highlighting はどうしているのだろうか。\n    zsh-syntax-highlighting theme で検索してみる。\n\n    どうも zsh-syntax-highlighting は theme を提供していない様だ。\n    https://highlightjs.org/static/demo/\n    ここは dark/light の両方を提供している theme があって参考になる。\n    但し、ファイル名着色に使う色は色々調整しなければならないが。。\n\n    fish の theme はあるだろうかと思って探すと。\n    https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md\n    どうもシェル業界では theme というのはプロンプトの事を指す様で。\n    然し、fish のブラウザ設定画面ではタブは colors となっている物の、\n    色々な設定の部分には theme という文字も見える。\n    何れにしても theme というのは紛らわしいかもしれない。\n    注意書きを書いておく必要があるかもしれない。\n\n  * tui: TUI 設定画面?\n    fish はユーザフレンドリーを謳っている。\n    ブラウザで設定できるなど (リモートの場合には使えない気がするが)。\n    ble.sh ではブラウザでなくても TUI で設定画面を用意しても良いのかもしれない。\n    マウスサポートまですればブラウザでなくてもOKなのである。\n\n    →fish の web 設定画面を確認してみた。\n      実は theme と prompt が選べるだけだった。\n      他は関数・変数・履歴・束縛・略語展開の一覧が見えるだけで、\n      何も設定することはできないのだった。\n      但し履歴項目の削除はする事ができる。\n      略語展開も実は編集することができた。\n    →theme に関しては配色が選べるだけで、\n      具体的にどの色がどの意味というのは余り考えられていない気がする。\n      適当に順番に割り当てただけなのではなかろうか?\n\n    その様に考えると履歴の着色でも良いのかもしれない等と。\n\n  * complete: 重い補完関数に対する対策\n\n    * 曖昧補完の為に何度も progcomp を呼び出していて非効率的\n      →無駄があると思ったが実際にどういう補完を行っているか調べると\n      様々な補完点を試しているのだった。うーん。\n      自動補完の補完候補がすぐに見つかる場合にはそんなにたくさん呼び出されない。\n      補完交互が見つからない時には自動補完によって何度も補完が実行されて遅くなる。\n\n      もしかすると自動補完を off にしたいという人は時間のかかる\n      補完関数を使っているという事なのかもしれない。\n      よく考えたら peco の類を設定している場合大変に面倒な事になるのでは?\n      自動補完が実行される度に選択メニューが表示されてしまう。\n      そもそも補完に peco を設定している時点で変ではあるが。\n\n      色々な補完点で試すとしても現在の単語を 0 文字または 1 文字しか\n      入力していない場合には、同じ状態で呼び出す事もあるだろうという気がする。\n      その場合の為に compgen の呼び出し結果をキャッシュする利点はあるだろうか。\n      つまり、同じ補完状態で再度呼び出される事を見込めるかどうかが問題になる。\n\n    * 或いは、処理を非同期で呼び出すというのが良いのかもしれない。\n      その場合には計算結果を何処かファイルに書き出す様にしなければならない。\n\n      非同期で呼び出すのは -CF が設定されているときだけで良い。\n      と思ったが -F の中で環境を変更したいという場合にはどうするのだろう。\n      非同期で呼び出すという事にすると環境に対する変更が適用されない。\n      これは bleopt で変更できる様にしても良いのではないだろうか。\n\n  * complete: menu-complete 中の通常文字挿入は\n    絞り込みに戻すのが良いのではないか。\n    というか普通にキャンセルして挿入すれば絞り込みになるのでは?\n    と思ったが menu-complete 状態からは抜ける事になる。\n\n    後、suffix を挿入せずに確定する方法がなくなる。\n    これについては別の操作方法について考えると良さそう。\n    例えばスペースを押すと suffix 挿入を抑制して確定する等。\n\n    →やはりこれは分かりにくいのではないか。\n      fish, zsh の動作を確認してみたが menu-complete 中に\n      新しい文字を入力すると何れも現在の選択肢を確定させた後に\n      続きの文字が入力される様になっている。\n      これらのシェルと異なる振る舞いをするのは良くない。\n\n      だとすると絞り込みをする為には明示的に\n      絞り込みのモードに入るキーを設定するべきなのでは。\n      例えば M-e 等?\n\n      因みに emacs で試してみると M-e, M-a は end/beginning of\n      sentence 的な動作をしている様に見える。\n      なので上書きしてしまっても良い様な気がする。\n      うーん。でも end of line の代わりに使っている人がいるだろうか?\n\n      因みに現在の ble.sh では M-e は何にも紐付いていない。\n      うーん。M-e を勝手に補完の絞り込みモードに割り当てる事にする。\n      絞り込みモードにいる時にはカーソルの動く範囲と編集範囲を制限する。\n      と思ったが vi の様な複雑なモードの場合にそれを実現することは可能か?\n      移動だけならば __after_widget__ で範囲外に出た時に\n      強制的に範囲内に移動させる事が可能であるが、編集まで入ると困難である。\n      編集を禁止しなければならないがそれは難しい。\n\n      だとすると新しいプロンプトで編集させるというのが現実的だろうか。\n\n2019-12-29\n\n  * color: term_true_colors=auto\n\n    自動判定は難しい。screen-4.99.0 が truecolor on/off\n    のオプションを持っているので実際にユーザが有効にしているかどうかは\n    TERM や DA2 を使っても分からない。結局試しに色を設定して、\n    その色を読み出すという事をしなければ判定できないのだろうか。\n    然し、これも端末によって問い合わせができたりできなかったり\n    (セキュリティ上の都合から)無効になっていたりする気がする。\n\n    以下の優先順位で試すというのが妥当な実装方法の気がする。\n    然し 1 の判定を非同期に行わなければならないので面倒である。\n\n    1. 色を設定して問い合わせる\n\n      http://nanno.dip.jp/softlib/man/rlogin/ctrlcode.html\n      https://qiita.com/kefir_/items/c2bd46728364bdc7470b\n      OSC 10 ; ? ST で前景色RGB問い合わせ、\n      OSC 11 ; ? ST で背景色RGB問い合わせの様である。\n      応答は OSC 10 ; \"rgb:rrrr/gggg/bbbb\" ST の形式?\n\n      よく考えたら現在の実装では ESC-[ (CSI) しか特別扱いしていない。\n      これに対応する為には \"ESC ]\" (OSC) についても処理する必要がある。\n      これは ble-decode-char/csi/consume の辺りを拡張する必要がある。\n      特に BEL または ST (ESC \\) で終端する様に処理を書く事に注意する。\n\n    2. DA2 を元に判断する\n      然し https://gist.github.com/XVilka/8346728 のページには\n      各ターミナルの対応 version が書かれていないので使えない。\n      自分で調べ上げるしかないのだろうか。\n\n    3. TERM を元に判断する (*-24bit *-24bits *-truecolor)\n    4. terminfo を元に判断する (setf24, setb24, tc, RGB)\n\n2019-10-21\n\n  * ずっと起動していると段々と遅くなっていくのは何故か。\n\n    Ubuntu bash-4.3 (song437) で動かしていて気づいた。\n    bash として新しく起動すると速い。\n    ble-update や ble-reload をしたり、\n    ble-detach / ble-attach しても直らない。\n\n    カーソル移動だけでも遅くなって行くので描画が関係しているとは思われない。\n    また、reload しても直らないという事から考えられる事は何か。\n    履歴がどんどん溜まって重くなるという事でもない様な気がする。\n\n    或いは変数のアクセスが遅くなって行くという事なのだろうか。\n    変数に代入するスクリプトを回してみたが特に遅いという事はない様だ。\n    (それにそもそも使用している時間に比例して変数が増えていくという物でもない)\n\n2019-09-24\n\n  * ble.sh で export PATH=aaa:bbb:ccc で最後の部分しか着色されない。\n    それぞれ着色するべきなのではないか。\n\n2019-09-22\n\n  * complete: = を含むファイル名を補完すると = 以前の部分が重複して挿入されてしまう。\n\n    →今確かめてみると再現しない。\\= としていても = としていても同じ。\n\n    2019-12-31 ./configure の引数で --prefix= を補完している時に\n    = が \\= になったり --prefix= も丸ごと置換されたりなど変な動作をする。\n    一方で、complete -r で progcomp を消してやると変な事は起こらない。\n    これは要するに progcomp の仕様の微妙な違いに起因して変な事が起こっている。\n\n2019-07-16\n\n  * complete: パス名展開で複数語に展開される場合の補完に関して\n    現在の実装ではパス名展開が起こったとしても展開された最初のファイル名を使って補完を実行する。\n    然し、実際には展開された各パス名について補完を実施しても良いのではないだろうか。うーん。\n\n    更に failglob の場合には続きを入力したら一致したかもしれなくても常に展開に失敗してしまう。\n    というか現状でそもそも failglob だった時にそれを検出しているのかどうかすら怪しい。\n    確認する必要があるのである。\n\n    既に COMPV には複数の値が入る仕組みになっていた。\n    それならばと COMPV に入っている値の数だけ source を呼び出せば良いのかと考えたが、\n    実際に試してみると全く同じ候補が何度も生成されるだけに終わってしまった。\n    よく考えたら progcomp では独自に展開を行っていたのではあるまいか。\n    調べてみたらやはりそうである…。これに対応するのは面倒である。\n\n    或いは複数語に展開される場合には先ず始めにその内のどれか一つに絞らせるという可能性もある?\n    然しそれはそれで不便な気もする。\n\n2019-07-09\n\n  * history.mlfix: bash-3.0 で実現する方法?\n    history -s が使えないので複数行の履歴を登録する事が不可能である。\n\n2019-07-02\n\n  * menu: 複数選択を可能にしても良いのではないか\n    C-@ で toggle をする等。抜ける時に全てを挿入する?\n    然し使いみちがよく分からない。使いたくなったら追加するというので良い気がする。\n\n2019-06-18\n\n  * history: interactive な history 編集に対応できたらする\n    つまりメニューを表示して其処で選択したり削除したりする。\n    検索などもできる様にする。遅延で着色をする。\n\n    core-complete に実装されている既存のメニューの枠組みは、\n    menu item を配列に格納する。従って容量を食う。\n    更に重そうである。これは独自に新しく実装した方が良いだろうか。\n\n2019-05-27\n\n  * 次に機能を追加するとしたらマウスなのだろうという気がする。\n    fish は未だマウスに対応していない。\n    zsh はそういう拡張があるらしいがちゃんと動くのかは知らない。\n\n    zsh extension: https://unix.stackexchange.com/questions/444601/any-terminal-shell-with-mouse-support\n    fish suggestion: https://github.com/fish-shell/fish-shell/issues/4918\n    question: https://superuser.com/questions/322367/are-there-any-unix-shells-that-support-mouse-reporting\n\n    マウス対応の問題点はマウスが有効になっていると、\n    従来の端末に対するマウス操作(端末に表示されている内容のコピー・ペーストなど)が使えなくなる事である。\n    端末に表示されている内容まで全て ble.sh の管理下であればそういう事もできたかもしれない。\n\n    部分的なサポートとして何らかのモードに入っている時だけマウスを有効にするというのはあるかもしれない。\n    例えば補完のメニューを出している間だけ、など。然し、それもなかなか分かりにくい気はする。\n    或る特定の範囲だけでマウスを有効にするという制御機能があった様な気がする。\n    それが使えればそれを使ってマウスを有効にするというのが可能になる気がする。\n    何れにしてもこれは考察が必要になるのである。\n\n    2019-07-22 どうも既存の端末では Shift を押しながら操作すると\n    Mouse report ではなくてローカルでの端末上でのマウス操作になる、\n    というのを採用している物が多い、という話を何処かで見かけた。\n    何処で見掛けたかは忘れたし実際にそうなのかの確認はしていないが。\n\n2019-04-21\n\n  * 実は背景色を判定する方法はなくはない様だ。\n    https://qiita.com/kefir_/items/c2bd46728364bdc7470b\n    しかしそうだからと言って暗い背景用に配色を調整する必要があるので、\n    それを実行するまでは対応しても仕方がないかもしれない。\n\n    % というか、調べていたら DECSCNM (SM/RM(?5)) が背景が暗いか明るいかの設定の様だ。\n    % という事は DECRQM して DECRPM を受け取れば普通に背景が明るいか暗いか分かるのでは。\n    % そして Poderosa や screen の側でもそれを設定すれば良かったのではないか…。\n    % と思ったが xterm は明るいか暗いかが反転している。\n    % つまり、DECSCNM は飽くまでその端末の既定の背景と比べて反転しているかどうかしか分からない。\n    % 既定の背景色が明るいか暗いのかの情報は取る事ができない。\n\n    一方で、背景色の問い合わせで返ってくる色が DECSCNM の影響を受けるのか\n    は気にして置かなければならない。\n\n2019-03-23\n\n  * menu: alias select='while myselect $# \"$@\"' 等として select を上書きできるのでは\n\n    というか現在の ble.sh で select を実行すると悲惨な事になる気がする…。\n    と思ったが select は別に readline は使っていない様子だ。\n    元の bash でも全然行編集できない感じの入力になっている。\n    なので現状で問題が発生しているという訳でもない。\n\n    もし置き換える事ができるのであれば便利かもしれないという程度である。\n\n  * menu: 今後の拡張性\n\n    * 因みにフィルタリング機能は menu-filter を統合・整理する形で実装したい。\n      フィルタリング文字列の入力に関しては isearch や iswitchb の様な、\n      単に文字を入力するか BS で戻るかだけしかできない様なものでも良い事にする。\n\n      フィルタリングに関してはフィルタリングを実行する関数と、\n      フィルタリングを誘発する為の機能を分離して実装する事にする。\n      既存の menu-filter の機能は自動的にフィルタリングを呼び出す。\n      明示的なフィルタリングの場合には keymap にフィルタリングを紐付ける。\n\n    * cdhist では更にリスト編集機能までついている。\n      つまり項目を並び替えたり削除したりと言った事ができる。\n\n      うーん。これをどの様に返すかは微妙かもしれないが、\n      _ble_complete_menu_items にある物を呼び出し元で参照してもらうというので良い気がする。\n      或いは callback でどの様に並び替えたかを返すという手もあるが分かりにくいだろうか。\n      両方という事で良い気がする。使う側で便利そうな方を選んでもらう。\n      どの様に並び替えたかの操作が欲しければ callback を使うし、\n      最終的な結果だけ欲しければ _ble_complete_menu_items を参照してもらう事にする。\n\n    * callback という事で思ったが、実は accept だとか cancel だとかも\n      全て menu_class 経由で定義した方が良いのではないだろうか。\n      一つずつ全て callback を変数に設定していくのは面倒である。\n      更に、並び替えの callback だとかどんどん増やしていくと際限がない。\n\n2019-03-22\n\n  * menu-filter の使い心地が微妙なのはもしかして\n    menu-complete を実行中に絞り込みができないからなのではないか。\n    現在は menu-complete を実行している途中に入力をするとその場で確定してしまう。\n\n    では bash の振る舞いはどうなっているだろうか。\n    確認してみた所、bash の menu-complete はもうその場所に挿入してしまう。\n    そして文字を入力すれば続きに挿入される事になる。\n\n    現在の ble.sh の振る舞いはどうだろうか。\n    その場で入力すると addtail 等の処理をせずにいきなり続きから入力されてしまう。\n    少なくとも addtail ぐらいはするべきなのではないか。\n    また、絞り込みを実行しても良いのではないかという気もする。\n    然し、それでも何か違う様な気がする。\n\n    絞り込みの入力欄と現在選択されている内容というのは別に一致している必要はない。\n\n2019-03-19\n\n  * complete: 実装されていない補完関連の rlvar は以下の通りである。\n    実際に対応するかどうかも含めて考察する必要がある。\n\n    - set completion-map-case off\n    - set disable-completion off\n    - set expand-tilde off\n    - set horizontal-scroll-mode off\n    - set page-completions on\n    - set completion-display-width -1\n    - set completion-prefix-display-length 0\n    - set completion-query-items 100\n\n    うーん。これらの設定は bash の既定値では余り便利ではなかったりする。\n    ble.sh で折角実装してもユーザに使ってもらえないのでは仕方がない。\n    それならば最初から ble.sh の bleopt として提供してしまった方が良いのでは。\n    元々 bash を普通に使っていて設定している人の為に、\n    bash の規定値と異なる値を敢えて選択している時に限り\n    ble.sh でその効果を再現する様にすれば良い。\n\n2019-02-09\n\n  * main: --attach=prompt の問題は何だったか\n    ref #D0940\n\n    何か問題があって現在はこれを使っていないが、それは何だったろうか。\n    何処かに記録されていて良い筈なのに何処にも記述がない。\n    対応した時の記録は #D0737 にある。\n    動かしてみた所、ちゃんと動いている様に見える。\n\n    →恐らく、先ず古い ble.sh の version では使えないという事。\n      それから PROMPT_COMMAND を上書きすると使えなくなってしまうからという事。\n      ユーザに PROMPT_COMMAND を設定しないように要求するのは面倒である。\n\n2018-09-21\n\n  * [保留] 2018-09-15 complete: 文脈の変更範囲で end0 だけ負になるバグ (ref `#D0818`)\n  * [保留] 2018-09-11 complete: 端末が操作を受け付けなくなるバグ (ref `#D0817`)\n\n2018-08-16\n\n  * complete: オーバーレイによる実装?\n\n    現在の実装では仮挿入しているが、\n    これによって現在の入力内容でエラー着色するべき所が、\n    補完が実行された後の着色になってしまっていて、\n    補完前の現状でエラーなのかどうなのかが判別できなくなっている。\n\n    やはり仮挿入ではなくて overlay で実装するべきなのではないか。\n    しかし overlay の仕組みを実装するのは面倒である。\n    どの様な仕様にするのが良いのかの吟味から実装まで。\n    しかし、これについては後回しで良いだろう。\n\n    以下に仮入力の4種類の方法について言及がある。\n    https://mattn.kaoriya.net/software/vim/20170905113330.htm\n\n    リンク先は消えている。web archive のリンクを追記 (2018-09-23)。\n    https://web.archive.org/web/20110630165743/https://www.mozilla-japan.org/projects/intl/input-method-spec.html\n\n    * 2018-09-23 自動補完時の着色について\n      cmplstofB さんからも指摘があった。\n      https://github.com/akinomyoga/ble.sh/issues/5\n\n      自動補完の候補文字列は実際に挿入しているので構文着色に影響を与える。\n      \"現在の内容\" で着色するべきなのではないか、ということ。\n      そうしないと例えば今入力したコマンドが実際に存在するコマンドなのかどうかが分からない。\n\n2018-08-05\n\n  * edit: set blink-matching-paren on に相当する機能\n    対応するならカーソル移動ではなくて着色でやった方が良い。\n\n    | 括弧の対応と region が両方走っていると分かりにくい。\n    | 既に region には複数箇所を highlight する機能がある。\n    | そういう意味で region を使うという手もある。\n    | と思ったが、分かりにくい問題に関しては region の方を上に配置すれば良い。\n    | 複数箇所を highlight する機能は実装を参考にするだけで良い。\n    | 論理的には全く異なる (region は _ble_edit_mark を参照する) し、\n    | それぞれ独立に on/off する事を考えれば別の highlighter にするべき。\n\n    region の複数箇所着色の実装を参考にする可能性も考えつつ、\n    region とは独立な highlighter にしたい。\n    その時は region の一つ下の層に挿入したい。\n\n    また対応する括弧はどの様に検出するのが良いだろうか。\n    やはり文法構造を参照する実装にするしかない様に思われる。\n    しかし、括弧の対応には色々ある。引用符の対応、\n    括弧の対応、if then else などのキーワードの対応、\n    ヒアドキュメントの始まりと終わりの対応である。\n    それらは必ずしも記録されていないし、また、記録されているとしても\n    様々な形式で記録されている。取り敢えず一番簡単な対応として\n    nest に記録されている物を着色するというのが良さそうである。\n\n    2023-03-26 https://github.com/akinomyoga/ble.sh/discussions/308\n\n    対応する request が来た。うーん。もっと最近にも関連した考察をした気がするが、\n    メモに記録があるかどうかは覚えていない。\n\n2018-07-29\n\n  * complete: メモ\n\n    - 生成候補のキャッシュを行うとすれば source 内で実装するべきである #D0705\n\n2018-07-19\n\n  * ble-decode: 'set convert-meta on' 的な操作\n\n    ref #D0699 (LANG=C bash で ble.sh をロードすると全く操作できない)\n\n    ble.sh の内部環境では set convert-meta off にしているが\n    (そうしてないと特殊文字の受信時に無限ループになる)、\n    外部環境で set convert-meta on だった時に、\n    それをエミュレートする様な動作を行っても良い。\n\n    外部環境における set convert-meta の状態は\n    変数 _ble_term_rl_convert_meta_external に記録してある。\n\n  * 現在の `LC_CTYPE` で表現できない文字を入力した時の `self-insert` の振る舞い\n\n    ref #D0699\n\n    self-insert で入力するのは逆符号化したバイト列であるべきでは?\n\n    というのも LC_CTYPE が正しくない場合でもファイルシステムのファイル名などは\n    そのまま謎の文字列として取り扱われるからである。\n    然し逆符号化したバイト列は文字列として正しくないかもしれない。\n    逆符号化したバイト列を更に一バイトずつ現在の LC_CTYPE に変換すると意味がない。\n\n    これは文字列を編集などしようとすると分からない事になりそうなので、\n    取り敢えず現段階では \\u???? を出力するという現状の振る舞いを維持する。\n    後で落ち着いてから再考する事にする。\n\n    以下の c2s 使用箇所は一貫している必要がある。\n\n    ble/widget/self-insert 編集文字列の入力\n    ble/widget/vi-command/search-char.impl/core 検索文字列の入力\n    ble/widget/vi_xmap/visual-replace-char.hook 置換に使う文字の入力\n    ble/lib/vim-surround.sh/get-char-from-key 囲み文字の入力 (あらゆる遅延入力)\n\n2018-02-21\n\n  * vi-mode: nmap (, ), {, }\n\n    カーソルを N 文元に戻す or 先に進める。N 段落元に戻す or 先に進める。\n\n    これは operator:d,c で \"- ではなく \"1 に記録するという例外の対象であるので、\n    対応したらその例外のリストに登録する必要がある。\n\n    2020-08-27\n    https://www.youtube.com/watch?v=hIJh-KlQ7io\n    この動画で zsh/bash の vi mode に (){} がない事を嘆いている。\n    然し、\"文\" をどの様に定義するのか。文法的なコマンドで定義するのか、\n    或いは、元の vim と同様に . の位置で判断するのか。\n    シェルの機能としては . の位置で判断するのは使いようがない。\n    一方で、シェル文法の . で移動する様にすると\n    vim に使い慣れた人に取っては混乱の元である。\n\n2018-02-12\n\n  * [保留] vi-mode: operators 保留項目 [#tmp0002]\n\n    * 領域折り畳み zf には対応しない。\n\n    * gq の formatexpr, formatprg には未対応である。\n\n2018-02-11\n\n  * [保留] keymap/emacs: 連続する delete-backward-char の場合 undo の記録をまとめる可能性?\n\n    現状では一文字ずつ記録しているので一文字ずつ undo される。\n    現在の振る舞いの方が良いのか emacs と同様にまとめた方が良いかは微妙な所である。\n\n2017-11-21\n\n  * syntax: for^J で改行にエラーが設置されるが見えない [#T0005]\n\n    改行のエラーは何らかの方法で見える様にするか、\n    或いは、改行位置にエラーがある様な時は、\n    その前の文字でエラーが発生する様にチェックを行うべき。\n\n    Note: これは端末によっては表示されたりする。端末による。\n    エラー着色はどの様に行われているのか。for の後には FARGX1 に入る。\n\n    これは ble-syntax:bash/ctx-command/.check-delimiter-or-redirect の冒頭部分が怪しい。\n    と思ったが FARGX1 に関してはチェックが入っていないのでやはり関係ないだろうか。\n    うーん。調べるとやはり文法レベルでの着色になっている。\n\n    2019-03-11\n\n    | rps1 で表示している時に EL を空白で代替していると、\n    | 改行の着色が空白に反映される。これでも良いような気がしてきた。\n    | 然し、右側が全て着色されるというのもうるさい。\n    | 最初の1文字だけ着色して SGR(0) するかと思ったが、\n    | そうするとその次にある文字の着色も消えてしまう。\n    |\n    | それの対策のために _ble_textmap_ichg があるのでは。\n    | と思ったが、実装を見てみると違っている様に見える。\n    | _ble_textmap_ichg は着色の調整に使っている事は確かだが、\n    | _ble_textmap_ichg に登録されている文字の着色を計算しているのであって、\n    | _ble_textmap_ichg に登録されている文字の次の文字の着色は計算していない様に見える。\n    | うーん。_ble_textmap_ichg は他の箇所では全く使っていない。\n    |\n    | そうだ。思い出した…。_ble_textmap_ichg に登録されている文字は、\n    | 配置の場所によって中身が変わるので、shift が使えないという事だった。\n    | 特に、中身が変化している場合には文字を取り出して変更を行うのだった。\n    | では以前 ichg に登録されていて、現在位置では ichg に登録されていない文字はどうなるのか。\n    | と思ったら既定の文字形は別の所で決定されている様だ。\n    | ble/highlight/layer:plain/update/.getch である。\n\n    a 右側の1文字だけ着色される様にする?\n\n      x 問題点はコピーペーストした時に必ず余分な空白が入る事である。\n        これは右側の全てを着色させる場合にも同様の問題が生じる。\n\n        また、エラーが有る時にだけ (着色の必要がある時にだけ)\n        右側に空白を入れるという方法もある。\n        しかし、その為にはその位置にエラーが有るのかないのかを\n        外部から取得しなければならない。\n\n        ble/textmap#update は edit.sh だとかの仕組みに依存しない、\n        独立した枠組みにしたいので余り変な機能は取り付けたくない。\n\n      x また実装上の問題点として、rps1 が表示されている時に、\n        _ble_term_ech を使わない場合、2文字目以降の空白文字を SGR(0)\n        でクリアしなければならない事である。この場合、\n        改行の次の文字の SGR を復元する為には…\n\n        _ble_textmap_ichg に次の文字の番号も追加するか、\n        或いは現在の改行文字の SGR 状態を復元する必要がある。\n        しかし textmap の処理をしている間は、\n        未だ着色が完了していないので SGR 状態を取得できない。\n\n        或いは着色部分だけ textmap#update よりも前に持ってきても良いのだが、\n        その様にしたとしても色情報を textmap#update に伝達する手法が必要である。\n        例えば getg なる関数を textmap#update から呼び出してもらう事にするのか。\n        或いは呼び出す関数名も外から指定できる様にするのか。\n\n    b やはり改行の前の1文字を描画時に強制的に着色するという手もあるのではないか。\n      と思ったが…エラー着色だけ特別扱いするというのも変な話である。\n\n    c その様に考えると初めから改行にはエラー着色はしないというのが正しい気がする。\n\n      改めて調べると ble/syntax:bash/ctx-command-compound-expect がエラーを設置している。\n      うーん。for だけの問題では無い様である。他に select, case の時にも同様である。\n\n      ('for'|'select'|'case')\n        [[ ${text:i:1} == $'\\n' ]] &&\n          ((_ble_syntax_attr[i-1]=ATTR_ERR))\n        case $word_expanded in\n        ('for')    ((ctx=CTX_FARGX1)) ;;\n        ('select') ((ctx=CTX_SARGX1)) ;;\n        ('case')   ((ctx=CTX_CARGX1)) ;;\n        esac\n        processed=begin ;;\n\n      実際に上記の様にして見たら見える様になった。\n      しかし rps1 が有効になっている時はやはりうるさく感じられる。\n      また端末に依っては rps1 が無効になっていても行全体が赤く着色される。\n      そういう端末 (mintty など) どういう発想なのかはよく分からないが…。\n\n      更に here documents も行末にエラーを設置する。\n      これについても対策したいが、here documents に関しては、\n      nest の終端がない事によるエラー着色である。\n      これは nest の範囲を変更しないと着色を変更できない。\n\n      何だか中途半端な実装の気がしてきたので取り敢えずこの変更はなかった事にする。\n\n    d うーん。右側の内容の消去は実は改行文字を使って行うのではなくて、\n      描画した後に消去するという方法にした方が良いのだろうか。\n      しかし、その様にすると、今度は urange の中にある行末というのを列挙して、\n      それから各行末について位置を計算して実行するという事をしなければならない。\n      textmap さえあれば指定範囲内の行末は二分法によって特定する事が可能である。\n      しかし面倒である事に変わりはない。もっとまともな方法はないのだろうか。\n\n    結局実装の面倒さを考えなければ三種類の仕様が考えられる。\n\n    a 右側に1文字赤く表示する\n    b 行末まで赤く表示する\n    c 行の最後の文字を赤くする\n    d 表示されなくても気にしない\n\n2017-11-09\n\n  * complete: 候補の優先順位? 例えば拡張子でフィルタすると絞りすぎることがある。\n    拡張子の要件を満たすものを先に表示して、満たさないものを後に表示する。\n    満たさないものに関してはサブ候補として、TAB による接頭辞挿入には寄与しない。\n\n    2018-07-28 候補間の優先順位をつける可能性。\n    weak な優先順位は、候補を表示する時の順序。\n    strong な優先順位は、候補絞り込みの際に一番優先順位の高いものが一つしかない場合にはそれに確定する。\n\n2017-11-05\n\n  * vi-mode\n\n    :help 関連の気になること:\n\n    - v_p v_P: Implementation details に書かれている処理の順序は実際は逆\n    - exclusive-linewise: ここの inclusive/linewise になる条件の記述は曖昧だし全く合っていない\n    - star: vim-jp の文書だと WORD と書いてあるが、振る舞いは word (しかも \\<\\> で囲まれる) に近い\n\n    振る舞いで気になること\n\n    - i<C-o><C-c> とすると普通のノーマルモードに移行したように見えるのに、\n      モード表示は -- (挿入) -- のままである。これは何故だろう。\n      ble.sh ではノーマルモードに完全に移行する。\n\n    - qa<C-c>q とすると ^C が二重に記録される。これは何か?\n      ble.sh では単に ^C は入力された通りに一個だけ記録する。\n\n    - C-v <bracketed paste> では矩形挿入にするべきなのではないか。\n      ble.sh では矩形挿入を行う。\n\n\n2017-11-03\n\n  * vi-mode (registers): 各種特殊レジスタの対応\n\n    http://vim-jp.org/vimdoc-ja/change.html#registers\n\n    - done: \"% は現在のファイル名を保持するが、これは $HISTFILE の内容を返す事にした。\n\n    - done: \": は一番最後のコマンドラインの内容である。\n    コマンドラインを入力し途中でキャンセルした場合などには記録されない。\n    空のコマンドラインで確定した時にも記録されない。\n    コマンドが入力された場合は、それが存在しないコマンドであっても記録される。\n    コマンドが実行されている途中では未だ設定されていない。\n    つまり、そのコマンドが実行された後で値が設定される。\n\n    - \". は挿入モードで挿入された文字列を保持する。挿入モードから抜ける時に記録すればよいだろうか。\n    と思ったが説明をよく読んでみるとそういう振る舞いという訳でもなさそうだ。\n    よく分からないので実際に動かして試してみる必要がある。\n\n    - \"# は代替ファイル (副ファイル) の名前だそうだが何か良くわからない。\n    C-^ の動作と関係しているそうだ。これは未だ実装しない。\n\n    - \"= これは複雑だ\n    - \"* \"+ \"~ これは GUI で選択した範囲を表すものだそうだ。\n\n2017-10-31\n\n  * [保留] vi-mode (_ble_keymap_vi_REX_WORD): Unicode categories?\n\n    Bash の正規表現 (<regex.h> ERE) で対応するのは難しい。\n    また必ずしも Unicode (UTF-8) で実行されるとは限らない。\n    現在は UTF-8 しか対応していないが枠組みとしては\n    別の文字コードにも対応できる余地は残して置きたい。\n\n2017-10-12\n\n  * vi-mode まだ対応していない・考えていないコマンドを列挙する\n\n    意外とそんなに残っていないようなので。\n\n    * nmap: C-^ '括弧 `括弧\n      C-t C-] M Q ZZ ZQ do dp { }\n      [{char} ]{char} z{char} C-w{char}\n      g<C-a> g<C-g> g<C-h> g<C-]> g# g* g$ g&\n      g` g' g+ g, g- g8 g; g< gD gH gN gP gQ gT gV\n      g] ga gd gf gF gh gn gp gq gs gt gw gx g@\n\n  * [保留] vi-mode: xmap <C-]>\n\n    % <C-]> なる物は今見ても存在しない。vivis https://qiita.com/b4b4r07/items/8db0257d2e6f6b19ecb9\n    % 辺りに在ったものかとも思ったが、ない。zsh-vimode-visual を見てもない。\n    % vim で C-] としてもベルが鳴る。何かの間違いで C-[ を C-] と書いてしまっただけなのかもしれない。\n    % と思って改めて vimindex を見ていたら実はあった。\n\n    C-] で \"選択した文字のタグ\" へジャンプと書かれている。\n    タグとは何だろうと思ったら http://vim-jp.org/vimdoc-ja/tagsrch.html に説明がある。\n    ctags のタグと同じものと思って良さそうだ。因みに :help ... で表示されるのもタグの様だ。\n    またノーマルモードの C-] はカーソル位置の単語を \":ta\" で検索と書かれているが、\n    実質 xmap の時と同じことのようだ。\n\n    % これについてはシェルの操作としてどの様な意味を持たせるのかというのは微妙な所である。\n    % 履歴項目のブックマーク的なものとして利用することはできるかもしれない。\n    % しかし、既にコマンドラインに入力されている文字列を元にジャンプをするとなると矢張り微妙だ。\n    % 唯一意味がありそうなのは、指定した単語がコマンドライン上で定義された\n    % シェル関数だった時にそこにジャンプするという物だが…本当に需要があるのかは微妙である。\n    % しかし、シェル関数の定義を確認したいのであれば寧ろ command-help を呼び出せば良い。\n    % シェル関数を修正するという目的ならば使えるかもしれない。\n    % 然し、必ずしもシェル関数をコマンドラインで定義したとは限らないし、\n    % 該当するファイルがあったとしてもそれをコマンドラインで表示する訳にも行かない。\n\n    既に入力した文字列に対応して適切な履歴項目またはコマンドライン中の文字があればそこにジャンプする。\n    例えばシェル関数を定義した履歴項目に跳んだり、変数名から declare に移動するなど。\n    そういう機能でまともそうなのが定義できればそれを実装する。\n\n2017-09-18\n\n  * vi-mode: operator = [#tmp0001]\n\n    :help = を見ると (設定 equalprog || 内部関数 C-indenting, lisp || 外部コマンド indent) が使われるそうだ。\n    但し、indentexpr が非空白の時、indentexpr が使われる (参照: indent-expression)。\n\n    インデントの規則について調べる。\n    先ず初めに空行 (空白だけの行) を隔てて前の行に括弧がある場合には、\n    それを考慮に入れて初めのインデントが決定される。\n    空行を隔てて前の行がインデントされていればそれを継承する。\n\n    結局空行を隔てた前の行のインデントまたは最後の括弧の位置を継承するということ?\n\n    また括弧の種類は () しか見ていない {} や [] は見ていないようだ。\n    デフォルトが lisp だからだと思われる。\n    これは実のところシェルに適したインデントを実行するようにするべきなのだと思われる。\n    しかしながらシェルのインデントはかなり面倒くさい。\n    特に if, then, else, while, do, done 等については現在の解析では状態を記録していない。\n\n    関連してコマンドが閉じていない時 RET を押すと改行挿入にするという物がある。\n    この機能を実装する為にも現在の入れ子の状態を調べる仕組みが必要になる。\n    RET で改行挿入にする機能のほうが幾らか単純なので、\n    それを先に実装してからこれを実装する方が良い気がする。\n\n  * vi-mode: 関連して [/ 等の実装についても調べたい。\n\n    既に vim-surround.sh で類似の機能について実装したが、\n    [/ についても個別に実装したい所である。\n\n    他にテキストオブジェクトで [{ [} [( [) などと同等の機能も実装している。\n\n    [# [' [( [* [/ [` [D [I [P [p [[ [] [c [d [f [i [m [s [z [{ [<mouse2>\n    ]# ]' ]) ]* ]/ ]` ]D ]I ]P ]p ][ ]] ]c ]d ]f ]i ]m ]s ]z ]} ]<mouse2>\n\n  * vim-surround: ds cs インデント\n\n    surround.vim では改行が絡むとき = によるインデントを実行している。\n    現在 vim-surround.sh ではインデントを実行していない。\n\n    2017-10-09 追記\n\n    yS ySS でもインデントは起こる様である。\n    更に、xmap S でもインデントを行う (xmap gS はインデントは行わない)。\n\n2017-09-17\n\n  * cmplstofB: ビジュアルモード・選択モード?\n\n    関連 #D0672 選択モード対応\n\n    * テキストオブジェクトで範囲を選択し、また範囲を拡大する。\n\n      どうやらテキストオブジェクトの拡大では左右の両端からの拡大を試みるような気がする。\n      決して右端からテキストオブジェクトを拡大するというわけではないようだ。\n\n      というのも変なところから初めて (...) の中に右端を移動して、\n      その上で ib としてもエラーになるからである。或いは短くなる。\n      どうも ib の動作としては左端から外側の ( を見つけて、\n      それに対応する ) を右端に直すようである。\n\n      うーん。これはテキストオブジェクトによって動作が異なるのかもしれない。\n      aw などは明らかに右に向かって拡大を行っている。\n      因みに矩形選択かどうかは気にしないようだ。\n      同じ動作をする。行の右端に行くと次に次の行に普通に移動する。\n\n    2018-02-22 現状の xmap におけるテキストオブジェクトの状況について整理する。\n    - ble/keymap:vi/text-object/word.impl に於いては既に xmap での振る舞いに対応している様子である。\n    - ble/keymap:vi/text-object/quote.impl は明らかに対応していない→対応した #D0670\n    - ble/keymap:vi/text-object/block.impl も対応していない→対応した #D2095\n    - ble/keymap:vi/text-object/tag.impl も対応していない\n    - ble/keymap:vi/text-object/sentence.impl も対応していない\n    - ble/keymap:vi/text-object/paragraph.impl も対応していない\n\n2017-09-16\n\n  * cmplstofB: vim-surround.sh: ds cs cS yS ySsd ySSd S gS 'C-s' 'C-g s' 'C-g S'\n\n    現在のところ特に要望は出ていないが ds cs あたりは使いたくなるのではないかと思われる。\n    → ds cs に関しては要望が出たので対応した。\n    → cS yS ySs ySS vS vgS にも対応した。\n\n    残っているのは imap <C-s> <C-g>s <C-g>S のみである。\n\n2017-09-15\n\n  * cmplstofB: here string 候補について\n\n    here string 候補にファイル名以外のものがあれば対応する。返信待ち → やはり候補は難しい。\n\n    コマンド名に応じた補完関数の設定を可能にする?\n    例えば python3 に対する here document の場合には、import を補完候補に出すなど。\n\n    2018-10-02 C++ の場合にはこんな感じに clang を呼び出せば良い様だ。\n    clang -cc1 -fsyntax-only -code-completion-at=test2.cpp:7:7 test2.cpp\n    http://d.hatena.ne.jp/ohtorii/20110319/1300514225\n\n    Here document で補完候補を出す為には、\n    Here document の内容 (先頭から現在位置まで) が\n    単純内容 (単純単語に近いがシェルの特殊文字を使える) でなければならない。\n    その為の関数を追加する必要がある。simple-word の実装を真似れば良い。\n\n2017-08-19\n\n  * [保留] cmap/default.sh: \"CAN @ ?\" 代替?\n\n    \"CAN @ ?\" は \"C-x C-x\" と較べて曖昧ということで現在無効にしている。\n    これの代替キーシーケンスを定義しても良いかもしれない。\n    といいつつ現実の端末に存在するものを登録しなければ意味がない。\n    (そういう意味では \"CAN @ ?\" もこれに対応する現代的な端末が実在するのか怪しいのであるが。)\n\n    思うに s-x だとか H-x だとか A-x を送りたければ CSI 2 7 ; ... ; ... ~ を使えば良い。\n    何故 Emacs が \"CAN @ ?\" に対応しているのかは謎である。\n\n    →実はこれは isolated esc と同じ方法を用いて区別して受信可能かもしれない。\n    しかし、何れにしても \"CAN @ ?\" に対応している端末は殆どないので、対応する理由がない。\n    https://superuser.com/questions/407391/super-key-over-ssh によると Konsole がこの形式を使うそうだ。\n\n2017-03-04\n\n  * syntax: bug ヒアドキュメントによる nparam の更新が追いついていない。\n\n    これは何でかというと nparam の計算に stat 保存点を超えた過去の情報を用いているからである。\n    部分更新をしている為に過去の情報が書き換わったとしても\n    stat 保存点で解析状態が一致したと見なされてしまい、\n    其処で解析が中断してしまうのがいけない。\n\n    これを解決する為にはヒアドキュメントの word に相当する部分は\n    一気に解析する様に修正しなければならない。\n    結局 word 部分は最終的には独自の方法で読み取るのが良い様な気がする。\n\n    或いは暫定的に範囲を指定して stat を消去する様な機能があったような…?\n    →昔その様な処理の仕方をしていたような気がするが、いま確認してみるとない。\n    恐らく何か問題が色々生じて結局その方法は使わないという事になった様な気がする。\n    記憶が正しければそれは time ... や function func () だとか func () を解析する時の話だった。\n    結局何れの場合でも一回の解析で行けるところまで解析するという事になった。\n    ヒアドキュメントでもその様に実装するのが一貫している。\n\n  * syntax: ヒアドキュメント 終端 word 着色\n\n    todo: 取り敢えず RDRS 等と同様に完全に入れ子を追跡する様に実装する。\n\n    $() ${} の入れ子も含めた実装が必要になる。\n\n    実は、通常通りに解析してしまって、\n    後の着色で一様な色に塗り潰してしまうという方策で良いのではないか。\n    しかしそれだと tree-enumerate の際に $() の内部で着色が起こる気がする…。\n    % 特に部分更新などをすると確実に内部での着色が発生するのでは…??\n    % →部分更新の時は一番外側の単語についても着色が判定されるから特に\n    % 部分更新仮想で内科に依る違いは発生しないと思われる。\n\n    取り敢えずの実装として通常通りに解析する様に変更した。\n    単に ble-syntax:bash/ctx-heredoc-word から\n    ble-syntax:bash/ctx-redirect に処理を委譲するだけで良かった。\n    ヒアドキュメント特有の処理は ble-syntax:bash/ctx-heredoc-word/check-word-end\n    の方にしかなかったからである。\n    また、同時に CTX_RDRI, CTX_RDRH の単語を上から塗りつぶす様にした。\n    しかし、やはり予想通り $() の内部などの単語の着色は発生してしまっている。\n\n2017-03-02\n\n  * syntax: パラメータ展開・算術式評価内部の quote 除去が為されない状況での _ble_syntax_attr\n\n    以下の項目で対応しきれなかった (対応しないことにした) ものをここにまとめる。\n    cf. #D0375 \"2017-03-02 [2016-08-06] syntax: extquote と \"${}\" の入れ子に関して\"\n\n    > - $(()) の中の () のネストに関しては対応していない。\n    >   つまり () が一つでも挟まれば quote 除去が有効であるかのように着色される。\n    >   →これは対応した。\n\n    - $((a['1+1'])) などの添字の quote 除去は有効であるが、現実装では quote の着色はしていない。\n      つまり $(('1+1')) などと同様に quote 除去が為されない物として着色を行っている。\n\n      これに対応する為には $(()) の中でも [] に対応するネストを判定する様にしなければならない。\n      ※一方で [] の中では () に対応するネストの判定はしなくても良い。\n\n    - $((\"${hello}\")) などの構造では CTX_QUOTE の中で自身が有効かどうかを判定して\n      自身の着色を変更したりするのは面倒なので、普通に (有効であるかの様に) 着色している。\n\n      算術式の場合には quote 除去されないと分かっている時点で文法エラーになるので\n      1文字目をエラーの色にするというので良い気がする。\n      パラメータ展開の内部の場合には quote 除去されないからと言ってエラーにはならない。\n\n    - bash では \"${var# ... }\" の中の '' は quote 除去される一方で、\n      \"${var:- ... }\" の中の '' は quote 除去されない。\n      この実装では取り敢えず quote は除去されるという取り扱いである。\n\n      これらについては包括的に振る舞いを調査する必要があるだろう。\n      他にも様々な種類のパラメータ展開があるし、\n      また将来的に各種類のパラメータ展開についての詳細な構文解析にも対応する可能性がある。\n      (特に ${var//a/b} の quote (\\?) の取り扱いがややこしいのでこれは視覚的に分かる様にしたほうが良い。)\n\n    - 現状では $((\"a\")) はエラー着色になっているが実は文法的に有効である。\n      同じクォートでも $(('a')) や $((\\a)) は文法的に駄目。\n\n    - Bash 5.1 以降では (('a')) がエラーになる様に文法が変わった。\n\n2016-07-15\n\n  * isearch: 現在の履歴内の位置を % で表示しているが、\n    これは検索の進捗状況の表示の方が分かりやすいのではないか。\n\n  * complete: declare の引数を特別扱いしているがこれも compgen があればそれに従うべきでは。\n    もしくは、何か特別な処理をするとしても compgen を介して特別な処理をするべきではないのか。\n\n    現状の実装だと、declare などの変数を宣言する組み込みコマンドについて、\n    ユーザが complete によって補完の制御を行う事ができない。\n\n2016-07-08\n\n  * prompt: 最終行・先頭行に何か表示する機能があっても良い。\n\n2016-07-07\n\n  * isearch: 正規表現検索?\n\n    →取り敢えず vi-mode で実装した #D0513。incremental ではない。\n\n    正規表現で incremental にすると一度通り越したものに一致する可能性があるので直観的でない。\n    もし incremental にする需要がある場合には再度考える必要がある。\n    因みに、emacs は (分かりにくい動作だが) 現在の位置から続きの検索をする。\n\n  * edit: 置換モード (正規表現・固定文字列・globパターン)?\n\n    その為には置換前・置換後を入力する欄を別に表示する必要がある。\n    入力欄でも様々な binding が使えた方が嬉しい。\n\n2016-06-22\n\n  * tui: prompt-toolkit という物がある様だ。ちょっと観察してみるのも良い。\n\n    基本的には補完候補を勝手に出すという事と、\n    表示の仕方が emacs auto-complete と同様に\n    overlay によって実現されているという事。\n\n    所で overlay で実現するためには複数行で編集を行っている時に、\n    下の行にある内容を記憶しておく必要性が生じる。\n    Emacs の場合には表示している内容を完全に内部に保持しているので問題にならなかった。\n    (a) 現在の実装で実現するためには内容を完全に記憶するか、そうでなければ\n    (b) 複数行で編集を行っている場合には枠の位置・大きさを変更する際に\n    毎回下の方にある行を再描画するかといった事が必要になるだろう。\n\n    Bash では 2 次元配列を実現するのは辛いので\n    結局内容を完全に記憶するというのは余り嬉しくない事だろうか。\n    と思ったが、表示領域の幅 (COLUMNS) さえ把握しているのであれば、\n    実は 1 次元配列の上に terminal の内容を保持してしまっても問題ない気がする。\n    というか枠の大きささえ決まっていれば普通に sub window の様な物も\n    bash で実現する事ができる。今まで余り考えたくないとして避けていたことだが、\n    この方法ならば楽である。\n\n  * tui: GUI Window System を整える? Window を出したり消したりだとかそういう事。\n\n2016-04-05\n\n  * tree-enumerate による skip の実装と解析一時中断の不整合に関して。\n\n    ble-syntax.sh: ble-syntax/parse/shift.impl2 の問題点である。\n\n    現状の方法では、解析一時中断を行った時に shift 対象の高速な列挙が出来なくなる。\n    唯一の現実的な高速化手法は \"直前非空白要素の位置\" を管理するように変更する事である。\n    これは解析自体の動作とは全く関係なく、_ble_syntax_tree/stat/nest の配列としてのデータ構造を拡張するという事である。\n    解析自体の実装とは直交して実装する事が可能と思われるが、新規情報の管理コストが増えるという問題点が残る。\n\n    →一方で tree-enumerate を使った場合には閉じている単語内部の shift を省略できるなどの利点がある。\n      最終的にはこれらを組み合わせたような shift が必要になるだろうと考えられる。\n      もう少し詳しく考察を行う必要性がある。\n\n2015-12-20\n\n  * complete: 履歴を用いた候補生成? 特に単語について。\n\n    2018-09-23 これは動的略語展開によって部分的には対応された。\n    しかし処理の重さから一度に全ての候補は計算しないし、\n    また文法的な単語ではなくて COMP_WORDBREAKS によって分割された単語である。\n    これを本当に対応しようと思ったら background でプログラムを\n    走らせるなどの事が必要になる気がする。\n\n2015-11-21\n\n  * 公開までに追加であった方が良いかも知れない物\n\n    + 拡張性の提供 (拡張の仕方の説明)\n      + theme の枠組を整える事 (setting files の置き場?)\n        ble-color-list\n      + 文字コード拡張 (Unicode との mapping)\n      + 端末制御コード拡張\n        tput からもっと積極的に読み込むべきなのでは?\n        cmap/default.sh に加えて cmap/tput.sh 的な物も?\n        > minimal.sh, xterm.sh, rosaterm.sh の整理。\n\n    + 簡単なキーボードハンドラのサンプル (テトリスとか? 或いは sentaku 再実装とか)\n\n      サンプルとしては、端末の出力画面に現れる物よりは、\n      画面を altscreen で完全に切り替える物の方が実装しやすいと思われる。\n      それでいて、read -t 0 などを有効に使えるとなるとテトリスなどになるだろうか。\n\n    + マウス対応\n\n    + キーボード入力内容を全部 vbell で表示する方法?\n\n2015-11-06\n\n  * まったく同じ nest 状態になると思われるのに解析中断が起こらない\n\n    ☆これは表面上は何の問題も起きない。多少無駄な処理をするだけである。\n      従ってそんなに対処に緊急を要しない。\n\n      | function ble-syntax/parse/nest-equals {\n      |   local parent_inest=\"$1\"\n      |   while :; do\n      |     ((parent_inest<i1)) && return 0 # 変更していない範囲 または -1\n    -->     ((parent_inest<i2)) && return 1 # 変更によって消えた範囲\n      |\n      | local _onest=\"${_tail_syntax_nest[parent_inest-i2]}\"\n      | local _nnest=\"${_ble_syntax_nest[parent_inest]}\"\n      | [[ $_onest != $_nnest ]] && return 1\n    変更によって消えた領域を指している場合は、\n    既に消えた領域のデータを捨てているので nest の判定を行う事ができない。\n    そんな訳で解析中断はできないと判定されてしまうのである。\n\n    ここで解析中断を出来るようにする為には消えた領域のデータも取って置いて、\n    その上で全く同じ解析結果になったら解析中断を行う、という事になろう。\n    以降の解析の動作に違いがなければ良いのだから\n    過去の nest の状態だけが一致していれば解析中断には充分である。\n    これは別項目として独立させて残す事にする。\n\n    ※問題は解析領域拡大によって i1 が後退する事によって\n      変化の無かった部分についても解析結果が消去されてしまう事にある。\n\n2015-08-20\n\n  * エラー検出・表示の管理について\n\n    現状\n\n    現在エラーは様々な方法で使用者に対して提示している。\n    解析の途中状態で既にエラーと分かる物については\n    _ble_syntax_attr に ATTR_ERR を設定している。\n    これは _ble_highlight_layer_syntax1_table を経由して表示の着色に反映される。\n    もう一つのエラーの種類は入力したコマンドラインの末端で入れ子が閉じていない物である。\n    これは一番最後の文字と対応する入れ子の開始点の色を変更する事によって提示する。\n    この着色は解析点より前に対して行われるので部分更新の対象とする事は難しい。\n    従って _ble_highlight_layer_syntax3_table を介して、毎回全消去・再計算を実行している。\n\n    以下に改善したい箇所について列挙する。\n\n    - この様に複数の方法を用いてエラーを提示しているのは少し醜い。\n      もう少し統一した枠組を作っても良いのではないかという気がする。\n\n    - ATTR_ERR を用いて設定したエラーは、\n      後の処理で追加される単語毎の着色によって上書きされてしまう。\n      つまり、折角エラー通知の為に着色を設定していても使用者に見えない事がある。\n      別の場所にエラーを登録しても良いのではないかという気がする。\n\n    - 各エラー項目に対して何が問題なのか・何のエラーなのかのメッセージを設定したい。\n      これらのメッセージも枠組の中で管理して、カーソルの位置に応じて表示できる様にしたい。\n\n    もう少し現状について調べて実装の方法について考える。\n    先ずエラー情報を記録する為の配列の形式について。\n    既存のエラー着色に使っている配列 _ble_highlight_layer_syntax3_table が気になる。\n    これを拡張する形で実装する事はできないだろうか。。\n    →この配列は部分更新できないような情報を保持するのに使っている。\n      部分更新できない様な着色であっても今回の実装によって\n      よりましな方法に変更できるのではないか、という気もするが、\n      それは今回の実装が終わってから考えれば良い事である。\n      (初めからその様な物にも対応できる様に今回の実装を設計するという事も出来るが\n      複雑になるので、取り敢えずは何も考えずに実装する事を目指す。)\n\n    つまり、_ble_highlight_layer_syntax3_table は non local な着色の為に使うとして残し、\n    それとは別にエラーを管理する為の配列を作成する。\n\n    部分更新の際の効率を考えると _ble_syntax_attr と同様に、\n    編集文字列中の位置を配列のインデックスとする方法が良さそうに思われる。\n    然し一方で、エラーの数はそんなに沢山になるとは考えがたい (sparse) なので、\n    リストにして管理するという方針も考えられる。どちらの方が良いだろうか。\n    リストにしている場合、\"エラー設置点 エラー開始点 エラー終了点 メッセージ\" というデータ形式になるだろうか。\n    shift や解析中断後の再開に際してはエラー設置点を用いた filtering を行う。\n    % このエラー情報の内容は解析の動作に全く影響を与えないし、\n    % 解析が同じように進めば全く同じエラー情報を生成すると期待できるので、\n    % 解析中断の判断基準に含める必要はないと考えられる。\n    →本当だろうか。エラー開始点・終了点などの情報は解析状態が同じになっても異なる値になりうるのでは?\n      特に、現在 _ble_highlight_layer_syntax3_table で管理している物はその最たる例である。\n      ここで、エラー開始点・終了点が正しく設定される為には次の条件が必要である。\n\n      エラー設置点を p1 とする。ble-syntax/parse の 1 step で i=i1 から\n      i=i2 まで進む (但し i1 <= p1 < i2) 時、エラー開始点 p2, 終了点 p3 は、\n      i1 <= p2 < p3 < i2 を満たす。\n\n      この条件が揃っている時のみに現状の解析中断条件で部分更新安全である。\n      因みに p2, p3 を設置点からの相対位置で記録しておけば shift の操作が必要なくなるのでその様にするべきである。\n\n2015-08-16\n\n  * 入れ子構造を考慮に入れた効率的な単語着色\n\n    現状: 新規生成単語及び消滅単語の範囲 (range1) に関して再度単語の着色を実行する。\n\n    x 但し、着色は \"消滅単語の存在していた範囲\" 及び \"新規生成単語登録位置の範囲\"\n      に登録されている単語及びその子孫だけになっている。\n      本来は、range1 に被さっている全ての単語について処理を実行するべきである。\n\n    - 考慮に入れるべき事として、将来的に解析を途中で停止した場合でもそれなりに動くような方法がよい。\n      しかしながら未だ解析を終えていない部分については結局どうしようもないから、\n      解析が完了している部分文字列について木構造を作成して処理する事になるだろう。\n      結局、現在 shift を実行するのに用いているのと同じ事をする事になる。\n      (そしてそれは tree-enumerate/.initialize で実装されているので余り気にする事はない。)\n\n    方法\n\n    a 一つの方法は tree-enumerate を使用して末端から順に単語の範囲をチェックしていく方法である。\n      つまり、現状の shift の実装と同じになっている。\n\n    b もう一つの方法は、先に単語の木構造の情報だけ構築してから、\n      range1 に対応するノードを列挙して構築する方法である。\n      木構造として親ノードの位置・子ノードの配列を保持していれば、\n      指定した範囲に対応するノードの範囲を効率的に計算する事が出来る。\n\n      ただし、木構造の情報の構築自体にどれだけのコストがかかるかについて考える必要がある。\n      木構造は後ろから掘り出すようにして実行する為、\n      更新範囲の beg から文字列の末端 iN 迄を完全に構築し直す必要がある。\n      部分更新するというのが難しいと思われる。\n\n      しかし、部分更新は全くできないのでは等と考えていたが、\n      考えてみると意外と部分更新も出来るのではないかという気になってくる。\n      更新範囲に含まれていないノードの内部構造に関しては実は更新の対象ではない。\n      また、更新範囲より前にあるノードの内部構造についても同様である。\n      但し、親ノードの位置は、更新範囲より前にあるノードであっても更新する必要がある。\n\n    c 或いは、parse の過程でより分かり易い木構造データも同時に構築してしまうという手もある。\n\n      x parse の内部状態を増やせば増やす程、解析中断が難しくなるが\n        最終的に構造を再構築するのであれば結局中断してもしなくても同じかも知れない…?\n        しかしながら木構造を考えずに parse した後、木構造に対する更新を行った方が処理量は少なくなるはずである。\n        というのも木構造を考えながら parse する事にすると、\n        更新の必要のない文法的処理も木構造の構築と同時に実行してしまうからである。\n        それよりは、文法的処理で必要最低限の所を parse で処理して、\n        木構造の構築について必要最低限の所を後の処理で実行する、という形の方が良さそうである。\n\n      o ただ、parse の過程で木構造も一緒に構築するようにした方が、\n        データ同士の依存関係が整理されて良いという側面もある。\n        parse の後で木構造としてどの範囲を更新するべきかを決定するのは面倒でありバグを生む原因にも成る。\n        →parse の後で処理をする際にも何らかの \"原則\" を決めてその下で実装するなどした方が良いと思う。\n        (逆に言えば上手に原則を決める事さえ出来れば、parse で木構造を構築する事の利点はなくなる。)\n\n\n    入れ子構造の実装後に改善できる箇所\n    - tree-enumerate-in-range 及びその呼出元\n      現在は愚直に範囲内に設置されている単語識別子を\n\n2015-08-15\n\n  * syntax: `function ...' において関数名の部分に使用した履歴展開を解釈する?\n    履歴展開だけを解釈する新しい文脈が必要になると思われる。\n\n    然し乍ら、履歴展開の結果として複数の単語になる場合などを考えると、\n    そもそも一つの単語として読み取って良いのかなど疑問点が残る。\n\n    % 或いは、その場で履歴展開としての妥当性を検証して色をつけてしまうという手もある?\n    % →これだと正しく解釈されない。例えば履歴展開には $ が含まれて良いが関数名には $ が含まれないので、\n    %   先に関数名としての切り出しを実行すると $ の直前で不正に関数名が中断する事になる。\n\n2015-08-14\n\n  * 高速化: ble-syntax/parse: より厳密な shift 範囲の特定・省略?\n\n2015-08-11\n\n  * 今後必要になる大きな書換・再実装は2つある:\n    1 コマンドライン着色の効率的方法の模索\n    > 2 shift の高速化の為の _ble_syntax_word, etc. のデータ構造の変更\n\n2015-02-24\n\n  * layer の仕組みに対する問題提起\n\n    | 現在の実装では各レイヤーは下のレイヤーが提供した文字配列を弄る事によって動作している。\n    | しかし、実の所受け継ぐのは文字配列ではなくて描画属性の配列の方が良いのではないだろうか。\n    |\n    | o 先ず第一に実装の簡便さがある。\n    |\n    | o 次に、更新範囲というのは複数のレイヤーで似たような箇所になりがちなのではないかと思う。\n    |   属性の配列で渡して置いてから一番最後の所で更新範囲に対して切り貼りをして文字配列を構築した方が良いかも知れない。\n    |\n    | x ただ、文字配列にするという事の利点も存在する。\n    |   region 等の様に大域的に色を一時的に変更する様な物の場合、\n    |   文字配列として region の下層にあるレイヤーについて記録を行っておく事は有意である。\n    |   選択が解除された時に再び構築し直すというのは時間が掛かる。\n    |\n    |   但し、その様な動作をする物は限られている様にも思われる。\n    |   殆どの場合には纏まった箇所でコンパクトに更新が行われる。\n    |\n    | x 括弧の対応などの場合、まとめて描画属性から文字列を構築する場合に細かい最適化が出来ない。\n    |\n    |   複数のレイヤーの描画属性の配列からまとめて文字列を生成する場合、\n    |   複数のレイヤーが報告した更新範囲を総合してその範囲で文字列を再生成する事になる。\n    |   しかし、括弧の対応など、実際の変更が小規模に渡るにも拘わらず、\n    |   離れた二点で実施される色付けの場合には、変更の実体に反して範囲が拡大する。\n    |\n    |   今迄の様に文字列を各層で構築する方式の場合には、\n    |   更新を各層の関数の中で自由に行う事ができるので、\n    |   自身の変更の update に関しては最適な方法で更新する事ができる。\n    |\n    |   とはいいつつも更に上のレイヤーに渡す更新範囲はやはり巨大な物になる為、\n    |   上のレイヤーでの合成作業が大域に渡る事は考えておかなければならない。\n    |   実のところ合成作業についてはちゃんと実装していない。\n    |   region に関しては可能な限り最適な方法になる様に実装したが滅茶苦茶複雑になった。\n    |   実際の実装では被覆によって隠される更新などについては考慮に入れなくても良いが、\n    |   複雑になりそうだという事に代わりはない。\n    |   結局、内部的に描画属性の配列を持って更新に望まなければならないという事態になりそうだ。\n    |\n    | 何れにしても現在の実装は、今後拡張していく上で非現実的な感じがする。\n    | ベースを (下層の情報を含まない) 描画属性の配列を上流に渡す方法に変更した方が良いのではと思う。\n    | region 等の実装の際には cache を行う様にする等の工夫をその上で実装する様にしてみたい。\n    |\n    | また、実装が複雑になるが仕様がない。\n    | 取り敢えず現在の所まともに着色を行っている所が syntax だけなので、\n    | これを ble-highlight-layer:syntax に対応する上で考えてみる。\n    |\n    | ble-highlight-layer:syntax の内部で三つの描画属性の配列を用意し、\n    | これらの三つの描画属性の配列を総合する事で文字列を構築する様にしてみた。\n    | 可もなく不可もない感じの実装である。\n    | 少なくとも各層で文字列を構築する様な実装はしたくない。\n    | これぐらいが丁度良い実装の複雑さである様に思う。\n\n    将来的には描画属性の配列で対応できる様にする。\n\n2015-02-23\n\n  * bleopt_suppress_bash_output 制限\n\n    - SIGWINCH (ウィンドウサイズ変更) の時に bash の表示する物になってしまう\n\n  * 描画ちらつき: DCH や ICH 等を用いた効率化?\n\n2015-02-18\n\n  * エラーメッセージの設定を可能にする\n\n2015-02-16\n\n  * syntax: ToDo\n\n    - [[ 条件式の文法。より正確に。特に括弧の入れ子。\n\n      →括弧の入れ子というのはどういう意味であったか?\n      今試してみた所括弧の入れ子などは関係なく ]] が来れば条件コマンドは終了とみなされる様である。\n      例えば $ [[ ( [[ == ]] ) ]] は構文エラーになる。初めの ]] で条件コマンドが終了と解釈される為である。\n\n2013-06-10\n\n  * sword で quote を正しく処理する?\n    これは少なくとも解析器が出来た後に考える。\n\n2013-06-01以前\n\n  * ble-decode\n    + [kbd] terminfo からの読み取り (entry 名は tmux が参考になる)\n    * ble-bind: -s オプションで文字入力の羅列を指定できる様にする (2019-02-10 #D0915 で実装)\n\n  * 説明書\n    + 文字コード decoder の追加方法\n    + keysequence を指定する文字列の文法 (2018-09-23 done)\n    + スタイルを指定する文字列の文法 (2018-09-23 done)\n\n    取り敢えず GitHub の Wiki 上に作る事にした。\n\n\f\n*******************************************************************************\n    Done (実装ログ)\n-------------------------------------------------------------------------------\n\n2024-12-31\n\n  * main: 初期化時刻の表示 (motivated by tessus, Darukutsu) [#D2313]\n    https://github.com/akinomyoga/ble.sh/issues/340\n    https://forum.atuin.sh/t/atuin-bash-and-ble-sh/175/26?u=akinomyoga\n\n    議論に上る度に修正して自分で計算してまた元に戻すのは面倒なので、parse,\n    load, attach, prompt, bind の一連の処理の時間も全て計測して表示する事にした。\n    idle についてはユーザーが勘違いしそうなので積極的には表示しない。必要であれ\n    ば自分で書き換えて表示して使う事にする。\n\n  * global: ble/util/assign をもっと広く使う [#D2312]\n\n    初期化の段階で $() を使っていた箇所があるが、もっと早く ble/util/assign の\n    一時実装を用意して良い筈である。特に bash-5.3 では ${ ...; } を単純に使えば\n    良いので最初に定義するのが効率的である。\n\n    そもそも builtin eval -- \"$(...)\" だって今後は builtin eval -- \"${ ...; }\"\n    に置き換えることができる筈。\n\n2024-12-30\n\n  * decode (bind): print the filename and line in error messages (motivated by excited-bore) [#D2311]\n    https://github.com/akinomyoga/ble.sh/issues/534\n\n    bind のエラーメッセージで問題のあった keyseq をエラーメッセージに含める。ま\n    た、その呼出に対応するファイル名と行番号もエラーメッセージの中に含める事に\n    する。これで少なくともユーザーはそのファイルを確認することができるだろう。\n\n  * util: ble/path#remove-glob で * を指定すると後ろまで全て削除してしまう [#D2310]\n\n    これはとんでもない振る舞いである。元々は恐らく * を使うつもりはなかったが、\n    実際のところ例えば WSL2 で /mnt を除外する為に remove-glob PATH '/mnt/*' 等\n    を指定するので考慮に入れる必要がある。これは修正するべき。\n\n  * global: avoid raw word splitting [#D2309]\n\n    未だ $bytes 等の様に quote されていない箇所があって気になるので、\n    \"ble/string#split-words\" や \"ble/util/assign-words\" を使う様に修正する。\n\n  * progcomp: fix a bug that \"x\" at the end of the last completion is trimmed [#D2308]\n\n    l ~/.opt/tilix を補完しようとすると何故か \"~/.opt/tili \" になってしまう。色々\n    試すと progcomp でファイル名を補完した時に発生する様である。builtin の補完\n    生成では発生しない。また、\"touch fixfixfix\" 等で作った \"x\" で終わるファイル\n    名に対しても発生するという事が分かった。\"touch fixfixfix1\" 等 \"x\" 以外で終\n    わるファイル名に対しては問題は発生しいない。\n\n    問題は ble/complete/progcomp/.filter-and-split-compgen で発生している様だ。\n    この中で x が消滅している。最近修正した mawk bug に対する workaround が問題\n    かもしれないと思ったが、その処理よりも前の時点で既に x が失われている様だ。\n    と思ったら out=${out%x} として明示的に \"x\" を消去している場所がある。これは\n    その直前に ${out%nlfix} というダミー文字列消去の処理があるので、それの一時\n    的な実装の時のコードが残留していたという事の気がする。単純に対象の行を消す\n    事にした。\n\n    これは 5.3 compgen -V 対応によって追加されたコードなので殆どのユーザーに対\n    しては影響がない物である。\n\n2024-12-24\n\n  * vi_[in]map: rlfunc \"paste-from-clipboard\" の対応 [#D2307]\n\n    vi_imap は paste-from-clipboard で良さそうな気がする。一方で、vi_nmap に関\n    しては特別な配慮が必要になる。面倒なので p を呼び出す様にすれば良い気がする。\n\n    今まで Cygwin 上でしか paste-from-clipboard を友好にしていなかったが、\n    rlfunc.txt にあるのに使えないというのも混乱の元なので全ての環境で widget は\n    定義する事にした。また、clipboard から抽出する様々の方法を追加する事にした。\n\n2024-12-23\n\n  * 2022-04-13 bash が `vi-edit-and-execute-command' を追加している [#D2306]\n\n    これは自分が以下で報告した事が元になっているのだろう。\n    https://lists.gnu.org/archive/html/help-bash/2022-02/msg00031.html\n\n    d70b5339 で追加されている。つまり help-bash で発言した次の日には修正が入っ\n    ていたのだった。\n\n    2024-12-23 これはエディタを指定して実行する物。新しく追加する事にした。\n\n  * edit: bash-5.3 \"bash-vi-complete\" を実装 [#D2305]\n\n    bash-vi-complete は vi-complete に似た readline bindable function の様だが\n    そもそも vi-complete が実装されていない。\n\n    ? vi-complete と complete の違いは何か? これは Bash の実装を確認する必要が\n      ある → 実はこれは結構振る舞いが異なるのでは。key によって振る舞いを切り\n      替える様になっている。更に bash-vi-complete という物もあって、その違いは\n      よく分からない。\n\n    * bash-vi-complete は何なのか説明を探そうとしたが見つからない。そもそも\n      readline に備わっている昨日なので man readline には見つからない。一方で、\n      devel の man bash の方にも載っていない。ソースコードを見て振る舞いを調べ\n      るしかないのか? 一応 bashline.c (bash_vi_complete) の最初にコメントで何か\n      書かれているが結局よく分からない。rl_vi_complete との違いは bash の glob\n      を使うという事? 或いは、途中の文字列も glob pattern として展開してしまう\n      という事?\n\n    取り合えず Bash における両実装を確認する。vi-complete と bash-vi-complete\n    は両者とも最初にカーソル位置を修正している。前方が空白でない場合にカーソル\n    位置を一つ進めている。\n\n    ? done: うーん。これについては vi_nmap/complete も同様に実装するべき?\n\n      と思ったが、まあ、敢えて vi-complete ではなく complete を選んだ場合には\n      やはり vi として consistent な振る舞いということで現在の振る舞いを保持\n      する? 勝手にユーザーにとって non-trivial な振る舞いをするのも考え物であ\n      る…\n\n      が空白の位置にカーソルが置かれている場合には文字を一つ進めて補完を試み\n      るのも変な感じがするのでやはり既定で文字を進めない様にする?\n\n\n    構造としては類似だが vi-complete と bash-vi-complete では実際に実行する操作\n    が全く異なる? よく分からないので先ずは vi-complete について確認する事にする。\n    vi-complete では次に key に応じて振る舞いを分けている。`*` -> `*`, `=` ->\n    `?`, `\\\\` -> TAB に変換して rl_internal_complete に渡している。具体的な振る\n    舞いについては rl_internal_complete のコメントに書かれている。\n\n    > `*' means insert all of the possible completions.\n    > `?' means list the possible completions.\n    > TAB means do standard completion.\n\n    うーん。つまり…  `\\\\` を指定した場合には既存の補完を削除して改めて最初から\n    補完を実行するという事? ble/complete/menu/clear を呼び出してから実行すると\n    いう事だろうか。\n\n    更に、'*' と '\\\\' の場合には挿入モードに移行している。どういう事だろうか?\n\n    ? これが POSIX の要求という事なのだろうか? 然し XCU を見ても set -o vi で\n      vi editor になるという事が書かれているだけで TAB がどう振る舞うべきか等に\n      ついては何も記述されていない気がする? そもそも XCU では補完の話はしていな\n      い。completion で色々記述があるが何れも \"コマンド実行完了\" や \"文法として\n      のコマンド終わり\" を意味している様だ。一方で XCU vi の方を見ても何処にも\n      補完の話は書かれていない。<tab> の振る舞いの説明についても書かれていない\n      (insert mode で生の tab を入力すること以外は)。<control>-I についての記述\n      もない。うーん。謎だ。\n\n    具体的に振る舞いを確認してみても、'*' と '\\\\' の時にだけ insert-mode に移行\n    して、'?' の時などには insert-mode に移行しないようだ。これは変だ。或いは、\n    これは話が逆で '?' の時だけ insert-mode に移行しないという事で、その他の場\n    合には予期しない呼び出しだから適当に処理しているという事だろうか。\n\n    さて、次に bash-vi-complete の実装を確認する。うーん。これは結局既存の\n    widget たちを呼び出している様な気がする。という事は、ble.sh 側の実装でも単\n    に opts に context=glob を追加して呼び出せば良い様な気がする。\n\n    bash-vi-complete では他に bigWord に対する処理という物が加わっている。うー\n    ん。どうやら現在の単語を抽出して、現在の単語に glob 文字が含まれていなけれ\n    ば glob pattern の末尾に * を追加している様だ。うーん。面倒だ。\n\n    ? そもそも現在の実装の context=glob はどの様に振る舞っていたか。先ず展開を\n      試みている。それで何も生成されなければ * を追加して再展開を実行している。\n\n      これは bash-vi-complete の動作と同じになるだろうか? うーんならない気がす\n      る。例えば glob 文字を含まない場合を考える。この場合は、bash-vi-complete\n      だとそれから始まるファイルが全て生成されるが、ble.sh の context=glob では\n      完全一致するファイルが存在する時ただ一個の候補が生成されてそれに確定する。\n      glob 文字を含む場合には bash-vi-complete だと一致するファイルが存在しない\n      時に何もしない事になるが、ble.sh の context=glob では末尾に * をつけて再\n      展開を行うのでファイルが生成される場合がある。\n\n      そもそも bash の M-g はどの様に振る舞うのかと調べてみたが glob 文字が含ま\n      れていても問答無用で末尾に * をつけて生成している気がする。従って候補が生\n      成されなかった時にだけ * を末尾につけて再展開するというのは ble.sh による\n      拡張である。\n\n      ? bash の M-g の振る舞いは何処で実装されているのか。もしこれが編集関数に\n        よって実装されているのだとしたら bash-vi-complete で * を末尾に付加して\n        いるのは果たして必要な物なのだろうか?\n\n        うーん。調べてみると bash は emacs mode でかつ M-g の時だけ * を末尾に\n        付加する様である。M-* や C-x* など他の場合には * を末尾には付加しない。\n        不思議な仕様だし余り consistent とは言えない。\n\n      うーん。bash の実装が何か変な気がするので、この * が付加される条件は勝手\n      に単純化する事にする。\n\n  * edit: more widgets in vi_nmap (requested by excited-bore) [#D2304]\n    https://github.com/akinomyoga/ble.sh/issues/534\n\n    先ず最近追加された readline bindable function に対する対応を行う事にする。\n    但し spell-correct-word に関しては面倒なので後回しにする。\n\n    [complete]\n\n    menu-complete, menu-complete-backward: これは complete と一緒に対応する必要\n    がある。\n\n    * カーソル位置をどの様に処理するのかが微妙だと思ったが、p や insert mode か\n      ら戻った時のカーソル移動やその行の最後の文字の右にカーソルをおけない事な\n      どを考えると、現在位置の右にある文字も既に入力された文字列の一部として取\n      り扱うのが自然である。\n\n    * done: vi_imap/complete が存在しているが rlfunc では使われていない。何故?\n      うーん。単に書き換えるのを忘れていただけという事の気がする。これは全て\n      vi_imap/complete を使う様に修正した。\n\n      * todo: 或いは menu-complete に入る物に関しては特別に処理する必要がなかっ\n        たという可能性もある? そうだとしても分かりにくいので vi_imap/complete\n        経由で呼び出す様に修正するが、念の為、後で本当にそうなのか確認する。\n\n    x fixed: menu-complete を vi_nmap の中でキャンセルして vi_nmap を抜けて\n      menu が非表示になっても、menu が未だ active の儘になっている。これは変な\n      気がする。\n\n      vi_imap で menu-complete をキャンセルして vi_nmap に入った時にはその様な\n      事は起こっていない。と思ったが vi_imap から vi_nmap に入った時にキャンセ\n      ルされるというよりは menu-filter によって deactivate されていたという事の\n      様に見える。うーん。update-mode-indicator で menu を deactivate するのが\n      良い?\n\n    * done: `[`] の動作確認\n    * done: nmap . の動作確認\n    * done: imap-repeat に対する影響は? うーん。期待される動作が何なのかもよく\n      分からないが、取り敢えずは現状の振る舞いで良い様な気がする。C-o で補完を\n      試みてその後で何か挿入すると、C-o で補完を試みて以降の内容が記録される。\n      C-o で補完を試みてその直後に ESC で insert-mode を抜けると、C-o を押す前\n      までに入力された内容が挿入される。\n\n    * done: undo が正しく記録されて元に戻すことができるか確認\n\n      undo はちゃんと記録されている。\n\n    * done: menu-complete の時にも同様のテストをするべきなのではないか。\n\n      `[ `] . の 動作確認はした。undo についても動作確認した。まあ良いだろう。\n\n    * fixed: 但し、undo 後のカーソル位置が変かもしれない。しかし、これは今回の\n      問題というよりは nmap における undo の実装の問題の気がする。vim ではどの\n      ように振る舞っていただろうか。\n\n      % うーん。どうやら vim ではカーソル位置もちゃんと覚えていて u をするとちゃ\n      % んと元の位置に戻る様である。つまり、単に編集範囲の先頭もしくは末端にカー\n      % ソルを配置するのではなくて、その操作をする前のカーソルの位置に戻る。例\n      % えば pu と Pu の結果の違いを観察すると分かる。編集範囲を元にすると両者\n      % は異なるカーソル位置になるはずだが、実際にはちゃんと最初のカーソル位置\n      % になる。\n      %\n      % →これは勘違いである。vim は編集範囲を個別に記録していて、カーソル位置\n      % は編集範囲の先頭に来る様にする様である。然し pu で元の編集位置に戻るの\n      % は何故かは分からない。編集範囲を元々カーソルが居た位置を含むように設定\n      % しているという事だろうか? よく分からないがこれは別項目で残す事にする。\n\n      或いは undo_point を適切に設定すれば vim の振る舞いに合わせることができる?\n\n      うーん。改めて vim の振る舞いを見てみると最後の位置を覚えているのではなく\n      て単に編集範囲の先頭にカーソルを移動するだけの様である。→微妙に編集範囲\n      の特定の振る舞いが異なるがこれは仕方がない事にする。\n\n    [undo]\n\n    vi-undo: これは undo と全く同じで良い。Bash のソースコードを見たら単に undo\n    の関数を呼び出しているだけであった。5.2 で新しく vi-undo が追加されたのは、\n    Bash の中で存在していた synonym にちゃんと一対一対応する様に名前を付与した\n    という事なのだろう。或いは、一覧にリストされる様になったか。\n\n    うーん。全く同じで良いと思ったが vi_imap に於いては imap-repeat との兼ね合\n    いを考える必要がある。うーん。imap-repeat において undo をどの様に取り扱う\n    べきか。\n\n    a undo 操作自体を繰り返す? しかしそれだと意図しない振る舞いになる可能性はな\n      いだろうか。\n\n    b 或いは実際に発生した効果を模倣する?\n\n      undo という事は必然的に実際の挙動としては、既に入力された物を削除する場合\n      が考えられる。その場合にどのようにして削除するのかが問題になる。文字数を\n      数えて全く同じ文字数だけ削除するのか、或いは、削除された文字列に一致する\n      文字列が存在した場合にだけ削除を実施するのか。然し、前者だと全く意図しな\n      い振る舞いになる可能性がある。後者の場合にも、削除する事を前提として次の\n      操作を続ける可能性もあって、何も発生しないというのはそれはそれとして問題\n      である。\n\n      そもそも、直前の操作が実際に同じ文字数だけ文字列を挿入するのかも分からな\n      い。例えば p の場合には予測不可能である。然し、結果がどうであれ u で p を\n      実行する前の状態に戻したい。その様に考えるとやはり undo は undo 操作自体\n      を実行するという事で良い気がする。\n\n    結局 undo 操作を直接呼び出すのが妥当の様な気がする。そうすると emacs/undo\n    と全く同じ実装で良さそうだ。\n\n    * reject: emacs/undo という名前はやめて edit.sh に移動して ble/widget/undo\n      という事にする? と思ったが emacs/* という名前になっているのは、それによっ\n      て ble/edit/undo/add の呼び出しを抑制する目的があった。\n\n    [backward-kill-word]\n\n    これについては既に類似の vi-rlfunc/* という widget が沢山あるのでそれに倣っ\n    て実装する事にした。特に vi-rlfunc/kill-word と殆ど同じと思って良いだろう。\n    振る舞いを確認してみると特に前の単語の先頭までを削除する様なので丁度 \"db\"\n    を呼び出すのと同様の振る舞いで良いだろう。\n\n    * 実は他にも類似の widget は沢山ある気がする。これらも一緒に対応するのが妥\n      当だろう→同様の方法で簡単に対応できる物を幾つか追加で対応した。他にも未\n      だ沢山対応していない readline bindable functions はあるが、他のは何れも対\n      応は大変そうである。\n\n  * edit: \"bleopt undo_point=\" にしても直前のカーソル位置に戻らない [#D2303]\n\n    現状の実装では undo_point= 最後から二番目の編集が起こった直後のカーソルの位\n    置が復元されて、最後の編集が起こる直前のカーソルの位置が復元される訳ではな\n    い。記録するのはその状態での最後のカーソル位置であるべきではないか?  しかし\n    C-r の時には操作直後の状態を復元したい気もする。両方記録する?\n\n    x fixed: 動作確認して気付いたが undo/redo を実行しただけで undo の履歴が書\n      き換わってしまっている。これによって redo をする事ができなくなっている気\n      がする。どうしてこの様な事になるのか? → 単に最終カーソル位置を更新する時\n      の配列要素を間違えていた。修正した。\n\n    x fixed: redo をしているのに編集直後の位置ではなくその編集文字列における最\n      後のカーソル位置になっている。これは $1 を $2 で参照しようとしていたのが\n      原因だった。修正した。\n\n    * done: vi-undo では既定の undo_point の振る舞いを変更する可能性? 然し、\n      Bash で同一実装なのだとしたら undo と vi-undo で実装を変えるのも変だ。寧\n      ろ、undo の実装も一緒に手を入れるべきなのではないか。\n\n    undo_point に新しく first,last,near,auto を追加して既定の振る舞いは auto と\n    する事にした。auto の場合には emacs editing mode と vi editing mode で振る\n    舞いを変更する。うーん。vi editing mode でも vi_imap は emacs と同様に振る\n    舞うべきではないか…。やはり変更する事にした。vi command modes では beg の\n    様に振る舞う事にして、それ以外の場合には near として振る舞う事にする。\n\n  * vi_nmap: C-o の内部で vi_nmap/complete を呼び出すと何だかよく分からない状態になる [#D2302]\n\n    先ず、カーソル位置がちゃんと元に戻っていない。これは C-o の特性だろうか?\n\n    うーん。vim ではそもそも C-o を押した時にカーソルの位置が変化したりはしな\n    い。行末に居る時にだけカーソルの位置が後退する様である。先ずはこの振る舞\n    いを修正する必要がある気がする→修正した。\n\n    また、vi_nmap/complete で menu_complete 等の特別な状態にならない限りは\n    adjust-command-mode を呼び出す様にした。これによりちゃんと一回コマンドを実\n    行した後に insert に戻る振る舞いが可能になる。\n\n    改めて試してみたが変な事にはなっていない様なので取り敢えずは良しとすること\n    にする?\n\n    ? でも何故 menu-complete になって元に戻った時にちゃんと insert になっている\n      のだろうか? vi_imap vi_nmap menu-complete の様な keymap 状態になる訳では\n      ないのか? 或いは adjust-command-mode が menu-complete 終了後に実施される\n      という事か? うーん。少なくとも complete/insert.hook の中では vi_imap\n      vi_nmap menu_complete という状態になっている。という事はその後で vi_imap\n      まで状態が pop するという事になる。試しに adjust-command-mode を調べてみ\n      ると確かに呼び出されている。何処から呼び出されているのかを確認すると、\n\n      [1]=\"ble/complete/menu-complete/exit\"\n      [2]=\"ble/widget/menu_complete/exit\"\n\n      となっている。うーん。これは自分で新しく追加したコードだった。つまり、こ\n      れについてもちゃんと対策ができている。\n\n2024-12-20\n\n  * edit: C-c 後の履歴位置が変だ (reported by dezza) [#D2301]\n    https://github.com/akinomyoga/ble.sh/discussions/540\n\n    C-c を実行した後は C-m を実行した時と同様に全ての編集をクリアして、履歴位置\n    は履歴の末端に移動するべきである。\n\n  * global: rename \"ret\" not used as REPLY [#D2300]\n    Ref #T0009\n\n    将来的に ret -> REPLY の全置換を実施する時に変なことが起こらない為に。\n\n  * global: 実は [:space:] は \\v\\f\\r\\n にも一致する。代わりに [:blank:] を使う [#D2299]\n\n    一方で [:blank:] は全く使われていない。実は [:space:] になっている箇所は全\n    て [:blank:] なのでは? ただし改行 \\n も意図していた可能性があるのでそれにつ\n    いては $_ble_term_IFS に置き換える。\n\n    関連して _ble_term_space も _ble_term_blank に改名する。\n\n  * main: work around macOS sed (reported by Mossop) [#D2298]\n    https://github.com/akinomyoga/ble.sh/issues/538\n\n    macOS awk と同様の問題があるようだ。バイナリデータがあると問答無用で失敗し\n    何も実行しない。取り敢えず locale に C を指定して動くかどうか確認する。もし\n    かすると、encoding 固定で locale を C にしても動かない可能性もあるが、もし\n    そうだったらそれは macOS が悪い。\n\n2024-12-18\n\n  * edit: 履歴移動を行った時のカーソル位置の設定 (requested by miltieIV2) [#D2297]\n    https://github.com/akinomyoga/ble.sh/issues/537\n\n    Note: これにより history_preserve_point -> history_default_point に変更した。\n\n    * fixed: 何と今まで \"bleopt edit_line_type\" が動いていなかった様だ。\n\n    * fixed: 何と今まで bleopt/check:input_encoding のエラーメッセージの一部が\n      表示されていなかった様だ。\n\n      * ok: ble-0.3 では ble/util/print ではなく echo を使っているので問題なかっ\n        た。\n\n      * ok: 類似のものは他にはないようだ。\n\n    * done: wiki, blerc\n\n    x fixed: preserve にしても位置が preserve されていない\n\n      これは何処かの時点で壊れたという事だろうか。上に遡る時には必ずカーソルは\n      先頭に移動してしまう。また、下に移動する時には前のコマンドラインの末端位\n      置に移動しようとする。現在のカーソル位置は全く保持していない。keymap.vi\n      特有の問題ではないようだ。emacs モードでも同様の現象が起こっている。\n\n      うーん。呼び出しの順序的に履歴移動が発生しなかった時に正しい位置にカーソ\n      ルを移動してエラーメッセージも必要に応じて出力しなければならない。しかし\n      現在の枠組みだと履歴移動が発生したかどうかを forward-history-line.impl の\n      呼び出し元で知ることができない。\n\n      振る舞いについて確認する forward-history-line.impl は先ず行を追跡して適切\n      な履歴項目の位置を探し出している。その後で対応する行が見つかれば其処に移\n      動するし、見つからなければ先頭項目か末端項目に移動して終了する。\n\n      * 先ず ble/widget/forward-history-line.impl を呼び出したら、履歴移動が発\n        生しなかったとしても、必ずカーソル位置は適切な位置に設置することにする。\n\n    x resolved: forward-history-line etc 等との consistency はどうなっているの\n      か?  複数行の時に forward-history-line も位置を調整しようとしている。履歴\n      移動後にどの位置にいるのかは実は ble-edit/history/goto で管理するのではな\n      くて forward-history-line 等の実装ごとに適切に処理する必要があるのではな\n      いか?\n\n      * done: ble-edit/history/goto でもカーソル位置を調整するしその呼び出し元\n        でもカーソル位置を調整しているというのは無駄の処理の気がする。→これは\n        ble-edit/history/goto で opts を受け取って clear-point が指定されている\n        場合には、単に _ble_edit_ind=0 にする事にした。\n\n      forward-history-line 等の行指向の履歴移動の場合には振る舞いを行指向に変更\n      した物を別に実装することにした。\n\n    * done: preserve-{,graphical,logical-}column 等も用意するべきではないか?\n\n    * done: clear-point ではなく point=none にする。point=near 等に対応する\n\n    * done: graphical, logical も外から指定できるようにする? graphical-linewise\n      もしくは logical-linewise の形で。と思ったが、そもそも\n      forward-history-line.impl の時点でどちらか分からないので、これも更に外側\n      から種類を受け取る様に修正する必要がある→面倒だと思ったが結局対応した。\n\n    [動作確認]\n\n    x fixed: 全く動かなくなっている。と思ったら graphica/logical の決定による\n      point の書き換えに失敗していた。修正した。\n\n    その他は大体動いている様だ。\n\n    2024-12-31 実は keymap.vi の vi motion 経由で呼び出される履歴移動は\n    ble/widget/history-{prev,next} を用いていた為に、今回の新しいカーソル位置の\n    設定が適用されていなかった? 取り敢えず対応した。\n\n    ? done: と思ったが、本来は ble/widget/history-{prev,next} が正しく位置を設\n      定する筈だったのでは…? 何故動いていないのだろう? 後で確認する必要がある。\n\n      →確認した。history-{prev,next} の直後にカーソル位置を手動で設定している\n      ので折角 ble/widget/history-{prev,next} がカーソル位置を設定してもそれが\n      上書きされていた。その処理を削除されたら期待通りの振る舞いになる事も確認\n      できた。然し、更に引数付きで履歴項目内を移動した時には何れにしてもカーソ\n      ル位置を調整する必要がある。そもそも処理をよく見てみると\n      ble/widget/history-{prev,next} を呼び出す意味はない。単に index を追跡し\n      てその都度 get-edited-entry で取り出した文字列に含まれる改行を数えれば良\n      いだけである。\n\n      最後に ble-edit/history/goto を一回呼び出すだけにする事にした。\n\n2024-12-12\n\n  * style: prefix:$name の形をしている定義関数の呼び出しのクォートを調整 [#D2296]\n\n    \"ble/.../prefix:$name\" としている場合と ble/.../prefix:\"$name\" としている場\n    合がある。検索する時に探しにくいので統一したい。特に :\"$name\" の方が特徴的\n    で検索しやすいのでそちらに統一する事にする。但し、関数呼び出し以外の文脈で\n    どの様にするかは微妙である。\n\n    * エラーメッセージの一部の場合は全体としてクォートしているので :\"$name\" の\n      様なクォートにはできない。\n\n    * コメントの内部の解説の場合にも微妙である。他にも prefix:\"$name\" に似た形\n      をしているが自動生成したラムダ式などの関数名も存在する。元々、ユーザーな\n      どが後付けで定義する時の関数のクォートとして prefix:\"$name\" を使うので、\n      自動生成する関数には適用しない事にする。但し、\n      ble/function#advice/original:\"$name\" 等についてはちゃんと prefix:\"$name\"\n      の形になっているので :\"$name\" の形式を採用する事にする。\n\n    * ble/is-function 関数名 の場合には関数呼び出しと対になっている事が多いとい\n      う事、右辺に関数名が来ることが決まりきっている事などから :\"$name\" のクォー\n      トを採用する事にする。その他の一般の関数の引数 (callback など) として指定\n      する場合は微妙だが全体をクォートする事にする。\n\n    * 類似の物として ble/widget/WIDGET_NAME などスラッシュで区切られた物も存在\n      する。これについても同様に統一する事にする。\n\n2024-12-11\n\n  * complete: mawk-1.3.4-20230525 以前でプログラム補完が全く効かない (reported by KaKi87) [#D2295]\n    https://github.com/akinomyoga/ble.sh/issues/535\n\n    どうも mawk-1.3.4-20230525 以前では関数引数が配列の時に a[] よりも前に\n    length(a) があると、勝手にその引数はスカラー文字列と判定してコンパイルを実\n    行する様である。そしてこの振る舞いはずっと昔からだった様である。これまで報\n    告を受けなかったのは、gawk が入っているシステムでは mawk よりも gawk を優先\n    してこの部分の処理で使っていたため。git clone してビルドする方式だと何れに\n    しても gawk が要求されるので、殆どのユーザーは gawk をいれていたのだった。\n    一方で、報告者は nightly version を使っていた。\n\n    取り敢えず修正した。動作確認もした。\n\n2024-11-28\n\n  * README: README 及び wiki によく行う説明をまとめる [#D2294]\n\n    * auto-complete 関連のエラーに関して説明を何処かに書くべきである。\n      CONTRIBUTING か何かに説明を書いてそれを読む様に指示する。\n\n      * done: 問題がこちらでも再現するとは限らないこと。再現することが大事ということ。\n      * done: 問題解決のために協力がほしいということ。\n\n      元々 template に書かれている内容についてもそちらに移動する? 取り敢えず最\n      低限の内容だけにして其処に記述する事にする。\n\n      * ok: fzf や skim の設定についての説明は何処かの issue comment を参照する\n        のが良い。何回かそういう説明をした気がする。\n\n        取り敢えず記述だけはした。改めてリンク先の内容を見て記述漏れの内容や未\n        だ書きたいことがないかを確認したら完了という事にする→これは良い気がす\n        る。\n\n      * done: また Performance からリンクを貼る: hang しているのは単におかしな\n        状態になったからかもしれない。\n\n      * done: auto-complete についての説明の様に書かれているが後半の殆ど全ての\n        部分は TAB completion にも当て嵌る事である。構成を調整する必要がある。\n        →適当に書き加えた。TAB completion 専用の短い section を追加した。\n\n    * done: 常に ble/widget/display-shell-version の結果を載せる様に要求する?\n      但し ble.sh をロードする事ができない、session を開始できない時に限って\n      Bash version と ble.sh version を記述する様にする。\n\n    * done: \"line_limit_type=editor\" の時には history_limit_length も一緒に調整\n      するべきという事を wiki, blerc.template に追記する。\n\n    * done: 未解決のまま放置されることとなった巷の問題の一覧を wiki の中に移動する。\n\n      > 溜まってきた \"保留\" 的な項目については一旦 wiki の何処かにまとめてしまっ\n      > て忘れる事にする? 返事のない Issue や再現できない物についてずっと Issue\n      > を開いておくのだと際限なく open issue が増えていく事になるが、それらが\n      > いつか改めて情報を得て解決されるという事はない様な気がする。また、この\n      > note.txt の中にも噂だけで再現しない項目が色々ある。それらについては一つ\n      > の文書を用意してその中に記録しておくという事にすれば良い気がする。\n\n      取り敢えず作ったが少ししか記述していない。うーん。また色々 Issues を漁る\n      のは大変である。取り敢えず Information Needed の issue は拾って良い気がす\n      るがこれも後にする。\n\n    * Performance issue に関連するページも作成すると良いかも。典型的な問題及び\n      解決法について。\n\n      https://github.com/akinomyoga/ble.sh/discussions/525\n\n      以下に書いてある様な内容についてまとめる。\n\n      done: https://github.com/akinomyoga/ble.sh/issues/457#issuecomment-2291920637\n      done: https://twitter.com/akinomyoga/status/1633101778894958595\n\n      * done: auto-complete に関しては auto-complete で補完生成を turnoff する\n        関数や、或いは background で候補生成を実行する様に変更する関数などを用\n        意しても良い。それを contrib に入れて於いて呼び出させるなど。或いは、そ\n        もそも core-complete.sh の中にある workaround についても、同様の処理は\n        実装している筈なのでそのコードを使い回せる様にするべきではないか。\n\n        https://github.com/akinomyoga/ble.sh/issues/522#issuecomment-2425293437\n\n        ここにある設定を記述する? contrib に入れるとしたら何処に入れる?\n        complete-utils.bash 的な名前の設定?\n\n      * 返信 https://www.reddit.com/r/bash/comments/1gkv8y1/modern_bash_setup/\n\n        Performance のページを用意する。それに対する pointer を提供する。\n\n        > (i can't even ctrl-c in there)\n\n        Have you checked ble.sh's README for the vi editing mode? Please check\n        [the item of `C-c` in the linked\n        page](https://github.com/akinomyoga/ble.sh/wiki/Vi-%28Vim%29-editing-mode#normalinsert-mode-c-c-cancel--discard-line).\n\n        と思ったがやはりこれは関係ない事の気がするし、いつの間にかに他の人が色々\n        別の話をしているので気にしない事にする。\n\n      * done; 返信 https://www.reddit.com/r/bash/comments/1gzn6gu/blesh_performance_tune_help/?show=original\n      * done: 返信 https://github.com/akinomyoga/ble.sh/discussions/525\n\n      * done: profiler の使い方等についても記述するべきではないか。というか、そ\n        もそも performance を改善する為にできることはないかと質問しているのは、\n        もしかしたら開発者視点での質問かもしれない。ble.sh のコードベースを修正\n        する為に何ができるかなどの意味。その為に書けることも実はたくさんあるの\n        ではないか。\n\n    x resolved: ble/widget/display-shell-version が set -o posix で正しく動作しない (reported by devidw)\n\n      ユーザーに出力結果の提供を要求する以上は set -o posix であっても動作する\n      様にしなければならない。というか、そもそも 5.3 以上では set -o posix の状\n      態だと ble/widget/display-shell-version の関数自体呼び出すことができない。\n\n      だとすると C-x C-v で結果を出力するのを主要な方法にするか? 或いは (set +o\n      posix; ble/widget/display-shell-version) という形で呼び出してもらう事にす\n      るか。然し、それは複雑過ぎる。或いはこれもまた関数名を変更して\n      _ble_widget_display_shell_version 等にするべきか。しかしその様にはしたく\n      ない。というより ble status とかで表示できる様にするか、或いは ble\n      version の中に含めるか。\"ble summary\" というコマンドで出力できる様にする\n      事にした。今後は \"ble summary\" の結果を出力してもらう事にする。\n\n    x fixed: ble/widget/display-shell-version | cat とした時に _ble_term_bold\n      だけ直接使われている為に出力の中に混入する。\n\n    * ok: 実は README 本体は何も更新していない?\n\n      * C で書けだとかシェルで実装するのは云々みたいな批判に対して。これは現時\n        点で必要という気もしないので取り敢えず別項目にして後で気が向いたら対応\n        する事にする。\n\n      * done: Performance 記事へのリンク。Limitation/Criticism に performance\n        を乗せる? 或いは最近頻出なのでもっと上の方に乗せるべきだろうか → うー\n        ん。丁度言及できそうな場所が余りない。Limitation という程 limitation で\n        もない気がするし、 performance が ble.sh が欠陥の一つとして他の本質的な\n        問題と一緒に列挙されるのも嫌な気がする。一番下に troubleshooting の項目\n        を乗せてみたがこれだと気づかないかもしれない。Basic settings の丁度上の\n        Uninstalling の下に挿入するのが良い気がしてきたので取り敢えずそうする事\n        にする。\n\n2024-11-07\n\n  * kitty で _command_offset のエラーが発生する (reported by ozmodeuz) [#D2293]\n    https://github.com/akinomyoga/ble.sh/issues/512#issuecomment-2392121827\n\n    これは kitty の側で修正されるべきである。\n\n    ? kitty が bash_completion を load していてしかし何らかの理由で失敗している\n      可能性? 実際に g grep で検索してみると bash_completion_script なるものが\n      見える。これが何なのか確認する。と思ったがこれは単に kitty が inject して\n      いる script のことをそう呼んでいるだけだった。bash-completion に一致する\n      文字列はなかった。\n\n    これは kitty に PR を提出したらすぐに merge された。\n\n    →kitty はなかなか新しい version が release されないがこれで解決という事にする。\n\n2024-10-20\n\n  * complete: macOS awk の \"towc: multibyte conversion failure on: '...'\"エラー (reported by devidw) [#D2292]\n    https://github.com/akinomyoga/ble.sh/issues/515\n\n    Ref #D1974\n\n    x fixed: macOS awk の workaround として LC_CTYPE を指定していたが単に local\n      を指定しているだけなので呼び出している awk に対してちゃんと環境変数として\n      渡せていなかったのではないか。local -x として宣言する必要がある。\n\n      更に LC_CTYPE だけでなく LC_COLLATE についてもちゃんと指定しないと正規表\n      現の中にある範囲指定が正しく動作しない (可能性がある)。\n\n      https://github.com/akinomyoga/ble.sh/issues/515#issuecomment-2425177424\n      を見る限りは LC_CTYPE さえ指定していれば問題は発生しない様である。なので、\n      報告された問題は、本来、前回の workaround の LC_CTYPE が正しく export さ\n      れていれば発生しなかった筈の物である。\n\n    x fixed: nawk の判定が正しく動作していない。\n\n      \"$path\" -W version || \"$path\" --version\n\n      で version を取得しようとしているが、nawk は \"-W\" に対応してないというエ\n      ラーメッセージが出るにも拘らず 'version' を AWK script だと思って実行し、\n      成功する。従って \"$path\" --version が呼び出されずに version 文字列の取得\n      に失敗する。\"$path\" -W version の実行結果を確認して、それが空だった時は\n      \"$path\" --version を使う様に変更する事にした。\n\n2024-10-19\n\n  * complete: make menu-item styles configurable (requested by simonLeary42) [#D2291]\n    https://github.com/akinomyoga/ble.sh/issues/519\n\n    * done: fish の menu 関連の着色を確認する\n\n      HighlightRole::pager_prefix => L!(\"fish_pager_color_prefix\"),\n        これが今回の色。\n\n      HighlightRole::pager_progress => L!(\"fish_pager_color_progress\"),\n        これは処理中の表示の着色に使う色。\n\n      HighlightRole::pager_background => L!(\"fish_pager_color_background\"),\n        全体の背景色? これは必要だろうか? でも secondary や selected などで同様\n        のものがある事を考えるとやはりそれぞれの項目の色? でもそれなら普通に\n        --background= で指定すれば良いはず。\n\n      HighlightRole::pager_completion => L!(\"fish_pager_color_completion\"),\n        謎。fg は全ての候補に適用される。bg は選択された項目だけに適用されてい\n        る。background と conflict しないのか?\n\n      HighlightRole::pager_description => L!(\"fish_pager_color_description\"),\n        これは既に menu_desc_default がある。\n\n      HighlightRole::pager_secondary_background => L!(\"fish_pager_color_secondary_background\"),\n      HighlightRole::pager_secondary_prefix => L!(\"fish_pager_color_secondary_prefix\"),\n      HighlightRole::pager_secondary_completion => L!(\"fish_pager_color_secondary_completion\"),\n      HighlightRole::pager_secondary_description => L!(\"fish_pager_color_secondary_description\"),\n\n      HighlightRole::pager_selected_background => L!(\"fish_pager_color_selected_background\"),\n      HighlightRole::pager_selected_prefix => L!(\"fish_pager_color_selected_prefix\"),\n      HighlightRole::pager_selected_completion => L!(\"fish_pager_color_selected_completion\"),\n      HighlightRole::pager_selected_description => L!(\"fish_pager_color_selected_description\"),\n\n      意味が分からない。コードを見てみたがそれでも良く分からない。background は\n      bg を決定するだけの為に使われている様に見える。そして {selected_,\n      secondary_, }background は排他的に指定されている?\n\n      prefix の着色には prefix を、それ以外の部分については completion を使って\n      いる。うーん。fg と bg は独立に指定している? ちょっと意味が分からない。\n      https://fishshell.com/docs/current/interactive.html に一応説明があった。\n      secondary に関しては候補について交互に着色を切り替えるための物らしい。背\n      景色ぐらいはこれで指定できる様にして良い気がする。\n\n      fg = prefix || completion で、bg = background || prefix || completion 的\n      な優先順位で決まっているという事だろうか。一方で ble.sh では候補毎に着色\n      を決められる様にしているのでこれを外部から指定するのは変な気がする (或い\n      は何も指定しなかった時の着色をこれにする?)。何れにしてもこれらは\n\n      * prefix の時の追加描画属性\n      * 選択時の追加描画属性\n\n      として実装するべきの気がする。背景色については普通に指定すれば良い。\n      secondary については背景色は指定できる様にしても良いかもしれないが、文字\n      色やスタイルまで変えるのは変な気がする。また、背景色についてはその文字の\n      位置だけではなくて領域全体に広がって指定できる様にしたい気がする。\n\n    * done: update wiki for filename_ls_colors #D2213 (e169e31d) で色々修正した\n      筈。ln=target と '.'* と '*'?* が追加されている。\n\n    * done: g#append で reverse を xor で合成するべきか、或いは加算的に合成する\n      べきか。うーん。地の文の描画属性に対して g#append で部分的な文字列の描画\n      属性を作る時には xor で合成するべきである。一方で、face の設定として\n      reverse を使う時には微妙である。うーん。xor で良い気がする。そもそも現状\n      で g#append を使う時に reverse は使っていない気がするので、振る舞いを変更\n      しても問題ないのでは?\n\n      現在の使用箇所について確認を行う。\n\n      * ble/canvas/trace/.put-sgr.draw で trace に指定した地の文に対して esc で\n        指定された着色を追加する時に使われている。これは寧ろ xor を使うべきパター\n        ンである。\n\n      * ble/highlight/layer:menu_filter/getg において menu_filter_{fixed,input}\n        の region 着色を求める時に、下の layer の着色を元にして色を決定している。\n        これは xor で良い気がする。というかこれも xor を使うべき?\n\n      * ble/syntax/highlight/ls_colors では face filename_ls_colors で指定した\n        着色の上に LS_COLORS 由来の着色を合成している。これは xor ではなくて or\n        でも良い様な気がする、というか寧ろ or の方が良いかもしれない、と思うが、\n        そもそも LS_COLORS に反転を使うのかという話もあるし、filename_ls_colors\n        を用いて一律に反転している時に、元々 LS_COLORS で指定していた物が紛れて\n        しまうというのも意図に合致するのか分からない。そう考えると xor でも or\n        でも良い様にも思われる。\n\n      現状ではこれだけでしか使われていない。\n\n      * face の合成については将来的に対応するかもしれないが、現状では未実装であ\n        る。face の合成については or の方が良いのではとも思ったが、よく考えると\n        上記のパターンと同様の使い方をする場合もあるから xor の方が良いパターン\n        もあるだろう。という事を考えるとやはり振る舞いは統一して xor にするべき\n        である。そもそも合成する場合に reverse を用いるのが非自明である。\n\n    * done; menu_complete_match, menu_complete_selected には対応した。動作も確\n      認した。\n\n    * done: .readline-colored-completion-prefix\n\n      うーん。これは現在の LS_COLORS を参照するべきか、或いは bleopt\n      filename_ls_colors に指定した値を参照するべきか。filename_ls_colors で対\n      応しようと思っていたが、考えてみれば readline は LS_COLORS の値を反映して\n      動作するのだった。filename_ls_colors は LS_COLORS という本来は ls の為の\n      変数を ble.sh に流用する時に用いる変数だったので、独立した設定にしていた。\n      一方で、.readline-colored-completion-prefix は readline 専用の項目なので\n      積極的に取り込んで良いのではないか。\n\n      と思ったが、bleopt には bleopt の設定変数があって、指定方法など考えるとそ\n      ちらの方を優先したい様にも思う。そもそも\n      *.readline-colored-completion-prefix は ble.sh の為ではなくて readline 用\n      に設定している場合もあるだろうから、積極的に設定を読みに行くのも問題があ\n      る気がする。\n\n      等の事を考えると、やはり filename_ls_colors に明示的に指定した時にだけ着\n      色が反映される用にするという事で良い気がする。\n\n      →対応した。\n\n    * reject: 背景色および交互背景色を指定できる様にする? 交互指定については背\n      景色にしか対応しない。文字色やスタイルも一緒に変えるのは変だ。\n\n      背景色に関してはその項目の文字列部分だけの背景色ではなくて、desc も含めた\n      その項目の領域の背景色にする。逆に言うとその項目の領域を明確に定義する必\n      要があるという事。マウスサポート等も考えると元より領域は定義するべきの気\n      がするのでこれ自体は問題ない。\n\n      うーん。実装を確認すると例えば align の場合には measure-item で先に各項目\n      の esc を生成しつつサイズを測り、その後で配置を決定している。つまり esc\n      を生成している時点ではどの様な配置になるか分かっていないという事になる。\n      もし交互に背景色を変えようと思ったら配置が決まった後に再度 esc の生成を実\n      行しなければならなくなり処理が倍増する。これは実装しなくて良い気がする。\n\n      一方で menu-complete を表示する領域全体の背景色を設定できる様にする可能性\n      はあるかもしれない。ただ、だからと言ってそれほど便利な気もしないので取り\n      敢えず今は対応しないという事で良い。\n\n    * done: blerc.template 及び wiki に新しく追加した face の説明を追加する。\n\n2024-10-07\n\n  * make: .git に依存しない設定のために (requested by LecrisUT, blackteahamburger) [#D2290]\n    https://github.com/akinomyoga/ble.sh/issues/509\n\n    * edit: git archive で .git の代わりに commit-id を埋め込む (requested by LecrisUT)\n\n      issue title は git archive が build できないという物だが、提示されている\n      解決法は部分的な解決でしかない。結局 submodule の中身が含まれないので依然\n      として build できない。\n\n      .git に対する prerequisites は消す事にする。何故なら別に .git を作成する\n      規則を用意している訳でもないので、別に prerequisites のエラーとして処理し\n      なければならない必要性もないから。単に $(error ...) でエラーを出色すれば\n      良いだけの話である。\n\n      ble.pp の内部で解決するのも面倒なので GNUmakefile の中でまとめて git 関連\n      の情報取得を行って、環境変数経由で ble.pp に渡す事にした。\n\n    * 元々 git 前提だし git なしでビルドできる様にするのには色々困難があるので、\n      中途半端に対応しても仕方がないと考えていたが、修正しようとする人が余りに\n      も多い (しかも何故 .git repository を禁止している package manager がこん\n      なにもあるのだろうか) ので或る程度修正する事にした。\n\n    * ble.sh の依存性を git ls-files を用いて抽出しようとする部分があるが、これ\n      は out/ble.dep から依存ファイルを抜き出せば良いのでは → 実装した。\n\n  * histdb: calendar の着色が消滅している。何故? [#D2289]\n\n    これは既定の histdb palette の halloween の指定が誤っている為だった。10月に\n    なったので halloween の配色を指定する様になったから問題が出るようになったの\n    であって昔からあったバグだった。github-light を halloween-light に書き換え\n    るべき所を github-halloween に書き換えていたのが問題。\n\n2024-09-25\n\n  * edit: M-x execute-named-command の補完 [#D2288]\n\n    * fixed: histdb-history が auto-complete でコマンドを生成している。うーん。\n      調べてみると source:history については .search-light では\n      $_ble_history_prefix が設定されている場合には処理をキャンセルする様になっ\n      ている。これと同様にするべきである (因みに .search-heavy については直接履\n      歴を検索するので問題ない)。\n\n    decode.sh の ble/builtin/bind/rlfunc2widget で配列に読み込んでいる部分を分\n    離して別の関数にする。そして、それを用いて現在の入力に合致する候補を生成す\n    る。\n\n    うーん。これは ble/widget/complete とは別の枠組みになる? と思ったが同じ枠組\n    みで補完できる様になっているべきである。ちゃんとそれに対応できているだろう\n    か? これは一般の補完の枠組みの再考にもなる。\n\n    * 既存の実装の syntax/completion-context は現在の言語に関する分岐は何もして\n      いない。どのように拡張するべきか。\n\n      check-here は bash の文法について hardcode されていて拡張性がない形になっ\n      ている。check-prefix に関しては配列に設定を代入できる様になっているので、\n      別の言語の場合にも\n\n      新しい言語に対応させる方法はどの様にするべきだろうか。\n\n      a 現在の文法文脈 ctx に補完を結びつける方法をそのまま拡張して、別の言語で\n        も別の文法文脈にしてそれによって補完を生成するべきだろうか。\n\n        x この方法だと現在の言語に応じて同じ文法要素でも生成する候補を切り替え\n          たりする様な場合には困るかもしれない。然し実際にそのような状況が存在\n          するだろうか。\n\n        x また文法が何もない plain な時の補完についてはこれだと対応できない?\n\n          →しかしその場合には plain な時の補完関数の中で _ble_syntax_lang に応\n          じた補完を実行すれば良いのである。拡張の為の interface も用意する。\n\n          →或いは補完を提供するのであればその為だけに新しく ctx を定義しても良\n          いのではないか。もし補完を提供するのであればそれと同時に着色も提供し\n          たくなる。そうすると更に ctx を提供する理由が出てくる。\n\n      b reject: 或いは、現在の言語 _ble_syntax_lang の値に応じて補完の仕方を変\n        更するべきだろうか。\n\n        x 複数の言語が途中で切り替わったり混ざったりする様な状況を考えると、こ\n          の方法だと複雑になってしまう。基本的には言語が混ざっている場合にはそ\n          の言語に対応する関数を下請けにして呼び出す様にすれば良い気がするが、\n          そもそも ctx base で parse した結果として、それぞれの位置がどの言語に\n          対応していたのかを後で決定するのは非自明である。\n\n        そもそも _ble_syntax_lang は一番最初の ctx を指定するぐらいの役割しか無\n        かったのではないか? だとすると _ble_syntax_lang に基づいて全体的に振る\n        舞いを変更するというのも変である。\n\n        実際調べてみると _ble_syntax_lang によって切り替わっている処理は\n        ble/syntax:bash/initialize-ctx, ble/syntax:bash/initialize-vars だけの\n        様である。だとすれば _ble_syntax_lang で振る舞いを変更するというのは設\n        計として不自然である。\n\n    * done: execute-named-command に対応する文脈を追加する\n\n    * done: execute-named-command に対応する着色を提供する\n\n      これについてはもっと考察が必要である。文法解析の辞典で単語の種類まで特定\n      し始めるとキー入力をする度に処理が走る事になって遅くなる? なので単語を設\n      置して単語着色として単語の種類を決定してそれに基づいて着色する? と思った\n      が、よく考えたら文法解析だって連続でユーザーが文字を入力した場合には最後\n      の文字を入力するまで suppress されるのだし、別に問題ない。\n\n      また補完の為に単語を設置しようとも思ったが completion-context で word が\n      見えるのは単語の途中に解析再開点を設置した時だけである。\n\n      単語を設置しても処理が複雑になるだけなので気にしなくて良い気がする。と思っ\n      たが一度実装したので取り敢えずはそのままにしておく?\n\n    * done: execute-named-command に対応する補完を提供する\n\n      * done: check-prefix については取り敢えず実装した。\n\n      * done: check-here についてはどうするか? 特に一番最初の補完ができない。現\n        在の枠組みでは check-here は hardcode されている → check-here について\n        も check-prefix と同様に配列に登録する形に変更した。\n\n        これも取り敢えず実装した。動いている。\n\n      * done: completion-context/.add は completion-context/add に名前を変更す\n        るべきである。\n\n    x fixed: 入れ子で M-x を実行しようとすると assertion failure になる。\n\n      | assertion failure: [[ ! $_ble_edit_async_read_prefix ]]\n      | it is already inside the async-read mode.\n\n      うーん。async-read-mode の keymap では execute-named-command を無効化しよ\n      うと思ったが、async-read-mode はユーザーが指定した keymap を元にして実行\n      できる様になっている。また、既定の keymap は read である。然し、read でも\n      execute-named-command を実行したくなる事もあるだろうし、keymap から完全に\n      削除するのも微妙な気がする。execute-named-command は keymap に入っていて\n      もいいが呼び出した時には無視する様にする事にした。\n\n      と思ったが普通に実行した read -e の中で execute-named-command を実行する\n      と描画が変な事になる事が分かった。一応動いている事には動いているが、同じ\n      panel を使って処理されている? そして、処理が終わった時に元々の表示済みだっ\n      た文字列が再描画されない。という事を考えるとやはり read -e は subprompt\n      が発生する様な入力について想定していなかったという事?\n\n      然し plain bash の read -p に関してはちゃんと M-x を正しく処理できている。\n      なので、read だからと言って subprompt が出せないという訳には行かない。現\n      在の panel の構成は以下の様になっている:\n\n      - panel0 ble/textarea\n      - panel1 ble/textarea\n      - panel2 ble/edit/info\n      - panel3 ble/edit/visible-bell\n      - panel4 ble/prompt/status\n\n      read -e は panel1 を使っている。async-read-mode も panel1 を使っている。\n\n      a 更に新しい panel を用意してその上で描画する? わざわざそれだけの為に\n        panel を増やしたくない。そもそも本当に必要なのだろうか?\n\n      b 或いはコマンド実行時は read -e は panel0 を使う? 然しこれだと ble.sh\n        context の中で read -e をユーザーが設定したスクリプトが使った時に問題に\n        なるのでは? と思ったがその場合には panel1 を使うので大丈夫。\n\n        うーん。この方針で良いのではないか? command-layout では panel0 を使い\n        M-x は独立した行に表示される。非 command-layout では read は panel1 を\n        使い、M-x は同じ位置に置き換える形で描画される。但し、M-x から戻った時\n        に元の内容をちゃんと復元する。\n\n      c panel1 の上で上書きする様に実行する。但し、元に戻る時に再描画を要求する。\n        これだと read の中で更にコマンドを入力している時に元の入力文字列が一時\n        的に見えなくなる。しかし、plain bash の実装が既にその様になっているので\n        それは許されるのではないか。\n\n      d やはり read -e の中では execute-named-command は禁止する?\n\n      取り敢えず b の方針で調整する事にした。動作確認した。良い。\n\n    x ok: COMPV 生成方法に関する議論: COMPS -> COMPV に変換するのは COMPV がフィ\n      ルタリングに使われる物である事を考えると必要である。然し一方で文脈によっ\n      ては COMPS -> COMPV の変換は bash の文法ではなくてその文脈固有の方法で実\n      行する必要がある。その様な場合にどの様に処理するべきか。\n\n      | comps_flags や comps_fixed による変な作用も考慮に入れる必要がある。\n      | pick-nearest-sources で同じ位置から始まる source を全てまとめてしまって\n      | いるが、本当は文法的な取り扱いに応じて分類して同じ分類になる物だけをま\n      | とめて実行するようにするべきである。\n      |\n      | うーん。COMPV の生成は pick-nearest-sources が担っているのでこの関数の\n      | 振る舞いさえ調整すれば問題ない筈である。うーん。word-eval の方法を指定\n      | できる様にする? どの様に指定できる様にするべきか?\n      |\n      | a 各 source 毎に word-eval の方法を指定できる様にする。例えば追加の関数\n      |   を定義させる等して。この場合には複数の source が混ざっていて、それぞ\n      |   れの source が異なる word-eval の規則を要求した時にどうするのか非自明\n      |   である。例えば同じ種類の word-eval の物だけまとめて最初に処理する?\n      |\n      |   またどの様に指定させるのかも非自明である。例えば comp1 の field を拡\n      |   張して comp1,word-eval 等の形に指定できる様にする? この様にすれば同じ\n      |   種類の補完の grouping は簡単になる。\n      |\n      | b そもそも word-eval は top-level で実行する必要があるのだったか?\n      |   filtering についても生成された候補が主張する文字列で filter すれば良\n      |   いのではないのか。例えば complete の時に改めて COMPV を確認する必要が\n      |   あったのだったか。改めて COMPV の使われ方について確認する必要がある。\n      |\n      |   単に速度の問題として共通に使いそうな word-eval を top-level で提供し\n      |   ているだけなのだとしたら、実は内部で生成する時に COMPV を好きに上書き\n      |   して処理すれば良いので余り気にしなくて良い事になる。\n      |\n      |   - というか既に fzf 等の補完では COMPV を勝手に書き換えて処理している。\n      |     特に問題は発生していないのでそれで良いという事なのでは?\n      |\n      |   * 実際に実装を確認してみると選択された sources で使われた COMPV を\n      |     menu_common_part の着色に使用している。つまり、現在の入力内容に基づ\n      |     いて filtering をしてまた候補に着色をする時に、その候補に対応する\n      |     word-eval で得られた現在の値を用いて着色を行う必要がある。\n      |\n      |     これにちゃんと対応するには各候補毎に word-eval の方法を記録して、そ\n      |     の候補毎に値を取得して部分着色を実行する必要があるのでは? 大変であ\n      |     る。\n      |\n      |     →確認した所やはり menu_common_part を使っているのは\n      |     ble/complete/menu-complete.class/render-item である。他では値を引き\n      |     回しているだけで使っているようには見えない。疑問は\n      |     menu-filter/auto-menu で incremental に絞っている時に\n      |     menu_common_part がどの様に更新されているのかという事。\n      |\n      |     うーん ble/complete/menu-filter が menu_common_part を再設定してい\n      |     る様だ。\n      |\n      |   ? menu-filter による filter-candidates で無駄に制限されたりしないのだ\n      |     ろうか? filter-candidates は COMPV (simple-word/eval) による\n      |     filtering を前提にしている。\n      |\n      |     うーん。 ble/complete/menu-filter/.filter-candidates の中で\n      |     ble/complete/candidates/filter#init と\n      |     ble/complete/candidates/filter#test のペアを使っているが、此処で候\n      |     補毎に compv の取得方法の指定をできる様にしたら良いのではないか? 例\n      |     えば ble/complete/candidates/filter#test の第二引数に word-eval の\n      |     種類を指定した時は対応する COMPV を特別の方法で取得してそれを使って\n      |     制限する様にする。追加で comp_filter_type[index] にキャッシュしても\n      |     良い。word-eval の方法と index の対応付は事前に行っておく必要がある。\n      |\n      |   これは複雑になりそうなので別項目で処理することにする。\n      |\n      | c 或いは、ble/complete/context:* の側で word-eval の方法を指定する。つ\n      |   まり context:syntax の場合には現在の COMPV を生成を用いてそれ以外の時\n      |   にはそれぞれに応じた展開・評価を実行する。と思ったが、複数の言語が混\n      |   ざる場合などを考えると、ble/complete/context:syntax のレベルでも\n      |   source 毎に異なる word-eval の方法を用いたい様な気がする。\n\n      取り敢えず b の方針で考える事にする。然し、現時点で既に menu-filter によ\n      る filtering は不完全 (例えば compopt -o ble/syntax-raw で生成された候補\n      など) なので、これに対処しようと思うと広範囲にチェックが必要になる。なの\n      で、取り敢えず今回の修正では menu-filter の事は考えずに source の内部だけ\n      でのみ COMPV を書き換えて評価する事にする。今後の COMPV の様々な評価方法\n      への対処については独立した項目として残す事にする。\n\n    * done: compgen -V を使う。というかそもそも compgen 自体を抽象化して良いの\n      �"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}