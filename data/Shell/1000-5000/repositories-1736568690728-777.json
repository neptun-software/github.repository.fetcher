{
  "metadata": {
    "timestamp": 1736568690728,
    "page": 777,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hwdsl2/wireguard-install",
      "stars": 1254,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.103515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2022-2024 Lin Song <linsongui@gmail.com>\nCopyright (c) 2020-2023 Nyr\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README-zh.md",
          "type": "blob",
          "size": 7.134765625,
          "content": "[English](README.md) | [中文](README-zh.md) | [Video en Español](https://www.youtube.com/watch?v=99qtaJU2E2k)\n\n# WireGuard VPN 服务器一键安装脚本\n\n[![Build Status](https://github.com/hwdsl2/wireguard-install/actions/workflows/main.yml/badge.svg)](https://github.com/hwdsl2/wireguard-install/actions/workflows/main.yml) &nbsp;[![License: MIT](docs/images/license.svg)](https://opensource.org/licenses/MIT)\n\n使用 Linux 脚本一键快速搭建自己的 WireGuard VPN 服务器。支持 Ubuntu, Debian, AlmaLinux, Rocky Linux, CentOS, Fedora, openSUSE 和 Raspberry Pi OS。\n\n该脚本可让你在几分钟内建立自己的 VPN 服务器，即使你以前没有使用过 WireGuard。[WireGuard](https://www.wireguard.com) 是一种快速且现代的 VPN，其设计目标是易于使用和高性能。\n\n另见：[OpenVPN](https://github.com/hwdsl2/openvpn-install/blob/master/README-zh.md) 和 [IPsec VPN](https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md) 服务器一键安装脚本。\n\n**[&raquo; :book: Book: 搭建自己的 VPN 服务器分步指南](https://books2read.com/vpnguidezh)** [[中文](https://books2read.com/vpnguidezh) | [English](https://books2read.com/vpnguide?store=amazon) | [Español](https://books2read.com/vpnguidees?store=amazon) | [Deutsch](https://books2read.com/vpnguidede?store=amazon) | [Français](https://books2read.com/vpnguidefr?store=amazon) | [Italiano](https://books2read.com/vpnguideit?store=amazon) | [PT](https://books2read.com/vpnguidept?store=amazon) | [日本語](https://books2read.com/vpnguideja?store=amazon)]\n\n## 功能特性\n\n- 全自动的 WireGuard VPN 服务器配置，无需用户输入\n- 支持使用自定义选项进行交互式安装\n- 生成 VPN 配置文件以自动配置 Windows, macOS, iOS 和 Android 设备\n- 支持管理 WireGuard VPN 用户\n- 优化 `sysctl` 设置以提高 VPN 性能\n\n## 安装说明\n\n首先在你的 Linux 服务器\\* 上下载脚本：\n\n```bash\nwget -O wireguard.sh https://get.vpnsetup.net/wg\n```\n\n\\* 一个云服务器，虚拟专用服务器 (VPS) 或者专用服务器。\n\n**选项 1:** 使用默认选项自动安装 WireGuard。\n\n```bash\nsudo bash wireguard.sh --auto\n```\n\n<details>\n<summary>\n查看脚本的示例输出（终端记录）。\n</summary>\n\n**注：** 此终端记录仅用于演示目的。\n\n<p align=\"center\"><img src=\"docs/images/demo1.svg\"></p>\n</details>\n\n对于有外部防火墙的服务器（比如 [EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-security-groups.html)/[GCE](https://cloud.google.com/firewall/docs/firewalls)），请为 VPN 打开 UDP 端口 51820。\n\n**选项 2:** 使用自定义选项进行交互式安装。\n\n```bash\nsudo bash wireguard.sh\n```\n\n你可以自定义以下选项：VPN 服务器的域名，UDP 端口，VPN 客户端的 DNS 服务器以及第一个客户端的名称。\n\n对于有外部防火墙的服务器，请为 VPN 打开所选的 UDP 端口。\n\n<details>\n<summary>\n如果无法下载，请点这里。\n</summary>\n\n你也可以使用 `curl` 下载：\n\n```bash\ncurl -fL -o wireguard.sh https://get.vpnsetup.net/wg\n```\n\n然后按照上面的说明安装。\n\n或者，你也可以使用这些链接：\n\n```bash\nhttps://github.com/hwdsl2/wireguard-install/raw/master/wireguard-install.sh\nhttps://gitlab.com/hwdsl2/wireguard-install/-/raw/master/wireguard-install.sh\n```\n\n如果无法下载，打开 [wireguard-install.sh](wireguard-install.sh)，然后点击右边的 `Raw` 按钮。按快捷键 `Ctrl/Cmd+A` 全选，`Ctrl/Cmd+C` 复制，然后粘贴到你喜欢的编辑器。\n</details>\n<details>\n<summary>\n高级：使用自定义选项自动安装。\n</summary>\n\n高级用户可以使用自定义选项自动安装 WireGuard，方法是在运行脚本时指定命令行参数。有关更多信息，请参见下一节，查看 WireGuard 脚本的使用信息。\n\n或者，你也可以提供一个 Bash \"here document\" 作为安装脚本的输入。此方法还可用于在安装后提供输入以管理用户。\n\n首先，使用自定义选项以交互方式安装 WireGuard，并写下你对脚本的所有输入值。\n\n```bash\nsudo bash wireguard.sh\n```\n\n如需删除 WireGuard，请再次运行脚本并选择适当的选项。\n\n然后使用你的输入值创建自定义安装命令。例如：\n\n```bash\nsudo bash wireguard.sh <<ANSWERS\nn\n51820\nclient\n2\ny\nANSWERS\n```\n\n**注：** 安装选项可能会在脚本的未来版本中发生变化。\n</details>\n<details>\n<summary>\n查看 WireGuard 脚本的使用信息。\n</summary>\n\n```\nUsage: bash wireguard.sh [options]\n\nOptions:\n\n  --addclient [client name]      add a new client\n  --dns1 [DNS server IP]         primary DNS server for new client (optional, default: Google Public DNS)\n  --dns2 [DNS server IP]         secondary DNS server for new client (optional)\n  --listclients                  list the names of existing clients\n  --removeclient [client name]   remove an existing client\n  --showclientqr [client name]   show QR code for an existing client\n  --uninstall                    remove WireGuard and delete all configuration\n  -y, --yes                      assume \"yes\" as answer to prompts when removing a client or removing WireGuard\n  -h, --help                     show this help message and exit\n\nInstall options (optional):\n\n  --auto                         auto install WireGuard using default or custom options\n  --serveraddr [DNS name or IP]  server address, must be a fully qualified domain name (FQDN) or an IPv4 address\n  --port [number]                port for WireGuard (1-65535, default: 51820)\n  --clientname [client name]     name for the first WireGuard client (default: client)\n  --dns1 [DNS server IP]         primary DNS server for first client (default: Google Public DNS)\n  --dns2 [DNS server IP]         secondary DNS server for first client\n\nTo customize options, you may also run this script without arguments.\n```\n</details>\n\n## 下一步\n\n安装完成后，你可以再次运行脚本来管理用户或者卸载 WireGuard。\n\n配置你的计算机或其它设备使用 VPN。请参见：\n\n**[配置 WireGuard VPN 客户端](docs/clients-zh.md)**\n\n**阅读 [:book: VPN book](https://ko-fi.com/post/Support-this-project-and-get-access-to-supporter-o-X8X5FVFZC) 以访问 [额外内容](https://ko-fi.com/post/Support-this-project-and-get-access-to-supporter-o-X8X5FVFZC)。**\n\n开始使用自己的专属 VPN! :sparkles::tada::rocket::sparkles:\n\n## 致谢\n\n此脚本基于 [Nyr 和 contributors](https://github.com/Nyr/wireguard-install) 的出色工作，并进行了增强和更改以与 [Setup IPsec VPN](https://github.com/hwdsl2/setup-ipsec-vpn) 项目兼容。\n\n<details>\n<summary>\n对 Nyr/wireguard-install 的改进列表。\n</summary>\n\n- 改进了与 Setup IPsec VPN 的兼容性\n- 改进了脚本的可靠性，用户输入和输出\n- 支持使用默认或自定义选项自动安装\n- 支持使用域名作为服务器地址\n- 增加了对 openSUSE Linux 的支持\n- 支持列出现有的 VPN 客户端\n- 支持显示客户端配置的二维码\n- 支持为 VPN 客户端自定义 DNS 服务器\n- 支持使用命令行参数管理 VPN 客户端\n- 优化 `sysctl` 设置以提高 VPN 性能\n- 使用 `sudo` 时改进了客户端配置文件的创建\n\n...和更多！\n</details>\n\n## 授权协议\n\nMIT\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.119140625,
          "content": "[English](README.md) | [中文](README-zh.md) | [Video en Español](https://www.youtube.com/watch?v=99qtaJU2E2k)\n\n# WireGuard VPN Server Auto Setup Script\n\n[![Build Status](https://github.com/hwdsl2/wireguard-install/actions/workflows/main.yml/badge.svg)](https://github.com/hwdsl2/wireguard-install/actions/workflows/main.yml) &nbsp;[![License: MIT](docs/images/license.svg)](https://opensource.org/licenses/MIT)\n\nWireGuard VPN server installer for Ubuntu, Debian, AlmaLinux, Rocky Linux, CentOS, Fedora, openSUSE and Raspberry Pi OS.\n\nThis script will let you set up your own VPN server in just a few minutes, even if you haven't used WireGuard before. [WireGuard](https://www.wireguard.com) is a fast and modern VPN designed with the goals of ease of use and high performance.\n\nSee also: [OpenVPN](https://github.com/hwdsl2/openvpn-install) and [IPsec VPN](https://github.com/hwdsl2/setup-ipsec-vpn) server auto setup scripts.\n\n**[&raquo; :book: Book: Build Your Own VPN Server](https://books2read.com/vpnguide?store=amazon)** [[English](https://books2read.com/vpnguide?store=amazon) | [中文](https://books2read.com/vpnguidezh) | [Español](https://books2read.com/vpnguidees?store=amazon) | [Deutsch](https://books2read.com/vpnguidede?store=amazon) | [Français](https://books2read.com/vpnguidefr?store=amazon) | [Italiano](https://books2read.com/vpnguideit?store=amazon) | [PT](https://books2read.com/vpnguidept?store=amazon) | [日本語](https://books2read.com/vpnguideja?store=amazon)]\n\n## Features\n\n- Fully automated WireGuard VPN server setup, no user input needed\n- Supports interactive install using custom options\n- Generates VPN profiles to auto-configure Windows, macOS, iOS and Android devices\n- Supports managing WireGuard VPN users\n- Optimizes `sysctl` settings for improved VPN performance\n\n## Installation\n\nFirst, download the script on your Linux server\\*:\n\n```bash\nwget -O wireguard.sh https://get.vpnsetup.net/wg\n```\n\n\\* A cloud server, virtual private server (VPS) or dedicated server.\n\n**Option 1:** Auto install WireGuard using default options.\n\n```bash\nsudo bash wireguard.sh --auto\n```\n\n<details>\n<summary>\nSee the script in action (terminal recording).\n</summary>\n\n**Note:** This recording is for demo purposes only.\n\n<p align=\"center\"><img src=\"docs/images/demo1.svg\"></p>\n</details>\n\nFor servers with an external firewall (e.g. [EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-security-groups.html)/[GCE](https://cloud.google.com/firewall/docs/firewalls)), open UDP port 51820 for the VPN.\n\n**Option 2:** Interactive install using custom options.\n\n```bash\nsudo bash wireguard.sh\n```\n\nYou can customize the following options: VPN server's DNS name, UDP port, DNS server for VPN clients and name of the first client.\n\nFor servers with an external firewall, open your selected UDP port for the VPN.\n\n<details>\n<summary>\nClick here if you are unable to download.\n</summary>\n\nYou may also use `curl` to download:\n\n```bash\ncurl -fL -o wireguard.sh https://get.vpnsetup.net/wg\n```\n\nThen follow the instructions above to install.\n\nAlternative setup URLs:\n\n```bash\nhttps://github.com/hwdsl2/wireguard-install/raw/master/wireguard-install.sh\nhttps://gitlab.com/hwdsl2/wireguard-install/-/raw/master/wireguard-install.sh\n```\n\nIf you are unable to download, open [wireguard-install.sh](wireguard-install.sh), then click the `Raw` button on the right. Press `Ctrl/Cmd+A` to select all, `Ctrl/Cmd+C` to copy, then paste into your favorite editor.\n</details>\n<details>\n<summary>\nAdvanced: Auto install using custom options.\n</summary>\n\nAdvanced users can auto install WireGuard using custom options, by specifying command-line options when running the script. For more details, see the next section \"view usage information for the WireGuard script\".\n\nAlternatively, you may provide a Bash \"here document\" as input to the setup script. This method can also be used to provide input to manage users after install.\n\nFirst, install WireGuard interactively using custom options, and write down all your inputs to the script.\n\n```bash\nsudo bash wireguard.sh\n```\n\nIf you need to remove WireGuard, run the script again and select the appropriate option.\n\nNext, create the custom install command using your inputs. Example:\n\n```bash\nsudo bash wireguard.sh <<ANSWERS\nn\n51820\nclient\n2\ny\nANSWERS\n```\n\n**Note:** The install options may change in future versions of the script.\n</details>\n<details>\n<summary>\nView usage information for the WireGuard script.\n</summary>\n\n```\nUsage: bash wireguard.sh [options]\n\nOptions:\n\n  --addclient [client name]      add a new client\n  --dns1 [DNS server IP]         primary DNS server for new client (optional, default: Google Public DNS)\n  --dns2 [DNS server IP]         secondary DNS server for new client (optional)\n  --listclients                  list the names of existing clients\n  --removeclient [client name]   remove an existing client\n  --showclientqr [client name]   show QR code for an existing client\n  --uninstall                    remove WireGuard and delete all configuration\n  -y, --yes                      assume \"yes\" as answer to prompts when removing a client or removing WireGuard\n  -h, --help                     show this help message and exit\n\nInstall options (optional):\n\n  --auto                         auto install WireGuard using default or custom options\n  --serveraddr [DNS name or IP]  server address, must be a fully qualified domain name (FQDN) or an IPv4 address\n  --port [number]                port for WireGuard (1-65535, default: 51820)\n  --clientname [client name]     name for the first WireGuard client (default: client)\n  --dns1 [DNS server IP]         primary DNS server for first client (default: Google Public DNS)\n  --dns2 [DNS server IP]         secondary DNS server for first client\n\nTo customize options, you may also run this script without arguments.\n```\n</details>\n\n## Next steps\n\nAfter setup, you can run the script again to manage users or uninstall WireGuard.\n\nGet your computer or device to use the VPN. Please refer to:\n\n**[Configure WireGuard VPN Clients](docs/clients.md)**\n\n**Read [:book: VPN book](https://ko-fi.com/post/Support-this-project-and-get-access-to-supporter-o-O5O7FVF8J) to access [extra content](https://ko-fi.com/post/Support-this-project-and-get-access-to-supporter-o-O5O7FVF8J).**\n\nEnjoy your very own VPN! :sparkles::tada::rocket::sparkles:\n\n## Credits\n\nThis script is based on the great work of [Nyr and contributors](https://github.com/Nyr/wireguard-install), with enhancements and changes for compatibility with the [Setup IPsec VPN](https://github.com/hwdsl2/setup-ipsec-vpn) project.\n\n<details>\n<summary>\nList of enhancements over Nyr/wireguard-install.\n</summary>\n\n- Improved compatibility with Setup IPsec VPN\n- Improved script reliability, user input and output\n- Supports auto install using default or custom options\n- Supports using a DNS name as server address\n- Added support for openSUSE Linux\n- Supports listing existing VPN clients\n- Supports showing QR code for a client\n- Supports custom DNS server(s) for VPN clients\n- Supports command-line options for managing VPN clients\n- Optimizes `sysctl` settings for improved VPN performance\n- Improved creation of client config files when using `sudo`\n\n...and more!\n</details>\n\n## License\n\nMIT\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "wireguard-install.sh",
          "type": "blob",
          "size": 39.5244140625,
          "content": "#!/bin/bash\n#\n# https://github.com/hwdsl2/wireguard-install\n#\n# Based on the work of Nyr and contributors at:\n# https://github.com/Nyr/wireguard-install\n#\n# Copyright (c) 2022-2024 Lin Song <linsongui@gmail.com>\n# Copyright (c) 2020-2023 Nyr\n#\n# Released under the MIT License, see the accompanying file LICENSE.txt\n# or https://opensource.org/licenses/MIT\n\nexiterr()  { echo \"Error: $1\" >&2; exit 1; }\nexiterr2() { exiterr \"'apt-get install' failed.\"; }\nexiterr3() { exiterr \"'yum install' failed.\"; }\nexiterr4() { exiterr \"'zypper install' failed.\"; }\n\ncheck_ip() {\n\tIP_REGEX='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'\n\tprintf '%s' \"$1\" | tr -d '\\n' | grep -Eq \"$IP_REGEX\"\n}\n\ncheck_pvt_ip() {\n\tIPP_REGEX='^(10|127|172\\.(1[6-9]|2[0-9]|3[0-1])|192\\.168|169\\.254)\\.'\n\tprintf '%s' \"$1\" | tr -d '\\n' | grep -Eq \"$IPP_REGEX\"\n}\n\ncheck_dns_name() {\n\tFQDN_REGEX='^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$'\n\tprintf '%s' \"$1\" | tr -d '\\n' | grep -Eq \"$FQDN_REGEX\"\n}\n\ncheck_root() {\n\tif [ \"$(id -u)\" != 0 ]; then\n\t\texiterr \"This installer must be run as root. Try 'sudo bash $0'\"\n\tfi\n}\n\ncheck_shell() {\n\t# Detect Debian users running the script with \"sh\" instead of bash\n\tif readlink /proc/$$/exe | grep -q \"dash\"; then\n\t\texiterr 'This installer needs to be run with \"bash\", not \"sh\".'\n\tfi\n}\n\ncheck_kernel() {\n\t# Detect OpenVZ 6\n\tif [[ $(uname -r | cut -d \".\" -f 1) -eq 2 ]]; then\n\t\texiterr \"The system is running an old kernel, which is incompatible with this installer.\"\n\tfi\n}\n\ncheck_os() {\n\tif grep -qs \"ubuntu\" /etc/os-release; then\n\t\tos=\"ubuntu\"\n\t\tos_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '\"' -f 2 | tr -d '.')\n\telif [[ -e /etc/debian_version ]]; then\n\t\tos=\"debian\"\n\t\tos_version=$(grep -oE '[0-9]+' /etc/debian_version | head -1)\n\telif [[ -e /etc/almalinux-release || -e /etc/rocky-release || -e /etc/centos-release ]]; then\n\t\tos=\"centos\"\n\t\tos_version=$(grep -shoE '[0-9]+' /etc/almalinux-release /etc/rocky-release /etc/centos-release | head -1)\n\telif [[ -e /etc/fedora-release ]]; then\n\t\tos=\"fedora\"\n\t\tos_version=$(grep -oE '[0-9]+' /etc/fedora-release | head -1)\n\telif [[ -e /etc/SUSE-brand && \"$(head -1 /etc/SUSE-brand)\" == \"openSUSE\" ]]; then\n\t\tos=\"openSUSE\"\n\t\tos_version=$(tail -1 /etc/SUSE-brand | grep -oE '[0-9\\\\.]+')\n\telse\n\t\texiterr \"This installer seems to be running on an unsupported distribution.\nSupported distros are Ubuntu, Debian, AlmaLinux, Rocky Linux, CentOS, Fedora and openSUSE.\"\n\tfi\n}\n\ncheck_os_ver() {\n\tif [[ \"$os\" == \"ubuntu\" && \"$os_version\" -lt 2004 ]]; then\n\t\texiterr \"Ubuntu 20.04 or higher is required to use this installer.\nThis version of Ubuntu is too old and unsupported.\"\n\tfi\n\tif [[ \"$os\" == \"debian\" && \"$os_version\" -lt 11 ]]; then\n\t\texiterr \"Debian 11 or higher is required to use this installer.\nThis version of Debian is too old and unsupported.\"\n\tfi\n\tif [[ \"$os\" == \"centos\" && \"$os_version\" -lt 8 ]]; then\n\t\texiterr \"CentOS 8 or higher is required to use this installer.\nThis version of CentOS is too old and unsupported.\"\n\tfi\n}\n\ncheck_container() {\n\tif systemd-detect-virt -cq 2>/dev/null; then\n\t\texiterr \"This system is running inside a container, which is not supported by this installer.\"\n\tfi\n}\n\nset_client_name() {\n\t# Allow a limited set of characters to avoid conflicts\n\t# Limit to 15 characters for compatibility with Linux clients\n\tclient=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< \"$unsanitized_client\" | cut -c-15)\n}\n\nparse_args() {\n\twhile [ \"$#\" -gt 0 ]; do\n\t\tcase $1 in\n\t\t\t--auto)\n\t\t\t\tauto=1\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--addclient)\n\t\t\t\tadd_client=1\n\t\t\t\tunsanitized_client=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--listclients)\n\t\t\t\tlist_clients=1\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--removeclient)\n\t\t\t\tremove_client=1\n\t\t\t\tunsanitized_client=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--showclientqr)\n\t\t\t\tshow_client_qr=1\n\t\t\t\tunsanitized_client=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--uninstall)\n\t\t\t\tremove_wg=1\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--serveraddr)\n\t\t\t\tserver_addr=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--port)\n\t\t\t\tserver_port=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--clientname)\n\t\t\t\tfirst_client_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--dns1)\n\t\t\t\tdns1=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--dns2)\n\t\t\t\tdns2=\"$2\"\n\t\t\t\tshift\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t-y|--yes)\n\t\t\t\tassume_yes=1\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tshow_usage\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tshow_usage \"Unknown parameter: $1\"\n\t\t\t\t;;\n\t\tesac\n\tdone\n}\n\ncheck_args() {\n\tif [ \"$auto\" != 0 ] && [ -e \"$WG_CONF\" ]; then\n\t\tshow_usage \"Invalid parameter '--auto'. WireGuard is already set up on this server.\"\n\tfi\n\tif [ \"$((add_client + list_clients + remove_client + show_client_qr))\" -gt 1 ]; then\n\t\tshow_usage \"Invalid parameters. Specify only one of '--addclient', '--listclients', '--removeclient' or '--showclientqr'.\"\n\tfi\n\tif [ \"$remove_wg\" = 1 ]; then\n\t\tif [ \"$((add_client + list_clients + remove_client + show_client_qr + auto))\" -gt 0 ]; then\n\t\t\tshow_usage \"Invalid parameters. '--uninstall' cannot be specified with other parameters.\"\n\t\tfi\n\tfi\n\tif [ ! -e \"$WG_CONF\" ]; then\n\t\tst_text=\"You must first set up WireGuard before\"\n\t\t[ \"$add_client\" = 1 ] && exiterr \"$st_text adding a client.\"\n\t\t[ \"$list_clients\" = 1 ] && exiterr \"$st_text listing clients.\"\n\t\t[ \"$remove_client\" = 1 ] && exiterr \"$st_text removing a client.\"\n\t\t[ \"$show_client_qr\" = 1 ] && exiterr \"$st_text showing QR code for a client.\"\n\t\t[ \"$remove_wg\" = 1 ] && exiterr \"Cannot remove WireGuard because it has not been set up on this server.\"\n\tfi\n\tif [ \"$((add_client + remove_client + show_client_qr))\" = 1 ] && [ -n \"$first_client_name\" ]; then\n\t\tshow_usage \"Invalid parameters. '--clientname' can only be specified when installing WireGuard.\"\n\tfi\n\tif [ -n \"$server_addr\" ] || [ -n \"$server_port\" ] || [ -n \"$first_client_name\" ]; then\n\t\t\tif [ -e \"$WG_CONF\" ]; then\n\t\t\t\tshow_usage \"Invalid parameters. WireGuard is already set up on this server.\"\n\t\t\telif [ \"$auto\" = 0 ]; then\n\t\t\t\tshow_usage \"Invalid parameters. You must specify '--auto' when using these parameters.\"\n\t\t\tfi\n\tfi\n\tif [ \"$add_client\" = 1 ]; then\n\t\tset_client_name\n\t\tif [ -z \"$client\" ]; then\n\t\t\texiterr \"Invalid client name. Use one word only, no special characters except '-' and '_'.\"\n\t\telif grep -q \"^# BEGIN_PEER $client$\" \"$WG_CONF\"; then\n\t\t\texiterr \"$client: invalid name. Client already exists.\"\n\t\tfi\n\tfi\n\tif [ \"$remove_client\" = 1 ] || [ \"$show_client_qr\" = 1 ]; then\n\t\tset_client_name\n\t\tif [ -z \"$client\" ] || ! grep -q \"^# BEGIN_PEER $client$\" \"$WG_CONF\"; then\n\t\t\texiterr \"Invalid client name, or client does not exist.\"\n\t\tfi\n\tfi\n\tif [ -n \"$server_addr\" ] && { ! check_dns_name \"$server_addr\" && ! check_ip \"$server_addr\"; }; then\n\t\texiterr \"Invalid server address. Must be a fully qualified domain name (FQDN) or an IPv4 address.\"\n\tfi\n\tif [ -n \"$first_client_name\" ]; then\n\t\tunsanitized_client=\"$first_client_name\"\n\t\tset_client_name\n\t\tif [ -z \"$client\" ]; then\n\t\t\texiterr \"Invalid client name. Use one word only, no special characters except '-' and '_'.\"\n\t\tfi\n\tfi\n\tif [ -n \"$server_port\" ]; then\n\t\tif [[ ! \"$server_port\" =~ ^[0-9]+$ || \"$server_port\" -gt 65535 ]]; then\n\t\t\texiterr \"Invalid port. Must be an integer between 1 and 65535.\"\n\t\tfi\n\tfi\n\tif [ -n \"$dns1\" ]; then\n\t\tif [ -e \"$WG_CONF\" ] && [ \"$add_client\" = 0 ]; then\n\t\t\tshow_usage \"Invalid parameters. Custom DNS server(s) can only be specified when installing WireGuard or adding a client.\"\n\t\tfi\n\tfi\n\tif { [ -n \"$dns1\" ] && ! check_ip \"$dns1\"; } \\\n\t\t|| { [ -n \"$dns2\" ] && ! check_ip \"$dns2\"; }; then\n\t\texiterr \"Invalid DNS server(s).\"\n\tfi\n\tif [ -z \"$dns1\" ] && [ -n \"$dns2\" ]; then\n\t\tshow_usage \"Invalid DNS server. --dns2 cannot be specified without --dns1.\"\n\tfi\n\tif [ -n \"$dns1\" ] && [ -n \"$dns2\" ]; then\n\t\tdns=\"$dns1, $dns2\"\n\telif [ -n \"$dns1\" ]; then\n\t\tdns=\"$dns1\"\n\telse\n\t\tdns=\"8.8.8.8, 8.8.4.4\"\n\tfi\n}\n\ncheck_nftables() {\n\tif [ \"$os\" = \"centos\" ]; then\n\t\tif grep -qs \"hwdsl2 VPN script\" /etc/sysconfig/nftables.conf \\\n\t\t\t|| systemctl is-active --quiet nftables 2>/dev/null; then\n\t\t\texiterr \"This system has nftables enabled, which is not supported by this installer.\"\n\t\tfi\n\tfi\n}\n\ninstall_wget() {\n\t# Detect some Debian minimal setups where neither wget nor curl are installed\n\tif ! hash wget 2>/dev/null && ! hash curl 2>/dev/null; then\n\t\tif [ \"$auto\" = 0 ]; then\n\t\t\techo \"Wget is required to use this installer.\"\n\t\t\tread -n1 -r -p \"Press any key to install Wget and continue...\"\n\t\tfi\n\t\texport DEBIAN_FRONTEND=noninteractive\n\t\t(\n\t\t\tset -x\n\t\t\tapt-get -yqq update || apt-get -yqq update\n\t\t\tapt-get -yqq install wget >/dev/null\n\t\t) || exiterr2\n\tfi\n}\n\ninstall_iproute() {\n\tif ! hash ip 2>/dev/null; then\n\t\tif [ \"$auto\" = 0 ]; then\n\t\t\techo \"iproute is required to use this installer.\"\n\t\t\tread -n1 -r -p \"Press any key to install iproute and continue...\"\n\t\tfi\n\t\tif [ \"$os\" = \"debian\" ] || [ \"$os\" = \"ubuntu\" ]; then\n\t\t\texport DEBIAN_FRONTEND=noninteractive\n\t\t\t(\n\t\t\t\tset -x\n\t\t\t\tapt-get -yqq update || apt-get -yqq update\n\t\t\t\tapt-get -yqq install iproute2 >/dev/null\n\t\t\t) || exiterr2\n\t\telif [ \"$os\" = \"openSUSE\" ]; then\n\t\t\t(\n\t\t\t\tset -x\n\t\t\t\tzypper install iproute2 >/dev/null\n\t\t\t) || exiterr4\n\t\telse\n\t\t\t(\n\t\t\t\tset -x\n\t\t\t\tyum -y -q install iproute >/dev/null\n\t\t\t) || exiterr3\n\t\tfi\n\tfi\n}\n\nshow_header() {\ncat <<'EOF'\n\nWireGuard Script\nhttps://github.com/hwdsl2/wireguard-install\nEOF\n}\n\nshow_header2() {\ncat <<'EOF'\n\nWelcome to this WireGuard server installer!\nGitHub: https://github.com/hwdsl2/wireguard-install\n\nEOF\n}\n\nshow_header3() {\ncat <<'EOF'\n\nCopyright (c) 2022-2024 Lin Song\nCopyright (c) 2020-2023 Nyr\nEOF\n}\n\nshow_usage() {\n\tif [ -n \"$1\" ]; then\n\t\techo \"Error: $1\" >&2\n\tfi\n\tshow_header\n\tshow_header3\ncat 1>&2 <<EOF\n\nUsage: bash $0 [options]\n\nOptions:\n\n  --addclient [client name]      add a new client\n  --dns1 [DNS server IP]         primary DNS server for new client (optional, default: Google Public DNS)\n  --dns2 [DNS server IP]         secondary DNS server for new client (optional)\n  --listclients                  list the names of existing clients\n  --removeclient [client name]   remove an existing client\n  --showclientqr [client name]   show QR code for an existing client\n  --uninstall                    remove WireGuard and delete all configuration\n  -y, --yes                      assume \"yes\" as answer to prompts when removing a client or removing WireGuard\n  -h, --help                     show this help message and exit\n\nInstall options (optional):\n\n  --auto                         auto install WireGuard using default or custom options\n  --serveraddr [DNS name or IP]  server address, must be a fully qualified domain name (FQDN) or an IPv4 address\n  --port [number]                port for WireGuard (1-65535, default: 51820)\n  --clientname [client name]     name for the first WireGuard client (default: client)\n  --dns1 [DNS server IP]         primary DNS server for first client (default: Google Public DNS)\n  --dns2 [DNS server IP]         secondary DNS server for first client\n\nTo customize options, you may also run this script without arguments.\nEOF\n\texit 1\n}\n\nshow_welcome() {\n\tif [ \"$auto\" = 0 ]; then\n\t\tshow_header2\n\t\techo 'I need to ask you a few questions before starting setup.'\n\t\techo 'You can use the default options and just press enter if you are OK with them.'\n\telse\n\t\tshow_header\n\t\top_text=default\n\t\tif [ -n \"$server_addr\" ] || [ -n \"$server_port\" ] \\\n\t\t\t|| [ -n \"$first_client_name\" ] || [ -n \"$dns1\" ]; then\n\t\t\top_text=custom\n\t\tfi\n\t\techo\n\t\techo \"Starting WireGuard setup using $op_text options.\"\n\tfi\n}\n\nshow_dns_name_note() {\ncat <<EOF\n\nNote: Make sure this DNS name '$1'\n      resolves to the IPv4 address of this server.\nEOF\n}\n\nenter_server_address() {\n\techo\n\techo \"Do you want WireGuard VPN clients to connect to this server using a DNS name,\"\n\tprintf \"e.g. vpn.example.com, instead of its IP address? [y/N] \"\n\tread -r response\n\tcase $response in\n\t\t[yY][eE][sS]|[yY])\n\t\t\tuse_dns_name=1\n\t\t\techo\n\t\t\t;;\n\t\t*)\n\t\t\tuse_dns_name=0\n\t\t\t;;\n\tesac\n\tif [ \"$use_dns_name\" = 1 ]; then\n\t\tread -rp \"Enter the DNS name of this VPN server: \" server_addr_i\n\t\tuntil check_dns_name \"$server_addr_i\"; do\n\t\t\techo \"Invalid DNS name. You must enter a fully qualified domain name (FQDN).\"\n\t\t\tread -rp \"Enter the DNS name of this VPN server: \" server_addr_i\n\t\tdone\n\t\tip=\"$server_addr_i\"\n\t\tshow_dns_name_note \"$ip\"\n\telse\n\t\tdetect_ip\n\t\tcheck_nat_ip\n\tfi\n}\n\nfind_public_ip() {\n\tip_url1=\"http://ipv4.icanhazip.com\"\n\tip_url2=\"http://ip1.dynupdate.no-ip.com\"\n\t# Get public IP and sanitize with grep\n\tget_public_ip=$(grep -m 1 -oE '^[0-9]{1,3}(\\.[0-9]{1,3}){3}$' <<< \"$(wget -T 10 -t 1 -4qO- \"$ip_url1\" || curl -m 10 -4Ls \"$ip_url1\")\")\n\tif ! check_ip \"$get_public_ip\"; then\n\t\tget_public_ip=$(grep -m 1 -oE '^[0-9]{1,3}(\\.[0-9]{1,3}){3}$' <<< \"$(wget -T 10 -t 1 -4qO- \"$ip_url2\" || curl -m 10 -4Ls \"$ip_url2\")\")\n\tfi\n}\n\ndetect_ip() {\n\t# If system has a single IPv4, it is selected automatically.\n\tif [[ $(ip -4 addr | grep inet | grep -vEc '127(\\.[0-9]{1,3}){3}') -eq 1 ]]; then\n\t\tip=$(ip -4 addr | grep inet | grep -vE '127(\\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\\.[0-9]{1,3}){3}')\n\telse\n\t\t# Use the IP address on the default route\n\t\tip=$(ip -4 route get 1 | sed 's/ uid .*//' | awk '{print $NF;exit}' 2>/dev/null)\n\t\tif ! check_ip \"$ip\"; then\n\t\t\tfind_public_ip\n\t\t\tip_match=0\n\t\t\tif [ -n \"$get_public_ip\" ]; then\n\t\t\t\tip_list=$(ip -4 addr | grep inet | grep -vE '127(\\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\\.[0-9]{1,3}){3}')\n\t\t\t\twhile IFS= read -r line; do\n\t\t\t\t\tif [ \"$line\" = \"$get_public_ip\" ]; then\n\t\t\t\t\t\tip_match=1\n\t\t\t\t\t\tip=\"$line\"\n\t\t\t\t\tfi\n\t\t\t\tdone <<< \"$ip_list\"\n\t\t\tfi\n\t\t\tif [ \"$ip_match\" = 0 ]; then\n\t\t\t\tif [ \"$auto\" = 0 ]; then\n\t\t\t\t\techo\n\t\t\t\t\techo \"Which IPv4 address should be used?\"\n\t\t\t\t\tnum_of_ip=$(ip -4 addr | grep inet | grep -vEc '127(\\.[0-9]{1,3}){3}')\n\t\t\t\t\tip -4 addr | grep inet | grep -vE '127(\\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\\.[0-9]{1,3}){3}' | nl -s ') '\n\t\t\t\t\tread -rp \"IPv4 address [1]: \" ip_num\n\t\t\t\t\tuntil [[ -z \"$ip_num\" || \"$ip_num\" =~ ^[0-9]+$ && \"$ip_num\" -le \"$num_of_ip\" ]]; do\n\t\t\t\t\t\techo \"$ip_num: invalid selection.\"\n\t\t\t\t\t\tread -rp \"IPv4 address [1]: \" ip_num\n\t\t\t\t\tdone\n\t\t\t\t\t[[ -z \"$ip_num\" ]] && ip_num=1\n\t\t\t\telse\n\t\t\t\t\tip_num=1\n\t\t\t\tfi\n\t\t\t\tip=$(ip -4 addr | grep inet | grep -vE '127(\\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\\.[0-9]{1,3}){3}' | sed -n \"$ip_num\"p)\n\t\t\tfi\n\t\tfi\n\tfi\n\tif ! check_ip \"$ip\"; then\n\t\techo \"Error: Could not detect this server's IP address.\" >&2\n\t\techo \"Abort. No changes were made.\" >&2\n\t\texit 1\n\tfi\n}\n\ncheck_nat_ip() {\n\t# If $ip is a private IP address, the server must be behind NAT\n\tif check_pvt_ip \"$ip\"; then\n\t\tfind_public_ip\n\t\tif ! check_ip \"$get_public_ip\"; then\n\t\t\tif [ \"$auto\" = 0 ]; then\n\t\t\t\techo\n\t\t\t\techo \"This server is behind NAT. What is the public IPv4 address?\"\n\t\t\t\tread -rp \"Public IPv4 address: \" public_ip\n\t\t\t\tuntil check_ip \"$public_ip\"; do\n\t\t\t\t\techo \"Invalid input.\"\n\t\t\t\t\tread -rp \"Public IPv4 address: \" public_ip\n\t\t\t\tdone\n\t\t\telse\n\t\t\t\techo \"Error: Could not detect this server's public IP.\" >&2\n\t\t\t\techo \"Abort. No changes were made.\" >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\telse\n\t\t\tpublic_ip=\"$get_public_ip\"\n\t\tfi\n\tfi\n}\n\nshow_config() {\n\tif [ \"$auto\" != 0 ]; then\n\t\techo\n\t\tif [ -n \"$server_addr\" ]; then\n\t\t\techo \"Server address: $server_addr\"\n\t\telse\n\t\t\tprintf '%s' \"Server IP: \"\n\t\t\t[ -n \"$public_ip\" ] && printf '%s\\n' \"$public_ip\" || printf '%s\\n' \"$ip\"\n\t\tfi\n\t\t[ -n \"$server_port\" ] && port_text=\"$server_port\" || port_text=51820\n\t\t[ -n \"$first_client_name\" ] && client_text=\"$client\" || client_text=client\n\t\tif [ -n \"$dns1\" ] && [ -n \"$dns2\" ]; then\n\t\t\tdns_text=\"$dns1, $dns2\"\n\t\telif [ -n \"$dns1\" ]; then\n\t\t\tdns_text=\"$dns1\"\n\t\telse\n\t\t\tdns_text=\"Google Public DNS\"\n\t\tfi\n\t\techo \"Port: UDP/$port_text\"\n\t\techo \"Client name: $client_text\"\n\t\techo \"Client DNS: $dns_text\"\n\tfi\n}\n\ndetect_ipv6() {\n\tip6=\"\"\n\tif [[ $(ip -6 addr | grep -c 'inet6 [23]') -ne 0 ]]; then\n\t\tip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | sed -n 1p)\n\tfi\n}\n\nselect_port() {\n\tif [ \"$auto\" = 0 ]; then\n\t\techo\n\t\techo \"Which port should WireGuard listen to?\"\n\t\tread -rp \"Port [51820]: \" port\n\t\tuntil [[ -z \"$port\" || \"$port\" =~ ^[0-9]+$ && \"$port\" -le 65535 ]]; do\n\t\t\techo \"$port: invalid port.\"\n\t\t\tread -rp \"Port [51820]: \" port\n\t\tdone\n\t\t[[ -z \"$port\" ]] && port=51820\n\telse\n\t\t[ -n \"$server_port\" ] && port=\"$server_port\" || port=51820\n\tfi\n}\n\nenter_custom_dns() {\n\tread -rp \"Enter primary DNS server: \" dns1\n\tuntil check_ip \"$dns1\"; do\n\t\techo \"Invalid DNS server.\"\n\t\tread -rp \"Enter primary DNS server: \" dns1\n\tdone\n\tread -rp \"Enter secondary DNS server (Enter to skip): \" dns2\n\tuntil [ -z \"$dns2\" ] || check_ip \"$dns2\"; do\n\t\techo \"Invalid DNS server.\"\n\t\tread -rp \"Enter secondary DNS server (Enter to skip): \" dns2\n\tdone\n}\n\nenter_first_client_name() {\n\tif [ \"$auto\" = 0 ]; then\n\t\techo\n\t\techo \"Enter a name for the first client:\"\n\t\tread -rp \"Name [client]: \" unsanitized_client\n\t\tset_client_name\n\t\t[[ -z \"$client\" ]] && client=client\n\telse\n\t\tif [ -n \"$first_client_name\" ]; then\n\t\t\tunsanitized_client=\"$first_client_name\"\n\t\t\tset_client_name\n\t\telse\n\t\t\tclient=client\n\t\tfi\n\tfi\n}\n\nshow_setup_ready() {\n\tif [ \"$auto\" = 0 ]; then\n\t\techo\n\t\techo \"WireGuard installation is ready to begin.\"\n\tfi\n}\n\ncheck_firewall() {\n\t# Install a firewall if firewalld or iptables are not already available\n\tif ! systemctl is-active --quiet firewalld.service && ! hash iptables 2>/dev/null; then\n\t\tif [[ \"$os\" == \"centos\" || \"$os\" == \"fedora\" ]]; then\n\t\t\tfirewall=\"firewalld\"\n\t\telif [[ \"$os\" == \"openSUSE\" ]]; then\n\t\t\tfirewall=\"firewalld\"\n\t\telif [[ \"$os\" == \"debian\" || \"$os\" == \"ubuntu\" ]]; then\n\t\t\tfirewall=\"iptables\"\n\t\tfi\n\t\tif [[ \"$firewall\" == \"firewalld\" ]]; then\n\t\t\t# We don't want to silently enable firewalld, so we give a subtle warning\n\t\t\t# If the user continues, firewalld will be installed and enabled during setup\n\t\t\techo\n\t\t\techo \"Note: firewalld, which is required to manage routing tables, will also be installed.\"\n\t\tfi\n\tfi\n}\n\nabort_and_exit() {\n\techo \"Abort. No changes were made.\" >&2\n\texit 1\n}\n\nconfirm_setup() {\n\tif [ \"$auto\" = 0 ]; then\n\t\tprintf \"Do you want to continue? [Y/n] \"\n\t\tread -r response\n\t\tcase $response in\n\t\t\t[yY][eE][sS]|[yY]|'')\n\t\t\t\t:\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tabort_and_exit\n\t\t\t\t;;\n\t\tesac\n\tfi\n}\n\nshow_start_setup() {\n\techo\n\techo \"Installing WireGuard, please wait...\"\n}\n\ninstall_pkgs() {\n\tif [[ \"$os\" == \"ubuntu\" ]]; then\n\t\texport DEBIAN_FRONTEND=noninteractive\n\t\t(\n\t\t\tset -x\n\t\t\tapt-get -yqq update || apt-get -yqq update\n\t\t\tapt-get -yqq install wireguard qrencode $firewall >/dev/null\n\t\t) || exiterr2\n\telif [[ \"$os\" == \"debian\" ]]; then\n\t\texport DEBIAN_FRONTEND=noninteractive\n\t\t(\n\t\t\tset -x\n\t\t\tapt-get -yqq update || apt-get -yqq update\n\t\t\tapt-get -yqq install wireguard qrencode $firewall >/dev/null\n\t\t) || exiterr2\n\telif [[ \"$os\" == \"centos\" && \"$os_version\" -eq 9 ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tyum -y -q install epel-release >/dev/null\n\t\t\tyum -y -q install wireguard-tools qrencode $firewall >/dev/null 2>&1\n\t\t) || exiterr3\n\t\tmkdir -p /etc/wireguard/\n\telif [[ \"$os\" == \"centos\" && \"$os_version\" -eq 8 ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tyum -y -q install epel-release elrepo-release >/dev/null\n\t\t\tyum -y -q --nobest install kmod-wireguard >/dev/null 2>&1\n\t\t\tyum -y -q install wireguard-tools qrencode $firewall >/dev/null 2>&1\n\t\t) || exiterr3\n\t\tmkdir -p /etc/wireguard/\n\telif [[ \"$os\" == \"fedora\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tdnf install -y wireguard-tools qrencode $firewall >/dev/null\n\t\t) || exiterr \"'dnf install' failed.\"\n\t\tmkdir -p /etc/wireguard/\n\telif [[ \"$os\" == \"openSUSE\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tzypper install -y wireguard-tools qrencode $firewall >/dev/null\n\t\t) || exiterr4\n\t\tmkdir -p /etc/wireguard/\n\tfi\n\t[ ! -d /etc/wireguard ] && exiterr2\n\t# If firewalld was just installed, enable it\n\tif [[ \"$firewall\" == \"firewalld\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tsystemctl enable --now firewalld.service >/dev/null 2>&1\n\t\t)\n\tfi\n}\n\nremove_pkgs() {\n\tif [[ \"$os\" == \"ubuntu\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\trm -rf /etc/wireguard/\n\t\t\tapt-get remove --purge -y wireguard wireguard-tools >/dev/null\n\t\t)\n\telif [[ \"$os\" == \"debian\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\trm -rf /etc/wireguard/\n\t\t\tapt-get remove --purge -y wireguard wireguard-tools >/dev/null\n\t\t)\n\telif [[ \"$os\" == \"centos\" && \"$os_version\" -eq 9 ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tyum -y -q remove wireguard-tools >/dev/null\n\t\t\trm -rf /etc/wireguard/\n\t\t)\n\telif [[ \"$os\" == \"centos\" && \"$os_version\" -le 8 ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tyum -y -q remove kmod-wireguard wireguard-tools >/dev/null\n\t\t\trm -rf /etc/wireguard/\n\t\t)\n\telif [[ \"$os\" == \"fedora\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tdnf remove -y wireguard-tools >/dev/null\n\t\t\trm -rf /etc/wireguard/\n\t\t)\n\telif [[ \"$os\" == \"openSUSE\" ]]; then\n\t\t(\n\t\t\tset -x\n\t\t\tzypper remove -y wireguard-tools >/dev/null\n\t\t\trm -rf /etc/wireguard/\n\t\t)\n\tfi\n}\n\ncreate_server_config() {\n\t# Generate wg0.conf\n\tcat << EOF > \"$WG_CONF\"\n# Do not alter the commented lines\n# They are used by wireguard-install\n# ENDPOINT $([[ -n \"$public_ip\" ]] && echo \"$public_ip\" || echo \"$ip\")\n\n[Interface]\nAddress = 10.7.0.1/24$([[ -n \"$ip6\" ]] && echo \", fddd:2c4:2c4:2c4::1/64\")\nPrivateKey = $(wg genkey)\nListenPort = $port\n\nEOF\n\tchmod 600 \"$WG_CONF\"\n}\n\ncreate_firewall_rules() {\n\tif systemctl is-active --quiet firewalld.service; then\n\t\t# Using both permanent and not permanent rules to avoid a firewalld reload\n\t\tfirewall-cmd -q --add-port=\"$port\"/udp\n\t\tfirewall-cmd -q --zone=trusted --add-source=10.7.0.0/24\n\t\tfirewall-cmd -q --permanent --add-port=\"$port\"/udp\n\t\tfirewall-cmd -q --permanent --zone=trusted --add-source=10.7.0.0/24\n\t\t# Set NAT for the VPN subnet\n\t\tfirewall-cmd -q --direct --add-rule ipv4 nat POSTROUTING 0 -s 10.7.0.0/24 ! -d 10.7.0.0/24 -j MASQUERADE\n\t\tfirewall-cmd -q --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -s 10.7.0.0/24 ! -d 10.7.0.0/24 -j MASQUERADE\n\t\tif [[ -n \"$ip6\" ]]; then\n\t\t\tfirewall-cmd -q --zone=trusted --add-source=fddd:2c4:2c4:2c4::/64\n\t\t\tfirewall-cmd -q --permanent --zone=trusted --add-source=fddd:2c4:2c4:2c4::/64\n\t\t\tfirewall-cmd -q --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:2c4:2c4:2c4::/64 ! -d fddd:2c4:2c4:2c4::/64 -j MASQUERADE\n\t\t\tfirewall-cmd -q --permanent --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:2c4:2c4:2c4::/64 ! -d fddd:2c4:2c4:2c4::/64 -j MASQUERADE\n\t\tfi\n\telse\n\t\t# Create a service to set up persistent iptables rules\n\t\tiptables_path=$(command -v iptables)\n\t\tip6tables_path=$(command -v ip6tables)\n\t\t# nf_tables is not available as standard in OVZ kernels. So use iptables-legacy\n\t\t# if we are in OVZ, with a nf_tables backend and iptables-legacy is available.\n\t\tif [[ $(systemd-detect-virt) == \"openvz\" ]] && readlink -f \"$(command -v iptables)\" | grep -q \"nft\" && hash iptables-legacy 2>/dev/null; then\n\t\t\tiptables_path=$(command -v iptables-legacy)\n\t\t\tip6tables_path=$(command -v ip6tables-legacy)\n\t\tfi\n\t\techo \"[Unit]\nBefore=network.target\n[Service]\nType=oneshot\nExecStart=$iptables_path -t nat -A POSTROUTING -s 10.7.0.0/24 ! -d 10.7.0.0/24 -j MASQUERADE\nExecStart=$iptables_path -I INPUT -p udp --dport $port -j ACCEPT\nExecStart=$iptables_path -I FORWARD -s 10.7.0.0/24 -j ACCEPT\nExecStart=$iptables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\nExecStop=$iptables_path -t nat -D POSTROUTING -s 10.7.0.0/24 ! -d 10.7.0.0/24 -j MASQUERADE\nExecStop=$iptables_path -D INPUT -p udp --dport $port -j ACCEPT\nExecStop=$iptables_path -D FORWARD -s 10.7.0.0/24 -j ACCEPT\nExecStop=$iptables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\" > /etc/systemd/system/wg-iptables.service\n\t\tif [[ -n \"$ip6\" ]]; then\n\t\t\techo \"ExecStart=$ip6tables_path -t nat -A POSTROUTING -s fddd:2c4:2c4:2c4::/64 ! -d fddd:2c4:2c4:2c4::/64 -j MASQUERADE\nExecStart=$ip6tables_path -I FORWARD -s fddd:2c4:2c4:2c4::/64 -j ACCEPT\nExecStart=$ip6tables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\nExecStop=$ip6tables_path -t nat -D POSTROUTING -s fddd:2c4:2c4:2c4::/64 ! -d fddd:2c4:2c4:2c4::/64 -j MASQUERADE\nExecStop=$ip6tables_path -D FORWARD -s fddd:2c4:2c4:2c4::/64 -j ACCEPT\nExecStop=$ip6tables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\" >> /etc/systemd/system/wg-iptables.service\n\t\tfi\n\t\techo \"RemainAfterExit=yes\n[Install]\nWantedBy=multi-user.target\" >> /etc/systemd/system/wg-iptables.service\n\t\t(\n\t\t\tset -x\n\t\t\tsystemctl enable --now wg-iptables.service >/dev/null 2>&1\n\t\t)\n\tfi\n}\n\nremove_firewall_rules() {\n\tport=$(grep '^ListenPort' \"$WG_CONF\" | cut -d \" \" -f 3)\n\tif systemctl is-active --quiet firewalld.service; then\n\t\tip=$(firewall-cmd --direct --get-rules ipv4 nat POSTROUTING | grep '\\-s 10.7.0.0/24 '\"'\"'!'\"'\"' -d 10.7.0.0/24' | grep -oE '[^ ]+$')\n\t\t# Using both permanent and not permanent rules to avoid a firewalld reload.\n\t\tfirewall-cmd -q --remove-port=\"$port\"/udp\n\t\tfirewall-cmd -q --zone=trusted --remove-source=10.7.0.0/24\n\t\tfirewall-cmd -q --permanent --remove-port=\"$port\"/udp\n\t\tfirewall-cmd -q --permanent --zone=trusted --remove-source=10.7.0.0/24\n\t\tfirewall-cmd -q --direct --remove-rule ipv4 nat POSTROUTING 0 -s 10.7.0.0/24 ! -d 10.7.0.0/24 -j MASQUERADE\n\t\tfirewall-cmd -q --permanent --direct --remove-rule ipv4 nat POSTROUTING 0 -s 10.7.0.0/24 ! -d 10.7.0.0/24 -j MASQUERADE\n\t\tif grep -qs 'fddd:2c4:2c4:2c4::1/64' \"$WG_CONF\"; then\n\t\t\tip6=$(firewall-cmd --direct --get-rules ipv6 nat POSTROUTING | grep '\\-s fddd:2c4:2c4:2c4::/64 '\"'\"'!'\"'\"' -d fddd:2c4:2c4:2c4::/64' | grep -oE '[^ ]+$')\n\t\t\tfirewall-cmd -q --zone=trusted --remove-source=fddd:2c4:2c4:2c4::/64\n\t\t\tfirewall-cmd -q --permanent --zone=trusted --remove-source=fddd:2c4:2c4:2c4::/64\n\t\t\tfirewall-cmd -q --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:2c4:2c4:2c4::/64 ! -d fddd:2c4:2c4:2c4::/64 -j MASQUERADE\n\t\t\tfirewall-cmd -q --permanent --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:2c4:2c4:2c4::/64 ! -d fddd:2c4:2c4:2c4::/64 -j MASQUERADE\n\t\tfi\n\telse\n\t\tsystemctl disable --now wg-iptables.service\n\t\trm -f /etc/systemd/system/wg-iptables.service\n\tfi\n}\n\nget_export_dir() {\n\texport_to_home_dir=0\n\texport_dir=~/\n\tif [ -n \"$SUDO_USER\" ] && getent group \"$SUDO_USER\" >/dev/null 2>&1; then\n\t\tuser_home_dir=$(getent passwd \"$SUDO_USER\" 2>/dev/null | cut -d: -f6)\n\t\tif [ -d \"$user_home_dir\" ] && [ \"$user_home_dir\" != \"/\" ]; then\n\t\t\texport_dir=\"$user_home_dir/\"\n\t\t\texport_to_home_dir=1\n\t\tfi\n\tfi\n}\n\nselect_dns() {\n\tif [ \"$auto\" = 0 ]; then\n\t\techo\n\t\techo \"Select a DNS server for the client:\"\n\t\techo \"   1) Current system resolvers\"\n\t\techo \"   2) Google Public DNS\"\n\t\techo \"   3) Cloudflare DNS\"\n\t\techo \"   4) OpenDNS\"\n\t\techo \"   5) Quad9\"\n\t\techo \"   6) AdGuard DNS\"\n\t\techo \"   7) Custom\"\n\t\tread -rp \"DNS server [2]: \" dns\n\t\tuntil [[ -z \"$dns\" || \"$dns\" =~ ^[1-7]$ ]]; do\n\t\t\techo \"$dns: invalid selection.\"\n\t\t\tread -rp \"DNS server [2]: \" dns\n\t\tdone\n\telse\n\t\tdns=2\n\tfi\n\t\t# DNS\n\tcase \"$dns\" in\n\t\t1)\n\t\t\t# Locate the proper resolv.conf\n\t\t\t# Needed for systems running systemd-resolved\n\t\t\tif grep '^nameserver' \"/etc/resolv.conf\" | grep -qv '127.0.0.53' ; then\n\t\t\t\tresolv_conf=\"/etc/resolv.conf\"\n\t\t\telse\n\t\t\t\tresolv_conf=\"/run/systemd/resolve/resolv.conf\"\n\t\t\tfi\n\t\t\t# Extract nameservers and provide them in the required format\n\t\t\tdns=$(grep -v '^#\\|^;' \"$resolv_conf\" | grep '^nameserver' | grep -v '127.0.0.53' | grep -oE '[0-9]{1,3}(\\.[0-9]{1,3}){3}' | xargs | sed -e 's/ /, /g')\n\t\t;;\n\t\t2|\"\")\n\t\t\tdns=\"8.8.8.8, 8.8.4.4\"\n\t\t;;\n\t\t3)\n\t\t\tdns=\"1.1.1.1, 1.0.0.1\"\n\t\t;;\n\t\t4)\n\t\t\tdns=\"208.67.222.222, 208.67.220.220\"\n\t\t;;\n\t\t5)\n\t\t\tdns=\"9.9.9.9, 149.112.112.112\"\n\t\t;;\n\t\t6)\n\t\t\tdns=\"94.140.14.14, 94.140.15.15\"\n\t\t;;\n\t\t7)\n\t\t\tenter_custom_dns\n\t\t\tif [ -n \"$dns2\" ]; then\n\t\t\t\tdns=\"$dns1, $dns2\"\n\t\t\telse\n\t\t\t\tdns=\"$dns1\"\n\t\t\tfi\n\t\t;;\n\tesac\n}\n\nselect_client_ip() {\n\t# Given a list of the assigned internal IPv4 addresses, obtain the lowest still\n\t# available octet. Important to start looking at 2, because 1 is our gateway.\n\toctet=2\n\twhile grep AllowedIPs \"$WG_CONF\" | cut -d \".\" -f 4 | cut -d \"/\" -f 1 | grep -q \"^$octet$\"; do\n\t\t(( octet++ ))\n\tdone\n\t# Don't break the WireGuard configuration in case the address space is full\n\tif [[ \"$octet\" -eq 255 ]]; then\n\t\texiterr \"253 clients are already configured. The WireGuard internal subnet is full!\"\n\tfi\n}\n\nnew_client() {\n\tselect_client_ip\n\tspecify_ip=n\n\tif [ \"$1\" = \"add_client\" ] && [ \"$add_client\" = 0 ]; then\n\t\techo\n\t\tread -rp \"Do you want to specify an internal IP address for the new client? [y/N]: \" specify_ip\n\t\tuntil [[ \"$specify_ip\" =~ ^[yYnN]*$ ]]; do\n\t\t\techo \"$specify_ip: invalid selection.\"\n\t\t\tread -rp \"Do you want to specify an internal IP address for the new client? [y/N]: \" specify_ip\n\t\tdone\n\t\tif [[ ! \"$specify_ip\" =~ ^[yY]$ ]]; then\n\t\t\techo \"Using auto assigned IP address 10.7.0.$octet.\"\n\t\tfi\n\tfi\n\tif [[ \"$specify_ip\" =~ ^[yY]$ ]]; then\n\t\techo\n\t\tread -rp \"Enter IP address for the new client (e.g. 10.7.0.X): \" client_ip\n\t\toctet=$(printf '%s' \"$client_ip\" | cut -d \".\" -f 4)\n\t\tuntil [[ $client_ip =~ ^10\\.7\\.0\\.([2-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-4])$ ]] \\\n\t\t\t&& ! grep AllowedIPs \"$WG_CONF\" | cut -d \".\" -f 4 | cut -d \"/\" -f 1 | grep -q \"^$octet$\"; do\n\t\t\tif [[ ! $client_ip =~ ^10\\.7\\.0\\.([2-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-4])$ ]]; then\n\t\t\t\techo \"Invalid IP address. Must be within the range 10.7.0.2 to 10.7.0.254.\"\n\t\t\telse\n\t\t\t\techo \"The IP address is already in use. Please choose another one.\"\n\t\t\tfi\n\t\t\tread -rp \"Enter IP address for the new client (e.g. 10.7.0.X): \" client_ip\n\t\t\toctet=$(printf '%s' \"$client_ip\" | cut -d \".\" -f 4)\n\t\tdone\n\tfi\n\tkey=$(wg genkey)\n\tpsk=$(wg genpsk)\n\t# Configure client in the server\n\tcat << EOF >> \"$WG_CONF\"\n# BEGIN_PEER $client\n[Peer]\nPublicKey = $(wg pubkey <<< \"$key\")\nPresharedKey = $psk\nAllowedIPs = 10.7.0.$octet/32$(grep -q 'fddd:2c4:2c4:2c4::1' \"$WG_CONF\" && echo \", fddd:2c4:2c4:2c4::$octet/128\")\n# END_PEER $client\nEOF\n\t# Create client configuration\n\tget_export_dir\n\tcat << EOF > \"$export_dir$client\".conf\n[Interface]\nAddress = 10.7.0.$octet/24$(grep -q 'fddd:2c4:2c4:2c4::1' \"$WG_CONF\" && echo \", fddd:2c4:2c4:2c4::$octet/64\")\nDNS = $dns\nPrivateKey = $key\n\n[Peer]\nPublicKey = $(grep PrivateKey \"$WG_CONF\" | cut -d \" \" -f 3 | wg pubkey)\nPresharedKey = $psk\nAllowedIPs = 0.0.0.0/0, ::/0\nEndpoint = $(grep '^# ENDPOINT' \"$WG_CONF\" | cut -d \" \" -f 3):$(grep ListenPort \"$WG_CONF\" | cut -d \" \" -f 3)\nPersistentKeepalive = 25\nEOF\n\tif [ \"$export_to_home_dir\" = 1 ]; then\n\t\tchown \"$SUDO_USER:$SUDO_USER\" \"$export_dir$client\".conf\n\tfi\n\tchmod 600 \"$export_dir$client\".conf\n}\n\nupdate_sysctl() {\n\tmkdir -p /etc/sysctl.d\n\tconf_fwd=\"/etc/sysctl.d/99-wireguard-forward.conf\"\n\tconf_opt=\"/etc/sysctl.d/99-wireguard-optimize.conf\"\n\t# Enable net.ipv4.ip_forward for the system\n\techo 'net.ipv4.ip_forward=1' > \"$conf_fwd\"\n\tif [[ -n \"$ip6\" ]]; then\n\t\t# Enable net.ipv6.conf.all.forwarding for the system\n\t\techo \"net.ipv6.conf.all.forwarding=1\" >> \"$conf_fwd\"\n\tfi\n\t# Optimize sysctl settings such as TCP buffer sizes\n\tbase_url=\"https://github.com/hwdsl2/vpn-extras/releases/download/v1.0.0\"\n\tconf_url=\"$base_url/sysctl-wg-$os\"\n\t[ \"$auto\" != 0 ] && conf_url=\"${conf_url}-auto\"\n\twget -t 3 -T 30 -q -O \"$conf_opt\" \"$conf_url\" 2>/dev/null \\\n\t\t|| curl -m 30 -fsL \"$conf_url\" -o \"$conf_opt\" 2>/dev/null \\\n\t\t|| { /bin/rm -f \"$conf_opt\"; touch \"$conf_opt\"; }\n\t# Enable TCP BBR congestion control if kernel version >= 4.20\n\tif modprobe -q tcp_bbr \\\n\t\t&& printf '%s\\n%s' \"4.20\" \"$(uname -r)\" | sort -C -V \\\n\t\t&& [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then\ncat >> \"$conf_opt\" <<'EOF'\nnet.core.default_qdisc = fq\nnet.ipv4.tcp_congestion_control = bbr\nEOF\n\tfi\n\t# Apply sysctl settings\n\tsysctl -e -q -p \"$conf_fwd\"\n\tsysctl -e -q -p \"$conf_opt\"\n}\n\nupdate_rclocal() {\n\tipt_cmd=\"systemctl restart wg-iptables.service\"\n\tif ! grep -qs \"$ipt_cmd\" /etc/rc.local; then\n\t\tif [ ! -f /etc/rc.local ]; then\n\t\t\techo '#!/bin/sh' > /etc/rc.local\n\t\telse\n\t\t\tif [ \"$os\" = \"ubuntu\" ] || [ \"$os\" = \"debian\" ]; then\n\t\t\t\tsed --follow-symlinks -i '/^exit 0/d' /etc/rc.local\n\t\t\tfi\n\t\tfi\ncat >> /etc/rc.local <<EOF\n\n$ipt_cmd\nEOF\n\t\tif [ \"$os\" = \"ubuntu\" ] || [ \"$os\" = \"debian\" ]; then\n\t\t\techo \"exit 0\" >> /etc/rc.local\n\t\tfi\n\t\tchmod +x /etc/rc.local\n\tfi\n}\n\nstart_wg_service() {\n\t# Enable and start the wg-quick service\n\t(\n\t\tset -x\n\t\tsystemctl enable --now wg-quick@wg0.service >/dev/null 2>&1\n\t)\n}\n\nshow_client_qr_code() {\n\tqrencode -t UTF8 < \"$export_dir$client\".conf\n\techo -e '\\xE2\\x86\\x91 That is a QR code containing the client configuration.'\n}\n\nfinish_setup() {\n\techo\n\t# If the kernel module didn't load, system probably had an outdated kernel\n\tif ! modprobe -nq wireguard; then\n\t\techo \"Warning!\"\n\t\techo \"Installation was finished, but the WireGuard kernel module could not load.\"\n\t\techo \"Reboot the system to load the most recent kernel.\"\n\telse\n\t\techo \"Finished!\"\n\tfi\n\techo\n\techo \"The client configuration is available in: $export_dir$client.conf\"\n\techo \"New clients can be added by running this script again.\"\n}\n\nselect_menu_option() {\n\techo\n\techo \"WireGuard is already installed.\"\n\techo\n\techo \"Select an option:\"\n\techo \"   1) Add a new client\"\n\techo \"   2) List existing clients\"\n\techo \"   3) Remove an existing client\"\n\techo \"   4) Show QR code for a client\"\n\techo \"   5) Remove WireGuard\"\n\techo \"   6) Exit\"\n\tread -rp \"Option: \" option\n\tuntil [[ \"$option\" =~ ^[1-6]$ ]]; do\n\t\techo \"$option: invalid selection.\"\n\t\tread -rp \"Option: \" option\n\tdone\n}\n\nshow_clients() {\n\tgrep '^# BEGIN_PEER' \"$WG_CONF\" | cut -d ' ' -f 3 | nl -s ') '\n}\n\nenter_client_name() {\n\techo\n\techo \"Provide a name for the client:\"\n\tread -rp \"Name: \" unsanitized_client\n\t[ -z \"$unsanitized_client\" ] && abort_and_exit\n\tset_client_name\n\twhile [[ -z \"$client\" ]] || grep -q \"^# BEGIN_PEER $client$\" \"$WG_CONF\"; do\n\t\tif [ -z \"$client\" ]; then\n\t\t\techo \"Invalid client name. Use one word only, no special characters except '-' and '_'.\"\n\t\telse\n\t\t\techo \"$client: invalid name. Client already exists.\"\n\t\tfi\n\t\tread -rp \"Name: \" unsanitized_client\n\t\t[ -z \"$unsanitized_client\" ] && abort_and_exit\n\t\tset_client_name\n\tdone\n}\n\nupdate_wg_conf() {\n\t# Append new client configuration to the WireGuard interface\n\twg addconf wg0 <(sed -n \"/^# BEGIN_PEER $client/,/^# END_PEER $client/p\" \"$WG_CONF\")\n}\n\nprint_client_added() {\n\techo\n\techo \"$client added. Configuration available in: $export_dir$client.conf\"\n}\n\nprint_check_clients() {\n\techo\n\techo \"Checking for existing client(s)...\"\n}\n\ncheck_clients() {\n\tnum_of_clients=$(grep -c '^# BEGIN_PEER' \"$WG_CONF\")\n\tif [[ \"$num_of_clients\" = 0 ]]; then\n\t\techo\n\t\techo \"There are no existing clients!\"\n\t\texit 1\n\tfi\n}\n\nprint_client_total() {\n\tif [ \"$num_of_clients\" = 1 ]; then\n\t\tprintf '\\n%s\\n' \"Total: 1 client\"\n\telif [ -n \"$num_of_clients\" ]; then\n\t\tprintf '\\n%s\\n' \"Total: $num_of_clients clients\"\n\tfi\n}\n\nselect_client_to() {\n\techo\n\techo \"Select the client to $1:\"\n\tshow_clients\n\tread -rp \"Client: \" client_num\n\t[ -z \"$client_num\" ] && abort_and_exit\n\tuntil [[ \"$client_num\" =~ ^[0-9]+$ && \"$client_num\" -le \"$num_of_clients\" ]]; do\n\t\techo \"$client_num: invalid selection.\"\n\t\tread -rp \"Client: \" client_num\n\t\t[ -z \"$client_num\" ] && abort_and_exit\n\tdone\n\tclient=$(grep '^# BEGIN_PEER' \"$WG_CONF\" | cut -d ' ' -f 3 | sed -n \"$client_num\"p)\n}\n\nconfirm_remove_client() {\n\tif [ \"$assume_yes\" != 1 ]; then\n\t\techo\n\t\tread -rp \"Confirm $client removal? [y/N]: \" remove\n\t\tuntil [[ \"$remove\" =~ ^[yYnN]*$ ]]; do\n\t\t\techo \"$remove: invalid selection.\"\n\t\t\tread -rp \"Confirm $client removal? [y/N]: \" remove\n\t\tdone\n\telse\n\t\tremove=y\n\tfi\n}\n\nremove_client_conf() {\n\tget_export_dir\n\twg_file=\"$export_dir$client.conf\"\n\tif [ -f \"$wg_file\" ]; then\n\t\techo \"Removing $wg_file...\"\n\t\trm -f \"$wg_file\"\n\tfi\n}\n\nprint_remove_client() {\n\techo\n\techo \"Removing $client...\"\n}\n\nremove_client_wg() {\n\t# The following is the right way to avoid disrupting other active connections:\n\t# Remove from the live interface\n\twg set wg0 peer \"$(sed -n \"/^# BEGIN_PEER $client$/,\\$p\" \"$WG_CONF\" | grep -m 1 PublicKey | cut -d \" \" -f 3)\" remove\n\t# Remove from the configuration file\n\tsed -i \"/^# BEGIN_PEER $client$/,/^# END_PEER $client$/d\" \"$WG_CONF\"\n\tremove_client_conf\n}\n\nprint_client_removed() {\n\techo\n\techo \"$client removed!\"\n}\n\nprint_client_removal_aborted() {\n\techo\n\techo \"$client removal aborted!\"\n}\n\ncheck_client_conf() {\n\twg_file=\"$export_dir$client.conf\"\n\tif [ ! -f \"$wg_file\" ]; then\n\t\techo \"Error: Cannot show QR code. Missing client config file $wg_file\" >&2\n\t\techo \"       You may instead re-run this script and add a new client.\" >&2\n\t\texit 1\n\tfi\n}\n\nprint_client_conf() {\n\techo\n\techo \"Configuration for '$client' is available in: $wg_file\"\n}\n\nconfirm_remove_wg() {\n\tif [ \"$assume_yes\" != 1 ]; then\n\t\techo\n\t\tread -rp \"Confirm WireGuard removal? [y/N]: \" remove\n\t\tuntil [[ \"$remove\" =~ ^[yYnN]*$ ]]; do\n\t\t\techo \"$remove: invalid selection.\"\n\t\t\tread -rp \"Confirm WireGuard removal? [y/N]: \" remove\n\t\tdone\n\telse\n\t\tremove=y\n\tfi\n}\n\nprint_remove_wg() {\n\techo\n\techo \"Removing WireGuard, please wait...\"\n}\n\ndisable_wg_service() {\n\tsystemctl disable --now wg-quick@wg0.service\n}\n\nremove_sysctl_rules() {\n\trm -f /etc/sysctl.d/99-wireguard-forward.conf /etc/sysctl.d/99-wireguard-optimize.conf\n\tif [ ! -f /usr/sbin/openvpn ] && [ ! -f /usr/sbin/ipsec ] \\\n\t\t&& [ ! -f /usr/local/sbin/ipsec ]; then\n\t\techo 0 > /proc/sys/net/ipv4/ip_forward\n\t\techo 0 > /proc/sys/net/ipv6/conf/all/forwarding\n\tfi\n}\n\nremove_rclocal_rules() {\n\tipt_cmd=\"systemctl restart wg-iptables.service\"\n\tif grep -qs \"$ipt_cmd\" /etc/rc.local; then\n\t\tsed --follow-symlinks -i \"/^$ipt_cmd/d\" /etc/rc.local\n\tfi\n}\n\nprint_wg_removed() {\n\techo\n\techo \"WireGuard removed!\"\n}\n\nprint_wg_removal_aborted() {\n\techo\n\techo \"WireGuard removal aborted!\"\n}\n\nwgsetup() {\n\nexport PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\n\ncheck_root\ncheck_shell\ncheck_kernel\ncheck_os\ncheck_os_ver\ncheck_container\n\nWG_CONF=\"/etc/wireguard/wg0.conf\"\n\nauto=0\nassume_yes=0\nadd_client=0\nlist_clients=0\nremove_client=0\nshow_client_qr=0\nremove_wg=0\npublic_ip=\"\"\nserver_addr=\"\"\nserver_port=\"\"\nfirst_client_name=\"\"\nunsanitized_client=\"\"\nclient=\"\"\ndns=\"\"\ndns1=\"\"\ndns2=\"\"\n\nparse_args \"$@\"\ncheck_args\n\nif [ \"$add_client\" = 1 ]; then\n\tshow_header\n\tnew_client add_client\n\tupdate_wg_conf\n\techo\n\tshow_client_qr_code\n\tprint_client_added\n\texit 0\nfi\n\nif [ \"$list_clients\" = 1 ]; then\n\tshow_header\n\tprint_check_clients\n\tcheck_clients\n\techo\n\tshow_clients\n\tprint_client_total\n\texit 0\nfi\n\nif [ \"$remove_client\" = 1 ]; then\n\tshow_header\n\tconfirm_remove_client\n\tif [[ \"$remove\" =~ ^[yY]$ ]]; then\n\t\tprint_remove_client\n\t\tremove_client_wg\n\t\tprint_client_removed\n\t\texit 0\n\telse\n\t\tprint_client_removal_aborted\n\t\texit 1\n\tfi\nfi\n\nif [ \"$show_client_qr\" = 1 ]; then\n\tshow_header\n\techo\n\tget_export_dir\n\tcheck_client_conf\n\tshow_client_qr_code\n\tprint_client_conf\n\texit 0\nfi\n\nif [ \"$remove_wg\" = 1 ]; then\n\tshow_header\n\tconfirm_remove_wg\n\tif [[ \"$remove\" =~ ^[yY]$ ]]; then\n\t\tprint_remove_wg\n\t\tremove_firewall_rules\n\t\tdisable_wg_service\n\t\tremove_sysctl_rules\n\t\tremove_rclocal_rules\n\t\tremove_pkgs\n\t\tprint_wg_removed\n\t\texit 0\n\telse\n\t\tprint_wg_removal_aborted\n\t\texit 1\n\tfi\nfi\n\nif [[ ! -e \"$WG_CONF\" ]]; then\n\tcheck_nftables\n\tinstall_wget\n\tinstall_iproute\n\tshow_welcome\n\tif [ \"$auto\" = 0 ]; then\n\t\tenter_server_address\n\telse\n\t\tif [ -n \"$server_addr\" ]; then\n\t\t\tip=\"$server_addr\"\n\t\telse\n\t\t\tdetect_ip\n\t\t\tcheck_nat_ip\n\t\tfi\n\tfi\n\tshow_config\n\tdetect_ipv6\n\tselect_port\n\tenter_first_client_name\n\tif [ \"$auto\" = 0 ]; then\n\t\tselect_dns\n\tfi\n\tshow_setup_ready\n\tcheck_firewall\n\tconfirm_setup\n\tshow_start_setup\n\tinstall_pkgs\n\tcreate_server_config\n\tupdate_sysctl\n\tcreate_firewall_rules\n\tif [ \"$os\" != \"openSUSE\" ]; then\n\t\tupdate_rclocal\n\tfi\n\tnew_client\n\tstart_wg_service\n\techo\n\tshow_client_qr_code\n\tif [ \"$auto\" != 0 ] && check_dns_name \"$server_addr\"; then\n\t\tshow_dns_name_note \"$server_addr\"\n\tfi\n\tfinish_setup\nelse\n\tshow_header\n\tselect_menu_option\n\tcase \"$option\" in\n\t\t1)\n\t\t\tenter_client_name\n\t\t\tselect_dns\n\t\t\tnew_client add_client\n\t\t\tupdate_wg_conf\n\t\t\techo\n\t\t\tshow_client_qr_code\n\t\t\tprint_client_added\n\t\t\texit 0\n\t\t;;\n\t\t2)\n\t\t\tprint_check_clients\n\t\t\tcheck_clients\n\t\t\techo\n\t\t\tshow_clients\n\t\t\tprint_client_total\n\t\t\texit 0\n\t\t;;\n\t\t3)\n\t\t\tcheck_clients\n\t\t\tselect_client_to remove\n\t\t\tconfirm_remove_client\n\t\t\tif [[ \"$remove\" =~ ^[yY]$ ]]; then\n\t\t\t\tprint_remove_client\n\t\t\t\tremove_client_wg\n\t\t\t\tprint_client_removed\n\t\t\t\texit 0\n\t\t\telse\n\t\t\t\tprint_client_removal_aborted\n\t\t\t\texit 1\n\t\t\tfi\n\t\t;;\n\t\t4)\n\t\t\tcheck_clients\n\t\t\tselect_client_to \"show QR code for\"\n\t\t\techo\n\t\t\tget_export_dir\n\t\t\tcheck_client_conf\n\t\t\tshow_client_qr_code\n\t\t\tprint_client_conf\n\t\t\texit 0\n\t\t;;\n\t\t5)\n\t\t\tconfirm_remove_wg\n\t\t\tif [[ \"$remove\" =~ ^[yY]$ ]]; then\n\t\t\t\tprint_remove_wg\n\t\t\t\tremove_firewall_rules\n\t\t\t\tdisable_wg_service\n\t\t\t\tremove_sysctl_rules\n\t\t\t\tremove_rclocal_rules\n\t\t\t\tremove_pkgs\n\t\t\t\tprint_wg_removed\n\t\t\t\texit 0\n\t\t\telse\n\t\t\t\tprint_wg_removal_aborted\n\t\t\t\texit 1\n\t\t\tfi\n\t\t;;\n\t\t6)\n\t\t\texit 0\n\t\t;;\n\tesac\nfi\n}\n\n## Defer setup until we have the complete script\nwgsetup \"$@\"\n\nexit 0\n"
        }
      ]
    }
  ]
}