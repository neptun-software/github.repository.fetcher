{
  "metadata": {
    "timestamp": 1736568819910,
    "page": 983,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk4OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Tomas-M/linux-live",
      "stars": 1027,
      "defaultBranch": "master",
      "files": [
        {
          "name": "DOC",
          "type": "tree",
          "content": null
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.8779296875,
          "content": "Linux Live Kit\n==============\n\nUse this set of scripts to turn your existing preinstalled Linux\ndistribution into a Live Kit (formely known as Live CD).\nMake sure to extract and use it on a posix-compatible filesystem,\nsince it creates some (sym)links and such.\n\nNote:\n\n* Store Linux Live kit in a directory which is not going to be included\n  in your live distro, else it would be copied to it. Best practice is to\n  make a directory such as /a and put these scripts there.\n  Be warned, if you put it to /tmp, some distros may erase it on reboot.\n\n* Before you start building your Kit, edit the file ./config\n  Most importantly change the LIVEKITNAME variable.\n\n* Make sure your kernel is in /vmlinuz or change the path in ./config\n  Your kernel must support squashfs. Your kernel must also support either\n  aufs or overlayfs or both. AUFS is recommended for more flexibility,\n  but if your distro does not support it, overlayfs will work too.\n\n* You may also wish to replace boot graphics in ./bootfiles/bootlogo.png\n  (one options is to modify and run the ./tools/bootlogo.update script) \n  and reorganize isolinux.cfg to fit your needs (when editing the file,\n  keep all paths in /boot/, it will be rellocated during LiveKit creation)\n\n* Linux Live Kit comes with precompiled static binaries in ./initramfs\n  directory. Those may be outdated but will work. You may replace them\n  by your own statically linked binaries, if you know how to compile them.  \n\n* If you plan to boot your Live Kit from CD, you need to recompile\n  syslinux.bin else it won't be able to boot your Live Kit from directory\n  LIVEKITNAME. There is a script prepared for you which will handle all\n  of that. Simply go to directory ./tools/ and run isolinux.bin.update ...\n  it will update ./bootfiles/isolinux.bin automatically by downloading\n  isolinux sources, patching them using your actual LIVEKITNAME and\n  recompiling. This step is not needed if you plan to boot from USB only.\n\n* If you plan to boot your Live Kit from USB device, you may wish to add\n  the following boot parameter to the end of APPEND section in syslinux.cfg:\n     perch\n  This parameter activates persistent changes\n\n* If you have tmpfs mounted on /tmp during building your Live Kit ISO,\n  make sure you have enough RAM since LiveKit will store lots of data in /tmp.\n  If you are low on RAM, make sure /tmp is a regular on-disk directory.\n\n* When done, run the ./build script to create your Live Kit\n  - it will create ISO and TAR files for you in /tmp\n  - make sure you have enough free space in /tmp to handle it\n  \n* If you want to use the Live Kit on a USB you have to either\n  - use Windows to execute the bootinst.bat file in the $NAME/boot folder\n  - or use Linux to execute the shellscript bootinst.sh in the $NAME/boot folder.\n\n* You will need the following packages to be installed:\n  - squashfs-tools\n  - genisoimage or mkisofs\n  - zip\n\n\nAuthor: Tomas M. <http://www.linux-live.org>\n"
        },
        {
          "name": "Slax",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootfiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootinfo.txt",
          "type": "blob",
          "size": 1.017578125,
          "content": "# This file gets copied to LiveKit ZIP build, in order to provide\n# some basic information for the user - mostly hints to encourage\n# the user to run /mylinux/boot/bootinst.sh(bat).\n#\n# Lines containing # are ignored\n#\nThank you for using mylinux!\nIf you are reading this from a CD, it is already bootable.\nSteps to make it bootable from your USB device are following:\n\n1) Copy the entire /mylinux/ directory to your USB drive.\n   If you are using Windows, you will get for example E:\\mylinux\\\n   You probably already did this - just make sure you are on your\n   USB drive now and not on your local harddisk.\n\n2) Now navigate to directory /mylinux/boot/ on your USB drive.\n   In Windows, it will be E:\\mylinux\\boot\\ for example.\n   Use explorer or any other file manager for this task.\n\n3) While you're in the boot directory, locate file bootinst.bat\n   Run it by doubleclicking it. It will setup your USB to boot.\n\n-- That's it. Your USB device is now ready to boot mylinux.\n-- You can safely delete this file (readme.txt), it's not needed.\n"
        },
        {
          "name": "build",
          "type": "blob",
          "size": 3.107421875,
          "content": "#!/bin/bash\n# Linux Live Kit version 7\n\nexport PATH=.:./tools:../tools:/usr/sbin:/usr/bin:/sbin:/bin:/\n\nCHANGEDIR=$(dirname $(readlink -f $0))\necho \"Changing current directory to $CHANGEDIR\"\ncd $CHANGEDIR\nCWD=\"$(pwd)\"\n\n. ./config || exit 1\n. ./livekitlib || exit 1\n\n# only root can continue, because only root can read all files from your system\nallow_only_root\n\n# check for xz\nif [ \"$(xz --help 2>&1 | grep -i \"Compress\")\" = \"\" ]; then\n   echo \"xz not found or cannot compress\"\n   echo \"you may consider installing xz-tools package\"\n   exit 1\nfi\n\n# check for mksquashfs with xz compression\nif [ \"$(mksquashfs 2>&1 | grep \"Xdict-size\")\" = \"\" ]; then\n   echo \"mksquashfs not found or doesn't support -comp xz, aborting, no changes made\"\n   echo \"you may consider installing squashfs-tools package\"\n   exit 1\nfi\n\nMKISOFS=$(which mkisofs)\nif [ \"$MKISOFS\" = \"\" ]; then\n   MKISOFS=$(which genisoimage)\nfi\nif [ \"$MKISOFS\" = \"\" ]; then\n   echo \"Cannot find mkisofs or genisoimage, stop\"\n   exit 3\nfi\n\n# build initramfs image\nif [ \"$SKIPINITRFS\" = \"\" ]; then\n   echo \"Building initramfs image...\"\n   cd initramfs\n   INITRAMFS=$(./initramfs_create)\n   cd ..\nfi\n\n# create live kit filesystem (cpio archive)\nrm -Rf \"$LIVEKITDATA\"\nBOOT=\"$LIVEKITDATA\"/\"$LIVEKITNAME\"/boot\nmkdir -p \"$BOOT\"\nmkdir -p \"$BOOT\"/../changes\nmkdir -p \"$BOOT\"/../modules\n\nif [ \"$INITRAMFS\" != \"\" ]; then\n   mv \"$INITRAMFS\" $BOOT/initrfs.img\nfi\n\n# BIOS / MBR booting\ncp -r bootfiles/* $BOOT\ncat bootfiles/syslinux.cfg | sed -r \"s:/boot/:/$LIVEKITNAME/boot/:\" > $BOOT/syslinux.cfg\ncat bootfiles/bootinst.bat | sed -r \"s:/boot/:/$LIVEKITNAME/boot/:\" | sed -r \"s:\\\\\\\\boot\\\\\\\\:\\\\\\\\$LIVEKITNAME\\\\\\\\boot\\\\\\\\:\" > $BOOT/bootinst.bat\ncp $VMLINUZ $BOOT/ || exit\n\n# UEFI booting\nmkdir -p $BOOT/EFI/Boot\ncp bootfiles/EFI/Boot/syslinux.efi $BOOT/EFI/Boot/bootx64.efi\ncp bootfiles/EFI/Boot/{ldlinux.e64,menu.c32,libutil.c32,vesamenu.c32,libcom32.c32} $BOOT/EFI/Boot\ncat $BOOT/syslinux.cfg | sed -r \"s:/$LIVEKITNAME/boot/vesamenu:vesamenu:\" > $BOOT/EFI/Boot/syslinux.cfg\n\n# create compressed 01-core.sb\nCOREFS=\"\"\nfor i in $MKMOD; do\n   if [ -d /$i ]; then\n      COREFS=\"$COREFS /$i\"\n   fi\ndone\nif [ \"$SKIPCOREMOD\" = \"\" ]; then\n   mksquashfs $COREFS $LIVEKITDATA/$LIVEKITNAME/modules/01-core.$BEXT -comp xz -b 1024K -Xbcj x86 -always-use-fragments -keep-as-directory || exit\nfi\n\ncd \"$LIVEKITDATA\"\nARCH=$(uname -m)\nTARGET=/tmp\n\ncat \"$CWD/bootinfo.txt\" | fgrep -v \"#\" | sed -r \"s/mylinux/$LIVEKITNAME/\" | sed -r \"s/\\$/\\x0D/\" > readme.txt\n\necho cd $LIVEKITDATA '&&' $MKISOFS -o \"$TARGET/$LIVEKITNAME-$ARCH.iso\" -v -J -R -D -A \"$LIVEKITNAME\" -V \"$LIVEKITNAME\" \\\n-no-emul-boot -boot-info-table -boot-load-size 4 \\\n-b \"$LIVEKITNAME\"/boot/isolinux.bin -c \"$LIVEKITNAME\"/boot/isolinux.boot . \\\n> $TARGET/gen_\"$LIVEKITNAME\"_iso.sh\nchmod o+x $TARGET/gen_\"$LIVEKITNAME\"_iso.sh\n\necho cd $LIVEKITDATA '&&' zip -0 -r \"$TARGET/$LIVEKITNAME-$ARCH.zip\" '*' \\\n> $TARGET/gen_\"$LIVEKITNAME\"_zip.sh\nchmod o+x $TARGET/gen_\"$LIVEKITNAME\"_zip.sh\n\necho \"-----------------------------\"\necho \"Finished. Find your result in $LIVEKITDATA\"\necho \"To build ISO, run: $TARGET/gen_\"$LIVEKITNAME\"_iso.sh\"\necho \"To build ZIP, run: $TARGET/gen_\"$LIVEKITNAME\"_zip.sh\"\ncd $CWD\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 1.73828125,
          "content": "#!/bin/bash\n# This is a config file for Linux Live Kit build script.\n# You shouldn't need to change anything expect LIVEKITNAME\n\n# Live Kit Name. Defaults to 'linux';\n# This will be the name of the directory created on your CD/USB, which\n# will contain everything including boot files and such.\n# For example, Slax changes it to 'slax'\n# Must not contain any spaces.\n# If you change it, you must run ./tools/isolinux.bin.update script\n# in order to update isolinux.bin for CD booting.\n# If you do not need booting from CD (eg you're booting only from USB)\n# then you can ignore recompiling isolinux.bin, just rename LIVEKITNAME\n# and you're done.\nLIVEKITNAME=\"linux\"\n\n# Kernel file, will be copied to your Live Kit\n# Your kernel must support aufs and squashfs. Debian Jessie's kernel is ready\n# out of the box.\nVMLINUZ=/vmlinuz\n\n# Kernel version. Change it to \"3.2.28\" for example, if you are building\n# Live Kit with a different kernel than the one you are actually running\nKERNEL=$(uname -r)\n\n# List of directories for root filesystem\n# No subdirectories are allowed, no slashes,\n# so You can't use /var/tmp here for example\n# Exclude directories like proc sys tmp\nMKMOD=\"bin etc home lib lib64 libx32 opt root sbin srv usr var\"\n\n# If you require network support in initrd, for example to boot over\n# PXE or to load data using 'from' boot parameter from a http server,\n# you will need network modules included in your initrd.\n# This is disabled by default since most people won't need it.\n# To enable, set to true\nNETWORK=false\n\n# Temporary directory to store livekit filesystem\nLIVEKITDATA=/tmp/$LIVEKITNAME-data-$$\n\n# Bundle extension, for example 'sb' for .sb extension\nBEXT=sb\n\n# Directory with kernel .ko modules, can be different in some distros\nLMK=\"lib/modules/$KERNEL\"\n"
        },
        {
          "name": "initramfs",
          "type": "tree",
          "content": null
        },
        {
          "name": "livekitlib",
          "type": "blob",
          "size": 27.9375,
          "content": "#!/bin/sh\n\n# Functions library :: for Linux Live Kit scripts\n# Author: Tomas M. <http://www.linux-live.org>\n#\n\n# =================================================================\n# debug and output functions\n# =================================================================\n\ndebug_start()\n{\n   if grep -q debug /proc/cmdline; then\n      DEBUG_IS_ENABLED=1\n      set -x\n   else\n      DEBUG_IS_ENABLED=\n   fi\n}\n\ndebug_log()\n{\n   if [ \"$DEBUG_IS_ENABLED\" ]; then\n      echo \"- debug: $*\" >&2\n   fi\n   log \"- debug: $*\"\n}\n\n# header\n# $1 = text to show\n#\nheader()\n{\n   echo \"\u001b[0;1m\"\"$@\"\"\u001b[0;0m\"\n}\n\n\n# echo green star\n#\necho_green_star()\n{\n   echo -ne \"\u001b[0;32m\"\"* \"\"\u001b[0;39m\"\n}\n\n# log - store given text in /var/log/livedbg\nlog()\n{\n   echo \"$@\" 2>/dev/null >>/var/log/livedbg\n}\n\necholog()\n{\n   echo \"$@\"\n   log \"$@\"\n}\n\n\n# show information about the debug shell\nshow_debug_banner()\n{\n   echo\n   echo \"=====\"\n   echo \": Debugging started. Here is the root shell for you.\"\n   echo \": Type your desired commands or hit Ctrl+D to continue booting.\"\n   echo\n}\n\n\n# debug_shell\n# executed when debug boot parameter is present\n#\ndebug_shell()\n{\n   if [ \"$DEBUG_IS_ENABLED\" ]; then\n      show_debug_banner\n      setsid sh -c 'exec sh < /dev/tty1 >/dev/tty1 2>&1'\n      echo\n   fi\n}\n\nfatal()\n{\n   echolog\n   header \"Fatal error occured - $1\"\n   echolog \"Something went wrong and we can't continue. This should never happen.\"\n   echolog \"Please reboot your computer with Ctrl+Alt+Delete ...\"\n   echolog\n   setsid sh -c 'exec sh < /dev/tty1 >/dev/tty1 2>&1'\n}\n\n\n# get value of commandline parameter $1\n# $1 = parameter to search for\n#\ncmdline_value()\n{\n   cat /proc/cmdline | egrep -o \"(^|[[:space:]])$1=[^[:space:]]+\" | tr -d \" \" | cut -d \"=\" -f 2- | tail -n 1\n}\n\n\n# test if the script is started by root user. If not, exit\n#\nallow_only_root()\n{\n  if [ \"0$UID\" -ne 0 ]; then\n     echo \"Only root can run $(basename $0)\"; exit 1\n  fi\n}\n\n\n# Create bundle\n# call mksquashfs with apropriate arguments\n# $1 = directory which will be compressed to squashfs bundle\n# $2 = output file\n# $3..$9 = optional arguments like -keep-as-directory or -b 123456789\n#\ncreate_bundle()\n{\n   debug_log \"create_module\" \"$*\"\n   rm -f \"$2\" # overwrite, never append to existing file\n   mksquashfs \"$1\" \"$2\" -comp xz -b 1024K -Xbcj x86 -always-use-fragments $3 $4 $5 $6 $7 $8 $9>/dev/null\n}\n\n\n# Move entire initramfs tree to tmpfs mount.\n# It's a bit tricky but is necessray to enable pivot_root\n# even for initramfs boot image\n#\ntransfer_initramfs()\n{\n   if [ ! -r /lib/initramfs_escaped ]; then\n      echo \"switch root from initramfs to ramfs\"\n      SWITCH=/m # one letter directory\n      mkdir -p $SWITCH\n      mount -t tmpfs -o size=\"100%\" tmpfs $SWITCH\n      cp -a /??* $SWITCH 2>/dev/null # only copy two-and-more-letter directories\n      cd $SWITCH\n      echo \"This file indicates that we successfully escaped initramfs\" > $SWITCH/lib/initramfs_escaped\n      exec switch_root -c /dev/console . $0\n   fi\n}\n\n\n# mount virtual filesystems like proc etc\n#\ninit_proc_sysfs()\n{\n   debug_log \"init_proc_sysfs\" \"$*\"\n   mkdir -p /proc /sys /etc $MEMORY\n   mount -n -t proc proc /proc\n   echo \"0\" >/proc/sys/kernel/printk\n   mount -n -t sysfs sysfs /sys\n   mount -n -o remount,rw rootfs /\n   ln -sf /proc/mounts /etc/mtab\n}\n\n\n# modprobe all modules found in initial ramdisk\n# $1 = -e for match, -v for negative match\n# $2 = regex pattern\n#\nmodprobe_everything()\n{\n   debug_log \"modprobe_everything\" \"$*\"\n\n   echo_green_star >&2\n   echo \"Probing for hardware\" >&2\n\n   find /lib/modules/ | fgrep .ko | egrep $1 $2 | sed -r \"s:^.*/|[.]ko\\$::g\" | xargs -n 1 modprobe 2>/dev/null\n   refresh_devs\n}\n\n\nrefresh_devs()\n{\n   debug_log \"refresh_devs\" \"$*\"\n   if [ -r /proc/sys/kernel/hotplug ]; then\n      echo /sbin/mdev > /proc/sys/kernel/hotplug\n   fi\n   mdev -s\n}\n\n\n# make sure some devices are there\ninit_devs()\n{\n   debug_log \"init_devs\" \"$*\"\n   modprobe zram 2>/dev/null\n   modprobe loop 2>/dev/null\n   modprobe squashfs 2>/dev/null\n   modprobe fuse 2>/dev/null\n   refresh_devs\n}\n\n\n# Activate zram (auto-compression of RAM)\n# Compressed RAM consumes 1/2 or even 1/4 of original size\n# Setup static size of 500MB\n#\ninit_zram()\n{\n   debug_log \"init_zram\" \"$*\"\n   echo_green_star\n   echo \"Setting dynamic RAM compression using ZRAM if available\"\n   if [ -r /sys/block/zram0/disksize ]; then\n      echo 536870912 > /sys/block/zram0/disksize # 512MB\n      mkswap /dev/zram0 >/dev/null\n      swapon /dev/zram0\n      echo 100 > /proc/sys/vm/swappiness\n   fi\n}\n\n\naufs_is_supported()\n{\n   cat /proc/filesystems | grep aufs\n}\n\n\n# load the AUFS kernel driver. If not found,\n# load overlayfs instead.\n#\ninit_aufs()\n{\n   debug_log \"init_aufs\" \"$*\"\n   modprobe aufs 2>/dev/null\n   if ! aufs_is_supported >/dev/null; then\n      modprobe overlay 2>/dev/null\n   fi\n   refresh_devs\n}\n\n\n# Setup empty aufs union, or create overlayfs union\n# $1 = changes directory (ramfs or persistent changes)\n# $2 = union directory where to mount the union\n# $3 = bundles directory\n#\ninit_union()\n{\n   debug_log \"init_union\" \"$*\"\n   mkdir -p \"$1\"\n   mkdir -p \"$2\"\n\n   if aufs_is_supported >/dev/null; then\n      echo_green_star\n      echo \"Setting up empty union using aufs\"\n      mount -t aufs -o xino=\"/.xino\",trunc_xino,br=\"$1\" aufs \"$2\"\n   else\n      echo_green_star\n      echo \"Setting up union using overlayfs\"\n      mkdir -p \"$1/changes\"\n      mkdir -p \"$1/workdir\"\n      mount -t overlay overlay -o lowerdir=$(find \"$3\" -mindepth 1 -maxdepth 1 | sortmod | tac | tr '\\n' ':' | sed -r 's/:$//'),upperdir=$1/changes,workdir=$1/workdir $2\n   fi\n}\n\n\n# Return device mounted for given directory\n# $1 = directory\n#\nmounted_device()\n{\n   debug_log \"mounted_device\" \"$*\"\n\n   local MNT TARGET\n   MNT=\"$1\"\n   while [ \"$MNT\" != \"/\" -a \"$MNT\" != \".\" -a \"$MNT\" != \"\" ]; do\n      TARGET=\"$(grep -F \" $MNT \" /proc/mounts | cut -d \" \" -f 1)\"\n      if [ \"$TARGET\" != \"\" ]; then\n         echo \"$TARGET\"\n         return\n      fi\n      MNT=\"$(dirname \"$MNT\")\"\n   done\n}\n\n\n# Return mounted dir for given directory\n# $1 = directory\n#\nmounted_dir()\n{\n   debug_log \"mounted_dir\" \"$*\"\n\n   local MNT\n   MNT=\"$1\"\n   while [ \"$MNT\" != \"/\" -a \"$MNT\" != \".\" -a \"$MNT\" != \"\" ]; do\n      if mountpoint -q \"$MNT\" 2>/dev/null; then\n         echo \"$MNT\"\n         return\n      fi\n      MNT=\"$(dirname \"$MNT\")\"\n   done\n}\n\n\n# Initialize blkid cache by manually probing all devices\n#\ninit_blkid_cache()\n{\n   local DEV\n   cat /proc/partitions | tr -s \" \" |  cut -d \" \" -f 5 | while read DEV; do\n      blkid /dev/$DEV >/dev/null 2>/dev/null\n   done\n}\n\n\n# Get device tag.\n# $1 = device\n# $2 = tag name, such as TYPE, LABEL, UUID, etc\n#\ndevice_tag()\n{\n   blkid -s $2 \"$1\" | sed -r \"s/^[^=]+=//\" | tr -d '\"'\n}\n\n\n# Make sure to mount FAT12/16/32 using vfat\n# in order to support long filenames\n# $1 = device\n# $2 = prefix to add, like -t\n#\ndevice_bestfs()\n{\n   debug_log \"device_bestfs\" \"$*\"\n   local FS\n\n   FS=\"$(device_tag \"$1\" TYPE | tr [A-Z] [a-z])\"\n   if [ \"$FS\" = \"msdos\" -o \"$FS\" = \"fat\" -o \"$FS\" = \"vfat\" ]; then\n      FS=\"vfat\"\n   elif [ \"$FS\" = \"ntfs\" ]; then\n      FS=\"ntfs3\"\n   fi\n\n   if [ \"$2\" != \"\" ]; then\n      echo -n \"$2\"\n   fi\n\n   echo \"$FS\"\n}\n\n\n# Filesystem options for initial mount\n# $1.. = filesystem\n#\nfs_options()\n{\n   debug_log \"fs_options\" \"$*\"\n\n   echo -n \"-t $1 \"\n   echo -n \"-o rw\"\n\n   if [ \"$1\" = \"vfat\" ]; then\n      echo \",check=s,shortname=mixed,iocharset=utf8\"\n   fi\n}\n\n\n# Mount command for given filesystem\n# $1.. = filesystem\n#\nmount_command()\n{\n   debug_log \"mount_command\" \"$*\"\n\n   echo \"mount\"\n}\n\n\n# echo first network device known at the moment of calling, eg. eth0\n#\nnetwork_device()\n{\n   debug_log \"network_device\" \"$*\"\n   cat /proc/net/dev | grep : | grep -v lo: | grep -v ip6tnl | cut -d : -f 1 | tr -d \" \" | head -n 1\n}\n\n\n# Modprobe network kernel modules until a working driver is found.\n# These drivers are (or used to be) probed in Slackware's initrd.\n# The function returns the first device found, yet it doesn't have\n# to be a working one, eg. if the computer has two network interfaces\n# and ethernet cable is plugged only to one of them.\n#\ninit_network_dev()\n{\n   debug_log \"init_network_dev\" \"$*\"\n   local MODULE ETH\n\n   for MODULE in 3c59x acenic e1000 e1000e e100 epic100 hp100 ne2k-pci \\\n   pcnet32 8139too 8139cp tulip via-rhine r8169 atl1e yellowfin tg3 \\\n   dl2k ns83820 atl1 b44 bnx2 skge sky2 tulip forcedeth sb1000 sis900; do\n      modprobe $MODULE 2>/dev/null\n      ETH=\"$(network_device)\"\n      if [ \"$ETH\" != \"\" ]; then\n         echo $ETH\n         return 0\n      fi\n      rmmod $MODULE 2>/dev/null\n   done\n\n   # If we are here, none of the above specified modules worked.\n   # As a last chance, try to modprobe everything else\n   modprobe_everything -e /drivers/net/\n   echo $(network_device)\n}\n\n\n# Initialize network IP address\n# either static from ip=bootparameter, or from DHCP\n#\ninit_network_ip()\n{\n   debug_log \"init_network_ip\" \"$*\"\n   local IP ETH SCRIPT CLIENT SERVER GW MASK\n\n   SCRIPT=/tmp/dhcpscript\n   ETH=$(init_network_dev)\n   IP=$(cmdline_value ip)\n\n   echo \"* Setting up network\" >&2\n\n   if [ \"$IP\" != \"\" ]; then\n      # set IP address as given by boot paramter\n      echo \"$IP\" | while IFS=\":\" read CLIENT SERVER GW MASK; do\n         ifconfig $ETH \"$CLIENT\" netmask \"$MASK\"\n         route add default gw \"$GW\"\n         echo nameserver \"$GW\" >> /etc/resolv.conf\n         echo nameserver \"$SERVER\" >> /etc/resolv.conf\n      done\n   else\n      # if client ip is unknown, try to get a DHCP lease\n      ifconfig $ETH up\n      echo -e '#!/bin/sh\\nif [ \"$1\" != \"bound\" ]; then exit; fi\\nifconfig $interface $ip netmask $subnet\\nroute add default gw $router\\necho nameserver $dns >>/etc/resolv.conf' >$SCRIPT\n      chmod a+x $SCRIPT\n      udhcpc -i $ETH -n -s $SCRIPT -q >/dev/null\n   fi\n}\n\n\n# Mount data from http using httpfs\n# $1 = from URL\n# $2 = target\nmount_data_http()\n{\n   debug_log \"mount_data_http\" \"$*\"\n   local CACHE\n\n   echo_green_star >&2\n   echo \"Load data from $1\" >&2\n\n   CACHE=$(cmdline_value cache | sed -r \"s/[^0-9]//g\" | sed -r \"s/^0+//g\")\n   if [ \"$CACHE\" != \"\" ]; then\n      CACHE=\"-C /tmp/httpfs.cache -S \"$(($CACHE*1024*1024))\n   fi\n\n   init_network_ip\n\n   if [ \"$(network_device)\" != \"\" ]; then\n      echo \"* Mounting remote file...\" >&2\n      mkdir -p \"$2\"\n      @mount.httpfs2 -r 9999 -t 5 $CACHE -c /dev/null \"$1\" \"$2\" -o ro >/dev/null 2>/dev/null\n      mount -o loop \"$2\"/* \"$2\" # self mount\n      echo \"$2/$LIVEKITNAME\"\n   fi\n}\n\n\n# stdin = files to get\n# $1 = server\n# $2 = destination directory\n#\ntftp_mget()\n{\n   while read FNAME; do\n      echo \"* $FNAME ...\" >&2\n      tftp -b 1486 -g -r \"$FNAME\" -l \"$2/$FNAME\" \"$1\"\n   done\n}\n\n\n# Download data from tftp\n# $1 = target (store downloaded files there)\n#\ndownload_data_pxe()\n{\n   debug_log \"download_data_pxe\" \"$*\"\n   local IP CMD CLIENT SERVER GW MASK PORT PROTOCOL JOBS\n\n   mkdir -p \"$1/$LIVEKITNAME\"\n   IP=\"$(cmdline_value ip)\"\n\n   echo \"$IP\" | while IFS=\":\" read CLIENT SERVER GW MASK PORT; do\n      echo_green_star >&2\n      echo \"Contacting PXE server $SERVER\" >&2\n\n      if [ \"$PORT\" = \"\" ]; then PORT=\"7529\"; fi\n\n      init_network_ip\n\n      echo \"* Downloading PXE file list\" >&2\n\n      PROTOCOL=http\n      wget -q -O \"$1/PXEFILELIST\" \"http://$SERVER:$PORT/PXEFILELIST?$(uname -r):$(uname -m)\"\n      if [ $? -ne 0 ]; then\n         echo \"Error downloading from http://$SERVER:$PORT, trying TFTP\" >&2\n         PROTOCOL=tftp\n         echo PXEFILELIST | tftp_mget \"$SERVER\" \"$1\"\n      fi\n\n      echo \"* Downloading files from the list\" >&2\n\n      if [ \"$PROTOCOL\" = \"http\" ]; then\n         cat \"$1/PXEFILELIST\" | while read FILE; do\n            wget -O \"$1/$LIVEKITNAME/$(basename $FILE)\" \"http://$SERVER:$PORT/$FILE\"\n         done\n      else\n         JOBS=3\n         for i in $(seq 1 $JOBS); do\n            awk \"NR % $JOBS == $i-1\" \"$1/PXEFILELIST\" | tftp_mget \"$SERVER\" \"$1/$LIVEKITNAME\" &\n         done\n         wait\n      fi\n   done\n\n   echo \"$1/$LIVEKITNAME\"\n}\n\n\n# Find LIVEKIT data by mounting all devices\n# If found, keep mounted, else unmount\n# $1 = data directory target (mount here)\n# $2 = data directory which contains compressed bundles\n#\nfind_data_try()\n{\n   debug_log \"find_data_try\" \"$*\"\n\n   local DEVICE FS FROM OPTIONS MOUNT\n\n   mkdir -p \"$1\"\n   blkid | sort | cut -d: -f 1 | grep -E -v \"/loop|/ram|/zram\" | while read DEVICE; do\n      FROM=\"$2\"\n\n      # supported syntax is even like from=/dev/sr0/livekitname. It is not so much\n      # optiomal to put the following block of code here inside the while loop,\n      # but there is no harm so lets modify DEVICE and FROM to make it work\n      if echo \"$FROM\" | grep -q '^/dev/'; then\n         DEVICE=\"$(echo \"$FROM\" | cut -d '/' -f 1-3)\"\n         FROM=\"$(echo \"$FROM\" | cut -d '/' -f 4-)\"\n         if [ \"$FROM\" = \"\" ]; then\n            FROM=\"$LIVEKITNAME\"\n         fi\n      fi\n\n      FS=\"$(device_bestfs \"$DEVICE\")\"\n      OPTIONS=\"$(fs_options $FS)\"\n      MOUNT=\"$(mount_command $FS)\"\n\n      $MOUNT \"$DEVICE\" \"$1\" $OPTIONS 2>/dev/null\n\n      # if the FROM parameter is actual file, mount it again as loop (eg. iso)\n      if [ -f \"$1/$FROM\" ]; then\n         mkdir -p \"$1/../iso\"\n         mount -o loop,ro \"$1/$FROM\" \"$1/../iso\" 2>/dev/null\n         FROM=\"../iso/$LIVEKITNAME\"\n      fi\n\n      # search for bundles in the mounted directory\n      if [ \"$(find \"$1/$FROM\" -maxdepth 1 -name \"*.$BEXT\" 2>/dev/null)\" != \"\" ]; then\n         # we found at least one bundle/module here\n         echo \"$FROM\" > /var/log/from.log\n         echo \"$1/$FROM\" | tr -s \"/\" | sed -r \"s:/[^/]+/[.][.]/:/:g\"\n         return\n      fi\n\n      # search for bundles in modules directory\n      if [ \"$(find \"$1/$FROM/modules\" -maxdepth 1 -name \"*.$BEXT\" 2>/dev/null)\" != \"\" ]; then\n         # we found at least one bundle/module here\n         echo \"$1/$FROM\" | tr -s \"/\" | sed -r \"s:/[^/]+/[.][.]/:/:g\"\n         echo \"$FROM\" > /var/log/from.log\n         return\n      fi\n\n      # unmount twice, since there could be mounted ISO as loop too. If not, it doesn't hurt\n      umount \"$1\" 2>/dev/null\n      umount \"$1\" 2>/dev/null\n   done\n}\n\n\n# Retry finding LIVEKIT data several times,\n# until timeouted or until data is found\n# $1 = timeout\n# $2 = data directory target (mount here)\n#\nfind_data()\n{\n   debug_log \"find_data\" \"$*\"\n\n   local DATA FROM TIMEOUT ASKPID\n\n   FROM=\"$(cmdline_value from)\"\n\n   # boot parameter specified as from=http://server.com/file.iso\n   if [ \"$(echo $FROM | grep 'http://')\" != \"\" ]; then\n      mount_data_http \"$FROM\" \"$2\"\n      return\n   fi\n\n   # if we got IP address as boot parameter, it means we booted over PXE\n   if [ \"$(cmdline_value ip)\" != \"\" ]; then\n      download_data_pxe \"$2\"\n      return\n   fi\n\n   # If user wants to get asked, ask and periodically update list of devices\n   if [ \"$FROM\" = \"ask\" ]; then\n      (\n         while true; do\n            blkid -o full -s TYPE -s LABEL | grep -E -v \"/loop|/ram|/zram|swap\" | while read LINE; do\n               DISK=\"$(echo \"$LINE\" | cut -d : -f 1)\"\n               SIZE=\"$(fdisk -l \"$DISK\" 2>/dev/null | grep $DISK | grep : | sed -r \"s/.*: |,.*//g\")\"\n               echo -n \"$DISK: $SIZE, \"\n               echo \"$LINE\" | sed -r 's/[^\"]*\"([^\"]*)\"/\\1, /g' | sed -r 's/, $//'\n            done >/tmp/0.txt\n            mv -f /tmp/0.txt /tmp/ask.txt\n            sleep 1\n         done\n      ) &\n      ASKPID=$!\n      sleep 1 # give blkid some chance to finish\n      FROM=\"$(ncurses-menu -t \"Look for /$LIVEKITNAME/ directory on:\" -f /tmp/ask.txt -s 2>&1 >/dev/tty1 < /dev/tty1)\"\n      FROM=\"$(echo \"$FROM\" | cut -d : -f 1)/$LIVEKITNAME\"\n      kill $ASKPID\n   fi\n\n   # default to livekitname autodetected on all disks\n   if [ \"$FROM\" = \"\" ]; then FROM=\"$LIVEKITNAME\"; fi\n\n   echo_green_star >&2\n   echo -n \"Looking for $LIVEKITNAME data in /$FROM ..\" | tr -s \"/\" >&2\n   for TIMEOUT in $(seq 1 $1); do\n      echo -n \".\" >&2\n      refresh_devs\n      DATA=\"$(find_data_try \"$2\" \"$FROM\")\"\n      if [ \"$DATA\" != \"\" ]; then\n         echo \"\" >&2\n         echo \"* Found on $(mounted_device \"$2\")\" >&2\n         echo \"$DATA\"\n         return\n      fi\n      sleep 1\n   done\n   echo \"\" >&2\n}\n\n\n# Check if data is found and exists\n# $1 = data directory\n#\ncheck_data_found()\n{\n   if [ \"$1\" = \"\" -o ! -d \"$1\" ]; then\n      fatal \"Could not locate $LIVEKITNAME data\";\n   fi\n}\n\n\n# Get a human readable format of time elapsed since given datetime\n# $1 = date time\n#\ndate_diff_since_now()\n{\n   local NOW TIMESTAMP SEC MINS HOURS DAYS\n\n   NOW=$(date '+%s')\n   TIMESTAMP=$(date --date \"$1\" '+%s')\n   SEC=$(($NOW - $TIMESTAMP))\n   MINS=$(($SEC / 60))\n   HOURS=$(($SEC / 3600))\n   DAYS=$(($SEC / 86400))\n\n   if [ \"$DAYS\" -gt 0 ]; then echo \"$DAYS days\" | sed -r \"s/^1 days/1 day/\";\n   elif [ \"$HOURS\" -gt 0 ]; then echo \"$HOURS hours\" | sed -r \"s/^1 hours/1 hour/\";\n   elif [ \"$MINS\" -gt 0 ]; then echo \"$MINS minutes\" | sed -r \"s/^1 minutes/1 minute/\";\n   else echo \"$SEC seconds\" | sed -r \"s/^1 seconds/1 second/\";\n   fi\n}\n\n\n# Restore persistent changes from previous session.\n# Store persistent changes to a directory and keep the directory in a session file,\n# so we know which session was active last time so we can resume it next time\n# $1 = changes directory\n#\nrestore_perch_session()\n{\n   debug_log \"restore_perch_session\" \"$*\"\n\n   local TIMEOUT DEVICE FS OPTIONS MOUNT\n   local CHANDIR PERCHDIR FILE LAST LASTMOD LASTSESSION NEW DIR USAGE LAST DAYS\n\n   CHANDIR=\"$1\"\n   PERCHDIR=\"$(cmdline_value perchdir)\"\n\n   # Supported syntax is even like perchdir=/dev/sda1/changes\n   # In this case, perchdir is mounted over $CHANDIR and is set to ask\n   if echo \"$PERCHDIR\" | grep -q '^/dev/'; then\n      DEVICE=\"$(echo \"$PERCHDIR\" | cut -d '/' -f 1-3)\"\n      PERCHDIR=\"$(echo \"$PERCHDIR\" | cut -d '/' -f 4-)\"\n\n      FS=\"$(device_bestfs \"$DEVICE\")\"\n      OPTIONS=\"$(fs_options $FS)\"\n      MOUNT=\"$(mount_command $FS)\"\n\n      echo -n \"* Waiting for persistent changes on $DEVICE ..\" >&2\n      for TIMEOUT in $(seq 1 20); do\n         echo -n \".\" >&2\n         refresh_devs\n         $MOUNT \"$DEVICE\" \"$CHANDIR\" $OPTIONS 2>/dev/null\n         if [ $? -eq 0 ]; then\n            if [ \"$PERCHDIR\" != \"\" -a \"$PERCHDIR\" != \"/\" ]; then\n               mkdir -p \"$CHANDIR/$PERCHDIR\"\n               $MOUNT --bind \"$CHANDIR/$PERCHDIR\" \"$CHANDIR\"\n               if [ $? -eq 0 ]; then\n                 echo -e \"\\n\" >&2\n                 PERCHDIR=ask\n                 break\n               fi\n            else\n              echo -e \"\\n\" >&2\n               PERCHDIR=ask\n               break\n            fi\n         fi\n         sleep 1\n      done\n   fi\n\n   LAST=last_session.txt\n   LASTSESSION=$(cat \"$CHANDIR/$LAST\" 2>/dev/null)\n\n   # ask for session, print msgs to stderr so it is visible\n   if [ \"$LASTSESSION\" != \"\" -a \"$PERCHDIR\" = \"ask\" ]; then\n      ls -1 $CHANDIR | grep -E \"^[0-9]+\" | while read DIR; do\n         USAGE=$(du -s -h \"$CHANDIR/$DIR\" 2>/dev/null | sed -r \"s/[[:space:]].*//\")\n         LASTMOD=\"$(date -r \"$CHANDIR/$DIR\" \"+%Y-%m-%d %H:%M:%S\")\"\n         DAYS=$(date_diff_since_now \"$LASTMOD\")\n         echo \"$LASTMOD Resume session #$DIR - last access $DAYS ago - using $USAGE\" | sed -r \"s/(.)\\$/ \\\\1B/\"\n      done | sort -r | cut -d \" \" -f 3- > /tmp/sessions.txt\n\n      PERCHDIR=\"$(ncurses-menu -t 'Select action:' -o 'Start a new session' -f /tmp/sessions.txt 2>&1 >/dev/tty1 < /dev/tty1)\"\n\n      if echo \"$PERCHDIR\" | grep -q \"new\"; then\n         PERCHDIR=\"new\"\n      else\n         PERCHDIR=\"$(echo \"$PERCHDIR\" | sed -r 's/.*#//' | sed -r 's/[^0-9].*//')\"\n      fi\n   fi\n\n   # restore name for previous session if empty\n   if [ \"$PERCHDIR\" = \"\" -o \"$PERCHDIR\" = \"resume\" ]; then\n      PERCHDIR=\"$LASTSESSION\"\n   fi\n\n   # if last is empty or new/nonexistent is requested, create new\n   if [ \"$PERCHDIR\" = \"\" -o \"$PERCHDIR\" = \"new\" -o ! -d \"$CHANDIR/$PERCHDIR\" ]; then\n      NEW=\"$(ls -1 $CHANDIR | egrep '^[0-9]' | sed -r 's/[^0-9].*//' | sort | tail -n 1)\"\n      NEW=$(($NEW + 1))\n      mkdir -p \"$CHANDIR/$NEW\"\n      PERCHDIR=\"$NEW\"\n   fi\n\n   # remember current, update timestamp\n   echo \"$PERCHDIR\" > \"$CHANDIR/$LAST\"\n   touch \"$CHANDIR/$PERCHDIR\"\n   echo \"$PERCHDIR\"\n}\n\n\n# Activate persistent changes\n# $1 = data directory\n# $2 = target changes directory\n#\npersistent_changes()\n{\n   debug_log \"persistent_changes\" \"$*\"\n\n   local CHANGES T1 T2 EXISTS DEVICE PERCHDIR PERCHSIZE PERCHFILE GROWDIR\n\n   CHANGES=\"$1/$(basename \"$2\")\"\n   DEVICE=\"$(df $1 | tail -n 1 | cut -d \" \" -f 1)\"\n   T1=\"$CHANGES/.empty\"\n   T2=\"$T1\"2\n\n   # Setup the directory anyway, it will be used in all cases\n   mkdir -p \"$2\"\n\n   # If persistent changes are not requested, end here\n   # so memory will be used to save chanves temporarily\n   if grep -vq perch /proc/cmdline; then\n      return\n   fi\n\n   PERCHDIR=$(restore_perch_session \"$CHANGES\")\n\n   # check if changes directory exists and is writable\n   touch \"$T1\" 2>/dev/null && rm -f \"$T1\" 2>/dev/null\n\n   # if not, simply return back\n   if [ $? -ne 0 ]; then\n      echo \"* Persistent changes not writable or not used\"\n      return\n   fi\n\n   # try to use native fs if posix-compatible\n   echo_green_star\n   echo \"Testing persistent changes for posix compatibility\"\n   touch \"$T1\" && ln -sf \"$T1\" \"$T2\" 2>/dev/null && \\\n   chmod +x \"$T1\" 2>/dev/null && test -x \"$T1\" && \\\n   chmod -x \"$T1\" 2>/dev/null && test ! -x \"$T1\" && \\\n   rm \"$T1\" \"$T2\" 2>/dev/null\n\n   if [ $? -eq 0 ]; then\n      if device_bestfs $DEVICE | grep -v ntfs >/dev/null; then\n         echo \"* Activating native persistent changes for session #$PERCHDIR\"\n         mount --bind \"$CHANGES/$PERCHDIR\" \"$2\"\n         return\n      fi\n   else\n      # if test failed at any point, we may have temp files left behind\n      rm \"$T1\" \"$T2\" 2>/dev/null\n   fi\n\n\n   # If we are here, native fs was not supported or user requested perchsize anyway\n\n   PERCHSIZE=$(cmdline_value perchsize | sed -r \"s/TB?/000000/i\" | sed -r \"s/GB?/000/i\" | sed -r \"s/[^0-9]//g\")\n\n   if [ \"$PERCHSIZE\" = \"\" ]; then\n      PERCHSIZE=16000\n   fi\n\n   # minimum size is 16GB\n   if [ \"$PERCHSIZE\" -lt 16000 ]; then\n      PERCHSIZE=16000\n   fi\n\n   PERCHFILE=\"$PERCHDIR/changes.dat\"\n\n   # resume or use new\n   if [ -e \"$CHANGES/$PERCHFILE\" ]; then\n      echo \"* Resuming persistent changes for session #$PERCHDIR\"\n      EXISTS=\"true\"\n   else\n      echo \"* Creating new persistent changes for session #$PERCHDIR\"\n      EXISTS=\"\"\n   fi\n\n   # mount it, splitsize of 4000MB is hardcoded, it must be the same all the time anyway\n   echo \"- mounting dynamically enlarged storage\"\n   @mount.dynfilefs -f \"$CHANGES/$PERCHFILE\" -s $PERCHSIZE -m \"$2\" -p 4000\n   if [ ! \"$EXISTS\" ]; then\n      echo \"- creating filesystem\"\n      mkfs.xfs.custom \"$2/virtual.dat\"\n   fi\n\n   if [ \"$PERCHSIZE\" -gt 16000 ]; then\n      GROWDIR=/tmp/changes.grow\n      echo \"- grow if needed\"\n      mkdir -p \"$GROWDIR\"\n      mount -o loop \"$2/virtual.dat\" \"$GROWDIR\"\n      xfs_growfs \"$GROWDIR\" >/dev/null\n      umount \"$GROWDIR\"\n      rmdir \"$GROWDIR\"\n   fi\n\n   echo \"- mounting persistent changes\"\n   mount -o loop \"$2/virtual.dat\" \"$2\"\n}\n\n\n# Copy content of rootcopy directory to union\n# $1 = data directory\n# $2 = union directory\ncopy_rootcopy_content()\n{\n   debug_log \"copy_rootcopy_content\" \"$*\"\n\n   if [ \"$(ls -1 \"$1/rootcopy/\" 2>/dev/null)\" != \"\" ]; then\n      echo_green_star\n      echo \"Copying content of rootcopy directory...\"\n      cp -a \"$1\"/rootcopy/* \"$2\"\n   fi\n}\n\n\n# Run user custom preinit script if it exists\n# $1 = data directory\n# $2 = union directory\nuser_preinit()\n{\n   debug_log \"user_preinit\" \"$*\"\n\n   local SRC\n\n   SRC=\"$1/rootcopy/run/preinit.sh\"\n\n   if [ \"$(ls -1 \"$SRC\" 2>/dev/null)\" != \"\" ]; then\n      echo_green_star\n      echo \"Executing user custom preinit...\"\n      debug_log \"Executing user custom preinit [$SRC]\"\n      . \"$SRC\" \"$2\"\n   fi\n}\n\n\n# Copy data to RAM if requested\n# $1 = live data directory\n# $2 = changes directory\n#\ncopy_to_ram()\n{\n   debug_log \"copy_to_ram\" \"$*\"\n\n   local MDIR MDEV RAM CHANGES\n\n   if grep -vq toram /proc/cmdline; then\n      echo \"$1\"\n      return\n   fi\n\n   echo \"* Copying $LIVEKITNAME data to RAM...\" >&2\n   RAM=\"$(dirname \"$2\")\"/toram\n   mkdir  -p \"$RAM\"\n   cp -a \"$1\"/* \"$RAM\"\n   echo \"$RAM\"\n\n   MDIR=\"$(mounted_dir \"$1\")\"\n   MDEV=\"$(mounted_device \"$1\")\"\n   MDEV=\"$(losetup $MDEV 2>/dev/null | cut -d \" \" -f 3)\"\n   umount \"$MDIR\" 2>/dev/null\n\n   if [ \"$MDEV\" ]; then # iso was mounted here, try to unmount the FS it resides on too\n      MDEV=\"$(mounted_device \"$MDEV\")\"\n      umount \"$MDEV\" 2>/dev/null\n   fi\n}\n\n\n# load filter\n#\nfilter_load()\n{\n   local FILTER\n   FILTER=$(cmdline_value load)\n   if [ \"$FILTER\" = \"\" ]; then\n      cat -\n   else\n      cat - | egrep \"$FILTER\"\n   fi\n}\n\n\n# noload filter\n#\nfilter_noload()\n{\n   local FILTER\n   FILTER=$(cmdline_value noload)\n   FILTER=${FILTER//,/|}\n   if [ \"$FILTER\" = \"\" ]; then\n      cat -\n   else\n      cat - | egrep -v \"$FILTER\"\n   fi\n}\n\n# sort modules by number even if they are in subdirectory\n#\nsortmod()\n{\n   cat - | sed -r \"s,(.*/(.*)),\\\\2:\\\\1,\" | sort -n | cut -d : -f 2-\n}\n\n\n# Mount squashfs filesystem bundles\n# $1 = directory where to search for bundles\n# $2 = directory where to mount bundles\nmount_bundles()\n{\n   echo_green_star\n   echo \"Mounting bundles\"\n   ( ls -1 \"$1\" | sort -n ; cd \"$1\" ; find modules/ 2>/dev/null | sortmod | filter_load) | grep '[.]'$BEXT'$' | filter_noload | while read BUNDLE; do\n      echo \"* $BUNDLE\"\n      BUN=\"$(basename \"$BUNDLE\")\"\n      mkdir -p \"$2/$BUN\"\n      mount -o loop,ro -t squashfs \"$1/$BUNDLE\" \"$2/$BUN\"\n   done\n}\n\n\n# Add mounted bundles to aufs union\n# $1 = directory where bundles are mounted\n# $2 = directory where union is mounted\n#\nunion_append_bundles()\n{\n   debug_log \"union_append_bundles\" \"$*\"\n\n   if aufs_is_supported >/dev/null; then\n      echo_green_star\n      echo \"Adding bundles to union\"\n      find \"$1\" -mindepth 1 -maxdepth 1 | sortmod | while read BUNDLE; do\n         mount -o remount,add:1:\"$BUNDLE=rr+wh\" aufs \"$2\"\n      done\n   fi\n}\n\n\n# Create empty fstab properly\n# $1 = root directory\n# $2 = directory where boot disk is mounted\n#\nfstab_create()\n{\n   debug_log \"fstab_create\" \"$*\"\n\n   local FSTAB DEVICE FS LABEL BOOTDEVICE OPTS\n\n   FSTAB=\"$1/etc/fstab\"\n   echo aufs / aufs defaults 0 0 > $FSTAB\n   echo proc /proc proc defaults 0 0 >> $FSTAB\n   echo sysfs /sys sysfs defaults 0 0 >> $FSTAB\n   echo devpts /dev/pts devpts gid=5,mode=620 0 0 >> $FSTAB\n   echo tmpfs /dev/shm tmpfs defaults 0 0 >> $FSTAB\n\n   if grep -vq automount /proc/cmdline; then\n      return\n   fi\n\n   BOOTDEVICE=$(df \"$2\" | tail -n 1 | cut -d \" \" -f 1)\n\n   echo >> $FSTAB\n\n   blkid | grep -v \"^/dev/loop\" | grep -v \"^/dev/zram\" | cut -d: -f 1 | while read DEVICE; do\n      FS=\"$(device_bestfs $DEVICE)\"\n      LABEL=\"$(basename $DEVICE)\"\n      OPTS=\"defaults,noatime,nofail,x-systemd.device-timeout=10\"\n\n      if [ \"$FS\" != \"\" -a \"$FS\" != \"swap\" -a \"$FS\" != \"squashfs\" -a \"$DEVICE\" != \"$BOOTDEVICE\" ]; then\n         mkdir -p \"$1/media/$LABEL\"\n         echo \"$DEVICE\" \"/media/$LABEL\" $FS $OPTS 0 0 >> $FSTAB\n      fi\n   done\n}\n\n\n# Change root and execute init\n# $1 = where to change root\n#\nchange_root()\n{\n   debug_log \"change_root\" \"$*\"\n\n   # if we are booting over httpfs, we need to copyup some files so they are\n   # accessible on union without any further lookup down, else httpfs locks\n   if [ \"$(network_device)\" != \"\" ]; then\n      touch \"/net.up.flag\"\n      touch \"$1/etc/resolv.conf\"\n      touch \"$1/etc/hosts\"\n      touch \"$1/etc/gai.conf\"\n   fi\n\n   umount /proc\n   umount /sys\n\n   cd \"$1\"\n\n   # make sure important device files and directories are in union\n   mkdir -p boot dev proc sys tmp media mnt run\n   chmod 1777 tmp\n   if [ ! -e dev/console ]; then mknod dev/console c 5 1; fi\n   if [ ! -e dev/tty ]; then mknod dev/tty c 5 0; fi\n   if [ ! -e dev/tty0 ]; then mknod dev/tty0 c 4 0; fi\n   if [ ! -e dev/tty1 ]; then mknod dev/tty1 c 4 1; fi\n   if [ ! -e dev/null ]; then mknod dev/null c 1 3; fi\n   if [ ! -e sbin/fsck.aufs ]; then ln -s /bin/true sbin/fsck.aufs; fi\n\n   # find chroot and init\n   if [ -x bin/chroot -o -L bin/chroot ]; then  CHROOT=bin/chroot; fi\n   if [ -x sbin/chroot -o -L sbin/chroot ]; then  CHROOT=sbin/chroot; fi\n   if [ -x usr/bin/chroot -o -L usr/bin/chroot ]; then  CHROOT=usr/bin/chroot; fi\n   if [ -x usr/sbin/chroot -o -L usr/sbin/chroot ]; then CHROOT=usr/sbin/chroot; fi\n   if [ \"$CHROOT\" = \"\" ]; then fatal \"Can't find executable chroot command\"; fi\n\n   if [ -x bin/init -o -L bin/init ]; then INIT=bin/init; fi\n   if [ -x sbin/init -o -L sbin/init  ]; then INIT=sbin/init; fi\n   if [ \"$INIT\" = \"\" ]; then fatal \"Can't find executable init command\"; fi\n\n   mkdir -p run\n   mount -t tmpfs tmpfs run\n   mkdir -p run/initramfs\n   mount -n -o remount,ro aufs .\n   pivot_root . run/initramfs\n   exec $CHROOT . $INIT < dev/console > dev/console 2>&1\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}