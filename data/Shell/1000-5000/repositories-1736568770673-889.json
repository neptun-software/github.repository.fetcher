{
  "metadata": {
    "timestamp": 1736568770673,
    "page": 889,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "qoomon/docker-host",
      "stars": 1111,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.212890625,
          "content": "# syntax=docker/dockerfile:1\nFROM alpine:3.20.2\n\nRUN apk --no-cache upgrade \\\n && apk --no-cache add  \\\n    # nftables \\\n    iptables iptables-legacy \\\n    libcap\n\nCOPY ./entrypoint.sh /\n\nENTRYPOINT [\"/entrypoint.sh\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2018 Bengt Brodersen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.1044921875,
          "content": "\n# docker-host [![starline](https://starlines.qoo.monster/assets/qoomon/docker-host)](https://github.com/qoomon/starlines)\n\n[![GitHub release](https://img.shields.io/github/release/qoomon/docker-host.svg)](https://hub.docker.com/r/qoomon/docker-host/)\n[![Docker Stars](https://img.shields.io/docker/pulls/qoomon/docker-host.svg)](https://hub.docker.com/r/qoomon/docker-host/)\n[![Build Workflow](https://github.com/qoomon/docker-host/workflows/Build/badge.svg)](https://github.com/qoomon/docker-host/actions?query=workflow%3ABuild)\n\n\nDocker Image Tags:\n* `latest`\n* `3`\n* `3.x.x`\n\nDocker image to forward **TCP** and **UDP** traffic to the docker host. This\nalso works for (rootless) podman. This README.md uses the term docker, but you\ncan read that as both `docker` and `podman` (it works for both), unless\notherwise specified.\n\nThis container will determine the docker host address in the following order\n* If set use environment variable `DOCKER_HOST`. Can be an IP address or a DNS name.\n  * This allows you to use this image to forward traffic to arbitrary destinations, not only the docker host.\n* Try to resolve host address from DNS names.\n  * docker hostname `host.docker.internal` \n  * podman hostname `host.containers.internal`\n* Defaults to default gateway (`ip -4 route show default`)\n\n#### Ports\nBy default all ports (`1-65535`) are forwarded to docker host. \n\n* You may restrict ports by setting environment variable `PORTS` to a space and/or comma separated list of ports and/or port ranges e.g \n  * `docker run -e PORTS='443, 8000-9000' ...`. \n* You may also configure port mapping e.g. `443:8443, 8000-9000:5000-6000` (`CONTAINER_PORT:HOST_PORT`).\n\n---\n> [!IMPORTANT]\n> #### On **Linux systems**\n> \n> * You have to bind your host applications to `0.0.0.0` or `bridge` network gateway in addition to `127.0.0.1`. \n> \n>   Use following docker command to get the bridge network gateway IP address \n> \n>   `docker network inspect bridge --format='{{( index .IPAM.Config 0).Gateway}}'`\n> \n>   > For (rootless) **podman**, it's sufficient to bind to localhost, assuming\n>   > default podman installation.\n> \n> * You might need to configure your firewall of the host system to allow the docker-host container to communicate with the host on your relevant port, see [#21](https://github.com/qoomon/docker-host/issues/21#issuecomment-497831038).\n> \n> #### On **MacOS systems**\n> \n> ##### Podman Only\n> \n> * You probably need to add `nf_nat` kernal module to podman machine by running following commands\n> \n>   ```shell\n>   podman machine ssh\n> \n>   sudo modprobe nf_nat\n>   ```\n\n---\n\n# Examples\nThese examples will send messages from docker container to docker host with `netcat`\n\n### Preparation\nStart `netcat` server **TCP** on port `2323` to receive and display messages\n```sh\nnc -lk 2323\n```\nStart `netcat` server **UDP** on port `5353` to receive and display messages\n```sh\nnc -lk 5353 -u\n```   \n\n## Docker Link\nRun the dockerhost container.\n```sh\ndocker run \\\n  --name 'docker-host' \\\n  --cap-add=NET_ADMIN --cap-add=NET_RAW \\\n  --restart on-failure \\\n  -d qoomon/docker-host\n```\nRun your application container and link the dockerhost container.\nThe dockerhost will be reachable through the domain/link `dockerhost` of the dockerhost container\n#### This example will let you send messages to **TCP** `netcat` server on docker host.\n```sh\ndocker run --rm \\\n  --link 'docker-host' \\\n  -it alpine nc 'docker-host' 2323 -v\n```\n#### This example will let you send messages to **UDP** `netcat` server on docker host.\n```sh\ndocker run --rm \\\n  --link 'docker-host' \\\n  -it alpine nc 'docker-host' 5353 -u -v\n```\n\n## Docker Network\nCreate the dockerhost network.\n```sh\nnetwork_name=\"Network-$RANDOM\"\ndocker network create \"$network_name\"\n```\nRun the dockerhost container within the dockerhost network.\n```sh\ndocker run --name \"${network_name}-docker-host\" \\\n  --cap-add=NET_ADMIN --cap-add=NET_RAW \\\n  --restart on-failure \\\n  --net=${network_name} --network-alias 'docker-host' \\\n  qoomon/docker-host\n```\nRun your application container within the dockerhost network.\nThe dockerhost will be reachable through the domain/link `docker-host` of the dockerhost container\n#### This example will let you send messages to **TCP** `netcat` server on docker host.\n```sh\ndocker run --rm \\\n  --link 'docker-host' \\\n  -it alpine nc 'docker-host' 2323 -v\n```\n#### This example will let you send messages to **UDP** `netcat` server on docker host.\n```sh\ndocker run --rm \\\n  --link 'docker-host' \\\n  -it alpine nc 'docker-host' 5353 -u -v\n```\n\n## Docker Compose\n```yaml\nversion: '2'\n\nservices:\n    docker-host:\n        image: qoomon/docker-host\n        cap_add: [ 'NET_ADMIN', 'NET_RAW' ]\n        mem_limit: 8M\n        restart: on-failure\n    tcp_message_emitter:\n        depends_on: [ docker-host ]\n        image: alpine\n        command: [ \"sh\", \"-c\", \"while :; do date; sleep 1; done | nc 'docker-host' 2323 -v\"]\n    udp_message_emitter:\n        depends_on: [ docker-host ]\n        image: alpine\n        command: [ \"sh\", \"-c\", \"while :; do date; sleep 1; done | nc 'docker-host' 5353 -u -v\"]\n```\n\n---\n# External References\n* https://medium.com/@sam_ngu/connecting-to-docker-host-mysql-from-docker-container-linux-ubuntu-766e526542fd\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.5419921875,
          "content": "version: '2'\n\nservices:\n    dockerhost:\n        image: qoomon/docker-host\n        cap_add: [ 'NET_ADMIN', 'NET_RAW' ]\n        mem_limit: 8M\n        restart: on-failure\n    tcp_message_emitter:\n        depends_on: [ dockerhost ]\n        image: alpine\n        command: [ \"sh\", \"-c\", \"while :; do echo -n 'TCP - '; date; sleep 1; done | nc 'dockerhost' 2323 -v\"]\n    udp_message_emitter:\n        depends_on: [ dockerhost ]\n        image: alpine\n        command: [ \"sh\", \"-c\", \"while :; do echo -n 'UDP - '; date; sleep 1; done | nc 'dockerhost' 5353 -u -v\"]\n"
        },
        {
          "name": "entrypoint.sh",
          "type": "blob",
          "size": 3.4775390625,
          "content": "#!/bin/sh\n# Use unofficial strict mode of Bash: http://redsymbol.net/articles/unofficial-bash-strict-mode/\nset -euo pipefail\nc=$'\\n\\t'\n\n# since alpine version 3.19.0 iptables-nft is used by default (https://wiki.alpinelinux.org/wiki/Release_Notes_for_Alpine_3.19.0),  \n# however this causes compatibility issues for hosts with older kernels (e.g. Windows > https://github.com/microsoft/WSL/issues/6044), \n# therefore we still use iptables-legacy\nalias iptables=iptables-legacy\n\n# --- Ensure container network capabilities ----------------------------------\n\nif ! capsh --has-p='cap_net_admin' --has-p='cap_net_raw' &>/dev/null\nthen\n  echo \"[ERROR] docker-host container needs Linux capabilities NET_ADMIN and NET_RAW\"\n  echo \"  e.g 'docker run --cap-add=NET_ADMIN --cap-add=NET_RAW ...'\"\n  exit 1\nfi\n\n\n# --- Determine docker host address ------------------------------------------\n\nfunction _resolve_host {\n  ip=$(getent ahostsv4 \"$1\" | head -n1 | cut -d' ' -f1)\n  echo \"$ip\"\n}\n\n# Check if the docker host env var is set\nif [ \"${DOCKER_HOST:-}\" ]\nthen\n  docker_host_source=\"DOCKER_HOST=$DOCKER_HOST\"\n  docker_host_ip=\"$(_resolve_host \"$DOCKER_HOST\")\"\n\n  if [ ! \"$docker_host_ip\" ]\n  then\n    echo \"[ERROR] could not resolve $DOCKER_HOST (DOCKER_HOST) \"\n    exit 1\n  fi\nelse\n  # Check if we can resolve some special hostnames\n  # docker - host.docker.internal\n  # podman - host.containers.internal\n  DOCKER_HOSTNAMES=$'host.docker.internal\\thost.containers.internal'\n  docker_host_ip=\"\"\n\n  for docker_hostname in $DOCKER_HOSTNAMES\n  do\n    docker_host_source=\"$docker_hostname\"\n    docker_host_ip=\"$(_resolve_host \"$docker_hostname\")\"\n    if [ \"$docker_host_ip\" ]\n    then\n      break\n    fi\n  done\n\n  # If none hostname resolves, then we try using the default gateway address\n  if [ ! \"$docker_host_ip\" ]; then\n    docker_host_source=\"default gateway\"\n    docker_host_ip=\"$(ip -4 route show default | cut -d' ' -f3 | head -n1)\"\n  fi\n\n  if [ ! \"$docker_host_ip\" ]\n  then\n    echo \"[ERROR] could not determine docker host ip\"\n    exit 1\n  fi\nfi\n\necho \"Docker Host: $docker_host_ip ($docker_host_source)\"\n\n\n# --- Configure iptables port forwarding -------------------------------------\n\nPORTS=\"${PORTS:-\"1-65535\"}\"\nPORTS=\"$(echo ${PORTS//,/ })\"\n\n# nft add table nat\n# nft add chain nat prerouting  { type nat hook prerouting  priority -100 \\; }\n# nft add chain nat postrouting { type nat hook postrouting priority  100 \\; }\n\necho \"Forwarding ports: ${PORTS// /, }\"\nfor forwarding_port in $PORTS\ndo\n  docker_container_port=\"${forwarding_port%%:*}\"\n  docker_host_port=\"${forwarding_port#*:}\"\n  \n  # nft add rule nat prerouting tcp \\\n  #   dport \"${docker_container_port}\" \\\n  #   dnat to \"$docker_host_ip:$docker_host_port\"\n  iptables --table nat --insert PREROUTING \\\n    --protocol tcp --destination-port \"${docker_container_port/-/:}\" \\\n    --jump DNAT --to-destination \"$docker_host_ip:$docker_host_port\"   \n\n  # nft add rule nat prerouting udp \\\n  #   dport \"${docker_container_port}\" \\\n  #   dnat to \"$docker_host_ip:$docker_host_port\"\n  iptables --table nat --insert PREROUTING \\\n    --protocol udp --destination-port \"${docker_container_port/-/:}\" \\\n    --jump DNAT --to-destination \"$docker_host_ip:$docker_host_port\"\ndone\n\n# nft add rule nat postrouting masquerade\niptables --table nat --insert POSTROUTING --jump MASQUERADE\n\n\n# --- Drop root access and \"Ah, ha, ha, ha, stayin' alive\" ---------------------\n\n# utilize trap to handle docker stop (SIGTERM) and manual interrupt (SIGINT)\nexec su nobody -s /bin/sh -c 'trap : TERM INT; sleep infinity & wait'\n"
        }
      ]
    }
  ]
}