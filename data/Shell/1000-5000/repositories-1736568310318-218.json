{
  "metadata": {
    "timestamp": 1736568310318,
    "page": 218,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "billw2/rpi-clone",
      "stars": 2583,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.48046875,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2018-2019, Bill Wilson\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.62890625,
          "content": "## rpi-clone\nLatest version: 2.0.22\n\nVersion 2 is a complete rewrite with improved capability over\nthe original.  See the examples below.\n\nrpi-clone is a shell script that is for cloning a running\nRaspberry Pi booted source disk (SD card or USB disk) to a destination\ndisk which will be bootable. Destination disks are SD cards in the SD\ncard slot or a USB card reader, USB flash disks, or USB hard drives.\n\nI also use rpi-clone on my Debian desktop, but there are too many\nvariables in how an /etc/fstab can be set up and a desktop bootloader like\ngrub can be configured for this to be an officially supported way of\nusing rpi-clone.  See On other OS below.\n\n\n#### Clone by initialization\nAn initialization clone starts by imaging the source disk partition\ntable to the destination disk This is is a convenience that gets\nthe destination disk partitioned so you can avoid manual partitioning.\nPartitions are then cloned by making destination file systems matching\nthe source file system types followed by file system syncs to the\ndestinations.  Initialization clones are used when the source file system\ntypes or number of partitions do not match the destination.  An initialization\nclone can also be forced by command line option.  An alternative to\nimaging the source partition table is to manually create partitions on\na destination disk with file systems made to match the types in the\nsource partitions.  See example 7 below.\n\n#### Clone by syncing\nIf the source and destination disk partition file system types match,\nthe clone does not start over with a partition table image and making of\nfilesytems, but instead mounts destination partitions corresponding to the\nsource and syncs the file systems.  After a first clone of a disk, this\noperation is an incremental sync which copies only the files that have\nchanged in the source disk and is much faster than an initilization clone.\n\n## Install\nrpi-clone is on github and is downloaded by cloning the repository.\nIt is a standalone script and the install is a simple copy to a\nbin directory.  When run it checks its program dependencies and offers to\ninstall needed packages.  But currently rpi-clone knows how to install\nonly Debian packages with apt-get.\n\n#### On a Raspberry Pi:\n```\n\t$ git clone https://github.com/billw2/rpi-clone.git \n\t$ cd rpi-clone\n\t$ sudo cp rpi-clone rpi-clone-setup /usr/local/sbin\n```\nMake sure /usr/local/sbin is in your $PATH and then run\nrpi-clone or rpi-clone-setup with no args to print usage.\n\nrpi-clone-setup is for setting the hostname in /etc/hostname and /etc/hosts\nfiles.  It is run automatically by rpi-clone if -s args are given,\nbut before your first clone using a -s option, test run rpi-clone-setup with:\n```\n      $ sudo rpi-clone-setup -t testhostname\n```\nAnd check the files under /tmp/clone-test to be sure the files have been\nedited correctly.  If you need additional customizations to a clone,\nadd them to the rpi-clone-setup script.\n\n#### On other OS:\n  To install on another OS, rpi-clone may be renamed to suit.  For example,\n  on my Debian desktop I rename:\n```\n\t$ git clone https://github.com/billw2/rpi-clone.git \n\t$ cd rpi-clone\n\t$ sudo cp rpi-clone /usr/local/sbin/sys-clone\n\t$ sudo cp rpi-clone-setup /usr/local/sbin/sys-clone-setup\n```\nOn SD card systems other than Raspberry Pi, rpi-clone may work\nbecause an initialize clone images the sectors through the start\nof partition 1 to capture the partition table and possible boot loader blocks.\nHowever, unlike the Pi, a bootloader install may need to be run in\nthe setup script.\nAs of version 2.0.21 this may be a new requirement for some systems\nbecause rpi-clone no longer images past the end of the first partition.\n\nrpi-clone does not directly support a traditional desktop OS because there\nare different possible bootloaders and while device names or PARTUUID\nare handled for /etc/fstab, file system UUIDs are not handled.\nHowever, it works for me and I use rpi-clone renamed as sys-clone on\nmy Debian desktop because I use PARTUUID in my fstab and I use the grub\nbootloader (rpi-clone will run grub-install if it detects it installed\nand there is a /boot/grub directory).  Using PARTUUID makes fstab\nediting simple because only a single number identifies the entire disk.\nI do have possible ambiguity in my grub menu setup because I only use\ndevice names in my menu entries while the fstab uses PARTUUID.\nBut what actually happens is that with a root=/dev/sda2 in my grub menu\ndefault boot line, a USB disk will boot as sda if I have the disk plugged\nin when booting, which is what I want.  Device names in fstab are a bad\nidea when doing this because the USB disk root partition could boot and then\nmount my internal drive partitions instead of the USB partitions.  But\nI use PARTUUID so there will not be cross mounting.  And I have a couple\nof extra grub menu entries with other root variations just in case.\n\n\n## Usage\nTo get a usage screen showing available options,\nrun rpi-clone without any arguments:\n```\npi@rpi0: $ sudo rpi-clone\nNo destination disk given.\n\nusage: sys-clone sdN {-v|--verbose} {-f|--force-initialize} {-f2}\n         {-u|--unattended} {-U|--Unattended} {-q|--quiet}\n         {-s|--setup host} {-e|--edit-fstab sdX } {-m|--mountdir dir }\n         {-L|--label-partitions label} {-l|--leave-sd-usb-boot}\n         {-a|--all-sync} {-F|--Force-sync} {-x} {-V|--version}\n         {--convert-fstab-to-partuuid}\n         {--exclude=PATTERN} {--exclude-from=FILE}\n\n    -v\t    - verbose rsync, list all files as they are copied.\n    -f\t    - force initialize the destination disk by imaging the booted disk\n                partition structure.  File systems are then synced or imaged.\n    -f2\t    - force initialize only the first 2 partitions to the destination.\n                So a multi partition USB boot can initialize clone back to\n                a 2 partition SD card.\n    -p size - resize destination partition 1 to 'size' bytes. For two partition\n                initialize (when first clone to blank disk or using -f2 or -f).\n                Use 'sizeM' for MiB size units. eg -p 256M equals -p 268435456\n    -u\t    - unattended clone if not initializing.  No confirmations asked,\n                but abort if disk needs initializing or on error.\n    -U      - unattended even if initializing. No confirmations asked,\n                but abort only on errors.\n    -q      - quiet mode, no output unless errors or initializing. Implies -u.\n    -s host - add 'host' to args passed to script rpi-clone-setup and run it\n                after cloning but before unmounting partitions. For setting\n                clone disk hostname, but args can be what the script expects.\n                You can give multiple -s arg options.\n    -e sdX  - edit destination fstab to change booted device names to new\n      \t        device 'sdX'.  This is Only for fstabs that use device names.\n                Used for setting up a USB bootable disk.\n    -m dir  - Add dir to a custom list of mounted directories to sync.  Then\n                the custom list will be synced instead of the default of all\n                mounted directories.  The root directory is always synced.\n                Not for when initializing.\n    -L lbl  - label for ext type partitions.  If 'lbl' ends with '#', replace\n\t\t\t\tthe '#' with a partition number and label all ext partitions.\n                Otherwise apply label to root partition only.\n    -l      - leave SD card to USB boot alone when cloning to SD card mmcblk0\n                from a USB boot.  This preserves a SD card to USB boot setup\n                by leaving the SD card cmdline.txt using the USB root.\tWhen\n                cloning to USB from SD card this option sets up the SD card\n                cmdline.txt to boot to the USB disk.\n    -a      - Sync all partitions if types compatible, not just mounted ones.\n    -F      - force file system sync or image for some errors. eg:\n                If source used > destination space error, do the sync anyway.\n                If a source partition mount error, skip it and do other syncs.\n    -x      - use set -x for very verbose bash shell script debugging\n    -V      - print rpi-clone version.\n```\n+ See examples below for usage of these command line options.\n+ rpi-clone version 1 briefly had a -s option that is replaced with a\n  -s option that has different meaning.\n+ **--convert-fstab-to-partuuid** converts the booted fstab from using device\nnames to PARTUUID.  This is a helper if you wish to convert to PARTUUID as\nis standard in recent Raspbian distributions.  After running, PARTUUID\nusage will propagate to subsequent clones.  This changes the booted fstab\nand cmdline.txt, so have a backup first.\n+ FUSE mounts (ssh mounts) should be unmounted before cloning or else the\ndirectory mounted on will not stat and the directory will not be made on the\nclone.  You will get a readlink stat error from rsync because root can't access\na users FUSE mount - only the user can.\n+ The examples below show a /boot partition smaller than recommended for the\nrecent Rasbian Buster release. rpi-clone version 2.0.21 adds the -p option so\nthe /boot partition can be resized at the same time the root partition is\nresized to the end of the disk.  If you upgraded Stretch to Buster and are\nrunning with a small /boot, then for the clone to have a resized /boot, run:\n```\n\t$ rpi-clone -f -p 256M sda\n```\n\n\n## rpi-clone Example Runs\n#### 0) Examples review - a quick guide to what the examples cover in detail.\n1. Typical two partition clones - SD card or USB disk to USB disk:\n```\n\t$ rpi-clone sda\n```\n2. USB boot - clone back to SD card slot:\n```\n\t$ rpi-clone mmcblk0\n```\n3. Clone to USB disk intended for use as a standalone Pi3 bootable\ndisk.  No special rpi-clone args are required.\n4. SD card to USB disk clone to create a SD card to USB boot setup:\n```\nIf fstab uses PARTUUID:\n\t$ rpi-clone -l sda\nIf fstab uses device names:\n\t$ rpi-clone -l sda -e sda\n```\n5. USB boot clone back to SD card slot that preserves SD card to USB boot setup:\n```\n\t$ rpi-clone -l mmcblk0\n```\n6. Attempted clone to a disk that is too small.\n7. Manually partition a disk with three partitions so it can\nbe cloned to from a two partition boot.\n8. Clone from three partition disk to smaller disk large enough\nto hold the source three partitions.\n```\n\t$ rpi-clone sdb\n```\n9. Clone from three partition disk to smaller disk (sdN or mmcblk0)\nnot large enough to hold the source three partitions.\nA first initialize clone forces a clone of only the first two partitions:\n```\n\t$ rpi-clone sdb -f2\n```\n10. Subsequent sync clones from three partition disk to two partition\ndisk (sdN or mmcblk0):\n```\nIf the source third partition is not mounted:\n\t$ rpi-clone sdb\nIf the source third partition is mounted, select partitions to clone:\n\t$ rpi-clone sdb -m /boot\n```\n**Note** - if a larger USB disk is manually partitioned to create more than\nthree partitions as in example 7, a smaller disk can be initialize\ncloned to only if it is large enough to hold at least part of the last\nsource partition.\nIf it is not, then the clone will have to be to a two partition -f2\nclone or a clone to a manually partitioned destination.  So, for a\nmulti partition disk, select partition number and sizes with a eye\ntowards how you will be cloning back to smaller disks.\n11. Desktop demo\n\n\n#### 1) First clone to a new SD card in USB card reader\nIn this example a new SD card in a USB card reader has been plugged in\nthat I want to clone to, but it could also be to a USB disk or from a\nUSB disk back to the SD card slot.\nIn this case, the disk showed up as sdb because I have another USB\ndisk sda plugged in. Look in /proc/partitions to see where yours is.\nThe destination disk does not have partition types matching the booted disk.\n+ The clone will be an initialize because of partition types mismatch.\n+ The destination last partition will be resized down in this case because\nthe destination disk is smaller than the booted disk.\n+ rpi-clone will ask for a destination root label which I will give\nso I can keep track of my clones.\n+ If PARTUUID is used in fstab and cmdline.txt, those files will be edited\nto use the PARTUUID of the destination SD card.  The SD card will\nbootable when plugged in to the SD card slot.\n+ If fstab and cmdline.txt use device names (mmcblk0), then rpi-clone\ndoes need to edit the fstab and the card will be bootable when plugged\ninto a SD card slot.\n```\npi@rpi0: $ sudo rpi-clone sdb\n\nBooted disk: mmcblk0 16.0GB                Destination disk: sdb 8.0GB\n---------------------------------------------------------------------------\nPart      Size    FS     Label           Part   Size    FS     Label\n1 /boot   58.4MB  fat16  --              1       8.0GB  fat32  --\n2 root    16.0GB  ext4   SD-RPI-s1                               \n---------------------------------------------------------------------------\n== Initialize: IMAGE mmcblk0 partition table to sdb - FS types mismatch ==\n1 /boot     (22.5MB used)    : IMAGE     to sdb1  FSCK\n2 root      (6.0GB used)     : RESIZE(8.0GB) MKFS SYNC to sdb2\n---------------------------------------------------------------------------\nRun setup script       : no\nVerbose mode           : no\n-----------------------:\n** WARNING **          : All destination disk sdb data will be overwritten!\n                       : The partition structure will be imaged from mmcblk0.\n-----------------------:\n\nInitialize and clone to the destination disk sdb?  (yes/no): yes\nOptional destination rootfs /dev/sdb2 label (16 chars max): SD-RPI-8a\n... \n```\n\n#### 2) Subsequent clone to the same SD card in USB card reader as example 1\nThis time the destination partition type will match the source booted\ntypes, and I'll add a rpi-clone-setup script -s arg to set a\ndifferent destination disk hostname.\n\n+ The clone will be a pure sync where only modified files will be copied.\n+ The setup script will set the hostnames in the destination disk files\n/etc/hostname and /etc/hosts to what I give with -s, in this case rpi2.\n ```\npi@rpi0: $ sudo rpi-clone sdb -s rpi2\n\nBooted disk: mmcblk0 16.0GB                Destination disk: sdb 8.0GB\n---------------------------------------------------------------------------\nPart      Size    FS     Label           Part   Size    FS     Label\n1 /boot   58.4MB  fat16  --              1      58.4MB  fat16  --\n2 root    16.0GB  ext4   SD-RPI-s1       2       8.0GB  ext4   SD-RPI-8a\n---------------------------------------------------------------------------\n== SYNC mmcblk0 file systems to sdb ==\n/boot       (22.5MB used)    : SYNC to sdb1 (58.4MB size)\n/           (6.0GB used)     : SYNC to sdb2 (8.0GB size)\n---------------------------------------------------------------------------\nRun setup script       : rpi-clone-setup  rpi2\nVerbose mode           : no\n-----------------------:\n\nOk to proceed with the clone?  (yes/no): \n```\n\n#### 3) Cloning a Pi3 when fstab uses PARTUUID\nIf fstab and cmdline.txt use PARTUUID as is the case in recent\nRaspbian distributions, rpi-clone always edits**\nthe destination fstab and cmdline.txt to use the PARTUUID of the\ndestination disk.  So the destination is always bootable.  If it\nis a USB flash or hard drive it is automatically bootable on a Pi3\nas a USB disk so long as the Pi3 has been USB boot enabled with\na program_usb_boot_mode=1 line in /boot/config.txt.\n\n** There is one exception.  When using the -l option, which is used for\ncreating or preserving a special SD card to USB boot, the cmdline.txt\non the SD card is not edited after a clone to the SD card, see\nexamples 4 and 5.\n\n#### 4) Creating a USB bootable disk for other than a USB enabled Pi3\nrpi-clone can be used to create a SD card to USB boot setup and preserve\nthat setup when cloning from a USB boot back to the SD card slot.\nWith the SD card booted and a target USB disk plugged in and assuming\nthe USB disk shows up as sda, the initial clone command depends on\nfstab usage of device names or PARTUUID.\n\n=> Before you do this, have a backup of your booted SD card made\nas in example 2 without the -l option because these steps will\nchange the booted SD card cmdline.txt to a USB boot.\n\nIf fstab is using PARTUUID, run:\n```\n$ rpi-clone -l sda\n```\nOr if fstab is using device names, run:\n```\n$ rpi-clone -l -e sda sda\n```\n+ Destination disk \"sda\" will be synced or initialized if required (or add\nthe -f option to force initialize).\n+ After files are synced the destination sda fstab and cmdline.txt will\nbe edited to reference either device names or PARTUUID for the USB disk.\nFor the fstab uses device names case, the \"-e sda\" means to edit the\ndestination /etc/fstab to use \"sda\" for the root (will be sda1) and\n/boot (will be sda2) lines. Also, the destination disk /boot/cmdline.txt\nwill be edited to use root=/dev/sda2.  It is expected that when the USB disk\nis plugged in for booting to, it will be sda and this will be a cause\nof boot failure if it is not.  So using PARTUUID is better because that\nwill reliably boot.\n+ The -l option causes the SD card cmdline.txt to be backed up to\ncmdline.boot and the destination USB disk cmdline.txt to be copied\nto the SD card.  Since the USB cmdline.txt was edited to reference\nthe USB disk, the next Pi boot will start with the SD card\n/boot partition, but will redirect to using the USB root partition.\nSince the USB fstab was edited to reference the USB disk, the Pi will boot\nwith the USB partition 1 mounted on /boot.\nThe SD card /boot partition that initiated the boot process\nis no longer in use but can remain in place for subsequent\nSD card to USB boots.  To make the SD card standalone bootable\nagain, its cmdline.boot can be moved back to cmdline.txt.\n\n+ If -l is not used, rpi-clone will not replace the currently booted SD card\ncmdline.txt and it will need to be edited by hand for the USB boot to work.\n\n+ Also a caution note if fstab uses device names: check your\n/boot to be sure it is mounted with /dev/sda1 after booting to USB.\nI have a Pi where this fails even though syslog says it mounted.\nJust be sure to check when you first do this and before you try example 5.\n\nNow when the Pi is booted from SD card to USB and the SD card is no longer\nin use, the SD card slot is available for cloning to.\n\n#### 5) Cloning back to SD cards in the SD card slot from USB boots\nWhether the boot was a Pi3 straight to USB or a SD card to USB,\nthe SD card is not in use so it is free to clone back to.  This\ncreates a standalone bootable SD card:\n```\n$ rpi-clone mmcblk0\n```\nHowever, for the case where the boot was SD card to USB,\nthis destroys the ability of the SD card to boot to USB.\nTo preserve that SD to USB boot setup, run:\n```\n$ rpi-clone -l mmcblk0\n```\n+ The SD card is cloned to as before.  It now has the USB /boot/cmdline.txt.\n+ But the -l option prevents editing that cmdline.txt to reference the SD card.\nIt is left alone so that it still references the USB root partition.\nSo the clone has created USB disk to SD card backup  while preserving\nthe SD card to USB boot setup.  On the SD card a backup cmdline.boot\nis created and edited to reference the SD card.  That backup can be moved\nto be cmdline.txt to make the SD card standalone bootable should\nyou ever want to do that.\nOr you could just clone to the SD card without using -l.\n+ Both above mmcblk0 clone commands apply whether using PARTUUID or\ndevice names.  When using device names and cloning to SD cards,\nrpi-clone knows fstab device names need editing so \"-e mmcblk0p\" is assumed.\nNow the SD card can be left in permanently and periodically cloned to for\nbackups and reboots to USB will work as you want.  Or other SD\ncards can be inserted to create a set of backups.\nIf making a clone for another Pi that will be SD card bootable, don't use -l.\n+ Warning: this works if the original SD card to USB boot setup has edited\nthe USB /etc/fstab to reference USB partitions as is done by rpi-clone\nwhen creating a USB bootable disk with -l.  If you have an existing\nSD card to USB boot setup where this was not done, then your USB boot\nlikely has the SD card /boot partition mounted, the SD card is in use\nand using rpi-clone for a clone back to the SD card slot will not work.\n\n\n#### 6) Clone to smaller 4GB SD card\nI happen to have an old 4GB SD card and here's a try to clone to it: \n```\nroot@rpi2: ~$ rpi-clone sda\n\nBooted disk: mmcblk0 15.8GB                Destination disk: sda 4.0GB\n---------------------------------------------------------------------------\nPart      Size    FS     Label           Part   Size    FS     Label\n1 /boot   58.4MB  fat16  --              1      58.4MB  fat16  --\n2 root    15.8GB  ext4   SD-RPI-16N      2       3.9GB  ext4   --\n---------------------------------------------------------------------------\n== SYNC mmcblk0 file systems to sda ==\n/boot       (22.5MB used)    : SYNC to sda1 (58.4MB size)\n/           (5.9GB used)     : SYNC to sda2 (3.9GB size)\n---------------------------------------------------------------------------\nRun setup script       : no\nVerbose mode           : no\n-----------------------:\n** FATAL **            : Partition 2: source used > destination space.\n-----------------------:\n\nAborting!\n  Use -F to override used > space fail.\n```\nSo even if rpi-clone thinks that the sync won't work because of lack of\nspace, there is a -F option which will allow the clone to proceed\nanyway.  The interesting thing about this case is that while this might\nseem a bad idea, the sync will actually come close to succeeding.  That's\nbecause the root used space includes a 1.8GB file system based\nswap file (/var/swap) that will be excluded from the sync.  If this\nclone is forced with -F, the card may boot, but there could be some missing\nfiles if the rsync runs out of space and fails to complete and some things\nwould not work.\nThis is just a FYI.\n\n\n#### 7) Clone SD card to USB disk with extra partitions\nIf you have space with a larger USB disk, you can manually partition it\nwith extra partitions and clone to it.  If partition types and file systems\nare made to match the booted SD card, then rpi-clone will sync files and\nnot try to initialize so the extra destination partitions will not be\ntouched.\n\nThe requirement to make this work is getting the first two partition types\nand file systems right, but the sizes may be different. gparted will make\nfilesystems automatically but cfdisk or fdisk will not and if\nfile systems aren't made, rpi-clone will fail to mount the partitions.\n\nFor this example I wanted to partition a 64GB flash disk into 3 partitions\nso I could have a large third partition for data.\nI made the second root partition 16GB so I could clone this to a\n32GB disk and still have a data partition.\n\nIf using cfdisk or fdisk to make the partitions and then making the file\nsystems, the work would be:\n```\n  Partition Type               Size          Make File System\n  1: type c  W95 FAT32 (LBA)   100MiB        mkfs -t vfat -F 32 /dev/sda1\n  2: type 83 Linux              16GiB        mkfs.ext4 /dev/sda2\n  3: type 83 Linux             rest of disk  mkfs.ext4 /dev/sda3\n```\nBut what I did was use gparted so the file systems were made for me.\nAlso, in anticipation of initialize cloning back to SD cards,\nI set the first partition start to be 8192 (by setting \"Free space preceding\"\nto 4MiB) to match Raspbian distribution SD card images.\nAlso I made partition sizes in multiples of 4MiB for SD card compatibility.\n\nNow I cloned to the 64GB disk.  It synced only my two booted partitions\ninstead of initializing, and it left the third partition alone:\n```\npi@rpi2: ~$ sudo rpi-clone sda\n\nBooted disk: mmcblk0 15.8GB                Destination disk: sda 64.2GB\n---------------------------------------------------------------------------\nPart      Size    FS     Label           Part   Size    FS     Label\n1 /boot   58.4MB  fat16  --              1     104.4MB  fat32  --\n2 root    15.8GB  ext4   SD-RPI-16N      2      16.8GB  ext4   Samsung 64GB A\n                                         3      47.3GB  ext4   --\n---------------------------------------------------------------------------\n== SYNC mmcblk0 file systems to sda ==\n/boot       (22.5MB used)    : SYNC to sda1 (104.4MB size)\n/           (5.9GB used)     : SYNC to sda2 (16.8GB size)\n---------------------------------------------------------------------------\nRun setup script       : no\nVerbose mode           : no\n-----------------------:\n\nOk to proceed with the clone?  (yes/no):\n```\nThis was a boot enabled Pi3, so I simply powered down, pulled the SD\ncard, and rebooted into the three partition USB disk.\n\n\n#### 8) Clone 64GB USB disk with extra partitions to smaller 32GB USB disk\nWith the USB disk made in example 7 booted and the third partition mounted,\nthis is a clone to a smaller 32GB USB disk that is still large enough\nto hold three partitions.  The disk is not manually formatted so it will\nbe an initialize clone.  The space used in the 64GB source third partition\nfits into the size of the destination 32GB disk third partition,\nso there is no problem:\n```\npi@rpi2: ~$ sudo rpi-clone sdb\n\nBooted disk: sda 64.2GB                    Destination disk: sdb 31.5GB\n---------------------------------------------------------------------------\nPart               Size    FS     Label           Part   Size    FS     Label\n1 /boot           104.4MB  fat32  --              1      31.5GB  fat32  --\n2 root             16.8GB  ext4   Samsung 64GB A                          \n3 /home/pi/media   47.3GB  ext4   --                                      \n---------------------------------------------------------------------------\n== Initialize: IMAGE sda partition table to sdb - FS types mismatch ==\n1 /boot               (21.5MB used)  : IMAGE     to sdb1  FSCK\n2 root                (5.9GB used)   : MKFS SYNC to sdb2\n3 /home/pi/media      (54.3MB used)  : RESIZE(14.6GB) MKFS SYNC to sdb3\n---------------------------------------------------------------------------\nRun setup script       : no\nVerbose mode           : no\n-----------------------:\n** WARNING **          : All destination disk sdb data will be overwritten!\n                       :   The partition structure will be imaged from sda.\n-----------------------:\n\nInitialize and clone to the destination disk sdb?  (yes/no): \n```\nNote that if I had partitioned the 64GB disk with more than three\npartitions it would have been more difficult to clone down to the\n32GB card.  If there had been 4 partitions, then a smaller disk has\nto be large enough to image the sizes of the first three source partitions.\nIf the disk is too small for that, then an initialize clone would be\nlimited to a two partition clone as the next example shows.  The other\nalternative would be a manual partition.  The take away is that you need\nto consider how you would be cloning to smaller disks when you partition\na larger disk for a Pi.\n\n#### 9) Clone 64GB USB disk with extra partitions to new 16GB SD card\nWith a USB boot, the SD card slot is available for use, so I plugged in\na 16GB SD card to clone to:\n```\npi@rpi2: ~$ sudo rpi-clone mmcblk0\n\nBooted disk: sda 64.2GB                    Destination disk: mmcblk0 15.8GB\n---------------------------------------------------------------------------\nPart               Size    FS     Label           Part   Size    FS     Label\n1 /boot           104.4MB  fat32  --              1      15.8GB  fat32  --\n2 root             16.8GB  ext4   Samsung 64GB A                       \n3 /home/pi/media   47.3GB  ext4   --                                   \n---------------------------------------------------------------------------\nInitialize required    : partition - types mismatch.\n                       :   The minimum destination disk size is 16.9GB\n                       :   The destination disk is too small.\n                       :   You could try a two partition -f2 clone.\n-----------------------:\n```\nThis failed because there is a type mismatch that requires an initialize\nand additionally the SD card does not have the space for three partitions\ngiven the size of the source disk second partition.  The solution is to\ntell rpi-clone to clone only the first two partitions and accept that\nthis backup cannot back up the data partition.  The -f2 option is just\nfor going back to a two partition disk from a multi partitioned disk:\n```\npi@rpi2: ~$ sudo rpi-clone mmcblk0 -f2\n\nBooted disk: sda 64.2GB                    Destination disk: mmcblk0 15.8GB\n---------------------------------------------------------------------------\nPart               Size    FS     Label           Part   Size    FS     Label\n1 /boot           104.4MB  fat32  --              1      15.8GB  fat32  --\n2 root             16.8GB  ext4   Samsung 64GB A                          \n3 /home/pi/media   47.3GB  ext4   --                                      \n---------------------------------------------------------------------------\n== Initialize: IMAGE sda partition table to mmcblk0 - forced by option ==\n1 /boot               (21.5MB used)  : IMAGE     to mmcblk0p1  FSCK\n2 root                (5.9GB used)   : RESIZE(15.7GB) MKFS SYNC to mmcblk0p2\n---------------------------------------------------------------------------\n-f2                    : force initialize to first two partitions only\nRun setup script       : no\nVerbose mode           : no\n-----------------------:\n** WARNING **          : All destination disk mmcblk0 data will be overwritten!\n                       :   The partition structure will be imaged from sda.\n-----------------------:\n\nInitialize and clone to the destination disk mmcblk0?  (yes/no): \n```\nI'm using PARTUUID in /etc/fstab, but if I weren't, this clone would also\nautomatically edit mmcblk0p names into the destination disk fstab.\n\n\n#### 10) Sync Clone 64GB USB disk with extra partitions to 16GB SD card\nWith an initialize clone to the SD card done in example 8, I expect\nsubsequent clones to be sync clones.  But I run the rpi-clone command and\nI get an error requiring another initialize.  This time the\nerror is because rpi-clone wants to clone the mounted third partition and\nthere is no destination third partition:\n```\npi@rpi2: ~$ sudo rpi-clone mmcblk0 \n\nBooted disk: sda 64.2GB                    Destination disk: mmcblk0 15.8GB\n---------------------------------------------------------------------------\nPart               Size    FS     Label           Part   Size    FS     Label\n1 /boot           104.4MB  fat32  --              1     104.4MB  fat32  --\n2 root             16.8GB  ext4   Samsung 64GB A  2      15.7GB  ext4   SD-16c\n3 /home/pi/media   47.3GB  ext4   --                                      \n---------------------------------------------------------------------------\nInitialize required    : partition 3 /home/pi/media - destination missing.\n                       :   Unmount source partitions or use -m\n-----------------------:\n```\nBut I want to sync and not do another long -f2 initialize,\nso there are two choices.\nIf I unmount the third partition, the clone will sync.  If I don't want\nto do that, I can tell rpi-clone to sync clone only the /boot partition\n(the root partition is included by default):\n```\npi@rpi2: ~$ sudo rpi-clone mmcblk0 -m /boot\n\nBooted disk: sda 64.2GB                    Destination disk: mmcblk0 15.8GB\n---------------------------------------------------------------------------\nPart               Size    FS     Label           Part   Size    FS     Label\n1 /boot           104.4MB  fat32  --              1     104.4MB  fat32  --\n2 root             16.8GB  ext4   Samsung 64GB A  2      15.7GB  ext4   SD-16c\n3 /home/pi/media   47.3GB  ext4   --                                      \n---------------------------------------------------------------------------\n== SYNC sda file systems to mmcblk0 ==\n/boot                 (21.5MB used)  : SYNC to mmcblk0p1 (104.4MB size)\n/                     (5.9GB used)   : SYNC to mmcblk0p2 (15.7GB size)\n---------------------------------------------------------------------------\nRun setup script       : no\nVerbose mode           : no\n-----------------------:\n\nOk to proceed with the clone?  (yes/no): \n```\n\n#### 11) Clones from my Debian desktop\nHere are a couple of runs to show how rpi-clone looks handling more complex\npartitioning on my desktop.  I have three primary partitions and extra\nextended partitions.  I don't have a separate /boot partition but have\na small first partition in case I want to change that.\nIt probably won't work if there is a primary partition\nafter an extended partition.\n```\n~$ sudo sys-clone sdb\n/usr/sbin/grub-install\n\nBooted disk: sda 275.1GB                   Destination disk: sdb 320.1GB\n---------------------------------------------------------------------------\nPart         Size    FS    Label           Part   Size    FS  Label\n1             1.0GB  ext4  SSD-275-G6-p1   1     320.1GB  --  --\n2 root       52.4GB  ext4  SSD-275-G6-p2                        \n3            12.6GB  swap  --                                   \n4           209.0GB  EXT   --                                   \n5 /home      62.9GB  ext4  SSD-275-G6-p5                        \n6 /mnt/sda  146.1GB  ext4  SSD-275-G6-p6                        \n---------------------------------------------------------------------------\n== Initialize: IMAGE sda partition table to sdb - FS types mismatch ==\n1                                    : IMAGE     to sdb1\n2 root                (15.3GB used)  : MKFS SYNC to sdb2\n3                                    : MKSWAP\n5 /home               (12.9GB used)  : MKFS SYNC to sdb5\n6 /mnt/sda            (73.1GB used)  : RESIZE(191.1GB) MKFS SYNC to sdb6\n---------------------------------------------------------------------------\nRun setup script       : no\nRun grub               : grub-install --root-directory=/mnt/clone /dev/sdb\nVerbose mode           : no\n-----------------------:\n** WARNING **          : All destination disk sdb data will be overwritten!\n                       :   The partition structure will be imaged from sda.\n-----------------------:\n\nInitialize and clone to the destination disk sdb?  (yes/no): \n```\nAnd a subsequent sync to the same disk after I have manually labeled all\nthe partitions:\n```\n~$ sudo sys-clone sdb\n/usr/sbin/grub-install\n\nBooted disk: sda 275.1GB                   Destination disk: sdb 320.1GB\n---------------------------------------------------------------------------\nPart         Size    FS    Label           Part   Size    FS    Label\n1             1.0GB  ext4  SSD-275-G6-p1   1       1.0GB  ext4  Maxone-320A-p1\n2 root       52.4GB  ext4  SSD-275-G6-p2   2      52.4GB  ext4  Maxone-320A-p2\n3            12.6GB  swap  --              3      12.6GB  swap  --\n4           209.0GB  EXT   --              4     254.0GB  EXT   --\n5 /home      62.9GB  ext4  SSD-275-G6-p5   5      62.9GB  ext4  Maxone-320A-p5\n6 /mnt/sda  146.1GB  ext4  SSD-275-G6-p6   6     191.1GB  ext4  Maxone-320A-p6\n---------------------------------------------------------------------------\n== SYNC sda file systems to sdb ==\n/                     (15.3GB used)  : SYNC to sdb2 (52.4GB size)\n/home                 (12.9GB used)  : SYNC to sdb5 (62.9GB size)\n/mnt/sda              (73.1GB used)  : SYNC to sdb6 (191.1GB size)\n---------------------------------------------------------------------------\nRun setup script       : no\nRun grub               : grub-install --root-directory=/mnt/clone /dev/sdb\nVerbose mode           : no\n-----------------------:\n\nOk to proceed with the clone?  (yes/no): \n```\n\n\n## Author\nBill Wilson\nbillw--at--gkrellm.net\n"
        },
        {
          "name": "rpi-clone",
          "type": "blob",
          "size": 41.8037109375,
          "content": "#!/bin/bash\n\n# rpi-clone is Copyright (c) 2018-2019 Bill Wilson\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted under the conditions of the BSD LICENSE file at\n# the rpi-clone github source repository:\n#    https://github.com/billw2/rpi-clone\n\n\nversion=2.0.22\n\n# setup trusted paths for dependancies (like rsync, grub, fdisk, etc)\nexport PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\n\n# auto run grub-install if grub detected\ngrub_auto=1\n\nPGM=`basename $0`\nsetup_command=\"$PGM-setup\"\n\nrsync_options=\"--force -rltWDEHXAgoptx\"\n\nif [ `id -u` != 0 ]\nthen\n    echo -e \"$PGM needs to be run as root.\\n\"\n    exit 1\nfi\n\nraspbian=0\nraspbian_buster=0\nif [ -f /etc/os-release ]\nthen\n\tpretty=`cat /etc/os-release | grep PRETTY`\n\tif [[ \"$pretty\" == *\"Raspbian\"* ]]\n\tthen\n\t\traspbian=1\n\tfi\n\tif ((raspbian)) && [[ \"$pretty\" == *\"buster\"* ]]\n\tthen\n\t\traspbian_buster=1\n\tfi\nfi\n\nconfirm()\n\t{\n\tif ((unattended || (initialize && Unattended) ))\n\tthen\n\t\treturn 0\n\tfi\n\tprintf \"\\n%s  (yes/no): \" \"$1\"\n\tread resp\n\tif [ \"$resp\" = \"y\" ] || [ \"$resp\" = \"yes\" ]\n\tthen\n\t\treturn 0\n\tfi\n\tif [ \"$2\" == \"abort\" ]\n\tthen\n\t\techo -e \"Aborting!\\n\"\n\t\texit 0\n\tfi\n\treturn 1\n\t}\n\n# sfdisk is in fdisk package\ncommands=\"rsync parted fdisk findmnt column fsck.vfat\"\npackages=\"rsync parted util-linux mount bsdmainutils dosfstools\"\nneed_packages=\"\"\n\nidx=1\nfor cmd in $commands\ndo\n\tif ! command -v $cmd > /dev/null\n\tthen\n\t\tpkg=$(echo \"$packages\" | cut -d \" \" -f $idx)\n\t\tprintf \"%-30s %s\\n\" \"Command not found: $cmd\" \"Package required: $pkg\"\n\t\tneed_packages=\"$need_packages $pkg\"\n\tfi\n\t((++idx))\ndone\n\nif [ \"$need_packages\" != \"\" ]\nthen\n\tconfirm \"Do you want to apt-get install the packages?\" \"abort\"\n\tapt-get install -y --no-install-recommends $need_packages\nfi\n\nclone=/mnt/clone\nclone_src=/mnt/clone-src\nclone_log=/var/log/$PGM.log\n\nHOSTNAME=`hostname`\n\n\nusage()\n\t{\n\techo $\"\nusage: $PGM sdN {-v|--verbose} {-f|--force-initialize} {-f2}\n         {-p|--p1-size size} {-u|--unattended} {-U|--Unattended} {-q|--quiet}\n         {-s|--setup host} {-e|--edit-fstab sdX } {-m|--mountdir dir }\n         {-L|--label-partitions label} {-l|--leave-sd-usb-boot}\n         {-a|--all-sync} {-F|--Force-sync} {-x} {-V|--version}\n         {--convert-fstab-to-partuuid}\n         {--exclude=PATTERN} {--exclude-from=FILE}\n\n    -v\t    - verbose rsync, list all files as they are copied.\n    -f\t    - force initialize the destination disk by imaging the booted disk\n                partition structure.  File systems are then synced or imaged.\n    -f2\t    - force initialize only the first 2 partitions to the destination.\n                So a multi partition USB boot can initialize clone back to\n                a 2 partition SD card.\n    -p size - resize destination partition 1 to 'size' bytes. For two partition\n                initialize (when first clone to blank disk or using -f2 or -f).\n                Use 'sizeM' for MiB size units. eg -p 256M equals -p 268435456\n    -u\t    - unattended clone if not initializing.  No confirmations asked,\n                but abort if disk needs initializing or on error.\n    -U      - unattended even if initializing. No confirmations asked,\n                but abort only on errors.\n    -q      - quiet mode, no output unless errors or initializing. Implies -u.\n    -s host - add 'host' to args passed to script rpi-clone-setup and run it\n                after cloning but before unmounting partitions. For setting\n                clone disk hostname, but args can be what the script expects.\n                You can give multiple '-s arg' options.\n    -e sdX  - edit destination fstab to change booted device names to new\n      \t        device 'sdX'.  This is Only for fstabs that use device names.\n                Used for setting up a USB bootable disk.\n    -m dir  - Add dir to a custom list of mounted directories to sync.  Then\n                the custom list will be synced instead of the default of all\n                mounted directories.  The root directory is always synced.\n                Not for when initializing.\n    -L lbl  - label for ext type partitions.  If 'lbl' ends with '#', replace\n                '#' with a partition number and label all ext partitions.\n                Otherwise, apply label to root partition only.\n    -l      - leave SD card to USB boot alone when cloning to SD card mmcblk0\n                from a USB boot.  This preserves a SD card to USB boot setup\n                by leaving the SD card cmdline.txt using the USB root.\tWhen\n                cloning to USB from SD card this option sets up the SD card\n                cmdline.txt to boot to the USB disk.\n    -a      - Sync all partitions if types compatible, not just mounted ones.\n    -F      - force file system sync or image for some errors. eg:\n                If source used > destination space error, do the sync anyway.\n                If a source partition mount error, skip it and do other syncs.\n    -x      - use set -x for very verbose bash shell script debugging\n    -V      - print rpi-clone version.\n\n  Clone a booted file system to a destination disk which is bootable.\n\n  The destination disk is a SD card (USB card reader) or USB disk 'sdN' plugged\n  into a USB port.  The 'sdN' name should be a full disk name like sda and not\n  a partition name like sda1.  $PGM works on a Raspberry Pi and can work on\n  other systems.  For a destination disk that shows up as sda, run:\n\n    $ sudo rpi-clone sda\n\n  Clones can be from a booted SD card or USB disk.  For a description, example\n  clone runs and example usage of above options, see the README.md at:\n\n      https://github.com/billw2/rpi-clone\n\n  A line logging a $PGM run is written to $clone_log.\n\n  Download:\n    git clone https://github.com/billw2/rpi-clone\n\"\n\texit 1\n\t}\n\nreadable_MiB()\n\t{\n\tval=$1\n\tif [ \"$val\" == \"\" ]\n\tthen\n\t\tresult=\"   ??\"\n\telse\n\t\tblk_size=$2\n\t\tval=$((val / 1024 * blk_size))\n\n\t\tif ((val < 1024 * 1024))\n\t\tthen\n\t\t\tresult=$(echo $val \\\n\t\t\t| awk '{ byte =$1 /1024; printf \"%.1f%s\", byte, \"M\" }')\n\t\telif ((val < 1024 * 1024 * 1024))\n\t\tthen\n\t\t\tresult=$(echo $val \\\n\t\t\t| awk '{ byte =$1 /1024/1024; printf \"%.1f%s\", byte, \"G\" }')\n\t\telse\n\t\t\tresult=$(echo $val \\\n\t\t\t| awk '{ byte =$1 /1024/1024/1024; printf \"%.1f%s\", byte, \"T\" }')\n\t\tfi\n\tfi\n\tprintf -v \"${3}\" \"%s\" \"$result\"\n\t}\n\nreadable_MB()\n\t{\n\tval=$1\n\tif [ \"$val\" == \"\" ]\n\tthen\n\t\tresult=\"   ??\"\n\telse\n\t\tblk_size=$2\n\t\tval=$((val / 1000 * blk_size))\n\n\t\tif ((val < 1000 * 1000))\n\t\tthen\n\t\t\tresult=$(echo $val \\\n\t\t\t| awk '{ byte =$1 /1000; printf \"%.1f%s\", byte, \"MB\" }')\n\t\telif ((val < 1000 * 1000 * 1000))\n\t\tthen\n\t\t\tresult=$(echo $val \\\n\t\t\t| awk '{ byte =$1 /1000/1000; printf \"%.1f%s\", byte, \"GB\" }')\n\t\telse\n\t\t\tresult=$(echo $val \\\n\t\t\t| awk '{ byte =$1 /1000/1000/1000; printf \"%.1f%s\", byte, \"TB\" }')\n\t\tfi\n\tfi\n\tprintf -v \"${3}\" \"%s\" \"$result\"\n\t}\n\nqecho()\n\t{\n    if ((!quiet))\n\tthen\n    \techo \"$@\"\n    fi\n\t}\n\t\nqprintf()\n\t{\n    if ((!quiet))\n\tthen\n    \tprintf \"$@\"\n    fi\n\t}\n\nunmount_or_abort()\n\t{\n\tif [ \"$1\" == \"\" ]\n\tthen\n\t\treturn\n\tfi\n\tqprintf \"\\n  $2\\n  The clone cannot proceed unless it is unmounted.\"\n\n\tif confirm \"Do you want to unmount $1?\" \"abort\"\n\tthen\n\t\tif ! umount $1\n\t\tthen\n\t\t\techo \"$PGM could not unmount $1.\"\n\t\t\techo -e \"Aborting!\\n\"\n\t\t\texit 0\n\t\tfi\n\tfi\n\t}\n\nunmount_list()\n\t{\n\tif [ \"$1\" == \"\" ]\n\tthen\n\t\treturn\n\tfi\n\tfor dir in $1\n\tdo\n\t\tqecho \"  unmounting $dir\"\n\t\tif ! umount $dir\n\t\tthen\n\t\t\tqecho \"  Failed to unmount: $dir\"\n\t\tfi\n\tdone\n\t}\n\nmount_partition()\n\t{\n\tqecho \"  Mounting $1 on $2\"\n\n\tif ! mount $1 $2\n\tthen\n\t\techo \"    Mount failure of $1 on $2.\"\n\t\tif [ \"$3\" != \"\" ]\n\t\tthen\n\t\t\tunmount_list $3\n\t\tfi\n\t\techo \"Aborting!\"\n\t\texit 1\n\tfi\n\t}\n\nrsync_file_system()\n\t{\n\tsrc_dir=\"$1\"\n\tdst_dir=\"$2\"\n\n\tqprintf \"  => rsync $1 $2 $3 ...\"\n\n\tif [ \"$3\" == \"with-root-excludes\" ]\n\tthen\n\t\trsync $rsync_options --delete \\\n\t\t\t$exclude_useropt \\\n\t\t\t$exclude_swapfile \\\n\t\t\t--exclude '.gvfs' \\\n\t\t\t--exclude '/dev/*' \\\n\t\t\t--exclude '/mnt/clone/*' \\\n\t\t\t--exclude '/proc/*' \\\n\t\t\t--exclude '/run/*' \\\n\t\t\t--exclude '/sys/*' \\\n\t\t\t--exclude '/tmp/*' \\\n\t\t\t--exclude 'lost\\+found/*' \\\n\t\t$src_dir \\\n\t\t$dst_dir\n\telse\n\t\trsync $rsync_options --delete \\\n\t\t\t$exclude_useropt \\\n\t\t\t--exclude '.gvfs' \\\n\t\t\t--exclude 'lost\\+found/*' \\\n\t\t$src_dir \\\n\t\t$dst_dir\n\tfi\n\tqecho \"\"\n\t}\n\nprint_partitions()\n\t{\n\tif ((quiet)) && ((!initialize))\n\tthen\n\t\treturn\n\tfi\n\tn_parts=$(( (n_src_parts >= n_dst_parts) ? n_src_parts : n_dst_parts ))\n\n\treadable_MB $src_disk_size \"512\" src_size_readable\n\treadable_MB $dst_disk_size \"512\" dst_size_readable\n\n\tprintf \"\\n%-43s%s\" \"Booted disk: $src_disk $src_size_readable\" \\\n\t\t\t\t\"Destination disk: $dst_disk $dst_size_readable\"\n\techo $\"\n---------------------------------------------------------------------------\"\n\tout=$'Part, Size,FS,Label         ,Part, Size,FS,Label\\n'\n\tfor ((p = 1; p <= n_parts; p++))\n\tdo\n\t\tif ((p <= n_src_parts && src_exists[p]))\n\t\tthen\n\t\t\treadable_MiB ${src_size_sectors[p]} \"512\" tmp\n\t\t\tprintf -v sectors_readable \"%7s\" $tmp\n\t\t\tpname=\"$p ${src_name[p]}\"\n\t\t\tout=${out}$\"$pname,$sectors_readable,${src_fs_type[p]},${src_label[p]},\"\n\t\telse\n\t\t\tout=${out}$\"  ,  ,  ,  ,\"\n\t\tfi\n\n\t\tif ((p <= n_dst_parts && dst_exists[p]))\n\t\tthen\n\t\t\treadable_MiB ${dst_size_sectors[p]} \"512\" tmp\n\t\t\tprintf -v sectors_readable \"%7s\" $tmp\n\t\t\tout=${out}$\"$p,$sectors_readable,${dst_fs_type[p]},${dst_label[p]},\"\n\t\telse\n\t\t\tout=${out}$\"  ,  ,  ,  ,\"\n\t\tfi\n\t\tout=${out}$'\\n'\n\tdone\n\n\techo $\"$out\" | column -t -s ','\n\n\tif ((alt_root_part_num > 0))\n\tthen\n\t\techo $\"\n** Assuming destination root partition for the clone is $dst_part_base$root_part_num\n   The root FS mount is not from booted $src_disk.  It is ${src_root_dev#/dev/}\"\n\n\tfi\n\techo $\"---------------------------------------------------------------------------\"\n\t}\n\nprint_sync_actions()\n\t{\n\tif ((quiet))\n\tthen\n\t\treturn\n\tfi\n\tfor ((p = 1; p <= n_src_parts; p++))\n\tdo\n\t\tif ((!src_exists[p]))\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\t\tif ((p == root_part_num && alt_root_part_num > 0))\n\t\tthen\n\t\t\tpart=${src_root_dev#/dev/}\n\t\t\tflow=\"$part to $dst_part_base$p\"\n\t\telse\n\t\t\tflow=\"to $dst_part_base$p\"\n\t\tfi\n\t\tif ((src_sync_part[p]))\n\t\tthen\n\t\t\tif [ \"${src_mounted_dir[p]}\" != \"\" ]\n\t\t\tthen\n\t\t\t\tsrc_label=\"${src_mounted_dir[p]}\"\n\t\t\t\taction_label=\"SYNC\"\n\t\t\telse\n\t\t\t\tsrc_label=\"/dev/${src_partition[p]}\"\n\t\t\t\taction_label=\"MOUNT SYNC\"\n\t\t\tfi\n\t\t\treadable_MiB ${src_used_sectors[p]} \"512\" used\n\t\t\treadable_MiB ${dst_size_sectors[p]} \"512\" size\n\t\t\tprintf \"%-22s%-14s : %s %s\\n\" \\\n\t\t\t\t\t\"$src_label\" \"(${used} used)\" \"$action_label\" \\\n\t\t\t\t\t\"$flow (${size} size)\"\n\t\tfi\n\tdone\n\t}\n\nprint_image_actions()\n\t{\n\tfor ((p = 1; p <= n_src_parts; p++))\n\tdo\n\t\tif ((!src_exists[p]))\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\t\tpname=\"$p ${src_name[p]}\"\n\t\tfs_type=${src_fs_type[$p]}\n\n\t\tif ((p == root_part_num && alt_root_part_num > 0))\n\t\tthen\n\t\t\tpart=${src_root_dev#/dev/}\n\t\t\tflow=\"$part to $dst_part_base$p\"\n\t\telse\n\t\t\tflow=\"to $dst_part_base$p\"\n\t\tfi\n\n\t\taction=\"\"\n\t\tif ((p <= n_image_parts))\n\t\tthen\n\t\t\tif ((p == 1))\n\t\t\tthen\n\t\t\t\tif ((p1_size_new > 0))\n\t\t\t\tthen\n\t\t\t\t\taction=\"RESIZE  MKFS  SYNC $flow\"\n\t\t\t\telse\n\t\t\t\t\taction=\"MKFS  SYNC $flow\"\n\t\t\t\tfi\n\t\t\telif [ \"$fs_type\" == \"swap\" ]\n\t\t\tthen\n\t\t\t\taction=\"MKSWAP\"\n\t\t\telif ((p != ext_part_num))\n\t\t\tthen\n\t\t\t\tif [ \"${src_mounted_dir[p]}\" != \"\" ] || ((p == n_src_parts))\n\t\t\t\tthen\n\t\t\t\t\tif ((p < n_src_parts || last_part_space || force_sync))\n\t\t\t\t\tthen\n\t\t\t\t\t\taction=\"MKFS  SYNC $flow\"\n\t\t\t\t\telse\n\t\t\t\t\t\taction=\"MKFS  **NO SYNC**\"\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\taction=\"IMAGE $flow\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\tif ((p == n_image_parts))\n\t\tthen\n\t\t\treadable_MiB ${src_used_sectors[n_image_parts]} \"512\" used\n\t\t\tprintf \"%-22s%-14s : RESIZE  %s\\n\" \\\n\t\t\t\t\t\t\"$pname\" \"(${used} used)\" \"$action\"\n\t\telif ((src_used_sectors[$p] > 0 && p < n_image_parts))\n\t\tthen\n\t\t\treadable_MiB ${src_used_sectors[p]} \"512\" used\n\t\t\tprintf \"%-22s%-14s : $action\\n\" \"$pname\" \"(${used} used)\"\n\t\telif [ \"$action\" != \"\" ]\n\t\tthen\n\t\t\tprintf \"%-36s : $action\\n\" \"$pname\"\n\t\tfi\n\tdone\n\t}\n\nprint_options()\n\t{\n\tif ((quiet))\n\tthen\n\t\treturn\n\tfi\n\techo $\"---------------------------------------------------------------------------\"\n\n\tif ((force_sync))\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"-F\" \\\n\t\t\t\t\"forcing clone to skip some errors.\"\n\tfi\n\n\tif ((force_2_parts))\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"-f2\" \\\n\t\t\t\t\"force initialize to first two partitions only.\"\n\tfi\n\n\tif ((p1_size_new > 0))\n\tthen\n\t\tprintf \"%-3s%-19s : %s %s %s\\n\" \"-p \" \"$p1_size_arg\" \\\n\t\t\t\t\"resize /boot to\" \"$p1_size_new\" \"blocks of 512 Bytes.\"\n\tfi\n\n\tif [ \"$edit_fstab_name\" != \"\" ]\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"-e clone fstab edit\" \\\n\t\t\t\t\"edit $src_part_base device entries to $edit_fstab_name.\"\n\tfi\n\n\tif [ \"$ext_label\" != \"\" ]\n\tthen\n\t\trep=\"${ext_label: -1}\"\n\t\tif [ \"$rep\" == \"#\" ]\n\t\tthen\n\t\t\tmsg=\"all ext partition types\"\n\t\telse\n\t\t\tmsg=\"root partition only\"\n\t\tfi\n\t\tprintf \"%-22s : %s\\n\" \"-L $ext_label\" \\\n\t\t\t\t\"volume label for $msg.\"\n\tfi\n\n\tif ((leave_sd_usb_boot))\n\tthen\n\t\tif ((SD_slot_dst))\n\t\tthen\n\t\t\tmsg=\"leave SD card cmdline.txt bootable to USB.\"\n\t\telif ((SD_slot_boot))\n\t\tthen\n\t\t\tmsg=\"install boot to USB cmdline.txt on SD card.\"\n\t\telse\n\t\t\tmsg=\"-l ignored.  Src or dst is not a SD card slot.\"\n\t\tfi\n\t\tprintf \"%-22s : %s\\n\" \"-l SD to USB boot mode\" \"$msg\"\n\tfi\n\n\tif [ \"$setup_args\" != \"\" ]\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"Run setup script\" \"$setup_command $setup_args\"\n\telse\n\t\tprintf \"%-22s : no.\\n\" \"Run setup script\"\n\tfi\n\n\tif ((have_grub))\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"Run grub\" \\\n\t\t\t\"grub-install --root-directory=$clone /dev/$dst_disk\"\n\tfi\n\tprintf \"%-22s : %s.\\n\" \"Verbose mode\" \"$verbose\"\n\tprintf \"%-23s:\\n\" \"-----------------------\"\n\t}\n\next_label()\n\t{\n\tpnum=$1\n\tfs_type=$2\n\tflag=$3\n\tlabel_arg=\"\"\n\n\tif [ \"$ext_label\" != \"\" ] && [[ \"$fs_type\" == *\"ext\"* ]]\n\tthen\n\t\trep=\"${ext_label: -1}\"\n\t\tif [ \"$rep\" == \"#\" ]\n\t\tthen\n\t\t\tlabel_arg=${ext_label:: -1}\n\t\t\tlabel_arg=\"$flag $label_arg$pnum\"\n\t\telif ((pnum == root_part_num))\n\t\tthen\n\t\t\tlabel_arg=\"$flag $ext_label\"\n\t\tfi\n\tfi\n\tprintf -v \"${4}\" \"%s\" \"$label_arg\"\n\t}\n\nget_src_disk()\n\t{\n\tpartition=${1#/dev/}\n\tdisk=${partition:: -1}\n\tnum=\"${partition: -1}\"\n\tif [[ $disk == *\"mmcblk\"* ]]\n\tthen\n\t\tSD_slot_boot=1\n\t\tdisk=${disk:0:7}\n\t\tsrc_part_base=${disk}p\n\tfi\n\tprintf -v \"${2}\" \"%s\" \"$disk\"\n\tprintf -v \"${3}\" \"%s\" \"$num\"\n\t}\n\n\n# ==== source (booted) disk info and default mount list\n#\nsrc_boot_dev=`findmnt /boot -o source -n | grep \"/dev/\"`\nsrc_root_dev=`findmnt / -o source -n | grep \"/dev/\"`\nSD_slot_boot=0\nSD_slot_dst=0\nsrc_part_base=\"\"\n\nboot_part_num=0\nalt_root_part_num=0\n\n\nif [ \"$src_boot_dev\" == \"\" ]\nthen\n\tget_src_disk \"$src_root_dev\" \"src_disk\" \"unused\"\nelse\n\tget_src_disk \"$src_boot_dev\" \"src_disk\" \"boot_part_num\"\nfi\n\nget_src_disk \"$src_root_dev\" \"src_root_disk\" \"root_part_num\"\n\nif [ \"$src_disk\" == \"\" ]\nthen\n\techo \"Cannot find booted device.\"\n\texit 1\nfi\n\nif [ \"$src_part_base\" == \"\" ]\nthen\n\tsrc_part_base=$src_disk\nfi\n\nif [ \"$src_disk\" != \"$src_root_disk\" ]\nthen\n\tif ((SD_slot_boot))\n\tthen\n\t\t# Handle SD card boots with root on different USB disk device.\n\t\t# But will assume SD card has a root partition just above its root.\n\t\t#\n\t\talt_root_part_num=\"$root_part_num\"\n\t\troot_part_num=$((boot_part_num + 1))\n\telse\n\t\techo $\"\nBoot and root are on different disks and it's not a SD card boot.\nDon't know how to partition the destination disk!\"\n\t\texit 1\n\tfi\nfi\n\n# src_root_dev, if on device other than booted, is not in src_partition_table\n# and src_fdisk_table, but is in src_df_table and src_mount_table\n#\nsrc_partition_table=$(parted -m \"/dev/$src_disk\" unit s print | tr -d ';')\nsrc_fdisk_table=$(fdisk -l /dev/$src_disk | grep \"^/dev/\")\n\ntmp=$(df | grep -e \"^/dev/$src_disk\" -e \"^/dev/root\" -e \"$src_root_dev\" \\\n\t\t\t| tr -s \" \")\ndev=${src_root_dev#/dev/}\nsrc_df_table=$(echo \"$tmp\" | sed \"s/root/$dev/\")\n\nn_src_parts=$(echo \"$src_partition_table\" | tail -n 1 | cut -d \":\" -f 1)\nsrc_disk_size=$(echo \"$src_partition_table\" \\\n\t\t\t\t| grep \"^/dev/$src_disk\" | cut -d \":\" -f 2 | tr -d 's')\n\nline=$(fdisk -l /dev/$src_disk | grep \"Disk identifier:\")\nsrc_disk_ID=${line#*x}\n\nsrc_mount_table=$(findmnt -o source,target -n -l \\\n\t\t\t\t| grep -e \"^/dev/$src_disk\" -e \"^$src_root_dev\" | tr -s \" \")\nn_mounts=$(echo \"$src_mount_table\" | wc -l)\n\nif ((alt_root_part_num > 0 && n_src_parts < 2))\nthen\n\techo $\"\nBooted disk has only one partition and the root is from another device.\nDon't know how to partition the destination disk!\n\"\n\texit 1\nfi\n\n\nline=$(echo \"$src_fdisk_table\" | grep \"Extended\")\nif [ \"$line\" != \"\" ]\nthen\n\tdev=$(echo \"$line\" | cut -d \" \" -f 1)\n\text_part_num=\"${dev: -1}\"\nelse\n\text_part_num=0\nfi\n\n\nfor ((p = 1; p <= n_src_parts; p++))\ndo\n\tline=$(echo \"$src_partition_table\" | grep -e \"^${p}:\")\n\tif [ \"$line\" == \"\" ]\n\tthen\n\t\tsrc_exists[p]=0\n\t\tcontinue\n\tfi\n\tsrc_exists[p]=1\n\n\tif ((p == root_part_num))\n\tthen\n\t\tsrc_partition[p]=${src_root_dev#/dev/}\n\t\tsrc_device[p]=$src_root_dev\n\telse\n\t\tsrc_partition[p]=\"${src_part_base}${p}\"\n\t\tsrc_device[p]=\"/dev/${src_partition[p]}\"\n\tfi\n\n\t# parted sectors are 512 bytes\n\tsrc_start_sector[p]=$(echo \"$line\" | cut -d \":\" -f 2 | tr -d 's')\n\tsrc_size_sectors[p]=$(echo \"$line\" | cut -d \":\" -f 4 | tr -d 's')\n\n\tpart_type=$(echo \"$line\" | cut -d \":\" -f 5)\n\n\tsrc_mounted_dir[p]=$(echo \"$src_mount_table\" \\\n\t\t\t\t\t\t| grep -m 1 -e \"^${src_device[p]}\" | cut -d \" \" -f 2)\n\tif [ \"${src_mounted_dir[p]}\" != \"\" ]\n\tthen\n\t\tsrc_sync_part[p]=1\n\telse\n\t\tsrc_sync_part[p]=0\n\tfi\n\n\tsrc_name[p]=\"\"\n\tif [ \"$part_type\" != \"\" ]\n\tthen\n\t\tsrc_fs_type[p]=\"$part_type\"\n\telse\n\t\tsrc_fs_type[p]=\"--\"\n\tfi\n\tsrc_label[p]=\"--\"\n\n\tif [ \"${src_mounted_dir[p]}\" == \"/\" ]\n\tthen\n\t\tsrc_name[p]=\"root\"\n\t#\n\t# If root on device other than booted SD card, root_part_num assumed to be\n\t# booted /boot part_num + 1 and alt_root_part_num  is from root device.\n\t#\n\telif ((p == root_part_num)) && ((alt_root_part_num > 0))\n\tthen\n\t\tsrc_name[p]=\"root**\"\n\telif ((p == ext_part_num))\n\tthen\n\t\tsrc_fs_type[p]=\"EXT\"\n\telif [[ \"$part_type\" == *\"linux-swap\"* ]]\n\tthen\n\t\tsrc_fs_type[p]=\"swap\"\n\telif [ \"${src_mounted_dir[p]}\" != \"\" ]\n\tthen\n\t\tsrc_name[p]=\"${src_mounted_dir[p]}\"\n\tfi\n\n\tif [[ \"$part_type\" == *\"ext\"* ]]\n\tthen\n\t\tlabel=`e2label ${src_device[p]} 2> /dev/null`\n\t\tif [ \"$label\" != \"\" ]\n\t\tthen\n\t\t\tsrc_label[p]=\"$label\"\n\t\tfi\n\tfi\ndone\n\n\n# command line\n#\nsetup_args=\"\"\nedit_fstab_name=\"\"\next_label=\"\"\nverbose=\"no\"\n\nforce_initialize=0\nforce_2_parts=0\nforce_sync=0\nall_sync=0\nusage_error=0\nunattended=0\nUnattended=0\nquiet=0\ncustom_sync=0\nleave_sd_usb_boot=0\nconvert_to_partuuid=0\np1_size_new=0\n\nwhile [ \"$1\" ]\ndo\n\tcase \"$1\" in\n\t\t-v|--verbose)\n\t\t\tverbose=\"yes\"\n\t\t\trsync_options=${rsync_options}v\n\t\t\t;;\n\t\t-u|--unattended)\n\t\t\tunattended=1\n\t\t\t;;\n\t\t-U|--Unattended-init)\n\t\t\tunattended=1\n\t\t\tUnattended=1\n\t\t\t;;\n\t\t-q|--quiet)\n\t\t\tunattended=1\n\t\t\tquiet=1\n\t\t\trsync_options=${rsync_options}q\n\t\t\t;;\n\t\t--exclude=*|--exclude-from=*)\n\t\t\texclude_useropt=\"${exclude_useropt} $1\"\n\t\t\t;;\n\t\t-s|--setup)\n\t\t\tshift\n\t\t\tif ! command -v $setup_command > /dev/null\n\t\t\tthen\n\t\t\t\techo \"Cannot find script $setup_command for setup arg \\\"$1\\\".\"\n\t\t\t\tusage_error=1\n\t\t\tfi\n\t\t\tif [ \"$setup_args\" == \"\" ]\n\t\t\tthen\n\t\t\t\tsetup_args=\"$1\"\n\t\t\telse\n\t\t\t\tsetup_args=\"$setup_args $1\"\n\t\t\tfi\n\t\t\t;;\n\t\t-e|--edit-fstab)\n\t\t\tshift\n\t\t\tedit_fstab_name=$1\n\t\t\t;;\n\t\t-f|--force-initialize)\n\t\t\tforce_initialize=1\n\t\t\t;;\n\t\t-f2)\n\t\t\tforce_initialize=1\n\t\t\tforce_2_parts=1\n\t\t\t;;\n\t\t-p|--p1-size)\n\t\t\tshift\n\t\t\tp1_size_arg=$1\n\t\t\tp1_size_new=$1\n\t\t\tif [[ $p1_size_arg =~ ^[0-9MG]+$ ]]\n\t\t\tthen\n\t\t\t\tif [[ $p1_size_new == *\"M\" ]]\n\t\t\t\tthen\n\t\t\t\t\tsize=$(echo $p1_size_new | cut -d M -f 1)\n\t\t\t\t\tp1_size_new=$(($size * 1024 * 1024 / 512))\n\t\t\t\telif [[ $p1_size_new == *\"G\" ]]\n\t\t\t\tthen\n\t\t\t\t\tsize=$(echo $p1_size_new | cut -d G -f 1)\n\t\t\t\t\tp1_size_new=$(($size * 1024 * 1024 * 1024 / 512))\n\t\t\t\tfi\n\n\t\t\t\tif [[ $p1_size_new =~ ^[0-9]+$ ]]\n\t\t\t\tthen\n\t\t\t\t\tif ((!force_sync && p1_size_new < 200 * 1024))\n\t\t\t\t\tthen\n\t\t\t\t\t\techo \"Setting /boot partition size less than 100 MB seems wrong so will not try.\"\n\t\t\t\t\t\techo \"    Use -F before -p to override.\"\n\t\t\t\t\t\texit 1\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"Confused by -p $p1_size_arg.\"\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"Invalid character in -p size.  Use digits + M or G like: -p 256M\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\t;;\n\t\t-x)\n\t\t\tset -x\n\t\t\t;;\n\t\t-a|--all-sync)\n\t\t\tall_sync=1\n\t\t\t;;\n\t\t-m|--mountdir)\n\t\t\tshift\n\t\t\tmount_ok=0\n\t\t\tfor ((p = 1; p <= n_src_parts; p++))\n\t\t\tdo\n\t\t\t\tif ((!src_exists[p]))\n\t\t\t\tthen\n\t\t\t\t\tcontinue\n\t\t\t\tfi\n\t\t\t\tif ((!custom_sync)) && ((p != root_part_num))\n\t\t\t\tthen\n\t\t\t\t\tsrc_sync_part[p]=0\n\t\t\t\tfi\n\t\t\t\tif [ \"${src_mounted_dir[p]}\" == \"$1\" ]\n\t\t\t\tthen\n\t\t\t\t\tsrc_sync_part[p]=1\n\t\t\t\t\tmount_ok=1\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif ((!mount_ok))\n\t\t\tthen\n\t\t\t\techo \"Asking to clone directory \\\"$1\\\", but it is not mounted.\"\n\t\t\t\tusage_error=1\n\t\t\tfi\n\t\t\tcustom_sync=1\n\t\t\t;;\n\t\t-L|--label_partitions)\n\t\t\tshift\n\t\t\text_label=$1\n\t\t\t;;\n\t\t-l|--leave-sd-usb-boot)\n\t\t\tleave_sd_usb_boot=1\n\t\t\t;;\n\t\t-F|--Force-sync)\n\t\t\tforce_sync=1\n\t\t\t;;\n\t\t--convert-fstab-to-partuuid)\n\t\t\tconvert_to_partuuid=1\n\t\t\t;;\n\t\t-V|--version)\n\t\t\techo $PGM Version: $version\n\t\t\texit 0\n\t\t\t;;\n\t\t-h|--help)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tif [ \"$dst_disk\" != \"\" ]\n\t\t\tthen\n\t\t\t\techo \"Bad arg: $1\"\n\t\t\t\techo \"Run $PGM with -h or no args for usage.\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tdst_disk=$1\n\t\t\tdir=`expr substr $dst_disk 1 5`\n\t\t\tif [ \"$dir\" == \"/dev/\" ]\n\t\t\tthen\n\t\t\t\tdst_disk=${dst_disk#/dev/}\n\t\t\tfi\n\t\t\t;;\n\tesac\n\tshift\ndone\n\nif ((custom_sync)) && ((all_sync))\nthen\n\techo \"-m and -a options at the same time conflict.\"\n\texit 1\nfi\nif ((custom_sync)) && ((force_initialize))\nthen\n\techo \"-m and -f options at the same time conflict.\"\n\texit 1\nfi\nif [[ \"$verbose\" == \"yes\" ]] && ((quiet))\nthen\n\techo \"-q and -v options at the same time conflict.\"\n\texit 1\nfi\n\nif ((usage_error))\nthen\n\techo \"\"\n    exit 1\nfi\n\nif ((convert_to_partuuid))\nthen\n\tunattended=0\n\tUnattended=0\n\n\tfstab=/etc/fstab\n\tfstab_tmp=/tmp/fstab\n\tfstab_save=${fstab}.${PGM}-save\n\tconfirm \"This will change your $fstab, are you sure?\" \"abort\"\n\n\tcp $fstab $fstab_tmp\n\tprintf \"\\nConverting $fstab from device names to PARTUUID\\n\"\n\tcount=0\n\tfor ((p = 1; p <= n_src_parts; p++))\n\tdo\n\t\tif grep -q \"^/dev/${src_partition[p]}\" $fstab_tmp\n\t\tthen\n\t\t\tpartuuid=$(lsblk -n -o PARTUUID /dev/${src_partition[p]})\n\t\t\tsed -i \"s/\\/dev\\/${src_partition[p]}/PARTUUID=$partuuid/\" $fstab_tmp\n\t\t\tprintf \"  Editing $fstab, changing /dev/${src_partition[p]} to $partuuid\\n\"\n\t\t\t((++count))\n\t\tfi\n\tdone\n\tif ((count))\n\tthen\n\t\tcp $fstab $fstab_save\n\t\tcp $fstab_tmp $fstab\n\t\tprintf \"Your original fstab is backed up to $fstab_save\\n\"\n\n\t\tcmdline_txt=/boot/cmdline.txt\n\t\tcmdline_save=$cmdline_txt.${PGM}-save\n\t\tif [ -f $cmdline_txt ] && grep -q \"$src_root_dev\" $cmdline_txt\n\t\tthen\n\t\t\troot_part=${src_partition[root_part_num]}\n\t\t\tpartuuid=$(lsblk -n -o PARTUUID $src_root_dev)\n\t\t\tif [ \"$partuuid\" != \"\" ]\n\t\t\tthen\n\t\t\t\tcp $cmdline_txt $cmdline_save\n\t\t\t\tsed -i \"s/\\/dev\\/$root_part/PARTUUID=$partuuid/\" $cmdline_txt\n\t\t\t\tprintf \"  Editing $cmdline_txt, changing root=$src_root_dev to root=PARTUUID=$partuuid\\n\"\n\t\t\t\tprintf \"Your original cmdline.txt is backed up to $cmdline_save\\n\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\tprintf \"Could not find any $src_disk partition names in $fstab, nothing changed.\\n\"\n\tfi\n\trm $fstab_tmp\n\techo \"\"\n\texit 0\nfi\n\n# dst_mount_flag enumerations:\nlive=1\ntemp=2\nfail=3\n\nfor ((p = 1; p <= n_src_parts; p++))\ndo\n\tif ((!src_exists[p]))\n\tthen\n\t\tcontinue\n\tfi\n\tblocks=0\n\tdst_mount_flag[p]=0\n\n\tif [ \"${src_mounted_dir[p]}\" != \"\" ]\n\tthen\t\t# df blocks are 1024 bytes\n\t\tdst_mount_flag[p]=$live\n\t\tblocks=$(echo \"$src_df_table\" \\\n\t\t\t\t\t| grep -m 1 \"^${src_device[p]}\" | cut -d \" \" -f 3)\n\t# in case intializing, get n_src_parts to compare to dest space\n\telif   ((p == n_src_parts)) \\\n\t    || ((all_sync)) \\\n\t\t&& [ \"${src_fs_type[p]}\" != \"EXT\" ] \\\n\t\t&& [ \"${src_fs_type[p]}\" != \"swap\" ] \\\n\t\t&& [ \"${src_fs_type[p]}\" != \"\" ]\n\tthen\n\t\tif mount ${src_device[p]} $clone\n\t\tthen\n\t\t\tsleep 1\n\t\t\tblocks=$(df | grep \"^${src_device[p]}\" \\\n\t\t\t\t\t\t| tr -s \" \" | cut -d \" \" -f 3)\n\t\t\tumount $clone\n\t\t\tdst_mount_flag[p]=$temp\n\t\t\tif ((all_sync))\n\t\t\tthen\n\t\t\t\tsrc_sync_part[p]=1\n\t\t\tfi\n\t\telse\n\t\t\tdst_mount_flag[p]=$fail\n\t\tfi\n\tfi\n\tsrc_used_sectors[p]=$((blocks * 2))\ndone\n\n# ==== destination disk checks\n#\nif [ \"$dst_disk\" = \"\" ]\nthen\n\techo \"No destination disk given.\"\n\tusage\nfi\n\nchk_disk=`cat /proc/partitions | grep -m 1 $dst_disk`\n\nif [ \"$chk_disk\" == \"\" ]\nthen\n\techo $\"\n  Cannot find '$dst_disk' in the partition table.  The partition table is:\"\n\tcat /proc/partitions\n\texit 1\nfi\n\ndst_part_base=$dst_disk\n\nif [[ ${chk_disk: -1} =~ ^[0-9]$ ]]\nthen\n\tif [[ $dst_disk == *\"mmcblk\"* ]]\n\tthen\n\t\tSD_slot_dst=1\n\t\tdst_part_base=${dst_disk}p\n\t\tif    [ \"$edit_fstab_name\" == \"\" ] \\\n\t\t   && ! grep -q \"^PARTUUID=\" /etc/fstab\n\t\tthen\n\t\t\tedit_fstab_name=$dst_part_base\n\t\t\tassumed_fstab_edit=1\n\t\telse\n\t\t\tassumed_fstab_edit=0\n\t\tfi\n\telse\n\t\tqecho $\"\n  Target disk $dst_disk ends with a digit so may be a partition.\n  $PGM requires disk names like 'sda' and not partition names like 'sda1'.\"\n\n\t\tconfirm \"Continue anyway?\" \"abort\"\n\tfi\nfi\n\nif [ \"$src_disk\" == \"$dst_disk\" ]\nthen\n\techo \"Destination disk $dst_disk is the booted disk.  Cannot clone!\"\n\texit 1\nfi\n\ndst_partition_table=$(parted -m \"/dev/$dst_disk\" unit s print | tr -d ';')\nn_dst_parts=$(echo \"$dst_partition_table\" | tail -n 1 | cut -d \":\" -f 1)\nif [ \"$n_dst_parts\" == \"/dev/$dst_disk\" ]\nthen\n\tn_dst_parts=0\nfi\n\ndst_disk_size=$(echo \"$dst_partition_table\" \\\n\t\t\t\t| grep \"^/dev/$dst_disk\" | cut -d \":\" -f 2 | tr -d 's')\ndst_root_dev=/dev/${dst_part_base}${root_part_num}\n\ndst_mount_table=$(findmnt -o source,target -n -l \\\n\t\t\t\t| grep \"^/dev/$dst_disk\" | tr -s \" \")\n\ndst_fdisk_table=$(fdisk -l /dev/$dst_disk | grep \"^/dev/\")\nline=$(echo \"$dst_fdisk_table\" | grep \"Extended\")\nif [ \"$line\" != \"\" ]\nthen\n\tdev=$(echo \"$line\" | cut -d \" \" -f 1)\n\text_num=\"${dev: -1}\"\nelse\n\text_num=0\nfi\n\nfor ((p = 1; p <= n_dst_parts; p++))\ndo\n\tline=$(echo \"$dst_partition_table\" | grep -e \"^${p}:\")\n\tif [ \"$line\" == \"\" ]\n\tthen\n\t\tdst_exists[p]=0\n\t\tcontinue\n\tfi\n\tdst_exists[p]=1\n\n\tpart=\"${dst_part_base}${p}\"\n\tdst_partition[p]=\"$part\"\n\tdst_device[p]=\"/dev/$part\"\n\n\tdst_start_sector[p]=$(echo \"$line\" | cut -d \":\" -f 2 | tr -d 's')\n\tdst_size_sectors[p]=$(echo \"$line\" | cut -d \":\" -f 4 | tr -d 's')\n\n\tpart_type=$(echo \"$line\" | cut -d \":\" -f 5)\n\tif [ \"$part_type\" != \"\" ]\n\tthen\n\t\tdst_fs_type[p]=\"$part_type\"\n\telse\n\t\tdst_fs_type[p]=\"--\"\n\tfi\n\tdst_label[p]=\"--\"\n\n\tif [[ \"$part_type\" == *\"linux-swap\"* ]]\n\tthen\n\t\tdst_fs_type[p]=\"swap\"\n\telif [[ \"$part_type\" == *\"ext\"* ]]\n\tthen\n\t\tlabel=`e2label ${dst_device[p]} 2> /dev/null`\n\t\tif [ \"$label\" != \"\" ]\n\t\tthen\n\t\t\tdst_label[p]=\"$label\"\n\t\tfi\n\telif ((p == ext_num))\n\tthen\n\t\tdst_fs_type[p]=\"EXT\"\n\tfi\ndone\n\nfs_match=1\nroot_part_match=0\nfirst_part_mismatch=0\n\ninitialize=$((force_initialize))\n\nfor ((p = 1; p <= n_src_parts; p++))\ndo\n\tif ((!src_exists[p]))\n\tthen\n\t\tcontinue\n\tfi\n\tstype=${src_fs_type[p]}\n\tdtype=${dst_fs_type[p]}\n\tif [ \"$stype\" != \"$dtype\" ]\n\tthen\n\t\ttmp_match=0\n\t\tif [[ \"$stype\" == *\"fat\"* ]] && [[ \"$dtype\" == *\"fat\"* ]]\n\t\tthen\n\t\t\ttmp_match=1\n\t\telif [[ \"$stype\" == *\"ext\"* ]] && [[ \"$dtype\" == *\"ext\"* ]]\n\t\tthen\n\t\t\ttmp_match=1\n\t\tfi\n\t\tif ((tmp_match && p == root_part_num))\n\t\tthen\n\t\t\troot_part_match=1\n\t\tfi\n\t\tif ((!tmp_match)) && ((src_sync_part[p]))\n\t\tthen\n\t\t\tfirst_part_mismatch=$p\n\t\t\tfs_match=0\n\t\t\tbreak\n\t\tfi\n\tfi\ndone\n\n\nif ((!fs_match))\nthen\n\tinitialize=1\n\tfs_match_string=\"do not match\"\nelse\n\tfs_match_string=\"OK, they match\"\nfi\n\nif ((initialize)) && ((quiet))\nthen\n\techo \"Quiet mode asked for but an initialize is required - can't clone!\"\n\texit 1\nfi\n\nif ((!initialize && p1_size_new > 0))\nthen\n\techo \"Cannot specify a -p size for partition 1 unless initializing.\"\n\techo \"    Use -f or -f2\"\n\texit 1\nfi\n\nif ((initialize && p1_size_new > 0 && n_image_parts > 2))\nthen\n\techo \"Cannot specify a -p size for partition 1 unless cloning to only 2 partitions.\"\n\techo \"    Use -f2\"\n\texit 1\nfi\n\nif ((!force_sync && p1_size_new > dst_disk_size * 8 / 10))\nthen\n\techo \"-p1 size > 80% of destination disk size seems wrong so will not try.\"\n\techo \"    Use -F to override.\"\n\texit 1\nfi\n\nfor ((p = n_dst_parts; p >= 1; --p))\ndo\n\tif ((!dst_exists[p]))\n\tthen\n\t\tcontinue\n\tfi\n\tdir=$(echo \"$dst_mount_table\" \\\n\t\t\t\t| grep -e \"^${dst_device[p]}\" | cut -d \" \" -f 2)\n\tunmount_or_abort \"$dir\" \\\n\"Destination disk partition ${dst_device[p]} is mounted on $dir.\"\ndone\n\nmounted_dev=$(findmnt $clone -o source -n)\nunmount_or_abort \"$mounted_dev\" \\\n\t\t\t\"Directory $clone is already mounted with $mounted_dev.\"\n\nmounted_dev=$(findmnt $clone_src -o source -n)\nunmount_or_abort \"$mounted_dev\" \\\n\t\t\t\"Directory $clone_src is already mounted with $mounted_dev.\"\n\nmounted_dev=$(findmnt /mnt -o source -n)\nunmount_or_abort \"$mounted_dev\" \"$mounted_dev is currently mounted on /mnt.\"\n\n\nif [ ! -d $clone ]\nthen\n\tmkdir $clone\nfi\nif [ ! -d $clone_src ]\nthen\n\tmkdir $clone_src\nfi\n\n# Do not include a dhpys swapfile in rsync.  It regenerates at boot.\n#\nif [ -f /etc/dphys-swapfile ]\nthen\n\tswapfile=`cat /etc/dphys-swapfile | grep ^CONF_SWAPFILE | cut -f 2 -d=`\n\tif [ \"$swapfile\" = \"\" ]\n\tthen\n\t\tswapfile=/var/swap\n\tfi\n\texclude_swapfile=\"--exclude $swapfile\"\nfi\n\nif ((grub_auto)) && [ -d /boot/grub ] && command -v grub-install\nthen\n\thave_grub=1\nelse\n\thave_grub=0\nfi\n\nprint_partitions\n\nif ((initialize))\nthen\n\tif ((unattended && !Unattended))\n\tthen\n\t\techo $\"\nUnattended -u option not allowed when initializing.\nUse -U for unattended even if initializing.\n\"\n\t\texit 1\n\tfi\n\n\tn_image_parts=$((force_2_parts ? 2 : n_src_parts))\n\n\tif ((force_initialize))\n\tthen\n\t\treason=\"forced by option\"\n\telif ((n_dst_parts < n_image_parts))\n\tthen\n\t\treason=\"partition number mismatch: $n_image_parts -> $n_dst_parts\"\n\telse\n\t\treason=\"FS types conflict\"\n\tfi\n\n\tstart_sector=${src_start_sector[$n_image_parts]}\n\tlast_part_sectors=$((dst_disk_size - start_sector))\n\tlast_part_used=${src_used_sectors[$n_image_parts]}\n\tlast_part_space=$(( (last_part_sectors > last_part_used) ? 1 : 0 ))\n\n\tif ((last_part_sectors < 7812))\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"** FATAL **\" \\\n\t\t\t\t\t\"Initialize needed - $reason\"\n\t\tprintf \"%-22s : %s %s %s\\n\" \"\" \\\n\t\t\t\t\t\"But destination is too small to clone\" \"$n_image_parts\" \"partitions.\"\n\t\treadable_MiB $((start_sector + 7812)) \"512\" min_size\n\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\t\"Minimum destination size required is $min_size.\"\n\t\tif ((n_image_parts > 2))\n\t\tthen\n\t\t\tprintf \"%-22s : %s\\n\" \" \" \\\n\t\t\t\t\t\t\"Possible options:\"\n\t\t\tif ((raspbian))\n\t\t\tthen\n\t\t\t\tprintf \"%-22s : %s\\n\" \" \" \\\n\t\t\t\t\t\t\"    Use -f2 to force a two partition initialize clone.\"\n\t\t\tfi\n\t\t\tprintf \"%-22s : %s\\n\" \" \" \\\n\t\t\t\t\t\t\"    Use -m to limit partitions to clone.\"\n\t\t\tprintf \"%-22s : %s\\n\" \" \" \\\n\t\t\t\t\t\t\"    Manually create custom partitions that can work.\"\n\t\t\tprintf \"%-22s : %s\\n\" \" \" \\\n\t\t\t\t\t\t\"    Larger destination disk..\"\n\t\tfi\n\t\tprintf \"%-23s:\\n\" \"-----------------------\"\n\t\texit 1\n\tfi\n\n\treadable_MiB $((last_part_sectors + 7812)) \"512\" image_space_readable\n\n\techo \"== Initialize: IMAGE partition table - $reason ==\" \n\tprint_image_actions\n\tprint_options\n\n\tprintf \"%-22s : %s\\n\" \"** WARNING **\" \\\n\t\t\t\"All destination disk $dst_disk data will be overwritten!\"\n\n\tif ((raspbian_buster && p1_size_new == 0 && src_size_sectors[1] < 400000))\n\tthen\n\t\tprintf \"%-22s : %s\\n\" \"** WARNING **\" \\\n\t\t\t\"Your source /boot partition is smaller than the\"\n\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\"  Raspbian Buster 256M standard.  Consider using\"\n\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\"  the '-p 256M' option to avoid /boot clone errors.\"\n\tfi\n\n\tabort=0\n\tif ((!last_part_space))\n\tthen\n\t\treadable_MiB $last_part_used \"512\" used_readable\n\t\tprintf \"%-22s : %s\\n\" \"** WARNING **\" \\\n\t\t\t\t\"Destination last partition resize to $image_space_readable\"\n\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\"  is too small to hold source used $used_readable.\"\n\t\tif [ \"$n_image_parts\" == \"$root_part_num\" ] && ((!force_sync))\n\t\tthen\n\t\t\tprintf \"%-22s : %s\\n\" \"** FATAL **\" \\\n\t\t\t\t\t\"This is the root partition, so aborting!\"\n\t\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\t\"  Use -F to override.\"\n\t\t\tabort=1\n\t\telif ((!force_sync))\n\t\tthen\n\t\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\t\"  The partition SYNC is skipped, use -F to override.\"\n\t\telse\n\t\t\tprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\t\"  ** Syncing anyway as you asked with -F. **\"\n\t\tfi\n\tfi\n\tprintf \"%-23s:\\n\" \"-----------------------\"\n\tif ((abort))\n\tthen\n\t\texit 1\n\tfi\n\tconfirm \"Initialize and clone to the destination disk ${dst_disk}?\" \"abort\"\n\n\tif ((!Unattended)) && [ \"$ext_label\" == \"\" ]\n\tthen\n\t\tprintf \"Optional destination ext type file system label (16 chars max): \"\n\t\tread ext_label\n\tfi\n\n\tstart_time=`date '+%H:%M:%S'`\n\tstart_sec=$(date '+%s')\n\n\timage_to_sector=${src_start_sector[1]}\n\tcount=$((image_to_sector / 2 / 1024 + 4))  # in MiB blocks for dd bs=1M\n\n\tprintf \"\\nInitializing\\n\"\n\tprintf \"  Imaging past partition 1 start.\\n\"\n\tsync\n\tprintf \"  => dd if=/dev/$src_disk of=/dev/$dst_disk bs=1M count=$count ...\"\n\tdd if=/dev/$src_disk of=/dev/$dst_disk bs=1M count=$count &> /tmp/$PGM-output\n\tif [ \"$?\" != 0 ]\n\tthen\n\t\tprintf \"\\n  dd failed.  See /tmp/$PGM-output.\\n\"\n\t\tprintf \"  Try running $PGM again.\\n\\n\"\n\t\texit 1\n\tfi\n\techo \"\"\n\tsync\n\tsleep 1\n\tsfd0=$(sfdisk -d /dev/$src_disk)\n\tif ((force_2_parts && (n_src_parts > n_image_parts)))\n\tthen\n\t\tremove_part_start=${src_partition[3]}\n\t\tsfd0=$(echo \"$sfd0\" | sed -e \"/\\/dev\\/$remove_part_start/,\\$d\")\n\tfi\n\n\tpart=\"${src_part_base}$n_image_parts\"\n\tsfd1=$(echo \"$sfd0\" | sed \"\\/dev\\/$part/s/size=[^,]*,//\")\n\n\tif ((ext_part_num > 0 && !force_2_parts))\n\tthen\n\t\tpart=\"${src_part_base}$ext_part_num\"\n\t\tsfd1=$(echo \"$sfd1\" | sed \"\\/dev\\/$part/s/size=[^,]*,//\")\n\tfi\n\n\tif ((p1_size_new > 0))\n\tthen\n\t\tp1_size_orig=$(echo $sfd1 | grep -Po \"size= \\K[^ ,]*\")\n\t\tp2_start_orig=$(echo $sfd1 | grep -Po \"\\/dev\\/${src_part_base}2 : start= \\K[^ ,]*\")\n\t\tp2_start_new=$((p2_start_orig + p1_size_new - p1_size_orig))\n\t\ttmp=$(echo \"$sfd1\" | sed -e \"s/$p2_start_orig/$p2_start_new/\")\n\t\tsfd1=$(echo \"$tmp\" | sed -e \"s/$p1_size_orig/$p1_size_new/\")\n\t\tprintf \"  Resizing both destination disk partitions ...\"\n\telse\n\t\tprintf \"  Resizing destination disk last partition ...\"\n\tfi\n\n\tfor ((x = 0; x < 3; ++x))\n\tdo\n\t\tsleep $((x + 1))\n\t\tsfdisk --force /dev/$dst_disk &> /tmp/$PGM-output <<< \"$sfd1\"\n\t\tif [ \"$?\" == 0 ]\n\t\tthen\n\t\t\tbreak\n\t\tfi\n\t\tif ((x == 2))\n\t\tthen\n\t\t\tprintf \"\\n====$PGM\\n==orig:\\n%s\\n\\n==edited:\\n%s\\n\" \\\n\t\t\t\t\t\"$sfd0\" \"$sfd1\" >> /tmp/$PGM-output\n\t\t\tprintf \"\\n    Resize failed.  See /tmp/$PGM-output.\\n\"\n\t\t\tprintf \"    Try running $PGM again.\\n\\n\"\n\n\t\t\t# Don't let dst disk keep source disk ID.  Can lead to remounts.\n\t\t\tnew_id=$(od -A n -t x -N 4 /dev/urandom | tr -d \" \")\n\t\t\tqprintf \"x\\ni\\n0x$new_id\\nr\\nw\\nq\\n\" | fdisk /dev/$dst_disk > /dev/null\n\t\t\texit 1\n\t\tfi\n\tdone\n\tprintf \"\\n    Resize success.\\n\"\n\tprintf \"  Changing destination Disk ID ...\"\n\tsync\n\tsleep 2\n\n\tnew_id=$(od -A n -t x -N 4 /dev/urandom | tr -d \" \")\n\tqprintf \"x\\ni\\n0x$new_id\\nr\\nw\\nq\\n\" | fdisk /dev/$dst_disk > /dev/null\n\tsync\n\tsleep 2\n\tpartprobe \"/dev/$dst_disk\"\n\tsleep 2\n\techo \"\"\n\n\tfor ((p = n_image_parts + 1; p <= n_src_parts; p++))\n\tdo\n\t\tsrc_sync_part[p]=0\n\tdone\n\n\tfor ((p = 1; p <= n_image_parts; p++))\n\tdo\n\t\tif ((!src_exists[p]))\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\t\tdst_dev=/dev/${dst_part_base}${p}\n\t\tfs_type=${src_fs_type[$p]}\n\t\tif    ((p == ext_part_num)) \\\n\t\t   || [ \"$fs_type\" == \"--\" ]\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\n\t\tif [ \"$fs_type\" == \"fat16\" ]\n\t\tthen\n\t\t\tmkfs_type=\"vfat\"\n\t\telif [ \"$fs_type\" == \"fat32\" ]\n\t\tthen\n\t\t\tmkfs_type=\"vfat -F 32\"\n\t\telse\n\t\t\tmkfs_type=$fs_type\n\t\tfi\n\n\t\tif [ \"${src_mounted_dir[p]}\" == \"/boot\" ] && ((p == 1))\n\t\tthen\n\t\t\text_label $p \"$fs_type\" \"-L\" label\n\t\t\tprintf \"  => mkfs -t $mkfs_type $label $dst_dev ...\"\n\t\t\tyes | mkfs -t $mkfs_type $label $dst_dev &>> /tmp/$PGM-output\n\t\t\techo \"\"\n\t\telse\n\t\t\tif [ \"$fs_type\" == \"swap\" ]\n\t\t\tthen\n\t\t\t\tprintf \"  => mkswap $dst_dev\\n\"\n\t\t\t\tmkswap $dst_dev &>> /tmp/$PGM-log\n\t\t\telif ((p != ext_part_num))\n\t\t\tthen\n\t\t\t\tif [ \"${src_mounted_dir[p]}\" != \"\" ] || ((p == n_image_parts))\n\t\t\t\tthen\n\t\t\t\t\text_label $p $fs_type \"-L\" label\n\t\t\t\t\tprintf \"  => mkfs -t $mkfs_type $label $dst_dev ...\"\n\t\t\t\t\tyes | mkfs -t $mkfs_type $label $dst_dev &>> /tmp/$PGM-output\n\t\t\t\t\techo \"\"\n\t\t\t\t\tif ((p == n_image_parts))\n\t\t\t\t\tthen\n\t\t\t\t\t\tif ((!last_part_space))\n\t\t\t\t\t\tthen\n\t\t\t\t\t\t\tsrc_sync_part[p]=$force_sync\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsrc_sync_part[p]=1\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\t\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\tprintf \"  => dd if=${src_device[$p]} of=$dst_dev bs=1M ...\"\n\t\t\t\t\tdd if=${src_device[$p]} of=$dst_dev bs=1M &>> /tmp/$PGM-output\n\t\t\t\t\tif [ \"$?\" != 0 ]\n\t\t\t\t\tthen\n\t\t\t\t\t\tprintf \"\\n  dd failed.  See /tmp/$PGM-output.\\n\"\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"\"\n\t\t\t\t\tfi\n\t\t\t\t\text_label $p $fs_type \"\" label\n\t\t\t\t\tif [ \"$label\" != \"\" ]\n\t\t\t\t\tthen\n\t\t\t\t\t\techo \"     e2label $dst_dev $label\"\n\t\t\t\t\t\te2label $dst_dev $label\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tdone\n\text_label=\"\"\nelse\n\tqecho \"== SYNC $src_disk file systems to $dst_disk ==\"\n\tprint_sync_actions\n\tprint_options\n\n\tinformed=0\n\tspace_ok=1\n\tall_sync_mount_ok=1\n\tif ((force_sync))\n\tthen\n\t\terr=\"WARNING\"\n\telse\n\t\terr=\"FATAL\"\n\tfi\n\tfor ((p = 1; p <= n_src_parts; p++))\n\tdo\n\t\tif ((!src_exists[p] || !dst_exists[p]))\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\t\tif    ((${dst_size_sectors[p]} < ${src_used_sectors[p]})) \\\n\t\t   && ((src_sync_part[p]))\n\t\tthen\n\t\t\tqprintf \"%-22s : %s\\n\" \"** $err **\" \\\n\t\t\t\"Partition $p: source used > destination space.\"\n\t\t\tspace_ok=$force_sync\n\t\t\tinformed=1\n\t\tfi\n\t\tif ((all_sync && dst_mount_flag[p] == fail))\n\t\tthen\n\t\t\tqprintf \"%-22s : %s\\n\" \"** $err **\" \\\n\t\t\t\"Partition $p: mount failed, cannot sync.\"\n\t\t\tall_sync_mount_ok=$force_sync\n\t\t\tinformed=1\n\t\tfi\n\tdone\n\tif ((informed))\n\tthen\n\t\tqprintf \"%-23s:\" \"-----------------------\"\n\tfi\n\n\tif ((!space_ok || !all_sync_mount_ok))\n\tthen\n\t\tprintf \"\\nAborting!\\n\"\n\t\tif ((!space_ok))\n\t\tthen\n\t\t\tprintf \"  Use -F to override used > space fail or -m to select mounts to clone.\\n\"\n\t\tfi\n\t\tif ((!all_sync_mount_ok))\n\t\tthen\n\t\t\tprintf \"  Use -a -F to sync all except failed mounts.\\n\"\n\t\tfi\n\t\texit 1\n\tfi\n\n\tif ((raspbian_buster && dst_size_sectors[1] < 500000))\n\tthen\n\t\tqprintf \"%-22s : %s\\n\" \"** WARNING **\" \\\n\t\t\t\"Your destination /boot partition is smaller than the\"\n\t\tqprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\"  Raspbian Buster 256M standard. Consider initializing\"\n\t\tif ((n_dst_parts <= 2))\n\t\tthen\n\t\t\tqprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\"  with '-f' or '-f2' along with the '-p 256M' options.\"\n\t\telse\n\t\t\tqprintf \"%-22s : %s\\n\" \"\" \\\n\t\t\t\t\"  destination disk (gparted) with new partition sizes.\"\n\t\tfi\n\t\tqprintf \"%-23s:\\n\" \"-----------------------\"\n\tfi\n\n\tconfirm \"Ok to proceed with the clone?\" \"abort\"\n\tstart_time=`date '+%H:%M:%S'`\n\tstart_sec=$(date '+%s')\nfi\n\nline=$(fdisk -l /dev/$dst_disk | grep \"Disk identifier:\")\ndst_disk_ID=${line#*x}\nif [ \"$dst_disk_ID\" == \"$src_disk_ID\" ]\nthen\n\tqecho \"Destination disk has same Disk ID as source, changing it.\"\n\tnew_id=$(od -A n -t x -N 4 /dev/urandom | tr -d \" \")\n\tqprintf \"x\\ni\\n0x$new_id\\nr\\nw\\nq\\n\" | fdisk /dev/$dst_disk | grep changed\n\tsync\n\tsleep 2\n\tpartprobe \"/dev/$dst_disk\"\n\tsleep 2\n\n\tline=$(fdisk -l /dev/$dst_disk | grep \"Disk identifier:\")\n\tdst_disk_ID=${line#*x}\n\tif [ \"$dst_disk_ID\" == \"$src_disk_ID\" ]\n\tthen\n\t\tqecho \"  Failed to set a new Disk ID.\"\n\tfi\nfi\n\nsync\nqprintf \"\\nSyncing file systems (can take a long time)\\n\"\n\nsync_msg_done=0\nfor ((p = 1; p <= n_src_parts; p++))\ndo\n\tif ((!src_exists[p]))\n\tthen\n\t\tcontinue\n\tfi\n\tif ((src_sync_part[p] && dst_mount_flag[p] == temp))\n\tthen\n\t\tif ((!sync_msg_done))\n\t\tthen\n\t\t\tqprintf \"Syncing unmounted partitions:\\n\"\n\t\tfi\n\t\tsync_msg_done=1\n\t\tdst_dev=/dev/${dst_part_base}${p}\n\t\tfs_type=${src_fs_type[$p]}\n\t\text_label $p $fs_type \"\" label\n\t\tif [ \"$label\" != \"\" ]\n\t\tthen\n\t\t\tqecho \"     e2label $dst_dev $label\"\n\t\t\te2label $dst_dev $label\n\t\tfi\n\n\t\tmount_partition ${src_device[p]} $clone_src \"\"\n\t\tmount_partition $dst_dev $clone \"$clone_src\"\n\t\tunmount_list=\"$clone_src $clone\"\n\t\trsync_file_system \"${clone_src}/\" \"${clone}\" \"\"\n\t\tunmount_list \"$unmount_list\"\n\tfi\ndone\n\nqprintf \"Syncing mounted partitions:\\n\"\n\nfs_type=${src_fs_type[$root_part_num]}\next_label $root_part_num $fs_type \"\" label\nif [ \"$label\" != \"\" ]\nthen\n\tqecho \"     e2label $dst_root_dev $label\"\n\te2label $dst_root_dev $label\nfi\n\nmount_partition $dst_root_dev $clone \"\"\nunmount_list=\"$clone\"\n\nrsync_file_system \"//\" \"$clone\" \"with-root-excludes\"\n\nfor ((p = 1; p <= n_src_parts; p++))\ndo\n\tif ((!src_exists[p]))\n\tthen\n\t\tcontinue\n\tfi\n\tif ((p != root_part_num && src_sync_part[p] && dst_mount_flag[p] == live))\n\tthen\n\t\tdst_dir=$clone${src_mounted_dir[p]}\n\t\tif [ ! -d $dst_dir ]\n\t\tthen\n\t\t\tmkdir -p $dst_dir\n\t\tfi\n\n\t\tdst_dev=/dev/${dst_part_base}${p}\n\t\tfs_type=${src_fs_type[$p]}\n\t\text_label $p $fs_type \"\" label\n\t\tif [ \"$label\" != \"\" ]\n\t\tthen\n\t\t\tqecho \"     e2label $dst_dev $label\"\n\t\t\te2label $dst_dev $label\n\t\tfi\n\n\t\tmount_partition \"$dst_dev\" \"$dst_dir\" \"$unmount_list\"\n\t\trsync_file_system \"${src_mounted_dir[p]}/\" \"${dst_dir}\" \"\"\n\t\tunmount_list=\"$dst_dir $unmount_list\"\n\tfi\ndone\nqecho \"\"\n\n# Fix PARTUUID or device name references in cmdline.txt and fstab\n#\nfstab=${clone}/etc/fstab\ncmdline_txt=${clone}/boot/cmdline.txt\n\nif [ -f $cmdline_txt ]\nthen\n\tif ((leave_sd_usb_boot && SD_slot_dst))\n\tthen\n\t\tqecho \"Leaving SD to USB boot alone.\"\n\t\tcp $cmdline_txt ${clone}/boot/cmdline.boot\n\t\tcmdline_txt=${clone}/boot/cmdline.boot\n\tfi\n\tif grep -q $src_disk_ID $cmdline_txt\n\tthen\n\t\tqecho \"Editing $cmdline_txt PARTUUID to use $dst_disk_ID\"\n\t\tsed -i \"s/${src_disk_ID}/${dst_disk_ID}/\" \"$cmdline_txt\"\n\telif [ \"$edit_fstab_name\" != \"\" ] && grep -q ${src_part_base} $cmdline_txt\n\tthen\n\t\tqecho \"Editing $cmdline_txt references from $src_part_base to $edit_fstab_name\"\n\t\tsed -i \"s/${src_part_base}/$edit_fstab_name/\" \"$cmdline_txt\"\n\tfi\n\tif ((leave_sd_usb_boot && SD_slot_boot))\n\tthen\n\t\tqecho \"Copying USB cmdline.txt to SD card to set up USB boot.\"\n\t\tcp /boot/cmdline.txt /boot/cmdline.boot\n\t\tcp $cmdline_txt /boot/cmdline.txt\n\tfi\nfi\n\nif grep -q $src_disk_ID $fstab\nthen\n\tqecho \"Editing $fstab PARTUUID to use $dst_disk_ID\"\n\tsed -i \"s/${src_disk_ID}/${dst_disk_ID}/g\" \"$fstab\"\nelif [ \"$edit_fstab_name\" != \"\" ] && grep -q ${src_part_base} $fstab\nthen\n\tqecho \"Editing $fstab references from $src_part_base to $edit_fstab_name\"\n\tsed -i \"s/${src_part_base}/${edit_fstab_name}/\" \"$fstab\"\nfi\n\n\nrm -f $clone/etc/udev/rules.d/70-persistent-net.rules\n\ndst_root_vol_name=`e2label $dst_root_dev`\n\nif [ \"$dst_root_vol_name\" = \"\" ]\nthen\n\tdst_root_vol_name=\"no label\"\nfi\n\nif ((have_grub))\nthen\n\tqecho \"grub-install --root-directory=$clone /dev/$dst_disk\"\n\tif ((quiet))\n\tthen\n\t\tgrub-install --root-directory=$clone /dev/$dst_disk &> /dev/null\n\telse\n\t\tgrub-install --root-directory=$clone /dev/$dst_disk\n\tfi\nfi\n\nif [ \"$setup_args\" != \"\" ]\nthen\n\tqprintf \"\\nRunning setup script: $setup_command $setup_args\\n\"\n\t$setup_command $setup_args\nfi\n\ndate=`date '+%F %H:%M'`\necho \"$date  $HOSTNAME $PGM : clone to $dst_disk ($dst_root_vol_name)\" \\\n\t\t>> $clone_log\necho \"$date  $HOSTNAME $PGM : clone to $dst_disk ($dst_root_vol_name)\" \\\n\t\t>> ${clone}${clone_log}\n\n\nstop_sec=$(date '+%s')\nclone_sec=$((stop_sec - start_sec))\n\nstop_time=`date '+%H:%M:%S'`\n\nqecho \"===============================\"\nqecho \"Done with clone to /dev/$dst_disk\"\nqprintf \"   Start - %s    End - %s    Elapsed Time - %d:%02d\\n\" \\\n\t\t\"$start_time\" \"$stop_time\" \"$((clone_sec / 60))\" \"$((clone_sec % 60))\"\n\nif ((!unattended))\nthen\n\techo -n $\"\nCloned partitions are mounted on $clone for inspection or customizing. \n\nHit Enter when ready to unmount the /dev/$dst_disk partitions ...\"\n\n\tread resp\nfi\n\nunmount_list \"$unmount_list\"\nqprintf \"===============================\\n\\n\"\n\nexit 0\n"
        },
        {
          "name": "rpi-clone-setup",
          "type": "blob",
          "size": 2.9013671875,
          "content": "#!/bin/bash\n\n# Usage:  rpi-clone-setup {-t|--test} hostname\n#    eg:  sudo rpi-clone-setup bozo\n#\n# This script is automatically run by rpi-clone (when it is given -s options)\n# to setup an alternate hostname.  A cloned file system mounted on /mnt/clone\n# is expected unless testing with the -t option.\n#\n# Or, this script can be run by hand at the end of a clone when rpi-clone\n# pauses with the cloned file systems still mounted on /mnt/clone.\n#\n# Or, run this script by hand with -t to process files in test directories\n# under /tmp/clone-test.  Run -t and look at the files to see if the files\n# have been edited OK.\n#   eg:  sudo rpi-clone-setup -t bozo\n#\n# This is a starter script that handles only /etc/hosts and /etc/hostname.\n# Make sure the script works correctly for your /etc/hosts file.\n#\n# If adding a customization for another file:\n#    Add the file to file_list.\n#    If needed, add a mkdir -p line to the \"if ((testing))\" part.\n#    Add the scripting necessary to customize the file.\n#    Test new scripting by running:  rpi-clone-setup -t newhostname\n#\n\nfile_list=\"etc/hostname etc/hosts\"\n\nclone=/mnt/clone\nclone_test=/tmp/clone-test\n\nPGM=`basename $0`\n\nif [ `id -u` != 0 ]\nthen\n\techo \"You must be root to run $PGM\"\n\texit 0\nfi\n\nfunction usage\n\t{\n\techo \"Usage: $PGM hostname  {-t|--test}\"\n\techo \"   Eg:  $PGM rpi1\"\n\techo \"   Modify files appropriate to set up for a new host.\"\n\techo \"   Files handled are:\"\n\tfor file in $file_list\n\tdo\n\t\techo \"        $file\"\n\tdone\n\techo \"\"\n\techo \"If testing (-t flag) files are copied and processed to $clone_test\"\n\techo \"\"\n\texit 0\n\t}\n\ntesting=0\nwhile [ \"$1\" ]\ndo\n\tcase \"$1\" in\n\t\t-t|--test)\n\t\t\ttesting=1\n\t\t\t;;\n\t\t*)\n\t\t\tif [ \"$newhost\" != \"\" ]\n\t\t\tthen\n\t\t\t\techo \"Bad args\"\n\t\t\t\tusage\n\t\t\tfi\n\t\t\tnewhost=$1\n\t\t\t;;\n\tesac\n\tshift\ndone\n\nif [ \"$newhost\" = \"\" ]\nthen\n\techo -e \"You must specify a target hostname\\n\"\n\tusage\nfi\n\necho -e \"\\t$newhost\\t- target hostname\"\n\nif ((!testing)) && [ ! -d /mnt/clone/etc ]\nthen\n\techo \"A destination clone file system is not mounted on /mnt/clone\"\n\techo \"Aborting!\"\n\texit 0\nfi\n\nif ((testing))\nthen\n\tcd /tmp\n\trm -rf $clone_test\n\tclone=$clone_test\n\n\tmkdir -p $clone/etc\n\n\techo \"**********************************************\"\n\techo \"Testing setup: copying files to $clone\"\n\tfor file in $file_list\n\tdo\n\t\techo \"    cp /$file $clone/$file\"\n\t\tcp /$file $clone/$file\n\tdone\n\techo \"This test run will modify those files.\"\n\techo \"**********************************************\"\n\techo \"\"\nfi\n\n\n##\n# Set /etc/hostname\n#\ncd $clone/etc\necho $newhost > hostname\n#\n# Read it back to verify.\n#\necho \"$clone/etc/hostname - set new hostname: \"\nLINE=`cat hostname`\necho -e \"$LINE\\n\"\n\n\n##\n# Edit /etc/hosts - edit the sed command if editing fails for your /etc/hosts.\n#\ncd $clone/etc\nsed -i s/\"$HOSTNAME\"/\"$newhost\"/ hosts\n#\n# Read it back to verify.\n#\necho \"$clone/etc/hosts - set new hostname \\\"$newhost\\\" in lines: \"\nLINE=`grep $newhost hosts`\necho -e \"$LINE\\n\"\n\n\n##\n# Add more customizations if needed.\n#\n\n\nexit 0\n\n"
        }
      ]
    }
  ]
}