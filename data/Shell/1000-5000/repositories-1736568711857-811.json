{
  "metadata": {
    "timestamp": 1736568711857,
    "page": 811,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vincentcox/bypass-firewalls-by-DNS-history",
      "stars": 1209,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2017 Vincent Cox\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.8349609375,
          "content": "# Bypass firewalls by abusing DNS history\n![](https://img.shields.io/github/issues/vincentcox/bypass-firewalls-by-DNS-history.svg) ![](https://img.shields.io/github/license/vincentcox/bypass-firewalls-by-DNS-history.svg) ![](https://img.shields.io/badge/Mac%20%26%20Linux-Compatible-green.svg)\n![Tool overview](https://i.imgur.com/RrPqt9w.png)\n\nThis script will try to find:\n- the direct IP address of a server behind a firewall like Cloudflare, Incapsula, SUCURI ...\n- an old server which still running the same (inactive and unmaintained) website, not receiving active traffic because the A DNS record is not pointing towards it. Because it's an outdated and unmaintained website version of the current active one, it is likely vulnerable for various exploits. It might be easier to find SQL injections and access the database of the old website and abuse this information to use on the current and active website.\n\nThis script (ab)uses DNS history records. This script will search for old DNS A records **and** check if the server replies for that domain.\n__It also outputs a confidence level, based on the similarity in HTML response of the possible origin server and the firewall.__\n\nThe script also fetches the IP's of subdomains because my own experience learned me that subdomain IP's sometimes point to the origin of the main domain.\n\n## Usage\nUse the script like this:\n\n`bash bypass-firewalls-by-DNS-history.sh -d example.com`\n\n* `-d --domain`: domain to bypass\n* `-o --outputfile`: output file with IP's\n* `-l --listsubdomains`: list with subdomains for extra coverage\n* `-a --checkall`: Check all subdomains for a WAF bypass\n\n## Requirements (optional)\n`jq` is needed to parse output to gather automatically subdomains.\nInstall with `apt install jq`.\n\n## Background information\n### WAF Bypass explanation\nTo illustrate what we define as WAF bypass, look at the scheme below.\n\n![Scheme WAF Bypass](https://i.imgur.com/arl4zCk.png)\n\nA normal visitor connects to a Website. The initial request is a DNS request to ask the IP of the website, so the browser of the client knows where to send the HTTP request to. For sites behind cloudflare or some other public WAF, the reply contains an IP address of the WAF itself. Your HTTP traffic flows basically through the WAF to the origin web server. The WAF blocks malicious requests and protects against (D)DoS attacks. However, if an attacker knows the IP of the origin webserver **and** the origin webserver accepts HTTP traffic from the entire internet, the attacker can perform a WAF bypass: let the HTTP traffic go directly to the origin webserver instead of passing through the WAF.\n\nThis script tries to find that origin IP, so you can connect directly to the origin webserver. Attacks like SQL injections or SSRF's are not filtered and can be successfully, in contrary when there is a WAF in between which stops these kind of attacks.\n\n### Further exploitation\nWhen you find a bypass, you have two options:\n- Edit your host-file, which is a system-wide solution. You can find your host-file at `/etc/hosts`(Linux/Mac) or `c:\\Windows\\System32\\Drivers\\etc\\hosts` (Windows). Add an entry like this: `80.40.10.22 vincentcox.com`.\n- Burp Suite: ![Burp Suite Settings](https://i.imgur.com/TIyXXP2.png)\n\nFrom this moment, your HTTP traffic goes directly to the origin webserver. You can perform a penetration test as usual, without your requests being blocked by the WAF.\n\n### How to protect against this script?\n- If you use a firewall, make sure to accept only traffic coming through the firewall. Deny all traffic coming directly from the internet. For example: Cloudflare has a [list of IP's](https://www.cloudflare.com/ips/) which you can whitelist with iptables or UFW. Deny all other traffic.\n- Make sure that no old servers are still accepting connections and not accessible in the first place\n\n### For who is this script?\nThis script is handy for:\n- Security auditors\n- Web administrators\n- __Bug bounty hunters__\n- Blackhatters I guess ¯\\\\\\_(ツ)\\_/¯\n\n\n## Web services used in this script\nThe following services are used:\n- [SecurityTrails](https://securitytrails.com)\n- [CrimeFlare](http://crimeflare.org:82/)\n- [certspotter](https://certspotter.com)\n- [DNSDumpster](https://dnsdumpster.com/)\n- [IPinfo](https://ipinfo.io/)\n- [ViewDNS](https://viewdns.info)\n\n## FAQ\n> Why in Bash and not in Python?\n\nIt started out as a few CURL one-liners, became a bash script, extended the code more and more, and the regret of not using Python extended accordingly.\n\n> I find more subdomains with my tools?\n\nI know. I cannot expect everyone to install all these DNS brute-force and enumeration tools. In addition, I don't know beforehand in which folder these tools are placed or under which alias these tools are called. You can still provide your own list with `-l` so you can feed output of these subdomain tools into this tool. Expected input is a full subdomain on each line.\n## Author\n\n<table>\n  <tr>\n    <th><center>Project Creator</center></th>\n  </tr>\n  <tr>\n    <td>\n    <p align=\"center\"><img src=\"https://github.com/vincentcox/StaCoAn/raw/master/resources/authors/vincentcox.jpg\" alt=\"Vincent Cox\" width=\"200px\"/></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <div align=\"center\">\n        <a href=\"https://www.linkedin.com/in/ivincentcox/\">\n          <img src=\"https://cdnjs.cloudflare.com/ajax/libs/foundicons/3.0.0/svgs/fi-social-linkedin.svg\" alt=\"LinkedIn\" width=\"40px\"/>\n        </a>\n        <a href=\"https://twitter.com/vincentcox_be\">\n          <img src=\"https://cdnjs.cloudflare.com/ajax/libs/foundicons/3.0.0/svgs/fi-social-twitter.svg\" alt=\"Twitter\" width=\"40px\"/>\n        </a>\n        <a href=\"https://vincentcox.com\">\n          <img src=\"https://cdnjs.cloudflare.com/ajax/libs/foundicons/3.0.0/svgs/fi-web.svg\" alt=\"Website\" width=\"40px\"/>\n        </a>\n      </div>\n    </td>\n  </tr>\n</table>\n\n## Tags\nWAF bypass<br>\nWeb Application Firewall bypass<br>\nDNS History<br>\nfind direct/origin IP website\n"
        },
        {
          "name": "bypass-firewalls-by-DNS-history.sh",
          "type": "blob",
          "size": 18.62890625,
          "content": "#!/usr/bin/env bash\n################################################################################\n######################## Constants and variables ###############################\n################################################################################\nSCRIPTPATH=\"$( cd \"$(dirname \"$0\")\" ; pwd -P )\"\n# Colors\nGREEN='\\033[1;32m'\nNC='\\033[0m' # No Color\nRED='\\033[1;31m'\nYELLOW='\\033[0;33m'\n# Input variables\ncheckall=0\nPOSITIONAL=()\nwhile [[ $# -gt 0 ]]\ndo\nkey=\"$1\"\ncase $key in\n    -d|--domain)\n    domain=\"$2\"\n    shift # past argument\n    shift # past value\n    ;;\n    -o|--outputfile)\n    outfile=\"$2\"\n    shift # past argument\n    shift # past value\n    ;;\n    -l|--listsubdomains)\n    listsubdomains=\"$2\"\n    shift # past argument\n    shift # past value\n    ;;\n    -a|--checkall)\n    checkall=1\n    shift # past argument\n    ;;\n    *)    # unknown option\n    POSITIONAL+=(\"$1\") # save it in an array for later\n    shift # past argument\n    ;;\nesac\ndone\nset -- \"${POSITIONAL[@]}\" # restore positional parameters\n\n################################################################################\n######################## Show Script Information ###############################\n################################################################################\nif [ -z \"$domain\" ] ; then\n\t  echo 'usage: ./bypass-firewalls-by-DNS-history.sh -d example.com'\n    echo '-d --domain: domain to bypass'\n    echo \"-o --outputfile: output file with IP's only\"\n    echo '-l --listsubdomains: list with subdomains for extra coverage'\n    echo '-a --checkall: Check all subdomains for a WAF bypass'\n    exit 0\nfi\n################################################################################\n######################## Various ###############################################\n################################################################################\n\n# Check if jq is installed\njq --help >/dev/null 2>&1 || { echo >&2 \"'jq' is needed for extra subdomain lookups, but it's not installed. Consider installing it for better results (eg.: 'apt install jq'). Aborting.\"; exit 1; }\n\n# Cleanup temp files when program was interrupted.\nrm /tmp/waf-bypass-*$domain* &> /dev/null\n\n# Add extra Subdomains\nif [ -n \"$listsubdomains\" ] ; then\n  cat $listsubdomains > /tmp/waf-bypass-alldomains-$domain.txt\nfi\n\n################################################################################\n######################## Show Logo  ############################################\n################################################################################\n\ncat << \"EOF\"\n-------------------------------------------------------------\n __          __     ______   _\n \\ \\        / /\\   |  ____| | |\n  \\ \\  /\\  / /  \\  | |__    | |__  _   _ _ __   __ _ ___ ___\n   \\ \\/  \\/ / /\\ \\ |  __|   | '_ \\| | | | '_ \\ / _` / __/ __|\n    \\  /\\  / ____ \\| |      | |_) | |_| | |_) | (_| \\__ \\__ \\\n     \\/  \\/_/    \\_\\_|      |_.__/ \\__, | .__/ \\__,_|___/___/\n                                    __/ | |\n                                   |___/|_|\nVia DNS history. ( @vincentcox_be | vincentcox.com )\n-------------------------------------------------------------\nEOF\n\n################################################################################\n######################## Matchmaking function ##################################\n################################################################################\n# Purpose: Sometimes old IP's become different people's server. For example a\n# company uses a Digitalocean VPS and after one year they switched to amazon\n# so they remove their VPS instance. The IP is then released and then used by\n# some dude's server for a hobby project. To verify if we got a hit, we need\n# to inspect the HTML and compare it from the WAF and the direct IP and Calculate\n# a match percentage. This is exactly what we are going to do here.\n# This script is called later on in the script.\n\n## Most sites redirect HTTP to HTTPS, so the response body of http will be empty, causing false positives to appear.\n{\nif (curl --silent -v http://$domain 2>&1|tr '\\n' ' '| grep -e \"Moved Permanently.*https://$domain\"); then\n  cp \"/tmp/waf-bypass-https-$domain\" \"/tmp/waf-bypass-http-$domain\"\nfi\n} &> /dev/null # hide verbose output curl, somehow --silent is not enough when verbose is on.\n\n## This function is called to do the actual comparing\nfunction matchmaking {\nfile1=$1\nfile2=$2\nip=$3\nmatchmaking=$4\ndomain=$5\nprotocol=$6\n## Get the original content of the website to compare this to during the matchmaking\ncurl --silent -o \"/tmp/waf-bypass-https-$domain\" \"https://$domain\"\ncurl --silent -o \"/tmp/waf-bypass-http-$domain\" \"http://$domain\"\ntouch $file1\ntouch $file2\nthread=$!\nsizefile1=$(cat $file1 | wc -l )\nsizefile2=$(cat $file2 | wc -l )\nbiggestsize=$(( $sizefile1 > $sizefile2 ? $sizefile1 : $sizefile2 ))\nif [[ $biggestsize -ne 0  ]]; then\n  difference=$(( $(sdiff -B -b -s $file1 $file2 | wc -l) ))\n  confidence_percentage=$(( 100 * (( $biggestsize - ${difference#-} )) / $biggestsize ))\n  if [[ $confidence_percentage -gt 0 ]]; then\n    echo \"$ip\" >> \"$outfile\"\n    if [[ $checkall -le 0 ]];then\n      echo -e \"$protocol://$ip | $confidence_percentage % | $(curl --silent https://ipinfo.io/$ip/org )\" >>  /tmp/waf-bypass-output-$domain.txt\n    else\n      echo -e \"$protocol://$domain | $ip | $confidence_percentage % | $(curl --silent https://ipinfo.io/$ip/org )\" >>  /tmp/waf-bypass-output-$domain.txt\n    fi\n  fi\n\n  # ---- Debugging Info ----\n  echo \"$file1 $file2\" >> /tmp/waf-bypass-thread-$thread.txt\n  echo \"#Lines $file1: $sizefile1\" >> /tmp/waf-bypass-thread-$thread.txt\n  echo \"#Lines $file2: $sizefile2\" >> /tmp/waf-bypass-thread-$thread.txt\n  echo \"Different lines: $difference\" >> /tmp/waf-bypass-thread-$thread.txt\n  echo -e \"$ip | $confidence_percentage %\" >> /tmp/waf-bypass-thread-$thread.txt\n  echo \"----\" >> /tmp/waf-bypass-thread-$thread.txt\n  # if [ \"$confidence_percentage\" -gt 0 ]; then\n  # cat /tmp/waf-bypass-thread-$thread.txt\n  # fi\n\n  # Uncomment the following line to output the debugging info.\n  # cat /tmp/waf-bypass-thread-$thread.txt\n  # ++++ Debugging Info ++++\n  rm /tmp/waf-bypass-thread-$thread.txt\nfi\n}\n\n################################################################################\n######################## IP Validation #########################################\n################################################################################\n# Purpose: we need to check if the IP we find is not just the current IP and not\n# a public WAF service.\n# If no output file is specified\nif [ -z \"$outfile\" ]; then\n  outfile=/tmp/waf-bypass-$domain-log.txt # Get's removed anyway at the end of script.\nfi\nif [ -f \"$outfile\" ]; then\n  rm \"$outfile\"\nfi\n\n# Exclude Public Known WAF IP's\nPUBLICWAFS='103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 104.16.0.0/12 108.162.192.0/18 131.0.72.0/22 141.101.64.0/18 162.158.0.0/15 172.64.0.0/13 173.245.48.0/20 188.114.96.0/20 190.93.240.0/20 197.234.240.0/22 198.41.128.0/17 199.83.128.0/21 198.143.32.0/19 149.126.72.0/21 103.28.248.0/22 45.64.64.0/22 185.11.124.0/22 192.230.64.0/18 107.154.0.0/16 45.60.0.0/16 45.223.0.0/16'\nfunction in_subnet {\n    # Determine whether IP address is in the specified subnet.\n    #\n    # Args:\n    #   sub: Subnet, in CIDR notation.\n    #   ip: IP address to check.\n    #\n    # Returns:\n    #   1|0\n    #\n    local ip ip_a mask netmask sub sub_ip rval start end\n\n    # Define bitmask.\n    local readonly BITMASK=0xFFFFFFFF\n\n    # Read arguments.\n    IFS=/ read sub mask <<< \"${1}\"\n    IFS=. read -a sub_ip <<< \"${sub}\"\n    IFS=. read -a ip_a <<< \"${2}\"\n\n    # Calculate netmask.\n    netmask=$(($BITMASK<<$((32-$mask)) & $BITMASK))\n\n    # Determine address range.\n    start=0\n    for o in \"${sub_ip[@]}\"\n    do\n        start=$(($start<<8 | $o))\n    done\n\n    start=$(($start & $netmask))\n    end=$(($start | ~$netmask & $BITMASK))\n\n    # Convert IP address to 32-bit number.\n    ip=0\n    for o in \"${ip_a[@]}\"\n    do\n        ip=$(($ip<<8 | $o))\n    done\n\n    # Determine if IP in range.\n    (( $ip >= $start )) && (( $ip <= $end )) && rval=1 || rval=0\n    echo \"${rval}\"\n}\n\nfunction ip_is_waf {\nIP=$1\nfor subnet in $PUBLICWAFS\ndo\n    (( $(in_subnet $subnet $IP) )) &&\n        echo 1 && break\ndone\n}\n\n################################################################################\n################### Get Top Domain when sub is given  ##########################\n################################################################################\nfunction get_top_domain {\n  domain=$1\n  top_domain=$(curl -s \"http://tldextract.appspot.com/api/extract?url=$domain\" | jq ' .domain, .tld' | tr -d '\"' |tr '\\r\\n' '.' | rev | cut -c2- | rev)\n  if [ \"$domain\" != \"$top_domain\" ]; then\n      echo $top_domain\n  fi\n}\n\n################################################################################\n######################## Subdomain Gathering  ##################################\n################################################################################\n# Purpose: Subdomains can point to origin IP's behind the firewall (WAF).\n\n# Function to get subdomains from DNSDumpster\nfunction dnsdumpster_subdomains {\ndomain=$1\ncurl https://dnsdumpster.com -o /dev/null -c /tmp/dnsdumpster-$domain-cookies.txt -s\nCSRF=\"$(grep csrftoken /tmp/dnsdumpster-$domain-cookies.txt | cut -f 7)\"\ncurl -s -X 'POST' -H 'Host: dnsdumpster.com' -H 'Pragma: no-cache' -H 'Cache-Control: no-cache' -H 'Upgrade-Insecure-Requests: 1' -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' -H 'Origin: https://dnsdumpster.com' -H 'Content-Type: application/x-www-form-urlencoded' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8' -H 'Referer: https://dnsdumpster.com/' -H 'Accept-Language: en-US,en;q=0.9,nl;q=0.8' -H \"Cookie: csrftoken=$CSRF\" -b \"csrftoken=$CSRF\" --data-binary \"csrfmiddlewaretoken=$CSRF&targetip=$domain\" -o /tmp/dnsdumpster-$domain-output.txt 'https://dnsdumpster.com/'\nregex='\\w*\\.'$domain\ncat /tmp/dnsdumpster-$domain-output.txt | grep -oh \"$regex\" | sort -u\nrm /tmp/dnsdumpster-$domain-output.txt\nrm /tmp/dnsdumpster-$domain-cookies.txt\n}\n\n# DNSDumpster (call function)\necho \"$(dnsdumpster_subdomains $domain)\" >> /tmp/waf-bypass-alldomains-$domain.txt\n# Certspotter\ncurl -s https://certspotter.com/api/v0/certs?domain=$domain | jq -c '.[].dns_names' | grep -o '\"[^\"]\\+\"' | grep \"$domain\" | sed 's/\"//g' >> /tmp/waf-bypass-alldomains-$domain.txt\n# Virustotal\ncurl -H 'user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36' -s https://www.virustotal.com/ui/domains/$domain/subdomains\\?limit\\= | jq '.data[].id' | grep -o '\"[^\"]\\+\"' | grep \"$domain\" | sed 's/\"//g' >> /tmp/waf-bypass-alldomains-$domain.txt\n# Add own domain\necho \"$domain\" >> /tmp/waf-bypass-alldomains-$domain.txt\n# Add main (top level) domain if subdomain is inputted domain\necho \"$(get_top_domain $domain)\" >> /tmp/waf-bypass-alldomains-$domain.txt\n# Filter unique ones + remove wildcards\ncat  /tmp/waf-bypass-alldomains-$domain.txt | sort -u | grep -v -E '\\*' >  /tmp/waf-bypass-domains-filtered-$domain.txt\n# Read file to array. Readarray doesn't work on OS X, so we use the traditional way.\nwhile IFS=\\= read var; do\n    domainlist+=($var)\ndone < /tmp/waf-bypass-domains-filtered-$domain.txt\n\n# ---- Debugging Info ----\n# echo \"Using the IP's of the following (sub)domains for max coverage:\"\n# echo $(echo ${domainlist[*]})\n# ++++ Debugging Info ++++\n\necho -e \"${YELLOW}[-] $(echo ${#domainlist[@]}) Domains collected...${NC}\"\n\n################################################################################\n######################## Get IP's from subdomains  #############################\n################################################################################\n\nprogresscounter=0\nfor domainitem in \"${domainlist[@]}\"\ndo\n   progresscounter=$(($progresscounter+1))\n   echo -ne \"${YELLOW}[-] Scraping IP's from (sub)domains ($((100*$progresscounter/${#domainlist[@]}))%)${NC}\\r\"\n   domainitem=$( echo $domainitem | tr -d '\\n')\n   ### Source: viewdns.info\n   list_ips=$list_ips\" \"$( curl --max-time 10 -s -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' -H 'content-type: application/json;charset=UTF-8' -H 'accept: application/json, text/plain, */*' https://viewdns.info/iphistory/?domain=$domainitem | grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}' | sort -u)\n   ### Source: SecurityTrials\n   list_ips=$list_ips\" \"$( curl --max-time 10 -s \"https://securitytrails.com/domain/$domainitem/history/a\" | grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}' )\n   ### Source: Security Trials API (alternative)\n   list_ips=$list_ips\" \"$(curl -s \"https://securitytrails.com/app/api/v1/history/$domainitem/dns/a?page=0\" -H 'pragma: no-cache' -H 'origin: https://securitytrails.com' -H 'accept-encoding: gzip, deflate, br' -H 'accept-language: en-US,en;q=0.9,nl;q=0.8' -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' -H 'content-type: application/json;charset=UTF-8' -H 'accept: application/json, text/plain, */*' -H 'cache-control: no-cache' -H 'authority: securitytrails.com' -H \"referer: https://securitytrails.com/domain/$domainitem/history/a\" --data-binary '{\"captcha\":null,\"_csrf_token\":\"\"}' --compressed | grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}')\n   ### Source: http://crimeflare.com/\n   list_ips=$list_ips\" \"$( curl --max-time 15 -s 'http://www.crimeflare.com:82/cgi-bin/cfsearch.cgi' -H 'Connection: keep-alive' -H 'Pragma: no-cache' -H 'Cache-Control: no-cache' -H 'Origin: http://www.crimeflare.com:82' -H 'Upgrade-Insecure-Requests: 1' -H 'DNT: 1' -H 'Content-Type: application/x-www-form-urlencoded' -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8' -H 'Referer: http://www.crimeflare.com:82/cfs.html' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q=0.9,nl;q=0.8' --data \"cfS=$domainitem\" --compressed  | grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}' )\ndone\necho \"\" # Fix new line issue\nlist_ips=$(echo $list_ips | tr \" \" \"\\n\" | sort -u )\necho -e \"${YELLOW}[-] $( echo $list_ips | tr \" \" \"\\n\" | wc -l | tr -d '[:space:]') IP's gathered from DNS history...${NC}\"\n# ---- Debugging Info ----\n# echo -e \"${YELLOW}[!] IP's: $(echo ${list_ips[*]}) ${NC}\"\n# ++++ Debugging Info ++++\n################################################################################\n######################## Bypass Test ###########################################\n################################################################################\n# For each IP test the bypass and calculate the match %\necho -e \"${YELLOW}[-] Launching requests to origin servers...${NC}\"\nif [[ $checkall -eq 0 ]];then\n  for ip in $list_ips;do\n    if [[ $(ip_is_waf $ip) -eq 0 ]];then\n      # Remove current IP's via nslookup\n      currentips=$(nslookup $domain | grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}')\n      protocol=\"https\"\n      (if (curl --fail --max-time 10 --silent -k \"$protocol://$domain\" --resolve \"$domain:443:$ip\" | grep \"html\" | grep -q -v \"was rejected\" );then if [[ $currentips != *\"$ip\"* ]];then curl --silent -o \"/tmp/waf-bypass-$protocol-$ip-$domain\" -k -H \"Host: $domain\" \"$protocol\"://\"$ip\"/ ; matchmaking \"/tmp/waf-bypass-$protocol-$domain\" \"/tmp/waf-bypass-$protocol-$ip-$domain\" \"$ip\" \"$checkall\" \"$domain\" \"$protocol\";wait; fi; fi) & pid=$!;\n      PID_LIST+=\" $pid\";\n      protocol=\"http\"\n      (if (curl --fail --max-time 10 --silent -k \"$protocol://$domain\" --resolve \"$domain:80:$ip\" | grep \"html\" | grep -q -v \"was rejected\" );then if [[ $currentips != *\"$ip\"* ]];then curl --silent -o \"/tmp/waf-bypass-$protocol-$ip-$domain\" -k -H \"Host: $domain\" \"$protocol\"://\"$ip\"/ ; matchmaking \"/tmp/waf-bypass-$protocol-$domain\" \"/tmp/waf-bypass-$protocol-$ip-$domain\" \"$ip\" \"$checkall\" \"$domain\" \"$protocol\";wait; fi; fi) & pid=$!;\n      PID_LIST+=\" $pid\";\n    fi\n  done\nelse\nfor domainitem in \"${domainlist[@]}\";do\n  tempstorage=$domain\n  domain=$domainitem\n  for ip in $list_ips;do\n    if [[ $(ip_is_waf $ip) -eq 0 ]];then\n      # Remove current IP's via nslookup\n      currentips=$(nslookup $domain | grep -o '[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}\\.[0-9]\\{1,3\\}')\n      protocol=\"https\"\n      (if (curl --fail --max-time 10 --silent -k \"$protocol://$domain\" --resolve \"$domain:443:$ip\" | grep \"html\" | grep -q -v \"was rejected\" );then if [[ $currentips != *\"$ip\"* ]];then curl --silent -o \"/tmp/waf-bypass-$protocol-$ip-$domain\" -k -H \"Host: $domain\" \"$protocol\"://\"$ip\"/ ; matchmaking \"/tmp/waf-bypass-$protocol-$domain\" \"/tmp/waf-bypass-$protocol-$ip-$domain\" \"$ip\" \"$checkall\" \"$domain\" \"$protocol\";wait; fi; fi) & pid=$!;\n      PID_LIST+=\" $pid\";\n      protocol=\"http\"\n      (if (curl --fail --max-time 10 --silent -k \"$protocol://$domain\" --resolve \"$domain:80:$ip\" | grep \"html\" | grep -q -v \"was rejected\" );then if [[ $currentips != *\"$ip\"* ]];then curl --silent -o \"/tmp/waf-bypass-$protocol-$ip-$domain\" -k -H \"Host: $domain\" \"$protocol\"://\"$ip\"/ ; matchmaking \"/tmp/waf-bypass-$protocol-$domain\" \"/tmp/waf-bypass-$protocol-$ip-$domain\" \"$ip\" \"$checkall\" \"$domain\" \"$protocol\";wait; fi; fi) & pid=$!;\n      PID_LIST+=\" $pid\";\n    fi\n  done\n  domain=$tempstorage\ndone\nfi\necho -e \"${YELLOW}[-] Waiting on replies from origin servers...${NC}\"\ntrap \"kill $PID_LIST\" SIGINT\nwait $PID_LIST\nif [ ! -f \"$outfile\" ]; then\n  echo -e \"${RED}[-] No Bypass found!${NC}\"\nelse\n  echo -e \"${GREEN}[+] Bypass found!${NC}\"\n\tsort -u -o \"$outfile-tmp\" \"$outfile\"\n  mv \"$outfile-tmp\" \"$outfile\"\n  if [[ $checkall -eq 0 ]];then\n    echo -e \"[IP] | [Confidence] | [Organisation]\" >>  /tmp/waf-bypass-output-$domain-2.txt\n  else\n    echo -e \"[Domain] | [IP] | [Confidence] | [Organisation]\" >>  /tmp/waf-bypass-output-$domain-2.txt\n  fi\n  cat /tmp/waf-bypass-output-$domain.txt | sort -ur >> /tmp/waf-bypass-output-$domain-2.txt\n  cat /tmp/waf-bypass-output-$domain-2.txt > /tmp/waf-bypass-output-$domain.txt\nfi\n\n################################################################################\n######################## Presenting output + cleanup ###########################\n################################################################################\n\n# When checkall is enabled, merge all results to main file\nfor domainitem in \"${domainlist[@]}\"\ndo\n  if [ \"$domainitem\" != \"$domain\" ];then\n    touch \"/tmp/waf-bypass-output-$domainitem.txt\"\n    cat \"/tmp/waf-bypass-output-$domainitem.txt\" >> \"/tmp/waf-bypass-output-$domain.txt\"\n  fi\ndone\n\ntouch /tmp/waf-bypass-output-$domain.txt # If no IP's were found, the script will be empty.\ncat \"/tmp/waf-bypass-output-$domain.txt\" | column -s\"|\" -t\n\n# Cleanup temp files\nrm /tmp/waf-bypass-*$domain*\n"
        }
      ]
    }
  ]
}