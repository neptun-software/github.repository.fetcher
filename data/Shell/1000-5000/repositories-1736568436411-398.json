{
  "metadata": {
    "timestamp": 1736568436411,
    "page": 398,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Hexxeh/rpi-update",
      "stars": 1942,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0341796875,
          "content": "Copyright (C) 2013 Liam McLoughlin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.859375,
          "content": "# This repo is now deprecated\n\nDevelopment is continuing at https://github.com/raspberrypi/rpi-update\nThe rpi-update script will switch automatically to the new repo.\n\n# rpi-update\n\nA tool to get the latest bleeding-edge firmware and kernel for your Raspberry Pi.\n\n# Notes\n\nThis is only intended for use with Raspberry Pi OS. If you are using a different\ndistribution then check with the maintainers if using rpi-update is safe.\n\nIf the distribution ships a custom kernel (e.g. BerryBoot), then it almost certainly is not\nsafe. Also differences in the usage of /boot and /opt/vc directories will\nlikely make it unsafe.\n\nEven on Raspberry Pi OS you should only use this with a good reason.\n\nThis gets you the latest bleeding edge kernel/firmware.\nThere is always the possibility of regressions.\n\nBug fixes and improvements will eventually make their way into new Raspberry Pi OS\nreleases and apt-get when they are considered sufficiently well tested.\n\nA good reason for using this would be if you like to help with the testing effort,\nand are happy to risk breakages and submit bug reports. These testers are welcome.\n\nAlso if you are suffering from a bug in current firmware (perhaps as one of\nthe reporters of the bug on github or forum) and a fix has been pushed out for\ntesting, then using rpi-update is the right way to get the fix until it makes\nits way into new Raspberry Pi OS images and apt-get.\n\nBacking up before updating is always advisable.\n\n## Installing\n\n### Installing under Raspberry Pi OS\n \nTo install the tool, run the following command:\n\n    sudo apt-get install rpi-update\n\n### Installing under other OSes\n\nTo install the tool, run the following command:\n\n    sudo curl -L --output /usr/bin/rpi-update https://raw.githubusercontent.com/Hexxeh/rpi-update/master/rpi-update && sudo chmod +x /usr/bin/rpi-update\n\n## Updating\n\nThen, to update your firmware, just run the following command:\n\n    sudo rpi-update\n\n## Activating\n\nAfter the firmware has been sucessfully updated, you'll need to reboot to load\nthe new firmware.\n\n## Options\n\nIf you'd like to set a different GPU/ARM memory split, then define `gpu_mem` in\n`/boot/config.txt`.\n\nTo upgrade/downgrade to a specific firmware revision, specify its Git hash\n(from the https://github.com/Hexxeh/rpi-firmware repository) as follows:\n\n    sudo rpi-update fab7796df0cf29f9563b507a59ce5b17d93e0390\n\n### Expert options\n\nThere are a number of options for experts you might like to use.  These are all\nenvironment variables you must set if you wish to use them.\n\n#### `UPDATE_SELF`\n\nBy default, `rpi-update` will attempt to update itself each time it is run.\nYou can disable this behavior by:\n\n    sudo UPDATE_SELF=0 rpi-update\n\n#### `SKIP_KERNEL`\n\n    sudo SKIP_KERNEL=1 rpi-update\n\nWill update everything **except** the `kernel.img` files and the kernel modules.\nUse with caution, some firmware updates might depend on a kernel update.\n\n#### `SKIP_BACKUP`\n\n    sudo SKIP_BACKUP=1 rpi-update\n\nAvoids making backup of /boot and /lib/modules on first run.\n\n#### `SKIP_REPODELETE`\n\n    sudo SKIP_REPODELETE=1 rpi-update\n\nBy default the downloaded files (/root/.rpi-firmware) are deleted at end of update.\nUse this option to keep the files.\n\n#### `SKIP_VCLIBS`\n\n    sudo SKIP_VCLIBS=1 rpi-update\n\nWill update everything **except** the VideoCore libraries.\nUse this option to keep the existing VideoCore libraries if you do not want your\nlocal versions overwritten.\n\n#### `ROOT_PATH` and `BOOT_PATH`\n\n    sudo ROOT_PATH=/media/root BOOT_PATH=/media/boot rpi-update\n\nAllows you to perform an \"offline\" update, ie update firmware on an SD card you\nare not currently booted from. Useful for installing firmware/kernel to a\nnon-RPI customised image. Be careful, you must specify both options or neither.\nSpecifying only one will not work.\n\n#### `FW_SUBDIR`\n\n    sudo FW_SUBDIR=safe rpi-update\n\nAllows the firmware to be installed to a subdirectory of /boot. This feature is\nintended to support the `os_prefix` setting that can be used in `config.txt`.\nBy default, FW_SUBDIR is initialised to the value of `os_prefix` in effect when\nthe device was booted, so as to overwrite the \"running\" firmware. To explicitly\ninstall with no subdirectory (to install into /boot), use `FW_SUBDIR=/`.\n\n#### `BRANCH`\n\nBy default, clones the firmware files from the master branch, else uses the files\nfrom the specified branch, eg:\n\n    sudo BRANCH=next rpi-update\n\nwill use the 'next' branch.\n\n#### `PRUNE_MODULES`\n\nAllows you to delete unused module directories when doing an update. Set it equal to a non-zero value and it will remove all modules except the latest installed:\n\n    sudo PRUNE_MODULES=1 rpi-update\n\nwill remove previously installed module files. Use this option to free disk space used by older module updates.\n\n#### `JUST_CHECK`\n\nTo just get a list of commits contained in rpi-update since you last updated, run:\n\n    sudo JUST_CHECK=1 rpi-update\n\nThis won't update your firmware\n\n#### `GITHUB_API_TOKEN`\n\nBy default, `rpi-update` will not use a custom GitHub API token. If you run into rate limiting issues, you can supply an API token on the command line:\n\n\tsudo GITHUB_API_TOKEN=<your API token> rpi-update\n\n#### `RPI_REBOOT`\n\nTo reboot after successfully update, run:\n\n    sudo RPI_REBOOT=1 rpi-update\n\nYou can use it to automate updates.\n\n## Troubleshooting\n\nThere are two possible problems related to SSL certificates that may prevent\nthis tool from working.\n\n-   The time may be set incorrectly on your Raspberry Pi, which you can fix\n    by setting the time using NTP.\n\n        sudo apt-get install ntpdate\n        sudo ntpdate -u ntp.ubuntu.com\n\n-   The other possible issue is that you might not have the `ca-certificates`\n    package installed, and so GitHub's SSL certificate isn't trusted. If you are\n    on Debian, you can resolve this by typing:\n\n        sudo apt-get install ca-certificates\n\nPi-hole and similar DNS based may stop this tool from working.\nMake sure github.com domains are not blocked. (e.g. codeload.github.com)\n"
        },
        {
          "name": "rpi-update",
          "type": "blob",
          "size": 18.333984375,
          "content": "#!/bin/bash\n\nset -o nounset\nset -o errexit\n\nREPO_URI=${REPO_URI:-\"https://github.com/raspberrypi/rpi-firmware\"}\nREPO_API_URI=${REPO_URI/github.com/api.github.com\\/repos}\nREPO_CONTENT_URI=${REPO_URI/github.com/raw.githubusercontent.com}\n\nUPDATE_SELF=${UPDATE_SELF:-1}\nUPDATE_REPO_URI=\"https://github.com/raspberrypi/rpi-update\"\nUPDATE_REPO_CONTENT_URI=${UPDATE_REPO_URI/github.com/raw.githubusercontent.com}\nUPDATE_URI=\"${UPDATE_REPO_CONTENT_URI}/master/rpi-update\"\n\nif [[ \"${BOOT_PATH:-\"unset\"}\" == \"unset\" && \"${ROOT_PATH:-\"unset\"}\" != \"unset\" ]] ||\n[[ \"${BOOT_PATH:-\"unset\"}\" != \"unset\" && \"${ROOT_PATH:-\"unset\"}\" == \"unset\" ]]; then\n\techo \" *** You need to specify both ROOT_PATH and BOOT_PATH, or neither\"\n\texit 1\nfi\n\nif [[ \"${BOOT_PATH:-\"unset\"}\" == \"unset\" ]]; then\n\tNOOBS_CHECK=${NOOBS_CHECK:-1}\nelse\n\tNOOBS_CHECK=${NOOBS_CHECK:-0}\nfi\n\nBRANCH=${BRANCH:-\"master\"}\nROOT_PATH=${ROOT_PATH:-\"/\"}\nCUR_FW_SUBDIR=\"/$(echo =$(vcgencmd get_config os_prefix) | cut -d'=' -f3)\"\nFW_SUBDIR=${FW_SUBDIR:-${CUR_FW_SUBDIR}}\nif [[ \"${FW_SUBDIR}\" != \"\" ]]; then\n\tif [[ \"${FW_SUBDIR::1}\" != \"/\" ]]; then\n\t\tFW_SUBDIR=\"/$FW_SUBDIR\"\n\tfi\n\tif [[ \"${FW_SUBDIR: -1}\" == \"/\" ]]; then\n\t\tFW_SUBDIR=${FW_SUBDIR: : -1}\n\tfi\nfi\nBOOT_PATH=${BOOT_PATH:-\"/boot\"}\nWORK_PATH=${WORK_PATH:-\"${ROOT_PATH}/root\"}\nSKIP_KERNEL=${SKIP_KERNEL:-0}\nSKIP_SDK=${SKIP_SDK:-0}\nSKIP_VCLIBS=${SKIP_VCLIBS:-0}\nSKIP_REPODELETE=${SKIP_REPODELETE:-0}\nSKIP_BACKUP=${SKIP_BACKUP:-0}\nSKIP_DOWNLOAD=${SKIP_DOWNLOAD:-0}\nSKIP_WARNING=${SKIP_WARNING:-0}\nSKIP_CHECK_PARTITION=${SKIP_CHECK_PARTITION:-0}\nWANT_SYMVERS=${WANT_SYMVERS:-0}\nWANT_PI4=${WANT_PI4:-0}\nPRUNE_MODULES=${PRUNE_MODULES:-0}\nRPI_UPDATE_UNSUPPORTED=${RPI_UPDATE_UNSUPPORTED:-0}\nJUST_CHECK=${JUST_CHECK:-0}\nRPI_REBOOT=${RPI_REBOOT:-0}\nCURL_OPTIONS=${CURL_OPTIONS:-\"\"}\nGITHUB_API_TOKEN=${GITHUB_API_TOKEN:-\"\"}\n\nFW_REPO=\"${REPO_URI}.git\"\nFW_REPOLOCAL=${FW_REPOLOCAL:-\"${WORK_PATH}/.rpi-firmware\"}\nFW_PATH=\"${BOOT_PATH}${FW_SUBDIR}\"\nFW_MODPATH=\"${ROOT_PATH}/lib/modules\"\nFW_REV_IN=${1:-\"\"}\nFW_REVFILE=\"${FW_PATH}/.firmware_revision\"\nSELFUPDATE_SCRIPT=\"${WORK_PATH}/.updateScript.sh\"\n\n[ \"${RPI_UPDATE_UNSUPPORTED}\" -ne 0 ] && echo -e \"You appear to be trying to update firmware on an incompatible distribution. To force update, run the following:\\nsudo -E RPI_UPDATE_UNSUPPORTED=0 rpi-update\" && exit 1\n\nif command -v vcgencmd > /dev/null; then\n\tvcgencmd get_config str | grep -qE \"^kernel=\" && echo -e \"You appear to be using a custom kernel file.\\nSkipping installation of new kernel, as bundled dtb files may be incompatible with your kernel.\" && SKIP_KERNEL=1\nfi\n\n# Always follow redirects\nCURL_OPTIONS=\"${CURL_OPTIONS} -L\"\n\n# api.github.com requires a User-Agent header\nCURL_OPTIONS_API=\"${CURL_OPTIONS_API:-\"-A curl\"}\"\n\n# Support for custom GitHub Auth Tokens\nif [[ -n \"${GITHUB_API_TOKEN}\" ]]; then\n\techo \" *** Using GitHub token for all requests.\"\n\tCURL_OPTIONS=\"${CURL_OPTIONS} --header \\\"Authorization: token ${GITHUB_API_TOKEN}\\\"\"\nfi\n\nGITHUB_API_LIMITED=$(eval curl ${CURL_OPTIONS_API} -s ${CURL_OPTIONS} \"https://api.github.com/rate_limit\" | tr -d \",\" | awk 'BEGIN {reset=0;} { if ($1 == \"\\\"limit\\\":\") limit=$2; else if ($1 == \"\\\"remaining\\\":\") remaining=$2; else if ($1 == \"\\\"reset\\\":\" && limit>0 && remaining==0) reset=$2;} END { print reset }')\nif [ ${GITHUB_API_LIMITED} -gt 0 ]; then\n\techo \" *** Github API is currently rate limited - please try again after $(date --date @${GITHUB_API_LIMITED})\"\n\texit 1\nfi\n\n\nfunction update_self() {\n\techo \" *** Performing self-update\"\n\tlocal _tempFileName=\"$0.tmp\"\n\n\tif ! eval curl -fs ${CURL_OPTIONS} --output \"${_tempFileName}\" \"${UPDATE_URI}\"; then\n\t\techo \" !!! Failed to download update for rpi-update!\"\n\t\techo \" !!! Make sure you have ca-certificates installed and that the time is set correctly\"\n\t\texit 1\n\tfi\n\n\tif [[ \"$(head -1 ${_tempFileName})\" != '#!/bin/bash' ]]; then\n\t\techo \" !!! Failed to download update for rpi-update!\"\n\t\techo \" !!! Contents of file is not as expected - github may be down\"\n\t\texit 1\n\tfi\n\n\tlocal OCTAL_MODE=$(stat -c '%a' \"$0\")\n\tif ! chmod ${OCTAL_MODE} \"${_tempFileName}\" ; then\n\t\techo \" !!! Failed: Error while trying to set mode on ${_tempFileName}\"\n\t\texit 1\n\tfi\n\n\tcat > \"${SELFUPDATE_SCRIPT}\" << EOF\n\tif mv \"${_tempFileName}\" \"$0\"; then\n\t\trm -- \"\\$0\"\n\t\texec env UPDATE_SELF=0 /bin/bash \"$0\" \"${FW_REV_IN}\"\n\telse\n\t\techo \" !!! Failed!\"\n\tfi\nEOF\n\n\techo \" *** Relaunching after update\"\n\texec /bin/bash \"${SELFUPDATE_SCRIPT}\"\n}\n\nfunction update_modules {\n\tif [[ ${SKIP_KERNEL} -eq 0 ]]; then\n\t\techo \" *** Updating kernel modules\"\n\t\tfind \"${FW_REPOLOCAL}/modules\" -mindepth 1 -maxdepth 1 -type d | while read DIR; do\n\t\t\tBASEDIR=$(basename \"${DIR}\")\n\t\t\trm -rf \"${FW_MODPATH}/${BASEDIR}/kernel\"\n\t\tdone\n\n\t\tif [[ ${PRUNE_MODULES} -ne 0 ]]; then\n\t\t\tfind \"${FW_MODPATH}\" -mindepth 1 -maxdepth 1 -type d | while read DIR; do\n\t\t\t\tCOUNT=$(find \"${DIR}\" -type f ! \\( -name '*.ko' -o -name 'modules.*' \\) | wc -l);\n\t\t\t\tif [[ ${COUNT} -eq 0 ]]; then\n\t\t\t\t\techo \"Pruning ${DIR}\"\n\t\t\t\t\trm -rf \"${DIR}\"\n\t\t\t\telse\n\t\t\t\t\techo \"Keeping ${DIR}\"\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\n\t\tfind \"${FW_REPOLOCAL}/modules\" -mindepth 1 -maxdepth 1 -type d | while read DIR; do\n\t\t\tBASEDIR=\"$(basename \"${DIR}\")\"\n\t\t\tif [[ ${WANT_PI4} -ne 1 ]]; then\n\t\t\t\tENDSWITH=${BASEDIR: -4}\n\t\t\t\tif [[ \"${ENDSWITH}\" == \"v7l+\" ]]; then\n\t\t\t\t\tcontinue;\n\t\t\t\tfi\n\t\t\t\tENDSWITH=${BASEDIR: -3}\n\t\t\t\tif [[ \"${ENDSWITH}\" == \"v8+\" ]]; then\n\t\t\t\t\tcontinue;\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tcp -R \"${DIR}\" \"${FW_MODPATH}/\"\n\t\t\techo \" *** depmod ${BASEDIR}\"\n\t\t\tdepmod -b \"${ROOT_PATH}\" -a \"${BASEDIR}\"\n\t\tdone\n\telse\n\t\techo \" *** As requested, not updating kernel modules\"\n\tfi\n}\n\nfunction update_vc_libs {\n\tif [[ ${SKIP_VCLIBS} -eq 0 ]]; then\n\t\techo \" *** Updating VideoCore libraries\"\n\telse\n\t\techo \" *** As requested, not updating VideoCore libraries\"\n\t\treturn\n\tfi\n\n\tif [[ -e ${ROOT_PATH}/bin/sh ]]; then\n\t\tlocal ELFOUTPUT=$(readelf -a \"${ROOT_PATH}/bin/sh\"; readelf -h \"${ROOT_PATH}/bin/sh\")\n\telse\n\t\tlocal ELFOUTPUT=\"VFP_args\"\n\tfi\n\tif [[ \"${ELFOUTPUT}\" != \"${ELFOUTPUT/VFP_args/}\" || \\\n\t\t\t\"${ELFOUTPUT}\" != \"${ELFOUTPUT/hard-float/}\" ]]; then\n\t\techo \" *** Using HardFP libraries\"\n\t\tcp -R \"${FW_REPOLOCAL}/vc/hardfp/\"* \"${ROOT_PATH}/\"\n\telse\n\t\techo \" *** Using SoftFP libraries\"\n\t\tcp -R \"${FW_REPOLOCAL}/vc/softfp/\"* \"${ROOT_PATH}/\"\n\tfi\n}\n\nfunction update_sdk {\n\tif [[ ${SKIP_SDK} -eq 0 ]]; then\n\t\techo \" *** Updating SDK\"\n\t\tcp -R \"${FW_REPOLOCAL}/vc/sdk/\"* \"${ROOT_PATH}/\"\n\telse\n\t\techo \" *** As requested, not updating SDK\"\n\tfi\n}\n\n# Check if the bootloader is older than the latest critical release. An old\n# bootloader shouldn't block rpi-update so just inform the user that bootloader\n# is out of date.\nfunction check_eeprom_version {\n\tlocal CURRENT_VERSION=\"\"\n\tlocal FIRST_VERSION=1557513636\n\t# MIN VERSION for Sep 10 2019 EEPROM\n\tlocal MIN_VERSION=1568112110\n\tlocal HAVE_BOOTLOADER_EEPROM=0\n\n\t# Skip EEPROM check if vcgencmd is missing because it won't be possible to\n\t# check the version.\n\tif ! command -v vcgencmd > /dev/null; then\n\t\treturn\n\tfi\n\n\trev=\n\tif [ -f /proc/cpuinfo ]; then\n\t\trev=\"$(sed -n '/^Revision/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo)\"\n\tfi\n\n\tif [ -n $rev ] && [ $(((0x$rev >> 23) & 1)) -ne 0 ] && [ $(((0x$rev >> 12) & 15)) -eq 3 ]; then\n\t\tHAVE_BOOTLOADER_EEPROM=1\n\tfi\n\n\tif [ \"${HAVE_BOOTLOADER_EEPROM}\" != 1 ]; then\n\t\treturn\n\tfi\n\n\t# vcgencmd doesn't return non-zero for unknown commands.\n\tif vcgencmd bootloader_config | grep -qi \"Command not registered\"; then\n\t\t# Firmware is too old to return the bootloader config\n\t\treturn\n\tfi\n\n\t# If FREEZE_VERSION is specified then assume that the user doesn't want\n\t# an EEPROM update so skip the check.\n\tif vcgencmd bootloader_config | grep -q FREEZE_VERSION=1; then\n\t\treturn\n\tfi\n\n\tif vcgencmd bootloader_version | grep -q timestamp; then\n\t\tCURRENT_VERSION=$(vcgencmd bootloader_version | grep timestamp | awk '{print $2}')\n\t\tif [ \"${CURRENT_VERSION}\" = \"0\" ]; then\n\t\t\t# If a timestamp of zero is returned then it's new firmware but an\n\t\t\t# old bootloader. Assume bootloader v0\n\t\t\tCURRENT_VERSION=\"${FIRST_VERSION}\"\n\t\tfi\n\telif vcgencmd bootloader_version | grep -qi \"unknown\"; then\n\t\treturn\n\telse\n\t\t# New bootloader / old firmware ? Try to parse the date\n\t\tCURRENT_VERSION=$(date -u +%s --date \"$(vcgencmd bootloader_version | head -n1)\")\n\tfi\n\n\t# Failed to parse the version. Default to the initial production release.\n\tif [ -z \"${CURRENT_VERSION}\" ]; then\n\t\tCURRENT_VERSION=\"${FIRST_VERSION}\"\n\tfi\n\n\tif [ \"${CURRENT_VERSION}\" -lt \"${MIN_VERSION}\" ]; then\n\t\techo \"A newer bootloader EEPROM version is available.\"\n\t\techo \"On Debian, try: sudo apt update; sudo apt install rpi-eeprom\"\n\t\techo \"then reboot to install the new bootloader\"\n\tfi\n}\n\nfunction show_notice {\n\tlocal NOTICE_URI=${REPO_CONTENT_URI}/${FW_REV}/NOTICE.md\n\tlocal FULL_NOTICE=$(eval curl -fs ${CURL_OPTIONS} \"${NOTICE_URI}\")\n\tif [ -z \"${FULL_NOTICE}\" ]; then\n\t\treturn\n\tfi\n\tlocal NOTICE_HASH_HEAD=$(echo \"${FULL_NOTICE}\" | head -1)\n\tif [ \"$(echo \"${NOTICE_HASH_HEAD}\" | awk -F: '{print $1}')\" == \"HASH\" ]; then\n\t\tlocal NOTICE_HASH_EXISTS=true\n\t\tlocal NOTICE_HASH=$(echo \"${NOTICE_HASH_HEAD}\" | awk '{print $2}')\n\telse\n\t\tlocal NOTICE_HASH_EXISTS=false\n\tfi\n\tif ${NOTICE_HASH_EXISTS}; then\n\t\tlocal NOTICE=$(echo \"${FULL_NOTICE}\" | tail -n+2)\n\t\tlocal NEW_HASH=${FW_REV}\n\t\tlocal LOCAL_lt_NOTICE=$(compare_hashes \"${LOCAL_HASH}\" lt \"${NOTICE_HASH}\")\n\t\tlocal NEW_ge_NOTICE=$(compare_hashes \"${NEW_HASH}\" ge \"${NOTICE_HASH}\")\n\t\tif ! ${LOCAL_lt_NOTICE} && ! ${NEW_ge_NOTICE}; then\n\t\t\treturn\n\t\tfi\n\telse\n\t\tlocal NOTICE=${FULL_NOTICE}\n\tfi\n\techo \"${NOTICE}\"\n\tif ! echo \"${NOTICE}\" | grep -q WARNING; then\n\t\treturn\n\tfi\n\tif [[ ${SKIP_WARNING} -ne 0 ]]; then\n\t\treturn\n\tfi\n\tread -p \"Would you like to proceed? (y/N)\" -n 1 -r -s\n\techo \"\"\n\tif ! [[ $REPLY =~ ^[Yy]$ ]]; then\n\t\texit 1;\n\tfi\n}\n\nfunction check_partition {\n\tif [[ ${SKIP_CHECK_PARTITION} -ne 0 ]]; then\n\t\treturn\n\tfi\n\tlocal PARTSIZE=0\n\tif command -v df > /dev/null 2>&1 ; then\n\t\tlocal M=$(df -P ${BOOT_PATH} | awk 'END{print $1}')\n\t\tif [[ $M == /dev/* ]]; then\n\t\t\tif command -v lsblk > /dev/null 2>&1 ; then\n\t\t\t\tPARTSIZE=$(lsblk -bno SIZE ${M})\n\t\t\tfi\n\t\tfi\n\tfi\n\tif [ $PARTSIZE -ne 0 ] && [ $PARTSIZE -lt $(( 256*1024*1024 )) ]; then\n\t\techo \"Partition size $(( $PARTSIZE >> 20 ))M may not be sufficient for new Pi4 files\"\n\t\techo \"This could result in a system that will not boot.\"\n\t\techo \"256M FAT partition is recommended. Ensure you have a backup if continuing.\"\n\t\tif [[ ${SKIP_WARNING} -ne 0 ]]; then\n\t\t\treturn\n\t\tfi\n\t\tread -p \"Would you like to proceed? (y/N)\" -n 1 -r -s\n\t\techo \"\"\n\t\tif ! [[ $REPLY =~ ^[Yy]$ ]]; then\n\t\t\texit 1;\n\t\tfi\n\tfi\n}\n\nfunction update_firmware {\n\techo \" *** Updating firmware\"\n\trm -rf \"${FW_PATH}/\"*.elf\n\trm -rf \"${FW_PATH}/\"bootcode.bin\n\tif [[ ${WANT_PI4} -eq 1 ]]; then\n\t\tcp \"${FW_REPOLOCAL}/\"*.elf \"${FW_PATH}/\"\n\t\tcp \"${FW_REPOLOCAL}/\"*.dat \"${FW_PATH}/\"\n\telse\n\t\tcp \"${FW_REPOLOCAL}/\"start{,[^4]*}.elf \"${FW_PATH}/\"\n\t\tcp \"${FW_REPOLOCAL}/\"fixup{,[^4]*}.dat \"${FW_PATH}/\"\n\tfi\n\tcp \"${FW_REPOLOCAL}/\"*.bin \"${FW_PATH}/\"\n\tif [[ ${SKIP_KERNEL} -eq 0 ]]; then\n\t\tif [[ ${WANT_PI4} -eq 1 ]]; then\n\t\t\tcp \"${FW_REPOLOCAL}/\"*.img \"${FW_PATH}/\"\n\t\telse\n\t\t\tcp \"${FW_REPOLOCAL}/\"kernel.img \"${FW_REPOLOCAL}/\"kernel7.img \"${FW_PATH}/\"\n\t\tfi\n\t\tif [[ -n $(shopt -s nullglob; echo \"${FW_REPOLOCAL}/\"*.dtb*) ]]; then\n\t\t\tcp \"${FW_REPOLOCAL}/\"*.dtb* \"${FW_PATH}/\"\n\t\tfi\n\t\tif [[ -n $(shopt -s nullglob; echo \"${FW_REPOLOCAL}/overlays/\"*.dtb*) ]]; then\n\t\t\tmkdir -p \"${FW_PATH}/overlays\"\n\t\t\tcp \"${FW_REPOLOCAL}/overlays/\"*.dtb* \"${FW_PATH}/overlays/\"\n\t\t\tif [[ -f \"${FW_REPOLOCAL}/overlays/README\" ]]; then\n\t\t\t\tcp \"${FW_REPOLOCAL}/overlays/README\" \"${FW_PATH}/overlays/\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\techo \" *** As requested, not updating kernel\"\n\tfi\n\tif [[ ${WANT_SYMVERS} -ne 0 ]]; then\n\t\tif [[ -f \"${FW_REPOLOCAL}/Module.symvers\" ]]; then\n\t\t\tcp \"${FW_REPOLOCAL}/Module.symvers\" \"${FW_PATH}/\"\n\t\tfi\n\t\tif [[ -f \"${FW_REPOLOCAL}/Module7.symvers\" ]]; then\n\t\t\tcp \"${FW_REPOLOCAL}/Module7.symvers\" \"${FW_PATH}/\"\n\t\tfi\n\t\tif [[ -f \"${FW_REPOLOCAL}/git_hash\" ]]; then\n\t\t\tcp \"${FW_REPOLOCAL}/git_hash\" \"${FW_PATH}/\"\n\t\tfi\n\tfi\n}\n\nfunction finalise {\n\tif [[ -f \"${FW_PATH}/arm192_start.elf\" ]]; then\n\t\techo \" *** Setting 192M ARM split\"\n\t\tcp \"${FW_PATH}/arm192_start.elf\" \"${FW_PATH}/start.elf\"\n\tfi\n\tif [[ -e ${ROOT_PATH}/etc ]]; then\n\t\techo \" *** Running ldconfig\"\n\t\tldconfig -r \"${ROOT_PATH}\"\n\tfi\n\techo \" *** Storing current firmware revision\"\n\techo \"${FW_REV}\" > \"${FW_REVFILE}\"\n}\n\nfunction do_backup {\n\tif [[ ${SKIP_BACKUP} -eq 0 ]]; then\n\t\techo \" *** Backing up files (this will take a few minutes)\"\n\t\tlocal OLD_FW_PATH=\"${BOOT_PATH}.bak\"\n\t\tif [[ -d \"${OLD_FW_PATH}\" ]]; then\n\t\t\techo \" *** Remove old firmware backup\"\n\t\t\trm -rf \"${OLD_FW_PATH}\"\n\t\tfi\n\t\techo \" *** Backing up firmware\"\n\t\tcp -a \"${FW_PATH}\" \"${OLD_FW_PATH}\"\n\t\tif [[ ${SKIP_KERNEL} -eq 0 ]]; then\n\t\t\tOLD_FW_MODPATH=${FW_MODPATH}.bak\n\t\t\tif [[ -d \"${OLD_FW_MODPATH}\" ]]; then\n\t\t\t\techo \" *** Remove old modules backup\"\n\t\t\t\trm -rf \"${OLD_FW_MODPATH}\"\n\t\t\tfi\n\t\t\techo \" *** Backing up modules $(uname -r)\"\n\t\t\tlocal CURRENT_FW_MODPATH=${FW_MODPATH}/$(uname -r)\n\t\t\tif [[ -d \"${CURRENT_FW_MODPATH}\" ]]; then\n\t\t\t\tmkdir -p \"${OLD_FW_MODPATH}\" && cp -a \"${CURRENT_FW_MODPATH}\" \"${OLD_FW_MODPATH}\"\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\nfunction do_update {\n\tif [ -f ${FW_PATH}/kernel7l.img ] || [ -f ${FW_PATH}/kernel8.img ]; then\n\t\tWANT_PI4=1\n\tfi\n\tif [[ ${WANT_PI4} -eq 1 ]]; then\n\t\tcheck_partition\n\tfi\n\tcheck_eeprom_version\n\tshow_notice\n\tdownload_rev\n\tif [[ -f \"${FW_REPOLOCAL}/pre-install\" ]]; then\n\t\techo \" *** Running pre-install script\"\n\t\tsource \"${FW_REPOLOCAL}/pre-install\"\n\tfi\n\tupdate_firmware\n\tupdate_modules\n\tupdate_vc_libs\n\tupdate_sdk\n\tfinalise\n\tif [[ -f \"${FW_REPOLOCAL}/post-install\" ]]; then\n\t\techo \" *** Running post-install script\"\n\t\tsource \"${FW_REPOLOCAL}/post-install\"\n\tfi\n\tremove_rev\n\techo \" *** Syncing changes to disk\"\n\tsync\n\techo \" *** If no errors appeared, your firmware was successfully updated to ${FW_REV}\"\n\tif [[ \"${ROOT_PATH}\" == \"/\" ]]; then\n\t\tif [[ ${RPI_REBOOT} -ne 0 ]]; then\n\t\t\techo \" *** Rebooting to activate the new firmware\"\n\t\t\treboot\n\t\telse\n\t\t\techo \" *** A reboot is needed to activate the new firmware\"\n\t\tfi\n\tfi\n}\n\nfunction download_rev {\n\tif [[ ${SKIP_DOWNLOAD} -eq 0 ]]; then\n\t\tlocal FW_TARBALL_URI=${REPO_URI}/tarball/${FW_REV}\n\t\tif ! eval curl -fs ${CURL_OPTIONS} --output /dev/null --head \"${FW_TARBALL_URI}\"; then\n\t\t\techo \"Invalid git hash specified\"\n\t\t\texit 1\n\t\tfi\n\t\techo \" *** Downloading specific firmware revision (this will take a few minutes)\"\n\t\trm -rf \"${FW_REPOLOCAL}\"\n\t\tmkdir -p \"${FW_REPOLOCAL}\"\n\t\teval curl ${CURL_OPTIONS} \"${FW_TARBALL_URI}\" | tar xzf - -C \"${FW_REPOLOCAL}\" --strip-components=1\n\tfi\n}\n\nfunction remove_rev {\n\techo \" *** Deleting downloaded files\"\n\tif [[ ${SKIP_REPODELETE} -eq 0 ]]; then\n\t\trm -rf \"${FW_REPOLOCAL}\"\n\tfi\n}\n\nfunction noobs_fix {\n\techo \" !!! ${BOOT_PATH} appears to contain NOOBS files\"\n\techo \"     This may occur if fstab contains incorrect entries.\"\n\techo \"     rpi-update will attempt to correct fstab.\"\n\tread -p \"Would you like to proceed? (y/N)\" -n 1 -r -s\n\techo\n\tif ! [[ $REPLY =~ ^[Yy]$ ]]; then\n\t\texit 1;\n\tfi\n\n\tif ! grep -qE \"/dev/mmcblk0p1\\s+/boot\" \"${ROOT_PATH}/etc/fstab\"; then\n\t\techo \"Unexpected fstab entry\"\n\t\texit 1\n\tfi\n\n\tlocal ROOTNUM=$(cat \"/proc/cmdline\" | sed -n 's|.*root=/dev/mmcblk0p\\([0-9]*\\).*|\\1|p')\n\tif [ ! \"${ROOTNUM}\" ];then\n\t\techo \"Could not determine root partition.\"\n\t\texit 1\n\tfi\n\tlocal BOOT_DEV=\"/dev/mmcblk0p$((ROOTNUM-1))\"\n\tlocal ROOT_DEV=\"/dev/mmcblk0p${ROOTNUM}\"\n\tsed \"${ROOT_PATH}/etc/fstab\" -e \"s|^.*[^#].* / |${ROOT_DEV}  / |;s|^.*[^#].* /boot |${BOOT_DEV}  /boot |\"\n\tread -p \"Does this look correct? (y/N)\" -n 1 -r -s\n\techo\n\tif ! [[ $REPLY =~ ^[Yy]$ ]]; then\n\t\texit 1;\n\tfi\n\tsed \"${ROOT_PATH}/etc/fstab\" -i -e \"s|^.*[^#].* / |${ROOT_DEV}  / |;s|^.*[^#].* /boot |${BOOT_DEV}  /boot |\"\n\n\tumount \"${BOOT_PATH}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to umount ${BOOT_PATH}. Remount manually and try again.\"\n\t\texit 1\n\telse\n\t\tmount \"/boot\"\n\tfi\n\n}\n\nfunction get_hash_date {\n\tlocal COMMITS_URI=${REPO_API_URI}/commits/$1\n\teval curl ${CURL_OPTIONS_API} -s ${CURL_OPTIONS} \"${COMMITS_URI}\" | grep \"date\" | head -1 | awk -F\\\" '{print $4}'\n}\n\nfunction compare_hashes {\n\tlocal DATE1=$(get_hash_date \"$1\")\n\tlocal DATE2=$(get_hash_date \"$3\")\n\tif [ $(date -d \"${DATE1}\" +%s) -$2 $(date -d \"${DATE2}\" +%s) ]; then\n\t\techo true\n\telse\n\t\techo false\n\tfi\n}\n\nfunction get_long_hash {\n\t# ask github for long version hash\n\tlocal COMMITS_URI=${REPO_API_URI}/commits/$1\n\teval curl ${CURL_OPTIONS_API} -s ${CURL_OPTIONS} \"${COMMITS_URI}\" | awk 'BEGIN {hash=\"\"} { if (hash == \"\" && $1 == \"\\\"sha\\\":\") {hash=substr($2, 2, 40);} } END {print hash}'\n}\n\n\nif [[ ${EUID} -ne 0 ]]; then\n\techo \" !!! This tool must be run as root\"\n\texit 1\nfi\n\necho \" *** Raspberry Pi firmware updater by Hexxeh, enhanced by AndrewS and Dom\"\n\nif [[ ! -d ${WORK_PATH} ]]; then\n\techo \" !!! ${WORK_PATH} doesn't exist - creating\"\n\tmkdir -p \"${WORK_PATH}\"\nfi\n\nif [[ ${UPDATE_SELF} -ne 0 ]]; then\n\tupdate_self\nelse\n\trm -f \"${SELFUPDATE_SCRIPT}\"\nfi\n\nif [[ ! -d \"${FW_PATH}\" ]]; then\n\techo \" !!! ${FW_PATH} doesn't exist - creating\"\n\tmkdir -p \"${FW_PATH}\"\nfi\n\nif [[ ${SKIP_KERNEL} -eq 0 ]] && [[ ! -d \"${FW_MODPATH}\" ]]; then\n\techo \" !!! ${FW_MODPATH} doesn't exist - creating\"\n\tmkdir -p \"${FW_MODPATH}\"\nfi\n\nif [[ ${NOOBS_CHECK} -eq 1 ]] && [[ -f \"${BOOT_PATH}/recovery.elf\" ]]; then\n\tnoobs_fix\nfi\n\ncommand -v readelf >/dev/null 2>&1 || {\n\techo \" !!! This tool requires you have readelf installed, please install it first\"\n\techo \"     In Debian, try: sudo apt-get install binutils\"\n\techo \"     In Arch, try: pacman -S binutils\"\n\texit 1\n}\n\nif [[ \"${FW_REV_IN}\" == \"\" ]]; then\n\tFW_REV_IN=${BRANCH}\nfi\n\nFW_REV=$(get_long_hash \"${FW_REV_IN}\")\n\nif [[ \"${FW_REV}\" == \"\" ]]; then\n\techo \" *** Invalid hash given\"\n\texit 1\nfi\n\nif [[ ! -f \"${FW_REVFILE}\" ]]; then\n\tLOCAL_HASH=0\n\techo \" *** We're running for the first time\"\n\tif [[ ${JUST_CHECK} -ne 0 ]]; then\n\t\techo \" *** Firmware update required. No local hash to compare to.\"\n\t\texit 2\n\tfi\n\tdo_backup\nelse\n\tLOCAL_HASH=$(get_long_hash \"$(cat \"${FW_REVFILE}\")\")\n\tif [[ \"${LOCAL_HASH}\" == \"${FW_REV}\" ]]; then\n\t\techo \" *** Your firmware is already up to date (delete ${FW_REVFILE} to force an update anyway)\"\n\t\texit 0\n\tfi\n\tif [[ ${JUST_CHECK} -ne 0 ]]; then\n\t\tif $(compare_hashes \"${LOCAL_HASH}\" lt \"${FW_REV}\"); then\n\t\t\techo \" *** Firmware update required. New commits available:\"\n\t\t\tDIFF_URI=${REPO_API_URI}/compare/${LOCAL_HASH}...${FW_REV}\n\t\telse\n\t\t\techo \" *** Firmware downgrade requested. Commits to drop:\"\n\t\t\tDIFF_URI=${REPO_API_URI}/compare/${FW_REV}...${LOCAL_HASH}\n\t\tfi\n\t\tSEPARATOR=\"======================================================\"\n\t\teval curl ${CURL_OPTIONS_API} -s ${CURL_OPTIONS} \"${DIFF_URI}\" | awk -v SEPARATOR=\"${SEPARATOR}\" -F\\\" ' { if ($2 == \"commits\") {commits=1} if (commits && $2 == \"message\") {print SEPARATOR \"\\nCommit: \" $4} }' | sed 's/\\\\n\\\\n/\\nCommit:\\ /g'\n\t\texit 2\n\tfi\nfi\n\ndo_update\n"
        }
      ]
    }
  ]
}