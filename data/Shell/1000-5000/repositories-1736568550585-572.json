{
  "metadata": {
    "timestamp": 1736568550585,
    "page": 572,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU3OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "barryclark/bashstrap",
      "stars": 1559,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".bash_profile",
          "type": "blob",
          "size": 2.470703125,
          "content": "### Aliases\n\n# Open specified files in Sublime Text\n# \"s .\" will open the current directory in Sublime\nalias s='open -a \"Sublime Text\"'\n\n# Color LS\ncolorflag=\"-G\"\nalias ls=\"command ls ${colorflag}\"\nalias l=\"ls -lF ${colorflag}\" # all files, in long format\nalias la=\"ls -laF ${colorflag}\" # all files inc dotfiles, in long format\nalias lsd='ls -lF ${colorflag} | grep \"^d\"' # only directories\n\n# Quicker navigation\nalias ..=\"cd ..\"\nalias ...=\"cd ../..\"\nalias ....=\"cd ../../..\"\nalias .....=\"cd ../../../..\"\n\n# Enable aliases to be sudo’ed\nalias sudo='sudo '\n\n# Colored up cat!\n# You must install Pygments first - \"sudo easy_install Pygments\"\nalias c='pygmentize -O style=monokai -f console256 -g'\n\n# Git\n# You must install Git first\nalias gs='git status'\nalias ga='git add .'\nalias gc='git commit -m' # requires you to type a commit message\nalias gp='git push'\nalias grm='git rm $(git ls-files --deleted)'\n\n### Prompt Colors\n# Modified version of @gf3’s Sexy Bash Prompt\n# (https://github.com/gf3/dotfiles)\nif [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then\n\texport TERM=gnome-256color\nelif infocmp xterm-256color >/dev/null 2>&1; then\n\texport TERM=xterm-256color\nfi\n\nif tput setaf 1 &> /dev/null; then\n\ttput sgr0\n\tif [[ $(tput colors) -ge 256 ]] 2>/dev/null; then\n\t\tMAGENTA=$(tput setaf 9)\n\t\tORANGE=$(tput setaf 172)\n\t\tGREEN=$(tput setaf 190)\n\t\tPURPLE=$(tput setaf 141)\n\telse\n\t\tMAGENTA=$(tput setaf 5)\n\t\tORANGE=$(tput setaf 4)\n\t\tGREEN=$(tput setaf 2)\n\t\tPURPLE=$(tput setaf 1)\n\tfi\n\tBOLD=$(tput bold)\n\tRESET=$(tput sgr0)\nelse\n\tMAGENTA=\"\\033[1;31m\"\n\tORANGE=\"\\033[1;33m\"\n\tGREEN=\"\\033[1;32m\"\n\tPURPLE=\"\\033[1;35m\"\n\tBOLD=\"\"\n\tRESET=\"\\033[m\"\nfi\n\nexport MAGENTA\nexport ORANGE\nexport GREEN\nexport PURPLE\nexport BOLD\nexport RESET\n\n# Git branch details\nfunction parse_git_dirty() {\n\t[[ $(git status 2> /dev/null | tail -n1) != *\"working directory clean\"* ]] && echo \"*\"\n}\nfunction parse_git_branch() {\n\tgit branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e \"s/* \\(.*\\)/\\1$(parse_git_dirty)/\"\n}\n\n# Change this symbol to something sweet.\n# (http://en.wikipedia.org/wiki/Unicode_symbols)\nsymbol=\"⚡ \"\n\nexport PS1=\"\\[${MAGENTA}\\]\\u \\[$RESET\\]in \\[$GREEN\\]\\w\\[$RESET\\]\\$([[ -n \\$(git branch 2> /dev/null) ]] && echo \\\" on \\\")\\[$PURPLE\\]\\$(parse_git_branch)\\[$RESET\\]\\n$symbol\\[$RESET\\]\"\nexport PS2=\"\\[$ORANGE\\]→ \\[$RESET\\]\"\n\n\n### Misc\n\n# Only show the current directory's name in the tab\nexport PROMPT_COMMAND='echo -ne \"\\033]0;${PWD##*/}\\007\"'\n\n# init z! (https://github.com/rupa/z)\n. ~/z.sh\n"
        },
        {
          "name": ".bashrc",
          "type": "blob",
          "size": 0.0927734375,
          "content": "# Nothing to see here — Everything's in .bash_profile\n[ -n \"$PS1\" ] && source ~/.bash_profile"
        },
        {
          "name": ".gitconfig",
          "type": "blob",
          "size": 0.6025390625,
          "content": "[alias]\n\t# TBC\n[core]\n\t# Use custom `.gitignore`\n\texcludesfile = ~/.gitignore\n\t# Treat spaces before tabs, lines that are indented with 8 or more spaces, and all kinds of trailing whitespace as an error\n\twhitespace = space-before-tab,indent-with-non-tab,trailing-space\n[color]\n\t# Use colors in Git commands that are capable of colored output when outputting to the terminal\n\tui = auto\n[color \"branch\"]\n\tcurrent = yellow reverse\n\tlocal = yellow\n\tremote = green\n[color \"diff\"]\n\tmeta = yellow bold\n\tfrag = magenta bold\n\told = red bold\n\tnew = green bold\n[color \"status\"]\n\tadded = yellow\n\tchanged = green\n\tuntracked = cyan"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1923828125,
          "content": "# Some sensible files to ignore\n\n# Folder view configuration files\n.DS_Store\nDesktop.ini\n\n# Thumbnail cache files\n._*\nThumbs.db\n\n# Files that might appear on external disks\n.Spotlight-V100\n.Trashes"
        },
        {
          "name": ".hushlogin",
          "type": "blob",
          "size": 0.0576171875,
          "content": "# This file prevents the shell login message from appearing"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.96875,
          "content": "Bashstrap is a quick way to spruce up OSX terminal. It cuts out the fluff, adds in timesaving features, and provides a solid foundation for customizing your terminal style.\n\nBased on Mathias Bynens epic dotfiles - https://github.com/mathiasbynens/dotfiles\n\n<img src=\"https://raw.github.com/barryclark/bashstrap/master/screenshot.png\" alt=\"screenshot\" />\n\n### Feature list\n\n**Faster directory navigation**\n\n- Open your current directory in Sublime Text (with just 2 characters)\n- Jump directories rapidly, without having to set aliases—using Z (my favorite feature!)\n- Tab bar displays your current directory\n- Lots of quick shortcut aliases that I use for git and moving around directories\n\n**Customized bash prompt line**\n\n- Git branch status inline\n- ☠ ahoy! An easily customizable symbol\n- Stripped out extraneous text\n\n**Updated color scheme**\n\n- Colored 'ls'\n- Syntax highlighted 'cat'\n\n### Installation: dotfiles (2 mins)\n\n1. Back up your current dotfiles (optional):\n\n\t\tmv ~/.bash_profile ~/.bash_profile_backup\n\t\tmv ~/.bashrc ~/.bashrc_backup\n\t\tmv ~/.gitconfig ~/.gitconfig_backup\n\n2. Install Bashstrap into your home dir:\n\n\t\tcd; curl -#L https://github.com/barryclark/bashstrap/tarball/master | tar -xzv --strip-components 1 --exclude={README.md,screenshot.png}\n\t\t\n3. Run `source ~/.bash_profile` or restart iTerm or terminal.\n\n### Installation: iTerm (5 mins)\n\nFollowing these steps will make your iTerm look identical to mine in the screenshot above.\n\n1. [Install iTerm](http://www.iterm2.com/#/section/downloads).\n1. Prettier font: *iTerm Preferences > Profiles > Default > Text > Regular Font & Non-ASCII > 14pt Menlo regular*\n1. Unbold font: *iTerm Preferences > Profiles > Default > Text > Text Rendering > uncheck \"Draw bold text in bold font\"*\n1. Lighter blue for the directory highlighting: *iTerm Preferences > Profiles > Default > Colors > click Blue and make it lighter*\n\n### For more on configuring Bashstrap, see my blog post: [Creating Bashstrap](http://barryclark.co/creating-bashstrap)\n"
        },
        {
          "name": "screenshot.png",
          "type": "blob",
          "size": 282.5869140625,
          "content": null
        },
        {
          "name": "z.sh",
          "type": "blob",
          "size": 8.6083984375,
          "content": "# Copyright (c) 2009 rupa deadwyler under the WTFPL license\n\n# maintains a jump-list of the directories you actually use\n#\n# INSTALL:\n#     * put something like this in your .bashrc/.zshrc:\n#         . /path/to/z.sh\n#     * cd around for a while to build up the db\n#     * PROFIT!!\n#     * optionally:\n#         set $_Z_CMD in .bashrc/.zshrc to change the command (default z).\n#         set $_Z_DATA in .bashrc/.zshrc to change the datafile (default ~/.z).\n#         set $_Z_NO_RESOLVE_SYMLINKS to prevent symlink resolution.\n#         set $_Z_NO_PROMPT_COMMAND if you're handling PROMPT_COMMAND yourself.\n#         set $_Z_EXCLUDE_DIRS to an array of directories to exclude.\n#         set $_Z_OWNER to your username if you want use z while sudo with $HOME kept\n#\n# USE:\n#     * z foo     # cd to most frecent dir matching foo\n#     * z foo bar # cd to most frecent dir matching foo and bar\n#     * z -r foo  # cd to highest ranked dir matching foo\n#     * z -t foo  # cd to most recently accessed dir matching foo\n#     * z -l foo  # list matches instead of cd\n#     * z -c foo  # restrict matches to subdirs of $PWD\n\n[ -d \"${_Z_DATA:-$HOME/.z}\" ] && {\n    echo \"ERROR: z.sh's datafile (${_Z_DATA:-$HOME/.z}) is a directory.\"\n}\n\n_z() {\n\n    local datafile=\"${_Z_DATA:-$HOME/.z}\"\n\n    # bail if we don't own ~/.z and $_Z_OWNER not set\n    [ -z \"$_Z_OWNER\" -a -f \"$datafile\" -a ! -O \"$datafile\" ] && return\n\n    # add entries\n    if [ \"$1\" = \"--add\" ]; then\n        shift\n\n        # $HOME isn't worth matching\n        [ \"$*\" = \"$HOME\" ] && return\n\n        # don't track excluded directory trees\n        local exclude\n        for exclude in \"${_Z_EXCLUDE_DIRS[@]}\"; do\n            case \"$*\" in \"$exclude*\") return;; esac\n        done\n\n        # maintain the data file\n        local tempfile=\"$datafile.$RANDOM\"\n        while read line; do\n            # only count directories\n            [ -d \"${line%%\\|*}\" ] && echo $line\n        done < \"$datafile\" | awk -v path=\"$*\" -v now=\"$(date +%s)\" -F\"|\" '\n            BEGIN {\n                rank[path] = 1\n                time[path] = now\n            }\n            $2 >= 1 {\n                # drop ranks below 1\n                if( $1 == path ) {\n                    rank[$1] = $2 + 1\n                    time[$1] = now\n                } else {\n                    rank[$1] = $2\n                    time[$1] = $3\n                }\n                count += $2\n            }\n            END {\n                if( count > 9000 ) {\n                    # aging\n                    for( x in rank ) print x \"|\" 0.99*rank[x] \"|\" time[x]\n                } else for( x in rank ) print x \"|\" rank[x] \"|\" time[x]\n            }\n        ' 2>/dev/null >| \"$tempfile\"\n        # do our best to avoid clobbering the datafile in a race condition\n        if [ $? -ne 0 -a -f \"$datafile\" ]; then\n            env rm -f \"$tempfile\"\n        else\n            [ \"$_Z_OWNER\" ] && chown $_Z_OWNER:$(id -ng $_Z_OWNER) \"$tempfile\"\n            env mv -f \"$tempfile\" \"$datafile\" || env rm -f \"$tempfile\"\n        fi\n\n    # tab completion\n    elif [ \"$1\" = \"--complete\" -a -s \"$datafile\" ]; then\n        while read line; do\n            [ -d \"${line%%\\|*}\" ] && echo $line\n        done < \"$datafile\" | awk -v q=\"$2\" -F\"|\" '\n            BEGIN {\n                if( q == tolower(q) ) imatch = 1\n                q = substr(q, 3)\n                gsub(\" \", \".*\", q)\n            }\n            {\n                if( imatch ) {\n                    if( tolower($1) ~ tolower(q) ) print $1\n                } else if( $1 ~ q ) print $1\n            }\n        ' 2>/dev/null\n\n    else\n        # list/go\n        while [ \"$1\" ]; do case \"$1\" in\n            --) while [ \"$1\" ]; do shift; local fnd=\"$fnd${fnd:+ }$1\";done;;\n            -*) local opt=${1:1}; while [ \"$opt\" ]; do case ${opt:0:1} in\n                    c) local fnd=\"^$PWD $fnd\";;\n                    h) echo \"${_Z_CMD:-z} [-chlrtx] args\" >&2; return;;\n                    x) sed -i -e \"\\:^${PWD}|.*:d\" \"$datafile\";;\n                    l) local list=1;;\n                    r) local typ=\"rank\";;\n                    t) local typ=\"recent\";;\n                esac; opt=${opt:1}; done;;\n             *) local fnd=\"$fnd${fnd:+ }$1\";;\n        esac; local last=$1; [ \"$#\" -gt 0 ] && shift; done\n        [ \"$fnd\" -a \"$fnd\" != \"^$PWD \" ] || local list=1\n\n        # if we hit enter on a completion just go there\n        case \"$last\" in\n            # completions will always start with /\n            /*) [ -z \"$list\" -a -d \"$last\" ] && cd \"$last\" && return;;\n        esac\n\n        # no file yet\n        [ -f \"$datafile\" ] || return\n\n        local cd\n        cd=\"$(while read line; do\n            [ -d \"${line%%\\|*}\" ] && echo $line\n        done < \"$datafile\" | awk -v t=\"$(date +%s)\" -v list=\"$list\" -v typ=\"$typ\" -v q=\"$fnd\" -F\"|\" '\n            function frecent(rank, time) {\n                # relate frequency and time\n                dx = t - time\n                if( dx < 3600 ) return rank * 4\n                if( dx < 86400 ) return rank * 2\n                if( dx < 604800 ) return rank / 2\n                return rank / 4\n            }\n            function output(files, out, common) {\n                # list or return the desired directory\n                if( list ) {\n                    cmd = \"sort -n >&2\"\n                    for( x in files ) {\n                        if( files[x] ) printf \"%-10s %s\\n\", files[x], x | cmd\n                    }\n                    if( common ) {\n                        printf \"%-10s %s\\n\", \"common:\", common > \"/dev/stderr\"\n                    }\n                } else {\n                    if( common ) out = common\n                    print out\n                }\n            }\n            function common(matches) {\n                # find the common root of a list of matches, if it exists\n                for( x in matches ) {\n                    if( matches[x] && (!short || length(x) < length(short)) ) {\n                        short = x\n                    }\n                }\n                if( short == \"/\" ) return\n                # use a copy to escape special characters, as we want to return\n                # the original. yeah, this escaping is awful.\n                clean_short = short\n                gsub(/\\[\\(\\)\\[\\]\\|\\]/, \"\\\\\\\\&\", clean_short)\n                for( x in matches ) if( matches[x] && x !~ clean_short ) return\n                return short\n            }\n            BEGIN {\n                gsub(\" \", \".*\", q)\n                hi_rank = ihi_rank = -9999999999\n            }\n            {\n                if( typ == \"rank\" ) {\n                    rank = $2\n                } else if( typ == \"recent\" ) {\n                    rank = $3 - t\n                } else rank = frecent($2, $3)\n                if( $1 ~ q ) {\n                    matches[$1] = rank\n                } else if( tolower($1) ~ tolower(q) ) imatches[$1] = rank\n                if( matches[$1] && matches[$1] > hi_rank ) {\n                    best_match = $1\n                    hi_rank = matches[$1]\n                } else if( imatches[$1] && imatches[$1] > ihi_rank ) {\n                    ibest_match = $1\n                    ihi_rank = imatches[$1]\n                }\n            }\n            END {\n                # prefer case sensitive\n                if( best_match ) {\n                    output(matches, best_match, common(matches))\n                } else if( ibest_match ) {\n                    output(imatches, ibest_match, common(imatches))\n                }\n            }\n        ')\"\n        [ $? -gt 0 ] && return\n        [ \"$cd\" ] && cd \"$cd\"\n    fi\n}\n\nalias ${_Z_CMD:-z}='_z 2>&1'\n\n[ \"$_Z_NO_RESOLVE_SYMLINKS\" ] || _Z_RESOLVE_SYMLINKS=\"-P\"\n\nif compctl >/dev/null 2>&1; then\n    # zsh\n    [ \"$_Z_NO_PROMPT_COMMAND\" ] || {\n        # populate directory list, avoid clobbering any other precmds.\n        if [ \"$_Z_NO_RESOLVE_SYMLINKS\" ]; then\n            _z_precmd() {\n                _z --add \"${PWD:a}\"\n            }\n        else\n            _z_precmd() {\n                _z --add \"${PWD:A}\"\n            }\n        fi\n        [[ -n \"${precmd_functions[(r)_z_precmd]}\" ]] || {\n            precmd_functions[$(($#precmd_functions+1))]=_z_precmd\n        }\n    }\n    _z_zsh_tab_completion() {\n        # tab completion\n        local compl\n        read -l compl\n        reply=(${(f)\"$(_z --complete \"$compl\")\"})\n    }\n    compctl -U -K _z_zsh_tab_completion _z\nelif complete >/dev/null 2>&1; then\n    # bash\n    # tab completion\n    complete -o filenames -C '_z --complete \"$COMP_LINE\"' ${_Z_CMD:-z}\n    [ \"$_Z_NO_PROMPT_COMMAND\" ] || {\n        # populate directory list. avoid clobbering other PROMPT_COMMANDs.\n        grep \"_z --add\" <<< \"$PROMPT_COMMAND\" >/dev/null || {\n            PROMPT_COMMAND=\"$PROMPT_COMMAND\"$'\\n''_z --add \"$(command pwd '$_Z_RESOLVE_SYMLINKS' 2>/dev/null)\" 2>/dev/null;'\n        }\n    }\nfi\n"
        }
      ]
    }
  ]
}