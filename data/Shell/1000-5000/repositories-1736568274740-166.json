{
  "metadata": {
    "timestamp": 1736568274740,
    "page": 166,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "007revad/Synology_HDD_db",
      "stars": 2871,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.1318359375,
          "content": "# Common settings that generally should always be used with your language specific settings\n\n# Auto detect text files and perform LF normalization\n*          text=auto\n\n#\n# The above will handle all files NOT found below\n#\n\n# Documents\n*.bibtex   text diff=bibtex\n*.doc      diff=astextplain\n*.DOC      diff=astextplain\n*.docx     diff=astextplain\n*.DOCX     diff=astextplain\n*.dot      diff=astextplain\n*.DOT      diff=astextplain\n*.epub     diff=astextplain\n*.pdf      diff=astextplain\n*.PDF      diff=astextplain\n*.rtf      diff=astextplain\n*.RTF      diff=astextplain\n*.md       text diff=markdown\n*.mdx      text diff=markdown\n*.tex      text diff=tex\n*.adoc     text\n*.textile  text\n*.mustache text\n*.tab      text\n*.tsv      text\n*.txt      text eol=lf\n*.sql      text\n*.csv      text eol=crlf\n\n# Graphics\n*.png      binary\n*.jpg      binary\n*.jpeg     binary\n*.gif      binary\n*.tif      binary\n*.tiff     binary\n*.ico      binary\n*.eps      binary\n# SVG treated as text by default.\n*.svg      text\n# If you want to treat it as binary,\n# use the following line instead.\n# *.svg    binary\n\n# Scripts\n*.bash     text eol=lf\n*.fish     text eol=lf\n*.ksh      text eol=lf\n*.py       text eol=lf\n*.php      text eol=lf\n*.sh       text eol=lf\n*.zsh      text eol=lf\n# These are explicitly windows files and should use crlf\n*.bat      text eol=crlf\n*.cmd      text eol=crlf\n*.ps1      text eol=crlf\n\n# Visual Dialog Script\n*.dsc      text eol=crlf\n*.dsp      text eol=crlf\n\n# Config files\n*.ini      text eol=crlf\n*.conf     text eol=lf\n\n# Serialisation\n*.json     text\n*.toml     text\n*.xml      text\n*.yaml     text\n*.yml      text\n\n# Archives\n*.7z       binary\n*.bz       binary\n*.bz2      binary\n*.bzip2    binary\n*.gz       binary\n*.lz       binary\n*.lzma     binary\n*.rar      binary\n*.tar      binary\n*.taz      binary\n*.tbz      binary\n*.tbz2     binary\n*.tgz      binary\n*.tlz      binary\n*.txz      binary\n*.xz       binary\n*.Z        binary\n*.zip      binary\n*.zst      binary\n\n# Text files where line endings should be preserved\n*.patch    -text\n\n#\n# Exclude files from exporting\n#\n\n.gitattributes export-ignore\n.gitignore     export-ignore\n.gitkeep       export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGES.txt",
          "type": "blob",
          "size": 17.646484375,
          "content": "v3.6.110\n- Bug fix for not finding SAS expansion units. Issue #413\n\nv3.6.109\n- Added -I, --ihm option to update IronWolf Health Management to 2.5.1 to support recent model IronWolf and IronWolf Pro drives.\n  - For NAS with x86_64 CPUs only.\n  - Installs IronWolf Health Management on '22 series and newer models that don't have IronWolf Health Management (untested).\n\nv3.5.108\n- Prevent error message if /tmpRoot exists but does not contain /usr/syno/bin/synosetkeyvalue and /etc.defaults/synoinfo.conf. Issue #411\n\nv3.5.107\n- Bug fix for firmware version as \"Found]\" in db files. Issue #407\n\nv3.5.106\n- Bug fix for when script is not located on a volume. Issue #397\n\nv3.5.105\n- Bug fix for drives that return \"HCST <model>\" as the model, like HGST drives do. Issue #389\n\nv3.5.104\n- Some disks will be blocked in special scenarios. PR #387\n\nv3.5.103\n- Bug fix getting size of large drives. Issue #368\n  - Run the script once with the --restore option to undue the previous changes then run the script as normal.\n\nv3.5.102\n- Changed to use a faster method of detecting if an expansion unit is connected, for models with the syno_slot_mapping command.\n- Changed so XPE users using the hdddb addon don't need to reboot.\n\nv3.5.101\n- Changed to support \"--restore --ssd=restore\" to restore write_mostly when restoring all other changes. Issue #340\n  - When using --restore you can also use --ssd=restore, -e or --email\n\nv3.5.98\n- Changed to automatically download and install dtc if all of the following 4 conditions are met:\n    1. dtc is not already installed.\n    2. /bin/dtc or dtc are not in the same folder as the script.\n    3. The script needs dtc.\n    4. The script is running from task scheduler.\n- Bug fix for \"Enable write_mostly on slow internal drives so DSM runs from the fast internal drive(s).\" Issue #340\n- Improved output to make it clear which drive(s) have most_writely set.\n\nv3.5.97\n- Changed silently skip empty .db.new files with showing an error. Issue #175\n- Changed to warn if db file is 0 bytes.\n\nv3.5.96\n- Added option to set write_mostly for your internal HDDs so DSM will normally read from your faster internal SSD(s).\n    - It can automatically set DSM to read from your internal SSDs.\n    - Or you can tell the script which internal drive(s) DSM should read from.\n\nThanks to Xeroxxx for the writemostly suggestion and their writeup here: \nhttps://www.techspark.de/speed-up-synology-dsm-with-hdd-ssd/\n\nv3.5.94\n- Updated to support newer drive db versions.\n  - Synology added size_gb in a recent host v7 version (in SynoOfflinePack 764).\n  - Synology added barebone_installable_v2 in the latest host v7 version (in SynoOfflinePack 787).\n- Bug fix when restoring where memcheck service was only re-enabled on DVA models.\n- Changed to add leading 0 to short vids reported by drive.\n  - Sets 2 vids in case DSM uses the short one (e.g. 0x05dc=brand and 0x5dc=brand).\n\nNote: You may need to run syno_hdd_db without the -n or --noupdate option, then update the drive database from\n\"Storage Manager > HDD/SSD > Settings > Advanced > Update Now\" then run syno_hdd_db with your preferred options.\n\nv3.5.93\n- Bug fix for false \"Failed to delete tmp files\" log entries when script updates itself. Issue #312\n  - Bug first appeared in v3.1.64\n\nv3.5.92\n- Changed to support M.2 SATA SSDs in M2D18 or M2D17.\n- Change -s, --show option to show changes for each different drive model.\n\nv3.5.91\n- Changed to not exit if no SATA or SAS drives found. Issue #303\n  - Now only exits if no SATA, SAS or NVMe drives found.\n\nv3.5.90\n- Changed to enable creating storage pools/volumes on NVMe drives in a PCIe M.2 adaptor in DSM 7.2\n  - Previously only supported DSM 7.2.1\n- Changed to enable creating storage pools/volumes on NVMe drives in a PCIe M.2 adaptor even if PCIe M.2 adaptor not found.\n  - This may allow creating NVMe volumes on 3rd party PCIe M.2 adaptors.\n- Bug fix for when there's multiple expansion unit models only the last expansion unit was processed. Issue #288\n- Bug fix for when there's multiple M2 adaptor card models only the last M2 card was processed. \n- Bug fix for incorrectly matching model name variations as well as the exact model name. \n  - e.g. RX1217 matched RX1217, RX1217rp and RX1217sas.\n\nv3.5.89\n- Bug fix for -s, --showedits option with multiple of the same drive model but with different firmware versions. Issue #276\n\nv3.5.88\n- Changed how memory compatibility is disabled for older models. Issue #272\n\nv3.4.87\n- Fix Invalid json format syslog output #270\n\nv3.4.86\n- Hard coded /usr/syno/bin/<command> for Synology commands (to prevent $PATH issues). #249 \n\nv3.4.84\n- Bug fix when script updates itself and user ran the script from ./scriptname.sh\n\nv3.4.83\n- Fix for drives that exist in the drive database already but have \"compatibility not_support\".\n  - Affected drives were showing as \"Incompatible\" in storage manager.\n  - Need to use the -i or --incompatible option.\n\nv3.4.82\n- Fix for drives that exist in the drive database already but have \"compatibility unverified\". Issue #224\n  - Affected drives were showing as \"Unverified\" in storage manager.\n\nv3.4.81\n- Bug fix for false \"This script is NOT running on a Synology NAS!\" if uname is installed from Entware. Issue #218\n\nv3.4.80\n- Bug fix for chmod failed on changes.txt\n- Improved help message.\n\nv3.4.78\n- Added check that script is running on Synology NAS.\n\nv3.4.77\n- Include smart_test_ignore and smart_attr_ignore in db files.\n- Now saves changes.txt as <script-filename>_changes.txt when updating the script.\n    - To not overwrite changes.txt if my other scripts are in the same folder.\n- Bug fix for detecting if script is located on M.2 drive.\n- Bug fix for error when -s or --showedits option was used. Issue #200\n- Minor bug fix.\n\nv3.3.73\n- Bug fix for vendor id.\n\nv3.3.72\n- Bug fix for enabling creating storage pools in Storage Manager for M.2 drives in PCIe adaptor cards. \n- Bug fix for not copying syno_hdd_db_vendors.txt to script location when script updates itself.\n- Bug fix for checking if script located on NVMe drive.\n\nv3.3.70\n- Now enables creating storage pools in Storage Manager for M.2 drives in PCIe adaptor cards:\n  - E10M20-T1, M2D20, M2D18 and M2D17.\n  - DSM 7.2.1 and above only.\n  - Script needs to run after each boot.\n- Added new vendor ids for Apacer, aigo, Lexar and Transcend NVMe drives.\n- Now includes syno_hdd_vendor.txt so users can add their NVMe drive's vendor id.\n   - syno_hdd_vendor.txt needs to be in the same folder as syno_hdd_db.sh\n- Now warns if script is located on an M.2 volume.\n\nv3.2.69\n- Added KIOXIA vendor id.\n- Bug fix for wrong version number, which caused an update loop.\n\nv3.2.68\n- Updated so E10M20-T1, M2D20, M2D18 and M2D17 now work in models that use device tree and are using:\n    - DSM 7.2 Update 2 and 3, 7.2.1, 7.2.1 Update 1, 2 and 3. Issue #132, #148\n- Now edits model.dtb instead of downloading a pre-edited version.\n- Improvements to --restore option.\n- Fix for Unknown vendor causing \"Unsupported firmware version\" warning. Issue #161\n- Now supports NVMe drives that show as Unknown brand in storage manager: Issue #161\n    - ADATA, Corsair, Gigabyte, HS/MAXIO, MSI, Netac, Phison, PNY\n    - SK Hynix, Solidigm, SPCC/Lexar, TEAMGROUP, UMIS, ZHITAI\n- Fixed bug where memory was shown in MB but with GB unit.\n- Removed -i, --immutable option.\n- Minor bug fixes.\n\nv3.1.65\n- Bug fix for NVMe drives with / in the model name for non-device tree Synology models. Issue #154\n\nv3.1.64\n- Added -e --email option to disable coloured output to make task scheduler emails easier to read.\n- Bug fix for script not updating itself if .sh file had been renamed.\n- Bug fix for missing executable permissions if .sh file had been renamed.\n- Bug fix to prevent update loop if script's .tar.gz file already exists in /tmp.\n- Bug fix to prevent update failing if script's temp folder already exists in /tmp.\n- Now only copies CHANGES.txt to script location if script is located on a volume, to prevent putting CHANGES.txt on system partition (/usr/bin, /usr/sbin, /root etc.)\n\nv3.1.63\n- Added support to disable unsupported memory warnings on DVA models. #136\n\nv3.1.62\n- Fixed bug where newly connected expansion units weren't found until up to 24 hours later. Issue #124\n\nv3.1.61\n- Added enabling E10M20-T1, M2D20 and M2D18 for DS1821+, DS1621+ and DS1520+.\n- Added enabling M2D18 for RS822RP+, RS822+, RS1221RP+ and RS1221+ for older DSM versions.\n- Fixed enabling E10M20-T1, M2D20 and M2D18 cards in models that don't officially support them.\n- Fixed bugs where the calculated amount of installed memory could be incorrect:\n    - If last memory socket was empty an invalid unit of bytes could be used. Issue #106\n    - When dmidecode returned MB for one ram module and GB for another ram module. Issue #107\n- Fixed bug displaying the max memory setting if total installed memory was less than the max memory. Issue #107\n- Fixed bug where sata1 drive firmware version was wrong if there was a sata10 drive.\n\nv3.0.56\n- Minor bug fix for checking amount of installed memory.\n\nv3.0.55\n- Now enables any installed Synology M.2 PCIe cards for models that don't officially support them.\n   - You can use a M2D20, M2D18, M2D17 or E10M20-T1 on any model with a PCIe slot (not Mini PCIe).\n- Now the script reloads itself after updating.\n- Added -i, --immutable option to enable immutable snapshots on models older than '20 series running DSM 7.2.\n- Added -w, --wdda option to disable WDDA (to prevent warnings when WD drives have been running more than 3 years).\n- Added \"You may need to reboot\" message when NVMe drives were detected.\n- Added --autoupdate=[age] option to auto update synology_hdd_db x days after new version released.\n    - Autoupdate logs update success or errors to DSM system log.\n- Changed help to show -r, --ram also sets max memory to the amount of installed memory.\n- Changed the \"No M.2 cards found\" to \"No M.2 PCIe cards found\" to make it clearer.\n- Changed to skip checking the amount of installed memory in DSM 6 (because it was never working in DSM 6).\n- Fixed HDD/SSD firmware versions always being 4 characters long (for DSM 7.2 and 6.2.4 Update 7).\n- Fixed detecting amount of installed memory (for DSM 7.2 which now reports GB instead of MB).\n- Fixed USB drives sometimes being detected as internal drives (for DSM 7.2).\n- Fixed error if /run/synostorage/disks/nvme0n1/m2_pool_support doesn't exist yet (for DSM 7.2).\n- Fixed drive db update still being disabled in /etc/synoinfo.conf after script run without -n or --noupdate option.\n- Fixed drive db update still being disabled in /etc/synoinfo.conf after script run with --restore option.\n- Fixed permissions on restored files being incorrect after script run with --restore option.\n- Fixed permissions on backup files.\n\nv2.2.47\n- Updated reboot info in readme.\n- Added reboot message for DSM 7.\n- Bug fix for issue #77 (escape slashes in drive model name).\n- Added error sound.\n\nv2.2.45\n- Minor bug fix.\n\nv2.2.44\n- Added --restore info to --help\n- Updated restore option to download the latest db files from Synology.\n- Now warns you if you try to run it in sh with \"sh scriptname.sh\"\n\nv2.2.43\n- Fixed DSM 6 bug where the drives were being duplicated in the .db files each time the script was run.\n- Fixed DSM 6 bug where the .db files were being duplicated as .dbr each time the db files were edited.\n\nv2.2.42\n- Fixed bug where expansion units ending in RP or II were not detected.\n- Added a --restore option to undo all changes made by the script.\n- Now looks for and edits both v7 and non-v7 db files to solve issue #11 for RS '21 models running DSM 6.2.4. This will also ensure the script still works if:\n    - Synology append different numbers to the db file names in DSM 8 etc.\n    - The detected NAS model name does not match the .db files' model name.\n- Now backs up the .db.new files (as well as the .db files).\n- Now shows max memory in GB instead of MB.\n- Now shows status of \"Support disk compatibility\" setting even if it wasn't changed.\n- Now shows status of \"Support memory compatibility\" setting even if it wasn't changed.\n\nv2.1.38\n- Improved shell output when editing max memory setting.\n- Changed method of checking if drive is a USB drive to prevent ignoring internal drives on RS models.\n- Changed to not run \"synostgdisk --check-all-disks-compatibility\" in DSM 6.2.3 (which has no synostgdisk).\n\nv2.1.37\n- Now edits max supported memory to match the amount of memory installed, if installed memory is greater than the current max memory setting.\n- Minor improvements.\n\nv2.0.36\n- Show the options used.\n- Thank you to Gummibando on reddit for their donation.\n\nv2.0.35\n- Now allows creating M.2 storage pool and volume all from Storage Manager.\n\nv1.3.34\n- Now always shows your drive entries in the host db file if -s or --showedits used instead of only if db file was edited during that run.\n- Changed to show usage if invalid long option used instead of continuing.\n\nv1.3.33\n-  Fixed bug inserting firmware version for already existing model.\n\nv1.3.32\n- Changed to add drives' firmware version to the db files (to support data deduplication).\n    - See https://github.com/007revad/Synology_enable_Deduplication\n- Changed to be able to edit existing drive entries in the db files to add the firmware version.\n- Now supports editing db files that don't currently have any drives listed.\n\nv1.2.31\n- Bug fix. The --noupdate option was coded as --nodbupdate. Now either will work.\n- Bug fix. Re-enable drive db updates wasn't working in some instances.\n\nv1.2.30\n- Fixed \"download new version\" failing if script was run via symlink or ./<scriptname>\n\nv1.2.29\n- Bug fix. v1.2.28 had v1.2.27 in the sh file so it always wanted to update!\n\nv1.2.28\n- Fixed bug in getting the M.2 card model.\n\nv1.2.27\n- Changed 'latest version check' to download and extract to /tmp then copy only the syno_hdd_db.sh and readme.txt files to the currrently running script's location.\n- Minor tweaks to the shell output.\n\nv1.2.25\n- Minor bug fix.\n\nv1.2.24\n- Bug fix. Ignoring removable drives was ignoring all drives in DSM 7 on a RS2421rp+. Fix issue #23.\n\nv1.2.23\n- Changed to show if no M.2 cards were found, if M.2 drives were found.\n\nv1.2.22\n- Changed 'latest version check' to download to /tmp and extract files to the script's location to fix issue #27.\n\nv1.2.21\n- Reinstated removing brand from start of drive model to fix issue #24.\n\nv1.2.20\n- Added a timeouts when checking for newer script version in case github is down or slow to fix issue #25.\n- Fixed change log (v1.2.19 and v1.2.18 were listed as v2.2.19 and v2.2.19).\n\nv1.2.19\n- Minor change to check new version code.\n\nv1.2.18\n- Minor shell output formatting fix.\n\nv1.2.17\n- Added disable support memory compatibility option --ram or -r\n\nv1.2.16\n- Changed to show the script version, Synology model and DSM version on each run to make it easier to debug any user's issues.\n\nv1.2.15\n- Now finds your expansion units' model numbers and adds your drives to their db files.\n- Now adds your M.2 drives to your M.2 PCI card's db files (supports M2Dxx and E10M20-T1 and future models with similar model names).\n- Improved flags/options checking and added usage help (-h or --help) and version info (-v or --version).\n- Can now download the latest script version for you (if you have 'user home service' enabled in DSM).\n- Now adds 'support_m2_pool=\"yes\"' line for models that don't have support_m2_pool in synoinfo.conf\n  - To (hopefully) prevent losing your SSH created M2 volume when running this script on models that DSM 7.2 Beta does not list as supported for creating M2 volumes.\n- Added removal of \" 00Y\" from end of Samsung/Lenovo SSDs to fix issue #13.\n- Changed Synology NAS model detection to be more reliable (for models that came in different variations and report extra text after model). issue #2 and issue #10\n- Changed checking drive_db_test_url setting to be more durable.\n- Fixed bug where removable drives were being added to the drive database.\n- Fixed bug where \"M.2 volume support already enabled\" message appeared when NAS had no M.2 drives.\n\nv1.1.14\n- Minor bug fix.\n\nv1.1.13\n- Fixed bug in v1.1.12 \"check that M.2 volume support is enabled\"\n\nv1.1.12\n- Added check that M.2 volume support is enabled.\n\nv1.1.11\n- Added support for M.2 SATA drives.\n- Can now skip processing M.2 drives by running script with the -m2 flag.\n- Changed method of getting drive and firmware version so script is faster and easier to maintain. No longer using smartctl or hdparm.\n- Changed SAS drive firmware version detection to support SAS drives that hdparm doesn't work with.\n- Removed error message and aborting if *.db.new not found (clean DSM installs don't have a *.db.new).\n- Fixed script version check introduced in 1.0.7.\n\nv1.1.10\n- Now makes DSM recheck disk compatibility so reboot not needed (DSM 7 only).\n- Fixed DSM 6 bug when DSM 6 used the old db file format.\n\nv1.1.9\n- Added support for SAS drives.\n- Now gets HDD/SSD/SAS drive model number with smartctl instead of hdparm.\n\nv1.1.8\n- Now prevents DSM auto updating the drive database.\n- Disable \"support_disk_compatibility\" (that was added in v1.0.6) is now optional.\n  - Run script with -f or -force to disable \"support_disk_compatibility\".\n  - If run without -f or -force \"support_disk_compatibility\" is re-enabled.\n\nv1.0.7\n- Added message if newer script version is available.\n\nv1.0.6\n- Added 2nd method of disabling disk compatibility to solve issue #1 and #4 for the few people where the original method didn't work.\n\nv1.0.5\n- Changed to avoid issue #2\n\nv1.0.4\n- Now backs up the database file if there is no backup already.\n\nv1.0.3\nChanged to avoid avoid error messages from previous change to search for sda and sata# drives in DSM 6 and DSM 7.\n- /dev/sata*: No such file or directory\n- /dev/sd*: No such file or directory\n\nv1.0.2\n- Improved formatting when listing found drives.\n\nv1.0.1\n- Fixed issue where drives weren't detected if:\n  - NAS had been updated from DSM 6 to DSM 7 and still used sda, sdb etc.\n  - Models like the DVA3219 that use sata# even in DSM 6.\n\nv1.0.0\n- Initial release.\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2023 007revad\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.9716796875,
          "content": "# Synology HDD db\n\n<a href=\"https://github.com/007revad/Synology_HDD_db/releases\"><img src=\"https://img.shields.io/github/release/007revad/Synology_HDD_db.svg\"></a>\n<a href=\"https://hits.seeyoufarm.com\"><img src=\"https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2F007revad%2FSynology_HDD_db&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=views&edge_flat=false\"/></a>\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/paypalme/007revad)\n[![](https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=%23fe8e86)](https://github.com/sponsors/007revad)\n[![committers.top badge](https://user-badge.committers.top/australia/007revad.svg)](https://user-badge.committers.top/australia/007revad)\n<!-- [![committers.top badge](https://user-badge.committers.top/australia_public/007revad.svg)](https://user-badge.committers.top/australia_public/007revad) -->\n<!-- [![committers.top badge](https://user-badge.committers.top/australia_private/007revad.svg)](https://user-badge.committers.top/australia_private/007revad) -->\n<!-- [![Github Releases](https://img.shields.io/github/downloads/007revad/synology_hdd_db/total.svg)](https://github.com/007revad/Synology_HDD_db/releases) -->\n\n### Description\n\nAdd your SATA or SAS HDDs and SSDs plus SATA and NVMe M.2 drives to your Synology's compatible drive databases, including your Synology M.2 PCIe card and Expansion Unit databases. \n\nThe script works in DSM 7, including DSM 7.2, and DSM 6.\n\nIt also has a restore option to undo all the changes made by the script.\n\n#### What the script does:\n\n* Gets the Synology NAS model and DSM version (so it knows which db files to edit).\n* Gets a list of the HDD, SSD, SAS and NVMe drives installed in your Synology NAS.\n* Gets each drive's model number and firmware version.\n* Backs up the database files if there is no backup already.\n* Checks if each drive is already in the Synology's compatible-drive database.\n* Adds any missing drives to the Synology's compatible-drive database.\n* Optionally prevents DSM auto updating the drive database.\n* Optionally disable DSM's \"support_disk_compatibility\".\n* Optionally disable DSM's \"support_memory_compatibility\" to prevent <a href=images/ram_warning.png/>non-Synology memory notifications</a>.\n* Optionally edits max supported memory to match the amount of memory installed, if installed memory is greater than the current max memory setting.\n    * DSM only uses the max memory setting when calculating the reserved RAM area size for SSD caches.\n* Optionally set write_mostly for your internal HDDs so DSM will normally read from your faster internal SSD(s).\n    * It can automatically set DSM to read from your internal SSDs.\n    * Or you can tell the script which internal drive(s) DSM should read from.\n* Optionally disables Western Digital Device Analytics (aka WDDA) to prevent DSM showing a [warning for WD drives that are 3 years old](https://arstechnica.com/gadgets/2023/06/clearly-predatory-western-digital-sparks-panic-anger-for-age-shaming-hdds).\n    * DSM 7.2.1 already has WDDA disabled.\n* Enables M2D20, M2D18, M2D17 and E10M20-T1 if present on Synology NAS that don't officially support them.\n    * Newer NAS models may also need [Synology_enable_M2_card](https://github.com/007revad/Synology_enable_M2_card)\n* Checks that M.2 volume support is enabled (on models that have M.2 slots or PCIe slots).\n* Enables creating M.2 storage pools and volumes from within Storage Manager in DSM 7.2 and later **(newer models only?)**.\n    * Including M.2 drives in PCIe adaptor cards like M2D20, M2D18, M2D17 and E10M20-T1 for DSM 7.2 and above **(schedule the script to run boot)**.\n* Optionally update IronWolf Health Monitor to v2.5.1 to support recent model IronWolf and IronWolf Pro drives. **(NAS with x86_64 CPUs only)**.\n    * Installs IronWolf Health Management on '22 series and newer models that don't have IronWolf Health Management **(untested)**.\n* Makes DSM recheck disk compatibility so rebooting is not needed if you don't have M.2 drives (DSM 7 only).\n    * **If you have M.2 drives you may need to reboot.**\n    * Reminds you that you may need to reboot the Synology after running the script.\n* Checks if there is a newer version of this script and offers to download it for you.\n  * The new version available messages time out so they don't prevent the script running if it is scheduled to run unattended.\n\n### Download the script\n\n1. Download the latest version _Source code (zip)_ from https://github.com/007revad/Synology_HDD_db/releases\n2. Save the download zip file to a folder on the Synology.\n    - Do ***NOT*** save the script to a M.2 volume. After a DSM or Storage Manager update the M.2 volume won't be available until after the script has run.\n3. Unzip the zip file.\n\nOr via SSH as your regular user:\n```\ncd $HOME\nwget https://github.com/007revad/Synology_HDD_db/archive/refs/heads/main.zip -O syno_hdd_db.zip\n7z x syno_hdd_db.zip\ncd Synology_HDD_db-main && ls -ali\n```\n\n### Required files\n\nThe following files from the downloaded zip file must be in the same folder:\n\n1. syno_hdd_db.sh\n2. syno_hdd_vendor_ids.txt\n3. dtc or the bin folder containing dtc (only required if you have a E10M20-T1, M2D20 or M2D18 in a NAS that does not support them).\n\n### When to run the script\n\nYou would need to re-run the script after a DSM update. If you have DSM set to auto update the best option is to run the script every time the Synology boots, and the best way to do that is to <a href=how_to_schedule.md/>setup a scheduled task</a> to run the the script at boot-up.\n\n**Note:** After you first run the script you may need to reboot the Synology to see the effect of the changes.\n\n### Options when running the script <a name=\"options\"></a>\n\nThere are optional flags you can use when running the script:\n```YAML\n  -s, --showedits       Show edits made to <model>_host db and db.new file(s)\n  -n, --noupdate        Prevent DSM updating the compatible drive databases\n  -r, --ram             Disable memory compatibility checking (DSM 7.x only)\n                        and sets max memory to the amount of installed memory\n  -f, --force           Force DSM to not check drive compatibility\n                        Do not use this option unless absolutely needed\n  -i, --incompatible    Change incompatible drives to supported\n                        Do not use this option unless absolutely needed\n  -w, --wdda            Disable WD Device Analytics to prevent DSM showing\n                        a false warning for WD drives that are 3 years old\n                          DSM 7.2.1 already has WDDA disabled\n  -p, --pcie            Enable creating volumes on M2 in unknown PCIe adaptor\n  -e, --email           Disable colored text in output scheduler emails\n  -S, --ssd=DRIVE       Enable write_mostly on slow internal drives so DSM \n                        runs from the fast internal drive(s).\n                          -S automatically sets internal SSDs as DSM preferred\n                          --ssd=DRIVE requires the fast drive(s) as argument,\n                          or restore as the argument to reset drives to default\n                          --ssd=sata1 or --ssd=sata1,sata2 or --ssd=sda etc\n                          --ssd=restore\n      --restore         Undo all changes made by the script (except -S --ssd)\n      --autoupdate=AGE  Auto update script (useful when script is scheduled)\n                          AGE is how many days old a release must be before\n                          auto-updating. AGE must be a number: 0 or greater\n  -I, --ihm             Update IronWolf Health Monitor to 2.5.1 to support\n                        recent model IronWolf and IronWolf Pro drives\n  -h, --help            Show this help message\n  -v, --version         Show the script version\n\n  -s, --showedits       Show edits made to <model>_host db and db.new file(s)\n  -n, --noupdate        Prevent DSM updating the compatible drive databases\n  -r, --ram             Disable memory compatibility checking (DSM 7.x only)\n                        and sets max memory to the amount of installed memory\n  -f, --force           Force DSM to not check drive compatibility\n                        Do not use this option unless absolutely needed\n  -i, --incompatible    Change incompatible drives to supported\n                        Do not use this option unless absolutely needed\n  -w, --wdda            Disable WD Device Analytics to prevent DSM showing\n                        a false warning for WD drives that are 3 years old\n                          DSM 7.2.1 and later already has WDDA disabled\n  -p, --pcie            Enable creating volumes on M2 in unknown PCIe adaptor\n  -e, --email           Disable colored text in output scheduler emails\n  -S, --ssd=DRIVE       Enable write_mostly on internal HDDs so DSM primarily \n                        reads from internal SSDs or your specified drives\n                          -S automatically sets internal SSDs as DSM preferred\n                          --ssd=DRIVE requires the fast drive(s) as argument,\n                          or restore as the argument to reset drives to default\n                          --ssd=sata1 or --ssd=sata1,sata2 or --ssd=sda etc\n                          --ssd=restore\n      --restore         Undo all changes made by the script (except -S --ssd)\n                        To restore all changes including write_mostly use\n                          --restore --ssd=restore\n      --autoupdate=AGE  Auto update script (useful when script is scheduled)\n                          AGE is how many days old a release must be before\n                          auto-updating. AGE must be a number: 0 or greater\n  -I, --ihm             Update IronWolf Health Management to 2.5.1 to support\n                        recent model IronWolf and IronWolf Pro drives.\n                        For NAS with x86_64 CPUs only.\n                        Installs IHM on '22 series and newer models (untested)\n  -h, --help            Show this help message\n  -v, --version         Show the script version\n```\n\n**Notes:** \n- The -f or --force option is only needed if for some reason your drives still show as unsupported in storage manager.\n    - Only use this option as last resort.\n    - Using this option will prevent data deduplication from being available, and prevent firmware updates on Synology brand drives.\n- If you have some Synology drives and want to update their firmware run the script **without** --noupdate or -n then do the drive database update from Storage Manager and finally run the script again with your preferred options.\n\n### Scheduling the script in Synology's Task Scheduler\n\nSee <a href=how_to_schedule.md/>How to schedule a script in Synology Task Scheduler</a>\n\n### Running the script via SSH\n\n[How to enable SSH and login to DSM via SSH](https://kb.synology.com/en-global/DSM/tutorial/How_to_login_to_DSM_with_root_permission_via_SSH_Telnet)\n\nYou run the script in a shell with sudo -s or as root.\n\n```YAML\nsudo -s /path-to-script/syno_hdd_db.sh -nr\n```\n\n**Note:** Replace /path-to-script/ with the actual path to the script on your Synology.\n\n<p align=\"left\"><img src=\"images/syno_hdd_db1.png\"></p>\n\nIf you run the script with the --showedits flag it will show you the changes it made to the Synology's compatible-drive database. Obviously this is only useful if you run the script in a shell.\n\n```YAML\nsudo -s /path-to-script/syno_hdd_db.sh -nr --showedits\n```\n\n**Note:** Replace /path-to-script/ with the actual path to the script on your Synology.\n\n<p align=\"left\"><img src=\"images/syno_hdd_db.png\"></p>\n\n### Troubleshooting\n\n| Issue | Cause | Solution |\n|-------|-------|----------|\n| /usr/bin/env: ‘bash\\r’: No such file or directory | File has Mac line endings! | [Download latest zip file](https://github.com/007revad/Synology_HDD_db/releases) |\n| Cursor sits there doing nothing | File has Windows line endings! | [Download latest zip file](https://github.com/007revad/Synology_HDD_db/releases) |\n| syntax error near unexpected token | You downloaded the webpage! | [Download latest zip file](https://github.com/007revad/Synology_HDD_db/releases) |\n\nIf you get a \"No such file or directory\" error check the following:\n\n1. Make sure you downloaded the zip or rar file to a folder on your Synology (not on your computer).\n2. Make sure you unpacked the zip or rar file that you downloaded and are trying to run the syno_hdd_db.sh file.\n3. If the path to the script contains any spaces you need to enclose the path/scriptname in double quotes:\n   ```YAML\n   sudo -s \"/volume1/my scripts/syno_hdd_db.sh -n\"\n   ```\n4. Set the script file as executable:\n   ```YAML\n   sudo chmod +x \"/volume1/scripts/syno_hdd_db.sh\"\n   ```\n\n\n### vendor_ids.txt\n\nYou only need to edit syno_hdd_vendor_ids.txt if the script warns you about a missing vendor id.\n\nIf DSM doesn't know the brand of your NVMe drives they will show up in Storage Manager as Unknown brand, and Unrecognised firmware version.\n\n<p align=\"left\"><img src=\"images/unknown.png\"></p>\n\nIn this case the script will show you the vendor ID and advise you to add it to the syno_hdd_vendor_ids.txt file.\n\n<p align=\"left\"><img src=\"images/vendor_ids.png\"></p>\n\n<br>\n\n### Credits\n\n- The idea for this script came from a comment made by Empyrealist on the Synology subreddit.\n- Thanks for the assistance from Alex_of_Chaos on the Synology subreddit.\n- Thanks to dwabraxus and aferende for help detecting connected expansion units.\n- Thanks to bartoque on the Synology subreddit for the tip on making the script download the latest release from GitHub.\n- Thanks to nicolerenee for pointing out the easiest way to enable creating M.2 storage pools and volumes in Storage Manager.\n- Thanks to Xeroxxx for the writemostly suggestion and their writeup here: https://www.techspark.de/speed-up-synology-dsm-with-hdd-ssd/\n\n### Donators\n\nThank you to the PayPal and Buy Me a Coffee donators, GitHub sponsors and hardware donators\n\n|  |  |  |  | \n|--------------------|--------------------|----------------------|----------------------|\n|  |  | Will (war59312) | Christopher Maglio |\n| Flow | Jake Morrison | tsnyder | zhangchi198 | \n| leadadri | Gary Plumbridge | frogger1805 | ctrlaltdelete | \n| CannotTouch | Kevin Staude | Alistair Hathaway | 8347 | \n| BrattishPlaque | Chris Bunnell | dansimau | Bsih | \n| Tim Trace | Michel VIEUX-PERNON | R De Jong | Rick | \n| Klaus-Dieter Fahlbusch | Amarand Agasi | someone61986 | Alexander Machatschek | \n| Yeong​Nuno | Joe | Torben Schreiter | Anthony McMurray | \n| Abhishek | Steven Haskell | Malte Müller | Aaron Thomas | \n| DENNIS BRAZIL | kunvanimals | Arnaud Costermans | dealchecker |\n| Michael Carras | Alan | speedyyyyyy | Jordi Chavarria Fibla |\n| Qwerty.xyz | Max | Mark Rohde | Someone |\n| vaadmin | Sebastiaan Mulder | Nico Stark | Oleksandr Antonishak |\n| Marcel Siemienowski | Dave Smart | dweagle79 | lingyinsam | \n| Vojtech Filkorn | Craig Sadler | Po-Chia Chen | Jean-François Fruhauf |\n| Sven 'ctraltdelete' | Thomas Horn | Christian | Simon Azzouni |\n| Lee Booy | Bünyamin Olgun | Hartmut Heinbach | Alexander Gundermann |\n| Björn Schöninger | Nico Scherer | Patrick Hoekstra | Alex Joyce |\n| Marcus Ackermann | Lorenz Schmid | enil-kil | Xaver Zöllner |\n| Jan Bublitz | Darren O'Connor | Charles Young | J Davis | \n| Jürg Baiker | Joshua Gillispie | bizIT Hirschberg | Jordan Crawford |\n| Tyler Teal | Voluntary Commerce LLC | Ez Hosting | Alec Wilhere |\n| Reece Lyne | Enric Escudé Santana | Yunhao Zhang | Matthias Gerhardt |\n| Darryl Harper | Mikescher | Matthias Pfaff | cpharada |\n| Neil Tapp | zen1605 | Kleissner Investments | Angel Scandinavia |\n| B Collins | Peter jackson | Mir Hekmat | Andrew Tapp |\n| Peter Weißflog | Joseph Skup | Dirk Kurfuerst | Gareth Locke |\n| Rory de Ruijter | Nathan O'Farrell | Harry Bos | Mark-Philipp Wolfger |\n| Filip Kraus | John Pham | Alejandro Bribian Rix | Daniel Hofer |\n| Bogdan-Stefan Rotariu | Kevin Boatswain | anschluss-org | Yemeth |\n| Patrick Thomas | Manuel Marquez Corral | Evrard Franck | Chad Palmer |\n| 侯​永政 | CHEN​HAN-YING | Eric Wells | Massimiliano Pesce |\n| JasonEMartin | Gerrit Klussmann | Alain Aube | Robert Kraut |\n| Charles-Edouard Poisnel | Oliver Busch | anonymous donors | private sponsors |\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "how_to_schedule.md",
          "type": "blob",
          "size": 1.3232421875,
          "content": "# How to schedule a script in Synology Task Scheduler\n\nTo schedule a script to run on your Synology at boot-up or shut-down follow these steps:\n\n**Note:** You can setup a schedule task and leave it disabled, so it only runs when you select the task in the Task Scheduler and click on the Run button.\n\n1. Go to **Control Panel** > **Task Scheduler** > click **Create** > and select **Triggered Task**.\n2. Select **User-defined script**.\n3. Enter a task name.\n4. Select **root** as the user (The script needs to run as root).\n5. Select **Boot-up** as the event that triggers the task.\n6. Leave **Enable** ticked.\n7. Click **Task Settings**.\n8. Optionally you can tick **Send run details by email** and **Send run details only when the script terminates abnormally** then enter your email address.\n9. In the box under **User-defined script** type the path to the script. \n    - e.g. If you saved the script to a shared folder on volume1 called \"scripts\" you'd type:\n    - **/volume1/scripts/syno_hdd_db.sh -nr --autoupdate=3**\n    - For information on the options see [Options](README.md#options)\n11. Click **OK** to save the settings.\n\nHere's some screenshots showing what needs to be set:\n\n<p align=\"leftr\"><img src=\"images/schedule1.png\"></p>\n\n<p align=\"leftr\"><img src=\"images/schedule2.png\"></p>\n\n<p align=\"leftr\"><img src=\"images/schedule3-2.png\"></p>\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "my-other-scripts.md",
          "type": "blob",
          "size": 6.75,
          "content": "## All my scripts\n\n#### Contents\n- [Plex](#plex)\n- [Synology docker](#synology-docker)\n- [Synology recovery](#synology-recovery)\n- [Other Synology scripts](#other-synology-scripts)\n- [Synology hardware restrictions](#synology-hardware-restrictions)\n- [How To Guides](#how-to-guides)\n- [Synology dev](#synology-dev)\n##\n\n### Plex\n\n- **<a href=\"https://github.com/007revad/Synology_Plex_Backup\">Synology_Plex_Backup</a>**\n  - A script to backup Plex to a tgz file foror DSM 7 and DSM 6.\n  - Works for Plex Synology package and Plex in docker.\n\n- **<a href=\"https://github.com/007revad/Asustor_Plex_Backup\">Asustor_Plex_Backup</a>**\n  - Backup your Asustor's Plex Media Server settings and database.\n\n- **<a href=\"https://github.com/007revad/Linux_Plex_Backup\">Linux_Plex_Backup</a>**\n  - Backup your Linux Plex Media Server's settings and database.\n\n- **<a href=\"https://github.com/007revad/Plex_Server_Sync\">Plex_Server_Sync</a>**\n  - Sync your main Plex server database & metadata to a backup Plex server.\n  - Works for Synology, Asustor, Linux and supports Plex package or Plex in docker.\n\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n\n### Synology docker\n\n- **<a href=\"https://github.com/007revad/Synology_Docker_Export\">Synology_Docker_export</a>**\n  - Export all Synology Container Manager or Docker containers' settings as json files to your docker shared folder.\n\n- **<a href=\"https://github.com/007revad/Synology_ContainerManager_IPv6\">Synology_ContainerManager_IPv6</a>**\n  - Enable IPv6 for Container Manager's bridge network.\n\n- **<a href=\"https://github.com/007revad/ContainerManager_for_all_armv8\">ContainerManager_for_all_armv8</a>**\n  - Script to install Container Manager on a RS819, DS119j, DS418, DS418j, DS218, DS218play or DS118.\n \n- **<a href=\"https://github.com/007revad/Docker_Autocompose\">Docker_Autocompose</a>**\n  - Create .yml files from your docker existing containers.\n\n- **<a href=\"https://github.com/007revad/Synology_docker_cleanup\">Synology_docker_cleanup</a>**\n  - Remove orphan docker btrfs subvolumes and images in Synology DSM 7 and DSM 6.\n\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n\n### Synology recovery\n\n- **<a href=\"https://github.com/007revad/Synology_DSM_reinstall\">Synology_DSM_reinstall</a>**\n  - Easily re-install the same DSM version without losing any data or settings.\n\n- **<a href=\"https://github.com/007revad/Synology_Recover_Data\">Synology_Recover_Data</a>**\n  - A script to make it easy to recover your data from your Synology's drives using a computer.\n\n- **<a href=\"https://github.com/007revad/Synology_clear_drive_error\">Synology clear drive error</a>**\n  - Clear drive critical errors so DSM will let you use the drive.\n\n- **<a href=\"https://github.com/007revad/Synology_DSM_Telnet_Password\">Synology_DSM_Telnet_Password</a>**\n  - Synology DSM Recovery Telnet Password of the Day generator.\n \n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n\n### Other Synology scripts\n\n- **<a href=\"https://github.com/007revad/Synology_app_mover\">Synology_app_mover</a>**\n  - Easily move Synology packages from one volume to another volume.\n\n- **<a href=\"https://github.com/007revad/Video_Station_for_DSM_722\">Video_Station_for_DSM_722</a>**\n  - Script to install Video Station in DSM 7.2.2\n\n- **<a href=\"https://github.com/007revad/Synology_Config_Backup\">Synology_Config_Backup</a>**\n  - Backup and export your Synology DSM configuration.\n\n- **<a href=\"https://github.com/007revad/Synology_CPU_temperature\">Synology_CPU_temperature</a>**\n  - Get and log Synology NAS CPU temperature via SSH.\n\n- **<a href=\"https://github.com/007revad/Synology_SMART_info\">Synology_SMART_info</a>**\n  - Show Synology smart test progress or smart health and attributes.\n\n- **<a href=\"https://github.com/007revad/Synology_Cleanup_Coredumps\">Synology_Cleanup_Coredumps</a>**\n  - Cleanup memory core dumps from crashed processes.\n\n- **<a href=\"https://github.com/007revad/Synology_toggle_reset_button\">Synology_toggle_reset_button</a>**\n  - Script to disable or enable the reset button and show current setting.\n\n- **<a href=\"https://github.com/007revad/Synology_Download_Station_Chrome_Extension\">Synology_Download_Station_Chrome_Extension</a>**\n  - Download Station Chrome Extension.\n\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n\n### Synology hardware restrictions\n\n- **<a href=\"https://github.com/007revad/Synology_HDD_db\">Synology_HDD_db</a>**\n  - Add your SATA or SAS HDDs and SSDs plus SATA and NVMe M.2 drives to your Synology's compatible drive databases, including your Synology M.2 PCIe card and Expansion Unit databases.\n\n- **<a href=\"https://github.com/007revad/Synology_enable_M2_volume\">Synology_enable_M2_volume</a>**\n  - Enable creating volumes with non-Synology M.2 drives.\n  - Enable Health Info for non-Synology NVMe drives (not in DSM 7.2.1 or later).\n\n- **<a href=\"https://github.com/007revad/Synology_M2_volume\">Synology_M2_volume</a>**\n  - Easily create an M.2 volume on Synology NAS.\n\n- **<a href=\"https://github.com/007revad/Synology_enable_M2_card\">Synology_enable_M2_card</a>**\n  - Enable Synology M.2 PCIe cards in Synology NAS that don't officially support them.\n\n- **<a href=\"https://github.com/007revad/Synology_enable_eunit\">Synology_enable_eunit</a>**\n  - Enable an unsupported Synology eSATA Expansion Unit models.\n\n- **<a href=\"https://github.com/007revad/Synology_enable_Deduplication\">Synology_enable_Deduplication</a>**\n  - Enable deduplication with non-Synology SSDs and unsupported NAS models.\n\n- **<a href=\"https://github.com/007revad/Synology_SHR_switch\">Synology_SHR_switch</a>**\n  - Easily switch between SHR and RAID Groups, or enable RAID F1.\n\n- **<a href=\"https://github.com/007revad/Synology_enable_sequential_IO\">Synology_enable_sequential_IO</a>**\n  - Enables sequential I/O for your SSD caches, like DSM 6 had.\n\n- **<a href=\"https://github.com/007revad/Synology_Information_Wiki\">Synology_Information_Wiki</a>**\n  - Information about Synology hardware.\n\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n\n### How To Guides\n\n- **<a href=\"https://github.com/007revad/Synology_SSH_key_setup\">Synology_SSH_key_setup</a>**\n  - How to setup SSH key authentication for your Synology.\n\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n\n### Synology dev\n\n- **<a href=\"https://github.com/007revad/Download_Synology_Archive\">Download_Synology_Archive</a>**\n  - Download all or part of the Synology archive.\n\n- **<a href=\"https://github.com/007revad/ScriptNotify\">ScriptNotify</a>**\n  - DSM 7 package to allow your scripts to send DSM notifications.\n\n- **<a href=\"https://github.com/007revad/DTC_GUI_for_Windows\">DTC_GUI_for_Windows</a>**\n  - GUI for DTC.exe for Window.\n\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Back to Contents](#contents)\n"
        },
        {
          "name": "syno_hdd_db.sh",
          "type": "blob",
          "size": 84.6669921875,
          "content": "#!/usr/bin/env bash\n# shellcheck disable=SC1083,SC2054,SC2121,SC2207\n#--------------------------------------------------------------------------------------------------\n# Github: https://github.com/007revad/Synology_HDD_db\n# Script verified at https://www.shellcheck.net/\n#\n# To run in task manager as root (manually or scheduled):\n# /volume1/scripts/syno_hdd_db.sh  # replace /volume1/scripts/ with path to script\n#\n# To run in a shell (replace /volume1/scripts/ with path to script):\n# sudo -i /volume1/scripts/syno_hdd_db.sh\n#  or\n# sudo -i /volume1/scripts/syno_hdd_db.sh -showedits\n#  or\n# sudo -i /volume1/scripts/syno_hdd_db.sh -force -showedits\n#--------------------------------------------------------------------------------------------------\n# https://smarthdd.com/database/\n\n# RECENT CHANGES\n# Make DSM read md0 and md1 from SSD drive(s) if internal SSD and HDD are installed.\n# https://github.com/007revad/Synology_HDD_db/issues/318\n# https://www.techspark.de/speed-up-synology-dsm-with-hdd-ssd/\n# https://raid.wiki.kernel.org/index.php/Write-mostly\n\n# TODO\n# Enable SMART Attributes button on Storage Manager\n# disabled:e.healthInfoDisabled\n# enabled:e.healthInfoDisabled\n# /var/packages/StorageManager/target/ui/storage_panel.js\n\n\nscriptver=\"v3.6.110\"\nscript=Synology_HDD_db\nrepo=\"007revad/Synology_HDD_db\"\nscriptname=syno_hdd_db\n\n# Check BASH variable is bash\nif [ ! \"$(basename \"$BASH\")\" = bash ]; then\n    echo \"This is a bash script. Do not run it with $(basename \"$BASH\")\"\n    printf \\\\a\n    exit 1\nfi\n\n# Check script is running on a Synology NAS\nif ! /usr/bin/uname -a | grep -q -i synology; then\n    echo \"This script is NOT running on a Synology NAS!\"\n    echo \"Copy the script to a folder on the Synology\"\n    echo \"and run it from there.\"\n    exit 1\nfi\n\nding(){ \n    printf \\\\a\n}\n\nusage(){ \n    cat <<EOF\n$script $scriptver - by 007revad\n\nUsage: $(basename \"$0\") [options]\n\nOptions:\n  -s, --showedits       Show edits made to <model>_host db and db.new file(s)\n  -n, --noupdate        Prevent DSM updating the compatible drive databases\n  -r, --ram             Disable memory compatibility checking (DSM 7.x only)\n                        and sets max memory to the amount of installed memory\n  -f, --force           Force DSM to not check drive compatibility\n                        Do not use this option unless absolutely needed\n  -i, --incompatible    Change incompatible drives to supported\n                        Do not use this option unless absolutely needed\n  -w, --wdda            Disable WD Device Analytics to prevent DSM showing\n                        a false warning for WD drives that are 3 years old\n                          DSM 7.2.1 and later already has WDDA disabled\n  -p, --pcie            Enable creating volumes on M2 in unknown PCIe adaptor\n  -e, --email           Disable colored text in output scheduler emails\n  -S, --ssd=DRIVE       Enable write_mostly on internal HDDs so DSM primarily \n                        reads from internal SSDs or your specified drives\n                          -S automatically sets internal SSDs as DSM preferred\n                          --ssd=DRIVE requires the fast drive(s) as argument,\n                          or restore as the argument to reset drives to default\n                          --ssd=sata1 or --ssd=sata1,sata2 or --ssd=sda etc\n                          --ssd=restore\n      --restore         Undo all changes made by the script (except -S --ssd)\n                        To restore all changes including write_mostly use\n                          --restore --ssd=restore\n      --autoupdate=AGE  Auto update script (useful when script is scheduled)\n                          AGE is how many days old a release must be before\n                          auto-updating. AGE must be a number: 0 or greater\n  -I, --ihm             Update IronWolf Health Management to 2.5.1 to support\n                        recent model IronWolf and IronWolf Pro drives.\n                        For NAS with x86_64 CPUs only\n                        Installs IHM on '22 series and newer models (untested)\n  -h, --help            Show this help message\n  -v, --version         Show the script version\n\nEOF\n    exit 0\n}\n\n\nscriptversion(){ \n    cat <<EOF\n$script $scriptver - by 007revad\n\nSee https://github.com/$repo\nEOF\n    exit 0\n}\n\n\n# Save options used\nargs=(\"$@\")\n\n# Check for flags with getopt\nif options=\"$(getopt -o SIabcdefghijklmnopqrstuvwxyz0123456789 -l \\\n    ssd:,ihm,restore,showedits,noupdate,nodbupdate,m2,force,incompatible,ram,pcie,wdda,email,autoupdate:,help,version,debug \\\n    -- \"$@\")\"; then\n    eval set -- \"$options\"\n    while true; do\n        case \"$1\" in\n            -d|--debug)         # Show and log debug info\n                debug=yes\n                ;;\n            -e|--email)         # Disable colour text in task scheduler emails\n                color=no\n                ;;\n            --restore)          # Restore changes from backups\n                restore=yes\n                if $(echo \"${args[@]}\" | grep -q -- '--ssd=restore'); then\n                    ssd_restore=yes\n                fi\n                #break\n                ;;\n            -s|--showedits)     # Show edits done to host db file\n                showedits=yes\n                ;;\n            -S)                 # Enable writemostly for md0 and md1\n                ssd=yes\n                ;;\n            --ssd)              # Enable writemostly for md0 and md1\n                ssd=yes\n                if [[ ${2,,} == \"restore\" ]]; then\n                    ssd_restore=yes\n                else\n                    IFS=$','\n                    for d in $2; do ssds_writemostly+=(\"${d,,}\"); done\n                    unset IFS\n                fi\n                shift\n                ;;\n            -n|--nodbupdate|--noupdate)  # Disable disk compatibility db updates\n                nodbupdate=yes\n                ;;\n            -m|--m2)            # Don't add M.2 drives to db files\n                m2=no\n                ;;\n            -f|--force)         # Disable \"support_disk_compatibility\"\n                force=yes\n                ;;\n            -i|--incompatible)  # Change incompatible drives to supported\n                incompatible=yes\n                ;;\n            -r|--ram)           # Disable \"support_memory_compatibility\"\n                ram=yes\n                ;;\n            -w|--wdda)          # Disable \"support_wdda\"\n                wdda=no\n                ;;\n            -p|--pcie)          # Enable creating volumes on M2 in unknown PCIe adaptor\n                forcepci=yes\n                ;;\n            -I|--ihm)           # Update IronWolf Health Management\n                ihm=yes\n                ;;\n            --autoupdate)       # Auto update script\n                autoupdate=yes\n                if [[ $2 =~ ^[0-9]+$ ]]; then\n                    delay=\"$2\"\n                    shift\n                else\n                    delay=\"0\"\n                fi\n                ;;\n            -h|--help)          # Show usage options\n                usage\n                ;;\n            -v|--version)       # Show script version\n                scriptversion\n                ;;\n            --)\n                shift\n                break\n                ;;\n            *)                  # Show usage options\n                echo -e \"Invalid option '$1'\\n\"\n                usage \"$1\"\n                ;;\n        esac\n        shift\n    done\nelse\n    echo\n    usage\nfi\n\n\n# shellcheck disable=SC2317  # Don't warn about unreachable commands in this function\nPS4func() {\n    local lineno=\"$1\"\n    local i f=''\n    local c=\"\\033[0;36m\" y=\"\\033[0;33m\" n=\"\\033[0m\"\n    local d=$((${#FUNCNAME[@]}-2))\n\n    if [[ $lineno == 1 ]]\n    then lineno=0\n    fi\n\n    for ((i=d; i>0; i--))\n    do printf -v f \"%s%s()\" \"$f\" \"${FUNCNAME[i]}\"\n    done\n\n    printf \"$y%s:%04d$c%s$n \" \"${BASH_SOURCE[1]##*/}\" \"$lineno\" \"$f\"\n}\nif [[ $debug == \"yes\" ]]; then\n    PS4='\\r$(PS4func $LINENO)'\n    set -o xtrace\nfi\n\n\n# Shell Colors\nif [[ $color != \"no\" ]]; then\n    #Black='\\e[0;30m'   # ${Black}\n    Red='\\e[0;31m'      # ${Red}\n    #Green='\\e[0;32m'   # ${Green}\n    Yellow='\\e[0;33m'   # ${Yellow}\n    #Blue='\\e[0;34m'    # ${Blue}\n    #Purple='\\e[0;35m'  # ${Purple}\n    Cyan='\\e[0;36m'     # ${Cyan}\n    #White='\\e[0;37m'   # ${White}\n    Error='\\e[41m'      # ${Error}\n    Off='\\e[0m'         # ${Off}\nelse\n    echo \"\"  # For task scheduler email readability\nfi\n\n\n# Check script is running as root\nif [[ $( whoami ) != \"root\" ]]; then\n    ding\n    echo -e \"${Error}ERROR${Off} This script must be run as sudo or root!\"\n    exit 1\nfi\n\n# Get DSM major version\ndsm=$(/usr/syno/bin/synogetkeyvalue /etc.defaults/VERSION majorversion)\nif [[ $dsm -gt \"6\" ]]; then\n    version=\"_v$dsm\"\nfi\n\n# Get Synology model\nmodel=$(cat /proc/sys/kernel/syno_hw_version)\nmodelname=\"$model\"\n\n# Get CPU platform_name\nplatform_name=$(/usr/syno/bin/synogetkeyvalue /etc.defaults/synoinfo.conf platform_name)\n\n# Get CPU arch\narch=\"$(uname -m)\"\n\n\n# Show script version\n#echo -e \"$script $scriptver\\ngithub.com/$repo\\n\"\necho \"$script $scriptver\"\n\n# Get DSM full version\nproductversion=$(/usr/syno/bin/synogetkeyvalue /etc.defaults/VERSION productversion)\nbuildphase=$(/usr/syno/bin/synogetkeyvalue /etc.defaults/VERSION buildphase)\nbuildnumber=$(/usr/syno/bin/synogetkeyvalue /etc.defaults/VERSION buildnumber)\nsmallfixnumber=$(/usr/syno/bin/synogetkeyvalue /etc.defaults/VERSION smallfixnumber)\n\n# Show DSM full version and model\nif [[ $buildphase == GM ]]; then buildphase=\"\"; fi\nif [[ $smallfixnumber -gt \"0\" ]]; then smallfix=\"-$smallfixnumber\"; fi\necho \"$model $arch DSM $productversion-$buildnumber$smallfix $buildphase\"\n\n\n# Convert model to lower case\nmodel=${model,,}\n\n# Check for dodgy characters after model number\nif [[ $model =~ 'pv10-j'$ ]]; then  # GitHub issue #10\n    modelname=${modelname%??????}+  # replace last 6 chars with +\n    model=${model%??????}+          # replace last 6 chars with +\n    echo -e \"\\nUsing model: $model\"\nelif [[ $model =~ '-j'$ ]]; then  # GitHub issue #2\n    modelname=${modelname%??}     # remove last 2 chars\n    model=${model%??}             # remove last 2 chars\n    echo -e \"\\nUsing model: $model\"\nfi\n\n# Get StorageManager version\nstoragemgrver=$(/usr/syno/bin/synopkg version StorageManager)\n# Show StorageManager version\nif [[ $storagemgrver ]]; then echo -e \"StorageManager $storagemgrver\\n\"; fi\n\n# Show host drive db version\nif [[ -f \"/var/lib/disk-compatibility/${model}_host_v7.version\" ]]; then\n    echo -n \"${model}_host_v7 version \"\n    cat \"/var/lib/disk-compatibility/${model}_host_v7.version\"\n    echo -e \"\\n\"\nfi\nif [[ -f \"/var/lib/disk-compatibility/${model}_host.version\" ]]; then\n    echo -n \"${model}_host version \"\n    cat \"/var/lib/disk-compatibility/${model}_host.version\"\n    echo -e \"\\n\"\nfi\n\n\n# Show options used\nif [[ ${#args[@]} -gt \"0\" ]]; then\n    echo \"Using options: ${args[*]}\"\nfi\n\n#echo \"\"  # To keep output readable\n\n\n# shellcheck disable=SC2317  # Don't warn about unreachable commands in this function\npause(){ \n    # When debugging insert pause command where needed\n    read -s -r -n 1 -p \"Press any key to continue...\"\n    read -r -t 0.1 -s -e --  # Silently consume all input\n    stty echo echok  # Ensure read didn't disable echoing user input\n    echo -e \"\\n\"\n}\n\n\n#------------------------------------------------------------------------------\n# Check latest release with GitHub API\n\nsyslog_set(){ \n    if [[ ${1,,} == \"info\" ]] || [[ ${1,,} == \"warn\" ]] || [[ ${1,,} == \"err\" ]]; then\n        if [[ $autoupdate == \"yes\" ]]; then\n            # Add entry to Synology system log\n            /usr/syno/bin/synologset1 sys \"$1\" 0x11100000 \"$2\"\n        fi\n    fi\n}\n\n\n# Get latest release info\n# Curl timeout options:\n# https://unix.stackexchange.com/questions/94604/does-curl-have-a-timeout\nrelease=$(curl --silent -m 10 --connect-timeout 5 \\\n    \"https://api.github.com/repos/$repo/releases/latest\")\n\n# Release version\ntag=$(echo \"$release\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/')\nshorttag=\"${tag:1}\"\n\n# Release published date\npublished=$(echo \"$release\" | grep '\"published_at\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/')\npublished=\"${published:0:10}\"\npublished=$(date -d \"$published\" '+%s')\n\n# Today's date\nnow=$(date '+%s')\n\n# Days since release published\nage=$(((now - published)/(60*60*24)))\n\n\n# Get script location\n# https://stackoverflow.com/questions/59895/\nsource=${BASH_SOURCE[0]}\nwhile [ -L \"$source\" ]; do # Resolve $source until the file is no longer a symlink\n    scriptpath=$( cd -P \"$( dirname \"$source\" )\" >/dev/null 2>&1 && pwd )\n    source=$(readlink \"$source\")\n    # If $source was a relative symlink, we need to resolve it\n    # relative to the path where the symlink file was located\n    [[ $source != /* ]] && source=$scriptpath/$source\ndone\nscriptpath=$( cd -P \"$( dirname \"$source\" )\" >/dev/null 2>&1 && pwd )\nscriptfile=$( basename -- \"$source\" )\necho \"Running from: ${scriptpath}/$scriptfile\"\n\n#echo \"Script location: $scriptpath\"  # debug\n#echo \"Source: $source\"               # debug\n#echo \"Script filename: $scriptfile\"  # debug\n\n#echo \"tag: $tag\"              # debug\n#echo \"scriptver: $scriptver\"  # debug\n\n\n# Warn if script located on M.2 drive\nget_script_vol() {\n    local script_root vol_num vg_name\n    script_root=\"${scriptpath#/*}\"\n    script_root=\"${script_root%%/*}\"\n    if [[ $script_root =~ ^volume ]]\n    then\n        vol_num=\"${script_root:6}\"\n        vg_name=$(lvs --noheadings --select=lv_name=\"volume_$vol_num\" --options=vg_name)\n        vg_name=\"${vg_name// }\"\n        vol_name=$(pvs --noheadings --select=vg_name=\"$vg_name\" --options=pv_name)\n        vol_name=\"${vol_name// }\"\n    else\n        vol_name=$(df --output=source \"/$script_root\" |sed 1d)\n    fi\n}\nget_script_vol # sets $vol_name to /dev/whatever\nif grep -qE \"^${vol_name#/dev/} .+ nvme\" /proc/mdstat\nthen\n    echo -e \"\\n${Yellow}WARNING${Off} Don't store this script on an NVMe volume!\"\nfi\n\n\ncleanup_tmp(){ \n    cleanup_err=\n\n    # Delete downloaded .tar.gz file\n    if [[ -f \"/tmp/$script-$shorttag.tar.gz\" ]]; then\n        if ! rm \"/tmp/$script-$shorttag.tar.gz\"; then\n            echo -e \"${Error}ERROR${Off} Failed to delete\"\\\n                \"downloaded /tmp/$script-$shorttag.tar.gz!\" >&2\n            cleanup_err=1\n        fi\n    fi\n\n    # Delete extracted tmp files\n    if [[ -d \"/tmp/$script-$shorttag\" ]]; then\n        if ! rm -r \"/tmp/$script-$shorttag\"; then\n            echo -e \"${Error}ERROR${Off} Failed to delete\"\\\n                \"downloaded /tmp/$script-$shorttag!\" >&2\n            cleanup_err=1\n        fi\n    fi\n\n    # Add warning to DSM log\n    if [[ $cleanup_err ]]; then\n        syslog_set warn \"$script update failed to delete tmp files\"\n    fi\n}\n\n\nif ! printf \"%s\\n%s\\n\" \"$tag\" \"$scriptver\" |\n        sort --check=quiet --version-sort >/dev/null ; then\n    echo -e \"\\n${Cyan}There is a newer version of this script available.${Off}\"\n    echo -e \"Current version: ${scriptver}\\nLatest version:  $tag\"\n    scriptdl=\"$scriptpath/$script-$shorttag\"\n    if [[ -f ${scriptdl}.tar.gz ]] || [[ -f ${scriptdl}.zip ]]; then\n        # They have the latest version tar.gz downloaded but are using older version\n        echo \"You have the latest version downloaded but are using an older version\"\n        sleep 10\n    elif [[ -d $scriptdl ]]; then\n        # They have the latest version extracted but are using older version\n        echo \"You have the latest version extracted but are using an older version\"\n        sleep 10\n    else\n        if [[ $autoupdate == \"yes\" ]]; then\n            if [[ $age -gt \"$delay\" ]] || [[ $age -eq \"$delay\" ]]; then\n                echo \"Downloading $tag\"\n                reply=y\n            else\n                echo \"Skipping as $tag is less than $delay days old.\"\n            fi\n        else\n            echo -e \"${Cyan}Do you want to download $tag now?${Off} [y/n]\"\n            read -r -t 30 reply\n        fi\n\n        if [[ ${reply,,} == \"y\" ]]; then\n            # Delete previously downloaded .tar.gz file and extracted tmp files\n            cleanup_tmp\n\n            if cd /tmp; then\n                url=\"https://github.com/$repo/archive/refs/tags/$tag.tar.gz\"\n                if ! curl -JLO -m 30 --connect-timeout 5 \"$url\"; then\n                    echo -e \"${Error}ERROR${Off} Failed to download\"\\\n                        \"$script-$shorttag.tar.gz!\"\n                    syslog_set warn \"$script $tag failed to download\"\n                else\n                    if [[ -f /tmp/$script-$shorttag.tar.gz ]]; then\n                        # Extract tar file to /tmp/<script-name>\n                        if ! tar -xf \"/tmp/$script-$shorttag.tar.gz\" -C \"/tmp\"; then\n                            echo -e \"${Error}ERROR${Off} Failed to\"\\\n                                \"extract $script-$shorttag.tar.gz!\"\n                            syslog_set warn \"$script failed to extract $script-$shorttag.tar.gz!\"\n                        else\n                            # Set script sh files as executable\n                            if ! chmod a+x \"/tmp/$script-$shorttag/\"*.sh ; then\n                                permerr=1\n                                echo -e \"${Error}ERROR${Off} Failed to set executable permissions\"\n                                syslog_set warn \"$script failed to set permissions on $tag\"\n                            fi\n\n                            # Copy new script sh file to script location\n                            if ! cp -p \"/tmp/$script-$shorttag/${scriptname}.sh\" \"${scriptpath}/${scriptfile}\";\n                            then\n                                copyerr=1\n                                echo -e \"${Error}ERROR${Off} Failed to copy\"\\\n                                    \"$script-$shorttag sh file(s) to:\\n $scriptpath/${scriptfile}\"\n                                syslog_set warn \"$script failed to copy $tag to script location\"\n                            fi\n\n                            # Copy new syno_hdd_vendor_ids.txt file\n                            vidstxt=\"syno_hdd_vendor_ids.txt\"\n                            if [[ $scriptpath =~ /volume* ]]; then\n                                if [[ ! -f \"$scriptpath/$vidstxt\" ]]; then  # Don't overwrite file\n                                    # Copy new syno_hdd_vendor_ids.txt file to script location\n                                    if ! cp -p \"/tmp/$script-$shorttag/$vidstxt\" \"$scriptpath\"; then\n                                        if [[ $autoupdate != \"yes\" ]]; then copyerr=1; fi\n                                        echo -e \"${Error}ERROR${Off} Failed to copy\"\\\n                                            \"$script-$shorttag/$vidstxt to:\\n $scriptpath\"\n                                    else\n                                        # Set permissions on syno_hdd_vendor_ids.txt\n                                        if ! chmod 755 \"$scriptpath/$vidstxt\"; then\n                                            if [[ $autoupdate != \"yes\" ]]; then permerr=1; fi\n                                            echo -e \"${Error}ERROR${Off} Failed to set permissions on:\"\n                                            echo \"$scriptpath/$vidstxt\"\n                                        fi\n                                        vids_txt=\", syno_hdd_vendor_ids.txt\"\n                                    fi\n                                fi\n                            fi\n\n                            # Copy new CHANGES.txt file to script location (if script on a volume)\n                            if [[ $scriptpath =~ /volume* ]]; then\n                                # Set permissions on CHANGES.txt\n                                if ! chmod 664 \"/tmp/$script-$shorttag/CHANGES.txt\"; then\n                                    permerr=1\n                                    echo -e \"${Error}ERROR${Off} Failed to set permissions on:\"\n                                    echo \"$scriptpath/CHANGES.txt\"\n                                fi\n\n                                # Copy new CHANGES.txt file to script location\n                                if ! cp -p \"/tmp/$script-$shorttag/CHANGES.txt\"\\\n                                    \"${scriptpath}/${scriptname}_CHANGES.txt\";\n                                then\n                                    if [[ $autoupdate != \"yes\" ]]; then copyerr=1; fi\n                                    echo -e \"${Error}ERROR${Off} Failed to copy\"\\\n                                        \"$script-$shorttag/CHANGES.txt to:\\n $scriptpath\"\n                                else\n                                    changestxt=\" and changes.txt\"\n                                fi\n                            fi\n\n                            # Delete downloaded tmp files\n                            cleanup_tmp\n\n                            # Notify of success (if there were no errors)\n                            if [[ $copyerr != 1 ]] && [[ $permerr != 1 ]]; then\n                                echo -e \"\\n$tag ${scriptfile}$vids_txt$changestxt downloaded to: ${scriptpath}\\n\"\n                                syslog_set info \"$script successfully updated to $tag\"\n\n                                # Reload script\n                                printf -- '-%.0s' {1..79}; echo  # print 79 -\n                                exec \"${scriptpath}/$scriptfile\" \"${args[@]}\"\n                            else\n                                syslog_set warn \"$script update to $tag had errors\"\n                            fi\n                        fi\n                    else\n                        echo -e \"${Error}ERROR${Off}\"\\\n                            \"/tmp/$script-$shorttag.tar.gz not found!\"\n                        #ls /tmp | grep \"$script\"  # debug\n                        syslog_set warn \"/tmp/$script-$shorttag.tar.gz not found\"\n                    fi\n                fi\n                cd \"$scriptpath\" || echo -e \"${Error}ERROR${Off} Failed to cd to script location!\"\n            else\n                echo -e \"${Error}ERROR${Off} Failed to cd to /tmp!\"\n                syslog_set warn \"$script update failed to cd to /tmp\"\n            fi\n        fi\n    fi\nfi\n\n\n#------------------------------------------------------------------------------\n# Set file variables\n\nif [[ -f /etc.defaults/model.dtb ]]; then  # Is device tree model\n    # Get syn_hw_revision, r1 or r2 etc (or just a linefeed if not a revision)\n    hwrevision=$(cat /proc/sys/kernel/syno_hw_revision)\n\n    # If syno_hw_revision is r1 or r2 it's a real Synology,\n    # and I need to edit model_rN.dtb instead of model.dtb\n    if [[ $hwrevision =~ r[0-9] ]]; then\n        #echo \"hwrevision: $hwrevision\"  # debug\n        hwrev=\"_$hwrevision\"\n    fi\n\n    dtb_file=\"/etc.defaults/model${hwrev}.dtb\"\n    dtb2_file=\"/etc/model${hwrev}.dtb\"\n    #dts_file=\"/etc.defaults/model${hwrev}.dts\"\n    dts_file=\"/tmp/model${hwrev}.dts\"\nfi\n\nadapter_cards=\"/usr/syno/etc.defaults/adapter_cards.conf\"\nadapter_cards2=\"/usr/syno/etc/adapter_cards.conf\"\ndbpath=/var/lib/disk-compatibility/\nsynoinfo=\"/etc.defaults/synoinfo.conf\"\n\nif [[ $buildnumber -gt 64570 ]]; then\n    # DSM 7.2.1 and later\n    #strgmgr=\"/var/packages/StorageManager/target/ui/storage_panel.js\"\n    strgmgr=\"/usr/local/packages/@appstore/StorageManager/ui/storage_panel.js\"\nelif [[ $buildnumber -ge 64561 ]]; then\n    # DSM 7.2\n    strgmgr=\"/usr/syno/synoman/webman/modules/StorageManager/storage_panel.js\"\nfi\nvidfile=\"/usr/syno/etc.defaults/pci_vendor_ids.conf\"\nvidfile2=\"/usr/syno/etc/pci_vendor_ids.conf\"\n\n\nset_writemostly(){ \n    # $1 is writemostly or -writemostly\n    # $2 is sata1 or sas1 or sda etc\n    local model\n    # Show drive model\n    model=\"$(cat /sys/block/\"${2}\"/device/model | xargs)\"\n    echo -e \"${Yellow}$model${Off}\"\n\n    if [[ ${1::2} == \"sd\" ]]; then\n        # sda etc\n        # md0 DSM system partition\n        echo \"$1\" > /sys/block/md0/md/dev-\"${2}\"1/state\n        # Show setting\n        echo -n \"  $2 DSM partition:  \"\n        cat /sys/block/md0/md/dev-\"${2}\"1/state\n\n        # md1 DSM swap partition\n        echo \"$1\" > /sys/block/md1/md/dev-\"${2}\"2/state\n        # Show setting\n        echo -n \"  $2 Swap partition: \"\n        cat /sys/block/md1/md/dev-\"${2}\"2/state\n    else\n        # sata1 or sas1 etc\n        # md0 DSM system partition\n        echo \"$1\" > /sys/block/md0/md/dev-\"${2}\"p1/state\n        # Show setting\n        echo -n \"  $2 DSM partition:  \"\n        cat /sys/block/md0/md/dev-\"${2}\"p1/state\n\n        # md1 DSM swap partition\n        echo \"$1\" > /sys/block/md1/md/dev-\"${2}\"p2/state\n        # Show setting\n        echo -n \"  $2 Swap partition: \"\n        cat /sys/block/md1/md/dev-\"${2}\"p2/state\n    fi\n}\n\n\n#------------------------------------------------------------------------------\n# Restore changes from backups\n\nif [[ $restore == \"yes\" ]]; then\n    dbbaklist=($(find $dbpath -maxdepth 1 \\( -name \"*.db.new.bak\" -o -name \"*.db.bak\" \\)))\n    # Sort array\n    IFS=$'\\n'\n    dbbakfiles=($(sort <<<\"${dbbaklist[*]}\"))\n    unset IFS\n\n    echo \"\"\n    if [[ ${#dbbakfiles[@]} -gt \"0\" ]] || [[ -f ${synoinfo}.bak ]] ||\\\n        [[ -f ${dtb_file}.bak ]] || [[ -f ${adapter_cards}.bak ]] ; then\n\n        # Restore synoinfo.conf from backup\n        if [[ -f ${synoinfo}.bak ]]; then\n            keyvalues=(\"support_disk_compatibility\" \"support_memory_compatibility\")\n            keyvalues+=(\"mem_max_mb\" \"supportnvme\" \"support_m2_pool\" \"support_wdda\")\n            for v in \"${!keyvalues[@]}\"; do\n                defaultval=\"$(/usr/syno/bin/synogetkeyvalue ${synoinfo}.bak \"${keyvalues[v]}\")\"\n                currentval=\"$(/usr/syno/bin/synogetkeyvalue ${synoinfo} \"${keyvalues[v]}\")\"\n                if [[ $currentval != \"$defaultval\" ]]; then\n                    if /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"${keyvalues[v]}\" \"$defaultval\";\n                    then\n                        echo \"Restored ${keyvalues[v]} = $defaultval\"\n                    fi\n                fi\n            done\n        fi\n\n        # Delete \"drive_db_test_url=127.0.0.1\" line (and line break) from synoinfo.conf\n        sed -i \"/drive_db_test_url=*/d\" \"$synoinfo\"\n        sed -i \"/drive_db_test_url=*/d\" /etc/synoinfo.conf\n\n        # Restore adapter_cards.conf from backup\n        # /usr/syno/etc.defaults/adapter_cards.conf\n        if [[ -f ${adapter_cards}.bak ]]; then\n            if cp -p \"${adapter_cards}.bak\" \"${adapter_cards}\"; then\n                echo \"Restored ${adapter_cards}\"\n            else\n                restoreerr=1\n                echo -e \"${Error}ERROR${Off} Failed to restore ${adapter_cards}!\\n\"\n            fi\n            # /usr/syno/etc/adapter_cards.conf\n            if cp -p \"${adapter_cards}.bak\" \"${adapter_cards2}\"; then\n                echo -e \"Restored ${adapter_cards2}\"\n            else\n                restoreerr=1\n                echo -e \"${Error}ERROR${Off} Failed to restore ${adapter_cards2}!\\n\"\n            fi\n\n            # Make sure they don't lose E10M20-T1 network connection\n            modelrplowercase=${modelname//RP/rp}\n            /usr/syno/bin/set_section_key_value ${adapter_cards} E10M20-T1_sup_nic \"$modelrplowercase\"\n            /usr/syno/bin/set_section_key_value ${adapter_cards2} E10M20-T1_sup_nic \"$modelrplowercase\"\n        fi\n\n        # Restore model.dtb from backup\n        if [[ -f ${dtb_file}.bak ]]; then\n            # /etc.default/model.dtb\n            if cp -p \"${dtb_file}.bak\" \"${dtb_file}\"; then\n                echo \"Restored ${dtb_file}\"\n            else\n                restoreerr=1\n                echo -e \"${Error}ERROR${Off} Failed to restore ${dtb_file}!\\n\"\n            fi\n            # Restore /etc/model.dtb from /etc.default/model.dtb\n            if cp -p \"${dtb_file}.bak\" \"${dtb2_file}\"; then\n                echo -e \"Restored ${dtb2_file}\"\n            else\n                restoreerr=1\n                echo -e \"${Error}ERROR${Off} Failed to restore ${dtb2_file}!\\n\"\n            fi\n        fi\n\n        # Restore storage_panel.js from backup\n        if [[ $buildnumber -gt 64570 ]]; then\n            # DSM 7.2.1 and later\n            strgmgrver=\"$(/usr/syno/bin/synopkg version StorageManager)\"\n        elif [[ $buildnumber -ge 64561 ]]; then\n            # DSM 7.2\n            strgmgrver=\"${buildnumber}${smallfixnumber}\"\n        fi\n        if [[ -f \"${strgmgr}.$strgmgrver\" ]]; then\n            if cp -p \"${strgmgr}.$strgmgrver\" \"$strgmgr\"; then\n                echo \"Restored $(basename -- \"$strgmgr\")\"\n            else\n                restoreerr=1\n                echo -e \"${Error}ERROR${Off} Failed to restore $(basename -- \"$strgmgr\")!\\n\"\n            fi\n        else\n            echo \"No backup of $(basename -- \"$strgmgr\") found.\"\n        fi\n\n        echo \"\"\n        # Restore .db files from backups\n        for f in \"${!dbbakfiles[@]}\"; do\n            replaceme=\"${dbbakfiles[f]%.bak}\"  # Remove .bak\n            if cp -p \"${dbbakfiles[f]}\" \"$replaceme\"; then\n                echo \"Restored $(basename -- \"$replaceme\")\"\n            else\n                restoreerr=1\n                echo -e \"${Error}ERROR${Off} Failed to restore $(basename -- \"$replaceme\")!\\n\"\n            fi\n        done\n\n        # Delete any .dbr and .db.newr files left by previous script versions\n        for f in \"${dbpath}\"*dbr; do\n            if [[ -f $f ]]; then\n                rm \"$f\" >/dev/null\n            fi\n        done\n        for f in \"${dbpath}\"*db.newr; do\n            if [[ -f $f ]]; then\n                rm \"$f\" >/dev/null\n            fi\n        done\n\n        # Update .db files from Synology\n        /usr/syno/bin/syno_disk_db_update --update\n\n        # Enable SynoMemCheck.service if disabled\n        memcheck=\"/usr/lib/systemd/system/SynoMemCheck.service\"\n        if [[ $(/usr/syno/bin/synogetkeyvalue \"$memcheck\" ExecStart) == \"/bin/true\" ]]; then\n            /usr/syno/bin/synosetkeyvalue \"$memcheck\" ExecStart /usr/syno/bin/syno_mem_check\n        fi\n\n        if [[ -z $restoreerr ]]; then\n            echo -e \"\\nRestore successful.\"\n        fi\n\n        # Restore writemostly if set\n        if [[ $ssd_restore == \"yes\" ]]; then\n            # Get array of internal drives\n            readarray -t internal_drives < <(synodisk --enum -t internal | grep 'Disk path' | cut -d\"/\" -f3)\n\n            # Restore all internal drives to just in_sync\n            echo -e \"\\nRestoring internal drive's state\"\n            for idrive in \"${internal_drives[@]}\"; do\n                md0=\"/sys/block/md0/md/dev-\"\n                md1=\"/sys/block/md1/md/dev-\"\n                if [[ ${idrive::2} == \"sd\" ]]; then\n                    # sda etc\n                    # Check DSM system and swap partitions\n                    if grep -q \"write_mostly\" \"${md0}$idrive\"1/state ||\\\n                        grep -q \"write_mostly\" \"${md1}$idrive\"2/state; then \n                        set_writemostly -writemostly \"$idrive\"\n                    fi\n                else\n                    # sata1 or sas1 etc\n                    # Check DSM system and swap partitions\n                    if grep -q \"write_mostly\" \"${md0}$idrive\"p1/state ||\\\n                        grep -q \"write_mostly\" \"${md1}$idrive\"p2/state; then \n                        set_writemostly -writemostly \"$idrive\"\n                    fi\n                fi\n            done\n        fi\n\n    else\n        echo \"Nothing to restore.\"\n    fi\n    exit\nfi\n\n\n#------------------------------------------------------------------------------\n# Get list of installed SATA, SAS and M.2 NVMe/SATA drives,\n# PCIe M.2 cards and connected Expansion Units.\n\nvendor_from_id(){ \n    # Vendor ids missing in /usr/syno/etc.defaults/pci_vendor_ids.conf\n    # $1 is vendor id\n    # https://devicehunt.com/all-pci-vendors\n    # https://pci-ids.ucw.cz/\n    vendor=\"\"\n    case \"${1,,}\" in\n        0x10ec) vendor=TEAMGROUP ;;\n        0x025e) vendor=Solidigm ;;\n        0x1458) vendor=Gigabyte ;;\n        0x1462) vendor=MSI ;;\n        0x196e) vendor=PNY ;;\n        0x1987) vendor=Phison ;;\n        0x1b1c) vendor=Corsair ;;\n        0x1c5c) vendor=\"SK Hynix\" ;;\n        0x1cc4) vendor=UMIS ;;\n        0x1cfa) vendor=Corsair ;;     # Memory only?\n        0x1d97) vendor=SPCC/Lexar ;;  # 2 brands with same vid\n        0x1dbe) vendor=ADATA ;;\n        0x1e0f) vendor=KIOXIA ;;\n        0x1e49) vendor=ZHITAI ;;\n        0x1e4b) vendor=HS/MAXIO ;;    # 2 brands with same vid\n        0x1f40) vendor=Netac ;;\n\n        0x1bdc) vendor=Apacer;;\n        0x0ed1) vendor=aigo ;;\n        0x05dc) vendor=Lexar ;;\n        0x1d79) vendor=Transcend;;\n        *)\n            # Get vendor from syno_hdd_vendor_ids.txt\n            vidlist=\"$scriptpath/syno_hdd_vendor_ids.txt\"\n            if [[ -r \"$vidlist\" ]]; then\n                val=$(/usr/syno/bin/synogetkeyvalue \"$vidlist\" \"$1\")\n                if [[ -n \"$val\" ]]; then\n                    vendor=\"$val\"\n                else\n                    echo -e \"\\n${Yellow}WARNING${Off} No vendor found for vid $1\" >&2\n                    echo -e \"You can add ${Cyan}$1${Off} and your drive's vendor to: \" >&2\n                    echo \"$vidlist\" >&2\n                fi\n            else\n                echo -e \"\\n${Error}ERROR{OFF} $vidlist not found!\" >&2\n            fi\n        ;;\n    esac\n}\n\nset_vendor(){ \n    # Add missing vendors to /usr/syno/etc.defaults/pci_vendor_ids.conf\n    if [[ $vendor ]]; then\n        # DS1817+, DS1517+, RS1219+, RS818+ don't have pci_vendor_ids.conf\n        if [[ \"$vidfile\" ]]; then\n            if ! grep -q \"$vid\" \"$vidfile\"; then\n                /usr/syno/bin/synosetkeyvalue \"$vidfile\" \"${vid,,}\" \"$vendor\"\n                val=$(/usr/syno/bin/synogetkeyvalue \"$vidfile\" \"${vid,,}\")\n                if [[ $val == \"${vendor}\" ]]; then\n                    echo -e \"\\nAdded $vendor to pci_vendor_ids\" >&2\n                else\n                    echo -e \"\\nFailed to add $vendor to pci_vendor_ids!\" >&2\n                fi\n            fi\n            if ! grep -q \"$vid\" \"$vidfile2\"; then\n                /usr/syno/bin/synosetkeyvalue \"$vidfile2\" \"${vid,,}\" \"$vendor\"\n            fi\n\n            # Add leading 0 to short vid (change 0x5dc to 0x05dc)\n            if [[ ${#vid} -eq \"5\" ]]; then\n                vid=\"0x0${vid: -3}\"\n            fi\n            if ! grep -q \"$vid\" \"$vidfile\"; then\n                /usr/syno/bin/synosetkeyvalue \"$vidfile\" \"${vid,,}\" \"$vendor\"\n            fi\n            if ! grep -q \"$vid\" \"$vidfile2\"; then\n                /usr/syno/bin/synosetkeyvalue \"$vidfile2\" \"${vid,,}\" \"$vendor\"\n            fi\n\n        fi\n    fi\n}\n\nget_vid(){ \n    # $1 is /dev/nvme0n1 etc\n    if [[ $1 ]]; then\n        vid=$(nvme id-ctrl \"$1\" | grep -E ^vid | awk '{print $NF}')\n        if [[ $vid ]]; then\n            val=$(/usr/syno/bin/synogetkeyvalue \"$vidfile\" \"${vid,,}\")\n            if [[ -z $val ]]; then\n                vendor_from_id \"$vid\" && set_vendor\n            fi\n        fi\n    fi\n}\n\nfixdrivemodel(){ \n    # Remove \" 00Y\" from end of Samsung/Lenovo SSDs  # Github issue #13\n    if [[ $1 =~ MZ.*' 00Y' ]]; then\n        hdmodel=$(printf \"%s\" \"$1\" | sed 's/ 00Y.*//')\n    fi\n\n    # Brands that return \"BRAND <model>\" and need \"BRAND \" removed.\n    if [[ $1 =~ ^[A-Za-z]{3,7}' '.* ]]; then\n        # See  Smartmontools database in /var/lib/smartmontools/drivedb.db\n        hdmodel=${hdmodel#\"WDC \"}       # Remove \"WDC \" from start of model name\n        hdmodel=${hdmodel#\"HGST \"}      # Remove \"HGST \" from start of model name\n        hdmodel=${hdmodel#\"TOSHIBA \"}   # Remove \"TOSHIBA \" from start of model name\n\n        # Chinese brand?\n        hdmodel=${hdmodel#\"HCST \"}      # Remove \"HCST \" from start of model name. Issue #389\n\n        # Old drive brands\n        hdmodel=${hdmodel#\"Hitachi \"}   # Remove \"Hitachi \" from start of model name\n        hdmodel=${hdmodel#\"SAMSUNG \"}   # Remove \"SAMSUNG \" from start of model name\n        hdmodel=${hdmodel#\"FUJISTU \"}   # Remove \"FUJISTU \" from start of model name\n    elif [[ $1 =~ ^'APPLE HDD '.* ]]; then\n        # Old drive brands\n        hdmodel=${hdmodel#\"APPLE HDD \"} # Remove \"APPLE HDD \" from start of model name\n    fi\n}\n\nget_size_gb(){ \n    # $1 is /sys/block/sata1 or /sys/block/nvme0n1 etc\n    local disk_size_gb\n    disk_size_gb=$(synodisk --info /dev/\"$(basename -- \"$1\")\" 2>/dev/null | grep 'Total capacity' | awk '{print int($4 * 1.073741824)}')\n    echo \"$disk_size_gb\"\n}\n\ngetdriveinfo(){ \n    # $1 is /sys/block/sata1 etc\n\n    # Skip USB drives\n    usb=$(grep \"$(basename -- \"$1\")\" /proc/mounts | grep \"[Uu][Ss][Bb]\" | cut -d\" \" -f1-2)\n    if [[ ! $usb ]]; then\n\n        # Get drive model\n        hdmodel=$(cat \"$1/device/model\")\n        hdmodel=$(printf \"%s\" \"$hdmodel\" | xargs)  # trim leading and trailing white space\n\n        # Fix dodgy model numbers\n        fixdrivemodel \"$hdmodel\"\n\n        # Get drive firmware version\n        #fwrev=$(cat \"$1/device/rev\")\n        #fwrev=$(printf \"%s\" \"$fwrev\" | xargs)  # trim leading and trailing white space\n\n        device=/dev/\"$(basename -- \"$1\")\"\n        #fwrev=$(/usr/syno/bin/syno_hdd_util --ssd_detect | grep \"$device \" | awk '{print $2}')      # GitHub issue #86, 87\n        # Account for SSD drives with spaces in their model name/number\n        fwrev=$(/usr/syno/bin/syno_hdd_util --ssd_detect | grep \"$device \" | awk '{print $(NF-3)}')  # GitHub issue #86, 87\n\n        # Get firmware version with smartctl if $fwrev null\n        # for M.2 SATA SSD and SAS drives. Github issue #407\n        if [[ -z $fwrev ]]; then\n            dev=/dev/\"$(basename -- \"$1\")\"\n            fwrev=$(smartctl -a -d ata -T permissive \"$dev\" | grep -i firmware | awk '{print $NF}')\n        fi\n\n        # Get drive GB size\n        size_gb=$(get_size_gb \"$1\")\n        if [[ -n \"$size_gb\" ]]; then  # PR #187\n            if [[ $hdmodel ]] && [[ $fwrev ]]; then\n                if /usr/syno/bin/synodisk --enum -t cache | grep -q /dev/\"$(basename -- \"$1\")\"; then\n                    # Is SATA M.2 SSD\n                    nvmelist+=(\"${hdmodel},${fwrev},${size_gb}\")\n                else\n                    hdlist+=(\"${hdmodel},${fwrev},${size_gb}\")\n                fi\n                drivelist+=(\"${hdmodel}\")\n            fi\n        fi\n    fi\n}\n\ngetm2info(){ \n    # $1 is /sys/block/nvme0n1 etc\n    nvmemodel=$(cat \"$1/device/model\")\n    nvmemodel=$(printf \"%s\" \"$nvmemodel\" | xargs)  # trim leading and trailing white space\n    if [[ $2 == \"nvme\" ]]; then\n        nvmefw=$(cat \"$1/device/firmware_rev\")\n    elif [[ $2 == \"nvc\" ]]; then\n        nvmefw=$(cat \"$1/device/rev\")\n    fi\n    nvmefw=$(printf \"%s\" \"$nvmefw\" | xargs)  # trim leading and trailing white space\n\n    # Get drive GB size\n    size_gb=$(get_size_gb \"$1\")\n\n    if [[ $nvmemodel ]] && [[ $nvmefw ]]; then\n        nvmelist+=(\"${nvmemodel},${nvmefw},${size_gb}\")\n        drivelist+=(\"${nvmemodel}\")\n    fi\n}\n\ngetcardmodel(){ \n    # Get M.2 card model (if M.2 drives found)\n    # $1 is /dev/nvme0n1 etc\n    if [[ ${#nvmelist[@]} -gt \"0\" ]]; then\n        cardmodel=$(/usr/syno/bin/synodisk --m2-card-model-get \"$1\")\n        if [[ $cardmodel =~ M2D[0-9][0-9] ]]; then\n            # M2 adaptor card\n            if [[ -f \"${model}_${cardmodel,,}${version}.db\" ]]; then\n                m2carddblist+=(\"${model}_${cardmodel,,}${version}.db\")  # M.2 card's db file\n            fi\n            if [[ -f \"${model}_${cardmodel,,}.db\" ]]; then\n                m2carddblist+=(\"${model}_${cardmodel,,}.db\")            # M.2 card's db file\n            fi\n            m2cardlist+=(\"$cardmodel\")                                  # M.2 card\n        elif [[ $cardmodel =~ E[0-9][0-9]+M.+ ]]; then\n            # Ethernet + M2 adaptor card\n            if [[ -f \"${model}_${cardmodel,,}${version}.db\" ]]; then\n                m2carddblist+=(\"${model}_${cardmodel,,}${version}.db\")  # M.2 card's db file\n            fi\n            if [[ -f \"${model}_${cardmodel,,}.db\" ]]; then\n                m2carddblist+=(\"${model}_${cardmodel,,}.db\")            # M.2 card's db file\n            fi\n            m2cardlist+=(\"$cardmodel\")                                  # M.2 card\n        fi\n    fi\n}\n\nm2_pool_support(){ \n    # M.2 drives in M2 adaptor card do not officially support storage pools\n    if [[ -f /run/synostorage/disks/\"$(basename -- \"$1\")\"/m2_pool_support ]]; then  # GitHub issue #86, 87\n        echo -n 1 > /run/synostorage/disks/\"$(basename -- \"$1\")\"/m2_pool_support\n    fi\n}\n\nm2_drive(){ \n    # $1 is nvme1 etc\n    # $2 is drive type (nvme or nvc)\n    if [[ $m2 != \"no\" ]]; then\n        # Check if is NVMe or SATA M.2 SSD\n        if /usr/syno/bin/synodisk --enum -t cache | grep -q /dev/\"$(basename -- \"$1\")\"; then\n\n            if [[ $2 == \"nvme\" ]] || [[ $2 == \"nvc\" ]]; then\n                # Fix unknown vendor id if needed. GitHub issue #161\n                # \"Failed to get disk vendor\" from synonvme --vendor-get\n                # causes \"Unsupported firmware version\" warning.\n                get_vid /dev/\"$(basename -- \"$1\")\"\n\n                # Get M2 model and firmware version\n                getm2info \"$1\" \"$2\"\n            fi\n\n            # Get M.2 card model if in M.2 card\n            getcardmodel /dev/\"$(basename -- \"$1\")\"\n\n            # Enable creating M.2 storage pool and volume in Storage Manager\n            m2_pool_support \"$1\"\n\n            rebootmsg=yes  # Show reboot message at end\n        fi\n    fi\n}\n\nfor d in /sys/block/*; do\n    # $d is /sys/block/sata1 etc\n    case \"$(basename -- \"${d}\")\" in\n        sd*|hd*)\n            if [[ $d =~ [hs]d[a-z][a-z]?$ ]]; then\n                getdriveinfo \"$d\"\n            fi\n        ;;\n        sas*)\n            if [[ $d =~ sas[0-9][0-9]?[0-9]?$ ]]; then\n                getdriveinfo \"$d\"\n            fi\n        ;;\n        sata*)\n            if [[ $d =~ sata[0-9][0-9]?[0-9]?$ ]]; then\n                getdriveinfo \"$d\"\n\n                # In case it's a SATA M.2 SSD in device tree model NAS\n                # M.2 SATA drives in M2D18 or M2S17\n                m2_drive \"$d\"\n            fi\n        ;;\n        nvme*)\n            if [[ $d =~ nvme[0-9][0-9]?n[0-9][0-9]?$ ]]; then\n                m2_drive \"$d\" \"nvme\"\n            fi\n        ;;\n        nvc*)  # M.2 SATA drives (in PCIe M2D18 or M2S17 only?)\n            if [[ $d =~ nvc[0-9][0-9]?$ ]]; then\n                m2_drive \"$d\" \"nvc\"\n            fi\n        ;;\n    esac\ndone\n\n\n# Sort hdlist array into new hdds array to remove duplicates\nif [[ ${#hdlist[@]} -gt \"0\" ]]; then\n    while IFS= read -r -d '' x; do\n        hdds+=(\"$x\")\n    done < <(printf \"%s\\0\" \"${hdlist[@]}\" | sort -uz)        \nfi\n\n# Show hdds if hdds array isn't empty\nif [[ ${#hdds[@]} -eq \"0\" ]]; then\n    echo -e \"No SATA or SAS drives found\\n\"\nelse\n    echo -e \"\\nHDD/SSD models found: ${#hdds[@]}\"\n    num=\"0\"\n    while [[ $num -lt \"${#hdds[@]}\" ]]; do\n        echo \"${hdds[num]} GB\"\n        num=$((num +1))\n    done\n    echo\nfi\n\n\n# Sort nvmelist array into new nvmes array to remove duplicates\nif [[ ${#nvmelist[@]} -gt \"0\" ]]; then\n    while IFS= read -r -d '' x; do\n        nvmes+=(\"$x\")\n    done < <(printf \"%s\\0\" \"${nvmelist[@]}\" | sort -uz)        \nfi\n\n# Show nvmes if nvmes array isn't empty\nif [[ $m2 != \"no\" ]]; then\n    if [[ ${#nvmes[@]} -eq \"0\" ]]; then\n        echo -e \"No M.2 drives found\\n\"\n    else    \n        m2exists=\"yes\"\n        echo \"M.2 drive models found: ${#nvmes[@]}\"\n        num=\"0\"\n        while [[ $num -lt \"${#nvmes[@]}\" ]]; do\n            echo \"${nvmes[num]} GB\"\n            num=$((num +1))\n        done\n        echo\n    fi\nfi\n\n\n# Exit if no drives found\nif [[ ${#hdds[@]} -eq \"0\" ]] && [[ ${#nvmes[@]} -eq \"0\" ]]; then\n    ding\n    echo -e \"\\n${Error}ERROR${Off} No drives found!\" && exit 2\nfi\n\n\n# M.2 card db files\n# Sort m2carddblist array into new m2carddbs array to remove duplicates\nif [[ ${#m2carddblist[@]} -gt \"0\" ]]; then\n    while IFS= read -r -d '' x; do\n        m2carddbs+=(\"$x\")\n    done < <(printf \"%s\\0\" \"${m2carddblist[@]}\" | sort -uz)        \nfi\n\n# M.2 cards\n# Sort m2cardlist array into new m2cards array to remove duplicates\nif [[ ${#m2cardlist[@]} -gt \"0\" ]]; then\n    while IFS= read -r -d '' x; do\n        m2cards+=(\"$x\")\n    done < <(printf \"%s\\0\" \"${m2cardlist[@]}\" | sort -uz)        \nfi\n\n# Check m2cards array isn't empty\nif [[ $m2 != \"no\" ]]; then\n    if [[ ${#m2cards[@]} -eq \"0\" ]]; then\n        echo -e \"No M.2 PCIe cards found\\n\"\n    else    \n        echo \"M.2 PCIe card models found: ${#m2cards[@]}\"\n        num=\"0\"\n        while [[ $num -lt \"${#m2cards[@]}\" ]]; do\n            echo \"${m2cards[num]}\"\n            num=$((num +1))\n        done\n        echo\n    fi\nfi\n\n\n# Expansion units\nebox_conected=$(synodisk --enum -t ebox)\nif [[ $ebox_conected ]]; then\n    # Only device tree models have syno_slot_mapping\n    # eSATA and InfiniBand ports both appear in syno_slot_mapping as:\n    # Esata port count: 1\n    # Eunit port 1 - RX1214\n    if which syno_slot_mapping >/dev/null; then\n        # syno_slot_mapping does not find SAS eunits\n        eunitlist=($(syno_slot_mapping | grep 'Eunit port' | awk '{print $5}'))\n    fi\n    if [[ ${#eunitlist[@]} -eq \"0\" ]]; then\n        # Create new /var/log/diskprediction log to ensure newly connected ebox is in latest log\n        # Otherwise the new /var/log/diskprediction log is only created a midnight.\n        /usr/syno/bin/syno_disk_data_collector record\n\n        # Get list of connected expansion units (aka eunit/ebox)\n        path=\"/var/log/diskprediction\"\n        # shellcheck disable=SC2012\n        file=$(ls $path | tail -n1)\n        eunitlist=($(grep -Eowi \"([FRD]XD?[0-9]{3,4})(rp|ii|sas){0,2}\" \"$path/$file\" | uniq))\n    fi\nfi\n\n# Sort eunitlist array into new eunits array to remove duplicates\nif [[ ${#eunitlist[@]} -gt \"0\" ]]; then\n    while IFS= read -r -d '' x; do\n        eunits+=(\"$x\")\n    done < <(printf \"%s\\0\" \"${eunitlist[@]}\" | sort -uz)        \nfi\n\n# Check eunits array isn't empty\nif [[ ${#eunits[@]} -eq \"0\" ]]; then\n    echo -e \"No Expansion Units found\\n\"\nelse    \n    #eunitexists=\"yes\"\n    echo \"Expansion Unit models found: ${#eunits[@]}\"\n    num=\"0\"\n    while [[ $num -lt \"${#eunits[@]}\" ]]; do\n        echo \"${eunits[num]}\"\n        num=$((num +1))\n    done\n    echo\nfi\n\n\n#------------------------------------------------------------------------------\n# Check databases and add our drives if needed\n\n# Host db files\ndb1list=($(find \"$dbpath\" -maxdepth 1 -name \"*_host*.db\"))\ndb2list=($(find \"$dbpath\" -maxdepth 1 -name \"*_host*.db.new\"))\n#db1list=($(find \"$dbpath\" -maxdepth 1 -regextype posix-extended\\\n#    -iregex \".*_host(_v7)?.db\"))\n#db2list=($(find \"$dbpath\" -maxdepth 1 -regextype posix-extended\\\n#    -iregex \".*_host(_v7)?.db.new\"))\n\n# Expansion Unit db files\nfor i in \"${!eunits[@]}\"; do\n    #eunitdb1list+=($(find \"$dbpath\" -maxdepth 1 -name \"${eunits[i],,}*.db\"))\n    eunitdb1list+=($(find \"$dbpath\" -maxdepth 1 -regextype posix-extended\\\n        -iregex \".*${eunits[i],,}(_v7)?.db\"))\n    #eunitdb2list+=($(find \"$dbpath\" -maxdepth 1 -name \"${eunits[i],,}*.db.new\"))\n    eunitdb2list+=($(find \"$dbpath\" -maxdepth 1 -regextype posix-extended\\\n        -iregex \".*${eunits[i],,}(_v7)?.db.new\"))\ndone\n\n# M.2 Card db files\nfor i in \"${!m2cards[@]}\"; do\n    m2carddb1list+=($(find \"$dbpath\" -maxdepth 1 -name \"*_${m2cards[i],,}*.db\"))\n    m2carddb2list+=($(find \"$dbpath\" -maxdepth 1 -name \"*_${m2cards[i],,}*.db.new\"))\ndone\n\n\nif [[ ${#db1list[@]} -eq \"0\" ]]; then\n    ding\n    echo -e \"${Error}ERROR 4${Off} Host db file not found!\" && exit 4\nfi\n# Don't check .db.new as new installs don't have a .db.new file\n\n\ngetdbtype(){ \n    # Detect drive db type\n    # Synology misspelt compatibility as compatbility\n    if grep -q -F '{\"disk_compatbility_info\":' \"$1\"; then\n        # DSM 7 drive db files start with {\"disk_compatbility_info\":\n        dbtype=7\n    elif grep -q -F '{\"success\":1,\"list\":[' \"$1\"; then\n        # DSM 6 drive db files start with {\"success\":1,\"list\":[\n        dbtype=6\n    elif [[ ! $1 =~ .*'.db.new' ]]; then\n        if [[ $(stat -c%s \"$1\") -eq \"0\" ]]; then\n            echo -e \"${Error}ERROR${Off} $(basename -- \"${1}\") is 0 bytes!\" >&2\n        else\n            echo -e \"${Error}ERROR${Off} Unknown database type $(basename -- \"${1}\")!\" >&2\n        fi\n        dbtype=1\n    else\n        dbtype=1\n    fi\n    #echo \"db type: $dbtype\" >&2  # debug\n}\n\n\nbackupdb(){ \n    # Backup database file if needed\n    if [[ ! -f \"$1.bak\" ]]; then\n        if [[ $(basename \"$1\") == \"synoinfo.conf\" ]]; then\n            echo \"\" >&2  # Formatting for stdout\n        fi\n        if [[ $2 == \"long\" ]]; then\n            fname=\"$1\"\n        else\n            fname=$(basename -- \"${1}\")\n        fi\n        if cp -p \"$1\" \"$1.bak\"; then\n            echo -e \"Backed up ${fname}\" >&2\n        else\n            echo -e \"${Error}ERROR 5${Off} Failed to backup ${fname}!\" >&2\n            return 1\n        fi\n    fi\n    # Fix permissions if needed\n    octal=$(stat -c \"%a %n\" \"$1\" | cut -d\" \" -f1)\n    if [[ ! $octal -eq 644 ]]; then\n        chmod 644 \"$1\"\n    fi\n    return 0\n}\n\n\n# Backup host database file if needed\nfor i in \"${!db1list[@]}\"; do\n    backupdb \"${db1list[i]}\" ||{\n        ding\n        exit 5\n        }\ndone\nfor i in \"${!db2list[@]}\"; do\n    backupdb \"${db2list[i]}\" ||{\n        ding\n        exit 5  # maybe don't exit for .db.new file\n        }\ndone\n\n\n#------------------------------------------------------------------------------\n# Edit db files\n\neditcount(){ \n    # Count drives added to host db files\n    if [[ $1 =~ .*\\.db$ ]]; then\n        db1Edits=$((db1Edits +1))\n    elif [[ $1 =~ .*\\.db.new ]]; then\n        db2Edits=$((db2Edits +1))\n    fi\n}\n\n\neditdb7(){ \n    if [[ $1 == \"append\" ]]; then  # model not in db file\n        #if sed -i \"s/}}}/}},\\\"$hdmodel\\\":{$fwstrng$default/\" \"$2\"; then  # append\n        if sed -i \"s/}}}/}},\\\"${hdmodel//\\//\\\\/}\\\":{$fwstrng$default/\" \"$2\"; then  # append\n            echo -e \"Added ${Yellow}$hdmodel${Off} to ${Cyan}$(basename -- \"$2\")${Off}\"\n            editcount \"$2\"\n        else\n            echo -e \"\\n${Error}ERROR 6a${Off} Failed to update $(basename -- \"$2\")${Off}\"\n            #exit 6\n        fi\n\n    elif [[ $1 == \"insert\" ]]; then  # model and default exists\n        #if sed -i \"s/\\\"$hdmodel\\\":{/\\\"$hdmodel\\\":{$fwstrng/\" \"$2\"; then  # insert firmware\n        if sed -i \"s/\\\"${hdmodel//\\//\\\\/}\\\":{/\\\"${hdmodel//\\//\\\\/}\\\":{$fwstrng/\" \"$2\"; then  # insert firmware\n            echo -e \"Updated ${Yellow}$hdmodel${Off} in ${Cyan}$(basename -- \"$2\")${Off}\"\n            #editcount \"$2\"\n        else\n            echo -e \"\\n${Error}ERROR 6b${Off} Failed to update $(basename -- \"$2\")${Off}\"\n            #exit 6\n        fi\n\n    elif [[ $1 == \"empty\" ]]; then  # db file only contains {}\n        #if sed -i \"s/{}/{\\\"$hdmodel\\\":{$fwstrng${default}}/\" \"$2\"; then  # empty\n        #if sed -i \"s/{}/{\\\"${hdmodel//\\//\\\\/}\\\":{$fwstrng${default}}/\" \"$2\"; then  # empty\n        if sed -i \"s/{}/{\\\"${hdmodel//\\//\\\\/}\\\":{$fwstrng${default}/\" \"$2\"; then  # empty\n            echo -e \"Added ${Yellow}$hdmodel${Off} to ${Cyan}$(basename -- \"$2\")${Off}\"\n            editcount \"$2\"\n        else\n            echo -e \"\\n${Error}ERROR 6c${Off} Failed to update $(basename -- \"$2\")${Off}\"\n            #exit 6\n        fi\n    fi\n}\n\n\nupdatedb(){ \n    hdmodel=$(printf \"%s\" \"$1\" | cut -d\",\" -f 1)\n    fwrev=$(printf \"%s\" \"$1\" | cut -d\",\" -f 2)\n    size_gb=$(printf \"%s\" \"$1\" | cut -d\",\" -f 3)\n\n    #echo arg1 \"$1\" >&2           # debug\n    #echo arg2 \"$2\" >&2           # debug\n    #echo hdmodel \"$hdmodel\" >&2  # debug\n    #echo fwrev \"$fwrev\" >&2      # debug\n\n    # Check if db file is new or old style\n    getdbtype \"$2\"\n\n    if [[ $dbtype -gt \"6\" ]]; then\n        # db type 7 used from DSM 7.1 and later\n        if grep -q \"$hdmodel\"'\":{\"'\"$fwrev\" \"$2\"; then\n            echo -e \"${Yellow}$hdmodel${Off} already exists in ${Cyan}$(basename -- \"$2\")${Off}\" >&2\n        else\n            common_string=\\\"size_gb\\\":$size_gb,\n            common_string=\"$common_string\"\\\"compatibility_interval\\\":[{\n            common_string=\"$common_string\"\\\"compatibility\\\":\\\"support\\\",\n            common_string=\"$common_string\"\\\"not_yet_rolling_status\\\":\\\"support\\\",\n            common_string=\"$common_string\"\\\"fw_dsm_update_status_notify\\\":false,\n            common_string=\"$common_string\"\\\"barebone_installable\\\":true,\n            common_string=\"$common_string\"\\\"barebone_installable_v2\\\":\\\"auto\\\",\n            common_string=\"$common_string\"\\\"smart_test_ignore\\\":false,\n            common_string=\"$common_string\"\\\"smart_attr_ignore\\\":false\n\n            fwstrng=\\\"$fwrev\\\":{\n            fwstrng=\"$fwstrng$common_string\"\n            fwstrng=\"$fwstrng\"}]},\n\n            default=\\\"default\\\":{\n            default=\"$default$common_string\"\n            default=\"$default\"}]}}}\n\n            # Synology misspelt compatibility as compatbility\n            if grep -q '\"disk_compatbility_info\":{}' \"$2\"; then\n                # Replace \"disk_compatbility_info\":{} with\n                # \"disk_compatbility_info\":{\"WD40PURX-64GVNY0\":{\"80.00A80\":{ ... }}},\"default\":{ ... }}}}\n                #echo \"Edit empty db file:\"  # debug\n                editdb7 \"empty\" \"$2\"\n\n            elif grep -q '\"'\"$hdmodel\"'\":' \"$2\"; then\n                # Replace \"WD40PURX-64GVNY0\":{ with \"WD40PURX-64GVNY0\":{\"80.00A80\":{ ... }}},\n                #echo \"Insert firmware version:\"  # debug\n                editdb7 \"insert\" \"$2\"\n\n            else\n                # Add \"WD40PURX-64GVNY0\":{\"80.00A80\":{ ... }}},\"default\":{ ... }}}\n                #echo \"Append drive and firmware:\"  # debug\n                editdb7 \"append\" \"$2\"\n            fi\n        fi\n\n        # Edit existing drives in db with compatibility:unverified  # Issue #224\n        if grep -q 'unverified' \"$2\"; then\n            sed -i 's/unverified/support/g' \"$2\"\n            if ! grep -q 'unverified' \"$2\"; then\n                echo -e \"Edited unverified drives in ${Cyan}$(basename -- \"$2\")${Off}\" >&2\n            fi\n        fi\n\n        # Edit existing drives in db with compatibility:not_support\n        if [[ $incompatible == \"yes\" ]]; then\n            if grep -q 'not_support' \"$2\"; then\n                sed -i 's/not_support/support/g' \"$2\"\n                if ! grep -q 'not_support' \"$2\"; then\n                    echo -e \"Edited incompatible drives in ${Cyan}$(basename -- \"$2\")${Off}\" >&2\n                fi\n            fi\n        fi\n    elif [[ $dbtype -eq \"6\" ]]; then\n        # db type 6 used up to DSM 7.0.1\n        if grep -q \"$hdmodel\" \"$2\"; then\n            echo -e \"${Yellow}$hdmodel${Off} already exists in ${Cyan}$(basename -- \"$2\")${Off}\" >&2\n        else\n            # example:\n            # {\"model\":\"WD60EFRX-68MYMN1\",\"firmware\":\"82.00A82\",\"rec_intvl\":[1]},\n            # Don't need to add firmware version?\n            #string=\"{\\\"model\\\":\\\"${hdmodel}\\\",\\\"firmware\\\":\\\"${fwrev}\\\",\\\"rec_intvl\\\":\\[1\\]},\"\n            string=\"{\\\"model\\\":\\\"${hdmodel}\\\",\\\"firmware\\\":\\\"\\\",\\\"rec_intvl\\\":\\[1\\]},\"\n            # {\"success\":1,\"list\":[\n            startstring=\"{\\\"success\\\":1,\\\"list\\\":\\[\"\n            # example:\n            # {\"success\":1,\"list\":[{\"model\":\"WD60EFRX-68MYMN1\",\"firmware\":\"82.00A82\",\"rec_intvl\":[1]},\n            #if sed -i \"s/$startstring/$startstring$string/\" \"$2\"; then\n            #if sed -i \"s/${startstring//\\//\\\\/}/${startstring//\\//\\\\/}$string/\" \"$2\"; then\n            if sed -i \"s/$startstring/$startstring${string//\\//\\\\/}/\" \"$2\"; then\n                echo -e \"Added ${Yellow}$hdmodel${Off} to ${Cyan}$(basename -- \"$2\")${Off}\"\n            else\n                ding\n                echo -e \"\\n${Error}ERROR 8${Off} Failed to update $(basename -- \"$2\")${Off}\" >&2\n                exit 8\n            fi\n        fi\n    fi\n}\n\n\n# Fix ,, instead of , bug caused by v3.3.75\nif [[ \"${#db1list[@]}\" -gt \"0\" ]]; then\n    for i in \"${!db1list[@]}\"; do\n        sed -i \"s/,,/,/\"  \"${db1list[i]}\"\n    done\nfi\nif [[ \"${#db2list[@]}\" -gt \"0\" ]]; then\n    for i in \"${!db2list[@]}\"; do\n        sed -i \"s/,,/,/\"  \"${db2list[i]}\"\n    done\nfi\n\n# HDDs and SATA SSDs\nnum=\"0\"\nwhile [[ $num -lt \"${#hdds[@]}\" ]]; do\n    for i in \"${!db1list[@]}\"; do\n        updatedb \"${hdds[$num]}\" \"${db1list[i]}\"\n    done\n    for i in \"${!db2list[@]}\"; do\n        updatedb \"${hdds[$num]}\" \"${db2list[i]}\"\n    done\n\n    #------------------------------------------------\n    # Expansion Units\n    for i in \"${!eunitdb1list[@]}\"; do\n        backupdb \"${eunitdb1list[i]}\" &&\\\n            updatedb \"${hdds[$num]}\" \"${eunitdb1list[i]}\"\n    done\n    for i in \"${!eunitdb2list[@]}\"; do\n        backupdb \"${eunitdb2list[i]}\" &&\\\n            updatedb \"${hdds[$num]}\" \"${eunitdb2list[i]}\"\n    done\n    #------------------------------------------------\n\n    num=$((num +1))\ndone\n\n# M.2 NVMe/SATA drives\nnum=\"0\"\nwhile [[ $num -lt \"${#nvmes[@]}\" ]]; do\n    for i in \"${!db1list[@]}\"; do\n        updatedb \"${nvmes[$num]}\" \"${db1list[i]}\"\n    done\n    for i in \"${!db2list[@]}\"; do\n        updatedb \"${nvmes[$num]}\" \"${db2list[i]}\"\n    done\n\n    #------------------------------------------------\n    # M.2 adaptor cards\n    for i in \"${!m2carddb1list[@]}\"; do\n        backupdb \"${m2carddb1list[i]}\" &&\\\n            updatedb \"${nvmes[$num]}\" \"${m2carddb1list[i]}\"\n    done\n    for i in \"${!m2carddb2list[@]}\"; do\n        backupdb \"${m2carddb2list[i]}\" &&\\\n            updatedb \"${nvmes[$num]}\" \"${m2carddb2list[i]}\"\n    done\n    #------------------------------------------------\n\n    num=$((num +1))\ndone\n\n\n#------------------------------------------------------------------------------\n# Enable unsupported Synology M2 PCIe cards\n\nenable_card(){ \n    # $1 is the file\n    # $2 is the section\n    # $3 is the card model and mode\n    if [[ -f $1 ]] && [[ -n $2 ]] && [[ -n $3 ]]; then\n        backupdb \"$adapter_cards\" long\n        backupdb \"$adapter_cards2\" long\n\n        # Check if section exists\n        if ! grep -q '^\\['\"$2\"'\\]$' \"$1\"; then\n            echo -e \"Section [$2] not found in $(basename -- \"$1\")!\" >&2\n            return\n        fi\n        # Check if already enabled\n        #\n        # No idea if \"cat /proc/sys/kernel/syno_hw_version\" returns upper or lower case RP\n        # \"/usr/syno/etc.defaults/adapter_cards.conf\" uses lower case rp but upper case RS\n        # So we'll convert RP to rp when needed.\n        #\n        modelrplowercase=${modelname//RP/rp}\n        val=$(/usr/syno/bin/get_section_key_value \"$1\" \"$2\" \"$modelrplowercase\")\n        if [[ $val != \"yes\" ]]; then\n            # /usr/syno/etc.defaults/adapter_cards.conf\n            if /usr/syno/bin/set_section_key_value \"$1\" \"$2\" \"$modelrplowercase\" yes; then\n                # /usr/syno/etc/adapter_cards.conf\n                /usr/syno/bin/set_section_key_value \"$adapter_cards2\" \"$2\" \"$modelrplowercase\" yes\n                echo -e \"Enabled ${Yellow}$3${Off} for ${Cyan}$modelname${Off}\" >&2\n                rebootmsg=yes\n            else\n                echo -e \"${Error}ERROR 9${Off} Failed to enable $3 for ${modelname}!\" >&2\n            fi\n        else\n            echo -e \"${Yellow}$3${Off} already enabled for ${Cyan}$modelname${Off}\" >&2\n        fi\n    fi\n}\n\ndts_m2_card(){ \n# $1 is the card model\n# $2 is the dts file\n\n# Remove last }; so we can append to dts file\nsed -i '/^};/d' \"$2\"\n\n# Append PCIe M.2 card node to dts file\nif [[ $1 == E10M20-T1 ]] || [[ $1 == M2D20 ]]; then\n    cat >> \"$2\" <<EOM2D\n\n\t$1 {\n\t\tcompatible = \"Synology\";\n\t\tmodel = \"synology_${1,,}\";\n\t\tpower_limit = \"14.85,14.85\";\n\n\t\tm2_card@1 {\n\n\t\t\tnvme {\n\t\t\t\tpcie_postfix = \"00.0,08.0,00.0\";\n\t\t\t\tport_type = \"ssdcache\";\n\t\t\t};\n\t\t};\n\n\t\tm2_card@2 {\n\n\t\t\tnvme {\n\t\t\t\tpcie_postfix = \"00.0,04.0,00.0\";\n\t\t\t\tport_type = \"ssdcache\";\n\t\t\t};\n\t\t};\n\t};\n};\nEOM2D\n\nelif [[ $1 == M2D18 ]]; then\n    cat >> \"$2\" <<EOM2D18\n\n\tM2D18 {\n\t\tcompatible = \"Synology\";\n\t\tmodel = \"synology_m2d18\";\n\t\tpower_limit = \"9.9,9.9\";\n\n\t\tm2_card@1 {\n\n\t\t\tahci {\n\t\t\t\tpcie_postfix = \"00.0,03.0,00.0\";\n\t\t\t\tata_port = <0x00>;\n\t\t\t};\n\n\t\t\tnvme {\n\t\t\t\tpcie_postfix = \"00.0,04.0,00.0\";\n\t\t\t\tport_type = \"ssdcache\";\n\t\t\t};\n\t\t};\n\n\t\tm2_card@2 {\n\n\t\t\tahci {\n\t\t\t\tpcie_postfix = \"00.0,03.0,00.0\";\n\t\t\t\tata_port = <0x01>;\n\t\t\t};\n\n\t\t\tnvme {\n\t\t\t\tpcie_postfix = \"00.0,05.0,00.0\";\n\t\t\t\tport_type = \"ssdcache\";\n\t\t\t};\n\t\t};\n\t};\n};\nEOM2D18\n\nelif [[ $1 == M2D17 ]]; then\n    cat >> \"$2\" <<EOM2D17\n\n\tM2D17 {\n\t\tcompatible = \"Synology\";\n\t\tmodel = \"synology_m2d17\";\n\t\tpower_limit = \"9.9,9.9\";\n\n\t\tm2_card@1 {\n\n\t\t\tahci {\n\t\t\t\tpcie_postfix = \"00.0,03.0,00.0\";\n\t\t\t\tata_port = <0x00>;\n\t\t\t};\n\t\t};\n\n\t\tm2_card@2 {\n\n\t\t\tahci {\n\t\t\t\tpcie_postfix = \"00.0,03.0,00.0\";\n\t\t\t\tata_port = <0x01>;\n\t\t\t};\n\t\t};\n\t};\n};\nEOM2D17\n\nfi\n}\n\nis_schedule_running(){ \n    # $1 is script's filename. e.g. syno_hdd_db.sh etc\n    local file=\"/usr/syno/etc/esynoscheduler/esynoscheduler.db\"\n    local rows offset task status pid result\n\n    # Get number of rows in database\n    rows=$(sqlite3 \"${file}\" <<ECNT\nSELECT COUNT(*) from task;\n.quit\nECNT\n)\n    # Check if script is running from task scheduler\n    offset=\"0\"\n    while [[ $rows != \"$offset\" ]]; do\n        task=$(sqlite3 \"$file\" \"SELECT operation FROM task WHERE rowid = (SELECT rowid FROM task LIMIT 1 OFFSET ${offset});\")\n        if echo \"$task\" | grep -q \"$1\"; then\n            status=$(sqlite3 \"$file\" \"SELECT status FROM task WHERE rowid = (SELECT rowid FROM task LIMIT 1 OFFSET ${offset});\")\n            pid=$(echo \"$status\" | cut -d\"[\" -f2 | cut -d\"]\" -f1)\n            if [[ $pid -gt \"0\" ]]; then\n                result=$((result +pid))\n            fi\n        fi\n        offset=$((offset +1))\n    done\n    [ -n \"$result\" ] || return 1\n}\n\ninstall_binfile(){ \n    # install_binfile <file> <file-url> <destination> <chmod> <bundled-path> <hash>\n    # example:\n    #  file_url=\"https://raw.githubusercontent.com/${repo}/main/bin/dtc\"\n    #  install_binfile dtc \"$file_url\" /usr/bin/dtc a+x bin/dtc\n\n    if [[ -f \"${scriptpath}/$5\" ]]; then\n        binfile=\"${scriptpath}/$5\"\n        echo -e \"\\nInstalling ${1}\"\n    elif [[ -f \"${scriptpath}/$(basename -- \"$5\")\" ]]; then\n        binfile=\"${scriptpath}/$(basename -- \"$5\")\"\n        echo -e \"\\nInstalling ${1}\"\n    else\n        # Download binfile\n        if [[ $autoupdate == \"yes\" ]]; then\n            reply=y\n        elif is_schedule_running \"$(basename -- \"$0\")\"; then\n            reply=y\n        else\n            echo -e \"\\nNeed to download ${1}\"\n            echo -e \"${Cyan}Do you want to download ${1}?${Off} [y/n]\"\n            read -r -t 30 reply\n        fi\n        if [[ ${reply,,} == \"y\" ]]; then\n            echo -e \"\\nDownloading ${1}\"\n            if ! curl -kL -m 30 --connect-timeout 5 \"$2\" -o \"/tmp/$1\"; then\n                echo -e \"${Error}ERROR${Off} Failed to download ${1}!\"\n                return\n            fi\n            binfile=\"/tmp/${1}\"\n\n            printf \"Downloaded md5: \"\n            md5sum -b \"$binfile\" | awk '{print $1}'\n\n            md5=$(md5sum -b \"$binfile\" | awk '{print $1}')\n            if [[ $md5 != \"$6\" ]]; then\n                echo \"Expected md5:   $6\"\n                echo -e \"${Error}ERROR${Off} Downloaded $1 md5 hash does not match!\"\n                exit 1\n            fi\n        else\n            echo -e \"${Error}ERROR${Off} Cannot add M2 PCIe card without ${1}!\"\n            exit 1\n        fi\n    fi\n\n    # Set binfile executable\n    chmod \"$4\" \"$binfile\"\n\n    # Copy binfile to destination\n    cp -p \"$binfile\" \"$3\"\n}\n\nedit_modeldtb(){ \n    # $1 is E10M20-T1 or M2D20 or M2D18 or M2D17\n    if [[ -f /etc.defaults/model.dtb ]]; then  # Is device tree model\n        # Check if dtc exists and is executable\n        if [[ ! -x $(which dtc) ]]; then\n            md5hash=\"01381dabbe86e13a2f4a8017b5552918\"\n            branch=\"main\"\n            file_url=\"https://raw.githubusercontent.com/${repo}/${branch}/bin/dtc\"\n            # install_binfile <file> <file-url> <destination> <chmod> <bundled-path> <hash>\n            install_binfile dtc \"$file_url\" /usr/sbin/dtc \"a+x\" bin/dtc \"$md5hash\"\n        fi\n\n        # Check again if dtc exists and is executable\n        if [[ -x /usr/sbin/dtc ]]; then\n\n            # Backup model.dtb\n            backupdb \"$dtb_file\" long\n\n            # Output model.dtb to model.dts\n            dtc -q -I dtb -O dts -o \"$dts_file\" \"$dtb_file\"  # -q Suppress warnings\n            chmod 644 \"$dts_file\"\n\n            # Edit model.dts\n            for c in \"${cards[@]}\"; do\n                # Edit model.dts if needed\n                if ! grep -q \"$c\" \"$dtb_file\"; then\n                    dts_m2_card \"$c\" \"$dts_file\"\n                    echo -e \"Added ${Yellow}$c${Off} to ${Cyan}model${hwrev}.dtb${Off}\" >&2\n                else\n                    echo -e \"${Yellow}$c${Off} already exists in ${Cyan}model${hwrev}.dtb${Off}\" >&2\n                fi\n            done\n\n            # Compile model.dts to model.dtb\n            dtc -q -I dts -O dtb -o \"$dtb_file\" \"$dts_file\"  # -q Suppress warnings\n\n            # Set owner and permissions for model.dtb\n            chmod a+r \"$dtb_file\"\n            chown root:root \"$dtb_file\"\n            cp -pu \"$dtb_file\" \"$dtb2_file\"  # Copy dtb file to /etc\n            rebootmsg=yes\n        else\n            echo -e \"${Error}ERROR${Off} Missing /usr/sbin/dtc or not executable!\" >&2\n        fi\n    fi\n}\n\n\nfor c in \"${m2cards[@]}\"; do\n    case \"$c\" in\n        E10M20-T1)\n            echo \"\"\n            enable_card \"$adapter_cards\" E10M20-T1_sup_nic \"E10M20-T1 NIC\"\n            enable_card \"$adapter_cards\" E10M20-T1_sup_nvme \"E10M20-T1 NVMe\"\n            #enable_card \"$adapter_cards\" E10M20-T1_sup_sata \"E10M20-T1 SATA\"\n            cards=(E10M20-T1) && edit_modeldtb\n        ;;\n        M2D20)\n            echo \"\"\n            enable_card \"$adapter_cards\" M2D20_sup_nvme \"M2D20 NVMe\"\n            cards=(M2D20) && edit_modeldtb\n        ;;\n        M2D18)\n            echo \"\"\n            enable_card \"$adapter_cards\" M2D18_sup_nvme \"M2D18 NVMe\"\n            enable_card \"$adapter_cards\" M2D18_sup_sata \"M2D18 SATA\"\n            cards=(M2D18) && edit_modeldtb\n        ;;\n        M2D17)\n            echo \"\"\n            enable_card \"$adapter_cards\" M2D17_sup_sata \"M2D17 SATA\"\n            cards=(M2D17) && edit_modeldtb\n        ;;\n        *)\n            echo \"Unknown M2 card type: $c\"\n        ;;\n    esac\ndone\n\n\n#------------------------------------------------------------------------------\n# Set or restore writemostly\n\nif [[ $ssd == \"yes\" ]]; then\n    # Get array of internal drives\n    readarray -t internal_drives < <(synodisk --enum -t internal | grep 'Disk path' | cut -d\"/\" -f3)\n\n    if [[ $ssd_restore == \"yes\" ]]; then\n        # Restore all internal drives to just in_sync\n        echo -e \"\\nRestoring internal drive's state\"\n        for idrive in \"${internal_drives[@]}\"; do\n            #if ! grep -q \"write_mostly\"; then \n                set_writemostly -writemostly \"$idrive\"\n            #fi\n        done\n\n    elif [[ ${#ssds_writemostly[@]} -gt \"0\" ]]; then\n        # User specified their fast drive(s)\n        echo -e \"\\nSetting slow internal HDDs state to write_mostly\"\n        for idrive in \"${internal_drives[@]}\"; do\n            if [[ ! ${ssds_writemostly[*]} =~ $idrive ]]; then\n                set_writemostly writemostly \"$idrive\"\n            fi\n        done\n\n    else\n        # Get list of internal HDDs and qty of SSDs\n        internal_ssd_qty=\"0\"\n        for idrive in \"${internal_drives[@]}\"; do\n            if synodisk --isssd /dev/\"${idrive:?}\" >/dev/null; then\n                # exit code 0 = is not SSD\n                # exit code 1 = is SSD\n\n                # Add internal HDDs to array\n                internal_hdds+=(\"$idrive\")\n            else\n                # Count number of internal 2.5 inch SSDs\n                internal_ssd_qty=$((internal_ssd_qty +1))\n            fi\n        done\n\n        # Set HDDs to writemostly if there's also internal SSDs\n        if [[ $internal_ssd_qty -gt \"0\" ]] && [[ ${#internal_hdds[@]} -gt \"0\" ]]; then\n            # There are internal SSDs and HDDs\n            echo -e \"\\nSetting internal HDDs state to write_mostly\"\n            for idrive in \"${internal_hdds[@]}\"; do\n                set_writemostly writemostly \"$idrive\"\n            done\n        fi\n    fi\nfi\n\n\n#------------------------------------------------------------------------------\n# Edit /etc.defaults/synoinfo.conf\n\n# Backup synoinfo.conf if needed\nbackupdb \"$synoinfo\" ||{\n    ding\n    exit 9\n}\n\n# Optionally disable \"support_disk_compatibility\"\nsdc=support_disk_compatibility\nsetting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo $sdc)\"\nif [[ $force == \"yes\" ]]; then\n    if [[ $setting == \"yes\" ]]; then\n        # Disable support_disk_compatibility\n        /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$sdc\" \"no\"\n        setting=\"$(/usr/syno/bin/synogetkeyvalue \"$synoinfo\" $sdc)\"\n        if [[ $setting == \"no\" ]]; then\n            echo -e \"\\nDisabled support disk compatibility.\"\n        fi\n    elif [[ $setting == \"no\" ]]; then\n        echo -e \"\\nSupport disk compatibility already disabled.\"\n    fi\nelse\n    if [[ $setting == \"no\" ]]; then\n        # Enable support_disk_compatibility\n        /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$sdc\" \"yes\"\n        setting=\"$(/usr/syno/bin/synogetkeyvalue \"$synoinfo\" $sdc)\"\n        if [[ $setting == \"yes\" ]]; then\n            echo -e \"\\nRe-enabled support disk compatibility.\"\n        fi\n    elif [[ $setting == \"yes\" ]]; then\n        echo -e \"\\nSupport disk compatibility already enabled.\"\n    fi\nfi\n\n\n# Optionally disable memory compatibility warnings\nsmc=support_memory_compatibility\nsetting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo $smc)\"\nsettingbak=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo.bak $smc)\"\n\nif [[ -z $settingbak ]] || [[ -z $setting ]]; then\n    # For older models that don't use \"support_memory_compatibility\"\n    memcheck=\"/usr/lib/systemd/system/SynoMemCheck.service\"\n    memcheck_value=\"$(/usr/syno/bin/synosetkeyvalue \"$memcheck\" ExecStart)\"\n    if [[ $ram == \"yes\" ]]; then\n        if [[ $memcheck_value == \"/usr/syno/bin/syno_mem_check\" ]]; then\n            # Disable SynoMemCheck.service\n            /usr/syno/bin/synosetkeyvalue \"$memcheck\" ExecStart /bin/true\n            memcheck_value=\"$(/usr/syno/bin/synosetkeyvalue \"$memcheck\" ExecStart)\"\n            if [[ $memcheck_value == \"/bin/true\" ]]; then\n                echo -e \"\\nDisabled SynoMemCheck memory compatibility.\"\n            fi\n        elif [[ $memcheck_value == \"/bin/true\" ]]; then\n            echo -e \"\\nSynoMemCheck memory compatibility already disabled.\"\n        fi\n    else\n        if [[ $memcheck_value == \"/bin/true\" ]]; then\n            # Enable SynoMemCheck.service\n            /usr/syno/bin/synosetkeyvalue \"$memcheck\" ExecStart /usr/syno/bin/syno_mem_check\n            memcheck_value=\"$(/usr/syno/bin/synosetkeyvalue \"$memcheck\" ExecStart)\"\n            if [[ $memcheck_value == \"/usr/syno/bin/syno_mem_check\" ]]; then\n                echo -e \"\\nRe-enabled SynoMemCheck memory compatibility.\"\n            fi\n        elif [[ $memcheck_value == \"/usr/syno/bin/syno_mem_check\" ]]; then\n            echo -e \"\\nSynoMemCheck memory compatibility already enabled.\"\n        fi\n    fi\nelse\n    # Disable \"support_memory_compatibility\" (not for older models)\n    if [[ $ram == \"yes\" ]]; then\n        if [[ $setting == \"yes\" ]]; then\n            # Disable support_memory_compatibility\n            /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$smc\" \"no\"\n            setting=\"$(/usr/syno/bin/synogetkeyvalue \"$synoinfo\" $smc)\"\n            if [[ $setting == \"no\" ]]; then\n                echo -e \"\\nDisabled support memory compatibility.\"\n            fi\n        elif [[ $setting == \"no\" ]]; then\n            echo -e \"\\nSupport memory compatibility already disabled.\"\n        fi\n    else\n        if [[ $setting == \"no\" ]]; then\n            # Enable support_memory_compatibility\n            /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$smc\" \"yes\"\n            setting=\"$(/usr/syno/bin/synogetkeyvalue \"$synoinfo\" $smc)\"\n            if [[ $setting == \"yes\" ]]; then\n                echo -e \"\\nRe-enabled support memory compatibility.\"\n            fi\n        elif [[ $setting == \"yes\" ]]; then\n            echo -e \"\\nSupport memory compatibility already enabled.\"\n        fi\n    fi\nfi\n\n# Optionally set mem_max_mb to the amount of installed memory\nif [[ $dsm -gt \"6\" ]]; then  # DSM 6 as has no dmidecode\n    if [[ $ram == \"yes\" ]] && [[ -f /usr/sbin/dmidecode ]]; then\n        # Get total amount of installed memory\n        #IFS=$'\\n' read -r -d '' -a array < <(dmidecode -t memory | grep \"[Ss]ize\")  # GitHub issue #86, 87\n        IFS=$'\\n' read -r -d '' -a array < <(dmidecode -t memory |\\\n            grep -E \"[Ss]ize: [0-9]+ [MG]{1}[B]{1}$\")  # GitHub issue #86, 87, 106\n        if [[ ${#array[@]} -gt \"0\" ]]; then\n            num=\"0\"\n            while [[ $num -lt \"${#array[@]}\" ]]; do\n                check=$(printf %s \"${array[num]}\" | awk '{print $1}')\n                if [[ ${check,,} == \"size:\" ]]; then\n                    ramsize=$(printf %s \"${array[num]}\" | awk '{print $2}')           # GitHub issue #86, 87\n                    bytes=$(printf %s \"${array[num]}\" | awk '{print $3}')             # GitHub issue #86, 87\n                    if [[ $ramsize =~ ^[0-9]+$ ]]; then  # Check $ramsize is numeric  # GitHub issue #86, 87\n                        if [[ $bytes == \"GB\" ]]; then    # DSM 7.2 dmidecode returned GB\n                            ramsize=$((ramsize * 1024))  # Convert to MB              # GitHub issue #107\n                        fi\n                        if [[ $ramtotal ]]; then\n                            ramtotal=$((ramtotal +ramsize))\n                        else\n                            ramtotal=\"$ramsize\"\n                        fi\n                    fi\n                fi\n                num=$((num +1))\n            done\n        fi\n        # Set mem_max_mb to the amount of installed memory\n        setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo mem_max_mb)\"\n        settingbak=\"$(/usr/syno/bin/synogetkeyvalue ${synoinfo}.bak mem_max_mb)\"      # GitHub issue #107\n        if [[ $ramtotal =~ ^[0-9]+$ ]]; then   # Check $ramtotal is numeric\n            if [[ $ramtotal -gt \"$setting\" ]]; then\n                /usr/syno/bin/synosetkeyvalue \"$synoinfo\" mem_max_mb \"$ramtotal\"\n                # Check we changed mem_max_mb\n                setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo mem_max_mb)\"\n                if [[ $ramtotal == \"$setting\" ]]; then\n                    #echo -e \"\\nSet max memory to $ramtotal MB.\"\n                    ramgb=$((ramtotal / 1024))\n                    echo -e \"\\nSet max memory to $ramgb GB.\"\n                else\n                    echo -e \"\\n${Error}ERROR${Off} Failed to change max memory!\"\n                fi\n\n            elif [[ $setting -gt \"$ramtotal\" ]] && [[ $setting -gt \"$settingbak\" ]];  # GitHub issue #107 \n            then\n                # Fix setting is greater than both ramtotal and default in syninfo.conf.bak\n                /usr/syno/bin/synosetkeyvalue \"$synoinfo\" mem_max_mb \"$settingbak\"\n                # Check we restored mem_max_mb\n                setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo mem_max_mb)\"\n                if [[ $settingbak == \"$setting\" ]]; then\n                    #echo -e \"\\nSet max memory to $ramtotal MB.\"\n                    ramgb=$((ramtotal / 1024))\n                    echo -e \"\\nRestored max memory to $ramgb GB.\"\n                else\n                    echo -e \"\\n${Error}ERROR${Off} Failed to restore max memory!\"\n                fi\n\n            elif [[ $ramtotal == \"$setting\" ]]; then\n                #echo -e \"\\nMax memory already set to $ramtotal MB.\"\n                ramgb=$((ramtotal / 1024))\n                echo -e \"\\nMax memory already set to $ramgb GB.\"\n            else [[ $ramtotal -lt \"$setting\" ]]\n                #echo -e \"\\nMax memory is set to $setting MB.\"\n                ramgb=$((setting / 1024))\n                echo -e \"\\nMax memory is set to $ramgb GB.\"\n            fi\n        else\n            echo -e \"\\n${Error}ERROR${Off} Total memory size is not numeric: '$ramtotal'\"\n        fi\n    fi\nfi\n\n\n# Enable nvme support\n# shellcheck disable=SC2010  # Don't warn about \"Don't use ls | grep\"\nif ls /dev | grep -q nvme; then\n    if [[ $m2 != \"no\" ]]; then\n        # Check if nvme support is enabled\n        setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo supportnvme)\"\n        enabled=\"\"\n        if [[ ! $setting ]]; then\n            # Add supportnvme=\"yes\"\n            /usr/syno/bin/synosetkeyvalue \"$synoinfo\" supportnvme \"yes\"\n            enabled=\"yes\"\n        elif [[ $setting == \"no\" ]]; then\n            # Change supportnvme=\"no\" to \"yes\"\n            /usr/syno/bin/synosetkeyvalue \"$synoinfo\" supportnvme \"yes\"\n            enabled=\"yes\"\n        elif [[ $setting == \"yes\" ]]; then\n            echo -e \"\\nNVMe support already enabled.\"\n        fi\n\n        # Check if we enabled nvme support\n        setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo supportnvme)\"\n        if [[ $enabled == \"yes\" ]]; then\n            if [[ $setting == \"yes\" ]]; then\n                echo -e \"\\nEnabled NVMe support.\"\n            else\n                echo -e \"\\n${Error}ERROR${Off} Failed to enable NVMe support!\"\n            fi\n        fi\n    fi\nfi\n\n\n# Enable m2 volume support\n# shellcheck disable=SC2010  # Don't warn about \"Don't use ls | grep\"\nif ls /dev | grep -q \"nv[cm]\"; then\n    if [[ $m2 != \"no\" ]]; then\n        if [[ $m2exists == \"yes\" ]]; then\n            # Check if m2 volume support is enabled\n            smp=support_m2_pool\n            setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo ${smp})\"\n            enabled=\"\"\n            if [[ ! $setting ]]; then\n                # Add support_m2_pool=\"yes\"\n                #echo 'support_m2_pool=\"yes\"' >> \"$synoinfo\"\n                /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$smp\" \"yes\"\n                enabled=\"yes\"\n            elif [[ $setting == \"no\" ]]; then\n                # Change support_m2_pool=\"no\" to \"yes\"\n                /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$smp\" \"yes\"\n                enabled=\"yes\"\n            elif [[ $setting == \"yes\" ]]; then\n                echo -e \"\\nM.2 volume support already enabled.\"\n            fi\n\n            # Check if we enabled m2 volume support\n            setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo ${smp})\"\n            if [[ $enabled == \"yes\" ]]; then\n                if [[ $setting == \"yes\" ]]; then\n                    echo -e \"\\nEnabled M.2 volume support.\"\n                else\n                    echo -e \"\\n${Error}ERROR${Off} Failed to enable m2 volume support!\"\n                fi\n            fi\n        fi\n    fi\nfi\n\n\n# Edit synoinfo.conf to prevent drive db updates\ndtu=drive_db_test_url\nurl=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo ${dtu})\"\ndisabled=\"\"\nif [[ $nodbupdate == \"yes\" ]]; then\n    if [[ ! $url ]]; then\n        # Add drive_db_test_url=\"127.0.0.1\"\n        #echo 'drive_db_test_url=\"127.0.0.1\"' >> \"$synoinfo\"\n        /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$dtu\" \"127.0.0.1\"\n        # Junior boot\n        #[ -d /tmpRoot ] && /tmpRoot/usr/syno/bin/synosetkeyvalue /tmpRoot/etc.defaults/synoinfo.conf \"$dtu\" \"127.0.0.1\"\n        if [ -f /tmpRoot/usr/syno/bin/synosetkeyvalue ] && [ -f /tmpRoot/etc.defaults/synoinfo.conf ]; then\n            /tmpRoot/usr/syno/bin/synosetkeyvalue /tmpRoot/etc.defaults/synoinfo.conf \"$dtu\" \"127.0.0.1\"\n        fi\n        disabled=\"yes\"\n    elif [[ $url != \"127.0.0.1\" ]]; then\n        # Edit drive_db_test_url=\n        /usr/syno/bin/synosetkeyvalue \"$synoinfo\" \"$dtu\" \"127.0.0.1\"\n        # Junior boot\n        #[ -d /tmpRoot ] && /tmpRoot/usr/syno/bin/synosetkeyvalue /tmpRoot/etc.defaults/synoinfo.conf \"$dtu\" \"127.0.0.1\"\n        if [ -f /tmpRoot/usr/syno/bin/synosetkeyvalue ] && [ -f /tmpRoot/etc.defaults/synoinfo.conf ]; then\n            /tmpRoot/usr/syno/bin/synosetkeyvalue /tmpRoot/etc.defaults/synoinfo.conf \"$dtu\" \"127.0.0.1\"\n        fi\n        disabled=\"yes\"\n    fi\n\n    # Check if we disabled drive db auto updates\n    url=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo drive_db_test_url)\"\n    if [[ $disabled == \"yes\" ]]; then\n        if [[ $url == \"127.0.0.1\" ]]; then\n            echo -e \"\\nDisabled drive db auto updates.\"\n        else\n            echo -e \"\\n${Error}ERROR${Off} Failed to disable drive db auto updates!\"\n        fi\n    else\n        echo -e \"\\nDrive db auto updates already disabled.\"\n    fi\nelse\n    # Re-enable drive db updates\n    #if [[ $url == \"127.0.0.1\" ]]; then\n    if [[ $url ]]; then\n        # Delete \"drive_db_test_url=127.0.0.1\" line (inc. line break)\n        sed -i \"/drive_db_test_url=*/d\" \"$synoinfo\"\n        sed -i \"/drive_db_test_url=*/d\" /etc/synoinfo.conf\n\n        # Check if we re-enabled drive db auto updates\n        url=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo drive_db_test_url)\"\n        if [[ $url != \"127.0.0.1\" ]]; then\n            echo -e \"\\nRe-enabled drive db auto updates.\"\n        else\n            echo -e \"\\n${Error}ERROR${Off} Failed to enable drive db auto updates!\"\n        fi\n    else\n        echo -e \"\\nDrive db auto updates already enabled.\"\n    fi\nfi\n\n\n# Optionally disable \"support_wdda\"\nsetting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo support_wdda)\"\nif [[ $wdda == \"no\" ]]; then\n    if [[ $setting == \"yes\" ]]; then\n        # Disable support_wdda\n        /usr/syno/bin/synosetkeyvalue \"$synoinfo\" support_wdda \"no\"\n        setting=\"$(/usr/syno/bin/synogetkeyvalue \"$synoinfo\" support_wdda)\"\n        if [[ $setting == \"no\" ]]; then\n            echo -e \"\\nDisabled support WDDA.\"\n        fi\n    elif [[ $setting == \"no\" ]]; then\n        echo -e \"\\nSupport WDDA already disabled.\"\n    fi\nfi\n\n\n# Enable creating pool on drives in M.2 adaptor card\nif [[ -f \"$strgmgr\" ]] && [[ $buildnumber -gt 42962 ]]; then\n    # DSM 7.2 and later\n    if [[ ${#m2cards[@]} -gt \"0\" ]] || [[ $forcepci == \"yes\" ]]; then\n\n        if grep -q 'notSupportM2Pool_addOnCard' \"$strgmgr\"; then\n            # Backup storage_panel.js\"\n\n            if [[ $buildnumber -gt 64570 ]]; then\n                # DSM 7.2.1 and later\n                strgmgrver=\"$(/usr/syno/bin/synopkg version StorageManager)\"\n            elif [[ $buildnumber -ge 64561 ]]; then\n                # DSM 7.2\n                strgmgrver=\"${buildnumber}${smallfixnumber}\"\n            fi\n\n            echo \"\"\n            if [[ ! -f \"${strgmgr}.$strgmgrver\" ]]; then\n                if cp -p \"$strgmgr\" \"${strgmgr}.$strgmgrver\"; then\n                    echo -e \"Backed up $(basename -- \"$strgmgr\")\"\n                else\n                    echo -e \"${Error}ERROR${Off} Failed to backup $(basename -- \"$strgmgr\")!\"\n                fi\n            fi\n\n            sed -i 's/notSupportM2Pool_addOnCard:this.T(\"disk_info\",\"disk_reason_m2_add_on_card\"),//g' \"$strgmgr\"\n            sed -i 's/},{isConditionInvalid:0<this.pciSlot,invalidReason:\"notSupportM2Pool_addOnCard\"//g' \"$strgmgr\"\n            # Check if we edited file\n            if ! grep -q 'notSupportM2Pool_addOnCard' \"$strgmgr\"; then\n                echo -e \"Enabled creating pool on drives in M.2 adaptor card.\"\n            else\n                echo -e \"${Error}ERROR${Off} Failed to enable creating pool on drives in M.2 adaptor card!\"\n            fi\n        else\n            echo -e \"\\nCreating pool in UI on drives in M.2 adaptor card already enabled.\"\n        fi\n    fi\nfi\n\n\n# Optionally update IronWolf Health Management\nif [[ $arch == \"x86_64\" ]]; then\n    if [[ $ihm == \"yes\" ]]; then\n        setting=\"$(/usr/syno/bin/synogetkeyvalue $synoinfo support_ihm)\"\n        if [[ $setting != \"yes\" ]]; then\n            # Enable support_ihm\n            /usr/syno/bin/synosetkeyvalue \"$synoinfo\" support_ihm \"yes\"\n            setting=\"$(/usr/syno/bin/synogetkeyvalue \"$synoinfo\" support_ihm)\"\n            if [[ $setting == \"yes\" ]]; then\n                echo -e \"\\nEnabled support IronWolf Health Management.\"\n            fi\n        else\n            echo -e \"\\nSupport IronWolf Health Management already enabled.\"\n        fi\n\n        if [[ ! -f /usr/syno/sbin/dhm_tool ]]; then\n            # Install dhm_tool on models without it ('22 series and newer)\n            # Untested\n            md5hash=\"cf67c1d5006913297f85ca7f9d1795ba\"\n            branch=\"main\"\n            file_url=\"https://raw.githubusercontent.com/${repo}/${branch}/bin/dhm_tool\"\n            # install_binfile <file> <file-url> <destination> <chmod> <bundled-path> <hash>\n            install_binfile dhm_tool \"$file_url\" /usr/syno/sbin/dhm_tool \"755\" bin/dhm_tool \"$md5hash\"\n        else\n            # Check if dhm_tool needs updating\n            dhm_version=\"$(dhm_tool --version | grep \"Utility Version\" | awk '{print $NF}')\"\n            if ! printf \"%s\\n%s\\n\" \"2.5.1\" \"$dhm_version\" |\n                sort --check=quiet --version-sort >/dev/null ; then\n\n                # Backup existing dhm_tool\n                backupdb \"/usr/syno/sbin/dhm_tool\"\n\n                # Update dhm_tool\n                md5hash=\"cf67c1d5006913297f85ca7f9d1795ba\"\n                branch=\"main\"\n                file_url=\"https://raw.githubusercontent.com/${repo}/${branch}/bin/dhm_tool\"\n                # install_binfile <file> <file-url> <destination> <chmod> <bundled-path> <hash>\n                install_binfile dhm_tool \"$file_url\" /usr/syno/sbin/dhm_tool \"755\" bin/dhm_tool \"$md5hash\"\n\n                # Check dhm_tool updated\n                dhm_version=\"$(dhm_tool --version | grep \"Utility Version\" | awk '{print $NF}')\"\n                if [[ $dhm_version == \"2.5.1\" ]]; then\n                    echo \"Updated IronWolf Health Management.\"\n                else\n                    echo \"${Error}ERROR${Off} Failed to update IronWolf Health Management!\"\n                fi\n            else\n                echo \"IronWolf Health Management already updated.\"\n            fi\n        fi\n    fi\nfi\n\n\n#------------------------------------------------------------------------------\n# Finished\n\nshow_changes(){  \n    # $1 is drive_model,firmware_version,size_gb\n    drive_model=\"$(printf \"%s\" \"$1\" | cut -d\",\" -f 1)\"\n    echo -e \"\\n$drive_model:\"\n    jq -r --arg drive_model \"$drive_model\" '.disk_compatbility_info[$drive_model]' \"${db1list[0]}\"\n}\n\n# Show the changes\nif [[ ${showedits,,} == \"yes\" ]]; then\n    # HDDs/SSDs\n    for d in \"${hdds[@]}\"; do\n        show_changes \"$d\"\n    done\n\n    # NVMe drives\n    for d in \"${nvmes[@]}\"; do\n        show_changes \"$d\"\n    done\nfi\n\n# Make Synology check disk compatibility\nif [[ -f /usr/syno/sbin/synostgdisk ]]; then  # DSM 6.2.3 does not have synostgdisk\n    /usr/syno/sbin/synostgdisk --check-all-disks-compatibility\n    status=$?\n    if [[ $status -eq \"0\" ]]; then\n        echo -e \"\\nDSM successfully checked disk compatibility.\"\n        rebootmsg=yes  # Show reboot message at end\n    else\n        # Ignore DSM 6.2.4 as it returns 255 for \"synostgdisk --check-all-disks-compatibility\"\n        # and DSM 6.2.3 and lower have no synostgdisk command\n        if [[ $dsm -gt \"6\" ]]; then\n            echo -e \"\\nDSM ${Red}failed${Off} to check disk compatibility with exit code $status\"\n            rebootmsg=yes  # Show reboot message at end\n        fi\n    fi\nfi\n\n# Show reboot message if required\nif [[ $dsm -eq \"6\" ]] || [[ $rebootmsg == \"yes\" ]]; then\n    echo -e \"\\nYou may need to ${Cyan}reboot the Synology${Off} to see the changes.\"\nfi\n\nexit\n\n"
        },
        {
          "name": "syno_hdd_vendor_ids.txt",
          "type": "blob",
          "size": 0.4462890625,
          "content": "# You can add your drive's vendor id and vendor name here.\n#\n# Only edit this file if the script warns you about a missing vendor id.\n\n0x025e=\"Solidigm\"\n0x05dc=\"Lexar\"\n0x0ed1=\"aigo\"\n0x10ec=\"TEAMGROUP\"\n0x137e=\"Patriot\"\n0x1458=\"Gigabyte\"\n0x1462=\"MSI\"\n0x196e=\"PNY\"\n0x1987=\"Phison\"\n0x1b1c=\"Corsair\"\n0x1bdc=\"Apacer\"\n0x1c5c=\"SK Hynix\"\n0x1cc4=\"UMIS\"\n0x1cfa=\"Corsair\"\n0x1d79=\"Transcend\"\n0x1dbe=\"ADATA\"\n0x1e0f=\"KIOXIA\"\n0x1e49=\"ZHITAI\"\n0x1e4b=\"FIKWOT\"\n0x1f40=\"Netac\"\n"
        }
      ]
    }
  ]
}