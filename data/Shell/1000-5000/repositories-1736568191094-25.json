{
  "metadata": {
    "timestamp": 1736568191094,
    "page": 25,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "oblique/create_ap",
      "stars": 4451,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.259765625,
          "content": "Copyright (c) 2013, oblique\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.048828125,
          "content": "PREFIX=/usr\nMANDIR=$(PREFIX)/share/man\nBINDIR=$(PREFIX)/bin\n\nall:\n\t@echo \"Run 'make install' for installation.\"\n\t@echo \"Run 'make uninstall' for uninstallation.\"\n\ninstall:\n\tinstall -Dm755 create_ap $(DESTDIR)$(BINDIR)/create_ap\n\tinstall -Dm644 create_ap.conf $(DESTDIR)/etc/create_ap.conf\n\t[ ! -d /lib/systemd/system ] || install -Dm644 create_ap.service $(DESTDIR)$(PREFIX)/lib/systemd/system/create_ap.service\n\t[ ! -e /sbin/openrc-run ] || install -Dm755 create_ap.openrc $(DESTDIR)/etc/init.d/create_ap\n\tinstall -Dm644 bash_completion $(DESTDIR)$(PREFIX)/share/bash-completion/completions/create_ap\n\tinstall -Dm644 README.md $(DESTDIR)$(PREFIX)/share/doc/create_ap/README.md\n\nuninstall:\n\trm -f $(DESTDIR)$(BINDIR)/create_ap\n\trm -f $(DESTDIR)/etc/create_ap.conf\n\t[ ! -f /lib/systemd/system/create_ap.service ] || rm -f $(DESTDIR)$(PREFIX)/lib/systemd/system/create_ap.service\n\t[ ! -e /sbin/openrc-run ] || rm -f $(DESTDIR)/etc/init.d/create_ap\n\trm -f $(DESTDIR)$(PREFIX)/share/bash-completion/completions/create_ap\n\trm -f $(DESTDIR)$(PREFIX)/share/doc/create_ap/README.md\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.9931640625,
          "content": "## NOT MAINTAINED\n\nThis project is no longer maintained.\n\n\n## Forks and continuation of this project\n\n* [linux-wifi-hotspot] - Fork that is focused on providing GUI and improvements.\n* [linux-router] - Fork that is focused on providing new features and\n    improvements which are not limited to WiFi. Some interesting features are:\n    sharing Internet to a wired interface and sharing Internet via a transparent\n    proxy using redsocks.\n\n\n## Features\n\n* Create an AP (Access Point) at any channel.\n* Choose one of the following encryptions: WPA, WPA2, WPA/WPA2, Open (no encryption).\n* Hide your SSID.\n* Disable communication between clients (client isolation).\n* IEEE 802.11n & 802.11ac support\n* Internet sharing methods: NATed or Bridged or None (no Internet sharing).\n* Choose the AP Gateway IP (only for 'NATed' and 'None' Internet sharing methods).\n* You can create an AP with the same interface you are getting your Internet connection.\n* You can pass your SSID and password through pipe or through arguments (see examples).\n\n\n## Dependencies\n\n### General\n\n* bash (to run this script)\n* util-linux (for getopt)\n* procps or procps-ng\n* hostapd\n* iproute2\n* iw\n* iwconfig (you only need this if 'iw' can not recognize your adapter)\n* haveged (optional)\n\n### For 'NATed' or 'None' Internet sharing method\n\n* dnsmasq\n* iptables\n\n\n## Installation\n\n### Generic\n    git clone https://github.com/oblique/create_ap\n    cd create_ap\n    make install\n\n### ArchLinux\n    pacman -S create_ap\n\n### Gentoo\n    emerge layman\n    layman -f -a jorgicio\n    emerge net-wireless/create_ap\n\n## Examples\n### No passphrase (open network):\n    create_ap wlan0 eth0 MyAccessPoint\n\n### WPA + WPA2 passphrase:\n    create_ap wlan0 eth0 MyAccessPoint MyPassPhrase\n\n### AP without Internet sharing:\n    create_ap -n wlan0 MyAccessPoint MyPassPhrase\n\n### Bridged Internet sharing:\n    create_ap -m bridge wlan0 eth0 MyAccessPoint MyPassPhrase\n\n### Bridged Internet sharing (pre-configured bridge interface):\n    create_ap -m bridge wlan0 br0 MyAccessPoint MyPassPhrase\n\n### Internet sharing from the same WiFi interface:\n    create_ap wlan0 wlan0 MyAccessPoint MyPassPhrase\n\n### Choose a different WiFi adapter driver\n    create_ap --driver rtl871xdrv wlan0 eth0 MyAccessPoint MyPassPhrase\n\n### No passphrase (open network) using pipe:\n    echo -e \"MyAccessPoint\" | create_ap wlan0 eth0\n\n### WPA + WPA2 passphrase using pipe:\n    echo -e \"MyAccessPoint\\nMyPassPhrase\" | create_ap wlan0 eth0\n\n### Enable IEEE 802.11n\n    create_ap --ieee80211n --ht_capab '[HT40+]' wlan0 eth0 MyAccessPoint MyPassPhrase\n\n### Client Isolation:\n    create_ap --isolate-clients wlan0 eth0 MyAccessPoint MyPassPhrase\n\n## Systemd service\nUsing the persistent [systemd](https://wiki.archlinux.org/index.php/systemd#Basic_systemctl_usage) service\n### Start service immediately:\n    systemctl start create_ap\n\n### Start on boot:\n    systemctl enable create_ap\n\n\n## License\nFreeBSD\n\n\n[linux-wifi-hotspot]: https://github.com/lakinduakash/linux-wifi-hotspot\n[linux-router]: https://github.com/garywill/linux-router\n"
        },
        {
          "name": "bash_completion",
          "type": "blob",
          "size": 4.4853515625,
          "content": "#\n# Bash Completion routine for create_ap\n#\n\n_use_filedir() {\n    if [[ $(type -t _filedir) == \"function\" ]]; then\n        _filedir\n        return 0\n    fi\n    return 1\n}\n\n_create_ap() {\n    local awk_cmd='\n        ($1 ~ /^-/) {\n            for (i = 1; i <= NF; i++) {\n                if ($i ~ /,$/) {\n                    print substr ($i, 0, length ($i)-1)\n                }\n                else {\n                    print $i\n                    break\n                }\n            }\n        }\n    '\n\n    local cur prev opts\n    COMPREPLY=()\n    cur=\"$2\"\n    prev=\"$3\"\n    opts=$(\"$1\" --help | awk \"$awk_cmd\")\n\n    case \"$prev\" in\n        -h|--help)\n            # No Options\n            ;;\n        --version)\n            # No Options\n            ;;\n        -c)\n            # Refer http://en.wikipedia.org/wiki/List_of_WLAN_channels\n            opts=$(\n                iw list | grep ' MHz \\[[[:digit:]]\\+\\] ' |\n                grep -v 'no IR\\|disabled' |\n                sed 's/.*\\[\\(.*\\)\\].*/\\1/' | sort -n | uniq\n            )\n            ;;\n        -w)\n            opts=\"1 2 1+2\"\n            ;;\n        -n)\n            # No Options\n            ;;\n        -m)\n            opts=\"nat bridge none\"\n            ;;\n        --psk)\n            # No Options\n            ;;\n        --hidden)\n            # No Options\n            ;;\n        --mac-filter)\n            # No Options\n            ;;\n        --mac-filter-accept)\n            # No Options\n            ;;\n        --ieee80211n)\n            # No Options\n            ;;\n        --ht_capab)\n            # Refer http://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf\n            opts='\n                [LDPC] [HT40-] [HT40+] [SMPS-STATIC] [SMPS-DYNAMIC]\n                [GF] [SHORT-GI-20] [SHORT-GI-40] [TX-STBC]\n                [RX-STBC1] [RX-STBC12] [RX-STBC123] [DELAYED-BA]\n                [MAX-AMSDU-7935] [DSSS_CCK-40] [40-INTOLERANT]\n                [LSIG-TXOP-PROT]\n            '\n            ;;\n        --country)\n            local reg_file=/usr/lib/crda/regulatory.bin\n            if command -v regdbdump > /dev/null && [[ -f \"$reg_file\" ]]; then\n                local country_awk_cmd='\n                    ($1 ~ /^country/) {\n                        print substr ($2, 0, length ($2)-1)\n                    }\n                '\n                opts=$(regdbdump \"$reg_file\" 2>/dev/null | awk \"$country_awk_cmd\")\n            else\n                opts='\n                    AD AE AF AI AL AM AN AR AS AT AU AW AZ BA BB BD BE\n                    BF BG BH BL BM BN BO BR BS BT BY BZ CA CF CH CI CL\n                    CN CO CR CX CY CZ DE DK DM DO DZ EC EE EG ES ET FI\n                    FM FR GB GD GE GF GH GL GP GR GT GU GY HK HN HR HT\n                    HU ID IE IL IN IR IS IT JM JO JP KE KH KN KP KR KW\n                    KY KZ LB LC LI LK LS LT LU LV MA MC MD ME MF MH MK\n                    MN MO MP MQ MR MT MU MW MX MY NG NI NL NO NP NZ OM\n                    PA PE PF PG PH PK PL PM PR PT PW PY QA RE RO RS RU\n                    RW SA SE SG SI SK SN SR SV SY TC TD TG TH TN TR TT\n                    TW TZ UA UG US UY UZ VC VE VI VN VU WF WS YE YT ZA\n                    ZW 00\n                '\n            fi\n            ;;\n        --freq-band)\n            opts=\"2.4 5\"\n            ;;\n        --driver)\n            # Refer http://w1.fi/cgit/hostap/tree/src/drivers\n            # Not going to implement\n            ;;\n        --no-virt)\n            # No Options\n            ;;\n        --no-haveged)\n            # No Options\n            ;;\n        --fix-unmanaged)\n            # No Options\n            ;;\n        --mac)\n            # Not going to implement\n            ;;\n        --daemon)\n            # No Options\n            ;;\n        --stop)\n            local stop_awk_cmd='$1 ~ /^[0-9]+$/'\n            opts=$(\"$1\" --list-running | awk \"$stop_awk_cmd\")\n            ;;\n        --list-running)\n            # No Options\n            ;;\n        --list-clients)\n            local clients_awk_cmd='$1 ~ /^[0-9]+$/'\n            opts=$(\"$1\" --list-running | awk \"$clients_awk_cmd\")\n            ;;\n        --no-dns)\n            # No Options\n            ;;\n        --dhcp-dns)\n            # Not going to implement\n            ;;\n        --mkconfig)\n            _use_filedir && return 0\n            ;;\n        --config)\n            _use_filedir && return 0\n            ;;\n        -g)\n            # Not going to implement\n            ;;\n        -d)\n            # No Options\n            ;;\n        *)\n            ;;\n    esac\n\n    COMPREPLY=( $(compgen -W \"$opts\" -- $cur) )\n    return 0\n}\ncomplete -F _create_ap create_ap\n\n# vim: set ft=sh:\n"
        },
        {
          "name": "create_ap",
          "type": "blob",
          "size": 55.6962890625,
          "content": "#!/bin/bash\n\n# general dependencies:\n#    bash (to run this script)\n#    util-linux (for getopt)\n#    procps or procps-ng\n#    hostapd\n#    iproute2\n#    iw\n#    iwconfig (you only need this if 'iw' can not recognize your adapter)\n#    haveged (optional)\n\n# dependencies for 'nat' or 'none' Internet sharing method\n#    dnsmasq\n#    iptables\n\nVERSION=0.4.6\nPROGNAME=\"$(basename $0)\"\n\n# make sure that all command outputs are in english\n# so we can parse them correctly\nexport LC_ALL=C\n\n# all new files and directories must be readable only by root.\n# in special cases we must use chmod to give any other permissions.\nSCRIPT_UMASK=0077\numask $SCRIPT_UMASK\n\nusage() {\n    echo \"Usage: \"$PROGNAME\" [options] <wifi-interface> [<interface-with-internet>] [<access-point-name> [<passphrase>]]\"\n    echo\n    echo \"Options:\"\n    echo \"  -h, --help              Show this help\"\n    echo \"  --version               Print version number\"\n    echo \"  -c <channel>            Channel number (default: 1)\"\n    echo \"  -w <WPA version>        Use 1 for WPA, use 2 for WPA2, use 1+2 for both (default: 1+2)\"\n    echo \"  -n                      Disable Internet sharing (if you use this, don't pass\"\n    echo \"                          the <interface-with-internet> argument)\"\n    echo \"  -m <method>             Method for Internet sharing.\"\n    echo \"                          Use: 'nat' for NAT (default)\"\n    echo \"                               'bridge' for bridging\"\n    echo \"                               'none' for no Internet sharing (equivalent to -n)\"\n    echo \"  --psk                   Use 64 hex digits pre-shared-key instead of passphrase\"\n    echo \"  --hidden                Make the Access Point hidden (do not broadcast the SSID)\"\n    echo \"  --mac-filter            Enable MAC address filtering\"\n    echo \"  --mac-filter-accept     Location of MAC address filter list (defaults to /etc/hostapd/hostapd.accept)\"\n    echo \"  --redirect-to-localhost If -n is set, redirect every web request to localhost (useful for public information networks)\"\n    echo \"  --hostapd-debug <level> With level between 1 and 2, passes arguments -d or -dd to hostapd for debugging.\"\n    echo \"  --isolate-clients       Disable communication between clients\"\n    echo \"  --ieee80211n            Enable IEEE 802.11n (HT)\"\n    echo \"  --ieee80211ac           Enable IEEE 802.11ac (VHT)\"\n    echo \"  --ht_capab <HT>         HT capabilities (default: [HT40+])\"\n    echo \"  --vht_capab <VHT>       VHT capabilities\"\n    echo \"  --country <code>        Set two-letter country code for regularity (example: US)\"\n    echo \"  --freq-band <GHz>       Set frequency band. Valid inputs: 2.4, 5 (default: 2.4)\"\n    echo \"  --driver                Choose your WiFi adapter driver (default: nl80211)\"\n    echo \"  --no-virt               Do not create virtual interface\"\n    echo \"  --no-haveged            Do not run 'haveged' automatically when needed\"\n    echo \"  --fix-unmanaged         If NetworkManager shows your interface as unmanaged after you\"\n    echo \"                          close create_ap, then use this option to switch your interface\"\n    echo \"                          back to managed\"\n    echo \"  --mac <MAC>             Set MAC address\"\n    echo \"  --dhcp-dns <IP1[,IP2]>  Set DNS returned by DHCP\"\n    echo \"  --daemon                Run create_ap in the background\"\n    echo \"  --pidfile <pidfile>     Save daemon PID to file\"\n    echo \"  --logfile <logfile>     Save daemon messages to file\"\n    echo \"  --stop <id>             Send stop command to an already running create_ap. For an <id>\"\n    echo \"                          you can put the PID of create_ap or the WiFi interface. You can\"\n    echo \"                          get them with --list-running\"\n    echo \"  --list-running          Show the create_ap processes that are already running\"\n    echo \"  --list-clients <id>     List the clients connected to create_ap instance associated with <id>.\"\n    echo \"                          For an <id> you can put the PID of create_ap or the WiFi interface.\"\n    echo \"                          If virtual WiFi interface was created, then use that one.\"\n    echo \"                          You can get them with --list-running\"\n    echo \"  --mkconfig <conf_file>  Store configs in conf_file\"\n    echo \"  --config <conf_file>    Load configs from conf_file\"\n    echo\n    echo \"Non-Bridging Options:\"\n    echo \"  --no-dns                Disable dnsmasq DNS server\"\n    echo \"  --no-dnsmasq            Disable dnsmasq server completely\"\n    echo \"  -g <gateway>            IPv4 Gateway for the Access Point (default: 192.168.12.1)\"\n    echo \"  -d                      DNS server will take into account /etc/hosts\"\n    echo \"  -e <hosts_file>         DNS server will take into account additional hosts file\"\n    echo\n    echo \"Useful informations:\"\n    echo \"  * If you're not using the --no-virt option, then you can create an AP with the same\"\n    echo \"    interface you are getting your Internet connection.\"\n    echo \"  * You can pass your SSID and password through pipe or through arguments (see examples).\"\n    echo \"  * On bridge method if the <interface-with-internet> is not a bridge interface, then\"\n    echo \"    a bridge interface is created automatically.\"\n    echo\n    echo \"Examples:\"\n    echo \"  \"$PROGNAME\" wlan0 eth0 MyAccessPoint MyPassPhrase\"\n    echo \"  echo -e 'MyAccessPoint\\nMyPassPhrase' | \"$PROGNAME\" wlan0 eth0\"\n    echo \"  \"$PROGNAME\" wlan0 eth0 MyAccessPoint\"\n    echo \"  echo 'MyAccessPoint' | \"$PROGNAME\" wlan0 eth0\"\n    echo \"  \"$PROGNAME\" wlan0 wlan0 MyAccessPoint MyPassPhrase\"\n    echo \"  \"$PROGNAME\" -n wlan0 MyAccessPoint MyPassPhrase\"\n    echo \"  \"$PROGNAME\" -m bridge wlan0 eth0 MyAccessPoint MyPassPhrase\"\n    echo \"  \"$PROGNAME\" -m bridge wlan0 br0 MyAccessPoint MyPassPhrase\"\n    echo \"  \"$PROGNAME\" --driver rtl871xdrv wlan0 eth0 MyAccessPoint MyPassPhrase\"\n    echo \"  \"$PROGNAME\" --daemon wlan0 eth0 MyAccessPoint MyPassPhrase\"\n    echo \"  \"$PROGNAME\" --stop wlan0\"\n}\n\n# Busybox polyfills\nif cp --help 2>&1 | grep -q -- --no-clobber; then\n    cp_n() {\n        cp -n \"$@\"\n    }\nelse\n    cp_n() {\n        yes n | cp -i \"$@\"\n    }\nfi\n\n# on success it echos a non-zero unused FD\n# on error it echos 0\nget_avail_fd() {\n    local x\n    for x in $(seq 1 $(ulimit -n)); do\n        if [[ ! -a \"/proc/$BASHPID/fd/$x\" ]]; then\n            echo $x\n            return\n        fi\n    done\n    echo 0\n}\n\n# lock file for the mutex counter\nCOUNTER_LOCK_FILE=/tmp/create_ap.$$.lock\n\ncleanup_lock() {\n    rm -f $COUNTER_LOCK_FILE\n}\n\ninit_lock() {\n    local LOCK_FILE=/tmp/create_ap.all.lock\n\n    # we initialize only once\n    [[ $LOCK_FD -ne 0 ]] && return 0\n\n    LOCK_FD=$(get_avail_fd)\n    [[ $LOCK_FD -eq 0 ]] && return 1\n\n    # open/create lock file with write access for all users\n    # otherwise normal users will not be able to use it.\n    # to avoid race conditions on creation, we need to\n    # use umask to set the permissions.\n    umask 0555\n    eval \"exec $LOCK_FD>$LOCK_FILE\" > /dev/null 2>&1 || return 1\n    umask $SCRIPT_UMASK\n\n    # there is a case where lock file was created from a normal\n    # user. change the owner to root as soon as we can.\n    [[ $(id -u) -eq 0 ]] && chown 0:0 $LOCK_FILE\n\n    # create mutex counter lock file\n    echo 0 > $COUNTER_LOCK_FILE\n\n    return $?\n}\n\n# recursive mutex lock for all create_ap processes\nmutex_lock() {\n    local counter_mutex_fd\n    local counter\n\n    # lock local mutex and read counter\n    counter_mutex_fd=$(get_avail_fd)\n    if [[ $counter_mutex_fd -ne 0 ]]; then\n        eval \"exec $counter_mutex_fd<>$COUNTER_LOCK_FILE\"\n        flock $counter_mutex_fd\n        read -u $counter_mutex_fd counter\n    else\n        echo \"Failed to lock mutex counter\" >&2\n        return 1\n    fi\n\n    # lock global mutex and increase counter\n    [[ $counter -eq 0 ]] && flock $LOCK_FD\n    counter=$(( $counter + 1 ))\n\n    # write counter and unlock local mutex\n    echo $counter > /proc/$BASHPID/fd/$counter_mutex_fd\n    eval \"exec ${counter_mutex_fd}<&-\"\n    return 0\n}\n\n# recursive mutex unlock for all create_ap processes\nmutex_unlock() {\n    local counter_mutex_fd\n    local counter\n\n    # lock local mutex and read counter\n    counter_mutex_fd=$(get_avail_fd)\n    if [[ $counter_mutex_fd -ne 0 ]]; then\n        eval \"exec $counter_mutex_fd<>$COUNTER_LOCK_FILE\"\n        flock $counter_mutex_fd\n        read -u $counter_mutex_fd counter\n    else\n        echo \"Failed to lock mutex counter\" >&2\n        return 1\n    fi\n\n    # decrease counter and unlock global mutex\n    if [[ $counter -gt 0 ]]; then\n        counter=$(( $counter - 1 ))\n        [[ $counter -eq 0 ]] && flock -u $LOCK_FD\n    fi\n\n    # write counter and unlock local mutex\n    echo $counter > /proc/$BASHPID/fd/$counter_mutex_fd\n    eval \"exec ${counter_mutex_fd}<&-\"\n    return 0\n}\n\n# it takes 2 arguments\n# returns:\n#  0 if v1 (1st argument) and v2 (2nd argument) are the same\n#  1 if v1 is less than v2\n#  2 if v1 is greater than v2\nversion_cmp() {\n    local V1 V2 VN x\n    [[ ! $1 =~ ^[0-9]+(\\.[0-9]+)*$ ]] && die \"Wrong version format!\"\n    [[ ! $2 =~ ^[0-9]+(\\.[0-9]+)*$ ]] && die \"Wrong version format!\"\n\n    V1=( $(echo $1 | tr '.' ' ') )\n    V2=( $(echo $2 | tr '.' ' ') )\n    VN=${#V1[@]}\n    [[ $VN -lt ${#V2[@]} ]] && VN=${#V2[@]}\n\n    for ((x = 0; x < $VN; x++)); do\n        [[ ${V1[x]} -lt ${V2[x]} ]] && return 1\n        [[ ${V1[x]} -gt ${V2[x]} ]] && return 2\n    done\n\n    return 0\n}\n\nUSE_IWCONFIG=0\n\nis_interface() {\n    [[ -z \"$1\" ]] && return 1\n    [[ -d \"/sys/class/net/${1}\" ]]\n}\n\nis_wifi_interface() {\n    which iw > /dev/null 2>&1 && iw dev $1 info > /dev/null 2>&1 && return 0\n    if which iwconfig > /dev/null 2>&1 && iwconfig $1 > /dev/null 2>&1; then\n        USE_IWCONFIG=1\n        return 0\n    fi\n    return 1\n}\n\nis_bridge_interface() {\n    [[ -z \"$1\" ]] && return 1\n    [[ -d \"/sys/class/net/${1}/bridge\" ]]\n}\n\nget_phy_device() {\n    local x\n    for x in /sys/class/ieee80211/*; do\n        [[ ! -e \"$x\" ]] && continue\n        if [[ \"${x##*/}\" = \"$1\" ]]; then\n            echo $1\n            return 0\n        elif [[ -e \"$x/device/net/$1\" ]]; then\n            echo ${x##*/}\n            return 0\n        elif [[ -e \"$x/device/net:$1\" ]]; then\n            echo ${x##*/}\n            return 0\n        fi\n    done\n    echo \"Failed to get phy interface\" >&2\n    return 1\n}\n\nget_adapter_info() {\n    local PHY\n    PHY=$(get_phy_device \"$1\")\n    [[ $? -ne 0 ]] && return 1\n    iw phy $PHY info\n}\n\nget_adapter_kernel_module() {\n    local MODULE\n    MODULE=$(readlink -f \"/sys/class/net/$1/device/driver/module\")\n    echo ${MODULE##*/}\n}\n\ncan_be_sta_and_ap() {\n    # iwconfig does not provide this information, assume false\n    [[ $USE_IWCONFIG -eq 1 ]] && return 1\n    if [[ \"$(get_adapter_kernel_module \"$1\")\" == \"brcmfmac\" ]]; then\n        echo \"WARN: brmfmac driver doesn't work properly with virtual interfaces and\" >&2\n        echo \"      it can cause kernel panic. For this reason we disallow virtual\" >&2\n        echo \"      interfaces for your adapter.\" >&2\n        echo \"      For more info: https://github.com/oblique/create_ap/issues/203\" >&2\n        return 1\n    fi\n    get_adapter_info \"$1\" | grep -E '{.* managed.* AP.*}' > /dev/null 2>&1 && return 0\n    get_adapter_info \"$1\" | grep -E '{.* AP.* managed.*}' > /dev/null 2>&1 && return 0\n    return 1\n}\n\ncan_be_ap() {\n    # iwconfig does not provide this information, assume true\n    [[ $USE_IWCONFIG -eq 1 ]] && return 0\n    get_adapter_info \"$1\" | grep -E '\\* AP$' > /dev/null 2>&1 && return 0\n    return 1\n}\n\ncan_transmit_to_channel() {\n    local IFACE CHANNEL_NUM CHANNEL_INFO\n    IFACE=$1\n    CHANNEL_NUM=$2\n\n    if [[ $USE_IWCONFIG -eq 0 ]]; then\n        if [[ $FREQ_BAND == 2.4 ]]; then\n            CHANNEL_INFO=$(get_adapter_info ${IFACE} | grep \" 24[0-9][0-9] MHz \\[${CHANNEL_NUM}\\]\")\n        else\n            CHANNEL_INFO=$(get_adapter_info ${IFACE} | grep \" \\(49[0-9][0-9]\\|5[0-9]\\{3\\}\\) MHz \\[${CHANNEL_NUM}\\]\")\n        fi\n        [[ -z \"${CHANNEL_INFO}\" ]] && return 1\n        [[ \"${CHANNEL_INFO}\" == *no\\ IR* ]] && return 1\n        [[ \"${CHANNEL_INFO}\" == *disabled* ]] && return 1\n        return 0\n    else\n        CHANNEL_NUM=$(printf '%02d' ${CHANNEL_NUM})\n        CHANNEL_INFO=$(iwlist ${IFACE} channel | grep -E \"Channel[[:blank:]]${CHANNEL_NUM}[[:blank:]]?:\")\n        [[ -z \"${CHANNEL_INFO}\" ]] && return 1\n        return 0\n    fi\n}\n\n# taken from iw/util.c\nieee80211_frequency_to_channel() {\n    local FREQ=$1\n    if [[ $FREQ -eq 2484 ]]; then\n        echo 14\n    elif [[ $FREQ -lt 2484 ]]; then\n        echo $(( ($FREQ - 2407) / 5 ))\n    elif [[ $FREQ -ge 4910 && $FREQ -le 4980 ]]; then\n        echo $(( ($FREQ - 4000) / 5 ))\n    elif [[ $FREQ -le 45000 ]]; then\n        echo $(( ($FREQ - 5000) / 5 ))\n    elif [[ $FREQ -ge 58320 && $FREQ -le 64800 ]]; then\n        echo $(( ($FREQ - 56160) / 2160 ))\n    else\n        echo 0\n    fi\n}\n\nis_5ghz_frequency() {\n    [[ $1 =~ ^(49[0-9]{2})|(5[0-9]{3})$ ]]\n}\n\nis_wifi_connected() {\n    if [[ $USE_IWCONFIG -eq 0 ]]; then\n        iw dev \"$1\" link 2>&1 | grep -E '^Connected to' > /dev/null 2>&1 && return 0\n    else\n        iwconfig \"$1\" 2>&1 | grep -E 'Access Point: [0-9a-fA-F]{2}:' > /dev/null 2>&1 && return 0\n    fi\n    return 1\n}\n\nis_macaddr() {\n    echo \"$1\" | grep -E \"^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$\" > /dev/null 2>&1\n}\n\nis_unicast_macaddr() {\n    local x\n    is_macaddr \"$1\" || return 1\n    x=$(echo \"$1\" | cut -d: -f1)\n    x=$(printf '%d' \"0x${x}\")\n    [[ $(expr $x % 2) -eq 0 ]]\n}\n\nget_macaddr() {\n    is_interface \"$1\" || return\n    cat \"/sys/class/net/${1}/address\"\n}\n\nget_mtu() {\n    is_interface \"$1\" || return\n    cat \"/sys/class/net/${1}/mtu\"\n}\n\nalloc_new_iface() {\n    local prefix=$1\n    local i=0\n\n    mutex_lock\n    while :; do\n        if ! is_interface $prefix$i && [[ ! -f $COMMON_CONFDIR/ifaces/$prefix$i ]]; then\n            mkdir -p $COMMON_CONFDIR/ifaces\n            touch $COMMON_CONFDIR/ifaces/$prefix$i\n            echo $prefix$i\n            mutex_unlock\n            return\n        fi\n        i=$((i + 1))\n    done\n    mutex_unlock\n}\n\ndealloc_iface() {\n    rm -f $COMMON_CONFDIR/ifaces/$1\n}\n\nget_all_macaddrs() {\n    cat /sys/class/net/*/address\n}\n\nget_new_macaddr() {\n    local OLDMAC NEWMAC LAST_BYTE i\n    OLDMAC=$(get_macaddr \"$1\")\n    LAST_BYTE=$(printf %d 0x${OLDMAC##*:})\n    mutex_lock\n    for i in {1..255}; do\n        NEWMAC=\"${OLDMAC%:*}:$(printf %02x $(( ($LAST_BYTE + $i) % 256 )))\"\n        (get_all_macaddrs | grep \"$NEWMAC\" > /dev/null 2>&1) || break\n    done\n    mutex_unlock\n    echo $NEWMAC\n}\n\n# start haveged when needed\nhaveged_watchdog() {\n    local show_warn=1\n    while :; do\n        mutex_lock\n        if [[ $(cat /proc/sys/kernel/random/entropy_avail) -lt 1000 ]]; then\n            if ! which haveged > /dev/null 2>&1; then\n                if [[ $show_warn -eq 1 ]]; then\n                    echo \"WARN: Low entropy detected. We recommend you to install \\`haveged'\"\n                    show_warn=0\n                fi\n            elif ! pidof haveged > /dev/null 2>&1; then\n                echo \"Low entropy detected, starting haveged\"\n                # boost low-entropy\n                haveged -w 1024 -p $COMMON_CONFDIR/haveged.pid\n            fi\n        fi\n        mutex_unlock\n        sleep 2\n    done\n}\n\nNETWORKMANAGER_CONF=/etc/NetworkManager/NetworkManager.conf\nNM_OLDER_VERSION=1\n\nnetworkmanager_exists() {\n    local NM_VER\n    which nmcli > /dev/null 2>&1 || return 1\n    NM_VER=$(nmcli -v | grep -m1 -oE '[0-9]+(\\.[0-9]+)*\\.[0-9]+')\n    version_cmp $NM_VER 0.9.9\n    if [[ $? -eq 1 ]]; then\n        NM_OLDER_VERSION=1\n    else\n        NM_OLDER_VERSION=0\n    fi\n    return 0\n}\n\nnetworkmanager_is_running() {\n    local NMCLI_OUT\n    networkmanager_exists || return 1\n    if [[ $NM_OLDER_VERSION -eq 1 ]]; then\n        NMCLI_OUT=$(nmcli -t -f RUNNING nm 2>&1 | grep -E '^running$')\n    else\n        NMCLI_OUT=$(nmcli -t -f RUNNING g 2>&1 | grep -E '^running$')\n    fi\n    [[ -n \"$NMCLI_OUT\" ]]\n}\n\nnetworkmanager_knows_iface() {\n    # check if the interface $1 is known to NetworkManager\n    # an interface may exist but may not be known to NetworkManager if it is in a different network namespace than NetworkManager\n    nmcli -t -f DEVICE d 2>&1 | grep -Fxq \"$1\"\n}\n\nnetworkmanager_iface_is_unmanaged() {\n    is_interface \"$1\" || return 2\n    networkmanager_knows_iface \"$1\" || return 0\n    (nmcli -t -f DEVICE,STATE d 2>&1 | grep -E \"^$1:unmanaged$\" > /dev/null 2>&1) || return 1\n}\n\nADDED_UNMANAGED=\n\nnetworkmanager_add_unmanaged() {\n    local MAC UNMANAGED WAS_EMPTY x\n    networkmanager_exists || return 1\n\n    [[ -d ${NETWORKMANAGER_CONF%/*} ]] || mkdir -p ${NETWORKMANAGER_CONF%/*}\n    [[ -f ${NETWORKMANAGER_CONF} ]] || touch ${NETWORKMANAGER_CONF}\n\n    if [[ $NM_OLDER_VERSION -eq 1 ]]; then\n        if [[ -z \"$2\" ]]; then\n            MAC=$(get_macaddr \"$1\")\n        else\n            MAC=\"$2\"\n        fi\n        [[ -z \"$MAC\" ]] && return 1\n    fi\n\n    mutex_lock\n    UNMANAGED=$(grep -m1 -Eo '^unmanaged-devices=[[:alnum:]:;,-]*' /etc/NetworkManager/NetworkManager.conf)\n\n    WAS_EMPTY=0\n    [[ -z \"$UNMANAGED\" ]] && WAS_EMPTY=1\n    UNMANAGED=$(echo \"$UNMANAGED\" | sed 's/unmanaged-devices=//' | tr ';,' ' ')\n\n    # if it exists, do nothing\n    for x in $UNMANAGED; do\n        if [[ $x == \"mac:${MAC}\" ]] ||\n               [[ $NM_OLDER_VERSION -eq 0 && $x == \"interface-name:${1}\" ]]; then\n            mutex_unlock\n            return 2\n        fi\n    done\n\n    if [[ $NM_OLDER_VERSION -eq 1 ]]; then\n        UNMANAGED=\"${UNMANAGED} mac:${MAC}\"\n    else\n        UNMANAGED=\"${UNMANAGED} interface-name:${1}\"\n    fi\n\n    UNMANAGED=$(echo $UNMANAGED | sed -e 's/^ //')\n    UNMANAGED=\"${UNMANAGED// /;}\"\n    UNMANAGED=\"unmanaged-devices=${UNMANAGED}\"\n\n    if ! grep -E '^\\[keyfile\\]' ${NETWORKMANAGER_CONF} > /dev/null 2>&1; then\n        echo -e \"\\n\\n[keyfile]\\n${UNMANAGED}\" >> ${NETWORKMANAGER_CONF}\n    elif [[ $WAS_EMPTY -eq 1 ]]; then\n        sed -e \"s/^\\(\\[keyfile\\].*\\)$/\\1\\n${UNMANAGED}/\" -i ${NETWORKMANAGER_CONF}\n    else\n        sed -e \"s/^unmanaged-devices=.*/${UNMANAGED}/\" -i ${NETWORKMANAGER_CONF}\n    fi\n\n    ADDED_UNMANAGED=\"${ADDED_UNMANAGED} ${1} \"\n    mutex_unlock\n\n    local nm_pid=$(pidof NetworkManager)\n    [[ -n \"$nm_pid\" ]] && kill -HUP $nm_pid\n\n    return 0\n}\n\nnetworkmanager_rm_unmanaged() {\n    local MAC UNMANAGED\n    networkmanager_exists || return 1\n    [[ ! -f ${NETWORKMANAGER_CONF} ]] && return 1\n\n    if [[ $NM_OLDER_VERSION -eq 1 ]]; then\n        if [[ -z \"$2\" ]]; then\n            MAC=$(get_macaddr \"$1\")\n        else\n            MAC=\"$2\"\n        fi\n        [[ -z \"$MAC\" ]] && return 1\n    fi\n\n    mutex_lock\n    UNMANAGED=$(grep -m1 -Eo '^unmanaged-devices=[[:alnum:]:;,-]*' /etc/NetworkManager/NetworkManager.conf | sed 's/unmanaged-devices=//' | tr ';,' ' ')\n\n    if [[ -z \"$UNMANAGED\" ]]; then\n        mutex_unlock\n        return 1\n    fi\n\n    [[ -n \"$MAC\" ]] && UNMANAGED=$(echo $UNMANAGED | sed -e \"s/mac:${MAC}\\( \\|$\\)//g\")\n    UNMANAGED=$(echo $UNMANAGED | sed -e \"s/interface-name:${1}\\( \\|$\\)//g\")\n    UNMANAGED=$(echo $UNMANAGED | sed -e 's/ $//')\n\n    if [[ -z \"$UNMANAGED\" ]]; then\n        sed -e \"/^unmanaged-devices=.*/d\" -i ${NETWORKMANAGER_CONF}\n    else\n        UNMANAGED=\"${UNMANAGED// /;}\"\n        UNMANAGED=\"unmanaged-devices=${UNMANAGED}\"\n        sed -e \"s/^unmanaged-devices=.*/${UNMANAGED}/\" -i ${NETWORKMANAGER_CONF}\n    fi\n\n    ADDED_UNMANAGED=\"${ADDED_UNMANAGED/ ${1} /}\"\n    mutex_unlock\n\n    local nm_pid=$(pidof NetworkManager)\n    [[ -n \"$nm_pid\" ]] && kill -HUP $nm_pid\n\n    return 0\n}\n\nnetworkmanager_fix_unmanaged() {\n    [[ -f ${NETWORKMANAGER_CONF} ]] || return\n\n    mutex_lock\n    sed -e \"/^unmanaged-devices=.*/d\" -i ${NETWORKMANAGER_CONF}\n    mutex_unlock\n\n    local nm_pid=$(pidof NetworkManager)\n    [[ -n \"$nm_pid\" ]] && kill -HUP $nm_pid\n}\n\nnetworkmanager_rm_unmanaged_if_needed() {\n    [[ $ADDED_UNMANAGED =~ .*\\ ${1}\\ .* ]] && networkmanager_rm_unmanaged $1 $2\n}\n\nnetworkmanager_wait_until_unmanaged() {\n    local RES\n    networkmanager_is_running || return 1\n    while :; do\n        networkmanager_iface_is_unmanaged \"$1\"\n        RES=$?\n        [[ $RES -eq 0 ]] && break\n        [[ $RES -eq 2 ]] && die \"Interface '${1}' does not exist.\n       It's probably renamed by a udev rule.\"\n        sleep 1\n    done\n    sleep 2\n    return 0\n}\n\n\nCHANNEL=default\nGATEWAY=192.168.12.1\nWPA_VERSION=1+2\nETC_HOSTS=0\nADDN_HOSTS=\nDHCP_DNS=gateway\nNO_DNS=0\nNO_DNSMASQ=0\nDNS_PORT=\nHIDDEN=0\nMAC_FILTER=0\nMAC_FILTER_ACCEPT=/etc/hostapd/hostapd.accept\nISOLATE_CLIENTS=0\nSHARE_METHOD=nat\nIEEE80211N=0\nIEEE80211AC=0\nHT_CAPAB='[HT40+]'\nVHT_CAPAB=\nDRIVER=nl80211\nNO_VIRT=0\nCOUNTRY=\nFREQ_BAND=2.4\nNEW_MACADDR=\nDAEMONIZE=0\nDAEMON_PIDFILE=\nDAEMON_LOGFILE=/dev/null\nNO_HAVEGED=0\nUSE_PSK=0\n\nHOSTAPD_DEBUG_ARGS=\nREDIRECT_TO_LOCALHOST=0\n\nCONFIG_OPTS=(CHANNEL GATEWAY WPA_VERSION ETC_HOSTS DHCP_DNS NO_DNS NO_DNSMASQ HIDDEN MAC_FILTER MAC_FILTER_ACCEPT ISOLATE_CLIENTS\n             SHARE_METHOD IEEE80211N IEEE80211AC HT_CAPAB VHT_CAPAB DRIVER NO_VIRT COUNTRY FREQ_BAND\n             NEW_MACADDR DAEMONIZE DAEMON_PIDFILE DAEMON_LOGFILE NO_HAVEGED WIFI_IFACE INTERNET_IFACE\n             SSID PASSPHRASE USE_PSK)\n\nFIX_UNMANAGED=0\nLIST_RUNNING=0\nSTOP_ID=\nLIST_CLIENTS_ID=\n\nSTORE_CONFIG=\nLOAD_CONFIG=\n\nCONFDIR=\nWIFI_IFACE=\nVWIFI_IFACE=\nINTERNET_IFACE=\nBRIDGE_IFACE=\nOLD_MACADDR=\nIP_ADDRS=\nROUTE_ADDRS=\n\nHAVEGED_WATCHDOG_PID=\n\n_cleanup() {\n    local PID x\n\n    trap \"\" SIGINT SIGUSR1 SIGUSR2 EXIT\n    mutex_lock\n    disown -a\n\n    # kill haveged_watchdog\n    [[ -n \"$HAVEGED_WATCHDOG_PID\" ]] && kill $HAVEGED_WATCHDOG_PID\n\n    # kill processes\n    for x in $CONFDIR/*.pid; do\n        # even if the $CONFDIR is empty, the for loop will assign\n        # a value in $x. so we need to check if the value is a file\n        [[ -f $x ]] && kill -9 $(cat $x)\n    done\n\n    rm -rf $CONFDIR\n\n    local found=0\n    for x in $(list_running_conf); do\n        if [[ -f $x/nat_internet_iface && $(cat $x/nat_internet_iface) == $INTERNET_IFACE ]]; then\n            found=1\n            break\n        fi\n    done\n\n    if [[ $found -eq 0 ]]; then\n        cp -f $COMMON_CONFDIR/${INTERNET_IFACE}_forwarding \\\n           /proc/sys/net/ipv4/conf/$INTERNET_IFACE/forwarding\n        rm -f $COMMON_CONFDIR/${INTERNET_IFACE}_forwarding\n    fi\n\n    # if we are the last create_ap instance then set back the common values\n    if ! has_running_instance; then\n        # kill common processes\n        for x in $COMMON_CONFDIR/*.pid; do\n            [[ -f $x ]] && kill -9 $(cat $x)\n        done\n\n        # set old ip_forward\n        if [[ -f $COMMON_CONFDIR/ip_forward ]]; then\n            cp -f $COMMON_CONFDIR/ip_forward /proc/sys/net/ipv4\n            rm -f $COMMON_CONFDIR/ip_forward\n        fi\n\n        # set old bridge-nf-call-iptables\n        if [[ -f $COMMON_CONFDIR/bridge-nf-call-iptables ]]; then\n            if [[ -e /proc/sys/net/bridge/bridge-nf-call-iptables ]]; then\n                cp -f $COMMON_CONFDIR/bridge-nf-call-iptables /proc/sys/net/bridge\n            fi\n            rm -f $COMMON_CONFDIR/bridge-nf-call-iptables\n        fi\n\n        rm -rf $COMMON_CONFDIR\n    fi\n\n    if [[ \"$SHARE_METHOD\" != \"none\" ]]; then\n        if [[ \"$SHARE_METHOD\" == \"nat\" ]]; then\n            iptables -w -t nat -D POSTROUTING -s ${GATEWAY%.*}.0/24 ! -o ${WIFI_IFACE} -j MASQUERADE\n            iptables -w -D FORWARD -i ${WIFI_IFACE} -s ${GATEWAY%.*}.0/24 -j ACCEPT\n            iptables -w -D FORWARD -i ${INTERNET_IFACE} -d ${GATEWAY%.*}.0/24 -j ACCEPT\n        elif [[ \"$SHARE_METHOD\" == \"bridge\" ]]; then\n            if ! is_bridge_interface $INTERNET_IFACE; then\n                ip link set dev $BRIDGE_IFACE down\n                ip link set dev $INTERNET_IFACE down\n                ip link set dev $INTERNET_IFACE promisc off\n                ip link set dev $INTERNET_IFACE nomaster\n                ip link delete $BRIDGE_IFACE type bridge\n                ip addr flush $INTERNET_IFACE\n                ip link set dev $INTERNET_IFACE up\n                dealloc_iface $BRIDGE_IFACE\n\n                for x in \"${IP_ADDRS[@]}\"; do\n                    x=\"${x/inet/}\"\n                    x=\"${x/secondary/}\"\n                    x=\"${x/dynamic/}\"\n                    x=$(echo $x | sed 's/\\([0-9]\\)sec/\\1/g')\n                    x=\"${x/${INTERNET_IFACE}/}\"\n                    ip addr add $x dev $INTERNET_IFACE\n                done\n\n                ip route flush dev $INTERNET_IFACE\n\n                for x in \"${ROUTE_ADDRS[@]}\"; do\n                    [[ -z \"$x\" ]] && continue\n                    [[ \"$x\" == default* ]] && continue\n                    ip route add $x dev $INTERNET_IFACE\n                done\n\n                for x in \"${ROUTE_ADDRS[@]}\"; do\n                    [[ -z \"$x\" ]] && continue\n                    [[ \"$x\" != default* ]] && continue\n                    ip route add $x dev $INTERNET_IFACE\n                done\n\n                networkmanager_rm_unmanaged_if_needed $INTERNET_IFACE\n            fi\n        fi\n    fi\n\n    if [[ \"$SHARE_METHOD\" != \"bridge\" ]]; then\n        if [[ $NO_DNS -eq 0 ]]; then\n            iptables -w -D INPUT -p tcp -m tcp --dport $DNS_PORT -j ACCEPT\n            iptables -w -D INPUT -p udp -m udp --dport $DNS_PORT -j ACCEPT\n            iptables -w -t nat -D PREROUTING -s ${GATEWAY%.*}.0/24 -d ${GATEWAY} \\\n                -p tcp -m tcp --dport 53 -j REDIRECT --to-ports $DNS_PORT\n            iptables -w -t nat -D PREROUTING -s ${GATEWAY%.*}.0/24 -d ${GATEWAY} \\\n                -p udp -m udp --dport 53 -j REDIRECT --to-ports $DNS_PORT\n        fi\n        iptables -w -D INPUT -p udp -m udp --dport 67 -j ACCEPT\n    fi\n\n    if [[ $NO_VIRT -eq 0 ]]; then\n        if [[ -n \"$VWIFI_IFACE\" ]]; then\n            ip link set down dev ${VWIFI_IFACE}\n            ip addr flush ${VWIFI_IFACE}\n            networkmanager_rm_unmanaged_if_needed ${VWIFI_IFACE} ${OLD_MACADDR}\n            iw dev ${VWIFI_IFACE} del\n            dealloc_iface $VWIFI_IFACE\n        fi\n    else\n        ip link set down dev ${WIFI_IFACE}\n        ip addr flush ${WIFI_IFACE}\n        if [[ -n \"$NEW_MACADDR\" ]]; then\n            ip link set dev ${WIFI_IFACE} address ${OLD_MACADDR}\n        fi\n        networkmanager_rm_unmanaged_if_needed ${WIFI_IFACE} ${OLD_MACADDR}\n    fi\n\n    mutex_unlock\n    cleanup_lock\n\n    if [[ $RUNNING_AS_DAEMON -eq 1 && -n \"$DAEMON_PIDFILE\" && -f \"$DAEMON_PIDFILE\" ]]; then\n        rm $DAEMON_PIDFILE\n    fi\n}\n\ncleanup() {\n    echo\n    echo -n \"Doing cleanup.. \"\n    _cleanup > /dev/null 2>&1\n    echo \"done\"\n}\n\ndie() {\n    [[ -n \"$1\" ]] && echo -e \"\\nERROR: $1\\n\" >&2\n    # send die signal to the main process\n    [[ $BASHPID -ne $$ ]] && kill -USR2 $$\n    # we don't need to call cleanup because it's traped on EXIT\n    exit 1\n}\n\nclean_exit() {\n    # send clean_exit signal to the main process\n    [[ $BASHPID -ne $$ ]] && kill -USR1 $$\n    # we don't need to call cleanup because it's traped on EXIT\n    exit 0\n}\n\nlist_running_conf() {\n    local x\n    mutex_lock\n    for x in /tmp/create_ap.*; do\n        if [[ -f $x/pid && -f $x/wifi_iface && -d /proc/$(cat $x/pid) ]]; then\n            echo $x\n        fi\n    done\n    mutex_unlock\n}\n\nlist_running() {\n    local IFACE wifi_iface x\n    mutex_lock\n    for x in $(list_running_conf); do\n        IFACE=${x#*.}\n        IFACE=${IFACE%%.*}\n        wifi_iface=$(cat $x/wifi_iface)\n\n        if [[ $IFACE == $wifi_iface ]]; then\n            echo $(cat $x/pid) $IFACE\n        else\n            echo $(cat $x/pid) $IFACE '('$(cat $x/wifi_iface)')'\n        fi\n    done\n    mutex_unlock\n}\n\nget_wifi_iface_from_pid() {\n    list_running | awk '{print $1 \" \" $NF}' | tr -d '\\(\\)' | grep -E \"^${1} \" | cut -d' ' -f2\n}\n\nget_pid_from_wifi_iface() {\n    list_running | awk '{print $1 \" \" $NF}' | tr -d '\\(\\)' | grep -E \" ${1}$\" | cut -d' ' -f1\n}\n\nget_confdir_from_pid() {\n    local IFACE x\n    mutex_lock\n    for x in $(list_running_conf); do\n        if [[ $(cat $x/pid) == \"$1\" ]]; then\n            echo $x\n            break\n        fi\n    done\n    mutex_unlock\n}\n\nprint_client() {\n    local line ipaddr hostname\n    local mac=\"$1\"\n\n    if [[ -f $CONFDIR/dnsmasq.leases ]]; then\n        line=$(grep \" $mac \" $CONFDIR/dnsmasq.leases | tail -n 1)\n        ipaddr=$(echo $line | cut -d' ' -f3)\n        hostname=$(echo \"$line\" | cut -d' ' -f4)\n    fi\n\n    [[ -z \"$ipaddr\" ]] && ipaddr=\"*\"\n    [[ -z \"$hostname\" ]] && hostname=\"*\"\n\n    printf \"%-20s %-18s %s\\n\" \"$mac\" \"$ipaddr\" \"$hostname\"\n}\n\nlist_clients() {\n    local wifi_iface pid\n\n    # If PID is given, get the associated wifi iface\n    if [[ \"$1\" =~ ^[1-9][0-9]*$ ]]; then\n        pid=\"$1\"\n        wifi_iface=$(get_wifi_iface_from_pid \"$pid\")\n        [[ -z \"$wifi_iface\" ]] && die \"'$pid' is not the pid of a running $PROGNAME instance.\"\n    fi\n\n    [[ -z \"$wifi_iface\" ]] && wifi_iface=\"$1\"\n    is_wifi_interface \"$wifi_iface\" || die \"'$wifi_iface' is not a WiFi interface.\"\n\n    [[ -z \"$pid\" ]] && pid=$(get_pid_from_wifi_iface \"$wifi_iface\")\n    [[ -z \"$pid\" ]] && die \"'$wifi_iface' is not used from $PROGNAME instance.\\n\\\n       Maybe you need to pass the virtual interface instead.\\n\\\n       Use --list-running to find it out.\"\n    [[ -z \"$CONFDIR\" ]] && CONFDIR=$(get_confdir_from_pid \"$pid\")\n\n    if [[ $USE_IWCONFIG -eq 0 ]]; then\n        local awk_cmd='($1 ~ /Station$/) {print $2}'\n        local client_list=$(iw dev \"$wifi_iface\" station dump | awk \"$awk_cmd\")\n\n        if [[ -z \"$client_list\" ]]; then\n            echo \"No clients connected\"\n            return\n        fi\n\n        printf \"%-20s %-18s %s\\n\" \"MAC\" \"IP\" \"Hostname\"\n\n        local mac\n        for mac in $client_list; do\n            print_client $mac\n        done\n    else\n        die \"This option is not supported for the current driver.\"\n    fi\n}\n\nhas_running_instance() {\n    local PID x\n\n    mutex_lock\n    for x in /tmp/create_ap.*; do\n        if [[ -f $x/pid ]]; then\n            PID=$(cat $x/pid)\n            if [[ -d /proc/$PID ]]; then\n                mutex_unlock\n                return 0\n            fi\n        fi\n    done\n    mutex_lock\n\n    return 1\n}\n\nis_running_pid() {\n    list_running | grep -E \"^${1} \" > /dev/null 2>&1\n}\n\nsend_stop() {\n    local x\n\n    mutex_lock\n    # send stop signal to specific pid\n    if is_running_pid $1; then\n        kill -USR1 $1\n        mutex_unlock\n        return\n    fi\n\n    # send stop signal to specific interface\n    for x in $(list_running | grep -E \" \\(?${1}( |\\)?\\$)\" | cut -f1 -d' '); do\n        kill -USR1 $x\n    done\n    mutex_unlock\n}\n\n# Storing configs\nwrite_config() {\n    local i=1\n\n    if ! eval 'echo -n > \"$STORE_CONFIG\"' > /dev/null 2>&1; then\n        echo \"ERROR: Unable to create config file $STORE_CONFIG\" >&2\n        exit 1\n    fi\n\n    WIFI_IFACE=$1\n    if [[ \"$SHARE_METHOD\" == \"none\" ]]; then\n        SSID=\"$2\"\n        PASSPHRASE=\"$3\"\n    else\n        INTERNET_IFACE=\"$2\"\n        SSID=\"$3\"\n        PASSPHRASE=\"$4\"\n    fi\n\n    for config_opt in \"${CONFIG_OPTS[@]}\"; do\n        eval echo $config_opt=\\$$config_opt\n    done >> \"$STORE_CONFIG\"\n\n    echo -e \"Config options written to '$STORE_CONFIG'\"\n    exit 0\n}\n\nis_config_opt() {\n    local elem opt=\"$1\"\n\n    for elem in \"${CONFIG_OPTS[@]}\"; do\n        if [[ \"$elem\" == \"$opt\" ]]; then\n            return 0\n        fi\n    done\n    return 1\n}\n\n# Load options from config file\nread_config() {\n    local opt_name opt_val line\n\n    while read line; do\n        # Read switches and their values\n        opt_name=\"${line%%=*}\"\n        opt_val=\"${line#*=}\"\n        if is_config_opt \"$opt_name\" ; then\n            eval $opt_name=\"\\$opt_val\"\n        else\n            echo \"WARN: Unrecognized configuration entry $opt_name\" >&2\n        fi\n    done < \"$LOAD_CONFIG\"\n}\n\n\nARGS=( \"$@\" )\n\n# Preprocessing for --config before option-parsing starts\nfor ((i=0; i<$#; i++)); do\n    if [[ \"${ARGS[i]}\" = \"--config\" ]]; then\n        if [[ -f \"${ARGS[i+1]}\" ]]; then\n            LOAD_CONFIG=\"${ARGS[i+1]}\"\n            read_config\n        else\n            echo \"ERROR: No config file found at given location\" >&2\n            exit 1\n        fi\n        break\n    fi\ndone\n\nGETOPT_ARGS=$(getopt -o hc:w:g:de:nm: -l \"help\",\"hidden\",\"hostapd-debug:\",\"redirect-to-localhost\",\"mac-filter\",\"mac-filter-accept:\",\"isolate-clients\",\"ieee80211n\",\"ieee80211ac\",\"ht_capab:\",\"vht_capab:\",\"driver:\",\"no-virt\",\"fix-unmanaged\",\"country:\",\"freq-band:\",\"mac:\",\"dhcp-dns:\",\"daemon\",\"pidfile:\",\"logfile:\",\"stop:\",\"list\",\"list-running\",\"list-clients:\",\"version\",\"psk\",\"no-haveged\",\"no-dns\",\"no-dnsmasq\",\"mkconfig:\",\"config:\" -n \"$PROGNAME\" -- \"$@\")\n[[ $? -ne 0 ]] && exit 1\neval set -- \"$GETOPT_ARGS\"\n\nwhile :; do\n    case \"$1\" in\n        -h|--help)\n            usage\n            exit 0\n            ;;\n        --version)\n            echo $VERSION\n            exit 0\n            ;;\n        --hidden)\n            shift\n            HIDDEN=1\n            ;;\n        --mac-filter)\n            shift\n            MAC_FILTER=1\n            ;;\n        --mac-filter-accept)\n            shift\n            MAC_FILTER_ACCEPT=\"$1\"\n            shift\n            ;;\n        --isolate-clients)\n            shift\n            ISOLATE_CLIENTS=1\n            ;;\n        -c)\n            shift\n            CHANNEL=\"$1\"\n            shift\n            ;;\n        -w)\n            shift\n            WPA_VERSION=\"$1\"\n            [[ \"$WPA_VERSION\" == \"2+1\" ]] && WPA_VERSION=1+2\n            shift\n            ;;\n        -g)\n            shift\n            GATEWAY=\"$1\"\n            shift\n            ;;\n        -d)\n            shift\n            ETC_HOSTS=1\n            ;;\n        -e)\n            shift\n            ADDN_HOSTS=\"$1\"\n            shift\n            ;;\n        -n)\n            shift\n            SHARE_METHOD=none\n            ;;\n        -m)\n            shift\n            SHARE_METHOD=\"$1\"\n            shift\n            ;;\n        --ieee80211n)\n            shift\n            IEEE80211N=1\n            ;;\n        --ieee80211ac)\n            shift\n            IEEE80211AC=1\n            ;;\n        --ht_capab)\n            shift\n            HT_CAPAB=\"$1\"\n            shift\n            ;;\n        --vht_capab)\n            shift\n            VHT_CAPAB=\"$1\"\n            shift\n            ;;\n        --driver)\n            shift\n            DRIVER=\"$1\"\n            shift\n            ;;\n        --no-virt)\n            shift\n            NO_VIRT=1\n            ;;\n        --fix-unmanaged)\n            shift\n            FIX_UNMANAGED=1\n            ;;\n        --country)\n            shift\n            COUNTRY=\"$1\"\n            shift\n            ;;\n        --freq-band)\n            shift\n            FREQ_BAND=\"$1\"\n            shift\n            ;;\n        --mac)\n            shift\n            NEW_MACADDR=\"$1\"\n            shift\n            ;;\n        --dhcp-dns)\n            shift\n            DHCP_DNS=\"$1\"\n            shift\n            ;;\n        --daemon)\n            shift\n            DAEMONIZE=1\n            ;;\n        --pidfile)\n            shift\n            DAEMON_PIDFILE=\"$1\"\n            shift\n            ;;\n        --logfile)\n            shift\n            DAEMON_LOGFILE=\"$1\"\n            shift\n            ;;\n        --stop)\n            shift\n            STOP_ID=\"$1\"\n            shift\n            ;;\n        --list)\n            shift\n            LIST_RUNNING=1\n            echo -e \"WARN: --list is deprecated, use --list-running instead.\\n\" >&2\n            ;;\n        --list-running)\n            shift\n            LIST_RUNNING=1\n            ;;\n        --list-clients)\n            shift\n            LIST_CLIENTS_ID=\"$1\"\n            shift\n            ;;\n        --no-haveged)\n            shift\n            NO_HAVEGED=1\n            ;;\n        --psk)\n            shift\n            USE_PSK=1\n            ;;\n        --no-dns)\n            shift\n            NO_DNS=1\n            ;;\n        --no-dnsmasq)\n            shift\n            NO_DNSMASQ=1\n            ;;\n        --redirect-to-localhost)\n            shift\n            REDIRECT_TO_LOCALHOST=1\n            ;;\n        --hostapd-debug)\n            shift\n            if [ \"x$1\" = \"x1\" ]; then\n                HOSTAPD_DEBUG_ARGS=\"-d\"\n            elif [ \"x$1\" = \"x2\" ]; then\n                HOSTAPD_DEBUG_ARGS=\"-dd\"\n            else\n                printf \"Error: argument for --hostapd-debug expected 1 or 2, got %s\\n\" \"$1\"\n                exit 1\n            fi\n            shift\n            ;;\n        --mkconfig)\n            shift\n            STORE_CONFIG=\"$1\"\n            shift\n            ;;\n        --config)\n            shift\n            shift\n            ;;\n        --)\n            shift\n            break\n            ;;\n    esac\ndone\n\n# Load positional args from config file, if needed\nif [[ -n \"$LOAD_CONFIG\" && $# -eq 0 ]]; then\n    i=0\n    # set arguments in order\n    for x in WIFI_IFACE INTERNET_IFACE SSID PASSPHRASE; do\n        if eval \"[[ -n \\\"\\$${x}\\\" ]]\"; then\n            eval \"set -- \\\"\\${@:1:$i}\\\" \\\"\\$${x}\\\"\"\n            ((i++))\n        fi\n        # we unset the variable to avoid any problems later\n        eval \"unset $x\"\n    done\nfi\n\n# Check if required number of positional args are present\nif [[ $# -lt 1 && $FIX_UNMANAGED -eq 0  && -z \"$STOP_ID\" &&\n      $LIST_RUNNING -eq 0 && -z \"$LIST_CLIENTS_ID\" ]]; then\n    usage >&2\n    exit 1\nfi\n\n# Set NO_DNS, if dnsmasq is disabled\nif [[ $NO_DNSMASQ -eq 1 ]]; then\n  NO_DNS=1\nfi\n\ntrap \"cleanup_lock\" EXIT\n\nif ! init_lock; then\n    echo \"ERROR: Failed to initialize lock\" >&2\n    exit 1\nfi\n\n# if the user press ctrl+c or we get USR1 signal\n# then run clean_exit()\ntrap \"clean_exit\" SIGINT SIGUSR1\n# if we get USR2 signal then run die().\ntrap \"die\" SIGUSR2\n\n[[ -n \"$STORE_CONFIG\" ]] && write_config \"$@\"\n\nif [[ $LIST_RUNNING -eq 1 ]]; then\n    echo -e \"List of running $PROGNAME instances:\\n\"\n    list_running\n    exit 0\nfi\n\nif [[ -n \"$LIST_CLIENTS_ID\" ]]; then\n    list_clients \"$LIST_CLIENTS_ID\"\n    exit 0\nfi\n\nif [[ $(id -u) -ne 0 ]]; then\n    echo \"You must run it as root.\" >&2\n    exit 1\nfi\n\nif [[ -n \"$STOP_ID\" ]]; then\n    echo \"Trying to kill $PROGNAME instance associated with $STOP_ID...\"\n    send_stop \"$STOP_ID\"\n    exit 0\nfi\n\nif [[ $FIX_UNMANAGED -eq 1 ]]; then\n    echo \"Trying to fix unmanaged status in NetworkManager...\"\n    networkmanager_fix_unmanaged\n    exit 0\nfi\n\nif [[ $DAEMONIZE -eq 1 && $RUNNING_AS_DAEMON -eq 0 ]]; then\n    # Assume we're running underneath a service manager if PIDFILE is set\n    # and don't clobber it's output with a useless message\n    if [ -z \"$DAEMON_PIDFILE\" ]; then\n        echo \"Running as Daemon...\"\n    fi\n    # run a detached create_ap\n    RUNNING_AS_DAEMON=1 setsid \"$0\" \"${ARGS[@]}\" >>$DAEMON_LOGFILE 2>&1 &\n    exit 0\nelif [[ $RUNNING_AS_DAEMON -eq 1 && -n \"$DAEMON_PIDFILE\" ]]; then\n    echo $$ >$DAEMON_PIDFILE\nfi\n\nif [[ $FREQ_BAND != 2.4 && $FREQ_BAND != 5 ]]; then\n    echo \"ERROR: Invalid frequency band\" >&2\n    exit 1\nfi\n\nif [[ $CHANNEL == default ]]; then\n    if [[ $FREQ_BAND == 2.4 ]]; then\n        CHANNEL=1\n    else\n        CHANNEL=36\n    fi\nfi\n\nif [[ $FREQ_BAND != 5 && $CHANNEL -gt 14 ]]; then\n    echo \"Channel number is greater than 14, assuming 5GHz frequency band\"\n    FREQ_BAND=5\nfi\n\nWIFI_IFACE=$1\n\nif ! is_wifi_interface ${WIFI_IFACE}; then\n    echo \"ERROR: '${WIFI_IFACE}' is not a WiFi interface\" >&2\n    exit 1\nfi\n\nif ! can_be_ap ${WIFI_IFACE}; then\n    echo \"ERROR: Your adapter does not support AP (master) mode\" >&2\n    exit 1\nfi\n\nif ! can_be_sta_and_ap ${WIFI_IFACE}; then\n    if is_wifi_connected ${WIFI_IFACE}; then\n        echo \"ERROR: Your adapter can not be a station (i.e. be connected) and an AP at the same time\" >&2\n        exit 1\n    elif [[ $NO_VIRT -eq 0 ]]; then\n        echo \"WARN: Your adapter does not fully support AP virtual interface, enabling --no-virt\" >&2\n        NO_VIRT=1\n    fi\nfi\n\nHOSTAPD=$(which hostapd)\n\nif [[ ! -x \"$HOSTAPD\" ]]; then\n    echo \"ERROR: hostapd not found.\" >&2\n    exit 1\nfi\n\nif [[ $(get_adapter_kernel_module ${WIFI_IFACE}) =~ ^(8192[cd][ue]|8723a[sue])$ ]]; then\n    if ! strings \"$HOSTAPD\" | grep -m1 rtl871xdrv > /dev/null 2>&1; then\n        echo \"ERROR: You need to patch your hostapd with rtl871xdrv patches.\" >&2\n        exit 1\n    fi\n\n    if [[ $DRIVER != \"rtl871xdrv\" ]]; then\n        echo \"WARN: Your adapter needs rtl871xdrv, enabling --driver=rtl871xdrv\" >&2\n        DRIVER=rtl871xdrv\n    fi\nfi\n\nif [[ \"$SHARE_METHOD\" != \"nat\" && \"$SHARE_METHOD\" != \"bridge\" && \"$SHARE_METHOD\" != \"none\" ]]; then\n    echo \"ERROR: Wrong Internet sharing method\" >&2\n    echo\n    usage >&2\n    exit 1\nfi\n\nif [[ -n \"$NEW_MACADDR\" ]]; then\n    if ! is_macaddr \"$NEW_MACADDR\"; then\n        echo \"ERROR: '${NEW_MACADDR}' is not a valid MAC address\" >&2\n        exit 1\n    fi\n\n    if ! is_unicast_macaddr \"$NEW_MACADDR\"; then\n        echo \"ERROR: The first byte of MAC address (${NEW_MACADDR}) must be even\" >&2\n        exit 1\n    fi\n\n    if [[ $(get_all_macaddrs | grep -c ${NEW_MACADDR}) -ne 0 ]]; then\n        echo \"WARN: MAC address '${NEW_MACADDR}' already exists. Because of this, you may encounter some problems\" >&2\n    fi\nfi\n\nif [[ \"$SHARE_METHOD\" != \"none\" ]]; then\n    MIN_REQUIRED_ARGS=2\nelse\n    MIN_REQUIRED_ARGS=1\nfi\n\nif [[ $# -gt $MIN_REQUIRED_ARGS ]]; then\n    if [[ \"$SHARE_METHOD\" != \"none\" ]]; then\n        if [[ $# -ne 3 && $# -ne 4 ]]; then\n            usage >&2\n            exit 1\n        fi\n        INTERNET_IFACE=\"$2\"\n        SSID=\"$3\"\n        PASSPHRASE=\"$4\"\n    else\n        if [[ $# -ne 2 && $# -ne 3 ]]; then\n            usage >&2\n            exit 1\n        fi\n        SSID=\"$2\"\n        PASSPHRASE=\"$3\"\n    fi\nelse\n    if [[ \"$SHARE_METHOD\" != \"none\" ]]; then\n        if [[ $# -ne 2 ]]; then\n            usage >&2\n            exit 1\n        fi\n        INTERNET_IFACE=\"$2\"\n    fi\n    if tty -s; then\n        while :; do\n            read -p \"SSID: \" SSID\n            if [[ ${#SSID} -lt 1 || ${#SSID} -gt 32 ]]; then\n                echo \"ERROR: Invalid SSID length ${#SSID} (expected 1..32)\" >&2\n                continue\n            fi\n            break\n        done\n        while :; do\n            if [[ $USE_PSK -eq 0 ]]; then\n                read -p \"Passphrase: \" -s PASSPHRASE\n                echo\n                if [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -lt 8 ]] || [[ ${#PASSPHRASE} -gt 63 ]]; then\n                    echo \"ERROR: Invalid passphrase length ${#PASSPHRASE} (expected 8..63)\" >&2\n                    continue\n                fi\n                read -p \"Retype passphrase: \" -s PASSPHRASE2\n                echo\n                if [[ \"$PASSPHRASE\" != \"$PASSPHRASE2\" ]]; then\n                    echo \"Passphrases do not match.\"\n                else\n                    break\n                fi\n            else\n                read -p \"PSK: \" PASSPHRASE\n                echo\n                if [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -ne 64 ]]; then\n                    echo \"ERROR: Invalid pre-shared-key length ${#PASSPHRASE} (expected 64)\" >&2\n                    continue\n                fi\n            fi\n        done\n    else\n        read SSID\n        read PASSPHRASE\n    fi\nfi\n\nif [[ \"$SHARE_METHOD\" != \"none\" ]] && ! is_interface $INTERNET_IFACE; then\n    echo \"ERROR: '${INTERNET_IFACE}' is not an interface\" >&2\n    exit 1\nfi\n\nif [[ ${#SSID} -lt 1 || ${#SSID} -gt 32 ]]; then\n    echo \"ERROR: Invalid SSID length ${#SSID} (expected 1..32)\" >&2\n    exit 1\nfi\n\nif [[ $USE_PSK -eq 0 ]]; then\n    if [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -lt 8 ]] || [[ ${#PASSPHRASE} -gt 63 ]]; then\n        echo \"ERROR: Invalid passphrase length ${#PASSPHRASE} (expected 8..63)\" >&2\n        exit 1\n    fi\nelif [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -ne 64 ]]; then\n    echo \"ERROR: Invalid pre-shared-key length ${#PASSPHRASE} (expected 64)\" >&2\n    exit 1\nfi\n\nif [[ $(get_adapter_kernel_module ${WIFI_IFACE}) =~ ^rtl[0-9].*$ ]]; then\n    if [[ -n \"$PASSPHRASE\" ]]; then\n        echo \"WARN: Realtek drivers usually have problems with WPA1, enabling -w 2\" >&2\n        WPA_VERSION=2\n    fi\n    echo \"WARN: If AP doesn't work, please read: howto/realtek.md\" >&2\nfi\n\nif [[ $NO_VIRT -eq 1 && \"$WIFI_IFACE\" == \"$INTERNET_IFACE\" ]]; then\n    echo -n \"ERROR: You can not share your connection from the same\" >&2\n    echo \" interface if you are using --no-virt option.\" >&2\n    exit 1\nfi\n\nmutex_lock\ntrap \"cleanup\" EXIT\nCONFDIR=$(mktemp -d /tmp/create_ap.${WIFI_IFACE}.conf.XXXXXXXX)\necho \"Config dir: $CONFDIR\"\necho \"PID: $$\"\necho $$ > $CONFDIR/pid\n\n# to make --list-running work from any user, we must give read\n# permissions to $CONFDIR and $CONFDIR/pid\nchmod 755 $CONFDIR\nchmod 444 $CONFDIR/pid\n\nCOMMON_CONFDIR=/tmp/create_ap.common.conf\nmkdir -p $COMMON_CONFDIR\n\nif [[ \"$SHARE_METHOD\" == \"nat\" ]]; then\n    echo $INTERNET_IFACE > $CONFDIR/nat_internet_iface\n    cp_n /proc/sys/net/ipv4/conf/$INTERNET_IFACE/forwarding \\\n       $COMMON_CONFDIR/${INTERNET_IFACE}_forwarding\nfi\ncp_n /proc/sys/net/ipv4/ip_forward $COMMON_CONFDIR\nif [[ -e /proc/sys/net/bridge/bridge-nf-call-iptables ]]; then\n    cp_n /proc/sys/net/bridge/bridge-nf-call-iptables $COMMON_CONFDIR\nfi\nmutex_unlock\n\nif [[ \"$SHARE_METHOD\" == \"bridge\" ]]; then\n    if is_bridge_interface $INTERNET_IFACE; then\n        BRIDGE_IFACE=$INTERNET_IFACE\n    else\n        BRIDGE_IFACE=$(alloc_new_iface br)\n    fi\nfi\n\nif [[ $USE_IWCONFIG -eq 0 ]]; then\n    iw dev ${WIFI_IFACE} set power_save off\nfi\n\nif [[ $NO_VIRT -eq 0 ]]; then\n    VWIFI_IFACE=$(alloc_new_iface ap)\n\n    # in NetworkManager 0.9.9 and above we can set the interface as unmanaged without\n    # the need of MAC address, so we set it before we create the virtual interface.\n    if networkmanager_is_running && [[ $NM_OLDER_VERSION -eq 0 ]]; then\n        echo -n \"Network Manager found, set ${VWIFI_IFACE} as unmanaged device... \"\n        networkmanager_add_unmanaged ${VWIFI_IFACE}\n        # do not call networkmanager_wait_until_unmanaged because interface does not\n        # exist yet\n        echo \"DONE\"\n    fi\n\n    if is_wifi_connected ${WIFI_IFACE}; then\n        WIFI_IFACE_FREQ=$(iw dev ${WIFI_IFACE} link | grep -i freq | awk '{print $2}')\n        WIFI_IFACE_CHANNEL=$(ieee80211_frequency_to_channel ${WIFI_IFACE_FREQ})\n        echo -n \"${WIFI_IFACE} is already associated with channel ${WIFI_IFACE_CHANNEL} (${WIFI_IFACE_FREQ} MHz)\"\n        if is_5ghz_frequency $WIFI_IFACE_FREQ; then\n            FREQ_BAND=5\n        else\n            FREQ_BAND=2.4\n        fi\n        if [[ $WIFI_IFACE_CHANNEL -ne $CHANNEL ]]; then\n            echo \", fallback to channel ${WIFI_IFACE_CHANNEL}\"\n            CHANNEL=$WIFI_IFACE_CHANNEL\n        else\n            echo\n        fi\n    fi\n\n    VIRTDIEMSG=\"Maybe your WiFi adapter does not fully support virtual interfaces.\n       Try again with --no-virt.\"\n    echo -n \"Creating a virtual WiFi interface... \"\n\n    if iw dev ${WIFI_IFACE} interface add ${VWIFI_IFACE} type __ap; then\n        # now we can call networkmanager_wait_until_unmanaged\n        networkmanager_is_running && [[ $NM_OLDER_VERSION -eq 0 ]] && networkmanager_wait_until_unmanaged ${VWIFI_IFACE}\n        echo \"${VWIFI_IFACE} created.\"\n    else\n        VWIFI_IFACE=\n        die \"$VIRTDIEMSG\"\n    fi\n    OLD_MACADDR=$(get_macaddr ${VWIFI_IFACE})\n    if [[ -z \"$NEW_MACADDR\" && $(get_all_macaddrs | grep -c ${OLD_MACADDR}) -ne 1 ]]; then\n        NEW_MACADDR=$(get_new_macaddr ${VWIFI_IFACE})\n    fi\n    WIFI_IFACE=${VWIFI_IFACE}\nelse\n    OLD_MACADDR=$(get_macaddr ${WIFI_IFACE})\nfi\n\nmutex_lock\necho $WIFI_IFACE > $CONFDIR/wifi_iface\nchmod 444 $CONFDIR/wifi_iface\nmutex_unlock\n\nif [[ -n \"$COUNTRY\" && $USE_IWCONFIG -eq 0 ]]; then\n    iw reg set \"$COUNTRY\"\nfi\n\ncan_transmit_to_channel ${WIFI_IFACE} ${CHANNEL} || die \"Your adapter can not transmit to channel ${CHANNEL}, frequency band ${FREQ_BAND}GHz.\"\n\nif networkmanager_exists && ! networkmanager_iface_is_unmanaged ${WIFI_IFACE}; then\n    echo -n \"Network Manager found, set ${WIFI_IFACE} as unmanaged device... \"\n    networkmanager_add_unmanaged ${WIFI_IFACE}\n\n    if networkmanager_is_running; then\n        networkmanager_wait_until_unmanaged ${WIFI_IFACE}\n    fi\n\n    echo \"DONE\"\nfi\n\n[[ $HIDDEN -eq 1 ]] && echo \"Access Point's SSID is hidden!\"\n\n[[ $MAC_FILTER -eq 1 ]] && echo \"MAC address filtering is enabled!\"\n\n[[ $ISOLATE_CLIENTS -eq 1 ]] && echo \"Access Point's clients will be isolated!\"\n\n# hostapd config\ncat << EOF > $CONFDIR/hostapd.conf\nbeacon_int=100\nssid=${SSID}\ninterface=${WIFI_IFACE}\ndriver=${DRIVER}\nchannel=${CHANNEL}\nctrl_interface=$CONFDIR/hostapd_ctrl\nctrl_interface_group=0\nignore_broadcast_ssid=$HIDDEN\nap_isolate=$ISOLATE_CLIENTS\nEOF\n\nif [[ -n \"$COUNTRY\" ]]; then\n    cat << EOF >> $CONFDIR/hostapd.conf\ncountry_code=${COUNTRY}\nieee80211d=1\nEOF\nfi\n\nif [[ $FREQ_BAND == 2.4 ]]; then\n    echo \"hw_mode=g\" >> $CONFDIR/hostapd.conf\nelse\n    echo \"hw_mode=a\" >> $CONFDIR/hostapd.conf\nfi\n\nif [[ $MAC_FILTER -eq 1 ]]; then\n    cat << EOF >> $CONFDIR/hostapd.conf\nmacaddr_acl=${MAC_FILTER}\naccept_mac_file=${MAC_FILTER_ACCEPT}\nEOF\nfi\n\nif [[ $IEEE80211N -eq 1 ]]; then\n    cat << EOF >> $CONFDIR/hostapd.conf\nieee80211n=1\nht_capab=${HT_CAPAB}\nEOF\nfi\n\nif [[ $IEEE80211AC -eq 1 ]]; then\n    echo \"ieee80211ac=1\" >> $CONFDIR/hostapd.conf\nfi\n\nif [[ -n \"$VHT_CAPAB\" ]]; then\n    echo \"vht_capab=${VHT_CAPAB}\" >> $CONFDIR/hostapd.conf\nfi\n\nif [[ $IEEE80211N -eq 1 ]] || [[ $IEEE80211AC -eq 1 ]]; then\n    echo \"wmm_enabled=1\" >> $CONFDIR/hostapd.conf\nfi\n\nif [[ -n \"$PASSPHRASE\" ]]; then\n    [[ \"$WPA_VERSION\" == \"1+2\" ]] && WPA_VERSION=3\n    if [[ $USE_PSK -eq 0 ]]; then\n        WPA_KEY_TYPE=passphrase\n    else\n        WPA_KEY_TYPE=psk\n    fi\n    cat << EOF >> $CONFDIR/hostapd.conf\nwpa=${WPA_VERSION}\nwpa_${WPA_KEY_TYPE}=${PASSPHRASE}\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=TKIP CCMP\nrsn_pairwise=CCMP\nEOF\nfi\n\nif [[ \"$SHARE_METHOD\" == \"bridge\" ]]; then\n    echo \"bridge=${BRIDGE_IFACE}\" >> $CONFDIR/hostapd.conf\nelif [[ $NO_DNSMASQ -eq 0 ]]; then\n    # dnsmasq config (dhcp + dns)\n    DNSMASQ_VER=$(dnsmasq -v | grep -m1 -oE '[0-9]+(\\.[0-9]+)*\\.[0-9]+')\n    version_cmp $DNSMASQ_VER 2.63\n    if [[ $? -eq 1 ]]; then\n        DNSMASQ_BIND=bind-interfaces\n    else\n        DNSMASQ_BIND=bind-dynamic\n    fi\n    if [[ \"$DHCP_DNS\" == \"gateway\" ]]; then\n        DHCP_DNS=\"$GATEWAY\"\n    fi\n    cat << EOF > $CONFDIR/dnsmasq.conf\nlisten-address=${GATEWAY}\n${DNSMASQ_BIND}\ndhcp-range=${GATEWAY%.*}.1,${GATEWAY%.*}.254,255.255.255.0,24h\ndhcp-option-force=option:router,${GATEWAY}\ndhcp-option-force=option:dns-server,${DHCP_DNS}\nEOF\n    MTU=$(get_mtu $INTERNET_IFACE)\n    [[ -n \"$MTU\" ]] && echo \"dhcp-option-force=option:mtu,${MTU}\" >> $CONFDIR/dnsmasq.conf\n    [[ $ETC_HOSTS -eq 0 ]] && echo no-hosts >> $CONFDIR/dnsmasq.conf\n    [[ -n \"$ADDN_HOSTS\" ]] && echo \"addn-hosts=${ADDN_HOSTS}\" >> $CONFDIR/dnsmasq.conf\n    if [[ \"$SHARE_METHOD\" == \"none\" && \"$REDIRECT_TO_LOCALHOST\" == \"1\" ]]; then\n        cat << EOF >> $CONFDIR/dnsmasq.conf\naddress=/#/$GATEWAY\nEOF\n    fi\nfi\n\n# initialize WiFi interface\nif [[ $NO_VIRT -eq 0 && -n \"$NEW_MACADDR\" ]]; then\n    ip link set dev ${WIFI_IFACE} address ${NEW_MACADDR} || die \"$VIRTDIEMSG\"\nfi\n\nip link set down dev ${WIFI_IFACE} || die \"$VIRTDIEMSG\"\nip addr flush ${WIFI_IFACE} || die \"$VIRTDIEMSG\"\n\nif [[ $NO_VIRT -eq 1 && -n \"$NEW_MACADDR\" ]]; then\n    ip link set dev ${WIFI_IFACE} address ${NEW_MACADDR} || die\nfi\n\nif [[ \"$SHARE_METHOD\" != \"bridge\" ]]; then\n    ip link set up dev ${WIFI_IFACE} || die \"$VIRTDIEMSG\"\n    ip addr add ${GATEWAY}/24 broadcast ${GATEWAY%.*}.255 dev ${WIFI_IFACE} || die \"$VIRTDIEMSG\"\nfi\n\n# enable Internet sharing\nif [[ \"$SHARE_METHOD\" != \"none\" ]]; then\n    echo \"Sharing Internet using method: $SHARE_METHOD\"\n    if [[ \"$SHARE_METHOD\" == \"nat\" ]]; then\n        iptables -w -t nat -I POSTROUTING -s ${GATEWAY%.*}.0/24 ! -o ${WIFI_IFACE} -j MASQUERADE || die\n        iptables -w -I FORWARD -i ${WIFI_IFACE} -s ${GATEWAY%.*}.0/24 -j ACCEPT || die\n        iptables -w -I FORWARD -i ${INTERNET_IFACE} -d ${GATEWAY%.*}.0/24 -j ACCEPT || die\n        echo 1 > /proc/sys/net/ipv4/conf/$INTERNET_IFACE/forwarding || die\n        echo 1 > /proc/sys/net/ipv4/ip_forward || die\n        # to enable clients to establish PPTP connections we must\n        # load nf_nat_pptp module\n        modprobe nf_nat_pptp > /dev/null 2>&1\n    elif [[ \"$SHARE_METHOD\" == \"bridge\" ]]; then\n        # disable iptables rules for bridged interfaces\n        if [[ -e /proc/sys/net/bridge/bridge-nf-call-iptables ]]; then\n            echo 0 > /proc/sys/net/bridge/bridge-nf-call-iptables\n        fi\n\n        # to initialize the bridge interface correctly we need to do the following:\n        #\n        # 1) save the IPs and route table of INTERNET_IFACE\n        # 2) if NetworkManager is running set INTERNET_IFACE as unmanaged\n        # 3) create BRIDGE_IFACE and attach INTERNET_IFACE to it\n        # 4) set the previously saved IPs and route table to BRIDGE_IFACE\n        #\n        # we need the above because BRIDGE_IFACE is the master interface from now on\n        # and it must know where is connected, otherwise connection is lost.\n        if ! is_bridge_interface $INTERNET_IFACE; then\n            echo -n \"Create a bridge interface... \"\n            OLD_IFS=\"$IFS\"\n            IFS=$'\\n'\n\n            IP_ADDRS=( $(ip addr show $INTERNET_IFACE | grep -A 1 -E 'inet[[:blank:]]' | paste - -) )\n            ROUTE_ADDRS=( $(ip route show dev $INTERNET_IFACE) )\n\n            IFS=\"$OLD_IFS\"\n\n            if networkmanager_is_running; then\n                networkmanager_add_unmanaged $INTERNET_IFACE\n                networkmanager_wait_until_unmanaged $INTERNET_IFACE\n            fi\n\n            # create bridge interface\n            ip link add name $BRIDGE_IFACE type bridge || die\n            ip link set dev $BRIDGE_IFACE up || die\n            # set 0ms forward delay\n            echo -n 0 > /sys/class/net/$BRIDGE_IFACE/bridge/forward_delay\n\n            # attach internet interface to bridge interface\n            ip link set dev $INTERNET_IFACE promisc on || die\n            ip link set dev $INTERNET_IFACE up || die\n            ip link set dev $INTERNET_IFACE master $BRIDGE_IFACE || die\n\n            ip addr flush $INTERNET_IFACE\n            for x in \"${IP_ADDRS[@]}\"; do\n                x=\"${x/inet/}\"\n                x=\"${x/secondary/}\"\n                x=\"${x/dynamic/}\"\n                x=$(echo $x | sed 's/\\([0-9]\\)sec/\\1/g')\n                x=\"${x/${INTERNET_IFACE}/}\"\n                ip addr add $x dev $BRIDGE_IFACE || die\n            done\n\n            # remove any existing entries that were added from 'ip addr add'\n            ip route flush dev $INTERNET_IFACE\n            ip route flush dev $BRIDGE_IFACE\n\n            # we must first add the entries that specify the subnets and then the\n            # gateway entry, otherwise 'ip addr add' will return an error\n            for x in \"${ROUTE_ADDRS[@]}\"; do\n                [[ \"$x\" == default* ]] && continue\n                ip route add $x dev $BRIDGE_IFACE || die\n            done\n\n            for x in \"${ROUTE_ADDRS[@]}\"; do\n                [[ \"$x\" != default* ]] && continue\n                ip route add $x dev $BRIDGE_IFACE || die\n            done\n\n            echo \"$BRIDGE_IFACE created.\"\n        fi\n    fi\nelse\n    echo \"No Internet sharing\"\nfi\n\n# start dhcp + dns (optional)\nif [[ \"$SHARE_METHOD\" != \"bridge\" ]]; then\n    if [[ $NO_DNS -eq 0 ]]; then\n        DNS_PORT=5353\n        iptables -w -I INPUT -p tcp -m tcp --dport $DNS_PORT -j ACCEPT || die\n        iptables -w -I INPUT -p udp -m udp --dport $DNS_PORT -j ACCEPT || die\n        iptables -w -t nat -I PREROUTING -s ${GATEWAY%.*}.0/24 -d ${GATEWAY} \\\n            -p tcp -m tcp --dport 53 -j REDIRECT --to-ports $DNS_PORT || die\n        iptables -w -t nat -I PREROUTING -s ${GATEWAY%.*}.0/24 -d ${GATEWAY} \\\n            -p udp -m udp --dport 53 -j REDIRECT --to-ports $DNS_PORT || die\n    else\n        DNS_PORT=0\n    fi\n\n    if [[ $NO_DNSMASQ -eq 0 ]]; then\n      iptables -w -I INPUT -p udp -m udp --dport 67 -j ACCEPT || die\n\n      if which complain > /dev/null 2>&1; then\n          # openSUSE's apparmor does not allow dnsmasq to read files.\n          # remove restriction.\n          complain dnsmasq\n      fi\n\n      umask 0033\n      dnsmasq -C $CONFDIR/dnsmasq.conf -x $CONFDIR/dnsmasq.pid -l $CONFDIR/dnsmasq.leases -p $DNS_PORT || die\n      umask $SCRIPT_UMASK\n    fi\nfi\n\n# start access point\necho \"hostapd command-line interface: hostapd_cli -p $CONFDIR/hostapd_ctrl\"\n\nif [[ $NO_HAVEGED -eq 0 ]]; then\n    haveged_watchdog &\n    HAVEGED_WATCHDOG_PID=$!\nfi\n\n# start hostapd (use stdbuf when available for no delayed output in programs that redirect stdout)\nSTDBUF_PATH=`which stdbuf`\nif [ $? -eq 0 ]; then\n    STDBUF_PATH=$STDBUF_PATH\" -oL\"\nfi\n$STDBUF_PATH $HOSTAPD $HOSTAPD_DEBUG_ARGS $CONFDIR/hostapd.conf &\nHOSTAPD_PID=$!\necho $HOSTAPD_PID > $CONFDIR/hostapd.pid\n\nif ! wait $HOSTAPD_PID; then\n    echo -e \"\\nError: Failed to run hostapd, maybe a program is interfering.\" >&2\n    if networkmanager_is_running; then\n        echo \"If an error like 'n80211: Could not configure driver mode' was thrown\" >&2\n        echo \"try running the following before starting create_ap:\" >&2\n        if [[ $NM_OLDER_VERSION -eq 1 ]]; then\n            echo \"    nmcli nm wifi off\" >&2\n        else\n            echo \"    nmcli r wifi off\" >&2\n        fi\n        echo \"    rfkill unblock wlan\" >&2\n    fi\n    die\nfi\n\nclean_exit\n\n# Local Variables:\n# tab-width: 4\n# indent-tabs-mode: nil\n# End:\n\n# vim: et sts=4 sw=4\n"
        },
        {
          "name": "create_ap.conf",
          "type": "blob",
          "size": 0.41796875,
          "content": "CHANNEL=default\nGATEWAY=10.0.0.1\nWPA_VERSION=2\nETC_HOSTS=0\nDHCP_DNS=gateway\nNO_DNS=0\nNO_DNSMASQ=0\nHIDDEN=0\nMAC_FILTER=0\nMAC_FILTER_ACCEPT=/etc/hostapd/hostapd.accept\nISOLATE_CLIENTS=0\nSHARE_METHOD=nat\nIEEE80211N=0\nIEEE80211AC=0\nHT_CAPAB=[HT40+]\nVHT_CAPAB=\nDRIVER=nl80211\nNO_VIRT=0\nCOUNTRY=\nFREQ_BAND=2.4\nNEW_MACADDR=\nDAEMONIZE=0\nNO_HAVEGED=0\nWIFI_IFACE=wlan0\nINTERNET_IFACE=eth0\nSSID=MyAccessPoint\nPASSPHRASE=12345678\nUSE_PSK=0\n"
        },
        {
          "name": "create_ap.openrc",
          "type": "blob",
          "size": 0.2197265625,
          "content": "#!/sbin/openrc-run\n\nname=$RC_SVCNAME\n\ncfgfile=/etc/$RC_SVCNAME.conf\npidfile=/run/$RC_SVCNAME.pid\n\ncommand=/usr/bin/create_ap\ncommand_args=\"--config $cfgfile\"\ncommand_args_background=\"--daemon --pidfile $pidfile\"\nstopsig=USR1\n"
        },
        {
          "name": "create_ap.service",
          "type": "blob",
          "size": 0.2216796875,
          "content": "[Unit]\nDescription=Create AP Service\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/usr/bin/create_ap --config /etc/create_ap.conf\nKillSignal=SIGINT\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "howto",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}