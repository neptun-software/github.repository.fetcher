{
  "metadata": {
    "timestamp": 1736568702710,
    "page": 794,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zdharma-continuum/fast-syntax-highlighting",
      "stars": 1229,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".fast-make-targets",
          "type": "blob",
          "size": 2.8740234375,
          "content": "# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n# Almost all code borrowed from Zshell's _make function\n#\n# Copyright (c) 2018 Sebastian Gniazdowski\n\nlocal -a TARGETS\n\n.make-expandVars() {\n    local open close var val front='' rest=$1\n\n    while [[ $rest == (#b)[^$]#($)* ]]; do\n        front=$front${rest[1,$mbegin[1]-1]}\n        rest=${rest[$mbegin[1],-1]}\n\n        case $rest[2] in\n            ($)           # '$$'. may not appear in target and variable's value\n                front=$front\\$\\$\n                rest=${rest[3,-1]}\n                continue\n                ;;\n                (\\()          # Variable of the form $(foobar)\n                open='('\n                close=')'\n                ;;\n            ({)           # ${foobar}\n                open='{'\n                close='}'\n                ;;\n            ([[:alpha:]]) # $foobar. This is exactly $(f)oobar.\n                open=''\n                close=''\n                var=$rest[2]\n                ;;\n            (*)           # bad parameter name\n                print -- $front$rest\n                return 1\n                ;;\n        esac\n\n        if [[ -n $open ]]; then\n            if [[ $rest == \\$$open(#b)([[:alnum:]_]##)(#B)$close* ]]; then\n                var=$match\n            else  # unmatched () or {}, or bad parameter name\n                print -- $front$rest\n                return 1\n            fi\n        fi\n\n        val=''\n        if [[ -n ${VAR_ARGS[(i)$var]} ]]; then\n            val=${VAR_ARGS[$var]}\n        else\n            if [[ -n $opt_args[(I)(-e|--environment-overrides)] ]]; then\n                if [[ $parameters[$var] == scalar-export* ]]; then\n                    val=${(P)var}\n                elif [[ -n ${VARIABLES[(i)$var]} ]]; then\n                    val=${VARIABLES[$var]}\n                fi\n            else\n                if [[ -n ${VARIABLES[(i)$var]} ]]; then\n                    val=${VARIABLES[$var]}\n                elif [[ $parameters[$var] == scalar-export* ]]; then\n                    val=${(P)var}\n                fi\n            fi\n        fi\n        rest=${rest//\\$$open$var$close/$val}\n    done\n\n    print -- ${front}${rest}\n}\n\n\n.make-parseMakefile () {\n    local input var val target dep TAB=$'\\t' tmp IFS=\n\n    while read input\n    do\n        case \"$input \" in\n            # TARGET: dependencies\n            # TARGET1 TARGET2 TARGET3: dependencies\n            ([[*?[:alnum:]$][^$TAB:=%]#:[^=]*)\n            target=$(.make-expandVars ${input%%:*})\n            TARGETS+=( ${(z)target} )\n            ;;\n        esac\n    done\n}\n\nif [[ -z \"${FAST_HIGHLIGHT[chroma-make-cache]}\" || $(( EPOCHSECONDS - FAST_HIGHLIGHT[chroma-make-cache-born-at] )) -gt 7 ]]; then\n    .make-parseMakefile\n    FAST_HIGHLIGHT[chroma-make-cache-born-at]=\"$EPOCHSECONDS\"\n    FAST_HIGHLIGHT[chroma-make-cache]=\"${(j:;:)TARGETS}\"\nfi\n\nreply2=( \"${(s:;:)FAST_HIGHLIGHT[chroma-make-cache]}\" )\n\n# vim:ft=zsh:et\n"
        },
        {
          "name": ".fast-read-ini-file",
          "type": "blob",
          "size": 1.1298828125,
          "content": "# Copyright (c) 2018 Sebastian Gniazdowski\n#\n# $1 - path to the ini file to parse\n# $2 - name of output hash (INI by default)\n# $3 - prefix for keys in the hash (can be empty)\n#\n# Writes to given hash under keys built in following way: ${3}<section>_field.\n# Values are values from ini file.\n\nlocal __ini_file=\"$1\" __out_hash=\"${2:-INI}\" __key_prefix=\"$3\"\nlocal IFS='' __line __cur_section=\"void\" __access_string\nlocal -a match mbegin mend\n\n[[ ! -r \"$__ini_file\" ]] && { builtin print -r \"fast-syntax-highlighting: an ini file is unreadable ($__ini_file)\"; return 1; }\n\nwhile read -r -t 1 __line; do\n    if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then\n        continue\n    elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then\n        __cur_section=\"${match[1]}\"\n    elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then\n        match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # remove trailing whitespace\n        __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\"\n        : \"${(P)__access_string::=${match[2]}}\"\n    fi\ndone < \"$__ini_file\"\n\nreturn 0\n\n# vim:ft=zsh:sw=4:sts=4:et\n"
        },
        {
          "name": ".fast-run-command",
          "type": "blob",
          "size": 1.611328125,
          "content": "# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n# Copyright (c) 2018 Sebastian Gniazdowski\n#\n# FAST_HIGHLIGHT hash serves as container for variables that\n# prevents creating them in global scope. (P) flag is not used,\n# output array is fixed (__lines_list).\n#\n# $1 - the command, e.g. \"git remote\"; 2>/dev/null redirection is\n#      added automatically\n# $2 - FAST_HIGHLIGHT field name, e.g. \"chroma-git-branches\"; two\n#      additional fields will be used, $2-cache, $2-cache-born-at\n# $3 - what to remove from beginning of the lines returned by the\n#      command\n# $4 - cache validity time, default 5 (seconds)\n#\n# Output: array __lines_list, with output of the command ran\n\n# User should not forget to define this array, the below code\n# will only ensure that it's array (can also define a global)\ntypeset -ga __lines_list\nlocal -a __response\n\nif [[ -z \"${FAST_HIGHLIGHT[$2-cache]}\" || $(( EPOCHSECONDS - FAST_HIGHLIGHT[$2-cache-born-at] )) -gt ${4:-5} ]]; then\n    FAST_HIGHLIGHT[$2-cache-born-at]=\"$EPOCHSECONDS\"\n    __response=( ${${(f)\"$(command ${(Qz)1#+} 2>/dev/null)\"}#${~3}} )\n    [[ \"$1\" = \"+\"* ]] && __lines_list+=( \"${__response[@]}\" ) || __lines_list=( \"${__response[@]}\" )\n    FAST_HIGHLIGHT[$2-cache]=\"${(j:;:)__response}\"\nelse\n    # Quoted (s:;:) flag without @ will skip empty elements. It\n    # still produces array output, interesingly. All this is for\n    # the trailing \";\" above, to skip last, empty element.\n    [[ \"$1\" = \"+\"* ]] && \\\n        __lines_list+=( \"${(@s:;:)FAST_HIGHLIGHT[$2-cache]}\" ) || \\\n        __lines_list=( \"${(@s:;:)FAST_HIGHLIGHT[$2-cache]}\" )\nfi\n\n# vim:ft=zsh:et:sw=4\n"
        },
        {
          "name": ".fast-run-git-command",
          "type": "blob",
          "size": 2.3095703125,
          "content": "# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n# Copyright (c) 2018 Sebastian Gniazdowski\n#\n# It runs given command, which in general will be a git command,\n# automatically looking at cache first (a field named *-cache,\n# in FAST_HIGHLIGHT), which is valid for 5 seconds, and in case\n# of outdated or not existing cache, runs the command, splitting\n# on new-lines, first checking if PWD is inside git repository.\n#\n# FAST_HIGHLIGHT hash serves as container for variables that\n# prevents creating them in global scope. (P) flag is not used,\n# output array is fixed (__lines_list).\n#\n# $1 - the command, e.g. \"git remote\"; 2>/dev/null redirection is\n#      added automatically\n# $2 - FAST_HIGHLIGHT field name, e.g. \"chroma-git-branches\"; two\n#      additional fields will be used, $2-cache, $2-cache-born-at\n# $3 - what to remove from beginning of the lines returned by the\n#      command\n# $4 - cache validity time, default 5 (seconds)\n#\n# Output: array __lines_list, with output of the (git) command ran\n\n# User should not forget to define this array, the below code\n# will only ensure that it's array (can also define a global)\ntypeset -ga __lines_list\nlocal -a __response\n\nif [[ $1 == --status ]] {\n    integer __status=1\n    shift\n}\n\nif [[ -z ${FAST_HIGHLIGHT[$2-cache]} || $(( EPOCHSECONDS - FAST_HIGHLIGHT[$2-cache-born-at] )) -gt ${4:-5} ]]; then\n    FAST_HIGHLIGHT[$2-cache-born-at]=$EPOCHSECONDS\n    if [[ \"$(command git rev-parse --is-inside-work-tree 2>/dev/null)\" = true ]]; then\n        __response=( ${${(f)\"$(command ${(Qz)${1#+}} 2>/dev/null)\"}#$3} )\n        integer retval=$?\n        if (( __status )) {\n            __response=( $retval )\n            __lines_list=( $retval )\n        } else {\n            [[ \"$1\" = \"+\"* ]] && \\\n                __lines_list+=( \"${__response[@]}\" ) || \\\n                __lines_list=( \"${__response[@]}\" )\n        }\n    else\n        __lines_list=()\n    fi\n    FAST_HIGHLIGHT[$2-cache]=\"${(j:;:)__response}\"\nelse\n    # Quoted (s:;:) flag without @ will skip empty elements. It\n    # still produces array output, interesingly. All this is for\n    # the trailing \";\" above, to skip last, empty element.\n    [[ \"$1\" = \"+\"* ]] && \\\n        __lines_list+=( \"${(@s:;:)FAST_HIGHLIGHT[$2-cache]}\" ) || \\\n        __lines_list=( \"${(@s:;:)FAST_HIGHLIGHT[$2-cache]}\" )\nfi\n\n# vim:ft=zsh:et:sw=4\n"
        },
        {
          "name": ".fast-zts-read-all",
          "type": "blob",
          "size": 0.4482421875,
          "content": "# $1 - file-descriptor to be read from\n# $2 - name of output variable (default: REPLY)\n\nlocal __in_fd=${1:-0} __out_var=${2:-REPLY}\nlocal -a __tmp\ninteger __ret=1 __repeat=10 __tmp_size=0\n\nwhile sysread -s 65535 -i \"$__in_fd\" '__tmp[__tmp_size + 1]'; do\n    (( ( __ret=$? ) == 0 )) && (( ++ __tmp_size ))\n    (( __ret == 5 )) && { __ret=0; (( --__repeat == 0 )) && break; }\ndone\n\n: ${(P)__out_var::=\"${(j::)__tmp}\"}\n\nreturn __ret\n\n# vim: ft=zsh:et:sw=4:sts=4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2509765625,
          "content": "current_theme.zsh\nsecondary_theme.zsh\ntheme_overlay.zsh\n*.txt\ntest/out.parse\ntest/res\nhold/*\n*.zwc\n\n### Vim\n# Swap\n[._]*.s[a-v][a-z]\n[._]*.sw[a-p]\n[._]s[a-v][a-z]\n[._]sw[a-p]\n\n# Session\nSession.vim\n\n# Temporary\n.netrwhist\n*~\n# Auto-generated tag files\ntags\n"
        },
        {
          "name": ".zunit.yml",
          "type": "blob",
          "size": 0.1357421875,
          "content": "tap: false\ndirectories:\n  tests: tests\n  output: tests/_output\n  support: tests/_support\ntime_limit: 0\nfail_fast: false\nallow_risky: false\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.0283203125,
          "content": "# News On Updates in F-Sy-H\n\n**2018-08-09**\n\nAdded ideal string highlighting – FSH now handles any legal quoting and combination of `\"`,`'` and `\\` when highlighting\nprogram arguments. See the introduction for an example (item #14).\n\n**2018-08-02**\n\nGlobal aliases are now supported:\n\n![image](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/global-alias.png)\n\n**2018-08-01**\n\nHint – how to customize styles when using Zplugin and turbo mode:\n\n```zsh\nzplugin ice wait\"1\" atload\"set_fast_theme\"\nzplugin light zdharma/fast-syntax-highlighting\n\nset_fast_theme() {\n    FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}paired-bracket]='bg=blue'\n    FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}bracket-level-1]='fg=red,bold'\n    FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}bracket-level-2]='fg=magenta,bold'\n    FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}bracket-level-3]='fg=cyan,bold'\n}\n```\n\nIf you have set theme before an update of styles (e.g. recent addition of bracket highlighting) then please repeat\n`fast-theme {theme}` call to regenerate theme files. (**2018-08-09**: FSH now has full user-theme support, refer to\n[appropriate section of README](#customization)).\n\n**2018-07-30**\n\nIdeal highlighting of brackets (pairing, etc.) – no quoting can disturb the result:\n\n![image](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/brackets.gif)\n\n`FAST_HIGHLIGHT[use_brackets]=1` to enable this feature (**2018-07-31**: not needed anymore, this highlighting is active\nby default).\n\n**2018-07-21**\n\nChroma architecture now supports aliases. You can have `alias mygit=\"git commit\"` and when `mygit` will be invoked\neverything will work as expected (Git chroma will be ran).\n\n**2018-07-11**\n\nThere were problems with Ctrl-C not working when using FSH. After many days I've found a fix for this, it's pushed to\nmaster.\n\nSecond, asynchronous path checking (useful on e.g. slow network drives, or when there are many files in directory) is\nnow optional. Set `FAST_HIGHLIGHT[use_async]=1` to enable it. This saves some users from Zshell crashes – there's an\nunknown bug in Zsh.\n\n**2018-06-09**\n\nNew chroma functions: `awk`, `make`, `perl`, `vim`. Checkout the [video](https://asciinema.org/a/186234), it shows\nfunctionality of `awk` – compiling of code and NOT running it. Perl can do this too:\n[video](https://asciinema.org/a/186098).\n\n**2018-06-06**\n\nFSH gained a new architecture – \"chroma functions\". They are similar to \"completion functions\", i.e. they are defined\n**per-command**, but instead of completing that command, they colorize it. Two chroma exist, for `Git`\n([video](https://asciinema.org/a/185707), [video](https://asciinema.org/a/185811)) and for `grep`\n([video](https://asciinema.org/a/185942)). Checkout\n[example chroma](https://github.com/zdharma/fast-syntax-highlighting/blob/master/chroma/-example.ch) if you would like\nto highlight a command.\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/git_chroma.png)\n\n**2018-06-01**\n\nHighlighting of command substitution (i.e. `$(...)`) with alternate theme – two themes at once! It was just white\nbefore:\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/cmdsubst.png)\n\nTo select which theme to use for `$(...)` set the key `secondary=` in\n[theme ini file](https://github.com/zdharma/fast-syntax-highlighting/blob/master/themes/free.ini#L7). All shipped themes\nhave this key set (only the `default` theme doesn't use second theme).\n\nAlso added correct highlighting of descriptor-variables passed to `exec`:\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/execfd.png)\n\n**2018-05-30**\n\nFor-loop is highlighted, it has separate settings in\n[theme file](https://github.com/zdharma/fast-syntax-highlighting/blob/master/themes/free.ini).\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/for-loop.png)\n\n**2018-05-27**\n\nAdded support for 256-color themes. There are six themes shipped with FSH. The command to switch theme is\n`fast-theme {theme-name}`, it has a completion which lists available themes and options. Checkout\n[asciinema recording](https://asciinema.org/a/183814) that presents the themes.\n\n**2018-05-25**\n\nHash holding paths that shouldn't be grepped (globbed) – blacklist for slow disks, mounts, etc.:\n\n```zsh\ntypeset -gA FAST_BLIST_PATTERNS\nFAST_BLIST_PATTERNS[/mount/nfs1/*]=1\nFAST_BLIST_PATTERNS[/mount/disk2/*]=1\n```\n\n**2018-05-23**\n\nAssign colorizing now spans to variables defined by `typeset`, `export`, `local`, etc.:\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/typeset.png)\n\nAlso, `zcalc` has a separate math mode and specialized highlighting – no more light-red colors because of treating\n`zcalc` like a regular command-line:\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/zcalc.png)\n\n**2018-05-22**\n\nArray assignments were still boring, so I throwed in bracked colorizing:\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/array-assign.png)\n\n**2018-05-22**<a name=\"assign-update\"></a>\n\nAssignments are no more one-colour default-white. When used in assignment, highlighted are:\n\n- variables (outside strings),\n- strings (double-quoted and single-quoted),\n- math-mode (`val=$(( ... ))`).\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/assign.png)\n\n**2018-01-06**\n\nMath mode is highlighted – expressions `(( ... ))` and `$(( ... ))`. Empty variables are colorized as red. There are 3\nstyle names (fields of\n[FAST_HIGHLIGHT_STYLES](https://github.com/zdharma/fast-syntax-highlighting/blob/master/fast-highlight#L34) hash) for\nmath-variable, number and empty variable (error): `mathvar`, `mathnum`, `matherr`. You can set them (like the animation\nbelow shows) to change colors.\n\n![animation](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/math.gif)\n"
        },
        {
          "name": "CHROMA_GUIDE.adoc",
          "type": "blob",
          "size": 7.02734375,
          "content": "# Chroma Guide for F-Sy-H\n\n## Motivation\n\nSomeone might want to create a detailed highlighting for a **specific program**\nand this document helps achieving this. It explains how chroma functions – the\ncode behind such detailed highlighting – are constructed and used.\n\n## Keywords\n\n- `chroma` - a shorthand for `chroma function` – the thing that literally colorizes selected commands, like `git`, `grep`, etc. invocations, see `chroma function` below,\n- `big loop` - main highlighting code, a loop over tokens and at least 2 large structular constructs (big `if` and `case`);\n  it is advanced, e.g. parses `case` statements, here-string, it basically constitutes 90% of the F-Sy-H project,\n- `chroma function` - a plugin-function that is called when a specific command occurs (e.g. when user enters `git` at\n  command line) suppressing activity of `big loop` (i.e. no standard highlighting unless requested),\n- `token` - result of splitting whole command line (i.e. `$BUFFER`, the Zle variable) into bits called tokens, which are\n  words in general, separated by spaces on the command line.\n\n## Overview Of Functioning\n\n1. Big loop is working – token by token processes command line, changes states (e.g. enters state \"inside case\n   statement\") and in the end decides on color of the token currently processed.\n\n2. Big loop occurs a command that has a chroma, e.g. `git`.\n\n3. Big loop enters \"chroma\" state, calls associated chroma function.\n\n4. Chroma takes care of \"chroma\" state, ensures it will be set also for next token.\n\n5. \"chroma\" state is active, so all following tokens are routed to the chroma (in general skipping big-loop, see next items),\n\n6. When processing of a single token is complete, the associated chroma returns 0\n   (shell-truth) to request no further processing by the big loop.\n\n7. It can also return 1 so that single, current token will be passed into big-loop\n   for processing (to do a standard highlighting).\n\n## Chroma-Function Arguments\n\n- `$1` - 0 or 1, denoting if it's the first call to the chroma, or a following one,\n\n- `$2` - the current token, also accessible by `$\\__arg` from the upper scope -\n       basically a private copy of `$__arg`; the token can be eg.: \"grep\",\n\n- `$3` - a private copy of `$_start_pos`, i.e. the position of the token in the\n       command line buffer, used to add region_highlight entry (see man),\n       because Zsh colorizes by *ranges* applied onto command line buffer (e.g.\n       `from-10 to-13 fg=red`),\n\n- `$4` - a private copy of `$_end_pos` from the upper scope; denotes where current token\n       ends (at which index in the string being the command line).\n\nSo example invocation could look like this:\n\n----\nchroma/-example.ch 1 \"grep\" \"$_start_pos\" \"$_end_pos\"\n----\n\nBig-loop will be doing such calls for the user, after occurring a specific chroma-enabled command (like e.g. `awk`), and then until chroma will detect end of this chroma-enabled command (end of whole invocation, with arguments, etc.; in other words, when e.g. new line or `;`-character occurs, etc.).\n\n## Example Chroma-Function\n\n[source,zsh]\n----\n# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n# Copyright (c) 2018 Sebastian Gniazdowski\n#\n# Example chroma function. It colorizes first two arguments as `builtin' style,\n# third and following arguments as `globbing' style. First two arguments may\n# be \"strings\", they will be passed through to normal higlighter (by returning 1).\n#\n# $1 - 0 or 1, denoting if it's first call to the chroma, or following one\n#\n# $2 - like above document says\n#\n# $3 - ...\n#\n# $4 - ...\n#\n# Other tips are:\n# - $CURSOR holds cursor position\n# - $BUFFER holds whole command line buffer\n# - $LBUFFER holds command line buffer that is left from the cursor, i.e. it's a\n#   BUFFER substring 1 .. $CURSOR\n# - $RBUFFER is the same as LBUFFER but holds part of BUFFER right to the cursor\n#\n# The function receives $BUFFER but via sequence of tokens, which are shell words,\n# e.g. \"a b c\" is a shell word, while a b c are 3 shell words.\n#\n# FAST_HIGHLIGHT is a friendly hash array which allows to store strings without\n# creating global parameters (variables). If you need hash, go ahead and use it,\n# declaring first, under some distinct name like: typeset -gA CHROMA_EXPLE_DICT.\n# Remember to reset the hash and others at __first_call == 1, so that you have\n# a fresh state for new command.\n\n# Keep chroma-takever state meaning: until ;, handle highlighting via chroma.\n# So the below 8192 assignment takes care that next token will be routed to chroma.\n(( next_word = 2 | 8192 ))\n\nlocal __first_call=\"$1\" __wrd=\"$2\" __start_pos=\"$3\" __end_pos=\"$4\"\nlocal __style\ninteger __idx1 __idx2\n\n(( __first_call )) && {\n    # Called for the first time - new command.\n    # FAST_HIGHLIGHT is used because it survives between calls, and\n    # allows to use a single global hash only, instead of multiple\n    # global string variables.\n    FAST_HIGHLIGHT[chroma-example-counter]=0\n\n    # Set style for region_highlight entry. It is used below in\n    # '[[ -n \"$__style\" ]] ...' line, which adds highlight entry,\n    # like \"10 12 fg=green\", through `reply' array.\n    #\n    # Could check if command `example' exists and set `unknown-token'\n    # style instead of `command'\n    __style=${FAST_THEME_NAME}command\n\n} || {\n    # Following call, i.e. not the first one\n\n    # Check if chroma should end – test if token is of type\n    # \"starts new command\", if so pass-through – chroma ends\n    [[ \"$__arg_type\" = 3 ]] && return 2\n\n    if [[ \"$__wrd\" = -* ]]; then\n        # Detected option, add style for it.\n        [[ \"$__wrd\" = --* ]] && __style=${FAST_THEME_NAME}double-hyphen-option || \\\n                                __style=${FAST_THEME_NAME}single-hyphen-option\n    else\n        # Count non-option tokens\n        (( FAST_HIGHLIGHT[chroma-example-counter] += 1, __idx1 = FAST_HIGHLIGHT[chroma-example-counter] ))\n\n        # Colorize 1..2 as builtin, 3.. as glob\n        if (( FAST_HIGHLIGHT[chroma-example-counter] <= 2 )); then\n            if [[ \"$__wrd\" = \\\"* ]]; then\n                # Pass through, fsh main code will do the highlight!\n                return 1\n            else\n                __style=${FAST_THEME_NAME}builtin\n            fi\n        else\n            __style=${FAST_THEME_NAME}globbing\n        fi\n    fi\n}\n\n# Add region_highlight entry (via `reply' array).\n# If 1 will be added to __start_pos, this will highlight \"oken\".\n# If 1 will be subtracted from __end_pos, this will highlight \"toke\".\n# $PREBUFFER is for specific situations when users does command \\<ENTER>\n# i.e. when multi-line command using backslash is entered.\n#\n# This is a common place of adding such entry, but any above code can do\n# it itself (and it does in other chromas) and skip setting __style to\n# this way disable this code.\n[[ -n \"$__style\" ]] && (( __start=__start_pos-${#PREBUFFER}, __end=__end_pos-${#PREBUFFER}, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n\n# We aren't passing-through, do obligatory things ourselves.\n# _start_pos=$_end_pos advainces pointers in command line buffer.\n(( this_word = next_word ))\n_start_pos=$_end_pos\n\nreturn 0\n----\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5078125,
          "content": "Copyright (c) 2010-2016 zsh-syntax-highlighting contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice, this list of conditions\n   and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice, this list of\n   conditions and the following disclaimer in the documentation and/or other materials provided\n   with the distribution.\n * Neither the name of the zsh-syntax-highlighting contributors nor the names of its contributors\n   may be used to endorse or promote products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.6435546875,
          "content": "# Fast Syntax Highlighting (F-Sy-H) [![Gitter][gitter-image]][gitter-link]\n\nFeature rich syntax highlighting for Zsh.\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/highlight-much.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Table of Contents\n\n- [News](#news)\n- [Installation](#installation)\n- [Features](#features)\n- [Performance](#performance)\n\n### Other Contents\n\n- [License](https://github.com/zdharma-continuum/fast-syntax-highlighting/blob/master/LICENSE)\n- [Changelog](https://github.com/zdharma-continuum/fast-syntax-highlighting/blob/master/CHANGELOG.md)\n- [Theme Guide](https://github.com/zdharma-continuum/fast-syntax-highlighting/blob/master/THEME_GUIDE.md)\n- [Chroma Guide](https://github.com/zdharma-continuum/fast-syntax-highlighting/blob/master/CHROMA_GUIDE.adoc)\n\n# News\n\n- 15-06-2019\n  - A new architecture for defining the highlighting for **specific commands**: it now uses **abstract definitions**\n    instead of **top-down, regular code**. The first effect is the highlighting for the `git` command it is now\n    **maximally faithful**, it follows the `git` command almost completely. [Screencast](https://asciinema.org/a/253411)\n\n# Installation\n\n### Manual\n\nClone the Repository.\n\n```zsh\ngit clone https://github.com/zdharma-continuum/fast-syntax-highlighting ~/path/to/fsh\n```\n\nAnd add the following to your `zshrc` file.\n\n```zsh\nsource ~/path/to/fsh/fast-syntax-highlighting.plugin.zsh\n```\n\n### Zinit\n\nAdd the following to your `zshrc` file.\n\n```zsh\nzinit light zdharma-continuum/fast-syntax-highlighting\n```\n\nHere's an example of how to load the plugin together with a few other popular ones with the use of\n[Turbo](https://zdharma-continuum.org/zinit/wiki/INTRODUCTION/#turbo_mode_zsh_62_53), i.e.: speeding up the Zsh startup\nby loading the plugin right after the first prompt, in background:\n\n```zsh\nzinit wait lucid for \\\n atinit\"ZINIT[COMPINIT_OPTS]=-C; zicompinit; zicdreplay\" \\\n    zdharma-continuum/fast-syntax-highlighting \\\n blockf \\\n    zsh-users/zsh-completions \\\n atload\"!_zsh_autosuggest_start\" \\\n    zsh-users/zsh-autosuggestions\n```\n\n### Antigen\n\nAdd the following to your `zshrc` file.\n\n```zsh\nantigen bundle zdharma-continuum/fast-syntax-highlighting\n```\n\n### Fig\n\n[Fig](https://fig.io) adds apps, shortcuts, and autocomplete to your existing terminal.\n\nInstall `fast-syntax-highlighting` in just one click.\n\n<a href=\"https://fig.io/plugins/other/fast-syntax-highlighting_zdharma-continuum\" target=\"_blank\"><img src=\"https://fig.io/badges/install-with-fig.svg\" /></a>\n\n\n### Zgen\n\nAdd the following to your `.zshrc` file in the same place you're doing your other `zgen load` calls in.\n\n```zsh\nzgen load zdharma-continuum/fast-syntax-highlighting\n```\n\n### Oh-My-Zsh\n\nClone the Repository.\n\n```zsh\ngit clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git \\\n  ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting\n```\n\nAnd add `fast-syntax-highlighting` to your plugin list.\n\n# Features\n\n### Themes\n\nSwitch themes via `fast-theme {theme-name}`.\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/theme.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\nRun `fast-theme -t {theme-name}` option to obtain the snippet above.\n\nRun `fast-theme -l` to list available themes.\n\n### Variables\n\nComparing to the project `zsh-users/zsh-syntax-highlighting` (the upper line):\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/parameter.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/in_string.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Brackets\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/brackets.gif\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Conditions\n\nComparing to the project `zsh-users/zsh-syntax-highlighting` (the upper line):\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/cplx_cond.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Strings\n\nExact highlighting that recognizes quotings.\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/ideal-string.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### here-strings\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/herestring.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### `exec` descriptor-variables\n\nComparing to the project `zsh-users/zsh-syntax-highlighting` (the upper line):\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/execfd_cmp.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### for-loops and alternate syntax (brace `{`/`}` blocks)\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/for-loop-cmp.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Function definitions\n\nComparing to the project `zsh-users/zsh-syntax-highlighting` (the upper 2 lines):\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/function.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Recursive `eval` and `$( )` highlighting\n\nComparing to the project `zsh-users/zsh-syntax-highlighting` (the upper line):\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/eval_cmp.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Chroma functions\n\nHighlighting that is specific for a given command.\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/git_chroma.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\nThe [chromas](https://github.com/zdharma-continuum/fast-syntax-highlighting/tree/master/%E2%86%92chroma) that are\nenabled by default can be found\n[here](https://github.com/zdharma-continuum/fast-syntax-highlighting/blob/master/fast-highlight#L166).\n\n### Math-mode highlighting\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/math.gif\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n### Zcalc highlighting\n\n<div style=\"width:100%;background-color:black;border:3px solid black;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <img\n    src=\"https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/zcalc.png\"\n    alt=\"image could not be loaded\"\n    style=\"color:red;background-color:black;font-weight:bold\"\n  />\n</div>\n\n# Performance\n\nPerformance differences can be observed in this Asciinema recording, where a `10 kB` function is being edited.\n\n<div style=\"width:100%;background-color:#121314;border:3px solid #121314;border-radius:6px;margin:5px 0;padding:2px 5px\">\n  <a href=\"https://asciinema.org/a/112367\">\n    <img src=\"https://asciinema.org/a/112367.png\" alt=\"asciicast\">\n  </a>\n</div>\n\n[gitter-image]: https://badges.gitter.im/zdharma-continuum/community.svg\n[gitter-link]: https://gitter.im/zdharma-continuum/community\n"
        },
        {
          "name": "THEME_GUIDE.md",
          "type": "blob",
          "size": 2.794921875,
          "content": "# Theme Guide for F-Sy-H\n\n`fast-theme` tool is used to select a theme. There are 6 shipped themes, they can be listed with `fast-theme -l`. Themes\nare basic [INI files](https://github.com/zdharma/fast-syntax-highlighting/tree/master/themes) where each key is a\n*style*. Besides shipped themes, user can point this tool to any other theme, by simple `fast-theme ~/mytheme.ini`. To\nobtain template to work on when creating own theme, issue `fast-theme --copy-shipped-theme {theme-name}`.\n\nTo alter just a few styles and not create a whole new theme, use **overlay**. What is overlay? It is in the same format\nas full theme, but can have only a few styles defined, and these styles will overwrite styles in main-theme. Example\noverlay file:\n\n```ini\n; overlay.ini\n[base]\ncommandseparator = yellow,bold\ncomment          = 17\n\n[command-point]\nfunction       = green\ncommand        = 180\n```\n\nFile name `overlay.ini` is treated specially.\n\nWhen specifing path, following short-hands can be used:\n\n```\nXDG:    = ~/.config/fsh (respects $XDG_CONFIG_HOME env var)\nLOCAL:  = /usr/local/share/fsh/\nHOME:   = ~/.fsh/\nOPT:    = /opt/local/share/fsh/\n```\n\nSo for example, issue `fast-theme XDG:overlay` to load `~/.config/fsh/overlay.ini` as overlay. The `.ini` extension is\noptional.\n\n## Secondary Theme\n\nEach theme has key `secondary`, e.g. for theme `free`:\n\n```ini\n; free.ini\n[base]\ndefault          = none\nunknown-token    = red,bold\n; ...\n; ...\n; ...\nsecondary        = zdharma\n```\n\nSecondary theme (`zdharma` in the example) will be used for highlighting of argument for `eval` and of `$( ... )`\ninterior (i.e. of interior of command substitution). Basically, recursive highlighting uses alternate theme to make the\nhighlighted code distinct:\n\n![sshot](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/cmdsubst.png)\n\nIn the above screen-shot the interior of `$( ... )` uses different colors than the rest of the code. Example for `eval`:\n\n![image](https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/images/eval_cmp.png)\n\nFirst line doesn't use recursive highlighting, highlights `eval` argument as regular string. Second line switches theme\nto `zdharma` and does full recursive highlighting of eval argument.\n\n## Custom Working Directory\n\nSet `$FAST_WORK_DIR` before loading the plugin to have e.g. processed theme files (ready to load, in Zsh format, not\nINI) kept under specified location. This is handy if e.g. you install Fast-Syntax-Highlighting system-wide (e.g. from\nAUR on ArchLinux) and want to have per-user theme setup.\n\nYou can use \"~\" in the path, e.g. `FAST_WORK_DIR=~/.fsh` and also the `XDG:`, `LOCAL:`, `OPT:`, etc. short-hands, so\ne.g. `FAST_WORK_DIR=XDG` or `FAST_WORK_DIR=XDG:` is allowed (in this case it will be changed to `$HOME/.config/fsh` by\ndefault by F-Sy-H loader).\n"
        },
        {
          "name": "_fast-theme",
          "type": "blob",
          "size": 1.1728515625,
          "content": "#compdef fast-theme\n\n#\n# Copyright (c) 2018 Sebastian Gniazdowski\n#\n# Completion for theme-switching function, fast-theme,\n# part of zdharma/fast-syntax-highlighting.\n#\n\ninteger ret=1\nlocal -a arguments\n\narguments=(\n  {-h,--help}'[display help text]'\n  {-l,--list}'[list available themes]'\n  {-r,--reset}'[unset any theme (revert to default highlighting)]'\n  {-R,--ov-reset}'[unset overlay, use styles only from main-theme (requires restart)]'\n  {-q,--quiet}'[no default messages]'\n  {-s,--show}'[get and display the theme currently being set]'\n  {-v,--verbose}'[more messages during operation]'\n  {-t,--test}'[test theme after setting it (show example code)]'\n  {-p,--palette}'[just print all 256 colors and exit (useful when creating a theme)]'\n  {-w,--workdir}'[cd into $FAST_WORK_DIR (if not set, then into the plugin directory)]'\n)\n\ntypeset -a themes\nthemes=( \"$FAST_WORK_DIR\"/themes/*.ini(:t:r) )\n\nif [[ -d ${XDG_CONFIG_HOME:-$HOME/.config}/fsh ]] {\n    typeset -a themes2\n    themes2=( \"${XDG_CONFIG_HOME:-$HOME/.config}\"/fsh/*.ini(:t:r) )\n    themes+=( XDG:${^themes2[@]} )\n}\n\n_wanted themes expl \"Themes\" \\\n    compadd \"$@\" -a - themes && ret=0\n_arguments -s $arguments && ret=0\n\nreturn $ret\n"
        },
        {
          "name": "fast-highlight",
          "type": "blob",
          "size": 69.9658203125,
          "content": "# -*- mode: sh; sh-indentation: 2; indent-tabs-mode: nil; sh-basic-offset: 2; -*-\n# -------------------------------------------------------------------------------------------------\n# Copyright (c) 2010-2016 zsh-syntax-highlighting contributors\n# Copyright (c) 2016-2019 Sebastian Gniazdowski (modifications)\n# All rights reserved.\n#\n# The only licensing for this file follows.\n#\n# Redistribution and use in source and binary forms, with or without modification, are permitted\n# provided that the following conditions are met:\n#\n#  * Redistributions of source code must retain the above copyright notice, this list of conditions\n#    and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright notice, this list of\n#    conditions and the following disclaimer in the documentation and/or other materials provided\n#    with the distribution.\n#  * Neither the name of the zsh-syntax-highlighting contributors nor the names of its contributors\n#    may be used to endorse or promote products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# -------------------------------------------------------------------------------------------------\n\ntypeset -gA __fast_highlight_main__command_type_cache FAST_BLIST_PATTERNS\ntypeset -g FAST_WORK_DIR\n: ${FAST_WORK_DIR:=$FAST_BASE_DIR}\nFAST_WORK_DIR=${~FAST_WORK_DIR}\n() {\n  # We must not use emulate -o if we want to keep compatibility with Zsh < v.5.0\n  # See https://github.com/zdharma-continuum/fast-syntax-highlighting/pull/7\n  emulate -L zsh\n  setopt extendedglob\n  local -A map\n  map=( \"XDG:\"    \"${XDG_CONFIG_HOME:-$HOME/.config}/fsh/\"\n        \"LOCAL:\"  \"/usr/local/share/fsh/\"\n        \"HOME:\"   \"$HOME/.fsh/\"\n        \"OPT:\"    \"/opt/local/share/fsh/\"\n  )\n  FAST_WORK_DIR=${${FAST_WORK_DIR/(#m)(#s)(XDG|LOCAL|HOME|OPT):(#c0,1)/${map[${MATCH%:}:]}}%/}\n}\n\n# Define default styles. You can set this after loading the plugin in\n# Zshrc and use 256 colors via numbers, like: fg=150\ntypeset -gA FAST_HIGHLIGHT_STYLES\nif [[ -e $FAST_WORK_DIR/current_theme.zsh ]]; then\n  source $FAST_WORK_DIR/current_theme.zsh\nelse\n# built-in theme\nzstyle :plugin:fast-syntax-highlighting theme default\n: ${FAST_HIGHLIGHT_STYLES[default]:=none}\n: ${FAST_HIGHLIGHT_STYLES[unknown-token]:=fg=red,bold}\n: ${FAST_HIGHLIGHT_STYLES[reserved-word]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[subcommand]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[alias]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[suffix-alias]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[global-alias]:=bg=blue}\n: ${FAST_HIGHLIGHT_STYLES[builtin]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[function]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[command]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[precommand]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[commandseparator]:=none}\n: ${FAST_HIGHLIGHT_STYLES[hashed-command]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[path]:=fg=magenta}\n: ${FAST_HIGHLIGHT_STYLES[path-to-dir]:=fg=magenta,underline}\n: ${FAST_HIGHLIGHT_STYLES[path_pathseparator]:=}\n: ${FAST_HIGHLIGHT_STYLES[globbing]:=fg=blue,bold}\n: ${FAST_HIGHLIGHT_STYLES[globbing-ext]:=fg=13}\n: ${FAST_HIGHLIGHT_STYLES[history-expansion]:=fg=blue,bold}\n: ${FAST_HIGHLIGHT_STYLES[single-hyphen-option]:=fg=cyan}\n: ${FAST_HIGHLIGHT_STYLES[double-hyphen-option]:=fg=cyan}\n: ${FAST_HIGHLIGHT_STYLES[back-quoted-argument]:=none}\n: ${FAST_HIGHLIGHT_STYLES[single-quoted-argument]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[double-quoted-argument]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[dollar-quoted-argument]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[back-or-dollar-double-quoted-argument]:=fg=cyan}\n: ${FAST_HIGHLIGHT_STYLES[back-dollar-quoted-argument]:=fg=cyan}\n: ${FAST_HIGHLIGHT_STYLES[assign]:=none}\n: ${FAST_HIGHLIGHT_STYLES[redirection]:=none}\n: ${FAST_HIGHLIGHT_STYLES[comment]:=fg=black,bold}\n: ${FAST_HIGHLIGHT_STYLES[variable]:=fg=113}\n: ${FAST_HIGHLIGHT_STYLES[mathvar]:=fg=blue,bold}\n: ${FAST_HIGHLIGHT_STYLES[mathnum]:=fg=magenta}\n: ${FAST_HIGHLIGHT_STYLES[matherr]:=fg=red}\n: ${FAST_HIGHLIGHT_STYLES[assign-array-bracket]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[for-loop-variable]:=none}\n: ${FAST_HIGHLIGHT_STYLES[for-loop-operator]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[for-loop-number]:=fg=magenta}\n: ${FAST_HIGHLIGHT_STYLES[for-loop-separator]:=fg=yellow,bold}\n: ${FAST_HIGHLIGHT_STYLES[here-string-tri]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[here-string-text]:=bg=18}\n: ${FAST_HIGHLIGHT_STYLES[here-string-var]:=fg=cyan,bg=18}\n: ${FAST_HIGHLIGHT_STYLES[case-input]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[case-parentheses]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[case-condition]:=bg=blue}\n: ${FAST_HIGHLIGHT_STYLES[paired-bracket]:=bg=blue}\n: ${FAST_HIGHLIGHT_STYLES[bracket-level-1]:=fg=green,bold}\n: ${FAST_HIGHLIGHT_STYLES[bracket-level-2]:=fg=yellow,bold}\n: ${FAST_HIGHLIGHT_STYLES[bracket-level-3]:=fg=cyan,bold}\n: ${FAST_HIGHLIGHT_STYLES[single-sq-bracket]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[double-sq-bracket]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[double-paren]:=fg=yellow}\n: ${FAST_HIGHLIGHT_STYLES[correct-subtle]:=fg=12}\n: ${FAST_HIGHLIGHT_STYLES[incorrect-subtle]:=fg=red}\n: ${FAST_HIGHLIGHT_STYLES[subtle-separator]:=fg=green}\n: ${FAST_HIGHLIGHT_STYLES[subtle-bg]:=bg=18}\n: ${FAST_HIGHLIGHT_STYLES[secondary]:=free}\nfi\n\n# This can overwrite some of *_STYLES fields\n[[ -r $FAST_WORK_DIR/theme_overlay.zsh ]] && source $FAST_WORK_DIR/theme_overlay.zsh\n\ntypeset -gA __FAST_HIGHLIGHT_TOKEN_TYPES\n\n__FAST_HIGHLIGHT_TOKEN_TYPES=(\n\n  # Precommand\n\n  'builtin'     1\n  'command'     1\n  'exec'        1\n  'nocorrect'   1\n  'noglob'      1\n  'pkexec'      1 # immune to #121 because it's usually not passed --option flags\n\n  # Control flow\n  # Tokens that, at (naively-determined) \"command position\", are followed by\n  # a de jure command position.  All of these are reserved words.\n\n  $'\\x7b'   2 # block '{'\n  $'\\x28'   2 # subshell '('\n  '()'      2 # anonymous function\n  'while'   2\n  'until'   2\n  'if'      2\n  'then'    2\n  'elif'    2\n  'else'    2\n  'do'      2\n  'time'    2\n  'coproc'  2\n  '!'       2 # reserved word; unrelated to $histchars[1]\n\n  # Command separators\n\n  '|'   3\n  '||'  3\n  ';'   3\n  '&'   3\n  '&&'  3\n  '|&'  3\n  '&!'  3\n  '&|'  3\n  # ### 'case' syntax, but followed by a pattern, not by a command\n  # ';;' ';&' ';|'\n)\n\n# A hash instead of multiple globals\ntypeset -gA FAST_HIGHLIGHT\n\n# Brackets highlighter active by default\n: ${FAST_HIGHLIGHT[use_brackets]:=1}\n\nFAST_HIGHLIGHT+=(\n  chroma-fast-theme    →chroma/-fast-theme.ch\n  chroma-alias         →chroma/-alias.ch\n  chroma-autoload      →chroma/-autoload.ch\n  chroma-autorandr     →chroma/-autorandr.ch\n  chroma-docker        →chroma/-docker.ch\n  chroma-example       →chroma/-example.ch\n  chroma-ionice        →chroma/-ionice.ch\n  chroma-make          →chroma/-make.ch\n  chroma-nice          →chroma/-nice.ch\n  chroma-nmcli         →chroma/-nmcli.ch\n  chroma-node          →chroma/-node.ch\n  chroma-perl          →chroma/-perl.ch\n  chroma-printf        →chroma/-printf.ch\n  chroma-ruby          →chroma/-ruby.ch\n  chroma-scp           →chroma/-scp.ch\n  chroma-ssh           →chroma/-ssh.ch\n\n  chroma-git           →chroma/main-chroma.ch%git\n  chroma-hub           →chroma/-hub.ch\n  chroma-lab           →chroma/-lab.ch\n  chroma-svn           →chroma/-subversion.ch\n  chroma-svnadmin      →chroma/-subversion.ch\n  chroma-svndumpfilter →chroma/-subversion.ch\n\n  chroma-egrep         →chroma/-grep.ch\n  chroma-fgrep         →chroma/-grep.ch\n  chroma-grep          →chroma/-grep.ch\n\n  chroma-awk           →chroma/-awk.ch\n  chroma-gawk          →chroma/-awk.ch\n  chroma-goawk         →chroma/-awk.ch\n  chroma-mawk          →chroma/-awk.ch\n\n  chroma-source        →chroma/-source.ch\n  chroma-.             →chroma/-source.ch\n\n  chroma-bash          →chroma/-sh.ch\n  chroma-fish          →chroma/-sh.ch\n  chroma-sh            →chroma/-sh.ch\n  chroma-zsh           →chroma/-sh.ch\n\n  chroma-whatis        →chroma/-whatis.ch\n  chroma-man           →chroma/-whatis.ch\n\n  chroma--             →chroma/-precommand.ch\n  chroma-xargs         →chroma/-precommand.ch\n  chroma-nohup         →chroma/-precommand.ch\n  chroma-strace        →chroma/-precommand.ch\n  chroma-ltrace        →chroma/-precommand.ch\n\n  chroma-hg            →chroma/-subcommand.ch\n  chroma-cvs           →chroma/-subcommand.ch\n  chroma-pip           →chroma/-subcommand.ch\n  chroma-pip2          →chroma/-subcommand.ch\n  chroma-pip3          →chroma/-subcommand.ch\n  chroma-gem           →chroma/-subcommand.ch\n  chroma-bundle        →chroma/-subcommand.ch\n  chroma-yard          →chroma/-subcommand.ch\n  chroma-cabal         →chroma/-subcommand.ch\n  chroma-npm           →chroma/-subcommand.ch\n  chroma-nvm           →chroma/-subcommand.ch\n  chroma-yarn          →chroma/-subcommand.ch\n  chroma-brew          →chroma/-subcommand.ch\n  chroma-port          →chroma/-subcommand.ch\n  chroma-yum           →chroma/-subcommand.ch\n  chroma-dnf           →chroma/-subcommand.ch\n  chroma-tmux          →chroma/-subcommand.ch\n  chroma-pass          →chroma/-subcommand.ch\n  chroma-aws           →chroma/-subcommand.ch\n  chroma-apt           →chroma/-subcommand.ch\n  chroma-apt-get       →chroma/-subcommand.ch\n  chroma-apt-cache     →chroma/-subcommand.ch\n  chroma-aptitude      →chroma/-subcommand.ch\n  chroma-keyctl        →chroma/-subcommand.ch\n  chroma-systemctl     →chroma/-subcommand.ch\n  chroma-asciinema     →chroma/-subcommand.ch\n  chroma-ipfs          →chroma/-subcommand.ch\n  chroma-zinit       →chroma/main-chroma.ch%zinit\n  chroma-aspell        →chroma/-subcommand.ch\n  chroma-bspc          →chroma/-subcommand.ch\n  chroma-cryptsetup    →chroma/-subcommand.ch\n  chroma-diskutil      →chroma/-subcommand.ch\n  chroma-exercism      →chroma/-subcommand.ch\n  chroma-gulp          →chroma/-subcommand.ch\n  chroma-i3-msg        →chroma/-subcommand.ch\n  chroma-openssl       →chroma/-subcommand.ch\n  chroma-solargraph    →chroma/-subcommand.ch\n  chroma-subliminal    →chroma/-subcommand.ch\n  chroma-svnadmin      →chroma/-subcommand.ch\n  chroma-travis        →chroma/-subcommand.ch\n  chroma-udisksctl     →chroma/-subcommand.ch\n  chroma-xdotool       →chroma/-subcommand.ch\n  chroma-zmanage       →chroma/-subcommand.ch\n  chroma-zsystem       →chroma/-subcommand.ch\n  chroma-zypper        →chroma/-subcommand.ch\n\n  chroma-fpath+=\\(     →chroma/-fpath_peq.ch\n  chroma-fpath=\\(      →chroma/-fpath_peq.ch\n  chroma-FPATH+=       →chroma/-fpath_peq.ch\n  chroma-FPATH=        →chroma/-fpath_peq.ch\n  #chroma-which        →chroma/-which.ch\n  #chroma-vim          →chroma/-vim.ch\n)\n\nif [[ $OSTYPE == darwin* ]] {\n  noglob unset FAST_HIGHLIGHT[chroma-man] FAST_HIGHLIGHT[chroma-whatis]\n}\n\n# Assignments seen, to know if math parameter exists\ntypeset -gA FAST_ASSIGNS_SEEN\n\n# Exposing tokens found on command position,\n# for other scripts to process\ntypeset -ga ZLAST_COMMANDS\n\n# Get the type of a command.\n#\n# Uses the zsh/parameter module if available to avoid forks, and a\n# wrapper around 'type -w' as fallback.\n#\n# Takes a single argument.\n#\n# The result will be stored in REPLY.\n-fast-highlight-main-type() {\n  REPLY=$__fast_highlight_main__command_type_cache[(e)$1]\n  [[ -z $REPLY ]] && {\n\n  if zmodload -e zsh/parameter; then\n    if (( $+aliases[(e)$1] )); then\n      REPLY=alias\n    elif (( ${+galiases[(e)${(Q)1}]} )); then\n      REPLY=\"global alias\"\n    elif (( $+functions[(e)$1] )); then\n      REPLY=function\n    elif (( $+builtins[(e)$1] )); then\n      REPLY=builtin\n    elif (( $+commands[(e)$1] )); then\n      REPLY=command\n    elif (( $+saliases[(e)${1##*.}] )); then\n      REPLY='suffix alias'\n    elif (( $reswords[(Ie)$1] )); then\n      REPLY=reserved\n    # zsh 5.2 and older have a bug whereby running 'type -w ./sudo' implicitly\n    # runs 'hash ./sudo=/usr/local/bin/./sudo' (assuming /usr/local/bin/sudo\n    # exists and is in $PATH).  Avoid triggering the bug, at the expense of\n    # falling through to the $() below, incurring a fork.  (Issue #354.)\n    #\n    # The second disjunct mimics the isrelative() C call from the zsh bug.\n    elif [[ $1 != */* || ${+ZSH_ARGZERO} = \"1\" ]] && ! builtin type -w -- $1 >/dev/null 2>&1; then\n      REPLY=none\n    fi\n  fi\n\n  [[ -z $REPLY ]] && REPLY=\"${$(LC_ALL=C builtin type -w -- $1 2>/dev/null)##*: }\"\n\n  [[ $REPLY = \"none\" ]] && {\n    [[ -n ${FAST_BLIST_PATTERNS[(k)${${(M)1:#/*}:-$PWD/$1}]} ]] || {\n      [[ -d $1 ]] && REPLY=\"dirpath\" || {\n        for cdpath_dir in $cdpath; do\n          [[ -d $cdpath_dir/$1 ]] && { REPLY=\"dirpath\"; break; }\n        done\n      }\n    }\n  }\n\n  __fast_highlight_main__command_type_cache[(e)$1]=$REPLY\n\n  }\n}\n\n# Below are variables that must be defined in outer\n# scope so that they are reachable in *-process()\n-fast-highlight-fill-option-variables() {\n  if [[ -o ignore_braces ]] || eval '[[ -o ignore_close_braces ]] 2>/dev/null'; then\n    FAST_HIGHLIGHT[right_brace_is_recognised_everywhere]=0\n  else\n    FAST_HIGHLIGHT[right_brace_is_recognised_everywhere]=1\n  fi\n\n  if [[ -o path_dirs ]]; then\n    FAST_HIGHLIGHT[path_dirs_was_set]=1\n  else\n    FAST_HIGHLIGHT[path_dirs_was_set]=0\n  fi\n\n  if [[ -o multi_func_def ]]; then\n    FAST_HIGHLIGHT[multi_func_def]=1\n  else\n    FAST_HIGHLIGHT[multi_func_def]=0\n  fi\n\n  if [[ -o interactive_comments ]]; then\n    FAST_HIGHLIGHT[ointeractive_comments]=1\n  else\n    FAST_HIGHLIGHT[ointeractive_comments]=0\n  fi\n}\n\n# Main syntax highlighting function.\n-fast-highlight-process()\n{\n  emulate -L zsh\n  setopt extendedglob bareglobqual nonomatch typesetsilent\n\n  [[ $CONTEXT == \"select\" ]] && return 0\n\n  (( FAST_HIGHLIGHT[path_dirs_was_set] )) && setopt PATH_DIRS\n  (( FAST_HIGHLIGHT[ointeractive_comments] )) && local interactive_comments= # _set_ to empty\n\n  # Variable declarations and initializations\n  # in_array_assignment true between 'a=(' and the matching ')'\n  # braces_stack: \"R\" for round, \"Q\" for square, \"Y\" for curly\n  # _mybuf, cdpath_dir are used in sub-functions\n  local _start_pos=$3 _end_pos __start __end highlight_glob=1 __arg __style in_array_assignment=0 MATCH expanded_path braces_stack __buf=$1$2 _mybuf __workbuf cdpath_dir active_command alias_target _was_double_hyphen=0 __nul=$'\\0' __tmp\n  # __arg_type can be 0, 1, 2 or 3, i.e. precommand, control flow, command separator\n  # __idx and _end_idx are used in sub-functions\n  # for this_word and next_word look below at commented integers and at state machine description\n  integer __arg_type=0 MBEGIN MEND in_redirection __len=${#__buf} __PBUFLEN=${#1} already_added offset __idx _end_idx this_word=1 next_word=0 __pos  __asize __delimited=0 itmp iitmp\n  local -a match mbegin mend __inputs __list\n\n  # This comment explains the numbers:\n  # BIT_for - word after reserved-word-recognized `for'\n  # BIT_afpcmd - word after a precommand that can take options, like `command' and `exec'\n  # integer BIT_start=1 BIT_regular=2 BIT_sudo_opt=4 BIT_sudo_arg=8 BIT_always=16 BIT_for=32 BIT_afpcmd=64\n  # integer BIT_chroma=8192\n\n  integer BIT_case_preamble=512 BIT_case_item=1024 BIT_case_nempty_item=2048 BIT_case_code=4096\n\n  # Braces stack\n  # T - typeset, local, etc.\n\n  # State machine\n  #\n  # The states are:\n  # - :__start:      Command word\n  # - :sudo_opt:   A leading-dash option to sudo (such as \"-u\" or \"-i\")\n  # - :sudo_arg:   The argument to a sudo leading-dash option that takes one,\n  #                when given as a separate word; i.e., \"foo\" in \"-u foo\" (two\n  #                words) but not in \"-ufoo\" (one word).\n  # - :regular:    \"Not a command word\", and command delimiters are permitted.\n  #                Mainly used to detect premature termination of commands.\n  # - :always:     The word 'always' in the «{ foo } always { bar }» syntax.\n  #\n  # When the kind of a word is not yet known, $this_word / $next_word may contain\n  # multiple states.  For example, after \"sudo -i\", the next word may be either\n  # another --flag or a command name, hence the state would include both :__start:\n  # and :sudo_opt:.\n  #\n  # The tokens are always added with both leading and trailing colons to serve as\n  # word delimiters (an improvised array); [[ $x == *:foo:* ]] and x=${x//:foo:/}\n  # will DTRT regardless of how many elements or repetitions $x has..\n  #\n  # Handling of redirections: upon seeing a redirection token, we must stall\n  # the current state --- that is, the value of $this_word --- for two iterations\n  # (one for the redirection operator, one for the word following it representing\n  # the redirection target).  Therefore, we set $in_redirection to 2 upon seeing a\n  # redirection operator, decrement it each iteration, and stall the current state\n  # when it is non-zero.  Thus, upon reaching the next word (the one that follows\n  # the redirection operator and target), $this_word will still contain values\n  # appropriate for the word immediately following the word that preceded the\n  # redirection operator.\n  #\n  # The \"the previous word was a redirection operator\" state is not communicated\n  # to the next iteration via $next_word/$this_word as usual, but via\n  # $in_redirection.  The value of $next_word from the iteration that processed\n  # the operator is discarded.\n  #\n\n  # Command exposure for other scripts\n  ZLAST_COMMANDS=()\n  # Restart observing of assigns\n  FAST_ASSIGNS_SEEN=()\n  # Restart function's gathering\n  FAST_HIGHLIGHT[chroma-autoload-elements]=\"\"\n  # Restart FPATH elements gathering\n  FAST_HIGHLIGHT[chroma-fpath_peq-elements]=\"\"\n  # Restart svn zinit's ICE gathering\n  FAST_HIGHLIGHT[chroma-zinit-ice-elements-svn]=0\n  FAST_HIGHLIGHT[chroma-zinit-ice-elements-id-as]=\"\"\n\n  [[ -n $ZCALC_ACTIVE ]] && {\n    _start_pos=0; _end_pos=__len; __arg=$__buf\n    -fast-highlight-math-string\n    return 0\n  }\n\n  # Processing buffer\n  local proc_buf=$__buf needle\n  for __arg in ${interactive_comments-${(z)__buf}} \\\n             ${interactive_comments+${(zZ+c+)__buf}}; do\n\n    # Initialize $next_word to its default value?\n    (( in_redirection = in_redirection > 0 ? in_redirection - 1 : in_redirection ));\n    (( next_word = (in_redirection == 0) ? 2 : next_word )) # else Stall $next_word.\n    (( next_word = next_word | (this_word & (BIT_case_code|8192)) ))\n\n    # If we have a good delimiting construct just ending, and '{'\n    # occurs, then respect this and go for alternate syntax, i.e.\n    # treat '{' (\\x7b) as if it's on command position\n    [[ $__arg = '{' && $__delimited = 2 ]] && { (( this_word = (this_word & ~2) | 1 )); __delimited=0; }\n\n    __asize=${#__arg}\n\n    # Reset state of working variables\n    already_added=0\n    __style=${FAST_THEME_NAME}unknown-token\n    (( this_word & 1 )) && { in_array_assignment=0; [[ $__arg == 'noglob' ]] && highlight_glob=0; }\n\n    # Compute the new $_start_pos and $_end_pos, skipping over whitespace in $__buf.\n    if [[ $__arg == ';' ]] ; then\n      braces_stack=${braces_stack#T}\n      __delimited=0\n\n      # Both ; and \\n are rendered as a \";\" (SEPER) by the ${(z)..} flag.\n      needle=$';\\n'\n      [[ $proc_buf = (#b)[^$needle]#([$needle]##)* ]] && offset=${mbegin[1]}-1\n      (( _start_pos += offset ))\n      (( _end_pos = _start_pos + __asize ))\n\n      # Prepare next loop cycle\n      (( this_word & BIT_case_item )) || { (( in_array_assignment )) && (( this_word = 2 | (this_word & BIT_case_code) )) || { (( this_word = 1 | (this_word & BIT_case_code) )); highlight_glob=1; }; }\n      in_redirection=0\n\n      # Chance to highlight ';'\n      [[ ${proc_buf[offset+1]} != $'\\n' ]] && {\n        [[ ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}commandseparator]} != \"none\" ]] && \\\n          (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n            reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}commandseparator]}\")\n      }\n\n      proc_buf=${proc_buf[offset + __asize + 1,__len]}\n      _start_pos=$_end_pos\n      continue\n    else\n      offset=0\n      if [[ $proc_buf = (#b)(#s)(([[:space:]]|\\\\[[:space:]])##)* ]]; then\n          # The first, outer parenthesis\n          offset=${mend[1]}\n      fi\n      (( _start_pos += offset ))\n      (( _end_pos = _start_pos + __asize ))\n\n      # No-hit will result in value 0\n      __arg_type=${__FAST_HIGHLIGHT_TOKEN_TYPES[$__arg]}\n    fi\n\n    (( this_word & 1 )) && ZLAST_COMMANDS+=( $__arg );\n\n    proc_buf=${proc_buf[offset + __asize + 1,__len]}\n\n    # Handle the INTERACTIVE_COMMENTS option.\n    #\n    # We use the (Z+c+) flag so the entire comment is presented as one token in $__arg.\n    if [[ -n ${interactive_comments+'set'} && $__arg == ${histchars[3]}* ]]; then\n      if (( this_word & 3 )); then\n        __style=${FAST_THEME_NAME}comment\n      else\n        __style=${FAST_THEME_NAME}unknown-token # prematurely terminated\n      fi\n      # ADD\n      (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n      _start_pos=$_end_pos\n      continue\n    fi\n\n    # Redirection?\n    [[ $__arg == (<0-9>|)(\\<|\\>)* && $__arg != (\\<|\\>)$'\\x28'* && $__arg != \"<<<\" ]] && \\\n      in_redirection=2\n\n    # Special-case the first word after 'sudo'.\n    if (( ! in_redirection )); then\n      (( this_word & 4 )) && [[ $__arg != -* ]] && (( this_word = this_word ^ 4 ))\n\n      # Parse the sudo command line\n      if (( this_word & 4 )); then\n        case $__arg in\n          # Flag that requires an argument\n          '-'[Cgprtu])\n                       (( this_word = this_word & ~1 ))\n                       (( next_word = 8 | (this_word & BIT_case_code) ))\n                       ;;\n          # This prevents misbehavior with sudo -u -otherargument\n          '-'*)\n                       (( this_word = this_word & ~1 ))\n                       (( next_word = next_word | 1 | 4 ))\n                       ;;\n        esac\n      elif (( this_word & 8 )); then\n        (( next_word = next_word | 4 | 1 ))\n      elif (( this_word & 64 )); then\n        [[ $__arg = -[pvV-]## && $active_command = \"command\" ]] && (( this_word = (this_word & ~1) | 2, next_word = (next_word | 65) & ~2 ))\n        [[ $__arg = -[cla-]## && $active_command = \"exec\" ]] && (( this_word = (this_word & ~1) | 2, next_word = (next_word | 65) & ~2 ))\n        [[ $__arg = \\{[a-zA-Z_][a-zA-Z0-9_]#\\} && $active_command = \"exec\" ]] && {\n          # Highlight {descriptor} passed to exec\n          (( this_word = (this_word & ~1) | 2, next_word = (next_word | 65) & ~2 ))\n          (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}exec-descriptor]}\")\n          already_added=1\n        }\n      fi\n   fi\n\n   (( this_word & 8192 )) && {\n     __list=( ${(z@)${aliases[$active_command]:-${active_command##*/}}##[[:space:]]#(command|builtin|exec|noglob|nocorrect|pkexec)[[:space:]]#} )\n     ${${FAST_HIGHLIGHT[chroma-${__list[1]}]}%\\%*} ${(M)FAST_HIGHLIGHT[chroma-${__list[1]}]%\\%*} 0 \"$__arg\" $_start_pos $_end_pos 2>/dev/null && continue\n   }\n\n   (( this_word & 1 )) && {\n     # !in_redirection needed particularly for exec {A}>b {C}>d\n     (( !in_redirection )) && active_command=$__arg\n     _mybuf=${${aliases[$active_command]:-${active_command##*/}}##[[:space:]]#(command|builtin|exec|noglob|nocorrect|pkexec)[[:space:]]#}\n     [[ \"$_mybuf\" = (#b)(FPATH+(#c0,1)=)* ]] && _mybuf=\"${match[1]} ${(j: :)${(s,:,)${_mybuf#FPATH+(#c0,1)=}}}\"\n     [[ -n ${FAST_HIGHLIGHT[chroma-${_mybuf%% *}]} ]] && {\n       __list=( ${(z@)_mybuf} )\n       if (( ${#__list} > 1 )) || [[ $active_command != $_mybuf ]]; then\n         __style=${FAST_THEME_NAME}alias\n         (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n\n         ${${FAST_HIGHLIGHT[chroma-${__list[1]}]}%\\%*} ${(M)FAST_HIGHLIGHT[chroma-${__list[1]}]%\\%*} 1 \"${__list[1]}\" \"-100000\" $_end_pos 2>/dev/null || \\\n           (( this_word = next_word, next_word = 2 ))\n\n         for _mybuf in \"${(@)__list[2,-1]}\"; do\n           (( next_word = next_word | (this_word & (BIT_case_code|8192)) ))\n           ${${FAST_HIGHLIGHT[chroma-${__list[1]}]}%\\%*} ${(M)FAST_HIGHLIGHT[chroma-${__list[1]}]%\\%*} 0 \"$_mybuf\" \"-100000\" $_end_pos 2>/dev/null || \\\n             (( this_word = next_word, next_word = 2 ))\n         done\n\n         # This might have been done multiple times in chroma, but\n         # as _end_pos doesn't change, it can be done one more time\n         _start_pos=$_end_pos\n\n         continue\n       else\n         ${${FAST_HIGHLIGHT[chroma-${__list[1]}]}%\\%*} ${(M)FAST_HIGHLIGHT[chroma-${__list[1]}]%\\%*} 1 \"$__arg\" $_start_pos $_end_pos 2>/dev/null && continue\n       fi\n     } || (( 1 ))\n   }\n\n   expanded_path=\"\"\n\n   # The Great Fork: is this a command word?  Is this a non-command word?\n   if (( this_word & 16 )) && [[ $__arg == 'always' ]]; then\n     # try-always construct\n     __style=${FAST_THEME_NAME}reserved-word # de facto a reserved word, although not de jure\n     (( next_word = 1 | (this_word & BIT_case_code) ))\n   elif (( (this_word & 1) && (in_redirection == 0) )) || [[ $braces_stack = T* ]]; then # T - typedef, etc.\n     if (( __arg_type == 1 )); then\n      __style=${FAST_THEME_NAME}precommand\n      [[ $__arg = \"command\" || $__arg = \"exec\" ]] && (( next_word = next_word | 64 ))\n     elif [[ $__arg = (sudo|doas) ]]; then\n      __style=${FAST_THEME_NAME}precommand\n      (( next_word = (next_word & ~2) | 4 | 1 ))\n     else\n       _mybuf=${${(Q)__arg}#\\\"}\n       if (( ${+parameters} )) && \\\n          [[ $_mybuf = (#b)(*)(*)\\$([a-zA-Z_][a-zA-Z0-9_]#|[0-9]##)(*) || \\\n             $_mybuf = (#b)(*)(*)\\$\\{([a-zA-Z_][a-zA-Z0-9_:-]#|[0-9]##)(*) ]] && \\\n         (( ${+parameters[${match[3]%%:-*}]} ))\n       then\n         -fast-highlight-main-type ${match[1]}${match[2]}${(P)match[3]%%:-*}${match[4]#\\}}\n       elif [[ $braces_stack = T* ]]; then # T - typedef, etc.\n         REPLY=none\n       else\n         : ${expanded_path::=${~_mybuf}}\n         -fast-highlight-main-type $expanded_path\n       fi\n\n      case $REPLY in\n        reserved)       # reserved word\n                        [[ $__arg = \"[[\" ]] && __style=${FAST_THEME_NAME}double-sq-bracket || __style=${FAST_THEME_NAME}reserved-word\n                        if [[ $__arg == $'\\x7b' ]]; then # Y - '{'\n                          braces_stack='Y'$braces_stack\n\n                        elif [[ $__arg == $'\\x7d' && $braces_stack = Y* ]]; then # Y - '}'\n                          # We're at command word, so no need to check right_brace_is_recognised_everywhere\n                          braces_stack=${braces_stack#Y}\n                          __style=${FAST_THEME_NAME}reserved-word\n                          (( next_word = next_word | 16 ))\n\n                        elif [[ $__arg == \"[[\" ]]; then  # A - [[\n                          braces_stack='A'$braces_stack\n\n                          # Counting complex brackets (for brackets-highlighter): 1. [[ as command\n                          _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN + 1 )) )\n                        elif [[ $__arg == \"for\" ]]; then\n                          (( next_word = next_word | 32 )) # BIT_for\n\n                        elif [[ $__arg == \"case\" ]]; then\n                          (( next_word = BIT_case_preamble ))\n\n                        elif [[ $__arg = (typeset|declare|local|float|integer|export|readonly) ]]; then\n                          braces_stack='T'$braces_stack\n                        fi\n                        ;;\n        'suffix alias') __style=${FAST_THEME_NAME}suffix-alias;;\n        'global alias') __style=${FAST_THEME_NAME}global-alias;;\n\n        alias)\n                          if [[ $__arg = ?*'='* ]]; then\n                            # The so called (by old code) \"insane_alias\"\n                            __style=${FAST_THEME_NAME}unknown-token\n                          else\n                            __style=${FAST_THEME_NAME}alias\n                            (( ${+aliases} )) && alias_target=${aliases[$__arg]} || alias_target=\"${\"$(alias -- $__arg)\"#*=}\"\n                            [[ ${__FAST_HIGHLIGHT_TOKEN_TYPES[$alias_target]} = \"1\" && $__arg_type != \"1\" ]] && __FAST_HIGHLIGHT_TOKEN_TYPES[$__arg]=\"1\"\n                          fi\n                        ;;\n\n        builtin)        [[ $__arg = \"[\" ]] && {\n                          __style=${FAST_THEME_NAME}single-sq-bracket\n                          _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) )\n                        } || __style=${FAST_THEME_NAME}builtin\n                        # T - typeset, etc. mode\n                        [[ $__arg = (typeset|declare|local|float|integer|export|readonly) ]] && braces_stack='T'$braces_stack\n                        [[ $__arg = eval ]] && (( next_word = next_word | 256 ))\n                        ;;\n\n        function)       __style=${FAST_THEME_NAME}function;;\n\n        command)        __style=${FAST_THEME_NAME}command;;\n\n        hashed)         __style=${FAST_THEME_NAME}hashed-command;;\n\n        dirpath)        __style=${FAST_THEME_NAME}path-to-dir;;\n\n        none)           # Assign?\n                        if [[ $__arg == [a-zA-Z_][a-zA-Z0-9_]#(|\\[[^\\]]#\\])(|[^\\]]#\\])(|[+])=* || $__arg == [0-9]##(|[+])=* || ( $braces_stack = T* && ${__arg_type} != 3 ) ]] {\n                          __style=${FAST_THEME_NAME}assign\n                          FAST_ASSIGNS_SEEN[${__arg%%=*}]=1\n\n                          # Handle array assignment\n                          [[ $__arg = (#b)*=(\\()*(\\))* || $__arg = (#b)*=(\\()* ]] && {\n                              (( __start=_start_pos-__PBUFLEN+${mbegin[1]}-1, __end=__start+1, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}assign-array-bracket]}\")\n                              # Counting complex brackets (for brackets-highlighter): 2. ( in array assign\n                              _FAST_COMPLEX_BRACKETS+=( $__start )\n                              (( mbegin[2] >= 1 )) && {\n                                (( __start=_start_pos-__PBUFLEN+${mbegin[2]}-1, __end=__start+1, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}assign-array-bracket]}\")\n                                # Counting complex brackets (for brackets-highlighter): 3a. ) in array assign\n                                _FAST_COMPLEX_BRACKETS+=( $__start )\n                              } || in_array_assignment=1\n                          } || { [[ ${braces_stack[1]} != 'T' ]] && (( next_word = (next_word | 1) & ~2 )); }\n\n                          # Handle no-string highlight, string \"/' highlight, math mode highlight\n                          local ctmp=\"\\\"\" dtmp=\"'\"\n                          itmp=${__arg[(i)$ctmp]}-1 iitmp=${__arg[(i)$dtmp]}-1\n                          integer jtmp=${__arg[(b:itmp+2:i)$ctmp]} jjtmp=${__arg[(b:iitmp+2:i)$dtmp]}\n                          (( itmp < iitmp && itmp <= __asize - 1 )) && (( jtmp > __asize && (jtmp = __asize), 1 > 0 )) && \\\n                              (( __start=_start_pos-__PBUFLEN+itmp, __end=_start_pos-__PBUFLEN+jtmp, __start >= 0 )) && \\\n                                  reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-quoted-argument]}\") && \\\n                                      { itmp=${__arg[(i)=]}; __arg=${__arg[itmp,__asize]}; (( _start_pos += itmp - 1 ));\n                                        -fast-highlight-string; (( _start_pos = _start_pos - itmp + 1, 1 > 0 )); } || \\\n                          {\n                              (( iitmp <= __asize - 1 )) && (( jjtmp > __asize && (jjtmp = __asize), 1 > 0 )) && \\\n                                  (( __start=_start_pos-__PBUFLEN+iitmp, __end=_start_pos-__PBUFLEN+jjtmp, __start >= 0 )) && \\\n                                      reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}single-quoted-argument]}\")\n                          } || \\\n                            {\n                                itmp=${__arg[(i)=]}; __arg=${__arg[itmp,__asize]}; (( _start_pos += itmp - 1 ));\n                                [[ ${__arg[2,4]} = '$((' ]] && { -fast-highlight-math-string;\n                                   (( __start=_start_pos-__PBUFLEN+2, __end=__start+2, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-paren]}\")\n                                   # Counting complex brackets (for brackets-highlighter): 4. $(( in assign argument\n                                   _FAST_COMPLEX_BRACKETS+=( $__start $(( __start + 1 )) )\n                                   (( jtmp = ${__arg[(I)\\)\\)]}-1, jtmp > 0 )) && {\n                                     (( __start=_start_pos-__PBUFLEN+jtmp, __end=__start+2, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-paren]}\")\n                                     # Counting complex brackets (for brackets-highlighter): 5. )) in assign argument\n                                     _FAST_COMPLEX_BRACKETS+=( $__start $(( __start + 1 )) )\n                                   }\n                                } || -fast-highlight-string;\n                                (( _start_pos = _start_pos - itmp + 1, 1 > 0 ))\n                            }\n\n                        } elif [[ $__arg = ${histchars[1]}* && -n ${__arg[2]} ]] {\n                          __style=${FAST_THEME_NAME}history-expansion\n\n                        } elif [[ $__arg == ${histchars[2]}* ]] {\n                          __style=${FAST_THEME_NAME}history-expansion\n\n                        } elif (( __arg_type == 3 )) {\n                          # This highlights empty commands (semicolon follows nothing) as an error.\n                          # Zsh accepts them, though.\n                          (( this_word & 3 )) && __style=${FAST_THEME_NAME}commandseparator\n\n                        } elif [[ $__arg[1,2] == '((' ]] {\n                          # Arithmetic evaluation.\n                          #\n                          # Note: prior to zsh-5.1.1-52-g4bed2cf (workers/36669), the ${(z)...}\n                          # splitter would only output the '((' token if the matching '))' had\n                          # been typed.  Therefore, under those versions of zsh, BUFFER=\"(( 42\"\n                          # would be highlighted as an error until the matching \"))\" are typed.\n                          #\n                          # We highlight just the opening parentheses, as a reserved word; this\n                          # is how [[ ... ]] is highlighted, too.\n\n                          # ADD\n                          (( __start=_start_pos-__PBUFLEN, __end=__start+2, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-paren]}\")\n                          already_added=1\n\n                          # Counting complex brackets (for brackets-highlighter): 6. (( as command\n                          _FAST_COMPLEX_BRACKETS+=( $__start $(( __start + 1 )) )\n\n                          -fast-highlight-math-string\n\n                          # ADD\n                          [[ $__arg[-2,-1] == '))' ]] && {\n                            (( __start=_end_pos-__PBUFLEN-2, __end=__start+2, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-paren]}\")\n                            (( __delimited = __delimited ? 2 : __delimited ))\n\n                            # Counting complex brackets (for brackets-highlighter): 7. )) for as-command ((\n                            _FAST_COMPLEX_BRACKETS+=( $__start $(( __start + 1 )) )\n                          }\n\n                        } elif [[ $__arg == '()' ]] {\n                          _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN + 1 )) )\n                          # anonymous function\n                          __style=${FAST_THEME_NAME}reserved-word\n                        } elif [[ $__arg == $'\\x28' ]] {\n                          # subshell '(', stack: letter 'R'\n                          __style=${FAST_THEME_NAME}reserved-word\n                          braces_stack='R'$braces_stack\n\n                        } elif [[ $__arg == $'\\x29' ]] {\n                          # ')', stack: letter 'R' for subshell\n                          [[ $braces_stack = R* ]] && { braces_stack=${braces_stack#R}; __style=${FAST_THEME_NAME}reserved-word; }\n\n                        } elif (( this_word & 14 )) {\n                          __style=${FAST_THEME_NAME}default\n\n                        } elif [[ $__arg = (';;'|';&'|';|') ]] && (( this_word & BIT_case_code )) {\n                          (( next_word = (next_word | BIT_case_item) & ~(BIT_case_code+3) ))\n                          __style=${FAST_THEME_NAME}default\n\n                        } elif [[ $__arg = \\$\\([^\\(]* ]] {\n                          already_added=1\n                        }\n                        ;;\n        *)\n                        # ADD\n                        # (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end commandtypefromthefuture-$REPLY\")\n                        already_added=1\n                        ;;\n      esac\n     fi\n   # in_redirection || BIT_regular || BIT_sudo_opt || BIT_sudo_arg\n   elif (( in_redirection + this_word & 14 ))\n   then # $__arg is a non-command word\n      case $__arg in\n        ']]')\n                 # A - [[\n                 [[ $braces_stack = A* ]] && {\n                   __style=${FAST_THEME_NAME}double-sq-bracket\n                   (( __delimited = __delimited ? 2 : __delimited ))\n                   # Counting complex brackets (for brackets-highlighter): 8a. ]] for as-command [[\n                   _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN+1 )) )\n                 } || {\n                   [[ $braces_stack = *A* ]] && {\n                      __style=${FAST_THEME_NAME}unknown-token\n                      # Counting complex brackets (for brackets-highlighter): 8b. ]] for as-command [[\n                      _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN+1 )) )\n                   } || __style=${FAST_THEME_NAME}default\n                 }\n                 braces_stack=${braces_stack#A}\n                 ;;\n        ']')\n                 __style=${FAST_THEME_NAME}single-sq-bracket\n                 _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) )\n                 ;;\n        $'\\x28')\n                 # '(' inside [[\n                 __style=${FAST_THEME_NAME}reserved-word\n                 braces_stack='R'$braces_stack\n                 ;;\n        $'\\x29') # ')' - subshell or end of array assignment\n                 if (( in_array_assignment )); then\n                   in_array_assignment=0\n                   (( next_word = next_word | 1 ))\n                   (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}assign-array-bracket]}\")\n                   already_added=1\n                   # Counting complex brackets (for brackets-highlighter): 3b. ) in array assign\n                   _FAST_COMPLEX_BRACKETS+=( $__start )\n                 elif [[ $braces_stack = R* ]]; then\n                   braces_stack=${braces_stack#R}\n                   __style=${FAST_THEME_NAME}reserved-word\n                 # Zsh doesn't tokenize final ) if it's just single ')',\n                 # but logically what's below is correct, so it is kept\n                 # in case Zsh will be changed / fixed, etc.\n                 elif [[ $braces_stack = F* ]]; then\n                   __style=${FAST_THEME_NAME}builtin\n                 fi\n                 ;;\n        $'\\x28\\x29') # '()' - possibly a function definition\n                 # || false # TODO: or if the previous word was a command word\n                 (( FAST_HIGHLIGHT[multi_func_def] )) && (( next_word = next_word | 1 ))\n                 __style=${FAST_THEME_NAME}reserved-word\n                 _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN + 1 )) )\n                 # Remove possible annoying unknown-token __style, or misleading function __style\n                 reply[-1]=()\n                 __fast_highlight_main__command_type_cache[$active_command]=\"function\"\n                 ;;\n        '--'*)   [[ $__arg == \"--\" ]] && { _was_double_hyphen=1; __style=${FAST_THEME_NAME}double-hyphen-option; } || {\n                   (( !_was_double_hyphen )) && {\n                     [[ \"$__arg\" = (#b)(--[a-zA-Z0-9_]##)=(*) ]] && {\n                       (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n                         reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-hyphen-option]}\")\n                       (( __start=_start_pos-__PBUFLEN+1+mend[1], __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n                        reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}optarg-${${${(M)match[2]:#<->}:+number}:-string}]}\")\n                       already_added=1\n                     } || __style=${FAST_THEME_NAME}double-hyphen-option\n                   } || __style=${FAST_THEME_NAME}default\n                 }\n                 ;;\n        '-'*)    (( !_was_double_hyphen )) && __style=${FAST_THEME_NAME}single-hyphen-option || __style=${FAST_THEME_NAME}default;;\n        \\$\\'*)\n                 (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}dollar-quoted-argument]}\")\n                 -fast-highlight-dollar-string\n                 already_added=1\n                 ;;\n        [\\\"\\']*|[^\\\"\\\\]##([\\\\][\\\\])#\\\"*|[^\\'\\\\]##([\\\\][\\\\])#\\'*)\n                 # 256 is eval-mode\n                 if (( this_word & 256 )) && [[ $__arg = [\\'\\\"]* ]]; then\n                   (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n                     reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}recursive-base]}\")\n                   if [[ -n ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}secondary]} ]]; then\n                     __idx=1\n                     _mybuf=$FAST_THEME_NAME\n                     FAST_THEME_NAME=${${${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}secondary]}:t:r}#(XDG|LOCAL|HOME|OPT):}\n                     (( ${+FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}default]} )) || source $FAST_WORK_DIR/secondary_theme.zsh\n                   else\n                     __idx=0\n                   fi\n                   (( _start_pos-__PBUFLEN >= 0 )) && \\\n                     -fast-highlight-process \"$PREBUFFER\" \"${${__arg%[\\'\\\"]}#[\\'\\\"]}\" $(( _start_pos + 1 ))\n                   (( __idx )) && FAST_THEME_NAME=$_mybuf\n                   already_added=1\n                 else\n                   [[ $__arg = *([^\\\\][\\#][\\#]|\"(#b)\"|\"(#B)\"|\"(#m)\"|\"(#c\")* && $highlight_glob -ne 0 ]] && \\\n                     (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n                       reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}globbing-ext]}\")\n                   # Reusing existing vars, treat this code like C++ STL\n                   # header, full of underscores and unhelpful var names\n                   itmp=0 __workbuf=$__arg __tmp=\"\" cdpath_dir=$__arg\n                   while [[ $__workbuf = (#b)[^\\\"\\'\\\\]#(([\\\"\\'])|[\\\\](*))(*) ]]; do\n                     [[ -n ${match[3]} ]] && {\n                       itmp+=${mbegin[1]}\n                       # Optionally skip 1 quoted char\n                       [[ $__tmp = \\' ]] && __workbuf=${match[3]} || { itmp+=1; __workbuf=${match[3]:1}; }\n                     } || {\n                       itmp+=${mbegin[1]}\n                       __workbuf=${match[4]}\n                       # Toggle quoting\n                       [[ ( ${match[1]} = \\\" && $__tmp != \\' ) || ( ${match[1]} = \\' && $__tmp != \\\" ) ]] && {\n                         [[ $__tmp = [\\\"\\'] ]] && {\n                           # End of quoting\n                           (( __start=_start_pos-__PBUFLEN+iitmp-1, __end=_start_pos-__PBUFLEN+itmp, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}${${${__tmp#\\'}:+double-quoted-argument}:-single-quoted-argument}]}\")\n                           already_added=1\n\n                           [[ $__tmp = \\\" ]] && {\n                             __arg=${cdpath_dir[iitmp+1,itmp-1]}\n                             (( _start_pos += iitmp - 1 + 1 ))\n                             -fast-highlight-string\n                             (( _start_pos = _start_pos - iitmp + 1 - 1 ))\n                           }\n                           # The end-of-quoting proper algorithm action\n                           __tmp=\n                         } || {\n                           # Beginning of quoting\n                           iitmp=itmp\n                           # The beginning-of-quoting proper algorithm action\n                           __tmp=${match[1]}\n                         }\n                       }\n                     }\n                   done\n                   [[ $__tmp = [\\\"\\'] ]] && {\n                     (( __start=_start_pos-__PBUFLEN+iitmp-1, __end=_start_pos-__PBUFLEN+__asize, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}${${${__tmp#\\'}:+double-quoted-argument}:-single-quoted-argument}]}\")\n                     already_added=1\n\n                     [[ $__tmp = \\\" ]] && {\n                       __arg=${cdpath_dir[iitmp+1,__asize]}\n                       (( _start_pos += iitmp - 1 + 1 ))\n                       -fast-highlight-string\n                       (( _start_pos = _start_pos - iitmp + 1 - 1 ))\n                     }\n                   }\n                 fi\n                 ;;\n        \\$\\(\\(*)\n                 already_added=1\n                 -fast-highlight-math-string\n                 # ADD\n                 (( __start=_start_pos-__PBUFLEN+1, __end=__start+2, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-paren]}\")\n                 # Counting complex brackets (for brackets-highlighter): 9. $(( as argument\n                 _FAST_COMPLEX_BRACKETS+=( $__start $(( __start + 1 )) )\n                 # ADD\n                 [[ $__arg[-2,-1] == '))' ]] && (( __start=_end_pos-__PBUFLEN-2, __end=__start+2, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}double-paren]}\")\n                 # Counting complex brackets (for brackets-highlighter): 10. )) for as-argument $((\n                 _FAST_COMPLEX_BRACKETS+=( $__start $(( __start + 1 )) )\n                 ;;\n        '`'*)\n                 (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n                   reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}back-quoted-argument]}\")\n                 if [[ -n ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}secondary]} ]]; then\n                   __idx=1\n                   _mybuf=$FAST_THEME_NAME\n                   FAST_THEME_NAME=${${${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}secondary]}:t:r}#(XDG|LOCAL|HOME|OPT):}\n                   (( ${+FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}default]} )) || source $FAST_WORK_DIR/secondary_theme.zsh\n                 else\n                   __idx=0\n                 fi\n                 (( _start_pos-__PBUFLEN >= 0 )) && \\\n                   -fast-highlight-process \"$PREBUFFER\" \"${${__arg%[\\`]}#[\\`]}\" $(( _start_pos + 1 ))\n                 (( __idx )) && FAST_THEME_NAME=$_mybuf\n                 already_added=1\n          ;;\n        '((')    # 'F' - (( after for\n                 (( this_word & 32 )) && {\n                   braces_stack='F'$braces_stack\n                   __style=${FAST_THEME_NAME}double-paren\n                   # Counting complex brackets (for brackets-highlighter): 11. (( as for-syntax\n                   _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN+1 )) )\n                   # This is set after __arg_type == 2, and also here,\n                   # when another alternate-syntax capable command occurs\n                   __delimited=1\n                 }\n                 ;;\n        '))')    # 'F' - (( after for\n                 [[ $braces_stack = F* ]] && {\n                   braces_stack=${braces_stack#F}\n                   __style=${FAST_THEME_NAME}double-paren\n                   # Counting complex brackets (for brackets-highlighter): 12. )) as for-syntax\n                   _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) $(( _start_pos-__PBUFLEN+1 )) )\n                   (( __delimited = __delimited ? 2 : __delimited ))\n                 }\n                 ;;\n        '<<<')\n                 (( next_word = (next_word | 128) & ~3 ))\n                 [[ ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}here-string-tri]} != \"none\" ]] && (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}here-string-tri]}\")\n                 already_added=1\n                 ;;\n        *)       # F - (( after for\n                 if [[ $braces_stack = F* ]]; then\n                   -fast-highlight-string\n                   _mybuf=$__arg\n                   __idx=_start_pos\n                   while [[ $_mybuf = (#b)[^a-zA-Z\\{\\$]#([a-zA-Z][a-zA-Z0-9]#)(*) ]]; do\n                     (( __start=__idx-__PBUFLEN+${mbegin[1]}-1, __end=__idx-__PBUFLEN+${mend[1]}+1-1, __start >= 0 )) && \\\n                       reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}for-loop-variable]}\")\n                     __idx+=${mend[1]}\n                     _mybuf=${match[2]}\n                   done\n\n                   _mybuf=$__arg\n                   __idx=_start_pos\n                   while [[ $_mybuf = (#b)[^+\\<\\>=:\\*\\|\\&\\^\\~-]#([+\\<\\>=:\\*\\|\\&\\^\\~-]##)(*) ]]; do\n                     (( __start=__idx-__PBUFLEN+${mbegin[1]}-1, __end=__idx-__PBUFLEN+${mend[1]}+1-1, __start >= 0 )) && \\\n                       reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}for-loop-operator]}\")\n                     __idx+=${mend[1]}\n                     _mybuf=${match[2]}\n                   done\n\n                   _mybuf=$__arg\n                   __idx=_start_pos\n                   while [[ $_mybuf = (#b)[^0-9]#([0-9]##)(*) ]]; do\n                     (( __start=__idx-__PBUFLEN+${mbegin[1]}-1, __end=__idx-__PBUFLEN+${mend[1]}+1-1, __start >= 0 )) && \\\n                       reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}for-loop-number]}\")\n                     __idx+=${mend[1]}\n                     _mybuf=${match[2]}\n                   done\n\n                   if [[ $__arg = (#b)[^\\;]#(\\;)[\\ ]# ]]; then\n                     (( __start=_start_pos-__PBUFLEN+${mbegin[1]}-1, __end=_start_pos-__PBUFLEN+${mend[1]}+1-1, __start >= 0 )) && \\\n                       reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}for-loop-separator]}\")\n                   fi\n\n                   already_added=1\n                 elif [[ $__arg = *([^\\\\][\\#][\\#]|\"(#b)\"|\"(#B)\"|\"(#m)\"|\"(#c\")* ]]; then\n                   (( highlight_glob )) && __style=${FAST_THEME_NAME}globbing-ext || __style=${FAST_THEME_NAME}default\n                 elif [[ $__arg = ([*?]*|*[^\\\\][*?]*) ]]; then\n                   (( highlight_glob )) && __style=${FAST_THEME_NAME}globbing || __style=${FAST_THEME_NAME}default\n                 elif [[ $__arg = \\$* ]]; then\n                   __style=${FAST_THEME_NAME}variable\n                 elif [[ $__arg = $'\\x7d' && $braces_stack = Y* && ${FAST_HIGHLIGHT[right_brace_is_recognised_everywhere]} = \"1\" ]]; then\n                   # right brace, i.e. $'\\x7d' == '}'\n                   # Parsing rule: # {\n                   #\n                   #     Additionally, `tt(})' is recognized in any position if neither the\n                   #     tt(IGNORE_BRACES) option nor the tt(IGNORE_CLOSE_BRACES) option is set.\"\"\"\n                   braces_stack=${braces_stack#Y}\n                   __style=${FAST_THEME_NAME}reserved-word\n                   (( next_word = next_word | 16 ))\n                 elif [[ $__arg = (';;'|';&'|';|') ]] && (( this_word & BIT_case_code )); then\n                   (( next_word = (next_word | BIT_case_item) & ~(BIT_case_code+3) ))\n                   __style=${FAST_THEME_NAME}default\n                 elif [[ $__arg = ${histchars[1]}* && -n ${__arg[2]} ]]; then\n                   __style=${FAST_THEME_NAME}history-expansion\n                 elif (( __arg_type == 3 )); then\n                   __style=${FAST_THEME_NAME}commandseparator\n                 elif (( in_redirection == 2 )); then\n                   __style=${FAST_THEME_NAME}redirection\n                 elif (( ${+galiases[(e)${(Q)__arg}]} )); then\n                   __style=${FAST_THEME_NAME}global-alias\n                 else\n                   if [[ ${FAST_HIGHLIGHT[no_check_paths]} != 1 ]]; then\n                     if [[ ${FAST_HIGHLIGHT[use_async]} != 1 ]]; then\n\t\t       if -fast-highlight-check-path noasync; then\n\t\t\t # ADD\n\t\t\t (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n                         already_added=1\n\n                         # TODO: path separators, optimize and add to async code-path\n                         [[ -n ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}path_pathseparator]} && ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}path]} != ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}path_pathseparator]} ]] && {\n                           for (( __pos = _start_pos; __pos <= _end_pos; __pos++ )) ; do\n                             # ADD\n                             [[ ${__buf[__pos]} == \"/\" ]] && (( __start=__pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$(( __start - 1 )) $__start ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}path_pathseparator]}\")\n                           done\n                         }\n                       else\n                         __style=${FAST_THEME_NAME}default\n\t\t       fi\n\t\t     else\n\t\t       if [[ -z ${FAST_HIGHLIGHT[cache-path-${(q)__arg}-${_start_pos}]} || $(( EPOCHSECONDS - FAST_HIGHLIGHT[cache-path-${(q)__arg}-${_start_pos}-born-at] )) -gt 8 ]]; then\n\t\t\t if [[ $LASTWIDGET != *-or-beginning-search ]]; then\n\t\t\t   exec {PCFD}< <(-fast-highlight-check-path; sleep 5)\n\t\t\t   command sleep 0\n\t\t\t   FAST_HIGHLIGHT[path-queue]+=\";$_start_pos $_end_pos;\"\n\t\t\t   is-at-least 5.0.6 && __pos=1 || __pos=0\n\t\t\t   zle -F ${${__pos:#0}:+-w} $PCFD fast-highlight-check-path-handler\n                           already_added=1\n                         else\n                           __style=${FAST_THEME_NAME}default\n\t\t\t fi\n\t\t       elif [[ ${FAST_HIGHLIGHT[cache-path-${(q)__arg}-${_start_pos}]%D} -eq 1 ]]; then\n                         (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}path${${(M)FAST_HIGHLIGHT[cache-path-${(q)__arg}-${_start_pos}]%D}:+-to-dir}]}\")\n\t\t\t already_added=1\n\t\t       else\n\t\t\t __style=${FAST_THEME_NAME}default\n\t\t       fi\n                     fi\n                   else\n                     __style=${FAST_THEME_NAME}default\n                   fi\n                 fi\n                 ;;\n      esac\n    elif (( this_word & 128 ))\n    then\n      (( next_word = (next_word | 2) & ~129 ))\n      [[ ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}here-string-text]} != \"none\" ]] && (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}here-string-text]}\")\n      -fast-highlight-string ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}here-string-var]:#none}\n      already_added=1\n    elif (( this_word & (BIT_case_preamble + BIT_case_item) ))\n    then\n      if (( this_word & BIT_case_preamble )); then\n        [[ $__arg = \"in\" ]] && {\n          __style=${FAST_THEME_NAME}reserved-word\n          (( next_word = BIT_case_item ))\n        } || {\n          __style=${FAST_THEME_NAME}case-input\n          (( next_word = BIT_case_preamble ))\n        }\n      else\n        if (( this_word & BIT_case_nempty_item == 0 )) && [[ $__arg = \"esac\" ]]; then\n          (( next_word = 1 ))\n          __style=${FAST_THEME_NAME}reserved-word\n        elif [[ $__arg = (\\(*\\)|\\)|\\() ]]; then\n          [[ $__arg = *\\) ]] && (( next_word = BIT_case_code | 1 )) || (( next_word = BIT_case_item | BIT_case_nempty_item ))\n          _FAST_COMPLEX_BRACKETS+=( $(( _start_pos-__PBUFLEN )) )\n          (( ${#__arg} > 1 )) && {\n            _FAST_COMPLEX_BRACKETS+=( $(( _start_pos+${#__arg}-1-__PBUFLEN )) )\n            (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && \\\n              reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}case-parentheses]}\")\n            (( __start=_start_pos+1-__PBUFLEN, __end=_end_pos-1-__PBUFLEN, __start >= 0 )) && \\\n              reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}case-condition]}\")\n            already_added=1\n          } || {\n            __style=${FAST_THEME_NAME}case-parentheses\n          }\n        else\n          (( next_word = BIT_case_item | BIT_case_nempty_item ))\n          __style=${FAST_THEME_NAME}case-condition\n        fi\n      fi\n    fi\n    if [[ $__arg = (#b)*'#'(([0-9a-fA-F][0-9a-fA-F])([0-9a-fA-F][0-9a-fA-F])([0-9a-fA-F][0-9a-fA-F])|([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F]))(|[^[:alnum:]]*) || $__arg = (#b)*'rgb('(([0-9a-fA-F][0-9a-fA-F](#c0,1)),([0-9a-fA-F][0-9a-fA-F](#c0,1)),([0-9a-fA-F][0-9a-fA-F](#c0,1)))* ]]; then\n      if [[ -n $match[2] ]]; then\n        if [[ $match[2] = ?? || $match[3] = ?? || $match[4] = ?? ]]; then\n          (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end bg=#${(l:2::0:)match[2]}${(l:2::0:)match[3]}${(l:2::0:)match[4]}\")\n        else\n          (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end bg=#$match[2]$match[3]$match[4]\")\n        fi\n      else\n        (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end bg=#$match[5]$match[6]$match[7]\")\n      fi\n      already_added=1\n    fi\n\n    # ADD\n    (( already_added == 0 )) && [[ ${FAST_HIGHLIGHT_STYLES[$__style]} != \"none\" ]] && (( __start=_start_pos-__PBUFLEN, __end=_end_pos-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n\n    if (( (__arg_type == 3) && ((this_word & (BIT_case_preamble|BIT_case_item)) == 0) )); then\n      if [[ $__arg == ';' ]] && (( in_array_assignment )); then\n        # literal newline inside an array assignment\n        (( next_word = 2 | (next_word & BIT_case_code) ))\n      elif [[ -n ${braces_stack[(r)A]} ]]; then\n        # 'A' in stack -> inside [[ ... ]]\n        (( next_word = 2 | (next_word & BIT_case_code) ))\n      else\n        braces_stack=${braces_stack#T}\n        (( next_word = 1 | (next_word & BIT_case_code) ))\n        highlight_glob=1\n        # A new command means that we should not expect that alternate\n        # syntax will occur (this is also in the ';' short-path), but\n        # || and && mean going down just 1 step, not all the way to 0\n        [[ $__arg != (\"||\"|\"&&\") ]] && __delimited=0 || (( __delimited = __delimited == 2 ? 1 : __delimited ))\n      fi\n    elif (( ( (__arg_type == 1) || (__arg_type == 2) ) && (this_word & 1) )); then # (( __arg_type == 1 || __arg_type == 2 )) && (( this_word & 1 ))\n        __delimited=1\n        (( next_word = 1 | (next_word & (64 | BIT_case_code)) ))\n    elif [[ $__arg == \"repeat\" ]] && (( this_word & 1 )); then\n      __delimited=1\n      # skip the repeat-count word\n      in_redirection=2\n      # The redirection mechanism assumes $this_word describes the word\n      # following the redirection.  Make it so.\n      #\n      # That word can be a command word with shortloops (`repeat 2 ls`)\n      # or a command separator (`repeat 2; ls` or `repeat 2; do ls; done`).\n      #\n      # The repeat-count word will be handled like a redirection target.\n      (( this_word = 3 ))\n    fi\n    _start_pos=$_end_pos\n    # This is the default/common codepath.\n    (( this_word = in_redirection == 0 ? next_word : this_word )) #else # Stall $this_word.\n  done\n\n  # Do we have whole buffer? I.e. start at zero\n  [[ $3 != 0 ]] && return 0\n\n  # The loop overwrites \")\" with \"x\", except those from $( ) substitution\n  #\n  # __pos: current nest level, starts from 0\n  # __workbuf: copy of __buf, with limit on 250 characters\n  # __idx: index in whole command line buffer\n  # __list: list of coordinates of ) which shouldn't be ovewritten\n  _mybuf=${__buf[1,250]} __workbuf=$_mybuf __idx=0 __pos=0 __list=()\n\n  while [[ $__workbuf = (#b)[^\\(\\)]#([\\(\\)])(*) ]]; do\n    if [[ ${match[1]} == \\( ]]; then\n      __arg=${_mybuf[__idx+${mbegin[1]}-1,__idx+${mbegin[1]}-1+2]}\n      [[ $__arg = '$('[^\\(] ]] && __list+=( $__pos )\n      [[ $__arg = '$((' ]] && _mybuf[__idx+${mbegin[1]}-1]=x\n      # Increase parenthesis level\n      __pos+=1\n    else\n      # Decrease parenthesis level\n      __pos=__pos-1\n      [[ -z ${__list[(r)$__pos]} ]] && [[ $__pos -gt 0 ]] && _mybuf[__idx+${mbegin[1]}]=x\n    fi\n    __idx+=${mbegin[2]}-1\n    __workbuf=${match[2]}\n  done\n\n  # Run on fake buffer with replaced parentheses: \")\" into \"x\"\n  if [[ \"$_mybuf\" = *$__nul* ]]; then\n    # Try to avoid conflict with the \\0, however\n    # we have to split at *some* character - \\7\n    # is ^G, so one cannot have null and ^G at\n    # the same time on the command line\n    __nul=$'\\7'\n  fi\n\n  __inputs=( ${(ps:$__nul:)${(S)_mybuf//(#b)*\\$\\(([^\\)]#)(\\)|(#e))/${mbegin[1]};${mend[1]}${__nul}}%$__nul*} )\n  if [[ \"${__inputs[1]}\" != \"$_mybuf\" && -n \"${__inputs[1]}\" ]]; then\n    if [[ -n ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}secondary]} ]]; then\n      __idx=1\n      __tmp=$FAST_THEME_NAME\n      FAST_THEME_NAME=${${${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}secondary]}:t:r}#(XDG|LOCAL|HOME|OPT):}\n      (( ${+FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}default]} )) || source $FAST_WORK_DIR/secondary_theme.zsh\n    else\n      __idx=0\n    fi\n    for _mybuf in $__inputs; do\n      (( __start=${_mybuf%%;*}-__PBUFLEN-1, __end=${_mybuf##*;}-__PBUFLEN, __start >= 0 )) && \\\n        reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${__tmp}recursive-base]}\")\n      # Pass authentic buffer for recursive analysis\n      -fast-highlight-process \"$PREBUFFER\" \"${__buf[${_mybuf%%;*},${_mybuf##*;}]}\" $(( ${_mybuf%%;*} - 1 ))\n    done\n    # Restore theme\n    (( __idx )) && FAST_THEME_NAME=$__tmp\n  fi\n\n  return 0\n}\n\n-fast-highlight-check-path()\n{\n  (( _start_pos-__PBUFLEN >= 0 )) || \\\n    { [[ $1 != \"noasync\" ]] && print -r -- \"- $_start_pos $_end_pos\"; return 1; }\n  [[ $1 != \"noasync\" ]] && {\n    print -r -- ${sysparams[pid]}\n    # This is to fill cache\n    print -r -- $__arg\n  }\n\n  : ${expanded_path:=${(Q)~__arg}}\n  [[ -n ${FAST_BLIST_PATTERNS[(k)${${(M)expanded_path:#/*}:-$PWD/$expanded_path}]} ]] && { [[ $1 != \"noasync\" ]] && print -r -- \"- $_start_pos $_end_pos\"; return 1; }\n\n  [[ -z $expanded_path ]] && { [[ $1 != \"noasync\" ]] && print -r -- \"- $_start_pos $_end_pos\"; return 1; }\n  [[ -d $expanded_path ]] && { [[ $1 != \"noasync\" ]] && print -r -- \"$_start_pos ${_end_pos}D\" || __style=${FAST_THEME_NAME}path-to-dir; return 0; }\n  [[ -e $expanded_path ]] && { [[ $1 != \"noasync\" ]] && print -r -- \"$_start_pos $_end_pos\" || __style=${FAST_THEME_NAME}path; return 0; }\n\n  # Search the path in CDPATH, only for CD command\n  [[ $active_command = \"cd\" ]] && for cdpath_dir in $cdpath; do\n    [[ -d $cdpath_dir/$expanded_path ]] && { [[ $1 != \"noasync\" ]] && print -r -- \"$_start_pos ${_end_pos}D\" || __style=${FAST_THEME_NAME}path-to-dir; return 0; }\n    [[ -e $cdpath_dir/$expanded_path ]] && { [[ $1 != \"noasync\" ]] && print -r -- \"$_start_pos $_end_pos\" || __style=${FAST_THEME_NAME}path; return 0; }\n  done\n\n  # It's not a path.\n  [[ $1 != \"noasync\" ]] && print -r -- \"- $_start_pos $_end_pos\"\n  return 1\n}\n\n-fast-highlight-check-path-handler() {\n  local IFS=$'\\n' pid PCFD=$1 line stripped val\n  integer idx\n\n  if read -r -u $PCFD pid; then\n    if read -r -u $PCFD val; then\n      if read -r -u $PCFD line; then\n        stripped=${${line#- }%D}\n        FAST_HIGHLIGHT[cache-path-${(q)val}-${stripped%% *}-born-at]=$EPOCHSECONDS\n        idx=${${FAST_HIGHLIGHT[path-queue]}[(I)$stripped]}\n        (( idx > 0 )) && {\n          if [[ $line != -* ]]; then\n            FAST_HIGHLIGHT[cache-path-${(q)val}-${stripped%% *}]=\"1${(M)line%D}\"\n            region_highlight+=(\"${line%% *} ${${line##* }%D} ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}path${${(M)line%D}:+-to-dir}]}\")\n          else\n            FAST_HIGHLIGHT[cache-path-${(q)val}-${stripped%% *}]=0\n          fi\n          val=${FAST_HIGHLIGHT[path-queue]}\n          val[idx-1,idx+${#stripped}]=\"\"\n          FAST_HIGHLIGHT[path-queue]=$val\n          [[ ${FAST_HIGHLIGHT[cache-path-${(q)val}-${stripped%% *}]%D} = 1 && ${#val} -le 27 ]] && zle -R\n        }\n      fi\n    fi\n    kill -9 $pid 2>/dev/null\n  fi\n\n  zle -F -w ${PCFD}\n  exec {PCFD}<&-\n}\n\nzle -N -- fast-highlight-check-path-handler -fast-highlight-check-path-handler\n\n# Highlight special blocks inside double-quoted strings\n#\n# The while [[ ... ]] pattern is logically ((A)|(B)|(C)|(D)|(E))(*), where:\n# - A matches $var[abc]\n# - B matches ${(...)var[abc]}\n# - C matches $\n# - D matches \\$ or \\\" or \\'\n# - E matches \\*\n#\n# and the first condition -n ${match[7] uses D to continue searching when\n# backslash-something (not ['\"$]) is occured.\n#\n# $1 - additional style to glue-in to added style\n-fast-highlight-string()\n{\n  (( _start_pos-__PBUFLEN >= 0 )) || return 0\n  _mybuf=$__arg\n  __idx=_start_pos\n\n  #                                                                                                                                                                                                    7   8\n  while [[ $_mybuf = (#b)[^\\$\\\\]#((\\$(#B)([#+^=~](#c1,2))(#c0,1)(#B)([a-zA-Z_:][a-zA-Z0-9_:]#|[0-9]##)(#b)(\\[[^\\]]#\\])(#c0,1))|(\\$[{](#B)([#+^=~](#c1,2))(#c0,1)(#b)(\\([a-zA-Z0-9_:@%#]##\\))(#c0,1)[a-zA-Z0-9_:#]##(\\[[^\\]]#\\])(#c0,1)[}])|\\$|[\\\\][\\'\\\"\\$]|[\\\\](*))(*) ]]; do\n    [[ -n ${match[7]} ]] && {\n      # Skip following char – it is quoted. Choice is\n      # made to not highlight such quoting\n      __idx+=${mbegin[1]}+1\n      _mybuf=${match[7]:1}\n    } || {\n      __idx+=${mbegin[1]}-1\n      _end_idx=__idx+${mend[1]}-${mbegin[1]}+1\n      _mybuf=${match[8]}\n\n      # ADD\n      (( __start=__idx-__PBUFLEN, __end=_end_idx-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${${1:+$1}:-${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}back-or-dollar-double-quoted-argument]}}\")\n\n      __idx=_end_idx\n    }\n  done\n  return 0\n}\n\n# Highlight math and non-math context variables inside $(( )) and (( ))\n#\n# The while [[ ... ]] pattern is logically ((A)|(B)|(C)|(D))(*), where:\n# - A matches $var[abc]\n# - B matches ${(...)var[abc]}\n# - C matches $\n# - D matches words [a-zA-Z]## (variables)\n#\n# Parameters used: _mybuf, __idx, _end_idx, __style\n-fast-highlight-math-string()\n{\n  (( _start_pos-__PBUFLEN >= 0 )) || return 0\n  _mybuf=$__arg\n  __idx=_start_pos\n\n  #                                                                                                                                                                                                                       7\n  while [[ $_mybuf = (#b)[^\\$_a-zA-Z0-9]#((\\$(#B)(+|)(#B)([a-zA-Z_:][a-zA-Z0-9_:]#|[0-9]##)(#b)(\\[[^\\]]##\\])(#c0,1))|(\\$[{](#B)(+|)(#b)(\\([a-zA-Z0-9_:@%#]##\\))(#c0,1)[a-zA-Z0-9_:#]##(\\[[^\\]]##\\])(#c0,1)[}])|\\$|[a-zA-Z_][a-zA-Z0-9_]#|[0-9]##)(*) ]]; do\n    __idx+=${mbegin[1]}-1\n    _end_idx=__idx+${mend[1]}-${mbegin[1]}+1\n    _mybuf=${match[7]}\n\n    [[ ${match[1]} = [0-9]* ]] && __style=${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}mathnum]} || {\n      [[ ${match[1]} = [a-zA-Z_]* ]] && {\n        [[ ${+parameters[${match[1]}]} = 1 || ${FAST_ASSIGNS_SEEN[${match[1]}]} = 1 ]] && \\\n            __style=${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}mathvar]} || \\\n            __style=${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}matherr]}\n      } || {\n        [[ ${match[1]} = \"$\"* ]] && {\n          match[1]=${match[1]//[\\{\\}+]/}\n          if [[ ${match[1]} = \"$\" || ${FAST_ASSIGNS_SEEN[${match[1]:1}]} = 1 ]] || \\\n            { eval \"[[ -n \\${(P)\\${match[1]:1}} ]]\" } 2>> /dev/null; then\n                __style=${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}back-or-dollar-double-quoted-argument]}\n          else\n            __style=${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}matherr]}\n          fi\n        }\n      }\n    }\n\n    # ADD\n    [[ $__style != \"none\" && -n $__style ]] && (( __start=__idx-__PBUFLEN, __end=_end_idx-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end $__style\")\n\n    __idx=_end_idx\n  done\n}\n\n# Highlight special chars inside dollar-quoted strings\n-fast-highlight-dollar-string()\n{\n  (( _start_pos-__PBUFLEN >= 0 )) || return 0\n  local i j k __style\n  local AA\n  integer c\n\n  # Starting dollar-quote is at 1:2, so __start parsing at offset 3 in the string.\n  for (( i = 3 ; i < _end_pos - _start_pos ; i += 1 )) ; do\n    (( j = i + _start_pos - 1 ))\n    (( k = j + 1 ))\n\n    case ${__arg[$i]} in\n      \"\\\\\") __style=${FAST_THEME_NAME}back-dollar-quoted-argument\n            for (( c = i + 1 ; c <= _end_pos - _start_pos ; c += 1 )); do\n              [[ ${__arg[$c]} != ([0-9xXuUa-fA-F]) ]] && break\n            done\n            AA=$__arg[$i+1,$c-1]\n            # Matching for HEX and OCT values like \\0xA6, \\xA6 or \\012\n            if [[    \"$AA\" == (#m)(#s)(x|X)[0-9a-fA-F](#c1,2)\n                  || \"$AA\" == (#m)(#s)[0-7](#c1,3)\n                  || \"$AA\" == (#m)(#s)u[0-9a-fA-F](#c1,4)\n                  || \"$AA\" == (#m)(#s)U[0-9a-fA-F](#c1,8)\n               ]]; then\n              (( k += MEND ))\n              (( i += MEND ))\n            else\n              if (( __asize > i+1 )) && [[ $__arg[i+1] == [xXuU] ]]; then\n                # \\x not followed by hex digits is probably an error\n                __style=${FAST_THEME_NAME}unknown-token\n              fi\n              (( k += 1 )) # Color following char too.\n              (( i += 1 )) # Skip parsing the escaped char.\n            fi\n            ;;\n      *) continue ;;\n\n    esac\n    # ADD\n    (( __start=j-__PBUFLEN, __end=k-__PBUFLEN, __start >= 0 )) && reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n  done\n}\n\n-fast-highlight-init() {\n  _FAST_COMPLEX_BRACKETS=()\n  __fast_highlight_main__command_type_cache=()\n}\n\ntypeset -ga FSH_LIST\n-fsh_sy_h_shappend() {\n    FSH_LIST+=( \"$(( $1 - 1 ));;$(( $2 ))\" )\n}\n\nfunctions -M fsh_sy_h_append 2 2 -fsh_sy_h_shappend 2>/dev/null\n\n# vim:ft=zsh:sw=2:sts=2\n"
        },
        {
          "name": "fast-string-highlight",
          "type": "blob",
          "size": 3.0537109375,
          "content": "# vim:ft=zsh:sw=4:sts=4\n\n#\n# $1 - PREBUFFER\n# $2 - BUFFER\n#\nfunction -fast-highlight-string-process {\n    emulate -LR zsh\n    setopt extendedglob warncreateglobal typesetsilent\n\n    local -A pos_to_level level_to_pos pair_map final_pairs\n    local input=$1$2 _mybuf=$1$2 __style __quoting\n    integer __idx=0 __pair_idx __level=0 __start __end\n    local -a match mbegin mend\n\n    pair_map=( \"(\" \")\" \"{\" \"}\" \"[\" \"]\" )\n\n    while [[ $_mybuf = (#b)([^\"{}()[]\\\\\\\"'\"]#)(([\"({[]})\\\"'\"])|[\\\\](*))(*) ]]; do\n        if [[ -n ${match[4]} ]] {\n            __idx+=${mbegin[2]}\n\n            [[ $__quoting = \\' ]] && _mybuf=${match[4]} || { _mybuf=${match[4]:1}; (( ++ __idx )); }\n        } else {\n            __idx+=${mbegin[2]}\n            [[ -z $__quoting && -z ${_FAST_COMPLEX_BRACKETS[(r)$((__idx-${#PREBUFFER}-1))]} ]] && {\n                if [[ ${match[2]} = [\"({[\"] ]]; then\n                    pos_to_level[$__idx]=$(( ++__level ))\n                    level_to_pos[$__level]=$__idx\n                elif [[ ${match[2]} = [\"]})\"] ]]; then\n                    if (( __level > 0 )); then\n                        __pair_idx=${level_to_pos[$__level]}\n                        pos_to_level[$__idx]=$(( __level -- ))\n                        [[ ${pair_map[${input[__pair_idx]}]} = ${input[__idx]} ]] && {\n                            final_pairs[$__idx]=$__pair_idx\n                            final_pairs[$__pair_idx]=$__idx\n                        }\n                    else\n                        pos_to_level[$__idx]=-1\n                    fi\n                fi\n            }\n\n            if [[ ${match[2]} = \\\" && $__quoting != \\' ]] {\n                [[ $__quoting = '\"' ]] && __quoting=\"\" || __quoting='\"';\n            }\n            if [[ ${match[2]} = \\' && $__quoting != \\\" ]] {\n                if [[ $__quoting = (\"'\"|\"$'\") ]] {\n                    __quoting=\"\"\n                } else {\n                    if [[ $match[1] = *\\$ ]] {\n                        __quoting=\"\\$'\";\n                    } else {\n                        __quoting=\"'\";\n                    }\n                }\n            }\n            _mybuf=${match[5]}\n        }\n    done\n\n    for __idx in ${(k)pos_to_level}; do\n        (( ${+final_pairs[$__idx]} )) && __style=${FAST_THEME_NAME}bracket-level-$(( ( (pos_to_level[$__idx]-1) % 3 ) + 1 )) || __style=${FAST_THEME_NAME}unknown-token\n        (( __start=__idx-${#PREBUFFER}-1, __end=__idx-${#PREBUFFER}, __start >= 0 )) && \\\n            reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}\")\n    done\n\n    # If cursor is on a bracket, then highlight corresponding bracket, if any.\n    if [[ $WIDGET != zle-line-finish ]]; then\n        __idx=$(( CURSOR + 1 ))\n        if (( ${+pos_to_level[$__idx]} )) && (( ${+final_pairs[$__idx]} )); then\n            (( __start=final_pairs[$__idx]-${#PREBUFFER}-1, __end=final_pairs[$__idx]-${#PREBUFFER}, __start >= 0 )) && \\\n                reply+=(\"$__start $__end ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}paired-bracket]}\") && \\\n                reply+=(\"$CURSOR $__idx ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}paired-bracket]}\")\n        fi\n    fi\n    return 0\n}\n"
        },
        {
          "name": "fast-syntax-highlighting.plugin.zsh",
          "type": "blob",
          "size": 15.8720703125,
          "content": "# -------------------------------------------------------------------------------------------------\n# Copyright (c) 2010-2016 zsh-syntax-highlighting contributors\n# Copyright (c) 2017-2019 Sebastian Gniazdowski (modifications)\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, are permitted\n# provided that the following conditions are met:\n#\n#  * Redistributions of source code must retain the above copyright notice, this list of conditions\n#    and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright notice, this list of\n#    conditions and the following disclaimer in the documentation and/or other materials provided\n#    with the distribution.\n#  * Neither the name of the zsh-syntax-highlighting contributors nor the names of its contributors\n#    may be used to endorse or promote products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# -------------------------------------------------------------------------------------------------\n# -*- mode: zsh; sh-indentation: 2; indent-tabs-mode: nil; sh-basic-offset: 2; -*-\n# vim: ft=zsh sw=2 ts=2 et\n# -------------------------------------------------------------------------------------------------\n\n\n# Standarized way of handling finding plugin dir,\n# regardless of functionargzero and posixargzero,\n# and with an option for a plugin manager to alter\n# the plugin directory (i.e. set ZERO parameter)\n# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html\n0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\"\n0=\"${${(M)0:#/*}:-$PWD/$0}\"\n\ntypeset -g FAST_HIGHLIGHT_VERSION=1.55\ntypeset -g FAST_BASE_DIR=\"${0:h}\"\ntypeset -ga _FAST_MAIN_CACHE\n# Holds list of indices pointing at brackets that\n# are complex, i.e. e.g. part of \"[[\" in [[ ... ]]\ntypeset -ga _FAST_COMPLEX_BRACKETS\n\ntypeset -g FAST_WORK_DIR=${FAST_WORK_DIR:-${XDG_CACHE_HOME:-~/.cache}/fast-syntax-highlighting}\n: ${FAST_WORK_DIR:=${FAST_BASE_DIR-}}\n# Expand any tilde in the (supposed) path.\nFAST_WORK_DIR=${~FAST_WORK_DIR}\n\n# Last (currently, possibly) loaded plugin isn't \"fast-syntax-highlighting\"?\n# And FPATH isn't containing plugin dir?\nif [[ ${zsh_loaded_plugins[-1]-} != */fast-syntax-highlighting && -z ${fpath[(r)${0:h}]-} ]]\nthen\n    fpath+=( \"${0:h}\" )\nfi\n\nif [[ ! -w $FAST_WORK_DIR ]]; then\n    FAST_WORK_DIR=\"${XDG_CACHE_HOME:-$HOME/.cache}/fsh\"\n    command mkdir -p \"$FAST_WORK_DIR\"\nfi\n\n# Invokes each highlighter that needs updating.\n# This function is supposed to be called whenever the ZLE state changes.\n_zsh_highlight()\n{\n  # Store the previous command return code to restore it whatever happens.\n  local ret=$?\n\n  # Remove all highlighting in isearch, so that only the underlining done by zsh itself remains.\n  # For details see FAQ entry 'Why does syntax highlighting not work while searching history?'.\n  if [[ $WIDGET == zle-isearch-update ]] && ! (( $+ISEARCHMATCH_ACTIVE )); then\n    region_highlight=()\n    return $ret\n  fi\n\n  emulate -LR zsh\n  setopt extendedglob warncreateglobal typesetsilent noshortloops\n\n  local REPLY # don't leak $REPLY into global scope\n  local -a reply\n\n  # Do not highlight if there are more than 300 chars in the buffer. It's most\n  # likely a pasted command or a huge list of files in that case..\n  [[ -n ${ZSH_HIGHLIGHT_MAXLENGTH:-} ]] && [[ $#BUFFER -gt $ZSH_HIGHLIGHT_MAXLENGTH ]] && return $ret\n\n  # Do not highlight if there are pending inputs (copy/paste).\n  [[ $PENDING -gt 0 ]] && return $ret\n\n  # Reset region highlight to build it from scratch\n  # may need to remove path_prefix highlighting when the line ends\n  if [[ $WIDGET == zle-line-finish ]] || _zsh_highlight_buffer_modified; then\n      -fast-highlight-init\n      -fast-highlight-process \"$PREBUFFER\" \"$BUFFER\" 0\n      (( FAST_HIGHLIGHT[use_brackets] )) && {\n          _FAST_MAIN_CACHE=( $reply )\n          -fast-highlight-string-process \"$PREBUFFER\" \"$BUFFER\"\n      }\n      region_highlight=( $reply )\n  else\n      local char=\"${BUFFER[CURSOR+1]}\"\n      if [[ \"$char\" = [\"{([])}\"] || \"${FAST_HIGHLIGHT[prev_char]}\" = [\"{([])}\"] ]]; then\n          FAST_HIGHLIGHT[prev_char]=\"$char\"\n          (( FAST_HIGHLIGHT[use_brackets] )) && {\n              reply=( $_FAST_MAIN_CACHE )\n              -fast-highlight-string-process \"$PREBUFFER\" \"$BUFFER\"\n              region_highlight=( $reply )\n          }\n      fi\n  fi\n\n  {\n    local cache_place\n    local -a region_highlight_copy\n\n    # Re-apply zle_highlight settings\n\n    # region\n    if (( REGION_ACTIVE == 1 )); then\n      _zsh_highlight_apply_zle_highlight region standout \"$MARK\" \"$CURSOR\"\n    elif (( REGION_ACTIVE == 2 )); then\n      () {\n        local needle=$'\\n'\n        integer min max\n        if (( MARK > CURSOR )) ; then\n          min=$CURSOR max=$(( MARK + 1 ))\n        else\n          min=$MARK max=$CURSOR\n        fi\n        (( min = ${${BUFFER[1,$min]}[(I)$needle]} ))\n        (( max += ${${BUFFER:($max-1)}[(i)$needle]} - 1 ))\n        _zsh_highlight_apply_zle_highlight region standout \"$min\" \"$max\"\n      }\n    fi\n\n    # yank / paste (zsh-5.1.1 and newer)\n    (( $+YANK_ACTIVE )) && (( YANK_ACTIVE )) && _zsh_highlight_apply_zle_highlight paste standout \"$YANK_START\" \"$YANK_END\"\n\n    # isearch\n    (( $+ISEARCHMATCH_ACTIVE )) && (( ISEARCHMATCH_ACTIVE )) && _zsh_highlight_apply_zle_highlight isearch underline \"$ISEARCHMATCH_START\" \"$ISEARCHMATCH_END\"\n\n    # suffix\n    (( $+SUFFIX_ACTIVE )) && (( SUFFIX_ACTIVE )) && _zsh_highlight_apply_zle_highlight suffix bold \"$SUFFIX_START\" \"$SUFFIX_END\"\n\n    return $ret\n\n  } always {\n    typeset -g _ZSH_HIGHLIGHT_PRIOR_BUFFER=\"$BUFFER\"\n    typeset -g _ZSH_HIGHLIGHT_PRIOR_RACTIVE=\"$REGION_ACTIVE\"\n    typeset -gi _ZSH_HIGHLIGHT_PRIOR_CURSOR=$CURSOR\n  }\n}\n\n# Apply highlighting based on entries in the zle_highlight array.\n# This function takes four arguments:\n# 1. The exact entry (no patterns) in the zle_highlight array:\n#    region, paste, isearch, or suffix\n# 2. The default highlighting that should be applied if the entry is unset\n# 3. and 4. Two integer values describing the beginning and end of the\n#    range. The order does not matter.\n_zsh_highlight_apply_zle_highlight() {\n  local entry=\"$1\" default=\"$2\"\n  integer first=\"$3\" second=\"$4\"\n\n  # read the relevant entry from zle_highlight\n  local region=\"${zle_highlight[(r)${entry}:*]}\"\n\n  if [[ -z \"$region\" ]]; then\n    # entry not specified at all, use default value\n    region=$default\n  else\n    # strip prefix\n    region=\"${region#${entry}:}\"\n\n    # no highlighting when set to the empty string or to 'none'\n    if [[ -z \"$region\" ]] || [[ \"$region\" == none ]]; then\n      return\n    fi\n  fi\n\n  integer start end\n  if (( first < second )); then\n    start=$first end=$second\n  else\n    start=$second end=$first\n  fi\n  region_highlight+=(\"$start $end $region\")\n}\n\n\n# -------------------------------------------------------------------------------------------------\n# API/utility functions for highlighters\n# -------------------------------------------------------------------------------------------------\n\n# Whether the command line buffer has been modified or not.\n#\n# Returns 0 if the buffer has changed since _zsh_highlight was last called.\n_zsh_highlight_buffer_modified()\n{\n  [[ \"${_ZSH_HIGHLIGHT_PRIOR_BUFFER:-}\" != \"$BUFFER\" ]] || [[ \"$REGION_ACTIVE\" != \"$_ZSH_HIGHLIGHT_PRIOR_RACTIVE\" ]] || { _zsh_highlight_cursor_moved && [[ \"$REGION_ACTIVE\" = 1 || \"$REGION_ACTIVE\" = 2 ]] }\n}\n\n# Whether the cursor has moved or not.\n#\n# Returns 0 if the cursor has moved since _zsh_highlight was last called.\n_zsh_highlight_cursor_moved()\n{\n  [[ -n $CURSOR ]] && [[ -n ${_ZSH_HIGHLIGHT_PRIOR_CURSOR-} ]] && (($_ZSH_HIGHLIGHT_PRIOR_CURSOR != $CURSOR))\n}\n\n# -------------------------------------------------------------------------------------------------\n# Setup functions\n# -------------------------------------------------------------------------------------------------\n\n# Helper for _zsh_highlight_bind_widgets\n# $1 is name of widget to call\n_zsh_highlight_call_widget()\n{\n  integer ret\n  builtin zle \"$@\"\n  ret=$?\n  _zsh_highlight\n  return $ret\n}\n\n# Rebind all ZLE widgets to make them invoke _zsh_highlights.\n_zsh_highlight_bind_widgets()\n{\n  setopt localoptions noksharrays\n  local -F2 SECONDS\n  local prefix=orig-s${SECONDS/./}-r$(( RANDOM % 1000 )) # unique each time, in case we're sourced more than once\n\n  # Load ZSH module zsh/zleparameter, needed to override user defined widgets.\n  zmodload zsh/zleparameter 2>/dev/null || {\n    print -r -- >&2 'zsh-syntax-highlighting: failed loading zsh/zleparameter.'\n    return 1\n  }\n\n  # Override ZLE widgets to make them invoke _zsh_highlight.\n  local -U widgets_to_bind\n  widgets_to_bind=(${${(k)widgets}:#(.*|run-help|which-command|beep|set-local-history|yank|zle-line-pre-redraw|zle-keymap-select)})\n\n  # Always wrap special zle-line-finish widget. This is needed to decide if the\n  # current line ends and special highlighting logic needs to be applied.\n  # E.g. remove cursor imprint, don't highlight partial paths, ...\n  widgets_to_bind+=(zle-line-finish)\n\n  # Always wrap special zle-isearch-update widget to be notified of updates in isearch.\n  # This is needed because we need to disable highlighting in that case.\n  widgets_to_bind+=(zle-isearch-update)\n\n  local cur_widget\n  for cur_widget in $widgets_to_bind; do\n    case ${widgets[$cur_widget]-} in\n\n      # Already rebound event: do nothing.\n      user:_zsh_highlight_widget_*);;\n\n      # The \"eval\"'s are required to make $cur_widget a closure: the value of the parameter at function\n      # definition time is used.\n      #\n      # We can't use ${0/_zsh_highlight_widget_} because these widgets are always invoked with\n      # NO_function_argzero, regardless of the option's setting here.\n\n      # User defined widget: override and rebind old one with prefix \"orig-\".\n      user:*) zle -N -- $prefix-$cur_widget ${widgets[$cur_widget]#*:}\n              eval \"_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget ${(q)prefix}-${(q)cur_widget} -- \\\"\\$@\\\" }\"\n              zle -N -- $cur_widget _zsh_highlight_widget_$prefix-$cur_widget;;\n\n      # Completion widget: override and rebind old one with prefix \"orig-\".\n      completion:*) zle -C $prefix-$cur_widget ${${(s.:.)widgets[$cur_widget]}[2,3]} \n                    eval \"_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget ${(q)prefix}-${(q)cur_widget} -- \\\"\\$@\\\" }\"\n                    zle -N -- $cur_widget _zsh_highlight_widget_$prefix-$cur_widget;;\n\n      # Builtin widget: override and make it call the builtin \".widget\".\n      builtin) eval \"_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget .${(q)cur_widget} -- \\\"\\$@\\\" }\"\n               zle -N -- $cur_widget _zsh_highlight_widget_$prefix-$cur_widget;;\n\n      # Incomplete or nonexistent widget: Bind to z-sy-h directly.\n      *) \n         if [[ $cur_widget == zle-* ]] && [[ -z ${widgets[$cur_widget]-} ]]; then\n           _zsh_highlight_widget_${cur_widget}() { :; _zsh_highlight }\n           zle -N -- $cur_widget _zsh_highlight_widget_$cur_widget\n         else\n      # Default: unhandled case.\n           print -r -- >&2 \"zsh-syntax-highlighting: unhandled ZLE widget ${(qq)cur_widget}\"\n         fi\n    esac\n  done\n}\n\n# -------------------------------------------------------------------------------------------------\n# Setup\n# -------------------------------------------------------------------------------------------------\n\n# Try binding widgets.\n_zsh_highlight_bind_widgets || {\n  print -r -- >&2 'zsh-syntax-highlighting: failed binding ZLE widgets, exiting.'\n  return 1\n}\n\n# Reset scratch variables when commandline is done.\n_zsh_highlight_preexec_hook()\n{\n  typeset -g _ZSH_HIGHLIGHT_PRIOR_BUFFER=\n  typeset -gi _ZSH_HIGHLIGHT_PRIOR_CURSOR=0\n  typeset -ga _FAST_MAIN_CACHE\n  _FAST_MAIN_CACHE=()\n}\n\nautoload -Uz add-zsh-hook\nadd-zsh-hook preexec _zsh_highlight_preexec_hook 2>/dev/null || {\n    print -r -- >&2 'zsh-syntax-highlighting: failed loading add-zsh-hook.'\n}\n\n/fshdbg() {\n    print -r -- \"$@\" >>! /tmp/reply\n}\n\ntypeset -g ZSH_HIGHLIGHT_MAXLENGTH=10000\n\n# Load zsh/parameter module if available\nzmodload zsh/parameter 2>/dev/null\nzmodload zsh/system 2>/dev/null\n\nautoload -Uz -- is-at-least fast-theme .fast-read-ini-file .fast-run-git-command \\\n                .fast-make-targets .fast-run-command .fast-zts-read-all\nautoload -Uz -- →chroma/-git.ch →chroma/-hub.ch →chroma/-lab.ch →chroma/-example.ch \\\n                →chroma/-grep.ch →chroma/-perl.ch →chroma/-make.ch →chroma/-awk.ch \\\n                →chroma/-vim.ch →chroma/-source.ch →chroma/-sh.ch →chroma/-docker.ch \\\n                →chroma/-autoload.ch →chroma/-ssh.ch →chroma/-scp.ch →chroma/-which.ch \\\n                →chroma/-printf.ch →chroma/-ruby.ch →chroma/-whatis.ch →chroma/-alias.ch \\\n                →chroma/-subcommand.ch →chroma/-autorandr.ch →chroma/-nmcli.ch \\\n                →chroma/-fast-theme.ch →chroma/-node.ch →chroma/-fpath_peq.ch \\\n                →chroma/-precommand.ch →chroma/-subversion.ch →chroma/-ionice.ch \\\n                →chroma/-nice.ch →chroma/main-chroma.ch →chroma/-ogit.ch →chroma/-zinit.ch\n\nsource \"${0:h}/fast-highlight\"\nsource \"${0:h}/fast-string-highlight\"\n\nlocal __fsyh_theme\nzstyle -s :plugin:fast-syntax-highlighting theme __fsyh_theme\n\n[[ ( \"${+termcap}\" != 1 || \"${termcap[Co]}\" != <-> || \"${termcap[Co]}\" -lt \"256\" ) && \"$__fsyh_theme\" = (default|) ]] && {\n    FAST_HIGHLIGHT_STYLES[defaultvariable]=\"none\"\n    FAST_HIGHLIGHT_STYLES[defaultglobbing-ext]=\"fg=blue,bold\"\n    FAST_HIGHLIGHT_STYLES[defaulthere-string-text]=\"bg=blue\"\n    FAST_HIGHLIGHT_STYLES[defaulthere-string-var]=\"fg=cyan,bg=blue\"\n    FAST_HIGHLIGHT_STYLES[defaultcorrect-subtle]=\"bg=blue\"\n    FAST_HIGHLIGHT_STYLES[defaultsubtle-bg]=\"bg=blue\"\n    [[ \"${FAST_HIGHLIGHT_STYLES[variable]}\" = \"fg=113\" ]] && FAST_HIGHLIGHT_STYLES[variable]=\"none\"\n    [[ \"${FAST_HIGHLIGHT_STYLES[globbing-ext]}\" = \"fg=13\" ]] && FAST_HIGHLIGHT_STYLES[globbing-ext]=\"fg=blue,bold\"\n    [[ \"${FAST_HIGHLIGHT_STYLES[here-string-text]}\" = \"bg=18\" ]] && FAST_HIGHLIGHT_STYLES[here-string-text]=\"bg=blue\"\n    [[ \"${FAST_HIGHLIGHT_STYLES[here-string-var]}\" = \"fg=cyan,bg=18\" ]] && FAST_HIGHLIGHT_STYLES[here-string-var]=\"fg=cyan,bg=blue\"\n    [[ \"${FAST_HIGHLIGHT_STYLES[correct-subtle]}\" = \"fg=12\" ]] && FAST_HIGHLIGHT_STYLES[correct-subtle]=\"bg=blue\"\n    [[ \"${FAST_HIGHLIGHT_STYLES[subtle-bg]}\" = \"bg=18\" ]] && FAST_HIGHLIGHT_STYLES[subtle-bg]=\"bg=blue\"\n}\n\nunset __fsyh_theme\n\nalias fsh-alias=fast-theme\n\n-fast-highlight-fill-option-variables\n\nif [[ ! -e $FAST_WORK_DIR/secondary_theme.zsh ]] {\n    if { type curl &>/dev/null } {\n        curl -fsSL -o \"$FAST_WORK_DIR/secondary_theme.zsh\" \\\n            https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/share/free_theme.zsh \\\n            &>/dev/null\n    } elif { type wget &>/dev/null } {\n        wget -O \"$FAST_WORK_DIR/secondary_theme.zsh\" \\\n            https://raw.githubusercontent.com/zdharma-continuum/fast-syntax-highlighting/master/share/free_theme.zsh \\\n            &>/dev/null\n    }\n    touch \"$FAST_WORK_DIR/secondary_theme.zsh\"\n}\n\nif [[ $(uname -a) = (#i)*darwin* ]] {\n    typeset -gA FAST_HIGHLIGHT\n    FAST_HIGHLIGHT[chroma-man]=\n}\n\n[[ ${COLORTERM-} == (24bit|truecolor) || ${terminfo[colors]} -eq 16777216 ]] || zmodload zsh/nearcolor &>/dev/null || true\n"
        },
        {
          "name": "fast-theme",
          "type": "blob",
          "size": 17.298828125,
          "content": "# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n# Copyright (c) 2018 Sebastian Gniazdowski\n# Copyright (c) 2018, 2019 Philippe Troin (F-i-f on GitHub)\n#\n# Theme support using ini-files.\n#\n\nzmodload zsh/zutil 2>/dev/null\n\nemulate -LR zsh\nsetopt extendedglob typesetsilent warncreateglobal\nautoload colors; colors\n\ntypeset -g FAST_WORK_DIR\n: ${FAST_WORK_DIR:=$FAST_BASE_DIR}\nFAST_WORK_DIR=${~FAST_WORK_DIR}\n\nlocal -A map\nmap=( \"XDG:\"    \"${XDG_CONFIG_HOME:-$HOME/.config}/fsh/\"\n      \"LOCAL:\"  \"/usr/local/share/fsh/\"\n      \"HOME:\"   \"$HOME/.fsh/\"\n      \"OPT:\"    \"/opt/local/share/fsh/\"\n)\n\nFAST_WORK_DIR=${${FAST_WORK_DIR/(#m)(#s)(XDG|LOCAL|HOME|OPT):(#c0,1)/${map[${MATCH%:}:]}}%/}\n\nlocal OPT_HELP OPT_VERBOSE OPT_QUIET OPT_RESET OPT_LIST OPT_TEST OPT_SECONDARY OPT_SHOW OPT_COPY OPT_OV_RESET\nlocal OPT_PALETTE OPT_CDWD OPT_XCHG OPT_OV_XCHG\nlocal -A opthash\nzparseopts -E -D -A opthash h -help v -verbose q -quiet r -reset l -list t -test -secondary \\\n            s -show -copy-shipped-theme: R -ov-reset p -palette w -workdir \\\n            x -xchg y -ov-xchg || \\\n                { echo \"Improper options given, see help (-h/--help)\"; return 1; }\n\n(( ${+opthash[-h]} + ${+opthash[--help]} ))    && OPT_HELP=\"-h\"\n(( ${+opthash[-v]} + ${+opthash[--verbose]} )) && OPT_VERBOSE=\"-v\"\n(( ${+opthash[-q]} + ${+opthash[--quiet]} ))   && OPT_QUIET=\"-q\"\n(( ${+opthash[-r]} + ${+opthash[--reset]} ))   && OPT_RESET=\"-r\"\n(( ${+opthash[-l]} + ${+opthash[--list]} ))    && OPT_LIST=\"-l\"\n(( ${+opthash[-t]} + ${+opthash[--test]} ))    && OPT_TEST=\"-t\"\n(( ${+opthash[--secondary]} ))                 && OPT_SECONDARY=\"--secondary\"\n(( ${+opthash[-s]} + ${+opthash[--show]} ))    && OPT_SHOW=\"-s\"\n(( ${+opthash[--copy-shipped-theme]} ))        && OPT_COPY=\"${opthash[--copy-shipped-theme]}\"\n(( ${+opthash[-R]} + ${+opthash[--ov-reset]} )) && OPT_OV_RESET=\"-R\"\n(( ${+opthash[-p]} + ${+opthash[--palette]} )) && OPT_PALETTE=\"-p\"\n(( ${+opthash[-w]} + ${+opthash[--workdir]} )) && OPT_CDWD=\"-w\"\n(( ${+opthash[-x]} + ${+opthash[--xchg]} ))    && OPT_XCHG=\"-x\"\n(( ${+opthash[-y]} + ${+opthash[--ov-xchg]} )) && OPT_OV_XCHG=\"-y\"\n\nlocal -a match mbegin mend\nlocal MATCH; integer MBEGIN MEND\n\n[[ -n \"$OPT_CDWD\" ]] && {\n    builtin cd $FAST_WORK_DIR\n    return 0\n}\n\n[[ -n \"$OPT_PALETTE\" ]] && {\n    local n\n    local -a __colors\n    for n in {000..255}\n    do\n        __colors+=(\"%F{$n}$n%f\")\n    done\n    print -cP $__colors\n    return\n}\n\n[[ -n \"$OPT_SHOW\" ]] && {\n    print -r -- \"Currently active theme: ${fg_bold[yellow]}$FAST_THEME_NAME$reset_color\"\n    ( source \"$FAST_WORK_DIR\"/current_theme.zsh 2>/dev/null && print \"Main theme (loaded at startup of a session): ${fg_bold[yellow]}$FAST_THEME_NAME$reset_color\" || print \"No main theme is set\"; )\n    return 0\n}\n\n[[ -n \"$OPT_COPY\" ]] && {\n    [[ ! -f \"$FAST_BASE_DIR\"/themes/\"${OPT_COPY%.ini}.ini\" ]] && { print \"Theme \\`$OPT_COPY' doesn't exist in FSH plugin dir ($FAST_BASE_DIR/themes)\"; return 1; }\n    [[ ! -r \"$FAST_BASE_DIR\"/themes/\"${OPT_COPY%.ini}.ini\" ]] && { print \"Theme \\`$OPT_COPY' isn't readable in FSH plugin dir ($FAST_BASE_DIR/themes)\"; return 1; }\n    [[ -n \"$1\" ]] && {\n        [[ ! -e \"$1\" && ! -e ${1:h} ]] && { print \"Destination path doesn't exist, aborting\"; return 1; }\n    }\n    command cp -vf \"$FAST_BASE_DIR\"/themes/\"${OPT_COPY%.ini}.ini\" \"${${1:-.}%.ini}.ini\" || return 1\n    return 0\n}\n\n[[ -n \"$OPT_RESET\" ]] && { command rm -f \"$FAST_WORK_DIR\"/{current_theme.zsh,secondary_theme.zsh}; [[ -z \"$OPT_QUIET\" ]] && print \"Reset done (no theme is now set, restart is required)\"; return 0; }\n\n[[ -n \"$OPT_OV_RESET\" ]] && { command rm -f \"$FAST_WORK_DIR\"/theme_overlay.zsh; [[ -z \"$OPT_QUIET\" ]] && print \"Overlay-reset done, it is inactive (restart is required)\"; return 0; }\n\n[[ -n \"$OPT_LIST\" ]] && {\n    [[ -z \"$OPT_QUIET\" ]] && print -r -- \"Available themes:\"\n    print -rl -- \"$FAST_BASE_DIR\"/themes/*.ini(:t:r)\n    return 0\n}\n\n[[ -n \"$OPT_HELP\" ]] && {\n    print -r -- \"Usage: fast-theme [-h/--help] [-v/--verbose] [-q/--quiet] [-t/--test] <theme-name|theme-path>\"\n    print -r -- \"       fast-theme [-r/--reset] [-l/--list] [-s/--show] [-p/--palette] [-w/--workdir]\"\n    print -r -- \"       fast-theme --copy-shipped-theme {theme-name} [destination-path]\"\n    print -r -- \"\"\n    print -r -- \"Default action (after providing <theme-name> or <theme-path>) is to switch\"\n    print -r -- \"current session and any future sessions to the new theme. Using <theme-path>,\"\n    print -r -- \"i.e.: a path to an ini file means using custom, own theme. The path can use an\"\n    print -r -- \"\\\"XDG:\\\" shorthand (e.g.: \\\"XDG:mytheme\\\") that will point to ~/.config/fsh/<theme>.ini\"\n    print -r -- \"(or \\$XDG_CONFIG_HOME/fsh/<theme>.ini in general if the variable is set in the\"\n    print -r -- \"environment). If the INI file pointed in the path is \\\"*overlay*\\\", then it is\"\n    print -r -- \"not a full theme, but an additional theme-snippet that overwrites only selected\" \n    print -r -- \"styles of the main theme.\"\n    print -r -- \"\"\n    print -r -- \"Other path-shorthands:\"\n    print -r -- \"LOCAL: = /usr/local/share/fsh/\"\n    print -r -- \"HOME: = $HOME/.fsh/\"\n    print -r -- \"OPT: = /opt/local/share/fsh/\"\n    print -r -- \"\"\n    print -r -- \"-r/--reset     - unset any theme, use default highlighting (requires restart)\"\n    print -r -- \"-R/--ov-reset  - unset overlay, use styles only from main-theme (requires restart)\"\n    print -r -- \"-l/--list      - list names of available themes\"\n    print -r -- \"-t/--test      - show test block of code after switching theme\"\n    print -r -- \"-s/--show      - get and display the theme currently being set\"\n    print -r -- \"-p/--palette   - just print all 256 colors and exit (useful when creating a theme)\"\n    print -r -- \"-w/--workdir   - cd into \\$FAST_WORK_DIR (if not set, then into the plugin directory)\"\n    print -r -- \"-v/--verbose   - more messages during operation\"\n    print -r -- \"-q/--quiet     - no default messages\"\n    print -r -- \"\"\n    print -r -- \"The option --copy-shipped-theme allows easy copying of one of the 6 shipped\"\n    print -r -- \"themes into given destination path. Normal use means changing directory to\"\n    print -r -- \"e.g.: ~/.config/fsh, and then issuing e.g.: \\`fast-theme --copy-shipped-theme\"\n    print -r -- \"clean mytheme', to obtain a template for own new theme.\"\n    return 0\n}\n\n[[ -z \"$1\" ]] && { print -u2 \"Provide a theme (its name or path to its file) to switch to, aborting (see -h/--help)\"; return 1; }\n\n# FAST_HIGHLIGHT_STYLES key onto ini-file key\nmap=(\n    default                     \"-\"\n    unknown-token               \"-\"\n    reserved-word               \"-\"\n    subcommand                  \"- reserved-word\"\n    alias                       \"- command builtin\"\n    suffix-alias                \"- alias command builtin\"\n    builtin                     \"-\"\n    function                    \"- builtin command\"\n    command                     \"-\"\n    precommand                  \"- command\"\n    commandseparator            \"-\"\n    hashed-command              \"- command\"\n    path                        \"-\"\n    path_pathseparator          \"pathseparator\"\n    globbing                    \"- back-or-dollar-double-quoted-argument\" # fallback: variable in string \"text $var text\"\n    globbing-ext                \"- double-quoted-argument\" # fallback: the string \"abc...\"\n    history-expansion           \"-\"\n    single-hyphen-option        \"- single-quoted-argument\"\n    double-hyphen-option        \"- double-quoted-argument\"\n    back-quoted-argument        \"-\"\n    single-quoted-argument      \"-\"\n    double-quoted-argument      \"-\"\n    dollar-quoted-argument      \"-\"\n    back-or-dollar-double-quoted-argument   \"- back-dollar-quoted-argument\"\n    back-dollar-quoted-argument             \"- back-or-dollar-double-quoted-argument\"\n    assign                      \"- reserved-word\"\n    redirection                 \"- reserved-word\"\n    comment                     \"-\"\n    variable                    \"-\"\n    mathvar                     \"- forvar variable\"\n    mathnum                     \"- fornum\"\n    matherr                     \"- incorrect-subtle\"\n    assign-array-bracket        \"-\"\n    for-loop-variable           \"forvar mathvar variable\"\n    for-loop-number             \"fornum mathnum\"\n    for-loop-operator           \"foroper reserved-word\"\n    for-loop-separator          \"forsep commandseparator\"\n    exec-descriptor             \"- reserved-word\"\n    here-string-tri             \"-\"\n    here-string-text            \"- subtle-bg\"\n    here-string-var             \"- back-or-dollar-double-quoted-argument\"\n    secondary                   \"-\"\n    recursive-base              \"- default\"\n    case-input                  \"- variable\"\n    case-parentheses            \"- reserved-word\"\n    case-condition              \"- correct-subtle\"\n    correct-subtle              \"-\"\n    incorrect-subtle            \"-\"\n    subtle-separator            \"- commandseparator\"\n    subtle-bg                   \"- correct-subtle\"\n    path-to-dir                 \"- path\"\n    paired-bracket              \"- subtle-bg correct-subtle\"\n    bracket-level-1             \"-\"\n    bracket-level-2             \"-\"\n    bracket-level-3             \"-\"\n    global-alias                \"- alias suffix-alias\"\n    single-sq-bracket           \"-\"\n    double-sq-bracket           \"-\"\n    double-paren                \"-\"\n    optarg-string               \"- double-quoted-argument\"\n    optarg-number               \"- mathnum\"\n)\n\n# In which order to generate entries\nlocal -a order\norder=( \n    default unknown-token reserved-word alias suffix-alias builtin function command precommand \n    commandseparator hashed-command path path_pathseparator globbing globbing-ext history-expansion\n    single-hyphen-option double-hyphen-option back-quoted-argument single-quoted-argument \n    double-quoted-argument dollar-quoted-argument back-or-dollar-double-quoted-argument \n    back-dollar-quoted-argument assign redirection comment variable mathvar \n    mathnum matherr assign-array-bracket for-loop-variable for-loop-number for-loop-operator\n    for-loop-separator exec-descriptor here-string-tri here-string-text here-string-var secondary\n    case-input case-parentheses case-condition correct-subtle incorrect-subtle subtle-separator subtle-bg\n    path-to-dir paired-bracket bracket-level-1 bracket-level-2 bracket-level-3\n    global-alias subcommand single-sq-bracket double-sq-bracket double-paren\n    optarg-string optarg-number recursive-base\n)\n\n[[ -n \"$OPT_VERBOSE\" ]] && print \"Number of styles available for customization: ${#order}\"\n\n# Named colors\nlocal -a color\ncolor=( red green blue yellow cyan magenta black white default )\n\n#\n# Execution starts here\n#\n\nlocal -A out\nlocal THEME_NAME THEME_PATH=\"$1\"\nif [[ \"$1\" = */* || \"$1\" = (XDG|LOCAL|HOME|OPT):* ]]; then\n    1=\"${${1/(#s)XDG:/${${XDG_CONFIG_HOME:-$HOME/.config}%/}/fsh/}%.ini}.ini\"\n    1=\"${${1/(#s)LOCAL://usr/local/share/fsh/}%.ini}.ini\"\n    1=\"${${1/(#s)HOME:/$HOME/.fsh/}%.ini}.ini\"\n    1=\"${${1/(#s)OPT://opt/local/share/fsh/}%.ini}.ini\"\n    1=${~1} # allow user to quote ~\n\n    [[ ! -f \"$1\" ]] && { print -u2 \"No such theme \\`$1', aborting\"; return 1; }\n    [[ ! -r \"$1\" ]] && { print -u2 \"Theme \\`$1' unreadable, aborting\"; return 1; }\n\n    THEME_NAME=\"${1:t:r}\"\n    .fast-read-ini-file \"$1\" out \"\"\nelse\n    [[ ! -f \"$FAST_BASE_DIR/themes/$1.ini\" ]] && { print -u2 \"No such theme \\`$1', aborting\"; return 1; }\n    [[ ! -r \"$FAST_BASE_DIR/themes/$1.ini\" ]] && { print -u2 \"Theme \\`$1' unreadable, aborting\"; return 1; }\n\n    THEME_NAME=\"$1\"\n    .fast-read-ini-file \"$FAST_BASE_DIR/themes/$1.ini\" out \"\"\nfi\n\n[[ -z \"$OPT_SECONDARY\" ]] && { [[ \"$THEME_NAME\" = *\"overlay\"* ]] && local outfile=\"theme_overlay.zsh\" || local outfile=\"current_theme.zsh\"; } || local outfile=\"secondary_theme.zsh\"\n[[ -z \"$OPT_XCHG\" && -z \"$OPT_OV_XCHG\" ]] && command rm -f \"$FAST_WORK_DIR\"/\"$outfile\"\n\n# Set a zstyle and a parameter to carry theme name\nif [[ -z \"$OPT_SECONDARY\" && -z \"$OPT_XCHG\" && -z \"$OPT_OV_XCHG\" ]]; then\n    [[ \"$THEME_NAME\" != *\"overlay\"* ]] && {\n        print -r -- 'zstyle :plugin:fast-syntax-highlighting theme \"'\"$THEME_NAME\"'\"' >>! \"$FAST_WORK_DIR\"/\"$outfile\"\n        print -r -- 'typeset -g FAST_THEME_NAME=\"'\"$THEME_NAME\"'\"' >>! \"$FAST_WORK_DIR\"/\"$outfile\"\n        zstyle :plugin:fast-syntax-highlighting theme \"$THEME_NAME\"\n        typeset -g FAST_THEME_NAME=\"$THEME_NAME\"\n    }\nelif [[ -z \"$OPT_XCHG\" && -z \"$OPT_OV_XCHG\" ]]; then\n    local FAST_THEME_NAME=\"$THEME_NAME\"\nfi\n\n# Store from which file the theme or overlay is being loaded\n[[ \"$THEME_NAME\" != *\"overlay\" && -z \"$OPT_OV_XCHG\" ]] && FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}-path]=\"$THEME_PATH\" || FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}-ov-path]=\"$THEME_PATH\"\n\n# Generate current_theme.zsh or secondary_theme.zsh, traversing ini-file associative array\nlocal k kk\nlocal inikey inival result result2 first_val isbg\ninteger ov_counter=0 first\nfor k in \"${order[@]}\"; do\n    first=1\n    for kk in ${(s. .)map[$k]} default; do\n        [[ \"$kk\" = \"-\" ]] && kk=\"$k\"\n        (( first )) && first_val=\"$kk\"\n        inikey=\"${out[(i)<*>_${kk}]}\"\n        [[ -n \"$inikey\" ]] && {\n            (( !first )) && [[ -z \"$OPT_QUIET\" ]] && {\n                [[ $kk = default ]] && {\n                    [[ \"$THEME_NAME\" != *\"overlay\"* ]] && print \"Missing style: $first_val\"\n                } || print \"For style $first_val, went for fallback style $kk\"\n            }\n            break\n        }\n        first=0\n        [[ \"$THEME_NAME\" = *\"overlay\"* ]] && break\n    done\n\n    # ORIG: Clear orig-style when loading a new theme, not overlay\n    [[ -z \"$OPT_OV_XCHG\" ]] && unset \"FAST_HIGHLIGHT_STYLES[orig-style-$k]\"\n    # ORIG: Restore orig-style when loading a new overlay\n    [[ -n \"$OPT_OV_XCHG\" && -n \"${FAST_HIGHLIGHT_STYLES[orig-style-$k]}\" ]] && { FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}$k]=\"${FAST_HIGHLIGHT_STYLES[orig-style-$k]}\"; unset \"FAST_HIGHLIGHT_STYLES[orig-style-$k]\"; }\n    # Set only the keys provided in theme\n    [[ -z \"$inikey\" ]] && { [[ -z \"$OPT_QUIET\" && \"$THEME_NAME\" != *\"overlay\"* ]] && print \"Missing style $first_val\"; continue; }\n\n    inival=\"${out[$inikey]}\"\n    if [[ \"$k\" = \"secondary\" && -z \"$OPT_SECONDARY\" && -n \"$inival\" ]]; then\n        fast-theme -q --secondary \"$inival\"\n    fi\n\n    result=\"\"\n    if [[ $k = secondary ]]; then\n        result=\"$inival\"\n    else\n        for kk in ${(s:,:)inival}\n        do\n            if [[ $kk = (none|(no-|)(bold|blink|conceal|reverse|standout|underline)) ]]; then\n                result+=\"${result:+,}$kk\"\n            else\n                isbg=0\n                if [[ $kk = bg:* ]]; then\n                    isbg=1\n                    kk=${kk#bg:}\n                fi\n                if [[ $kk = (${(~j:|:)color}) || $kk = [0-9]## || $kk = \\#[0-9a-fA-F](#c6,6) ]]; then\n                    result+=\"${result:+,}\"\n                    (( isbg )) && result+=\"bg=\" || result+=\"fg=\"\n                    result+=\"$kk\"\n                else\n                    print \"cannot parse style $k: unknown color or style element $kk\"\n                fi\n            fi\n        done\n    fi\n\n    if [[ \"$THEME_NAME\" = *\"overlay\"* || -n \"$OPT_OV_XCHG\" ]]; then\n        (( ++ ov_counter ))\n        [[ -z \"$OPT_XCHG$OPT_OV_XCHG\" ]] && print -r -- ': ${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}'\"$k\"']::='\"$result\"'}' >>! \"$FAST_WORK_DIR\"/\"$outfile\"\n        # ORIG: Save original value of the overwritten style\n        FAST_HIGHLIGHT_STYLES[orig-style-$k]=${FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}$k]}\n        # Overwrite theme's style\n        FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}$k]=\"$result\"\n    else\n        [[ -z \"$OPT_XCHG$OPT_OV_XCHG\" ]] && print -r -- ': ${FAST_HIGHLIGHT_STYLES['\"${FAST_THEME_NAME}$k\"']:='\"$result\"'}' >>! \"$FAST_WORK_DIR\"/\"$outfile\"\n        FAST_HIGHLIGHT_STYLES[${FAST_THEME_NAME}$k]=\"$result\"\n    fi\ndone\n\n# This can overwrite some of *_STYLES fields\n# Re-apply overlay on top of the theme we switched to\n[[ \"$THEME_NAME\" != *\"overlay\"* ]] && [[ -r \"$FAST_WORK_DIR\"/theme_overlay.zsh ]] && source \"$FAST_WORK_DIR\"/theme_overlay.zsh\n\nzcompile $FAST_WORK_DIR/$outfile 2>/dev/null\n\n[[ -z \"$OPT_QUIET\" ]] && {\n    if [[ \"$THEME_NAME\" != *\"overlay\"* ]]; then\n        print \"Switched to theme \\`$THEME_NAME' (current session, and future sessions)\" || \\\n    else\n        print \"Processed the overlay ($ov_counter keys found), it is now active (for current session, and future sessions)\"\n    fi\n}\n\n[[ -n \"$OPT_TEST\" ]] && {\n    print -zr '\n# Subshell, assignments, math-mode\necho $(cat /etc/hosts |& grep -i \"hello337\")\nlocal param1=\"text ${+variable[test]} text ${var} text\"; typeset param2='\"'\"'other $variable'\"'\"'\nmath=$(( 10 + HISTSIZ + HISTSIZE + $SAVEHIST )) size=$(( 0 ))\n\n# Programming-like usage, bracket matching - through distinct colors; note the backslash quoting\nfor (( ii = 1; ii <= size; ++ ii )); do\n    if [[ \"${cmds[ii]} string\" = \"| string\" ]]\n    then\n        sidx=${buffer[(in:ii:)\\$\\(?#[^\\\\\\\\]\\)]} # find opening cmd-subst\n        (( sidx <= len + 100 )) && {\n            eidx=${buffer[(b:sidx:ii)[^\\\\\\\\]\\)]} # find closing cmd-subst\n        }\n    fi\ndone\n\n# Regular command-line usage\nrepeat 0 {\n    zsh -i -c \"cat /etc/shells* | grep -x --line-buffered -i '\"'/bin/zsh'\"'\"\n    builtin exit $return_value\n    fast-theme -tq default\n    fsh-alias -tq default-X # alias '\"'\"'fsh-alias=fast-theme'\"'\"' works just like the previous line\n    command -v git | grep \".+git\" && echo $'\"'\"'Git is installed'\"'\"'\n    git checkout -m --ours /etc/shells && git status-X\n    gem install asciidoctor\n    cat <<<$PATH | tr : \\\\n > /dev/null 2>/usr/local\n    man -a fopen fopen-X\n    CFLAGS=\"-g -Wall -O0\" ./configure\n}\n'\n}\n\nreturn 0\n# vim:ft=zsh:et:sw=4:sts=4\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "share",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "themes",
          "type": "tree",
          "content": null
        },
        {
          "name": "→chroma",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}