{
  "metadata": {
    "timestamp": 1736568620071,
    "page": 694,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "apenwarr/git-subtree",
      "stars": 1371,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "*~\ngit-subtree.xml\ngit-subtree.1\nmainline\nsubproj\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.5654296875,
          "content": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 0.484375,
          "content": "\nHOW TO INSTALL git-subtree\n==========================\n\nYou simply need to copy the file 'git-subtree.sh' to where\nthe rest of the git scripts are stored. \n\nFrom the Git bash window just run:\n\ninstall.sh \n\nOr if you have the full Cygwin installed, you can use make:\n\nmake install\n\nThat will make a 'git subtree' (note: space instead of dash) command\navailable.  See the file git-subtree.txt for more.\n\nYou can also install the man page by doing:\n\n\tmake doc\n\tcp git-subtree.1 /usr/share/man/man1/\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.9990234375,
          "content": "prefix ?= /usr/local\nmandir ?= $(prefix)/share/man\ngitdir ?= $(shell git --exec-path)\n\ngitver ?= $(word 3,$(shell git --version))\n\n# this should be set to a 'standard' bsd-type install program\nINSTALL ?= install\nINSTALL_DATA = $(INSTALL) -c -m 0644\nINSTALL_EXE = $(INSTALL) -c -m 0755\nINSTALL_DIR = $(INSTALL) -c -d -m 0755\n\ndefault:\n\t@echo \"git-subtree doesn't need to be built.\"\n\t@echo \"Just copy it somewhere on your PATH, like /usr/local/bin.\"\n\t@echo\n\t@echo \"Try: make doc\"\n\t@echo \" or: make test\"\n\t@false\n\ninstall: install-exe install-doc\n\ninstall-exe: git-subtree.sh\n\t$(INSTALL_DIR) $(DESTDIR)/$(gitdir)\n\t$(INSTALL_EXE) $< $(DESTDIR)/$(gitdir)/git-subtree\n\ninstall-doc: git-subtree.1\n\t$(INSTALL_DIR) $(DESTDIR)/$(mandir)/man1/\n\t$(INSTALL_DATA) $< $(DESTDIR)/$(mandir)/man1/\n\ndoc: git-subtree.1\n\n%.1: %.xml\n\txmlto -m manpage-normal.xsl  man $^\n\n%.xml: %.txt\n\tasciidoc -b docbook -d manpage -f asciidoc.conf \\\n\t\t-agit_version=$(gitver) $^\n\t\t\ntest:\n\t./test.sh\n\nclean:\n\trm -f *~ *.xml *.html *.1\n\trm -rf subproj mainline\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.2060546875,
          "content": "\nPlease read git-subtree.txt for documentation.\n\nPlease don't contact me using github mail; it's slow, ugly, and worst of\nall, redundant. Email me instead at apenwarr@gmail.com and I'll be happy to\nhelp.\n\nAvery\n"
        },
        {
          "name": "THIS-REPO-IS-OBSOLETE",
          "type": "blob",
          "size": 0.5947265625,
          "content": "Hi,\n\nThis git-subtree repository is obsolete now that git-subtree has been merged\ninto mainline git (yay!).  If you have patches you want to make to\ngit-subtree, I encourage you to email them to the core git mailing list,\nwhere the hordes of awesome maintainers are well known for responding very\nquickly to queries and patches, very much unlike me.\n\nNote: it is only available in git 1.7.11 and higher.  Also, it's in the\n\"contrib\" subtree for now, so it's not installed by default.  Please\nencourage your distribution packager (eg. Debian) to include contrib\nwhen making their git packages.\n\nThanks!\n\nAvery\n"
        },
        {
          "name": "asciidoc.conf",
          "type": "blob",
          "size": 2.1728515625,
          "content": "## linkgit: macro\n#\n# Usage: linkgit:command[manpage-section]\n#\n# Note, {0} is the manpage section, while {target} is the command.\n#\n# Show GIT link as: <command>(<section>); if section is defined, else just show\n# the command.\n\n[macros]\n(?su)[\\\\]?(?P<name>linkgit):(?P<target>\\S*?)\\[(?P<attrlist>.*?)\\]=\n\n[attributes]\nasterisk=&#42;\nplus=&#43;\ncaret=&#94;\nstartsb=&#91;\nendsb=&#93;\ntilde=&#126;\n\nifdef::backend-docbook[]\n[linkgit-inlinemacro]\n{0%{target}}\n{0#<citerefentry>}\n{0#<refentrytitle>{target}</refentrytitle><manvolnum>{0}</manvolnum>}\n{0#</citerefentry>}\nendif::backend-docbook[]\n\nifdef::backend-docbook[]\nifndef::git-asciidoc-no-roff[]\n# \"unbreak\" docbook-xsl v1.68 for manpages. v1.69 works with or without this.\n# v1.72 breaks with this because it replaces dots not in roff requests.\n[listingblock]\n<example><title>{title}</title>\n<literallayout>\nifdef::doctype-manpage[]\n&#10;.ft C&#10;\nendif::doctype-manpage[]\n|\nifdef::doctype-manpage[]\n&#10;.ft&#10;\nendif::doctype-manpage[]\n</literallayout>\n{title#}</example>\nendif::git-asciidoc-no-roff[]\n\nifdef::git-asciidoc-no-roff[]\nifdef::doctype-manpage[]\n# The following two small workarounds insert a simple paragraph after screen\n[listingblock]\n<example><title>{title}</title>\n<literallayout>\n|\n</literallayout><simpara></simpara>\n{title#}</example>\n\n[verseblock]\n<formalpara{id? id=\"{id}\"}><title>{title}</title><para>\n{title%}<literallayout{id? id=\"{id}\"}>\n{title#}<literallayout>\n|\n</literallayout>\n{title#}</para></formalpara>\n{title%}<simpara></simpara>\nendif::doctype-manpage[]\nendif::git-asciidoc-no-roff[]\nendif::backend-docbook[]\n\nifdef::doctype-manpage[]\nifdef::backend-docbook[]\n[header]\ntemplate::[header-declarations]\n<refentry>\n<refmeta>\n<refentrytitle>{mantitle}</refentrytitle>\n<manvolnum>{manvolnum}</manvolnum>\n<refmiscinfo class=\"source\">Git</refmiscinfo>\n<refmiscinfo class=\"version\">{git_version}</refmiscinfo>\n<refmiscinfo class=\"manual\">Git Manual</refmiscinfo>\n</refmeta>\n<refnamediv>\n  <refname>{manname}</refname>\n  <refpurpose>{manpurpose}</refpurpose>\n</refnamediv>\nendif::backend-docbook[]\nendif::doctype-manpage[]\n\nifdef::backend-xhtml11[]\n[linkgit-inlinemacro]\n<a href=\"{target}.html\">{target}{0?({0})}</a>\nendif::backend-xhtml11[]\n"
        },
        {
          "name": "git-subtree",
          "type": "blob",
          "size": 0.013671875,
          "content": "git-subtree.sh"
        },
        {
          "name": "git-subtree.sh",
          "type": "blob",
          "size": 14.546875,
          "content": "#!/bin/bash\n#\n# git-subtree.sh: split/join git repositories in subdirectories of this one\n#\n# Copyright (C) 2009 Avery Pennarun <apenwarr@gmail.com>\n#\nif [ $# -eq 0 ]; then\n    set -- -h\nfi\nOPTS_SPEC=\"\\\ngit subtree add   --prefix=<prefix> <commit>\ngit subtree merge --prefix=<prefix> <commit>\ngit subtree pull  --prefix=<prefix> <repository> <refspec...>\ngit subtree push  --prefix=<prefix> <repository> <refspec...>\ngit subtree split --prefix=<prefix> <commit...>\n--\nh,help        show the help\nq             quiet\nd             show debug messages\nP,prefix=     the name of the subdir to split out\nm,message=    use the given message as the commit message for the merge commit\n options for 'split'\nannotate=     add a prefix to commit message of new commits\nb,branch=     create a new branch from the split subtree\nignore-joins  ignore prior --rejoin commits\nonto=         try connecting new tree to an existing one\nrejoin        merge the new branch back into HEAD\n options for 'add', 'merge', 'pull' and 'push'\nsquash        merge subtree changes as a single commit\n\"\neval \"$(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\"\n\nPATH=$PATH:$(git --exec-path)\n. git-sh-setup\n\nrequire_work_tree\n\nquiet=\nbranch=\ndebug=\ncommand=\nonto=\nrejoin=\nignore_joins=\nannotate=\nsquash=\nmessage=\n\ndebug()\n{\n\tif [ -n \"$debug\" ]; then\n\t\techo \"$@\" >&2\n\tfi\n}\n\nsay()\n{\n\tif [ -z \"$quiet\" ]; then\n\t\techo \"$@\" >&2\n\tfi\n}\n\nassert()\n{\n\tif \"$@\"; then\n\t\t:\n\telse\n\t\tdie \"assertion failed: \" \"$@\"\n\tfi\n}\n\n\n#echo \"Options: $*\"\n\nwhile [ $# -gt 0 ]; do\n\topt=\"$1\"\n\tshift\n\tcase \"$opt\" in\n\t\t-q) quiet=1 ;;\n\t\t-d) debug=1 ;;\n\t\t--annotate) annotate=\"$1\"; shift ;;\n\t\t--no-annotate) annotate= ;;\n\t\t-b) branch=\"$1\"; shift ;;\n\t\t-P) prefix=\"$1\"; shift ;;\n\t\t-m) message=\"$1\"; shift ;;\n\t\t--no-prefix) prefix= ;;\n\t\t--onto) onto=\"$1\"; shift ;;\n\t\t--no-onto) onto= ;;\n\t\t--rejoin) rejoin=1 ;;\n\t\t--no-rejoin) rejoin= ;;\n\t\t--ignore-joins) ignore_joins=1 ;;\n\t\t--no-ignore-joins) ignore_joins= ;;\n\t\t--squash) squash=1 ;;\n\t\t--no-squash) squash= ;;\n\t\t--) break ;;\n\t\t*) die \"Unexpected option: $opt\" ;;\n\tesac\ndone\n\ncommand=\"$1\"\nshift\ncase \"$command\" in\n\tadd|merge|pull) default= ;;\n\tsplit|push) default=\"--default HEAD\" ;;\n\t*) die \"Unknown command '$command'\" ;;\nesac\n\nif [ -z \"$prefix\" ]; then\n\tdie \"You must provide the --prefix option.\"\nfi\n\ncase \"$command\" in\n\tadd) [ -e \"$prefix\" ] && \n\t\tdie \"prefix '$prefix' already exists.\" ;;\n\t*)   [ -e \"$prefix\" ] || \n\t\tdie \"'$prefix' does not exist; use 'git subtree add'\" ;;\nesac\n\ndir=\"$(dirname \"$prefix/.\")\"\n\nif [ \"$command\" != \"pull\" -a \"$command\" != \"add\" -a \"$command\" != \"push\" ]; then\n\trevs=$(git rev-parse $default --revs-only \"$@\") || exit $?\n\tdirs=\"$(git rev-parse --no-revs --no-flags \"$@\")\" || exit $?\n\tif [ -n \"$dirs\" ]; then\n\t\tdie \"Error: Use --prefix instead of bare filenames.\"\n\tfi\nfi\n\ndebug \"command: {$command}\"\ndebug \"quiet: {$quiet}\"\ndebug \"revs: {$revs}\"\ndebug \"dir: {$dir}\"\ndebug \"opts: {$*}\"\ndebug\n\ncache_setup()\n{\n\tcachedir=\"$GIT_DIR/subtree-cache/$$\"\n\trm -rf \"$cachedir\" || die \"Can't delete old cachedir: $cachedir\"\n\tmkdir -p \"$cachedir\" || die \"Can't create new cachedir: $cachedir\"\n\tmkdir -p \"$cachedir/notree\" || die \"Can't create new cachedir: $cachedir/notree\"\n\tdebug \"Using cachedir: $cachedir\" >&2\n}\n\ncache_get()\n{\n\tfor oldrev in $*; do\n\t\tif [ -r \"$cachedir/$oldrev\" ]; then\n\t\t\tread newrev <\"$cachedir/$oldrev\"\n\t\t\techo $newrev\n\t\tfi\n\tdone\n}\n\ncache_miss()\n{\n\tfor oldrev in $*; do\n\t\tif [ ! -r \"$cachedir/$oldrev\" ]; then\n\t\t\techo $oldrev\n\t\tfi\n\tdone\n}\n\ncheck_parents()\n{\n\tmissed=$(cache_miss $*)\n\tfor miss in $missed; do\n\t\tif [ ! -r \"$cachedir/notree/$miss\" ]; then\n\t\t\tdebug \"  incorrect order: $miss\"\n\t\tfi\n\tdone\n}\n\nset_notree()\n{\n\techo \"1\" > \"$cachedir/notree/$1\"\n}\n\ncache_set()\n{\n\toldrev=\"$1\"\n\tnewrev=\"$2\"\n\tif [ \"$oldrev\" != \"latest_old\" \\\n\t     -a \"$oldrev\" != \"latest_new\" \\\n\t     -a -e \"$cachedir/$oldrev\" ]; then\n\t\tdie \"cache for $oldrev already exists!\"\n\tfi\n\techo \"$newrev\" >\"$cachedir/$oldrev\"\n}\n\nrev_exists()\n{\n\tif git rev-parse \"$1\" >/dev/null 2>&1; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\nrev_is_descendant_of_branch()\n{\n\tnewrev=\"$1\"\n\tbranch=\"$2\"\n\tbranch_hash=$(git rev-parse $branch)\n\tmatch=$(git rev-list -1 $branch_hash ^$newrev)\n\n\tif [ -z \"$match\" ]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\n# if a commit doesn't have a parent, this might not work.  But we only want\n# to remove the parent from the rev-list, and since it doesn't exist, it won't\n# be there anyway, so do nothing in that case.\ntry_remove_previous()\n{\n\tif rev_exists \"$1^\"; then\n\t\techo \"^$1^\"\n\tfi\n}\n\nfind_latest_squash()\n{\n\tdebug \"Looking for latest squash ($dir)...\"\n\tdir=\"$1\"\n\tsq=\n\tmain=\n\tsub=\n\tgit log --grep=\"^git-subtree-dir: $dir/*\\$\" \\\n\t\t--pretty=format:'START %H%n%s%n%n%b%nEND%n' HEAD |\n\twhile read a b junk; do\n\t\tdebug \"$a $b $junk\"\n\t\tdebug \"{{$sq/$main/$sub}}\"\n\t\tcase \"$a\" in\n\t\t\tSTART) sq=\"$b\" ;;\n\t\t\tgit-subtree-mainline:) main=\"$b\" ;;\n\t\t\tgit-subtree-split:) sub=\"$b\" ;;\n\t\t\tEND)\n\t\t\t\tif [ -n \"$sub\" ]; then\n\t\t\t\t\tif [ -n \"$main\" ]; then\n\t\t\t\t\t\t# a rejoin commit?\n\t\t\t\t\t\t# Pretend its sub was a squash.\n\t\t\t\t\t\tsq=\"$sub\"\n\t\t\t\t\tfi\n\t\t\t\t\tdebug \"Squash found: $sq $sub\"\n\t\t\t\t\techo \"$sq\" \"$sub\"\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\t\tsq=\n\t\t\t\tmain=\n\t\t\t\tsub=\n\t\t\t\t;;\n\t\tesac\n\tdone\n}\n\nfind_existing_splits()\n{\n\tdebug \"Looking for prior splits...\"\n\tdir=\"$1\"\n\trevs=\"$2\"\n\tmain=\n\tsub=\n\tgit log --grep=\"^git-subtree-dir: $dir/*\\$\" \\\n\t\t--pretty=format:'START %H%n%s%n%n%b%nEND%n' $revs |\n\twhile read a b junk; do\n\t\tcase \"$a\" in\n\t\t\tSTART) sq=\"$b\" ;;\n\t\t\tgit-subtree-mainline:) main=\"$b\" ;;\n\t\t\tgit-subtree-split:) sub=\"$b\" ;;\n\t\t\tEND)\n\t\t\t\tdebug \"  Main is: '$main'\"\n\t\t\t\tif [ -z \"$main\" -a -n \"$sub\" ]; then\n\t\t\t\t\t# squash commits refer to a subtree\n\t\t\t\t\tdebug \"  Squash: $sq from $sub\"\n\t\t\t\t\tcache_set \"$sq\" \"$sub\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$main\" -a -n \"$sub\" ]; then\n\t\t\t\t\tdebug \"  Prior: $main -> $sub\"\n\t\t\t\t\tcache_set $main $sub\n\t\t\t\t\tcache_set $sub $sub\n\t\t\t\t\ttry_remove_previous \"$main\"\n\t\t\t\t\ttry_remove_previous \"$sub\"\n\t\t\t\tfi\n\t\t\t\tmain=\n\t\t\t\tsub=\n\t\t\t\t;;\n\t\tesac\n\tdone\n}\n\ncopy_commit()\n{\n\t# We're going to set some environment vars here, so\n\t# do it in a subshell to get rid of them safely later\n\tdebug copy_commit \"{$1}\" \"{$2}\" \"{$3}\"\n\tgit log -1 --pretty=format:'%an%n%ae%n%ad%n%cn%n%ce%n%cd%n%s%n%n%b' \"$1\" |\n\t(\n\t\tread GIT_AUTHOR_NAME\n\t\tread GIT_AUTHOR_EMAIL\n\t\tread GIT_AUTHOR_DATE\n\t\tread GIT_COMMITTER_NAME\n\t\tread GIT_COMMITTER_EMAIL\n\t\tread GIT_COMMITTER_DATE\n\t\texport  GIT_AUTHOR_NAME \\\n\t\t\tGIT_AUTHOR_EMAIL \\\n\t\t\tGIT_AUTHOR_DATE \\\n\t\t\tGIT_COMMITTER_NAME \\\n\t\t\tGIT_COMMITTER_EMAIL \\\n\t\t\tGIT_COMMITTER_DATE\n\t\t(echo -n \"$annotate\"; cat ) |\n\t\tgit commit-tree \"$2\" $3  # reads the rest of stdin\n\t) || die \"Can't copy commit $1\"\n}\n\nadd_msg()\n{\n\tdir=\"$1\"\n\tlatest_old=\"$2\"\n\tlatest_new=\"$3\"\n\tif [ -n \"$message\" ]; then\n\t\tcommit_message=\"$message\"\n\telse\n\t\tcommit_message=\"Add '$dir/' from commit '$latest_new'\"\n\tfi\n\tcat <<-EOF\n\t\t$commit_message\n\t\t\n\t\tgit-subtree-dir: $dir\n\t\tgit-subtree-mainline: $latest_old\n\t\tgit-subtree-split: $latest_new\n\tEOF\n}\n\nadd_squashed_msg()\n{\n\tif [ -n \"$message\" ]; then\n\t\techo \"$message\"\n\telse\n\t\techo \"Merge commit '$1' as '$2'\"\n\tfi\n}\n\nrejoin_msg()\n{\n\tdir=\"$1\"\n\tlatest_old=\"$2\"\n\tlatest_new=\"$3\"\n\tif [ -n \"$message\" ]; then\n\t\tcommit_message=\"$message\"\n\telse\n\t\tcommit_message=\"Split '$dir/' into commit '$latest_new'\"\n\tfi\n\tcat <<-EOF\n\t\t$commit_message\n\t\t\n\t\tgit-subtree-dir: $dir\n\t\tgit-subtree-mainline: $latest_old\n\t\tgit-subtree-split: $latest_new\n\tEOF\n}\n\nsquash_msg()\n{\n\tdir=\"$1\"\n\toldsub=\"$2\"\n\tnewsub=\"$3\"\n\tnewsub_short=$(git rev-parse --short \"$newsub\")\n\t\n\tif [ -n \"$oldsub\" ]; then\n\t\toldsub_short=$(git rev-parse --short \"$oldsub\")\n\t\techo \"Squashed '$dir/' changes from $oldsub_short..$newsub_short\"\n\t\techo\n\t\tgit log --pretty=tformat:'%h %s' \"$oldsub..$newsub\"\n\t\tgit log --pretty=tformat:'REVERT: %h %s' \"$newsub..$oldsub\"\n\telse\n\t\techo \"Squashed '$dir/' content from commit $newsub_short\"\n\tfi\n\t\n\techo\n\techo \"git-subtree-dir: $dir\"\n\techo \"git-subtree-split: $newsub\"\n}\n\ntoptree_for_commit()\n{\n\tcommit=\"$1\"\n\tgit log -1 --pretty=format:'%T' \"$commit\" -- || exit $?\n}\n\nsubtree_for_commit()\n{\n\tcommit=\"$1\"\n\tdir=\"$2\"\n\tgit ls-tree \"$commit\" -- \"$dir\" |\n\twhile read mode type tree name; do\n\t\tassert [ \"$name\" = \"$dir\" ]\n\t\tassert [ \"$type\" = \"tree\" -o \"$type\" = \"commit\" ]\n\t\t[ \"$type\" = \"commit\" ] && continue  # ignore submodules\n\t\techo $tree\n\t\tbreak\n\tdone\n}\n\ntree_changed()\n{\n\ttree=$1\n\tshift\n\tif [ $# -ne 1 ]; then\n\t\treturn 0   # weird parents, consider it changed\n\telse\n\t\tptree=$(toptree_for_commit $1)\n\t\tif [ \"$ptree\" != \"$tree\" ]; then\n\t\t\treturn 0   # changed\n\t\telse\n\t\t\treturn 1   # not changed\n\t\tfi\n\tfi\n}\n\nnew_squash_commit()\n{\n\told=\"$1\"\n\toldsub=\"$2\"\n\tnewsub=\"$3\"\n\ttree=$(toptree_for_commit $newsub) || exit $?\n\tif [ -n \"$old\" ]; then\n\t\tsquash_msg \"$dir\" \"$oldsub\" \"$newsub\" | \n\t\t\tgit commit-tree \"$tree\" -p \"$old\" || exit $?\n\telse\n\t\tsquash_msg \"$dir\" \"\" \"$newsub\" |\n\t\t\tgit commit-tree \"$tree\" || exit $?\n\tfi\n}\n\ncopy_or_skip()\n{\n\trev=\"$1\"\n\ttree=\"$2\"\n\tnewparents=\"$3\"\n\tassert [ -n \"$tree\" ]\n\n\tidentical=\n\tnonidentical=\n\tp=\n\tgotparents=\n\tfor parent in $newparents; do\n\t\tptree=$(toptree_for_commit $parent) || exit $?\n\t\t[ -z \"$ptree\" ] && continue\n\t\tif [ \"$ptree\" = \"$tree\" ]; then\n\t\t\t# an identical parent could be used in place of this rev.\n\t\t\tidentical=\"$parent\"\n\t\telse\n\t\t\tnonidentical=\"$parent\"\n\t\tfi\n\t\t\n\t\t# sometimes both old parents map to the same newparent;\n\t\t# eliminate duplicates\n\t\tis_new=1\n\t\tfor gp in $gotparents; do\n\t\t\tif [ \"$gp\" = \"$parent\" ]; then\n\t\t\t\tis_new=\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [ -n \"$is_new\" ]; then\n\t\t\tgotparents=\"$gotparents $parent\"\n\t\t\tp=\"$p -p $parent\"\n\t\tfi\n\tdone\n\t\n\tif [ -n \"$identical\" ]; then\n\t\techo $identical\n\telse\n\t\tcopy_commit $rev $tree \"$p\" || exit $?\n\tfi\n}\n\nensure_clean()\n{\n\tif ! git diff-index HEAD --exit-code --quiet 2>&1; then\n\t\tdie \"Working tree has modifications.  Cannot add.\"\n\tfi\n\tif ! git diff-index --cached HEAD --exit-code --quiet 2>&1; then\n\t\tdie \"Index has modifications.  Cannot add.\"\n\tfi\n}\n\ncmd_add()\n{\n\tif [ -e \"$dir\" ]; then\n\t\tdie \"'$dir' already exists.  Cannot add.\"\n\tfi\n\n\tensure_clean\n\t\n\tif [ $# -eq 1 ]; then\n\t\t\"cmd_add_commit\" \"$@\"\n\telif [ $# -eq 2 ]; then\n\t\t\"cmd_add_repository\" \"$@\"\n\telse\n\t    say \"error: parameters were '$@'\"\n\t    die \"Provide either a refspec or a repository and refspec.\"\n\tfi\n}\n\ncmd_add_repository()\n{\n\techo \"git fetch\" \"$@\"\n\trepository=$1\n\trefspec=$2\n\tgit fetch \"$@\" || exit $?\n\trevs=FETCH_HEAD\n\tset -- $revs\n\tcmd_add_commit \"$@\"\n}\n\ncmd_add_commit()\n{\n\trevs=$(git rev-parse $default --revs-only \"$@\") || exit $?\n\tset -- $revs\n\trev=\"$1\"\n\t\n\tdebug \"Adding $dir as '$rev'...\"\n\tgit read-tree --prefix=\"$dir\" $rev || exit $?\n\tgit checkout -- \"$dir\" || exit $?\n\ttree=$(git write-tree) || exit $?\n\t\n\theadrev=$(git rev-parse HEAD) || exit $?\n\tif [ -n \"$headrev\" -a \"$headrev\" != \"$rev\" ]; then\n\t\theadp=\"-p $headrev\"\n\telse\n\t\theadp=\n\tfi\n\t\n\tif [ -n \"$squash\" ]; then\n\t\trev=$(new_squash_commit \"\" \"\" \"$rev\") || exit $?\n\t\tcommit=$(add_squashed_msg \"$rev\" \"$dir\" |\n\t\t\t git commit-tree $tree $headp -p \"$rev\") || exit $?\n\telse\n\t\tcommit=$(add_msg \"$dir\" \"$headrev\" \"$rev\" |\n\t\t\t git commit-tree $tree $headp -p \"$rev\") || exit $?\n\tfi\n\tgit reset \"$commit\" || exit $?\n\t\n\tsay \"Added dir '$dir'\"\n}\n\ncmd_split()\n{\n\tdebug \"Splitting $dir...\"\n\tcache_setup || exit $?\n\t\n\tif [ -n \"$onto\" ]; then\n\t\tdebug \"Reading history for --onto=$onto...\"\n\t\tgit rev-list $onto |\n\t\twhile read rev; do\n\t\t\t# the 'onto' history is already just the subdir, so\n\t\t\t# any parent we find there can be used verbatim\n\t\t\tdebug \"  cache: $rev\"\n\t\t\tcache_set $rev $rev\n\t\tdone\n\tfi\n\t\n\tif [ -n \"$ignore_joins\" ]; then\n\t\tunrevs=\n\telse\n\t\tunrevs=\"$(find_existing_splits \"$dir\" \"$revs\")\"\n\tfi\n\t\n\t# We can't restrict rev-list to only $dir here, because some of our\n\t# parents have the $dir contents the root, and those won't match.\n\t# (and rev-list --follow doesn't seem to solve this)\n\tgrl='git rev-list --topo-order --reverse --parents $revs $unrevs'\n\trevmax=$(eval \"$grl\" | wc -l)\n\trevcount=0\n\tcreatecount=0\n\teval \"$grl\" |\n\twhile read rev parents; do\n\t\trevcount=$(($revcount + 1))\n\t\tsay -n \"$revcount/$revmax ($createcount)\r\"\n\t\tdebug \"Processing commit: $rev\"\n\t\texists=$(cache_get $rev)\n\t\tif [ -n \"$exists\" ]; then\n\t\t\tdebug \"  prior: $exists\"\n\t\t\tcontinue\n\t\tfi\n\t\tcreatecount=$(($createcount + 1))\n\t\tdebug \"  parents: $parents\"\n\t\tnewparents=$(cache_get $parents)\n\t\tdebug \"  newparents: $newparents\"\n\t\t\n\t\ttree=$(subtree_for_commit $rev \"$dir\")\n\t\tdebug \"  tree is: $tree\"\n\n\t\tcheck_parents $parents\n\t\t\n\t\t# ugly.  is there no better way to tell if this is a subtree\n\t\t# vs. a mainline commit?  Does it matter?\n\t\tif [ -z $tree ]; then\n\t\t\tset_notree $rev\n\t\t\tif [ -n \"$newparents\" ]; then\n\t\t\t\tcache_set $rev $rev\n\t\t\tfi\n\t\t\tcontinue\n\t\tfi\n\n\t\tnewrev=$(copy_or_skip \"$rev\" \"$tree\" \"$newparents\") || exit $?\n\t\tdebug \"  newrev is: $newrev\"\n\t\tcache_set $rev $newrev\n\t\tcache_set latest_new $newrev\n\t\tcache_set latest_old $rev\n\tdone || exit $?\n\tlatest_new=$(cache_get latest_new)\n\tif [ -z \"$latest_new\" ]; then\n\t\tdie \"No new revisions were found\"\n\tfi\n\t\n\tif [ -n \"$rejoin\" ]; then\n\t\tdebug \"Merging split branch into HEAD...\"\n\t\tlatest_old=$(cache_get latest_old)\n\t\tgit merge -s ours \\\n\t\t\t-m \"$(rejoin_msg $dir $latest_old $latest_new)\" \\\n\t\t\t$latest_new >&2 || exit $?\n\tfi\n\tif [ -n \"$branch\" ]; then\n\t\tif rev_exists \"refs/heads/$branch\"; then\n\t\t\tif ! rev_is_descendant_of_branch $latest_new $branch; then\n\t\t\t\tdie \"Branch '$branch' is not an ancestor of commit '$latest_new'.\"\n\t\t\tfi\n\t\t\taction='Updated'\n\t\telse\n\t\t\taction='Created'\n\t\tfi\n\t\tgit update-ref -m 'subtree split' \"refs/heads/$branch\" $latest_new || exit $?\n\t\tsay \"$action branch '$branch'\"\n\tfi\n\techo $latest_new\n\texit 0\n}\n\ncmd_merge()\n{\n\trevs=$(git rev-parse $default --revs-only \"$@\") || exit $?\n\tensure_clean\n\t\n\tset -- $revs\n\tif [ $# -ne 1 ]; then\n\t\tdie \"You must provide exactly one revision.  Got: '$revs'\"\n\tfi\n\trev=\"$1\"\n\t\n\tif [ -n \"$squash\" ]; then\n\t\tfirst_split=\"$(find_latest_squash \"$dir\")\"\n\t\tif [ -z \"$first_split\" ]; then\n\t\t\tdie \"Can't squash-merge: '$dir' was never added.\"\n\t\tfi\n\t\tset $first_split\n\t\told=$1\n\t\tsub=$2\n\t\tif [ \"$sub\" = \"$rev\" ]; then\n\t\t\tsay \"Subtree is already at commit $rev.\"\n\t\t\texit 0\n\t\tfi\n\t\tnew=$(new_squash_commit \"$old\" \"$sub\" \"$rev\") || exit $?\n\t\tdebug \"New squash commit: $new\"\n\t\trev=\"$new\"\n\tfi\n\n\tversion=$(git version)\n\tif [ \"$version\" \\< \"git version 1.7\" ]; then\n\t\tif [ -n \"$message\" ]; then\n\t\t\tgit merge -s subtree --message=\"$message\" $rev\n\t\telse\n\t\t\tgit merge -s subtree $rev\n\t\tfi\n\telse\n\t\tif [ -n \"$message\" ]; then\n\t\t\tgit merge -Xsubtree=\"$prefix\" --message=\"$message\" $rev\n\t\telse\n\t\t\tgit merge -Xsubtree=\"$prefix\" $rev\n\t\tfi\n\tfi\n}\n\ncmd_pull()\n{\n\tensure_clean\n\tgit fetch \"$@\" || exit $?\n\trevs=FETCH_HEAD\n\tset -- $revs\n\tcmd_merge \"$@\"\n}\n\ncmd_push()\n{\n\tif [ $# -ne 2 ]; then\n\t    die \"You must provide <repository> <refspec>\"\n\tfi\n\tif [ -e \"$dir\" ]; then\n\t    repository=$1\n\t    refspec=$2\n\t    echo \"git push using: \" $repository $refspec\n\t    git push $repository $(git subtree split --prefix=$prefix):refs/heads/$refspec\n\telse\n\t    die \"'$dir' must already exist. Try 'git subtree add'.\"\n\tfi\n}\n\n\"cmd_$command\" \"$@\"\n"
        },
        {
          "name": "git-subtree.txt",
          "type": "blob",
          "size": 12.4521484375,
          "content": "git-subtree(1)\n==============\n\nNAME\n----\ngit-subtree - Merge subtrees together and split repository into subtrees\n\n\nSYNOPSIS\n--------\n[verse]\n'git subtree' add   -P <prefix> <commit>\n'git subtree' pull  -P <prefix> <repository> <refspec...>\n'git subtree' push  -P <prefix> <repository> <refspec...>\n'git subtree' merge -P <prefix> <commit>\n'git subtree' split -P <prefix> [OPTIONS] [<commit>]\n\n\nDESCRIPTION\n-----------\nSubtrees allow subprojects to be included within a subdirectory\nof the main project, optionally including the subproject's\nentire history.\n\nFor example, you could include the source code for a library\nas a subdirectory of your application.\n\nSubtrees are not to be confused with submodules, which are meant for\nthe same task. Unlike submodules, subtrees do not need any special\nconstructions (like .gitmodule files or gitlinks) be present in\nyour repository, and do not force end-users of your\nrepository to do anything special or to understand how subtrees\nwork. A subtree is just a subdirectory that can be\ncommitted to, branched, and merged along with your project in\nany way you want.\n\nThey are also not to be confused with using the subtree merge\nstrategy. The main difference is that, besides merging\nthe other project as a subdirectory, you can also extract the\nentire history of a subdirectory from your project and make it\ninto a standalone project. Unlike the subtree merge strategy\nyou can alternate back and forth between these\ntwo operations. If the standalone library gets updated, you can\nautomatically merge the changes into your project; if you\nupdate the library inside your project, you can \"split\" the\nchanges back out again and merge them back into the library\nproject.\n\nFor example, if a library you made for one application ends up being\nuseful elsewhere, you can extract its entire history and publish\nthat as its own git repository, without accidentally\nintermingling the history of your application project.\n\n[TIP]\nIn order to keep your commit messages clean, we recommend that\npeople split their commits between the subtrees and the main\nproject as much as possible.  That is, if you make a change that\naffects both the library and the main application, commit it in\ntwo pieces.  That way, when you split the library commits out\nlater, their descriptions will still make sense.  But if this\nisn't important to you, it's not *necessary*.  git subtree will\nsimply leave out the non-library-related parts of the commit\nwhen it splits it out into the subproject later.\n\n\nCOMMANDS\n--------\nadd::\n\tCreate the <prefix> subtree by importing its contents\n\tfrom the given <refspec> or <repository> and remote <refspec>.\n\tA new commit is created\tautomatically, joining the imported\n\tproject's history with your own.  With '--squash', imports\n\tonly a single commit from the subproject, rather than its\n\tentire history.\n\nmerge::\n\tMerge recent changes up to <commit> into the <prefix>\n\tsubtree.  As with normal 'git merge', this doesn't\n\tremove your own local changes; it just merges those\n\tchanges into the latest <commit>.  With '--squash',\n\tcreates only one commit that contains all the changes,\n\trather than merging in the entire history.\n\n\tIf you use '--squash', the merge direction doesn't\n\talways have to be forward; you can use this command to\n\tgo back in time from v2.5 to v2.4, for example.  If your\n\tmerge introduces a conflict, you can resolve it in the\n\tusual ways.\n\t\npull::\n\tExactly like 'merge', but parallels 'git pull' in that\n\tit fetches the given commit from the specified remote\n\trepository.\n\t\npush::\n\tDoes a 'split' (see above) using the <prefix> supplied\n\tand then does a 'git push' to push the result to the \n\trepository and refspec. This can be used to push your\n\tsubtree to different branches of the remote repository.\n\nsplit::\n\tExtract a new, synthetic project history from the\n\thistory of the <prefix> subtree.  The new history\n\tincludes only the commits (including merges) that\n\taffected <prefix>, and each of those commits now has the\n\tcontents of <prefix> at the root of the project instead\n\tof in a subdirectory.  Thus, the newly created history\n\tis suitable for export as a separate git repository.\n\t\n\tAfter splitting successfully, a single commit id is\n\tprinted to stdout.  This corresponds to the HEAD of the\n\tnewly created tree, which you can manipulate however you\n\twant.\n\t\n\tRepeated splits of exactly the same history are\n\tguaranteed to be identical (ie. to produce the same\n\tcommit ids).  Because of this, if you add new commits\n\tand then re-split, the new commits will be attached as\n\tcommits on top of the history you generated last time,\n\tso 'git merge' and friends will work as expected.\n\t\n\tNote that if you use '--squash' when you merge, you\n\tshould usually not just '--rejoin' when you split.\n\n\nOPTIONS\n-------\n-q::\n--quiet::\n\tSuppress unnecessary output messages on stderr.\n\n-d::\n--debug::\n\tProduce even more unnecessary output messages on stderr.\n\n-P <prefix>::\n--prefix=<prefix>::\n\tSpecify the path in the repository to the subtree you\n\twant to manipulate.  This option is mandatory\n\tfor all commands.\n\n-m <message>::\n--message=<message>::\n\tThis option is only valid for add, merge and pull (unsure).\n\tSpecify <message> as the commit message for the merge commit.\n\n\nOPTIONS FOR add, merge, push, pull\n----------------------------------\n--squash::\n\tThis option is only valid for add, merge, push and pull\n\tcommands.\n\n\tInstead of merging the entire history from the subtree\n\tproject, produce only a single commit that contains all\n\tthe differences you want to merge, and then merge that\n\tnew commit into your project.\n\t\n\tUsing this option helps to reduce log clutter. People\n\trarely want to see every change that happened between\n\tv1.0 and v1.1 of the library they're using, since none of the\n\tinterim versions were ever included in their application.\n\t\n\tUsing '--squash' also helps avoid problems when the same\n\tsubproject is included multiple times in the same\n\tproject, or is removed and then re-added.  In such a\n\tcase, it doesn't make sense to combine the histories\n\tanyway, since it's unclear which part of the history\n\tbelongs to which subtree.\n\t\n\tFurthermore, with '--squash', you can switch back and\n\tforth between different versions of a subtree, rather\n\tthan strictly forward.  'git subtree merge --squash'\n\talways adjusts the subtree to match the exactly\n\tspecified commit, even if getting to that commit would\n\trequire undoing some changes that were added earlier.\n\t\n\tWhether or not you use '--squash', changes made in your\n\tlocal repository remain intact and can be later split\n\tand send upstream to the subproject.\n\n\nOPTIONS FOR split\n-----------------\n--annotate=<annotation>::\n\tThis option is only valid for the split command.\n\n\tWhen generating synthetic history, add <annotation> as a\n\tprefix to each commit message.  Since we're creating new\n\tcommits with the same commit message, but possibly\n\tdifferent content, from the original commits, this can help\n\tto differentiate them and avoid confusion.\n\t\n\tWhenever you split, you need to use the same\n\t<annotation>, or else you don't have a guarantee that\n\tthe new re-created history will be identical to the old\n\tone.  That will prevent merging from working correctly. \n\tgit subtree tries to make it work anyway, particularly\n\tif you use --rejoin, but it may not always be effective.\n\n-b <branch>::\n--branch=<branch>::\n\tThis option is only valid for the split command.\n\n\tAfter generating the synthetic history, create a new\n\tbranch called <branch> that contains the new history. \n\tThis is suitable for immediate pushing upstream. \n\t<branch> must not already exist.\n\n--ignore-joins::\n\tThis option is only valid for the split command.\n\n\tIf you use '--rejoin', git subtree attempts to optimize\n\tits history reconstruction to generate only the new\n\tcommits since the last '--rejoin'.  '--ignore-join'\n\tdisables this behaviour, forcing it to regenerate the\n\tentire history.  In a large project, this can take a\n\tlong time.\n\n--onto=<onto>::\n\tThis option is only valid for the split command.\n\n\tIf your subtree was originally imported using something\n\tother than git subtree, its history may not match what\n\tgit subtree is expecting.  In that case, you can specify\n\tthe commit id <onto> that corresponds to the first\n\trevision of the subproject's history that was imported\n\tinto your project, and git subtree will attempt to build\n\tits history from there.\n\t\n\tIf you used 'git subtree add', you should never need\n\tthis option.\n\n--rejoin::\n\tThis option is only valid for the split command.\n\n\tAfter splitting, merge the newly created synthetic\n\thistory back into your main project.  That way, future\n\tsplits can search only the part of history that has\n\tbeen added since the most recent --rejoin.\n\t\n\tIf your split commits end up merged into the upstream\n\tsubproject, and then you want to get the latest upstream\n\tversion, this will allow git's merge algorithm to more\n\tintelligently avoid conflicts (since it knows these\n\tsynthetic commits are already part of the upstream\n\trepository).\n\t\n\tUnfortunately, using this option results in 'git log'\n\tshowing an extra copy of every new commit that was\n\tcreated (the original, and the synthetic one).\n\t\n\tIf you do all your merges with '--squash', don't use\n\t'--rejoin' when you split, because you don't want the\n\tsubproject's history to be part of your project anyway.\n\n\nEXAMPLE 1. Add command\n----------------------\nLet's assume that you have a local repository that you would like\nto add an external vendor library to. In this case we will add the\ngit-subtree repository as a subdirectory of your already existing\ngit-extensions repository in ~/git-extensions/:\n\n\t$ git subtree add --prefix=git-subtree --squash \\\n\t\tgit://github.com/apenwarr/git-subtree.git master\n\n'master' needs to be a valid remote ref and can be a different branch\nname\n\nYou can omit the --squash flag, but doing so will increase the number\nof commits that are incldued in your local repository.\n\nWe now have a ~/git-extensions/git-subtree directory containing code\nfrom the master branch of git://github.com/apenwarr/git-subtree.git\nin our git-extensions repository.\n\nEXAMPLE 2. Extract a subtree using commit, merge and pull\n---------------------------------------------------------\nLet's use the repository for the git source code as an example.\nFirst, get your own copy of the git.git repository:\n\n\t$ git clone git://git.kernel.org/pub/scm/git/git.git test-git\n\t$ cd test-git\n\ngitweb (commit 1130ef3) was merged into git as of commit\n0a8f4f0, after which it was no longer maintained separately. \nBut imagine it had been maintained separately, and we wanted to\nextract git's changes to gitweb since that time, to share with\nthe upstream.  You could do this:\n\n\t$ git subtree split --prefix=gitweb --annotate='(split) ' \\\n        \t0a8f4f0^.. --onto=1130ef3 --rejoin \\\n        \t--branch gitweb-latest\n        $ gitk gitweb-latest\n        $ git push git@github.com:whatever/gitweb.git gitweb-latest:master\n        \n(We use '0a8f4f0^..' because that means \"all the changes from\n0a8f4f0 to the current version, including 0a8f4f0 itself.\")\n\nIf gitweb had originally been merged using 'git subtree add' (or\na previous split had already been done with --rejoin specified)\nthen you can do all your splits without having to remember any\nweird commit ids:\n\n\t$ git subtree split --prefix=gitweb --annotate='(split) ' --rejoin \\\n\t\t--branch gitweb-latest2\n\nAnd you can merge changes back in from the upstream project just\nas easily:\n\n\t$ git subtree pull --prefix=gitweb \\\n\t\tgit@github.com:whatever/gitweb.git master\n\nOr, using '--squash', you can actually rewind to an earlier\nversion of gitweb:\n\n\t$ git subtree merge --prefix=gitweb --squash gitweb-latest~10\n\nThen make some changes:\n\n\t$ date >gitweb/myfile\n\t$ git add gitweb/myfile\n\t$ git commit -m 'created myfile'\n\nAnd fast forward again:\n\n\t$ git subtree merge --prefix=gitweb --squash gitweb-latest\n\nAnd notice that your change is still intact:\n\t\n\t$ ls -l gitweb/myfile\n\nAnd you can split it out and look at your changes versus\nthe standard gitweb:\n\n\tgit log gitweb-latest..$(git subtree split --prefix=gitweb)\n\nEXAMPLE 3. Extract a subtree using branch\n-----------------------------------------\nSuppose you have a source directory with many files and\nsubdirectories, and you want to extract the lib directory to its own\ngit project. Here's a short way to do it:\n\nFirst, make the new repository wherever you want:\n\n\t$ <go to the new location>\n\t$ git init --bare\n\nBack in your original directory:\n\n\t$ git subtree split --prefix=lib --annotate=\"(split)\" -b split\n\nThen push the new branch onto the new empty repository:\n\n\t$ git push <new-repo> split:master\n\n\nAUTHOR\n------\nWritten by Avery Pennarun <apenwarr@gmail.com>\n\n\nGIT\n---\nPart of the linkgit:git[1] suite\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 0.1064453125,
          "content": "# copy Git to where the rest of the Git scripts are found.\ncp git-subtree.sh \"$(git --exec-path)\"/git-subtree"
        },
        {
          "name": "manpage-base.xsl",
          "type": "blob",
          "size": 1.1640625,
          "content": "<!-- manpage-base.xsl:\n     special formatting for manpages rendered from asciidoc+docbook -->\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n\t\tversion=\"1.0\">\n\n<!-- these params silence some output from xmlto -->\n<xsl:param name=\"man.output.quietly\" select=\"1\"/>\n<xsl:param name=\"refentry.meta.get.quietly\" select=\"1\"/>\n\n<!-- convert asciidoc callouts to man page format;\n     git.docbook.backslash and git.docbook.dot params\n     must be supplied by another XSL file or other means -->\n<xsl:template match=\"co\">\n\t<xsl:value-of select=\"concat(\n\t\t\t      $git.docbook.backslash,'fB(',\n\t\t\t      substring-after(@id,'-'),')',\n\t\t\t      $git.docbook.backslash,'fR')\"/>\n</xsl:template>\n<xsl:template match=\"calloutlist\">\n\t<xsl:value-of select=\"$git.docbook.dot\"/>\n\t<xsl:text>sp&#10;</xsl:text>\n\t<xsl:apply-templates/>\n\t<xsl:text>&#10;</xsl:text>\n</xsl:template>\n<xsl:template match=\"callout\">\n\t<xsl:value-of select=\"concat(\n\t\t\t      $git.docbook.backslash,'fB',\n\t\t\t      substring-after(@arearefs,'-'),\n\t\t\t      '. ',$git.docbook.backslash,'fR')\"/>\n\t<xsl:apply-templates/>\n\t<xsl:value-of select=\"$git.docbook.dot\"/>\n\t<xsl:text>br&#10;</xsl:text>\n</xsl:template>\n\n</xsl:stylesheet>\n"
        },
        {
          "name": "manpage-normal.xsl",
          "type": "blob",
          "size": 0.4638671875,
          "content": "<!-- manpage-normal.xsl:\n     special settings for manpages rendered from asciidoc+docbook\n     handles anything we want to keep away from docbook-xsl 1.72.0 -->\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n\t\tversion=\"1.0\">\n\n<xsl:import href=\"manpage-base.xsl\"/>\n\n<!-- these are the normal values for the roff control characters -->\n<xsl:param name=\"git.docbook.backslash\">\\</xsl:param>\n<xsl:param name=\"git.docbook.dot\"\t>.</xsl:param>\n\n</xsl:stylesheet>\n"
        },
        {
          "name": "shellopts.sh",
          "type": "blob",
          "size": 0.0224609375,
          "content": "export PATH=$PWD:$PATH\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 8.1640625,
          "content": "#!/bin/bash\n. shellopts.sh\nset -e\n\ncreate()\n{\n\techo \"$1\" >\"$1\"\n\tgit add \"$1\"\n}\n\ncheck()\n{\n\techo\n\techo \"check:\" \"$@\"\n\tif \"$@\"; then\n\t\techo ok\n\t\treturn 0\n\telse\n\t\techo FAILED\n\t\texit 1\n\tfi\n}\n\ncheck_not()\n{\n\techo\n\techo \"check: NOT \" \"$@\"\n\tif \"$@\"; then\n\t\techo FAILED\n\t\texit 1\n\telse\n\t\techo ok\n\t\treturn 0\n\tfi\n}\n\ncheck_equal()\n{\n\techo\n\techo \"check a:\" \"{$1}\"\n\techo \"      b:\" \"{$2}\"\n\tif [ \"$1\" = \"$2\" ]; then\n\t\treturn 0\n\telse\n\t\techo FAILED\n\t\texit 1\n\tfi\n}\n\nfixnl()\n{\t\n\tt=\"\"\n\twhile read x; do\n\t\tt=\"$t$x \"\n\tdone\n\techo $t\n}\n\nmultiline()\n{\n\twhile read x; do\n\t\tset -- $x\n\t\tfor d in \"$@\"; do\n\t\t\techo \"$d\"\n\t\tdone\n\tdone\n}\n\nundo()\n{\n\tgit reset --hard HEAD~\n}\n\nlast_commit_message()\n{\n\tgit log --pretty=format:%s -1\n}\n\nrm -rf mainline subproj\nmkdir mainline subproj\n\ncd subproj\ngit init\n\ncreate sub1\ngit commit -m 'sub1'\ngit branch sub1\ngit branch -m master subproj\ncheck true\n\ncreate sub2\ngit commit -m 'sub2'\ngit branch sub2\n\ncreate sub3\ngit commit -m 'sub3'\ngit branch sub3\n\ncd ../mainline\ngit init\ncreate main4\ngit commit -m 'main4'\ngit branch -m master mainline\ngit branch subdir\n\ngit fetch ../subproj sub1\ngit branch sub1 FETCH_HEAD\n\n# check if --message works for add\ncheck_not git subtree merge --prefix=subdir sub1\ncheck_not git subtree pull --prefix=subdir ../subproj sub1\ngit subtree add --prefix=subdir --message=\"Added subproject\" sub1\ncheck_equal \"$(last_commit_message)\" \"Added subproject\"\nundo\n\n# check if --message works as -m and --prefix as -P\ngit subtree add -P subdir -m \"Added subproject using git subtree\" sub1\ncheck_equal \"$(last_commit_message)\" \"Added subproject using git subtree\"\nundo\n\n# check if --message works with squash too\ngit subtree add -P subdir -m \"Added subproject with squash\" --squash sub1\ncheck_equal \"$(last_commit_message)\" \"Added subproject with squash\"\nundo\n\ngit subtree add --prefix=subdir/ FETCH_HEAD\ncheck_equal \"$(last_commit_message)\" \"Add 'subdir/' from commit '$(git rev-parse sub1)'\"\n\n# this shouldn't actually do anything, since FETCH_HEAD is already a parent\ngit merge -m 'merge -s -ours' -s ours FETCH_HEAD\n\ncreate subdir/main-sub5\ngit commit -m 'main-sub5'\n\ncreate main6\ngit commit -m 'main6 boring'\n\ncreate subdir/main-sub7\ngit commit -m 'main-sub7'\n\ngit fetch ../subproj sub2\ngit branch sub2 FETCH_HEAD\n\n# check if --message works for merge\ngit subtree merge --prefix=subdir -m \"Merged changes from subproject\" sub2\ncheck_equal \"$(last_commit_message)\" \"Merged changes from subproject\"\nundo\n\n# check if --message for merge works with squash too\ngit subtree merge --prefix subdir -m \"Merged changes from subproject using squash\" --squash sub2\ncheck_equal \"$(last_commit_message)\" \"Merged changes from subproject using squash\"\nundo\n\ngit subtree merge --prefix=subdir FETCH_HEAD\ngit branch pre-split\ncheck_equal \"$(last_commit_message)\" \"Merge commit '$(git rev-parse sub2)' into mainline\"\n\n# Check that prefix argument is required for split (exits with warning and exit status = 1)\n! result=$(git subtree split 2>&1)\ncheck_equal \"You must provide the --prefix option.\" \"$result\"\n\n# Check that the <prefix> exists for a split.\n! result=$(git subtree split --prefix=non-existent-directory 2>&1)\ncheck_equal \"'non-existent-directory' does not exist; use 'git subtree add'\" \\\n  \"$result\"\n\n# check if --message works for split+rejoin\nspl1=$(git subtree split --annotate='*' --prefix subdir --onto FETCH_HEAD --message \"Split & rejoin\" --rejoin)\necho \"spl1={$spl1}\"\ngit branch spl1 \"$spl1\"\ncheck_equal \"$(last_commit_message)\" \"Split & rejoin\"\nundo\n\n# check split with --branch\ngit subtree split --annotate='*' --prefix subdir --onto FETCH_HEAD --branch splitbr1\ncheck_equal \"$(git rev-parse splitbr1)\" \"$spl1\"\n\n# check split with --branch for an existing branch\ngit branch splitbr2 sub1\ngit subtree split --annotate='*' --prefix subdir --onto FETCH_HEAD --branch splitbr2\ncheck_equal \"$(git rev-parse splitbr2)\" \"$spl1\"\n\n# check split with --branch for an incompatible branch\nresult=$(git subtree split --prefix subdir --onto FETCH_HEAD --branch subdir || echo \"caught error\")\ncheck_equal \"$result\" \"caught error\"\n\n\ngit subtree split --annotate='*' --prefix subdir --onto FETCH_HEAD --rejoin\ncheck_equal \"$(last_commit_message)\" \"Split 'subdir/' into commit '$spl1'\"\n\ncreate subdir/main-sub8\ngit commit -m 'main-sub8'\n\ncd ../subproj\ngit fetch ../mainline spl1\ngit branch spl1 FETCH_HEAD\ngit merge FETCH_HEAD\n\ncreate sub9\ngit commit -m 'sub9'\n\ncd ../mainline\nsplit2=$(git subtree split --annotate='*' --prefix subdir/ --rejoin)\ngit branch split2 \"$split2\"\n\ncreate subdir/main-sub10\ngit commit -m 'main-sub10'\n\nspl3=$(git subtree split --annotate='*' --prefix subdir --rejoin)\ngit branch spl3 \"$spl3\"\n\ncd ../subproj\ngit fetch ../mainline spl3\ngit branch spl3 FETCH_HEAD\ngit merge FETCH_HEAD\ngit branch subproj-merge-spl3\n\nchkm=\"main4 main6\"\nchkms=\"main-sub10 main-sub5 main-sub7 main-sub8\"\nchkms_sub=$(echo $chkms | multiline | sed 's,^,subdir/,' | fixnl)\nchks=\"sub1 sub2 sub3 sub9\"\nchks_sub=$(echo $chks | multiline | sed 's,^,subdir/,' | fixnl)\n\n# make sure exactly the right set of files ends up in the subproj\nsubfiles=$(git ls-files | fixnl)\ncheck_equal \"$subfiles\" \"$chkms $chks\"\n\n# make sure the subproj history *only* contains commits that affect the subdir.\nallchanges=$(git log --name-only --pretty=format:'' | sort | fixnl)\ncheck_equal \"$allchanges\" \"$chkms $chks\"\n\ncd ../mainline\ngit fetch ../subproj subproj-merge-spl3\ngit branch subproj-merge-spl3 FETCH_HEAD\ngit subtree pull --prefix=subdir ../subproj subproj-merge-spl3\n\n# make sure exactly the right set of files ends up in the mainline\nmainfiles=$(git ls-files | fixnl)\ncheck_equal \"$mainfiles\" \"$chkm $chkms_sub $chks_sub\"\n\n# make sure each filename changed exactly once in the entire history.\n# 'main-sub??' and '/subdir/main-sub??' both change, because those are the\n# changes that were split into their own history.  And 'subdir/sub??' never\n# change, since they were *only* changed in the subtree branch.\nallchanges=$(git log --name-only --pretty=format:'' | sort | fixnl)\ncheck_equal \"$allchanges\" \"$(echo $chkms $chkm $chks $chkms_sub | multiline | sort | fixnl)\"\n\n# make sure the --rejoin commits never make it into subproj\ncheck_equal \"$(git log --pretty=format:'%s' HEAD^2 | grep -i split)\" \"\"\n\n# make sure no 'git subtree' tagged commits make it into subproj. (They're\n# meaningless to subproj since one side of the merge refers to the mainline)\ncheck_equal \"$(git log --pretty=format:'%s%n%b' HEAD^2 | grep 'git-subtree.*:')\" \"\"\n\n\n# check if split can find proper base without --onto\n# prepare second pair of repositories\nmkdir test2\ncd test2\n\nmkdir main\ncd main\ngit init\ncreate main1\ngit commit -m \"main1\"\n\ncd ..\nmkdir sub\ncd sub\ngit init\ncreate sub2\ngit commit -m \"sub2\"\n\ncd ../main\ngit fetch ../sub master\ngit branch sub2 FETCH_HEAD\ngit subtree add --prefix subdir sub2\n\ncd ../sub\ncreate sub3\ngit commit -m \"sub3\"\n\ncd ../main\ngit fetch ../sub master\ngit branch sub3 FETCH_HEAD\ngit subtree merge --prefix subdir sub3\n\ncreate subdir/main-sub4\ngit commit -m \"main-sub4\"\ngit subtree split --prefix subdir --branch mainsub4\n\n# at this point, the new commit's parent should be sub3\n# if it's not, something went wrong (the \"newparent\" of \"master~\" commit should have been sub3,\n# but it wasn't, because it's cache was not set to itself)\ncheck_equal \"$(git log --pretty=format:%P -1 mainsub4)\" \"$(git rev-parse sub3)\"\n\nmkdir subdir2\ncreate subdir2/main-sub5\ngit commit -m \"main-sub5\"\ngit subtree split --prefix subdir2 --branch mainsub5\n\n# also test that we still can split out an entirely new subtree\n# if the parent of the first commit in the tree isn't empty,\n# then the new subtree has accidently been attached to something\ncheck_equal \"$(git log --pretty=format:%P -1 mainsub5)\" \"\"\n\n\n# make sure no patch changes more than one file.  The original set of commits\n# changed only one file each.  A multi-file change would imply that we pruned\n# commits too aggressively.\njoincommits()\n{\n\tcommit=\n\tall=\n\twhile read x y; do\n\t\techo \"{$x}\" >&2\n\t\tif [ -z \"$x\" ]; then\n\t\t\tcontinue\n\t\telif [ \"$x\" = \"commit:\" ]; then\n\t\t\tif [ -n \"$commit\" ]; then\n\t\t\t\techo \"$commit $all\"\n\t\t\t\tall=\n\t\t\tfi\n\t\t\tcommit=\"$y\"\n\t\telse\n\t\t\tall=\"$all $y\"\n\t\tfi\n\tdone\n\techo \"$commit $all\"\n}\nx=\ngit log --pretty=format:'commit: %H' | joincommits |\n(\twhile read commit a b; do\n\t\techo \"Verifying commit $commit\"\n\t\tcheck_equal \"$b\" \"\"\n\t\tx=1\n\tdone\n\tcheck_equal \"$x\" 1\n) || exit 1\n\necho\necho 'ok'\n"
        },
        {
          "name": "todo",
          "type": "blob",
          "size": 1.6923828125,
          "content": "\n\tdelete tempdir\n\n\t'git subtree rejoin' option to do the same as --rejoin, eg. after a\n\t  rebase\n\n\t--prefix doesn't force the subtree correctly in merge/pull:\n\t\"-s subtree\" should be given an explicit subtree option?\n\t\tThere doesn't seem to be a way to do this.  We'd have to\n\t\tpatch git-merge-subtree.  Ugh.\n\t\t(but we could avoid this problem by generating squashes with\n\t\texactly the right subtree structure, rather than using\n\t\tsubtree merge...)\n\n\tadd a 'push' subcommand to parallel 'pull'\n\t\n\tadd a 'log' subcommand to see what's new in a subtree?\n\n\tadd to-submodule and from-submodule commands\n\n\tautomated tests for --squash stuff\n\n\t\"add\" command non-obviously requires a commitid; would be easier if\n\t\tit had a \"pull\" sort of mode instead\n\n\t\"pull\" and \"merge\" commands should fail if you've never merged\n\t\tthat --prefix before\n\t\t\n\tdocs should provide an example of \"add\"\n\t\n\tnote that the initial split doesn't *have* to have a commitid\n\t\tspecified... that's just an optimization\n\n\tif you try to add (or maybe merge?) with an invalid commitid, you\n\t\tget a misleading \"prefix must end with /\" message from\n\t\tone of the other git tools that git-subtree calls.  Should\n\t\tdetect this situation and print the *real* problem.\n\t\n\t\"pull --squash\" should do fetch-synthesize-merge, but instead just\n\t\tdoes \"pull\" directly, which doesn't work at all.\n\n\tmake a 'force-update' that does what 'add' does even if the subtree\n\t\talready exists.  That way we can help people who imported\n\t\tsubtrees \"incorrectly\" (eg. by just copying in the files) in\n\t\tthe past.\n\n\tguess --prefix automatically if possible based on pwd\n\n\tmake a 'git subtree grafts' that automatically expands --squash'd\n\t\tcommits so you can see the full history if you want it.\n"
        }
      ]
    }
  ]
}