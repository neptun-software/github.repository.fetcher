{
  "metadata": {
    "timestamp": 1736568605253,
    "page": 669,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "willfarrell/docker-autoheal",
      "stars": 1401,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0478515625,
          "content": ".github\n.gitignore\n.dockerignore\nDockerfile\ntests"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "\n\n# IDE\n.idea\n*.iml\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.5478515625,
          "content": "# syntax = docker/dockerfile:latest\n\nARG ALPINE_VERSION=3.18\n\nFROM alpine:${ALPINE_VERSION}\n\nRUN apk add --no-cache curl jq\n\nENV AUTOHEAL_CONTAINER_LABEL=autoheal \\\n    AUTOHEAL_START_PERIOD=0 \\\n    AUTOHEAL_INTERVAL=5 \\\n    AUTOHEAL_DEFAULT_STOP_TIMEOUT=10 \\\n    DOCKER_SOCK=/var/run/docker.sock \\\n    CURL_TIMEOUT=30 \\\n    WEBHOOK_URL=\"\" \\\n    WEBHOOK_JSON_KEY=\"content\" \\\n    APPRISE_URL=\"\" \\\n    POST_RESTART_SCRIPT=\"\"\n\nCOPY docker-entrypoint /\n\nHEALTHCHECK --interval=5s CMD pgrep -f autoheal || exit 1\n\nENTRYPOINT [\"/docker-entrypoint\"]\n\nCMD [\"autoheal\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2018 will Farrell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.3759765625,
          "content": "# Docker Autoheal\n\nMonitor and restart unhealthy docker containers. \nThis functionality was proposed to be included with the addition of `HEALTHCHECK`, however didn't make the cut.\nThis container is a stand-in till there is native support for `--exit-on-unhealthy` https://github.com/docker/docker/pull/22719.\n\n## Supported tags and Dockerfile links\n- [`latest` (*Dockerfile*)](https://github.com/willfarrell/docker-autoheal/blob/main/Dockerfile) - Built daily\n- [`1.1.0` (*Dockerfile*)](https://github.com/willfarrell/docker-autoheal/blob/1.1.0/Dockerfile)\n- [`v0.7.0` (*Dockerfile*)](https://github.com/willfarrell/docker-autoheal/blob/v0.7.0/Dockerfile)\n\n\n![](https://img.shields.io/docker/pulls/willfarrell/autoheal \"Total docker pulls\") [![](https://images.microbadger.com/badges/image/willfarrell/autoheal.svg)](http://microbadger.com/images/willfarrell/autoheal \"Docker layer breakdown\")\n\n## How to use\n\n### 1. Docker CLI\n#### UNIX socket passthrough\n```bash\ndocker run -d \\\n    --name autoheal \\\n    --restart=always \\\n    -e AUTOHEAL_CONTAINER_LABEL=all \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    willfarrell/autoheal\n```\n#### TCP socket \n```bash\ndocker run -d \\\n    --name autoheal \\\n    --restart=always \\\n    -e AUTOHEAL_CONTAINER_LABEL=all \\\n    -e DOCKER_SOCK=tcp://$HOST:$PORT \\\n    -v /path/to/certs/:/certs/:ro \\\n    willfarrell/autoheal\n```\n#### TCP with mTLS (HTTPS)\n```bash\ndocker run -d \\\n    --name autoheal \\\n    --restart=always \\\n    --tlscacert=/certs/ca.pem \\\n    --tlscert=/certs/client-cert.pem \\\n    --tlskey=/certs/client-key.pem \\\n    -e AUTOHEAL_CONTAINER_LABEL=all \\\n    -e DOCKER_HOST=tcp://$HOST:2376 \\\n    -e DOCKER_SOCK=tcps://$HOST:2376 \\\n    -e DOCKER_TLS_VERIFY=1 \\\n    -v /path/to/certs/:/certs/:ro \\\n    willfarrell/autoheal\n```\nThe certificates and keys need these names and resides under /certs inside the container:\n* ca.pem\n* client-cert.pem\n* client-key.pem\n\n> See https://docs.docker.com/engine/security/https/ for how to configure TCP with mTLS\n\n### Change Timezone\nIf you need the timezone to match the local machine, you can map the `/etc/localtime` into the container.\n```bash\ndocker run ... -v /etc/localtime:/etc/localtime:ro\n```\n\n### 2. Use in your container image\nChoose one of the three alternatives:\n\na) Apply the label `autoheal=true` to your container to have it watched;<br/>\nb) Set ENV `AUTOHEAL_CONTAINER_LABEL=all` to watch all running containers;<br/>\nc) Set ENV `AUTOHEAL_CONTAINER_LABEL` to existing container label that has the value `true`;<br/>\n\n> Note: You must apply `HEALTHCHECK` to your docker images first.<br/>\n> See https://docs.docker.com/engine/reference/builder/#healthcheck for details.\n\n#### Docker Compose (example)\n```yaml\nservices:\n  app:\n    extends:\n      file: ${PWD}/services.yml\n      service: app\n    labels:\n      autoheal-app: true\n\n  autoheal:\n    deploy:\n      replicas: 1\n    environment:\n      AUTOHEAL_CONTAINER_LABEL: autoheal-app\n    image: willfarrell/autoheal:latest\n    network_mode: none\n    restart: always\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n#### Optional Container Labels\n|`autoheal.stop.timeout=20`            |Per containers override for stop timeout seconds during restart|\n| --- | --- |\n\n## Environment Defaults\n|Variable                              |Description|\n| --- | --- |\n|`AUTOHEAL_CONTAINER_LABEL=autoheal`   |set to existing label name that has the value `true`|\n|`AUTOHEAL_INTERVAL=5`                 |check every 5 seconds|\n|`AUTOHEAL_START_PERIOD=0`             |wait 0 seconds before first health check|\n|`AUTOHEAL_DEFAULT_STOP_TIMEOUT=10`    |Docker waits max 10 seconds (the Docker default) for a container to stop before killing during restarts (container overridable via label, see below)|\n|`AUTOHEAL_ONLY_MONITOR_RUNNING=false` |All containers monitored by default. Set this to true to only monitor running containers. This will result in Paused contaners being ignored.|\n|`DOCKER_SOCK=/var/run/docker.sock`    |Unix socket for curl requests to Docker API|\n|`CURL_TIMEOUT=30`                     |--max-time seconds for curl requests to Docker API|\n|`WEBHOOK_URL=\"\"`                      |post message to the webhook if a container was restarted (or restart failed)|\n\n## Testing (building locally)\n```bash\ndocker buildx build -t autoheal .\n\ndocker run -d \\\n    -e AUTOHEAL_CONTAINER_LABEL=all \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    autoheal\n```\n"
        },
        {
          "name": "docker-entrypoint",
          "type": "blob",
          "size": 5.380859375,
          "content": "#!/usr/bin/env sh\n\nset -e\n# shellcheck disable=2039\nset -o pipefail\n\nDOCKER_SOCK=${DOCKER_SOCK:-/var/run/docker.sock}\nUNIX_SOCK=\"\"\nCURL_TIMEOUT=${CURL_TIMEOUT:-30}\nWEBHOOK_URL=${WEBHOOK_URL:-\"\"}\nWEBHOOK_JSON_KEY=${WEBHOOK_JSON_KEY:-\"text\"}\nAPPRISE_URL=${APPRISE_URL:-\"\"}\n\n# only use unix domain socket if no TCP endpoint is defined\ncase \"${DOCKER_SOCK}\" in\n  \"tcp://\"*) HTTP_ENDPOINT=\"$(echo ${DOCKER_SOCK} | sed 's#tcp://#http://#')\"\n             ;;\n  \"tcps://\"*) HTTP_ENDPOINT=\"$(echo ${DOCKER_SOCK} | sed 's#tcps://#https://#')\"\n             CA=\"--cacert /certs/ca.pem\"\n             CLIENT_KEY=\"--key /certs/client-key.pem\"\n             CLIENT_CERT=\"--cert /certs/client-cert.pem\"\n             ;;\n  *)         HTTP_ENDPOINT=\"http://localhost\"\n             UNIX_SOCK=\"--unix-socket ${DOCKER_SOCK}\"\n             ;;\nesac\n\nAUTOHEAL_CONTAINER_LABEL=${AUTOHEAL_CONTAINER_LABEL:-autoheal}\nAUTOHEAL_START_PERIOD=${AUTOHEAL_START_PERIOD:-0}\nAUTOHEAL_INTERVAL=${AUTOHEAL_INTERVAL:-5}\nAUTOHEAL_DEFAULT_STOP_TIMEOUT=${AUTOHEAL_DEFAULT_STOP_TIMEOUT:-10}\nAUTOHEAL_ONLY_MONITOR_RUNNING=${AUTOHEAL_ONLY_MONITOR_RUNNING:-false}\n\necho AUTOHEAL_CONTAINER_LABEL=${AUTOHEAL_CONTAINER_LABEL}\necho AUTOHEAL_START_PERIOD=${AUTOHEAL_START_PERIOD}\necho AUTOHEAL_INTERVAL=${AUTOHEAL_INTERVAL}\necho AUTOHEAL_DEFAULT_STOP_TIMEOUT=${AUTOHEAL_DEFAULT_STOP_TIMEOUT}\necho AUTOHEAL_ONLY_MONITOR_RUNNING=${AUTOHEAL_ONLY_MONITOR_RUNNING}\n\ndocker_curl() {\n  curl --max-time \"${CURL_TIMEOUT}\" --no-buffer -s \\\n  ${CA} ${CLIENT_KEY} ${CLIENT_CERT} \\\n  ${UNIX_SOCK} \\\n  \"$@\"\n}\n\n# shellcheck disable=2039\nget_container_info() {\n  local label_filter\n  local running_filter\n  local url\n\n  # Set container selector\n  if [ \"$AUTOHEAL_CONTAINER_LABEL\" = \"all\" ]\n  then\n    label_filter=\"\"\n  else\n    label_filter=\",\\\"label\\\":\\[\\\"${AUTOHEAL_CONTAINER_LABEL}=true\\\"\\]\"\n  fi\n  if [ \"$AUTOHEAL_ONLY_MONITOR_RUNNING\" = false ]\n  then\n    running_filter=\"\"\n  else\n    running_filter=\",\\\"status\\\":\\[\\\"running\\\"\\]\"\n  fi\n  url=\"${HTTP_ENDPOINT}/containers/json?filters=\\{\\\"health\\\":\\[\\\"unhealthy\\\"\\]${label_filter}${running_filter}\\}\"\n  docker_curl \"$url\"\n}\n\n# shellcheck disable=2039\nrestart_container() {\n  local container_id=\"$1\"\n  local timeout=\"$2\"\n\n  docker_curl -f -X POST \"${HTTP_ENDPOINT}/containers/${container_id}/restart?t=${timeout}\"\n}\n\nnotify_webhook() {\n  local text=\"$@\"\n\n  if [ -n \"$WEBHOOK_URL\" ]\n  then\n    # execute webhook requests as background process to prevent healer from blocking\n    curl -s -X POST -H \"Content-type: application/json\" -d \"$(generate_webhook_payload $text)\"  $WEBHOOK_URL\n  fi\n\n  if [ -n \"$APPRISE_URL\" ]\n  then\n    # execute webhook requests as background process to prevent healer from blocking\n    curl -s -X POST -H \"Content-type: application/json\" -d \"$(generate_apprise_payload $text)\"  $APPRISE_URL\n  fi\n}\n\nnotify_post_restart_script() {\n  if [ -n \"$POST_RESTART_SCRIPT\" ]\n  then\n    # execute post restart script as background process to prevent healer from blocking\n    $POST_RESTART_SCRIPT \"$@\" &\n  fi\n}\n\n# https://towardsdatascience.com/proper-ways-to-pass-environment-variables-in-json-for-curl-post-f797d2698bf3\ngenerate_webhook_payload() {\n  local text=\"$@\"\n  cat <<EOF\n{\n  \"$WEBHOOK_JSON_KEY\":\"$text\"\n}\nEOF\n}\n\ngenerate_apprise_payload() {\n  local text=\"$@\"\n  cat <<EOF\n{\n  \"title\":\"Autoheal\",\n  \"body\":\"$text\"\n}\nEOF\n}\n\n# SIGTERM-handler\nterm_handler() {\n  exit 143  # 128 + 15 -- SIGTERM\n}\n\n# shellcheck disable=2039\ntrap 'kill $$; term_handler' SIGTERM\n\nif [ \"$1\" = \"autoheal\" ]\nthen\n  if [ -n \"$UNIX_SOCK\" ] && ! [ -S \"$DOCKER_SOCK\" ]\n  then\n    echo \"unix socket is currently not available\" >&2\n    exit 1\n  fi\n  # Delayed startup\n  if [ \"$AUTOHEAL_START_PERIOD\" -gt 0 ]\n  then\n  echo \"Monitoring containers for unhealthy status in $AUTOHEAL_START_PERIOD second(s)\"\n    sleep \"$AUTOHEAL_START_PERIOD\" &\n    wait $!\n  fi\n\n  while true\n  do\n    STOP_TIMEOUT=\".Labels[\\\"autoheal.stop.timeout\\\"] // $AUTOHEAL_DEFAULT_STOP_TIMEOUT\"\n    get_container_info | \\\n      jq -r \".[] | select(.Labels[\\\"autoheal\\\"] != \\\"False\\\") | foreach . as \\$CONTAINER([];[]; \\$CONTAINER | .Id, .Names[0], .State, ${STOP_TIMEOUT})\" | \\\n      while read -r CONTAINER_ID && read -r CONTAINER_NAME && read -r CONTAINER_STATE && read -r TIMEOUT\n    do\n      # shellcheck disable=2039\n      CONTAINER_SHORT_ID=${CONTAINER_ID:0:12}\n      DATE=$(date +%d-%m-%Y\" \"%H:%M:%S)\n\n      if [ \"$CONTAINER_NAME\" = \"null\" ]\n      then\n        echo \"$DATE Container name of (${CONTAINER_SHORT_ID}) is null, which implies container does not exist - don't restart\" >&2\n      elif [ \"$CONTAINER_STATE\" = \"restarting\" ]\n      then\n        echo \"$DATE Container $CONTAINER_NAME (${CONTAINER_SHORT_ID}) found to be restarting - don't restart\"\n      else\n        echo \"$DATE Container $CONTAINER_NAME (${CONTAINER_SHORT_ID}) found to be unhealthy - Restarting container now with ${TIMEOUT}s timeout\"\n        if ! restart_container \"$CONTAINER_ID\" \"$TIMEOUT\"\n        then\n          echo \"$DATE Restarting container $CONTAINER_SHORT_ID failed\" >&2\n          notify_webhook \"Container ${CONTAINER_NAME:1} (${CONTAINER_SHORT_ID}) found to be unhealthy. Failed to restart the container!\" &\n        else\n          notify_webhook \"Container ${CONTAINER_NAME:1} (${CONTAINER_SHORT_ID}) found to be unhealthy. Successfully restarted the container!\" &\n        fi\n        notify_post_restart_script \"$CONTAINER_NAME\" \"$CONTAINER_SHORT_ID\" \"$CONTAINER_STATE\" \"$TIMEOUT\" &\n      fi\n    done\n    sleep \"$AUTOHEAL_INTERVAL\" &\n    wait $!\n  done\n\nelse\n  exec \"$@\"\nfi\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}