{
  "metadata": {
    "timestamp": 1736568407083,
    "page": 351,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "agkozak/zsh-z",
      "stars": 2077,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.04296875,
          "content": "*.zwc\n.*.swp\n._zplugin/\n._zinit/\nzsdoc/data\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "MIT License\n\nCopyright (c) 2018-2024 Alexandros Kozak\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.75,
          "content": "# Zsh-z\n\n[![MIT License](img/mit_license.svg)](https://opensource.org/licenses/MIT)\n![Zsh version 4.3.11 and higher](img/zsh_4.3.11_plus.svg)\n[![GitHub stars](https://img.shields.io/github/stars/agkozak/zsh-z.svg)](https://github.com/agkozak/zsh-z/stargazers)\n\n![Zsh-z demo](img/demo.gif)\n\nZsh-z is a command-line tool that allows you to jump quickly to directories that you have visited frequently or recently -- but most often a combination of the two (a concept known as [\"frecency\"](https://en.wikipedia.org/wiki/Frecency)). It works by keeping track of when you go to directories and how much time you spend in them. Based on this data, it predicts where you want to go when you type a partial string. For example, `z src` might take you to `~/src/zsh`. `z zsh` might also get you there, and `z c/z` might prove to be even more specific -- it all depends on your habits and how long you have been using Zsh-z to build up a database. After using Zsh-z for a little while, you will get to where you want to be by typing considerably less than you would need to if you were using `cd`.\n\nZsh-z is a native Zsh port of [`rupa/z`](https://github.com/rupa/z), a tool written for `bash` and Zsh that uses embedded `awk` scripts to do the heavy lifting. `rupa/z` was my most used command-line tool for a couple of years. I decided to translate it, `awk` parts and all, into pure Zsh script, to see if by eliminating calls to external tools (`awk`, `sort`, `date`, `sed`, `mv`, `rm`, and `chown`) and reducing forking through subshells I could make it faster. The performance increase is impressive, particularly on systems where forking is slow, such as Cygwin, MSYS2, and WSL. I have found that in those environments, switching directories using Zsh-z can be over 100% faster than it is using `rupa/z`.\n\nThere is also a significant stability improvement. Race conditions have always been a problem with `rupa/z`, and users of that utility occasionally lose their `~/.z` databases. By having Zsh-z only use Zsh (`rupa/z` uses a hybrid shell code standard that works on `bash` as well), I have been able to implement a `zsh/system`-based file-locking mechanism similar to [the one @mafredri once proposed for `rupa/z`](https://github.com/rupa/z/pull/199). It is now nearly impossible to crash the database.\n\nThere are other, smaller improvements which I document below in [Improvements and Fixes](#improvements-and-fixes). For instance, tab completions are now sorted by frecency by default rather than alphabetically (the latter behavior can be restored if you like it -- [see below](#settings)).\n\nZsh-z is a drop-in replacement for `rupa/z` and will, by default, use the same database (`~/.z`, or whatever database file you specify), so you can go on using `rupa/z` when you launch `bash`.\n\n## Table of Contents\n- [News](#news)\n- [Installation](#installation)\n- [Command Line Options](#command-line-options)\n- [Settings](#settings)\n- [Case Sensitivity](#case-sensitivity)\n- [`ZSHZ_UNCOMMON`](#zshz_uncommon)\n- [Making `--add` work for you](#making---add-work-for-you)\n- [Other Improvements and Fixes](#other-improvements-and-fixes)\n- [Migrating from Other Tools](#migrating-from-other-tools)\n- [`COMPLETE_ALIASES`](#complete_aliases)\n- [Known Bugs](#known-bugs)\n\n## News\n\n<details>\n    <summary>Here are the latest features and updates.</summary>\n\n- August 24, 2023\n    + Zsh-z will now run when `setopt NO_UNSET` has been enabled (props @ntninja).\n- August 23, 2023\n    + Better logic for loading `zsh/files` (props @z0rc).\n- August 2, 2023\n    + Zsh-z still uses the `zsh/files` module when possible but will fall back on the standard `chown`, `mv`, and `rm` commands in its absence.\n- April 27, 2023\n    + Zsh-z now allows the user to specify the directory-changing command using the `ZSHZ_CD` environment variable (default: `builtin cd`; props @basnijholt).\n- January 27, 2023\n    + If the database file directory specified by `ZSHZ_DATA` or `_Z_DATA` does not already exist, create it (props @mattmc3).\n- June 29, 2022\n    + Zsh-z is less likely to leave temporary files sitting around (props @mafredri).\n- June 27, 2022\n    + A bug was fixed which was preventing paths with spaces in them from being updated ([#61](https://github.com/agkozak/zsh-z/issues/61)).\n    + If writing to the temporary database file fails, the database will not be clobbered (props @mafredri).\n- December 19, 2021\n    + ZSH-z will now display tildes for `HOME` during completion when `ZSHZ_TILDE=1` has been set.\n- November 11, 2021\n    + A bug was fixed which was preventing ranks from being incremented.\n    + `--add` has been made to work with relative paths and has been documented for the user.\n- October 14, 2021\n    + Completions were being sorted alphabetically, rather than by rank; this error has been fixed.\n- September 25, 2021\n    + Orthographical change: \"Zsh,\" not \"ZSH.\"\n- September 23, 2021\n    + `z -xR` will now remove a directory *and its subdirectories* from the database.\n    + `z -x` and `z -xR` can now take an argument; without one, `PWD` is assumed.\n- September 7, 2021\n    + Fixed the unload function so that it removes the `$ZSHZ_CMD` alias (default: `z`).\n- August 27, 2021\n    + Using `print -v ... -f` instead of `print -v` to work around longstanding bug in Zsh involving `print -v` and multibyte strings.\n- August 13, 2021\n    + Fixed the explanation string printed during completion so that it may be formatted with `zstyle`.\n    + Zsh-z now declares `ZSHZ_EXCLUDE_DIRS` as an array with unique elements so that you do not have to.\n- July 29, 2021\n    + Temporarily disabling the use of `print -v`, which was mangling CJK multibyte strings.\n- July 27, 2021\n    + Internal escaping of path names now works with older versions of ZSH.\n    + Zsh-z now detects and discards any incomplete or incorrectly formatted database entries.\n- July 10, 2021\n    + Setting `ZSHZ_TRAILING_SLASH=1` makes it so that a search pattern ending in `/` can match the end of a path; e.g. `z foo/` can match `/path/to/foo`.\n- June 25, 2021\n    + Setting `ZSHZ_TILDE=1` displays the `HOME` directory as `~`.\n- May 7, 2021\n    + Setting `ZSHZ_ECHO=1` will cause Zsh-z to display the new path when you change directories.\n    + Better escaping of path names to deal paths containing the characters ``\\`()[]``.\n- February 15, 2021\n    + Ranks are displayed the way `rupa/z` now displays them, i.e. as large integers. This should help Zsh-z to integrate with other tools.\n- January 31, 2021\n    + Zsh-z is now efficient enough that, on MSYS2 and Cygwin, it is faster to run it in the foreground than it is to fork a subshell for it.\n    + `_zshz_precmd` simply returns if `PWD` is `HOME` or in `ZSH_EXCLUDE_DIRS`, rather than waiting for `zshz` to do that.\n- January 17, 2021\n    + Made sure that the `PUSHD_IGNORE_DUPS` option is respected.\n- January 14, 2021\n    + The `z -h` help text now breaks at spaces.\n    + `z -l` was not working for Zsh version < 5.\n- January 11, 2021\n    + Major refactoring of the code.\n    + `z -lr` and `z -lt` work as expected.\n    + `EXTENDED_GLOB` has been disabled within the plugin to accommodate old-fashioned Windows directories with names such as `Progra~1`.\n    + Removed `zshelldoc` documentation.\n- January 6, 2021\n    + I have corrected the frecency routine so that it matches `rupa/z`'s math, but for the present, Zsh-z will continue to display ranks as 1/10000th of what they are in `rupa/z` -- [they had to multiply theirs by 10000](https://github.com/rupa/z/commit/f1f113d9bae9effaef6b1e15853b5eeb445e0712) to work around `bash`'s inadequacies at dealing with decimal fractions.\n- January 5, 2021\n    + If you try `z foo`, and `foo` is not in the database but `${PWD}/foo` is a valid directory, Zsh-z will `cd` to it.\n- December 22, 2020\n    + `ZSHZ_CASE`: when set to `ignore`, pattern matching is case-insensitive; when set to `smart`, patterns are matched case-insensitively when they are all lowercase and case-sensitively when they have uppercase characters in them (a behavior very much like Vim's `smartcase` setting).\n    + `ZSHZ_KEEP_DIRS` is an array of directory names that should not be removed from the database, even if they are not currently available (useful when a drive is not always mounted).\n    + Symlinked database files were having their symlinks overwritten; this bug has been fixed.\n\n</details>\n\n## Installation\n\n### General observations\n\nThis plugin can be installed simply by putting the various files in a directory together and by sourcing `zsh-z.plugin.zsh` in your `.zshrc`:\n\n    source /path/to/zsh-z.plugin.zsh\n\nFor tab completion to work, `_zshz` *must* be in the same directory as `zsh-z.plugin.zsh`, and you will want to have loaded `compinit`. The frameworks handle this themselves. If you are not using a framework, put\n\n    autoload -U compinit; compinit\n\nin your `.zshrc` somewhere below where you source `zsh-z.plugin.zsh`.\n\nIf you add\n\n    zstyle ':completion:*' menu select\n\nto your `.zshrc`, your completion menus will look very nice. This `zstyle` invocation should work with any of the frameworks below as well.\n\n### For [antigen](https://github.com/zsh-users/antigen) users\n\nAdd the line\n\n    antigen bundle agkozak/zsh-z\n\nto your `.zshrc`, somewhere above the line that says `antigen apply`.\n\n### For [Oh My Zsh](http://ohmyz.sh/) users\n\nZsh-z is now included as part of Oh My Zsh! As long as you are using an up-to-date installation of Oh My Zsh, you can activate Zsh-z simply by adding `z` to your `plugins` array in your `.zshrc`, e.g.,\n\n    plugins=( git z )\n\nIt is as simple as that.\n\nIf, however, you prefer always to use the latest version of Zsh-z from the `agkozak/zsh-z` repo, you may install it thus:\n\n    git clone https://github.com/agkozak/zsh-z ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-z\n\nand activate it by adding `zsh-z` to the line of your `.zshrc` that specifies `plugins=()`, e.g., `plugins=( git zsh-z )`.\n\n### For [prezto](https://github.com/sorin-ionescu/prezto) users\n\nExecute the following command:\n\n    git clone https://github.com/agkozak/zsh-z.git ~/.zprezto-contrib/zsh-z\n\nThen edit your `~/.zpreztorc` file. Make sure the line that says\n\n    zstyle ':prezto:load' pmodule-dirs $HOME/.zprezto-contrib\n\nis uncommented. Then find the section that specifies which modules are to be loaded; it should look something like this:\n\n    zstyle ':prezto:load' pmodule \\\n        'environment' \\\n        'terminal' \\\n        'editor' \\\n        'history' \\\n        'directory' \\\n        'spectrum' \\\n        'utility' \\\n        'completion' \\\n        'prompt'\n\nAdd a backslash to the end of the last line add `'zsh-z'` to the list, e.g.,\n\n    zstyle ':prezto:load' pmodule \\\n        'environment' \\\n        'terminal' \\\n        'editor' \\\n        'history' \\\n        'directory' \\\n        'spectrum' \\\n        'utility' \\\n        'completion' \\\n        'prompt' \\\n        'zsh-z'\n\nThen relaunch `zsh`.\n\n### For [zcomet](https://github.com/agkozak/zcomet) users\n        \nSimply add\n\n    zcomet load agkozak/zsh-z\n\nto your `.zshrc` (below where you source `zcomet.zsh` and above where you run `zcomet compinit`).\n\n### For [zgen](https://github.com/tarjoilija/zgen) users\n\nAdd the line\n\n    zgen load agkozak/zsh-z\n\nsomewhere above the line that says `zgen save`. Then run\n\n    zgen reset\n    zsh\n\nto refresh your init script.\n\n### For [Zim](https://github.com/zimfw/zimfw)\n\nAdd the following line to your `.zimrc`:\n\n    zmodule https://github.com/agkozak/zsh-z\n\nThen run\n\n    zimfw install\n\nand restart your shell.\n\n### For [Zinit](https://github.com/zdharma-continuum/zinit) users\n\nAdd the line\n\n    zinit load agkozak/zsh-z\n\nto your `.zshrc`.\n\nZsh-z supports `zinit`'s `unload` feature; just run `zinit unload agkozak/zsh-z` to restore the shell to its state before Zsh-z was loaded.\n\n### For [Znap](https://github.com/marlonrichert/zsh-snap) users\n\nAdd the line\n\n    znap source agkozak/zsh-z\n\nsomewhere below the line where you `source` Znap itself.\n\n### For [zplug](https://github.com/zplug/zplug) users\n\nAdd the line\n\n    zplug \"agkozak/zsh-z\"\n\nsomewhere above the line that says `zplug load`. Then run\n\n    zplug install\n    zplug load\n\nto install Zsh-z.\n\n## Command Line Options\n\n- `--add` Add a directory to the database\n- `-c`    Only match subdirectories of the current directory\n- `-e`    Echo the best match without going to it\n- `-h`    Display help\n- `-l`    List all matches without going to them\n- `-r`    Match by rank (i.e. how much time you spend in directories)\n- `-t`    Time -- match by how recently you have been to directories\n- `-x`    Remove a directory (by default, the current directory) from the database\n- `-xR`   Remove a directory (by default, the current directory) and its subdirectories from the database\n\n## Settings\n\nZsh-z has environment variables (they all begin with `ZSHZ_`) that change its behavior if you set them. You can also keep your old ones if you have been using `rupa/z` (whose environment variables begin with `_Z_`).\n\n* `ZSHZ_CMD` changes the command name (default: `z`)\n* `ZSHZ_CD` specifies the default directory-changing command (default: `builtin cd`)\n* `ZSHZ_COMPLETION` can be `'frecent'` (default) or `'legacy'`, depending on whether you want your completion results sorted according to frecency or simply sorted alphabetically\n* `ZSHZ_DATA` changes the database file (default: `~/.z`)\n* `ZSHZ_ECHO` displays the new path name when changing directories (default: `0`)\n* `ZSHZ_EXCLUDE_DIRS` is an array of directories to keep out of the database (default: empty)\n* `ZSHZ_KEEP_DIRS` is an array of directories that should not be removed from the database, even if they are not currently available (useful when a drive is not always mounted) (default: empty)\n* `ZSHZ_MAX_SCORE` is the maximum combined score the database entries can have before they begin to age and potentially drop out of the database (default: 9000)\n* `ZSHZ_NO_RESOLVE_SYMLINKS` prevents symlink resolution (default: `0`)\n* `ZSHZ_OWNER` allows usage when in `sudo -s` mode (default: empty)\n* `ZSHZ_TILDE` displays the name of the `HOME` directory as a `~` (default: `0`)\n* `ZSHZ_TRAILING_SLASH` makes it so that a search pattern ending in `/` can match the final element in a path; e.g., `z foo/` can match `/path/to/foo` (default: `0`)\n* `ZSHZ_UNCOMMON` changes the logic used to calculate the directory jumped to; [see below](#zshz_uncommon`) (default: `0`)\n\n## Case sensitivity\n\nThe default behavior of Zsh-z is to try to find a case-sensitive match. If there is none, then Zsh-z tries to find a case-insensitive match.\n\nSome users prefer simple case-insensitivity; this behavior can be enabled by setting\n\n    ZSHZ_CASE=ignore\n\nIf you like Vim's `smartcase` setting, where lowercase patterns are case-insensitive while patterns with any uppercase characters are treated case-sensitively, try setting\n\n    ZSHZ_CASE=smart\n\n## `ZSHZ_UNCOMMON`\n\nA common complaint about the default behavior of `rupa/z` and Zsh-z involves \"common prefixes.\" If you type `z code` and the best matches, in increasing order, are\n\n    /home/me/code/foo\n    /home/me/code/bar\n    /home/me/code/bat\n\nZsh-z will see that all possible matches share a common prefix and will send you to that directory -- `/home/me/code` -- which is often a desirable result. But if the possible matches are\n\n    /home/me/.vscode/foo\n    /home/me/code/foo\n    /home/me/code/bar\n    /home/me/code/bat\n\nthen there is no common prefix. In this case, `z code` will simply send you to the highest-ranking match, `/home/me/code/bat`.\n\nYou may enable an alternate, experimental behavior by setting `ZSHZ_UNCOMMON=1`. If you do that, Zsh-z will not jump to a common prefix, even if one exists. Instead, it chooses the highest-ranking match -- but it drops any subdirectories that do not include the search term. So if you type `z bat` and `/home/me/code/bat` is the best match, that is exactly where you will end up. If, however, you had typed `z code` and the best match was also `/home/me/code/bat`, you would have ended up in `/home/me/code` (because `code` was what you had searched for). This feature is still in development, and feedback is welcome.\n\n## Making `--add` Work for You\n\nZsh-z internally uses the `--add` option to add paths to its database. @zachriggle pointed out to me that users might want to use `--add` themselves, so I have altered it a little to make it more user-friendly.\n\nA good example might involve a directory tree that has Git repositories within it. The working directories could be added to the Zsh-z database as a batch with\n\n    for i in $(find $PWD -maxdepth 3 -name .git -type d); do\n      z --add ${i:h}\n    done\n\n(As a Zsh user, I tend to use `**` instead of `find`, but it is good to see how deep your directory trees go before doing that.)\n\n## Other Improvements and Fixes\n\n* `z -x` works, with the help of `chpwd_functions`.\n* Zsh-z is compatible with Solaris.\n* Zsh-z uses the \"new\" `zshcompsys` completion system instead of the old `compctl` one.\n* No error message is displayed when the database file has not yet been created.\n* Special characters (e.g., `[`) in directory names are now supported.\n* If `z -l` returns only one match, a common root is not printed.\n* Exit status codes are more logical.\n* Completions now work with options `-c`, `-r`, and `-t`.\n* If `~/foo` and `~/foob` are matches, `~/foo` is no longer considered the common root. Only a common parent directory can be a common root.\n* `z -x` and the new, recursive `z -xR` can now accept an argument so that you can remove directories other than `PWD` from the database.\n\n## Migrating from Other Tools\n\nZsh-z's database format is identical to that of `rupa/z`. You may switch freely between the two tools (I still use `rupa/z` for `bash`). `fasd` also uses that database format, but it stores it by default in `~/.fasd`, so you will have to `cp ~/.fasd ~/.z` if you want to use your old directory history.\n\nIf you are coming to Zsh-z (or even to the original `rupa/z`, for that matter) from `autojump`, try using my [`jumpstart-z`](https://github.com/agkozak/jumpstart-z/blob/master/jumpstart-z) tool to convert your old database to the Zsh-z format, or simply run\n\n    awk -F \"\\t\" '{printf(\"%s|%0.f|%s\\n\", $2, $1, '\"$(date +%s)\"')}' < /path/to/autojump.txt > ~/.z\n\n## `COMPLETE_ALIASES`\n\n`z`, or any alternative you set up using `$ZSH_CMD` or `$_Z_CMD`, is an alias. `setopt COMPLETE_ALIASES` divorces the tab completion for aliases from the underlying commands they invoke, so if you enable `COMPLETE_ALIASES`, tab completion for Zsh-z will be broken. You can get it working again, however, by adding under\n\n    setopt COMPLETE_ALIASES\n\nthe line\n\n    compdef _zshz ${ZSHZ_CMD:-${_Z_CMD:-z}}\n\nThat will re-bind `z` or the command of your choice to the underlying Zsh-z function.\n\n## Known Bug\nIt is possible to run a completion on a string with spaces in it, e.g., `z us bi<TAB>` might take you to `/usr/local/bin`. This works, but as things stand, after the completion the command line reads\n\n    z us /usr/local/bin.\n\nYou get where you want to go, but the detritus on the command line is annoying. This is also a problem in `rupa/z`, but I am keen on eventually eliminating this glitch. Advice is welcome.\n"
        },
        {
          "name": "_zshz",
          "type": "blob",
          "size": 2.5849609375,
          "content": "#compdef zshz ${ZSHZ_CMD:-${_Z_CMD:-z}}\n#\n# Zsh-z - jump around with Zsh - A native Zsh version of z without awk, sort,\n# date, or sed\n#\n# https://github.com/agkozak/zsh-z\n#\n# Copyright (c) 2018-2023 Alexandros Kozak\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n# z (https://github.com/rupa/z) is copyright (c) 2009 rupa deadwyler and\n# licensed under the WTFPL license, Version 2.a\n#\n# shellcheck shell=ksh\n\n############################################################\n# Zsh-z COMPLETIONS\n############################################################\nemulate -L zsh\n(( ZSHZ_DEBUG )) &&\n  setopt LOCAL_OPTIONS WARN_CREATE_GLOBAL NO_WARN_NESTED_VAR 2> /dev/null\n\n# TODO: This routine currently reproduces z's feature of allowing spaces to be\n# used as wildcards in completions, so that\n#\n#   z us lo bi\n#\n# can expand to\n#\n#   z /usr/local/bin\n#\n# but it also reproduces z's buggy display on the commandline, viz.\n#\n#   z us lo /usr/local/bin\n#\n# Address.\n\nlocal completions expl completion\nlocal -a completion_list\n\ncompletions=$(zshz --complete ${(@)words:1})\n[[ -z $completions ]] && return 1\n\nfor completion in ${(f)completions[@]}; do\n  if (( ZSHZ_TILDE )) && [[ $completion == ${HOME}* ]]; then\n    completion=\"~${(q)${completion#${HOME}}}\"\n  else\n    completion=\"${(q)completion}\"\n  fi\n  completion_list+=( $completion )\ndone\n\n_description -V completion_list expl 'directories'\n\nif [[ $ZSHZ_COMPLETION == 'legacy' ]]; then\n  compadd \"${expl[@]}\" -QU -- \"${completion_list[@]}\"\nelse\n  compadd \"${expl[@]}\" -QU -V zsh-z -- \"${completion_list[@]}\"\nfi\n\ncompstate[insert]=menu\n\nreturn 0\n\n# vim: ft=zsh:fdm=indent:ts=2:et:sts=2:sw=2:\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "zsh-z.plugin.zsh",
          "type": "blob",
          "size": 30.92578125,
          "content": "################################################################################\n# Zsh-z - jump around with Zsh - A native Zsh version of z without awk, sort,\n# date, or sed\n#\n# https://github.com/agkozak/zsh-z\n#\n# Copyright (c) 2018-2024 Alexandros Kozak\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n# z (https://github.com/rupa/z) is copyright (c) 2009 rupa deadwyler and\n# licensed under the WTFPL license, Version 2.\n#\n# Zsh-z maintains a jump-list of the directories you actually use.\n#\n# INSTALL:\n#   * put something like this in your .zshrc:\n#       source /path/to/zsh-z.plugin.zsh\n#   * cd around for a while to build up the database\n#\n# USAGE:\n#   * z foo       cd to the most frecent directory matching foo\n#   * z foo bar   cd to the most frecent directory matching both foo and bar\n#                   (e.g. /foo/bat/bar/quux)\n#   * z -r foo    cd to the highest ranked directory matching foo\n#   * z -t foo    cd to most recently accessed directory matching foo\n#   * z -l foo    List matches instead of changing directories\n#   * z -e foo    Echo the best match without changing directories\n#   * z -c foo    Restrict matches to subdirectories of PWD\n#   * z -x        Remove a directory (default: PWD) from the database\n#   * z -xR       Remove a directory (default: PWD) and its subdirectories from\n#                   the database\n#\n# ENVIRONMENT VARIABLES:\n#\n#   ZSHZ_CASE -> if `ignore', pattern matching is case-insensitive; if `smart',\n#     pattern matching is case-insensitive only when the pattern is all\n#     lowercase\n#   ZSHZ_CD -> the directory-changing command that is used (default: builtin cd)\n#   ZSHZ_CMD -> name of command (default: z)\n#   ZSHZ_COMPLETION -> completion method (default: 'frecent'; 'legacy' for\n#     alphabetic sorting)\n#   ZSHZ_DATA -> name of datafile (default: ~/.z)\n#   ZSHZ_EXCLUDE_DIRS -> array of directories to exclude from your database\n#     (default: empty)\n#   ZSHZ_KEEP_DIRS -> array of directories that should not be removed from the\n#     database, even if they are not currently available (default: empty)\n#   ZSHZ_MAX_SCORE -> maximum combined score the database entries can have\n#     before beginning to age (default: 9000)\n#   ZSHZ_NO_RESOLVE_SYMLINKS -> '1' prevents symlink resolution\n#   ZSHZ_OWNER -> your username (if you want use Zsh-z while using sudo -s)\n#   ZSHZ_UNCOMMON -> if 1, do not jump to \"common directories,\" but rather drop\n#     subdirectories based on what the search string was (default: 0)\n################################################################################\n\nautoload -U is-at-least\n\nif ! is-at-least 4.3.11; then\n  print \"Zsh-z requires Zsh v4.3.11 or higher.\" >&2 && exit\nfi\n\n############################################################\n# The help message\n#\n# Globals:\n#   ZSHZ_CMD\n############################################################\n_zshz_usage() {\n  print \"Usage: ${ZSHZ_CMD:-${_Z_CMD:-z}} [OPTION]... [ARGUMENT]\nJump to a directory that you have visited frequently or recently, or a bit of both, based on the partial string ARGUMENT.\n\nWith no ARGUMENT, list the directory history in ascending rank.\n\n  --add Add a directory to the database\n  -c    Only match subdirectories of the current directory\n  -e    Echo the best match without going to it\n  -h    Display this help and exit\n  -l    List all matches without going to them\n  -r    Match by rank\n  -t    Match by recent access\n  -x    Remove a directory from the database (by default, the current directory)\n  -xR   Remove a directory and its subdirectories from the database (by default, the current directory)\" |\n    fold -s -w $COLUMNS >&2\n}\n\n# Load zsh/datetime module, if necessary\n(( ${+EPOCHSECONDS} )) || zmodload zsh/datetime\n\n# Global associative array for internal use\ntypeset -gA ZSHZ\n\n# Fallback utilities in case Zsh lacks zsh/files (as is the case with MobaXterm)\nZSHZ[CHOWN]='chown'\nZSHZ[MV]='mv'\nZSHZ[RM]='rm'\n# Try to load zsh/files utilities\nif [[ ${builtins[zf_chown]-} != 'defined' ||\n      ${builtins[zf_mv]-}    != 'defined' ||\n      ${builtins[zf_rm]-}    != 'defined' ]]; then\n  zmodload -F zsh/files b:zf_chown b:zf_mv b:zf_rm &> /dev/null\nfi\n# Use zsh/files, if it is available\n[[ ${builtins[zf_chown]-} == 'defined' ]] && ZSHZ[CHOWN]='zf_chown'\n[[ ${builtins[zf_mv]-} == 'defined' ]] && ZSHZ[MV]='zf_mv'\n[[ ${builtins[zf_rm]-} == 'defined' ]] && ZSHZ[RM]='zf_rm'\n\n# Load zsh/system, if necessary\n[[ ${modules[zsh/system]-} == 'loaded' ]] || zmodload zsh/system &> /dev/null\n\n# Make sure ZSHZ_EXCLUDE_DIRS has been declared so that other scripts can\n# simply append to it\n(( ${+ZSHZ_EXCLUDE_DIRS} )) || typeset -gUa ZSHZ_EXCLUDE_DIRS\n\n# Determine if zsystem flock is available\nzsystem supports flock &> /dev/null && ZSHZ[USE_FLOCK]=1\n\n# Determine if `print -v' is supported\nis-at-least 5.3.0 && ZSHZ[PRINTV]=1\n\n############################################################\n# The Zsh-z Command\n#\n# Globals:\n#   ZSHZ\n#   ZSHZ_CASE\n#   ZSHZ_CD\n#   ZSHZ_COMPLETION\n#   ZSHZ_DATA\n#   ZSHZ_DEBUG\n#   ZSHZ_EXCLUDE_DIRS\n#   ZSHZ_KEEP_DIRS\n#   ZSHZ_MAX_SCORE\n#   ZSHZ_OWNER\n#\n# Arguments:\n#   $* Command options and arguments\n############################################################\nzshz() {\n\n  # Don't use `emulate -L zsh' - it breaks PUSHD_IGNORE_DUPS\n  setopt LOCAL_OPTIONS NO_KSH_ARRAYS NO_SH_WORD_SPLIT EXTENDED_GLOB UNSET\n  (( ZSHZ_DEBUG )) && setopt LOCAL_OPTIONS WARN_CREATE_GLOBAL\n\n  local REPLY\n  local -a lines\n\n  # Allow the user to specify a custom datafile in $ZSHZ_DATA (or legacy $_Z_DATA)\n  local custom_datafile=\"${ZSHZ_DATA:-$_Z_DATA}\"\n\n  # If a datafile was provided as a standalone file without a directory path\n  # print a warning and exit\n  if [[ -n ${custom_datafile} && ${custom_datafile} != */* ]]; then\n    print \"ERROR: You configured a custom Zsh-z datafile (${custom_datafile}), but have not specified its directory.\" >&2\n    exit\n  fi\n\n  # If the user specified a datafile, use that or default to ~/.z\n  # If the datafile is a symlink, it gets dereferenced\n  local datafile=${${custom_datafile:-$HOME/.z}:A}\n\n  # If the datafile is a directory, print a warning and exit\n  if [[ -d $datafile ]]; then\n    print \"ERROR: Zsh-z's datafile (${datafile}) is a directory.\" >&2\n    exit\n  fi\n\n  # Make sure that the datafile exists before attempting to read it or lock it\n  # for writing\n  [[ -f $datafile ]] || { mkdir -p \"${datafile:h}\" && touch \"$datafile\" }\n\n  # Bail if we don't own the datafile and $ZSHZ_OWNER is not set\n  [[ -z ${ZSHZ_OWNER:-${_Z_OWNER}} && -f $datafile && ! -O $datafile ]] &&\n    return\n\n  # Load the datafile into an array and parse it\n  lines=( ${(f)\"$(< $datafile)\"} )\n  # Discard entries that are incomplete or incorrectly formatted\n  lines=( ${(M)lines:#/*\\|[[:digit:]]##[.,]#[[:digit:]]#\\|[[:digit:]]##} )\n\n  ############################################################\n  # Add a path to or remove one from the datafile\n  #\n  # Globals:\n  #   ZSHZ\n  #   ZSHZ_EXCLUDE_DIRS\n  #   ZSHZ_OWNER\n  #\n  # Arguments:\n  #   $1 Which action to perform (--add/--remove)\n  #   $2 The path to add\n  ############################################################\n  _zshz_add_or_remove_path() {\n    local action=${1}\n    shift\n\n    if [[ $action == '--add' ]]; then\n\n      # TODO: The following tasks are now handled by _agkozak_precmd. Dead code?\n\n      # Don't add $HOME\n      [[ $* == $HOME ]] && return\n\n      # Don't track directory trees excluded in ZSHZ_EXCLUDE_DIRS\n      local exclude\n      for exclude in ${(@)ZSHZ_EXCLUDE_DIRS:-${(@)_Z_EXCLUDE_DIRS}}; do\n        case $* in\n          ${exclude}|${exclude}/*) return ;;\n        esac\n      done\n    fi\n\n    # A temporary file that gets copied over the datafile if all goes well\n    local tempfile=\"${datafile}.${RANDOM}\"\n\n    # See https://github.com/rupa/z/pull/199/commits/ed6eeed9b70d27c1582e3dd050e72ebfe246341c\n    if (( ZSHZ[USE_FLOCK] )); then\n\n      local lockfd\n\n      # Grab exclusive lock (released when function exits)\n      zsystem flock -f lockfd \"$datafile\" 2> /dev/null || return\n\n    fi\n\n    integer tmpfd\n    case $action in\n      --add)\n        exec {tmpfd}>|\"$tempfile\"  # Open up tempfile for writing\n        _zshz_update_datafile $tmpfd \"$*\"\n        local ret=$?\n        ;;\n      --remove)\n        local xdir  # Directory to be removed\n\n        if (( ${ZSHZ_NO_RESOLVE_SYMLINKS:-${_Z_NO_RESOLVE_SYMLINKS}} )); then\n          [[ -d ${${*:-${PWD}}:a} ]] && xdir=${${*:-${PWD}}:a}\n        else\n          [[ -d ${${*:-${PWD}}:A} ]] && xdir=${${*:-${PWD}}:a}\n        fi\n\n        local -a lines_to_keep\n        if (( ${+opts[-R]} )); then\n          # Prompt user before deleting entire database\n          if [[ $xdir == '/' ]] && ! read -q \"?Delete entire Zsh-z database? \"; then\n            print && return 1\n          fi\n          # All of the lines that don't match the directory to be deleted\n          lines_to_keep=( ${lines:#${xdir}\\|*} )\n          # Or its subdirectories\n          lines_to_keep=( ${lines_to_keep:#${xdir%/}/**} )\n        else\n          # All of the lines that don't match the directory to be deleted\n          lines_to_keep=( ${lines:#${xdir}\\|*} )\n        fi\n        if [[ $lines != \"$lines_to_keep\" ]]; then\n          lines=( $lines_to_keep )\n        else\n          return 1  # The $PWD isn't in the datafile\n        fi\n        exec {tmpfd}>|\"$tempfile\"  # Open up tempfile for writing\n        print -u $tmpfd -l -- $lines\n        local ret=$?\n        ;;\n    esac\n\n    if (( tmpfd != 0 )); then\n      # Close tempfile\n      exec {tmpfd}>&-\n    fi\n\n    if (( ret != 0 )); then\n      # Avoid clobbering the datafile if the write to tempfile failed\n      ${ZSHZ[RM]} -f \"$tempfile\"\n      return $ret\n    fi\n\n    local owner\n    owner=${ZSHZ_OWNER:-${_Z_OWNER}}\n\n    if (( ZSHZ[USE_FLOCK] )); then\n      ${ZSHZ[MV]} \"$tempfile\" \"$datafile\" 2> /dev/null || ${ZSHZ[RM]} -f \"$tempfile\"\n\n      if [[ -n $owner ]]; then\n        ${ZSHZ[CHOWN]} ${owner}:\"$(id -ng ${owner})\" \"$datafile\"\n      fi\n    else\n      if [[ -n $owner ]]; then\n        ${ZSHZ[CHOWN]} \"${owner}\":\"$(id -ng \"${owner}\")\" \"$tempfile\"\n      fi\n      ${ZSHZ[MV]} -f \"$tempfile\" \"$datafile\" 2> /dev/null ||\n          ${ZSHZ[RM]} -f \"$tempfile\"\n    fi\n\n    # In order to make z -x work, we have to disable zsh-z's adding\n    # to the database until the user changes directory and the\n    # chpwd_functions are run\n    if [[ $action == '--remove' ]]; then\n      ZSHZ[DIRECTORY_REMOVED]=1\n    fi\n  }\n\n  ############################################################\n  # Read the current datafile contents, update them, \"age\" them\n  # when the total rank gets high enough, and print the new\n  # contents to STDOUT.\n  #\n  # Globals:\n  #   ZSHZ_KEEP_DIRS\n  #   ZSHZ_MAX_SCORE\n  #\n  # Arguments:\n  #   $1 File descriptor linked to tempfile\n  #   $2 Path to be added to datafile\n  ############################################################\n  _zshz_update_datafile() {\n\n    integer fd=$1\n    local -A rank time\n\n    # Characters special to the shell (such as '[]') are quoted with backslashes\n    # See https://github.com/rupa/z/issues/246\n    local add_path=${(q)2}\n\n    local -a existing_paths\n    local now=$EPOCHSECONDS line dir\n    local path_field rank_field time_field count x\n\n    rank[$add_path]=1\n    time[$add_path]=$now\n\n    # Remove paths from database if they no longer exist\n    for line in $lines; do\n      if [[ ! -d ${line%%\\|*} ]]; then\n        for dir in ${(@)ZSHZ_KEEP_DIRS}; do\n          if [[ ${line%%\\|*} == ${dir}/* ||\n                ${line%%\\|*} == $dir     ||\n                $dir == '/' ]]; then\n            existing_paths+=( $line )\n          fi\n        done\n      else\n        existing_paths+=( $line )\n      fi\n    done\n    lines=( $existing_paths )\n\n    for line in $lines; do\n      path_field=${(q)line%%\\|*}\n      rank_field=${${line%\\|*}#*\\|}\n      time_field=${line##*\\|}\n\n      # When a rank drops below 1, drop the path from the database\n      (( rank_field < 1 )) && continue\n\n      if [[ $path_field == $add_path ]]; then\n        rank[$path_field]=$rank_field\n        (( rank[$path_field]++ ))\n        time[$path_field]=$now\n      else\n        rank[$path_field]=$rank_field\n        time[$path_field]=$time_field\n      fi\n      (( count += rank_field ))\n    done\n    if (( count > ${ZSHZ_MAX_SCORE:-${_Z_MAX_SCORE:-9000}} )); then\n      # Aging\n      for x in ${(k)rank}; do\n        print -u $fd -- \"$x|$(( 0.99 * rank[$x] ))|${time[$x]}\" || return 1\n      done\n    else\n      for x in ${(k)rank}; do\n        print -u $fd -- \"$x|${rank[$x]}|${time[$x]}\" || return 1\n      done\n    fi\n  }\n\n  ############################################################\n  # The original tab completion method\n  #\n  # String processing is smartcase -- case-insensitive if the\n  # search string is lowercase, case-sensitive if there are\n  # any uppercase letters. Spaces in the search string are\n  # treated as *'s in globbing. Read the contents of the\n  # datafile and print matches to STDOUT.\n  #\n  # Arguments:\n  #   $1 The string to be completed\n  ############################################################\n  _zshz_legacy_complete() {\n\n    local line path_field path_field_normalized\n\n    # Replace spaces in the search string with asterisks for globbing\n    1=${1//[[:space:]]/*}\n\n    for line in $lines; do\n\n      path_field=${line%%\\|*}\n\n      path_field_normalized=$path_field\n      if (( ZSHZ_TRAILING_SLASH )); then\n        path_field_normalized=${path_field%/}/\n      fi\n\n      # If the search string is all lowercase, the search will be case-insensitive\n      if [[ $1 == \"${1:l}\" && ${path_field_normalized:l} == *${~1}* ]]; then\n        print -- $path_field\n      # Otherwise, case-sensitive\n      elif [[ $path_field_normalized == *${~1}* ]]; then\n        print -- $path_field\n      fi\n\n    done\n    # TODO: Search strings with spaces in them are currently treated case-\n    # insensitively.\n  }\n\n  ############################################################\n  # `print' or `printf' to REPLY\n  #\n  # Variable assignment through command substitution, of the\n  # form\n  #\n  #   foo=$( bar )\n  #\n  # requires forking a subshell; on Cygwin/MSYS2/WSL1 that can\n  # be surprisingly slow. Zsh-z avoids doing that by printing\n  # values to the variable REPLY. Since Zsh v5.3.0 that has\n  # been possible with `print -v'; for earlier versions of the\n  # shell, the values are placed on the editing buffer stack\n  # and then `read' into REPLY.\n  #\n  # Globals:\n  #   ZSHZ\n  #\n  # Arguments:\n  #   Options and parameters for `print'\n  ############################################################\n  _zshz_printv() {\n    # NOTE: For a long time, ZSH's `print -v' had a tendency\n    # to mangle multibyte strings:\n    #\n    #   https://www.zsh.org/mla/workers/2020/msg00307.html\n    #\n    # The bug was fixed in late 2020:\n    #\n    #   https://github.com/zsh-users/zsh/commit/b6ba74cd4eaec2b6cb515748cf1b74a19133d4a4#diff-32bbef18e126b837c87b06f11bfc61fafdaa0ed99fcb009ec53f4767e246b129\n    #\n    # In order to support shells with the bug, we must use a form of `printf`,\n    # which does not exhibit the undesired behavior. See\n    #\n    #   https://www.zsh.org/mla/workers/2020/msg00308.html\n\n    if (( ZSHZ[PRINTV] )); then\n      builtin print -v REPLY -f %s $@\n    else\n      builtin print -z $@\n      builtin read -rz REPLY\n    fi\n  }\n\n  ############################################################\n  # If matches share a common root, find it, and put it in\n  # REPLY for _zshz_output to use.\n  #\n  # Arguments:\n  #   $1 Name of associative array of matches and ranks\n  ############################################################\n  _zshz_find_common_root() {\n    local -a common_matches\n    local x short\n\n    common_matches=( ${(@Pk)1} )\n\n    for x in ${(@)common_matches}; do\n      if [[ -z $short ]] || (( $#x < $#short )) || [[ $x != ${short}/* ]]; then\n        short=$x\n      fi\n    done\n\n    [[ $short == '/' ]] && return\n\n    for x in ${(@)common_matches}; do\n      [[ $x != $short* ]] && return\n    done\n\n    _zshz_printv -- $short\n  }\n\n  ############################################################\n  # Calculate a common root, if there is one. Then do one of\n  # the following:\n  #\n  #   1) Print a list of completions in frecent order;\n  #   2) List them (z -l) to STDOUT; or\n  #   3) Put a common root or best match into REPLY\n  #\n  # Globals:\n  #   ZSHZ_UNCOMMON\n  #\n  # Arguments:\n  #   $1 Name of an associative array of matches and ranks\n  #   $2 The best match or best case-insensitive match\n  #   $3 Whether to produce a completion, a list, or a root or\n  #        match\n  ############################################################\n  _zshz_output() {\n\n    local match_array=$1 match=$2 format=$3\n    local common k x\n    local -a descending_list output\n    local -A output_matches\n\n    output_matches=( ${(Pkv)match_array} )\n\n    _zshz_find_common_root $match_array\n    common=$REPLY\n\n    case $format in\n\n      completion)\n        for k in ${(@k)output_matches}; do\n          _zshz_printv -f \"%.2f|%s\" ${output_matches[$k]} $k\n          descending_list+=( ${(f)REPLY} )\n          REPLY=''\n        done\n        descending_list=( ${${(@On)descending_list}#*\\|} )\n        print -l $descending_list\n        ;;\n\n      list)\n        local path_to_display\n        for x in ${(k)output_matches}; do\n          if (( ${output_matches[$x]} )); then\n            path_to_display=$x\n            (( ZSHZ_TILDE )) &&\n              path_to_display=${path_to_display/#${HOME}/\\~}\n            _zshz_printv -f \"%-10d %s\\n\" ${output_matches[$x]} $path_to_display\n            output+=( ${(f)REPLY} )\n            REPLY=''\n          fi\n        done\n        if [[ -n $common ]]; then\n          (( ZSHZ_TILDE )) && common=${common/#${HOME}/\\~}\n          (( $#output > 1 )) && printf \"%-10s %s\\n\" 'common:' $common\n        fi\n        # -lt\n        if (( $+opts[-t] )); then\n          for x in ${(@On)output}; do\n            print -- $x\n          done\n        # -lr\n        elif (( $+opts[-r] )); then\n          for x in ${(@on)output}; do\n            print -- $x\n          done\n        # -l\n        else\n          for x in ${(@on)output}; do\n            print $x\n          done\n        fi\n        ;;\n\n      *)\n        if (( ! ZSHZ_UNCOMMON )) && [[ -n $common ]]; then\n          _zshz_printv -- $common\n        else\n          _zshz_printv -- ${(P)match}\n        fi\n        ;;\n    esac\n  }\n\n  ############################################################\n  # Match a pattern by rank, time, or a combination of the\n  # two, and output the results as completions, a list, or a\n  # best match.\n  #\n  # Globals:\n  #   ZSHZ\n  #   ZSHZ_CASE\n  #   ZSHZ_KEEP_DIRS\n  #   ZSHZ_OWNER\n  #\n  # Arguments:\n  #   #1 Pattern to match\n  #   $2 Matching method (rank, time, or [default] frecency)\n  #   $3 Output format (completion, list, or [default] store\n  #     in REPLY\n  ############################################################\n  _zshz_find_matches() {\n    setopt LOCAL_OPTIONS NO_EXTENDED_GLOB\n\n    local fnd=$1 method=$2 format=$3\n\n    local -a existing_paths\n    local line dir path_field rank_field time_field rank dx escaped_path_field\n    local -A matches imatches\n    local best_match ibest_match hi_rank=-9999999999 ihi_rank=-9999999999\n\n    # Remove paths from database if they no longer exist\n    for line in $lines; do\n      if [[ ! -d ${line%%\\|*} ]]; then\n        for dir in ${(@)ZSHZ_KEEP_DIRS}; do\n          if [[ ${line%%\\|*} == ${dir}/* ||\n                ${line%%\\|*} == $dir     ||\n                $dir == '/' ]]; then\n            existing_paths+=( $line )\n          fi\n        done\n      else\n        existing_paths+=( $line )\n      fi\n    done\n    lines=( $existing_paths )\n\n    for line in $lines; do\n      path_field=${line%%\\|*}\n      rank_field=${${line%\\|*}#*\\|}\n      time_field=${line##*\\|}\n\n      case $method in\n        rank) rank=$rank_field ;;\n        time) (( rank = time_field - EPOCHSECONDS )) ;;\n        *)\n          # Frecency routine\n          (( dx = EPOCHSECONDS - time_field ))\n          rank=$(( 10000 * rank_field * (3.75/( (0.0001 * dx + 1) + 0.25)) ))\n          ;;\n      esac\n\n      # Use spaces as wildcards\n      local q=${fnd//[[:space:]]/\\*}\n\n      # If $ZSHZ_TRAILING_SLASH is set, use path_field with a trailing slash for matching.\n      local path_field_normalized=$path_field\n      if (( ZSHZ_TRAILING_SLASH )); then\n        path_field_normalized=${path_field%/}/\n      fi\n\n      # If $ZSHZ_CASE is 'ignore', be case-insensitive.\n      #\n      # If it's 'smart', be case-insensitive unless the string to be matched\n      # includes capital letters.\n      #\n      # Otherwise, the default behavior of Zsh-z is to match case-sensitively if\n      # possible, then to fall back on a case-insensitive match if possible.\n      if [[ $ZSHZ_CASE == 'smart' && ${1:l} == $1 &&\n            ${path_field_normalized:l} == ${~q:l} ]]; then\n        imatches[$path_field]=$rank\n      elif [[ $ZSHZ_CASE != 'ignore' && $path_field_normalized == ${~q} ]]; then\n        matches[$path_field]=$rank\n      elif [[ $ZSHZ_CASE != 'smart' && ${path_field_normalized:l} == ${~q:l} ]]; then\n        imatches[$path_field]=$rank\n      fi\n\n      # Escape characters that would cause \"invalid subscript\" errors\n      # when accessing the associative array.\n      escaped_path_field=${path_field//'\\'/'\\\\'}\n      escaped_path_field=${escaped_path_field//'`'/'\\`'}\n      escaped_path_field=${escaped_path_field//'('/'\\('}\n      escaped_path_field=${escaped_path_field//')'/'\\)'}\n      escaped_path_field=${escaped_path_field//'['/'\\['}\n      escaped_path_field=${escaped_path_field//']'/'\\]'}\n\n      if (( matches[$escaped_path_field] )) &&\n         (( matches[$escaped_path_field] > hi_rank )); then\n        best_match=$path_field\n        hi_rank=${matches[$escaped_path_field]}\n      elif (( imatches[$escaped_path_field] )) &&\n           (( imatches[$escaped_path_field] > ihi_rank )); then\n        ibest_match=$path_field\n        ihi_rank=${imatches[$escaped_path_field]}\n        ZSHZ[CASE_INSENSITIVE]=1\n      fi\n    done\n\n    # Return 1 when there are no matches\n    [[ -z $best_match && -z $ibest_match ]] && return 1\n\n    if [[ -n $best_match ]]; then\n      _zshz_output matches best_match $format\n    elif [[ -n $ibest_match ]]; then\n      _zshz_output imatches ibest_match $format\n    fi\n  }\n\n  # THE MAIN ROUTINE\n\n  local -A opts\n\n  zparseopts -E -D -A opts -- \\\n    -add \\\n    -complete \\\n    c \\\n    e \\\n    h \\\n    -help \\\n    l \\\n    r \\\n    R \\\n    t \\\n    x\n\n  if [[ $1 == '--' ]]; then\n    shift\n  elif [[ -n ${(M)@:#-*} && -z $compstate ]]; then\n    print \"Improper option(s) given.\"\n    _zshz_usage\n    return 1\n  fi\n\n  local opt output_format method='frecency' fnd prefix req\n\n  for opt in ${(k)opts}; do\n    case $opt in\n      --add)\n        [[ ! -d $* ]] && return 1\n        local dir\n        # Cygwin and MSYS2 have a hard time with relative paths expressed from /\n        if [[ $OSTYPE == (cygwin|msys) && $PWD == '/' && $* != /* ]]; then\n          set -- \"/$*\"\n        fi\n        if (( ${ZSHZ_NO_RESOLVE_SYMLINKS:-${_Z_NO_RESOLVE_SYMLINKS}} )); then\n          dir=${*:a}\n        else\n          dir=${*:A}\n        fi\n        _zshz_add_or_remove_path --add \"$dir\"\n        return\n        ;;\n      --complete)\n        if [[ -s $datafile && ${ZSHZ_COMPLETION:-frecent} == 'legacy' ]]; then\n          _zshz_legacy_complete \"$1\"\n          return\n        fi\n        output_format='completion'\n        ;;\n      -c) [[ $* == ${PWD}/* || $PWD == '/' ]] || prefix=\"$PWD \" ;;\n      -h|--help)\n        _zshz_usage\n        return\n        ;;\n      -l) output_format='list' ;;\n      -r) method='rank' ;;\n      -t) method='time' ;;\n      -x)\n        # Cygwin and MSYS2 have a hard time with relative paths expressed from /\n        if [[ $OSTYPE == (cygwin|msys) && $PWD == '/' && $* != /* ]]; then\n          set -- \"/$*\"\n        fi\n        _zshz_add_or_remove_path --remove $*\n        return\n        ;;\n    esac\n  done\n  req=\"$*\"\n  fnd=\"$prefix$*\"\n\n  [[ -n $fnd && $fnd != \"$PWD \" ]] || {\n    [[ $output_format != 'completion' ]] && output_format='list'\n  }\n\n  #########################################################\n  # Allow the user to specify directory-changing command\n  # using $ZSHZ_CD (default: builtin cd).\n  #\n  # Globals:\n  #   ZSHZ_CD\n  #\n  # Arguments:\n  #   $* Path\n  #########################################################\n  zshz_cd() {\n    setopt LOCAL_OPTIONS NO_WARN_CREATE_GLOBAL\n\n    if [[ -z $ZSHZ_CD ]]; then\n      builtin cd \"$*\"\n    else\n      ${=ZSHZ_CD} \"$*\"\n    fi\n  }\n\n  #########################################################\n  # If $ZSHZ_ECHO == 1, display paths as you jump to them.\n  # If it is also the case that $ZSHZ_TILDE == 1, display\n  # the home directory as a tilde.\n  #########################################################\n  _zshz_echo() {\n    if (( ZSHZ_ECHO )); then\n      if (( ZSHZ_TILDE )); then\n        print ${PWD/#${HOME}/\\~}\n      else\n        print $PWD\n      fi\n    fi\n  }\n\n  if [[ ${@: -1} == /* ]] && (( ! $+opts[-e] && ! $+opts[-l] )); then\n    # cd if possible; echo the new path if $ZSHZ_ECHO == 1\n    [[ -d ${@: -1} ]] && zshz_cd ${@: -1} && _zshz_echo && return\n  fi\n\n  # With option -c, make sure query string matches beginning of matches;\n  # otherwise look for matches anywhere in paths\n\n  # zpm-zsh/colors has a global $c, so we'll avoid math expressions here\n  if [[ ! -z ${(tP)opts[-c]} ]]; then\n    _zshz_find_matches \"$fnd*\" $method $output_format\n  else\n    _zshz_find_matches \"*$fnd*\" $method $output_format\n  fi\n\n  local ret2=$?\n\n  local cd\n  cd=$REPLY\n\n  # New experimental \"uncommon\" behavior\n  #\n  # If the best choice at this point is something like /foo/bar/foo/bar, and the  # search pattern is `bar', go to /foo/bar/foo/bar; but if the search pattern\n  # is `foo', go to /foo/bar/foo\n  if (( ZSHZ_UNCOMMON )) && [[ -n $cd ]]; then\n    if [[ -n $cd ]]; then\n\n      # In the search pattern, replace spaces with *\n      local q=${fnd//[[:space:]]/\\*}\n      q=${q%/} # Trailing slash has to be removed\n\n      # As long as the best match is not case-insensitive\n      if (( ! ZSHZ[CASE_INSENSITIVE] )); then\n        # Count the number of characters in $cd that $q matches\n        local q_chars=$(( ${#cd} - ${#${cd//${~q}/}} ))\n        # Try dropping directory elements from the right; stop when it affects\n        # how many times the search pattern appears\n        until (( ( ${#cd:h} - ${#${${cd:h}//${~q}/}} ) != q_chars )); do\n          cd=${cd:h}\n        done\n\n      # If the best match is case-insensitive\n      else\n        local q_chars=$(( ${#cd} - ${#${${cd:l}//${~${q:l}}/}} ))\n        until (( ( ${#cd:h} - ${#${${${cd:h}:l}//${~${q:l}}/}} ) != q_chars )); do\n          cd=${cd:h}\n        done\n      fi\n\n      ZSHZ[CASE_INSENSITIVE]=0\n    fi\n  fi\n\n  if (( ret2 == 0 )) && [[ -n $cd ]]; then\n    if (( $+opts[-e] )); then               # echo\n      (( ZSHZ_TILDE )) && cd=${cd/#${HOME}/\\~}\n      print -- \"$cd\"\n    else\n      # cd if possible; echo the new path if $ZSHZ_ECHO == 1\n      [[ -d $cd ]] && zshz_cd \"$cd\" && _zshz_echo\n    fi\n  else\n    # if $req is a valid path, cd to it; echo the new path if $ZSHZ_ECHO == 1\n    if ! (( $+opts[-e] || $+opts[-l] )) && [[ -d $req ]]; then\n      zshz_cd \"$req\" && _zshz_echo\n    else\n      return $ret2\n    fi\n  fi\n}\n\nalias ${ZSHZ_CMD:-${_Z_CMD:-z}}='zshz 2>&1'\n\n############################################################\n# precmd - add path to datafile unless `z -x' has just been\n#   run\n#\n# Globals:\n#   ZSHZ\n############################################################\n_zshz_precmd() {\n  # Protect against `setopt NO_UNSET'\n  setopt LOCAL_OPTIONS UNSET\n\n  # Do not add PWD to datafile when in HOME directory, or\n  # if `z -x' has just been run\n  [[ $PWD == \"$HOME\" ]] || (( ZSHZ[DIRECTORY_REMOVED] )) && return\n\n  # Don't track directory trees excluded in ZSHZ_EXCLUDE_DIRS\n  local exclude\n  for exclude in ${(@)ZSHZ_EXCLUDE_DIRS:-${(@)_Z_EXCLUDE_DIRS}}; do\n    case $PWD in\n      ${exclude}|${exclude}/*) return ;;\n    esac\n  done\n\n  # It appears that forking a subshell is so slow in Windows that it is better\n  # just to add the PWD to the datafile in the foreground\n  if [[ $OSTYPE == (cygwin|msys) ]]; then\n      zshz --add \"$PWD\"\n  else\n      (zshz --add \"$PWD\" &)\n  fi\n\n  # See https://github.com/rupa/z/pull/247/commits/081406117ea42ccb8d159f7630cfc7658db054b6\n  : $RANDOM\n}\n\n############################################################\n# chpwd\n#\n# When the $PWD is removed from the datafile with `z -x',\n# Zsh-z refrains from adding it again until the user has\n# left the directory.\n#\n# Globals:\n#   ZSHZ\n############################################################\n_zshz_chpwd() {\n  ZSHZ[DIRECTORY_REMOVED]=0\n}\n\nautoload -Uz add-zsh-hook\n\nadd-zsh-hook precmd _zshz_precmd\nadd-zsh-hook chpwd _zshz_chpwd\n\n############################################################\n# Completion\n############################################################\n\n# Standardized $0 handling\n# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html\n0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\"\n0=\"${${(M)0:#/*}:-$PWD/$0}\"\n\n(( ${fpath[(ie)${0:A:h}]} <= ${#fpath} )) || fpath=( \"${0:A:h}\" \"${fpath[@]}\" )\n\n############################################################\n# zsh-z functions\n############################################################\nZSHZ[FUNCTIONS]='_zshz_usage\n                 _zshz_add_or_remove_path\n                 _zshz_update_datafile\n                 _zshz_legacy_complete\n                 _zshz_printv\n                 _zshz_find_common_root\n                 _zshz_output\n                 _zshz_find_matches\n                 zshz\n                 _zshz_precmd\n                 _zshz_chpwd\n                 _zshz'\n\n############################################################\n# Enable WARN_NESTED_VAR for functions listed in\n#   ZSHZ[FUNCTIONS]\n############################################################\n(( ${+ZSHZ_DEBUG} )) && () {\n  if is-at-least 5.4.0; then\n    local x\n    for x in ${=ZSHZ[FUNCTIONS]}; do\n      functions -W $x\n    done\n  fi\n}\n\n############################################################\n# Unload function\n#\n# See https://github.com/agkozak/Zsh-100-Commits-Club/blob/master/Zsh-Plugin-Standard.adoc#unload-fun\n#\n# Globals:\n#   ZSHZ\n#   ZSHZ_CMD\n############################################################\nzsh-z_plugin_unload() {\n  emulate -L zsh\n\n  add-zsh-hook -D precmd _zshz_precmd\n  add-zsh-hook -d chpwd _zshz_chpwd\n\n  local x\n  for x in ${=ZSHZ[FUNCTIONS]}; do\n    (( ${+functions[$x]} )) && unfunction $x\n  done\n\n  unset ZSHZ\n\n  fpath=( \"${(@)fpath:#${0:A:h}}\" )\n\n  (( ${+aliases[${ZSHZ_CMD:-${_Z_CMD:-z}}]} )) &&\n    unalias ${ZSHZ_CMD:-${_Z_CMD:-z}}\n\n  unfunction $0\n}\n\n# vim: fdm=indent:ts=2:et:sts=2:sw=2:\n"
        }
      ]
    }
  ]
}