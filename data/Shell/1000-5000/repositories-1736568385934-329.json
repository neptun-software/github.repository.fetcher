{
  "metadata": {
    "timestamp": 1736568385934,
    "page": 329,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "karalabe/xgo",
      "stars": 2142,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0712890625,
          "content": "The MIT License\n\nCopyright (c) 2014 Péter Szilágyi <peterke@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.693359375,
          "content": "# xgo - Go CGO cross compiler\n\nAlthough Go strives to be a cross platform language, cross compilation from one\nplatform to another is not as simple as it could be, as you need the Go sources\nbootstrapped to each platform and architecture.\n\nThe first step towards cross compiling was Dave Cheney's [golang-crosscompile](https://github.com/davecheney/golang-crosscompile)\npackage, which automatically bootstrapped the necessary sources based on your\nexisting Go installation. Although this was enough for a lot of cases, certain\ndrawbacks became apparent where the official libraries used CGO internally: any\ndependency to third party platform code is unavailable, hence those parts don't\ncross compile nicely (native DNS resolution, system certificate access, etc).\n\nA step forward in enabling cross compilation was Alan Shreve's [gonative](https://github.com/inconshreveable/gonative)\npackage, which instead of bootstrapping the different platforms based on the\nexisting Go installation, downloaded the official pre-compiled binaries from the\ngolang website and injected those into the local toolchain. Since the pre-built\nbinaries already contained the necessary platform specific code, the few missing\ndependencies were resolved, and true cross compilation could commence... of pure\nGo code.\n\nHowever, there was still one feature missing: cross compiling Go code that used\nCGO itself, which isn't trivial since you need access to OS specific headers and\nlibraries. This becomes very annoying when you need access only to some trivial\nOS specific functionality (e.g. query the CPU load), but need to configure and\nmaintain separate build environments to do it.\n\n## Enter xgo\n\nMy solution to the challenge of cross compiling Go code with embedded C/C++ snippets\n(i.e. CGO_ENABLED=1) is based on the concept of [lightweight Linux containers](http://en.wikipedia.org/wiki/LXC).\nAll the necessary Go tool-chains, C cross compilers and platform headers/libraries\nhave been assembled into a single Docker container, which can then be called as if\na single command to compile a Go package to various platforms and architectures.\n\n## Installation\n\nAlthough you could build the container manually, it is available as an automatic\ntrusted build from Docker's container registry (not insignificant in size):\n\n    docker pull karalabe/xgo-latest\n\nTo prevent having to remember a potentially complex Docker command every time,\na lightweight Go wrapper was written on top of it.\n\n    go get github.com/karalabe/xgo\n\n## Usage\n\nSimply specify the import path you want to build, and xgo will do the rest:\n\n    $ xgo github.com/project-iris/iris\n    ...\n\n    $ ls -al\n    -rwxr-xr-x  1 root  root    9995000 Nov 24 16:44 iris-android-16-arm\n    -rwxr-xr-x  1 root  root    6776500 Nov 24 16:44 iris-darwin-10.6-386\n    -rwxr-xr-x  1 root  root    8755532 Nov 24 16:44 iris-darwin-10.6-amd64\n    -rwxr-xr-x  1 root  root    7114176 Nov 24 16:45 iris-ios-5.0-arm\n    -rwxr-xr-x  1 root  root   10135248 Nov 24 16:44 iris-linux-386\n    -rwxr-xr-x  1 root  root   12598472 Nov 24 16:44 iris-linux-amd64\n    -rwxr-xr-x  1 root  root   10040464 Nov 24 16:44 iris-linux-arm\n    -rwxr-xr-x  1 root  root    7516368 Nov 24 16:44 iris-windows-4.0-386.exe\n    -rwxr-xr-x  1 root  root    9549416 Nov 24 16:44 iris-windows-4.0-amd64.exe\n\n\nIf the path is not a canonical import path, but rather a local path (starts with\na dot `.` or a dash `/`), xgo will use the local GOPATH contents for the cross\ncompilation.\n\n\n### Build flags\n\nA handful of flags can be passed to `go build`. The currently supported ones are\n\n  - `-v`: prints the names of packages as they are compiled\n  - `-x`: prints the build commands as compilation progresses\n  - `-race`: enables data race detection (supported only on amd64, rest built without)\n  - `-tags='tag list'`: list of build tags to consider satisfied during the build\n  - `-ldflags='flag list'`: arguments to pass on each go tool link invocation\n  - `-buildmode=mode`: binary type to produce by the compiler\n\n\n### Go releases\n\nAs newer versions of the language runtime, libraries and tools get released,\nthese will get incorporated into xgo too as extensions layers to the base cross\ncompilation image (only Go 1.3 and above will be supported).\n\nYou can select which Go release to work with through the `-go` command line flag\nto xgo and if the specific release was already integrated, it will automatically\nbe retrieved and installed.\n\n    $ xgo -go 1.6.1 github.com/project-iris/iris\n\nAdditionally, a few wildcard release strings are also supported:\n\n  - `latest` will use the latest Go release (this is the default)\n  - `1.6.x` will use the latest point release of a specific Go version\n  - `1.6-develop` will use the develop branch of a specific Go version\n  - `develop` will use the develop branch of the entire Go repository\n\n### Output prefixing\n\nxgo by default uses the name of the package being cross compiled as the output\nfile prefix. This can be overridden with the `-out` flag.\n\n    $ xgo -out iris-v0.3.2 github.com/project-iris/iris\n    ...\n\n    $ ls -al\n    -rwxr-xr-x  1 root  root   9995000 Nov 24 16:44 iris-v0.3.2-android-16-arm\n    -rwxr-xr-x  1 root  root   6776500 Nov 24 16:44 iris-v0.3.2-darwin-10.6-386\n    -rwxr-xr-x  1 root  root   8755532 Nov 24 16:44 iris-v0.3.2-darwin-10.6-amd64\n    -rwxr-xr-x  1 root  root   7114176 Nov 24 16:45 iris-v0.3.2-ios-5.0-arm\n    -rwxr-xr-x  1 root  root  10135248 Nov 24 16:44 iris-v0.3.2-linux-386\n    -rwxr-xr-x  1 root  root  12598472 Nov 24 16:44 iris-v0.3.2-linux-amd64\n    -rwxr-xr-x  1 root  root  10040464 Nov 24 16:44 iris-v0.3.2-linux-arm\n    -rwxr-xr-x  1 root  root   7516368 Nov 24 16:44 iris-v0.3.2-windows-4.0-386.exe\n    -rwxr-xr-x  1 root  root   9549416 Nov 24 16:44 iris-v0.3.2-windows-4.0-amd64.exe\n\n\n### Branch selection\n\nSimilarly to `go get`, xgo also uses the `master` branch of a repository during\nsource code retrieval. To switch to a different branch before compilation pass\nthe desired branch name through the `--branch` argument.\n\n    $ xgo --branch release-branch.go1.4 golang.org/x/tools/cmd/goimports\n    ...\n\n    $ ls -al\n    -rwxr-xr-x  1 root  root   4171248 Nov 24 16:40 goimports-android-16-arm\n    -rwxr-xr-x  1 root  root   4139868 Nov 24 16:40 goimports-darwin-10.6-386\n    -rwxr-xr-x  1 root  root   5186720 Nov 24 16:40 goimports-darwin-10.6-amd64\n    -rwxr-xr-x  1 root  root   3202364 Nov 24 16:40 goimports-ios-5.0-arm\n    -rwxr-xr-x  1 root  root   4189456 Nov 24 16:40 goimports-linux-386\n    -rwxr-xr-x  1 root  root   5264136 Nov 24 16:40 goimports-linux-amd64\n    -rwxr-xr-x  1 root  root   4209416 Nov 24 16:40 goimports-linux-arm\n    -rwxr-xr-x  1 root  root   4348416 Nov 24 16:40 goimports-windows-4.0-386.exe\n    -rwxr-xr-x  1 root  root   5415424 Nov 24 16:40 goimports-windows-4.0-amd64.exe\n\n\n### Remote selection\n\nYet again similarly to `go get`, xgo uses the repository remote corresponding to\nthe import path being built. To switch to a different remote while preserving the\noriginal import path, use the `--remote` argument.\n\n    $ xgo --remote github.com/golang/tools golang.org/x/tools/cmd/goimports\n    ...\n\n### Package selection\n\nIf you used the above *branch* or *remote* selection machanisms, it may happen\nthat the path you are trying to build is only present in the specific branch and\nnot the default repository, causing Go to fail at locating it. To circumvent this,\nyou may specify only the repository root for xgo, and use an additional `--pkg`\nparameter to select the exact package within, honoring any prior *branch* and\n*remote* selections.\n\n    $ xgo --pkg cmd/goimports golang.org/x/tools\n    ...\n\n    $ ls -al\n    -rwxr-xr-x  1 root  root   4194956 Nov 24 16:38 goimports-android-16-arm\n    -rwxr-xr-x  1 root  root   4164448 Nov 24 16:38 goimports-darwin-10.6-386\n    -rwxr-xr-x  1 root  root   5223584 Nov 24 16:38 goimports-darwin-10.6-amd64\n    -rwxr-xr-x  1 root  root   3222848 Nov 24 16:39 goimports-ios-5.0-arm\n    -rwxr-xr-x  1 root  root   4217184 Nov 24 16:38 goimports-linux-386\n    -rwxr-xr-x  1 root  root   5295768 Nov 24 16:38 goimports-linux-amd64\n    -rwxr-xr-x  1 root  root   4233120 Nov 24 16:38 goimports-linux-arm\n    -rwxr-xr-x  1 root  root   4373504 Nov 24 16:38 goimports-windows-4.0-386.exe\n    -rwxr-xr-x  1 root  root   5450240 Nov 24 16:38 goimports-windows-4.0-amd64.exe\n\nThis argument may at some point be integrated into the import path itself, but for\nnow it exists as an independent build parameter. Also, there is not possibility\nfor now to build mulitple commands in one go.\n\n### Limit build targets\n\nBy default `xgo` will try and build the specified package to all platforms and\narchitectures supported by the underlying Go runtime. If you wish to restrict\nthe build to only a few target systems, use the comma separated `--targets` CLI\nargument:\n\n  * `--targets=linux/arm`: builds only the ARMv5 Linux binaries (`arm-6`/`arm-7` allowed)\n  * `--targets=windows/*,darwin/*`: builds all Windows and OSX binaries\n  * `--targets=*/arm`: builds ARM binaries for all platforms\n  * `--targets=*/*`: builds all suppoted targets (default)\n\nThe supported targets are:\n\n * Platforms: `android`, `darwin`, `ios`, `linux`, `windows`\n * Achitectures: `386`, `amd64`, `arm-5`, `arm-6`, `arm-7`, `arm64`, `mips`, `mipsle`, `mips64`, `mips64le`\n\n### Platform versions\n\nBy default `xgo` tries to cross compile to the lowest possible versions of every\nsupported platform, in order to produce binaries that are portable among various\nversions of the same operating system. This however can lead to issues if a used\ndependency is only supported by more recent systems. As such, `xgo` supports the\nselection of specific platform versions by appending them to the OS target string.\n\n * `--targets=ios-8.1/*`: cross compile to iOS 8.1\n * `--targets=android-16/*`: cross compile to Android Jelly Bean\n * `--targets=darwin-10.9/*`: cross compile to Mac OS X Mavericks\n * `--targets=windows-6.0/*`: cross compile to Windows Vista\n\nThe supported platforms are:\n\n * All Android APIs up to Android Lollipop 5.0 ([API level ids](https://source.android.com/source/build-numbers.html))\n * All Windows APIs up to Windows 8.1 limited by `mingw-w64` ([API level ids](https://en.wikipedia.org/wiki/Windows_NT#Releases))\n * OSX APIs in the range of 10.6 - 10.11\n * All iOS APIs up to iOS 9.3\n\n### Mobile libraries\n\nApart from the usual runnable binaries, `xgo` also supports building library\narchives for Android (`android/aar`) and iOS (`ios/framework`). Opposed to\n`gomobile` however `xgo` does not derive library APIs from the Go code, so\nproper CGO C external methods must be defined within the package.\n\nIn the case of Android archives, all architectures will be bundled that are\nsupported by the requested Android platform version. For iOS frameworks `xgo`\nwill bundle armv7 and arm64 by default, and also the x86_64 simulator builds\nif the iPhoneSimulator.sdk was injected by the user:\n\n* Create a new docker image based on xgo: `FROM karalabe/xgo-latest`\n* Inject the simulator SDK: `ADD iPhoneSimulator9.3.sdk.tar.xz /iPhoneSimulator9.3.sdk.tar.xz`\n* Bootstrap the simulator SDK: `$UPDATE_IOS /iPhoneSimulator9.3.sdk.tar.xz`\n\n### CGO dependencies\n\nThe main differentiator of xgo versus other cross compilers is support for basic\nembedded C/C++ code and target-platform specific OS SDK availability. The current\nxgo release introduces an experimental CGO *dependency* cross compilation, enabling\nbuilding Go programs that require external C/C++ libraries.\n\nIt is assumed that the dependent C/C++ library is `configure/make` based, was\nproperly prepared for cross compilation and is available as a tarball download\n(`.tar`, `.tar.gz` or `.tar.bz2`). Further plans include extending this to cmake\nbased projects, if need arises (please open an issue if it's important to you).\n\nSuch dependencies can be added via the `--deps` argument. They will be retrieved\nprior to starting the cross compilation and the packages cached to save bandwidth\non subsequent calls.\n\nA complex sample for such a scenario is building the Ethereum CLI node, which has\nthe GNU Multiple Precision Arithmetic Library as it's dependency.\n\n    $ xgo --deps=https://gmplib.org/download/gmp/gmp-6.1.0.tar.bz2  \\\n        --targets=windows/* github.com/ethereum/go-ethereum/cmd/geth\n    ...\n\n    $ ls -al\n    -rwxr-xr-x 1 root root 16315679 Nov 24 16:39 geth-windows-4.0-386.exe\n    -rwxr-xr-x 1 root root 19452036 Nov 24 16:38 geth-windows-4.0-amd64.exe\n\nSome trivial arguments may be passed to the dependencies' configure script via\n`--depsargs`.\n\n    $ xgo --deps=https://gmplib.org/download/gmp/gmp-6.1.0.tar.bz2  \\\n        --targets=ios/* --depsargs=--disable-assembly               \\\n        github.com/ethereum/go-ethereum/cmd/geth\n    ...\n\n    $ ls -al\n    -rwxr-xr-x 1 root root 14804160 Nov 24 16:32 geth-ios-5.0-arm\n\nNote, that since xgo needs to cross compile the dependencies for each platform\nand architecture separately, build time can increase significantly.\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "testsuite.go",
          "type": "blob",
          "size": 2.599609375,
          "content": "// Go CGO cross compiler\n// Copyright (c) 2016 Péter Szilágyi. All rights reserved.\n//\n// Released under the MIT license.\n\n// This is a manual test suite to run the cross compiler against various known\n// projects, codebases and repositories to ensure at least a baseline guarantee\n// that things work as they supposed to.\n//\n// Run as: go run testsuite.go\n\n// +build ignore\n\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n)\n\n// layers defines all the docker layers needed for the final xgo image. The last\n// one will be used to run the test suite against.\nvar layers = []struct {\n\ttag string\n\tdir string\n}{\n\t{\"karalabe/xgo-base\", \"base\"},\n\t{\"karalabe/xgo-1.6.2\", \"go-1.6.2\"},\n\t{\"karalabe/xgo-1.6.x\", \"go-1.6.x\"},\n\t{\"karalabe/xgo-latest\", \"go-latest\"},\n\t//{\"karalabe/xgo-latest-ios\", \"go-latest-ios\"}, // Non-public layer (XCode licensing)\n}\n\n// tests defaines all the input test cases and associated arguments the cross\n// compiler should be ran for and with which arguments.\nvar tests = []struct {\n\tpath string\n\targs []string\n}{\n\t// Tiny test cases to smoke test cross compilations\n\t{\"github.com/karalabe/xgo/tests/embedded_c\", nil},\n\t{\"github.com/karalabe/xgo/tests/embedded_cpp\", nil},\n\n\t// Baseline projects to ensure minimal requirements\n\t//{\"github.com/project-iris/iris\", nil}, // Deps failed, disable\n\t{\"github.com/ethereum/go-ethereum/cmd/geth\", []string{\"--branch\", \"develop\"}},\n\n\t// Third party projects using xgo, smoke test that they don't break\n\t{\"github.com/rwcarlsen/cyan/cmd/cyan\", nil},\n\t{\"github.com/cockroachdb/cockroach\", []string{\"--targets\", \"darwin-10.11/amd64\"}},\n}\n\nfunc main() {\n\t// Retrieve the current working directory to locate the dockerfiles\n\tpwd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve local working directory: %v\", err)\n\t}\n\tif _, err := os.Stat(filepath.Join(pwd, \"docker\", \"base\")); err != nil {\n\t\tlog.Fatalf(\"Failed to locate docker image: %v\", err)\n\t}\n\t// Assemble the multi-layered xgo docker image\n\tfor _, layer := range layers {\n\t\tcmd := exec.Command(\"docker\", \"build\", \"--tag\", layer.tag, filepath.Join(pwd, \"docker\", layer.dir))\n\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to build xgo layer: %v\", err)\n\t\t}\n\t}\n\t// Iterate over each of the test cases and run them\n\tfor i, test := range tests {\n\t\tcmd := exec.Command(\"docker\", append([]string{\"run\", \"--entrypoint\", \"xgo\", layers[len(layers)-1].tag, \"-v\"}, append(test.args, test.path)...)...)\n\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tlog.Fatalf(\"Test #%d: cross compilation failed: %v\", i, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "xgo.go",
          "type": "blob",
          "size": 13.0380859375,
          "content": "// Go CGO cross compiler\n// Copyright (c) 2014 Péter Szilágyi. All rights reserved.\n//\n// Released under the MIT license.\n\n// Wrapper around the GCO cross compiler docker container.\npackage main\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Path where to cache external dependencies\nvar depsCache string\n\nfunc init() {\n\t// Initialize the external dependency cache path to a few possible locations\n\tif home := os.Getenv(\"HOME\"); home != \"\" {\n\t\tdepsCache = filepath.Join(home, \".xgo-cache\")\n\t\treturn\n\t}\n\tif user, err := user.Current(); user != nil && err == nil && user.HomeDir != \"\" {\n\t\tdepsCache = filepath.Join(user.HomeDir, \".xgo-cache\")\n\t\treturn\n\t}\n\tdepsCache = filepath.Join(os.TempDir(), \"xgo-cache\")\n}\n\n// Cross compilation docker containers\nvar dockerBase = \"karalabe/xgo-base\"\nvar dockerDist = \"karalabe/xgo-\"\n\n// Command line arguments to fine tune the compilation\nvar (\n\tgoVersion   = flag.String(\"go\", \"latest\", \"Go release to use for cross compilation\")\n\tsrcPackage  = flag.String(\"pkg\", \"\", \"Sub-package to build if not root import\")\n\tsrcRemote   = flag.String(\"remote\", \"\", \"Version control remote repository to build\")\n\tsrcBranch   = flag.String(\"branch\", \"\", \"Version control branch to build\")\n\toutPrefix   = flag.String(\"out\", \"\", \"Prefix to use for output naming (empty = package name)\")\n\toutFolder   = flag.String(\"dest\", \"\", \"Destination folder to put binaries in (empty = current)\")\n\tcrossDeps   = flag.String(\"deps\", \"\", \"CGO dependencies (configure/make based archives)\")\n\tcrossArgs   = flag.String(\"depsargs\", \"\", \"CGO dependency configure arguments\")\n\ttargets     = flag.String(\"targets\", \"*/*\", \"Comma separated targets to build for\")\n\tdockerImage = flag.String(\"image\", \"\", \"Use custom docker image instead of official distribution\")\n)\n\n// ConfigFlags is a simple set of flags to define the environment and dependencies.\ntype ConfigFlags struct {\n\tRepository   string   // Root import path to build\n\tPackage      string   // Sub-package to build if not root import\n\tPrefix       string   // Prefix to use for output naming\n\tRemote       string   // Version control remote repository to build\n\tBranch       string   // Version control branch to build\n\tDependencies string   // CGO dependencies (configure/make based archives)\n\tArguments    string   // CGO dependency configure arguments\n\tTargets      []string // Targets to build for\n}\n\n// Command line arguments to pass to go build\nvar (\n\tbuildVerbose = flag.Bool(\"v\", false, \"Print the names of packages as they are compiled\")\n\tbuildSteps   = flag.Bool(\"x\", false, \"Print the command as executing the builds\")\n\tbuildRace    = flag.Bool(\"race\", false, \"Enable data race detection (supported only on amd64)\")\n\tbuildTags    = flag.String(\"tags\", \"\", \"List of build tags to consider satisfied during the build\")\n\tbuildLdFlags = flag.String(\"ldflags\", \"\", \"Arguments to pass on each go tool link invocation\")\n\tbuildMode    = flag.String(\"buildmode\", \"default\", \"Indicates which kind of object file to build\")\n)\n\n// BuildFlags is a simple collection of flags to fine tune a build.\ntype BuildFlags struct {\n\tVerbose bool   // Print the names of packages as they are compiled\n\tSteps   bool   // Print the command as executing the builds\n\tRace    bool   // Enable data race detection (supported only on amd64)\n\tTags    string // List of build tags to consider satisfied during the build\n\tLdFlags string // Arguments to pass on each go tool link invocation\n\tMode    string // Indicates which kind of object file to build\n}\n\nfunc main() {\n\t// Retrieve the CLI flags and the execution environment\n\tflag.Parse()\n\n\txgoInXgo := os.Getenv(\"XGO_IN_XGO\") == \"1\"\n\tif xgoInXgo {\n\t\tdepsCache = \"/deps-cache\"\n\t}\n\t// Only use docker images if we're not already inside out own image\n\timage := \"\"\n\n\tif !xgoInXgo {\n\t\t// Ensure docker is available\n\t\tif err := checkDocker(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to check docker installation: %v.\", err)\n\t\t}\n\t\t// Validate the command line arguments\n\t\tif len(flag.Args()) != 1 {\n\t\t\tlog.Fatalf(\"Usage: %s [options] <go import path>\", os.Args[0])\n\t\t}\n\t\t// Select the image to use, either official or custom\n\t\timage = dockerDist + *goVersion\n\t\tif *dockerImage != \"\" {\n\t\t\timage = *dockerImage\n\t\t}\n\t\t// Check that all required images are available\n\t\tfound, err := checkDockerImage(image)\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tlog.Fatalf(\"Failed to check docker image availability: %v.\", err)\n\t\tcase !found:\n\t\t\tfmt.Println(\"not found!\")\n\t\t\tif err := pullDockerImage(image); err != nil {\n\t\t\t\tlog.Fatalf(\"Failed to pull docker image from the registry: %v.\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tfmt.Println(\"found.\")\n\t\t}\n\t}\n\t// Cache all external dependencies to prevent always hitting the internet\n\tif *crossDeps != \"\" {\n\t\tif err := os.MkdirAll(depsCache, 0751); err != nil {\n\t\t\tlog.Fatalf(\"Failed to create dependency cache: %v.\", err)\n\t\t}\n\t\t// Download all missing dependencies\n\t\tfor _, dep := range strings.Split(*crossDeps, \" \") {\n\t\t\tif url := strings.TrimSpace(dep); len(url) > 0 {\n\t\t\t\tpath := filepath.Join(depsCache, filepath.Base(url))\n\n\t\t\t\tif _, err := os.Stat(path); err != nil {\n\t\t\t\t\tfmt.Printf(\"Downloading new dependency: %s...\\n\", url)\n\n\t\t\t\t\tout, err := os.Create(path)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatalf(\"Failed to create dependency file: %v.\", err)\n\t\t\t\t\t}\n\t\t\t\t\tres, err := http.Get(url)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatalf(\"Failed to retrieve dependency: %v.\", err)\n\t\t\t\t\t}\n\t\t\t\t\tdefer res.Body.Close()\n\n\t\t\t\t\tif _, err := io.Copy(out, res.Body); err != nil {\n\t\t\t\t\t\tlog.Fatalf(\"Failed to download dependency: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tout.Close()\n\n\t\t\t\t\tfmt.Printf(\"New dependency cached: %s.\\n\", path)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"Dependency already cached: %s.\\n\", path)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Assemble the cross compilation environment and build options\n\tconfig := &ConfigFlags{\n\t\tRepository:   flag.Args()[0],\n\t\tPackage:      *srcPackage,\n\t\tRemote:       *srcRemote,\n\t\tBranch:       *srcBranch,\n\t\tPrefix:       *outPrefix,\n\t\tDependencies: *crossDeps,\n\t\tArguments:    *crossArgs,\n\t\tTargets:      strings.Split(*targets, \",\"),\n\t}\n\tflags := &BuildFlags{\n\t\tVerbose: *buildVerbose,\n\t\tSteps:   *buildSteps,\n\t\tRace:    *buildRace,\n\t\tTags:    *buildTags,\n\t\tLdFlags: *buildLdFlags,\n\t\tMode:    *buildMode,\n\t}\n\tfolder, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to retrieve the working directory: %v.\", err)\n\t}\n\tif *outFolder != \"\" {\n\t\tfolder, err = filepath.Abs(*outFolder)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to resolve destination path (%s): %v.\", *outFolder, err)\n\t\t}\n\t}\n\t// Execute the cross compilation, either in a container or the current system\n\tif !xgoInXgo {\n\t\terr = compile(image, config, flags, folder)\n\t} else {\n\t\terr = compileContained(config, flags, folder)\n\t}\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to cross compile package: %v.\", err)\n\t}\n}\n\n// Checks whether a docker installation can be found and is functional.\nfunc checkDocker() error {\n\tfmt.Println(\"Checking docker installation...\")\n\tif err := run(exec.Command(\"docker\", \"version\")); err != nil {\n\t\treturn err\n\t}\n\tfmt.Println()\n\treturn nil\n}\n\n// Checks whether a required docker image is available locally.\nfunc checkDockerImage(image string) (bool, error) {\n\tfmt.Printf(\"Checking for required docker image %s... \", image)\n\tout, err := exec.Command(\"docker\", \"images\", \"--no-trunc\").Output()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn bytes.Contains(out, []byte(image)), nil\n}\n\n// Pulls an image from the docker registry.\nfunc pullDockerImage(image string) error {\n\tfmt.Printf(\"Pulling %s from docker registry...\\n\", image)\n\treturn run(exec.Command(\"docker\", \"pull\", image))\n}\n\n// compile cross builds a requested package according to the given build specs\n// using a specific docker cross compilation image.\nfunc compile(image string, config *ConfigFlags, flags *BuildFlags, folder string) error {\n\t// If a local build was requested, find the import path and mount all GOPATH sources\n\tlocals, mounts, paths := []string{}, []string{}, []string{}\n\tif strings.HasPrefix(config.Repository, string(filepath.Separator)) || strings.HasPrefix(config.Repository, \".\") {\n\t\t// Resolve the repository import path from the file path\n\t\tconfig.Repository = resolveImportPath(config.Repository)\n\n\t\t// Iterate over all the local libs and export the mount points\n\t\tif os.Getenv(\"GOPATH\") == \"\" {\n\t\t\tlog.Fatalf(\"No $GOPATH is set or forwarded to xgo\")\n\t\t}\n\t\tfor _, gopath := range strings.Split(os.Getenv(\"GOPATH\"), string(os.PathListSeparator)) {\n\t\t\t// Since docker sandboxes volumes, resolve any symlinks manually\n\t\t\tsources := filepath.Join(gopath, \"src\")\n\t\t\tfilepath.Walk(sources, func(path string, info os.FileInfo, err error) error {\n\t\t\t\t// Skip any folders that errored out\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to access GOPATH element %s: %v\", path, err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Skip anything that's not a symlink\n\t\t\t\tif info.Mode()&os.ModeSymlink == 0 {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Resolve the symlink and skip if it's not a folder\n\t\t\t\ttarget, err := filepath.EvalSymlinks(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif info, err = os.Stat(target); err != nil || !info.IsDir() {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Skip if the symlink points within GOPATH\n\t\t\t\tif filepath.HasPrefix(target, sources) {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Folder needs explicit mounting due to docker symlink security\n\t\t\t\tlocals = append(locals, target)\n\t\t\t\tmounts = append(mounts, filepath.Join(\"/ext-go\", strconv.Itoa(len(locals)), \"src\", strings.TrimPrefix(path, sources)))\n\t\t\t\tpaths = append(paths, filepath.Join(\"/ext-go\", strconv.Itoa(len(locals))))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\t// Export the main mount point for this GOPATH entry\n\t\t\tlocals = append(locals, sources)\n\t\t\tmounts = append(mounts, filepath.Join(\"/ext-go\", strconv.Itoa(len(locals)), \"src\"))\n\t\t\tpaths = append(paths, filepath.Join(\"/ext-go\", strconv.Itoa(len(locals))))\n\t\t}\n\t}\n\t// Assemble and run the cross compilation command\n\tfmt.Printf(\"Cross compiling %s...\\n\", config.Repository)\n\n\targs := []string{\n\t\t\"run\", \"--rm\",\n\t\t\"-v\", folder + \":/build\",\n\t\t\"-v\", depsCache + \":/deps-cache:ro\",\n\t\t\"-e\", \"REPO_REMOTE=\" + config.Remote,\n\t\t\"-e\", \"REPO_BRANCH=\" + config.Branch,\n\t\t\"-e\", \"PACK=\" + config.Package,\n\t\t\"-e\", \"DEPS=\" + config.Dependencies,\n\t\t\"-e\", \"ARGS=\" + config.Arguments,\n\t\t\"-e\", \"OUT=\" + config.Prefix,\n\t\t\"-e\", fmt.Sprintf(\"FLAG_V=%v\", flags.Verbose),\n\t\t\"-e\", fmt.Sprintf(\"FLAG_X=%v\", flags.Steps),\n\t\t\"-e\", fmt.Sprintf(\"FLAG_RACE=%v\", flags.Race),\n\t\t\"-e\", fmt.Sprintf(\"FLAG_TAGS=%s\", flags.Tags),\n\t\t\"-e\", fmt.Sprintf(\"FLAG_LDFLAGS=%s\", flags.LdFlags),\n\t\t\"-e\", fmt.Sprintf(\"FLAG_BUILDMODE=%s\", flags.Mode),\n\t\t\"-e\", \"TARGETS=\" + strings.Replace(strings.Join(config.Targets, \" \"), \"*\", \".\", -1),\n\t}\n\tfor i := 0; i < len(locals); i++ {\n\t\targs = append(args, []string{\"-v\", fmt.Sprintf(\"%s:%s:ro\", locals[i], mounts[i])}...)\n\t}\n\targs = append(args, []string{\"-e\", \"EXT_GOPATH=\" + strings.Join(paths, \":\")}...)\n\n\targs = append(args, []string{image, config.Repository}...)\n\treturn run(exec.Command(\"docker\", args...))\n}\n\n// compileContained cross builds a requested package according to the given build\n// specs using the current system opposed to running in a container. This is meant\n// to be used for cross compilation already from within an xgo image, allowing the\n// inheritance and bundling of the root xgo images.\nfunc compileContained(config *ConfigFlags, flags *BuildFlags, folder string) error {\n\t// If a local build was requested, resolve the import path\n\tlocal := strings.HasPrefix(config.Repository, string(filepath.Separator)) || strings.HasPrefix(config.Repository, \".\")\n\tif local {\n\t\tconfig.Repository = resolveImportPath(config.Repository)\n\t}\n\t// Fine tune the original environment variables with those required by the build script\n\tenv := []string{\n\t\t\"REPO_REMOTE=\" + config.Remote,\n\t\t\"REPO_BRANCH=\" + config.Branch,\n\t\t\"PACK=\" + config.Package,\n\t\t\"DEPS=\" + config.Dependencies,\n\t\t\"ARGS=\" + config.Arguments,\n\t\t\"OUT=\" + config.Prefix,\n\t\tfmt.Sprintf(\"FLAG_V=%v\", flags.Verbose),\n\t\tfmt.Sprintf(\"FLAG_X=%v\", flags.Steps),\n\t\tfmt.Sprintf(\"FLAG_RACE=%v\", flags.Race),\n\t\tfmt.Sprintf(\"FLAG_TAGS=%s\", flags.Tags),\n\t\tfmt.Sprintf(\"FLAG_LDFLAGS=%s\", flags.LdFlags),\n\t\tfmt.Sprintf(\"FLAG_BUILDMODE=%s\", flags.Mode),\n\t\t\"TARGETS=\" + strings.Replace(strings.Join(config.Targets, \" \"), \"*\", \".\", -1),\n\t}\n\tif local {\n\t\tenv = append(env, \"EXT_GOPATH=/non-existent-path-to-signal-local-build\")\n\t}\n\t// Assemble and run the local cross compilation command\n\tfmt.Printf(\"Cross compiling %s...\\n\", config.Repository)\n\n\tcmd := exec.Command(\"/build.sh\", config.Repository)\n\tcmd.Env = append(os.Environ(), env...)\n\n\treturn run(cmd)\n}\n\n// resolveImportPath converts a package given by a relative path to a Go import\n// path using the local GOPATH environment.\nfunc resolveImportPath(path string) string {\n\tabs, err := filepath.Abs(path)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to locate requested package: %v.\", err)\n\t}\n\tstat, err := os.Stat(abs)\n\tif err != nil || !stat.IsDir() {\n\t\tlog.Fatalf(\"Requested path invalid.\")\n\t}\n\tpack, err := build.ImportDir(abs, build.FindOnly)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to resolve import path: %v.\", err)\n\t}\n\treturn pack.ImportPath\n}\n\n// Executes a command synchronously, redirecting its output to stdout.\nfunc run(cmd *exec.Cmd) error {\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\treturn cmd.Run()\n}\n"
        }
      ]
    }
  ]
}