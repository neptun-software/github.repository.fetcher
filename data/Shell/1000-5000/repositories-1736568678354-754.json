{
  "metadata": {
    "timestamp": 1736568678354,
    "page": 754,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pimterry/notes",
      "stars": 1282,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.314453125,
          "content": "[submodule \"test/libs/bats\"]\n\tpath = test/libs/bats\n\turl = https://github.com/sstephenson/bats\n[submodule \"test/libs/bats-assert\"]\n\tpath = test/libs/bats-assert\n\turl = https://github.com/ztombol/bats-assert\n[submodule \"test/libs/bats-support\"]\n\tpath = test/libs/bats-support\n\turl = https://github.com/ztombol/bats-support\n"
        },
        {
          "name": "ISSUE_TEMPLATE",
          "type": "blob",
          "size": 0.587890625,
          "content": "<!--\nThis template is for use with a bug report. If creating a feature request, please delete this file\n-->\n#### Issue Summary\n\nA summary of the issue. In this summary, please feel free to include screenshots, outputs, or any relevant data.\n\n#### Steps to Reproduce\n\n1. This is the first step\n2. This is the second step\n3. Further steps, etc.\n\nAny other information you want to share that is relevant to the issue being reported. Especially, why do you consider this to be a bug? What do you expect to happen instead?\n\n#### Technical details:\n\n* notes version: master (latest commit: [commit number])\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2016 Tim Perry\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.5361328125,
          "content": "PREFIX ?= /usr/local\nBASH_COMPLETION_DIR ?= $(shell pkg-config --silence-errors --variable=completionsdir bash-completion)\nUSERDIR ?= $(HOME)\n\n# The @ symbols make the output silent.\n\ninstall:\n\t@if [ $(BASH_COMPLETION_DIR) ]; then \\\n\t\tcp notes.bash_completion \"$(BASH_COMPLETION_DIR)/notes\"; \\\n\telse \\\n\t\tprintf \\\n\"Bash completion was not installed, because the directory was not found. \\\nIf you have bash completion installed, follow the README \\\n(https://github.com/pimterry/notes#installing-bash-completion) \\\nto manually install it.\\n\\n\"; \\\n\tfi # Small test for bash completion support\n\n\t@install -m755 -d $(PREFIX)/bin/\n\t@install -m755 notes $(PREFIX)/bin/\n\t@install -d $(PREFIX)/share/man/man1/\n\t@install notes.1 $(PREFIX)/share/man/man1/\n\n\t@mandb 1>/dev/null 2>&1 || true # Fail silently if we don't have a mandb\n\n\t@printf \"Notes has been installed to $(PREFIX)/bin/notes.\\n\"\n\n\t@if [ ! -f $(USERDIR)/.config/notes/config ]; then \\\n\t\tinstall -m777 -d $(USERDIR)/.config/notes/; \\\n\t\tinstall -m777 config $(USERDIR)/.config/notes/; \\\n\t\tprintf \\\n\"A configuration file has also been created at $(USERDIR)/.config/notes/config, \\\nwhich you can edit if you'd like to change the default settings.\\n\"; \\\n\tfi # install default config file if non present\n\n\t@printf \\\n\"\\nGet started now by running 'notes new my-note' \\\nor you can run 'notes help' for more info.\\n\"; \\\n\nuninstall:\n\trm -f $(PREFIX)/bin/notes\n\trm -f $(PREFIX)/share/man/man1/notes.1\n\trm -f $(BASH_COMPLETION_DIR)/notes\n\trm -f $(USERDIR)/.config/notes/config.example\n\n\t@printf \"\\nNotes has now been uninstalled.\\n\"\n"
        },
        {
          "name": "PULL_REQUEST_TEMPLATE",
          "type": "blob",
          "size": 0.87109375,
          "content": "<!--\nThank you for contributing to notes, before you submit your pull request, please follow this template to make sure your PR fits the criteria. \n\nPlease enter each issue number you are resolving in your PR after one of the following words [Fixes, Closes, Resolves]. This will auto-link these issues and close them when this PR is merged!\ne.g. \nFixes #1\nCloses #2\n-->\n# Fixes # \n\n### Checklist\n- [ ] I have made a change to this repository, be it functionality, testing, documentation, spelling, or grammar.\n- [ ] I updated my branch with the master branch.\n- [ ] I have added the necessary testing to prove my fix is effective/my feature works (or I did not modify functionality).\n- [ ] I have added necessary documentation about the functionality in an appropriate .md file.\n- [ ] I have appropriately commented any code I have modified\n\n### Short description of what this PR does:\n- \n- \n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.837890625,
          "content": "# notes [![Build Status](https://github.com/pimterry/notes/workflows/CI/badge.svg)](https://github.com/pimterry/notes/actions)\nSimple delightful note taking, with none of the lock-in.\n\n[![Asciicast demo](asciicast.gif)](https://asciinema.org/a/2pmdb9vyv71skgwx4r7mlnea8?speed=2&t=1&autoplay=1)\n\nThis demo uses zsh, vim and dropbox, but don't panic, that's just me. `notes` will work just fine with whatever other text editor, shell and syncing solution you feel like.\n\n## Why do I want this?\n\nYou already have a tool that backs up and syncs your data (be it Dropbox, iCloud, Seafile or whatever). You already have a text editor on your desktop, your laptops, your phone and that tablet you've forgotten about.\n\nYou want to take notes.\n\nYou could use a web X.0 note taking app that reimplements all of that from scratch (poorly). You could tie yourself to a tool that holds all your data for you in its own brand-new format, locks you into its (often bloated) UI, and then steadily removes features unless you start paying (hey Evernote). You don't have to.\n\nInstead, you could have a simple folder full of simple text files, synced with your sync-thing of choice, edited with your edit-thing of choice. It's easy to understand, easy to use, and accessible from a million other new tools too whenever you next fancy a change. You can do this with little more than windows explorer and notepad, but it's nice to have a specialised tool to add on top and make this a little neater where you can.\n\n**That's where `notes` comes in. Bring your own data syncing, bring your own text editor, put your notes in good old fashioned files, and `notes` will give you a CLI tool to neatly glue it all together.**\n\nThis is just one tool in the chain. `notes` is a command line tool, and some people will want a proper UI, or a web interface, or something that works on mobile. You can use this in one place and solve every other step in that chain any other way you like though &mdash; there's no shortage of simple file browsers and text editors that'll get the job done on any platform you like.\n\n## How do I install this?\n\n### Automatic:\n\n```bash\ncurl -Ls https://raw.githubusercontent.com/pimterry/notes/latest-release/install.sh | sudo bash\n```\nThis will install `notes`, a default configuration, a man page, and bash completion if possible.\n\n```bash\ncurl -Ls https://raw.githubusercontent.com/pimterry/notes/latest-release/install.sh | PREFIX=$HOME bash\n```\nFor non-root installation(user directory).\n\n### Manual:\n\nDownload `notes`, `chmod +x`, put it in your `$path`. This will probably do it:\n\n```bash\ncurl https://raw.githubusercontent.com/pimterry/notes/latest-release/notes > /usr/local/bin/notes && chmod +x /usr/local/bin/notes\n```\n\n#### Installing auto completion\n\n`notes` includes auto completion, to let you tab-complete commands and your note names. This requires Bash > 4.0 and [bash-completion](https://github.com/scop/bash-completion), Zsh, or Fish-shell to be installed - it's probably available from your friendly local package manager.\n\nTo enable completion for notes, copy the completion script into your bash, zsh, or fish completion directory, and it should be automatically loaded. The bash completion directory is `/usr/share/bash-completion/completions/` on a typical Debian install, or `/usr/local/etc/bash_completion.d/` on OSX with `bash-completion` from homebrew. The zsh completion directory is `/usr/share/zsh/functions/Completion/` in Linux. The fish completion directory is `~/.config/fish/completions` or `/etc/fish/completions`. You may be able to find your own bash completion directory by running the following command:\n\n    pkg-config --variable=completionsdir bash-completion\n\nInstalling the completions might be as follows:\n\n**Bash**\n\n```bash\ncurl https://raw.githubusercontent.com/pimterry/notes/latest-release/notes.bash_completion > /usr/share/bash-completion/completions/notes\n```\n\n**Zsh**\n\nOn *buntu based distros and OSX:\n```bash\ncurl -L https://raw.githubusercontent.com/pimterry/notes/latest-release/_notes > /usr/local/share/zsh/site-functions/_notes\n```\n\nOn other Unix distros:\n\n```bash\ncurl -L https://raw.githubusercontent.com/pimterry/notes/latest-release/_notes > /usr/share/zsh/site-functions/_notes\n```\n**Fish**\n\n```fish\ncurl -L https://raw.githubusercontent.com/pimterry/notes/latest-release/notes.fish > ~/.config/fish/completions/notes.fish\n```\n\nYou'll need to open a new shell for this to take effect.\n\n## What if I want to uninstall this?\nIf you used the automated install script to install notes, you can uninstall it the same way, by running:\n```bash\ncurl -L https://raw.githubusercontent.com/pimterry/notes/latest-release/install.sh | bash -s -- uninstall\n```\n\n## How do I configure this?\n\nBy default your notes live in ~/notes, but you can change that to anywhere you like by setting the `$NOTES_DIRECTORY` environmental variable. See [how do I configure this?](#how-do-i-configure-this) for more details.\n\nTo get started with you'll want to set `$EDITOR` to your favourite text editor, and probably `$NOTES_DIRECTORY` to the directory in which you'd like to use to store your notes (this defaults to `~/notes`). You'll typically want to set these as environment variables in your `.bashrc`, `.zshrc`, or similar. Remember to use `export` command when setting environment variables on the command line in Linux.\n\nThere are also more complex options available. You can set any configuration properties either in the environment, or in a config file (stored in `~/.config/notes/config`), with settings in config overriding those in your environment. This allows you to configure a different `$EDITOR` for notes to everything else, if you like. The config file is a good choice for more complex set ups, but probably not worth worrying about to start with. We've included an example config in this repo for you ([config](config)) that you can copy if you like.\n\n### What are the configuration options?\n\n* `QUICKNOTE_FORMAT` changes the way that quicknotes are generated. The string formatted using the `date` command.\n* `NOTES_EXT` changes the default extension that notes are saved with.\n* `TEMPLATES_DIR` changes the directory in which templates are stored.\n* `NOTES_DIRECTORY` changes the directory in which notes are stored.\n* `EDITOR` can also be overriden here, for `notes` only.\n* `POST_COMMAND` sets the command to run after any modification command (e.g. `open`, `mv`, ...) succeeds\n\n\n## How do I use it?\n\n### `notes new [-t <template-name>] <note-name>`\n\nOpens your `$EDITOR` of choice for a new note, with the given name. The name can include slashes, if you want to put your note in a subfolder. Leave out the name if you want one to be generated for you (e.g. `quicknote-2016-12-21.md` - format configurable with `$QUICKNOTE_FORMAT`). If you want to place a quicknote in a subfolder, use a trailing slash: `notes new subfolder/`. Shorthand alias also available with `notes n`.\n\nIf you pass the `-t` flag to `notes new`, the note will be created from a template. The template is a file in your notes directory, with the same name as the template name you pass in. For example, if you have a template called `meeting-notes` in your notes directory, you can create a new note from that template with `notes new -t meeting-notes new-file-name`. This will open your `$EDITOR` with the contents of that template file, and you can edit it and save it as a new note.\n\nIf you do not supply an extension in `note-name`, it will be automatically appended with the default file extension (e.g. \"newnote\" will become \"newnote.md\"). However, if you include a one-to-four-letter file extension, notes will use that extension when creating the file (e.g. \"newnote.tex\" is created as \"newnote.tex\"; not \"newnote.md\", or \"newnote.tex.md\").\n\n### `notes find <part-of-a-note-name>`\n\nSearches note filenames and paths for the given string, and returns every single match. If no pattern is specified, this returns every single note. Shorthand alias also available with `notes f`.\n\n### `notes grep <part-of-some-note-content>`\n\nSearches all note content for the given string and returns all the matches. Shorthand alias also available with `notes g`.\n\n### `notes search <part-of-a-note-name-or-note-content>`\n\nSearches all note content and note filenames for the given string and returns all the matches. Shorthand alias also available with `notes s`.\n\n### `notes ls <directory>`\n\nLists note names and note directories at a single level. Lists all top level notes and directories if no path is provided, or the top-level contents of a directory if one is provided. Automatically ignores hidden files or filenames ending with `~` (Vim backup files).\n\n### `notes open`\n\nOpens your notes folder in your default configured file explorer. Shorthand alias also available with `notes o`.\n\n### `notes open <note-name>`\n\nOpens a given note in your `$EDITOR`. Name can be an absolute path, or a relative path in your notes (.md suffix optional). Shorthand alias also available with `notes o`.\n\nIf no file-suffix is given in `note-name`, the notes will attempt to open `note-name.md` (or whatever your default suffix is set to). However, if the note-name is given an suffix, the default suffix will not be appended (e.g. `notes open note-name.txt` will open `note-name.txt`; not `note-name.md` or `note-name.txt.md`).\n\n### `notes append <note-name> [message]`\n\nAppends `message` to the `note-name` note. If this note does not exist, a new note of <note-name> will be created. This command also accepts stdin via piping. An example would be `echo \"hello\" | notes append <note-name>` Shorthand alias also available with `notes a`.\n\n### `notes mv <note-name> <destination>|<directory>`\n\nRenames a given note to destination or moves the note to directory. Name can be an absolute path, or a relative path in your notes (.md suffix optional). Destination and directory have to be a relative path in your notes.\n\n### `notes rm [-r | --recursive] <note-name>`\n\nRemoves the given note if it exists. If `-r` or `--recursive` is given, deletes the folders/notes recursively.\n\n### `notes cat <note-name>`\nDisplays the note. Shorthand alias also available with `notes c`.\n\n### `notes grep/find <pattern> | notes open`\n\nCombine these together! This opens each matching note in your `$EDITOR` in turn.\n\n### `notes realpath [note-name]`\n\nDisplays the path to the note name, if provided. Displays the root path to all notes otherwise.\n\n## Tell me of the future\n\nAll the above works. Here's what's coming next:\n\n- [ ] More interesting and nicer looking file/grep search result formatting, perhaps only when not piping? (https://github.com/pimterry/notes/issues/27)\n- [ ] Make the file extension optional (https://github.com/pimterry/notes/issues/24)\n- [ ] Interactive mode? `notes` could open a scrollable list of notes, open your editor when you pick one, and reappear after you close it. (https://github.com/pimterry/notes/issues/17)\n- [ ] Tree view (https://github.com/pimterry/notes/issues/26)\n- [ ] Easy way to see short notes snippets in find/grep/tree? Could be option (`--snippets`) or by piping to a command (`notes find | notes snippets`). Maybe call it `head`? (https://github.com/pimterry/notes/issues/22)\n- [ ] Version control - probably by finding an easy (optional) way to integrate this automatically with Git (https://github.com/pimterry/notes/issues/12)\n\n## I want to help\n\nGreat! Jump in. Feel free to play around, open an issue with new feature ideas or open PRs for fixes and improvements. Do check with an issue first if you're planning to do anything substantial to avoid disappointment.\n\nRemember that `notes` is intended to be a small toolbox of commands - if it's possible to build your extension as an independent wrapper building on the existing notes commands, that's probably a better first step. Create new functionality on top of `notes` and then file issues to extend `notes` to better support that wrapper, or to merge your wrapper in as a built-in command later, once you're sure it works and it's useful.\n\nIf you want to get the code locally you'll need to:\n\n```bash\ngit clone <your fork>\ngit submodule update --init --recursive\n./test.sh # Check the tests work before you make any changes\n```\n\nIf you install [`entr`](http://entrproject.org/) you can also run `./dev.sh`, which will watch all files within the project directory, and rerun tests any time they change.\n\nIf you submit a PR, please make sure it:\n\n* Doesn't break any existing tests\n* Adds new tests, if appropriate\n* Adds new documentation, if appropriate\n\n### Release process\n\nTo build a new release of `notes`:\n\n* `export NEW_VERSION=\"X.Y.Z\"` (replacing X.Y.Z with the appropriate new version)\n* Run:\n    ```\n    # Update the version number in the source\n    sed -i -e \"s/notes_version=.*/notes_version=\\\"$NEW_VERSION\\\"/g\" notes\n\n    # Commit, tag & push the new version\n    git add notes\n    git commit -m $NEW_VERSION\n    git tag $NEW_VERSION\n    git push origin master --tags\n\n    # Mark this version as the latest release\n    git checkout -B latest-release\n    git push --force origin latest-release\n    git checkout -\n    ```\n"
        },
        {
          "name": "_notes",
          "type": "blob",
          "size": 1.720703125,
          "content": "#compdef notes\n# ------------------------------------------------------------------------------\n# Description\n# -----------\n#\n#  Simple delightful note taking, with more unix and less lock-in. (https://github.com/pimterry/notes)\n#\n# ------------------------------------------------------------------------------\n# Authors\n# -------\n#\n#  * pimterry et al.\n#\n# ------------------------------------------------------------------------------\n\n__notes_cmd ()\n{\n  local -a list\n  list=(\n    new:'Create new file'\n    ls:'<pattern> List notes by path'\n    find:'[pattern] Search notes by filename and path'\n    grep:'<pattern> Search notes by content'\n    search:'[pattern] Search notes by filename or content'\n    open:'<name> Open a notes for editing by full name'\n    append:'<name> [message] Appends a note. Will use stdin if no message is given'\n    rm:'[-r | --recursive] <name> Remove note, or folder if -r or --recursive is given]'\n    cat:'<name> Display a note by name'\n    --version:'Show version'\n    --help:'Show usage'\n  )\n  _describe -t sub-commands 'sub commands' list && _ret=0\n}\n\n_notes ()\n{\n  # Look for configuration file at ~/.config/notes/config and use it\n  if [ -f ~/.config/notes/config ]; then\n      . ~/.config/notes/config\n  fi\n\n  local configured_dir=${NOTES_DIRECTORY%/}\n  local note_dir=\"${configured_dir:-$HOME/notes}\"\n\n  if (($CURRENT == 2)); then\n    _alternative 'sub-commands:files:__notes_cmd' && _ret=0\n  elif (($CURRENT == 3)); then\n    case $words[2] in\n      open|o|rm|cat)\n        _path_files -W \"${note_dir}\" && _ret=0;;\n      new|n|ls)\n        _path_files -W \"${note_dir}\" -/ && _ret=0;;\n    esac\n  elif (($CURRENT >= 3)); then\n    case $words[2] in\n      rm)\n        _path_files -W \"${note_dir}\" && _ret=0;;\n    esac\n  fi\n}\n"
        },
        {
          "name": "asciicast.gif",
          "type": "blob",
          "size": 743.4833984375,
          "content": null
        },
        {
          "name": "config",
          "type": "blob",
          "size": 0.5810546875,
          "content": "# This is an example configuration file for notes\n# To use it, copy to ~/.config/notes/config\n# This config is case sensitive\n\n# Set the editor that notes are opened with\n# EDITOR=nano\n\n# Change the quicknote format to get rid of the word \"quicknote\"\n# QUICKNOTE_FORMAT=\"%Y-%m-%d\"\n\n# Set extension to plain txt instead of markdown\n# NOTES_EXT=\"txt\"\n\n# Define the directory where notes are stored\n# NOTES_DIRECTORY=~/notes\n\n# Define the directory where templates are stored\n# TEMPLATES_DIR=.templates\n\n# Define command to run after modification command\n# POST_COMMAND=\"/path/to/custom_script.sh\"\n"
        },
        {
          "name": "dev.sh",
          "type": "blob",
          "size": 0.1064453125,
          "content": "# Run this file (with 'entr' installed) to watch files and rerun tests on changes\nls -d **/* | entr ./test.sh"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 1.033203125,
          "content": "#!/bin/sh\n\n# This is an install script for notes\n\n# This has to be defined after root elevation or script will fail.\nfunction assertInstalled() {\n    for var in \"$@\"; do\n        if ! which $var &> /dev/null; then\n            echo \"$var is required but not installed, exiting.\"\n            exit 1\n        fi\n    done\n}\n\n# Make sure we have everything actually installed that we need to install this.\necho \"Checking for dependencies...\"\n    assertInstalled bash curl tar mktemp install make\n\n# Variable Definitions go here. \nuser_home=`eval echo ~$SUDO_USER`\nextract_dir=$(mktemp -d /tmp/notes.XXXXX)\n\necho \"Downloading and extracting Notes from Repository...\"\n    curl -L https://api.github.com/repos/pimterry/notes/tarball/latest-release | tar -xzp -C $extract_dir --strip-components=1\nif [ \"$1\" != \"uninstall\" ]; then\n    echo \"Installing notes...\"\n    cd $extract_dir && make USERDIR=$user_home\nelse\n    echo \"Uninstalling notes...\"\n    cd $extract_dir && make uninstall USERDIR=$user_home\nfi\necho \"Cleaning up...\"\n    rm -rf $extract_dir\necho \"All done.\"\n"
        },
        {
          "name": "notes",
          "type": "blob",
          "size": 11.6494140625,
          "content": "#!/usr/bin/env bash\n\n# Version\nnotes_version=\"1.4.0\"\n\n# Default Date string before config\nQUICKNOTE_FORMAT=\"quicknote-%Y-%m-%d\"\nNOTES_EXT=\"md\"\nTEMPLATES_DIR=\".templates\"\n# Look for configuration file at ~/.config/notes/config and use it\nif [ -f ~/.config/notes/config ]; then\n    . ~/.config/notes/config\nfi\n\nconfigured_dir=${NOTES_DIRECTORY%/} # Remove trailing slashes\nnotes_dir=\"${configured_dir:-$HOME/notes}\"\nescaped_notes_dir=\"$(printf \"$notes_dir\" | sed -e 's/[]\\/$*.^|[]/\\\\&/g')\"\n\n# Make sure the notes directory actually exists, and create it if it doesn't\nif ! $(mkdir -p \"$notes_dir\"); then\n    echo \"Could not create directory $notes_dir, please update your \\$NOTES_DIRECTORY\" >&2\n    exit 1\nfi\n\n# If no $EDITOR, look for `editor` (symlink on debian/ubuntu/etc)\nif [ -z \"$EDITOR\" ] && type editor &>/dev/null; then\n    EDITOR=editor\nfi\n\nwithout_notes_dir() {\n    cat | sed -e \"s/^$escaped_notes_dir//g\" | sed -E \"s/^\\/+//g\"\n}\n\nls_notes() {\n    local ls_output=$(ls -p \"$notes_dir/$*\" 2>&1 | grep -v \"~$\")\n    local ls_result=$?\n    local formatted_output\n\n    if [ $# -gt 0 ]; then\n        local path_prefix=$(printf \"${*%/}\" | sed -e 's/[]\\/$*.^|[]/\\\\&/g')\n        formatted_output=$(printf \"$ls_output\" | sed -E \"s/^/$path_prefix\\//\")\n    else\n        formatted_output=$ls_output\n    fi\n\n    if [[ $ls_result == 0 && \"$formatted_output\" ]]; then\n        printf \"$formatted_output\\n\"\n        return 0\n    else\n        return 2\n    fi\n}\n\nsearch_filenames_and_contents() {\n    if [ \"$#\" -gt 0 ]; then\n        find_output=$(find \"$notes_dir\" -type f -exec bash -c \\\n            \"shopt -s nocasematch\n            grep -il \\\"$*\\\" \\\"{}\\\" || if [[ \\\"{}\\\" =~ \\\"$*\\\" ]]; then\n                echo \\\"{}\\\";\n            fi\" \\;\\\n        )\n    else\n        find_output=$(find \"$notes_dir\" -type f)\n    fi\n    find_result=$?\n    formatted_output=$(printf \"$find_output\" | without_notes_dir | sort)\n\n    if [[ $find_result == 0 && \"$formatted_output\" ]]; then\n        printf \"$formatted_output\\n\"\n        return 0\n    else\n        return 2\n    fi\n}\n\nfind_notes() {\n    local find_output=$(find \"$notes_dir\" -ipath \"$notes_dir/*$**\" -type f 2>&1)\n    local find_result=$?\n    local formatted_output=$(printf \"$find_output\" | without_notes_dir | sort)\n\n    if [[ $find_result == 0 && \"$formatted_output\" ]]; then\n        printf \"$formatted_output\\n\"\n        return 0\n    else\n        return 2\n    fi\n}\n\ngrep_notes() {\n    if [ ! \"$#\" -gt 0 ]; then\n        printf \"Grep requires a pattern, but none was provided.\\n\"\n        return 1\n    fi\n\n    local grep_output=$(grep -r \"$notes_dir\" -li -e \"$*\" 2>&1)\n    local grep_result=$?\n    local formatted_output=$(printf \"$grep_output\" | without_notes_dir | sort)\n\n    if [[ $grep_result == 0 && \"$formatted_output\" ]]; then\n        printf \"$formatted_output\\n\"\n        return 0\n    else\n        return 2\n    fi\n}\n\ngenerate_name() {\n    local append_num=0\n    local format_string=\"`date +$QUICKNOTE_FORMAT`\"\n    # Initial test has no append\n    local resolved_name=$format_string\n    while [[ -e \"$notes_dir/$resolved_name.$NOTES_EXT\" ]]\n    do\n        append_num=$[$append_num+1]\n        resolved_name=$format_string.$append_num\n    done\n    printf $resolved_name\n}\n\nnew_note() {\n    local template_path=\"\" # Either empty (no template) or the path to the template we'll use\n    if [[ \"$1\" == \"-t\" ]]; then\n        shift\n\n        local template_name=\"$1\"\n        if [[ $template_name == \"\" ]]; then\n            printf \"Error: Template name is missing.\\n\"\n            exit 1\n        fi\n        shift\n\n        local template_folder=\"$notes_dir/$TEMPLATES_DIR\"\n\n        if [[ ! -d \"$template_folder\" ]]; then\n            printf \"Template folder not found: $template_folder\\n\"\n            exit 1\n        fi\n\n        if [[ ! \"$template_name\" == *.$NOTES_EXT ]]; then\n            template_name=\"$template_name.$NOTES_EXT\"\n        fi\n\n        template_path=\"$template_folder/$template_name\"\n        if [[ ! -e \"$template_path\" ]]; then\n            printf \"Template not found\\n\"\n            printf \"You can create it by running: notes new .templates/$template_name\\n\"\n            exit 1\n        fi\n    fi\n\n    local note_name=\"$*\"\n    if [[ $note_name == \"\" ]]; then\n        note_name=\"$(generate_name)\"\n    fi\n\n    if echo \"$note_name\" | grep \"/$\" &> /dev/null; then\n        note_name=\"${note_name}/$(generate_name)\"\n    fi\n\n    mkdir -p \"$(dirname \"$notes_dir/$note_name\")\"\n\n    if [[ \"$template_path\" != \"\" ]]; then\n        local note_path=$(get_full_note_path \"$note_name\")\n        cp \"$template_path\" \"$note_path\"\n    fi\n\n    open_note \"$note_name\"\n}\n\nremove_note() {\n    local rm_args=()\n    if [[ \"$1\" == \"-r\" || \"$1\" == \"--recursive\" ]]; then\n        # -r is more portable than recursive, supported in some envs e.g. OSX, Busybox\n        rm_args+=(\"-r\")\n        shift\n    fi\n\n    if [ ! \"$#\" -gt 0 ]; then\n        printf \"Remove requires a file or folder, but none was provided.\\n\"\n        return 1\n    fi\n\n    local note_name=\"$*\"\n    local to_remove=\"$notes_dir/$note_name\"\n\n    if [ ! -f \"$to_remove\" ] && [ -f \"$notes_dir/$note_name.$NOTES_EXT\" ]; then\n        # append default extension only if no file exists with exact filename given\n        to_remove=\"$notes_dir/$note_name.$NOTES_EXT\"\n    fi\n    rm \"${rm_args[@]}\" \"$to_remove\"\n}\n\nhandle_multiple_notes() {\n    local cmd=$1\n\n    if [[ -p /dev/stdin ]]; then\n        read -d'\\n' note_names\n        while read note_name; do\n            ${cmd}_note \"$note_name\"\n        done <<< \"$note_names\"\n    else\n        ${cmd}_note \"${@:2}\"\n    fi\n}\n\nget_full_note_path() {\n    local note_path=$1\n\n    # first check if file exists\n    if [ -f \"$note_path\" ]; then # note path given is good absolute or relative path\n        note_path=\"$note_path\"\n    elif [ -f \"$notes_dir/$note_path\" ]; then # exists in notes_dir\n        note_path=\"$notes_dir/$note_path\"\n    elif [ -f \"$notes_dir/$note_path.$NOTES_EXT\" ]; then # note with this name and default extension exists\n        note_path=\"$notes_dir/$note_path.$NOTES_EXT\"\n    elif echo \"$note_path\" | grep '[.][A-Za-z]\\{1,4\\}$' &>/dev/null; then # given name has a 1-4 letter extension\n        note_path=\"$notes_dir/$note_path\"\n    else\n        if [[ \"$note_path\" != *.$NOTES_EXT ]]; then\n            note_path=\"$note_path.$NOTES_EXT\"\n        fi\n        note_path=\"$notes_dir/$note_path\"\n    fi\n\n    echo \"$note_path\"\n}\n\nopen_note() {\n    local note_path=$1\n\n    if [[ -z \"$note_path\" ]]; then\n        open \"$notes_dir\"\n        return\n    fi\n\n    if [ -z \"$EDITOR\" ]; then\n        printf \"Please set \\$EDITOR to edit notes\\n\"\n        exit 1\n    fi\n\n    note_path=$( get_full_note_path \"$note_path\" )\n\n    if bash -c \": >/dev/tty\" >/dev/null 2>/dev/null; then\n        $EDITOR \"$note_path\" </dev/tty\n    else\n        $EDITOR \"$note_path\"\n    fi\n}\n\nappend_note() {\n    local source_note_path=$( get_full_note_path \"$1\" )\n    local to_append=\"${@:2}\"\n\n    # If no note name was provided, exit\n    if [[ -z \"$1\" ]]; then\n        printf \"Append requires a name, but none was provided.\\n\"\n        exit 1\n    fi\n\n    # If note doesn't exist, make sure the directory does\n    if [[ ! -e \"$source_note_path\" ]]; then\n        mkdir -p \"$(dirname \"$source_note_path\")\"\n    fi\n\n    # if to_append is empty, check stdin\n    if [[ -z \"$to_append\" ]] && [[ -p /dev/stdin ]]; then\n        to_append=$(cat)\n    fi\n\n    # If to_append is *still* empty, report an error\n    if [[ -z \"$to_append\" ]]; then\n        printf \"No text was provided to append\\n\"\n        exit 1\n    fi\n\n    echo \"$to_append\" >> \"$source_note_path\"\n}\n\nmove_note() {\n    local source_note_path=$( get_full_note_path \"$1\" )\n    local dest_or_dir_path=$2\n\n    if [[ ! -e \"$source_note_path\" ]]; then\n        printf \"mv requires a source note that exists\\n\"\n        exit 1\n    fi\n\n    if [[ -z \"$dest_or_dir_path\" ]]; then\n        printf \"mv requires a destination name or folder\\n\"\n        exit 1\n    fi\n\n    dir_path=\"$notes_dir/$dest_or_dir_path\"\n    if [[ -d \"$dir_path\" ]]; then\n        mv $source_note_path $dir_path\n        return\n    fi\n\n    local dest_path=$( get_full_note_path \"$dest_or_dir_path\" )\n    mkdir -p \"$( dirname $dest_path)\"\n    mv $source_note_path $dest_path\n}\n\ncat_note() {\n    local note_path=$1\n\n    if [[ -z \"$note_path\" ]]; then\n        printf \"Cat requires a name, but none was provided.\\n\"\n        exit 1\n    fi\n\n    note_path=$( get_full_note_path \"$note_path\" )\n\n    cat \"$note_path\"\n}\n\nrealpath() {\n    local note_path=$1\n\n    # If no note name was provided, return notes directory\n    if [[ -z \"$note_path\" ]]; then\n        note_path=$notes_dir\n    else # otherwise, get full path of note\n        note_path=$( get_full_note_path \"$note_path\" )\n    fi\n\n    echo \"$note_path\"\n}\n\nusage() {\n  local name=$(basename $0)\n\tcat <<EOF\n$name is a command line note taking tool.\n\nUsage:\n    $name new|n [-t <template>] <name>    # Create a new note, if -t is given, use template\n    $name ls <pattern>                    # List notes by path\n    $name find|f [pattern]                # Search notes by filename and path\n    $name grep|g <pattern>                # Search notes by content\n    $name search|s [pattern]              # Search notes by filename or content\n    $name open|o                          # Open your notes directory\n    $name open|o <name>                   # Open a note for editing by full name\n    $name append|a <name> [message]       # Appends a note. Will use stdin if no message is given\n    $name mv <source> <dest>|<directory>  # Rename a note, or move a note when a directory is given\n    $name rm [-r | --recursive] <name>    # Remove note, or folder if -r or --recursive is given\n    $name cat|c <name>                    # Display note\n    $name realpath [name]                 # Display full path of note, or notes directory if no name is given\n    echo <name> | $name open|o            # Open all note filenames piped in\n    echo <name> | $name cat               # Display all note filenames piped in\n    $name --help                          # Print this usage information\n\n'command|c' means you can use 'command' or the equivalent shorthand alias 'c'\n\nYour notes directory is $notes_dir. You can\noverride this by setting \\$NOTES_DIRECTORY to your preferred path.\nEOF\n}\n\nversion() {\n  local name=$(basename $0)\n\tcat <<EOF\n$name $notes_version\nEOF\n}\n\nmain() {\n    local ret=0\n    local cmd=\"\"\n    # variable to indicate whether it's a modification command\n    local modified=0\n\n    if [ -z \"$1\" ]; then\n        printf \"No command specified\\n\\n\"\n        usage\n        exit 1\n    fi\n\n    case \"$1\" in\n        \"new\"|\"n\" )\n            cmd=\"new_note\"\n            modified=1\n            ;;\n        \"ls\" )\n            cmd=\"ls_notes\"\n            ;;\n        \"search\"|\"s\" )\n            cmd=\"search_filenames_and_contents\"\n            ;;\n        \"find\"|\"f\" )\n            cmd=\"find_notes\"\n            ;;\n        \"grep\"|\"g\" )\n            cmd=\"grep_notes\"\n            ;;\n        \"open\"|\"o\" )\n            cmd=\"handle_multiple_notes open\"\n            modified=1\n            ;;\n        \"append\"|\"a\" )\n            cmd=\"append_note\"\n            modified=1\n            ;;\n        \"mv\" )\n            cmd=\"move_note\"\n            modified=1\n            ;;\n        \"rm\" )\n            cmd=\"remove_note\"\n            modified=1\n            ;;\n        \"cat\" | \"c\" )\n            cmd=\"handle_multiple_notes cat\"\n            ;;\n        \"realpath\" )\n            cmd=\"realpath\"\n            ;;\n        --help | -help | -h )\n            cmd=\"usage\"\n            ;;\n        --version | -version )\n            cmd=\"version\"\n            ;;\n        * )\n            printf \"$1 is not a recognized notes command.\\n\\n\"\n            cmd=\"usage\"\n            ret=1\n            ;;\n    esac\n    shift\n\n    $cmd \"$@\"\n    ret=$[$ret+$?]\n\n    # run POST_COMMAND hook when modification cmd succeeds\n    if [ $ret -eq 0 ] && [ $modified -eq 1 ] && [ -n \"$POST_COMMAND\" ]; then\n        eval \"$POST_COMMAND\"\n    fi\n\n    exit $ret\n}\nmain \"$@\"\n\n"
        },
        {
          "name": "notes.1",
          "type": "blob",
          "size": 2.4130859375,
          "content": ".TH NOTES 1\n.SH NAME\nnotes \\ - Simple delightful note taking, with more unix and less lock-in.\n.SH SYNOPSIS\n.B notes\n\\fICOMMAND\\fR\n.SH DESCRIPTION\n.B notes\nis a simple command line tool that makes note taking simpler.\nWhen run without a command, the help screen will appear and will offer a brief\ndescription of availible commands.\n\n\\fBnotes\\fR will run the default editor for your distribution when opening a\nnote. You can set $EDITOR in your shell to override it.\n\\fBnotes\\fR uses a configuration file located at \\fB~/.config/notes/config\\fR.\nThis file overrides any settings in your rc file.\n.SH COMMANDS\n.TP\n.BR new \", \" n \" \" \"\\fR[\\fB\\-t\\fR] \" \\fR[\\fBTEMPLATE\\fR] \\fR[\\fINAME\\fR]\nOpen your text editor with a new note, with the given name.\nIf no name is given, a quick note will be created with an auto-generated\nname. If the \\-t option is provided, the specified TEMPLATE will be used for the new note.\n.TP\n.BR find \", \" f \" \" \\fR[\\fIPATTERN\\fR]\nSearches for notes using the given pattern, returning all matches. If no\npattern is given, returns every note.\n.TP\n.BR grep \", \" g \" \" \\fIPATTERN\\fR\nSearches the contents of all notes for the given pattern. Returns all matches.\n.TP\n.BR search \", \" s \" \" \\fIPATTERN\\fR\nCombination of find and grep.\n.TP\n.BR ls \" \" \\fR[\\fIDIRECTORY\\fR]\nLists all notes within \\fIDIRECTORY\\fR. Lists contents of $NOTES_DIRECTORY if\nno path is provided.\n.TP\n.BR open \", \" o\nOpens $NOTES_DIRECTORY in your file explorer.\n.TP\n.BR open \", \" o \" \"\\fINAME\\fR\nOpens note \\fINAME\\fR using your configured editor. \\fINAME\\fR can either be an\nabsolute path or relative to $NOTES_DIRECTORY.\n.TP\n.BR append \", \" a \" \"\\fINAME\\fR \" [\" \\fIMESSAGE\\fR]\nAppends \\fINAME\\fR with text \\fIMESSAGE\\fR if given. If no \\fIMESSAGE\\fR is\ndefined, it will be taken from stdin. Stdin input does not work\nin interactive mode (The input must be piped in).\n.TP\n.BR rm \" \"\\fR[\\fB\\-r\\fR | \\fB\\-\\-recursive\\fR] \" \"\\fINAME\\fR\nRemoves \\fINAME\\fR. If \\-r or \\-\\-recursive is given, folders will be removed.\n.TP\n.BR cat \" \" \\fINAME\\fR\nDisplay note \\fINAME\\fR. \\fINAME\\fR can either be an absolute path or relative\nto $NOTES_DIRECTORY.\n.SH AUTHORS\nNotes was created by Tim Perry, who is still the maintainer. Numerous\ncontributions have been submitted via pull requests on github.\n<\\fBhttp://github.com/pimterry/notes\\fR>.\n\nIf you have a clone of notes.git, the output of \\fBgit-shortlog\\fR(1) and\n\\fBgit-blame\\fR(1) can show you the authors for specific parts of the project.\n\n"
        },
        {
          "name": "notes.bash_completion",
          "type": "blob",
          "size": 1.6689453125,
          "content": "#!/bin/bash\n\n_notes_complete_notes() {\n    # Look for configuration file at ~/.config/notes/config and use it\n    if [ -f ~/.config/notes/config ]; then\n        . ~/.config/notes/config\n    fi\n\n    local configured_dir=${NOTES_DIRECTORY%/} # Remove trailing slashes\n    local notes_dir=\"${configured_dir:-$HOME/notes}\"\n    local OLD_IFS=\"$IFS\"\n    IFS=$'\\n'\n    local items=($(compgen -f \"$notes_dir/$1\" | sort ))\n    IFS=\"$OLD_IFS\"\n    for item in \"${items[@]}\"; do\n        [[ $item =~ /\\.[^/]*$ ]] && continue\n        [[ -d $item ]] && item=\"$item/\"\n        local filename=${item#$notes_dir/}\n        COMPREPLY+=(\"${filename%.md}\")\n    done\n}\n\n_notes_complete_commands() {\n    local valid_commands=\"new find grep open ls rm cat append search\"\n    COMPREPLY=($(compgen -W \"${valid_commands}\" -- \"${1}\"))\n}\n\n_notes()\n{\n    local cur\n\n    COMPREPLY=()   # Array variable storing the possible completions.\n    cur=${COMP_WORDS[COMP_CWORD]}\n\n    if [[ $COMP_CWORD -gt 1 ]]; then\n        case \"${COMP_WORDS[1]}\" in\n            new|n)\n                _notes_complete_notes \"$cur\"\n                ;;\n            find|f)\n                _notes_complete_notes \"$cur\"\n                ;;\n            grep)\n                ;;\n            append|a)\n                _notes_complete_notes \"$cur\"\n                ;;\n            open|o)\n                _notes_complete_notes \"$cur\"\n                ;;\n            cat|c)\n                _notes_complete_notes \"$cur\"\n                ;;\n            ls)\n                _notes_complete_notes \"$cur\"\n                ;;\n        esac\n    else\n        compopt +o nospace\n        _notes_complete_commands \"$cur\"\n    fi\n    return 0\n}\n\ncomplete -o filenames -o nospace -F _notes notes\n"
        },
        {
          "name": "notes.fish",
          "type": "blob",
          "size": 1.1787109375,
          "content": "# Notes completion file for fish shell <https://github.com/pimterry/notes>\n# Place in ~/.config/fish/completions/\n\n# Set some useful local variables\n## lists of commands used by notes\nset -l notes_list_commands o open mv rm cat\nset -l notes_friendly_commands new open find ls rm cat mv grep\nset -l notes_commands n new ls find f grep g search s open o mv rm cat append a\nset -l notes_dir_commands n new grep ls\n\n# NOTES_DIRECTORY\n## use NOTES_DIRECTORY variable if set else...\nif not set -q NOTES_DIRECTORY\n    ## if config file exists, read it\n    if test -e $HOME/.config/notes/config\n        set NOTES_DIRECTORY (string split = (grep \"NOTES_DIRECTORY\" $HOME/.config/notes/config))[2]\n    end\nend\n## in case of failure, use default notes dir\nif not set -q NOTES_DIRECTORY[1]\n    set NOTES_DIRECTORY \"$HOME/notes\"\nend\n\n# FILE COMPLETIONS\ncomplete -c notes -f\ncomplete -c notes -n \"not __fish_seen_subcommand_from $notes_commands\" -a \"$notes_friendly_commands\"\ncomplete -c notes -n \"__fish_seen_subcommand_from $notes_list_commands\" -a \"(notes find|grep -v '~\\$'|sed 's/[.]md\\$//')\"\ncomplete -c notes -n \"__fish_seen_subcommand_from $notes_dir_commands\" -a \"(find $NOTES_DIRECTORY -type d -printf '%P/\\n')\"\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 0.1875,
          "content": "#!/usr/bin/env bash\n\n# Run this file to run all the tests in test/*.bats\n\nparent_path=$( cd \"$(dirname \"${BASH_SOURCE[0]}\")\" ; pwd -P )\ncd \"$parent_path\"\n./test/libs/bats/bin/bats test/*.bats\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}