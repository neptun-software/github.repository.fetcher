{
  "metadata": {
    "timestamp": 1736568218976,
    "page": 73,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "just-containers/s6-overlay",
      "stars": 3872,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0078125,
          "content": "/output\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 0.1025390625,
          "content": "Laurent Bercot ([@skarnet](https://github.com/skarnet))\n\nJohn Regan ([@jprjr](https://github.com/jprjr))\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.205078125,
          "content": "# CHANGELOG for s6-overlay\n\n## Note about minor changes\n\nPlease view the git log to see all the minor changes made to the code. This document only tracks major/breaking changes.\n\n## Major changes\n\n### Version 3.2.0.0\n\n* There is no default global timeout for starting services anymore. Previously,\nif the services took more than 5 seconds to be brought up, they would\nfail; the intent was to detect hanged containers (waiting on a dysfunctional\nnetwork connection, for instance) and make them fail early, but it has\nproven to create more problems than it was solving - so the timeout has\nbeen removed. If you need it, you can, as before, use the `S6_CMD_WAIT_FOR_SERVICES_MAXTIME`\nvariable.\n* More unprivileged configurations are supported: you should now be\nable to use s6-overlay in containers created by Kubernetes, for instance.\n\n### Version 3.1.0.0\n\n* `/etc/s6-overlay/config/global_path` isn't provided or taken into\naccount anymore. Instead, the initial value of PATH for all the services\nis inherited from the `PATH` environment variable, that you can set\nin the Dockerfile.\n* Generated tarballs don't encode the version numbers anymore.\n(The download URLs provided by GitHub still encode the version numbers,\nso there is no possible confusion on what tarball you're downloading.)\n* justc-envdir does not exist anymore: use s6-envdir with the new -L\noption if you need environment variables with unlimited length.\n* `docker stop` now normally exits 0 (or any predefined exit code\nin `/run/s6-linux-init-container-results/exitcode`) instead of 111.\n\n### Version 3.0.0.0\n\n* Completely revamp the build system and the installation system.\n  * Building is now a single `make` invocation.\n  * No more self-extracting installer.\n  * One to five tarballs to be installed, depending on user needs.\n  * Only one of these tarballs is architecture-dependent.\n* Use shell where beneficial. Execline is still used where it makes sense.\n* Take advantage of new skaware.\n  * Stage 1 is now handled by [s6-linux-init](https://skarnet.org/software/s6-linux-init/).\n    * The new `S6_CATCHALL_USER` variable can be used to run the catch-all logger as non-root.\n  * Stage 2 is now handled by [s6-rc](https://skarnet.org/software/s6-rc/).\n    * `fix-attrs`,`cont-init`/`cont-finish`, and `/etc/services.d` are\nstill supported; under the hood, they're run as s6-rc services.\n    * A `user` bundle is provided for users to put all their services in.\n* Move binaries out of the way.\n  * All skaware is installed under `/package` and accessible via `/command`.\n  * All binaries are accessed via PATH resolution, making it transparent.\n  * `/usr/bin` symlinks are provided in optional tarballs.\n  * Some distributions will provide skaware binaries in their own packages;\nthose will likely be accessible via `/bin` or `/usr/bin`, but the overlay\nscripts do not care.\n* All in all this is a complete rewrite of s6-overlay, but the transition\nfrom 2.1.0.2 to 3.0.0.0 should be painless for users.\n\n### Version 2.1.0.2\n\n* Add a new self-extracting installer as an installation\n  option. It works correctly on all distros, whether or not `/bin` is a\n  symlink to `/usr/bin` or a directory.\n\n### Version 2.1.0.0\n\n* Add initial support for Docker's `USER` directive.\n* Add a new binary to the tarball (`s6-overlay-preinit`), and move creating\n  a specific folder from the build-time to runtime.\n\n### Version 2.0.0.1\n\n* Fix issues with shells overwriting the `cd`\n  binary [#278](https://github.com/just-containers/s6-overlay/issues/278)\n  and tarballs having too-loose permissions [#274](https://github.com/just-containers/s6-overlay/issues/274).\n\n### Version 2.0.0.0\n\n* Starting with version `2.0.0.0`, `with-contenv` no longer uses `s6-envdir`, instead it\n  uses [justc-envdir](https://github.com/just-containers/justc-envdir), a small fork that\n  uses the entire contents of the files in the envdir. A new script is introduced, `with-contenv-legacy`,\n  in case you rely on the old behavior.\n\n### Version 1.21.8.0\n\n* Up to and including version `1.21.8.0`, the init system would call `s6-sync` to sync disks when\n  the container exited. This actually syncs all block devices on the hosts, which is\n  likely not what you want to do. As of version `1.22.0.0`, this is disabled by default, see the\n  README on how to re-enable it.\n"
        },
        {
          "name": "CONTRIBUTING",
          "type": "blob",
          "size": 0.2802734375,
          "content": " Please add a Signed-Off-By: line at the end of your commit,\nwhich certifies that you have the right and authority to pass\nit on as an open-source patch, as explicited in the Developer's\nCertificate of Origin available in this project's DCO file,\nor at https://developercertificate.org/\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 0.8447265625,
          "content": "Internet Systems Consortium license\n===================================\n\nCopyright (c) 2021-2024 Laurent Bercot <ska-skaware@skarnet.org>, John Regan <john@jrjrtech.com>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "DCO",
          "type": "blob",
          "size": 1.3876953125,
          "content": "Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n"
        },
        {
          "name": "MOVING-TO-V3.md",
          "type": "blob",
          "size": 6.76953125,
          "content": "\n# Moving from s6-overlay v2 to s6-overlay v3\n\n There are a lot of changes between version 2 of s6-overlay, which was\nthe one used until 2021, and version 3, which was released in January 2022.\n\n This document sums up the most important changes.\n As always, please refer to the latest version of the\n[README.md file](https://github.com/just-containers/s6-overlay/blob/master/README.md)\nfor detailed s6-overlay usage instructions.\n\n Thanks for @alexyao2015 for the initial ideas for this document.\n\n## Immediately visible changes\n\n- s6-overlay is now provided as a series of several tarballs, that you can pick\nand choose depending on the details of how you use s6-overlay. Most people will\nneed *two* tarballs (the architecture-dependent binaries, and the architecture-independent\noverlay scripts).\n  * These tarballs are `.tar.xz` files: to extract them, most distributions\nrequire installing the `xz-utils` package, which is not always provided by\ndefault.\n- Except when specifically built otherwise, commands and scripts provided by s6-overlay\nnow reside under `/command`. This means several things:\n  * The default PATH always contains `/command` as well as `/usr/bin` and `/bin`. You can\nadd directories to that PATH by declaring your own `PATH` variable in the Dockerfile.\n  * s6-overlay commands should *always* be called by their short name, never by an\nabsolute path. You should always trust PATH to do the right thing.\n    + In practice: every time you used something like `/bin/s6-chmod`, change it to\n`s6-chmod` instead. That will work in every situation.\n  * Shebangs, which require absolute paths, are an exception, and need manual editing.\nFor instance, `#!/usr/bin/with-contenv` should be changed to `#!/command/with-contenv`.\n    + To give you time to perform that change incrementally, s6-overlay provides\noptional tarballs that install `/usr/bin/foobar` symlinks to `/command/foobar`.\n- All the user scripts need to be executable: they are now *executed* instead of\n*interpreted by a shell*.\n- The supervision tree now resides in `/run/service`, and you should not attempt to stop it\nwhen you want to exit the container; more generally you should not attempt to send\ncontrol commands to the supervision tree. In particular, you should not try to run\nthe `s6-svscanctl -t /var/run/s6/services` command - it will not work anyway because\nthe supervision tree has changed locations. If you need to exit a container from the\ninside, without your CMD dying (or without having declared a CMD), run the\n`/run/s6/basedir/bin/halt` command instead.\n  * Services that were previously addressed via `/var/run/s6/services/foobar` are now\naddressed via `/run/service/foobar`.\n- The CMD, if any, always used to run under the container environment. This is not\nthe case anymore: just like supervised services, the CMD is now run with a minimal\nenvironment by default, and you need to prepend it with `with-contenv` if you want\nto provide it with the full container environment.\n\n## Service management-related changes\n\nThe container startup process now uses [s6-rc](https://skarnet.org/software/s6-rc/),\nwhich has several benefits over the old method. This impacts the overlay in the\nfollowing ways:\n\n- There is a global timeout for all the services, adjustable via the\n`S6_CMD_WAIT_FOR_SERVICES_MAXTIME` variable. You can disable it via setting this\nvariable to 0.\n- The scripts in `/etc/cont-init.d` are now run as the `up` command of the first service\n(a oneshot); the scripts in `/etc/cont-finish.d` are run as the `down` command of the\nsame service. This means `/etc/cont-init.d` is run as the first thing when the container\nstarts, and `/etc/cont-finish.d` is run as the last thing when the container stops. (This\ndoes not change from the v2 behaviour.)\n  * This means that `/etc/cont-init.d` is subjected to the `S6_CMD_WAIT_FOR_SERVICES_MAXTIME`\ntimeout. Adjust this timeout if your container initialization scripts take a long time\nto run.\n- The service directories in `/etc/services.d` are copied to a subdirectory of `/run` and\nsupervised by s6, as the `up` command of the second service. This means they're started\nafter `/etc/cont-init.d` is run, and they are *not stopped* until the container stops.\nServices declared in `/etc/services.d` are still running when `/etc/cont-finish.d` is\nrun; they are stopped afterwards.\n- Rather than running their services in `/etc/cont-init.d`, `/etc/services.d` and\n`/etc/cont-finish.d`, users can now add s6-rc source definitions for them, so they will\nbe run independently by the service manager. The old way is still supported, and will\ncontinue to be, but we encourage users to switch to the new way.\n  * This has the advantage of supporting both oneshots (scripts that do one thing and\nexit) and longruns (daemons that are supervised with s6), and dependencies can be\ndeclared between services for super flexible ordering; you can also add more\ncomplex service pipelines for multi-step log processing.\n  * The drawback is that it requires following the\n[s6-rc source format](https://skarnet.org/software/s6-rc/s6-rc-compile.html#source),\nwhich is not immediately intuitive. Please read the documentation attentively\nif you want to convert your services to that format. As a quickstart, what you\nneed to know immediately is:\n    + You need a `type` file in the directory, saying whether the service is a\n`oneshot` or a `longrun`.\n    + The source definition directory for a *longrun* looks a lot like a service\ndirectory: it has a `run` script, possibly a `finish` script, etc.\n    + The source definition directory for a *oneshot* is different. It\nneeds an `up` file, but don't write your script in it. Instead, put your\nscript in another executable file, in a place of your choice (for instance\n`/etc/s6-overlay/scripts/foobar`, and just put `/etc/s6-overlay/scripts/foobar`\nin your `up` file. *Be aware that `up` is __not__ a shell script*, and will not\nhonor shebangs; for the details, look for `weird syntax` in the\n[README file](README.md).\n    + To get your service _foo_ properly started at container boot time, you need\nto add it to the `user` bundle: `touch /etc/s6-overlay/s6-rc.d/user/contents.d/foo`.\nAlso, to ensure it's started at the proper time, you should make it depend on\n`base`: `mkdir /etc/s6-overlay/s6-rc.d/foo/dependencies.d && touch\n/etc/s6-overlay/s6-rc.d/foo/dependencies.d/base`.\n- Services are run from their own, temporary, current working directory, instead\nof `WORKDIR`; scripts should now use absolute paths instead of paths relative\nto `WORKDIR`. The CMD, if any, is still run in `WORKDIR`.\n\n## Other changes\n\n - Socklog has been replaced by a `syslogd-overlay` tarball, provided by\ns6-overlay. The tarball expands into a series of s6-rc services implementing\na small syslogd emulation, using a combination of the new `s6-socklog`\nbinary and a `s6-log` service with a complex logging script that dispatches\nlogs the same way syslogd would.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.9287109375,
          "content": "it: all\n\ninclude conf/defaults.mk\n\nifeq ($(strip $(OUTPUT)),)\nOUTPUT := output\nendif\nOUTPUT := $(abspath $(OUTPUT))\nHW := $(if $(findstring arm-linux-musleabihf,$(ARCH)),armhf,$(firstword $(subst -, ,$(ARCH))))\n\ninclude conf/versions\ninclude mk/toolchain.mk\ninclude mk/bearssl.mk\ninclude mk/skaware.mk\n\n.PHONY: it distclean clean all\n\ndistclean:\n\texec rm -rf $(OUTPUT)\n\nclean:\n\tls -1 $(OUTPUT) | grep -vF sources | while read a ; do rm -rf $(OUTPUT)/\"$$a\" & : ; done ; true\n\nall: rootfs-overlay-arch-tarball symlinks-overlay-arch-tarball rootfs-overlay-noarch-tarball symlinks-overlay-noarch-tarball syslogd-overlay-noarch-tarball\n\n\n.PHONY: rootfs-overlay-arch rootfs-overlay-arch-tarball\nrootfs-overlay-arch: $(OUTPUT)/rootfs-overlay-$(ARCH)/package/admin/execline/command/execlineb\nrootfs-overlay-arch-tarball: $(OUTPUT)/s6-overlay-$(HW).tar.xz\n\n$(OUTPUT)/rootfs-overlay-$(ARCH)/package/admin/execline/command/execlineb: skaware-install\n\texec rm -rf $(OUTPUT)/rootfs-overlay-$(ARCH)\n\texec mkdir -p $(OUTPUT)/rootfs-overlay-$(ARCH)\n\texec cp -a $(OUTPUT)/staging-$(ARCH)/package $(OUTPUT)/staging-$(ARCH)/command $(OUTPUT)/rootfs-overlay-$(ARCH)/\n\texec rm -rf $(OUTPUT)/rootfs-overlay-$(ARCH)/package/*/*/include $(OUTPUT)/rootfs-overlay-$(ARCH)/package/*/*/library\n\n$(OUTPUT)/s6-overlay-$(HW).tar.xz: rootfs-overlay-arch\n\texec rm -f $@.tmp\n\tcd $(OUTPUT)/rootfs-overlay-$(ARCH) && tar -Jcvf $@.tmp --owner=0 --group=0 --numeric-owner .\n\texec mv -f $@.tmp $@\n\n.PHONY: symlinks-overlay-arch symlinks-overlay-arch-tarball\nsymlinks-overlay-arch: $(OUTPUT)/symlinks-overlay-arch/usr/bin/execlineb\nsymlinks-overlay-arch-tarball: $(OUTPUT)/s6-overlay-symlinks-arch.tar.xz\n\n$(OUTPUT)/symlinks-overlay-arch/usr/bin/execlineb: rootfs-overlay-arch\n\texec rm -rf $(OUTPUT)/symlinks-overlay-arch\n\texec mkdir -p $(OUTPUT)/symlinks-overlay-arch/usr/bin\n\tfor i in `ls -1 $(OUTPUT)/rootfs-overlay-$(ARCH)/command` ; do ln -s \"../../command/$$i\" $(OUTPUT)/symlinks-overlay-arch/usr/bin/ ; done\n\n$(OUTPUT)/s6-overlay-symlinks-arch.tar.xz: symlinks-overlay-arch\n\texec rm -f $@.tmp\n\tcd $(OUTPUT)/symlinks-overlay-arch && tar -Jcvf $@.tmp --owner=0 --group=0 --numeric-owner .\n\texec mv -f $@.tmp $@\n\n.PHONY: rootfs-overlay-noarch rootfs-overlay-noarch-tarball\nrootfs-overlay-noarch: $(OUTPUT)/rootfs-overlay-noarch/init\nrootfs-overlay-noarch-tarball: $(OUTPUT)/s6-overlay-noarch.tar.xz\n\nTMPDIR1 := $(OUTPUT)/rootfs-overlay-noarch.tmp\n\n$(OUTPUT)/rootfs-overlay-noarch/init: layout/rootfs-overlay/init\n\texec rm -rf $(TMPDIR1)\n\texec mkdir -p $(OUTPUT)\n\texec cp -a layout/rootfs-overlay $(TMPDIR1)\n\tfind $(TMPDIR1) -type f -name .empty -print | xargs rm -f --\n\tfind $(TMPDIR1) -name '*@VERSION@*' -print | while read name ; do mv -f \"$$name\" `echo \"$$name\" | sed -e 's/@VERSION@/$(VERSION)/'` ; done\n\tfind $(TMPDIR1) -type f -size +0c -print | xargs sed -i -e 's|@SHEBANGDIR@|$(SHEBANGDIR)|g; s/@VERSION@/$(VERSION)/g;' --\n\texec ln -s s6-overlay-$(VERSION) $(TMPDIR1)/package/admin/s6-overlay\n\texec mv -f $(TMPDIR1) $(OUTPUT)/rootfs-overlay-noarch\n\n$(OUTPUT)/s6-overlay-noarch.tar.xz: rootfs-overlay-noarch\n\texec rm -f $@.tmp\n\tcd $(OUTPUT)/rootfs-overlay-noarch && tar -Jcvf $@.tmp --owner=0 --group=0 --numeric-owner .\n\texec mv -f $@.tmp $@\n\n.PHONY: symlinks-overlay-noarch symlinks-overlay-noarch-tarball\nsymlinks-overlay-noarch: $(OUTPUT)/symlinks-overlay-noarch/usr/bin/printcontenv\nsymlinks-overlay-noarch-tarball: $(OUTPUT)/s6-overlay-symlinks-noarch.tar.xz\n\n$(OUTPUT)/symlinks-overlay-noarch/usr/bin/printcontenv: rootfs-overlay-noarch\n\texec rm -rf $(OUTPUT)/symlinks-overlay-noarch\n\texec mkdir -p $(OUTPUT)/symlinks-overlay-noarch/usr/bin\n\tfor i in `ls -1 $(OUTPUT)/rootfs-overlay-noarch/command` ; do ln -s \"../../command/$$i\" $(OUTPUT)/symlinks-overlay-noarch/usr/bin/ ; done\n\n$(OUTPUT)/s6-overlay-symlinks-noarch.tar.xz: symlinks-overlay-noarch\n\texec rm -f $@.tmp\n\tcd $(OUTPUT)/symlinks-overlay-noarch && tar -Jcvf $@.tmp --owner=0 --group=0 --numeric-owner .\n\texec mv -f $@.tmp $@\n\n.PHONY: syslogd-overlay-noarch syslogd-overlay-noarch-tarball\nsyslogd-overlay-noarch: $(OUTPUT)/syslogd-overlay-noarch/etc/s6-overlay/s6-rc.d/syslogd/run\nsyslogd-overlay-noarch-tarball: $(OUTPUT)/syslogd-overlay-noarch.tar.xz\n\nTMPDIR2 := $(OUTPUT)/syslogd-overlay-noarch.tmp\n\n$(OUTPUT)/syslogd-overlay-noarch/etc/s6-overlay/s6-rc.d/syslogd/run: layout/syslogd-overlay/etc/s6-overlay/s6-rc.d/syslogd/run\n\texec rm -rf $(TMPDIR2)\n\texec mkdir -p $(OUTPUT)\n\texec cp -a layout/syslogd-overlay $(TMPDIR2)\n\tfind $(TMPDIR2) -type f -name .empty -print | xargs rm -f --\n\tfind $(TMPDIR2) -name '*@VERSION@*' -print | while read name ; do mv -f \"$$name\" `echo \"$$name\" | sed -e 's/@VERSION@/$(VERSION)/'` ; done\n\tfind $(TMPDIR2) -type f -size +0c -print | xargs sed -i -e 's|@SHEBANGDIR@|$(SHEBANGDIR)|g; s/@VERSION@/$(VERSION)/g;' --\n\texec mv -f $(TMPDIR2) $(OUTPUT)/syslogd-overlay-noarch\n\n$(OUTPUT)/syslogd-overlay-noarch.tar.xz: syslogd-overlay-noarch\n\texec rm -f $@.tmp\n\tcd $(OUTPUT)/syslogd-overlay-noarch && tar -Jcvf $@.tmp --owner=0 --group=0 --numeric-owner .\n\texec mv -f $@.tmp $@\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 51.4619140625,
          "content": "**Table of Contents**\n\n- [Quickstart](#quickstart)\n- [Compatibility with v2](#compatibility-with-v2)\n- [Goals](#goals)\n- [Features](#features)\n- [The Docker Way?](#the-docker-way)\n- [Init stages](#init-stages)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [Using `CMD`](#using-cmd)\n  - [Writing a service script](#writing-a-service-script)\n  - [Setting the exit code of the container to the exit code of your main service](#setting-the-exit-code-of-the-container-to-the-exit-code-of-your-main-service)\n  - [Fixing ownership and permissions](#fixing-ownership-and-permissions)\n  - [Executing initialization and finalization tasks](#executing-initialization-and-finalization-tasks)\n  - [Writing an optional finish script](#writing-an-optional-finish-script)\n  - [Logging](#logging)\n  - [Dropping privileges](#dropping-privileges)\n  - [Read-only Root Filesystem](#read-only-root-filesystem)\n  - [Container environment](#container-environment)\n  - [Customizing s6-overlay's behaviour](#customizing-s6-overlay-behaviour)\n  - [syslog](#syslog)\n- [Performance](#performance)\n- [Verifying Downloads](#verifying-downloads)\n- [Notes](#notes)\n- [Releases](#releases)\n  - [Which architecture to use depending on your TARGETARCH](#which-architecture-to-use-depending-on-your-targetarch)\n- [Contributing](#contributing)\n- [Building the overlay yourself](#building-the-overlay-yourself)\n- [Upgrade notes](#upgrade-notes)\n\n# s6-overlay [![Build Status](https://api.travis-ci.org/just-containers/s6-overlay.svg?branch=master)](https://travis-ci.org/just-containers/s6-overlay)\n\ns6-overlay is an easy-to-install (just extract a tarball or two!) set of scripts and utilities\nallowing you to use existing Docker images while using [s6](https://skarnet.org/software/s6/overview.html)\nas a pid 1 for your container and process supervisor for your services.\n\n## Quickstart\n\nBuild the following Dockerfile and try it out:\n\n```\n# Use your favorite image\nFROM ubuntu\nARG S6_OVERLAY_VERSION=3.2.0.3\n\nRUN apt-get update && apt-get install -y nginx xz-utils\nRUN echo \"daemon off;\" >> /etc/nginx/nginx.conf\nCMD [\"/usr/sbin/nginx\"]\n\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp\nRUN tar -C / -Jxpf /tmp/s6-overlay-noarch.tar.xz\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp\nRUN tar -C / -Jxpf /tmp/s6-overlay-x86_64.tar.xz\nENTRYPOINT [\"/init\"]\n```\n\n```\ndocker-host $ docker build -t demo .\ndocker-host $ docker run --name s6demo -d -p 80:80 demo\ndocker-host $ docker top s6demo acxf\nPID                 TTY                 STAT                TIME                COMMAND\n11735               ?                   Ss                  0:00                \\_ s6-svscan\n11772               ?                   S                   0:00                \\_ s6-supervise\n11773               ?                   Ss                  0:00                | \\_ s6-linux-init-s\n11771               ?                   Ss                  0:00                \\_ rc.init\n11812               ?                   S                   0:00                | \\_ nginx\n11814               ?                   S                   0:00                | \\_ nginx\n11816               ?                   S                   0:00                | \\_ nginx\n11813               ?                   S                   0:00                | \\_ nginx\n11815               ?                   S                   0:00                | \\_ nginx\n11779               ?                   S                   0:00                \\_ s6-supervise\n11785               ?                   Ss                  0:00                | \\_ s6-ipcserverd\n11778               ?                   S                   0:00                \\_ s6-supervise\ndocker-host $ curl --head http://127.0.0.1/\nHTTP/1.1 200 OK\nServer: nginx/1.18.0 (Ubuntu)\nDate: Mon, 17 Jan 2022 13:33:58 GMT\nContent-Type: text/html\nContent-Length: 612\nLast-Modified: Mon, 17 Jan 2022 13:32:11 GMT\nConnection: keep-alive\nETag: \"61e56fdb-264\"\nAccept-Ranges: bytes\n\n```\n\n## Compatibility with v2\n\nIf you're migrating from a previous version of s6-overlay (*v2*) to the\nnew version (*v3*), you may need to make some changes to your services\nor the way you use s6-overlay in order for everything to work smoothly.\nThis document tries to be accurate on how v3 works, but we have a\n[separate page](https://github.com/just-containers/s6-overlay/blob/master/MOVING-TO-V3.md)\nlisting the main differences, and things you're likely to notice. Please\nread it if you're in this situation!\n\n## Goals\n\nThe project has the following goals:\n\n* Be usable on top of *any* Docker image\n* Make it easy to create new images, that will operate like any other images\n* Provide users with a turnkey s6 installation that will give them a stable\npid 1, a fast and orderly init sequence and shutdown sequence, and the power\nof process supervision and automatically rotated logs.\n\n## Features\n\n* A simple init process which allows the end-user to execute tasks like initialization (`cont-init.d`),\nfinalization (`cont-finish.d`) and their own services with dependencies between them\n* The s6-overlay provides proper `PID 1` functionality\n  * You'll never have zombie processes hanging around in your container, they will be properly cleaned up.\n* Multiple processes in a single container\n* Able to operate in \"The Docker Way\"\n* Usable with all base images - Ubuntu, CentOS, Fedora, Alpine, Busybox...\n* Distributed as a small number of .tar.xz files depending on what exact functionality you need - to keep your image's number of layers small.\n* A whole set of utilities included in `s6` and `s6-portable-utils`. They include handy and composable utilities which make our lives much, much easier.\n* Log rotating out-of-the-box through `logutil-service` which uses [`s6-log`](https://skarnet.org/software/s6/s6-log.html) under the hood.\n* Some support for Docker's `USER` directive, to run your whole process tree as a specific user. Not compatible with all features, details in the [notes](#notes) section.\n\n## The Docker Way?\n\nOne of the oft-repeated Docker mantras is \"one process per container\", but we disagree.\nThere's nothing inherently *bad* about running multiple processes in a container.\nThe more abstract \"one *thing* per container\" is our policy - a container should do one thing,\nsuch as \"run a chat service\" or \"run gitlab.\" This may involve multiple processes, which is fine.\n\nThe other reason image authors shy away from process supervisors is they believe a process supervisor\n*must* restart failed services, meaning the Docker container will never die.\n\nThis does effectively break the Docker ecosystem - most images run one process that will\nexit when there's an error. By exiting on error, you allow the system administrator to\nhandle failures however they prefer. If your image will never exit, you now need some\nalternative method of error recovery and failure notification.\n\nOur policy is that if \"the thing\" fails, then the container should fail, too.\nWe do this by determining which processes can restart, and which should bring down\nthe container. For example, if `cron` or `syslog` fails, your container can most\nlikely restart it without any ill effects, but if `ejabberd` fails, the container\nshould exit so the system administrator can take action.\n\nOur interpretation of \"The Docker Way\" is thus:\n\n* Containers should do one thing\n* Containers should stop when that thing stops\n\nand our init system is designed to do exactly that. Your images will behave like\nother Docker images and fit in with the existing ecosystem of images.\n\nSee \"Writing an optional finish script\" under the [Usage](#usage) section for details on stopping \"the thing.\"\n\n## Init stages\n\nOur overlay init is a properly customized one to run appropriately in containerized environments.\nThis section briefly explains how stages work but if you want to know how a complete init system\nshould work, you can read this article: [How to run s6-svscan as process 1](https://skarnet.org/software/s6/s6-svscan-1.html)\n\n1. **stage 1**: Its purpose is to set up the image to execute the supervision tree which\nwill handle all the auxiliary services, and to launch stage 2. Stage 1 is where all the\nblack magic happens, all the container setup details that we handle for you so that you don't\nhave to care about them.\n2. **stage 2**: This is where most of the end-user provided files are meant to be executed:\n    1. Execute legacy oneshot user scripts contained in `/etc/cont-init.d`.\n    2. Run user s6-rc services declared in `/etc/s6-overlay/s6-rc.d`, following dependencies\n    3. Copy legacy longrun user services (`/etc/services.d`) to a temporary directory and have s6 start (and supervise) them.\n3. **stage 3**: This is the shutdown stage. When the container is supposed to exit, it will:\n    1. Send a TERM signal to all legacy longrun services and, if required, wait for them to exit.\n    2. Bring down user s6-rc services in an orderly fashion.\n    3. Run any finalization scripts contained in `/etc/cont-finish.d`.\n    4. Send all remaining processes a `TERM` signal. There should not be any remaining processes anyway.\n    5. Sleep for a small grace time, to allow stray processes to exit cleanly.\n    6. Send all processes a `KILL` signal. Then the container exits.\n\n## Installation\n\ns6-overlay comes as a set of tarballs that you can extract onto your image.\nThe tarballs you need are a function of the image you use; most people will\nneed the first two, and the other ones are extras you can use at your\nconvenience.\n\n1. `s6-overlay-noarch.tar.xz`: this tarball contains the scripts\nimplementing the overlay. We call it \"noarch\" because it is architecture-\nindependent: it only contains scripts and other text files. Everyone who\nwants to run s6-overlay needs to extract this tarball.\n2. `s6-overlay-x86_64.tar.xz`: replace `x86_64` with your\nsystem's architecture. This tarball contains all the necessary binaries\nfrom the s6 ecosystem, all linked statically and out of the way of\nyour image's binaries. Unless you know for sure that your image already\ncomes with all the packages providing the binaries used in the overlay,\nyou need to extract this tarball.\n3. `s6-overlay-symlinks-noarch.tar.xz`: this tarball contains\nsymlinks to the s6-overlay scripts so they are accessible via `/usr/bin`.\nIt is normally not needed, all the scripts are accessible via the PATH\nenvironment variable, but if you have old user scripts containing\nshebangs such as `#!/usr/bin/with-contenv`, installing these symlinks\nwill make them work.\n4. `s6-overlay-symlinks-arch.tar.xz`: this tarball contains\nsymlinks to the binaries from the s6 ecosystem provided by the second\ntarball, to make them accessible via `/usr/bin`. It is normally not\nneeded, but if you have old user scripts containing shebangs such as\n`#!/usr/bin/execlineb`, installing these symlinks will make them work.\n5. `syslogd-overlay-noarch.tar.xz`: this tarball contains\ndefinitions for a `syslogd` service. If you are running daemons that\ncannot log to stderr to take advantage of the s6 logging infrastructure,\nbut hardcode the use of the old `syslog()` mechanism, you can extract\nthis tarball, and your container will run a lightweight emulation of a\n`syslogd` daemon, so your syslog logs will be caught and stored to disk.\n\nTo install those tarballs, add lines to your Dockerfile that correspond\nto the functionality you want to install. For instance, most people would\nuse the following:\n```\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp\nRUN tar -C / -Jxpf /tmp/s6-overlay-noarch.tar.xz\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp\nRUN tar -C / -Jxpf /tmp/s6-overlay-x86_64.tar.xz\n```\n\nMake sure to preserve file permissions when extracting (i.e. to use the\n`-p` option to `tar`.)\n\n## Usage\n\nThe project is distributed as a set of standard .tar.xz files, which you extract at the root of your image.\n(You need the xz-utils package for `tar` to understand `.tar.xz` files; it is available\nin every distribution, but not always in the default container images, so you may need\nto `apt install xz-utils` or `apk add xz`, or equivalent, before you can\nexpand the archives.)\n\nAfterwards, set your `ENTRYPOINT` to `/init`.\n\nRight now, we recommend using Docker's `ADD` directive instead of running `wget` or `curl`\nin a `RUN` directive - Docker is able to handle the https URL when you use `ADD`, whereas\nyour base image might not be able to use https, or might not even have `wget` or `curl`\ninstalled at all.\n\nFrom there, you have a couple of options:\n\n* If you want the container to exit when your program exits: run the program as your image's `CMD`.\n* If you want the container to run until told to exit, and your program to be supervised by s6:\nwrite a service script for your program.\n\n### Using `CMD`\n\nUsing `CMD` is a convenient way to take advantage of the overlay. Your `CMD` can be given at\nbuild time in the Dockerfile, or at run time on the command line, either way is fine. It will\nbe run as a normal process in the environment set up by s6; when it fails or exits, the\ncontainer will shut down cleanly and exit. You can run interactive programs in this manner:\nonly the CMD will receive your interactive command, the support processes will be unimpacted.\n\nFor example:\n\n```\nFROM busybox\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp\nRUN tar -C / -Jxpf /tmp/s6-overlay-noarch.tar.xz\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp\nRUN tar -C / -Jxpf /tmp/s6-overlay-x86_64.tar.xz\nENTRYPOINT [\"/init\"]\n```\n\n```\ndocker-host $ docker build -t s6demo .\ndocker-host $ docker run -ti s6demo /bin/sh\n/package/admin/s6-overlay/libexec/preinit: notice: /var/run is not a symlink to /run, fixing it\ns6-rc: info: service s6rc-oneshot-runner: starting\ns6-rc: info: service s6rc-oneshot-runner successfully started\ns6-rc: info: service fix-attrs: starting\ns6-rc: info: service fix-attrs successfully started\ns6-rc: info: service legacy-cont-init: starting\ns6-rc: info: service legacy-cont-init successfully started\ns6-rc: info: service legacy-services: starting\ns6-rc: info: service legacy-services successfully started\n/ # ps\nPID   USER     TIME  COMMAND\n    1 root      0:00 /package/admin/s6/command/s6-svscan -d4 -- /run/service\n   17 root      0:00 {rc.init} /bin/sh -e /run/s6/basedir/scripts/rc.init top /bin/sh\n   18 root      0:00 s6-supervise s6-linux-init-shutdownd\n   20 root      0:00 /package/admin/s6-linux-init/command/s6-linux-init-shutdownd -c /run/s6/basedir -g 3000 -C -B\n   24 root      0:00 s6-supervise s6rc-fdholder\n   25 root      0:00 s6-supervise s6rc-oneshot-runner\n   31 root      0:00 /package/admin/s6/command/s6-ipcserverd -1 -- /package/admin/s6/command/s6-ipcserver-access -v0 -E -l0 -i data/rules -- /packa\n   58 root      0:00 /bin/sh\n   66 root      0:00 ps\n/ # exit\ns6-rc: info: service legacy-services: stopping\ns6-rc: info: service legacy-services successfully stopped\ns6-rc: info: service legacy-cont-init: stopping\ns6-rc: info: service legacy-cont-init successfully stopped\ns6-rc: info: service fix-attrs: stopping\ns6-rc: info: service fix-attrs successfully stopped\ns6-rc: info: service s6rc-oneshot-runner: stopping\ns6-rc: info: service s6rc-oneshot-runner successfully stopped\ndocker-host $\n```\n\n### Writing a service script\n\nThe other way to use a container with s6-overlay is to make your\nservices supervised. You can supervise any number of services;\nusually they're just support services for the main daemon you run as\na CMD, but if that's what you want, nothing prevents you from having\nan empty CMD and running your main daemon as a supervised service as\nwell. In that case, the daemon will be restarted by s6 whenever it\nexits; the container will only stop when you tell it to do so, either\nvia a `docker stop` command, or from inside the container with the\n`/run/s6/basedir/bin/halt` command.\n\nThere are two ways of making a supervised service. The old way, which\nis still supported, is to make a \"pure s6\" service directory. Create a\ndirectory with the name of your service in `/etc/services.d` and put an executable `run`\nfile into it; this is the file in which you'll put your long-lived process execution.\nFor details of supervision of service directories, and how you can\nconfigure how s6 handles your daemon, you can take a look at the\n[servicedir](https://skarnet.org/software/s6/servicedir.html) documentation.\nA simple example would look like this:\n\n`/etc/services.d/myapp/run`:\n```\n#!/command/execlineb -P\nnginx -g \"daemon off;\"\n```\n\nThe new way is to make an [s6-rc](https://skarnet.org/software/s6-rc/)\n*source definition directory* in the `/etc/s6-overlay/s6-rc.d` directory,\nand add the name of that directory to the `user` bundle, i.e. create an\nempty file with the same name in the `/etc/s6-overlay/s6-rc.d/user/contents.d`\ndirectory. The format of a *source definition directory* is described in\n[this page](https://skarnet.org/software/s6-rc/s6-rc-compile.html). Note that\nyou can define *longruns*, i.e. daemons that will get supervised by s6 just\nlike with the `/etc/services.d` method, but also *oneshots*, i.e. programs that\nwill run once and exit. Your main service is probably a *longrun*, not a\n*oneshot*: you probably need a daemon to stick around.\n\nThe advantage of this new format is that it allows you to define dependencies\nbetween services: if *B* depends on *A*, then *A* will start first, then *B* will\nstart when *A* is ready, and when the container is told to exit, *B* will stop\nfirst, then *A*. If you have a complex architecture where various processes\ndepends on one another, or simply where you have to mix *oneshots* and *longruns*\nin a precise order, this may be for you.\n\nThe example above could be rewritten this way:\n\n`/etc/s6-overlay/s6-rc.d/myapp/type`:\n```\nlongrun\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp/run`:\n```\n#!/command/execlineb -P\nnginx -g \"daemon off;\"\n```\n\n`/etc/s6-overlay/s6-rc.d/user/contents.d/myapp`: empty file.\n(This adds `myapp` to the set of services that s6-rc will start at\ncontainer boot.)\n\n`/etc/s6-overlay/s6-rc.d/myapp/dependencies.d/base`: empty file.\n(This tells s6-rc to only start `myapp` when all the base services\nare ready: it prevents race conditions.)\n\nWe encourage you to switch to the new format, but if you don't need its\nbenefits, you can stick with regular service directories in `/etc/services.d`,\nit will work just as well.\n\n### Setting the exit code of the container to the exit code of your main service\n\nIf you run your main service as a CMD, you have nothing to do: when your CMD\nexits, or when you run `docker stop`, the container will naturally exit with the\nsame exit code as your service. (Be aware, however, that in the `docker stop`\ncase, your service will get a SIGTERM, in which case the exit code will entirely\ndepend on how your service handles it - it could trap it and exit 0, trap it and\nexit something else, or not trap it and let the shell exit its own code for it -\nnormally 130.)\n\nIf you run your main service as a supervised service, however, things are\ndifferent, and you need to tell the container what code to exit with when you\nsend it a `docker stop` command. To do that, you need to write a `finish` script:\n\n- If your service is a legacy service in `/etc/services.d`, you need an\nexecutable `/etc/services.d/myapp/finish` script.\n- If your service is an s6-rc one, you need a\n`/etc/s6-overlay/s6-rc.d/myapp/finish` file containing your script (the\nfile may or may not be executable).\n\nThis `finish` script will be run when your service exits, and will take\ntwo arguments:\n\n- The first argument will be the exit code of your service, or 256 if\nyour service was killed by an uncaught signal.\n- The second argument is only meaningful if your service was killed by\nan uncaught signal, and contains the number of said signal.\n\nIn the `finish` script, you need to write the container exit code you\nwant to the `/run/s6-linux-init-container-results/exitcode` file - and\nthat's it.\n\nFor instance, the `finish` script for the `myapp` service above could\nbe something like this:\n```sh\n#!/bin/sh\n\nif test \"$1\" -eq 256 ; then\n  e=$((128 + $2))\nelse\n  e=\"$1\"\nfi\n\necho \"$e\" > /run/s6-linux-init-container-results/exitcode\n```\nWhen you send a `docker stop` command to your container, the `myapp`\nservice will be killed and this script will be run; it will write\neither `myapp`'s exit code (if `myapp` catches the TERM signal) or\n130 (if `myapp` does not catch the TERM signal) to the special\n`/run/s6-linux-init-container-results/exitcode` file, which will\nbe read by s6-overlay at the end of the container shutdown procedure,\nand your container will exit with that value.\n\n### Fixing ownership and permissions\n\nThis section describes a functionality from the versions of s6-overlay\nthat are **anterior to** v3. fix-attrs is still supported in v3,\nbut is **deprecated**, for several reasons: one of them is that it's\ngenerally not good policy to change ownership dynamically when it can be\ndone statically. Another reason is that it doesn't work with USER containers.\nInstead of fix-attrs, we now recommend you to take care of ownership and\npermissions on host mounts *offline, before running the container*. This\nshould be done in your Dockerfile, when you have all the needed information.\n\nThat said, here is what we wrote for previous versions and that is still\napplicable today (but please stop depending on it):\n\nSometimes it's interesting to fix ownership & permissions before proceeding because,\nfor example, you have mounted/mapped a host folder inside your container. Our overlay\nprovides a way to tackle this issue using files in `/etc/fix-attrs.d`.\nThis is the pattern format followed by fix-attrs files:\n\n```\npath recurse account fmode dmode\n```\n* `path`: File or dir path.\n* `recurse`: (Set to `true` or `false`) If a folder is found, recurse through all containing files & folders in it.\n* `account`: Target account. It's possible to default to fallback `uid:gid` if the account isn't found. For example, `nobody,32768:32768` would try to use the `nobody` account first, then fallback to `uid 32768` instead.\nIf, for instance, `daemon` account is `UID=2` and `GID=2`, these are the possible values for `account` field:\n  * `daemon:                UID=2     GID=2`\n  * `daemon,3:4:            UID=2     GID=2`\n  * `2:2,3:4:               UID=2     GID=2`\n  * `daemon:11111,3:4:      UID=2     GID=11111`\n  * `11111:daemon,3:4:      UID=11111 GID=2`\n  * `daemon:daemon,3:4:     UID=2     GID=2`\n  * `daemon:unexisting,3:4: UID=2     GID=4`\n  * `unexisting:daemon,3:4: UID=3     GID=2`\n  * `11111:11111,3:4:       UID=11111 GID=11111`\n* `fmode`: Target file mode. For example, `0644`.\n* `dmode`: Target dir/folder mode. For example, `0755`.\n\nHere you have some working examples:\n\n`/etc/fix-attrs.d/01-mysql-data-dir`:\n```\n/var/lib/mysql true mysql 0600 0700\n```\n`/etc/fix-attrs.d/02-mysql-log-dirs`:\n```\n/var/log/mysql-error-logs true nobody,32768:32768 0644 2700\n/var/log/mysql-general-logs true nobody,32768:32768 0644 2700\n/var/log/mysql-slow-query-logs true nobody,32768:32768 0644 2700\n```\n\n### Executing initialization and finalization tasks\n\nHere is the old way of doing it:\n\nAfter fixing attributes (through `/etc/fix-attrs.d/`) and before starting\nuser provided services (through s6-rc or `/etc/services.d`) our overlay will\nexecute all the scripts found in `/etc/cont-init.d`, for example:\n\n[`/etc/cont-init.d/02-confd-onetime`](https://github.com/just-containers/nginx-loadbalancer/blob/master/rootfs/etc/cont-init.d/02-confd-onetime):\n```\n#!/command/execlineb -P\n\nwith-contenv\ns6-envuidgid nginx\nmultisubstitute\n{\n  import -u -D0 UID\n  import -u -D0 GID\n  import -u CONFD_PREFIX\n  define CONFD_CHECK_CMD \"/usr/sbin/nginx -t -c {{ .src }}\"\n}\nconfd --onetime --prefix=\"${CONFD_PREFIX}\" --tmpl-uid=\"${UID}\" --tmpl-gid=\"${GID}\" --tmpl-src=\"/etc/nginx/nginx.conf.tmpl\" --tmpl-dest=\"/etc/nginx/nginx.conf\" --tmpl-check-cmd=\"${CONFD_CHECK_CMD}\" etcd\n```\n\nThis way is still supported. However, there is now a more generic and\nefficient way to do it: writing your oneshot initialization and finalization\ntasks as s6-rc services, by adding service definition directories in\n`/etc/s6-overlay/s6-rc.d`, making them part of the `user` bundle (so they\nare actually started when the container boots), and making them depend on\nthe `base` bundle (so they are only started after `base`).\n\nAll the information on s6-rc can be found [here](https://skarnet.org/software/s6-rc/).\n\nWhen the container is started, the operations are performed in this order:\n\n- (deprecated) Attribute fixing is performed according to files in `/etc/fix-attrs.d`.\n- (legacy) One-shot initialization scripts in `/etc/cont-init.d` are run sequentially.\n- Services in the `user` bundle are started by s6-rc, in an order defined by\ndependencies. Services can be oneshots (initialization\ntasks) or longruns (daemons that will run throughout the container's lifetime). If\nthe services depend on `base`, they are guaranteed to start at this point and not\nearlier; if they do not, they might have been started earlier, which may cause\nrace conditions - so it's recommended to always make them depend on `base`.\n- (legacy) Longrun services in `/etc/services.d` are started.\n- Services in the `user2` bundle with the correct dependency are started.\n(Most people don't need to use this; if you are not sure, stick to the `user` bundle.)\n\nWhen the container is stopped, either because the admin sent a stop command or\nbecause the CMD exited, the operations are performed in the reverse order:\n\n- Services in the `user2` bundle with the correct dependency are stopped.\n- (legacy) Longrun services in `/etc/services.d` are stopped.\n- All s6-rc services are stopped, in an order defined by dependencies. For\noneshots, that means that the `down` script in the source definition directory\nis executed; that's how s6-rc can perform finalization tasks.\n- (legacy) One shot finalization scripts in `/etc/cont-finish.d` are run sequentially.\n\nThe point of the `user2` bundle is to allow user services declared in it to\nstart *after* the `/etc/services.d` ones; but in order to do so, every service\nin `user2` needs to declare a dependency to `legacy-services`. In other words,\nfor a service `foobar` to start late, you need to:\n- Define it in `/etc/s6-overlay/s6-rc.d/foobar` like any other s6-rc service.\n- Add an `/etc/s6-overlay/s6-rc.d/foobar/dependencies.d/legacy-services` file\n- Add an `/etc/s6-overlay/s6-rc.d/user2/contents.d/foobar` file.\n\nThat will ensure that `foobar` will start _after_ everything in `/etc/services.d`.\n\n### Writing an optional finish script\n\nBy default, services created in `/etc/services.d` will automatically restart.\nIf a service should bring the container down, you should probably run it as\na CMD instead; but if you'd rather run it as a supervised service, then you'll\nneed to write a `finish` script, which will be run when the service is down; to\nmake the container stop, the `/run/s6/basedir/bin/halt` command must be invoked.\nHere's an example finish script:\n\n`/etc/services.d/myapp/finish`:\n```\n#!/command/execlineb -S0\n\nforeground { redirfd -w 1 /run/s6-linux-init-container-results/exitcode echo 0 }\n/run/s6/basedir/bin/halt\n```\n\nThe first line of the script writes `0` to the `/run/s6-linux-init-container-results/exitcode` file.\nThe second line stops the container. When you stop the container via the `/run/s6/basedir/bin/halt`\ncommand run from inside the container, `/run/s6-linux-init-container-results/exitcode` is read and\nits contents are used as the exit code for the `docker run` command that launched the container.\nIf the file doesn't exist, or if the container is stopped with `docker stop` or another reason,\nthat exit code defaults to 0.\n\nIt is possible to do more advanced operations in a finish script. For example, here's a script\nfrom that only brings down the service when it exits nonzero:\n\n`/etc/services.d/myapp/finish`:\n```\n#!/command/execlineb -S1\nif { eltest ${1} -ne 0 -a ${1} -ne 256 }\n/run/s6/basedir/bin/halt\n```\n\nNote that in general, finish scripts should only be used for local cleanups\nafter a daemon dies. If a service is so important that the container needs\nto stop when it dies, we really recommend running it as the CMD.\n\n### Logging\n\nEvery service can have its dedicated logger. A logger is a s6 service that\nautomatically reads from the *stdout* of your service, and logs the data\nto an automatically rotated file in the place you want. Note that daemons\nusually log to stderr, not stdout, so you should probably start your service's\nrun script with `exec 2>&1` in shell, or with `fdmove -c 2 1` in execline, in\norder to catch *stderr*.\n\ns6-overlay provides a utility called `logutil-service` which is a wrapper over\nthe [`s6-log`](https://skarnet.org/software/s6/s6-log.html) program.\nThis helper does the following:\n- read how s6-log should proceed reading the logging script contained in `S6_LOGGING_SCRIPT`\n- drop privileges to the `nobody` user (defaulting to `65534:65534` if it doesn't exist)\n- clean all the environments variables\n- execute into s6-log.\n\ns6-log will then run forever, reading data from your service and writing it to\nthe directory you specified to `logutil-service`.\n\nPlease note:\n- Since the privileges are dropped automatically, there is no need to switch users with `s6-setuidgid`\n- You should ensure the log folder either:\n  - exists, and is writable by the `nobody` user\n  - does not exist, but the parent folder is writable by the `nobody` user.\n\nYou can create log folders in `cont-init.d` scripts, or as s6-rc oneshots.\nHere is an example of a logged service `myapp` implemented the old way:\n\n`/etc/cont-init.d/myapp-log-prepare`:\n```sh\n#!/bin/sh -e\nmkdir -p /var/log/myapp\nchown nobody:nogroup /var/log/myapp\nchmod 02755 /var/log/myapp\n```\n\n`/etc/services.d/myapp/run`:\n```sh\n#!/bin/sh\nexec 2>&1\nexec mydaemon-in-the-foreground-and-logging-to-stderr\n```\n\n`/etc/services.d/myapp/log/run`:\n```sh\n#!/bin/sh\nexec logutil-service /var/log/myapp\n```\n\nAnd here is the same service, myapp, implemented in s6-rc.\n\n`/etc/s6-overlay/s6-rc.d/myapp-log-prepare/dependencies.d/base`: empty file\n\n`/etc/s6-overlay/s6-rc.d/myapp-log-prepare/type`:\n```\noneshot\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp-log-prepare/up`:\n```\nif { mkdir -p /var/log/myapp }\nif { chown nobody:nogroup /var/log/myapp }\nchmod 02755 /var/log/myapp\n```\n\n<details><summary>(Click here for an explanation of the weird syntax\nor if you don't understand why your `up` file isn't working.)</summary>\n<p>\n\n(Beginning of the detailed section.)\n\nSo, the `up` and `down` files are special: they're not shell scripts, but\nsingle command lines interpreted by [execlineb](https://skarnet.org/software/execline/execlineb.html).\nYou should not have to worry about execline; you should only remember that\nan `up` file contains a single command line. So if you need a script with\nseveral instructions, here's how to do it:\n\n- Write your script in the language of your choice, in a location of your choice\n- Make it executable\n- Call that script in the `up` file.\n\nHere is how you would normally proceed to write the `up` file for\n`myapp-log-prepare`:\n\n`/etc/s6-overlay/s6-rc.d/myapp-log-prepare/up`:\n```\n/etc/s6-overlay/scripts/myapp-log-prepare\n```\n\n`/etc/s6-overlay/scripts/myapp-log-prepare`: (needs to be executable)\n```sh\n#!/bin/sh -e\nmkdir -p /var/log/myapp\nchown nobody:nogroup /var/log/myapp\nchmod 02755 /var/log/myapp\n```\n\nThe location of the actual script is arbitrary, it just needs to match\nwhat you're writing in the `up` file.\n\nBut here, it just so happens that the script is simple enough that it can\nfit entirely in the `up` file without making it too complex or too\ndifficult to understand. So, we chose to include it as an example to\nshow that there's more that you can do with `up` files, if you are\nso inclined. You can read the full documentation for the execline\nlanguage [here](https://skarnet.org/software/execline/).\n\n(End of the detailed section, click the triangle above again to collapse.)\n</p>\n</details>\n\n`/etc/s6-overlay/s6-rc.d/myapp/dependencies.d/base`: empty file\n\n`/etc/s6-overlay/s6-rc.d/myapp-log/dependencies.d/myapp-log-prepare`: empty file\n\n\n`/etc/s6-overlay/s6-rc.d/myapp/type`:\n```\nlongrun\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp/run`:\n```sh\n#!/bin/sh\nexec 2>&1\nexec mydaemon-in-the-foreground-and-logging-to-stderr\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp/producer-for`:\n```\nmyapp-log\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp-log/type`:\n```\nlongrun\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp-log/run`:\n```sh\n#!/bin/sh\nexec logutil-service /var/log/myapp\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp-log/consumer-for`:\n```\nmyapp\n```\n\n`/etc/s6-overlay/s6-rc.d/myapp-log/pipeline-name`:\n```\nmyapp-pipeline\n```\n\n`/etc/s6-overlay/s6-rc.d/user/contents.d/myapp-pipeline`: empty file\n\nThat's a lot of files! A summary of what it all means is:\n- myapp-log-prepare is a oneshot, preparing the logging directory.\nIt is a dependency of myapp-log, so it will be started *before* myapp-log.\n- myapp is a producer for myapp-log and myapp-log is a consumer for myapp,\nso what myapp writes to its stdout will go to myapp-log's stdin. Both\nare longruns, i.e. daemons that will be supervised by s6.\n- The `myapp | myapp-log` pipeline is given a name, `myapp-pipeline`, and\nthis name is declared as a part of the `user` bundle, so it will be started\nwhen the container starts.\n- `myapp-log-prepare`, `myapp-log` and `myapp` all depend on the `base`\nbundle, which means they will only be started when the system is actually\nready to start them.\n\nIt really accomplishes the same things as the `/etc/cont-init.d` plus\n`/etc/services.d` method, but it's a lot cleaner underneath, and can handle\nmuch more complex dependency graphs, so whenever you get the opportunity,\nwe recommend you familiarize yourself with the [s6-rc](https://skarnet.org/software/s6-rc/)\nway of declaring your services and your loggers. The full syntax of a\nservice definition directory, including declaring whether your service\nis a longrun or a oneshot, declaring pipelines, adding service-specific\ntimeouts if you need them, etc., can be found\n[here](https://skarnet.org/software/s6-rc/s6-rc-compile.html#source).\n\n\n### Dropping privileges\n\nWhen it comes to executing a service, no matter whether it's a service or a logger,\na good practice is to drop privileges before executing it.\n`s6` already includes utilities to do exactly these kind of things:\n\nIn `execline`:\n\n```\n#!/command/execlineb -P\ns6-setuidgid daemon\nmyservice\n```\n\nIn `sh`:\n\n```sh\n#!/bin/sh\nexec s6-setuidgid daemon myservice\n```\n\nIf you want to know more about these utilities, please take a look at:\n[`s6-setuidgid`](http://skarnet.org/software/s6/s6-setuidgid.html),\n[`s6-envuidgid`](http://skarnet.org/software/s6/s6-envuidgid.html), and\n[`s6-applyuidgid`](http://skarnet.org/software/s6/s6-applyuidgid.html).\n\n### Container environment\n\nIf you want your custom script to have container environments available:\nyou can use the `with-contenv` helper, which will push all of those into your\nexecution environment, for example:\n\n`/etc/cont-init.d/01-contenv-example`:\n```sh\n#!/command/with-contenv sh\nenv\n```\n\nThis script will output the contents of your container environment.\n\n### Read-Only Root Filesystem\n\nRecent versions of Docker allow running containers with a read-only root filesystem.\nIf your container is in such a case, you should set `S6_READ_ONLY_ROOT=1` to inform\ns6-overlay that it should not attempt to write to certain areas - instead, it will\nperform copies into a tmpfs mounted on `/run`.\n\nNote that s6-overlay assumes that:\n- `/run` exists and is writable. If it is not, it will attempt to mount a tmpfs there.\n- `/var/run` is a symbolic link to `/run`, for compatibility with previous versions. If it is not, it will make it so.\n\nIn general your default docker settings should already provide a suitable tmpfs in `/run`.\n\n### Customizing s6-overlay behaviour\n\nIt is possible somehow to tweak s6-overlay's behaviour by providing an already predefined set of environment variables to the execution context:\n\n* `PATH` (default = `/command:/usr/bin:/bin`):\nthis is the default PATH that all the services in the container,\nincluding the CMD, will have. Set this variable if you have a lot\nof services that depend on binaries stored in another directory, e.g.\n`/usr/sbin`. Note that `/command`, `/usr/bin` and `/bin` will always\nbe added to that path if they're not already in the one you provide.\n* `S6_KEEP_ENV` (default = 0): if set, then environment is not reset and whole supervision tree sees original set of env vars. It switches `with-contenv` into a nop.\n* `S6_LOGGING` (default = 0): \n  * **`0`**: Outputs everything to stdout/stderr.\n  * **`1`**: Uses an internal `catch-all` logger and persists everything on it, it is located in `/var/log/s6-uncaught-logs`. Anything run as a `CMD` is still output to stdout/stderr.\n  * **`2`**: Uses an internal `catch-all` logger and persists everything on it, including the output of `CMD`. Absolutely nothing is written to stdout/stderr.\n* `S6_CATCHALL_USER` (default = root): if set, and if `S6_LOGGING` is 1 or 2,\nthen the catch-all logger is run as this user, which must be defined in your\nimage's `/etc/passwd`. Every bit of privilege separation helps a little with security.\n* `S6_BEHAVIOUR_IF_STAGE2_FAILS` (default = 0): determines what the container should do\nif one of the service scripts fails. This includes:\n  * if the early stage2 hook exits nonzero (by default there's no hook)\n  * if anything fails in `fix-attrs`\n  * if any old-style `/etc/cont-init.d` or new-style [s6-rc](https://skarnet.org/software/s6-rc/) oneshot fails\n  * if any old-style `/etc/services.d` or new-style [s6-rc](https://skarnet.org/software/s6-rc/) longrun is marked\nas expecting readiness notification, and fails to become *ready* in the allotted time (see\n`S6_CMD_WAIT_FOR_SERVICES_MAXTIME` below). The valid values for `S6_BEHAVIOUR_IF_STAGE2_FAILS`\nare the following:\n  * **`0`**: Continue silently even if a script has failed.\n  * **`1`**: Continue but warn with an annoying error message.\n  * **`2`**: Stop the container.\n* `S6_KILL_FINISH_MAXTIME` (default = 5000): How long (in milliseconds) the system should\nwait, at shutdown time, for a script in `/etc/cont-finish.d` to finish naturally. After this\nduration, the script will be sent a SIGKILL. Bear in mind that scripts in `/etc/cont.finish.d`\nare run sequentially, and the shutdown sequence will potentially wait for `S6_KILL_FINISH_MAXTIME`\nmilliseconds for *each* script.\n* `S6_SERVICES_READYTIME` (default = 50): With services declared in `/etc/services.d`, there is\nan unavoidable race condition between the moment when services are started and the moment when\nthey can be tested for readiness. To avoid that race, we sleep a little time, by default 50\nmilliseconds, before testing for readiness. If your machine is slow or very busy, you may\nget errors looking like `s6-svwait: fatal: unable to s6_svstatus_read: No such file or directory`.\nIn that case, you should increase the sleeping time, by declaring it (in milliseconds) in the\n`S6_SERVICES_READYTIME` variable. Note that it only concerns `/etc/services.d`; s6-rc is immune\nto the race condition.\n* `S6_SERVICES_GRACETIME` (default = 3000): How long (in milliseconds) `s6` should wait,\nat shutdown time, for services declared in `/etc/services.d` to die before proceeding\nwith the rest of the shutdown.\n* `S6_KILL_GRACETIME` (default = 3000): How long (in milliseconds) `s6` should wait, at the end of\nthe shutdown procedure when all the processes have received a TERM signal, for them to die\nbefore sending a `KILL` signal to make *sure* they're dead.\n* `S6_LOGGING_SCRIPT` (default = \"n20 s1000000 T\"): This env decides what to log and how, by default every line will prepend with ISO8601, rotated when the current logging file reaches 1mb and archived, at most, with 20 files.\n* `S6_CMD_ARG0` (default = not set): Value of this env var will be prepended to any `CMD` args passed by docker. Use it if you are migrating an existing image to s6-overlay and want to make it a drop-in replacement: setting this variable to the value of a previously used ENTRYPOINT will help you transition.\n* `S6_CMD_USE_TERMINAL` (default = 0): Set this value to **1** if you have a CMD that needs a terminal for its output\n(typically when you're running your container with `docker run -it`), and you have set `S6_LOGGING` to a nonzero value.\nThis setting will make your CMD actually output to your terminal; the drawback is that its output will not be logged.\nBy default (when this variable is **0** or not set), the stdout and stderr of your CMD are logged when `S6_LOGGING` is nonzero,\nwhich means they go to a pipe even if you're running it in an interactive terminal.\n* `S6_FIX_ATTRS_HIDDEN` (default = 0): Controls how `fix-attrs.d` scripts process files and directories.\n  * **`0`**: Hidden files and directories are excluded.\n  * **`1`**: All files and directories are processed.\n* `S6_CMD_WAIT_FOR_SERVICES` (default = 0): By default when the container starts,\nservices in `/etc/services.d` will be started and execution will proceed to\nstarting the `user2` bundle and the CMD, if any of these is defined. If\n`S6_CMD_WAIT_FOR_SERVICES` is nonzero, however, the container starting sequence\nwill wait until the services in `/etc/services.d` are *ready* before proceeding\nwith the rest of the sequence. Note that this is only significant if the services in `/etc/services.d`\n[notify their readiness](https://skarnet.org/software/s6/notifywhenup.html) to s6.\n* `S6_CMD_WAIT_FOR_SERVICES_MAXTIME` (default = 0, i.e. infinite): The maximum time (in milliseconds) the services could take to bring up before proceding to CMD executing.\nSet this variable to a positive value if you have services that can potentially block indefinitely and you prefer the container to fail\nif not everything is up after a given time.\nNote that this value also includes the time setting up legacy container initialization (`/etc/cont-init.d`) and services (`/etc/services.d`), so\ntake that into account when computing a suitable value. In versions of s6-overlay up to 3.1.6.2, the default was 5000 (five seconds),\nbut it caused more unwanted container failures than it solved issues, so now there's no timeout by default: s6-overlay will wait as long as\nis necessary for all the services to be brought up.\n* `S6_READ_ONLY_ROOT` (default = 0): When running in a container whose root filesystem is read-only, set this env to **1** to inform init stage 2 that it should copy user-provided initialization scripts from `/etc` to `/run/s6/etc` before it attempts to change permissions, etc. See [Read-Only Root Filesystem](#read-only-root-filesystem) for more information.\n* `S6_SYNC_DISKS` (default = 0): Set this env to **1** to inform init stage 3 that it should attempt to sync filesystems before stopping the container. Note: this will likely sync all filesystems on the host.\n* `S6_STAGE2_HOOK` (default = none): If this variable exists, its contents\nwill be interpreted as a shell excerpt that will be run in the early stage 2,\nbefore services are started. This can be used, for instance, to dynamically\npatch the service database at run-time right before it is compiled and run.\nIf the hook program exits nonzero and `S6_BEHAVIOUR_IF_STAGE2_FAILS` is 2 or more,\nthe container will stop instantly. Please note that running the wrong hook program\nmay prevent your container from starting properly, or may endanger your security;\nso only use this if you know exactly what you are doing. When in doubt, leave\nthis variable undefined.\n* `S6_VERBOSITY` (default = 2): controls the verbosity of s6-rc, and potentially\nother tools, at container start and stop time. The default, 2, is normally verbose:\nit will list the service start and stop operations. You can make the container quieter\nby decreasing this number: 1 will only print warnings and errors, and 0 will only\nprint errors. You can also make the container _more_ verbose, i.e. print tracing and\ndebug information, by increasing this number up to 5, but the output will quickly\nbecome _very_ noisy, and most people shouldn't need this.\n* `S6_CMD_RECEIVE_SIGNALS` (default = 0): decides whether signals sent to the\ncontainer should be sent to the container's pid 1 or to the CMD. By default, when\nyou perform for instance a `docker stop`, a TERM signal will be sent to the\ncontainer's pid 1, which will trigger the full container shutdown sequence - but\nif a CMD is present, it will be among the last processes to be killed, only when\neverything else is down and the container is about to exit. If this variable is\n1 or more, signals are diverted from pid 1 to the CMD, which means that `docker stop`\nwill send a SIGTERM to the CMD instead, and the container will only trigger its shutdown\nprocedure when the CMD is dead. Note that only SIGTERM, SIGQUIT, SIGINT, SIGUSR1,\nSIGUSR2, SIGPWR and SIGWINCH are diverted; other signals either are ignored or\ncannot be diverted and are necessarily handled by pid 1. Please be aware that using\nthis option may prevent interactive CMDs from working at all - in other words, if\nyou're running an interactive CMD in a terminal, don't set this variable; but that\nshould be fine since in this case you already have interactive ways of stopping your CMD.\n\n### syslog\n\nIf software running in your container requires syslog, extract the\n`syslogd-overlay-noarch.tar.xz` tarball:\nthat will give you a small syslogd emulation. Logs will be found\nunder various subdirectories of `/var/log/syslogd`, for instance\nmessages will be found in the `/var/log/syslogd/messages/` directory,\nthe latest logs being available in the `/var/log/syslogd/messages/current` file.\nLogging directories are used rather than files so that logs can be\nautomatically rotated without race conditions (that is a feature of\n[s6-log](https://skarnet.org/software/s6/s6-log.html)).\n\nIt is recommended to add `syslog` and `sysllog` users to your image, for\nprivilege separation; the syslogd emulation processes will run as these users\nif they exist. Otherwise they will default to `32760:32760` and `32761:32761`,\nnumeric uids/gids that may already exist on your system.\n\n## Performance\n\n- The noarch and symlinks tarballs are all tiny. The biggest tarball is the\none that contains the binaries; it's around 650 kB.\n- Uncompressed on a tmpfs, the overlay scripts use about 120 kB, and the\nbinaries for x86_64 use about 5.7 MB.\n- We haven't yet measured the time it takes for the container to be up and running\nonce you run `docker run`, but you will notice it's fast. Faster than previous\nversions of s6-overlay, with fewer delays. And if you convert your `/etc/cont-init.d`\nscripts to the s6-rc format, they will be able to run in parallel, so you will\ngain even more performance. If you have benchmarks, please send them to us!\n\n\n## Verifying Downloads\n\nThe s6-overlay releases have a checksum files you can use to verify\nthe download using SHA256:\n\n```sh\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz.sha256 /tmp\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp\nADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz.sha256 /tmp\nRUN cd /tmp && sha256sum -c *.sha256\n```\n\n## Notes\n\n### `USER` directive\n\nAs of version 3.2.0.2, s6-overlay has limited support for running as a user other than `root`:\n\n* Tools like `fix-attrs` and `logutil-service` are unlikely to work (they rely\n  on being able to change UIDs).\n* The syslogd emulation will not work.\n\nGenerally speaking, if you're running a simple container with a main application and\none or two support services, you may benefit from the `USER` directive if that is\nyour preferred way of running containers. However, if you're running more than a few\nservices, or daemons that expect a real system with complete Unix infrastructure,\nthen USER is probably not a good idea and you would benefit more from using\nprivilege separation between services in your container.\n\n### Terminal support\n\nGenerally speaking, you *should not* run your containers with `docker run -it`.\nIt is bad practice to have console access to your containers. That said, if your\nCMD is interactive and needs a terminal, s6-overlay will try to support it whenever\npossible, but the nature of terminals makes it difficult to ensure that everything\nworks perfectly in all cases.\n\nIn particular, if you are stacking virtualization environments and other layers\nalready have their own kludges for terminals - for instance, if you are running\ns6-overlay under qemu - then it is almost guaranteed that `docker run -it` will\nnot work. However, once the container is running, you should always be able to\naccess an interactive shell inside it via `docker exec -it containername /bin/sh`.\n\nThe same caveats apply to stopping containers with ^C. Normally containers are\nstopped via `docker stop`, or when the CMD exits; ^C is not an officially supported\nmethod of stopping them. s6-overlay *tries* to exit cleanly on ^C, whether the\ncontainer is running with `-it` or not, but there will be cases where it is\nunfortunately impossible.\n\n\n## Releases\n\nOver on the releases tab, we have a number of tarballs:\n\n* `s6-overlay-noarch.tar.xz`: the s6-overlay scripts.\n* `s6-overlay-${arch}.tar.xz`: the binaries for platform *${arch}*.\nThey are statically compiled and will work with any Linux distribution.\n* `s6-overlay-symlinks-noarch.tar.xz`: `/usr/bin` symlinks to the s6-overlay scripts. Totally optional.\n* `s6-overlay-symlinks-arch.tar.xz`: `/usr/bin` symlinks to the skaware binaries. Totally optional.\n* `syslogd-overlay-noarch.tar.xz`: the syslogd emulation. Totally optional.\n* `s6-overlay-${version}.tar.xz`: the s6-overlay source. Download it if you want to build s6-overlay yourself.\n\nWe have binaries for at least x86_64, aarch64, arm32, i486, i686, riscv64, and s390x.\nThe full list of supported arches can be found in [conf/toolchains](https://github.com/just-containers/s6-overlay/blob/master/conf/toolchains).\n\n### Which architecture to use depending on your TARGETARCH\n\nThe `${arch}` part in the `s6-overlay-${arch}.tar.xz` tarball uses\nthe naming conventions of gcc, which are not the ones that Docker\nuses. (Everyone does something different in this field depending on\ntheir needs, and no solution is better than any other, but the Docker\none is *worse* than others because its naming is inconsistent. The gcc\nconvention is better for us because it simplifies our builds greatly and\nmakes them more maintainable.)\n\nThe following table should help you find the right tarball for you\nif you're using the TARGETARCH value provided by Docker:\n\n| ${TARGETARCH} | ${arch} | Notes                 |\n|:--------------|:--------|:----------------------|\n| amd64         | x86_64  |                       |\n| arm64         | aarch64 |                       |\n| arm/v7        | arm     | armv7 with soft-float |\n| arm/v6        | armhf   | Raspberry Pi 1        |\n| 386           | i686    | i486 for very old hw  |\n| riscv64       | riscv64 |                       |\n| s390x         | s390x   |                       |\n\nIf you need another architecture, ask us and we'll try to make a toolchain\nfor it. In particular, we know that armv7 is a mess and needs a flurry of\noptions depending on your precise target (and this is one of the reasons why\nthe Docker naming system isn't good, although arguably the gcc naming system\nisn't much better on that aspect).\n\n## Contributing\n\nAny way you want! Open issues, open PRs, we welcome all contributors!\n\n## Building the overlay yourself\n\n- Download the [s6-overlay source].\n- Check the [conf/defaults.mk](https://github.com/just-containers/s6-overlay/blob/master/conf/defaults.mk)\nfile for variables you may want to change. Do not modify the file itself.\n- Call `make` followed by your variable assignments. Example: `make ARCH=riscv64-linux-musl`\nto build the overlay for RISCV64.\n- The tarballs will be in the `output` subdirectory, unless you changed the `OUTPUT` variable.\n\n## Upgrade Notes\n\nPlease see [CHANGELOG](./CHANGELOG.md).\n"
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "layout",
          "type": "tree",
          "content": null
        },
        {
          "name": "mk",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}