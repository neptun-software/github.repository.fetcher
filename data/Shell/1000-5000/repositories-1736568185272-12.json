{
  "metadata": {
    "timestamp": 1736568185272,
    "page": 12,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pirate/wireguard-docs",
      "stars": 4679,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "MIT License\n\nCopyright (c) 2019 ~ 2023 Nick Sweeting\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 66.6181640625,
          "content": "<div align=\"center\">\n\n# Some Unofficial WireGuard Documentation\n\n<!--<img src=\"https://i.imgur.com/dQ3PDQQ.png\">--><br/><br/>\n\n\nAPI reference guide for WireGuard including Setup, Configuration, and Usage, with examples.\n\n\n<i>All credit goes to the WireGuard project, [zx2c4](https://www.zx2c4.com/) and the [open source contributors](https://github.com/WireGuard/WireGuard/graphs/contributors) for the original software,<br/> this is my solo unofficial attempt at providing more comprehensive documentation, API references, and examples.</i>\n\n<small>\n    \nSource for these docs, example code, and issue tracker: https://github.com/pirate/wireguard-docs &nbsp; &nbsp; \nNicer HTML page version: https://docs.sweeting.me/s/wireguard\n\n</small>\n\n</div>\n\n---\n\n[WireGuard](https://www.wireguard.com/) is an open-source VPN solution written in C by [Jason Donenfeld](https://www.jasondonenfeld.com) and [others](https://github.com/WireGuard/WireGuard/graphs/contributors), aiming to fix many of the problems that have plagued other modern server-to-server VPN offerings like IPSec/IKEv2, OpenVPN, or L2TP. It shares some similarities with other modern VPN offerings like [Tinc](https://www.tinc-vpn.org/) and [MeshBird](https://github.com/meshbird/meshbird), namely good cipher suites and minimal config. As of 2020-01 [it's been merged into the 5.6 version of the Linux kernel](https://arstechnica.com/gadgets/2020/01/linus-torvalds-pulled-wireguard-vpn-into-the-5-6-kernel-source-tree/), meaning it will ship with most Linux systems out-of-the-box.\n\n**Official Links**\n\n- Homepage: https://www.wireguard.com\n- Install: https://www.wireguard.com/install/\n- QuickStart: https://www.wireguard.com/quickstart/\n- Manpages: [`wg`](https://manpages.debian.org/testing/wireguard-tools/wg.8.en.html), [`wg-quick`](https://manpages.debian.org/unstable/wireguard-tools/wg-quick.8.en.html)\n- Main Git repo: https://git.zx2c4.com/WireGuard/\n- GitHub Mirror: https://github.com/WireGuard/WireGuard\n- Mailing List: https://lists.zx2c4.com/mailman/listinfo/wireguard\n\n**WireGuard Goals**\n\n - strong, modern security by default\n - minimal config and key management\n - fast, both low-latency and high-bandwidth\n - simple internals and small protocol surface area\n - simple CLI and seamless integration with system networking\n \n<div align=\"center\">\n<a href=\"https://www.ckn.io/blog/2017/11/14/wireguard-vpn-typical-setup/\"><img src=\"https://www.ckn.io/images/wireguard_comparisions.png\" width=\"600px\"/></a><br/><small>\nIt's also <i>fast as hell</i>. I routinely get sub 0.5ms pings and 900mbps+ on good connections.<br/>\n(See https://www.ckn.io/blog/2017/11/14/wireguard-vpn-typical-setup/)\n</small>\n</div>\n\n---\n\n# Table of Contents\n\nSee https://github.com/pirate/wireguard-docs for example code and documentation source.\n\n<ul>\n<li><a href=\"#Table-of-Contents\">Table of Contents</a></li>\n<li><a href=\"#Intro\">Intro</a>\n<ul>\n<li><a href=\"#My-Personal-Requirements-for-a-VPN-Solution\">My Personal Requirements for a VPN Solution</a></li>\n<li><a href=\"#List-of-Possible-VPN-Solutions\">List of Possible VPN Solutions</a></li>\n</ul>\n</li>\n<li><a href=\"#WireGuard-Documentation\">WireGuard Documentation</a>\n<ul>\n<li><a href=\"#Glossary\">Glossary</a>\n<ul>\n<li><a href=\"#PeerNodeDevice\">Peer/Node/Device</a></li>\n<li><a href=\"#Bounce-Server\">Bounce Server</a></li>\n<li><a href=\"#Subnet\">Subnet</a></li>\n<li><a href=\"#CIDR-Notation\">CIDR Notation</a></li>\n<li><a href=\"#NAT\">NAT</a></li>\n<li><a href=\"#Public-Endpoint\">Public Endpoint</a></li>\n<li><a href=\"#Private-key\">Private key</a></li>\n<li><a href=\"#Public-key\">Public key</a></li>\n<li><a href=\"#DNS\">DNS</a></li>\n<li><a href=\"#Example-Strings\">Example Strings</a></li>\n</ul>\n</li>\n<li><a href=\"#How-WireGuard-Works\">How WireGuard Works</a>\n<ul>\n<li><a href=\"#How-Public-Relay-Servers-Work\">How Public Relay Servers Work</a></li>\n<li><a href=\"#How-WireGuard-Routes-Packets\">How WireGuard Routes Packets</a></li>\n<li><a href=\"#What-WireGuard-Traffic-Looks-Like\">What WireGuard Traffic Looks Like</a></li>\n<li><a href=\"#WireGuard-Performance\">WireGuard Performance</a></li>\n<li><a href=\"#WireGuard-Security-Model\">WireGuard Security Model</a></li>\n<li><a href=\"#How-WireGuard-Manages-Keys\">How WireGuard Manages Keys</a></li>\n</ul>\n</li>\n<li><a href=\"#Usage\">Usage</a>\n<ul>\n<li><a href=\"#QuickStart\">QuickStart</a></li>\n<li><a href=\"#Setup\">Setup</a></li>\n<li><a href=\"#Config-Creation\">Config Creation</a></li>\n<li><a href=\"#Key-Generation\">Key Generation</a></li>\n<li><a href=\"#Start--Stop\">Start / Stop</a></li>\n<li><a href=\"#Inspect\">Inspect</a></li>\n<li><a href=\"#Testing\">Testing</a></li>\n</ul>\n</li>\n<li><a href=\"#Config-Reference\">Config Reference</a>\n<ul>\n<li><a href=\"#Interface\">[Interface]</a></li>\n<li><a href=\"#Peer\">[Peer]</a></li>\n</ul>\n</li>\n<li><a href=\"#Advanced-Topics\">Advanced Topics</a>\n<ul>\n<li><a href=\"#IPv6\">IPv6</a></li>\n<li><a href=\"#Forwarding-All-Traffic\">Forwarding All Traffic</a></li>\n<li><a href=\"#NAT-to-NAT-Connections\">NAT-to-NAT Connections</a></li>\n<li><a href=\"#Dynamic-IP-Allocation\">Dynamic IP Allocation</a></li>\n<li><a href=\"#Other-WireGuard-Implementations\">Other WireGuard Implementations</a></li>\n<li><a href=\"#WireGuard-Setup-tools\">WireGuard Setup Tools</a></li>\n<li><a href=\"#Config-Shortcuts\">Config Shortcuts</a></li>\n<li><a href=\"#Containerization\">Containerization</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#Further-Reading\">Further Reading</a>\n<ul>\n<li><a href=\"#Reference-Docs\">Reference Docs</a></li>\n<li><a href=\"#Tutorials\">Tutorials</a></li>\n<li><a href=\"#Papers-Articles-and-Talks\">Papers, Articles, and Talks</a></li>\n<li><a href=\"#Related-Projects\">Related Projects</a></li>\n<li><a href=\"#Docker\">Docker</a></li>\n<li><a href=\"#Other\">Other</a></li>\n<li><a href=\"#Discussions\">Discussions</a></li>\n</ul>\n</li>\n</ul>\n\n\n# Intro\n\nWhether living behind the Great Wall of China or just trying to form a network between your servers, WireGuard is a great option and serves as a \"lego block\" for building networks (much in the same way that ZFS is a lego block for building filesystems).\n\n## WireGuard Overview\n\n - minimal config, low tunable surface area and sane defaults\n - minimal key management work needed, just 1 public & 1 private key per host\n - behaves like a normal ethernet interface, behaves well with standard kernel packet routing rules\n - ability to easily create a LAN like 192.0.2.0/24 between all servers, or more complex networks using custom routes\n - ability to some traffic or all traffic to/through arbitrary hosts on the VPN LAN\n - robust automatic reconnects after reboots / network downtime / NAT connection table drops\n - fast (low latency and line-rate bandwidth)\n - modern encryption, secure by default with forward secrecy & resilience to downgrade attacks\n - ideally support for any type of Level 2 and control traffic, e.g. ARP/DHCP/ICMP (or ideally raw ethernet frames), not just TCP/HTTP\n - ability to join the VPN from Ubuntu, FreeBSD, iOS, MacOS, Windows, Android (via open-source apps or natively)\n - supports both running on the host routing traffic for docker or running in a docker container routing for the host\n\n**Things WireGuard does not do:**\n\n- form a self-healing mesh network where nodes automatically gossip with neighbors\n- break through double NATs with a signalling server (WebRTC-style)\n- handle automatically distributing & revoking keys through a central authority\n- allow sending raw layer-2 ethernet frames (it's at the IP layer)\n\nBut you can write your own solutions for these problems using WireGuard under the hood (like [Tailscale](https://github.com/tailscale/tailscale) or [AltheaNet](https://althea.net/)).\n\n## List of Other VPN Solutions\n\n - [WireGuard](https://www.wireguard.com/)\n - [IPSec (IKEv2)](https://github.com/jawj/IKEv2-setup)/strongSwan: in my experience, there was lots of brittle config that was different for each OS, the NAT busting setup is very manual and involves updating the central server and starting all the others in the correct order, it wasn't great at becoming stable again after network downtime, had to be manually restarted often. your mileage may vary.\n - [OpenVPN](https://openvpn.net/vpn-server-resources/site-to-site-routing-explained-in-detail/): can work over UDP or be disguised as HTTPS traffic over TCP\n - StealthVPN: haven't tried it, should I?\n - [DsVPN](https://github.com/jedisct1/dsvpn): I think it does TCP-over-TCP which usually doesn't end well...\n - [SoftEther](https://www.softether.org/) ([SSTP](https://en.wikipedia.org/wiki/Secure_Socket_Tunneling_Protocol)): haven't tried it yet, should I? (also does TCP-over-TCP?)\n - L2TP: somewhat outdated\n - PPTP: ancient, inflexible, insecure, doesn't solve all the requirements\n - SOCKS/SSH: good for proxying single-port traffic, not a full networking tunnel or VPN\n \n### Mesh VPN Solutions\n\n - [TINC](https://www.tinc-vpn.org/): haven't tried it yet, but it doesn't work on iOS, worst case scenario I could live\n - [VPNCloud](https://github.com/dswd/vpncloud): similar properties to WireGuard, with more auto-mesh features\n - [cjdns](https://github.com/cjdelisle/cjdns): haven't tried it yet, should I?\n - [ZeroTier](https://www.zerotier.com): haven't tried it yet, should I?\n - [MeshBird](https://github.com/meshbird/meshbird): \"Cloud native\" VPN/networking layer\n - [Yggdrasil Network](https://yggdrasil-network.github.io/): Yggdrasil is a self-arranging IPv4/IPv6 mesh VPN (haven't tried it yet)\n\n### VPN Setup Tools\n\n - [Algo](https://github.com/trailofbits/algo) WireGuard setup tool\n - [Striesand](https://github.com/StreisandEffect/streisand) Multi-protocol setup tool\n - [IKEv2-setup](https://github.com/jawj/IKEv2-setup) IKEv2 server setup script\n - [WireGuard-Manager](https://github.com/complexorganizations/wireguard-manager) WireGuard setup tool, all in one\n\n---\n\n# WireGuard Documentation\n\n---\n\n## Glossary\n\n### Example Strings\n\nThese are demo hostnames, domain names, IP addresses, and ranges used in the documentation and example configs.\nReplace them with your preferred values when doing your own setup.\n\n- Example domain: `example-vpn.dev` can be replaced with any publicly accessible domain you control\n- Example hostnames: `public-server1`, `public-server2`, `home-server`, `laptop`, `phone` can be changed to your device hostnames\n- IP addresses & ranges: `192.0.2.1/24`, `192.0.2.3`, `192.0.2.3/32`, `2001:DB8::/64` can be replaced with your preferred subnets and addresses (e.g. `192.168.5.1/24`)\n\nWherever you see these strings below, they're just being used as placeholder values to illustrate an example and have no special meaning.\n\n**Make sure to change the IP addresses in your configs!** The blocks used in these docs\nare reserved for example purposes by the IETF and should never be used in real network setups.\n\n - **`192.0.2.0/24`** (TEST-NET-1) IPv4 example range [RFC5737](https://tools.ietf.org/html/rfc5737)\n - **`2001:DB8::/32`** IPv6 example range [RFC3849](https://tools.ietf.org/html/rfc3849)\n\nYou can use any private range you want for your own setups, e.g. `10.0.44.0/24`, just make sure\nthey don't conflict with any of the LAN subnet ranges your peers are on.\n\n### Peer/Node/Device\n\nA host that connects to the VPN and registers a VPN subnet address such as `192.0.2.3` for itself. It can also optionally route traffic for more than its own address(es) by specifying subnet ranges in comma-separated CIDR notation.\n\n### Bounce Server\n\nA publicly reachable peer/node that serves as a fallback to relay traffic for other VPN peers behind NATs.  A bounce server is not a special type of server, it's a normal peer just like all the others, the only difference is that it has a public IP and has kernel-level IP forwarding turned on which allows it to bounce traffic back down the VPN to other clients.\n\nSee more: https://tailscale.com/blog/how-nat-traversal-works/ (Tailscale uses Wireguard under the hood)\n\n### Subnet\n\nA group of IPs separate from the public internet, e.g. 192.0.2.1-255 or 192.168.1.1/24. Generally behind a NAT provided by a router, e.g. in office internet LAN or a home Wi-Fi network.\n\n### CIDR Notation\n\nA way of defining a subnet and its size with a \"mask\", a smaller mask = more  address bits usable by the subnet & more IPs in the range. Most common ones:\n  + `192.0.2.1/32` (a single IP address, `192.0.2.1`) netmask = `255.255.255.255`\n  + `192.0.2.1/24` (255 IPs from `192.0.2.0`-`192.0.2.255`) netmask = ` 255.255.255.0`\n  + `192.0.2.1/16` (65,536 IPs from `192.0.0.0` - `192.0.255.255`) netmask = `255.255.0.0`\n  + `192.0.2.1/8` (16,777,216 IPs from `192.0.0.0` - `192.255.255.255`) netmask = `255.0.0.0`\n  + `0.0.0.1/0` (4,294,967,296 IPs from `0.0.0.0` - `255.255.255.255`) netmask = `0.0.0.0`\n  + IPv6 CIDR notation is also supported e.g. `2001:DB8::/64`\n \nhttps://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n\nTo people just getting started `192.0.2.1/32` may seem like a weird and confusing way to refer to a single IP.  This design is nice though because it allows peers to expose multiple IPs if needed without needing multiple notations.  Just know that anywhere you see something like `192.0.2.3/32`, it really just means `192.0.2.3`.\n\n### NAT\nA subnet with private IPs provided by a router standing in front of them doing Network Address Translation, individual nodes are not publicly accessible from the internet, instead the router keeps track of outgoing connections and forwards responses to the correct internal IP (e.g. standard office networks, home Wi-Fi networks, free public Wi-Fi networks, etc)\n\n### Public Endpoint\n\nThe publicly accessible address:port for a node, e.g. `123.124.125.126:1234` or `some.domain.tld:1234` (must be accessible via the public internet, generally can't be a private IP like `192.0.2.1` or `192.168.1.1` unless it's directly accessible using that address by other peers on the same subnet).\n\n\n### Private key\nA WireGuard private key for a single node, generated with:\n`wg genkey > example.key`\n(never leaves the node it's generated on)\n  \n### Public key\nA WireGuard public key for a single node, generated with:\n`wg pubkey < example.key > example.key.pub `\n(shared with other peers)\n\n### DNS\n\nDomain Name Server, used to resolve hostnames to IPs for VPN clients, instead of allowing DNS requests to leak outside the VPN and reveal traffic.  Leaks are testable with http://dnsleak.com.\n\n---\n\n## How WireGuard Works\n\n### How Public Relay Servers Work\n\nPublic relays are just normal VPN peers that are able to act as an intermediate relay server between any VPN clients behind NATs, they can forward any VPN subnet traffic they receive to the correct peer at the system level (WireGuard doesn't care how this happens, it's handled by the kernel `net.ipv4.ip_forward = 1` and the iptables routing rules).\n\nIf all peers are publicly accessible, you don't have to worry about special treatment to make one of them a relay server, it's only needed if you have any peers connecting from behind a NAT.\n\nEach client only needs to define the publicly accessible servers/peers in its config, any traffic bound to other peers behind NATs will go to the catchall VPN subnet (e.g. `192.0.2.1/24`) in the public relays `AllowedIPs` route and will be forwarded accordingly once it hits the relay server.\n\nIn summary: only direct connections between clients should be configured, any connections that need to be bounced should not be defined as peers, as they should head to the bounce server first and be routed from there back down the vpn to the correct client.\n\n### How WireGuard Routes Packets\n\nMore complex topologies are definitely achievable, but these are the basic routing methods used in typical WireGuard setups:\n\n- **Direct node-to-node**  \n  In the simplest case, the nodes will either be on the same LAN or both be publicly accessible. Define directly accessible nodes with hardcoded `Endpoint` addresses and ports so that WireGuard can connect straight to the open port and route UDP packets without intermediate hops.\n- **Node behind local NAT to public node**  \n  When 1 of the 2 parties is behind remote NAT (e.g. when a laptop behind NAT connects to `public-server2`), define the publicly accessible node with a hardcoded `Endpoint` and the NAT-ed node without. The connection will be opened from NAT client -> public client, then traffic will route directly between them in both directions as long as the connection is kept alive by outgoing `PersistentKeepalive` pings from the NAT-ed client.\n- **Node behind local NAT to node behind remote NAT (via relay)**  \n  Most of the time when both parties are behind NATs, the NATs do source port randomization making direct connections infeasible, so they will both have to open a connection to `public-server1`, and traffic will forward through the intermediary bounce server as long as the connections are kept alive.\n- **Node behind local NAT to node behind remote NAT (via UDP NAT hole-punching)**  \n  While sometimes possible, it's generally infeasible to do direct NAT-to-NAT connections on modern networks, because most NAT routers are quite strict about randomizing the source port, making it impossible to coordinate an open port for both sides ahead of time.  Instead, a signaling server (STUN) must be used that stands in the middle and communicates which random source ports are assigned to the other side. Both clients make an initial connection to the public signaling server, then it records the random source ports and sends them back to the clients. This is how WebRTC works in modern P2P web apps.  Even with a signalling server and known source ports for both ends, sometimes direct connections are not possible because the NAT routers are strict about only accepting traffic from the original destination address (the signalling server), and will require a new random source port to be opened to accept traffic from other IPs (e.g. the other client attempting to use the originally communicated source port). This is especially true for \"carrier-grade NATs\" like cellular networks and some enterprise networks, which are designed specifically to prevent this sort of hole-punching connection. See the full section below on [**NAT to NAT Connections**](#NAT-to-NAT-Connections) for more information.\n\nMore specific (also usually more direct) routes provided by other peers will take precedence when available, otherwise traffic will fall back to the least specific route and use the `192.0.2.1/24` catchall to forward traffic to the bounce server, where it will in turn be routed by the relay server's system routing table (`net.ipv4.ip_forward = 1`) back down the VPN to the specific peer that's accepting routes for that traffic.  WireGuard does not automatically find the fastest route or attempt to form direct connections between peers if not already defined, it just goes from the most specific route in `[Peers]` to least specific.\n\nYou can figure out which routing method WireGuard is using for a given address by measuring the ping times to figure out the unique length of each hop, and by inspecting the output of:\n```bash\nwg show wg0\n```\n\n### What WireGuard Traffic Looks Like\n\nWireGuard uses encrypted UDP packets for all traffic, it does not provide guarantees around packet delivery or ordering, as that is handled by TCP connections within the encrypted tunnel.\n\n<img src=\"https://github.com/Lekensteyn/wireguard-dissector/raw/master/wireshark-wg.png\" width=\"400px\"/><br/>\n\nFurther reading:\n\n- https://www.wireshark.org/docs/dfref/w/wg.html\n- https://github.com/Lekensteyn/wireguard-dissector\n- https://nbsoftsolutions.com/blog/viewing-wireguard-traffic-with-tcpdump\n\n### WireGuard Performance\n\nWireGuard claims faster performance than most other competing VPN solutions, though the exact numbers are sometimes debated and may depend on whether hardware-level acceleration is available for certain cryptographic ciphers.\n\nWireGuard's performance gains are achieved by handling routing at the kernel level, and by using modern cipher suites running on all cores to encrypt traffic. WireGuard also gains a significant advantage by using UDP with no delivery/ordering guarantees (compared to VPNs that run over TCP or implement their own guaranteed delivery mechanisms).\n\n<img src=\"https://i.imgur.com/heEYg59.png\" width=\"400px\"/>\n\n\nFurther reading:\n\n- https://www.wireguard.com/performance/\n- https://www.reddit.com/r/linux/comments/9bnowo/wireguard_benchmark_between_two_servers_with_10/\n- https://restoreprivacy.com/openvpn-ipsec-wireguard-l2tp-ikev2-protocols/\n\n\n### WireGuard Security Model\n\nWireGuard uses the following protocols and primitives to secure traffic:\n\n- ChaCha20 for symmetric encryption, authenticated with Poly1305, using RFC7539’s AEAD construction\n- Curve25519 for ECDH\n- BLAKE2s for hashing and keyed hashing, described in RFC7693\n- SipHash24 for hashtable keys\n- HKDF for key derivation, as described in RFC5869\n\n> WireGuard's cryptography is essentially an instantiation of Trevor Perrin's Noise framework. It's modern and, again, simple. Every other VPN option is a mess of negotiation and handshaking and complicated state machines. WireGuard is like the Signal/Axolotl of VPNs, except it's much simpler and easier to reason about (cryptographically, in this case) than double ratchet messaging protocols.\n> It is basically the qmail of VPN software.\n> And it's ~4000 lines of code. It is plural orders of magnitude smaller than its competitors.\n> \nhttps://news.ycombinator.com/item?id=14599834\n\nFurther reading:\n\n- https://www.wireguard.com/papers/wireguard.pdf\n- https://eprint.iacr.org/2018/080.pdf\n- https://courses.csail.mit.edu/6.857/2018/project/He-Xu-Xu-WireGuard.pdf\n- https://www.wireguard.com/talks/blackhat2018-slides.pdf\n- https://arstechnica.com/gadgets/2018/08/wireguard-vpn-review-fast-connections-amaze-but-windows-support-needs-to-happen/\n\n\n### How WireGuard Manages Keys\n\nAuthentication in both directions is achieved with a simple public/private key pair for each peer. Each peer generates these keys during the setup phase, and shares only the public key with other peers.\n\nNo other certificates or pre-shared keys are needed beyond the public/private keys for each node.\n\nKey generation, distribution, and revocation can be handled in larger deployments using a separate service like Ansible or Kubernetes Secrets.\n\nSome services that help with key distribution and deployment:\n\n- https://pypi.org/project/wireguard-p2p/\n- https://github.com/trailofbits/algo\n- https://github.com/StreisandEffect/streisand\n- https://github.com/its0x08/wg-install\n- https://github.com/brittson/wireguard_config_maker\n- https://www.wireguardconfig.com\n- https://github.com/UrielCh/wireguard\n\nYou can also read in keys from a file or via command if you don't want to hardcode them in `wg0.conf`, this makes managing keys via 3rd party service much easier:\n\n```ini\n[Interface]\n...\nPostUp = wg set %i private-key /etc/wireguard/wg0.key <(cat /some/path/%i/privkey)\n```\n\nTechnically, multiple servers can share the same private key as long as clients arent connected to two servers with the same key simulatenously.\nAn example of a scenario where this is a reasonable setup is if you're using round-robin DNS to load-balance connections between two servers that are pretending to be a single server.\nMost of the time however, every peer should have its own public/private keypair so that peers can't read eachothers traffic and can be individually revoked.\n\n---\n\n## Usage\n\n### QuickStart\n\nOverview of the general process:\n\n1. Install `apt install wireguard` or `pkg/brew install wireguard-tools` on each node\n2. Generate public and private keys locally on each node `wg genkey`+`wg pubkey`\n3. Create a `wg0.conf` WireGuard config file on the main relay server\n    - `[Interface]` Make sure to specify a CIDR range for the entire VPN subnet when defining the address the server accepts routes for `Address = 192.0.2.1/24`\n    - `[Peer]` Create a peer section for every client joining the VPN, using their corresponding remote public keys\n4. Create a `wg0.conf` on each client node\n   - `[Interface]` Make sure to specify only a single IP for client peers that don't relay traffic `Address = 192.0.2.3/32`.\n   - `[Peer]` Create a peer section for each public peer not behind a NAT, make sure to specify a CIDR range for the entire VPN subnet when defining the remote peer acting as the bounce server `AllowedIPs = 192.0.2.1/24`. Make sure to specify individual IPs for remote peers that don't relay traffic and only act as simple clients `AllowedIPs = 192.0.2.3/32`.\n5. Start WireGuard on the main relay server with `wg-quick up /full/path/to/wg0.conf`\n6. Start WireGuard on all the client peers with `wg-quick up /full/path/to/wg0.conf`\n7. Traffic is routed from peer to peer using most specific route first over the WireGuard interface, e.g. `ping 192.0.2.3` checks for a direct route to a peer with `AllowedIPs = 192.0.2.3/32` first, then falls back to a relay server that's accepting IPs in the whole subnet\n\n### Setup\n\n```bash\n# install on Ubuntu\nsudo add-apt-repository ppa:wireguard/wireguard\napt install wireguard\n\n# install on macOS\nbrew install wireguard-tools\n\n# install on FreeBSD\npkg install wireguard\n\n# install on iOS/Android using Apple App Store/Google Play Store\n# install on other systems using https://www.wireguard.com/install/#installation\n```\n\n```bash\n# to enable the kernel relaying/forwarding ability on bounce servers\necho \"net.ipv4.ip_forward = 1\" | sudo tee -a /etc/sysctl.conf\necho \"net.ipv4.conf.all.proxy_arp = 1\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p /etc/sysctl.conf\n\n# to add iptables forwarding rules on bounce servers\nsudo iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\nsudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\nsudo iptables -A FORWARD -i wg0 -o wg0 -m conntrack --ctstate NEW -j ACCEPT\nsudo iptables -t nat -A POSTROUTING -s 192.0.2.0/24 -o eth0 -j MASQUERADE\n```\n\n### Config Creation\n```bash\nnano wg0.conf  # can be placed anywhere, must be referred to using absolute path (usually placed in /etc/wireguard/wg0.conf on most Linux systems)\n```\n\n### Key Generation\n\n```bash\n# generate private key\nwg genkey > example.key\n\n# generate public key\nwg pubkey < example.key > example.key.pub\n```\n\n### Start / Stop\n\n```bash\nwg-quick up /full/path/to/wg0.conf\nwg-quick down /full/path/to/wg0.conf\n# Note: you must specify the absolute path to wg0.conf, relative paths won't work\n# If wg0.conf is in /etc/wireguard you can use the simpler:\nwg-quick up wg0\n```\n\n```bash\n# start/stop VPN network interface\nip link set wg0 up\nip link set wg0 down\n\n# register/unregister VPN network interface\nip link add dev wg0 type wireguard\nip link delete dev wg0\n\n# register/unregister local VPN address\nip address add dev wg0 192.0.2.3/32\nip address delete dev wg0 192.0.2.3/32\n\n# register/unregister VPN route\nip route add 192.0.2.3/32 dev wg0\nip route delete 192.0.2.3/32 dev wg0\n```\n\n\n### Inspect\n\n#### Interfaces\n\n```bash\n# show system LAN and WAN network interfaces\nip address show\n# or if ip is not available:\nifconfig\n\n# show system VPN network interfaces\nip link show wg0\n# or\nifconfig wg0\n\n# show WireGuard VPN interfaces\nwg show all\nwg show wg0\n```\n\n#### Addresses\n\n```bash\n# show public IP address\nip address show eth0\n# or\nifconfig eth0\n# or\ndig -4 +short myip.opendns.com @resolver1.opendns.com\n\n# show VPN IP address\nip address show wg0\n```\n\n#### Routes\n\n```bash\n# show WireGuard routing table and peer connections\nwg show\nwg show wg0 allowed-ips\n\n# show system routing table\nip route show table main\nip route show table local\n\n# show system route to specific address\nip route get 192.0.2.3\n```\n\n#### Logs\n\nTo enable additional logging run:\n```bash\nmodprobe wireguard\necho module wireguard +p > /sys/kernel/debug/dynamic_debug/control\n```\n\nTo follow logs:\n```bash\ndmesg -wH\n```\n\nSystems with modern kernel and Safe Boot might require disabling Secure Boot DKMS Signature Verification to allow access to kernel logs.\n```bash\nmokutil --disable-verification\nreboot\n```\n\n\n### Testing\n\n#### Ping Speed\n```bash\n# check that the main relay server is accessible directly via public internet\nping public-server1.example-vpn.dev\n\n# check that the main relay server is available via VPN\nping 192.0.2.1\n\n# check that public peers are available via VPN\nping 192.0.2.2\n\n# check that remote NAT-ed peers are available via VPN\nping 192.0.2.3\n\n# check that NAT-ed peers in your local LAN are available via VPN\nping 192.0.2.4\n```\n\n#### Bandwidth\n\n\n```bash\n# install iperf using your preferred package manager\napt/brew/pkg/opkg install iperf\n\n# check bandwidth over public internet to relay server\niperf -s # on public relay server\niperf -c public-server1.example-vpn.dev # on local client\n\n# check bandwidth over VPN to relay server\niperf -s # on public relay server\niperf -c 192.0.2.1 # on local client\n\n# check bandwidth over VPN to remote public peer\niperf -s # on remote public peer\niperf -c 192.0.2.2 # on local client\n\n# check bandwidth over VPN to remote NAT-ed peer\niperf -s # on remote NAT-ed peer\niperf -c 192.0.2.3 # on local client\n\n# check bandwidth over VPN to local NAT-ed peer (on same LAN)\niperf -s # on local NAT-ed peer\niperf -c 192.0.2.4 # on local client\n```\n\n#### DNS\n\nCheck for DNS leaks using http://dnsleak.com, or by checking the resolver on a lookup:\n```bash\ndig example.com A\n```\n\n---\n\n## Config Reference\n\n### Overview\n\nWireGuard config is in [INI syntax](https://en.wikipedia.org/wiki/INI_file), defined in a file usually called `wg0.conf`.  It can be placed anywhere on the system, but is often placed in `/etc/wireguard/wg0.conf`.  \n\nThe config path is specified as an argument when running any `wg-quick` command, e.g:  \n`wg-quick up /etc/wireguard/wg0.conf` (always specify the full, absolute path)\n\nThe config file name must be in the format `${name of the new WireGuard interface}.conf`. WireGuard interface names are typically prefixed with `wg` and numbered starting at `0`, but you can use any name that matches the regex `^[a-zA-Z0-9_=+.-]{1,15}$`.\n\nConfig files can opt to use the limited set of `wg` config options, or the more extended `wg-quick` options, depending on what command is preferred to start WireGuard.  These docs recommend sticking to `wg-quick` as it provides a more powerful and user-friendly config experience.\n\n**Jump to definition:**\n\n¶ <a href=\"#Interface\">`[Interface]`</a>  \n¶ <a href=\"#-Name\">`# Name = node1.example.tld`</a>  \n¶ <a href=\"#Address\">`Address = 192.0.2.3/32`</a>  \n¶ <a href=\"#ListenPort\">`ListenPort = 51820`</a>  \n¶ <a href=\"#PrivateKey\">`PrivateKey = localPrivateKeyAbcAbcAbc=`</a>  \n¶ <a href=\"#DNS-2\">`DNS = 1.1.1.1,8.8.8.8`</a>  \n¶ <a href=\"#Table\">`Table = 12345`</a>  \n¶ <a href=\"#MTU\">`MTU = 1500`</a>  \n¶ <a href=\"#PreUp\">`PreUp = /bin/example arg1 arg2 %i`</a>  \n¶ <a href=\"#PostUp\">`PostUp = /bin/example arg1 arg2 %i`</a>  \n¶ <a href=\"#PreDown\">`PreDown = /bin/example arg1 arg2 %i`</a>  \n¶ <a href=\"#PostDown\">`PostDown = /bin/example arg1 arg2 %i`</a>  \n\n\n¶ <a href=\"#Peer\">`[Peer]`</a>  \n¶ <a href=\"#-Name-1\">`# Name = node2-node.example.tld`</a>  \n¶ <a href=\"#AllowedIPs\">`AllowedIPs = 192.0.2.1/24`</a>  \n¶ <a href=\"#Endpoint\">`Endpoint = node1.example.tld:51820`</a>  \n¶ <a href=\"#PublicKey\">`PublicKey = remotePublicKeyAbcAbcAbc=`</a>  \n¶ <a href=\"#PersistentKeepalive\">`PersistentKeepalive = 25`</a>  \n\n### `[Interface]`\n\nDefines the VPN settings for the local node.\n\n**Examples**\n\n* Node is a client that only routes traffic for itself and only exposes one IP  \n```ini\n[Interface]\n# Name = phone.example-vpn.dev\nAddress = 192.0.2.5/32\nPrivateKey = <private key for phone.example-vpn.dev>\n```\n* Node is a public bounce server that can relay traffic to other peers and exposes route for entire VPN subnet  \n```ini\n[Interface]\n# Name = public-server1.example-vpn.tld\nAddress = 192.0.2.1/24\nListenPort = 51820\nPrivateKey = <private key for public-server1.example-vpn.tld>\nDNS = 1.1.1.1\n```\n\n#### `# Name`\n\nThis is just a standard comment in INI syntax used to help keep track of which config section belongs to which node, it's completely ignored by WireGuard and has no effect on VPN behavior.\n\nNOTE: All comments, including `# Name`, are removed from the .conf files by certain operations and applications. \nIf you need to identify peers, consider using a wireguard vanity key generator, such as \n[wireguard-vanity-keygen](https://github.com/axllent/wireguard-vanity-keygen) or \n[wireguard-vanity-address](https://github.com/warner/wireguard-vanity-address),\nwhich will allow you to include the host name in the public key of the host.\nThe key generation can take minutes (4 characters), hours (5 characters) or longer,\nso consider using an abbreviation for hosts with longer names.\n\n#### `Address`\n\nDefines what address range the local node should route traffic for. Depending on whether the node is a simple client joining the VPN subnet, or a bounce server that's relaying traffic between multiple clients, this can be set to a single IP of the node itself (specified with CIDR notation), e.g. 192.0.2.3/32), or a range of IPv4/IPv6 subnets that the node can route traffic for.\n\n**Examples**\n\n* Node is a client that only routes traffic for itself  \n`Address = 192.0.2.3/32`\n\n* Node is a public bounce server that can relay traffic to other peers  \nWhen the node is acting as the public bounce server, it should set this to be the entire subnet that it can route traffic, not just a single IP for itself.\n\n`Address = 192.0.2.1/24`\n\n* You can also specify multiple subnets or IPv6 subnets like so:  \n`Address = 192.0.2.1/24,2001:DB8::/64`\n\n#### `ListenPort`\n\nWhen the node is acting as a public bounce server, it should hardcode a port to listen for incoming VPN connections from the public internet.  Clients not acting as relays should not set this value.\n\n**Examples**\n\n* Using default WireGuard port  \n`ListenPort = 51820`\n* Using custom WireGuard port  \n`ListenPort = 7000`\n\n#### `PrivateKey`\n\nThis is the private key for the local node, never shared with other servers.\nAll nodes must have a private key set, regardless of whether they are public bounce servers relaying traffic, or simple clients joining the VPN.\n\nThis key can be generated with `wg genkey > example.key`\n\n**Examples**\n\n`PrivateKey = somePrivateKeyAbcdAbcdAbcdAbcd=`\n\n#### `DNS`\n\nThe DNS server(s) to announce to VPN clients via DHCP, most clients will use this server for DNS requests over the VPN, but clients can also override this value locally on their nodes\n\n**Examples**\n\n* The value can be left unconfigured to use the system's default DNS servers\n* A single DNS server can be provided  \n`DNS = 1.1.1.1`\n* or multiple DNS servers can be provided  \n`DNS = 1.1.1.1,8.8.8.8`\n\n#### `Table`\n\nOptionally defines which routing table to use for the WireGuard routes, not necessary to configure for most setups.\n\nThere are two special values: ‘off’ disables the creation of routes altogether, and ‘auto’ (the default) adds routes to the default table and enables special handling of default routes.\n\nhttps://git.zx2c4.com/WireGuard/about/src/tools/man/wg-quick.8\n\n**Examples**\n\n```ini\nTable = 1234\n```\n\n#### `MTU`\n\nOptionally defines the maximum transmission unit (MTU, aka packet/frame size) to use when connecting to the peer, not necessary to configure for most setups.\n\nThe MTU is automatically determined from the endpoint addresses or the system default route, which is usually a sane choice.\n\nhttps://git.zx2c4.com/WireGuard/about/src/tools/man/wg-quick.8\n\n**Examples**\n\n```ini\nMTU = 1500\n```\n\n\n#### `PreUp`\n\nOptionally run a command before the interface is brought up.\nThis option can be specified multiple times, with commands executed in the order they appear in the file.\n\n**Examples**\n\n* Add an IP route\n`PreUp = ip rule add ipproto tcp dport 22 table 1234`\n\n#### `PostUp`\n\nOptionally run a command after the interface is brought up.\nThis option can appear multiple times, as with <a href=\"#PreUp\">PreUp</a>\n\n**Examples**\n\n* Read in a config value from a file or some command's output  \n`PostUp = wg set %i private-key /etc/wireguard/wg0.key <(some command here)`\n\n* Log a line to a file  \n`PostUp = echo \"$(date +%s) WireGuard Started\" >> /var/log/wireguard.log`\n\n* Hit a webhook on another server  \n`PostUp = curl https://events.example.dev/wireguard/started/?key=abcdefg`\n\n* Add a route to the system routing table  \n`PostUp = ip rule add ipproto tcp dport 22 table 1234`\n\n* Add an iptables rule to enable packet forwarding on the WireGuard interface  \n`PostUp   = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE`\n\n* Force WireGuard to re-resolve IP address for peer domain  \n`PostUp = resolvectl domain %i \"~.\"; resolvectl dns %i 192.0.2.1; resolvectl dnssec %i yes`\n\n#### `PreDown`\n\nOptionally run a command before the interface is brought down.\nThis option can appear multiple times, as with <a href=\"#PreUp\">PreUp</a>\n\n**Examples**\n\n* Log a line to a file  \n`PostDown = echo \"$(date +%s) WireGuard Going Down\" >> /var/log/wireguard.log`\n\n* Hit a webhook on another server  \n`PostDown = curl https://events.example.dev/wireguard/stopping/?key=abcdefg`\n\n\n#### `PostDown`\n\nOptionally run a command after the interface is brought down.\nThis option can appear multiple times, as with <a href=\"#PreUp\">PreUp</a>\n\n**Examples**\n\n* Log a line to a file  \n`PostDown = echo \"$(date +%s) WireGuard Stopped\" >> /var/log/wireguard.log`\n\n* Hit a webhook on another server  \n`PostDown = curl https://events.example.dev/wireguard/stopped/?key=abcdefg`\n\n* Remove the iptables rule that forwards packets on the WireGuard interface  \n`PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE`\n\n\n### `[Peer]`\n\nDefines the VPN settings for a remote peer capable of routing traffic for one or more addresses (itself and/or other peers). Peers can be either a public bounce server that relays traffic to other peers, or a directly accessible client via LAN/internet that is not behind a NAT and only routes traffic for itself.\n\nAll clients must be defined as peers on the public bounce server. Simple clients that only route traffic for themselves, only need to define peers for the public relay, and any other nodes directly accessible.  Nodes that are behind separate NATs should _not_ be defined as peers outside of the public server config, as no direct route is available between separate NATs. Instead, nodes behind NATs should only define the public relay servers and other public clients as their peers, and should specify `AllowedIPs = 192.0.2.1/24` on the public server that accept routes and bounce traffic for the VPN subnet to the remote NAT-ed peers.\n\nIn summary, all nodes must be defined on the main bounce server.  On client servers, only peers that are directly accessible from a node should be defined as peers of that node, any peers that must be relayed by a bounce server should be left out and will be handled by the relay server's catchall route.\n\nIn the configuration outlined in the docs below, a single server `public-server1` acts as the relay bounce server for a mix of publicly accessible and NAT-ed clients, and peers are configured on each node accordingly:\n\n- **in `public-server1` `wg0.conf` (bounce server)**  \n  `[peer]` list: `public-server2`, `home-server`, `laptop`, `phone`\n\n- **in `public-server2` `wg0.conf` (simple public client)**  \n  `[peer]` list: `public-server1`\n\n- **in `home-server` `wg0.conf` (simple client behind NAT)**  \n  `[peer]` list: `public-server1`, `public-server2`\n\n- **in `laptop` `wg0.conf` (simple client behind NAT)**  \n  `[peer]` list: `public-server1`, `public-server2`\n\n- **in `phone` `wg0.conf` (simple client behind NAT)**  \n  `[peer]` list: `public-server1`, `public-server2`\n\n**Examples**\n\n - Peer is a simple public client that only routes traffic for itself  \n```ini\n[Peer]\n# Name = public-server2.example-vpn.dev\nEndpoint = public-server2.example-vpn.dev:51820\nPublicKey = <public key for public-server2.example-vpn.dev>\nAllowedIPs = 192.0.2.2/32\n```\n\n - Peer is a simple client behind a NAT that only routes traffic for itself  \n```ini\n[Peer]\n# Name = home-server.example-vpn.dev\nEndpoint = home-server.example-vpn.dev:51820\nPublicKey = <public key for home-server.example-vpn.dev>\nAllowedIPs = 192.0.2.3/32\n```\n\n - Peer is a public bounce server that can relay traffic to other peers  \n```ini\n[Peer]\n# Name = public-server1.example-vpn.tld\nEndpoint = public-server1.example-vpn.tld:51820\nPublicKey = <public key for public-server1.example-vpn.tld>\n# routes traffic to itself and entire subnet of peers as bounce server\nAllowedIPs = 192.0.2.1/24\nPersistentKeepalive = 25\n```\n\n#### `# Name`\n\nThis is just a standard comment in INI syntax used to help keep track of which config section belongs to which node, it's completely ignored by WireGuard and has no effect on VPN behavior.\n\n#### `Endpoint`\n\nDefines the publicly accessible address for a remote peer.  This should be left out for peers behind a NAT or peers that don't have a stable publicly accessible IP:PORT pair.  Typically, this only needs to be defined on the main bounce server, but it can also be defined on other public nodes with stable IPs like `public-server2` in the example config below.\n\n**Examples**\n\n - Endpoint is an IP address  \n`Endpoint = 123.124.125.126:51820`  (IPv6 is also supported)\n - Endpoint is a hostname/FQDN  \n`Endpoint = public-server1.example-vpn.tld:51820`\n\n#### `AllowedIPs`\n\nThis defines the IP ranges for which a peer will route traffic.  On simple clients, this is usually a single address (the VPN address of the simple client itself). For bounce servers this will be a range of the IPs or subnets that the relay server is capable of routing traffic for.  Multiple IPs and subnets may be specified using comma-separated IPv4 or IPv6 CIDR notation (from a single /32 or /128 address, all the way up to `0.0.0.0/0` and `::/0` to indicate a default route to send all internet and VPN traffic through that peer).  This option may be specified multiple times.\n\nWhen deciding how to route a packet, the system chooses the most specific route first, and falls back to broader routes. So for a packet destined to `192.0.2.3`, the system would first look for a peer advertising `192.0.2.3/32` specifically, and would fall back to a peer advertising `192.0.2.1/24` or a larger range like `0.0.0.0/0` as a last resort.\n\n**Examples**\n\n\n - peer is a simple client that only accepts traffic to/from itself  \n`AllowedIPs = 192.0.2.3/32`\n\n - peer is a relay server that can bounce VPN traffic to all other peers  \n`AllowedIPs = 192.0.2.1/24`\n\n - peer is a relay server that bounces all internet & VPN traffic (like a proxy), including IPv6  \n`AllowedIPs = 0.0.0.0/0,::/0`\n\n - peer is a relay server that routes to itself and only one other peer  \n`AllowedIPs = 192.0.2.3/32,192.0.2.4/32`\n\n - peer is a relay server that routes to itself and all nodes on its local LAN  \n`AllowedIPs = 192.0.2.3/32,192.168.1.1/24`\n\n#### `PublicKey`\n\nThis is the public key for the remote node, shareable with all peers.\nAll nodes must have a public key set, regardless of whether they are public bounce servers relaying traffic, or simple clients joining the VPN.\n\nThis key can be generated with `wg pubkey < example.key > example.key.pub`.\n(see above for how to generate the private key `example.key`)\n\n**Examples**\n\n`PublicKey = somePublicKeyAbcdAbcdAbcdAbcd=`\n\n#### `PersistentKeepalive`\n\nIf the connection is going from a NAT-ed peer to a public peer, the node behind the NAT must regularly send an outgoing ping in order to keep the bidirectional connection alive in the NAT router's connection table.\n\n**Examples**\n\n - local public node to remote public node  \n  This value should be left undefined as persistent pings are not needed.\n  \n - local public node to remote NAT-ed node  \n  This value should be left undefined as it's the client's responsibility to keep the connection alive because the server cannot reopen a dead connection to the client if it times out.\n  \n - local NAT-ed node to remote public node  \n`PersistentKeepalive = 25` this will send a ping to every 25 seconds keeping the connection open in the local NAT router's connection table.\n\n---\n\n## Advanced Topics\n\n### IPv6\n\nThe examples in these docs primarily use IPv4, but WireGuard natively supports IPv6 CIDR notation and addresses everywhere that it supports IPv4, simply add them as you would any other subnet range or address.\n\n**Example**\n\n```ini\n[Interface]\nAddress = 192.0.2.3/24, 2001:DB8::/64\n\n[Peer]\n...\nAllowedIPs = 0.0.0.0/0, ::/0\n```\n\n### Forwarding All Traffic\n\nIf you want to forward *all* internet traffic through the VPN, and not just use it as a server-to-server subnet, you can add `0.0.0.0/0, ::/0` to the `AllowedIPs` definition of the peer you want to pipe your traffic through.\n\nMake sure to also specify an IPv6 catchall even when only forwarding IPv4 traffic in order to avoid leaking IPv6 packets outside the VPN, see:  \nhttps://www.reddit.com/r/WireGuard/comments/b0m5g2/ipv6_leaks_psa_for_anyone_here_using_wireguard_to/\n\n**Example**\n\n```ini\n[Interface]\n# Name = phone.example-vpn.dev\nAddress = 192.0.2.3/32\nPrivateKey = <private key for phone.example-vpn.dev>\n\n[Peer]\n# Name = public-server1.example-vpn.dev\nPublicKey = <public key for public-server1.example-vpn.dev>\nEndpoint = public-server1.example-vpn.dev:51820\nAllowedIPs = 0.0.0.0/0, ::/0\n```\n\n### NAT To NAT Connections\n\nWireGuard can sometimes natively make connections between two clients behind NATs without the need for a public relay server, but in most cases this is not possible. NAT-to-NAT connections are only possible if at least one host has a stable, publicly-accessible IP address:port pair that can be hardcoded ahead of time, whether that's using a FQDN updated with Dynamic DNS, or a static public IP with a non-randomized NAT port opened by outgoing packets, anything works as long as all peers can communicate it beforehand and it doesn't change once the connection is initiated.\n\nA known port and address need to be configured ahead of time because WireGuard doesn't have a signalling layer or public STUN servers that can be used to search for other hosts dynamically.  WebRTC is an example of a protocol that can dynamically configure a connection between two NATs, but it does this by using an out-of-band signaling server to detect the IP:port combo of each host. WireGuard doesn't have this, so it only works with a hardcoded `Endpoint` + `ListenPort` (and `PersistentKeepalive` so it doesn't drop after inactivity).\n\nLearn more from Tailscale's bible of NAT traversal: https://tailscale.com/blog/how-nat-traversal-works/\n\n#### Requirements for NAT-to-NAT setups\n\n - At least one peer has to have to have a hardcoded, directly-accessible `Endpoint` defined. If they're both behind NATs without stable IP addresses, then you'll need to use Dynamic DNS or another solution to have a stable, publicly accessibly domain/IP for at least one peer\n - At least one peer has to have a hardcoded UDP `ListenPort` defined, and it's NAT router must not do UDP source port randomization, otherwise return packets will be sent to the hardcoded `ListenPort` and dropped by the router, instead of using the random port assigned by the NAT on the outgoing packet\n - All NAT'ed peers must have `PersistentKeepalive` enabled on all other peers, so that they continually send outgoing pings to keep connections persisted in their NAT's routing table\n\n#### The hole-punching connection process\n\n 1. Peer1 sends a UDP packet to Peer2, it's rejected Peer2's NAT router immediately, but that's ok, the only purpose was to get Peer1's NAT to start forwarding any expected UDP responses back to Peer1 behind its NAT\n 2. Peer2 sends a UDP packet to Peer1, it's accepted and forwarded to Peer1 as Peer1's NAT server is already expecting responses from Peer2 because of the initial outgoing packet\n 3. Peer1 sends a UDP response to Peer2's packet, it's accepted and forwarded by Peer2's NAT server as it's also expecting responses because of the initial outgoing packet \n\nThis process of sending an initial packet that gets rejected, then using the fact that the router has now created a forwarding rule to accept responses is called \"UDP hole-punching\".\n\nWhen you send a UDP packet out, the router (usually) creates a temporary rule mapping your source address and port to the destination address and port, and vice versa. UDP packets returning from the destination address and port (and no other) are passed through to the original source address and port (and no other). This is how most UDP applications function behind NATs (e.g. BitTorrent, Skype, etc). This rule will timeout after some minutes of inactivity, so the client behind the NAT must send regular outgoing packets to keep it open (see `PersistentKeepalive`).\n\nGetting this to work when both end-points are behind NATs or firewalls requires that both end-points send packets to each-other at about the same time. This means that both sides need to know each-other's public IP addresses and port numbers ahead of time, in WireGuard's case this is achieved by hard-coding pre-defined ports for both sides in `wg0.conf`.\n\n#### Drawbacks and limitations\n\nAs of 2019, many of the old hole-punching methods used that used to work are no longer effective.  One example was a novel method pioneered by [pwnat](https://github.com/samyk/pwnat) that faked an ICMP Time Exceeded response from outside the NAT to get a packet back through to a NAT'ed peer, thereby leaking its own source port. Hardcoding UDP ports and public IPs for both sides of a NAT-to-NAT connection (as described above) still works on a small percentage of networks. Generally the more \"enterprisey\" a network is, the less likely you'll be able to hole punch public UDP ports (commercial public Wi-Fi and cell data NATs often don't work for example). \n\n##### Source port randomization\n\nNAT-to-NAT connections are not possible if all endpoints are behind NAT's with strict UDP source port randomization (e.g. most cellular data networks).  Since neither side is able to hardcode a `ListenPort` and guarantee that their NAT will accept traffic on that port after the outgoing ping, you cannot coordinate a port for the initial hole-punch between peers and connections will fail.  For this reason, you generally cannot do phone-to-phone connections on LTE/3g networks, but you might be able to do phone-to-office or phone-to-home where the office or home has a stable public IP and doesn't do source port randomization.\n\n##### Using a signaling server\n\nNAT-to-NAT connections from behind NATs with strict source-port randomization is possible, you just need a signaling server to tell each side the other's IP:port tuple.  Here are a few implementations that achieve this with WireGuard:\n\n- https://github.com/takutakahashi/wg-connect\n- https://git.zx2c4.com/wireguard-tools/tree/contrib/nat-hole-punching/\n- https://github.com/jwhited/wgsd\n\n##### Dynamic IP addresses\nMany users report having to restart WireGuard whenever a dynamic IP changes, as it only resolves hostnames on startup. To force WireGuard to re-resolve dynamic DNS `Endpoint` hostnames more often, you may want to use a `PostUp` hook to restart WireGuard every few minutes or hours.\n\n\n#### Testing it out\n\nYou can see if a hole-punching setup is feasible by using netcat on the client and server to see what ports and connection order work to get a bidirectional connection open: run `nc -v -u -p 51820 <address of peer2> 51820` (on peer1) and `nc -v -u -l 0.0.0.0 51820` (on peer2), then type in both windows to see if you can get bidirectional traffic going.  If it doesn't work regardless of which peer sends the initial packet, then WireGuard won't be unable to work between the peers without a public relay server.\n\nNAT-to-NAT connections are often more unstable and have other limitations, which is why having a fallback public relay server is still advised.\n\n#### Further reading\n\n - https://github.com/samyk/pwnat\n - https://en.wikipedia.org/wiki/UDP_hole_punching\n - https://stackoverflow.com/questions/8892142/udp-hole-punching-algorithm\n - https://stackoverflow.com/questions/12359502/udp-hole-punching-not-going-through-on-3g\n - https://stackoverflow.com/questions/11819349/udp-hole-punching-not-possible-with-mobile-provider\n - https://github.com/WireGuard/WireGuard/tree/master/contrib/examples/nat-hole-punching\n - https://staaldraad.github.io/2017/04/17/nat-to-nat-with-wireguard/\n - https://golb.hplar.ch/2019/01/expose-server-vpn.html\n - https://www.jordanwhited.com/posts/wireguard-endpoint-discovery-nat-traversal/\n\n**Example**\n\n*Peer1:*\n```ini\n[Interface]\n...\nListenPort 12000\n\n[Peer]\n...\nEndpoint = peer2.example-vpn.dev:12000\nPersistentKeepalive = 25\n```\n\n*Peer2:*\n```ini\n[Interface]\n...\nListenPort 12000\n\n[Peer]\n...\nEndpoint = peer1.example-vpn.dev:12000\nPersistentKeepalive = 25\n```\n\n### Dynamic IP Allocation\n\n*Note: this section is about dynamic peer IPs within the VPN subnet, not dynamic public `Endpoint` addresses*.\n\nDynamic allocation of peer IPs (instead of only having fixed peers) is being developed, the WIP implementation is available here:\nhttps://github.com/WireGuard/wg-dynamic\n\nYou can also build a dynamic allocation system yourself by reading in IP values from files at runtime by using `PostUp` (see below).\n\n**Example**\n```ini\n[Interface]\n...\nPostUp = wg set %i allowed-ips /etc/wireguard/wg0.key <(some command)\n```\n\n### Other WireGuard Implementations\n\n- https://git.zx2c4.com/wireguard-go/about/  \nA compliant userland WireGuard implementation written in Go.\n\n- https://git.zx2c4.com/wireguard-rs/about/  \nAn incomplete, insecure userspace implementation of WireGuard written in Rust (not ready for the public).\n\n- https://git.zx2c4.com/wireguard-hs/about/  \nAn incomplete, insecure userspace implementation of WireGuard written in Haskell (not ready for the public).\n\n- https://github.com/cloudflare/boringtun  \nA non-compliant, independent WireGuard implementation written in Rust (a separate fork written by CloudFlare).\nSee https://blog.cloudflare.com/boringtun-userspace-wireguard-rust/\n\n- Platform-specific WireGuard apps  \nhttps://git.zx2c4.com/wireguard-ios/about/  \nhttps://git.zx2c4.com/wireguard-android/about/  \nhttps://git.zx2c4.com/wireguard-windows/about/  \n\nAll of the userspace implementations are slower than the native C version that runs in kernel-land, but provide other benefits by running in userland (e.g. easier containerization, compatibility, etc.).\n\n### WireGuard Setup Tools\n\nThese are some GUI and CLI tools that wrap WireGuard to assist with config, deployment, key management, and connection.\n\n - https://github.com/weejewel/wg-easy\n - https://github.com/seashell/drago\n - https://github.com/gravitl/netmaker\n - https://github.com/vx3r/wg-gen-web\n - https://github.com/subspacecloud/subspace\n - https://github.com/corrad1nho/qomui\n - https://github.com/max-moser/network-manager-wireguard\n - https://github.com/psyhomb/wireguard-tools\n - https://github.com/its0x08/wg-install\n - https://github.com/sowbug/mkwgconf\n - https://github.com/brittson/wireguard_config_maker\n - https://github.com/SirToffski/WireGuard-Ligase/\n - https://pypi.org/project/wireguard-p2p/\n - https://github.com/trailofbits/algo\n - https://github.com/StreisandEffect/streisand\n - https://www.veeam.com/blog/veeam-pn-v2-wireguard.html\n - https://github.com/wg-dashboard/wg-dashboard\n - https://www.wireguardconfig.com\n - https://github.com/complexorganizations/wireguard-manager\n - https://github.com/influxdata/wirey\n - https://github.com/apognu/wgctl\n - https://github.com/naggie/dsnet\n - https://github.com/perara/wg-manager\n - https://github.com/pivpn/pivpn\n - https://github.com/BrunIF/wg-ccg\n - https://github.com/freifunkMUC/wg-access-server\n - https://github.com/firezone/firezone\n\n\n### Config Shortcuts\n\nCredit for these shortcuts goes to: \nhttps://www.ericlight.com/new-things-i-didnt-know-about-wireguard.html\n\n#### Sharing a single peers.conf file\n\nWireGuard will ignore a peer whose public key matches the interface's private key. So you can distribute a single list of peers everywhere, and only define the `[Interface]` separately on each server.\n\nSee: https://lists.zx2c4.com/pipermail/wireguard/2018-December/003703.html\n\nYou can combine this with `wg addconf` like this:\n\n* Each peer has its own `/etc/wireguard/wg0.conf` file, which only contains its `[Interface]` section.\n\n* Each peer also has a shared `/etc/wireguard/peers.conf` file, which contains all the peers.\n\n* The `wg0.conf` file also has a `PostUp` hook: `PostUp = wg addconf /etc/wireguard/peers.conf`.\n\nIt's up to you to decide how you want to share the `peers.conf`, be it via a proper orchestration platform, something much more pedestrian like Dropbox, or something kinda wild like Ceph. I dunno, but it's pretty great that you can just wildly fling a peer section around, without worrying whether it's the same as the interface.\n\n#### Setting config values from files or command outputs\n\nYou can set config values from arbitrary commands or by reading in values from files, this makes key management and deployment much easier as you can read in keys at runtime from a 3rd party service like Kubernetes Secrets or AWS KMS.\n\nSee: https://lists.zx2c4.com/pipermail/wireguard/2018-December/003702.html\n\n**Example**\n\nYou can read in a file as the `PrivateKey` by doing something like:\n\n`PostUp = wg set %i private-key /etc/wireguard/wg0.key <(some command)`\n\n\n### Containerization\n\nWireGuard can be run in Docker with varying degrees of ease. In the simplest case, `--privileged` and `--cap-add=all` arguments can be added to the docker commands to enable the loading of the kernel module.\n\nSetups can get somewhat complex and are highly dependent on what you're trying to achieve. You can have WireGuard itself run in a container and expose a network interface to the host, or you can have WireGuard running on the host exposing an interface to specific containers.\n\nSee below for an example of a Docker container `vpn_test` routing all its traffic through a WireGuard relay server.\n\n#### Example Relay Server Setup\n\n```yaml\nversion: '3'\n\nservices:\n  wireguard:\n    image: linuxserver/wireguard\n    ports:\n      - 51820:51820/udp\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /lib/modules:/lib/modules\n      - ./wg0.conf:/config/wg0.conf:ro\n```\n**`wg0.conf`:**\n```ini\n[Interface]\n# Name = relay1.wg.example.com\nAddress = 192.0.2.1/24\nListenPort = 51820\nPrivateKey = oJpRt2Oq27vIB5/UVb7BRqCwad2YMReQgH5tlxz8YmI=\nDNS = 1.1.1.1,8.8.8.8\nPostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE; ip6tables -A FORWARD -i wg0  -j ACCEPT; ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\nPostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o eth0 -j MASQUERADE\n\n[Peer]\n# Name = peer1.wg.example.com\nPublicKey = I+hXRAJOG/UE2IQvIHsou2zTgkUyPve2pzvHTnd/2Gg=\nAllowedIPs = 192.0.2.2/32\n```\n\n#### Example Client Container Setup\n\nIn this example *all* the traffic from inside the `speedtest` container will go through the wireguard VPN.\nTo only route some traffic, replace `0.0.0.0/0` in `wg0.conf` below with the subnet ranges you want to route via the VPN.\n\n**`docker-compose.yml`:**\n```yaml\nversion: '3'\n\nservices:\n  wireguard:\n    image: linuxserver/wireguard\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    volumes:\n      - /lib/modules:/lib/modules\n      - ./wg0.conf:/config/wg0.conf:ro\n    \n  vpn_test:\n    image: curlimages/curl\n    entrypoint: curl -s http://whatismyip.akamai.com/\n    network_mode: 'service:wireguard'\n```\n**`wg0.conf`:**\n```ini\n[Interface]\n# Name = peer1.wg.example.com\nAddress = 192.0.2.2/32\nPrivateKey = YCW76edD4W7nZrPbWZxPZhcs32CsBLIi1sEhsV/sgk8=\nDNS = 1.1.1.1,8.8.8.8\n\n[Peer]\n# Name = relay1.wg.example.com\nEndpoint = relay1.wg.example.com:51820\nPublicKey = zJNKewtL3gcHdG62V3GaBkErFtapJWsAx+2um0c0B1s=\nAllowedIPs = 192.0.2.1/24,0.0.0.0/0\nPersistentKeepalive = 21\n```\n\nFor more details see the Further Reading: Docker section below.\n\n---\n\n# Further Reading\n\n### Reference Docs\n\n- https://www.wireguard.com/install/#installation\n- https://git.zx2c4.com/WireGuard/about/src/tools/man/wg.8\n- https://git.zx2c4.com/WireGuard/about/src/tools/man/wg-quick.8\n- https://wiki.archlinux.org/index.php/WireGuard / https://wiki.archlinux.org/title/WireGuard\n- https://wiki.debian.org/Wireguard#Configuration\n- https://docs.netgate.com/pfsense/en/latest/vpn/wireguard/index.html\n- https://www.procustodibus.com/blog/2020/10/wireguard-topologies/\n\n### Tutorials\n\n- https://www.wireguard.com/quickstart/\n- https://www.stavros.io/posts/how-to-configure-wireguard/\n- https://nbsoftsolutions.com/blog/wireguard-vpn-walkthrough\n- https://networkhobo.com/building-a-wireguard-router/\n- https://proprivacy.com/guides/wireguard-hands-on-guide\n- https://angristan.xyz/how-to-setup-vpn-server-wireguard-nat-ipv6/\n- https://medium.com/@headquartershq/setting-up-wireguard-on-a-mac-8a121bfe9d86\n- https://grh.am/2018/wireguard-setup-guide-for-ios/\n- https://techcrunch.com/2018/07/28/how-i-made-my-own-wireguard-vpn-server/\n- https://www.ckn.io/blog/2017/11/14/wireguard-vpn-typical-setup/\n- https://jrs-s.net/2018/08/05/routing-between-wg-interfaces-with-wireguard/\n- https://www.stavros.io/posts/how-to-configure-wireguard/\n- https://vincent.bernat.ch/en/blog/2018-route-based-vpn-wireguard\n- https://staaldraad.github.io/2017/04/17/nat-to-nat-with-wireguard\n- https://try.popho.be/wg.html\n- https://docs.artemix.org/sysadmin/wireguard-management/\n- https://github.com/adrianmihalko/raspberrypiwireguard\n- https://www.ericlight.com/wireguard-part-one-installation.html\n- https://www.ericlight.com/wireguard-part-two-vpn-routing.html\n- https://www.ericlight.com/wireguard-part-three-troubleshooting.html\n- https://wiki.dd-wrt.com/wiki/index.php/The_Easiest_Tunnel_Ever\n- https://www.reddit.com/r/pihole/comments/bnihyz/guide_how_to_install_wireguard_on_a_raspberry_pi/\n- https://jwillmer.de/blog/tutorial/wireguard-proxy-configuration\n- https://www.maths.tcd.ie/~fionn/misc/wireguard.php\n- https://www.linode.com/docs/networking/vpn/set-up-wireguard-vpn-on-debian/\n- https://golb.hplar.ch/2019/01/expose-server-vpn.html\n- https://medium.com/@jmarhee/configuring-and-managing-routes-between-multiple-networks-with-wireguard-61ad995c887c\n- https://stanislas.blog/2019/01/how-to-setup-vpn-server-wireguard-nat-ipv6/\n\n### Papers, Articles, and Talks\n\n- https://www.wireguard.com/papers/wireguard.pdf\n- https://www.wireguard.com/presentations/\n- https://eprint.iacr.org/2018/080.pdf\n- https://courses.csail.mit.edu/6.857/2018/project/He-Xu-Xu-WireGuard.pdf\n- https://arstechnica.com/gadgets/2018/08/wireguard-vpn-review-fast-connections-amaze-but-windows-support-needs-to-happen/\n- https://www.wireguard.com/talks/blackhat2018-slides.pdf\n\n### Related Projects\n\n- https://github.com/weejewel/wg-easy\n- https://github.com/gravitl/netmaker\n- https://github.com/complexorganizations/wireguard-manager\n- https://github.com/subspacecloud/subspace\n- https://github.com/trailofbits/algo\n- https://github.com/StreisandEffect/streisand\n- https://github.com/its0x08/wg-install\n- https://github.com/sowbug/mkwgconf\n- https://github.com/brittson/wireguard_config_maker\n- https://github.com/SirToffski/WireGuard-Ligase/\n- https://pypi.org/project/wireguard-p2p/\n- https://github.com/cloudflare/boringtun\n- https://git.zx2c4.com/wireguard-go/about/\n- https://github.com/WireGuard/wg-dynamic\n- https://github.com/WireGuard/wireguard-ios\n- https://github.com/WireGuard/wireguard-windows\n- https://github.com/WireGuard/wireguard-rs\n- https://github.com/WireGuard/wireguard-go\n- https://www.veeam.com/blog/veeam-pn-v2-wireguard.html\n- https://github.com/wg-dashboard/wg-dashboard\n- https://wirtbot.com\n- https://github.com/seashell/drago\n- https://www.wireguardconfig.com\n- https://github.com/angristan/wireguard-install\n- https://github.com/complexorganizations/wireguard-manager\n- https://github.com/influxdata/wirey\n- https://github.com/apognu/wgctl\n- https://github.com/tailscale/tailscale\n- https://github.com/pivpn/pivpn\n- https://github.com/jwhited/wgsd\n- https://github.com/freifunkMUC/wg-access-server\n- https://github.com/firezone/firezone\n\n### Docker\n\n\n- https://blog.jessfraz.com/post/installing-and-using-wireguard/\n- https://codeopolis.com/posts/installing-wireguard-in-docker/\n- http://tiven.wang/articles/wireguard-setup-server-in-docker/\n- https://github.com/activeeos/wireguard-docker\n- https://github.com/cmulk/wireguard-docker\n- https://github.com/ironhalik/docker-wireguard\n- https://github.com/linuxserver/docker-wireguard\n- https://github.com/squat/kilo\n- https://github.com/gravitational/wormhole\n- https://medium.com/@mdp/securing-docker-with-wireguard-82ad45004f4d\n- https://nbsoftsolutions.com/blog/leaning-on-algo-to-route-docker-traffic-through-wireguard\n- https://nbsoftsolutions.com/blog/routing-select-docker-containers-through-wireguard-vpn\n- https://www.net.in.tum.de/fileadmin/bibtex/publications/theses/2018-pudelko-vpn-performance.pdf\n- https://www.wireguard.com/#ready-for-containers\n- https://discuss.linuxcontainers.org/t/solved-wireguard-in-macvlan-container-on-ubuntu-18-04/4445\n- https://www.reddit.com/r/WireGuard/comments/gdhcej/trouble_tunneling_docker_containers_through_a/\n- https://forums.unraid.net/topic/91367-partially-working-wireguard-docker/\n- https://saasbootstrap.com/how-to-setup-a-vpn-with-wireguard-that-only-routes-traffic-from-a-specific-docker-container-or-specific-ip/\n\n### Other\n\n- https://blog.cloudflare.com/boringtun-userspace-wireguard-rust/\n- https://jrs-s.net/category/open-source/wireguard/\n- https://restoreprivacy.com/openvpn-ipsec-wireguard-l2tp-ikev2-protocols/\n- https://restoreprivacy.com/wireguard/\n- https://www.ericlight.com/new-things-i-didnt-know-about-wireguard.html\n- https://www.ericlight.com/tag/wireguard.html\n- https://www.linode.com/docs/networking/vpn/set-up-wireguard-vpn-on-ubuntu/\n- https://www.reddit.com/r/linux/comments/9bnowo/wireguard_benchmark_between_two_servers_with_10/\n- https://www.wireguard.com/netns/\n- https://www.wireguard.com/performance/\n- https://blogs.gnome.org/thaller/2019/03/15/wireguard-in-networkmanager/\n- https://github.com/max-moser/network-manager-wireguard\n- https://blog.linuxserver.io/2019/11/24/connect-an-ubuntu-client-to-opnsense-wireguard-tunnel-with-a-gui-toggle-in-gnome/\n- https://im.salty.fish/index.php/archives/linux-networking-shallow-dive.html\n\n\n### Discussions\n\n- https://www.reddit.com/r/WireGuard\n- https://lists.zx2c4.com/mailman/listinfo/wireguard\n- https://www.reddit.com/r/VPN/comments/a914mr/can_you_explain_the_difference_between_openvpn/\n- https://www.reddit.com/r/WireGuard/comments/b0m5g2/ipv6_leaks_psa_for_anyone_here_using_wireguard_to/?utm_source=reddit&utm_medium=usertext&utm_name=WireGuard&utm_content=t1_ep8tv0o\n- https://www.reddit.com/r/VPN/comments/au4owb/how_secure_is_wireguard_vpn_protocol/\n- https://www.reddit.com/r/WireGuard/comments/ap33df/wireguard_what_is_so_special_about_it_and_why/\n- https://www.reddit.com/r/VPN/comments/9hgs2x/what_is_the_difference_between_wireguard_openvpn/\n- https://www.reddit.com/r/WireGuard/comments/d3thxp/port_forwarding_on_the_router_with_wireguard_is/\n- https://www.reddit.com/r/privacytoolsIO/comments/8l0vxt/what_do_you_think_guys_of_wireguard/\n- https://community.ui.com/questions/Edgerouter-with-remote-Wireguard-access-issue/03e4f2e2-3871-437f-8632-3c5c7fb1c7a4\n- https://discuss.linuxcontainers.org/t/solved-wireguard-in-macvlan-container-on-ubuntu-18-04/4445\n- https://news.ycombinator.com/item?id=20036194\n- https://news.ycombinator.com/item?id=17659983\n- https://news.ycombinator.com/item?id=17846387\n\nFor more detailed instructions, see the [QuickStart](#QuickStart) guide and API reference above. You can also download the complete example setup here: https://github.com/pirate/wireguard-example.\n\n\n---\n\n<center>\n    \nSuggest changes: https://github.com/pirate/wireguard-docs/issues\n    \n</center>\n"
        },
        {
          "name": "example-full",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-internet-browsing-vpn",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-iptables",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-lan-briding",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-simple-client-to-server",
          "type": "tree",
          "content": null
        },
        {
          "name": "example-simple-server-to-server",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}