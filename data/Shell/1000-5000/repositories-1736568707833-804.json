{
  "metadata": {
    "timestamp": 1736568707833,
    "page": 804,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "KrumpetPirate/AAXtoMP3",
      "stars": 1218,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0478515625,
          "content": "ACTIVATION\n.authcode\n*aax\n*jpg\n*json\nAudiobook/*\n"
        },
        {
          "name": "AAXtoMP3",
          "type": "blob",
          "size": 41.74609375,
          "content": "#!/usr/bin/env bash\n\n\n# ========================================================================\n# Command Line Options\n\n# Usage Synopsis.\nusage=$'\\nUsage: AAXtoMP3 [--flac] [--aac] [--opus ] [--single] [--level <COMPRESSIONLEVEL>]\n[--chaptered] [-e:mp3] [-e:m4a] [-e:m4b] [--authcode <AUTHCODE>] [--no-clobber]\n[--target_dir <PATH>] [--complete_dir <PATH>] [--validate] [--loglevel <LOGLEVEL>]\n[--keep-author <N>] [--author <AUTHOR>] [--{dir,file,chapter}-naming-scheme <STRING>]  \n[--use-audible-cli-data] [--audible-cli-library-file <LIBRARY_PATH>] [--continue <CHAPTERNUMBER>] {FILES}\\n'\ncodec=libmp3lame            # Default encoder.\nextension=mp3               # Default encoder extension.\nlevel=-1                    # Compression level. Can be given for mp3, flac and opus. -1 = default/not specified.\nmode=chaptered              # Multi file output\nauth_code=                  # Required to be set via file or option.\ntargetdir=                  # Optional output location.  Note default is basedir of AAX file.\ndirNameScheme=              # Custom directory naming scheme, default is $genre/$artist/$title\ncustomDNS=0\nfileNameScheme=             # Custom file naming scheme, default is $title\ncustomFNS=0\nchapterNameScheme=          # Custom chapter naming scheme, default is '$title-$(printf %0${#chaptercount}d $chapternum) $chapter' (BookTitle-01 Chapter 1)\ncustomCNS=0\ncompletedir=                # Optional location to move aax files once the decoding is complete.\ncontainer=mp3               # Just in case we need to change the container.  Used for M4A to M4B\nVALIDATE=0                  # Validate the input aax file(s) only.  No Transcoding of files will occur\nloglevel=1                  # Loglevel: 0: Show progress only; 1: default; 2: a little more information, timestamps; 3: debug\nnoclobber=0                 # Default off, clobber only if flag is enabled\ncontinue=0                  # Default off, If set Transcoding is skipped and chapter splitting starts at chapter continueAt.\ncontinueAt=1                # Optional chapter to continue splitting the chapters.\nkeepArtist=-1               # Default off, if set change author metadata to use the passed argument as field\nauthorOverride=             # Override the author, ignoring the metadata           \naudibleCli=0                # Default off, Use additional data gathered from mkb79/audible-cli\naaxc_key=                   # Initialize variables, in case we need them in debug_vars\naaxc_iv=                    # Initialize variables, in case we need them in debug_vars\nffmpegPath=                 # Set a custom path, useful for using the updated version that supports aaxc\nffmpegName=ffmpeg           # Set a custom ffmpeg binary name, useful tailoring to local setup\nffprobeName=ffprobe         # Set a custom ffprobe binary name, useful tailoring to local setup\nlibrary_file=               # Libraryfile generated by mkb79/audible-cli\n\n# -----\n# Code tip Do not have any script above this point that calls a function or a binary.  If you do\n# the $1 will no longer be a ARGV element.  So you should only do basic variable setting above here.\n#\n# Process the command line options.  This allows for un-ordered options. Sorta like a getops style\nwhile true; do\n  case \"$1\" in\n                      # Flac encoding\n    -f | --flac       ) codec=flac; extension=flac; mode=single; container=flac;        shift ;;\n                      # Ogg Format\n    -o | --opus       ) codec=libopus; extension=opus; container=ogg;                   shift ;;\n                      # If appropriate use only a single file output.\n    -s | --single     ) mode=single;                                                    shift ;;\n                      # If appropriate use only a single file output.\n    -c | --chaptered  ) mode=chaptered;                                                 shift ;;\n                      # This is the same as --single option.\n    -e:mp3            ) codec=libmp3lame; extension=mp3; mode=single; container=mp3;    shift ;;\n                      # Identical to --acc option.\n    -e:m4a | -a | --aac ) codec=copy; extension=m4a; mode=single; container=mp4;          shift ;;\n                      # Similar to --aac but specific to audio books\n    -e:m4b            ) codec=copy; extension=m4b; mode=single; container=mp4;          shift ;;\n                      # Change the working dir from AAX directory to what you choose.\n    -t | --target_dir ) targetdir=\"$2\";                                                 shift 2 ;;\n                      # Use a custom directory naming scheme, with variables.\n    -D | --dir-naming-scheme ) dirNameScheme=\"$2\"; customDNS=1;                         shift 2 ;;\n                      # Use a custom file naming scheme, with variables.\n    -F | --file-naming-scheme ) fileNameScheme=\"$2\"; customFNS=1;                       shift 2 ;;\n                       # Use a custom chapter naming scheme, with variables.\n    --chapter-naming-scheme ) chapterNameScheme=\"$2\"; customCNS=1;                      shift 2 ;;\n                      # Move the AAX file to a new directory when decoding is complete.\n    -C | --complete_dir ) completedir=\"$2\";                                             shift 2 ;;\n                      # Authorization code associate with the AAX file(s)\n    -A | --authcode   ) auth_code=\"$2\";                                                 shift 2 ;;\n                      # Don't overwrite the target directory if it already exists\n    -n | --no-clobber ) noclobber=1;                                                    shift ;;\n                      # Extremely verbose output.\n    -d | --debug      ) loglevel=3;                                                     shift ;;\n                      # Set loglevel.\n    -l | --loglevel   ) loglevel=\"$2\";                                                  shift 2 ;;\n                      # Validate ONLY the aax file(s) No transcoding occurs\n    -V | --validate   ) VALIDATE=1;                                                     shift ;;\n                      # continue splitting chapters at chapter continueAt\n    --continue        ) continueAt=\"$2\"; continue=1;                                    shift 2 ;;\n                      # Use additional data got with mkb79/audible-cli\n    --use-audible-cli-data ) audibleCli=1;                                              shift ;;\n                      # Path of the library-file, generated by mkb79/audible-cli (audible library export -o ./library.tsv)\n    -L | --audible-cli-library-file ) library_file=\"$2\";                                shift 2 ;;\n                      # Compression level\n    --level           ) level=\"$2\";                                                     shift 2 ;;\n                      # Keep author number n\n    --keep-author     ) keepArtist=\"$2\";                                                shift 2 ;;\n                      # Author override\n    --author          ) authorOverride=\"$2\";                                            shift 2 ;;\n                      # Ffmpeg path override\n    --ffmpeg-path     ) ffmpegPath=\"$2\";                                                shift 2 ;;\n                      # Ffmpeg name override\n    --ffmpeg-name     ) ffmpegName=\"$2\";                                                shift 2 ;;\n                      # Ffprobe name override\n    --ffprobe-name    ) ffprobeName=\"$2\";                                                shift 2 ;;\n                      # Command synopsis.\n    -h | --help       ) printf \"$usage\" $0 ;                                            exit ;;\n                      # Standard flag signifying the end of command line processing.\n    --                )                                                                 shift; break ;;\n                      # Anything else stops command line processing.\n    *                 )                                                                 break ;;\n\n  esac\ndone\n\n# -----\n# Empty argv means we have nothing to do so lets bark some help.\nif [ \"$#\" -eq 0 ]; then\n  printf \"$usage\" $0\n  exit 1\nfi\n\n# Setup safer bash script defaults.\nset -o errexit -o noclobber -o nounset -o pipefail\n\n# ========================================================================\n# Utility Functions\n\n# -----\n# debug\n# debug \"Some longish message\"\ndebug() {\n  if [ $loglevel == 3 ] ; then\n    echo \"$(date \"+%F %T%z\") DEBUG ${1}\"\n  fi\n}\n\n# -----\n# debug dump contents of a file to STDOUT\n# debug \"<full path to file>\"\ndebug_file() {\n  if [ $loglevel == 3 ] ; then\n    echo \"$(date \"+%F %T%z\") DEBUG\"\n    echo \"=Start==========================================================================\"\n    cat \"${1}\"\n    echo \"=End============================================================================\"\n  fi\n}\n\n# -----\n# debug dump a list of internal script variables to STDOUT\n# debug_vars \"Some Message\" var1 var2 var3 var4 var5\ndebug_vars() {\n  if [ $loglevel == 3 ] ; then\n    msg=\"$1\"; shift ; # Grab the message\n    args=(\"$@\")       # Grab the rest of the args\n\n    # determine the length of the longest key\n    l=0\n    for (( n=0; n<${#args[@]}; n++ )) ; do\n      (( \"${#args[$n]}\" > \"$l\" )) && l=${#args[$n]}\n    done\n\n    # Print the Debug Message\n    echo \"$(date \"+%F %T%z\") DEBUG ${msg}\"\n    echo \"=Start==========================================================================\"\n\n    # Using the max length of a var name we dynamically create the format.\n    fmt=\"%-\"${l}\"s = %s\\n\"\n\n    for (( n=0; n<${#args[@]}; n++ )) ; do\n      eval val=\"\\$${args[$n]}\"              ; # We save off the value of the var in question for ease of coding.\n\n      echo \"$(printf \"${fmt}\" ${args[$n]} \"${val}\" )\"\n    done\n    echo \"=End============================================================================\"\n  fi\n}\n\n# -----\n# log\nlog() {\n  if [ \"$((${loglevel} > 1))\" == \"1\" ] ; then\n    echo \"$(date \"+%F %T%z\") ${1}\"\n  else\n    echo \"${1}\"\n  fi\n}\n\n# -----\n#progressbar produces a progressbar in the style of\n# process: |#######             |  XX% (part/total unit)\n# which is gonna be overwritten by the next line.\n\nprogressbar() {\n  #get input\n  part=${1}\n  total=${2}\n\n  #compute percentage and make print_percentage the same length regardless of the number of digits.\n  percentage=$((part*100/total))\n  if [ \"$((percentage<10))\" = \"1\" ]; then print_percentage=\"  $percentage\"\n  elif [ \"$((percentage<100))\" = \"1\" ]; then print_percentage=\" $percentage\"\n  else print_percentage=\"$percentage\"; fi\n\n  #draw progressbar with one # for every 5% and blank spaces for the missing part.\n  progressbar=\"\"\n  for (( n=0; n<(percentage/5); n++ )) ; do progressbar=\"$progressbar#\"; done\n  for (( n=0; n<(20-(percentage/5)); n++ )) ; do progressbar=\"$progressbar \"; done\n\n  #print progressbar\n  echo -ne \"Chapter splitting: |$progressbar| $print_percentage% ($part/$total chapters)\\r\"\n}\n# Print out what we have already after command line processing.\ndebug_vars \"Command line options as set\" codec extension mode container targetdir completedir auth_code keepArtist authorOverride audibleCli\n\n# ========================================================================\n# Variable validation\n\nif [ $(uname) = 'Linux' ]; then\n    GREP=\"grep\"\n    FIND=\"find\"\n    SED=\"sed\"\nelse\n    GREP=\"ggrep\"\n    FIND=\"gfind\"\n    SED=\"gsed\"\nfi\n\n# Use custom ffmpeg (and ffprobe) binary ( --ffmpeg-path flag)\nif [ -n \"$ffmpegPath\" ]; then\n  FFMPEG=\"$ffmpegPath/${ffmpegName}\"\n  FFPROBE=\"$ffmpegPath/${ffprobeName}\"\nelse\n  FFMPEG=\"${ffmpegName}\"\n  FFPROBE=\"${ffprobeName}\"\nfi\n\ndebug_vars \"ffmpeg/ffprobe paths\" FFMPEG FFPROBE\n\n# -----\n# Detect which annoying version of grep we have\nif ! [[ $(type -P \"$GREP\") ]]; then\n  echo \"$GREP (GNU grep) is not in your PATH\"\n  echo \"Without it, this script will break.\"\n  echo \"On macOS, you may want to try: brew install grep\"\n  exit 1\nfi\n\n# -----\n# Detect which annoying version of find we have\nif ! [[ $(type -P \"$FIND\") ]]; then\n  echo \"$FIND (GNU find) is not in your PATH\"\n  echo \"Without it, this script will break.\"\n  echo \"On macOS, you may want to try: brew install findutils\"\n  exit 1\nfi\n\n# -----\n# Detect which annoying version of sed we have\nif ! [[ $(type -P \"$SED\") ]]; then\n  echo \"$SED (GNU sed) is not in your PATH\"\n  echo \"Without it, this script will break.\"\n  echo \"On macOS, you may want to try: brew install gnu-sed\"\n  exit 1\nfi\n\n# -----\n# Detect ffmpeg and ffprobe\nif [[ \"x$(type -P \"$FFMPEG\")\" == \"x\" ]]; then\n  echo \"ERROR ffmpeg was not found on your env PATH variable\"\n  echo \"Without it, this script will break.\"\n  echo \"INSTALL:\"\n  echo \"MacOS:           brew install ffmpeg\"\n  echo \"Ubuntu:          sudo apt-get update; sudo apt-get install ffmpeg libav-tools x264 x265 bc\"\n  echo \"Ubuntu (20.04):  sudo apt-get update; sudo apt-get install ffmpeg x264 x265 bc\"\n  echo \"RHEL:            yum install ffmpeg\"\n  exit 1\nfi\n\n# -----\n# Detect ffmpeg and ffprobe\nif [[ \"x$(type -P \"$FFPROBE\")\" == \"x\" ]]; then\n  echo \"ERROR ffprobe was not found on your env PATH variable\"\n  echo \"Without it, this script will break.\"\n  echo \"INSTALL:\"\n  echo \"MacOS:   brew install ffmpeg\"\n  echo \"Ubuntu:  sudo apt-get update; sudo apt-get install ffmpeg libav-tools x264 x265 bc\"\n  echo \"RHEL:    yum install ffmpeg\"\n  exit 1\nfi\n\n\n# -----\n# Detect if we need mp4art for cover additions to m4a & m4b files.\nif [[ \"x${container}\" == \"xmp4\" && \"x$(type -P mp4art)\" == \"x\" ]]; then\n  echo \"WARN mp4art was not found on your env PATH variable\"\n  echo \"Without it, this script will not be able to add cover art to\"\n  echo \"m4b files. Note if there are no other errors the AAXtoMP3 will\"\n  echo \"continue. However no cover art will be added to the output.\"\n  echo \"INSTALL:\"\n  echo \"MacOS:   brew install mp4v2\"\n  echo \"Ubuntu:  sudo apt-get install mp4v2-utils\"\nfi\n\n# -----\n# Detect if we need mp4chaps for adding chapters to m4a & m4b files.\nif [[ \"x${container}\" == \"xmp4\" && \"x$(type -P mp4chaps)\" == \"x\" ]]; then\n  echo \"WARN mp4chaps was not found on your env PATH variable\"\n  echo \"Without it, this script will not be able to add chapters to\"\n  echo \"m4a/b files. Note if there are no other errors the AAXtoMP3 will\"\n  echo \"continue. However no chapter data will be added to the output.\"\n  echo \"INSTALL:\"\n  echo \"MacOS:   brew install mp4v2\"\n  echo \"Ubuntu:  sudo apt-get install mp4v2-utils\"\nfi\n\n# -----\n# Detect if we need mediainfo for adding description and narrator\nif [[ \"x$(type -P mediainfo)\" == \"x\" ]]; then\n  echo \"WARN mediainfo was not found on your env PATH variable\"\n  echo \"Without it, this script will not be able to add the narrator\"\n  echo \"and description tags. Note if there are no other errors the AAXtoMP3\"\n  echo \"will continue. However no such tags will be added to the output.\"\n  echo \"INSTALL:\"\n  echo \"MacOS:   brew install mediainfo\"\n  echo \"Ubuntu:  sudo apt-get install mediainfo\"\nfi\n\n# -----\n# Obtain the authcode from either the command line,  local directory or home directory.\n# See Readme.md for details on how to acquire your personal authcode for your personal\n# audible AAX files.\nif [ -z $auth_code ]; then\n  if [ -r .authcode ]; then\n    auth_code=`head -1 .authcode`\n  elif [ -r ~/.authcode ]; then\n    auth_code=`head -1 ~/.authcode`\n  fi\nfi\n\n# -----\n# Check the target dir for if set if it is writable\nif [[ \"x${targetdir}\" != \"x\"  ]]; then\n  if [[ ! -w \"${targetdir}\" || ! -d \"${targetdir}\" ]] ; then\n    echo \"ERROR Target Directory does not exist or is not writable: \\\"$targetdir\\\"\"\n    echo \"$usage\"\n    exit 1\n  fi\nfi\n\n# -----\n# Check the completed dir for if set if it is writable\nif [[ \"x${completedir}\" != \"x\"  ]]; then\n  if [[ ! -w \"${completedir}\" || ! -d \"${completedir}\" ]] ; then\n    echo \"ERROR Complete Directory does not exist or is not writable: \\\"$completedir\\\"\"\n    echo \"$usage\"\n    exit 1\n  fi\nfi\n\n# -----\n# Check whether the loglevel is valid\nif [ \"$((${loglevel} < 0 || ${loglevel} > 3 ))\" = \"1\" ]; then\n  echo \"ERROR loglevel has to be in the range from 0 to 3!\"\n  echo \"      0: Show progress only\"\n  echo \"      1: default\"\n  echo \"      2: a little more information, timestamps\"\n  echo \"      3: debug\"\n  echo \"$usage\"\n  exit 1\nfi\n# -----\n# If a compression level is given, check whether the given codec supports compression level specifiers and whether the level is valid.\nif [ \"${level}\" != \"-1\" ]; then\n  if [ \"${codec}\" == \"flac\" ]; then\n    if [ \"$((${level} < 0 || ${level} > 12 ))\" = \"1\" ]; then\n      echo \"ERROR Flac compression level has to be in the range from 0 to 12!\"\n      echo \"$usage\"\n      exit 1\n    fi\n  elif [ \"${codec}\" == \"libopus\" ]; then\n    if [ \"$((${level} < 0 || ${level} > 10 ))\" = \"1\" ]; then\n      echo \"ERROR Opus compression level has to be in the range from 0 to 10!\"\n      echo \"$usage\"\n      exit 1\n    fi\n  elif [ \"${codec}\" == \"libmp3lame\" ]; then\n    if [ \"$((${level} < 0 || ${level} > 9 ))\" = \"1\" ]; then\n      echo \"ERROR MP3 compression level has to be in the range from 0 to 9!\"\n      echo \"$usage\"\n      exit 1\n    fi\n  else\n    echo \"ERROR This codec doesnt support compression levels!\"\n    echo \"$usage\"\n    exit 1\n  fi\nfi\n\n# -----\n# Clean up if someone hits ^c or the script exits for any reason.\ntrap 'rm -r -f \"${working_directory}\"' EXIT\n\n# -----\n# Set up some basic working files ASAP.  Note the trap will clean this up no matter what.\nworking_directory=`mktemp -d 2>/dev/null || mktemp -d -t 'mytmpdir'`\nmetadata_file=\"${working_directory}/metadata.txt\"\n\n# -----\n# Validate the AAX and extract the metadata associated with the file.\nvalidate_aax() {\n  local media_file\n  media_file=\"$1\"\n\n  # Test for existence\n  if [[ ! -r \"${media_file}\" ]] ; then\n    log \"ERROR File NOT Found: ${media_file}\"\n    return 1\n  else\n    if [[ \"${VALIDATE}\" == \"1\" ]]; then\n      log \"Test 1 SUCCESS: ${media_file}\"\n    fi\n  fi\n\n  # Clear the errexit value we want to capture the output of the ffprobe below.\n  set +e errexit\n\n  # Take a look at the aax file and see if it is valid. If the source file is aaxc, we give ffprobe additional flags\n  output=\"$(\"$FFPROBE\" -loglevel warning ${decrypt_param} -i \"${media_file}\" 2>&1)\"\n\n  # If invalid then say something.\n  if [[ $? != \"0\" ]] ; then\n    # No matter what lets bark that something is wrong.\n    log \"ERROR: Invalid File: ${media_file}\"\n  elif [[ \"${VALIDATE}\" == \"1\" ]]; then\n    # If the validate option is present then lets at least state what is valid.\n    log \"Test 2 SUCCESS: ${media_file}\"\n  fi\n\n  # This is a big test only performed when the --validate switch is passed.\n  if [[ \"${VALIDATE}\" == \"1\" ]]; then\n    output=\"$(\"$FFMPEG\" -hide_banner ${decrypt_param} -i \"${media_file}\" -vn -f null - 2>&1)\"\n    if [[ $? != \"0\" ]] ; then\n      log \"ERROR: Invalid File: ${media_file}\"\n    else\n      log \"Test 3 SUCCESS: ${media_file}\"\n    fi\n  fi\n\n  # Dump the output of the ffprobe command.\n  debug \"$output\"\n\n  # Turn it back on.  ffprobe is done.\n  set -e errexit\n}\n\nvalidate_extra_files() {\n  local extra_media_file extra_find_command\n  extra_media_file=\"$1\"\n  # Bash trick to delete, non greedy, from the end up until the first '-'\n  extra_title=\"${extra_media_file%-*}\"\n\n  # Using this is not ideal, because if the naming scheme is changed then\n  # this part of the script will break\n  # AAX file: BookTitle-LC_128_44100_stereo.aax\n  # Cover file: BookTitle_(1215).jpg\n  # Chapter file: BookTitle-chapters.json\n\n  # Chapter\n  extra_chapter_file=\"${extra_title}-chapters.json\"\n\n  # Cover\n  extra_dirname=\"$(dirname \"${extra_media_file}\")\"\n  extra_find_command='$FIND \"${extra_dirname}\" -maxdepth 1 -regex \".*/${extra_title##*/}_([0-9]+)\\.jpg\"'\n  # We want the output of the find command, we will turn errexit on later\n  set +e errexit\n  extra_cover_file=\"$(eval ${extra_find_command})\"\n  extra_eval_comm=\"$(eval echo ${extra_find_command})\"\n  set -e errexit\n\n  if [[ \"${aaxc}\" == \"1\" ]]; then\n    # bash trick to get file w\\o extention (delete from end to the first '.')\n    extra_voucher=\"${extra_media_file%.*}.voucher\"\n    if [[ ! -r \"${extra_voucher}\" ]] ; then\n      log \"ERROR File NOT Found: ${extra_voucher}\"\n      return 1\n    fi\n    aaxc_key=$(jq -r '.content_license.license_response.key' \"${extra_voucher}\")\n    aaxc_iv=$(jq -r '.content_license.license_response.iv' \"${extra_voucher}\")\n  fi\n\n  debug_vars \"Audible-cli variables\" extra_media_file extra_title extra_chapter_file extra_cover_file extra_find_command extra_eval_comm extra_dirname extra_voucher aaxc_key aaxc_iv\n\n  # Test for chapter file existence\n  if [[ ! -r \"${extra_chapter_file}\" ]] ; then\n    log \"ERROR File NOT Found: ${extra_chapter_file}\"\n    return 1\n  fi\n  if [[ \"x${extra_cover_file}\" == \"x\" ]] ; then\n    log \"ERROR Cover File NOT Found\"\n    return 1\n  fi\n\n  # Test for library file\n  if [[ ! -r \"${library_file}\" ]] ; then\n    library_file_exists=0\n    debug \"library file not found\"\n  else\n    library_file_exists=1\n    debug \"library file found\"\n  fi\n\n  debug \"All expected audible-cli related file are here\"\n}\n\n# -----\n# Inspect the AAX and extract the metadata associated with the file.\nsave_metadata() {\n  local media_file\n  media_file=\"$1\"\n  \"$FFPROBE\" -i \"$media_file\" 2> \"$metadata_file\"\n  if [[ $(type -P mediainfo) ]]; then\n    echo \"Mediainfo data START\" >> \"$metadata_file\"\n    # Mediainfo output is structured like ffprobe, so we append it to the metadata file and then parse it with get_metadata_value()\n    # mediainfo \"$media_file\" >> \"$metadata_file\"\n    # Or we only get the data we are intrested in:\n    # Description\n    echo \"Track_More :\" \"$(mediainfo --Inform=\"General;%Track_More%\" \"$media_file\")\" >> \"$metadata_file\"\n    # Narrator\n    echo \"nrt :\" \"$(mediainfo --Inform=\"General;%nrt%\" \"$media_file\")\" >> \"$metadata_file\"\n    # Publisher\n    echo \"pub :\" \"$(mediainfo --Inform=\"General;%pub%\" \"$media_file\")\" >> \"$metadata_file\"\n    echo \"Mediainfo data END\" >> \"$metadata_file\"\n  fi\n  if [[ \"${audibleCli}\" == \"1\" ]]; then\n    # If we use data we got with audible-cli, we delete conflicting chapter infos\n    $SED -i '/^    Chapter #/d' \"${metadata_file}\"\n    # Some magic: we parse the .json generated by audible-cli.\n    # to get the output structure like the one generated by ffprobe, \n    # we use some characters (#) as placeholder, add some new lines,\n    # put a ',' after the start value, we calculate the end of each chapter\n    # as start+length, and we convert (divide) the time stamps from ms to s.\n    # Then we delete all ':' and '/' since they make a filename invalid.\n    jq -r '.content_metadata.chapter_info.chapters[] | \"Chapter # start: \\(.start_offset_ms/1000), end: \\((.start_offset_ms+.length_ms)/1000) \\n#\\n# Title: \\(.title)\"' \"${extra_chapter_file}\" \\\n      | $SED 's@[:/]@@g' >> \"$metadata_file\"\n    # In case we want to use a single file m4b we need to extract the\n    # chapter titles from the .json generated by audible–cli and store\n    # them correctly formatted for mp4chaps in a chapter.txt\n    if [ \"${mode}\" == \"single\" ]; then\n      # Creating a temp file to store the chapter data collected in save_metadata, as the output\n      # folder will only be defined after save_metadata has been executed.\n      # This file is only required when using audible-cli data and executing in single mode to\n      # get proper chapter titles in single file m4b output.\n      tmp_chapter_file=\"${working_directory}/chapter.txt\"\n      jq -r \\\n        'def pad(n): tostring | if (n > length) then ((n - length) * \"0\") + . else . end;\n        .content_metadata.chapter_info.chapters |\n        reduce .[] as $c ([]; if $c.chapters? then .+[$c | del(.chapters)]+[$c.chapters] else .+[$c] end) | flatten |\n        to_entries |\n        .[] |\n        \"CHAPTER\\((.key))=\\((((((.value.start_offset_ms / (1000*60*60)) /24 | floor)  *24 ) + ((.value.start_offset_ms / (1000*60*60)) %24 | floor)) | pad(2))):\\(((.value.start_offset_ms / (1000*60)) %60 | floor | pad(2))):\\(((.value.start_offset_ms / 1000) %60 | floor | pad(2))).\\((.value.start_offset_ms % 1000 | pad(3)))\nCHAPTER\\((.key))NAME=\\(.value.title)\"' \"${extra_chapter_file}\" > \"${tmp_chapter_file}\"\n    fi\n\n    # get extra meta data from library.tsv\n    if [[ \"${library_file_exists}\" == 1 ]]; then\n      asin=$(jq -r '.content_metadata.content_reference.asin' \"${extra_chapter_file}\")\n      if [[ ! -z \"${asin}\" ]]; then\n        lib_entry=$($GREP \"^${asin}\" \"${library_file}\")\n        if [[ ! -z \"${lib_entry}\" ]]; then\n          series_title=$(echo \"${lib_entry}\" | awk -F '\\t' '{print $6}')\n          series_sequence=$(echo \"${lib_entry}\" | awk -F '\\t' '{print $7}')\n          $SED -i \"/^  Metadata:/a\\\\\n    series          : ${series_title}\\\\\n    series_sequence : ${series_sequence}\" \"${metadata_file}\"\n        fi\n      fi\n    fi\n  fi\n  debug \"Metadata file $metadata_file\"\n  debug_file \"$metadata_file\"\n}\n\n# -----\n# Reach into the meta data and extract a specific value.\n#   This is a long pipe of transforms.\n#   This finds the first occurrence of the key : value pair.\nget_metadata_value() {\n  local key\n  key=\"$1\"\n        # Find the key in the meta data file                                  # Extract field value     # Remove the following /'s  \"(Unabridged)  <blanks> at start end and multiples.\n  echo \"$($GREP --max-count=1 --only-matching \"${key} *: .*\" \"$metadata_file\" | cut -d : -f 2- | $SED -e 's#/##g;s/ (Unabridged)//;s/^[[:blank:]]\\+//g;s/[[:blank:]]\\+$//g' | $SED 's/[[:blank:]]\\+/ /g')\"\n}\n\n# -----\n# specific variant of get_metadata_value bitrate is important for transcoding.\nget_bitrate() {\n  get_metadata_value bitrate | $GREP --only-matching '[0-9]\\+'\n}\n\n# Save the original value, since in the for loop we overwrite\n# $audibleCli in case the file is aaxc. If the file is the\n# old aax, reset the variable to be the one passed by the user\noriginalAudibleCliVar=$audibleCli\n# ========================================================================\n# Main Transcode Loop\nfor aax_file\ndo\n  # If the file is in aaxc format, set the proper variables\n  if [[ ${aax_file##*.} == \"aaxc\" ]]; then\n    # File is the new .aaxc\n    aaxc=1\n    audibleCli=1\n  else\n    # File is the old .aax\n    aaxc=0\n    # If some previous file in the loop are aaxc, the $audibleCli variable has been overwritten, so we reset it to the original one\n    audibleCli=$originalAudibleCliVar\n  fi\n\n  debug_vars \"Variables set based on file extention\" aaxc originalAudibleCliVar audibleCli\n\n  # No point going on if no authcode found and the file is aax.\n  # If we use aaxc as input, we do not need it\n  # if the string $auth_code is null and the format is not aaxc; quit. We need the authcode\n  if [ -z $auth_code ] && [ \"${aaxc}\" = \"0\" ]; then\n    echo \"ERROR Missing authcode, can't decode $aax_file\"\n    echo \"$usage\"\n    exit 1\n  fi\n\n  # Validate the input aax file.  Note this happens no matter what.\n  # It's just that if the validate option is set then we skip to next file.\n  # If however validate is not set and we proceed with the script any errors will\n  # case the script to stop.\n\n  # If the input file is aaxc, we need to first get the audible_key and audible_iv\n  # We get them in the function validate_extra_files\n\n  if [[ ${audibleCli} == \"1\" ]] ; then\n    # If we have additional files (obtained via audible-cli), be sure that they\n    # exists and they are in the correct location.\n    validate_extra_files \"${aax_file}\"\n  fi\n\n  # Set the needed params to decrypt the file. Needed in all command that require ffprobe or ffmpeg\n  # After validate_extra_files, since the -audible_key and -audible_iv are read in that function\n  if [[ ${aaxc} == \"1\" ]] ; then\n    decrypt_param=\"-audible_key ${aaxc_key} -audible_iv ${aaxc_iv}\"\n  else\n    decrypt_param=\"-activation_bytes ${auth_code}\"\n  fi\n\n  validate_aax \"${aax_file}\"\n  if [[ ${VALIDATE} == \"1\" ]] ; then\n    # Don't bother doing anything else with this file.\n    continue\n  fi\n\n  # -----\n  # Make sure everything is a variable.  Simplifying Command interpretation\n  save_metadata \"${aax_file}\"\n  genre=$(get_metadata_value genre)\n  if [ \"x${authorOverride}\" != \"x\" ]; then\n    #Manual Override\n    artist=\"${authorOverride}\"\n    album_artist=\"${authorOverride}\"\n  else\n    if [ \"${keepArtist}\" != \"-1\" ]; then\n      # Choose artist from the one that are present in the metadata. Comma separated list of names\n      #                                                                 remove leading space;     'C. S. Lewis' -> 'C.S. Lewis'\n      artist=\"$(get_metadata_value artist | cut -d',' -f\"$keepArtist\" | $SED -E 's|^ ||g; s|\\. +|\\.|g; s|((\\w+\\.)+)|\\1 |g')\"\n      album_artist=\"$(get_metadata_value album_artist | cut -d',' -f\"$keepArtist\" | $SED -E 's|^ ||g; s|\\. +|\\.|g; s|((\\w+\\.)+)|\\1 |g')\"\n    else\n      # The default\n      artist=$(get_metadata_value artist)\n      album_artist=\"$(get_metadata_value album_artist)\"\n    fi\n  fi\n  title=$(get_metadata_value title)\n  title=${title:0:128}\n  bitrate=\"$(get_bitrate)k\"\n  album=\"$(get_metadata_value album)\"\n  album_date=\"$(get_metadata_value date)\"\n  copyright=\"$(get_metadata_value copyright)\"\n  series=\"$(get_metadata_value series)\"\n  series_sequence=\"$(get_metadata_value series_sequence)\"\n\n  # Get more tags with mediainfo\n  if [[ $(type -P mediainfo) ]]; then\n    narrator=\"$(get_metadata_value nrt)\"\n    description=\"$(get_metadata_value Track_More)\"\n    publisher=\"$(get_metadata_value pub)\"\n  else\n    narrator=\"\"\n    description=\"\"\n    publisher=\"\"\n  fi\n\n  # Define the output_directory\n  if [ \"${customDNS}\" == \"1\" ]; then\n    currentDirNameScheme=\"$(eval echo \"${dirNameScheme}\")\"\n  else\n    # The Default\n    currentDirNameScheme=\"${genre}/${artist}/${title}\"\n  fi\n\n  # If we defined a target directory, use it. Otherwise use the location of the AAX file\n  if [ \"x${targetdir}\" != \"x\" ] ; then\n    output_directory=\"${targetdir}/${currentDirNameScheme}\"\n  else\n    output_directory=\"$(dirname \"${aax_file}\")/${currentDirNameScheme}\"\n  fi\n\n  # Define the output_file\n  if [ \"${customFNS}\" == \"1\" ]; then\n    currentFileNameScheme=\"$(eval echo \"${fileNameScheme}\")\"\n  else\n    # The Default\n    currentFileNameScheme=\"${title}\"\n  fi\n  output_file=\"${output_directory}/${currentFileNameScheme}.${extension}\"\n\n  if [[ \"${noclobber}\" = \"1\" ]] && [[ -d \"${output_directory}\" ]]; then\n    log \"Noclobber enabled but directory '${output_directory}' exists. Skipping to avoid overwriting\"\n    rm -f \"${metadata_file}\" \"${tmp_chapter_file}\"\n    continue\n  fi\n  mkdir -p \"${output_directory}\"\n\n  if [ \"$((${loglevel} > 0))\" = \"1\" ]; then\n    # Fancy declaration of which book we are decoding.  Including the AUTHCODE.\n    dashline=\"----------------------------------------------------\"\n    log \"$(printf '\\n----Decoding---%s%s--%s--' \"${title}\" \"${dashline:${#title}}\" \"${auth_code}\")\"\n    log \"Source: ${aax_file}\"\n  fi\n\n  # Big long DEBUG output. Fully describes the settings used for transcoding.\n  # Note this is a long debug command. It's not critical to operation. It's purely for people debugging\n  # and coders wanting to extend the script.\n  debug_vars \"Book and Variable values\" title auth_code aaxc aaxc_key aaxc_iv mode aax_file container codec bitrate artist album_artist album album_date genre copyright narrator description publisher currentDirNameScheme output_directory currentFileNameScheme output_file metadata_file working_directory\n\n\n  # Display the total length of the audiobook in format hh:mm:ss\n  # 10#$var force base-10 interpretation. By default it's base-8, so values like 08 or 09 are not octal numbers\n  total_length=\"$(\"$FFPROBE\" -v error ${decrypt_param} -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"${aax_file}\" | cut -d . -f 1)\"\n  hours=\"$((total_length/3600))\"\n  if [ \"$((hours<10))\" = \"1\" ]; then hours=\"0$hours\"; fi\n  minutes=\"$((total_length/60-60*10#$hours))\"\n  if [ \"$((minutes<10))\" = \"1\" ]; then minutes=\"0$minutes\"; fi\n  seconds=\"$((total_length-3600*10#$hours-60*10#$minutes))\"\n  if [ \"$((seconds<10))\" = \"1\" ]; then seconds=\"0$seconds\"; fi\n  log \"Total length: $hours:$minutes:$seconds\"\n  \n  # If level != -1 specify a compression level in ffmpeg.\n  compression_level_param=\"\"\n  if [ \"${level}\" != \"-1\" ]; then\n    compression_level_param=\"-compression_level ${level}\"\n  fi\n  \n  # -----\n  if [ \"${continue}\" == \"0\" ]; then\n    # This is the main work horse command.  This is the primary transcoder.\n    # This is the primary transcode. All the heavy lifting is here.\n    debug '\"$FFMPEG\" -loglevel error -stats ${decrypt_param} -i \"${aax_file}\" -vn -codec:a \"${codec}\" -ab ${bitrate} -map_metadata -1 -metadata title=\"${title}\" -metadata artist=\"${artist}\" -metadata album_artist=\"${album_artist}\" -metadata album=\"${album}\" -metadata date=\"${album_date}\" -metadata track=\"1/1\" -metadata genre=\"${genre}\" -metadata copyright=\"${copyright}\" \"${output_file}\"'\n    </dev/null \"$FFMPEG\" -loglevel error \\\n      -stats \\\n      ${decrypt_param} \\\n      -i \"${aax_file}\" \\\n      -vn \\\n      -codec:a \"${codec}\" \\\n      ${compression_level_param} \\\n      -ab ${bitrate} \\\n      -map_metadata -1 \\\n      -metadata title=\"${title}\" \\\n      -metadata artist=\"${artist}\" \\\n      -metadata album_artist=\"${album_artist}\" \\\n      -metadata album=\"${album}\" \\\n      -metadata date=\"${album_date}\" \\\n      -metadata track=\"1/1\" \\\n      -metadata genre=\"${genre}\" \\\n      -metadata copyright=\"${copyright}\" \\\n      -metadata description=\"${description}\" \\\n      -metadata composer=\"${narrator}\" \\\n      -metadata publisher=\"${publisher}\" \\\n      -metadata series=\"${series}\" \\\n      -metadata series_sequence=\"${series_sequence}\" \\\n      -f ${container} \\\n      \"${output_file}\"\n    if [ \"$((${loglevel} > 0))\" == \"1\" ]; then\n      log \"Created ${output_file}.\"\n    fi\n    # -----\n  fi\n  # Grab the cover art if available.\n  cover_file=\"${output_directory}/${currentFileNameScheme}.jpg\"\n  if [ \"${continue}\" == \"0\" ]; then\n    if [ \"${audibleCli}\" == \"1\" ]; then\n      # We have a better quality cover file, copy it.\n      if [ \"$((${loglevel} > 1))\" == \"1\" ]; then\n        log \"Copy cover file to ${cover_file}...\"\n      fi\n      cp \"${extra_cover_file}\" \"${cover_file}\"\n    else\n      # Audible-cli not used, extract the cover from the aax file\n      if [ \"$((${loglevel} > 1))\" == \"1\" ]; then\n        log \"Extracting cover into ${cover_file}...\"\n      fi\n      </dev/null \"$FFMPEG\" -loglevel error -activation_bytes \"${auth_code}\" -i \"${aax_file}\" -an -codec:v copy \"${cover_file}\"\n    fi\n  fi\n\n  extra_crop_cover=''\n  cover_width=$(ffprobe -i \"${cover_file}\" 2>&1 | $GREP -Po \"[0-9]+(?=x[0-9]+)\" | tail -n 1)\n  if (( ${cover_width} % 2 == 1 )); then\n    if [ \"$((${loglevel} > 1))\" == \"1\" ]; then\n      log \"Cover ${cover_file} has odd width ${cover_width}, setting extra_crop_cover to make even.\"\n    fi\n    # We now set a variable, ${extra_crop_cover}, which contains an additional\n    # ffmpeg flag. It crops the cover so the width and the height is divisible by two.\n    # Set the flag only if we use a cover art with an odd width.\n    extra_crop_cover='-vf crop=trunc(iw/2)*2:trunc(ih/2)*2'\n  fi\n\n  # -----\n  # If mode=chaptered, split the big converted file by chapter and remove it afterwards.\n  # Not all audio encodings make sense with multiple chapter outputs (see options section)\n  if [ \"${mode}\" == \"chaptered\" ]; then\n    # Playlist m3u support\n    playlist_file=\"${output_directory}/${currentFileNameScheme}.m3u\"\n    if [ \"${continue}\" == \"0\" ]; then\n      if [ \"$((${loglevel} > 0))\" == \"1\" ]; then\n        log \"Creating PlayList ${currentFileNameScheme}.m3u\"\n      fi\n      echo '#EXTM3U' > \"${playlist_file}\"\n    fi\n\n    # Determine the number of chapters.\n    chaptercount=$($GREP -Pc \"Chapter.*start.*end\" $metadata_file)\n    if [ \"$((${loglevel} > 0))\" == \"1\" ]; then\n      log \"Extracting ${chaptercount} chapter files from ${output_file}...\"\n      if [ \"${continue}\" == \"1\" ]; then\n        log \"Continuing at chapter ${continueAt}:\"\n      fi\n    fi\n    chapternum=1\n    #start progressbar for loglevel 0 and 1\n    if [ \"$((${loglevel} < 2))\" == \"1\" ]; then\n      progressbar 0 ${chaptercount}\n    fi\n    # We pipe the metadata_file in read.\n    # Example of the section that we are interested in:\n    #\n    # Chapter #0:0: start 0.000000, end 1928.231474\n    # Metadata:\n    # title           : Chapter 1\n    #\n    # Then read the line in these variables:\n    # first            Chapter\n    # _                #0:0:\n    # _                start\n    # chapter_start    0.000000,\n    # _                end\n    # chapter_end      1928.231474\n    while read -r -u9 first _ _ chapter_start _ chapter_end\n    do\n      # Do things only if the line starts with 'Chapter'\n      if [[ \"${first}\" = \"Chapter\" ]]; then\n        # The next line (Metadata:...) gets discarded\n        read -r -u9 _\n        # From the line 'title  :  Chapter 1' we save the third field and those after in chapter\n        read -r -u9 _ _ chapter\n\n        # The formatting of the chapters names and the file names.\n        # Chapter names are used in a few place.\n        # Define the chapter_file\n        if [ \"${customCNS}\" == \"1\" ]; then\n          chapter_title=\"$(eval echo \"${chapterNameScheme}\")\"\n        else\n          # The Default\n          chapter_title=\"${title}-$(printf %0${#chaptercount}d $chapternum) ${chapter}\"\n        fi\n        chapter_file=\"${output_directory}/${chapter_title}.${extension}\"\n\n        # Since the .aax file allready got converted we can use\n        # -acodec copy, which is much faster than a reencodation.\n        # Since there is an issue when using copy on flac, where\n        # the duration of the chapters gets shown as if they where\n        # as long as the whole audiobook.\n        chapter_codec=\"\"\n        if test \"${extension}\" = \"flac\"; then\n          chapter_codec=\"flac \"${compression_level_param}\"\"\n        else\n          chapter_codec=\"copy\"\n        fi\n\n        #Since there seems to be a bug in some older versions of ffmpeg, which makes, that -ss and -to\n        #have to be apllied to the output file, this makes, that -ss and -to get applied on the input for\n        #ffmpeg version 4+ and on the output for all older versions.\n        split_input=\"\"\n        split_output=\"\"\n        if [ \"$(($(\"$FFMPEG\" -version | $SED -E 's/[^0-9]*([0-9]).*/\\1/g;1q') > 3))\" = \"1\" ]; then\n          split_input=\"-ss ${chapter_start%?} -to ${chapter_end}\"\n        else\n          split_output=\"-ss ${chapter_start%?} -to ${chapter_end}\"\n        fi\n\n        # Big Long chapter debug\n        debug_vars \"Chapter Variables:\" cover_file chapter_start chapter_end chapternum chapter chapterNameScheme chapter_title chapter_file\n        if [ \"$((${continueAt} > ${chapternum}))\" = \"0\" ]; then\n          # Extract chapter by time stamps start and finish of chapter.\n          # This extracts based on time stamps start and end.\n          if [ \"$((${loglevel} > 1))\" == \"1\" ]; then\n            log \"Splitting chapter ${chapternum}/${chaptercount} start:${chapter_start%?}(s) end:${chapter_end}(s)\"\n          fi\n          </dev/null \"$FFMPEG\" -loglevel quiet \\\n            -nostats \\\n            ${split_input} \\\n            -i \"${output_file}\" \\\n            -i \"${cover_file}\" \\\n            ${extra_crop_cover} \\\n            ${split_output} \\\n            -map 0:0 \\\n            -map 1:0 \\\n            -acodec ${chapter_codec} \\\n            -metadata:s:v title=\"Album cover\" \\\n            -metadata:s:v comment=\"Cover (front)\" \\\n            -metadata track=\"${chapternum}\" \\\n            -metadata title=\"${chapter}\" \\\n            -metadata:s:a title=\"${chapter}\" \\\n            -metadata:s:a track=\"${chapternum}\" \\\n            -map_chapters -1 \\\n            -f ${container} \\\n            \"${chapter_file}\"\n          # -----\n          if [ \"$((${loglevel} < 2))\" == \"1\" ]; then\n            progressbar ${chapternum} ${chaptercount}\n          fi\n          # OK lets get what need for the next chapter in the Playlist m3u file.\n          # Playlist creation.\n          duration=$(echo \"${chapter_end} - ${chapter_start%?}\" | bc)\n          echo \"#EXTINF:${duration%.*},${title} - ${chapter}\" >>  \"${playlist_file}\"\n          echo \"${chapter_title}.${extension}\" >> \"${playlist_file}\"\n        fi\n        chapternum=$((chapternum + 1 ))\n      fi\n    done 9< \"$metadata_file\"\n\n    # Clean up of working directory stuff.\n    rm \"${output_file}\"\n    if [ \"$((${loglevel} > 1))\" == \"1\" ]; then\n      log \"Done creating chapters for ${output_directory}.\"\n    else\n      #ending progress bar\n      echo \"\"\n    fi\n  else\n    # Perform file tasks on output file.\n    # ----\n    # ffmpeg seems to copy only chapter position, not chapter names.\n    # use already created chapter.txt from save_metadata() in case\n    # audible-cli data is used else use ffprobe to extract from m4b\n    if [[ ${container} == \"mp4\" && $(type -P mp4chaps) ]]; then\n      if [ \"${audibleCli}\" == \"1\" ]; then\n        mv \"${tmp_chapter_file}\" \"${output_directory}/${currentFileNameScheme}.chapters.txt\"\n      else\n        \"$FFPROBE\" -i \"${aax_file}\" -print_format csv -show_chapters 2>/dev/null | awk -F \",\" '{printf \"CHAPTER%d=%02d:%02d:%02.3f\\nCHAPTER%dNAME=%s\\n\", NR, $5/60/60, $5/60%60, $5%60, NR, $8}' > \"${output_directory}/${currentFileNameScheme}.chapters.txt\"\n      fi\n      $SED -i 's/\\,000/\\.000/' \"${output_directory}/${currentFileNameScheme}.chapters.txt\"\n      mp4chaps -i \"${output_file}\"\n    fi\n  fi\n\n  if [ -f \"${cover_file}\" ]; then\n    log \"Adding cover art\"\n    # FFMPEG does not support MPEG-4 containers fully #\n    if [ \"${container}\" == \"mp4\" ] ; then\n      mp4art --add \"${cover_file}\" \"${output_file}\"\n    # FFMPEG for everything else #\n    else\n      # Create temporary output file name - ensure extention matches previous appropriate output file to keep ffmpeg happy\n      cover_output_file=\"${output_file%.*}.cover.${output_file##*.}\"\n      # Copy audio stream from current output, and video stream from cover file, setting appropriate metadata\n      </dev/null \"$FFMPEG\" -loglevel quiet \\\n        -nostats \\\n        -i \"${output_file}\" \\\n        -i \"${cover_file}\" \\\n        -map 0:a:0 \\\n        -map 1:v:0 \\\n        -acodec copy \\\n        -vcodec copy \\\n        -id3v2_version 3 \\\n        -metadata:s:v title=\"Album cover\" \\\n        -metadata:s:v comment=\"Cover (front)\" \\\n        \"${cover_output_file}\"\n        # Replace original output file with version including cover\n        mv \"${cover_output_file}\" \"${output_file}\"\n    fi\n  fi\n\n  # -----\n  # Announce that we have completed the transcode\n  if [ \"$((${loglevel} > 0))\" == \"1\" ]; then\n    log \"Complete ${title}\"\n  fi\n  # Lastly get rid of any extra stuff.\n  rm \"${metadata_file}\"\n\n  # Move the aax file if the decode is completed and the --complete_dir is set to a valid location.\n  # Check the target dir for if set if it is writable\n  if [[ \"x${completedir}\" != \"x\"  ]]; then\n    if [ \"$((${loglevel} > 0))\" == \"1\" ]; then\n      log \"Moving Transcoded ${aax_file} to ${completedir}\"\n    fi\n    mv \"${aax_file}\" \"${completedir}\"\n  fi\n\ndone\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.4111328125,
          "content": "DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \nVersion 2, December 2004 \n\nCopyright (c) 2015 KrumpetPirate\n\nEveryone is permitted to copy and distribute verbatim or modified \ncopies of this license document, and changing it is allowed as long \nas the name is changed. \n\nDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION \n\n0. You just DO WHAT THE FUCK YOU WANT TO.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.6943359375,
          "content": "# AAXtoMP3\nThe purpose of this software is to convert AAX (or AAXC) files to common MP3, M4A, M4B, flac and ogg formats\nthrough a basic bash script frontend to FFMPEG.\n\nAudible uses the AAX file format to maintain DRM restrictions on their audio\nbooks and if you download your book through your library it will be\nstored in this format.\n\nThe purpose of this software is **not** to circumvent the DRM restrictions\nfor audio books that **you** do not own in that you do not have them on\nyour **personal** Audible account. The purpose of this software is to\ncreate a method for you to download and store your books just in case\nAudible fails for some reason.\n\n## Requirements\n* bash 3.2.57 or later tested\n* ffmpeg version 2.8.3 or later (4.4 or later if the input file is `.aaxc`)\n* libmp3lame - (typically 'lame' in your system's package manager)\n* GNU grep - macOS or BSD users may need to install through package manager\n* GNU sed - see above\n* GNU find - see above\n* jq - only if `--use-audible-cli-data` is set or if converting an .aaxc file\n* mp4art used to add cover art to m4a and m4b files. Optional\n* mediainfo used to add additional media tags like narrator. Optional\n\n## Usage(s)\n```\nbash AAXtoMP3 [-f|--flac] [-o|--opus] [-a|--aac] [-s|--single] [--level <COMPRESSIONLEVEL>] [-c|--chaptered] [-e:mp3] [-e:m4a] [-e:m4b] [-A|--authcode <AUTHCODE>] [-n|--no-clobber] [-t|--target_dir <PATH>] [-C|--complete_dir <PATH>] [-V|--validate] [--use-audible-cli-data]] [-d|--debug] [-h|--help] [--continue <CHAPTERNUMBER>] <AAX/AAXC INPUT_FILES>...\n```\nor if you want to get guided through the options\n```\nbash interactiveAAXtoMP3 [-a|--advanced] [-h|--help]\n```\n\n* **&lt;AAX INPUT_FILES&gt;**... are considered input file(s), useful for batching!\n\n## Options for AAXtoMP3\n* **-f** or **--flac**   Flac Encoding and as default produces a single file.\n* **-o** or **--opus**   Ogg/Opus Encoding defaults to multiple file output by chapter. The extension is .ogg\n* **-a** or **--aac**    AAC Encoding and produce a m4a single files output.\n* **-A** or **--authcode &lt;AUTHCODE&gt;** for this execution of the command use the provided &lt;AUTHCODE&gt; to decode the AAX file. Not needed if the source file is .aaxc.\n* **-n** or **--no-clobber** If set and the target directory already exists, AAXtoMP3 will exit without overwriting anything.\n* **-t** or **--target_dir &lt;PATH&gt;** change the default output location to the named &lt;PATH&gt;. Note the default location is ./Audiobook of the directory to which each AAX file resides.\n* **-C** or **--complete_dir &lt;PATH&gt;** a directory to place aax files after they have been decoded successfully. Note make a back up of your aax files prior to using this option. Just in case something goes wrong.\n* **-V** or **--validate** Perform 2 validation tests on the supplied aax files. This is more extensive than the normal validation as we attempt to transcode the aax file to a null file.  This can take a long period of time. However it is useful when inspecting a large set of aax files prior to transcoding. As download errors are common with Audible servers.\n* **-e:mp3**         Identical to defaults.\n* **-e:m4a**         Create a m4a audio file. This is identical to --aac\n* **-e:m4b**         Create a m4b audio file. This is the book version of the m4a format.\n* **-s** or **--single**    Output a single file for the entire book. If you only want a single ogg file for instance.\n* **-c** or **--chaptered** Output a single file per chapter. The `--chaptered` will only work if it follows the `--aac -e:m4a -e:m4b --flac` options.\n* **--continue &lt;CHAPTERNUMBER&gt;**      If the splitting into chapters gets interrupted (e.g. by a weak battery on your laptop) you can go on where the process got interrupted. Just delete the last chapter (which was incompletely generated) and redo the task with \"--continue &lt;CHAPTERNUMBER&gt;\" where CHAPTERNUMBER is the chapter that got interrupted.\n* **--level &lt;COMPRESSIONLEVEL&gt;**      Set compression level. May be given for mp3, flac and opus.\n* **--keep-author &lt;FIELD&gt;**           If a book has multiple authors and you don't want all of them in the metadata, with this flag you can specify a specific author (1 is the first, 2 is the second...) to keep while discarding the others.\n* **--author &lt;AUTHOR&gt;**               Manually set the author metadata field, useful if you have multiple books of the same author but the name reported is different (eg. spacing, accents..). Has precedence over `--keep-author`.\n* **-l** or **--loglevel &lt;LOGLEVEL&gt;** Set loglevel: 0 = progress only, 1 (default) = more information, output of chapter splitting progress is limitted to a progressbar, 2 = more information, especially on chapter splitting, 3 = debug mode\n* **--dir-naming-scheme &lt;STRING&gt;** or **-D**      Use a custom directory naming scheme, with variables. See [below](#custom-naming-scheme) for more info.\n* **--file-naming-scheme &lt;STRING&gt;** or **-F**    Use a custom file naming scheme, with variables. See [below](#custom-naming-scheme) for more info.\n* **--chapter-naming-scheme &lt;STRING&gt;**  Use a custom chapter naming scheme, with variables. See [below](#custom-naming-scheme) for more info.\n* **--use-audible-cli-data** Use additional data got with mkb79/audible-cli. See [below](#audible-cli-integration) for more info. Needed for the files in the `aaxc` format.\n* **--audible-cli-library-file** or **-L** Path of the library-file, generated by mkb79/audible-cli (`audible library export -o ./library.tsv`). Only available if `--use-audible-cli-data` is set. This file is required to parse additional metadata such as `$series` or `$series_sequence`.\n* **--ffmpeg-path**  Set the ffmpeg/ffprobe binaries folder. Both of them must be executable and in the same folder.\n* **--ffmpeg-name**  Set a custom name for the ffmpeg binary. Must be executable and in path, or in custom path specified by --ffmpeg-path.\n* **--ffprobe-name**  Set a custom name for the ffprobe binary. Must be executable and in path, or in custom path specified by --ffmpeg-path.\n\n## Options for interactiveAAXtoMP3\n* **-a** or **--advanced** Get more options to choose. Not used right now.\n* **-h** or **--help** Get a help prompt.\nThis script presents you the options you chose last time as default.\nWhen you get asked for the aax-file you may just drag'n'drop it to the terminal.\n\n### AUTHCODE\n**Your** Audible auth code (it won't correctly decode otherwise) (not required to decode the `aaxc` format).\n\n#### Determining your own AUTHCODE\nYou will need your authentication code that comes from Audible's servers. This \nwill be used by ffmpeg to perform the initial audio convert. You can obtain \nthis string from a tool like \n[audible-activator](https://github.com/inAudible-NG/audible-activator) or like [audible-cli](https://github.com/mkb79/audible-cli).\n\n#### Specifying the AUTHCODE.\nIn order of __precidence__.\n1. __--authcode [AUTHCODE]__ The command line option. With the highest precedence.\n2. __.authcode__ If this file is placed in the current working directory and contains only the authcode it is used if the above is not.\n3. __~/.authcode__ a global config file for all the tools. And is used as the default if none of the above are specified.\n__Note:__ At least one of the above must be exist if converting `aax` files. The code must also match the encoding for the user that owns the AAX file(s). If the authcode does not match the AAX file no transcoding will occur.\n\n### MP3 Encoding\n* This is the **default** encoding\n* Produces 1 or more mp3 files for the AAX title.\n* The default mode is **chaptered**\n* If you want a mp3 file per chapter do not use the **--single** option. \n* A m3u playlist file will also be created in this instance in the case of **default** chaptered output.\n* **--level** has to be in range 0-9, where 9 is fastest and 0 is highest quality. Please note: The quality can **never** become higher than the qualitiy of the original aax file!\n\n### Ogg/Opus Encoding\n* Can be done by using the **-o** or **--opus** command line switches\n* The default mode is **chaptered**\n* Opus coded files are stored in the ogg container format for better compatibility.\n* **--level** has to be in range 0-10, where 0 is fastest and 10 is highest quality. Please note: The quality can **never** become higher than the qualitiy of the original aax file!\n\n### AAC Encoding\n* Can be done by using the **-a** or **--aac** command line switches\n* The default mode is **single**\n* Designed to be the successor of the MP3 format\n* Generally achieves better sound quality than MP3 at the same bit rate.\n* This will only produce 1 audio file as output.\n\n### FLAC Encoding\n* Can be done by using the **-f** or **--flac** command line switches\n* The default mode is **single**\n* FLAC is an open format with royalty-free licensing\n* This will only produce 1 audio file as output. If you want a flac file per chapter do use **-c** or **--chaptered**.\n* **--level** has to be in range 0-12, where 0 is fastest and 12 is highest compression. Since flac is lossless, the quality always remains the same.\n\n### M4A and M4B Containers\n* These containers were created by Apple Inc. They were meant to be the successor to mp3.\n* M4A is a container that is meant to hold music and is typically of a higher bitrate.\n* M4B is a container that is meant to hold audiobooks and is typically has bitrates of 64k and 32k.\n* Both formats are chaptered\n* Both support coverart internal\n* The default mode is **single**\n\n### Validating AAX files\n* The **--validate** option will result in only a validation pass over the supplied aax file(s). No transcoding will occur. This is useful when you wish to ensure you have a proper download of your personal Audible audio books. With this option all supplied books are validated.\n* If you do NOT supply the **--validate** option all audio books are still validated when they are processed. However if there is an invalid audio book in the supplied list of books the processing will stop at that point.\n* A third test is performed on the file where the entire file is inspected to see if it is valid. This is a lengthy process. However it will not break the script when an invalid file is found.\n* The 3 test current are:\n    1. aax present\n    1. meta data header in file is valid and complete\n    1. entire file is valid and complete.  _only executed with the **--validate** option._\n\n### Defaults\n* Default out put directory is the base directory of each file listed. Plus the genre, Artist and Title of the Audio Book.\n* The default codec is mp3\n* The default output is by chapter.\n\n### Custom naming scheme\nThe following flags can modify the default naming scheme:\n* **--dir-naming-scheme** or **-D**  \n* **--file-naming-scheme** or **-F** \n* **--chapter-naming-scheme** \n\nEach flag takes a string as argument. If the string contains a variable defined in the script (eg. artist, title, chapter, narrator...), the corresponding value is used.\nThe default options correspond to the following flags:\n* `--dir-naming-scheme '$genre/$artist/$title'`\n* `--file-naming-scheme '$title'`\n* `--chapter-naming-scheme '$title-$(printf %0${#chaptercount}d $chapternum) $chapter'`\n\nAdditional notes:\n* If a command substitution is present in the passed string, (for example `$(printf %0${#chaptercount}d $chapternum)`, used to pad with zeros the chapter number), the commands are executed.\nSo you can use `--dir-naming-scheme '$(date +%Y)/$artist'`, but using `--file-naming-scheme '$(rm -rf /)'` is a really bad idea. Be careful.\n* You can use basic text, like `--dir-naming-scheme 'Converted/$title'`\n* You can also use shell variables as long as you escape them properly: `CustomGenre=Horror ./AAXtoMP3 --dir-naming-scheme \"$CustomGenre/\\$artist/\\$title\" *.aax`\n* If you want shorter chapter names, use `--chapter-naming-scheme '$(printf %0${#chaptercount}d $chapternum) $chapter'`: only chapter number and chapter name\n* If you want to append the narrator name to the title, use `--dir-naming-scheme '$genre/$artist/$title-$narrator' --file-naming-scheme '$title-$narrator'`\n* If you don't want to have the books separated by author, use `--dir-naming-scheme '$genre/$title'`\n* To be able to use `$series` or `$series_sequence` in the schemes the following is required:\n  * `--use-audible-cli-data` is set\n  * you have pre-generated the library-file via `audible library export -o ./library.tsv`\n  * you have set the path to the generated library-file via `--audible-cli-library-file ./library.tsv`\n\n### Installing Dependencies.\nIn general, take a look at [command-not-found.com](https://command-not-found.com/)\n#### FFMPEG,FFPROBE\n__Ubuntu, Linux Mint, Debian__\n```\nsudo apt-get update\nsudo apt-get install ffmpeg libav-tools x264 x265 bc\n```\n\nIn Debian-based system's repositories the ffmpeg version is often outdated. If you want\nto convert .aaxc files, you need at least ffmpeg 4.4. So if your installed version\nneeds to be updated, you can either install a custom repository that has the newer version,\ncompile ffmpeg from source or download pre-compiled binaries.\nYou can then tell AAXtoMP3 to use the compiled binaries with the `--ffmpeg-path` flag.\nYou need to specify the folder where the ffmpeg and ffprobe binaries are. Make sure\nthey are both executable.\n\nIf you have snapd installed, you can also install a recent version of 4.4 from the edge channel:\n```\nsnap install ffmpeg --edge\n```\nIn this case you will need to confiure a custom path _and_ binary name for ffprobe, `--ffmpeg-path /snap/bin/ --ffprobe-name ffmpeg.ffprobe`.\n\n__Fedora__\n\nFedora users need to enable the rpm fusion repository to install ffmpeg. Version 22 and upwards are currently supported. The following command works independent of your current version:\n```\nsudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm\n```\nAfterwards use the package manager to install ffmpeg:\n```\nsudo dnf install ffmpeg\n```\n\n__RHEL or compatible like CentOS__\n\nRHEL version 6 and 7 are currently able to use rpm fusion.\nIn order to use rpm fusion you have to enable EPEL, see http://fedoraproject.org/wiki/EPEL\n\nAdd the rpm fusion repositories in version 6\n```\nsudo yum localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-6.noarch.rpm https://download1.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-6.noarch.rpm\n```\nor version 7:\n```\nsudo yum localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm https://download1.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-7.noarch.rpm\n```\nthen install ffmpeg:\n```\nsudo yum install ffmpeg\n```\n\n__MacOS__\n```\nbrew install ffmpeg\nbrew install gnu-sed\nbrew install grep\nbrew install findutils\n```\n\n#### mp4art/mp4chaps\n_Note: This is an optional dependency, required for adding cover art to m4a and b4b files only._\n\n__Ubuntu, Linux Mint, Debian__\n```\nsudo apt-get update\nsudo apt-get install mp4v2-utils\n```\n\nOn Debian and Ubuntu the mp4v2-utils package has been deprecated and removed, as the upsteam project is no longer maintained.\nThe package was removed in Debian Buster, and Ubuntu Focal [ 20.04 ].\n\n__CentOS, RHEL & Fedora__\n```\n# CentOS/RHEL and Fedora users make sure that you have enabled atrpms repository in system. Let’s begin installing FFmpeg as per your operating system.\nyum install mp4v2-utils\n```\n__MacOS__\n```\nbrew install mp4v2\n```\n\n#### mediainfo\n_Note: This is an optional dependency._\n\n__Ubuntu, Linux Mint, Debian__\n```\nsudo apt-get update\nsudo apt-get install mediainfo\n```\n__CentOS, RHEL & Fedora__\n```\nyum install mediainfo\n```\n__MacOS__\n```\nbrew install mediainfo\n```\n## AAXC files\nThe AAXC format is a new Audible encryption format, meant to replace the old AAX.\nThe encryption has been updated, and now to decrypt the file the authcode\nis not sufficient, we need two \"keys\" which are unique for each audiobook.\nSince getting those keys is not simple, for now the method used to get them\nis handled by the package audible-cli, that stores\nthem in a file when downloading the aaxc file. This means that in order to\ndecrypt the aaxc files, they must be downloaded with audible-cli.\nNote that you need at least [ffmpeg 4.4](#ffmpegffprobe).\n\n## Audible-cli integration\nSome information are not present in the AAX file. For example the chapters's\ntitle, additional chapters division (Opening and End credits, Copyright and\nmore).  Those information are avaiable via a non-public audible API. This\n[repo](https://github.com/mkb79/Audible) provides a python API wrapper, and the\n[audible-cli](https://github.com/mkb79/audible-cli) packege makes easy to get\nmore info. In particular the flags **--cover --cover-size 1215 --chapter**\ndownloads a better-quality cover (.jpg) and detailed chapter infos (.json).\nMore info are avaiable on the package page.\n\nSome books might not be avaiable in the old `aax` format, but only in the newer\n`aaxc` format. In that case, you can use [audible-cli](https://github.com/mkb79/audible-cli)\nto download them. For example, to download all the books in your library in the newer `aaxc` format, as well as\nchapters's title and an HQ cover: `audible download --all --aaxc --cover --cover-size 1215 --chapter`.\n\nTo make AAXtoMP3 use the additional data, specify the **--use-audible-cli-data**\nflag: it expects the cover and the chapter files (and the voucher, if converting\nan aaxc file) to be in the same location of the AAX file.  The naming of these\nfiles must be the one set by audible-cli. When converting aaxc files, the variable\nis automatically set, so be sure to follow the instructions in this paragraph.\n\nFor more information on how to use the `audible-cli` package, check out the git page [audible-cli](https://github.com/mkb79/audible-cli).\n\nPlease note that right now audible-cli is in dev stage, so keep in mind that the\nnaming scheme of the additional files, the flags syntax and other things can\nchange without warning.\n \n\n## Anti-Piracy Notice\nNote that this project **does NOT ‘crack’** the DRM. It simply allows the user to\nuse their own encryption key (fetched from Audible servers) to decrypt the\naudiobook in the same manner that the official audiobook playing software does.\n\nPlease only use this application for gaining full access to your own audiobooks\nfor archiving/conversion/convenience. DeDRMed audiobooks should not be uploaded\nto open servers, torrents, or other methods of mass distribution. No help will\nbe given to people doing such things. Authors, retailers, and publishers all\nneed to make a living, so that they can continue to produce audiobooks for us to\nhear, and enjoy. Don’t be a parasite.\n\nThis blurb is borrowed from the https://apprenticealf.wordpress.com/ page.\n\n## License\nChanged the license to the WTFPL, do whatever you like with this script. Ultimately it's just a front-end for ffmpeg after all.\n\n## Need Help?\nI'll help out if you are having issues, just submit and issue and I'll get back to you when I can.\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.0244140625,
          "content": "theme: jekyll-theme-slate"
        },
        {
          "name": "interactiveAAXtoMP3",
          "type": "blob",
          "size": 6.05859375,
          "content": "#!/usr/bin/env bash\n\n# ===Note for contributors========================================================================================================================\n\n# This script interactively asks the user for the options to call AAXtoMP3 with. This first version does not include all options of AAXtoMP3\n# since I tried to keep the dialog short, but I added an --advanced option, which is unused right now, but might be used in the future to add\n# more options which only show up if explicitely wanted.\n# If you want to add functionality please consider, whether the functionality you add might belong to the advanced options.\n\n# ===Variables====================================================================================================================================\n\n# Help message\nhelp=$'\\nUsage: interactiveAAXtoMP3 [--advanced] [--help]\\n\n--advanced\tMore options\n--help\t\tPrint this message\\n'\nsummary=\"\"         # This will contain a summary of the options allready set.\ncall=\"./AAXtoMP3\"  # This will contain the call for AAXtoMP3.\nadvanced=0         # Toggles advanced options on or off.\n\n# ===Options======================================================================================================================================\n\nwhile true; do\n  case \"$1\" in\n                     # Advanced options.\n    -a | --advanced  ) advanced=1;      shift ;;\n                     # Command synopsis.\n    -h | --help      ) echo -e \"$help\"; exit ;;\n                     # Anything else stops command line processing.\n    *                )                  break ;;\n  esac\ndone\n\n# ===Cross platform compatible use grep and sed===================================================================================================\n\n# ===Detect which annoying version of grep we have===\nGREP=$(grep --version | grep -q GNU && echo \"grep\" || echo \"ggrep\")\nif ! [[ $(type -P \"$GREP\") ]]; then\n  echo \"$GREP (GNU grep) is not in your PATH\"\n  echo \"Without it, this script will break.\"\n  echo \"On macOS, you may want to try: brew install grep\"\n  exit 1\nfi\n\n# ===Detect which annoying version of sed we have===\nSED=$(sed --version 2>&1 | $GREP -q GNU && echo \"sed\" || echo \"gsed\")\nif ! [[ $(type -P \"$SED\") ]]; then\n  echo \"$SED (GNU sed) is not in your PATH\"\n  echo \"Without it, this script will break.\"\n  echo \"On macOS, you may want to try: brew install gnu-sed\"\n  exit 1\nfi\n\n# ===Get options from last time===================================================================================================================\n\n# ===Set default values===\nlastcodec=\"mp3\"\nlastcompression=\"4\"\nlastchapters=\"yes\"\nlastauthcode=\"\"\nlastloglevel=\"1\"\n\n# ===Get Values from last time===\nif [ -f \".interactivesave\" ]; then\n  for ((i=1;i<=$(wc -l .interactivesave | cut -d \" \" -f 1);i++)) do\n    line=$(head -$i .interactivesave | tail -1)\n    case $(echo $line | cut -d \" \" -f 1 | $SED 's/.$//') in\n      codec        ) lastcodec=\"$(echo $line | cut -d \" \" -f 2)\";;\n      compression  ) lastcompression=\"$(echo $line | cut -d \" \" -f 2)\";;\n      chapters     ) lastchapters=\"$(echo $line | cut -d \" \" -f 2)\";;\n      authcode     ) lastauthcode=\"$(echo $line | cut -d \" \" -f 2)\";;\n      loglevel     ) lastloglevel=\"$(echo $line | cut -d \" \" -f 2)\";;\n      *            ) rm .interactivesave; exit 1;;\n    esac\n  done\nfi\n\n# ===Get options for AAXtoMP3=====================================================================================================================\n\n# ===Codec===\nwhile true; do\n  clear;\n  read -e -p \"codec (mp3/m4a/m4b/flac/aac/opus): \" -i \"$lastcodec\" codec\n  case \"$codec\" in\n    mp3   ) summary=\"$summary\"\"codec: $codec\"; call=\"$call -e:mp3\"; break;;\n    m4a   ) summary=\"$summary\"\"codec: $codec\"; call=\"$call -e:m4a\"; break;;\n    m4b   ) summary=\"$summary\"\"codec: $codec\"; call=\"$call -e:m4b\"; break;;\n    flac  ) summary=\"$summary\"\"codec: $codec\"; call=\"$call --flac\"; break;;\n    aac   ) summary=\"$summary\"\"codec: $codec\"; call=\"$call --aac\";  break;;\n    opus  ) summary=\"$summary\"\"codec: $codec\"; call=\"$call --opus\"; break;;\n  esac\ndone\n\n# ===Compression===\nwhile true; do\n  clear; echo -e \"$summary\"\n  case \"$codec\" in\n    mp3   ) maxlevel=9;;\n    flac  ) maxlevel=12;;\n    opus  ) maxlevel=10;;\n    *     ) break;;\n  esac\n  read -e -p \"compression level (0-$maxlevel): \" -i \"$lastcompression\" compression\n  if [[ $compression =~ ^[0-9]+$ ]] && [[ \"$compression\" -ge \"0\" ]] && [[ \"$compression\" -le \"$maxlevel\" ]]; then\n    summary=\"$summary\"\"\\ncompression level: $compression\"\n    call=\"$call --level $compression\"\n    break\n  fi\ndone\n\n# ===Chapters===\nwhile true; do\n  clear; echo -e \"$summary\"\n  read -e -p \"chapters (yes/no/chapternumber to continue with): \" -i \"$lastchapters\" chapters\n  case \"$chapters\" in\n    ^[0-9]+$  ) summary=\"$summary\"\"\\nchapters: $chapters\"; call=\"$call -c --continue ${chapters}\"; break;;\n    yes       ) summary=\"$summary\"\"\\nchapters: $chapters\"; call=\"$call -c\"; break;;\n    no        ) summary=\"$summary\"\"\\nchapters: $chapters\"; call=\"$call -s\"; break;;\n  esac\ndone\n\n# ===Authcode===\nif ! [ -r .authcode ] || [ -r ~/.authcode ]; then\n  clear; echo -e \"$summary\"\n  read -e -p \"Authcode: \" -i \"$lastauthcode\" authcode\n  summary=\"$summary\"\"\\nauthcode: $authcode\"\n  call=\"$call -A $authcode\"\nfi\n\n# ===Loglevel===\nwhile true; do\n  clear; echo -e \"$summary\"\n  read -e -p \"loglevel (0/1/2/3): \" -i \"$lastloglevel\" loglevel\n  if [[ $loglevel =~ ^[0-9]+$ ]] && [[ \"$loglevel\" -ge \"0\" ]] && [[ \"$loglevel\" -le \"3\" ]]; then\n    summary=\"$summary\"\"\\nloglevel: $loglevel\"\n    call=\"$call -l $loglevel\"\n    break\n  fi\ndone\n\n# ===File===\nclear; echo -e \"$summary\"\nread -p \"aax-file: \" file\nfile=\"${file%\\'}\" #remove suffix ' if file is given via drag'n'drop\nfile=\"${file#\\'}\" #remove prefix ' if file is given via drag'n'drop\nsavefile=\"$summary\"\nsummary=\"$summary\"\"\\naax-file: $file\"\ncall=\"$call $(echo $file | $SED \"s;~;$HOME;\")\"\n\n# ===Summerize chosen options and call AAXtoMP3===================================================================================================\n\n# ===Summary===\nclear; echo -e \"$summary\\n\"\necho -e \"$call\\n\"\n\n# ===Save chosen options===\necho -e $savefile | $SED \"s;\\ level:;:;\" > .interactivesave\n\n# ===Call AAXtoMP3===\n$call\n"
        }
      ]
    }
  ]
}