{
  "metadata": {
    "timestamp": 1736568300225,
    "page": 200,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "evertramos/nginx-proxy-automation",
      "stars": 2658,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".env.sample",
          "type": "blob",
          "size": 5.0986328125,
          "content": "#-----------------------------------------------------------------------\n#\n# https://github.com/evertramos/nginx-proxy-automation\n#\n# NGINX Proxy automation\n#\n# This is the .env file to set up nginx-proxy in your environment\n#\n#-----------------------------------------------------------------------\n\n#-----------------------------------------------------------------------\n#\n# Script requirements\n#\n\n# PID file the running script\nPID_FILE=.fresh_start.pid\n\n# Allow run commands with sudo if needed\nALLOW_RUN_WITH_SUDO=false\n\n#-----------------------------------------------------------------------\n#\n# NGINX-Proxy containers/service\n#\n# The variables below is used to set the containers name for the nginx-proxy\n# and the image version for each service, please note that if you use our script\n# we will replace the service name in docker-compose file with the container name\n#\nNGINX_WEB_SEVICE_NAME=proxy-web\nNGINX_IMAGE_VERSION=stable-alpine\n\nDOCKER_GEN_SEVICE_NAME=docker-gen\nDOCKER_GEN_IMAGE_VERSION=latest\n\nLETS_ENCRYPT_SEVICE_NAME=acme-companion\nNGINX_PROXY_COMPANION_IMAGE_VERSION=2.0\n\n#-----------------------------------------------------------------------\n#\n# IP address of the external interface\n#\n# The IP address below is used to bind your local services to the internet\n# please make sure you use the correct address otherwise your proxy will not\n# work properly, '0.0.0.0' will work, but we recommend to update this variable\n#\nIPv4=0.0.0.0\nIPv6=::0\n\n#-----------------------------------------------------------------------\n#\n# Default network name\n#\n# The network name set below is used by the proxy to forward internet requests\n# to the correct containers in your environment, so please make sure to add this\n# network in all docker containers, otherwise it will break the proxy redirection\n#\nNETWORK=proxy\n\n#-----------------------------------------------------------------------\n#\n# Data path for the nginx-proxy files\n#\n# The variable below will be used to place all files used by the nginx-proxy\n# please consider including this folder to your backup services, once all config\n# files, settings and certificates will be placed here in case you need to recover\n#\nNGINX_FILES_PATH=./data\n\n#-----------------------------------------------------------------------\n#\n# Docker logging settings\n#\n# Logs! Very important, right? But if you do not clean it up, it might causes you\n# issues on disk space over time, so keep in mind to set this log options making sure\n# you will have the least to audit, any further information on that please check the docs\n#\n# https://docs.docker.com/config/containers/logging/configure/\n#\nNGINX_WEB_LOG_DRIVER=json-file\nNGINX_WEB_LOG_MAX_SIZE=4m\nNGINX_WEB_LOG_MAX_FILE=10\n\nNGINX_GEN_LOG_DRIVER=json-file\nNGINX_GEN_LOG_MAX_SIZE=2m\nNGINX_GEN_LOG_MAX_FILE=10\n\nNGINX_LETSENCRYPT_LOG_DRIVER=json-file\nNGINX_LETSENCRYPT_LOG_MAX_SIZE=2m\nNGINX_LETSENCRYPT_LOG_MAX_FILE=10\n\n#-----------------------------------------------------------------------\n#\n# Docker ports that should be binded by the proxy\n#\n# This option were added by a contributor long ago, so might be a very specific case\n# where you might need to change http and https port number, keep in mind that changes\n# on that setting might will break the auto renewing Let's Encrypt certificate services\n#\nDOCKER_HTTP_=80\nDOCKER_HTTPS=443\n\n#-----------------------------------------------------------------------\n#\n# SSL policy (defaults to Mozilla-Intermediate)\n#\n# This also was added by a contributor which sets the default cipher configuration\n# to the nginx-proxy container, which has the 'Mozilla-Intermediate' as default value\n# plase make sure you take a good look at options in the url below before messing around\n#\n# https://github.com/nginx-proxy/nginx-proxy#how-ssl-support-works\n#\n#SSL_POLICY=Mozilla-Modern\n\n#-----------------------------------------------------------------------\n#\n# Let's Encrypt default email\n#\n# You might want to inform a default email to Let's Encrypt certificate once it is\n# a required parameter in order to issue the new certificate. This information will be\n# replaced by the LETSENCRYPT_EMAIL environment varibale present in your docker container\n#\nDEFAULT_EMAIL=mail@yourdomain.tld\n\n#-----------------------------------------------------------------------\n#\n# Default host\n#\n# Nginx-proxy will then redirect all requests to a container where you have set\n# \"VIRTUAL HOST\" set to \"DEFAULT HOST\", if they don't match any (other) container\n# You might want to check the link below for more information:\n# https://github.com/nginx-proxy/nginx-proxy#default-host\n#\nDEFAULT_HOST=\n\n#-----------------------------------------------------------------------\n#\n# Docker Rootless\n#\n# In case you want to use this proxy on Docker Rootless (DR) and you also have followed\n# the DR installation from the official documentation (https://docs.docker.com/engine/security/rootless/)\n# Set the following value of the DOCKER_HOST variable that you got in the final info messages after executing\n# the \"$ dockerd-rootless-setuptool.sh install\" command.\n# For example DOCKER_HOST_PATH=$XDG_RUNTIME_DIR/docker.sock\n# If you are not using Docker Rootless, leave this variable blank\nDOCKER_HOST_ROOTLESS_PATH=\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0810546875,
          "content": "data\n.env*\n!.env.sample\n.DS_Store\n.idea/\n/bin/basescript.log\n/docker-compose.yml.*\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.09375,
          "content": "[submodule \"basescript\"]\n\tpath = basescript\n\turl = https://github.com/evertramos/basescript.git\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) Evert Ramos\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "basescript",
          "type": "commit",
          "content": null
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf.d",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 3.2060546875,
          "content": "version: '3.5'\n\nservices:\n  nginx-proxy-automation-web:\n    image: nginx:${NGINX_IMAGE_VERSION:-stable-alpine}\n    labels:\n      com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy: \"true\"\n    container_name: ${NGINX_WEB_SEVICE_NAME:-nginx-proxy-automation-web}\n    restart: always\n    ports:\n      - \"${IPv4:-0.0.0.0}:${DOCKER_HTTP_:-80}:80\"\n      - \"${IPv4:-0.0.0.0}:${DOCKER_HTTPS:-443}:443\"\n#      - \"${IPv6:-::0}:${DOCKER_HTTP_:-80}:80\"\n#      - \"${IPv6:-::0}:${DOCKER_HTTPS:-443}:443\"\n    environment:\n      SSL_POLICY: ${SSL_POLICY:-Mozilla-Intermediate}\n#      DEFAULT_HOST: ${DEFAULT_HOST}\n#      ENABLE_IPV6: \"true\"\n    volumes:\n      - ${NGINX_FILES_PATH:-./data}/conf.d:/etc/nginx/conf.d\n      - ${NGINX_FILES_PATH:-./data}/vhost.d:/etc/nginx/vhost.d\n      - ${NGINX_FILES_PATH:-./data}/html:/usr/share/nginx/html\n      - ${NGINX_FILES_PATH:-./data}/certs:/etc/nginx/certs:ro\n      - ${NGINX_FILES_PATH:-./data}/htpasswd:/etc/nginx/htpasswd:ro\n    logging:\n      driver: ${NGINX_WEB_LOG_DRIVER:-json-file}\n      options:\n        max-size: ${NGINX_WEB_LOG_MAX_SIZE:-4m}\n        max-file: ${NGINX_WEB_LOG_MAX_FILE:-10}\n\n  nginx-proxy-automation-gen:\n    image: nginxproxy/docker-gen:${DOCKER_GEN_IMAGE_VERSION:-0.7.7}\n    command: -notify-sighup ${NGINX_WEB_SEVICE_NAME:-nginx-proxy-automation-web} -watch -wait 5s:30s /etc/docker-gen/templates/nginx.tmpl /etc/nginx/conf.d/default.conf\n    container_name: ${DOCKER_GEN_SEVICE_NAME:-nginx-proxy-automation-gen}\n    restart: always\n    volumes:\n      - ${NGINX_FILES_PATH:-./data}/conf.d:/etc/nginx/conf.d\n      - ${NGINX_FILES_PATH:-./data}/vhost.d:/etc/nginx/vhost.d\n      - ${NGINX_FILES_PATH:-./data}/html:/usr/share/nginx/html\n      - ${NGINX_FILES_PATH:-./data}/certs:/etc/nginx/certs:ro\n      - ${NGINX_FILES_PATH:-./data}/htpasswd:/etc/nginx/htpasswd:ro\n      - ${DOCKER_HOST_ROOTLESS_PATH:-/var/run/docker.sock}:/tmp/docker.sock:ro\n      - ./nginx.tmpl:/etc/docker-gen/templates/nginx.tmpl:ro\n    logging:\n      driver: ${NGINX_GEN_LOG_DRIVER:-json-file}\n      options:\n        max-size: ${NGINX_GEN_LOG_MAX_SIZE:-2m}\n        max-file: ${NGINX_GEN_LOG_MAX_FILE:-10}\n\n  nginx-proxy-automation-letsencrypt:\n    image: nginxproxy/acme-companion:${NGINX_PROXY_COMPANION_IMAGE_VERSION:-2.1}\n    container_name: ${LETS_ENCRYPT_SEVICE_NAME:-nginx-proxy-automation-letsencrypt}\n    restart: always\n    volumes:\n      - ${NGINX_FILES_PATH:-./data}/conf.d:/etc/nginx/conf.d\n      - ${NGINX_FILES_PATH:-./data}/vhost.d:/etc/nginx/vhost.d\n      - ${NGINX_FILES_PATH:-./data}/html:/usr/share/nginx/html\n      - ${NGINX_FILES_PATH:-./data}/certs:/etc/nginx/certs:rw\n      - ${NGINX_FILES_PATH:-./data}/acme.sh:/etc/acme.sh\n      - ${DOCKER_HOST_ROOTLESS_PATH:-/var/run/docker.sock}:/var/run/docker.sock:ro\n    environment:\n      NGINX_DOCKER_GEN_CONTAINER: ${DOCKER_GEN_SEVICE_NAME:-nginx-proxy-automation-gen}\n      NGINX_PROXY_CONTAINER: ${NGINX_WEB_SEVICE_NAME:-nginx-proxy-automation-web}\n      DEFAULT_EMAIL: ${DEFAULT_EMAIL:-mail@yourdomain.tld}\n    logging:\n      driver: ${NGINX_LETSENCRYPT_LOG_DRIVER:-json-file}\n      options:\n        max-size: ${NGINX_LETSENCRYPT_LOG_MAX_SIZE:-2m}\n        max-file: ${NGINX_LETSENCRYPT_LOG_MAX_FILE:-10}\n\nnetworks:\n  default:\n    external: true\n    name: ${NETWORK:-proxy}\n\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "nginx.tmpl",
          "type": "blob",
          "size": 16.7724609375,
          "content": "{{ $CurrentContainer := where $ \"ID\" .Docker.CurrentContainerID | first }}\n\n{{ $external_http_port := coalesce $.Env.HTTP_PORT \"80\" }}\n{{ $external_https_port := coalesce $.Env.HTTPS_PORT \"443\" }}\n\n{{ define \"upstream\" }}\n\t{{ if .Address }}\n\t\t{{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}\n\t\t{{ if and .Container.Node.ID .Address.HostPort }}\n\t\t\t# {{ .Container.Node.Name }}/{{ .Container.Name }}\n\t\t\tserver {{ .Container.Node.Address.IP }}:{{ .Address.HostPort }};\n\t\t{{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}\n\t\t{{ else if .Network }}\n\t\t\t# {{ .Container.Name }}\n\t\t\tserver {{ .Network.IP }}:{{ .Address.Port }};\n\t\t{{ end }}\n\t{{ else if .Network }}\n\t\t# {{ .Container.Name }}\n\t\t{{ if .Network.IP }}\n\t\t\tserver {{ .Network.IP }} down;\n\t\t{{ else }}\n\t\t\tserver 127.0.0.1 down;\n\t\t{{ end }}\n\t{{ end }}\n\n{{ end }}\n\n{{ define \"ssl_policy\" }}\n\t{{ if eq .ssl_policy \"Mozilla-Modern\" }}\n\t\tssl_protocols TLSv1.3;\n\t\t{{/* nginx currently lacks ability to choose ciphers in TLS 1.3 in configuration, see https://trac.nginx.org/nginx/ticket/1529 /*}}\n\t\t{{/* a possible workaround can be modify /etc/ssl/openssl.cnf to change it globally (see https://trac.nginx.org/nginx/ticket/1529#comment:12 ) /*}}\n\t\t{{/* explicitly set ngnix default value in order to allow single servers to override the global http value */}}\n\t\tssl_ciphers HIGH:!aNULL:!MD5;\n\t\tssl_prefer_server_ciphers off;\n\t{{ else if eq .ssl_policy \"Mozilla-Intermediate\" }}\n\t\tssl_protocols TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';\n\t\tssl_prefer_server_ciphers off;\n\t{{ else if eq .ssl_policy \"Mozilla-Old\" }}\n\t\tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA';\n\t\tssl_prefer_server_ciphers on;\n\t{{ else if eq .ssl_policy \"AWS-TLS-1-2-2017-01\" }}\n\t\tssl_protocols TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:AES128-GCM-SHA256:AES128-SHA256:AES256-GCM-SHA384:AES256-SHA256';\n\t\tssl_prefer_server_ciphers on;\n\t{{ else if eq .ssl_policy \"AWS-TLS-1-1-2017-01\" }}\n\t\tssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA';\n\t\tssl_prefer_server_ciphers on;\n\t{{ else if eq .ssl_policy \"AWS-2016-08\" }}\n\t\tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA';\n\t\tssl_prefer_server_ciphers on;\n\t{{ else if eq .ssl_policy \"AWS-2015-05\" }}\n\t\tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:DES-CBC3-SHA';\n\t\tssl_prefer_server_ciphers on;\n\t{{ else if eq .ssl_policy \"AWS-2015-03\" }}\n\t\tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:DHE-DSS-AES128-SHA:DES-CBC3-SHA';\n\t\tssl_prefer_server_ciphers on;\n\t{{ else if eq .ssl_policy \"AWS-2015-02\" }}\n\t\tssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\n\t\tssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:DHE-DSS-AES128-SHA';\n\t\tssl_prefer_server_ciphers on;\n\t{{ end }}\n{{ end }}\n\n# If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the\n# scheme used to connect to this server\nmap $http_x_forwarded_proto $proxy_x_forwarded_proto {\n  default $http_x_forwarded_proto;\n  ''      $scheme;\n}\n\n# If we receive X-Forwarded-Port, pass it through; otherwise, pass along the\n# server port the client connected to\nmap $http_x_forwarded_port $proxy_x_forwarded_port {\n  default $http_x_forwarded_port;\n  ''      $server_port;\n}\n\n# If we receive Upgrade, set Connection to \"upgrade\"; otherwise, delete any\n# Connection header that may have been passed to this server\nmap $http_upgrade $proxy_connection {\n  default upgrade;\n  '' close;\n}\n\n# Apply fix for very long server names\nserver_names_hash_bucket_size 128;\n\n# Default dhparam\n{{ if (exists \"/etc/nginx/dhparam/dhparam.pem\") }}\nssl_dhparam /etc/nginx/dhparam/dhparam.pem;\n{{ end }}\n\n# Set appropriate X-Forwarded-Ssl header\nmap $scheme $proxy_x_forwarded_ssl {\n  default off;\n  https on;\n}\n\ngzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n\nlog_format vhost '$host $remote_addr - $remote_user [$time_local] '\n                 '\"$request\" $status $body_bytes_sent '\n                 '\"$http_referer\" \"$http_user_agent\"';\n\naccess_log off;\n\n{{/* Get the SSL_POLICY defined by this container, falling back to \"Mozilla-Intermediate\" */}}\n{{ $ssl_policy := or ($.Env.SSL_POLICY) \"Mozilla-Intermediate\" }}\n{{ template \"ssl_policy\" (dict \"ssl_policy\" $ssl_policy) }}\n\n{{ if $.Env.RESOLVERS }}\nresolver {{ $.Env.RESOLVERS }};\n{{ end }}\n\n{{ if (exists \"/etc/nginx/proxy.conf\") }}\ninclude /etc/nginx/proxy.conf;\n{{ else }}\n# HTTP 1.1 support\nproxy_http_version 1.1;\nproxy_buffering off;\nproxy_set_header Host $http_host;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection $proxy_connection;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;\nproxy_set_header X-Forwarded-Ssl $proxy_x_forwarded_ssl;\nproxy_set_header X-Forwarded-Port $proxy_x_forwarded_port;\n\n# Mitigate httpoxy attack (see README for details)\nproxy_set_header Proxy \"\";\n{{ end }}\n\n{{ $access_log := (or (and (not $.Env.DISABLE_ACCESS_LOGS) \"access_log /var/log/nginx/access.log vhost;\") \"\") }}\n\n{{ $enable_ipv6 := eq (or ($.Env.ENABLE_IPV6) \"\") \"true\" }}\nserver {\n\tserver_name _; # This is just an invalid value which will never trigger on a real hostname.\n\tlisten {{ $external_http_port }};\n\t{{ if $enable_ipv6 }}\n\tlisten [::]:{{ $external_http_port }};\n\t{{ end }}\n\t{{ $access_log }}\n\treturn 503;\n}\n\n{{ if (and (exists \"/etc/nginx/certs/default.crt\") (exists \"/etc/nginx/certs/default.key\")) }}\nserver {\n\tserver_name _; # This is just an invalid value which will never trigger on a real hostname.\n\tlisten {{ $external_https_port }} ssl http2;\n\t{{ if $enable_ipv6 }}\n\tlisten [::]:{{ $external_https_port }} ssl http2;\n\t{{ end }}\n\t{{ $access_log }}\n\treturn 503;\n\n\tssl_session_cache shared:SSL:50m;\n\tssl_session_tickets off;\n\tssl_certificate /etc/nginx/certs/default.crt;\n\tssl_certificate_key /etc/nginx/certs/default.key;\n}\n{{ end }}\n\n{{ range $host, $containers := groupByMulti $ \"Env.VIRTUAL_HOST\" \",\" }}\n\n{{ $host := trim $host }}\n{{ $is_regexp := hasPrefix \"~\" $host }}\n{{ $upstream_name := when $is_regexp (sha1 $host) $host }}\n\n# {{ $host }}\nupstream {{ $upstream_name }} {\n\n{{ range $container := $containers }}\n\t{{ $addrLen := len $container.Addresses }}\n\n\t{{ range $knownNetwork := $CurrentContainer.Networks }}\n\t\t{{ range $containerNetwork := $container.Networks }}\n\t\t\t{{ if (and (ne $containerNetwork.Name \"ingress\") (or (eq $knownNetwork.Name $containerNetwork.Name) (eq $knownNetwork.Name \"host\"))) }}\n\t\t\t\t## Can be connected with \"{{ $containerNetwork.Name }}\" network\n\n\t\t\t\t{{/* If only 1 port exposed, use that */}}\n\t\t\t\t{{ if eq $addrLen 1 }}\n\t\t\t\t\t{{ $address := index $container.Addresses 0 }}\n\t\t\t\t\t{{ template \"upstream\" (dict \"Container\" $container \"Address\" $address \"Network\" $containerNetwork) }}\n\t\t\t\t{{/* If more than one port exposed, use the one matching VIRTUAL_PORT env var, falling back to standard web port 80 */}}\n\t\t\t\t{{ else }}\n\t\t\t\t\t{{ $port := coalesce $container.Env.VIRTUAL_PORT \"80\" }}\n\t\t\t\t\t{{ $address := where $container.Addresses \"Port\" $port | first }}\n\t\t\t\t\t{{ template \"upstream\" (dict \"Container\" $container \"Address\" $address \"Network\" $containerNetwork) }}\n\t\t\t\t{{ end }}\n\t\t\t{{ else }}\n\t\t\t\t# Cannot connect to network of this container\n\t\t\t\tserver 127.0.0.1 down;\n\t\t\t{{ end }}\n\t\t{{ end }}\n\t{{ end }}\n{{ end }}\n}\n\n{{ $default_host := or ($.Env.DEFAULT_HOST) \"\" }}\n{{ $default_server := index (dict $host \"\" $default_host \"default_server\") $host }}\n\n{{/* Get the VIRTUAL_PROTO defined by containers w/ the same vhost, falling back to \"http\" */}}\n{{ $proto := trim (or (first (groupByKeys $containers \"Env.VIRTUAL_PROTO\")) \"http\") }}\n\n{{/* Get the NETWORK_ACCESS defined by containers w/ the same vhost, falling back to \"external\" */}}\n{{ $network_tag := or (first (groupByKeys $containers \"Env.NETWORK_ACCESS\")) \"external\" }}\n\n{{/* Get the HTTPS_METHOD defined by containers w/ the same vhost, falling back to \"redirect\" */}}\n{{ $https_method := or (first (groupByKeys $containers \"Env.HTTPS_METHOD\")) (or $.Env.HTTPS_METHOD \"redirect\") }}\n\n{{/* Get the SSL_POLICY defined by containers w/ the same vhost, falling back to empty string (use default) */}}\n{{ $ssl_policy := or (first (groupByKeys $containers \"Env.SSL_POLICY\")) \"\" }}\n\n{{/* Get the HSTS defined by containers w/ the same vhost, falling back to \"max-age=31536000\" */}}\n{{ $hsts := or (first (groupByKeys $containers \"Env.HSTS\")) (or $.Env.HSTS \"max-age=31536000\") }}\n\n{{/* Get the VIRTUAL_ROOT By containers w/ use fastcgi root */}}\n{{ $vhost_root := or (first (groupByKeys $containers \"Env.VIRTUAL_ROOT\")) \"/var/www/public\" }}\n\n\n{{/* Get the first cert name defined by containers w/ the same vhost */}}\n{{ $certName := (first (groupByKeys $containers \"Env.CERT_NAME\")) }}\n\n{{/* Get the best matching cert  by name for the vhost. */}}\n{{ $vhostCert := (closest (dir \"/etc/nginx/certs\") (printf \"%s.crt\" $host))}}\n\n{{/* vhostCert is actually a filename so remove any suffixes since they are added later */}}\n{{ $vhostCert := trimSuffix \".crt\" $vhostCert }}\n{{ $vhostCert := trimSuffix \".key\" $vhostCert }}\n\n{{/* Use the cert specified on the container or fallback to the best vhost match */}}\n{{ $cert := (coalesce $certName $vhostCert) }}\n\n{{ $is_https := (and (ne $https_method \"nohttps\") (ne $cert \"\") (exists (printf \"/etc/nginx/certs/%s.crt\" $cert)) (exists (printf \"/etc/nginx/certs/%s.key\" $cert))) }}\n\n{{ if $is_https }}\n\n{{ if eq $https_method \"redirect\" }}\nserver {\n\tserver_name {{ $host }};\n\tlisten {{ $external_http_port }} {{ $default_server }};\n\t{{ if $enable_ipv6 }}\n\tlisten [::]:{{ $external_http_port }} {{ $default_server }};\n\t{{ end }}\n\t{{ $access_log }}\n\t\n\t# Do not HTTPS redirect Let'sEncrypt ACME challenge\n\tlocation /.well-known/acme-challenge/ {\n\t\tauth_basic off;\n\t\tallow all;\n\t\troot /usr/share/nginx/html;\n\t\ttry_files $uri =404;\n\t\tbreak;\n\t}\n\t\n\tlocation / {\n\t\treturn 301 https://$host$request_uri;\n\t}\n}\n{{ end }}\n\nserver {\n\tserver_name {{ $host }};\n\tlisten {{ $external_https_port }} ssl http2 {{ $default_server }};\n\t{{ if $enable_ipv6 }}\n\tlisten [::]:{{ $external_https_port }} ssl http2 {{ $default_server }};\n\t{{ end }}\n\t{{ $access_log }}\n\n\t{{ if eq $network_tag \"internal\" }}\n\t# Only allow traffic from internal clients\n\tinclude /etc/nginx/network_internal.conf;\n\t{{ end }}\n\n\t{{ template \"ssl_policy\" (dict \"ssl_policy\" $ssl_policy) }}\n\n\tssl_session_timeout 5m;\n\tssl_session_cache shared:SSL:50m;\n\tssl_session_tickets off;\n\n\tssl_certificate /etc/nginx/certs/{{ (printf \"%s.crt\" $cert) }};\n\tssl_certificate_key /etc/nginx/certs/{{ (printf \"%s.key\" $cert) }};\n\n\t{{ if (exists (printf \"/etc/nginx/certs/%s.dhparam.pem\" $cert)) }}\n\tssl_dhparam {{ printf \"/etc/nginx/certs/%s.dhparam.pem\" $cert }};\n\t{{ end }}\n\n\t{{ if (exists (printf \"/etc/nginx/certs/%s.chain.pem\" $cert)) }}\n\tssl_stapling on;\n\tssl_stapling_verify on;\n\tssl_trusted_certificate {{ printf \"/etc/nginx/certs/%s.chain.pem\" $cert }};\n\t{{ end }}\n\n\t{{ if (not (or (eq $https_method \"noredirect\") (eq $hsts \"off\"))) }}\n\tadd_header Strict-Transport-Security \"{{ trim $hsts }}\" always;\n\t{{ end }}\n\n\t{{ if (exists (printf \"/etc/nginx/vhost.d/%s\" $host)) }}\n\tinclude {{ printf \"/etc/nginx/vhost.d/%s\" $host }};\n\t{{ else if (exists \"/etc/nginx/vhost.d/default\") }}\n\tinclude /etc/nginx/vhost.d/default;\n\t{{ end }}\n\n\tlocation / {\n\t\t{{ if eq $proto \"uwsgi\" }}\n\t\tinclude uwsgi_params;\n\t\tuwsgi_pass {{ trim $proto }}://{{ trim $upstream_name }};\n\t\t{{ else if eq $proto \"fastcgi\" }}\n\t\troot   {{ trim $vhost_root }};\n\t\tinclude fastcgi_params;\n\t\tfastcgi_pass {{ trim $upstream_name }};\n\t\t{{ else if eq $proto \"grpc\" }}\n\t\tgrpc_pass {{ trim $proto }}://{{ trim $upstream_name }};\n\t\t{{ else }}\n\t\tproxy_pass {{ trim $proto }}://{{ trim $upstream_name }};\n\t\t{{ end }}\n\n\t\t{{ if (exists (printf \"/etc/nginx/htpasswd/%s\" $host)) }}\n\t\tauth_basic\t\"Restricted {{ $host }}\";\n\t\tauth_basic_user_file\t{{ (printf \"/etc/nginx/htpasswd/%s\" $host) }};\n\t\t{{ end }}\n\t\t{{ if (exists (printf \"/etc/nginx/vhost.d/%s_location\" $host)) }}\n\t\tinclude {{ printf \"/etc/nginx/vhost.d/%s_location\" $host}};\n\t\t{{ else if (exists \"/etc/nginx/vhost.d/default_location\") }}\n\t\tinclude /etc/nginx/vhost.d/default_location;\n\t\t{{ end }}\n\t}\n}\n\n{{ end }}\n\n{{ if or (not $is_https) (eq $https_method \"noredirect\") }}\n\nserver {\n\tserver_name {{ $host }};\n\tlisten {{ $external_http_port }} {{ $default_server }};\n\t{{ if $enable_ipv6 }}\n\tlisten [::]:80 {{ $default_server }};\n\t{{ end }}\n\t{{ $access_log }}\n\n\t{{ if eq $network_tag \"internal\" }}\n\t# Only allow traffic from internal clients\n\tinclude /etc/nginx/network_internal.conf;\n\t{{ end }}\n\n\t{{ if (exists (printf \"/etc/nginx/vhost.d/%s\" $host)) }}\n\tinclude {{ printf \"/etc/nginx/vhost.d/%s\" $host }};\n\t{{ else if (exists \"/etc/nginx/vhost.d/default\") }}\n\tinclude /etc/nginx/vhost.d/default;\n\t{{ end }}\n\n\tlocation / {\n\t\t{{ if eq $proto \"uwsgi\" }}\n\t\tinclude uwsgi_params;\n\t\tuwsgi_pass {{ trim $proto }}://{{ trim $upstream_name }};\n\t\t{{ else if eq $proto \"fastcgi\" }}\n\t\troot   {{ trim $vhost_root }};\n\t\tinclude fastcgi_params;\n\t\tfastcgi_pass {{ trim $upstream_name }};\n\t\t{{ else if eq $proto \"grpc\" }}\n\t\tgrpc_pass {{ trim $proto }}://{{ trim $upstream_name }};\n\t\t{{ else }}\n\t\tproxy_pass {{ trim $proto }}://{{ trim $upstream_name }};\n\t\t{{ end }}\n\t\t{{ if (exists (printf \"/etc/nginx/htpasswd/%s\" $host)) }}\n\t\tauth_basic\t\"Restricted {{ $host }}\";\n\t\tauth_basic_user_file\t{{ (printf \"/etc/nginx/htpasswd/%s\" $host) }};\n\t\t{{ end }}\n\t\t{{ if (exists (printf \"/etc/nginx/vhost.d/%s_location\" $host)) }}\n\t\tinclude {{ printf \"/etc/nginx/vhost.d/%s_location\" $host}};\n\t\t{{ else if (exists \"/etc/nginx/vhost.d/default_location\") }}\n\t\tinclude /etc/nginx/vhost.d/default_location;\n\t\t{{ end }}\n\t}\n}\n\n{{ if (and (not $is_https) (exists \"/etc/nginx/certs/default.crt\") (exists \"/etc/nginx/certs/default.key\")) }}\nserver {\n\tserver_name {{ $host }};\n\tlisten {{ $external_https_port }} ssl http2 {{ $default_server }};\n\t{{ if $enable_ipv6 }}\n\tlisten [::]:{{ $external_https_port }} ssl http2 {{ $default_server }};\n\t{{ end }}\n\t{{ $access_log }}\n\treturn 500;\n\n\tssl_certificate /etc/nginx/certs/default.crt;\n\tssl_certificate_key /etc/nginx/certs/default.key;\n}\n{{ end }}\n\n{{ end }}\n{{ end }}\n"
        }
      ]
    }
  ]
}