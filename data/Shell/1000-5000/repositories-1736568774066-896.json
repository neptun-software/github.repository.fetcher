{
  "metadata": {
    "timestamp": 1736568774066,
    "page": 896,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "termux/termux-api-package",
      "stars": 1107,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "termux-api\n*~\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.3046875,
          "content": "cmake_minimum_required(VERSION 3.0.0)\nproject(termux-api)\ninclude(GNUInstallDirs)\n\nset(TERMUX_PREFIX ${CMAKE_INSTALL_PREFIX})\n\nadd_library(termux-api SHARED termux-api.c)\nadd_library(termux-api-static STATIC termux-api.c)\nset_target_properties(termux-api-static PROPERTIES OUTPUT_NAME termux-api)\n\nadd_executable(termux-api-broadcast termux-api-broadcast.c)\ntarget_link_libraries(termux-api-broadcast termux-api-static)\n\n# TODO: get list through regex or similar\nset(script_files\n  scripts/termux-api-start\n  scripts/termux-api-stop\n  scripts/termux-audio-info\n  scripts/termux-battery-status\n  scripts/termux-brightness\n  scripts/termux-call-log\n  scripts/termux-camera-info\n  scripts/termux-camera-photo\n  scripts/termux-clipboard-get\n  scripts/termux-clipboard-set\n  scripts/termux-contact-list\n  scripts/termux-dialog\n  scripts/termux-download\n  scripts/termux-fingerprint\n  scripts/termux-infrared-frequencies\n  scripts/termux-infrared-transmit\n  scripts/termux-job-scheduler\n  scripts/termux-keystore\n  scripts/termux-location\n  scripts/termux-media-player\n  scripts/termux-media-scan\n  scripts/termux-microphone-record\n  scripts/termux-nfc\n  scripts/termux-notification\n  scripts/termux-notification-channel\n  scripts/termux-notification-list\n  scripts/termux-notification-remove\n  scripts/termux-saf-create\n  scripts/termux-saf-dirs\n  scripts/termux-saf-ls\n  scripts/termux-saf-managedir\n  scripts/termux-saf-mkdir\n  scripts/termux-saf-read\n  scripts/termux-saf-rm\n  scripts/termux-saf-stat\n  scripts/termux-saf-write\n  scripts/termux-sensor\n  scripts/termux-share\n  scripts/termux-sms-inbox\n  scripts/termux-sms-list\n  scripts/termux-sms-send\n  scripts/termux-speech-to-text\n  scripts/termux-storage-get\n  scripts/termux-telephony-call\n  scripts/termux-telephony-cellinfo\n  scripts/termux-telephony-deviceinfo\n  scripts/termux-toast\n  scripts/termux-torch\n  scripts/termux-tts-engines\n  scripts/termux-tts-speak\n  scripts/termux-usb\n  scripts/termux-vibrate\n  scripts/termux-volume\n  scripts/termux-wallpaper\n  scripts/termux-wifi-connectioninfo\n  scripts/termux-wifi-enable\n  scripts/termux-wifi-scaninfo\n)\n\nmake_directory(scripts)\nforeach(file ${script_files})\n  configure_file(\n    ${CMAKE_CURRENT_SOURCE_DIR}/${file}.in\n    ${file} @ONLY\n  )\nendforeach()\n\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/termux-callback.in\n  termux-callback @ONLY\n)\n\ninstall(\n  FILES ${CMAKE_BINARY_DIR}/termux-api-broadcast\n  DESTINATION ${CMAKE_INSTALL_PREFIX}/libexec\n  PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE\n    GROUP_READ GROUP_EXECUTE\n    WORLD_READ WORLD_EXECUTE\n)\n\n# Create a symlink for termux-api-broadcast->termux-api for backwards\n# compatibility\nINSTALL(CODE \"execute_process( \\\n  COMMAND ${CMAKE_COMMAND} -E create_symlink \\\n  termux-api-broadcast \\\n  ${CMAKE_INSTALL_PREFIX}/libexec/termux-api \\\n  )\"\n)\n\ninstall(\n  FILES\n    ${CMAKE_BINARY_DIR}/libtermux-api.so\n    ${CMAKE_BINARY_DIR}/libtermux-api.a\n  TYPE LIB\n)\n\ninstall(\n  FILES ${CMAKE_CURRENT_SOURCE_DIR}/termux-api.h\n  TYPE INCLUDE\n)\n\nforeach(file ${script_files})\n  install(\n    FILES ${CMAKE_BINARY_DIR}/${file}\n    TYPE BIN\n    PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE\n  )\nendforeach()\n\ninstall(\n  FILES ${CMAKE_BINARY_DIR}/termux-callback\n  DESTINATION ${CMAKE_INSTALL_PREFIX}/libexec\n  PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE\n    GROUP_READ GROUP_EXECUTE\n    WORLD_READ WORLD_EXECUTE\n)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2017-2021 Termux\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.142578125,
          "content": "# termux-api-package\nTermux package containing scripts to call exposed API methods in the [Termux:API](https://github.com/termux/termux-api) app.\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "termux-api-broadcast.c",
          "type": "blob",
          "size": 0.70703125,
          "content": "/* termux-api.c - helper binary for calling termux api classes\n * Usage: termux-api ${API_METHOD} ${ADDITIONAL_FLAGS}\n * This executes\n *   am broadcast com.termux.api/.TermuxApiReceiver \\\n *   --es socket_input ${INPUT_SOCKET} \\\n *   --es socket_output ${OUTPUT_SOCKET} \\\n *   --es api_method ${API_METHOD} \\\n *   ${ADDITIONAL_FLAGS}\n * where ${INPUT_SOCKET} and ${OUTPUT_SOCKET} are addresses to linux\n * abstract namespace sockets, used to pass on stdin to the java\n * implementation and pass back output from java to stdout.\n */\n\n#include \"termux-api.h\"\n\nint main(int argc, char** argv) {\n    /* Run the api command */\n    int fd = run_api_command(argc, argv);\n\n    if (fd != -1) { exec_callback(fd); }\n\n    return 0;\n}\n"
        },
        {
          "name": "termux-api.c",
          "type": "blob",
          "size": 16.4951171875,
          "content": "#define _POSIX_SOURCE\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/endian.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <time.h>\n#include <unistd.h>\n\n#ifdef __ANDROID__\n#include <android/api-level.h>\n#endif\n\n#include \"termux-api.h\"\n\n#define TERMUX_API_PACKAGE_VERSION \"0.58.0\"\n\n#ifndef PREFIX\n# define PREFIX \"/data/data/com.termux/files/usr\"\n#endif\n\n#define LISTEN_SOCKET_ADDRESS \"com.termux.api://listen\"\n\n/* passes the arguments to the plugin via the unix socket, falling\n * back to exec_am_broadcast() if that doesn't work\n */\n_Noreturn void contact_plugin(int argc, char** argv,\n                                 char* input_address_string,\n                                 char* output_address_string)\n{\n    // Redirect stdout to /dev/null (but leave stderr open):\n    close(STDOUT_FILENO);\n    open(\"/dev/null\", O_RDONLY);\n    // Close stdin:\n    close(STDIN_FILENO);\n\n    // ignore SIGPIPE, so am will be called when the connection is closed unexpectedly\n    struct sigaction sigpipe_action = {\n        .sa_handler = SIG_IGN,\n        .sa_flags = 0\n    };\n    sigaction(SIGPIPE, &sigpipe_action, NULL);\n\n    // Try to connect over the listen socket first if running on Android `< 14`.\n    // On Android `>= 14`, if termux-api app process was started previously\n    // and it started the socket server, but later Android froze the\n    // process, the socket will still be connectable, but no response\n    // will be received until the app process is unfrozen agin and\n    // `read()` call below will hang indefinitely until that happens,\n    // so use legacy `am broadcast` command, which will also unfreeze\n    // the app process to deliver the intent.\n    // - https://github.com/termux/termux-api/issues/638#issuecomment-1813233924\n    int listenfd = -1;\n    #ifdef __ANDROID__\n        if (android_get_device_api_level() < 34) {\n            listenfd = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);\n        }\n    #endif\n    if (listenfd != -1) {\n        struct sockaddr_un listen_addr = { .sun_family = AF_UNIX };\n        memcpy(listen_addr.sun_path+1, LISTEN_SOCKET_ADDRESS, strlen(LISTEN_SOCKET_ADDRESS));\n        if (connect(listenfd, (struct sockaddr*) &listen_addr, sizeof(sa_family_t) + strlen(LISTEN_SOCKET_ADDRESS) + 1) == 0) {\n            socklen_t optlen = sizeof(struct ucred);\n            // check the uid to see if the socket is actually provided by the plugin\n            struct ucred cred;\n            if (getsockopt(listenfd, SOL_SOCKET, SO_PEERCRED, &cred, &optlen) == 0 && cred.uid == getuid()) {\n\n                const char insock_str[] = \"--es socket_input \\\"\";\n                const char outsock_str[] = \"--es socket_output \\\"\";\n                const char method_str[] = \"--es api_method \\\"\";\n\n                int len = 0;\n                len += sizeof(insock_str)-1 + strlen(output_address_string)+2;\n                len += sizeof(outsock_str)-1 + strlen(input_address_string)+2;\n                len += sizeof(method_str)-1 + strlen(argv[1])+2;\n                for (int i = 2; i<argc; i++) {\n                    len += strlen(argv[i])+1;\n                    if (strcmp(argv[i], \"--es\") == 0 || strcmp(argv[i], \"-e\") == 0 || strcmp(argv[i], \"--esa\") == 0) {\n                        len += 2; // the string extra has to be enclosed in \"\n                    }\n                    for (int a = 0; a<strlen(argv[i]); a++) {\n                        if (argv[i][a] == '\"') {\n                            len += 1; // \" has to be escaped, so one character more.\n                            /* This assumes \" is only present in\n                            string extra arguments, but that is\n                            probably an acceptable assumption to\n                            make */\n                        }\n                    }\n                }\n\n                char* buffer = malloc(len);\n\n                int offset = 0;\n                memcpy(buffer+offset, insock_str, sizeof(insock_str)-1);\n                offset += sizeof(insock_str)-1;\n\n                memcpy(buffer+offset, output_address_string, strlen(output_address_string));\n                offset += strlen(output_address_string);\n\n                buffer[offset] = '\"';\n                offset++;\n                buffer[offset] = ' ';\n                offset++;\n\n                memcpy(buffer+offset, outsock_str, sizeof(outsock_str)-1);\n                offset += sizeof(outsock_str)-1;\n\n                memcpy(buffer+offset, input_address_string, strlen(input_address_string));\n                offset += strlen(input_address_string);\n\n                buffer[offset] = '\"';\n                offset++;\n                buffer[offset] = ' ';\n                offset++;\n\n                memcpy(buffer+offset, method_str, sizeof(method_str)-1);\n                offset += sizeof(method_str)-1;\n\n                memcpy(buffer+offset, argv[1], strlen(argv[1]));\n                offset += strlen(argv[1]);\n\n                buffer[offset] = '\"';\n                offset++;\n                buffer[offset] = ' ';\n                offset++;\n\n                for (int i = 2; i<argc; i++) {\n                    if (strcmp(argv[i], \"--es\") == 0 || strcmp(argv[i], \"-e\") == 0 || strcmp(argv[i], \"--esa\") == 0) {\n                        memcpy(buffer+offset, argv[i], strlen(argv[i]));\n                        offset += strlen(argv[i]);\n                        buffer[offset] = ' ';\n                        offset++;\n                        i++;\n                        if (i < argc) {\n                            memcpy(buffer+offset, argv[i], strlen(argv[i]));\n                            offset += strlen(argv[i]);\n                            buffer[offset] = ' ';\n                            offset++;\n                        }\n                        i++;\n                        if (i < argc) {\n                            buffer[offset] = '\"';\n                            offset++;\n                            for (int a = 0; a<strlen(argv[i]); a++) {\n                                if (argv[i][a] == '\"') {\n                                    buffer[offset] = '\\\\';\n                                    offset++;\n                                    buffer[offset] = '\"';\n                                    offset++;\n                                } else {\n                                    buffer[offset] = argv[i][a];\n                                    offset++;\n                                }\n                            }\n                            buffer[offset] = '\"';\n                            offset++;\n                            buffer[offset] = ' ';\n                            offset++;\n                        }\n                    } else {\n                        memcpy(buffer+offset, argv[i], strlen(argv[i]));\n                        offset += strlen(argv[i]);\n                        buffer[offset] = ' ';\n                        offset++;\n                    }\n                }\n\n                int netlen = htons(len);\n\n                bool err = false;\n                // transmit the size\n                int totransmit = 2;\n                void* transmit = &netlen;\n                while (totransmit > 0) {\n                    int ret = send(listenfd, transmit, totransmit, 0);\n                    if (ret == -1) {\n                        err = true;\n                        break;\n                    }\n                    totransmit -= ret;\n                }\n\n                // transmit the argument list\n                if (! err) {\n                    totransmit = len;\n                    transmit = buffer;\n                    while (totransmit > 0) {\n                        int ret = send(listenfd, transmit, totransmit, 0);\n                        if (ret == -1) {\n                            err = true;\n                            break;\n                        }\n                        totransmit -= ret;\n                    }\n                }\n\n                if (! err) {\n                    char readbuffer[100];\n                    int ret;\n                    bool first = true;\n                    err = true;\n                    while ((ret = read(listenfd, readbuffer, 99)) > 0) {\n                        // if a single null byte is received as the first message, the call was successful\n                        if (ret == 1 && readbuffer[0] == 0 && first) {\n                            err = false;\n                            break;\n                        }\n                        // otherwise it's an error message\n                        readbuffer[ret] = '\\0';\n                        // printing out the error is good for debug purposes, but feel free to disable this\n                        fprintf(stderr, \"%s\", readbuffer);\n                        fflush(stderr);\n                        first = false;\n                    }\n                }\n\n                // if everything went well, there is no need to call am\n                if (! err) {\n                    exit(0);\n                }\n            }\n        }\n    }\n\n    exec_am_broadcast(argc, argv, input_address_string, output_address_string);\n}\n\n// Function which execs \"am broadcast ..\".\n_Noreturn void exec_am_broadcast(int argc, char** argv,\n                                 char* input_address_string,\n                                 char* output_address_string)\n{\n    // Redirect stdout to /dev/null (but leave stderr open):\n    close(STDOUT_FILENO);\n    open(\"/dev/null\", O_RDONLY);\n    // Close stdin:\n    close(STDIN_FILENO);\n\n    int const extra_args = 15; // Including ending NULL.\n    char** child_argv = malloc((sizeof(char*)) * (argc + extra_args));\n\n    child_argv[0] = \"am\";\n    child_argv[1] = \"broadcast\";\n    child_argv[2] = \"--user\";\n    child_argv[3] = \"0\";\n    child_argv[4] = \"-n\";\n    child_argv[5] = \"com.termux.api/.TermuxApiReceiver\";\n    child_argv[6] = \"--es\";\n    // Input/output are reversed for the java process (our output is its input):\n    child_argv[7] = \"socket_input\";\n    child_argv[8] = output_address_string;\n    child_argv[9] = \"--es\";\n    child_argv[10] = \"socket_output\";\n    child_argv[11] = input_address_string;\n    child_argv[12] = \"--es\";\n    child_argv[13] = \"api_method\";\n    child_argv[14] = argv[1];\n\n    // Copy the remaining arguments -2 for first binary and second api name:\n    memcpy(child_argv + extra_args, argv + 2, (argc-1) * sizeof(char*));\n\n    // End with NULL:\n    child_argv[argc + extra_args - 1] = NULL;\n\n    // Use an a executable taking care of PATH and LD_LIBRARY_PATH:\n    execv(PREFIX \"/bin/am\", child_argv);\n\n    perror(\"execv(\\\"\" PREFIX \"/bin/am\\\")\");\n    exit(1);\n}\n\n_Noreturn void exec_callback(int fd)\n{\n    char *fds;\n    if (asprintf(&fds, \"%d\", fd) == -1)\n        perror(\"asprintf\");\n\n    /* TERMUX_EXPORT_FD and TERMUX_USB_FD are (currently) specific for\n       termux-usb, so there's some room for improvement here (this\n       function should be generic) */\n    char errmsg[256];\n    char *export_to_env = getenv(\"TERMUX_EXPORT_FD\");\n    if (export_to_env && strncmp(export_to_env, \"true\", 4) == 0) {\n        if (setenv(\"TERMUX_USB_FD\", fds, true) == -1)\n            perror(\"setenv\");\n        execl(PREFIX \"/libexec/termux-callback\", \"termux-callback\", NULL);\n        sprintf(errmsg, \"execl(\\\"\" PREFIX \"/libexec/termux-callback\\\")\");\n    } else {\n        execl(PREFIX \"/libexec/termux-callback\", \"termux-callback\", fds, NULL);\n        sprintf(errmsg, \"execl(\\\"\" PREFIX \"/libexec/termux-callback\\\", %s)\", fds);\n    }\n    perror(errmsg);\n    exit(1);\n}\n\nvoid generate_uuid(char* str) {\n    sprintf(str, \"%x%x-%x-%x-%x-%x%x%x\",\n            /* 64-bit Hex number */\n            arc4random(), arc4random(),\n            /* 32-bit Hex number */\n            (uint32_t) getpid(),\n            /* 32-bit Hex number of the form 4xxx (4 is the UUID version) */\n            ((arc4random() & 0x0fff) | 0x4000),\n            /* 32-bit Hex number in the range [0x8000, 0xbfff] */\n            arc4random() % 0x3fff + 0x8000,\n            /*  96-bit Hex number */\n            arc4random(), arc4random(), arc4random());\n}\n\n// Thread function which reads from stdin and writes to socket.\nvoid* transmit_stdin_to_socket(void* arg) {\n    int output_server_socket = *((int*) arg);\n    struct sockaddr_un remote_addr;\n    socklen_t addrlen = sizeof(remote_addr);\n    int output_client_socket = accept(output_server_socket,\n                                      (struct sockaddr*) &remote_addr,\n                                      &addrlen);\n\n    ssize_t len;\n    char buffer[1024];\n    while (len = read(STDIN_FILENO, &buffer, sizeof(buffer)), len > 0) {\n        if (write(output_client_socket, buffer, len) < 0) break;\n    }\n    // Close output socket on end of input:\n    close(output_client_socket);\n    return NULL;\n}\n\n// Main thread function which reads from input socket and writes to stdout.\nint transmit_socket_to_stdout(int input_socket_fd) {\n    ssize_t len;\n    char buffer[1024];\n    char cbuf[256];\n    struct iovec io = { .iov_base = buffer, .iov_len = sizeof(buffer) };\n    struct msghdr msg = { 0 };\n    int fd = -1;  // An optional file descriptor received through the socket\n    msg.msg_iov = &io;\n    msg.msg_iovlen = 1;\n    msg.msg_control = cbuf;\n    msg.msg_controllen = sizeof(cbuf);\n    while ((len = recvmsg(input_socket_fd, &msg, 0)) > 0) {\n        struct cmsghdr * cmsg = CMSG_FIRSTHDR(&msg);\n        if (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {\n            if (cmsg->cmsg_type == SCM_RIGHTS) {\n                fd = *((int *) CMSG_DATA(cmsg));\n            }\n        }\n        // A file descriptor must be accompanied by a non-empty message,\n        // so we use \"@\" when we don't want any output.\n        if (fd != -1 && len == 1 && buffer[0] == '@') { len = 0; }\n        write(STDOUT_FILENO, buffer, len);\n        msg.msg_controllen = sizeof(cbuf);\n    }\n    if (len < 0) perror(\"recvmsg()\");\n    return fd;\n}\n\nint run_api_command(int argc, char **argv) {\n    // If only `--version` argument is passed\n    if (argc == 2 && strcmp(argv[1], \"--version\") == 0) {\n        fprintf(stdout, \"%s\\n\", TERMUX_API_PACKAGE_VERSION);\n        fflush(stdout);\n        exit(0);\n    }\n\n    // Do not transform children into zombies when they terminate:\n    struct sigaction sigchld_action = {\n        .sa_handler = SIG_DFL,\n        .sa_flags = SA_RESTART | SA_NOCLDSTOP | SA_NOCLDWAIT\n    };\n    sigaction(SIGCHLD, &sigchld_action, NULL);\n\n    char input_addr_str[100];  // This program reads from it.\n    char output_addr_str[100]; // This program writes to it.\n\n    generate_uuid(input_addr_str);\n    generate_uuid(output_addr_str);\n\n    struct sockaddr_un input_addr = { .sun_family = AF_UNIX };\n    struct sockaddr_un output_addr = { .sun_family = AF_UNIX };\n    // Leave struct sockaddr_un.sun_path[0] as 0 and use the UUID\n    // string as abstract linux namespace:\n    strncpy(&input_addr.sun_path[1], input_addr_str, strlen(input_addr_str));\n    strncpy(&output_addr.sun_path[1], output_addr_str, strlen(output_addr_str));\n\n    int input_server_socket = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);\n    if (input_server_socket == -1) {\n        perror(\"socket()\");\n        return -1;\n    }\n    int output_server_socket = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);\n    if (output_server_socket == -1) {\n        perror(\"socket()\");\n        return -1;\n    }\n\n    int ret;\n    ret = bind(input_server_socket, (struct sockaddr*) &input_addr,\n               sizeof(sa_family_t) + strlen(input_addr_str) + 1);\n    if (ret == -1) {\n        perror(\"bind(input)\");\n        return ret;\n    }\n\n    ret = bind(output_server_socket, (struct sockaddr*) &output_addr,\n               sizeof(sa_family_t) + strlen(output_addr_str) + 1);\n    if (ret == -1) {\n        perror(\"bind(output)\");\n        return ret;\n    }\n\n    if (listen(input_server_socket, 1) == -1) {\n        perror(\"listen()\");\n        return -1;\n    }\n\n    if (listen(output_server_socket, 1) == -1) {\n        perror(\"listen()\");\n        return -1;\n    }\n\n    pid_t fork_result = fork();\n    if (fork_result == -1) {\n        perror(\"fork()\");\n        return -1;\n    } else if (fork_result == 0)\n        contact_plugin(argc, argv, input_addr_str, output_addr_str);\n\n    struct sockaddr_un remote_addr;\n    socklen_t addrlen = sizeof(remote_addr);\n    int input_client_socket = accept(input_server_socket,\n                                     (struct sockaddr*) &remote_addr,\n                                     &addrlen);\n\n    pthread_t transmit_thread;\n    pthread_create(&transmit_thread, NULL, transmit_stdin_to_socket,\n                   &output_server_socket);\n\n    /* Device has been opened, time to actually get the fd */\n    int fd = transmit_socket_to_stdout(input_client_socket);\n    close(input_client_socket);\n    return fd;\n}\n"
        },
        {
          "name": "termux-api.h",
          "type": "blob",
          "size": 0.451171875,
          "content": "#ifndef TERMUX_API_H\n#define TERMUX_API_H\n\n#include <stdlib.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n_Noreturn void exec_am_broadcast(int, char**, char*, char*);\n_Noreturn void contact_plugin(int, char**, char*, char*);\n_Noreturn void exec_callback(int);\nvoid generate_uuid(char*);\nvoid* transmit_stdin_to_socket(void*);\nint transmit_socket_to_stdout(int);\nint run_api_command(int, char**);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif /* TERMUX_API_H */\n"
        },
        {
          "name": "termux-callback.in",
          "type": "blob",
          "size": 0.0576171875,
          "content": "#!@TERMUX_PREFIX@/bin/bash\nset -e -u\n$TERMUX_CALLBACK \"$@\"\n"
        }
      ]
    }
  ]
}