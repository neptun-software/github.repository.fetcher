{
  "metadata": {
    "timestamp": 1736568537613,
    "page": 548,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kerl/kerl",
      "stars": 1605,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0029296875,
          "content": "*~\n"
        },
        {
          "name": ".markdownlint.yml",
          "type": "blob",
          "size": 0.107421875,
          "content": "---\ndefault: true\nMD013:\n  line_length: 100\nMD014: false  # commands-show-output\nMD024:\n  siblings_only: true\n"
        },
        {
          "name": ".yamllint.yml",
          "type": "blob",
          "size": 0.0546875,
          "content": "---\nextends: default\nrules:\n  line-length:\n    max: 100\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 10.3056640625,
          "content": "<!-- markdownlint-disable MD007 # ul-indent -->\n# Changelog\n\n21 Sep 2024 - 4.3.0\n\n  - Fix `kerl upgrade` example on `README.md` (#541)\n  - Make Bash and Zsh completions support custom `KERL_BASE_DIR` (#544)\n  - Add fish shell completion support (#543)\n  - Stop depending on (or proposing, in probes) `automake` (#547)\n\n3 Jul 2024 - 4.2.0\n\n  - Allow specifying Git clone depth on `kerl build git ...` (#527)\n  - On macOS, use OpenSSL 1.1 if Erlang/OTP is pre-25.1, and OpenSSL 3.0 otherwise (#528)\n  - Fix warning on Fedora's missing package `gcc-c++` by (#532)\n  - Have shared code reusable (on the package warning list) (#534)\n  - Fix broken documentation links (#533)\n  - `kerl upgrade` always \"upgrading\" (#539)\n\n21 May 2024 - 4.1.1\n\n  - KERL_DOC_TARGETS needs to be quoted (#520)\n  - Probe fails for `libncurses5-dev` (#521)\n  - Standardize on `libncurses-dev` for `dpkg` package probing (#523)\n  - Prepare for OTP 27 (#507)\n\n3 March 2024 - 4.1.0\n\n  - Ease log and output code maintenance (#476)\n  - Fix as per Lint workflow (#477)\n  - Update README.md (#478)\n  - Add lock/unlock for build git, build, and install (#479)\n  - Fix `is_older_than_x_days`: use `find` instead of `stat` (#481)\n  - Simplify code maintenance (#480)\n  - Fix/improve output on errors (#482)\n  - Fix typos in security policy (#486)\n  - Fix awk script (#484)\n  - Warn on stale build due to kernel changed (#485)\n  - Fix verification for `$#` in `kerl delete build` (#489)\n  - Minor fixes around `delete installation` (#488)\n  - Fix/complement `cleanup` (#492)\n  - Be more specific in the packages we suggest for installation (#491)\n  - Fix broken Zsh completion scripts (#497)\n  - `brew` in CI: don't install updates \"just because\" (#499)\n  - Attempt auto-cleanup of `otp_builds` and `otp_installations`, at every run (#490)\n  - Make Pop!_OS a `kerl`-known Linux distro, for package probing (#505)\n  - Prevent GitHub CI warnings on \"Node.js 16 actions are deprecated\" (#506)\n  - Fix shell completion scripts (#501)\n  - Extend `KERL_AUTOCLEAN` to Git-based builds (#511)\n  - Have CI run on pull request, workflow dispatch and push to main (#516)\n  - Ignore ownership and permissions of files in OTP source archives (#515)\n  \n12 October 2023 - 4.0.0\n\n  - Fix fish shell deactivate (#460)\n  - Fix sh shell deactivate (#461)\n  - Shellcheck and shfmt completion scripts (#463)\n  - Shellcheck and shfmt generated files (#464)\n  - Trim kerl releases output **Breaking change** (#465)\n  - Bury dead code **Breaking change** (#466)\n    patches and code for very old OTP releases have been removed - if you need this,\n    please use 3.1.0 or earlier.\n  - Fix kerl remote command (#469)\n  - Fix csh (de)activate (#470)\n  - Fix no whitespace before ps output (#474)\n  - Completely overhaul build pre-requisite package tests **Breaking change** (#471)\n    If your Linux isn't supported, please submit a PR\n\n9 September 2023 - 3.1.0\n\n  - Respect markdownlint (#446)\n  - Huge maintenance update/cleanup (#449)\n  - Add a new `emit-activate` command to emit activation/deactivation artifacts (#452)\n  - Warn on activation script staleness (#454)\n  - Use -o exportall to write less code (#456)\n  - Handle REBAR_CACHE_DIR (#457)\n\n11 May 2023 - 3.0.0\n\n  - Fix shellcheck issues (#442)\n  - For CI, force install OpenSSL 1.1 on Ubuntu 22 for older OTPs (#443, #444)\n  - NEW FEATURE: a single build install step! (#419)\n  - REMOVED: docsh functionality has been removed, as it no longer needed\n             for newer OTPs (#445)\n\n18 April 2023 - 2.6.0\n\n  - Make logging less verbose (#417)\n  - Use Github Actions instead of CircleCI (#423)\n  - Fix broken CI images on README (#424)\n  - Fix broken version output (#425)\n  - Add macOS to CI matrix (#427)\n  - Fix error when running in a container (#402)\n  - Use Ubuntu 22.04, drop Ubuntu 20.04 for CI (#429)\n  - Add Ventura to version bypass for macOS (#433)\n  - If a patch has already been applied, do not apply it again (#437)\n  - Fix shellcheck for unreachable code (#438)\n  - On build failures, autoclean build art{e|i}facts (#410)\n\n18 June 2022 - 2.5.1\n\n  - Many shellcheck, ci and bugfixes (#414)\n\n31 May 2022 - 2.5.0\n\n  - Add a way to specify a debug/release target build (#411)\n\n27 April 2022 - 2.4.0\n\n  - Handle a failed github retrieval better (#408)\n  - Colorize kerl output (if available) (#409)\n\n13 April 2022 - 2.3.0\n\n  - Fix build of older OTPs on macOS Monterey (#397)\n  - Separate info and error messages onto stdout/stderr (#401 - rebased as #403)\n  - Add a new `upgrade` command to check, download and install kerl upgrades (#400)\n\n7 January 2022 - 2.2.4\n\n  - Fix fish activation error (#392)\n  - Fix build issue on macOS Monterey (#395)\n\n27 November 2021 - 2.2.3\n\n  - Use `-path` in find to be more POSIX friendly (#388)\n  - Do not let default values override config values (#389)\n\n1 November 2021 - 2.2.2\n\n  - Enable autoconf when patches are applied on macOS; fixes #384 (#385)\n\n8 October 2021 - 2.2.1\n\n  - Fix downloads for certain OTP releases (#383)\n  - Pin openssl to version 1.1 (#380)\n\n17 September 2021 - 2.2.0\n\n  - Download prebuilt binaries (if available) from github to speed builds (#376)\n\n3 June 2021 - 2.1.2\n\n  - Do not munge `LD_` flags on macOS any more (#372)\n\n22 March 2021 - 2.1.1\n\n  - grep `with-ssl` (#367)\n  - Add a `\\` to commands to bypass any shell alias (#363)\n  - Enable multiple doc targets (#362)\n\n26 January 2021 - 2.1.0\n\n  - Fix Big Sur build issues again (#358)\n  - Automate building a debug Erlang (#360)\n\n10 December 2020 - 2.0.2\n\n  - Fix Big Sur build issue (#356) (see also [OTP #2871](https://github.com/erlang/otp/pull/2871))\n\n20 October 2020 - 2.0.1\n\n  - Use `-path` in `find` (#345)\n  - Redownload a tarball if it's corrupted (#348)\n  - Update to build on Catalina and Big Sur (#355)\n\n4 May 2020 - 2.0.0\n\n  - **Important**: possible breaking change - releases are now fetched\n                   through github tags by default (#277)\n  - Fix documentation building, especially for inline REPL help (#336)\n  - Fix builds on Catalina (#337, #339) - if you are on Catalina and\n    need to build older Erlangs, you should downgrade your XCode to an\n    earlier version.\n\n3 March 2020 - 1.8.7\n\n  - Implement version sorting (#319)\n  - Fix CI breakage (#327)\n  - Include `erl_call` in the path (#330)\n\n16 September 2019 - 1.8.6\n\n  - Remove almost all special cases for older macOS releases\n\n25 September 2018 - 1.8.5\n\n  - Support Mojave builds (#301)\n  - Disable SC2207 for Bash completion (#296)\n\n3 August 2018 - 1.8.4\n\n  - Support docsh 0.6.1 (#290)\n  - Update docs about KERL_INSTALL_MANPAGES & HTML_DOCS (#292)\n  - Fix bash completion for Bash 3 (#295)\n\n3 July 2018 - 1.8.3\n\n  - Update testing to include OTP 21 (#286)\n  - Fix an issue affecting CD\\_PATH during builds (#284)\n\n5 March 2018 - 1.8.2\n\n  - Apply zlib patch when building OTP 17-19. (#258)\n  - Add CircleCI (#246)\n  - Fix empty package name warning (#245)\n\n13 November 2017 - 1.8.1\n\n  - Fix removing an installation by its name. (#244)\n\n8 November 2017 - 1.8.0\n\n  - Include support for installing and managing docsh (#213)\n  - Fix a function name typo (#241)\n\n23 October 2017 - 1.7.0\n\n  - Suggest the proper activation script based on the shell you're using (#225)\n  - Automatically turn on built-in shell history when using an OTP release >=\n    20 (#214)\n  - Warn when a Linux does not appear to have a pre-requisite library/package\n    to compile Erlang from source code. (#222)\n\n2 October 2017 - 1.6.0\n\n  - Support clang 9 and High Sierra command-line tools (CLT) on older Erlang\n    builds. (#234)\n  - Fix a pointer error in wx on macOS/clang 9 (#235)\n\n25 May 2017 - 1.5.1\n\n  - Bug Fix: Remove spurious spaces (#209)\n\n24 May 2017 - 1.5.0\n\n  - Published an OTP support policy, triage schedule, IRC channel\n  - Apply build patches for Perls >= 5.22 on older OTP releases (#198)\n  - Fix bad `read` usage (#200)\n  - Add a force flag for mv (#201)\n  - Use a more portable way to get perl minor release version (#204)\n  - Force 64 bit flag on macOS (#205)\n  - Fix documentation symlinks (#206)\n\n22 February 2017 - 1.4.2\n\n  - Fixed a syntax error when comparing hash outputs on reconfigurations (#191)\n  - Added the path subcommand; enabled Travis-CI (#190)\n  - Fixed mistakenly omitted version string from past 2 releases.\n\n12 February 2017 - 1.4.1\n\n  - Fix reading a checksum file for compile options (#180)\n  - Get a little smarter about figuring out what apps to use\n    when building a PLT file for dialyzer (#181)\n\n5 February 2017 - 1.4.0\n\n  - Fix environment variable handling and a typo (#179)\n  - Overhaul the README; document all environment variables (#178)\n  - Store build configuration in a file. Enables detecting if configuration has\n    changed from build to build and also allows outputing build time options\n    in `kerl status` (#177)\n  - Assert perl exists before attempting build (#176); fixes issue #170\n\n13 October 2016 - 1.3.4\n\n  - Use a more portable way to restore PATH (#165)\n  - Exit if curl fails. Download files if they are 0 length. (#166)\n\n07 October 2016 - 1.3.3\n\n  - Add support for (T)CSH (#155)\n  - If homebrew is installed, make kerl check for a homebrew OpenSSL library path (#161)\n  - If `--enable-native-libs` is active, make, clean and make again. (#163)\n\n20 July 2016 - 1.3.2\n\n  - Optionally enhance the activation prompt (#149)\n  - Do not permit installation into a location that's already installed (#150)\n  - Fix duplicate response from `kerl prompt` (fix #88) (#150)\n  - Do not run if $HOME is not set. (fix #22) (#151)\n\n16 July 2016 - 1.3.1\n\n  - Fix argument order in archive unpacking (#146)\n  - When building, show output of unmet dependencies or other build prerequisites (#148)\n\n1 July 2016 - 1.3.0\n\n  - basic fish shell support (#91)\n\n28 June 2016 - 1.2.0\n\n  - Make curl output more robust if using a .curlrc (#137)\n  - Apply patches to build older Erlangs (#138)\n  - Add a command to output a version string (#140)\n  - Do not assume success for metadata file writes (#142)\n  - Fix a grammar problem (#145)\n\n20 May 2016 - 1.1.1\n\n  - Remove valid directory check when doing a remote deployment.\n  - Various get_otp_version() regex cleanup/fixes\n\n14 May 2016 - 1.1.0\n\n  - Remove support for Mac OS X Lion. Stop setting CFLAGS for better compiler\n    optimizations. (#132)\n\n14 May 2016 - 1.0.1\n\n  - Be much more careful about installing into and removing directories. (#127)\n  - Make `OTP_GITHUB_URL` and `KERL_BUILD_BACKEND` controllable from .kerlrc (#130)\n\n2 May 2016 - 1.0\n\n  - Support builds from git tags (#122)\n  - Support documentation builds/installs from source code (#126)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.111328125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\n<jadeallenx@outlook.com>.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\n<https://www.contributor-covenant.org/version/2/0/code_of_conduct.html>.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: <https://www.contributor-covenant.org>\n\nFor answers to common questions about this code of conduct, see the FAQ at\n<https://www.contributor-covenant.org/faq>. Translations are available at\n<https://www.contributor-covenant.org/translations>.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.3203125,
          "content": "# Contributing to kerl\n\n1. [License](#license)\n1. [Reporting a bug](#reporting-a-bug)\n1. [Requesting or implementing a feature](#requesting-or-implementing-a-feature)\n1. [Submitting your changes](#submitting-your-changes)\n   1. [Code Style](#code-style)\n   1. [Committing your changes](#committing-your-changes)\n   1. [Pull requests and branching](#pull-requests-and-branching)\n   1. [Credits](#credits)\n\n## License\n\n`kerl` is licensed under The [MIT](LICENSE.md) License, for all code.\n\n## Reporting a bug\n\n`kerl` is not perfect software and will be buggy.\n\nBugs can be reported via\n[GitHub issues: bug report](https://github.com/kerl/kerl/issues/new?template=bug_report.md).\n\nSome contributors and maintainers may be unpaid developers working on `kerl`, in their own time,\nwith limited resources. We ask for respect and understanding, and will provide the same back.\n\nIf your contribution is an actual bug fix, we ask you to include tests that, not only show the issue\nis solved, but help prevent future regressions related to it.\n\n## Requesting or implementing a feature\n\nBefore requesting or implementing a new feature, do the following:\n\n- search, in existing [issues](https://github.com/kerl/kerl/issues) (open or closed), whether\nthe feature might already be in the works, or has already been rejected,\n- make sure you're using the latest software release (or even the latest code, if you're going for\n_bleeding edge_).\n\nIf this is done, open up a\n[GitHub issues: feature request](https://github.com/kerl/kerl/issues/new?template=feature_request.md).\n\nWe may discuss details with you regarding the implementation, and its inclusion within the project.\n\nWe try to have as many of `kerl`'s features tested as possible. Everything that a user can do,\nand is repeatable in any way, should be tested, to guarantee backwards compatible.\n\n## Adding support for your Linux distribution to scan for build pre-requisites\n\nErlang needs several packages to build correctly - many of which may or may not be present on a fresh\nOS install or Docker image, so as a convenience, `kerl` tests for these packages before it attempts to\nbuild.\n\nWe currently have tests for many popular Linux distributions but the sheer number of them means we\nmay not have support for yours. If you want to add it, here is what we are looking for:\n\n- Starting around line 700 are a series of `_KPP_<distro>_` parameters\n- Inspect the `/etc/os-release` file and find out what your distribution is called there\n- Use that name to name your variables\n- Add a new function in the style of `_rpm()`, `_dpkg()`, etc., to probe your distribution's package\nmanager\n- Add the list of packages corresponding to names used by the package manager in another variable\n- Add the package probe function name to a new variable so `kerl` knows how to drive its testing\n- Test locally and submit the output from that test as a comment in your PR\n\n## Submitting your changes\n\n### Code Style\n\n- do not introduce trailing whitespace\n- indentation is 4 spaces, not tabs\n- try not to introduce lines longer than 100 characters\n- write small functions whenever possible, and use descriptive names for functions and variables\n- comment tricky or non-obvious decisions made to explain their rationale\n- the tool is linted with `shellcheck` and formatted with `shfmt`: make sure you run these locally\nto avoid CI issues (their options are listed in `lint.yml`)\n\n### Pre- continuous integration\n\nCheck out what out `lint.yml` GitHub action will do over your changes, when submitting them,\nnamely regarding shell scripts, `.md` files, and `.yml` files (all linted).\n\n### Committing your changes\n\nMerging to the `master` branch may be preceded by a squash.\n\nWhile it's Ok (and expected) your commit messages relate to why a given change was made, be aware\nthat the final commit (the merge one) will be the issue title, so it's important it is as specific\nas possible. This will also help eventual automated changelog generation.\n\n### Pull requests and branching\n\nAll fixes to `kerl` end up requiring a +1 from one or more of the project's maintainers.\n\nDuring the review process, you may be asked to correct or edit a few things before a final rebase\nto merge things. Do send edits as individual commits to allow for gradual and partial reviews to be\ndone by reviewers.\n\n### Credits\n\n`kerl` has been improved by\n[many contributors](https://github.com/kerl/kerl/graphs/contributors)!\n"
        },
        {
          "name": "LATEST",
          "type": "blob",
          "size": 0.005859375,
          "content": "4.3.0\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.1396484375,
          "content": "# License\n\nCopyright (c) 2016- Jade Allen\n\nCopyright (c) 2011, 2012 Spawngrid, Inc\n\nCopyright (c) 2011 Evax Software <contact(at)evax(dot)org>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.9560546875,
          "content": "# `kerl` [![GitHub Actions CI][ci-img]][ci] [![GitHub Actions Lint][lint-img]][lint]\n\n[ci-img]: https://github.com/kerl/kerl/actions/workflows/ci.yml/badge.svg\n[ci]: https://github.com/kerl/kerl/actions/workflows/ci.yml\n[lint-img]: https://github.com/kerl/kerl/actions/workflows/lint.yml/badge.svg\n[lint]: https://github.com/kerl/kerl/actions/workflows/lint.yml\n\nEasy building and installing of [Erlang/OTP](https://www.erlang.org) instances.\n\n`kerl` aims to be shell agnostic (it runs in a POSIX shell) and its only dependencies,\nexcluding what's required to actually build Erlang/OTP, are `curl` and `git`.\n\nAll is done so that, once a specific release has been built, creating a new\ninstallation is as fast as possible.\n\n## Table of Contents\n\n- [Installing `kerl`](#installing-kerl)\n- [How `kerl` works](#how-kerl-works)\n- [Using `kerl`](#using-kerl)\n- [`kerl` options](#kerl-options)\n- [Command reference](#command-reference)\n- [Important notes](#important-notes)\n- [Shell support](#shell-support)\n- [The `kerl` glossary](#the-kerl-glossary)\n- [The `kerl` project](#the-kerl-project)\n\n## Installing `kerl`\n\nIf you are on macOS, and using [homebrew](https://github.com/Homebrew/brew),\nyou can install `kerl`, along with shell completion, by running:\n\n```console\n$ brew install kerl\n```\n\nAlternatively, you can download the script directly from GitHub:\n\n```console\n$ curl -O https://raw.githubusercontent.com/kerl/kerl/master/kerl\n```\n\nThen ensure it is executable\n\n```console\n$ chmod a+x kerl\n```\n\nand drop it in your `$PATH`.\n\nOptionally, download and install `kerl`'s `bash_completion` file from\n<https://github.com/kerl/kerl/raw/master/bash_completion/kerl>\n\nOptionally, download and install `kerl`'s `zsh-completion` file from\n<https://github.com/kerl/kerl/raw/master/zsh_completion/_kerl>\n\n### Updating `kerl` locally\n\nRun:\n\n```console\n$ kerl upgrade\nLocal kerl found (/usr/local/bin/kerl) at version 2.6.0.\nRemote kerl found at version 3.0.0.\nVersions are different. Upgrading to 3.0.0...\nkerl 3.0.0 is now available at /usr/local/bin/kerl.\nUpdating list of available releases...\n... done!\n```\n\n## How `kerl` works\n\n`kerl` keeps tracks of the releases it downloads, builds and installs, allowing\neasy installations to new destinations (without complete rebuilding) and easy\nswitches between Erlang/OTP installations.\n\nBy default, `kerl` downloads source tarballs from the [official Erlang/OTP repository](https://github.com/erlang/otp/tags)\nbut you can tell `kerl` to download from the [official Erlang/OTP website](https://www.erlang.org/downloads)\nby setting `KERL_BUILD_BACKEND=tarball`.\nHowever, this website does not use HTTPS and is down more often than GitHub.\n\nYou can also install directly from a raw Git repository by using the\n`kerl build git <git_url> <git_version> <build_name>` syntax.\n\n## Using `kerl`\n\nList the available releases:\n\n```console\n$ kerl list releases\n17.5.6.10\n18.3.4.11\n19.3.6.13\n20.3.8.26\n21.3.8.24\n22.3.4.26\n23.3.4.19\n24.3.4.16\n25.3.2.9 *\n26.2.2 *\n27.0 *\nRun './kerl update releases' to update this list.\nRun './kerl list releases all' to view all available releases.\nNote: * means \"currently supported\".\n```\n\nPick your choice and build it:\n\n```console\n$ kerl build 27.0 27.0\nDownloading (from GitHub) Erlang/OTP 27.0 to /home/user/.kerl/archives...\n...\nExtracting source code for normal build...\nBuilding (normal) Erlang/OTP 27.0 (27.0); please wait...\n...\nErlang/OTP 27.0 (27.0) has been successfully built.\n```\n\nNote that named builds allow you to have different builds for the same Erlang/OTP release with\ndifferent configure options:\n\n```console\n$ KERL_BUILD_DOCS=yes kerl build 27.0 27.0-builtdocs\nExtracting source code for normal build...\nBuilding Erlang/OTP 27.0 (27.0-builtdocs); please wait...\n...\nBuilding docs...\nErlang/OTP 27.0 (27.0-builtdocs) has been successfully built.\n```\n\nYou can verify your build has been registered:\n\n```console\n$ kerl list builds\n27.0,27.0\n27.0,27.0-builtdocs\n```\n\nNow install a build to some location:\n\n```console\n$ kerl install 27.0 /usr/local/lib/erlang/27.0\nInstalling Erlang/OTP 27.0 (27.0) in /usr/local/lib/erlang/27.0...\nBuilding Dialyzer PLT...\nDone building /usr/local/lib/erlang/27.0/dialyzer/plt.\nYou can activate this installation running the following command:\n. /usr/local/lib/erlang/27.0/activate\nLater on, you can leave the installation typing:\nkerl_deactivate\n```\n\nHere again you can check the installation's been registered:\n\n```console\n$ kerl list installations\n27.0 /usr/local/lib/erlang/27.0\n```\n\nAnd at last activate it:\n\n```console\n$ . /usr/local/lib/erlang/27.0/activate\n```\n\nActivation will backup your `$PATH`, and prepend it with the installation's `bin/`\ndirectory. Thus it's only valid for the current shell session, and until you either\nactivate another installation or call `kerl_deactivate`.\n\n**Note**: alternatively you can use `kerl build-install` as a shortcut for\nthe two previous actions to be played in sequence.\n\n```console\n$ kerl build-install\nusage: ./kerl build-install <release> [build_name] [directory]\n```\n\n```console\n$ kerl build-install git\nusage: ./kerl build-install git <git_url> <git_version> <build_name> [directory]\n```\n\nYou're now ready to work with your 27.0 installation:\n\n```console\n$ erl -version\nErlang (SMP,ASYNC_THREADS) (BEAM) emulator version 13.2\n```\n\nWhen you're done just call the shell function:\n\n```console\n$ kerl_deactivate\n```\n\nAnytime you can check which installation, if any, is currently active with:\n\n```console\n$ kerl active\nThe current active installation is:\n/usr/local/lib/erlang/27.0\n```\n\nYou can get an overview of the current `kerl` state with:\n\n```console\n$ kerl status\nAvailable builds:\n27.0,27.0\n27.0,27.0-builtdocs\n----------\nAvailable installations:\n27.0 /usr/local/lib/erlang/27.0\n----------\nThe current active installation is:\n/usr/local/lib/erlang/27.0\nThe Dialyzer PLT for the active installation is:\n/usr/local/lib/erlang/27.0/dialyzer/plt\nThe build options for the active installation are:\n...\n```\n\nYou can delete builds and installations with the following commands:\n\n```console\n$ kerl delete build 27.0-builtdocs\nBuild '27.0-builtdocs' has been deleted.\n```\n\n```console\n$ kerl delete installation 27.0\nInstallation '27.0' has been deleted.\n```\n\nYou can easily deploy an installation to another host having `ssh` and `rsync` access with the\nfollowing command:\n\n```console\n$ kerl deploy anotherhost /usr/local/lib/erlang/27.0\nCloning Erlang/OTP 27.0 (/usr/local/lib/erlang/27.0) to anotherhost (/usr/local/lib/erlang/27.0)...\n```\n\nOn `anotherhost`, you can activate this installation running the following command:\n\n```console\n$ . /usr/local/lib/erlang/27.0/activate\n```\n\nLater on, you can leave the installation typing:\n\n```console\n$ kerl_deactivate\n```\n\n### Building Erlang/OTP from a GitHub fork\n\nIt is possible to build Erlang/OTP from a GitHub fork, by using the `KERL_BUILD_BACKEND=git` and\nsetting `OTP_GITHUB_URL` to the URL of the fork. For example, to build `<orgname>'s` Erlang/OTP fork:\n\n```console\n$ export KERL_BUILD_BACKEND=git\n$ export OTP_GITHUB_URL='https://github.com/<orgname>/otp'\n$ KERL_INCLUDE_RELEASE_CANDIDATES=yes kerl update releases\nGetting releases from GitHub...\nThe available releases are:\n...\n24.0-rc3\n24.0-rc3.1-orgname\n24.3.4.16\n24.3.4.16.1.1-orgname\n25.0-rc3 *\n25.0-rc3.1-orgname *\n25.3.2.9 *\n25.3.2.9.1-orgname *\n26.0-rc3 *\n26.0-rc3.1-orgname *\n26.2.2 *\n26.2.2.1-orgname *\n27.0 *\n27.0.1-orgname *\n```\n\n**Note**: this list, kept in a file managed by `kerl`, is different depending on the build backend\nyou use.\n\nFrom here (provided the `KERL_BUILD_BACKEND` and `OTP_GITHUB_URL` variables remain in place), it is\npossible to use `kerl` as before:\n\n```console\n$ kerl build 27.0.1-orgname 27.0.1-orgname\n```\n\n### Building Erlang/OTP from a Git source\n\nYou can build Erlang/OTP directly from a Git repository with a command of the form\n`kerl build git <git_url> <git_version> <build_name>` where `<git_version>` can\nbe either a branch, a tag or a commit id that will be passed to `git checkout`:\n\n```console\n$ kerl build git https://github.com/erlang/otp.git OTP-27.0 27.0\nChecking out Erlang/OTP git repository from https://github.com/erlang/otp.git...\nBuilding (git) Erlang/OTP OTP-27.0; please wait...\nErlang/OTP '27.0' (from git) has been successfully built.\n```\n\n### Debugging `kerl` usage\n\nIf `KERL_DEBUG` is set to a value, then `kerl` will emit copious debug logging, including\na best effort attempt at line numbers. The line numbers may or may not be accurate if\n`kerl` is run under the `dash` shell, as is commonly found in Alpine Linux/Docker images.\n\n### Configuring `kerl`\n\nYou can tune `kerl` using the `.kerlrc` file in your `$HOME` directory.\n\n### `kerl` and OpenSSL\n\nIf you're running `kerl` on macOS, it will try to guess the OpenSSL\nversion to use if none is specified (e.g. via `KERL_CONFIGURE_OPTIONS`' `--with-ssl`).\n\nSince Erlang/OTP 25.1, OpenSSL 3.0 is supported, so the following applies\n\n| Erlang/OTP version | OpenSSL version |\n|-                   |-                |\n| up until 25.1      | 1.1             |\n| after 25.1         | 3.0             |\n\n## `kerl` options\n\n`kerl` options can be passed either via `.kerlrc` or environment variables, as shown below.\n\n### Color configuration\n\n#### `KERL_COLORIZE`\n\nDefault: 1 (Enabled)\nEnable VT100 colorizing if `tput` available (provided by `ncurses`). Set to 0 to disable.\nColorization will be disabled anyway if necessary requirements are missing.\n\nColor for log levels can be overriden, by setting ANSI numerical color code to variables\n`KERL_COLOR_*` :\n\n- `KERL_COLOR_E` : (1=red) Error level color\n- `KERL_COLOR_W` : (3=yellow) Warning level color\n- `KERL_COLOR_N` : (4=blue) Notice level color\n- `KERL_COLOR_T` : (6=cyan) Tip level color\n- `KERL_COLOR_S` : (2=green) Success level color\n- `KERL_COLOR_D` : (9) Default Terminal color\n\n### Locations on disk\n\n#### `KERL_BASE_DIR`\n\nDefault: `$HOME/.kerl`\nDirectory in which `kerl` will cache artifacts for building and installing.\n\n#### `KERL_CONFIG`\n\nDefault: `$HOME/.kerlrc`\nFile from which to source `kerl` configuration\n\n#### `KERL_DOWNLOAD_DIR`\n\nDefault: `${KERL_BASE_DIR}/archives`\nDirectory in which to place downloaded artifacts\n\n#### `KERL_BUILD_DIR`\n\nDefault: `${KERL_BASE_DIR}/builds`\nDirectory in which `kerl` will perform builds\n\n#### `KERL_GIT_DIR`\n\nDefault: `${KERL_BASE_DIR}/gits`\nDirectory in which `kerl` will clone Git repositories for building.\n\n### Build configuration\n\n#### `KERL_CHECK_BUILD_PACKAGES`\n\nDefault: yes (Enabled)\n`kerl` will try to probe your Linux distro for build-required packages logging\nwhere the probes fail. You can turn off this behaviour by setting the\nenvironment variable to something other than \"yes\".\n\n#### `KERL_AUTOCLEAN`\n\nDefault: 1 (Enabled)\nClean all build artifacts but the log file on failure. This allows safe build retries\nafter failure while still keeping a log file with all attempted builds until\nsuccess.\n\nSet to 0 to keep build artifacts on failure.\n\n#### `KERL_CONFIGURE_OPTIONS`\n\nSpace-separated options to pass to `configure` when building Erlang/OTP.\n\n#### `KERL_CONFIGURE_APPLICATIONS`\n\nSpace-separated list of Erlang/OTP applications which should exclusively be built.\n\n#### `KERL_CONFIGURE_DISABLE_APPLICATIONS`\n\nSpace-separated list of Erlang/OTP applications to disable during building.\n\n#### `KERL_BUILD_PLT`\n\nCreate a PLT file alongside the built release.\n\n#### `KERL_USE_AUTOCONF`\n\nUse `autoconf` during build process.\n\n**Note**: automatically enabled when using `KERL_BUILD_BACKEND=git`\n\n#### `KERL_BUILD_BACKEND`\n\nDefault value: `git`\nAcceptable values: `tarball`, `git`\n\n- `tarball`: fetch Erlang/OTP releases from <erlang.org>\n- `git`: fetch Erlang/OTP releases from [`$OTP_GITHUB_URL`](#otp_github_url)\n\n**Note**: docs are only fetched when this is set to `tarball`. To enable creation of docs when set to\n`git`, one must also set [`$KERL_BUILD_DOCS`](#kerl_build_docs).\n\n**Note**: this option has no effect when using `kerl build git...`, which invokes `kerl` to directly\nclone a Git repository and build from there.\n\n#### `KERL_RELEASE_TARGET`\n\nAllows building, alongside the regular VM, a list of various runtime types for debugging\n(such as `cerl -debug` or `cerl -asan`)\n\n**Note**: enable this build using `KERL_RELEASE_TARGET=\"debug asan\"`\n\n**Note**: available types: `opt`, `gcov`, `gprof`, `debug`, `valgrind`, `asan` or `lcnt`\n\nFor more information: see  \"How to Build a Debug Enabled Erlang RunTime System\" in\n<https://www.erlang.org/doc/installation_guide/install>.\n\n#### `OTP_GITHUB_URL`\n\nDefault value: `https://github.com/erlang/otp`\nAcceptable value: any GitHub fork of Erlang/OTP\n\n#### `KERL_BUILD_DOCS`\n\nIf `$KERL_BUILD_DOCS` is set, `kerl` will create docs from the built Erlang/OTP version regardless of\norigin (`tarball` backend from <erlang.org> or via `kerl build git`, or via `git` backend).\n\nIf `$KERL_BUILD_DOCS` is unset, `kerl` will only install docs when **not** installing a build\ncreated via `kerl build git...`, and according to `KERL_INSTALL_HTMLDOCS` and `KERL_INSTALL_MANPAGES`.\n\n#### `KERL_DOC_TARGETS`\n\nDefault: `chunks`\nAvailable targets:\n\n- `man` (dropped in OTP 27): install manpage docs.\n- `html`: install HTML docs.\n- `pdf` (dropped in OTP 27): install PDF docs.\n- `chunks`: install the \"chunks\" format to get documentation from the `erl` REPL.\n\nYou can set multiple type of targets separated by space, example `KERL_DOC_TARGETS=\"html chunks\"`\n\n#### `KERL_INSTALL_MANPAGES`\n\nInstall man pages when not building from Git source.\n\nIt's noteworthy that when not using `KERL_BUILD_DOCS=yes`, the docset that may be downloaded can be\nup to 120 MB.\n\n#### `KERL_INSTALL_HTMLDOCS`\n\nInstall HTML documentation when not building from Git source.\n\nIt's noteworthy that when not using `KERL_BUILD_DOCS=yes`, the docset that may be downloaded can be\nup to 120 MB.\n\n#### `KERL_SASL_STARTUP`\n\nBuild Erlang/OTP to use SASL startup instead of minimal (default, when var is unset).\n\n### Activation configuration\n\nThe following applies when activating an installation (i.e. `. ${KERL_DEFAULT_INSTALL_DIR}/19.2/activate`).\n\n#### `KERL_ENABLE_PROMPT`\n\nWhen set, automatically prefix the shell prompt with a section containing the\nErlang/OTP version (see [`$KERL_PROMPT_FORMAT`](#kerl_prompt_format) ).\n\n#### `KERL_PROMPT_FORMAT`\n\nDefault: `(%BUILDNAME%)`\nAvailable variables:\n\n- `%BUILDNAME%`: name of the `kerl` build (e.g. `my_test_build_18.0`)\n- `%RELEASE%`: name of the Erlang/OTP release (e.g. `19.2` or `R16B02`)\n\nThe format of the prompt section to add.\n\n#### `KERL_GIT_CLONE_DEPTH`\n\nDefault: `not set`\nValue passed to `git clone --depth=` when using `kerl build git ...`.\n\n**Note**: this doesn't always result in smaller clones.\n\n### Installation configuration\n\n#### `KERL_DEFAULT_INSTALL_DIR`\n\nEffective when calling `kerl install <build>` with no installation location argument.\n\nIf unset, `$PWD` is used.\n\nIf set, install the build under `$KERL_DEFAULT_INSTALL_DIR/${buildname}`.\n\n#### `KERL_APP_INSTALL_DIR`\n\nEffective when calling `kerl upgrade`. This is the folder where the `kerl` application\nresides.\n\nIf unset, `$PWD` is used.\n\nIf set, `kerl` is installed at `$KERL_APP_INSTALL_DIR/kerl`.\n\n#### `KERL_DEPLOY_SSH_OPTIONS` + `KERL_DEPLOY_RSYNC_OPTIONS`\n\nOptions passed to `ssh` and `rsync` during `kerl deploy` tasks.\n\n## Command reference\n\nYou can also get information on the following by executing `kerl` (no parameters) on your shell.\n\n### `build`\n\n```console\n$ kerl build <release> [build_name]\n$ # or\n$ kerl build git <git_url> <git_version> <build_name>\n```\n\nCreates a named build either from an official Erlang/OTP release or from a git repository.\n\n```console\n$ kerl build 27.0 27.0\n$ #or\n$ kerl build git https://github.com/erlang/otp.git OTP-27.0 27.0\n```\n\n#### Tuning\n\n##### Configure options\n\nYou can specify the configure options to use when building Erlang/OTP with the\n`KERL_CONFIGURE_OPTIONS` variable, either in your `$HOME/.kerlrc` file or\nprepending it to the command line. A full list of all options can be found the in\n[Erlang/OTP documentation](https://www.erlang.org/doc/system/install.html#configuring-1).\n\n##### Configure applications\n\nIf non-empty, you can specify the subset of applications to use when building\n(and subsequent installing) Erlang/OTP with the `KERL_CONFIGURE_APPLICATIONS`\nvariable, either in your `$HOME/.kerlrc` file or prepending it to the command\nline.\n\n```console\n$ KERL_CONFIGURE_APPLICATIONS=\"kernel stdlib sasl\" kerl build 27.0 27.0-minimal\n```\n\n##### Configure disable applications\n\nIf non-empty, you can specify the subset of applications to disable when\nbuilding (and subsequent installing) Erlang/OTP with the\n`KERL_CONFIGURE_DISABLE_APPLICATIONS` variable, either in your `$HOME/.kerlrc`\nfile or prepending it to the command line.\n\n```console\n$ KERL_CONFIGURE_DISABLE_APPLICATIONS=\"odbc\" kerl build 27.0 27.0-no-odbc\n```\n\n##### Enable autoconf\n\nYou can enable the use of `autoconf` in the build process setting\n`KERL_USE_AUTOCONF=yes` in your `$HOME/.kerlrc` file.\n\n**Note**: `autoconf` is always enabled for Git builds.\n\n##### Using shell export command in .kerlrc\n\nConfigure variables which includes spaces such as those in `CFLAGS` cannot be\npassed on with `KERL_CONFIGURE_OPTIONS`. In such a case you can use shell\n`export` command to define the environment variables for `./configure`. Note\nwell: this method has a side effect to change your shell execution environment\nafter activating a `kerl` installation of Erlang/OTP. Here is an example of\n`.kerlrc` for building Erlang/OTP for FreeBSD with clang compiler:\n\n<!-- markdownlint-disable MD007 # line-length -->\n```console\n$ # for clang\n$ export CC=clang CXX=clang CFLAGS=\"-g -O3 -fstack-protector\" LDFLAGS=\"-fstack-protector\"\n$ # compilation options\n$ KERL_CONFIGURE_OPTIONS=\"--disable-native-libs --enable-vm-probes --with-dynamic-trace=dtrace --with-ssl=/usr/local --with-javac --enable-hipe --enable-kernel-poll --with-wx-config=/usr/local/bin/wxgtk2u-2.8-config --without-odbc --enable-threads --enable-sctp --enable-smp-support\"\n```\n<!-- markdownlint-enable MD007 # line-length -->\n\nIn case you cannot access the default directory for temporary files (`/tmp`) or\nsimply want them somewhere else, you can also provide your own directory with\nthe variable `TMP_DIR`.\n\n```console\n$ export TMP_DIR=/your/custom/temporary/dir\n```\n\n#### Building documentation\n\nPrior to `kerl` 1.0, `kerl` always downloaded prepared documentation from\nerlang.org. Now if `KERL_BUILD_DOCS=yes` is set, `kerl` will build the man pages\nand HTML documentation from the source repository in which it is working.\n\n**Note**: this variable takes precedent over the other documentation parameters.\n\n### `install`\n\n#### Installing a build\n\n```console\n$ kerl install <build_name> [directory]\n```\n\nInstalls a named build to the specified filesystem location.\n\n```console\n$ kerl install 27.0 /usr/local/lib/erlang/27.0\n```\n\nIf path is omitted the current working directory will be used. However, if\n`KERL_DEFAULT_INSTALL_DIR` is defined in `$HOME/.kerlrc`,\n`KERL_DEFAULT_INSTALL_DIR/<build-name>` will be used instead.\n\n##### Install location restrictions\n\n**Warning**: `kerl` assumes the given installation directory is for its sole use.\nIf you later delete it with the `kerl delete` command, the whole directory will\nbe deleted, along with anything you may have added to it!\n\nSo only install `kerl` in an empty (or non-existant) directory.\n\nIf you attempt to install `kerl` in `$HOME` or `.erlang` or `$KERL_BASE_DIR`,\nthen `kerl` will give you an error and refuse to proceed. If you try to install\n`kerl` in a directory that exists and is not empty, `kerl` will give you an error.\n\n##### Tuning\n\n###### SASL startup\n\nYou can have SASL started automatically setting `KERL_SASL_STARTUP=yes` in your\n`$HOME/.kerlrc` file or prepending it to the command line.\n\n###### Manpages installation\n\nYou can have manpages installed automatically setting\n`KERL_INSTALL_MANPAGES=yes` in your `$HOME/.kerlrc` file or prepending it to the\ncommand line.\n\n**Note**: for Git-based builds, you want to set `KERL_BUILD_DOCS=yes`\n\n###### HTML docs installation\n\nYou can have HTML docs installed automatically setting\n`KERL_INSTALL_HTMLDOCS=yes` in your `$HOME/.kerlrc` file or prepending it to the\ncommand line.\n\n*Note*: for Git-based builds, you want to set `KERL_BUILD_DOCS=yes`\n\n#### Documentation installation\n\nMan pages will be installed to `[path]/man` and HTML docs will be installed in\n`[path]/html`.  The `kerl` `activate` script manipulates the MANPATH of the current\nshell such that `man 3 gen_server` or `erl -man gen_server` should work perfectly.\n\nDo not fret - `kerl_deactivate` restores your shell's `MANPATH` to whatever its\noriginal value was.\n\n### `deploy`\n\n```console\n$ kerl deploy <[user@]host> [directory] [remote_directory]\n```\n\nDeploys the specified installation to the given host and location.\n\n```console\n$ kerl deploy anotherhost /path/to/install/dir\n```\n\nIf `[remote_directory]` is omitted the specified `[directory]` will be used.\n\nIf both `[directory]` and `[remote_directory]` are omitted the current working directory will be used.\n\n*NOTE*: `kerl` assumes the specified host is accessible via `ssh` and `rsync`.\n\n#### Tuning\n\n##### Additional SSH options\n\nYou can have additional options given to `ssh` by setting them in the\n`KERL_DEPLOY_SSH_OPTIONS` variable in your `$HOME/.kerlrc` file or on the command\nline, e.g. `KERL_DEPLOY_SSH_OPTIONS='-qx -o PasswordAuthentication=no'`.\n\n##### Additional RSYNC options\n\nYou can have additional options given to `rsync` by setting them in the\n`KERL_DEPLOY_RSYNC_OPTIONS` variable in your `$HOME/.kerlrc` file or on the\ncommand line, e.g. `KERL_DEPLOY_RSYNC_OPTIONS='--delete'`.\n\n### `update`\n\n```console\n$ kerl update releases\n```\n\nIf `KERL_BUILD_BACKEND=tarball` this command fetches the up-to-date list of Erlang/OTP\nreleases from erlang.org.\n\nIf it is set to `KERL_BUILD_BACKEND=git` this command fetches an up-to-date\nlist of Erlang/OTP tags from the official Erlang/OTP GitHub repository.\n\n**Note**: the output of this function can be tweaked with `KERL_INCLUDE_RELEASE_CANDIDATES=yes` to\nprint release candidates.\n\n### `list`\n\n```console\n$ kerl list <releases|builds|installations> [all]\n```\n\nLists the releases, builds or installations available.\n\nWhen listing releases (without option `all`), the following applies:\n\n- no release candidates are shown, unless you set environment variable\n`KERL_INCLUDE_RELEASE_CANDIDATES` to `yes`\n- no \"very old\" releases are shown (depends on the current `kerl` version)\n- versions included in the support policy are flagged with `*`\n\n**Note**: using `all` means all available releases are shown without filters.\n\n### `delete`\n\n```console\n$ kerl delete build <build_name>\n$ # or\n$ kerl delete installation <build_name|directory>\n```\n\nDeletes the specified build or installation.\n\n```console\n$ kerl delete build 27.0\nThe 27.0 build has been deleted\n```\n\n```console\n$ kerl delete installation /usr/local/lib/erlang/27.0\nThe installation in /usr/local/lib/erlang/27.0 has been deleted\n```\n\n### `active`\n\n```console\n$ kerl active\n```\n\nPrints the path of the currently active installation, if any.\n\n```console\n$ kerl active\nThe current active installation is:\n/usr/local/lib/erlang/27.0\n```\n\n### `status`\n\n```console\n$ kerl status\n```\n\nPrints the available builds and installations as well as the currently active installation.\n\n```console\n$ kerl status\nAvailable builds:\n27.0,27.0\n27.0,27.0-builtdocs\n----------\nAvailable installations:\n27.0 /usr/local/lib/erlang/27.0\n----------\nThe current active installation is:\n/usr/local/lib/erlang/27.0\nDialyzer PLT for the active installation is:\n/usr/local/lib/erlang/27.0/dialyzer/plt\nThe build options for the active installation are:\n...\n```\n\n### `path`\n\n```console\n$ kerl path [installation]\n```\n\nPrints the path of the currently active installation if one is active. When given an\ninstallation name, it will return the path to that installation location on disk.\nThis makes it useful for automation without having to run `kerl`'s output through\nother tools to extract to path information.\n\n```console\n$ kerl path\nNo active kerl-managed erlang installation\n```\n\n```console\n$ kerl path 27.0\n/usr/local/lib/erlang/27.0\n```\n\n### `build-install`\n\n```console\n$ kerl build-install <release> [build_name] [directory]\nkerl build-install git <git_url> <git_version> <build_name> [directory]\n```\n\nCombines `kerl build` and `kerl install` into a single command.\n\n### `plt`\n\nPrints Dialyzer PLT path for the active installation.\n\n### `prompt`\n\nPrints a string suitable for insertion in prompt.\n\n### `cleanup`\n\n```console\n$ kerl cleanup <build_name|all>\n```\n\nRemove compilation artifacts (use after installation), for a given build or for \"all\".\n\n### `emit-activate`\n\n```console\n$ kerl emit-activate <release> <build_name> <directory> [sh|bash|fish|csh]\n```\n\nPrint the `activate` script, as generated by `kerl`.\n\n**Note**: the output defaults to shell `sh` (also `bash`), as per file `activate`. To emit\n`activate.fish`, or `activate.csh`, set the last argument to `fish` or `csh`, respectively.\n\n### `version`\n\nPrints current version.\n\n## Important notes\n\n### Note on .kerlrc\n\nSince `.kerlrc` is a dot file for `/bin/sh`, running shell commands inside the\n`.kerlrc` will affect the shell and environment variables for the commands being\nexecuted later. For example, the shell `export` commands in `.kerlrc` will affect\n*your login shell environment* when activating `curl`.  Use with care.\n\n## Shell support\n\n### fish\n\n`kerl` has basic support for the fish shell.\n\nTo activate an installation:\n\n```console\n$ source /path/to/install/dir/activate.fish\n```\n\nDeactivation is the same as in other shells:\n\n```console\n$ kerl_deactivate\n```\n\n### C\n\n`kerl` has basic support for the C shells (`csh`, `tcsh`, etc.).\n\nTo activate an installation:\n\n```console\n$ source /path/to/install/dir/activate.csh\n```\n\nThe activation script sources file `.kerlrc.csh` instead of `.kerlrc`.\n\nDeactivation is the same as in other shells:\n\n```console\n$ kerl_deactivate\n```\n\n### Command-line completion\n\nOptionally, download and install `kerl`'s:\n\n- `bash_completion` file from <https://github.com/kerl/kerl/raw/master/bash_completion/kerl>\n- `zsh_completion` file from <https://github.com/kerl/kerl/raw/master/zsh_completion/_kerl>\n- `fish-completion` file from <https://github.com/kerl/kerl/raw/master/fish_completion/kerl.fish>\n\ndepending on your preferred shell.\n\n## The `kerl` glossary\n\nHere are the abstractions `kerl` is handling:\n\n- **releases**: Erlang/OTP releases from [erlang.org](https://erlang.org)\n\n- **builds**: the result of configuring and compiling releases or Git repositories\n\n- **installations**: the result of deploying builds to filesystem locations (also referred to as \"sandboxes\")\n\n## The `kerl` project\n\n### Erlang/OTP support policy\n\nAs of September 2021, we are supporting the current Erlang/OTP release version\nand 2 prior release versions (same as upstream Erlang/OTP). Older Erlang/OTP releases\nmay or may not work. We will advance release support as new releases of Erlang/OTP\nbecome available.\n\n### Code of conduct\n\nYou can read more about our code of conduct at [CODE_OF_CONDUCT.md](CODE_OF_CONDUCT.md).\n\n### Contributing to `kerl`\n\nContributions are welcome! Be sure to read and follow the general guidelines made explicit in\n[CONTRIBUTING.md](CONTRIBUTING.md).\n\n### License\n\n`kerl` is MIT-licensed, as per [LICENSE.md](LICENSE.md). You'll also find the same license notice\ninside the distributable shell script.\n\n### Changelog\n\nCheck [CHANGELOG.md](CHANGELOG.md) and also [GitHub releases](https://github.com/kerl/kerl/releases).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 1.2294921875,
          "content": "# Security policy\n\nThanks for helping make `kerl` safer for everyone.\n\nFind below updated information on our security policy.\n\n## Security\n\nWe take the security of this software seriously.\n\nWe don't implement a bug bounty program or bounty rewards, but will work with\nyou to ensure that your findings get the appropriate handling.\n\n## Reporting Security Issues\n\nIf you believe you have found a security vulnerability in this repository,\nplease report it to <jadeallenx@outlook.com>.\n\nPlease do not report security vulnerabilities through public channels, like\nGitHub issues, discussions, or pull requests.\n\nPlease include as much of the information listed below as you can to help us\nbetter understand and resolve the issue:\n\n- the type of issue (e.g., buffer overflow, SQL injection, or cross-site\n  scripting)\n- full paths of source file(s) related to the manifestation of the issue\n- the location of the affected source code (tag/branch/commit or direct URL)\n- any special configuration required to reproduce the issue\n- step-by-step instructions to reproduce the issue\n- proof-of-concept or exploit code (if possible)\n- impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n"
        },
        {
          "name": "bash_completion",
          "type": "tree",
          "content": null
        },
        {
          "name": "fish_completion",
          "type": "tree",
          "content": null
        },
        {
          "name": "kerl",
          "type": "blob",
          "size": 81.8359375,
          "content": "#!/bin/sh\n\n# Copyright (c) 2016- Jade Allen\n# Copyright (c) 2011, 2012 Spawngrid, Inc\n# Copyright (c) 2011 Evax Software <contact(at)evax(dot)org>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n# shellcheck disable=SC2250  # Prefer putting braces around variable references even when not strictly required\n# shellcheck disable=SC2292  # Prefer `[[ ]]` over `[ ]` for tests in Bash/Ksh\n# shellcheck disable=SC2312  # Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore)\n\nunset ERL_TOP\n\n# Make sure CDPATH doesn't affect cd in case path is relative.\nunset CDPATH\n\nif [ -n \"$KERL_DEBUG\" ]; then\n    set -x\n    ## Line numbers do not work in dash (aka Debian/Ubuntu sh)\n    ## so you may want to change sh to bash to get better debug info\n    if [ -n \"${LINENO}\" ]; then\n        PS4='+ ${LINENO}: '\n    fi\nfi\n\nKERL_VERSION='4.3.0'\nOLDEST_OTP_LISTED='17'\nOLDEST_OTP_SUPPORTED='25'\n\nERLANG_DOWNLOAD_URL='https://erlang.org/download'\nKERL_CONFIG_STORAGE_FILENAME='.kerl_config'\n\n_KERL_SCRIPT=$0\n\n# Redirect to stderr only if it is a terminal, otherwise mute\nstderr() {\n    if [ -t 1 ]; then\n        if [ -z \"$l\" ] || [ \"$KERL_COLORIZE\" -eq 0 ]; then\n            echo \"$*\" 1>&2\n        else\n            left=\"$(colorize \"$l\")\"\n            # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n            right=\"$(tput $KERL_COLOR_RESET)\"\n            echo \"${left}$*${right}\" 1>&2\n            unset -v l\n        fi\n    elif [ -n \"$KERL_DEBUG\" ] && [ -n \"$CI\" ]; then\n        echo \"$*\"\n    fi\n}\n\nnocolor() {\n    # $1: log entry\n\n    stderr \"$1\"\n}\n\nusage_exit() {\n    # $1: usage tip\n\n    l=error stderr \"usage: ${_KERL_SCRIPT} $1\"\n    exit 1\n}\n\nerror() {\n    # $1: log entry\n\n    l=error stderr \"ERROR: $1\"\n}\n\nwarn() {\n    # $1: log entry\n    # $2: use 'noprefix' if you want to omit WARNING:\n\n    if [ \"$2\" != \"noprefix\" ]; then\n        l=warn stderr \"WARNING: $1\"\n    else\n        l=warn stderr \"$1\"\n    fi\n}\n\nnotice() {\n    # $1: log entry\n\n    l=notice stderr \"$1\"\n}\n\nsuccess() {\n    # $1: log entry\n\n    l=success stderr \"$1\"\n}\n\ntip() {\n    # $1: log entry\n\n    l=tip stderr \"$1\"\n}\n\ninit_build_logfile() {\n    # $1: release\n    # $2: build name\n\n    BUILD_LOGFILE=\"$KERL_BUILD_DIR/$2/otp_build_$1.log\"\n    rm -f \"$BUILD_LOGFILE\"\n    touch \"$BUILD_LOGFILE\"\n    tip \"Initializing (build) log file at $BUILD_LOGFILE\".\n}\n\nlog_build_entry() {\n    # $1: log entry\n\n    echo \"$1\" >>\"$BUILD_LOGFILE\" 2>&1\n}\n\nlog_build_cmd() {\n    # $*: command\n    build_cmd=\"$*\"\n\n    eval \"$build_cmd\" >>\"$BUILD_LOGFILE\" 2>&1\n}\n\ninit_install_logfile() {\n    # $1: release\n    # $2: build name\n\n    INSTALL_LOGFILE=\"$KERL_BUILD_DIR/$2/otp_install_$1.log\"\n    rm -f \"$INSTALL_LOGFILE\"\n    touch \"$INSTALL_LOGFILE\"\n    tip \"Initializing (install) log file at $INSTALL_LOGFILE\".\n}\n\nlog_install_cmd() {\n    # $*: command\n    install_cmd=\"$*\"\n\n    eval \"$install_cmd\" >>\"$INSTALL_LOGFILE\" 2>&1\n}\n\n# Check if tput is available for colorize\ntp=$(tput sgr0 1>/dev/null 2>&1 && printf \"OK\" || printf \"\")\nif [ -z \"$tp\" ]; then\n    if [ -z \"$CI\" ]; then\n        nocolor \"Colorization disabled as 'tput' (via 'ncurses') seems to be unavailable.\"\n    fi\n    KERL_COLOR_AVAILABLE=0\n    KERL_COLORIZE=0 # Force disabling colorization\nelse\n    KERL_COLOR_AVAILABLE=1\n    if [ -n \"$KERL_COLOR_D\" ]; then\n        KERL_COLOR_RESET=\"setaf $KERL_COLOR_D\"\n    else\n        KERL_COLOR_RESET=\"sgr0\"\n    fi\nfi\n\ncolorize() {\n    case \"$1\" in\n    \"error\")\n        ret=\"$(tput setaf \"${KERL_COLOR_E:=1}\")\"\n        ;;\n    \"warn\")\n        ret=\"$(tput setaf \"${KERL_COLOR_W:=3}\")\"\n        ;;\n    \"notice\")\n        ret=\"$(tput setaf \"${KERL_COLOR_N:=4}\")\"\n        ;;\n    \"tip\")\n        ret=\"$(tput setaf \"${KERL_COLOR_T:=6}\")\"\n        ;;\n    \"success\")\n        ret=\"$(tput setaf \"${KERL_COLOR_S:=2}\")\"\n        ;;\n    *)\n        ret=\"$(tput setaf \"${KERL_COLOR_D:=9}\")\"\n        ;;\n    esac\n    printf \"%b\" \"$ret\"\n}\n\nautoclean() {\n    if [ \"${KERL_AUTOCLEAN:=1}\" -eq 1 ]; then\n        notice \"Auto cleaning all artifacts except the log file...\"\n        tip \"(use KERL_AUTOCLEAN=0 to keep build on failure, if desired)\"\n        # Cleaning current build\n        cd - 1>/dev/null 2>&1 || return 0\n        test -n \"$1\" && ${_KERL_SCRIPT} cleanup \"$1\"\n    else\n        warn \"auto cleaning (on failure) disabled!\"\n    fi\n}\n\nTMP_DIR=${TMP_DIR:-'/tmp'}\nif [ -z \"$HOME\" ]; then\n    error \"\\$HOME is empty or not set.\"\n    exit 1\nfi\n\n# Default values\nKERL_BASE_DIR=${KERL_BASE_DIR:=\"$HOME\"/.kerl}\nKERL_CONFIG=${KERL_CONFIG:=\"$HOME\"/.kerlrc}\nKERL_DOWNLOAD_DIR=${KERL_DOWNLOAD_DIR:=\"${KERL_BASE_DIR:?}\"/archives}\nKERL_BUILD_DIR=${KERL_BUILD_DIR:=\"${KERL_BASE_DIR:?}\"/builds}\nKERL_GIT_DIR=${KERL_GIT_DIR:=\"${KERL_BASE_DIR:?}\"/gits}\nKERL_GIT_BASE=https://raw.githubusercontent.com/kerl/kerl/master\nKERL_COLORIZE=${KERL_COLORIZE:=$KERL_COLOR_AVAILABLE}\nKERL_INCLUDE_RELEASE_CANDIDATES=${KERL_INCLUDE_RELEASE_CANDIDATES:=no}\nKERL_CHECK_BUILD_PACKAGES=${KERL_CHECK_BUILD_PACKAGES:=\"yes\"}\n\nact_on_kerl_cfgs() {\n    # $1: kerl config. flags (we're only interested in the keys)\n    # $2: action - cache | restore (default)\n\n    for _KERL_CFG in $1; do\n        k=$(echo \"$_KERL_CFG\" | \\sed 's|\\(.*\\)=.*|\\1|')\n\n        if [ \"$2\" = cache ]; then\n            eval \"_KERL_CFG_VAR=\\$${k}\"\n            eval \"_KERL_TARGET_VAR=__${k}\"\n        elif [ \"$2\" = restore ]; then\n            eval \"_KERL_CFG_VAR=\\$__${k}\"\n            eval \"_KERL_TARGET_VAR=${k}\"\n        fi\n        if [ -n \"${_KERL_CFG_VAR}\" ]; then\n            # shellcheck disable=SC2154  # _KERL_TARGET_VAR is referenced but not assigned\n            eval \"$_KERL_TARGET_VAR=\\\"$_KERL_CFG_VAR\\\"\"\n        fi\n    done\n}\n\n# List is [<config_key>=<def_value>, ...]\n_KERL_CFGS=\"\nOTP_GITHUB_URL=https://github.com/erlang/otp\nKERL_CONFIGURE_OPTIONS=\nKERL_CONFIGURE_APPLICATIONS=\nKERL_CONFIGURE_DISABLE_APPLICATIONS=\nKERL_SASL_STARTUP=\nKERL_DEPLOY_SSH_OPTIONS=\nKERL_DEPLOY_RSYNC_OPTIONS=\nKERL_INSTALL_MANPAGES=\nKERL_INSTALL_HTMLDOCS=\nKERL_BUILD_PLT=\nKERL_BUILD_DOCS=\nKERL_DOC_TARGETS=chunks\nKERL_BUILD_BACKEND=\nKERL_RELEASE_TARGET=\n\"\nact_on_kerl_cfgs \"$_KERL_CFGS\" \"cache\"\neval \"$_KERL_CFGS\"\n\n# ensure the base dir exists\nmkdir -p \"$KERL_BASE_DIR\" || exit 1\n\n# source the config file if available\nif [ -f \"$KERL_CONFIG\" ]; then\n    # shellcheck source=/dev/null\n    . \"$KERL_CONFIG\"\nfi\n\nact_on_kerl_cfgs \"$_KERL_CFGS\" \"restore\"\n\nif [ -z \"$KERL_SASL_STARTUP\" ]; then\n    INSTALL_OPT='-minimal'\nelse\n    INSTALL_OPT='-sasl'\nfi\n\nif [ -z \"$KERL_BUILD_BACKEND\" ]; then\n    KERL_BUILD_BACKEND='git'\nfi\nif [ \"$KERL_BUILD_BACKEND\" = 'git' ]; then\n    KERL_USE_AUTOCONF=1\nelif [ \"$KERL_BUILD_BACKEND\" != 'tarball' ]; then\n    error \"unhandled value KERL_BUILD_BACKEND=${KERL_BUILD_BACKEND}.\"\n    tip \"KERL_BUILD_BACKEND must be either 'git' (default), or 'tarball'.\"\n    exit 1\nfi\n\nKERL_SYSTEM=$(uname -s)\ncase \"$KERL_SYSTEM\" in\nDarwin | FreeBSD | OpenBSD)\n    MD5SUM='openssl md5'\n    MD5SUM_FIELD=2\n    SED_OPT=-E\n    ;;\n*)\n    MD5SUM=md5sum\n    MD5SUM_FIELD=1\n    SED_OPT=-r\n    ;;\nesac\n\nk_usage() {\n    nocolor \"kerl: build and install Erlang/OTP\"\n    nocolor \"usage: ${_KERL_SCRIPT} <command> [options ...]\"\n    nocolor \"\"\n    nocolor \"  <command>       Command to be executed\"\n    nocolor \"\"\n    nocolor \"Valid commands are:\"\n    nocolor \"  build           Build specified release or git repository\"\n    nocolor \"  install         Install the specified release at the given location\"\n    nocolor \"  build-install   Builds and installs the specified release or git repository at the given location\"\n    nocolor \"  deploy          Deploy the specified installation to the given host and location\"\n    nocolor \"  update          Update the list of available releases from your source provider\"\n    nocolor \"  list            List releases, builds and installations\"\n    nocolor \"  delete          Delete builds and installations\"\n    nocolor \"  path            Print the path of a given installation\"\n    nocolor \"  active          Print the path of the active installation\"\n    nocolor \"  plt             Print Dialyzer PLT path for the active installation\"\n    nocolor \"  status          Print available builds and installations\"\n    nocolor \"  prompt          Print a string suitable for insertion in prompt\"\n    nocolor \"  cleanup         Remove compilation artifacts (use after installation)\"\n    nocolor \"  emit-activate   Print the activate script\"\n    nocolor \"  upgrade         Fetch and install the most recent kerl release\"\n    nocolor \"  version         Print current version (current: $KERL_VERSION)\"\n    exit 1\n}\n\nif [ $# -eq 0 ]; then k_usage; fi\n\nget_releases() {\n    # $1: path to file otp_releases\n\n    if [ \"$KERL_BUILD_BACKEND\" = 'git' ]; then\n        if ! get_git_releases \"$1\"; then\n            return 1\n        fi\n    else\n        if ! get_tarball_releases \"$1\"; then\n            return 1\n        fi\n    fi\n}\n\nget_git_releases() {\n    tmp=\"$(mktemp \"$TMP_DIR\"/kerl.XXXXXX)\"\n    # shellcheck disable=SC2154  # OTP_GITHUB_URL is referenced but not assigned\n    git ls-remote --tags --refs \"$OTP_GITHUB_URL\" >\"$tmp\"\n    ret=$?\n    notice \"Getting releases from GitHub...\"\n    if [ \"$ret\" -eq 0 ]; then\n        if ! cut <\"$tmp\" -f2 |\n            cut -d'/' -f3- |\n            sed \"$SED_OPT\" \\\n                -e '# Delete all tags starting with \":\" as to not mix' \\\n                -e '# them with the prefixed lines we`re generating next.' \\\n                -e '/^:/d' \\\n                \\\n                -e '# Prefix \"OTP*\" release lines with the crux of their versions.' \\\n                -e '#  - \"OTP_R16B01_RC1\"  =>  \":16B01_RC1 OTP_R16B01_RC1\"' \\\n                -e '#  - \"OTP_R16B03\"      =>  \":16B03 OTP_R16B03\"' \\\n                -e '#  - \"OTP-17.0\"        =>  \":17.0 OTP-17.0\"' \\\n                -e '#  - \"OTP-17.3.1\"      =>  \":17.3.1 OTP-17.3.1\"' \\\n                -e '#  - \"OTP-19.0-rc1\"    =>  \":19.0-rc1 OTP-19.0-rc1\"' \\\n                -e '#  - \"OTP-19.0-rc2\"    =>  \":19.0-rc2 OTP-19.0-rc2\"' \\\n                -e 's/^(OTP[-_](R?([0-9][^ :]*).*))/:\\3 \\2/' \\\n                \\\n                -e '# Delete all lines that did not get prefixed above.' \\\n                -e '/^[^:]/d' \\\n                \\\n                -e '# Move the colon markers preceding each version prefix' \\\n                -e '# as to precede the tag suffix instead, which will make' \\\n                -e '# throwing the version prefixes easier later on.' \\\n                -e '#  - \":16B01_RC1 OTP_R16B03\"  =>  \"16B01_RC1 :OTP_R16B01_RC1\"' \\\n                -e '#  -     \":16B03 OTP_R16B03\"  =>  \"16B03 :OTP_R16B03\"' \\\n                -e '#  -      \":17.0 OTP_R16B03\"  =>  \"17.0 :OTP-17.0\"' \\\n                -e '#  -    \":17.3.1 OTP_R16B03\"  =>  \"17.3.1 :OTP-17.3.1\"' \\\n                -e '#  -  \":19.0-rc1 OTP_R16B03\"  =>  \"19.0-rc1 :OTP-19.0-rc1\"' \\\n                -e '#  -  \":19.0-rc2 OTP_R16B03\"  =>  \"19.0-rc2 :OTP-19.0-rc2\"' \\\n                -e 's/^:([^ ]+) /\\1 :/' \\\n                \\\n                -e '# Repeatedly replace sequences of one or more dots, dashes' \\\n                -e '# or underscores, within each version prefix, with single' \\\n                -e '# space characters.' \\\n                -e '#  - \"16B01_RC1 :OTP_R16B01_RC1\"  =>  \"16B01 RC1 :OTP_R16B01_RC1\"' \\\n                -e '#  -     \"16B03 :OTP_R16B03\"      =>  \"16B03 :OTP_R16B03\"' \\\n                -e '#  -      \"17.0 :OTP-17.0\"        =>  \"17 0 :OTP-17.0\"' \\\n                -e '#  -    \"17.3.1 :OTP-17.3.1\"      =>  \"17 3 1 :OTP-17.3.1\"' \\\n                -e '#  -  \"19.0-rc1 :OTP-19.0-rc1\"    =>  \"19 0 rc1 :OTP-19.0-rc1\"' \\\n                -e '#  -  \"19.0-rc2 :OTP-19.0-rc2\"    =>  \"19 0 rc2 :OTP-19.0-rc2\"' \\\n                -e ':loop' \\\n                -e 's/^([^:]*)[.-]+([^:]*) :/\\1 \\2 :/' \\\n                -e 't loop' \\\n                \\\n                -e '# Repeatedly replace \"A\", \"B\", or \"C\" separators, within each' \\\n                -e '# version prefix, with \" 0 \", \" 1 \" and \" 2 \", respectively.' \\\n                -e '#  - \"16B01 RC1 :OTP_R16B01_RC1\"  =>  \"16 1 01 RC1 :OTP_R16B01_RC1\"' \\\n                -e '#  -     \"16B03 :OTP_R16B03\"      =>  \"16 1 03 :OTP_R16B03\"' \\\n                -e ':loop2' \\\n                -e 's/^(.*[0-9]+)A([^:]*) :/\\1 0 \\2 :/' \\\n                -e 's/^(.*[0-9]+)B([^:]*) :/\\1 1 \\2 :/' \\\n                -e 's/^(.*[0-9]+)C([^:]*) :/\\1 2 \\2 :/' \\\n                -e 't loop2' \\\n                \\\n                -e '# Repeatedly replace space-release candidate infixes, within' \\\n                -e '# each version prefix, with a leading zero followed by' \\\n                -e '# the candidate number.' \\\n                -e '# - \"16 1 01 RC1 :OTP_R16B01_RC1\"  =>  \"16 1 01 0 1 :OTP_R16B01_RC1\"' \\\n                -e '# -      \"19 0 rc1 :OTP-19.0-rc1\"  =>  \"19 0 0 1 :OTP-19.0-rc1\"' \\\n                -e '# -      \"19 0 rc2 :OTP-19.0-rc2\"  =>  \"19 0 0 2 :OTP-19.0-rc2\"' \\\n                -e ':loop3' \\\n                -e 's/^([^:]* )(rc|RC)([0-9]+)(( [^:]*)?) :/\\10 \\3\\4 :/' \\\n                -e 't loop3' \\\n                \\\n                -e '# Repeatedly prefix single digits, within each version prefix,' \\\n                -e '# with leading zeroes.' \\\n                -e '#  - \"16 1 01 0 1 :OTP_R16B01_RC1\"  =>  \"16 01 01 00 01 :OTP_R16B01_RC1\"' \\\n                -e '#  -     \"16 1 03 :OTP_R16B03\"      =>  \"16 01 03 :OTP_R16B03\"' \\\n                -e '#  -        \"17 0 :OTP-17.0\"        =>  \"17 00 :OTP-17.0\"' \\\n                -e '#  -      \"17 3 1 :OTP-17.3.1\"      =>  \"17 03 01 :OTP-17.3.1\"' \\\n                -e '#  -    \"19 0 0 1 :OTP-19.0-rc1\"    =>  \"19 00 00 01 :OTP-19.0-rc.1\"' \\\n                -e '#  -    \"19 0 0 2 :OTP-19.0-rc2\"    =>  \"19 00 00 02 :OTP-19.0-rc.2\"' \\\n                -e ':loop4' \\\n                -e 's/^([^:]*[^0-9:])([0-9])(([^0-9][^:]*)?) :/\\10\\2\\3 :/' \\\n                -e 't loop4' \\\n                \\\n                -e '# Suffix each version prefix with 00 as to not compare ':' with a number.' \\\n                -e '#  - \"16 01 01 00 01 :OTP_R16B01_RC1\"  =>  \"16 01 01 00 01 00 :OTP_R16B01_RC1\"' \\\n                -e '#  -       \"16 01 03 :OTP_R16B03\"      =>  \"16 01 03 00 :OTP_R16B03\"' \\\n                -e '#  -          \"17 00 :OTP-17.0\"\"       =>  \"17 00 00 :OTP-17.0\"' \\\n                -e '#  -       \"17 03 01 :OTP-17.3.1\"      =>  \"17 03 01 00 :OTP-17.3.1\"' \\\n                -e '#  -    \"19 00 00 01 :OTP-19.0-rc.1\"   =>  \"19 00 00 01 00 :OTP-19.0-rc.1\"' \\\n                -e '#  -    \"19 00 00 02 :OTP-19.0-rc.2\"   =>  \"19 00 00 02 00 :OTP-19.0-rc.2\"' \\\n                -e 's/^([^:]+) :/\\1 00 :/' |\n            LC_ALL=C sort -n |\n            cut -d':' -f2- |\n            tee \"$1\" >/dev/null 2>&1; then\n            error \"file $1 does not appear to be writable.\"\n            return 1\n        fi\n        rm -f \"$tmp\"\n        return 0\n    else\n        rm -f \"$tmp\"\n        error \"git ls-remote --tags --refs $OTP_GITHUB_URL returned $ret!\"\n        return 1\n    fi\n}\n\n_curl() {\n    # $1: <file> to write output to, instead of stdout (if body_only function only returns body)\n    # $2: URL to consider\n    # $3: extra options\n\n    if [ \"$1\" != body_only ]; then\n        _curl_extra=\"--output $1 --write-out %{http_code}\"\n    fi\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    \\curl -q --silent --location --fail $2 $3 $_curl_extra\n}\n\nunpack() {\n    # $1: <file> to extract to current directory\n\n    tar -x --no-same-owner --no-same-permissions -zf \"$1\"\n}\n\nget_tarball_releases() {\n    tmp=\"$(mktemp \"$TMP_DIR\"/kerl.XXXXXX)\"\n    notice \"Getting releases from erlang.org...\"\n    http_code=$(_curl \"$tmp\" \"$ERLANG_DOWNLOAD_URL\")\n    if [ 200 = \"$http_code\" ]; then\n        if ! sed \"$SED_OPT\" \\\n            -e 's/^.*<[aA] [hH][rR][eE][fF]=\\\"otp_src_([-0-9A-Za-z_.]+)\\.tar\\.gz\\\">.*$/\\1/' \\\n            -e '/^R1|^[0-9]/!d' \"$tmp\" |\n            sed -e 's/^R\\(.*\\)/\\1:R\\1/' |\n            sed -e 's/^\\([^\\:]*\\)$/\\1-z:\\1/' |\n            sort |\n            cut -d: -f2 |\n            tee \"$1\" >/dev/null 2>&1; then\n            error \"file $1 does not appear to be writable.\"\n            return 1\n        fi\n        rm -f \"$tmp\"\n        return 0\n    else\n        rm -f \"$tmp\"\n        error \"$ERLANG_DOWNLOAD_URL returned $http_code!\"\n        return 1\n    fi\n}\n\nupdate_checksum_file() {\n    if [ \"$KERL_BUILD_BACKEND\" != 'git' ]; then\n        notice \"Getting checksum file from erlang.org...\"\n        http_code=$(_curl \"$KERL_DOWNLOAD_DIR\"/MD5 \"$ERLANG_DOWNLOAD_URL\"/MD5)\n        if [ 200 != \"$http_code\" ]; then\n            error \"$ERLANG_DOWNLOAD_URL/MD5 returned $http_code!\"\n            return 1\n        fi\n    fi\n}\n\nensure_checksum_file() {\n    if [ ! -s \"$KERL_DOWNLOAD_DIR\"/MD5 ] && ! update_checksum_file; then\n        return 1\n    fi\n}\n\ncheck_releases() {\n    # $1: force?: if force, the list is always recreated\n\n    if [ \"$1\" = force ]; then\n        if ! rm -f \"${KERL_BASE_DIR:?}\"/otp_releases 2>/dev/null; then\n            error \"${KERL_BASE_DIR:?}/otp_releases cannot be removed.\"\n            return 1\n        fi\n    fi\n    if [ ! -f \"$KERL_BASE_DIR\"/otp_releases ] &&\n        ! get_releases \"$KERL_BASE_DIR\"/otp_releases; then\n        return 1\n    fi\n}\n\nis_valid_release() {\n    if ! check_releases; then\n        return 1\n    fi\n    while read -r rel; do\n        if [ \"$1\" = \"$rel\" ]; then\n            return 0\n        fi\n    done <\"$KERL_BASE_DIR\"/otp_releases\n    error \"'$1' is not a valid Erlang/OTP release.\"\n    return 1\n}\n\nget_release_from_name() {\n    # $1: build_name\n\n    if [ -f \"$KERL_BASE_DIR\"/otp_builds ]; then\n        while read -r l; do\n            rel=$(echo \"$l\" | cut -d, -f1)\n            name=$(echo \"$l\" | cut -d, -f2)\n            if [ \"$name\" = \"$1\" ]; then\n                echo \"$rel\"\n                return 0\n            fi\n        done <\"$KERL_BASE_DIR\"/otp_builds\n    fi\n    return 1\n}\n\nis_valid_installation() {\n    if [ -f \"$KERL_BASE_DIR\"/otp_installations ]; then\n        while read -r l; do\n            name=$(echo \"$l\" | cut -d' ' -f1)\n            path=$(echo \"$l\" | cut -d' ' -f2)\n            if [ \"$name\" = \"$1\" ] || [ \"$path\" = \"$1\" ]; then\n                if [ -f \"$path\"/activate ]; then\n                    return 0\n                fi\n            fi\n        done <\"$KERL_BASE_DIR\"/otp_installations\n    fi\n    return 1\n}\n\nis_build_name_used() {\n    if [ -f \"$KERL_BASE_DIR\"/otp_builds ]; then\n        while read -r l; do\n            name=$(echo \"$l\" | cut -d, -f2)\n            if [ \"$name\" = \"$1\" ]; then\n                return 0\n            fi\n        done <\"$KERL_BASE_DIR\"/otp_builds\n    fi\n    return 1\n}\n\nis_older_than_x_days() {\n    # $1: file to check\n    # $2: age in days\n\n    old_file=$(find \"$1\" -type f -mtime \"$2\")\n    if [ -n \"$old_file\" ]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\nlock() {\n    # $1: build | install\n    # $2: folder to act on\n\n    if [ -f \"$2/$1.lock\" ]; then\n        if is_older_than_x_days \"$2/$1.lock\" \"+14\"; then\n            unlock \"$1\" \"$2\"\n        else\n            error \"trying to $1 in $2, but lock file ($2/$1.lock) exists!\"\n            exit 1\n        fi\n    else\n        mkdir -p \"$2\"\n        touch \"$2/$1.lock\"\n    fi\n}\n\nunlock() {\n    # $1: build | install\n    # $2: folder to act on\n\n    rm -f \"$2/$1.lock\"\n}\n\nlock_build() {\n    # $_KERL_BUILD_DIR is global\n    lock \"build\" \"$_KERL_BUILD_DIR\"\n}\n\nunlock_build() {\n    # $_KERL_BUILD_DIR is global\n    unlock \"build\" \"$_KERL_BUILD_DIR\"\n}\n\nlock_install() {\n    # $_KERL_INSTALL_DIR is global\n    lock \"install\" \"$_KERL_INSTALL_DIR\"\n}\n\nunlock_install() {\n    # $_KERL_INSTALL_DIR is global\n    unlock \"install\" \"$_KERL_INSTALL_DIR\"\n}\n\nexit_build() {\n    # $1: error message\n    # $2: build name\n\n    if [ -n \"$1\" ]; then\n        error \"$1\"\n    fi\n\n    tmp=$(save_logfile)\n\n    if [ -n \"$2\" ]; then\n        if [ \"${KERL_AUTOCLEAN:=1}\" -eq 1 ]; then\n            rm -Rf \"${KERL_BUILD_DIR:?}/$2\"\n        fi\n    fi\n\n    unlock_build\n    restore_logfile \"$tmp\"\n\n    exit 1\n}\n\nexit_install() {\n    # $1: error message\n\n    if [ -n \"$1\" ]; then\n        error \"$1\"\n    fi\n\n    unlock_install\n\n    exit 1\n}\n\nget_git_clone_depth() {\n    if [ -n \"${KERL_GIT_CLONE_DEPTH}\" ]; then\n        depth=\" --depth ${KERL_GIT_CLONE_DEPTH}\"\n    fi\n    echo \"${depth}\"\n}\n\noutput_git_clone_depth() {\n    if [ -n \"${KERL_GIT_CLONE_DEPTH}\" ]; then\n        echo \" (depth = ${KERL_GIT_CLONE_DEPTH})\"\n    fi\n}\n\ndo_git_build() {\n    git_url=$1\n    git_version=$2\n    build_name=$3\n\n    if is_build_name_used \"$build_name\"; then\n        error \"there's already a build named '$build_name'.\"\n        exit_build\n    fi\n\n    GIT=$(printf '%s' \"$git_url\" | $MD5SUM | cut -d ' ' -f \"$MD5SUM_FIELD\")\n\n    _KERL_BUILD_DIR=\"$KERL_GIT_DIR/$GIT\"\n\n    mkdir -p \"$KERL_GIT_DIR\" || exit_build\n    cd \"$KERL_GIT_DIR\" || exit_build\n    notice \"Checking out Erlang/OTP git repository from $git_url...$(output_git_clone_depth)\"\n    # shellcheck disable=SC2046  # Quote this to prevent word splitting\n    if [ ! -d \"$GIT\" ] &&\n        ! git clone$(get_git_clone_depth) -q --mirror \"$git_url\" \"$GIT\" >/dev/null 2>&1; then\n        exit_build \"mirroring remote git repository ($_KERL_BUILD_DIR exists?).\"\n    fi\n\n    lock_build\n\n    cd \"$_KERL_BUILD_DIR\" || exit_build\n    if ! git remote update --prune >/dev/null 2>&1; then\n        exit_build \"updating remote git repository.\"\n    fi\n    rm -Rf \"${KERL_BUILD_DIR:?}/$build_name\"\n\n    mkdir -p \"$KERL_BUILD_DIR/$build_name\" || exit_build\n    cd \"$KERL_BUILD_DIR/$build_name\" || exit_build \"\" \"$build_name\"\n    if ! git clone -l \"$_KERL_BUILD_DIR\" otp_src_git >/dev/null 2>&1; then\n        exit_build \"cloning local git repository.\" \"$build_name\"\n    fi\n\n    cd \"$KERL_BUILD_DIR/$build_name/otp_src_git\" || exit_build \"\" \"$build_name\"\n    if ! git checkout \"$git_version\" >/dev/null 2>&1 &&\n        ! git checkout -b \"$git_version\" \"$git_version\" >/dev/null 2>&1; then\n        exit_build \"could not checkout specified version.\" \"$build_name\"\n    fi\n\n    if [ ! -x otp_build ]; then\n        exit_build \"not a valid Erlang/OTP repository.\" \"$build_name\"\n    fi\n\n    notice \"Building (git) Erlang/OTP $git_version; please wait...\"\n\n    if [ -z \"$KERL_BUILD_AUTOCONF\" ]; then\n        KERL_USE_AUTOCONF=1\n    fi\n\n    if ! _do_build 'git' \"$build_name\"; then\n        exit_build \"\" \"$build_name\"\n    fi\n\n    success \"Erlang/OTP '$build_name' (from git) has been successfully built.\"\n    if ! list_add builds git,\"$build_name\"; then\n        exit_build \"\" \"$build_name\"\n    fi\n\n    unlock_build\n}\n\nget_otp_version() {\n    echo \"$1\" | sed \"$SED_OPT\" -e 's/R?([0-9]{1,2}).+/\\1/'\n}\n\nshow_configuration_warnings() {\n    # $1 is log file\n    # $2 is section header (E.g. \"APPLICATIONS DISABLED\")\n    # Find the row number for the section we are looking for\n    INDEX=$(\\grep -n -m1 \"$2\" \"$1\" | cut -d: -f1)\n\n    # If there are no warnings, the section won't appear in the log\n    if [ -n \"$INDEX\" ]; then\n        # Skip the section header, find the end line and skip it\n        # then print the results indented\n        tail -n +$((INDEX + 3)) \"$1\" |\n            sed -n '1,/\\*/p' |\n            awk -F: -v logfile=\"$1\" -v section=\"$2\" \\\n                'BEGIN { printf \"%s (See: %s)\\n\", section, logfile }\n                 /^[^\\*]/ { print \" *\", $0 }\n                 END { print \"\" } '\n    fi\n}\n\nshow_logfile() {\n    # $1 reason\n    # $2 log file\n\n    error \"$1\"\n    tail \"$2\" 1>&2\n    nocolor \"\"\n    tip \"Please see $2 for full details.\"\n}\n\nshow_build_logfile() {\n    # $1 reason\n\n    show_logfile \"$1\" \"$BUILD_LOGFILE\"\n}\n\nshow_install_logfile() {\n    # $1 reason\n\n    show_logfile \"$1\" \"$INSTALL_LOGFILE\"\n}\n\nmaybe_patch() {\n    # $1 = OS platform e.g., Darwin, etc\n    # $2 = OTP release\n\n    release=$(get_otp_version \"$2\")\n    case \"$1\" in\n    Darwin) ;;\n    SunOS) ;;\n    *) ;;\n    esac\n}\n\ndo_normal_build() {\n    # $1: release\n    # $2: build name\n\n    if ! is_valid_release \"$1\"; then\n        exit_build\n    fi\n    if is_build_name_used \"$2\"; then\n        error \"there's already a build named '$2'.\"\n        exit_build\n    fi\n\n    _KERL_BUILD_DIR=\"$KERL_BUILD_DIR/$2\"\n    lock_build\n\n    FILENAME=\"\"\n    if ! download \"$1\"; then\n        exit_build\n    fi\n\n    if [ ! -d \"$_KERL_BUILD_DIR/$FILENAME\" ]; then\n        notice \"Extracting source code for normal build...\"\n        UNTARDIRNAME=\"$_KERL_BUILD_DIR/$FILENAME-kerluntar-$$\"\n        rm -rf \"$UNTARDIRNAME\"\n        mkdir -p \"$UNTARDIRNAME\" || exit_build\n        # github tarballs have a directory in the form of \"otp[_-]TAGNAME\"\n        # Ericsson tarballs have the classic otp_src_RELEASE pattern\n        # Standardize on Ericsson format because that's what the rest of the script expects\n        (cd \"$UNTARDIRNAME\" && unpack \"$KERL_DOWNLOAD_DIR/$FILENAME\".tar.gz &&\n            cp -rfp ./* \"$_KERL_BUILD_DIR/otp_src_$1\")\n        rm -rf \"$UNTARDIRNAME\"\n    fi\n\n    notice \"Building (normal) Erlang/OTP $1 ($2); please wait...\"\n    if ! _do_build \"$1\" \"$2\"; then\n        exit_build\n    fi\n    success \"Erlang/OTP $1 ($2) has been successfully built.\"\n    if ! list_add builds \"$1,$2\"; then\n        exit_build\n    fi\n\n    unlock_build\n}\n\n_flags() {\n    # We used to munge the LD and DED flags for clang 9/10 shipped with\n    # High Sierra (macOS 10.13), Mojave (macOS 10.14) and Catalina\n    # (macOS 10.15)\n    #\n    # As of OTP 20.1 that is (apparently) no longer necessary and\n    # from OTP 24 breaks stuff. See thread and comment here:\n    # https://github.com/erlang/otp/issues/4821#issuecomment-845914942\n    case \"$KERL_SYSTEM\" in\n    Darwin)\n        # Make sure we don't overwrite stuff that someone who\n        # knows better than us set.\n        if [ -z \"$CC\" ]; then\n            CC='clang'\n        fi\n\n        CFLAGS=\"${CFLAGS:-}\" CC=\"$CC\" \"$@\"\n        ;;\n    *)\n        CFLAGS=\"${CFLAGS:-}\" \"$@\"\n        ;;\n    esac\n}\n\n_dpkg() {\n    # gratefully stolen from\n    # https://superuser.com/questions/427318/test-if-a-package-is-installed-in-apt\n    # returns 0 (true) if found, 1 otherwise\n    echo \"dpkg-query -Wf'\\${db:Status-abbrev}' \\\"$1\\\" 2>/dev/null | \\grep -q '^i'\"\n}\n\n_rpm() {\n    echo \"rpm -q \\\"$1\\\"\"\n}\n\n_apk() {\n    echo \"apk -e info \\\"$1\\\"\"\n}\n\ncommon_ALL_pkgs=\"gcc make\"\ncommon_ALL_BUILD_BACKEND_git_pkgs=\"autoconf\"\ncommon_debian_pkgs=\"${common_ALL_pkgs} libssl-dev libncurses-dev g++\"\ncommon_rhel_pkgs=\"${common_ALL_pkgs} openssl-devel ncurses-devel gcc-c++\"\n\n# To add package guessing magic for your Linux distro/package,\n# create a variable named _KPP_<distro>_pkgs where the content\n# is an array with packages, and then create a unique probe\n# command, in variable _KPP_<distro>_probe to check from the package manager.\n# It should return 0 if package installation is Ok, non-0 otherwise.\n\n_KPP_alpine_pkgs=\"${common_ALL_pkgs} openssl-dev ncurses-dev g++\"\n_KPP_alpine_probe=\"_apk\"\n\n_KPP_debian_pkgs=${common_debian_pkgs}\n_KPP_debian_probe=\"_dpkg\"\n\n_KPP_fedora_pkgs=${common_rhel_pkgs}\n_KPP_fedora_probe=\"_rpm\"\n\n_KPP_linuxmint_pkgs=${common_debian_pkgs}\n_KPP_linuxmint_probe=\"_dpkg\"\n\n_KPP_pop_pkgs=${common_debian_pkgs}\n_KPP_pop_probe=\"_dpkg\"\n\n_KPP_rhel_pkgs=${common_rhel_pkgs}\n_KPP_rhel_probe=\"_rpm\"\n\n_KPP_ubuntu_pkgs=${common_debian_pkgs}\n_KPP_ubuntu_probe=\"_dpkg\"\n\nparse_os_release() {\n    # $1: path to os-release\n    # returns:\n    # - 2 if release ID is not found in os-release file\n    os_release_id0=$(\\grep \"^ID=\" \"$1\")\n    os_release_id=$(echo \"${os_release_id0}\" | \\sed 's|.*=||' | \\sed 's|\"||g')\n    os_release_pretty_name0=$(\\grep \"^PRETTY_NAME=\" \"$1\")\n    os_release_pretty_name=$(echo \"${os_release_pretty_name0}\" | \\sed 's|.*=||' | \\sed 's|\"||g')\n    log_build_entry \"[packages] Found ${os_release_pretty_name} with ID ${os_release_id}\"\n    if [ -z \"${os_release_id}\" ]; then\n        log_build_entry \"[packages] Release ID not found in $1\"\n        echo \"2\"\n    else\n        log_build_entry \"[packages] Release ID found in $1: ${os_release_id}\"\n        echo \"${os_release_id}\"\n    fi\n}\n\nget_id_from_os_release_files() {\n    # returns:\n    # 1 - if no release files exist\n    files=\"/etc/os-release /usr/lib/os-release\"\n    for file in ${files}; do\n        if [ -f \"${file}\" ]; then\n            parsed=$(parse_os_release \"${file}\")\n            if [ \"${parsed}\" != \"2\" ]; then\n                break\n            fi\n        fi\n    done\n\n    if [ -z \"${parsed}\" ]; then\n        log_build_entry \"[packages] Found no file in: ${files}. Bailing out...\"\n        echo \"1\"\n    fi\n\n    echo \"${parsed}\"\n}\n\nprobe_pkgs() {\n    os_release_id=$(get_id_from_os_release_files)\n\n    if [ \"${os_release_id}\" = \"1\" ]; then\n        msg=\"[packages] Unable to determine Linux distro (no release files); not checking build packages.\"\n        log_build_entry \"${msg}\"\n        warn \"${msg}\"\n        return 0\n    elif [ \"${os_release_id}\" = \"2\" ]; then\n        msg=\"[packages] Unable to determine Linux distro (no ID); not checking build packages.\"\n        log_build_entry \"${msg}\"\n        warn \"${msg}\"\n        return 0\n    fi\n\n    kpp=$(eval echo \\$_KPP_\"${os_release_id}\"_pkgs)\n    if [ \"$KERL_BUILD_BACKEND\" = 'git' ]; then\n        kpp=\"${common_ALL_BUILD_BACKEND_git_pkgs} ${kpp}\"\n    fi\n\n    if [ -n \"${kpp}\" ]; then\n        log_build_entry \"[packages] Found package declarations for your Linux distro: ${os_release_id}\"\n        for pkg in ${kpp}; do\n            cmd=$(eval echo \"\\$_KPP_${os_release_id}_probe ${pkg}\")\n            probe=$(${cmd})\n            eval \"${probe}\" >/dev/null 2>&1\n            probe_res=$?\n            if [ \"${probe_res}\" != 0 ]; then\n                msg=\"[packages] Probe failed for ${pkg} (distro: ${os_release_id}): probe \\\"${probe}\\\" returned ${probe_res}\"\n                log_build_entry \"${msg}\"\n                warn \"${msg}\"\n            else\n                log_build_entry \"[packages] Probe success for ${pkg} (distro: ${os_release_id})!\"\n            fi\n        done\n    else\n        msg=\"[packages] Unknown Linux distro ${os_release_id}; not checking build packages.\"\n        log_build_entry \"${msg}\"\n        warn \"${msg}\"\n    fi\n}\n\nsave_logfile() {\n    tmp=\"$(mktemp \"$TMP_DIR\"/kerl.XXXXXX)\"\n    test -f \"$BUILD_LOGFILE\" && cp -f \"$BUILD_LOGFILE\" \"$tmp\"\n    echo \"$tmp\"\n}\n\nrestore_logfile() {\n    # $1: logfile to restore\n\n    mkdir -p \"$(dirname \"$BUILD_LOGFILE\")\"\n    test -n \"$BUILD_LOGFILE\" && mv -f \"$1\" \"$BUILD_LOGFILE\"\n    rm -f \"$1\"\n}\n\nfail_do_build() {\n    # $1: error message\n    # $2: build name\n    # $3: release\n\n    show_build_logfile \"$1\"\n    tmp=$(save_logfile)\n\n    if [ -n \"$2\" ]; then\n        autoclean \"$2\"\n    fi\n\n    if [ -n \"$3\" ]; then\n        list_remove builds \"$3 $2\"\n    fi\n\n    restore_logfile \"$tmp\"\n}\n\nuname_r_label() {\n    echo \"uname -r\"\n}\n\nuname_r() {\n    eval \"$(uname_r_label)\"\n}\n\nbrew_openssl() {\n    # $1: release (or git)\n    otp_major=$(echo \"$1\" | cut -d. -f1)\n    otp_minor=$(echo \"$1\" | cut -d. -f2)\n\n    if [ \"$otp_major\" = 'git' ] || [ \"$otp_major\" -lt 25 ] || { [ \"$otp_major\" -eq 25 ] && [ \"$otp_minor\" -lt 1 ]; }; then\n        brew --prefix openssl@1.1\n    else\n        brew --prefix openssl@3.0\n    fi\n}\n\n_do_build() {\n    # $1: release (or git)\n    # $2: build name\n\n    init_build_logfile \"$1\" \"$2\"\n    log_build_entry \"*** $(date) - kerl build $1 ***\"\n    log_build_entry \"Build options:\"\n    log_build_cmd \"env | grep KERL_BUILD_ | xargs -n1 echo \\\"*\\\"\"\n\n    case \"$KERL_SYSTEM\" in\n    Darwin)\n        # Ensure that the --enable-darwin-64bit flag is set on all macOS\n        # That way even on older Erlangs we get 64 bit Erlang builds\n        # macOS has been mandatory 64 bit for a while\n        if ! echo \"$KERL_CONFIGURE_OPTIONS\" | \\grep 'darwin-64bit' >/dev/null 2>&1; then\n            KERL_CONFIGURE_OPTIONS=\"$KERL_CONFIGURE_OPTIONS \"--enable-darwin-64bit\n        fi\n\n        # Attempt to use brew to discover if and where openssl has been\n        # installed unless the user has already explicitly set it.\n\n        if ! echo \"$KERL_CONFIGURE_OPTIONS\" | \\grep 'with-ssl' >/dev/null 2>&1; then\n            whichbrew=$(command -v brew)\n            if [ -n \"$whichbrew\" ] && [ -x \"$whichbrew\" ]; then\n                brew_prefix=$(brew_openssl \"$1\")\n                notice \"Attempting to use Homebrew OpenSSL from $brew_prefix...\"\n                if [ -n \"$brew_prefix\" ] && [ -d \"$brew_prefix\" ]; then\n                    success \"... found!\"\n                    KERL_CONFIGURE_OPTIONS=\"$KERL_CONFIGURE_OPTIONS \"--with-ssl=$brew_prefix\n                else\n                    warn \"... you may have to brew the expected version or otherwise use --with-ssl\"\n                fi\n            fi\n        fi\n        ;;\n    Linux)\n        # We implement a \"best effort\" attempt to discover if a Linux distro has the\n        # packages needed to build Erlang. We will always assume the user\n        # knows better than us and are going to go ahead and try to build\n        # Erlang anyway. But at least there will be a clear warning to the\n        # user if a build fails.\n        if [ \"${KERL_CHECK_BUILD_PACKAGES}\" = \"yes\" ]; then\n            probe_pkgs\n        fi\n        ;;\n    *) ;;\n    esac\n\n    ERL_TOP=\"$KERL_BUILD_DIR/$2/otp_src_$1\"\n    if ! cd \"$ERL_TOP\"; then\n        fail_do_build \"couldn't cd into $ERL_TOP\"\n        return 1\n    fi\n\n    # Set configuration flags given applications white/black lists\n    if [ -n \"$KERL_CONFIGURE_APPLICATIONS\" ]; then\n        for app in $KERL_CONFIGURE_APPLICATIONS; do\n            case \"$KERL_CONFIGURE_OPTIONS\" in\n            *\"--with-$app\"*)\n                tip \"Option '--with-$app' in KERL_CONFIGURE_OPTIONS is superfluous.\"\n                ;;\n            *)\n                KERL_CONFIGURE_OPTIONS=\"$KERL_CONFIGURE_OPTIONS --with-$app\"\n                ;;\n            esac\n        done\n    fi\n    if [ -n \"$KERL_CONFIGURE_DISABLE_APPLICATIONS\" ]; then\n        for app in $KERL_CONFIGURE_DISABLE_APPLICATIONS; do\n            case \"$KERL_CONFIGURE_OPTIONS\" in\n            *\"--without-$app\"*)\n                tip \"Option '--without-$app' in KERL_CONFIGURE_OPTIONS is superfluous.\"\n                ;;\n            *)\n                KERL_CONFIGURE_OPTIONS=\"$KERL_CONFIGURE_OPTIONS --without-$app\"\n                ;;\n            esac\n        done\n    fi\n\n    # Check to see if configuration options need to be stored or have changed\n    TMPOPT=\"${TMP_DIR}/kerloptions.$$\"\n    {\n        echo \"This is kerl's control file for build configuration.\"\n        echo \"Please don't edit it manually!\"\n        echo \"CFLAGS: ${CFLAGS:-}\"\n        echo \"KERL_CONFIGURE_OPTIONS: $KERL_CONFIGURE_OPTIONS\"\n        echo \"$(uname_r_label): $(uname_r)\"\n    } >>\"$TMPOPT\"\n    SUM=$($MD5SUM \"$TMPOPT\" | cut -d ' ' -f \"$MD5SUM_FIELD\")\n    # Check for a .kerl_config.md5 file\n    if [ -e ./\"$KERL_CONFIG_STORAGE_FILENAME\".md5 ]; then\n        # Compare our current options to the saved ones\n        read -r OLD_SUM <./\"$KERL_CONFIG_STORAGE_FILENAME\".md5\n        if [ \"$SUM\" != \"$OLD_SUM\" ]; then\n            notice \"Configuration options changed. Re-configuring...\"\n            rm -f configure\n            mv \"$TMPOPT\" ./\"$KERL_CONFIG_STORAGE_FILENAME\"\n            echo \"$SUM\" >./\"$KERL_CONFIG_STORAGE_FILENAME\".md5\n        else\n            # configure options are the same\n            rm -f \"$TMPOPT\"\n        fi\n    else\n        # no file exists, so write one\n        mv \"$TMPOPT\" \"$KERL_CONFIG_STORAGE_FILENAME\"\n        echo \"$SUM\" >\"$KERL_CONFIG_STORAGE_FILENAME\".md5\n    fi\n\n    # Don't apply patches to \"custom\" git builds. We have no idea if they will apply\n    # cleanly or not.\n    if [ \"$1\" != 'git' ]; then\n        maybe_patch \"$KERL_SYSTEM\" \"$1\"\n    fi\n\n    if [ -n \"$KERL_USE_AUTOCONF\" ]; then\n        # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n        if ! log_build_cmd \"./otp_build autoconf && _flags ./otp_build configure $KERL_CONFIGURE_OPTIONS\"; then\n            fail_do_build \"configure failed.\" \"$2\" \"$1\"\n            return 1\n        fi\n    else\n        # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n        if ! log_build_cmd \"_flags ./otp_build configure $KERL_CONFIGURE_OPTIONS\"; then\n            fail_do_build \"configure failed.\" \"$2\" \"$1\"\n            return 1\n        fi\n\n    fi\n    if echo \"$KERL_CONFIGURE_OPTIONS\" | \\grep -- '--enable-native-libs' >/dev/null 2>&1; then\n        log_build_cmd \"make clean\"\n        # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n        if ! log_build_cmd \"_flags ./otp_build configure $KERL_CONFIGURE_OPTIONS\"; then\n            fail_do_build \"configure failed.\" \"$2\" \"$1\"\n            return 1\n        fi\n    fi\n\n    for SECTION in 'APPLICATIONS DISABLED' \\\n        'APPLICATIONS INFORMATION' \\\n        'DOCUMENTATION INFORMATION'; do\n        show_configuration_warnings \"$BUILD_LOGFILE\" \"$SECTION\"\n    done\n\n    if [ -n \"$KERL_CONFIGURE_APPLICATIONS\" ]; then\n        \\find ./lib -maxdepth 1 -type d -exec touch -f {}/SKIP \\;\n        for app in $KERL_CONFIGURE_APPLICATIONS; do\n            if ! rm ./lib/\"$app\"/SKIP; then\n                fail_do_build \"couldn't prepare '$app' application for building.\" \"$2\" \"$1\"\n                return 1\n            fi\n        done\n    fi\n    if [ -n \"$KERL_CONFIGURE_DISABLE_APPLICATIONS\" ]; then\n        for app in $KERL_CONFIGURE_DISABLE_APPLICATIONS; do\n            if ! touch -f ./lib/\"$app\"/SKIP; then\n                fail_do_build \"couldn't disable '$app' application for building.\" \"$2\" \"$1\"\n                return 1\n            fi\n        done\n    fi\n\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    if ! log_build_cmd \"_flags ./otp_build boot -a $KERL_CONFIGURE_OPTIONS\"; then\n        fail_do_build \"build failed.\" \"$2\" \"$1\"\n        return 1\n    fi\n    if [ -n \"$KERL_BUILD_DOCS\" ]; then\n        notice \"Building docs...\"\n        OPT_VERSION=$(get_otp_version \"$(cat OTP_VERSION)\")\n        if [ \"$OPT_VERSION\" -ge 27 ]; then\n            # from OTP 27 on we depend on ex_doc to build the documentation\n            if ! log_build_cmd \"./otp_build download_ex_doc\"; then\n                fail_do_build \"download_ex_doc failed.\" \"$2\" \"$1\"\n                return 1\n            fi\n        fi\n        # shellcheck disable=SC2154  # KERL_DOC_TARGETS is referenced but not assigned\n        if ! log_build_cmd \"make docs DOC_TARGETS=\\\"$KERL_DOC_TARGETS\\\"\"; then\n            fail_do_build \"building docs failed.\" \"$2\" \"$1\"\n            return 1\n        fi\n        if ! log_build_cmd \"make release_docs DOC_TARGETS=\\\"$KERL_DOC_TARGETS\\\" RELEASE_ROOT=$KERL_BUILD_DIR/$2/release_$1\"; then\n            fail_do_build \"release of docs failed.\" \"$2\" \"$1\"\n            return 1\n        fi\n    fi\n\n    if [ -n \"$KERL_RELEASE_TARGET\" ]; then\n        # where `$TYPE` is `opt`, `gcov`, `gprof`, `debug`, `valgrind`, `asan` or `lcnt`.\n        for r_type in $KERL_RELEASE_TARGET; do\n            case $r_type in\n            opt | debug)\n                notice \"Also building for Erlang/OTP $1 ($2) $r_type VM; please wait...\"\n                if ! cd \"$ERL_TOP\"; then\n                    fail_do_build \"couldn't cd into $ERL_TOP\" \"$2\" \"$1\"\n                    return 1\n                fi\n                if ! log_build_cmd \"make TYPE=$r_type ERL_TOP=$ERL_TOP\"; then\n                    fail_do_build \"build of '$r_type' VM failed.\" \"$2\" \"$1\"\n                    return 1\n                fi\n                ;;\n            gcov | gprof | valgrind | asan | lcnt)\n                notice \"Also building for Erlang/OTP $1 ($2) $r_type VM; please wait...\"\n                if ! cd \"$ERL_TOP/erts/emulator\"; then\n                    fail_do_build \"couldn't cd into $ERL_TOP/erts/emulator\" \"$2\" \"$1\"\n                    return 1\n                fi\n                if ! log_build_cmd \"make $r_type ERL_TOP=$ERL_TOP\"; then\n                    fail_do_build \"build of '$r_type' VM failed.\" \"$2\" \"$1\"\n                    return 1\n                fi\n                ;;\n            *)\n                warn \"runtime type '$r_type' is invalid!\"\n                ;;\n            esac\n        done\n    fi\n}\n\ndo_build_install() {\n    release_or_git=$1\n    git_url=$2\n    git_version=$3\n    build_name=$4\n    directory=$5\n\n    if is_valid_installation \"$build_name\"; then\n        error \"there's already an installation named '$build_name'. Skipping build step...\"\n        exit 1\n    fi\n\n    # This is also done on do_install, but saves the build time in case of error\n    if ! is_valid_install_path \"$directory\"; then\n        exit 1\n    fi\n\n    if [ \"$release_or_git\" = \"git\" ]; then\n        ${_KERL_SCRIPT} build git \"$git_url\" \"$git_version\" \"$build_name\"\n    else\n        release=\"$release_or_git\"\n        ${_KERL_SCRIPT} build \"$release\" \"$build_name\"\n    fi\n\n    status=$?\n    if [ \"$status\" -ne 0 ]; then\n        error \"build failed! Skipping installation step...\"\n        exit 1\n    fi\n\n    ${_KERL_SCRIPT} install \"$build_name\" \"$directory\"\n}\n\n# emit_activate: outputs (via cat) the content of the 'activate' script, as used by kerl (sh/bash)\n# @param $1/release: the <release> argument in e.g. kerl build <release> <build_name>\n# @param $2/build_name: the <build_name> argument in e.g. kerl build <release> <build_name>\n# @param $3/directory: the [directory] argument in e.g. kerl install <build_name> [directory]\nemit_activate() {\n    release=$1\n    build_name=$2\n    directory=$3\n\n    cat << \\\n        =======\n#!/bin/sh\n\n# shellcheck disable=SC2250  # Prefer putting braces around variable references even when not strictly required\n\nif type kerl_deactivate 2>/dev/null | \\grep -qw function; then\n    kerl_deactivate\nfi\n\n_KERL=$(command -v kerl)\nif [ -n \"\\$_KERL\" ]; then\n    _KERL_VERSION=\\$(\\$_KERL version)\nfi\nif [ -n \"\\$_KERL_VERSION\" ] && [ \"\\$_KERL_VERSION\" != \"$KERL_VERSION\" ]; then\n    echo \"WARNING: this Erlang/OTP installation appears to be stale. Please consider reinstalling.\"\n    echo \"         It was created with kerl $KERL_VERSION, and the current version is \\$_KERL_VERSION.\"\nfi\nunset _KERL_VERSION\nunset _KERL\n\nadd_cleanup() {\n    _KERL_CLEANUP=\"\n    \\$1\n    \\$_KERL_CLEANUP\n    \"\n}\n\nset -o allexport\n\n_KERL_ACTIVE_DIR=\"$directory\"\nadd_cleanup \"unset _KERL_ACTIVE_DIR\"\n\nif [ -n \"\\$BASH\" ] || [ -n \"\\$ZSH_VERSION\" ]; then\n    add_cleanup \"hash -r\"\nfi\n\n_KERL_PATH_REMOVABLE=\"$directory/bin\"\nPATH=\"\\${_KERL_PATH_REMOVABLE}:\\$PATH\"\nadd_cleanup \"PATH=\\\"\\\\\\$(echo \\\"\\\\\\$PATH\\\" | sed -e \\\"s%\\$_KERL_PATH_REMOVABLE:%%\\\")\\\"\"\nunset _KERL_PATH_REMOVABLE\n\n_KERL_ERL_CALL_REMOVABLE=\\$(\\\\find $directory -type d -path \"*erl_interface*/bin\" 2>/dev/null)\nif [ -n \"\\$_KERL_ERL_CALL_REMOVABLE\" ]; then\n    PATH=\"\\${_KERL_ERL_CALL_REMOVABLE}:\\$PATH\"\n    add_cleanup \"PATH=\\\"\\\\\\$(echo \\\"\\\\\\$PATH\\\" | sed -e \\\"s%\\$_KERL_ERL_CALL_REMOVABLE:%%\\\")\\\"\"\nfi\nunset _KERL_ERL_CALL_REMOVABLE\n\n_KERL_MANPATH_REMOVABLE=\"$directory/lib/erlang/man:$directory/man\"\nif [ -n \"\\${MANPATH+x}\" ]; then\n    if [ -n \"\\$MANPATH\" ]; then\n        MANPATH=\"\\${_KERL_MANPATH_REMOVABLE}:\\$MANPATH\"\n    else\n        MANPATH=\"\\${_KERL_MANPATH_REMOVABLE}\"\n    fi\nelse\n    MANPATH=\"\\${_KERL_MANPATH_REMOVABLE}\"\n    add_cleanup \"\n        if [ -z \\\"\\\\\\$MANPATH\\\" ]; then\n            unset MANPATH\n        fi\n    \"\nfi\nadd_cleanup \"MANPATH=\\\"\\\\\\$(echo \\\"\\\\\\$MANPATH\\\" | sed -r \\\"s%\\$_KERL_MANPATH_REMOVABLE:?%%\\\")\\\"\"\nunset _KERL_MANPATH_REMOVABLE\n\nif [ -n \"\\${REBAR_PLT_DIR+x}\" ]; then\n    add_cleanup \"REBAR_PLT_DIR=\\\"\\$REBAR_PLT_DIR\\\"\"\nelse\n    add_cleanup \"unset REBAR_PLT_DIR\"\nfi\nREBAR_PLT_DIR=\"$directory\"\n\nif [ -n \"\\${REBAR_CACHE_DIR+x}\" ]; then\n    add_cleanup \"REBAR_CACHE_DIR=\\\"\\$REBAR_CACHE_DIR\\\"\"\nelse\n    add_cleanup \"unset REBAR_CACHE_DIR\"\nfi\nREBAR_CACHE_DIR=\"$directory/.cache/rebar3\"\n\n# https://twitter.com/mononcqc/status/877544929496629248\n_KERL_KERNEL_HISTORY=\\$(echo \"\\$ERL_AFLAGS\" | \\\\grep 'kernel shell_history' || true)\nif [ -z \"\\$_KERL_KERNEL_HISTORY\" ]; then\n    if [ -n \"\\${ERL_AFLAGS+x}\" ]; then\n        add_cleanup \"ERL_AFLAGS=\\\"\\$ERL_AFLAGS\\\"\"\n    else\n        add_cleanup \"unset ERL_AFLAGS\"\n    fi\n    if [ -n \"\\$ERL_AFLAGS\" ]; then\n        ERL_AFLAGS=\"-kernel shell_history enabled \\$ERL_AFLAGS\"\n    else\n        ERL_AFLAGS=\"-kernel shell_history enabled\"\n    fi\nfi\nunset _KERL_KERNEL_HISTORY\n\n# shellcheck source=/dev/null\nif [ -f \"$KERL_CONFIG\" ]; then\n    . \"$KERL_CONFIG\"\nfi\nif [ -n \"\\$KERL_ENABLE_PROMPT\" ]; then\n    if [ -n \"\\${PS1+x}\" ]; then\n        add_cleanup \"PS1=\\\"\\$PS1\\\"\"\n    else\n        add_cleanup \"unset PS1\"\n    fi\n    if [ -n \"\\$KERL_PROMPT_FORMAT\" ]; then\n        _KERL_PROMPT_FORMAT=\"\\$KERL_PROMPT_FORMAT\"\n    else\n        _KERL_PROMPT_FORMAT=\"(%BUILDNAME%)\"\n    fi\n    _KERL_PRMPT=\\$(echo \"\\$_KERL_PROMPT_FORMAT\" | sed 's^%RELEASE%^$release^;s^%BUILDNAME%^$build_name^')\n    PS1=\"\\$_KERL_PRMPT\\$PS1\"\n    unset KERL_ENABLE_PROMPT\n    unset KERL_PROMPT_FORMAT\n    unset _KERL_PRMPT\n    unset _KERL_PROMPT_FORMAT\nfi\n\nif [ -n \"\\$BASH\" ] || [ -n \"\\$ZSH_VERSION\" ]; then\n    hash -r\nfi\n\nset +o allexport\n\nunset add_cleanup\n\neval \"\nkerl_deactivate() {\n    set -o allexport\n    \\$_KERL_CLEANUP\n    unset -f kerl_deactivate\n    set +o allexport\n}\n\"\nunset _KERL_CLEANUP\n=======\n}\n\n# emit_activate_fish: outputs (via cat) the content of the 'activate' script, as used by kerl (fish)\n# @param $1/release: the <release> argument in e.g. kerl build <release> <build_name>\n# @param $2/build_name: the <build_name> argument in e.g. kerl build <release> <build_name>\n# @param $3/directory: the [directory] argument in e.g. kerl install <build_name> [directory]\nemit_activate_fish() {\n    release=$1\n    build_name=$2\n    directory=$3\n\n    cat << \\\n        =======\nif functions -q kerl_deactivate\n    kerl_deactivate\nend\n\nset _KERL (command -v kerl)\n\nif test -n \"\\$_KERL\"\n  set _KERL_VERSION (\\$_KERL version)\nend\n\nif test -n \"\\$_KERL_VERSION\" -a \"\\$_KERL_VERSION\" != \"$KERL_VERSION\"\n  echo \"WARNING: this Erlang/OTP installation appears to be stale. Please consider reinstalling.\"\n  echo \"         It was created with kerl $KERL_VERSION, and the current version is \\$_KERL_VERSION.\"\nend\n\nset -e _KERL_VERSION _KERL\n\nset -x _KERL_ACTIVE_DIR \"$directory\"\nset -p _KERL_CLEANUP \"set -e _KERL_ACTIVE_DIR;\"\n\nfunction _kerl_remove_el_ --description 'remove elements from array'\n    set path_var \\$argv[1]\n    set elements \\$argv[2]\n    echo \"\n        for el in \\\\\\$\\$elements;\n            if set -l index (contains -i -- \\\\\\$el \\\\\\$\\$path_var);\n                set -e \\$path_var[1][\\\\\\$index];\n            end;\n        end;\n    \"\nend\n\nset -x _KERL_PATH_REMOVABLE \"$directory/bin\"\nset -l _KERL_ERL_CALL_REMOVABLE (find \"$directory\" -type d -path \"*erl_interface*/bin\" 2>/dev/null)\nif test -n \"\\$_KERL_ERL_CALL_REMOVABLE\"\n    set -a _KERL_PATH_REMOVABLE \\$_KERL_ERL_CALL_REMOVABLE\nend\nset -p _KERL_CLEANUP \"set -e _KERL_PATH_REMOVABLE;\"\nset -xp PATH \\$_KERL_PATH_REMOVABLE\nset -p _KERL_CLEANUP (_kerl_remove_el_ PATH _KERL_PATH_REMOVABLE)\n\nset -x _KERL_MANPATH_REMOVABLE \"$directory/lib/erlang/man\" \"$directory/man\"\nset -p _KERL_CLEANUP \"set -e _KERL_MANPATH_REMOVABLE;\"\nif set -q MANPATH\n    if test -n \"\\$MANPATH\"\n        set -xp MANPATH \\$_KERL_MANPATH_REMOVABLE\n    else\n        set -x MANPATH \\$_KERL_MANPATH_REMOVABLE\n    end\nelse\n    set -x MANPATH \\$_KERL_MANPATH_REMOVABLE\n    set -p _KERL_CLEANUP \"\n        if test -z \\\"\\\\\\$MANPATH\\\"\n            set -e MANPATH\n        end\n    \"\nend\nset -p _KERL_CLEANUP (_kerl_remove_el_ MANPATH _KERL_MANPATH_REMOVABLE)\n\nfunctions -e _kerl_remove_el_\n\nif set -q REBAR_PLT_DIR\n    set -p _KERL_CLEANUP \"set -x REBAR_PLT_DIR \\\"\\$REBAR_PLT_DIR\\\";\"\nelse\n    set -p _KERL_CLEANUP \"set -e REBAR_PLT_DIR;\"\nend\nset -x REBAR_PLT_DIR \"$directory\"\n\nif set -q REBAR_CACHE_DIR\n    set -p _KERL_CLEANUP \"set -x REBAR_CACHE_DIR \\\"\\$REBAR_CACHE_DIR\\\";\"\nelse\n    set -p _KERL_CLEANUP \"set -e REBAR_CACHE_DIR;\"\nend\nset -x REBAR_CACHE_DIR \"$directory/.cache/rebar3\"\n\nif test -f \"$KERL_CONFIG.fish\"\n    source \"$KERL_CONFIG.fish\"\nend\nif set --query KERL_ENABLE_PROMPT\n    if functions -q fish_prompt\n        functions --copy fish_prompt _kerl_saved_prompt\n        set -p _KERL_CLEANUP \"\n            functions --copy _kerl_saved_prompt fish_prompt\n            functions --erase _kerl_saved_prompt;\n        \"\n    end\n    function fish_prompt\n        printf \"%b\" \"($build_name)\"\n        _kerl_saved_prompt\n    end\n    set -p _KERL_CLEANUP \"functions --erase fish_prompt;\"\nend\n\neval \"function kerl_deactivate -S --description \\\"deactivate erlang environment\\\"\n    \\$_KERL_CLEANUP\n    functions -e kerl_deactivate\nend\"\nset -e _KERL_CLEANUP\n=======\n}\n\n# emit_activate_csh: outputs (via cat) the content of the 'activate' script, as used by kerl (csh)\n# @param $1/release: the <release> argument in e.g. kerl build <release> <build_name>\n# @param $2/build_name: the <build_name> argument in e.g. kerl build <release> <build_name>\n# @param $3/directory: the [directory] argument in e.g. kerl install <build_name> [directory]\nemit_activate_csh() {\n    release=$1\n    build_name=$2\n    directory=$3\n\n    cat << \\\n        =======\n# This file must be used with \"source bin/activate.csh\" *from csh*.\n# You cannot run it directly.\n\n# Unset irrelevant variables.\nwhich kerl_deactivate >& /dev/null\nif ( \\$status == 0 ) then\n    kerl_deactivate\nendif\n\nset _KERL = $(command -v kerl)\n\nif ( \"\\$_KERL\" != \"\" ) then\n  set _KERL_VERSION = \\`\\$_KERL version\\`\nendif\n\nif ( \\$?_KERL_VERSION ) then\n  if ( \"\\$_KERL_VERSION\" != \"\" && \"\\$_KERL_VERSION\" != \"$KERL_VERSION\" ) then\n    echo \"WARNING: this Erlang/OTP installation appears to be stale. Please consider reinstalling.\"\n    echo \"         It was created with kerl $KERL_VERSION, and the current version is \\$_KERL_VERSION.\"\n  endif\nendif\n\nunset _KERL_VERSION _KERL\n\nalias add_cleanup 'set _KERL_CLEANUP = '\\\"'\\!:1*; \\$_KERL_CLEANUP'\\\"''\nalias _kerl_remove_el 'setenv \\!:1 \\`echo \\$\\!:1 | sed -r \"s%\\!:2*%%\"\\`'\nalias _kerl_cleanup_manpath 'eval \"if ( '\\''\\${MANPATH}'\\'' == '\\'''\\'' ) then \\\\\\\\\n    unsetenv MANPATH \\\\\\\\\nendif\"'\n\nset _KERL_CLEANUP = \"\"\n\nset _KERL_ACTIVE_DIR = \"$directory\"\nadd_cleanup unset _KERL_ACTIVE_DIR\n\nif ( \\$?REBAR_CACHE_DIR ) then\n    add_cleanup setenv REBAR_CACHE_DIR \\$REBAR_CACHE_DIR\nelse\n    add_cleanup unsetenv REBAR_CACHE_DIR\nendif\nsetenv REBAR_CACHE_DIR \"$directory/.cache/rebar3\"\n\nif ( \\$?REBAR_PLT_DIR ) then\n    add_cleanup setenv REBAR_PLT_DIR \\$REBAR_PLT_DIR\nelse\n    add_cleanup unsetenv REBAR_PLT_DIR\nendif\nsetenv REBAR_PLT_DIR \"$directory\"\n\nset _KERL_PATH_REMOVABLE = \"$directory/bin\"\nadd_cleanup setenv PATH \\$PATH\nsetenv PATH \"\\${_KERL_PATH_REMOVABLE}:\\$PATH\"\nunset _KERL_PATH_REMOVABLE\n\nset _KERL_MANPATH_REMOVABLE = \"$directory/lib/erlang/man:$directory/man\"\nif ( \\$?MANPATH ) then\n    if ( \"\\$MANPATH\" == \"\" ) then\n        setenv MANPATH \"\\${_KERL_MANPATH_REMOVABLE}\"\n    else\n        setenv MANPATH \"\\${_KERL_MANPATH_REMOVABLE}:\\$MANPATH\"\n    endif\nelse\n    add_cleanup _kerl_cleanup_manpath\n    setenv MANPATH \"\\${_KERL_MANPATH_REMOVABLE}\"\nendif\nadd_cleanup _kerl_remove_el MANPATH \\${_KERL_MANPATH_REMOVABLE}\nadd_cleanup _kerl_remove_el MANPATH \\${_KERL_MANPATH_REMOVABLE}:\nunset _KERL_MANPATH_REMOVABLE\n\nset _KERL_ERL_CALL_REMOVABLE = $(\\find \"$directory\" -type d -path '*erl_interface*/bin' 2>/dev/null)\nif (\"\\$_KERL_ERL_CALL_REMOVABLE\" != \"\") then\n    add_cleanup setenv PATH \\$PATH\n    setenv PATH \"\\${_KERL_ERL_CALL_REMOVABLE}:\\$PATH\"\nendif\nunset _KERL_ERL_CALL_REMOVABLE\n\nif ( -f \"$KERL_CONFIG.csh\" ) then\n    source \"$KERL_CONFIG.csh\"\nendif\n\nif ( \\$?KERL_ENABLE_PROMPT ) then\n    if ( \\$?KERL_PROMPT_FORMAT ) then\n        set FRMT = \"\\$KERL_PROMPT_FORMAT\"\n    else\n        set FRMT = \"(%BUILDNAME%)\"\n    endif\n    set PROMPT = \\`echo \"\\$FRMT\" | sed 's^%RELEASE%^$release^;s^%BUILDNAME%^$build_name^'\\`\n    if ( \\$?prompt ) then\n        add_cleanup set prompt = '\\$prompt'\n        set prompt = \"\\$PROMPT\\$prompt\"\n    else\n        add_cleanup unset prompt\n        set prompt = \"\\$PROMPT\"\n    endif\n    unset FRMT PROMPT\nendif\n\nrehash\n\nunalias add_cleanup\neval 'alias kerl_deactivate \"\\$_KERL_CLEANUP; unalias kerl_deactivate _kerl_remove_el _kerl_cleanup_manpath\"'\nunset _KERL_CLEANUP\n=======\n}\n\ndo_install() {\n    build_name=$1\n\n    if ! is_valid_install_path \"$2\"; then\n        exit_install\n    fi\n\n    _KERL_INSTALL_DIR=\"$2\"\n    lock_install\n\n    if ! rel=$(get_release_from_name \"$build_name\"); then\n        exit_install \"no build named '$build_name'.\"\n    fi\n\n    absdir=$(cd \"$_KERL_INSTALL_DIR\" && pwd)\n\n    notice \"Installing Erlang/OTP $rel ($build_name) in $absdir...\"\n    ERL_TOP=\"$KERL_BUILD_DIR/$build_name/otp_src_$rel\"\n    cd \"$ERL_TOP\" || exit_install\n    init_install_logfile \"$rel\" \"$build_name\"\n\n    prev_build_kernel_release=$(grep <\"$ERL_TOP\"/\"$KERL_CONFIG_STORAGE_FILENAME\" -o \"^$(uname_r_label): \\(.*\\)\\$\" | sed -n \"s|^$(uname_r_label): \\(.*\\)\\$|\\1|p\")\n    if [ \"$(uname_r)\" != \"$prev_build_kernel_release\" ]; then\n        warn \"this Erlang/OTP build appears to be stale. It was created with kernel release\"\n        warn \"         '$prev_build_kernel_release' while currently your system's kernel release is\" \"noprefix\"\n        warn \"         '$(uname_r)'.\" \"noprefix\"\n        warn \"         You should consider removing the build with 'kerl delete build ...' and\" \"noprefix\"\n        warn \"         re-installing it with 'kerl build-install ...'\" \"noprefix\"\n    fi\n\n    if ! log_install_cmd \"ERL_TOP=$ERL_TOP ./otp_build release -a $absdir && cd $absdir && ./Install $INSTALL_OPT $absdir\"; then\n        show_install_logfile \"install of Erlang/OTP $rel ($build_name), in $absdir, failed!\"\n        exit_install\n    fi\n\n    for r_type in $KERL_RELEASE_TARGET; do\n        case \"$r_type\" in\n        opt | debug)\n            notice \"Installing Erlang/OTP $rel ($build_name) ${r_type} VM in $absdir...\"\n            cd \"$ERL_TOP\" || exit_install\n            if ! log_install_cmd \"TYPE=$r_type ERL_TOP=$ERL_TOP ./otp_build release -a $absdir\"; then\n                show_install_logfile \"install Erlang/OTP $rel ($build_name) of type '$r_type', in $absdir, failed\"\n                exit_install\n            fi\n            ;;\n        *)\n            BEAM_TYPE_SMP=$(\\find . -name \"beam.${r_type}.smp\")\n            if [ -n \"$BEAM_TYPE_SMP\" ]; then\n                ERL_CHILD_SETUP_TYPE=$(\\find . -name \"erl_child_setup.${r_type}\")\n                notice \"Installing Erlang/OTP $rel ($build_name) ${r_type} VM in $absdir...\"\n                cp \"$BEAM_TYPE_SMP\" \"$absdir\"/erts-*/bin/\n                cp \"$ERL_CHILD_SETUP_TYPE\" \"$absdir\"/erts-*/bin/\n            fi\n            ;;\n        esac\n    done\n\n    [ -n \"$KERL_RELEASE_TARGET\" ] && [ -f bin/cerl ] && cp bin/cerl \"$absdir/bin\"\n\n    if ! list_add installations \"$build_name $absdir\"; then\n        exit_install\n    fi\n\n    emit_activate \"$rel\" \"$build_name\" \"$absdir\" >\"$absdir\"/activate\n    emit_activate_fish \"$rel\" \"$build_name\" \"$absdir\" >\"$absdir\"/activate.fish\n    emit_activate_csh \"$rel\" \"$build_name\" \"$absdir\" >\"$absdir\"/activate.csh\n\n    if [ -n \"$KERL_BUILD_DOCS\" ]; then\n        if ! cd \"$ERL_TOP\"; then\n            error \"couldn't cd into $ERL_TOP.\"\n            exit_install\n        fi\n        if ! log_install_cmd \"ERL_TOP=$ERL_TOP make release_docs DOC_TARGETS=\\\"$KERL_DOC_TARGETS\\\" RELEASE_ROOT=$absdir\"; then\n            show_install_logfile \"couldn't install docs for Erlang/OTP $rel ($build_name) in $absdir\"\n            exit_install\n        fi\n    else\n        if [ \"$KERL_BUILD_BACKEND\" = 'tarball' ]; then\n            if [ \"$rel\" != 'git' ]; then\n                if [ -n \"$KERL_INSTALL_MANPAGES\" ]; then\n                    notice \"Fetching and installing man pages...\"\n                    if ! download_manpages \"$rel\"; then\n                        exit_install\n                    fi\n                fi\n\n                if [ -n \"$KERL_INSTALL_HTMLDOCS\" ]; then\n                    notice \"Fetching and installing HTML docs...\"\n                    if ! download_htmldocs \"$rel\"; then\n                        exit_install\n                    fi\n                fi\n            fi\n        fi\n    fi\n\n    KERL_CONFIG_STORAGE_PATH=\"$KERL_BUILD_DIR/$build_name/otp_src_$rel/$KERL_CONFIG_STORAGE_FILENAME\"\n    [ -e \"$KERL_CONFIG_STORAGE_PATH\" ] && cp \"$KERL_CONFIG_STORAGE_PATH\" \"$absdir/$KERL_CONFIG_STORAGE_FILENAME\"\n\n    if [ -n \"$KERL_BUILD_PLT\" ]; then\n        notice \"Building Dialyzer PLT...\"\n        if ! build_plt \"$absdir\"; then\n            exit_install\n        fi\n    fi\n\n    PID=$$\n    if command -v apk >/dev/null 2>&1; then\n        # Running on Alpine Linux, assuming non-exotic shell\n        SHELL_SUFFIX=''\n    elif [ \"$(\\ps -p \"$PID\" -o ppid= | tr -d ' ')\" -eq 0 ]; then\n        SHELL_SUFFIX=''\n    else\n        PARENT_PID=$(\\ps -p \"$PID\" -o ppid= | tr -d ' ') || exit 1\n        PARENT_CMD=$(\\ps -p \"$PARENT_PID\" -o ucomm | tail -n 1 | tr -d ' ')\n        case \"$PARENT_CMD\" in\n        fish)\n            SHELL_SUFFIX='.fish'\n            ;;\n        csh)\n            SHELL_SUFFIX='.csh'\n            ;;\n        *)\n            SHELL_SUFFIX=''\n            ;;\n        esac\n    fi\n\n    tip \"You can activate this installation running the following command:\"\n    tip \". $absdir/activate$SHELL_SUFFIX\"\n    tip \"Later on, you can leave the installation typing:\"\n    tip \"kerl_deactivate\"\n\n    unlock_install\n}\n\ndownload_manpages() {\n    FILENAME=otp_doc_man_$1.tar.gz\n    if ! tarball_download \"$FILENAME\"; then\n        return 1\n    fi\n    notice \"Extracting man pages...\"\n    (cd \"$absdir\" && unpack \"$KERL_DOWNLOAD_DIR/$FILENAME\")\n}\n\ndownload_htmldocs() {\n    FILENAME=otp_doc_html_\"$1\".tar.gz\n    if ! tarball_download \"$FILENAME\"; then\n        return 1\n    fi\n    notice \"Extracting HTML docs...\"\n    (cd \"$absdir\" && mkdir -p html && cd html && unpack \"$KERL_DOWNLOAD_DIR/$FILENAME\")\n}\n\nbuild_plt() {\n    dialyzerd=\"$1\"/dialyzer\n    if ! mkdir -p \"$dialyzerd\"; then\n        error \"couldn't create folder $dialyzerd.\"\n        return 1\n    fi\n    plt=\"$dialyzerd\"/plt\n    build_log=\"$dialyzerd\"/build.log\n    dirs=$(\\find \"$1\"/lib -maxdepth 2 -name ebin -type d -exec dirname {} \\;)\n    apps=$(for app in $dirs; do basename \"$app\" | cut -d- -f1; done | \\grep -Ev 'erl_interface|jinterface' | xargs echo)\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    \"$1\"/bin/dialyzer --output_plt \"$plt\" --build_plt --apps $apps >>\"$build_log\" 2>&1\n    status=$?\n    if [ \"$status\" -eq 0 ] || [ \"$status\" -eq 2 ]; then\n        success \"Done building $plt.\"\n        return 0\n    else\n        error \"building Dialyzer PLT; see $build_log for details.\"\n        return 1\n    fi\n}\n\ndo_plt() {\n    ACTIVE_PATH=\"$1\"\n    if [ -n \"$ACTIVE_PATH\" ]; then\n        plt=\"$ACTIVE_PATH\"/dialyzer/plt\n        if [ -f \"$plt\" ]; then\n            notice \"The Dialyzer PLT for the active installation is:\"\n            success \"$plt\"\n            return 0\n        else\n            warn \"there is no Dialyzer PLT for the active installation.\"\n            return 1\n        fi\n    else\n        warn \"no Erlang/OTP installation is currently active.\"\n        return 1\n    fi\n}\n\nprint_buildopts() {\n    buildopts=\"$1/$KERL_CONFIG_STORAGE_FILENAME\"\n    if [ -f \"$buildopts\" ]; then\n        notice \"The build options for the active installation are:\"\n        cat \"$buildopts\"\n    else\n        error \"the build options for the active installation are not available.\"\n    fi\n}\n\ndo_deploy() {\n    if [ -z \"$1\" ]; then\n        error \"no host given!\"\n        exit 1\n    fi\n    host=\"$1\"\n\n    if ! is_valid_installation \"$2\"; then\n        error \"'$2' is not a kerl-managed Erlang/OTP installation.\"\n        exit 1\n    fi\n    rel=\"$(get_name_from_install_path \"$2\")\"\n    path=\"$2\"\n    remotepath=\"$path\"\n\n    if [ -n \"$3\" ]; then\n        remotepath=\"$3\"\n    fi\n\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    # shellcheck disable=SC2154  # KERL_DEPLOY_SSH_OPTIONS is referenced but not assigned\n    if ! ssh $KERL_DEPLOY_SSH_OPTIONS \"$host\" true >/dev/null 2>&1; then\n        error \"couldn't ssh to $host.\"\n        exit 1\n    fi\n\n    notice \"Cloning Erlang/OTP $rel ($path) to $host ($remotepath)...\"\n\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    # shellcheck disable=SC2154  # KERL_DEPLOY_RSYNC_OPTIONS is referenced but not assigned\n    if ! rsync -aqz -e \"ssh $KERL_DEPLOY_SSH_OPTIONS\" $KERL_DEPLOY_RSYNC_OPTIONS \"$path/\" \"$host:$remotepath/\"; then\n        error \"couldn't rsync Erlang/OTP $rel ($path) to $host ($remotepath).\"\n        exit 1\n    fi\n\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    # shellcheck disable=SC2029  # Note that, unescaped, this expands on the client side\n    if ! ssh $KERL_DEPLOY_SSH_OPTIONS \"$host\" \"cd \\\"$remotepath\\\" && env ERL_TOP=\\\"\\$(pwd)\\\" ./Install $INSTALL_OPT \\\"\\$(pwd)\\\" >/dev/null 2>&1\"; then\n        error \"couldn't install Erlang/OTP $rel to $host ($remotepath).\"\n        exit 1\n    fi\n\n    # shellcheck disable=SC2086  # Double quote to prevent globbing and word splitting\n    # shellcheck disable=SC2029  # Note that, unescaped, this expands on the client side\n    if ! ssh $KERL_DEPLOY_SSH_OPTIONS \"$host\" \"cd \\\"$remotepath\\\" && sed -i -e \\\"s#$path#\\\"\\$(pwd)\\\"#g\\\" activate\"; then\n        error \"couldn't completely install Erlang/OTP $rel to $host ($remotepath).\"\n        exit 1\n    fi\n\n    tip \"On $host, you can activate this installation running the following command:\"\n    tip \". $remotepath/activate\"\n    tip \"Later on, you can leave the installation typing:\"\n    tip \"kerl_deactivate\"\n}\n\n# Quoted from https://github.com/mkropat/sh-realpath\n# LICENSE: MIT\n\nrealpath() {\n    canonicalize_path \"$(resolve_symlinks \"$1\")\"\n}\n\nresolve_symlinks() {\n    _resolve_symlinks \"$1\"\n}\n\n_resolve_symlinks() {\n    _assert_no_path_cycles \"$@\" || return 0\n\n    if path=$(readlink -- \"$1\"); then\n        dir_context=$(dirname -- \"$1\")\n        _resolve_symlinks \"$(_prepend_dir_context_if_necessary \"$dir_context\" \"$path\")\" \"$@\"\n    else\n        printf '%s\\n' \"$1\"\n    fi\n}\n\n_prepend_dir_context_if_necessary() {\n    if [ \"$1\" = . ]; then\n        printf '%s\\n' \"$2\"\n    else\n        _prepend_path_if_relative \"$1\" \"$2\"\n    fi\n}\n\n_prepend_path_if_relative() {\n    case \"$2\" in\n    /*) printf '%s\\n' \"$2\" ;;\n    *) printf '%s\\n' \"$1/$2\" ;;\n    esac\n}\n\n_assert_no_path_cycles() {\n    target=$1\n    shift\n\n    for path in \"$@\"; do\n        if [ \"$path\" = \"$target\" ]; then\n            return 1\n        fi\n    done\n}\n\ncanonicalize_path() {\n    if [ -d \"$1\" ]; then\n        _canonicalize_dir_path \"$1\"\n    else\n        _canonicalize_file_path \"$1\"\n    fi\n}\n\n_canonicalize_dir_path() {\n    (cd \"$1\" 2>/dev/null && pwd -P)\n}\n\n_canonicalize_file_path() {\n    dir=$(dirname -- \"$1\")\n    file=$(basename -- \"$1\")\n    (cd \"$dir\" 2>/dev/null && printf '%s/%s\\n' \"$(pwd -P)\" \"$file\")\n}\n\n# END QUOTE\n\nis_valid_install_path() {\n    # don't allow installs into .erlang because\n    # it's a special configuration file location for OTP\n    if [ \"$(basename -- \"$1\")\" = '.erlang' ]; then\n        error \"you cannot install a build into .erlang, as it is a special configuration file location for OTP!\"\n        return 1\n    fi\n\n    candidate=$(realpath \"$1\")\n    canonical_home=$(realpath \"$HOME\")\n    canonical_base_dir=$(realpath \"$KERL_BASE_DIR\")\n\n    # don't allow installs into home directory\n    if [ \"$candidate\" = \"$canonical_home\" ]; then\n        error \"you cannot install a build into $HOME. It's a really bad idea!\"\n        return 1\n    fi\n\n    # don't install into our base directory either.\n    if [ \"$candidate\" = \"$canonical_base_dir\" ]; then\n        error \"you cannot install a build into $KERL_BASE_DIR.\"\n        return 1\n    fi\n\n    INSTALLED_NAME=$(get_name_from_install_path \"$candidate\")\n    if [ -n \"$INSTALLED_NAME\" ]; then\n        error \"installation '$INSTALLED_NAME' already registered for this location ($1).\"\n        return 1\n    fi\n\n    # if the install directory exists,\n    # do not allow installs into a directory that is not empty\n    if [ -e \"$1\" ]; then\n        if [ ! -d \"$1\" ]; then\n            error \"$1 is not a directory.\"\n            return 1\n        else\n            count=$(\\find \"$1\" | wc -l)\n            if [ \"$count\" -ne 1 ]; then\n                error \"$1 does not appear to be an empty directory.\"\n                return 1\n            fi\n        fi\n    fi\n}\n\nmaybe_remove() {\n    candidate=$(realpath \"$1\")\n    canonical_home=$(realpath \"$HOME\")\n\n    if [ \"$candidate\" = \"$canonical_home\" ]; then\n        warn \"you cannot remove an install from '$HOME'; it's your home directory!\"\n        return 0\n    fi\n\n    ACTIVE_PATH=\"$(get_active_path)\"\n    if [ \"$candidate\" = \"$ACTIVE_PATH\" ]; then\n        error \"you cannot delete the active installation. Deactivate it first.\"\n        return 1\n    fi\n\n    rm -Rf \"$1\"\n}\n\nlist_print() {\n    list_type=$1 # releases | builds | installations\n    maybe_all=$2\n\n    list=$KERL_BASE_DIR/otp_${list_type}\n    if [ -f \"$list\" ]; then\n        if [ \"$(\\wc -l \"$list\")\" != '0' ]; then\n            if [ \"${list_type}\" = releases ] && [ \"$maybe_all\" != all ]; then\n                awk -v oldest_listed=\"$OLDEST_OTP_LISTED\" \\\n                    -v oldest_supported=\"$OLDEST_OTP_SUPPORTED\" \\\n                    -v include_rc=\"$KERL_INCLUDE_RELEASE_CANDIDATES\" '\n                function _print(vsn, is_this_supported) {\n                    if (is_this_supported) {\n                        suf=\" *\"\n                    }\n                    printf \"%s%s\\n\", vsn, suf\n                }\n                {\n                    this_version=$0\n                    split(this_version, version_components, \".\")\n                    this_major=version_components[1]\n\n                    if (last_major == \"\") {\n                        last_major = oldest_supported - 1\n                    }\n\n                    is_this_r=/^R/\n                    is_this_rc=/-rc/\n                    is_rc_printable=(include_rc == \"yes\")\n                    is_this_supported=(last_major >= oldest_supported)\n\n                    if (!is_this_r) {\n                        is_transition_to_rc=(is_last_not_rc && is_this_rc)\n                        is_transition_from_rc=(!is_last_not_rc && !is_this_rc && is_rc_printable)\n                        (is_transition_to_rc || is_transition_from_rc) \\\n                            && _print(last_version, is_this_supported)\n\n                        last_version=this_version\n                        last_major=this_major\n                        is_last_not_rc=!is_this_rc\n                    }\n                }\n                END {\n                    last_version=$0\n                    is_supported=1\n                    (!is_this_rc || is_rc_printable) \\\n                        && _print(last_version, is_supported)\n                }' \"$list\"\n            else\n                cat \"$KERL_BASE_DIR/otp_$1\"\n            fi\n\n            return 0\n        fi\n    fi\n    notice \"There are no $1 available.\"\n}\n\nlist_add() {\n    if [ -f \"$KERL_BASE_DIR/otp_$1\" ]; then\n        while read -r l; do\n            if [ \"$l\" = \"$2\" ]; then\n                return 0\n            fi\n        done <\"$KERL_BASE_DIR/otp_$1\"\n        if ! echo \"$2\" | tee -a \"$KERL_BASE_DIR/otp_$1\" >/dev/null 2>&1; then\n            error \"file $KERL_BASE_DIR/otp_$1 does not appear to be writable.\"\n            return 1\n        fi\n    else\n        if ! echo \"$2\" | tee \"$KERL_BASE_DIR/otp_$1\" >/dev/null 2>&1; then\n            error \"file $KERL_BASE_DIR/otp_$1 does not appear to be writable.\"\n            return 1\n        fi\n    fi\n}\n\nlist_remove() {\n    if [ -f \"$KERL_BASE_DIR/otp_$1\" ]; then\n        if ! sed \"$SED_OPT\" -i -e \"/^.*$2$/d\" \"$KERL_BASE_DIR/otp_$1\" 2>/dev/null; then\n            error \"file $KERL_BASE_DIR/otp_$1 does not appear writable.\"\n            return 1\n        fi\n    fi\n}\n\nget_active_path() {\n    if [ -n \"$_KERL_ACTIVE_DIR\" ]; then\n        echo \"$_KERL_ACTIVE_DIR\"\n    fi\n}\n\nfix_otp_installations() {\n    if [ -f \"$KERL_BASE_DIR\"/otp_installations ]; then\n        missing_paths=\"\"\n        while read -r l; do\n            path=$(echo \"$l\" | cut -d' ' -f2)\n            if [ ! -e \"$path\" ]; then\n                missing_paths=\"$path $missing_paths\"\n            fi\n        done <\"$KERL_BASE_DIR\"/otp_installations\n        for missing_path in ${missing_paths}; do\n            escaped=\"$(echo \"$missing_path\" | \\sed \"$SED_OPT\" -e 's#/$##' -e 's#\\/#\\\\\\/#g')\"\n            list_remove installations \"$escaped\"\n        done\n    fi\n}\n\nfix_otp_builds() {\n    if [ -f \"$KERL_BASE_DIR\"/otp_builds ]; then\n        missing_keys=\"\"\n        while read -r l; do\n            rel=$(echo \"$l\" | cut -d, -f1)\n            name=$(echo \"$l\" | cut -d, -f2)\n            if [ ! -e \"${KERL_BUILD_DIR}/${name}\" ]; then\n                missing_keys=\"${rel},${name} $missing_keys\"\n            fi\n        done <\"$KERL_BASE_DIR\"/otp_builds\n        for missing_key in ${missing_keys}; do\n            list_remove builds \"${missing_key}\"\n        done\n    fi\n}\n\nget_name_from_install_path() {\n    if [ -f \"$KERL_BASE_DIR\"/otp_installations ]; then\n        \\grep -m1 -E \"$1$\" \"$KERL_BASE_DIR\"/otp_installations | cut -d' ' -f1\n    fi\n}\n\nget_install_path_from_name() {\n    if [ -f \"$KERL_BASE_DIR\"/otp_installations ]; then\n        \\grep -m1 -E \"$1$\" \"$KERL_BASE_DIR\"/otp_installations | cut -d' ' -f2\n    fi\n}\n\ndo_active() {\n    ACTIVE_PATH=\"$(get_active_path)\"\n    if [ -n \"$ACTIVE_PATH\" ]; then\n        notice \"The current active installation is:\"\n        echo \"$ACTIVE_PATH\"\n        return 0\n    else\n        error \"no Erlang/OTP installation is currently active.\"\n        return 1\n    fi\n}\n\ndownload() {\n    # $1: release\n\n    if ! mkdir -p \"$KERL_DOWNLOAD_DIR\"; then\n        error \"couldn't create folder $KERL_DOWNLOAD_DIR.\"\n        return 1\n    fi\n    if [ \"$KERL_BUILD_BACKEND\" = 'git' ]; then\n        FILENAME=\"OTP-$1\"\n        if ! github_download \"$1\" \"$FILENAME\".tar.gz; then\n            return 1\n        fi\n    else\n        FILENAME=\"otp_src_$1\"\n        if ! tarball_download \"$FILENAME\".tar.gz; then\n            return 1\n        fi\n    fi\n}\n\ngithub_download() {\n    tarball_file=\"$KERL_DOWNLOAD_DIR/$2\"\n    tarball_url=\"$OTP_GITHUB_URL/archive/$2\"\n    prebuilt_url=\"$OTP_GITHUB_URL/releases/download/OTP-$1/otp_src_$1.tar.gz\"\n    http_code=$(_curl /dev/null \"$prebuilt_url\" \"-I\")\n    if [ 200 = \"$http_code\" ]; then\n        tarball_url=$prebuilt_url\n        unset KERL_USE_AUTOCONF\n    fi\n    # if the file doesn't exist or the file has no size\n    if [ ! -s \"$tarball_file\" ]; then\n        notice \"Downloading (from GitHub) Erlang/OTP $1 to $KERL_DOWNLOAD_DIR...\"\n        http_code=$(_curl \"$tarball_file\" \"$tarball_url\")\n        if [ 200 != \"$http_code\" ]; then\n            error \"$tarball_url returned $http_code!\"\n            return 1\n        fi\n    else\n        # If the downloaded tarball was corrupted due to interruption while\n        # downloading.\n        if ! gunzip -t \"$tarball_file\" 2>/dev/null; then\n            notice \"$tarball_file (from GitHub) corrupted; re-downloading...\"\n            rm -rf \"$tarball_file\"\n            http_code=$(_curl \"$tarball_file\" \"$tarball_url\")\n            if [ 200 != \"$http_code\" ]; then\n                error \"$tarball_url returned $http_code!\"\n                return 1\n            fi\n        fi\n    fi\n}\n\ntarball_download() {\n    if [ ! -s \"$KERL_DOWNLOAD_DIR/$1\" ]; then\n        notice \"Downloading tarball $1 to $KERL_DOWNLOAD_DIR...\"\n        http_code=$(_curl \"$KERL_DOWNLOAD_DIR/$1\" \"$ERLANG_DOWNLOAD_URL/$1\")\n        if [ 200 != \"$http_code\" ]; then\n            error \"$ERLANG_DOWNLOAD_URL/$1 returned $http_code!\"\n            return 1\n        fi\n        if ! update_checksum_file; then\n            return 1\n        fi\n    fi\n    if ! ensure_checksum_file; then\n        return 1\n    fi\n    notice \"Tarball archive checksum being verified...\"\n    SUM=\"$($MD5SUM \"$KERL_DOWNLOAD_DIR/$1\" | cut -d' ' -f \"$MD5SUM_FIELD\")\"\n    ORIG_SUM=\"$(\\grep -F \"$1\" \"$KERL_DOWNLOAD_DIR\"/MD5 | cut -d' ' -f2)\"\n    if [ \"$SUM\" != \"$ORIG_SUM\" ]; then\n        error \"checksum error; check file $1 in $KERL_DOWNLOAD_DIR.\"\n        return 1\n    fi\n    success \"Checksum verified: $SUM.\"\n}\n\nupgrade_kerl() {\n    install_folder=$1\n    http_code=$(_curl \"$install_folder/kerl\" \"$KERL_GIT_BASE\"/kerl)\n    if [ 200 != \"$http_code\" ]; then\n        error \"$KERL_GIT_BASE/kerl returned $http_code!\"\n        return 1\n    fi\n    chmod +x \"$install_folder/kerl\"\n    version=$(kerl version)\n    current_kerl_path=\"$(command -v kerl)\"\n    notice \"kerl $version is now available at $current_kerl_path.\"\n}\n\nfix_otp_builds\nfix_otp_installations\n\ncase \"$1\" in\nversion)\n    if [ $# -ne 1 ]; then\n        usage_exit \"version\"\n    fi\n\n    echo \"$KERL_VERSION\"\n    ;;\nbuild)\n    if [ \"$2\" = 'git' ]; then\n        if [ $# -ne 5 ]; then\n            usage_exit \"build git <git_url> <git_version> <build_name>\"\n        fi\n\n        do_git_build \"$3\" \"$4\" \"$5\"\n    else\n        if [ $# -lt 2 ] || [ $# -gt 3 ]; then\n            usage_exit \"build <release> [build_name]\"\n        fi\n\n        if [ $# -eq 2 ]; then\n            do_normal_build \"$2\" \"$2\"\n        else\n            do_normal_build \"$2\" \"$3\"\n        fi\n    fi\n    ;;\nbuild-install)\n    # naming contains _or_ because do_build_install either accepts $2 as \"git\" or otherwise\n    release_or_git=\"$2\"\n    build_name_or_git_url=\"$3\"\n    directory_or_git_version=\"$4\"\n    build_name=\"$5\"\n    directory=\"$6\"\n\n    if [ \"$release_or_git\" = \"git\" ]; then\n        if [ $# -lt 5 ] || [ $# -gt 6 ]; then\n            usage_exit \"build-install git <git_url> <git_version> <build_name> [directory]\"\n        fi\n\n        git_url=\"$build_name_or_git_url\"\n        git_version=\"$directory_or_git_version\"\n    else\n        if [ $# -lt 2 ] || [ $# -gt 4 ]; then\n            usage_exit \"build-install <release> [build_name] [directory]\"\n        fi\n\n        release=\"$release_or_git\"\n        build_name=\"$build_name_or_git_url\"\n        git_url=\"_unused_\"\n        directory=\"$directory_or_git_version\"\n        git_version=\"_unused_\"\n        if [ $# -eq 2 ]; then\n            build_name=\"$release\"\n        fi\n    fi\n    if [ -z \"$directory\" ]; then\n        if [ -z \"$KERL_DEFAULT_INSTALL_DIR\" ]; then\n            directory=\"$PWD\"\n        else\n            directory=\"$KERL_DEFAULT_INSTALL_DIR/$build_name\"\n        fi\n    fi\n    do_build_install \"$release_or_git\" \"$git_url\" \"$git_version\" \"$build_name\" \"$directory\"\n    ;;\ninstall)\n    if [ $# -lt 2 ] || [ $# -gt 3 ]; then\n        usage_exit \"install <build_name> [directory]\"\n    fi\n\n    if [ $# -eq 3 ]; then\n        do_install \"$2\" \"$3\"\n    else\n        if [ -z \"$KERL_DEFAULT_INSTALL_DIR\" ]; then\n            do_install \"$2\" \"$PWD\"\n        else\n            do_install \"$2\" \"$KERL_DEFAULT_INSTALL_DIR/$2\"\n        fi\n    fi\n    ;;\ndeploy)\n    if [ $# -lt 2 ] || [ $# -gt 4 ]; then\n        usage_exit \"deploy <[user@]host> [directory] [remote_directory]\"\n    fi\n\n    if [ $# -eq 4 ]; then\n        do_deploy \"$2\" \"$3\" \"$4\"\n    elif [ $# -eq 3 ]; then\n        do_deploy \"$2\" \"$3\"\n    else\n        do_deploy \"$2\" .\n    fi\n    ;;\nupdate)\n    if [ $# -ne 2 ] || [ \"$2\" != \"releases\" ]; then\n        usage_exit \"update releases\"\n    fi\n\n    if ! check_releases force; then\n        exit 1\n    else\n        notice \"The available releases are:\"\n        list_print releases\n    fi\n    ;;\nupgrade)\n    if [ $# -ne 1 ]; then\n        usage_exit \"upgrade\"\n    fi\n\n    current_kerl_path=\"$(command -v kerl)\"\n    which_status=$?\n    if [ \"$which_status\" != 0 ]; then\n        if [ -z ${KERL_APP_INSTALL_DIR+x} ]; then\n            install_folder=\"$PWD\"\n        else\n            install_folder=\"$KERL_APP_INSTALL_DIR\"\n        fi\n        notice \"kerl not installed. Dropping it into $install_folder/kerl...\"\n        upgrade_kerl \"$install_folder\"\n    else\n        version=$(kerl version)\n        notice \"Local kerl found ($current_kerl_path) at version $version.\"\n        latest=$(_curl body_only \"$KERL_GIT_BASE\"/LATEST)\n        notice \"Remote kerl found at version $latest.\"\n        if [ \"$version\" != \"$latest\" ]; then\n            notice \"Versions are different. Upgrading to $latest...\"\n            current_kerl_path=$(dirname \"$current_kerl_path\")\n            if ! upgrade_kerl \"$current_kerl_path\"; then\n                exit 1\n            fi\n        else\n            success \"No upgrade required.\"\n        fi\n        notice \"Updating list of available releases... \"\n        kerl update releases >/dev/null\n        notice \"... done!\"\n    fi\n    ;;\nlist)\n    case \"$2\" in\n    releases)\n        if [ $# -lt 2 ] || [ $# -gt 3 ] || { [ $# -eq 3 ] && [ \"$3\" != 'all' ]; }; then\n            usage_exit \"list releases [all]\"\n        fi\n\n        if ! check_releases; then\n            exit 1\n        fi\n        list_print \"$2\" \"$3\"\n        tip \"Run '$0 update releases' to update this list.\"\n        if [ $# -eq 2 ]; then\n            tip \"Run '$0 list releases all' to view all available releases.\"\n            tip \"Note: * means \\\"currently supported\\\".\"\n        fi\n        ;;\n    builds)\n        if [ $# -ne 2 ]; then\n            usage_exit \"list builds\"\n        fi\n\n        list_print \"$2\"\n        ;;\n    installations)\n        if [ $# -ne 2 ]; then\n            usage_exit \"list installations\"\n        fi\n\n        list_print \"$2\"\n        ;;\n    *)\n        if [ -n \"$2\" ]; then\n            error \"cannot list (unknown) $2.\"\n        fi\n        usage_exit \"list <releases|builds|installations> [all]\"\n        ;;\n    esac\n    ;;\npath)\n    if [ $# -lt 1 ] || [ $# -gt 2 ]; then\n        usage_exit \"path [installation]\"\n    fi\n\n    # Usage:\n    # kerl path\n    # # Print currently active installation path, else non-zero exit\n    # kerl path <install>\n    # Print path to installation with name <install>, else non-zero exit\n    if [ -z \"$2\" ]; then\n        activepath=$(get_active_path)\n        if [ -z \"$activepath\" ]; then\n            warn \"no active kerl-managed Erlang/OTP installation.\"\n            exit 1\n        fi\n        tip \"$activepath\"\n    else\n        # There are some possible extensions to this we could\n        # consider, such as:\n        # - if 2+ matches: prefer one in a sub dir from $PWD\n        # - prefer $KERL_DEFAULT_INSTALL_DIR\n        match=\n        for ins in $(list_print installations | cut -d' ' -f2); do\n            if [ \"$(basename \"$ins\")\" = \"$2\" ]; then\n                if [ -z \"$match\" ]; then\n                    match=\"$ins\"\n                else\n                    error \"too many matching installations.\"\n                    exit 1\n                fi\n            fi\n        done\n        if [ -n \"$match\" ]; then\n            echo \"$match\"\n        else\n            error \"no matching installation found.\"\n            exit 1\n        fi\n    fi\n    ;;\ndelete)\n    case \"$2\" in\n    build)\n        if [ $# -ne 3 ]; then\n            usage_exit \"delete build [build_name]\"\n        fi\n\n        rel=\"$(get_release_from_name \"$3\")\"\n        if [ -d \"${KERL_BUILD_DIR:?}/$3\" ]; then\n            if ! maybe_remove \"${KERL_BUILD_DIR:?}/$3\"; then\n                exit 1\n            fi\n        else\n            if [ -z \"$rel\" ]; then\n                error \"no build named '$3'!\"\n                exit 1\n            fi\n        fi\n        if ! list_remove \"$2\"s \"$rel,$3\"; then\n            exit 1\n        fi\n        notice \"Build '$3' has been deleted.\"\n        ;;\n    installation)\n        if [ $# -ne 3 ]; then\n            usage_exit \"delete installation <build_name|directory>\"\n        fi\n\n        if ! is_valid_installation \"$3\"; then\n            error \"'$3' is not a kerl-managed Erlang/OTP installation.\"\n            exit 1\n        fi\n        if [ -d \"$3\" ]; then\n            if ! maybe_remove \"$3\"; then\n                exit 1\n            fi\n        else\n            if ! maybe_remove \"$(get_install_path_from_name \"$3\")\"; then\n                exit 1\n            fi\n        fi\n        escaped=\"$(echo \"$3\" | \\sed \"$SED_OPT\" -e 's#/$##' -e 's#\\/#\\\\\\/#g')\"\n        if ! list_remove \"$2\"s \"$escaped\"; then\n            exit 1\n        fi\n        notice \"Installation '$3' has been deleted.\"\n        ;;\n    *)\n        if [ -n \"$2\" ]; then\n            error \"cannot delete $2.\"\n        fi\n        usage_exit \"delete <build|installation> <build_name or directory>\"\n        ;;\n    esac\n    ;;\nactive)\n    if [ $# -ne 1 ]; then\n        usage_exit \"active\"\n    fi\n\n    if ! do_active; then\n        exit 1\n    fi\n    ;;\nplt)\n    if [ $# -ne 1 ]; then\n        usage_exit \"plt\"\n    fi\n\n    ACTIVE_PATH=$(get_active_path)\n    if ! do_plt \"$ACTIVE_PATH\"; then\n        exit 1\n    fi\n    ;;\nstatus)\n    if [ $# -ne 1 ]; then\n        usage_exit \"status\"\n    fi\n\n    notice \"Available builds:\"\n    list_print builds\n    nocolor '----------'\n    notice \"Available installations:\"\n    list_print installations\n    nocolor '----------'\n    if ! do_active; then\n        exit 1\n    fi\n\n    ACTIVE_PATH=$(get_active_path)\n    do_plt \"$ACTIVE_PATH\"\n    print_buildopts \"$ACTIVE_PATH\"\n    ;;\nprompt)\n    if [ $# -ne 1 ]; then\n        usage_exit \"prompt\"\n    fi\n\n    FMT=' (%s)'\n    if [ -n \"$2\" ]; then\n        FMT=\"$2\"\n    fi\n    ACTIVE_PATH=\"$(get_active_path)\"\n    if [ -n \"$ACTIVE_PATH\" ]; then\n        ACTIVE_NAME=\"$(get_name_from_install_path \"$ACTIVE_PATH\")\"\n        if [ -z \"$ACTIVE_NAME\" ]; then\n            VALUE=\"$(basename \"$ACTIVE_PATH\")*\"\n        else\n            VALUE=\"$ACTIVE_NAME\"\n        fi\n        # shellcheck disable=SC2059  # Don't use variables in the printf format string. Use printf \"..%s..\" \"$foo\"\n        printf \"$FMT\" \"$VALUE\"\n    fi\n    ;;\ncleanup)\n    if [ $# -ne 2 ]; then\n        usage_exit \"cleanup <build_name|all>\"\n    fi\n\n    case \"$2\" in\n    all)\n        notice \"Cleaning up compilation products for ALL builds under:\"\n        notice \"  - $KERL_BUILD_DIR...\"\n        rm -rf \"${KERL_BUILD_DIR:?}\"/*\n        notice \"  - $KERL_DOWNLOAD_DIR...\"\n        rm -rf \"${KERL_DOWNLOAD_DIR:?}\"/*\n        notice \"  - $KERL_GIT_DIR...\"\n        rm -rf \"${KERL_GIT_DIR:?}\"/*\n        notice \"... done.\"\n        ;;\n    *)\n        notice \"Cleaning up compilation products for '$2' under:\"\n        notice \"  - $KERL_BUILD_DIR...\"\n        rm -rf \"${KERL_BUILD_DIR:?}/$2\"\n        rel=$(get_release_from_name \"$2\")\n        if [ \"${rel}\" != \"git\" ]; then\n            notice \"  - $KERL_DOWNLOAD_DIR...\"\n            rm -f \"${KERL_DOWNLOAD_DIR:?}\"/OTP-\"$2\".tar.gz\n            rm -f \"${KERL_DOWNLOAD_DIR:?}\"/otp_src_\"$2\".tar.gz\n            rm -f \"${KERL_DOWNLOAD_DIR:?}\"/otp_doc_man_\"$2\".tar.gz\n            rm -f \"${KERL_DOWNLOAD_DIR:?}\"/otp_doc_html_\"$2\".tar.gz\n        fi\n        notice \"... done.\"\n        ;;\n    esac\n    ;;\nemit-activate)\n    release=$2\n    build_name=$3\n    directory=$4\n    shell=$5\n\n    if [ $# -lt 4 ] || [ $# -gt 5 ] ||\n        { [ $# -eq 5 ] && [ \"$5\" != \"sh\" ] && [ \"$5\" != \"bash\" ] && [ \"$5\" != \"fish\" ] && [ \"$5\" != \"csh\" ]; }; then\n        usage_exit \"emit-activate <release> <build_name> <directory> [sh|bash|fish|csh]\"\n    fi\n\n    if [ -z \"$5\" ]; then\n        shell=\"sh\"\n    elif [ \"$shell\" = \"bash\" ]; then\n        shell=\"sh\"\n    fi\n\n    case \"$shell\" in\n    sh)\n        emit_activate \"$release\" \"$build_name\" \"$directory\"\n        ;;\n    fish)\n        emit_activate_fish \"$release\" \"$build_name\" \"$directory\"\n        ;;\n    csh)\n        emit_activate_csh \"$release\" \"$build_name\" \"$directory\"\n        ;;\n    *) ;;\n    esac\n    ;;\n*)\n    error \"unknown command '$1'.\"\n    k_usage\n    ;;\nesac\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "zsh_completion",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}