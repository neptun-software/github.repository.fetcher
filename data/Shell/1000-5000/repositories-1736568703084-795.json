{
  "metadata": {
    "timestamp": 1736568703084,
    "page": 795,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mchav/with",
      "stars": 1228,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 0.5439453125,
          "content": "Copyright 2016 Michael Chavinda\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.6708984375,
          "content": "# with\n\n[![Join the chat at https://gitter.im/with-tool/with](https://badges.gitter.im/with-tool/with.svg)](https://gitter.im/with-tool/with?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\nProgram prefixing for continuous workflow using a single tool.\n\n### Usage\n\n`with <program>`\n\n\nStarts an interactive shell with where every command is prefixed using `<program>`.\n\nFor example:\n```sh\n$ with git\ngit> add .\ngit> commit -a -m \"Commited\"\ngit> push\n```\n\n\nCan also be used for compound commands.\n```sh\n$ with java Primes\njava Primes> 1\n2\njava Primes> 4\n7\n```\n\nAnd to repeat commands:\n```sh\n$ with gcc -o output input.c\ngcc -o -output input.c>\n<enter>\nCompiling...\ngcc -o -output input.c>\n```\n\n\nTo execute a shell command proper prefix line with `:`.\n\n\n`git> :ls`\n\nYou can also drop, add, and replace different commands.\n\n```sh\ngit> +add\ngit add> <some file>\ngit add> !commit\ngit commit> <arguments and message>\ngit commit> -\ngit>\n```\n\nTo exit use either `:q` or `:exit`.\n\n### Installation\n\nWith [apt-get](https://wiki.debian.org/apt-get):\n\n```sh\nsudo add-apt-repository ppa:mchav/with && sudo apt-get update && sudo apt-get install with\n```\n\nWith [bpkg](https://github.com/bpkg/bpkg):\n\n```sh\nbpkg install mchav/with -g\n```\n\nWith FreeBSD [pkg](https://github.com/freebsd/pkg):\n\n```sh\npkg install with\n```\n\nWith FreeBSD [ports](https://www.freshports.org/misc/with/)\n\n```sh\ncd /usr/ports/misc/with && make install clean\n```\n\nWith [rawgit](https://rawgit.com):\n\n```sh\ncurl -sLo- https://cdn.rawgit.com/mchav/with/master/install | bash\n```\n\nor:\n\n```\ncurl -s https://raw.githubusercontent.com/mchav/with/master/install | bash\n```\n\nCurrently supports command history and limited completions.\n"
        },
        {
          "name": "install",
          "type": "blob",
          "size": 0.7412109375,
          "content": "#!/usr/bin/env bash\n\nif (( `uname` == \"Darwin\" )); then\n  BIN=/usr/local/bin\n  BASH_COMPLETION_D=/usr/local/etc/bash_completion.d\n  CURL=curl\nelse\n  # check if user is root \n  # and re-exec the script with sudo if not\n  #\n  # equivalent to: [ \"$(whoami)\" != \"root\" ] && exec sudo -- \"$0\" \"$@\"\n  # bash only, but without external call to whoami\n  # \n  (( EUID != 0 )) && exec sudo -- \"$0\" \"$@\"\n  BIN=/usr/bin\n  BASH_COMPLETION_D=/etc/bash_completion.d\n  CURL=\"sudo curl\"\nfi\n\necho \"Installing with\"\n$CURL -s https://raw.githubusercontent.com/mchav/with/master/with -o $BIN/with && chmod +x $BIN/with\n$CURL -s https://raw.githubusercontent.com/mchav/with/master/with.bash-completion -o $BASH_COMPLETION_D/with.bash-completion\necho \"with successfully installed!\"\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.2490234375,
          "content": "{\n  \"name\": \"with\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Program prefixing for continuous workflow using a single tool.\",\n  \"global\": \"1\",\n  \"install\": \"install -b with ${PREFIX:-/usr/local}/bin/with\",\n  \"scripts\": [ \"with\", \"with.bash-completion\" ]\n}\n"
        },
        {
          "name": "with",
          "type": "blob",
          "size": 9.021484375,
          "content": "#!/usr/bin/env bash\nVERSION=\"0.0.2\"\n\n# with tool\n# usage: with <program>\n# opens an interactive shell instance that automatically prefixes all subsequent commands with program name\n\n# bind TAB to completion function within the script\nbind -x '\"\\C-i\": \"with_completion\"' &> /dev/null\n\nprint_version()\n{\n  echo \"with, version $VERSION\"\n  exit 0\n}\n\nprint_options()\n{\n  echo \"  -h, --help   : Display command help\"\n  echo \"  -v, --version: Display the currently installed version of with\"\n}\n\nprint_usage()\n{\n  print \"\"\"\n    USAGE:\n      with <prefix>\n\n    Prefix can be any string with a valid executable.\n  \"\"\"\n  exit 0\n}\n\n#add options here, such as -h, -v\ndeclare -a prefix\nprefix=( \"$@\" )\n\ncase ${prefix[*]} in\n  \"\" )\n    echo \"Missing arguments.\"\n    echo \"usage: with <program>\"\n    exit 1;;\n  \"-v\"|\"--version\")\n    print_version;;\n  \"-h\"|\"--help\")\n    print_help;;\n  -*|--*)\n    echo \"Unrecognised option:\" ${prefix[*]}\n    print_options\n    exit 1;;\nesac\n\npmpt=${prefix[*]}\n\nsetup()\n{\n\n  # source bash completions\n  [ -f /etc/bash_completion ] && source /etc/bash_completion\n\n  BASH_COMPLETION_DEFAULT_DIR=/usr/share/bash-completion/completions\n  for completion_file in $BASH_COMPLETION_DEFAULT_DIR/* $BASH_COMPLETION_COMPAT_DIR/*\n  do\n    . \"$completion_file\" &> /dev/null\n  done\n\n  # initialise history file\n  touch /tmp/with_history\n\n  # set up colour codes\n  __blk=\"$(tput setaf 0)\"\n  __red=\"$(tput setaf 1)\"\n  __grn=\"$(tput setaf 2)\"\n  __yel=\"$(tput setaf 3)\"\n  __blu=\"$(tput setaf 4)\"\n  __mag=\"$(tput setaf 5)\"\n  __cyn=\"$(tput setaf 6)\"\n  __wht=\"$(tput setaf 7)\"\n\n  __bold_blk=\"$__bold$__blk\"\n  __bold_red=\"$__bold$__red\"\n  __bold_grn=\"$__bold$__grn\"\n  __bold_yel=\"$__bold$__yel\"\n  __bold_blu=\"$__bold$__blu\"\n  __bold_mag=\"$__bold$__mag\"\n  __bold_cyn=\"$__bold$__cyn\"\n  __bold_wht=\"$__bold$__wht\"\n\n  __on_blk=\"$(tput setab 0)\"\n  __on_red=\"$(tput setab 1)\"\n  __on_grn=\"$(tput setab 2)\"\n  __on_yel=\"$(tput setab 3)\"\n  __on_blu=\"$(tput setab 4)\"\n  __on_mag=\"$(tput setab 5)\"\n  __on_cyn=\"$(tput setab 6)\"\n  __on_wht=\"$(tput setab 7)\"\n\n  # color reset\n  __nc=\"$(tput sgr0)\"\n\n  __blk() { echo -n \"$__blk$*$__nc\"; }\n  __red() { echo -n \"$__red$*$__nc\"; }\n  __grn() { echo -n \"$__grn$*$__nc\"; }\n  __yel() { echo -n \"$__yel$*$__nc\"; }\n  __blu() { echo -n \"$__blu$*$__nc\"; }\n  __mag() { echo -n \"$__mag$*$__nc\"; }\n  __cyn() { echo -n \"$__cyn$*$__nc\"; }\n  __wht() { echo -n \"$__wht$*$__nc\"; }\n\n  __bold_blk() { echo -n \"$__bold_blk$*$__nc\"; }\n  __bold_red() { echo -n \"$__bold_red$*$__nc\"; }\n  __bold_grn() { echo -n \"$__bold_grn$*$__nc\"; }\n  __bold_yel() { echo -n \"$__bold_yel$*$__nc\"; }\n  __bold_blu() { echo -n \"$__bold_blu$*$__nc\"; }\n  __bold_mag() { echo -n \"$__bold_mag$*$__nc\"; }\n  __bold_cyn() { echo -n \"$__bold_cyn$*$__nc\"; }\n  __bold_wht() { echo -n \"$__bold_wht$*$__nc\"; }\n\n  __on_blk() { echo -n \"$__on_blk$*$__nc\"; }\n  __on_red() { echo -n \"$__on_red$*$__nc\"; }\n  __on_grn() { echo -n \"$__on_grn$*$__nc\"; }\n  __on_yel() { echo -n \"$__on_yel$*$__nc\"; }\n  __on_blu() { echo -n \"$__on_blu$*$__nc\"; }\n  __on_mag() { echo -n \"$__on_mag$*$__nc\"; }\n  __on_cyn() { echo -n \"$__on_cyn$*$__nc\"; }\n  __on_wht() { echo -n \"$__on_wht$*$__nc\"; }\n}\n\n__print_prompt() {\n  __prefix=\"${prefix[*]}\" print_prompt \"$@\"\n}\n\nprint_prompt() {\n\n  # TODO: change name to correct\n  hashdollar() {\n    (( UID )) && echo '$' \\\n              || echo '#'\n  }\n\n  colorise_prompt() {\n    local to_be_replaced=(blk red grn yel blu mag cyn wht)\n\n    local SED_COMMAND_LINE=('sed' '-E')\n\n    for color in \"${to_be_replaced[@]}\"; do\n      SED_COMMAND_LINE+=(\n        '-e' \"s/%on_$color%/$(eval echo \"\\$__on_$color\")/g\"\n        '-e' \"s/%bold_$color%/$(eval echo \"\\$__bold_$color\")/g\"\n        '-e' \"s/%$color%/$(eval echo \"\\$__$color\")/g\"\n        )\n    done\n\n    \"${SED_COMMAND_LINE[@]}\" -e \"s/%nc%/$__nc/g\"\n  }\n  local __escaped_prefix=$(echo -n \"$__prefix\" | sed -e 's/\\./\\\\./g' -e 's/\\//\\\\\\//g')\n  echo -n \"$*\" | colorise_prompt | sed -E -e \"s/%prefix%/$__escaped_prefix/g\" \\\n                                          -e \"s/\\\\$/$(hashdollar)/g\"\n}\n\nwith_completion()\n{\n  # print readline's prompt for visual separation\n  if [ \"$#\" -eq 0 ]; then\n      echo \"$(__print_prompt \"$PROMPT_FORMAT\")$READLINE_LINE\"\n  fi\n\n  # remove part after readline cursor from completion line\n  local completion_line completion_word\n  completion_line=\"${READLINE_LINE:0:READLINE_POINT}\"\n  completion_word=\"${completion_line##* }\"\n\n  # set completion cursor according to pmpt length\n  COMP_POINT=$((${#pmpt}+${#completion_line}+1))\n  COMP_WORDBREAKS=\"\\n\\\"'><=;|&(:\"\n  COMP_LINE=\"$pmpt $completion_line\"\n  COMP_WORDS=($COMP_LINE)\n\n  # TODO: the purpose of these variables is still unclear\n  # COMP_TYPE=63\n  # COMP_KEY=9\n\n  # get index of word to be completed\n  local whitespaces_count escaped_whitespaces_count\n  whitespaces_count=$(echo \"$COMP_LINE\" | grep -o ' ' | wc -l)\n  escaped_whitespaces_count=$(echo \"$COMP_LINE\" | grep -o '\\\\ ' | wc -l)\n  COMP_CWORD=$((whitespaces_count-escaped_whitespaces_count))\n\n  # get sourced completion command\n  local program_name complete_command\n  program_name=${COMP_WORDS[0]}\n  program_name=$(basename \"$program_name\")\n  complete_command=$(complete -p | grep \" ${program_name}$\")\n\n  COMPREPLY=()\n\n  # execute appropriate complete actions\n  if [[ \"$complete_command\" =~  \\ -F\\  ]]\n  then\n    local complete_function\n    complete_function=$(awk '{for(i=1;i<=NF;i++) if ($i==\"-F\") print $(i+1)}' <(echo \"$complete_command\"))\n\n    # generate completions\n    $complete_function\n  else\n    # construct compgen command\n    local compgen_command\n    compgen_command=$(echo \"$complete_command\" | sed 's/^complete/compgen/g')\n    compgen_command=\"${compgen_command//$program_name/$completion_word}\"\n\n    # generate completions\n    COMPREPLY=($($compgen_command))\n  fi\n\n  # get commmon prefix of available completions\n  local completions_prefix readline_prefix readline_suffix\n  completions_prefix=$(printf \"%s\\n\" \"${COMPREPLY[@]}\" | \\\n    sed -e '$!{N;s/^\\(.*\\).*\\n\\1.*$/\\1\\n\\1/;D;}' | xargs)\n  readline_prefix=\"${READLINE_LINE:0:READLINE_POINT}\"\n  readline_suffix=\"${READLINE_LINE:READLINE_POINT}\"\n  # remove the word to be completed\n  readline_prefix=$(sed s/'\\w*$'// <(echo \"$readline_prefix\") | xargs)\n\n  READLINE_LINE=\"\"\n  if [[ \"$readline_prefix\" != \"\" ]]; then\n    READLINE_LINE=\"$readline_prefix \"\n  fi\n\n  READLINE_LINE=\"$READLINE_LINE$completions_prefix\"\n  # adjust readline cursor position\n  READLINE_POINT=$((${#READLINE_LINE}+1))\n\n  if [[ \"$readline_suffix\" != \"\" ]]; then\n    READLINE_LINE=\"$READLINE_LINE $readline_suffix\"\n  fi\n\n  local completions_count display_all\n  completions_count=${#COMPREPLY[@]}\n  display_all=\"y\"\n  if [[ $completions_count -eq 1 ]]; then\n    READLINE_LINE=$(echo \"$READLINE_LINE\" | xargs)\n    READLINE_LINE=\"$READLINE_LINE \"\n    return\n  elif [[ $completions_count -gt 80 ]]; then\n    echo -en \"Display all $completions_count possibilities? (y or n) \"\n    read -N 1 display_all\n    echo \"$display_all\"\n  fi\n\n  if [[ \"$display_all\" = \"y\" ]]; then\n    for completion in \"${COMPREPLY[@]}\"; do echo \"$completion\"; done | column\n  fi\n}\n\nfinish()\n{\n  # save history to bash history\n  if [ -f ~/.bash_history ]; then\n    cat /tmp/with_history >> ~/.bash_history\n  fi\n  rm /tmp/with_history\n}\n\ndrop_with()\n{\n  if [ ${#prefix[@]} -gt 1 ]\n  then\n    prefix=( \"${prefix[@]:0:${#prefix[@]}-1}\" )\n  else\n    exit 0\n  fi\n}\n\nadd_with()\n{\n  # separate into white space\n  # FIXME: foo \"bar baz\" should add two elements not one\n  IFS=' ' read -r -a parse_array <<< \"$@\"\n  prefix=( \"${prefix[@]}\" \"${parse_array[@]}\" )\n}\n\nrun_with()\n{\n  while IFS=\"\" read -r -e -d $'\\n' -p \"$(__print_prompt \"$PROMPT_FORMAT\")\" options; do\n    history -s \"$options\" > /dev/null 2>&1\n\n    curr_command=\"$(echo \"$options\" | { read -r first rest ; echo \"$first\" ; })\"\n    case $curr_command in\n      \"\" )\n        # null case: run prefix\n        ${prefix[*]} ;;\n      !* )\n        # replace current command\n        drop_with\n        parsed=${options#\"!\"}\n        add_with \"$parsed\" ;;\n      -* )\n        # remove with\n        parsed=${options#\"-\"}\n        if [ -z \"$parsed\" ]; then\n          drop_with\n        else\n          for ((x=0; x<$((parsed)); x++)) {\n            drop_with\n          }\n        fi\n        pmpt=\"${prefix[*]}\" ;;\n      +* )\n        # nesting withs\n        parsed=${options#\"+\"}\n        add_with \"$parsed\"\n        pmpt=\"${prefix[*]}\" ;;\n      :* )\n        # shell command\n        parsed=${options#\":\"}\n        if [ \"$parsed\" = \"q\" ]; then\n          exit 0\n        fi\n        IFS=' ' read -r -a parsed_array <<< \"$parsed\"\n        echo \"${parsed_array[@]}\" >> /tmp/with_history\n        eval \"${parsed_array[@]}\" ;;\n      * )\n        # prepend prefix to command\n        echo \"${prefix[*]} ${options}\" >> /tmp/with_history\n        eval \"${prefix[*]} ${options}\"\n    esac\n  done\n}\n\nmain()\n{\n  trap finish exit\n  [ \"$PROMPT_FORMAT\" ] || PROMPT_FORMAT+='%yel%$%nc% ' \\\n                        PROMPT_FORMAT+='%cyn%%prefix%%nc% ' \\\n                        PROMPT_FORMAT+='%wht%>%nc% '\n\n  HISTCONTROL=ignoreboth\n\n  # run script setup\n  setup\n\n  if [ \"$1\" == \"\" ]; then\n    print_usage\n  elif ! type \"$1\" > /dev/null 2>&1; then\n    echo \"error: \\\"$1\\\" is not a valid executable\"\n    exit 1\n  fi\n\n  while true ; do\n    run_with\n  done\n}\n\nmain \"$@\"\n"
        },
        {
          "name": "with.bash-completion",
          "type": "blob",
          "size": 0.072265625,
          "content": "# bash completion for with\ncomplete -F _command with # command completion\n"
        }
      ]
    }
  ]
}