{
  "metadata": {
    "timestamp": 1736568244072,
    "page": 119,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zdharma-continuum/zinit",
      "stars": 3302,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".commitlintrc",
          "type": "blob",
          "size": 0.044921875,
          "content": "{\n  \"extends\": \"@commitlint/config-angular\"\n}\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0625,
          "content": ".git/\n.github/\n.git*\ndoc/\nscripts/\ntest/\ntests/\n\n*.zwc\nMakefile\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.240234375,
          "content": "# By default, everything is text\n* text\n\n# These must be unix EOLs\n*.sh             eol=lf\n*.zsh   diff=zsh eol=lf\n*.zunit diff=zsh eol=lf\nMakefile         eol=lf\n\n# Use the markdown differ.\n*.md diff=markdown\n\n# Binary files\n*.png binary\n\n# EOF\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1865234375,
          "content": "*.[aos]\n*.bundle\n*.dll\n*.orig\n*.txt\n*.zini\n*.zwc\n*deploy*key*\n*~\n.*.sw?\n.project\nTAGS\nTODO*\n\\#*\ndoc/zsdoc/data\nother\nsite*/\ntags\ntest/\ntxt/\nzmodules/\ntests/_output/\ntests/_support/tmp*\n.idea\n"
        },
        {
          "name": ".releaserc.json",
          "type": "blob",
          "size": 1.0234375,
          "content": "{\n  \"repositoryUrl\": \"https://github.com/zdharma-continuum/zinit.git\",\n  \"branches\": [\n    \"main\"\n  ],\n  \"plugins\": [\n    [ \"@semantic-release/commit-analyzer\", { } ],\n    [\n      \"@google/semantic-release-replace-plugin\",\n      {\n        \"replacements\": [\n          {\n            \"files\": [\n              \"VERSION\"\n            ],\n            \"from\": \"^([0-9]).+([0-9]).+([0-9])$\",\n            \"to\": \"${nextRelease.version}\",\n            \"results\": [\n              {\n                \"file\": \"VERSION\",\n                \"hasChanged\": true\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    [ \"@semantic-release/release-notes-generator\", { } ],\n    [\n      \"@semantic-release/changelog\",\n      {\n        \"changelogFile\": \"CHANGELOG.md\"\n      }\n    ],\n    [\n      \"@semantic-release/git\",\n      {\n        \"assets\": [\n          \"CHANGELOG.md\",\n          \"VERSION\"\n        ],\n        \"message\": \"release: v${lastRelease.version} → v${nextRelease.version}\\n\\n${nextRelease.notes}\"\n      }\n    ],\n    \"@semantic-release/github\"\n  ]\n}\n"
        },
        {
          "name": ".zunit.yml",
          "type": "blob",
          "size": 0.1240234375,
          "content": "allow_risky: false\ndirectories:\n  output: tests/_output\n  support: tests/_support\n  tests: tests\nfail_fast: true\nverbose: true\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 23.365234375,
          "content": "## [3.13.1](https://github.com/zdharma-continuum/zinit/compare/v3.13.0...v3.13.1) (2024-01-22)\n\n\n### Bug Fixes\n\n*  `plugins` command correctly handles keyword argument ([#626](https://github.com/zdharma-continuum/zinit/issues/626)) ([f26d387](https://github.com/zdharma-continuum/zinit/commit/f26d387e51c9103f2ba7142a8c1a25ba1d62e065))\n\n# [3.13.0](https://github.com/zdharma-continuum/zinit/compare/v3.12.1...v3.13.0) (2024-01-18)\n\n\n### Bug Fixes\n\n* **ci:** remove duplicate gh-r  zunit job ([#623](https://github.com/zdharma-continuum/zinit/issues/623)) ([70cefc0](https://github.com/zdharma-continuum/zinit/commit/70cefc086a8b2277476e7f4fa3e00e0f7d4fd4cf))\n* debug logging logic and format ([#592](https://github.com/zdharma-continuum/zinit/issues/592)) ([3c7e5be](https://github.com/zdharma-continuum/zinit/commit/3c7e5be07d79b8f1a7fbd5dfd150a09a6309e461))\n* handle zinit --help ([#597](https://github.com/zdharma-continuum/zinit/issues/597)) ([8cf9104](https://github.com/zdharma-continuum/zinit/commit/8cf9104ac08da3f7f108a32e0a3b117e22681d46))\n* link ice check in .zinit-download-snippet function ([#608](https://github.com/zdharma-continuum/zinit/issues/608)) ([358ef03](https://github.com/zdharma-continuum/zinit/commit/358ef03785a18e694e94fd4560e0582c4024bcc3))\n* pin dua gh-r test to v2.20.3 ([#605](https://github.com/zdharma-continuum/zinit/issues/605)) ([0ba778a](https://github.com/zdharma-continuum/zinit/commit/0ba778ac734e33c960fe08bbd56a351b1b86dcd4))\n* silence unzip command in ziextract ([#614](https://github.com/zdharma-continuum/zinit/issues/614)) ([71764bf](https://github.com/zdharma-continuum/zinit/commit/71764bf2caa553f52435ed374bb48b74b0a8ad96))\n* tar permissions when `ziextract` ran as root user ([#557](https://github.com/zdharma-continuum/zinit/issues/557)) ([e2d477c](https://github.com/zdharma-continuum/zinit/commit/e2d477cde4e87d13ebc6b99e7f95022f75ca075e))\n* update labeler config to v5 ([#604](https://github.com/zdharma-continuum/zinit/issues/604)) ([794723c](https://github.com/zdharma-continuum/zinit/commit/794723cc4829e0f9293fc441100913ac7f02566a))\n\n\n### Features\n\n* configure, make, cmake, and build ices ([#613](https://github.com/zdharma-continuum/zinit/issues/613)) ([#616](https://github.com/zdharma-continuum/zinit/issues/616)) ([22e66db](https://github.com/zdharma-continuum/zinit/commit/22e66db478716005d6fec52cd412fad3fc94a9a2))\n* **delete:** fix unsetting plugin state & add `--debug` / `--quiet` flags ([#622](https://github.com/zdharma-continuum/zinit/issues/622)) ([3f4b685](https://github.com/zdharma-continuum/zinit/commit/3f4b68562265e6b06f55124e34fab0fe58c53adf))\n* remove zpextract and use ziextract ([#611](https://github.com/zdharma-continuum/zinit/issues/611)) ([2ccac85](https://github.com/zdharma-continuum/zinit/commit/2ccac85e376965a6e6d9fe1dc3f1470b706e9fac))\n\n## [3.12.1](https://github.com/zdharma-continuum/zinit/compare/v3.12.0...v3.12.1) (2023-11-20)\n\n\n### Bug Fixes\n\n* container zshelldoc install ([#591](https://github.com/zdharma-continuum/zinit/issues/591)) ([8170753](https://github.com/zdharma-continuum/zinit/commit/8170753a5d21f2e54ba30901cdb0afb6399a7b51))\n* from'gh-r' skips compile by default ([#590](https://github.com/zdharma-continuum/zinit/issues/590)) ([1f52eee](https://github.com/zdharma-continuum/zinit/commit/1f52eee1b1ef4a76b779d2017f2e7d2151516544))\n* respect delete flags after positional arguments ([#587](https://github.com/zdharma-continuum/zinit/issues/587)) ([e18f9a7](https://github.com/zdharma-continuum/zinit/commit/e18f9a7da273fa44079b16a90e89df76664fcbee))\n* set home dir to test env in gh-r tests ([#582](https://github.com/zdharma-continuum/zinit/issues/582)) ([9b33288](https://github.com/zdharma-continuum/zinit/commit/9b33288b4aa88a1d41786eacfe31eb966b6c0455))\n* use $MACHTYPE instead of arch command ([#588](https://github.com/zdharma-continuum/zinit/issues/588)) ([bcf70e8](https://github.com/zdharma-continuum/zinit/commit/bcf70e8268dd09737d262919dcba0ff3301a705d))\n\n# [3.12.0](https://github.com/zdharma-continuum/zinit/compare/v3.11.0...v3.12.0) (2023-08-30)\n\n\n### Bug Fixes\n\n* build container for tagged releases ([f933dc0](https://github.com/zdharma-continuum/zinit/commit/f933dc028e9968ed434c21775c2bfc85a722ee04))\n* gh-r linux regex & gh-r zunit tests ([#564](https://github.com/zdharma-continuum/zinit/issues/564)) ([207ab9f](https://github.com/zdharma-continuum/zinit/commit/207ab9f281214bc07da82e7e542126745bf878dd))\n* gh-r zunit tests ([#561](https://github.com/zdharma-continuum/zinit/issues/561)) ([97b087e](https://github.com/zdharma-continuum/zinit/commit/97b087e68ae0c87cc31bcc9172cedf1cf5fcab68))\n* Ignore .yaml and .py files when installing completions ([#528](https://github.com/zdharma-continuum/zinit/issues/528)) ([113cfc4](https://github.com/zdharma-continuum/zinit/commit/113cfc47fb6ec1ed753222b7ba4542ef48ca2fde))\n* jq has moved from stedolan/jq to jqlang/jq ([#530](https://github.com/zdharma-continuum/zinit/issues/530)) ([de85908](https://github.com/zdharma-continuum/zinit/commit/de85908f8d0b89ff6327adfa285ca5a0c4302f2d))\n* math expression in plugins command ([#559](https://github.com/zdharma-continuum/zinit/issues/559)) ([68a6b42](https://github.com/zdharma-continuum/zinit/commit/68a6b42caf224b2ca2c172d58daf9faf5c86beb9))\n* pin fclones version to v0.31.0 ([497d519](https://github.com/zdharma-continuum/zinit/commit/497d519d99c3d3cdb8e71dfdf4583cadef9220a0))\n* quote parens so that they aren't used as globs ([#549](https://github.com/zdharma-continuum/zinit/issues/549)) ([1375adf](https://github.com/zdharma-continuum/zinit/commit/1375adf8f8edadbdcfc18445d852c7f08e723887))\n* self-update check for updates ([#562](https://github.com/zdharma-continuum/zinit/issues/562)) ([b456a2d](https://github.com/zdharma-continuum/zinit/commit/b456a2dba65673f4cf5a9a8c2bc16d7d0dcb3ace))\n* update gomi repo owner ([#568](https://github.com/zdharma-continuum/zinit/issues/568)) ([19ca2dc](https://github.com/zdharma-continuum/zinit/commit/19ca2dc361f9995a3e6a8a8aed0ade435168cd3d))\n\n\n### Features\n\n* build container with zsh 5.9 ([#525](https://github.com/zdharma-continuum/zinit/issues/525)) ([238e843](https://github.com/zdharma-continuum/zinit/commit/238e843d60de27b8f3deaf2d0b5e6657b293c9eb))\n\n# [3.11.0](https://github.com/zdharma-continuum/zinit/compare/v3.10.0...v3.11.0) (2023-05-04)\n\n\n### Bug Fixes\n\n* add `.gitignore` with '*' pattern in a plugins `._zinit/` directory ([#397](https://github.com/zdharma-continuum/zinit/issues/397)) ([fccb508](https://github.com/zdharma-continuum/zinit/commit/fccb5080ab4b1df83f01906082eea444f218776f)), closes [#395](https://github.com/zdharma-continuum/zinit/issues/395)\n* broken update command ([336ca85](https://github.com/zdharma-continuum/zinit/commit/336ca85ade5d4c5c99bd903610baf9961753192b))\n* cleanup style, naming, and completion ([6c82d67](https://github.com/zdharma-continuum/zinit/commit/6c82d6788dec6a60c4c217d03c45c327bc0e59a1))\n* compile and completion log messages ([c4446da](https://github.com/zdharma-continuum/zinit/commit/c4446da57e5375f4a89ea94e1e8c04eacfc4e494))\n* csearch ignores lua files ([4d1840b](https://github.com/zdharma-continuum/zinit/commit/4d1840b883e86cc46df2050c01bd0731e29023aa))\n* makefile clean target less verbose ([3396f5e](https://github.com/zdharma-continuum/zinit/commit/3396f5e3aa1fb81d128d4f34b9ff868011d68981))\n* pin git-mkver gh-r test to v.1.2.2 ([a05cc1a](https://github.com/zdharma-continuum/zinit/commit/a05cc1ab59db5b82c5a0f7ee0b6bbef84f0e8b0e))\n* pin git-mkver unit test to v1.2.2 ([08f02e0](https://github.com/zdharma-continuum/zinit/commit/08f02e00d0fbc86b10d44d18f5b774c9c00806cc))\n* regenerate docs ([e0177e2](https://github.com/zdharma-continuum/zinit/commit/e0177e20382d8336d55bc2637a6f2c515d25ce19))\n\n\n### Features\n\n* expand gh-r zunit tests ([c323116](https://github.com/zdharma-continuum/zinit/commit/c3231164836c8ca3ca9ebded8d95c31c0a186567))\n* refactor debug commands ([930b25e](https://github.com/zdharma-continuum/zinit/commit/930b25ee3c6cc66931eda0030c422fddd69ef9c4))\n* refactor ls, list, and loaded commands ([a865907](https://github.com/zdharma-continuum/zinit/commit/a86590762ac2bb5244db5d3cd7d99d32a9dc11fe))\n\n# [3.10.0](https://github.com/zdharma-continuum/zinit/compare/v3.9.0...v3.10.0) (2023-04-02)\n\n\n### Bug Fixes\n\n* absolute path support in the symbol browser ([d29a8ba](https://github.com/zdharma-continuum/zinit/commit/d29a8ba2b757b936663c16d12e46d3638f44027a))\n* assign to functions hash to make %x work ([bd65a01](https://github.com/zdharma-continuum/zinit/commit/bd65a017345ac891b6b14eb5feb4182bc9c74ace))\n* broken symbolic link after `creinstall .` ([da0d6b7](https://github.com/zdharma-continuum/zinit/commit/da0d6b712c6466d11165ac9e27a6cd7de856e537))\n* bump node version in release workflow ([938f483](https://github.com/zdharma-continuum/zinit/commit/938f48375b20545078b63d6c1dba0a905599afe4))\n* change prefix `~zi::` to `__zi::` ([0e45493](https://github.com/zdharma-continuum/zinit/commit/0e45493e36ff350c79c164895bd4718103e2cf7a))\n* container build & shell make targets ([a72fb83](https://github.com/zdharma-continuum/zinit/commit/a72fb83f0999a7fa4a26c6e1bb71d6cab3858b4f))\n* container build & shell make targets ([14b2cda](https://github.com/zdharma-continuum/zinit/commit/14b2cda0397c343b1bfdc041cba7c4ab216e3803))\n* container build & shell make targets ([370808d](https://github.com/zdharma-continuum/zinit/commit/370808dd5186f4b9c8a214e7ef6f4350df243b5b))\n* container build & shell make targets ([47bd74f](https://github.com/zdharma-continuum/zinit/commit/47bd74f8a7c74761e9b03943d3c40fc523df585f))\n* container build & shell make targets ([f8eb967](https://github.com/zdharma-continuum/zinit/commit/f8eb967b0e98f135b43cb5065aceb8a4f058aa09))\n* container build & shell make targets ([3af321e](https://github.com/zdharma-continuum/zinit/commit/3af321e8e4975a07634df08acda383e4cf53e99c))\n* do not run `make docs` ([3802893](https://github.com/zdharma-continuum/zinit/commit/3802893c74988fc03bad086601c905a1046a9fc1))\n* failing zunit tests & bootstrap script ([d618467](https://github.com/zdharma-continuum/zinit/commit/d618467ff090a6dbfb327ca0a29141d0c9312b24))\n* file modelines ([75bb735](https://github.com/zdharma-continuum/zinit/commit/75bb73547ed24ab6d25e1aed03684caebba39f5e))\n* gh-r & bpick ice log format and content ([ad88a89](https://github.com/zdharma-continuum/zinit/commit/ad88a890ad25505acb764f9551ee00d5264daa9a))\n* gh-r parsing logic for arm64 & logging style ([7e48651](https://github.com/zdharma-continuum/zinit/commit/7e486519d7aad48a8b6009ae5075f0efec2409f9))\n* gh-r pattern for 64bit linux-gnu systems ([b5a31c0](https://github.com/zdharma-continuum/zinit/commit/b5a31c07f2bd2d823ce9e99b98228ec68db523bd))\n* lsd repo owner changed to lsd-rs organization ([#489](https://github.com/zdharma-continuum/zinit/issues/489)) ([824d9d3](https://github.com/zdharma-continuum/zinit/commit/824d9d36177dac00a81333205e2b3dfbc35cb758))\n* make gh-r release search case-insensitive ([3eb75b7](https://github.com/zdharma-continuum/zinit/commit/3eb75b7ee9db4dd01455811cf4ca4539dd07246b))\n* make target docker cmd flags ([dd04896](https://github.com/zdharma-continuum/zinit/commit/dd048964491b9a63f4622b591b9a227d5e981408))\n* pin `ggsrun` version in gh-r z-unit test ([9f67798](https://github.com/zdharma-continuum/zinit/commit/9f677989e8386469bc2d5dcb0d2cb5d62d489e34))\n* the starship example does not work properly ([4933b62](https://github.com/zdharma-continuum/zinit/commit/4933b62f400a1b6b29b82a9ff233911b336a33c5))\n* update pygmentize flags in glance subcommand ([#488](https://github.com/zdharma-continuum/zinit/issues/488)) ([b773763](https://github.com/zdharma-continuum/zinit/commit/b773763bdc37d414a5d954ccb00877374177f0ec))\n* use correct return code in zinit-confirm ([d467738](https://github.com/zdharma-continuum/zinit/commit/d467738c1b1c834e938b4b4bb6e83cab5bfdc429))\n* vim modelines & zsdoc pdf rendering ([2b460a7](https://github.com/zdharma-continuum/zinit/commit/2b460a74f236178cd8d06b55069049381d79256e))\n\n\n### Features\n\n* delete subcommand refactor ([9eee215](https://github.com/zdharma-continuum/zinit/commit/9eee215e3f8ee7d8404e4e54f8ef57a57a21fde2)), closes [#57](https://github.com/zdharma-continuum/zinit/issues/57) [#239](https://github.com/zdharma-continuum/zinit/issues/239)\n* zinit completion improvements ([b8d12e5](https://github.com/zdharma-continuum/zinit/commit/b8d12e555d4cadff7769ef67c5d4c0d403f0b11e))\n\n\n### Reverts\n\n* \"Merge branch 'refactor/zinit-function-names' into main\" ([515688b](https://github.com/zdharma-continuum/zinit/commit/515688bc976e793422d21ba9debfdd1a982c611e))\n\n# [3.9.0](https://github.com/zdharma-continuum/zinit/compare/v3.8.0...v3.9.0) (2022-12-17)\n\n\n### Bug Fixes\n\n* remove broken gh-r zunit test for \"warp\" ([#430](https://github.com/zdharma-continuum/zinit/issues/430)) ([64fa4ae](https://github.com/zdharma-continuum/zinit/commit/64fa4aef3ae517afe5444b24df9603e9d1a77a55))\n\n\n### Features\n\n* add `completions` ice ([#417](https://github.com/zdharma-continuum/zinit/issues/417)) ([59975d7](https://github.com/zdharma-continuum/zinit/commit/59975d70d7101651b0bb01f4e22c23db0dae8133))\n* display version via `version` sub command ([bfb01e6](https://github.com/zdharma-continuum/zinit/commit/bfb01e65d7b9a98c643f3ee0a92f2df06372f52e))\n\n\n### Performance Improvements\n\n* reduce scheduler task check to 10 second interval ([#429](https://github.com/zdharma-continuum/zinit/issues/429)) ([1681ce4](https://github.com/zdharma-continuum/zinit/commit/1681ce40ebf98e5bf48b78ac5d6c060c1ecada99))\n\n\n### Reverts\n\n* \"perf: reduce scheduler task check to 10 second interval ([#429](https://github.com/zdharma-continuum/zinit/issues/429))\" ([#432](https://github.com/zdharma-continuum/zinit/issues/432)) ([cfd3261](https://github.com/zdharma-continuum/zinit/commit/cfd32618921ce0626a6deadc794da962750a845d))\n\n# [3.8.0](https://github.com/zdharma-continuum/zinit/compare/v3.7.0...v3.8.0) (2022-11-07)\n\n\n### Bug Fixes\n\n* account for systems where musl is present ([#269](https://github.com/zdharma-continuum/zinit/issues/269)) ([8620574](https://github.com/zdharma-continuum/zinit/commit/8620574a5533695525260fd88df8d249c701217f))\n* alist repository for gh-r test ([#305](https://github.com/zdharma-continuum/zinit/issues/305)) ([fb3c082](https://github.com/zdharma-continuum/zinit/commit/fb3c082551ee9f48676c3183d5a4e9e842d3d874))\n* allow zinit to be run from non-interactive scripts ([#227](https://github.com/zdharma-continuum/zinit/issues/227)) ([c3d1bb5](https://github.com/zdharma-continuum/zinit/commit/c3d1bb586c77a98566c552358fd9aee084e30da8)), closes [#199](https://github.com/zdharma-continuum/zinit/issues/199)\n* broken yaml syntax in issue template ([#355](https://github.com/zdharma-continuum/zinit/issues/355)) ([f729e06](https://github.com/zdharma-continuum/zinit/commit/f729e065db88a5cd0daa8a6f2bd2f8ee0439545a))\n* calico gh-r zunit test ([#356](https://github.com/zdharma-continuum/zinit/issues/356)) ([56fb9e0](https://github.com/zdharma-continuum/zinit/commit/56fb9e0b1df21de809a2efc935882b49e9161618))\n* change ctags symbols browser key  binding from `ctrl-k` to `alt-Q` ([#387](https://github.com/zdharma-continuum/zinit/issues/387)) ([7f6dc7d](https://github.com/zdharma-continuum/zinit/commit/7f6dc7da6c824b30c0e8e30ae0ecbda5be118e68)), closes [#386](https://github.com/zdharma-continuum/zinit/issues/386)\n* Do not try to escape exclamation marks ([#399](https://github.com/zdharma-continuum/zinit/issues/399)) ([0e55b2e](https://github.com/zdharma-continuum/zinit/commit/0e55b2ea673915c462af752ee7d46fff55e6f436))\n* docs workflow should fail if out-of-date ([#278](https://github.com/zdharma-continuum/zinit/issues/278)) ([07cde66](https://github.com/zdharma-continuum/zinit/commit/07cde660081c91382ce73b60485839710154c7c6))\n* Don't error if $OPTS is not yet defined in .zinit-compinit call ([44765e0](https://github.com/zdharma-continuum/zinit/commit/44765e0bcb8d3f1ee3eb55286e33ad17b8c72a5e))\n* filter by runtime detected CPU before compiled CPU ([#304](https://github.com/zdharma-continuum/zinit/issues/304)) ([a4dc13f](https://github.com/zdharma-continuum/zinit/commit/a4dc13f66a65c4fa52953104c13e44a7d7c0a945)), closes [#287](https://github.com/zdharma-continuum/zinit/issues/287)\n* gh-r & plugin zunit tests ([dd12fce](https://github.com/zdharma-continuum/zinit/commit/dd12fce3f49db284de7cf18a03ef891cc46bc7cc))\n* gh-r filters i686 (32 bit) for x86_64 ([#226](https://github.com/zdharma-continuum/zinit/issues/226)) ([57f0d82](https://github.com/zdharma-continuum/zinit/commit/57f0d82118ed626f04d4b9b8b26de48c9d7e0956)), closes [#225](https://github.com/zdharma-continuum/zinit/issues/225)\n* gh-r logic ignores [36]86 assets ([#235](https://github.com/zdharma-continuum/zinit/issues/235)) ([d60638f](https://github.com/zdharma-continuum/zinit/commit/d60638f2217875056a061b3411c4bcc678dce5f6)), closes [#225](https://github.com/zdharma-continuum/zinit/issues/225) [#246](https://github.com/zdharma-continuum/zinit/issues/246) [#247](https://github.com/zdharma-continuum/zinit/issues/247)\n* gh-r removes linux32 assets on 64 bit OS ([1864c0b](https://github.com/zdharma-continuum/zinit/commit/1864c0be09faa0e4d9a7c549cafed7d296d7517e))\n* gh-r retrieves release data GH REST API  ([#373](https://github.com/zdharma-continuum/zinit/issues/373)) ([4a2a120](https://github.com/zdharma-continuum/zinit/commit/4a2a120b341793b1abaef5f12fbb4808277d8570)), closes [#374](https://github.com/zdharma-continuum/zinit/issues/374)\n* modify regex in gh-r for assets to not consider for selection ([#244](https://github.com/zdharma-continuum/zinit/issues/244)) ([6ef8439](https://github.com/zdharma-continuum/zinit/commit/6ef84398b2c92073d88f440dfbfd554cb8e75343))\n* more cleaning up urls ([672ae51](https://github.com/zdharma-continuum/zinit/commit/672ae514142b433708ea10486556fe3f0ba54e3e)), closes [#47](https://github.com/zdharma-continuum/zinit/issues/47)\n* names of ctag Make target deps ([#407](https://github.com/zdharma-continuum/zinit/issues/407)) ([9987d5c](https://github.com/zdharma-continuum/zinit/commit/9987d5c781d4a95698ed649dc59b11c34006b1c1))\n* package are broken again ([24f10f6](https://github.com/zdharma-continuum/zinit/commit/24f10f6367cbab6039bd0c1ca07dd9449bbc3557))\n* permissions for PR labeler GH action workflow ([#236](https://github.com/zdharma-continuum/zinit/issues/236)) ([8a0d567](https://github.com/zdharma-continuum/zinit/commit/8a0d5678d1ee0eeed91d2c3a094578a2cd39ba04))\n* read without -r is generally bad. ([00c70a4](https://github.com/zdharma-continuum/zinit/commit/00c70a434d50a1591bcdc73185150b2fdce96c77))\n* remove curl option \"--tcp-fastopen\" which is not always available ([#299](https://github.com/zdharma-continuum/zinit/issues/299)) ([308c9d4](https://github.com/zdharma-continuum/zinit/commit/308c9d4cd82f3e41d2ae21ff31fba0dc4a7c6cb5))\n* remove macOS 10.5 & 11 from test matrix ([c613193](https://github.com/zdharma-continuum/zinit/commit/c61319378df5b0deae68fc467b9a2449fcf67336))\n* remove use less line ([4f87076](https://github.com/zdharma-continuum/zinit/commit/4f870766011d36c871d8afd07afe56733c8de76d))\n* rename `docs` to `doc` to match doc dir ([#212](https://github.com/zdharma-continuum/zinit/issues/212)) ([3a7dc95](https://github.com/zdharma-continuum/zinit/commit/3a7dc95f02340fb56693ca0f304e31be8c8a9652))\n* rm linux32 assets in aarch64/arm64 gh-r regex ([#414](https://github.com/zdharma-continuum/zinit/issues/414)) ([529aa20](https://github.com/zdharma-continuum/zinit/commit/529aa20f42a249f609b9e8248d6fd00d609a35ce))\n* syntax error when checking for `realpath` command  ([#259](https://github.com/zdharma-continuum/zinit/issues/259)) ([05559eb](https://github.com/zdharma-continuum/zinit/commit/05559ebdbcda77622daaf3935d20fdf9b9c09c6c)), closes [#257](https://github.com/zdharma-continuum/zinit/issues/257)\n* trigger for PR labeler GH action workflow ([#237](https://github.com/zdharma-continuum/zinit/issues/237)) ([49af866](https://github.com/zdharma-continuum/zinit/commit/49af86688bc8c5882744a679f9c0094e2f4c7fa6))\n* typo & triggers in documentation workflow ([#308](https://github.com/zdharma-continuum/zinit/issues/308)) ([161d7c1](https://github.com/zdharma-continuum/zinit/commit/161d7c1ee1fc2bbb43442cd90b48e502bf62603f))\n* unmatched \"(\" in windows gh-r patterns ([#280](https://github.com/zdharma-continuum/zinit/issues/280)) ([1f4ba5a](https://github.com/zdharma-continuum/zinit/commit/1f4ba5ae0ccf928d1914dc3a11d00393e0fd94a8))\n* update `zdharma` to `zdharma-continuum` ([66b1700](https://github.com/zdharma-continuum/zinit/commit/66b17007523321f9afee91dbe75b487de5db4fec))\n* update docs for new jq-check ([6207427](https://github.com/zdharma-continuum/zinit/commit/62074272563f88a32a701f56f914297930a9da19))\n* use [*] inside arbitrary strings. ([73a8c92](https://github.com/zdharma-continuum/zinit/commit/73a8c92d43f57bca514e44b9fed14e941168c61f))\n* workflow pkg mgmt due to base OS changes ([195f72d](https://github.com/zdharma-continuum/zinit/commit/195f72d54b80051fc71d1f73909f5dabe6745649))\n* ziextract execs discovery regex ([#410](https://github.com/zdharma-continuum/zinit/issues/410)) ([105b38a](https://github.com/zdharma-continuum/zinit/commit/105b38a195e2a67eaba9d7a69bcef7738c57d12d))\n* zunit install in GH workflow ([#412](https://github.com/zdharma-continuum/zinit/issues/412)) ([f4787dc](https://github.com/zdharma-continuum/zinit/commit/f4787dcac803ed9055c4032c516dba66737beebf))\n\n\n### Features\n\n* ability to set program for `zinit ls` to use ([#221](https://github.com/zdharma-continuum/zinit/issues/221)) ([bad7af3](https://github.com/zdharma-continuum/zinit/commit/bad7af3ae2d8aab18feb11a0251987fe3c08c31b)), closes [#170](https://github.com/zdharma-continuum/zinit/issues/170)\n* add `-a` (actual time) to `zinit times` cmd ([#223](https://github.com/zdharma-continuum/zinit/issues/223)) ([450d3c1](https://github.com/zdharma-continuum/zinit/commit/450d3c10a8f6728ee8c76bfb99f777658b8d3f35))\n* add `krew` and `prebuilt-ripgrep` gh-r zunit tests ([#267](https://github.com/zdharma-continuum/zinit/issues/267)) ([f25b4ae](https://github.com/zdharma-continuum/zinit/commit/f25b4ae2b9951bf0d1306a17ef512a1868211b78))\n* add compile vim from source zunit test ([#232](https://github.com/zdharma-continuum/zinit/issues/232)) ([126528c](https://github.com/zdharma-continuum/zinit/commit/126528ccd50e98c0e71f06971ae16aceb571fb97))\n* add configure\"\" ice ([#334](https://github.com/zdharma-continuum/zinit/issues/334)) ([40a46c6](https://github.com/zdharma-continuum/zinit/commit/40a46c6d2250af7e01d91b2f8ec3e01cf392c3d1))\n* add GH action to remove old workflow logs ([#248](https://github.com/zdharma-continuum/zinit/issues/248)) ([6647bdc](https://github.com/zdharma-continuum/zinit/commit/6647bdc31c5b82378195ce71055099a7b36734a1))\n* add PR labeler to show what parts of Zinit are changed ([#211](https://github.com/zdharma-continuum/zinit/issues/211)) ([42e83d7](https://github.com/zdharma-continuum/zinit/commit/42e83d7f99254c16e408f52848b914f7aa264372))\n* add releases via semantic-release ([73542b4](https://github.com/zdharma-continuum/zinit/commit/73542b490981e43adca4a09b64c327fe811d01e1))\n* add releases via semantic-release ([#415](https://github.com/zdharma-continuum/zinit/issues/415)) ([cfa2f0e](https://github.com/zdharma-continuum/zinit/commit/cfa2f0ebcd674706d5cb91533cf362f6f4ddd7ee))\n* expand linted file types to markdown and shell ([96fe03f](https://github.com/zdharma-continuum/zinit/commit/96fe03f85baf8eae33270a09a5ca82f108f6cc25))\n* **git-process-output:** simplify progress-bar ([#204](https://github.com/zdharma-continuum/zinit/issues/204)) ([c888917](https://github.com/zdharma-continuum/zinit/commit/c888917edbafa3772870ad1f320da7a5f169cc6f))\n* update output messaging to be more informative ([047320a](https://github.com/zdharma-continuum/zinit/commit/047320a9234be4de8299ff4796e28e2363e77984))\n\n# [v3.7.0](https://github.com/zdharma-continuum/zinit/compare/v3.1...v3.7.0)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.0693359375,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for\neveryone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity\nand expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion,\nor sexual identity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our community include:\n\n- Demonstrating empathy and kindness toward other people\n- Being respectful of differing opinions, viewpoints, and experiences\n- Giving and gracefully accepting constructive feedback\n- Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\n- Focusing on what is best not just for us as individuals, but for the overall community\n\nExamples of unacceptable behavior include:\n\n- The use of sexualized language or imagery, and sexual attention or advances of any kind\n- Trolling, insulting or derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or email address, without their explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take\nappropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits,\nissues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for\nmoderation decisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing\nthe community in public spaces. Examples of representing our community include using an official e-mail address, posting\nvia an official social media account, or acting as an appointed representative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible\nfor enforcement at . All complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem\nin violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the\ncommunity.\n\n**Consequence**: A private, written warning from community leaders, providing clarity around the nature of the violation\nand an explanation of why the behavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series of actions.\n\n**Consequence**: A warning with consequences for continued behavior. No interaction with the people involved, including\nunsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding\ninteractions in community spaces as well as external channels like social media. Violating these terms may lead to a\ntemporary or permanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including sustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public communication with the community for a specified\nperiod of time. No public or private interaction with the people involved, including unsolicited interaction with those\nenforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community standards, including sustained inappropriate\nbehavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within the community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by\n[Mozilla's code of conduct enforcement ladder](https://github.com/mozilla/diversity).\n\nFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq.\nTranslations are available at https://www.contributor-covenant.org/translations.\n\n[homepage]: https://www.contributor-covenant.org\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.115234375,
          "content": "MIT License\n\nCopyright (c) 2016-2020 Sebastian Gniazdowski and contributors\nCopyright (c) 2021-2022 zdharma-continuum\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.8095703125,
          "content": ".EXPORT_ALL_VARIABLES:\n\nZSH := $(shell command -v zsh 2> /dev/null)\nSRC := zinit{'','-additional','-autoload','-install','-side'}.zsh\nDOC_SRC := $(foreach wrd,$(SRC),../$(wrd))\n\n.PHONY: all clean container doc doc/container tags tags/emacs tags/vim test zwc\n\nclean:\n\trm -rf *.zwc doc/zsdoc/zinit{'','-additional','-autoload','-install','-side'}.zsh.adoc doc/zsdoc/data/\n\ncontainer:\n\tdocker build --tag=ghcr.io/zdharma-continuum/zinit:latest --file=docker/Dockerfile .\n\ndoc: clean\n\tcd doc; zsh -l -d -f -i -c \"zsd -v --scomm --cignore '(\\#*FUNCTION:[[:space:]][\\:\\∞\\.\\+\\@\\-a-zA-Z0-9]*[\\[]*|}[[:space:]]\\#[[:space:]][\\]]*)' $(DOC_SRC)\"\n\ndoc/container: container\n\t./scripts/docker-run.sh --docs --debug\n\n# Run ctags to generate Emacs and Vim's format tag file.\ntags: tags/emacs tags/vim\n\ntags/emacs: ## Build Emacs-style ctags file\n\t@if type ctags >/dev/null 2>&1; then \\\n\t\tif ctags --version | grep >/dev/null 2>&1 \"Universal Ctags\"; then \\\n\t\t\tctags -e -R --options=share/zsh.ctags --languages=zsh \\\n\t\t\t    --pattern-length-limit=250 --maxdepth=1; \\\n\t\telse \\\n\t\t\tctags -e -R --languages=sh --langmap=sh:.zsh; \\\n\t\tfi; \\\n\t\tprintf \"Created the Emacs \\`TAGS\\` file.\\\\n\"; \\\n\telse \\\n\t    printf 'Error: Please install a Ctags (e.g.: either the Exuberant or Universal %b' \\\n\t    'version) utility first.\\n'; \\\n\tfi\n\ntags/vim: ## Build the Vim-style ctags file\n\t@if type ctags >/dev/null 2>&1; then \\\n\t\tif ctags --version | grep >/dev/null 2>&1 \"Universal Ctags\"; then \\\n\t\t\tctags --languages=zsh --maxdepth=1 --options=share/zsh.ctags --pattern-length-limit=250 -R; \\\n\t\telse \\\n\t\t\tctags -R --languages=sh --langmap=sh:.zsh; \\\n\t\tfi; \\\n\t\tprintf \"Created the Vim's style \\`tags\\` file.\\\\n\"; \\\n\telse \\\n\t    printf 'Error: Please install a ctags first.\\n'; \\\n\tfi\n\ntest:\n\tzunit run\n\nzwc:\n\t$(or $(ZSH),:) -fc 'for f in *.zsh; do zcompile -R -- $$f.zwc $$f || exit; done'\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 89.10546875,
          "content": "<p align=\"center\">\n  <a href=\"https://github.com/zdharma-continuum/zinit\">\n    <img src=\"https://raw.githubusercontent.com/zdharma-continuum/zinit/images/zinit.png\"/>\n  </a>\n</p>\n\n# Zinit<a name=\"zinit\"></a>\n\n[![MIT License][mit-badge]][mit-link] [![zinit version][ver-badge]][ver-link] [![zunit tests][tests-badge]][tests-link]\n[![Join the chat at https://gitter.im/zdharma-continuum/zinit][gitter-badge]][gitter-link]\n\n<!-- mdformat-toc start --slug=github --maxlevel=3 --minlevel=2 -->\n\n- [Zinit Wiki](#zinit-wiki)\n- [Install](#install)\n  - [Automatic](#automatic)\n  - [Manual](#manual)\n- [Usage](#usage)\n  - [Introduction](#introduction)\n  - [Plugins and snippets](#plugins-and-snippets)\n  - [Upgrade Zinit and plugins](#upgrade-zinit-and-plugins)\n  - [Turbo and lucid](#turbo-and-lucid)\n  - [Migration](#migration)\n- [Frequently Asked Questions](#frequently-asked-questions)\n  - [Use `zi ice svn` if a plugin/snippet requires an entire subdirectory](#use-zi-ice-svn-if-a-pluginsnippet-requires-an-entire-subdirectory)\n  - [Use `zi ice as'completion'` to directly add single file completion snippets](#use-zi-ice-ascompletion-to-directly-add-single-file-completion-snippets)\n  - [More Examples](#more-examples)\n- [Ice Modifiers](#ice-modifiers)\n  - [Cloning Options](#cloning-options)\n  - [Selection of Files (To Source, …)](#selection-of-files-to-source-%E2%80%A6)\n  - [Conditional Loading](#conditional-loading)\n  - [Plugin Output](#plugin-output)\n  - [Completions](#completions)\n  - [Command Execution After Cloning, Updating or Loading](#command-execution-after-cloning-updating-or-loading)\n  - [Sticky-Emulation Of Other Shells](#sticky-emulation-of-other-shells)\n  - [Others](#others)\n  - [Order of Execution](#order-of-execution)\n- [Zinit Commands](#zinit-commands)\n  - [Help](#help)\n  - [Loading and Unloading](#loading-and-unloading)\n  - [Completions](#completions-1)\n  - [Tracking of the Active Session](#tracking-of-the-active-session)\n  - [Reports and Statistics](#reports-and-statistics)\n  - [Compiling](#compiling)\n  - [Other](#other)\n- [Updating Zinit and Plugins](#updating-zinit-and-plugins)\n- [Completions](#completions-2)\n  - [Calling `compinit` Without Turbo Mode](#calling-compinit-without-turbo-mode)\n  - [Calling `compinit` With Turbo Mode](#calling-compinit-with-turbo-mode)\n  - [Ignoring Compdefs](#ignoring-compdefs)\n  - [Disabling System-Wide `compinit` Call (Ubuntu)](#disabling-system-wide-compinit-call-ubuntu)\n- [Zinit Module](#zinit-module)\n- [Hints and Tips](#hints-and-tips)\n  - [Using ZPFX variable](#using-zpfx-variable)\n  - [Customizing Paths](#customizing-paths)\n  - [Non-GitHub (Local) Plugins](#non-github-local-plugins)\n  - [Extending Git](#extending-git)\n- [Changelog](#changelog)\n- [Support](#support)\n- [Getting Help and Community](#getting-help-and-community)\n\n<!-- mdformat-toc end -->\n\n<p align=\"center\">\n<a href=\"https://github.com/zdharma-continuum/pm-perf-test\">\n<img width=\"550px\" src=\"https://raw.githubusercontent.com/zdharma-continuum/zinit/images/startup-times.png\"/>\n</a>\n</p>\n\nZinit is a flexible and fast Zshell plugin manager that will allow you to install everything from GitHub and other\nsites. Its characteristics are:\n\n1. Zinit is currently the only plugin manager that provides Turbo mode, which yields **50-80% faster Zsh startup**\n   (i.e., the shell will start up to **5** times faster!). Check out a speed comparison with other popular plugin\n   managers [here](https://github.com/zdharma-continuum/pm-perf-test).\n\n2. The plugin manager gives **reports** from plugin loadings describing what **aliases**, functions, **bindkeys**, Zle\n   widgets, zstyles, **completions**, variables, `PATH` and `FPATH` elements a plugin has set up. This allows one to\n   quickly familiarize oneself with a new plugin and provides rich and easy-to-digest information which might be helpful\n   on various occasions.\n\n3. Supported is the unloading of plugin and ability to list, (un)install and **selectively disable**, **enable**\n   plugin's completions.\n\n4. The plugin manager supports loading plugins and libraries from Oh My Zsh or Prezto. However, the implementation isn't\n   framework-specific and doesn't bloat the plugin manager with such code (more on this topic can be found on the Wiki,\n   in the [Introduction](https://zdharma-continuum.github.io/zinit/wiki/INTRODUCTION/#oh_my_zsh_prezto)).\n\n5. The system does not use `$FPATH`, loading multiple plugins doesn't clutter `$FPATH` with the same number of entries\n   (e.g. `10`, `15` or more). Code is immune to `KSH_ARRAYS` and other options typically causing compatibility problems.\n\n6. Zinit supports special, dedicated **packages** that offload the user from providing long and complex commands. See\n   the [zinit-packages repository](https://github.com/zdharma-continuum/zinit-packages) for a growing, complete list of\n   Zinit packages and the [Wiki page](https://zdharma-continuum.github.io/zinit/wiki/Zinit-Packages/) for an article\n   about the feature.\n\n7. Also, specialized Zinit extensions — called **annexes** — have the ability to extend the plugin manager with new\n   commands, URL-preprocessors (used by e.g.:\n   [zinit-annex-readurl](https://github.com/zdharma-continuum/zinit-annex-readurl) annex), post-install and post-update\n   hooks, and much more. See the [zdharma-continuum](https://github.com/zdharma-continuum) organization for a growing,\n   complete list of available Zinit extensions and refer to the\n   [Wiki article](https://zdharma-continuum.github.io/zinit/wiki/Annexes/) for an introduction on creating your annex.\n\n## Zinit Wiki<a name=\"zinit-wiki\"></a>\n\nThe information in this README is complemented by the [Zinit Wiki](https://zdharma-continuum.github.io/zinit/wiki/). The\nREADME is an introductory overview of Zinit, while the Wiki gives complete information with examples. Make sure to read\nit to get the most out of Zinit.\n\n## Install<a name=\"install\"></a>\n\n### Automatic<a name=\"automatic\"></a>\n\nThe easiest way to install Zinit is to execute:\n\n```bash\nbash -c \"$(curl --fail --show-error --silent --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh)\"\n```\n\nThis will install Zinit in `~/.local/share/zinit/zinit.git`. `.zshrc` will be updated with three lines of code that will\nbe added to the bottom. The lines will be sourcing `zinit.zsh` and setting up completion for command `zinit`.\n\nAfter installing and reloading the shell, compile Zinit via:\n\n```zsh\nzinit self-update\n```\n\n### Manual<a name=\"manual\"></a>\n\nIn your `.zshrc`, add the following snippet\n\n```zsh\nZINIT_HOME=\"${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git\"\n[ ! -d $ZINIT_HOME ] && mkdir -p \"$(dirname $ZINIT_HOME)\"\n[ ! -d $ZINIT_HOME/.git ] && git clone https://github.com/zdharma-continuum/zinit.git \"$ZINIT_HOME\"\nsource \"${ZINIT_HOME}/zinit.zsh\"\n```\n\n[compinit](http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Initialization)):\n\nIf you source `zinit.zsh` after `compinit`, add the following snippet after sourcing `zinit.zsh`:\n\n```zsh\nautoload -Uz _zinit\n(( ${+_comps} )) && _comps[zinit]=_zinit\n```\n\nReload Zsh to install Zinit:\n\n```zsh\nexec zsh\n```\n\nVarious paths can be customized; see section [Customizing Paths](#customizing-paths).\n\n## Usage<a name=\"usage\"></a>\n\n### Introduction<a name=\"introduction\"></a>\n\n[Click here to read the introduction to Zinit](https://zdharma-continuum.github.io/zinit/wiki/INTRODUCTION/). It\nexplains basic usage and some of the more unique features of Zinit, such as the Turbo mode. If you're new to Zinit, we\nrecommend you read it at least once.\n\n### Plugins and snippets<a name=\"plugins-and-snippets\"></a>\n\nPlugins can be loaded using `load` or `light`.\n\n```zsh\nzinit load  <repo/plugin> # Load with reporting/investigating.\nzinit light <repo/plugin> # Load without reporting/investigating.\n```\n\nIf you want to source local or remote files (using direct URL), you can do so with `snippet`.\n\n```zsh\nzinit snippet <URL>\n```\n\nSuch lines should be added to `.zshrc`. Snippets are cached locally. Use the `-f` option to download a new version of a\nsnippet or `zinit update {URL}`. You can also use `zinit update --all` to update all snippets (and plugins).\n\n**Example**\n\n```zsh\n# Plugin history-search-multi-word loaded with investigating.\nzinit load zdharma-continuum/history-search-multi-word\n\n# Two regular plugins loaded without investigating.\nzinit light zsh-users/zsh-autosuggestions\nzinit light zdharma-continuum/fast-syntax-highlighting\n\n# Snippet\nzinit snippet https://gist.githubusercontent.com/hightemp/5071909/raw/\n```\n\n**Prompt(Theme) Example**\n\nThis is [powerlevel10k](https://github.com/romkatv/powerlevel10k), [pure](https://github.com/sindresorhus/pure),\n[starship](https://github.com/starship/starship) sample:\n\n```zsh\n# Load powerlevel10k theme\nzinit ice depth\"1\" # git clone depth\nzinit light romkatv/powerlevel10k\n\n# Load pure theme\nzinit ice pick\"async.zsh\" src\"pure.zsh\" # with zsh-async library that's bundled with it.\nzinit light sindresorhus/pure\n\n# Load starship theme\n# line 1: `starship` binary as command, from github release\n# line 2: starship setup at clone(create init.zsh, completion)\n# line 3: pull behavior same as clone, source init.zsh\nzinit ice as\"command\" from\"gh-r\" \\\n          atclone\"./starship init zsh > init.zsh; ./starship completions zsh > _starship\" \\\n          atpull\"%atclone\" src\"init.zsh\"\nzinit light starship/starship\n```\n\n### Upgrade Zinit and plugins<a name=\"upgrade-zinit-and-plugins\"></a>\n\nZinit can be updated to `self-update` and plugins to `update`.\n\n```zsh\n# Self update\nzinit self-update\n\n# Plugin update\nzinit update\n\n# Plugin parallel update\nzinit update --parallel\n\n# Increase the number of jobs in a concurrent-set to 40\nzinit update --parallel 40\n```\n\n### Turbo and lucid<a name=\"turbo-and-lucid\"></a>\n\nTurbo and lucid are the most used options.\n\n<details>\n  <summary><b>Turbo Mode</b></summary>\nTurbo mode is the key to performance. It can be loaded asynchronously, which makes a huge difference when the amount of plugins increases.\n\nUsually used as `zinit ice wait\"<SECONDS>\"`, let's use the previous example:\n\n```zsh\nzinit ice wait    # wait is the same as wait\"0\"\nzinit load zdharma-continuum/history-search-multi-word\n\nzinit ice wait\"2\" # load after 2 seconds\nzinit load zdharma-continuum/history-search-multi-word\n\nzinit ice wait    # also be used in `light` and `snippet`\nzinit snippet https://gist.githubusercontent.com/hightemp/5071909/raw/\n```\n\n</details>\n\n<details>\n  <summary><b>Lucid</b></summary>\n\nTurbo mode is verbose, so you need an option for quiet.\n\nYou can use `lucid`:\n\n```zsh\nzinit ice wait lucid\nzinit load zdharma-continuum/history-search-multi-word\n```\n\n</details>\n\n**_F&A:_** What is `ice`?\n\n`ice` is zinit's options command. The option melts like ice and is used only once. (more:\n[Ice Modifiers](#ice-modifiers))\n\n### Migration<a name=\"migration\"></a>\n\n<details>\n  <summary><b>Migration from Oh-My-ZSH</b></summary>\n\n**Basic**\n\n```zsh\nzinit snippet <URL>        # Raw Syntax with URL\nzinit snippet OMZ::<PATH>  # Shorthand OMZ/ (https://github.com/ohmyzsh/ohmyzsh/raw/master/)\nzinit snippet OMZL::<PATH> # Shorthand OMZ/lib/\nzinit snippet OMZT::<PATH> # Shorthand OMZ/themes/\nzinit snippet OMZP::<PATH> # Shorthand OMZ/plugins/\n```\n\n**Library**\n\nImporting the [clipboard](https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/clipboard.zsh) and\n[termsupport](https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/termsupport.zsh) Oh-My-Zsh Library Sample:\n\n```zsh\n# Raw Syntax\nzi snippet https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/clipboard.zsh\nzi snippet https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/termsupport.zsh\n\n# OMZ Shorthand Syntax\nzi snippet OMZ::lib/clipboard.zsh\nzi snippet OMZ::lib/termsupport.zsh\n\n# OMZL Shorthand Syntax\nzi snippet OMZL::clipboard.zsh\nzi snippet OMZL::termsupport.zsh\n```\n\n**Theme**\n\nTo use **themes** created for Oh My Zsh you might want to first source the `git` library there.\n\nThen you can use the themes as snippets (`zinit snippet <file path or GitHub URL>`). Some themes require not only Oh My\nZsh's Git **library**, but also Git **plugin** (error about `current_branch` may appear). Load this Git-plugin as\nsingle-file snippet directly from OMZ.\n\nMost themes require `promptsubst` option (`setopt promptsubst` in `zshrc`), if it isn't set, then prompt will appear as\nsomething like: `... $(build_prompt) ...`.\n\nYou might want to suppress completions provided by the git plugin by issuing `zinit cdclear -q` (`-q` is for quiet) –\nsee below **Ignoring Compdefs**.\n\nTo summarize:\n\n```zsh\n## Oh My Zsh Setting\nZSH_THEME=\"robbyrussell\"\n\n## Zinit Setting\n# Must Load OMZ Git library\nzi snippet OMZL::git.zsh\n\n# Load Git plugin from OMZ\nzi snippet OMZP::git\nzi cdclear -q # <- forget completions provided up to this moment\n\nsetopt promptsubst\n\n# Load Prompt\nzi snippet OMZT::robbyrussell\n```\n\nExternal Theme Sample: [NicoSantangelo/Alpharized](https://github.com/nicosantangelo/Alpharized)\n\n```zsh\n## Oh My Zsh Setting\nZSH_THEME=\"alpharized\"\n\n## Zinit Setting\n# Must Load OMZ Git library\nzi snippet OMZL::git.zsh\n\n# Load Git plugin from OMZ\nzi snippet OMZP::git\nzi cdclear -q # <- forget completions provided up to this moment\n\nsetopt promptsubst\n\n# Load Prompt\nzi light NicoSantangelo/Alpharized\n```\n\n## Frequently Asked Questions<a name=\"frequently-asked-questions\"></a>\n\nError occurs when loading OMZ's theme.\n\nIf the `git` library will not be loaded, the following errors will appear:\n\n```zsh\n........:1: command not found: git_prompt_status\n........:1: command not found: git_prompt_short_sha\n```\n\n**Plugin**\n\nIf it consists of a single file, you can just load it.\n\n```zsh\n## Oh-My-Zsh Setting\nplugins=(\n  git\n  dotenv\n  rake\n  rbenv\n  ruby\n)\n\n## Zinit Setting\nzi snippet OMZP::git\nzi snippet OMZP::dotenv\nzi snippet OMZP::rake\nzi snippet OMZP::rbenv\nzi snippet OMZP::ruby\n```\n\n### Use `zi ice svn` if a plugin/snippet requires an entire subdirectory<a name=\"use-zi-ice-svn-if-a-pluginsnippet-requires-an-entire-subdirectory\"></a>\n\n1. [gitfast](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/gitfast)\n2. [osx](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/osx)\n\n```zsh\nzi ice svn\nzi snippet OMZP::gitfast\n\nzi ice svn\nzi snippet OMZP::osx\n```\n\n### Use `zi ice as'completion'` to directly add single file completion snippets<a name=\"use-zi-ice-ascompletion-to-directly-add-single-file-completion-snippets\"></a>\n\n1. [docker](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/docker)\n2. [fd](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/fd)\n\n```zsh\nzi ice as\"completion\"\nzi snippet OMZP::docker/_docker\n\nzi ice as\"completion\"\nzi snippet OMZP::fd/_fd\n```\n\n[Find more information on Oh-My-Zsh + Zinit on the Wiki](https://zdharma-continuum.github.io/zinit/wiki/Example-Oh-My-Zsh-setup/)\n\n</details>\n\n<details>\n  <summary><b>Migration from Prezto</b></summary>\n\n**Basic**\n\n```zsh\nzi snippet <URL>        # Raw Syntax with URL\nzi snippet PZT::<PATH>  # Shorthand PZT/ (https://github.com/sorin-ionescu/prezto/tree/master/)\nzi snippet PZTM::<PATH> # Shorthand PZT/modules/\n```\n\n**Modules**\n\nImporting the [environment](https://github.com/sorin-ionescu/prezto/tree/master/modules/environment) and\n[terminal](https://github.com/sorin-ionescu/prezto/tree/master/modules/terminal) Prezto Modules Sample:\n\n```zsh\n## Prezto Setting\nzstyle ':prezto:load' pmodule 'environment' 'terminal'\n\n## Zinit Setting\n# Raw Syntax\nzi snippet https://github.com/sorin-ionescu/prezto/blob/master/modules/environment/init.zsh\nzi snippet https://github.com/sorin-ionescu/prezto/blob/master/modules/terminal/init.zsh\n\n# PZT Shorthand Syntax\nzi snippet PZT::modules/environment\nzi snippet PZT::modules/terminal\n\n# PZTM Shorthand Syntax\nzi snippet PZTM::environment\nzi snippet PZTM::terminal\n```\n\nUse `zinit ice svn` if multiple files require an entire subdirectory. Like\n[docker](https://github.com/sorin-ionescu/prezto/tree/master/modules/docker),\n[git](https://github.com/sorin-ionescu/prezto/tree/master/modules/git):\n\n```zsh\nzi ice svn\nzi snippet PZTM::docker\n\nzi ice svn\nzi snippet PZTM::git\n```\n\nUse `zinit ice as\"null\"` if don't exist `*.plugin.zsh`, `init.zsh`, `*.zsh-theme*` files in module. Like\n[archive](https://github.com/sorin-ionescu/prezto/tree/master/modules/archive):\n\n```zsh\nzi ice svn as\"null\"\nzi snippet PZTM::archive\n```\n\nUse `zinit ice atclone\"git clone <repo> <location>\"` if module have external module. Like\n[completion](https://github.com/sorin-ionescu/prezto/tree/master/modules/completion):\n\n```zsh\nzi ice \\\n  atclone\"git clone --recursive https://github.com/zsh-users/zsh-completions.git external\" \\\n  blockf \\ # use blockf to prevent any unnecessary additions to fpath, as zinit manages fpath\n  svn\n\nzi snippet PZTM::completion\n```\n\n**_F&A:_** What is `zstyle`?\n\nRead [zstyle](http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzutil-Module) doc (more:\n[What does `zstyle` do?](https://unix.stackexchange.com/questions/214657/what-does-zstyle-do)).\n\n</details>\n\n<details>\n  <summary><b>Migration from Zgen</b></summary>\n\n**Oh My Zsh**\n\nMore reference: check **Migration from Oh-My-ZSH**\n\n```zsh\n# Load ohmyzsh base\nzgen oh-my-zsh\nzi snippet OMZL::<ALL OF THEM>\n\n# Load ohmyzsh plugins\nzgen oh-my-zsh <PATH>\nzi snippet OMZ::<PATH>\n```\n\n**Prezto**\n\nMore reference: check **Migration from Prezto**\n\n```zsh\n# Load Prezto\nzgen prezto\nzi snippet PZTM::<COMMENT's List> # environment terminal editor history directory spectrum utility completion prompt\n\n# Load prezto plugins\nzgen prezto <modulename>\nzi snippet PZTM::<modulename>\n\n# Load a repo as Prezto plugins\nzgen pmodule <reponame> <branch>\nzi ice ver\"<branch>\"\nzi load <repo/plugin>\n\n# Set prezto options\nzgen prezto <modulename> <option> <value(s)>\nzstyle ':prezto:<modulename>:' <option> <values(s)> # Set original prezto style\n```\n\n**General**\n\n`location`: refer [Selection of Files](#selection-of-files-to-source-)\n\n```zsh\nzgen load <repo> [location] [branch]\n\nzi ice ver\"[branch]\"\nzi load <repo>\n```\n\n</details>\n\n<details>\n  <summary><b>Migration from Zplug</b></summary>\n\n**Basic**\n\n```zsh\nzplug <repo/plugin>, tag1:<option1>, tag2:<option2>\n\nzi ice tag1\"<option1>\" tag2\"<option2>\"\nzi load <repo/plugin>\n```\n\n**Tag comparison**\n\n- `as` => `as`\n- `use` => `pick`, `src`, `multisrc`\n- `ignore` => None\n- `from` => `from`\n- `at` => `ver`\n- `rename-to` => `mv`, `cp`\n- `dir` => Selection(`pick`, ...) with rename\n- `if` => `if`\n- `hook-build` => `atclone`, `atpull`\n- `hook-load` => `atload`\n- `frozen` => None\n- `on` => None\n- `defer` => `wait`\n- `lazy` => `autoload`\n- `depth` => `depth`\n\n</details>\n\n### More Examples<a name=\"more-examples\"></a>\n\nAfter installing Zinit you can start adding some actions (load some plugins) to `~/.zshrc`, at bottom. Some examples:\n\n```zsh\n# Load the pure theme, with zsh-async library that's bundled with it.\nzi ice pick\"async.zsh\" src\"pure.zsh\"\nzi light sindresorhus/pure\n\n# A glance at the new for-syntax – load all of the above\n# plugins with a single command. For more information see:\n# https://zdharma-continuum.github.io/zinit/wiki/For-Syntax/\nzinit for \\\n    light-mode \\\n  zsh-users/zsh-autosuggestions \\\n    light-mode \\\n  zdharma-continuum/fast-syntax-highlighting \\\n  zdharma-continuum/history-search-multi-word \\\n    light-mode \\\n    pick\"async.zsh\" \\\n    src\"pure.zsh\" \\\n  sindresorhus/pure\n\n# Binary release in archive, from GitHub-releases page.\n# After automatic unpacking it provides program \"fzf\".\nzi ice from\"gh-r\" as\"program\"\nzi light junegunn/fzf\n\n# One other binary release, it needs renaming from `docker-compose-Linux-x86_64`.\n# This is done by ice-mod `mv'{from} -> {to}'. There are multiple packages per\n# single version, for OS X, Linux and Windows – so ice-mod `bpick' is used to\n# select Linux package – in this case this is actually not needed, Zinit will\n# grep operating system name and architecture automatically when there's no `bpick'.\nzi ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" bpick\"*linux*\"\nzi load docker/compose\n\n# Vim repository on GitHub – a typical source code that needs compilation – Zinit\n# can manage it for you if you like, run `./configure` and other `make`, etc.\n# Ice-mod `pick` selects a binary program to add to $PATH. You could also install the\n# package under the path $ZPFX, see: https://zdharma-continuum.github.io/zinit/wiki/Compiling-programs\nzi ice \\\n  as\"program\" \\\n  atclone\"rm -f src/auto/config.cache; ./configure\" \\\n  atpull\"%atclone\" \\\n  make \\\n  pick\"src/vim\"\nzi light vim/vim\n\n# Scripts built at install (there's single default make target, \"install\",\n# and it constructs scripts by `cat'ing a few files). The make'' ice could also be:\n# `make\"install PREFIX=$ZPFX\"`, if \"install\" wouldn't be the only default target.\nzi ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\"\nzi light tj/git-extras\n\n# Handle completions without loading any plugin; see \"completions\" command.\n# This one is to be ran just once, in interactive session.\nzi creinstall %HOME/my_completions\n```\n\n```zsh\n# For GNU ls (the binaries can be gls, gdircolors, e.g. on OS X when installing the\n# coreutils package from Homebrew; you can also use https://github.com/ogham/exa)\nzi ice atclone\"dircolors -b LS_COLORS > c.zsh\" atpull'%atclone' pick\"c.zsh\" nocompile'!'\nzi light trapd00r/LS_COLORS\n```\n\n[You can see an extended explanation of LS_COLORS in the Wiki.](https://zdharma-continuum.github.io/zinit/wiki/LS_COLORS-explanation/)\n\n```zsh\n# make'!...' -> run make before atclone & atpull\nzi ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' atpull'%atclone' src\"zhook.zsh\"\nzi light direnv/direnv\n```\n\n[You can see an extended explanation of direnv in the Wiki.](https://zdharma-continuum.github.io/zinit/wiki/Direnv-explanation/)\n\nIf you're interested in more examples, then check out the\n[zinit-configs repository](https://github.com/zdharma-continuum/zinit-configs), where users have uploaded their\n`~/.zshrc` and Zinit configurations. Feel free to\n[submit](https://github.com/zdharma-continuum/zinit-configs/issues/new?template=request-to-add-zshrc-to-the-zinit-configs-repo.md)\nyour `~/.zshrc` there if it contains Zinit commands.\n\nYou can also check out the [Gallery of Zinit Invocations](https://zdharma-continuum.github.io/zinit/wiki/GALLERY/) for\nsome additional examples.\n\nAlso, two articles on the Wiki present an example setup\n[here](https://zdharma-continuum.github.io/zinit/wiki/Example-Minimal-Setup/) and\n[here](https://zdharma-continuum.github.io/zinit/wiki/Example-Oh-My-Zsh-setup/).\n\n# How to Use<a name=\"how-to-use\"></a>\n\n## Ice Modifiers<a name=\"ice-modifiers\"></a>\n\nFollowing `ice` modifiers are to be [passed](https://zdharma-continuum.github.io/zinit/wiki/Alternate-Ice-Syntax/) to\n`zinit ice ...` to obtain described effects. The word `ice` means something that's added (like ice to a drink) – and in\nZinit it means adding modifier to a next `zinit` command, and also something that's temporary because it melts – and\nthis means that the modification will last only for a **single** next `zinit` command.\n\nSome Ice-modifiers are highlighted and clicking on them will take you to the appropriate Wiki page for an extended\nexplanation.\n\nYou may safely assume a given ice works with both plugins and snippets unless explicitly stated otherwise.\n\n### Cloning Options<a name=\"cloning-options\"></a>\n\n| Modifier    | Description                                                                                                                                                                                                                                                                                                                                  |\n| :---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `bpick`     | Used to select which release from GitHub Releases to download, e.g. `zini ice from\"gh-r\" as\"program\" bpick\"*Darwin*\"; zini load docker/compose`. **Does not work with snippets.**                                                                                                                                                            |\n| `cloneopts` | Pass the contents of `cloneopts` to `git clone`. Defaults to `--recursive`. I.e.: change cloning options. Pass empty ice to disable recursive cloning. **Does not work with snippets.**                                                                                                                                                      |\n| `depth`     | Pass `--depth` to `git`, i.e. limit how much of history to download. **Does not work with snippets.**                                                                                                                                                                                                                                        |\n| `from`      | Clone plugin from given site. Supported are `from\"github\"` (default), `...\"github-rel\"`, `...\"gitlab\"`, `...\"bitbucket\"`, `...\"notabug\"` (short names: `gh`, `gh-r`, `gl`, `bb`, `nb`). Can also be a full domain name (e.g. for GitHub enterprise). **Does not work with snippets.**                                                        |\n| `proto`     | Change protocol to `git`,`ftp`,`ftps`,`ssh`, `rsync`, etc. Default is `https`. **Does not work with snippets.**                                                                                                                                                                                                                              |\n| `pullopts`  | Pass the contents of `pullopts` to `git pull` used when updating plugins. **Does not work with snippets.**                                                                                                                                                                                                                                   |\n| `svn`       | Use Subversion for downloading snippet. GitHub supports `SVN` protocol, this allows to clone subdirectories as snippets, e.g. `zinit ice svn; zinit snippet OMZP::git`. Other ice `pick` can be used to select file to source (default are: `*.plugin.zsh`, `init.zsh`, `*.zsh-theme`). **Does not work with plugins.**                      |\n| `ver`       | Used with `from\"gh-r\"` (i.e. downloading a binary release, e.g. for use with `as\"program\"`) – selects which version to download. Default is latest, can also be explicitly `ver\"latest\"`. Works also with regular plugins and packages (`pack` ice) checkouts e.g. `ver\"abranch\"`, i.e. a specific version. **Does not work with snippets.** |\n\n### Selection of Files (To Source, …)<a name=\"selection-of-files-to-source-%E2%80%A6\"></a>\n\n| Modifier   | Description                                                                                                                                                                                                                                |\n| :--------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `multisrc` | Allows to specify multiple files for sourcing, enumerated with spaces as the separators (e.g. `multisrc'misc.zsh grep.zsh'`) and also using brace-expansion syntax (e.g. `multisrc'{misc,grep}.zsh'`). Supports patterns.                  |\n| `pick`     | Select the file to source, or the file to set as command (when using `snippet --command` or the ice `as\"program\"`); it is a pattern, alphabetically first matched file is being chosen; e.g. `zinit ice pick\"*.plugin.zsh\"; zinit load …`. |\n| `src`      | Specify additional file to source after sourcing main file or after setting up command (via `as\"program\"`). It is not a pattern but a plain file name.                                                                                     |\n\n### Conditional Loading<a name=\"conditional-loading\"></a>\n\n| Modifier                     | Description                                                                                                                                                                                                                                                                                                                                                              |\n| :--------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `cloneonly`                  | Don't load the plugin / snippet, only download it                                                                                                                                                                                                                                                                                                                        |\n| `has`                        | Load plugin or snippet only when given command is available (in $PATH), e.g. `zinit ice has'git' ...`                                                                                                                                                                                                                                                                    |\n| `if`                         | Load plugin or snippet only when given condition is fulfilled, for example: `zinit ice if'[[ -n \"$commands[otool]\" ]]'; zinit load ...`.                                                                                                                                                                                                                                 |\n| `load`                       | A condition to check which should cause plugin to load. It will load once, the condition can be still true, but will not trigger second load (unless plugin is unloaded earlier, see `unload` below). E.g.: `load'[[ $PWD = */github* ]]'`.                                                                                                                              |\n| `subscribe` / `on-update-of` | Postpone loading of a plugin or snippet until the given file(s) get updated, e.g. `subscribe'{~/files-*,/tmp/files-*}'`                                                                                                                                                                                                                                                  |\n| `trigger-load`               | Creates a function that loads the associated plugin/snippet, with an option (to use it, precede the ice content with `!`) to automatically forward the call afterwards, to a command of the same name as the function. Can obtain multiple functions to create – sparate with `;`.                                                                                       |\n| `unload`                     | A condition to check causing plugin to unload. It will unload once, then only if loaded again. E.g.: `unload'[[ $PWD != */github* ]]'`.                                                                                                                                                                                                                                  |\n| `wait`                       | Postpone loading a plugin or snippet. For `wait'1'`, loading is done `1` second after prompt. For `wait'[[ ... ]]'`, `wait'(( ... ))'`, loading is done when given condition is meet. For `wait'!...'`, prompt is reset after load. Zsh can start 80% (i.e.: 5x) faster thanks to postponed loading. **Fact:** when `wait` is used without value, it works as `wait'0'`. |\n\n### Plugin Output<a name=\"plugin-output\"></a>\n\n| Modifier | Description                                                                                                                                                                                                                                                                                                 |\n| :------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `lucid`  | Skip `Loaded ...` message under prompt for `wait`, etc. loaded plugins (a subset of `silent`).                                                                                                                                                                                                              |\n| `notify` | Output given message under-prompt after successfully loading a plugin/snippet. In case of problems with the loading, output a warning message and the return code. If starts with `!` it will then always output the given message. Hint: if the message is empty, then it will just notify about problems. |\n| `silent` | Mute plugin's or snippet's `stderr` & `stdout`. Also skip `Loaded ...` message under prompt for `wait`, etc. loaded plugins, and completion-installation messages.                                                                                                                                          |\n\n### Completions<a name=\"completions\"></a>\n\n| Modifier        | Description                                                                                                                                                                         |\n| :-------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `blockf`        | Disallow plugin to modify `fpath`. Useful when a plugin wants to provide completions in traditional way. Zinit can manage completions and plugin can be blocked from exposing them. |\n| `completions`   | Do detect, install and manage completions for this plugin. Overwrites `as'null'` or `nocompletions`.                                                                                |\n| `nocompletions` | Don't detect, install and manage completions for this plugin. Completions can be installed later with `zinit creinstall {plugin-spec}`.                                             |\n\n### Command Execution After Cloning, Updating or Loading<a name=\"command-execution-after-cloning-updating-or-loading\"></a>\n\n| Modifier     | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| :----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `atclone`    | Run command after cloning, within plugin's directory, e.g. `zinit ice atclone\"echo Cloned\"`. Ran also after downloading snippet.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| `atinit`     | Run command after directory setup (cloning, checking it, etc.) of plugin/snippet but before loading.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| `atload`     | Run command after loading, within plugin's directory. Can be also used with snippets. Passed code can be preceded with `!`, it will then be investigated (if using `load`, not `light`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| `atpull`     | Run command after updating (**only if new commits are waiting for download**), within plugin's directory. If starts with \"!\" then command will be ran before `mv` & `cp` ices and before `git pull` or `svn update`. Otherwise it is ran after them. Can be `atpull'%atclone'`, to repeat `atclone` Ice-mod.                                                                                                                                                                                                                                                                                                                                                              |\n| `configure`  | Runs `./configure` script and by default changes the installation directory by passing `--prefix=$ZPFX` to the script. Runs before `make''` and after `make'!'`, you can pass `'!'` too to this ice (i.e.: `configure'!'`) to make it execute earlier – before `make'!'` and after `make'!!'`. If `#` given in the ice value then also executes script `./autogen.sh` first before running `./configure`. The script is run anyway if there is no `configure` script. Also, when there exist another build-system related files, then it is run if no `configure` script is found. Currently supported systems are: CMake, scons and meson, checked-for/run in this order |\n| `countdown`  | Causes an interruptable (by Ctrl-C) countdown 5…4…3…2…1…0 to be displayed before executing `atclone''`,`atpull''` and `make` ices                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| `cp`         | Copy file after cloning or after update (then, only if new commits were downloaded). Example: `cp \"docker-c* -> dcompose\"`. Ran after `mv`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| `make`       | Run `make` command after cloning/updating and executing `mv`, `cp`, `atpull`, `atclone` Ice mods. Can obtain argument, e.g. `make\"install PREFIX=/opt\"`. If the value starts with `!` then `make` is ran before `atclone`/`atpull`, e.g. `make'!'`.                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| `mv`         | Move file after cloning or after update (then, only if new commits were downloaded). Example: `mv \"fzf-* -> fzf\"`. It uses `->` as separator for old and new file names. Works also with snippets.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| `nocd`       | Don't switch the current directory into the plugin's directory when evaluating the above ice-mods `atinit''`,`atload''`, etc.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| `reset`      | Invokes `git reset --hard HEAD` for plugins or `svn revert` for SVN snippets before pulling any new changes. This way `git` or `svn` will not report conflicts if some changes were done in e.g.: `atclone''` ice. For file snippets and `gh-r` plugins it invokes `rm -rf *`.                                                                                                                                                                                                                                                                                                                                                                                            |\n| `run-atpull` | Always run the atpull hook (when updating), not only when there are new commits to be downloaded.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n\n### Sticky-Emulation Of Other Shells<a name=\"sticky-emulation-of-other-shells\"></a>\n\n| Modifier       | Description                                                                                                                                                                                                                                                                                                                                |\n| :------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `sh`/`!sh`     | Source the plugin's (or snippet's) script with `sh` emulation so that also all functions declared within the file will get a _sticky_ emulation assigned – when invoked they'll execute also with the `sh` emulation set-up. The `!sh` version switches additional options that are rather not important from the portability perspective. |\n| `csh`/`!csh`   | The same as `sh`, but emulating `csh` shell.                                                                                                                                                                                                                                                                                               |\n| `ksh`/`!ksh`   | The same as `sh`, but emulating `ksh` shell.                                                                                                                                                                                                                                                                                               |\n| `bash`/`!bash` | The same as `sh`, but with the `SH_GLOB` option disabled, so that Bash regular expressions work.                                                                                                                                                                                                                                           |\n\n### Others<a name=\"others\"></a>\n\n| Modifier       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| :------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `as`           | Can be `as\"program\"` (also the alias: `as\"command\"`), and will cause to add script/program to `$PATH` instead of sourcing (see `pick`). Can also be `as\"completion\"` – use with plugins or snippets in whose only underscore-starting `_*` files you are interested in. The third possible value is `as\"null\"` – a shorthand for `pick\"/dev/null\" nocompletions` – i.e.: it disables the default script-file sourcing and also the installation of completions.                                                                                                                                                                                                   |\n| `link`         | Use a symlink to cache a local snippet instead of copying into the snippets directory. Uses relative links if realpath >= 8.23 is found. **_Does not apply to URL-based snippets. Does not work with plugins._**                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| `id-as`        | Nickname a plugin or snippet, to e.g. create a short handler for long-url snippet.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| `subst`        | Substitute the given string into another string when sourcing the plugin script, e.g.: `zinit subst'autoload → autoload -Uz' …`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| `aliases`      | Load the plugin with the aliases mechanism enabled. Use with plugins that define **and use** aliases in their scripts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| `autoload`     | Autoload the given functions (from their files). Equvalent to calling `atinit'autoload the-function'`. Supports renaming of the function – pass `'… → new-name'` or `'… -> new-name'`, e.g.: `zinit autoload'fun → my-fun; fun2 → my-fun2'`.                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| `bindmap`      | To hold `;`-separated strings like `Key(s)A -> Key(s)B`, e.g. `^R -> ^T; ^A -> ^B`. In general, `bindmap''`changes bindings (done with the `bindkey` builtin) the plugin does. The example would cause the plugin to map Ctrl-T instead of Ctrl-R, and Ctrl-B instead of Ctrl-A. **Does not work with snippets.**                                                                                                                                                                                                                                                                                                                                                 |\n| `compile`      | Pattern (+ possible `{...}` expansion, like `{a/*,b*}`) to select additional files to compile, e.g. \\`compile\"(pure\\\\                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| `extract`      | Performs archive extraction supporting multiple formats like `zip`, `tar.gz`, etc. and also notably OS X `dmg` images. If it has no value, then it works in the _auto_ mode – it automatically extracts all files of known archive extensions IF they aren't located deeper than in a sub-directory (this is to prevent extraction of some helper archive files, typically located somewhere deeper in the tree). If no such files will be found, then it extracts all found files of known **type** – the type is being read by the `file` Unix command. If not empty, then takes names of the files to extract. Refer to the Wiki page for further information. |\n| `service`      | Make following plugin or snippet a _service_, which will be ran in background, and only in single Zshell instance. See [the zservice-\\* repositories](https://github.com/orgs/zdharma-continuum/repositories?q=zservice-).                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| `light-mode`   | Load the plugin without the investigating, i.e.: as if it would be loaded with the `light` command. Useful for the for-syntax, where there is no `load` nor `light` subcommand                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| `nocompile`    | Don't try to compile `pick`-pointed files. If passed the exclamation mark (i.e. `nocompile'!'`), then do compile, but after `make''` and `atclone''` (useful if Makefile installs some scripts, to point `pick''` at the location of their installation).                                                                                                                                                                                                                                                                                                                                                                                                         |\n| `trackbinds`   | Shadow but only `bindkey` calls even with `zinit light ...`, i.e. even with investigating disabled (fast loading), to allow `bindmap` to remap the key-binds. The same effect has `zinit light -b ...`, i.e. additional `-b` option to the `light`-subcommand. **Does not work with snippets.**                                                                                                                                                                                                                                                                                                                                                                   |\n| `wrap-track`   | Takes a `;`-separated list of function names that are to be investigated (meaning gathering report and unload data) **once** during execution. It works by wrapping the functions with a investigating-enabling and disabling snippet of code. In summary, `wrap-track` allows to extend the investigating beyond the moment of loading of a plugin. Example use is to `wrap-track` a precmd function of a prompt (like `_p9k_precmd()` of powerlevel10k) or other plugin that _postpones its initialization till the first prompt_ (like e.g.: zsh-autosuggestions). **Does not work with snippets.**                                                            |\n| `reset-prompt` | Reset the prompt after loading the plugin/snippet (by issuing `zle .reset-prompt`). Note: normally it's sufficient to precede the value of `wait''` ice with `!`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n\n### Order of Execution<a name=\"order-of-execution\"></a>\n\nOrder of execution of related Ice-mods: `atinit` -> `atpull!` -> `make'!!'` -> `mv` -> `cp` -> `make!` ->\n`atclone`/`atpull` -> `make` -> `(plugin script loading)` -> `src` -> `multisrc` -> `atload`.\n\n## Zinit Commands<a name=\"zinit-commands\"></a>\n\nFollowing commands are passed to `zinit ...` to obtain described effects.\n\n### Help<a name=\"help\"></a>\n\n| Command   | Description           |\n| :-------- | --------------------- |\n| `help`    | Usage information.    |\n| `man`     | Manual.               |\n| `version` | Display Zinit version |\n\n### Loading and Unloading<a name=\"loading-and-unloading\"></a>\n\n| Command                  | Description                                                                                                                                                                                                                                                                                                          |\n| :----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `load {plg-spec}`        | Load plugin, can also receive absolute local path.                                                                                                                                                                                                                                                                   |\n| `snippet [-f] {url}`     | Source local or remote file (by direct URL). `-f` – don't use cache (force redownload). The URL can use the following shorthands: `PZT::` (Prezto), `PZTM::` (Prezto module), `OMZ::` (Oh My Zsh), `OMZP::` (OMZ plugin), `OMZL::` (OMZ library), `OMZT::` (OMZ theme), e.g.: `PZTM::environment`, `OMZP::git`, etc. |\n| `light [-b] {plg-spec}`  | Light plugin load, without reporting/investigating. `-b` – investigate `bindkey`-calls only. There's also `light-mode` ice which can be used to induce the no-investigating (i.e.: _light_) loading, regardless of the command used.                                                                                 |\n| `unload [-q] {plg-spec}` | Unload plugin loaded with `zinit load ...`. `-q` – quiet.                                                                                                                                                                                                                                                            |\n\n### Completions<a name=\"completions-1\"></a>\n\n| Command                           | Description                                                                                                                                         |\n| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `cclear`                          | Clear stray and improper completions.                                                                                                               |\n| `cdclear [-q]`                    | Clear compdef replay list. `-q` – quiet.                                                                                                            |\n| `cdisable {cname}`                | Disable completion `cname`.                                                                                                                         |\n| `cdlist`                          | Show compdef replay list.                                                                                                                           |\n| `cdreplay [-q]`                   | Replay compdefs (to be done after compinit). `-q` – quiet.                                                                                          |\n| `cenable {cname}`                 | Enable completion `cname`.                                                                                                                          |\n| `completions \\[*columns*\\]`       | List completions in use, with <code>columns</code> completions per line. `zpl clist 5` will for example print 5 completions per line. Default is 3. |\n| `compinit`                        | Refresh installed completions.                                                                                                                      |\n| `creinstall [-q] [-Q] {plg-spec}` | Install completions for plugin, can also receive absolute local path. `-q` – quiet. `-Q` - quiet all.                                               |\n| `csearch`                         | Search for available completions from any plugin.                                                                                                   |\n| `cuninstall {plg-spec}`           | Uninstall completions for plugin.                                                                                                                   |\n\n### Tracking of the Active Session<a name=\"tracking-of-the-active-session\"></a>\n\n| Command          | Description                                       |\n| ---------------- | ------------------------------------------------- |\n| `dclear`         | Clear report of what was going on in session.     |\n| `dstop`          | Stop investigating what's going on in session.    |\n| `dreport`        | Report what was going on in session.              |\n| `dunload`        | Revert changes recorded between dstart and dstop. |\n| `dtrace, dstart` | Start investigating what's going on in session.   |\n\n### Reports and Statistics<a name=\"reports-and-statistics\"></a>\n\n| Command                  | Description                                                                                                                                              |\n| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `bindkeys`               | Lists bindkeys set up by each plugin.                                                                                                                    |\n| `list-plugins [keyword]` | Show what plugins are loaded (filter with 'keyword').                                                                                                    |\n| `list-snippets`          | List snippets in formatted and colorized manner. Requires `tree` program.                                                                                |\n| `recently [time-spec]`   | Show plugins that changed recently, argument is e.g. 1 month 2 days.                                                                                     |\n| `report {plg-spec}`      | Show plugin report. `--all` – do it for all plugins.                                                                                                     |\n| `status {plg-spec}`      | Git status for plugin or svn status for snippet. `--all` – do it for all plugins and snippets.                                                           |\n| `zstatus`                | Display brief statistics for your Zinit installation.                                                                                                    |\n| `times [-a] [-m] [-s]`   | Print load times for each plugin. `-s` – Times are printed in seconds. `-m` – Show plugin loading moments. `-a` - Times and loading moments are printed. |\n\n### Compiling<a name=\"compiling\"></a>\n\n#### compile<a name=\"compile\"></a>\n\nList plugins that are compiled.\n\n```zsh\nzinit [options] compile PLUGIN\n```\n\n| Option        | Description               |\n| ------------- | ------------------------- |\n| `-a, --all`   | Compile all plugins       |\n| `-h, --help`  | Print usage               |\n| `-q, --quiet` | Suppress the build output |\n\n#### compiled<a name=\"compiled\"></a>\n\nList plugins that are compiled.\n\n```zsh\nzinit compiled\n```\n\n#### uncompile<a name=\"uncompile\"></a>\n\nList plugins that are compiled.\n\n```zsh\nzinit [options] uncompile PLUGIN\n```\n\n| Option        | Description                               |\n| ------------- | ----------------------------------------- |\n| `-a, --all`   | Remove any compiled files for all plugins |\n| `-h, --help`  | Print usage                               |\n| `-q, --quiet` | Suppress the output                       |\n\n### Other<a name=\"other\"></a>\n\n| Command                                                          | Description                                                                                                                                                                                                                                                                                                                           |\n| ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `module`                                                         | Manage binary Zsh module shipped with Zinit, see `zinit module help`.                                                                                                                                                                                                                                                                 |\n| `self-update`                                                    | Updates and compiles Zinit.                                                                                                                                                                                                                                                                                                           |\n| `cd {plg-spec}`                                                  | Cd into plugin's directory. Also support snippets if fed with URL.                                                                                                                                                                                                                                                                    |\n| `edit {plg-spec}`                                                | Edit plugin's file with $EDITOR.                                                                                                                                                                                                                                                                                                      |\n| `changes {plg-spec}`                                             | View plugin's git log.                                                                                                                                                                                                                                                                                                                |\n| `create {plg-spec}`                                              | Create plugin (also together with GitHub repository).                                                                                                                                                                                                                                                                                 |\n| `glance {plg-spec}`                                              | Look at plugin's source (pygmentize, {,source-}highlight).                                                                                                                                                                                                                                                                            |\n| `stress {plg-spec}`                                              | Test plugin for compatibility with set of options.                                                                                                                                                                                                                                                                                    |\n| `recall {plg-spec}\\|URL`                                         | Fetch saved ice modifiers and construct `zinit ice ...` command.                                                                                                                                                                                                                                                                      |\n| `srv {service-id} [cmd]`                                         | Control a service, command can be: stop,start,restart,next,quit; `next` moves the service to another Zshell.                                                                                                                                                                                                                          |\n| `ice <ice specification>`                                        | Add ice to next command, argument is e.g. from\"gitlab\".                                                                                                                                                                                                                                                                               |\n| `env-whitelist [-v] [-h] {env..}`                                | Allows to specify names (also patterns) of variables left unchanged during an unload. `-v` – verbose.                                                                                                                                                                                                                                 |\n| `run` `[-l]` `[plugin]` `{command}`                              | Runs the given command in the given plugin's directory. If the option `-l` will be given then the plugin should be skipped – the option will cause the previous plugin to be reused.                                                                                                                                                  |\n| `delete {plg-spec}\\|URL\\|--clean\\|--all`                         | Remove plugin or snippet from disk (good to forget wrongly passed ice-mods). <br> `--all` – purge.<br> `--clean` – delete plugins and snippets that are not loaded.                                                                                                                                                                   |\n| `update [-q] [-r] {plg-spec}\\|URL\\|--all`                        | Git update plugin or snippet.<br> `--all` – update all plugins and snippets.<br> `-q` – quiet.<br> `-r` \\| `--reset` – run `git reset --hard` / `svn revert` before pulling changes.                                                                                                                                                  |\n| `add-fpath\\|fpath` `[-f\\|--front]` `{plg-spec}` `[subdirectory]` | Adds given plugin (not yet snippet) directory to `$fpath`. If the second argument is given, it is appended to the directory path. If the option `-f`/`--front` is given, the directory path is prepended instead of appended to `$fpath`. The `{plg-spec}` can be absolute path, i.e.: it's possible to also add regular directories. |\n\n## Updating Zinit and Plugins<a name=\"updating-zinit-and-plugins\"></a>\n\nTo update Zinit issue `zinit self-update` in the command line.\n\nTo update all plugins and snippets, issue `zinit update`. If you wish to update only a single plugin/snippet instead\nissue `zinit update NAME_OF_PLUGIN`. A list of commits will be shown:\n\n<p align=\"center\">\n<img src=\"./doc/img/update.png\" />\n</p>\n\nSome plugins require performing an action each time they're updated. One way you can do this is by using the `atpull`\nice modifier. For example, writing `zinit ice atpull'./configure'` before loading a plugin will execute `./configure`\nafter a successful update. Refer to [Ice Modifiers](#ice-modifiers) for more information.\n\nThe ice modifiers for any plugin or snippet are stored in their directory in a `._zinit` subdirectory, hence the plugin\ndoesn't have to be loaded to be correctly updated. There's one other file created there, `.zinit_lstupd` – it holds the\nlog of the new commits pulled-in in the last update.\n\n## Completions<a name=\"completions-2\"></a>\n\n### Calling `compinit` Without Turbo Mode<a name=\"calling-compinit-without-turbo-mode\"></a>\n\nWith no Turbo mode in use, compinit can be called normally, i.e.: as `autoload compinit; compinit`. This should be done\nafter loading of all plugins and before possibly calling `zinit cdreplay`.\n\nThe `cdreplay` subcommand is provided to re-play all catched `compdef` calls. The `compdef` calls are used to define a\ncompletion for a command. For example, `compdef _git git` defines that the `git` command should be completed by a `_git`\nfunction.\n\nThe `compdef` function is provided by `compinit` call. As it should be called later, after loading all of the plugins,\nZinit provides its own `compdef` function that catches (i.e.: records in an array) the arguments of the call, so that\nthe loaded plugins can freely call `compdef`. Then, the `cdreplay` (_compdef-replay_) can be used, after `compinit` will\nbe called (and the original `compdef` function will become available), to execute all detected `compdef` calls. To\nsummarize:\n\n```zsh\nZINIT_HOME=\"${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git\"\nsource \"${ZINIT_HOME}/zinit.zsh\"\n\nzinit load \"some/plugin\"\n...\ncompdef _gnu_generic fd  # this will be intercepted by Zinit, because as the compinit\n                         # isn't yet loaded, thus there's no such function `compdef'; yet\n                         # Zinit provides its own `compdef' function which saves the\n                         # completion-definition for later possible re-run with `zinit\n                         # cdreplay' or `zicdreplay' (the second one can be used in hooks\n                         # like atload'', atinit'', etc.)\n...\nzinit load \"other/plugin\"\n\nautoload -Uz compinit\ncompinit\n\n# -q is for quiet; actually run all the `compdef's saved before `compinit` call\n# (`compinit' declares the `compdef' function, so it cannot be used until\n# `compinit' is ran; Zinit solves this via intercepting the `compdef'-calls and\n# storing them for later use with `zinit cdreplay')\n\nzinit cdreplay -q\n```\n\nThis allows to call compinit once. Performance gains are huge, example shell startup time with double `compinit`:\n**0.980** sec, with `cdreplay` and single `compinit`: **0.156** sec.\n\n### Calling `compinit` With Turbo Mode<a name=\"calling-compinit-with-turbo-mode\"></a>\n\nIf you load completions using `wait''` Turbo mode then you can add `atinit'zicompinit'` to syntax-highlighting plugin\n(which should be the last one loaded, as their (2 projects,\n[z-sy-h](https://github.com/zsh-users/zsh-syntax-highlighting) &\n[f-sy-h](https://github.com/zdharma-continuum/fast-syntax-highlighting)) documentation state), or `atload'zicompinit'`\nto last completion-related plugin. `zicompinit` is a function that just runs `autoload compinit; compinit`, created for\nconvenience. There's also `zicdreplay` which will replay any caught compdefs so you can also do:\n`atinit'zicompinit; zicdreplay'`, etc. Basically, the whole topic is the same as normal `compinit` call, but it is done\nin `atinit` or `atload` hook of the last related plugin with use of the helper functions (`zicompinit`,`zicdreplay` &\n`zicdclear` – see below for explanation of the last one). To summarize:\n\n```zsh\nZINIT_HOME=\"${XDG_DATA_HOME:-${HOME}/.local/share/zinit}\"\nsource \"${ZINIT_HOME}/zinit.zsh\"\n\n# Load using the for-syntax\nzinit lucid wait for \\\n  \"some/plugin\"\n\nzinit lucid wait for \\\n  \"other/plugin\"\n\nzi for \\\n    atload\"zicompinit; zicdreplay\" \\\n    blockf \\\n    lucid \\\n    wait \\\n  zsh-users/zsh-completions\n```\n\n### Ignoring Compdefs<a name=\"ignoring-compdefs\"></a>\n\nIf you want to ignore compdefs provided by some plugins or snippets, place their load commands before commands loading\nother plugins or snippets, and issue `zinit cdclear` (or `zicdclear`, designed to be used in hooks like `atload''`):\n\n```zsh\nZINIT_HOME=\"${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git\"\nsource \"${ZINIT_HOME}/zinit.zsh\"\n\nzi snippet OMZP::git\nzi cdclear -q # <- forget completions provided by Git plugin\n\nzi load \"some/plugin\"\n...\nzi load \"other/plugin\"\n\nautoload -Uz compinit\ncompinit\nzi cdreplay -q # <- execute compdefs provided by rest of plugins\nzi cdlist # look at gathered compdefs\n```\n\nThe `cdreplay` is important if you use plugins like `OMZP::kubectl` or `asdf-vm/asdf`, because these plugins call\n`compdef`.\n\n### Disabling System-Wide `compinit` Call (Ubuntu)<a name=\"disabling-system-wide-compinit-call-ubuntu\"></a>\n\nOn Ubuntu users might get surprised that e.g. their completions work while they didn't call `compinit` in their\n`.zshrc`. That's because the function is being called in `/etc/zshrc`. To disable this call – what is needed to avoid\nthe slowdown and if user loads any completion-equipped plugins, i.e. almost on 100% – add the following lines to\n`~/.zshenv`:\n\n```zsh\n# Skip the not really helping Ubuntu global compinit\nskip_global_compinit=1\n```\n\n## Zinit Module<a name=\"zinit-module\"></a>\n\nThe module is now hosted [in its own repository](https://github.com/zdharma-continuum/zinit-module)\n\n## Hints and Tips<a name=\"hints-and-tips\"></a>\n\n### Using ZPFX variable<a name=\"using-zpfx-variable\"></a>\n\nZinit uses a special, short named variable `$ZPFX` to denote a standard \"prefix\" for installing compiled software. Such,\ncommonly used, prefixes are usually, e.g.: `/usr/`,`/usr/local` or `$HOME/.local`. Basically, when one would want to\nexplain what a prefix-dir is in one sentence, it would be something like: a root directory, under which\n`…/bin`,`…/share`, `…/lib` sub-dirs are populated with installed binaries, data-files, libraries, etc.\n\nHow to use the variable? It is automatically exploited when using `configure''` and `make''` ices, and user doesn't have\nto take any actions. This means that the `configure` command that'll be run will be:\n\n```zsh\n./configure --prefix=$ZPFX\n```\n\nThe default location used for `$ZPFX` is: `~/.local/share/zinit/polaris`. You can, for example, set it to `$HOME/.local`\nto have the software installed with `configure''` and `make''` ices installed to that directory.\n\nTypical use cases when working with `$ZPFX` are, e.g.:\n\n```zsh\n$ ls $ZPFX\n$ cd $ZPFX\n$ cd $ZPFX/bin  # note: $ZPFX/bin is automatically prepended to $PATH\n$ cd $ZPFX/share\n```\n\nBefore the `configure''` ice appeared one would use `$ZPFX` as follows:\n\n```zsh\nzinit atclone'./configure --prefix=$ZPFX` atpull'%atclone' make \\\n        for universal-ctags/ctags\n```\n\nbut now it's sufficient to do:\n\n```zsh\n# Will work for any build system\n# (supported are: configure, cmake, scons and meson)\nzinit configure make for universal-ctags/ctags\n```\n\nTo set ZPFX, one should do (in `.zshrc` before loading `zinit`):\n\n```zsh\n$ export ZPFX=$HOME/my-software # or: ZPFX=$HOME/.local, etc.\n```\n\nWe encourage people to install compiled software with use of `$ZPFX` and `configure''` and `make''` ices, to have a\nnice, clean user-home dir based setup.\n\n### Customizing Paths<a name=\"customizing-paths\"></a>\n\nFollowing variables can be set to custom values, before sourcing Zinit. The previous global variables like `$ZPLG_HOME`\nhave been removed to not pollute the namespace – there's single `$ZINIT` hash instead of `8` string variables. Please\nupdate your dotfiles.\n\n```zsh\ndeclare -A ZINIT  # initial Zinit's hash definition, if configuring before loading Zinit, and then:\n```\n\n| Hash Field                          | Description                                                                                                                                                                                                                                                                                                                                                                                              |\n| ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ZINIT\\[BIN_DIR\\]                    | Where Zinit code resides, e.g.: \"~/.local/share/zinit/zinit.git\"                                                                                                                                                                                                                                                                                                                                         |\n| ZINIT\\[HOME_DIR\\]                   | Where Zinit should create all working directories, e.g.: \"~/.local/share/zinit\"                                                                                                                                                                                                                                                                                                                          |\n| ZINIT\\[MAN_DIR\\]                    | Directory where plugins can store their manpages (`atclone\"cp -vf myplugin.1 $ZINIT[MAN_DIR]/man1\"`). If overridden, this directory will not necessarily be used by `man` (See #8). Default: `$ZPFX/man`                                                                                                                                                                                                 |\n| ZINIT\\[PLUGINS_DIR\\]                | Override single working directory – for plugins, e.g. \"/opt/zsh/zinit/plugins\"                                                                                                                                                                                                                                                                                                                           |\n| ZINIT\\[COMPLETIONS_DIR\\]            | As above, but for completion files, e.g. \"/opt/zsh/zinit/root_completions\"                                                                                                                                                                                                                                                                                                                               |\n| ZINIT\\[SNIPPETS_DIR\\]               | As above, but for snippets                                                                                                                                                                                                                                                                                                                                                                               |\n| ZINIT\\[LIST_COMMAND\\]               | Command to use for displaying a directory tree (e.g., `ls --tree`, `tree`, etc.)                                                                                                                                                                                                                                                                                                                         |\n| ZINIT\\[ZCOMPDUMP_PATH\\]             | Path to `.zcompdump` file, with the file included (i.e. its name can be different)                                                                                                                                                                                                                                                                                                                       |\n| ZINIT\\[COMPINIT_OPTS\\]              | Options for `compinit` call (i.e. done by `zicompinit`), use to pass -C to speed up loading                                                                                                                                                                                                                                                                                                              |\n| ZINIT\\[MUTE_WARNINGS\\]              | If set to `1`, then mutes some of the Zinit warnings, specifically the `plugin already registered` warning                                                                                                                                                                                                                                                                                               |\n| ZINIT\\[OPTIMIZE_OUT_DISK_ACCESSES\\] | If set to `1`, then Zinit will skip checking if a Turbo-loaded object exists on the disk. By default Zinit skips Turbo for non-existing objects (plugins or snippets) to install them before the first prompt – without any delays, during the normal processing of `zshrc`. This option can give a performance gain of about 10 ms out of 150 ms (i.e.: Zsh will start up in 140 ms instead of 150 ms). |\n| ZINIT\\[NO_ALIASES\\]                 | If set to `1`, then Zinit will not set aliases such as `zi` or `zini`                                                                                                                                                                                                                                                                                                                                    |\n\nThere is also `$ZPFX`, set by default to `~/.local/share/zinit/polaris` – a directory where software with `Makefile`,\netc. can be pointed to, by e.g. `atclone'./configure --prefix=$ZPFX'`.\n\n### Non-GitHub (Local) Plugins<a name=\"non-github-local-plugins\"></a>\n\nUse `create` subcommand with user name `_local` (the default) to create plugin's skeleton in `$ZINIT[PLUGINS_DIR]`. It\nwill be not connected with GitHub repository (because of user name being `_local`). To enter the plugin's directory use\n`cd` command with just plugin's name (without `_local`, it's optional).\n\nIf user name will not be `_local`, then Zinit will create repository also on GitHub and setup correct repository origin.\n\n### Extending Git<a name=\"extending-git\"></a>\n\nThere are several projects that provide git extensions. Installing them with Zinit has many benefits:\n\n- all files are under `$HOME` – no administrator rights needed,\n- declarative setup (like Chef or Puppet) – copying `.zshrc` to different account brings also git-related setup,\n- easy update by e.g. `zinit update --all`.\n\nBelow is a configuration that adds multiple git extensions, loaded in Turbo mode, 1 second after prompt, with use of the\n[Bin-Gem-Node](https://github.com/zdharma-continuum/zinit-annex-bin-gem-node) annex:\n\n```zsh\nzi as'null' lucid sbin wait'1' for \\\n  Fakerr/git-recall \\\n  davidosomething/git-my \\\n  iwata/git-now \\\n  paulirish/git-open \\\n  paulirish/git-recent \\\n    atload'export _MENU_THEME=legacy' \\\n  arzzen/git-quick-stats \\\n    make'install' \\\n  tj/git-extras \\\n    make'GITURL_NO_CGITURL=1' \\\n    sbin'git-url;git-guclone' \\\n  zdharma-continuum/git-url\n```\n\nTarget directory for installed files is `$ZPFX` (`~/.local/share/zinit/polaris` by default).\n\n## Changelog<a name=\"changelog\"></a>\n\nLink to the [CHANGELOG](doc/CHANGELOG.md).\n\n## Support<a name=\"support\"></a>\n\nZinit is a personal, free-time project with no funding and a huge\n[feature request backlog](https://github.com/zdharma-continuum/zinit/issues). If you love it, consider supporting its\ndevelopment via GitHub Sponsors \\[pending\\]. Any help counts!\n\n## Getting Help and Community<a name=\"getting-help-and-community\"></a>\n\nDo you need help or wish to get in touch with other Zinit users?\n\n- [Open a discussion](https://github.com/zdharma-continuum/zinit/discussions).\n\n- Or via reach out via Gitter\n  [![Join the chat at https://gitter.im/zdharma-continuum/community][gitter-badge]][gitter-link]\n\n[gitter-badge]: https://badges.gitter.im/zdharma-continuum/zinit.svg\n[gitter-link]: https://gitter.im/zdharma-continuum/community?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n[mit-badge]: https://img.shields.io/badge/license-MIT-blue.svg\n[mit-link]: ./LICENSE\n[tests-badge]: https://github.com/zdharma-continuum/zinit/actions/workflows/tests.yaml/badge.svg\n[tests-link]: https://github.com/zdharma-continuum/zinit/actions/workflows/tests.yaml\n[ver-badge]: https://img.shields.io/github/tag/zdharma-continuum/zinit.svg\n[ver-link]: https://github.com/zdharma-continuum/zinit/releases\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.0068359375,
          "content": "3.13.1\n"
        },
        {
          "name": "_zinit",
          "type": "blob",
          "size": 11.86328125,
          "content": "#compdef zinit\n#autoload\n#\n# Zinit ZSH completion function\n# Copyright (c) 2016-2020 Sebastian Gniazdowski\n# Copyright (c) 2016-2023 zdharma-continuum\n# Homepage: https://github.com/zdharma-continuum/zinit\n# License: MIT License\n#\n\n# FUNCTION: __zinit_commands [[[\n__zinit_commands(){\n  local -a commands\n  commands=(\n    'add-fpath:Add plugin folder to $FPATH'\n    'bindkeys:List of plugin defined key bindings'\n    'cclear:Clear completions list'\n    'cd:Go to a plugin or snippet direcorty'\n    'cdclear:Clear the compdef replay list'\n    'cdisable:Disable completions'\n    'cdreplay:Replay compdef list'\n    'cenable:Enable completions'\n    'changes:View plugins git log'\n    'compile:Compile plugin (or all plugins if --all passed)'\n    'compiled:List of compiled plugins'\n    'compinit:Refresh installed completions'\n    'completions:List status of all installed completions'\n    'create:Generate Zsh plugin boilerplate'\n    'creinstall:Install completions for plugin'\n    'csearch:Search for available completions from any plugin'\n    'cuninstall:Uninstall completions for plugin'\n    'debug:Functions for debugging Zinit'\n    'delete:Uninstall a plugin or snippet'\n    'edit:Edit a plugins or snippet with \\$EDITOR'\n    'env-whitelist:Specify names (also patterns) of parameters to be left unchanged during an unload'\n    'glance:Look at plugins source'\n    'help:Usage information'\n    'load:Load plugin'\n    'man:Display Zinit'\\''s manpage'\n    'module:Manage binary Zsh module shipped with Zinit'\n    'plugins:List status of all installed plugins'\n    'recall:Fetch saved ice modifiers and construct '\n    'recently:Show plugins that changed recently'\n    'report:Show plugins report'\n    'run:Run a command inside plugins folder'\n    'self-update:Fetch the newest version of Zinit from GitHub using `git`(1) and recompile'\n    'snippet:Source a local or remote file'\n    'snippets:List status of all installed snippets'\n    'srv:Control a service, command'\n    'status:Git status for plugin'\n    'stress:Test plugin for compatibility with set of options'\n    'times:Display brief statistics for your Zinit installation'\n    'uncompile:Remove compiled plugin'\n    'uninstall:Uninstall a formula or cask'\n    'unload:Unload a plugin or snippet'\n    'update:Upgrade outdated plugins and snippets using the same options they were originally installed with'\n    'version:Print the version numbers of Zinit to standard output'\n    'zstatus:Overall Zinit status'\n  )\n  _describe -t commands 'zinit commands' commands\n} # ]]]\n###\n# Commands in the debug context\n###\n_zinit_debug_commands=(\n  'clear:Clear report of debug tracing session'\n  'report:Show report of debug tracing session'\n  'revert:Revert changes detected during debug tracing session'\n  'start:Start debug tracing session'\n  'status:Show current state of debug mode'\n  'stop:Stop debug tracing session'\n)\n# FUNCTION: __zinit_completion_caching_policy [[[\n__zinit_completion_caching_policy(){\n  local -a tmp\n  (( $#tmp )) || return 0\n  tmp=( $ZINIT[BIN_DIR]/*.git/index(om[1]N) )\n  [[ -z $tmp || $tmp -nt $1 ]]\n} # ]]]\n# FUNCTION: __zinit_installed [[[\n__zinit_installed() {\n  _alternative \\\n    'plugins:installed:__zinit_installed_plugins' \\\n    'snippets:installed:__zinit_installed_snippets'\n} # ]]]\n# FUNCTION: __zinit_installed_plugins [[[\n__zinit_installed_plugins(){\n  # [[ -prefix '-' ]] && return 0\n  typeset -a list\n  local expl\n  list=( \"${ZINIT[PLUGINS_DIR]}\"/*(N:t) )\n  list=( \"${list[@]//---//}\" )\n  list=( \"${list[@]:#_local/zinit}\" )\n  list=( \"${list[@]:#custom}\" )\n  _wanted list expl 'plugins' compadd -a - list\n} # ]]]\n# FUNCTION: __zinit_installed_snippets [[[\n__zinit_installed_snippets(){\n  # [[ -prefix '-' ]] && return 0\n  typeset -a snippets\n  local expl snippet\n  snippets=( \"${ZINIT[SNIPPETS_DIR]}\"/**/._zinit(D/:h) )\n  snippets=( ${(Q)snippets[@]#${ZINIT[SNIPPETS_DIR]}/} )\n  # formulae=( ${(qq)formulae[@]/(#b)(http|https|ftp|ftps|scp)--/${match[1]}://} )\n  # formulae=( ${formulae[@]/--//} )\n  #\n  _wanted snippets expl 'snippets' compadd -a - snippets\n} # ]]]\n# FUNCTION: __zinit_list_aliases [[[\n__zinit_list_aliases(){\n  local -a aliases\n  aliases=( ls list uninstall delete )\n  builtin print -- \"$aliases\"\n} # ]]]\n\n# FUNCTION: _zinit_add_fpath [[[\n_zinit_add_fpath(){\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]' && ret=0\n} # ]]]\n# FUNCTION: _zinit_bindkeys [[[\n_zinit_bindkeys(){\n  _message 'Hit enter to list the defined key bindings replay' && ret=0\n} # ]]]\n# FUNCTION: _zinit_cclear [[[\n_zinit_cclear(){\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-q --quiet)'{-q,--quiet}'[Turn off messages from the operation]' \\\n    && ret=0\n} # ]]]\n# FUNCTION: _zinit_cd [[[\n_zinit_cd(){\n  _arguments - plugin '1::plugin:__zinit_installed_plugins' && ret=0\n} # ]]]\n# FUNCTION: _zinit_cdclear [[[\n_zinit_cdclear(){\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-q --quiet)'{-q,--quiet}'[Turn off messages from the operation]' \\\n    && ret=0\n} # ]]]\n# FUNCTION: _zinit_cdisable [[[\n_zinit_cdisable(){\n  _message 'Press enter to disable completions' && ret=0\n} # ]]]\n# FUNCTION: _zinit_cdlist [[[\n_zinit_cdlist(){\n  _message 'List of compdef replays' && ret=0\n} # ]]]\n# FUNCTION: _zinit_cdreplay [[[\n_zinit_cdreplay(){\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-q --quiet)'{-q,--quiet}'[Turn off messages from the operation]' \\\n    && ret=0\n} # ]]]\n# FUNCTION: _zinit_cenable [[[\n_zinit_cenable(){\n  _message 'Hit enter to enable completions' && ret=0\n} # ]]]\n# FUNCTION: _zinit_changes [[[\n_zinit_changes(){\n  _message 'View git log of a plugin' && ret=0\n} # ]]]\n# FUNCTION: _zinit_compiled [[[\n_zinit_compiled(){\n  _message 'Hit enter to get list of compiled plugins and snippets'\n} # ]]]\n# FUNCTION: _zinit_compinit [[[\n_zinit_compinit(){\n  _message \"Refresh completions\" && ret=0\n} # ]]]\n# FUNCTION: _zinit_completions [[[\n_zinit_completions(){\n  _message \"Display a list of completions\" && ret=0\n} # ]]]\n# FUNCTION: _zinit_create [[[\n_zinit_compile(){\n  _arguments \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-q --quiet)'{-q,--quiet}'[Make some output more quiet]' \\\n    + '(operation)' \\\n      '(-a --all)'{-a,--all}'[Compile all plugins]' \\\n      '*::installed:__zinit_installed' \\\n    && ret=0\n} # ]]]\n# FUNCTION: _zinit_create [[[\n_zinit_create(){\n  _arguments \\\n    '1:Plugin Name' && ret=0\n} # ]]]\n# FUNCTION: _zinit_creinstall [[[\n_zinit_creinstall(){\n  _arguments - plugin '1::plugin:__zinit_installed_plugins' && ret=0\n} # ]]]\n# FUNCTION: _zinit_csearch [[[\n_zinit_csearch(){\n  ret=0\n} # ]]]\n# FUNCTION: _zinit_cunistall [[[\n_zinit_cunistall(){\n  _arguments - installed '*::installed:__zinit_installed' && ret=0\n} # ]]]\n# FUNCTION: _zinit_delete [[[\n_zinit_delete(){\n  _arguments \\\n    {-d,--debug}'[Enable xtrace]' \\\n    {-h,--help}'[Show this help message]' \\\n    {-q,--quiet}'[Make some output more quiet]' \\\n    {-y,--yes}'[Automatically confirm any yes/no prompts]' \\\n    + '(operation)' \\\n      '*::installed:__zinit_installed' \\\n      {-a,--all}'[Delete all plugins and snippets]' \\\n      {-c,--clean}'[Delete only the currently-not loaded plugins and snippets]' \\\n    && ret=0\n} # ]]]\n_zinit_debug(){\n  _arguments \\\n    '1: :_zinit_debug_cmds'\n} # ]]]\n# FUNCTION: _zinit_edit [[[\n_zinit_edit(){\n  _arguments \\\n    - installed '*::plugin:__zinit_installed_plugins' \\\n    - snippet '*::snippet:__zinit_installed_snippets' && ret=0\n} # ]]]\n# FUNCTION: _zinit_env_whitelist [[[\n_zinit_env_whitelist(){\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-v --verbose)'{-v,--verbose}'[Make some output more verbose]' \\\n    && ret=0\n} # ]]]\n# FUNCTION: _zinit_glance [[[\n_zinit_glance(){\n  _arguments - installed '1:installed:__zinit_installed' && ret=0\n} # ]]]\n# FUNCTION: _zinit_list [[[\n_zinit_list(){\n  _message 'Hit enter to list the defined key bindings replay' && ret=0\n} # ]]]\n# FUNCTION: _zinit_loaded [[[\n_zinit_loaded(){\n  _message 'Hit enter to list the defined key bindings replay' && ret=0\n} # ]]]\n# FUNCTION: _zinit_man [[[\n_zinit_man(){\n  _message \"Hit enter to view the Zinit man page\" && ret=0\n} # ]]]\n# FUNCTION: _zinit_module [[[\n_zinit_module(){\n  _arguments \\\n    - subcommand '*::subcommand:(build help info)' && ret=0\n} # ]]]\n# FUNCTION: _zinit_recall [[[\n_zinit_recall(){\n  _message 'Hit enter to list the defined key bindings replay' && ret=0\n} # ]]]\n# FUNCTION: _zinit_recently [[[\n_zinit_recently(){\n  ret=0\n} # ]]]\n# FUNCTION: _zinit_report [[[\n_zinit_report(){\n  _message 'Hit enter to list the defined key bindings replay' && ret=0\n} # ]]]\n# FUNCTION: _zinit_run [[[\n_zinit_run(){\n  _arguments \\\n    - installed '1:installed:__zinit_installed' \\\n    '2:command to run:' && ret=0\n} # ]]]\n# FUNCTION: _zinit_self_update [[[\n_zinit_self_update(){\n} # ]]]\n# FUNCTION: _zinit_snippet [[[\n_zinit_snippet(){\n  _arguments -A \\\n    '(-c --command)'{-c,--command}'[Load the snippet as a command (i.e., make executable and apend to $PATH])' \\\n    '(-f --force)'{-f,--force}'[Force new download of the snippet file]' \\\n    '(-h --help)'{-h,--help}'[Show this help message]'\n  _arguments - snippet '*::snippet:__zinit_installed_snippets' && ret=0\n} # ]]]\n# FUNCTION: _zinit_status [[[\n_zinit_status(){\n  _message 'Display current status of Zinit' && ret=0\n} # ]]]\n# FUNCTION: _zinit_stress [[[\n_zinit_stress(){\n  _message 'Stress' && ret=0\n} # ]]]\n# FUNCTION: _zinit_times [[[\n_zinit_times(){\n  _arguments \\\n    '--help[Show this help message]' \\\n    + '(operation)' \\\n      '(-a --all)'{-a,--all}'[show both load times and loading moments]' \\\n      '(-m --moments)'{-m,--moments}'[Display loading moments]' \\\n      '(-s --seconds)'{-s,--seconds}'[Load times displayed in seconds]' \\\n  && ret=0\n} # ]]]\n# FUNCTION: _zinit_uncompile [[[\n_zinit_uncompile(){\n  _arguments \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-q --quiet)'{-q,--quiet}'[Make some output more quiet]' \\\n    + '(operation)' \\\n      '(-a --all)'{-a,--all}'[Uncompile all plugins]' \\\n      '*::installed:__zinit_installed' \\\n    && ret=0\n} # ]]]\n# FUNCTION: _zinit_unload [[[\n_zinit_unload(){\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]' \\\n    '(-q --quiet)'{-q,--quiet}'[Turn off messages from the operation]' \\\n    - installed '*:installed:__zinit_installed'\n} # ]]]\n# FUNCTION: _zinit_update [[[\n_zinit_update(){\n  _arguments \\\n    '--help[Show this help message]' \\\n    '--no-pager[Don'\\''t automatically install dependencies]' \\\n    '--quiet[Turn off messages from the operation]' \\\n    '--reset[Reset repository or delete downloadremove single-file snippets and gh-r plugins)]' \\\n    '--urge[Cause all the hooks like: atpull'', cp'', etc. to execute even when there aren'\\''t any new commits / any new version of the gh-r file / etc.… available for download↔ simulate a non-empty update]' \\\n  - set1 \\\n      '--parallel[Turn on concurrent, multi-thread update (of all objects)]' \\\n      '(-a --all)'{-a,--all}'[Update all plugins and snippets]' \\\n  - set2 \\\n      '1:installed:__zinit_installed'\n} # ]]]\n# FUNCTION: _zunit_load [[[\n_zinit_load() {\n  _message 'Hit enter to list the defined key bindings replay' && ret=0\n} # ]]]\n\n# FUNCTION: _zinit [[[\n_zinit(){\n  local curcontext=\"$curcontext\" state state_descr line expl\n  local tmp ret=1\n  _arguments -A \\\n    '(-h --help)'{-h,--help}'[Show this help message]'\n  _arguments -C \\\n    \"1: :->cmds\" \\\n    \"*::arg:->args\"\n  case \"$state\" in\n    cmds)\n      __zinit_commands && return 0\n      ;;\n    args)\n      local cmd=\"${line[1]}\"\n      curcontext=\"${curcontext%:*}-${cmd}:${curcontext##*:}\"\n      local completion_func=\"_zinit_${cmd//-/_}\"\n      _call_function ret \"${completion_func}\" && return ret\n      _message \"a completion function is not defined for command or alias: ${cmd}\"\n      return 1\n      ;;\n  esac\n} # ]]]\n\n(( $+functions[_zinit_debug_cmds] )) || _zinit_debug_cmds() {\n  _describe -t commands 'commands' _zinit_debug_commands \"$@\"\n}\n\n_zinit \"$@\"\n\n#vim: filetype=zsh foldmarker=[[[,]]] foldmethod=marker shiftwidth=2 softtabstop=2 tabstop=2:\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "share",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "zi-browse-symbol",
          "type": "blob",
          "size": 20.57421875,
          "content": "#!/bin/zsh\n# This is a Zle widget file. In general, it is s used as (without setup\n# provided by the plugin):\n#\n# autoload browse-symbol\n# zle -N browse-symbol\n# zle -N browse-symbol-backwards browse-symbol\n# zle -N browse-symbol-pbackwards browse-symbol\n# zle -N browse-symbol-pforwards browse-symbol\n# bindkey \"^T\" browse-symbol\n#\n# This will bind to Ctrl-T. The plugin binds to Ctrl-O Ctrl-K.\n#\n# Example zstyles:\n# zstyle \":plugin:zinit:symbol-search\" page-size 5\n# zstyle \":plugin:zinit:symbol-search\" highlight-color \"fg=magenta,bold\"\n# zstyle \":plugin:zinit:symbol-search\" heading-color \"fg=18,bold\"\n# zstyle \":plugin:zinit:symbol-search\" title-color \"fg=180,bold\"\n# zstyle \":plugin:zinit:symbol-search\" arrow-color \"fg=180,bg=39,bold\"\n# zstyle \":plugin:zinit:symbol-search\" func-color \"fg=208,bold\"\n# zstyle \":plugin:zinit:symbol-search\" var-color \"fg=174,bg=39,bold\"\n# zstyle \":plugin:zinit:symbol-search\" macro-color \"fg=39,bold\"\n# zstyle \":plugin:zinit:symbol-search\" eqdol-color \"fg=183,bg=39,bold\"\n\nemulate -L zsh\nsetopt typesetsilent extendedglob noshortloops localtraps warncreateglobal\n\n# When an error, then no cursor keys bindings\nzmodload zsh/terminfo 2>/dev/null\nzmodload zsh/termcap 2>/dev/null\n\ntypeset -gA TAG\ninteger -g __tfind_spe_index\ninteger -g __tfind_spe_restart __tfind_spe_call_count __tfind_spe_funct __tfind_spe_sort\ntypeset -g __tfind_page_size __tfind_high_color __tfind_heading_color \\\n\t__tfind_title_color __tfind_arrow_color __tfind_func_color \\\n\t__tfind_var_color __tfind_eqdol_color __tfind_macro_color\ntypeset -gaU __tfind_spe_found\ntypeset -ga __tfind_tag_data\ntypeset -g __tfind_git_or_project __tfind_outside_git\nlocal mbegin mend match\nlocal MATCH\ninteger MBEGIN MEND\n\n(( __tfind_spe_call_count ++ ))\ntrap '(( __tfind_spe_call_count -- )); return 0;' INT\n\n_tfind_find_index() {\n    local q\n    local -a p\n    # Read tags file\n    p=( (../)#TAGS(N) )\n    TAG[file]=${${(On)p}[1]}\n    [[ -f ./TAGS ]] && TAG[file]=$PWD/TAGS\n    if [[ -n $TAG[file] ]]; then\n        TAG[git-or-project]=${${TAG[file]:a}:h:t}\n    else\n        TAG[git-or-project]=\"<unknown>\"\n        #TAG[file]=\n    fi\n\n    # Pre-process found index\n    TAG[file-pp]=${TAG[file]/TAGS/.TAGS}.z\n    if [[ -n $TAG[file] && -f $TAG[file] && ( ! -f $TAG[file-pp] || $TAG[file] -nt $TAG[file-pp]) ]]\n    then\n        local sed_\n        (( $+commands[sed] )) && sed_=sed\n        (( $+commands[gsed] )) && sed_=gsed\n        # Generate simplified file – append the filename at each line,\n        # so that it's not only at the preamble line\n        command $sed_ -r -n $'/^\\x0c$/ { n; s/,[^,]*$//;s/^/\\x02/; h; d;}; G; y/\\\\n/,/; p' $TAG[file] >! $TAG[file-pp]\n    fi\n\n    # Read index, and as index is found, establish git main dir for it\n    __tfind_outside_git=$TAG[file]:h\n    if [[ -n $TAG[file] && -f $TAG[file-pp] ]]; then\n        __tfind_tag_data=( ${\"${(@f)\"$(<${TAG[file-pp]})\"}\"##[[:space:]]##} )\n        # Cleanup functions and their preambles\n        __tfind_tag_data=( ${__tfind_tag_data[@]/(#b)(\\([^\\)]#\\))[[:space:]]#[\\{]*($'\\x7f')/$match[1]$match[2]} )\n        __tfind_tag_data=( ${__tfind_tag_data[@]/(#b)[[:space:]]\\#*($'\\x7f')/$match[1]} )\n        __tfind_outside_git=\"${PWD%/${$(git rev-parse --quiet --show-prefix 2>/dev/null)%/}}\"\n        if [[ -d $__tfind_outside_git && -n ${${(M)PWD##$__tfind_outside_git}##$HOME} ]]; then\n            TAG[git-or-project]=$__tfind_outside_git:t\n            TAG[repo-dir]=$__tfind_outside_git\n        else\n            TAG[git-or-project]=$TAG[file]:h\n            TAG[repo-dir]=$TAG[file]:h\n        fi\n        return 0\n    fi\n    return 1\n}\n\n_tfind_error_msg()\n{\n    integer buflen=$#BUFFER\n    if [[ -z $TAG[repo-dir] || $TAG[repo-dir] == . ]]; then\n        POSTDISPLAY=$'\\n'\"Symbol index NOT found, NO DATA to show, sleeping…\"\n        local search_buffer=\n    elif [[ $#__tfind_tag_data -eq 0 ]]; then\n        POSTDISPLAY=$'\\n'\"The index file contains NO symbol data, forced sleeping...\"\n        local search_buffer=\n    elif [[ $#__tfind_spe_found -eq 0 && $search_buffer == [[:space:]]# ]]; then\n        POSTDISPLAY=$'\\n'\"No items found\"\n    elif [[ $search_buffer != [[:space:]]# && $#__tfind_spe_found -eq 0 ]]; then\n        POSTDISPLAY=$'\\n'\"Found 0 matches for query: $search_buffer\"\n    else\n        return 1\n    fi\n    region_highlight+=(\"$buflen $(( $buflen+$#POSTDISPLAY-$#search_buffer )) fg=179,bold\")\n    region_highlight+=(\"$(( $buflen+$#POSTDISPLAY-$#search_buffer ))  $(( $buflen+$#POSTDISPLAY )) fg=39,bold\")\n    # Number?\n    [[ -n ${#${(MS)POSTDISPLAY##<->##}} ]] && \\\n        region_highlight+=(\"$((buflen+7)) $((buflen+7+${#${(MS)POSTDISPLAY##<->##}})) fg=39,bold\")\n    return 0\n\n}\n_tfind_main() {\n    local match mbegin mend\n    local MATCH\n    integer MBEGIN MEND buflen=${#BUFFER}\n    TAG[fun-xt-chars]='+.:@\\/→↓←↑\\$,_\\--'\n    # First call or restart?\n    if [[ $__tfind_spe_call_count -le 1 || $__tfind_spe_restart = 1 ]]; then\n        if [[ $__tfind_spe_call_count -le 1 ]]; then\n            # Read configuration data\n            zstyle -s \":plugin:zinit:symbol-search\" page-size __tfind_page_size || __tfind_page_size=$(( LINES / 3 ))\n            zstyle -s \":plugin:zinit:symbol-search\" highlight-color __tfind_high_color || __tfind_high_color=\"fg=39,bold\"\n            zstyle -s \":plugin:zinit:symbol-search\" heading-color __tfind_heading_color || __tfind_heading_color=\"fg=69,bold\"\n            zstyle -s \":plugin:zinit:symbol-search\" title-color __tfind_title_color || __tfind_title_color=\"fg=208,bold\"\n            zstyle -s \":plugin:zinit:symbol-search\" arrow-color __tfind_arrow_color || __tfind_arrow_color=\"fg=227,bg=69,bold\"\n            zstyle -s \":plugin:zini t:symbol-search\" var-color __tfind_var_color || __tfind_var_color=\"fg=127,bold\"\n            zstyle -s \":plugin:zinit:symbol-search\" func-color __tfind_func_color || __tfind_func_color=\"fg=70,bold\"\n            zstyle -s \":plugin:zinit:symbol-search\" macro-color __tfind_macro_color || __tfind_macro_color=\"fg=208,bold\"\n            zstyle -s \":plugin:zinit:symbol-search\" eqdol-color __tfind_eqdol_color || __tfind_eqdol_color=\"fg=69,bold\"\n\n        # Find the index to operate on, git dir, etc.\n        _tfind_find_index || { _tfind_error_msg && return;}\n       fi\n\n        # '0' will get changed into $to_display limit\n        [[ $WIDGET = *-symbol || $WIDGET = *-pforwards ]] && __tfind_spe_index=1\n        [[ $WIDGET = *-backwards || $WIDGET = *-pbackwards ]] && __tfind_spe_index=0\n        __tfind_spe_found=()\n        __tfind_spe_restart=0\n    else\n        # Consecutive call\n        [[ $WIDGET = *-symbol ]] && (( __tfind_spe_index ++ ))\n        [[ $WIDGET = *-backwards ]] && (( __tfind_spe_index -- ))\n        [[ $WIDGET = *-pforwards ]] && (( __tfind_spe_index = __tfind_spe_index + __tfind_page_size ))\n        [[ $WIDGET = *-pbackwards ]] && (( __tfind_spe_index = __tfind_spe_index - __tfind_page_size ))\n    fi\n\n    # Find history entries matching pattern *word1*~^*word2*~^*word3* etc.\n    local search_buffer=\"${BUFFER%% ##}\" search_pattern=\"\" csearch_pattern=\"\"\n    search_buffer=\"${${search_buffer## ##}%% ##}\"\n    search_buffer=\"${search_buffer//(#m)[][*?|#~^()><\\\\]/\\\\$MATCH}\"\n    search_pattern=\"*${search_buffer// ##/*~^*}*\"\n    csearch_pattern=\"${search_buffer// ##/|}\"\n\n    if [[ $#__tfind_spe_found -eq 0 ]]; then\n        # The repeat will make the matching work on a fresh heap arena\n        repeat 1; do\n            # Match only before ^? ($'\\177')\n            __tfind_spe_found=( \"${(@M)__tfind_tag_data:#(#i)$~search_pattern*$'\\177'*}\" )\n            ((__tfind_spe_funct)) &&  __tfind_spe_found=(${(M)__tfind_spe_found:#[[:alnum:]$TAG[fun-xt-chars]]##[[:space:]]#\\([^\\)]#\\)[[:space:]]#(\\{|)*})\n            ((__tfind_spe_sort)) &&  __tfind_spe_found=(${(no)__tfind_spe_found})\n        done\n    fi\n\n    if ((!$#__tfind_spe_found)); then\n        _tfind_error_msg && return\n    fi\n\n    #\n    # Pagination, index value guards\n    #\n\n    integer page_size=$__tfind_page_size\n    integer max_index=\"$#__tfind_spe_found\"\n    [[ $page_size -gt $max_index ]] && page_size=$max_index\n    [[ $__tfind_spe_index -le 0 ]] && __tfind_spe_index=$max_index\n    [[ $__tfind_spe_index -gt $max_index ]] && __tfind_spe_index=1\n    integer page_start_idx=$(( ((__tfind_spe_index-1)/page_size)*page_size+1 ))\n    integer on_page_idx=$(( (__tfind_spe_index-1) % page_size + 1 ))\n\n    #\n    # Prepare display\n    #\n\n    typeset -a disp_list\n    disp_list=( \"${(@)__tfind_spe_found[page_start_idx,page_start_idx+page_size-1]}\" )\n\n    # Remove meta-data from the entries\n    disp_list=( \"${(@)disp_list//$'\\177'*/}\" )\n\n    # All entries should have multilines replaced\n    disp_list=( \"${(@)disp_list//$'\\n'/\\\\n}\" )\n    # ... and truncated to display width, and\n    # also preceeded by two spaces\n    disp_list=( \"${(@)disp_list/(#m)*/  ${MATCH[1,COLUMNS-8]}}\" )\n\n    local p=$'\\n'\n    local entry=$disp_list[on_page_idx]\n    entry[1]='»'\n    disp_list[on_page_idx]=$entry\n\n    #\n    # Detect where \"> ..\" entry starts\n    #\n\n    local txt_before=\"${(F)${(@)disp_list[1,on_page_idx-1]}}\"\n\n    #\n    # Colorify\n    #\n    local noun=${${${__tfind_spe_funct:#0}:+function}:-symbol}\n    local preamble=$'\\n'\"View of ${noun}s for repo: «««${(U)TAG[git-or-project]}»»» located at: $TAG[repo-dir]:h\"$'\\n'\"${(C)noun} no. #$__tfind_spe_index. Found $max_index ${noun}s in the index.\"$'\\n' \\\n    key=\"Ctrl-f to toggle functions-ONLY view. Alt-s to toggle sort.\"$'\\n'\n    preamble+=$key\n\n    local text=\"${(F)disp_list}\"\n    integer offset=${#preamble}+$buflen\n\n    POSTDISPLAY=\"$preamble$text\"\n\n    region_highlight=( \"$(( offset + ${#txt_before} )) $(( offset + ${#txt_before} + ${#entry} + 1 )) underline\" )\n\n    color_att() { local c;if (($4==0)){c=$__tfind_title_color;} elif (($4==1)){c=$__tfind_high_color;} elif (($4==4)){c=$__tfind_var_color;} elif (($4==7)){c=$__tfind_func_color;} elif (($4==9)){c=$__tfind_eqdol_color;} elif (($4==10)){c=$__tfind_macro_color;} else {c=$__tfind_arrow_color;}; region_highlight_+=(\"$(($1+$2-1)) $(($1+$3)) $c\"); }\n    functions -M coloratt 4 4 color_att\n    local -a region_highlight_\n    # Also highlight project name\n    local h=\"$(( 30+buflen+__tfind_spe_funct*2 )) $(( 30+$buflen+${#TAG[git-or-project]}+__tfind_spe_funct*2 )) $__tfind_title_color\"\n    local q=\"$buflen $offset $__tfind_heading_color\"\n    region_highlight+=( $q $h )\n    : \"${preamble//(#b)no. ([^.]##)./$((coloratt(buflen,mbegin[1],mend[1],0)))}\"\n    : \"${preamble//(#b)Found ([0-9]##)/$((coloratt(buflen,mbegin[1],mend[1],1)))}\"\n    : \"${preamble//(#b)» located at: ([^$p]##)/$((coloratt(buflen,mbegin[1],mend[1],1)))}\"\n    : \"${preamble//(#b)(Ctrl-f)/$((coloratt(buflen,mbegin[1],mend[1],0)))}\"\n    : \"${preamble//(#b)(Alt-s)/$((coloratt(buflen,mbegin[1],mend[1],0)))}\"\n    : \"${text//((#s)|$p)(#b)(»)/$((coloratt(offset,mbegin[1],mend[1],3)))}\"\n    # Basic syntax highlighting - a few keywords like C/Java type names\n    : \"${text//(#b)((([[:space:]\\(\\{\\[]int|double|enum|short|long|(u|w|g|gu)(int|char|long|short)(8|16|32|64|128|max|)(_t|)|char|(|un)signed|FILE|const|restrict|size_t|va_list|ptrdiff_t|off_t|gboolean|gpointer|gconstpointer|typedef|static|struct|union)[[:space:]])|[a-zA-Z_]##_t|local|integer|float|declare|typeset|readonly)/$((coloratt(offset,mbegin[1],mend[1],4)))}\"\n    : \"${text//(#b)(=)/$((coloratt(offset,mbegin[1],mend[1],9)))}\"\n    : \"${text//(#b)(\\#[[:space:]]#(include|define|if|endif))/$((coloratt(offset,mbegin[1],mend[1],10)))}\"\n    : \"${text//(#b)(\\$<->#)/$((coloratt(offset,mbegin[1],mend[1],9)))}\"\n    : \"${text//(#b)([[:alnum:]$TAG[fun-xt-chars]]##)[[:space:]]#\\([^\\)]#\\)/$((coloratt(offset,mbegin[1],mend[1],7)))}\"\n    : \"${text//(#b)\\#[[:space:]]#(include|define)[[:space:]]##([[:alnum:]_]##)[^[:alnum:]_]/$((coloratt(offset,mbegin[2],mend[2],7)))}\"\n    if [[ -n $search_pattern ]]; then\n        : \"${(f)${(S)text//*(#bi)(${~csearch_pattern})/$((coloratt(offset,mbegin[1],mend[1],1)))}}\"\n    fi\n\n    functions +M color_att\n    unfunction color_att\n    region_highlight+=( $region_highlight_ )\n}\n\n\n_tfind_functions() {\n    __tfind_spe_funct=1-__tfind_spe_funct\n    __tfind_spe_restart=1\n    _tfind_simulate_widget\n}\n_tfind_sort() {\n    __tfind_spe_sort=1-__tfind_spe_sort\n    __tfind_spe_restart=1\n    _tfind_simulate_widget\n}\n_tfind_simulate_widget() {\n    (( __tfind_spe_call_count ++ ))\n    _tfind_main\n}\n\n_tfind_self_insert() {\n    [[ $#KEYS ]] && __tfind_spe_restart=1\n    LBUFFER+=\"${KEYS[-1]}\"\n    _tfind_simulate_widget\n}\n\n_tfind_backward_delete_char() {\n    [[ $#LBUFFER ]] && __tfind_spe_restart=1\n    LBUFFER=\"${LBUFFER%?}\"\n    _tfind_simulate_widget\n}\n\n_tfind_delete_char() {\n    [[ $#RBUFFER ]] && __tfind_spe_restart=1\n    RBUFFER=\"${RBUFFER#?}\"\n    _tfind_simulate_widget\n}\n\n_tfind_cancel_accept() {\n    BUFFER=\"\"\n    __tfind_spe_index=-1\n    zle .accept-line\n}\n\n_tfind_main\n\nif [[ $__tfind_spe_call_count -eq 1 ]]; then\n    # Make the tfind keymap a copy of the current main\n    bindkey -N tfind emacs\n\n    local down_widget=\"${${${WIDGET%-backwards}%-pbackwards}-pforwards}\"\n    local up_widget=\"${down_widget}-backwards\"\n    local pdown_widget=\"${down_widget}-pforwards\"\n    local pup_widget=\"${down_widget}-pbackwards\"\n\n    # Manual, termcap, terminfo\n    bindkey -M tfind '^[OA' $up_widget\n    bindkey -M tfind '^[OB' $down_widget\n    bindkey -M tfind '^[[A' $up_widget\n    bindkey -M tfind '^[[B' $down_widget\n    [[ -n \"$termcap[ku]\" ]] && bindkey -M tfind \"$termcap[ku]\" $up_widget\n    [[ -n \"$termcap[kd]\" ]] && bindkey -M tfind \"$termcap[kd]\" $down_widget\n    [[ -n \"$termcap[kD]\" ]] && bindkey -M tfind \"$termcap[kD]\" delete-char\n    [[ -n \"$terminfo[kcuu1]\" ]] && bindkey -M tfind \"$terminfo[kcuu1]\" $up_widget\n    [[ -n \"$terminfo[kcud1]\" ]] && bindkey -M tfind \"$terminfo[kcud1]\" $down_widget\n    [[ -n \"$terminfo[kdch1]\" ]] && bindkey -M tfind \"$terminfo[kdch1]\" delete-char\n\n    # More bindkeys, to remove influence of overloading plugins (sy-h, suggestions)\n    # Left/Right cursor keys\n    bindkey -M tfind '^[[D' .backward-char\n    bindkey -M tfind '^[[C' .forward-char\n    [[ -n \"$termcap[kl]\" ]] && bindkey -M tfind \"$termcap[kl]\" .backward-char\n    [[ -n \"$termcap[kr]\" ]] && bindkey -M tfind \"$termcap[kr]\" .forward-char\n    [[ -n \"$terminfo[kcub1]\" ]] && bindkey -M tfind \"$terminfo[kcub1]\" .backward-char\n    [[ -n \"$terminfo[kcuf1]\" ]] && bindkey -M tfind \"$terminfo[kcuf1]\" .forward-char\n    # Now Home/End keys, first few recorded in my .zshrc during the years sequences\n    bindkey -M tfind \"\\e[1~\" .beginning-of-line\n    bindkey -M tfind \"\\e[7~\" .beginning-of-line\n    bindkey -M tfind \"\\e[H\"  .beginning-of-line\n    bindkey -M tfind \"\\e[4~\" .end-of-line\n    bindkey -M tfind \"\\e[F\"  .end-of-line\n    bindkey -M tfind \"\\e[8~\" .end-of-line\n    [[ -n \"$termcap[kh]\" ]] && bindkey -M tfind \"$termcap[kh]\" .beginning-of-line\n    [[ -n \"$termcap[@7]\" ]] && bindkey -M tfind \"$termcap[@7]\" .end-of-line\n    [[ -n \"$terminfo[khome]\" ]] && bindkey -M tfind \"$terminfo[khome]\" .beginning-of-line\n    [[ -n \"$terminfo[kend]\" ]] && bindkey -M tfind \"$terminfo[kend]\" .end-of-line\n    # The same for Ctrl-E, Ctrl-F\n    bindkey -M tfind '^A' .beginning-of-line\n    bindkey -M tfind '^E' .end-of-line\n    # Additional keys\n    bindkey -M tfind '^[b' .backward-word\n    bindkey -M tfind '^[B' .backward-word\n    bindkey -M tfind '^[f' .forward-word\n    bindkey -M tfind '^[F' .forward-word\n    bindkey -M tfind '^[w' .forward-word\n    bindkey -M tfind '^[W' .forward-word\n\n    # Additional keys\n    bindkey -M tfind '^P' $up_widget\n    bindkey -M tfind '^N' $down_widget\n\n    # Page Up, Page Down keys\n    [[ -n \"$termcap[kP]\" ]] && bindkey -M tfind \"$termcap[kP]\" $pup_widget\n    [[ -n \"$termcap[kN]\" ]] && bindkey -M tfind \"$termcap[kN]\" $pdown_widget\n    [[ -n \"$terminfo[kpp]\" ]] && bindkey -M tfind \"$terminfo[kpp]\" $pup_widget\n    [[ -n \"$terminfo[knp]\" ]] && bindkey -M tfind \"$terminfo[knp]\" $pdown_widget\n\n    # Needed for Fedora 23, zsh-5.1.1\n    bindkey -M tfind ' ' self-insert\n\n    # Removal of default Ctrl-R binding\n    bindkey -M tfind '^R' $down_widget\n    # If one would like to re-open\n    bindkey -M tfind '^O' $down_widget\n\n    # Substitute self-insert, backward-delete-char, delete-char\n    zle -A self-insert saved-self-insert\n    zle -A backward-delete-char saved-backward-delete-char\n    zle -A delete-char saved-delete-char\n    zle -N self-insert _tfind_self_insert\n    zle -N backward-delete-char _tfind_backward_delete_char\n    zle -N delete-char _tfind_delete_char\n    zle -N tfind-functions _tfind_functions\n    zle -N tfind-sort _tfind_sort\n\n    # Override ourselves with what we actually are\n    # because zsh-autosuggestions change us\n    zle -A $down_widget saved-$down_widget\n    zle -A $up_widget saved-$up_widget\n    zle -N $down_widget _tfind_simulate_widget\n    zle -N $up_widget _tfind_simulate_widget\n\n    zle -A $pdown_widget saved-$pdown_widget\n    zle -A $pup_widget saved-$pup_widget\n    zle -N $pdown_widget _tfind_simulate_widget\n    zle -N $pup_widget _tfind_simulate_widget\n    if (( $+widgets[zle-line-pre-redraw] )); then\n        zle -A zle-line-pre-redraw saved-pre-redraw\n        zle -D zle-line-pre-redraw\n    fi\n    local selected_editor cd_at_edit tagtext tagline taglinebyte tagfile\n    local -a comm\n    comm=()\n\n    # Add Ctrl-V, ESC bindings to cancel search\n    # A workaround for Zsh versions like 5.0.2\n    zle -N _tfind_cancel_accept\n    bindkey -M tfind \"^[\" _tfind_cancel_accept\n    bindkey -M tfind \"^f\" tfind-functions\n    bindkey -M tfind \"\\es\" tfind-sort\n\n    local redrawbkp=0\n    # Trap INT to manually interrupt Zle to work around a bug\n    trap 'zle && zle .send-break' INT\n    if zle .recursive-edit -K tfind; then\n        if ((__tfind_spe_index<=0)); then\n            :\n        else\n            zstyle -s \":plugin:zinit:symbol-search\" editor selected_editor || selected_editor=${VISUAL:-${EDITOR:-mcedit}}\n            zstyle -T \":plugin:zinit:symbol-search\" cd_at_edit && cd_at_edit=yes || cd_at_edit=no\n            (( ! $+commands[$selected_editor] )) && selected_editor=vim\n            (( ! $+commands[$selected_editor] )) && selected_editor=nano\n            (( ! $+commands[$selected_editor] )) && selected_editor=emacs\n\n            tagtext=$__tfind_spe_found[__tfind_spe_index]\n            if [[ $tagtext = (#b)[^$'\\177']#$'\\177'[^$'\\1']#$'\\1'([^$'\\2']#)$'\\2'(*) ]]; then\n                taglinebyte=${match[1]}\n                tagline=${taglinebyte%%,*}\n\n                # CD vs absolute path\n                if [[ $match[2] != /* && -n $TAG[repo-dir] ]]; then\n                    tagfile=$TAG[repo-dir]/$match[2]\n                else\n                    tagfile=$match[2]\n                fi\n                [[ ! -f $tagfile && -f $match[2] ]] && tagfile=$match[2]\n                # Editor command\n                case \"$selected_editor\" in\n                    (vim|vi|gvim|mvim|nvim)\n                        comm+=( $selected_editor \"+$tagline\" -- \"${(q)tagfile}\" )\n                        ;;\n                    (emacs|emacsclient)\n                        comm+=( $selected_editor \"+$tagline\" -- \"${(q)tagfile}\" )\n                        ;;\n                    (gedit)\n                        comm+=( $selected_editor \"+$tagline\" -- \"${(q)tagfile}\" )\n                        ;;\n                    (nano)\n                        comm+=( $selected_editor \"+$tagline\" -- \"${(q)tagfile}\" )\n                        ;;\n                    (mcedit)\n                        comm+=( $selected_editor \"+$tagline\" -- \"${(q)tagfile}\" )\n                        ;;\n                    (*)\n                        comm+=( $selected_editor \"+$tagline\" -- \"${(q)tagfile}\" )\n                        ;;\n                esac\n            fi\n        fi\n    else\n        BUFFER=\"\"\n    fi\n    POSTDISPLAY=\n\n    # Restore self-insert, backward-delete-char, delete-char\n    zle -A saved-self-insert self-insert\n    zle -A saved-backward-delete-char backward-delete-char\n    zle -A saved-delete-char delete-char\n    zle -D saved-self-insert saved-backward-delete-char saved-delete-char\n\n    # Restore ourselves\n    zle -A saved-$down_widget $down_widget\n    zle -A saved-$up_widget $up_widget\n    zle -D saved-$down_widget saved-$up_widget\n\n    zle -A saved-$pdown_widget $pdown_widget\n    zle -A saved-$pup_widget $pup_widget\n    zle -D saved-$pdown_widget saved-$pup_widget\n\n    if (( $+widgets[saved-pre-redraw] )); then\n        zle -A saved-pre-redraw zle-line-pre-redraw\n        zle -D saved-pre-redraw\n    fi\n\n    # Full reinitialisation at next call\n    __tfind_spe_call_count=0\n\n    # Free memory\n    __tfind_spe_found=()\n    __tfind_tag_data=()\n    region_highlight=()\n\n    # Is there a command to run?\n    if [[ $#comm != 0 ]]; then\n        local auto_run\n        zstyle -T \":plugin:zinit\" auto_run && auto_run=yes || auto_run=no\n        BUFFER=$comm[*]\n        CURSOR=$buflen\n        [[ $auto_run = yes ]] && zle .accept-line\n    fi\nelif (( __tfind_spe_call_count > 0 )); then\n    (( __tfind_spe_call_count -- ))\nfi\n\n# Local Variables:\n# mode: Shell-Script\n# sh-indentation: 2\n# indent-tabs-mode: nil\n# sh-basic-offset: 2\n# End:\n# vim: ft=zsh sw=2 ts=2 et\n"
        },
        {
          "name": "zinit-additional.zsh",
          "type": "blob",
          "size": 7.94140625,
          "content": "# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n# Copyright (c) 2016-2020 Sebastian Gniazdowski and contributors.\n\n# FUNCTION: :zinit-tmp-subst-source [[[\n:zinit-tmp-subst-source() {\n    local -a ___substs ___ab\n    ___substs=( \"${(@s.;.)ICE[subst]}\" )\n    if [[ -n ${(M)___substs:#*\\\\(#e)} ]] {\n        local ___prev\n        ___substs=( ${___substs[@]//(#b)((*)\\\\(#e)|(*))/${match[3]:+${___prev:+$___prev\\;}}${match[3]}${${___prev::=${match[2]:+${___prev:+$___prev\\;}}${match[2]}}:+}} )\n    }\n\n    # Load the plugin\n    if [[ ! -r $1 ]] {\n        +zi-log \"{error}source: Couldn't read the script {obj}${1}{error}\" \\\n            \", cannot substitute {data}${ICE[subst]}{error}.{rst}\"\n    }\n\n    local ___data=\"$(<$1)\"\n\n    () {\n        builtin emulate -LR zsh -o extendedglob -o interactivecomments ${=${options[xtrace]:#off}:+-o xtrace}\n        local ___subst ___tabspc=$'\\t'\n        for ___subst ( \"${___substs[@]}\" ) {\n            ___ab=( \"${(@)${(@)${(@s:->:)___subst}##[[:space:]]##}%%[[:space:]]##}\" )\n            ___ab[2]=${___ab[2]//(#b)\\\\([[:digit:]])/\\${match[${match[1]}]}}\n            builtin eval \"___data=\\\"\\${___data//(#b)\\${~___ab[1]}/${___ab[2]}}\\\"\"\n        }\n        ___data=\"() { ${(F)${(@)${(f)___data[@]}:#[$___tabspc]#\\#*}} ; } \\\"\\${@[2,-1]}\\\"\"\n    }\n\n    builtin eval \"$___data\"\n} # ]]]\n# FUNCTION: .zinit-service [[[\n# Handles given service, i.e. obtains lock, runs it, or waits if no lock\n#\n# $1 - type \"p\" or \"s\" (plugin or snippet)\n# $2 - mode - for plugin (light or load)\n# $3 - id - URL or plugin ID or alias name (from id-as'')\n.zinit-service() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops\n\n    local ___tpe=\"$1\" ___mode=\"$2\" ___id=\"$3\" ___fle=\"${ZINIT[SERVICES_DIR]}/${ICE[service]}.lock\" ___fd ___cmd ___tmp ___lckd ___strd=0\n    { builtin print -n >! \"$___fle\"; } 2>/dev/null 1>&2\n    [[ ! -e ${___fle:r}.fifo ]] && command mkfifo \"${___fle:r}.fifo\" 2>/dev/null 1>&2\n    [[ ! -e ${___fle:r}.fifo2 ]] && command mkfifo \"${___fle:r}.fifo2\" 2>/dev/null 1>&2\n\n    typeset -gx ZSRV_WORK_DIR=\"${ZINIT[SERVICES_DIR]}\" ZSRV_ID=\"${ICE[service]}\"  # should be also set by other p-m\n\n    while (( 1 )); do\n        (\n            while (( 1 )); do\n                [[ ! -f ${___fle:r}.stop ]] && if (( ___lckd )) || zsystem 2>/dev/null 1>&2 flock -t 1 -f ___fd -e $___fle; then\n                    ___lckd=1\n                    if (( ! ___strd )) || [[ $___cmd = RESTART ]]; then\n                        [[ $___tpe = p ]] && { ___strd=1\n                                                .zinit-load \"$___id\" \"\" \"$___mode\" 0;\n                                            }\n                        [[ $___tpe = s ]] && { ___strd=1\n                                                .zinit-load-snippet \"$___id\" \"\" 0;\n                                            }\n                    fi\n                    ___cmd=\n                    while (( 1 )); do builtin read -t 32767 ___cmd <>\"${___fle:r}.fifo\" && break; done\n                else\n                    return 0\n                fi\n\n                [[ $___cmd = (#i)NEXT ]] && { kill -TERM \"$ZSRV_PID\"; builtin read -t 2 ___tmp <>\"${___fle:r}.fifo2\"; kill -HUP \"$ZSRV_PID\"; exec {___fd}>&-; ___lckd=0; ___strd=0; builtin read -t 10 ___tmp <>\"${___fle:r}.fifo2\"; }\n                [[ $___cmd = (#i)STOP ]] && { kill -TERM \"$ZSRV_PID\"; builtin read -t 2 ___tmp <>\"${___fle:r}.fifo2\"; kill -HUP \"$ZSRV_PID\"; ___strd=0; builtin print >! \"${___fle:r}.stop\"; }\n                [[ $___cmd = (#i)QUIT ]] && { kill -HUP ${sysparams[pid]}; return 1; }\n                [[ $___cmd != (#i)RESTART ]] && { ___cmd=; builtin read -t 1 ___tmp <>\"${___fle:r}.fifo2\"; }\n            done\n        ) || break\n        builtin read -t 1 ___tmp <>\"${___fle:r}.fifo2\"\n    done >>! \"$ZSRV_WORK_DIR/$ZSRV_ID\".log 2>&1\n} # ]]]\n# FUNCTION: .zinit-wrap-track-functions [[[\n.zinit-wrap-track-functions() {\n    local user=\"$1\" plugin=\"$2\" id_as=\"$3\" f\n    local -a wt\n    wt=( ${(@s.;.)ICE[wrap-track]} )\n    for f in ${wt[@]}; do\n        functions[${f}-zinit-bkp]=\"${functions[$f]}\"\n        eval \"\nfunction $f {\n    ZINIT[CUR_USR]=\\\"$user\\\" ZINIT[CUR_PLUGIN]=\\\"$plugin\\\" ZINIT[CUR_USPL2]=\\\"$id_as\\\"\n    .zinit-add-report \\\"\\${ZINIT[CUR_USPL2]}\\\" \\\"Note: === Starting to track function: $f ===\\\"\n    .zinit-diff \\\"\\${ZINIT[CUR_USPL2]}\\\" begin\n    .zinit-tmp-subst-on load\n    functions[${f}]=\\${functions[${f}-zinit-bkp]}\n    ${f} \\\"\\$@\\\"\n    .zinit-tmp-subst-off load\n    .zinit-diff \\\"\\${ZINIT[CUR_USPL2]}\\\" end\n    .zinit-add-report \\\"\\${ZINIT[CUR_USPL2]}\\\" \\\"Note: === Ended tracking function: $f ===\\\"\n    ZINIT[CUR_USR]= ZINIT[CUR_PLUGIN]= ZINIT[CUR_USPL2]=\n}\"\n    done\n} # ]]]\n\n#\n# debug command\n#\n\n# FUNCTION: .zinit-debug-clear [[[\n# Clear latest debug report\n.zinit-debug-clear() {\n    {\n        .zinit-clear-report-for _dtrace/_dtrace\n        +zi-log '{m} Cleared debug report'\n    } || {\n        +zi-log '{e} Failed to clear debug report'\n        return 1\n    }\n} # ]]]\n# FUNCTION: .zinit-debug-report [[[\n# Displays debug report (data recorded in interactive session).\n.zinit-debug-report() {\n    if [[ ${ZINIT[DTRACE]} = 1 ]]; then\n        +zi-log \"{e} Debug mode active, stop it first via {cmd}zinit debug stop{rst}\"\n    else\n        (( ${+functions[.zinit-unload]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n        .zinit-show-report \"_dtrace/_dtrace\"\n    fi\n} # ]]]\n# FUNCTION: .zinit-debug-revert [[[\n# Revert changes made during debug mode\n.zinit-debug-revert() {\n    if [[ ${ZINIT[DTRACE]} = 1 ]]; then\n        +zi-log \"{e} Debug mode is active. To stop, run {cmd}zinit debug stop{rst}\"\n    else\n        (( ${+functions[.zinit-unload]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n        .zinit-unload _dtrace _dtrace\n        +zi-log \"{m} Reverted changes detected during debug mode\"\n    fi\n} # ]]]\n# FUNCTION: .zinit-debug-start [[[\n# Start debug mode\n.zinit-debug-start() {\n    if [[ $ZINIT[DTRACE] = 1 ]]; then\n        +zi-log \"{e} Debug mode currently active\"\n        return 1\n    fi\n    (){\n        ZINIT[DTRACE]=1\n        .zinit-diff _dtrace/_dtrace begin\n        .zinit-tmp-subst-on dtrace\n    }\n    if (( $? == 0 )); then\n        +zi-log \"{i} Started debug mode\"\n        return 0\n    fi\n} # ]]]\n# FUNCTION: .zinit-debug-status [[[\n# Revert changes made during debug mode\n.zinit-debug-status() {\n    +zi-log -n '{m} Debug mode: '\n    (( ZINIT[DTRACE] )) && +zi-log 'running' || +zi-log 'stopped'\n} # ]]]\n# FUNCTION: .zinit-debug-stop [[[\n# Stop debug mode\n.zinit-debug-stop() {\n    if [[ $ZINIT[DTRACE] = 0 ]]; then\n        +zi-log '{e} Debug mode not active'\n        return 0\n    else\n        ZINIT[DTRACE]=0\n        (){\n            .zinit-tmp-subst-off dtrace     # turn of shadowing\n            .zinit-diff _dtrace/_dtrace end # get end data to diff later\n        }\n        if (( $? == 0 )); then\n            +zi-log '{i} Stopped debug mode'\n            return 0\n        fi\n    fi\n} # ]]]\n# FUNCTION: +zinit-debug [[[\n# Debug command entry point\n+zinit-debug(){\n    emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob noksharrays nokshglob nullglob typesetsilent warncreateglobal\n    local o_help cmd\n    local -a usage=(\n      'Usage:'\n      '  zinit debug [options] [command]'\n      ' '\n      'Options:'\n      '  -h, --help     Show list of command-line options'\n      ' '\n      'Commands:'\n      '  clear     Clear debug report'\n      '  report    Show debug report'\n      '  revert    Revert changes made during debug mode'\n      '  start     Start debug mode'\n      '  status    Current debug status'\n      '  stop      Stop debug mode'\n    )\n    zmodload zsh/zutil\n    zparseopts -D -F -K -- \\\n        {h,-help}=o_help \\\n    || return 1\n\n    (( $#o_help )) && {\n        print -l -- $usage\n        return 0\n    }\n\n    cmd=\"$1\"\n    if (( ! $+functions[.zinit-debug-${cmd}] )); then\n        print -l -- $usage\n        return 1\n    else\n        .zinit-debug-${cmd} \"${(@)@:2}\"\n    fi\n} # ]]]\n\n# vim: ft=zsh sw=4 ts=4 et foldmarker=[[[,]]] foldmethod=marker\n"
        },
        {
          "name": "zinit-autoload.zsh",
          "type": "blob",
          "size": 140.6943359375,
          "content": "#!/usr/bin/env zsh\n#\n# zdharma-continuum/zinit/zinit-autoload.zsh\n# Copyright (c) 2016-2021 Sebastian Gniazdowski\n# Copyright (c) 2021-2023 zdharma-continuum\n# Homepage: https://github.com/zdharma-continuum/zinit\n# License: MIT License\n#\n\nbuiltin source \"${ZINIT[BIN_DIR]}/zinit-side.zsh\" || { builtin print -P \"${ZINIT[col-error]}ERROR:%f%b Couldn't find ${ZINIT[col-obj]}zinit-side.zsh%f%b.\"; return 1; }\n\nZINIT[EXTENDED_GLOB]=\"\"\n\n#\n# Backend, low level functions\n#\n\n# FUNCTION: .zinit-unregister-plugin [[[\n# Removes the plugin from ZINIT_REGISTERED_PLUGINS array and from the\n# zsh_loaded_plugins array (managed according to the plugin standard)\n.zinit-unregister-plugin() {\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local uspl2=\"${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}\" \\\n        teleid=\"$3\"\n\n    # If not found, the index will be length+1\n    ZINIT_REGISTERED_PLUGINS[${ZINIT_REGISTERED_PLUGINS[(i)$uspl2]}]=()\n    # Support Zsh plugin standard\n    zsh_loaded_plugins[${zsh_loaded_plugins[(i)$teleid]}]=()\n    ZINIT[STATES__$uspl2]=\"0\"\n} # ]]]\n# FUNCTION: .zinit-diff-functions-compute [[[\n# Computes FUNCTIONS that holds new functions added by plugin.\n# Uses data gathered earlier by .zinit-diff-functions().\n#\n# $1 - user/plugin\n.zinit-diff-functions-compute() {\n    local uspl2=\"$1\"\n\n    # Cannot run diff if *_BEFORE or *_AFTER variable is not set\n    # Following is paranoid for *_BEFORE and *_AFTER being only spaces\n\n    builtin setopt localoptions extendedglob nokshglob noksharrays\n    [[ \"${ZINIT[FUNCTIONS_BEFORE__$uspl2]}\" != *[$'! \\t']* || \"${ZINIT[FUNCTIONS_AFTER__$uspl2]}\" != *[$'! \\t']* ]] && return 1\n\n    typeset -A func\n    local i\n\n    # This includes new functions. Quoting is kept (i.e. no i=${(Q)i})\n    for i in \"${(z)ZINIT[FUNCTIONS_AFTER__$uspl2]}\"; do\n        func[$i]=1\n    done\n\n    # Remove duplicated entries, i.e. existing before. Quoting is kept\n    for i in \"${(z)ZINIT[FUNCTIONS_BEFORE__$uspl2]}\"; do\n        # if would do unset, then: func[opp+a\\[]: invalid parameter name\n        func[$i]=0\n    done\n\n    # Store the functions, associating them with plugin ($uspl2)\n    ZINIT[FUNCTIONS__$uspl2]=\"\"\n    for i in \"${(onk)func[@]}\"; do\n        [[ \"${func[$i]}\" = \"1\" ]] && ZINIT[FUNCTIONS__$uspl2]+=\"$i \"\n    done\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-diff-options-compute [[[\n# Computes OPTIONS that holds options changed by plugin.\n# Uses data gathered earlier by .zinit-diff-options().\n#\n# $1 - user/plugin\n.zinit-diff-options-compute() {\n    local uspl2=\"$1\"\n\n    # Cannot run diff if *_BEFORE or *_AFTER variable is not set\n    # Following is paranoid for *_BEFORE and *_AFTER being only spaces\n    builtin setopt localoptions extendedglob nokshglob noksharrays\n    [[ \"${ZINIT[OPTIONS_BEFORE__$uspl2]}\" != *[$'! \\t']* || \"${ZINIT[OPTIONS_AFTER__$uspl2]}\" != *[$'! \\t']* ]] && return 1\n\n    typeset -A opts_before opts_after opts\n    opts_before=( \"${(z)ZINIT[OPTIONS_BEFORE__$uspl2]}\" )\n    opts_after=( \"${(z)ZINIT[OPTIONS_AFTER__$uspl2]}\" )\n    opts=( )\n\n    # Iterate through first array (keys the same\n    # on both of them though) and test for a change\n    local key\n    for key in \"${(k)opts_before[@]}\"; do\n        if [[ \"${opts_before[$key]}\" != \"${opts_after[$key]}\" ]]; then\n            opts[$key]=\"${opts_before[$key]}\"\n        fi\n    done\n\n    # Serialize for reporting\n    local IFS=\" \"\n    ZINIT[OPTIONS__$uspl2]=\"${(kv)opts[@]}\"\n    return 0\n} # ]]]\n# FUNCTION: .zinit-diff-env-compute [[[\n# Computes ZINIT_PATH, ZINIT_FPATH that hold (f)path components\n# added by plugin. Uses data gathered earlier by .zinit-diff-env().\n#\n# $1 - user/plugin\n.zinit-diff-env-compute() {\n    local uspl2=\"$1\"\n    typeset -a tmp\n\n    # Cannot run diff if *_BEFORE or *_AFTER variable is not set\n    # Following is paranoid for *_BEFORE and *_AFTER being only spaces\n    builtin setopt localoptions extendedglob nokshglob noksharrays\n    [[ \"${ZINIT[PATH_BEFORE__$uspl2]}\" != *[$'! \\t']* || \"${ZINIT[PATH_AFTER__$uspl2]}\" != *[$'! \\t']* ]] && return 1\n    [[ \"${ZINIT[FPATH_BEFORE__$uspl2]}\" != *[$'! \\t']* || \"${ZINIT[FPATH_AFTER__$uspl2]}\" != *[$'! \\t']* ]] && return 1\n\n    typeset -A path_state fpath_state\n    local i\n\n    #\n    # PATH processing\n    #\n\n    # This includes new path elements\n    for i in \"${(z)ZINIT[PATH_AFTER__$uspl2]}\"; do\n        path_state[${(Q)i}]=1\n    done\n\n    # Remove duplicated entries, i.e. existing before\n    for i in \"${(z)ZINIT[PATH_BEFORE__$uspl2]}\"; do\n        unset \"path_state[${(Q)i}]\"\n    done\n\n    # Store the path elements, associating them with plugin ($uspl2)\n    ZINIT[PATH__$uspl2]=\"\"\n    for i in \"${(onk)path_state[@]}\"; do\n        ZINIT[PATH__$uspl2]+=\"${(q)i} \"\n    done\n\n    #\n    # FPATH processing\n    #\n\n    # This includes new path elements\n    for i in \"${(z)ZINIT[FPATH_AFTER__$uspl2]}\"; do\n        fpath_state[${(Q)i}]=1\n    done\n\n    # Remove duplicated entries, i.e. existing before\n    for i in \"${(z)ZINIT[FPATH_BEFORE__$uspl2]}\"; do\n        unset \"fpath_state[${(Q)i}]\"\n    done\n\n    # Store the path elements, associating them with plugin ($uspl2)\n    ZINIT[FPATH__$uspl2]=\"\"\n    for i in \"${(onk)fpath_state[@]}\"; do\n        ZINIT[FPATH__$uspl2]+=\"${(q)i} \"\n    done\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-diff-parameter-compute [[[\n# Computes ZINIT_PARAMETERS_PRE, ZINIT_PARAMETERS_POST that hold\n# parameters created or changed (their type) by plugin. Uses\n# data gathered earlier by .zinit-diff-parameter().\n#\n# $1 - user/plugin\n.zinit-diff-parameter-compute() {\n    local uspl2=\"$1\"\n    typeset -a tmp\n\n    # Cannot run diff if *_BEFORE or *_AFTER variable is not set\n    # Following is paranoid for *_BEFORE and *_AFTER being only spaces\n    builtin setopt localoptions extendedglob nokshglob noksharrays\n    [[ \"${ZINIT[PARAMETERS_BEFORE__$uspl2]}\" != *[$'! \\t']* || \"${ZINIT[PARAMETERS_AFTER__$uspl2]}\" != *[$'! \\t']* ]] && return 1\n\n    # Un-concatenated parameters from moment of diff start and of diff end\n    typeset -A params_before params_after\n    params_before=( \"${(z)ZINIT[PARAMETERS_BEFORE__$uspl2]}\" )\n    params_after=( \"${(z)ZINIT[PARAMETERS_AFTER__$uspl2]}\" )\n\n    # The parameters that changed, with save of what\n    # parameter was when diff started or when diff ended\n    typeset -A params_pre params_post\n    params_pre=( )\n    params_post=( )\n\n    # Iterate through all existing keys, before or after diff,\n    # i.e. after all variables that were somehow live across\n    # the diffing process\n    local key\n    typeset -aU keys\n    keys=( \"${(k)params_after[@]}\" );\n    keys=( \"${keys[@]}\" \"${(k)params_before[@]}\" );\n    for key in \"${keys[@]}\"; do\n        key=\"${(Q)key}\"\n        [[ \"${params_after[$key]}\" = *local* ]] && continue\n        if [[ \"${params_after[$key]}\" != \"${params_before[$key]}\" ]]; then\n            # Empty for a new param, a type otherwise\n            [[ -z \"${params_before[$key]}\" ]] && params_before[$key]=\"\\\"\\\"\"\n            params_pre[$key]=\"${params_before[$key]}\"\n\n            # Current type, can also be empty, when plugin\n            # unsets a parameter\n            [[ -z \"${params_after[$key]}\" ]] && params_after[$key]=\"\\\"\\\"\"\n            params_post[$key]=\"${params_after[$key]}\"\n        fi\n    done\n\n    # Serialize for reporting\n    ZINIT[PARAMETERS_PRE__$uspl2]=\"${(j: :)${(qkv)params_pre[@]}}\"\n    ZINIT[PARAMETERS_POST__$uspl2]=\"${(j: :)${(qkv)params_post[@]}}\"\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-any-to-uspl2 [[[\n# Converts given plugin-spec to format that's used in keys for hash tables.\n# So basically, creates string \"user/plugin\" (this format is called: uspl2).\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - (optional) plugin (only when $1 - i.e. user - given)\n.zinit-any-to-uspl2() {\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    [[ \"${reply[-2]}\" = \"%\" ]] && REPLY=\"${reply[-2]}${reply[-1]}\" || REPLY=\"${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]//---//}\"\n} # ]]]\n# FUNCTION: .zinit-save-set-extendedglob [[[\n# Enables extendedglob-option first saving if it was already\n# enabled, for restoration of this state later.\n.zinit-save-set-extendedglob() {\n    [[ -o \"extendedglob\" ]] && ZINIT[EXTENDED_GLOB]=\"1\" || ZINIT[EXTENDED_GLOB]=\"0\"\n    builtin setopt extendedglob\n} # ]]]\n# FUNCTION: .zinit-restore-extendedglob [[[\n# Restores extendedglob-option from state saved earlier.\n.zinit-restore-extendedglob() {\n    [[ \"${ZINIT[EXTENDED_GLOB]}\" = \"0\" ]] && builtin unsetopt extendedglob || builtin setopt extendedglob\n} # ]]]\n# FUNCTION: .zinit-prepare-readlink [[[\n# Prepares readlink command, used for establishing completion's owner.\n#\n# $REPLY = \":\" or \"readlink\"\n.zinit-prepare-readlink() {\n    REPLY=\":\"\n    if type readlink 2>/dev/null 1>&2; then\n        REPLY=\"readlink\"\n    fi\n} # ]]]\n# FUNCTION: .zinit-clear-report-for [[[\n# Clears all report data for given user/plugin. This is\n# done by resetting all related global ZINIT_* hashes.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - (optional) plugin (only when $1 - i.e. user - given)\n.zinit-clear-report-for() {\n    .zinit-any-to-uspl2 \"$1\" \"$2\"\n\n    # Shadowing\n    ZINIT_REPORTS[$REPLY]=\"\"\n    ZINIT[BINDKEYS__$REPLY]=\"\"\n    ZINIT[ZSTYLES__$REPLY]=\"\"\n    ZINIT[ALIASES__$REPLY]=\"\"\n    ZINIT[WIDGETS_SAVED__$REPLY]=\"\"\n    ZINIT[WIDGETS_DELETE__$REPLY]=\"\"\n\n    # Function diffing\n    ZINIT[FUNCTIONS__$REPLY]=\"\"\n    ZINIT[FUNCTIONS_BEFORE__$REPLY]=\"\"\n    ZINIT[FUNCTIONS_AFTER__$REPLY]=\"\"\n\n    # Option diffing\n    ZINIT[OPTIONS__$REPLY]=\"\"\n    ZINIT[OPTIONS_BEFORE__$REPLY]=\"\"\n    ZINIT[OPTIONS_AFTER__$REPLY]=\"\"\n\n    # Environment diffing\n    ZINIT[PATH__$REPLY]=\"\"\n    ZINIT[PATH_BEFORE__$REPLY]=\"\"\n    ZINIT[PATH_AFTER__$REPLY]=\"\"\n    ZINIT[FPATH__$REPLY]=\"\"\n    ZINIT[FPATH_BEFORE__$REPLY]=\"\"\n    ZINIT[FPATH_AFTER__$REPLY]=\"\"\n\n    # Parameter diffing\n    ZINIT[PARAMETERS_PRE__$REPLY]=\"\"\n    ZINIT[PARAMETERS_POST__$REPLY]=\"\"\n    ZINIT[PARAMETERS_BEFORE__$REPLY]=\"\"\n    ZINIT[PARAMETERS_AFTER__$REPLY]=\"\"\n} # ]]]\n# FUNCTION: .zinit-exists-message [[[\n# Checks if plugin is loaded. Testable. Also outputs error\n# message if plugin is not loaded.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - (optional) plugin (only when $1 - i.e. user - given)\n.zinit-exists-message() {\n    .zinit-any-to-uspl2 \"$1\" \"$2\"\n    if [[ -z \"${ZINIT_REGISTERED_PLUGINS[(r)$REPLY]}\" ]]; then\n        .zinit-any-colorify-as-uspl2 \"$1\" \"$2\"\n        builtin print \"${ZINIT[col-error]}No such plugin${ZINIT[col-rst]} $REPLY\"\n        return 1\n    fi\n    return 0\n} # ]]]\n# FUNCTION: .zinit-at-eval [[[\n.zinit-at-eval() {\n    local atclone=\"$2\" atpull=\"$1\"\n    integer retval\n    @zinit-substitute atclone atpull\n    [[ $atpull = \"%atclone\" ]] && { eval \"$atclone\"; retval=$?; } || { eval \"$atpull\"; retval=$?; }\n    return $retval\n} # ]]]\n\n#\n# Format functions\n#\n\n# FUNCTION: .zinit-format-functions [[[\n# Creates a one or two columns text with functions created\n# by given plugin.\n#\n# $1 - user/plugin (i.e. uspl2 format of plugin-spec)\n.zinit-format-functions() {\n    local uspl2=\"$1\"\n\n    typeset -a func\n    func=( \"${(z)ZINIT[FUNCTIONS__$uspl2]}\" )\n\n    # Get length of longest left-right string pair,\n    # and length of longest left string\n    integer longest=0 longest_left=0 cur_left_len=0 count=1\n    local f\n    for f in \"${(on)func[@]}\"; do\n        [[ -z \"${#f}\" ]] && continue\n        f=\"${(Q)f}\"\n\n        # Compute for elements in left column,\n        # ones that will be paded with spaces\n        if (( count ++ % 2 != 0 )); then\n            [[ \"${#f}\" -gt \"$longest_left\" ]] && longest_left=\"${#f}\"\n            cur_left_len=\"${#f}\"\n        else\n            cur_left_len+=\"${#f}\"\n            cur_left_len+=1 # For separating space\n            [[ \"$cur_left_len\" -gt \"$longest\" ]] && longest=\"$cur_left_len\"\n        fi\n    done\n\n    # Output in one or two columns\n    local answer=\"\"\n    count=1\n    for f in \"${(on)func[@]}\"; do\n        [[ -z \"$f\" ]] && continue\n        f=\"${(Q)f}\"\n\n        if (( COLUMNS >= longest )); then\n            if (( count ++ % 2 != 0 )); then\n                answer+=\"${(r:longest_left+1:: :)f}\"\n            else\n                answer+=\"$f\"$'\\n'\n            fi\n        else\n            answer+=\"$f\"$'\\n'\n        fi\n    done\n    REPLY=\"$answer\"\n    # == 0 is: next element would have newline (postfix addition in \"count ++\")\n    (( COLUMNS >= longest && count % 2 == 0 )) && REPLY=\"$REPLY\"$'\\n'\n} # ]]]\n# FUNCTION: .zinit-format-options [[[\n# Creates one-column text about options that changed when\n# plugin \"$1\" was loaded.\n#\n# $1 - user/plugin (i.e. uspl2 format of plugin-spec)\n.zinit-format-options() {\n    local uspl2=\"$1\"\n\n    REPLY=\"\"\n\n    # Paranoid, don't want bad key/value pair error\n    integer empty=0\n    .zinit-save-set-extendedglob\n    [[ \"${ZINIT[OPTIONS__$uspl2]}\" != *[$'! \\t']* ]] && empty=1\n    .zinit-restore-extendedglob\n    (( empty )) && return 0\n\n    typeset -A opts\n    opts=( \"${(z)ZINIT[OPTIONS__$uspl2]}\" )\n\n    # Get length of longest option\n    integer longest=0\n    local k\n    for k in \"${(kon)opts[@]}\"; do\n        [[ \"${#k}\" -gt \"$longest\" ]] && longest=\"${#k}\"\n    done\n\n    # Output in one column\n    local txt\n    for k in \"${(kon)opts[@]}\"; do\n        [[ \"${opts[$k]}\" = \"on\" ]] && txt=\"was unset\" || txt=\"was set\"\n        REPLY+=\"${(r:longest+1:: :)k}$txt\"$'\\n'\n    done\n} # ]]]\n# FUNCTION: .zinit-format-env [[[\n# Creates one-column text about FPATH or PATH elements\n# added when given plugin was loaded.\n#\n# $1 - user/plugin (i.e. uspl2 format of plugin-spec)\n# $2 - if 1, then examine PATH, if 2, then examine FPATH\n.zinit-format-env() {\n    local uspl2=\"$1\" which=\"$2\"\n\n    # Format PATH?\n    if [[ \"$which\" = \"1\" ]]; then\n        typeset -a elem\n        elem=( \"${(z@)ZINIT[PATH__$uspl2]}\" )\n    elif [[ \"$which\" = \"2\" ]]; then\n        typeset -a elem\n        elem=( \"${(z@)ZINIT[FPATH__$uspl2]}\" )\n    fi\n\n    # Enumerate elements added\n    local answer=\"\" e\n    for e in \"${elem[@]}\"; do\n        [[ -z \"$e\" ]] && continue\n        e=\"${(Q)e}\"\n        answer+=\"$e\"$'\\n'\n    done\n\n    [[ -n \"$answer\" ]] && REPLY=\"$answer\"\n} # ]]]\n# FUNCTION: .zinit-format-parameter [[[\n# Creates one column text that lists global parameters that\n# changed when the given plugin was loaded.\n#\n# $1 - user/plugin (i.e. uspl2 format of plugin-spec)\n.zinit-format-parameter() {\n    local uspl2=\"$1\" infoc=\"${ZINIT[col-info]}\" k\n\n    builtin setopt localoptions extendedglob nokshglob noksharrays\n    REPLY=\"\"\n    [[ \"${ZINIT[PARAMETERS_PRE__$uspl2]}\" != *[$'! \\t']* || \"${ZINIT[PARAMETERS_POST__$uspl2]}\" != *[$'! \\t']* ]] && return 0\n\n    typeset -A elem_pre elem_post\n    elem_pre=( \"${(z)ZINIT[PARAMETERS_PRE__$uspl2]}\" )\n    elem_post=( \"${(z)ZINIT[PARAMETERS_POST__$uspl2]}\" )\n\n    # Find longest key and longest value\n    integer longest=0 vlongest1=0 vlongest2=0\n    local v1 v2\n    for k in \"${(k)elem_post[@]}\"; do\n        k=\"${(Q)k}\"\n        [[ \"${#k}\" -gt \"$longest\" ]] && longest=\"${#k}\"\n\n        v1=\"${(Q)elem_pre[$k]}\"\n        v2=\"${(Q)elem_post[$k]}\"\n        [[ \"${#v1}\" -gt \"$vlongest1\" ]] && vlongest1=\"${#v1}\"\n        [[ \"${#v2}\" -gt \"$vlongest2\" ]] && vlongest2=\"${#v2}\"\n    done\n\n    # Enumerate parameters that changed. A key\n    # always exists in both of the arrays\n    local answer=\"\" k\n    for k in \"${(k)elem_post[@]}\"; do\n        v1=\"${(Q)elem_pre[$k]}\"\n        v2=\"${(Q)elem_post[$k]}\"\n        k=\"${(Q)k}\"\n\n        k=\"${(r:longest+1:: :)k}\"\n        v1=\"${(l:vlongest1+1:: :)v1}\"\n        v2=\"${(r:vlongest2+1:: :)v2}\"\n        answer+=\"$k ${infoc}[$v1 -> $v2]${ZINIT[col-rst]}\"$'\\n'\n    done\n\n    [[ -n \"$answer\" ]] && REPLY=\"$answer\"\n\n    return 0\n} # ]]]\n\n#\n# Completion functions\n#\n\n# FUNCTION: .zinit-get-completion-owner [[[\n# Returns \"user---plugin\" string (uspl1 format) of plugin that\n# owns given completion.\n#\n# Both :A and readlink will be used, then readlink's output if\n# results differ. Readlink might not be available.\n#\n# :A will read the link \"twice\" and give the final repository\n# directory, possibly without username in the uspl format;\n# readlink will read the link \"once\"\n#\n# $1 - absolute path to completion file (in COMPLETIONS_DIR)\n# $2 - readlink command (\":\" or \"readlink\")\n.zinit-get-completion-owner() {\n    setopt localoptions extendedglob nokshglob noksharrays noshwordsplit\n    local cpath=\"$1\"\n    local readlink_cmd=\"$2\"\n    local in_plugin_path tmp\n\n    # Try to go not too deep into resolving the symlink,\n    # to have the name as it is in .zinit/plugins\n    # :A goes deep, descends fully to origin directory\n    # Readlink just reads what symlink points to\n    in_plugin_path=\"${cpath:A}\"\n    tmp=$( \"$readlink_cmd\" \"$cpath\" )\n    # This in effect works as: \"if different, then readlink\"\n    [[ -n \"$tmp\" ]] && in_plugin_path=\"$tmp\"\n\n    if [[ \"$in_plugin_path\" != \"$cpath\" && -r \"$in_plugin_path\" ]]; then\n        # Get the user---plugin part of path\n        while [[ \"$in_plugin_path\" != ${ZINIT[PLUGINS_DIR]}/[^/]## && \"$in_plugin_path\" != \"/\" && \"$in_plugin_path\" != \".\" ]]; do\n            in_plugin_path=\"${in_plugin_path:h}\"\n        done\n        in_plugin_path=\"${in_plugin_path:t}\"\n\n        if [[ -z \"$in_plugin_path\" ]]; then\n            in_plugin_path=\"${tmp:h}\"\n        fi\n    else\n        # readlink and :A have nothing\n        in_plugin_path=\"[unknown]\"\n    fi\n\n    REPLY=\"$in_plugin_path\"\n} # ]]]\n# FUNCTION: .zinit-get-completion-owner-uspl2col [[[\n# For shortening of code - returns colorized plugin name\n# that owns given completion.\n#\n# $1 - absolute path to completion file (in COMPLETIONS_DIR)\n# $2 - readlink command (\":\" or \"readlink\")\n.zinit-get-completion-owner-uspl2col() {\n    # \"cpath\" \"readline_cmd\"\n    .zinit-get-completion-owner \"$1\" \"$2\"\n    .zinit-any-colorify-as-uspl2 \"$REPLY\"\n} # ]]]\n# FUNCTION: .zinit-find-completions-of-plugin [[[\n# Searches for completions owned by given plugin.\n# Returns them in `reply' array.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-find-completions-of-plugin() {\n    builtin setopt localoptions nullglob extendedglob nokshglob noksharrays\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\" uspl\n    [[ \"$user\" = \"%\" ]] && uspl=\"${user}${plugin}\" || uspl=\"${reply[-2]}${reply[-2]:+---}${reply[-1]//\\//---}\"\n\n    reply=( \"${ZINIT[PLUGINS_DIR]}/$uspl\"/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1)(DN) )\n} # ]]]\n# FUNCTION: .zinit-check-comp-consistency [[[\n# Zinit creates symlink for each installed completion.\n# This function checks whether given completion (i.e.\n# file like \"_mkdir\") is indeed a symlink. Backup file\n# is a completion that is disabled - has the leading \"_\"\n# removed.\n#\n# $1 - path to completion within plugin's directory\n# $2 - path to backup file within plugin's directory\n.zinit-check-comp-consistency() {\n    local cfile=\"$1\" bkpfile=\"$2\"\n    integer error=\"$3\"\n\n    # bkpfile must be a symlink\n    if [[ -e \"$bkpfile\" && ! -L \"$bkpfile\" ]]; then\n        builtin print \"${ZINIT[col-error]}Warning: completion's backup file \\`${bkpfile:t}' isn't a symlink${ZINIT[col-rst]}\"\n        error=1\n    fi\n\n    # cfile must be a symlink\n    if [[ -e \"$cfile\" && ! -L \"$cfile\" ]]; then\n        builtin print \"${ZINIT[col-error]}Warning: completion file \\`${cfile:t}' isn't a symlink${ZINIT[col-rst]}\"\n        error=1\n    fi\n\n    # Tell user that he can manually modify but should do it right\n    (( error )) && builtin print \"${ZINIT[col-error]}Manual edit of ${ZINIT[COMPLETIONS_DIR]} occured?${ZINIT[col-rst]}\"\n} # ]]]\n# FUNCTION: .zinit-check-which-completions-are-installed [[[\n# For each argument that each should be a path to completion\n# within a plugin's dir, it checks whether that completion\n# is installed - returns 0 or 1 on corresponding positions\n# in reply.\n#\n# $1, ... - path to completion within plugin's directory\n.zinit-check-which-completions-are-installed() {\n    local i cfile bkpfile\n    reply=( )\n    for i in \"$@\"; do\n        cfile=\"${i:t}\"\n        bkpfile=\"${cfile#_}\"\n\n        if [[ -e \"${ZINIT[COMPLETIONS_DIR]}\"/\"$cfile\" || -e \"${ZINIT[COMPLETIONS_DIR]}\"/\"$bkpfile\" ]]; then\n            reply+=( \"1\" )\n        else\n            reply+=( \"0\" )\n        fi\n    done\n} # ]]]\n# FUNCTION: .zinit-check-which-completions-are-enabled [[[\n# For each argument that each should be a path to completion\n# within a plugin's dir, it checks whether that completion\n# is disabled - returns 0 or 1 on corresponding positions\n# in reply.\n#\n# Uninstalled completions will be reported as \"0\"\n# - i.e. disabled\n#\n# $1, ... - path to completion within plugin's directory\n.zinit-check-which-completions-are-enabled() {\n    local i cfile\n    reply=( )\n    for i in \"$@\"; do\n        cfile=\"${i:t}\"\n\n        if [[ -e \"${ZINIT[COMPLETIONS_DIR]}\"/\"$cfile\" ]]; then\n            reply+=( \"1\" )\n        else\n            reply+=( \"0\" )\n        fi\n    done\n} # ]]]\n# FUNCTION: .zinit-uninstall-completions [[[\n# Removes all completions of given plugin from Zshell (i.e. from FPATH).\n# The FPATH is typically `~/.zinit/completions/'.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-uninstall-completions() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt nullglob extendedglob warncreateglobal typesetsilent noshortloops\n\n    typeset -a completions symlinked backup_comps\n    local c cfile bkpfile\n    integer action global_action=0\n\n    .zinit-get-path \"$1\" \"$2\"\n    [[ -e $REPLY ]] && {\n        completions=( $REPLY/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1)(DN) )\n    } || {\n        builtin print \"No completions found for \\`$1${${1:#(%|/)*}:+${2:+/}}$2'\"\n        return 1\n    }\n\n    symlinked=( ${ZINIT[COMPLETIONS_DIR]}/_[^_.]*~*.zwc )\n    backup_comps=( ${ZINIT[COMPLETIONS_DIR]}/[^_.]*~*.zwc )\n\n    (( ${+functions[.zinit-forget-completion]} )) || builtin source ${ZINIT[BIN_DIR]}\"/zinit-install.zsh\"\n\n    # Delete completions if they are really there, either\n    # as completions (_fname) or backups (fname)\n    for c in ${completions[@]}; do\n        action=0\n        cfile=${c:t}\n        bkpfile=${cfile#_}\n\n        # Remove symlink to completion\n        if [[ -n ${symlinked[(r)*/$cfile]} ]]; then\n            command rm -f ${ZINIT[COMPLETIONS_DIR]}/$cfile\n            action=1\n        fi\n\n        # Remove backup symlink (created by cdisable)\n        if [[ -n ${backup_comps[(r)*/$bkpfile]} ]]; then\n            command rm -f ${ZINIT[COMPLETIONS_DIR]}/$bkpfile\n            action=1\n        fi\n\n        if (( action )); then\n            +zi-log \"{info}Uninstalling completion \\`{file}$cfile{info}'{…}{rst}\"\n            # Make compinit notice the change\n            .zinit-forget-completion \"$cfile\"\n            (( global_action ++ ))\n        else\n            +zi-log \"{info}Completion \\`{file}$cfile{info}' not installed.{rst}\"\n        fi\n    done\n\n    if (( global_action > 0 )); then\n        +zi-log \"{info}Uninstalled {num}$global_action{info} completions.{rst}\"\n    fi\n\n    .zinit-compinit >/dev/null\n} # ]]]\n\n#\n# User-exposed functions\n#\n\n# FUNCTION: .zinit-pager [[[\n# BusyBox less lacks the -X and -i options, so it can use more\n.zinit-pager() {\n    setopt LOCAL_OPTIONS EQUALS\n    # Quiet mode ? → no pager.\n    if (( OPTS[opt_-n,--no-pager] )) {\n        cat\n        return 0\n    }\n    if [[ ${${:-=less}:A:t} = busybox* ]] {\n        more 2>/dev/null\n        (( ${+commands[more]} ))\n    } else {\n        less -FRXi 2>/dev/null\n        (( ${+commands[less]} ))\n    }\n    (( $? )) && cat\n    return 0\n} # ]]]\n\n# FUNCTION: .zinit-build-module [[[\n# Performs ./configure && make on the module and displays information\n# how to load the module in .zshrc.\n.zinit-build-module() {\n    setopt localoptions localtraps\n    trap 'return 1' INT TERM\n    if command git -C \"${ZINIT[MODULE_DIR]}\" rev-parse 2>/dev/null; then\n        command git -C \"${ZINIT[MODULE_DIR]}\" clean -d -f -f\n        command git -C \"${ZINIT[MODULE_DIR]}\" reset --hard HEAD\n        command git -C \"${ZINIT[MODULE_DIR]}\" pull\n    else\n        command git clone \"https://github.com/zdharma-continuum/zinit-module.git\" \"${ZINIT[MODULE_DIR]}\" || {\n            builtin print \"${ZINIT[col-error]}Failed to clone module repo${ZINIT[col-rst]}\"\n            return 1\n        }\n    fi\n    ( builtin cd -q \"${ZINIT[MODULE_DIR]}\"\n      +zi-log \"{pname}== Building module zdharma-continuum/zinit-module, running: make clean, then ./configure and then make =={rst}\"\n      +zi-log \"{pname}== The module sources are located at: \"${ZINIT[MODULE_DIR]}\" =={rst}\"\n      if [[ -f Makefile ]] {\n          if [[ \"$1\" = \"--clean\" ]] {\n              noglob +zi-log {p}-- make distclean --{rst}\n              make distclean\n              ((1))\n          } else {\n              noglob +zi-log {p}-- make clean --{rst}\n              make clean\n          }\n      }\n      noglob +zi-log  {p}-- ./configure --{rst}\n      CPPFLAGS=-I/usr/local/include CFLAGS=\"-g -Wall -O3\" LDFLAGS=-L/usr/local/lib ./configure --disable-gdbm --without-tcsetpgrp && {\n          noglob +zi-log {p}-- make --{rst}\n          if { make } {\n            [[ -f Src/zdharma_continuum/zinit.so ]] && cp -vf Src/zdharma_continuum/zinit.{so,bundle}\n            noglob +zi-log \"{info}Module has been built correctly.{rst}\"\n            .zinit-module info\n          } else {\n              noglob +zi-log  \"{error}Module didn't build.{rst} \"\n              .zinit-module info --link\n          }\n      }\n      builtin print $EPOCHSECONDS >! \"${ZINIT[MAN_DIR]}/COMPILED_AT\"\n    )\n} # ]]]\n# FUNCTION: .zinit-module [[[\n# Function that has sub-commands passed as long-options (with two dashes, --).\n# It's an attempt to plugin only this one function into `zinit' function\n# defined in zinit.zsh, to not make this file longer than it's needed.\n.zinit-module() {\n    if [[ \"$1\" = \"build\" ]]; then\n        .zinit-build-module \"${@[2,-1]}\"\n    elif [[ \"$1\" = \"info\" ]]; then\n        if [[ \"$2\" = \"--link\" ]]; then\n              builtin print -r \"You can copy the error messages and submit\"\n              builtin print -r \"error-report at: https://github.com/zdharma-continuum/zinit-module/issues\"\n        else\n            builtin print -r \"To load the module, add following 2 lines to .zshrc, at top:\"\n            builtin print -r \"    module_path+=( \\\"${ZINIT[MODULE_DIR]}/Src\\\" )\"\n            builtin print -r \"    zmodload zdharma_continuum/zinit\"\n            builtin print -r \"\"\n            builtin print -r \"After loading, use command \\`zpmod' to communicate with the module.\"\n            builtin print -r \"See \\`zpmod -h' for more information.\"\n        fi\n    elif [[ \"$1\" = (help|usage) ]]; then\n        builtin print -r \"Usage: zinit module {build|info|help} [options]\"\n        builtin print -r \"       zinit module build [--clean]\"\n        builtin print -r \"       zinit module info [--link]\"\n        builtin print -r \"\"\n        builtin print -r \"To start using the zinit Zsh module run: \\`zinit module build'\"\n        builtin print -r \"and follow the instructions. Option --clean causes \\`make distclean'\"\n        builtin print -r \"to be run. To display the instructions on loading the module, run:\"\n        builtin print -r \"\\`zinit module info'.\"\n    fi\n} # ]]]\n\n# FUNCTION: .zinit-cd [[[\n# Jumps to plugin's directory (in Zinit's home directory).\n#\n# User-action entry point.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-cd() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob warncreateglobal typesetsilent rcquotes\n\n    .zinit-get-path \"$1\" \"$2\" && {\n        if [[ -e $REPLY ]]; then\n            builtin pushd $REPLY\n        else\n            +zi-log \"No such plugin or snippet\"\n            return 1\n        fi\n        builtin print\n    } || {\n        +zi-log \"No such plugin or snippet\"\n        return 1\n    }\n} # ]]]\n# FUNCTION: .zinit-cdisable [[[\n# Enables given installed completion.\n#\n# User-action entry point.\n#\n# $1 - e.g. \"_mkdir\" or \"mkdir\"\n.zinit-cdisable() {\n    local c=\"$1\"\n    c=\"${c#_}\"\n\n    local cfile=\"${ZINIT[COMPLETIONS_DIR]}/_${c}\"\n    local bkpfile=\"${cfile:h}/$c\"\n\n    if [[ ! -e \"$cfile\" && ! -e \"$bkpfile\" ]]; then\n        builtin print \"${ZINIT[col-error]}No such completion \\`$c'${ZINIT[col-rst]}\"\n        return 1\n    fi\n\n    # Check if it's already disabled\n    # Not existing \"$cfile\" says that\n    if [[ ! -e \"$cfile\" ]]; then\n        builtin print \"Completion ${ZINIT[col-info]}$c${ZINIT[col-rst]} already disabled\"\n\n        .zinit-check-comp-consistency \"$cfile\" \"$bkpfile\" 0\n        return 1\n    fi\n\n    # No disable, but bkpfile exists?\n    if [[ -e \"$bkpfile\" ]]; then\n        builtin print \"${ZINIT[col-error]}Warning: completion's backup file \\`${bkpfile:t}' already exists, will overwrite${ZINIT[col-rst]}\"\n        .zinit-check-comp-consistency \"$cfile\" \"$bkpfile\" 1\n        command rm -f \"$bkpfile\"\n    else\n        .zinit-check-comp-consistency \"$cfile\" \"$bkpfile\" 0\n    fi\n\n    # Disable\n    command mv \"$cfile\" \"$bkpfile\"\n\n    # Prepare readlink command for establishing completion's owner\n    .zinit-prepare-readlink\n    # Get completion's owning plugin\n    .zinit-get-completion-owner-uspl2col \"$bkpfile\" \"$REPLY\"\n\n    builtin print \"Disabled ${ZINIT[col-info]}$c${ZINIT[col-rst]} completion belonging to $REPLY\"\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-cenable [[[\n# Disables given installed completion.\n#\n# User-action entry point.\n#\n# $1 - e.g. \"_mkdir\" or \"mkdir\"\n.zinit-cenable() {\n    local c=\"$1\"\n    c=\"${c#_}\"\n\n    local cfile=\"${ZINIT[COMPLETIONS_DIR]}/_${c}\"\n    local bkpfile=\"${cfile:h}/$c\"\n\n    if [[ ! -e \"$cfile\" && ! -e \"$bkpfile\" ]]; then\n        builtin print \"${ZINIT[col-error]}No such completion \\`$c'${ZINIT[col-rst]}\"\n        return 1\n    fi\n\n    # Check if there is no backup file\n    # This is treated as if the completion is already enabled\n    if [[ ! -e \"$bkpfile\" ]]; then\n        builtin print \"Completion ${ZINIT[col-info]}$c${ZINIT[col-rst]} already enabled\"\n\n        .zinit-check-comp-consistency \"$cfile\" \"$bkpfile\" 0\n        return 1\n    fi\n\n    # Disabled, but completion file already exists?\n    if [[ -e \"$cfile\" ]]; then\n        builtin print \"${ZINIT[col-error]}Warning: completion's file \\`${cfile:t}' exists, will overwrite${ZINIT[col-rst]}\"\n        builtin print \"${ZINIT[col-error]}Completion is actually enabled and will re-enable it again${ZINIT[col-rst]}\"\n        .zinit-check-comp-consistency \"$cfile\" \"$bkpfile\" 1\n        command rm -f \"$cfile\"\n    else\n        .zinit-check-comp-consistency \"$cfile\" \"$bkpfile\" 0\n    fi\n\n    # Enable\n    command mv \"$bkpfile\" \"$cfile\" # move completion's backup file created when disabling\n\n    # Prepare readlink command for establishing completion's owner\n    .zinit-prepare-readlink\n    # Get completion's owning plugin\n    .zinit-get-completion-owner-uspl2col \"$cfile\" \"$REPLY\"\n\n    builtin print \"Enabled ${ZINIT[col-info]}$c${ZINIT[col-rst]} completion belonging to $REPLY\"\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-changes [[[\n# Shows `git log` of given plugin.\n#\n# User-action entry point.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-changes() {\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n\n    .zinit-exists-physically-message \"$user\" \"$plugin\" || return 1\n\n    (\n        builtin cd -q \"${ZINIT[PLUGINS_DIR]}/${user:+${user}---}${plugin//\\//---}\" && \\\n        command git log -p --graph --decorate --date=relative -C -M\n    )\n} # ]]]\n# FUNCTION: .zinit-clear-completions [[[\n# Delete stray and improper completions.\n#\n# Completions live even when plugin isn't loaded - if they are\n# installed and enabled.\n#\n# User-action entry point.\n.zinit-clear-completions() {\n    builtin setopt localoptions nullglob extendedglob nokshglob noksharrays\n\n    typeset -a completions\n    completions=( \"${ZINIT[COMPLETIONS_DIR]}\"/_[^_.]*~*.zwc \"${ZINIT[COMPLETIONS_DIR]}\"/[^_.]*~*.zwc )\n\n    # Find longest completion name\n    local cpath c\n    integer longest=0\n    for cpath in \"${completions[@]}\"; do\n        c=\"${cpath:t}\"\n        c=\"${c#_}\"\n        [[ \"${#c}\" -gt \"$longest\" ]] && longest=\"${#c}\"\n    done\n\n    .zinit-prepare-readlink\n    local rdlink=\"$REPLY\"\n\n    integer disabled unknown stray\n    for cpath in \"${completions[@]}\"; do\n        c=\"${cpath:t}\"\n        [[ \"${c#_}\" = \"${c}\" ]] && disabled=1 || disabled=0\n        c=\"${c#_}\"\n\n        # This will resolve completion's symlink to obtain\n        # information about the repository it comes from, i.e.\n        # about user and plugin, taken from directory name\n        .zinit-get-completion-owner \"$cpath\" \"$rdlink\"\n        [[ \"$REPLY\" = \"[unknown]\" ]] && unknown=1 || unknown=0\n        .zinit-any-colorify-as-uspl2 \"$REPLY\"\n\n        # If we successfully read a symlink (unknown == 0), test if it isn't broken\n        stray=0\n        if (( unknown == 0 )); then\n            [[ ! -f \"$cpath\" ]] && stray=1\n        fi\n\n        if (( unknown == 1 || stray == 1 )); then\n            builtin print -n \"Removing completion: ${(r:longest+1:: :)c} $REPLY\"\n            (( disabled )) && builtin print -n \" ${ZINIT[col-error]}[disabled]${ZINIT[col-rst]}\"\n            (( unknown )) && builtin print -n \" ${ZINIT[col-error]}[unknown file]${ZINIT[col-rst]}\"\n            (( stray )) && builtin print -n \" ${ZINIT[col-error]}[stray]${ZINIT[col-rst]}\"\n            builtin print\n            command rm -f \"$cpath\"\n        fi\n    done\n} # ]]]\n\n# FUNCTION: .zinit-compile-plugin [[[\n# Compiles given plugin (its main source file, and also an\n# additional \"....zsh\" file if it exists).\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-compile-plugin () {\n    emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes\n    local id_as=$1${2:+${${${(M)1:#%}:+$2}:-/$2}} first plugin_dir filename is_snippet\n    local -a list\n    local -A ICE\n    .zinit-compute-ice \"$id_as\" \"pack\" ICE plugin_dir filename is_snippet || return 1\n    if [[ ${ICE[from]} = gh-r ]] && (( ${+ICE[compile]} == 0 )); then\n        +zi-log \"{dbg} $0: ${id_as} has from'gh-r', skip compile\"\n        return 0\n    fi\n    __compile_header () {\n        (( $#quiet )) || +zi-log \"{i} {b}${1}{rst}\"\n    }\n    if [[ -n \"${ICE[compile]}\" ]]; then\n        local -aU pats list=()\n        pats=(${(s.;.)ICE[compile]})\n        local pat\n        __compile_header \"${id_as}\"\n        for pat in $pats; do\n            list+=(\"${plugin_dir:A}/\"${~pat}(.N))\n        done\n        +zi-log \"{dbg} $0: pattern {glob}${pats}{rst} found ${(pj;, ;)list[@]:t}\"\n        if [[ ${#list} -eq 0 ]]; then\n            +zi-log \"{w} {ice}compile{apo}''{rst} didn't match any files\"\n        else\n            +zi-log -n \"{m} Compiling {num}${#list}{rst} file${=${list:#1}:+s} ${(pj;, ;)list[@]:t}\"\n            integer retval\n            for first in $list; do\n                () {\n                    builtin zcompile -Uz -- \"${first}\"\n                    retval+=$?\n                }\n            done\n            builtin print -rl -- ${list[@]#$plugin_dir/} >| ${TMPDIR:-/tmp}/zinit.compiled.$$.lst\n            if (( !retval )); then\n                +zi-log \" [{happy}OK{rst}]\"\n            else\n                +zi-log \" (exit code: {ehi}$retval{rst})\"\n            fi\n        fi\n        return\n    fi\n    if [[ ${ICE[pick]} != /dev/null && ${ICE[as]} != null && ${+ICE[null]} -eq 0 && ${ICE[as]} != command && ${+ICE[binary]} -eq 0 && ( ${+ICE[nocompile]} = 0 || ${ICE[nocompile]} = \\! ) ]]; then\n        __compile_header \"${id_as}\"\n        reply=()\n        if [[ -n ${ICE[pick]} ]]; then\n            list=(${~${(M)ICE[pick]:#/*}:-$plugin_dir/$ICE[pick]}(DN))\n            if [[ ${#list} -eq 0 ]]; then\n                +zi-log \"{w} No files for compilation found (pick-ice didn't match)\"\n                return 1\n            fi\n            reply=(\"${list[1]:h}\" \"${list[1]}\")\n        else\n            if (( is_snippet )); then\n                if [[ -f $plugin_dir/$filename ]]; then\n                    reply=(\"$plugin_dir\" $plugin_dir/$filename)\n                elif { ! .zinit-first % \"$plugin_dir\" }; then\n                    +zi-log \"{m} No files for compilation found\"\n                    return 1\n                fi\n            else\n                .zinit-first \"$1\" \"$2\" || {\n                    +zi-log \"{m} No files for compilation found\"\n                    return 1\n                }\n            fi\n        fi\n        local pdir_path=${reply[-2]}\n        first=${reply[-1]}\n        local fname=${first#$pdir_path/}\n        +zi-log -n \"{m} Compiling {file}${fname}{rst}\"\n        if [[ -z ${ICE[(i)(\\!|)(sh|bash|ksh|csh)]} ]]; then\n            () {\n                builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n                if { ! zcompile -Uz \"$first\" }; then\n                    +zi-log \"{msg2}Warning:{rst} Compilation failed. Don't worry, the plugin will work also without compilation.\"\n                    +zi-log \"{msg2}Warning:{rst} Consider submitting an error report to Zinit or to the plugin's author.\"\n                else\n                    +zi-log \" [{happy}OK{rst}]\"\n                fi\n                zcompile -U \"${${first%.plugin.zsh}%.zsh-theme}.zsh\" 2> /dev/null\n            }\n        fi\n    fi\n    return 0\n} # ]]]\n# FUNCTION: .zinit-compile-uncompile-all [[[\n# Compiles or uncompiles all existing (on disk) plugins.\n#\n# User-action entry point.\n.zinit-compile-uncompile-all () {\n    emulate -L zsh\n    setopt extendedglob null_glob typeset_silent\n    local compile=\"$1\"\n    +zi-log \"{dbg} ${compile} all\"\n    condition () {\n        if [[ -e \"${REPLY:h}\"/id-as ]]; then\n            reply+=(\"$(cat \"${REPLY:h}/id-as\")\")\n        else\n            reply+=(\"$(cat \"${REPLY:A}\")\")\n        fi\n    }\n    local -aU plugins=(\"$ZINIT_REGISTERED_PLUGINS[@]\")\n    plugins+=(${ZINIT[PLUGINS_DIR]}/*/\\._zinit/teleid(on+condition))\n    local p user plugin\n    for p in \"${plugins[@]}\"; do\n        [[ \"${p:t}\" = \"custom\" || \"${p}\" = \"_local/zinit\" ]] && continue\n        .zinit-any-to-user-plugin \"${p}\"\n        user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n        if [[ -n ${user} ]]; then\n            .zinit-${compile}-plugin \"$user\" \"$plugin\"\n        else\n            .zinit-${compile}-plugin \"$plugin\"\n        fi\n    done\n} # ]]]\n# FUNCTION: .zinit-compiled [[[\n# Displays list of plugins that are compiled.\n#\n# User-action entry point.\n.zinit-compiled () {\n    builtin setopt localoptions nullglob\n    typeset -a matches m\n    matches=(${ZINIT[PLUGINS_DIR]}/*/*.zwc(DN))\n    if [[ \"${#matches[@]}\" -eq \"0\" ]]; then\n        builtin print \"No compiled plugins\"\n        return 0\n    fi\n    local cur_plugin=\"\" uspl1 file user plugin\n    for m in \"${matches[@]}\"; do\n        file=\"${m:t}\"\n        uspl1=\"${${m:h}:t}\"\n        .zinit-any-to-user-plugin \"$uspl1\"\n        user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n        if [[ \"$cur_plugin\" != \"$uspl1\" ]]; then\n            [[ -n \"$cur_plugin\" ]] && builtin print\n            .zinit-any-colorify-as-uspl2 \"$user\" \"$plugin\"\n            builtin print -r -- \"$REPLY:\"\n            cur_plugin=\"$uspl1\"\n        fi\n        builtin print \"$file\"\n    done\n} # ]]]\n# FUNCTION: .zinit-uncompile-plugin [[[\n# Uncompiles given plugin.\n#\n# User-action entry point.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-uncompile-plugin () {\n    emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extended_glob no_short_loops rc_quotes warn_create_global\n    local id_as=$1${2:+${${${(M)1:#%}:+$2}:-/$2}} filename first is_snippet m plugin_dir\n    local -a list\n    local -A ICE\n    .zinit-compute-ice \"$id_as\" \"pack\" ICE plugin_dir filename is_snippet || return 1\n    if [[ ${ICE[from]} = gh-r ]] && (( ${+ICE[compile]} == 0 )); then\n        +zi-log \"{dbg} $0: ${id_as} has from'gh-r', skip compile\"\n        return 0\n    fi\n    if [[ -n ${plugin_dir}/*.zwc(#qN) ]]; then\n        if (( $#quiet )); then\n            +zi-log -n \"{m} Uncompiling {b}${id_as}{rst}\"\n        else\n            +zi-log \"{i} {file}${id_as}{rst}\"\n        fi\n        integer retval\n        (( !$#quiet )) && +zi-log -n \"{m} Removing: \"\n        for m in ${plugin_dir}/*.zwc(.N); do\n            command rm -f \"${m:A}\"\n            retval+=$?\n            (( !$#quiet )) && +zi-log -n \"{file}${m:t}{rst} \"\n        done\n        if (( retval )); then\n            +zi-log \" [exit code: {ehi}$retval{rst}]\"\n        else\n            +zi-log \" [{happy}OK{rst}]\"\n        fi\n    fi\n} # ]]]\n\n# FUNCTION: .zinit-confirm [[[\n# Prints given question, waits for \"y\" key, evals\n# given expression if \"y\" obtained\n#\n# $1 - question\n# $2 - expression\n.zinit-confirm() {\n    integer retval\n    if (( OPTS[opt_-y,--yes] )); then\n        builtin eval \"${2}\"; retval=$?\n        (( OPTS[opt_-q,--quiet] )) || +zi-log -lrP \"{m} Action executed (exit code: {num}${retval}{rst})\"\n    else\n      local choice prompt\n      builtin print -D -v prompt \"$(+zi-log '{i} Press [{opt}Y{rst}/{opt}y{rst}] to continue: {nl}')\"\n      +zi-log \"${1}\"\n      if builtin read -qs \"choice?${prompt}\"; then\n        builtin eval \"${2}\"; retval=$?\n        +zi-log \"{m} Action executed (exit code: {num}${retval}{rst})\"\n        return 0\n      else\n        +zi-log \"{m} No action executed ('{opt}${choice}{rst}' not 'Y' or 'y')\"\n        return 1\n      fi\n    fi\n} # ]]]\n# FUNCTION: .zinit-create [[[\n# Creates a plugin, also on Github (if not \"_local/name\" plugin).\n#\n# User-action entry point.\n#\n# $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - (optional) plugin (only when $1 - i.e. user - given)\n.zinit-create() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt localoptions extendedglob noshortloops rcquotes typesetsilent warncreateglobal\n\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n\n    if (( ${+commands[curl]} == 0 || ${+commands[git]} == 0 )); then\n        builtin print \"${ZINIT[col-error]}curl and git are needed${ZINIT[col-rst]}\"\n        return 1\n    fi\n\n    # Read whether to create under organization\n    local isorg\n    vared -cp 'Create under an organization? (y/n): ' isorg\n\n    if [[ $isorg = (y|yes) ]]; then\n        local org=\"$user\"\n        vared -cp \"Github organization name: \" org\n    fi\n\n    # Read user\n    local compcontext=\"user:User Name:(\\\"$USER\\\" \\\"$user\\\")\"\n    vared -cp \"Github user name or just \\\"_local\\\" (or leave blank, for an userless plugin): \" user\n\n    # Read plugin\n    unset compcontext\n    vared -cp 'Plugin name: ' plugin\n\n    if [[ \"$plugin\" = \"_unknown\" ]]; then\n        builtin print \"${ZINIT[col-error]}No plugin name entered${ZINIT[col-rst]}\"\n        return 1\n    fi\n\n    plugin=\"${plugin//[^a-zA-Z0-9_]##/-}\"\n    .zinit-any-colorify-as-uspl2 \"${${${(M)isorg:#(y|yes)}:+$org}:-$user}\" \"$plugin\"\n    local uspl2col=\"$REPLY\"\n    builtin print \"Plugin is $uspl2col\"\n\n    if .zinit-exists-physically \"${${${(M)isorg:#(y|yes)}:+$org}:-$user}\" \"$plugin\"; then\n        builtin print \"${ZINIT[col-error]}Repository${ZINIT[col-rst]} $uspl2col ${ZINIT[col-error]}already exists locally${ZINIT[col-rst]}\"\n        return 1\n    fi\n\n    builtin cd -q \"${ZINIT[PLUGINS_DIR]}\"\n\n    if [[ \"$user\" != \"_local\" && -n \"$user\" ]]; then\n        builtin print \"${ZINIT[col-info]}Creating Github repository${ZINIT[col-rst]}\"\n        if [[ $isorg = (y|yes) ]]; then\n            curl --silent -u \"$user\" https://api.github.com/orgs/$org/repos -d '{\"name\":\"'\"$plugin\"'\"}' >/dev/null\n        else\n            curl --silent -u \"$user\" https://api.github.com/user/repos -d '{\"name\":\"'\"$plugin\"'\"}' >/dev/null\n        fi\n        command git clone \"https://github.com/${${${(M)isorg:#(y|yes)}:+$org}:-$user}/${plugin}.git\" \"${${${(M)isorg:#(y|yes)}:+$org}:-$user}---${plugin//\\//---}\" || {\n            builtin print \"${ZINIT[col-error]}Creation of remote repository $uspl2col ${ZINIT[col-error]}failed${ZINIT[col-rst]}\"\n            builtin print \"${ZINIT[col-error]}Bad credentials?${ZINIT[col-rst]}\"\n            return 1\n        }\n        builtin cd -q \"${${${(M)isorg:#(y|yes)}:+$org}:-$user}---${plugin//\\//---}\"\n        command git config credential.https://github.com.username \"${user}\"\n    else\n        builtin print \"${ZINIT[col-info]}Creating local git repository${${user:+.}:-, ${ZINIT[col-pname]}free-style, without the \\\"_local/\\\" part${ZINIT[col-info]}.}${ZINIT[col-rst]}\"\n        command mkdir \"${user:+${user}---}${plugin//\\//---}\"\n        builtin cd -q \"${user:+${user}---}${plugin//\\//---}\"\n        command git init || {\n            builtin print \"Git repository initialization failed, aborting\"\n            return 1\n        }\n    fi\n\n    local user_name=\"$(command git config user.name 2>/dev/null)\"\n    local year=\"${$(command date \"+%Y\"):-2020}\"\n\n    command cat >! \"${plugin:t}.plugin.zsh\" <<EOF\n# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-\n\n# Copyright (c) $year $user_name\n\n# According to the Zsh Plugin Standard:\n# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html\n\n0=\\${\\${ZERO:-\\${0:#\\$ZSH_ARGZERO}}:-\\${(%):-%N}}\n0=\\${\\${(M)0:#/*}:-\\$PWD/\\$0}\n\n# Then \\${0:h} to get plugin's directory\n\nif [[ \\${zsh_loaded_plugins[-1]} != */${plugin:t} && -z \\${fpath[(r)\\${0:h}]} ]] {\n    fpath+=( \"\\${0:h}\" )\n}\n\n# Standard hash for plugins, to not pollute the namespace\ntypeset -gA Plugins\nPlugins[${${(U)plugin:t}//-/_}_DIR]=\"\\${0:h}\"\n\nautoload -Uz template-script\n\n# Use alternate vim marks [[[ and ]]] as the original ones can\n# confuse nested substitutions, e.g.: \\${\\${\\${VAR}}}\n\n# vim:ft=zsh:tw=80:sw=4:sts=4:et:foldmarker=[[[,]]]\nEOF\n\n    builtin print -r -- \"# $plugin\" >! \"README.md\"\n    command cp -vf \"${ZINIT[BIN_DIR]}/LICENSE\" LICENSE\n    command cp -vf \"${ZINIT[BIN_DIR]}/share/template-plugin/zsh.gitignore\" .gitignore\n    command cp -vf \"${ZINIT[BIN_DIR]}/share/template-plugin/template-script\" .\n\n    command sed -i -e \"s/MY_PLUGIN_DIR/${${(U)plugin:t}//-/_}_DIR/g\" template-script\n    command sed -i -e \"s/USER_NAME/$user_name/g\" template-script\n    command sed -i -e \"s/YEAR/$year/g\" template-script\n\n    if [[ \"$user\" != \"_local\" && -n \"$user\" ]]; then\n        builtin print \"Your repository is ready\\!\"\n        builtin print \"An MIT LICENSE file has been placed - please review the \" \\\n                      \"license terms to see if they fit your new project:\"\n        builtin print \"- https://choosealicense.com/\"\n        builtin print \"Remote repository $uspl2col set up as origin.\"\n        builtin print \"You're in plugin's local folder, the files aren't added to git.\"\n        builtin print \"Your next step after commiting will be:\"\n        builtin print \"git push -u origin master (or \\`… -u origin main')\"\n    else\n        builtin print \"Created local $uspl2col plugin.\"\n        builtin print \"You're in plugin's repository folder, the files aren't added to git.\"\n    fi\n} # ]]]\n\n# FUNCTION: .zinit-delete [[[\n# Deletes a plugin or snippet and related files and hooks\n#\n# $1 - snippet url or plugin\n.zinit-delete () {\n    emulate -LR zsh\n    setopt extended_glob no_ksh_arrays no_ksh_glob typeset_silent warn_create_global\n    +zi-log \"{dbg} $0: ${(qqS)@}\"\n    local o_all o_clean o_debug o_help o_quiet o_yes rc\n    local -a usage=(\n        'Usage:'\n        '  zinit delete [options] [plugins...]'\n        ' '\n        'Options:'\n        '  -a, --all      Delete all installed plugins, snippets, and completions'\n        '  -c, --clean    Delete unloaded plugins and snippets'\n        '  -d, --debug    Enable debug mode'\n        '  -h, --help     Show list of command-line options'\n        '  -q, --quiet    Make some output more quiet'\n        '  -y, --yes      Don´t prompt for user confirmation'\n    )\n    zmodload zsh/zutil\n    zparseopts -D -E -F -K -- \\\n        {a,-all}=o_all \\\n        {c,-clean}=o_clean \\\n        {d,-debug}=o_debug \\\n        {h,-help}=o_help \\\n        {q,-quiet}=o_quiet \\\n        {y,-yes}=o_yes \\\n    || return 1\n    (( $#o_help )) && {\n        print -l -- ${usage}\n        return 0\n    }\n    (( $#o_debug )) && {\n        setopt xtrace\n    }\n    (( $#o_clean && $#o_all )) && {\n        +zi-log \"{e} Invalid usage: Options --all and --clean are mutually exclusive\"\n        return 1\n    }\n    (( $#o_clean )) && {\n        local -a unld_plgns\n        local -aU ld_snips unld_snips del_list\n        local snip plugin _retval dir=${${ZINIT[SNIPPETS_DIR]%%[/[:space:]]##}:-${TMPDIR:-${TMPDIR:-/tmp}}/xyzcba231}\n        unld_snips=($dir/*/*/*(ND/) $dir/*/*(ND/) $dir/*(ND/))\n        ld_snips=(${${ZINIT_SNIPPETS[@]% <*>}/(#m)*/$(.zinit-get-object-path snippet \"$MATCH\" && builtin print -rn -- $REPLY; )})\n        del_list=(${unld_snips[@]:#*/(${(~j:|:)ld_snips}|*/plugins|._backup|._zinit|.svn|.git)(|/*)})\n        del_list=(${del_list[@]//(#m)*/$( .zinit-get-object-path snippet \"${${${MATCH##${dir}[/[:space:]]#}/(#i)(#b)(http(s|)|ftp(s|)|ssh|rsync)--/${match[1]##--}://}//--//}\" && builtin print -r -- $REPLY)})\n        del_list=(${del_list[@]:#(${(~j:|:)ld_snips}|*/plugins|*/._backup|*/._zinit|*/.svn|*/.git)(|/*)})\n        unld_snips=(${${${(@)${(@)del_list##$dir/#}//(#i)(#m)(http(s|)|ftp(s|)|ssh|rsync)--/${MATCH%--}://}//--//}//(#b)(*)\\/([^\\/]##)(#e)/$match[1]/$ZINIT[col-file]$match[2]$ZINIT[col-rst]})\n        unld_snips=(${unld_snips[@]//(#m)(#s)[^\\/]##(#e)/$ZINIT[col-file]$MATCH$ZINIT[col-rst]})\n        unld_snips+=($(builtin print -- \"${ZINIT[HOME_DIR]}\"/snippets/*(/N^F:t)))\n        del_list=(${${${(@)${(@)del_list##$dir/#}//(#i)(#m)(http(s|)|ftp(s|)|ssh|rsync)--/${MATCH%--}://}//--//}//(#b)(*)\\/([^\\/]##)(#e)/$match[1]/$match[2]})\n        unld_plgns=(${${ZINIT[PLUGINS_DIR]%%[/[:space:]]##}:-${TMPDIR:-${TMPDIR:-/tmp}}/abcEFG312}/*~*/(${(~j:|:)${ZINIT_REGISTERED_PLUGINS[@]//\\//---}})(ND/))\n        unld_plgns=(${(@)${unld_plgns[@]##$ZINIT[PLUGINS_DIR]/#}//---//})\n        (( $#del_list || $#unld_plgns || $#unld_snips )) && {\n            (( $#unld_snips )) && +zi-log \"{m} Deleting {num}${#unld_snips}{rst} unloaded snippets:\" $unld_snips\n            (( $#unld_plgns )) && +zi-log \"{m} Deleting {num}${#unld_plgns}{rst} unloaded plugins:\" $unld_plgns\n            if (( $#o_yes )) || ( .zinit-prompt \"Delete ${#unld_snips} snippets and ${#unld_plgns} plugins?\" ); then\n                for snip in $del_list $unld_plgns $unld_snips; do\n                    zinit delete --yes \"$snip\"\n                    _retval+=$?\n                done\n                return _retval\n            else\n                return 0\n            fi\n        } || {\n            +zi-log \"{m} No unloaded plugins or snippets to delete\"\n            return 0\n        }\n    }\n    local i\n    if (( $#o_all && !$#o_clean )); then\n        condition () {\n            if [[ -e \"${REPLY:h}\"/id-as ]]; then\n                reply+=(\"$(cat \"${REPLY:h}/id-as\")\")\n            else\n                reply+=(\"$(cat \"${REPLY:A}\")\")\n            fi\n        }\n        local -a all_installed=(\"${ZINIT[HOME_DIR]}\"/{'plugins','snippets'}/**/\\._zinit/teleid(N+condition))\n        if (( $#o_yes )) || ( .zinit-prompt \"Delete all plugins and snippets ($#all_installed total)\" ); then\n            for i in ${all_installed[@]}; do\n                zinit delete --yes \"${i}\"\n            done\n            rc=$?\n            command rm -d -f -v \"${ZINIT[HOME_DIR]}\"/**/*(-@N) \"${ZINIT[HOME_DIR]}\"/{'plugins','snippets'}/*(N/^F)\n            local f\n            for f in ${(k)ZINIT[(I)STATES__*~*local/zinit]}; do\n                builtin unset \"ZINIT[${f}]\"\n            done\n            +zi-log \"{m} Delete completed with return code {num}${rc}{rst}\"\n            return $rc\n        fi\n        return 1\n    fi\n    (( !$# )) && {\n        +zi-log \"{e} Invalid usage: This command requires at least 1 plugin or snippet argument.\"\n        return 0\n    }\n    if (( $#o_yes )) || ( .zinit-prompt \"Delete ${(j:, :)@}\" ); then\n        for i in \"${@}\"; do\n            local -A ICE=() ICE2=()\n            local the_id=\"${${i:#(%|/)*}}\" filename is_snippet local_dir\n            .zinit-compute-ice \"$the_id\" \"pack\" ICE2 local_dir filename is_snippet || return 1\n            if [[ \"$local_dir\" != /* ]]; then\n                +zi-log \"{w} No available plugin or snippet with the name '{b}$i{rst}'\"\n                return 1\n            fi\n            ICE2[teleid]=\"${ICE2[teleid]:-${ICE2[id-as]}}\"\n            local -a files\n            files=(\"$local_dir\"/*(%DN:t) \"$local_dir\"/*(*DN:t) \"$local_dir\"/*(.DN:t) \"$local_dir\"/*(=DN:t) \"$local_dir\"/*(@DN:t) \"$local_dir\"/*(pDN:t) \"$local_dir\"/*.(zsh|sh|bash|ksh)(DN:t) \"$local_dir\"/*~*/.(_zinit|svn|git)(/DN:t))\n            (( !${#files} )) && files=(\"no files?\")\n            files=(${(@)files[1,4]} ${files[4]+more…})\n            ICE=(\"${(kv)ICE2[@]}\")\n            if [[ -e $local_dir ]]; then\n                (( is_snippet )) && {\n                    .zinit-run-delete-hooks snippet \"${ICE2[teleid]}\" \"\" \"$the_id\" \"$local_dir\"\n                } || {\n                    .zinit-any-to-user-plugin \"${ICE2[teleid]}\"\n                    .zinit-run-delete-hooks plugin \"${reply[-2]}\" \"${reply[-1]}\" \"$the_id\" \"$local_dir\"\n                }\n                command rm -d -f -r \"${ZINIT[HOME_DIR]}\"/**/*(-@N) \"${ZINIT[HOME_DIR]}\"/{'plugins','snippets'}/*(N/^F) ${(q)${${local_dir:#[/[:space:]]##}:-${TMPDIR:-${TMPDIR:-/tmp}}/abcYZX321}}(N)\n                builtin unset \"ZINIT[STATES__${i}]\" || builtin unset \"ZINIT[STATES__${ICE2[teleid]}]\"\n                (( $#o_quiet )) || +zi-log \"{m} Uninstalled {b}$i{rst}\"\n            else\n                +zi-log \"{w} No available plugin or snippet with the name '{b}$i{rst}'\"\n                return 1\n            fi\n        done\n    fi\n    return 0\n} # ]]]\n# FUNCTION: .zinit-edit [[[\n# Runs $EDITOR on source of given plugin. If the variable is not\n# set then defaults to `vim'.\n#\n# User-action entry point.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-edit() {\n    local -A ICE2\n    local local_dir filename is_snippet the_id=\"$1${${1:#(%|/)*}:+${2:+/}}$2\"\n\n    .zinit-compute-ice \"$the_id\" \"pack\" \\\n        ICE2 local_dir filename is_snippet || return 1\n\n    ICE2[teleid]=\"${ICE2[teleid]:-${ICE2[id-as]}}\"\n\n    if (( is_snippet )); then\n        if [[ ! -e \"$local_dir\" ]]; then\n            builtin print \"No such snippet\"\n            return 1\n        fi\n    else\n        if [[ ! -e \"$local_dir\" ]]; then\n            builtin print -r -- \"No such plugin or snippet\"\n            return 1\n        fi\n    fi\n\n    \"${EDITOR:-vim}\" \"$local_dir\"\n    return 0\n} # ]]]\n# FUNCTION: .zinit-get-path [[[\n# Returns path of given ID-string, which may be a plugin-spec\n# (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path\n# (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin\n# nickname (i.e. id-as'' ice-mod), or a snippet nickname.\n.zinit-get-path() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops\n\n    [[ $1 == % ]] && local id_as=%$2 || local id_as=$1${1:+/}$2\n    .zinit-get-object-path snippet \"$id_as\" || \\\n        .zinit-get-object-path plugin \"$id_as\"\n\n    return $(( 1 - reply[3] ))\n} # ]]]\n# FUNCTION: .zinit-glance [[[\n# Shows colorized source code of plugin. Is able to use pygmentize,\n# highlight, GNU source-highlight.\n#\n# User-action entry point.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-glance() {\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n\n    .zinit-exists-physically-message \"$user\" \"$plugin\" || return 1\n\n    .zinit-first \"$1\" \"$2\" || {\n       +zi-log '{log-err} No source file found, cannot glance'\n        return 1\n    }\n\n    local fname=\"${reply[-1]}\"\n\n    integer has_256_colors=0\n    [[ \"$TERM\" = xterm* || \"$TERM\" = \"screen\" ]] && has_256_colors=1\n\n    {\n        if (( ${+commands[pygmentize]} )); then\n            +zi-log \"{log-info} Inspecting via {cmd}pygmentize{rst}\"\n            pygmentize -l 'bash' \"$fname\"\n        elif (( ${+commands[highlight]} )); then\n            +zi-log \"{log-info} Inspecting via {cmd}highlight{rst}\"\n            if (( has_256_colors )); then\n                highlight --force --output-format xterm256 --quiet --syntax sh \"$fname\"\n            else\n                highlight --force --output-format ansi --quiet --syntax sh \"$fname\"\n            fi\n        elif (( ${+commands[source-highlight]} )); then\n            +zi-log \"{log-info} Inspecting via {cmd}source-highlight{rst}\"\n            source-highlight -fesc --failsafe -s zsh -o STDOUT -i \"$fname\"\n        else\n            cat \"$fname\"\n        fi\n    } | {\n        if [[ -t 1 ]]; then\n            .zinit-pager\n        else\n            cat\n        fi\n    }\n} # ]]]\n# FUNCTION: .zinit-help [[[\n# Shows usage information.\n#\n# User-action entry point.\n.zinit-help() {\n           builtin print -r -- \"${ZINIT[col-p]}Usage${ZINIT[col-rst]}:\n—— help                          – usage information\n—— bindkeys                      – lists bindkeys set up by each plugin\n—— cd ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}                   – cd into plugin's directory; also support snippets, if feed with URL\n—— cdclear [-q]                  – clear compdef replay list, -q – quiet\n—— cdisable ${ZINIT[col-info]}cname${ZINIT[col-rst]}                – disable completion \\`cname'\n—— cdlist                        – show compdef replay list\n—— cdreplay [-q]                 – replay compdefs (to be done after compinit), -q – quiet\n—— cenable ${ZINIT[col-info]}cname${ZINIT[col-rst]}                 – enable completion \\`cname'\n—— changes ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}              – view plugin's git log\n—— completions                   – list installed completions\n—— compile ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}              – compile plugin (or all plugins if ——all passed)\n—— compiled                      – list plugins that are compiled\n—— compinit                      – refresh installed completions\n—— create ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}               – create plugin (also together with Github repository)\n—— creinstall ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}           – install completions for plugin, can also receive absolute local path; -q – quiet\n—— csearch                       – search for available completions from any plugin\n—— cuninstall ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}           – uninstall completions for plugin\n—— debug                         – manage debug mode\n—— delete                        – delete a plugin or snippet\n—— edit ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}                 – edit plugin's file with \\$EDITOR\n—— env-whitelist [-v|-h] {env..} – allows to specify names (also patterns) of variables left unchanged during an unload. -v – verbose\n—— glance ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}               – look at plugin's source (pygmentize, {,source-}highlight)\n—— ice <ice specification>       – add ICE to next command, argument is e.g. from\\\"gitlab\\\"\n—— light [-b] ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}           – light plugin load, without reporting/tracking (-b – do track but bindkey-calls only)\n—— load ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}                 – load plugin, can also receive absolute local path\n—— loaded|list {keyword}         – show what plugins are loaded (filter with \\'keyword')\n—— ls                            – list snippets in formatted and colorized manner\n—— man                           – manual\n—— module                        – manage binary Zsh module shipped with Zinit, see \\`zinit module help'\n—— recall ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}|URL           – fetch saved ice modifiers and construct \\`zinit ice ...' command\n—— recently ${ZINIT[col-info]}[time-spec]${ZINIT[col-rst]}          – show plugins that changed recently, argument is e.g. 1 month 2 days\n—— report ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}               – show plugin's report (or all plugins' if ——all passed)\n—— self-update                   – updates and compiles Zinit\n—— snippet [-f] ${ZINIT[col-pname]}{url}${ZINIT[col-rst]}            – source local or remote file (by direct URL), -f: force – don't use cache\n—— srv {service-id} [cmd]        – control a service, command can be: stop,start,restart,next,quit; \\`next' moves the service to another Zshell\n—— status ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}|URL           – Git status for plugin or svn status for snippet (or for all those if ——all passed)\n—— stress ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}               – test plugin for compatibility with set of options\n—— times [-s] [-m] [-a] – statistics on plugin load times, sorted in order of loading; -s – use seconds instead of milliseconds, -m – show plugin loading moments, -a – show both load times and loading moments\n—— uncompile ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}            – remove compiled version of plugin (or of all plugins if ——all passed)\n—— unload ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}               – unload plugin loaded with \\`zinit load ...', -q – quiet\n—— update [-q] ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]}|URL      – Git update plugin or snippet (or all plugins and snippets if ——all passed); besides -q accepts also ——quiet, and also -r/--reset – this option causes to run git reset --hard / svn revert before pulling changes\n—— version                       – display zinit version\n—— zstatus                       – overall Zinit statu\n—— add-fpath|fpath ${ZINIT[col-info]}[-f|--front]${ZINIT[col-rst]} \\\\\n    ${ZINIT[col-pname]}plg-spec ${ZINIT[col-info]}[subdirectory]${ZINIT[col-rst]}      – adds given plugin directory to \\$fpath; if the second argument is given, it is appended to the directory path; if the option -f/--front is given, the directory path is prepended instead of appended to \\$fpath. The ${ZINIT[col-pname]}plg-spec${ZINIT[col-rst]} can be absolute path\n—— run [-l] [plugin] {command}   – runs the given command in the given plugin's directory; if the option -l will be given then the plugin should be skipped – the option will cause the previous plugin to be reused\"\n\n    integer idx\n    local type key\n    local -a arr\n    for type in subcommand hook; do\n        for (( idx=1; idx <= ZINIT_EXTS[seqno]; ++ idx )); do\n            key=\"${(k)ZINIT_EXTS[(r)$idx *]}\"\n            [[ -z \"$key\" || \"$key\" != \"z-annex $type:\"* ]] && continue\n            arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]}[@]}\" )\n            (( ${+functions[${arr[6]}]} )) && { \"${arr[6]}\"; ((1)); } || \\\n                { builtin print -rl -- \"(Couldn't find the help-handler \\`${arr[6]}' of the z-annex \\`${arr[3]}')\"; }\n        done\n    done\n\nlocal -a ice_order\nice_order=( ${${(s.|.)ZINIT[ice-list]}:#teleid} ${(@)${(@)${(@Akons:|:u)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}:#(.*|dynamic-unscope)} )\nprint -- \"\\nAvailable ice-modifiers:\\n\\n${ice_order[*]}\"\n} # ]]]\n\n# FUNCTION: .zinit-list-bindkeys [[[\n.zinit-list-bindkeys() {\n    local uspl2 uspl2col sw first=1\n    local -a string_widget\n\n    # KSH_ARRAYS immunity\n    integer correct=0\n    [[ -o \"KSH_ARRAYS\" ]] && correct=1\n\n    for uspl2 in \"${(@ko)ZINIT[(I)BINDKEYS__*]}\"; do\n        [[ -z \"${ZINIT[$uspl2]}\" ]] && continue\n\n        (( !first )) && builtin print\n        first=0\n\n        uspl2=\"${uspl2#BINDKEYS__}\"\n\n        .zinit-any-colorify-as-uspl2 \"$uspl2\"\n        uspl2col=\"$REPLY\"\n        builtin print \"$uspl2col\"\n\n        string_widget=( \"${(z@)ZINIT[BINDKEYS__$uspl2]}\" )\n        for sw in \"${(Oa)string_widget[@]}\"; do\n            [[ -z \"$sw\" ]] && continue\n            # Remove one level of quoting to split using (z)\n            sw=\"${(Q)sw}\"\n            typeset -a sw_arr\n            sw_arr=( \"${(z@)sw}\" )\n\n            # Remove one level of quoting to pass to bindkey\n            local sw_arr1=\"${(Q)sw_arr[1-correct]}\" # Keys\n            local sw_arr2=\"${(Q)sw_arr[2-correct]}\" # Widget\n            local sw_arr3=\"${(Q)sw_arr[3-correct]}\" # Optional -M or -A or -N\n            local sw_arr4=\"${(Q)sw_arr[4-correct]}\" # Optional map name\n            local sw_arr5=\"${(Q)sw_arr[5-correct]}\" # Optional -R (not with -A, -N)\n\n            if [[ \"$sw_arr3\" = \"-M\" && \"$sw_arr5\" != \"-R\" ]]; then\n                builtin print \"bindkey $sw_arr1 $sw_arr2 ${ZINIT[col-info]}for keymap $sw_arr4${ZINIT[col-rst]}\"\n            elif [[ \"$sw_arr3\" = \"-M\" && \"$sw_arr5\" = \"-R\" ]]; then\n                builtin print \"${ZINIT[col-info]}range${ZINIT[col-rst]} bindkey $sw_arr1 $sw_arr2 ${ZINIT[col-info]}mapped to $sw_arr4${ZINIT[col-rst]}\"\n            elif [[ \"$sw_arr3\" != \"-M\" && \"$sw_arr5\" = \"-R\" ]]; then\n                builtin print \"${ZINIT[col-info]}range${ZINIT[col-rst]} bindkey $sw_arr1 $sw_arr2\"\n            elif [[ \"$sw_arr3\" = \"-A\" ]]; then\n                builtin print \"Override of keymap \\`main'\"\n            elif [[ \"$sw_arr3\" = \"-N\" ]]; then\n                builtin print \"New keymap \\`$sw_arr4'\"\n            else\n                builtin print \"bindkey $sw_arr1 $sw_arr2\"\n            fi\n        done\n    done\n} # ]]]\n# FUNCTION: .zinit-list-compdef-replay [[[\n# Shows recorded compdefs (called by plugins loaded earlier).\n# Plugins often call `compdef' hoping for `compinit' being\n# already ran. Zinit solves this by recording compdefs.\n#\n# User-action entry point.\n.zinit-list-compdef-replay() {\n    builtin print \"Recorded compdefs:\"\n    local cdf\n    for cdf in \"${ZINIT_COMPDEF_REPLAY[@]}\"; do\n        builtin print \"compdef ${(Q)cdf}\"\n    done\n} # ]]]\n# FUNCTION: .zinit-list-plugins [[[\n# Lists loaded plugins\n.zinit-list-plugins () {\n    builtin emulate -LR zsh\n    setopt extended_glob warn_create_global typeset_silent no_short_loops\n    typeset -a filtered\n    local keyword=\"${${${1}## ##}%% ##}\"\n    if [[ -n \"$keyword\" ]]; then\n        +zi-log \"{dbg} ${(qqq)1} -> ${(qqq)keyword}{rst}\"\n        filtered=(${${(k)ZINIT[(I)STATES__*${keyword}*~*(local/zinit)*]}//[A-Z]*__/})\n        +zi-log \"{m} ${#filtered} {b}Plugins{rst} matching '{glob}${keyword}{rst}'\"\n    else\n        filtered=(${${(M)${(k)ZINIT[@]}:##STATES__*~*local/zinit*}//[A-Z]*__/})\n        +zi-log \"{m} ${#filtered} {b}Plugins{rst}\"\n    fi\n    local i\n    local -i idx=1\n    for i in \"${(o)filtered[@]}\"; do\n        local is_loaded='{error}U'\n        (( ZINIT[STATES__${i}] )) && is_loaded=\"{happy}L\"\n        +zi-log \"$(print -f \"%2d %s %s\\n\" ${idx} ${is_loaded} {b}${(D)i//[%]/}{rst})\"\n        (( idx+=1 ))\n    done\n    +zi-log -- '{nl}Loaded: {happy}L{rst} | Unloaded: {error}U{rst}'\n} # ]]]\n# FUNCTION: .zinit-list-snippets [[[\n.zinit-list-snippets() {\n    (( ${+commands[tree]} )) || {\n        builtin print \"${ZINIT[col-error]}No \\`tree' program, it is required by the subcommand \\`ls\\'${ZINIT[col-rst]}\"\n        builtin print \"Download from: http://mama.indstate.edu/users/ice/tree/\"\n        builtin print \"It is also available probably in all distributions and Homebrew, as package \\`tree'\"\n    }\n    (\n        setopt localoptions extendedglob nokshglob noksharrays\n        builtin cd -q \"${ZINIT[SNIPPETS_DIR]}\"\n        local -a list\n        local -x LANG=en_US.utf-8\n        list=( \"${(f@)\"$(${=ZINIT[LIST_COMMAND]})\"}\" )\n        # Oh-My-Zsh single file\n        list=( \"${list[@]//(#b)(https--github.com--(ohmyzsh|robbyrussel)l--oh-my-zsh--raw--master(--)(#c0,1)(*))/$ZINIT[col-info]Oh-My-Zsh$ZINIT[col-error]${match[2]/--//}$ZINIT[col-pname]${match[3]//--/$ZINIT[col-error]/$ZINIT[col-pname]} $ZINIT[col-info](single-file)$ZINIT[col-rst] ${match[1]}}\" )\n        # Oh-My-Zsh SVN\n        list=( \"${list[@]//(#b)(https--github.com--(ohmyzsh|robbyrussel)l--oh-my-zsh--trunk(--)(#c0,1)(*))/$ZINIT[col-info]Oh-My-Zsh$ZINIT[col-error]${match[2]/--//}$ZINIT[col-pname]${match[3]//--/$ZINIT[col-error]/$ZINIT[col-pname]} $ZINIT[col-info](SVN)$ZINIT[col-rst] ${match[1]}}\" )\n        # Prezto single file\n        list=( \"${list[@]//(#b)(https--github.com--sorin-ionescu--prezto--raw--master(--)(#c0,1)(*))/$ZINIT[col-info]Prezto$ZINIT[col-error]${match[2]/--//}$ZINIT[col-pname]${match[3]//--/$ZINIT[col-error]/$ZINIT[col-pname]} $ZINIT[col-info](single-file)$ZINIT[col-rst] ${match[1]}}\" )\n        # Prezto SVN\n        list=( \"${list[@]//(#b)(https--github.com--sorin-ionescu--prezto--trunk(--)(#c0,1)(*))/$ZINIT[col-info]Prezto$ZINIT[col-error]${match[2]/--//}$ZINIT[col-pname]${match[3]//--/$ZINIT[col-error]/$ZINIT[col-pname]} $ZINIT[col-info](SVN)$ZINIT[col-rst] ${match[1]}}\" )\n\n        # First-level names\n        list=( \"${list[@]//(#b)(#s)(│   └──|    └──|    ├──|│   ├──) (*)/${match[1]} $ZINIT[col-p]${match[2]}$ZINIT[col-rst]}\" )\n\n        list[-1]+=\", located at ZINIT[SNIPPETS_DIR], i.e. ${ZINIT[SNIPPETS_DIR]}\"\n        builtin print -rl -- \"${list[@]}\"\n    )\n} # ]]]\n\n# FUNCTION: .zinit-prompt [[[\n# Prompt user to confirm\n#\n# $1 - prompt\n#\n# $REPLY - 0 or 1\n.zinit-prompt () {\n    local REPLY\n    read -q ${(%):-\"?%s%F{cyan}==>%f%s ${1}? [y/N]: \"} && REPLY=y\n    print ''\n    [[ $REPLY == y ]] && return 0 || return 1\n} # ]]]\n# FUNCTION: .zinit-recall [[[\n.zinit-recall() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops\n\n    local -A ice\n    local el val cand1 cand2 local_dir filename is_snippet\n\n    local -a ice_order nval_ices output\n    ice_order=(\n        ${(s.|.)ZINIT[ice-list]}\n\n        # Include all additional ices – after\n        # stripping them from the possible: ''\n        ${(@)${(@Akons:|:u)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}\n    )\n    nval_ices=(\n            ${(s.|.)ZINIT[nval-ice-list]}\n            # Include only those additional ices,\n            # don't have the '' in their name, i.e.\n            # aren't designed to hold value\n            ${(@)${(@)${(@Akons:|:u)ZINIT_EXTS[ice-mods]}:#*\\'\\'*}/(#s)<->-/}\n\n            # Must be last\n            svn\n    )\n    .zinit-compute-ice \"$1${${1:#(%|/)*}:+${2:+/}}$2\" \"pack\" \\\n        ice local_dir filename is_snippet || return 1\n\n    [[ -e $local_dir ]] && {\n        for el ( ${ice_order[@]} ) {\n            val=\"${ice[$el]}\"\n            cand1=\"${(qqq)val}\"\n            cand2=\"${(qq)val}\"\n            if [[ -n \"$val\" ]] {\n                [[ \"${cand1/\\\\\\$/}\" != \"$cand1\" || \"${cand1/\\\\\\!/}\" != \"$cand1\" ]] && output+=( \"$el$cand2\" ) || output+=( \"$el$cand1\" )\n            } elif [[ ${+ice[$el]} = 1 && -n \"${nval_ices[(r)$el]}\" ]] {\n                output+=( \"$el\" )\n            }\n        }\n\n        if [[ ${#output} = 0 ]]; then\n            builtin print -zr \"# No Ice modifiers\"\n        else\n            builtin print -zr \"zinit ice ${output[*]}; zinit \"\n        fi\n        +zinit-deploy-message @rst\n    } || builtin print -r -- \"No such plugin or snippet\"\n} # ]]]\n# FUNCTION: .zinit-recently [[[\n# Shows plugins that obtained commits in specified past time.\n#\n# User-action entry point.\n#\n# $1 - time spec, e.g. \"1 week\"\n.zinit-recently() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt nullglob extendedglob warncreateglobal \\\n                typesetsilent noshortloops\n\n    local IFS=.\n    local gitout\n    local timespec=${*// ##/.}\n    timespec=${timespec//.##/.}\n    [[ -z $timespec ]] && timespec=1.week\n\n    typeset -a plugins\n    plugins=( ${ZINIT[PLUGINS_DIR]}/*(DN-/) )\n\n    local p uspl1\n    for p in ${plugins[@]}; do\n        uspl1=${p:t}\n        [[ $uspl1 = custom || $uspl1 = _local---zinit ]] && continue\n\n        pushd \"$p\" >/dev/null || continue\n        if [[ -d .git ]]; then\n            gitout=`command git log --all --max-count=1 --since=$timespec 2>/dev/null`\n            if [[ -n $gitout ]]; then\n                .zinit-any-colorify-as-uspl2 \"$uspl1\"\n                builtin print -r -- \"$REPLY\"\n            fi\n        fi\n        popd >/dev/null\n    done\n} # ]]]\n# FUNCTION: .zinit-run-delete-hooks [[[\n.zinit-run-delete-hooks () {\n    local make_path=$5/Makefile mfest_path=$5/build/install_manifest.txt quiet='2>/dev/null 1>&2'\n    if [[ -f $make_path ]] && grep '^uninstall' $make_path &> /dev/null; then\n        +zi-log -n \"{m} Make uninstall... \"\n        eval 'command make -C ${make_path:h} {prefix,{,CMAKE_INSTALL_}PREFIX}=$ZINIT[ZPFX] --ignore-errors uninstall' 2>/dev/null 1>&2\n        if (( $? == 0 )); then\n            +zi-log \" [{happy}OK{rst}]\"\n        else\n            +zi-log \" [{error}Failed{rst}]\"\n        fi\n    elif [[ -f $mfest_path ]]; then\n        +zi-log -n \"{m} Cmake uninstall... \"\n        if { command cmake --build ${mfest_path:h} --target uninstall || xargs rm -rf < \"$mfest_path\" } &>/dev/null ; then\n            +zi-log \" [{happy}OK{rst}]\"\n        else\n            +zi-log \" [{error}Failed{rst}]\"\n        fi\n    fi\n    eval 'find $ZINIT[ZPFX] -depth -type d -empty -delete' &> /dev/null\n    if [[ -n ${ICE[atdelete]} ]]; then\n        (\n            (( ${+ICE[nocd]} == 0 )) && {\n                builtin cd -q \"$5\" && eval \"${ICE[atdelete]}\"\n                ((1))\n            } || eval \"${ICE[atdelete]}\"\n        )\n    fi\n    local -a arr\n    local key\n    reply=(${(on)ZINIT_EXTS2[(I)zinit hook:atdelete-pre <->]} ${(on)ZINIT_EXTS[(I)z-annex hook:atdelete-<-> <->]} ${(on)ZINIT_EXTS2[(I)zinit hook:atdelete-post <->]})\n    for key in \"${reply[@]}\"; do\n        arr=(\"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\")\n        \"${arr[5]}\" \"$1\" \"$2\" $3 \"$4\" \"$5\" \"${${key##(zinit|z-annex) hook:}%% <->}\" delete:TODO\n    done\n} # ]]]\n# FUNCTION: .zinit-search-completions [[[\n# While .zinit-show-completions() shows what completions are\n# installed, this functions searches through all plugin dirs\n# showing what's available in general (for installation).\n#\n# User-action entry point.\n.zinit-search-completions() {\n    builtin setopt localoptions nullglob extendedglob nokshglob noksharrays\n\n    typeset -a plugin_paths\n    plugin_paths=( \"${ZINIT[PLUGINS_DIR]}\"/*(DN) )\n\n    # Find longest plugin name. Things are ran twice here, first pass\n    # is to get longest name of plugin which is having any completions\n    integer longest=0\n    typeset -a completions\n    local pp\n    for pp in \"${plugin_paths[@]}\"; do\n        completions=( \"$pp\"/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1|*.lua)(DN^/) )\n        if [[ \"${#completions[@]}\" -gt 0 ]]; then\n            local pd=\"${pp:t}\"\n            [[ \"${#pd}\" -gt \"$longest\" ]] && longest=\"${#pd}\"\n        fi\n    done\n\n    builtin print \"${ZINIT[col-info]}[+]${ZINIT[col-rst]} is installed, ${ZINIT[col-p]}[-]${ZINIT[col-rst]} uninstalled, ${ZINIT[col-error]}[+-]${ZINIT[col-rst]} partially installed\"\n\n    local c\n    for pp in \"${plugin_paths[@]}\"; do\n        completions=( \"$pp\"/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1|*.lua)(DN^/) )\n\n        if [[ \"${#completions[@]}\" -gt 0 ]]; then\n            # Array of completions, e.g. ( _cp _xauth )\n            completions=( \"${completions[@]:t}\" )\n\n            # Detect if the completions are installed\n            integer all_installed=\"${#completions[@]}\"\n            for c in \"${completions[@]}\"; do\n                if [[ -e \"${ZINIT[COMPLETIONS_DIR]}/$c\" || -e \"${ZINIT[COMPLETIONS_DIR]}/${c#_}\" ]]; then\n                    (( all_installed -- ))\n                fi\n            done\n\n            if [[ \"$all_installed\" -eq \"${#completions[@]}\" ]]; then\n                builtin print -n \"${ZINIT[col-p]}[-]${ZINIT[col-rst]} \"\n            elif [[ \"$all_installed\" -eq \"0\" ]]; then\n                builtin print -n \"${ZINIT[col-info]}[+]${ZINIT[col-rst]} \"\n            else\n                builtin print -n \"${ZINIT[col-error]}[+-]${ZINIT[col-rst]} \"\n            fi\n\n            # Convert directory name to colorified $user/$plugin\n            .zinit-any-colorify-as-uspl2 \"${pp:t}\"\n\n            # Adjust for escape code (nasty, utilizes fact that\n            # ${ZINIT[col-rst]} is used twice, so as a $ZINIT_COL)\n            integer adjust_ec=$(( ${#ZINIT[col-rst]} * 2 + ${#ZINIT[col-uname]} + ${#ZINIT[col-pname]} ))\n\n            builtin print \"${(r:longest+adjust_ec:: :)REPLY} ${(j:, :)completions}\"\n        fi\n    done\n} # ]]]\n\n# FUNCTION: .zi-check-for-git-changes [[[\n# Check for Git updates\n#\n# $1 - Absolute path to Git repository\"\n.zi-check-for-git-changes() {\n    +zi-log \"{dbg} checking $1\"\n    if command git --work-tree \"$1\" rev-parse --is-inside-work-tree &> /dev/null; then\n        if command git --work-tree \"$1\" rev-parse --abbrev-ref @'{u}' &> /dev/null; then\n            local count=\"$(command git --work-tree \"$1\" rev-list --left-right --count HEAD...@'{u}' 2> /dev/null)\"\n            local down=\"$count[(w)2]\"\n            if [[ $down -gt 0 ]]; then\n                return 0\n            fi\n        fi\n        builtin print -P -- \"Already up-to-date.\"\n        return 1\n    fi\n} # ]]]\n# FUNCTION: .zinit-self-update [[[\n# Updates Zinit code (does a git pull)\n.zinit-self-update() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob typesetsilent warncreateglobal\n\n    if .zi-check-for-git-changes \"$ZINIT[BIN_DIR]\"; then\n        [[ $1 = -q ]] && +zi-log \"{pre}[self-update]{info} updating zinit repository{msg2}\" \\\n\n        local nl=$'\\n' escape=$'\\x1b['\n        local current_branch=$(command git -C $ZINIT[BIN_DIR] rev-parse --abbrev-ref HEAD)\n        # local current_branch='main'\n        local -a lines\n        (\n            builtin cd -q \"$ZINIT[BIN_DIR]\" \\\n            && +zi-log -n \"{pre}[self-update]{info} fetching latest changes from {obj}$current_branch{info} branch$nl{rst}\" \\\n            && command git fetch --quiet \\\n            && lines=( ${(f)\"$(command git log --color --date=short --pretty=format:'%Cgreen%cd %h %Creset%s %Cred%d%Creset || %b' ..origin/HEAD)\"} )\n            if (( ${#lines} > 0 )); then\n                # Remove the (origin/main ...) segments, to expect only tags to appear\n                lines=( \"${(S)lines[@]//\\(([,[:blank:]]#(origin|HEAD|master|main)[^a-zA-Z]##(HEAD|origin|master|main)[,[:blank:]]#)#\\)/}\" )\n                # Remove \" ||\" if it ends the line (i.e. no additional text from the body)\n                lines=( \"${lines[@]/ \\|\\|[[:blank:]]#(#e)/}\" )\n                # If there's no ref-name, 2 consecutive spaces occur - fix this\n                lines=( \"${lines[@]/(#b)[[:space:]]#\\|\\|[[:space:]]#(*)(#e)/|| ${match[1]}}\" )\n                lines=( \"${lines[@]/(#b)$escape([0-9]##)m[[:space:]]##${escape}m/$escape${match[1]}m${escape}m}\" )\n                # Replace what follows \"|| ...\" with the same thing but with no\n                # newlines, and also only first 10 words (the (w)-flag enables\n                # word-indexing)\n                lines=( \"${lines[@]/(#b)[[:blank:]]#\\|\\|(*)(#e)/| ${${match[1]//$nl/ }[(w)1,(w)10]}}\" )\n                builtin print -rl -- \"${lines[@]}\" | .zinit-pager\n                builtin print\n            fi\n            if [[ $1 != -q ]] {\n                command git pull --no-stat --ff-only origin main\n            } else {\n                command git pull --no-stat --quiet --ff-only origin main\n            }\n        )\n        if [[ $1 != -q ]] {\n            +zi-log \"{pre}[self-update]{info} compiling zinit via {obj}zcompile{rst}\"\n        }\n        command rm -f $ZINIT[BIN_DIR]/*.zwc(DN)\n        zcompile -U $ZINIT[BIN_DIR]/zinit.zsh\n        zcompile -U $ZINIT[BIN_DIR]/zinit-{'side','install','autoload','additional'}.zsh\n        zcompile -U $ZINIT[BIN_DIR]/share/git-process-output.zsh\n        # Load for the current session\n        [[ $1 != -q ]] && +zi-log \"{pre}[self-update]{info} reloading zinit for the current session{rst}\"\n\n        # +zi-log \"{pre}[self-update]{info} resetting zinit repository via{rst}: {cmd}${ICE[reset]:-git reset --hard HEAD}{rst}\"\n        source $ZINIT[BIN_DIR]/zinit.zsh\n        zcompile -U $ZINIT[BIN_DIR]/zinit-{'side','install','autoload'}.zsh\n        # Read and remember the new modification timestamps\n        local file\n        for file ( \"\" -side -install -autoload ) {\n            .zinit-get-mtime-into \"${ZINIT[BIN_DIR]}/zinit$file.zsh\" \"ZINIT[mtime$file]\"\n        }\n    fi\n} # ]]]\n\n# FUNCTION: .zinit-show-all-reports [[[\n# Displays reports of all loaded plugins.\n#\n# User-action entry point.\n.zinit-show-all-reports() {\n    local i\n    for i in \"${ZINIT_REGISTERED_PLUGINS[@]}\"; do\n        [[ \"$i\" = \"_local/zinit\" ]] && continue\n        .zinit-show-report \"$i\"\n    done\n} # ]]]\n# FUNCTION: .zinit-show-completions [[[\n# Display installed (enabled and disabled), completions. Detect\n# stray and improper ones.\n#\n# Completions live even when plugin isn't loaded - if they are\n# installed and enabled.\n#\n# User-action entry point.\n.zinit-show-completions() {\n    builtin setopt localoptions nullglob extendedglob nokshglob noksharrays\n    local count=\"${1:-3}\"\n\n    typeset -a completions\n    completions=( \"${ZINIT[COMPLETIONS_DIR]}\"/_[^_.]*~*.zwc \"${ZINIT[COMPLETIONS_DIR]}\"/[^_.]*~*.zwc )\n\n    local cpath c o s group\n\n    # Prepare readlink command for establishing\n    # completion's owner\n    .zinit-prepare-readlink\n    local rdlink=\"$REPLY\"\n\n    float flmax=${#completions} flcur=0\n    typeset -F1 flper\n\n    local -A owner_to_group\n    local -a packs splitted\n\n    integer disabled unknown stray\n    for cpath in \"${completions[@]}\"; do\n        c=\"${cpath:t}\"\n        [[ \"${c#_}\" = \"${c}\" ]] && disabled=1 || disabled=0\n        c=\"${c#_}\"\n\n        # This will resolve completion's symlink to obtain\n        # information about the repository it comes from, i.e.\n        # about user and plugin, taken from directory name\n        .zinit-get-completion-owner \"$cpath\" \"$rdlink\"\n        [[ \"$REPLY\" = \"[unknown]\" ]] && unknown=1 || unknown=0\n        o=\"$REPLY\"\n\n        # If we successfully read a symlink (unknown == 0), test if it isn't broken\n        stray=0\n        if (( unknown == 0 )); then\n            [[ ! -f \"$cpath\" ]] && stray=1\n        fi\n\n        s=$(( 1*disabled + 2*unknown + 4*stray ))\n\n        owner_to_group[${o}--$s]+=\"$c;\"\n        group=\"${owner_to_group[${o}--$s]%;}\"\n        splitted=( \"${(s:;:)group}\" )\n\n        if [[ \"${#splitted}\" -ge \"$count\" ]]; then\n            packs+=( \"${(q)group//;/, } ${(q)o} ${(q)s}\" )\n            unset \"owner_to_group[${o}--$s]\"\n        fi\n\n        (( ++ flcur ))\n        flper=$(( flcur / flmax * 100 ))\n        builtin print -u 2 -n -- \"\\r${flper}% \"\n    done\n\n    for o in \"${(k)owner_to_group[@]}\"; do\n        group=\"${owner_to_group[$o]%;}\"\n        s=\"${o##*--}\"\n        o=\"${o%--*}\"\n        packs+=( \"${(q)group//;/, } ${(q)o} ${(q)s}\" )\n    done\n    packs=( \"${(on)packs[@]}\" )\n\n    builtin print -u 2 # newline after percent\n\n    # Find longest completion name\n    integer longest=0\n    local -a unpacked\n    for c in \"${packs[@]}\"; do\n        unpacked=( \"${(Q@)${(z@)c}}\" )\n        [[ \"${#unpacked[1]}\" -gt \"$longest\" ]] && longest=\"${#unpacked[1]}\"\n    done\n\n    for c in \"${packs[@]}\"; do\n        unpacked=( \"${(Q@)${(z@)c}}\" ) # TODO: ${(Q)${(z@)c}[@]} ?\n\n        .zinit-any-colorify-as-uspl2 \"$unpacked[2]\"\n        builtin print -n \"${(r:longest+1:: :)unpacked[1]} $REPLY\"\n\n        (( unpacked[3] & 0x1 )) && builtin print -n \" ${ZINIT[col-error]}[disabled]${ZINIT[col-rst]}\"\n        (( unpacked[3] & 0x2 )) && builtin print -n \" ${ZINIT[col-error]}[unknown file, clean with cclear]${ZINIT[col-rst]}\"\n        (( unpacked[3] & 0x4 )) && builtin print -n \" ${ZINIT[col-error]}[stray, clean with cclear]${ZINIT[col-rst]}\"\n        builtin print\n    done\n} # ]]]\n# FUNCTION: .zinit-show-debug-report [[[\n# Displays dtrace report (data recorded in interactive session).\n#\n# User-action entry point.\n.zinit-show-debug-report() {\n    .zinit-show-report \"_dtrace/_dtrace\"\n} # ]]]\n# FUNCTION: .zinit-show-report [[[\n# Displays report of the plugin given.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-show-report() {\n    setopt localoptions extendedglob warncreateglobal typesetsilent noksharrays\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\" uspl2=\"${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}\"\n\n    # Allow debug report\n    if [[ \"$user/$plugin\" != \"_dtrace/_dtrace\" ]]; then\n        .zinit-exists-message \"$user\" \"$plugin\" || return 1\n    fi\n\n    # Print title\n    builtin printf \"${ZINIT[col-title]}Report for${ZINIT[col-rst]} %s%s plugin\\n\"\\\n            \"${user:+${ZINIT[col-uname]}$user${ZINIT[col-rst]}}${${user:#(%|/)*}:+/}\"\\\n            \"${ZINIT[col-pname]}$plugin${ZINIT[col-rst]}\"\n\n    # Print \"----------\"\n    local msg=\"Report for $user${${user:#(%|/)*}:+/}$plugin plugin\"\n    builtin print -- \"${ZINIT[col-bar]}${(r:${#msg}::-:)tmp__}${ZINIT[col-rst]}\"\n\n    local -A map\n    map=(\n        Error:  \"${ZINIT[col-error]}\"\n        Warning:  \"${ZINIT[col-error]}\"\n        Note:  \"${ZINIT[col-note]}\"\n    )\n    # Print report gathered via shadowing\n    () {\n        setopt localoptions extendedglob\n        builtin print -rl -- \"${(@)${(f@)ZINIT_REPORTS[$uspl2]}/(#b)(#s)([^[:space:]]##)([[:space:]]##)/${map[${match[1]}]:-${ZINIT[col-keyword]}}${match[1]}${ZINIT[col-rst]}${match[2]}}\"\n    }\n\n    # Print report gathered via $functions-diffing\n    REPLY=\"\"\n    .zinit-diff-functions-compute \"$uspl2\"\n    .zinit-format-functions \"$uspl2\"\n    [[ -n \"$REPLY\" ]] && builtin print \"${ZINIT[col-p]}Functions created:${ZINIT[col-rst]}\"$'\\n'\"$REPLY\"\n\n    # Print report gathered via $options-diffing\n    REPLY=\"\"\n    .zinit-diff-options-compute \"$uspl2\"\n    .zinit-format-options \"$uspl2\"\n    [[ -n \"$REPLY\" ]] && builtin print \"${ZINIT[col-p]}Options changed:${ZINIT[col-rst]}\"$'\\n'\"$REPLY\"\n\n    # Print report gathered via environment diffing\n    REPLY=\"\"\n    .zinit-diff-env-compute \"$uspl2\"\n    .zinit-format-env \"$uspl2\" \"1\"\n    [[ -n \"$REPLY\" ]] && builtin print \"${ZINIT[col-p]}PATH elements added:${ZINIT[col-rst]}\"$'\\n'\"$REPLY\"\n\n    REPLY=\"\"\n    .zinit-format-env \"$uspl2\" \"2\"\n    [[ -n \"$REPLY\" ]] && builtin print \"${ZINIT[col-p]}FPATH elements added:${ZINIT[col-rst]}\"$'\\n'\"$REPLY\"\n\n    # Print report gathered via parameter diffing\n    .zinit-diff-parameter-compute \"$uspl2\"\n    .zinit-format-parameter \"$uspl2\"\n    [[ -n \"$REPLY\" ]] && builtin print \"${ZINIT[col-p]}Variables added or redefined:${ZINIT[col-rst]}\"$'\\n'\"$REPLY\"\n\n    # Print what completions plugin has\n    .zinit-find-completions-of-plugin \"$user\" \"$plugin\"\n    typeset -a completions\n    completions=( \"${reply[@]}\" )\n\n    if [[ \"${#completions[@]}\" -ge \"1\" ]]; then\n        builtin print \"${ZINIT[col-p]}Completions:${ZINIT[col-rst]}\"\n        .zinit-check-which-completions-are-installed \"${completions[@]}\"\n        typeset -a installed\n        installed=( \"${reply[@]}\" )\n\n        .zinit-check-which-completions-are-enabled \"${completions[@]}\"\n        typeset -a enabled\n        enabled=( \"${reply[@]}\" )\n\n        integer count=\"${#completions[@]}\" idx\n        for (( idx=1; idx <= count; idx ++ )); do\n            builtin print -n \"${completions[idx]:t}\"\n            if [[ \"${installed[idx]}\" != \"1\" ]]; then\n                builtin print -n \" ${ZINIT[col-uninst]}[not installed]${ZINIT[col-rst]}\"\n            else\n                if [[ \"${enabled[idx]}\" = \"1\" ]]; then\n                    builtin print -n \" ${ZINIT[col-info]}[enabled]${ZINIT[col-rst]}\"\n                else\n                    builtin print -n \" ${ZINIT[col-error]}[disabled]${ZINIT[col-rst]}\"\n                fi\n            fi\n            builtin print\n        done\n        builtin print\n    fi\n} # ]]]\n# FUNCTION: .zinit-show-times [[[\n# Shows loading times of all loaded plugins.\n#\n# User-action entry point.\n.zinit-show-times() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt  extendedglob warncreateglobal noshortloops\n\n    local opt=\"$1 $2 $3\" entry entry2 entry3 user plugin\n    float -F 3 sum=0.0\n    local -A sice\n    local -a tmp\n\n    [[ \"$opt\" = *-[a-z]#m[a-z]#* ]] && \\\n        { builtin print \"Plugin loading moments (relative to the first prompt):\"; ((1)); } || \\\n        builtin print \"Plugin loading times:\"\n\n    for entry in \"${(@on)ZINIT[(I)TIME_[0-9]##_*]}\"; do\n        entry2=\"${entry#TIME_[0-9]##_}\"\n        entry3=\"AT_$entry\"\n        if [[ \"$entry2\" = (http|https|ftp|ftps|scp|${(~j.|.)${${(k)ZINIT_1MAP}%::}}):* ]]; then\n            REPLY=\"${ZINIT[col-pname]}$entry2${ZINIT[col-rst]}\"\n\n            tmp=( \"${(z@)ZINIT_SICE[${entry2%/}]}\" )\n            (( ${#tmp} > 1 && ${#tmp} % 2 == 0 )) && sice=( \"${(Q)tmp[@]}\" ) || sice=()\n        else\n            user=\"${entry2%%---*}\"\n            plugin=\"${entry2#*---}\"\n            [[ \"$user\" = \\% ]] && plugin=\"/${plugin//---/\\/}\"\n            [[ \"$user\" = \"$plugin\" && \"$user/$plugin\" != \"$entry2\" ]] && user=\"\"\n            .zinit-any-colorify-as-uspl2 \"$user\" \"$plugin\"\n\n            tmp=( \"${(z@)ZINIT_SICE[$user/$plugin]}\" )\n            (( ${#tmp} > 1 && ${#tmp} % 2 == 0 )) && sice=( \"${(Q)tmp[@]}\" ) || sice=()\n        fi\n\n        local attime=$(( ZINIT[$entry3] - ZINIT[START_TIME] ))\n        if [[ \"$opt\" = *-[a-z]#s[a-z]#* ]]; then\n            local time=\"$ZINIT[$entry] sec\"\n            attime=\"${(M)attime#*.???} sec\"\n        else\n            local time=\"${(l:5:: :)$(( ZINIT[$entry] * 1000 ))%%[,.]*} ms\"\n            attime=\"${(l:5:: :)$(( attime * 1000 ))%%[,.]*} ms\"\n        fi\n        [[ -z $EPOCHREALTIME ]] && attime=\"<no zsh/datetime module → no time data>\"\n\n        local line=\"$time\"\n        if [[ \"$opt\" = *-[a-z]#m[a-z]#* ]]; then\n            line=\"$attime\"\n        elif [[ \"$opt\" = *-[a-z]#a[a-z]#* ]]; then\n            line=\"$attime $line\"\n        fi\n\n        line=\"$line - $REPLY\"\n\n        if [[ ${sice[as]} == \"command\" ]]; then\n            line=\"$line (command)\"\n        elif [[ -n ${sice[sbin]+abc} ]]; then\n            line=\"$line (sbin command)\"\n        elif [[ -n ${sice[fbin]+abc} ]]; then\n            line=\"$line (fbin command)\"\n        elif [[ ( ${sice[pick]} = /dev/null || ${sice[as]} = null ) && ${+sice[make]} = 1 ]]; then\n            line=\"$line (/dev/null make plugin)\"\n        fi\n\n        builtin print \"$line\"\n\n        (( sum += ZINIT[$entry] ))\n    done\n    builtin print \"Total: $sum sec\"\n} # ]]]\n# FUNCTION: .zinit-show-zstatus [[[\n# Shows Zinit status, i.e. number of loaded plugins,\n# of available completions, etc.\n#\n# User-action entry point.\n.zinit-show-zstatus() {\n    builtin setopt localoptions nullglob extendedglob nokshglob noksharrays\n\n    local infoc=\"${ZINIT[col-info2]}\"\n\n    +zi-log \"Zinit's main directory: {file}${ZINIT[HOME_DIR]}{rst}\"\n    +zi-log \"Zinit's binary directory: {file}${ZINIT[BIN_DIR]}{rst}\"\n    +zi-log \"Plugin directory: {file}${ZINIT[PLUGINS_DIR]}{rst}\"\n    +zi-log \"Completions directory: {file}${ZINIT[COMPLETIONS_DIR]}{rst}\"\n\n    # Without _zlocal/zinit\n    +zi-log \"Loaded plugins: {num}$(( ${#ZINIT_REGISTERED_PLUGINS[@]} - 1 )){rst}\"\n\n    # Count light-loaded plugins\n    integer light=0\n    local s\n    for s in \"${(@v)ZINIT[(I)STATES__*]}\"; do\n        [[ \"$s\" = 1 ]] && (( light ++ ))\n    done\n    # Without _zlocal/zinit\n    +zi-log \"Light loaded: {num}$(( light - 1 )){rst}\"\n\n    # Downloaded plugins, without _zlocal/zinit, custom\n    typeset -a plugins\n    plugins=( \"${ZINIT[PLUGINS_DIR]}\"/*(DN) )\n    +zi-log \"Downloaded plugins: {num}$(( ${#plugins} - 1 )){rst}\"\n\n    # Number of enabled completions, with _zlocal/zinit\n    typeset -a completions\n    completions=( \"${ZINIT[COMPLETIONS_DIR]}\"/_[^_.]*~*.zwc(DN) )\n    +zi-log \"Enabled completions: {num}${#completions[@]}{rst}\"\n\n    # Number of disabled completions, with _zlocal/zinit\n    completions=( \"${ZINIT[COMPLETIONS_DIR]}\"/[^_.]*~*.zwc(DN) )\n    +zi-log \"Disabled completions: {num}${#completions[@]}{rst}\"\n\n    # Number of completions existing in all plugins\n    completions=( \"${ZINIT[PLUGINS_DIR]}\"/*/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1)(DN) )\n    +zi-log \"Completions available overall: {num}${#completions[@]}{rst}\"\n\n    # Enumerate snippets loaded\n    # }, ${infoc}{rst}\", j:, :, {msg}\"$'\\e[0m, +zi-log h\n    +zi-log -n \"Snippets loaded: \"\n    local sni\n    for sni in ${(onv)ZINIT_SNIPPETS[@]}; do\n        +zi-log -n \"{url}${sni% <[^>]#>}{rst} ${(M)sni%<[^>]##>}, \"\n    done\n    [[ -z $sni ]] && builtin print -n \" \"\n    builtin print '\\b\\b  '\n\n    # Number of compiled plugins\n    typeset -a matches m\n    integer count=0\n    matches=( ${ZINIT[PLUGINS_DIR]}/*/*.zwc(DN) )\n\n    local cur_plugin=\"\" uspl1\n    for m in \"${matches[@]}\"; do\n        uspl1=\"${${m:h}:t}\"\n\n        if [[ \"$cur_plugin\" != \"$uspl1\" ]]; then\n            (( count ++ ))\n            cur_plugin=\"$uspl1\"\n        fi\n    done\n\n    +zi-log \"Compiled plugins: {num}$count{rst}\"\n} # ]]]\n\n# FUNCTION: .zinit-stress [[[\n# Compiles plugin with various options on and off to see\n# how well the code is written. The options are:\n#\n# NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB,\n# CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF.\n#\n# User-action entry point.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-stress() {\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n\n    .zinit-exists-physically-message \"$user\" \"$plugin\" || return 1\n\n    .zinit-first \"$1\" \"$2\" || {\n        builtin print \"${ZINIT[col-error]}No source file found, cannot stress${ZINIT[col-rst]}\"\n        return 1\n    }\n\n    local pdir_path=\"${reply[-2]}\" fname=\"${reply[-1]}\"\n\n    integer compiled=1\n    [[ -e \"${fname}.zwc\" ]] && command rm -f \"${fname}.zwc\" || compiled=0\n\n    local -a ZINIT_STRESS_TEST_OPTIONS\n    ZINIT_STRESS_TEST_OPTIONS=(\n        \"NO_SHORT_LOOPS\" \"IGNORE_BRACES\" \"IGNORE_CLOSE_BRACES\"\n        \"SH_GLOB\" \"CSH_JUNKIE_QUOTES\" \"NO_MULTI_FUNC_DEF\"\n    )\n\n    (\n        builtin emulate -LR ksh ${=${options[xtrace]:#off}:+-o xtrace}\n        builtin unsetopt shglob kshglob\n        for i in \"${ZINIT_STRESS_TEST_OPTIONS[@]}\"; do\n            builtin setopt \"$i\"\n            builtin print -n \"Stress-testing ${fname:t} for option $i \"\n            zcompile -UR \"$fname\" 2>/dev/null && {\n                builtin print \"[${ZINIT[col-success]}Success${ZINIT[col-rst]}]\"\n            } || {\n                builtin print \"[${ZINIT[col-failure]}Fail${ZINIT[col-rst]}]\"\n            }\n            builtin unsetopt \"$i\"\n        done\n    )\n\n    command rm -f \"${fname}.zwc\"\n    (( compiled )) && zcompile -U \"$fname\"\n} # ]]]\n\n# FUNCTION: .zinit-unload [[[\n# 1. call the zsh plugin's standard *_plugin_unload function\n# 2. call the code provided by the zsh plugin's standard @zsh-plugin-run-at-update\n# 3. delete bindkeys (...)\n# 4. delete zstyles\n# 5. restore options\n# 6. remove aliases\n# 7. restore zle state\n# 8. unfunction functions (created by plugin)\n# 9. clean-up fpath and path\n# 10. delete created variables\n# 11. forget the plugin\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-unload() {\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local uspl2=\"${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}\" user=\"${reply[-2]}\" plugin=\"${reply[-1]}\" quiet=\"${${3:+1}:-0}\"\n    local k\n\n    .zinit-any-colorify-as-uspl2 \"$uspl2\"\n    (( quiet )) || +zi-log \"{i} Unloading $REPLY\"\n\n    local ___dir\n    [[ \"$user\" = \"%\" ]] && ___dir=\"$plugin\" || ___dir=\"${ZINIT[PLUGINS_DIR]}/${user:+${user}---}${plugin//\\//---}\"\n\n    # KSH_ARRAYS immunity\n    integer correct=0\n    [[ -o \"KSH_ARRAYS\" ]] && correct=1\n\n    # Allow unload for debug user\n    if [[ \"$uspl2\" != \"_dtrace/_dtrace\" ]]; then\n        .zinit-exists-message \"$1\" \"$2\" || return 1\n    fi\n\n    .zinit-any-colorify-as-uspl2 \"$1\" \"$2\"\n    local uspl2col=\"$REPLY\"\n\n    # Store report of the plugin in variable LASTREPORT\n    typeset -g LASTREPORT\n    LASTREPORT=`.zinit-show-report \"$1\" \"$2\"`\n\n    # Call the Zsh Plugin's Standard *_plugin_unload function\n    (( ${+functions[${plugin}_plugin_unload]} )) && ${plugin}_plugin_unload\n\n    # Call the code provided by the Zsh Plugin's Standard @zsh-plugin-run-at-update\n    local -a tmp\n    local -A sice\n    tmp=( \"${(z@)ZINIT_SICE[$uspl2]}\" )\n    (( ${#tmp} > 1 && ${#tmp} % 2 == 0 )) && sice=( \"${(Q)tmp[@]}\" ) || sice=()\n\n    if [[ -n ${sice[ps-on-unload]} ]]; then\n        (( quiet )) || builtin print -r \"Running plugin's provided unload code: ${ZINIT[col-info]}${sice[ps-on-unload][1,50]}${sice[ps-on-unload][51]:+…}${ZINIT[col-rst]}\"\n        local ___oldcd=\"$PWD\"\n        () { setopt localoptions noautopushd; builtin cd -q \"$___dir\"; }\n        eval \"${sice[ps-on-unload]}\"\n        () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }\n    fi\n\n    # 1. Delete done bindkeys\n    typeset -a string_widget\n    string_widget=( \"${(z)ZINIT[BINDKEYS__$uspl2]}\" )\n    local sw\n    for sw in \"${(Oa)string_widget[@]}\"; do\n        [[ -z \"$sw\" ]] && continue\n        # Remove one level of quoting to split using (z)\n        sw=\"${(Q)sw}\"\n        typeset -a sw_arr\n        sw_arr=( \"${(z)sw}\" )\n\n        # Remove one level of quoting to pass to bindkey\n        local sw_arr1=\"${(Q)sw_arr[1-correct]}\" # Keys\n        local sw_arr2=\"${(Q)sw_arr[2-correct]}\" # Widget\n        local sw_arr3=\"${(Q)sw_arr[3-correct]}\" # Optional previous-bound widget\n        local sw_arr4=\"${(Q)sw_arr[4-correct]}\" # Optional -M or -A or -N\n        local sw_arr5=\"${(Q)sw_arr[5-correct]}\" # Optional map name\n        local sw_arr6=\"${(Q)sw_arr[6-correct]}\" # Optional -R (not with -A, -N)\n\n        if [[ \"$sw_arr4\" = \"-M\" && \"$sw_arr6\" != \"-R\" ]]; then\n            if [[ -n \"$sw_arr3\" ]]; then\n                () {\n                    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n                    (( quiet )) || builtin print -r \"Restoring bindkey ${${(q)sw_arr1}//(#m)\\\\[\\^\\?\\]\\[\\)\\(\\'\\\"\\}\\{\\`]/${MATCH#\\\\}} $sw_arr3 ${ZINIT[col-info]}in map ${ZINIT[col-rst]}$sw_arr5\"\n                }\n                bindkey -M \"$sw_arr5\" \"$sw_arr1\" \"$sw_arr3\"\n            else\n                (( quiet )) || builtin print -r \"Deleting bindkey ${(q)sw_arr1} $sw_arr2 ${ZINIT[col-info]}in map ${ZINIT[col-rst]}$sw_arr5\"\n                bindkey -M \"$sw_arr5\" -r \"$sw_arr1\"\n            fi\n        elif [[ \"$sw_arr4\" = \"-M\" && \"$sw_arr6\" = \"-R\" ]]; then\n            if [[ -n \"$sw_arr3\" ]]; then\n                (( quiet )) || builtin print -r \"Restoring ${ZINIT[col-info]}range${ZINIT[col-rst]} bindkey ${(q)sw_arr1} $sw_arr3 ${ZINIT[col-info]}in map ${ZINIT[col-rst]}$sw_arr5\"\n                bindkey -RM \"$sw_arr5\" \"$sw_arr1\" \"$sw_arr3\"\n            else\n                (( quiet )) || builtin print -r \"Deleting ${ZINIT[col-info]}range${ZINIT[col-rst]} bindkey ${(q)sw_arr1} $sw_arr2 ${ZINIT[col-info]}in map ${ZINIT[col-rst]}$sw_arr5\"\n                bindkey -M \"$sw_arr5\" -Rr \"$sw_arr1\"\n            fi\n        elif [[ \"$sw_arr4\" != \"-M\" && \"$sw_arr6\" = \"-R\" ]]; then\n            if [[ -n \"$sw_arr3\" ]]; then\n                (( quiet )) || builtin print -r \"Restoring ${ZINIT[col-info]}range${ZINIT[col-rst]} bindkey ${(q)sw_arr1} $sw_arr3\"\n                bindkey -R \"$sw_arr1\" \"$sw_arr3\"\n            else\n                (( quiet )) || builtin print -r \"Deleting ${ZINIT[col-info]}range${ZINIT[col-rst]} bindkey ${(q)sw_arr1} $sw_arr2\"\n                bindkey -Rr \"$sw_arr1\"\n            fi\n        elif [[ \"$sw_arr4\" = \"-A\" ]]; then\n            (( quiet )) || builtin print -r \"Linking backup-\\`main' keymap \\`$sw_arr5' back to \\`main'\"\n            bindkey -A \"$sw_arr5\" \"main\"\n        elif [[ \"$sw_arr4\" = \"-N\" ]]; then\n            (( quiet )) || builtin print -r \"Deleting keymap \\`$sw_arr5'\"\n            bindkey -D \"$sw_arr5\"\n        else\n            if [[ -n \"$sw_arr3\" ]]; then\n                () {\n                    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n                    (( quiet )) || builtin print -r \"Restoring bindkey ${${(q)sw_arr1}//(#m)\\\\[\\^\\?\\]\\[\\)\\(\\'\\\"\\}\\{\\`]/${MATCH#\\\\}} $sw_arr3\"\n                }\n                bindkey \"$sw_arr1\" \"$sw_arr3\"\n            else\n                (( quiet )) || builtin print -r \"Deleting bindkey ${(q)sw_arr1} $sw_arr2\"\n                bindkey -r \"$sw_arr1\"\n            fi\n        fi\n    done\n\n    # 2. Delete created Zstyles\n\n    typeset -a pattern_style\n    pattern_style=( \"${(z)ZINIT[ZSTYLES__$uspl2]}\" )\n    local ps\n    for ps in \"${(Oa)pattern_style[@]}\"; do\n        [[ -z \"$ps\" ]] && continue\n        # Remove one level of quoting to split using (z)\n        ps=\"${(Q)ps}\"\n        typeset -a ps_arr\n        ps_arr=( \"${(z)ps}\" )\n\n        # Remove one level of quoting to pass to zstyle\n        local ps_arr1=\"${(Q)ps_arr[1-correct]}\"\n        local ps_arr2=\"${(Q)ps_arr[2-correct]}\"\n\n        (( quiet )) || builtin print \"Deleting zstyle $ps_arr1 $ps_arr2\"\n\n        zstyle -d \"$ps_arr1\" \"$ps_arr2\"\n    done\n\n    # 3. Restore changed options\n    # paranoid, don't want bad key/value pair error\n    .zinit-diff-options-compute \"$uspl2\"\n    integer empty=0\n    .zinit-save-set-extendedglob\n    [[ \"${ZINIT[OPTIONS__$uspl2]}\" != *[$'! \\t']* ]] && empty=1\n    .zinit-restore-extendedglob\n\n    if (( empty != 1 )); then\n        typeset -A opts\n        opts=( \"${(z)ZINIT[OPTIONS__$uspl2]}\" )\n        for k in \"${(kon)opts[@]}\"; do\n            # Internal options\n            [[ \"$k\" = \"physical\" ]] && continue\n\n            if [[ \"${opts[$k]}\" = \"on\" ]]; then\n                (( quiet )) || builtin print \"Setting option $k\"\n                builtin setopt \"$k\"\n            else\n                (( quiet )) || builtin print \"Unsetting option $k\"\n                builtin unsetopt \"$k\"\n            fi\n        done\n    fi\n\n    # 4. Delete aliases\n    typeset -a aname_avalue\n    aname_avalue=( \"${(z)ZINIT[ALIASES__$uspl2]}\" )\n    local nv\n    for nv in \"${(Oa)aname_avalue[@]}\"; do\n        [[ -z \"$nv\" ]] && continue\n        # Remove one level of quoting to split using (z)\n        nv=\"${(Q)nv}\"\n        typeset -a nv_arr\n        nv_arr=( \"${(z)nv}\" )\n\n        # Remove one level of quoting to pass to unalias\n        local nv_arr1=\"${(Q)nv_arr[1-correct]}\"\n        local nv_arr2=\"${(Q)nv_arr[2-correct]}\"\n        local nv_arr3=\"${(Q)nv_arr[3-correct]}\"\n\n        if [[ \"$nv_arr3\" = \"-s\" ]]; then\n            if [[ -n \"$nv_arr2\" ]]; then\n                (( quiet )) || builtin print \"Restoring ${ZINIT[col-info]}suffix${ZINIT[col-rst]} alias ${nv_arr1}=${nv_arr2}\"\n                alias \"$nv_arr1\" &> /dev/null && unalias -s -- \"$nv_arr1\"\n                alias -s -- \"${nv_arr1}=${nv_arr2}\"\n            else\n                (( quiet )) || alias \"$nv_arr1\" &> /dev/null && {\n                    builtin print \"Removing ${ZINIT[col-info]}suffix${ZINIT[col-rst]} alias ${nv_arr1}\"\n                    unalias -s -- \"$nv_arr1\"\n                }\n            fi\n        elif [[ \"$nv_arr3\" = \"-g\" ]]; then\n            if [[ -n \"$nv_arr2\" ]]; then\n                (( quiet )) || builtin print \"Restoring ${ZINIT[col-info]}global${ZINIT[col-rst]} alias ${nv_arr1}=${nv_arr2}\"\n                alias \"$nv_arr1\" &> /dev/null && unalias -g -- \"$nv_arr1\"\n                alias -g -- \"${nv_arr1}=${nv_arr2}\"\n            else\n                (( quiet )) || alias \"$nv_arr1\" &> /dev/null && {\n                    builtin print \"Removing ${ZINIT[col-info]}global${ZINIT[col-rst]} alias ${nv_arr1}\"\n                    unalias -- \"${(q)nv_arr1}\"\n                }\n            fi\n        else\n            if [[ -n \"$nv_arr2\" ]]; then\n                (( quiet )) || builtin print \"Restoring alias ${nv_arr1}=${nv_arr2}\"\n                alias \"$nv_arr1\" &> /dev/null && unalias -- \"$nv_arr1\"\n                alias -- \"${nv_arr1}=${nv_arr2}\"\n            else\n                (( quiet )) || alias \"$nv_arr1\" &> /dev/null && {\n                    builtin print \"Removing alias ${nv_arr1}\"\n                    unalias -- \"$nv_arr1\"\n                }\n            fi\n        fi\n    done\n\n    #\n    # 5. Restore Zle state\n    #\n\n    local -a keys\n    keys=( \"${(@on)ZINIT[(I)TIME_<->_*]}\" )\n    integer keys_size=${#keys}\n    () {\n        setopt localoptions extendedglob noksharrays typesetsilent\n        typeset -a restore_widgets skip_delete\n        local wid\n        restore_widgets=( \"${(z)ZINIT[WIDGETS_SAVED__$uspl2]}\" )\n        for wid in \"${(Oa)restore_widgets[@]}\"; do\n            [[ -z \"$wid\" ]] && continue\n            wid=\"${(Q)wid}\"\n            typeset -a orig_saved\n            orig_saved=( \"${(z)wid}\" )\n\n            local tpe=\"${orig_saved[1]}\"\n            local orig_saved1=\"${(Q)orig_saved[2]}\" # Original widget\n            local comp_wid=\"${(Q)orig_saved[3]}\"\n            local orig_saved2=\"${(Q)orig_saved[4]}\" # Saved target function\n            local orig_saved3=\"${(Q)orig_saved[5]}\" # Saved previous $widget's contents\n\n            local found_time_key=\"${keys[(r)TIME_<->_${uspl2//\\//---}]}\" to_process_plugin\n            integer found_time_idx=0 idx=0\n            to_process_plugin=\"\"\n            [[ \"$found_time_key\" = (#b)TIME_(<->)_* ]] && found_time_idx=\"${match[1]}\"\n            if (( found_time_idx )); then # Must be true\n                for (( idx = found_time_idx + 1; idx <= keys_size; ++ idx )); do\n                    found_time_key=\"${keys[(r)TIME_${idx}_*]}\"\n                    local oth_uspl2=\"\"\n                    [[ \"$found_time_key\" = (#b)TIME_${idx}_(*) ]] && oth_uspl2=\"${match[1]//---//}\"\n                    local -a entry_splitted\n                    entry_splitted=( \"${(z@)ZINIT[WIDGETS_SAVED__$oth_uspl2]}\" )\n                    integer found_idx=\"${entry_splitted[(I)(-N|-C)\\ $orig_saved1\\\\\\ *]}\"\n                    local -a entry_splitted2\n                    entry_splitted2=( \"${(z@)ZINIT[BINDKEYS__$oth_uspl2]}\" )\n                    integer found_idx2=\"${entry_splitted2[(I)*\\ $orig_saved1\\ *]}\"\n                    if (( found_idx || found_idx2 ))\n                    then\n                        # Skip multiple loads of the same plugin\n                        # TODO: fully handle multiple plugin loads\n                        if [[ \"$oth_uspl2\" != \"$uspl2\" ]]; then\n                            to_process_plugin=\"$oth_uspl2\"\n                            # only the first one is needed\n                            break\n                        fi\n                    fi\n                done\n                if [[ -n \"$to_process_plugin\" ]]; then\n                    if (( !found_idx && !found_idx2 )); then\n                        (( quiet )) || builtin print \"Problem (1) during handling of widget \\`$orig_saved1' (contents: $orig_saved2)\"\n                        continue\n                    fi\n                    (( quiet )) || builtin print \"Chaining widget \\`$orig_saved1' to plugin $oth_uspl2\"\n                    local -a oth_orig_saved\n                    if (( found_idx )) {\n                        oth_orig_saved=( \"${(z)${(Q)entry_splitted[found_idx]}}\" )\n                        local oth_fun=\"${oth_orig_saved[4]}\"\n                        # below is wrong because we don't want to call other plugins function at any moment\n                        # oth_orig_saved[2]=\"${(q)orig_saved2}\"\n                        oth_orig_saved[5]=\"${(q)orig_saved3}\" # chain up the widget\n                        entry_splitted[found_idx]=\"${(q)${(j: :)oth_orig_saved}}\"\n                        ZINIT[WIDGETS_SAVED__$oth_uspl2]=\"${(j: :)entry_splitted}\"\n                    } else {\n                        oth_orig_saved=( \"${(z)${(Q)entry_splitted2[found_idx2]}}\" )\n                        local oth_fun=\"${widgets[${oth_orig_saved[3]}]#*:}\"\n                    }\n                    integer idx=\"${functions[$orig_saved2][(i)(#b)([^[:space:]]#${orig_saved1}[^[:space:]]#)]}\"\n                    if (( idx <= ${#functions[$orig_saved2]} ))\n                    then\n                        local prefix_X=\"${match[1]#\\{}\"\n                        [[ $prefix_X != \\$* ]] && prefix_X=\"${prefix_X%\\}}\"\n                        idx=\"${functions[$oth_fun][(i)(#b)([^[:space:]]#${orig_saved1}[^[:space:]]#)]}\"\n                        if (( idx <= ${#functions[$oth_fun]} )); then\n                            match[1]=\"${match[1]#\\{}\"\n                            [[ ${match[1]} != \\$* ]] && match[1]=\"${match[1]%\\}}\"\n                            eval \"local oth_prefix_uspl2_X=\\\"${match[1]}\\\"\"\n                            if [[ \"${widgets[$prefix_X]}\" = builtin ]]; then\n                                (( quiet )) || builtin print \"Builtin-restoring widget \\`$oth_prefix_uspl2_X' ($oth_uspl2)\"\n                                zle -A \".${prefix_X#.}\" \"$oth_prefix_uspl2_X\"\n                            elif [[ \"${widgets[$prefix_X]}\" = completion:* ]]; then\n                                (( quiet )) || builtin print \"Chain*-restoring widget \\`$oth_prefix_uspl2_X' ($oth_uspl2)\"\n                                zle -C \"$oth_prefix_uspl2_X\" \"${(@)${(@s.:.)${orig_saved3#user:}}[2,3]}\"\n                            else\n                                (( quiet )) || builtin print \"Chain-restoring widget \\`$oth_prefix_uspl2_X' ($oth_uspl2)\"\n                                zle -N \"$oth_prefix_uspl2_X\" \"${widgets[$prefix_X]#user:}\"\n                            fi\n                        fi\n                        # The alternate method\n                        # skip_delete+=( \"${match[1]}\" )\n                        # functions[$oth_fun]=\"${functions[$oth_fun]//[^\\{[:space:]]#$orig_saved1/${match[1]}}\"\n                    fi\n                else\n                    (( quiet )) || builtin print \"Restoring Zle widget $orig_saved1\"\n                    if [[ \"$orig_saved3\" = builtin ]]; then\n                        zle -A \".$orig_saved1\" \"$orig_saved1\"\n                    elif [[ \"$orig_saved3\" = completion:* ]]; then\n                        zle -C \"$orig_saved1\" \"${(@)${(@s.:.)${orig_saved3#user:}}[2,3]}\"\n                    else\n                        zle -N \"$orig_saved1\" \"${orig_saved3#user:}\"\n                    fi\n                fi\n            else\n                (( quiet )) || builtin print \"Problem (2) during handling of widget \\`$orig_saved1' (contents: $orig_saved2)\"\n            fi\n        done\n    }\n\n    typeset -a delete_widgets\n    delete_widgets=( \"${(z)ZINIT[WIDGETS_DELETE__$uspl2]}\" )\n    local wid\n    for wid in \"${(Oa)delete_widgets[@]}\"; do\n        [[ -z \"$wid\" ]] && continue\n        wid=\"${(Q)wid}\"\n        if [[ -n \"${skip_delete[(r)$wid]}\" ]]; then\n            builtin print \"Would delete $wid\"\n            continue\n        fi\n        if [[ \"${ZINIT_ZLE_HOOKS_LIST[$wid]}\" = \"1\" ]]; then\n            (( quiet )) || builtin print \"Removing Zle hook \\`$wid'\"\n        else\n            (( quiet )) || builtin print \"Removing Zle widget \\`$wid'\"\n        fi\n        zle -D \"$wid\"\n    done\n\n    # 6. Unfunction\n    .zinit-diff-functions-compute \"$uspl2\"\n    typeset -a func\n    func=( \"${(z)ZINIT[FUNCTIONS__$uspl2]}\" )\n    local f\n    for f in \"${(on)func[@]}\"; do\n        [[ -z \"$f\" ]] && continue\n        f=\"${(Q)f}\"\n        (( quiet )) || builtin print \"Deleting function $f\"\n        (( ${+functions[$f]} )) && unfunction -- \"$f\"\n        (( ${+precmd_functions} )) && precmd_functions=( ${precmd_functions[@]:#$f} )\n        (( ${+preexec_functions} )) && preexec_functions=( ${preexec_functions[@]:#$f} )\n        (( ${+chpwd_functions} )) && chpwd_functions=( ${chpwd_functions[@]:#$f} )\n        (( ${+periodic_functions} )) && periodic_functions=( ${periodic_functions[@]:#$f} )\n        (( ${+zshaddhistory_functions} )) && zshaddhistory_functions=( ${zshaddhistory_functions[@]:#$f} )\n        (( ${+zshexit_functions} )) && zshexit_functions=( ${zshexit_functions[@]:#$f} )\n    done\n\n    # 7. Clean up FPATH and PATH\n    .zinit-diff-env-compute \"$uspl2\"\n    # iterate over $path elements and skip those that were added by the plugin\n    typeset -a new elem p\n    elem=( \"${(z)ZINIT[PATH__$uspl2]}\" )\n    for p in \"${path[@]}\"; do\n        if [[ -z \"${elem[(r)${(q)p}]}\" ]] {\n            new+=( \"$p\" )\n        } else {\n            (( quiet )) || builtin print \"Removing PATH element ${ZINIT[col-info]}$p${ZINIT[col-rst]}\"\n            [[ -d \"$p\" ]] || (( quiet )) || builtin print \"${ZINIT[col-error]}Warning:${ZINIT[col-rst]} it didn't exist on disk\"\n        }\n    done\n    path=( \"${new[@]}\" )\n\n    # The same for $fpath\n    elem=( \"${(z)ZINIT[FPATH__$uspl2]}\" )\n    new=( )\n    for p ( \"${fpath[@]}\" ) {\n        if [[ -z \"${elem[(r)${(q)p}]}\" ]] {\n            new+=( \"$p\" )\n        } else {\n            (( quiet )) || builtin print \"Removing FPATH element ${ZINIT[col-info]}$p${ZINIT[col-rst]}\"\n            [[ -d \"$p\" ]] || (( quiet )) || builtin print \"${ZINIT[col-error]}Warning:${ZINIT[col-rst]} it didn't exist on disk\"\n        }\n    }\n    fpath=( \"${new[@]}\" )\n\n    # 8. Delete created variables\n    .zinit-diff-parameter-compute \"$uspl2\"\n    empty=0\n    .zinit-save-set-extendedglob\n    [[ \"${ZINIT[PARAMETERS_POST__$uspl2]}\" != *[$'! \\t']* ]] && empty=1\n    .zinit-restore-extendedglob\n\n    if (( empty != 1 )); then\n        typeset -A elem_pre elem_post\n        elem_pre=( \"${(z)ZINIT[PARAMETERS_PRE__$uspl2]}\" )\n        elem_post=( \"${(z)ZINIT[PARAMETERS_POST__$uspl2]}\" )\n\n        # Find variables created or modified\n        local wl found\n        local -a whitelist\n        whitelist=( \"${(@Q)${(z@)ZINIT[ENV-WHITELIST]}}\" )\n        for k in \"${(k)elem_post[@]}\"; do\n            k=\"${(Q)k}\"\n            local v1=\"${(Q)elem_pre[$k]}\"\n            local v2=\"${(Q)elem_post[$k]}\"\n\n            # \"\" means a variable was deleted, not created/changed\n            if [[ $v2 != '\"\"' ]]; then\n                # Don't unset readonly variables\n                [[ ${(tP)k} == *-readonly(|-*) ]] && continue\n\n                # Don't unset arrays managed by add-zsh-hook, also ignore a few special parameters\n                # TODO: remember and remove hooks\n                case \"$k\" in\n                    (chpwd_functions|precmd_functions|preexec_functions|periodic_functions|zshaddhistory_functions|zshexit_functions|zsh_directory_name_functions)\n                        continue\n                    (path|PATH|fpath|FPATH)\n                        continue;\n                        ;;\n                esac\n\n                # Don't unset redefined variables, only newly defined \"\" means variable didn't exist before plugin load (didn't have a type).\n                # Do an exception for the prompt variables\n                if [[ $v1 = '\"\"' || ( $k = (RPROMPT|RPS1|RPS2|PROMPT|PS1|PS2|PS3|PS4) && $v1 != $v2 ) ]]; then\n                    found=0\n                    for wl in \"${whitelist[@]}\"; do\n                        if [[ \"$k\" = ${~wl} ]]; then\n                            found=1\n                            break\n                        fi\n                    done\n                    if (( !found )); then\n                        (( quiet )) || builtin print \"Unsetting variable $k\"\n                        # checked that 4.3.17 does support \"--\"; cannot be parameter starting with \"-\" but let's defensively use \"--\" here\n                        unset -- \"$k\"\n                    else\n                        builtin print \"Skipping unset of variable $k (whitelist)\"\n                    fi\n                fi\n            fi\n        done\n    fi\n\n    # 9. Forget the plugin\n    if [[ \"$uspl2\" = \"_dtrace/_dtrace\" ]]; then\n        .zinit-debug-clear\n    else\n        (( quiet )) || builtin print \"Unregistering plugin $uspl2col\"\n        .zinit-unregister-plugin \"$user\" \"$plugin\" \"${sice[teleid]}\"\n        zsh_loaded_plugins[${zsh_loaded_plugins[(i)$user${${user:#(%|/)*}:+/}$plugin]}]=()  # Support Zsh plugin standard\n        .zinit-clear-report-for \"$user\" \"$plugin\"\n        (( quiet )) || builtin print \"Plugin's report saved to \\$LASTREPORT\"\n    fi\n} # ]]]\n\n# FUNCTION: .zinit-update-all-parallel [[[\n.zinit-update-all-parallel() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent \\\n        noshortloops nomonitor nonotify\n\n    local id_as repo snip uspl user plugin PUDIR=\"$(mktemp -d)\"\n\n    local -A PUAssocArray map\n    map=( / --  \"=\" -EQ-  \"?\" -QM-  \"&\" -AMP-  : - )\n    local -a files\n    integer main_counter counter PUPDATE=1\n\n    files=( ${ZINIT[SNIPPETS_DIR]}/**/(._zinit|._zplugin)/mode(ND) )\n    main_counter=${#files}\n    if (( OPTS[opt_-s,--snippets] || !OPTS[opt_-l,--plugins] )) {\n        for snip ( \"${files[@]}\" ) {\n            main_counter=main_counter-1\n            # The continue may cause the tail of processes to fall-through to the following plugins-specific `wait'\n            # Should happen only in a very special conditions\n            # TODO handle this\n            [[ ! -f ${snip:h}/url ]] && continue\n            [[ -f ${snip:h}/id-as ]] && \\\n                id_as=\"$(<${snip:h}/id-as)\" || \\\n                id_as=\n\n            counter+=1\n            local ef_id=\"${id_as:-$(<${snip:h}/url)}\"\n            local PUFILEMAIN=${${ef_id#/}//(#m)[\\/=\\?\\&:]/${map[$MATCH]}}\n            local PUFILE=$PUDIR/${counter}_$PUFILEMAIN.out\n\n            .zinit-update-or-status-snippet \"$st\" \"$ef_id\" &>! $PUFILE &\n\n            PUAssocArray[$!]=$PUFILE\n\n            .zinit-wait-for-update-jobs snippets\n        }\n    }\n\n    counter=0\n    PUAssocArray=()\n\n    if (( OPTS[opt_-l,--plugins] || !OPTS[opt_-s,--snippets] )) {\n        local -a files2\n        files=( ${ZINIT[PLUGINS_DIR]}/*(ND/) )\n\n        # Pre-process plugins\n        for repo ( $files ) {\n            uspl=${repo:t}\n            # Two special cases\n            [[ $uspl = custom || $uspl = _local---zinit ]] && continue\n\n            # Check if repository has a remote set\n            if [[ -f $repo/.git/config ]] {\n                local -a config\n                config=( ${(f)\"$(<$repo/.git/config)\"} )\n                if [[ ${#${(M)config[@]:#\\[remote[[:blank:]]*\\]}} -eq 0 ]] {\n                    continue\n                }\n            }\n\n            .zinit-any-to-user-plugin \"$uspl\"\n            local user=${reply[-2]} plugin=${reply[-1]}\n\n            # Must be a git repository or a binary release\n            if [[ ! -d $repo/.git && ! -f $repo/._zinit/is_release ]] {\n                continue\n            }\n            files2+=( $repo )\n        }\n\n        main_counter=${#files2}\n        for repo ( \"${files2[@]}\" ) {\n            main_counter=main_counter-1\n\n            uspl=${repo:t}\n            id_as=${uspl//---//}\n\n            counter+=1\n            local PUFILEMAIN=${${id_as#/}//(#m)[\\/=\\?\\&:]/${map[$MATCH]}}\n            local PUFILE=$PUDIR/${counter}_$PUFILEMAIN.out\n\n            .zinit-any-colorify-as-uspl2 \"$uspl\"\n            +zi-log \"Updating $REPLY{…}\" >! $PUFILE\n\n            .zinit-any-to-user-plugin \"$uspl\"\n            local user=${reply[-2]} plugin=${reply[-1]}\n\n            .zinit-update-or-status update \"$user\" \"$plugin\" &>>! $PUFILE &\n\n            PUAssocArray[$!]=$PUFILE\n\n            .zinit-wait-for-update-jobs plugins\n\n        }\n    }\n    # Shouldn't happen\n    # (( ${#PUAssocArray} > 0 )) && wait ${(k)PUAssocArray}\n} # ]]]\n# FUNCTION: .zinit-update-or-status [[[\n# Updates (git pull) or does `git status' for given plugin.\n#\n# User-action entry point.\n#\n# $1 - \"status\" for status, other for update\n# $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin)\n# $3 - plugin (only when $1 - i.e. user - given)\n.zinit-update-or-status() {\n    # Set the localtraps option.\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob nullglob warncreateglobal typesetsilent noshortloops\n\n    local -a arr\n    ZINIT[first-plugin-mark]=${${ZINIT[first-plugin-mark]:#init}:-1}\n    ZINIT[-r/--reset-opt-hook-has-been-run]=0\n\n    # Deliver and withdraw the `m` function when finished.\n    .zinit-set-m-func set\n    trap \".zinit-set-m-func unset\" EXIT\n\n    integer retval hook_rc was_snippet\n    .zinit-two-paths \"$2${${2:#(%|/)*}:+${3:+/}}$3\"\n    if [[ -d ${reply[-4]} || -d ${reply[-2]} ]]; then\n        .zinit-update-or-status-snippet \"$1\" \"$2${${2:#(%|/)*}:+${3:+/}}$3\"\n        retval=$?\n        was_snippet=1\n    fi\n\n    .zinit-any-to-user-plugin \"$2\" \"$3\"\n    local user=${reply[-2]} plugin=${reply[-1]} st=$1 \\\n        local_dir filename is_snippet key \\\n        id_as=\"${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}\"\n    local -A ice\n\n    if (( was_snippet )) {\n        .zinit-exists-physically \"$user\" \"$plugin\" || return $retval\n        .zinit-any-colorify-as-uspl2 \"$2\" \"$3\"\n        (( !OPTS[opt_-q,--quiet] )) && \\\n            +zi-log \"{msg2}Updating also \\`$REPLY{rst}{msg2}'\" \\\n                \"plugin (already updated a snippet of the same name){…}{rst}\"\n    } else {\n        .zinit-exists-physically-message \"$user\" \"$plugin\" || return 1\n    }\n\n    if [[ $st = status ]]; then\n        ( builtin cd -q ${ZINIT[PLUGINS_DIR]}/${user:+${user}---}${plugin//\\//---}; command git status; )\n        return $retval\n    fi\n\n    command rm -f ${TMPDIR:-${TMPDIR:-/tmp}}/zinit-execs.$$.lst ${TMPDIR:-${TMPDIR:-/tmp}}/zinit.installed_comps.$$.lst \\\n                    ${TMPDIR:-${TMPDIR:-/tmp}}/zinit.skipped_comps.$$.lst ${TMPDIR:-${TMPDIR:-/tmp}}/zinit.compiled.$$.lst\n\n    # A flag for the annexes. 0 – no new commits, 1 - run-atpull mode,\n    # 2 – full update/there are new commits to download, 3 - full but\n    # a forced download (i.e.: the medium doesn't allow to peek update)\n    ZINIT[annex-multi-flag:pull-active]=0\n\n    (( ${#ICE[@]} > 0 )) && { ZINIT_SICE[$user${${user:#(%|/)*}:+/}$plugin]=\"\"; local nf=\"-nftid\"; }\n\n    .zinit-compute-ice \"$user${${user:#(%|/)*}:+/}$plugin\" \"pack$nf\" \\\n        ice local_dir filename is_snippet || return 1\n\n    .zinit-any-to-user-plugin ${ice[teleid]:-$id_as}\n    user=${reply[1]} plugin=${reply[2]}\n\n    local repo=\"${${${(M)id_as#%}:+${id_as#%}}:-${ZINIT[PLUGINS_DIR]}/${id_as//\\//---}}\"\n\n    # Run annexes' preinit hooks\n    local -a arr\n    reply=(\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-pre <->]}\n        ${(on)ZINIT_EXTS[(I)z-annex hook:preinit-<-> <->]}\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-post <->]}\n    )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n        \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_dir\" ${${key##(zinit|z-annex) hook:}%% <->} update || \\\n            return $(( 10 - $? ))\n    done\n\n    # Check if repository has a remote set, if it is _local\n    if [[ -f $local_dir/.git/config ]]; then\n        local -a config\n        config=( ${(f)\"$(<$local_dir/.git/config)\"} )\n        if [[ ${#${(M)config[@]:#\\[remote[[:blank:]]*\\]}} -eq 0 ]]; then\n            (( !OPTS[opt_-q,--quiet] )) && {\n                .zinit-any-colorify-as-uspl2 \"$id_as\"\n                [[ $id_as = _local/* ]] && builtin print -r -- \"Skipping local plugin $REPLY\" || \\\n                    builtin print -r -- \"$REPLY doesn't have a remote set, will not fetch\"\n            }\n            return 1\n        fi\n    fi\n\n    command rm -f $local_dir/.zinit_lastupd\n\n    if (( 1 )); then\n        if [[ -z ${ice[is_release]} && ${ice[from]} = (gh-r|github-rel|cygwin) ]] {\n            ice[is_release]=true\n        }\n\n        integer count is_release=0\n        for (( count = 1; count <= 5; ++ count )) {\n            if (( ${+ice[is_release${count:#1}]} )) {\n                is_release=1\n            }\n        }\n\n        (( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source ${ZINIT[BIN_DIR]}\"/zinit-install.zsh\"\n        if [[ $ice[from] == (gh-r|github-rel) ]] {\n            {\n                ICE=( \"${(kv)ice[@]}\" )\n                .zinit-get-latest-gh-r-url-part \"$user\" \"$plugin\" || return $?\n            } always {\n                ICE=()\n            }\n        } else {\n            REPLY=\"\"\n        }\n\n        if (( is_release )) {\n            count=0\n            for REPLY ( $reply ) {\n                count+=1\n                local version=${REPLY/(#b)(\\/[^\\/]##)(#c4,4)\\/([^\\/]##)*/${match[2]}}\n                if [[ ${ice[is_release${count:#1}]} = $REPLY ]] {\n                    (( ${+ice[run-atpull]} || OPTS[opt_-u,--urge] )) && \\\n                        ZINIT[annex-multi-flag:pull-active]=1 || \\\n                        ZINIT[annex-multi-flag:pull-active]=0\n                } else {\n                    ZINIT[annex-multi-flag:pull-active]=2\n                    break\n                }\n            }\n            if (( ZINIT[annex-multi-flag:pull-active] <= 1 && !OPTS[opt_-q,--quiet] )) {\n                +zi-log \"{info}[{pre}${ice[from]}{info}]{rst} latest version ({version}${version}{rst}) already installed\"\n            }\n        }\n\n        if (( 1 )) {\n            if (( ZINIT[annex-multi-flag:pull-active] >= 1 )) {\n                if (( OPTS[opt_-q,--quiet] && !PUPDATE )) {\n                    .zinit-any-colorify-as-uspl2 \"$id_as\"\n                    (( ZINIT[first-plugin-mark] )) && {\n                        ZINIT[first-plugin-mark]=0\n                    } || builtin print\n                    builtin print \"\\rUpdating $REPLY\"\n                }\n\n                ICE=( \"${(kv)ice[@]}\" )\n                # Run annexes' atpull hooks (the before atpull-ice ones).\n                # The gh-r / GitHub releases block.\n                reply=(\n                    ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-pre <->]}\n                    ${${(M)ICE[atpull]#\\!}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                    ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-post <->]}\n                )\n                for key in \"${reply[@]}\"; do\n                    arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                    \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_dir\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:bin\n                    hook_rc=$?\n                    [[ \"$hook_rc\" -ne 0 ]] && {\n                        # note: this will effectively return the last != 0 rc\n                        retval=\"$hook_rc\"\n                        builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                    }\n                done\n\n                if (( ZINIT[annex-multi-flag:pull-active] >= 2 )) {\n                    if ! .zinit-setup-plugin-dir \"$user\" \"$plugin\" \"$id_as\" release -u $version; then\n                        ZINIT[annex-multi-flag:pull-active]=0\n                    fi\n                    if (( OPTS[opt_-q,--quiet] != 1 )) {\n                        builtin print\n                    }\n                }\n                ICE=()\n            }\n        }\n\n        if [[ -d $local_dir/.git ]] && ( builtin cd -q $local_dir ; command git show-ref --verify --quiet refs/heads/main ); then\n            local main_branch=main\n        else\n            local main_branch=master\n        fi\n\n        if (( ! is_release )) {\n            ( builtin cd -q \"$local_dir\" || return 1\n              integer had_output=0\n              local IFS=$'\\n'\n              command git fetch --quiet && \\\n                command git --no-pager log --color --date=short --pretty=format:'%Cgreen%cd %h %Creset%s%n' ..FETCH_HEAD | \\\n                while read line; do\n                  [[ -n ${line%%[[:space:]]##} ]] && {\n                      [[ $had_output -eq 0 ]] && {\n                          had_output=1\n                          if (( OPTS[opt_-q,--quiet] && !PUPDATE )) {\n                              .zinit-any-colorify-as-uspl2 \"$id_as\"\n                              (( ZINIT[first-plugin-mark] )) && {\n                                  ZINIT[first-plugin-mark]=0\n                              } || builtin print\n                              builtin print \"Updating $REPLY\"\n                          }\n                      }\n                      builtin print $line\n                  }\n                done | \\\n                command tee .zinit_lastupd | \\\n                .zinit-pager &\n\n              integer pager_pid=$!\n              { sleep 20 && kill -9 $pager_pid 2>/dev/null 1>&2; } &!\n              { wait $pager_pid; } > /dev/null 2>&1\n\n              local -a log\n              { log=( ${(@f)\"$(<$local_dir/.zinit_lastupd)\"} ); } 2>/dev/null\n              command rm -f $local_dir/.zinit_lastupd\n\n              if [[ ${#log} -gt 0 ]] {\n                  ZINIT[annex-multi-flag:pull-active]=2\n              } else {\n                  if (( ${+ice[run-atpull]} || OPTS[opt_-u,--urge] )) {\n                      ZINIT[annex-multi-flag:pull-active]=1\n\n                      # Handle the snippet/plugin boundary in the messages\n                      if (( OPTS[opt_-q,--quiet] && !PUPDATE )) {\n                          .zinit-any-colorify-as-uspl2 \"$id_as\"\n                          (( ZINIT[first-plugin-mark] )) && {\n                              ZINIT[first-plugin-mark]=0\n                          } || builtin print\n                          builtin print \"\\rUpdating $REPLY\"\n                      }\n                  } else {\n                      ZINIT[annex-multi-flag:pull-active]=0\n                  }\n              }\n\n              if (( ZINIT[annex-multi-flag:pull-active] >= 1 )) {\n                  ICE=( \"${(kv)ice[@]}\" )\n                  # Run annexes' atpull hooks (the before atpull-ice ones).\n                  # The regular Git-plugins block.\n                  reply=(\n                      ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-pre <->]}\n                      ${${(M)ICE[atpull]#\\!}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                      ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-post <->]}\n                  )\n                  for key in \"${reply[@]}\"; do\n                      arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                      \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_dir\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:git\n                      hook_rc=$?\n                      [[ \"$hook_rc\" -ne 0 ]] && {\n                          # note: this will effectively return the last != 0 rc\n                          retval=\"$hook_rc\"\n                          builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                      }\n                  done\n                  ICE=()\n                  (( ZINIT[annex-multi-flag:pull-active] >= 2 )) && command git pull --no-stat ${=ice[pullopts]:---ff-only} origin ${ice[ver]:-$main_branch} |& command grep -E -v '(FETCH_HEAD|up.to.date\\.|From.*://)'\n              }\n              return ${ZINIT[annex-multi-flag:pull-active]}\n            )\n            ZINIT[annex-multi-flag:pull-active]=$?\n        }\n\n        if [[ -d $local_dir/.git ]]; then\n            (\n                builtin cd -q \"$local_dir\" # || return 1 - don't return, maybe it's some hook's logic\n                if (( OPTS[opt_-q,--quiet] )) {\n                    command git pull --recurse-submodules ${=ice[pullopts]:---ff-only} origin ${ice[ver]:-$main_branch} &> /dev/null\n                } else {\n                    command git pull --recurse-submodules ${=ice[pullopts]:---ff-only} origin ${ice[ver]:-$main_branch} |& command grep -E -v '(FETCH_HEAD|up.to.date\\.|From.*://)'\n                }\n            )\n        fi\n        if [[ -n ${(v)ice[(I)(mv|cp|atpull|ps-on-update|cargo)]} || $+ice[sbin]$+ice[make]$+ice[extract]$+ice[configure] -ne 0 ]] {\n            if (( !OPTS[opt_-q,--quiet] && ZINIT[annex-multi-flag:pull-active] == 1 )) {\n                +zi-log -n \"{pre}[update]{msg3} Continuing with the update because \"\n                (( ${+ice[run-atpull]} )) && \\\n                    +zi-log \"{ice}run-atpull{apo}''{msg3} ice given.{rst}\" || \\\n                    +zi-log \"{opt}-u{msg3}/{opt}--urge{msg3} given.{rst}\"\n            }\n        }\n\n        # Any new commits?\n        if (( ZINIT[annex-multi-flag:pull-active] >= 1  )) {\n            ICE=( \"${(kv)ice[@]}\" )\n            # Run annexes' atpull hooks (the before atpull[^!]…-ice ones).\n            # Block common for Git and gh-r plugins.\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:no-e-\\!atpull-pre <->]}\n                ${${ICE[atpull]:#\\!*}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:no-e-\\!atpull-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_dir\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update\n                hook_rc=\"$?\"\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    # note: this will effectively return the last != 0 rc\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n\n            # Run annexes' atpull hooks (the after atpull-ice ones).\n            # Block common for Git and gh-r plugins.\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:atpull-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:atpull-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:atpull-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_dir\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update\n                hook_rc=\"$?\"\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    # note: this will effectively return the last != 0 rc\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n            ICE=()\n        }\n\n        # Store ices to disk at update of plugin\n        .zinit-store-ices \"$local_dir/._zinit\" ice \"\" \"\" \"\" \"\"\n    fi\n\n    # Run annexes' atpull hooks (the `always' after atpull-ice ones)\n    # Block common for Git and gh-r plugins.\n    ICE=( \"${(kv)ice[@]}\" )\n    reply=(\n        ${(on)ZINIT_EXTS2[(I)zinit hook:%atpull-pre <->]}\n        ${(on)ZINIT_EXTS[(I)z-annex hook:%atpull-<-> <->]}\n        ${(on)ZINIT_EXTS2[(I)zinit hook:%atpull-post <->]}\n    )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n        \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_dir\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:$ZINIT[annex-multi-flag:pull-active]\n        hook_rc=$?\n        [[ \"$hook_rc\" -ne 0 ]] && {\n            # note: this will effectively return the last != 0 rc\n            retval=\"$hook_rc\"\n            builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n        }\n    done\n    ICE=()\n\n    typeset -ga INSTALLED_EXECS\n    { INSTALLED_EXECS=( \"${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zinit-execs.$$.lst)}\" ) } 2>/dev/null\n\n    if [[ -e ${TMPDIR:-${TMPDIR:-/tmp}}/zinit.skipped_comps.$$.lst || -e ${TMPDIR:-${TMPDIR:-/tmp}}/zinit.installed_comps.$$.lst ]] {\n        typeset -ga INSTALLED_COMPS SKIPPED_COMPS\n        { INSTALLED_COMPS=( \"${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zinit.installed_comps.$$.lst)}\" ) } 2>/dev/null\n        { SKIPPED_COMPS=( \"${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zinit.skipped_comps.$$.lst)}\" ) } 2>/dev/null\n    }\n\n    if [[ -e ${TMPDIR:-${TMPDIR:-/tmp}}/zinit.compiled.$$.lst ]] {\n        typeset -ga ADD_COMPILED\n        { ADD_COMPILED=( \"${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zinit.compiled.$$.lst)}\" ) } 2>/dev/null\n    }\n\n    if (( PUPDATE && ZINIT[annex-multi-flag:pull-active] > 0 )) {\n        builtin print ${ZINIT[annex-multi-flag:pull-active]} >! $PUFILE.ind\n    }\n\n    return $retval\n} # ]]]\n# FUNCTION: .zinit-update-or-status-all [[[\n# Updates (git pull) or does `git status` for all existing plugins.\n# This includes also plugins that are not loaded into Zsh (but exist\n# on disk). Also updates (i.e. redownloads) snippets.\n#\n# User-action entry point.\n.zinit-update-or-status-all() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob nullglob warncreateglobal typesetsilent noshortloops\n\n    local -F2 SECONDS=0\n\n    .zinit-self-update -q\n\n    [[ $2 = restart ]] && \\\n        +zi-log \"{msg2}Restarting the update with the new codebase loaded.{rst}\"$'\\n'\n\n    local file\n    integer sum el update_rc\n    for file ( \"\" -side -install -autoload ) {\n        .zinit-get-mtime-into \"${ZINIT[BIN_DIR]}/zinit$file.zsh\" el; sum+=el\n    }\n\n    # Reload Zinit?\n    if [[ $2 != restart ]] && (( ZINIT[mtime] + ZINIT[mtime-side] +\n        ZINIT[mtime-install] + ZINIT[mtime-autoload] != sum\n    )) {\n        +zi-log \"{msg2}Detected Zinit update in another session -\" \\\n            \"{pre}reloading Zinit{msg2}{…}{rst}\"\n        source $ZINIT[BIN_DIR]/zinit.zsh\n        source $ZINIT[BIN_DIR]/zinit-side.zsh\n        source $ZINIT[BIN_DIR]/zinit-install.zsh\n        source $ZINIT[BIN_DIR]/zinit-autoload.zsh\n        for file ( \"\" -side -install -autoload ) {\n            .zinit-get-mtime-into \"${ZINIT[BIN_DIR]}/zinit$file.zsh\" \"ZINIT[mtime$file]\"\n        }\n        +zi-log \"%B{pname}Done.{rst}\"$'\\n'\n        .zinit-update-or-status-all \"$1\" restart\n        return $?\n    }\n\n    integer retval\n\n    if (( OPTS[opt_-p,--parallel] )) && [[ $1 = update ]] {\n        (( !OPTS[opt_-q,--quiet] )) && \\\n            +zi-log '{info2}Parallel Update Starts Now{…}{rst}'\n        .zinit-update-all-parallel\n        retval=$?\n        .zinit-compinit 1 1 &>/dev/null\n        rehash\n        if (( !OPTS[opt_-q,--quiet] )) {\n            +zi-log \"{msg2}The update took {obj}${SECONDS}{msg2} seconds{rst}\"\n        }\n        return $retval\n    }\n\n    local st=$1 id_as repo snip pd user plugin\n    integer PUPDATE=0\n\n    local -A ICE\n\n\n    if (( OPTS[opt_-s,--snippets] || !OPTS[opt_-l,--plugins] )) {\n        local -a snipps\n        snipps=( ${ZINIT[SNIPPETS_DIR]}/**/(._zinit|._zplugin)(ND) )\n\n        [[ $st != status && ${OPTS[opt_-q,--quiet]} != 1 && -n $snipps ]] && \\\n            +zi-log \"{info}Note:{rst} updating also unloaded snippets\"\n\n        for snip ( ${ZINIT[SNIPPETS_DIR]}/**/(._zinit|._zplugin)/mode(D) ) {\n            [[ ! -f ${snip:h}/url ]] && continue\n            [[ -f ${snip:h}/id-as ]] && \\\n                id_as=\"$(<${snip:h}/id-as)\" || \\\n                id_as=\n            .zinit-update-or-status-snippet \"$st\" \"${id_as:-$(<${snip:h}/url)}\"\n            ICE=()\n        }\n        [[ -n $snipps ]] && builtin print\n    }\n\n    ICE=()\n\n    if (( OPTS[opt_-s,--snippets] && !OPTS[opt_-l,--plugins] )) {\n        return\n    }\n\n    if [[ $st = status ]]; then\n        (( !OPTS[opt_-q,--quiet] )) && \\\n            +zi-log \"{info}Note:{rst} status done also for unloaded plugins\"\n    else\n        (( !OPTS[opt_-q,--quiet] )) && \\\n            +zi-log \"{info}Note:{rst} updating also unloaded plugins\"\n    fi\n\n    ZINIT[first-plugin-mark]=init\n\n    for repo in ${ZINIT[PLUGINS_DIR]}/*; do\n        pd=${repo:t}\n\n        # Two special cases\n        [[ $pd = custom || $pd = _local---zinit ]] && continue\n\n        .zinit-any-colorify-as-uspl2 \"$pd\"\n\n        # Check if repository has a remote set\n        if [[ -f $repo/.git/config ]]; then\n            local -a config\n            config=( ${(f)\"$(<$repo/.git/config)\"} )\n            if [[ ${#${(M)config[@]:#\\[remote[[:blank:]]*\\]}} -eq 0 ]]; then\n                if (( !OPTS[opt_-q,--quiet] )) {\n                    [[ $pd = _local---* ]] && \\\n                        builtin print -- \"\\nSkipping local plugin $REPLY\" || \\\n                        builtin print \"\\n$REPLY doesn't have a remote set, will not fetch\"\n                }\n                continue\n            fi\n        fi\n\n        .zinit-any-to-user-plugin \"$pd\"\n        local user=${reply[-2]} plugin=${reply[-1]}\n\n        # Must be a git repository or a binary release\n        if [[ ! -d $repo/.git && ! -f $repo/._zinit/is_release ]]; then\n            (( !OPTS[opt_-q,--quiet] )) && \\\n                builtin print \"$REPLY: not a git repository\"\n            continue\n        fi\n\n        if [[ $st = status ]]; then\n            builtin print \"\\nStatus for plugin $REPLY\"\n            ( builtin cd -q \"$repo\"; command git status )\n        else\n            (( !OPTS[opt_-q,--quiet] )) && builtin print \"Updating $REPLY\" || builtin print -n .\n            .zinit-update-or-status update \"$user\" \"$plugin\"\n            update_rc=$?\n            [[ $update_rc -ne 0 ]] && {\n                +zi-log \"🚧{warn}Warning: {pid}${user}/${plugin} {warn}update returned {obj}$update_rc\"\n                retval=$?\n            }\n        fi\n    done\n\n    .zinit-compinit 1 1 &>/dev/null\n    if (( !OPTS[opt_-q,--quiet] )) {\n        +zi-log \"{msg2}The update took {obj}${SECONDS}{msg2} seconds{rst}\"\n    }\n\n    return \"$retval\"\n} # ]]]\n# FUNCTION: .zinit-update-or-status-snippet [[[\n#\n# Implements update or status operation for snippet given by URL.\n#\n# $1 - \"status\" or \"update\"\n# $2 - snippet URL\n.zinit-update-or-status-snippet() {\n    local st=\"$1\" URL=\"${2%/}\" local_dir filename is_snippet\n    (( ${#ICE[@]} > 0 )) && { ZINIT_SICE[$URL]=\"\"; local nf=\"-nftid\"; }\n    local -A ICE2\n    .zinit-compute-ice \"$URL\" \"pack$nf\" \\\n        ICE2 local_dir filename is_snippet || return 1\n\n    integer retval\n\n    if [[ \"$st\" = \"status\" ]]; then\n        if (( ${+ICE2[svn]} )); then\n            builtin print -r -- \"${ZINIT[col-info]}Status for ${${${local_dir:h}:t}##*--}/${local_dir:t}${ZINIT[col-rst]}\"\n            ( builtin cd -q \"$local_dir\"; command svn status -vu )\n            retval=$?\n            builtin print\n        else\n            builtin print -r -- \"${ZINIT[col-info]}Status for ${${local_dir:h}##*--}/$filename${ZINIT[col-rst]}\"\n            ( builtin cd -q \"$local_dir\"; command ls -lth $filename )\n            retval=$?\n            builtin print\n        fi\n    else\n        (( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source ${ZINIT[BIN_DIR]}\"/zinit-install.zsh\"\n        ICE=( \"${(kv)ICE2[@]}\" )\n        .zinit-update-snippet \"${ICE2[teleid]:-$URL}\"\n        retval=$?\n    fi\n\n    ICE=()\n\n    if (( PUPDATE && ZINIT[annex-multi-flag:pull-active] > 0 )) {\n        builtin print ${ZINIT[annex-multi-flag:pull-active]} >! $PUFILE.ind\n    }\n\n    return $retval\n} # ]]]\n# FUNCTION: .zinit-wait-for-update-jobs [[[\n.zinit-wait-for-update-jobs() {\n    local tpe=$1\n    if (( counter > OPTS[value] || main_counter == 0 )) {\n        wait ${(k)PUAssocArray}\n        local ind_file\n        for ind_file ( ${^${(von)PUAssocArray}}.ind(DN.) ) {\n            command cat ${ind_file:r}\n            (( !OPTS[opt_-d,--debug] && !ZINIT[DEBUG_MODE] )) && \\\n                command rm -f $ind_file\n        }\n        (( !OPTS[opt_-d,--debug] && !ZINIT[DEBUG_MODE] )) && \\\n            command rm -f ${(v)PUAssocArray}\n        counter=0\n        PUAssocArray=()\n    } elif (( counter == 1 && !OPTS[opt_-q,--quiet] )) {\n        +zi-log \"{obj}Spawning the next{num}\" \\\n            \"${OPTS[value]}{obj} concurrent update jobs\" \\\n            \"({msg2}${tpe}{obj}){…}{rst}\"\n    }\n} # ]]]\n\n# FUNCTION: zi::version [[[\n# Shows usage information.\n#\n# User-action entry point.\nzi::version() {\n\t+zi-log \"zinit{cmd} $(command git --git-dir=$(realpath ${ZINIT[BIN_DIR]}/.git) describe --tags) {rst}(${OSTYPE}_${CPUTYPE})\"\n\treturn $?\n} # ]]]\n\n# vim: set fenc=utf8 ffs=unix foldmarker=[[[,]]] foldmethod=marker ft=zsh list et sts=4 sw=4 ts=4 tw=100:\n"
        },
        {
          "name": "zinit-install.zsh",
          "type": "blob",
          "size": 101.994140625,
          "content": "# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4;\n# -*-\n# Copyright (c) 2016-2020 Sebastian Gniazdowski and contributors.\n\nbuiltin source \"${ZINIT[BIN_DIR]}/zinit-side.zsh\" || {\n    builtin print -P \"${ZINIT[col-error]}ERROR:%f%b Couldn't find ${ZINIT[col-obj]}zinit-side.zsh%f%b.\"\n    return 1\n}\n\n# FUNCTION: .zinit-jq-check [[[\n# Check if jq is available and outputs an error message with instructions if\n# that's not the case\n.zinit-jq-check() {\n    command -v jq >/dev/null && return 0\n\n    +zi-log \"{error}❌ ERROR: jq binary not found\" \\\n        \"{nl}{u-warn}Please install jq:{rst}\" \\\n        \"https://github.com/jqlang/jq\" \\\n        \"{nl}{u-warn}To do so with zinit, please refer to:{rst}\" \\\n        \"https://github.com/zdharma-continuum/zinit/wiki/%F0%9F%A7%8A-Recommended-ices#jq\"\n    return 1\n} # ]]]\n# FUNCTION: .zinit-json-get-value [[[\n# Wrapper around jq that return the value of a property\n#\n# $1: JSON structure\n# $2: jq path\n.zinit-json-get-value() {\n    .zinit-jq-check || return 1\n\n    local jsonstr=$1 jqpath=$2\n    jq -er \".${jqpath}\" <<< \"$jsonstr\"\n} # ]]]\n# FUNCTION: .zinit-json-to-array [[[\n# Wrapper around jq that sets key/values of an associative array, replicating\n# the structure of a given JSON object\n#\n# $1: JSON structure\n# $2: jq path\n# $3: name of the associative array to store the key/value pairs in\n.zinit-json-to-array() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt localoptions noglob\n\n    .zinit-jq-check || return 1\n\n    local jsonstr=$1 jqpath=$2 varname=$3\n\n    (( ${(P)+varname} )) || typeset -gA \"$varname\"\n\n    # NOTE We're not using @sh for the keys on purpose. Associative\n    # array keys are used verbatim by zsh:\n    # typeset -A a; a[key]=one; a['key']=two; echo ${(k)a}\n    # 'key' key\n    local evalstr=$(command jq -er --arg varname $varname \\\n        '.'${jqpath}' | to_entries |\n        map($varname + \"[\\(.key)]=\\(.value | @sh);\")[]' \\\n        <<< \"$jsonstr\")\n    eval \"$evalstr\"\n} # ]]]\n# FUNCTION: .zinit-get-package [[[\n.zinit-get-package() {\n    .zinit-jq-check || return 1\n\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes\n\n    local user=$1 pkg=$2 plugin=$2 id_as=$3 dir=$4 profile=$5 \\\n        ver=${ICE[ver]} local_path=${ZINIT[PLUGINS_DIR]}/${3//\\//---} \\\n        pkgjson tmpfile=${$(mktemp):-${TMPDIR:-/tmp}/zsh.xYzAbc123}\n    local URL=https://raw.githubusercontent.com/${ZINIT[PACKAGES_REPO]}/${ver:-${ZINIT[PACKAGES_BRANCH]}}/${pkg}/package.json\n\n    # Consume (i.e., delete) the ver ice to avoid being consumed again at git-clone time\n    [[ -n \"$ver\" ]] && unset 'ICE[ver]'\n\n    local pro_sep=\"{rst}, {profile}\" epro_sep=\"{error}, {profile}\" \\\n        tool_sep=\"{rst}, {cmd}\" \\\n        lhi_hl=\"{lhi}\" profile_hl=\"{profile}\"\n\n    trap \"rmdir ${(qqq)local_path} 2>/dev/null; return 1\" INT TERM QUIT HUP\n    trap \"rmdir ${(qqq)local_path} 2>/dev/null\" EXIT\n\n    # Check if we were provided with a local path to a package.json\n    # as in:\n    # zinit pack'/zp/firefox-dev/package.json:default' for firefox-dev\n    if [[ $profile == ./* || $profile == /* ]] {\n        local localpkg=1\n        # FIXME below only works if there are no ':' in the path\n        tmpfile=${profile%:*}\n        profile=${${${(M)profile:#*:*}:+${profile#*:}}:-default}\n    } elif { ! .zinit-download-file-stdout $URL 0 1 2>/dev/null > $tmpfile } {\n        # retry\n        command rm -f $tmpfile\n        .zinit-download-file-stdout $URL 1 1 2>/dev/null >1 $tmpfile\n    }\n\n    # load json from file\n    [[ -e $tmpfile ]] && pkgjson=\"$(<$tmpfile)\"\n\n    # Set package name (used later in the output)\n    local pkgname=${${id_as##_unknown}:-${pkg:-${plugin}}}\n    [[ -n \"$localpkg\" ]] && pkgname=\"{pid}$pkgname{rst} {note}[$tmpfile]{rst}\"\n\n    if [[ -z $pkgjson ]] {\n        +zi-log \"{error}❌ Error: the package {hi}${pkgname}\" \\\n                       \"{error}couldn't be found.{rst}\"\n        return 1\n    }\n\n    # root field, where the relevant data is stored\n    local json_root='[\"zsh-data\"]'\n    local json_ices=\"${json_root}[\\\"zinit-ices\\\"]\"\n    local json_meta=\"${json_root}[\\\"plugin-info\\\"]\"\n\n    local -a profiles\n    profiles=(\"${(@f)$(.zinit-json-get-value \"$pkgjson\" \"${json_ices} | keys[]\")}\") \\\n        || return 1\n\n    # Check if user requested an unknown profile\n    if ! (( ${profiles[(I)${profile}]} )) {\n        # Assumption: the default profile is the first in the table (-> different color).\n        +zi-log \"{u-warn}Error{b-warn}:{error} the profile {apo}\\`{hi}$profile{apo}\\`\" \\\n            \"{error}couldn't be found, aborting. Available profiles are:\" \\\n            \"{lhi}${(pj:$epro_sep:)profiles[@]}{error}.{rst}\"\n        return 1\n    }\n    local json_profile=\"${json_ices}[\\\"${profile}\\\"]\"\n\n    local -A metadata\n    .zinit-json-to-array \"$pkgjson\" \"$json_meta\" metadata\n    if [[ \"$?\" -ne 0 || -z \"$metadata\" ]] {\n        +zi-log '{error}❌ ERROR: Failed to retrieve metadata from package.json'\n        return 1\n    }\n\n    local user=${metadata[user]} plugin=${metadata[plugin]} \\\n        message=${metadata[message]} url=${metadata[url]}\n\n    .zinit-json-to-array \"$pkgjson\" \"$json_profile\" ICE\n    local -a requirements\n\n    # FIXME requires shouldn't be stored under zinit-ices...\n    if [[ -n \"$ICE[requires]\" ]] {\n        # split requirements on ';'\n        requirements=(${(s.;.)${ICE[requires]}})\n        unset 'ICE[requires]'\n    }\n\n    [[ ${ICE[as]} == program ]] && ICE[as]=\"command\"\n    [[ -n ${ICE[on-update-of]} ]] && ICE[subscribe]=\"${ICE[subscribe]:-${ICE[on-update-of]}}\"\n    [[ -n ${ICE[pick]} ]] && ICE[pick]=\"${ICE[pick]//\\$ZPFX/${ZPFX%/}}\"\n\n    # FIXME Do we even need that? If yes, we may want to do that in\n    # .zinit-json-to-array\n    if [[ -n ${ICE[id-as]} ]] {\n        @zinit-substitute 'ICE[id-as]'\n        local -A map\n        map=( \"\\\"\" \"\\\\\\\"\" \"\\\\\" \"\\\\\" )\n        eval \"ICE[id-as]=\\\"${ICE[id-as]//(#m)[\\\"\\\\]/${map[$MATCH]}}\\\"\"\n    }\n\n    +zi-log \"{info3}Package{ehi}:{rst} ${pkgname}. Selected\" \\\n        \"profile{ehi}:{rst} {hi}$profile{rst}. Available\" \\\n        \"profiles:${${${(M)profile:#default}:+$lhi_hl}:-$profile_hl}\" \\\n        \"${(pj:$pro_sep:)profiles[@]}{rst}.\"\n\n    if [[ $profile != *bgn* && -n ${(M)profiles[@]:#*bgn*} ]] {\n        +zi-log \"{note}Note:{rst} The {apo}\\`{profile}bgn{glob}*{apo}\\`{rst}\" \\\n            \"profiles (if any are available) are the recommended ones (the reason\" \\\n            \"is that they expose the binaries provided by the package without\" \\\n            \"altering (i.e.: {slight}cluttering{rst}{…}) the {var}\\$PATH{rst}\" \\\n            \"environment variable).\"\n    }\n\n    local required\n    for required ( $requirements ) {\n        if [[ $required == (bgn|dl|monitor) ]]; then\n            if [[ ( $required == bgn && -z ${(k)ZINIT_EXTS[(r)<-> z-annex-data: zinit-annex-bin-gem-node *]} ) || \\\n                ( $required == dl && -z ${(k)ZINIT_EXTS[(r)<-> z-annex-data: zinit-annex-patch-dl *]} ) || \\\n                ( $required == monitor && -z ${(k)ZINIT_EXTS[(r)<-> z-annex-data: zinit-annex-readurl *]} )\n            ]]; then\n                local -A namemap\n                namemap=( bgn bin-gem-node dl patch-dl monitor readurl )\n                +zi-log -n \"{u-warn}ERROR{b-warn}: {error}the \"\n                if [[ -z ${(MS)ICE[requires]##(\\;|(#s))$required(\\;|(#e))} ]]; then\n                    +zi-log -n \"{error}requested profile {apo}\\`{hi}$profile{apo}\\`{error} \"\n                else\n                    +zi-log -n \"{error}package {pid}$pkg{error} \"\n                fi\n                +zi-log '{error}requires the {apo}`{annex}'${namemap[$required]}'{apo}`' \\\n                    \"{error}annex, which is currently not installed.\" \\\n                    \"{nl}{nl}If you'd like to install it, you can visit its homepage:\" \\\n                    \"{nl}– {url}https://github.com/zdharma-continuum/zinit-annex-${(L)namemap[$required]}{rst}\" \\\n                    \"{nl}for instructions.\"\n                (( ${#profiles[@]:#$profile} > 0 )) && \\\n                    +zi-log \"{nl}Other available profiles are:\" \\\n\"{profile}${(pj:$pro_sep:)${profiles[@]:#$profile}}{rst}.\"\n\n                return 1\n            fi\n        else\n            if ! command -v $required &>/dev/null; then\n                +zi-log -n \"{u-warn}ERROR{b-warn}: {error}the \"\n                if [[ -n ${(MS)ICE[requires]##(\\;|(#s))$required(\\;|(#e))} ]]; then\n                    +zi-log -n \"{error}requested profile {apo}\\`{hi}$profile{apo}\\`{error} \"\n                else\n                    +zi-log -n \"{error}package {pid}$pkg{error} \"\n                fi\n                +zi-log '{error}requires a {apo}`{cmd}'$required'{apo}`{error}' \\\n                    \"command to be available in {var}\\$PATH{error}.{rst}\" \\\n                    \"{nl}{error}The package cannot be installed unless the\" \\\n                    \"command will be available.\"\n                (( ${#profiles[@]:#$profile} > 0 )) && \\\n                    +zi-log \"{nl}Other available profiles are:\" \\\n                        \"{profile}${(pj:$pro_sep:)${profiles[@]:#$profile}}{rst}.\"\n                return 1\n            fi\n        fi\n    }\n\n    if [[ -n ${ICE[dl]} && -z ${(k)ZINIT_EXTS[(r)<-> z-annex-data: zinit-annex-patch-dl *]} ]] {\n        +zi-log \"{nl}{u-warn}WARNING{b-warn}:{rst} the profile uses\" \\\n            \"{ice}dl''{rst} ice however there's currently no {annex}zinit-annex-patch-dl{rst}\" \\\n            \"annex loaded, which provides it.\"\n        +zi-log \"The ice will be inactive, i.e.: no additional\" \\\n            \"files will become downloaded (the ice downloads the given URLs).\" \\\n            \"The package should still work, as it doesn't indicate to\" \\\n            \"{u}{slight}require{rst} the annex.\"\n        +zi-log \"{nl}You can download the\" \\\n            \"annex from its homepage at {url}https://github.com/zdharma-continuum/zinit-annex-patch-dl{rst}.\"\n    }\n\n    [[ -n ${message} ]] && +zi-log \"{info}${message}{rst}\"\n\n    if (( ${+ICE[is-snippet]} )) {\n        reply=( \"\" \"$url\" )\n        REPLY=snippet\n        return 0\n    }\n\n    # FIXME This part below is a bit odd since it essentially replicates what\n    # the dl ice supposed to be doing.\n    # TL;DR below downloads whatever url is stored in the \"_resolved\" field\n    if (( !${+ICE[git]} && !${+ICE[from]} )) {\n        (\n            local -A jsondata\n            local URL=$(.zinit-json-get-value \"$pkgjson\" \"_resolved\")\n            local fname=\"${${URL%%\\?*}:t}\"\n\n            command mkdir -p $dir || {\n                +zi-log \"{u-warn}Error{b-warn}:{error} Couldn't create directory:\" \\\n                    \"{dir}$dir{error}, aborting.{rst}\"\n                return 1\n            }\n            builtin cd -q $dir || return 1\n\n            +zi-log \"Downloading tarball for {pid}$plugin{rst}{…}\"\n\n            if { ! .zinit-download-file-stdout \"$URL\" 0 1 >! \"$fname\" } {\n                if { ! .zinit-download-file-stdout \"$URL\" 1 1 >! \"$fname\" } {\n                    command rm -f \"$fname\"\n                    +zi-log \"Download of the file {apo}\\`{file}$fname{apo}\\`{rst}\" \\\n                        \"failed. No available download tool? One of:\" \\\n                        \"{cmd}${(pj:$tool_sep:)${=:-curl wget lftp lynx}}{rst}.\"\n\n                    return 1\n                }\n            }\n\n            # --move is default (or as explicit, when extract'!…' is given)\n            # Also possible is --move2 when extract'!!…' given\n            ziextract \"$fname\" ${ICE[extract]---move} ${${(M)ICE[extract]:#!([^!]|(#e))*}:+--move} ${${(M)ICE[extract]:#!!*}:+--move2}\n            return 0\n        ) && {\n            reply=( \"$user\" \"$plugin\" )\n            REPLY=tarball\n        }\n    } else {\n            reply=( \"${ICE[user]:-$user}\" \"${ICE[plugin]:-$plugin}\" )\n            if [[ ${ICE[from]} = (|gh-r|github-rel) ]]; then\n                REPLY=github\n            else\n                REPLY=unknown\n            fi\n    }\n\n    return $?\n} # ]]]\n# FUNCTION: .zinit-setup-plugin-dir [[[\n# Clones given plugin into PLUGIN_DIR. Supports multiple\n# sites (respecting `from' and `proto' ice modifiers).\n# Invokes compilation of plugin's main file.\n#\n# $1 - user\n# $2 - plugin\n.zinit-setup-plugin-dir() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal noshortloops rcquotes\n\n    local user=$1 plugin=$2 id_as=$3 remote_url_path=${1:+$1/}$2 \\\n        local_path tpe=$4 update=$5 version=$6\n\n    if .zinit-get-object-path plugin \"$id_as\" && [[ -z $update ]] {\n        +zi-log \"{u-warn}ERROR{b-warn}:{error} A plugin named {pid}$id_as{error}\" \\\n                \"already exists, aborting.\"\n        return 1\n    }\n    local_path=$REPLY\n\n    trap \"rmdir ${(qqq)local_path}/._zinit ${(qqq)local_path} 2>/dev/null\" EXIT\n    trap \"rmdir ${(qqq)local_path}/._zinit ${(qqq)local_path} 2>/dev/null; return 1\" INT TERM QUIT HUP\n\n    local -A sites\n    sites=(\n        github    github.com\n        gh        github.com\n        bitbucket bitbucket.org\n        bb        bitbucket.org\n        gitlab    gitlab.com\n        gl        gitlab.com\n        notabug   notabug.org\n        nb        notabug.org\n        github-rel github.com/$remote_url_path/releases\n        gh-r      github.com/$remote_url_path/releases\n        cygwin    cygwin\n    )\n\n    ZINIT[annex-multi-flag:pull-active]=${${${(M)update:#-u}:+${ZINIT[annex-multi-flag:pull-active]}}:-2}\n\n    local -a arr\n\n    if [[ $user = _local ]]; then\n        builtin print \"Warning: no local plugin \\`$plugin\\'.\"\n        builtin print \"(should be located at: $local_path)\"\n        return 1\n    fi\n\n    command rm -f ${TMPDIR:-/tmp}/zinit-execs.$$.lst ${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst \\\n                  ${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst ${TMPDIR:-/tmp}/zinit.compiled.$$.lst\n\n    if [[ $tpe != tarball ]] {\n        if [[ -z $update ]] {\n            .zinit-any-colorify-as-uspl2 \"$user\" \"$plugin\"\n            local pid_hl='{pid}' id_msg_part=\" (at label: {id-as}$id_as{rst})\"\n            +zi-log \"{nl}{i} Downloading {b}{file}$user${user:+/}$plugin{rst} ${${${id_as:#$user/$plugin}}:+$id_msg_part}{rst}\"\n        }\n\n        local site\n        [[ -n ${ICE[from]} ]] && site=${sites[${ICE[from]}]}\n        if [[ -z $site && ${ICE[from]} = *(gh-r|github-rel)* ]] {\n            site=${ICE[from]/(gh-r|github-re)/${sites[gh-r]}}\n        }\n    }\n\n    (\n        if [[ $site = */releases ]] {\n            local tag_version=${ICE[ver]}\n            if [[ -z $tag_version ]]; then\n                tag_version=\"$({.zinit-download-file-stdout $site/latest || .zinit-download-file-stdout $site/latest 1;} 2>/dev/null | command grep -i -m 1 -o 'href=./'$user'/'$plugin'/releases/tag/[^\"]\\+')\"\n                tag_version=${tag_version##*/}\n            fi\n            local url=$site/expanded_assets/$tag_version\n\n            .zinit-get-latest-gh-r-url-part \"$user\" \"$plugin\" \"$url\" || return $?\n\n            command mkdir -p \"$local_path\"\n            [[ -d \"$local_path\" ]] || return 1\n\n            (\n                () { setopt localoptions noautopushd; builtin cd -q \"$local_path\"; } || return 1\n                integer count\n\n                for REPLY ( $reply ) {\n                    count+=1\n                    url=\"https://github.com${REPLY}\"\n                    if [[ -d $local_path/._zinit ]] {\n                        { local old_version=\"$(<$local_path/._zinit/is_release${count:#1})\"; } 2>/dev/null\n                        old_version=${old_version/(#b)(\\/[^\\/]##)(#c4,4)\\/([^\\/]##)*/${match[2]}}\n                    }\n                    +zi-log \"{m} Requesting ${REPLY:t} ${version:+, version $version} ${old_version:+ Current version: $old_version.}{rst}\"\n                    if { ! .zinit-download-file-stdout \"$url\" 0 1 >! \"${REPLY:t}\" } {\n                        if { ! .zinit-download-file-stdout \"$url\" 1 1 >! \"${REPLY:t}\" } {\n                            command rm -f \"${REPLY:t}\"\n                            +zi-log \"Download of release for \\`$remote_url_path' \" \\\n                                \"failed.{nl}Tried url: $url.\"\n                            return 1\n                        }\n                    }\n                    if .zinit-download-file-stdout \"$url.sig\" 2>/dev/null >! \"${REPLY:t}.sig\"; then\n                        :\n                    else\n                        command rm -f \"${REPLY:t}.sig\"\n                    fi\n\n                    command mkdir -p ._zinit && echo '*' > ._zinit/.gitignore\n                    [[ -d ._zinit ]] || return 2\n                    builtin print -r -- $url >! ._zinit/url || return 3\n                    builtin print -r -- ${REPLY} >! ._zinit/is_release${count:#1} || return 4\n                    ziextract ${REPLY:t} ${${${#reply}:#1}:+--nobkp} ${${(M)ICE[extract]:#!([^!]|(#e))*}:+--move} ${${(M)ICE[extract]:#!!*}:+--move2}\n                }\n                return $?\n            ) || {\n                return 1\n            }\n        } elif [[ $site = cygwin ]] {\n            command mkdir -p \"$local_path/._zinit\" && echo '*' > \"$local_path/._zinit/.gitignore\"\n            [[ -d \"$local_path\" ]] || return 1\n\n            (\n                () { setopt localoptions noautopushd; builtin cd -q \"$local_path\"; } || return 1\n                .zinit-get-cygwin-package \"$remote_url_path\" || return 1\n                builtin print -r -- $REPLY >! ._zinit/is_release\n                ziextract \"$REPLY\"\n            ) || return $?\n        } elif [[ $tpe = github ]] {\n            case ${ICE[proto]} in\n                (|ftp(|s)|git|http(|s)|rsync|ssh)\n                    :zinit-git-clone() {\n                        command git clone --progress ${(s: :)ICE[cloneopts]---recursive} \\\n                            ${(s: :)ICE[depth]:+--depth ${ICE[depth]}} \\\n                            \"${ICE[proto]:-https}://${site:-${ICE[from]:-github.com}}/$remote_url_path\" \\\n                            \"$local_path\" \\\n                            --config transfer.fsckobjects=false \\\n                            --config receive.fsckobjects=false \\\n                            --config fetch.fsckobjects=false \\\n                            --config pull.rebase=false\n                            integer retval=$?\n                            unfunction :zinit-git-clone\n                            return $retval\n                    }\n                    :zinit-git-clone |& { command ${ZINIT[BIN_DIR]}/share/git-process-output.zsh || cat; }\n                    if (( pipestatus[1] == 141 )) {\n                        :zinit-git-clone\n                        integer retval=$?\n                        if (( retval )) {\n                            builtin print -Pr -- \"$ZINIT[col-error]Clone failed (code: $ZINIT[col-obj]$retval$ZINIT[col-error]).%f%b\"\n                            return 1\n                        }\n                    } elif (( pipestatus[1] )) {\n                        builtin print -Pr -- \"$ZINIT[col-error]Clone failed (code: $ZINIT[col-obj]$pipestatus[1]$ZINIT[col-error]).%f%b\"\n                        return 1\n                    }\n                    ;;\n                (*)\n                    builtin print -Pr \"${ZINIT[col-error]}Unknown protocol:%f%b ${ICE[proto]}.\"\n                    return 1\n            esac\n\n            if [[ -n ${ICE[ver]} ]] {\n                command git -C \"$local_path\" checkout \"${ICE[ver]}\"\n            }\n        }\n\n        if [[ $update != -u ]] {\n            hook_rc=0\n            # Store ices at clone of a plugin\n            .zinit-store-ices \"$local_path/._zinit\" ICE \"\" \"\" \"\" \"\"\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:\\!atclone-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atclone-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:\\!atclone-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                # Functions calls\n                \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_path\" \"${${key##(zinit|z-annex) hook:}%% <->}\" load\n                hook_rc=$?\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    # note: this will effectively return the last != 0 rc\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n\n            # Run annexes' atclone hooks (the after atclone-ice ones)\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:atclone-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:atclone-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:atclone-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" plugin \"$user\" \"$plugin\" \"$id_as\" \"$local_path\" \"${${key##(zinit|z-annex) hook:}%% <->}\"\n                hook_rc=$?\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n        }\n\n        return \"$retval\"\n    ) || return $?\n\n    typeset -ga INSTALLED_EXECS\n    { INSTALLED_EXECS=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit-execs.$$.lst)}\" ) } 2>/dev/null\n\n    # After additional executions like atclone'' - install completions (1 - plugins)\n    local -A OPTS\n    OPTS[opt_-q,--quiet]=1\n    [[ (0 = ${+ICE[nocompletions]} && ${ICE[as]} != null && ${+ICE[null]} -eq 0) || 0 != ${+ICE[completions]} ]] && \\\n        .zinit-install-completions \"$id_as\" \"\" \"0\"\n\n    if [[ -e ${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst || -e ${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst ]] {\n        typeset -ga INSTALLED_COMPS SKIPPED_COMPS\n        { INSTALLED_COMPS=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst)}\" ) } 2>/dev/null\n        { SKIPPED_COMPS=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst)}\" ) } 2>/dev/null\n    }\n\n    if [[ -e ${TMPDIR:-/tmp}/zinit.compiled.$$.lst ]] {\n        typeset -ga ADD_COMPILED\n        { ADD_COMPILED=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit.compiled.$$.lst)}\" ) } 2>/dev/null\n    }\n\n    # After any download – rehash the command table\n    # This will however miss the as\"program\" binaries\n    # as their PATH gets extended - and it is done\n    # later. It will however work for sbin'' ice.\n    (( !OPTS[opt_-p,--parallel] )) && rehash\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-install-completions [[[\n# Installs all completions of given plugin. After that they are visible to\n# 'compinit'. Visible completions can be selectively disabled and enabled. User\n# can access completion data with 'completions' subcommand.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin if $1 (i.e., user) given\n# $3 - if 1, then reinstall, otherwise only install completions that are not present\n.zinit-install-completions() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt nullglob extendedglob warncreateglobal typesetsilent noshortloops\n\n    local id_as=$1${2:+${${${(M)1:#%}:+$2}:-/$2}}\n    local reinstall=${3:-0} quiet=${${4:+1}:-0}\n    (( OPTS[opt_-q,--quiet] )) && quiet=1\n    [[ $4 = -Q ]] && quiet=2\n    typeset -ga INSTALLED_COMPS SKIPPED_COMPS\n    INSTALLED_COMPS=() SKIPPED_COMPS=()\n\n    .zinit-any-to-user-plugin \"$id_as\" \"\"\n    local user=${reply[-2]}\n    local plugin=${reply[-1]}\n    .zinit-any-colorify-as-uspl2 \"$user\" \"$plugin\"\n    local abbrev_pspec=$REPLY\n\n    .zinit-exists-physically-message \"$id_as\" \"\" || return 1\n\n    # Symlink any completion files included in the plugin directory\n    typeset -a completions already_symlinked backup_comps\n    local c cfile bkpfile\n    # The plugin == . is a semi-hack/trick to handle 'creinstall .' properly\n    [[ $user == % || ( -z $user && $plugin == . ) ]] && \\\n        completions=( \"${plugin}\"/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.yaml|*.py|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1)(DN^/) ) || \\\n        completions=( \"${ZINIT[PLUGINS_DIR]}/${id_as//\\//---}\"/**/_[^_.]*~*(*.zwc|*.html|*.txt|*.png|*.jpg|*.jpeg|*.js|*.md|*.yml|*.yaml|*.py|*.ri|_zsh_highlight*|/zsdoc/*|*.ps1)(DN^/) )\n    already_symlinked=( \"${ZINIT[COMPLETIONS_DIR]}\"/_[^_.]*~*.zwc(DN) )\n    backup_comps=( \"${ZINIT[COMPLETIONS_DIR]}\"/[^_.]*~*.zwc(DN) )\n\n    # Symlink completions if they are not already there\n    # either as completions (_fname) or as backups (fname)\n    # OR - if its a reinstall\n    for c in \"${completions[@]:A}\"; do\n        cfile=\"${c:t}\"\n        bkpfile=\"${cfile#_}\"\n        if [[ ( -z ${already_symlinked[(r)*/$cfile]} || $reinstall = 1 ) &&\n              -z ${backup_comps[(r)*/$bkpfile]}\n        ]]; then\n            if [[ $reinstall = 1 ]]; then\n                # Remove old files\n                command rm -f \"${ZINIT[COMPLETIONS_DIR]}/$cfile\" \"${ZINIT[COMPLETIONS_DIR]}/$bkpfile\"\n            fi\n            INSTALLED_COMPS+=( $cfile )\n            (( quiet )) || builtin print -Pr \"Symlinking completion ${ZINIT[col-uname]}$cfile%f%b to completions directory.\"\n            command ln -fs \"$c\" \"${ZINIT[COMPLETIONS_DIR]}/$cfile\"\n            # Make compinit notice the change\n            .zinit-forget-completion \"$cfile\" \"$quiet\"\n        else\n            SKIPPED_COMPS+=( $cfile )\n            (( quiet )) || builtin print -Pr \"Not symlinking completion \\`${ZINIT[col-obj]}$cfile%f%b', it already exists.\"\n            (( quiet )) || builtin print -Pr \"${ZINIT[col-info2]}Use \\`${ZINIT[col-pname]}zinit creinstall $abbrev_pspec${ZINIT[col-info2]}' to force install.%f%b\"\n        fi\n    done\n\n    local comps msg\n    local -A comp_types=(\\$INSTALLED_COMPS 'Installed' \\$SKIPPED_COMPS 'Skipped re-installing')\n    for comps msg in ${(kv)comp_types}; do\n        local comps_num=${#${(e)comps}}\n        if (( comps_num > 0 )); then\n            +zi-log \"{m} ${msg} {num}$comps_num{rst} completion${=${comps_num:#1}:+s}\"\n            if (( quiet == 0 )); then\n                +zi-log \"{m} Added $comps_num completion${=${comps_num:#1}:+s} to {var}$comps{rst} array\"\n            fi\n        fi\n    done\n\n    if (( ZSH_SUBSHELL )) {\n        builtin print -rl -- $INSTALLED_COMPS >! ${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst\n        builtin print -rl -- $SKIPPED_COMPS >! ${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst\n    }\n\n    .zinit-compinit 1 1 &>/dev/null\n} # ]]]\n# FUNCTION: .zinit-compinit [[[\n# User-exposed `compinit' frontend which first ensures that all\n# completions managed by Zinit are forgotten by Zshell. After\n# that it runs normal `compinit', which should more easily detect\n# Zinit's completions.\n#\n# No arguments.\n.zinit-compinit() {\n    # This might be called during sourcing when setting up the plugins dir, so check that OPTS is actually existing\n    [[ -n $OPTS && -n ${OPTS[opt_-p,--parallel]} && $1 != 1 ]] && return\n\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt nullglob extendedglob warncreateglobal typesetsilent\n\n    integer use_C=$2\n\n    typeset -a symlinked backup_comps\n    local c cfile bkpfile action\n\n    symlinked=( \"${ZINIT[COMPLETIONS_DIR]}\"/_[^_.]*~*.zwc )\n    backup_comps=( \"${ZINIT[COMPLETIONS_DIR]}\"/[^_.]*~*.zwc )\n\n    # Delete completions if they are really there, either\n    # as completions (_fname) or backups (fname)\n    for c in \"${symlinked[@]}\" \"${backup_comps[@]}\"; do\n        action=0\n        cfile=\"${c:t}\"\n        cfile=\"_${cfile#_}\"\n        bkpfile=\"${cfile#_}\"\n\n        #print -Pr \"${ZINIT[col-info]}Processing completion $cfile%f%b\"\n        .zinit-forget-completion \"$cfile\"\n    done\n\n    +zi-log \"Initializing completion ({func}compinit{rst}){…}\"\n    command rm -f ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump}\n\n    # Workaround for a nasty trick in _vim\n    (( ${+functions[_vim_files]} )) && unfunction _vim_files\n\n    builtin autoload -Uz compinit\n    compinit ${${(M)use_C:#1}:+-C} -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n} # ]]]\n# FUNCTION: .zinit-download-file-stdout [[[\n# Downloads file to stdout. Supports following backend commands:\n# curl, wget, lftp, lynx. Used by snippet loading.\n.zinit-download-file-stdout() {\n    local url=\"$1\" restart=\"$2\" progress=\"${(M)3:#1}\"\n\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt localtraps extendedglob\n\n    # Return file directly for file:// urls, wget doesn't support this schema\n    if [[ \"$url\" =~ ^file:// ]] {\n        local filepath=${url##file://}\n        <\"$filepath\"\n        return \"$?\"\n    }\n\n    if (( restart )) {\n        (( ${path[(I)/usr/local/bin]} )) || \\\n            {\n                path+=( \"/usr/local/bin\" );\n                trap \"path[-1]=()\" EXIT\n            }\n\n        if (( ${+commands[curl]} )); then\n            if [[ -n $progress ]]; then\n                command curl --progress-bar -fSL \"$url\" 2> >(.zinit-single-line >&2) || return 1\n            else\n                command curl -fsSL \"$url\" || return 1\n            fi\n        elif (( ${+commands[wget]} )); then\n            command wget ${${progress:--q}:#1} \"$url\" -O - || return 1\n        elif (( ${+commands[lftp]} )); then\n            command lftp -c \"cat $url\" || return 1\n        elif (( ${+commands[lynx]} )); then\n            command lynx -source \"$url\" || return 1\n        else\n            +zi-log \"{u-warn}ERROR{b-warn}:{rst}No download tool detected\" \\\n                \"(one of: {cmd}curl{rst}, {cmd}wget{rst}, {cmd}lftp{rst},\" \\\n                \"{cmd}lynx{rst}).\"\n            return 2\n        fi\n    } else {\n        if type curl 2>/dev/null 1>&2; then\n            if [[ -n $progress ]]; then\n                command curl --progress-bar -fSL \"$url\" 2> >(.zinit-single-line >&2) || return 1\n            else\n                command curl -fsSL \"$url\" || return 1\n            fi\n        elif type wget 2>/dev/null 1>&2; then\n            command wget ${${progress:--q}:#1} \"$url\" -O - || return 1\n        elif type lftp 2>/dev/null 1>&2; then\n            command lftp -c \"cat $url\" || return 1\n        else\n            .zinit-download-file-stdout \"$url\" \"1\" \"$progress\"\n            return $?\n        fi\n    }\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-get-url-mtime [[[\n# For the given URL returns the date in the Last-Modified\n# header as a time stamp\n.zinit-get-url-mtime() {\n    local url=\"$1\" IFS line header\n    local -a cmd\n\n    setopt localoptions localtraps\n\n    (( !${path[(I)/usr/local/bin]} )) && \\\n        {\n            path+=( \"/usr/local/bin\" );\n            trap \"path[-1]=()\" EXIT\n        }\n\n    if (( ${+commands[curl]} )) || type curl 2>/dev/null 1>&2; then\n        cmd=(command curl -sIL \"$url\")\n    elif (( ${+commands[wget]} )) || type wget 2>/dev/null 1>&2; then\n        cmd=(command wget --server-response --spider -q \"$url\" -O -)\n    else\n        REPLY=$(( $(date +\"%s\") ))\n        return 2\n    fi\n\n    \"${cmd[@]}\" |& command grep -i Last-Modified: | while read -r line; do\n        header=\"${${line#*, }//$'\\r'}\"\n    done\n\n    if [[ -z $header ]] {\n        REPLY=$(( $(date +\"%s\") ))\n        return 3\n    }\n\n    LANG=C TZ=UTC strftime -r -s REPLY \"%d %b %Y %H:%M:%S GMT\" \"$header\" &>/dev/null || {\n        REPLY=$(( $(date +\"%s\") ))\n        return 4\n    }\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-mirror-using-svn [[[\n# Used to clone subdirectories from Github. If in update mode\n# (see $2), then invokes `svn update', in normal mode invokes\n# `svn checkout --non-interactive -q <URL>'. In test mode only\n# compares remote and local revision and outputs true if update\n# is needed.\n#\n# $1 - URL\n# $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test\n# $3 - subdirectory (not path) with working copy, needed for -t and -u\n.zinit-mirror-using-svn() {\n    setopt localoptions extendedglob warncreateglobal\n    local url=\"$1\" update=\"$2\" directory=\"$3\"\n\n    (( ${+commands[svn]} )) || \\\n        builtin print -Pr -- \"${ZINIT[col-error]}Warning:%f%b Subversion not found\" \\\n            \", please install it to use \\`${ZINIT[col-obj]}svn%f%b' ice.\"\n\n    if [[ \"$update\" = \"-t\" ]]; then\n        (\n            () { setopt localoptions noautopushd; builtin cd -q \"$directory\"; }\n            local -a out1 out2\n            out1=( \"${(f@)\"$(LANG=C svn info -r HEAD)\"}\" )\n            out2=( \"${(f@)\"$(LANG=C svn info)\"}\" )\n\n            out1=( \"${(M)out1[@]:#Revision:*}\" )\n            out2=( \"${(M)out2[@]:#Revision:*}\" )\n            [[ \"${out1[1]##[^0-9]##}\" != \"${out2[1]##[^0-9]##}\" ]] && return 0\n            return 1\n        )\n        return $?\n    fi\n    if [[ \"$update\" = \"-u\" && -d \"$directory\" && -d \"$directory/.svn\" ]]; then\n        ( () { setopt localoptions noautopushd; builtin cd -q \"$directory\"; }\n          command svn update\n          return $? )\n    else\n        command svn checkout --non-interactive -q \"$url\" \"$directory\"\n    fi\n    return $?\n} # ]]]\n# FUNCTION: .zinit-forget-completion [[[\n# Implements alternation of Zsh state so that already initialized\n# completion stops being visible to Zsh.\n#\n# $1 - completion function name, e.g. \"_cp\"; can also be \"cp\"\n.zinit-forget-completion() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob typesetsilent warncreateglobal\n\n    local f=\"$1\" quiet=\"$2\"\n\n    typeset -a commands\n    commands=( ${(k)_comps[(Re)$f]} )\n\n    [[ \"${#commands}\" -gt 0 ]] && (( quiet == 0 )) && builtin print -Prn \"Forgetting commands completed by \\`${ZINIT[col-obj]}$f%f%b': \"\n\n    local k\n    integer first=1\n    for k ( $commands ) {\n        unset \"_comps[$k]\"\n        (( quiet )) || builtin print -Prn \"${${first:#1}:+, }${ZINIT[col-info]}$k%f%b\"\n        first=0\n    }\n    (( quiet || first )) || builtin print\n\n    unfunction -- 2>/dev/null \"$f\"\n} # ]]]\n# FUNCTION: .zinit-download-snippet [[[\n# Downloads snippet\n#   file – with curl, wget, lftp or lynx,\n#   directory, with Subversion – when svn-ICE is active.\n#\n#   Github supports Subversion protocol and allows to clone subdirectories.\n#   This is used to provide a layer of support for Oh-My-Zsh and Prezto.\n.zinit-download-snippet() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent\n\n    local save_url=$1 url=$2 id_as=$3 local_dir=$4 dirname=$5 filename=$6 update=$7\n\n    trap \"command rmdir ${(qqq)local_dir}/${(qqq)dirname} 2>/dev/null; return 1;\" INT TERM QUIT HUP\n\n    local -a list arr\n    integer retval=0 hook_rc=0\n    local teleid_clean=${ICE[teleid]%%\\?*}\n    [[ $teleid_clean == *://* ]] && \\\n        local sname=${(M)teleid_clean##*://[^/]##(/[^/]##)(#c0,4)} || \\\n        local sname=${${teleid_clean:h}:t}/${teleid_clean:t}\n    [[ $sname = */trunk* ]] && sname=${${ICE[teleid]%%/trunk*}:t}/${ICE[teleid]:t}\n    sname=${sname#./}\n\n    if (( ${+ICE[svn]} )) {\n        [[ $url = *(${(~kj.|.)${(Mk)ZINIT_1MAP:#OMZ*}}|robbyrussell*oh-my-zsh|ohmyzsh/ohmyzsh)* ]] && local ZSH=${ZINIT[SNIPPETS_DIR]}\n        url=${url/(#s)(#m)(${(~kj.|.)ZINIT_1MAP})/$ZINIT_1MAP[$MATCH]}\n    } else {\n        url=${url/(#s)(#m)(${(~kj.|.)ZINIT_2MAP})/$ZINIT_2MAP[$MATCH]}\n        if [[ $save_url == (${(~kj.|.)${(Mk)ZINIT_1MAP:#OMZ*}})* ]] {\n            if [[ $url != *.zsh(|-theme) && $url != */_[^/]## ]] {\n                if [[ $save_url == OMZT::* ]] {\n                    url+=.zsh-theme\n                } else {\n                    url+=/${${url#*::}:t}.plugin.zsh\n                }\n            }\n        } elif [[ $save_url = (${(~kj.|.)${(kM)ZINIT_1MAP:#PZT*}})* ]] {\n            if [[ $url != *.zsh && $url != */_[^/]## ]] {\n                url+=/init.zsh\n            }\n        }\n    }\n\n    # Change the url to point to raw github content if it isn't like that\n    if [[ \"$url\" = *github.com* && ! \"$url\" = */raw/* && \"${+ICE[svn]}\" = \"0\" ]] {\n        url=\"${${url/\\/blob\\///raw/}/\\/tree\\///raw/}\"\n    }\n\n    command rm -f ${TMPDIR:-/tmp}/zinit-execs.$$.lst ${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst \\\n                  ${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst ${TMPDIR:-/tmp}/zinit.compiled.$$.lst\n\n    if [[ ! -d $local_dir/$dirname ]]; then\n        local id_msg_part=\"{…} (at label{ehi}:{rst} {id-as}$id_as{rst})\"\n        [[ $update != -u ]] && +zi-log \"{nl}{info}Setting up snippet:\" \\\n                                    \"{url}$sname{rst}${ICE[id-as]:+$id_msg_part}\"\n        command mkdir -p \"$local_dir\"\n    fi\n\n    if [[ $update = -u && ${OPTS[opt_-q,--quiet]} != 1 ]]; then\n        local id_msg_part=\"{…} (identified as{ehi}:{rst} {id-as}$id_as{rst})\"\n        +zi-log \"{nl}{info2}Updating snippet: {url}$sname{rst}${ICE[id-as]:+$id_msg_part}\"\n    fi\n\n    # A flag for the annexes. 0 – no new commits, 1 - run-atpull mode,\n    # 2 – full update/there are new commits to download, 3 - full but\n    # a forced download (i.e.: the medium doesn't allow to peek update)\n    #\n    # The below inherits the flag if it's an update call (i.e.: -u given),\n    # otherwise it sets it to 2 – a new download is treated like a full\n    # update.\n    ZINIT[annex-multi-flag:pull-active]=${${${(M)update:#-u}:+${ZINIT[annex-multi-flag:pull-active]}}:-2}\n\n    (\n        if [[ $url = (ftp(|s)|http(|s)|scp)://* ]] {\n            (\n                () { setopt localoptions noautopushd; builtin cd -q \"$local_dir\"; } || return 4\n\n                (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{i} Downloading {file}$sname{rst} ${${ICE[svn]+\" (with Subversion)\"}:-\" (with curl, wget, lftp)\"}{rst}\"\n\n                if (( ${+ICE[svn]} )) {\n                    if [[ $update = -u ]] {\n                        # Test if update available\n                        if ! .zinit-mirror-using-svn \"$url\" \"-t\" \"$dirname\"; then\n                            if (( ${+ICE[run-atpull]} || OPTS[opt_-u,--urge] )) {\n                                ZINIT[annex-multi-flag:pull-active]=1\n                            } else { return 0; } # Will return when no updates so atpull''\n                                                 # code below doesn't need any checks.\n                                                 # This return 0 statement also sets the\n                                                 # pull-active flag outside this subshell.\n                        else\n                            ZINIT[annex-multi-flag:pull-active]=2\n                        fi\n\n                        # Run annexes' atpull hooks (the before atpull-ice ones).\n                        # The SVN block.\n                        reply=(\n                            ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-pre <->]}\n                            ${${(M)ICE[atpull]#\\!}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                            ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-post <->]}\n                        )\n                        for key in \"${reply[@]}\"; do\n                            arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                            \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:svn\n                            hook_rc=$?\n                            [[ \"$hook_rc\" -ne 0 ]] && {\n                                retval=\"$hook_rc\"\n                                builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                            }\n                        done\n\n                        if (( ZINIT[annex-multi-flag:pull-active] == 2 )) {\n                            # Do the update\n                            # The condition is reversed on purpose – to show only\n                            # the messages on an actual update\n                            if (( OPTS[opt_-q,--quiet] )); then\n                                local id_msg_part=\"{…} (identified as{ehi}: {id-as}$id_as{rst})\"\n                                +zi-log \"{nl}{info2}Updating snippet {url}${sname}{rst}${ICE[id-as]:+$id_msg_part}\"\n                                +zi-log \"Downloading {apo}\\`{rst}$sname{apo}\\`{rst} (with Subversion){…}\"\n                            fi\n                            .zinit-mirror-using-svn \"$url\" \"-u\" \"$dirname\" || return 4\n                        }\n                    } else {\n                        .zinit-mirror-using-svn \"$url\" \"\" \"$dirname\" || return 4\n                    }\n\n                    # Redundant code, just to compile SVN snippet\n                    if [[ ${ICE[as]} != command ]]; then\n                        if [[ -n ${ICE[pick]} ]]; then\n                            list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )\n                        elif [[ -z ${ICE[pick]} ]]; then\n                            list=(\n                                $local_dir/$dirname/*.plugin.zsh(DN) $local_dir/$dirname/*.zsh-theme(DN) $local_dir/$dirname/init.zsh(DN)\n                                $local_dir/$dirname/*.zsh(DN) $local_dir/$dirname/*.sh(DN) $local_dir/$dirname/.zshrc(DN)\n                            )\n                        fi\n\n                        if [[ -e ${list[1]} && ${list[1]} != */dev/null && \\\n                            -z ${ICE[(i)(\\!|)(sh|bash|ksh|csh)]} && \\\n                            ${+ICE[nocompile]} -eq 0\n                        ]] {\n                            () {\n                                builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n                                zcompile -U \"${list[1]}\" &>/dev/null || \\\n                                    +zi-log \"{u-warn}Warning{b-warn}:{rst} couldn't compile {apo}\\`{file}${list[1]}{apo}\\`{rst}.\"\n                            }\n                        }\n                    fi\n\n                    return $ZINIT[annex-multi-flag:pull-active]\n                } else {\n                    command mkdir -p \"$local_dir/$dirname\"\n\n                    if (( !OPTS[opt_-f,--force] )) {\n                        .zinit-get-url-mtime \"$url\"\n                    } else {\n                        REPLY=$EPOCHSECONDS\n                    }\n\n                    # Returned is: modification time of the remote file.\n                    # Thus, EPOCHSECONDS - REPLY is: allowed window for the\n                    # local file to be modified in. ms-$secs is: files accessed\n                    # within last $secs seconds. Thus, if there's no match, the\n                    # local file is out of date.\n\n                    local secs=$(( EPOCHSECONDS - REPLY ))\n                    # Guard so that it's positive\n                    (( $secs >= 0 )) || secs=0\n                    integer skip_dl\n                    local -a matched\n                    matched=( $local_dir/$dirname/$filename(DNms-$secs) )\n                    if (( ${#matched} )) {\n                        +zi-log \"{info}Already up to date.{rst}\"\n                        # Empty-update return-short path – it also decides the\n                        # pull-active flag after the return from this sub-shell\n                        (( ${+ICE[run-atpull]} || OPTS[opt_-u,--urge] )) && skip_dl=1 || return 0\n                    }\n\n                    if [[ ! -f $local_dir/$dirname/$filename ]] {\n                        ZINIT[annex-multi-flag:pull-active]=2\n                    } else {\n                        # secs > 1 → the file is outdated, then:\n                        #   - if true, then the mode is 2 minus run-atpull-activation,\n                        #   - if false, then mode is 3 → a forced download (no remote mtime found).\n                        ZINIT[annex-multi-flag:pull-active]=$(( secs > 1 ? (2 - skip_dl) : 3 ))\n                    }\n\n                    # Run annexes' atpull hooks (the before atpull-ice ones).\n                    # The URL-snippet block.\n                    if [[ $update = -u && $ZINIT[annex-multi-flag:pull-active] -ge 1 ]] {\n                        reply=(\n                            ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-pre <->]}\n                            ${${ICE[atpull]#\\!}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                            ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-post <->]}\n                        )\n                        for key in \"${reply[@]}\"; do\n                            arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                            \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:url\n                            hook_rc=\"$?\"\n                            [[ \"$hook_rc\" -ne 0 ]] && {\n                                retval=\"$hook_rc\"\n                                builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                            }\n                        done\n                    }\n\n                    if (( !skip_dl )) {\n                        if { ! .zinit-download-file-stdout \"$url\" 0 1 >! \"$dirname/$filename\" } {\n                            if { ! .zinit-download-file-stdout \"$url\" 1 1 >! \"$dirname/$filename\" } {\n                                command rm -f \"$dirname/$filename\"\n                                +zi-log \"{u-warn}ERROR{b-warn}:{rst} Download failed.\"\n                                return 4\n                            }\n                        }\n                    }\n                    return $ZINIT[annex-multi-flag:pull-active]\n                }\n            )\n            retval=$?\n\n            # Overestimate the pull-level to 2 also in error situations\n            # – no hooks will be run anyway because of the error\n            ZINIT[annex-multi-flag:pull-active]=$retval\n\n            if [[ $ICE[as] != command && ${+ICE[svn]} -eq 0 ]] {\n                local file_path=$local_dir/$dirname/$filename\n                if [[ -n ${ICE[pick]} ]]; then\n                    list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )\n                    file_path=${list[1]}\n                fi\n                if [[ -e $file_path && -z ${ICE[(i)(\\!|)(sh|bash|ksh|csh)]} && \\\n                        $file_path != */dev/null && ${+ICE[nocompile]} -eq 0\n                ]] {\n                    () {\n                        builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n                        if ! zcompile -U \"$file_path\" 2>/dev/null; then\n                            builtin print -r \"Couldn't compile \\`${file_path:t}', it MIGHT be wrongly downloaded\"\n                            builtin print -r \"(snippet URL points to a directory instead of a file?\"\n                            builtin print -r \"to download directory, use preceding: zinit ice svn).\"\n                            retval=4\n                        fi\n                    }\n                }\n            }\n        } else { # Local-file snippet branch\n            # Local files are (yet…) forcefully copied.\n            ZINIT[annex-multi-flag:pull-active]=3 retval=3\n            # Run annexes' atpull hooks (the before atpull-ice ones).\n            # The local-file snippets block.\n            if [[ $update = -u ]] {\n                reply=(\n                    ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-pre <->]}\n                    ${${(M)ICE[atpull]#\\!}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                    ${(on)ZINIT_EXTS2[(I)zinit hook:e-\\!atpull-post <->]}\n                )\n                for key in \"${reply[@]}\"; do\n                    arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                    \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:file\n                    hook_rc=\"$?\"\n                    [[ \"$hook_rc\" -ne 0 ]] && {\n                        retval=\"$hook_rc\"\n                        builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                    }\n                done\n            }\n\n            command mkdir -p \"$local_dir/$dirname\"\n            if [[ ! -e $url ]] {\n                (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{ehi}ERROR:{error} The source file {file}$url{error} doesn't exist.{rst}\"\n                retval=4\n            }\n            if [[ -e $url && ! -f $url && $url != /dev/null ]] {\n                (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{ehi}ERROR:{error} The source {file}$url{error} isn't a regular file.{rst}\"\n                retval=4\n            }\n            if [[ -e $url && ! -r $url && $url != /dev/null ]] {\n                (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{ehi}ERROR:{error} The source {file}$url{error} isn't\" \\\n                    \"accessible (wrong permissions).{rst}\"\n                retval=4\n            }\n            if ! (( ${+ICE[link]} )) {\n                if (( !OPTS[opt_-q,--quiet] )) && [[ $url != /dev/null ]] {\n                    +zi-log \"{msg}Copying {file}$filename{msg}{…}{rst}\"\n                    command cp -vf \"$url\" \"$local_dir/$dirname/$filename\" || \\\n                        { +zi-log \"{ehi}ERROR:{error} The file copying has been unsuccessful.{rst}\"; retval=4; }\n                } else {\n                    command cp -f \"$url\" \"$local_dir/$dirname/$filename\" &>/dev/null || \\\n                        { +zi-log \"{ehi}ERROR:{error} The copying of {file}$filename{error} has been unsuccessful\"\\\n    \"${${(M)OPTS[opt_-q,--quiet]:#1}:+, skip the -q/--quiet option for more information}.{rst}\"; retval=4; }\n                }\n            } else {\n                if (( $+commands[realpath] )) {\n                    local rpv=\"$(realpath --version | head -n1 | sed -E 's/realpath (\\(.*\\))?//g')\"\n                    if is-at-least 8.23 $rpv; then\n                        rel_url=\"$(realpath --relative-to=\"$local_dir/$dirname\" \"$url\")\" && \\\n                            { url=\"$rel_url\" }\n                    fi\n                }\n                if (( !OPTS[opt_-q,--quiet] )) && [[ $url != /dev/null ]] {\n                    +zi-log \"{msg}Linking {file}$filename{msg}{…}{rst}\"\n                    command ln -svf \"$url\" \"$local_dir/$dirname/$filename\" || \\\n                        { +zi-log \"{ehi}ERROR:{error} The file linking has been unsuccessful.{rst}\"; retval=4; }\n                } else {\n                    command ln -sf \"$url\" \"$local_dir/$dirname/$filename\" &>/dev/null || \\\n                        { +zi-log \"{ehi}ERROR:{error} The link of {file}$filename{error} has been unsuccessful\"\\\n    \"${${(M)OPTS[opt_-q,--quiet]:#1}:+, skip the -q/--quiet option for more information}.{rst}\"; retval=4; }\n                }\n            }\n        }\n\n        (( retval == 4 )) && { command rmdir \"$local_dir/$dirname\" 2>/dev/null; return $retval; }\n\n        if [[ ${${:-$local_dir/$dirname}%%/##} != ${ZINIT[SNIPPETS_DIR]} ]] {\n            # Store ices at \"clone\" and update of snippet, SVN and single-file\n            local pfx=$local_dir/$dirname/._zinit\n            .zinit-store-ices \"$pfx\" ICE url_rsvd \"\" \"$save_url\" \"${+ICE[svn]}\"\n        } elif [[ -n $id_as ]] {\n            +zi-log \"{u-warn}Warning{b-warn}:{rst} the snippet {url}$id_as{rst} isn't\" \\\n                \"fully downloaded – you should remove it with {apo}\\`{cmd}zinit delete $id_as{apo}\\`{rst}.\"\n        }\n\n        # Empty update short-path\n        if (( ZINIT[annex-multi-flag:pull-active] == 0 )) {\n            # Run annexes' atpull hooks (the `always' after atpull-ice ones)\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:%atpull-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:%atpull-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:%atpull-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:0\n                hook_rc=\"$?\"\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n\n            return $retval;\n        }\n\n        if [[ $update = -u ]] {\n            # Run annexes' atpull hooks (the before atpull-ice ones).\n            # The block is common to all 3 snippet types.\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:no-e-\\!atpull-pre <->]}\n                ${${ICE[atpull]:#\\!*}:+${(on)ZINIT_EXTS[(I)z-annex hook:\\!atpull-<-> <->]}}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:no-e-\\!atpull-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update\n                hook_rc=$?\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n        } else {\n            # Run annexes' atclone hooks (the before atclone-ice ones)\n            # The block is common to all 3 snippet types.\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:\\!atclone-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atclone-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:\\!atclone-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" load\n            done\n\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:atclone-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:atclone-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:atclone-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" load\n            done\n        }\n\n        # Run annexes' atpull hooks (the after atpull-ice ones)\n        # The block is common to all 3 snippet types.\n        if [[ $update = -u ]] {\n            if (( ZINIT[annex-multi-flag:pull-active] > 0 )) {\n                reply=(\n                    ${(on)ZINIT_EXTS2[(I)zinit hook:atpull-pre <->]}\n                    ${(on)ZINIT_EXTS[(I)z-annex hook:atpull-<-> <->]}\n                    ${(on)ZINIT_EXTS2[(I)zinit hook:atpull-post <->]}\n                )\n                for key in \"${reply[@]}\"; do\n                    arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                    \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update\n                    hook_rc=$?\n                    [[ \"$hook_rc\" -ne 0 ]] && {\n                        retval=\"$hook_rc\"\n                        builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                    }\n                done\n            }\n\n            # Run annexes' atpull hooks (the `always' after atpull-ice ones)\n            # The block is common to all 3 snippet types.\n            reply=(\n                ${(on)ZINIT_EXTS2[(I)zinit hook:%atpull-pre <->]}\n                ${(on)ZINIT_EXTS[(I)z-annex hook:%atpull-<-> <->]}\n                ${(on)ZINIT_EXTS2[(I)zinit hook:%atpull-post <->]}\n            )\n            for key in \"${reply[@]}\"; do\n                arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n                \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" update:$ZINIT[annex-multi-flag:pull-active]\n                hook_rc=$?\n                [[ \"$hook_rc\" -ne 0 ]] && {\n                    retval=\"$hook_rc\"\n                    builtin print -Pr -- \"${ZINIT[col-warn]}Warning:%f%b ${ZINIT[col-obj]}${arr[5]}${ZINIT[col-warn]} hook returned with ${ZINIT[col-obj]}${hook_rc}${ZINIT[col-rst]}\"\n                }\n            done\n        }\n    ) || return $?\n\n    typeset -ga INSTALLED_EXECS\n    { INSTALLED_EXECS=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit-execs.$$.lst)}\" ) } 2>/dev/null\n\n    # After additional executions like atclone'' - install completions (2 - snippets)\n    local -A OPTS\n    OPTS[opt_-q,--quiet]=1\n    [[ (0 = ${+ICE[nocompletions]} && ${ICE[as]} != null && ${+ICE[null]} -eq 0) || 0 != ${+ICE[completions]} ]] && \\\n        .zinit-install-completions \"%\" \"$local_dir/$dirname\" 0\n\n    if [[ -e ${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst || -e ${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst ]] {\n        typeset -ga INSTALLED_COMPS SKIPPED_COMPS\n        { INSTALLED_COMPS=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit.installed_comps.$$.lst)}\" ) } 2>/dev/null\n        { SKIPPED_COMPS=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit.skipped_comps.$$.lst)}\" ) } 2>/dev/null\n    }\n\n    if [[ -e ${TMPDIR:-/tmp}/zinit.compiled.$$.lst ]] {\n        typeset -ga ADD_COMPILED\n        { ADD_COMPILED=( \"${(@f)$(<${TMPDIR:-/tmp}/zinit.compiled.$$.lst)}\" ) } 2>/dev/null\n    }\n\n    # After any download – rehash the command table\n    # This will however miss the as\"program\" binaries\n    # as their PATH gets extended - and it is done\n    # later. It will however work for sbin'' ice.\n    (( !OPTS[opt_-p,--parallel] )) && rehash\n\n    return $retval\n} # ]]]\n# FUNCTION: .zinit-update-snippet [[[\n.zinit-update-snippet() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes\n\n    local -a tmp opts\n    local url=$1\n    integer correct=0\n    [[ -o ksharrays ]] && correct=1\n    opts=( -u ) # for zinit-annex-readurl\n\n    # Create a local copy of OPTS, basically\n    # for zinit-annex-readurl annex\n    local -A ice_opts\n    ice_opts=( \"${(kv)OPTS[@]}\" )\n    local -A OPTS\n    OPTS=( \"${(kv)ice_opts[@]}\" )\n\n    ZINIT[annex-multi-flag:pull-active]=0 ZINIT[-r/--reset-opt-hook-has-been-run]=0\n\n    # Remove leading whitespace and trailing /\n    url=${${url#${url%%[! $'\\t']*}}%/}\n    ICE[teleid]=${ICE[teleid]:-$url}\n    [[ ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ]] && \\\n        ICE[pick]=${ICE[pick]:-/dev/null}\n\n    local local_dir dirname filename save_url=$url \\\n        id_as=${ICE[id-as]:-$url}\n\n    .zinit-pack-ice \"$id_as\" \"\"\n\n    # Allow things like $OSTYPE in the URL\n    eval \"url=\\\"$url\\\"\"\n\n    # - case A: called from `update --all', ICE empty, static ice will win\n    # - case B: called from `update', ICE packed, so it will win\n    tmp=( \"${(Q@)${(z@)ZINIT_SICE[$id_as]}}\" )\n    if (( ${#tmp} > 1 && ${#tmp} % 2 == 0 )) {\n        ICE=( \"${(kv)ICE[@]}\" \"${tmp[@]}\" )\n    } elif [[ -n ${ZINIT_SICE[$id_as]} ]] {\n        +zi-log \"{error}WARNING:{msg2} Inconsistency #3\" \\\n            \"occurred, please report the string: \\`{obj}${ZINIT_SICE[$id_as]}{msg2}' to the\" \\\n            \"GitHub issues page: {obj}https://github.com/zdharma-continuum/zinit/issues/{msg2}.{rst}\"\n    }\n    id_as=${ICE[id-as]:-$id_as}\n\n    # Oh-My-Zsh, Prezto and manual shorthands\n    if (( ${+ICE[svn]} )) {\n        [[ $url = *(${(~kj.|.)${(Mk)ZINIT_1MAP:#OMZ*}}|robbyrussell*oh-my-zsh|ohmyzsh/ohmyzsh)* ]] && local ZSH=${ZINIT[SNIPPETS_DIR]}\n        url=${url/(#s)(#m)(${(~kj.|.)ZINIT_1MAP})/$ZINIT_1MAP[$MATCH]}\n    } else {\n        url=${url/(#s)(#m)(${(~kj.|.)ZINIT_2MAP})/$ZINIT_2MAP[$MATCH]}\n        if [[ $save_url == (${(~kj.|.)${(Mk)ZINIT_1MAP:#OMZ*}})* ]] {\n            if [[ $url != *.zsh(|-theme) && $url != */_[^/]## ]] {\n                if [[ $save_url == OMZT::* ]] {\n                    url+=.zsh-theme\n                } else {\n                    url+=/${${url#*::}:t}.plugin.zsh\n                }\n            }\n        } elif [[ $save_url = (${(~kj.|.)${(kM)ZINIT_1MAP:#PZT*}})* ]] {\n            if [[ $url != *.zsh ]] {\n                url+=/init.zsh\n            }\n        }\n    }\n\n    if { ! .zinit-get-object-path snippet \"$id_as\" } {\n        +zi-log \"{msg2}Error: the snippet \\`{obj}$id_as{msg2}'\" \\\n                \"doesn't exist, aborting the update.{rst}\"\n            return 1\n    }\n    filename=$reply[-2] dirname=$reply[-2] local_dir=$reply[-3]\n\n    local -a arr\n    local key\n    reply=(\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-pre <->]}\n        ${(on)ZINIT_EXTS[(I)z-annex hook:preinit-<-> <->]}\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-post <->]}\n    )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n        \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" ${${key##(zinit|z-annex) hook:}%% <->} update || \\\n            return $(( 10 - $? ))\n    done\n\n    # Download or copy the file\n    [[ $url = *github.com* && $url != */raw/* ]] && url=${url/\\/(blob|tree)\\///raw/}\n    .zinit-download-snippet \"$save_url\" \"$url\" \"$id_as\" \"$local_dir\" \"$dirname\" \"$filename\" \"-u\"\n\n    return $?\n} # ]]]\n# FUNCTION: .zinit-single-line [[[\n# Display cURL progress bar on a single line\n.zinit-single-line() {\n    emulate -LR zsh\n    setopt extendedglob noshortloops nowarncreateglobal rcquotes typesetsilent\n    local IFS= n=$'\\n' r=$'\\r' zero=$'\\0'\n\n    {\n      command perl -pe 'BEGIN { $|++; $/ = \\1 }; tr/\\r\\n/\\n\\0/' \\\n        || gstdbuf -o0 gtr '\\r\\n' '\\n\\0' \\\n        || stdbuf -o0 tr '\\r\\n' '\\n\\0';\n      print\n    } 2>/dev/null | while read -r line;\n\n    do\n      if [[ $line == *$zero* ]]; then\n        # cURL doesn't add a newline to progress bars\n        # print -nr -- \"${r}${(l:COLUMNS:: :):-}${r}${line##*${zero}}\"\n        print -nr -- \"${r}${(l:COLUMNS:: :):-}${r}${line%${zero}}\"\n      else\n        print -nr -- \"${r}${(l:COLUMNS:: :):-}${r}${${line//[${r}${n}]/}%\\%*}${${(M)line%\\%}:+%}\"\n      fi\n    done\n\n    print\n} # ]]]\n# FUNCTION: .zi::get-architecture [[[\n.zi::get-architecture () {\n  emulate -L zsh\n  setopt extendedglob noshortloops nowarncreateglobal rcquotes\n  local _clib=\"gnu\" _cpu=\"$(uname -m)\" _os=\"$(uname -s)\" _sys=\"\"\n  case \"$_os\" in\n    (Darwin)\n      _sys='(apple|darwin|apple-darwin|dmg|mac((-|)os|)|os(-|64|)x)'\n      arch -x86_64 /usr/bin/true 2> /dev/null\n      if [[ $? -eq 0 ]] && [[ $_cpu != \"arm64\" ]]; then\n        _os=$_sys*~*((aarch|arm)64)\n      fi\n      ;;\n    (Linux)\n      _sys='(musl|gnu)*~^*(unknown|)linux*'\n      ;;\n    (MINGW* | MSYS* | CYGWIN* | Windows_NT)\n      _sys='pc-windows-gnu'\n      ;;\n    (*)\n      +zi-log \"{e} {b}gh-r{rst}Unsupported OS: {obj}$_os{rst}\"\n      ;;\n  esac\n  case \"$_cpu\" in\n    (aarch64 | arm64)\n      _cpu='(arm|aarch)64'\n      ;;\n    (amd64 | i386 | i486 | i686| i786 | x64 | x86 | x86-64 | x86_64)\n      _cpu='(amd64|x86_64|x64)'\n      ;;\n    (armv6l)\n      _os=${_os}eabihf\n      ;;\n    (armv7l | armv8l)\n      _os=${_os}eabihf\n      ;;\n    (*)\n      +zi-log \"{e} {b}gh-r{rst}Unsupported CPU: {obj}$_cpu{rst}\"\n      ;;\n  esac\n  echo \"${_sys};${_cpu};${_os}\"\n} # ]]]\n# FUNCTION: .zinit-get-latest-gh-r-url-part [[[\n# Gets version string of latest release of given Github\n# package. Connects to Github releases page.\n.zinit-get-latest-gh-r-url-part () {\n  builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n  setopt extendedglob nowarncreateglobal typesetsilent noshortloops\n  REPLY=\n  local plugin=\"$2\" urlpart=\"$3\" user=\"$1\"\n  local -a bpicks filtered init_list list parts\n  parts=(${(@s:;:)$(.zi::get-architecture)})\n  if [[ -z $urlpart ]]; then\n    local tag_version=${ICE[ver]}\n    if [[ -z $tag_version ]]; then\n      local releases_url=https://github.com/$user/$plugin/releases/latest\n      tag_version=\"$( { .zinit-download-file-stdout $releases_url || .zinit-download-file-stdout $releases_url 1; } 2>/dev/null | command grep -m1 -o 'href=./'$user'/'$plugin'/releases/tag/[^\"]\\+' )\"\n      tag_version=${tag_version##*/}\n    fi\n    local url=https://github.com/$user/$plugin/releases/expanded_assets/$tag_version\n  else\n    local url=https://$urlpart\n  fi\n  init_list=( ${(@f)\"$( { .zinit-download-file-stdout $url || .zinit-download-file-stdout $url 1; } 2>/dev/null | command grep -i -o 'href=./'$user'/'$plugin'/releases/download/[^\"]\\+')\"} )\n  init_list=(${(L)init_list[@]#href=?})\n  bpicks=(${(s.;.)ICE[bpick]})\n  [[ -z $bpicks ]] && bpicks=(\"\")\n  local bpick bpick_error=\"\"\n  reply=()\n  for bpick in \"${bpicks[@]}\"; do\n    list=($init_list)\n    if [[ -n $bpick ]]; then\n      list=( ${(M)list[@]:#(#i)*/$~bpick} )\n      if (( !$#list )); then\n        +zi-log \"{e} {b}gh-r{rst}: {ice}bpick{rst} ice found no release assets To fix, modify the {ice}bpick{rst} glob pattern {glob}$bpick{rst}\"\n      fi\n    else\n      local junk='*((s(ha256|ig|um)|386|asc|md5|txt|vsix)*|(apk|b3|deb|json|pkg|rpm|sh|zst)(#e))';\n      # print -l ${${(m@)list:#${~junk}}:t}\n      filtered=( ${(m@)list:#(#i)${~junk}} ) && (( $#filtered > 0 )) && list=( ${filtered[@]} )\n    fi\n\n    local -a array=( $(print -rm \"*(${MACHTYPE}|${VENDOR}|)*~^*(${parts[1]}|${(L)$(uname)})*\" $list[@]) )\n    (( ${#array} > 0 )) && list=( ${array[@]} )\n\n    for part in \"${parts[@]}\"; do\n      if (( $#list > 1 )); then\n        filtered=( ${(M)list[@]:#(#i)*${~part}*} ) && (( $#filtered > 0 )) && list=( ${filtered[@]} )\n      else\n        break\n      fi\n    done\n\n    if (( $#list > 1 )) { filtered=( ${list[@]:#(#i)*.(sha[[:digit:]]#|asc)} ) && (( $#filtered > 0 )) && list=( ${filtered[@]} ); }\n\n    if (( !$#list )); then\n      +zi-log \"{e} {b}gh-r{rst}: No GitHub release assets found for {glob}$tag_version{rst}\"\n      return 1\n    fi\n    reply+=( \"${list[1]}\" )\n  done\n  [[ -n $reply ]]\n} # ]]]\n# FUNCTION: ziextract [[[\n# If the file is an archive, it is extracted by this function.\n# Next stage is scanning of files with the common utility file\n# to detect executables. They are given +x mode. There are also\n# messages to the user on performed actions.\n#\n# $1 - url\n# $2 - file\nziextract() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob typesetsilent noshortloops # warncreateglobal\n\n    local -aU opt_move opt_move2 opt_norm opt_auto opt_nobkp\n    zparseopts -D -E -move=opt_move -move2=opt_move2 -norm=opt_norm \\\n            -auto=opt_auto -nobkp=opt_nobkp || \\\n        { +zi-log \"{info}[{pre}ziextract{info}]{error} Incorrect options given to\" \\\n                  \"\\`{pre}ziextract{msg2}' (available are: {meta}--auto{msg2},\" \\\n                  \"{meta}--move{msg2}, {meta}--move2{msg2}, {meta}--norm{msg2},\" \\\n                  \"{meta}--nobkp{msg2}).{rst}\"; return 1; }\n\n    local file=\"$1\" ext=\"$2\"\n    integer move=${${${(M)${#opt_move}:#0}:+0}:-1} \\\n            move2=${${${(M)${#opt_move2}:#0}:+0}:-1} \\\n            norm=${${${(M)${#opt_norm}:#0}:+0}:-1} \\\n            auto=${${${(M)${#opt_auto}:#0}:+0}:-1} \\\n            nobkp=${${${(M)${#opt_nobkp}:#0}:+0}:-1}\n\n    if (( auto )) {\n        # First try known file extensions\n        local -aU files\n        integer ret_val\n        files=( (#i)**/*.(zip|rar|7z|tgz|tbz|tbz2|tar.gz|tar.bz2|tar.7z|txz|tar.xz|gz|xz|tar|dmg|exe)~(*/*|.(_backup|git))/*(-.DN) )\n        for file ( $files ) {\n            ziextract \"$file\" $opt_move $opt_move2 $opt_norm $opt_nobkp ${${${#files}:#1}:+--nobkp}\n            ret_val+=$?\n        }\n        # Second, try to find the archive via `file' tool\n        if (( !${#files} )) {\n            local -aU output infiles stage2_processed archives\n            infiles=( **/*~(._zinit*|._backup|.git)(|/*)~*/*/*(-.DN) )\n            output=( ${(@f)\"$(command file -- $infiles 2>&1)\"} )\n            archives=( ${(M)output[@]:#(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) *} )\n            for file ( $archives ) {\n                local fname=${(M)file#(${(~j:|:)infiles}): } desc=${file#(${(~j:|:)infiles}): } type\n                fname=${fname%%??}\n                [[ -z $fname || -n ${stage2_processed[(r)$fname]} ]] && continue\n                type=${(L)desc/(#b)(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) */$match[2]}\n                if [[ $type = (zip|rar|xz|7-zip|gzip|bzip2|tar|exe|pe32) ]] {\n                    (( !OPTS[opt_-q,--quiet] )) && \\\n                        +zi-log \"{info}[{pre}ziextract{info}]{msg2} detected a {meta}$type{rst} archive in the file {file}$fname{rst}.\"\n                    ziextract \"$fname\" \"$type\" $opt_move $opt_move2 $opt_norm --norm ${${${#archives}:#1}:+--nobkp}\n                    integer iret_val=$?\n                    ret_val+=iret_val\n\n                    (( iret_val )) && continue\n\n                    # Support nested tar.(bz2|gz|…) archives\n                    local infname=$fname\n                    [[ -f $fname.out ]] && fname=$fname.out\n                    files=( *.tar(ND) )\n                    if [[ -f $fname || -f ${fname:r} ]] {\n                        local -aU output2 archives2\n                        output2=( ${(@f)\"$(command file -- \"$fname\"(N) \"${fname:r}\"(N) $files[1](N) 2>&1)\"} )\n                        archives2=( ${(M)output2[@]:#(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) *} )\n                        local file2\n                        for file2 ( $archives2 ) {\n                            fname=${file2%:*} desc=${file2##*:}\n                            local type2=${(L)desc/(#b)(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) */$match[2]}\n                            if [[ $type != $type2 && \\\n                                $type2 = (zip|rar|xz|7-zip|gzip|bzip2|tar)\n                            ]] {\n                                # TODO: if multiple archives are really in the archive,\n                                # this might delete too soon… However, it's unusual case.\n                                [[ $fname != $infname && $norm -eq 0 ]] && command rm -f \"$infname\"\n                                (( !OPTS[opt_-q,--quiet] )) && \\\n                                    +zi-log \"{info}[{pre}ziextract{info}]{msg2} detected a {obj}${type2}{rst} archive in the file {file}${fname}{rst}.\"\n                                ziextract \"$fname\" \"$type2\" $opt_move $opt_move2 $opt_norm ${${${#archives}:#1}:+--nobkp}\n                                ret_val+=$?\n                                stage2_processed+=( $fname )\n                                if [[ $fname == *.out ]] {\n                                    [[ -f $fname ]] && command mv -f \"$fname\" \"${fname%.out}\"\n                                    stage2_processed+=( ${fname%.out} )\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return $ret_val\n    }\n\n    if [[ -z $file ]] {\n        +zi-log \"{info}[{pre}ziextract{info}]{error} argument needed (the file to extract) or the {meta}--auto{msg} option.\"\n        return 1\n    }\n    if [[ ! -e $file ]] {\n        +zi-log \"{info}[{pre}ziextract{info}]{error} ERROR:{msg} the file \\`{meta}${file}{msg}' doesn't exist.{rst}\"\n        return 1\n    }\n    if (( !nobkp )) {\n        command mkdir -p ._backup\n        command rm -rf ._backup/*(DN)\n        command mv -f *~(._zinit*|._backup|.git|.svn|.hg|$file)(DN) ._backup 2>/dev/null\n    }\n\n    .zinit-extract-wrapper() {\n        local file=\"$1\" fun=\"$2\" retval\n        (( !OPTS[opt_-q,--quiet] )) && \\\n            +zi-log \"{info}[{pre}ziextract{info}]{rst} Unpacking the files from: \\`{obj}$file{msg}'{…}{rst}\"\n        $fun; retval=$?\n        if (( retval == 0 )) {\n            local -a files\n            files=( *~(._zinit*|._backup|.git|.svn|.hg|$file)(DN) )\n            (( ${#files} && !norm )) && command rm -f \"$file\"\n        }\n        return $retval\n    }\n\n    →zinit-check() { (( ${+commands[$1]} )) || \\\n        +zi-log \"{info}[{pre}ziextract{info}]{error} Error:{msg} No command {data}$1{msg}, it is required to unpack {file}$2{rst}.\"\n    }\n\n    case \"${${ext:+.$ext}:-$file}\" in\n        ((#i)*.zip)\n            →zinit-extract() { →zinit-check unzip \"$file\" || return 1; command unzip -qq -o \"$file\"; }\n            ;;\n        ((#i)*.rar)\n            →zinit-extract() { →zinit-check unrar \"$file\" || return 1; command unrar x \"$file\"; }\n            ;;\n        ((#i)*.tar.bz2|(#i)*.tbz|(#i)*.tbz2)\n            →zinit-extract() { →zinit-check bzip2 \"$file\" || return 1; command bzip2 -dc \"$file\" | command tar --no-same-owner -xf -; }\n            ;;\n        ((#i)*.tar.gz|(#i)*.tgz)\n            →zinit-extract() { →zinit-check gzip \"$file\" || return 1; command gzip -dc \"$file\" | command tar --no-same-owner -xf -; }\n            ;;\n        ((#i)*.tar.xz|(#i)*.txz)\n            →zinit-extract() { →zinit-check xz \"$file\" || return 1; command xz -dc \"$file\" | command tar --no-same-owner -xf -; }\n            ;;\n        ((#i)*.tar.7z|(#i)*.t7z)\n            →zinit-extract() { →zinit-check 7z \"$file\" || return 1; command 7z x -so \"$file\" | command tar --no-same-owner -xf -; }\n            ;;\n        ((#i)*.tar)\n            →zinit-extract() { →zinit-check tar \"$file\" || return 1; command tar --no-same-owner -xf \"$file\"; }\n            ;;\n        ((#i)*.gz|(#i)*.gzip)\n            if [[ $file != (#i)*.gz ]] {\n                command mv $file $file.gz\n                file=$file.gz\n                integer zi_was_renamed=1\n            }\n            →zinit-extract() {\n                →zinit-check gunzip \"$file\" || return 1\n                .zinit-get-mtime-into \"$file\" 'ZINIT[tmp]'\n                command gunzip \"$file\" |& command grep -E -v '.out$'\n                integer ret=$pipestatus[1]\n                command touch -t \"$(strftime %Y%m%d%H%M.%S $ZINIT[tmp])\" \"$file\"\n                return ret\n            }\n            ;;\n        ((#i)*.bz2|(#i)*.bzip2)\n            # Rename file if its extension does not match \"bz2\". bunzip2 refuses\n            # to operate on files that are not named correctly.\n            # See https://github.com/zdharma-continuum/zinit/issues/105\n            if [[ $file != (#i)*.bz2 ]] {\n                command mv $file $file.bz2\n                file=$file.bz2\n            }\n            →zinit-extract() { →zinit-check bunzip2 \"$file\" || return 1\n                .zinit-get-mtime-into \"$file\" 'ZINIT[tmp]'\n                command bunzip2 \"$file\" |& command grep -E -v '.out$'\n                integer ret=$pipestatus[1]\n                command touch -t \"$(strftime %Y%m%d%H%M.%S $ZINIT[tmp])\" \"$file\"\n                return ret\n            }\n            ;;\n        ((#i)*.xz)\n            if [[ $file != (#i)*.xz ]] {\n                command mv $file $file.xz\n                file=$file.xz\n            }\n            →zinit-extract() { →zinit-check xz \"$file\" || return 1\n                .zinit-get-mtime-into \"$file\" 'ZINIT[tmp]'\n                command xz -d \"$file\"\n                integer ret=$?\n                command touch -t \"$(strftime %Y%m%d%H%M.%S $ZINIT[tmp])\" \"$file\"\n                return ret\n             }\n            ;;\n        ((#i)*.7z|(#i)*.7-zip)\n            →zinit-extract() { →zinit-check 7z \"$file\" || return 1; command 7z x \"$file\" >/dev/null;  }\n            ;;\n        ((#i)*.dmg)\n            →zinit-extract() {\n                local prog\n                for prog ( hdiutil cp ) { →zinit-check $prog \"$file\" || return 1; }\n\n                integer retval\n                local attached_vol=\"$( command hdiutil attach \"$file\" | \\\n                           command tail -n1 | command cut -f 3 )\"\n\n                command cp -Rf ${attached_vol:-${TMPDIR:-/tmp}/acb321GEF}/*(D) .\n                retval=$?\n                command hdiutil detach $attached_vol\n\n                if (( retval )) {\n                    +zi-log \"{info}[{pre}ziextract{info}]{error} Error:{msg} problem occurred when attempted to copy the files\" \\\n                            \"from the mounted image: \\`{obj}${file}{msg}'.{rst}\"\n                }\n                return $retval\n            }\n            ;;\n        ((#i)*.deb)\n            →zinit-extract() { →zinit-check dpkg-deb \"$file\" || return 1; command dpkg-deb -R \"$file\" .; }\n            ;;\n        ((#i)*.rpm)\n            →zinit-extract() { →zinit-check cpio \"$file\" || return 1; $ZINIT[BIN_DIR]/share/rpm2cpio.zsh \"$file\" | command cpio -imd --no-absolute-filenames; }\n            ;;\n        ((#i)*.exe|(#i)*.pe32)\n            →zinit-extract() {\n                command chmod a+x -- ./$file\n                ./$file /S /D=\"`cygpath -w $PWD`\"\n            }\n            ;;\n    esac\n\n    if [[ $(typeset -f + →zinit-extract) == \"→zinit-extract\" ]] {\n        .zinit-extract-wrapper \"$file\" →zinit-extract || {\n            +zi-log -n \"{info}[{pre}ziextract{info}]{error} Error:{msg} extraction of the archive \\`{file}${file}{msg}' had problems\"\n            local -a bfiles\n            bfiles=( ._backup/*(DN) )\n            if (( ${#bfiles} && !nobkp )) {\n                +zi-log -n \", restoring the previous version of the plugin/snippet\"\n                command mv ._backup/*(DN) . 2>/dev/null\n            }\n            +zi-log \".{rst}\"\n            unfunction -- →zinit-extract →zinit-check 2>/dev/null\n            return 1\n        }\n        unfunction -- →zinit-extract →zinit-check\n    } else {\n        integer warning=1\n    }\n    unfunction -- .zinit-extract-wrapper\n\n    local -aU execs\n    execs=( **/*~(._zinit(|/*)|.git(|/*)|.svn(|/*)|.hg(|/*)|._backup(|/*))(DN-.) )\n    if [[ ${#execs} -gt 0 && -n $execs ]] {\n        execs=( ${(@f)\"$( file ${execs[@]} )\"} )\n        execs=( \"${(M)execs[@]:#[^(:]##:*executable*}\" )\n        execs=( \"${execs[@]/(#b)([^(:]##):*/${match[1]}}\" )\n    }\n\n    builtin print -rl -- ${execs[@]} >! ${TMPDIR:-/tmp}/zinit-execs.$$.lst\n    if [[ ${#execs} -gt 0 ]] {\n        command chmod a+x \"${execs[@]}\"\n        if (( !OPTS[opt_-q,--quiet] )) {\n            if (( ${#execs} == 1 )); then\n                    +zi-log \"{info}[{pre}ziextract{info}]{rst} Successfully extracted and assigned +x chmod to the file: {obj}${execs[1]}{rst}.\"\n            else\n                local sep=\"$ZINIT[col-rst],$ZINIT[col-obj] \"\n                if (( ${#execs} > 7 )) {\n                    +zi-log \"{info}[{pre}ziextract{info}]{rst} Successfully\" \\\n                        \"extracted and marked executable the appropriate files\" \\\n                        \"({obj}${(pj:$sep:)${(@)execs[1,5]:t}},…{rst}) contained\" \\\n                        \"in \\`{file}$file{rst}'. All the extracted\" \\\n                        \"{obj}${#execs}{rst} executables are\" \\\n                        \"available in the {msg2}INSTALLED_EXECS{rst}\" \\\n                        \"array.\"\n                } else {\n                    +zi-log \"{info}[{pre}ziextract{info}]{rst} Successfully\" \\\n                        \"extracted and marked {obj}${#execs}{rst} executable the appropriate files\" \\\n                        \"({obj}${(pj:$sep:)${execs[@]:t}}{rst}) contained\" \\\n                        \"in \\`{file}$file{rst}'.\"\n                }\n            fi\n        }\n    } elif (( warning )) {\n        +zi-log \"{info}[{pre}ziextract{info}]{error} Error:{msg} didn't recognize archive type of {obj}${file}{msg} ${ext:+/ {obj2}${ext}{msg} } (no extraction has been done).{rst}\"\n    }\n\n    if (( move | move2 )) {\n        local -a files\n        files=( *~(._zinit|.git|._backup|.tmp231ABC)(DN/) )\n        if (( ${#files} )) {\n            command mkdir -p .tmp231ABC\n            command mv -f *~(._zinit|.git|._backup|.tmp231ABC)(D) .tmp231ABC\n            if (( !move2 )) {\n                command mv -f **/*~(*/*~*/*/*|*/*/*/*|^*/*|._zinit(|/*)|.git(|/*)|._backup(|/*))(DN) .\n            } else {\n                command mv -f **/*~(*/*~*/*/*/*|*/*/*/*/*|^*/*|._zinit(|/*)|.git(|/*)|._backup(|/*))(DN) .\n            }\n\n            command mv .tmp231ABC/$file . &>/dev/null\n            command rm -rf .tmp231ABC\n        }\n        REPLY=\"${${execs[1]:h}:h}/${execs[1]:t}\"\n    } else {\n        REPLY=\"${execs[1]}\"\n    }\n    return 0\n} # ]]]\n# FUNCTION: .zinit-extract [[[\n.zinit-extract() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent\n    local tpe=$1 extract=$2 local_dir=$3\n    (\n        builtin cd -q \"$local_dir\" || \\\n            { +zi-log \"{error}ERROR:{msg2} The path of the $tpe\" \\\n                      \"(\\`{file}$local_dir{msg2}') isn't accessible.{rst}\"\n                return 1\n            }\n        local -aU files\n        files=( ${(@)${(@s: :)${extract##(\\!-|-\\!|\\!|-)}}//(#b)(((#s)|([^\\\\])[\\\\]([\\\\][\\\\])#)|((#s)|([^\\\\])([\\\\][\\\\])#)) /${match[2]:+$match[3]$match[4] }${match[5]:+$match[6]${(l:${#match[7]}/2::\\\\:):-} }} )\n        if [[ ${#files} -eq 0 && -n ${extract##(\\!-|-\\!|\\!|-)} ]] {\n                +zi-log \"{error}ERROR:{msg2} The files\" \\\n                        \"(\\`{file}${extract##(\\!-|-\\!|\\!|-)}{msg2}')\" \\\n                        \"not found, cannot extract.{rst}\"\n                return 1\n        } else {\n            (( !${#files} )) && files=( \"\" )\n        }\n        local file\n        for file ( \"${files[@]}\" ) {\n            [[ -z $extract ]] && local auto2=--auto\n            ziextract ${${(M)extract:#(\\!|-)##}:+--auto} \\\n                $auto2 $file \\\n                ${${(MS)extract[1,2]##-}:+--norm} \\\n                ${${(MS)extract[1,2]##\\!}:+--move} \\\n                ${${(MS)extract[1,2]##\\!\\!}:+--move2} \\\n                ${${${#files}:#1}:+--nobkp}\n        }\n    )\n} # ]]]\n# FUNCTION: .zinit-at-eval [[[\n.zinit-at-eval() {\n    local atpull=\"$1\" atclone=\"$2\"\n    integer retval\n    @zinit-substitute atclone atpull\n\n    local cmd=\"$atpull\"\n    [[ $atpull == \"%atclone\" ]] && cmd=\"$atclone\"\n\n    eval \"$cmd\"\n    return \"$?\"\n} # ]]]\n# FUNCTION: .zinit-get-cygwin-package [[[\n.zinit-get-cygwin-package() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes\n\n    REPLY=\n\n    local pkg=$1 nl=$'\\n'\n    integer retry=3\n\n    #\n    # Download mirrors.lst\n    #\n\n    +zi-log \"{info}Downloading{ehi}: {obj}mirrors.lst{info}{…}{rst}\"\n    local mlst=\"$(mktemp)\"\n    while (( retry -- )) {\n        if ! .zinit-download-file-stdout https://cygwin.com/mirrors.lst 0 > $mlst; then\n            .zinit-download-file-stdout https://cygwin.com/mirrors.lst 1 > $mlst\n        fi\n\n        local -a mlist\n        mlist=( \"${(@f)$(<$mlst)}\" )\n\n        local mirror=${${mlist[ RANDOM % (${#mlist} + 1) ]}%%;*}\n        [[ -n $mirror ]] && break\n    }\n\n    if [[ -z $mirror ]] {\n        +zi-log \"{error}Couldn't download{error}: {obj}mirrors.lst {error}.\"\n        return 1\n    }\n\n    mirror=http://ftp.eq.uc.pt/software/pc/prog/cygwin/\n\n    #\n    # Download setup.ini.bz2\n    #\n\n    +zi-log \"{info2}Selected mirror is{error}: {url}${mirror}{rst}\"\n    +zi-log \"{info}Downloading{ehi}: {file}setup.ini.bz2{info}{…}{rst}\"\n    local setup=\"$(mktemp -u)\"\n    retry=3\n    while (( retry -- )) {\n        if ! .zinit-download-file-stdout ${mirror}x86_64/setup.bz2 0 1 > $setup.bz2; then\n            .zinit-download-file-stdout ${mirror}x86_64/setup.bz2 1 1 > $setup.bz2\n        fi\n\n        command bunzip2 \"$setup.bz2\" 2>/dev/null\n        [[ -s $setup ]] && break\n        mirror=${${mlist[ RANDOM % (${#mlist} + 1) ]}%%;*}\n        +zi-log \"{pre}Retrying{error}: {meta}#{obj}$(( 3 - $retry ))/3, {pre}with mirror{error}: {url}${mirror}{rst}\"\n    }\n    local setup_contents=\"$(command grep -A 26 \"@ $pkg\\$\" \"$setup\")\"\n    local urlpart=${${(S)setup_contents/(#b)*@ $pkg${nl}*install: (*)$nl*/$match[1]}%% *}\n    if [[ -z $urlpart ]] {\n        +zi-log \"{error}Couldn't find package{error}: {data2}\\`{data}${pkg}{data2}'{error}.{rst}\"\n        return 2\n    }\n    local url=$mirror/$urlpart outfile=${TMPDIR:-${TMPDIR:-/tmp}}/${urlpart:t}\n\n    #\n    # Download the package\n    #\n\n    +zi-log \"{nl}{i} Downloading {b}{file}${url:t}{rst}\"\n    retry=2\n    while (( retry -- )) {\n        integer retval=0\n        if ! .zinit-download-file-stdout $url 0 1 > $outfile; then\n            if ! .zinit-download-file-stdout $url 1 1 > $outfile; then\n                +zi-log \"{error}Couldn't download{error}: {url}${url}{error}.\"\n                retval=1\n                mirror=${${mlist[ RANDOM % (${#mlist} + 1) ]}%%;*}\n                url=$mirror/$urlpart outfile=${TMPDIR:-${TMPDIR:-/tmp}}/${urlpart:t}\n                if (( retry )) {\n                    +zi-log \"{info2}Retrying, with mirror{error}: {url}${mirror}{info2}{…}{rst}\"\n                    continue\n                }\n            fi\n        fi\n        break\n    }\n    REPLY=$outfile\n} # ]]]\n# FUNCTION: zicp [[[\nzicp() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes\n\n    local -a mbegin mend match\n\n    local cmd=cp\n    if [[ $1 = (-m|--mv) ]] { cmd=mv; shift; }\n\n    local dir\n    if [[ $1 = (-d|--dir)  ]] { dir=$2; shift 2; }\n\n    local arg\n    arg=${${(j: :)@}//(#b)(([[:space:]]~ )#(([^[:space:]]| )##)([[:space:]]~ )#(#B)(->|=>|→)(#B)([[:space:]]~ )#(#b)(([^[:space:]]| )##)|(#B)([[:space:]]~ )#(#b)(([^[:space:]]| )##))/${match[3]:+$match[3] $match[6]\\;}${match[8]:+$match[8] $match[8]\\;}}\n\n    (\n        if [[ -n $dir ]] { cd $dir || return 1; }\n        local a b var\n        integer retval\n        for a b ( \"${(s: :)${${(@s.;.)${arg%\\;}}:-* .}}\" ) {\n            for var ( a b ) {\n                : ${(P)var::=${(P)var//(#b)(((#s)|([^\\\\])[\\\\]([\\\\][\\\\])#)|((#s)|([^\\\\])([\\\\][\\\\])#)) /${match[2]:+$match[3]$match[4] }${match[5]:+$match[6]${(l:${#match[7]}/2::\\\\:):-} }}}\n            }\n            if [[ $a != *\\** ]] { a=${a%%/##}\"/*\" }\n            command mkdir -p ${~${(M)b:#/*}:-$ZPFX/$b}\n            command $cmd -f ${${(M)cmd:#cp}:+-R} $~a ${~${(M)b:#/*}:-$ZPFX/$b}\n            retval+=$?\n        }\n        return $retval\n    )\n    return\n} # ]]]\n# FUNCTION: zimv [[[\nzimv() {\n    local dir\n    if [[ $1 = (-d|--dir) ]] { dir=$2; shift 2; }\n    zicp --mv ${dir:+--dir} $dir \"$@\"\n} # ]]]\n# FUNCTION: ∞zinit-reset-hook [[[\n∞zinit-reset-hook() {\n    # File\n    if [[ \"$1\" = plugin ]] {\n        local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"${5#%}\" hook=\"$6\"\n    } else {\n        local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"${4#%}\" hook=\"$5\"\n    }\n    if (( ( OPTS[opt_-r,--reset] && ZINIT[-r/--reset-opt-hook-has-been-run] == 0 ) || \\\n        ( ${+ICE[reset]} && ZINIT[-r/--reset-opt-hook-has-been-run] == 1 )\n    )) {\n        if (( ZINIT[-r/--reset-opt-hook-has-been-run] )) {\n            local msg_bit=\"{meta}reset{msg2} ice given{pre}\" option=\n        } else {\n            local msg_bit=\"{meta2}-r/--reset{msg2} given to \\`{meta}update{pre}'\" option=1\n        }\n        if [[ $type == snippet ]] {\n            if (( $+ICE[svn] )) {\n                if [[ $skip_pull -eq 0 && -d $filename/.svn ]] {\n                    (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{pre}reset ($msg_bit): {msg2}Resetting the repository ($msg_bit) with command: {rst}svn revert --recursive {…}/{file}$filename/.{rst} {…}\"\n                    command svn revert --recursive $filename/.\n                }\n            } else {\n                if (( ZINIT[annex-multi-flag:pull-active] >= 2 )) {\n                    if (( !OPTS[opt_-q,--quiet] )) {\n                        if [[ -f $local_dir/$dirname/$filename ]] {\n                            if [[ -n $option || -z $ICE[reset] ]] {\n                                +zi-log \"{pre}reset ($msg_bit):{msg2} Removing the snippet-file: {file}$filename{msg2} {…}{rst}\"\n                            } else {\n                                +zi-log \"{pre}reset ($msg_bit):{msg2} Removing the snippet-file: {file}$filename{msg2},\" \\\n                                    \"with the supplied code: {data2}$ICE[reset]{msg2} {…}{rst}\"\n                            }\n                            if (( option )) {\n                                command rm -f \"$local_dir/$dirname/$filename\"\n                            } else {\n                                eval \"${ICE[reset]:-rm -f \\\"$local_dir/$dirname/$filename\\\"}\"\n                            }\n                        } else {\n                            +zi-log \"{pre}reset ($msg_bit):{msg2} The file {file}$filename{msg2} is already deleted {…}{rst}\"\n                            if [[ -n $ICE[reset] && ! -n $option ]] {\n                                +zi-log \"{pre}reset ($msg_bit):{msg2} (skipped running the provided reset-code:\" \\\n                                    \"{data2}$ICE[reset]{msg2}){rst}\"\n                            }\n                        }\n                    }\n                } else {\n                        [[ -f $local_dir/$dirname/$filename ]] && \\\n                            +zi-log \"{pre}reset ($msg_bit): {msg2}Skipping the removal of {file}$filename{msg2}\" \\\n                                 \"as there is no new copy scheduled for download.{rst}\" || \\\n                            +zi-log \"{pre}reset ($msg_bit): {msg2}The file {file}$filename{msg2} is already deleted\" \\\n                                \"and {ehi}no new download is being scheduled.{rst}\"\n                }\n            }\n        } elif [[ $type == plugin ]] {\n            if (( is_release && !skip_pull )) {\n                if (( option )) {\n                    (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{pre}reset ($msg_bit): {msg2}running: {rst}rm -rf ${${ZINIT[PLUGINS_DIR]:#[/[:space:]]##}:-${TMPDIR:-/tmp}/xyzabc312}/${${(M)${local_dir##${ZINIT[PLUGINS_DIR]}[/[:space:]]#}:#[^/]*}:-${TMPDIR:-/tmp}/xyzabc312-zinit-protection-triggered}/*\"\n                    builtin eval command rm -rf ${${ZINIT[PLUGINS_DIR]:#[/[:space:]]##}:-${TMPDIR:-/tmp}/xyzabc312}/\"${${(M)${local_dir##${ZINIT[PLUGINS_DIR]}[/[:space:]]#}:#[^/]*}:-${TMPDIR:-/tmp}/xyzabc312-zinit-protection-triggered}\"/*(ND)\n                } else {\n                    (( !OPTS[opt_-q,--quiet] )) && +zi-log \"{pre}reset ($msg_bit): {msg2}running: {rst}${ICE[reset]:-rm -rf ${${ZINIT[PLUGINS_DIR]:#[/[:space:]]##}:-${TMPDIR:-/tmp}/xyzabc312}/${${(M)${local_dir##${ZINIT[PLUGINS_DIR]}[/[:space:]]#}:#[^/]*}:-${TMPDIR:-/tmp}/xyzabc312-zinit-protection-triggered}/*}\"\n                    builtin eval ${ICE[reset]:-command rm -rf ${${ZINIT[PLUGINS_DIR]:#[/[:space:]]##}:-${TMPDIR:-/tmp}/xyzabc312}/\"${${(M)${local_dir##${ZINIT[PLUGINS_DIR]}[/[:space:]]#}:#[^/]*}:-${TMPDIR:-/tmp}/xyzabc312-zinit-protection-triggered}\"/*(ND)}\n                }\n            } elif (( !skip_pull )) {\n                if (( option )) {\n                    +zi-log \"{pre}reset ($msg_bit): {msg2}Resetting the repository with command:{rst} git reset --hard HEAD {…}\"\n                    command git reset --hard HEAD\n                } else {\n                    +zi-log \"{pre}reset ($msg_bit): {msg2}Resetting the repository with command:{rst} ${ICE[reset]:-git reset --hard HEAD} {…}\"\n                    builtin eval \"${ICE[reset]:-git reset --hard HEAD}\"\n                }\n            }\n        }\n    }\n\n    if (( OPTS[opt_-r,--reset] )) {\n        if (( ZINIT[-r/--reset-opt-hook-has-been-run] == 1 )) {\n            ZINIT[-r/--reset-opt-hook-has-been-run]=0\n        } else {\n            ZINIT[-r/--reset-opt-hook-has-been-run]=1\n        }\n    } else {\n        # If theres no -r/--reset, pretend that it already has been served.\n        ZINIT[-r/--reset-opt-hook-has-been-run]=1\n    }\n} # ]]]\n# FUNCTION: ∞zinit-configure-base-hook [[[\n# A base common implementation of the configure ice\n∞zinit-configure-base-hook () {\n    emulate -L zsh\n    setopt extendedglob\n    if [[ \"$1\" = plugin ]]; then\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" ex=\"$8\"\n    else\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\" ex=\"$7\"\n    fi\n    local flags configure eflags aflags ice='{b}configure{rst}:'\n    configure=${ICE[configure]}\n    @zinit-substitute configure\n    (( ${+ICE[configure]} )) || return 0\n    flags=${(M)configure##[smc0\\!\\#]##}\n    configure=${configure##$flags([[:space:]]##|(#e))}\n    eflags=${(SM)flags##[\\!]##}\n    aflags=${(SM)flags##[smc0]##}\n    [[ $eflags == $ex ]] || return 0\n    typeset -aU configure_opt=(${(@s; ;)configure})\n    configure_opt+=(\"--prefix=${ZPFX:-${ZINIT[HOME_DIR]}/polaris}\")\n    {\n        builtin cd -- \"$dir\" || return 1\n        if [[ -n *(#i)makefile(#qN) ]]; then\n            return 0\n        elif [[ -z *(#i)configure(#qN) ]]; then\n            +zi-log \"{m} ${ice} Attempting to generate configure script... \"\n            local c\n            for c in \"[[ -e autogen.sh ]] && sh ./autogen.sh\" \"[[ -n *.a[mc](#qN.) ]] && autoreconf -ifm\" \"git clean -fxd; aclocal --force; autoconf --force; automake --add-missing --copy --force-missing\"; do\n                +zi-log -PrD \"{dbg} ${ice} {faint}${c}{rst}\"\n                {\n                    eval \"${c}\" 2> /dev/null >&2\n                } always {\n                    [[ -n *(#i)configure(#qN) ]] && break\n                    (( TRY_BLOCK_ERROR = 0 ))\n                }\n            done\n        fi\n        +zi-log \"{m} ${ice} Generating Makefile\"\n        +zi-log \"{dbg} ${ice} {faint}./configure $(builtin print -PDn -- ${(Ds; ;)configure_opt[@]//prefix /prefix=}){rst}\"\n        eval \"./configure ${(S)configure_opt[@]//prefix /prefix=}\" 2> /dev/null >&2\n        if [[ -n *(#i)makefile(#qN) ]]; then\n            +zi-log \"{m} ${ice} Successfully generated Makefile\"\n            return 0\n        else\n            +zi-log \"{e} ${ice} Failed project configuration\"\n            return 1\n        fi\n    }\n} # ]]]\n# FUNCTION: ∞zinit-configure-e-hook [[[\n∞zinit-configure-e-hook() {\n    ∞zinit-configure-base-hook \"$@\" \"!\"\n} # ]]]\n# FUNCTION: ∞zinit-configure-hook [[[\n# The non-! version of configure'' ice. Runs in between\n# of make'!' and make''. Configure script naturally runs\n# before make.\n∞zinit-configure-hook() {\n    ∞zinit-configure-base-hook \"$@\" \"\"\n} # ]]]\n\n# FUNCTION: ∞zinit-make-base-hook [[[\n# A base common implementation of the make ice\n∞zinit-make-base-hook () {\n    emulate -L zsh\n    setopt extendedglob\n    [[ -z $ICE[make] ]] && return 0\n    if [[ \"$1\" = plugin ]]; then\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" ex=\"$8\"\n    else\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\" ex=\"$7\"\n    fi\n    local make=${ICE[make]} ice='{b}make{rst}:'\n    @zinit-substitute make\n    (( ${+ICE[make]} )) || return 0\n    local eflags=${(M)make##[\\!]##}\n    make=${make##$eflags}\n    [[ $ex == $eflags ]] || return 0\n    local make_prefix='prefix'\n    if grep -w -- \"PREFIX =\" ${dir}/[Mm]akefile >/dev/null; then\n        make_prefix=\"PREFIX\"\n    fi\n\n    local src=($dir/[Cc][Mm]ake*(N.om[1]))\n    if (( $#src )); then\n      +zi-log \"{m} ${ice} Detected Cmake project, using CMAKE_INSTALL_PREFIX={file}\\$ZPFX{rst}\"\n      make_prefix=\"CMAKE_INSTALL_PREFIX\"\n    else\n      +zi-log -ru2 -- \"{dbg} ${dir:t}: No Cmake files found in ${dir}\"\n    fi\n    local prefix=\"${ZINIT[ZPFX]}\"\n    if [[ -n OPTS[opt_-q,--quiet] || -n ${ZINIT[DEBUG]:#1} ]]; then\n        +zi-log \"{dbg} ${ice} setting quiet mode\"\n        local quiet='2>/dev/null 1>&2'\n    fi\n    local -i ret=0\n    {\n        build=\"make -C ${dir} --jobs 4\"\n        +zi-log \"{m} ${ice} Building...\"\n        # +zi-log \"{m} ${ice} {faint}${(Ds; ;)build} $make_prefix=$(builtin print -Pnf '%s' ${(D)ZINIT[ZPFX]}){rst}\"\n        +zi-log \"{dbg} ${ice} eval ${build} $make_prefix=$prefix 2>/dev/null 1>&2\"\n        eval \"${build} $make_prefix=$prefix\" 2>/dev/null 1>&2\n        ret=$?\n    } always {\n        if (( ret )); then\n            +zi-log \"{w} ${ice} Build returned {num}${ret}{rst}\"\n        fi\n        (( TRY_BLOCK_ERROR = 0 ))\n    }\n    {\n        install=\"${build} ${make}\"\n        # +zi-log \"{m} ${ice} {faint}${(Ds; ;)build} $make_prefix=$(builtin print -Pnf '%s' ${ZINIT[POLARIS]}) ${make} {rst}\"\n        +zi-log \"{m} ${ice} Installing in ${(D)ZINIT[ZPFX]}\"\n        +zi-log \"{dbg} ${ice} eval ${build} $make_prefix=$prefix ${make} 2>/dev/null 1>&2\"\n        eval \"${(s; ;)install} $make_prefix=$prefix\" 2>/dev/null 1>&2\n        ret=$?\n    } always {\n        if (( ret )); then\n            +zi-log \"{w} ${ice} Install returned {num}${ret}{rst}\"\n        fi\n        (( TRY_BLOCK_ERROR = 0 ))\n    }\n    return $ret\n} # ]]]\n# FUNCTION: ∞zinit-make-e-hook [[[\n∞zinit-make-e-hook() {\n    ∞zinit-make-base-hook \"$@\" \"!\"\n} # ]]]\n# FUNCTION: ∞zinit-make-ee-hook [[[\n∞zinit-make-ee-hook() {\n    ∞zinit-make-base-hook \"$@\" \"!!\"\n} # ]]]\n# FUNCTION: ∞zinit-make-hook [[[\n∞zinit-make-hook() {\n    ∞zinit-make-base-hook \"$@\" \"\"\n} # ]]]\n\n# FUNCTION: __zinit-cmake-base-hook [[[\n# A base common implementation of the cmake ice\n__zinit-cmake-base-hook () {\n    emulate -L zsh\n    setopt extended_glob\n    (( ${+ICE[cmake]} )) || return 0\n    if (( ! ${+commands[cmake]} )); then\n        +zi-log \"{e} {cmd}cmake{rst} required to use {ice}cmake{rst} ice\"\n        return 0\n    fi\n    if [[ \"$1\" = plugin ]]; then\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" ex=\"$8\"\n    else\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\" ex=\"$7\"\n    fi\n    (( OPTS[opt_-q,--quiet] || ZINIT[DEBUG] )) && local QUIET='2>/dev/null 1>&2'\n    local c ret=0 ice='{b}cmake{rst}:'\n    for c in \"-S ${dir} -B ${dir}/build -DCMAKE_BUILD_TYPE=Release --install-prefix ${ZINIT[ZPFX]} ${QUIET}\" \"--build ${dir}/build --parallel $(nproc) ${QUIET}\" \"--install ${dir}/build ${QUIET}\"; do\n      +zi-log \"{m} ${ice} {faint}cmake ${(Ds; ;)c} {rst}\"\n        eval \"cmake ${c}\" 2> /dev/null >&2\n        if (( $? )); then\n            +zi-log \"{e} ${ice} Failure cmake ${c}{rst}\"\n            ret=$?\n        fi\n    done\n    return $?\n} # ]]]\n# FUNCTION: +zinit-cmake-hook [[[\n+zinit-cmake-hook() {\n    __zinit-cmake-base-hook \"$@\"\n} # ]]]\n\n# FUNCTION: ∞zinit-atclone-hook [[[\n∞zinit-atclone-hook() {\n    [[ \"$1\" = plugin ]] && \\\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    local atclone=${ICE[atclone]}\n    @zinit-substitute atclone\n    (( ${+ICE[atclone]} )) || return 0\n\n    local rc=0\n    [[ -n $atclone ]] && .zinit-countdown atclone && {\n        local ___oldcd=$PWD\n\n        (( ${+ICE[nocd]} == 0 )) && {\n            () {\n                setopt localoptions noautopushd\n                builtin cd -q \"$dir\"\n            }\n        }\n\n        eval \"$atclone\"\n        rc=\"$?\"\n\n        () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }\n    }\n\n    return \"$rc\"\n} # ]]]\n# FUNCTION: ∞zinit-extract-hook [[[\n∞zinit-extract-hook() {\n    [[ \"$1\" = plugin ]] && \\\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    local extract=${ICE[extract]}\n    @zinit-substitute extract\n\n    (( ${+ICE[extract]} )) || return 0\n\n    .zinit-extract plugin \"$extract\" \"$dir\"\n} # ]]]\n# FUNCTION: ∞zinit-mv-hook [[[\n∞zinit-mv-hook() {\n    [[ -z $ICE[mv] ]] && return 0\n\n    [[ \"$1\" = plugin ]] && \\\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    if [[ $ICE[mv] == *(\"->\"|\"→\")* ]] {\n        local from=${ICE[mv]%%[[:space:]]#(->|→)*} to=${ICE[mv]##*(->|→)[[:space:]]#} || \\\n    } else {\n        local from=${ICE[mv]%%[[:space:]]##*} to=${ICE[mv]##*[[:space:]]##}\n    }\n\n    @zinit-substitute from to\n\n    local -a mv_args=(\"-f\")\n    local -a afr\n\n    (\n        () { setopt localoptions noautopushd; builtin cd -q \"$dir\"; } || return 1\n        afr=( ${~from}(DN) )\n\n        if (( ! ${#afr} )) {\n            +zi-log \"{warn}Warning: mv ice didn't match any file. [{error}$ICE[mv]{warn}]\" \\\n                           \"{nl}{warn}Available files:{nl}{obj}$(ls -1)\"\n            return 1\n        }\n        if (( !OPTS[opt_-q,--quiet] )) {\n            mv_args+=(\"-v\")\n        }\n\n        command mv \"${mv_args[@]}\" \"${afr[1]}\" \"$to\"\n        local retval=$?\n        command mv \"${mv_args[@]}\" \"${afr[1]}\".zwc \"$to\".zwc 2>/dev/null\n        return $retval\n    )\n} # ]]]\n# FUNCTION: ∞zinit-cp-hook [[[\n∞zinit-cp-hook() {\n    [[ -z $ICE[cp] ]] && return\n\n    [[ \"$1\" = plugin ]] && \\\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    if [[ $ICE[cp] == *(\"->\"|\"→\")* ]] {\n        local from=${ICE[cp]%%[[:space:]]#(->|→)*} to=${ICE[cp]##*(->|→)[[:space:]]#} || \\\n    } else {\n        local from=${ICE[cp]%%[[:space:]]##*} to=${ICE[cp]##*[[:space:]]##}\n    }\n\n    @zinit-substitute from to\n\n    local -a afr retval\n    ( () { setopt localoptions noautopushd; builtin cd -q \"$dir\"; } || return 1\n      afr=( ${~from}(DN) )\n      if (( ${#afr} )) {\n          if (( !OPTS[opt_-q,--quiet] )) {\n              command cp -vf \"${afr[1]}\" \"$to\"\n              retval=$?\n              # ignore errors if no compiled file is found\n              command cp -vf \"${afr[1]}\".zwc \"$to\".zwc 2>/dev/null\n          } else {\n              command cp -f \"${afr[1]}\" \"$to\"\n              retval=$?\n              # ignore errors if no compiled file is found\n              command cp -f \"${afr[1]}\".zwc \"$to\".zwc 2>/dev/null\n          }\n      }\n      return $retval\n    )\n} # ]]]\n# FUNCTION: ∞zinit-compile-plugin-hook [[[\n∞zinit-compile-plugin-hook () {\n    if [[ \"$1\" = plugin ]]; then\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\"\n    else\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n    fi\n    if ! [[ ( $hook = *\\!at(clone|pull)* && ${+ICE[nocompile]} -eq 0 ) || ( $hook = at(clone|pull)* && $ICE[nocompile] = '!' ) ]]; then\n        return 0\n    fi\n    if [[ -z $ICE[(i)(\\!|)(sh|bash|ksh|csh)] ]]; then\n        () {\n            builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n            setopt local_options extended_glob warn_create_global\n            local quiet=1\n            if [[ $tpe == snippet ]]; then\n                .zinit-compile-plugin \"%$dir\"\n            else\n                .zinit-compile-plugin \"$id_as\"\n            fi\n        }\n    fi\n} # ]]]\n# FUNCTION: ∞zinit-atpull-e-hook [[[\n∞zinit-atpull-e-hook() {\n    (( ${+ICE[atpull]} )) || return 0\n    [[ -n ${ICE[atpull]} ]] || return 0\n    # Only process atpull\"!cmd\"\n    [[ $ICE[atpull] == \"!\"* ]] || return 0\n\n    [[ \"$1\" = plugin ]] && \\\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    local atpull=${ICE[atpull]#\\!}\n    local rc=0\n\n    .zinit-countdown atpull && {\n        local ___oldcd=$PWD\n        (( ${+ICE[nocd]} == 0 )) && {\n            () { setopt localoptions noautopushd; builtin cd -q \"$dir\"; }\n        }\n        .zinit-at-eval \"$atpull\" \"$ICE[atclone]\"\n        rc=\"$?\"\n        () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; };\n    }\n\n    return \"$rc\"\n} # ]]]\n# FUNCTION: ∞zinit-atpull-hook [[[\n∞zinit-atpull-hook() {\n    (( ${+ICE[atpull]} )) || return 0\n    [[ -n ${ICE[atpull]} ]] || return 0\n    # Exit early if atpull\"!cmd\" -> this is done by zinit-atpull-e-hook\n    [[ $ICE[atpull] == \"!\"* ]] && return 0\n\n    [[ \"$1\" == plugin ]] && \\\n        local dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    local atpull=${ICE[atpull]}\n    local rc=0\n\n    .zinit-countdown atpull && {\n        local ___oldcd=$PWD\n        (( ${+ICE[nocd]} == 0 )) && {\n            () { setopt localoptions noautopushd; builtin cd -q \"$dir\"; }\n        }\n        .zinit-at-eval \"$atpull\" $ICE[atclone]\n        rc=\"$?\"\n        () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; };\n    }\n\n    return \"$rc\"\n} # ]]]\n# FUNCTION: ∞zinit-ps-on-update-hook [[[\n∞zinit-ps-on-update-hook() {\n    [[ -z $ICE[ps-on-update] ]] && return 0\n\n    [[ \"$1\" = plugin ]] && \\\n        local tpe=\"$1\" dir=\"${5#%}\" hook=\"$6\" subtype=\"$7\" || \\\n        local tpe=\"$1\" dir=\"${4#%}\" hook=\"$5\" subtype=\"$6\"\n\n    if (( !OPTS[opt_-q,--quiet] )) {\n        +zi-log \"Running $tpe's provided update code: {info}${ICE[ps-on-update][1,50]}${ICE[ps-on-update][51]:+…}{rst}\"\n        (\n            builtin cd -q \"$dir\" || return 1\n            eval \"$ICE[ps-on-update]\"\n        )\n    } else {\n        (\n            builtin cd -q \"$dir\" || return 1\n            eval \"$ICE[ps-on-update]\" &> /dev/null\n        )\n    }\n} # ]]]\n\n# vim: ft=zsh sw=2 ts=2 et foldmarker=[[[,]]] foldmethod=marker\n"
        },
        {
          "name": "zinit-side.zsh",
          "type": "blob",
          "size": 14.5791015625,
          "content": "#!/usr/bin/env zsh\n#\n# Copyright (c) 2016-2020 Sebastian Gniazdowski and contributors\n# Copyright (c) 2021-2022 zdharma-continuum and contributors\n\n# FUNCTION: .zinit-any-colorify-as-uspl2 [[[\n# Returns ANSI-colorified \"user/plugin\" string, from any supported\n# plugin spec (user---plugin, user/plugin, user plugin, plugin).\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n#\n# $REPLY - ANSI-colorified \"user/plugin\" string\n.zinit-any-colorify-as-uspl2() {\n  .zinit-any-to-user-plugin \"$1\" \"$2\"\n  local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n  if [[ \"$user\" = \"%\" ]]; then\n    .zinit-any-to-pid \"\" $plugin\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--plugins--/OMZP::}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--plugins/OMZP}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--lib--/OMZL::}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--lib/OMZL}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--themes--/OMZT::}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--themes/OMZT}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk--/OMZ::}\"\n    REPLY=\"${REPLY/https--github.com--(robbyrussell--oh-my-zsh|ohmyzsh--ohmyzsh)--trunk/OMZ}\"\n    REPLY=\"${REPLY/https--github.com--sorin-ionescu--prezto--trunk--modules--/PZTM::}\"\n    REPLY=\"${REPLY/https--github.com--sorin-ionescu--prezto--trunk--modules/PZTM}\"\n    REPLY=\"${REPLY/https--github.com--sorin-ionescu--prezto--trunk--/PZT::}\"\n    REPLY=\"${REPLY/https--github.com--sorin-ionescu--prezto--trunk/PZT}\"\n    REPLY=\"${REPLY/(#b)%([A-Z]##)(#c0,1)(*)/%$ZINIT[col-uname]$match[1]$ZINIT[col-pname]$match[2]$ZINIT[col-rst]}\"\n  elif [[ $user == http(|s): ]]; then\n    REPLY=\"${ZINIT[col-ice]}${user}/${plugin}${ZINIT[col-rst]}\"\n  else\n    REPLY=\"${user:+${ZINIT[col-uname]}${user}${ZINIT[col-rst]}/}${ZINIT[col-pname]}${plugin}${ZINIT[col-rst]}\"\n  fi\n} # ]]]\n# FUNCTION: .zinit-compute-ice [[[\n# Computes ICE array\n#   - input\n#   - static\n#   - saved\n# taking priorities into account.\n# Can also pack resulting ices into ZINIT_SICE (see $2).\n# Returns filepath to snippet directory and optional snippet file name (only\n# valid if ICE[svn] is not set).\n#\n# $1 - URL (also plugin-spec)\n# $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ICE\n#      wins with static ice; \"pack-nf\" means that disk-ices will\n#      be ignored (no-file?)\n# $3 - name of output associative array, \"ICE\" is the default\n# $4 - name of output string parameter, to hold path to directory (\"local_dir\")\n# $5 - name of output string parameter, to hold filename (\"filename\")\n# $6 - name of output string parameter, to hold is-snippet 0/1-bool (\"is_snippet\")\n#\n# $REPLY - snippet directory filepath\n.zinit-compute-ice() {\n  builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n  setopt extendedglob typesetsilent warncreateglobal noshortloops\n\n  local ___URL=\"${1%/}\" ___pack=\"$2\" ___is_snippet=0\n  local ___var_name1=\"${3:-ZINIT_ICE}\" ___var_name2=\"${4:-local_dir}\" ___var_name3=\"${5:-filename}\" ___var_name4=\"${6:-is_snippet}\"\n\n  # Copy from .zinit-recall\n  local -a ice_order nval_ices\n  ice_order=(\n    ${(s.|.)ZINIT[ice-list]}\n    # include all additional ices – after stripping them from the possible: ''\n    ${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}\n  )\n  nval_ices=(\n    ${(s.|.)ZINIT[nval-ice-list]}\n    # include only those additional ices, don't have the '' in their name, i.e.\n    # aren't designed to hold value\n    ${(@)${(@)${(@Akons:|:)ZINIT_EXTS[ice-mods]}:#*\\'\\'*}/(#s)<->-/}\n    svn\n  )\n\n  # strip whitespace from beginning of url\n  ___URL=\"${${___URL#\"${___URL%%[! $'\\t']*}\"}%/}\"\n\n  # snippet\n  .zinit-two-paths \"$___URL\"\n  local ___s_path=\"${reply[-4]}\" ___s_svn=\"${reply[-3]}\" ___path=\"${reply[-2]}\" ___filename=\"${reply[-1]}\" ___local_dir\n\n  if [[ -d \"$___s_path\" || -d \"$___path\" ]]; then\n    ___is_snippet=1\n  else\n    # plugin\n    .zinit-any-to-user-plugin \"$___URL\" \"\"\n    local ___user=\"${reply[-2]}\" ___plugin=\"${reply[-1]}\"\n    ___s_path=\"\" ___filename=\"\"\n    [[ \"$___user\" = \"%\" ]] && ___path=\"$___plugin\" || ___path=\"${ZINIT[PLUGINS_DIR]}/${___user:+${___user}---}${___plugin//\\//---}\"\n    .zinit-exists-physically-message \"$___user\" \"$___plugin\" || return 1\n  fi\n\n  [[ $___pack = pack* ]] && (( ${#ICE} > 0 )) && .zinit-pack-ice \"${___user-$___URL}\" \"$___plugin\"\n\n  local -A ___sice\n  local -a ___tmp\n\n  ___tmp=( \"${(z@)ZINIT_SICE[${___user-$___URL}${${___user:#(%|/)*}:+/}$___plugin]}\" )\n  (( ${#___tmp[@]} > 1 && ${#___tmp[@]} % 2 == 0 )) && ___sice=( \"${(Q)___tmp[@]}\" )\n\n  if [[ \"${+___sice[svn]}\" = \"1\" || -n \"$___s_svn\" ]]; then\n    if (( !___is_snippet && ${+___sice[svn]} == 1 )); then\n      builtin print -r -- \"The \\`svn' ice is given, but the argument ($___URL) is a plugin\"\n      builtin print -r -- \"(\\`svn' can be used only with snippets)\"\n      return 1\n    elif (( !___is_snippet )); then\n      builtin print -r -- \"Undefined behavior #1 occurred, please report at https://github.com/zdharma-continuum/zinit/issues\"\n      return 1\n    fi\n    if [[ -e \"$___s_path\" && -n \"$___s_svn\" ]]; then\n      ___sice[svn]=\"\"\n      ___local_dir=\"$___s_path\"\n    else\n      if [[ ! -e \"$___path\" ]] { \n        builtin print -r -- \"No such snippet, looked at paths (1): $___s_path, and: $___path\";\n        return 1;\n      }\n      unset '___sice[svn]'\n      ___local_dir=\"$___path\"\n    fi\n  else\n    if [[ -e \"$___path\" ]]; then\n      unset '___sice[svn]'\n      ___local_dir=\"$___path\"\n    else\n      builtin print -r -- \"No such snippet, looked at paths (2): $___s_path, and: $___path\"\n      return 1\n    fi\n  fi\n\n  local ___zinit_path=\"$___local_dir/._zinit\"\n  # read disk-ice\n  local -A ___mdata\n  local ___key\n\n  {\n    for ___key in mode url is_release is_release{2..5} ${ice_order[@]}; do\n      [[ -f \"$___zinit_path/$___key\" ]] && ___mdata[$___key]=\"$(<$___zinit_path/$___key)\"\n    done\n    [[ \"${___mdata[mode]}\" = \"1\" ]] && ___mdata[svn]=\"\"\n  } 2>/dev/null\n\n  # handle flag-ices; svn must be last\n  for ___key in ${ice_order[@]}; do\n    [[ $___key == (no|)compile ]] && continue\n\n    if (( 0 == ${+ICE[no$___key]} && 0 == ${+___sice[no$___key]} )) {\n      continue\n    }\n    # \"If there is such ice currently, and there's no no* ice given, and\n    # there's the no* ice in the static ice\" – skip, don't unset. With\n    # conjunction with the previous line this has the proper meaning: uset if\n    # at least in one – current or static – ice there is the no* ice unless it\n    # is the only in the static ice (unless there's on such ice \"anyway\").\n    if (( 1 == ${+ICE[$___key]} && 0 == ${+ICE[no$___key]} && 1 == ${+___sice[no$___key]} )) {\n      continue\n    }\n\n    if [[ \"$___key\" = \"svn\" ]]; then\n      command builtin print -r -- \"0\" >! \"$___zinit_path/mode\"\n      ___mdata[mode]=0\n    else\n      command rm -f -- \"$___zinit_path/$___key\"\n    fi\n\n    unset \"___mdata[$___key]\" \"___sice[$___key]\" \"ICE[$___key]\"\n  done\n\n  # final decision, static ice vs. saved ice\n  local -A ___MY_ICE\n  for ___key in mode url is_release is_release{2..5} ${ice_order[@]}; do\n    # The second sum is: if the pack is *not* pack-nf, then depending on the\n    # disk availability, otherwise: no disk ice\n    (( ${+___sice[$___key]} + ${${${___pack:#pack-nf*}:+${+___mdata[$___key]}}:-0} )) && ___MY_ICE[$___key]=\"${___sice[$___key]-${___mdata[$___key]}}\"\n  done\n  # One more round for the special case – update, which ALWAYS needs the teleid\n  # from the disk or static ice\n  ___key=teleid; [[ \"$___pack\" = pack-nftid ]] && {\n    (( ${+___sice[$___key]} + ${+___mdata[$___key]} )) && ___MY_ICE[$___key]=\"${___sice[$___key]-${___mdata[$___key]}}\"\n  }\n\n  : ${(PA)___var_name1::=\"${(kv)___MY_ICE[@]}\"}\n  : ${(P)___var_name2::=$___local_dir}\n  : ${(P)___var_name3::=$___filename}\n  : ${(P)___var_name4::=$___is_snippet}\n\n  return 0\n} # ]]]\n# FUNCTION: .zinit-countdown [[[\n# Displays a countdown 5...4... etc.\n#\n# $REPLY - 1 if Ctrl-C is pressed, otherwise 0\n.zinit-countdown() {\n  (( !${+ICE[countdown]} )) && return 0\n\n  builtin emulate -L zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n  trap \"+zi-log \\\"{ehi}ABORTING, the ice {ice}$ice{ehi} not ran{rst}\\\"; return 1\" INT\n\n  local count=5 ice tpe=\"$1\"\n\n  ice=\"${ICE[$tpe]}\"\n  [[ $tpe = \"atpull\" && $ice = \"%atclone\" ]] && ice=\"${ICE[atclone]}\"\n  ice=\"{b}{ice}$tpe{ehi}:{rst}${ice//(#b)(\\{[a-z0-9…–_-]##\\})/\\\\$match[1]}\"\n\n  +zi-log -n \"{hi}Running $ice{rst}{hi} ice in...{rst} \"\n\n  while (( -- count + 1 )) {\n    +zi-log -n -- \"{b}{error}\"$(( count + 1 ))\"{rst}{…}\"\n    sleep 1\n  }\n\n  +zi-log -r -- \"{b}{error}0 <running now>{rst}{…}\"\n  return 0\n} # ]]]\n# FUNCTION: .zinit-exists-physically [[[\n# Checks if directory of given plugin exists in PLUGIN_DIR.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-exists-physically() {\n  .zinit-any-to-user-plugin \"$1\" \"$2\"\n  if [[ ${reply[-2]} = % ]]; then\n    [[ -d ${reply[-1]} ]] && return 0 || return 1\n  else\n    [[ -d ${ZINIT[PLUGINS_DIR]}/${reply[-2]:+${reply[-2]}---}${reply[-1]//\\//---} ]] \\\n      && return 0 \\\n      || return 1\n  fi\n} # ]]]\n# FUNCTION: .zinit-exists-physically-message [[[\n# Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error\n# message if it doesn't.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-exists-physically-message() {\n  builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n  builtin setopt extendedglob warncreateglobal typesetsilent noshortloops rcquotes\n  if ! .zinit-exists-physically \"$1\" \"$2\"; then\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    if [[ $reply[1] = % ]]; then\n      .zinit-any-to-pid \"$1\" \"$2\"\n      local spec1=$REPLY\n      if [[ $1 = %* ]]; then\n        local spec2=%${1#%}${${1#%}:+${2:+/}}$2\n      elif [[ -z $1 || -z $2 ]]; then\n        local spec3=%${1#%}${2#%}\n      fi\n    else\n      integer nospec=1\n    fi\n    .zinit-any-colorify-as-uspl2 \"$1\" \"$2\"\n\n    +zi-log \"{error}No such (plugin or snippet){rst}: $REPLY.\"\n\n    [[ $nospec -eq 0 && $spec1 != $spec2 ]] \\\n      && +zi-log \"(expands to: {file}${spec2#%}{rst}).\"\n\n    return 1\n  fi\n  return 0\n} # ]]]\n# FUNCTION: .zinit-first [[[\n# Finds the main file of plugin. There are multiple file name formats, they are\n# ordered in order starting from more correct ones, and matched.\n# .zinit-load-plugin() has similar code parts and doesn't call .zinit-first() –\n# for performance. Obscure matching is done in .zinit-find-other-matches, here\n# and in .zinit-load(). Obscure = non-standard main-file naming convention.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n.zinit-first() {\n  .zinit-any-to-user-plugin \"$1\" \"$2\"\n  local user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n\n  .zinit-any-to-pid \"$1\" \"$2\"\n  .zinit-get-object-path plugin \"$REPLY\"\n  integer ret=$?\n  local dname=\"$REPLY\"\n  (( ret )) && { reply=( \"$dname\" \"\" ); return 1; }\n\n  # look for file to compile - first look for the most common one (optimization)\n  # then for other possibilities\n  if [[ -e \"$dname/$plugin.plugin.zsh\" ]]; then\n    reply=( \"$dname/$plugin.plugin.zsh\" )\n  else\n    .zinit-find-other-matches \"$dname\" \"$plugin\"\n  fi\n\n  if [[ \"${#reply}\" -eq \"0\" ]]; then\n    reply=( \"$dname\" \"\" )\n    return 1\n  fi\n\n  # take first entry (ksharrays resilience)\n  reply=( \"$dname\" \"${reply[-${#reply}]}\" )\n  return 0\n} # ]]]\n# FUNCTION: .zinit-store-ices [[[\n# Saves ice mods in given hash onto disk.\n#\n# $1 - directory where to create or delete files\n# $2 - name of hash that holds values\n# $3 - additional keys of hash to store, space separated\n# $4 - additional keys of hash to store, empty-meaningful ices, space separated\n# $5 – URL, if applicable\n# $6 – mode, svn=1, 0=single file\n.zinit-store-ices() {\n  local ___pfx=\"$1\" ___ice_var=\"$2\" ___add_ices=\"$3\" ___add_ices2=\"$4\"\n  local url=\"$5\" mode=\"$6\"\n\n  # Copy from zinit-recall response\n  local -a ice_order nval_ices\n  ice_order=(\n    ${(s.|.)ZINIT[ice-list]}\n    # include all additional ices – after stripping them from the possible: ''\n    ${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}\n  )\n  nval_ices=(\n    ${(s.|.)ZINIT[nval-ice-list]}\n    # include only those additional ices, don't have the '' in their name, i.e.\n    # aren't designed to hold value\n    ${(@)${(@)${(@Akons:|:)ZINIT_EXTS[ice-mods]}:#*\\'\\'*}/(#s)<->-/}\n    # must be last\n    svn\n  )\n\n  command mkdir -p \"$___pfx\" && echo '*' > \"$___pfx/.gitignore\"\n  local ___key ___var_name\n  # No nval_ices here\n  for ___key in ${ice_order[@]:#(${(~j:|:)nval_ices[@]})} ${(s: :)___add_ices[@]}; do\n    ___var_name=\"${___ice_var}[$___key]\"\n    (( ${(P)+___var_name} )) && builtin print -r -- \"${(P)___var_name}\" >! \"$___pfx\"/\"$___key\"\n  done\n\n  # Ices that even empty mean something\n  for ___key in ${nval_ices[@]} ${(s: :)___add_ices2[@]}; do\n    ___var_name=\"${___ice_var}[$___key]\"\n    if (( ${(P)+___var_name} )); then\n      builtin print -r -- \"${(P)___var_name}\" >! \"$___pfx\"/\"$___key\"\n    else\n      command rm -f \"$___pfx\"/\"$___key\"\n    fi\n  done\n\n  # url and mode are declared at the beginning of the body\n  for ___key in url mode; do\n    [[ -n \"${(P)___key}\" ]] && builtin print -r -- \"${(P)___key}\" >! \"$___pfx\"/\"$___key\"\n  done\n} # ]]]\n# FUNCTION: .zinit-two-paths [[[\n# Obtains a snippet URL without specification if it is an SVN URL (points to\n# directory) or regular URL (points to file), returns 2 possible paths for\n# further examination\n#\n# $REPLY - two filepaths\n.zinit-two-paths() {\n  builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n  setopt extendedglob typesetsilent warncreateglobal noshortloops\n\n  local dirnameA dirnameB local_dirA local_dirB svn_dirA url1 url2 url=$1\n  local -a fileB_there\n\n  # remove leading whitespace and trailing /\n  url=\"${${url#\"${url%%[! $'\\t']*}\"}%/}\"\n  url1=$url\n  url2=$url\n\n  .zinit-get-object-path snippet \"$url1\"\n  local_dirA=$reply[-3] dirnameA=$reply[-2]\n  [[ -d \"$local_dirA/$dirnameA/.svn\" ]] && {\n    svn_dirA=\".svn\"\n    if { .zinit-first % \"$local_dirA/$dirnameA\"; } {\n      fileB_there=( ${reply[-1]} )\n    }\n  }\n\n  .zinit-get-object-path snippet \"$url2\"\n  local_dirB=$reply[-3] dirnameB=$reply[-2]\n\n  [[ -z $svn_dirA ]] && fileB_there=( \"$local_dirB/$dirnameB\"/*~*.(zwc|md|js|html)(.-DOnN[1]) )\n\n  reply=( \"$local_dirA/$dirnameA\" \"$svn_dirA\" \"$local_dirB/$dirnameB\" \"${fileB_there[1]##$local_dirB/$dirnameB/#}\" )\n} # ]]]\n\n# Local Variables:\n# mode: Shell-Script\n# sh-indentation: 2\n# indent-tabs-mode: nil\n# sh-basic-offset: 2\n# End:\n# vim: ft=zsh sw=2 ts=2 et foldmarker=[[[,]]] foldmethod=marker\n"
        },
        {
          "name": "zinit.zsh",
          "type": "blob",
          "size": 150.0625,
          "content": "#\n# zdharma-continuum/zinit/zinit.zsh\n# Copyright (c) 2016-2021 Sebastian Gniazdowski\n# Copyright (c) 2021-2023 zdharma-continuum\n# Homepage: https://github.com/zdharma-continuum/zinit\n# License: MIT License\n#\n\n#\n# Main state variables.\n#\n\ntypeset -gaH ZINIT_REGISTERED_PLUGINS ZINIT_TASKS ZINIT_RUN\ntypeset -ga zsh_loaded_plugins\nif (( !${#ZINIT_TASKS} )) { ZINIT_TASKS=( \"<no-data>\" ); }\n# Snippets loaded, url -> file name.\ntypeset -gAH ZINIT ZINIT_SNIPPETS ZINIT_REPORTS ZINIT_ICES ZINIT_SICE ZINIT_CUR_BIND_MAP ZINIT_EXTS ZINIT_EXTS2\ntypeset -gaH ZINIT_COMPDEF_REPLAY\n\n# Compatibility with pre-rename project (Zplugin).\ntypeset -gAH ZPLGM\nZINIT=( \"${(kv)ZPLGM[@]}\" \"${(kv)ZINIT[@]}\" )\nunset ZPLGM\n\n#\n# Common needed values.\n#\n\n[[ ! -e ${ZINIT[BIN_DIR]}/zinit.zsh ]] && ZINIT[BIN_DIR]=\n\n# Respect the plugin standard too.\nZINIT[ZERO]=\"${ZERO:-${${0:#$ZSH_ARGZERO}:-${(%):-%N}}}\"\n[[ ! -o functionargzero || ${options[posixargzero]} = on || ${ZINIT[ZERO]} != */* ]] && ZINIT[ZERO]=\"${(%):-%N}\"\n\n: ${ZINIT[BIN_DIR]:=\"${ZINIT[ZERO]:h}\"}\n[[ ${ZINIT[BIN_DIR]} = \\~* ]] && ZINIT[BIN_DIR]=${~ZINIT[BIN_DIR]}\n\n# Make ZINIT[BIN_DIR] path absolute.\nZINIT[BIN_DIR]=\"${${(M)ZINIT[BIN_DIR]:#/*}:-$PWD/${ZINIT[BIN_DIR]}}\"\n\n# Final test of ZINIT[BIN_DIR].\nif [[ ! -e ${ZINIT[BIN_DIR]}/zinit.zsh ]]; then\n    builtin print -P \"%F{196}Could not establish ZINIT[BIN_DIR] hash field. It should point where Zinit's Git repository is.%f\"\n    return 1\nfi\n\n# User can override ZINIT[HOME_DIR].\nif [[ -z ${ZINIT[HOME_DIR]} ]]; then\n    # Search for zinit home in the usual locations\n    if [[ -d ${XDG_DATA_HOME:-${HOME}/.local/share}/zinit ]]; then\n        ZINIT[HOME_DIR]=\"${XDG_DATA_HOME:-${HOME}/.local/share}/zinit\"\n    elif [[ -d $HOME/.zinit ]]; then\n        ZINIT[HOME_DIR]=\"$HOME/.zinit\"\n    elif [[ -d ${ZDOTDIR:-$HOME}/.zinit ]]; then\n        ZINIT[HOME_DIR]=\"${ZDOTDIR:-$HOME}/.zinit\"\n    elif [[ -d $HOME/.zplugin ]]; then\n        ZINIT[HOME_DIR]=\"$HOME/.zplugin\"\n    elif [[ -d ${ZDOTDIR:-$HOME}/.zplugin ]]; then\n        ZINIT[HOME_DIR]=\"${ZDOTDIR:-$HOME}/.zplugin\"\n    else\n        ZINIT[HOME_DIR]=\"${XDG_DATA_HOME:-${HOME}/.local/share}/zinit\"\n    fi\nfi\n\nif [[ -z ${ZINIT[LIST_COMMAND]} ]]; then\n    if (( ${+commands[exa]} )); then\n        ZINIT[LIST_COMMAND]='exa --color=always --tree --icons -L3'\n    elif (( ${+commands[tree]} )); then\n        ZINIT[LIST_COMMAND]='tree -L 3 -C --charset utf-8'\n    else\n        ZINIT[LIST_COMMAND]='ls --tree'\n    fi\nfi\n\nZINIT[ice-list]=\"\\\n\\!bash|\\!csh|\\!ksh|\\!sh|\\\naliases|as|atclone|atdelete|atinit|atload|atpull|autoload|\\\nbash|binary|bindmap|blockf|bpick|build|\\\ncloneonly|cloneopts|cmake|compile|completions|configure|countdown|cp|csh|\\\ndebug|depth|\\\nextract|\\\nfrom|git|\\\nhas|\\\nid-as|if|install|is-snippet|\\\nksh|\\\nlight-mode|link|load|lucid|\\\nmake|multisrc|mv|nocd|nocompile|nocompletions|notify|null|\\\non-update-of|opts|\\\npack|param|pick|proto|ps-on-unload|ps-on-update|pullopts|\\\nreset|reset-prompt|run-atpull|\\\nservice|sh|silent|src|subscribe|subst|svn|\\\nteleid|trackbinds|trigger-load|\\\nunload|\\\nver|verbose|\\\nwait|wrap\"\nZINIT[nval-ice-list]=\"\\\n\\!bash|\\!csh|\\!ksh|\\!sh|\\\naliases|\\\nbash|binary|blockf|\\\ncloneonly|cloneopts|cmake|configure|countdown|csh|\\\ndebug|\\\ngit|\\\nis-snippet|\\\nksh|\\\nlight-mode|lucid|\\\nmake|\\\nnocd|nocompile|nocompletions|notify|null|\\\npullopts|\\\nreset|run-atpull|\\\nsh|silent|\\\ntrackbinds|\\\nverbose\"\nZINIT[cmds]=\"\\\nadd-fpath|\\\nbindkeys|\\\ncclear|cd|cdclear|cdisable|cdlist|cdreplay|cenable|changes|compile|compiled|compinit|completions|create|creinstall|csearch|cuninstall|\\\ndelete|debug|\\\nedit|env-whitelist|\\\nfpath|\\\nglance|\\\nhelp|--help|-h|\\\nice|\\\nlight|load|\\\nman|module|\\\nplugins|\\\nrecall|recently|report|run|\\\nself-update|snippet|snippets|srv|status|stress|\\\ntimes|\\\nuncompile|unload|update|\\\nversion|\\\nzstatus\"\n\n# Can be customized.\n: ${ZINIT[COMPLETIONS_DIR]:=${ZINIT[HOME_DIR]}/completions}\n: ${ZINIT[MODULE_DIR]:=${ZINIT[HOME_DIR]}/module}\n: ${ZINIT[PACKAGES_BRANCH]:=HEAD}\n: ${ZINIT[PACKAGES_REPO]:=zdharma-continuum/zinit-packages}\n: ${ZINIT[PLUGINS_DIR]:=${ZINIT[HOME_DIR]}/plugins}\n: ${ZINIT[POLARIS_DIR]:=${ZINIT[HOME_DIR]}/polaris}\n: ${ZINIT[SERVICES_DIR]:=${ZINIT[HOME_DIR]}/services}\n: ${ZINIT[SNIPPETS_DIR]:=${ZINIT[HOME_DIR]}/snippets}\n: ${ZINIT[ZPFX]:=${ZINIT[HOME_DIR]}/polaris}\ntypeset -g ZPFX\n: ${ZPFX:=${ZINIT[ZPFX]}}\n: ${ZINIT[ALIASES_OPT]::=${${options[aliases]:#off}:+1}}\n: ${ZINIT[MAN_DIR]:=${ZPFX}/man}\n\nZINIT[PLUGINS_DIR]=${~ZINIT[PLUGINS_DIR]}   ZINIT[COMPLETIONS_DIR]=${~ZINIT[COMPLETIONS_DIR]}\nZINIT[SNIPPETS_DIR]=${~ZINIT[SNIPPETS_DIR]} ZINIT[SERVICES_DIR]=${~ZINIT[SERVICES_DIR]}\nexport ZPFX=${~ZPFX} ZSH_CACHE_DIR=\"${ZSH_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/zinit}\" \\\n    PMSPEC=0uUpiPsf\n[[ -z ${path[(re)$ZPFX/bin]} ]] && [[ -d \"$ZPFX/bin\" ]] && path=( \"$ZPFX/bin\" \"${path[@]}\" )\n[[ -z ${path[(re)$ZPFX/sbin]} ]] && [[ -d \"$ZPFX/sbin\" ]] && path=( \"$ZPFX/sbin\" \"${path[@]}\" )\n\nhash -f\nhash -d zinit=${ZINIT[HOME_DIR]}\nhash -d plugins=${ZINIT[PLUGINS_DIR]}\nhash -d zpfx=${ZINIT[HOME_DIR]}/polaris\n\n# Add completions directory to fpath.\n[[ -z ${fpath[(re)${ZINIT[COMPLETIONS_DIR]}]} ]] && fpath=( \"${ZINIT[COMPLETIONS_DIR]}\" \"${fpath[@]}\" )\n\n[[ ! -d $ZSH_CACHE_DIR ]] && command mkdir -p \"$ZSH_CACHE_DIR\"\n[[ -n ${ZINIT[ZCOMPDUMP_PATH]} ]] && ZINIT[ZCOMPDUMP_PATH]=${~ZINIT[ZCOMPDUMP_PATH]}\n\nZINIT[UPAR]=\";:^[[A;:^[OA;:\\\\e[A;:\\\\eOA;:${termcap[ku]/$'\\e'/^\\[};:${terminfo[kcuu1]/$'\\e'/^\\[};:\"\nZINIT[DOWNAR]=\";:^[[B;:^[OB;:\\\\e[B;:\\\\eOB;:${termcap[kd]/$'\\e'/^\\[};:${terminfo[kcud1]/$'\\e'/^\\[};:\"\nZINIT[RIGHTAR]=\";:^[[C;:^[OC;:\\\\e[C;:\\\\eOC;:${termcap[kr]/$'\\e'/^\\[};:${terminfo[kcuf1]/$'\\e'/^\\[};:\"\nZINIT[LEFTAR]=\";:^[[D;:^[OD;:\\\\e[D;:\\\\eOD;:${termcap[kl]/$'\\e'/^\\[};:${terminfo[kcub1]/$'\\e'/^\\[};:\"\n\nbuiltin autoload -Uz is-at-least\nis-at-least 5.1 && ZINIT[NEW_AUTOLOAD]=1 || ZINIT[NEW_AUTOLOAD]=0\n#is-at-least 5.4 && ZINIT[NEW_AUTOLOAD]=2\n\n# Parameters [[[\n# temporary substituting of functions\nZINIT[TMP_SUBST]=inactive ZINIT[DTRACE]=0 ZINIT[CUR_PLUGIN]=\n\n# ice\ndeclare -gA ZINIT_1MAP ZINIT_2MAP\nZINIT_1MAP=(\n    OMZ:: https://github.com/ohmyzsh/ohmyzsh/trunk/\n    OMZP:: https://github.com/ohmyzsh/ohmyzsh/trunk/plugins/\n    OMZT:: https://github.com/ohmyzsh/ohmyzsh/trunk/themes/\n    OMZL:: https://github.com/ohmyzsh/ohmyzsh/trunk/lib/\n    PZT:: https://github.com/sorin-ionescu/prezto/trunk/\n    PZTM:: https://github.com/sorin-ionescu/prezto/trunk/modules/\n)\nZINIT_2MAP=(\n    OMZ:: https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/\n    OMZP:: https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/plugins/\n    OMZT:: https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/themes/\n    OMZL:: https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/lib/\n    PZT:: https://raw.githubusercontent.com/sorin-ionescu/prezto/master/\n    PZTM:: https://raw.githubusercontent.com/sorin-ionescu/prezto/master/modules/\n)\n# ]]]\n\n# Init [[[\nzmodload zsh/zutil || { builtin print -P \"%F{196}zsh/zutil module is required, aborting Zinit set up.%f\"; return 1; }\nzmodload zsh/parameter || { builtin print -P \"%F{196}zsh/parameter module is required, aborting Zinit set up.%f\"; return 1; }\nzmodload zsh/term{cap,info} 2>/dev/null\nautoload -Uz colors && colors\n\nif [[ -z $SOURCED && ( ${+terminfo} -eq 1 && -n ${terminfo[colors]} ) || ( ${+termcap} -eq 1 && -n ${termcap[Co]} ) ]]; then\n  ZINIT+=(\n    col-annex   $'\\e[38;5;153m'         col-faint   $'\\e[38;5;238m'         col-msg2    $'\\e[38;5;172m'      col-quo     $'\\e[1;38;5;33m'\n    col-apo     $'\\e[1;38;5;45m'        col-file    $'\\e[3;38;5;117m'       col-msg3    $'\\e[38;5;238m'      col-quos    $'\\e[1;38;5;160m'\n    col-aps     $'\\e[38;5;117m'         col-flag    $'\\e[1;3;38;5;79m'      col-nb      $'\\e[22m'            col-rst     $'\\e[0m'\n    col-b       $'\\e[1m'                col-func    $'\\e[38;5;219m'         col-nit     $'\\e[23m'            col-slight  $'\\e[38;5;230m'\n    col-b-lhi   $'\\e[1m\\e[38;5;75m'     col-glob    $'\\e[38;5;227m'         col-nl      $'\\n'                col-st      $'\\e[9m'\n    col-b-warn  $'\\e[1;38;5;214m'       col-happy   $'\\e[1m\\e[38;5;82m'     col-note    $'\\e[38;5;148m'      col-tab     $' \\t '\n    col-bapo    $'\\e[1;38;5;220m'       col-hi      $'\\e[1m\\e[38;5;183m'    col-nst     $'\\e[29m'            col-term    $'\\e[38;5;185m'\n    col-baps    $'\\e[1;38;5;82m'        col-ice     $'\\e[38;5;39m'          col-nu      $'\\e[24m'            col-th-bar  $'\\e[38;5;82m'\n    col-bar     $'\\e[38;5;82m'          col-id-as   $'\\e[4;38;5;220m'       col-num     $'\\e[3;38;5;155m'    col-time    $'\\e[38;5;220m'\n    col-bcmd    $'\\e[38;5;220m'         col-info    $'\\e[38;5;82m'          col-obj     $'\\e[38;5;218m'      col-txt     $'\\e[38;5;254m'\n    col-bspc    $'\\b'                   col-info2   $'\\e[38;5;227m'         col-obj2    $'\\e[38;5;118m'      col-u       $'\\e[4m'\n    col-cmd     $'\\e[38;5;82m'          col-info3   $'\\e[1m\\e[38;5;227m'    col-ok      $'\\e[38;5;220m'      col-u-warn  $'\\e[4;38;5;214m'\n    col-data    $'\\e[38;5;82m'          col-it      $'\\e[3m'                col-opt     $'\\e[38;5;219m'      col-uname   $'\\e[1;4m\\e[35m'\n    col-data2   $'\\e[38;5;117m'         col-keyword $'\\e[32m'               col-p       $'\\e[38;5;81m'       col-uninst  $'\\e[38;5;118m'\n    col-dir     $'\\e[3;38;5;153m'       col-lhi     $'\\e[38;5;81m'          col-pkg     $'\\e[1;3;38;5;27m'   col-url     $'\\e[38;5;75m'\n    col-ehi     $'\\e[1m\\e[38;5;210m'    col-meta    $'\\e[38;5;57m'          col-pname   $'\\e[1;4m\\e[32m'     col-var     $'\\e[38;5;81m'\n    col-error   $'\\e[1m\\e[38;5;204m'    col-meta2   $'\\e[38;5;147m'         col-pre     $'\\e[38;5;135m'      col-version $'\\e[3;38;5;87m'\n    col-failure $'\\e[38;5;204m'         col-msg     $'\\e[0m'                col-profile $'\\e[38;5;148m'      col-warn    $'\\e[38;5;214m'\n\n    col-dbg $'\\e[2m\\e[38;47;107m'\"[debug]\"$'\\e[0m'\n    col-e $'\\e[1m\\e[38;5;204m'\"Error\"$'\\e[0m'\":\"\n    col-i $'\\e[1m\\e[38;5;82m'\"==>\"$'\\e[0m'\n    col-m $'\\e[38;5;4m'\"==>\"$'\\e[0m'\n    col-w $'\\e[1m\\e[38;5;214m'\"Warning\"$'\\e[0m'\":\"\n\n    col--…   \"${${${(M)LANG:#*UTF-8*}:+⋯⋯}:-···}\"    col-lr \"${${${(M)LANG:#*UTF-8*}:+↔}:-\"«-»\"}\"\n    col-ndsh \"${${${(M)LANG:#*UTF-8*}:+–}:-}\"        col-…  \"${${${(M)LANG:#*UTF-8*}:+…}:-...}\"\n\n    col-mdsh  $'\\e[1;38;5;220m'\"${${${(M)LANG:#*UTF-8*}:+–}:--}\"$'\\e[0m'\n    col-mmdsh $'\\e[1;38;5;220m'\"${${${(M)LANG:#*UTF-8*}:+――}:--}\"$'\\e[0m'\n\n    col-↔     ${${${(M)LANG:#*UTF-8*}:+$'\\e[38;5;82m↔\\e[0m'}:-$'\\e[38;5;82m«-»\\e[0m'}\n  )\n  if [[ ( ${+terminfo} -eq 1 && ${terminfo[colors]} -ge 256 ) || ( ${+termcap} -eq 1 && ${termcap[Co]} -ge 256 ) ]]; then\n    ZINIT+=( col-pname $'\\e[1;4m\\e[38;5;39m' col-uname  $'\\e[1;4m\\e[38;5;207m' )\n  fi\nfi\n\n# Hooks\ntypeset -gAH ZINIT_ZLE_HOOKS_LIST\nZINIT_ZLE_HOOKS_LIST=(\n    zle-isearch-exit 1\n    zle-isearch-update 1\n    zle-line-pre-redraw 1\n    zle-line-init 1\n    zle-line-finish 1\n    zle-history-line-set 1\n    zle-keymap-select 1\n    paste-insert 1\n)\nbuiltin setopt noaliases\n# ]]]\n\n#\n# Temporary substituting of functions-related functions.\n#\n\n# FUNCTION: :zinit-reload-and-run [[[\n# Marks given function ($3) for autoloading, and executes it triggering the\n# load. $1 is the fpath dedicated to the function, $2 are autoload options.\n# This function replaces \"autoload -X\", because using that on older Zsh\n# versions causes problems with traps.\n#\n# So basically one creates function stub that calls :zinit-reload-and-run()\n# instead of \"autoload -X\".\n#\n# Author: Bart Schaefer\n#\n# $1 - FPATH dedicated to function\n# $2 - autoload options\n# $3 - function name (one that needs autoloading)\n:zinit-reload-and-run() {\n    local fpath_prefix=\"$1\" autoload_opts=\"$2\" func=\"$3\"\n    shift 3\n\n    # Unfunction caller function (its name is given).\n    unfunction -- \"$func\"\n\n    local -a ___fpath\n    ___fpath=( ${fpath[@]} )\n    local -a +h fpath\n    # See #127.\n    [[ $FPATH != *${${(@0)fpath_prefix}[1]}* ]] && \\\n        fpath=( ${(@0)fpath_prefix} ${___fpath[@]} )\n\n    # After this the function exists again.\n    builtin autoload ${(s: :)autoload_opts} -- \"$func\"\n\n    # User wanted to call the function, not only load it.\n    \"$func\" \"$@\"\n} # ]]]\n# FUNCTION: :zinit-tmp-subst-autoload [[[\n# Hijack plugin's calls to the 'autoload' builtin.\n#\n# The hijacking gathers report data and runs custom `autoload' function, that doesn't need FPATH.\n:zinit-tmp-subst-autoload() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob warncreateglobal typesetsilent rcquotes\n    local -a opts opts2 custom reply\n    local func\n\n    zparseopts -D -E -M -a opts ${(s::):-RTUXdkmrtWzwC} I+=opts2 S+:=custom\n\n    builtin set -- ${@:#--}\n\n    # Process the id-as''/teleid'' to get the plugin dir.\n    .zinit-any-to-user-plugin $ZINIT[CUR_USPL2]\n    [[ $reply[1] = % ]] && \\\n        local PLUGIN_DIR=\"$reply[2]\" || \\\n        local PLUGIN_DIR=\"$ZINIT[PLUGINS_DIR]/${reply[1]:+$reply[1]---}${reply[2]//\\//---}\"\n\n\n    # \"fpath elements\" ----  those elements that lie inside the plug directory.\n    local -a fpath_elements\n    fpath_elements=( ${fpath[(r)$PLUGIN_DIR/*]} )\n\n    # Add a function subdirectory to items, if any (this action is\n    # according to the Plug Standard version 1.07 and later).\n    [[ -d $PLUGIN_DIR/functions ]] && fpath_elements+=( \"$PLUGIN_DIR\"/functions )\n\n    if (( ${+opts[(r)-X]} )); then\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Warning: Failed autoload ${(j: :)opts[@]} $*\"\n        +zi-log -u2 \"{error}builtin autoload required for {obj}${(j: :)opts[@]}{error} option(s)\"\n        return 1\n    fi\n    if (( ${+opts[(r)-w]} )); then\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"-w-Autoload ${(j: :)opts[@]} ${(j: :)@}\"\n        fpath+=( $PLUGIN_DIR )\n        builtin autoload ${opts[@]} \"$@\"\n        return $?\n    fi\n    if [[ -n ${(M)@:#+X} ]]; then\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Autoload +X ${opts:+${(j: :)opts[@]} }${(j: :)${@:#+X}}\"\n        local +h FPATH=$PLUGINS_DIR${fpath_elements:+:${(j.:.)fpath_elements[@]}}:$FPATH\n        local +h -a fpath\n        fpath=( $PLUGIN_DIR $fpath_elements $fpath )\n        builtin autoload +X ${opts[@]} \"${@:#+X}\"\n        return $?\n    fi\n\n    for func; do\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Autoload $func${opts:+ with options ${(j: :)opts[@]}}\"\n    done\n\n    integer count retval\n    for func; do\n        # Real autoload doesn't touch function if it already exists.\n        # Author of the idea of FPATH-clean autoloading: Bart Schaefer.\n        if (( ${+functions[$func]} != 1 )) {\n            builtin setopt noaliases\n            if [[ $func == /* ]] && is-at-least 5.4; then\n                builtin autoload ${opts[@]} $func\n                return $?\n            elif [[ $func == /* ]]; then\n                if [[ $ZINIT[MUTE_WARNINGS] != (1|true|on|yes) && \\\n                        -z $ZINIT[WARN_SHOWN_FOR_$ZINIT[CUR_USPL2]] ]]; then\n                    +zi-log \"{u-warn}Warning{b-warn}: {rst}the plugin {pid}$ZINIT[CUR_USPL2]\" \\\n                        \"{rst}is using autoload functions specified by their absolute path,\" \\\n                        \"which is not supported by this Zsh version ({↔} {version}$ZSH_VERSION{rst},\" \\\n                        \"required is Zsh >= {version}5.4{rst}).\" \\\n                        \"{nl}A fallback mechanism has been applied, which works well only\" \\\n                        \"for functions in the plugin {u}{slight}main{rst} directory.\" \\\n                        \"{nl}(To mute this message, set\" \\\n                        \"{var}\\$ZINIT[MUTE_WARNINGS]{rst} to a truth value.)\"\n                    ZINIT[WARN_SHOWN_FOR_$ZINIT[CUR_USPL2]]=1\n                fi\n\n                # Workaround\n                func=$func:t\n            fi\n            if [[ ${ZINIT[NEW_AUTOLOAD]} = 2 ]]; then\n                builtin autoload ${opts[@]} \"$PLUGIN_DIR/$func\"\n                retval=$?\n            elif [[ ${ZINIT[NEW_AUTOLOAD]} = 1 ]]; then\n                if (( ${+opts[(r)-C]} )) {\n                    local pth nl=$'\\n' sel=\"\"\n                    for pth ( $PLUGIN_DIR $fpath_elements $fpath ) {\n                        [[ -f $pth/$func ]] && { sel=$pth; break; }\n                    }\n                    if [[ -z $sel ]] {\n                        +zi-log '{u-warn}zinit{b-warn}:{error} Couldn''t find autoload function{ehi}:' \\\n                            \"{apo}\\`{file}${func}{apo}\\`{error} anywhere in {var}\\$fpath{error}.\"\n                            retval=1\n                    } else {\n                        eval \"function ${(q)${custom[++count*2]}:-$func} {\n                            local body=\\\"\\$(<${(qqq)sel}/${(qqq)func})\\\" body2\n                            () { setopt localoptions extendedglob\n                                 body2=\\\"\\${body##[[:space:]]#${func}[[:blank:]]#\\(\\)[[:space:]]#\\{}\\\"\n                                 [[ \\$body2 != \\$body ]] && \\\n                                    body2=\\\"\\${body2%\\}[[:space:]]#([$nl]#([[:blank:]]#\\#[^$nl]#((#e)|[$nl]))#)#}\\\"\n                            }\n\n                            functions[${${(q)custom[count*2]}:-$func}]=\\\"\\$body2\\\"\n                            ${(q)${custom[count*2]}:-$func} \\\"\\$@\\\"\n                        }\"\n                        retval=$?\n                    }\n                } else {\n                    functions[$func]=\"\n                        local -a fpath\n                        fpath=( ${(qqq)PLUGIN_DIR} ${(qqq@)fpath_elements} ${(qqq@)fpath} )\n                        builtin autoload -X ${(j: :)${(q-)opts[@]}}\n                    \"\n                    retval=$?\n                }\n            else\n                eval \"function ${(q)func} {\n                    :zinit-reload-and-run ${(qqq)PLUGIN_DIR}\"$'\\0'\"${(pj,\\0,)${(qqq)fpath_elements[@]}} ${(qq)opts[*]} ${(q)func} \"'\"$@\"\n                }'\n                retval=$?\n            fi\n            (( ZINIT[ALIASES_OPT] )) && builtin setopt aliases\n        }\n        if (( ${+opts2[(r)-I]} )) {\n            ${custom[count*2]:-$func}\n            retval=$?\n        }\n    done\n\n    return $retval\n} # ]]]\n# FUNCTION: :zinit-tmp-subst-bindkey [[[\n# Function defined to hijack plugin's calls to the `bindkey' builtin.\n#\n# The hijacking is to gather report data (which is used in unload).\n:zinit-tmp-subst-bindkey() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob warncreateglobal typesetsilent noshortloops\n\n    is-at-least 5.3 && \\\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Bindkey ${(j: :)${(q+)@}}\" || \\\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Bindkey ${(j: :)${(q)@}}\"\n\n    # Remember to perform the actual bindkey call.\n    typeset -a pos\n    pos=( \"$@\" )\n\n    # Check if we have regular bindkey call, i.e.\n    # with no options or with -s, plus possible -M\n    # option.\n    local -A opts\n    zparseopts -A opts -D ${(s::):-lLdDAmrsevaR} M: N:\n\n    if (( ${#opts} == 0 ||\n        ( ${#opts} == 1 && ${+opts[-M]} ) ||\n        ( ${#opts} == 1 && ${+opts[-R]} ) ||\n        ( ${#opts} == 1 && ${+opts[-s]} ) ||\n        ( ${#opts} <= 2 && ${+opts[-M]} && ${+opts[-s]} ) ||\n        ( ${#opts} <= 2 && ${+opts[-M]} && ${+opts[-R]} )\n    )); then\n        local string=\"${(q)1}\" widget=\"${(q)2}\"\n        local quoted\n\n        if [[ -n ${ICE[bindmap]} && ${ZINIT_CUR_BIND_MAP[empty]} -eq 1 ]]; then\n            local -a pairs\n            pairs=( \"${(@s,;,)ICE[bindmap]}\" )\n            if [[ -n ${(M)pairs:#*\\\\(#e)} ]] {\n                local prev\n                pairs=( ${pairs[@]//(#b)((*)\\\\(#e)|(*))/${match[3]:+${prev:+$prev\\;}}${match[3]}${${prev::=${match[2]:+${prev:+$prev\\;}}${match[2]}}:+}} )\n            }\n            pairs=( \"${(@)${(@)${(@s:->:)pairs}##[[:space:]]##}%%[[:space:]]##}\" )\n            ZINIT_CUR_BIND_MAP=( empty 0 )\n            (( ${#pairs} > 1 && ${#pairs[@]} % 2 == 0 )) && ZINIT_CUR_BIND_MAP+=( \"${pairs[@]}\" )\n        fi\n\n        local bmap_val=\"${ZINIT_CUR_BIND_MAP[${1}]}\"\n        if (( !ZINIT_CUR_BIND_MAP[empty] )) {\n            [[ -z $bmap_val ]] && bmap_val=\"${ZINIT_CUR_BIND_MAP[${(qqq)1}]}\"\n            [[ -z $bmap_val ]] && bmap_val=\"${ZINIT_CUR_BIND_MAP[${(qqq)${(Q)1}}]}\"\n            [[ -z $bmap_val ]] && { bmap_val=\"${ZINIT_CUR_BIND_MAP[!${(qqq)1}]}\"; integer val=1; }\n            [[ -z $bmap_val ]] && bmap_val=\"${ZINIT_CUR_BIND_MAP[!${(qqq)${(Q)1}}]}\"\n        }\n        if [[ -n $bmap_val ]]; then\n            string=\"${(q)bmap_val}\"\n            if (( val )) {\n                [[ ${pos[1]} = \"-M\" ]] && pos[4]=\"$bmap_val\" || pos[2]=\"$bmap_val\"\n            } else {\n                [[ ${pos[1]} = \"-M\" ]] && pos[3]=\"${(Q)bmap_val}\" || pos[1]=\"${(Q)bmap_val}\"\n            }\n            .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \":::Bindkey: combination <$1> changed to <$bmap_val>${${(M)bmap_val:#hold}:+, i.e. ${ZINIT[col-error]}unmapped${ZINIT[col-rst]}}\"\n            ((1))\n        elif [[ ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[UPAR]}} && -n ${${ZINIT[UPAR]}[(r);:${(q)1};:]} ) || \\\n                ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[DOWNAR]}} && -n ${${ZINIT[DOWNAR]}[(r);:${(q)1};:]} ) || \\\n                ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[RIGHTAR]}} && -n ${${ZINIT[RIGHTAR]}[(r);:${(q)1};:]} ) || \\\n                ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[LEFTAR]}} && -n ${${ZINIT[LEFTAR]}[(r);:${(q)1};:]} )\n        ]]; then\n            string=\"${(q)bmap_val}\"\n            if (( val )) {\n                [[ ${pos[1]} = \"-M\" ]] && pos[4]=\"$bmap_val\" || pos[2]=\"$bmap_val\"\n            } else {\n                [[ ${pos[1]} = \"-M\" ]] && pos[3]=\"${(Q)bmap_val}\" || pos[1]=\"${(Q)bmap_val}\"\n            }\n            .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \":::Bindkey: combination <$1> recognized as cursor-key and changed to <${bmap_val}>${${(M)bmap_val:#hold}:+, i.e. ${ZINIT[col-error]}unmapped${ZINIT[col-rst]}}\"\n        fi\n        [[ $bmap_val = hold ]] && return 0\n\n        local prev=\"${(q)${(s: :)$(builtin bindkey ${(Q)string})}[-1]#undefined-key}\"\n\n        # \"-M map\" given?\n        if (( ${+opts[-M]} )); then\n            local Mopt=-M\n            local Marg=\"${opts[-M]}\"\n\n            Mopt=\"${(q)Mopt}\"\n            Marg=\"${(q)Marg}\"\n\n            quoted=\"$string $widget $prev $Mopt $Marg\"\n        else\n            quoted=\"$string $widget $prev\"\n        fi\n\n        # -R given?\n        if (( ${+opts[-R]} )); then\n            local Ropt=-R\n            Ropt=\"${(q)Ropt}\"\n\n            if (( ${+opts[-M]} )); then\n                quoted=\"$quoted $Ropt\"\n            else\n                # Two empty fields for non-existent -M arg.\n                local space=_\n                space=\"${(q)space}\"\n                quoted=\"$quoted $space $space $Ropt\"\n            fi\n        fi\n\n        quoted=\"${(q)quoted}\"\n\n        # Remember the bindkey, only when load is in progress (it can be dstart that leads execution here).\n        [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[BINDKEYS__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n        # Remember for dtrace.\n        [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[BINDKEYS___dtrace/_dtrace]+=\"$quoted \"\n    else\n        # bindkey -A newkeymap main?\n        # Negative indices for KSH_ARRAYS immunity.\n        if [[ ${#opts} -eq 1 && ${+opts[-A]} = 1 && ${#pos} = 3 && ${pos[-1]} = main && ${pos[-2]} != -A ]]; then\n            # Save a copy of main keymap.\n            (( ZINIT[BINDKEY_MAIN_IDX] = ${ZINIT[BINDKEY_MAIN_IDX]:-0} + 1 ))\n            local pname=\"${ZINIT[CUR_PLUGIN]:-_dtrace}\"\n            local name=\"${(q)pname}-main-${ZINIT[BINDKEY_MAIN_IDX]}\"\n            builtin bindkey -N \"$name\" main\n\n            # Remember occurence of main keymap substitution, to revert on unload.\n            local keys=_ widget=_ prev= optA=-A mapname=\"${name}\" optR=_\n            local quoted=\"${(q)keys} ${(q)widget} ${(q)prev} ${(q)optA} ${(q)mapname} ${(q)optR}\"\n            quoted=\"${(q)quoted}\"\n\n            # Remember the bindkey, only when load is in progress (it can be dstart that leads execution here).\n            [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[BINDKEYS__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n            [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[BINDKEYS___dtrace/_dtrace]+=\"$quoted \"\n\n            .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Warning: keymap \\`main' copied to \\`${name}' because of \\`${pos[-2]}' substitution\"\n        # bindkey -N newkeymap [other].\n        elif [[ ${#opts} -eq 1 && ${+opts[-N]} = 1 ]]; then\n            local Nopt=-N\n            local Narg=\"${opts[-N]}\"\n\n            local keys=_ widget=_ prev= optN=-N mapname=\"${Narg}\" optR=_\n            local quoted=\"${(q)keys} ${(q)widget} ${(q)prev} ${(q)optN} ${(q)mapname} ${(q)optR}\"\n            quoted=\"${(q)quoted}\"\n\n            # Remember the bindkey, only when load is in progress (it can be dstart that leads execution here).\n            [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[BINDKEYS__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n            [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[BINDKEYS___dtrace/_dtrace]+=\"$quoted \"\n        else\n            .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Warning: last bindkey used non-typical options: ${(kv)opts[*]}\"\n        fi\n    fi\n\n    # Actual bindkey.\n    builtin bindkey \"${pos[@]}\"\n    return $? # testable\n} # ]]]\n# FUNCTION: :zinit-tmp-subst-zstyle [[[\n# Function defined to hijack plugin's calls to the `zstyle' builtin.\n#\n# The hijacking is to gather report data (which is used in unload).\n:zinit-tmp-subst-zstyle() {\n    builtin setopt localoptions noerrreturn noerrexit extendedglob nowarncreateglobal \\\n        typesetsilent noshortloops unset\n    .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Zstyle $*\"\n\n    # Remember in order to perform the actual zstyle call.\n    typeset -a pos\n    pos=( \"$@\" )\n\n    # Check if we have regular zstyle call, i.e.\n    # with no options or with -e.\n    local -a opts\n    zparseopts -a opts -D ${(s::):-eLdgabsTtm}\n\n    if [[ ${#opts} -eq 0 || ( ${#opts} -eq 1 && ${+opts[(r)-e]} = 1 ) ]]; then\n        # Have to quote $1, then $2, then concatenate them, then quote them again.\n        local pattern=\"${(q)1}\" style=\"${(q)2}\"\n        local ps=\"$pattern $style\"\n        ps=\"${(q)ps}\"\n\n        # Remember the zstyle, only when load is in progress (it can be dstart that leads execution here).\n        [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[ZSTYLES__${ZINIT[CUR_USPL2]}]+=\"$ps \"\n        # Remember for dtrace.\n        [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[ZSTYLES___dtrace/_dtrace]+=$ps\n    else\n        if [[ ! ${#opts[@]} = 1 && ( ${+opts[(r)-s]} = 1 || ${+opts[(r)-b]} = 1 || ${+opts[(r)-a]} = 1 ||\n              ${+opts[(r)-t]} = 1 || ${+opts[(r)-T]} = 1 || ${+opts[(r)-m]} = 1 )\n        ]]; then\n            .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Warning: last zstyle used non-typical options: ${opts[*]}\"\n        fi\n    fi\n\n    # Actual zstyle.\n    builtin zstyle \"${pos[@]}\"\n    return $? # testable\n} # ]]]\n# FUNCTION: :zinit-tmp-subst-alias [[[\n# Function defined to hijack plugin's calls to the `alias' builtin.\n#\n# The hijacking is to gather report data (which is used in unload).\n:zinit-tmp-subst-alias() {\n    builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal \\\n        typesetsilent noshortloops unset\n    .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Alias $*\"\n\n    # Remember to perform the actual alias call.\n    typeset -a pos\n    pos=( \"$@\" )\n\n    local -a opts\n    zparseopts -a opts -D ${(s::):-gs}\n\n    local a quoted tmp\n    for a in \"$@\"; do\n        local aname=\"${a%%[=]*}\"\n        local avalue=\"${a#*=}\"\n\n        # Check if alias is to be redefined.\n        (( ${+aliases[$aname]} )) && .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Warning: redefining alias \\`${aname}', previous value: ${aliases[$aname]}\"\n\n        local bname=${(q)aliases[$aname]}\n        aname=\"${(q)aname}\"\n\n        if (( ${+opts[(r)-s]} )); then\n            tmp=-s\n            tmp=\"${(q)tmp}\"\n            quoted=\"$aname $bname $tmp\"\n        elif (( ${+opts[(r)-g]} )); then\n            tmp=-g\n            tmp=\"${(q)tmp}\"\n            quoted=\"$aname $bname $tmp\"\n        else\n            quoted=\"$aname $bname\"\n        fi\n\n        quoted=\"${(q)quoted}\"\n\n        # Remember the alias, only when load is in progress (it can be dstart that leads execution here).\n        [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[ALIASES__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n        # Remember for dtrace.\n        [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[ALIASES___dtrace/_dtrace]+=\"$quoted \"\n    done\n\n    # Actual alias.\n    builtin alias \"${pos[@]}\"\n    return $? # testable\n} # ]]]\n# FUNCTION: :zinit-tmp-subst-zle [[[.\n# Function defined to hijack plugin's calls to the `zle' builtin.\n#\n# The hijacking is to gather report data (which is used in unload).\n:zinit-tmp-subst-zle() {\n    builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal \\\n        typesetsilent noshortloops unset\n    .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Zle $*\"\n\n    # Remember to perform the actual zle call.\n    typeset -a pos\n    pos=( \"$@\" )\n\n    builtin set -- \"${@:#--}\"\n\n    # Try to catch game-changing \"-N\".\n    if [[ ( $1 = -N && ( $# = 2 || $# = 3 ) ) || ( $1 = -C && $# = 4 ) ]]; then\n            # Hooks.\n            if [[ ${ZINIT_ZLE_HOOKS_LIST[$2]} = 1 ]]; then\n                local quoted=\"$2\"\n                quoted=\"${(q)quoted}\"\n                # Remember only when load is in progress (it can be dstart that leads execution here).\n                [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[WIDGETS_DELETE__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n                # Remember for dtrace.\n                [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[WIDGETS_DELETE___dtrace/_dtrace]+=\"$quoted \"\n            # These will be saved and restored.\n            elif (( ${+widgets[$2]} )); then\n                # Have to remember original widget \"$2\" and\n                # the copy that it's going to be done.\n                local widname=\"$2\" targetfun=\"${${${(M)1:#-C}:+$4}:-$3}\"\n                local completion_widget=\"${${(M)1:#-C}:+$3}\"\n                local saved_widcontents=\"${widgets[$widname]}\"\n\n                widname=\"${(q)widname}\"\n                completion_widget=\"${(q)completion_widget}\"\n                targetfun=\"${(q)targetfun}\"\n                saved_widcontents=\"${(q)saved_widcontents}\"\n                local quoted=\"$1 $widname $completion_widget $targetfun $saved_widcontents\"\n                quoted=\"${(q)quoted}\"\n                # Remember only when load is in progress (it can be dstart that leads execution here).\n                [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[WIDGETS_SAVED__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n                # Remember for dtrace.\n                [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[WIDGETS_SAVED___dtrace/_dtrace]+=\"$quoted \"\n             # These will be deleted.\n             else\n                 .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Note: a new widget created via zle -N: \\`$2'\"\n                 local quoted=\"$2\"\n                 quoted=\"${(q)quoted}\"\n                 # Remember only when load is in progress (it can be dstart that leads execution here).\n                 [[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[WIDGETS_DELETE__${ZINIT[CUR_USPL2]}]+=\"$quoted \"\n                 # Remember for dtrace.\n                 [[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[WIDGETS_DELETE___dtrace/_dtrace]+=\"$quoted \"\n             fi\n    fi\n\n    # Actual zle.\n    builtin zle \"${pos[@]}\"\n    return $? # testable\n} # ]]]\n# FUNCTION: :zinit-tmp-subst-compdef [[[\n# Function defined to hijack plugin's calls to the `compdef' function.\n# The hijacking is not only for reporting, but also to save compdef\n# calls so that `compinit' can be called after loading plugins.\n:zinit-tmp-subst-compdef() {\n    builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal \\\n        typesetsilent noshortloops unset\n    .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Saving \\`compdef $*' for replay\"\n    ZINIT_COMPDEF_REPLAY+=( \"${(j: :)${(q)@}}\" )\n\n    return 0 # testable\n} # ]]]\n# FUNCTION: .zinit-tmp-subst-on [[[\n# Turn on temporary substituting of functions of builtins and functions according to passed\n# mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The temporary substituting of functions is\n# to gather report data, and to hijack 'autoload', 'bindkey' and 'compdef' calls.\n.zinit-tmp-subst-on() {\n    local mode=\"$1\"\n\n    # Enable temporary substituting of functions only once.\n    #\n    # One could expect possibility of widening of temporary substituting of functions, however\n    # such sequence doesn't exist, e.g. \"light\" then \"load\"/\"dtrace\", \"compdef\" then \"load\"/\n    # \"dtrace\", \"light\" then \"compdef\", \"compdef\" then \"light\".\n    #\n    # It is always \"dtrace\" then \"load\" (i.e. dtrace then load) \"dtrace\" then \"light\" (i.e.:\n    # dtrace then light load) \"dtrace\" then \"compdef\" (i.e.: dtrace then snippet).\n    [[ ${ZINIT[TMP_SUBST]} != inactive ]] && builtin return 0\n\n    ZINIT[TMP_SUBST]=\"$mode\"\n\n    # The point about backuping is: does the key exist in functions array.\n    # If it does exist, then it will also exist as ZINIT[bkp-*].\n\n    # Defensive code, shouldn't be needed.\n    builtin unset \"ZINIT[bkp-autoload]\" \"ZINIT[bkp-compdef]\"  # 0, E.\n\n    if [[ $mode != compdef ]]; then\n        # 0. Used, but not in temporary restoration, which doesn't happen for autoload.\n        (( ${+functions[autoload]} )) && ZINIT[bkp-autoload]=\"${functions[autoload]}\"\n        functions[autoload]=':zinit-tmp-subst-autoload \"$@\";'\n    fi\n\n    # E. Always shade compdef.\n    (( ${+functions[compdef]} )) && ZINIT[bkp-compdef]=\"${functions[compdef]}\"\n    functions[compdef]=':zinit-tmp-subst-compdef \"$@\";'\n\n    # Temporarily replace `source' if subst'' given.\n    if [[ -n ${ICE[subst]} ]] {\n        (( ${+functions[source]} )) && ZINIT[bkp-source]=\"${functions[source]}\"\n        (( ${+functions[.]} )) && ZINIT[bkp-.]=\"${functions[.]}\"\n        (( ${+functions[.zinit-service]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n        functions[source]=':zinit-tmp-subst-source \"$@\";'\n        functions[.]=':zinit-tmp-subst-source \"$@\";'\n    }\n\n    # Light and compdef temporary substituting of functions stops here. Dtrace and load go on.\n    [[ ( $mode = light && ${+ICE[trackbinds]} -eq 0 ) || $mode = compdef ]] && return 0\n\n    # Defensive code, shouldn't be needed. A, B, C, D.\n    builtin unset \"ZINIT[bkp-bindkey]\" \"ZINIT[bkp-zstyle]\" \"ZINIT[bkp-alias]\" \"ZINIT[bkp-zle]\"\n\n    # A.\n    (( ${+functions[bindkey]} )) && ZINIT[bkp-bindkey]=\"${functions[bindkey]}\"\n    functions[bindkey]=':zinit-tmp-subst-bindkey \"$@\";'\n\n    # B, when `zinit light -b ...' or when `zinit ice trackbinds ...; zinit light ...'.\n    [[ $mode = light-b || ( $mode = light && ${+ICE[trackbinds]} -eq 1 ) ]] && return 0\n\n    # B.\n    (( ${+functions[zstyle]} )) && ZINIT[bkp-zstyle]=\"${functions[zstyle]}\"\n    functions[zstyle]=':zinit-tmp-subst-zstyle \"$@\";'\n\n    # C.\n    (( ${+functions[alias]} )) && ZINIT[bkp-alias]=\"${functions[alias]}\"\n    functions[alias]=':zinit-tmp-subst-alias \"$@\";'\n\n    # D.\n    (( ${+functions[zle]} )) && ZINIT[bkp-zle]=\"${functions[zle]}\"\n    functions[zle]=':zinit-tmp-subst-zle \"$@\";'\n\n    builtin return 0\n} # ]]]\n# FUNCTION: .zinit-tmp-subst-off [[[\n# Turn off temporary substituting of functions completely for a given mode (\"load\", \"light\",\n# \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\").\n.zinit-tmp-subst-off() {\n    builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal \\\n        typesetsilent noshortloops unset noaliases\n    local mode=\"$1\"\n\n    # Disable temporary substituting of functions only once.\n    # Disable temporary substituting of functions only the way it was enabled first.\n    [[ ${ZINIT[TMP_SUBST]} = inactive || ${ZINIT[TMP_SUBST]} != $mode ]] && return 0\n\n    ZINIT[TMP_SUBST]=inactive\n\n    if [[ $mode != compdef ]]; then\n        # 0. Unfunction autoload.\n        (( ${+ZINIT[bkp-autoload]} )) && functions[autoload]=\"${ZINIT[bkp-autoload]}\" || unfunction autoload\n    fi\n\n    # E. Restore original compdef if it existed.\n    (( ${+ZINIT[bkp-compdef]} )) && functions[compdef]=\"${ZINIT[bkp-compdef]}\" || unfunction compdef\n\n    # Restore the possible source function.\n    (( ${+ZINIT[bkp-source]} )) && functions[source]=\"${ZINIT[bkp-source]}\" || unfunction source 2>/dev/null\n    (( ${+ZINIT[bkp-.]} )) && functions[.]=\"${ZINIT[bkp-.]}\" || unfunction . 2> /dev/null\n\n    # Light and compdef temporary substituting of functions stops here.\n    [[ ( $mode = light && ${+ICE[trackbinds]} -eq 0 ) || $mode = compdef ]] && return 0\n\n    # Unfunction temporary substituting of functions functions.\n\n    # A.\n    (( ${+ZINIT[bkp-bindkey]} )) && functions[bindkey]=\"${ZINIT[bkp-bindkey]}\" || unfunction bindkey\n\n    # When `zinit light -b ...' or when `zinit ice trackbinds ...; zinit light ...'.\n    [[ $mode = light-b || ( $mode = light && ${+ICE[trackbinds]} -eq 1 ) ]] && return 0\n\n    # B.\n    (( ${+ZINIT[bkp-zstyle]} )) && functions[zstyle]=\"${ZINIT[bkp-zstyle]}\" || unfunction zstyle\n    # C.\n    (( ${+ZINIT[bkp-alias]} )) && functions[alias]=\"${ZINIT[bkp-alias]}\" || unfunction alias\n    # D.\n    (( ${+ZINIT[bkp-zle]} )) && functions[zle]=\"${ZINIT[bkp-zle]}\" || unfunction zle\n\n    return 0\n} # ]]]\n# FUNCTION: pmodload [[[\n# Compatibility with Prezto. Calls can be recursive\n(( ${+functions[pmodload]} )) || pmodload() {\n    local -A ices\n    (( ${+ICE} )) && ices=( \"${(kv)ICE[@]}\" teleid '' )\n    local -A ICE ZINIT_ICE\n    ICE=( \"${(kv)ices[@]}\" ) ZINIT_ICE=( \"${(kv)ices[@]}\" )\n    while (( $# )); do\n        ICE[teleid]=\"PZT::modules/$1${ICE[svn]-/init.zsh}\"\n        ZINIT_ICE[teleid]=\"PZT::modules/$1${ICE[svn]-/init.zsh}\"\n        if zstyle -t \":prezto:module:$1\" loaded 'yes' 'no'; then\n            shift\n            continue\n        else\n            [[ -z ${ZINIT_SNIPPETS[PZT::modules/$1${ICE[svn]-/init.zsh}]} && -z ${ZINIT_SNIPPETS[https://github.com/sorin-ionescu/prezto/trunk/modules/$1${ICE[svn]-/init.zsh}]} ]] && .zinit-load-snippet PZT::modules/\"$1${ICE[svn]-/init.zsh}\"\n            shift\n        fi\n    done\n} # ]]]\n\n#\n# Diff functions.\n#\n\n# FUNCTION: .zinit-diff-functions [[[\n# Implements detection of newly created functions. Performs\n# data gathering, computation is done in *-compute().\n#\n# $1 - user/plugin (i.e. uspl2 format)\n# $2 - command, can be \"begin\" or \"end\"\n.zinit-diff-functions() {\n    local uspl2=\"$1\"\n    local cmd=\"$2\"\n\n    [[ $cmd = begin ]] && \\\n        { [[ -z ${ZINIT[FUNCTIONS_BEFORE__$uspl2]} ]] && \\\n                ZINIT[FUNCTIONS_BEFORE__$uspl2]=\"${(j: :)${(qk)functions[@]}}\"\n        } || \\\n            ZINIT[FUNCTIONS_AFTER__$uspl2]+=\" ${(j: :)${(qk)functions[@]}}\"\n} # ]]]\n# FUNCTION: .zinit-diff-options [[[\n# Implements detection of change in option state. Performs\n# data gathering, computation is done in *-compute().\n#\n# $1 - user/plugin (i.e. uspl2 format)\n# $2 - command, can be \"begin\" or \"end\"\n.zinit-diff-options() {\n    local IFS=\" \"\n\n    [[ $2 = begin ]] && \\\n        { [[ -z ${ZINIT[OPTIONS_BEFORE__$uspl2]} ]] && \\\n            ZINIT[OPTIONS_BEFORE__$1]=\"${(kv)options[@]}\"\n        } || \\\n        ZINIT[OPTIONS_AFTER__$1]+=\" ${(kv)options[@]}\"\n} # ]]]\n# FUNCTION: .zinit-diff-env [[[\n# Implements detection of change in PATH and FPATH.\n#\n# $1 - user/plugin (i.e. uspl2 format)\n# $2 - command, can be \"begin\" or \"end\"\n.zinit-diff-env() {\n    typeset -a tmp\n    local IFS=\" \"\n\n    [[ $2 = begin ]] && {\n            { [[ -z ${ZINIT[PATH_BEFORE__$uspl2]} ]] && \\\n                tmp=( \"${(q)path[@]}\" )\n                ZINIT[PATH_BEFORE__$1]=\"${tmp[*]}\"\n            }\n            { [[ -z ${ZINIT[FPATH_BEFORE__$uspl2]} ]] && \\\n                tmp=( \"${(q)fpath[@]}\" )\n                ZINIT[FPATH_BEFORE__$1]=\"${tmp[*]}\"\n            }\n    } || {\n            tmp=( \"${(q)path[@]}\" )\n            ZINIT[PATH_AFTER__$1]+=\" ${tmp[*]}\"\n            tmp=( \"${(q)fpath[@]}\" )\n            ZINIT[FPATH_AFTER__$1]+=\" ${tmp[*]}\"\n    }\n} # ]]]\n# FUNCTION: .zinit-diff-parameter [[[\n# Implements detection of change in any parameter's existence and type.\n# Performs data gathering, computation is done in *-compute().\n#\n# $1 - user/plugin (i.e. uspl2 format)\n# $2 - command, can be \"begin\" or \"end\"\n.zinit-diff-parameter() {\n    typeset -a tmp\n\n    [[ $2 = begin ]] && {\n        { [[ -z ${ZINIT[PARAMETERS_BEFORE__$uspl2]} ]] && \\\n            ZINIT[PARAMETERS_BEFORE__$1]=\"${(j: :)${(qkv)parameters[@]}}\"\n        }\n    } || {\n        ZINIT[PARAMETERS_AFTER__$1]+=\" ${(j: :)${(qkv)parameters[@]}}\"\n    }\n} # ]]]\n# FUNCTION: .zinit-diff [[[\n# Performs diff actions of all types\n.zinit-diff() {\n    .zinit-diff-functions \"$1\" \"$2\"\n    .zinit-diff-options \"$1\" \"$2\"\n    .zinit-diff-env \"$1\" \"$2\"\n    .zinit-diff-parameter \"$1\" \"$2\"\n} # ]]]\n\n#\n# Utility functions.\n#\n\n# FUNCTION: .zinit-get-mtime-into [[[\n.zinit-get-mtime-into() {\n    if (( ZINIT[HAVE_ZSTAT] )) {\n        local -a arr\n        { zstat +mtime -A arr \"$1\"; } 2>/dev/null\n        : ${(P)2::=\"${arr[1]}\"}\n    } else {\n        { : ${(P)2::=\"$(stat -c %Y \"$1\")\"}; } 2>/dev/null\n    }\n} # ]]]\n# FUNCTION: .zinit-any-to-user-plugin [[[\n# Allows elastic plugin-spec across the code.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin (only when $1 - i.e. user - given)\n#\n# $REPLY - user and plugin\n.zinit-any-to-user-plugin() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob typesetsilent noshortloops rcquotes \\\n         ${${${+reply}:#0}:+warncreateglobal}\n\n    # Two components given?\n    # That's a pretty fast track to call this function this way.\n    if [[ -n $2 ]]; then\n        2=${~2}\n        reply=( ${1:-${${(M)2#/}:+%}} ${${${(M)1#%}:+$2}:-${2//---//}} )\n        return 0\n    fi\n\n    # Is it absolute path?\n    if [[ $1 = /* ]]; then\n        reply=( % $1 )\n        return 0\n    fi\n\n    # Is it absolute path in zinit format?\n    if [[ $1 = %* ]]; then\n        local -A map\n        map=( ZPFX \"$ZPFX\" HOME $HOME SNIPPETS $ZINIT[SNIPPETS_DIR] PLUGINS $ZINIT[PLUGINS_DIR] )\n        reply=( % ${${1/(#b)(#s)%(${(~j:|:)${(@k)map}}|)/$map[$match[1]]}} )\n        reply[2]=${~reply[2]}\n        return 0\n    fi\n\n    # Rest is for single component given.\n    # It doesn't touch $2\n\n    1=${1//---//}\n    if [[ $1 = */* ]]; then\n        reply=( ${1%%/*} ${1#*/} )\n        return 0\n    fi\n\n    reply=( \"\" \"${1:-_unknown}\" )\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-any-to-pid [[[\n.zinit-any-to-pid() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob typesetsilent noshortloops rcquotes \\\n         ${${${+REPLY}:#0}:+warncreateglobal}\n\n    1=${~1} 2=${~2}\n\n    # Two components given?\n    if [[ -n $2 ]] {\n        if [[ $1 == (%|/)* || ( -z $1 && $2 == /* ) ]] {\n            .zinit-util-shands-path $1${${(M)1#(%/?|%[^/]|/?)}:+/}$2\n            REPLY=${${REPLY:#%*}:+%}$REPLY\n        } else {\n            REPLY=$1${1:+/}$2\n        }\n        return 0\n    }\n\n    # Is it absolute path?\n    if [[ $1 = (%|/|\\~)* ]] {\n        .zinit-util-shands-path $1\n        REPLY=${${REPLY:#%*}:+%}$REPLY\n        return 0\n    }\n\n    # Single component given.\n    REPLY=${1//---//}\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-util-shands-path [[[\n# Replaces parts of path with %HOME, etc.\n.zinit-util-shands-path() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob typesetsilent noshortloops rcquotes \\\n         ${${${+REPLY}:#0}:+warncreateglobal}\n\n    local -A map\n    map=( \\~ %HOME $HOME %HOME $ZINIT[SNIPPETS_DIR] %SNIPPETS $ZINIT[PLUGINS_DIR] %PLUGINS\n        \"$ZPFX\" %ZPFX HOME %HOME SNIPPETS %SNIPPETS PLUGINS %PLUGINS \"\" \"\" )\n    REPLY=${${1/(#b)(#s)(%|)(${(~j:|:)${(@k)map:#$HOME}}|$HOME|)/$map[$match[2]]}}\n    return 0\n} # ]]]\n# FUNCTION: .zinit-find-other-matches [[[\n# Plugin's main source file is in general `name.plugin.zsh'. However,\n# there can be different conventions, if that file is not found, then\n# this functions examines other conventions in the most sane order.\n.zinit-find-other-matches() {\n    local pdir_path=\"$1\" pbase=\"$2\" limit=\"$3\"\n\n    # Only *.plugin.zsh load? When loading service.\n    if [[ $limit == 1 ]]; then\n        reply=( \"$pdir_path\"/*.plugin.zsh(DN) )\n    elif [[ $limit == 0 ]]; then\n        reply=( \"$pdir_path\"/*.service.zsh(DN) )\n    else\n        if [[ -e $pdir_path/init.zsh ]] {\n            reply=( \"$pdir_path\"/init.zsh )\n        } elif [[ -e $pdir_path/$pbase.zsh-theme ]] {\n            reply=( \"$pdir_path/$pbase\".zsh-theme )\n        } elif [[ -e $pdir_path/$pbase.theme.zsh ]] {\n            reply=( \"$pdir_path/$pbase\".theme.zsh )\n        } else {\n            reply=(\n                \"$pdir_path\"/*.plugin.zsh(DN) \"$pdir_path\"/*.zsh-theme(DN) \"$pdir_path\"/*.lib.zsh(DN)\n                \"$pdir_path\"/*.zsh(DN) \"$pdir_path\"/*.sh(DN) \"$pdir_path\"/.zshrc(DN)\n            )\n        }\n    fi\n    reply=( \"${(u)reply[@]}\" )\n\n    return $(( ${#reply} > 0 ? 0 : 1 ))\n} # ]]]\n# FUNCTION: .zinit-register-plugin [[[\n# Adds the plugin to ZINIT_REGISTERED_PLUGINS array and to the\n# zsh_loaded_plugins array (managed according to the plugin standard:\n# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html).\n.zinit-register-plugin() {\n    local uspl2=\"$1\" mode=\"$2\" teleid=\"$3\"\n    integer ret=0\n\n    if [[ -z ${ZINIT_REGISTERED_PLUGINS[(r)$uspl2]} ]]; then\n        ZINIT_REGISTERED_PLUGINS+=( \"$uspl2\" )\n    else\n        # Allow overwrite-load, however warn about it.\n        [[ -z ${ZINIT[TEST]}${${+ICE[wait]}:#0}${ICE[load]}${ICE[subscribe]} && ${ZINIT[MUTE_WARNINGS]} != (1|true|on|yes) ]] && +zi-log \"{u-warn}Warning{b-warn}:{rst} plugin {apo}\\`{pid}${uspl2}{apo}\\`{rst} already registered, will overwrite-load.\"\n        ret=1\n    fi\n\n    # Support Zsh plugin standard.\n    zsh_loaded_plugins+=( \"$teleid\" )\n\n    # Full or light load?\n    [[ $mode == light ]] && ZINIT[STATES__$uspl2]=1 || ZINIT[STATES__$uspl2]=2\n\n    ZINIT_REPORTS[$uspl2]=             ZINIT_CUR_BIND_MAP=( empty 1 )\n    # Functions.\n    ZINIT[FUNCTIONS_BEFORE__$uspl2]=  ZINIT[FUNCTIONS_AFTER__$uspl2]=\n    ZINIT[FUNCTIONS__$uspl2]=\n    # Objects.\n    ZINIT[ZSTYLES__$uspl2]=           ZINIT[BINDKEYS__$uspl2]=\n    ZINIT[ALIASES__$uspl2]=\n    # Widgets.\n    ZINIT[WIDGETS_SAVED__$uspl2]=     ZINIT[WIDGETS_DELETE__$uspl2]=\n    # Rest (options and (f)path).\n    ZINIT[OPTIONS__$uspl2]=           ZINIT[PATH__$uspl2]=\n    ZINIT[OPTIONS_BEFORE__$uspl2]=    ZINIT[OPTIONS_AFTER__$uspl2]=\n    ZINIT[FPATH__$uspl2]=\n\n    return ret\n} # ]]]\n# FUNCTION: .zinit-get-object-path [[[\n.zinit-get-object-path() {\n    local type=\"$1\" id_as=\"$2\" local_dir dirname\n    integer exists\n\n    id_as=\"${ICE[id-as]:-$id_as}\"\n\n    # Remove leading whitespace and trailing /.\n    id_as=\"${${id_as#\"${id_as%%[! $'\\t']*}\"}%/}\"\n\n    for type ( ${=${${(M)type:#AUTO}:+snippet plugin}:-$type} ) {\n        if [[ $type == snippet ]] {\n            dirname=\"${${id_as%%\\?*}:t}\"\n            local_dir=\"${${${id_as%%\\?*}/:\\/\\//--}:h}\"\n            [[ $local_dir = . ]] && local_dir= || local_dir=\"${${${${${local_dir#/}//\\//--}//=/-EQ-}//\\?/-QM-}//\\&/-AMP-}\"\n            local_dir=\"${ZINIT[SNIPPETS_DIR]}${local_dir:+/$local_dir}\"\n        } else {\n            .zinit-any-to-user-plugin \"$id_as\"\n            local_dir=${${${(M)reply[-2]:#%}:+${reply[2]}}:-${ZINIT[PLUGINS_DIR]}/${id_as//\\//---}}\n            [[ $id_as == _local/* && -d $local_dir && ! -d $local_dir/._zinit ]] && command mkdir -p \"$local_dir\"/._zinit\n            dirname=\"\"\n        }\n        [[ -e $local_dir/${dirname:+$dirname/}._zinit || \\\n            -e $local_dir/${dirname:+$dirname/}._zplugin ]] && exists=1\n\n        (( exists )) && break\n    }\n\n    reply=( \"$local_dir\" \"$dirname\" \"$exists\" )\n    REPLY=\"$local_dir${dirname:+/$dirname}\"\n\n    return $(( 1 - exists ))\n} # ]]]\n# FUNCTION: @zinit-substitute [[[\n@zinit-substitute() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    builtin setopt extendedglob warncreateglobal typesetsilent noshortloops\n\n    local -A ___subst_map\n    ___subst_map=(\n        \"%ID%\"   \"${id_as_clean:-$id_as}\"\n        \"%USER%\" \"$user\"\n        \"%PLUGIN%\" \"${plugin:-$save_url}\"\n        \"%URL%\" \"${save_url:-${user:+$user/}$plugin}\"\n        \"%DIR%\" \"${local_path:-$local_dir${dirname:+/$dirname}}\"\n        '$ZPFX' \"$ZPFX\"\n        '${ZPFX}' \"$ZPFX\"\n        '%OS%' \"${OSTYPE%(-gnu|[0-9]##)}\" '%MACH%' \"$MACHTYPE\" '%CPU%' \"$CPUTYPE\"\n        '%VENDOR%' \"$VENDOR\" '%HOST%' \"$HOST\" '%UID%' \"$UID\" '%GID%' \"$GID\"\n    )\n    if [[ -n ${ICE[param]} && ${ZINIT[SUBST_DONE_FOR]} != ${ICE[param]} ]] {\n        ZINIT[SUBST_DONE_FOR]=${ICE[param]}\n        ZINIT[PARAM_SUBST]=\n        local -a ___params\n        ___params=( ${(s.;.)ICE[param]} )\n        local ___param ___from ___to\n        for ___param ( ${___params[@]} ) {\n            local ___from=${${___param%%([[:space:]]|)(->|→)*}##[[:space:]]##} \\\n                ___to=${${___param#*(->|→)([[:space:]]|)}%[[:space:]]}\n            ___from=${___from//((#s)[[:space:]]##|[[:space:]]##(#e))/}\n            ___to=${___to//((#s)[[:space:]]##|[[:space:]]##(#e))/}\n            ZINIT[PARAM_SUBST]+=\"%${(q)___from}% ${(q)___to} \"\n        }\n    }\n\n    local -a ___add\n    ___add=( \"${ICE[param]:+${(@Q)${(@z)ZINIT[PARAM_SUBST]}}}\" )\n    (( ${#___add} % 2 == 0 )) && ___subst_map+=( \"${___add[@]}\" )\n\n    local ___var_name\n    for ___var_name; do\n        local ___value=${(P)___var_name}\n        ___value=${___value//(#m)(%[a-zA-Z0-9]##%|\\$ZPFX|\\$\\{ZPFX\\})/${___subst_map[$MATCH]}}\n        : ${(P)___var_name::=$___value}\n    done\n} # ]]]\n# FUNCTION: @zinit-register-annex [[[\n# Registers the z-annex inside Zinit – i.e. an Zinit extension\n@zinit-register-annex() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    # See comment in zinit-register-hook() why nobanghist is needed\n    builtin setopt nobanghist\n    local name=\"$1\" type=\"$2\" handler=\"$3\" helphandler=\"$4\" icemods=\"$5\" key=\"z-annex ${(q)2}\"\n    ZINIT_EXTS[seqno]=$(( ${ZINIT_EXTS[seqno]:-0} + 1 ))\n    ZINIT_EXTS[$key${${(M)type#hook:}:+ ${ZINIT_EXTS[seqno]}}]=\"${ZINIT_EXTS[seqno]} z-annex-data: ${(q)name} ${(q)type} ${(q)handler} ${(q)helphandler} ${(q)icemods}\"\n    () {\n        builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n        # See comment in zinit-register-hook() why nobanghist is needed\n        builtin setopt nobanghist\n        integer index=\"${type##[%a-zA-Z:_!-]##}\"\n        ZINIT_EXTS[ice-mods]=\"${ZINIT_EXTS[ice-mods]}${icemods:+|}${(j:|:)${(@)${(@s:|:)icemods}/(#b)(#s)(?)/$index-$match[1]}}\"\n    }\n} # ]]]\n# FUNCTION: @zinit-register-hook [[[\n# Registers the z-annex inside Zinit (i.e., an Zinit extension)\n@zinit-register-hook() {\n    builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n    # zsh per default behaves differently in interactive sessions (escapes !) and\n    # non-interactive ones (does not). Setting 'nobanghist' option disables backslash\n    # escaping for \"!\" even in interactive sessions.\n    # Exclamation marks are used in a lot of hock names.\n    builtin setopt extendedglob nobanghist noshortloops typesetsilent warncreateglobal\n    local name=\"$1\" type=\"$2\" handler=\"$3\" icemods=\"$4\" key=\"zinit ${(q)2}\"\n    ZINIT_EXTS2[seqno]=$(( ${ZINIT_EXTS2[seqno]:-0} + 1 ))\n    ZINIT_EXTS2[$key${${(M)type#hook:}:+ ${ZINIT_EXTS2[seqno]}}]=\"${ZINIT_EXTS2[seqno]} z-annex-data: ${(q)name} ${(q)type} ${(q)handler} '' ${(q)icemods}\"\n    ZINIT_EXTS2[ice-mods]=\"${ZINIT_EXTS2[ice-mods]}${icemods:+|}$icemods\"\n} # ]]]\n# FUNCTION: @zsh-plugin-run-on-unload [[[\n# The Plugin Standard required mechanism, see:\n# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html\n@zsh-plugin-run-on-unload() {\n    ICE[ps-on-unload]=\"${(j.; .)@}\"\n    .zinit-pack-ice \"$id_as\" \"\"\n} # ]]]\n# FUNCTION: @zsh-plugin-run-on-update [[[\n# The Plugin Standard required mechanism\n@zsh-plugin-run-on-update() {\n    ICE[ps-on-update]=\"${(j.; .)@}\"\n    .zinit-pack-ice \"$id_as\" \"\"\n} # ]]]\n\n#\n# Remaining functions.\n#\n\n# FUNCTION: .zinit-prepare-home [[[\n# Creates all directories needed by Zinit, first checks if they\n# already exist.\n.zinit-prepare-home() {\n    [[ -n ${ZINIT[HOME_READY]} ]] && return\n    ZINIT[HOME_READY]=1\n\n    [[ ! -d ${ZINIT[HOME_DIR]} ]] && {\n        command mkdir  -p \"${ZINIT[HOME_DIR]}\"\n        # For compaudit.\n        command chmod go-w \"${ZINIT[HOME_DIR]}\"\n        # Also set up */bin and ZPFX in general.\n        command mkdir -p \"${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin\"\n    }\n    [[ ! -d ${ZINIT[PLUGINS_DIR]}/_local---zinit ]] && {\n        command rm -rf \"${ZINIT[PLUGINS_DIR]:-${TMPDIR:-/tmp}/132bcaCAB}/_local---zplugin\"\n        command mkdir -p \"${ZINIT[PLUGINS_DIR]}/_local---zinit\"\n        command chmod go-w \"${ZINIT[PLUGINS_DIR]}\"\n        command ln -s \"${ZINIT[BIN_DIR]}/_zinit\" \"${ZINIT[PLUGINS_DIR]}/_local---zinit\"\n\n        # Also set up */bin and ZPFX in general.\n        command mkdir -p \"${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin\"\n\n        (( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n        (( ${+functions[.zinit-confirm]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n        .zinit-clear-completions &>/dev/null\n        .zinit-compinit &>/dev/null\n    }\n    [[ ! -d ${ZINIT[COMPLETIONS_DIR]} ]] && {\n        command mkdir \"${ZINIT[COMPLETIONS_DIR]}\"\n        # For compaudit.\n        command chmod go-w \"${ZINIT[COMPLETIONS_DIR]}\"\n\n        # Symlink _zinit completion into _local---zinit directory.\n        command ln -s \"${ZINIT[PLUGINS_DIR]}/_local---zinit/_zinit\" \"${ZINIT[COMPLETIONS_DIR]}\"\n\n        # Also set up */bin and ZPFX in general.\n        command mkdir -p \"${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin\"\n\n        (( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n        .zinit-compinit &>/dev/null\n    }\n    [[ ! -d ${ZINIT[SNIPPETS_DIR]} ]] && {\n        command mkdir -p \"${ZINIT[SNIPPETS_DIR]}/OMZ::plugins\"\n        command chmod go-w \"${ZINIT[SNIPPETS_DIR]}\"\n        ( builtin cd ${ZINIT[SNIPPETS_DIR]}; command ln -s OMZ::plugins plugins; )\n\n        # Also create the SERVICES_DIR.\n        command mkdir -p \"${ZINIT[SERVICES_DIR]}\"\n        command chmod go-w \"${ZINIT[SERVICES_DIR]}\"\n\n        # Also set up */bin and ZPFX in general.\n        command mkdir -p \"${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin\"\n    }\n    [[ ! -d ${~ZINIT[MAN_DIR]}/man9 ]] && {\n        # Create ZINIT[MAN_DIR]/man{1..9}\n        command mkdir 2>/dev/null -p ${~ZINIT[MAN_DIR]}/man{1..9}\n    }\n    # Copy Zinit manpage so that man is able to find it\n    [[ ! -f $ZINIT[MAN_DIR]/man1/zinit.1 || \\\n        $ZINIT[MAN_DIR]/man1/zinit.1 -ot $ZINIT[BIN_DIR]/doc/zinit.1 ]] && {\n        command mkdir -p $ZINIT[MAN_DIR]/man1\n        command cp -f $ZINIT[BIN_DIR]/doc/zinit.1 $ZINIT[MAN_DIR]/man1\n    }\n} # ]]]\n# FUNCTION: .zinit-load-object [[[\n.zinit-load-object() {\n    local ___type=\"$1\" ___id=$2\n    local -a ___opt\n    ___opt=( ${@[3,-1]} )\n\n    if [[ $___type == snippet ]] {\n        .zinit-load-snippet $___opt \"$___id\"\n    } elif [[ $___type == plugin ]] {\n        .zinit-load \"$___id\" \"\" $___opt\n    }\n    ___retval+=$?\n\n    return __retval\n} # ]]]\n# FUNCTION: .zinit-set-m-func [[[\n# Sets and withdraws the temporary, atclone/atpull time function `m`.\n.zinit-set-m-func() {\n    if [[ $1 == set ]]; then\n        ZINIT[___m_bkp]=\"${functions[m]}\"\n        setopt noaliases\n        functions[m]=\"${functions[+zi-log]}\"\n        setopt aliases\n    elif [[ $1 == unset ]]; then\n        if [[ -n ${ZINIT[___m_bkp]} ]]; then\n            setopt noaliases\n            functions[m]=\"${ZINIT[___m_bkp]}\"\n            setopt aliases\n        else\n            noglob unset functions[m]\n        fi\n    else\n        +zi-log \"{error}ERROR #1\"\n        return 1\n    fi\n} # ]]]\n\n# FUNCTION: .zinit-load-snippet [[[\n# Implements the exposed-to-user action of loading a snippet.\n#\n# $1 - url (can be local, absolute path).\n.zinit-load-snippet() {\n    typeset -F 3 SECONDS=0\n    local -a opts\n    zparseopts -E -D -a opts f -command || { +zi-log \"{u-warn}Error{b-warn}:{rst} Incorrect options (accepted ones: {opt}-f{rst}, {opt}--command{rst}).\"; return 1; }\n    local url=\"$1\" limit=\"$3\"\n    [[ -n ${ICE[teleid]} ]] && url=\"${ICE[teleid]}\"\n    # Hide arguments from sourced scripts. Without this calls our \"$@\" are visible as \"$@\"\n    # within scripts that we `source`.\n    builtin set --\n    integer correct retval exists\n    [[ -o ksharrays ]] && correct=1\n\n    [[ -n ${ICE[(i)(\\!|)(sh|bash|ksh|csh)]}${ICE[opts]} ]] && {\n        local -a precm\n        precm=(\n            builtin emulate\n            ${${(M)${ICE[(i)(\\!|)(sh|bash|ksh|csh)]}#\\!}:+-R}\n            ${${${ICE[(i)(\\!|)(sh|bash|ksh|csh)]}#\\!}:-zsh}\n            ${${ICE[(i)(\\!|)bash]}:+-${(s: :):-o noshglob -o braceexpand -o kshglob}}\n            ${(s: :):-${${:-${(@s: :):--o}\" \"${(s: :)^ICE[opts]}}:#-o }}\n            -c\n        )\n    }\n    # Remove leading whitespace and trailing /.\n    url=\"${${url#\"${url%%[! $'\\t']*}\"}%/}\"\n    ICE[teleid]=\"${ICE[teleid]:-$url}\"\n    [[ ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ]] && \\\n        ICE[pick]=\"${ICE[pick]:-/dev/null}\"\n\n    local local_dir dirname filename save_url=\"$url\"\n\n    # Allow things like $OSTYPE in the URL.\n    eval \"url=\\\"$url\\\"\"\n\n    local id_as=\"${ICE[id-as]:-$url}\"\n\n    .zinit-set-m-func set\n\n    # Set up param'' objects (parameters).\n    if [[ -n ${ICE[param]} ]] {\n        .zinit-setup-params && local -x ${(Q)reply[@]}\n    }\n\n    .zinit-pack-ice \"$id_as\" \"\"\n\n    # Oh-My-Zsh, Prezto and manual shorthands.\n    [[ $url = *(${(~kj.|.)${(Mk)ZINIT_1MAP:#OMZ*}}|robbyrussell*oh-my-zsh|ohmyzsh/ohmyzsh)* ]] && local ZSH=\"${ZINIT[SNIPPETS_DIR]}\"\n\n    # Construct containing directory, extract final directory\n    # into handy-variable $dirname.\n    .zinit-get-object-path snippet \"$id_as\"\n    filename=\"${reply[-2]}\" dirname=\"${reply[-2]}\"\n    local_dir=\"${reply[-3]}\" exists=${reply[-1]}\n\n    local -a arr\n    local key\n    reply=(\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-pre <->]}\n        ${(on)ZINIT_EXTS[(I)z-annex hook:preinit-<-> <->]}\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-post <->]}\n    )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}\" )\n        \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \"${${key##(zinit|z-annex) hook:}%% <->}\" load || \\\n            return $(( 10 - $? ))\n    done\n\n    # Download or copy the file.\n    if [[ -n ${opts[(r)-f]} || $exists -eq 0 ]] {\n        (( ${+functions[.zinit-download-snippet]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n        .zinit-download-snippet \"$save_url\" \"$url\" \"$id_as\" \"$local_dir\" \"$dirname\" \"$filename\"\n        retval=$?\n    }\n\n    (( ${+ICE[cloneonly]} || retval )) && return 0\n\n    ZINIT_SNIPPETS[$id_as]=\"$id_as <${${ICE[svn]+svn}:-single file}>\"\n\n    ZINIT[CUR_USPL2]=\"$id_as\" ZINIT_REPORTS[$id_as]=\n\n    reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atinit-<-> <->]} )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]}[@]}\" )\n        \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \\!atinit || \\\n            return $(( 10 - $? ))\n    done\n\n    (( ${+ICE[atinit]} )) && { local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$local_dir/$dirname\"; } && eval \"${ICE[atinit]}\"; ((1)); } || eval \"${ICE[atinit]}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n    reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:atinit-<-> <->]} )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]}[@]}\" )\n        \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" atinit || \\\n            return $(( 10 - $? ))\n    done\n\n    local -a list\n    local ZERO\n\n    if [[ -z ${opts[(r)--command]} && ( -z ${ICE[as]} || ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ) ]]; then\n        # Source the file with compdef temporary substituting of functions.\n        if [[ ${ZINIT[TMP_SUBST]} = inactive ]]; then\n            # Temporary substituting of functions code is inlined from .zinit-tmp-subst-on.\n            (( ${+functions[compdef]} )) && ZINIT[bkp-compdef]=\"${functions[compdef]}\" || builtin unset \"ZINIT[bkp-compdef]\"\n            functions[compdef]=':zinit-tmp-subst-compdef \"$@\";'\n            ZINIT[TMP_SUBST]=1\n        else\n            (( ++ ZINIT[TMP_SUBST] ))\n        fi\n\n        # Add to fpath.\n        if [[ -d $local_dir/$dirname/functions ]] {\n            [[ -z ${fpath[(r)$local_dir/$dirname/functions]} ]] && fpath+=( \"$local_dir/$dirname/functions\" )\n            () {\n                builtin setopt localoptions extendedglob\n                autoload $local_dir/$dirname/functions/^([_.]*|prompt_*_setup|README*)(D-.N:t)\n            }\n        }\n\n        # Source.\n        if (( ${+ICE[svn]} == 0 )) {\n            [[ ${+ICE[pick]} = 0 ]] && list=( \"$local_dir/$dirname/$filename\" )\n            [[ -n ${ICE[pick]} ]] && list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )\n        } else {\n            if [[ -n ${ICE[pick]} ]]; then\n                list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )\n            elif (( ${+ICE[pick]} == 0 )); then\n                .zinit-find-other-matches \"$local_dir/$dirname\" \"$filename\" \"$limit\"\n                list=( ${reply[@]} )\n            fi\n        }\n\n        if [[ -f ${list[1-correct]} ]] {\n            ZERO=\"${list[1-correct]}\"\n            (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; }; (( retval += $? )); }\n            (( 0 == retval )) && [[ $url = PZT::* || $url = https://github.com/sorin-ionescu/prezto/* ]] && zstyle \":prezto:module:${${id_as%/init.zsh}:t}\" loaded 'yes'\n        } else { [[ ${+ICE[silent]} -eq 1 || ${+ICE[pick]} -eq 1 && -z ${ICE[pick]} || ${ICE[pick]} = /dev/null ]] || { +zi-log \"Snippet not loaded ({url}${id_as}{rst})\"; retval=1; } }\n\n        [[ -n ${ICE[src]} ]] && { ZERO=\"${${(M)ICE[src]##/*}:-$local_dir/$dirname/${ICE[src]}}\"; (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; }; (( retval += $? )); }; }\n        [[ -n ${ICE[multisrc]} ]] && { local ___oldcd=\"$PWD\"; () { setopt localoptions noautopushd; builtin cd -q \"$local_dir/$dirname\"; }; eval \"reply=(${ICE[multisrc]})\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; local fname; for fname in \"${reply[@]}\"; do ZERO=\"${${(M)fname:#/*}:-$local_dir/$dirname/$fname}\"; (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; }; (( retval += $? )); }; done; }\n\n        # Run the atload hooks right before atload ice.\n        reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atload-<-> <->]} )\n        for key in \"${reply[@]}\"; do\n            arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]}[@]}\" )\n            \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \\!atload\n        done\n\n        # Run the functions' wrapping & tracking requests.\n        if [[ -n ${ICE[wrap]} ]] {\n            (( ${+functions[.zinit-service]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n            .zinit-wrap-functions \"$save_url\" \"\" \"$id_as\"\n        }\n\n        [[ ${ICE[atload][1]} = \"!\" ]] && { .zinit-add-report \"$id_as\" \"Note: Starting to track the atload'!…' ice…\"; ZERO=\"$local_dir/$dirname/-atload-\"; local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$local_dir/$dirname\"; } && builtin eval \"${ICE[atload]#\\!}\"; ((1)); } || eval \"${ICE[atload]#\\!}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n        (( -- ZINIT[TMP_SUBST] == 0 )) && { ZINIT[TMP_SUBST]=inactive; builtin setopt noaliases; (( ${+ZINIT[bkp-compdef]} )) && functions[compdef]=\"${ZINIT[bkp-compdef]}\" || unfunction compdef; (( ZINIT[ALIASES_OPT] )) && builtin setopt aliases; }\n    elif [[ -n ${opts[(r)--command]} || ${ICE[as]} = command ]]; then\n        [[ ${+ICE[pick]} = 1 && -z ${ICE[pick]} ]] && \\\n            ICE[pick]=\"${id_as:t}\"\n        # Subversion - directory and multiple files possible.\n        if (( ${+ICE[svn]} )); then\n            if [[ -n ${ICE[pick]} ]]; then\n                list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )\n                [[ -n ${list[1-correct]} ]] && local xpath=\"${list[1-correct]:h}\" xfilepath=\"${list[1-correct]}\"\n            else\n                local xpath=\"$local_dir/$dirname\"\n            fi\n        else\n            local xpath=\"$local_dir/$dirname\" xfilepath=\"$local_dir/$dirname/$filename\"\n            # This doesn't make sense, but users may come up with something.\n            [[ -n ${ICE[pick]} ]] && {\n                list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )\n                [[ -n ${list[1-correct]} ]] && xpath=\"${list[1-correct]:h}\" xfilepath=\"${list[1-correct]}\"\n            }\n        fi\n        [[ -n $xpath && -z ${path[(er)$xpath]} ]] && path=( \"${xpath%/}\" ${path[@]} )\n        [[ -n $xfilepath && -f $xfilepath && ! -x \"$xfilepath\" ]] && command chmod a+x \"$xfilepath\" ${list[@]:#$xfilepath}\n        [[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = \"!\" ]] && {\n            if [[ ${ZINIT[TMP_SUBST]} = inactive ]]; then\n                # Temporary substituting of functions code is inlined from .zinit-tmp-subst-on.\n                (( ${+functions[compdef]} )) && ZINIT[bkp-compdef]=\"${functions[compdef]}\" || builtin unset \"ZINIT[bkp-compdef]\"\n                functions[compdef]=':zinit-tmp-subst-compdef \"$@\";'\n                ZINIT[TMP_SUBST]=1\n            else\n                (( ++ ZINIT[TMP_SUBST] ))\n            fi\n        }\n\n        if [[ -n ${ICE[src]} ]]; then\n            ZERO=\"${${(M)ICE[src]##/*}:-$local_dir/$dirname/${ICE[src]}}\"\n            (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; }; (( retval += $? )); }\n        fi\n        [[ -n ${ICE[multisrc]} ]] && { local ___oldcd=\"$PWD\"; () { setopt localoptions noautopushd; builtin cd -q \"$local_dir/$dirname\"; }; eval \"reply=(${ICE[multisrc]})\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; local fname; for fname in \"${reply[@]}\"; do ZERO=\"${${(M)fname:#/*}:-$local_dir/$dirname/$fname}\"; (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); builtin source \"$ZERO\"; }; }; (( retval += $? )); }; done; }\n\n        # Run the atload hooks right before atload ice.\n        reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atload-<-> <->]} )\n        for key in \"${reply[@]}\"; do\n            arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]}[@]}\" )\n            \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" \\!atload\n        done\n\n        # Run the functions' wrapping & tracking requests.\n        if [[ -n ${ICE[wrap]} ]] {\n            (( ${+functions[.zinit-service]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n            .zinit-wrap-functions \"$save_url\" \"\" \"$id_as\"\n        }\n\n        [[ ${ICE[atload][1]} = \"!\" ]] && { .zinit-add-report \"$id_as\" \"Note: Starting to track the atload'!…' ice…\"; ZERO=\"$local_dir/$dirname/-atload-\"; local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$local_dir/$dirname\"; } && builtin eval \"${ICE[atload]#\\!}\"; ((1)); } || eval \"${ICE[atload]#\\!}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n        [[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = \"!\" ]] && {\n            (( -- ZINIT[TMP_SUBST] == 0 )) && { ZINIT[TMP_SUBST]=inactive; builtin setopt noaliases; (( ${+ZINIT[bkp-compdef]} )) && functions[compdef]=\"${ZINIT[bkp-compdef]}\" || unfunction compdef; (( ZINIT[ALIASES_OPT] )) && builtin setopt aliases; }\n        }\n    elif [[ ${ICE[as]} = completion ]]; then\n        ((1))\n    fi\n\n    (( ${+ICE[atload]} )) && [[ ${ICE[atload][1]} != \"!\" ]] && { ZERO=\"$local_dir/$dirname/-atload-\"; local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$local_dir/$dirname\"; } && builtin eval \"${ICE[atload]}\"; ((1)); } || eval \"${ICE[atload]}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n    reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:atload-<-> <->]} )\n    for key in \"${reply[@]}\"; do\n        arr=( \"${(Q)${(z@)ZINIT_EXTS[$key]}[@]}\" )\n        \"${arr[5]}\" snippet \"$save_url\" \"$id_as\" \"$local_dir/$dirname\" atload\n    done\n\n    (( ${+ICE[notify]} == 1 )) && { [[ $retval -eq 0 || -n ${(M)ICE[notify]#\\!} ]] && { local msg; eval \"msg=\\\"${ICE[notify]#\\!}\\\"\"; +zinit-deploy-message @msg \"$msg\" } || +zinit-deploy-message @msg \"notify: Plugin not loaded / loaded with problem, the return code: $retval\"; }\n    (( ${+ICE[reset-prompt]} == 1 )) && +zinit-deploy-message @rst\n\n    ZINIT[CUR_USPL2]=\n    ZINIT[TIME_INDEX]=$(( ${ZINIT[TIME_INDEX]:-0} + 1 ))\n    ZINIT[TIME_${ZINIT[TIME_INDEX]}_${id_as}]=$SECONDS\n    ZINIT[AT_TIME_${ZINIT[TIME_INDEX]}_${id_as}]=$EPOCHREALTIME\n\n    .zinit-set-m-func unset\n    return retval\n} # ]]]\n\n# FUNCTION: .zinit-load [[[\n# Implements the exposed-to-user action of loading a plugin.\n#\n# $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin)\n# $2 - plugin name, if the third format is used\n.zinit-load() {\n    typeset -F 3 SECONDS=0\n    local ___mode=\"$3\" ___limit=\"$4\" ___rst=0 ___retval=0 ___key\n    .zinit-any-to-user-plugin \"$1\" \"$2\"\n    local ___user=\"${reply[-2]}\" ___plugin=\"${reply[-1]}\" ___id_as=\"${ICE[id-as]:-${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}}\"\n    local ___pdir_path=\"${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}}\"\n    local ___pdir_orig=\"$___pdir_path\"\n    ZINIT[CUR_USR]=\"$___user\" ZINIT[CUR_PLUGIN]=\"$___plugin\" ZINIT[CUR_USPL2]=\"$___id_as\"\n    if [[ -n ${ICE[teleid]} ]] {\n        .zinit-any-to-user-plugin \"${ICE[teleid]}\"\n        ___user=\"${reply[-2]}\" ___plugin=\"${reply[-1]}\"\n    } else {\n        ICE[teleid]=\"$___user${${___user:#%}:+/}$___plugin\"\n    }\n\n    .zinit-set-m-func set\n\n    local -a ___arr\n    reply=(\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-pre <->]}\n        ${(on)ZINIT_EXTS[(I)z-annex hook:preinit-<-> <->]}\n        ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-post <->]}\n    )\n    for ___key in \"${reply[@]}\"; do\n        ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]:-$ZINIT_EXTS2[$___key]}[@]}\" )\n        \"${___arr[5]}\" plugin \"$___user\" \"$___plugin\" \"$___id_as\" \"$___pdir_orig\" \"${${___key##(zinit|z-annex) hook:}%% <->}\" load || \\\n            return $(( 10 - $? ))\n    done\n\n    if [[ $___user != % && ! -d ${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---} ]] {\n        (( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n        reply=( \"$___user\" \"$___plugin\" ) REPLY=github\n        if (( ${+ICE[pack]} )) {\n            if ! .zinit-get-package \"$___user\" \"$___plugin\" \"$___id_as\" \\\n                \"${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}\" \\\n                \"${ICE[pack]:-default}\"\n            then\n                zle && { builtin print; zle .reset-prompt; }\n                return 1\n            fi\n            ___id_as=\"${ICE[id-as]:-${___user}${${___user:#(%|/)*}:+/}$___plugin}\"\n        }\n        ___user=\"${reply[-2]}\" ___plugin=\"${reply[-1]}\"\n        ICE[teleid]=\"$___user${${___user:#(%|/)*}:+/}$___plugin\"\n        [[ $REPLY = snippet ]] && {\n            ICE[id-as]=\"${ICE[id-as]:-$___id_as}\"\n            .zinit-load-snippet $___plugin \"\" $___limit && return\n            zle && { builtin print; zle .reset-prompt; }\n            return 1\n        }\n        .zinit-setup-plugin-dir \"$___user\" \"$___plugin\" \"$___id_as\" \"$REPLY\"\n        local rc=\"$?\"\n        if [[ \"$rc\" -ne 0 ]]; then\n            zle && { builtin print; zle .reset-prompt; }\n            return \"$rc\"\n        fi\n        zle && ___rst=1\n    }\n\n    ZINIT_SICE[$___id_as]=\n    .zinit-pack-ice \"$___id_as\"\n\n    (( ${+ICE[cloneonly]} )) && return 0\n\n    .zinit-register-plugin \"$___id_as\" \"$___mode\" \"${ICE[teleid]}\"\n\n    # Set up param'' objects (parameters).\n    if [[ -n ${ICE[param]} ]] {\n        .zinit-setup-params && local -x ${(Q)reply[@]}\n    }\n\n    reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atinit-<-> <->]} )\n    for ___key in \"${reply[@]}\"; do\n        ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}\" )\n        \"${___arr[5]}\" plugin \"$___user\" \"$___plugin\" \"$___id_as\" \"${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}}\" \\!atinit || \\\n            return $(( 10 - $? ))\n    done\n\n    [[ ${+ICE[atinit]} = 1 && $ICE[atinit] != '!'*   ]] && { local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}}\"; } && eval \"${ICE[atinit]}\"; ((1)); } || eval \"${ICE[atinit]}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n    reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:atinit-<-> <->]} )\n    for ___key in \"${reply[@]}\"; do\n        ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}\" )\n        \"${___arr[5]}\" plugin \"$___user\" \"$___plugin\" \"$___id_as\" \"${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}}\" atinit || \\\n            return $(( 10 - $? ))\n    done\n\n    .zinit-load-plugin \"$___user\" \"$___plugin\" \"$___id_as\" \\\n                    \"$___mode\" \"$___rst\" \"$___limit\" ; ___retval=$?\n    (( ${+ICE[notify]} == 1 )) && { [[ $___retval -eq 0 || -n ${(M)ICE[notify]#\\!} ]] && { local msg; eval \"msg=\\\"${ICE[notify]#\\!}\\\"\"; +zinit-deploy-message @msg \"$msg\" } || +zinit-deploy-message @msg \"notify: Plugin not loaded / loaded with problem, the return code: $___retval\"; }\n    (( ${+ICE[reset-prompt]} == 1 )) && +zinit-deploy-message @___rst\n\n    # Unset the `m` function.\n    .zinit-set-m-func unset\n\n    # Mark no load is in progress.\n    ZINIT[CUR_USR]= ZINIT[CUR_PLUGIN]= ZINIT[CUR_USPL2]=\n\n    ZINIT[TIME_INDEX]=$(( ${ZINIT[TIME_INDEX]:-0} + 1 ))\n    ZINIT[TIME_${ZINIT[TIME_INDEX]}_${___id_as//\\//---}]=$SECONDS\n    ZINIT[AT_TIME_${ZINIT[TIME_INDEX]}_${___id_as//\\//---}]=$EPOCHREALTIME\n    return ___retval\n} # ]]]\n\n# FUNCTION: .zinit-load-plugin [[[\n# Lower-level function for loading a plugin.\n#\n# $1 - user\n# $2 - plugin\n# $3 - mode (light or load)\n.zinit-load-plugin() {\n    local ___user=\"$1\" ___plugin=\"$2\" ___id_as=\"$3\" ___mode=\"$4\" \\\n            ___rst=\"$5\" ___limit=\"$6\" ___correct=0 ___retval=0\n    local ___pbase=\"${${___plugin:t}%(.plugin.zsh|.zsh|.git)}\" ___key\n    # Hide arguments from sourced scripts. Without this calls our \"$@\" are visible as \"$@\"\n    # within scripts that we `source`.\n    builtin set --\n    [[ -o ksharrays ]] && ___correct=1\n\n    [[ -n ${ICE[(i)(\\!|)(sh|bash|ksh|csh)]}${ICE[opts]} ]] && {\n        local -a ___precm\n        ___precm=(\n            builtin emulate\n            ${${(M)${ICE[(i)(\\!|)(sh|bash|ksh|csh)]}#\\!}:+-R}\n            ${${${ICE[(i)(\\!|)(sh|bash|ksh|csh)]}#\\!}:-zsh}\n            ${${ICE[(i)(\\!|)bash]}:+-${(s: :):-o noshglob -o braceexpand -o kshglob}}\n            ${(s: :):-${${:-${(@s: :):--o}\" \"${(s: :)^ICE[opts]}}:#-o }}\n            -c\n        )\n    }\n\n    [[ -z ${ICE[subst]} ]] && local ___builtin=builtin\n\n    [[ ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ]] && \\\n        ICE[pick]=\"${ICE[pick]:-/dev/null}\"\n\n    if [[ -n ${ICE[autoload]} ]] {\n        :zinit-tmp-subst-autoload -Uz \\\n            ${(s: :)${${${(s.;.)ICE[autoload]#[\\!\\#]}#[\\!\\#]}//(#b)((*)(->|=>|→)(*)|(*))/${match[2]:+$match[2] -S $match[4]}${match[5]:+${match[5]} -S ${match[5]}}}} \\\n            ${${(M)ICE[autoload]:#*(->|=>|→)*}:+-C} ${${(M)ICE[autoload]#(?\\!|\\!)}:+-C} ${${(M)ICE[autoload]#(?\\#|\\#)}:+-I}\n    }\n\n    if [[ ${ICE[as]} = command ]]; then\n        [[ ${+ICE[pick]} = 1 && -z ${ICE[pick]} ]] && \\\n            ICE[pick]=\"${___id_as:t}\"\n        reply=()\n        if [[ -n ${ICE[pick]} && ${ICE[pick]} != /dev/null ]]; then\n            reply=( ${(M)~ICE[pick]##/*}(DN) $___pdir_path/${~ICE[pick]}(DN) )\n            [[ -n ${reply[1-correct]} ]] && ___pdir_path=\"${reply[1-correct]:h}\"\n        fi\n        [[ -z ${path[(er)$___pdir_path]} ]] && {\n            [[ $___mode != light ]] && .zinit-diff-env \"${ZINIT[CUR_USPL2]}\" begin\n            path=( \"${___pdir_path%/}\" ${path[@]} )\n            [[ $___mode != light ]] && .zinit-diff-env \"${ZINIT[CUR_USPL2]}\" end\n            .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"$ZINIT[col-info2]$___pdir_path$ZINIT[col-rst] added to \\$PATH\"\n        }\n        [[ -n ${reply[1-correct]} && ! -x ${reply[1-correct]} ]] && command chmod a+x ${reply[@]}\n\n        [[ ${ICE[atinit]} = '!'* || -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = \"!\" ]] && {\n            if [[ ${ZINIT[TMP_SUBST]} = inactive ]]; then\n                (( ${+functions[compdef]} )) && ZINIT[bkp-compdef]=\"${functions[compdef]}\" || builtin unset \"ZINIT[bkp-compdef]\"\n                functions[compdef]=':zinit-tmp-subst-compdef \"$@\";'\n                ZINIT[TMP_SUBST]=1\n            else\n                (( ++ ZINIT[TMP_SUBST] ))\n            fi\n        }\n\n        local ZERO\n        [[ $ICE[atinit] = '!'* ]] && { local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}}\"; } && eval \"${ICE[atinit#!]}\"; ((1)); } || eval \"${ICE[atinit]#!}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n        [[ -n ${ICE[src]} ]] && { ZERO=\"${${(M)ICE[src]##/*}:-$___pdir_orig/${ICE[src]}}\"; (( ${+ICE[silent]} )) && { { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( ___retval += $? )); ((1)); } || { ((1)); { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; }; (( ___retval += $? )); }; }\n        [[ -n ${ICE[multisrc]} ]] && { local ___oldcd=\"$PWD\"; () { setopt localoptions noautopushd; builtin cd -q \"$___pdir_orig\"; }; eval \"reply=(${ICE[multisrc]})\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; local ___fname; for ___fname in \"${reply[@]}\"; do ZERO=\"${${(M)___fname:#/*}:-$___pdir_orig/$___fname}\"; (( ${+ICE[silent]} )) && { { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( ___retval += $? )); ((1)); } || { ((1)); { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; }; (( ___retval += $? )); }; done; }\n\n        # Run the atload hooks right before atload ice.\n        reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atload-<-> <->]} )\n        for ___key in \"${reply[@]}\"; do\n            ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}\" )\n            \"${___arr[5]}\" plugin \"$___user\" \"$___plugin\" \"$___id_as\" \"$___pdir_orig\" \\!atload\n        done\n\n        # Run the functions' wrapping & tracking requests.\n        if [[ -n ${ICE[wrap]} ]] {\n            (( ${+functions[.zinit-service]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n            .zinit-wrap-functions \"$___user\" \"$___plugin\" \"$___id_as\"\n        }\n\n        [[ ${ICE[atload][1]} = \"!\" ]] && { .zinit-add-report \"$___id_as\" \"Note: Starting to track the atload'!…' ice…\"; ZERO=\"$___pdir_orig/-atload-\"; local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$___pdir_orig\"; } && builtin eval \"${ICE[atload]#\\!}\"; } || eval \"${ICE[atload]#\\!}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n        [[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = \"!\" ]] && {\n            (( -- ZINIT[TMP_SUBST] == 0 )) && { ZINIT[TMP_SUBST]=inactive; builtin setopt noaliases; (( ${+ZINIT[bkp-compdef]} )) && functions[compdef]=\"${ZINIT[bkp-compdef]}\" || unfunction compdef; (( ZINIT[ALIASES_OPT] )) && builtin setopt aliases; }\n        }\n    elif [[ ${ICE[as]} = completion ]]; then\n        ((1))\n    else\n        if [[ -n ${ICE[pick]} ]]; then\n            [[ ${ICE[pick]} = /dev/null ]] && reply=( /dev/null ) || reply=( ${(M)~ICE[pick]##/*}(DN) $___pdir_path/${~ICE[pick]}(DN) )\n        elif [[ -e $___pdir_path/$___pbase.plugin.zsh && $___limit -ne 0 ]]; then\n            reply=( \"$___pdir_path/$___pbase\".plugin.zsh )\n        else\n            .zinit-find-other-matches \"$___pdir_path\" \"$___pbase\" \"$___limit\"\n        fi\n\n        #[[ ${#reply} -eq 0 ]] && return 1\n\n        # Get first one.\n        local ___fname=\"${reply[1-correct]:t}\"\n        ___pdir_path=\"${reply[1-correct]:h}\"\n\n        .zinit-add-report \"${ZINIT[CUR_USPL2]}\" \"Source $___fname ${${${(M)___mode:#light}:+(no reporting)}:-$ZINIT[col-info2](reporting enabled)$ZINIT[col-rst]}\"\n\n        # Light and compdef ___mode doesn't do diffs and temporary substituting of functions.\n        [[ $___mode != light(|-b) ]] && .zinit-diff \"${ZINIT[CUR_USPL2]}\" begin\n\n        .zinit-tmp-subst-on \"${___mode:-load}\"\n\n        # We need some state, but ___user wants his for his plugins.\n        (( ${+ICE[blockf]} )) && { local -a fpath_bkp; fpath_bkp=( \"${fpath[@]}\" ); }\n        local ZERO=\"$___pdir_path/$___fname\"\n        (( ${+ICE[aliases]} )) || builtin setopt noaliases\n        [[ $ICE[atinit] = '!'* ]] && { local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}}\"; } && eval \"${ICE[atinit]#!}\"; ((1)); } || eval \"${ICE[atinit]#1}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n        (( ${+ICE[silent]} )) && { { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( ___retval += $? )); ((1)); } || { ((1)); { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; }; (( ___retval += $? )); }\n        [[ -n ${ICE[src]} ]] && { ZERO=\"${${(M)ICE[src]##/*}:-$___pdir_orig/${ICE[src]}}\"; (( ${+ICE[silent]} )) && { { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( ___retval += $? )); ((1)); } || { ((1)); { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; }; (( ___retval += $? )); }; }\n        [[ -n ${ICE[multisrc]} ]] && { local ___oldcd=\"$PWD\"; () { setopt localoptions noautopushd; builtin cd -q \"$___pdir_orig\"; }; eval \"reply=(${ICE[multisrc]})\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; for ___fname in \"${reply[@]}\"; do ZERO=\"${${(M)___fname:#/*}:-$___pdir_orig/$___fname}\"; (( ${+ICE[silent]} )) && { { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; } 2>/dev/null 1>&2; (( ___retval += $? )); ((1)); } || { { [[ -n $___precm ]] && { builtin ${___precm[@]} 'source \"$ZERO\"'; ((1)); } || { ((1)); $___builtin source \"$ZERO\"; }; }; (( ___retval += $? )); } done; }\n\n        # Run the atload hooks right before atload ice.\n        reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:\\!atload-<-> <->]} )\n        for ___key in \"${reply[@]}\"; do\n            ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}\" )\n            \"${___arr[5]}\" plugin \"$___user\" \"$___plugin\" \"$___id_as\" \"$___pdir_orig\" \\!atload\n        done\n\n        # Run the functions' wrapping & tracking requests.\n        if [[ -n ${ICE[wrap]} ]] {\n            (( ${+functions[.zinit-service]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n            .zinit-wrap-functions \"$___user\" \"$___plugin\" \"$___id_as\"\n        }\n\n        [[ ${ICE[atload][1]} = \"!\" ]] && { .zinit-add-report \"$___id_as\" \"Note: Starting to track the atload'!…' ice…\"; ZERO=\"$___pdir_orig/-atload-\"; local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$___pdir_orig\"; } && builtin eval \"${ICE[atload]#\\!}\"; ((1)); } || eval \"${ICE[atload]#\\!}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n        (( ZINIT[ALIASES_OPT] )) && builtin setopt aliases\n        (( ${+ICE[blockf]} )) && { fpath=( \"${fpath_bkp[@]}\" ); }\n\n        .zinit-tmp-subst-off \"${___mode:-load}\"\n\n        [[ $___mode != light(|-b) ]] && .zinit-diff \"${ZINIT[CUR_USPL2]}\" end\n    fi\n\n    [[ ${+ICE[atload]} = 1 && ${ICE[atload][1]} != \"!\" ]] && { ZERO=\"$___pdir_orig/-atload-\"; local ___oldcd=\"$PWD\"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q \"$___pdir_orig\"; } && builtin eval \"${ICE[atload]}\"; ((1)); } || eval \"${ICE[atload]}\"; () { setopt localoptions noautopushd; builtin cd -q \"$___oldcd\"; }; }\n\n    reply=( ${(on)ZINIT_EXTS[(I)z-annex hook:atload-<-> <->]} )\n    for ___key in \"${reply[@]}\"; do\n        ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}\" )\n        \"${___arr[5]}\" plugin \"$___user\" \"$___plugin\" \"$___id_as\" \"$___pdir_orig\" atload\n    done\n\n    (( ___rst )) && { builtin print; zle .reset-prompt; }\n\n    return ___retval\n} # ]]]\n\n# FUNCTION: .zinit-compdef-replay [[[\n# Runs gathered compdef calls. This allows to run 'compinit' after loading plugins.\n.zinit-compdef-replay() {\n    local quiet=\"$1\"\n    typeset -a pos\n\n    # Check if compinit was loaded.\n    if [[ ${+functions[compdef]} = 0 ]]; then\n        +zi-log \"{u-warn}Error{b-warn}:{rst} The {func}compinit{rst}\" \\\n            \"function hasn't been loaded, cannot do {it}{cmd}compdef replay{rst}.\"\n        return 1\n    fi\n\n    # In the same order.\n    local cdf\n    for cdf in \"${ZINIT_COMPDEF_REPLAY[@]}\"; do\n        pos=( \"${(z)cdf}\" )\n        # When ZINIT_COMPDEF_REPLAY empty (also when only white spaces).\n        [[ ${#pos[@]} = 1 && -z ${pos[-1]} ]] && continue\n        pos=( \"${(Q)pos[@]}\" )\n        [[ $quiet = -q ]] || +zi-log \"Running compdef: {cmd}${pos[*]}{rst}\"\n        compdef \"${pos[@]}\"\n    done\n\n    return 0\n} # ]]]\n\n# FUNCTION: .zinit-compdef-clear [[[\n# Implements user-exposed functionality to clear gathered compdefs.\n.zinit-compdef-clear() {\n    local quiet=\"$1\" count=\"${#ZINIT_COMPDEF_REPLAY}\"\n    ZINIT_COMPDEF_REPLAY=( )\n    [[ $quiet = -q ]] || +zi-log \"Compdef-replay cleared (it had {num}${count}{rst} entries).\"\n} # ]]]\n\n# FUNCTION: .zinit-add-report [[[\n# Adds a report line for given plugin.\n#\n# $1 - uspl2, i.e. user/plugin\n# $2 - the text\n.zinit-add-report() {\n    # Use zinit binary module if available.\n    [[ -n $1 ]] && { (( ${+builtins[zpmod]} && 0 )) && zpmod report-append \"$1\" \"$2\"$'\\n' || ZINIT_REPORTS[$1]+=\"$2\"$'\\n'; }\n    [[ ${ZINIT[DTRACE]} = 1 ]] && { (( ${+builtins[zpmod]} )) && zpmod report-append _dtrace/_dtrace \"$2\"$'\\n' || ZINIT_REPORTS[_dtrace/_dtrace]+=\"$2\"$'\\n'; }\n    return 0\n} # ]]]\n\n# FUNCTION: .zinit-add-fpath [[[\n.zinit-add-fpath() {\n    [[ $1 = (-f|--front) ]] && { shift; integer front=1; }\n    .zinit-any-to-user-plugin \"$1\" \"\"\n    local id_as=\"$1\" add_dir=\"$2\" user=\"${reply[-2]}\" plugin=\"${reply[-1]}\"\n    if (( front )) {\n        fpath[1,0]=${${${(M)user:#%}:+$plugin}:-${ZINIT[PLUGINS_DIR]}/${id_as//\\//---}}${add_dir:+/$add_dir}\n    } else {\n        fpath+=(\n            ${${${(M)user:#%}:+$plugin}:-${ZINIT[PLUGINS_DIR]}/${id_as//\\//---}}${add_dir:+/$add_dir}\n        )\n    }\n} # ]]]\n\n# FUNCTION: .zinit-run [[[\n# Run code inside plugins folder\n# It uses the 'correct' parameter from uppers scope zinit().\n.zinit-run() {\n    if [[ $1 = (-l|--last) ]]; then\n        { set -- \"${ZINIT[last-run-plugin]:-$(<${ZINIT[BIN_DIR]}/last-run-object.txt)}\" \"${@[2-correct,-1]}\"; } &>/dev/null\n        [[ -z $1 ]] && { +zi-log \"{u-warn}Error{b-warn}:{rst} No recent plugin-ID saved on the disk yet, please specify\" \\\n                            \"it as the first argument, i.e.{ehi}: {cmd}zi run {pid}usr/plg{slight} {…}the code to run{…} \"; return 1; }\n    else\n        integer ___nolast=1\n    fi\n    .zinit-any-to-user-plugin \"$1\" \"\"\n    local ___id_as=\"$1\" ___user=\"${reply[-2]}\" ___plugin=\"${reply[-1]}\" ___oldpwd=\"$PWD\"\n    () {\n        builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}\n        builtin cd &>/dev/null -q ${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\\//---}} || {\n            .zinit-get-object-path snippet \"$___id_as\"\n            builtin cd &>/dev/null -q $REPLY\n        }\n    }\n    if (( $? == 0 )); then\n        (( ___nolast )) && { builtin print -r \"$1\" >! ${ZINIT[BIN_DIR]}/last-run-object.txt; }\n        ZINIT[last-run-plugin]=\"$1\"\n        eval \"${@[2-correct,-1]}\"\n        () { setopt localoptions noautopushd; builtin cd -q \"$___oldpwd\"; }\n    else\n        +zi-log \"{u-warn}Error{b-warn}:{rst} no such plugin or snippet.\"\n    fi\n} # ]]]\n\n# FUNCTION: +zinit-deploy-message [[[\n# Deploys a sub-prompt message to be displayed OR a 'zle .reset-prompt'\n# call to be invoked\n+zinit-deploy-message() {\n    [[ $1 = <-> && ( ${#} = 1 || ( $2 = (hup|nval|err) && ${#} = 2 ) ) ]] && { zle && {\n            local alltext text IFS=$'\\n' nl=$'\\n'\n            repeat 25; do read -r -u\"$1\" text; alltext+=\"${text:+$text$nl}\"; done\n            [[ $alltext = @rst$nl ]] && { builtin zle reset-prompt; ((1)); } || \\\n                { [[ -n $alltext ]] && builtin zle -M \"$alltext\"; }\n        }\n        builtin zle -F \"$1\"; exec {1}<&-\n        return 0\n    }\n    local THEFD=13371337 hasw\n    # The expansion is: if there is @sleep: pfx, then use what is after.\n    # it, otherwise substitute 0\n    exec {THEFD} < <(LANG=C sleep $(( 0.01 + ${${${(M)1#@sleep:}:+${1#@sleep:}}:-0} )); builtin print -r -- ${1:#(@msg|@sleep:*)} \"${@[2,-1]}\"; )\n    command true # workaround a Zsh bug, see: https://www.zsh.org/mla/workers/2018/msg00966.html\n    builtin zle -F \"$THEFD\" +zinit-deploy-message\n} # ]]]\n\n# FUNCTION: .zinit-formatter-auto [[[\n.zinit-formatter-auto() {\n    emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent\n    local out in=$1 i wrk match spaces rest\n    integer mbegin mend\n    local -a ice_order ecmds\n    ice_order=(\n        ${(As:|:)ZINIT[ice-list]}\n        ${(@)${(A@kons:|:)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}\n    )\n    ecmds=( ${ZINIT_EXTS[(I)z-annex subcommand:*]#z-annex subcommand:} )\n\n    in=${(j: :)${${(Z+Cn+)in}//[$'\\t ']/$'\\u00a0'}}\n    wrk=$in\n    # Work on input bit by bit on whitespace separated words\n    while [[ $in == (#b)([[:space:]]#)([^[:space:]]##)(*) ]]; do\n        spaces=$match[1]\n        rest=$match[3]\n        wrk=${match[2]//---//}\n        REPLY=$wrk\n        # Is it a time?\n        if [[ $wrk == ([[:space:]]##|(#s))[0-9.]##([[:space:]]##|(#e)) &&\n            $rest == ([[:space:]]#|(#s))[sm]([[:space:]]##*|(#e)) || $wrk == ([[:space:]]##|(#s))[0-9.]##[sm]([[:space:]]##|(#e)) ]]; then\n            REPLY=$ZINIT[col-time]$wrk$ZINIT[col-rst]\n            # Colorize next token\n            if [[ $wrk != *[sm]* ]]; then\n                rest=$ZINIT[col-time]${(M)rest##[[:space:]]#[sm]}$ZINIT[col-rst]${rest##[[:space:]]#[sm]}\n            fi\n        # Is it a number?\n        # TODO: differentiate floats\n        elif [[ $wrk == ([[:space:]]##|(#s))[0-9.]##([[:space:]]##|(#e)) ]]; then\n            REPLY=$ZINIT[col-num]$wrk$ZINIT[col-rst]\n        # Is it a URL?\n        elif [[ $wrk == (#b)(((http|ftp)(|s)|ssh|scp|ntp|file)://[[:alnum:].:+/]##) ]]; then\n            .zinit-formatter-url $wrk\n        # Is it an ice mod?\n        elif [[ $wrk == (--|)(${(~j:|:)ice_order})[:=\\\"\\'\\!a-zA-Z0-9-]* ]]; then\n            REPLY=$ZINIT[col-ice]$wrk$ZINIT[col-rst]\n        # Is it an object ID?\n        elif [[ $wrk == (OMZ([PLT]|)|PZT([MLT]|)):* || $wrk == [^/]##/[^/]## || -d $ZINIT[PLUGINS_DIR]/${wrk//\\//---} ]]; then\n            .zinit-formatter-pid $wrk\n        # Is it a zinit command?\n        elif [[ $wrk == (${~ZINIT[cmds]}|${(~j:|:)ecmds}) ]]; then\n            REPLY=$ZINIT[col-cmd]$wrk$ZINIT[col-rst]\n        # Is it a binary or other runnable?\n        elif type $1 &>/dev/null; then\n            REPLY=$ZINIT[col-bcmd]$wrk$ZINIT[col-rst]\n        # Is it a single-char glymph?\n        elif [[ $wrk == (#b)(*)('<->'|'<–>'|'<—>')(*) || $wrk == (#b)(*)(…|–|—|↔|...)(*) ]]; then\n            local -A map=( … … - dsh – ndsh\n                — mdsh '<->' ↔ '<–>' ↔ '<—>' ↔\n                ↔ ↔ ... …)\n            REPLY=$match[1]$ZINIT[col-$map[$wrk]]$match[3]\n        # Is it a quoted string?\n        # \\1 - preceding \\2 - open, \\3 - string, \\4 - close, \\5 - following\n        elif [[ $wrk == (#b)(*)([\\'\\`\\\"])([^\\'\\`\\\"]##)([\\'\\`\\\"])(*) ]]; then\n            local -A map=( \\` bapo \\' apo \\\" quo\n                x\\` baps x\\' aps x\\\" quos )\n            local openq=$match[2] str=$match[3] closeq=$match[4] RST=$ZINIT[col-rst]\n            REPLY=$match[1]$ZINIT[col-$map[$openq]]$openq$RST$ZINIT[col-$map[x$openq]]$str$RST$ZINIT[col-$map[$closeq]]$closeq$RST$match[5]\n        fi\n        in=$rest\n        out+=${spaces//$'\\n'/$'\\013\\015'}$REPLY\n    done\n    # Restore regular, not non-breaking (0xa0) spaces\n    REPLY=${out//$'\\u00a0'/ }\n} # ]]]\n\n# FUNCTION: .zinit-formatter-pid [[[\n.zinit-formatter-pid() {\n    builtin emulate -L zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n\n    # Save whitespace location\n    local pbz=${(M)1##(#s)[[:space:]]##}\n    local kbz=${(M)1%%[[:space:]]##(#e)}\n    # trim whitespace\n    1=${1//((#s)[[:space:]]##|[[:space:]]##(#e))/}\n\n    ((${+functions[.zinit-first]})) || source ${ZINIT[BIN_DIR]}/zinit-side.zsh\n    .zinit-any-colorify-as-uspl2 \"$1\";\n\n    # Replace at least one character with an unbreakable space, because\n    # due to implementation problems, marginal whitespace is lost ...\n    pbz=${pbz/[[:blank:]]/ }\n    local kbz_rev=\"${(j::)${(@Oas::)kbz}}\"\n    kbz=\"${(j::)${(@Oas::)${kbz_rev/[[:blank:]]/ }}}\"\n\n    # Re-add whitespace\n    REPLY=$pbz$REPLY$kbz\n} # ]]]\n\n# FUNCTION: .zinit-formatter-bar [[[\n.zinit-formatter-bar() {\n    .zinit-formatter-bar-util ─ bar\n} # ]]]\n\n# FUNCTION: .zinit-formatter-th-bar [[[\n.zinit-formatter-th-bar() {\n    .zinit-formatter-bar-util ━ th-bar\n} # ]]]\n\n# FUNCTION: .zinit-formatter-bar-util [[[\n.zinit-formatter-bar-util() {\n    if [[ $LANG == (#i)*utf-8* ]]; then\n        ch=$1\n    else\n        ch=-\n    fi\n\n    REPLY=$ZINIT[col-$2]${(pl:COLUMNS-1::$ch:):-}$ZINIT[col-rst]\n} # ]]]\n\n# FUNCTION: .zinit-formatter-url [[[\n.zinit-formatter-url() {\n    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n    #              1:proto        3:domain/5:start      6:end-of-it         7:no-dot-domain        9:file-path\n    if [[ $1 = (#b)([^:]#)(://|::)((([[:alnum:]._+-]##).([[:alnum:]_+-]##))|([[:alnum:].+_-]##))(|/(*)) ]] {\n        # The advanced coloring if recognized the format…\n        match[9]=${match[9]//\\//\"%F{227}%B\"/\"%F{81}%b\"}\n        if [[ -n $match[4] ]]; then\n            REPLY=\"$(builtin print -Pr -- %F{220}$match[1]%F{227}$match[2]\\\n%B%F{82}$match[5]\\\n%B%F{227}.\\\n%B%F{183}$match[6]%f%b)\" # … this ·case· ends at: trailing component of the with-dot domain …\n        else\n            REPLY=\"$(builtin print -Pr -- %F{220}$match[1]%F{227}$match[2]\\\n%B%F{82}$match[7]%f%b)\" # … this ·case· ends at: no-dot domain …\n        fi\n        # Is there any file-path part in the URL?\n        if [[ -n $match[9] ]]; then\n            REPLY+=\"$(print -Pr -- \\\n%F{227}%B/%F{81}%b$match[9]%f%b)\" # … append it. This ends the URL.\n        fi\n#endif\n    } else {\n        # …revert to the basic if not…\n        REPLY=$ZINIT[col-url]$1$ZINIT[col-rst]\n    }\n} # ]]]\n\n# FUNCTION: .zinit-main-message-formatter [[[\n.zinit-main-message-formatter() {\n    if [[ -z $1 && -z $2 && -z $3 ]]; then\n        REPLY=\"\"\n        return\n    fi\n    local append influx in_prepend\n    if [[ $2 == (b|u|it|st|nb|nu|nit|nst) ]]; then\n        # Code repetition to preserve any leading/trailing whitespace\n        # and to allow accumulation of this code with others.\n        append=$ZINIT[col-$2]\n    elif [[ $2 == (…|ndsh|mdsh|mmdsh|-…|lr|) || -z $2 || -z $ZINIT[col-$2] ]]; then\n        # Resume previous escape code, if one is present.\n        if [[ $ZINIT[__last-formatter-code] != (…|ndsh|mdsh|mmdsh|-…|lr|rst|nl|) ]]; then\n            in_prepend=$ZINIT[col-$ZINIT[__last-formatter-code]]\n            influx=$ZINIT[col-$ZINIT[__last-formatter-code]]\n        fi\n        # Otherwise no action - only copy of this code without color.\n    else\n        # End of escaping logic\n        append=$ZINIT[col-rst]\n    fi\n\n    # Construct the text.\n    REPLY=$in_prepend${ZINIT[col-$2]:-$1}$influx$3$append\n\n    # Replace new lines with characters that work the same but are not\n    # deleted in the substitution $ (...) - vertical tab 0xB <-> 13 in the system\n    # octagonal connected back carriage (015).\n    local nl=$'\\n' vertical=$'\\013' carriager=$'\\015'\n    REPLY=${REPLY//$nl/$vertical$carriager}\n\n#    REPLY+=\"x(${3}…)\"\n} # ]]]\n\n# FUNCTION: +zi-log [[[\n# Logging function\n+zi-log() {\n    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n    local opt msg\n    [[ $1 = -* ]] && { local opt=$1; shift; }\n\n    ZINIT[__last-formatter-code]=\n    msg=${${(j: :)${@:#--}}//\\%/%%}\n\n    if [[ -z $ZINIT[DEBUG] ]] && [[ \"$msg\" = (#s){dbg}* ]]; then\n        return\n    fi\n\n    # First try a dedicated formatter, marking its empty output with ←→, then\n    # the general formatter and in the end filter-out the ←→ from the message.\n    msg=${${msg//(#b)(([\\\\]|(%F))([\\{]([^\\}]##)[\\}])|([\\{]([^\\}]##)[\\}])([^\\%\\{\\\\]#))/\\\n${match[4]:+${${match[3]:-$ZINIT[col-${ZINIT[__last-formatter-code]}]}:#%F}}$match[3]$match[4]\\\n${${functions[.zinit-formatter-$match[7]]:+\\\n${$(.zinit-formatter-$match[7] \"$match[8]\"; builtin print -rn -- $REPLY):-←→}}:-\\\n$(.zinit-main-message-formatter \"$match[6]\" \"$match[7]\" \"$match[8]\"; \\\n  builtin print -rn -- \"$REPLY\"\n )${${ZINIT[__last-formatter-code]::=${${${match[7]:#(…|ndsh|mdsh|mmdsh|-…|lr)}:+\\\n$match[7]}:-${ZINIT[__last-formatter-code]}}}:+}}}//←→}\n\n    [[ -z $msg ]] && return\n\n    # Reset color attributes at the end of the message\n    msg=$msg$ZINIT[col-rst]\n    # Output the processed message:\n    builtin print -Pr ${opt:#--} -- $msg\n\n    # Needed to correctly end a message with {nl}.\n    if [[ -n ${opt:#*n*} || -z $opt ]]; then\n        print -n $'\\015'\n    fi\n} # ]]]\n# FUNCTION: +zinit-message [[[\n# Wrapper function to maintain backward compatibility\n+zinit-message(){\n    +zi-log $@\n} # ]]]\n\n# FUNCTION: +zinit-prehelp-usage-message [[[\n+zinit-prehelp-usage-message() {\n    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n    local cmd=$1 allowed=$2 sep=\"$ZINIT[col-msg2], $ZINIT[col-ehi]\" \\\n        sep2=\"$ZINIT[col-msg2], $ZINIT[col-opt]\" bcol\n\n    # -h/--help given?\n    if (( OPTS[opt_-h,--help] )) {\n        # Yes – a help message:\n        +zi-log \"{lhi}HELP FOR {apo}\\`{cmd}$cmd{apo}\\`{lhi} subcommand {mdsh}\" \\\n                \"the available {b-lhi}options{ehi}:{rst}\"\n        local opt\n        for opt ( ${(kos:|:)allowed} ) {\n            [[ $opt == --* ]] && continue\n            local msg=${___opt_map[$opt]#*:} txt=${___opt_map[(r)opt_$opt,--[^:]##]}\n            if [[ $msg == *\":[\"* ]] {\n                msg=${${(MS)msg##$cmd:\\[[^]]##}:-${(MS)msg##\\*:\\[[^]]##}}\n                msg=${msg#($cmd|\\*):\\[}\n            }\n            local pre_msg=`+zi-log -n {opt}${(r:14:)${txt#opt_}}`\n            +zi-log ${(r:35:: :)pre_msg}{rst}{ehi}→{rst}\"  $msg\"\n        }\n    } elif [[ -n $allowed ]] {\n        shift 2\n        # No – an error message:\n        +zi-log \"{b}{u-warn}ERROR{b-warn}:{rst}{msg2} Incorrect options given{ehi}:\" \\\n                \"${(Mpj:$sep:)@:#-*}{rst}{msg2}. Allowed for the subcommand{ehi}:{rst}\" \\\n                \"{apo}\\`{cmd}$cmd{apo}\\`{msg2} are{ehi}:{rst}\" \\\n                \"{nl}{mmdsh} {opt}${allowed//\\|/$sep2}{msg2}.\" \\\n                \"{nl}{…} Aborting.{rst}\"\n    } else {\n        local -a cmds\n        cmds=( load snippet update delete )\n        local bcol=\"{$cmd}\" sep=\"${ZINIT[col-rst]}${ZINIT[col-$cmd]}\\`, \\`${ZINIT[col-cmd]}\"\n        +zi-log \"$bcol(it should be one of, e.g.{ehi}:\" \\\n                \"{nb}$bcol\\`{cmd}${(pj:$sep:)cmds}$bcol\\`,\" \\\n                \"{cmd}{…}$bcol, e.g.{ehi}: {nb}$bcol\\`{lhi}zinit {b}{cmd}load\" \\\n                \"{pid}username/reponame$bcol\\`) or a {b}{hi}for{nb}$bcol-based\" \\\n                \"command body (i.e.{ehi}:{rst}$bcol e.g.{ehi}: {rst}$bcol\\`{lhi}zinit\" \\\n                    \"{…}{b}ice-spec{nb}{…} {hi}for{nb}{lhi} {…}({b}plugin\" \\\n                    \"{nb}or{b} snippet) {pname}ID-1 ID-2 {-…} {lhi}{…}$bcol\\`).\" \\\n                \"See \\`{cmd}help$bcol\\` for a more detailed usage information and\" \\\n                \"the list of the {cmd}subcommands$bcol.{rst}\"\n    }\n} # ]]]\n# FUNCTION: .zinit-parse-opts [[[\n.zinit-parse-opts() {\n    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n    reply=( \"${(@)${@[2,-1]//([  $'\\t']##|(#s))(#b)(${(~j.|.)${(@s.|.)___opt_map[$1]}})(#B)([  $'\\t']##|(#e))/${OPTS[${___opt_map[${match[1]}]%%:*}]::=1}ß←↓→}:#1ß←↓→}\" )\n} # ]]]\n\n# Ice support\n\n# FUNCTION: .zinit-ice [[[\n# Parses ICE specification, puts the result into ICE global hash.\n# The ice-spec is valid for next command only (i.e. it \"melts\"), but\n# it can then stick to plugin and activate e.g. at update.\n.zinit-ice() {\n    builtin setopt localoptions noksharrays extendedglob warncreateglobal typesetsilent noshortloops\n    integer retval\n    local bit exts=\"${(j:|:)${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}}\"\n    for bit; do\n        [[ $bit = (#b)(--|)(${~ZINIT[ice-list]}${~exts})(*) ]] && ZINIT_ICES[${match[2]}]+=\"${ZINIT_ICES[${match[2]}]:+;}${match[3]#(:|=)}\" || break\n        retval+=1\n    done\n    [[ ${ZINIT_ICES[as]} = program ]] && ZINIT_ICES[as]=command\n    [[ -n ${ZINIT_ICES[on-update-of]} ]] && ZINIT_ICES[subscribe]=\"${ZINIT_ICES[subscribe]:-${ZINIT_ICES[on-update-of]}}\"\n    [[ -n ${ZINIT_ICES[pick]} ]] && ZINIT_ICES[pick]=\"${ZINIT_ICES[pick]//\\$ZPFX/${ZPFX%/}}\"\n    if (( $+ZINIT_ICES[build] )); then\n        +zi-log -- \"{dbg} {ice}build{rst}: setting configure & make ices\"\n        ZINIT_ICES[configure]=\n        ZINIT_ICES[make]=\n    fi\n    if (( $+ZINIT_ICES[configure] || $+ZINIT_ICES[cmake] || $+ZINIT_ICES[make] )); then\n        ZINIT_ICES[null]=\n    fi\n    (( $+ZINIT_ICES[configure] )) && ZINIT_ICES[configure]=\"${ZINIT_ICES[configure]}\"\n    (( $+ZINIT_ICES[make] )) && ZINIT_ICES[make]=\"${ZINIT_ICES[make]:-install}\"\n    return retval\n} # ]]]\n# FUNCTION: .zinit-pack-ice [[[\n# Remembers all ice-mods, assigns them to concrete plugin. Ice spec\n# is in general forgotten for second-next command (i.e., ice melts quickly), however they\n# glue to the object (plugin or snippet) mentioned in the next command for later use with (e.g. 'zinit update ...').\n.zinit-pack-ice() {\n    ZINIT_SICE[$1${1:+${2:+/}}$2]+=\"${(j: :)${(qkv)ICE[@]}} \"\n    ZINIT_SICE[$1${1:+${2:+/}}$2]=\"${ZINIT_SICE[$1${1:+${2:+/}}$2]# }\"\n    return 0\n} # ]]]\n# FUNCTION: .zinit-load-ices [[[\n.zinit-load-ices() {\n    local id_as=\"$1\" ___key ___path\n    local -a ice_order\n    ice_order=(\n        ${(As:|:)ZINIT[ice-list]}\n        ${(@)${(A@kons:|:)${ZINIT_EXTS[ice-mods]//\\'\\'/}}/(#s)<->-/}\n    )\n    ___path=\"${ZINIT[PLUGINS_DIR]}/${id_as//\\//---}\"/._zinit\n    # TODO: snippets dir computation\n    if [[ ! -d $___path ]] {\n        if ! .zinit-get-object-path snippet \"${id_as//\\//---}\"; then\n            return 1\n        fi\n        ___path=\"$REPLY\"/._zinit\n    }\n    for ___key ( \"${ice_order[@]}\" ) {\n        (( ${+ICE[$___key]} )) && [[ ${ICE[$___key]} != +* ]] && continue\n        [[ -e $___path/$___key ]] && ICE[$___key]=\"$(<$___path/$___key)\"\n    }\n    [[ -n ${ICE[on-update-of]} ]] && ICE[subscribe]=\"${ICE[subscribe]:-${ICE[on-update-of]}}\"\n    [[ ${ICE[as]} = program ]] && ICE[as]=command\n    [[ -n ${ICE[pick]} ]] && ICE[pick]=\"${ICE[pick]//\\$ZPFX/${ZPFX%/}}\"\n\n    return 0\n} # ]]]\n# FUNCTION: .zinit-setup-params [[[\n.zinit-setup-params() {\n    builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n    reply=( ${(@)${(@s.;.)ICE[param]}/(#m)*/${${MATCH%%(-\\>|→|=\\>)*}//((#s)[[:space:]]##|[[:space:]]##(#e))}${${(M)MATCH#*(-\\>|→|=\\>)}:+\\=${${MATCH#*(-\\>|→|=\\>)}//((#s)[[:space:]]##|[[:space:]]##(#e))}}} )\n    (( ${#reply} )) && return 0 || return 1\n} # ]]]\n\n#\n# Turbo.\n#\n\n# FUNCTION: .zinit-run-task [[[\n# A backend, worker function of .zinit-scheduler. It obtains the tasks\n# index and a few of its properties (like the type: plugin, snippet,\n# service plugin, service snippet) and executes it first checking for\n# additional conditions (like non-numeric wait'' ice).\n#\n# $1 - current pass: 1 or 2\n# $2 - time assigned to the task\n# $3 - type: plugin, service plugin, service snippet, snippet\n# $4 - tasks index in the ZINIT[WAIT_ICE_...] fields\n# $5 - mode: load, light\n# $6 - details: alias name (derived from id-as''), plugin-spec, or snippet URL\n.zinit-run-task() {\n    local ___pass=\"$1\" ___t=\"$2\" ___tpe=\"$3\" ___idx=\"$4\" ___mode=\"$5\" ___id=\"${(Q)6}\" ___opt=\"${(Q)7}\" ___action ___s=1 ___retval=0\n\n    local -A ICE ZINIT_ICE\n    ICE=( \"${(@Q)${(z@)ZINIT[WAIT_ICE_${___idx}]}}\" )\n    ZINIT_ICE=( \"${(kv)ICE[@]}\" )\n\n    local ___id_as=${ICE[id-as]:-$___id}\n\n    if [[ $___pass = 1 && ${${ICE[wait]#\\!}%%[^0-9]([^0-9]|)([^0-9]|)([^0-9]|)} = <-> ]]; then\n        ___action=\"${(M)ICE[wait]#\\!}load\"\n    elif [[ $___pass = 1 && -n ${ICE[wait]#\\!} ]] && { eval \"${ICE[wait]#\\!}\" || [[ $(( ___s=0 )) = 1 ]]; }; then\n        ___action=\"${(M)ICE[wait]#\\!}load\"\n    elif [[ -n ${ICE[load]#\\!} && -n $(( ___s=0 )) && $___pass = 3 && -z ${ZINIT_REGISTERED_PLUGINS[(r)$___id_as]} ]] && eval \"${ICE[load]#\\!}\"; then\n        ___action=\"${(M)ICE[load]#\\!}load\"\n    elif [[ -n ${ICE[unload]#\\!} && -n $(( ___s=0 )) && $___pass = 2 && -n ${ZINIT_REGISTERED_PLUGINS[(r)$___id_as]} ]] && eval \"${ICE[unload]#\\!}\"; then\n        ___action=\"${(M)ICE[unload]#\\!}remove\"\n    elif [[ -n ${ICE[subscribe]#\\!} && -n $(( ___s=0 )) && $___pass = 3 ]] && \\\n        { local -a fts_arr\n          eval \"fts_arr=( ${ICE[subscribe]}(DNms-$(( EPOCHSECONDS -\n                 ZINIT[fts-${ICE[subscribe]}] ))) ); (( \\${#fts_arr} ))\" && \\\n             { ZINIT[fts-${ICE[subscribe]}]=\"$EPOCHSECONDS\"; ___s=${+ICE[once]}; } || \\\n             (( 0 ))\n        }\n    then\n        ___action=\"${(M)ICE[subscribe]#\\!}load\"\n    fi\n\n    if [[ $___action = *load ]]; then\n        if [[ $___tpe = p* ]]; then\n            .zinit-load \"${(@)=___id}\" \"\" \"$___mode\" ${___tpe#p}; (( ___retval += $? ))\n        elif [[ $___tpe = s* ]]; then\n            .zinit-load-snippet $___opt \"$___id\" \"\" ${___tpe#s}; (( ___retval += $? ))\n        fi\n        if [[ $___tpe = p1 || $___tpe = s1 ]]; then\n            (( ${+functions[.zinit-service]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n            zpty -b \"${___id//\\//:} / ${ICE[service]}\" '.zinit-service '\"${(M)___tpe#?}\"' \"$___mode\" \"$___id\"'\n        fi\n        (( ${+ICE[silent]} == 0 && ${+ICE[lucid]} == 0 && ___retval == 0 )) && zle && zle -M \"Loaded $___id\"\n    elif [[ $___action = *remove ]]; then\n        (( ${+functions[.zinit-confirm]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n        [[ $___tpe = p ]] && .zinit-unload \"$___id_as\" \"\" -q\n        (( ${+ICE[silent]} == 0 && ${+ICE[lucid]} == 0 && ___retval == 0 )) && zle && zle -M \"Unloaded $___id_as\"\n    fi\n\n    [[ ${REPLY::=$___action} = \\!* ]] && zle && zle .reset-prompt\n\n    return ___s\n} # ]]]\n# FUNCTION: .zinit-submit-turbo [[[\n# If `zinit load`, `zinit light` or `zinit snippet`  will be\n# preceded with 'wait', 'load', 'unload' or 'on-update-of'/'subscribe'\n# ice-mods then the plugin or snipped is to be loaded in turbo-mode,\n# and this function adds it to internal data structures. @zinit-scheduler uses the data to\n# create load or unload tasks.\n.zinit-submit-turbo() {\n    local tpe=\"$1\" mode=\"$2\" opt_uspl2=\"$3\" opt_plugin=\"$4\"\n\n    ICE[wait]=\"${ICE[wait]%%.[0-9]##}\"\n    ZINIT[WAIT_IDX]=$(( ${ZINIT[WAIT_IDX]:-0} + 1 ))\n    ZINIT[WAIT_ICE_${ZINIT[WAIT_IDX]}]=\"${(j: :)${(qkv)ICE[@]}}\"\n    ZINIT[fts-${ICE[subscribe]}]=\"${ICE[subscribe]:+$EPOCHSECONDS}\"\n\n    [[ $tpe = s* ]] && \\\n        local id=\"${${opt_plugin:+$opt_plugin}:-$opt_uspl2}\" || \\\n        local id=\"${${opt_plugin:+$opt_uspl2${${opt_uspl2:#%*}:+/}$opt_plugin}:-$opt_uspl2}\"\n\n    if [[ ${${ICE[wait]}%%[^0-9]([^0-9]|)([^0-9]|)([^0-9]|)} = (\\!|.|)<-> ]]; then\n        ZINIT_TASKS+=( \"$EPOCHSECONDS+${${ICE[wait]#(\\!|.)}%%[^0-9]([^0-9]|)([^0-9]|)([^0-9]|)}+${${${(M)ICE[wait]%a}:+1}:-${${${(M)ICE[wait]%b}:+2}:-${${${(M)ICE[wait]%c}:+3}:-1}}} $tpe ${ZINIT[WAIT_IDX]} ${mode:-_} ${(q)id} ${opt_plugin:+${(q)opt_uspl2}}\" )\n    elif [[ -n ${ICE[wait]}${ICE[load]}${ICE[unload]}${ICE[subscribe]} ]]; then\n        ZINIT_TASKS+=( \"${${ICE[wait]:+0}:-1}+0+1 $tpe ${ZINIT[WAIT_IDX]} ${mode:-_} ${(q)id} ${opt_plugin:+${(q)opt_uspl2}}\" )\n    fi\n} # ]]]\n# FUNCTION: -zinit_scheduler_add_sh [[[\n# Copies task into ZINIT_RUN array, called when a task timeouts.\n# A small function ran from pattern in /-substitution as a math\n# function.\n-zinit_scheduler_add_sh() {\n    local idx=\"$1\" in_wait=\"$___ar2\" in_abc=\"$___ar3\" ver_wait=\"$___ar4\" ver_abc=\"$___ar5\"\n    if [[ ( $in_wait = $ver_wait || $in_wait -ge 4 ) && $in_abc = $ver_abc ]]; then\n        ZINIT_RUN+=( \"${ZINIT_TASKS[$idx]}\" )\n        return 1\n    else\n        return idx\n    fi\n} # ]]]\n# FUNCTION: @zinit-scheduler [[[\n# Searches for timeout tasks, executes them. Theres an array of tasks\n# waiting for execution, this scheduler manages them, detects which ones\n# should be run at current moment, decides to remove (or not) them from\n# the array after execution.\n#\n# $1 - if \"following\", then it is non-first (second and more)\n#      invocation of the scheduler; this results in chain of 'sched'\n#      invocations that results in repetitive @zinit-scheduler activity.\n#\n#      if \"burst\", then all tasks are marked timeout and executed one\n#      by one; this is handy if e.g. a docker image starts up and\n#      needs to install all turbo-mode plugins without any hesitation\n#      (delay), i.e. \"burst\" allows to run package installations from\n#      script, not from prompt.\n@zinit-scheduler() {\n    integer ___ret=\"${${ZINIT[lro-data]%:*}##*:}\"\n    # lro stands for lastarg-retval-option.\n    [[ $1 = following ]] && sched +1 'ZINIT[lro-data]=\"$_:$?:${options[printexitvalue]}\"; @zinit-scheduler following \"${ZINIT[lro-data]%:*:*}\"'\n    [[ -n $1 && $1 != (following*|burst) ]] && { local THEFD=\"$1\"; zle -F \"$THEFD\"; exec {THEFD}<&-; }\n    [[ $1 = burst ]] && local -h EPOCHSECONDS=$(( EPOCHSECONDS+10000 ))\n    ZINIT[START_TIME]=\"${ZINIT[START_TIME]:-$EPOCHREALTIME}\"\n\n    integer ___t=EPOCHSECONDS ___i correct\n    local -a match mbegin mend reply\n    local MATCH REPLY AFD; integer MBEGIN MEND\n\n    [[ -o ksharrays ]] && correct=1\n\n    if [[ -n $1 ]] {\n        if [[ ${#ZINIT_RUN} -le 1 || $1 = following ]]  {\n            () {\n                builtin emulate -L zsh ${=${options[xtrace]:#off}:+-o xtrace}\n                builtin setopt extendedglob\n                # Example entry:\n                # 1531252764+2+1 p 18 light zdharma/zsh-diff-so-fancy\n                #\n                # This either doesnt change ZINIT_TASKS entry - when\n                # ___i is used in the ternary expression, or replaces\n                # an entry with \"<no-data>\", i.e. ZINIT_TASKS[1] entry.\n                integer ___idx1 ___idx2\n                local ___ar2 ___ar3 ___ar4 ___ar5\n                for (( ___idx1 = 0; ___idx1 <= 4; ___idx1 ++ )) {\n                    for (( ___idx2 = 1; ___idx2 <= (___idx >= 4 ? 1 : 3); ___idx2 ++ )) {\n                        # The following substitution could be just (well, 'just'..) this:\n                        #\n                        # ZINIT_TASKS=( ${ZINIT_TASKS[@]/(#b)([0-9]##)+([0-9]##)+([1-3])(*)/\n                        # ${ZINIT_TASKS[$(( (${match[1]}+${match[2]}) <= $___t ?\n                        # zinit_scheduler_add(___i++, ${match[2]},\n                        # ${(M)match[3]%[1-3]}, ___idx1, ___idx2) : ___i++ ))]}} )\n                        #\n                        # However, there's a severe bug in Zsh <= 5.3.1 - use of the period\n                        # (,) is impossible inside ${..//$arr[$(( ... ))]}.\n                        ___i=2\n\n                        ZINIT_TASKS=( ${ZINIT_TASKS[@]/(#b)([0-9]##)+([0-9]##)+([1-3])(*)/${ZINIT_TASKS[\n                        $(( (___ar2=${match[2]}+1) ? (\n                            (___ar3=${(M)match[3]%[1-3]}) ? (\n                            (___ar4=___idx1+1) ? (\n                            (___ar5=___idx2) ? (\n                (${match[1]}+${match[2]}) <= $___t ?\n                zinit_scheduler_add(___i++) : ___i++ )\n                            : 1 )\n                            : 1 )\n                            : 1 )\n                            : 1  ))]}} )\n                        ZINIT_TASKS=( \"<no-data>\" ${ZINIT_TASKS[@]:#<no-data>} )\n                    }\n                }\n            }\n        }\n    } else {\n        add-zsh-hook -d -- precmd @zinit-scheduler\n        add-zsh-hook -- chpwd @zinit-scheduler\n        () {\n            builtin emulate -L zsh ${=${options[xtrace]:#off}:+-o xtrace}\n            builtin setopt extendedglob\n            # No \"+\" in this pattern, it will match only \"1531252764\"\n            # in \"1531252764+2\" and replace it with current time.\n            ZINIT_TASKS=( ${ZINIT_TASKS[@]/(#b)([0-9]##)(*)/$(( ${match[1]} <= 1 ? ${match[1]} : ___t ))${match[2]}} )\n        }\n        # Theres a bug in Zsh: first sched call would not be issued\n        # until a key-press, if \"sched +1 ...\" would be called inside\n        # zle -F handler. So its done here, in precmd-handle code.\n        sched +1 'ZINIT[lro-data]=\"$_:$?:${options[printexitvalue]}\"; @zinit-scheduler following ${ZINIT[lro-data]%:*:*}'\n\n        AFD=13371337 # for older Zsh + noclobber option\n        exec {AFD}< <(LANG=C command sleep 0.002; builtin print run;)\n\tcommand true # workaround a Zsh bug, see: https://www.zsh.org/mla/workers/2018/msg00966.html\n        zle -F \"$AFD\" @zinit-scheduler\n    }\n\n    local ___task ___idx=0 ___count=0 ___idx2\n    # All wait'' objects.\n    for ___task ( \"${ZINIT_RUN[@]}\" ) {\n        .zinit-run-task 1 \"${(@z)___task}\" && ZINIT_TASKS+=( \"$___task\" )\n        if [[ $(( ++___idx, ___count += ${${REPLY:+1}:-0} )) -gt 0 && $1 != burst ]] {\n            AFD=13371337 # for older Zsh + noclobber option\n            exec {AFD}< <(LANG=C command sleep 0.0002; builtin print run;)\n            command true\n            # The $? and $_ will be left unchanged automatically by Zsh.\n            zle -F \"$AFD\" @zinit-scheduler\n            break\n        }\n    }\n    # All unload'' objects.\n    for (( ___idx2=1; ___idx2 <= ___idx; ++ ___idx2 )) {\n        .zinit-run-task 2 \"${(@z)ZINIT_RUN[___idx2-correct]}\"\n    }\n    # All load'' & subscribe'' objects.\n    for (( ___idx2=1; ___idx2 <= ___idx; ++ ___idx2 )) {\n        .zinit-run-task 3 \"${(@z)ZINIT_RUN[___idx2-correct]}\"\n    }\n    ZINIT_RUN[1-correct,___idx-correct]=()\n\n    [[ ${ZINIT[lro-data]##*:} = on ]] && return 0 || return ___ret\n} # ]]]\n\n#\n# Exposed functions.\n#\n\n# FUNCTION: zinit [[[\n# Entrypoint function directly exposed to user, consumes subcommands with respective arguments,\n# and completion.\nzinit() {\n    local -A ICE ZINIT_ICE\n    ICE=( \"${(kv)ZINIT_ICES[@]}\" )\n    ZINIT_ICE=( \"${(kv)ICE[@]}\" )\n    ZINIT_ICES=()\n\n    integer ___retval ___retval2 ___correct\n    local -a match mbegin mend\n    local MATCH cmd ___q=\"\\`\" ___q2=\"'\" IFS=$' \\t\\n\\0'; integer MBEGIN MEND\n\n    # An annexs subcommand might use the reply vars.\n    match=( ${ZINIT_EXTS[(I)z-annex subcommand:$1]} )\n    if (( !${#match} )) {\n        local -a reply; local REPLY\n    }\n\n    [[ -o ksharrays ]] && ___correct=1\n\n    local -A ___opt_map OPTS\n    ___opt_map=(\n        -q         opt_-q,--quiet:\"update:[Turn off almost-all messages from the {cmd}update{rst} operation {b-lhi}FOR the objects{rst} which don't have any {b-lhi}new version{rst} available.] *:[Turn off any (or: almost-any) messages from the operation.]\"\n        --quiet    opt_-q,--quiet\n        -v         opt_-v,--verbose:\"Turn on more messages from the operation.\"\n        --verbose  opt_-v,--verbose\n        -r         opt_-r,--reset:\"Reset the repository before updating (or remove the files for single-file snippets and gh-r plugins).\"\n        --reset    opt_-r,--reset\n        -a         opt_-a,--all:\"delete:[Delete {hi}all{rst} plugins and snippets.] update:[Update {b-lhi}all{rst} plugins and snippets.]\"\n        --all      opt_-a,--all\n        -c         opt_-c,--clean:\"Delete {b-lhi}only{rst} the {b-lhi}currently-not loaded{rst} plugins and snippets.\"\n        --clean    opt_-c,--clean\n        -y         opt_-y,--yes:\"Automatically confirm any yes/no prompts.\"\n        --yes      opt_-y,--yes\n        -f         opt_-f,--force:\"Force new download of the snippet file.\"\n        --force    opt_-f,--force\n        -p         opt_-p,--parallel:\"Turn on concurrent, multi-thread update (of all objects).\"\n        --parallel opt_-p,--parallel\n        -s         opt_-s,--snippets:\"snippets:[Update only snippets (i.e.: skip updating plugins).] times:[Show times in seconds instead of milliseconds.]\"\n        --snippets opt_-s,--snippets\n        -L         opt_-l,--plugins:\"Update only plugins (i.e.: skip updating snippets).\"\n        --plugins  opt_-l,--plugins\n        -h         opt_-h,--help:\"Show this help message.\"\n        --help     opt_-h,--help\n        -u         opt_-u,--urge:\"Cause all the hooks like{ehi}:{rst} {ice}atpull{apo}''{rst}, {ice}cp{apo}''{rst}, etc. to execute even when there aren't any new commits {b}/{rst} any new version of the {b}{meta}gh-r{rst} file {b}/{rst} etc.{…} available for download {ehi}{lr}{rst} simulate a non-empty update.\"\n        --urge     opt_-u,--urge\n        -n         opt_-n,--no-pager:\"Disable the use of the pager.\"\n        --no-pager opt_-n,--no-pager\n        -m         opt_-m,--moments:\"Show the {apo}*{b-lhi}moments{apo}*{rst} of object (i.e.: a plugin or snippet) loading time.\"\n        --moments  opt_-m,--moments\n        -b         opt_-b,--bindkeys:\"Load in light mode, however do still track {cmd}bindkey{rst} calls (to allow remapping the keys bound).\"\n        --bindkeys opt_-b,--bindkeys\n        -x         opt_-x,--command:\"Load the snippet as a {cmd}command{rst}, i.e.: add it to {var}\\$PATH{rst} and set {b-lhi}+x{rst} on it.\"\n        --command  opt_-x,--command\n        cdclear       \"--help|--quiet|-h|-q\"\n        cdreplay      \"--help|--quiet|-h|-q\"\n        delete        \"--all|--clean|--help|--quiet|--yes|-a|-c|-h|-q|-y\"\n        env-whitelist \"--help|--verbose|-h|-v\"\n        light         \"--help|-b|-h\"\n        snippet       \"--command|--force|--help|-f|-h|-x\"\n        times         \"--help|-h|-m|-s\"\n        unload        \"--help|--quiet|-h|-q\"\n        update        \"--all|--help|--no-pager|--parallel|--plugins|--quiet|--reset|--snippets|--urge|--verbose|-L|-a|-h|-n|-p|-q|-r|-s|-u|-v\"\n        version       \"\"\n    )\n\n    cmd=\"$1\"\n    if [[ $cmd == (times|unload|env-whitelist|update|snippet|load|light|cdreplay|cdclear) ]]; then\n        if (( $@[(I)-*] || OPTS[opt_-h,--help] )); then\n            .zinit-parse-opts \"$cmd\" \"$@\"\n            if (( OPTS[opt_-h,--help] )); then\n                +zinit-prehelp-usage-message $cmd $___opt_map[$cmd] $@\n                return 1;\n            fi\n        fi\n    fi\n\n    reply=( ${ZINIT_EXTS[(I)z-annex subcommand:*]} )\n\n    [[ -n $1 && $1 != (${~ZINIT[cmds]}|${(~j:|:)reply[@]#z-annex subcommand:}) || $1 = (load|light|snippet) ]] && \\\n    {\n        integer ___error\n        if [[ $1 = (load|light|snippet) ]] {\n            integer  ___is_snippet\n            # Classic syntax -> simulate a call through the for-syntax.\n            () {\n                builtin setopt localoptions extendedglob\n                : ${@[@]//(#b)([ $'\\t']##|(#s))(-b|--command|-f|--force)([ $'\\t']##|(#e))/${OPTS[${match[2]}]::=1}}\n            } \"$@\"\n            builtin set -- \"${@[@]:#(-b|--command|-f|--force)}\"\n            [[ $1 = light && -z ${OPTS[(I)-b]} ]] && ICE[light-mode]=\n            [[ $1 = snippet ]] && ICE[is-snippet]= || ___is_snippet=-1\n            shift\n\n            ZINIT_ICES=( \"${(kv)ICE[@]}\" )\n            ICE=() ZINIT_ICE=()\n            1=\"${1:+@}${1#@}${2:+/$2}\"\n            (( $# > 1 )) && { shift -p $(( $# - 1 )); }\n            [[ -z $1 ]] && {\n               +zi-log \"Argument needed, try: {cmd}help.\"\n               return 1\n            }\n        } else {\n            .zinit-ice \"$@\"\n            ___retval2=$?\n            local ___last_ice=${@[___retval2]}\n            shift ___retval2\n            if [[ $# -gt 0 && $1 != for ]] {\n                +zi-log -n \"{b}{u-warn}ERROR{b-warn}:{rst} Unknown subcommand{ehi}:\" \\\n                        \"{apo}\\`{cmd}$1{apo}\\`{rst} \"\n                +zinit-prehelp-usage-message rst\n                return 1\n            } elif (( $# == 0 )) {\n                ___error=1\n            } else {\n                shift\n            }\n        }\n        integer ___had_wait\n        local ___id ___ehid ___etid ___key\n        local -a ___arr\n        ZINIT[annex-exposed-processed-IDs]=\n        if (( $# )) {\n            local -a ___ices\n            ___ices=( \"${(kv)ZINIT_ICES[@]}\" )\n            ZINIT_ICES=()\n            while (( $# )) {\n                .zinit-ice \"$@\"\n                ___retval2=$?\n                local ___last_ice=${@[___retval2]}\n                shift ___retval2\n                if [[ -n $1 ]] {\n                    ICE=( \"${___ices[@]}\" \"${(kv)ZINIT_ICES[@]}\" )\n                    ZINIT_ICE=( \"${(kv)ICE[@]}\" ) ZINIT_ICES=()\n                    integer ___msgs=${+ICE[debug]}\n                    (( ___msgs )) && +zi-log \"{pre}zinit-main:{faint} Processing {pname}$1{faint}{…}{rst}\"\n\n                    # Delete up to the final space to get the previously-processed ID.\n                    ZINIT[annex-exposed-processed-IDs]+=\"${___id:+ $___id}\"\n\n                    # Strip the ID-qualifier (`@') and GitHub domain from the ID.\n                    ___id=\"${${1#@}%%(///|//|/)}\"\n                    (( ___is_snippet == -1 )) && ___id=\"${___id#https://github.com/}\"\n\n                    # Effective handle-ID – the label under which the object\n                    # will be identified / referred-to by Zinit.\n                    ___ehid=\"${ICE[id-as]:-$___id}\"\n\n                    # Effective remote-ID (i.e.: URL, GitHub username/repo,\n                    # package name, etc.). teleid'' allows \"overriding\" of $1.\n                    # In case of a package using teleid'', the value here\n                    # is being took from the given ices, before disk-ices.\n                    ___etid=\"${ICE[teleid]:-$___id}\"\n\n                    if (( ${+ICE[pack]} )); then\n                        ___had_wait=${+ICE[wait]}\n                        .zinit-load-ices \"$___ehid\"\n                        # wait'' isn't possible via the disk-ices (for\n                        # packages), only via the command's ice-spec.\n                        [[ $___had_wait -eq 0 ]] && unset 'ICE[wait]'\n                    fi\n\n                    [[ ${ICE[id-as]} = (auto|) && ${+ICE[id-as]} == 1 ]] && ICE[id-as]=\"${___etid:t}\"\n\n                    integer  ___is_snippet=${${(M)___is_snippet:#-1}:-0}\n                    () {\n                        builtin setopt localoptions extendedglob\n                        if [[ $___is_snippet -ge 0 && ( -n ${ICE[is-snippet]+1} || $___etid = ((#i)(http(s|)|ftp(s|)):/|(${(~kj.|.)ZINIT_1MAP}))* ) ]] {\n                            ___is_snippet=1\n                        }\n                    } \"$@\"\n\n                    local ___type=${${${(M)___is_snippet:#1}:+snippet}:-plugin}\n                    reply=(\n                        ${(on)ZINIT_EXTS2[(I)zinit hook:before-load-pre <->]}\n                        ${(on)ZINIT_EXTS[(I)z-annex hook:before-load-<-> <->]}\n                        ${(on)ZINIT_EXTS2[(I)zinit hook:before-load-post <->]}\n                    )\n                    for ___key in \"${reply[@]}\"; do\n                        ___arr=( \"${(Q)${(z@)ZINIT_EXTS[$___key]:-$ZINIT_EXTS2[$___key]}[@]}\" )\n                        \"${___arr[5]}\" \"$___type\" \"$___id\" \"${ICE[id_as]}\" \\\n                            \"${(j: :)${(q)@[2,-1]}}\" \"${(j: :)${(qkv)___ices[@]}}\" \\\n                            \"${${___key##(zinit|z-annex) hook:}%% <->}\" load\n                        ___retval2=$?\n                        if (( ___retval2 )) {\n                            # An error is actually only an odd return code.\n                            ___retval+=$(( ___retval2 & 1 ? ___retval2 : 0 ))\n                            (( ___retval2 & 1 && $# )) && shift\n\n                            # Override $@?\n                            if (( ___retval2 & 2 )) {\n                                local -a ___args\n                                ___args=( \"${(@Q)${(@z)ZINIT[annex-before-load:new-@]}}\" )\n                                builtin set -- \"${___args[@]}\"\n                            }\n\n                            # Override $___ices?\n                            if (( ___retval2 & 4 )) {\n                                local -a ___new_ices\n                                ___new_ices=( \"${(Q@)${(@z)ZINIT[annex-before-load:new-global-ices]}}\" )\n                                (( 0 == ${#___new_ices} % 2 )) && \\\n                                    ___ices=( \"${___new_ices[@]}\" ) || \\\n                                        { [[ ${ZINIT[MUTE_WARNINGS]} != (1|true|on|yes) ]] && \\\n                                            +zi-log \"{u-warn}Warning{b-warn}:{msg} Bad new-ices returned\" \\\n                                                \"from the annex{ehi}:{rst} {annex}${___arr[3]}{msg},\" \\\n                                                \"please file an issue report at:{url}\" \\\n                                    \"https://github.com/zdharma-continuum/${___arr[3]}/issues/new{msg}.{rst}\"\n                                            ___ices=(  ) ___retval+=7\n                                        }\n                            }\n                            continue 2\n                        }\n                    done\n                    integer ___action_load=0 ___turbo=0\n                    if [[ -n ${(M)${+ICE[wait]}:#1}${ICE[load]}${ICE[unload]}${ICE[service]}${ICE[subscribe]} ]] {\n                        ___turbo=1\n                    }\n\n                    if [[ -n ${ICE[trigger-load]} || \\\n                          ( ${+ICE[wait]} == 1 &&\n                              ${ICE[wait]} = (\\!|)(<->(a|b|c|)|) )\n                       ]] && (( !ZINIT[OPTIMIZE_OUT_DISK_ACCESSES]\n                    )) {\n                        if (( ___is_snippet > 0 )) {\n                            .zinit-get-object-path snippet $___ehid\n                        } else {\n                            .zinit-get-object-path plugin $___ehid\n                        }\n                        (( $? )) && [[ ${zsh_eval_context[1]} = file ]] && { ___action_load=1; }\n                        local ___object_path=\"$REPLY\"\n                    } elif (( ! ___turbo )) {\n                        ___action_load=1\n                        reply=( 1 )\n                    } else {\n                        reply=( 1 )\n                    }\n\n                    if [[ ${reply[-1]} -eq 1 && -n ${ICE[trigger-load]} ]] {\n                        () {\n                            builtin setopt localoptions extendedglob\n                            local ___mode\n                            (( ___is_snippet > 0 )) && ___mode=snippet || ___mode=\"${${${ICE[light-mode]+light}}:-load}\"\n                            for MATCH ( ${(s.;.)ICE[trigger-load]} ) {\n                                eval \"${MATCH#!}() {\n                                    ${${(M)MATCH#!}:+unset -f ${MATCH#!}}\n                                    local a b; local -a ices\n                                    # The wait'' ice is filtered-out.\n                                    for a b ( ${(qqkv@)${(kv@)ICE[(I)^(trigger-load|wait|light-mode)]}} ) {\n                                        ices+=( \\\"\\$a\\$b\\\" )\n                                    }\n                                    zinit ice \\${ices[@]}; zinit $___mode ${(qqq)___id}\n                                    ${${(M)MATCH#!}:+# Forward the call\n                                    eval ${MATCH#!} \\$@}\n                                }\"\n                            }\n                        } \"$@\"\n                        ___retval+=$?\n                        (( $# )) && shift\n                        continue\n                    }\n\n                    if (( ${+ICE[if]} )) {\n                        eval \"${ICE[if]}\" || { (( $# )) && shift; continue; };\n                    }\n                    for REPLY ( ${(s.;.)ICE[has]} ) {\n                        (( ${+commands[$REPLY]} )) || \\\n                            { (( $# )) && shift; continue 2; }\n                    }\n\n                    integer ___had_cloneonly=0\n                    ICE[wait]=\"${${(M)${+ICE[wait]}:#1}:+${(M)ICE[wait]#!}${${ICE[wait]#!}:-0}}\"\n                    if (( ___action_load || !ZINIT[HAVE_SCHEDULER] )) {\n                        if (( ___turbo && ZINIT[HAVE_SCHEDULER] )) {\n                            ___had_cloneonly=${+ICE[cloneonly]}\n                            ICE[cloneonly]=\"\"\n                        }\n\n                        (( ___is_snippet )) && \\\n                            local ___opt=\"${(k)OPTS[*]}\" || \\\n                            local ___opt=\"${${ICE[light-mode]+light}:-${OPTS[(I)-b]:+light-b}}\"\n\n                        .zinit-load-object ${${${(M)___is_snippet:#1}:+snippet}:-plugin} $___id $___opt\n                        integer ___last_retval=$?\n                        ___retval+=___last_retval\n\n                        if (( ___turbo && !___had_cloneonly && ZINIT[HAVE_SCHEDULER] )) {\n                            command rm -f $___object_path/._zinit/cloneonly\n                            unset 'ICE[cloneonly]'\n                        }\n                    }\n                    if (( ___turbo && ZINIT[HAVE_SCHEDULER] && 0 == ___last_retval )) {\n                        ICE[wait]=\"${ICE[wait]:-${ICE[service]:+0}}\"\n                        if (( ___is_snippet > 0 )); then\n                            ZINIT_SICE[$___ehid]=\n                            .zinit-submit-turbo s${ICE[service]:+1} \"\" \\\n                                \"$___id\" \"${(k)OPTS[*]}\"\n                        else\n                            ZINIT_SICE[$___ehid]=\n                            .zinit-submit-turbo p${ICE[service]:+1} \\\n                                \"${${${ICE[light-mode]+light}}:-load}\" \\\n                                \"$___id\" \"\"\n                        fi\n                        ___retval+=$?\n                    }\n                } else {\n                    ___error=1\n                }\n                (( $# )) && shift\n                ___is_snippet=0\n            }\n        } else {\n            ___error=1\n        }\n\n        if (( ___error )) {\n            () {\n                builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}\n                +zi-log -n \"{u-warn}Error{b-warn}:{rst} No plugin or snippet ID given\"\n                if [[ -n $___last_ice ]] {\n                    +zi-log -n \" (the last recognized ice was: {ice}\"\\\n\"${___last_ice/(#m)(${~ZINIT[ice-list]})/\"{data}$MATCH\"}{apo}''{rst}).{error}\nYou can try to prepend {apo}${___q}{lhi}@{apo}'{error} to the ID if the last ice is in fact a plugin.{rst}\n{note}Note:{rst} The {apo}\\`{ice}ice{apo}\\`{rst} subcommand is now again required if not using the for-syntax\"\n                }\n                +zi-log \".\"\n            }\n            return 2\n       } elif (( ! $# )) {\n           return ___retval\n       }\n    }\n\n    case \"$1\" in\n       (ice)\n           shift\n           .zinit-ice \"$@\"\n           ;;\n       (cdreplay)\n           .zinit-compdef-replay \"$2\"; ___retval=$?\n           ;;\n       (cdclear)\n           .zinit-compdef-clear \"$2\"\n           ;;\n       ((add-|)fpath)\n           .zinit-add-fpath \"${@[2-correct,-1]}\"\n           ;;\n       (run)\n           .zinit-run \"${@[2-correct,-1]}\"\n           ;;\n       (man)\n           man \"${ZINIT[BIN_DIR]}/doc/zinit.1\"\n           ;;\n       (env-whitelist)\n            shift\n            .zinit-parse-opts env-whitelist \"$@\"\n            builtin set -- \"${reply[@]}\"\n\n            if (( $# == 0 )) {\n                ZINIT[ENV-WHITELIST]=\n                (( OPTS[opt_-v,--verbose] )) && +zi-log \"{msg2}Cleared the parameter whitelist.{rst}\"\n            } else {\n                ZINIT[ENV-WHITELIST]+=\"${(j: :)${(q-kv)@}} \"\n                local ___sep=\"$ZINIT[col-msg2], $ZINIT[col-data2]\"\n                (( OPTS[opt_-v,--verbose] )) && +zi-log \"{msg2}Extended the parameter whitelist with: {data2}${(pj:$___sep:)@}{msg2}.{rst}\"\n            }\n            ;;\n       (*)\n           # Check if there is a z-annex registered for the subcommand.\n           reply=( ${ZINIT_EXTS[z-annex subcommand:${(q)1}]} )\n           (( ${#reply} )) && {\n               reply=( \"${(Q)${(z@)reply[1]}[@]}\" )\n               (( ${+functions[${reply[5]}]} )) && \\\n                   { \"${reply[5]}\" \"$@\"; return $?; } || \\\n                   { +zi-log \"({error}Couldn't find the subcommand-handler \\`{obj}${reply[5]}{error}' of the z-annex \\`{file}${reply[3]}{error}')\"; return 1; }\n           }\n           (( ${+functions[.zinit-confirm]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n           case \"$1\" in\n                (zstatus)\n                    .zinit-show-zstatus\n                    ;;\n                (delete)\n                    shift\n                    .zinit-delete \"$@\"\n                    ;;\n                (times)\n                    .zinit-show-times \"${@[2-correct,-1]}\"\n                    ;;\n                (self-update)\n                    .zinit-self-update\n                    ;;\n                (unload)\n                    (( ${+functions[.zinit-unload]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n                    if [[ -z $2 && -z $3 ]]; then\n                        builtin print \"Argument needed, try: help\"; ___retval=1\n                    else\n                        [[ $2 = -q ]] && { 5=-q; shift; }\n                        # Unload given plugin. Cloned directory remains intact\n                        # so as are completions.\n                        .zinit-unload \"${2%%(///|//|/)}\" \"${${3:#-q}%%(///|//|/)}\" \"${${(M)4:#-q}:-${(M)3:#-q}}\"; ___retval=$?\n                    fi\n                    ;;\n                 (bindkeys)\n                    .zinit-list-bindkeys\n                    ;;\n                 (update)\n                    if (( ${+ICE[if]} )) {\n                        eval \"${ICE[if]}\" || return 1;\n                    }\n                    for REPLY ( ${(s.;.)ICE[has]} ) {\n                        (( ${+commands[$REPLY]} )) || return 1\n                    }\n                    shift\n                    .zinit-parse-opts update \"$@\"\n                    builtin set -- \"${reply[@]}\"\n                    if [[ ${OPTS[opt_-a,--all]} -eq 1 || ${OPTS[opt_-p,--parallel]} -eq 1 || ${OPTS[opt_-s,--snippets]} -eq 1 || ${OPTS[opt_-l,--plugins]} -eq 1 || -z $1$2${ICE[teleid]}${ICE[id-as]} ]]; then\n                        [[ -z $1$2 && $(( OPTS[opt_-a,--all] + OPTS[opt_-p,--parallel] + OPTS[opt_-s,--snippets] + OPTS[opt_-l,--plugins] )) -eq 0 ]] && { builtin print -r -- \"Assuming --all is passed\"; }\n                        (( OPTS[opt_-p,--parallel] )) && OPTS[value]=${1:-15}\n                        .zinit-update-or-status-all update; ___retval=$?\n                    else\n                        local ___key ___id=\"${1%%(///|//|/)}${2:+/}${2%%(///|//|/)}\"\n                        [[ -z ${___id//[[:space:]]/} ]] && ___id=\"${ICE[id-as]:-$ICE[teleid]}\"\n                        .zinit-update-or-status update \"$___id\" \"\"; ___retval=$?\n                    fi\n                    ;;\n                (status)\n                    if [[ $2 = --all || ( -z $2 && -z $3 ) ]]; then\n                        [[ -z $2 ]] && { builtin print -r -- \"Assuming --all is passed\"; }\n                        .zinit-update-or-status-all status; ___retval=$?\n                    else\n                        .zinit-update-or-status status \"${2%%(///|//|/)}\" \"${3%%(///|//|/)}\"; ___retval=$?\n                    fi\n                    ;;\n                (report)\n                    if [[ $2 = --all || ( -z $2 && -z $3 ) ]]; then\n                        [[ -z $2 ]] && { builtin print -r -- \"Assuming --all is passed\"; }\n                        .zinit-show-all-reports\n                    else\n                        .zinit-show-report \"${2%%(///|//|/)}\" \"${3%%(///|//|/)}\"; ___retval=$?\n                    fi\n                    ;;\n                (plugins)\n                    .zinit-list-plugins \"$2\"\n                    ;;\n                (snippets)\n                    .zinit-list-snippets \"$2\"\n                    ;;\n                (completions) # Show installed, enabled or disabled, completions and detect stray and improper ones\n                    .zinit-show-completions \"$2\"\n                    ;;\n                (cclear) # Delete stray and improper completions.\n                    .zinit-clear-completions\n                    ;;\n                (cdisable)\n                    if [[ -z $2 ]]; then\n                        builtin print \"Argument needed, try: help\"; ___retval=1\n                    else\n                        local ___f=\"_${2#_}\"\n                        # Disable completion given by completion function name\n                        # with or without leading _, e.g. cp, _cp.\n                        if .zinit-cdisable \"$___f\"; then\n                            (( ${+functions[.zinit-forget-completion]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n                            .zinit-forget-completion \"$___f\"\n                            +zi-log \"Initializing completion system ({func}compinit{rst}){…}\"\n                            builtin autoload -Uz compinit\n                            compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n                        else\n                            ___retval=1\n                        fi\n                    fi\n                    ;;\n                (cenable)\n                    if [[ -z $2 ]]; then\n                        builtin print \"Argument needed, try: help\"; ___retval=1\n                    else\n                         local ___f=\"_${2#_}\"\n                        # Enable completion given by completion function name\n                        # with or without leading _, e.g. cp, _cp.\n                        if .zinit-cenable \"$___f\"; then\n                            (( ${+functions[.zinit-forget-completion]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n                            .zinit-forget-completion \"$___f\"\n                            +zi-log \"Initializing completion system ({func}compinit{rst}){…}\"\n                            builtin autoload -Uz compinit\n                            compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n                        else\n                            ___retval=1\n                        fi\n                    fi\n                    ;;\n                (creinstall)\n                    (( ${+functions[.zinit-install-completions]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n                    # Installs completions for plugin. Enables them all. It is a reinstallation, thus every obstacle gets overwritten or removed.\n                    [[ $2 = -[qQ] ]] && { 5=$2; shift; }\n                    .zinit-install-completions \"${2%%(///|//|/)}\" \"${3%%(///|//|/)}\" 1 \"${(M)4:#-[qQ]}\"; ___retval=$?\n                    [[ -z ${(M)4:#-[qQ]} ]] && +zi-log \"Initializing completion ({func}compinit{rst}){…}\"\n                    builtin autoload -Uz compinit\n                    compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n                    ;;\n                (cuninstall)\n                    if [[ -z $2 && -z $3 ]]; then\n                        builtin print \"Argument needed, try: help\"; ___retval=1\n                    else\n                        (( ${+functions[.zinit-forget-completion]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n                        # Uninstalls completions for plugin.\n                        .zinit-uninstall-completions \"${2%%(///|//|/)}\" \"${3%%(///|//|/)}\"; ___retval=$?\n                        +zi-log \"Initializing completion ({func}compinit{rst}){…}\"\n                        builtin autoload -Uz compinit\n                        compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n                    fi\n                    ;;\n                (csearch)\n                    .zinit-search-completions\n                    ;;\n                (compinit)\n                    (( ${+functions[.zinit-forget-completion]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-install.zsh\" || return 1\n                    .zinit-compinit; ___retval=$?\n                    ;;\n                (compiled)\n                    .zinit-compiled\n                    ;;\n                (compile|uncompile)\n                    (( ${+functions[.zinit-compile-plugin]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n                    local action=\"$1\" all f help quiet\n                    shift\n                    zparseopts -D -F -K -- {a,-all}=all {h,-help}=help {q,-quiet}=quiet || return\n                    if (( $#help )); then\n                        print \"Usage:\"\n                        print \"  zinit ${0} <options> <plugin>\"\n                        print \" \"\n                        print \"Options:\"\n                        print \"  -a, --all       Checkout the specified branch\"\n                        print \"  -h, --help      Checkout the specified branch\"\n                        print \"  -q, --quiet     Checkout the specified tag or commit\"\n                    fi\n                    if (( $#all )); then\n                        .zinit-compile-uncompile-all ${action}; ___retval=\"${?}\"\n                    else\n                        for f in ${(q+)^@}; do\n                            .zinit-$action-plugin \"${f}\"; (( ___retval += ${?} ))\n                        done\n                    fi\n                    ;;\n                (debug)\n                    shift;\n                    (( ${+functions[+zinit-debug]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-additional.zsh\"\n                    +zinit-debug $@\n                    ;;\n\n                (cdlist)\n                    .zinit-list-compdef-replay\n                    ;;\n                ((c(hanges|d))|create|edit|glance|recall|stress)\n                    .zinit-\"$1\" \"${@[2-correct,-1]%%(///|//|/)}\"; ___retval=$?\n                    ;;\n                (recently)\n                    shift\n                    .zinit-recently \"$@\"; ___retval=$?\n                    ;;\n                (-h|--help|help)\n                    .zinit-help\n                    ;;\n                (version)\n                    zi::version\n                    ;;\n                (srv)\n                    () { setopt localoptions extendedglob warncreateglobal\n                    [[ ! -e ${ZINIT[SERVICES_DIR]}/\"$2\".fifo ]] && { builtin print \"No such service: $2\"; } ||\n                        { [[ $3 = (#i)(next|stop|quit|restart) ]] &&\n                            { builtin print \"${(U)3}\" >>! ${ZINIT[SERVICES_DIR]}/\"$2\".fifo || builtin print \"Service $2 inactive\"; ___retval=1; } ||\n                                { [[ $3 = (#i)start ]] && rm -f ${ZINIT[SERVICES_DIR]}/\"$2\".stop ||\n                                    { builtin print \"Unknown service-command: $3\"; ___retval=1; }\n                                }\n                        }\n                    } \"$@\"\n                    ;;\n                (module)\n                    .zinit-module \"${@[2-correct,-1]}\"; ___retval=$?\n                    ;;\n                 (*)\n                    if [[ -z $1 ]] {\n                       +zi-log -n \"{b}{u-warn}ERROR{b-warn}:{rst} Missing a {cmd}subcommand \"\n                       +zinit-prehelp-usage-message rst\n                    } else {\n                       +zi-log -n \"{b}{u-warn}ERROR{b-warn}:{rst} Unknown subcommand{ehi}:{rst}\" \\\n                               \"{apo}\\`{error}$1{apo}\\`{rst} \"\n                       +zinit-prehelp-usage-message rst\n                    }\n                    ___retval=1\n                    ;;\n             esac\n             ;;\n    esac\n\n    return ___retval\n} # ]]]\n# FUNCTION: zicdreplay [[[\n# A function that can be invoked from within \"atinit\", \"atload\", etc.\n# ice-mod. It works like \"zinit cdreplay\", which cannot be invoked from such hook ices\nzicdreplay() {\n  .zinit-compdef-replay -q\n} # ]]]\n# FUNCTION: zicdclear [[[\n# A wrapper for \"zinit cdclear -q\" which can be called from hook\n# ices like the atinit\"\", atload\"\", etc. ices.\nzicdclear() {\n  .zinit-compdef-clear -q\n} # ]]]\n# FUNCTION: zicompinit [[[\n# A function that can be invoked from within \"atinit\", \"atload\", etc.\n# ice-mod.  It runs \"autoload compinit; compinit\" and respects\n# ZINIT[ZCOMPDUMP_PATH] and ZINIT[COMPINIT_OPTS].\nzicompinit() {\n  autoload -Uz compinit\n  compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n} # ]]]\n# FUNCTION: zicompdef [[[\n# Stores compdef for a replay with \"zicdreplay\" (turbo mode) or\n# with \"zinit cdreplay\" (normal mode). An utility functton of an undefined use case.\nzicompdef() {\n  ZINIT_COMPDEF_REPLAY+=( \"${(j: :)${(q)@}}\" )\n} # ]]]\n# FUNCTION: @autoload [[[\n@autoload() {\n    :zinit-tmp-subst-autoload -Uz \\\n      ${(s: :)${${(j: :)${@#\\!}}//(#b)((*)(->|=>|→)(*)|(*))/${match[2]:+$match[2] \\\n      -S $match[4]}${match[5]:+${match[5]} \\\n      -S ${match[5]}}}} \\\n      ${${${(@M)${@#\\!}:#*(->|=>|→)*}}:+-C} \\\n      ${${@#\\!}:+-C}\n} # ]]]\n\n#\n# Compatibility functions\n#\n\n# FUNCTION: zplugin [[[\nzplugin() {\n  zinit \"$@\"\n} # ]]]\n# FUNCTION: zpcdreplay [[[\nzpcdreplay() {\n  .zinit-compdef-replay -q\n} # ]]]\n# FUNCTION: zpcdclear [[[\nzpcdclear() {\n  .zinit-compdef-clear -q\n} # ]]]\n# FUNCTION: zpcompinit [[[\nzpcompinit() {\n  autoload -Uz compinit\n  compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} \"${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}\"\n} # ]]]\n# FUNCTION: zpcompdef [[[\nzpcompdef() {\n  ZINIT_COMPDEF_REPLAY+=( \"${(j: :)${(q)@}}\" )\n} # ]]]\n\n#\n# Source-executed code.\n#\n\n(( ZINIT[ALIASES_OPT] )) && builtin setopt aliases\n(( ZINIT[SOURCED] ++ )) && return\n\nautoload add-zsh-hook\nif { zmodload zsh/datetime } {\n    add-zsh-hook -- precmd @zinit-scheduler  # zsh/datetime required for wait/load/unload ice-mods\n    ZINIT[HAVE_SCHEDULER]=1\n}\nfunctions -M -- zinit_scheduler_add 1 1 -zinit_scheduler_add_sh 2>/dev/null\nzmodload zsh/zpty zsh/system 2>/dev/null\nzmodload -F zsh/stat b:zstat 2>/dev/null && ZINIT[HAVE_ZSTAT]=1\n\n# code [[[\nif [[ -z $ZINIT[NO_ALIASES] ]]; then\n    builtin alias zpl=zinit zplg=zinit zi=zinit zini=zinit\nfi\n\n.zinit-prepare-home\n\n# Remember source timestamps for the automatic-reload feature.\ntypeset -g ZINIT_TMP\nfor ZINIT_TMP ( \"\" -side -install -autoload ) {\n    .zinit-get-mtime-into \"${ZINIT[BIN_DIR]}/zinit$ZINIT_TMP.zsh\" \"ZINIT[mtime$ZINIT_TMP]\"\n}\n\n# Simulate existence of _local/zinit plugin (enables cuninstall of related completions)\nZINIT_REGISTERED_PLUGINS=( _local/zinit \"${(u)ZINIT_REGISTERED_PLUGINS[@]:#_local/zinit}\" )\nZINIT[STATES___local/zinit]=1\n\n# inform prezto that the compdef function is available.\nzstyle ':prezto:module:completion' loaded 1\n\n# Colorize completions for commands unload, report, creinstall, cuninstall.\nzstyle ':completion:*:zinit:argument-rest:plugins' list-colors '=(#b)(*)/(*)==1;35=1;33'\nzstyle ':completion:*:zinit:argument-rest:plugins' matcher 'r:|=** l:|=*'\nzstyle ':completion:*:*:zinit:*' group-name \"\"\n# ]]]\n\n# module recompilation for the project rename. [[[\nif [[ -e ${${ZINIT[BIN_DIR]}}/zmodules/Src/zdharma/zplugin.so ]] {\n    if [[ ! -f ${${ZINIT[BIN_DIR]}}/zmodules/COMPILED_AT || ( ${${ZINIT[BIN_DIR]}}/zmodules/COMPILED_AT -ot ${${ZINIT[BIN_DIR]}}/zmodules/RECOMPILE_REQUEST ) ]] {\n        # Don't trust access times and verify hard stored values.\n        [[ -e ${${ZINIT[BIN_DIR]}}/module/COMPILED_AT ]] && local compiled_at_ts=\"$(<${${ZINIT[BIN_DIR]}}/module/COMPILED_AT)\"\n        [[ -e ${${ZINIT[BIN_DIR]}}/module/RECOMPILE_REQUEST ]] && local recompile_request_ts=\"$(<${${ZINIT[BIN_DIR]}}/module/RECOMPILE_REQUEST)\"\n\n        if [[ ${recompile_request_ts:-1} -gt ${compiled_at_ts:-0} ]] {\n            +zi-log \"{u-warn}WARNING{b-warn}:{rst}{msg} A {lhi}recompilation{rst}\" \\\n                \"of the Zinit module has been requested… {hi}Building{rst}…\"\n            (( ${+functions[.zinit-confirm]} )) || builtin source \"${ZINIT[BIN_DIR]}/zinit-autoload.zsh\" || return 1\n            command make -C \"${ZINIT[BIN_DIR]}/zmodules\" distclean &>/dev/null\n            .zinit-module build &>/dev/null\n            if command make -C \"${ZINIT[BIN_DIR]}/zmodules\" &>/dev/null; then\n                +zi-log \"{ok}Build successful!{rst}\"\n            else\n                builtin print -r -- \"${ZINIT[col-error]}Compilation failed.${ZINIT[col-rst]}\" \\\n                     \"${ZINIT[col-pre]}You can enter the following command:${ZINIT[col-rst]}\" \\\n                     'make -C \"${ZINIT[BIN_DIR]}/zmodules' \\\n                     \"${ZINIT[col-pre]}to see the error messages and e.g.: report an issue\" \\\n                     \"at GitHub${ZINIT[col-rst]}\"\n            fi\n\n            command date '+%s' >! \"${ZINIT[BIN_DIR]}/zmodules/COMPILED_AT\"\n        }\n    }\n} # ]]]\n\n# !atpull-pre\n@zinit-register-hook \"-r/--reset\" hook:e-\\!atpull-pre ∞zinit-reset-hook\n# !atpull-post\n@zinit-register-hook \"ICE[reset]\" hook:e-\\!atpull-post ∞zinit-reset-hook\n@zinit-register-hook \"atpull'!'\" hook:e-\\!atpull-post ∞zinit-atpull-e-hook\n\n# e-!atpull-pre.\n@zinit-register-hook \"make'!!'\" hook:no-e-\\!atpull-pre ∞zinit-make-ee-hook\n@zinit-register-hook \"extract\" hook:e-\\!atpull-pre ∞zinit-extract-hook\n@zinit-register-hook \"mv''\" hook:no-e-\\!atpull-pre ∞zinit-mv-hook\n@zinit-register-hook \"cp''\" hook:no-e-\\!atpull-pre ∞zinit-cp-hook\n@zinit-register-hook \"compile-plugin\" hook:no-e-\\!atpull-pre ∞zinit-compile-plugin-hook\n# no-e-!atpull-post.\n@zinit-register-hook \"configure'!'\" hook:no-e-\\!atpull-post ∞zinit-configure-e-hook\n@zinit-register-hook \"make'!'\" hook:no-e-\\!atpull-post ∞zinit-make-e-hook\n@zinit-register-hook \"configure''\" hook:no-e-\\!atpull-post ∞zinit-configure-hook\n@zinit-register-hook \"atpull\" hook:no-e-\\!atpull-post ∞zinit-atpull-hook\n@zinit-register-hook \"make''\" hook:no-e-\\!atpull-post ∞zinit-make-hook\n@zinit-register-hook \"cmake''\" hook:no-e-\\!atpull-post +zinit-cmake-hook\n# atpull-post.\n@zinit-register-hook \"compile-plugin\" hook:atpull-post ∞zinit-compile-plugin-hook\n@zinit-register-hook \"ps-on-update\" hook:%atpull-post ∞zinit-ps-on-update-hook\n\n# !atclone-pre.\n@zinit-register-hook \"make'!!'\" hook:\\!atclone-pre ∞zinit-make-ee-hook\n@zinit-register-hook \"extract\" hook:\\!atclone-pre ∞zinit-extract-hook\n@zinit-register-hook \"mv''\" hook:\\!atclone-pre ∞zinit-mv-hook\n@zinit-register-hook \"cp''\" hook:\\!atclone-pre ∞zinit-cp-hook\n@zinit-register-hook \"compile-plugin\" hook:\\!atclone-pre ∞zinit-compile-plugin-hook\n# !atclone-post.\n@zinit-register-hook \"configure'!'\" hook:\\!atclone-post ∞zinit-configure-e-hook\n@zinit-register-hook \"make'!'\" hook:\\!atclone-post ∞zinit-make-e-hook\n@zinit-register-hook \"configure''\" hook:\\!atclone-post ∞zinit-configure-hook\n@zinit-register-hook \"atclone\" hook:\\!atclone-post ∞zinit-atclone-hook\n@zinit-register-hook \"make''\" hook:\\!atclone-post ∞zinit-make-hook\n@zinit-register-hook \"cmake''\" hook:\\!atclone-post +zinit-cmake-hook\n# atclone-post.\n@zinit-register-hook \"compile-plugin\" hook:atclone-post ∞zinit-compile-plugin-hook\n\n# create so that for sure no warncreateglobal warning is issued\ntypeset -g REPLY\n\n# a searchable menu of tags for current directory\nzinit null light-mode autoload'zi-browse-symbol' for %$ZINIT[BIN_DIR]\nzle -N zi-browse-symbol\nzle -N zi-browse-symbol-backwards zi-browse-symbol\nzle -N zi-browse-symbol-pbackwards zi-browse-symbol\nzle -N zi-browse-symbol-pforwards zi-browse-symbol\nzstyle -s ':zinit:browse-symbol' key ZINIT_TMP || ZINIT_TMP='\\eQ'\n[[ -n $ZINIT_TMP ]] && bindkey $ZINIT_TMP zi-browse-symbol\n\n# Local Variables:\n# mode: Shell-Script\n# sh-indentation: 2\n# indent-tabs-mode: nil\n# sh-basic-offset: 2\n# End:\n# vim: ft=zsh sw=2 ts=2 et foldmarker=[[[,]]] foldmethod=marker\n"
        }
      ]
    }
  ]
}