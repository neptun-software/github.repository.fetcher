{
  "metadata": {
    "timestamp": 1736568690422,
    "page": 776,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eth-p/bat-extras",
      "stars": 1256,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1650390625,
          "content": "# System\n.DS_Store\n._*\n\n# Developer\n.idea\n.vscode\n*.iml\n\n# Project\n/.circleci/.config.yml\n/bin\n/man\n\n# Side-Effects\n/test/data/.config/fish\n/test/data/.local/share/fish\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.080078125,
          "content": "[submodule \"best\"]\npath = .test-framework\nurl = https://github.com/eth-p/best.git\n"
        },
        {
          "name": ".test-framework",
          "type": "commit",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.0751953125,
          "content": "# Contributing\nAre you interested in contributing to `bat-extras`? That's great!  \nAll we ask is that you keep a few things in mind:\n\n\n## DOs:\n\n- Use Bashisms whenever possible (unless it would make the code unclear). These are scripts written specifically for the `bash` shell, and they should take advantage of built-in functionality instead of spawning external processes.\n- Use `awk` or `sed` when it would be faster or less verbose than only using `bash` builtins.\n\n## DON'Ts:\n\n- Include crude or offensive language inside issues or scripts.\n- Use GNU/BSD-only features in external programs like `sed` or `awk`.\n- Use `bash` features that require a Bash version newer than 3.2. \n- Use `head` in a pipe. See [Issue #19](https://github.com/eth-p/bat-extras/issues/19) for more details.\n- Use any external program that isn't likely to come installed by default (e.g. avoid `perl` and `python`).\n- Automatically reformat scripts unless it's a pull request specifically intended for reformatting. The formatting style that we use differs from what `shfmt` and other shell script formatters will emit.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.021484375,
          "content": "Copyright 2019 eth-p\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.6025390625,
          "content": "# bat-extras\n\nBash scripts that integrate [bat](https://github.com/sharkdp/bat) with various command line tools.\n\n&nbsp;\n\n## Scripts\n\n### [`batgrep`](doc/batgrep.md)\nQuickly search through and highlight files using [ripgrep](https://github.com/burntsushi/ripgrep).\n<u>Requirements:</u> `ripgrep`\n\n\n\n### [`batman`](doc/batman.md)\n\nRead system manual pages (`man`) using `bat` as the manual page formatter.\n\n\n\n### [`batpipe`](doc/batpipe.md)\n\nA `less` (and soon `bat`) preprocessor for viewing more types of files in the terminal.\n\n\n\n### [`batwatch`](doc/batwatch.md)\n\nWatch for changes in one or more files, and print them with `bat`.\n<u>Requirements:</u> `entr` (optional)\n\n\n\n### [`batdiff`](doc/batdiff.md)\nDiff a file against the current git index, or display the diff between two files.\n<u>Requirements:</u> `bat`, `delta` (optional)\n\n\n\n### [`prettybat`](doc/prettybat.md)\n\nPretty-print source code and highlight it with `bat`.\n<u>Requirements:</u> (see doc/prettybat.md)\n\n&nbsp;\n\n## Installation via Package Manager\n\n### Homebrew\n\nAll of the `bat-extras` scripts can be installed with `brew install bat-extras`.\n\nIf you would prefer to only install the specific scripts you need, you can use the `eth-p/software` tap to install individual scripts: `brew install eth-p/software/bat-extras-[SCRIPT]`\n\n\n### MacPorts\n\nThe `bat-extras` scripts can also be installed via [MacPorts](https://www.macports.org) on macOS:\n\n```bash\nsudo port install bat-extras\n```\n\nPort info [here](https://ports.macports.org/port/bat-extras/).\n\n### Pacman \n\n`bat-extras` is [officially available](https://archlinux.org/packages/extra/any/bat-extras/) on the Arch extra repository!\n\nIf you have the extra repository enabled, you can install `bat-extras` by running:\n\n```bash\npacman -S bat-extras\n```\n\n### Gentoo\n`bat-extras` is available on **Gentoo's Guru Overlay** as `sys-apps/bat-extras`.\n\nTo install, first make sure you've added the [Gentoo Guru Overlay](https://wiki.gentoo.org/wiki/Project:GURU) to your local repositories, then emerge accordingly...\n\n```bash\nemerge sys-apps/bat-extras\n```\n\n### Fedora (Unofficial)\n`bat-extras` is available in an unofficial Fedora Copr\n[repository](https://copr.fedorainfracloud.org/coprs/awood/bat-extras/).\n**Note**: this package does not contain `prettybat` since `prettier` is not yet\npackaged for Fedora.\n\nInstall the Copr plugin, enable the repository, and then install the package\nby running:\n\n```bash\ndnf install dnf-plugins-core \ndnf copr enable awood/bat-extras\ndnf install bat-extras\n```\n\n&nbsp;\n\n## Installation\n\n[![Test](https://github.com/eth-p/bat-extras/actions/workflows/test.yaml/badge.svg)](https://github.com/eth-p/bat-extras/actions/workflows/test.yaml)\n\nThe scripts in this repository are designed to run as-is, provided that they aren't moved around.\nThis means that you're free to just symlink `src/[script].sh` to your local bin folder.\n\nIf you would rather have *faster*, self-contained scripts that you can place and run anywhere, you can use the `build.sh` script to create (and optionally install) them.\n\n&nbsp;\n\n**Building:**\n\n```bash\n./build.sh [OPTIONS...]\n```\n\nThis will combine and preprocess each script under the `src` directory, and create corresponding self-contained scripts in the `bin` folder. Any library scripts that are sourced using `source \"${LIB}/[NAME].sh\"` will be embedded automatically.\n\n&nbsp;\n\n**Minification:**\n\nThere are three different options for minification:\n\n| Option          | Description                                            |\n| --------------- | ------------------------------------------------------ |\n| `--minify=none` | Nothing will be minified.                              |\n| `--minify=lib`  | Embedded library scripts will be minified. \\[default\\] |\n| `--minify=all`  | Everything will be minified.                           |\n\nThis uses [shfmt](https://github.com/mvdan/sh) to perform minification.\n\n\n&nbsp;\n\n**Installation:**\n\nYou can also specify `--install` and `--prefix=PATH` to have the build script automatically install the scripts for all users on the system. You may need to run the build script as root.\n\nIf you only want to install a single script, you can run the build process and copy the script directly out of the newly-created `bin` folder.\n\n\n\n**Manuals:**\n\nThe build script will automatically generate a `man` page for each of the markdown documentation files.\nThis is a beta feature that uses a non-compliant Markdown \"parser\" written in Bash, and there is no guarantee towards the quality of the generated manual pages. If you do not want to generate manual files, you can provide the `--no-manuals` option to disable manual file generation.\n\n\n\n**Alternate Executable:**\n\nDepending on the distribution, bat may have been renamed to avoid package conflicts.\nIf you wish to use these scripts on a distribution where this is the case, there is an `--alternate-executable=NAME` option which will build the scripts to use an alternate executable name.\n\nYou may also specify alternate executables for `ripgrep`, `delta`, `fzf`, or `git` with `--alternate-executable:PROGRAM NAME` where `PROGRAM` is one the aforementioned programs. Note that doing so may cause verification to fail.\n\n\n**Verification:**\n\nThe build script will attempt to verify the correctness of the \"bin\" scripts by comparing their output with their source counterparts. It is recommended to let it do this, but you can disable verification with the `--no-verify` option.\n\n&nbsp;\n\n## Contributing\n\nIf you would like to contribute to `bat-extras`, please feel free to [open an issue on GitHub](https://github.com/eth-p/bat-extras/issues), or make a pull request. If you do the latter, please keep our [contributing guidelines](./CONTRIBUTING.md) in mind.  \n"
        },
        {
          "name": "banner.txt",
          "type": "blob",
          "size": 0.3369140625,
          "content": "# -----------------------------------------------------------------------------\n# bat-extras | Copyright (C) 2020-2024 eth-p and contributors | MIT License\n#\n# Repository: https://github.com/eth-p/bat-extras\n# Issues:     https://github.com/eth-p/bat-extras/issues\n# -----------------------------------------------------------------------------\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 18.54296875,
          "content": "#!/usr/bin/env bash\n# -----------------------------------------------------------------------------\n# bat-extras | Copyright (C) 2019-2023 eth-p | MIT License\n#\n# Repository: https://github.com/eth-p/bat-extras\n# Issues:     https://github.com/eth-p/bat-extras/issues\n# -----------------------------------------------------------------------------\n\n# -----------------------------------------------------------------------------\n# Build-as-a-Library Functions:\n# -----------------------------------------------------------------------------\n\n# Redefines a function to print a constant string whenever called.\n# This is used for lazy-loading of some getter functions.\n#\n# Arguments:\n#     1  -- The function name.\n#     2  -- The constant string to print.\n#\n# Output:\n#     The constant string.\nbatextras:lazy_done() {\n\teval \"$(printf \"%s() { printf \\\"%%s\\n\\\" %q; }\" \"$1\" \"$2\")\"\n\t\"$1\"\n}\n\n# Checks to see if a function is defined.\n# Arguments:\n#     1  -- The function name.\n#           If prefixed with \"::\", it will use \"batextras:\" as a namespace.\nbatextras:is_function_defined() {\n\tlocal name=\"$1\"\n\tif [[ \"${name:0:2}\" = \"::\" ]]; then name=\"batextras:${name:2}\"; fi\n\t[[ \"$(type -t \"$name\" || echo 'undefined')\" = \"function\" ]]\n\treturn $?\n}\n\n# Prints the path to the project directory.\nif ! batextras:is_function_defined ::get_project_directory; then\n\tbatextras:get_project_directory() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\t}\nfi\n\n# Prints the path to the project source directory.\nif ! batextras:is_function_defined ::get_source_directory; then\n\tbatextras:get_source_directory() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:get_project_directory)/src\"\n\t}\nfi\n\n# Prints the path to the project output directory for executables.\nif ! batextras:is_function_defined ::get_output_bin_directory; then\n\tbatextras:get_output_bin_directory() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:get_project_directory)/bin\"\n\t}\nfi\n\n# Prints the path to the project output directory for manuals.\nif ! batextras:is_function_defined ::get_output_man_directory; then\n\tbatextras:get_output_man_directory() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:get_project_directory)/man\"\n\t}\nfi\n\n# Prints the path to the project directory for documentation.\nif ! batextras:is_function_defined ::get_docs_directory; then\n\tbatextras:get_docs_directory() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:get_project_directory)/doc\"\n\t}\nfi\n\n# Prints the declared version (in version.txt).\nif ! batextras:is_function_defined ::get_version; then\n\tbatextras:get_version() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(cat \"$(batextras:get_project_directory)/version.txt\")\"\n\t}\nfi\n\n# Prints the paths for all source scripts in this project.\n#\n# Output:\n#     One line for each script with the full path to the script.\nif ! batextras:is_function_defined ::get_source_paths; then\n\tbatextras:get_source_paths() {\n\t\tfor file in \"$(batextras:get_source_directory)\"/*.sh; do\n\t\t\tprintf \"%s\\n\" \"$file\"\n\t\t\tfile_bin=\"$(basename -- \"$file\" \".sh\")\"\n\t\tdone\n\t}\nfi\n\n\n# -----------------------------------------------------------------------------\n# Main:\n# Only run everything past this point if the script is not sourced.\n# -----------------------------------------------------------------------------\n(return 0 2>/dev/null) && return 0\n\nHERE=\"$(batextras:get_project_directory)\"\nSRC=\"$(batextras:get_source_directory)\"\nBIN=\"$(batextras:get_output_bin_directory)\"\nMAN=\"$(batextras:get_output_man_directory)\"\nMAN_SRC=\"$(batextras:get_docs_directory)\"\nLIB=\"$HERE/lib\"\n\nsource \"${LIB}/print.sh\"\nsource \"${LIB}/opt.sh\"\nsource \"${LIB}/constants.sh\"\nsource \"${HERE}/mdroff.sh\"\n# -----------------------------------------------------------------------------\nset -eo pipefail\nexec 3>&1\n\n# Runs the next build step.\n#\n# Arguments:\n#     1  -- The build step function name.\n#     @  -- The function arguments.\n#\n# Input:\n#     The unprocessed file data.\n#\n# Output:\n#     The processed file data.\nnext() {\n\t\"$@\"\n\treturn $?\n}\n\n# Prints a build step message.\nsmsg() {\n\tcase \"$2\" in\n\t\"SKIP\") printc_msg \"    %{YELLOW}      %{DIM}%s [skipped]%{CLEAR}\\n\" \"$1\" ;;\n\t*)      printc_msg \"    %{YELLOW}      %s...%{CLEAR}\\n\" \"$1\" ;;\n\tesac\n}\n\n# Prints a message to STDOUT (via FD 3).\n# Works the same as printc.\nprintc_msg() {\n\tprintc \"$@\" 1>&3\n}\n\n# Prints a message to STDERR.\n# Works the same as printc.\nprintc_err() {\n\tprintc \"$@\" 1>&2\n}\n\n# Escapes a sed pattern.\n# Arguments:\n#     1  -- The pattern.\n#\n# Output:\n#     The escaped string.\nsed_escape() {\n\tsed 's/\\([][\\\\\\/\\^\\$\\*\\.\\-]\\)/\\\\\\1/g' <<< \"$1\"\n}\n\n# Checks if the output scripts will be minified.\n# Arguments:\n#    1  \"all\"    -- All scripts will be minified.\n#       \"any\"    -- Any scripts will be minified.\n#       \"lib\"    -- Library scripts will be minified.\n#       \"unsafe\" -- Unsafe minifications will be applied.\nwill_minify() {\n\tcase \"$1\" in\n\tall)\n\t\t[[ \"$OPT_MINIFY\" =~ ^all($|\\+.*) ]]\n\t\treturn $? ;;\n\tunsafe)\n\t\t[[ \"$OPT_MINIFY\" =~ ^.*+unsafe(\\+.*)*$ ]]\n\t\treturn $? ;;\n\tlib)\n\t\t[[ \"$OPT_MINIFY\" =~ ^lib($|\\+.*) ]]\n\t\treturn $? ;;\n\tany|\"\")\n\t\t[[ \"$OPT_MINIFY\" != \"none\" ]]\n\t\treturn $? ;;\n\tnone)\n\t\t! will_minify any\n\t\treturn $? ;;\n\tesac\n\treturn 1\n}\n\n# Generates the banner for the output files.\n#\n# Output:\n#    The contents of banner.txt\ngenerate_banner() {\n\tlocal step=\"$1\"\n\tif ! \"$OPT_BANNER\"; then\n\t\treturn 0\n\tfi\n\n\t# Don't run it unless the comments are removed or hidden.\n\tif ! { will_minify all || \"$OPT_COMPRESS\"; }; then\n\t\treturn 0\n\tfi\n\n\t# Only run it in the compression step if both minifying and compressing.\n\tif will_minify all && \"$OPT_COMPRESS\" && [[ \"$step\" != \"step_compress\" ]]; then\n\t\treturn 0\n\tfi\n\n\t# Write the banner.\n\tbat \"${HERE}/banner.txt\"\n}\n\n# Build step: read\n# Reads the file from its source.\n#\n# Arguments:\n#     1  -- The source file.\n#     2  -- A description of what is being read.\n#\n# Output:\n#     The file contents.\nstep_read() {\n\tlocal what=\"\"\n\tif [[ -n \"${2:-}\" ]]; then\n\t\twhat=\" $2\"\n\tfi\n\n\tcat \"$1\"\n\tsmsg \"Reading${what}\"\n}\n\n# Build step: preprocess\n# Preprocesses the script.\n#\n# This will embed library scripts and inline constants.\n#\n# Input:\n#     The original file contents.\n#\n# Output:\n#      The processed file contents.\nstep_preprocess() {\n\tlocal line\n\tlocal docvar\n\tpp_consolidate | while IFS='' read -r line; do\n\t\t# Skip certain lines.\n\t\t[[ \"$line\" =~ ^LIB=.*$ ]] && continue\n\t\t[[ \"$line\" =~ ^[[:space:]]*source[[:space:]]+[\\\"\\']\\$\\{?LIB\\}/(constants\\.sh)[\\\"\\'] ]] && continue\n\n\t\t# Forward data.\n\t\techo \"$line\"\n\tdone | pp_inline_constants\n\n\tsmsg \"Preprocessing\"\n}\n\n# Build step: minify\n# Minifies the output script.\n#\n# Input:\n#     The original file contents.\n#\n# Output:\n#     The minified file contents.\nstep_minify() {\n\tif ! will_minify all; then\n\t\tcat\n\t\tsmsg \"Minifying\" \"SKIP\"\n\t\treturn 0\n\tfi\n\n\tprintf \"#!/usr/bin/env bash\\n\"\n\tgenerate_banner step_minify\n\tpp_minify | pp_minify_unsafe\n\tsmsg \"Minifying\"\n}\n\n# Build step: compress\n# Compresses the input into a gzipped self-executable script.\n#\n# Input:\n#     The original file contents.\n#\n# Output:\n#     The compressed self-executable script.\nstep_compress() {\n\tif ! \"$OPT_COMPRESS\"; then\n\t\tcat\n\t\tsmsg \"Compressing\" \"SKIP\"\n\t\treturn 0\n\tfi\n\n\tlocal wrapper\n\twrapper=\"$({\n\t\tprintf '#!/usr/bin/env bash\\n'\n\t\tgenerate_banner step_compress\n\t\tprintf \"(exec -a \\\"\\$0\\\" bash -c 'eval \\\"\\$(cat <&3)\\\"' \\\"\\$0\\\" \\\"\\$@\\\" 3< <(dd bs=1 if=\\\"\\$0\\\" skip=::: 2>/dev/null | gunzip)); exit \\$?;\\n\"\n\t})\"\n\n\techo \"${wrapper/:::/$(wc -c <<<\"$wrapper\" | sed 's/^[[:space:]]*//')}\"\n\tgzip\n\tsmsg \"Compressing\"\n}\n\n# Build step: write\n# Writes the output script to a file.\n#\n# Arguments:\n#     1  -- The file to write to.\n#\n# Input:\n#     The file contents.\n#\n# Output:\n#     The file contents.\nstep_write() {\n\ttee \"$1\"\n\tchmod +x \"$1\"\n\tsmsg \"Building\"\n}\n\n# Build step: write_install\n# Optionally writes the output script to a file.\n#\n# Arguments:\n#     1  -- The file to write to.\n#\n# Input:\n#     The file contents.\n#\n# Output:\n#     The file contents.\nstep_write_install() {\n\tif [[ \"$OPT_INSTALL\" != true ]]; then\n\t\tcat\n\t\tsmsg \"Installing\" \"SKIP\"\n\t\treturn 0\n\tfi\n\n\ttee \"$1\"\n\tchmod +x \"$1\"\n\tsmsg \"Installing\"\n}\n\n# Build step: manpage_install\n# Optionally writes the manpage to a gzipped file.\n#\n# Arguments:\n#     1  -- The file to write to.\n#\n# Input:\n#     The file contents.\n#\n# Output:\n#     The file contents.\nstep_manpage_install() {\n\tif [[ \"$OPT_INSTALL\" != true ]]; then\n\t\tcat\n\t\tsmsg \"Installing manual\" \"SKIP\"\n\t\treturn 0\n\tfi\n\n\tgzip | tee \"$1\"\n\tsmsg \"Installing manual\"\n}\n\n# Build step: manpage_generate\n# Generates a manpage document from a markdown document.\n#\n# Input:\n#     The markdown doc contents.\n#\n# Output:\n#     The roff manpage contents.\nstep_manpage_generate() {\n\tif [[ \"$OPT_MANUALS\" != true ]]; then\n\t\tcat\n\t\tsmsg \"Generating manual\" \"SKIP\"\n\t\treturn 0\n\tfi\n\n\t(mdroff)\n\tsmsg \"Generating manual\"\n}\n\n# -----------------------------------------------------------------------------\n# Preprocessor:\n# -----------------------------------------------------------------------------\n\n# Consolidates all scripts into a single file.\n# This follows all `source \"${LIB}/...\"` files and embeds them into the script.\npp_consolidate() {\n\tPP_CONSOLIDATE_PROCESSED=()\n\tpp_consolidate__do 0\n}\n\npp_consolidate__do() {\n\tlocal depth=\"$1\"\n\tlocal indent=\"$(printf \"%-${depth}s\" | tr ' ' $'\\t')\"\n\n\tlocal line\n\twhile IFS='' read -r line; do\n\t\t# Embed library scripts.\n\t\tif [[ \"$line\" =~ ^[[:space:]]*source[[:space:]]+[\\\"\\']\\$\\{?LIB\\}/([a-z_-]+\\.sh)[\\\"\\'] ]]; then\n\t\t\tlocal script_name=\"${BASH_REMATCH[1]}\"\n\t\t\tlocal script=\"$LIB/$script_name\"\n\n\t\t\t# Skip if it's the constants library.\n\t\t\t[[ \"$script_name\" = \"constants.sh\" ]] && continue\n\n\t\t\t# Skip if it's already embedded.\n\t\t\tlocal other\n\t\t\tfor other in \"${PP_CONSOLIDATE_PROCESSED[@]}\"; do\n\t\t\t\t[[ \"$script\" = \"$other\" ]] && continue 2\n\t\t\tdone\n\t\t\tPP_CONSOLIDATE_PROCESSED+=(\"$script\")\n\n\t\t\t# Embed the script.\n\t\t\techo \"${indent}# --- BEGIN LIBRARY FILE: ${BASH_REMATCH[1]} ---\"\n\t\t\t{\n\t\t\t\tif will_minify lib; then\n\t\t\t\t\tpp_strip_comments | pp_minify | pp_minify_unsafe\n\t\t\t\telse\n\t\t\t\t\tpp_strip_copyright | pp_strip_separators\n\t\t\t\tfi\n\t\t\t} < <(pp_consolidate__do \"$((depth + 1))\" < \"$script\") | sed \"s/^/${indent}/\"\n\t\t\techo \"${indent}# --- END LIBRARY FILE ---\"\n\t\t\tcontinue\n\t\tfi\n\n\t\t# Forward data.\n\t\techo \"$line\"\n\tdone\n}\n\n# Inlines constants:\n# EXECUTABLE_*\n# PROGRAM_*\npp_inline_constants() {\n\tlocal constants=(\"PROGRAM\")\n\n\t# Determine the PROGRAM_ constants.\n\tlocal nf_constants=\"$( ( set -o posix ; set) | grep '^\\(PROGRAM_\\|EXECUTABLE_\\)' | cut -d'=' -f1)\"\n\tlocal line\n\twhile read -r line; do\n\t\tconstants+=(\"$line\")\n\tdone <<< \"$nf_constants\"\n\n\t# Generate a sed replace for the constants.\n\tlocal constants_pattern=''\n\tlocal constant_name\n\tlocal constant_value\n\tfor constant_name in \"${constants[@]}\"; do\n\t\tconstant_value=\"$(sed_escape \"${!constant_name}\")\"\n\t\tconstant_name=\"$(sed_escape \"$constant_name\")\"\n\t\tconstant_sed=\"s/\\\\\\$${constant_name}\\([^A-Za-z0-9_]\\)/${constant_value}\\1/; s/\\\\\\${${constant_name}}/${constant_value}/g;\"\n\t\tconstants_pattern=\"${constants_pattern}${constant_sed}\"\n\tdone\n\n\tsed \"${constants_pattern}\"\n}\n\n\n# Strips comments from a Bash source file.\npp_strip_comments() {\n\tsed '/^[[:space:]]*#.*$/d'\n}\n\n# Strips copyright comments from the start of a Bash source file.\npp_strip_copyright() {\n\tawk '/^#/ {if(!p){ next }} { p=1; print $0 }'\n}\n\n# Strips separator comments from the start of a Bash source file.\npp_strip_separators() {\n\tawk '/^#\\s*-{5,}/ { next; } {print $0}'\n}\n\n# Minify a Bash source file.\n# https://github.com/mvdan/sh\npp_minify() {\n\tif will_minify none; then\n\t\tcat\n\t\treturn\n\tfi\n\n\tshfmt -mn\n\treturn $?\n}\n\n# Minifies the output script (unsafely).\n# Right now, this doesn't do anything.\n# This should be applied after shfmt minification.\npp_minify_unsafe() {\n\tif ! will_minify unsafe; then\n\t\tcat\n\t\treturn 0\n\tfi\n\n\tcat\n}\n\n# -----------------------------------------------------------------------------\n# Options:\n# -----------------------------------------------------------------------------\nOPT_INSTALL=false\nOPT_COMPRESS=false\nOPT_VERIFY=true\nOPT_BANNER=true\nOPT_MANUALS=true\nOPT_INLINE=true\nOPT_MINIFY=\"lib\"\nOPT_PREFIX=\"/usr/local\"\nEXECUTABLE_BAT=\"$(basename -- \"$EXECUTABLE_BAT\")\"\nALT_EXECS=()\nBUILD_FILTER=()\n\nDOCS_URL=\"https://github.com/eth-p/bat-extras/blob/master/doc\"\nDOCS_MAINTAINER=\"eth-p <eth-p@hidden.email>\"\n\n# -----------------------------------------------------------------------------\n# Use a different default prefix when running on Termux.\n\nif [[ \"$(uname -o)\" = \"Android\" ]] && [[ -n \"${TERMUX_VERSION:-}\" ]]; then\n     OPT_PREFIX=\"/data/data/com.termux/files/usr/\"\nelse\n     OPT_PREFIX=\"/usr/local\"\nfi\n\n# -----------------------------------------------------------------------------\n# Parse arguments.\n\nwhile shiftopt; do\n\t# shellcheck disable=SC2034\n\tcase \"$OPT\" in\n\t--install)                        OPT_INSTALL=true ;;\n\t--compress)                       OPT_COMPRESS=true ;;\n\t--manuals)                        OPT_MANUALS=\"${OPT_VAL:-true}\" ;;\n\t--no-manuals)                     OPT_MANUALS=false ;;\n\t--verify)                         OPT_VERIFY=true ;;\n\t--no-verify)                      OPT_VERIFY=false ;;\n\t--banner)                         OPT_BANNER=true ;;\n\t--no-banner)                      OPT_BANNER=false ;;\n\t--inline)                         OPT_INLINE=true ;;\n\t--no-inline)                      OPT_INLINE=false ;;\n\t--prefix)               shiftval; OPT_PREFIX=\"$OPT_VAL\" ;;\n\t--alternate-executable)         shiftval; ALT_EXECS+=(\"bat\");     EXECUTABLE_BAT=\"$OPT_VAL\" ;;\n\t--alternate-executable:bat)     shiftval; ALT_EXECS+=(\"bat\");     EXECUTABLE_BAT=\"$OPT_VAL\" ;;\n\t--alternate-executable:ripgrep) shiftval; ALT_EXECS+=(\"ripgrep\"); EXECUTABLE_RIPGREP=\"$OPT_VAL\" ;;\n\t--alternate-executable:delta)   shiftval; ALT_EXECS+=(\"delta\");   EXECUTABLE_DELTA=\"$OPT_VAL\" ;;\n\t--alternate-executable:fzf)     shiftval; ALT_EXECS+=(\"fzf\");     EXECUTABLE_FZF=\"$OPT_VAL\" ;;\n\t--alternate-executable:git)     shiftval; ALT_EXECS+=(\"git\");     EXECUTABLE_GIT=\"$OPT_VAL\" ;;\n\t--minify)\t\t        shiftval; OPT_MINIFY=\"$OPT_VAL\" ;;\n\n\t# Print scripts.\n\t--show:source-paths) get_source_paths; exit 0 ;;\n\n\t# Unknown options.\n\t*)\n\t\tif ! [[ -f \"${SRC}/${OPT}.sh\" ]]; then\n\t\t\tprintc_err \"%{RED}%s: unknown option '%s'%{CLEAR}\" \"$PROGRAM\" \"$OPT\"\n\t\t\texit 1\n\t\tfi\n\n\t\tBUILD_FILTER+=(\"$OPT\")\n\t\t;;\n\tesac\ndone\n\nif [[ \"${#ALT_EXECS[@]}\" -gt 0 ]]; then\n\tprintc_msg \"%{YELLOW}Building executable scripts with alternate executables for:%{CLEAR}\\n\"\n\tprintc_msg \"%{YELLOW} - %{CLEAR}%s\\n\" \"${ALT_EXECS[@]}\"\n\tprintc_msg \"\\n\"\n\n\tif ! command -v \"$EXECUTABLE_BAT\" &>/dev/null; then\n\t\tprintc_err \"%{YELLOW}WARNING: Bash cannot execute bat's executable file.\\n\"\n\t\tprintc_err \"%{YELLOW}         The finished scripts may not run properly.%{CLEAR}\\n\"\n\tfi\n\n\t# shellcheck disable=SC2034\n\tprintc_msg \"\\n\"\nfi\n\nif [[ \"$OPT_INSTALL\" = true ]]; then\n\tprintc_msg \"%{YELLOW}Installing to %{MAGENTA}%s%{YELLOW}.%{CLEAR}\\n\" \"$OPT_PREFIX\"\nelse\n\tprintc_msg \"%{YELLOW}This will not install the script.%{CLEAR}\\n\"\n\tprintc_msg \"%{YELLOW}Use %{BLUE}--install%{YELLOW} for a global install.%{CLEAR}\\n\\n\"\nfi\n\nif [[ \"$OPT_INLINE\" = false ]]; then\n\t# Prevent full executable paths from being inlined.\n\twhile read -r exec; do\n\t\tdeclare \"$exec=$(basename \"${!exec}\")\"\n\tdone < <(set | grep '^EXECUTABLE' | cut -d'=' -f1)\nfi\n\n# -----------------------------------------------------------------------------\n# Check for resources.\n\nif ! will_minify none && ! command -v shfmt &>/dev/null; then\n\tprintc_err \"%{RED}Warning: cannot find shfmt. Unable to minify scripts.%{CLEAR}\\n\"\n\tOPT_MINIFY=none\nfi\n\n# -----------------------------------------------------------------------------\n# Check target directories exist.\n\n[[ -d \"$BIN\" ]] || mkdir -p \"$BIN\"\n\nif \"$OPT_INSTALL\"; then\n\t[[ -d \"${OPT_PREFIX}/bin\" ]] || mkdir -p \"${OPT_PREFIX}/bin\"\n\t[[ \"$OPT_MANUALS\" = \"true\" && ! -d \"${OPT_PREFIX}/share/man/man1\" ]] \\\n\t\t&& mkdir -p \"${OPT_PREFIX}/share/man/man1\"\nfi\n\nif [[ \"$OPT_MANUALS\" = \"true\" ]]; then\n\t[[ -d \"$MAN\" ]] || mkdir -p \"$MAN\"\nfi\n\n# -----------------------------------------------------------------------------\n# Find files.\n\nSOURCES=()\n\nprintc_msg \"%{YELLOW}Preparing scripts...%{CLEAR}\\n\"\nwhile read -r file; do\n\tfile_bin=\"$(basename -- \"$file\" \".sh\")\"\n\tbuildable=false\n\n\tif ! \"$buildable\" && [[ \"${#BUILD_FILTER[@]}\" -eq 0 ]]; then\n\t\tbuildable=true\n\telif ! \"$buildable\"; then\n\t\tfor buildable_file in \"${BUILD_FILTER[@]}\"; do\n\t\t\tif [[ \"$buildable_file\" = \"$file_bin\" ]]; then\n\t\t\t\tbuildable=true\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\tfi\n\n\t# If that one is allowed to build, add it to the sources list.\n\tif \"$buildable\"; then\n\t\tSOURCES+=(\"$file\")\n\telse\n\t\tprintc_msg \"          %{YELLOW}Skipping %{MAGENTA}%s%{CLEAR}\\n\" \"$(basename \"$file_bin\")\"\n\tfi\ndone < <(batextras:get_source_paths)\n\nif [[ \"${#BUILD_FILTER[@]}\" -gt 0 ]]; then\n\tprintf \"\\n\"\nfi\n\n\n# -----------------------------------------------------------------------------\n# Build files.\n\nprintc_msg \"%{YELLOW}Building scripts...%{CLEAR}\\n\"\nfile_i=0\nfile_n=\"${#SOURCES[@]}\"\nfor file in \"${SOURCES[@]}\"; do\n\t((file_i++)) || true\n\n\tfilename=\"$(basename \"$file\" .sh)\"\n\tPROGRAM=\"$filename\"\n\tPROGRAM_VERSION=\"$(<\"${HERE}/version.txt\")\"\n\n\tprintc_msg \"    %{YELLOW}[%s/%s] %{MAGENTA}%s%{CLEAR}\\n\" \"$file_i\" \"$file_n\" \"$file\"\n\tstep_read \"$file\" |\n\t\tnext step_preprocess |\n\t\tnext step_minify |\n\t\tnext step_compress |\n\t\tnext step_write \"${BIN}/${filename}\" |\n\t\tnext step_write_install \"${OPT_PREFIX}/bin/${filename}\" |\n\t\tcat >/dev/null\n\n\t# Build manuals.\n\tif [[ -f \"${HERE}/doc/${filename}.md\" && \"$OPT_MANUALS\" = \"true\" ]]; then\n\t\tstep_read \"${HERE}/doc/${filename}.md\" \"manual\" |\n\t\t\tnext step_manpage_generate |\n\t\t\tnext step_write \"${MAN}/${filename}.1\" |\n\t\t\tnext step_manpage_install \"${OPT_PREFIX}/share/man/man1/${filename}.1.gz\" |\n\t\t\tcat >/dev/null\n\tfi\ndone\n\n# -----------------------------------------------------------------------------\n# Verify files by running the tests.\n\nif \"$OPT_VERIFY\"; then\n\tprintc_msg \"\\n%{YELLOW}Verifying scripts...%{CLEAR}\\n\"\n\n\t# Run the tests.\n\tFAIL=0\n\tSKIP=0\n\twhile read -r action data1 data2 splat; do\n\t\t[[ \"$action\" == \"result\" ]] || continue\n\t\tcase \"$data2\" in\n\t\t\tfail)\n\t\t\t\tprintc_err \"\\x1B[G\\x1B[K%s failed.\\n\" \"$data1\"\n\t\t\t\t((FAIL++)) || true\n\t\t\t\t;;\n\n\t\t\tskip)\n\t\t\t\tprintc_msg \"\\x1B[G\\x1B[K%s skipped.\\n\" \"$data1\"\n\t\t\t\t((SKIP++)) || true\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\tprintc_msg \"\\x1B[G\\x1B[K%s\" \"$data1\"\n\t\t\t\t;;\n\t\tesac\n\tdone < <(\"${HERE}/test.sh\" --compiled --porcelain --jobs=8)\n\n\t# Print the overall result.\n\tprintc_msg \"\\x1B[G\\x1B[K\"\n\n\tif [[ \"$FAIL\" -ne 0 ]]; then\n\t\tprintc_err \"%{RED}%s\\n\" \"One or more tests failed.\"\n\t\tprintc_msg \"\\x1B[A\\x1B[G\\x1B[K%{RED}%s\\n\" \"One or more tests failed.\"\n\t\tprintc_err \"%{RED}%s%{CLEAR}\\n\" \"Run './test.sh --failed' for more detailed information.\"\n\t\texit 1\n\tfi\n\n\tif [[ \"$SKIP\" -gt 0 ]]; then\n\t\tprintc_err \"%{CYAN}One or more tests were skipped.\\n\"\n\t\tprintc_err \"Run ./test.sh for more detailed information.%{CLEAR}\\n\"\n\tfi\n\n\tprintc_msg \"%{YELLOW}Verified successfully.%{CLEAR}\\n\"\nfi\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "mdroff.sh",
          "type": "blob",
          "size": 7.59375,
          "content": "#!/usr/bin/env bash\n# -----------------------------------------------------------------------------\n# bat-extras | Copyright (C) 2020 eth-p | MIT License\n#\n# Repository: https://github.com/eth-p/bat-extras\n# Issues:     https://github.com/eth-p/bat-extras/issues\n# -----------------------------------------------------------------------------\n# shellcheck disable=SC2021\n# shellcheck disable=SC2155\n\nprintf_msg() {\n\t# shellcheck disable=SC2059\n\tprintf \"$@\" 1>&2\n}\n\nprintf_err() {\n\t# shellcheck disable=SC2059\n\tprintf \"$@\" 1>&2\n}\n\n# -----------------------------------------------------------------------------\n# MDroff:\n# -----------------------------------------------------------------------------\n\nmdroff:emit:h1() {\n\tprintf '.TH \"%s\" 1\\n' \"$1\"\n}\n\nmdroff:emit:h2() {\n\tprintf '.SH \"%s\"\\n' \"$1\"\n}\n\nmdroff:emit:h3() {\n\tprintf '.SS \"%s\"\\n' \"$1\"\n}\n\nmdroff:emit:h4() {\n\tprintf '.SS \"%s\"\\n' \"$1\"\n}\n\nmdroff:emit:h5() {\n\tprintf '.SS \"%s\"\\n' \"$1\"\n}\n\nmdroff:emit:line() {\n\tif \"$MDROFF_PARAGRAPH\"; then\n\t\tMDROFF_PARAGRAPH=false\n\t\tprintf \".P\\n%s\\n\" \"$1\"\n\telse\n\t\tprintf \".br\\n%s\\n\" \"$1\"\n\tfi\n}\n\nmdroff:emit:attr() {\n\tprintf '\\\\fR'\n\t\n\tif \"$MDROFF_ATTR_STRONG\"; then\n\t\tprintf '\\\\fB'\n\tfi\n\t\n\tif \"$MDROFF_ATTR_EMPHASIS\"; then\n\t\tprintf '\\\\fI'\n\tfi\n\t\n\tif \"$MDROFF_ATTR_CODE\"; then\n\t\tprintf '\\\\fI'\n\tfi\n}\n\nmdroff:emit:link() {\n\tprintf \"%s\" \"$1\"\n}\n\n\n# shellcheck disable=SC2034\nmdroff:emit:table_start() {\n\tprintf \".TS\\n\"\n\tprintf \"tab(|) box;\\n\"\n\t\n\t# Print Header Alignment\n\tlocal temp\n\tfor temp in \"$@\"; do printf \"| cB \"; done\n\tprintf \"|\\n\"\n\t\n\t# Print Separator\n\tfor temp in \"$@\"; do printf \"| _ \"; done\n\tprintf \"|\\n\"\n\t\n\t# Print Column Alignment\n\tlocal cols=(\"$@\")\n\tprintf \"| \"\n\tprintf \"%s0 |1 \" \"${cols:0:$((${#@}-1))}\"\n\tprintf \"%s \" \"${cols[$((${#@}-1))]}\"\n\tprintf \"|.\\n\"\n}\n\nmdroff:emit:table_end() {\n\tprintf \".TE\\n\\n\"\n}\n\nmdroff:emit:table_heading() {\n\tlocal heading=\"$(printf \"| %s \" \"$@\")\"\n\tprintf \"%s\\n\" \"${heading:1}\"\n\t\n\t# Prevent tbl warning.\n\tfor temp in \"${@:2}\"; do printf \"|\"; done\n\tprintf \"\\n\"\n\t\n\t# Start table data.\n\tprintf \".SP\\n\"\n}\n\nmdroff:emit:table_row() {\n\tlocal row=\"$(printf \"| %s \" \"$@\")\"\n\tprintf \"%s\\n\" \"${row:1}\"\n}\n\nmdroff:emit:text() {\n\tlocal text=\"$1\"\n\t\n\ttext=\"${text//<br>/ }\"\n\ttext=\"${text//<br\\/>/ }\"\n\ttext=\"${text//<br \\/>/ }\"\n\t\n\tprintf \"%s\" \"$text\"\n}\n\nmdroff:emit() {\n\tlocal type=\"$1\"\n\tlocal data=\"$2\"\n\t\n\tif type \"mdroff:rewrite:${type}\" &>/dev/null; then\n\t\tdata=\"$(\"mdroff:rewrite:${type}\" \"${@:2}\")\"\n\tfi\n\t\n\tif type \"mdroff:emit_hook:${type}\" &>/dev/null; then\n\t\t\"mdroff:emit_hook:${type}\" \"$data\" \"${@:3}\"\n\t\treturn\n\tfi\n\t\n\t\"mdroff:emit:${type}\" \"$data\" \"${@:3}\"\n}\n\nmdroff:trim_right() {\n\t# shellcheck disable=SC2001\n\tsed 's/[[:space:]]*$//' <<< \"$1\"\n}\n\nmdroff:trim() {\n\tsed 's/^[[:space:]]*//; s/[[:space:]]*$//' <<< \"$1\"\n}\n\nmdroff:parseln() {\n\tMDROFF_ATTR_STRONG=false\n\tMDROFF_ATTR_EMPHASIS=false\n\tMDROFF_ATTR_CODE=false\n\t\n\tlocal buffer=\"$1\"\n\tlocal before\n\tlocal found\n\tlocal pos\n\t\n\twhile [[ \"${#buffer}\" -gt 0 ]]; do\n\t\t[[ \"$buffer\" =~ \\*{1,3}|\\`|\\[([^\\]]+)\\]\\(([^\\)]+)\\) ]] || {\n\t\t\tmdroff:emit text \"$(mdroff:trim_right \"$buffer\")\"\n\t\t\tmdroff:emit text $'\\n'\n\t\t\treturn\n\t\t}\n\t\t\n\t\tfound=\"${BASH_REMATCH[0]}\"\n\t\tpos=\"$(awk -v search=\"$found\" '{print index($0,search) - 1}' <<< \"$buffer\")\"\n\t\t\n\t\tbefore=\"${buffer:0:$pos}\"\n\t\tbuffer=\"${buffer:$(($pos + ${#found}))}\"\n\t\t\n\t\tmdroff:emit text \"$before\"\n\t\tcase \"$found\" in\n\t\t\t'***')\n\t\t\t\tif \"$MDROFF_ATTR_STRONG\" && \"$MDROFF_ATTR_EMPHASIS\"; then\n\t\t\t\t\tMDROFF_ATTR_STRONG=false\n\t\t\t\t\tMDROFF_ATTR_EMPHASIS=false\n\t\t\t\telse\n\t\t\t\t\tMDROFF_ATTR_STRONG=true\n\t\t\t\t\tMDROFF_ATTR_EMPHASIS=true\n\t\t\t\tfi \n\t\t\t\tmdroff:emit attr\n\t\t\t\t;;\n\n\t\t\t'**')\t\n\t\t\t\tif \"$MDROFF_ATTR_STRONG\"; then\n\t\t\t\t\tMDROFF_ATTR_STRONG=false\n\t\t\t\telse\n\t\t\t\t\tMDROFF_ATTR_STRONG=true\n\t\t\t\tfi\n\t\t\t\tmdroff:emit attr\n\t\t\t\t;;\n\n\t\t\t'*')\n\t\t\t\tif \"$MDROFF_ATTR_EMPHASIS\"; then\n\t\t\t\t\tMDROFF_ATTR_EMPHASIS=false\n\t\t\t\telse\n\t\t\t\t\tMDROFF_ATTR_EMPHASIS=true\n\t\t\t\tfi\n\t\t\t\tmdroff:emit attr\n\t\t\t\t;;\n\n\t\t\t'`')\n\t\t\t\tif \"$MDROFF_ATTR_CODE\"; then\n\t\t\t\t\tMDROFF_ATTR_CODE=false\n\t\t\t\telse\n\t\t\t\t\tMDROFF_ATTR_CODE=true\n\t\t\t\tfi\n\t\t\t\tmdroff:emit attr\n\t\t\t\t;;\n\t\t\t\t\n\n\t\t\t'['*)\n\t\t\t\tmdroff:emit link \"${BASH_REMATCH[1]}\" \"${BASH_REMATCH[2]}\"\n\t\tesac\n\tdone\n}\n\nmdroff() {\n\tMDROFF_HEADING_LEVEL=0\n\tMDROFF_HEADING=''\n\tMDROFF_ATTR_STRONG=false\n\tMDROFF_ATTR_EMPHASIS=false\n\tMDROFF_ATTR_CODE=false\n\tMDROFF_IN_TABLE=false\n\tMDROFF_PARAGRAPH=false\n\tMDROFF_TABLE_HEADER=()\n\t\n\tlocal line\n\tlocal empty=0\n\tlocal empty_continue=0\n\twhile IFS='' read -r line; do\n\t\tline=\"$(mdroff:parseln \"$line\")\"\n\t\t\n\t\t# Empty\n\t\tif [[ \"$line\" =~ ^[[:space:]]*$ ]]; then\n\t\t\t((empty_continue++)) || true\n\t\t\tif \"$MDROFF_IN_TABLE\"; then\n\t\t\t\tmdroff:emit table_end\t\n\t\t\tfi\n\t\t\t\n\t\t\tMDROFF_PARAGRAPH=true\n\t\t\tMDROFF_TABLE_HEADER=()\n\t\t\tMDROFF_IN_TABLE=false\n\t\t\tcontinue\n\t\tfi\n\t\t\n\t\tempty=\"$empty_continue\"\n\t\tempty_continue=0\n\t\t\n\t\t# Headings\n\t\tif [[ \"$line\" =~ ^(#{1,})[[:space:]]{1,}(.*)$ ]]; then\n\t\t\tlocal level=\"${#BASH_REMATCH[1]}\"\n\t\t\tlocal text=\"${BASH_REMATCH[2]}\"\n\t\t\t\n\t\t\tMDROFF_HEADING_LEVEL=\"$level\"\n\t\t\tMDROFF_HEADING=\"$text\"\n\t\t\t\n\t\t\tmdroff:emit \"h${level}\" \"$text\"\n\t\t\tMDROFF_PARAGRAPH=true\n\t\t\tcontinue\n\t\tfi\n\t\t\n\t\t# Tables (Partially Supported)\n\t\tif [[ \"$line\" =~ ^[[:space:]]*\\| ]]; then\n\t\t\tlocal raw_cells=()\n\t\t\tlocal cells=()\n\t\t\tlocal table_cell\n\t\t\t\n\t\t\tline=\"$(sed 's/^[[:space:]]*|//; s/|[[:space:]]*$//' <<< \"$line\")\"\n\t\t\t\n\t\t\t# shellcheck disable=SC2206\n\t\t\tIFS='|' raw_cells=($line)\n\t\t\tfor table_cell in \"${raw_cells[@]}\"; do\n\t\t\t\tcells+=(\"$(mdroff:trim \"$table_cell\")\")\n\t\t\tdone\n\t\t\t\n\t\t\tif [[ \"${cells[0]}\" =~ ^[[:space:]]*-+[[:space:]]*$ ]]; then\n\t\t\t\t# Calculate the column alignments.\n\t\t\t\tlocal table_alignments=()\n\t\t\t\tlocal table_cell\n\t\t\t\t\n\t\t\t\tfor table_cell in \"${cells[@]}\"; do\n\t\t\t\t\tcase \"$table_cell\" in\n\t\t\t\t\t\t:-*:)\n\t\t\t\t\t\t\ttable_alignments+=('c')\n\t\t\t\t\t\t\t;;\n\t\t\t\t\t\t:-*)\n\t\t\t\t\t\t\ttable_alignments+=('l')\n\t\t\t\t\t\t\t;;\n\t\t\t\t\t\t*-:)\n\t\t\t\t\t\t\ttable_alignments+=('r')\n\t\t\t\t\t\t\t;;\n\t\t\t\t\t\t*)\n\t\t\t\t\t\t\ttable_alignments+=('l') # Unknown, but let's assume left.\n\t\t\t\t\tesac\n\t\t\t\tdone\n\t\t\t\t\n\t\t\t\t# Emit the table start and table header.\n\t\t\t\tmdroff:emit table_start \"${table_alignments[@]}\"\n\t\t\t\tmdroff:emit table_heading \"${MDROFF_TABLE_HEADER[@]}\"\n\t\t\t\tMDROFF_TABLE_HEADER=()\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\t\n\t\t\tif ! \"$MDROFF_IN_TABLE\"; then\n\t\t\t\tMDROFF_IN_TABLE=true\n\t\t\t\tMDROFF_TABLE_HEADER=(\"${cells[@]}\")\n\t\t\telse\n\t\t\t\tif [[ \"${#MDROFF_TABLE_HEADER[@]}\" -ne 0 ]]; then\n\t\t\t\t\tmdroff:emit table_heading \"${MDROFF_TABLE_HEADER[@]}\"\n\t\t\t\t\tMDROFF_TABLE_HEADER=()\t\n\t\t\t\tfi\n\t\t\t\t\n\t\t\t\tmdroff:emit table_row \"${cells[@]}\"\n\t\t\tfi\n\t\t\n\t\t\tMDROFF_PARAGRAPH=true\n\t\t\tcontinue\t\n\t\tfi\n\t\t\n\t\tmdroff:emit line \"$line\"\n\tdone < <(sed 's/<br *\\/?>//')\n}\n\n# -----------------------------------------------------------------------------\n# bat-extras:\n# -----------------------------------------------------------------------------\n\nmdroff:rewrite:h1() {\n\temitted_name=false\n\temitted_description=false\n\tsed 's/^bat-extras: //' <<< \"$1\" | tr '[[:lower:]]' '[[:upper:]]'\n}\n\n\nmdroff:emit_hook:h2() {\n\tcase \"$MDROFF_HEADING\" in\n\t\t\"Installation\") return ;;\n\t\t\"Issues?\")      return ;;\n\tesac\n\t\n\tmdroff:emit:h2 \"$(tr '[[:lower:]]' '[[:upper:]]' <<< \"$1\")\"\n}\n\nmdroff:emit_hook:line() {\n\tif [[ \"$MDROFF_HEADING_LEVEL\" = \"1\" ]] && [[ \"$emitted_name\" != true ]]; then\n\t\temitted_name=true\n\t\tprintf \".SH NAME\\n%s - %s\\n\" \"$(sed 's/^bat-extras: //' <<< \"$MDROFF_HEADING\" | tr '[[:upper:]]' '[[:lower:]]')\" \"$1\"\n\t\tprintf \".SH DESCRIPTION\\n\"\n\t\treturn\n\tfi\n\t\n\tcase \"$MDROFF_HEADING\" in\n\t\t\"Installation\") return ;;\n\t\t\"Issues?\")      return ;;\n\tesac\n\t\n\tmdroff:emit:line \"$@\"\n}\n\n# -----------------------------------------------------------------------------\n# Main:\n# -----------------------------------------------------------------------------\n\nif [[ \"${#BASH_SOURCE[@]}\" -eq 1 ]]; then\n\tcase \"$1\" in\n\t\t\"\") mdroff ;;\n\t\t*) {\n\t\t\tif ! [ -f \"$1\" ]; then\n\t\t\t\tprintf_err \"%s: cannot find or read file %s\\n\" \"$0\" \"$1\" \n\t\t\t\texit 1;\t\n\t\t\tfi\n\t\t\t\n\t\t\tmdroff < \"$1\"\n\t\t} ;;\n\tesac\nfi\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 10.4130859375,
          "content": "#!/usr/bin/env bash\n# -----------------------------------------------------------------------------\n# bat-extras | Copyright (C) 2019-2023 eth-p | MIT License\n#\n# Repository: https://github.com/eth-p/bat-extras\n# Issues:     https://github.com/eth-p/bat-extras/issues\n# -----------------------------------------------------------------------------\nsource \"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)/build.sh\"\n\n# -----------------------------------------------------------------------------\n# Release-as-a-Library Functions:\n# -----------------------------------------------------------------------------\n\n# Prints the path to the git workspace.\nif ! batextras:is_function_defined ::get_git_workspace; then\n\tbatextras:get_git_workspace() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:get_project_directory)\"\n\t}\nfi\n\n# Prints the commit of the latest-tagged version of bat-extras.\nif ! batextras:is_function_defined ::get_current_commit; then\n\tbatextras:get_current_commit() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:git rev-parse HEAD)\"\n\t}\nfi\n\n# Prints the commit of the latest-tagged version of bat-extras.\nif ! batextras:is_function_defined ::get_previous_tag_commit; then\n\tbatextras:get_previous_tag_commit() {\n\t\tlocal latest_tag\n\t\tlocal before_latest_tag\n\t\t{\n\t\t\tread -r latest_tag\n\t\t\tread -r before_latest_tag\n\t\t} < <(batextras:git rev-list --tags --max-count=2)\n\n\t\t# If the latest commit is a tag, go to the one before that.\n\t\tif [[ \"$(batextras:get_current_commit)\" = \"$latest_tag\" ]]; then\n\t\t\tlatest_tag=\"${before_latest_tag}\"\n\t\tfi\n\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \"$latest_tag\"\n\t}\nfi\n\n# Prints the ref name of the latest-tagged version of bat-extras.\nif ! batextras:is_function_defined ::get_previous_tag_name; then\n\tbatextras:get_previous_tag_name() {\n\t\tbatextras:lazy_done \"${FUNCNAME[0]}\" \\\n\t\t\t\"$(batextras:git describe --tags --abbrev=0 \"$(batextras:get_previous_tag_commit)\")\"\n\t}\nfi\n\n# Returns the suffix for a day of the month.\n#\n# Arguments:\n#     1  -- The day number.\n#\n# Output:\n#     The suffix.\nbatextras:day_suffix() {\n\tcase \"$1\" in\n\t\t11 | 12 | 13) echo \"th\" ;;\n\t\t*1) echo \"st\" ;;\n\t\t*2) echo \"nd\" ;;\n\t\t*3) echo \"rd\" ;;\n\t\t*)  echo \"th\" ;;\n\tesac\n}\n\n# Runs `git` within the project directory.\n#\n# This takes the same arguments as git (with the exception of `-C`), and\n# does exactly what `git` would normally do.\nbatextras:git() {\n\tgit -C \"$(batextras:get_git_workspace)\" \"$@\"\n\treturn $?\n}\n\n# Creates the zipball for release.\n# YOU MUST BUILD THE PROJECT FIRST!\n#\n# Arguments:\n#     1  -- The absolute path to the output zip file.\n#\n# Stderr:\n#     Messages.\nbatextras:create_package() {\n\tlocal artifact=\"$1\"\n\tlocal bin_dir man_dir doc_dir\n\tbin_dir=\"$(batextras:get_output_bin_directory)\"\n\tman_dir=\"$(batextras:get_output_man_directory)\"\n\tdoc_dir=\"$(batextras:get_docs_directory)\"\n\n\t(\n\t\t# Remove the old zipball, if one exists.\n\t\tif [[ -f \"$artifact\" ]]; then\n\t\t\trm \"$artifact\" || return $?\n\t\tfi\n\n\t\t# Add the bin directory.\n\t\tcd \"$(dirname -- \"$bin_dir\")\" || return $?\n\t\tzip -r \"$artifact\" \"$(basename -- \"$bin_dir\")\"\n\n\t\t# Add the doc directory.\n\t\tcd \"$(dirname -- \"$doc_dir\")\" || return $?\n\t\tzip -ru \"$artifact\" \"$(basename -- \"$doc_dir\")\"\n\n\t\t# Add the man directory.\n\t\tif [[ -d \"$man_dir\" ]]; then\n\t\t\tcd \"$(dirname -- \"$man_dir\")\" || return $?\n\t\t\tzip -ru \"$artifact\" \"$(basename -- \"$man_dir\")\"\n\t\tfi\n\t) 1>&2\n}\n\n# Generates a Markdown changelog for all changes between two commits.\n#\n# Arguments:\n#     1  -- The first commit, exclusive.\n#     2  -- The second commit, inclusive.\n#     3  -- A filter in regex.\n#\n# Output:\n#     The changelog.\nbatextras:generate_changelog() {\n\tlocal start_commit=\"$1\"\n\tlocal end_commit=\"$2\"\n\tlocal filter=\"${3}\"\n\n\t# Generate sed replacement patterns.\n\tlocal script_links=()\n\tlocal script_names=()\n\tlocal script script_name\n\twhile read -r script; do\n\t\tscript_name=\"$(basename \"$script\" .sh)\"\n\t\tscript_names+=(\"$script_name\")\n\tdone < <(batextras:get_source_paths)\n\n\tlocal script_pattern\n\tscript_pattern=\"$(printf 's/\\\\(%s\\\\)/`\\\\1`/;' \"${script_names[@]}\")\"\n\n\t# Generate the changelog.\n\tlocal changelog=''\n\tlocal commit\n\tlocal affected_module\n\tlocal commit_message\n\twhile read -r commit; do\n\t\tcommit_message=\"$(batextras:git show -s --format=%s \"$commit\")\"\n\n\t\tif ! [[ \"$commit_message\" =~ ^([a-z-]+):[[:space:]]*(.*)$ ]]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\taffected_module=\"${BASH_REMATCH[1]}\"\n\n\t\t# Make module names consistent.\n\t\tcase \"$affected_module\" in\n\t\t\tdev | lib | mdroff) affected_module=\"developer\" ;;\n\t\t\ttests) affected_module=\"test\" ;;\n\t\t\tdoc) affected_module=\"docs\" ;;\n\t\tesac\n\n\t\t# Append to changelog.\n\t\tif [[ \"$affected_module\" =~ ^($filter)$ ]]; then\n\t\t\tchangelog=\"$changelog\"$'\\n'\" - ${commit_message}\"\n\t\tfi\n\tdone < <(batextras:git rev-list \"${start_commit}..${end_commit}\")\n\n\t# Print the changelog.\n\tchangelog=\"$(sed \"$script_pattern\" <<< \"$changelog\")\"\n\tprintf \"%s\\n\" \"${changelog:1}\"\n\treturn 0\n}\n\n# Generates the Markdown release notes.\n#\n# Arguments:\n#     1  -- The oldest commit, exclusive.\n#     2  -- The newest commit, inclusive.\n#\n# Output:\n#     The changelog.\nbatextras:generate_release_notes() {\n\tlocal commit_oldest=\"$1\"\n\tlocal commit_newest=\"$2\"\n\tlocal commit_newest_url=\"https://github.com/eth-p/bat-extras/tree/${commit_newest}\"\n\tlocal date_str\n\n\t# Get the commit date.\n\tlocal date_year date_month date_day date_month_text date_day_suffix\n\tread -r date_year date_month date_day date_month_text \\\n\t\t< <(batextras:git show -s --format=\"%cd\" --date=\"format:%Y %m %d %B\" \"$commit_newest\")\n\n\tdate_day_suffix=\"$(batextras:day_suffix \"$date_day\")\"\n\tdate_str=\"${date_month_text} ${date_day}${date_day_suffix}, ${date_year}\"\n\n\t# For each built script, we want to:\n\t#   - Get the name of the script.\n\t#   - Get a link to the documentation.\n\t#   - Add it to the filter for non-developer items.\n\tlocal script_name script_names script_links script_filters script_list_markdown\n\tscript_links=()\n\tscript_names=()\n\tscript_filters=''\n\n\twhile read -r script; do\n\t\tscript_name=\"$(basename \"$script\" .sh)\"\n\t\tscript_names+=(\"$script_name\")\n\t\tscript_links+=(\"[\\`${script_name}\\`](https://github.com/eth-p/bat-extras/blob/${commit_newest}/doc/${script_name}.md)\")\n\t\tscript_filters=\"${script_filters}|$(printf \"%q\" \"$script_name\")\"\n\tdone < <(batextras:get_source_paths)\n\n\tscript_filters=\"${script_filters:1}\" # Remove the leading \"|\"\n\tscript_list_markdown=\"$(printf \"%s, \" \"${script_links[@]:0:$((${#script_links[@]} - 1))}\")\"\n\tscript_list_markdown=\"${script_list_markdown}and ${script_links[$((${#script_links[@]} - 1))]}\"\n\n\t# Get the changelog.\n\tlocal changelog changelog_dev\n\tchangelog=\"$(batextras:generate_changelog \"$commit_oldest\" \"$commit_newest\" \"$script_filters\")\"\n\tchangelog_dev=\"$(batextras:generate_changelog \"$commit_oldest\" \"$commit_newest\" \"test|developer|ci|build\")\"\n\n\t# Print the template.\n\t{ sed '/\\\\$/{N;s/\\\\\\n//;s/\\n//p;}'; } <<- EOF\n\t\tThis contains the latest versions of ${script_list_markdown} as of commit [${commit_newest}](${commit_newest_url}) (${date_str}).\n\n\t\t**This is provided as a convenience only.**\n\t\tI would still recommend following the installation instructions in [the README](https://github.com/eth-p/bat-extras#installation-) for the most up-to-date versions.\n\n\t\t### Changes\n\t\t${changelog}\n\n\t\t### Developer\n\t\t<details>\n\t\t<div markdown=\"1\">\n\n\t\t${changelog_dev}\n\n\t\t</div>\n\t\t</details>\n\tEOF\n\n}\n\n# -----------------------------------------------------------------------------\n# Main:\n# Only run everything past this point if the script is not sourced.\n# -----------------------------------------------------------------------------\n(return 0 2>/dev/null) && return 0\n\nHERE=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nDATE=\"$(date +%Y%m%d)\"\nVERSION=\"$(< \"${HERE}/version.txt\")\"\nVERSION_EXPECTED=\"$(date +%Y.%m.%d)\"\nLIB=\"$HERE/lib\"\nSRC=\"$HERE/src\"\nsource \"${LIB}/print.sh\"\nsource \"${LIB}/opt.sh\"\n# -----------------------------------------------------------------------------\nset -euo pipefail\n\n# -----------------------------------------------------------------------------\n# Options.\nOPT_ARTIFACT=\"bat-extras-${DATE}.zip\"\nOPT_SINCE=\nOPT_BAD_IDEA=false\nOPT_BIN_DIR=\"$(batextras:get_output_bin_directory)\"\nOPT_DOC_DIR=\"$(batextras:get_docs_directory)\"\nOPT_MAN_DIR=\"$(batextras:get_output_man_directory)\"\n\nwhile shiftopt; do\n\tcase \"$OPT\" in\n\t\t--since)\n\t\t\tshiftval\n\t\t\tOPT_SINCE=\"$OPT_VAL\"\n\t\t\tif ! batextras:git rev-parse \"$OPT_SINCE\" &> /dev/null; then\n\t\t\t\tprintc \"%{RED}%s: unknown commit or tag for '%s'\\n\" \"$PROGRAM\" \"$OPT\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\t;;\n\n\t\t--badidea)\n\t\t\tOPT_BAD_IDEA=true\n\t\t\t;;\n\n\t\t*)\n\t\t\tprintc \"%{RED}%s: unknown option '%s'%{CLEAR}\" \"$PROGRAM\" \"$OPT\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\ndone\n\n# -----------------------------------------------------------------------------\n# Verify the version matches today's date.\n\nVERSION=\"$(source \"${LIB}/constants.sh\" && echo \"${PROGRAM_VERSION}\")\"\nVERSION_EXPECTED=\"$(date +%Y.%m.%d)\"\n\nif [[ \"$VERSION\" != \"$VERSION_EXPECTED\" ]] && ! \"$OPT_BAD_IDEA\"; then\n\tprintc \"%{RED}The expected version does not match %{DEFAULT}version.txt%{RED}!%{CLEAR}\\n\"\n\tprintc \"%{RED}Expected: %{YELLOW}%s%{CLEAR}\\n\" \"$VERSION_EXPECTED\"\n\tprintc \"%{RED}Actual:   %{YELLOW}%s%{CLEAR}\\n\" \"$VERSION\"\n\texit 1\nfi\n\n# -----------------------------------------------------------------------------\n# Verify the working tree is clean-ish.\n\nif ! \"$OPT_BAD_IDEA\"; then\n\twhile read -r flags file; do\n\t\tif [[ \"$flags\" =~ M ]]; then\n\t\t\tprintc \"%{RED}Found an uncommitted change in %{DEFAULT}%s%{RED}!%{CLEAR}\\n\" \"$file\"\n\t\t\texit 1\n\t\tfi\n\tdone < <(batextras:git status --porcelain)\nfi\n\n# -----------------------------------------------------------------------------\n# Build files.\n\n# Clean the old files.\n# Make sure it's not trying to delete /bin or /man first, though.\nif [[ \"$OPT_BIN_DIR\" != \"/bin\" ]]; then rm -rf \"$OPT_BIN_DIR\"; fi\nif [[ \"$OPT_MAN_DIR\" != \"/man\" ]]; then rm -rf \"$OPT_MAN_DIR\"; fi\n\n# Generate the new bin files.\nprintc \"%{YELLOW}Building scripts...%{CLEAR}\\n\"\n\"$HERE/build.sh\" --minify=all --alternate-executable='bat' --no-inline &>/dev/null || {\n\tprintc \"%{RED}FAILED TO BUILD SCRIPTS.%{CLEAR}\\n\"\n\tprintc \"%{RED}CAN NOT PROCEED WITH RELEASE.%{CLEAR}\\n\"\n\texit 1\n}\n\n# -----------------------------------------------------------------------------\n# Build package.\n\nprintc \"%{YELLOW}Packaging artifacts...%{CLEAR}\\n\"\nbatextras:create_package \"$OPT_ARTIFACT\"\nprintc \"%{YELLOW}Package created as %{BLUE}%s%{YELLOW}.%{CLEAR}\\n\" \"$OPT_ARTIFACT\"\n\n# -----------------------------------------------------------------------------\n# Print template description package.\n\nprintc \"%{YELLOW}Release description:%{CLEAR}\\n\"\nbatextras:generate_release_notes \\\n\t\"$(batextras:get_previous_tag_name)\" \\\n\t\"$(batextras:get_current_commit)\"\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 1.5263671875,
          "content": "#!/usr/bin/env bash\n# -----------------------------------------------------------------------------\n# bat-extras | Copyright (C) 2019 eth-p | MIT License\n#\n# Repository: https://github.com/eth-p/bat-extras\n# Issues:     https://github.com/eth-p/bat-extras/issues\n# -----------------------------------------------------------------------------\nHERE=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nLIB=\"${HERE}/lib\"\nsource \"${LIB}/opt.sh\"\n# -----------------------------------------------------------------------------\ncd \"$HERE\" || exit\n\n# -----------------------------------------------------------------------------\nexport TEST_ENV_LIB=\"${HERE}/lib\"\nexport TEST_ENV_BIN_DIR=\"${HERE}/src\"\nexport TEST_ENV_BIN_SUFFIX=\".sh\"\nexport TEST_ENV_HOME=\"${HERE}/test/data\"\nexport TEST_ENV_PATH=\"${HERE}/test/shimexec:${PATH}\"\nexport TEST_DIR=\"${HERE}/test/suite\"\nexport TEST_PWD=\"${HERE}/test/data\"\nexport TEST_SHIM_PATH=\"${HERE}/test/shim\"\nexport SNAPSHOT_DIR=\"${HERE}/test/snapshot\"\n\nOPT_ARGV=()\nSHIFTOPT_SHORT_OPTIONS=\"PASS\"\nwhile shiftopt; do\n\tcase \"$OPT\" in\n\t--compiled)\n\t\tTEST_ENV_BIN_DIR=\"${HERE}/bin\"\n\t\tTEST_ENV_BIN_SUFFIX=\"\"\n\t\t;;\n\t*)\n\t\tif [[ \"$OPT_VAL\" ]]; then\n\t\t\tOPT_ARGV+=(\"${OPT}=${OPT_VAL}\")\n\t\telse\n\t\t\tOPT_ARGV+=(\"$OPT\")\n\t\tfi ;;\n\tesac\ndone\n\n# -----------------------------------------------------------------------------\n# Initialize submodule if it isn't already.\nif ! [[ -f \"${HERE}/.test-framework/bin/best.sh\" ]]; then\n\tgit submodule init '.test-framework'\n\tgit submodule update\nfi\n\n# Run best.\nexec \"${HERE}/.test-framework/bin/best.sh\" \"${OPT_ARGV[@]}\"\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.txt",
          "type": "blob",
          "size": 0.0107421875,
          "content": "2024.08.24\n"
        }
      ]
    }
  ]
}