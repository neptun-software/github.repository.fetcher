{
  "metadata": {
    "timestamp": 1736568396509,
    "page": 340,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Fakerr/git-recall",
      "stars": 2118,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2017 Berrahal Walid\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.30078125,
          "content": "PREFIX ?= /usr/local\nBINPREFIX ?= \"$(PREFIX)/bin\"\n\nLIB=git-recall\n\n.PHONY: all install uninstall\n\nall:\n\t@echo \"usage: make install\"\n\t@echo \"       make uninstall\"\n\ninstall:\n\tmkdir -p $(BINPREFIX)\n\tinstall -m 0755 $(LIB) $(BINPREFIX)\n\nuninstall:\n\ttest -d $(BINPREFIX) && \\\n\tcd $(BINPREFIX) && \\\n\trm -f $(LIB)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.7626953125,
          "content": "# git-recall\n\n> Simple and handy tool to easily recall what you've done\n\n![git recall](http://imgur.com/zuw2LqW.gif)\n\n## Purpose\n\n`git-recall` is a simple tool that allows you to easily go through your commits and\ncheck what you or other contributors in your team did. It doesn't aim to be a replacement for the\n`git log` command, but just to be a convenient way to recall what you've done from your terminal.\n\n\n## Usage\n\n```sh\n$ git recall   [-a <author name>]\n               [-d <days-ago>]\n               [-b <branch name>]\n               [-p <paths>]\n               [-f]\n               [-h]\n               [-v]\n```\n\n##### Options description:\n\n- `-a`      - Restrict search for a specific user (use -a \"all\" for all users)\n- `-d`      - Display commits for the last n days\n- `-b`      - Specify branch to display commits from\n- `-p`      - Specify path/s or file/s to display commits from\n- `-f`      - Fetch the latest changes\n- `-h`      - Show help screen\n- `-v`      - Show version\n\n##### How to use:\n\nOnce the commits are displayed, you can use either the `arrow keys` or `j/k` to switch between commits,\npress `TAB` or `e` to `expand/reduce` the commit's diff or `q` to quit.\n\n##### Limitations:\n\nwhen the number of lines between the commits list and a commit's diff is higher than the current terminal session's number of lines,\nthe result will be displayed using the [`less`](http://www.tutorialspoint.com/unix_commands/less.htm) program which will open the diff in a separate screen.\nYou can still use either `TAB` or `q` to return to the commits list.\n\n## Examples\n\n```sh\n$ git recall\n# By default (without options), the command will display commits from yesterday and\n# for the current user.\n```\n\n\n```sh\n$ git recall -d 5 -a \"Doge\"\n# The command will show all Doge's commits from 5 days ago.\n\n$ git recall -d 5 -a \"all\"\n# The command will show commits of all contributors from 5 days ago.\n```\n\n\n```sh\n$ git recall -f\n# Fetch commits beforehand.\n```\n\n## Installation\n\n##### Without using tools\n\nYou can install it by simply copying the `git-recall` script into any existing path\n(e.g. `/usr/local/bin`) or create your own directory and add it to the `PATH` variable.\n\nMake sure to run `chmod +x /usr/local/bin/git-recall` or the directory in which you copied it to. \n\n##### Using NPM\nUse `npm` to install the project.\n\n```sh\nnpm install --global git-recall\n```\n##### Manual install\nClone the project and install it using make install.\n\n```sh\n$ git clone https://github.com/Fakerr/git-recall.git\n$ cd git-recall\n$ sudo make install\n```\n## Requirements\n- OS: Linux or OSX\n- Bash 4.3 or more\n- Tools: git, less, sed\n\n##### Optional Requirements\n- For a better UX, it's recommended to have installed the `lesskey` program.\n\n## Contribution\nPull requests are welcome, along with any feedback or ideas.\n\n\n## License\n\nMIT\n"
        },
        {
          "name": "git-recall",
          "type": "blob",
          "size": 9.4267578125,
          "content": "#!/usr/bin/env bash\n\n\n# usage info\nusage() {\n  cat <<EOF\n  Usage: git recall [options]\n  Options:\n    -d, --date              Show logs for last n days.\n    -a, --author            Author name (use -a \"all\" for all users).\n    -b, --branch            Specify branch to display commits from.\n    -p  --path              Specify path or filename to display commits from.\n    -f, --fetch             fetch commits.\n    -h, --help              This message.\n    -v, --version           Show version.\n    --                      End of options.\nEOF\n}\n\n# Global variables\norig_stty=$(stty -g)   # Store original terminal settings\nAUTHOR=\"\"\nFETCH=false\nGIT_FORMAT=\"\"\nGIT_LOG=\"\"\nCOMMITS=\"\"\nSINCE=\"1 days ago\"     # show logs for last day by default\nCOMMITS_UNCOL=()       # commits without colors\nSED_CMD=\"\"             # Sed command to use according OS.\nLESSKEY=false\nVERSION=\"1.2.4\"\nBRANCH=\"\"\nSEARCH_PATH=\"\"\n\n# Set key bindings.\nau=\"`echo -e '\\e[A'`\" # arrow up\nad=\"`echo -e '\\e[B'`\" # arrow down\nec=\"`echo -e '\\e'`\"   # escape\nnl=\"`echo -e '\\n'`\"   # newline\nau_1=\"k\"              # arrow up\nad_1=\"j\"              # arrow down\nnl_1=\"e\"              # expand\n\n# Colored output.\nfunction colored() {\n    GREEN=$(tput setaf 4)\n    YELLOW=$(tput setaf 3)\n    NORMAL=$(tput sgr0)\n    REVERSE=$(tput rev)\n} \n\n# Uncolored output.\nfunction uncolored() {\n    GREEN=\"\"\n    YELLOW=\"\"\n    NORMAL=\"\"\n    REVERSE=\"\"\n}\n\n# Clear screen from cursor to end of screen\nfunction clear_screen() {\n    echo -e \"\\E[J\"\n    tput cuu1\n}\n\n# Are we in a git repo?\nif [[ ! -d \".git\" ]] && ! git rev-parse --git-dir &>/dev/null; then\n    echo \"abort: not a git repository.\" 1>&2\n    exit 1\nfi\n\n# Parse options\nwhile [[ \"$1\" =~ ^- && ! \"$1\" == \"--\" ]]; do\n    case $1 in\n\t-v | --version )\n\t    echo \"$VERSION\"\n\t    exit\n\t    ;;\n\t-d | --date )\n\t    SINCE=\"$2 days ago\"\n\t    shift;\n\t    ;;\n\t-a | --author )\n\t    AUTHOR=\"$2\"\n\t    shift\n\t    ;;\n\t-f | --fetch )\n\t    FETCH=true\n\t    ;;\n\t-h | --help )\n\t    usage\n\t    exit\n\t    ;;\n\t-b | --branch )\n            BRANCH=\"$2\"\n            shift\n            ;;\n        -p | --path )\n            SEARCH_PATH=\"$2\"\n            shift\n            ;;\n\t* )\n\t    echo \"abort: unknown argument\" 1>&2\n\t    exit 1\n    esac\n    shift\ndone\nif [[ \"$1\" == \"--\" ]]; then shift; fi\n\n# Enable colors if supported by terminal.\nif [[ -t 1 ]] && [[ -n \"$TERM\" ]] && which tput &>/dev/null && tput colors &>/dev/null; then\n    ncolors=$(tput colors)\n    if [[ -n \"$ncolors\" ]] && [[ \"$ncolors\" -ge 8 ]] ; then\n\tcolored\n    else\n\tuncolored\n    fi\nelse\n    uncolored\nfi\n\n# Set AUTHOR to current user if no param passed or display for all users if param equal to \"all\". \nif [[ ! -n $AUTHOR ]]; then\n    AUTHOR=$(git config user.name 2>/dev/null)\nelif [[ $AUTHOR = \"all\" ]]; then\n    AUTHOR=\".*\"\nfi\n\n# Fetch changes before.\nif [[ $FETCH == true ]]; then\n    echo \"${GREEN}Fetching changes...${NORMAL}\"\n    git fetch --all &> /dev/null\n    tput cuu1\n    clear_screen\nfi\n\n# Log template.\nGIT_FORMAT=\"%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\"\n\n# Log command.\nGIT_LOG=\"git log --pretty=format:'${GIT_FORMAT}'  \n           --author \\\"$AUTHOR\\\"\n           --since \\\"$SINCE\\\" --abbrev-commit --no-merges $BRANCH $SEARCH_PATH\"\n\n# Change temporary the IFS to store GIT_LOG's output into an array.\nIFS=$'\\n'\nCOMMITS=($(eval ${GIT_LOG} 2>/dev/null))\nunset IFS\n\nNI=${#COMMITS[@]}                             # Total number of items.\nSN=$(( `tput lines` - 1 ))                    # Screen's number of lines.\nCN=$(tput cols)                               # Screen's number of columns.\nTN=$(( $NI < $((SN -1)) ? $NI : $((SN -1))))  # Number of lines that we will display.\nOFFSET=0                                      # Incremented by one each time a commit's length is higher than teminal width.\n\n# If there is no items, exit.\nif [[ $NI = 0 ]]; then\n    if [[ $AUTHOR = \".*\" ]]; then\n   \techo \"${YELLOW}All contributors did nothing during this period.${NORMAL}\" && exit 0\n    else\n   \techo \"${YELLOW}The contributor \\\"${AUTHOR}\\\" did nothing during this period.${NORMAL}\" && exit 0\n    fi\nfi\n\n# Check if lesskey is installed.\nif command -v lesskey &> /dev/null; then\n    LESSKEY=true\nfi\n\n# Set correct sed command according OS's type\ncase \"$OSTYPE\" in\n    darwin*) SED_CMD=\"sed -E s/\"$'\\E'\"\\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g\" ;;\n    *)       SED_CMD=\"sed -r s/\\x1B\\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g\" ;;\nesac\n\n# Create array with uncolred commits (removing escape sequences using sed)\nfor elt in \"${COMMITS[@]}\"\ndo\n    ELT=\"$(echo \"$elt\" | $SED_CMD)\" # remove colors escape codes\n    COMMITS_UNCOL+=(\"$ELT\")\ndone\n\n# Add +1 to OFFSET if a commit's length is bigger than the current terminal session's width. (This is to fix a redraw issue)\nfor C in \"${COMMITS_UNCOL[@]}\"\ndo\n    if [[ ${#C} -gt $CN ]]; then\n\tOFFSET=$(( OFFSET + 1 ))\n    fi\ndone\n\n# Create a temporary lesskey file to change the keybindings so the user can use the TAB key to quit less. (more convenient)  \nif [[ $LESSKEY = true ]]; then\n    echo \"\\t quit\" | lesskey -o /tmp/lsh_less_keys_tmp -- - &> /dev/null\nfi\n\n# Get commit's diff.\nfunction get_diff() {\n    ELT=\"$(echo \"${COMMITS_UNCOL[$CP-1]}\")\"\n    DIFF_TIP=${ELT:0:7}\n    DIFF_CMD=\"git show $DIFF_TIP --color=always $SEARCH_PATH\"\n    DIFF=$(eval ${DIFF_CMD} 2>/dev/null)\n    tmp_diff=\"$(echo \"$DIFF\" | $SED_CMD)\"\n    off=$(echo \"$tmp_diff\" | grep -c \".\\{$CN\\}\") # Number of lines in the diff that are longer than terminal width.\n    DIFF_LINES_NUMBER=\"$(echo \"$DIFF\" | wc -l)\"\n    DIFF_LINES_NUMBER=$(( DIFF_LINES_NUMBER + off ))\n}\n\n# This function will print the diff according the commit's tip. If the diff is too long, the result will be displayed using 'less'. \nfunction print_diff() {\n    get_diff\n    if [[ $(( TN + DIFF_LINES_NUMBER + OFFSET )) -ge $(( `tput lines` - 1 )) ]]; then\n\ttrap - INT\n\tif [[ $LESSKEY = true ]]; then\n\t    echo \"$DIFF\" | less -r -k /tmp/lsh_less_keys_tmp\n\telse \n\t    echo \"$DIFF\" | less -r\n\tfi\n\ttrap cleanup_and_exit INT\n\tclear_screen\n    else \n\tstop=false\n\tclear_screen\n\tfor i in `seq 1 $TN`\n\tdo\n\t    echo -n \"$NORMAL\"\n\t    [[ $CP == \"$i\" ]] && echo -n \"$REVERSE\"\n\t    echo \"${COMMITS[$i - 1]}\"\n\t    [[ $CP == \"$i\" ]] && echo \"$DIFF\"\n\tdone\n\t# Wait for user action.\n\twhile ! $stop\n\tdo\n\t    read -sn 1 key\n\t    case \"$key\" in\n\t\t\"$nl\" | \"$nl_1\")\n\t\t    stop=true\n\t\t    ;;\n\t\t\"q\")\n\t\t    stop=true\n\t\t    END=true\n\t\t    ;;\n\t    esac\n\tdone\n\t[[ $END = false ]] && tput cuu $(( TN + DIFF_LINES_NUMBER + OFFSET )) && clear_screen\n    fi\n}\n\n# Calculate OFFSET to avoid bad redraw.\nfunction calculate_offset {\n    tmp=1\n    index=$(( SI -1 ))\n    while [[ $tmp -lt $SN ]]\n    do\n    \tel=${COMMITS_UNCOL[$index]}\n    \tif [[ ${#el} -gt $CN ]] && [[ $CP -lt $((SN -1)) ]]; then\n    \t    OFFSET_2=$(( OFFSET_2 + 1 ))\n    \t    tmp=$(( tmp + 1 ))\n    \tfi\n    \ttmp=$(( tmp + 1 ))\n    \tindex=$(( index + 1 ))\n    done\n}\n\n# Reset changes made by this script before exiting\nfunction cleanup_and_exit() {\n    # remove temporary less keybindings\n    [[ $LESSKEY = true ]] && rm /tmp/lsh_less_keys_tmp\n\n    tput cuu 1      # move cursor up one line. (remove extra line)\n    tput cnorm      # unhide cursor\n    echo \"$NORMAL\"  # normal colors\n    stty \"$orig_stty\" > /dev/null 2>&1\n    exit\n}\n\n# Catch a control-C interrupt and perform cleanup operations before exiting\ntrap cleanup_and_exit INT\n\n{ # capture stdout to stderr\n\ntput civis   # hide cursor.\nCP=1         # current position\nSI=1         # index\nEND=false    # end while loop\nEXT=0        # Used to extend the number of lines to display.\n\nwhile ! $END\ndo\n    # When the number of item is higher than screen's number of lines, OFFSET_2 is recalculated each time we select a new item.\n    # Set last index to print. (based on OFFSET)\n    END_INDEX=0 # Index for the last item to display\n    if [[  $TN == $NI ]]; then \n\tEND_INDEX=$TN\n\tOFFSET_2=$OFFSET\n    elif [[  $TN == $(( SN - 1 )) ]]; then\n\t# Calculate new OFFSET.\n\tif [[ $OFFSET != 0 ]]; then \n   \t    [[ $CP -lt $((SN -1)) ]] && OFFSET_2=0\n   \t    EXT=1\n   \t    calculate_offset\n\tfi\n\tEND_INDEX=$(( TN + SI -1 + EXT - OFFSET_2 ))\n    fi\n\n    # Loop and echo commits\n    for i in `seq $SI $END_INDEX`\n    do\n\techo -n \"$NORMAL\"\n\t[[ $CP == $i ]] && echo -n \"$REVERSE\"\n\techo \"${COMMITS[$i - 1]}\"\n    done\n\n    read -sn 1 key\n    [[ \"$key\" == \"$ec\" ]] &&\n    {\n\tread -sn 2 k2\n\tkey=\"$key$k2\"\n    }\n\n    case \"$key\" in\n\t\"$au\" | \"$au_1\")\n            CP=$(( CP - 1 ))\n            [[ $CP == 0 ]] && [[ $SI == 1 ]] && [[ $TN == $(( SN - 1 )) ]] && CP=$NI && SI=$(( NI - SN + 2 + OFFSET_2 ))\n            [[ $CP == 0 ]] && [[ $SI == 1 ]] && [[ $TN == $NI ]] && CP=$TN\n            [[ $CP == $(( SI - 1 )) ]] && [[ $SI != 1 ]] && SI=$(( SI - 1 ))\n\n   \t    [[ $TN != $(( SN - 1 )) ]] && tput cuu $(( TN + OFFSET_2 ))\n   \t    [[ $TN == $(( SN - 1 )) ]] && tput cuu $(( TN + EXT ))\n            [[ $SI != 1 ]] && clear_screen\n            ;;\n\t\"$ad\" | \"$ad_1\")\n   \t    CP=$(( CP + 1 ))\n            [[ $CP == $(( NI + 1 )) ]] && CP=1 && SI=1 \n            [[ $CP == $(( SN + SI - 1 + EXT - OFFSET_2 )) ]] && [[ $TN == $(( SN - 1 )) ]] && SI=$(( SI + 1 ))\n\n   \t    [[ $TN != $(( SN - 1 )) ]] && tput cuu $(( TN + OFFSET_2 ))\n   \t    [[ $TN == $(( SN - 1 )) ]] && tput cuu $(( TN + EXT ))\n            [[ $SI != 1 ]] && clear_screen\n            [[ $SI = 1 ]] && [[ $CP = 1 ]] && clear_screen\n            ;;\n\t\"$nl\" | \"$nl_1\")\n   \t    [[  $TN == $NI ]] && tput cuu $(( TN + OFFSET_2 ))\n   \t    [[  $TN != $NI ]] && tput cuu $(( TN + EXT ))\n            print_diff \n            ;;\n\t\"q\")\n            si=false\n            END=true\n            ;;\n\t* )\n   \t    tput cuu $(( TN + OFFSET_2 ))\n    esac\ndone\n\ncleanup_and_exit\n\n} >&2 # END capture\n\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.515625,
          "content": "{\n  \"name\": \"git-recall\",\n  \"version\": \"1.2.4\",\n  \"description\": \"Simple and convenient Git tool to easily recall what you've done\",\n  \"main\": \"\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/Fakerr/git-recall.git\"\n  },\n  \"bin\": {\n    \"git-recall\": \"./git-recall\"\n  },\n  \"keywords\": [\n    \"git\",\n    \"log\",\n    \"cli\"\n  ],\n  \"author\": \"Walid Berrahal\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/Fakerr/git-recall\"\n}\n"
        }
      ]
    }
  ]
}