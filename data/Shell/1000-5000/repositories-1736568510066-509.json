{
  "metadata": {
    "timestamp": 1736568510066,
    "page": 509,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUxOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cfenollosa/bashblog",
      "stars": 1683,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.4609375,
          "content": "bashblog\n========\n\nA single Bash script to create blogs. \n\nI created it because I wanted a very, very simple way to post entries to a blog by using a public folder on my server, without any special requirements and dependencies. Works on GNU/Linux, OSX and BSD.\n\n*How simple? Just type `./bb.sh post` and start writing your blogpost.*\n\n[![asciinema](https://asciinema.org/a/4nr44km9ipow4s7u2w2eabeik.png)](https://asciinema.org/a/4nr44km9ipow4s7u2w2eabeik)\n\nYou can see a sample here: [read the initial blog post](https://web.archive.org/web/20130520204024/http://mmb.pcb.ub.es/~carlesfe/blog/creating-a-simple-blog-system-with-a-500-line-bash-script.html). That page was 100% generated using bashblog, no additional tweaking.\n\n[![demo](https://raw.githubusercontent.com/cfenollosa/bashblog/gh-pages/images/demo_thumb.png)](https://raw.githubusercontent.com/cfenollosa/bashblog/gh-pages/images/demo.png)\n\nCheck out [other bashblog users](https://www.google.com/search?q=%22Generated+with+bashblog,+a+single+bash+script+to+easily+create+blogs+like+this+one%22)\n\n\nUsage\n-----\n\nDownload the code and copy bb.sh into a public folder (for example, `$HOME/public_html/blog`) and run\n\n    ./bb.sh\n\nThis will show the available commands. If the file is not executable, type `chmod +x bb.sh` and retry.\n\n**Before creating your first post, you may want to configure the blog settings (title, author, etc).\nRead the Configuration section below for more information**\n\nTo create your first post, just run:\n\n    ./bb.sh post\n    \nIt will try to use Markdown, if installed. To force HTML:\n\n    ./bb.sh post -html\n    \nThe script will handle the rest.\n\nWhen you're done, access the public URL for that folder  (e.g. `http://server.com/~username/blog`) \nand you should see the index file and a new page for that post!\n\n\nHow to...\n---------\n\nPlease [read the wiki](https://github.com/cfenollosa/bashblog/wiki) to learn how to use the advanced features of Bashblog, such as headers and footers, static pages, and more.\n\n\nFeatures\n--------\n\n- Ultra simple usage: Just type a post with your favorite editor and the script does the rest. No templating.\n- No installation required. Download `bb.sh` and start blogging.\n- Zero dependencies. It runs just on base utils (`date`, `basename`, `grep`, `sed`, `head`, etc)\n- GNU/Linux, BSD and OSX compatible out of the box, no need for GNU `coreutils` on a Mac.\n  It does some magic to autodetect which command switches it needs to run depending on your system.\n- All content is static. You only need shell access to a machine with a public web folder.\n  *Tip: advanced users could mount a remote public folder via `ftpfs` and run this script locally*\n- Allows drafts, includes a simple but clean stylesheet, generates the RSS file automatically.\n- Support for tags/categories\n- Support for Markdown, Disqus comments, Twitter, Feedburner, Google Analytics.\n- The project is still maintained as of 2016. Bugs are fixed, and new features are considered (see \"Contributing\")\n- Everything stored in a single ~1k lines bash script, how cool is that?! ;) \n\n\nConfiguration\n-------------\n\nConfiguration is not required for a test drive, but if you plan on running your blog with bashblog, you will\nwant to change the default titles, author names, etc, to match your own.\n\nThere are two ways to configure the blog strings:\n\n- Edit `bb.sh` and modify the variables in the `global_variables()` function\n- Create a `.config` file with your configuration values -- useful if you don't want to touch the script and be able to update it regularly with git\n\nThe software will load the values in the script first, then overwrite them with the values in the `.config` file.\nThis means that you don't need to define all variables in the config file, only those which you need to override\nfrom the defaults.\n\nThe format of the `.config` file is just one `variablename=\"value\"` per line, just like in the `global_variables()`\nfunction. **Please remember:** quote the values, do not declare a variable with the dollar sign, do not use \nspaces around the equal sign.\n\nbashblog uses the `$EDITOR` environment value to open the text editor.\n\n\nDetailed features\n-----------------\n\n- A simple but nice and readable design, with nothing but the blog posts\n- **NEW on 2.0** Markdown support via a third-party library.  \n  The easiest method is to download\n  Gruber's [Markdown.pl](http://daringfireball.net/projects/markdown/)\n- Post preview\n- Save posts as drafts and resume editing later\n- HTML page for each post, using its title as the URL\n- Configurable number of posts on the front page\n- Automatic generation of an RSS file, feedburner support\n- Additional page containing an index of all posts\n- Automatically generates pages for each tag\n- Rebuild all files while keeping the original data\n- Comments delegated to Twitter, with additional Disqus support\n- An option for cookieless Twitter sharing, to comply with the \n[EU cookie law](https://github.com/cfenollosa/eu-cookie-law)\n- Google Analytics code support\n- Contains its own CSS so that everything is reasonably styled by default\n- Headers, footers, and in general everything that a well-structured html file needs\n- Support to add extra content on top of every page (e.g. banners, images, etc)\n- xhtml validation, CSS validation, RSS validation by the w3c\n- Automatic backup of the site every time you post (stored as `.backup.tar.gz`)\n\nRead the Changelog section for more updates or [check out the news on my blog](http://cfenollosa.com/blog/tag_bashblog.html)\n\n\nContributing\n------------\n\nBashblog started at 500 SLOC and it now has hit the 1000 SLOC barrier. \nIf we want to keep the code minimal and understandable, we need to make the difficult effort to restrain ourselves \nfrom adding too many features.\n\nAll bugfixes are welcome, but brand new features need to be strongly justified to get into the main tree. \nEvery new request will be honestly and civilly discussed on the comments. \nAs a guideline, pull requests should:\n\n- Fix a use case for some people (e.g. internationalization)\n- Add a use case which is arguably very common (e.g. disqus integration for comments)\n- Be very small when possible (a couple lines of code)\n- Don't require a significant rewrite of the code (Don't break `create_html_file()` or `write_entry()`, etc)\n- It must work on Linux, BSD and Mac. Beware of using GNU coreutils with non-POSIX flags (i.e. `date` or `grep`)\n- Follow the UNIX philosophy: do one thing and do it well, rely on third party software for external features, etc\n- **Always** keep backwards compatibility when using the default configuration\n\n\nChangelog\n---------\n- 2.10     Added `global_twitter_card_image`\n- 2.9      Added `body_begin_file_index`\n- 2.8      Bugfixes<br/>\n           Slavic language support thanks to Tomasz Jadowski<br/>\n           Removed the now defunct Twitter JSON API share count<br/>\n           Support for static, not managed by bashblog html files<br/>\n- 2.7      Store post date on a comment in the html file (#96).<br/>\n           On rebuild, the post date will be synchronised between comment date and file date, with precedence for comment date.\n- 2.6      Support for multiple authors, use a different `.config` for each one\n- 2.5      Massive code cleanup by Martijn Dekker<br/>\n           'tags' command<br/>\n           The word 'posts' in the tag list (both website and command) now has a singular form, check out `template_tags_posts_singular`\n- 2.4      Added Twitter summaries metadata for posts (#36)\n- 2.3.3    Removed big comment header.<br/>\n           Added option to display tags for cut articles on index pages (#61)<br/>\n           Cleaned up \"all posts\" page (#57)\n- 2.3.2    Option to use topsy instead of twitter for references\n- 2.3.1    Cookieless Twitter option\n- 2.3      Intelligent tag rebuilding and Markdown by default\n- 2.2      Flexible post title -> filename conversion\n- 2.1      Support for tags/categories.<br/>\n           'delete' command\n- 2.0.3    Support for other analytics code, via external file\n- 2.0.2    Fixed bug when $body_begin_file was empty.<br/>\n           Added extra line in the footer linking to the github project\n- 2.0.1    Allow personalized header/footer files\n- 2.0      Added Markdown support.<br/>\n           Fully support BSD date\n- 1.6.4    Fixed bug in localized dates\n- 1.6.3    Now supporting BSD date\n- 1.6.2    Simplified some functions and variables to avoid duplicated information\n- 1.6.1    'date' fix when hours are 1 digit.\n- 1.6.0    Disqus comments. External configuration file. Check of 'date' command version.\n- 1.5.1    Misc bugfixes and parameter checks\n- 1.5      Đurađ Radojičić (djura-san) refactored some code and added flexibility and i18n\n- 1.4.2    Now issues are handled at Github\n- 1.4.1    Some code refactoring\n- 1.4      Using twitter for comments, improved 'rebuild' command\n- 1.3      'edit' command\n- 1.2.2    Feedburner support\n- 1.2.1    Fixed the timestamps bug\n- 1.2      'list' command\n- 1.1      Draft and preview support\n- 1.0      Read http://is.gd/Bkdoru\n\n\nLicense\n-------\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "bb.sh",
          "type": "blob",
          "size": 46.572265625,
          "content": "#!/usr/bin/env bash\n\n# BashBlog, a simple blog system written in a single bash script\n# (C) Carlos Fenollosa <carlos.fenollosa@gmail.com>, 2011-2016 and contributors\n# https://github.com/carlesfe/bashblog/contributors\n# Check out README.md for more details\n\n# Global variables\n# It is recommended to perform a 'rebuild' after changing any of this in the code\n\n# Config file. Any settings \"key=value\" written there will override the\n# global_variables defaults. Useful to avoid editing bb.sh and having to deal\n# with merges in VCS\nglobal_config=\".config\"\n\n# This function will load all the variables defined here. They might be overridden\n# by the 'global_config' file contents\nglobal_variables() {\n    global_software_name=\"BashBlog\"\n    global_software_version=\"2.10\"\n\n    # Blog title\n    global_title=\"My fancy blog\"\n    # The typical subtitle for each blog\n    global_description=\"A blog about turtles and carrots\"\n    # The public base URL for this blog\n    global_url=\"http://example.com/blog\"\n\n    # Your name\n    global_author=\"John Smith\"\n    # You can use twitter or facebook or anything for global_author_url\n    global_author_url=\"http://twitter.com/example\" \n    # Your email\n    global_email=\"john@smith.com\"\n\n    # CC by-nc-nd is a good starting point, you can change this to \"&copy;\" for Copyright\n    global_license=\"CC by-nc-nd\"\n\n    # If you have a Google Analytics ID (UA-XXXXX) and wish to use the standard\n    # embedding code, put it on global_analytics\n    # If you have custom analytics code (i.e. non-google) or want to use the Universal\n    # code, leave global_analytics empty and specify a global_analytics_file\n    global_analytics=\"\"\n    global_analytics_file=\"\"\n\n    # Leave this empty (i.e. \"\") if you don't want to use feedburner, \n    # or change it to your own URL\n    global_feedburner=\"\"\n\n    # Change this to your username if you want to use twitter for comments\n    global_twitter_username=\"\"\n    # Default image for the Twitter cards. Use an absolute URL\n    global_twitter_card_image=\"\"\n    # Set this to false for a Twitter button with share count. The cookieless version\n    # is just a link.\n    global_twitter_cookieless=\"true\"\n    # Default search page, where tweets more than a week old are hidden\n    global_twitter_search=\"twitter\"\n\n    # Change this to your disqus username to use disqus for comments\n    global_disqus_username=\"\"\n\n\n    # Blog generated files\n    # index page of blog (it is usually good to use \"index.html\" here)\n    index_file=\"index.html\"\n    number_of_index_articles=\"8\"\n    # global archive\n    archive_index=\"all_posts.html\"\n    tags_index=\"all_tags.html\"\n\n    # Non blogpost files. Bashblog will ignore these. Useful for static pages and custom content\n    # Add them as a bash array, e.g. non_blogpost_files=(\"news.html\" \"test.html\")\n    non_blogpost_files=()\n\n    # feed file (rss in this case)\n    blog_feed=\"feed.rss\"\n    number_of_feed_articles=\"10\"\n    # \"cut\" blog entry when putting it to index page. Leave blank for full articles in front page\n    # i.e. include only up to first '<hr>', or '----' in markdown\n    cut_do=\"cut\"\n    # When cutting, cut also tags? If \"no\", tags will appear in index page for cut articles\n    cut_tags=\"yes\"\n    # Regexp matching the HTML line where to do the cut\n    # note that slash is regexp separator so you need to prepend it with backslash\n    cut_line='<hr ?\\/?>'\n    # save markdown file when posting with \"bb post -m\". Leave blank to discard it.\n    save_markdown=\"yes\"\n    # prefix for tags/categories files\n    # please make sure that no other html file starts with this prefix\n    prefix_tags=\"tag_\"\n    # personalized header and footer (only if you know what you're doing)\n    # DO NOT name them .header.html, .footer.html or they will be overwritten\n    # leave blank to generate them, recommended\n    header_file=\"\"\n    footer_file=\"\"\n    # extra content to add just after we open the <body> tag\n    # and before the actual blog content\n    body_begin_file=\"\"\n    # extra content to add just before we close </body>\n    body_end_file=\"\"\n    # extra content to ONLY on the index page AFTER `body_begin_file` contents\n    # and before the actual content\n    body_begin_file_index=\"\"\n    # CSS files to include on every page, f.ex. css_include=('main.css' 'blog.css')\n    # leave empty to use generated\n    css_include=()\n    # HTML files to exclude from index, f.ex. post_exclude=('imprint.html 'aboutme.html')\n    html_exclude=()\n\n    # Localization and i18n\n    # \"Comments?\" (used in twitter link after every post)\n    template_comments=\"Comments?\"\n    # \"Read more...\" (link under cut article on index page)\n    template_read_more=\"Read more...\"\n    # \"View more posts\" (used on bottom of index page as link to archive)\n    template_archive=\"View more posts\"\n    # \"All posts\" (title of archive page)\n    template_archive_title=\"All posts\"\n    # \"All tags\"\n    template_tags_title=\"All tags\"\n    # \"posts\" (on \"All tags\" page, text at the end of each tag line, like \"2. Music - 15 posts\")\n    template_tags_posts=\"posts\"\n    template_tags_posts_2_4=\"posts\"  # Some slavic languages use a different plural form for 2-4 items\n    template_tags_posts_singular=\"post\"\n    # \"Posts tagged\" (text on a title of a page with index of one tag, like \"My Blog - Posts tagged \"Music\"\")\n    template_tag_title=\"Posts tagged\"\n    # \"Tags:\" (beginning of line in HTML file with list of all tags for this article)\n    template_tags_line_header=\"Tags:\"\n    # \"Back to the index page\" (used on archive page, it is link to blog index)\n    template_archive_index_page=\"Back to the index page\"\n    # \"Subscribe\" (used on bottom of index page, it is link to RSS feed)\n    template_subscribe=\"Subscribe\"\n    # \"Subscribe to this page...\" (used as text for browser feed button that is embedded to html)\n    template_subscribe_browser_button=\"Subscribe to this page...\"\n    # \"Tweet\" (used as twitter text button for posting to twitter)\n    template_twitter_button=\"Tweet\"\n    template_twitter_comment=\"&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;\"\n    \n    # The locale to use for the dates displayed on screen\n    date_format=\"%B %d, %Y\"\n    date_locale=\"C\"\n    date_inpost=\"bashblog_timestamp\"\n    # Don't change these dates\n    date_format_full=\"%a, %d %b %Y %H:%M:%S %z\"\n    date_format_timestamp=\"%Y%m%d%H%M.%S\"\n    date_allposts_header=\"%B %Y\"\n\n    # Perform the post title -> filename conversion\n    # Experts only. You may need to tune the locales too\n    # Leave empty for no conversion, which is not recommended\n    # This default filter respects backwards compatibility\n    convert_filename=\"iconv -f utf-8 -t ascii//translit | sed 's/^-*//' | tr [:upper:] [:lower:] | tr ' ' '-' | tr -dc '[:alnum:]-'\"\n\n    # URL where you can view the post while it's being edited\n    # same as global_url by default\n    # You can change it to path on your computer, if you write posts locally\n    # before copying them to the server\n    preview_url=\"\"\n\n    # Markdown location. Trying to autodetect by default.\n    # The invocation must support the signature 'markdown_bin in.md > out.html'\n    [[ -f Markdown.pl ]] && markdown_bin=./Markdown.pl || markdown_bin=$(which Markdown.pl 2>/dev/null || which markdown 2>/dev/null)\n}\n\n# Check for the validity of some variables\n# DO NOT EDIT THIS FUNCTION unless you know what you're doing\nglobal_variables_check() {\n    [[ $header_file == .header.html ]] &&\n        echo \"Please check your configuration. '.header.html' is not a valid value for the setting 'header_file'\" &&\n        exit\n    [[ $footer_file == .footer.html ]] &&\n        echo \"Please check your configuration. '.footer.html' is not a valid value for the setting 'footer_file'\" &&\n        exit\n}\n\n\n# Test if the markdown script is working correctly\ntest_markdown() {\n    [[ -n $markdown_bin ]] &&\n        (\n        [[ $(\"$markdown_bin\" <<< $'line 1\\n\\nline 2') == $'<p>line 1</p>\\n\\n<p>line 2</p>' ]] ||\n        [[ $(\"$markdown_bin\" <<< $'line 1\\n\\nline 2') == $'<p>line 1</p>\\n<p>line 2</p>' ]]\n        )\n}\n\n\n# Parse a Markdown file into HTML and return the generated file\nmarkdown() {\n    out=${1%.md}.html\n    while [[ -f $out ]]; do out=${out%.html}.$RANDOM.html; done\n    $markdown_bin \"$1\" > \"$out\"\n    echo \"$out\"\n}\n\n\n# Prints the required google analytics code\ngoogle_analytics() {\n    [[ -z $global_analytics && -z $global_analytics_file ]]  && return\n\n    if [[ -z $global_analytics_file ]]; then\n        echo \"<script type=\\\"text/javascript\\\">\n\n        var _gaq = _gaq || [];\n        _gaq.push(['_setAccount', '${global_analytics}']);\n        _gaq.push(['_trackPageview']);\n\n        (function() {\n        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n        })();\n\n        </script>\"\n    else\n        cat \"$global_analytics_file\"\n    fi\n}\n\n# Prints the required code for disqus comments\ndisqus_body() {\n    [[ -z $global_disqus_username ]] && return\n\n    echo '<div id=\"disqus_thread\"></div>\n            <script type=\"text/javascript\">\n            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n               var disqus_shortname = '\"'$global_disqus_username'\"'; // required: replace example with your forum shortname\n\n            /* * * DONT EDIT BELOW THIS LINE * * */\n            (function() {\n            var dsq = document.createElement(\"script\"); dsq.type = \"text/javascript\"; dsq.async = true;\n            dsq.src = \"//\" + disqus_shortname + \".disqus.com/embed.js\";\n            (document.getElementsByTagName(\"head\")[0] || document.getElementsByTagName(\"body\")[0]).appendChild(dsq);\n            })();\n            </script>\n            <noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n            <a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>'\n}\n\n# Prints the required code for disqus in the footer\ndisqus_footer() {\n    [[ -z $global_disqus_username ]] && return\n    echo '<script type=\"text/javascript\">\n        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n        var disqus_shortname = '\"'$global_disqus_username'\"'; // required: replace example with your forum shortname\n\n        /* * * DONT EDIT BELOW THIS LINE * * */\n        (function () {\n        var s = document.createElement(\"script\"); s.async = true;\n        s.type = \"text/javascript\";\n        s.src = \"//\" + disqus_shortname + \".disqus.com/count.js\";\n        (document.getElementsByTagName(\"HEAD\")[0] || document.getElementsByTagName(\"BODY\")[0]).appendChild(s);\n    }());\n    </script>'\n}\n\n# Reads HTML file from stdin, prints its content to stdout\n# $1    where to start (\"text\" or \"entry\")\n# $2    where to stop (\"text\" or \"entry\")\n# $3    \"cut\" to remove text from <hr /> to <!-- text end -->\n#       note that this does not remove <hr /> line itself,\n#       so you can see if text was cut or not\nget_html_file_content() {\n    awk \"/<!-- $1 begin -->/, /<!-- $2 end -->/{\n        if (!/<!-- $1 begin -->/ && !/<!-- $2 end -->/) print\n        if (\\\"$3\\\" == \\\"cut\\\" && /$cut_line/){\n            if (\\\"$2\\\" == \\\"text\\\") exit # no need to read further\n            while (getline > 0 && !/<!-- text end -->/) {\n                if (\\\"$cut_tags\\\" == \\\"no\\\" && /^<p>$template_tags_line_header/ ) print \n            }\n        }\n    }\"\n}\n\n# Edit an existing, published .html file while keeping its original timestamp\n# Please note that this function does not automatically republish anything, as\n# it is usually called from 'main'.\n#\n# Note that it edits HTML file, even if you wrote the post as markdown originally\n# Note that if you edit title then filename might also change\n#\n# $1 \tthe file to edit\n# $2\t(optional) edit mode:\n#\t\"keep\" to keep old filename\n#\t\"full\" to edit full HTML, and not only text part (keeps old filename)\n#\tleave empty for default behavior (edit only text part and change name)\nedit() {\n    [[ ! -f \"${1%%.*}.html\" ]] && echo \"Can't edit post \"${1%%.*}.html\", did you mean to use \\\"bb.sh post <draft_file>\\\"?\" && exit -1\n    # Original post timestamp\n    edit_timestamp=$(LC_ALL=C date -r \"${1%%.*}.html\" +\"$date_format_full\" )\n    touch_timestamp=$(LC_ALL=C date -r \"${1%%.*}.html\" +\"$date_format_timestamp\")\n    tags_before=$(tags_in_post \"${1%%.*}.html\")\n    if [[ $2 == full ]]; then\n        $EDITOR \"$1\"\n        filename=$1\n    else\n        if [[ ${1##*.} == md ]]; then\n            test_markdown\n            if (($? != 0)); then\n                echo \"Markdown is not working, please edit HTML file directly.\"\n                exit\n            fi\n            # editing markdown file\n            $EDITOR \"$1\"\n            TMPFILE=$(markdown \"$1\")\n            filename=${1%%.*}.html\n        else\n            # Create the content file\n            TMPFILE=$(basename \"$1\").$RANDOM.html\n            # Title\n            get_post_title \"$1\" > \"$TMPFILE\"\n            # Post text with plaintext tags\n            get_html_file_content 'text' 'text' <\"$1\" | sed \"/^<p>$template_tags_line_header/s|<a href='$prefix_tags\\([^']*\\).html'>\\\\1</a>|\\\\1|g\" >> \"$TMPFILE\"\n            $EDITOR \"$TMPFILE\"\n            filename=$1\n        fi\n        rm \"$filename\"\n        if [[ $2 == keep ]]; then\n            parse_file \"$TMPFILE\" \"$edit_timestamp\" \"$filename\"\n        else\n            parse_file \"$TMPFILE\" \"$edit_timestamp\" # this command sets $filename as the html processed file\n            [[ ${1##*.} == md ]] && mv \"$1\" \"${filename%%.*}.md\" 2>/dev/null\n        fi\n        rm \"$TMPFILE\"\n    fi\n    touch -t \"$touch_timestamp\" \"$filename\"\n    touch -t \"$touch_timestamp\" \"$1\"\n    chmod 644 \"$filename\"\n    echo \"Posted $filename\"\n    tags_after=$(tags_in_post \"$filename\")\n    relevant_tags=$(echo \"$tags_before $tags_after\" | tr ',' ' ' | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\n    if [[ ! -z $relevant_tags ]]; then\n        relevant_posts=\"$(posts_with_tags $relevant_tags) $filename\"\n        rebuild_tags \"$relevant_posts\" \"$relevant_tags\"\n    fi\n}\n\n# Create a Twitter summary (twitter \"card\") for the post\n#\n# $1 the post file\n# $2 the title\ntwitter_card() {\n    [[ -z $global_twitter_username ]] && return\n    \n    echo \"<meta name='twitter:card' content='summary' />\"\n    echo \"<meta name='twitter:site' content='@$global_twitter_username' />\"\n    echo \"<meta name='twitter:title' content='$2' />\" # Twitter truncates at 70 char\n    description=$(grep -v \"^<p>$template_tags_line_header\" \"$1\" | sed -e 's/<[^>]*>//g' | tr '\\n' ' ' | sed \"s/\\\"/'/g\" | head -c 250) \n    echo \"<meta name='twitter:description' content=\\\"$description\\\" />\"\n\n    # For the image we try to locate the first image in the article\n    image=$(sed -n '2,$ d; s/.*<img.*src=\"\\([^\"]*\\)\".*/\\1/p' \"$1\") \n\n    # If none, then we try a global setting image\n    [[ -z $image ]] && [[ -n $global_twitter_card_image ]] && image=$global_twitter_card_image\n\n    # If none, return\n    [[ -z $image ]] && return\n\n    # Final housekeeping\n    [[ $image =~ ^https?:// ]] || image=$global_url/$image # Check that URL is absolute\n    echo \"<meta name='twitter:image' content='$image' />\"\n}\n\n# Adds the code needed by the twitter button\n#\n# $1 the post URL\ntwitter() {\n    [[ -z $global_twitter_username ]] && return\n\n    if [[ -z $global_disqus_username ]]; then\n        if [[ $global_twitter_cookieless == true ]]; then \n            id=$RANDOM\n\n            search_engine=\"https://twitter.com/search?q=\"\n\n            echo \"<p id='twitter'><a href='http://twitter.com/intent/tweet?url=$1&text=$template_twitter_comment&via=$global_twitter_username'>$template_comments $template_twitter_button</a> \"\n            echo \"<a href='$search_engine\"\"$1'><span id='count-$id'></span></a>&nbsp;</p>\"\n            return;\n        else \n            echo \"<p id='twitter'>$template_comments&nbsp;\"; \n        fi\n    else\n        echo \"<p id='twitter'><a href=\\\"$1#disqus_thread\\\">$template_comments</a> &nbsp;\"\n    fi  \n\n    echo \"<a href=\\\"https://twitter.com/share\\\" class=\\\"twitter-share-button\\\" data-text=\\\"$template_twitter_comment\\\" data-url=\\\"$1\\\"\"\n    echo \" data-via=\\\"$global_twitter_username\\\"\"\n    echo \">$template_twitter_button</a>\t<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=\\\"//platform.twitter.com/widgets.js\\\";fjs.parentNode.insertBefore(js,fjs);}}(document,\\\"script\\\",\\\"twitter-wjs\\\");</script>\"\n    echo \"</p>\"\n}\n\n# Check if the file is a 'boilerplate' (i.e. not a post)\n# The return values are designed to be used like this inside a loop:\n# is_boilerplate_file <file> && continue\n#\n# $1 the file\n#\n# Return 0 (bash return value 'true') if the input file is an index, feed, etc\n# or 1 (bash return value 'false') if it is a blogpost\nis_boilerplate_file() {\n    name=${1#./}\n    # First check against user-defined non-blogpost pages\n    for item in \"${non_blogpost_files[@]}\"; do\n        [[ \"$name\" == \"$item\" ]] && return 0\n    done\n\n    case $name in\n    ( \"$index_file\" | \"$archive_index\" | \"$tags_index\" | \"$footer_file\" | \"$header_file\" | \"$global_analytics_file\" | \"$prefix_tags\"* )\n        return 0 ;;\n    ( * ) # Check for excluded\n        for excl in \"${html_exclude[@]}\"; do\n            [[ $name == \"$excl\" ]] && return 0\n        done\n        return 1 ;;\n    esac\n}\n\n# Adds all the bells and whistles to format the html page\n# Every blog post is marked with a <!-- entry begin --> and <!-- entry end -->\n# which is parsed afterwards in the other functions. There is also a marker\n# <!-- text begin --> to determine just the beginning of the text body of the post\n#\n# $1     a file with the body of the content\n# $2     the output file\n# $3     \"yes\" if we want to generate the index.html,\n#        \"no\" to insert new blog posts\n# $4     title for the html header\n# $5     original blog timestamp\n# $6     post author\ncreate_html_page() {\n    content=$1\n    filename=$2\n    index=$3\n    title=$4\n    timestamp=$5\n    author=$6\n\n    # Create the actual blog post\n    # html, head\n    {\n        cat \".header.html\"\n        echo \"<title>$title</title>\"\n        google_analytics\n        twitter_card \"$content\" \"$title\"\n        echo \"</head><body>\"\n        # stuff to add before the actual body content\n        [[ -n $body_begin_file ]] && cat \"$body_begin_file\"\n        [[ $filename = $index_file* ]] && [[ -n $body_begin_file_index ]] && cat \"$body_begin_file_index\"\n        # body divs\n        echo '<div id=\"divbodyholder\">'\n        echo '<div class=\"headerholder\"><div class=\"header\">'\n        # blog title\n        echo '<div id=\"title\">'\n        cat .title.html\n        echo '</div></div></div>' # title, header, headerholder\n        echo '<div id=\"divbody\"><div class=\"content\">'\n\n        file_url=${filename#./}\n        file_url=${file_url%.rebuilt} # Get the correct URL when rebuilding\n        # one blog entry\n        if [[ $index == no ]]; then\n            echo '<!-- entry begin -->' # marks the beginning of the whole post\n            echo \"<h3><a class=\\\"ablack\\\" href=\\\"$file_url\\\">\"\n            # remove possible <p>'s on the title because of markdown conversion\n            title=${title//<p>/}\n            title=${title//<\\/p>/}\n            echo \"$title\"\n            echo '</a></h3>'\n            if [[ -z $timestamp ]]; then\n                echo \"<!-- $date_inpost: #$(LC_ALL=$date_locale date +\"$date_format_timestamp\")# -->\"\n            else\n                echo \"<!-- $date_inpost: #$(LC_ALL=$date_locale date +\"$date_format_timestamp\" --date=\"$timestamp\")# -->\"\n            fi\n            if [[ -z $timestamp ]]; then\n                echo -n \"<div class=\\\"subtitle\\\">$(LC_ALL=$date_locale date +\"$date_format\")\"\n            else\n                echo -n \"<div class=\\\"subtitle\\\">$(LC_ALL=$date_locale date +\"$date_format\" --date=\"$timestamp\")\"\n            fi\n            [[ -n $author ]] && echo -e \" &mdash; \\n$author\"\n            echo \"</div>\"\n            echo '<!-- text begin -->' # This marks the text body, after the title, date...\n        fi\n        cat \"$content\" # Actual content\n        if [[ $index == no ]]; then\n            echo -e '\\n<!-- text end -->'\n\n            twitter \"$global_url/$file_url\"\n\n            echo '<!-- entry end -->' # absolute end of the post\n        fi\n\n        echo '</div>' # content\n\n        # Add disqus commments except for index and all_posts pages\n        [[ $index == no ]] && disqus_body\n\n        # page footer\n        cat .footer.html\n        # close divs\n        echo '</div></div>' # divbody and divbodyholder \n        disqus_footer\n        [[ -n $body_end_file ]] && cat \"$body_end_file\"\n        echo '</body></html>'\n    } > \"$filename\"\n}\n\n# Parse the plain text file into an html file\n#\n# $1    source file name\n# $2    (optional) timestamp for the file\n# $3    (optional) destination file name\n# note that although timestamp is optional, something must be provided at its\n# place if destination file name is provided, i.e:\n# parse_file source.txt \"\" destination.html\nparse_file() {\n    # Read for the title and check that the filename is ok\n    title=\"\"\n    while IFS='' read -r line; do\n        if [[ -z $title ]]; then\n            # remove extra <p> and </p> added by markdown\n            title=$(echo \"$line\" | sed 's/<\\/*p>//g')\n            if [[ -n $3 ]]; then\n                filename=$3\n            else\n                filename=$title\n                [[ -n $convert_filename ]] &&\n                    filename=$(echo \"$title\" | eval \"$convert_filename\")\n                [[ -n $filename ]] || \n                    filename=$RANDOM # don't allow empty filenames\n\n                filename=$filename.html\n\n                # Check for duplicate file names\n                while [[ -f $filename ]]; do\n                    filename=${filename%.html}$RANDOM.html\n                done\n            fi\n            content=$filename.tmp\n        # Parse possible tags\n        elif [[ $line == \"<p>$template_tags_line_header\"* ]]; then\n            tags=$(echo \"$line\" | cut -d \":\" -f 2- | sed -e 's/<\\/p>//g' -e 's/^ *//' -e 's/ *$//' -e 's/, /,/g')\n            IFS=, read -r -a array <<< \"$tags\"\n\n            echo -n \"<p>$template_tags_line_header \" >> \"$content\"\n            for item in \"${array[@]}\"; do\n                echo -n \"<a href='$prefix_tags$item.html'>$item</a>, \"\n            done | sed 's/, $/<\\/p>/g' >> \"$content\"\n        else\n            echo \"$line\" >> \"$content\"\n        fi\n    done < \"$1\"\n\n    # Create the actual html page\n    create_html_page \"$content\" \"$filename\" no \"$title\" \"$2\" \"$global_author\"\n    rm \"$content\"\n}\n\n# Manages the creation of the text file and the parsing to html file\n# also the drafts\nwrite_entry() {\n    test_markdown && fmt=md || fmt=html\n    f=$2\n    [[ $2 == -html ]] && fmt=html && f=$3\n\n    if [[ -n $f ]]; then\n        TMPFILE=$f\n        if [[ ! -f $TMPFILE ]]; then\n            echo \"The file doesn't exist\"\n            delete_includes\n            exit\n        fi\n        # guess format from TMPFILE\n        extension=${TMPFILE##*.}\n        [[ $extension == md || $extension == html ]] && fmt=$extension\n        # but let user override it (`bb.sh post -html file.md`)\n        [[ $2 == -html ]] && fmt=html\n        # Test if Markdown is working before re-posting a .md file\n        if [[ $extension == md ]]; then\n            test_markdown\n            if (($? != 0)); then\n                echo \"Markdown is not working, please edit HTML file directly.\"\n                exit\n            fi\n        fi\n    else\n        TMPFILE=.entry-$RANDOM.$fmt\n        echo -e \"Title on this line\\n\" >> \"$TMPFILE\"\n\n        [[ $fmt == html ]] && cat << EOF >> \"$TMPFILE\"\n<p>The rest of the text file is an <b>html</b> blog post. The process will continue as soon\nas you exit your editor.</p>\n\n<p>$template_tags_line_header keep-this-tag-format, tags-are-optional, example</p>\nEOF\n        [[ $fmt == md ]] && cat << EOF >> \"$TMPFILE\"\nThe rest of the text file is a **Markdown** blog post. The process will continue\nas soon as you exit your editor.\n\n$template_tags_line_header keep-this-tag-format, tags-are-optional, beware-with-underscores-in-markdown, example\nEOF\n    fi\n    chmod 600 \"$TMPFILE\"\n\n    post_status=\"E\"\n    filename=\"\"\n    while [[ $post_status != \"p\" && $post_status != \"P\" ]]; do\n        [[ -n $filename ]] && rm \"$filename\" # Delete the generated html file, if any\n        $EDITOR \"$TMPFILE\"\n        if [[ $fmt == md ]]; then\n            html_from_md=$(markdown \"$TMPFILE\")\n            parse_file \"$html_from_md\"\n            rm \"$html_from_md\"\n        else\n            parse_file \"$TMPFILE\" # this command sets $filename as the html processed file\n        fi\n\n        chmod 644 \"$filename\"\n        [[ -n $preview_url ]] || preview_url=$global_url\n        echo \"To preview the entry, open $preview_url/$filename in your browser\"\n\n        echo -n \"[P]ost this entry, [E]dit again, [D]raft for later? (p/E/d) \"\n        read -r post_status\n        if [[ $post_status == d || $post_status == D ]]; then\n            mkdir -p \"drafts/\"\n            chmod 700 \"drafts/\"\n\n            title=$(head -n 1 $TMPFILE)\n            [[ -n $convert_filename ]] && title=$(echo \"$title\" | eval \"$convert_filename\")\n            [[ -n $title ]] || title=$RANDOM\n\n            draft=drafts/$title.$fmt\n            mv \"$TMPFILE\" \"$draft\"\n            chmod 600 \"$draft\"\n            rm \"$filename\"\n            delete_includes\n            echo \"Saved your draft as '$draft'\"\n            exit\n        fi\n    done\n\n    if [[ $fmt == md && -n $save_markdown ]]; then\n        mv \"$TMPFILE\" \"${filename%%.*}.md\"\n    else\n        rm \"$TMPFILE\"\n    fi\n    chmod 644 \"$filename\"\n    echo \"Posted $filename\"\n    relevant_tags=$(tags_in_post $filename)\n    if [[ -n $relevant_tags ]]; then\n        relevant_posts=\"$(posts_with_tags $relevant_tags) $filename\"\n        rebuild_tags \"$relevant_posts\" \"$relevant_tags\"\n    fi\n}\n\n# Create an index page with all the posts\nall_posts() {\n    echo -n \"Creating an index page with all the posts \"\n    contentfile=$archive_index.$RANDOM\n    while [[ -f $contentfile ]]; do\n        contentfile=$archive_index.$RANDOM\n    done\n\n    {\n        echo \"<h3>$template_archive_title</h3>\"\n        prev_month=\"\"\n        while IFS='' read -r i; do\n            is_boilerplate_file \"$i\" && continue\n            echo -n \".\" 1>&3\n            # Month headers\n            month=$(LC_ALL=$date_locale date -r \"$i\" +\"$date_allposts_header\")\n            if [[ $month != \"$prev_month\" ]]; then\n                [[ -n $prev_month ]] && echo \"</ul>\"  # Don't close ul before first header\n                echo \"<h4 class='allposts_header'>$month</h4>\"\n                echo \"<ul>\"\n                prev_month=$month\n            fi\n            # Title\n            title=$(get_post_title \"$i\")\n            echo -n \"<li><a href=\\\"$i\\\">$title</a> &mdash;\"\n            # Date\n            date=$(LC_ALL=$date_locale date -r \"$i\" +\"$date_format\")\n            echo \" $date</li>\"\n        done < <(ls -t ./*.html)\n        echo \"\" 1>&3\n        echo \"</ul>\"\n        echo \"<div id=\\\"all_posts\\\"><a href=\\\"./$index_file\\\">$template_archive_index_page</a></div>\"\n    } 3>&1 >\"$contentfile\"\n\n    create_html_page \"$contentfile\" \"$archive_index.tmp\" yes \"$global_title &mdash; $template_archive_title\" \"$global_author\"\n    mv \"$archive_index.tmp\" \"$archive_index\"\n    chmod 644 \"$archive_index\"\n    rm \"$contentfile\"\n}\n\n# Create an index page with all the tags\nall_tags() {\n    echo -n \"Creating an index page with all the tags \"\n    contentfile=$tags_index.$RANDOM\n    while [[ -f $contentfile ]]; do\n        contentfile=$tags_index.$RANDOM\n    done\n\n    {\n        echo \"<h3>$template_tags_title</h3>\"\n        echo \"<ul>\"\n        for i in $prefix_tags*.html; do\n            [[ -f \"$i\" ]] || break\n            echo -n \".\" 1>&3\n            nposts=$(grep -c \"<\\!-- text begin -->\" \"$i\")\n            tagname=${i#\"$prefix_tags\"}\n            tagname=${tagname%.html}\n            case $nposts in\n                1) word=$template_tags_posts_singular;;\n                2|3|4) word=$template_tags_posts_2_4;;\n                *) word=$template_tags_posts;;\n            esac\n            echo \"<li><a href=\\\"$i\\\">$tagname</a> &mdash; $nposts $word</li>\"\n        done\n        echo \"\" 1>&3\n        echo \"</ul>\"\n        echo \"<div id=\\\"all_posts\\\"><a href=\\\"./$index_file\\\">$template_archive_index_page</a></div>\"\n    } 3>&1 > \"$contentfile\"\n\n    create_html_page \"$contentfile\" \"$tags_index.tmp\" yes \"$global_title &mdash; $template_tags_title\" \"$global_author\"\n    mv \"$tags_index.tmp\" \"$tags_index\"\n    chmod 644 \"$tags_index\"\n    rm \"$contentfile\"\n}\n\n# Generate the index.html with the content of the latest posts\nrebuild_index() {\n    echo -n \"Rebuilding the index \"\n    newindexfile=$index_file.$RANDOM\n    contentfile=$newindexfile.content\n    while [[ -f $newindexfile ]]; do \n        newindexfile=$index_file.$RANDOM\n        contentfile=$newindexfile.content\n    done\n\n    # Create the content file\n    {\n        n=0\n        while IFS='' read -r i; do\n            is_boilerplate_file \"$i\" && continue;\n            if ((n >= number_of_index_articles)); then break; fi\n            if [[ -n $cut_do ]]; then\n                get_html_file_content 'entry' 'entry' 'cut' <\"$i\" | awk \"/$cut_line/ { print \\\"<p class=\\\\\\\"readmore\\\\\\\"><a href=\\\\\\\"$i\\\\\\\">$template_read_more</a></p>\\\" ; next } 1\"\n            else\n                get_html_file_content 'entry' 'entry' <\"$i\"\n            fi\n            echo -n \".\" 1>&3\n            n=$(( n + 1 ))\n        done < <(ls -t ./*.html) # sort by date, newest first\n\n        feed=$blog_feed\n        if [[ -n $global_feedburner ]]; then feed=$global_feedburner; fi\n        echo \"<div id=\\\"all_posts\\\"><a href=\\\"$archive_index\\\">$template_archive</a> &mdash; <a href=\\\"$tags_index\\\">$template_tags_title</a> &mdash; <a href=\\\"$feed\\\">$template_subscribe</a></div>\"\n    } 3>&1 >\"$contentfile\"\n\n    echo \"\"\n\n    create_html_page \"$contentfile\" \"$newindexfile\" yes \"$global_title\" \"$global_author\"\n    rm \"$contentfile\"\n    mv \"$newindexfile\" \"$index_file\"\n    chmod 644 \"$index_file\"\n}\n\n# Finds all tags referenced in one post.\n# Accepts either filename as first argument, or post content at stdin\n# Prints one line with space-separated tags to stdout\ntags_in_post() {\n    sed -n \"/^<p>$template_tags_line_header/{s/^<p>$template_tags_line_header//;s/<[^>]*>//g;s/[ ,]\\+/ /g;p;}\" \"$1\" | tr ', ' ' '\n}\n\n# Finds all posts referenced in a number of tags.\n# Arguments are tags\n# Prints one line with space-separated tags to stdout\nposts_with_tags() {\n    (($# < 1)) && return\n    set -- \"${@/#/$prefix_tags}\"\n    set -- \"${@/%/.html}\"\n    sed -n '/^<h3><a class=\"ablack\" href=\"[^\"]*\">/{s/.*href=\"\\([^\"]*\\)\">.*/\\1/;p;}' \"$@\" 2> /dev/null\n}\n\n# Rebuilds tag_*.html files\n# if no arguments given, rebuilds all of them\n# if arguments given, they should have this format:\n# \"FILE1 [FILE2 [...]]\" \"TAG1 [TAG2 [...]]\"\n# where FILEn are files with posts which should be used for rebuilding tags,\n# and TAGn are names of tags which should be rebuilt.\n# example:\n# rebuild_tags \"one_post.html another_article.html\" \"example-tag another-tag\"\n# mind the quotes!\nrebuild_tags() {\n    if (($# < 2)); then\n        # will process all files and tags\n        files=$(ls -t ./*.html)\n        all_tags=yes\n    else\n        # will process only given files and tags\n        files=$(printf '%s\\n' $1 | sort -u)\n        files=$(ls -t $files)\n        tags=$2\n    fi\n    echo -n \"Rebuilding tag pages \"\n    n=0\n    if [[ -n $all_tags ]]; then\n        rm ./\"$prefix_tags\"*.html &> /dev/null\n    else\n        for i in $tags; do\n            rm \"./$prefix_tags$i.html\" &> /dev/null\n        done\n    fi\n    # First we will process all files and create temporal tag files\n    # with just the content of the posts\n    tmpfile=tmp.$RANDOM\n    while [[ -f $tmpfile ]]; do tmpfile=tmp.$RANDOM; done\n    while IFS='' read -r i; do\n        is_boilerplate_file \"$i\" && continue;\n        echo -n \".\"\n        if [[ -n $cut_do ]]; then\n            get_html_file_content 'entry' 'entry' 'cut' <\"$i\" | awk \"/$cut_line/ { print \\\"<p class=\\\\\\\"readmore\\\\\\\"><a href=\\\\\\\"$i\\\\\\\">$template_read_more</a></p>\\\" ; next } 1\"\n        else\n            get_html_file_content 'entry' 'entry' <\"$i\"\n        fi >\"$tmpfile\"\n        for tag in $(tags_in_post \"$i\"); do\n            if [[ -n $all_tags || \" $tags \" == *\" $tag \"* ]]; then\n                cat \"$tmpfile\" >> \"$prefix_tags$tag\".tmp.html\n            fi\n        done\n    done <<< \"$files\"\n    rm \"$tmpfile\"\n    # Now generate the tag files with headers, footers, etc\n    while IFS='' read -r i; do\n        tagname=${i#./\"$prefix_tags\"}\n        tagname=${tagname%.tmp.html}\n        create_html_page \"$i\" \"$prefix_tags$tagname.html\" yes \"$global_title &mdash; $template_tag_title \\\"$tagname\\\"\" \"$global_author\"\n        rm \"$i\"\n    done < <(ls -t ./\"$prefix_tags\"*.tmp.html 2>/dev/null)\n    echo\n}\n\n# Return the post title\n#\n# $1 the html file\nget_post_title() {\n    awk '/<h3><a class=\"ablack\" href=\".+\">/, /<\\/a><\\/h3>/{if (!/<h3><a class=\"ablack\" href=\".+\">/ && !/<\\/a><\\/h3>/) print}' \"$1\"\n}\n\n# Return the post author\n#\n# $1 the html file\nget_post_author() { \n    awk '/<div class=\"subtitle\">.+/, /<!-- text begin -->/{if (!/<div class=\"subtitle\">.+/ && !/<!-- text begin -->/) print}' \"$1\" | sed 's/<\\/div>//g'\n}\n\n# Displays a list of the tags\n#\n# $2 if \"-n\", tags will be sorted by number of posts\nlist_tags() {\n    if [[ $2 == -n ]]; then do_sort=1; else do_sort=0; fi\n\n    ls ./$prefix_tags*.html &> /dev/null\n    (($? != 0)) && echo \"No posts yet. Use 'bb.sh post' to create one\" && return\n\n    lines=\"\"\n    for i in $prefix_tags*.html; do\n        [[ -f \"$i\" ]] || break\n        nposts=$(grep -c \"<\\!-- text begin -->\" \"$i\")\n        tagname=${i#\"$prefix_tags\"}\n        tagname=${tagname#.html}\n        ((nposts > 1)) && word=$template_tags_posts || word=$template_tags_posts_singular\n        line=\"$tagname # $nposts # $word\"\n        lines+=$line\\\\n\n    done\n\n    if (( do_sort == 1 )); then\n        echo -e \"$lines\" | column -t -s \"#\" | sort -nrk 2\n    else\n        echo -e \"$lines\" | column -t -s \"#\" \n    fi\n}\n\n# Displays a list of the posts\nlist_posts() {\n    ls ./*.html &> /dev/null\n    (($? != 0)) && echo \"No posts yet. Use 'bb.sh post' to create one\" && return\n\n    lines=\"\"\n    n=1\n    while IFS='' read -r i; do\n        is_boilerplate_file \"$i\" && continue\n        line=\"$n # $(get_post_title \"$i\") # $(LC_ALL=$date_locale date -r \"$i\" +\"$date_format\")\"\n        lines+=$line\\\\n\n        n=$(( n + 1 ))\n    done < <(ls -t ./*.html)\n\n    echo -e \"$lines\" | column -t -s \"#\"\n}\n\n# Generate the feed file\nmake_rss() {\n    echo -n \"Making RSS \"\n\n    rssfile=$blog_feed.$RANDOM\n    while [[ -f $rssfile ]]; do rssfile=$blog_feed.$RANDOM; done\n\n    {\n        pubdate=$(LC_ALL=C date +\"$date_format_full\")\n        echo '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>' \n        echo '<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">' \n        echo \"<channel><title>$global_title</title><link>$global_url/$index_file</link>\"\n        echo \"<description>$global_description</description><language>en</language>\"\n        echo \"<lastBuildDate>$pubdate</lastBuildDate>\"\n        echo \"<pubDate>$pubdate</pubDate>\"\n        echo \"<atom:link href=\\\"$global_url/$blog_feed\\\" rel=\\\"self\\\" type=\\\"application/rss+xml\\\" />\"\n    \n        n=0\n        while IFS='' read -r i; do\n            is_boilerplate_file \"$i\" && continue\n            ((n >= number_of_feed_articles)) && break # max 10 items\n            echo -n \".\" 1>&3\n            echo '<item><title>' \n            get_post_title \"$i\"\n            echo '</title><description><![CDATA[' \n            get_html_file_content 'text' 'entry' $cut_do <\"$i\"\n            echo \"]]></description><link>$global_url/${i#./}</link>\" \n            echo \"<guid>$global_url/$i</guid>\" \n            echo \"<dc:creator>$(get_post_author \"$i\")</dc:creator>\" \n            echo \"<pubDate>$(LC_ALL=C date -r \"$i\" +\"$date_format_full\")</pubDate></item>\"\n    \n            n=$(( n + 1 ))\n        done < <(ls -t ./*.html)\n    \n        echo '</channel></rss>'\n    } 3>&1 >\"$rssfile\"\n    echo \"\"\n\n    mv \"$rssfile\" \"$blog_feed\"\n    chmod 644 \"$blog_feed\"\n}\n\n# generate headers, footers, etc\ncreate_includes() {\n    {\n        echo \"<h1 class=\\\"nomargin\\\"><a class=\\\"ablack\\\" href=\\\"$global_url/$index_file\\\">$global_title</a></h1>\" \n        echo \"<div id=\\\"description\\\">$global_description</div>\"\n    } > \".title.html\"\n\n    if [[ -f $header_file ]]; then cp \"$header_file\" .header.html\n    else {\n        echo '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">'\n        echo '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head>'\n        echo '<meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\" />'\n        echo '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />'\n        printf '<link rel=\"stylesheet\" href=\"%s\" type=\"text/css\" />\\n' \"${css_include[@]}\"\n        if [[ -z $global_feedburner ]]; then\n            echo \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"$template_subscribe_browser_button\\\" href=\\\"$blog_feed\\\" />\"\n        else \n            echo \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"$template_subscribe_browser_button\\\" href=\\\"$global_feedburner\\\" />\"\n        fi\n        } > \".header.html\"\n    fi\n\n    if [[ -f $footer_file ]]; then cp \"$footer_file\" .footer.html\n    else {\n        protected_mail=${global_email//@/&#64;}\n        protected_mail=${protected_mail//./&#46;}\n        echo \"<div id=\\\"footer\\\">$global_license <a href=\\\"$global_author_url\\\">$global_author</a> &mdash; <a href=\\\"mailto:$protected_mail\\\">$protected_mail</a><br/>\"\n        echo 'Generated with <a href=\"https://github.com/cfenollosa/bashblog\">bashblog</a>, a single bash script to easily create blogs like this one</div>'\n        } >> \".footer.html\"\n    fi\n}\n\n# Delete the temporarily generated include files\ndelete_includes() {\n    rm \".title.html\" \".footer.html\" \".header.html\"\n}\n\n# Create the css file from scratch\ncreate_css() {\n    # To avoid overwriting manual changes. However it is recommended that\n    # this function is modified if the user changes the blog.css file\n    (( ${#css_include[@]} > 0 )) && return || css_include=('main.css' 'blog.css')\n    if [[ ! -f blog.css ]]; then \n        # blog.css directives will be loaded after main.css and thus will prevail\n        echo '#title{font-size: x-large;}\n        a.ablack{color:black !important;}\n        li{margin-bottom:8px;}\n        ul,ol{margin-left:24px;margin-right:24px;}\n        #all_posts{margin-top:24px;text-align:center;}\n        .subtitle{font-size:small;margin:12px 0px;}\n        .content p{margin-left:24px;margin-right:24px;}\n        h1{margin-bottom:12px !important;}\n        #description{font-size:large;margin-bottom:12px;}\n        h3{margin-top:42px;margin-bottom:8px;}\n        h4{margin-left:24px;margin-right:24px;}\n        img{max-width:100%;}\n        #twitter{line-height:20px;vertical-align:top;text-align:right;font-style:italic;color:#333;margin-top:24px;font-size:14px;}' > blog.css\n    fi\n\n    # If there is a style.css from the parent page (i.e. some landing page)\n    # then use it. This directive is here for compatibility with my own\n    # home page. Feel free to edit it out, though it doesn't hurt\n    if [[ -f ../style.css ]] && [[ ! -f main.css ]]; then\n        ln -s \"../style.css\" \"main.css\" \n    elif [[ ! -f main.css ]]; then\n        echo 'body{font-family:Georgia,\"Times New Roman\",Times,serif;margin:0;padding:0;background-color:#F3F3F3;}\n        #divbodyholder{padding:5px;background-color:#DDD;width:100%;max-width:874px;margin:24px auto;}\n        #divbody{border:solid 1px #ccc;background-color:#fff;padding:0px 48px 24px 48px;top:0;}\n        .headerholder{background-color:#f9f9f9;border-top:solid 1px #ccc;border-left:solid 1px #ccc;border-right:solid 1px #ccc;}\n        .header{width:100%;max-width:800px;margin:0px auto;padding-top:24px;padding-bottom:8px;}\n        .content{margin-bottom:5%;}\n        .nomargin{margin:0;}\n        .description{margin-top:10px;border-top:solid 1px #666;padding:10px 0;}\n        h3{font-size:20pt;width:100%;font-weight:bold;margin-top:32px;margin-bottom:0;}\n        .clear{clear:both;}\n        #footer{padding-top:10px;border-top:solid 1px #666;color:#333333;text-align:center;font-size:small;font-family:\"Courier New\",\"Courier\",monospace;}\n        a{text-decoration:none;color:#003366 !important;}\n        a:visited{text-decoration:none;color:#336699 !important;}\n        blockquote{background-color:#f9f9f9;border-left:solid 4px #e9e9e9;margin-left:12px;padding:12px 12px 12px 24px;}\n        blockquote img{margin:12px 0px;}\n        blockquote iframe{margin:12px 0px;}' > main.css\n    fi\n}\n\n# Regenerates all the single post entries, keeping the post content but modifying\n# the title, html structure, etc\nrebuild_all_entries() {\n    echo -n \"Rebuilding all entries \"\n\n    for i in ./*.html; do\n        is_boilerplate_file \"$i\" && continue;\n        contentfile=.tmp.$RANDOM\n        while [[ -f $contentfile ]]; do contentfile=.tmp.$RANDOM; done\n\n        echo -n \".\"\n        # Get the title and entry, and rebuild the html structure from scratch (divs, title, description...)\n        title=$(get_post_title \"$i\")\n\n        get_html_file_content 'text' 'text' <\"$i\" >> \"$contentfile\"\n\n        # Read timestamp from post, if present, and sync file timestamp\n        timestamp=$(awk '/<!-- '$date_inpost': .+ -->/ { print }' \"$i\" | cut -d '#' -f 2)\n        [[ -n $timestamp ]] && touch -t \"$timestamp\" \"$i\"\n        # Read timestamp from file in correct format for 'create_html_page'\n        timestamp=$(LC_ALL=C date -r \"$i\" +\"$date_format_full\")\n\n        create_html_page \"$contentfile\" \"$i.rebuilt\" no \"$title\" \"$timestamp\" \"$(get_post_author \"$i\")\"\n        # keep the original timestamp!\n        timestamp=$(LC_ALL=C date -r \"$i\" +\"$date_format_timestamp\")\n        mv \"$i.rebuilt\" \"$i\"\n        chmod 644 \"$i\"\n        touch -t \"$timestamp\" \"$i\"\n        rm \"$contentfile\"\n    done\n    echo \"\"\n}\n\n# Displays the help\nusage() {\n    echo \"$global_software_name v$global_software_version\"\n    echo \"Usage: $0 command [filename]\"\n    echo \"\"\n    echo \"Commands:\"\n    echo \"    post [-html] [filename] insert a new blog post, or the filename of a draft to continue editing it\"\n    echo \"                            it tries to use markdown by default, and falls back to HTML if it's not available.\"\n    echo \"                            use '-html' to override it and edit the post as HTML even when markdown is available\"\n    echo \"    edit [-n|-f] [filename] edit an already published .html or .md file. **NEVER** edit manually a published .html file,\"\n    echo \"                            always use this function as it keeps internal data and rebuilds the blog\"\n    echo \"                            use '-n' to give the file a new name, if title was changed\"\n    echo \"                            use '-f' to edit full html file, instead of just text part (also preserves name)\"\n    echo \"    delete [filename]       deletes the post and rebuilds the blog\"\n    echo \"    rebuild                 regenerates all the pages and posts, preserving the content of the entries\"\n    echo \"    reset                   deletes everything except this script. Use with a lot of caution and back up first!\"\n    echo \"    list                    list all posts\"\n    echo \"    tags [-n]               list all tags in alphabetical order\"\n    echo \"                            use '-n' to sort list by number of posts\"\n    echo \"\"\n    echo \"For more information please open $0 in a code editor and read the header and comments\"\n}\n\n# Delete all generated content, leaving only this script\nreset() {\n    echo \"Are you sure you want to delete all blog entries? Please write \\\"Yes, I am!\\\" \"\n    read -r line\n    if [[ $line == \"Yes, I am!\" ]]; then\n        rm .*.html ./*.html ./*.css ./*.rss &> /dev/null\n        echo\n        echo \"Deleted all posts, stylesheets and feeds.\"\n        echo \"Kept your old '.backup.tar.gz' just in case, please delete it manually if needed.\"\n    else\n        echo \"Phew! You dodged a bullet there. Nothing was modified.\"\n    fi\n}\n\n# Detects if GNU date is installed\ndate_version_detect() {\n\tdate --version >/dev/null 2>&1\n\tif (($? != 0));  then\n\t\t# date utility is BSD. Test if gdate is installed \n\t\tif gdate --version >/dev/null 2>&1 ; then\n            date() {\n                gdate \"$@\"\n            }\n\t\telse\n            # BSD date\n            date() {\n                if [[ $1 == -r ]]; then\n                    # Fall back to using stat for 'date -r'\n                    format=${3//+/}\n                    stat -f \"%Sm\" -t \"$format\" \"$2\"\n                elif [[ $2 == --date* ]]; then\n                    # convert between dates using BSD date syntax\n                    command date -j -f \"$date_format_full\" \"${2#--date=}\" \"$1\" \n                else\n                    # acceptable format for BSD date\n                    command date -j \"$@\"\n                fi\n            }\n        fi\n    fi    \n}\n\n# Main function\n# Encapsulated on its own function for readability purposes\n#\n# $1     command to run\n# $2     file name of a draft to continue editing (optional)\ndo_main() {\n    # Detect if using BSD date or GNU date\n    date_version_detect\n    # Load default configuration, then override settings with the config file\n    global_variables\n    [[ -f $global_config ]] && source \"$global_config\" &> /dev/null \n    global_variables_check\n\n    # Check for $EDITOR\n    [[ -z $EDITOR ]] && \n        echo \"Please set your \\$EDITOR environment variable. For example, to use nano, add the line 'export EDITOR=nano' to your \\$HOME/.bashrc file\" && exit\n\n    # Check for validity of argument\n    [[ $1 != \"reset\" && $1 != \"post\" && $1 != \"rebuild\" && $1 != \"list\" && $1 != \"edit\" && $1 != \"delete\" && $1 != \"tags\" ]] && \n        usage && exit\n\n    [[ $1 == list ]] &&\n        list_posts && exit\n\n    [[ $1 == tags ]] &&\n        list_tags \"$@\" && exit\n\n    if [[ $1 == edit ]]; then\n        if (($# < 2)) || [[ ! -f ${!#} ]]; then\n            echo \"Please enter a valid .md or .html file to edit\"\n            exit\n        fi\n    fi\n\n    # Test for existing html files\n    if ls ./*.html &> /dev/null; then\n        # We're going to back up just in case\n        tar -c -z -f \".backup.tar.gz\" -- *.html &&\n            chmod 600 \".backup.tar.gz\"\n    elif [[ $1 == rebuild ]]; then\n        echo \"Can't find any html files, nothing to rebuild\"\n        exit\n    fi\n\n    # Keep first backup of this day containing yesterday's version of the blog\n    [[ ! -f .yesterday.tar.gz || $(date -r .yesterday.tar.gz +'%d') != \"$(date +'%d')\" ]] &&\n        cp .backup.tar.gz .yesterday.tar.gz &> /dev/null\n\n    [[ $1 == reset ]] &&\n        reset && exit\n\n    create_css\n    create_includes\n    [[ $1 == post ]] && write_entry \"$@\"\n    [[ $1 == rebuild ]] && rebuild_all_entries && rebuild_tags\n    [[ $1 == delete ]] && rm \"$2\" &> /dev/null && rebuild_tags\n    if [[ $1 == edit ]]; then\n        if [[ $2 == -n ]]; then\n            edit \"$3\"\n        elif [[ $2 == -f ]]; then\n            edit \"$3\" full\n        else\n            edit \"$2\" keep\n        fi\n    fi\n    rebuild_index\n    all_posts\n    all_tags\n    make_rss\n    delete_includes\n}\n\n\n#\n# MAIN\n# Do not change anything here. If you want to modify the code, edit do_main()\n#\ndo_main \"$@\"\n\n# vim: set shiftwidth=4 tabstop=4 expandtab:\n"
        }
      ]
    }
  ]
}