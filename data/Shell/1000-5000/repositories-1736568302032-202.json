{
  "metadata": {
    "timestamp": 1736568302032,
    "page": 202,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "micha/resty",
      "stars": 2651,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "*.swp\n*.swo\n*~\n.DS_Store\n\ntest/node_modules\n.idea\n"
        },
        {
          "name": ".travis-test.zsh",
          "type": "blob",
          "size": 0.0419921875,
          "content": "#!/usr/bin/env zsh\n\nsource ~/.zshrc\n\nshpec\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.1748046875,
          "content": "# zsh shpec build draft\nlanguage: sh\nenv:\n  matrix:\n    - SHELL=bash\n    - SHELL=zsh\nos:\n  - linux\n  - osx\n\ninstall:\n  # install antigen\n  - curl -L git.io/antigen > ~/antigen.zsh\n  - echo \"source ~/antigen.zsh; antigen bundle rylnd/shpec; antigen apply\" > ~/.zshrc\n  - echo \"setopt sh_word_split\" > ~/.zshenv\n  - zsh ~/.zshrc\n  - sh -c \"export BINDIR=$HOME ; `curl -L https://raw.github.com/rylnd/shpec/master/install.sh`\"\n\n  - $HOME/.nvm/nvm.sh\n  - nvm install 6 && nvm use 6\n  - (cd test && npm install)\n\n  - curl --version\n  - lynx --version\n\nscript:\n  - (cd test && node server.js &)\n  - sleep 1\n  - |\n        echo $SHELL && $SHELL --version\n        if [ \"$SHELL\" = \"zsh\" ]; then\n          echo \"Run Zsh test\"\n          ./.travis-test.zsh\n        elif [ \"$SHELL\" = \"bash\" ]; then\n          echo \"Run Bash test\"\n          $HOME/shpec\n        fi\nbefore_install:\n  - |\n      ([ \"${TRAVIS_OS_NAME}\" = \"linux\" ] && sudo apt-get install zsh lynx) || echo \"osx, skipping apt-get\"\n  - |\n      ([ \"${TRAVIS_OS_NAME}\" = \"osx\" ] && brew update && brew install zsh lynx curl) || echo \"linux, skipping brew\"\n\n\ncache:\n  apt: true\n  directories:\n    - $HOME/Library/Caches/Homebrew\n\nnotifications:\n  email: false\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.5146484375,
          "content": "# Change Log\nAll notable changes to *Resty* will be documented in this file.\nThis project adheres to [Semantic Versioning](http://semver.org/).\n\n## [Unreleased][unreleased]\n### Changed\n\n- major refactor\n### Fixed\n- Documentation glitch\n\n## History Black Hole to retrieve\n\n<!-- TODO: Patch release and 1 to 2 -->\n\n## [1.5] - 2011-03-20\n### Added\n- Curl options can now be specified when calling the resty command to set\n  the URI base. These options will be passed to curl for all subsequent\n  requests, until the next time the resty command is called.\n\n## [1.4] - 2011-03-08\n### Fixed\n- several bugs fix for zsh users.\n\n## [1.3] - 2011-03-04\n\n* Attempted bug fix for zsh users that prevented options from being passed\n  correctly to curl.\n\n## [1.2] - 2011-02-06 -\n\n* Data is now optional in PUT and POST requests. If the input is not a\n  terminal and no data is specified on the command line, resty won't wait\n  for data on stdin anymore. If you liked the old behavior you can always do\n  something like `cat | POST /Somewhere` for the same effect.\n\n## [1.1] - 2011-01-07\n### Fixed\n-  bug where `-V` option required input on stdin, and would block waiting  for it.\n\n<!-- Holder history to be retrieved\n\n[unreleased]: https://github.com/micha/resty/compare/v0.10.2...HEAD\n[1.5]: https://github.com/micha/resty/compare/1.4...1.5\n[1.4]: https://github.com/micha/resty/compare/1.3...1.4\n[1.3]: https://github.com/micha/resty/compare/1.2...1.3\n[1.2]: https://github.com/micha/resty/compare/1.1...1.2\n[1.1]: https://github.com/micha/resty/compare/1.0...1.1\n"
        },
        {
          "name": "MIT-LICENSE.txt",
          "type": "blob",
          "size": 1.0771484375,
          "content": "The MIT License (MIT)\n\nCopyright 2009-2017 Micha Niskin and other contributors\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2421875,
          "content": "\nPREFIX ?= /usr/local\n\ninstall:\n\tmkdir -p $(HOME)/.bashrc.d\n\tcp resty $(HOME)/.bashrc.d\n\tcp pypp pp $(PREFIX)/bin/\n\t@echo \"You should add 'source ~/.bashrc.d/resty' to your bashrc\"\n\nuninstall:\n\trm -f $(PREFIX)/bin/{pp,pypp} $(HOME)/.bashrc.d/resty\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.2529296875,
          "content": "Resty\n=====\n\n[![GitHub release](https://img.shields.io/github/release/micha/resty.svg)](https://github.com/micha/resty/releases)\n[![Build Status](https://travis-ci.org/AdrieanKhisbe/resty.svg?branch=master)](https://travis-ci.org/AdrieanKhisbe/resty)\n[![GitHub license](https://img.shields.io/github/license/micha/resty.svg)](https://github.com/micha/resty/blob/master/MIT-LICENSE.txt)\n\n> **Resty** is a *tiny* script wrapper for [curl](http://curl.haxx.se/).\n\nIt provides a simple, concise shell interface for interacting with\n[REST](http://en.wikipedia.org/wiki/Representational_State_Transfer) services.\nSince it is implemented as functions in your shell and not in its own separate\ncommand environment you have access to all the powerful shell tools, such\nas `perl`, `awk`, `grep`, `sed`, etc. You can use resty in pipelines to process data\nfrom `REST` services, and `PUT`, `PATCH`, or `POST` the data right back.  You can even pipe\nthe data in and then edit it interactively in your text editor prior to `PUT`,\n`PATCH`, or `POST`.\n\nCookies are supported automatically and stored in a file locally. Most of\nthe arguments are remembered from one call to the next to save typing. It\nhas pretty good defaults for most purposes. Additionally, **resty** allows you\nto easily provide your own options to be passed directly to `curl`, so even\nthe most complex requests can be accomplished with the minimum amount of\ncommand line pain.\n\n[Here is a nice screencast showing resty in action](http://jpmens.net/2010/04/26/resty/) (by Jan-Piet Mens).\n\n## Quick Start\n\nYou have `curl`, right? Okay.\n\n      $ curl -L https://raw.githubusercontent.com/micha/resty/master/resty > resty\n\nSource the script before using it.\n\n      $ . resty\n\nOnce **resty** is installed, set your REST host to which you will be making your requests.\n\n      $ resty http://127.0.0.1:8080/data\n      http://127.0.0.1:8080/data*\n\nAnd now you can Make some HTTP requests.\n\n      $ GET /blogs.json\n      [ {\"id\" : 1, \"title\" : \"first post\", \"body\" : \"This is the first post\"}, ... ]\n\n      $ PUT /blogs/2.json '{\"id\" : 2, \"title\" : \"updated post\", \"body\" : \"This is the new.\"}'\n      {\"id\" : 2, \"title\" : \"updated post\", \"body\" : \"This is the new.\"}\n\n      $ DELETE /blogs/2\n\n      $ POST /blogs.json '{\"title\" : \"new post\", \"body\" : \"This is the new new.\"}'\n      {\"id\" : 204, \"title\" : \"new post\", \"body\" : \"This is the new new.\"}\n\n## Installation\n\nThere are several way to install **resty** other than `curl`ing it and sourcing it.\n\nHere are some shell package manager that are supported:\n\n- **Bpkg** : with [`bpkg`](http://www.bpkg.sh/) installed just run `bpkg install -g micha/resty`,\n   then follow the instruction by adding `source ~/.bashrc.d/resty` to your `bashrc`\n- **Antigen** : with [`antigen`](https://github.com/zsh-users/antigen) for zsh, just add `antigen bundle micha/resty` in your `.zshrc`\n- **Zplug**: with [`zplug`](https://github.com/zplug/zplug) installed, just add `zplug micha/resty, use:'resty'` in your `.zshrc`\n- **Oh my Zsh**: clone the github repositery in the `plugins` directory of `ZSH_CUSTOM` and add `resty` to you `plugins` list\n\n\n## Usage\n\n      source resty [-W] [remote] [OPTIONS]    # load functions into shell\n      resty [-v]                              # prints current request URI base\n      resty <remote> [OPTIONS]                # sets the base request URI\n\n      HEAD [path] [OPTIONS]                   # HEAD request\n      OPTIONS [path] [OPTIONS]                # OPTIONS request\n      GET [path] [OPTIONS]                    # GET request\n      DELETE [path] [OPTIONS]                 # DELETE request\n      PUT [path] [data] [OPTIONS]             # PUT request\n      PATCH [path] [data] [OPTIONS]           # PATCH request\n      POST [path] [data] [OPTIONS]            # POST request\n      TRACE [path] [OPTIONS]                  # TRACE request\n\n      Options:\n\n      -Q            Don't URL encode the path.\n      -q <query>    Send query string with the path. A '?' is prepended to\n                    <query> and concatenated onto the <path>.\n      -W            Don't write to history file (only when sourcing script).\n      -V            Edit the input data interactively in 'vi'. (PUT, PATCH,\n                    and POST requests only, with data piped to stdin.)\n      -Z            Raw output. This disables any processing of HTML in the\n                    response.\n      -v            Verbose output. When used with the resty command itself\n                    this prints the saved curl options along with the current\n                    URI base. Otherwise this is passed to curl for verbose\n                    curl output.\n      --dry-run     Just output the curl command.\n      <curl opt>    Any curl options will be passed down to curl.\n\n## Configuration, Data File Locations\n\n\nResty creates a few files in either your `${XDG_CONFIG_HOME}` and `${XDG_DATA_HOME}`\ndirectory (if your linux uses the XDG directory standard) or in the `~/.resty`\ndirectory, otherwise.\n\n#### Using Existing, Pre-v2.1 Configuration Files With v2.1 ####\n\nIf you had resty installed before version 2.1 and your system uses the XDG\nconfig directory standard and you want to continue using your existing\nconfiguration files, please make a backup of your `~/.resty` directory\nand then do:\n\n      $ mkdir -p \"${XDG_CONFIG_HOME}/resty\" \"${XDG_DATA_HOME}/resty\"\n      $ mv ~/.resty/c \"${XDG_DATA_HOME}/resty\"\n      $ mv ~/.resty/* \"${XDG_CONFIG_HOME}/resty\"\n\n## Request URI Base\n\nThe request URI base is what the eventual URI to which the requests will be\nmade is based on. Specifically, it is a URI that may contain the `*` character\none or more times. The `*` will be replaced with the `path` parameter in the\n`OPTIONS`, `HEAD`, `GET`, `POST`, `PUT`, `PATCH`, or `DELETE` request as described\nabove.\n\nFor example:\n\n      $ resty 'http://127.0.0.1:8080/data*.json'\n      http://127.0.0.1:8080/data*.json\n\nand then\n\n      $ GET /5\n      { \"the_response\" : true }\n\nwould result in a `GET` request to the URI `http://127.0.0.1:8080/data/5.json`.\n\nIf no `*` character is specified when setting the base URI, it's just added\nonto the end for you automatically.\n\n### HTTPS URIs\n\nHTTPS URIs can be used, as well. For example:\n\n      $ resty 'https://example.com/doit'\n      https://example.com/doit*\n\n### URI Base History\n\nThe URI base is saved to an rc file (`${XDG_CONFIG_HOME}/resty/host` or `~/.resty/host`)\neach time it's set, and the last setting is saved in an environment variable\n(`$_resty_host`).  The URI base is read from the rc file when resty starts\nup, but only if the `$_resty_host` environment variable is not set.\nIn this way you can make requests to different hosts using resty from\nseparate terminals, and have a different URI base for each terminal.\n\nIf you want to see what the current URI base is, just run `resty` with no\narguments. The URI base will be printed to stdout.\n\n## The Optional Path Parameter\n\nThe HTTP verbs (`OPTIONS`, `HEAD`, `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`)\nfirst argument is always an optional URI path. This path must always start with a\n`/` character. If the path parameter is not provided on the command line, resty\nwill just use the last path it was provided with. This \"last path\" is stored in an\nenvironment variable (`$_RESTY_PATH`), so each terminal basically has its\nown \"last path\".\n\nThis feature can be disabled with the following flag `RESTY_NO_PRESERVE_PATH=true`.\n\n### URL Encoding Of Path Parameter\n\nResty will always [URL encode]\n(http://www.blooberry.com/indexdot/html/topics/urlencoding.htm) the path,\nexcept for slashes. (Slashes in path elements need to be manually encoded as\n`%2F`.) This means that the `?`, `=`, and `&` characters will be encoded, as\nwell as some other problematic characters. To disable this behavior use the\n`-Q` option.\n\n### Query Strings, POST Parameters, And Both At The Same Time\n\n\nThere are three ways to add a query string to the path. The first, mentioned\nabove, is to disable URL encoding with the `-Q` option, and include the\nquery string with the path parameter, like this:\n\n      $ GET '/blogs/47?param=foo&otherparam=bar' -Q\n\nTo specify a query string without disabling URL encoding on the path the\n`-q` option is used, like this:\n\n      $ GET /blogs/47 -q 'param=foo&otherparam=bar'\n\nFinally, you can use the curl `-d` and `-G` options, like this:\n\n      $ GET /blogs/47 -d 'param=foo' -d 'otherparam=bar' -G\n\nHowever, if you want to pass both GET parameters in the query string _and_\n`POST` parameters in the request body, curl cannot support this by itself.\nUsing the `-q` or `-Q` resty options with the `-d` curl option will accomplish\nthis, like so:\n\n      $ POST '/blogs/47?param=foo&otherparam=bar' -Q -d 'postparam=baz'\n\n## POST/PUT/PATCH Requests and Data\n\nNormally you would probably want to provide the request body data right on\nthe command line like this:\n\n      $ PUT /blogs/5.json '{\"title\" : \"hello\", \"body\" : \"this is it\"}'\n\nBut sometimes you will want to send the request body from a file instead. To\ndo that you pipe in the contents of the file:\n\n      $ PUT /blogs/5.json < /tmp/t\n\nOr you can pipe the data from another program, like this:\n\n      $ myprog | PUT /blogs/5.json\n\nOr, interestingly, as a filter pipeline with\n[jsawk](http://github.com/micha/jsawk):\n\n      $ GET /blogs/5.json | jsawk 'this.author=\"Bob Smith\";this.tags.push(\"news\")' | PUT\n\nNotice how the `path` argument is omitted from the `PUT` command.\n\n### Edit PUT/PATCH/POST Data In Vi\n\nWith the `-V` options you can pipe data into `PUT`, `PATCH`, or `POST`, edit\nit in vi, save the data (using `:wq` in vi, as normal) and the resulting data\nis then PUT, PATCH, or POSTed. This is similar to the way `visudo` works, for example.\n\n      $ GET /blogs/2 | PUT -V\n\nThis fetches the data and lets you edit it, and then does a PUT on the\nresource. If you don't like vi you can specify your preferred editor by\nsetting the `EDITOR` environment variable.\n\n## Errors and Output\n\nFor successful *2xx* responses, the response body is printed on stdout. You\ncan pipe the output to stuff, process it, and then pipe it back to resty,\nif you want.\n\nFor responses other than *2xx* the response body is dumped to stderr.\n\nIn either case, if the content type of the response is `text/html`, then\nresty will try to process the response through either `lynx`, `html2text`,\nor, finally, `cat`, depending on which of those programs are available on\nyour system.\n\n### Raw Output (-Z option)\n\nIf you don't want resty to process the output through lynx or html2text you\ncan use the `-Z` option, and get the raw output.\n\n## Passing Command Line Options To Curl\n\nAnything after the (optional) `path` and `data` arguments is passed on to\n`curl`.\n\nFor example:\n\n      $ GET /blogs.json -H \"Range: items=1-10\"\n\nThe `-H \"Range: items=1-10\"` argument will be passed to `curl` for you. This\nmakes it possible to do some more complex operations when necessary.\n\n      $ POST -v -u user:test\n\nIn this example the `path` and `data` arguments were left off, but `-v` and\n`-u user:test` will be passed through to `curl`, as you would expect.\n\nHere are some useful options to try:\n\n  - **-v** verbose output, shows HTTP headers and status on stderr\n  - **-j** junk session cookies (refresh cookie-based session)\n  - **-u \\<username:password\\>** HTTP basic authentication\n  - **-H \\<header\\>** add request header (this option can be added more than\n    once)\n\n### Setting The Default Curl Options\n\nSometimes you want to send some options to curl for every request. It\nwould be tedious to have to repeat these options constantly. To tell\n*resty* to always add certain curl options you can specify those options\nwhen you call resty to set the URI base. For example:\n\n      $ resty example.com:8080 -H \"Accept: application/json\" -u user:pass\n\nEvery subsequent request will have the `-H \"Accept:...\"` and `-u user:...`\noptions automatically added. Each time resty is called this option list\nis reset.\n\n### Per-Host/Per-Method Curl Configuration Files\n\n*Resty* supports a *per-host/per-method configuration* file to help you with\nfrequently used curl options. Each host (including the port) can have its\nown configuration file in the `~/.resty` directory.\nA special host `resty` is used to define *default* options for all the hosts.\n\nThe file format is\n\n      GET [arg] [arg] ...\n      PUT [arg] [arg] ...\n      PATCH [arg] [arg] ...\n      POST [arg] [arg] ...\n      DELETE [arg] [arg] ...\n\nWhere the `arg`s are curl command line arguments. Each line can specify\narguments for that HTTP verb only, and all lines are optional.\n\nThese config files are loaded each time you run the `resty` command.\n\n#### Example\nSo, suppose you find yourself using the same curl options over and over. You\ncan save them in a file and resty will pass them to curl for you. Say this\nis a frequent pattern for you:\n\n      $ resty localhost:8080\n      $ GET /Blah -H \"Accept: application/json\"\n      $ GET /Other -H \"Accept: application/json\"\n      ...\n      $ POST /Something -H \"Content-Type: text/plain\" -u user:pass\n      $ POST /SomethingElse -H \"Content-Type: text/plain\" -u user:pass\n      ...\n\nIt's annoying to add the `-H` and `-u` options to curl all the time. So\ncreate a file `~/.resty/localhost:8080`, like this:\n\n_~/.resty/localhost:8080_\n\n      GET -H \"Accept: application/json\"\n      POST -H \"Content-Type: text/plain\" -u user:pass\n\nThen any `GET` or `POST` requests to `localhost:8080` will have the specified\noptions prepended to the curl command line arguments, saving you from having\nto type them out each time, like this:\n\n      $ GET /Blah\n      $ GET /Other\n      ...\n      $ POST /Something\n      $ POST /SomethingElse\n      ...\n\nSweet! Much better.\n\n## Exit Status\n\nSuccessful requests (HTTP respose with *2xx* status) return zero.\nOtherwise, the first digit of the response status is returned (i.e., 1 for\n1xx, 3 for 3xx, 4 for 4xx, etc.) This is because the exit status is an 8 bit\ninteger---it can't be greater than 255. If you want the exact status code\nyou can always just pass the `-v` option to curl.\n\n## Using Resty In Shell Scripts\n\nSince resty creates the REST verb functions in the shell, when using it from a script you must `source` it before you use any of the functions. However, it's likely that you don't want it to be overwriting the resty host history file, and you will almost always want to set the URI base explicitly.\n\n      #!/usr/bin/env bash\n\n      # Load resty, don't write to the history file, and set the URI base\n      . /path/to/resty -W 'https://myhost.com/data*.json'\n\n      # GET the JSON list of users, set each of their 'disabled' properties\n      # to 'false', and PUT the modified JSON back\n      GET /users | jsawk 'this.disabled = false' | PUT\n\nHere the `-W` option was used when loading the script to prevent writing to the history file and an initial URI base was set at the same time. Then a JSON file was fetched, edited using [jsawk](http://github.com/micha/jsawk), and re-uploaded to the server.\n\nTo assign the response of resty to a variable you can you do for example: `VAR=\"$(GET /some/request)\"`. Note that the quote symbol (`\"`) around the subcommand is necessary if the output contains spaces.\n\n## Working With JSON or XML Data\n\n`JSON REST` web services require some special tools to make them accessible\nand easily manipulated in the shell environment. The following are a few\nscripts that make dealing with JSON data easier.\n\n  * The included `pp` script will pretty-print JSON for you. You just need to\n    install the JSON perl module from CPAN (included with brew install)\n    or you can use `pypp` if you have python installed.\n\n    `GET /blogs.json | pp   # pretty-prints the JSON output from resty`\n\n  * You can use powerful [jq](https://stedolan.github.io/jq/) Json command line\n    processor to perform operations on the received json. just pyping to `jq .`\n    will pretty print the json in color\n\n  * Another way to format JSON output:\n\n        $ echo '{\"json\":\"obj\"}' | python -mjson.tool\n        {\n          \"json\": \"obj\"\n        }\n\n  * [Jsawk](http://github.com/micha/jsawk) can be used to process and filter\n    JSON data from and to resty, in a shell pipeline. This takes care of\n    parsing the input JSON correctly, rather than using regexes and `sed`,\n    `awk`, `per`l or the like, and prints the resulting output in correct JSON\n    format, as well.\n\n    `GET /blogs.json | jsawk -n 'out(this.title)' # prints all the blog titles`\n\n\n  * The `tidy` tool can be used to format HTML/XML:\n\n        $ ~$ echo \"<test><deep>value</deep></test>\" | tidy -xml -q -i\n        <test>\n          <deep>value</deep>\n        </test>\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.1806640625,
          "content": "{\n  \"name\": \"resty\",\n  \"version\": \"3.0.0-beta\",\n  \"description\": \"Terminal utility functions\",\n  \"scripts\": [ \"resty\", \"pypp\", \"pp\" ],\n  \"global\": \"true\",\n  \"install\": \"make install\"\n}\n"
        },
        {
          "name": "pp",
          "type": "blob",
          "size": 0.3779296875,
          "content": "#!/usr/bin/env perl -0007\n\nif( $ARGV[0] eq '-h' || $ARGV[0] eq '--help') {\n  print \"pp: Pretty print json piped as stdin or provided as file argument.\\n\";\n  exit;\n}\n\nuse JSON;\nwhile (<>) {\n  print to_json(from_json($_, {allow_nonref=>1}),{pretty=>1}).\"\\n\";\n}\n\n# about:\n# was orignaly a one liner:\n# perl -0007 -MJSON -ne'print to_json(from_json($_, {allow_nonref=>1}),{pretty=>1}).\"\\n\"'\n"
        },
        {
          "name": "pypp",
          "type": "blob",
          "size": 0.3017578125,
          "content": "#!/usr/bin/env python\nfrom __future__ import print_function\nimport sys\nimport json\n\nif \"-h\" in sys.argv or \"--help\" in sys.argv:\n    print(\"pypp: Pretty print json piped as stdin\")\n    sys.exit(0)\n\ndata = sys.stdin.read()\n\nprint(json.dumps(json.loads(data), sort_keys=True, indent=4, separators=(',', ': ')))\n"
        },
        {
          "name": "resty",
          "type": "blob",
          "size": 10.7626953125,
          "content": "#  -*-  mode: sh -*-\n# resty - A tiny command line REST interface for bash and zsh.\n#\n# Fork me on github:\n#   http://github.com/micha/resty\n#\n# Author:\n#   Micha Niskin <micha@thinkminimo.com>\n#   Copyright 2009-2017, MIT licence.\n#\n# Maintener:\n#   Adriean Khisbe <adriean.khisbe@live.fr>\n#\n\n\nexport _RESTY_HOST=\"\"\nexport _RESTY_PATH=\"\"\nexport _RESTY_NO_HISTORY=\"\"\nexport _RESTY_H2T=\"$( (exec 2>&-; (which lynx >/dev/null && echo \"lynx -stdin -dump\") \\\n\t\t\t  || which html2text || which cat) |tail -n 1)\"\nexport _RESTY_EDITOR=$( (exec 2>&-; which \"$EDITOR\" || which vim || echo \"vi\") |tail -n 1)    # editor default\n\nexport _RESTY_DATA_DIR _RESTY_CONF_DIR\n\n\nfunction resty() {\n\n    local url; url=\"$1\"; [ -n \"$1\" ] && shift\n    if [ -n \"$url\" ] && [[ \"HEAD OPTIONS GET PATCH POST PUT TRACE DELETE\" =~ $url ]] ; then\n        resty-call $url \"$@\"\n        return\n    fi\n\n    local args j; args=() j=1\n    for i in \"$@\"; do\n        args[j]=\"$i\" && j=$((j + 1))\n        if [[ $i =~ ^-h\\|--help$ ]] ; then\n            cat <<HELP\nresty [host] [options]:\n\n      Set the host and default options to provided values\nHELP\n            -resty-help-options\n            return 0\n        fi\n    done\n\n    if [ -n \"$XDG_CONFIG_HOME\" ]; then\n        _RESTY_CONF_DIR=\"$XDG_CONFIG_HOME/resty\"\n        _RESTY_DATA_DIR=\"$XDG_DATA_HOME/resty\"\n    else\n        _RESTY_CONF_DIR=\"$HOME/.resty\"\n        _RESTY_DATA_DIR=\"$_RESTY_CONF_DIR\"\n    fi\n    mkdir -p \"$_RESTY_CONF_DIR\"\n\n    local host; host=\"$_RESTY_DATA_DIR/host\"\n\n    case \"$url\" in\n\thttp://*|https://*)\n\t    if [ \"${#args[@]}\" -ne 0 ]; then _RESTY_OPTS=$(printf \"%q \" \"${args[@]}\"|sed 's:[[:space:]]*$::'); else _RESTY_OPTS=\"\"; fi\n\t    export _RESTY_OPTS\n\t    echo \"$url\" |grep '\\*' >/dev/null || url=\"${url}*\"\n\t    (echo \"$url\" |tee \"${_RESTY_NO_HISTORY:-$host}\") |cat 1>&2 \\\n\t\t&& export _RESTY_HOST=\"$url\"\n\t    ;;\n\t*)\n\t    resty \"http://$url\" \"${args[@]}\"\n\t    return\n\t    ;;\n    esac\n\n    resty-compute-host-option\n}\n\nfunction resty-compute-host-option () {\n    # note: extract a function so it can be manually called if edited file\n    local domain; domain=$(echo -n \"$_RESTY_HOST\" | perl -ane '/^https?:\\/\\/([^\\/\\*]+)/; print $1')\n    if [[ -f \"$_RESTY_CONF_DIR/resty\" ]] ; then\n        for method in HEAD OPTIONS GET PATCH POST PUT TRACE DELETE ; do\n            eval \"export _RESTY_OPT_DEFAULT_$method; _RESTY_OPT_DEFAULT_$method=\\\"$(cat \"$_RESTY_CONF_DIR/resty\" 2>/dev/null\\\n                          | sed 's/^ *//' \\\n                          | grep \"^$method\" | cut -b $((${#method}+2))-)\\\"\"\n        done\n    else\n        for method in HEAD OPTIONS GET PATCH POST PUT TRACE DELETE ; do\n            eval \"export _RESTY_OPT_DEFAULT_$method; _RESTY_OPT_DEFAULT_$method=\\\"\\\"\"\n        done\n    fi\n    if [[ -f \"$_RESTY_CONF_DIR/$domain\" ]] ; then\n        for method in HEAD OPTIONS GET PATCH POST PUT TRACE DELETE ; do\n            eval \"export _RESTY_OPT_HOST_$method; _RESTY_OPT_HOST_$method=\\\"$(cat \"$_RESTY_CONF_DIR/$domain\" 2>/dev/null\\\n                        | sed 's/^ *//' \\\n                        | grep \"^$method\" | cut -b $((${#method}+2))-)\\\"\"\n        done\n    else\n        for method in HEAD OPTIONS GET PATCH POST PUT TRACE DELETE ; do\n           eval \"export _RESTY_OPT_HOST_$method; _RESTY_OPT_HOST_$method=''\"\n        done\n    fi\n}\n\nfunction resty-call() {\n    if [ $# = 0 ] ; then echo \"resty-call need args\" >&2; return 1; fi\n\n    local method; method=\"$1\"; shift\n    if [[ ! \"HEAD OPTIONS GET PATCH POST PUT TRACE DELETE\" =~ $method ]] ; then # this is not good\n        echo \"First arg must be an HTTP verb, '$method' isn't\" >&2\n        return 1\n    fi\n    for opt in \"$@\"; do # print help if requested\n        if [[ $opt =~ ^-h\\|--help$ ]] ; then\n            cat <<HELP\n$method [path] [options]:\n\n      Perform a $method request to host $_RESTY_HOST with path and options.\nHELP\n            -resty-help-options\n            return 0\n        fi\n    done\n\n    local _path __path\n\n    local host=\"$_RESTY_DATA_DIR/host\"\n    local cookies=\"$_RESTY_DATA_DIR/c\"\n\n    local h2t=\"$_RESTY_H2T\"\n    local editor=\"$_RESTY_EDITOR\"\n    if [[ \"POST PUT TRACE PATCH DELETE\" =~ $method ]]; then local hasbody; hasbody=\"yes\" ;fi\n\n    if [ -d \"$cookies\" ] ; then # retrieve cookie\n\t    (mkdir -p \"$cookies\"; echo \"http://localhost*\" > \"$host\")\n    fi\n\n    if [[ \"$1\" =~ ^/ ]] ; then # retrieve path\n        _path=\"$1\"\n        shift\n    fi\n    local body\n    if [[ ! \"$1\" =~ ^- ]] ; then # retrieve data\n         body=\"$1\"\n        [[ $# -gt 0 ]] && shift\n    fi\n\n    local -a all_opts curlopt_cmd\n    local raw query vimedit quote maybe_query verbose dry_run\n\n    local -a resty_default_arg host_arg;\n    for i in $(eval echo \"\\${_RESTY_OPT_DEFAULT_$method}\") ; do resty_default_arg+=(\"$i\") ; done\n    for i in $(eval echo \"\\${_RESTY_OPT_HOST_$method}\") ; do host_arg+=(\"$i\") ; done\n\n    for opt in \"$@\"; do all_opts+=($(printf '%q' \"$opt\")) ; done\n    all_opts+=(\"${resty_default_arg[@]}\")\n    all_opts+=(\"${host_arg[@]}\")\n    if [ \"${#_RESTY_OPTS[@]}\" -ne 0 ] ; then all_opts+=(\"${_RESTY_OPTS[@]}\") ; fi\n\n    for opt in \"${all_opts[@]}\"; do\n        if [ -n \"$maybe_query\" ] && [ -z \"$query\" ] ; then query=\"?$opt\"; continue; fi\n\n        case $opt in\n            --verbose|-v) verbose=\"yes\";;\n            # TODO; try adapt ; echo \"$opt\" | grep '^-[a-zA-Z]*v[a-zA-Z]*$' >/dev/null) \\\n            -V) vimedit=\"yes\" ;;\n            -Z) raw=\"yes\" ;;\n            -W) ;;\n            -Q) quote=\"yes\" ;;\n            -q) maybe_query=\"yes\" ;;\n            --dry-run) dry_run=\"yes\";;\n            --json) curlopt_cmd+=(\"-H 'Accept: application/json'\" \"-H 'Content-Type: application/json'\") ;;\n            --xml) curlopt_cmd+=(\"-H 'Accept: application/xml'\" \"-H 'Content-Type: application/xml'\") ;;\n            *) curlopt_cmd+=(\"$opt\")\n        esac\n    done\n\n    if [ -z \"$quote\" ]; then # replace special char with codes\n\t    _path=$(echo \"$_path\"|sed 's/%/%25/g;s/\\[/%5B/g;s/\\]/%5D/g;s/|/%7C/g;s/\\$/%24/g;s/&/%26/g;s/+/%2B/g;s/,/%2C/g;s/:/%3A/g;s/;/%3B/g;s/=/%3D/g;s/?/%3F/g;s/@/%40/g;s/ /%20/g;s/#/%23/g;s/{/%7B/g;s/}/%7D/g;s/\\\\/%5C/g;s/\\^/%5E/g;s/~/%7E/g;s/`/%60/g')\n    fi\n\n    if [ -z \"$_RESTY_HOST\" ] ;then _RESTY_HOST=$(cat \"$host\" 2>/dev/null);fi\n\n    if [ \"$RESTY_NO_PRESERVE_PATH\" != \"true\" ]&&[ \"$RESTY_NO_PRESERVE_PATH\" != \"yes\" ]; then\n        __path=\"${_path:-${_RESTY_PATH}}\"\n        _RESTY_PATH=\"${__path}\"\n    else\n        __path=$_path\n    fi\n\n    local domain; domain=$(echo -n \"$_RESTY_HOST\" | perl -ane '/^https?:\\/\\/([^\\/\\*]+)/; print $1')\n    _path=\"${_RESTY_HOST//\\*/$__path}\"\n\n    if [ \"$hasbody\" = \"yes\" ] && [ -z \"$body\" ]; then # treat when no body provided as arg\n        if [ ! -t 0 ] ; then # retrieve what stdin hold if stdin open\n           body=\"@-\"\n        else\n           body=\"\"\n        fi\n    fi\n\n    if [ \"$hasbody\" = \"yes\" ] && [ \"$vimedit\" = \"yes\" ]; then\n        local tmpf; tmpf=$(mktemp)\n        [ -t 0 ] || cat > \"$tmpf\"\n        (exec < /dev/tty; \"$editor\" \"$tmpf\")\n        body=$(cat \"$tmpf\")\n        rm -f \"$tmpf\"\n    fi\n\n    if [ -n \"$body\" ] ; then curl_opt=\"--data-binary\" ;fi\n    if [ \"$method\" = \"OPTIONS\" ] ; then raw=\"yes\" ; fi\n    if [ \"$method\" = \"HEAD\" ] ; then\n        curl_opt=\"-I\"\n        raw=\"yes\"\n    fi\n\n    # Forge command and display it if dry-run\n    local cmd\n    cmd=(curl -sLv $curl_opt $(printf \"%q\" \"$body\") -X $method  -b \\\"$cookies/$domain\\\" -c \\\"$cookies/$domain\\\" \"$(\\\n        [ -n \"$curlopt_cmd\" ] && printf '%s ' ${curlopt_cmd[@]})\"\\\"$_path$query\\\")\n    if [ \"$dry_run\" = \"yes\" ] ; then\n        echo \"${cmd[@]}\"\n        return 0\n    fi\n\n    # Launch command and retrieved streams\n    local res out err ret _status outf errf\n    outf=$(mktemp) errf=$(mktemp)\n    eval \"${cmd[@]}\" > \"$outf\" 2> \"$errf\"\n    _status=$?; out=\"$(cat \"$outf\")\"; err=\"$(cat \"$errf\")\"; rm -f \"$outf\" \"$errf\"\n    ret=$(sed '/^.*HTTP\\/1\\.[01] [0-9][0-9][0-9]/s/.*\\([0-9]\\)[0-9][0-9].*/\\1/p; d' <<< \"$err\" | tail -n1)\n\n    if [ \"$_status\" -ne \"0\" ]; then echo \"$err\" >&2 ; return $_status ; fi\n\n    if [ -n \"$err\" ] && [ -n \"$verbose\" ]; then echo \"$err\" 1>&2 ; fi\n\n    # post process for display\n    local display\n    if [ -z \"$raw\" ] && grep -i '^< \\s*Content-Type:  *text/html' >/dev/null <<< \"$err\"\n    then display=$h2t\n    else display=cat\n    fi\n    if [ -n \"$out\" ]; then out=$(echo \"$out\" | eval \"$display\") ; fi\n\n    if [[ \"$display\" =~ ^lynx ]] || [[ \"$display\" =~ ^elinks ]] ; then\n        out=$(echo \"$out\" |perl -e \"\\$host='$(echo \"$_RESTY_HOST\" |sed 's/^\\(https*:\\/\\/[^\\/*]*\\).*$/\\1/')';\" \\\n                                -e \"$(cat <<'PERL'\n            @a=<>;\n            $s=0;\n            foreach (reverse(@a)) {\n                if ($_ =~ /^References$/) { $s++; }\n                unless ($s>0) {\n                    s/^\\s+[0-9]+\\. //;\n                    s/^file:\\/\\/localhost/$host/;\n                }\n                push(@ret,$_);\n            }\n            print(join(\"\",reverse(@ret)))\nPERL\n            )\")\n    fi\n\n    if [ \"$ret\" != \"2\" ]; then\n        [ -n \"$out\" ] && echo \"$out\" 1>&2\n        return $ret\n    else\n        [ -n \"$out\" ] && echo \"$out\"\n        return 0\n    fi\n\n}\n\nfunction resty-load-alias(){\n    alias HEAD=resty-head OPTIONS=resty-options GET=resty-get POST=resty-post PUT=resty-put\n    alias TRACE=resty-trace PATCH=resty-patch DELETE=resty-delete\n    # maybe add option?\n}\n\nresty-load-alias # Loaded by default. §maybe: Latter do an option (opt-in or opt-out)\n\nfunction resty-unload-alias(){\n    unalias HEAD OPTIONS GET POST PUT TRACE PATCH DELETE\n}\n\nfunction resty-head() {\n    resty-call HEAD \"$@\"\n}\n\nfunction resty-options() {\n    resty-call OPTIONS \"$@\"\n}\n\nfunction resty-get() {\n    resty-call GET \"$@\"\n}\n\nfunction resty-post() {\n    resty-call POST \"$@\"\n}\n\nfunction resty-put() {\n    resty-call PUT \"$@\"\n}\n\nfunction resty-patch() {\n    resty-call PATCH \"$@\"\n}\n\nfunction resty-delete() {\n    resty-call DELETE \"$@\"\n}\n\nfunction resty-trace() {\n    resty-call TRACE \"$@\"\n}\n\nfunction -resty-help-options () {\ncat <<HELP\n\n      Options:\n\n      -Q            Don't URL encode the path.\n      -q <query>    Send query string with the path. A '?' is prepended to\n                    <query> and concatenated onto the <path>.\n      -W            Don't write to history file (only when sourcing script).\n      -V            Edit the input data interactively in 'vi'. (PUT, PATCH,\n                    and POST requests only, with data piped to stdin.)\n      -Z            Raw output. This disables any processing of HTML in the\n                    response.\n      -v            Verbose output. When used with the resty command itself\n                    this prints the saved curl options along with the current\n                    URI base. Otherwise this is passed to curl for verbose\n                    curl output.\n      --dry-run     Just output the curl command.\n      <curl opt>    Any curl options will be passed down to curl.\nHELP\n}\n\n# With -W option, does not write to history file\n[ \"$1\" = \"-W\" ] && export _RESTY_NO_HISTORY=\"/dev/null\" && [[ $# -gt 0 ]] && shift\n\nresty \"$@\" >/dev/null 2>&1\n"
        },
        {
          "name": "resty.plugin.zsh",
          "type": "blob",
          "size": 0.7802734375,
          "content": "##########################################################\n#                                                        #\n#                ____            __                      #\n#               / __ \\___  _____/ /___  __               #\n#              / /_/ / _ \\/ ___/ __/ / / /               #\n#             / _, _/  __(__  ) /_/ /_/ /                #\n#            /_/ |_|\\___/____/\\__/\\__, /                 #\n#                                /____/                  #\n#                                                        #\n##########################################################\n\n## Zsh Antigen installer for resty.\n\nsource \"$(dirname $0:A)/resty\"\nalias pp=\"$(cat $(dirname $0:A)/pp)\"\nalias pypp=\"$(cat $(dirname $0:A)/pypp)\"\n\n# source file, and create alias with the content of pp, ppyp\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}