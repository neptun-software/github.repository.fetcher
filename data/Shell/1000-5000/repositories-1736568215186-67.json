{
  "metadata": {
    "timestamp": 1736568215186,
    "page": 67,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sdushantha/tmpmail",
      "stars": 3914,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.28515625,
          "content": "# editorconfig.org\nroot = true\n\n[*]\ncharset = utf-8\nindent_size = 4\nindent_style = space\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nmax_line_length = 130\n\n# https://github.com/mvdan/sh#shfmt\nswitch_case_indent = true\n\n[*.md]\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": ".DS_Store\n\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2021484375,
          "content": "FROM alpine:3.15.4\n\nRUN apk --no-cache add curl jq w3m xclip util-linux\n\nRUN curl -L \"https://raw.githubusercontent.com/sdushantha/tmpmail/master/tmpmail\" > tmpmail && chmod +x tmpmail\n\nRUN mv tmpmail /bin/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "MIT License\n\nCopyright (c) 2020 Siddharth Dushantha\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.146484375,
          "content": "<h1 align=\"center\">\n  <img src=\"images/logo.png\">\n</h1>\n<p align=\"center\"> A temporary email right from your terminal written in POSIX sh</p><br>\n\n<img src=\"images/demo.gif\" align=\"right\"> `tmpmail` is a command line utility written in POSIX `sh` that allows you to create a temporary email address\nand receive emails to the temporary email address. It uses 1secmail's [API](https://www.1secmail.com/api/)\nto receive emails.\n\nBy default `w3m` is used to render the HTML emails on the terminal.\nBut if you prefer another text based web browser or would rather view the email in a GUI web browser such as Firefox, simply\nuse the `--browser` argument followed by the command needed to launch the web browser of your choice.\n\n<br>\n<br>\n<br>\n\n## Dependencies\n- `w3m`\n- `curl`\n- [`jq`](https://github.com/stedolan/jq)\n- `xclip`\n\n## Installation\n### Install locally\n\n```bash\n# Download the tmpmail file and make it executable\n$ curl -L \"https://raw.githubusercontent.com/sdushantha/tmpmail/master/tmpmail\" > tmpmail && chmod +x tmpmail\n\n# Then move it somewhere in your $PATH. Here is an example:\n$ mv tmpmail ~/bin/\n```\n\n### AUR\n`tmpmail` is available on the [AUR](https://aur.archlinux.org/packages/tmpmail-git/), which is currently being maintained by [Benjamin Bädorf](https://github.com/b12f)\n\n```bash\n$ yay -S tmpmail-git\n```\n\n### [Pacstall](https://github.com/pacstall/pacstall) (Debian/Ubuntu)\n`tmpmail` is available on the [pacstall-programs repository](https://github.com/pacstall/pacstall-programs/blob/master/packages/tmpmail-bin/tmpmail-bin.pacscript), which is being currently being maintained by [wizard-28](https://github.com/wizard-28)\n\n```\n$ pacstall -I tmpmail-bin\n```\n\n### Nixpkgs\n`tmpmail` is also available in the [nix package collection (only unstable currently)](https://search.nixos.org/packages?channel=unstable&show=tmpmail&from=0&size=50&sort=relevance&query=tmpmail), which is maintained by [legendofmiracles](https://github.com/legendofmiracles)\n\nEither add it to your system packages, install it with nix-env or try it out in a ephemeral nix-shell `nix-shell -p tmpmail`\n\n### Docker\n\nrequirements:\n - [docker](https://www.docker.com/)\n - clone this repo\n\n```bash                                                                                        \n$ docker build -t mail .; # Dockerfile available in source code\n$ docker run -it mail;\n```   \n\n## Usage\n```console\n$ tmpmail --help\ntmpmail\ntmpmail -h | --version\ntmpmail -g [ADDRESS]\ntmpmail [-t | -b BROWSER] -r | ID\n\nWhen called with no option and no argument, tmpmail lists the messages in\nthe inbox and their numeric IDs.  When called with one argument, tmpmail\nshows the email message with specified ID.\n\n-b, --browser BROWSER\n        Specify BROWSER that is used to render the HTML of\n        the email (default: w3m)\n    --clipboard-cmd COMMAND\n        Specify the COMMAND to use for copying the email address to your\n        clipboard (default: xclip -selection c)\n-c, --copy\n        Copy the email address to your clipboard\n-d, --domains\n        Show list of available domains\n-g, --generate [ADDRESS]\n        Generate a new email address, either the specified ADDRESS, or\n        randomly create one\n-h, --help\n        Show help\n-r, --recent\n        View the most recent email message\n-t, --text\n        View the email as raw text, where all the HTML tags are removed.\n        Without this option, HTML is used.\n--version\n        Show version\n```\n\n### Examples\nCreate random email\n```console\n$ tmpmail --generate\nxoithrjagpx@1secmail.net\n```\n\nCreate custom email\n```console\n$ tmpmail --generate mycustomemail@1secmail.com\nmycustomemail@1secmail.com\n```\n\nView the inbox\n```console\n$ tmpmail\n[ Inbox for wdebivbyjor@1secmail.com ]\n\n83414443   username@example.com   Test Email\n```\n\nView the email\n```console\n$ tmpmail 83414443\n```\n\nView the most recent email\n```console\n$ tmpmail -r\n```\n\nView emails as pure text\n```console\n$ tmpmail -t 83414443\nTo: wdebivbyjor@1secmail.com\nFrom: username@example.com\nSubject: Test Email\n\nHello World\n\n[Attachments]\nhttps://is.gd/aBCdEf [apple.jpg]\nhttps://is.gd/AbCDeF [ball.jpg]\n```\n\n## Credits\nThis script is heavily inspired by Mitch Weaver's [`1secmail`](https://github.com/mitchweaver/bin/blob/master/OLD/1secmail) script\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "tmpmail",
          "type": "blob",
          "size": 15.525390625,
          "content": "#!/usr/bin/env sh\n#\n# by Siddharth Dushantha 2020\n#\n# Dependencies: jq, curl, w3m\n#\n\nversion=1.2.3\n\n# By default 'tmpmail' uses 'w3m' as it's web browser to render\n# the HTML of the email\nbrowser=\"w3m\"\n\n# The default command that will be used to copy the email address to\n# the user's clipboard when running 'tmpmail --copy'\ncopy_to_clipboard_cmd=\"xclip -selection c\"\n\n# If the value is set to 'true' tmpmail will convert the HTML email\n# to raw text and send that to stdout\nraw_text=false\n\n# Everything related to 'tmpmail' will be stored in /tmp/tmpmail\n# so that the old emails and email addresses get cleared after\n# restarting the computer\ntmpmail_dir=\"/tmp/tmpmail\"\n\n# tmpmail_email_address is where we store the temporary email address\n# that gets generated. This prevents the user from providing\n# the email address everytime they run tmpmail\ntmpmail_email_address=\"$tmpmail_dir/email_address\"\n\n# tmpmail.html is where the email gets stored.\n# Even though the file ends with a .html extension, the raw text version of\n# the email will also be stored in this file so that w3m and other browsers\n# are able to open this file\ntmpmail_html_email=\"$tmpmail_dir/tmpmail.html\"\n\n# Default 1secmail API URL\ntmpmail_api_url=\"https://www.1secmail.com/api/v1/\"\n\nusage() {\n    # Using 'cat << EOF' we can easily output a multiline text. This is much\n    # better than using 'echo' for each line or using '\\n' to create a new line.\n    cat <<EOF\ntmpmail\ntmpmail -h | --version\ntmpmail -g [ADDRESS]\ntmpmail [-t | -b BROWSER] -r | ID\n\nWhen called with no option and no argument, tmpmail lists the messages in\nthe inbox and their numeric IDs.  When called with one argument, tmpmail\nshows the email message with specified ID.\n\n-b, --browser BROWSER\n        Specify BROWSER that is used to render the HTML of\n        the email (default: w3m)\n    --clipboard-cmd COMMAND\n        Specify the COMMAND to use for copying the email address to your\n        clipboard (default: xclip -selection c)\n-c, --copy\n        Copy the email address to your clipboard\n-d, --domains\n        Show list of available domains\n-g, --generate [ADDRESS]\n        Generate a new email address, either the specified ADDRESS, or\n        randomly create one\n-h, --help\n        Show help\n-r, --recent\n        View the most recent email message\n-t, --text\n        View the email as raw text, where all the HTML tags are removed.\n        Without this option, HTML is used.\n--version\n        Show version\nEOF\n}\n\nget_list_of_domains() {\n    # Getting domains list from 1secmail API\n    data=$(curl -sL \"$tmpmail_api_url?action=getDomainList\") \n\n    # Number of available domains\n    data_length=$(printf %s \"$data\" | jq length)\n\n    # If the length of the data we got is 0, that means the email address\n    # has not received any emails yet.\n    [ \"$data_length\" -eq 0 ] && echo \"1secmail API error for getting domains list\" && exit\n\n    # Getting rid of quotes, braces and replace comma with space\n    printf \"%s\" \"$data\" | tr -d \"[|]|\\\"\" | tr \",\" \" \"\n}\n\nshow_list_of_domains() {\n    # Convert the list of domains which are in a singal line, into multiple lines\n    # with a dash in the beginning of each domain for a clean output\n    domains=$(printf \"%s\" \"$(get_list_of_domains)\" | tr \" \" \"\\n\" | sed \"s/^/- /g\")\n    printf \"List of available domains: \\n%s\\n\" \"$domains\"\n}\n\ngenerate_email_address() {\n    # There are 2 ways which this function is called in this script.\n    #  [1] The user wants to generate a new email and runs 'tmpmail --generate'\n    #  [2] The user runs 'tmpmail' to check the inbox , but /tmp/tmpmail/email_address\n    #      is empty or nonexistant. Therefore a new email gets automatically\n    #      generated before showing the inbox. But of course the inbox will\n    #      be empty as the newly generated email address has not been\n    #      sent any emails.\n    #\n    # When the function 'generate_email_address()' is called with the arguement\n    # 'true', it means that the function was called because the user\n    # ran 'tmpmail --generate'.\n    #\n    # We need this variable so we can know whether or not we need to show the user\n    # what the email was. <-- More about this can be found further down in this function.\n    externally=${1:-false}\n\n    # This variable lets generate_email_address know if the user has provided a custom\n    # email address which they want to use. custom is set to false if $2 has no value.\n    custom=${2:-false}\n\n    # Generate a random email address.\n    # This function is called whenever the user wants to generate a new email\n    # address by running 'tmpmail --generate' or when the user runs 'tmpmail'\n    # but /tmp/tmpmail/email_address is empty or nonexistent.\n    #\n    # We create a random username by taking the first 10 lines from /dev/random\n    # and delete all the characters which are *not* lower case letters from A to Z.\n    # So charcters such as dashes, periods, underscore, and numbers are all deleted,\n    # giving us a text which only contains lower case letters form A to Z. We then take\n    # the first 10 characters, which will be the username of the email address\n    username=$(head /dev/urandom | LC_ALL=C tr -dc \"[:alnum:]\" | cut -c1-11 | tr \"[:upper:]\" \"[:lower:]\")\n\n    # Generate a regex for valif email adress by fetching the list of supported domains\n    valid_email_address_regex=$(printf \"[a-z0-9]+@%s\" \"$(get_list_of_domains | tr ' ' '|')\")\n    username_black_list_regex=\"(abuse|webmaster|contact|postmaster|hostmaster|admin)\"\n    username_black_list=\"- abuse\\n- webmaster\\n- contact\\n- postmaster\\n- hostmaster\\n- admin\"\n\n    # Randomly pick one of the domains mentioned above.\n    domain=$(printf \"%b\" \"$(get_list_of_domains)\" | tr \" \" \"\\n\" | randomize | tail -1)\n\n    email_address=\"$username@$domain\"\n\n    # If the user provided a custom email address then use that email address\n    if [ \"$custom\" != false ]; then\n        email_address=$custom\n\n        # Check if the user is using username in the email address which appears\n        # in the black list.\n        if printf %b \"$email_address\" | grep -Eq \"$username_black_list_regex\"; then\n            die \"For security reasons, that username cannot be used. Here are the blacklisted usernames:\\n$username_black_list\"\n        fi\n\n        # Do a regex check to see if the email address provided by the user is a\n        # valid email address\n        if ! printf %b \"$email_address\" | grep -Eq \"$valid_email_address_regex\"; then\n            die \"Provided email is invalid. Must match $valid_email_address_regex\"\n        fi\n    fi\n\n    # Save the generated email address to the $tmpmail_email_address file\n    # so that it can be whenever 'tmpmail' is run\n    printf %s \"$email_address\" >\"$tmpmail_email_address\"\n\n    # If this function was called because the user wanted to generate a new\n    # email address, show them the email address\n    [ \"$externally\" = true ] && cat \"$tmpmail_email_address\" && printf \"\\n\"\n}\n\nget_email_address() {\n    # This function is only called once and that is when this script\n    # get executed. The output of this function gets stored in $email_address\n    #\n    # If the file that contains the email address is empty,\n    # that means we do not have an email address, so generate one.\n    [ ! -s \"$tmpmail_email_address\" ] && generate_email_address\n\n    # Output the email address by getting the first line of $tmpmail_email\n    head -n 1 \"$tmpmail_email_address\"\n}\n\nlist_emails() {\n    # List all the received emails in a nicely formatted order\n    #\n    # Fetch the email data using 1secmail's API\n    data=$(curl -sL \"$tmpmail_api_url?action=getMessages&login=$username&domain=$domain\")\n\n    # Using 'jq' we get the length of the JSON data. From this we can determine whether or not\n    # the email address has gotten any emails\n    data_length=$(printf %s \"$data\" | jq length)\n\n    # We are showing what email address is currently being used\n    # in case the user has forgotten what the email address was.\n    printf \"[ Inbox for %s ]\\n\\n\" \"$email_address\"\n\n    # If the length of the data we got is 0, that means the email address\n    # has not received any emails yet.\n    [ \"$data_length\" -eq 0 ] && echo \"No new mail\" && exit\n\n    # This is where we store all of our emails, which is then\n    # displayed using 'column'\n    inbox=\"\"\n\n    # Go through each mail that has been received\n    index=1\n    while [ $index -le \"${data_length}\" ]; do\n        # Since arrays in JSON data start at 0, we must subtract\n        # the value of $index by 1 so that we dont miss one of the\n        # emails in the array\n        mail_data=$(printf %s \"$data\" | jq -r \".[$index-1]\")\n        id=$(printf %s \"$mail_data\" | jq -r \".id\")\n        from=$(printf %s \"$mail_data\" | jq -r \".from\")\n        subject=$(printf %s \"$mail_data\" | jq -r \".subject\")\n\n        # The '||' are used as a divideder for 'column'. 'column' will use this divider as\n        # a point of reference to create the division. By default 'column' uses a blank space\n        # but that would not work in our case as the email subject could have multiple white spaces\n        # and 'column' would split the words that are seperated by white space, in different columns.\n        inbox=\"$inbox$id ||$from ||$subject\\n\"\n        index=$((index + 1))\n    done\n\n    # Show the emails cleanly\n    printf \"%b\" \"$inbox\" | column -t -s \"||\"\n}\n\nrandomize() {\n    # We could use 'shuf' and 'sort -R' but they are not a part of POSIX\n    awk 'BEGIN {srand();} {print rand(), $0}' | \\\n        sort -n -k1 | cut -d' ' -f2\n}\n\nview_email() {\n    # View an email by providing it's ID\n    #\n    # The first argument provided to this function will be the ID of the email\n    # that has been received\n    email_id=\"$1\"\n    data=$(curl -sL \"$tmpmail_api_url?action=readMessage&login=$username&domain=$domain&id=$email_id\")\n\n    # After the data is retrieved using the API, we have to check if we got any emails.\n    # Luckily 1secmail's API is not complicated and returns 'Message not found' as plain text\n    # if our email address as not received any emails.\n    # If we received the error message from the API just quit because there is nothing to do\n    [ \"$data\" = \"Message not found\" ] && die \"Message not found\"\n\n    # We pass the $data to 'jq' which extracts the values\n    from=$(printf %s \"$data\" | jq -r \".from\")\n    subject=$(printf %s \"$data\" | jq -r \".subject\")\n    html_body=$(printf %s \"$data\" | jq -r \".htmlBody\")\n    attachments=$(printf %s \"$data\" | jq -r \".attachments | length\")\n    \n    # If you get an email that is in pure text, the .htmlBody field will be empty and\n    # we will need to get the content from .textBody instead\n    [ -z \"$html_body\" ] && html_body=\"<pre>$(printf %s \"$data\" | jq -r \".textBody\")</pre>\"\n\n    # Create the HTML with all the information that is relevant and then\n    # assigning that HTML to the variable html_mail. This is the best method\n    # to create a multiline variable\n    html_mail=$(cat <<EOF\n<pre><b>To: </b>$email_address\n<b>From: </b>$from\n<b>Subject: </b>$subject</pre>\n$html_body\n\nEOF\n)\n    \n    if [ ! \"$attachments\" = \"0\" ]; then\n        html_mail=\"$html_mail<br><b>[Attachments]</b><br>\"\n\n        index=1\n        while [ \"$index\" -le \"$attachments\" ]; do\n            filename=$(printf %s \"$data\" | jq -r \".attachments | .[$index-1] | .filename\")\n            link=\"$tmpmail_api_url?action=download&login=$username&domain=$domain&id=$email_id&file=$filename\"\n            html_link=\"<a href=$link download=$filename>$filename</a><br>\"\n\n            if [ \"$raw_text\" = true ]; then\n                # The actual url is way too long and does not look so nice in STDOUT.\n                # Therefore we will shortening it using is.gd so that it looks nicer.\n                link=$(curl -s -F\"url=$link\" \"https://is.gd/create.php?format=simple\")\n                html_mail=\"$html_mail$link  [$filename]<br>\"\n            else\n                html_mail=\"$html_mail$html_link\"\n            fi\n\n            index=$((index + 1))\n        done\n    fi\n\n    # Save the $html_mail into $tmpmail_html_email\n    printf %s \"$html_mail\" >\"$tmpmail_html_email\"\n\n    # If the '--text' flag is used, then use 'w3m' to convert the HTML of\n    # the email to pure text by removing all the HTML tags\n    [ \"$raw_text\" = true ] && w3m -dump \"$tmpmail_html_email\" && exit\n\n    # Open up the HTML file using $browser. By default,\n    # this will be 'w3m'.\n    $browser \"$tmpmail_html_email\"\n}\n\n\nview_recent_email() {\n    # View the most recent email.\n    #\n    # This is done by listing all the received email like you\n    # normally see on the terminal when running 'tmpmail'.\n    # We then grab the ID of the most recent\n    # email, which the first line.\n    mail_id=$(list_emails | head -3 | tail -1 | cut -d' ' -f 1)\n    view_email \"$mail_id\"\n}\n\n\ncopy_email_to_clipboard(){\n    # Copy the email thats being used to the user's clipboard\n    $copy_to_clipboard_cmd < $tmpmail_email_address\n}\n\n\ndie() {\n    # Print error message and exit\n    #\n    # The first argument provided to this function will be the error message.\n    # Script will exit after printing the error message.\n    printf \"%b\\n\" \"Error: $1\" >&2\n    exit 1\n}\n\nmain() {\n    # Iterate of the array of dependencies and check if the user has them installed.\n    # We are checking if $browser is installed instead of checking for 'w3m'. By doing\n    # this, it allows the user to not have to install 'w3m' if they are using another\n    # browser to view the HTML.\n    #\n    # dep_missing allows us to keep track of how many dependencies the user is missing\n    # and then print out the missing dependencies once the checking is done.\n    dep_missing=\"\"\n\n    # The main command from $copy_to_clipboard_cmd\n    # Example:\n    #   xclip -selection c\n    #   ├───┘\n    #   └ This part\n    clipboard=${copy_to_clipboard_cmd%% *}\n\n    for dependency in jq $browser $clipboard curl; do\n        if ! command -v \"$dependency\" >/dev/null 2>&1; then\n            # Append to our list of missing dependencies\n            dep_missing=\"$dep_missing $dependency\"\n        fi\n    done\n\n    if [ \"${#dep_missing}\" -gt 0 ]; then\n        printf %s \"Could not find the following dependencies:$dep_missing\"\n        exit 1\n    fi\n\n    # Create the $tmpmail_dir directory and dont throw any errors\n    # if it already exists\n    mkdir -p \"$tmpmail_dir\"\n\n    # Get the email address and save the value to the email_address variable\n    email_address=\"$(get_email_address)\"\n\n    # ${VAR#PATTERN} Removes shortest match of pattern from start of a string.\n    # In this case, it takes the email_address and removed everything after\n    # the '@' symbol which gives us the username.\n    username=${email_address%@*}\n\n    # ${VAR%PATTERN} Remove shortest match of pattern from end of a string.\n    # In this case, it takes the email_address and removes everything until the\n    # period '.' which gives us the domain\n    domain=${email_address#*@}\n\n    # If no arguments are provided just the emails\n    [ $# -eq 0 ] && list_emails && exit\n\n    while [ \"$1\" ]; do\n        case \"$1\" in\n            --help | -h) usage && exit ;;\n            --domains | -d) show_list_of_domains && exit ;;\n            --generate | -g) generate_email_address true \"$2\" && exit ;;\n            --clipboard-cmd) copy_to_clipboard_cmd=\"$2\" ;;\n            --copy | -c) copy_email_to_clipboard && exit ;;\n            --browser | -b) browser=\"$2\" ;;\n            --text | -t) raw_text=true ;;\n            --version) echo \"$version\" && exit ;;\n            --recent | -r) view_recent_email && exit ;;\n            *[0-9]*)\n                # If the user provides number as an argument,\n                # assume its the ID of an email and try getting\n                # the email that belongs to the ID\n                view_email \"$1\" && exit\n                ;;\n            -*) die \"option '$1' does not exist\" ;;\n        esac\n        shift\n    done\n}\n\nmain \"$@\"\n"
        },
        {
          "name": "tmpmail.1",
          "type": "blob",
          "size": 1.2265625,
          "content": ".Dd 2020-10-01\n.Dt tmpmail 1\n.Os\n.Sh NAME\n.Nm tmpmail\n.Nd temporary email\n.Sh SYNOPSIS\n.Nm\n.Nm\n.Fl h | -version\n.Nm\n.Fl g Op Ar ADDRESS\n.Nm\n.Op Fl t | b Ar BROWSER\n.Fl r | Ar ID\n.Sh DESCRIPTION\n.Nm\nis a command line utility written in POSIX shell that allows you to create a temporary email address and receive emails to the temporary email address. It uses 1secmail's API to receive emails.\n.Ss Options and Arguments\nWhen called with no option and no argument,\n.Nm\nlists the messages in the inbox and their numeric IDs.\nWhen called with one argument,\n.Nm\nshows the email message with specified\n.Ar ID .\n.Bl -tag -width Ds\n.It Fl b , Fl Fl browser Ar BROWSER\nSpecify\n.Ar BROWSER\n(default: w3m) that is used to render the HTML of the email\n.It Fl Fl clipboard-cmd Ar COMMAND\nSpecify the COMMAND to use for copying the email address to your\nclipboard (default: xclip -selection c)\n.It Fl g , Fl Fl generate Op Ar ADDRESS\nGenerate a new email address, either the specified\n.Ar ADDRESS ,\nor randomly create one\n.It Fl h , Fl Fl help\nShow help\n.It Fl r , Fl Fl recent\nView the most recent email message\n.It Fl t , Fl Fl text\nView the email as raw text, where all the HTML tags are removed.  Without this option, HTML is used.\n.It Fl Fl version\nShow version\n.El\n"
        }
      ]
    }
  ]
}