{
  "metadata": {
    "timestamp": 1736568673088,
    "page": 745,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "larkery/zsh-histdb",
      "stars": 1292,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2019 Tom Hinton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.org",
          "type": "blob",
          "size": 10.4638671875,
          "content": "#+TITLE:ZSH History Database\n\n* News\n- 13/10/21 :: Thanks to Aloxaf some subshell invocations have been removed which should make things quicker. Thanks to m42e (again) ~histdb-sync~ uses the remote database IDs as the canonical ones which should make syncing a bit less thrashy. Thanks to Chad Transtrum we use ~builtin which~ rather than ~which~, for systems which have an unusual which (?!), and an improvement to examples below in the README. Thanks to Klaus Ethgen the invocation of ~sqlite3~ is now unaffected by some potential confusions in your sqlite rc files.\n- 30/06/20 :: Thanks to rolandwalker, add-zsh-hook is used so histdb is a better citizen.\n  Thanks to GreenArchon and phiresky the sqlite helper process is terminated on exit better, and the WAL is truncated before doing histdb sync. This should make things behave a bit better. Thanks to gabreal (and others, I think), some things have been changed to ~declare -ga~ which helps when using antigen or somesuch? Thanks to sheperdjerred and fuero there is now a file which might make antigen and oh-my-zsh work.\n\n  There is a *breaking change*, which is that you no longer need to ~add-zsh-hook precmd histdb-update-outcome~ in your rc file. This now happens when you source ~sqlite-history.zsh~.\n- 11/03/20 :: Thanks to phiresky (https://github.com/phiresky) history appends within a shell session are performed through a single long-running sqlite process rather than by starting a new process per history append. This reduces contention between shells that are trying to write, as sqlite always fsyncs on exit.\n- 29/05/19 :: Thanks to Matthias Bilger (https://github.com/m42e/) a bug has been removed which would have broken the database if the vacuum command were used. Turns out, you can't use rowid as a foreign key unless you've given it a name. As a side-effect your database will need updating, in a non-backwards compatible way, so you'll need to update on all your installations at once if you share a history file.\n              Also, it's not impossible that this change will make a problem for someone somewhere, so be careful with this update.\n\n              Also thanks to Matthias, the exit status of long-running commands is handled better.\n- 05/04/18 :: I've done a bit of work to make a replacement reverse-isearch function, which is in a usable state now.\n\n              If you want to use it, see the [[Reverse isearch]] section below which now covers it.\n\n- 09/09/17 :: If you have already installed and you want to get the right timings in the database, see the installation section again. Fix to issue #18.\n\n* What is this\n\nThis is a small bit of zsh code that stores your history into a sqlite3 database.\nIt improves on the normal history by storing, for each history command:\n\n- The start and stop times of the command\n- The working directory where the command was run\n- The hostname of the machine\n- A unique per-host session ID, so history from several sessions is not confused\n- The exit status of the command\n\nIt is also possible to merge multiple history databases together without conflict, so long as all your machines have different hostnames.\n\n* Installation\n\nYou will need ~sqlite3~ and the usual coreutils commands installed on your ~PATH~.\nTo load and activate history recording you need to source ~sqlite-history.zsh~ from your shell in your zsh startup files.\n\nExample for installing in ~$HOME/.oh-my-zsh/custom/plugins/zsh-histdb~ (note that ~oh-my-zsh~ is not required):\n\n#+BEGIN_SRC zsh\nmkdir -p $HOME/.oh-my-zsh/custom/plugins/\ngit clone https://github.com/larkery/zsh-histdb $HOME/.oh-my-zsh/custom/plugins/zsh-histdb\n#+END_SRC\n\nAdd this to your ~$HOME/.zshrc~:\n\n#+BEGIN_SRC zsh\nsource $HOME/.oh-my-zsh/custom/plugins/zsh-histdb/sqlite-history.zsh\nautoload -Uz add-zsh-hook\n#+END_SRC\n\nin your zsh startup files.\n\n** Note for OS X users\n\nAdd the following line before you source `sqlite-history.zsh`. See https://github.com/larkery/zsh-histdb/pull/31 for details.\n\n#+BEGIN_SRC zsh\nHISTDB_TABULATE_CMD=(sed -e $'s/\\x1f/\\t/g')\n#+END_SRC\n\n** Importing your old history\n\n[[https://github.com/drewis/go-histdbimport][go-histdbimport]] and [[https://github.com/phiresky/ts-histdbimport][ts-histdbimport]] are useful tools for doing this! Note that the imported history will not include metadata such as the working directory or the exit status, since that is not stored in the normal history file format, so queries using ~--in DIR~, etc. will not work as expected.\n\n* Configuration\nhistdb can be configured exactly as zsh:\n- [[https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-HISTORY_005fIGNORE][HISTORY_IGNORE]]: If set, is treated as a single glob pattern to match the commands that should be ignored. Ignored commands are not saved to the database. Example: ~(ls|cd|top|htop)~.\n\n* Querying history\nYou can query the history with the ~histdb~ command.\nWith no arguments it will print one screenful of history on the current host.\n\nWith arguments, it will print history lines matching their concatenation.\n\nFor wildcards within a history line, you can use the ~%~ character, which is like the shell glob ~*~, so ~histdb this%that~ will match any history line containing ~this~ followed by ~that~ with zero or more characters in-between.\n\nTo search on particular hosts, directories, sessions, or time periods, see the help with ~histdb --help~.\n\nYou can also run ~histdb-top~ to see your most frequent commands, and ~histdb-top dir~ to show your favourite directory for running commands in, but these commands are really a bit useless.\n** Example:\n\n#+BEGIN_SRC text\n$ histdb strace\ntime   ses  dir  cmd\n17/03  438  ~    strace conkeror\n22/03  522  ~    strace apropos cake\n22/03  522  ~    strace -e trace=file s\n22/03  522  ~    strace -e trace=file ls\n22/03  522  ~    strace -e trace=file cat temp/people.vcf\n22/03  522  ~    strace -e trace=file cat temp/gammu.log\n22/03  522  ~    run-help strace\n24/03  547  ~    man strace\n#+END_SRC\n\nThese are all the history entries involving ~strace~ in my history.\nIf there was more than one screenful, I would need to say ~--limit 1000~ or some other large number.\nThe command does not warn you if you haven't seen all the results.\nThe ~ses~ column contains a unique session number, so all the ~522~ rows are from the same shell session.\n\nTo see all hosts, add ~--host~ /after/ the query terms.\nTo see a specific host, add ~--host hostname~.\nTo see all of a specific session say e.g. ~-s 522 --limit 10000~.\n** Integration with ~zsh-autosuggestions~\n\nIf you use [[https://github.com/zsh-users/zsh-autosuggestions][zsh-autosuggestions]] you can configure it to search the history database instead of the zsh history file thus:\n\n#+BEGIN_SRC sh\n  _zsh_autosuggest_strategy_histdb_top_here() {\n      local query=\"select commands.argv from\n  history left join commands on history.command_id = commands.rowid\n  left join places on history.place_id = places.rowid\n  where places.dir LIKE '$(sql_escape $PWD)%'\n  and commands.argv LIKE '$(sql_escape $1)%'\n  group by commands.argv order by count(*) desc limit 1\"\n      suggestion=$(_histdb_query \"$query\")\n  }\n\n  ZSH_AUTOSUGGEST_STRATEGY=histdb_top_here\n#+END_SRC\n\nThis query will find the most frequently issued command that is issued in the current directory or any subdirectory. You can get other behaviours by changing the query, for example\n\n#+BEGIN_SRC sh\n  _zsh_autosuggest_strategy_histdb_top() {\n      local query=\"\n          select commands.argv from history\n          left join commands on history.command_id = commands.rowid\n          left join places on history.place_id = places.rowid\n          where commands.argv LIKE '$(sql_escape $1)%'\n          group by commands.argv, places.dir\n          order by places.dir != '$(sql_escape $PWD)', count(*) desc\n          limit 1\n      \"\n      suggestion=$(_histdb_query \"$query\")\n  }\n\n  ZSH_AUTOSUGGEST_STRATEGY=histdb_top\n#+END_SRC\n\nThis will find the most frequently issued command issued exactly in this directory, or if there are no matches it will find the most frequently issued command in any directory. You could use other fields like the hostname to restrict to suggestions on this host, etc.\n** Reverse isearch\nIf you want a history-reverse-isearch type feature there is one defined in ~histdb-interactive.zsh~. If you source that file you will get a new widget called _histdb-isearch which you can bind to a key, e.g.\n\n#+BEGIN_SRC sh\nsource histdb-interactive.zsh\nbindkey '^r' _histdb-isearch\n#+END_SRC\n\nThis is like normal ~history-reverse-isearch~ except:\n- The search will start with the buffer contents automatically\n- The editing keys are all standard (because it does not really use the minibuffer).\n\n  This means pressing ~C-a~ or ~C-e~ or similar will not exit the search like normal ~history-reverse-isearch~\n- The accept key (~RET~) does not cause the command to run immediately but instead lets you edit it\n\nThere are also a few extra keybindings:\n\n- ~M-j~ will ~cd~ to the directory for the history entry you're looking at.\n  This means you can search for ./run-this-command and then ~M-j~ to go to the right directory before running.\n- ~M-h~ will toggle limiting the search to the current host's history.\n- ~M-d~ will toggle limiting the search to the current directory and subdirectories' histories\n* Database schema\nThe database lives by default in ~$HOME/.histdb/zsh-history.db~.\nYou can look in it easily by running ~_histdb_query~, as this actually just fires up sqlite with the database.\n\nFor inspiration you can also use ~histdb~ with the ~-d~ argument and it will print the SQL it's running.\n* Synchronising history\nYou should be able to synchronise the history using ~git~; a 3-way merge driver is supplied in ~histdb-merge~.\n\nThe 3-way merge will only work properly if all the computers on which you use the repository have different hostnames.\n\nThe ~histdb-sync~ function will initialize git in the histdb directory and configure the merge driver for you first time you run it.\nSubsequent times it will commit all changes, pull all changes, force a merge, and push all changes back again.\nThe commit message is useless, so if you find that kind of thing upsetting you will need to fix it.\n\nThe reason for using ~histdb-sync~ instead of doing it by hand is that if you are running the git steps in your shell the history database will be changed each command, and so you will never be able to do a pull / merge.\n* Completion\nNone, and I've used the names with underscores to mean something else.\n* Pull requests / missing features\nHappy to look at changes.\nI did at one point have a reverse-isearch thing in here for searching the database interactively, but it didn't really make my life any better so I deleted it.\n"
        },
        {
          "name": "db_migrations",
          "type": "tree",
          "content": null
        },
        {
          "name": "histdb-interactive.zsh",
          "type": "blob",
          "size": 5.689453125,
          "content": "typeset -g HISTDB_ISEARCH_N\ntypeset -g HISTDB_ISEARCH_MATCH\ntypeset -g HISTDB_ISEARCH_DIR\ntypeset -g HISTDB_ISEARCH_HOST\ntypeset -g HISTDB_ISEARCH_DATE\ntypeset -g HISTDB_ISEARCH_MATCH_END\n\ntypeset -g HISTDB_ISEARCH_THIS_HOST=1\ntypeset -g HISTDB_ISEARCH_THIS_DIR=0\ntypeset -g HISTDB_ISEARCH_LAST_QUERY=\"\"\ntypeset -g HISTDB_ISEARCH_LAST_N=\"\"\n\n# TODO Show more info about match (n, date, pwd, host)\n# TODO Keys to limit match?\n\n# make a keymap for histdb isearch\nbindkey -N histdb-isearch main\n\n_histdb_isearch_query () {\n    if [[ -z $BUFFER ]]; then\n       HISTDB_ISEARCH_MATCH=\"\"\n       return\n    fi\n\n    local new_query=\"$BUFFER $HISTDB_ISEARCH_THIS_HOST $HISTDB_ISEARCH_THIS_DIR\"\n    if [[ $new_query == $HISTDB_ISEARCH_LAST_QUERY ]] && [[ $HISTDB_ISEARCH_N == $HISTDB_ISEARCH_LAST_N ]]; then\n        return\n    elif [[ $new_query != $HISTDB_ISEARCH_LAST_QUERY ]]; then\n        HISTDB_ISEARCH_N=0\n    fi\n\n    HISTDB_ISEARCH_LAST_QUERY=$new_query\n    HISTDB_ISEARCH_LAST_N=HISTDB_ISEARCH_N\n\n    if (( $HISTDB_ISEARCH_N < 0 )); then\n        local maxmin=\"min\"\n        local ascdesc=\"asc\"\n        local offset=$(( - $HISTDB_ISEARCH_N ))\n    else\n        local maxmin=\"max\"\n        local ascdesc=\"desc\"\n        local offset=$(( $HISTDB_ISEARCH_N ))\n    fi\n\n    if [[ $HISTDB_ISEARCH_THIS_DIR == 1 ]]; then\n        local where_dir=\"and places.dir like '$(sql_escape $PWD)%'\"\n    else\n        local where_dir=\"\"\n    fi\n\n\n    if [[ $HISTDB_ISEARCH_THIS_HOST == 1 ]]; then\n        local where_host=\"and places.host = '$(sql_escape $HOST)'\"\n    else\n        local where_host=\"\"\n    fi\n\n    local query=\"select\ncommands.argv,\nplaces.dir,\nplaces.host,\ndatetime(max(history.start_time), 'unixepoch', 'localtime')\nfrom history left join commands\non history.command_id = commands.rowid\nleft join places\non history.place_id = places.rowid\nwhere commands.argv glob '*$(sql_escape ${BUFFER})*'\n${where_host}\n${where_dir}\ngroup by commands.argv, places.dir, places.host\norder by ${maxmin}(history.start_time) ${ascdesc}\nlimit 1\noffset ${offset}\"\n    local result=$(_histdb_query -separator $'\\n' \"$query\")\n    local lines=(\"${(f)result}\")\n    HISTDB_ISEARCH_DATE=${lines[-1]}\n    HISTDB_ISEARCH_HOST=${lines[-2]}\n    HISTDB_ISEARCH_DIR=${lines[-3]}\n    lines[-1]=()\n    lines[-1]=()\n    lines[-1]=()\n    HISTDB_ISEARCH_MATCH=${(F)lines}\n}\n\n_histdb_isearch_display () {\n    if [[ $HISTDB_ISEARCH_THIS_HOST == 1 ]]; then\n        local host_bit=\" h\"\n    else\n        local host_bit=\"\"\n    fi\n    if [[ $HISTDB_ISEARCH_THIS_DIR == 1 ]]; then\n        local dir_bit=\" d\"\n    else\n        local dir_bit=\"\"\n    fi\n    local top_bit=\"histdb ${HISTDB_ISEARCH_N}${host_bit}${dir_bit}: \"\n    if [[ -z ${HISTDB_ISEARCH_MATCH} ]]; then\n        PREDISPLAY=\"(no match)\n$top_bit\"\n    else\n        local qbuffer=\"${(b)BUFFER}\"\n        qbuffer=\"${${qbuffer//\\\\\\*/*}//\\\\\\?/?}\"\n        local match_len=\"${#HISTDB_ISEARCH_MATCH}\"\n        local prefix=\"${HISTDB_ISEARCH_MATCH%%${~qbuffer}*}\"\n        local prefix_len=\"${#prefix}\"\n        local suffix_len=\"${#${HISTDB_ISEARCH_MATCH:${prefix_len}}##${~qbuffer}}\"\n        local match_end=$(( $match_len - $suffix_len ))\n        HISTDB_ISEARCH_MATCH_END=${match_end}\n\n        if [[ $HISTDB_ISEARCH_HOST == $HOST ]]; then\n            local host=\"\"\n        else\n            local host=\"\n  host: $HISTDB_ISEARCH_HOST\"\n        fi\n        region_highlight=(\"P${prefix_len} ${match_end} underline\")\n        PREDISPLAY=\"${HISTDB_ISEARCH_MATCH}\n→ in ${HISTDB_ISEARCH_DIR}$host\n→ on ${HISTDB_ISEARCH_DATE}\n$top_bit\"\n    fi\n}\n\n_histdb-isearch-up () {\n    HISTDB_ISEARCH_N=$(( $HISTDB_ISEARCH_N + 1 ))\n}\n\n_histdb-isearch-down () {\n    HISTDB_ISEARCH_N=$(( $HISTDB_ISEARCH_N - 1 ))\n}\n\nzle -N self-insert-histdb-isearch\n\n_histdb_line_redraw () {\n    _histdb_isearch_query\n    _histdb_isearch_display\n}\n\n_histdb-isearch () {\n    local old_buffer=${BUFFER}\n    local old_cursor=${CURSOR}\n    HISTDB_ISEARCH_N=0\n    echo -ne \"\\e[4 q\" # switch to underline cursor\n\n    zle -K histdb-isearch\n    zle -N zle-line-pre-redraw _histdb_line_redraw\n    _histdb_isearch_query\n    _histdb_isearch_display\n    zle recursive-edit; local stat=$?\n    zle -D zle-line-pre-redraw # TODO push/pop zle-line-pre-redraw and\n                               # self-insert, rather than nuking\n\n    zle -K main\n    PREDISPLAY=\"\"\n    region_highlight=()\n\n    echo -ne \"\\e[1 q\" #box cursor\n\n    if ! (( stat )); then\n        BUFFER=\"${HISTDB_ISEARCH_MATCH}\"\n        CURSOR=\"${HISTDB_ISEARCH_MATCH_END}\"\n    else\n        BUFFER=${old_buffer}\n        CURSOR=${old_cursor}\n    fi\n\n    return 0\n}\n\n# this will work outside histdb-isearch if you want\n# so you can recover from history and then cd afterwards\n_histdb-isearch-cd () {\n    if [[ -d ${HISTDB_ISEARCH_DIR} ]]; then\n        cd \"${HISTDB_ISEARCH_DIR}\"\n        zle reset-prompt\n    fi\n}\n\n_histdb-isearch-toggle-host () {\n    if [[ $HISTDB_ISEARCH_THIS_HOST == 1 ]]; then\n        HISTDB_ISEARCH_THIS_HOST=0\n    else\n        HISTDB_ISEARCH_THIS_HOST=1\n    fi\n}\n\n_histdb-isearch-toggle-dir () {\n    if [[ $HISTDB_ISEARCH_THIS_DIR == 1 ]]; then\n        HISTDB_ISEARCH_THIS_DIR=0\n    else\n        HISTDB_ISEARCH_THIS_DIR=1\n    fi\n}\n\nzle -N _histdb-isearch-up\nzle -N _histdb-isearch-down\nzle -N _histdb-isearch\nzle -N _histdb-isearch-cd\nzle -N _histdb-isearch-toggle-dir\nzle -N _histdb-isearch-toggle-host\n\nbindkey -M histdb-isearch '\u0012' _histdb-isearch-up\nbindkey -M histdb-isearch '^[[A' _histdb-isearch-up\n\nbindkey -M histdb-isearch '\u0013' _histdb-isearch-down\nbindkey -M histdb-isearch '^[[B' _histdb-isearch-down\n\nbindkey -M histdb-isearch '^[j' _histdb-isearch-cd\n\nbindkey -M histdb-isearch '^[h' _histdb-isearch-toggle-host\nbindkey -M histdb-isearch '^[d' _histdb-isearch-toggle-dir\n\n# because we are using BUFFER for output, we have to reimplement\n# pretty much the whole set of buffer editing operations\n"
        },
        {
          "name": "histdb-merge",
          "type": "blob",
          "size": 2.3681640625,
          "content": "#!/usr/bin/env zsh\n\ntypeset -g HERE=$(dirname \"${(%):-%N}\")\n\nlocal ancestor=${1:?three databases required}; shift\nlocal ours=${1:?three databases required}; shift\nlocal theirs=${1:?three databases required}\n\n$HERE/histdb-migrate $ancestor # this is always reasonable to do\n$HERE/histdb-migrate $ours # this also seems fine\n\nV_OURS=$(sqlite3 -batch -noheader $ours 'PRAGMA user_version')\nV_THEIRS=$(sqlite3 -batch -noheader $theirs 'PRAGMA user_version')\n\nif [[ ${V_OURS} -lt ${V_THEIRS} ]] ; then\n    echo \"Attempting to merge with a database from a future version (${V_THEIRS}).\"\n    echo \"You need to update your histdb version to continue.\"\n    exit 1\nelif [[ ${V_THEIRS} -lt ${V_OURS} ]]; then\n    echo \"Merging different database versions: ours ${V_OURS}, theirs ${V_THEIRS}.\"\n    echo \"To continue merging, their database needs migrating to newer version.\"\n    echo \"If you do this, and push the changes, then the remote version of histdb will need upgrading too.\"\n    \n    read -q \"REPLY?Try migrating their database? [y/n] \"\n    if [[ $REPLY != \"y\" ]]; then\n        echo \"Cancelled.\"\n        exit 1\n    fi\nfi\n\n# for reasons I cannot use the encryption filter here.\n# most annoying.\n#\necho \"Ancestor has $(sqlite3 ${ancestor} 'select count(*) from history') entries\"\necho \"We have $(sqlite3 ${ours} 'select count(*) from history') entries\"\necho \"Theirs have $(sqlite3 ${theirs} 'select count(*) from history') entries\"\n\nsqlite3 -batch -noheader \"${theirs}\" <<EOF\nATTACH DATABASE '${ours}' AS n;\nATTACH DATABASE '${ancestor}' AS a;\n\n-- copy missing commands and places\nINSERT INTO commands (argv) SELECT argv FROM n.commands as NC where NC.id > (SELECT max(id) FROM a.commands);\nINSERT INTO places (host, dir) SELECT host, dir FROM n.places as NP where NP.id > (SELECT max(id) FROM a.places);\n\n-- insert missing history, rewriting IDs\n-- could uniquify sessions by host in this way too\n\nINSERT INTO history (session, command_id, place_id, exit_status, start_time, duration)\nSELECT NO.session, C.id, P.id, NO.exit_status, NO.start_time, NO.duration\nFROM n.history NO\nLEFT JOIN n.places PO ON NO.place_id = PO.id\nLEFT JOIN n.commands CO ON NO.command_id = CO.id\nLEFT JOIN commands C ON C.argv = CO.argv\nLEFT JOIN places P ON (P.host = PO.host\nAND P.dir = PO.dir)\nWHERE NO.id > (SELECT MAX(id) FROM a.history)\n;\nVACUUM;\nEOF\ncp ${theirs} ${ours}\necho \"Now we have $(sqlite3 ${ours} 'select count(*) from history') entries\"\n"
        },
        {
          "name": "histdb-migrate",
          "type": "blob",
          "size": 1.5361328125,
          "content": "#!/usr/bin/env zsh\n\ntypeset -g HISTDB_SCHEMA_VERSION=2\ntypeset -g HISTDB_INSTALLED_IN=\"${(%):-%N}\"\n\nlocal TARGET_FILE=\"$1\"\nlocal CURRENT_VERSION=$(sqlite3 -batch -noheader \"${TARGET_FILE}\" 'PRAGMA user_version')\nif [[ ${CURRENT_VERSION} -lt ${HISTDB_SCHEMA_VERSION} ]]; then\n    echo \"History database ${TARGET_FILE} is using an older schema (${CURRENT_VERSION}) and will be updated to version ${HISTDB_SCHEMA_VERSION}.\"\n    local MIGRATION_FILENAME=\"$(dirname ${HISTDB_INSTALLED_IN})/db_migrations/${CURRENT_VERSION}to${HISTDB_SCHEMA_VERSION}.sql\"\n    if [[ -f $MIGRATION_FILENAME ]]; then\n        local BACKUP_FILE=\"${TARGET_FILE}-$(date +%s).bak\"\n        echo \"Backing up database to ${BACKUP_FILE} before migration\"\n        cp ${BACKUP_FILE} ${HISTDB_FILE}\n        sqlite3 -batch -noheader \"${TARGET_FILE}\" < \"${MIGRATION_FILENAME}\"\n        local R=\"$?\"\n        [[ \"$R\" -ne 0 ]] && (echo \"Error during database conversion\"; cp ${BACKUP_FILE} ${HISTDB_FILE}) || echo \"Update successful (you may want to remove the backup)\"\n        return \"$R\"\n    else\n        echo \"There is no migration script from version ${CURRENT_VERSION} to ${HISTDB_SCHEMA_VERSION}.\"\n        return 1\n    fi\nelif [[ ${CURRENT_VERSION} -gt ${HISTDB_SCHEMA_VERSION} ]]; then\n    echo \"History database ${TARGET_FILE} is using a newer schema (${CURRENT_VERSION}) than this version of histdb understands (${HISTDB_SCHEMA_VERSION}).\"\n    echo \"Most likely, you have updated histdb on another machine which has updated your history database, and you need to update this copy of histdb.\"\n    return 1\nfi\n"
        },
        {
          "name": "sqlite-history.zsh",
          "type": "blob",
          "size": 15.34375,
          "content": "which sqlite3 >/dev/null 2>&1 || return;\n\nzmodload zsh/datetime # for EPOCHSECONDS\nzmodload zsh/system # for sysopen\nbuiltin which sysopen &>/dev/null || return; # guard against zsh older than 5.0.8.\n\nzmodload -F zsh/stat b:zstat # just zstat\nautoload -U add-zsh-hook\n\ntypeset -g HISTDB_QUERY=\"\"\nif [[ -z ${HISTDB_FILE} ]]; then\n    typeset -g HISTDB_FILE=\"${HOME}/.histdb/zsh-history.db\"\nelse\n    typeset -g HISTDB_FILE\nfi\n\ntypeset -g HISTDB_FD\ntypeset -g HISTDB_INODE=()\ntypeset -g HISTDB_SESSION=\"\"\ntypeset -g HISTDB_HOST=\"\"\ntypeset -g HISTDB_INSTALLED_IN=\"${(%):-%N}\"\n\n\n\nsql_escape () {\n    print -r -- ${${@//\\'/\\'\\'}//$'\\x00'}\n}\n\n_histdb_query () {\n    sqlite3 -batch -noheader -cmd \".timeout 1000\" \"${HISTDB_FILE}\" \"$@\"\n    [[ \"$?\" -ne 0 ]] && echo \"error in $@\"\n}\n\n_histdb_stop_sqlite_pipe () {\n    if [[ -n $HISTDB_FD ]]; then\n        if print -nu$HISTDB_FD; then\n            exec {HISTDB_FD}>&-;  # https://stackoverflow.com/a/22794374/2639190\n        fi\n    fi\n    # Sometimes, it seems like closing the fd does not terminate the\n    # sqlite batch process, so here is a horrible fallback.\n    # if [[ -n $HISTDB_SQLITE_PID ]]; then\n    #     ps -o args= -p $HISTDB_SQLITE_PID | read -r args\n    #     if [[ $args == \"sqlite3 -batch ${HISTDB_FILE}\" ]]; then\n    #         kill -TERM $HISTDB_SQLITE_PID\n    #     fi\n    # fi\n}\n\nadd-zsh-hook zshexit _histdb_stop_sqlite_pipe\n\n_histdb_start_sqlite_pipe () {\n    local PIPE==(<<<'')\n    setopt local_options no_notify no_monitor\n    mkfifo $PIPE\n    sqlite3 -batch -noheader \"${HISTDB_FILE}\" < $PIPE >/dev/null &|\n    sysopen -w -o cloexec -u HISTDB_FD -- $PIPE\n    command rm $PIPE\n    zstat -A HISTDB_INODE +inode ${HISTDB_FILE}\n}\n\n_histdb_query_batch () {\n    local CUR_INODE\n    zstat -A CUR_INODE +inode ${HISTDB_FILE}\n    if [[ $CUR_INODE != $HISTDB_INODE ]]; then\n        _histdb_stop_sqlite_pipe\n        _histdb_start_sqlite_pipe\n    fi\n    cat >&$HISTDB_FD\n    echo ';' >&$HISTDB_FD # make sure last command is executed\n}\n\n_histdb_init () {\n    if [[ -n \"${HISTDB_SESSION}\" ]]; then\n        return\n    fi\n\n    if ! [[ -e \"${HISTDB_FILE}\" ]]; then\n        local hist_dir=\"${HISTDB_FILE:h}\"\n        if ! [[ -d \"$hist_dir\" ]]; then\n            mkdir -p -- \"$hist_dir\"\n        fi\n        _histdb_query <<-EOF\ncreate table commands (id integer primary key autoincrement, argv text, unique(argv) on conflict ignore);\ncreate table places   (id integer primary key autoincrement, host text, dir text, unique(host, dir) on conflict ignore);\ncreate table history  (id integer primary key autoincrement,\n                       session int,\n                       command_id int references commands (id),\n                       place_id int references places (id),\n                       exit_status int,\n                       start_time int,\n                       duration int);\nPRAGMA user_version = 2;\nEOF\n    fi\n    if [[ -z \"${HISTDB_SESSION}\" ]]; then\n        ${HISTDB_INSTALLED_IN:h}/histdb-migrate \"${HISTDB_FILE}\"\n        HISTDB_HOST=${HISTDB_HOST:-\"'$(sql_escape ${HOST})'\"}\n        HISTDB_SESSION=$(_histdb_query \"select 1+max(session) from history inner join places on places.id=history.place_id where places.host = ${HISTDB_HOST}\")\n        HISTDB_SESSION=\"${HISTDB_SESSION:-0}\"\n        readonly HISTDB_SESSION\n    fi\n\n    _histdb_start_sqlite_pipe\n    _histdb_query_batch >/dev/null <<EOF\ncreate index if not exists hist_time on history(start_time);\ncreate index if not exists place_dir on places(dir);\ncreate index if not exists place_host on places(host);\ncreate index if not exists history_command_place on history(command_id, place_id);\nPRAGMA journal_mode = WAL;\nPRAGMA synchronous=normal;\nEOF\n}\n\ndeclare -ga _BORING_COMMANDS\n_BORING_COMMANDS=(\"^ls$\" \"^cd$\" \"^ \" \"^histdb\" \"^top$\" \"^htop$\")\n\nif [[ -z \"${HISTDB_TABULATE_CMD[*]:-}\" ]]; then\n    declare -ga HISTDB_TABULATE_CMD\n    HISTDB_TABULATE_CMD=(column -t -s $'\\x1f')\nfi\n\n_histdb_update_outcome () {\n    local retval=$?\n    local finished=$EPOCHSECONDS\n    [[ -z \"${HISTDB_SESSION}\" ]] && return\n\n    _histdb_init\n    _histdb_query_batch <<EOF &|\nupdate history set\n      exit_status = ${retval},\n      duration = ${finished} - start_time\nwhere id = (select max(id) from history) and\n      session = ${HISTDB_SESSION} and\n      exit_status is NULL;\nEOF\n}\n\n_histdb_addhistory () {\n    local cmd=\"${1[0, -2]}\"\n\n    if [[ -o histignorespace && \"$cmd\" =~ \"^ \" ]]; then\n        return 0\n    fi\n    if [[ ${cmd} == ${~HISTORY_IGNORE} ]]; then\n        return 0\n    fi\n    local boring\n    for boring in \"${_BORING_COMMANDS[@]}\"; do\n        if [[ \"$cmd\" =~ $boring ]]; then\n            return 0\n        fi\n    done\n\n    local cmd=\"'$(sql_escape $cmd)'\"\n    local pwd=\"'$(sql_escape ${PWD})'\"\n    local started=$EPOCHSECONDS\n    _histdb_init\n\n    if [[ \"$cmd\" != \"''\" ]]; then\n        _histdb_query_batch <<EOF &|\ninsert into commands (argv) values (${cmd});\ninsert into places   (host, dir) values (${HISTDB_HOST}, ${pwd});\ninsert into history\n  (session, command_id, place_id, start_time)\nselect\n  ${HISTDB_SESSION},\n  commands.id,\n  places.id,\n  ${started}\nfrom\n  commands, places\nwhere\n  commands.argv = ${cmd} and\n  places.host = ${HISTDB_HOST} and\n  places.dir = ${pwd}\n;\nEOF\n    fi\n    return 0\n}\n\nadd-zsh-hook zshaddhistory _histdb_addhistory\nadd-zsh-hook precmd _histdb_update_outcome\n\nhistdb-top () {\n    _histdb_init\n    local sep=$'\\x1f'\n    local field\n    local join\n    local table\n    1=${1:-cmd}\n    case \"$1\" in\n        dir)\n            field=places.dir\n            join='places.id = history.place_id'\n            table=places\n            ;;\n        cmd)\n            field=commands.argv\n            join='commands.id = history.command_id'\n            table=commands\n            ;;;\n    esac\n    _histdb_query -separator \"$sep\" \\\n            -header \\\n            \"select count(*) as count, places.host, replace($field, '\n', '\n$sep$sep') as ${1:-cmd} from history left join commands on history.command_id=commands.id left join places on history.place_id=places.id group by places.host, $field order by count(*)\" | \\\n        \"${HISTDB_TABULATE_CMD[@]}\"\n}\n\nhistdb-sync () {\n    _histdb_init\n\n    # this ought to apply to other readers?\n    echo \"truncating WAL\"\n    echo 'pragma wal_checkpoint(truncate);' | _histdb_query_batch\n    \n    local hist_dir=\"${HISTDB_FILE:h}\"\n    if [[ -d \"$hist_dir\" ]]; then\n        () {\n            setopt local_options no_pushd_ignore_dups\n\n            pushd -q \"$hist_dir\"\n            if [[ $(git rev-parse --is-inside-work-tree) != \"true\" ]] || [[ \"$(git rev-parse --show-toplevel)\" != \"${PWD:A}\" ]]; then\n                git init\n                git config merge.histdb.driver \"${HISTDB_INSTALLED_IN:h}/histdb-merge %O %A %B\"\n                echo \"${HISTDB_FILE:t} merge=histdb\" >>! .gitattributes\n                git add .gitattributes\n                git add \"${HISTDB_FILE:t}\"\n            fi\n            _histdb_stop_sqlite_pipe # Stop in case of a merge, starting again afterwards\n            git commit -am \"history\" && git pull --no-edit && git push\n            _histdb_start_sqlite_pipe\n            popd -q\n        }\n    fi\n\n    echo 'pragma wal_checkpoint(passive);' | _histdb_query_batch\n}\n\nhistdb () {\n    _histdb_init\n    local -a opts\n    local -a hosts\n    local -a indirs\n    local -a atdirs\n    local -a sessions\n\n    zparseopts -E -D -a opts \\\n               -host+::=hosts \\\n               -in+::=indirs \\\n               -at+::=atdirs \\\n               -forget \\\n               -yes \\\n               -detail \\\n               -sep:- \\\n               -exact \\\n               d h -help \\\n               s+::=sessions \\\n               -from:- -until:- -limit:- \\\n               -status:- -desc\n\n    local usage=\"usage:$0 terms [--desc] [--host[ x]] [--in[ x]] [--at] [-s n]+* [-d] [--detail] [--forget] [--yes] [--exact] [--sep x] [--from x] [--until x] [--limit n] [--status x]\n    --desc     reverse sort order of results\n    --host     print the host column and show all hosts (otherwise current host)\n    --host x   find entries from host x\n    --in       find only entries run in the current dir or below\n    --in x     find only entries in directory x or below\n    --at       like --in, but excluding subdirectories\n    -s n       only show session n\n    -d         debug output query that will be run\n    --detail   show details\n    --forget   forget everything which matches in the history\n    --yes      don't ask for confirmation when forgetting\n    --exact    don't match substrings\n    --sep x    print with separator x, and don't tabulate\n    --from x   only show commands after date x (sqlite date parser)\n    --until x  only show commands before date x (sqlite date parser)\n    --limit n  only show n rows. defaults to $LINES or 25\n    --status x only show rows with exit status x. Can be 'error' to find all nonzero.\"\n\n    local selcols=\"session as ses, dir\"\n    local cols=\"session, replace(places.dir, '$HOME', '~') as dir\"\n    local where=\"1\"\n    if [[ -p /dev/stdout ]]; then\n        local limit=\"\"\n    else\n        local limit=\"${$((LINES - 4)):-25}\"\n    fi\n\n    local forget=\"0\"\n    local forget_accept=0\n    local exact=0\n\n    if (( ${#hosts} )); then\n        local hostwhere=\"\"\n        local host=\"\"\n        for host ($hosts); do\n            host=\"${${host#--host}#=}\"\n            hostwhere=\"${hostwhere}${host:+${hostwhere:+ or }places.host='$(sql_escape ${host})'}\"\n        done\n        where=\"${where}${hostwhere:+ and (${hostwhere})}\"\n        cols=\"${cols}, places.host as host\"\n        selcols=\"${selcols}, host\"\n    else\n        where=\"${where} and places.host=${HISTDB_HOST}\"\n    fi\n\n    if (( ${#indirs} + ${#atdirs} )); then\n        local dirwhere=\"\"\n        local dir=\"\"\n        for dir ($indirs); do\n            dir=\"${${${dir#--in}#=}:-$PWD}\"\n            dirwhere=\"${dirwhere}${dirwhere:+ or }places.dir like '$(sql_escape $dir)%'\"\n        done\n        for dir ($atdirs); do\n            dir=\"${${${dir#--at}#=}:-$PWD}\"\n            dirwhere=\"${dirwhere}${dirwhere:+ or }places.dir = '$(sql_escape $dir)'\"\n        done\n        where=\"${where}${dirwhere:+ and (${dirwhere})}\"\n    fi\n\n    if (( ${#sessions} )); then\n        local sin=\"\"\n        local ses=\"\"\n        for ses ($sessions); do\n            ses=\"${${${ses#-s}#=}:-${HISTDB_SESSION}}\"\n            sin=\"${sin}${sin:+, }$ses\"\n        done\n        where=\"${where}${sin:+ and session in ($sin)}\"\n    fi\n\n    local sep=$'\\x1f'\n    local orderdir='asc'\n    local debug=0\n    local opt=\"\"\n    for opt ($opts); do\n        case $opt in\n            --desc)\n                orderdir='desc'\n                ;;\n            --sep*)\n                sep=${opt#--sep}\n                ;;\n            --from*)\n                local from=${opt#--from}\n                case $from in\n                    -*)\n                        from=\"datetime('now', '$from')\"\n                        ;;\n                    today)\n                        from=\"datetime('now', 'start of day')\"\n                        ;;\n                    yesterday)\n                        from=\"datetime('now', 'start of day', '-1 day')\"\n                        ;;\n                esac\n                where=\"${where} and datetime(start_time, 'unixepoch') >= $from\"\n                ;;\n            --status*)\n                local xstatus=${opt#--status}\n                case $xstatus in\n                    <->)\n                        where=\"${where} and exit_status = $xstatus\"\n                        ;;\n                        error)\n                        where=\"${where} and exit_status <> 0\"\n                        ;;\n                esac\n                ;;\n            --until*)\n                local until=${opt#--until}\n                case $until in\n                    -*)\n                        until=\"datetime('now', '$until')\"\n                        ;;\n                    today)\n                        until=\"datetime('now', 'start of day')\"\n                        ;;\n                    yesterday)\n                        until=\"datetime('now', 'start of day', '-1 day')\"\n                        ;;\n                esac\n                where=\"${where} and datetime(start_time, 'unixepoch') <= $until\"\n                ;;\n            -d)\n                debug=1\n                ;;\n            --detail)\n                cols=\"${cols}, exit_status, duration \"\n                selcols=\"${selcols}, exit_status as [?],duration as secs \"\n                ;;\n            -h|--help)\n                echo \"$usage\"\n                return 0\n                ;;\n            --forget)\n                forget=1\n                ;;\n            --yes)\n                forget_accept=1\n                ;;\n            --exact)\n                exact=1\n                ;;\n            --limit*)\n                limit=${opt#--limit}\n                ;;\n        esac\n    done\n\n    if [[ -n \"$*\" ]]; then\n        if [[ $exact -eq 0 ]]; then\n            where=\"${where} and commands.argv glob '*$(sql_escape $@)*'\"\n        else\n            where=\"${where} and commands.argv = '$(sql_escape $@)'\"\n        fi\n    fi\n\n    if [[ $forget -gt 0 ]]; then\n        limit=\"\"\n    fi\n    local seps=$(echo \"$cols\" | tr -c -d ',' | tr ',' $sep)\n    cols=\"${cols}, replace(commands.argv, '\n', '\n$seps') as argv, max(start_time) as max_start\"\n\n    local mst=\"datetime(max_start, 'unixepoch')\"\n    local dst=\"datetime('now', 'start of day')\"\n    local timecol=\"strftime(case when $mst > $dst then '%H:%M' else '%d/%m' end, max_start, 'unixepoch', 'localtime') as time\"\n\n    selcols=\"${timecol}, ${selcols}, argv as cmd\"\n\n    local r_order=\"asc\"\n    if [[ $orderdir == \"asc\" ]]; then\n        r_order=\"desc\"\n    fi\n\n    local query=\"select ${selcols} from (select ${cols}\nfrom\n  commands\n  join history on history.command_id = commands.id\n  join places on history.place_id = places.id\nwhere ${where}\ngroup by history.command_id, history.place_id\norder by max_start ${r_order}\n${limit:+limit $limit}) order by max_start ${orderdir}\"\n\n    ## min max date?\n    local count_query=\"select count(*) from (select ${cols}\nfrom\n  commands\n  join history on history.command_id = commands.id\n  join places  on history.place_id = places.id\nwhere ${where}\ngroup by history.command_id, history.place_id\norder by max_start desc) order by max_start ${orderdir}\"\n\n    if [[ $debug = 1 ]]; then\n        echo \"$query\"\n    else\n        local count=$(_histdb_query \"$count_query\")\n        if [[ -p /dev/stdout ]]; then\n            buffer() {\n                ## this runs out of memory for big files I think perl -e 'local $/; my $stdin = <STDIN>; print $stdin;'\n                temp=$(mktemp)\n                cat >! \"$temp\"\n                cat -- \"$temp\"\n                rm -f -- \"$temp\"\n            }\n        else\n            buffer() {\n                cat\n            }\n        fi\n        if [[ $sep == $'\\x1f' ]]; then\n            _histdb_query -header -separator $sep \"$query\" | iconv -f utf-8 -t utf-8 -c | buffer | \"${HISTDB_TABULATE_CMD[@]}\"\n        else\n            _histdb_query -header -separator $sep \"$query\" | buffer\n        fi\n        [[ -n $limit ]] && [[ $limit -lt $count ]] && echo \"(showing $limit of $count results)\"\n    fi\n\n    if [[ $forget -gt 0 ]]; then\n        if [[ $forget_accept -gt 0 ]]; then\n          REPLY=y\n        else\n          read -q \"REPLY?Forget all these results? [y/n] \"\n        fi\n        if [[ $REPLY =~ \"[yY]\" ]]; then\n            _histdb_query \"delete from history where\nhistory.id in (\nselect history.id from\nhistory\n  left join commands on history.command_id = commands.id\n  left join places on history.place_id = places.id\nwhere ${where})\"\n            _histdb_query \"delete from commands where commands.id not in (select distinct history.command_id from history)\"\n        fi\n    fi\n}\n"
        },
        {
          "name": "zsh-histdb.plugin.zsh",
          "type": "blob",
          "size": 0.0341796875,
          "content": "source ${0:A:h}/sqlite-history.zsh\n"
        }
      ]
    }
  ]
}