{
  "metadata": {
    "timestamp": 1736568510702,
    "page": 511,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUxOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "andrewjfreyer/monitor",
      "stars": 1681,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.978515625,
          "content": "# mac related files\n.DS_Store\n\n# configuration files\naddress_blacklist\nbehavior_preferences\nknown_beacon_addresses\nknown_static_addresses\nmqtt_preferences\n\n# caches/temp files\n.pids\n.previous_version\n.public_name_cache\n.manufacturer_cache\n\n# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and WebStorm\n# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839\n\n# User-specific stuff\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/**/usage.statistics.xml\n.idea/**/dictionaries\n.idea/**/shelf\n\n# Generated files\n.idea/**/contentModel.xml\n\n# Sensitive or high-churn files\n.idea/**/dataSources/\n.idea/**/dataSources.ids\n.idea/**/dataSources.local.xml\n.idea/**/sqlDataSources.xml\n.idea/**/dynamic.xml\n.idea/**/uiDesigner.xml\n.idea/**/dbnavigator.xml\n\n# Gradle\n.idea/**/gradle.xml\n.idea/**/libraries\n\n# Gradle and Maven with auto-import\n# When using Gradle or Maven with auto-import, you should exclude module files,\n# since they will be recreated, and may cause churn.  Uncomment if using\n# auto-import.\n# .idea/artifacts\n# .idea/compiler.xml\n# .idea/jarRepositories.xml\n# .idea/modules.xml\n# .idea/*.iml\n# .idea/modules\n# *.iml\n# *.ipr\n\n# CMake\ncmake-build-*/\n\n# Mongo Explorer plugin\n.idea/**/mongoSettings.xml\n\n# File-based project format\n*.iws\n\n# IntelliJ\nout/\n\n# mpeltonen/sbt-idea plugin\n.idea_modules/\n\n# JIRA plugin\natlassian-ide-plugin.xml\n\n# Cursive Clojure plugin\n.idea/replstate.xml\n\n# Crashlytics plugin (for Android Studio and IntelliJ)\ncom_crashlytics_export_strings.xml\ncrashlytics.properties\ncrashlytics-build.properties\nfabric.properties\n\n# Editor-based Rest Client\n.idea/httpRequests\n\n# Android studio 3.1+ serialized cache file\n.idea/caches/build_file_checksums.ser\n\n# Vim related\n# Swap\n[._]*.s[a-v][a-z]\n!*.svg  # comment out if you don't need vector files\n[._]*.sw[a-p]\n[._]s[a-rt-v][a-z]\n[._]ss[a-gi-z]\n[._]sw[a-p]\n\n# Session\nSession.vim\nSessionx.vim\n\n# Temporary\n.netrwhist\n*~\n# Auto-generated tag files\ntags\n# Persistent undo\n[._]*.un~\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.619140625,
          "content": "`monitor`\n=======\n***TL;DR***: Passive Bluetooth presence detection of beacons, cell phones, and other Bluetooth devices. Useful for [mqtt-based](http://mqtt.org) home automation, especially when the script runs on multiple devices, distributed throughout a property. \n\n![version](https://img.shields.io/badge/version-0.2-green.svg?maxAge=2592000) ![mosquitto](https://img.shields.io/badge/mosquitto-1.5+-blue.svg?maxAge=2592000)\n\n[**Frequently Asked Questions**](https://github.com/andrewjfreyer/monitor/blob/master/support/README.md)\n\n<details><summary><b>Installation Instructions</b></summary>\n\n<br>\n\n<details><summary><i>Set Up Raspberry Pi From Scratch</i></summary>\n\n\n# Installation Instructions for Raspberry Pi Zero W\n\n## Setup of SD Card\n\n1. Download latest version of **raspbian** [here](https://downloads.raspberrypi.org/raspbian_lite_latest)\n\n2. Download etcher from [etcher.io](https://etcher.io)\n\n3. Image **raspbian lite buster** to SD card. [Instructions here.](https://www.raspberrypi.org/magpi/pi-sd-etcher/)\n\n4. Mount **boot** partition of imaged SD card (unplug it and plug it back in)\n\n5. **To enable ssh,** create blank file, without any extension, in the root directory called **ssh**\n\n6. **To setup Wi-Fi**, create **wpa_supplicant.conf** file in root directory and add Wi-Fi details for home Wi-Fi:\n\n```bash\ncountry=US\n    ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n    update_config=1\n\nnetwork={\n    ssid=\"Your Network Name\"\n    psk=\"Your Network Password\"\n    key_mgmt=WPA-PSK\n}\n```\n\n 7. **On the first startup,** insert SD card and power on Raspberry Pi Zero W. On first boot, the newly-created **wpa_supplicant.conf** file and **ssh** will be moved to appropriate directories. Find the IP address of the Pi via your router. \n\n## Configuration and Setup\n\n1. SSH into the Raspberry Pi (default password: raspberry):\n```bash\nssh pi@theipaddress\n```\n\n2. Change the default password:\n```bash \nsudo passwd pi\n```\n\n3. Update and upgrade:\n\n```bash\nsudo apt-get update\nsudo apt-get upgrade -y\nsudo apt-get dist-upgrade -y\nsudo reboot\n```\n\n5. Install Bluetooth Firmware, if necessary:\n```bash\n#install Bluetooth drivers for Pi Zero W\nsudo apt-get install pi-bluetooth\n\n```\n\n6. Reboot:\n```bash\nsudo reboot\n```\n\n7. Install Mosquitto 1.5+ **(important step!)**:\n```bash\n\n# get repo key\nwget http://repo.mosquitto.org/debian/mosquitto-repo.gpg.key\n\n#add repo\nsudo apt-key add mosquitto-repo.gpg.key\n\n#download appropriate lists file \ncd /etc/apt/sources.list.d/\nsudo wget http://repo.mosquitto.org/debian/mosquitto-buster.list\n\n#update caches and install \nsudo apt-cache search mosquitto\nsudo apt-get update\nsudo apt-get install -f libmosquitto-dev mosquitto mosquitto-clients libmosquitto1\n```\n</details>\n\n<details><summary><i>Monitor Setup</i></summary>\n\n## Setup `monitor`\n\n1. Clone `monitor` git:\n```bash\n#install git\ncd ~\nsudo apt-get install git\n\n#clone this repo\ngit clone https://github.com/andrewjfreyer/monitor.git\n\n#enter `monitor` directory\ncd monitor/\n\n#(optional) switch to beta branch for latest updates and features (may be unstable)\ngit checkout beta       \n\n```\n\n2. Initial run:\n\nConfiguration files will be created with default preferences. Any executables that are not installed will be reported. All can be installed via `apt-get install ...`\n\n```bash \nsudo bash monitor.sh\n```\n\n\n3. Edit **mqtt_preferences** file:\n\n```bash\nsudo nano mqtt_preferences\n```\n\n4. Edit **known_static_addresses** (phones, laptops, some smart watches): \n\n```bash\nsudo nano known_static_addresses\n```\n\nAlternatively, send an mqtt message to `monitor/setup/ADD STATIC DEVICE` with a message including a mac address and an alias separated by a space:\n\n\n**topic:** `monitor/setup/ADD STATIC DEVICE` \n**message:** 00:11:22:33:44:55 alias\n\n\nUse, `monitor/setup/DELETE STATIC DEVICE` with a message containing a mac address to remove a device from all `monitor` nodes.\n\n5. Read helpfile:\n\n```bash\nsudo bash monitor.sh -h\n```\n\nNow the basic setup is complete. Your broker should be receiving messages and the `monitor` service will restart each time the Raspberry Pi boots. As currently configured, you should run `sudo bash monitor.sh` a few times from your command line to get a sense of how the script works. \n\n</details>\n\n___\n\n</details>\n\n<details><summary><b>Background & Technical Details</b></summary>\n\n# *Highlights*\n\n`monitor` sends a JSON-formatted MQTT message including a confidence value from 0 to 100 to a specified broker when a specified Bluetooth device responds to a `name` query. By default, `name` queries are triggered after receiving an anonymous advertisement from a previously-unseen device (e.g., a device in peripheral mode advertising an ability to connect). \n\nExample JSON package:\n```\ntopic: monitor/{{name of monitor install}}/{{mac address}}\nmessage: {\n    \"id\":\"{{mac address}}\",\n    \"confidence\":\"{{ranging from 0-100}}\",\n    \"name\":\"{{if available}}\",\n    \"manufacturer\":{{if available}}\",\n    \"type\":\"KNOWN_MAC\",\n    \"retained\":\"{{message retained?}}\",\n    \"timestamp\":\"{{formatted date at which message is sent}}\",\n    \"version\":\"{{monitor version}}\"\n }\n```\n\nIn addition, optionally, a JSON-formatted MQTT message can be reported to the same broker whenever a publicly-advertising beacon device or an iBeacon device advertises. \n\nExample JSON package:\n```\ntopic: monitor/{{name of monitor install}}/{{mac address or ibeacon uuid}}\nmessage: {\n    \"id\":\"{{mac address or ibeacon uuid}}\",\n    \"report_delay\":\"{{delay from first detection to this message in seconds}}\",\n    \"flags\":\"{{GAP flags}}\",\n    \"movement\":\"stationary\",\n    \"confidence\":\"{{ranging from 0-100}}\",\n    \"name\":\"{{if available}}\",\n    \"power\":\"{{if available}}\",\n    \"rssi\":\"{{if available}}\",\n    \"mac\":\"{{if ibeacon, the current mac address associated with the uuid}}\",\n    \"manufacturer\":{{if available}}\",\n    \"type\":\"{{GENERIC_BEACON_PUBLIC or APPLE_IBEACON}},\n    \"retained\":\"{{message retained?}}\",\n    \"timestamp\":\"{{formatted date at which message is sent}}\",\n    \"version\":\"{{monitor version}}\"\n }\n ```\n___\n\n# *Oversimplified Analogy of the Bluetooth Presence Problem*\n\nImagine you're blindfolded in a large room with other people. We want to find out who of your friends **is** present and who of your friends **isn't** present:\n\n![First Picture](https://i.imgur.com/FOubz6T.png)\n\nSome of the people in the room periodically make sounds (e.g., eating a chip, sneeze, cough, etc.), others sit quietly and don’t make a sound unless you specifically ask for them by name, and still others periodically announce their own name out loud at regular intervals whether or not you want them to do that:\n\n![Second Picture](https://i.imgur.com/UwPJIMM.png)\n\nHere's the problem. You can’t just shout “WHO’S HERE” because then everyone would say their name at the same time and you couldn’t tell anything apart. Similarly, for obvious reasons, you can't simply ask \"WHO ISN'T HERE?\" \n\nSo, you take attendance like in a classroom. Everyone in the room responds **only** when their own name is shouted. \n\n![Third Picture](https://i.imgur.com/VCW8AmH.png)\n\nSo, one way to take attendance is to shout for each friend on a list by name, one at a time, repeatedly. Ask for someone, get a response, wait for a moment, and ask again. \n\nOnce a friend stops responding (for some period of time), you presume that he or she has left: \n\n![Simple Loop](https://i.imgur.com/ijGw2qb.png)\n\nThis technique should work just fine, but there's a minor problem. You're constantly shouting into the room, which means that it's difficult for you to hear quiet responses and it's difficult for other people to carry on conversations. What else can we do? Can we use those random sounds for anything? \n\nYes! A smarter approach is to wait for an anonymous sound, *then* start asking whether a friend *you know isn't present* has just arrived:\n\n![Complex Loop](https://i.imgur.com/9Ugn27i.png)\n\nThis way, you're not constantly asking the room for all of your friends. Efficient!\n\nThis technique is a very simplified description of how `monitor` works for devices like cell phones (friends on a list) and beacons (announce a name out loud). This also gives an idea of how `monitor` uses anonymous sounds to reduce the number of times that it has to send inquiries into the Bluetooth environment. \n\n___\n\n# *Oversimplified Technical Background*\n\nThe Bluetooth Low Energy spec was designed to make connecting Bluetooth devices simpler for the user. No more pin codes, no more code verifications, no more “discovery mode” - for the most part. It was also designed to be more private than previous Bluetooth implementations. That said, it’s hard to maintain privacy when you want to be able to connect to an unknown device without intervention. \n\n## Name Requests\n\nA part of the Blueooth spec is a special function called a `name` request that asks another Bluetooth device to send back a human-readable name of itself. In order to send a `name` request, however, we need to know a private (unchanging) address of the target device. \n\nIssuing a `name` request to the same private mac address every few seconds is a reliable - albeit rudimentary - way of detecting whether that device is \"**present**\" (it responds to the `name` request) or \"**absent**\" (no response to the `name` request is received). However, issuing `name` requests too frequently (*e.g.*, every few seconds) uses quite a bit of 2.4GHz spectrum, which can cause interference with Wi-Fi or other wireless communications.\n\nNot all devices respond to `name` requests, however. For example, beacon devices do not respond. \n\n## Connectible Devices\n\nBlueooth devices that can exchange information with other devices (almost always) advertise a random/anonymous address that other devices can use to negotiate a secure connection and receive the first device's real, private, Bluetooth address. Using a random address in this way when publicly advertising prevents bad actors from tracking via passive Bluetooth monitoring. \n\n## Beacon/Advertising Devices\n\nThe Bluetooth spec has been used by Apple, Google, and others to create additional standards (e.g., iBeacon, Eddystone, and so on). These devices generally don't care to connect to other devices, so use of random/anonymous addresses doesn't really matter. Instead, these devices encode additional information into each advertisement of an anonymous address. For example, iBeacon devices will broadcast a UUID that conforms to the 8-4-4-4-12 format defined by [IETC RFC4122](http://www.ietf.org/rfc/rfc4122.txt).\n\nAs noted above, most beacons do not respond to `name` requests, even if made to the device's private Bluetooth address. So, issuing periodic `name` requests to beacons is not a good way to detect whether a beacon device is **present** or **absent**. However, monitoring for beacon advertisement is a reliable way to detect whether a beacon device is **present** or **absent**.\n\n_____\n\n# *How `monitor` Works*\n\nThis script combines `name` requests, anonymous advertisements, and beacon advertisements to logically determine (1) *when* to issue a `name` request to determine whether a device is **present** and (2) *when* to issue a `name` request to determine whether a device is **absent**. The script also listens for beacons. \n\n##### Known Static Addresses\n`monitor` uses unchanging/static mac addresses for your devices that you have added to a file called `known_static_addresses`. These are the addresses for which `monitor` will issue `name` requests to determine whether or not these devices are **present** or **absent**. \n\nOnce a determination of presence is made, the script posts to an mqtt topic path defined in a file called `mqtt_preferences` that includes a JSON-formatted message with a confidence value that corresponds to a confidence of presence. For example, a confidence of 100 means that `monitor` is 100% sure the device is present. Similarly, a confidence of 0 means that `monitor` is 0% sure the device is present (*i.e.*, the `monitor` is 100% sure the device is absent).\n\nTo minimize the number of times that `monitor` issues `name` requests (thereby reducing 2.4GHz interference), the script performs either an ***ARRIVAL*** scan or a ***DEPART*** scan, instead of scanning all devices listed in the `known_static_addresses` each time.  \n\nMore specifically:\n\n*  An ***ARRIVAL*** scan issues a `name` request, sequentially, for each device listed in the `known_static_addresses` file that is known to be **absent**. \n\n*  Similarly, a ***DEPART*** scan issues a `name` request, sequentially, for each device listed in the `known_static_addresses` file that is known to be **present**. \n\nFor example, if there are two phone addresses listed in the `known_static_addresses` file, and both of those devices are **present**, an ***ARRIVAL*** scan will never occur. Similarly, if both of these addresses are **absent** then a ***DEPART*** scan will never occur. If only one device is present, an **ARRIVAL** scan will only scan for the device that is currently away. \n\nTo reduce the number of `name` requests that occur, `monitor` listens for anonymous advertisements and triggers an ***ARRIVAL*** scan for every *new* anonymous address. \n\nThe script will also trigger an ***ARRIVE*** scan in response to an mqtt message posted to the topic of `monitor/scan/arrive`. Advertisement-triggered scanning can be disabled by using the trigger argument if `-ta`, which causes `monitor` to *only* trigger ***ARRIVAL*** scans in response to mqtt messages. \n\nIf `monitor` has not heard from a particular anonymous address in a long time, `monitor` triggers a ***DEPART*** scan. The script will also trigger a ***DEPART*** scan in response to an mqtt message posted to the topic of `monitor/scan/depart`. Expiration-triggered scanning can be disabled by using the trigger argument if `-td`, which causes `monitor` to *only* trigger ***DEPART*** scans in response to mqtt messages. \n\nTo reduce scanning even further, `monitor` can filter which types of anonymous advertisements are used for ***ARRIVE*** scans. These are called \"filters\" and are defined in a file called `behavior_preferences`. The filters are bash RegEx strings that either pass or reject anonymous advertisements that match the filter. \n\nThere are two filter types: \n\n* **Manufacturer Filter** - filters based on data in an advertisement that is connected to a particular device manufacturer. This is almost always the OEM of the device that is transmitting the anonymous advertisement. By default, because of the prevalence of iPhones, Apple is the only manufacturer that triggers an ***ARRIVAL*** scan. Multiple manufacturers can be appended together by a pipe: `|`. An example filter for Apple and Samsung looks like: `Apple|Samsung`. To disable the manufacturer filter, use `.*`.\n\n* **Flag Filter:** filters based on flags contained in an advertisement. This varies by device type. By default, because of the prevalence of iPhones, the flag of `0x1b` triggers an ***ARRIVAL*** scan. Like with the manufacturer filter, multiple flags can be appended together by a pipe: `|`. To disable the manufacturer filter, use `.*`.\n\n##### Beacons & iBeacons\nIn addition, when run with the `-b` beacon argument, `monitor` listens for beacon advertisements that report themselves as \"public\", meaning that their addresses will not change. The script can track these by default; these addresses do not have to be added anywhere - after all, `monitor` will obtain them just by listening. \n\nSince iBeacons include a UUID and a mac address, two presence messages are reported via mqtt. \n\n## Known Beacon Addresses\nIn some cases, manufacturers try to get sneaky and cause their beacons to advertise as \"anonymous\" (or \"random\") devices, despite that their addresses do not change at all. By default, `monitor` does not report presence of anonymous advertisement devices, so to force `monitor` to recognize these devices, we add the \"random\" address to a file called `known_static_beacons`. After restarting, `monitor` will know that these addresses should be treated like a normal beacon. \n___\n\n</details>\n\n<details><summary><b>Home Assistant Example</b></summary>\n\n# Example with Home Assistant\n\nPersonally, I have four **raspberry pi zero w**s throughout the house and garage. My family spends most of our time on the first floor, so our main `monitor` node or sensor is on the first floor. Our other 'nodes' on the second and third floor and garage are set up for triggered use only - these will scan for ***ARRIVAL*** and ***DEPART*** only in response to mqtt messages, with option ```-tad```. The first floor node is set up to send mqtt arrive/depart scan instructions to these nodes by including the `-tr` flag (\"report\" to other nodes when an arrival or depart scan is triggered). \n\nThe first floor constantly monitors for beacons (`-b`) advertisements and anonymous advertisements, which may be sent by our phones listed in the `known_static_addresses` file. In response to a new anonymous advertisement, `monitor` will initiate an ***ARRIVAL*** scan for whichever of our phones is not present.  If one of those devices is seen, an mqtt message is sent to Home Assistant reporting that the scanned phone is \"home\" with a confidence of 100%. In addition, an mqtt message is sent to the second and third floor and garage to trigger a scan on those floors as well. As a result of this configuration, when we leave the house, we use either the front door or the garage door to trigger an mqtt trigger of ```monitor/scan/depart``` after a ten second delay to trigger a departure scan of our devices that were previously known to be present. The ten second delay gives us a chance to get out of Bluetooth range before a \"departure\" scan is triggered. Different houses/apartments will probably need different delays. \n\nMore specifically, each of these `monitor` nodes uses the same name for each device so that states can be tracked easily by Home Assistant. For example, on each node, my `known_static_addresses` file looks like this (note that 00:00:00:00:00:00 is an example address - this should be your phone's private, static, Bluetooth address): \n\n```bash\n00:00:00:00:00:00 alias #comment that is ignored\n```\n\nThe address I want to track is separated by a space from the *alias* that I want to use to refer to this device in Home Assistant. If you prefer to use the address instead of an alias, set the value `PREF_ALIAS_MODE=false` in your `behavior_preferences` file.\n\nIn this manner, [Home Assistant](https://www.home-assistant.io) receives mqtt messages and stores the values as input to a number of [mqtt sensors](https://www.home-assistant.io/components/sensor.mqtt/). Output from these sensors is combined to give an accurate numerical occupancy confidence:\n\n```\n- platform: mqtt\n  state_topic: 'monitor/first floor/alias'\n  value_template: '{{ value_json.confidence }}'\n  unit_of_measurement: '%'\n  name: 'First Floor'\n\n- platform: mqtt\n  state_topic: 'monitor/second floor/alias'\n  value_template: '{{ value_json.confidence }}'\n  unit_of_measurement: '%'\n  name: 'Second Floor'\n\n- platform: mqtt\n  state_topic: 'monitor/third floor/alias'\n  value_template: '{{ value_json.confidence }}'\n  unit_of_measurement: '%'\n  name: 'Third Floor'\n\n- platform: mqtt\n  state_topic: 'monitor/garage/alias'\n  value_template: '{{ value_json.confidence }}'\n  unit_of_measurement: '%'\n  name: 'Garage'\n```\n\nThese sensors can be combined using a [min_max](https://www.home-assistant.io/components/sensor.min_max/):\n\n```\n- platform: min_max\n  name: \"Home Occupancy Confidence\"\n  type: max\n  round_digits: 0\n  entity_ids:\n    - sensor.third_floor\n    - sensor.second_floor\n    - sensor.first_floor\n    - sensor.garage\n```\n\nThereafter, I use the entity **sensor.home_occupancy_confidence** in automations to control the state of an **input_boolean** that represents a very high confidence of a user being home or not. \n\nAs an example:\n\n```\n- alias: Occupancy On\n  trigger:\n    - platform: numeric_state\n      entity_id: sensor.home_occupancy_confidence\n      above: 10\n  action:\n    - service: input_boolean.turn_on\n      data:\n        entity_id: input_boolean.occupancy\n\n- alias: Occupancy Off\n  trigger:\n    - platform: numeric_state\n      entity_id: sensor.home_occupancy_confidence\n      below: 10\n  action:\n    - service: input_boolean.turn_off\n      data:\n        entity_id: input_boolean.occupancy\n```\n\nIf you prefer to use the `device_tracker` platform in Home Assistant, a unique solution is to use the undocumented `device_tracker.see` service:\n\nAs an example:\n\n```\n- alias: Andrew Occupancy On\n  trigger:\n    - platform: numeric_state\n      entity_id: sensor.andrew_occupancy_confidence\n      above: 10\n  action:\n    - service: device_tracker.see\n      data:\n        dev_id: andrew\n        location_name: home\n        source_type: bluetooth\n\n- alias: Andrew Occupancy Off\n  trigger:\n    - platform: numeric_state\n      entity_id: sensor.andrew_occupancy_confidence\n      below: 10\n  action:\n    - service: device_tracker.see\n      data:\n        dev_id: andrew\n        location_name: not_home\n        source_type: bluetooth\n\n```\n\nFor more information, see [here](https://community.home-assistant.io/t/device-tracker-from-script/97295/7) and [here](https://github.com/andrewjfreyer/monitor/issues/138).\n\nIf you only have one node, an [add-on](https://github.com/Limych/hassio-addons) by @limych may be an excellent choice for you!\n\nIf having several nodes and lots of users, there is an AppDaemon App that can easily manage the integration of of this system into Home Assistant automatically for you by @Odianosen25. More information can be found [here](https://github.com/Odianosen25/Monitor-App)\n\n</details>\n\n<details><summary><b>Advanced Configuration Options & Fine Tuning</b></summary>\n\n\n## Fine Tuning\n\n\n1. Observe output from `monitor` to tune filters:\n\n```bash\nsudo bash monitor.sh \n```\n\nObserve the output of the script for debug log [CMD-RAND] lines including [failed filter] or [passed filter]. These lines show what anonymous advertisement `monitor` sees and how `monitor` filters those advertisements. In particular, cycle the Bluetooth power on your phone or another device and look at the `flags` value, the `pdu` value, and the `man` (manufacturer) value that appears after you turn Bluetooth power back on. Remember, the address you see in the log will be an anonymous address - ignore it, we're only focused on the values referenced above. \n\n```\n0.1.xxx 03:25:39 pm [CMD-RAND]  [passed filter] data: 00:11:22:33:44:55 pdu: ADV_NONCONN_IND rssi: -73 dBm flags: 0x1b man: Apple, Inc. delay: 4\n```\n\nIf you repeatedly see the same values in one or more of these fields, consider adding a PASS filter condition to the `behavior_preferences` file. This will cause `monitor` to *only* scan in response to an anonymous advertisement that passes the filter condition that you define. For example, if you notice that Apple always shows up as the manufacturer when you cycle the power on you phone, you can create an Apple filter:\n\n```bash\nPREF_PASS_FILTER_MANUFACTURER_ARRIVE=\"Apple\"\n```\n\nIf you have two phones, and one is **Apple** and the other is **Google**, create a `bash` or statement in the filter like this: \n\n```bash\nPREF_PASS_FILTER_MANUFACTURER_ARRIVE=\"Apple|Google\"\n```\n\nIf your phone shows as **Unknown**, then it is best to disable the filter entirely - some phones will report a blank manufacturer, others will report a null value... it's much easier to try and filter with another value:\n\n```bash\nPREF_PASS_FILTER_MANUFACTURER_ARRIVE=\".*\"\n```\n\nSimilarly, we can create a negative filter. If you or your neighbors use Google Home, it is likely that you'll see at least some devices manufactured by **Google**. Create a fail filter condition to ignore these advertisements: \n\n```bash\nPREF_FAIL_FILTER_MANUFACTURER_ARRIVE=\"Google\"\n```\n\nFilters are a great way to minimize the frequency of `name` requestning, which causes 2.4GHz interference and can, if your values are too aggressive, dramatically interfere with Wi-Fi and other services. \n\n2. **Standard configuration options:**\n\nWhen `monitor` is first run, default preferences are created in the `behavior_preferences` file. These preferences can be changed, and in many cases should be changed depending on your Bluetooth environment (how many devices you have around you at any given time). A table below describes what these default variables are:  \n\n| **Option** | **Default Value** | **Description** |\n|-|-|-|\n| PREF_ARRIVAL_SCAN_ATTEMPTS | 1 | This is the number of times that `monitor` will send a name request before deciding that a device has not yet arrived. The higher the number, the fewer errors on arrival detection but also the longer it may take to recognize all devices are home in a multi-device installation. |\n| PREF_DEPART_SCAN_ATTEMPTS | 2 | This is the number of times that `monitor` will send a name request before deciding that a device has not yet departed. The higher the number, the fewer errors on departure detection but also the longer it may take to recognize all devices are away in a multi-device installation. |\n| PREF_BEACON_EXPIRATION | 180 | This is the number of seconds without observing an advertisement before a beacon is considered expired. |\n| PREF_MINIMUM_TIME_BETWEEN_SCANS | 15 | This is the minimum number of seconds required between \"arrival\" scans or between \"departure\" scans. Increasing the value will decrease interference, but will also increase arrival and departure detection time. |\n| PREF_PASS_FILTER_ADV_FLAGS_ARRIVE | .* | See above. |\n| PREF_PASS_FILTER_MANUFACTURER_ARRIVE | .* | See above. |\n| PREF_FAIL_FILTER_ADV_FLAGS_ARRIVE | NONE | See above. |\n| PREF_FAIL_FILTER_MANUFACTURER_ARRIVE | NONE | See above. |\n| PREF_ALIAS_MODE | true | Disable or enable alias mode; if disabled, MQTT messages are sent using a device's mac address. |\n\n3. **Advanced configuration options:**\n\nIn addition to the options described above, there are a number of advanced options that can be set by the user. To modify any of these options, add a line to the `behavior_preferences` file. \n\n\n| **Option** | **Default Value** | **Description** |\n|-|-|-|\nPREF_INTERSCAN_DELAY|3|This is a fixed delay between `name` requests. Increasing the value will decrease interference, but will decrease responsiveness. Decreasing the value will risk a Bluetooth hardware fault.|\nPREF_RANDOM_DEVICE_EXPIRATION_INTERVAL|75|This is the interval after which an anonymous advertisement mac address is considered expired. Increasing this value will reduce arrival scan frequency, but will also increase memory footprint (minimal) and will decrease the frequency of depart scans.|\nPREF_RSSI_CHANGE_THRESHOLD|-20|If a beacon's rssi changes by at least this value, then the beacon will be reported again via mqtt.|\nPREF_RSSI_IGNORE_BELOW|-75|If an anonymous advertisement is \"farther\" away (lower RSSI), ignore the advertisement\nPREF_HCI_DEVICE|hci0|Select which hci device should be used by `monitor`|\nPREF_COOPERATIVE_SCAN_THRESHOLD|60|Once confidence of a known device falls below this value, send an mqtt message to other `monitor` nodes to begin an arrival scan or a departure scan.|\nPREF_MQTT_REPORT_SCAN_MESSAGES|false|This value is either true or false and determines whether `monitor` publishes when a scan begins and when a scan ends|\nPREF_PERCENT_CONFIDENCE_REPORT_THRESHOLD|59|This value defines when a beacon begins reporting a decline in confidence|\nPREF_PASS_FILTER_PDU_TYPE|*Various. See FAQ.*|These are the PDU types that should be noticed by `monitor`|\nPREF_DEVICE_TRACKER_REPORT|false|If true, this value will cause `monitor` to report a 'home' or 'not_home' message to `... /device_tracker` conforming to device_tracker mqtt protocol. \nPREF_DEVICE_TRACKER_HOME_STRING|home|If `PREF_DEVICE_TRACKER_REPORT` is true, this is the string that is reported to the device_tracker when the device is home.\nPREF_DEVICE_TRACKER_AWAY_STRING|not_home|If `PREF_DEVICE_TRACKER_REPORT` is true, this is the string that is reported to the device_tracker when the device is not home.\nPREF_DEVICE_TRACKER_TOPIC_BRANCH|device_tracker|If `PREF_DEVICE_TRACKER_REPORT` is true, this is last path element of the mqtt topic path that will be used to publish the device tracker message.\nPREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP|15|This is the minimum interval (in seconds) used to estimate advertisement intervals reported in the MQTT message.\nPREF_DEPART_SCAN_INTERVAL|30|If using periodic scanning mode, this is the minimum interval (in seconds) at which depart scans are triggered automatically. \nPREF_ARRIVE_SCAN_INTERVAL|15|If using periodic scanning mode, this is the minimum interval (in seconds) at which arrive scans are triggered automatically. \n\n\n## RSSI Tracking\n\nThis script can also track RSSI changes throughout the day. This can be used for very rudimentary room- or floor-level tracking. Only devices in `known_static_addresses` that have been paired to a `monitor` node can have their RSSI tracked. Here's how to pair: \n\n1. Stop `monitor` service:\n\n```bash\nsudo systemctl stop monitor\n```\n\n2. Run `monitor` with `-c` flag, followed by the mac address of the known_device to connect:\n\n```bash\nsudo bash monitor.sh -c 00:11:22:33:44:55\n```\n\nAfter this, follow the prompts given by `monitor` and your device will be connected. That's it. After you restart monitor will periodically (once every ~1.5 minutes) connect to your phone and take three RSSI samples, average the samples, and report a string message to the same path as a confidence report, with the additional path component of */rssi*. So, if a `monitor` node is named 'first floor', an rssi message is reported to:\n\n```bash \ntopic: monitor/first floor/00:11:22:33:44:55/rssi\nmessage: -99 through 0\n```\n\nIf an rssi measurement cannot be obtained, the value of -99 is sent. \n\n## Report known states\n\nIt is also possible tell monitor to report all currently known device states by sending an MQTT message to something like `monitor/first floor/KNOWN DEVICE STATES`. monitor.sh will then iterate over all known static addresses and report the current confidence level. This may be useful in home assistant to get the current state after a home assistant restart.\n\n</details>\n\nAnything else? Post a [question.](https://github.com/andrewjfreyer/monitor/issues/new)\n"
        },
        {
          "name": "monitor.sh",
          "type": "blob",
          "size": 69.6611328125,
          "content": "#!/bin/bash\n\n# ----------------------------------------------------------------------------------------\n# GENERAL INFORMATION\n# ----------------------------------------------------------------------------------------\n#\n# Written by Andrew J Freyer\n# GNU General Public License\n# http://github.com/andrewjfreyer/monitor\n#\n# Credits to:\n#\t\tRadius Networks iBeacon Script\n#\t\t\t• http://developer.radiusnetworks.com/ibeacon/idk/ibeacon_scan\n#\n#\t\tReely Active advlib\n#\t\t\t• https://github.com/reelyactive/advlib\n#\n#                        _ _             \n#                       (_) |            \n#  _ __ ___   ___  _ __  _| |_ ___  _ __ \n# | '_ ` _ \\ / _ \\| '_ \\| | __/ _ \\| '__|\n# | | | | | | (_) | | | | | || (_) | |   \n# |_| |_| |_|\\___/|_| |_|_|\\__\\___/|_|\n#\n# ----------------------------------------------------------------------------------------\n\n#VERSION NUMBER\nexport version=0.2.200\n\nif [ -z ${NO_COLOR} -o -z ${NOCOLOR} ] ; then\n\t#COLOR OUTPUT FOR RICH OUTPUT\n\tORANGE=$'\\e[1;33m'\n\tRED=$'\\e[1;31m'\n\tNC=$'\\e[0m'\n\tGREEN=$'\\e[1;32m'\n\tPURPLE=$'\\e[1;35m'\n\tBLUE=$'\\e[1;34m'\n\tCYAN=$'\\e[1;36m'\n\tYELLOW=$'\\e[01;33m'\n\tREPEAT=$'\\e[1A'\nelse\n\t:\nfi\n\n# ----------------------------------------------------------------------------------------\n# BETA WARNING ONLY IF ON THE BETA CHANNEL\n# ----------------------------------------------------------------------------------------\n\nif command -v git >/dev/null && [[ $(git status) =~ .*beta.* ]]; then \n\n\tprintf \"\\n%s\\n\" \t\"${RED}===================================================${NC}\"\n\tprintf \"\\n%s\\n\"\t\t\"${RED}              ${PURPLE}*** BETA/DEV BRANCH ***${NC}\"\n\tprintf \"\\n%s\\n\" \t\"${RED}===================================================${NC}\"\n\nfi \n\n#CAPTURE ARGS IN VAR TO USE IN SOURCED FILE\nexport RUNTIME_ARGS=(\"$@\")\n\n# ----------------------------------------------------------------------------------------\n# SOURCES\n# ----------------------------------------------------------------------------------------\n#SOURCE SETUP AND ARGV FILES\nsource './support/argv'\nsource './support/init'\n\n#SOURCE FUNCTIONS\nsource './support/mqtt'\nsource './support/log'\nsource './support/data'\nsource './support/btle'\nsource './support/time'\n# ----------------------------------------------------------------------------------------\n# CLEANUP ROUTINE \n# ----------------------------------------------------------------------------------------\nclean() {\n\t#CLEANUP FOR TRAP\n\tpkill -f monitor.sh\n\n\t#REMOVE PIPES\n\trm main_pipe &>/dev/null\n\trm log_pipe &>/dev/null\n\trm packet_pipe &>/dev/null\n\n\t#MESSAGE\n\techo 'Exited.'\n}\n\ntrap \"clean\" EXIT\n\n# ----------------------------------------------------------------------------------------\n# DEFINE VALUES AND VARIABLES\n# ----------------------------------------------------------------------------------------\n\n#CYCLE BLUETOOTH INTERFACE \nhciconfig \"$PREF_HCI_DEVICE\" down && sleep 3 && hciconfig \"$PREF_HCI_DEVICE\" up\n\n#STOP OTHER INSTANCES OF MONITOR WITHOUT STOPPING THIS ONE\nfor pid in $(pidof -x \"$(basename \"$0\")\"); do\n    if [ \"$pid\" != $$ ]; then\n        kill -9 \"$pid\"\n    fi \ndone\n\n#SETUP MAIN PIPE\nrm main_pipe &>/dev/null\nmkfifo main_pipe\n\n#SETUP LOG PIPE\nrm log_pipe &>/dev/null\nmkfifo log_pipe\n\n#SETUP BTLE PIPE\nrm packet_pipe &>/dev/null\nmkfifo packet_pipe\n\n\n#DEFINE DEVICE TRACKING VARS\ndeclare -A public_device_log\ndeclare -A random_device_log\ndeclare -A rssi_log\n\n#STATIC DEVICE ASSOCIATIVE ARRAYS\ndeclare -A known_public_device_log\ndeclare -A expiring_device_log\ndeclare -A known_static_device_scan_log\ndeclare -A known_public_device_name\ndeclare -A blacklisted_devices\ndeclare -A beacon_mac_address_log\ndeclare -A mqtt_aliases\ndeclare -A advertisement_interval_observation\n\n#LAST TIME THIS \nscan_pid=\"\"\nscan_type=\"\"\n\n#SCAN VARIABLES\nnow=$(date +%s)\nlast_rssi_scan=\"\"\nlast_arrival_scan=$((now - 25))\nlast_depart_scan=$((now - 25))\nfirst_arrive_scan=true\n\n# ----------------------------------------------------------------------------------------\n# POPULATE THE ASSOCIATIVE ARRAYS THAT INCLUDE INFORMATION ABOUT THE STATIC DEVICES\n# WE WANT TO TRACK\n# ----------------------------------------------------------------------------------------\n\n#LOAD PUBLIC ADDRESSES TO SCAN INTO ARRAY, IGNORING COMMENTS\nmapfile -t known_static_beacons < <(sed 's/#.\\{0,\\}//gi' < \"$BEAC_CONFIG\" | awk '{print $1}' | grep -oiE \"([0-9a-f]{2}:){5}[0-9a-f]{2}\" )\nmapfile -t known_static_addresses < <(sed 's/#.\\{0,\\}//gi' < \"$PUB_CONFIG\" | awk '{print $1}' | grep -oiE \"([0-9a-f]{2}:){5}[0-9a-f]{2}\" )\nmapfile -t address_blacklist < <(sed 's/#.\\{0,\\}//gi' < \"$ADDRESS_BLACKLIST\" | awk '{print $1}' | grep -oiE \"([0-9a-f]{2}:){5}[0-9a-f]{2}\" )\n\n#ASSEMBLE COMMENT-CLEANED BLACKLIST INTO BLACKLIST ARRAY\nfor addr in \"${address_blacklist[@]^^}\"; do \n\tblacklisted_devices[$addr]=1\n\tprintf \"%s\\n\" \"> ${RED}blacklisted device:${NC} $addr\"\ndone \n\n# ----------------------------------------------------------------------------------------\n# POPULATE MAIN DEVICE ARRAY\n# ----------------------------------------------------------------------------------------\n\n#LIST CONNECTED DEVICES\npreviously_connected_devices=$(echo \"paired-devices\" | bluetoothctl | grep -Eio \"Device ([0-9A-F]{2}:){5}[0-9A-F]{2}\" | sed 's/Device //gi')\n\n#POPULATE KNOWN DEVICE ADDRESS\nfor addr in \"${known_static_addresses[@]^^}\"; do \n\n\t#================= SHOULD WE USE AN ALIAS? =====================\n\n\t#WAS THERE A NAME HERE?\n\tknown_name=$(grep -i \"$addr\" \"$PUB_CONFIG\" | tr \"\\\\t\" \" \" | sed 's/  */ /gi;s/#.\\{0,\\}//gi' | sed \"s/$addr //gi;s/  */ /gi\" )\n\n   \t#IF THE VALUE DOES NOT EXIST, USE THE KEY (MAC ADDRESS INSTEAD)\n   \talias_value=${known_name//[^A-Za-z0-9]/_}\n\n   \t#LOWERCASE\n  \talias_value=${alias_value,,}\n\n  \t#REMOVE FINAL UNDERSCORES SHOUDL THERE BE\n   \talias_value=$(echo \"$alias_value\" | sed 's/[^0-9a-z]\\{1,\\}$//gi;s/^[^0-9a-z]\\{1,\\}//gi;s/__*/_/gi')\n\n  \t#DEFAULT\n   \talias_value=${alias_value:-$addr}\n\n   \t#ALIASES\n   \t[ -n \"$addr\" ] && [ -n \"$alias_value\" ] && mqtt_aliases[$addr]=\"$alias_value\" \n\n\t#================= PROCESS THE KNOWN ADDR =====================\n\n\t#IF WE FOUND A NAME, RECORD IT\n\t[ -n \"$known_name\" ] && known_public_device_name[$addr]=\"$known_name\"\n\n\t#CONNECTED?\n\tis_connected=\"not previously connected\"\n\t[[ $previously_connected_devices =~ .*$addr.* ]] && is_connected=\"previously connected\"\n\n\t#CORRECT \n\t$PREF_ALIAS_MODE && mqtt_topic_branch=${mqtt_aliases[$addr]:-$addr} || mqtt_topic_branch=$addr\n\n\t#PUBLICATION TOPIC \n\tpub_topic=\"$mqtt_topicpath/$mqtt_publisher_identity/$mqtt_topic_branch\"\n\t$PREF_MQTT_SINGLE_TOPIC_MODE && pub_topic=\"$mqtt_topicpath/$mqtt_publisher_identity { id: $addr ... }\"\n\n\t#FOR DEBUGGING\n\tprintf \"%s\\n\" \"> ${GREEN}$addr${NC} confidence topic: $pub_topic (has $is_connected to $PREF_HCI_DEVICE)\"\n\t[ \"$PREF_DEVICE_TRACKER_REPORT\" == 'true' ] && printf \"%s\\n\" \"> ${GREEN}$addr${NC} device_tracker topic: $pub_topic/$PREF_DEVICE_TRACKER_TOPIC_BRANCH [$PREF_DEVICE_TRACKER_AWAY_STRING or $PREF_DEVICE_TRACKER_HOME_STRING]\"\ndone\n\n# ----------------------------------------------------------------------------------------\n# POPULATE BEACON ADDRESS ARRAY\n# ----------------------------------------------------------------------------------------\n#POPULATE KNOWN DEVICE ADDRESS\nfor addr in \"${known_static_beacons[@]^^}\"; do \n\n\t#WAS THERE A NAME HERE?\n\tknown_name=$(grep \"$addr\" \"$BEAC_CONFIG\" | tr \"\\\\t\" \" \" | sed 's/  */ /gi;s/#.\\{0,\\}//gi' | sed \"s/$addr //gi;s/  */ /gi\" )\n\n\t#================= SHOULD WE USE AN ALIAS? =====================\n\n   \t#IF THE VALUE DOES NOT EXIST, USE THE KEY (MAC ADDRESS INSTEAD)\n   \talias_value=${known_name//[^A-Za-z0-9]/_}\n\n   \t#LOWERCASE\n  \talias_value=${alias_value,,}\n\n  \t#REMOVE FINAL UNDERSCORES SHOUDL THERE BE\n   \talias_value=$(echo \"$alias_value\" | sed 's/[^0-9a-z]\\{1,\\}$//gi;s/^[^0-9a-z]\\{1,\\}//gi;s/__*/_/gi')\n\n  \t#DEFAULT\n   \talias_value=${alias_value:-$addr}\n\n   \t#ALIASES\n   \t[ -n \"$addr\" ] && [ -n \"$alias_value\" ] && mqtt_aliases[$addr]=\"$alias_value\" \n\n\t#IF WE FOUND A NAME, RECORD IT\n\t[ -n \"$known_name\" ] && known_public_device_name[$addr]=\"$known_name\"\n\n\t#CORRECT \n\t$PREF_ALIAS_MODE && mqtt_topic_branch=${mqtt_aliases[$addr]:-$addr} || mqtt_topic_branch=$addr\n\n\t#PUBLICATION TOPIC \n\tpub_topic=\"$mqtt_topicpath/$mqtt_publisher_identity/$mqtt_topic_branch\"\n\t$PREF_MQTT_SINGLE_TOPIC_MODE && pub_topic=\"$mqtt_topicpath/$mqtt_publisher_identity { id: $addr ... }\"\n\n\t#FOR DBUGGING\n\techo \"> known beacon: $addr publishes to: $pub_topic\"\ndone\n\n# ----------------------------------------------------------------------------------------\n# ASSEMBLE RSSI LISTS\n# ----------------------------------------------------------------------------------------\n\nconnectable_present_devices () {\n\n\t#DEFINE LOCAL VARS\n\tlocal this_state\n\tlocal known_device_rssi\n\tlocal avg_total\n\tlocal scan_result\n\n\t#ITERATE THROUGH THE KNOWN DEVICES \n\tlocal known_addr\n\tfor known_addr in \"${known_static_addresses[@]^^}\"; do \n\t\t\n\t\t#GET STATE; ONLY SCAN FOR DEVICES WITH SPECIFIC STATE\n\t\tthis_state=\"${known_public_device_log[$known_addr]}\"\n\t\tthis_state=${this_state:-0}\n\n\t\t#TEST IF THIS DEVICE MATCHES THE TARGET SCAN STATE\n\t\tif [ \"$this_state\" == \"1\" ] && [[ \"$previously_connected_devices\" =~ .*$known_addr.* ]] ; then \n\t\t\t\t\n\t\t\t#CREATE CONNECTION AND DETERMINE RSSI \n\t\t\t#AVERAGE OVER THREE CYCLES; IF BLANK GIVE VALUE OF 100\n\t\t\tknown_device_rssi=$(counter=0; \\\n\t\t\t\tavg_total=0; \\\n\t\t\t\thcitool cc \"$known_addr\"; \\\n\t\t\t\tavg_total=\"\"; \\\n\t\t\t\tfor i in 1 2 3; \\\n\t\t\t\tdo scan_result=$(hcitool rssi \"$known_addr\" 2>&1); \\\n\t\t\t\tscan_result=${scan_result//[^0-9]/}; \\\n\t\t\t\tscan_result=${scan_result:-99}; \\\n\t\t\t\t[[ \"$scan_result\" == \"0\" ]] && scan_result=99; \\\n\t\t\t\tcounter=$((counter+1)); \\\n\t\t\t\tavg_total=$((avg_total + scan_result )); \\\n\t\t\t\tsleep 0.5; \\\n\t\t\t\tdone; \\\n\t\t\t\tprintf \"%s\" \"$(( avg_total / counter ))\")\n\n\t\t\t#PUBLISH MESSAGE TO RSSI SENSOR \n\t\t\tpublish_rssi_message \\\n\t\t\t\"$known_addr\" \\\n\t\t\t\"-$known_device_rssi\"\n\n\t\t\t#REPORT \n\t\t\t$PREF_VERBOSE_LOGGING && log \"${CYAN}[CMD-RSSI]\t${NC}$known_addr ${GREEN}$cmd ${NC}RSSI: -$known_device_rssi dBm ${NC}\"\n\n\t\t\t#SET RSSI LOG\n\t\t\trssi_log[$known_addr]=\"$known_device_rssi\"\n\t\tfi \n\tdone\n}\n\n# ----------------------------------------------------------------------------------------\n# ASSEMBLE SCAN LISTS\n# ----------------------------------------------------------------------------------------\n\nscannable_devices_with_state () {\n\n\t#DEFINE LOCAL VARS\n\tlocal return_list\n\tlocal timestamp\n\tlocal scan_state\n\tlocal scan_type_diff\n\tlocal this_state\n\tlocal last_scan\n\tlocal time_diff\n\n\t#SET VALUES AFTER DECLARATION\n\ttimestamp=$(date +%s)\n\tscan_state=\"$1\"\n\n\t#FIRST, TEST IF WE HAVE DONE THIS TYPE OF SCAN TOO RECENTLY\n\tif [ \"$scan_state\" == \"1\" ]; then \n\t\t#SCAN FOR DEPARTED DEVICES\n\t\tscan_type_diff=$((timestamp - last_depart_scan))\n\telif [ \"$scan_state\" == \"0\" ]; then \n\t\t#SCAN FOR ARRIVED DEVICES\n\t\tscan_type_diff=$((timestamp - last_arrival_scan))\n\tfi \n\n\t#REJECT IF WE SCANNED TO RECENTLY\n\t[ \"$scan_type_diff\" -lt \"$PREF_MINIMUM_TIME_BETWEEN_SCANS\" ] && return 0\n\n\t#SCAN ALL? SET THE DEFAULT SCAN STATE TO [X]\n\tscan_state=${scan_state:-2}\n\t\t \t\n\t#ITERATE THROUGH THE KNOWN DEVICES \n\tlocal known_addr\n\tfor known_addr in \"${known_static_addresses[@]^^}\"; do \n\t\t\n\t\t#GET STATE; ONLY SCAN FOR DEVICES WITH SPECIFIC STATE\n\t\tthis_state=\"${known_public_device_log[$known_addr]}\"\n\n\t\t#IF WE HAVE NEVER SCANNED THIS DEVICE BEFORE, WE MARK AS \n\t\t#SCAN STATE [X]; THIS ALLOWS A FIRST SCAN TO PROGRESS TO \n\t\t#COMPLETION FOR ALL DEVICES\n\t\tthis_state=${this_state:-3}\n\n\t\t#FIND LAST TIME THIS DEVICE WAS SCANNED\n\t\tlast_scan=\"${known_static_device_scan_log[$known_addr]}\"\n\t\ttime_diff=$((timestamp - last_scan))\n\n\t\t#SCAN IF DEVICE HAS NOT BEEN SCANNED \n\t\t#WITHIN LAST [X] SECONDS\n\t\tif [ \"$time_diff\" -gt \"$PREF_MINIMUM_TIME_BETWEEN_SCANS\" ]; then \n\n\t\t\t#TEST IF THIS DEVICE MATCHES THE TARGET SCAN STATE\n\t\t\tif [ \"$this_state\" == \"$scan_state\" ]; then \n\t\t\t\t#ASSEMBLE LIST OF DEVICES TO SCAN\n\t\t\t\treturn_list=\"$return_list $this_state$known_addr\"\n\n\t\t\telif [ \"$this_state\" == \"2\" ] || [ \"$this_state\" == \"3\" ]; then\n\n\t\t\t\t#SCAN FOR ALL DEVICES THAT HAVEN'T BEEN RECENTLY SCANNED; \n\t\t\t\t#PRESUME DEVICE IS ABSENT\n\t\t\t\treturn_list=\"$return_list $this_state$known_addr\"\n\t\t\tfi \n\t\tfi \n\tdone\n \n\t#RETURN LIST, CLEANING FOR EXCESS SPACES OR STARTING WITH SPACES\n\treturn_list=$(echo \"$return_list\" | sed 's/^ //gi;s/ $//gi;s/  */ /gi')\n\n\t#RETURN THE LIST\n\techo \"$return_list\"\n}\n\n# ----------------------------------------------------------------------------------------\n# SCAN FOR DEVICES\n# ----------------------------------------------------------------------------------------\n\nperform_complete_scan () {\n\t#IF WE DO NOT RECEIVE A SCAN LIST, THEN RETURN 0\n\tif [ -z \"$1\" ]; then\n\t\t#log \"${GREEN}[CMD-INFO]\t${GREEN}**** Rejected group scan. No devices in desired state. **** ${NC}\"\n\t\treturn 0\n\tfi\n\n\t#REPEAT THROUGH ALL DEVICES THREE TIMES, THEN RETURN \n\tlocal repetitions=2\n\t[ -n \"$2\" ] && repetitions=\"$2\"\n\t[ \"$repetitions\" -lt \"1\" ] && repetitions=1\n\n\t#PRE\n\tlocal previous_state=0\n\t[ -n \"$3\" ] && previous_state=\"$3\"\n\n\t#SCAN TYPE\n\tlocal transition_type=\"arrival\"\n\t[ \"$previous_state\" == \"1\" ] && transition_type=\"departure\"\n\n\t#INTERATION VARIABLES\n\tlocal devices=\"$1\"\n\tlocal devices_next=\"$devices\"\n\tlocal scan_start=\"\"\n\tlocal scan_duration=\"\"\n\tlocal should_report=\"\"\n\tlocal manufacturer=\"Unknown\"\n\tlocal has_requested_collaborative_depart_scan=false\n\t\n\t#LOG START OF DEVICE SCAN \n\t$PREF_MQTT_REPORT_SCAN_MESSAGES && publish_cooperative_scan_message \"$transition_type/start\"\n\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INFO]\t${GREEN}**** started $transition_type scan [x$repetitions max rep] **** ${NC}\"\n\n\t#ITERATE THROUGH THE KNOWN DEVICES \t\n\tlocal repetition \n\tfor repetition in $(seq 1 $repetitions); do\n\n\t\t#SET DONE TO MAIN PIPE\n\t\tprintf \"%s\\n\" \"DONE\" > main_pipe\n\n\t\t#SET DEVICES\n\t\tdevices=\"$devices_next\"\n\n\t\t#ITERATE THROUGH THESE \n\t\tlocal known_addr\n\t\tlocal known_addr_stated\n\t\tlocal expected_name\n\t\tlocal name_raw\n\t\tlocal name\n\t\tlocal scan_end\n\t\tlocal scan_duration\n\t\tlocal percent_confidence\n\t\tlocal adjusted_delay\n\n\t\tfor known_addr_stated in $devices; do \n\n\t\t\t#EXTRACT KNOWN ADDRESS FROM STATE-PREFIXED KNOWN ADDRESS, IF PRESENT\n\t\t\tif [[ \"$known_addr_stated\" =~ .*[0-9A-Fa-f]{3}.* ]]; then \n\t\t\t\t#SET KNOWN ADDRESS\n\t\t\t\tknown_addr=${known_addr_stated:1}\n\n\t\t\t\t#SET PREVIOUS STATE\n\t\t\t\tprevious_state=${known_addr_stated:0:1}\n\t\t\telse\n\t\t\t\t#THIS ELEMENT OF THE ARRAY DOES NOT CONTAIN A STATE PREFIX; GO WITH GLOBAL\n\t\t\t\t#STATE SCAN TYPE\n\t\t\t\tknown_addr=$known_addr_stated\n\t\t\tfi \n\n\t\t\t#DETERMINE MANUFACTUERE\n\t\t\tmanufacturer=\"$(determine_manufacturer \"$known_addr\")\"\n\t\t\tmanufacturer=${manufacturer:-Unknown}\n\n\t\t\t#IN CASE WE HAVE A BLANK ADDRESS, FOR WHATEVER REASON\n\t\t\t[ -z \"$known_addr\" ] && continue\n\n\t\t\t#DETERMINE START OF SCAN\n\t\t\tscan_start=\"$(date +%s)\"\n\n\t\t\t#GET LOCAL NAME\n\t\t\texpected_name=\"$(determine_name \"$known_addr\")\"\n\t\t\texpected_name=${expected_name:-Unknown}\n\n\t\t\t#DEBUG LOGGING\n\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SCAN]\t${GREEN}(No. $repetition)${NC} $known_addr $transition_type? ${NC}\"\n\n\t\t\t#PERFORM NAME SCAN FROM HCI TOOL. THE HCITOOL CMD 0X1 0X0019 IS POSSIBLE, BUT HCITOOL NAME\n\t\t\t#SCAN PERFORMS VERIFICATIONS THAT REDUCE FALSE NEGATIVES. \n\n\t\t\t#L2SCAN MAY INVOLVE LESS INTERFERENCE\n\t\t\tname_raw=$(hcitool -i \"$PREF_HCI_DEVICE\" name \"$known_addr\" 2>/dev/null)\n\t\t\tname=$(echo \"$name_raw\" | grep -ivE 'input/output error|invalid device|invalid|error|network')\n\n\t\t\t#COLLECT STATISTICS ABOUT THE SCAN \n\t\t\tscan_end=\"$(date +%s)\"\n\t\t\tscan_duration=$((scan_end - scan_start))\n\n\t\t\t#MARK THE ADDRESS AS SCANNED SO THAT IT CAN BE LOGGED ON THE MAIN PIPE\n\t\t\tprintf \"%s\\n\" \"SCAN$known_addr\" > main_pipe & \n\n\t\t\t#IF STATUS CHANGES TO PRESENT FROM NOT PRESENT, REMOVE FROM VERIFICATIONS\n\t\t\tif [ -n \"$name\" ] && [ \"$previous_state\" == \"0\" ]; then \n\n\t\t\t\t#PUSH TO MAIN POPE\n\t\t\t\tprintf \"%s\\n\" \"NAME$known_addr|$name\" > main_pipe \n\n\t\t\t\t#DEVICE FOUND; IS IT CHANGED? IF SO, REPORT \n\t\t\t\tpublish_presence_message \\\n\t\t\t\t\"id=$known_addr\" \\\n\t\t\t\t\"confidence=100\" \\\n\t\t\t\t\"name=$expected_name\" \\\n\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\"type=KNOWN_MAC\"\n\n\t\t\t\t#REMOVE FROM SCAN\n\t\t\t\tdevices_next=$(echo \"$devices_next\" | sed \"s/$known_addr_stated//gi;s/  */ /gi\")\n\n\t\t\telif [ -n \"$name\" ] && [ \"$previous_state\" == \"3\" ]; then \n\t\t\t\t#HERE, WE HAVE FOUND A DEVICE FOR THE FIRST TIME\n\t\t\t\tdevices_next=$(echo \"$devices_next\" | sed \"s/$known_addr_stated//gi;s/  */ /gi\")\n\n\t\t\t\t#NEED TO UPDATE STATE TO MAIN THREAD\n\t\t\t\tprintf \"%s\\n\" \"NAME$known_addr|$name\" > main_pipe \n\n\t\t\t\t#NEVER SEEN THIS DEVICE; NEED TO PUBLISH STATE MESSAGE\n\t\t\t\tpublish_presence_message \\\n\t\t\t\t\"id=$known_addr\" \"confidence=100\" \\\n\t\t\t\t\"name=$expected_name\" \\\n\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\"type=KNOWN_MAC\"\n\n\t\t\t\t#COOPERATIVE SCAN ON RESTART\n\t\t\t\t$PREF_TRIGGER_MODE_REPORT_OUT && publish_cooperative_scan_message \"arrive\" \n\n\n\t\t\telif [ -n \"$name\" ] && [ \"$previous_state\" == \"1\" ]; then \n\n\t\t\t\t#THIS DEVICE IS STILL PRESENT; REMOVE FROM VERIFICATIONS\n\t\t\t\tdevices_next=$(echo \"$devices_next\" | sed \"s/$known_addr_stated//gi;s/  */ /gi\")\n\n\t\t\t\t#NEED TO REPORT? \n\t\t\t\tif [[ $should_report =~ .*$known_addr.* ]] || [ \"$PREF_REPORT_ALL_MODE\" == true ] ; then \t\t\t\n\t\t\t\t\t#REPORT PRESENCE\n\t\t\t\t\tpublish_presence_message \\\n\t\t\t\t\t\"id=$known_addr\" \\\n\t\t\t\t\t\"confidence=100\" \\\n\t\t\t\t\t\"name=$expected_name\" \\\n\t\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\t\"type=KNOWN_MAC\"\t\t\t\n\t\t\t\tfi \n\t\t\tfi \n\n\t\t\t#SHOULD WE REPORT A DROP IN CONFIDENCE? \n\t\t\tif [ -z \"$name\" ] && [ \"$previous_state\" == \"1\" ]; then \n\n\t\t\t\t#CALCULATE PERCENT CONFIDENCE\n\t\t\t\tpercent_confidence=$(echo \"scale=1; ($repetitions - $repetition + 1) / $repetitions * 90\" | bc )\n\n\t\t\t\t#FALLBACK TO REMOVE DECIMAL AND PRINT INTEGER ONLY\n\t\t\t\tpercent_confidence=${percent_confidence%.*}\n\n\t\t\t\t#ONLY PUBLISH COOPERATIVE SCAN MODE IF WE ARE NOT IN TRIGGER MODE\n\t\t\t\t#TRIGGER ONLY MODE DOES NOT SEND COOPERATIVE MESSAGES\n\t\t\t\tif [ \"$has_requested_collaborative_depart_scan\" == false ]; then \n\t\t\t\t\t#SEND THE MESSAGE IF APPROPRIATE\n\t\t\t\t\tif [ \"$percent_confidence\" -lt \"$PREF_COOPERATIVE_SCAN_THRESHOLD\" ] && $PREF_TRIGGER_MODE_REPORT_OUT; then \n\t\t\t\t\t\thas_requested_collaborative_depart_scan=true\n\t\t\t\t\t\tpublish_cooperative_scan_message \"depart\" \n\t\t\t\t\tfi \n\t\t\t\tfi \n\n\t\t\t\t#REPORT PRESENCE OF DEVICE\n\t\t\t\tpublish_presence_message \\\n\t\t\t\t\"id=$known_addr\" \\\n\t\t\t\t\"confidence=$percent_confidence\" \\\n\t\t\t\t\"name=$expected_name\" \\\n\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\"type=KNOWN_MAC\"\n\n\t\t\t\t#IF WE DO FIND A NAME LATER, WE SHOULD REPORT OUT \n\t\t\t\tshould_report=\"$should_report$known_addr\"\n\n\t\t\telif [ -z \"$name\" ] && [ \"$previous_state\" == \"3\" ]; then \n\n\t\t\t\t#NEVER SEEN THIS DEVICE; NEED TO PUBLISH STATE MESSAGE\n\t\t\t\tpublish_presence_message \\\n\t\t\t\t\"id=$known_addr\" \\\n\t\t\t\t\"confidence=0\" \\\n\t\t\t\t\"name=$expected_name\" \\\n\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\"type=KNOWN_MAC\"\n\n\t\t\t\t#PUBLISH MESSAGE TO RSSI SENSOR \n\t\t\t\tpublish_rssi_message \\\n\t\t\t\t\"$known_addr\" \\\n\t\t\t\t\"-99\"\n\n\t\t\t\t#NREMOVE FROM THE SCAN LIST TO THE MAIN BECAUSE THIS IS A BOOT UP \n\t\t\t\tdevices_next=$(echo \"$devices_next\" | sed \"s/$known_addr_stated//gi;s/  */ /gi\")\n\n\t\t\t\t#PUBLISH A NOT PRESENT TO THE NAME PIPE\n\t\t\t\tprintf \"%s\\n\" \"NAME$known_addr|\" > main_pipe \n\n\t\t\t\t#COOPERATIVE SCAN ON RESTART\n\t\t\t\t$PREF_TRIGGER_MODE_REPORT_OUT && publish_cooperative_scan_message \"depart\"\n\n\t\t\telif [ -z \"$name\" ] && [ \"$previous_state\" == \"0\" ]; then \n\n\t\t\t\tif [ \"$PREF_REPORT_ALL_MODE\" == true ] ; then \t\t\t\n\t\t\t\t\t#REPORT PRESENCE\n\t\t\t\t\tpublish_presence_message \\\n\t\t\t\t\t\"id=$known_addr\" \\\n\t\t\t\t\t\"confidence=0\" \\\n\t\t\t\t\t\"name=$expected_name\" \\\n\t\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\t\"type=KNOWN_MAC\"\t\t\t\n\n\t\t\t\t\t#PUBLISH MESSAGE TO RSSI SENSOR \n\t\t\t\t\tpublish_rssi_message \\\n\t\t\t\t\t\"$known_addr\" \\\n\t\t\t\t\t\"-99\"\n\n\t\t\t\tfi \n\t\t\tfi \n\n\t\t\t#IF WE HAVE NO MORE DEVICES TO SCAN, IMMEDIATELY RETURN\n\t\t\t[ -z \"$devices_next\" ] && break\n\n\t\t\t#TO PREVENT HARDWARE PROBLEMS\n\t\t\tif [ \"$scan_duration\" -lt \"$PREF_INTERSCAN_DELAY\" ]; then \n\t\t\t\tadjusted_delay=\"$((PREF_INTERSCAN_DELAY - scan_duration))\"\n\n\t\t\t\tif [ \"$adjusted_delay\" -gt \"0\" ]; then \n\t\t\t\t\tsleep \"$adjusted_delay\"\n\t\t\t\telse\n\t\t\t\t\t#DEFAULT MINIMUM SLEEP\n\t\t\t\t\tsleep \"$PREF_INTERSCAN_DELAY\"\n\t\t\t\tfi \n\t\t\telse\n\t\t\t\t#DEFAULT MINIMUM SLEEP\n\t\t\t\tsleep \"$PREF_INTERSCAN_DELAY\"\n\t\t\tfi \n\t\tdone\n\n\t\t#ARE WE DONE WITH ALL DEVICES? \n\t\t[ -z \"$devices_next\" ] && break\n\tdone \n\n\t#ANYHTING LEFT IN THE DEVICES GROUP IS NOT PRESENT\n\tlocal known_addr_stated\n\tlocal known_addr\n\tlocal expected_name\n\tfor known_addr_stated in $devices_next; do \n\t\t#EXTRACT KNOWN ADDRESS FROM STATE-PREFIXED KNOWN ADDRESS, IF PRESENT\n\t\tif [[ \"$known_addr_stated\" =~ .*[0-9A-Fa-f]{3}.* ]]; then \n\t\t\t#SET KNOWN ADDRESS\n\t\t\tknown_addr=${known_addr_stated:1}\n\t\telse\n\t\t\t#THIS ELEMENT OF THE ARRAY DOES NOT CONTAIN A STATE PREFIX\n\t\t\tknown_addr=$known_addr_stated\n\t\tfi\n\n\t\t#PUBLISH MESSAGE\n\t\tif [ ! \"$previous_state\" == \"0\" ]; then \n\t\t\texpected_name=\"$(determine_name \"$known_addr\")\"\n\t\t\texpected_name=${expected_name:-Unknown}\n\n\t\t\t\t\t#DETERMINE MANUFACTUERE\n\t\t\tmanufacturer=\"$(determine_manufacturer \"$known_addr\")\"\n\t\t\tmanufacturer=${manufacturer:-Unknown}\n\n\t\t\t#PUBLISH PRESENCE METHOD\n\t\t\tpublish_presence_message \\\n\t\t\t\"id=$known_addr\" \\\n\t\t\t\"confidence=0\" \\\n\t\t\t\"name=$expected_name\" \\\n\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\"type=KNOWN_MAC\"\n\n\t\t\t#PUBLISH MESSAGE TO RSSI SENSOR \n\t\t\tpublish_rssi_message \\\n\t\t\t\"$known_addr\" \\\n\t\t\t\"-99\"\n\t\tfi \n\n\t\tprintf \"%s\\n\" \"NAME$known_addr|\" > main_pipe \n\tdone\n\n\n\t#SET DONE TO MAIN PIPE\n\tprintf \"%s\\n\" \"DONE\" > main_pipe\n\n\t#GROUP SCAN FINISHED\n\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INFO]\t${GREEN}**** completed $transition_type scan **** ${NC}\"\n\n\t#PUBLISH END OF COOPERATIVE SCAN\n\t$PREF_MQTT_REPORT_SCAN_MESSAGES && publish_cooperative_scan_message \"$transition_type/end\"\n}\n\n# ----------------------------------------------------------------------------------------\n# SCAN TYPE FUNCTIONS \n# ----------------------------------------------------------------------------------------\n\nperform_departure_scan () {\n\n\t#SET SCAN TYPE\n \tlocal depart_list\n \tdepart_list=$(scannable_devices_with_state 1)\n\n \t#LOCAL SCAN ACTIVE VARIABLE\n\tlocal scan_active\n\tscan_active=true \n\n \t#SCAN ACTIVE?\n \tkill -0 \"$scan_pid\" >/dev/null 2>&1 && scan_active=true || scan_active=false \n\t\n\t#ONLY ASSEMBLE IF WE NEED TO SCAN FOR ARRIVAL\n\tif [ \"$scan_active\" == false ] ; then \n\n\t \t#ADD A FLAG TO SCAN FOR \n\t\t[ -n \"$depart_list\" ] && printf \"%s\\n\" \"BEXP\" > main_pipe & \n\n\t\t#ONCE THE LIST IS ESTABLISHED, TRIGGER SCAN OF THESE DEVICES IN THE BACKGROUND\n\t\tperform_complete_scan \"$depart_list\" \"$PREF_DEPART_SCAN_ATTEMPTS\" \"1\" & \n\t\tdisown \"$!\"\n\n\t\tscan_pid=$!\n\t\tscan_type=1\n\telse \n\t\t#HERE A DEPART SCAN IS ACTIVE; ENQUEUE ANOTHER DEPART SCAN AFTER DELAY \n\t\t[ \"$scan_type\" == \"0\" ] && sleep 5 && printf \"%s\\n\" \"ENQUdepart\" > main_pipe & \t\n\tfi\n}\n\nperform_arrival_scan () {\n\t#SET SCAN TYPE\n \tlocal arrive_list\n \tarrive_list=$(scannable_devices_with_state 0)\n\n\t#LOCAL SCAN ACTIVE VARIABLE\n\tlocal scan_active\n\tscan_active=true \n\n \t#SCAN ACTIVE?\n \tkill -0 \"$scan_pid\" >/dev/null 2>&1 && scan_active=true || scan_active=false \n\t\t\n\t#ONLY ASSEMBLE IF WE NEED TO SCAN FOR ARRIVAL\n\tif [ \"$scan_active\" == false ] ; then \n\n\t\t#FIRST SCAN IS DEAD\n\t\tfirst_arrive_scan=false\n\n\t\t#ONCE THE LIST IS ESTABLISHED, TRIGGER SCAN OF THESE DEVICES IN THE BACKGROUND\n\t\tperform_complete_scan \"$arrive_list\" \"$PREF_ARRIVAL_SCAN_ATTEMPTS\" \"0\" & \n\t\tdisown \"$!\"\n\n\t\tscan_pid=$!\n\t\tscan_type=0\n\telse \n\t\t#HERE A DEPART SCAN IS ACTIVE; ENQUEUE ANOTHER DEPART SCAN AFTER DELAY\n\t\t[ \"$scan_type\" == \"1\" ] && sleep 5 && printf \"%s\\n\" \"ENQUarrive\" > main_pipe & \n\tfi \n}\n\n# ----------------------------------------------------------------------------------------\n# NAME DETERMINATIONS\n# ----------------------------------------------------------------------------------------\n\ndetermine_name () {\n\n\t#SET DATA \n\tlocal address\n\taddress=\"$1\"\n\n\t#RETURN ADDRESS\n\t[ -z \"$address\" ] && return 0\n\n\t#ALTERNATIVE ADDRESS \n\tlocal alternate_address\n\talternate_address=\"$2\"\n\talternate_address=${alternate_address:-Unknown}\n\t\n\t#IF IS NEW AND IS PUBLIC, SHOULD CHECK FOR NAME\n\tlocal expected_name\n\texpected_name=\"${known_public_device_name[$address]}\"\n\n\t#ALTERNATE NAME? \n\t[ -z \"$expected_name\" ]\t&& expected_name=\"${known_public_device_name[$alternate_address]}\"\n\n\t#FIND PERMANENT DEVICE NAME OF PUBLIC DEVICE\n\tif [ -z \"$expected_name\" ]; then \n\n\t\t#CHECK CACHE\n\t\texpected_name=$(grep \"$address\" < \"$base_directory/.public_name_cache\" | awk -F \"\\t\" '{print $2}')\n\n\t\t#IF CACHE DOES NOT EXIST, TRY TO SCAN\n\t\tif [ -z \"$expected_name\" ]; then \n\n\t\t\t#DOES SCAN PROCESS CURRENTLY EXIST? \n\t\t\tkill -0 \"$scan_pid\" >/dev/null 2>&1 && scan_active=true || scan_active=false \n\n\t\t \t#ONLY SCAN IF WE ARE NOT OTHERWISE SCANNING; NAME FOR THIS DEVICE IS NOT IMPORTANT\n\t\t \tif [ \"$scan_active\" == false ] ; then \n\n\t\t\t\t#FIND NAME OF THIS DEVICE\n\t\t\t\texpected_name=$(hcitool -i \"$PREF_HCI_DEVICE\" name \"$address\" 2>/dev/null)\n\n\t\t\t\t#IS THE EXPECTED NAME BLANK? \n\t\t\t\tif [ -n \"$expected_name\" ]; then \n\n\t\t\t\t\t#ADD TO SESSION ARRAY\n\t\t\t\t\tknown_public_device_name[$address]=\"$expected_name\"\n\n\t\t\t\t\t#ADD TO CACHE\n\t\t\t\t\techo \"$address\t$expected_name\" >> .public_name_cache\n\t\t\t\telse\n\t\t\t\t\t#ADD TO CACHE TO PREVENT RE-SCANNING\n\t\t\t\t\techo \"$address\tUndeterminable\" >> .public_name_cache\n\n\t\t\t\tfi \n\t\t\tfi \n\t\telse\n\t\t\t#WE HAVE A CACHED NAME, ADD IT BACK TO THE PUBLIC DEVICE ARRAY \n\t\t\tknown_public_device_name[$address]=\"$expected_name\"\n\t\tfi\n\tfi \n\n\tprintf \"%s\\n\" \"$expected_name\"\n}\n\n# ----------------------------------------------------------------------------------------\n# BACKGROUND PROCESSES\n# ----------------------------------------------------------------------------------------\n\n#SET LOG\n(rm .pids) 2>&1 1>/dev/null \n\nlog_listener &\nlistener_pid=\"$!\"\necho \"> log listener pid = $listener_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> log listener pid = $listener_pid\"\ndisown \"$listener_pid\"\n\nbtle_scanner & \nbtle_scan_pid=\"$!\"\necho \"> btle scan pid = $btle_scan_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> btle scan pid = $btle_scan_pid\"\ndisown \"$btle_scan_pid\"\n\nbtle_text_listener &\nbtle_text_pid=\"$!\"\necho \"> btle text pid = $btle_text_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> btle text pid = $btle_text_pid\"\ndisown \"$btle_text_pid\"\n\nbtle_listener &\nbtle_listener_pid=\"$!\"\necho \"> btle listener pid = $btle_listener_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> btle listener pid = $btle_listener_pid\" \ndisown \"$btle_listener_pid\"\n\nmqtt_listener &\nmqtt_pid=\"$!\"\necho \"> mqtt listener pid = $mqtt_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> mqtt listener pid = $mqtt_pid\"\ndisown \"$mqtt_pid\"\n\nbtle_packet_listener &\nbtle_packet_listener_pid=\"$!\"\necho \"> packet listener pid = $btle_packet_listener_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> packet listener pid = $btle_packet_listener_pid\"\ndisown \"$btle_packet_listener_pid\"\n\nbeacon_database_expiration_trigger &\nbeacon_database_expiration_trigger_pid=\"$!\"\necho \"> beacon database time trigger pid = $beacon_database_expiration_trigger_pid\" >> .pids\n$PREF_VERBOSE_LOGGING && echo \"> beacon database time trigger pid = $beacon_database_expiration_trigger_pid\"\ndisown \"$beacon_database_expiration_trigger_pid\"\n\n# ----------------------------------------------------------------------------------------\n# MAIN LOOPS. INFINITE LOOP CONTINUES, NAMED PIPE IS READ INTO SECONDARY LOOP\n# ----------------------------------------------------------------------------------------\n\n#MAIN LOOP\nwhile true; do \n\t\n\t#READ FROM THE MAIN PIPE\n\twhile read -r event; do\n\n\t\t#DIVIDE EVENT MESSAGE INTO TYPE AND DATA\n\t\tcmd=\"${event:0:4}\"\n\t\tdata=\"${event:4}\"\n\t\ttimestamp=$(date +%s)\n\t\tuptime=$((timestamp - now))\n\n\t\t#FLAGS TO DETERMINE FRESHNESS OF DATA\n\t\tis_new=false\n\t\tshould_update=false\n\t\tdid_change=false\n\t\tis_apple_beacon=false\n\n\t\t#CLEAR DATA IN NONLOCAL VARS\n\t\tmanufacturer=\"unknown\"\n\t\tcurrent_associated_beacon_mac_address=\"\"\n\t\tname=\"\"\n\t\texpected_name=\"\"\n\t\tmac=\"\"\n\t\trssi=\"\"\n\t\tadv_data=\"\"\n\t\tresolvable=\"\"\n\t\tpdu_header=\"\"\n\t\tpower=\"\"\n\t\tmajor=\"\"\n\t\tminor=\"\"\n\t\tuuid=\"\"\n\t\tbeacon_type=\"GENERIC_BEACON\"\n\t\tbeacon_last_seen=\"\"\n\t\tkey_last_seen=\"\"\n\t\tuuid_reference=\"\"\n\t\tlast_appearance=\"\"\n\t\tbeacon_uuid_key=\"\"\n\t\tinstruction_timestamp=\"\"\n\t\tinstruction_delay=\"\"\n\t\tobservation_made=false\n\t\tmost_recent_beacon=\"\"\n\t\tobserved_max_advertisement_interval=\"\"\n\t\ttemp_observation=\"\"\n\t\tdevice_state=\"\"\n\n\t\t#PROCEED BASED ON COMMAND TYPE\n\t\tif [ \"$cmd\" == \"ENQU\" ] && [ \"$uptime\" -gt \"$PREF_STARTUP_SETTLE_TIME\" ]; then \n\n\t\t\t#WE HAVE AN ENQUEUED OPPOSITE SCAN; NEED TO TRIGGER THAT SCAN\n\t\t\tif [ \"$data\" == \"arrive\" ]; then \n\n\t\t\t\t#LOG\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[ENQ-ARR]\t${NC}Enqueued arrival scan triggered.${NC}\" \n\n\t\t\t\t#WAIT 5 SECONDS\n\t\t\t\tsleep 5\n\t\t\t\t\n\t\t\t\t#TRIGGER \n\t\t\t\tperform_arrival_scan\n\n\t\t\telif [ \"$data\" == \"depart\" ]; then \t\t\n\t\t\t\t#LOG\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[ENQ-DEP]\t${NC}Enqueued depart scan triggered.${NC}\" \n\n\t\t\t\t#WAIT 5 SECONDS\n\t\t\t\tsleep 5\n\n\t\t\t\t#TRIGGER \n\t\t\t\tperform_departure_scan\n\t\t\tfi\n\n\t\telif [ \"$cmd\" == \"RAND\" ]; then \n\t\t\t#PARSE RECEIVED DATA\n\t\t\tmac=$(echo \"$data\" | awk -F \"|\" '{print $1}')\n\t\t\tpdu_header=$(echo \"$data\" | awk -F \"|\" '{print $2}')\n\t\t\tname=$(echo \"$data\" | awk -F \"|\" '{print $3}')\n\t\t\trssi=$(echo \"$data\" | awk -F \"|\" '{print $4}')\n\t\t\tadv_data=$(echo \"$data\" | awk -F \"|\" '{print $5}')\n\t\t\tmanufacturer=$(echo \"$data\" | awk -F \"|\" '{print $6}')\n\t\t\tdevice_type=$(echo \"$data\" | awk -F \"|\" '{print $7}')\n\t\t\tflags=$(echo \"$data\" | awk -F \"|\" '{print $8}')\n\t\t\toem_data=$(echo \"$data\" | awk -F \"|\" '{print $9}')\n\t\t\tinstruction_timestamp=$(echo \"$data\" | awk -F \"|\" '{print $10}')\n\t\t\tresolvable=$(echo \"$data\" | awk -F \"|\" '{print $11}')\n\t\t\thex_data=$(echo \"$data\" | awk -F \"|\" '{print $12}')\n\n\t\t\t#FIND DELAY BASED ON INSTRUCTINO TIMESTAMP\n\t\t\tinstruction_delay=$((timestamp - instruction_timestamp))\n\n\t\t\t#GET LAST RSSI\n\t\t\trssi_latest=\"${rssi_log[$mac]}\"\n\t\t\t\n\t\t\t#IF WE HAVE A NAME; UNSEAT FROM RANDOM AND ADD TO STATIC\n\t\t\t#THIS IS A BIT OF A FUDGE, A RANDOM DEVICE WITH A LOCAL \n\t\t\t#NAME IS TRACKABLE, SO IT'S UNLIKELY THAT ANY CONSUMER\n\t\t\t#ELECTRONIC DEVICE OR CELL PHONE IS ASSOCIATED WITH THIS \n\t\t\t#ADDRESS. CONSIDER THE ADDRESS AS A STATIC ADDRESS\n\n\t\t\t#ALSO NEED TO CHECK WHETHER THE RANDOM BROADCAST\n\t\t\t#IS INCLUDED IN THE KNOWN DEVICES LOG...\n\n\t\t\tif [ -n \"${public_device_log[$mac]}\" ]; then\n\t\t\t\t\t\n\t\t\t\t#GET INTERVAL SINCE LAST SEEN\n\t\t\t\tlast_appearance=${public_device_log[$mac]:-$timestamp}\n\t\t\t\tif [ \"$observation_made\" == false ]; then \n\t\t\t\t\tobservation_made=true\n\t\t\t\t\ttemp_observation=\"\" && temp_observation=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\t\t\t\t\t[ \"$temp_observation\" -gt \"${advertisement_interval_observation[$mac]:-0}\" ] && [ \"$temp_observation\" -gt \"0\" ] && [ \"$temp_observation\" -lt \"300\" ] &&\tadvertisement_interval_observation[$mac]=$temp_observation\n\t\t\t\t\t\n\t\t\t\tfi\n\n\t\t\t\t#IS THIS A NEW STATIC DEVICE?\n\t\t\t\tpublic_device_log[$mac]=\"$timestamp\"\n\t\t\t\t[ -n \"$rssi\" ] && rssi_log[$mac]=\"$rssi\"\n\t\t\t\tcmd=\"PUBL\"\n\n\t\t\t\t#BEACON TYPE\n\t\t\t\tbeacon_type=\"GENERIC_BEACON_PUBLIC\"\n\n\t\t\telse\n\t\t\t\t#DO WE HAVE A NAME FOR THIS MAC ADDRESSS? \n\t\t\t\t#THAT IS NOT IN THE PUBLIC DEVICE ARRAY?\n\t\t\t\texpected_name=\"${known_public_device_name[$mac]}\"\n\n\t\t\t\t#DOES THIS DEVICE HAVE A NAME? \n\t\t\t\tif [ -n \"$name\" ] || [ -n \"$expected_name\" ]; then \n\t\t\t\t\t#RESET COMMAND\n\t\t\t\t\tcmd=\"PUBL\"\n\t\t\t\t\tunset \"random_device_log[$mac]\"\n\n\t\t\t\t\t#BEACON TYPE\n\t\t\t\t\tbeacon_type=\"GENERIC_BEACON_RANDOM\"\n\n\t\t\t\t\t#SAVE THE NAME\n\t\t\t\t\tknown_public_device_name[$mac]=\"$name\"\n\t\t\t\t\t[ -n \"$rssi\" ] && rssi_log[$mac]=\"$rssi\"\n\n\t\t\t\t\t#IS THIS A NEW STATIC DEVICE?\n\t\t\t\t\tif [ -n \"${public_device_log[$mac]}\" ]; then \t\t\t\t\t\n\t\t\t\t\t\t#GET INTERVAL SINCE LAST SEEN\n\t\t\t\t\t\tlast_appearance=${public_device_log[$mac]:-$timestamp}\n\t\t\t\t\t\tif [ \"$observation_made\" == false ]; then \n\t\t\t\t\t\t\tobservation_made=true\n\t\t\t\t\t\t\ttemp_observation=\"\" && temp_observation=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\t\t\t\t\t\t\t[ \"$temp_observation\" -gt \"${advertisement_interval_observation[$mac]:-0}\" ] && [ \"$temp_observation\" -gt \"0\" ] && [ \"$temp_observation\" -lt \"300\" ] &&\tadvertisement_interval_observation[$mac]=$temp_observation\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tfi\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tis_new=true\n\t\t\t\t\tfi \n\n\t\t\t\t\tpublic_device_log[$mac]=\"$timestamp\"\n\n\t\t\t\telse \n\n\t\t\t\t\t#DATA IS RANDOM MAC Addr.; ADD TO LOG\n\t\t\t\t\t[ -z \"${random_device_log[$mac]}\" ] && is_new=true\n\n\t\t\t\t\t#WHEN DOES THIS RANDOM BEACON EXPIRE?\n\t\t\t\t\tlast_appearance=${random_device_log[$mac]:-$timestamp}\n\t\t\t\t\tif [ \"$observation_made\" == false ]; then \n\t\t\t\t\t\tobservation_made=true\n\t\t\t\t\t\ttemp_observation=\"\" && temp_observation=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\t\t\t\t\t\t[ \"$temp_observation\" -gt \"${advertisement_interval_observation[$mac]:-0}\" ] && [ \"$temp_observation\" -gt \"0\" ] && [ \"$temp_observation\" -lt \"300\" ] &&\tadvertisement_interval_observation[$mac]=$temp_observation\n\t\t\t\t\t\t\n\t\t\t\t\tfi\n\t\t\t\t\t\n\t\t\t\t\t#ONLY ADD THIS TO THE DEVICE LOG \n\t\t\t\t\trandom_device_log[$mac]=\"$timestamp\"\n\t\t\t\t\t[ -n \"$rssi\" ] && rssi_log[$mac]=\"$rssi\"\n\t\t\t\tfi \n\t\t\tfi\n\n\t\telif [ \"$cmd\" == \"SCAN\" ]; then \n\t\t\t#SET MAC = DATA\n\t\t\tmac=$data\n\n\t\t\t#ADD TO THE SCAN LOG\n\t\t\tknown_static_device_scan_log[$mac]=$(date +%s)\n\t\t\tcontinue\n\n\t\telif [ \"$cmd\" == \"DONE\" ]; then \n\n\t\t\t#SCAN MODE IS COMPLETE\n\t\t\tscan_pid=\"\"\n\n\t\t\t#SET LAST ARRIVAL OR DEPARTURE SCAN\n\t\t\t[ \"$scan_type\" == \"0\" ] && last_arrival_scan=$(date +%s)\n\t\t\t[ \"$scan_type\" == \"1\" ] && last_depart_scan=$(date +%s)\n\n\t\t\tscan_type=\"\"\n\t\t\tcontinue\n\n\t\telif [ \"$cmd\" == \"MQTT\" ] && [ \"$uptime\" -gt \"$PREF_STARTUP_SETTLE_TIME\" ]; then \n\n\t\t\t#GET INSTRUCTION \n\t\t\ttopic_path_of_instruction=\"${data%%|*}\"\n\t\t\tdata_of_instruction=\"${data##*|}\"\n\n\t\t\t#IGNORE INSTRUCTION FROM SELF\n\t\t\tif [[ ${data_of_instruction^^} =~ .*${mqtt_publisher_identity^^}.* ]] || [[ ${topic_path_of_instruction^^} =~ .*${mqtt_publisher_identity^^}.* ]]; then \n\t\t\t\tcontinue\n\t\t\tfi \n\n\t\t\t#GET THE TOPIC \n\t\t\tmqtt_topic_branch=$(basename \"$topic_path_of_instruction\")\n\n\t\t\t#NORMALIZE TO UPPERCASE\n\t\t\tmqtt_topic_branch=${mqtt_topic_branch^^}\n\n\t\t\tif [[ $mqtt_topic_branch =~ .*ARRIVE.* ]]; then \n\n\t\t\t\t#IGNORE OR PASS MQTT INSTRUCTION?\n\t\t\t\tscan_type_diff=$((timestamp - last_arrival_scan))\n\t\t\t\tif [ \"$scan_type_diff\" -gt \"$PREF_MINIMUM_TIME_BETWEEN_SCANS\" ]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] arrive scan requested ${NC}\"\n\t\t\t\t\tperform_arrival_scan\n\t\t\t\telse\n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${RED}fail mqtt${NC}] arrive scan rejected due to recent scan ${NC}\"\n\t\t\t\tfi \n\t\t\t\t\n\t\t\telif [[ $mqtt_topic_branch =~ .*KNOWN\\ DEVICE\\ STATES.* ]]; then \t\t\t\t\n\n\t\t\t\t#SIMPLE STATUS MESSAGE FOR KNOWN\n\t\t\t\tdevice_state=\"\"\n\t\t\t\tfor addr in \"${known_static_addresses[@]^^}\"; do \n\t\t\t\t\t#GET STATE; ONLY SCAN FOR DEVICES WITH SPECIFIC STATE\n\t\t\t\t\tdevice_state=\"${known_public_device_log[$addr]}\"\n\t\t\t\t\tdevice_state=${device_state:-0}\n\n\t\t\t\t\t#SET TO CONFIDENCE RANGE\n\t\t\t\t\t[ \"$device_state\" == \"1\" ] && device_state=100\n\n\t\t\t\t\t#SEND STATUS UPDATE\n\t\t\t\t\tpublish_presence_message  \\\n\t\t\t\t\t\"id=$addr\" \\\n\t\t\t\t\t\"confidence=$device_state\" \\\n\t\t\t\t\t\"name=${known_public_device_name[$addr]}\" \\\n\t\t\t\t\t\"type=KNOWN_MAC\"\n\n\t\t\t\tdone\n\t\t\t\t\n\t\t\telif [[ $mqtt_topic_branch =~ .*ADD\\ STATIC\\ DEVICE.* ]] || [[ $mqtt_topic_branch =~ .*DELETE\\ STATIC\\ DEVICE.* ]]; then \n\n\t\t\t\tif [[ \"${data_of_instruction^^}\" =~ ([A-F0-9]{2}:){5}[A-F0-9]{2} ]]; then \n\t\t\t\t\t#GET MAC ADDRESSES\n\t\t\t\t\tmac=\"${BASH_REMATCH}\"\n\t\t\t\t\tif [ ! ${known_public_device_name[$mac]+true} ]; then \n\n\t\t\t\t\t\t#HERE, WE KNOW THAT WE HAVE A MAC ADDRESS AND A VALID INSTRUCTION\n\t\t\t\t\t\tif [[ $mqtt_topic_branch =~ .*ADD\\ STATIC\\ DEVICE.* ]]; then \n\t\t\t\t\t\t\t#WAS THERE A NAME HERE?\n\t\t\t\t\t\t\tname=$(echo \"$data_of_instruction\" | tr \"\\\\t\" \" \" | sed 's/  */ /gi;s/#.\\{0,\\}//gi' | sed \"s/$mac //gi;s/  */ /gi\" )\n\n\t\t\t\t\t\t\t#IF THE VALUE DOES NOT EXIST, USE THE KEY (MAC ADDRESS INSTEAD)\n\t\t\t\t\t\t   \talias_value=${name//[^A-Za-z0-9]/_}\n\n\t\t\t\t\t\t   \t#LOWERCASE\n\t\t\t\t\t\t  \talias_value=${alias_value,,}\n\n\t\t\t\t\t\t  \t#REMOVE FINAL UNDERSCORES SHOUDL THERE BE\n\t\t\t\t\t\t   \talias_value=$(echo \"$alias_value\" | sed 's/[^0-9a-z]\\{1,\\}$//gi;s/^[^0-9a-z]\\{1,\\}//gi;s/__*/_/gi')\n\n\t\t\t\t\t\t\t#ADD TO KNOWN PUBLIC DEVICE ARRAY\n\t\t\t\t\t\t\tknown_public_device_name[$mac]=\"$name\"\n\n\t\t\t\t\t\t\t#ESTABLISH ALIAS\n\t\t\t\t\t\t\t[ -n \"$mac\" ] && [ -n \"$alias_value\" ] && mqtt_aliases[$mac]=\"$alias_value\" \n\n\t\t\t\t\t\t\t#ADD TO KNOWN_STATIC_ADDRESSES FILE\n\t\t\t\t\t\t\techo \"$mac ${name:-}\" >> $PUB_CONFIG\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t#UPDATE FROM STATIC ADDRESSES TOO\n\t\t\t\t\t\t\tmapfile -t known_static_addresses < <(sed 's/#.\\{0,\\}//gi' < \"$PUB_CONFIG\" | awk '{print $1}' | grep -oiE \"([0-9a-f]{2}:){5}[0-9a-f]{2}\" )\n\n\t\t\t\t\t\t\t#LOGGING\n\t\t\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] new static device ${GREEN}$mac${NC} added with alias ${GREEN}${name:-none}${NC}\"\n\n\t\t\t\t\t\t\t#PERFORM ARRIVAL SCAN FOR NEW DEVICE\n\t\t\t\t\t\t\tperform_arrival_scan\n\t\t\t\t\t\tfi\n\t\t\t\t\t\t\n\t\t\t\t\telse\n\n\t\t\t\t\t\t#ONLY PERFORM IF WE HAVE A DEVICE TO DELETE\n\t\t\t\t\t\tif [[ $mqtt_topic_branch =~ .*DELETE\\ STATIC\\ DEVICE.* ]]; then \n\n\t\t\t\t\t\t\t#HERE, WE NOW THAT WE HAVE TO DELETE THE DEVICE WITH THE MAC ADDRESS\n\t\t\t\t\t\t\tsed -i '/'\"$mac\"'/Id' $PUB_CONFIG\n\n\t\t\t\t\t\t\t#UNSET FROM MEMORY\n\t\t\t\t\t\t\tunset \"known_public_device_name[$mac]\"\n\t\t\t\t\t\t\tunset \"mqtt_aliases[$mac]\"\n\n\t\t\t\t\t\t\t#REMOVE FROM STATIC ADDRESSES TOO\n\t\t\t\t\t\t\tmapfile -t known_static_addresses < <(sed 's/#.\\{0,\\}//gi' < \"$PUB_CONFIG\" | awk '{print $1}' | grep -oiE \"([0-9a-f]{2}:){5}[0-9a-f]{2}\" )\n\n\t\t\t\t\t\t\t#LOGGING\n\t\t\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] removed static device ${GREEN}$mac${NC}\"\n\n\t\t\t\t\t\t\t#PERFORM DEPARTURE SCAN TO MAKE SURE THIS DEVICE IS GONE\n\t\t\t\t\t\t\tperform_departure_scan\n\t\t\t\t\t\tfi \n\t\t\t\t\tfi \n\t\t\t\telse\n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${RED}fail mqtt${NC}] new static device request did not contain a device address ${NC}\"\n\t\t\t\tfi\n\n\t\t\telif [[ $mqtt_topic_branch =~ .*DEPART.* ]]; then \n\t\t\t\t\n\t\t\t\t#IGNORE OR PASS MQTT INSTRUCTION?\n\t\t\t\tscan_type_diff=$((timestamp - last_depart_scan))\n\t\t\t\tif [ \"$scan_type_diff\" -gt \"$PREF_MINIMUM_TIME_BETWEEN_SCANS\" ]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] depart scan requested ${NC}\"\n\t\t\t\t\tperform_departure_scan\n\t\t\t\telse\n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${RED}fail mqtt${NC}] depart scan rejected due to recent scan ${NC}\"\n\t\t\t\tfi \t\n\n\t\t\telif [[ $mqtt_topic_branch =~ .*RSSI.* ]]; then \n\t\t\t\t\n\t\t\t\t#SCAN FOR RSSI\n\t\t\t\tdifference_last_rssi=$((timestamp - last_rssi_scan))\n\n\t\t\t\t#ONLY EVER 5 MINUTES\n\t\t\t\tif [ \"$difference_last_rssi\" -gt \"100\" ] || [ -z \"$last_rssi_scan\" ] ; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] rssi update scan requested ${NC}\"\n\t\t\t\t\tconnectable_present_devices\n\t\t\t\t\tlast_rssi_scan=$(date +%s)\n\t\t\t\telse\n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${RED}fail mqtt${NC}] rssi update scan rejected due to recent scan ${NC}\"\n\t\t\t\tfi \n\n\t\t\telif [[ $mqtt_topic_branch =~ .*RESTART.* ]]; then \n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] service restart requested ${NC}\"\n\t\t\t\t\n\t\t\t\t#RESTART SYSTEM\n\t\t\t\tsystemctl restart monitor.service\t\n\n\t\t\t\t#exit\n\t\t\t\texit 0\t\n\n\t\t\telif [[ $mqtt_topic_branch =~ .*ECHO.* ]] && [[ -z \"$data_of_instruction\" ]]; then \n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] echo  ${NC}\"\t\t\t\t\n\t\t\t\t\n\t\t\t\tmqtt_echo\n\t\t\t\n\t\t\telif [[ $mqtt_topic_branch =~ .*UPDATEBETA.* ]]; then\n\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] beta update requested ${NC}\"\t\t\t\t\n\t\t\t\t\n\t\t\t\t#GIT FETCH\n\t\t\t\tgit fetch\n\t\t\t\t\n\t\t\t\t#GIT FETCH\n\t\t\t\tgit checkout beta\t\t\t\t\n\t\t\t\t\n\t\t\t\t#GIT PULL\n\t\t\t\tgit pull\n\n\t\t\t\t#RESTART SYSTEM\n\t\t\t\tsystemctl restart monitor.service\t\n\n\t\t\t\t#exit\n\t\t\t\texit 0\n\t\t\t\t\n\t\t\telif [[ $mqtt_topic_branch =~ .*UPDATE.* ]]; then \n\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-INST]\t${NC}[${GREEN}pass mqtt${NC}] update requested ${NC}\"\t\t\t\t\n\t\t\t\t\n\t\t\t\t#GIT FETCH\n\t\t\t\tgit fetch\n\t\t\t\t\n\t\t\t\t#GIT FETCH\n\t\t\t\tgit checkout master\t\t\t\t\n\t\t\t\t\n\t\t\t\t#GIT PULL\n\t\t\t\tgit pull\n\n\t\t\t\t#RESTART SYSTEM\n\t\t\t\tsystemctl restart monitor.service\t\n\n\t\t\t\t#exit\n\t\t\t\texit 0\n\n\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*START.* ]] || [[ ${mqtt_topic_branch^^} =~ .*END.* ]] || [[ ${mqtt_topic_branch^^} =~ .*STATUS.* ]]; then \n\t\t\t\t#IGNORE ERRORS\n\t\t\t\t#$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SCAN]\t${NC}[${RED}ignore mqtt${NC}] ${BLUE}topic:${NC} $topic_path_of_instruction ${BLUE}data:${NC} $data_of_instruction${NC}\"\n\n\t\t\t\tcontinue\n\n\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*[0-9A-F:-]{2,}.* ]]; then \n\t\t\t\t#LOG THE OUTPU\n\t\t\t\t#log \"${GREEN}[CMD-INST]\t${NC}[${ORANGE}ignored mqtt${NC}] ${BLUE}topic:${NC} $topic_path_of_instruction ${BLUE}data:${NC} $data_of_instruction${NC}\"\n\t\t\t\tcontinue\n\n\t\t\telse\n\n\t\t\t\t#LOG THE OUTPU\n\t\t\t\t#log \"${GREEN}[CMD-INST]\t${NC}[${RED}fail mqtt${NC}] ${BLUE}topic:${NC} $topic_path_of_instruction ${BLUE}data:${NC} $data_of_instruction${NC}\"\n\n\t\t\t\t#DO A LITTLE SPELL CHECKING HERE\n\t\t\t\tif [[ ${mqtt_topic_branch^^} =~ .*ARR.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}arrive${NC}? ${NC}\"\n\t\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*DEP.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}depart${NC}? ${NC}\"\n\t\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*BET.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}updatebeta${NC}? ${NC}\"\n\t\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*RSS.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}rssi${NC}? ${NC}\"\n\t\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*STAR.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}restart${NC}? ${NC}\"\n\t\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*DAT.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}update${NC} or .../scan/${RED}updatebeta${NC}? ${NC}\"\n\t\t\t\telif [[ ${mqtt_topic_branch^^} =~ .*ECH.* ]]; then \n\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${GREEN}[CMD-SUGG]\t${NC}[${RED}fail mqtt${NC}] did you mean .../scan/${RED}echo${NC} or .../scan/${RED}updatebeta${NC}? ${NC}\"\n\t\t\t\tfi \n\n\t\t\tfi\n\n\t\telif [ \"$cmd\" == \"BOFF\" ] || [ \"$cmd\" == \"BEXP\" ]; then \n\n\t\t\t[ \"$uptime\" -lt \"$PREF_STARTUP_SETTLE_TIME\" ] && continue\n\t\t\t\n\t\t\t#ONLY WHEN BLUETOOTH IS OFF DO WE ATTEMPT TO SCAN FOR RSSI OF KNOWN/CONNECTED DEVICES\n\t\t\tif [ \"$cmd\" == \"BOFF\" ]; then \n\t\t\t\t#FIND RSSI OF KNOWN DEVICES PREVIOUSLY CONNECTED WHILE HICTOOL IS NOT \n\t\t\t\t#SCANNING\t\t\t\n\t\t\t\tdifference_last_rssi=$((timestamp - last_rssi_scan))\n\n\t\t\t\t#ONLY EVER 5 MINUTES\n\t\t\t\tif [ \"$difference_last_rssi\" -gt \"90\" ] || [ -z \"$last_rssi_scan\" ] ; then \n\t\t\t\t\tconnectable_present_devices\n\t\t\t\t\tlast_rssi_scan=$(date +%s)\n\t\t\t\tfi \n\t\t\tfi \n\n\t\t\t#RETURN PERIODIC SCAN MODE\t\n\t\t\tif [ \"$PREF_PERIODIC_MODE\" == true ]; then \n\n\t\t\t\t#SCANNED RECENTLY? \n\t\t\t\tduration_since_arrival_scan=$((timestamp - last_arrival_scan))\n\t\t\t\t\n\t\t\t\t#CALCULATE DEPARTURE\n\t\t\t\tduration_since_depart_scan=$((timestamp - last_depart_scan))\n\n\t\t\t\tif [ \"$duration_since_depart_scan\" -gt \"$PREF_DEPART_SCAN_INTERVAL\" ]; then \n\n\t\t\t\t\tperform_departure_scan\n\n\t\t\t\telif [ \"$duration_since_arrival_scan\" -gt \"$PREF_ARRIVE_SCAN_INTERVAL\" ]; then \n\n\t\t\t\t\tperform_arrival_scan \n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\t#**********************************************************************\n\t\t\t#\n\t\t\t#\n\t\t\t#\tTHE FOLLOWING LOOPS CLEAR CACHES OF ALREADY SEEN DEVICES BASED \n\t\t\t#\tON APPROPRIATE TIMEOUT PERIODS FOR THOSE DEVICES. \n\t\t\t#\t\n\t\t\t#\n\t\t\t#**********************************************************************\n\n\t\t\t#DID ANY DEVICE EXPIRE? \n\t\t\tshould_scan=false\n\t\t\tlast_seen=\"\"\n\t\t\tkey=\"\"\n\t\t\tbeacon_specific_expiration_interval=\"\"\n\t\t\t\n\t\t\t#PURGE OLD KEYS FROM THE RANDOM DEVICE LOG\n\t\t\tfor key in \"${!random_device_log[@]}\"; do\n\n\t\t\t\t#FIND WHEN THIS KEYW AS LAST SEEN? \n\t\t\t\tlast_seen=\"${random_device_log[$key]}\"\n\n\t\t\t\t#DETERMINE THE LAST TIME THIS MAC WAS LOGGED\n\t\t\t\tdifference=$((timestamp - last_seen))\n\n\t\t\t\t#FIND THE EXPIRATION INTERVAL FOR THIS PARTICULAR BEACON\n\t\t\t\tbeacon_specific_expiration_interval=\"${advertisement_interval_observation[$key]}\"\n\t\t\t\tbeacon_specific_expiration_interval=$(( beacon_specific_expiration_interval * PREF_DEPART_SCAN_ATTEMPTS ))\n\n\t\t\t\t#SET EXPIRATION\n\t\t\t\tbeacon_specific_expiration_interval=$(( beacon_specific_expiration_interval > 45 && beacon_specific_expiration_interval  < PREF_RANDOM_DEVICE_EXPIRATION_INTERVAL ? beacon_specific_expiration_interval : PREF_RANDOM_DEVICE_EXPIRATION_INTERVAL ))\n\n\t\t\t\t#CONTINUE IF DEVICE HAS NOT BEEN SEEN OR DATE IS CORRUPT\n\t\t\t\t[ -z \"$last_seen\" ] && continue\n\n\t\t\t\t#IS THIS A BEACON??\n\t\t\t\tif [ \"$difference\" -gt \"$beacon_specific_expiration_interval\" ]; then \n\t\t\t\t\t\n\t\t\t\t\t#REMOVE FROM RANDOM DEVICE LOG\n\t\t\t\t\tunset \"random_device_log[$key]\"\n\t\t\t\t\tunset \"rssi_log[$key]\"\n\t\t\t\t\t[ -z \"${blacklisted_devices[$key]}\" ] && log \"${BLUE}[DEL-RAND]\t${NC}RAND $key expired after $difference seconds ${NC}\"\n\n\t\t\t\t\t#AT LEAST ONE DEVICE EXPIRED\n\t\t\t\t\tshould_scan=true \n\t\t\t\tfi \n\t\t\tdone\n\n\t\t\t#RANDOM DEVICE EXPIRATION SHOULD TRIGGER DEPARTURE SCAN\n\t\t\t[ \"$should_scan\" == true ] && [ \"$PREF_TRIGGER_MODE_DEPART\" == false ] && perform_departure_scan\n\n\t\t\t#THIS IS A LIST OF ALL DEVIES PURGED FROM THE RECORDS; MAY INCLUDE BEACONS\n\t\t\tnotification_sent=\"____ \"\n\n\t\t\t#RESET VARIABLES\n\t\t\tlast_seen=\"\"\n\t\t\tkey=\"\"\n\n\t\t\t#TEMP VAR\n\t\t\tmost_recent_beacon=\"\"\n\t\t\tobserved_max_advertisement_interval=\"\"\n\n\t\t\t#PURGE OLD KEYS FROM THE BEACON DEVICE LOG\n\t\t\tfor key in \"${!public_device_log[@]}\"; do\n\n\t\t\t\t#DETERMINE THE LAST TIME THIS MAC WAS LOGGED\n\t\t\t\tlast_seen=\"${public_device_log[$key]}\"\n\n\t\t\t\t#RSSI\n\t\t\t\tlatest_rssi=\"${rssi_log[$key]}\" \n\n\t\t\t\t#ADJUST FOR BEACON?\n\t\t\t\tis_apple_beacon=false\n\n\t\t\t\t#RESET BEACON KEY\n\t\t\t\tobserved_max_advertisement_interval=\"${advertisement_interval_observation[$key]}\"\n\t\t\t\tmost_recent_beacon=\"\"\n\t\t\t\tbeacon_uuid_found=\"\"\n\t\t\t\tbeacon_mac_found=\"\"\n\n\t\t\t\t#THE PROBLEM HEERE IS THAT WE CAN RUN THROUGH THIS AND HIT ONE OR THE OTHER OF MAC OR ADDRESS FIRST; \n\t\t\t\t#THEN WE EXIT\n\n\t\t\t\t#IS THIS RANDOM ADDRESS ASSOCIATED WITH A BEACON\n\t\t\t\tfor beacon_uuid_key in \"${!beacon_mac_address_log[@]}\"; do\n\t\t\t\t\t#FIND ASSOCIATED BEACON\n\t\t\t\t\tcurrent_associated_beacon_mac_address=\"${beacon_mac_address_log[$beacon_uuid_key]}\"\n\n\t\t\t\t\t#COMPARE TO CURRENT KEY\n\t\t\t\t\tif [ \"$current_associated_beacon_mac_address\" == \"$key\" ]; then \n\t\t\t\t\t\t\n\t\t\t\t\t\t#SET THIS IS A BEACON\n\t\t\t\t\t\tis_apple_beacon=true\n\n\t\t\t\t\t\t#SET VALUES\n\t\t\t\t\t\tbeacon_mac_found=\"$current_associated_beacon_mac_address\"\n\t\t\t\t\t\tbeacon_uuid_found=\"$beacon_uuid_key\"\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\telif [ \"$beacon_uuid_key\" == \"$key\" ]; then \n\n\t\t\t\t\t\t#SET THIS IS A BEACON\n\t\t\t\t\t\tis_apple_beacon=true\n\n\t\t\t\t\t\t#SET THIS IS A BEACON\n\t\t\t\t\t\tis_apple_beacon=true\n\n\t\t\t\t\t\t#SET VALUES\n\t\t\t\t\t\tbeacon_uuid_found=\"$beacon_uuid_key\"\n\t\t\t\t\t\tbeacon_mac_found=\"$current_associated_beacon_mac_address\"\n\t\t\t\t\t\tbreak\t\t\t\t\t\n\t\t\t\t\tfi\n\t\t\t\tdone\n\n\t\t\t\t#DETERMINE IF THIS WAS A BEACON AND, IF SO, WHETHER THE BEACON IS SEEN MORE RECENTLY \n\t\t\t\tif [ \"$is_apple_beacon\" == true ]; then \n\t\t\t\t\t\n\t\t\t\t\t#DETERMINE DIFFERENCE SET DEFAULT NON-EXPIRING VALUE FOR DEVUGGING PURPOSES\n\t\t\t\t\t[ \"${public_device_log[$beacon_mac_found]:--1}\" -ge \"${public_device_log[$beacon_uuid_found]:--1}\" ] && most_recent_beacon=${public_device_log[$beacon_mac_found]}\n\t\t\t\t\t[ \"${public_device_log[$beacon_uuid_found]:--1}\" -ge \"${public_device_log[$beacon_mac_found]:--1}\" ] && most_recent_beacon=${public_device_log[$beacon_uuid_found]}\n\t\t\t\t\t\n\t\t\t\t\tlast_seen=\"$most_recent_beacon\"\n\n\t\t\t\t\t#WHICH PREDICTION SHOULD WE USE? \n\t\t\t\t\t[ \"${advertisement_interval_observation[$beacon_mac_found]:--1}\" -ge \"${advertisement_interval_observation[$beacon_uuid_found]:--1}\" ] && observed_max_advertisement_interval=\"${advertisement_interval_observation[$beacon_mac_found]}\"\n\t\t\t\t\t[ \"${advertisement_interval_observation[$beacon_uuid_found]:--1}\" -ge \"${advertisement_interval_observation[$beacon_mac_found]:--1}\" ] && observed_max_advertisement_interval=\"${advertisement_interval_observation[$beacon_uuid_found]}\"\n\n\t\t\t\t\t#CALCUALTE DIFFERENCE FOR CONFIDENCE FINDING\n\t\t\t\t\tdifference=$((timestamp - most_recent_beacon))\n\n\t\t\t\telse\n\n\t\t\t\t\t#DETERMINE DIFFERENCE\n\t\t\t\t\tdifference=$((timestamp - last_seen))\n\n\t\t\t\t\t#CONTINUE IF DEVICE HAS NOT BEEN SEEN OR DATE IS CORRUPT\n\t\t\t\t\t[ -z \"$last_seen\" ] && continue \n\t\t\t\tfi \n\n\t\t\t\t#FIND THE EXPIRATION INTERVAL FOR THIS PARTICULAR BEACON\n\t\t\t\tbeacon_specific_expiration_interval=\"${advertisement_interval_observation[$key]}\"\n\n\t\t\t\t#ADJUST TO BUFFER BASED ON USER PREFERENCES\n\t\t\t\tbeacon_specific_expiration_interval=$(( beacon_specific_expiration_interval * PREF_DEPART_SCAN_ATTEMPTS ))\n\n\t\t\t\t#SET EXPIRATION \n\t\t\t\tbeacon_specific_expiration_interval=$(( beacon_specific_expiration_interval > 45 && beacon_specific_expiration_interval  < PREF_BEACON_EXPIRATION ? beacon_specific_expiration_interval : PREF_BEACON_EXPIRATION ))\n\n\t\t\t\t#TIMEOUT AFTER [XXX] SECONDS; ALL BEACONS HONOR THE SAME EXPRIATION THRESHOLD INCLUDING IBEACONS\n\t\t\t\tif [ \"$difference\" -gt \"$beacon_specific_expiration_interval\" ]; then \n\t\t\t\t\t#REMOVE FROM EXPIRING DEVICE LOG\n\t\t\t\t\t[ -n \"${expiring_device_log[$key]}\" ] && unset \"expiring_device_log[$key]\"\n\n\t\t\t\t\t#IS BEACON?\n\t\t\t\t\tif [ \"$is_apple_beacon\" == true ] && [ \"$PREF_BEACON_MODE\" == true ]; then \n\n\t\t\t\t\t\t#REMOVE FROM LOGS\n\t\t\t\t\t\tunset \"rssi_log[$beacon_uuid_found]\"\n\n\t\t\t\t\t\t#REMOVE MAC FROM PUBLIC LOG\n\t\t\t\t\t\tunset \"public_device_log[$beacon_mac_found]\"\n\t\t\t\t\t\tunset \"rssi_log[$beacon_mac_found]\"\n\n\t\t\t\t\t\t#REMOVE BEACON FROM MAC ADDRESS ARRAY\n\t\t\t\t\t\tunset \"beacon_mac_address_log[$beacon_uuid_found]\"\n\n\t\t\t\t\t\t#REMOVE FROM BEACON ASSOCIATION\n\t\t\t\t\t\tunset \"advertisement_interval_observation[$beacon_uuid_found]\"\n\t\t\t\t\t\tunset \"advertisement_interval_observation[$beacon_mac_found]\"\n\t\t\t\t\t\t\n\t\t\t\t\t\t#PUBLISH EXPIRATION\n\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$beacon_uuid_found]}\" ] && log \"${BLUE}[DEL-BEAC]\t${NC}BEAC $beacon_uuid_found expired after $difference seconds ${NC}\"\n\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$beacon_mac_found]}\" ] && log \"${BLUE}[DEL-PUBL]\t${NC}BEAC $beacon_mac_found expired after $difference seconds ${NC}\"\n\n\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$beacon_uuid_found]}\" ] && publish_presence_message \"id=$beacon_uuid_found\" \"confidence=0\" \"last_seen=$most_recent_beacon\"\n\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$beacon_mac_found]}\" ] && publish_presence_message \"id=$beacon_mac_found\" \"confidence=0\" \"last_seen=$most_recent_beacon\"\n\t\t\t\t\t\n\t\t\t\t\telse \n\n\t\t\t\t\t\tunset \"public_device_log[$key]\"\n\t\t\t\t\t\tunset \"rssi_log[$key]\"\n\n\t\t\t\t\t\t##REMOVE FROM BEACON ASSOCIATION\n\t\t\t\t\t\tunset \"advertisement_interval_observation[$key]\"\n\n\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$key]}\" ] && log \"${BLUE}[DEL-PUBL]\t${NC}PUBL $key expired after $difference seconds ${NC}\"\n\t\t\t\t\t\t\n\t\t\t\t\t\t#REPORT PRESENCE OF DEVICE\n\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$key]}\" ] && publish_presence_message \"id=$key\" \"confidence=0\" \"last_seen=$last_seen\"\n\t\t\t\t\n\t\t\t\t\tfi\n\n\t\t\t\telif [ \"${observed_max_advertisement_interval:-0}\" -gt \"0\" ] && [ \"$difference\" -gt \"$(( (beacon_specific_expiration_interval - observed_max_advertisement_interval)  / 2 + observed_max_advertisement_interval))\" ]; then\n\n\t\t\t\t\t#SHOULD REPORT A DROP IN CONFIDENCE? \n\t\t\t\t\tpercent_confidence=$(( 100 - (difference - observed_max_advertisement_interval) * 100 / (PREF_BEACON_EXPIRATION - observed_max_advertisement_interval) )) \n\t\t\t\t\t[ \"$percent_confidence\" -lt \"5\" ] && percent_confidence=0\n\n\n\t\t\t\t\tif [ \"$PREF_REPORT_ALL_MODE\" == true ]; then\t\t\t\t\t\t\n\t\t\t\t\t\t#REPORTING ALL \t\n\t\t\t\t\t\tif [ \"$is_apple_beacon\" == true ] && [ \"$PREF_BEACON_MODE\" == true ]; then \n\t\t\t\t\t\t\t#DEBUG LOGGING\n\t\t\t\t\t\t\t[ -z \"${blacklisted_devices[$beacon_uuid_found]}\" ] && publish_presence_message \"id=$beacon_uuid_found\" \"confidence=$percent_confidence\" \"mac=$key\" \"last_seen=$most_recent_beacon\" && expiring_device_log[$beacon_uuid_found]='true'\n\t\t\t\t\t\t\t[ -z \"${blacklisted_devices[$beacon_mac_found]}\" ] && publish_presence_message \"id=$beacon_mac_found\" \"confidence=$percent_confidence\" \"last_seen=$most_recent_beacon\" && expiring_device_log[$beacon_mac_found]='true'\n\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$key]}\" ] && publish_presence_message \"id=$key\" \"confidence=$percent_confidence\" \"last_seen=$last_seen\" && expiring_device_log[$key]='true'\n\t\t\t\t\t\tfi \n\t\t\t\t\telse \n\t\t\t\t\t\t#REPORT PRESENCE OF DEVICE ONLY IF IT IS ABOUT TO BE AWAY; ALSO DO NOT REPORT DEVICES THAT WE'VE ALREADY REPORTEDI IN THIS LOOP\n\t\t\t\t\t\tif [ \"$is_apple_beacon\" == true ]; then \t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t#IF NOT SEEN AND BELOW THRESHOLD\n\t\t\t\t\t\t\tif ! [[ $notification_sent  =~ $key ]] && [ \"$percent_confidence\" -lt \"$PREF_PERCENT_CONFIDENCE_REPORT_THRESHOLD\" ]; then \n\t\t\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$beacon_uuid_found]}\" ] && publish_presence_message \"id=$beacon_uuid_found\" \"confidence=$percent_confidence\" \"mac=$beacon_mac_found\" \"last_seen=$most_recent_beacon\" && expiring_device_log[$beacon_uuid_found]='true' && notification_sent=\"$notification_sent $beacon_uuid_found\"\n\t\t\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$beacon_mac_found]}\" ] && publish_presence_message \"id=$beacon_mac_found\" \"confidence=$percent_confidence\" \"last_seen=$most_recent_beacon\" && expiring_device_log[$beacon_mac_found]='true' && notification_sent=\"$notification_sent $beacon_mac_found\"\n\t\t\t\t\t\t\tfi \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\t[ \"$PREF_BEACON_MODE\" == true ] && [ -z \"${blacklisted_devices[$key]}\" ] && [ \"$percent_confidence\" -lt \"$PREF_PERCENT_CONFIDENCE_REPORT_THRESHOLD\" ] && publish_presence_message \"id=$key\" \"confidence=$percent_confidence\" \"last_seen=$last_seen\" && expiring_device_log[$key]='true' && notification_sent=\"$notification_sent $key\"\n\t\t\t\t\t\t\tnotification_sent=\"$notification_sent $key\"\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi  \n\t\t\t\tfi \n\t\t\tdone\n\n\t\t\tcontinue\n\n\t\telif [ \"$cmd\" == \"NAME\" ]; then \n\t\t\t#DATA IS DELIMITED BY VERTICAL PIPE\n\t\t\tmac=$(echo \"$data\" | awk -F \"|\" '{print $1}')\n\t\t\tname=$(echo \"$data\" | awk -F \"|\" '{print $2}')\n\t\t\trssi_latest=\"${rssi_log[$mac]}\"\n\n\t\t\t#PREVIOUS STATE; SET DEFAULT TO UNKNOWN\n\t\t\tprevious_state=\"${known_public_device_log[$mac]}\"\n\t\t\tprevious_state=${previous_state:--1}\n\n\t\t\t#GET MANUFACTURER INFORMATION\n\t\t\tmanufacturer=\"$(determine_manufacturer \"$mac\")\"\n\n\t\t\t#IF NAME IS DISCOVERED, PRESUME HOME\n\t\t\tif [ -n \"$name\" ]; then \n\t\t\t\tknown_public_device_log[$mac]=1\n\t\t\t\t[ \"$previous_state\" != \"1\" ] && did_change=true\n\t\t\telse\n\t\t\t\tknown_public_device_log[$mac]=0\n\t\t\t\t[ \"$previous_state\" != \"0\" ] && did_change=true\n\t\t\tfi \n\t\tfi \n\n\t\t#NEED TO VERIFY WHETHER WE HAVE TO UPDATE INFORMATION FOR A PRIVATE BEACON THAT IS \n\t\t#ACTUALLY PUBLIC\n\n\t\tif [ \"$cmd\" == \"PUBL\" ]; then \n\t\t\t#PARSE RECEIVED DATA\n\t\t\tmac=$(echo \"$data\" | awk -F \"|\" '{print $1}')\n\t\t\tpdu_header=$(echo \"$data\" | awk -F \"|\" '{print $2}')\n\t\t\tname=$(echo \"$data\" | awk -F \"|\" '{print $3}')\n\t\t\trssi=$(echo \"$data\" | awk -F \"|\" '{print $4}')\n\t\t\tadv_data=$(echo \"$data\" | awk -F \"|\" '{print $5}')\n\t\t\tmanufacturer=$(echo \"$data\" | awk -F \"|\" '{print $6}')\n\t\t\tdevice_type=$(echo \"$data\" | awk -F \"|\" '{print $7}')\n\t\t\tflags=$(echo \"$data\" | awk -F \"|\" '{print $8}')\n\t\t\toem_data=$(echo \"$data\" | awk -F \"|\" '{print $9}')\n\t\t\tinstruction_timestamp=$(echo \"$data\" | awk -F \"|\" '{print $10}')\n\t\t\tresolvable=$(echo \"$data\" | awk -F \"|\" '{print $11}')\n\t\t\thex_data=$(echo \"$data\" | awk -F \"|\" '{print $12}')\n\n\t\t\t#DEFAULT?\n\t\t\tinstruction_timestamp=${instruction_timestamp:-$timestamp}\n\t\t\tinstruction_delay=$((timestamp - instruction_timestamp))\n\n\t\t\t#RESET BEACON UUID\n\t\t\tbeacon_uuid_key=\"\"\n\n\t\t\t#SET TYPE\n\t\t\tbeacon_type=\"GENERIC_BEACON_PUBLIC\"\n\t\t\tmatching_beacon_uuid_key=\"\"\n\t\t\t\n\t\t\t#DETERMINE WHETHER THIS DEVICE IS ASSOCIATED WITH AN IBEACON\n\t\t\tcurrent_associated_beacon_mac_address=\"\"\n\t\t\tfor beacon_uuid_key in \"${!beacon_mac_address_log[@]}\"; do\n\t\t\t\tcurrent_associated_beacon_mac_address=\"${beacon_mac_address_log[$beacon_uuid_key]}\"\n\t\t\t\tif [ \"$current_associated_beacon_mac_address\" == \"$mac\" ]; then \n\t\t\t\t\tmatching_beacon_uuid_key=\"$beacon_uuid_key\"\n\t\t\t\t\tbreak\n\t\t\t\tfi \n\t\t\tdone\n\n\t\t\t#SET ADVERTISEMENT INTERVAL OBSERVATION\n\t\t\tlast_appearance=${public_device_log[$mac]:-$timestamp}\n\t\t\tif [ \"$observation_made\" == false ]; then \n\t\t\t\tobservation_made=true \n\t\t\t\ttemp_observation=\"\" && temp_observation=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\t\t\t\t[ \"$temp_observation\" -gt \"${advertisement_interval_observation[$mac]:-0}\" ] && [ \"$temp_observation\" -gt \"0\" ] && [ \"$temp_observation\" -lt \"300\" ] &&\tadvertisement_interval_observation[$mac]=$temp_observation\n\t\t\t\t\n\t\t\tfi\n\t\t\t\n\t\t\t#SET ADVERTISEMENT INTERVAL OBSERVATION\n\t\t\tif [ -n \"$matching_beacon_uuid_key\" ]; then \n\t\t\t\t#GET INTERVAL SINCE LAST SEEN\n\t\t\t\tlast_appearance=${public_device_log[$matching_beacon_uuid_key]:-$timestamp}\n\t\t\t\ttemp_observation=\"\" && temp_observation=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\t\t\t\t[ \"$temp_observation\" -gt \"${advertisement_interval_observation[$matching_beacon_uuid_key]:-0}\" ] && [ \"$temp_observation\" -gt \"0\" ] && [ \"$temp_observation\" -lt \"300\" ] &&\tadvertisement_interval_observation[$matching_beacon_uuid_key]=$temp_observation\n\t\t\tfi\n\n\t\t\t#SET NAME \n\t\t\t[ -n \"$name\" ] && known_public_device_name[$mac]=\"$name\"\n\t\t\t[ -z \"$name\" ] && name=\"$(determine_name \"$mac\")\"\n\n\t\t\t#DATA IS PUBLIC MAC Addr.; ADD TO LOG\n\t\t\t[ -z \"${public_device_log[$mac]}\" ] && is_new=true\n\n\t\t\t#HAS THIS DEVICE BEEN MARKED AS EXPIRING SOON? IF SO, SHOULD REPORT 100 AGAIN\n\t\t\t[ -n \"${expiring_device_log[$mac]}\" ] && should_update=true\n\t\t\t[ -n \"$matching_beacon_uuid_key\" ] && [ -n \"${expiring_device_log[$matching_beacon_uuid_key]}\" ] && should_update=true\n\n\t\t\t#GET LAST RSSI\n\t\t\trssi_latest=\"${rssi_log[$mac]}\" \n\t\t\t[ -z \"$rssi_latest\" ] && [ -n \"$matching_beacon_uuid_key\" ] && rssi_latest=\"${rssi_log[$matching_beacon_uuid_key]}\" \n\n\t\t\t#IF NOT IN DATABASE, BUT FOUND HERE\n\t\t\tif [ -n \"$name\" ]; then\n\n\t\t\t\t#FIND PUBLIC NAME \n\t\t\t\tknown_public_device_name[$mac]=\"$name\"\n\n\t\t\t\t#GET NAME FROM CACHE\n\t\t\t\tcached_name=$(grep \"$mac\" < \".public_name_cache\" | awk -F \"\\t\" '{print $2}')\n\n\t\t\t\t#ECHO TO CACHE IF DOES NOT EXIST\n\t\t\t\t[ -z \"$cached_name\" ] && echo \"$mac\t$name\" >> .public_name_cache\n\n\t\t\t\t#IS THIS ASSOCITED WITH A BEACON? \n\t\t\t\tif [ -n \"$matching_beacon_uuid_key\" ]; then \n\t\t\t\t\n\t\t\t\t\t#IF THIS IS AN IBEACON, WE ADD THE NAME TO THAT ARRAY TOO\n\t\t\t\t\tknown_public_device_name[$matching_beacon_uuid_key]=\"$name\"\n\n\t\t\t\t\t#GET NAME FROM CACHE\n\t\t\t\t\tcached_name=\"\"\n\t\t\t\t\tcached_name=$(grep \"$matching_beacon_uuid_key\" < \".public_name_cache\" | awk -F \"\\t\" '{print $2}')\n\n\t\t\t\t\t#ECHO TO CACHE IF DOES NOT EXIST\n\t\t\t\t\t[ -z \"$cached_name\" ] && echo \"$matching_beacon_uuid_key\t$name\" >> .public_name_cache\n\t\t\t\tfi \n\t\t\tfi \n\n\t\t\t#STATIC DEVICE DATABASE AND RSSI DATABASE\n\t\t\tpublic_device_log[$mac]=\"$timestamp\"\n\t\t\t[ -n \"$rssi\" ] && rssi_log[$mac]=\"$rssi\"\n\n\t\t\t#MANUFACTURER\n\t\t\t[ -z \"$manufacturer\" ] && manufacturer=\"$(determine_manufacturer \"$mac\")\"\n\t\t\n\t\telif [ \"$cmd\" == \"BEAC\" ]; then \n\n\t\t\t#DATA IS DELIMITED BY VERTICAL PIPE\n\t\t\tuuid=$(echo \"$data\" | awk -F \"|\" '{print $1}')\n\t\t\tmajor=$(echo \"$data\" | awk -F \"|\" '{print $2}')\n\t\t\tminor=$(echo \"$data\" | awk -F \"|\" '{print $3}')\n\t\t\trssi=$(echo \"$data\" | awk -F \"|\" '{print $4}')\n\t\t\tpower=$(echo \"$data\" | awk -F \"|\" '{print $5}')\n\t\t\tmac=$(echo \"$data\" | awk -F \"|\" '{print $6}')\n\t\t\tbeacon_type=\"APPLE_IBEACON\"\n\t\t\tname=\"\"\n\n\t\t\t#FIND INSTRUCTION TIMESTAMP\n\t\t\tinstruction_timestamp=$(echo \"$data\" | awk -F \"|\" '{print $7}')\n\n\t\t\t#DEFAULT?\n\t\t\tinstruction_timestamp=${instruction_timestamp:-$timestamp}\n\t\t\tinstruction_delay=$((timestamp - instruction_timestamp))\n\n\t\t\t#GET MAC AND PDU HEADER\n\t\t\tuuid_reference=\"$uuid-$major-$minor\"\n\n\t\t\t#HAS THIS DEVICE BEEN MARKED AS EXPIRING SOON? IF SO, SHOULD REPORT 100 AGAIN\n\t\t\t[ -n \"${expiring_device_log[$uuid_reference]}\" ] && should_update=true && unset \"expiring_device_log[$uuid_reference]\"\n\n\t\t\t#UPDATE MAC ADDRESS OF BEACON \n\n\t\t\t#FIRST FIND PREVIOUS ASSOCIATION OF MAC ADDRESS TO DETERMINE \n\t\t\t#WHETHER THIS ADDRESS HAS BEEN REMOVED BY AN EXPIRATION \n\n\t\t\tif [ -n \"${beacon_mac_address_log[$uuid_reference]}\" ]; then \n\n\t\t\t\t#FIND PREVIOUS ASSOCIATION; HAS THIS BEEN REMOVED?\n\t\t\t\tprevious_association=${beacon_mac_address_log[$uuid_reference]}\n\n\t\t\t\t#IF THE ADDRESS HAS CHANGED, THEN WE NEED TO UPDATE THE ADDRESS\n\t\t\t\tif [ ! \"$previous_association\" == \"$mac\" ]; then  \n\n\t\t\t\t\t#REMOVE THIS FROM PUBLIC RECORDS\n\t\t\t\t\tunset \"public_device_log[$previous_association]\"\n\t\t\t\tfi\n\t\t\telse \n\t\t\t\t#SET THIS AS NEW\n\t\t\t\tis_new=true\n\t\t\tfi \n\n\t\t\t#SET ADVERTISEMENT INTERVAL OBSERVATION\n\t\t\tlast_appearance=${public_device_log[$mac]:-$timestamp}\n\t\t\t[ \"$observation_made\" == false ] && observation_made=true && advertisement_interval_observation[$mac]=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\n\t\t\t#GET INTERVAL SINCE LAST SEEN\n\t\t\tlast_appearance=${public_device_log[$mac]:-$timestamp}\n\t\t\tif [ \"$observation_made\" == false ]; then \n\t\t\t\tobservation_made=true\n\t\t\t\ttemp_observation=\"\" && temp_observation=$((((timestamp - last_appearance - 1 + PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) / PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP) * PREF_ADVERTISEMENT_OBSERVED_INTERVAL_STEP))\n\t\t\t\t[ \"$temp_observation\" -gt \"${advertisement_interval_observation[$mac]:-0}\" ] && [ \"$temp_observation\" -gt \"0\" ] && [ \"$temp_observation\" -lt \"300\" ] &&\tadvertisement_interval_observation[$mac]=$temp_observation\n\n\t\t\tfi\n\t\t\t\n\t\t\t#SAVE BEACON ADDRESS LOG\n\t\t\tbeacon_mac_address_log[$uuid_reference]=\"$mac\"\n\n\t\t\t#FIND NAME OF BEACON\n\t\t\t[ -z \"$name\" ] && name=\"$(determine_name \"$mac\")\"\n\n\t\t\t#GET LAST RSSI\n\t\t\trssi_latest=\"${rssi_log[$uuid_reference]}\" \n\t\t\t[ -z \"$rssi_latest\" ] && rssi_latest=\"${rssi_log[$mac]}\" \n\n\t\t\t#IS THIS A NEW DEVICE? \n\t\t\t[ -z \"${public_device_log[$uuid_reference]}\" ] && is_new=true\n\n\t\t\t#RECORD BASED ON UUID AND MAC ADDRESS\n\t\t\tpublic_device_log[$uuid_reference]=\"$timestamp\"\t\n\n\t\t\t#RSSI LOGS\n\t\t\t[ -n \"$rssi\" ] && rssi_log[$uuid_reference]=\"$rssi\"\n\t\tfi\n\n\t\t#**********************************************************************\n\t\t#\n\t\t#\n\t\t#\tTHE FOLLOWING REPORTS RSSI CHANGES FOR PUBLIC OR RANDOM DEVICES \n\t\t#\t\n\t\t#\n\t\t#**********************************************************************\n\n\t\t#REPORT RSSI CHANGES\n\t\tif [ -n \"$rssi\" ] && [ \"${#rssi}\" -lt \"5\" ] && [ \"$uptime\" -gt \"$PREF_STARTUP_SETTLE_TIME\" ]; then \n\n\t\t\t#ONLY FOR PUBLIC OR BEAON DEVICES\n\t\t\tif [ \"$cmd\" == \"PUBL\" ] || [ \"$cmd\" == \"BEAC\" ]; then \n\n\t\t\t\t#SET RSSI LATEST IF NOT ALREADY SET \n\t\t\t\trssi_latest=${rssi_latest:--200}\n\n\t\t\t\t#IS RSSI THE SAME? \n\t\t\t\trssi_change=$((rssi - rssi_latest))\n\t\t\t\tabs_rssi_change=${rssi_change#-}\n\n\t\t\t\t#DETERMINE MOTION DIRECTION\n\t\t\t\tmotion_direction=\"depart\"\n\t\t\t\t[ \"$rssi_change\" == \"$abs_rssi_change\" ] && motion_direction=\"approach\"\n\n\t\t\t\t#IF POSITIVE, APPROACHING IF NEGATIVE DEPARTING\n\t\t\t\tcase \"1\" in\n\t\t\t\t\t$(( abs_rssi_change >= 50)) )\n\t\t\t\t\t\tchange_type=\"fast $motion_direction\"\n\t\t\t\t\t\t;;\n\t\t\t\t\t$(( abs_rssi_change >= 30)) )\n\t\t\t\t\t\tchange_type=\"moderate $motion_direction\"\n\t\t\t\t\t\t;;\n\t\t\t\t\t$(( abs_rssi_change >= 10)) )\n\t\t\t\t\t\tchange_type=\"slow movement $motion_direction\"\n\t\t\t\t\t\t;;\n\t\t\t\t\t$(( abs_rssi_change >= 3)) )\n\t\t\t\t\t\tchange_type=\"drifting\"\n\t\t\t\t\t\t;;\t\t\t\n\t\t\t\t\t*)\n\t\t\t\t\t\tchange_type=\"stationary\"\n\t\t\t\t\t\t;;\t\n\t\t\t\tesac\n\n\t\t\t\t#WITHOUT ANY DATA OR INFORMATION, MAKE SURE TO REPORT\n\t\t\t\t[ \"$rssi_latest\" == \"-200\" ] && change_type=\"initial reading\" && should_update=true\n\n\t\t\t\t#ONLY PRINT IF WE HAVE A CHANCE OF A CERTAIN MAGNITUDE\n\t\t\t\t[ -z \"${blacklisted_devices[$mac]}\" ] && [ \"$abs_rssi_change\" -gt \"$PREF_RSSI_CHANGE_THRESHOLD\" ] && log \"${CYAN}[CMD-RSSI]\t${NC}$cmd $mac ${GREEN}${NC}RSSI: ${rssi:-100} dBm ($change_type | $abs_rssi_change dBm) ${NC}\" && should_update=true\n\t\t\tfi\n\t\tfi \n\n\t\t#**********************************************************************\n\t\t#\n\t\t#\n\t\t#\tTHE FOLLOWING CONDITIONS DEFINE BEHAVIOR WHEN A DEVICE ARRIVES\n\t\t#\tOR DEPARTS\n\t\t#\t\n\t\t#\n\t\t#**********************************************************************\n\n\t\tif [ \"$cmd\" == \"NAME\" ] ; then \n\t\t\t\n\t\t\t#PRINTING FORMATING\n\t\t\tdebug_name=\"$name\"\n\t\t\texpected_name=\"$(determine_name \"$mac\")\"\n\t\t\t\n\n\t\t\tcurrent_state=\"${known_public_device_log[$mac]}\"\n\n\t\t\t#IF NAME IS NOT PREVIOUSLY SEEN, THEN WE SET THE STATIC DEVICE DATABASE NAME\n\t\t\t[ -z \"$expected_name\" ] && [ -n \"$name\" ] && known_public_device_name[$mac]=\"$name\" \n\t\t\t[ -n \"$expected_name\" ] && [ -z \"$name\" ] && name=\"$expected_name\"\n\n\t\t\t#OVERWRITE WITH EXPECTED NAME\n\t\t\t[ -n \"$expected_name\" ] && [ -n \"$name\" ] && name=\"$expected_name\"\n\n\t\t\t#FOR LOGGING; MAKE SURE THAT AN UNKNOWN NAME IS ADDED\n\t\t\tif [ -z \"$debug_name\" ]; then \n\t\t\t\t#SHOW ERROR\n\t\t\t\tdebug_name=\"Unknown Name\"\n\t\t\t\t\n\t\t\t\t#CHECK FOR KNOWN NAME\n\t\t\t\t[ -n \"$expected_name\" ] && debug_name=\"$expected_name\"\n\t\t\tfi \n\n\t\t\t#IF WE HAVE DEPARTED OR ARRIVED; MAKE A NOTE UNLESS WE ARE ALSO IN THE TRIGGER MODE\n\t\t\t[ \"$did_change\" == true ] && [ \"$current_state\" == \"1\" ] && $PREF_TRIGGER_MODE_REPORT_OUT && publish_cooperative_scan_message \"arrive\"\n\n\t\t\t#PRINT RAW COMMAND; DEBUGGING\n\t\t\tlog \"${CYAN}[CMD-$cmd]\t${NC}$mac ${GREEN}$debug_name ${NC} $manufacturer${NC}\"\n\t\t\n\t\telif [ \"$cmd\" == \"BEAC\" ] && [ \"$PREF_BEACON_MODE\" == true ] && ([ \"$should_update\" == true ] || [ \"$is_new\" == true ]); then \n\t\t\n\t\t\t#PROVIDE USEFUL LOGGING\n\t\t\tif [ -z \"${blacklisted_devices[$uuid_reference]}\" ] && [ -z \"${blacklisted_devices[$mac]}\" ]; then \n\n\t\t\t\t#REMOVE \n\t\t\t\t[ -n \"${expiring_device_log[$uuid_reference]}\" ] && unset \"expiring_device_log[$uuid_reference]\"\n\t\t\t\t[ -n \"${expiring_device_log[$mac]}\" ] && unset \"expiring_device_log[$mac]\"\n\n\t\t\t\t#LOG\n\t\t\t\tlog \"${GREEN}[CMD-$cmd]\t${NC}$mac ${GREEN}$uuid $major $minor ${NC}$name${NC}\"\n\t\t\t\t\n\t\t\t\tpublish_presence_message  \\\n\t\t\t\t\"id=$uuid_reference\" \\\n\t\t\t\t\"confidence=100\" \\\n\t\t\t\t\"name=$name\" \\\n\t\t\t\t\"type=$beacon_type\" \\\n\t\t\t\t\"rssi=$rssi\" \\\n\t\t\t\t\"mac=$mac\" \\\n\t\t\t\t\"report_delay=$instruction_delay\" \\\n\t\t\t\t\"observed_interval=${advertisement_interval_observation[$mac]:--1}\" \\\n\t\t\t\t\"power=$power\" \\\n\t\t\t\t\"movement=$change_type\"\n\n\t\t\t\t#LOG\n\t\t\t\tlog \"${PURPLE}[CMD-PUBL]${NC}\t$mac ${GREEN}$name${NC} ${BLUE}$manufacturer${NC} $rssi dBm\"\n\t\t\t\t\n\t\t\t\tpublish_presence_message \\\n\t\t\t\t\"id=$mac\" \\\n\t\t\t\t\"confidence=100\" \\\n\t\t\t\t\"name=$name\" \\\n\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\"type=GENERIC_BEACON_PUBLIC\" \\\n\t\t\t\t\"report_delay=$instruction_delay\" \\\n\t\t\t\t\"observed_interval=${advertisement_interval_observation[$mac]:--1}\" \\\n\t\t\t\t\"rssi=$rssi\" \\\n\t\t\t\t\"flags=$flags\" \\\n\t\t\t\t\"movement=${change_type:-none}\"\n\t\t\tfi \n\t\t\n\t\telif [ \"$cmd\" == \"PUBL\" ] && [ \"$PREF_BEACON_MODE\" == true ] && ([ \"$should_update\" == true ] || [ \"$is_new\" == true ]); then \n\n\t\t\t#PUBLISH PRESENCE MESSAGE FOR BEACON\n\t\t\tif [ -z \"${blacklisted_devices[$mac]}\" ]; then \n\t\t\t\t[ -n \"${expiring_device_log[$mac]}\" ] && unset \"expiring_device_log[$mac]\" \n\n\t\t\t\t#FIND NAME\n\t\t\t\texpected_name=\"$(determine_name \"$mac\")\"\n\n\t\t\t\tlog \"${PURPLE}[CMD-$cmd]${NC}\t$mac ${GREEN}$name${NC} ${BLUE}$manufacturer${NC} $rssi dBm\"\n\n\t\t\t\tpublish_presence_message \\\n\t\t\t\t\"id=$mac\" \\\n\t\t\t\t\"confidence=100\" \\\n\t\t\t\t\"name=$name\" \\\n\t\t\t\t\"manufacturer=$manufacturer\" \\\n\t\t\t\t\"type=$beacon_type\" \\\n\t\t\t\t\"report_delay=$instruction_delay\" \\\n\t\t\t\t\"rssi=$rssi\" \\\n\t\t\t\t\"observed_interval=${advertisement_interval_observation[$mac]:--1}\" \\\n\t\t\t\t\"flags=${flags:-none}\" \\\n\t\t\t\t\"movement=${change_type:-none}\" \\\n\t\t\t\t\"oem_data=${oem_data:-not advertised}\" \\\n\t\t\t\t\"hex_data=${hex_data:-none}\" \\\n\t\t\t\t\"resolvable=${resolvable:-PUBLIC}\"\n\n\t\t\t\t#PERFORM SCAN HERE AS WELL\n\t\t\t\tif [ \"$is_new\" == true ]; then \n\t\t\t\t\t#REJECTION FILTER\n\t\t\t\t\tif [[ ${flags,,} =~ ${PREF_FAIL_FILTER_ADV_FLAGS_ARRIVE,,} ]] || [[ ${manufacturer,,} =~ ${PREF_FAIL_FILTER_MANUFACTURER_ARRIVE,,} ]]; then \n\n\t\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${RED}[CMD-$cmd]${NC}\t[${RED}failed filter${NC}] data: ${BLUE}${mac:-none}${NC} pdu: ${BLUE}${pdu_header:-none}${NC} rssi: ${BLUE}${rssi:-UKN} dBm${NC} flags: ${RED}${flags:-none}${NC} man: ${RED}${manufacturer:-unknown}${NC} delay: ${BLUE}${instruction_delay:-UKN}${NC}\"\n\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfi \n\n\t\t\t\t\t#FLAG AND MFCG FILTER\n\t\t\t\t\tif [[ ${flags,,} =~ ${PREF_PASS_FILTER_ADV_FLAGS_ARRIVE,,} ]] && [[ ${manufacturer,,} =~ ${PREF_PASS_FILTER_MANUFACTURER_ARRIVE,,} ]]; then \n\t\t\t\t\t\t#PROVIDE USEFUL LOGGING\n\t\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${RED}[CMD-$cmd]${NC}\t[${GREEN}passed filter${NC}] data: ${BLUE}${mac:-none}${NC} pdu: ${BLUE}${pdu_header:-none}${NC} rssi: ${BLUE}${rssi:-UKN} dBm${NC} flags: ${BLUE}${flags:-none}${NC} man: ${BLUE}${manufacturer:-unknown}${NC} delay: ${BLUE}${instruction_delay:-UKN}${NC}\"\n\n\t\t\t\t\t\t#WE ARE PERFORMING THE FIRST ARRIVAL SCAN?\n\t\t\t\t\t\tfirst_arrive_scan=false\n\n\t\t\t\t\t\t#SCAN ONLY IF WE ARE NOT IN TRIGGER MODE\n\t\t\t\t\t\tperform_arrival_scan \n\n\t\t\t\t\t\tcontinue\n\t\t\t\t\telse \n\t\t\t\t\t\t#PROVIDE USEFUL LOGGING\n\t\t\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${RED}[CMD-$cmd]${NC}\t[${RED}failed filter${NC}] data: ${BLUE}${mac:-none}${NC} pdu: ${BLUE}${pdu_header:-none}${NC} rssi: ${BLUE}${rssi:-UKN} dBm${NC} flags: ${RED}${flags:-none}${NC} man: ${RED}${manufacturer:-unknown}${NC} delay: ${BLUE}${instruction_delay:-UKN}${NC}\"\n\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfi \n\t\t\t\tfi \n\t\t\tfi \n\n\n\t\telif [ \"$cmd\" == \"RAND\" ] && [ \"$is_new\" == true ] && [ \"$PREF_TRIGGER_MODE_ARRIVE\" == false ] && [ -z \"${blacklisted_devices[$mac]}\" ]; then \n\t\t\t\n\t\t\t#REJECTION FILTER\n\t\t\tif [[ ${flags,,} =~ ${PREF_FAIL_FILTER_ADV_FLAGS_ARRIVE,,} ]] || [[ ${manufacturer,,} =~ ${PREF_FAIL_FILTER_MANUFACTURER_ARRIVE,,} ]]; then \n\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${RED}[CMD-$cmd]${NC}\t[${RED}failed filter${NC}] data: ${BLUE}${mac:-none}${NC} pdu: ${BLUE}${pdu_header:-none}${NC} rssi: ${BLUE}${rssi:-UKN} dBm${NC} flags: ${RED}${flags:-none}${NC} man: ${RED}${manufacturer:-unknown}${NC} delay: ${BLUE}${instruction_delay:-UKN}${NC}\"\n\n\t\t\t\tcontinue\n\t\t\tfi \n\n\t\t\t#FLAG AND MFCG FILTER\n\t\t\tif [[ ${flags,,} =~ ${PREF_PASS_FILTER_ADV_FLAGS_ARRIVE,,} ]] && [[ ${manufacturer,,} =~ ${PREF_PASS_FILTER_MANUFACTURER_ARRIVE,,} ]]; then \n\t\t\t\t#PROVIDE USEFUL LOGGING\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${RED}[CMD-$cmd]${NC}\t[${GREEN}passed filter${NC}] data: ${BLUE}${mac:-none}${NC} pdu: ${BLUE}${pdu_header:-none}${NC} rssi: ${BLUE}${rssi:-UKN} dBm${NC} flags: ${BLUE}${flags:-none}${NC} man: ${BLUE}${manufacturer:-unknown}${NC} delay: ${BLUE}${instruction_delay:-UKN}${NC}\"\n\n\t\t\t\t#WE ARE PERFORMING THE FIRST ARRIVAL SCAN?\n\t\t\t\tfirst_arrive_scan=false\n\n\t\t\t\t#SCAN ONLY IF WE ARE NOT IN TRIGGER MODE\n\t\t\t\tperform_arrival_scan \n\n\t\t\t\tcontinue\n\t\t\telse \n\t\t\t\t#PROVIDE USEFUL LOGGING\n\t\t\t\t$PREF_VERBOSE_LOGGING && log \"${RED}[CMD-$cmd]${NC}\t[${RED}failed filter${NC}] data: ${BLUE}${mac:-none}${NC} pdu: ${BLUE}${pdu_header:-none}${NC} rssi: ${BLUE}${rssi:-UKN} dBm${NC} flags: ${RED}${flags:-none}${NC} man: ${RED}${manufacturer:-unknown}${NC} delay: ${BLUE}${instruction_delay:-UKN}${NC}\"\n\n\t\t\t\tcontinue\n\t\t\tfi \n\t\tfi \n\n\t\t#SHOUD WE PERFORM AN ARRIVAL SCAN AFTER THIS FIRST LOOP?\n\t\tif [ \"$first_arrive_scan\" == true ] && [ \"$uptime\" -lt \"$PREF_STARTUP_SETTLE_TIME\" ] ; then \n\t\t\tperform_arrival_scan \n\t\tfi \n\n\tdone < main_pipe\n\n\t#SHOUD WE PERFORM AN ARRIVAL SCAN AFTER THIS FIRST LOOP?\n\tif [ \"$first_arrive_scan\" == true ] && [ \"$uptime\" -lt \"$PREF_STARTUP_SETTLE_TIME\" ] ; then \n\t\tperform_arrival_scan \n\tfi\ndone\n"
        },
        {
          "name": "support",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}