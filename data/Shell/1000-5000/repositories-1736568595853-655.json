{
  "metadata": {
    "timestamp": 1736568595853,
    "page": 655,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nitefood/asn",
      "stars": 1422,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.140625,
          "content": "root = true\n\n[*]\nindent_style = tab\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.927734375,
          "content": "FROM alpine:3.20.2\n\nENV IQS_TOKEN \"\"\nENV IPINFO_TOKEN \"\"\nENV CLOUDFLARE_TOKEN \"\"\n\n# - Prepare the config directory\n# - Create the entrypoint script that writes the API tokens to the config files\n# - Install prerequisite packages\nRUN mkdir -p /etc/asn && \\\n\tchown nobody:nobody /etc/asn/ && \\\n    printf '%s\\n' '#!/usr/bin/env bash' \\\n    '[[ -n \"$IQS_TOKEN\" ]] \t\t\t&& echo \"$IQS_TOKEN\" > /etc/asn/iqs_token' \\\n\t'[[ -n \"$IPINFO_TOKEN\" ]] \t\t&& echo \"$IPINFO_TOKEN\" > /etc/asn/ipinfo_token' \\\n\t'[[ -n \"$CLOUDFLARE_TOKEN\" ]] \t&& echo \"$CLOUDFLARE_TOKEN\" > /etc/asn/cloudflare_token' \\\n    'exec \"$@\"' > /entrypoint.sh && \\\n    chmod +x /entrypoint.sh && \\\n    apk update && \\\n    apk add --no-cache aha bash bind-tools coreutils curl grepcidr3 ipcalc jq mtr ncurses nmap nmap-ncat whois\n\nCOPY asn /bin/asn\nRUN chmod 0755 /bin/asn\n\n# Start the service by default\nUSER nobody\nEXPOSE 49200/tcp\nENTRYPOINT [\"/entrypoint.sh\", \"/bin/asn\"]\nCMD [\"-l\", \"0.0.0.0\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "MIT License\n\nCopyright (c) 2020 Adriano Provvisiero\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 62.4140625,
          "content": "# ASN Lookup Tool and Traceroute Server\n\n[![Packaging status](https://repology.org/badge/vertical-allrepos/asn.svg)](https://repology.org/project/asn/versions)\n\n#### Container support:\n\n[![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)](#running-the-script-from-a-container)\n[![Google Cloud](https://img.shields.io/badge/GoogleCloud-%234285F4.svg?style=for-the-badge&logo=google-cloud&logoColor=white)](#running-the-script-from-a-container)\n\n#### OS support:\n\n[![Debian](https://img.shields.io/badge/Debian-D70A53?style=for-the-badge&logo=debian&logoColor=white)](#installation)\n[![Ubuntu](https://img.shields.io/badge/Ubuntu-E95420?style=for-the-badge&logo=ubuntu&logoColor=white)](#installation)\n[![Kali](https://img.shields.io/badge/Kali-268BEE?style=for-the-badge&logo=kalilinux&logoColor=white)](#installation)\n[![Cent OS](https://img.shields.io/badge/cent%20os-002260?style=for-the-badge&logo=centos&logoColor=F0F0F0)](#installation)\n[![Red Hat](https://img.shields.io/badge/Red%20Hat-EE0000?style=for-the-badge&logo=redhat&logoColor=white)](#installation)\n[![Rocky Linux](https://img.shields.io/badge/-Rocky%20Linux-%2310B981?style=for-the-badge&logo=rockylinux&logoColor=white)](#installation)\n[![Fedora](https://img.shields.io/badge/Fedora-294172?style=for-the-badge&logo=fedora&logoColor=white)](#installation)\n[![Arch](https://img.shields.io/badge/Arch%20Linux-1793D1?logo=arch-linux&logoColor=fff&style=for-the-badge)](#installation)\n[![Manjaro](https://img.shields.io/badge/Manjaro-35BF5C?style=for-the-badge&logo=Manjaro&logoColor=white)](#installation)\n[![Alpine Linux](https://img.shields.io/badge/Alpine_Linux-%230D597F.svg?style=for-the-badge&logo=alpine-linux&logoColor=white)](#installation)\n[![openSUSE](https://img.shields.io/badge/openSUSE-73BA25?logo=opensuse&logoColor=fff&style=for-the-badge)](#installation)\n[![FreeBSD](https://img.shields.io/badge/-FreeBSD-%23870000?style=for-the-badge&logo=freebsd&logoColor=white)](#installation)\n[![Nix](https://img.shields.io/badge/NIX-5277C3.svg?style=for-the-badge&logo=NixOS&logoColor=white)](#installation)\n[![macOS](https://img.shields.io/badge/mac%20os-000000?style=for-the-badge&logo=macos&logoColor=F0F0F0)](#installation)\n[![Windows](https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white)](#installation)\n[![Raspberry Pi](https://img.shields.io/badge/-RaspberryPi-C51A4A?style=for-the-badge&logo=Raspberry-Pi)](#installation)\n\n### Table of contents:\n\n* [Description](#description)\n* [Screenshots](#screenshots)\n* [Running the script from a container](#running-the-script-from-a-container)\n* [Installation](#installation)\n  * _Optional: adding your [API tokens](#api-tokens) to improve functionalities_\n* [Usage (as a command line tool)](#usage)\n* [Usage (as a lookup & traceroute server)](#running-lookups-from-the-browser)\n* [Usage (as a lookup API with JSON output)](#json-output-and-api-mode)\n\n---\n\n## Description\n\nASN / RPKI validity / BGP stats / IPv4v6 / Prefix / ASPath / Organization / IP reputation / IP geolocation / IP fingerprinting / Network recon / lookup tool / Web traceroute server.\n\nThis script serves the purpose of having a quick OSINT **command line tool** at disposal when investigating network data, which can come in handy in incident response scenarios as well (with features such as [bulk geolocation](#bulk-geolocation-mode) and threat scoring).\n\nIt can be used as a **recon tool** by querying Shodan for data about any type of target (CIDR blocks/URLs/single IPs/hostnames). This will quickly give the user a complete breakdown about open ports, known vulnerabilities, known software and hardware running on the target, and more - without ever sending a single packet to the target.\nJSON output of the results, multiple simultaneous targets and IP list file inputs and are also supported. Click [here](#shodan-scanning-recon-mode) for more information about Shodan scanning mode.\n\nIt can also be used as a **web-based traceroute server**, by running it in listening mode and launching lookups and traces from a local or remote browser (via a bookmarklet or custom search engine) or terminal (via `curl`, `elinks` or similar tools). Click [here](#running-lookups-from-the-browser) for more information about server mode functionality.\n\nFurthermore, it can serve as a self-hosted lookup **API endpoint** and output JSON-formatted data while running in both interactive and server mode. Click [here](#json-output-and-api-mode) for more information about API mode functionality.\n\n#### Features:\n\n* It will lookup relevant Autonomous System information for any given AS number, including:\n\n  * **Organization name and RIR region**\n  * **IXP Presence** (*Internet Exchange facilities where the AS is present*)\n  * **Global AS rank** (*derived from the size of its customer cone, number of peering relationships and more*)\n  * **BGP statistics** (*neighbours count, originated v4/v6 prefix count*)\n  * **BGP incident history** (number of *BGP hijacks* and *route leaks* involving the target AS in the past 12 months, as a **victim** or a **hijacker**)\n  * **Peering relationships** separated by type (*upstream/downstream/uncertain*), and sorted by observed *path count*, to give more reliable results (so for instance, the first few upstream peers are most likely to be transits). Furthermore, a recap of *transits/peers/customers* amount (per latest CAIDA data) is displayed.\n  * **Announced prefixes** aggregated to the most relevant less-specific `INET(6)NUM` object (actual [LIR allocation](https://www.ripe.net/manage-ips-and-asns/db/support/documentation/ripe-database-documentation/rpsl-object-types/4-2-descriptions-of-primary-objects/4-2-4-description-of-the-inetnum-object)).\n\n* It will perform an **AS path trace** (using [mtr](https://github.com/traviscross/mtr) and retrieving AS data from the results) for single IPs or DNS results, optionally reporting detailed data for each hop, such as RPKI ROA validity, organization/network name, geographic location, etc.\n\n* It will detect **IXPs** (Internet Exchange Points) traversed during the trace, and highlight them for clarity.\n\n* It will attempt to lookup all relevant **abuse contacts** for any given IP or prefix.\n\n* It will perform **RPKI validity** lookups for every possible IP. Data is validated using the [RIPEStat RPKI validation API](https://stat.ripe.net/docs/data_api#rpki-validation). For path traces, the tool will match each hop's ASN/Prefix pair (retrieved from the Prefix Whois public server) with relevant published RPKI ROAs. In case of origin AS mismatch or unallowed more-specific prefixes, it will warn the user of a potential **route leak / BGP hijack** along with the offending AS in the path (requires `-d` option, see below for usage info).\n\n  * *Read more about BGP hijacking [here](https://en.wikipedia.org/wiki/BGP_hijacking).*\n  * *Read more about RPKI [here](https://en.wikipedia.org/wiki/Resource_Public_Key_Infrastructure), [here](https://blog.cloudflare.com/rpki/), or [here](https://www.ripe.net/manage-ips-and-asns/resource-management/certification).*\n\n* It will perform **IP geolocation** lookups according to the logic described [below](#geolocation).\n\n  * geolocation can be performed in **bulk mode**. See [here](#bulk-geolocation-mode) for more info.\n  * the script can also **map all IPv4/IPv6 CIDR blocks** allocated to any given country, by querying data from Marcel Bischoff's [country-ip-blocks](https://github.com/herrbischoff/country-ip-blocks) repo. See [below](#mapping-the-ipv4v6-address-space-of-specific-countries) for more info.\n\n* It will perform **IP reputation, noise classification** and in-depth **threat analysis** reporting (especially useful when investigating foreign IPs from log files).\n\n* It will perform **IP fingerprinting** using Shodan's [InternetDB API](%5Bhttps://internetdb.shodan.io/%5D(https://internetdb.shodan.io/)) and report any known **vulnerabilities**, **open ports** and **services/operating system/hardware** pertaining to target IPs and individual trace hops (detailed traces only).\n\n  * Directly querying Shodan for any type of targets (including CIDR blocks) is also possible. More information [here](#shodan-scanning-recon-mode) about how to use the script as a recon tool.\n\n* It will perform **IP type identification** (*Anycast IP/Mobile network/Proxy host/Datacenter or hosting provider/IXP prefix*) for target IPs and individual trace hops. Broad type classification comes from [ip-api](https://ip-api.com), while detailed DC+region identification comes from [incolumitas.com](https://incolumitas.com/pages/Datacenter-IP-API/)\n\n  * It will also identify **bogon** addresses being traversed and classify them according to the relevant RFC (Private address space/CGN space/Test address/link-local/reserved/etc.)\n\n* It is possible to search by **organization name** in order to retrieve a list of IPv4/6 network ranges related to a given company. A multiple choice menu will be presented if more than one organization matches the search query.\n\n* It is possible to search for **ASNs matching a given name**, in order to map the ASNs for a given organization. The list will be enriched by each result's AS rank and useful tags highlighting the highest-ranking ASNs found.\n\n* It is possible to quickly identify the **transit/upstream AS network(s)** for a given prefix, through analysis of observed BGP updates and ASPATHs.\n\n  * the tool will also inform the user when a prefix is likely coming from a large tier-1 or multihomed network.\n\n* Lookup data can be integrated by third party tools by choosing **JSON output** and parsing the results externally, turning the script into a lookup API endpoint.\n\nScreenshots for every lookup option are below.\n\nThe script uses the following services for data retrieval:\n\n* [Team Cymru](https://team-cymru.com/community-services/ip-asn-mapping/)\n* [The Prefix WhoIs Project](https://pwhois.org/)\n* [PeeringDB](https://www.peeringdb.com/)\n* [CAIDA ASRank](https://asrank.caida.org/)\n* [ifconfig.co](https://ifconfig.co/)\n* [ipify](https://www.ipify.org/)\n* [ipinfo.io](https://ipinfo.io)\n* [RIPEStat](https://stat.ripe.net/)\n* [RIPE IPmap](https://ipmap.ripe.net/)\n* [ip-api](https://ip-api.com/)\n* [StopForumSpam](https://www.stopforumspam.com/)\n* [IP Quality Score](https://www.ipqualityscore.com)\n* [Cloudflare Radar](https://radar.cloudflare.com/)\n* [ISC DSHIELD](https://isc.sans.edu/)\n* [GreyNoise](https://greynoise.io)\n* [Shodan](https://www.shodan.io/)\n* [NIST National Vulnerability Database](https://nvd.nist.gov/)\n* [Incolumitas.com](https://incolumitas.com/pages/Datacenter-IP-API/)\n* [RestCountries](https://restcountries.com/)\n* Marcel Bischoff's [country-ip-blocks](https://github.com/herrbischoff/country-ip-blocks) repo\n\nIt also provides hyperlinks (in [server](#running-lookups-from-the-browser) mode) to the following external services when appropriate:\n\n* [HE.net](https://bgp.he.net)\n* [BGPView](https://bgpview.io)\n* [BGPTools](https://bgp.tools)\n* [ipinfo.io](https://ipinfo.io)\n* [Host.io](https://host.io)\n* [Cloudflare Radar](https://radar.cloudflare.com/)\n\nRequires Bash v4.2+. Tested on:\n\n* Linux\n* FreeBSD\n* Windows (WSL2, Cygwin)\n* MacOS *(thanks [Antonio Prado](https://github.com/Antonio-Prado) and Alessandro Barisone)*\n\n- - -\n\n## Screenshots\n\n### Generic usage\n\n* *IPv4 lookup with IP type detection (Anycast, Hosting/DC) and classification as good*\n\n  ![ipv4lookup](https://github.com/nitefood/asn/assets/24555810/81def31a-e080-4b01-9aa2-25b979062963)\n\n* *IPv4 lookup (bad reputation IP) with threat analysis/scoring, CPE/CVE identification and open ports reporting*\n\n  ![ipv4badlookup](https://github.com/nitefood/asn/assets/24555810/302dc69f-7026-4f41-afe6-e24c4d0a514a)\n\n* *IP fingerprinting with advanced datacenter+region identification, known vulnerabilities affecting the target and honeypot identification according to Shodan data*\n\n  ![](https://user-images.githubusercontent.com/24555810/159185618-fa20f45c-91b4-45b4-ad82-02becc648fa5.png)\n\n* *IPv6 lookup*\n\n  ![ipv6lookup](https://user-images.githubusercontent.com/24555810/159185780-44a1af6e-7aa9-4f52-b04c-55a314b2a5e3.png)\n\n* *Autonomous system number lookup with AS ranking, operational region, BGP stats and incident history, peering and prefix information*\n\n  ![asnlookup](https://github.com/user-attachments/assets/9ae33fe8-6069-48e6-a4a3-ea74d2f351e1)\n\n* *Hostname/URL lookup*\n\n  ![hostnamelookup](https://github.com/nitefood/asn/assets/24555810/f6c71594-d38a-4c7c-9142-5aa1e203f3fa)\n\n### AS Path tracing\n\n* *ASPath trace to www.github.com*\n\n  ![pathtrace](https://github.com/nitefood/asn/assets/24555810/8dfa68ba-de39-47f4-96d3-618210197e70)\n\n* *ASPath trace traversing both an unannounced PNI prefix (FASTWEB->SWISSCOM at hop 11) and an IXP (SWISSCOM -> RCN through Equinix Ashburn at hop 16)*\n\n  ![pathtrace_pni_ixp](https://user-images.githubusercontent.com/24555810/100301579-b4d00c00-2f98-11eb-82c5-047c190ffcd6.png)\n\n* *Detailed ASPath trace to 8.8.8.8 traversing the Milan Internet Exchange (MIX) IXP peering LAN at hop 6*\n\n  ![detailed_pathtrace](https://user-images.githubusercontent.com/24555810/117335188-28a50780-ae9b-11eb-98d9-cfd3bc2f1295.png)\n\n### Network search by organization\n\n* *Organization search for \"github\"*\n\n  ![search_by_org](https://user-images.githubusercontent.com/24555810/99845076-5b20a980-2b74-11eb-9312-986867034cc9.png)\n\n### Shodan scanning\n\n* *Scanning for Shodan information for a list of IPs*\n\n  ![shodanscan](https://github.com/nitefood/asn/assets/24555810/550d3004-9cbc-404e-b74c-9248a2d0bb0f)\n\n### Country IPv4/IPv6 CIDR mapping\n\n* *Displaying a list of  CIDR blocks allocated to Jamaica*\n\n  ![country_cidr](https://user-images.githubusercontent.com/24555810/163061676-bae440c6-ff0d-478e-8799-98a927600964.png)\n\n### Bulk Geolocation / country stats\n\n* *Performing bulk extraction, geolocation and stats for IPs from a logfile*\n\n  ![bulk_geolocation](https://user-images.githubusercontent.com/24555810/162656545-11db3759-6741-44e0-bcfb-f3542482415f.png)\n\n### Suggested ASNs search\n\n* *Suggested ASNs (and respective AS rankings) for \"google\"*\n\n  ![asnsuggest](https://github.com/nitefood/asn/assets/24555810/c8bd8cab-9894-4886-94b5-bfd6bb0b9d8e)\n\n### Transit/Upstream lookup\n\n* *A large tier-1 network (**COMCAST**, AS7922) prefix is reachable through multiple other tier-1 networks like **COGENT** (AS174), **LEVEL3** (AS3356) etc. - likely through settlement-free peering rather than BGP transit:*\n\n  ![upstreamfinder_tier1_network](https://github.com/nitefood/asn/assets/24555810/4a6a00d9-7a8c-4765-a4d6-ea99aa516200)\n\n* *Transit identification for a multihomed AS (**AS30036** announces this prefix to **Hurricane** and **GTT** in a balanced way):*\n\n  ![upstreamfinder_multihoming](https://github.com/nitefood/asn/assets/24555810/6c036a97-83f8-4c37-9ebd-2717c2d53507)\n\n* *Preferred transit identification - **Chinese UNICOM AS** is a large network, but likely prefers Russian **TRANSTELECOM** (AS20485) transit over **TELIA** (AS1299), **HURRICANE** (AS6939), **GTT** (AS3257) and others:*\n\n  ![upstreamfinder_preferred_transit](https://github.com/nitefood/asn/assets/24555810/dbb64ecc-394a-4fbd-8607-5b7f6955b340)\n\n\n- - -\n\n## Running the script from a container\n\nTo run the script without installing it locally, you have the following options:\n\n* **Docker** _(thanks [Gianni Stubbe](https://github.com/33Fraise33), [anarcat](https://github.com/anarcat), [Francesco Colista](https://github.com/fcolista), [arbal](https://github.com/arbal))_\n\n  _Note: the Docker image runs by default in server mode, if no parameters are given. This is equivalent to running the tool as `asn -l 0.0.0.0` (run server, bind to all IPv4 interfaces - this is necessary to expose the server port to the host machine). You can run the server with different [options](#syntax) by explicitly passing `-l [options]`. It's also possible to pass an [IpQualityScore](#ip-reputation-api-token-ipqualityscore), [ipinfo.io](#geolocation-api-token-ipinfoio) and/or [Cloudflare](#bgp-hijack-and-route-leak-incidents-cloudflare-radar) API token (both client and server runs) by setting, respectively, the `IQS_TOKEN`, `IPINFO_TOKEN` and `CLOUDFLARE_TOKEN` environment variables (examples below) in the container._\n\n  Usage examples:\n  - Start server: `docker run -it -p 49200:49200 nitefood/asn`\n  - Client mode: `docker run -it nitefood/asn 1.1.1.1`\n  - Supply an IQS token: `docker run -it -e IQS_TOKEN=\"xxx\" nitefood/asn [...]`\n  - Supply multiple tokens: `docker run -it -e IQS_TOKEN=\"xxx\" -e IPINFO_TOKEN=\"yyy\" -e CLOUDFLARE_TOKEN=\"zzz\" nitefood/asn [...]`\n\n* **Google Cloud Shell**\n\n  _Note: server mode **is supported** out of the box in Cloud Shell, just follow the **bookmarklet** link that will be shown at server launch to access the VM for remote lookups._\n\n  **1.** Clone the repository in Cloud Shell by clicking the following button:\n\n  [![Open in Cloud Shell](https://gstatic.com/cloudssh/images/open-btn.svg)](https://shell.cloud.google.com/cloudshell/editor?cloudshell_git_repo=https://github.com/nitefood/asn&ephemeral=true&show=terminal)\n\n  **2.** Prepare the GCP environment by launching `./cloudshell_bootstrap.sh`\n\n  **3.** _(OPTIONAL)_ Input your [API tokens](#api-tokens) when requested to enable full script features\n\n- - -\n\n## Installation\n\nThis script requires **BASH v4.2** or later. You can check your version by running from your shell:\n\n```\nbash -c 'echo $BASH_VERSION'\n```\n\nAfter installation, you can use the script by running the `asn` command.\n\n### Method 1: Install prerequisites + manual download\n\n> *Note: this method is **recommended** as it will always get you the **latest version** of the script.*\n\n<details><summary><b>STEP 1. Install prerequisite packages</b></summary><p>\n\nSome packages are required for full functionality:\n\n* **Debian 10 / Ubuntu 20.04 (or newer):**\n\n  ```\n  apt -y install curl whois bind9-host mtr-tiny jq ipcalc grepcidr nmap ncat aha\n  ```\n\n* **Debian 9 / Ubuntu 18.04 (or older):**\n\n  ```\n  apt -y install curl whois bind9-host mtr-tiny jq ipcalc grepcidr nmap git gcc make && \\\n  git clone https://github.com/theZiz/aha.git && \\\n  make install -C aha/\n  ```\n\n* **CentOS / RHEL / Rocky Linux 9:**\n\n  ```\n  dnf -y install epel-release && \\\n  dnf -y install curl whois bind-utils mtr jq nmap nmap-ncat ipcalc aha grepcidr\n  ```\n\n* **CentOS / RHEL / Rocky Linux 8:** *(thanks [Robert Scheck](https://github.com/robert-scheck))*\n\n  ```\n  dnf -y install epel-release 'dnf-command(copr)' && \\\n  dnf -y copr enable robert/ipcalc && \\\n  dnf -y install curl whois bind-utils mtr jq nmap nmap-ncat ipcalc aha grepcidr\n  ```\n\n* **CentOS / RHEL 7:** *(thanks [Robert Scheck](https://github.com/robert-scheck))*\n\n  ```\n  yum -y install epel-release yum-plugin-copr && \\\n  yum -y copr enable robert/ipcalc && \\\n  yum -y install curl whois bind-utils mtr jq nmap nmap-ncat ipcalc aha grepcidr && \\\n  hash -d ipcalc\n  ```\n\n* **Fedora:**\n\n  ```\n  dnf -y install curl whois bind-utils mtr jq nmap nmap-ncat ipcalc aha grepcidr\n  ```\n\n* **openSUSE Leap 15.5 (or newer), openSUSE Tumbleweed**\n\n  ```\n  zypper in -y curl whois bind-utils mtr jq nmap ncat ipcalc aha grepcidr\n  ```\n\n* **FreeBSD**:\n\n  ```\n  env ASSUME_ALWAYS_YES=YES pkg install bash coreutils curl whois mtr jq ipcalc grepcidr nmap aha\n  ```\n\n* **Windows**:\n\n  * **using [WSL2](https://docs.microsoft.com/en-us/windows/wsl/about) (recommended):**\n    Install Windows Subsystem for Linux (v2) by following Microsoft's [guide](https://docs.microsoft.com/en-us/windows/wsl/install-win10#manual-installation-steps). On step 6, choose one of the Linux distributions listed above (Ubuntu 20.04 LTS is recommended).\n    Once your WSL2 system is up and running, open a Linux terminal and follow the prerequisite installation instructions above for your distribution of choice.\n\n    > *Note for WSL2 users: Check [this](https://devblogs.microsoft.com/commandline/systemd-support-is-now-available-in-wsl/) page for details on how to activate **systemd** if you plan to install the [asn service](#optional-installing-the-asn-server-as-a-system-service).*\n\n  * **using [Cygwin](https://cygwin.com/index.html):**\n    Most of the prerequisite packages listed above for *Debian 10 / Ubuntu 20.04 (or newer)* are obtainable directly with Cygwin's own Setup wizard (or through scripts like *apt-cyg*). You will still have to manually compile (or find a suitable third-party precompiled binary) the *mtr*, *grepcidr* and *aha* tools. Instructions on how to do so can be found directly on the respective projects homepages.\n</p></details>\n\n<details><summary><b>STEP 2. Script download and installation</b></summary><p>\n\nAfterwards, to install the **asn** script from your shell to **/usr/bin**:\n\n`curl \"https://raw.githubusercontent.com/nitefood/asn/master/asn\" > /usr/bin/asn && chmod 0755 /usr/bin/asn`\n\n</p></details>\n\n### Method 2: Installing a packaged version of the script\n\n> *Note: packages may not reflect the latest version, check [Repology](https://repology.org/project/asn/versions) first.*\n\nPackaged versions of the tool are available for the following distributions:\n\n<details><summary><b>Distribution list</b></summary><p>\n\n* **Debian-based:** *(thanks [Marcos Rodrigues de Carvalho](https://github.com/odaydebian))*\n  > *Debian 13 / Sid*\\\n  > *Ubuntu 24.04 (or newer)*\\\n  > *Kali (rolling)*\\\n  > *Raspbian (testing)*\n\n  ```\n  sudo apt update && sudo apt install asn\n  ```\n* **Manjaro / Arch Linux:** *(thanks [Worty](https://github.com/worty))*\n\n  ```\n  yay -S asn-git\n  ```\n\n* **Alpine Linux 3.18 (or newer)** *(thanks [Francesco Colista](https://github.com/fcolista))*\n\n  ```\n  apk add -X https://dl-cdn.alpinelinux.org/alpine/v3.19/community asn\n  ```\n\n* **NixOS** *(thanks [devhell](https://github.com/devhell))*\n\n  * Package [here](https://github.com/NixOS/nixpkgs/tree/master/pkgs/by-name/as/asn)\n\n* **MacOS** *(using [Homebrew](https://formulae.brew.sh/formula/asn), thanks [filippovitale](https://github.com/filippovitale))*\n\n  ```\n  brew install asn\n  ```\n\n  >*Note for MacOS users:*\n  >\n  > *Homebrew has a [policy](https://github.com/Homebrew/homebrew-core/issues/35085#issuecomment-447184214) not to install any binary with the **setuid** bit, and mtr (or actually, the mtr-packet helper binary that comes with it) requires to elevate to root to perform traces (good explanations for this can be found [here](https://github.com/traviscross/mtr/issues/204#issuecomment-723961118) and [here](https://github.com/traviscross/mtr/blob/master/SECURITY)). If mtr (and therefore `asn`) traces are not working on your system, you should either run `asn` as root using **sudo**, or set the proper SUID permission bit on the mtr (or better, on the mtr-packet) binary.*\n\n</p></details>\n\n### *(Optional)* Installing the *asn server* as a system service\n\n>*Note: this step is optional, and these instructions are only for **systemd**-based Linux systems (most current major distributions).*\n\nTo control the **asn server** with utilities like *systemctl* and *service*, and to enable it to automatically start at boot, follow these steps:\n\n1. create a new file called `/etc/systemd/system/asn.service` with the following content (make sure you edit the *ExecStart* line to match your installation path and desired startup options):\n\n```\n[Unit]\nDescription=ASN lookup and traceroute server\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always\nRestartSec=1\nUser=nobody\nExecStart=/usr/bin/asn -l 0.0.0.0\n\n[Install]\nWantedBy=multi-user.target\n```\n\n2. Enable the *CAP\\_NET\\_RAW* capability for the mtr-packet binary:\n   `setcap cap_net_raw+ep $(which mtr-packet)`\n   *Explanation: this will allow mtr-packet to create raw sockets (and thus perform traces) when launched as an unprivileged user (we're setting up the service to run as user nobody for added security), without the requirement of the setuid-root bit and without having to invoke mtr as root. A thorough explanation for this can be found [here](https://github.com/traviscross/mtr/blob/master/SECURITY).*\n3. Now you can refer to standard systemd utilities to perform service operations:\n   * To start the service: `systemctl start asn`\n   * To stop the service: `systemctl stop asn`\n   * To check its status and latest logs: `systemctl status asn`\n   * To follow its logging in real time: `journalctl -f -u asn`\n   * To start the service automatically on boot: `systemctl enable asn`\n   * To disable automatic start on boot: `systemctl disable asn`\n\n## API tokens\n\nThe script can be configured to make use of your API tokens to enhance its functionalities.\n\nThe currently supported API tokens are:\n\n### Geolocation API token (ipinfo.io)\n\n<details><summary><b>Geolocation API token details</b></summary><p>\n\nThe geolocation provider of choice for single lookups (i.e. when not running bulk geolocation queries with the `-g` option) is **ipinfo.io**.\n\nBy default, the script uses the free (no API key) tier that supports up to **1,000** geolocation requests per day. In order to boost this limit (for free) to **50,000** requests per month, an API key token is required.\n\nIn order to obtain an API token, after [signing up](https://ipinfo.io/signup), the API token can be found in the [token section](https://ipinfo.io/account/token) of your reserved area. Once copied, the token should be written to one of the following files (parsed in that order):\n\n`$HOME/.asn/ipinfo_token` or\n`/etc/asn/ipinfo_token`\n\nThe `/etc`-based file should be used when running asn in **server mode**. The `$HOME`-based file takes precedence if both files exist, and is ideal for **user mode** (that is, running `asn` interactively from the command line).\n\nIn order to do so, you can use the following command:\n\n***User mode:***\n\n`TOKEN=\"<your_token_here>\"; mkdir \"$HOME/.asn/\" && echo \"$TOKEN\" > \"$HOME/.asn/ipinfo_token\" && chmod -R 600 \"$HOME/.asn/\"`\n\n***Server mode:***\n\n`TOKEN=\"<your_token_here>\"; mkdir \"/etc/asn/\" && echo \"$TOKEN\" > \"/etc/asn/ipinfo_token\" && chmod -R 700 \"/etc/asn/\" && chown -R nobody /etc/asn/`\n\nEither way, `asn` will pick up your token on the next run (no need to restart the service if running in server mode), and use it to query the ipinfo.io API.\n\n</p></details>\n\n### IP reputation API token (IPQualityScore)\n\n<details><summary><b>IP reputation API token details</b></summary><p>\n\nThe script will perform first-level IPv4/v6 reputation lookups using [StopForumSpam](https://www.stopforumspam.com/), and in case of a match it will perform a second-level, in-depth threat analysis for targets and trace hops using the [IPQualityScore](https://www.ipqualityscore.com/) API. The StopForumSpam API is free and requires no sign-up, and the service aggregates a [huge](https://www.stopforumspam.com/contributors) amount of blacklist feeds.\n\nStill, in order to use the IPQualityScore API for in-depth threat reporting, it's necessary to [sign up](https://www.ipqualityscore.com/create-account) for their service (it's free) and get an API token (it will be emailed to you on sign-up), which will entitle you to 5000 free lookups per month.\n\nOnce obtained, the api token should be written to one of the following files (parsed in that order):\n\n`$HOME/.asn/iqs_token` or\n`/etc/asn/iqs_token`\n\nThe `/etc`-based file should be used when running asn in **server mode**. The `$HOME`-based file takes precedence if both files exist, and is ideal for **user mode** (that is, running `asn` interactively from the command line).\n\nIn order to do so, you can use the following command:\n\n***User mode:***\n\n`TOKEN=\"<your_token_here>\"; mkdir \"$HOME/.asn/\" && echo \"$TOKEN\" > \"$HOME/.asn/iqs_token\" && chmod -R 600 \"$HOME/.asn/\"`\n\n***Server mode:***\n\n`TOKEN=\"<your_token_here>\"; mkdir \"/etc/asn/\" && echo \"$TOKEN\" > \"/etc/asn/iqs_token\" && chmod -R 700 \"/etc/asn/\" && chown -R nobody /etc/asn/`\n\nEither way, `asn` will pick up your token on the next run (no need to restart the service if running in server mode), and use it to query the IPQualityScore API.\n\n> ***Note:***\n> *IPQualityScore is not queried by default for every target, but only for targets that get flagged as BAD by StopForumSpam. It's possible to override this behavior (and force IQS lookup for every target) by setting the `IQS_ALWAYS_QUERY` parameter to `true` in the [preferences file](#preferences-file-homeasnrc). It is also possible to specify [custom query settings](https://www.ipqualityscore.com/documentation/proxy-detection/overview) through the `IQS_CUSTOM_SETTINGS` parameter.*\n\n</p></details>\n\n### BGP hijack and route leak incidents (Cloudflare Radar)\n\n<details><summary><b>Cloudflare token details</b></summary><p>\n\nWhen this token is available, an additional lookup will be enabled for **autonomous system** targets, in order to enumerate the BGP incidents (both **BGP hijacks** and **BGP route leaks**) involving the target ASN.\n\nThe script will use the [Cloudfare Radar](https://radar.cloudflare.com/) API to retrieve the amount of incidents involving the target ASN in the past 12 months. Additionally, it will report how many incidents saw the target ASN as a **hijacker** or as a **victim**.\n\nThe Cloudflare Radar API is **free** to use, but requires a registration. The steps are:\n\n1. [Sign up](https://dash.cloudflare.com/sign-up) for a free Cloudflare account and **validate your email**\n2. From the [Cloudflare dashboard](https://dash.cloudflare.com/profile/api-tokens/), go to **My Profile > API Tokens**.\n3. Select **Create Token**\n4. Choose the \"*Read Cloudflare Radar data*\" template\n5. Click **Continue to summary** (the default values are fine)\n6. Click **Create token**\n\nOnce obtained, the api token should be written to one of the following files (parsed in that order):\n\n`$HOME/.asn/cloudflare_token` or\n`/etc/asn/cloudflare_token`\n\nThe `/etc`-based file should be used when running asn in **server mode**. The `$HOME`-based file takes precedence if both files exist, and is ideal for **user mode** (that is, running `asn` interactively from the command line).\n\nIn order to do so, you can use the following command:\n\n***User mode:***\n\n`TOKEN=\"<your_token_here>\"; mkdir \"$HOME/.asn/\" && echo \"$TOKEN\" > \"$HOME/.asn/cloudflare_token\" && chmod -R 600 \"$HOME/.asn/\"`\n\n***Server mode:***\n\n`TOKEN=\"<your_token_here>\"; mkdir \"/etc/asn/\" && echo \"$TOKEN\" > \"/etc/asn/cloudflare_token\" && chmod -R 700 \"/etc/asn/\" && chown -R nobody /etc/asn/`\n\nEither way, `asn` will pick up your token on the next run (no need to restart the service if running in server mode), and use it to query the Cloudflare Radar API.\n\n</p></details>\n\n- - -\n\n## Usage\n\n##### *Syntax*\n\n`asn [OPTIONS] [TARGET]`\n\n`asn [-v] -l [SERVER OPTIONS]`\n\nwhere `TARGET` can be one of the following:\n\n* **AS number** \\-\\- lookup matching ASN and BGP announcements/neighbours data\\. Supports \"as123\" and \"123\" formats \\(case insensitive\\)\n* **IPv4/IPv6/Prefix** \\-\\- lookup matching route\\(4/6), IP reputation and ASN data\n* **Hostname** \\-\\- resolve the host and lookup data \\(same as IPv4/IPv6 lookup\\. Supports multiple IPs \\- e\\.g\\. DNS RR\\)\n* **URL** \\-\\- extract hostname/IP from the URL and lookup relative data\\. Supports any protocol prefix\\, non\\-standard ports and [prepended credentials](https://en.wikipedia.org/wiki/Basic_access_authentication#URL_encoding)\n* **Organization name** \\-\\- search by company name and lookup network ranges exported by \\(or related to\\) the company\n\n<u>Options</u>:\n\n* `-t`\n\n  * enables lookup and path tracing for targets **(this is the default behavior)**\n\n    >*.asnrc option equivalent: `MTR_TRACING=true` (default: `true`)*\n\n* `-d`\n\n  * enables detailed trace mode (more info below)\n\n    >*.asnrc option equivalent: `DETAILED_TRACE=true` (default: `false`)*\n\n* `-n`\n\n  * disables path tracing and only outputs lookup info _(for IP targets)_\n  * disables additional INETNUM/origin lookups _(for AS targets)_\n\n    >*.asnrc option equivalent: `MTR_TRACING=false` (default: `true`), `ADDITIONAL_INETNUM_LOOKUP=false` (default: `true`)*\n\n* `-s`\n\n  * Launch a Shodan InternetDB scan for the target(s). Supports multiple targets,\n    mixed target types (IP/hostname/CIDR/URL) and piping from stdin.\n\n* `-o`\n\n  * forces a Search-By-Organization lookup and skip all target identification checks\n\n* `-a`\n\n  * enable *ASN suggestion mode*. This will search for all ASNs matching a given name.\n\n* `-u`\n\n  * enable *Transit/Upstream lookup mode*. This will inspect BGP updates and ASPATHs for the TARGET address/prefix and identify possible transit/upstream autonomous systems.\n\n* `-c`\n\n  * enable *Country CIDR mode*. This will output all IPv4/v6 CIDR blocks allocated to the specified country.\n\n* `-g`\n\n  * enable *Bulk Geolocation mode*. This will extract all IPv4/v6 addresses from the input, geolocate them and draw some stats.\n\n* `-l`\n\n  * Launch the script in *server mode*. See **Server Options** below\n\n* `-j`\n\n  * enables compact JSON output. Useful for feeding the output into other tools (like `jq` or other parsers), or storing the lookup results.\n\n    >*.asnrc option equivalent: `JSON_OUTPUT=true` (default: `false`)*\n\n* `-J`\n\n  * enables pretty-printed JSON output.\n\n    >*.asnrc option equivalent: `JSON_PRETTY=true` (default: `false`)*\n\n* `-m`\n\n  * enables monochrome mode (disables all colors).\n\n    >*.asnrc option equivalent: `MONOCHROME_MODE=true` (default: `false`)*\n\n* `-v`\n\n  * Enable debug messages (will display all URLs being queried to help identify external API slowdowns). In client mode, `asn` will log all output (external calls and their response data) to the location defined by `$ASN_LOGFILE` _(by default the logfile can be found at `$HOME/asndebug.log`)_.\n\n    >*.asnrc option equivalent: `ASN_DEBUG=true` (default: `false`)*\n\n* `-h`\n\n  * Show usage information.\n\n<u>Server Options</u>:\n\n* `BIND_ADDRESS`\n\n  * IP address (v4/v6) to bind the listening server to (e.g. `asn -l 0.0.0.0`)\n\n    >*.asnrc option equivalent: `DEFAULT_SERVER_BINDADDR_v4=\"<IPv4address>\"` (default: `\"127.0.0.1\"`) and `DEFAULT_SERVER_BINDADDR_v6=\"<IPv6address>\"` (default: `\"::1\"`)*\n\n* `BIND_PORT`\n\n  * TCP Port to bind the listening server to (e.g. `asn -l 12345`)\n\n    >*.asnrc option equivalent: `DEFAULT_SERVER_BINDPORT=\"<port>\"` (default: `\"49200\"`)*\n\n* `BIND_ADDRESS BIND_PORT`\n\n  * IP address and port to bind the listening server to (e.g. `asn -l ::1 12345`)\n\n* `-v`\n\n  * Enable verbose output and debug messages in server mode\n\n    >*.asnrc option equivalent: `ASN_DEBUG=true` (default: `false`)*\n\n* `--allow host[,host,...]`\n\n  * Allow only given hosts to connect to the server\n\n* `--allowfile file`\n\n  * A file of hosts allowed to connect to the server\n\n* `--deny host[,host,...]`\n\n  * Deny given hosts from connecting to the server\n\n* `--denyfile file`\n\n  * A file of hosts denied from connecting to the server\n\n* `--max-conns <n>`\n\n  * The maximum number of simultaneous connections accepted by the server. 100 is the default.\n\n>*Note: Every option in server mode (after* `-l`*) is passed directly to the ncat listener.* *Refer to* `man ncat` *for more details on the available commands.*\n*Unless specified, the default IP:PORT values of **127.0.0.1:49200** (for IPv4) or **[::1]:49200** (for IPv6) will be used (e.g.* `asn -l`*)*\n\n##### *Default behavior:*\n\n* The script will attempt to automatically identify the `TARGET` type, if invoked with `-t`, `-n`, `-d` or without options,\n* AS path tracing is **enabled by default** for all lookups involving an IP or hostname. In case of multiple IP results, the script will trace the first IP, with a preference for IPv6 if possible on the user's host.\n\n##### *Preferences file (`$HOME/.asnrc`)*\n\nOptions defaults can be overridden by creating a file called `.asnrc` in the user's **home directory**.\nThe following values are the defaults. Any (or all) of them can be specified in the settings file and adjusted to the user's preference:\n\n```shell\nASN_LOGFILE=\"$HOME/asndebug.log\"\nMTR_TRACING=true\nADDITIONAL_INETNUM_LOOKUP=true\nDETAILED_TRACE=false\nMTR_ROUNDS=5\nMAX_CONCURRENT_SHODAN_REQUESTS=10\nSHODAN_SHOW_TOP_N=5\nMONOCHROME_MODE=false\nASN_DEBUG=false\nJSON_OUTPUT=false\nJSON_PRETTY=false\nDEFAULT_SERVER_BINDADDR_v4=\"127.0.0.1\"\nDEFAULT_SERVER_BINDADDR_v6=\"::1\"\nDEFAULT_SERVER_BINDPORT=\"49200\"\nIQS_ALWAYS_QUERY=false\nIQS_CUSTOM_SETTINGS=\"\"\n```\n\n##### *Detailed mode (`-d` | `DETAILED_TRACE=true`)*\n\n* Detailed hop info reporting and RPKI validation can be turned on by passing the `[-d|--detailed]` command line switch. This will enable querying the public [pWhois server](https://pwhois.org/server.who) and the [RIPEStat RPKI validation API](https://stat.ripe.net/docs/data_api#rpki-validation) for every hop in the mtr trace. Relevant info will be displayed as a \"tree\" below the hop data, in addition to Team Cymru's server output (which only reports the AS name that the organization originating the prefix gave to its autonomous system number). This can be useful to figure out more details regarding the organization's name, the prefix' intended designation, and even (to a certain extent) its geographical scope.\n  Furthermore, this will enable a warning whenever RPKI validation fails for one of the hops in the trace, indicating which AS in the path is wrongly announcing (as per current pWhois data) the hop prefix, indicating a potential route leak or BGP hijacking incident.\n\n##### *Organization search (`-o`)*\n\n* The script will try to figure out if the input is an Organization name (i.e. if it doesn't look like an IP address, an AS number or a hostname).\n  In order to force an organization search (for example for Orgs containing `.` in their name), pass the `[-o|--organization]` command line switch.\n\n##### *ASN suggest (`-a`)*\n\n* The script will try to find ASNs matching the given search string, using the RIPEStat API. This mode can be used to map all the autonomous systems related to a given company.\n\n##### *Upstream/transit identification (`-u`)*\n\n* The script will inspect BGP updates for the given IP (v4/v6) and identify the likelihood of the upstream autonomous system(s) being transit(s) for the origin AS. A probability of the upstreams being transits will be inferred by the amount of times the upstream AS appears in the observed ASPATHs towards the target IP, in comparison to other BGP peers. The script will also inform the user if the prefix is being simultaneously announced to multiple upstreams (e.g. in case of BGP multihoming, tier-1 prefixes, anycast addresses, etc.). JSON mode is supported.\n\n##### *Server mode (`-l`)*\n\n* The script will start up a webserver allowing the user to run remote lookups and traceroutes directly from the browser.\n  The web server is actually an [ncat](https://nmap.org/ncat/) listener waiting for requests, responding to browsers querying through the HTTP protocol. This interface makes for a straightforward integration into user workflow and no need to download any client-side tools.\n  By simply using a Javascript [bookmarklet](https://en.wikipedia.org/wiki/Bookmarklet) or custom [search engine](https://www.howtogeek.com/114176/how-to-easily-create-search-plugins-add-any-search-engine-to-your-browser/), it will be possible to launch remote traces and lookups without ever leaving the browser.\n  Refer to the [this section](#running-lookups-from-the-browser) for more information.\n\n## Notes\n\n##### *Organization data, IP Reputation, noise classification and IP fingerprinting*\n\n* Organization data is taken from pWhois\n* IP reputation data is taken from StopForumSpam and IpQualityScore\n  > Reputation is also enriched with IP *noise* classification (addresses that have been observed scanning the Internet, and very likely to appear in your logs), taken from [GreyNoise](https://greynoise.io). This will also help identify known-good IPs (e.g. Google networks, CDNs, etc.) from aggressive, known-malicious scanners.\n* IP fingerprinting data is retrieved from Shodan's [InternetDB API](https://internetdb.shodan.io/). Data includes open ports, [software/hardware information](https://en.wikipedia.org/wiki/Common_Platform_Enumeration) and [known vulnerabilities](https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures) pertaining to the IP address.\n\n##### *Geolocation*\n\nThe script will perform IP and trace hop geolocation with this logic:\n\n1. Using the [ipinfo.io](https://ipinfo.io/) service as a primary source of geolocation data. It offers extremely precise geolocation data based on a proprietary network of geographically distributed probes, and is extremely reliable\n2. Using the [ip-api](https://ip-api.com/) service as a fallback source of geolocation data\n3. Using the [Prefix Whois](https://pwhois.org/) service as a last-resort source of geolocation data\n\n##### *IP Classification*\n\nThe script will use the ip-api, incolumitas.com, ipinfo.io and PeeringDB services to classify target IPs and trace hops into these categories:\n\n* [Anycast](https://en.wikipedia.org/wiki/Anycast) IP\n* Mobile network\n* Proxy host (TOR exit node/VPN/etc)\n* Hosting network (datacenter/hosting provider/etc) along with detailed DC and region identification where available\n* IXP network\n\n##### *IXP detection and unannounced prefixes*\n\n* The script will detect [IXPs](https://en.wikipedia.org/wiki/Internet_exchange_point) traversed during path traces by matching them with [PeeringDB](https://www.peeringdb.com/)'s comprehensive dataset of IXP prefixes.\n* The script will also attempt a best-effort, fallback generic `whois` lookup when Team Cymru, pWhois and PeeringDB have no info about the IP address or prefix. This is usually the case with some [PNI](https://en.wikipedia.org/wiki/Peering#Private_peering) prefixes, and will give better insight into the path taken by packets.\n\n## Running lookups from the browser\n\n##### *Prerequisite tools for server mode*\n\nServer mode requires two tools for its functionality: `ncat` and `aha`. Specifically, [aha](https://github.com/theZiz/aha) (the ANSI->HTML converter) v0.5+ is required. The ncat tool is contained inside the *nmap* package on older distributions (e.g. Ubuntu 18.04, Debian 9), while it is packaged as a standalone tool on newer ones.\n\nPlease refer to the [installation](#installation) section and run the appropriate commands to install the required packages for your operating system, and optionally to install the asn server as a systemd service.\n\n##### *Advantages of server mode*\n\nThe main advantage of running lookups from the browser, is that every IP address and AS number gets converted into a hyperlink, allowing to perform subsequent lookups by simply clicking on them.\n\nWhen looking up an URL/hostname/domain, quick WHOIS info and links to relevant external resources will be available in the results.\n\nWhen looking up an AS number, all peering ASNs will be clickable. Also, if an AS peers at a public facility, PeeringDB info for that facility will be linked directly. Furthermore, additional external BGP information sources will be linked, directly for the target ASN.\n\nHere are some examples:\n\n![srvmode_hostname_lookup](https://user-images.githubusercontent.com/24555810/117340152-e1217a00-aea0-11eb-9d8f-abaea0d3389e.png)\n\n![srvmode_whois](https://user-images.githubusercontent.com/24555810/117340278-01e9cf80-aea1-11eb-8cad-457f60e80a86.png)\n\n![srvmode_asn_lookup](https://user-images.githubusercontent.com/24555810/117340969-d7e4dd00-aea1-11eb-8e94-88d166f67360.png)\n\n#### Server side\n\nOnce started in **server mode**, `asn` will spin up a custom webserver waiting for browser requests. This is what the server-side console looks like:\n\n![server_console](https://user-images.githubusercontent.com/24555810/102154363-80ee5500-3e79-11eb-840f-53e3619be2e4.png)\n\nThe server is now ready to accept browser requests (only from the local machine, in this case - since I've launched it with no command line switches, which defaults to listening on **127.0.0.1:49200**. Refer to the [usage](#usage) section for more information about the available server options).\n\n#### Client side\n\nVisit [this page](http://127.0.0.1:49200/asn_bookmarklet) in your browser and follow the instructions to copy the bookmarklet to your bookmarks toolbar:\n\n![bookmarklet_install](https://user-images.githubusercontent.com/24555810/102159720-640b4f00-3e84-11eb-8360-afa79b6f0f5f.png)\n\n##### *How it works*\n\nThe bookmarklet is actually a small piece of Javascript code which will grab the hostname of the website you're currently visiting in the browser, and pass it to the server through a simple *HTTP GET* request. The server then proceeds to perform the lookup and traceroute (from its own viewpoint, just like it does when ran interactively from the command line), and feed the results to your browser through an HTML page, mimicking the effect of a scrolling terminal.\n\n>*Note: The link you drag to the bookmarks bar is actually a *minified* (i.e.: compacted) version of the source javascript code, but for reference, here's the full source:*\n>\n>```javascript\n>javascript:(function () {\n>    var asnserver = \"localhost:49200\";\n>    var target = window.location.hostname;\n>    var width = screen.width - screen.width / 7;\n>    var height= screen.height - screen.height / 4;\n>    var left = window.innerWidth / 2 - width / 2;\n>    var top = window.innerHeight / 2 - height / 2;\n>    window.open(\"http://\" + asnserver + \"/asn_lookup&\" + target, \"newWindow\", \"width=\" + width + \",height=\" + height + \",top=\" + top + \",left=\" + left);\n>})();\n>```\n>\n>*If you want to \"un-minify\" the actual bookmarklet code, you can refer to [this site](https://unminify.com/)*\n\nOnce the trace is finished, an option to share the output on [termbin](https://termbin.com/) is given to the user. This makes for quick sharing of the traceroute or lookup output with other people:\n\n![termbin](https://user-images.githubusercontent.com/24555810/102160506-dc264480-3e85-11eb-9e14-8c851f261172.png)\n\n![termbin_2](https://user-images.githubusercontent.com/24555810/102168101-f49b5c80-3e8f-11eb-8bc6-9f0592fa9624.png)\n\n#### Search engine setup\n\nIn order to take full advantage of having `asn` inside the browser, it is possible to configure it as a custom search engine for the browser search bar. This allows to leverage the server to search for **ASNs**, **URLs**, **IPs**, **Hostnames**, and so on, depending on the search string.\n\nGenerally speaking, this implies instructing the browser that when a certain **keyword** is prepended to a search, the following characters (the actual **search string**, identified by `%s`) have to be passed to a certain URL. The URL is then composed according to this logic, and opened just like a normal webpage.\n\nI've used `@asn` for my keyword, but anything would do. In order to speed up things, one could very well use a shorter tag (e.g. `#`) that, when used in the address bar, automatically switches your search engine to the ASN Lookup server.\nNote that the leading `@` sign is not mandatory, just handy since it doesn't get in the way of normal searches, but there's much freedom with that.\n\nFor quick reference, the location URL string to enter (for both Firefox and Chrome) is: `http://127.0.0.1:49200/asn_lookup&%s`. Of course that sends lookup requests to the *locally* running ASN server.\n\nHere's how to add a search engine in Firefox and Chrome:\n\n***Firefox:***\n\n* Simply create a new bookmark and fill its details like this:\n\n  ![searchsetup_firefox](https://user-images.githubusercontent.com/24555810/102160982-c6fde580-3e86-11eb-9885-c23eb60d622b.png)\n\nAfterwards, you will be able to run queries and traceroutes by simply entering, for example, `@asn 8.8.8.8` in the browser's location bar.\n\n***Chrome:***\n\n1. Right click the location bar and select <i>**Manage search engines...**</i>\n\n   ![searchsetup_chrome_1](https://user-images.githubusercontent.com/24555810/102161929-87d09400-3e88-11eb-9e42-70087e3fab87.png)\n\n2. Click **Add**:\n\n   ![searchsetup_chrome_2](https://user-images.githubusercontent.com/24555810/102162100-dc740f00-3e88-11eb-8037-528fbcc636e9.png)\n\n3. Fill in the details as shown below:\n\n   ![searchsetup_chrome_3](https://user-images.githubusercontent.com/24555810/102162218-16451580-3e89-11eb-85d1-a4d24c980d7d.png)\n\nAs usual, the keyword is entirely customizable to your preference.\n\n***Other browsers:***\n\n* You may want to follow [this post](https://www.howtogeek.com/114176/how-to-easily-create-search-plugins-add-any-search-engine-to-your-browser/) to search for instructions on how to add a custom search engine for your browser of choice.\n\n#### Running the server on an external host\n\n##### *Port forwarding*\n\nIn order to access the server remotely, beside binding to `0.0.0.0` (or any other relevant IP address for your scenario), if the host is behind a NAT router, you'll need to forward the listening port (`BIND_PORT`) from the host/router outside IP to the actual machine where the ASN server is running on.\nIt is a single TCP port (by default `TCP/49200`), and you can change it via the command line parameters (see [Usage](#usage)).\n\n##### *Textual browser client*\n\nIt is possible to launch remote traces from another command line, and view the results directly in the terminal. All it takes is a compatible text browser, for example `elinks` (but you can download results for later reviewing even using `curl` or really anything else).\n\nThe script makes use of 8-bit ANSI colors for its output, so the command to launch a remote trace using elinks would be something like this:\n\n`elinks -dump -dump-color-mode 3 http://<ASN_SRV_IP>:49200/asn_lookup&8.8.8.8`\n\n##### *Security considerations*\n\nThe server logic in itself is very simple: the script implements a basic web server entirely in BASH, leveraging the fact that it can talk to a browser using the HTTP protocol and the HTML language, in a reasonably simple way.\n\nThe core behind it revolves around [ncat](https://nmap.org/ncat/), a very robust and stable netcat-like network tool. This is the actual \"server\" listening for incoming connection, and spawning connection handlers (that is, 'single-purpose' instances of the `asn` script itself) as clients connect.\n\nIf you decide to open it to the outside (i.e.: binding it to something that is not localhost, and launching traces from outside your local machine), please bear in mind that there is no authentication mechanism (yet) integrated into the code, so theoretically anybody with the right URL could *spawn traceroutes from your server* and view the results (bear in mind however that the server sanitizes user input by stripping any dangerous characters).\n\nTo contrast that, fortunately `ncat` implements a robust allow/deny logic (based both on command line parameters and files, a la `/etc/hosts.allow` and `hosts.deny`). The script supports passing parameters directly to `ncat`, therefore it's possible to make full use of its filtering capabilities and lock the server to a restricted range of trusted IPs.\n\nThe available options, and some usage examples, can be viewed by running `asn -h`.\n\n>*Note: if you plan to run the server somewhere else than your local machine, remember to change the bookmarklet code and the custom search engine URL values to reflect the actual IP of the asn server. It is naturally possible to have multiple bookmarklets and search engine keywords to map to different ASN server instances.*\n>\n>*For the bookmarklet, you'll need to change this value at the very beginning:* `var asnserver=\"localhost:49200\"` *and make it point to the new address:port pair. No further change is required in the remaining JS code.*\n\n## Shodan scanning (Recon Mode)\n\nThe tool can query Shodan's InternetDB API to look up information regarding any type of targets when launched with the `-s` command line switch.\n\nIf the scan identifies any vulnerabilities, the NIST NVD API is queried in order to provide descriptions, any well known names and a link to learn more about the top ones.\n\nCurrently supported targets are:\n\n- **IP addresses**\n- **CIDR blocks** *(will scan all of the IPs in the range)*\n- **URLs**\n- **Hostnames** *(will resolve to an IP (or list of IPs) and query all of them)*\n\nTarget types can be mixed and queried in a single run. Targets can be piped to the tool via standard input as well.\n\n*Usage Examples:*\n\n`asn -s 1.1.1.1 8.8.8.8 9.9.9.9`\n\n`asn -s https://www.google.com 8.8.8.0/24`\n\n`asn -s < iplist`\n\n`curl -s https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/blocklist_de_bots.ipset | asn -s`\n\nShodan scan results can be output in JSON mode by passing the `-j` or `-J` options.\n\n>*Note: the Nmap tool is needed to use this feature, but note that **no packets whatsoever** are sent to the targets. Nmap is only required to break down CIDR blocks into single IPs (as a calculator tool).*\n\n## Mapping the IP(v4/v6) address space of specific countries\n\nThe tool will search and display all IPv4 and IPv6 CIDR blocks allocated to a specific country when launched with the `-c` command line switch, plus some statistics.\n\n* Searching for a specific country code with a leading dot (e.g. `.fr`) will yield direct results for France, while full text search will display country codes matching the search string, or proceed to display the results if only one match is found.\n* Statistics such as v4 prefix length distribution, total IPv4 addresses available to the country, IPv4 addresses per capita, etc. are included.\n* JSON output is supported.\n\n*Usage Examples:*\n\n`asn -c germany`\n\n`asn -c .de`\n\n```shell\n# scan a random norwegian subnet for CVE/CPE/open ports/hostnames:\nasn -jc .no | jq -r \".results[] | .ipv4[$RANDOM % .ipv4_blocks]\" | asn -s\n```\n\n## Bulk geolocation mode\n\nIn this mode the tool will extract all IPv4 and IPv6 addresses from the input data and geolocate them. Anycast detection and general stats (top IPv4/IPv6 addresses with number of occurrences, number of IPs per country etc.) are included in the output. Bulk geolocation is quicker than normal `asn` lookups (300 IP addresses can be parsed in ~5s), and its main use case is to extract, geolocate and calculate country/occurrence stats for any number of IPs from arbitrarily formatted data streams (e.g. server logs). JSON output and stdin input are supported.\n\n*Usage Examples:*\n\n`asn -g 1.1.1.1 8.8.8.8`\n\n```shell\n# geolocate webserver clients\nasn -g < /var/log/apache2/access.log\n```\n\n```shell\n# geolocate IPs that have logged in to the system\nlast | asn -g\n```\n\n## JSON output and API mode\n\n#### Locally (shell mode)\n\nThe tool can be instructed to output lookup results in JSON mode by using the `-j` (compact JSON) or `-J` (pretty-printed JSON) command line options:\n\n<details><summary><i>Example 1 - IPv4 lookup</i></summary><p>\n\n##### Command:\n\n`asn -J 8.8.8.8`\n\n##### Output:\n\n```json\n{\n  \"target\": \"8.8.8.8\",\n  \"target_type\": \"ipv4\",\n  \"result\": \"ok\",\n  \"reason\": \"success\",\n  \"version\": \"0.78.0\",\n  \"request_time\": \"2024-08-20T02:50:28\",\n  \"request_duration\": 5,\n  \"api_tokens\": {\n    \"ipqualityscore\": true,\n    \"ipinfo\": true,\n    \"cloudflare\": true\n  },\n  \"result_count\": 1,\n  \"results\": [\n    {\n      \"ip\": \"8.8.8.8\",\n      \"ip_version\": \"4\",\n      \"reverse\": \"dns.google\",\n      \"org_name\": \"Google LLC\",\n      \"net_range\": \"8.8.8.0/24\",\n      \"net_name\": \"GOGL\",\n      \"abuse_contacts\": [\n        \"network-abuse@google.com\"\n      ],\n      \"routing\": {\n        \"is_announced\": true,\n        \"as_number\": \"15169\",\n        \"as_name\": \"GOOGLE, US\",\n        \"as_rank\": \"1788\",\n        \"route\": \"8.8.8.0/24\",\n        \"route_name\": \"\",\n        \"roa_count\": \"1\",\n        \"roa_validity\": \"valid\"\n      },\n      \"type\": {\n        \"is_bogon\": false,\n        \"is_anycast\": true,\n        \"is_mobile\": false,\n        \"is_proxy\": false,\n        \"is_dc\": true,\n        \"dc_details\": {\n          \"dc_name\": \"Google LLC\"\n        },\n        \"is_ixp\": false\n      },\n      \"geolocation\": {\n        \"city\": \"Mountain View\",\n        \"region\": \"California\",\n        \"country\": \"United States\",\n        \"cc\": \"US\"\n      },\n      \"reputation\": {\n        \"status\": \"good\",\n        \"is_known_good\": true,\n        \"known_as\": \"Google Public DNS\"\n      },\n      \"fingerprinting\": {\n        \"ports\": [\n          53,\n          443\n        ]\n      }\n    }\n  ]\n}\n```\n</p></details>\n<details><summary><i>Example 2 - ASN lookup</i></summary><p>\n\n##### Command:\n\n`asn -J 5505`\n\n##### Output:\n\n```json\n{\n  \"target\": \"5505\",\n  \"target_type\": \"asn\",\n  \"result\": \"ok\",\n  \"reason\": \"success\",\n  \"version\": \"0.78.0\",\n  \"request_time\": \"2024-08-20T02:50:46\",\n  \"request_duration\": 17,\n  \"api_tokens\": {\n    \"ipqualityscore\": true,\n    \"ipinfo\": true,\n    \"cloudflare\": true\n  },\n  \"result_count\": 1,\n  \"results\": [\n    {\n      \"asn\": \"5505\",\n      \"asname\": \"VADAVO, ES\",\n      \"asrank\": 4448,\n      \"org\": \"VDV-VLC-RED06 VDV-VLC-RED06 - CLIENTES TELECOM\",\n      \"holder\": \"VADAVO SOLUCIONES SL\",\n      \"abuse_contacts\": [\n        \"abuse@vadavo.com\"\n      ],\n      \"registration_date\": \"2016-12-13T08:28:07\",\n      \"ixp_presence\": [\n        \"DE-CIX Madrid: DE-CIX Madrid Peering LAN\",\n        \"ESpanix Madrid Lower LAN\"\n      ],\n      \"prefix_count_v4\": 8,\n      \"prefix_count_v6\": 1,\n      \"bgp_peer_count\": 36,\n      \"bgp_hijack_incidents\": {\n        \"total\": 0,\n        \"as_hijacker\": 0,\n        \"as_victim\": 0\n      },\n      \"bgp_leak_incidents\": {\n        \"total\": 0\n      },\n      \"bgp_peers\": {\n        \"upstream\": [\n          \"1299\",\n          \"6939\",\n          \"59432\",\n          \"174\",\n          \"34549\",\n          \"25091\",\n          \"35625\",\n          \"33891\",\n          \"48348\",\n          \"13030\",\n          \"8218\",\n          \"41327\",\n          \"3303\",\n          \"4455\",\n          \"6424\",\n          \"6057\",\n          \"34927\",\n          \"9498\",\n          \"35280\",\n          \"1239\"\n        ],\n        \"downstream\": [\n          \"48952\",\n          \"208248\",\n          \"205086\",\n          \"202054\"\n        ],\n        \"uncertain\": [\n          \"24482\",\n          \"51185\",\n          \"41047\",\n          \"29680\",\n          \"212483\",\n          \"198150\",\n          \"14840\",\n          \"49544\",\n          \"39384\",\n          \"37721\",\n          \"36236\",\n          \"25160\"\n        ]\n      },\n      \"announced_prefixes\": {\n        \"v4\": [\n          \"185.210.225.0/24\",\n          \"188.130.247.0/24\",\n          \"185.210.227.0/24\",\n          \"185.123.205.0/24\",\n          \"185.123.207.0/24\",\n          \"185.210.226.0/24\",\n          \"185.123.206.0/24\",\n          \"185.123.204.0/24\"\n        ],\n        \"v6\": [\n          \"2a03:9320::/32\"\n        ]\n      },\n      \"inetnums\": {\n        \"v4\": [\n          \"185.123.204.0/22\",\n          \"185.210.225.0/24\",\n          \"185.210.226.0/24\",\n          \"185.210.227.0/24\",\n          \"188.130.247.0/24\"\n        ],\n        \"v6\": [\n          \"2a03:9320::/32\"\n        ]\n      },\n      \"inetnums_announced_by_other_as\": {\n        \"v4\": [\n          {\n            \"prefix\": \"188.130.254.0/24\",\n            \"origin_asn\": \"\",\n            \"origin_org\": \"\",\n            \"is_announced\": false\n          }\n        ],\n        \"v6\": []\n      }\n    }\n  ]\n}\n```\n\n</p></details>\n<details><summary><i>Example 3 - enumerating abuse contacts for every IP to which a hostname resolves</i></summary><p>\n\n##### Command:\n\n`asn -j www.google.com | jq '[.results[].abuse_contacts[]] | unique[]'`\n\n##### Output:\n\n```\n\"network-abuse@google.com\"\n\"ripe-contact@google.com\"\n```\n\n</p></details>\n<details><summary><i>Example 4 - enumerating known vulnerabilities for a target</i></summary><p>\n\n##### Command:\n\n`asn -j 45.67.34.100 | jq '.results[].fingerprinting.vulns[]'`\n\n##### Output:\n```\n\"CVE-2017-15906\"\n\"CVE-2018-15919\"\n```\n\n</p></details>\n<details><summary><i>Example 5 - upstream/transit AS lookup for a given IP</i></summary><p>\n\n##### Command:\n\n`asn -Ju 72.17.119.201`\n\n##### Output:\n\n```json\n{\n  \"target\": \"72.17.119.201\",\n  \"target_type\": \"ipv4\",\n  \"result\": \"ok\",\n  \"reason\": \"success\",\n  \"version\": \"0.78.0\",\n  \"request_time\": \"2024-08-20T02:54:03\",\n  \"request_duration\": 4,\n  \"api_tokens\": {\n    \"ipqualityscore\": true,\n    \"ipinfo\": true,\n    \"cloudflare\": true\n  },\n  \"result_count\": 1,\n  \"results\": [\n    {\n      \"prefix\": \"72.17.0.0/17\",\n      \"origin_as\": \"33363\",\n      \"origin_as_name\": \"BHN-33363, US\",\n      \"origin_as_rank\": 441,\n      \"upstreams_count\": 1,\n      \"upstreams\": [\n        {\n          \"asn\": \"7843\",\n          \"asname\": \"TWC-7843-BB, US\",\n          \"probability\": 100,\n          \"is_tier1\": false\n        }\n      ],\n      \"multiple_upstreams\": false\n    }\n  ]\n}\n```\n\n</p></details>\n<details><summary><i>Example 6 - enumerating unannounced address blocks for a given AS</i></summary><p>\n\n##### Command:\n\n`asn -j AS5505 | jq -r '.results[].inetnums_announced_by_other_as.v4[] | select(.is_announced==false) | .prefix'`\n\n##### Output:\n\n```\n188.130.254.0/24\n```\n\n</p></details>\n<details><summary><i>Example 7 - enumerating the amount of BGP hijacking incidents involving a given AS</i></summary><p>\n\n##### Command:\n\n`asn -j AS8860 | jq '.results[].bgp_hijack_incidents'`\n\n##### Output:\n\n```\n{\n  \"total\": 18,\n  \"as_hijacker\": 11,\n  \"as_victim\": 7\n}\n```\n\n</p></details>\n\n#### Remotely (API endpoint)\n\nBy running the script in [server mode](#running-lookups-from-the-browser), it is possible to use it as a self-hosted lookup API service by running HTTP queries against it and retrieving the results in compact or pretty-printed JSON format. The server exposes the `asn_lookup_json` and `asn_lookup_jsonp` endpoints for this purpose. The syntax is the same as with normal browser-based remote queries.\n\n*Example 1: querying the server remotely using `curl` (compact output):*\n\n```shell\nroot@KRUSTY:~# curl -s \"http://localhost:49200/asn_lookup_json&1.1.1.1\"\n{\"target\":\"1.1.1.1\",\"target_type\":\"ipv4\",\"result\":\"ok\",\"reason\":\"success\",\"version\":\"0.72.1\",\"request_time\":\"2022-03-29T00:13:11\",\"request_duration\":5,\"result_count\":1,\"results\":[{\"ip\":\"1.1.1.1\",\"ip_version\":\"4\",\"reverse\":\"one.one.one.one\",\"org_name\":\"APNIC and Cloudflare DNS Resolver project\",\"abuse_contacts\":[\"helpdesk@apnic.net\"],\"routing\":{\"is_announced\":true,\"as_number\":\"13335\",\"as_name\":\"CLOUDFLARENET, US\",\"net_range\":\"1.1.1.0/24\",\"net_name\":\"APNIC-LABS\",\"roa_count\":\"1\",\"roa_validity\":\"valid\"},\"type\":{\"is_bogon\":false,\"is_anycast\":true,\"is_mobile\":false,\"is_proxy\":false,\"is_dc\":true,\"dc_details\":{\"dc_name\":\"Cloudflare\"},\"is_ixp\":false},\"geolocation\":{\"city\":\"Magomeni\",\"region\":\"Dar es Salaam\",\"country\":\"Tanzania\",\"cc\":\"TZ\"},\"reputation\":{\"status\":\"good\",\"is_known_good\":true,\"known_as\":\"Cloudflare Public DNS\"},\"fingerprinting\":{\"ports\":[53,80,443]}}]}\n```\n\n*Example 2: querying the server remotely using `curl` (pretty printed output):*\n\n```shell\nroot@KRUSTY:~# curl -s \"http://localhost:49200/asn_lookup_jsonp&10.0.0.1\"\n{\n  \"target\": \"10.0.0.1\",\n  \"target_type\": \"ipv4\",\n  \"result\": \"ok\",\n  \"reason\": \"success\",\n  \"version\": \"0.72.1\",\n  \"request_time\": \"2022-03-29T00:14:57\",\n  \"request_duration\": 0,\n  \"result_count\": 1,\n  \"results\": [\n    {\n      \"ip\": \"10.0.0.1\",\n      \"ip_version\": \"4\",\n      \"org_name\": \"IANA\",\n      \"routing\": {\n        \"is_announced\": false,\n        \"net_name\": \"PRIVATE-ADDRESS-ABLK-RFC1918-IANA-RESERVED\"\n      },\n      \"type\": {\n        \"is_bogon\": true,\n        \"bogon_type\": \"rfc1918 (Private Space)\"\n      },\n      \"reputation\": {},\n      \"fingerprinting\": {}\n    }\n  ]\n}\n```\n\n- - -\n\n## Thanks\n\nAn initial version of this script was featured in the **Security Trails** blog post \"[*ASN Lookup Tools, Strategies and Techniques*](https://securitytrails.com/blog/asn-lookup#autonomous-system-lookup-script)\". Thank you [Esteban](https://www.estebanborges.com/)!\n\nThanks [Massimo Candela](https://github.com/massimocandela/) for your support and excellent work on [IPmap](https://ipmap.ripe.net/), [BGPlay](https://github.com/massimocandela/BGPlay) and [TraceMON](https://github.com/RIPE-NCC/tracemon)!\n\nThanks to all the awesome contributors for their code, ideas, suggestions, packages and bug reports!\n\n## Feedback and contributing\n\nAny feedback or pull request to improve the code is welcome. Feel free to contribute!\n"
        },
        {
          "name": "asn",
          "type": "blob",
          "size": 203.7294921875,
          "content": "#!/usr/bin/env bash\n\n# ╭──────────────────────────────────────────────────────────────────────────────────────╮\n# │    ASN / IPv4 / IPv6 / Prefix / AS Path / Organization lookup and server tool        │\n# │                                                                                      │\n# │Project homepage:                                                                     │\n# │                                                                                      │\n# │ https://github.com/nitefood/asn                                                      │\n# │                                                                                      │\n# │Usage:                                                                                │\n# │                                                                                      │\n# │ (Launch the script without parameters or visit the project's homepage for usage info)│\n# ╰──────────────────────────────────────────────────────────────────────────────────────╯\n\nASN_VERSION=\"0.78.1\"\nASN_LOGFILE=\"$HOME/asndebug.log\"\n\n# ╭──────────────────╮\n# │ Helper functions │\n# ╰──────────────────╯\n\ndocurl(){\n\t# shellcheck disable=SC2124\n\tif [ \"$ASN_DEBUG\" = true ]; then\n\t\tparm=\"$@\"\n\t\tDebugPrint \"${yellow}curl $parm${default}\"\n\t\tcurloutput=$(curl \"$@\")\n\t\techo \"$curloutput\"\n\t\tcurloutput_jsonp=$(jq -C '.' <<<\"$curloutput\" 2>/dev/null)\n\t\t[[ -n \"$curloutput_jsonp\" ]] && echo -e \"$curloutput_jsonp\" >> \"$ASN_LOGFILE\" || echo \"$curloutput\" >> \"$ASN_LOGFILE\"\n\t\techo \"\" >> \"$ASN_LOGFILE\"\n\telse\n\t\tcurl \"$@\"\n\tfi\n}\n\nWhoisASN(){\n\tfound_asname=$(host -t TXT \"AS${1}.asn.cymru.com\" | grep -v \"NXDOMAIN\" | awk -F'|' 'NR==1{print substr($NF,2,length($NF)-2)}')\n\tif [ -n \"$found_asname\" ]; then\n\t\t((json_resultcount++))\n\t\tpwhois_full_asn_info=$(whois -h whois.pwhois.org \"registry source-as=$1\")\n\t\t# fetch last org only (in case there are multiple orgs listed for this AS)\n\t\tpwhois_asn_info=$(tac <<<\"$pwhois_full_asn_info\" | grep -m1 -E \"^Org-Name\")\n\t\tpwhois_asn_info+=\"\\n\"\n\t\tpwhois_asn_info+=$(tac <<<\"$pwhois_full_asn_info\" | grep -m1 -E \"^Create-Date\")\n\t\tfound_holder=$(docurl -m5 -s \"https://stat.ripe.net/data/as-overview/data.json?resource=AS$1&sourceapp=nitefood-asn\" | jq -r 'select (.data.holder != null) | .data.holder')\n\t\t# RIPE usually outputs holder as \"ASNAME - actual company name\", trim it to just the company name in such cases\n\t\tfound_holder=$(awk -F' - ' '{ if ( $2 ) {print $2} else {print} }' <<<\"$found_holder\")\n\t\tfound_org=$(echo -e \"$pwhois_asn_info\" | grep -E \"^Org-Name:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//')\n\t\t[[ -z \"$found_org\" ]] && found_org=\"N/A\"\n\t\tfound_abuse_contact=$(docurl -m5 -s \"https://stat.ripe.net/data/abuse-contact-finder/data.json?resource=AS$asn&sourceapp=nitefood-asn\" | jq -r 'select (.data.abuse_contacts[0] != null) | .data.abuse_contacts[0]')\n\t\t[[ -z \"$found_abuse_contact\" ]] && found_abuse_contact=\"-\"\n\t\tpwhois_createdate=$(echo -e \"$pwhois_asn_info\" | grep -E \"^Create-Date:\" | cut -d ':' -f 2- | sed 's/^[ \\t]*//')\n\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t[[ -z \"$pwhois_createdate\" ]] && found_createdate=\"\" || found_createdate=$(date -d \"$pwhois_createdate\" \"+%Y-%m-%dT%H:%M:%S\")\n\t\telse\n\t\t\t[[ -z \"$pwhois_createdate\" ]] && found_createdate=\"N/A\" || found_createdate=$(date -d \"$pwhois_createdate\" \"+%Y-%m-%d %H:%M:%S\")\n\t\tfi\n\tfi\n}\n\nQueryRipestat(){\n\tStatusbarMessage \"Retrieving BGP data for AS$1 ($found_asname)\"\n\t# BGP routing stats\n\tripestat_routing_data=$(docurl -m5 -s \"https://stat.ripe.net/data/routing-status/data.json?resource=AS$1&sourceapp=nitefood-asn\")\n\tif [ -n \"$ripestat_routing_data\" ]; then\n\t\tripestat_ipv4=$(jq -r '.data.announced_space.v4.prefixes' <<<\"$ripestat_routing_data\")\n\t\tripestat_ipv6=$(jq -r '.data.announced_space.v6.prefixes' <<<\"$ripestat_routing_data\")\n\t\tripestat_bgp=$(jq -r '.data.observed_neighbours' <<<\"$ripestat_routing_data\")\n\tfi\n\t# BGP neighbours list\n\tStatusbarMessage \"Retrieving peering data for AS$1 ($found_asname)\"\n\tripestat_neighbours_data=$(docurl -m10 -s \"https://stat.ripe.net/data/asn-neighbours/data.json?resource=AS$1&sourceapp=nitefood-asn\")\n\tupstream_peers=$(jq -r '.data.neighbours | sort_by(.power) | reverse[] | select (.type==\"left\") | .asn' <<<\"$ripestat_neighbours_data\")\n\tdownstream_peers=$(jq -r '.data.neighbours | sort_by(.power) | reverse[] | select (.type==\"right\") | .asn' <<<\"$ripestat_neighbours_data\")\n\tuncertain_peers=$(jq -r '.data.neighbours | sort_by(.power) | reverse[] | select (.type==\"uncertain\") | .asn' <<<\"$ripestat_neighbours_data\")\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\tjson_abuse_contacts=$(docurl -m5 -s \"https://stat.ripe.net/data/abuse-contact-finder/data.json?resource=AS$1&sourceapp=nitefood-asn\" | jq -cM 'select (.data.abuse_contacts != null) | .data.abuse_contacts')\n\t\t[[ -z \"$json_abuse_contacts\" ]] && json_abuse_contacts=\"[]\"\n\t\tjson_upstream_peers=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$upstream_peers\")\n\t\tjson_downstream_peers=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$downstream_peers\")\n\t\tjson_uncertain_peers=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$uncertain_peers\")\n\telse\n\t\tRESOLVE_COUNT=8\n\t\tOUTPUT_PEERS_PER_LINE=4\n\n\t\t# resolve AS names of the first n upstreams\n\t\tupstream_peercount=$(echo \"$upstream_peers\" | wc -l)\n\t\tresolved_upstream_peers=\"\"\n\t\tcount=0\n\t\tfor peer in $(echo -e \"$upstream_peers\" | head -n $RESOLVE_COUNT); do\n\t\t\t(( count++ ))\n\t\t\tpeername=$(docurl -s \"https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn\" | jq -r '.data.holder' | sed 's/ - .*//' )\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\tresolved_upstream_peers+=\"${greenbg} <a href=\\\"/asn_lookup&AS$peer\\\" class=\\\"hidden_underline\\\" style=\\\"background-color: $htmlgreen; color: $htmlblack;\\\">$peername ($peer)</a> ${default} \"\n\t\t\telse\n\t\t\t\tresolved_upstream_peers+=\"${greenbg} $peername ($peer) ${default} \"\n\t\t\tfi\n\t\t\t[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_upstream_peers+=\"\\n\"\n\t\tdone\n\t\t# and add the remaining ones as AS numbers only\n\t\tunresolved_peercount=$(( upstream_peercount - RESOLVE_COUNT ))\n\t\tif [ \"$unresolved_peercount\" -ge 1 ]; then\n\t\t\tresolved_upstream_peers+=\"and more: \"\n\t\t\tfor peer in $(echo -e \"$upstream_peers\" | tail -n $unresolved_peercount ); do\n\t\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t\tresolved_upstream_peers+=\"<a href=\\\"/asn_lookup&AS$peer\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlgreen;\\\">$peer</a>${default} \"\n\t\t\t\telse\n\t\t\t\t\tresolved_upstream_peers+=\"${green}${peer}${default} \"\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\tupstream_peers=\"$resolved_upstream_peers\"\n\n\t\t# resolve AS names of the first n downstreams\n\t\tdownstream_peercount=$(echo \"$downstream_peers\" | wc -l)\n\t\tresolved_downstream_peers=\"\"\n\t\tcount=0\n\t\tfor peer in $(echo -e \"$downstream_peers\" | head -n $RESOLVE_COUNT); do\n\t\t\t(( count++ ))\n\t\t\tpeername=$(docurl -s \"https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn\" | jq -r '.data.holder' | sed 's/ - .*//' )\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\tresolved_downstream_peers+=\"${yellowbg} <a href=\\\"/asn_lookup&AS$peer\\\" class=\\\"hidden_underline\\\" style=\\\"background-color: $htmlyellow; color: $htmlblack;\\\">$peername ($peer)</a> ${default} \"\n\t\t\telse\n\t\t\t\tresolved_downstream_peers+=\"${yellowbg} $peername ($peer) ${default} \"\n\t\t\tfi\n\t\t\t[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_downstream_peers+=\"\\n\"\n\t\tdone\n\t\t# and add the remaining ones as AS numbers only\n\t\tunresolved_peercount=$(( downstream_peercount - RESOLVE_COUNT ))\n\t\tif [ \"$unresolved_peercount\" -ge 1 ]; then\n\t\t\tresolved_downstream_peers+=\"and more: \"\n\t\t\tfor peer in $(echo -e \"$downstream_peers\" | tail -n $unresolved_peercount ); do\n\t\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t\tresolved_downstream_peers+=\"<a href=\\\"/asn_lookup&AS$peer\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlyellow;\\\">$peer</a>${default} \"\n\t\t\t\telse\n\t\t\t\t\tresolved_downstream_peers+=\"${yellow}${peer}${default} \"\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\tdownstream_peers=\"$resolved_downstream_peers\"\n\n\t\t# resolve AS names of the first n uncertains\n\t\tuncertain_peercount=$(echo \"$uncertain_peers\" | wc -l)\n\t\tresolved_uncertain_peers=\"\"\n\t\tcount=0\n\t\tfor peer in $(echo -e \"$uncertain_peers\" | head -n $RESOLVE_COUNT); do\n\t\t\t(( count++ ))\n\t\t\tpeername=$(docurl -s \"https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn\" | jq -r '.data.holder' | sed 's/ - .*//' )\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\tresolved_uncertain_peers+=\"${lightgreybg} <a href=\\\"/asn_lookup&AS$peer\\\" class=\\\"hidden_underline\\\" style=\\\"background-color: $htmllightgray; color: $htmlblack;\\\">$peername ($peer)</a> ${default} \"\n\t\t\telse\n\t\t\t\tresolved_uncertain_peers+=\"${lightgreybg} $peername ($peer) ${default} \"\n\t\t\tfi\n\t\t\t[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_uncertain_peers+=\"\\n\"\n\t\tdone\n\t\t# and add the remaining ones as AS numbers only\n\t\tunresolved_peercount=$(( uncertain_peercount - RESOLVE_COUNT ))\n\t\tif [ \"$unresolved_peercount\" -ge 1 ]; then\n\t\t\tresolved_uncertain_peers+=\"and more: \"\n\t\t\tfor peer in $(echo -e \"$uncertain_peers\" | tail -n $unresolved_peercount ); do\n\t\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t\tresolved_uncertain_peers+=\"<a href=\\\"/asn_lookup&AS$peer\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlwhite;\\\">$peer</a>${default} \"\n\t\t\t\telse\n\t\t\t\t\tresolved_uncertain_peers+=\"${white}${peer}${default} \"\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\tuncertain_peers=\"$resolved_uncertain_peers\"\n\tfi\n\n\tStatusbarMessage \"Retrieving prefix allocations and announcements for AS$1 ($found_asname)\"\n\tipv4_inetnums=\"\"\n\tipv6_inetnums=\"\"\n\tjson_ipv4_other_inetnums=\"\"\n\tjson_ipv6_other_inetnums=\"\"\n\tripe_prefixes=$(docurl -m10 -s \"https://stat.ripe.net/data/announced-prefixes/data.json?resource=$1&sourceapp=nitefood-asn\" | jq -r '.data.prefixes[].prefix')\n\tjson_ripe_prefixes=$(jq -cM --slurp --raw-input 'split(\"\\n\") | map(select(length > 0)) | {v4:map(select(contains(\":\")|not)), v6:map(select(contains(\":\")))}' <<<\"$ripe_prefixes\")\n\tipv4_ripe_prefixes=$(grep -v \":\" <<<\"$ripe_prefixes\" | grep -Ev \"^$\" | sort)\n\tipv4_ripe_prefixes_count=$(wc -l <<<\"$ipv4_ripe_prefixes\")\n\tipv6_ripe_prefixes=$(grep \":\" <<<\"$ripe_prefixes\" | grep -Ev \"^$\" | sort)\n\tipv6_ripe_prefixes_count=$(wc -l <<<\"$ipv6_ripe_prefixes\")\n\n\t# open persistent tcp connection to RIPE whois server\n\texec 6<>/dev/tcp/whois.ripe.net/43\n\n\tprefixcounter=0\n\tfor prefix in $ipv6_ripe_prefixes; do\n\t\t((prefixcounter++))\n\t\tStatusbarMessage \"Retrieving information for IPv6 prefix $prefixcounter/$ipv6_ripe_prefixes_count\"\n\t\t# old way (one whois lookup per prefix)\n\t\t# inet6nums=$(whois -h whois.ripe.net -- \"-T inet6num -K -L --resource $prefix\" | \\\n\t\t#\t\t\t\tgrep -m2 inet6num | cut -d ':' -f 2- | sed 's/^[ \\t]*//')\n\t\t# new way (direct tcp connection to whois server with persistent whois connection)\n\t\techo -e \"-k -T inet6num -K -L --resource $prefix\" >&6\n\t\twhoisoutput=\"\"\n\t\t# read whois output from the tcp stream line by line\n\t\twhile IFS= read -r -u 6 whoisoutputline; do\n\t\t\tif [ -n \"$whoisoutputline\" ]; then\n\t\t\t\twhoisoutput+=\"$whoisoutputline\\n\"\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\t# last line was empty, check if next line is empty too\n\t\t\t# if we get two empty lines in a row, the whois output is finished\n\t\t\tIFS= read -r -u 6 whoisoutputline\n\t\t\t[[ -z \"$whoisoutputline\" ]] && break || whoisoutput+=\"$whoisoutputline\\n\"\n\t\tdone\n\t\tinet6nums=$(echo -e \"$whoisoutput\" | grep -m2 inet6num | cut -d ':' -f 2- | sed 's/^[ \\t]*//')\n\t\tfor inet6num in $inet6nums; do\n\t\t\t# exclude RIR supernets\n\t\t\tprefix_size=$(echo \"$inet6num\" | cut -d '/' -f 2)\n\t\t\t[[ \"$prefix_size\" -le 12 ]] && continue || ipv6_inetnums+=\"${inet6num}\\n\"\n\t\tdone\n\tdone\n\n\tprefixcounter=0\n\tlookedup_parents_cache=\"\"\n\tfor prefix in $ipv4_ripe_prefixes; do\n\t\t((prefixcounter++))\n\t\tStatusbarMessage \"Retrieving information for IPv4 prefix $prefixcounter/$ipv4_ripe_prefixes_count\"\n\t\t# old way (one whois lookup per prefix)\n\t\t# parent_inetnum=$(whois -h whois.ripe.net -- \"-T inetnum -K -L --resource  $prefix\" | \\\n\t\t# \t\t\t\tgrep -E -m1 \"^inetnum\" | awk '{print $2\"-\"$4}' | xargs ipcalc -r 2>/dev/null | grep -v \"deaggregate\")\n\t\t# new way (direct tcp connection to whois server with persistent whois connection)\n\t\techo -e \"-k -T inetnum -K -L --resource $prefix\" >&6\n\t\twhoisoutput=\"\"\n\t\t# read whois output from the tcp stream line by line\n\t\twhile IFS= read -r -u 6 whoisoutputline; do\n\t\t\tif [ -n \"$whoisoutputline\" ]; then\n\t\t\t\twhoisoutput+=\"$whoisoutputline\\n\"\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\t# last line was empty, check if next line is empty too\n\t\t\t# if we get two empty lines in a row, the whois output is finished\n\t\t\tIFS= read -r -u 6 whoisoutputline\n\t\t\t[[ -z \"$whoisoutputline\" ]] && break || whoisoutput+=\"$whoisoutputline\\n\"\n\t\tdone\n\t\tparent_inetnum=$(echo -e \"$whoisoutput\" | grep -E -m1 \"^inetnum\")\n\t\tif [ -n \"$parent_inetnum\" ]; then\n\t\t\tparent_inetnum=$(awk '{print $2\"-\"$4}' <<<\"$parent_inetnum\")\n\t\t\tparent_inetnum=$(IpcalcDeaggregate \"$parent_inetnum\")\n\t\t\t# check if the inetnum containing this prefix is being announced by the same AS as the prefix itself, otherwise\n\t\t\t# it means it's part of a larger supernet by some other AS (e.g. larger carrier allocating own prefix to smaller customer)\n\t\t\tif ! grep -q \"$parent_inetnum\" <<<\"$lookedup_parents_cache\"; then\n\t\t\t\t# this parent inetnum hasn't been looked up yet\n\t\t\t\tlookedup_parents_cache+=\"$parent_inetnum\\n\"\n\t\t\t\tLookupASNAndRouteFromIP \"$parent_inetnum\"\n\t\t\t\tif [ -z \"$found_asname\" ] || [ \"$1\" = \"$found_asn\" ]; then\n\t\t\t\t\t# the target AS is also announcing the larger inetnum, or nobody is announcing it. Either way consider it part of the target's resources\n\t\t\t\t\tipv4_inetnums+=\"$parent_inetnum\\n\"\n\t\t\t\telse\n\t\t\t\t\t# the larger inetnum is being announced by another AS, only add the announced (smaller) prefix to the list\n\t\t\t\t\tipv4_inetnums+=\"$prefix\\n\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t# this parent inetnum has already been looked up\n\t\t\t\t# if it's not present in the list of ipv4_inetnums, it means it's part of a larger supernet by some other AS.\n\t\t\t\t# therefore we only add the announced (smaller) prefix to the list\n\t\t\t\tif ! grep -q \"$parent_inetnum\" <<<\"$ipv4_inetnums\"; then\n\t\t\t\t\tipv4_inetnums+=\"$prefix\\n\"\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tipv4_inetnums+=\"$prefix\\n\"\n\t\tfi\n\tdone\n\t# close persistent tcp connection to RIPE whois server\n\tif { true >&6; } 2<> /dev/null; then\n\t\techo -e \"-k\" >&6\n\tfi\n\n\tif [ \"$ADDITIONAL_INETNUM_LOOKUP\" = true ]; then\n\t\t# fetch further inetnums allocated to this AS from pWhois\n\t\tStatusbarMessage \"Identifying additional INETNUMs (not announced or announced by other AS) allocated to AS$1\"\n\t\tpwhois_prefixes=$(PwhoisListPrefixesForOrg \"$found_org\")\n\t\tpwhois_unique_prefixes=$(comm -13 <(echo -e \"$ipv4_ripe_prefixes\" | sort) <(echo -e \"$pwhois_prefixes\" | sort))\n\t\tpwhois_unique_prefixes=$(comm -13 <(echo -e \"$lookedup_parents_cache\" | sort) <(echo -e \"$pwhois_unique_prefixes\" | sort))\n\t\tif [ -n \"$pwhois_unique_prefixes\" ]; then\n\t\t\tpwhois_unique_prefixes_count=$(wc -l <<<\"$pwhois_unique_prefixes\")\n\t\t\tStatusbarMessage \"Identifying origin AS for $pwhois_unique_prefixes_count additional IPv4 prefix(es)\"\n\t\t\t# NEW WAY (bulk query to Team Cymru whois server)\n\t\t\t# map the unique prefixes pWhois reported to an array\n\t\t\tmapfile -t pwhois_unique_prefixes_array < <(echo -e \"$pwhois_unique_prefixes\")\n\t\t\t# assemble a bulk Team Cymru whois lookup query for the new prefixes found in pWhois.\n\t\t\t# we'll check if they're announced by the target AS, by different one, or by no one at all\n\t\t\t# (e.g. target AS has delegated announcements for this prefix to another AS, or is not announcing it)\n\t\t\t# and compile a list to integrate into the allocated IP resources for this AS\n\t\t\tteamcymru_bulk_query=\"begin\\n\"\n\t\t\tfor prefix in $pwhois_unique_prefixes; do\n\t\t\t\tteamcymru_bulk_query+=\"$prefix\\n\"\n\t\t\tdone\n\t\t\tteamcymru_bulk_query+=\"end\"\n\t\t\tprefixcounter=0\n\t\t\tfor single_prefix_data in $(echo -e \"$teamcymru_bulk_query\" | ncat --no-shutdown whois.cymru.com 43 | grep \"|\" | sed 's/\\ *|\\ */|/g'); do\n\t\t\t\tprefix=\"${pwhois_unique_prefixes_array[$prefixcounter]}\"\n\t\t\t\tprefix_originator_asn=$(echo \"$single_prefix_data\" | cut -d '|' -f 1)\n\t\t\t\tif [ \"$prefix_originator_asn\" = \"$1\" ]; then\n\t\t\t\t\t# prefix originator is same as target AS, add this prefix to the allocated IP resources for this AS\n\t\t\t\t\tipv4_inetnums+=\"$prefix\\n\"\n\t\t\t\telif [ \"$prefix_originator_asn\" = \"NA\" ]; then\n\t\t\t\t\t# prefix not announced, add this prefix to the allocated IP resources for this AS with a \"not announced\" remark\n\t\t\t\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t\t\t\t[[ -n \"$json_ipv4_other_inetnums\" ]] && json_ipv4_other_inetnums+=\",\"\n\t\t\t\t\t\tjson_ipv4_other_inetnums+=\"{\\\"prefix\\\":\\\"$prefix\\\",\\\"origin_asn\\\":\\\"\\\",\\\"origin_org\\\":\\\"\\\", \\\"is_announced\\\":false}\"\n\t\t\t\t\telif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t\t\t# skip colors, they will be added along with hyperlinks later\n\t\t\t\t\t\tipv4_inetnums+=$(printf \"%-18s → not announced\" \"$prefix\")\n\t\t\t\t\t\tipv4_inetnums+=\"\\n\"\n\t\t\t\t\telse\n\t\t\t\t\t\tipv4_inetnums+=$(printf \"${dim}%-18s → ${red}not announced${default}${green}\" \"$prefix\")\n\t\t\t\t\t\tipv4_inetnums+=\"\\n\"\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t# prefix is announced by a different AS, add this prefix to the allocated IP resources for this AS\n\t\t\t\t\tprefix_originator_org=$(echo \"$single_prefix_data\" | cut -d '|' -f 3)\n\t\t\t\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t\t\t\t[[ -n \"$json_ipv4_other_inetnums\" ]] && json_ipv4_other_inetnums+=\",\"\n\t\t\t\t\t\tjson_ipv4_other_inetnums+=\"{\\\"prefix\\\":\\\"$prefix\\\",\\\"origin_asn\\\":\\\"$prefix_originator_asn\\\",\\\"origin_org\\\":\\\"$prefix_originator_org\\\", \\\"is_announced\\\":true}\"\n\t\t\t\t\telif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t\t\t# skip colors, they will be added along with hyperlinks later\n\t\t\t\t\t\tipv4_inetnums+=$(printf \"%-18s → announced by AS%s %s\" \"$prefix\" \"${prefix_originator_asn}\" \"${prefix_originator_org}\")\n\t\t\t\t\t\tipv4_inetnums+=\"\\n\"\n\t\t\t\t\telse\n\t\t\t\t\t\tipv4_inetnums+=$(printf \"%-18s ${dim}→ announced by ${default}${red}AS%s ${default}${green}%s\" \"$prefix\" \"${prefix_originator_asn}\" \"${prefix_originator_org}\")\n\t\t\t\t\t\tipv4_inetnums+=\"\\n\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\t\t((prefixcounter++))\n\t\t\tdone\n\t\t\t# OLD WAY (one lookup per prefix)\n\t\t\t# for prefix in $pwhois_unique_prefixes; do\n\t\t\t# \t# found a new prefix in pWhois, check if it's announced by a different AS\n\t\t\t# \t# (e.g. target AS has delegated announcements for this prefix to another AS)\n\t\t\t# \t((prefixcounter++))\n\t\t\t# \tStatusbarMessage \"Identifying origin AS for additional IPv4 prefix $prefixcounter/$pwhois_unique_prefixes_count\"\n\t\t\t# \tLookupASNAndRouteFromIP \"$prefix\"\n\t\t\t# \tprefix_originator_asn=\"$found_asn\"\n\t\t\t# \tif [ -z \"$prefix_originator_asn\" ] || [ \"$prefix_originator_asn\" = \"$1\" ]; then\n\t\t\t# \t\t# prefix originator is same as target AS, or prefix not announced\n\t\t\t# \t\t# add this prefix to the allocated IP resources for this AS\n\t\t\t# \t\tipv4_inetnums+=\"$prefix\\n\"\n\t\t\t# \telse\n\t\t\t# \t\t# this prefix is allocated to target AS, but is being announced by a different AS\n\t\t\t# \t\tprefix_originator_org=$(docurl -m5 -s \"https://stat.ripe.net/data/as-overview/data.json?resource=AS${found_asn}&sourceapp=nitefood-asn\" | \\\n\t\t\t# \t\t\tjq -r 'select (.data.holder != null) | .data.holder' | \\\n\t\t\t# \t\t\tawk -F' - ' '{ if ( $2 ) {print $2} else {print} }' \\\n\t\t\t# \t\t)\n\t\t\t# \t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t# \t\t\t[[ -n \"$json_ipv4_other_inetnums\" ]] && json_ipv4_other_inetnums+=\",\"\n\t\t\t# \t\t\tjson_ipv4_other_inetnums+=\"{\\\"prefix\\\":\\\"$prefix\\\",\\\"origin_asn\\\":\\\"$prefix_originator_asn\\\",\\\"origin_org\\\":\\\"$prefix_originator_org\\\"}\"\n\t\t\t# \t\telse\n\t\t\t# \t\t\tipv4_inetnums+=\"$prefix (announced by AS${prefix_originator_asn} - ${prefix_originator_org})\\n\"\n\t\t\t# \t\tfi\n\t\t\t# \tfi\n\t\t\t# done\n\t\tfi\n\tfi\n\n\tif [ -n \"$ipv4_inetnums\" ]; then\n\t\tipv4_inetnums=$(echo -e \"$ipv4_inetnums\" | sort -iu)\n\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t# HTML output\n\t\t\thtml=\"\"\n\t\t\tfor inetnum in $ipv4_inetnums; do\n\t\t\t\tif grep -q \"announced by\" <<<\"$inetnum\"; then\n\t\t\t\t\t# handle special case \"<prefix> → announced by AS<asn>\"\n\t\t\t\t\tactual_inetnum=${inetnum:0:18}\n\t\t\t\t\toriginator=$(cut -d ' ' -f 7 <<<\"$inetnum\")\n\t\t\t\t\trest_of_line=$(cut -d ' ' -f 8- <<<\"$inetnum\")\n\t\t\t\t\thtml+=\"<a href=\\\"/asn_lookup&$actual_inetnum\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlgreen;\\\">$actual_inetnum</a>\"\n\t\t\t\t\thtml+=\"<span style=\\\"font-style: italic; color: $htmldarkgreen\\\"> → announced by </span>\"\n\t\t\t\t\thtml+=\"<a href=\\\"/asn_lookup&$originator\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlred;\\\">$originator</a> ${rest_of_line}\\n\"\n\t\t\t\telif grep -q \"not announced\" <<<\"$inetnum\"; then\n\t\t\t\t\t# handle special case \"<prefix> → not announced\"\n\t\t\t\t\tactual_inetnum=${inetnum:0:18}\n\t\t\t\t\thtml+=\"<a href=\\\"/asn_lookup&$actual_inetnum\\\" class=\\\"hidden_underline\\\" style=\\\"font-style: italic; color: $htmldarkgreen;\\\">$actual_inetnum</a>\"\n\t\t\t\t\thtml+=\"<span style=\\\"font-style: italic; color: $htmldarkred\\\"> → not announced</span>\\n\"\n\t\t\t\telse\n\t\t\t\t\thtml+=\"<a href=\\\"/asn_lookup&$inetnum\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlgreen;\\\">$inetnum</a>\\n\"\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tipv4_inetnums=\"$html\"\n\t\tfi\n\tfi\n\tif [ -n \"$ipv6_inetnums\" ]; then\n\t\tipv6_inetnums=$(echo -e \"$ipv6_inetnums\" | sort -u)\n\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\thtml=\"\"\n\t\t\tfor inet6num in $ipv6_inetnums; do\n\t\t\t\thtml+=\"<a href=\\\"/asn_lookup&$inet6num\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlyellow;\\\">$inet6num</a>\\n\"\n\t\t\tdone\n\t\t\tipv6_inetnums=\"$html\"\n\t\tfi\n\tfi\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\tjson_ipv4_aggregated_inetnums=$(jq -cM --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$ipv4_inetnums\")\n\t\tjson_ipv6_aggregated_inetnums=$(jq -cM --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$ipv6_inetnums\")\n\tfi\n\tStatusbarMessage\n}\n\nRIPESuggestASN(){\n\tTRIM_WHITESPACES=false\n\tinput=$(tr '[:lower:]' '[:upper:]' <<<\"$1\")\n\tripe_suggest_output=\"\"\n\twhile true; do\n\t\tfor input_variation in \"${input}\" \"AS_${input}\" \"AS-${input}\" \"${input}_AS\" \"${input}-AS\"; do\n\t\t\tStatusbarMessage \"Retrieving suggested ASNs for ${bluebg}${input_variation}${lightgreybg}\"\n\t\t\t# lookup input variation (AS_<input>, AS-<input>, <input>_AS, <input>-AS)\n\t\t\tripe_suggest_output+=$(docurl -s \"https://stat.ripe.net/data/searchcomplete/data.json?resource=${input_variation}&sourceapp=nitefood-asn\" | \\\n\t\t\t\t\t\t\t\t\tjq -r '.data.categories[] | select ( .category == \"ASNs\" ) | .suggestions[]')\n\t\tdone\n\t\tStatusbarMessage\n\t\tif [ -n \"$ripe_suggest_output\" ]; then\n\t\t\tfound_suggestions=$(jq -r '.description' <<<\"$ripe_suggest_output\" | sort -u)\n\t\t\tfor suggestion in $found_suggestions; do\n\t\t\t\techo -e \"\\n${green}$suggestion${default}\"\n\t\t\t\tfor suggestion_asn in $(jq -r 'select (.description==\"'\"$suggestion\"'\") | .value' <<<\"$ripe_suggest_output\" | awk 'NR==1{print}'); do\n\t\t\t\t\techo -en \"\\t${yellow}$suggestion_asn${default} (Rank: \"\n\t\t\t\t\tGetCAIDARank \"${suggestion_asn:2}\"\n\t\t\t\t\techo -en \"${caida_asrank_recap}\"\n\t\t\t\t\techo \"${default})\"\n\t\t\t\tdone\n\t\t\tdone\n\t\t\techo \"\"\n\t\t\treturn\n\t\telif [ \"$TRIM_WHITESPACES\" = false ]; then\n\t\t\tTRIM_WHITESPACES=true\n\t\t\toldinput=\"$input\"\n\t\t\t# shellcheck disable=SC2001\n\t\t\tinput=$(echo \"$oldinput\" | sed 's/[ \\t]*//g')\n\t\t\tif [ \"$input\" = \"$oldinput\" ]; then\n\t\t\t\techo -e \"\\n${redbg}No suggestions found${default}\\n\"\n\t\t\t\treturn\n\t\t\telse\n\t\t\t\tcontinue\n\t\t\tfi\n\t\telse\n\t\t\techo -e \"\\n${redbg}No suggestions found${default}\\n\"\n\t\t\treturn\n\t\tfi\n\tdone\n}\n\nWhoisIP(){\n\t# $1: (mandatory) IP to lookup\n\t# $2: (optional) if set to anything, only perform a generic whois lookup (skip pWhois/RPKI/IXP lookups)\n\t[[ \"$JSON_OUTPUT\" = true ]] && ((json_resultcount++))\n\tGENERIC_WHOIS_LOOKUP_ONLY=false\n\t[[ \"$#\" -gt 1 ]] && GENERIC_WHOIS_LOOKUP_ONLY=true\n\tfull_whois_data=$(timeout 5 whois \"$1\" 2>/dev/null)\n\tnetwork_whois_data=$(echo -e \"$full_whois_data\" | grep -i -E \"^netname:|^orgname:|^org-name:|^owner:|^descr:|^country:\")\n\t# fetch whois inetnum and later compare to cymru prefix, in order to find smallest match (sometimes whois and cymru/pwhois prefix data diverge)\n\twhois_inetnum=$(IpcalcDeaggregate \"$(grep -E -m1 \"inet[6]?num|NetRange\"<<<\"$full_whois_data\" | awk '{print $2 $3 $4}')\")\n\t# handle problematic IPs where whois gives out wrong info\n\t[[ \"$whois_inetnum\" = \"192.168.1.1/32\" ]] && whois_inetnum=\"$found_route\"\n\tixp_data=\"\"\n\tixp_geo=\"\"\n\tip_type_json_output=\"\"\n\t# Check if input is a bogon address\n\tif [ \"$IS_BOGON\" = false ]; then\n\t\tip_type_json_output+=\"\\\"is_bogon\\\":false\"\n\t\tif [ \"$GENERIC_WHOIS_LOOKUP_ONLY\" = false ]; then\n\t\t\thostname=$(RdnsLookup \"$1\")\n\t\t\t[[ -z \"$hostname\" ]] && hostname=\"-\"\n\t\t\tabuse_whois_data=$(echo -e \"$full_whois_data\" | grep -E \"^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:\")\n\t\t\tabusecontacts=$(AbuseLookupForPrefix \"$abuse_whois_data\" \"$1\")\n\t\tfi\n\t\tif [ \"$UNANNOUNCED_PREFIX\" = false ] && [ \"$GENERIC_WHOIS_LOOKUP_ONLY\" = false ]; then\n\t\t\t# Prefix found in the Team Cymru DB, perform pWhois lookup and CAIDA rank lookup\n\t\t\tPwhoisLookup \"$1\"\n\t\t\tGetCAIDARank \"$found_asn\"\n\t\telse\n\t\t\t# No data in the Team Cymru DB for this IP (unannounced prefix), or pWhois being skipped\n\t\t\tif [ \"$GENERIC_WHOIS_LOOKUP_ONLY\" = false ]; then\n\t\t\t\t[[ -z \"$network_whois_data\" ]] && PrintErrorAndExit \"Error: no data found for $input\"\n\t\t\t\tfound_asn=\"N/A (address not announced)\"\n\t\t\t\tfound_asname=\"\"\n\t\t\tfi\n\t\t\tIPGeoRepLookup \"$1\"\n\t\t\tIPShodanLookup \"$1\"\n\t\t\t# check if it's an IXP, otherwise fall back to generic whois\n\t\t\t[[ \"$GENERIC_WHOIS_LOOKUP_ONLY\" = false ]] && IsIXP \"$1\"\n\t\t\tif [ -n \"$ixp_data\" ]; then\n\t\t\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t\t\tpwhois_org=\"$ixp_data\"\n\t\t\t\telse\n\t\t\t\t\tpwhois_org=\"${bluebg} IXP ${default} ${blue}${ixp_data}${default}\"\n\t\t\t\t\tip_type_data=\" ${yellowbg} Internet Exchange ${default}\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpwhois_org=$(echo -e \"$network_whois_data\" | grep -i -E \"^orgname:|^org-name:|^owner:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//' | while read -r line; do echo -n \"$line / \"; done | sed 's/ \\/ $//')\n\t\t\tfi\n\t\t\t[[ -z \"$pwhois_org\" ]] && pwhois_org=\"N/A\"\n\t\t\tfound_route=$(echo -e \"$network_whois_data\" | grep -i -m2 -E \"^descr:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//' | while read -r line; do if [ -n \"$line\" ]; then echo -n \"$line / \"; fi; done | sed 's/ \\/ $//')\n\t\t\t[[ -z \"$found_route\" ]] && found_route=\"N/A\"\n\t\t\tpwhois_net=$(echo -e \"$network_whois_data\" | grep -i -E \"^netname:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//' | while read -r line; do echo -n \"$line / \"; done | sed 's/ \\/ $//')\n\t\t\t[[ -z \"$pwhois_net\" ]] && pwhois_net=\"N/A\"\n\t\t\tif [ -n \"$ixp_geo\" ]; then\n\t\t\t\tpwhois_geo=\"$ixp_geo\"\n\t\t\telif [ -n \"$ip_geo_data\" ]; then\n\t\t\t\tpwhois_geo=\"$ip_geo_data\"\n\t\t\telse\n\t\t\t\tpwhois_geo=$(echo -e \"$network_whois_data\" | grep -m1 -i -E \"^country:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//')\n\t\t\t\tgeo_cc_json_output=\"$pwhois_geo\"\n\t\t\tfi\n\t\t\t[[ -z \"$pwhois_geo\" ]] && pwhois_geo=\"N/A\"\n\t\tfi\n\t[[ -n \"$ixp_data\" ]] &&\tip_type_json_output+=\",\\\"is_ixp\\\":true\" || ip_type_json_output+=\",\\\"is_ixp\\\":false\"\n\telse\n\t\t# bogon address, skip lookups\n\t\tip_type_json_output+=\"\\\"is_bogon\\\":true\"\n\t\tip_type_json_output+=\",\\\"bogon_type\\\":\\\"$json_bogon_type\\\"\"\n\t\thostname=\"-\"\n\t\tfound_asn=\"-\"\n\t\tpwhois_org=\"IANA\"\n\t\tfound_route=\"N/A\"\n\t\tabusecontacts=\"-\"\n\t\tpwhois_net=$(echo -e \"$network_whois_data\" | grep -i -E \"^netname:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//' | while read -r line; do echo -n \"$line / \"; done | sed 's/ \\/ $//')\n\t\tfound_asname=\"\"\n\t\tip_type_data=\" $bogon_tag\"\n\t\tpwhois_geo=\"-\"\n\t\tip_rep_data=\"-\"\n\tfi\n\n\tindent=$(( longest+4 ))\n\tif [ -n \"$found_asname\" ]; then\n\t\toutput_asname=\"${green}($found_asname)\"\n\telse\n\t\toutput_asname=\"\"\n\tfi\n\trpki_output=\"\"\n\tif [ \"$UNANNOUNCED_PREFIX\" = false ] && [ \"$GENERIC_WHOIS_LOOKUP_ONLY\" = false ]; then\n\t\t# we skip RPKI lookup in both cases because if SKIP_WHOIS=true then we're being\n\t\t# called from TraceASPath, and RPKI lookup will be performed there subsequently\n\t\tStatusbarMessage \"Checking RPKI validity for ${bluebg}AS${found_asn}${lightgreybg} and prefix ${bluebg}${found_route}${lightgreybg}\"\n\t\tRPKILookup \"$found_asn\" \"$found_route\"\n\t\tStatusbarMessage\n\t\t[[ \"$JSON_OUTPUT\" = false ]] && echo \"\"\n\telif [ \"$IS_BOGON\" = false ]; then\n\t\trpki_output=\"${red}N/A (address not announced)${default}\"\n\telse\n\t\trpki_output=\"-\"\n\tfi\n\n\tfound_subprefix=\"$found_route\"\n\twhois_routename=\"\"\n\t# compare cymru net with whois net and pick longer (smaller), while retaining larger for route information.\n\t# we want to identify subnets to which target IPs belong, even when they aren't\n\t# announced directly but within a larger route.\n\tif [ \"$found_route\" != \"N/A\" ] && [ \"$found_route\" != \"$whois_inetnum\" ]; then\n\t\tfoundroute_prefixlen=$(cut -d '/' -f 2 <<<\"$found_route\")\n\t\twhois_prefixlen=$(cut -d '/' -f 2 <<<\"$whois_inetnum\")\n\t\tif (( whois_prefixlen > foundroute_prefixlen )) 2>/dev/null; then\n\t\t\tfound_subprefix=\"$whois_inetnum\"\n\t\t\t# lookup route name (RIPE)\n\t\t\twhois_routename=$(timeout 5 whois \"$found_route\" | grep -m1 -E \"^descr:\" | cut -d ':' -f 2 | sed 's/^ *//g')\n\t\tfi\n\tfi\n\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t# JSON output\n\t\tfinal_json_output+=\"{\"\n\t\tfinal_json_output+=\"\\\"ip\\\":\\\"$1\\\",\"\n\t\tgrep -q \":\" <<<\"$1\" && ipversion=\"6\" || ipversion=\"4\"\n\t\tfinal_json_output+=\"\\\"ip_version\\\":\\\"$ipversion\\\",\"\n\t\t[[ \"$hostname\" != \"-\" ]] && final_json_output+=\"\\\"reverse\\\":\\\"$hostname\\\",\"\n\t\tfinal_json_output+=\"\\\"org_name\\\":\\\"$pwhois_org\\\",\"\n\t\t# next field can be == $found_route or can be different (smaller) in case the IP belongs to a subnet (of $found_route) that's not routed directly\n\t\tfinal_json_output+=\"\\\"net_range\\\":\\\"$found_subprefix\\\",\"\n\t\tfinal_json_output+=\"\\\"net_name\\\":\\\"$pwhois_net\\\",\"\n\t\tif [ -n \"$abusecontacts\" ] && [ \"$abusecontacts\" != \"-\" ]; then\n\t\t\tfinal_json_output+=\"\\\"abuse_contacts\\\":$abusecontacts,\"\n\t\tfi\n\t\tfinal_json_output+=\"\\\"routing\\\":{\"\n\t\tif [ -n \"$found_asname\" ]; then\n\t\t\tfinal_json_output+=\"\\\"is_announced\\\":true,\"\n\t\t\tfinal_json_output+=\"\\\"as_number\\\":\\\"$found_asn\\\",\"\n\t\t\tfinal_json_output+=\"\\\"as_name\\\":\\\"${found_asname//\\\"/\\\\\\\"}\\\",\"\n\t\t\tfinal_json_output+=\"\\\"as_rank\\\":\\\"${caida_asrank//\\\"/\\\\\\\"}\\\",\"\n\t\t\tfinal_json_output+=\"\\\"route\\\":\\\"$found_route\\\",\"\n\t\t\tfinal_json_output+=\"\\\"route_name\\\":\\\"$whois_routename\\\",\"\n\t\t\tfinal_json_output+=\"\\\"roa_count\\\":\\\"$roacount_json_output\\\",\"\n\t\t\tfinal_json_output+=\"\\\"roa_validity\\\":\\\"$roavalidity_json_output\\\"\"\n\t\telse\n\t\t\tfinal_json_output+=\"\\\"is_announced\\\":false,\"\n\t\t\tif [ \"$found_route\" != \"N/A\" ]; then\n\t\t\t\tfinal_json_output+=\"\\\"net_name\\\":\\\"$found_route ($pwhois_net)\\\"\"\n\t\t\telse\n\t\t\t\tfinal_json_output+=\"\\\"net_name\\\":\\\"$pwhois_net\\\"\"\n\t\t\tfi\n\t\tfi\n\t\tfinal_json_output+=\"},\\\"type\\\":{$ip_type_json_output}\"\n\t\tif [ \"$IS_BOGON\" != true ]; then\n\t\t\tfinal_json_output+=\",\\\"geolocation\\\":{\"\n\t\t\tfinal_json_output+=\"\\\"city\\\":\\\"$geo_city_json_output\\\",\"\n\t\t\tfinal_json_output+=\"\\\"region\\\":\\\"$geo_region_json_output\\\",\"\n\t\t\tfinal_json_output+=\"\\\"country\\\":\\\"$geo_country_json_output\\\",\"\n\t\t\tfinal_json_output+=\"\\\"cc\\\":\\\"$geo_cc_json_output\\\"\"\n\t\t\tfinal_json_output+=\"}\"\n\t\tfi\n\telse\n\t\t# Normal output\n\t\tprintf \"${white}%${longest}s${default} ┌${bluebg}PTR${default} %s\\n\" \"$1\" \"$hostname\"\n\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ -n \"$found_asname\" ]; then\n\t\t\tsummary_asn=\"<a href=\\\"/asn_lookup&AS$found_asn\\\" style=\\\"color: $htmlred;\\\">$found_asn</a>\"\n\t\t\tipinfolink=\"<a href=\\\"https://ipinfo.io/AS$found_asn/$found_route\\\" target=\\\"_blank\\\" style=\\\"color: $htmlyellow; font-style: italic;\\\">ipinfo.io</a>\"\n\t\t\tsummary_ipinfo=\" <span style=\\\"font-size: 75%; color: $htmlyellow;\\\">($ipinfolink🔗)</span>\"\n\t\telse\n\t\t\tsummary_asn=\"$found_asn\"\n\t\t\tsummary_ipinfo=\"\"\n\t\tfi\n\t\tprintf \"${white}%${indent}s${bluebg}ASN${default} ${red}%s %s${default}\\n\" \"├\" \"$summary_asn\" \"$output_asname\"\n\t\t[[ \"$UNANNOUNCED_PREFIX\" = false ]] && printf \"${white}%${indent}s${bluebg}RNK${default} ${default}%s${default}\\n\" \"├\" \"$caida_asrank_recap\"\n\t\tprintf \"${white}%${indent}s${bluebg}ORG${default} ${green}%s${default}\\n\" \"├\" \"$pwhois_org\"\n\t\tif [ \"$found_subprefix\" != \"$found_route\" ]; then\n\t\t\t# target IP belongs to a subnet announced within a larger route\n\t\t\tprintf \"${white}%${indent}s${bluebg}NET${default} ${yellow}%s (%s)${default}\\n\" \"├\" \"$found_subprefix\" \"$pwhois_net\"\n\t\t\t[[ -n \"$whois_routename\" ]] && whois_routename=\" ($whois_routename)\"\n\t\t\tprintf \"${white}%${indent}s${bluebg}ROU${default} ${yellow}%s%s%s${default}\\n\" \"├\" \"$found_route\" \"$whois_routename\" \"$summary_ipinfo\"\n\t\telse\n\t\t\t# target IP belongs to a subnet announced directly\n\t\t\tprintf \"${white}%${indent}s${bluebg}NET${default} ${yellow}%s (%s)%s${default}\\n\" \"├\" \"$found_subprefix\" \"$pwhois_net\" \"$summary_ipinfo\"\n\t\tfi\n\t\tprintf \"${white}%${indent}s${bluebg}ABU${default} ${blue}%s${default}\\n\" \"├\" \"$abusecontacts\"\n\t\tprintf \"${white}%${indent}s${bluebg}ROA${default} %s\\n\" \"├\" \"$rpki_output\"\n\t\t[[ -n \"$ip_type_data\" ]] && printf \"${white}%${indent}s${bluebg}TYP${default}%s\\n\" \"├\" \"${ip_type_data}\"\n\t\tprintf \"${white}%${indent}s${bluebg}GEO${default} ${magenta}%s${default}\" \"├\" \"$pwhois_geo\"\n\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ -n \"$flag_icon_cc\" ]; then\n\t\t\t# signal to the parent connhandler the correct country flag to display for this IP\n\t\t\techo -n \" #COUNTRYCODE $flag_icon_cc\"\n\t\tfi\n\t\tprintf \"\\n\"\n\tfi\n}\n\nIsBogon(){\n\tbogon_tag=\"\"\n\tIS_BOGON=false\n\t# Bogon regex patterns\n\tlocalhostregex='(^127\\.)' # RFC 1122 localhost\n\tthisnetregex='(^0\\.)' # RFC 1122 'this' network\n\tprivateregex='(^192\\.168\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^::1$)|(^[fF][cCdD])' # RFC 1918 private space - cheers https://stackoverflow.com/a/11327345/5377165\n\tcgnregex='(^100\\.6[4-9]\\.)|(^100\\.[7-9][0-9]\\.)|(^100\\.1[0-1][0-9]\\.)|(^100\\.12[0-7]\\.)' # RFC 6598 Carrier grade nat space\n\tllregex='(^169\\.254\\.)' # RFC 3927 link local\n\tietfprotoregex='(^192\\.0\\.0\\.)' # IETF protocol assignments\n\ttestnetregex='(^192\\.0\\.2\\.)|(^198\\.51\\.100\\.)|(^203\\.0\\.113\\.)' # RFC 5737 TEST-NET\n\tbenchmarkregex='(^192\\.1[8-9]\\.)' # RFC 2544 Network interconnect device benchmark testing\n\tsixtofouranycast='(^192\\.88\\.99\\.)' # RFC 7526 6to4 anycast relay\n\tmulticastregex='(^22[4-9]\\.)|(^23[0-9]\\.)' # Multicast\n\treservedregex='(^24[0-9]\\.)|(^25[0-5]\\.)' # Reserved for future use/limited broadcast (255.255.255.255)\n\n\tif [[ \"$1\" =~ $localhostregex ]]; then\n\t\tbogon_tag=\"rfc1122 (Localhost)\"\n\t\tMTR_TRACING=false\n\telif [[ \"$1\" =~ $thisnetregex ]]; then\n\t\tbogon_tag=\"rfc1122 ('this' network)\"\n\t\tMTR_TRACING=false\n\telif [[ \"$1\" =~ $privateregex ]]; then\n\t\tbogon_tag=\"rfc1918 (Private Space)\"\n\telif [[ \"$1\" =~ $cgnregex ]]; then\n\t\tbogon_tag=\"rfc6598 (CGN Space)\"\n\telif [[ \"$1\" =~ $llregex ]]; then\n\t\tbogon_tag=\"rfc3927 (Link-Local)\"\n\telif [[ \"$1\" =~ $ietfprotoregex ]]; then\n\t\tbogon_tag=\"(Reserved for IETF protocol assignments)\"\n\telif [[ \"$1\" =~ $testnetregex ]]; then\n\t\tbogon_tag=\"rfc5737 (Reserved for Test Networks)\"\n\telif [[ \"$1\" =~ $benchmarkregex ]]; then\n\t\tbogon_tag=\"rfc2544 (Reserved for Network device benchmark testing)\"\n\telif [[ \"$1\" =~ $sixtofouranycast ]]; then\n\t\tbogon_tag=\"rfc7526 (6to4 anycast relay)\"\n\telif [[ \"$1\" =~ $multicastregex ]]; then\n\t\tbogon_tag=\"(Multicast Address)\"\n\t\tMTR_TRACING=false\n\telif [[ \"$1\" =~ $reservedregex ]]; then\n\t\tbogon_tag=\"(Reserved Address)\"\n\t\tMTR_TRACING=false\n\tfi\n\tif [ -n \"$bogon_tag\" ]; then\n\t\tIS_BOGON=true\n\t\tjson_bogon_type=\"$bogon_tag\"\n\t\tbogon_tag=\"${yellowbg} BOGON ${default} ${bogon_tag}\"\n\tfi\n}\n\nLookupASNAndRouteFromIP(){\n\tfound_asn=\"\"\n\tfound_route=\"\"\n\tfound_asname=\"\"\n\tIsBogon \"$1\"\n\tif [ \"$IS_BOGON\" = false ]; then\n\t\tif echo \"$1\" | grep -q ':'; then\n\t\t\t# whois query for IPv6 addresses\n\t\t\toutput=$(whois -h whois.cymru.com \" -f -p -u $1\" | sed 's/\\ *|\\ */|/g')\n\t\t\tfound_asn=$(echo \"$output\" | awk -F'[|]' 'NR==1{print $1}')\n\t\t\tif [ \"$found_asn\" = \"NA\" ]; then\n\t\t\t\t# Team Cymru has no data for this IPv6. Inform WhoisIP() that we will have to fall back to a generic whois lookup.\n\t\t\t\tfound_asn=\"\"\n\t\t\t\tUNANNOUNCED_PREFIX=true\n\t\t\telse\n\t\t\t\tfound_asname=$(echo \"$output\" | awk -F'[|]' 'NR==1{print $4}')\n\t\t\t\tfound_route=$(echo \"$output\" | awk -F'[|]' 'NR==1{print $3}')\n\t\t\t\tUNANNOUNCED_PREFIX=false\n\t\t\t\t# lookup CAIDA rank info for the origin AS\n\t\t\t\tGetCAIDARank \"$found_asn\"\n\t\t\tfi\n\t\telse\n\t\t\t# Query RIPEStat for IPv4 addresses\n\t\t\toutput=$(docurl -m5 -s \"https://stat.ripe.net/data/prefix-overview/data.json?resource=$1&sourceapp=nitefood-asn\")\n\t\t\tif jq -r '.data.announced' <<<\"$output\" | grep -q \"true\"; then\n\t\t\t\tfound_asn=$(jq -r '.data.asns[0].asn' <<<\"$output\")\n\t\t\t\tfound_asname=$(jq -r '.data.asns[0].holder' <<<\"$output\")\n\t\t\t\t# look up the country this ASN is located in\n\t\t\t\tcountry=$(docurl -m5 -s \"https://stat.ripe.net/data/rir-stats-country/data.json?resource=AS${found_asn}\" | jq -r '.data.located_resources[0].location')\n\t\t\t\t[[ \"$country\" != \"null\" ]] && found_asname=\"${found_asname}, ${country}\"\n\t\t\t\tfound_route=$(jq -r '.data.resource' <<<\"$output\")\n\t\t\t\tUNANNOUNCED_PREFIX=false\n\t\t\telse\n\t\t\t\t# RIPEStat has no data for this IPv4. Fallback to Team Cymru DNS query (faster than whois)\n\t\t\t\trev=$(echo \"$1\" | cut -d '/' -f 1 | awk -F'.' '{printf $4 \".\" $3 \".\" $2 \".\" $1}')\n\t\t\t\toutput=$(host -t TXT \"$rev.origin.asn.cymru.com\" | awk -F'\"' 'NR==1{print $2}' | sed 's/\\ *|\\ */|/g')\n\t\t\t\tfound_asn=$(echo \"$output\" | awk -F'[|]' 'NR==1{print $1}' | cut -d ' ' -f 1) # final cut gets first origin AS only if cymru has multiple\n\t\t\t\tif [ -n \"$found_asn\" ]; then\n\t\t\t\t\tfound_asname=$(host -t TXT \"AS$found_asn.asn.cymru.com\" | grep -v \"NXDOMAIN\" | awk -F'|' 'NR==1{print substr($NF,2,length($NF)-2)}')\n\t\t\t\t\tfound_route=$(echo \"$output\" | awk -F'[|]' 'NR==1{print $2}')\n\t\t\t\t\tUNANNOUNCED_PREFIX=false\n\t\t\t\telse\n\t\t\t\t# Team Cymru has no data for this IPv4 either. Inform WhoisIP() that we will have to fall back to a generic whois lookup.\n\t\t\t\t\tUNANNOUNCED_PREFIX=true\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\telse\n\t\t# bogon address, consider it unannounced\n\t\tUNANNOUNCED_PREFIX=true\n\tfi\n}\n\nResolveHostnameToIPList(){\n\traw_host_output=$(host \"$1\" 2>/dev/null)\n\tif echo -e \"$raw_host_output\" | grep -q \"mail is handled\"; then\n\t\thost_output=$(echo \"$raw_host_output\" | grep -B100 -A0 -m1 \"mail is handled\" | sed '$d')\n\telse\n\t\thost_output=\"$raw_host_output\"\n\tfi\n\tip=$(echo \"$host_output\" | grep -Eo \"$ipv4v6regex\")\n\techo -e \"$ip\\n\"\n}\n\nPrintErrorAndExit(){\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t# json output\n\t\tstatus_json_output=\"fail\"\n\t\treason_json_output=\"${1//\\\"/\\\\\\\"}\"\n\t\tjson_resultcount=0\n\t\tPrintJsonOutput\n\telif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\techo -e \"\\n${redbg}${1}${default}\\n\" # get the error in the html report\n\t\ttput sgr0\n\telse\n\t\t# normal output\n\t\techo -e \"\\n${redbg}${1}${default}\" >&2\n\t\ttput sgr0\n\tfi\n\texit 1\n}\n\nPrintUsage(){\n\t# if an argument is passed, it will be displayed on stderr and the script will exit with error\n\tscript_name=$(basename \"$0\")\n\tJSON_OUTPUT=false\n\tBoxHeader \"ASN / RPKI validity / BGP stats / IPv4v6 / Prefix / ASPath / Organization / IP reputation lookup tool\" >&2\n\techo -e \"\\nVERSION:\\n\\n  ${ASN_VERSION}\" \\\n\t\t\t\"\\n\\nUSAGE:\\n\\n  $script_name [${green}OPTIONS${default}] [${blue}TARGET${default}]\" \\\n\t\t\t\"\\n  $script_name [${red}-v${default}] ${red}-l${default} [${red}SERVER OPTIONS${default}]\" \\\n\t\t\t\"\\n\\nOPTIONS:\" \\\n\t\t\t\"\\n\\n  ${green}-t    (enable trace)\\n\\t${default}Enable AS path trace to the ${blue}TARGET${default} (this is the default behavior)\" \\\n\t\t\t\"\\n\\n  ${green}-n    (no trace|no additional INETNUM lookups)\\n\\t${default}Disable tracing the AS path to the ${blue}TARGET${default} (for IP targets) or\" \\\n\t\t\t\"\\n\\tDisable additional (unannounced / announced by other AS) INETNUM lookups for the ${blue}TARGET${default} (for AS targets)\" \\\n\t\t\t\"\\n\\n  ${green}-d    (detailed)\\n\\t${default}Output detailed hop info during the AS path trace to the ${blue}TARGET${default}\" \\\n\t\t\t\"\\n\\tThis option also enables RPKI validation/BGP hijacking detection for every hop\" \\\n\t\t\t\"\\n\\n  ${green}-a    (ASN Suggest)\\n\\t${default}Lookup AS names and numbers matching ${blue}TARGET${default}\" \\\n\t\t\t\"\\n\\n  ${green}-u    (Transit/Upstream lookup)\\n\\t${default}Inspect BGP updates and ASPATHs for the ${blue}TARGET${default} address/prefix and identify possible transit/upstream autonomous systems\" \\\n\t\t\t\"\\n\\n  ${green}-c    (Country CIDR)\\n\\t${default}Lookup all IPv4/v6 CIDR blocks allocated to the ${blue}TARGET${default} country\" \\\n\t\t\t\"\\n\\n  ${green}-g    (Bulk Geolocate)\\n\\t${default}Geolocate all IPv4/v6 addresses passed as ${blue}TARGET${default}\" \\\n\t\t\t\"\\n\\tThis mode supports multiple targets, stdin input and IP extraction from input, e.g.\" \\\n\t\t\t\"\\n\\t'asn -g < /var/log/apache2/error.log' or 'echo 1.1.1.1 2.2.2.2 | asn -g'\" \\\n\t\t\t\"\\n\\n  ${green}-s    (Shodan scan)\\n\\t${default}Query Shodan's InternetDB for CVE/CPE/Tags/Ports/Hostnames data about ${blue}TARGET${default}\" \\\n\t\t\t\"\\n\\tThis mode supports multiple targets and stdin input, e.g.\" \\\n\t\t\t\"\\n\\t'asn -s < iplist' or 'echo 1.1.1.0/24 google.com | asn -s'\" \\\n\t\t\t\"\\n\\n  ${green}-o    (organization search)\\n\\t${default}Force ${blue}TARGET${default} to be treated as an Organization Name\" \\\n\t\t\t\"\\n\\n  ${green}-m    (monochrome output)\\n\\t${default}Disable colored output\" \\\n\t\t\t\"\\n\\n  ${green}-v    (verbose)\\n\\t${default}Enable (and log to \\$HOME/asndebug.log) debug messages (URLs being queried and variable names being assigned).\" \\\n\t\t\t\"\\n\\tAPI call response data (i.e. the JSON output) is logged to the logfile.${default}\" \\\n\t\t\t\"\\n\\n  ${green}-j    (compact JSON output)\\n\\t${default}Set output to compact JSON mode (ideal for machine parsing)\" \\\n\t\t\t\"\\n\\n  ${green}-J    (pretty-printed JSON output)\\n\\t${default}Set output to pretty-printed JSON mode\" \\\n\t\t\t\"\\n\\n  ${green}-h    (help)\\n\\t${default}Show this help screen\" \\\n\t\t\t\"\\n\\n  ${red}-l    (lookup server)\\n\\t${default}Launch the script in server mode. See ${red}SERVER OPTIONS${default} below\" \\\n\t\t\t\"\\n\\nTARGET:\" \\\n\t\t\t\"\\n\\n  ${blue}<AS Number>${default}\\n\\tLookup matching ASN and BGP announcements/neighbours data.\" \\\n\t\t\t\"\\n\\t(Supports \\\"as123\\\" and \\\"123\\\" formats - case insensitive)\" \\\n\t\t\t\"\\n\\n  ${blue}<IPv4/IPv6>${default}\\n\\tLookup matching route(4/6), IP reputation and ASN data\" \\\n\t\t\t\"\\n\\n  ${blue}<Prefix>${default}\\n\\tLookup matching ASN data\" \\\n\t\t\t\"\\n\\n  ${blue}<host.name.tld>${default}\\n\\tLookup matching IP, route and ASN data. Supports multiple IPs - e.g. DNS RR\" \\\n\t\t\t\"\\n\\n  ${blue}<URL>${default}\\n\\tExtract hostname/IP from the URL and lookup relative data. Supports any protocol prefix, non-standard ports and prepended credentials\" \\\n\t\t\t\"\\n\\n  ${blue}<Organization Name>${default}\\n\\tSearch by company name and lookup network ranges exported by (or related to) the company\" \\\n\t\t\t\"\\n\\nSERVER OPTIONS:\" \\\n\t\t\t\"\\n\\n  ${red}BIND_ADDRESS${default}\\n\\tIP address (v4/v6) to bind the listening server to (e.g. '$script_name -l 0.0.0.0')\\n\\tDefault value: ${red}${DEFAULT_SERVER_BINDADDR_v4} (IPv4) or ${DEFAULT_SERVER_BINDADDR_v6} (IPv6)${default}\" \\\n\t\t\t\"\\n\\n  ${red}BIND_PORT${default}\\n\\tTCP Port to bind the listening server to (e.g. '$script_name -l 12345')\\n\\tDefault value: ${red}${DEFAULT_SERVER_BINDPORT}${default}\" \\\n\t\t\t\"\\n\\n  ${red}BIND_ADDRESS${default} ${red}BIND_PORT${default}\\n\\tIP address and port to bind the listening server to (e.g. '$script_name -l ::1 12345')\" \\\n\t\t\t\"\\n\\n  ${red}-v    (verbose)\\n\\t${default}Enable verbose output and debug messages in server mode${default}\" \\\n\t\t\t\"\\n\\n  ${red}--allow host[,host,...]\\n\\t${default}Allow only given hosts to connect to the server${default}\" \\\n\t\t\t\"\\n\\n  ${red}--allowfile file\\n\\t${default}A file of hosts allowed to connect to the server${default}\" \\\n\t\t\t\"\\n\\n  ${red}--deny host[,host,...]\\n\\t${default}Deny given hosts from connecting to the server${default}\" \\\n\t\t\t\"\\n\\n  ${red}--denyfile file\\n\\t${default}A file of hosts denied from connecting to the server${default}\" \\\n\t\t\t\"\\n\\n  ${red}-m, --max-conns <n>\\n\\t${default}The maximum number of simultaneous connections accepted by the server. 100 is the default.${default}\" \\\n\t\t\t\"\\n\\n\\n  Note: Every option in server mode (after -l) is passed directly to the ncat listener.\" \\\n\t\t\t\"\\n        Refer to ${blue}man ncat${default} for more details on the available commands.\" \\\n\t\t\t\"\\n        Unless specified, the default IP:PORT values of ${DEFAULT_SERVER_BINDADDR_v4}:${DEFAULT_SERVER_BINDPORT} (for IPv4) or [${DEFAULT_SERVER_BINDADDR_v6}]:${DEFAULT_SERVER_BINDPORT} (for IPv6) will be used (e.g. 'asn -l')\" \\\n\t\t\t\"\\n\\n  Example server usage:\" \\\n\t\t\t\"\\n\\t${blue}asn -l${default}\" \\\n\t\t\t\"\\n\\t  (starts server on default IP(v4/v6):PORT)\\n\" \\\n\t\t\t\"\\n\\t${blue}asn -l 0.0.0.0 --allow 192.168.0.0/24,192.168.1.0/24,192.168.2.245${default}\" \\\n\t\t\t\"\\n\\t  (binds to all availables IPv4 interfaces on the default port, allowing only connections from the three specified subnets)\\n\" \\\n\t\t\t\"\\n\\t${blue}asn -l :: 2222 --allow 2001:DB8::/32${default}\" \\\n\t\t\t\"\\n\\t  (binds to all availables IPv6 interfaces on port 2222, allowing only connections from the specified prefix)\\n\" \\\n\t\t\t\"\\n\\t${blue}asn -v -l 0.0.0.0 --allowfile \\\"~/goodips.txt\\\" -m 5${default}\" \\\n\t\t\t\"\\n\\t  (verbose mode, bind to all IPv4 interfaces, use an allowfile with allowed addresses, accept a maximum of 5 concurrent connections)\\n\" \\\n\t\t\t\"\\n  Bookmarklet configuration page:\" \\\n\t\t\t\"\\n\\tplease visit ${blue}http://127.0.0.1:49200/asn_bookmarklet${default} and follow the instructions. More documentation is available on github (link below).\" \\\n\t\t\t\"\\n\\n\\nProject homepage: ${yellow}https://github.com/nitefood/asn${default}\\n\" >&2\n\n\t[[ -n \"$1\" ]] && PrintErrorAndExit \"$1\"\n}\n\nPwhoisLookup(){\n\tStatusbarMessage \"Collecting pWhois data\"\n\tpwhois_output=$(whois -h whois.pwhois.org \"$1\")\n\tStatusbarMessage\n\tif echo \"$pwhois_output\" | grep -vq \"That IP address doesn't appear\"; then\n\t\t# pwhois_asn=$(echo \"$pwhois_output\" | grep -E \"^Origin-AS\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\t# pwhois_prefix=$(echo \"$pwhois_output\" | grep -E \"^Prefix\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\tpwhois_asorg=$(echo \"$pwhois_output\" | grep -E \"^AS-Org-Name\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\t# group all \"Org-Name\" fields on a single line\n\t\tpwhois_org=$(echo \"$pwhois_output\" | grep -E \"^Org-Name\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//g' | while read -r line; do echo -n \"$line / \"; done | sed 's/ \\/ $//')\n\t\tpwhois_net=$(echo \"$pwhois_output\" | grep -E \"^Net-Name\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\t# if pWhois' Net-Name=Org-Name, then it's more useful to use AS-Org-Name instead of Org-Name (unless AS-Org-Name is empty)\n\t\tif [ -n \"$pwhois_asorg\" ] && [ \"$pwhois_net\" = \"$pwhois_org\" ]; then\n\t\t\tpwhois_org=\"$pwhois_asorg\"\n\t\tfi\n\t\tIPGeoRepLookup \"$1\"\n\t\tIPShodanLookup \"$1\"\n\t\tpwhois_geo=\"$ip_geo_data\"\n\t\tif [ -z \"$ip_geo_data\" ]; then\n\t\t\tif echo \"$pwhois_output\" | grep -q -E \"^Geo-\"; then\n\t\t\t\t# use \"Geo-\" fields in pWhois output\n\t\t\t\tcityfield=\"Geo-City\"\n\t\t\t\tregionfield=\"Geo-Region\"\n\t\t\t\tccfield=\"Geo-CC\"\n\t\t\telse\n\t\t\t\tcityfield=\"City\"\n\t\t\t\tregionfield=\"Region\"\n\t\t\t\tccfield=\"Country-Code\"\n\t\t\tfi\n\t\t\tpwhois_city=$(echo \"$pwhois_output\" | grep -m1 -E \"^${cityfield}\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\t\tpwhois_region=$(echo \"$pwhois_output\" | grep -m1 -E \"^${regionfield}\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\t\tpwhois_cc=$(echo \"$pwhois_output\" | grep -m1 -E \"^${ccfield}\" | cut -d ':' -f 2 | sed 's/^ //')\n\t\t\tflag_icon_cc=$(tr '[:upper:]' '[:lower:]' <<<\"$pwhois_cc\")\n\t\t\tif [ \"$pwhois_city\" = \"NULL\" ] || [ \"$pwhois_region\" = \"NULL\" ]; then\n\t\t\t\tpwhois_geo=\"$pwhois_cc\"\n\t\t\telse\n\t\t\t\tpwhois_geo=\"$pwhois_city, $pwhois_region ($pwhois_cc)\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\tpwhois_output=\"\";\n\tfi\n}\n\nRdnsLookup(){\n\t# reverse DNS (PTR) lookup.\n\t# get first lookup result only (in case of multiple PTR records) and remove trailing dot and CR (Cygwin) from hostname\n\trdns=$(host \"$1\" | awk 'NR==1{sub(/\\.\\r?$/, \"\", $NF); print $NF}')\n\tif echo \"$rdns\" | grep -E -q \"NXDOMAIN|SERVFAIL|REFUSED|^record$\"; then rdns=\"\"; fi\n\techo \"$rdns\"\n}\n\nAbuseLookupForPrefix(){\n\t# $1=\"whois data\", $2=prefix\n\tif [ -n \"$mtr_output\" ] && [ \"$DETAILED_TRACE\" = false ]; then\n\t\t# skip abuse lookup for individual trace hops in non-detailed mode\n\t\treturn\n\tfi\n\twhoisdata=\"$1\"\n\tprefix=\"$2\"\n\tabuselist=\"\"\n\tfor abusecontact in $(echo -e \"$whoisdata\" | grep -E \"^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:\" | awk '{print $NF}' | tr -d \\'); do\n\t\tif ! grep -q '@' <<<\"$abusecontact\"; then\n\t\t\t# the currently parsed abuse contact, found in whois data, is not an email (but likely a NIC handle), fall back to RIPE API\n\t\t\tresolvedabuse=$(docurl -m5 -s \"https://stat.ripe.net/data/abuse-contact-finder/data.json?resource=$2&sourceapp=nitefood-asn\" | jq -r 'select (.data.abuse_contacts != null) | .data.abuse_contacts[]')\n\t\t\tif ! grep -q '@' <<<\"$resolvedabuse\"; then\n\t\t\t\t# RIPE API didn't give back an email, second and last fall back to DSHIELD API\n\t\t\t\tdshield_abuse_contact=$(docurl -m15 -s --user-agent \"nitefood/asn\" https://isc.sans.edu/api/ip/$2?json | jq -r 'select (.ip.asabusecontact != null) | .ip.asabusecontact')\n\t\t\t\tif grep -q '@' <<<\"$dshield_abuse_contact\"; then\n\t\t\t\t\tresolvedabuse=\"$dshield_abuse_contact\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t[[ -n \"$resolvedabuse\" ]] && abusecontact=\"$resolvedabuse\"\n\t\tfi\n\t\t[[ -n \"$abuselist\" ]] && abuselist+=\"\\n\"\n\t\tabuselist+=\"$abusecontact\"\n\tdone\n\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t# json output\n\t\tif [ -n \"$abuselist\" ]; then\n\t\t\techo -e \"$abuselist\" | jq -cM --slurp --raw-input 'split(\"\\n\") | map(select(length > 0)) | unique'\n\t\tfi\n\telse\n\t\t# normal output\n\t\tif [ -n \"$abuselist\" ]; then\n\t\t\t# use jq to join contacts together and separate them with the \" / \" multi-character delimiter, while getting rid of spurious newlines\n\t\t\techo -e \"$abuselist\" | jq -r --slurp --raw-input 'split(\"\\n\") | map(select(length > 0)) | unique | join(\" / \")'\n\t\telse\n\t\t\techo \"-\"\n\t\tfi\n\tfi\n}\n\nHopPrint(){\n\tStatusbarMessage\n\t# shellcheck disable=SC2124\n\toutput=\"$@\"\n\t# create hyperlinks if running in server mode\n\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t[[ -z \"$ixp_tag\" ]] && htmlcolor=\"$htmlwhite\" || htmlcolor=\"$htmlblue\"\n\t\t# extract and trim duplicate IPs from the trace output line\n\t\tfound_ips=$(grep -Eo \"${ipv4v6regex}\" <<<\"$output\" | sort -u)\n\t\tif [ -n \"$found_ips\" ]; then\n\t\t\tfor ip in $found_ips; do\n\t\t\t\t# replace only the last IP in the trace output, so to handle special cases\n\t\t\t\t# where the trace hop PTR contains the full dotted IP, ex:\n\t\t\t\t# 1.2.3.4.domain.name (1.2.3.4) -> 1.2.3.4.domain.name (<href to 1.2.3.4>)\n\t\t\t\toutput=$(sed \"s/\\(.*\\)$ip/\\1<a href=\\\"\\/asn_lookup\\&$ip\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlcolor;\\\">$ip<\\/a>/\" <<<\"$output\")\n\t\t\tdone\n\t\tfi\n\tfi\n\techo -e \"$output\"\n\tStatusbarMessage \"Analyzing collected trace output to ${bluebg}${host_to_trace}${lightgreybg}\"\n}\n\nTraceASPath(){\n\tstarttime=$(date +%s)\n\thost_to_trace=\"$1\"\n\tborder_color=\"$lightblue\"\n\t# attepmt to be as responsive as possible\n\t# ideal output width : 150 (size of headers in normal traces)\n\t# ideal border width : 100 (used in detailed traces only)\n\tif [ \"$terminal_width\" -ge 153 ]; then\n\t\toutput_width=150\n\t\tborder_width=100\n\telif [ \"$terminal_width\" -ge 103 ]; then\n\t\toutput_width=$((terminal_width-3))\n\t\tborder_width=100\n\telse\n\t\toutput_width=$((terminal_width-3))\n\t\tborder_width=$((terminal_width-3))\n\tfi\n\n\tWhatIsMyIP\n\tif [ \"$DETAILED_TRACE\" = true ]; then\n\t\theadermsg=\"Detailed trace to $userinput\"\n\telse\n\t\theadermsg=\"Trace to $userinput\"\n\tfi\n\tBoxHeader \"$headermsg\"\n\t# check if we're trying to trace an IPv6 from an IPv4-only box\n\techo \"$host_to_trace\" | grep -q ':' && is_ipv6=true || is_ipv6=false\n\tif [ \"$is_ipv6\" = true ] && [ \"$HAVE_IPV6\" = false ]; then\n\t\tPrintErrorAndExit \"Error: cannot trace an IPv6 from this IPv4-only host!\"\n\tfi\n\techo \"\"\n\tStatusbarMessage \"Collecting trace data to ${bluebg}${host_to_trace}${lightgreybg}\"\n\n\t# start the mtr trace\n\tDebugPrint \"${yellow}mtr → $host_to_trace ($MTR_ROUNDS rounds)${default}\"\n\tmtr_output=$(mtr -C -n -c\"$MTR_ROUNDS\" \"$host_to_trace\" | tail -n +2)\n\tdeclare -a tracehops_array\n\tdeclare -a aspath_array\n\t# initialize the aspath array with our source AS\n\tif [ \"$HAVE_IPV6\" = true ]; then\n\t\tfound_asn=$(docurl -s \"https://stat.ripe.net/data/whois/data.json?resource=$local_wanip&sourceapp=nitefood-asn\" | jq -r '.data.irr_records[0] | map(select(.key | match (\"origin\"))) | .[].value')\n\t\tWhoisASN \"$found_asn\"\n\telse\n\t\tLookupASNAndRouteFromIP \"$local_wanip\"\n\tfi\n\tif [ -z \"$found_asn\" ]; then\n\t\tfound_asn=\"XXX\"\n\t\tfound_asname=\"(Unknown)\"\n\tfi\n\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\taspatharray_asnvalue=\"<a href=\\\"/asn_lookup&AS$found_asn\\\" style=\\\"color: $htmlred; display:inline-block; width: 4em;\\\">$found_asn</a>\"\n\telse\n\t\taspatharray_asnvalue=\"$found_asn\"\n\tfi\n\t# Retrieve local AS CAIDA rank\n\tGetCAIDARank \"$found_asn\"\n\tif [ -n \"$caida_asrank_text\" ]; then\n\t\taspath_entry=$(printf \"${red}%-6s ${green}%s${default}${dim} •%s${dim}${default}\" \"$aspatharray_asnvalue\" \"$(echo \"$found_asname\" | cut -d ',' -f 1)\" \"$caida_asrank_text\")\n\telse\n\t\taspath_entry=$(printf \"${red}%-6s ${green}%s${default}\" \"$aspatharray_asnvalue\" \"$(echo \"$found_asname\" | cut -d ',' -f 1)\")\n\tfi\n\taspath_array+=(\"$aspath_entry\")\n\n\t# mtr finished, analyze and output results\n\t# print trace headers (only non-detailed trace)\n\tif [ \"$DETAILED_TRACE\" = false ]; then\n\t\tHopPrint \"$(printf \"${lightgreybg}%4s %-$((output_width-61))s %7s %13s     %s                ${default}\" \"Hop\" \"IP Address\" \"Loss%\" \"Ping avg\" \"AS Information\")\"\n\tfi\n\tLAST_HOP=false\n\tROUTING_LOOP=false\n\n\t# parse mtr output (csv)\n\thop_num=0\n\twhile true; do\n\t\t((hop_num++))\n\t\tIFS=',' read -ra cur_hop_data <<< \"$(echo \"$mtr_output\" | head -n \"$hop_num\" | tail -n 1)\"\n\t\tmtr_hopnum=${cur_hop_data[4]}\n\t\t[[ \"$hop_num\" -gt \"$mtr_hopnum\" ]] && break # we're past the last trace hop, quit the loop\n\t\thop_ip=${cur_hop_data[5]}\n\t\thop_loss=${cur_hop_data[6]%.*}\n\t\thop_ping=$(echo \"${cur_hop_data[10]}\" | awk '{ printf (\"%.1f\\n\", $1) }')\n\t\tif [ \"$hop_loss\" -ne 0 ]; then\n\t\t\t# color packet loss yellow if between 1% and 50%, or red if > 50%\n\t\t\t[[ \"$hop_loss\" -le 50 ]] && loss_color=\"$lightyellow\" || loss_color=\"$lightred\"\n\t\t\tif [ \"$DETAILED_TRACE\" = false ]; then\n\t\t\t\thop_loss=$(printf \"${loss_color}%5s\" \"$hop_loss\") # packet loss position in normal path trace (spacing to fit the column alignment)\n\t\t\telse\n\t\t\t\thop_loss=\"${loss_color}${hop_loss}\" # packet loss position in detailed path trace (no spacing)\n\t\t\tfi\n\t\tfi\n\t\ttracehops_array[\"$hop_num\"]=\"$hop_ip\"\n\t\tixp_tag=\"\"\n\t\thop_asn=\"\"\n\t\tif [ \"$hop_ip\" = \"???\" ]; then\n\t\t\t# print no reply hop info\n\t\t\tif [ \"$DETAILED_TRACE\" = true ]; then\n\t\t\t\ttrailing_line=$(printf '%.0s═' $(seq $((border_width-9-${#hop_ip}))) )\n\t\t\t\thop_output=\"$(printf \"${border_color}╔═[${default}%3s. %s ${border_color}]%s╗${default}\\n\" \"$hop_num\" \"$hop_ip\" \"$trailing_line\")\"\n\t\t\t\thop_output+=\"\\n        ├${bluebg}RTT${default} ${white}* (No reply)${default}\\n\"\n\t\t\t\thop_output+=\"        └${bluebg}LOS${default} ${hop_loss}%${default} packet loss\\n\"\n\t\t\telse\n\t\t\t\thop_output=\"$(printf \"%3s. %-$((output_width-60))s %6s${default} %13s   %s\" \"$hop_num\" \"$hop_ip\" \"$hop_loss%\" \"*\" \"${white}(No reply)${default}\")\"\n\t\t\tfi\n\t\t\tHopPrint \"${hop_output}\"\n\t\t\tcontinue # jump to the next hop\n\t\tfi\n\n\t\t# do a reverse DNS lookup for the IP\n\t\thostname=$(RdnsLookup \"$hop_ip\")\n\n\t\t# check for routing loops, if so fail immediately\n\t\tif [ \"$hop_num\" -ge 2 ]; then\n\t\t\tprev_hop=${tracehops_array[$(( hop_num-1 ))]}\n\t\t\t# Check disabled to avoid detecting routing loops in rare cases where the same hop appears twice in a row during the trace\n\t\t\t# if [ \"$hop_ip\" = \"$prev_hop\" ]; then\n\t\t\t# \tROUTING_LOOP=true\n\t\t\t# \tbreak\n\t\t\t# fi\n\t\tfi\n\t\tif [ \"$hop_num\" -ge 4 ]; then\n\t\t\t# detect routing loops\n\t\t\ttwo_hops_ago=${tracehops_array[$(( hop_num-2 ))]}\n\t\t\tthree_hops_ago=${tracehops_array[$(( hop_num-3 ))]}\n\t\t\tif [ \"$hop_ip\" = \"$two_hops_ago\" ] && [ \"$prev_hop\" = \"$three_hops_ago\" ]; then\n\t\t\t\tROUTING_LOOP=true\n\t\t\t\tbreak\n\t\t\tfi\n\t\tfi\n\t\t# AS DATA lookup\n\t\t# check if it's the last hop\n\t\t[[ \"$hop_ip\" = \"$host_to_trace\" ]] && LAST_HOP=true\n\t\tLookupASNAndRouteFromIP \"$hop_ip\"\n\t\t# check if IP is a bogon\n\t\tif [ \"$IS_BOGON\" = true ]; then\n\t\t\tasn_data=\"$bogon_tag\"\n\t\t\tpwhois_output=\"\"\n\t\telse\n\t\t\t# Hop IP is not a bogon address. Proceed with lookup of hop data\n\t\t\tif [ \"$UNANNOUNCED_PREFIX\" = true ]; then\n\t\t\t\t# No data in the Team Cymru DB. Check to see if the ip is assigned to an IXP, or fall back to generic whois.\n\t\t\t\tWhoisIP \"$hop_ip\" >/dev/null # don't display this, we're being parsed off-screen\n\t\t\t\thop_asn=\"${red}N/A (address not announced)${default}\"\n\t\t\t\thop_org=\"$pwhois_org\"\n\t\t\t\thop_net=\"$pwhois_net\"\n\t\t\t\t[[ -n \"$found_route\" ]] && hop_net+=\" ($found_route)\"\n\t\t\t\thop_typ=\"$ip_type_data\"\n\t\t\t\thop_cpe=\"$ip_shodan_cpe_data\"\n\t\t\t\thop_ports=\"$ip_shodan_ports_data\"\n\t\t\t\thop_tags=\"$ip_shodan_tags_data\"\n\t\t\t\thop_cve=\"$ip_shodan_cve_data\"\n\t\t\t\thop_geo=\"$pwhois_geo\"\n\t\t\t\thop_rep=\"$ip_rep_data\"\n\t\t\t\tif [ -n \"$ixp_data\" ]; then\n\t\t\t\t\t# this hop is an IXP\n\t\t\t\t\tixp_tag=\"${bluebg} IXP ${default}\"\n\t\t\t\t\tasn_data=\"${ixp_tag} ${blue}${ixp_data}${default}\"\n\t\t\t\t\thop_org=\"${ixp_tag} ${blue}${ixp_data}${default}\"\n\t\t\t\t\taspath_entry=$(printf \"%-6s  ${blue}%s${default}\" \"$ixp_tag\" \"$ixp_data\")\n\t\t\t\t\taspath_array+=(\"$aspath_entry\")\n\t\t\t\telse\n\t\t\t\t\t# no data found and not an IXP hop, try retrieving relevant info from a generic whois lookup\n\t\t\t\t\thop_whois_data=$(echo -e \"$full_whois_data\" | grep -i -m2 -E \"^netname:|^orgname:|^org-name:|^descr:\" | cut -d ':' -f 2 | sed 's/^[ \\t]*//' | while read -r line; do echo -n \"$line / \"; done | sed 's/ \\/ $//')\n\t\t\t\t\tif [ -z \"$hop_whois_data\" ]; then\n\t\t\t\t\t\tasn_data=\"${yellow}(No data)${default}\"\n\t\t\t\t\telse\n\t\t\t\t\t\tasn_data=\"${yellow}(${hop_whois_data})${default}\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t# $hop_ip belongs to an announced prefix\n\t\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t\tasn_data=\"${red}[<a href=\\\"/asn_lookup&AS$found_asn\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlred;\\\">AS$found_asn</a>] ${green}$found_asname${default}\"\n\t\t\t\t\taspatharray_asnvalue=\"<a href=\\\"/asn_lookup&AS$found_asn\\\" style=\\\"color: $htmlred; display:inline-block; width: 4em;\\\">$found_asn</a>\"\n\t\t\t\telse\n\t\t\t\t\tasn_data=\"${red}[AS$found_asn] ${green}$found_asname${default}\"\n\t\t\t\t\taspatharray_asnvalue=\"$found_asn\"\n\t\t\t\tfi\n\t\t\t\t# Retrieve AS CAIDA rank for this hop\n\t\t\t\tGetCAIDARank \"$found_asn\"\n\t\t\t\tif [ -n \"$caida_asrank_text\" ]; then\n\t\t\t\t\taspath_entry=$(printf \"${red}%-6s ${green}%s${default}${dim} •%s${dim}${default}\" \"$aspatharray_asnvalue\" \"$(echo \"$found_asname\" | cut -d ',' -f 1)\" \"$caida_asrank_text\")\n\t\t\t\telse\n\t\t\t\t\taspath_entry=$(printf \"${red}%-6s ${green}%s${default}\" \"$aspatharray_asnvalue\" \"$(echo \"$found_asname\" | cut -d ',' -f 1)\")\n\t\t\t\tfi\n\t\t\t\t# avoid adding the same AS multiple times in a row in the summary path\n\t\t\t\tif [[ \"${aspath_array[-1]}\" != \"$aspath_entry\" ]]; then\n\t\t\t\t\taspath_array+=(\"$aspath_entry\")\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ \"$DETAILED_TRACE\" = true ] && [ \"$UNANNOUNCED_PREFIX\" = false ]; then\n\t\t\t\thop_asn=\"$found_asn\"\n\t\t\t\thop_prefix=\"$found_route\"\n\n\t\t\t\t# run a pWhois lookup if the hop is within an announced prefix\n\t\t\t\tPwhoisLookup \"$hop_ip\"\n\n\t\t\t\t# in the event where Cymru has data, but pWhois doesn't, run a WhoisIP to fetch generic whois info\n\t\t\t\t# specifying the \"generic_whois_lookup_only\" parameter in order not to run pWhois/IXP lookups again\n\t\t\t\t[[ -z \"$pwhois_output\" ]] && WhoisIP \"$hop_ip\" \"generic_whois_lookup_only\" >/dev/null # don't display this, we're being parsed off-screen\n\t\t\t\thop_org=\"$pwhois_org\"\n\t\t\t\thop_net=\"$pwhois_net\"\n\t\t\t\thop_typ=\"$ip_type_data\"\n\t\t\t\thop_cpe=\"$ip_shodan_cpe_data\"\n\t\t\t\thop_ports=\"$ip_shodan_ports_data\"\n\t\t\t\thop_tags=\"$ip_shodan_tags_data\"\n\t\t\t\thop_cve=\"$ip_shodan_cve_data\"\n\t\t\t\thop_geo=\"$pwhois_geo\"\n\t\t\t\thop_rep=\"$ip_rep_data\"\n\t\t\tfi\n\t\tfi\n\n\t\t# DNS data (only used if a hostname was resolved)\n\t\tif [ -n \"$hostname\" ] && [ ! \"$hostname\" = \"-\" ]; then\n\t\t\thop_ip=\"$hostname ($hop_ip)\"\n\t\tfi\n\t\t# IXP coloring\n\t\t[[ -z \"$ixp_tag\" ]] && hop_ip=\"${white}${hop_ip}${default}\" || hop_ip=\"${blue}${hop_ip}${default}\"\n\n\t\t# print trace hop info\n\t\tif [ \"$DETAILED_TRACE\" = false ]; then\n\t\t\thop_output=\"$(printf \"%3s. %-$((output_width-45))s %6s${default} %10s ms   %s\" \"$hop_num\" \"${hop_ip}\" \"$hop_loss%\" \"${hop_ping}\" \"$asn_data\")\"\n\t\telse\n\t\t\ttrailing_line=$(printf '%.0s═' $(seq $((border_width+6-${#hop_ip}))) )\n\t\t\thop_output=\"$(printf \"${border_color}╔═[${default}%3s. %s ${border_color}]%s╗${default}\\n\" \"$hop_num\" \"${hop_ip}\" \"$trailing_line\")\"\n\t\t\thop_output+=\"\\n        ├${bluebg}RTT${default} ${white}${hop_ping} ms${default}\\n\"\n\t\t\thop_output+=\"        ├${bluebg}LOS${default} ${hop_loss}%${default} packet loss${default}\"\n\t\t\t# only add ASN data when not an IXP, otherwise we'll have duplicate data when ORG gets printed later\n\t\t\tif [ -z \"$ixp_tag\" ]; then\n\t\t\t\t# if it's a bogon address it's going to be the last branch of the displayed tree\n\t\t\t\tif [ \"$IS_BOGON\" = true ]; then\n\t\t\t\t\thop_output+=\"\\n        └${bluebg}TYP${default} $asn_data${default}\"\n\t\t\t\telse\n\t\t\t\t\thop_output+=\"\\n        ├${bluebg}ASN${default} $asn_data${default}\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\t\tHopPrint \"$hop_output\"\n\n\t\tif [ \"$DETAILED_TRACE\" = true ] && [ -n \"$hop_asn\" ]; then\n\t\t\tif [ -n \"$found_asname\" ]; then\n\t\t\t\t# only run RPKI lookups if the prefix is announced\n\t\t\t\tRPKILookup \"$found_asn\" \"$hop_prefix\"\n\t\t\t\tif [ \"$INVALID_ROA\" = true ]; then\n\t\t\t\t\t# notify user of possible BGP hijack/route leak\n\t\t\t\t\taspath_array[-1]+=\" ${redbg} ─> WARNING: POSSIBLE ROUTE LEAK / BGP HIJACK ${default}\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\trpki_output=\"${red}N/A (hop address not announced)${default}\"\n\t\t\tfi\n\t\t\t# compose hop detail output\n\t\t\t# 1. hop ASN, ORG, NET, ROA\n\t\t\thop_details=\"\"\n\t\t\t[[ \"$DETAILED_TRACE\" = false ]] && hop_details=\"       ├${bluebg}ASN${default} ${red}${hop_asn}${default}\\n\"\n\t\t\t[[ \"$ixp_tag\" = \"\" ]] && hop_details+=\"        ├${bluebg}RNK${default} ${caida_asrank_recap}${default}\\n\"\n\t\t\thop_details+=\"        ├${bluebg}ORG${default} ${green}${hop_org}${default}\\n\"\n\t\t\thop_details+=\"        ├${bluebg}NET${default} ${yellow}${hop_net}${default}\\n\"\n\t\t\thop_details+=\"        ├${bluebg}ROA${default} ${rpki_output}\\n\"\n\t\t\t# 2. hop TYP (optional, only if hop is a particular IP type (anycast/hosting/etc))\n\t\t\t[[ -n \"$hop_typ\" ]] && hop_details+=\"        ├${bluebg}TYP${default}${hop_typ}${default}\\n\"\n\t\t\t# 3. hop CPE, PORTS, TAGS, CVE\n\t\t\t[[ -n \"$hop_cpe\" ]] && hop_details+=\"        ├${bluebg}CPE${default}${hop_cpe}${default}\\n\"\n\t\t\t[[ -n \"$hop_ports\" ]] && hop_details+=\"        ├${bluebg}POR${default}${hop_ports}${default}\\n\"\n\t\t\t[[ -n \"$hop_tags\" ]] && hop_details+=\"        ├${bluebg}TAG${default}${hop_tags}${default}\\n\"\n\t\t\t[[ -n \"$hop_cve\" ]] && hop_details+=\"        ├${bluebg}CVE${default}${hop_cve}${default}\\n\"\n\t\t\t# 4. hop GEO, REP\n\t\t\thop_details+=\"        ├${bluebg}GEO${default} ${magenta}${hop_geo}${default}\\n\"\n\t\t\thop_details+=\"        └${bluebg}REP${default} ${hop_rep}${default}\"\n\t\t\t[[ \"$DETAILED_TRACE\" = false ]] && hop_details+=\"\\n\"\n\t\t\t# display hop details on screen\n\t\t\tHopPrint \"$hop_details\"\n\t\t\t[[ \"$DETAILED_TRACE\" = true ]] && HopPrint \"\\n\"\n\t\telif [ \"$DETAILED_TRACE\" = true ]; then\n\t\t\t# PWHOIS lookups ON, but no valid hop data (e.g. no-reply hop). Just add a newline\n\t\t\t[[ \"$DETAILED_TRACE\" = true ]] && HopPrint \"\\n\"\n\t\tfi\n\t\t[[ \"$LAST_HOP\" = true ]] && break\n\tdone\n\t# mtr output parsing complete\n\tif [ \"$LAST_HOP\" = false ]; then\n\t\t# last hop wasn't our target IP. Add a missing last hop to the trace.\n\t\tmtr_end_msg=\"${redbg} no route to host\"\n\t\t[[ \"$ROUTING_LOOP\" = true ]] && mtr_end_msg+=\" (routing loop detected)\"\n\t\tmtr_end_msg+=\" ${default}\"\n\t\t# print hop info with final error message\n\t\tif [ \"$DETAILED_TRACE\" = false ]; then\n\t\t\tHopPrint \"$(printf \"%3s. %-$((output_width-40))s ${lightred}%11s%%${default} %13s   %s\" \"$hop_num\" \"$mtr_end_msg\" \"100\" \"*\" \"${white}(No reply)${default}\")\"\n\t\telse\n\t\t\tupper_border=\"${border_color}╔$(printf '%.0s═' $(seq \"$border_width\"))╗${default}\"\n\t\t\tlower_border=\"${border_color}╚$(printf '%.0s═' $(seq \"$border_width\"))╝${default}\"\n\t\t\tHopPrint \"${upper_border}\\n  ${mtr_end_msg}\\n${lower_border}\"\n\t\tfi\n\t\taspath_array+=(\"${mtr_end_msg}${default}\")\n\tfi\n\n\tendtime=$(date +%s)\n\truntime=$((endtime-starttime))\n\tStatusbarMessage\n\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t# date and time is already displayed elsewhere in server mode\n\t\techo -e \"\\nTrace completed in $runtime seconds.\\n\"\n\telse\n\t\ttracetime=$(date +'%F %T %Z')\n\t\techo -e \"\\nTrace completed in $runtime seconds on $tracetime\\n\"\n\tfi\n\n\tBoxHeader \"AS path to $userinput\"\n\techo -en \"\\n  \"\n\tfor as in \"${aspath_array[@]}\"; do\n\t\tif [ \"$as\" = \"${aspath_array[0]}\" ]; then\n\t\t\techo -en \"${as} ${yellowbg} Local AS ${default}\"\n\t\telse\n\t\t\techo -en \"${as}${default}\"\n\t\tfi\n\t\tif [ \"$as\" != \"${aspath_array[-1]}\" ]; then\n\t\t\techo -en \"\\n ╭╯\\n ╰\"\n\t\tfi\n\tdone\n\techo -e \"\\n\"\n}\n\nSearchByOrg(){\n\tunset orgs\n\tdeclare -a orgs\n\techo \"\"\n\tif [ \"$ORG_FILTER\" = false ]; then\n\t\tStatusbarMessage \"Searching for organizations matching ${bluebg}$1${lightgreybg}\"\n\t\tfull_org_search_data=$(whois -h whois.pwhois.org \"registry org-name=$1\")\n\t\toriginal_organizations=$(echo -e \"$full_org_search_data\" | grep -E \"^Org-Name:\" | cut -d ':' -f 2- | sed 's/^ //g' | sort -uf)\n\t\ttotal_orgsearch_results=$(echo -e \"$original_organizations\" | wc -l)\n\t\torganizations=\"$original_organizations\"\n\telse\n\t\t# user chose to apply a search filter to a previous query\n\t\tif [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then\n\t\t\t# user deleted all search filters. Revert to original query result\n\t\t\torganizations=\"$original_organizations\"\n\t\t\tORG_FILTER=false\n\t\telse\n\t\t\tStatusbarMessage \"Applying filters\"\n\t\t\tfiltered_org=\"$original_organizations\"\n\t\t\t# parse all inclusion filters\n\t\t\tfor filter in \"${orgfilters_array[@]}\"; do\n\t\t\t\tapply_filter=$(echo -e \"$filtered_org\" | grep -i -- \"$filter\")\n\t\t\t\tif [ -z \"$apply_filter\" ]; then\n\t\t\t\t\tStatusbarMessage\n\t\t\t\t\techo -en \"${yellow}Warning: No results found for ${bluebg}${filter}${default}\"\n\t\t\t\t\tsleep 2\n\t\t\t\t\t# remove last filter term\n\t\t\t\t\tunset 'orgfilters_array[${#orgfilters_array[@]}-1]'\n\t\t\t\telse\n\t\t\t\t\tfiltered_org=\"$apply_filter\"\n\t\t\t\tfi\n\t\t\tdone\n\t\t\t# parse all exclusion filters\n\t\t\tfor filter in \"${excl_orgfilters_array[@]}\"; do\n\t\t\t\tapply_filter=$(echo -e \"$filtered_org\" | grep -i -v -- \"$filter\")\n\t\t\t\tif [ -z \"$apply_filter\" ]; then\n\t\t\t\t\tStatusbarMessage\n\t\t\t\t\techo -en \"${yellow}Warning: No more results found if excluding ${bluebg}${filter}${default}\"\n\t\t\t\t\tsleep 2\n\t\t\t\t\t# remove last filter term\n\t\t\t\t\tunset 'excl_orgfilters_array[${#excl_orgfilters_array[@]}-1]'\n\t\t\t\telse\n\t\t\t\t\tfiltered_org=\"$apply_filter\"\n\t\t\t\tfi\n\t\t\tdone\n\t\t\t# have we removed all filters (because of no matches)? go back to unfiltered results\n\t\t\tif [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then\n\t\t\t\tORG_FILTER=false\n\t\t\t\techo \"\"\n\t\t\tfi\n\t\t\torganizations=\"$filtered_org\"\n\t\tfi\n\tfi\n\tfor orgname in $organizations; do\n\t\torgs+=(\"$orgname\")\n\tdone\n\tStatusbarMessage\n\n\tif [ ${#orgs[@]} -eq 0 ]; then\n\t\t# company search yielded no results\n\t\tPrintErrorAndExit \"Error: no organizations found\"\n\tfi\n\n\t# Menu showing loop\n\twhile true; do\n\t\tShowMenu\n\t\tsearchresults=\"\"\n\t\t[[ \"$LOOKUP_ALL_RESULTS\" == true ]] && orgs_to_lookup=(\"${orgs[@]}\") || orgs_to_lookup=(\"$org\")\n\t\tfor org in \"${orgs_to_lookup[@]}\"; do\n\t\t\torgids=$(echo -e \"$full_org_search_data\" | grep -i -E -B1 \"Org-Name: $org$\" | grep \"Org-ID\" | cut -d ':' -f 2- | sed 's/^ //g')\n\t\t\tNO_ERROR_ON_INTERRUPT=true\n\t\t\tfor ipversion in 4 6; do\n\t\t\t\tNO_RESULTS=true\n\t\t\t\tsearchresults+=$(BoxHeader \"IPv${ipversion} networks for organization \\\"${org}\\\"\")\n\t\t\t\t# iterate over Org-IDs related to the company (in case of multiple Org-IDs for a single Org-Name)\n\t\t\t\tfor orgid in $orgids; do\n\t\t\t\t\tStatusbarMessage \"Looking up IPv${ipversion} networks for organization ${bluebg}$org${lightgreybg} (Org-ID: ${bluebg}${orgid}${lightgreybg})\"\n\t\t\t\t\tnetblocks_output=\"\"\n\t\t\t\t\tif [ \"$ipversion\" = \"4\" ]; then\n\t\t\t\t\t\t# Parse IPv4 NETBLOCKS\n\t\t\t\t\t\tnetblocks=$(whois -h whois.pwhois.org \"netblock org-id=${orgid}\" | grep -E \"^\\*>\")\n\t\t\t\t\t\tnetblocks_header=\"            IPv4 NET RANGE                | INFO\"\n\t\t\t\t\t\tfor netblock in $netblocks; do\n\t\t\t\t\t\t\tprefix=$(echo -e \"$netblock\" | cut -d '>' -f 2 | cut -d '|' -f 1)\n\t\t\t\t\t\t\tnetname=$(echo -e \"$netblock\" | cut -d '>' -f 2 | cut -d '|' -f 2 | tr -d ' ')\n\t\t\t\t\t\t\tnetblock_type=$(echo -e \"$netblock\" | cut -d '>' -f 2 | cut -d '|' -f 3 | tr -d ' ')\n\t\t\t\t\t\t\tif [ \"$netblock_type\" = \"unknown\" ]; then\n\t\t\t\t\t\t\t\tnettype=\"\"\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnettype=\" (${yellow}$netblock_type${default})\"\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tregdate=$(echo -e \"$netblock\" | cut -d '>' -f 2 | cut -d '|' -f 4 | tr -d ' ')\n\t\t\t\t\t\t\tif [ \"$HAVE_IPCALC\" = true ]; then\n\t\t\t\t\t\t\t\t# deaggregate IPv4 netblocks into CIDR prefixes for readability\n\t\t\t\t\t\t\t\tprefix_spacing=19\n\t\t\t\t\t\t\t\ttrimmed_prefix=$(echo \"$prefix\" | tr -d ' ')\n\t\t\t\t\t\t\t\tprefix=$(IpcalcDeaggregate \"$trimmed_prefix\")\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t# no ipcalc, use direct pWhois output\n\t\t\t\t\t\t\t\tprefix_spacing=41\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tnetblocks_output+=$(printf \"\\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s\" \"$prefix\" \"$netname\" \"$regdate\" \"$nettype\")\n\t\t\t\t\t\tdone\n\t\t\t\t\t\t[[ \"$HAVE_IPCALC\" = true ]] && netblocks_header=\"    IPv4 PREFIX     |       INFO\"\n\t\t\t\t\telse\n\t\t\t\t\t\t# Parse IPv6 NETBLOCKS\n\t\t\t\t\t\tnetblocks=$(whois -h whois.pwhois.org \"netblock6 org-id=${orgid}\" | grep -E \"^Net-(Range|Name|Handle|Type)|^Register-Date\" |\\\n\t\t\t\t\t\t\tcut -d ':' -f 2- |\\\n\t\t\t\t\t\t\tsed 's/^ //g' |\\\n\t\t\t\t\t\t\tawk '{if (NR%5) {ORS=\"\"} else {ORS=\"\\n\"}{print $0\"|\"}}') # cheers https://stackoverflow.com/a/35315421/5377165\n\t\t\t\t\t\tnetblocks_header=\"                       IPv6 NET RANGE                         | INFO\"\n\t\t\t\t\t\tfor netblock in $netblocks; do\n\t\t\t\t\t\t\tprefix=$(echo -e \"$netblock\" | cut -d '|' -f 1)\n\t\t\t\t\t\t\tnetname=$(echo -e \"$netblock\" | cut -d '|' -f 2)\n\t\t\t\t\t\t\tnethandle=$(echo -e \"$netblock\" | cut -d '|' -f 3)\n\t\t\t\t\t\t\tnetname+=\" (${nethandle})\"\n\t\t\t\t\t\t\tnetblock_type=$(echo -e \"$netblock\" | cut -d '|' -f 4)\n\t\t\t\t\t\t\tif [ \"$netblock_type\" = \"unknown\" ]; then\n\t\t\t\t\t\t\t\tnettype=\"\"\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnettype=\" (${yellow}$netblock_type${default})\"\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tregdate=$(echo -e \"$netblock\" | cut -d '|' -f 5)\n\t\t\t\t\t\t\tprefix_spacing=61\n\t\t\t\t\t\t\tnetblocks_output+=$(printf \"\\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s\" \"$prefix\" \"$netname\" \"$regdate\" \"$nettype\")\n\t\t\t\t\t\tdone\n\t\t\t\t\tfi\n\t\t\t\t\tif [ -n \"$netblocks_output\" ]; then\n\t\t\t\t\t\t# Print out netblocks\n\t\t\t\t\t\tNO_RESULTS=false\n\t\t\t\t\t\tsearchresults+=$(echo -e \"\\n${red}Org-ID: ${magenta}${orgid}${red}${default}\\n${netblocks_header}${netblocks_output}\")\n\t\t\t\t\t\tsearchresults+=\"\\n\"\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\t\t[[ \"$NO_RESULTS\" = true ]] && searchresults+=\"\\n\\t${red}No results found${default}\\n\"\n\t\t\tdone\n\t\tdone\n\t\tNO_ERROR_ON_INTERRUPT=false\n\t\tStatusbarMessage\n\t\techo -e \"$searchresults\\n${yellow}────────────────────────────────────────────────────${default}\"\n\t\t# let the user choose if they want to run a quick IP lookup\n\t\twhile true; do\n\t\t\techo -e \"\\n- Enter any ${blue}IP/Prefix${default} to look it up or\"\n\t\t\techo -e \"- Press ${yellow}ENTER${default} to return to the menu:\\n\"\n\t\t\techo -n \">> \"\n\t\t\tread -r choice\n\t\t\t# check if it's an IPv4/IPv6\n\t\t\tif [ -n \"${choice}\" ]; then\n\t\t\t\tinput=$(echo \"$choice\" | sed 's/\\/.*//g' | grep -Eo \"$ipv4v6regex\")\n\t\t\t\tif [ -n \"$input\" ]; then\n\t\t\t\t\t# valid IP\n\t\t\t\t\techo \"\"\n\t\t\t\t\tStatusbarMessage \"Looking up data for ${bluebg}${input}${lightgreybg}\"\n\t\t\t\t\tLookupASNAndRouteFromIP \"$input\"\n\t\t\t\t\t(( longest=${#input}+1 ))\n\t\t\t\t\tWhoisIP \"$input\"\n\t\t\t\t\tPrintReputationAndShodanData \"$input\"\n\t\t\t\t\tStatusbarMessage\n\t\t\t\t\tcontinue\n\t\t\t\telse\n\t\t\t\t\tcontinue\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t# user pressed ENTER, go back to main organizations menu\n\t\t\t\tclear\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\tdone\n}\n\nShowMenu(){ # show selection menu for search-by-company results\n\tclear\n\tBoxHeader \"Organizations matching \\\"$userinput\\\"\"\n\tif [ \"$ORG_FILTER\" = true ]; then\n\t\tnum_inclusion_filters=\"${#orgfilters_array[@]}\"\n\t\tnum_exclusion_filters=\"${#excl_orgfilters_array[@]}\"\n\t\tnum_filters=$(( num_inclusion_filters+num_exclusion_filters ))\n\t\t[[ $num_filters = 1 ]] && s=\"\" || s=\"s\"\n\t\tACTIVE_FILTERS_STRING=$'\\n'\"${bluebg}${black}${num_filters} Active filter${s}:${default}\"\n\n\t\t# recap inclusion filters\n\t\tfor filter in \"${orgfilters_array[@]}\"; do\n\t\t\tACTIVE_FILTERS_STRING+=\" ${lightgreybg}${filter}${default}\"\n\t\tdone\n\n\t\t# recap exclusion filters\n\t\tfor filter in \"${excl_orgfilters_array[@]}\"; do\n\t\t\tACTIVE_FILTERS_STRING+=\" ${lightgreybg}${red}-${filter}${default}\"\n\t\tdone\n\n\t\tACTIVE_FILTERS_STRING+=$'\\n'\n\telse\n\t\tACTIVE_FILTERS_STRING=\"\"\n\tfi\n\tif [ \"$HAVE_IPCALC\" = true ]; then\n\t\tIPCALC_WARNING=\"\"\n\telse\n\t\tIPCALC_WARNING=$'\\n'\"${yellow}Warning: program ${red}ipcalc${yellow} not found.\"$'\\n'\"Install it to enable netblock→CIDR\"$'\\n'\"prefix aggregation.${default}\"$'\\n'\n\tfi\n\tPS3=\"${yellow}────────────────────────────────────────────────────${default}\n$ACTIVE_FILTERS_STRING\n${yellow}${#orgs[@]} of $total_orgsearch_results total results shown${default}\n\nChoose an organization or enter:\n- <${green}text${default}> to FILTER FOR A STRING\n- <${blue}-${default}> to EXCLUDE A STRING\n- <${blue}x${default}> to REMOVE ALL FILTERS\n- <${blue}a${default}> to LOOKUP ALL RESULTS (max 10)\n- <${blue}q${default}> to QUIT\n$IPCALC_WARNING\n>> \"\n\techo -e \"${yellow}────────────────────────────────────────────────────${green}\"\n\tCOLUMNS=1\n\tset -o posix\n\tselect choice in \"${orgs[@]}\"; do\n\t\tfor org in \"${orgs[@]}\"; do\n\t\t\tif [[ \"$org\" = \"$choice\" ]]; then\n\t\t\t\tLOOKUP_ALL_RESULTS=false\n\t\t\t\tbreak 2\n\t\t\tfi\n\t\tdone\n\t\tcase \"$REPLY\" in\n\t\t\t\"q\"|\"Q\")\n\t\t\t\techo \"\"\n\t\t\t\texit 0\n\t\t\t;;\n\t\t\t\"-\")\n\t\t\t\t# add an exclusion filter\n\t\t\t\techo -n \"Enter a string to ${red}exclude${default}: \"\n\t\t\t\tread -r exclusion_string\n\t\t\t\texcl_orgfilters_array+=(\"$exclusion_string\")\n\t\t\t\tORG_FILTER=true\n\t\t\t\tSearchByOrg\n\t\t\t;;\n\t\t\t\"x\"|\"X\")\n\t\t\t\t# reset filters\n\t\t\t\tif [ \"$ORG_FILTER\" = true ]; then\n\t\t\t\t\tunset orgfilters_array\n\t\t\t\t\tunset excl_orgfilters_array\n\t\t\t\t\tdeclare -a orgfilters_array\n\t\t\t\t\tdeclare -a excl_orgfilters_array\n\t\t\t\t\tSearchByOrg\n\t\t\t\tfi\n\t\t\t;;\n\t\t\t\"a\"|\"A\")\n\t\t\t\t# lookup all results\n\t\t\t\tif [ \"${#orgs[@]}\" -gt 10 ]; then\n\t\t\t\t\techo -en \"\\n${redbg}Too many results! Please add some filters!${default}\\n\"\n\t\t\t\t\tsleep 2\n\t\t\t\t\tcontinue\n\t\t\t\tfi\n\t\t\t\tLOOKUP_ALL_RESULTS=true\n\t\t\t\tbreak\n\t\t\t;;\n\t\t\t*)\n\t\t\t\t# apply filter to the results\n\t\t\t\torgfilters_array+=(\"$REPLY\")\n\t\t\t\tORG_FILTER=true\n\t\t\t\tSearchByOrg\n\t\t\t;;\n\t\tesac\n\tdone\n\tset +o posix\n\techo \"\"\n}\n\nPrintReputationAndShodanData(){\n\t# We already collected reputation and Shodan data since we called IPGeoRepLookup() and IPShodanLookup() previously\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t# JSON output\n\t\tfinal_json_output+=\",\\\"reputation\\\":{\"\n\t\t[[ -n \"$json_rep\" ]] && final_json_output+=\"\\\"status\\\":\\\"$json_rep\\\"\"\n\t\t[[ -n \"$json_iqs_threat_score\" ]] && final_json_output+=\"$json_iqs_threat_score\"\n\t\t[[ \"$gn_noisy\" = \"true\" ]] && final_json_output+=\",\\\"is_noisy\\\":$gn_noisy\"\n\t\t[[ -n \"$gn_json_is_knowngood\" ]] && final_json_output+=\",\\\"is_known_good\\\":$gn_json_is_knowngood\"\n\t\t[[ -n \"$gn_json_is_knownbad\" ]] && final_json_output+=\",\\\"is_known_bad\\\":$gn_json_is_knownbad\"\n\t\t[[ -n \"$gn_json_aka\" ]] && final_json_output+=\",\\\"known_as\\\":\\\"$gn_json_aka\\\"\"\n\t\t[[ -n \"$json_iqs_threat_tags\" ]] && final_json_output+=\"$json_iqs_threat_tags\"\n\t\tfinal_json_output+=\"},\\\"fingerprinting\\\":{\"\n\t\t[[ -n \"$shodan_cpes_json_output\" ]] && final_json_output+=\"\\\"cpes\\\":$shodan_cpes_json_output,\"\n\t\t[[ -n \"$shodan_ports_json_output\" ]] && final_json_output+=\"\\\"ports\\\":$shodan_ports_json_output,\"\n\t\t[[ -n \"$shodan_tags_json_output\" ]] && final_json_output+=\"\\\"tags\\\":$shodan_tags_json_output,\"\n\t\t[[ -n \"$shodan_vulns_json_output\" ]] && final_json_output+=\"\\\"vulns\\\":$shodan_vulns_json_output,\"\n\t\t# truncate last comma\n\t\t[[ ${final_json_output: -1} = \",\" ]] && final_json_output=${final_json_output::-1}\n\t\tfinal_json_output+=\"}\"\n\t\tfinal_json_output+=\"}\"\n\telse\n\t\t# normal output\n\t\t[[ -n \"$ip_shodan_cpe_data\" ]] && printf \"${white}%${indent}s${bluebg}CPE${default}%s\\n\" \"├\" \"${ip_shodan_cpe_data}\"\n\t\t[[ -n \"$ip_shodan_ports_data\" ]] && printf \"${white}%${indent}s${bluebg}POR${default}%s\\n\" \"├\" \"${ip_shodan_ports_data}\"\n\t\t[[ -n \"$ip_shodan_tags_data\" ]] && printf \"${white}%${indent}s${bluebg}TAG${default}%s\\n\" \"├\" \"${ip_shodan_tags_data}\"\n\t\t[[ -n \"$ip_shodan_cve_data\" ]] && printf \"${white}%${indent}s${bluebg}CVE${default}%s\\n\" \"├\" \"${ip_shodan_cve_data}\"\n\t\tprintf \"${white}%${indent}s${bluebg}REP${default} ${magenta}%s${default}\\n\\n\" \"└\" \"$ip_rep_data\"\n\tfi\n}\n\nShodanRecon(){\n\tshodan_starttime=$(date +%s)\n\tshodan_json_output=\"\"\n\tcurloutput=\"\"\n\turllist=\"\"\n\n\t# identify target(s) type\n\ttargetlist=$(echo -e \"$userinput\" | tr ' ' '\\n')\n\ttarget_count=$(echo -e \"$targetlist\" | wc -l)\n\tif [ \"$target_count\" -gt 1 ]; then\n\t\t# user passed multiple targets \"e.g. asn -s 1.1.1.1 8.8.8.8\"\n\t\tuserinput=\"multiple targets\"\n\tfi\n\n\tBoxHeader \"Shodan scan for $userinput\"\n\n\tfor target in $targetlist; do\n\t\tinput=$(echo \"$target\" | sed 's/\\/.*//g' | grep -Eo \"$ipv4v6regex\")\n\t\tif [ -z \"$input\" ]; then\n\t\t\t# Input is not an IP Address. See if it's a hostname (includes at least one dot)\n\t\t\tif echo \"$target\" | grep -q \"\\.\"; then\n\t\t\t\ttarget=$(awk -F[/:] '{gsub(\".*//\", \"\"); gsub(\".*:.*@\", \"\"); print $1}' <<<\"$target\")\n\t\t\t\ttarget=$(ResolveHostnameToIPList \"$target\")\n\t\t\t\t[[ -z \"$target\" ]] && continue # could not resolve hostname\n\t\t\t\tjson_target_type=\"hostname\"\n\t\t\t\ttarget=$(grep -v \":\" <<<\"$target\")\n\t\t\t\tnumips=$(wc -l <<<\"$target\")\n\t\t\t\t[[ $numips = 1 ]] && s=\"\" || s=\"es\"\n\t\t\telse\n\t\t\t\t# not an IP, not a hostname\n\t\t\t\tcontinue\n\t\t\tfi\n\t\telse\n\t\t\tjson_target_type=\"ip\"\n\t\tfi\n\t\t# prepare shodan InternetDB API URL list for every IP in the given CIDR range\n\t\tfor ip in $target; do\n\t\t\tif grep -q \":\" <<<\"$ip\"; then\n\t\t\t\t# Shodan has no data for IPv6 addresses\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\t[[ -n \"$urllist\" ]] && urllist+=\"\\n\"\n\t\t\turllist+=$(nmap -sL -n \"$ip\" 2>/dev/null | awk '/Nmap scan report/{print \"https://internetdb.shodan.io/\"$NF}') # cheers https://stackoverflow.com/a/31412705\n\t\tdone\n\tdone\n\t[[ -z \"$urllist\" ]] && PrintErrorAndExit \"no valid targets found\"\n\tnumtargets=$(echo -e \"$urllist\" | wc -l)\n\n\tfirsturl=1\n\twhile true; do\n\t\tsaved_lasturl=\"$lasturl\"\n\t\tlasturl=$(( firsturl + MAX_CONCURRENT_SHODAN_REQUESTS ))\n\t\t# check if concurrent Shodan requests setting is > number of IPs yet to scan\n\t\t# if so, perform a batch lookup with all the urls and break. Otherwise\n\t\t# perform max concurrent lookups, sleep and continue\n\t\tif [ \"$lasturl\" -ge \"$numtargets\" ]; then\n\t\t\tlasturl=\"$numtargets\"\n\t\t\tLAST_BATCH=true\n\t\tfi\n\t\turlbatch=$(echo -e \"$urllist\" | awk \"NR==$firsturl,NR==$lasturl\")\n\t\tStatusbarMessage \"Collecting data for IPs ${bluebg}${firsturl}-${lasturl}${lightgreybg} of ${bluebg}$numtargets${lightgreybg} total ($MAX_CONCURRENT_SHODAN_REQUESTS threads)\"\n\t\tDebugPrint \"${yellow}curl {$(echo -e \"$urlbatch\" | tr '\\n' ',')}${default}\"\n\t\tbatchoutput=$( xargs -P \"$MAX_CONCURRENT_SHODAN_REQUESTS\" -n 1 curl -s < <(echo -e \"$urlbatch\") )\n\t\tif grep -q \"Rate limit exceeded\" <<<\"$batchoutput\"; then\n\t\t\t# rate limit exceeded during current batch of queries, loop while waiting to continue\n\t\t\tretryafter=$(docurl -s -i \"https://internetdb.shodan.io/127.0.0.1\" | awk '/^retry-after:/ {print $2}' | tr -d '\\r\\n')\n\t\t\twhile [[ ${retryafter} -gt 1 ]]; do\n\t\t\t\tStatusbarMessage \"Shodan rate limit hit during batch ${bluebg}${firsturl}-${lasturl}${lightgreybg}, resuming in ${redbg}${retryafter}${lightgreybg}s\"\n\t\t\t\tsleep 1\n\t\t\t\tretryafter=$(( retryafter-1 ))\n\t\t\tdone\n\t\t\t# retry last batch\n\t\t\tlasturl=\"$saved_lasturl\"\n\t\t\tcontinue\n\t\telse\n\t\t\tcurloutput+=\"$batchoutput\"\n\t\t\t[[ \"$LAST_BATCH\" = true ]] && break\n\t\t\t# enable below to introduce a delay between batches of curl queries to Shodan (could help with rate limiting)\n\t\t\t# sleep .5\n\t\t\tfirsturl=$(( lasturl++ ))\n\t\tfi\n\tdone\n\tStatusbarMessage\n\n\t# convert single API output results to array, delete IPs for which Shodan had no data available\n\tjson=$(jq -cM --slurp 'del (.[] | select(.ip==null))' <<<\"$curloutput\")\n\tif [ \"$json\" = \"[]\" ]; then\n\t\tfinal_json_output=\"$json\"\n\t\tPrintErrorAndExit \"Shodan has no data for $userinput\"\n\tfi\n\n\tshodan_json_output=\"$json\"\n\t[[ \"$JSON_OUTPUT\" = true ]] && return\n\n\tshodan_endtime=$(date +%s)\n\tshodan_runtime=$((shodan_endtime-shodan_starttime))\n\n\tStatusbarMessage \"Parsing collected data\"\n\tvulnlist=\"\"\n\thostnamelist=\"\"\n\tportlist=\"\"\n\ttaglist=\"\"\n\tcpelist=\"\"\n\ttotal_hosts_with_vulns=0\n\ttotal_hosts_with_ports=0\n\ttotal_hosts_with_tags=0\n\ttotal_hosts_with_cpe=0\n\ttotal_hosts_with_hostnames=0\n\n\t# find all IPs in the json having a non-null \".ip\" attribute. It means Shodan has some data about that IP.\n\tinteresting_iplist=$(echo -e \"$json\" | jq -r '.[].ip' | sort | uniq)\n\t# iterate over interesting IPs\n\tfor ip in $interesting_iplist; do\n\t\toutput+=\"\\n${white}•${default} $ip\"\n\t\tattribs=$(jq -r '.[] | select(.ip==\"'\"$ip\"'\")| to_entries | .[] | .key + \"=\" + (.value | @sh)' <<<\"$json\")\n\t\tnumattrs=$(grep -Evc \"=$|^ip=\" <<<\"$attribs\"); # get number of populated attributes\n\t\t# \"attribs\" contains a list of attributes for a single IP, composed like this:\n\t\t#\n\t\t# cpes='cpename1' 'cpename2'\n\t\t# hostnames='abc.com'\n\t\t# ip='1.2.3.4'\n\t\t# ports=22 80 8080\n\t\t# tags='vpn'\n\t\t# vulns='CVE-123' 'CVE-345'\n\n\t\t# iterate over resulting attributes.\n\t\tcount=0 # will be used to decide which tree symbol to use (├ or └)\n\n\t\t# - hostnames\n\t\tip_hostnames=$(grep -E \"^hostnames=\" <<<\"$attribs\" | cut -d '=' -f 2- | tr -d \"'\" | uniq)\n\t\thostnamelist+=$(echo -e \"\\n$ip_hostnames\" | tr ' ' '\\n')\n\t\tif [ -n \"$ip_hostnames\" ]; then\n\t\t\tcount=$(( count+1 ))\n\t\t\t[[ \"$count\" -eq \"$numattrs\" ]] && treesymbol=\"└\" || treesymbol=\"├\"\n\t\t\tip_hostnames=$(echo -e \"$ip_hostnames\" | sed -e 's/ / • /g' -e \"s/.\\{136\\}/&\\n               /g\")\n\t\t\ttotal_hosts_with_hostnames=$(( total_hosts_with_hostnames+1 ))\n\t\t\toutput+=\"\\n\\t${treesymbol}${bluebg} PTR ${default} ${white}$ip_hostnames${default}\"\n\t\tfi\n\n\t\t# - cpes\n\t\tip_cpes=$(grep -E \"^cpes=\" <<<\"$attribs\" | cut -d '=' -f 2- | tr -d \"'\" | uniq)\n\t\t# use more user-friendly names for some CPEs\n\t\tip_cpes=$(echo -e \"$ip_cpes\" | \\\n\t\t\tsed -e 's,cpe:/a:apache:http_server,Apache-HTTPD,g' \\\n\t\t\t\t-e 's,cpe:/o:linux:linux_kernel,[O/S]-Linux,g' \\\n\t\t\t\t-e 's,cpe:/o:microsoft:windows,[O/S]-Microsoft-Windows,g' \\\n\t\t\t\t-e 's,cpe:/o:debian:debian_linux,[O/S]-Debian-Linux,g' \\\n\t\t\t\t-e 's,cpe:/a:microsoft:internet_information_services,Microsoft-IIS,g' \\\n\t\t\t\t-e 's,cpe:/a:microsoft:exchange_server,Microsoft-Exchange,g' \\\n\t\t\t\t-e 's,cpe:/a:openbsd:openssh,OpenSSH,g' \\\n\t\t\t\t-e 's,cpe:/a:igor_sysoev:nginx,Nginx,g' \\\n\t\t\t\t-e 's,cpe:/a:php:php,PHP,g' \\\n\t\t\t\t-e 's,cpe:/a:jquery:jquery,jQuery,g' \\\n\t\t\t\t-e 's,cpe:/a:getbootstrap:bootstrap,Bootstrap,g' \\\n\t\t\t\t-e 's,cpe:/a:pureftpd:pure-ftpd,Pure-FTPd,g' \\\n\t\t\t\t-e 's,cpe:/a:postfix:postfix,Postfix,g' \\\n\t\t\t\t-e 's,cpe:/a:openssl:openssl,OpenSSL,g' \\\n\t\t\t\t-e 's,cpe:/a:mysql:mysql,MySQL,g' \\\n\t\t\t)\n\t\tcpelist+=$(echo -e \"\\n$ip_cpes\" | tr ' ' '\\n')\n\t\tif [ -n \"$ip_cpes\" ]; then\n\t\t\tcount=$(( count+1 ))\n\t\t\t[[ \"$count\" -eq \"$numattrs\" ]] && treesymbol=\"└\" || treesymbol=\"├\"\n\t\t\tip_cpes=$(echo -e \"$ip_cpes\" | sed -e 's/ / • /g' -e \"s/.\\{136\\}/&\\n               /g\")\n\t\t\ttotal_hosts_with_cpe=$(( total_hosts_with_cpe+1 ))\n\t\t\toutput+=\"\\n\\t${treesymbol}${bluebg} CPE ${default} ${blue}$ip_cpes${default}\"\n\t\tfi\n\n\t\t# - ports\n\t\tip_ports=$(grep -E \"^ports=\" <<<\"$attribs\" | cut -d '=' -f 2- | uniq)\n\t\tportlist+=$(echo -e \"\\n$ip_ports\" | tr ' ' '\\n')\n\t\tif [ -n \"$ip_ports\" ]; then\n\t\t\tcount=$(( count+1 ))\n\t\t\t[[ \"$count\" -eq \"$numattrs\" ]] && treesymbol=\"└\" || treesymbol=\"├\"\n\t\t\tip_ports=$(echo -e \"$ip_ports\" | sed -e 's/ / • /g' -e \"s/.\\{136\\}/&\\n               /g\")\n\t\t\ttotal_hosts_with_ports=$(( total_hosts_with_ports+1 ))\n\t\t\toutput+=\"\\n\\t${treesymbol}${bluebg} POR ${default} ${green}$ip_ports${default}\"\n\t\tfi\n\n\t\t# - tags\n\t\tip_tags=$(grep -E \"^tags=\" <<<\"$attribs\" | cut -d '=' -f 2- | tr -d \"'\" | uniq)\n\t\ttaglist+=$(echo -e \"\\n$ip_tags\" | tr ' ' '\\n')\n\t\tif [ -n \"$ip_tags\" ]; then\n\t\t\tcount=$(( count+1 ))\n\t\t\t[[ \"$count\" -eq \"$numattrs\" ]] && treesymbol=\"└\" || treesymbol=\"├\"\n\t\t\tip_tags=$(echo -e \"$ip_tags\" | sed -e 's/ / • /g' -e \"s/.\\{136\\}/&\\n               /g\")\n\t\t\ttotal_hosts_with_tags=$(( total_hosts_with_tags+1 ))\n\t\t\toutput+=\"\\n\\t${treesymbol}${bluebg} TAG ${default} ${yellow}$ip_tags${default}\"\n\t\tfi\n\n\t\t# - vulns\n\t\tip_vulns=$(grep -E \"^vulns=\" <<<\"$attribs\" | cut -d '=' -f 2- | tr -d \"'\" | uniq)\n\t\tvulnlist+=$(echo -e \"\\n$ip_vulns\" | tr ' ' '\\n')\n\t\tif [ -n \"$ip_vulns\" ]; then\n\t\t\tcount=$(( count+1 ))\n\t\t\t[[ \"$count\" -eq \"$numattrs\" ]] && treesymbol=\"└\" || treesymbol=\"├\"\n\t\t\t# ip_vulns=$(echo -e \"$ip_vulns\" | sed -e 's/ / • /g')\n\t\t\tip_vulns=$(echo -e \"$ip_vulns\" | sed -e 's/ / • /g' -e \"s/.\\{136\\}/&\\n               /g\")\n\t\t\ttotal_hosts_with_vulns=$(( total_hosts_with_vulns+1 ))\n\t\t\toutput+=\"\\n\\t${treesymbol}${bluebg} CVE ${default} ${red}$ip_vulns${default}\"\n\t\tfi\n\n\t\toutput+=\"\\n\"\n\n\tdone\n\n\tStatusbarMessage\n\techo -e \"$output\"\n\n\tfinal_stats=\"${default}\\n______________________________\\n\\n\"\n\tfinal_stats+=\"${green}$total_hosts_with_ports exposed${default} host\"; [[ \"$total_hosts_with_ports\" != \"1\" ]] && final_stats+=\"s\"; final_stats+=\" found\"\n\tfinal_stats+=\"\\n${blue}$total_hosts_with_cpe hosts${default} identified with a known CPE\"\n\tfinal_stats+=\"\\n${yellow}$total_hosts_with_tags tagged${default} host\"; [[ \"$total_hosts_with_tags\" != \"1\" ]] && final_stats+=\"s\"; final_stats+=\" identified\"\n\tfinal_stats+=\"\\n$total_hosts_with_hostnames hostname\"; [[ \"$total_hosts_with_hostnames\" != \"1\" ]] && final_stats+=\"s\"; final_stats+=\" discovered\"\n\tfinal_stats+=\"\\n${red}$total_hosts_with_vulns vulnerable${default} host\"; [[ \"$total_hosts_with_vulns\" != \"1\" ]] && final_stats+=\"s\"; final_stats+=\" found\"\n\tfinal_stats+=\"\\n\\n$numtargets host\"; [[ \"$numtargets\" != \"1\" ]] && final_stats+=\"s\"; final_stats+=\" analyzed in $shodan_runtime seconds.\\n\"\n\n\t# display final statistics (non-JSON output mode only)\n\tBoxHeader \"Statistics\"\n\n\t# top N ports\n\techo -e \"\\n${green}[TOP ${SHODAN_SHOW_TOP_N} Open Ports] \\n\"\n\tif [ -z \"$portlist\" ]; then\n\t\t# no ports found\n\t\techo -e \"${green}         Nothing found${default}\\n\"\n\telse\n\t\tfor port in $(echo -e \"$portlist\" | sort | grep -Ev '^$' | uniq -c | sort -rn | head -n \"${SHODAN_SHOW_TOP_N}\"); do\n\t\t\tporthits=$(awk '{print $1}' <<<\"$port\")\n\t\t\tportnum=$(awk '{print $2}' <<<\"$port\")\n\t\t\tportname=$(ResolveWellKnownPort \"$portnum\")\n\t\t\t[[ -n \"$portname\" ]] && portname=\"(${portname})\"\n\t\t\tprintf \"%10s host(s) → Port %5s %s\\n\" \"$porthits\" \"$portnum\" \"$portname\"\n\t\tdone\n\t\techo -e \"$default\"\n\tfi\n\n\t# top N CPEs\n\techo -e \"${blue}[TOP ${SHODAN_SHOW_TOP_N} CPEs] \\n\"\n\tif [ -z \"$cpelist\" ]; then\n\t\t# no CPEs found\n\t\techo -e \"${blue}         Nothing found${default}\\n\"\n\telse\n\t\tfor cpe in $(echo -e \"$cpelist\" | sort | grep -Ev '^$' |uniq -c | sort -rn | head -n \"${SHODAN_SHOW_TOP_N}\"); do\n\t\t\tcpehits=$(awk '{print $1}' <<<\"$cpe\")\n\t\t\tcpefullname=$(awk '{print $2}' <<<\"$cpe\")\n\t\t\tcpetype=$(echo \"$cpefullname\" | cut -d ':' -f 2)\n\t\t\tcpename=$(echo \"$cpefullname\" | cut -d ':' -f 3-)\n\t\t\tcase \"${cpetype}\" in\n\t\t\t\t\"/a\")\n\t\t\t\t\ttype=\"APP\"\n\t\t\t\t;;\n\t\t\t\t\"/o\")\n\t\t\t\t\ttype=\"O/S\"\n\t\t\t\t;;\n\t\t\t\t\"/h\")\n\t\t\t\t\ttype=\"H/W\"\n\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\ttype=\"\"\n\t\t\t\t;;\n\t\t\tesac\n\t\t\t[[ -n \"$type\" ]] && cpename=\"[$type] $cpefullname\" || cpename=\"$cpefullname\"\n\t\t\tprintf \"%10s host(s) → %s\\n\" \"$cpehits\" \"$cpename\"\n\t\tdone\n\t\techo -e \"$default\"\n\tfi\n\t# top N tags\n\techo -e \"${yellow}[TOP ${SHODAN_SHOW_TOP_N} Tags] \\n\"\n\tif [ -z \"$taglist\" ]; then\n\t\t# no tags found\n\t\techo -e \"${yellow}         Nothing found${default}\\n\"\n\telse\n\t\tfor tag in $(echo -e \"$taglist\" | sort | grep -Ev '^$' | uniq -c | sort -rn | head -n \"${SHODAN_SHOW_TOP_N}\"); do\n\t\t\ttaghits=$(awk '{print $1}' <<<\"$tag\")\n\t\t\ttagname=$(awk '{print $2}' <<<\"$tag\")\n\t\t\tprintf \"%10s host(s) → %s\\n\" \"$taghits\" \"$tagname\"\n\t\tdone\n\t\techo -e \"$default\"\n\tfi\n\t# first N hostnames discovered\n\techo -e \"${white}[First ${SHODAN_SHOW_TOP_N} Hostnames discovered] \\n\"\n\tif [ -z \"$hostnamelist\" ]; then\n\t\t# no tags found\n\t\techo -e \"${yellow}         Nothing found${default}\\n\"\n\telse\n\t\tfor hostname in $(echo -e \"$hostnamelist\" | grep -Ev '^$' | head -n \"${SHODAN_SHOW_TOP_N}\"); do\n\t\t\tprintf \"         %s\\n\" \"$hostname\"\n\t\tdone\n\t\techo -e \"$default\"\n\tfi\n\t# top N vulnerabilities\n\techo -e \"${red}[TOP ${SHODAN_SHOW_TOP_N} Vulnerabilities by number of occurrences] \\n\"\n\tStatusbarMessage \"Identifying CVE score and severity for vulnerable hosts\"\n\tcvestats_text=\"\"\n\tif [ -z \"$vulnlist\" ]; then\n\t\t# no vulns found\n\t\tcvestats_text=\"${red}         Nothing found${default}\"\n\telse\n\t\tfor cve in $(echo -e \"$vulnlist\" | sort | grep -Ev '^$' | uniq -c | sort -rn | head -n \"${SHODAN_SHOW_TOP_N}\"); do\n\t\t\tvulnhits=$(awk '{print $1}' <<<\"$cve\")\n\t\t\tcvenum=$(awk '{print $2}' <<<\"$cve\")\n\t\t\tcvejsondata=$(docurl -s \"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=$cvenum\")\n\t\t\tv3score=$(jq -r '.vulnerabilities[0].cve.metrics.cvssMetricV31[0].cvssData.baseScore | select(length>0)' <<<\"$cvejsondata\" 2>/dev/null)\n\t\t\tv3severity=$(jq -r '.vulnerabilities[0].cve.metrics.cvssMetricV31[0].cvssData.baseSeverity | select(length>0)' <<<\"$cvejsondata\" 2>/dev/null)\n\t\t\tv2score=$(jq -r '.vulnerabilities[0].cve.metrics.cvssMetricV2[0].cvssData.baseScore' <<<\"$cvejsondata\" 2>/dev/null)\n\t\t\tv2severity=$(jq -r '.vulnerabilities[0].cve.metrics.cvssMetricV2[0].baseSeverity' <<<\"$cvejsondata\" 2>/dev/null)\n\t\t\tcvename=$(jq -r '.vulnerabilities[0].cve.cisaVulnerabilityName | select(length>0)' <<<\"$cvejsondata\" 2>/dev/null)\n\t\t\tcvedesc=$(jq -r '.vulnerabilities[0].cve.descriptions[0].value | select(length>0)' <<<\"$cvejsondata\" 2>/dev/null)\n\t\t\t# apply formatting to cvedesc to fit the terminal width\n\t\t\tcvedesc_len=${#cvedesc}\n\t\t\tavailable_width=$(( terminal_width - 58 ));\n\t\t\tformatted_cvedesc=\"\"\n\t\t\tif [ \"$cvedesc_len\" -gt \"$available_width\" ]; then\n\t\t\t\t# iterate over cvedesc until it fits in the terminal width, inserting newlines\n\t\t\t\twhile [ \"$cvedesc_len\" -gt 0 ]; do\n\t\t\t\t\twordbreak_pointer=\"$available_width\"\n\t\t\t\t\tif [ \"$cvedesc_len\" -gt \"$available_width\" ]; then\n\t\t\t\t\t\twhile [ \"${cvedesc:$wordbreak_pointer:1}\" != \" \"  ] && [ \"$wordbreak_pointer\" -gt 0 ]; do\n\t\t\t\t\t\t\t((wordbreak_pointer--))\n\t\t\t\t\t\tdone\n\t\t\t\t\t\t[[ \"$wordbreak_pointer\" -eq 0 ]] && wordbreak_pointer=\"$available_width\"\n\t\t\t\t\tfi\n\t\t\t\t\tcvedesc_line=${cvedesc:0:$wordbreak_pointer}\n\t\t\t\t\tif [ -n \"$formatted_cvedesc\" ]; then\n\t\t\t\t\t\tformatted_cvedesc+=\"\\n\"\n\t\t\t\t\t\tformatted_cvedesc+=$(printf \"${default}${red}%49s        ${default}${dim}%s\" \"┆\" \"$cvedesc_line\")\n\t\t\t\t\telse\n\t\t\t\t\t\tformatted_cvedesc=\"$cvedesc_line\"\n\t\t\t\t\tfi\n\t\t\t\t\t((wordbreak_pointer++))\n\t\t\t\t\tcvedesc=${cvedesc:$wordbreak_pointer}\n\t\t\t\t\tcvedesc_len=${#cvedesc}\n\t\t\t\tdone\n\t\t\telse\n\t\t\t\tformatted_cvedesc=\"$cvedesc\"\n\t\t\tfi\n\t\t\tcvescore=\"\"\n\t\t\tcveseverity=\"\"\n\t\t\tif [ -n \"$v3score\" ] && [ -n \"$v3severity\" ]; then\n\t\t\t\tcvescore=\"$v3score\"\n\t\t\t\tcveseverity=\"$v3severity\"\n\t\t\telif [ -n \"$v2score\" ] && [ -n \"$v2severity\" ]; then\n\t\t\t\tcvescore=\"$v2score\"\n\t\t\t\tcveseverity=\"$v2severity\"\n\t\t\tfi\n\t\t\tif [ \"${#cvescore}\" -eq 1 ]; then\n\t\t\t\tcvescore+=\".0\"\n\t\t\telif [ \"${#cvescore}\" -eq 2 ]; then\n\t\t\t\tcvescore=\" $cvescore\"\n\t\t\tfi\n\n\t\t\tcase \"${cveseverity}\" in\n\t\t\t\t\"LOW\")\n\t\t\t\t\tcvetext=\"${greenbg}    ${cvescore} (LOW)   ${default}${red}\"\n\t\t\t\t;;\n\t\t\t\t\"MEDIUM\")\n\t\t\t\t\tcvetext=\"${yellowbg}  ${cvescore} (MEDIUM)  ${default}${red}\"\n\t\t\t\t;;\n\t\t\t\t\"HIGH\")\n\t\t\t\t\tcvetext=\"${redbg}   ${cvescore} (HIGH)   ${default}${red}\"\n\t\t\t\t;;\n\t\t\t\t\"CRITICAL\")\n\t\t\t\t\tcvetext=\"${redbg} ${cvescore} (CRITICAL) ${default}${red}\"\n\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tcvescore=\"N/A\"\n\t\t\t\t\tcvetext=\"${lightgreybg} ${cvescore} (UNKNOWN)  ${default}${red}\"\n\t\t\t\t;;\n\t\t\tesac\n\n\t\t\tcvestats_text+=$(printf \"${red}%10s host(s) → %-15s %-14s\" \"$vulnhits\" \"$cvetext\" \"$cvenum\")\n\t\t\t[[ -n \"$cvename\" ]] && cvestats_text+=\" • ${dim}${cvename}${default}\"\n\t\t\tcvestats_text+=\"\\n\"\n\t\t\tcvestats_text+=$(printf \"${red}%49s Desc : ${default}${dim}%s${default}\" \"├\" \"$formatted_cvedesc\")\n\t\t\tcvestats_text+=\"\\n\"\n\t\t\tcvestats_text+=$(printf \"${red}%49s Info : ${blue}${dim}%s${default}\" \"└\" \"https://nvd.nist.gov/vuln/detail/$cvenum\")\n\t\t\tcvestats_text+=\"\\n\\n\"\n\t\tdone\n\tfi\n\tStatusbarMessage\n\techo -e \"$cvestats_text\"\n\techo -e \"$final_stats\"\n}\n\nBulkGeolocate(){\n\t# identify target(s) type\n\ttargetlist_allips=$(echo -e \"$userinput\" | grep -Eo \"$ipv4v6regex\" | sort)\n\ttop10_ipv4=$(grep -v \":\" <<<\"$targetlist_allips\" | uniq -c | sort -rn | head -n 10)\n\ttop10_ipv6=$(grep \":\" <<<\"$targetlist_allips\" | uniq -c | sort -rn | head -n 10)\n\ttargetlist=$(uniq <<<\"$targetlist_allips\")\n\tif [ -n \"$targetlist\" ]; then\n\t\ttarget_count=$(echo -e \"$targetlist\" | wc -l)\n\telse\n\t\tPrintErrorAndExit \"no valid targets found\"\n\tfi\n\tif [ \"$target_count\" -gt 1 ]; then\n\t\t# user passed multiple targets \"e.g. asn -g 1.1.1.1 8.8.8.8\"\n\t\tuserinput=\"multiple targets\"\n\tfi\n\n\tBoxHeader \"Geolocation lookup for $userinput\"\n\n\t# TODO switch to ipinfo.io for bulk geolocation lookups when a token is present (free tier does not support batch queries)\n\tgeolocation_json_output=\"\"\n\tcountrylist=\"\"\n\tfirstip=1\n\twhile true; do\n\t\tlastip=$(( firstip + 99 ))\n\t\tif [ \"$lastip\" -ge \"$target_count\" ]; then\n\t\t\tlastip=\"$target_count\"\n\t\t\tLAST_BATCH=true\n\t\tfi\n\t\tipbatch=$(echo -en \"$targetlist\" | awk \"NR==$firstip,NR==$lastip\")\n\t\tStatusbarMessage \"Collecting geolocation data for IPs ${bluebg}${firstip}-${lastip}${lightgreybg} of ${bluebg}$target_count${lightgreybg} total\"\n\t\tipmap_targets=$(echo -en \"$ipbatch\" | tr '\\n' ',')\n\t\tipapi_targets=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$ipbatch\")\n\t\tipmap_output=$(docurl -m15 -s \"https://ipmap.ripe.net/api/v1/locate/all?resources=$ipmap_targets\")\n\t\tif [[ -n $(jq 'select (.error != null) | .error' <<<\"$ipmap_output\") ]]; then\n\t\t\tipmap_output=\"\"\n\t\tfi\n\t\t# Note: the free IP-API tier only supports unencrypted HTTP, not HTTPS\n\t\tipapi_output=$(docurl -m4 -s \"http://ip-api.com/batch?fields=query,status,message,country,countryCode,regionName,city\" --data ''\"$ipapi_targets\"'')\n\n\t\tfor target in $ipbatch; do\n\t\t\tip_geo_countryname=\"\"\n\t\t\tjson_geo_city=\"\"\n\t\t\tjson_geo_region=\"\"\n\t\t\tjson_geo_cc=\"\"\n\n\t\t\tif [ -n \"$ipmap_output\" ]; then\n\t\t\t\tIS_ANYCAST=$(jq '.metadata.service.contributions.\"'\"$target\"'\".latency.metadata.anycast' <<<\"$ipmap_output\")\n\t\t\t\t[[ \"$IS_ANYCAST\" = true ]] && anycast_tag=\"${yellowbg} ANYCAST ${default}\" || anycast_tag=\"\"\n\t\t\t\tip_geo_countryname=$(jq -r '.data.\"'\"$target\"'\" | select( .countryName != null ) | .countryName' <<<\"$ipmap_output\")\n\t\t\t\tjson_geo_city=\"$(jq -r '.data.\"'\"$target\"'\" | select( .cityName != null ) | .cityName' <<<\"$ipmap_output\")\"\n\t\t\t\tjson_geo_region=\"$(jq -r '.data.\"'\"$target\"'\" | select( .stateName != null ) | .stateName' <<<\"$ipmap_output\")\"\n\t\t\t\tjson_geo_cc=\"$(jq -r '.data.\"'\"$target\"'\" | select( .countryCodeAlpha2 != null ) | .countryCodeAlpha2' <<<\"$ipmap_output\")\"\n\t\t\tfi\n\n\t\t\tif [ -n \"$ip_geo_countryname\" ] && [ -n \"$json_geo_city\" ] && [ -n \"$json_geo_region\" ] && [ -n \"$json_geo_cc\" ]; then\n\t\t\t\tip_geo_data=\"$json_geo_city, $json_geo_region, $json_geo_cc\"\n\t\t\telse\n\t\t\t\t# incomplete/no data on RIPE IPMap, fallback to IP-API\n\t\t\t\tipapi_status=$(jq -r '.[] | select(.query == \"'\"$target\"'\") | .status' <<<\"$ipapi_output\")\n\t\t\t\tif [ \"$ipapi_status\" = \"fail\" ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\t\tip_geo_countryname=\"Unknown\"\n\t\t\t\t\tip_geo_data=\"N/A\"\n\t\t\t\telse\n\t\t\t\t\tip_geo_countryname=$(jq -r '.[] | select(.query == \"'\"$target\"'\") | .country' <<<\"$ipapi_output\")\n\t\t\t\t\tif [ -z \"$ip_geo_countryname\" ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\t\t\tip_geo_countryname=\"Unknown\"\n\t\t\t\t\t\tip_geo_data=\"N/A\"\n\t\t\t\t\telse\n\t\t\t\t\t\tjson_geo_city=\"$(jq -r '.[] | select(.query == \"'\"$target\"'\") | .city' <<<\"$ipapi_output\")\"\n\t\t\t\t\t\tjson_geo_region=\"$(jq -r '.[] | select(.query == \"'\"$target\"'\") | .regionName' <<<\"$ipapi_output\")\"\n\t\t\t\t\t\tjson_geo_cc=\"$(jq -r '.[] | select(.query == \"'\"$target\"'\") | .countryCode' <<<\"$ipapi_output\")\"\n\t\t\t\t\t\tif [ -n \"$json_geo_city\" ] && [ -n \"$json_geo_region\" ] && [ -n \"$json_geo_cc\" ]; then\n\t\t\t\t\t\t\tip_geo_data=\"$json_geo_city, $json_geo_region, $json_geo_cc\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tip_geo_data=\"Unknown\"\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ \"$ip_geo_countryname\" = \"Unknown\" ]; then\n\t\t\t\tnamecolor=\"${red}\"\n\t\t\t\tcountrycolor=\"${red}\"\n\t\t\telse\n\t\t\t\tnamecolor=\"${white}\"\n\t\t\t\tcountrycolor=\"${green}\"\n\t\t\tfi\n\t\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t\t[[ -n \"$geolocation_json_output\" ]] && geolocation_json_output+=\",\"\n\t\t\t\tgeolocation_json_output+=\"{\\\"ip\\\":\\\"$target\\\"\"\n\t\t\t\tgeolocation_json_output+=\",\\\"city\\\":\\\"$json_geo_city\\\"\"\n\t\t\t\tgeolocation_json_output+=\",\\\"region\\\":\\\"$json_geo_region\\\"\"\n\t\t\t\tgeolocation_json_output+=\",\\\"country\\\":\\\"$ip_geo_countryname\\\"\"\n\t\t\t\tgeolocation_json_output+=\",\\\"cc\\\":\\\"$json_geo_cc\\\"\"\n\t\t\t\tgeolocation_json_output+=\",\\\"hits\\\":$(grep -c \"$target\" <<<\"$targetlist_allips\")\"\n\t\t\t\t[[ \"$IS_ANYCAST\" = true ]] && geolocation_json_output+=\",\\\"is_anycast\\\": true\"\n\t\t\t\tgeolocation_json_output+=\"}\"\n\t\t\telse\n\t\t\t\tfinal_output+=$(printf \"${white}%-16s${default}: ${namecolor}%s${default} (${countrycolor}%s${default}) %s\" \"$target\" \"$ip_geo_data\" \"$ip_geo_countryname\" \"$anycast_tag\\n\")\n\t\t\t\tcountrylist+=\"\\n$ip_geo_countryname\"\n\t\t\tfi\n\t\tdone\n\n\t\t[[ \"$LAST_BATCH\" = true ]] && break\n\t\tfirstip=$(( lastip++ ))\n\tdone\n\n\tStatusbarMessage\n\n\t[[ \"$JSON_OUTPUT\" = true ]] && return\n\n\techo -en \"${final_output}\"\n\n\t# top 10 IPs\n\tif [ -n \"$top10_ipv4\" ]; then\n\t\tBoxHeader \"Top 10 IPv4 by number of hits\"\n\t\tfor entry in $top10_ipv4; do\n\t\t\tiphits=$(awk '{print $1}' <<<\"$entry\")\n\t\t\tipaddr=$(awk '{ print substr($0, index($0,$2)) }' <<<\"$entry\")\n\t\t\tprintf \"${white}%16s appears ${magenta}%s${default} time%s\\n\" \"$ipaddr\" \"$iphits\" \"$([[ \"$iphits\" != \"1\" ]] && echo -n \"s\")\"\n\t\tdone\n\tfi\n\tif [ -n \"$top10_ipv6\" ]; then\n\t\tBoxHeader \"Top 10 IPv6 by number of hits\"\n\t\tfor entry in $top10_ipv6; do\n\t\t\tiphits=$(awk '{print $1}' <<<\"$entry\")\n\t\t\tipaddr=$(awk '{ print substr($0, index($0,$2)) }' <<<\"$entry\")\n\t\t\tprintf \"${white}%16s appears ${magenta}%s${default} time%s\\n\" \"$ipaddr\" \"$iphits\" \"$([[ \"$iphits\" != \"1\" ]] && echo -n \"s\")\"\n\t\tdone\n\tfi\n\n\t# draw countries bar chart\n\tBoxHeader \"Country stats\"\n\tDrawChart \"$countrylist\" \"IP\"\n}\n\nDrawChart(){\n\t# draws a bar chart for the occurrences of values from a list.\n\t# $1 must be a list of values (not necessarily sorted)\n\t# $2 must be the unit name of the bars (singular. A final 's' is added for bars whose value is > 1)\n\t# [optional] $3 can be the number of items to display (i.e. TOP n)\n\tinputlist=\"$1\"\n\tunitname=\"$2\"\n\t[[ -n \"$3\" ]] && topn=\"$3\" || topn=\"0\"\n\tsorted_input=\"\"\n\tdeclare -A valuearray # associative array\n\tdeclare -a sorted_input # simple array, to be used as an index into valuearray\n\tfor item in $(echo -e \"$inputlist\" | sort | grep -Ev '^$' | uniq -c | sort -rn); do\n\t\titemhits=$(awk '{print $1}' <<<\"$item\")\n\t\titemname=$(awk '{ print substr($0, index($0,$2)) }' <<<\"$item\")\n\t\tvaluearray[\"$itemname\"]=\"$itemhits\"\n\t\tsorted_input+=(\"$itemname\")\n\tdone\n\n\ttotal_unique_names=\"${#sorted_input[@]}\"\n\tlongest_itemname=$(echo -e \"$inputlist\" | wc -L)\n\tcount=0\n\twhile true; do\n\t\titem=${sorted_input[$count]}\n\t\t# incrementally choose color for the bar and index for the item array entry - skip 0 (black)\n\t\t[[ \"$MONOCHROME_MODE\" = false ]] && tput setaf $(( count + 1 ))\n\t\titemhits=\"${valuearray[$item]}\"\n\t\tspacing=\"$itemhits\"\n\t\t[[ \"$itemhits\" -gt \"$terminal_width\" ]] && spacing=$(( terminal_width-(14+longest_itemname) ))\n\t\tprintf \" %${longest_itemname}s \" \"$item\"\n\t\tprintf \"█%.0s\" $(seq \"$spacing\")\n\t\tprintf \" %s ${unitname}%s\\n\" \"$itemhits\" \"$([[ \"$itemhits\" != \"1\" ]] && echo -n \"s\")\"\n\t\t(( count++ ))\n\t\tif [ \"$topn\" != \"0\" ] && [ \"$count\" -ge \"$topn\" ]; then\n\t\t\tbreak\n\t\telif [ \"$count\" -ge \"$total_unique_names\" ]; then\n\t\t\tbreak\n\t\tfi\n\tdone\n\techo -e \"${default}\"\n}\n\nPrintJsonOutput(){\n\tDisableColors\n\tendtime=$(date +%s)\n\truntime=$((endtime-starttime))\n\tjson_to_print=\"{\\\"target\\\":\\\"$userinput\\\",\"\n\tjson_to_print+=\"\\\"target_type\\\":\\\"$json_target_type\\\",\"\n\tjson_to_print+=\"\\\"result\\\":\\\"$status_json_output\\\",\"\n\tjson_to_print+=\"\\\"reason\\\":\\\"$reason_json_output\\\",\"\n\tjson_to_print+=\"\\\"version\\\":\\\"$ASN_VERSION\\\",\"\n\tjson_to_print+=\"\\\"request_time\\\":\\\"$json_request_time\\\",\"\n\tjson_to_print+=\"\\\"request_duration\\\":$runtime,\"\n\tjson_to_print+=\"\\\"api_tokens\\\":{\"\n\tjson_to_print+=\"\\\"ipqualityscore\\\":$json_IQS_TOKEN,\"\n\tjson_to_print+=\"\\\"ipinfo\\\":$json_IPINFO_TOKEN,\"\n\tjson_to_print+=\"\\\"cloudflare\\\":$json_CLOUDFLARE_TOKEN\"\n\tjson_to_print+=\"},\"\n\tjson_to_print+=\"\\\"result_count\\\":$json_resultcount,\"\n\tif [ \"$RECON_MODE\" = true ] || [ \"$BGP_UPSTREAM_MODE\" = true ]; then\n\t\t# we already have an array as a final json output, append it as-is\n\t\tjson_to_print+=\"\\\"results\\\":${final_json_output}}\"\n\telse\n\t\tjson_to_print+=\"\\\"results\\\":[${final_json_output}]}\"\n\tfi\n\t[[ \"$JSON_PRETTY\" = true ]] && json_to_print=$(jq -M '.' <<<\"$json_to_print\") || json_to_print=$(jq -c '.' <<<\"$json_to_print\")\n\techo -e \"$json_to_print\"\n}\n\nResolveWellKnownPort(){\n\t# input: port number, output: service name\n\t[[ -n \"$WELL_KNOWN_PORTS\" ]] && awk \"/\\t$1\\/(tc|ud)p/{print \\$1; exit}\" <<<\"$WELL_KNOWN_PORTS\"\n}\n\nRPKILookup(){\n\t# $1=asn, $2=prefix\n\tfound_rpkivalidity=\"\"\n\tINVALID_ROA=false\n\trpki_apioutput=$(docurl -s \"https://stat.ripe.net/data/rpki-validation/data.json?resource=$1&prefix=$2&sourceapp=nitefood-asn\")\n\tis_valid_json=$(jq type <<<\"$rpki_apioutput\" 2>/dev/null)\n\tif [ -n \"$is_valid_json\" ]; then\n\t\tfound_rpkivalidity=$(jq -r '.data.status' <<<\"$rpki_apioutput\" | tr '[:lower:]' '[:upper:]')\n\t\tfound_rpkiroacount=$(jq '.data.validating_roas | length' <<<\"$rpki_apioutput\")\n\t\troacount_json_output=\"$found_rpkiroacount\"\n\t\tfound_rpkiprefix=$(jq -r '.data.validating_roas[0].prefix' <<<\"$rpki_apioutput\")\n\t\tfound_rpkiorigins=$(jq -r '.data.validating_roas[] | select (.prefix==\"'\"$found_rpkiprefix\"'\") | .origin' <<<\"$rpki_apioutput\")\n\t\tfound_rpkiorigin=\"[\"\n\t\torigin_count=0\n\t\tfor origin in $found_rpkiorigins; do\n\t\t\t[[ \"$origin_count\" -gt 0 ]] && found_rpkiorigin+=\", \"\n\t\t\tfound_rpkiorigin+=\"AS$origin\"\n\t\t\t(( origin_count++ ))\n\t\tdone\n\t\tfound_rpkiorigin+=\"]\"\n\n\t\tfound_rpkimaxlength=$(jq -r '.data.validating_roas[0].max_length' <<<\"$rpki_apioutput\")\n\t\t# TODO: iterate over ROAs (.data.validatingRoas[]) to give deeper source RIR insight\n\t\t#found_rpkisource=$(echo \"$rpki_apioutput\" | jq -r '.data.validatingRoas[0].source')\n\t\tcase \"$found_rpkivalidity\" in\n\t\t\t\"VALID\")\n\t\t\t\t[[ \"${found_rpkiroacount}\" -gt 1 ]] && s=\"s\" || s=\"\"\n\t\t\t\trpki_output=\"${green}✓ VALID (${found_rpkiroacount} ROA$s found)${default}\"\n\t\t\t\troavalidity_json_output=\"valid\"\n\t\t\t\t;;\n\t\t\t\"UNKNOWN\")\n\t\t\t\trpki_output=\"${yellow}✓ UNKNOWN (no ROAs found)${default}\"\n\t\t\t\troavalidity_json_output=\"unknown\"\n\t\t\t\t;;\n\t\t\t\"INVALID_ASN\")\n\t\t\t\tINVALID_ROA=true\n\t\t\t\troavalidity_json_output=\"invalid\"\n\t\t\t\tif [ \"$found_rpkiorigin\" = \"0\" ]; then\n\t\t\t\t\trpki_output=\"${red}❌ ${found_rpkivalidity} (no Origin authorized to announce Prefix '${found_rpkiprefix}' with Max-Length=${found_rpkimaxlength})${default}\"\n\t\t\t\telse\n\t\t\t\t\trpki_output=\"${red}❌ ${found_rpkivalidity} (expected Origin(s): ${found_rpkiorigin} for Prefix '${found_rpkiprefix}' with Max-Length=${found_rpkimaxlength})${default}\"\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\"INVALID_LENGTH\")\n\t\t\t\tINVALID_ROA=true\n\t\t\t\troavalidity_json_output=\"invalid\"\n\t\t\t\trpki_output=\"${red}❌ ${found_rpkivalidity} (expected Max-Length=${found_rpkimaxlength} for Prefix '${found_rpkiprefix}')${default}\"\n\t\t\t\t;;\n\t\tesac\n\telse\n\t\trpki_output=\"${yellow}? (WRONG RPKI DATA or problem accessing RIPEStat API)${default}\"\n\t\troacount_json_output=\"-1\"\n\t\troavalidity_json_output=\"unknown (API error)\"\n\tfi\n}\n\nIsIXP() {\n\t# input ($1) is an IPv4/v6.\n\tixp_full_ix_data=\"\"\n\tixp_data=\"\"\n\tixp_geo=\"\"\n\tinput_is_ipv6=false\n\tif [ \"$IXP_DETECTION\" = true ]; then\n\t\techo -e \"$1\" | grep -q ':' && input_is_ipv6=true\n\t\t# Update IXP prefixes from PeeringDB if necessary\n\t\t# use the appropriate (v4/v6) IXP prefix dataset\n\t\tif [ \"$input_is_ipv6\" = false ]; then\n\t\t\t# if input is an IPv4, speedup lookups further by grabbing only IXP prefixes starting with the same two octets\n\t\t\t# we can afford filtering based on the first two octets since the largest individual IXP prefix is around /20\n\t\t\tfirst_octets=$(echo \"${1}.\" | cut -d '.' -f 1,2)\n\t\t\t# see if the PEERINGDB_CACHED_DATASETS array already an entry for this prefix's first two octets.\n\t\t\t# If not, fetch the relevant IXP prefix dataset from PeeringDB and store it in the PEERINGDB_CACHED_DATASETS\n\t\t\tif [ -n \"${PEERINGDB_CACHED_DATASETS[$first_octets]}\" ]; then\n\t\t\t\tpeeringdb_dataset=\"${PEERINGDB_CACHED_DATASETS[$first_octets]}\"\n\t\t\telse\n\t\t\t\tpeeringdb_ipv4_dataset=$(docurl -s \"https://www.peeringdb.com/api/ixpfx?prefix__startswith=$first_octets&protocol__in=IPv4\")\n\t\t\t\tpeeringdb_dataset=\"$peeringdb_ipv4_dataset\"\n\t\t\t\t# store the IXP dataset in the PEERINGDB_CACHED_DATASETS array\n\t\t\t\tPEERINGDB_CACHED_DATASETS[$first_octets]=\"$peeringdb_dataset\"\n\t\t\tfi\n\t\telse\n\t\t\t# only fetch IPv6 dataset once, since we don't filter it for prefixes\n\t\t\tif [ -z \"$peeringdb_ipv6_dataset\" ]; then\n\t\t\t\tpeeringdb_ipv6_dataset=$(docurl -s \"https://www.peeringdb.com/api/ixpfx?protocol__in=IPv6\")\n\t\t\tfi\n\t\t\tpeeringdb_dataset=\"$peeringdb_ipv6_dataset\"\n\t\tfi\n\t\tixp_prefixes=$(jq -r '.data[].prefix' <<<\"$peeringdb_dataset\" 2>/dev/null)\n\t\t# search for input prefix through PeeringDB IXP prefix list\n\t\tfor prefix in $ixp_prefixes; do\n\t\t\tif echo \"$1\" | grepcidr -f <(echo \"$prefix\") &>/dev/null; then\n\t\t\t\t# the IP is part of an IXP prefix\n\t\t\t\tixlan_id=$(jq -r '.data[] | select(.prefix == \"'\"$prefix\"'\") | .ixlan_id' <<<\"$peeringdb_dataset\")\n\t\t\t\t# see if the PEERINGDB_CACHED_IXP_DATA array already has an entry with the IXP details for this ixlan_id.\n\t\t\t\t# If not, fetch the full IXP data from PeeringDB and store it in the PEERINGDB_CACHED_IXP_DATA\n\t\t\t\tif [ -n \"${PEERINGDB_CACHED_IXP_DATA[$ixlan_id]}\" ]; then\n\t\t\t\t\tixp_full_ix_data=\"${PEERINGDB_CACHED_IXP_DATA[$ixlan_id]}\"\n\t\t\t\telse\n\t\t\t\t\t# Query PeeringDB to match an IXP for that prefix.\n\t\t\t\t\tixp_full_ix_data=$(docurl -s \"https://www.peeringdb.com/api/ix/$ixlan_id\")\n\t\t\t\t\t# store the IXP data in the PEERINGDB_CACHED_IXP_DATA array\n\t\t\t\t\tPEERINGDB_CACHED_IXP_DATA[$ixlan_id]=\"$ixp_full_ix_data\"\n\t\t\t\tfi\n\t\t\t\tixp_data=$(jq -r '.data[0].name, .data[0].name_long' <<<\"$ixp_full_ix_data\" | paste -sd '|' - | awk -F'|' '{print $1 \" (\" $2 \")\"}')\n\t\t\t\tixp_geo=$(jq -r '.data[0].org.city' <<<\"$ixp_full_ix_data\")\n\t\t\t\tixp_state=$(jq -r '.data[0].org.state' <<<\"$ixp_full_ix_data\")\n\t\t\t\tixp_country=$(jq -r '.data[0].org.country' <<<\"$ixp_full_ix_data\")\n\t\t\t\tip_type_data=\" ${lightgreybg} IXP ${default}\"\n\t\t\t\t[[ -n \"$ixp_state\" ]] && ixp_geo+=\", $ixp_state\"\n\t\t\t\t[[ -n \"$ixp_country\" ]] && ixp_geo+=\" ($ixp_country)\"\n\t\t\t\t[[ \"$IS_ASN_CHILD\" = true ]] && ixp_data=\"<a href=\\\"https://www.peeringdb.com/ix/$ixlan_id\\\" target=\\\"_blank\\\" class=\\\"hidden_underline\\\" style=\\\"color: $htmlblue;\\\">$ixp_data</a>\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\tfi\n}\n\nGetIXPresence(){\n\tasn=\"$1\"\n\tixps=\"\"\n\toutputix=\"\"\n\tjson_ixps=\"\"\n\tnetlist=$(docurl -s \"https://www.peeringdb.com/api/net?asn__in=$asn\" | jq -r '.data[].id')\n\tif [ -n \"$netlist\" ]; then\n\t\tfor net in $netlist; do\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\tixps+=$(docurl -s \"https://www.peeringdb.com/api/net/$net\" | jq -r '.data[].netixlan_set[] | \"<a href=\\\"https://www.peeringdb.com/ix/\\(.ix_id)\\\" target=\\\"_blank\\\" class=\\\"hidden_underline\\\" style=\\\"color: '\"$htmlblue\"';\\\">\\(.name)</a>\"')\n\t\t\telse\n\t\t\t\tixps+=$(docurl -s \"https://www.peeringdb.com/api/net/$net\" | jq -r '.data[].netixlan_set[].name')\n\t\t\tfi\n\t\tdone\n\t\tif [ -n \"$ixps\" ]; then\n\t\t\tfor ix in $(echo \"$ixps\" | sort -u); do\n\t\t\t\t[[ -n \"$outputix\" ]] && outputix+=\" • \"\n\t\t\t\toutputix+=\"${blue}${ix}${default}\"\n\t\t\tdone\n\t\telse\n\t\t\toutputix=\"${redbg} NONE ${default}\"\n\t\tfi\n\telse\n\t\toutputix=\"${redbg} NONE ${default}\"\n\tfi\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t# json output\n\t\tjson_ixps=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$ixps\")\n\telse\n\t\t# normal output\n\t\techo -e \"$outputix\"\n\tfi\n}\n\nGetCAIDARank(){\n\t# see if we already have CAIDA rank cached for this AS\n\tasn=\"$1\"\n\tif [ -n \"${CAIDARANK_CACHED_AS_DATA[$asn]}\" ]; then\n\t\tcaida_data=\"${CAIDARANK_CACHED_AS_DATA[$asn]}\"\n\telse\n\t\tcaida_data=$(docurl -s \"https://api.asrank.caida.org/dev/restful/asns/${asn}\")\n\t\t# store the rank in the CAIDARANK_CACHED_AS_DATA array\n\t\tCAIDARANK_CACHED_AS_DATA[$asn]=\"$caida_data\"\n\tfi\n\tcaida_asrank_text=\"\"\n\tcaida_asrank=$(jq -r '.data.asn.rank' <<<\"$caida_data\")\n\tif [ \"$caida_asrank\" != \"null\" ]; then\n\t\tcaida_rir=$(jq -r '.data.asn.source' <<<\"$caida_data\")\n\t\tcase \"${caida_rir}\" in\n\t\t\t\"AFRINIC\")\n\t\t\t\tcaida_rir=\"AFRINIC ${dim}(Africa)${default}\"\n\t\t\t;;\n\t\t\t\"APNIC\")\n\t\t\t\tcaida_rir=\"APNIC ${dim}(Asia Pacific)${default}\"\n\t\t\t;;\n\t\t\t\"ARIN\")\n\t\t\t\tcaida_rir=\"ARIN ${dim}(USA, Canada, many Caribbean and North Atlantic islands)${default}\"\n\t\t\t;;\n\t\t\t\"LACNIC\")\n\t\t\t\tcaida_rir=\"LACNIC ${dim}(Latin America and the Caribbean)${default}\"\n\t\t\t;;\n\t\t\t\"RIPE\")\n\t\t\t\tcaida_rir=\"RIPE ${dim}(Europe, the Middle East and parts of Central Asia)${default}\"\n\t\t\t;;\n\t\tesac\n\n\t\tcaida_customercone=$(jq -r '.data.asn.cone.numberAsns' <<<\"$caida_data\")\n\t\tcaida_degree_total=$(jq -r '.data.asn.asnDegree.total' <<<\"$caida_data\")\n\t\tcaida_degree_customer=$(jq -r '.data.asn.asnDegree.customer' <<<\"$caida_data\")\n\t\tcaida_degree_peer=$(jq -r '.data.asn.asnDegree.peer' <<<\"$caida_data\")\n\t\tcaida_degree_provider=$(jq -r '.data.asn.asnDegree.provider' <<<\"$caida_data\")\n\t\tif (( caida_asrank <= 10 )); then\n\t\t\tcaida_asrank_text=\" ${lightgreybg} TOP 10 AS ${default}\"\n\t\telif (( caida_asrank <= 35 )); then\n\t\t\tcaida_asrank_text=\" ${lightgreybg} TOP 35 AS ${default}\"\n\t\telif (( caida_asrank <= 100 )); then\n\t\t\tcaida_asrank_text=\" ${lightgreybg} TOP 100 AS ${default}\"\n\t\telif (( caida_asrank <= 500)); then\n\t\t\tcaida_asrank_text=\" ${lightgreybg} TOP 500 AS ${default}\"\n\t\telif (( caida_asrank <= 1000)); then\n\t\t\tcaida_asrank_text=\" ${lightgreybg} TOP 1000 AS ${default}\"\n\t\tfi\n\t\tcaida_asrank_recap=\"${dim}#${white}${caida_asrank}${caida_asrank_text}\"\n\telse\n\t\tcaida_asrank=\"N/A\"\n\t\tcaida_customercone=\"N/A\"\n\t\tcaida_rir=\"N/A\"\n\t\tcaida_customercone=\"N/A\"\n\t\tcaida_degree_total=\"N/A\"\n\t\tcaida_degree_provider=\"N/A\"\n\t\tcaida_degree_peer=\"N/A\"\n\t\tcaida_degree_customer=\"N/A\"\n\t\tcaida_asrank_recap=\"${dim}N/A\"\n\tfi\n}\n\nGetCloudflareHijacksAndLeaks(){\n\t# query Cloudflare Radar API for BGP hijacks or route leaks involving the target ASN in the past 12 months\n\tasn=\"$1\"\n\tcf_hijacks_text=\"${dim}${red}N/A${default}${dim} [Cloudflare query timed out or API error]\"\n\tcf_leaks_text=\"${dim}${red}N/A${default}${dim} [Cloudflare query timed out or API error]\"\n\tcf_hijack_query_success=false\n\tcf_leak_query_success=false\n\n\tif [ -z \"$CLOUDFLARE_TOKEN\" ]; then\n\t\tcf_hijacks_text=\"${dim}${red}N/A${default}${dim} [Cloudflare API token missing]${default}\"\n\t\tcf_leaks_text=\"${dim}${red}N/A${default}${dim} [Cloudflare API token missing]${default}\"\n\t\treturn\n\tfi\n\n\tStatusbarMessage \"Retrieving BGP hijacks and leaks history for AS${asn} (${target_asname})\"\n\tcf_hijacks_json_output=$(docurl -m 10 -s -H \"Authorization: Bearer $CLOUDFLARE_TOKEN\" \"https://api.cloudflare.com/client/v4/radar/bgp/hijacks/events?dateRange=52w&involvedAsn=$asn\")\n\tcf_leaks_json_output=$(docurl -m 10 -s -H \"Authorization: Bearer $CLOUDFLARE_TOKEN\" \"https://api.cloudflare.com/client/v4/radar/bgp/leaks/events?dateRange=52w&involvedAsn=$asn\")\n\tif [ -n \"$cf_hijacks_json_output\" ]; then\n\t\tcf_hijacks_count=$(jq -r '.result_info.total_count' <<<\"$cf_hijacks_json_output\" 2>/dev/null)\n\t\tif [ -z \"$cf_hijacks_count\" ]; then\n\t\t\tStatusbarMessage\n\t\t\treturn\n\t\tfi\n\t\tcf_hijacks_as_hijacker_count=$(jq -r \".result.events | map(select (.hijacker_asn == $asn)) | length\" <<<\"$cf_hijacks_json_output\" 2>/dev/null)\n\t\tif [ -z \"$cf_hijacks_as_hijacker_count\" ]; then\n\t\t\tStatusbarMessage\n\t\t\treturn\n\t\tfi\n\t\tcf_hijacks_as_victim_count=$((cf_hijacks_count - cf_hijacks_as_hijacker_count))\n\t\tif [ \"$cf_hijacks_count\" -gt 0 ]; then\n\t\t\t# at least one hijack incident involving this AS\n\t\t\t[[ \"$cf_hijacks_count\" -gt 1 ]] && s=\"s\" || s=\"\"\n\t\t\tcf_hijacks_text=\"${white}Involved in ${magenta}$cf_hijacks_count${white} BGP hijack incident${s}\"\n\t\t\tif [ \"$cf_hijacks_as_hijacker_count\" -gt 0 ] && [ \"$cf_hijacks_as_victim_count\" -gt 0 ]; then\n\t\t\t\t# mixed situations involving this AS (both hijacker and victim)\n\t\t\t\tcf_hijacks_text=\"${cf_hijacks_text} (of which ${red}$cf_hijacks_as_hijacker_count${white} as a hijacker and ${green}$cf_hijacks_as_victim_count${white} as a victim)${default}\"\n\t\t\telif [ \"$cf_hijacks_as_hijacker_count\" -gt 0 ]; then\n\t\t\t\t# this AS was always a hijacker\n\t\t\t\tcf_hijacks_text=\"${cf_hijacks_text} ${red}(always as a hijacker)${default}\"\n\t\t\telse\n\t\t\t\t# this AS was always a victim\n\t\t\t\tcf_hijacks_text=\"${cf_hijacks_text} ${green}(always as a victim)${default}\"\n\t\t\tfi\n\t\telse\n\t\t\t# no hijack incidents involving this AS\n\t\t\tcf_hijacks_text=\"${green}None${default}\"\n\t\tfi\n\tfi\n\tcf_hijack_query_success=true\n\n\tif [ -n \"$cf_leaks_json_output\" ]; then\n\t\tcf_leaks_count=$(jq -r '.result_info.total_count' <<<\"$cf_leaks_json_output\" 2>/dev/null)\n\t\tif [ -z \"$cf_leaks_count\" ]; then\n\t\t\tStatusbarMessage\n\t\t\treturn\n\t\tfi\n\t\tif [ \"$cf_leaks_count\" -gt 0 ]; then\n\t\t\t# at least one route leak incident involving this AS\n\t\t\t[[ \"$cf_leaks_count\" -gt 1 ]] && s=\"s\" || s=\"\"\n\t\t\tcf_leaks_text=\"${white}Involved in ${yellow}$cf_leaks_count${white} BGP route leak incident${s}${default}\"\n\t\telse\n\t\t\t# no route leak incidents involving this AS\n\t\t\tcf_leaks_text=\"${green}None${default}\"\n\t\tfi\n\tfi\n\tcf_leak_query_success=true\n\n\tStatusbarMessage\n}\n\nIPGeoRepLookup(){\n\tif [ -n \"$mtr_output\" ] && [ \"$DETAILED_TRACE\" = false ]; then\n\t\t# skip geolocation and reputation lookups for individual trace hops in non-detailed mode\n\t\treturn\n\tfi\n\n\tip_geo_data=\"\"\n\tip_geo_countryname=\"\"\n\tgeo_city_json_output=\"\"\n\tgeo_region_json_output=\"\"\n\tgeo_country_json_output=\"\"\n\tgeo_cc_json_output=\"\"\n\tipinfo_city=\"\"\n\tflag_icon_cc=\"\" # will be used in HTML reports served over HTTP\n\tIS_ANYCAST=\"\"\n\t# local ipmap_city\n\t# local ipmap_region\n\t# local ipmap_cc\n\t# local ipmap_country_name\n\t# local ipmap_location_data\n\tlocal ipinfo_city\n\tlocal ipinfo_region\n\tlocal ipinfo_cc\n\tlocal ipinfo_countryname\n\tlocal ipapi_city\n\tlocal ipapi_region\n\tlocal ipapi_cc\n\tlocal ipapi_countryname\n\tlocal ipapi_output\n\tlocal ipapi_status\n\tlocal ipapi_errmsg\n\n\tStatusbarMessage \"Collecting geolocation and classification data\"\n\n\t# fetch preferred geolocation and anycast data from ipinfo.io (pass token regardless of whether IPINFO_TOKEN is set, ipinfo API does not complain for an empty token)\n\tipinfo_output=$(docurl -m4 -s \"https://ipinfo.io/$1?token=${IPINFO_TOKEN}\")\n\n\t# fetch fallback geolocation and ip type (is mobile?) data from ip-api.com\n\t# Note: the free IP-API tier only supports unencrypted HTTP, not HTTPS\n\tipapi_output=$(docurl -m4 -s \"http://ip-api.com/json/$1?fields=status,message,country,countryCode,regionName,city,mobile,proxy,hosting\")\n\tipapi_status=$(jq -r '.status' <<<\"$ipapi_output\")\n\tif [ \"$ipapi_status\" = \"fail\" ]; then\n\t\tipapi_errmsg=$(jq -r '.message' <<<\"$ipapi_output\")\n\t\tip_rep_data=\"${red}IP-API ERROR:${default} ${ipapi_errmsg}\"\n\telse\n\t\tIS_MOBILE=$(jq -r '.mobile' <<<\"$ipapi_output\")\n\t\tIS_PROXY=$(jq -r '.proxy' <<<\"$ipapi_output\")\n\t\tIS_HOSTING=$(jq -r '.hosting' <<<\"$ipapi_output\")\n\tfi\n\n\t# ipmap_location_data=$(jq 'select (.location != null) | .location' <<<\"$ipmap_output\")\n\t# if [ -n \"$ipmap_location_data\" ]; then\n\t# \t# RIPE IPmap has (at least some) geo data about this address, check city/region\n\t# \tipmap_city=$(jq -r 'select (.cityNameAscii != null) | .cityNameAscii' <<<\"$ipmap_location_data\")\n\t# \tipmap_region=$(jq -r 'select (.stateName != null) | .stateName' <<<\"$ipmap_location_data\")\n\t# fi\n\n\t# check if ipinfo.io returned valid JSON\n\tif jq type <<<\"$ipinfo_output\" &>/dev/null; then\n\t\tif jq '.anycast' <<<\"$ipinfo_output\" | grep -q true; then\n\t\t\tIS_ANYCAST=true\n\t\tfi\n\t\tipinfo_city=$(jq -r 'select (.city != null) | .city' <<<\"$ipinfo_output\")\n\t\tipinfo_region=$(jq -r 'select (.region != null) | .region' <<<\"$ipinfo_output\")\n\t\tipinfo_cc=$(jq -r 'select (.country != null) | .country' <<<\"$ipinfo_output\")\n\t\tipinfo_countryname=$(jq -r \".${ipinfo_cc}\" <<<\"$COUNTRY_MAP_CACHE\")\n\tfi\n\n\tif [ -n \"$ipinfo_city\" ]; then\n\t\t# populate json output fields from ipinfo output\n\t\tgeo_city_json_output=\"$ipinfo_city\"\n\t\tgeo_region_json_output=\"$ipinfo_region\"\n\t\tgeo_country_json_output=\"$ipinfo_countryname\"\n\t\tgeo_cc_json_output=\"$ipinfo_cc\"\n\t\tip_geo_data=\"$ipinfo_city, $ipinfo_region ($ipinfo_cc)\"\n\t\tflag_icon_cc=$(tr '[:upper:]' '[:lower:]' <<<\"$ipinfo_cc\")\n\t\tip_geo_countryname=\"$ipinfo_countryname\"\n\telif [ \"$ipapi_status\" = \"success\" ]; then\n\t\t# ipinfo has no data about this address or returned an invalid response, fallback to ip-api.com\n\t\tipapi_city=$(jq -r '.city' <<<\"$ipapi_output\")\n\t\tipapi_region=$(jq -r '.regionName' <<<\"$ipapi_output\")\n\t\tipapi_cc=$(jq -r '.countryCode' <<<\"$ipapi_output\")\n\t\tipapi_countryname=$(jq -r '.country' <<<\"$ipapi_output\")\n\t\t# populate json output fields from ip-api output\n\t\tgeo_city_json_output=\"$ipapi_city\"\n\t\tgeo_region_json_output=\"$ipapi_region\"\n\t\tgeo_country_json_output=\"$ipapi_countryname\"\n\t\tgeo_cc_json_output=\"$ipapi_cc\"\n\t\tif [ -n \"$ipapi_city\" ] && [ -n \"$ipapi_region\" ] && [ -n \"$ipapi_cc\" ]; then\n\t\t\tip_geo_data=\"$ipapi_city, $ipapi_region ($ipapi_cc)\"\n\t\t\tip_geo_countryname=\"$ipapi_countryname\"\n\t\t\tflag_icon_cc=$(tr '[:upper:]' '[:lower:]' <<<\"$ipapi_cc\")\n\t\telif [ -n \"$ipapi_region\" ] && [ -n \"$ipapi_countryname\" ]; then\n\t\t\tip_geo_data=\"$ipapi_region ($ipapi_countryname)\"\n\t\t\tip_geo_countryname=\"$ipapi_countryname\"\n\t\telif [ -n \"$ipapi_countryname\" ]; then\n\t\t\tip_geo_data=\"$ipapi_countryname\"\n\t\t\tip_geo_countryname=\"$ipapi_countryname\"\n\t\tfi\n\tfi\n\n\t# IP type identification\n\tip_type_data=\"\"\n\tif [ \"$IS_ANYCAST\" = true ]; then\n\t\tip_type_data+=\" ${yellowbg} Anycast IP ${default}\"\n\t\tip_type_json_output+=\",\\\"is_anycast\\\":true\"\n\telse\n\t\tip_type_json_output+=\",\\\"is_anycast\\\":false\"\n\tfi\n\tif [ \"$IS_MOBILE\" = true ]; then\n\t\tip_type_data+=\" ${yellowbg} Mobile network IP ${default}\"\n\t\tip_type_json_output+=\",\\\"is_mobile\\\":true\"\n\telse\n\t\tip_type_json_output+=\",\\\"is_mobile\\\":false\"\n\tfi\n\tif [ \"$IS_PROXY\" = true ]; then\n\t\tip_type_data+=\" ${yellowbg} Proxy host ${default}\"\n\t\tip_type_json_output+=\",\\\"is_proxy\\\":true\"\n\telse\n\t\tip_type_json_output+=\",\\\"is_proxy\\\":false\"\n\tfi\n\t# fetch detailed DC information (incolumitas.com Datacenter IP Address API)\n\tincolumitas_dcdata=$(docurl -m2 -s \"https://api.incolumitas.com/datacenter?ip=$1\")\n\tdcname=$(jq -r 'select (.datacenter.datacenter != null) | .datacenter.datacenter' <<<\"$incolumitas_dcdata\" 2>/dev/null)\n\tdcregion=$(jq -r 'select (.datacenter.region != null) | .datacenter.region' <<<\"$incolumitas_dcdata\" 2>/dev/null)\n\tif [ -n \"$dcname\" ]; then\n\t\t# incolumitas.com has details regarding this DC\n\t\tip_type_data+=\" ${yellowbg} DC ${default}${yellow} $dcname\"\n\t\tip_type_json_output+=\",\\\"is_dc\\\":true\"\n\t\tip_type_json_output+=\",\\\"dc_details\\\":{\\\"dc_name\\\":\\\"$dcname\\\"\"\n\t\tif [ -n \"$dcregion\" ]; then\n\t\t\tip_type_data+=\" ($dcregion)\"\n\t\t\tip_type_json_output+=\",\\\"dc_region\\\":\\\"$dcregion\\\"\"\n\t\tfi\n\t\tip_type_json_output+=\"}\"\n\t\tip_type_data+=\"${default}\"\n\telif [ \"$IS_HOSTING\" = true ]; then\n\t\t# fallback to IP-API DC detection\n\t\tip_type_data+=\" ${yellowbg} Hosting/DC ${default}\"\n\t\tip_type_json_output+=\",\\\"is_dc\\\":true\"\n\telse\n\t\tip_type_json_output+=\",\\\"is_dc\\\":false\"\n\tfi\n\t# Reputation lookup (stopforumspam.org), noise classification (greynoise.io) and threat analysis (ipqualityscore.com)\n\tip_rep_data=\"${green}✓ NONE${default}\"\n\tjson_rep=\"none\"\n\tjson_iqs_threat_score=\"\"\n\tjson_iqs_threat_tags=\"\"\n\tis_blacklisted=$(docurl -m4 -s \"https://api.stopforumspam.org/api?json&ip=$1\" | jq -r '.ip.appears')\n\tif [ \"$is_blacklisted\" = \"1\" ]; then\n\t\t# IP is blacklisted by StopForumSpam\n\t\tjson_rep=\"bad\"\n\t\tip_rep_data=\"${red}❌ BAD (on stopforumspam.org)${default}\"\n\tfi\n\tif [ -n \"$IQS_TOKEN\" ]; then\n\t\tif [ \"$is_blacklisted\" = \"1\" ] || [ \"$IQS_ALWAYS_QUERY\" = true ]; then\n\t\t\t# Lookup detailed reputation data on IPQualityScore\n\t\t\tiqs_query_url=\"https://ipqualityscore.com/api/json/ip/$IQS_TOKEN/$1\"\n\t\t\t[[ -n \"$IQS_CUSTOM_SETTINGS\" ]] && iqs_query_url+=\"?$IQS_CUSTOM_SETTINGS\"\n\t\t\tiqs_output=$(docurl -m4 -s \"$iqs_query_url\")\n\t\t\tiqs_success=$(jq -r '.success' <<<\"$iqs_output\")\n\t\t\tif [ \"$iqs_success\" = true ]; then\n\t\t\t\tiqs_score=$(jq -r '.fraud_score' <<<\"$iqs_output\")\n\t\t\t\tiqs_proxy=$(jq -r '.proxy' <<<\"$iqs_output\")\n\t\t\t\tiqs_vpn=$(jq -r '.active_vpn' <<<\"$iqs_output\")\n\t\t\t\tiqs_tor=$(jq -r '.active_tor' <<<\"$iqs_output\")\n\t\t\t\tiqs_recentabuse=$(jq -r '.recent_abuse' <<<\"$iqs_output\")\n\t\t\t\tiqs_bot=$(jq -r '.bot_status' <<<\"$iqs_output\")\n\t\t\t\tiqs_crawler=$(jq -r '.is_crawler' <<<\"$iqs_output\")\n\t\t\t\tjson_iqs_threat_score+=\",\\\"threat_score\\\":\\\"$iqs_score\\\"\"\n\t\t\t\tif [ \"$iqs_score\" -lt 40 ]; then\n\t\t\t\t\tip_rep_data=\"✓ GOOD\"\n\t\t\t\t\tip_rep_color=\"$green\"\n\t\t\t\t\tjson_rep=\"good\"\n\t\t\t\telif [ \"$iqs_score\" -lt 75 ]; then\n\t\t\t\t\tip_rep_data=\"✓ AVERAGE\"\n\t\t\t\t\tip_rep_color=\"$green\"\n\t\t\t\t\tjson_rep=\"average\"\n\t\t\t\telif [ \"$iqs_score\" -lt 85 ]; then\n\t\t\t\t\tip_rep_data=\"! SUSPICIOUS\"\n\t\t\t\t\tip_rep_color=\"$yellow\"\n\t\t\t\t\tjson_rep=\"suspicious\"\n\t\t\t\telse\n\t\t\t\t\tip_rep_data=\"❌ BAD\"\n\t\t\t\t\tip_rep_color=\"$red\"\n\t\t\t\t\tjson_rep=\"bad\"\n\t\t\t\tfi\n\t\t\t\tip_rep_data=\"${ip_rep_color}${ip_rep_data} (Threat Score ${iqs_score}%)${default}\"\n\t\t\t\t[[ \"$iqs_recentabuse\" = true ]] && ip_rep_data+=\" ${redbg} RECENT ABUSER ${default}\"; json_iqs_threat_tags+=\",\\\"is_recent_abuser\\\": true\"\n\t\t\t\t[[ \"$iqs_bot\" = true ]] && ip_rep_data+=\" ${redbg} BOT ${default}\"; json_iqs_threat_tags+=\",\\\"is_bot\\\": true\"\n\t\t\t\t[[ \"$iqs_proxy\" = true ]] && ip_rep_data+=\" ${redbg} PROXY ${default}\"; json_iqs_threat_tags+=\",\\\"is_proxy\\\": true\"\n\t\t\t\t[[ \"$iqs_vpn\" = true ]] && ip_rep_data+=\" ${redbg} VPN ${default}\"; json_iqs_threat_tags+=\",\\\"is_vpn\\\": true\"\n\t\t\t\t[[ \"$iqs_tor\" = true ]] && ip_rep_data+=\" ${redbg} TOR EXIT NODE ${default}\"; json_iqs_threat_tags+=\",\\\"is_tor\\\": true\"\n\t\t\t\t[[ \"$iqs_crawler\" = true ]] && ip_rep_data+=\" ${redbg} CRAWLER ${default}\"; json_iqs_threat_tags+=\",\\\"is_crawler\\\": true\"\n\t\t\telse\n\t\t\t\tiqs_errmsg=$(jq -r '.message' <<<\"$iqs_output\")\n\t\t\t\tip_rep_data+=\" ${redbg} ERR ${default} (IpQualityScore API said: $iqs_errmsg)\"\n\t\t\tfi\n\t\tfi\n\tfi\n\t# GreyNoise lookup\n\tgreynoise_data=$(docurl -m5 -s \"https://api.greynoise.io/v3/community/$1\")\n\tgn_noisy=false\n\tgn_riot=\"\"\n\tgn_classification=\"\"\n\tgn_name=\"\"\n\tgn_json_is_knowngood=\"\"\n\tgn_json_is_knownbad=\"\"\n\tgn_json_aka=\"\"\n\tif [ -n \"$greynoise_data\" ]; then\n\t\tgn_noisy=$(jq -r 'select (.noise != null) | .noise' <<<\"$greynoise_data\")\n\t\tgn_riot=$(jq -r 'select (.riot != null) | .riot' <<<\"$greynoise_data\")\n\t\tgn_classification=$(jq -r 'select (.classification != null) | .classification' <<<\"$greynoise_data\")\n\t\tgn_name=$(jq -r 'select (.name != null) | .name' <<<\"$greynoise_data\")\n\t\tif [ \"$gn_name\" = \"unknown\" ]; then\n\t\t\tgn_name=\"${default}\"\n\t\telse\n\t\t\tgn_json_aka=\"$gn_name\"\n\t\t\tgn_name=\"as \\\"$gn_name\\\" ${default}\"\n\t\tfi\n\t\tif [ \"$gn_riot\" = \"true\" ] || [ \"$gn_classification\" = \"benign\" ]; then\n\t\t\t# GreyNoise known-good\n\t\t\tip_rep_data=\"${green}✓${default} ${greenbg} KNOWN GOOD $gn_name\"\n\t\t\tjson_rep=\"good\"\n\t\t\tgn_json_is_knowngood=true\n\t\t\t[[ \"$gn_noisy\" = \"true\" ]] && ip_rep_data+=\" ${yellowbg} SEEN SCANNING ${default}\"\n\t\telif [ \"$gn_classification\" = \"malicious\" ]; then\n\t\t\t# GreyNoise known-bad\n\t\t\t[[ \"$is_blacklisted\" != \"1\" ]] && ip_rep_data=\"${red}❌ BAD${default}\" # tag the IP with a bad REP, it wasn't caught by StopForumSpam earlier\n\t\t\tip_rep_data+=\" ${redbg} SCANNER $gn_name\"\n\t\t\tjson_rep=\"bad\"\n\t\t\tgn_json_is_knownbad=true\n\t\telse\n\t\t\t# GreyNoise not listed, or tagged as \"noisy\" but not explicitly good or bad\n\t\t\t[[ \"$gn_noisy\" = \"true\" ]] && ip_rep_data+=\" ${yellowbg} SEEN SCANNING ${default}\"\n\t\tfi\n\tfi\n\n\tStatusbarMessage\n}\n\nIPShodanLookup(){\n\t# Shodan InternetDB lookup\n\tif [ -n \"$mtr_output\" ] && [ \"$DETAILED_TRACE\" = false ]; then\n\t\t# skip Shodan lookup for individual trace hops in non-detailed mode\n\t\treturn\n\tfi\n\tip_shodan_cpe_data=\"\"\n\tip_shodan_ports_data=\"\"\n\tip_shodan_tags_data=\"\"\n\tip_shodan_cve_data=\"\"\n\tshodan_cpes_json_output=\"\"\n\tshodan_ports_json_output=\"\"\n\tshodan_tags_json_output=\"\"\n\tshodan_vulns_json_output=\"\"\n\tStatusbarMessage \"Collecting open ports, CPE and CVE data\"\n\tshodan_data=$(docurl -m5 -s \"https://internetdb.shodan.io/$1\" | grep -v \"No information available\")\n\tif [ -n \"$shodan_data\" ]; then\n\t\tshodan_cpes=$(jq -r '.cpes[]' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_cpes_json_output=$(jq -cM 'select (.cpes | length > 0) | .cpes' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_ports=$(jq -r '.ports[]' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_ports_json_output=$(jq -cM 'select (.ports | length > 0) | .ports' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_tags=$(jq -r '.tags[]' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_tags_json_output=$(jq -cM 'select (.tags | length > 0) | .tags' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_cve_count=$(jq '.vulns | length' <<<\"$shodan_data\" 2>/dev/null)\n\t\tshodan_vulns_json_output=$(jq -cM 'select (.vulns | length > 0) | .vulns' <<<\"$shodan_data\" 2>/dev/null)\n\n\t\t# fetch CPE types, possible values:\n\t\t# a for Applications, h for Hardware, o for Operating Systems\n\t\tfor cpe in $shodan_cpes; do\n\t\t\tcpetype=$(echo \"$cpe\" | cut -d ':' -f 2)\n\t\t\tcpename=$(echo \"$cpe\" | cut -d ':' -f 3-)\n\t\t\tcase \"${cpetype}\" in\n\t\t\t\t\"/a\")\n\t\t\t\t\ttype=\"APP\"\n\t\t\t\t;;\n\t\t\t\t\"/o\")\n\t\t\t\t\ttype=\"O/S\"\n\t\t\t\t;;\n\t\t\t\t\"/h\")\n\t\t\t\t\ttype=\"H/W\"\n\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\ttype=\"UNK\"\n\t\t\t\t;;\n\t\t\tesac\n\t\t\tip_shodan_cpe_data+=\"${white} [${blue}$type: ${white}$cpename]${default}\"\n\t\tdone\n\n\t\t# fetch open ports\n\t\tip_shodan_ports_data=\"\"\n\t\tfor port in $shodan_ports; do\n\t\t\t[[ -n \"$ip_shodan_ports_data\" ]] && ip_shodan_ports_data+=\",\" || ip_shodan_ports_data=\" ${green}Open ports:\"\n\t\t\tip_shodan_ports_data+=\" $port\"\n\t\tdone\n\t\t[[ -n \"$ip_shodan_ports_data\" ]] && ip_shodan_ports_data+=\"${default}\"\n\n\t\t# fetch Shodan tags\n\t\tip_shodan_tags_data=\"\"\n\t\tfor tag in $shodan_tags; do\n\t\t\tip_shodan_tags_data+=\" ${lightgreybg} $tag ${default}\"\n\t\tdone\n\n\t\t# fetch Shodan CVE count\n\t\tip_shodan_cve_data=\"\"\n\t\tif [ -n \"$shodan_cve_count\" ] && [ \"$shodan_cve_count\" != \"0\" ]; then\n\t\t\t[[ \"$shodan_cve_count\" != \"1\" ]] && vulntext=\"VULNERABILITIES\" || vulntext=\"VULNERABILITY\"\n\t\t\tip_shodan_cve_data+=\" ${redbg} $shodan_cve_count $vulntext FOUND ${default} (check \"\n\t\t\t[[ \"$IS_ASN_CHILD\" = true ]] && ip_shodan_cve_data+=\"<a href=\\\"https://internetdb.shodan.io/$1\\\" target=\\\"_blank\\\" \\\">Shodan</a>)\" || ip_shodan_cve_data+=\"https://internetdb.shodan.io/$1)\"\n\t\tfi\n\tfi\n\n\tStatusbarMessage\n}\n\nPwhoisListPrefixesForOrg(){\n\t# list all IPv4 prefixes on pWhois based on an Org-Name\n\t# $1 = Org-Name handle\n\t[[ \"$HAVE_IPCALC\" = false ]] && return\n\torg=\"$1\"\n\tfull_org_search_data=$(whois -h whois.pwhois.org \"registry org-name=$org\")\n\torgids=$(echo -e \"$full_org_search_data\" | grep -i -E -B1 \"Org-Name: $org$\" | grep \"Org-ID\" | cut -d ':' -f 2- | sed 's/^ //g')\n\t# assemble bulk pWhois query\n\tpwhois_bulk_query=\"begin\\n\"\n\tfor orgid in $orgids; do\n\t\tpwhois_bulk_query+=\"netblock org-id=${orgid}\\n\"\n\tdone\n\tpwhois_bulk_query+=\"end\"\n\t# query pWhois\n\tfor prefix in $(echo -e \"$pwhois_bulk_query\" | ncat whois.pwhois.org 43 | grep -E \"^\\*>\"); do\n\t\tiprange=$(echo -e \"$prefix\" | cut -d '>' -f 2 | cut -d '|' -f 1 | tr -d ' ')\n\t\tIpcalcDeaggregate \"$iprange\"\n\tdone\n}\n\nBGPUpstreamLookup(){\n\t# retrieve likely upstream/transit autonomous system(s) for this IP address\n\tfinal_json_output=\"[]\"\n\tif [ \"$IS_BOGON\" = true ]; then\n\t\tPrintErrorAndExit \"Error: IP $1 is a bogon address, cannot continue\"\n\telif [ -z \"$found_asname\" ]; then\n\t\tPrintErrorAndExit \"Error: IP $1 is not part of an announced prefix, cannot continue\"\n\tfi\n\n\tBoxHeader \"Recently observed upstream/transit AS for $1\"\n\t# fetch all observed ASPATHs involving this IP address\n\tfull_json_data=$(docurl -s \"https://stat.ripe.net/data/bgp-updates/data.json?resource=$1&sourceapp=nitefood-asn\")\n\tfound_prefix=$(jq -r '.data.resource' <<<\"$full_json_data\")\n\tupdates=$(jq '.data.updates[].attrs.path' <<<\"$full_json_data\")\n\n\tGetCAIDARank \"$found_asn\"\n\n\tasnlist=$(jq -r '. as $aspaths | $aspaths[first((range(1;length) | select($aspaths[.] == '\"$found_asn\"')) - 1)] // empty' <<<\"$updates\" | sort | uniq -c | sort -rn)\n\ttot=0\n\tfor line in $asnlist; do\n\t\tcount=$(awk '{print $1}' <<<\"$line\")\n\t\ttot=$(( tot+count ))\n\tdone\n\t[ -z \"$asnlist\" ] && total_upstreams_count=0 || total_upstreams_count=$(wc -l <<<\"$asnlist\")\n\tred_upstreams_count=0\n\tgreen_upstreams_count=0\n\tyellow_upstreams_count=0\n\twhite_upstreams_count=0\n\tdim_upstreams_count=0\n\t[[ \"$caida_asrank\" = \"N/A\" ]] && caida_asrank=99999\n\tif (( caida_asrank < 100 )) || (( total_upstreams_count > 50 )); then\n\t\t# origin AS is in the top 100, therefore less likely to need transits (given its large customer cone),\n\t\t# or the prefix is widely announced (likely also by well-connected IXP RS peers).\n\t\t# Raise the thresholds to infer transit relationship status (need a higher percentage of BGP updates)\n\t\tgreen_probability=85\n\t\tyellow_probability=75\n\t\twhite_probability=65\n\telse\n\t\tgreen_probability=66\n\t\tyellow_probability=33\n\t\twhite_probability=25\n\tfi\n\n\t# create a static list of the largest known transit ASNs.\n\t# The list includes most of the top 35 CAIDA ranked ASNs (https://asrank.caida.org/?page_number=1&page_size=40&sort=rank)\n\t# Note: the list excludes Hurricane Electric (AS6939) because HE is known to largely reannounce most prefixes it receives\n\t# (even from IXP RS/SFI peers who do not subscribe a transit relationship with them)\n\tstatic_transits_array=( 3356 1299 174 6762 2914 6461 6453 3257 3491 9002 1273 5511 4637 12956 7473 1239 3320 701 7018 6830 7922 )\n\n\tlegend=\"\\t${red}██ most likely transit\\t( very large / Tier 1 upstream AS )${default}\"\n\tlegend+=\"\\n\\t${green}██ very likely transit\\t( >= ${green_probability}% BGP updates from this AS )${default}\"\n\tlegend+=\"\\n\\t${yellow}██ likely transit\\t( >= ${yellow_probability}% BGP updates from this AS )${default}\"\n\tlegend+=\"\\n\\t██ potentially transit\\t( >= ${white_probability}% BGP updates from this AS )${default}\"\n\tlegend+=\"\\n\\t${dim}██ unlikely transit\\t(  < ${white_probability}% BGP updates from this AS )${default}\"\n\n\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\techo -e \"\\nLegend:\\n$legend\\n\"\n\t\techo -e \"${bluebg} Target       : ${default} ${blue}$1${default} ${dim}(matching prefix: ${white}$found_prefix${dim})${default}\"\n\t\techo -e \"${bluebg} Origin AS    : ${default} ${red}[AS$found_asn] ${green}$found_asname${default}\"\n\t\techo -e \"${bluebg} CAIDA AS rank: ${default} ${caida_asrank_recap}${default}\\n\"\n\telse\n\t\tfinal_json_output=$(jq '. += [{ \"prefix\": \"'\"$found_prefix\"'\", \"origin_as\": \"'\"$found_asn\"'\", \"origin_as_name\": \"'\"$found_asname\"'\", \"origin_as_rank\": '\"$caida_asrank\"' }]' <<<\"$final_json_output\")\n\t\tfinal_json_output=$(jq '.[0] += {\"upstreams_count\": '\"$total_upstreams_count\"',\"upstreams\":[]}' <<<\"$final_json_output\")\n\tfi\n\n\tfor line in $asnlist; do\n\t\tis_tier1=false\n\t\tcount=$(awk '{print $1}' <<<\"$line\")\n\t\tasn=$(awk '{print $2}' <<<\"$line\")\n\t\t# TODO use bulk Team Cymru query to lookup asnames\n\t\tasname=$(host -t TXT \"AS${asn}.asn.cymru.com\" | grep -v \"NXDOMAIN\" | awk -F'|' 'NR==1{print substr($NF,2,length($NF)-2)}')\n\t\tinteger_probability=$(( count*100/tot ))\n\t\tprobability=$(jq -n \"$count*100/$tot\")\n\t\tif grep -qw \"$asn\" <<<\"${static_transits_array[@]}\" && (( caida_asrank > 35 )); then\n\t\t\t# apply static transit list to this AS only if it's not among the top 35 ASNs (per CAIDA rankings).\n\t\t\t# Larger networks (ranked < 35) are more likely to arrange SFI relationships with other Tier-1 networks,\n\t\t\t# rather than pay for transit\n\t\t\tis_tier1=true\n\t\t\tprobability_color=\"${red}\"\n\t\t\t(( red_upstreams_count++ ))\n\t\telif (( integer_probability >= \"$green_probability\" )); then\n\t\t\tprobability_color=\"${green}\"\n\t\t\t(( green_upstreams_count++ ))\n\t\telif (( integer_probability >= \"$yellow_probability\" )); then\n\t\t\tprobability_color=\"${yellow}\"\n\t\t\t(( yellow_upstreams_count++ ))\n\t\telif (( integer_probability >= \"$white_probability\" )); then\n\t\t\tprobability_color=\"${default}\"\n\t\t\t(( white_upstreams_count++ ))\n\t\telse\n\t\t\tprobability_color=\"${dim}\"\n\t\t\t(( dim_upstreams_count++ ))\n\t\tfi\n\n\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\tfinal_json_output=$(jq '.[0].upstreams += [{\"asn\":\"'\"$asn\"'\", \"asname\":\"'\"$asname\"'\", \"probability\":'\"$(printf \"%.2f\" \"$probability\")\"', \"is_tier1\":'\"$is_tier1\"'}]' <<<\"$final_json_output\")\n\t\telse\n\t\t\tprintf \"${probability_color}██\\tAS%-6s (%6.2f%%) - %s${default}\\n\" \"$asn\" \"$probability\" \"$asname\"\n\t\tfi\n\tdone\n\n\t# count each type of upstreams and try to determine if this prefix is multihomed\n\t# echo \"dbg green: $green_upstreams_count, yellow: $yellow_upstreams_count, white: $white_upstreams_count, dim: $dim_upstreams_count\"\n\tMULTIPLE_UPSTREAMS=false\n\tmultiple_string=\"multiple\"\n\tif (( total_upstreams_count >= 20 )); then\n\t\tMULTIPLE_UPSTREAMS=true\n\t\tmultiple_string=\"several\"\n\telif (( green_upstreams_count >= 2 )) || (( yellow_upstreams_count >= 2 )) || (( white_upstreams_count >= 2 )) || (( red_upstreams_count >= 2 )); then\n\t\tMULTIPLE_UPSTREAMS=true\n\tfi\n\n\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\tif [ \"$MULTIPLE_UPSTREAMS\" = true ]; then\n\t\t\techo -e \"\\n${bluebg} INFO ${default}${blue} This prefix seems to be reannounced by ${underline}$multiple_string ($total_upstreams_count) upstream ASNs${default}${blue}. Possible reasons include:\\n\\t- ${underline}BGP multihoming${default}${blue} (if few upstreams announce this prefix)\\n\\t- ${underline}Tier 1 origin AS${default}${blue} or highly reachable prefix${default}${blue} (if many upstreams announce this prefix)\\n\\t- ${underline}Anycast prefix${default}\\n\"\n\t\tfi\n\telse\n\t\tjson_resultcount=\"1\"\n\t\tfinal_json_output=$(jq '.[0] += {\"multiple_upstreams\": '\"$MULTIPLE_UPSTREAMS\"'}' <<<\"$final_json_output\")\n\tfi\n\n\tif (( total_upstreams_count == 0 )); then\n\t\techo -e \"\\n${lightgreybg} Prefix has not been observed in the DFZ recently ${default}\\n\"\n\tfi\n}\n\nAsnServerListener(){\n\n\tDisableColors\n\n\tBoxHeader \"ASN Lookup Server v$ASN_VERSION on $HOSTNAME\"\n\n\tif [ \"$ASN_DEBUG\" = true ]; then\n\t\tserver_user_uid=$(id -u)\n\t\tserver_user_name=$(id -n -u \"$server_user_uid\")\n\t\techo -e \"\\n- ${yellow}[DBG]${default} Server UID       : ${blue}${server_user_uid} (${server_user_name})${default}\" >&2\n\t\techo -en \"- ${yellow}[DBG]${default} Server BIND_ADDR :\" >&2\n\t\t[[ -z \"$ASN_SRV_BINDADDR\" ]] && echo -en \" ${green}not specified (default v4/v6)${default}\" || echo -en \" $ASN_SRV_BINDADDR\" >&2\n\t\techo -en \"\\n- ${yellow}[DBG]${default} Server BIND_PORT : $ASN_SRV_BINDPORT\" >&2\n\t\t[[ \"$ASN_SRV_BINDPORT\" = \"$DEFAULT_SERVER_BINDPORT\" ]] && echo -en \" ${green}(default)${default}\" >&2\n\t\techo -e \"\\n- ${yellow}[DBG]${default} Ncat options     : '${blue}${userinput}${default}'\\n\" >&2\n\tfi\n\n\tCLOUD_SHELL_MARK=\"${red}❌ NO${default}\"\n\n\t# fetch external IP and ASN to include in the HTML reports\n\tStatusbarMessage \"Detecting host external IP and ASN\"\n\tWhatIsMyIP\n\tif [ \"$HAVE_IPV6\" = true ]; then\n\t\tfound_asn=$(docurl -s \"https://stat.ripe.net/data/whois/data.json?resource=$local_wanip&sourceapp=nitefood-asn\" | jq -r '.data.irr_records[0] | map(select(.key | match (\"origin\"))) | .[].value')\n\t\tWhoisASN \"$found_asn\"\n\t\t[[ -z \"$ASN_SRV_BINDADDR\" ]] && ASN_SRV_BINDADDR=\"$DEFAULT_SERVER_BINDADDR_v6\"\n\telse\n\t\tLookupASNAndRouteFromIP \"$local_wanip\"\n\t\t[[ -z \"$ASN_SRV_BINDADDR\" ]] && ASN_SRV_BINDADDR=\"$DEFAULT_SERVER_BINDADDR_v4\"\n\tfi\n\tif [ -z \"$found_asn\" ]; then\n\t\tfound_asn=\"N/A\"\n\t\tfound_asname=\"(Unknown)\"\n\tfi\n\tserver_country=$(echo \"${found_asname##*,}\" | tr -d ' ')\n\t[[ -z \"$server_country\" ]] && server_country=\"(Unknown)\"\n\n\t# prepare the server URL (for the JS bookmarklet)\n\tif [ \"$ASN_SRV_BINDADDR\" = \"0.0.0.0\" ] || [ \"$ASN_SRV_BINDADDR\" = \"::\" ]; then\n\t\tINTERNAL_ASNSERVER_ADDRESS=\"$local_wanip:$ASN_SRV_BINDPORT\"\n\telse\n\t\tINTERNAL_ASNSERVER_ADDRESS=\"$ASN_SRV_BINDADDR:$ASN_SRV_BINDPORT\"\n\tfi\n\tBOOKMARKLET_URL=\"http://${INTERNAL_ASNSERVER_ADDRESS}/asn_bookmarklet\"\n\t# detect if we're running in Google Cloud Shell environment\n\tif [ \"$GOOGLE_CLOUD_SHELL\" = true ] && [ -n \"$WEB_HOST\" ]; then\n\t\t# on Google Cloud Shell, the $WEB_HOST environment variable contains the external hostname to reach the server\n\t\t# the format is https://<port>-<hostname> (cheers https://stackoverflow.com/a/70255668)\n\t\tINTERNAL_ASNSERVER_ADDRESS=\"${ASN_SRV_BINDPORT}-${WEB_HOST}\"\n\t\tBOOKMARKLET_URL=\"https://${INTERNAL_ASNSERVER_ADDRESS}/asn_bookmarklet\"\n\t\tCLOUD_SHELL_MARK=\"${green}✓ YES${default}\"\n\tfi\n\n\tStatusbarMessage\n\n\tif [ \"$HAVE_IPV6\" = true ]; then\n\t\t[[ \"$IS_HEADLESS\" = true ]] && ipv6_mark=\"YES\" || ipv6_mark=\"${green}✓ YES${default}\"\n\telse\n\t\t[[ \"$IS_HEADLESS\" = true ]] && ipv6_mark=\"NO\" || ipv6_mark=\"${red}❌ NO${default}\"\n\tfi\n\t# properly show [IP]:PORT notation in case of IPv6 binding\n\tif grep -q ':' <<<\"$ASN_SRV_BINDADDR\"; then\n\t\tDISPLAY_ASN_SRV_BINDADDR=\"[${ASN_SRV_BINDADDR}]\"\n\telse\n\t\tDISPLAY_ASN_SRV_BINDADDR=\"${ASN_SRV_BINDADDR}\"\n\tfi\n\t# prepare API tokens status line\n\t[[ \"$json_IQS_TOKEN\" = true ]] && API_TOKENS_STATUS=\"${green}✓ IQS${default}\" || API_TOKENS_STATUS=\"${red}❌ IQS${default}\"\n\t[[ \"$json_IPINFO_TOKEN\" = true ]] && API_TOKENS_STATUS+=\" • ${green}✓ IPINFO${default}\" || API_TOKENS_STATUS+=\" • ${red}❌ IPINFO${default}\"\n\t[[ \"$json_CLOUDFLARE_TOKEN\" = true ]] && API_TOKENS_STATUS+=\" • ${green}✓ CLOUDFLARE${default}\" || API_TOKENS_STATUS+=\" • ${red}❌ CLOUDFLARE${default}\"\n\techo -e \"\\n- Server ext. IP  : ${blue}${local_wanip}${default}\" \\\n\t\t\t\"\\n- Server Country  : ${blue}${server_country}${default}\" \\\n\t\t\t\"\\n- Server ASN      : ${red}[AS${found_asn}]${default} ${green}$found_asname${default}\" \\\n\t\t\t\"\\n- Server has IPv6 : ${ipv6_mark}\" \\\n\t\t\t\"\\n- Running on GCP  : ${CLOUD_SHELL_MARK}\" \\\n\t\t\t\"\\n- API Tokens      : ${API_TOKENS_STATUS}\" \\\n\t\t\t\"\\n- Bookmarklet URL : ${BOOKMARKLET_URL}\" \\\n\t\t\t\"\\n\\n[$(date +\"%F %T\")] ${bluebg}  INFO   ${default} ASN Lookup Server listening on ${white}${DISPLAY_ASN_SRV_BINDADDR}:${ASN_SRV_BINDPORT}${default}\"\n\n\tserver_country=\"$(echo -e \"$server_country\" | tr '[:upper:]' '[:lower:]')\"\n\n\ttrap '\n\t\t[[ \"$IS_HEADLESS\" = false ]] && echo -en \"\\r\" >&2\n\t\techo -e \"[$(date +\"%F %T\")] ${bluebg}  INFO   ${default} ASN Lookup Server requested shutdown, terminating...\" >&2\n\t\texit 0\n\t\t' INT TERM\n\n\t#* Assemble the ncat listener command. Also pass on MONOCHROME/DEBUG preferences\n\t#* to the listener child (which will output to stderr on server's console)\n\t#* and print information about client requests (1 child spawned per client connected)\n\tread -r -d '' ncat_cmd <<- END_OF_NCAT_CMD\n\tncat -k -l $ASN_SRV_BINDADDR $ASN_SRV_BINDPORT $userinput --sh-exec \"\n\t\t\t\texport NCAT_REMOTE_ADDR; \\\n\t\t\t\tfound_asn=\\\"$found_asn\\\" \\\n\t\t\t\tfound_asname=\\\"$found_asname\\\" \\\n\t\t\t \tserver_country=\\\"$server_country\\\" \\\n\t\t\t\tINTERNAL_CONNHANDLER_CHILD=false \\\n\t\t\t \tINTERNAL_ASNSERVER_CONNHANDLER=true \\\n\t\t\t\tINTERNAL_ASNSERVER_ADDRESS=\"$INTERNAL_ASNSERVER_ADDRESS\" \\\n\t\t\t \tMONOCHROME_MODE=\\\"$MONOCHROME_MODE\\\" \\\n\t\t\t \tASN_DEBUG=\\\"$ASN_DEBUG\\\" \\\n\t\t\t \t\\\"$0\\\"\n\t\t \t\"\n\tEND_OF_NCAT_CMD\n\n\t#! Start the ncat listener and serve each client request\n\t#! by respawning the script with $INTERNAL_ASNSERVER_CONNHANDLER => true\n\t#! for every incoming connection\n\teval \"$ncat_cmd\"\n\n\tPrintErrorAndExit \"ERROR: The ncat server crashed or couldn't start. Try passing the '-v' option to see precisely what is being passed to it.\"\n}\n\nCtrl_C() {\n\tif [ \"$NO_ERROR_ON_INTERRUPT\" = true ]; then\n\t\tStatusbarMessage\n\t\ttput sgr0\n\t\tShowMenu\n\telse\n\t\tPrintErrorAndExit \"Interrupted\"\n\tfi\n}\n\nBoxHeader() { # cheers https://unix.stackexchange.com/a/70616\n\n\t# no output if in json mode\n\t[[ \"$JSON_OUTPUT\" = true ]] && return\n\tlocal message=\"$*\"\n\n\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\techo \"BOXHEADER $message\" # the BOXHEADER tag will be transformed by the ASN server into an html <table> element\n\telse\n\t\tif [ \"$IS_HEADLESS\" = true ]; then\n\t\t\techo \"// $message //\"\n\t\telse\n\t\t\techo -e \"\\n${white}╭─${message//?/─}─╮\\n│ ${yellow}${message}${white} │\\n╰─${message//?/─}─╯\"\n\t\t\ttput sgr 0\n\t\tfi\n\tfi\n}\n\nStatusbarMessage() { # invoke without parameters to delete the status bar message\n\t# suppress status bar displaying for headless, json or debug runs\n\tif [ \"$IS_HEADLESS\" = true ] || [ \"$JSON_OUTPUT\" = true ] || [ \"$ASN_DEBUG\" = true ]; then\n\t\treturn\n\tfi\n\n\tif [ -n \"$statusbar_message\" ]; then\n\t\t# delete previous status bar message\n\t\tblank_line=$(printf \"%.0s \" $(seq \"$terminal_width\"))\n\t\tprintf \"\\r%s\\r\" \"$blank_line\" >&2\n\tfi\n\tif [ -n \"$1\" ]; then\n\t\tstatusbar_message=\"$1\"\n\t\tmax_msg_size=$((terminal_width-23))\n\t\tif [ \"${#statusbar_message}\" -gt \"${max_msg_size}\" ]; then\n\t\t\tstatusbar_message=\"${lightgreybg}${statusbar_message:0:$max_msg_size}${lightgreybg}...\"\n\t\telse\n\t\t\tstatusbar_message=\"${lightgreybg}${statusbar_message}\"\n\t\tfi\n\t\tstatusbar_message+=\"${lightgreybg} (press CTRL-C to cancel)...${default}\"\n\t\techo -en \"$statusbar_message\" >&2\n\tfi\n}\n\nWhatIsMyIP() {\n\t# only lookup local WAN IP once\n\t[[ -n \"$local_wanip\" ]] && return\n\t# retrieve local WAN IP (v6 takes precedence) from ifconfig.co\n\tlocal_wanip=$(docurl -s \"https://ifconfig.co\")\n\t# handle ifconfig.co serving a captcha-type redirect page (e.g. when coming from some AWS networks)\n\tgrep -qE '^<!DOCTYPE html>' <<<\"$local_wanip\" && local_wanip=$(docurl -s \"https://api64.ipify.org\")\n\t# check if we default to an IPv6 internet connection\n\tif echo \"$local_wanip\" | grep -q ':'; then\n\t\tHAVE_IPV6=true\n\tfi\n}\n\nDisableColors() {\n\t# avoid colors for headless server runs (e.g. systemd logs/status),\n\t# for listener runs, json output and monochrome mode\n\tif [ \"$IS_HEADLESS\" = true ] || [ \"$JSON_OUTPUT\" = true ]; then\n\t\t# disable all colors for headless/json\n\t\tgreen=\"\"\n\t\tmagenta=\"\"\n\t\tyellow=\"\"\n\t\twhite=\"\"\n\t\tblue=\"\"\n\t\tred=\"\"\n\t\tblack=\"\"\n\t\tlightyellow=\"\"\n\t\tlightred=\"\"\n\t\tlightblue=\"\"\n\t\tlightgreybg=\"\"\n\t\tbluebg=\"\"\n\t\tredbg=\"\"\n\t\tgreenbg=\"\"\n\t\tyellowbg=\"\"\n\t\tdim=\"\"\n\t\tdefault=\"\"\n\telif [ \"$MONOCHROME_MODE\" = true ]; then\n\t\t# set all colors to white, leave black/white/dim/default intact\n\t\tgreen=\"$white\"\n\t\tmagenta=\"$white\"\n\t\tyellow=\"$white\"\n\t\tblue=\"$white\"\n\t\tred=\"$white\"\n\t\tlightyellow=\"$white\"\n\t\tlightred=\"$white\"\n\t\tlightblue=\"$white\"\n\t\tbluebg=\"$lightgreybg\"\n\t\tredbg=\"$lightgreybg\"\n\t\tgreenbg=\"$lightgreybg\"\n\t\tyellowbg=\"$lightgreybg\"\n\tfi\n}\n\nCoreutilsFixup() {\n\t# check for GNU coreutils alternatives (improve command predictability on FreeBSD/MacOS systems)\n\tif [ -x \"$(command -v gdate)\" ]; then\n\t\tdate() { gdate \"$@\"; }\n\t\texport -f date\n\tfi\n\tif [ -x \"$(command -v gsed)\" ]; then\n\t\tsed() { gsed \"$@\"; }\n\t\texport -f sed\n\tfi\n\tif [ -x \"$(command -v gawk)\" ]; then\n\t\tawk() { gawk \"$@\"; }\n\t\texport -f awk\n\tfi\n\tif [ -x \"$(command -v gbase64)\" ]; then\n\t\tbase64() { gbase64 \"$@\"; }\n\t\texport -f base64\n\tfi\n\tif [ -x \"$(command -v gwc)\" ]; then\n\t\twc() { gwc \"$@\"; }\n\t\texport -f wc\n\tfi\n\tif [ \"$IS_ASN_CHILD\" = true ] || [ \"$IS_ASN_CONNHANDLER\" = true ]; then\n\t\t# suppress the tput command during headless runs\n\t\ttput() { :; }\n\t\texport -f tput\n\tfi\n}\n\nIpcalcVersionCheck() {\n\t# check for ipcalc version to accommodate both v1.0.0+ (CentOS/RHEL/Rocky 9) and v0.41+ (Debian derivatives)\n\tIPCALC_FLAG=\"\"\n\tif [ \"$HAVE_IPCALC\" = true ]; then\n\t\tipcalc_version=$(ipcalc -v | sed 's/ipcalc //')\n\t\tipcalc_major=$(echo \"$ipcalc_version\" | cut -d '.' -f 1)\n\t\tcase \"${ipcalc_major}\" in\n\t\t\t\"0\")\n\t\t\t\tipcalc_minor=$(echo \"$ipcalc_version\" | cut -d '.' -f 2)\n\t\t\t\tif [ \"$ipcalc_minor\" -ge 5 ]; then\n\t\t\t\t\tIPCALC_FLAG=\"-r\"\n\t\t\t\telse\n\t\t\t\t\tHAVE_IPCALC=false\n\t\t\t\t\tmissing_tools+=\"\\n - ipcalc\"\n\t\t\t\t\tdisabled_features+=\"\\n - CIDR deaggregation (due to incompatible ipcalc version - v0.5+ for Debian-based or v1.0.0+ for RHEL-based required, but you have v$ipcalc_version)\"\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\"1\")\n\t\t\t\tIPCALC_FLAG=\"-d\"\n\t\t\t\t;;\n\t\tesac\n\tfi\n}\n\nIpcalcDeaggregate() {\n\tipcalc_parm=$(tr -d ' ' <<<\"$1\")\n\tif grep -q \"/\" <<<\"$1\"; then\n\t\t# consider input to be already a CIDR block, return it unchanged\n\t\techo \"$1\"\n\telse\n\t\tipcalc ${IPCALC_FLAG} \"$ipcalc_parm\" 2>/dev/null | grep -iv \"deaggregate\" | awk '{print $NF}' | tail -n1\n\tfi\n}\n\nCheckPrerequisites() {\n\tsaveIFS=\"$IFS\"\n\tIFS=' '\n\tprerequisite_tools=\"jq whois host curl\" # mandatory tools\n\toptional_tools=\"nmap mtr ipcalc grepcidr ncat aha\"\t# optional tools\n\tmissing_tools=\"\"\n\tdisabled_features=\"\"\n\tHARD_FAIL=false\n\n\tHAVE_IPCALC=true\n\tHAVE_NMAP=true\n\tIXP_DETECTION=true\n\tUNABLE_TO_SERVE=false\n\n\t# BASH version check\n\tbash_major=$(echo \"${BASH_VERSION}\" | cut -d '.' -f 1)\n\tbash_minor=$(echo \"${BASH_VERSION}\" | cut -d '.' -f 2)\n\tbash_version_too_low=false\n\tif [ \"$bash_major\" -lt 4 ]; then\n\t\tbash_version_too_low=true\n\telif [ \"$bash_major\" -eq 4 ] && [ \"$bash_minor\" -lt 2 ]; then\n\t\tbash_version_too_low=true\n\tfi\n\t[[ \"$bash_version_too_low\" = true ]] && PrintErrorAndExit \"Error: BASH version must be >= 4.2 (you are running v${BASH_VERSION})\"\n\n\t# Mandatory tools checking (hard fail if not found)\n\tfor tool in $prerequisite_tools; do\n\t\tif [ -z \"$(command -v \"$tool\")\" ]; then\n\t\t\tmissing_tools+=\"\\n - $tool\"\n\t\t\tHARD_FAIL=true\n\t\tfi\n\tdone\n\n\t# Optional tools checking (no hard fail if not found, but some features disabled)\n\tfor tool in $optional_tools; do\n\t\tif [ -z \"$(command -v \"$tool\")\" ]; then\n\t\t\tmissing_tools+=\"\\n - $tool\"\n\t\t\tcase \"$tool\" in\n\t\t\t\t\"mtr\")\n\t\t\t\t\tdisabled_feat=\"AS path tracing\"\n\t\t\t\t\tMTR_TRACING=false\n\t\t\t\t\t;;\n\t\t\t\t\"nmap\")\n\t\t\t\t\tdisabled_feat=\"Recon mode (Shodan scanning)\"\n\t\t\t\t\tHAVE_NMAP=false\n\t\t\t\t\t;;\n\t\t\t\t\"ipcalc\")\n\t\t\t\t\tdisabled_feat=\"CIDR deaggregation\"\n\t\t\t\t\tHAVE_IPCALC=false\n\t\t\t\t\t;;\n\t\t\t\t\"grepcidr\")\n\t\t\t\t\tdisabled_feat=\"IXP prefix detection\"\n\t\t\t\t\tIXP_DETECTION=false\n\t\t\t\t\t;;\n\t\t\t\t\"ncat\"|\"aha\")\n\t\t\t\t\tdisabled_feat=\"ASN Lookup Server\"\n\t\t\t\t\tUNABLE_TO_SERVE=true\n\t\t\t\t\t;;\n\t\t\tesac\n\n\t\t\tdisabled_features+=\"\\n - ${disabled_feat}\"\n\t\tfi\n\tdone\n\n\tIpcalcVersionCheck\n\n\tif [ -n \"$missing_tools\" ]; then\n\t\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\tBoxHeader \"! WARNING !\"\n\t\t\techo -e \"\\nThe following tools were not found on this system:\" \\\n\t\t\t\t\t\"${red} ${missing_tools}${default}\" >&2\n\n\t\t\tif [ -n \"$disabled_features\" ]; then\n\t\t\t\techo -e \"\\nThe following features will be disabled:\" \\\n\t\t\t\t\t\t\"${yellow}${disabled_features}${default}\" >&2\n\t\t\tfi\n\n\t\t\techo -e \"\\nPlease install the necessary prerequisite packages\\nfor your system by following these instructions:\" \\\n\t\t\t\t\t\"\\n\\n>> ${blue}https://github.com/nitefood/asn#prerequisite-packages${default} <<\\n\" >&2\n\n\t\t\t[[ \"$HARD_FAIL\" = true ]] && PrintErrorAndExit \"Can not continue without (at least) the following tools: ${prerequisite_tools// /, }\"\n\n\t\t\tread -srp \"${lightgreybg}Press ENTER to continue...${default}\" >&2\n\t\telse\n\t\t\t[[ \"$HARD_FAIL\" = true ]] && PrintErrorAndExit \"Can not continue without (at least) the following tools: ${prerequisite_tools// /, }\"\n\t\tfi\n\tfi\n\n\tIQS_TOKEN=\"\"\t\t; json_IQS_TOKEN=\"false\"\n\tIPINFO_TOKEN=\"\"\t\t; json_IPINFO_TOKEN=\"false\"\n\tCLOUDFLARE_TOKEN=\"\"\t; json_CLOUDFLARE_TOKEN=\"false\"\n\n\tIFS=$'\\n'\n\t# Read tokens token from possible config files on disk\n\tfor asn_config_file in $(tr ':' '\\n' <<<\"$IQS_TOKEN_FILES\"); do\n\t\tif [ -r \"$asn_config_file\" ]; then\n\t\t\tIQS_TOKEN=$(tr -d ' \\n\\r\\t' < \"$asn_config_file\")\n\t\t\tjson_IQS_TOKEN=\"true\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\tfor asn_config_file in $(tr ':' '\\n' <<<\"$IPINFO_TOKEN_FILES\"); do\n\t\tif [ -r \"$asn_config_file\" ]; then\n\t\t\tIPINFO_TOKEN=$(tr -d ' \\n\\r\\t' < \"$asn_config_file\")\n\t\t\tjson_IPINFO_TOKEN=\"true\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\tfor asn_config_file in $(tr ':' '\\n' <<<\"$CLOUDFLARE_TOKEN_FILES\"); do\n\t\tif [ -r \"$asn_config_file\" ]; then\n\t\t\tCLOUDFLARE_TOKEN=$(tr -d ' \\n\\r\\t' < \"$asn_config_file\")\n\t\t\tjson_CLOUDFLARE_TOKEN=\"true\"\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\tif \t[ -z \"$IQS_TOKEN\" ] || [ -z \"$IPINFO_TOKEN\" ] || [ -z \"$CLOUDFLARE_TOKEN\" ]; then\n\t\t\t# warn the user about the absence of external API token(s)\n\t\t\tif [ \"$IS_HEADLESS\" = true ]; then\n\t\t\t\tline=\"------------------------------------------------------------\"\n\t\t\t\techo -e \"\\n${line}\\nWARNING: At least one external (free) API token is missing.\" \\\n\t\t\t\t\t\"\\nCheck https://github.com/nitefood/asn#api-tokens for\\ninstructions on how to enable them.\" \\\n\t\t\t\t\t\"\\n${line}\" >&2\n\t\t\telse\n\t\t\t\tline=\"────────────────────────────────────────────────────\"\n\t\t\t\techo -e \"\\n${dim}${yellow}${line}\" \\\n\t\t\t\t\t\"\\nWarning: ${dim}${yellow}At least one external API token is missing.\" \\\n\t\t\t\t\t\"\\nTo enable full script functionalities, please visit\" \\\n\t\t\t\t\t\"\\n${blue}https://github.com/nitefood/asn#api-tokens\" >&2\n\t\t\t\techo -e \"${yellow}${line}${default}\" >&2\n\t\t\tfi\n\t\tfi\n\t\tif [ \"$ASN_DEBUG\" = true ]; then\n\t\t\techo \"\"\n\t\t\tfor token in \"IQS_TOKEN\" \"IPINFO_TOKEN\" \"CLOUDFLARE_TOKEN\"; do\n\t\t\t\tif [ -z \"${!token}\" ]; then\n\t\t\t\t\tDebugPrint \"${dim}${white}$token: ${red}❌ NOT FOUND${white}\"\n\t\t\t\telse\n\t\t\t\t\tDebugPrint \"${dim}${white}$token: ${green}✓ OK${white}\"\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tCoreutilsFixup\n\n\tIFS=\"$saveIFS\"\n}\n\nDebugPrint(){\n\t# Debug print helper function. will display debug string in terminal mode, or full client debug info in headless mode. Will append output to $ASN_LOGFILE logfile\n\tif [ \"$ASN_DEBUG\" = true ]; then\n\t\t# strip CRLFs\n\t\tdbgstring=$(echo -e \"$1\" | tr -d '\\r\\n')\n\t\tif [ \"$IS_HEADLESS\" = false ]; then\n\t\t\t# command line tool mode\n\t\t\techo -e \"${default}[$(date +'%F %T')] ${lightgreybg}  DEBUG  ${default} $dbgstring\" >&2\n\t\t\techo -e \"\\n────────────────────────────────────────────────────────────────────────────────────────────────────────\" \\\n\t\t\t\t\t\"\\n>>>> ${default}[$(date +'%F %T')] ${lightgreybg}  DEBUG  ${default} $dbgstring\" >> \"$ASN_LOGFILE\"\n\t\telse\n\t\t\t# server mode\n\t\t\tif [ -z \"$host\" ]; then\n\t\t\t\ttarget='N/A'\n\t\t\telse\n\t\t\t\ttarget=\"$host\"\n\t\t\tfi\n\t\t\tif [ -z \"$reqid\" ]; then\n\t\t\t\trequestid='N/A'\n\t\t\telse\n\t\t\t\trequestid=\"$reqid\"\n\t\t\tfi\n\t\t\techo -e \"${default}[$(date +'%F %T')] ${lightgreybg}  DEBUG  ${default} $dbgstring [CLIENT: ${yellow}$NCAT_REMOTE_ADDR${default}, \" \\\n\t\t\t\t\t\"TARGET: ${magenta}$target${default}, REQID: ${blue}$requestid${default}]\" >&2 \\\n\t\t\techo -e \"${default}[$(date +'%F %T')] ${lightgreybg}  DEBUG  ${default} $dbgstring [CLIENT: ${yellow}$NCAT_REMOTE_ADDR${default}, \" \\\n\t\t\t\t\t\"TARGET: ${magenta}$target${default}, REQID: ${blue}$requestid${default}]\" >> \"$ASN_LOGFILE\"\n\t\tfi\n\tfi\n}\n\nStripAnsi() {\n\t# portable ANSI colors strip helper fn (for termbin sharing) - cheers https://unix.stackexchange.com/a/140255\n\t# shellcheck disable=SC2001\n\techo -e \"$1\" | sed \"s,$(printf '\\033')\\\\[[0-9;]*[a-zA-Z],,g\"\n}\n\nHandleNcatClientConnection() {\n\n\t# ╭─────────────────────────────────────╮\n\t# │ MAIN NCAT CLIENT CONNECTION HANDLER │\n\t# ╰─────────────────────────────────────╯\n\n\tDisableColors\n\n\t# HTTP response headers\n\thttp_ok='HTTP/1.0 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n'\n\thttp_ok_json='HTTP/1.0 200 OK\\r\\nContent-Type: application/json\\r\\n'\n\thttp_ko='HTTP/1.0 400\\r\\nContent-Type: text/html\\r\\n\\r\\n<html><body><h1>400 Bad Request</h1>\\nYour request could not be processed.</body></html>'\n\thttp_ko_json='HTTP/1.0 400\\r\\nContent-Type: application/json\\r\\n'\n\n\t# Javascript bookmarklet\n\tjs_bookmarklet='javascript:(function(){var asnserver=\"'\"${INTERNAL_ASNSERVER_ADDRESS}\"'\",target=window.location.hostname,'\n\tjs_bookmarklet+='width=screen.width-screen.width/7,height=screen.height-screen.height/4,left=window.innerWidth/2-width/2,top=window.innerHeight/2-height/2;'\n\tjs_bookmarklet+='window.open(\"http://\"+asnserver+\"/asn_lookup&\"+target,\"newWindow\",\"width=\"+width+\",height=\"+height+\",top=\"+top+\",left=\"+left)})();'\n\n\t# HTML bookmarklet page\n\tread -r -d '' html_bookmarklet_page <<- END_OF_BOOKMARKLET_HTML\n\t<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"application/xml+xhtml; charset=UTF-8\"/>\n\t\t<title>[ASN] Server configuration (client-side)</title>\n\t\t<style>\n\t\t\t@import url(\"https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap\");\n\t\t\thtml * {\n\t\t\t\tfont-family: \"Roboto Mono\", monospace;\n\t\t\t\tfont-size: 1em;\n\t\t\t\tcolor: $htmlwhite;\n\t\t\t\tbackground-color: $htmlblack;\n\t\t\t\tborder-radius: 6px;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t<pre>\n\t\t<br /><br />\n\t\t<hr>\n\t\t<div style=\"text-align: center;\">\n\t\t\t<span style=\"color:$htmlgreen; font-size: 2em\">- ASN Server // Browser Integration -</span>\n\n\t\t\t<span>1) Drag and drop the <span style=\"color:$htmlyellow;\">yellow</span> link below to your bookmarks toolbar:</span>\n\n\t\t\t<span style=\"font-size: 2.5em;\"><a style=\"color:$htmlyellow;\" href='$js_bookmarklet' title=\"ASN Lookup\">ASN LOOKUP</a></span>\n\n\t\t\t<span>2) Close this page and click the new bookmark while viewing any website.\n\t\t\tA lookup and trace for that host should start in a pop-up window.</span>\n\t\t<br />\n\t\t<hr>\n\t\t<span style='color: darkgray; font-style: italic; font-size: 0.8em;'><a href='https://github.com/nitefood/asn' target='_blank'>ASN Lookup Server</a> v${ASN_VERSION} running on $HOSTNAME\n\t\t</span>\n\t\t</div>\n\t</pre>\n\t</body>\n\t</html>\n\tEND_OF_BOOKMARKLET_HTML\n\n\t# HTML opening tags\n\t# shellcheck disable=SC2016\n\thtml_header='\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\t<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\t\t<head>\n\t\t\t<meta http-equiv=\"Content-Type\" content=\"application/xml+xhtml; charset=UTF-8\"/>\n\t\t\t<title>[ASN] Lookup</title>\n\t\t\t<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js\"></script>\n\t\t\t<script>\n\t\t\t\tfunction termbinshare(){\n\t\t\t\t\t$(\"#termbinShareButton\").attr(\"disabled\",\"disabled\");\n\t\t\t\t\tvar oldbuttontext=$(\"#termbinShareButton\").text();\n\t\t\t\t\t$(\"#termbinShareButton\").text(\"Sharing...\");\n\t\t\t\t\tvar tracedata=$(\"#tracedata\").text();\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl: \"/termbin_share&\" + tracedata,\n\t\t\t\t\t\ttype: \"GET\",\n\t\t\t\t\t\tsuccess: function (termbinUrl) {\n\t\t\t\t\t\t\ttermbinUrl = termbinUrl.replace(/(\\\\r\\\\n|\\\\n|\\\\r)/gm,\"\");\n\t\t\t\t\t\t\tvar outputcontainer = document.getElementById(\"share-output-container\");\n\t\t\t\t\t\t\tif (termbinUrl === \"\"){\n\t\t\t\t\t\t\t\toutputcontainer.innerHTML = \"<span style=\\\"color: '\"$htmlred\"'; font-size: 0.9em;\\\">Sharing failed, check server console log</span>\";\n\t\t\t\t\t\t\t\t// show the \"sharing output\" element\n\t\t\t\t\t\t\t\toutputcontainer.classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t// hide it after 3s\n\t\t\t\t\t\t\t\tsetTimeout(function(){ outputcontainer.classList.add(\"hidden\"); }, 3000);\n\t\t\t\t\t\t\t\t$(\"#termbinShareButton\").text(oldbuttontext);\n\t\t\t\t\t\t\t\t$(\"#termbinShareButton\").removeAttr(\"disabled\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$(\"#share-container\").empty();\n\t\t\t\t\t\t\t\t$(\"#share-container\").html(\"<textarea wrap=\\\"off\\\" rows=1 cols=\"+termbinUrl.length+\" readonly id=\\\"termbinoutput\\\">\"+termbinUrl+\"</textarea>\");\n\t\t\t\t\t\t\t\tdocument.getElementById(\"termbinoutput\").select();\n\t\t\t\t\t\t\t\tdocument.execCommand(\"copy\");\n\t\t\t\t\t\t\t\t$(\"#share-container\").html(\"<a href=\\\"\"+termbinUrl+\"\\\" target=\\\"_blank\\\" style=\\\"color: '$htmlblue';\\\">\"+termbinUrl+\"</a>\");\n\t\t\t\t\t\t\t\toutputcontainer.innerHTML = \"<span style=\\\"color: '\"$htmlgreen\"'; font-size: 1em;\\\">✓ Link copied to clipboard</span>\";\n\t\t\t\t\t\t\t\t// show the \"sharing output\" element\n\t\t\t\t\t\t\t\toutputcontainer.classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t// hide it after 3s\n\t\t\t\t\t\t\t\tsetTimeout(function(){ outputcontainer.classList.add(\"hidden\"); }, 3000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Fade out loader when window is loaded\n\t\t\t\t$(window).load(function() { $(\".loader\").fadeOut(\"fast\");; });\n\n\t\t\t</script>\n\t\t\t<style>\n\t\t\t\t@import url(\"https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap\");\n\t\t\t\thtml * {\n\t\t\t\t\tfont-family: \"Roboto Mono\", monospace;\n\t\t\t\t\tfont-size: 1em;\n\t\t\t\t\tcolor:'$htmlwhite';\n\t\t\t\t\tbackground-color: '$htmlblack'; /* background-color: black; */\n\t\t\t\t\tborder-radius: 6px;\n\t\t\t\t}\n\t\t\t\ttable {\n\t\t\t\t\tborder: 1px solid '$htmlyellow';\n\t\t\t\t\tmargin-left: auto;\n\t\t\t\t\tmargin-right: auto;\n\t\t\t\t}\n\t\t\t\tth { text-align: center; background-color: '$htmlblue'; color: black; }\n\t\t\t\ttd { text-align: center; color: '$htmlwhite'; width: 20%; }\n\t\t\t\t.center { margin-left: auto; margin-right: auto; }\n\t\t\t\t.textoutput {\n\t\t\t\t\topacity:1;\n\t\t\t\t\ttransition:opacity 200ms;\n\t\t\t\t\tfont-size: 0.8em;\n\t\t\t\t}\n\t\t\t\t.hidden {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t\t/* cheers https://css-tricks.com/snippets/css/make-pre-text-wrap/ */\n\t\t\t\tpre {\n\t\t\t\t\twhite-space: pre-wrap;       /* css-3 */\n\t\t\t\t\twhite-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n\t\t\t\t\twhite-space: -pre-wrap;      /* Opera 4-6 */\n\t\t\t\t\twhite-space: -o-pre-wrap;    /* Opera 7 */\n\t\t\t\t\tword-wrap: break-word;       /* Internet Explorer 5.5+ */\n\t\t\t\t}\n\t\t\t\tbutton.sharebutton {\n\t\t\t\t\tbackground-color:'$htmlgreen';\n\t\t\t\t\tborder: solid 2px '$htmlblack';\n\t\t\t\t\tborder-radius: 8px;\n\t\t\t\t\tdisplay:inline-block;\n\t\t\t\t\tcursor:pointer;\n\t\t\t\t\tcolor: black;\n\t\t\t\t\t//padding:13px 32px;\n\t\t\t\t\ttext-decoration:none;\n\t\t\t\t}\n\t\t\t\t.sharebutton:hover {\n\t\t\t\t\tborder: solid 2px '$htmlyellow';\n\t\t\t\t}\n\t\t\t\t.sharebutton:active {\n\t\t\t\t\tposition:relative;\n\t\t\t\t\ttop:1px;\n\t\t\t\t}\n\n\t\t\t\t/* ------------------------------------------------------------------------*/\n\t\t\t\t/* CSS For modal popup (whois results in server mode for hostname targets) */\n\t\t\t\t/* ------------------------------------------------------------------------*/\n\t\t\t\t/* The Modal (background) */\n\t\t\t\t.modal {\n\t\t\t\t\tdisplay: none; /* Hidden by default */\n\t\t\t\t\tposition: fixed; /* Stay in place */\n\t\t\t\t\tz-index: 1; /* Sit on top */\n\t\t\t\t\tleft: 0;\n\t\t\t\t\ttop: 0;\n\t\t\t\t\twidth: 100%; /* Full width */\n\t\t\t\t\theight: 100%; /* Full height */\n\t\t\t\t\toverflow: auto; /* Enable scroll if needed */\n\t\t\t\t\tbackground-color: rgb(0,0,0); /* Fallback color */\n\t\t\t\t\tbackground-color: rgba(0,0,0,0.4); /* Black w/ opacity */\n\t\t\t\t}\n\n\t\t\t\t/* Modal Content/Box */\n\t\t\t\t.modal-content {\n\t\t\t\t\tbackground-color: '$htmlwhite';\n\t\t\t\t\tmargin: 15% auto; /* 15% from the top and centered */\n\t\t\t\t\tfont-size: 85%;\n\t\t\t\t\tborder: 1px solid '$htmlwhite';\n\t\t\t\t\twidth: 80%; /* Could be more or less, depending on screen size */\n\t\t\t\t}\n\t\t\t\t/* The Close Button */\n\t\t\t\t.close {\n\t\t\t\t\tcolor: #aaa;\n\t\t\t\t\tfloat: right;\n\t\t\t\t\tfont-size: 28px;\n\t\t\t\t\tfont-weight: bold;\n\t\t\t\t}\n\n\t\t\t\t.close:hover,\n\t\t\t\t\t.close:focus {\n\t\t\t\t\t\tcolor: black;\n\t\t\t\t\t\ttext-decoration: none;\n\t\t\t\t\t\tcursor: pointer;\n\t\t\t\t}\n\t\t\t\t.hidden_underline {\n\t\t\t\t\t/*text-decoration: none;*/\n\t\t\t\t\ttext-decoration: underline solid transparent;\n\t\t\t\t\ttransition: text-decoration 0.2s ease-out;\n\t\t\t\t}\n\t\t\t\t.hidden_underline:hover {\n\t\t\t\t\ttext-decoration: underline solid Currentcolor;\n\t\t\t\t}\n\t\t\t\t/* -------------------------------------------------------------------------------*/\n\t\t\t\t/* CSS Loader - cheers https://www.cssscript.com/demo/beautiful-creative-loaders/ */\n\t\t\t\t/* modified values to stick to bottom even on scroll:\n\t\t\t\t\tposition: fixed;\n\t\t\t\t\tbottom: 0;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t*/\n\t\t\t\t.loader {\n\t\t\t\t\twidth: 12px;\n\t\t\t\t\theight: 12px;\n\t\t\t\t\tborder-radius: 50%;\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\tmargin:15px auto;\n\t\t\t\t\tposition: fixed;\n\t\t\t\t\tbottom: 0;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\tcolor: '$htmlyellow';\n\t\t\t\t\tbox-sizing: border-box;\n\t\t\t\t\tanimation: animloader 1s linear infinite alternate;\n\t\t\t\t}\n\t\t\t\t@keyframes animloader {\n\t\t\t\t\t0% {\n\t\t\t\t\t\tbox-shadow: -38px -12px ,  -14px 0,  14px 0, 38px 0;\n\t\t\t\t\t}\n\t\t\t\t\t33% {\n\t\t\t\t\t\tbox-shadow: -38px 0px, -14px -12px,  14px 0, 38px 0;\n\t\t\t\t\t}\n\t\t\t\t\t66% {\n\t\t\t\t\t\tbox-shadow: -38px 0px , -14px 0, 14px -12px, 38px 0;\n\t\t\t\t\t}\n\t\t\t\t\t100% {\n\t\t\t\t\t\tbox-shadow: -38px 0 , -14px 0, 14px 0 , 38px -12px;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* -------------------------------------------------------------------------------*/\n\t\t\t</style>\n\t\t</head>\n\t\t<body>\n\t\t\t<span class=\"loader\"></span>\n\t\t\t<pre>\n\t'\n\n\t# HTML closing tags\n\thtml_footer='\n\t\t</body>\n\t\t<script>window.scrollTo(0,document.body.scrollHeight);</script>\n\t</html>\n\t'\n\n\tCoreutilsFixup\n\n\t# a client just connected\n\techo -e \"[$(date +'%F %T')] ${bluebg}  INFO   ${default} Incoming connection by client ${yellow}$NCAT_REMOTE_ADDR${default}\" >&2\n\n\t# read input from client (URL being accessed through the client browser)\n\tread -r line\n\tDebugPrint \"RECEIVED new client request: '$line'\"\n\n\t# handle 'asn_bookmarklet' command. This will show a web page for easy dragging&dropping of the bookmarklet to the favorites toolbar\n\tif (echo -e \"$line\" | grep -Eq \"^GET /asn_bookmarklet[?& ]\"); then\n\t\tDebugPrint \"SERVING bookmarklet page to client\"\n\t\techo -e \"${http_ok}${html_bookmarklet_page}\"\n\n\t# handle 'termbin_share' command. This will decode the input and send it to termbin, returning a html link to the client\n\telif (echo -e \"$line\" | grep -Eq \"^GET /termbin_share&\"); then\n\t\t# send HTTP 200 OK header to client\n\t\techo -e \"${http_ok}\"\n\t\t# decode input data\n\t\tinput_data=\"$(echo -e \"$line\" | cut -d '&' -f 2- | cut -d ' ' -f 1 | base64 -d | gunzip)\"\n\t\ttermbin_url=\"\"\n\t\tif [ -n \"$input_data\" ]; then\n\t\t\t# share on termbin.com and output the url to the client\n\t\t\ttermbin_url=\"$(echo -e \"$input_data\" | timeout 10 ncat termbin.com 9999 | tr -d '\\r\\n\\0')\" # sanitize trailing characters in termbin output link\n\t\tfi\n\t\t# analyze the sharing attempt result\n\t\tif [ -n \"$termbin_url\" ]; then\n\t\t\t# sharing successful, output the link\n\t\t\techo -e \"${termbin_url}\\n\"\n\t\t\t# log the successful sharing attempt\n\t\t\techo -e \"[$(date +'%F %T')] ${greenbg} SHAREOK ${default} Successfully shared termbin link ${blue}${termbin_url}${default} with client ${yellow}$NCAT_REMOTE_ADDR${default}\" >&2\n\t\t\texit 0\n\t\telif [ -z \"$input_data\" ]; then\n\t\t\tsharefailreason=\"invalid input data\"\n\t\telif [ -z \"$termbin_url\" ]; then\n\t\t\tsharefailreason=\"termbin.com error\"\n\t\telse\n\t\t\tsharefailreason=\"unknown reason\"\n\t\tfi\n\t\t# log the failed sharing attempt\n\t\techo -e \"[$(date +'%F %T')] ${redbg} SHAREKO ${default} Error sharing termbin link with client ${yellow}$NCAT_REMOTE_ADDR${default} ($sharefailreason)\" >&2\n\t\t# close the client connection without any output\n\t\texit 1\n\n\telif (grep -Eq \"^GET /asn_lookup(_json[p]?)?&\" <<<\"$line\"); then\n\t\tOUTPUT_TYPE=\"\"\n\t\tstarttime=$(date +'%s')\n\t\tstartdatetime=$(date +'%F %T')\n\t\treportdatetime=$(date +'%F %T (%Z)')\n\n\t\t# detect output method requested by the user\n\t\tmethod=$(echo -e \"$line\" | cut -d '&' -f 1)\n\t\tif grep -q \"jsonp\" <<<\"$method\"; then\n\t\t\t# user requested pretty-print json output from the server\n\t\t\tOUTPUT_TYPE=\"jsonp\"\n\t\telif grep -q \"json\" <<<\"$method\"; then\n\t\t\t# user requested compact json output from the server\n\t\t\tOUTPUT_TYPE=\"json\"\n\t\tfi\n\t\t# handle 'asn_lookup' command. This will start a lookup for the target.\n\t\t# 1) trim down target length to at most 100 characters\n\t\t# 2) extract target from client request (cut on ampersand first, space next, e.g.: 'GET /asn_lookup&google.com HTTP/1.1' should return google.com)\n\t\t# 3) convert any '%3A' to ':' (for IPv6 searches)\n\t\t# 4) convert any '%2F' to '/' (for URL searches)\n\t\t# 5) strip leading slash (/google.com -> google.com)\n\t\t# 6) sanitize by stripping any character except letters, numbers, and dot/colon/dash [.:-])\n\t\ttarget=$(echo -e \"$line\" | cut -d '&' -f 2- | awk -F' ' '{print substr($1,0,100)}')\n\t\thost=$(echo -e \"$target\" | sed -e 's/%3[aA]/:/g' -e 's/%2[fF]/\\//g' -e 's/^\\///' -e 's/[^0-9a-zA-Z/\\.:-]//g')\n\n\t\t# validate target by checking if it's an:\n\t\t# 1) IP address\n\t\t# 2) hostname (beginning with any alphanumeric character and including at least one dot '.')\n\t\t# 3) AS number (with or without case-insensitive 'AS' prefix)\n\t\tis_valid_target=$(echo -e \"$host\" | grep -Eo \"$ipv4v6regex|^([0-9a-zA-Z])+.*\\.|^([aA][sS])?[0-9]{1,6}$\")\n\n\t\t# avoid invalid/malformed targets\n\t\tif [ -n \"$is_valid_target\" ]; then\n\t\t\t# this is a valid client request, set up request identifier\n\t\t\treqid=$(date +'%N')\n\n\t\t\techo -e \"[$startdatetime] ${yellowbg} STARTED ${default} Lookup request by client ${yellow}$NCAT_REMOTE_ADDR${default} for target ${magenta}$host${default} (Request ID: ${blue}$reqid${default})\" >&2\n\n\t\t\tif [ \"$OUTPUT_TYPE\" = \"json\" ] || [ \"$OUTPUT_TYPE\" = \"jsonp\" ]; then\n\t\t\t\t# send HTTP 200 OK response with JSON Content-Type\n\t\t\t\techo -e \"${http_ok_json}\"\n\t\t\telse\n\t\t\t\t# send HTTP 200 OK response and display HTML headers\n\t\t\t\techo -e \"${http_ok}${html_header}\"\n\t\t\tfi\n\t\t\tcountryname=$(docurl -m2 -s \"https://restcountries.com/v3.1/alpha/$server_country\" | jq -r '.[].name.common')\n\t\t\tif [ -n \"$countryname\" ] && [ \"$countryname\" != \"null\" ]; then\n\t\t\t\ttitle_tag=\"title='$countryname'\"\n\t\t\telse\n\t\t\t\ttitle_tag=\"\"\n\t\t\tfi\n\n\t\t\tif [ -z \"$OUTPUT_TYPE\" ]; then\n\t\t\t\t# default HTML mode, display ASN server info table\n\t\t\t\techo -e \"\n\t\t\t\t\t<table style='border: none; white-space: nowrap';>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<th colspan='5' style='background-color: $htmllightgray;'>ASN Lookup Server Report</th>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<th>Lookup Target</td>\n\t\t\t\t\t\t\t<th>Client IP</td>\n\t\t\t\t\t\t\t<th>Lookup Server ASN</td>\n\t\t\t\t\t\t\t<th>Lookup Server Hostname</td>\n\t\t\t\t\t\t\t<th>Date and time</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td style='color:$htmlred;'>$host</td>\n\t\t\t\t\t\t\t<td style='color:$htmlyellow;'>$NCAT_REMOTE_ADDR</td>\n\t\t\t\t\t\t\t<td style='color:$htmlgreen;'><a href=\\\"/asn_lookup&AS$found_asn\\\" style=\\\"color: $htmlgreen;\\\">$found_asn</a> ($found_asname\n\t\t\t\t\t\t\t<img src='https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/flags/4x3/$server_country.svg' $title_tag style='height:1.05em; border-radius: 0; vertical-align: middle;'>)\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td style='color:$htmlmagenta;'>$HOSTNAME</td>\n\t\t\t\t\t\t\t<td style='color:$htmlwhite;'>$reportdatetime</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t\t<hr />\n\t\t\t\t\"\n\t\t\tfi\n\n\t\t\t# spawn ASN child and output results to the client\n\t\t\tDebugPrint \"Spawning child\"\n\n\t\t\tINTERNAL_CONNHANDLER_CHILD=true INTERNAL_ASNSERVER_CONNHANDLER=false INTERNAL_ASNSERVER_OUTPUT_TYPE=\"$OUTPUT_TYPE\" TERM=dumb \"$0\" \"$host\" |\n\t\t\t{\n\t\t\t\t#* ╭──────────────────────────────────────────────╮\n\t\t\t\t#* │ Main child output parsing loop command group │\n\t\t\t\t#* ╰──────────────────────────────────────────────╯\n\t\t\t\tif [ -n \"$OUTPUT_TYPE\" ]; then\n\t\t\t\t\t# JSON/JSONP mode\n\t\t\t\t\twhile IFS= read -r outputline; do\n\t\t\t\t\t\techo -e \"$outputline\"\n\t\t\t\t\tdone\n\t\t\t\telse\n\t\t\t\t\t# HTML mode\n\t\t\t\t\tTextHeader() {\n\t\t\t\t\t\theaderwidth=\"150\"\n\t\t\t\t\t\tpadchar=\"_\"\n\t\t\t\t\t\tpadding=\"$(printf '%0.1s' ' '{1..500})\"\n\t\t\t\t\t\tprintf \"%${headerwidth}s\\n\\n\" \"\" | tr \" \" \"${padchar}\"\n\t\t\t\t\t\tprintf '%*.*s %s %*.*s\\n' 0 \"$(((headerwidth-2-${#1})/2))\" \"$padding\" \"$1\" 0 \"$(((headerwidth-1-${#1})/2))\" \"$padding\"\n\t\t\t\t\t\tprintf \"%${headerwidth}s\\n\" \"\" | tr \" \" \"${padchar}\"\n\t\t\t\t\t}\n\n\t\t\t\t\t# initialize textual trace log variable\n\t\t\t\t\ttracedata=\"\"\n\t\t\t\t\twhile IFS= read -r outputline; do\n\t\t\t\t\t\t# DebugPrint \"[$reqid] CHILD OUTPUT: $outputline\" \"false\"\n\t\t\t\t\t\tif echo -e \"$outputline\" | grep -Eq \"^BOXHEADER \"; then\n\t\t\t\t\t\t\t# child instance is displaying a BoxHeader, transform it into a <table>\n\t\t\t\t\t\t\tmessage=$(echo -e \"$outputline\" | cut -d ' ' -f 2-)\n\t\t\t\t\t\t\techo -e \"<table style='width: 30%; height: 5%;'><tr><th style='background-color: $htmlblack; color: $htmlwhite;'>$message</th></tr></table>\\n\"\n\t\t\t\t\t\t\t# append boxheader to tracefile\n\t\t\t\t\t\t\t# tracedata+=\"$(BoxHeader \"$message\")\\n\"\n\t\t\t\t\t\t\ttracedata+=$(TextHeader \"[ $message ]\")\n\t\t\t\t\t\t\ttracedata+=\"\\n\\n\"\n\t\t\t\t\t\t\tif echo -e \"$message\" | grep -q \"Trace to \"; then\n\t\t\t\t\t\t\t\techo -e \"<script>top.document.title='[IN PROGRESS] Path trace to $host'</script>\"\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telif grep -Eq \"#COUNTRYCODE\" <<<\"$outputline\"; then\n\t\t\t\t\t\t\t# child instance is indicating a country code for the current IP, map it to a SVG and display it on the HTML report\n\t\t\t\t\t\t\t# alternative URLs for the flag SVGs:\n\t\t\t\t\t\t\t# JSdelivr CDN: https://cdn.jsdelivr.net/npm/flag-icon-css/flags/4x3/$cc.svg\n\t\t\t\t\t\t\t# Github Pages: https://lipis.github.io/flag-icon-css/flags/4x3/$cc.svg\n\t\t\t\t\t\t\t# CloudflareJS: https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/flags/4x3/$cc.svg\n\t\t\t\t\t\t\tcc=$(echo -e \"$outputline\" | awk '{print $NF}')\n\t\t\t\t\t\t\t# lookup full country name\n\t\t\t\t\t\t\tcountryname=$(docurl -m2 -s \"https://restcountries.com/v3.1/alpha/$cc\" | jq -r '.[].name.common')\n\t\t\t\t\t\t\tif [ -n \"$countryname\" ] && [ \"$countryname\" != \"null\" ]; then\n\t\t\t\t\t\t\t\ttitle_tag=\"title='$countryname'\"\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttitle_tag=\"\"\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\ttarget_flag_img=\"<img src='https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/flags/4x3/$cc.svg' $title_tag style='height:1.05em; border-radius: 0; vertical-align: middle;'>\"\n\t\t\t\t\t\t\toutputline=$(echo -e \"$outputline\" | sed -e 's/#COUNTRYCODE.*//')\n\t\t\t\t\t\t\ttracedata+=\"$outputline\\n\"\n\t\t\t\t\t\t\toutputline=$(echo -e \"$outputline\" | tr -d '\\r\\n' | aha -b -n)\n\t\t\t\t\t\t\tprintf \"%s%s\\n\" \"$outputline\" \"$target_flag_img\"\n\t\t\t\t\t\telif grep -Eq \"<a href=\" <<<\"$outputline\"; then\n\t\t\t\t\t\t\thref_stripped=$(awk '{gsub(/<[^>]*>/,\"\"); print }' <<<\"$outputline\")\n\t\t\t\t\t\t\ttracedata+=\"$href_stripped\\n\"\n\t\t\t\t\t\t\tprintf \"%s\\n\" \"$outputline\" | aha -b -n | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&quot;/\"/g' -e 's/&amp;/&/g'\n\t\t\t\t\t\telif grep -Eq \"#PERFORMWHOIS\" <<<\"$outputline\"; then\n\t\t\t\t\t\t\t# child instance is asking us to perform a whois lookup for the target domain\n\t\t\t\t\t\t\t# and show it to the user in the form of a tooltip\n\t\t\t\t\t\t\ttargetdomain=$(echo -e \"$outputline\" | awk '{print $NF}')\n\t\t\t\t\t\t\ttargetdomaindata=$(whois -H \"$targetdomain\" | grep -Ev \"^\\*\")\n\t\t\t\t\t\t\thostio_href=\"<a href=\\\"https://host.io/$targetdomain\\\" target=\\\"_blank\\\" style=\\\"color: $htmlyellow; font-style: italic;\\\">host.io</a>\"\n\t\t\t\t\t\t\thostio_link=\" <span style=\\\"font-size: 75%; color: $htmlyellow;\\\">$hostio_href🔗</span>\"\n\t\t\t\t\t\t\tread -r -d '' whoisbutton <<- END_OF_MODAL_HTML\n\t\t\t\t\t\t\t\t<!-- Trigger/Open The Modal -->\n\t\t\t\t\t\t\t\t<button id=\"whoisbtn\" style=\"cursor:pointer; background: none!important; border: none; padding: 0!important; text-decoration: underline dotted; font-size: 75%; font-style: italic; color: $htmlyellow;\">WHOIS</button>\n\t\t\t\t\t\t\t\t<!-- The Modal -->\n\t\t\t\t\t\t\t\t<div id=\"myModal\" class=\"modal\">\n\t\t\t\t\t\t\t\t\t<!-- Modal content -->\n\t\t\t\t\t\t\t\t\t<div class=\"modal-content\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"close\"></span>\n\t\t\t\t\t\t\t\t\t\t<p style=\"font-size: 120%; font-style: italic; text-align: center;\">Whois information for domain <span style=\"font-weight: bold; color: $htmlred;\">$targetdomain</span><br /><pre>$targetdomaindata</pre></p>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<script>\n\t\t\t\t\t\t\t\t\t// Get the modal\n\t\t\t\t\t\t\t\t\tvar modal = document.getElementById(\"myModal\");\n\n\t\t\t\t\t\t\t\t\t// Get the button that opens the modal\n\t\t\t\t\t\t\t\t\tvar btn = document.getElementById(\"whoisbtn\");\n\n\t\t\t\t\t\t\t\t\t// Get the <span> element that closes the modal\n\t\t\t\t\t\t\t\t\tvar span = document.getElementsByClassName(\"close\")[0];\n\n\t\t\t\t\t\t\t\t\t// When the user clicks the button, open the modal\n\t\t\t\t\t\t\t\t\tbtn.onclick = function() {\n\t\t\t\t\t\t\t\t\tmodal.style.display = \"block\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// When the user clicks on <span> (x), close the modal\n\t\t\t\t\t\t\t\t\tspan.onclick = function() {\n\t\t\t\t\t\t\t\t\tmodal.style.display = \"none\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// When the user clicks anywhere outside of the modal, close it\n\t\t\t\t\t\t\t\t\twindow.onclick = function(event) {\n\t\t\t\t\t\t\t\t\tif (event.target == modal) {\n\t\t\t\t\t\t\t\t\t\tmodal.style.display = \"none\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t</script>\n\t\t\t\t\t\t\tEND_OF_MODAL_HTML\n\t\t\t\t\t\t\toutputline=$(echo -e \"$outputline\" | sed -e 's/#PERFORMWHOIS.*//')\n\t\t\t\t\t\t\ttracedata+=\"${outputline}\\n\"\n\t\t\t\t\t\t\toutputline+=\"(<nobr>$whoisbutton</nobr>•$hostio_link )\"\n\t\t\t\t\t\t\tprintf \"%s\\n\" \"$outputline\" | aha -b -n | sed -e 's/&lt;/</g' -e 's/&gt;/>/g' -e 's/&quot;/\"/g' -e 's/&amp;/&/g'\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttracedata+=\"$outputline\\n\"\n\t\t\t\t\t\t\tprintf \"%s\\n\" \"$outputline\" | aha -b -n\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tprintf \"<script>window.scrollTo(0,document.body.scrollHeight);</script>\" # cheers https://stackoverflow.com/a/55471426\n\t\t\t\t\tdone\n\n\t\t\t\t\t#* Child asn instance finished, finish up the html\n\n\t\t\t\t\t# append text footer to tracedata (will only be displayed when sharing results on termbin)\n\t\t\t\t\tfootermsg=\"Report generated by ASN Lookup Server v${ASN_VERSION} (https://github.com/nitefood/asn) on $reportdatetime\"\n\t\t\t\t\tfootermsglen=${#footermsg}\n\t\t\t\t\tfooterhr=$(printf \"%150s\" \"\" | tr \" \" \"_\")\n\t\t\t\t\ttracedata+=\"$(printf \"%s\\n\\n%*s\\n\" \"$footerhr\" $(((footermsglen+150)/2)) \"$footermsg\")\"\n\n\t\t\t\t\t# print closing headers\n\t\t\t\t\tendtime=$(date +%s)\n\t\t\t\t\truntime=$((endtime-starttime))\n\t\t\t\t\techo -e \"<div style='text-align: center;'>\" \\\n\t\t\t\t\t\t\t\t\"<hr>\" \\\n\t\t\t\t\t\t\t\t\"<span style='color: darkgray; font-style: italic; font-size: 0.8em;'>\" \\\n\t\t\t\t\t\t\t\t\t\"Generated by <a href='https://github.com/nitefood/asn' target='_blank'>ASN Lookup Server</a> v${ASN_VERSION} running on $HOSTNAME in ${runtime}s (request ID: $reqid)\" \\\n\t\t\t\t\t\t\t\t\"</span>\" \\\n\t\t\t\t\t\t\t\t\"<br /><br /><span id='share-container'><button id='termbinShareButton' class='sharebutton' onclick='termbinshare()'>Share Results</button></span>\" \\\n\t\t\t\t\t\t\t\t\"<div id='share-output-container' class='textoutput hidden'> </div>\" \\\n\t\t\t\t\t\t\t\t\"<a href='#' onclick=\\\"document.getElementById('help-container').classList.toggle('hidden');return false;\\\" style='color: darkgray; font-size: 0.7em;'>What is that?</a>\" \\\n\t\t\t\t\t\t\t\t\"\\n<span id='help-container' class='textoutput hidden' style='color: $htmlgreen;'>This report will be shared on <a href='https://termbin.com' target='_blank'>Termbin</a> (a Pastebin-like sharing service for terminal data).\\nTermbin pastes have a lifespan of 1 week.</span>\" \\\n\t\t\t\t\t\t\t\"</div>\" \\\n\t\t\t\t\t\t\t\"</pre>\"\n\n\t\t\t\t\t# create a hidden div with the gzipped+b64 encoded trace output for optional termbin sharing\n\t\t\t\t\ttracedata_encoded=\"$(StripAnsi \"$tracedata\" | gzip | base64 -w0)\"\n\t\t\t\t\techo -e \"<div style='display: none;' id='tracedata'>${tracedata_encoded}</div>\"\n\n\t\t\t\t\techo -e \"$html_footer\"\n\t\t\t\tfi\n\t\t\t}\n\t\t\t#  end the ncat client connection for this request ID\n\t\t\tchildretval=\"$?\"\n\t\t\tif [ \"$childretval\" -eq 0 ]; then\n\t\t\t\tDebugPrint \"Child process completed successfully\"\n\t\t\t\t[[ -z \"$OUTPUT_TYPE\" ]] && echo -e \"<script>top.document.title='ASN Lookup for $host completed'</script>\"\n\t\t\t\t# log lookup request completed on server side\n\t\t\t\techo -e \"[$(date +\"%F %T\")] ${greenbg}COMPLETED${default} Lookup request by client ${yellow}$NCAT_REMOTE_ADDR${default} for target ${magenta}$host${default} (Request ID: ${blue}$reqid${default})\" >&2\n\t\t\telse\n\t\t\t\tDebugPrint \"Child process failed with exit code $childretval (SIG$(kill -l $childretval))\"\n\t\t\t\techo -e \"[$(date +\"%F %T\")] ${redbg}  FAILED ${default} Lookup request by client ${yellow}$NCAT_REMOTE_ADDR${default} for target ${magenta}$host${default} failed with exit code $childretval (SIG$(kill -l $childretval)) (Request ID: ${blue}$reqid${default})\" >&2\n\t\t\tfi\n\t\t\tif [ \"$childretval\" -eq 141 ]; then\n\t\t\t\tDebugPrint \"Client has gone away?\"\n\t\t\tfi\n\t\telse\n\t\t\t# send HTTP code 400 Bad Request to client\n\t\t\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\techo -e \"$http_ko\"\n\t\t\telse\n\t\t\t\techo -e \"$http_ko_json\"\n\t\t\t\tuserinput=\"$host\"\n\t\t\t\tjson_resultcount=0\n\t\t\t\tfinal_json_output=\"\"\n\t\t\t\tPrintErrorAndExit \"bad request\"\n\t\t\tfi\n\t\t\t# log lookup request ignored on server side\n\t\t\techo -e \"[$(date +\"%F %T\")] ${redbg} IGNORED ${default} Malformed data in request by client ${yellow}$NCAT_REMOTE_ADDR${default} for target ${magenta}$host${default}\" >&2\n\t\tfi\n\telse\n\t\t# ignore spurious browser requests (e.g. 'GET /favicon.ico') or scans.\n\t\t# Log the bad request on server side, sleep for 1 second, and drop the connection\n\t\treqbytes=$(echo -e \"$line\" | awk -F$'\\r\\n' '{print substr($1,0,30)}')\n\t\techo -e \"[$(date +\"%F %T\")] ${redbg} IGNORED ${default} Ignored request by client ${yellow}$NCAT_REMOTE_ADDR${default}. Request data (first 30 bytes): ${red}${reqbytes}${default}\" >&2\n\t\tsleep 1\n\tfi\n}\n\n#! ╭───────────────────────╮\n#! │ Main asn script start │\n#! ╰───────────────────────╯\n\nIFS=$'\\n\\t'\n\n# Color scheme\ngreen=$'\\e[38;5;035m'\nmagenta=$'\\e[38;5;207m'\nyellow=$'\\e[38;5;142m'\nwhite=$'\\e[38;5;007m'\nblue=$'\\e[38;5;038m'\nred=$'\\e[38;5;203m'\nblack=$'\\e[38;5;016m'\nlightyellow=$'\\e[38;5;220m'\nlightred=$'\\e[38;5;167m'\nlightblue=$'\\e[38;5;109m'\nlightgreybg=$'\\e[48;5;252m'${black}\nbluebg=$'\\e[48;5;038m'${black}\nredbg=$'\\e[48;5;210m'${black}\ngreenbg=$'\\e[48;5;035m'${black}\nyellowbg=$'\\e[48;5;142m'${black}\ndim=$'\\e[2m'\nunderline=$'\\e[4m'\ndefault=$'\\e[0m'\n\n# HTML color codes matching ANSI colors used by the script\nhtmlwhite=\"#cccccc\"\nhtmlblack=\"#1e1e1e\"\nhtmllightgray=\"#d5d5d5\"\nhtmlred=\"#ff5f5f\"\nhtmldarkred=\"#b74d4d\"\nhtmlblue=\"#00afd7\"\nhtmlyellow=\"#afaf00\"\nhtmlgreen=\"#00af5f\"\nhtmldarkgreen=\"#058505\"\nhtmlmagenta=\"#ff5fff\"\n\n[[ \"$TERM\" = \"dumb\" ]] && IS_HEADLESS=true || IS_HEADLESS=false\n\nipv4v6regex='[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|'\\\n'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\\\n'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'\\\n':((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|'\\\n'(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|'\\\n'1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))' # cheers https://stackoverflow.com/a/17871737\n\n# Get terminal width. If running headless in a child instance (or in server mode) set it to a \"sane\" value to display appropriate HTML spacing in reports\nif [ \"$IS_HEADLESS\" = true ]; then\n\tterminal_width=233\nelse\n\tterminal_width=$(tput cols)\n\ttrap 'terminal_width=$(tput cols)' SIGWINCH\nfi\n\n# Check if this script instance was launched by the ASN server connection handler\nif [ \"$INTERNAL_CONNHANDLER_CHILD\" = true ]; then\n\tIS_ASN_CHILD=true\nelse\n\tIS_ASN_CHILD=false\nfi\n\n# Check if this script instance was spawned by the ncat listener\nif [ \"$INTERNAL_ASNSERVER_CONNHANDLER\" = true ]; then\n\tIS_ASN_CONNHANDLER=true\n\tHandleNcatClientConnection\n\texit 0\nelse\n\tIS_ASN_CONNHANDLER=false\nfi\n\n# External API tokens for ipqualityscore.com (IP reputation & threat analysis lookup),\n# ipinfo.io (IP geolocation lookup) and Cloudflare Radar (BGP hijacks and route leaks historical data)\n# Files will be parsed in the order they are declared (first path found takes precedence)\nIQS_TOKEN_FILES=\"$HOME/.asn/iqs_token:/etc/asn/iqs_token\"\nIPINFO_TOKEN_FILES=\"$HOME/.asn/ipinfo_token:/etc/asn/ipinfo_token\"\nCLOUDFLARE_TOKEN_FILES=\"$HOME/.asn/cloudflare_token:/etc/asn/cloudflare_token\"\n\n# SIGINT trapping\nNO_ERROR_ON_INTERRUPT=false\ntrap Ctrl_C INT\n\n# PeeringDB list of IXP prefixes\npeeringdb_dataset=\"\"\npeeringdb_ipv6_dataset=\"\"\n\n# Well known ports list\n[[ -r \"/etc/services\" ]] && WELL_KNOWN_PORTS=$(cat /etc/services) || WELL_KNOWN_PORTS=\"\"\n\n# default options (configurable via $HOME/.asnrc)\nMTR_TRACING=true\nADDITIONAL_INETNUM_LOOKUP=true\nDETAILED_TRACE=false\nMTR_ROUNDS=5\nMAX_CONCURRENT_SHODAN_REQUESTS=10\nSHODAN_SHOW_TOP_N=5\nMONOCHROME_MODE=false\nASN_DEBUG=false\nJSON_OUTPUT=false\nJSON_PRETTY=false\nDEFAULT_SERVER_BINDADDR_v4=\"127.0.0.1\"\nDEFAULT_SERVER_BINDADDR_v6=\"::1\"\nDEFAULT_SERVER_BINDPORT=\"49200\"\nIQS_ALWAYS_QUERY=false\nIQS_CUSTOM_SETTINGS=\"\" # e.g. \"strictness=1&allow_public_access_points=false\" - see https://www.ipqualityscore.com/documentation/proxy-detection/overview -> \"Note About Front End IP Lookups\"\ndeclare -A PEERINGDB_CACHED_DATASETS\ndeclare -A PEERINGDB_CACHED_IXP_DATA\ndeclare -A CAIDARANK_CACHED_AS_DATA\n# to build the CC->CountryName mapping cache:\n# COUNTRY_MAP_CACHE=$(docurl -m4 -s \"https://restcountries.com/v3.1/all?fields=name,cca2\" | jq -c 'map({(.cca2): .name.common}) | add | to_entries | sort_by(.key) | from_entries')\nCOUNTRY_MAP_CACHE='{\"AD\":\"Andorra\",\"AE\":\"United Arab Emirates\",\"AF\":\"Afghanistan\",\"AG\":\"Antigua and Barbuda\",\"AI\":\"Anguilla\",\"AL\":\"Albania\",\"AM\":\"Armenia\",\"AO\":\"Angola\",\n\"AQ\":\"Antarctica\",\"AR\":\"Argentina\",\"AS\":\"American Samoa\",\"AT\":\"Austria\",\"AU\":\"Australia\",\"AW\":\"Aruba\",\"AX\":\"Åland Islands\",\"AZ\":\"Azerbaijan\",\"BA\":\"Bosnia and Herzegovina\",\n\"BB\":\"Barbados\",\"BD\":\"Bangladesh\",\"BE\":\"Belgium\",\"BF\":\"Burkina Faso\",\"BG\":\"Bulgaria\",\"BH\":\"Bahrain\",\"BI\":\"Burundi\",\"BJ\":\"Benin\",\"BL\":\"Saint Barthélemy\",\"BM\":\"Bermuda\",\n\"BN\":\"Brunei\",\"BO\":\"Bolivia\",\"BQ\":\"Caribbean Netherlands\",\"BR\":\"Brazil\",\"BS\":\"Bahamas\",\"BT\":\"Bhutan\",\"BV\":\"Bouvet Island\",\"BW\":\"Botswana\",\"BY\":\"Belarus\",\"BZ\":\"Belize\",\"CA\":\"Canada\",\n\"CC\":\"Cocos (Keeling) Islands\",\"CD\":\"DR Congo\",\"CF\":\"Central African Republic\",\"CG\":\"Republic of the Congo\",\"CH\":\"Switzerland\",\"CI\":\"Ivory Coast\",\"CK\":\"Cook Islands\",\"CL\":\"Chile\",\n\"CM\":\"Cameroon\",\"CN\":\"China\",\"CO\":\"Colombia\",\"CR\":\"Costa Rica\",\"CU\":\"Cuba\",\"CV\":\"Cape Verde\",\"CW\":\"Curaçao\",\"CX\":\"Christmas Island\",\"CY\":\"Cyprus\",\"CZ\":\"Czechia\",\"DE\":\"Germany\",\n\"DJ\":\"Djibouti\",\"DK\":\"Denmark\",\"DM\":\"Dominica\",\"DO\":\"Dominican Republic\",\"DZ\":\"Algeria\",\"EC\":\"Ecuador\",\"EE\":\"Estonia\",\"EG\":\"Egypt\",\"EH\":\"Western Sahara\",\"ER\":\"Eritrea\",\"ES\":\"Spain\",\n\"ET\":\"Ethiopia\",\"FI\":\"Finland\",\"FJ\":\"Fiji\",\"FK\":\"Falkland Islands\",\"FM\":\"Micronesia\",\"FO\":\"Faroe Islands\",\"FR\":\"France\",\"GA\":\"Gabon\",\"GB\":\"United Kingdom\",\"GD\":\"Grenada\",\n\"GE\":\"Georgia\",\"GF\":\"French Guiana\",\"GG\":\"Guernsey\",\"GH\":\"Ghana\",\"GI\":\"Gibraltar\",\"GL\":\"Greenland\",\"GM\":\"Gambia\",\"GN\":\"Guinea\",\"GP\":\"Guadeloupe\",\"GQ\":\"Equatorial Guinea\",\n\"GR\":\"Greece\",\"GS\":\"South Georgia\",\"GT\":\"Guatemala\",\"GU\":\"Guam\",\"GW\":\"Guinea-Bissau\",\"GY\":\"Guyana\",\"HK\":\"Hong Kong\",\"HM\":\"Heard Island and McDonald Islands\",\"HN\":\"Honduras\",\n\"HR\":\"Croatia\",\"HT\":\"Haiti\",\"HU\":\"Hungary\",\"ID\":\"Indonesia\",\"IE\":\"Ireland\",\"IL\":\"Israel\",\"IM\":\"Isle of Man\",\"IN\":\"India\",\"IO\":\"British Indian Ocean Territory\",\"IQ\":\"Iraq\",\n\"IR\":\"Iran\",\"IS\":\"Iceland\",\"IT\":\"Italy\",\"JE\":\"Jersey\",\"JM\":\"Jamaica\",\"JO\":\"Jordan\",\"JP\":\"Japan\",\"KE\":\"Kenya\",\"KG\":\"Kyrgyzstan\",\"KH\":\"Cambodia\",\"KI\":\"Kiribati\",\"KM\":\"Comoros\",\n\"KN\":\"Saint Kitts and Nevis\",\"KP\":\"North Korea\",\"KR\":\"South Korea\",\"KW\":\"Kuwait\",\"KY\":\"Cayman Islands\",\"KZ\":\"Kazakhstan\",\"LA\":\"Laos\",\"LB\":\"Lebanon\",\"LC\":\"Saint Lucia\",\n\"LI\":\"Liechtenstein\",\"LK\":\"Sri Lanka\",\"LR\":\"Liberia\",\"LS\":\"Lesotho\",\"LT\":\"Lithuania\",\"LU\":\"Luxembourg\",\"LV\":\"Latvia\",\"LY\":\"Libya\",\"MA\":\"Morocco\",\"MC\":\"Monaco\",\"MD\":\"Moldova\",\n\"ME\":\"Montenegro\",\"MF\":\"Saint Martin\",\"MG\":\"Madagascar\",\"MH\":\"Marshall Islands\",\"MK\":\"North Macedonia\",\"ML\":\"Mali\",\"MM\":\"Myanmar\",\"MN\":\"Mongolia\",\"MO\":\"Macau\",\n\"MP\":\"Northern Mariana Islands\",\"MQ\":\"Martinique\",\"MR\":\"Mauritania\",\"MS\":\"Montserrat\",\"MT\":\"Malta\",\"MU\":\"Mauritius\",\"MV\":\"Maldives\",\"MW\":\"Malawi\",\"MX\":\"Mexico\",\"MY\":\"Malaysia\",\n\"MZ\":\"Mozambique\",\"NA\":\"Namibia\",\"NC\":\"New Caledonia\",\"NE\":\"Niger\",\"NF\":\"Norfolk Island\",\"NG\":\"Nigeria\",\"NI\":\"Nicaragua\",\"NL\":\"Netherlands\",\"NO\":\"Norway\",\"NP\":\"Nepal\",\"NR\":\"Nauru\",\n\"NU\":\"Niue\",\"NZ\":\"New Zealand\",\"OM\":\"Oman\",\"PA\":\"Panama\",\"PE\":\"Peru\",\"PF\":\"French Polynesia\",\"PG\":\"Papua New Guinea\",\"PH\":\"Philippines\",\"PK\":\"Pakistan\",\"PL\":\"Poland\",\n\"PM\":\"Saint Pierre and Miquelon\",\"PN\":\"Pitcairn Islands\",\"PR\":\"Puerto Rico\",\"PS\":\"Palestine\",\"PT\":\"Portugal\",\"PW\":\"Palau\",\"PY\":\"Paraguay\",\"QA\":\"Qatar\",\"RE\":\"Réunion\",\"RO\":\"Romania\",\n\"RS\":\"Serbia\",\"RU\":\"Russia\",\"RW\":\"Rwanda\",\"SA\":\"Saudi Arabia\",\"SB\":\"Solomon Islands\",\"SC\":\"Seychelles\",\"SD\":\"Sudan\",\"SE\":\"Sweden\",\"SG\":\"Singapore\",\n\"SH\":\"Saint Helena, Ascension and Tristan da Cunha\",\"SI\":\"Slovenia\",\"SJ\":\"Svalbard and Jan Mayen\",\"SK\":\"Slovakia\",\"SL\":\"Sierra Leone\",\"SM\":\"San Marino\",\"SN\":\"Senegal\",\"SO\":\"Somalia\",\n\"SR\":\"Suriname\",\"SS\":\"South Sudan\",\"ST\":\"São Tomé and Príncipe\",\"SV\":\"El Salvador\",\"SX\":\"Sint Maarten\",\"SY\":\"Syria\",\"SZ\":\"Eswatini\",\"TC\":\"Turks and Caicos Islands\",\"TD\":\"Chad\",\n\"TF\":\"French Southern and Antarctic Lands\",\"TG\":\"Togo\",\"TH\":\"Thailand\",\"TJ\":\"Tajikistan\",\"TK\":\"Tokelau\",\"TL\":\"Timor-Leste\",\"TM\":\"Turkmenistan\",\"TN\":\"Tunisia\",\"TO\":\"Tonga\",\n\"TR\":\"Turkey\",\"TT\":\"Trinidad and Tobago\",\"TV\":\"Tuvalu\",\"TW\":\"Taiwan\",\"TZ\":\"Tanzania\",\"UA\":\"Ukraine\",\"UG\":\"Uganda\",\"UM\":\"United States Minor Outlying Islands\",\"US\":\"United States\",\n\"UY\":\"Uruguay\",\"UZ\":\"Uzbekistan\",\"VA\":\"Vatican City\",\"VC\":\"Saint Vincent and the Grenadines\",\"VE\":\"Venezuela\",\"VG\":\"British Virgin Islands\",\"VI\":\"United States Virgin Islands\",\n\"VN\":\"Vietnam\",\"VU\":\"Vanuatu\",\"WF\":\"Wallis and Futuna\",\"WS\":\"Samoa\",\"XK\":\"Kosovo\",\"YE\":\"Yemen\",\"YT\":\"Mayotte\",\"ZA\":\"South Africa\",\"ZM\":\"Zambia\",\"ZW\":\"Zimbabwe\"}'\n\n\n#*\n#* Parse command line options\n#*\nif [[ $# -lt 1 ]]; then\n\tPrintUsage\n\texit 1\nfi\n\n# read optional preferences from \"$HOME/.asnrc\" (only for non-headless runs)\nif [ \"$IS_HEADLESS\" = false ]; then\n\trcfile=\"/${HOME}/.asnrc\"\n\tif [ -r \"$rcfile\" ]; then\n\t\t# shellcheck disable=SC1090\n\t\t. \"$rcfile\"\n\tfi\nfi\n\nstatus_json_output=\"ok\"\nreason_json_output=\"success\"\njson_request_time=$(date \"+%Y-%m-%dT%H:%M:%S\")\nstarttime=\"$(date +%s)\"\nfinal_json_output=\"\"\njson_target_type=\"unknown\"\njson_resultcount=0\n\n# optspec contains:\n# - options followed by a colon: parameter is mandatory\n# - first colon: disable getopts' own error reporting\n# \tin this mode, getopts sets optchar to:\n# \t'?' -> unknown option\n# \t':' -> missing mandatory parameter to the option\noptspec=\":hvmljJsgn:t:d:o:a:c:u:\"\n\nFORCE_ORGSEARCH=false\nSUGGEST_SEARCH=false\nSERVER_MODE=false\nRECON_MODE=false\nCOUNTRY_BLOCK_MODE=false\nGEOLOCATE_ONLY_MODE=false\nBGP_UPSTREAM_MODE=false\nOPTIONS_PRESENT=false # will be set to true if getopts enters the loop (detects an option being passed)\nwhile getopts \"$optspec\" optchar; do {\n\n\tGetFullParamsFromCurrentPosition(){\n\t\t#\n\t\t# Helper function that retrieves all the command line\n\t\t# parameters starting from position $OPTIND (current\n\t\t# option's argument as being parsed by getopts)\n\t\t#\n\t\t# 1) first param is set to current option's param (space-separated)\n\t\t# 2) then append (if any exist) the following command line params.\n\t\t#\n\t\t# this allows for invocations such as 'asn -o NAME WITH SPACES'\n\t\t# without having to quote NAME WITH SPACES\n\t\t# The function requires passing the original $@ as parameter\n\t\t# so as to not confuse it with the function's own $@.\n\t\t#\n\t\t# in the above example, $OPTARG=\"NAME\", $OPTIND=\"3\", ${@:$OPTIND}=array(\"WITH\" \"SPACES\")\n\t\t#\n\t\tuserinput=\"$OPTARG\"\n\t\tfor option in \"${@:$OPTIND}\"; do\n\t\t\tuserinput+=\" $option\"\n\t\tdone\n\t}\n\n\tuserinput=\"\"\n\tOPTIONS_PRESENT=true\n    case \"${optchar}\" in\n\t\t\"n\")\n\t\t\tMTR_TRACING=false\n\t\t\tADDITIONAL_INETNUM_LOOKUP=false\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"t\")\n\t\t\tMTR_TRACING=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"d\")\n\t\t\tMTR_TRACING=true\n\t\t\tDETAILED_TRACE=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"o\")\n\t\t\tFORCE_ORGSEARCH=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"a\")\n\t\t\tSUGGEST_SEARCH=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"s\")\n\t\t\tMTR_TRACING=false\n\t\t\tRECON_MODE=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"c\")\n\t\t\tCOUNTRY_BLOCK_MODE=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"g\")\n\t\t\tGEOLOCATE_ONLY_MODE=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"u\")\n\t\t\tBGP_UPSTREAM_MODE=true\n\t\t\tGetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"m\")\n\t\t\tMONOCHROME_MODE=true\n\t\t\t;;\n\t\t\"j\")\n\t\t\tMTR_TRACING=false # json output for mtr traces not implemented yet\n\t\t\tJSON_OUTPUT=true\n\t\t\t# GetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"J\")\n\t\t\tMTR_TRACING=false # json output for mtr traces not implemented yet\n\t\t\tJSON_OUTPUT=true\n\t\t\tJSON_PRETTY=true\n\t\t\t# GetFullParamsFromCurrentPosition \"$@\"\n\t\t\t;;\n\t\t\"l\")\n\t\t\tSERVER_MODE=true\n\t\t\targcount=1\n\t\t\tfor option in \"${@:$OPTIND}\"; do\n\t\t\t\t# one or more parameters were passed to -l, check if\n\t\t\t\t# is an IP, PORT or \"IP PORT\" pair.\n\t\t\t\t# pass the rest of the command line as direct\n\t\t\t\t# ncat arguments.\n\t\t\t\t# Not passing everything directly (-l has the same\n\t\t\t\t# functionality in ncat) because asn should have more\n\t\t\t\t# sensible defaults (i.e. bind to 127.0.0.1 and not\n\t\t\t\t# 0.0.0.0 by default).\n\n\t\t\t\t# handle special case (if invocation was 'asn -l -v <server_opts>' instead of 'asn -v -l <server_opts>')\n\t\t\t\t[[ \"$option\" = \"-v\" ]] && { ASN_DEBUG=true; continue; }\n\n\t\t\t\tif [ \"$argcount\" -eq 1 ]; then\n\t\t\t\t\tlisten_opt1=\"$option\"\n\t\t\t\t\t[[ \"${listen_opt1:0:1}\" = \"-\" ]] && { listen_opt1=\"\"; userinput+=\" $option\"; argcount=99999; } # next lines will be treated as ncat options}\n\n\t\t\t\telif [ \"$argcount\" -eq 2 ]; then\n\t\t\t\t\tlisten_opt2=\"$option\"\n\t\t\t\t\t[[ \"${listen_opt2:0:1}\" = \"-\" ]] && { listen_opt2=\"\"; userinput+=\" $option\"; argcount=99999; } # next lines will be treated as ncat options}\n\t\t\t\telse\n\t\t\t\t\tuserinput+=\" $option\"\n\t\t\t\tfi\n\t\t\t\t(( argcount++ ))\n\t\t\tdone\n\t\t\t# analyze the args\n\t\t\tASN_SRV_BINDADDR=\"\"\n\t\t\tASN_SRV_BINDPORT=\"\"\n\t\t\tfor passedarg in $listen_opt1 $listen_opt2; do\n\t\t\t\tif grep -Eq \":|\\.\" <<<\"$passedarg\"; then\n\t\t\t\t\t# it's an IP address\n\t\t\t\t\tASN_SRV_BINDADDR=\"$passedarg\"\n\t\t\t\telse\n\t\t\t\t\t# it's a port\n\t\t\t\t\tASN_SRV_BINDPORT=\"$passedarg\"\n\t\t\t\tfi\n\t\t\tdone\n\t\t\t# fallback to default port if none was passed.\n\t\t\t# The rest is already in $userinput, ncat will use it for its own args\n\t\t\t[[ -z \"$ASN_SRV_BINDPORT\" ]] && ASN_SRV_BINDPORT=\"$DEFAULT_SERVER_BINDPORT\"\n\t\t\t# trim the leading whitespace from ncat options\n\t\t\tuserinput=\"${userinput#' '}\"\n\t\t\t# '-l' must be the last option (since it includes optional args), bail the getopts loop\n\t\t\tbreak\n\t\t\t;;\n\t\t\"h\")\n\t\t\tPrintUsage\n\t\t\texit 0\n\t\t\t;;\n\t\t\"v\")\n\t\t\tASN_DEBUG=true\n\t\t\trm -f \"$ASN_LOGFILE\" 2>/dev/null\n\t\t\t;;\n\t\t*)\n\t\t\tif [ \"$OPTERR\" = 1 ] && [ -t 0 ]; then\n\t\t\t\t[[ \"$optchar\" = \"?\" ]] && PrintUsage \"Error: unknown option '-$OPTARG'\"\n\t\t\t\t[[ \"$optchar\" = \":\" ]] && PrintUsage \"Error: option '-$OPTARG' requires an argument\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\t;;\n\tesac\n}\ndone\n\nif [ -t 0 ] || [ \"$IS_HEADLESS\" = true ]; then\n\t# input is from the terminal (or this is a headless instance)\n\tif [ \"$OPTIONS_PRESENT\" = false ]; then\n\t\t# shellcheck disable=SC2124\n\t\tuserinput=\"$@\"\n\telif [ -z \"$userinput\" ] && [ \"$SERVER_MODE\" =  false ]; then\n\t\t# an option was passed, but it was not one that requires a param (e.g. -m for monochrome mode)\n\t\t# fetch the actual target\n\t\tGetFullParamsFromCurrentPosition \"$@\"\n\tfi\nelse\n\t# script was invoked with input from stdin (e.g. \"asn -s < iplist\")\n\t# read IP list from stdin and trim blanks and comments\n\tuserinput=$(cat | grep -Ev '^$|^[ \\t]*#')\nfi\n\n# trim leading whitespace from userinput\nuserinput=$(awk '{ sub(/^[ \\t]+/, \"\"); print }' <<<\"$userinput\")\n# trim trailing newline from userinput\nuserinput=$(echo -en \"$userinput\")\n# check if we still don't have a target\nif [ -z \"$userinput\" ] && [ \"$SERVER_MODE\" = false ]; then\n\tPrintUsage \"Error: no target specified\"\nfi\n\n[[ \"$MONOCHROME_MODE\" = true ]] && DisableColors\n\n# options consistency check:\n# enable JSON_OUTPUT if the user has JSON_PRETTY=true in the preferences file\n# also explicitly disable tracing if the user forgot to pass \"-n\"\n[[ \"$JSON_PRETTY\" = true ]] && JSON_OUTPUT=true\n[[ \"$JSON_OUTPUT\" = true ]] && MTR_TRACING=false\n\n#* Check prerequisite and optional tools\nCheckPrerequisites\n\nlocal_wanip=\"\"\nHAVE_IPV6=false\n\nif [ \"$SERVER_MODE\" = true ]; then\n\t# user passed the \"-l\" switch\n\t[[ \"$UNABLE_TO_SERVE\" = true ]] && PrintErrorAndExit \"ERROR: Can not start the listening server. Please install the necessary tools.\"\n\tAsnServerListener\nfi\n\n# handle output type for child instances\n# supported output types: json, jsonp\nif [ -n \"$INTERNAL_ASNSERVER_OUTPUT_TYPE\" ]; then\n\tMTR_TRACING=false\n\tcase \"${INTERNAL_ASNSERVER_OUTPUT_TYPE}\" in\n\t\t\"json\")\n\t\t\tJSON_OUTPUT=true\n\t\t;;\n\t\t\"jsonp\")\n\t\t\tJSON_OUTPUT=true\n\t\t\tJSON_PRETTY=true\n\t\t;;\n\tesac\nfi\n\nif [ \"$RECON_MODE\" = true ]; then\n\t# user passed the \"-s\" switch\n\tfinal_json_output=\"[]\"\n\t[[ \"$HAVE_NMAP\" = false ]] && PrintErrorAndExit \"Nmap is required to use -s, but not available on this system\"\n\t# launch Shodan scan\n\tShodanRecon\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\tjson_resultcount=$(jq '. | length' <<<\"$shodan_json_output\")\n\t\tfinal_json_output=\"$shodan_json_output\"\n\t\tPrintJsonOutput\n\telse\n\t\ttput sgr0\n\tfi\n\texit 0\nfi\n\nif [ \"$GEOLOCATE_ONLY_MODE\" = true ]; then\n\t# user passed the \"-g\" switch\n\tfinal_json_output=\"[]\"\n\t# launch bulk geolocation lookup\n\tBulkGeolocate\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\tjson_resultcount=$(jq '. | length' <<<\"[$geolocation_json_output]\")\n\t\tfinal_json_output=\"$geolocation_json_output\"\n\t\tPrintJsonOutput\n\telse\n\t\ttput sgr0\n\tfi\n\texit 0\nfi\n\nif [ \"$COUNTRY_BLOCK_MODE\" = true ]; then\n\t# user passed the \"-c\" switch\n\t# check if user passed a country code (.xx)\n\tif [ \"${userinput::1}\" == \".\" ]; then\n\t\tcc=$(echo \"$userinput\" | cut -d '.' -f 2-)\n\t\trestcountries_output=$(docurl -s \"https://restcountries.com/v3.1/alpha/$cc\")\n\telse\n\t\t# Urlencode the spaces in user's input\n\t\tcountrystring=${userinput// /%20}\n\t\t# Look up the country code\n\t\trestcountries_output=$(docurl -s \"https://restcountries.com/v3.1/name/${countrystring}\")\n\tfi\n\thave_results=$(jq 'if type==\"array\" then true else false end' <<<\"$restcountries_output\")\n\t[[ \"$have_results\" = false ]] && PrintErrorAndExit \"No countries matching '$userinput'\"\n\tmatches=$(jq -r '. | length' <<<\"$restcountries_output\")\n\tif [ \"$matches\" -gt 1 ]; then\n\t\t[[ \"$JSON_OUTPUT\" = true ]] && PrintErrorAndExit \"Multiple countries found, please specify a valid country code\"\n\t\techo -e \"\\n${yellow}Multiple countries found, please specify a valid country code:${default}\\n\"\n\t\tfor (( i=0; i<\"$matches\"; i++ )); do\n\t\t\tformalname=$(jq -r \".[$i] | (.name.official)\" <<<\"$restcountries_output\")\n\t\t\tcommonname=$(jq -r \".[$i] | (.name.common)\" <<<\"$restcountries_output\")\n\t\t\tcc=$(jq -r \".[$i] | (.cca2)\" <<<\"$restcountries_output\")\n\t\t\tprintf \"%-55s : ${green}%s${default} (aka: %s)\\n\" \"$formalname\" \"$cc\" \"$commonname\"\n\t\tdone\n\t\techo \"\"\n\t\ttput sgr0\n\t\texit 0\n\tfi\n\tcc=$(jq -r 'select(.[].cca2 != null) | .[].cca2' <<<\"$restcountries_output\" | tr '[:upper:]' '[:lower:]')\n\t[[ -z \"$cc\" ]] && PrintErrorAndExit \"No country matching '$userinput' found\"\n\tcountryname=$(jq -r '.[].name.common' <<<\"$restcountries_output\")\n\tpopulation=$(jq -r '.[].population' <<<\"$restcountries_output\")\n\tcountry_ipv4_blocks=$(docurl -s \"https://raw.githubusercontent.com/herrbischoff/country-ip-blocks/master/ipv4/$cc.cidr\")\n\tcountry_ipv6_blocks=$(docurl -s \"https://raw.githubusercontent.com/herrbischoff/country-ip-blocks/master/ipv6/$cc.cidr\")\n\tcountry_ipv4_blocks_count=$(wc -l <<<\"$country_ipv4_blocks\")\n\tcountry_ipv6_blocks_count=$(wc -l <<<\"$country_ipv6_blocks\")\n\tif [ \"$country_ipv4_blocks\" = \"404: Not Found\" ]; then\n\t\tcountry_ipv4_blocks=\"\"\n\t\tcountry_ipv4_blocks_count=0\n\tfi\n\tif [ \"$country_ipv6_blocks\" = \"404: Not Found\" ]; then\n\t\tcountry_ipv6_blocks=\"\"\n\t\tcountry_ipv6_blocks_count=0\n\tfi\n\t# calculate total number of IPs allocated to the country\n\tjson_country_ipv4_ip_count=0\n\tcidrlist=$(echo -e \"$country_ipv4_blocks\" | sed -e 's/^.*\\///g' | sort | uniq -c | sort -nr)\n\tfor cidr in $cidrlist; do\n\t\tcidr_total_ips=$(awk '{printf \"%d\", (2**(32-$2) * $1)}' <<<\"$cidr\")\n\t\tjson_country_ipv4_ip_count=$(( json_country_ipv4_ip_count + cidr_total_ips ))\n\tdone\n\tips_per_capita=$(awk \"BEGIN {printf \\\"%.2g\\\", $json_country_ipv4_ip_count/$population}\")\n\tcountry_ipv4_ip_count=$(printf \"%'d\" \"$json_country_ipv4_ip_count\")\n\tpopulation=$(printf \"%'d\" \"$population\")\n\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\tjson_country_ipv4_blocks=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$country_ipv4_blocks\")\n\t\tjson_country_ipv6_blocks=$(jq -c --slurp --raw-input 'split(\"\\n\") | map(select(length > 0))' <<<\"$country_ipv6_blocks\")\n\t\tjson_resultcount=\"1\"\n\t\tjson_target_type=\"country\"\n\t\tfinal_json_output=\"{\\\"country_name\\\":\\\"$countryname\\\"\"\n\t\tfinal_json_output+=\",\\\"country_code\\\":\\\"$cc\\\"\"\n\t\tfinal_json_output+=\",\\\"ipv4_blocks\\\":$country_ipv4_blocks_count\"\n\t\tfinal_json_output+=\",\\\"ipv4_total_ips\\\":$json_country_ipv4_ip_count\"\n\t\tfinal_json_output+=\",\\\"ipv4_per_capita\\\":$ips_per_capita\"\n\t\tfinal_json_output+=\",\\\"ipv4\\\":${json_country_ipv4_blocks}\"\n\t\tfinal_json_output+=\",\\\"ipv6_blocks\\\":$country_ipv6_blocks_count\"\n\t\tfinal_json_output+=\",\\\"ipv6\\\":${json_country_ipv6_blocks}\"\n\t\tfinal_json_output+=\"}\"\n\t\tPrintJsonOutput\n\telse\n\t\tBoxHeader \"CIDR blocks allocated to $countryname\"\n\t\tBoxHeader \"IPv4\"\n\t\techo -e \"$country_ipv4_blocks\" | pr -4 -T -W$((terminal_width/2))\n\t\tBoxHeader \"IPv6\"\n\t\techo -e \"$country_ipv6_blocks\" | pr -4 -T -W$((terminal_width/2))\n\t\tBoxHeader \"IP Statistics for $countryname (.$cc)\"\n\t\techo -e \"\\n- ${green}$country_ipv4_blocks_count${default} IPv4 blocks found\\n- ${yellow}$country_ipv6_blocks_count${default} IPv6 blocks found\"\n\t\techo -e \"- Population: ${population}\\n- Total IPv4 addresses: ${blue}$country_ipv4_ip_count${default}${default} (~${blue}$ips_per_capita${default} IPs per person)\"\n\t\tBoxHeader \"CIDR distribution (IPv4)\"\n\t\tfor cidr in $cidrlist; do\n\t\t\tcidrcount=$(awk '{print $1}' <<<\"$cidr\")\n\t\t\tcidrsize=$(awk '{print $2}' <<<\"$cidr\")\n\t\t\t[[ \"$cidrcount\" = \"1\" ]] && s=\"\" || s=\"s\"\n\t\t\tprintf \"%10s x ${magenta}/%s${default} %s\\n\" \"$cidrcount\" \"$cidrsize\" \"block$s\"\n\t\tdone\n\t\techo \"\"\n\tfi\n\texit 0\nfi\n\nBoxHeader \"ASN lookup for $userinput\"\nDebugPrint \"ASN v$ASN_VERSION started with target: '$userinput'\"\n\nif [ \"$FORCE_ORGSEARCH\" = true ]; then\n\t# user passed the \"-o\" switch\n\tORG_FILTER=false\n\tdeclare -a orgfilters_array\n\tdeclare -a excl_orgfilters_array\n\tSearchByOrg \"$userinput\"\n\texit 0\nfi\n\nif [ \"$SUGGEST_SEARCH\" = true ]; then\n\t# user passed the \"-s\" switch\n\tRIPESuggestASN \"$userinput\"\n\texit 0\nfi\n\ninput=$(echo \"$userinput\" | sed 's/\\/.*//g' | grep -Eo \"$ipv4v6regex\")\n\nif [ -z \"$input\" ]; then\n\t# Input is not an IP Address\n\tif [ \"$BGP_UPSTREAM_MODE\" = true ]; then\n\t\techo -e \"\\n${red} Error: the ${blue}'-u'${red} option requires an IPv4 or IPv6 address as input${default}\\n\"\n\t\texit 1\n\tfi\n\t# Check if it is a number (ASN)\n\tasn=$(echo \"$userinput\" | sed 's/[a|A][s|S]//g' | grep -E \"^[0-9]*$\")\n\tif [ -z \"$asn\" ]; then\n\t\t# Input is not an ASN either. See if it's a hostname (includes at least one dot)\n\t\tif echo \"$userinput\" | grep -q \"\\.\"; then\n\t\t\t# filter the input in case it's a URL, extracting relevant hostname/IP data\n\t\t\tuserinput=$(awk -F[/:] '{gsub(\".*//\", \"\"); gsub(\".*:.*@\", \"\"); print $1}' <<<\"$userinput\")\n\t\t\t# run the IP regex again in case input is an IP(v6) URL (e.g. https://1.2.3.4/) and skip resolution if an IP is found\n\t\t\tip=$(echo \"$userinput\" | grep -Eo \"$ipv4v6regex\")\n\t\t\tif [ -z \"$ip\" ]; then\n\t\t\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\t\t# this instance is an ASN server child (not in JSON mode)\n\t\t\t\t\ttargetdomain=$(rev <<<\"$userinput\" | cut -d '.' -f 1,2 | rev)\n\t\t\t\t\techo -e \"\\n${blue}- Resolving \\\"$userinput\\\"... #PERFORMWHOIS $targetdomain\\n\"\n\t\t\t\telif [[ \"$JSON_OUTPUT\" = false ]]; then\n\t\t\t\t\t# normal output\n\t\t\t\t\techo -e -n \"\\n${blue}- Resolving \\\"$userinput\\\"... \"\n\t\t\t\tfi\n\t\t\t\tjson_target_type=\"hostname\"\n\t\t\t\tip=$(ResolveHostnameToIPList \"$userinput\")\n\t\t\t\tif [ -z \"$ip\" ]; then\n\t\t\t\t\tresolver_error=\"${red}Error: unable to resolve hostname${default}\"\n\t\t\t\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\t\t\techo -e \"$resolver_error\\n\"\n\t\t\t\t\telif [ \"$IS_ASN_CHILD\" = false ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\t\t\t# normal output\n\t\t\t\t\t\techo -e \"${resolver_error}\\n\\n(Hint: if you wanted to search by organization, try the ${blue}'-o'${default} switch)\\n\" >&2\n\t\t\t\t\telse\n\t\t\t\t\t\t# json output (both ASN child and normal instance)\n\t\t\t\t\t\tPrintErrorAndExit \"unable to resolve hostname\"\n\t\t\t\t\tfi\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tnumips=$(echo \"$ip\" | wc -l)\n\t\t\t[[ $numips = 1 ]] && s=\"\" || s=\"es\"\n\t\t\t[[ \"$JSON_OUTPUT\" = false ]] && echo -e \"${blue}$numips IP address$s found:${default}\\n\"\n\t\t\t# grab the longest IP to properly size output padding\n\t\t\tlongest=0\n\t\t\tfor singleip in $ip; do\n\t\t\t\t[[ ${#singleip} -gt $longest ]] && longest=${#singleip}\n\t\t\tdone\n\t\t\t(( longest++ ))\n\t\t\t# output actual results\n\t\t\tip_to_trace=\"\"\n\t\t\tWhatIsMyIP\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ] && [ \"$numips\" -gt 1 ] && [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\t# Running headless as an ASN server connhandler child, not in JSON mode, and more than 1 IP detected.\n\t\t\t\t# Speed up the operation and only process the first appropriate IP (v4/v6)\n\t\t\t\tif [ \"$HAVE_IPV6\" = true ] && grep -q ':' <<<\"$ip\"; then\n\t\t\t\t\tip_to_trace=$(echo \"$ip\" | grep -m1 ':')\n\t\t\t\telse\n\t\t\t\t\tip_to_trace=$(echo \"$ip\" | grep -v -m1 ':')\n\t\t\t\tfi\n\t\t\t\tLookupASNAndRouteFromIP \"$ip_to_trace\"\n\t\t\t\tWhoisIP \"$ip_to_trace\"\n\t\t\t\tPrintReputationAndShodanData \"$ip_to_trace\"\n\t\t\t\techo -e \"\\n${bluebg} INFO ${default} multiple IP support is ${red}disabled${default} for remote traces. The remaining $((numips-1)) IPs have been ignored:\"\n\t\t\t\tcount=1\n\t\t\t\tfor singleip in $(echo \"$ip\" | grep -v \"$ip_to_trace\"); do\n\t\t\t\t\tignoredip=\"<a href=\\\"/asn_lookup&$singleip\\\">$singleip</a>\"\n\t\t\t\t\tif [[ count -lt $((numips-1)) ]]; then\n\t\t\t\t\t\techo -e \"   ├ ${white}${ignoredip}${default}\"\n\t\t\t\t\telse\n\t\t\t\t\t\techo -e \"   └ ${white}${ignoredip}${default}\"\n\t\t\t\t\tfi\n\t\t\t\t\t((count++))\n\t\t\t\tdone\n\t\t\t\techo \"\"\n\t\t\t\tTraceASPath \"$ip_to_trace\"\n\t\t\telse\n\t\t\t\tfor singleip in $ip; do\n\t\t\t\t\tif [ -n \"$ip_to_trace\" ] && [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t\t\t\t# add a comma to separate json output in case we hit multiple dns lookup results\n\t\t\t\t\t\tfinal_json_output+=\",\"\n\t\t\t\t\tfi\n\t\t\t\t\tLookupASNAndRouteFromIP \"$singleip\"\n\t\t\t\t\tWhoisIP \"$singleip\"\n\t\t\t\t\tPrintReputationAndShodanData \"$singleip\"\n\t\t\t\t\t# save the first IP from the dns lookup result\n\t\t\t\t\t[[ -z \"$ip_to_trace\" ]] && ip_to_trace=\"$singleip\"\n\t\t\t\tdone\n\t\t\t\t[[ \"$JSON_OUTPUT\" = true ]] && PrintJsonOutput\n\t\t\t\t# Check if AS path tracing is requested\n\t\t\t\tif [ \"$MTR_TRACING\" = true ]; then\n\t\t\t\t\t# In case of multiple IPs (DNS RR), trace the first one.\n\t\t\t\t\t# Additionally, if we're on an IPv6 connection, default to\n\t\t\t\t\t# tracing to the first resolved IPv6 address (if any)\n\t\t\t\t\tif [ \"$HAVE_IPV6\" = true ]; then\n\t\t\t\t\t\tfirst_ipv6=$(echo \"$ip\" | grep -m1 ':')\n\t\t\t\t\t\t[[ -n \"$first_ipv6\" ]] && ip_to_trace=\"$first_ipv6\"\n\t\t\t\t\tfi\n\t\t\t\t\tTraceASPath \"$ip_to_trace\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\t\t\ttput sgr0\n\t\t\t\techo \"\"\n\t\t\tfi\n\t\t\texit 0\n\t\telse\n\t\t\t# not an IP, not an ASN, not a hostname. Consider it an Organization name\n\t\t\tORG_FILTER=false\n\t\t\tdeclare -a orgfilters_array\n\t\t\tdeclare -a excl_orgfilters_array\n\t\t\tSearchByOrg \"$userinput\"\n\t\tfi\n\telse\n\t\t# Input is an ASN\n\t\tjson_target_type=\"asn\"\n\t\tWhoisASN \"$asn\"\n\t\tif [ -z \"$found_asname\" ]; then\n\t\t\tPrintErrorAndExit \"Error: no data found for AS${asn}\"\n\t\tfi\n\t\tGetCAIDARank \"$asn\"\n\t\ttarget_asname=\"$found_asname\"\n\t\tif [ \"$JSON_OUTPUT\" = true ]; then\n\t\t\t# JSON output\n\t\t\tGetIXPresence \"$asn\"\n\t\t\tQueryRipestat \"$asn\"\n\t\t\tGetCloudflareHijacksAndLeaks \"$asn\"\n\t\t\tfinal_json_output+=\"{\"\n\t\t\tfinal_json_output+=\"\\\"asn\\\":\\\"${asn}\\\"\"\n\t\t\tfinal_json_output+=\",\\\"asname\\\":\\\"${target_asname//\\\"/\\\\\\\"}\\\"\"\n\t\t\tfinal_json_output+=\",\\\"asrank\\\":${caida_asrank//\\\"/\\\\\\\"}\"\n\t\t\tfinal_json_output+=\",\\\"org\\\":\\\"${found_org//\\\"/\\\\\\\"}\\\"\"\n\t\t\tfinal_json_output+=\",\\\"holder\\\":\\\"${found_holder//\\\"/\\\\\\\"}\\\"\"\n\t\t\tfinal_json_output+=\",\\\"abuse_contacts\\\":${json_abuse_contacts}\"\n\t\t\tfinal_json_output+=\",\\\"registration_date\\\":\\\"${found_createdate}\\\"\"\n\t\t\tfinal_json_output+=\",\\\"ixp_presence\\\":$json_ixps\"\n\t\t\t# peer count\n\t\t\tif [ -n \"$ripestat_routing_data\" ]; then\n\t\t\t\tfinal_json_output+=\",\\\"prefix_count_v4\\\":${ripestat_ipv4}\"\n\t\t\t\tfinal_json_output+=\",\\\"prefix_count_v6\\\":${ripestat_ipv6}\"\n\t\t\t\tfinal_json_output+=\",\\\"bgp_peer_count\\\":${ripestat_bgp}\"\n\t\t\tfi\n\t\t\t# BGP incident (hijacks/leaks) summary\n\t\t\tif [ \"$cf_hijack_query_success\" = true ]; then\n\t\t\t\tfinal_json_output+=\",\\\"bgp_hijack_incidents\\\":{\\\"total\\\":${cf_hijacks_count}\"\n\t\t\t\tfinal_json_output+=\",\\\"as_hijacker\\\":${cf_hijacks_as_hijacker_count}\"\n\t\t\t\tfinal_json_output+=\",\\\"as_victim\\\":${cf_hijacks_as_victim_count}\"\n\t\t\t\tfinal_json_output+=\"}\"\n\t\t\tfi\n\t\t\tif [ \"$cf_leak_query_success\" = true ]; then\n\t\t\t\tfinal_json_output+=\",\\\"bgp_leak_incidents\\\":{\\\"total\\\":${cf_leaks_count}\"\n\t\t\t\tfinal_json_output+=\"}\"\n\t\t\tfi\n\t\t\t# peer list\n\t\t\tif [ -n \"$ripestat_neighbours_data\" ]; then\n\t\t\t\tfinal_json_output+=\",\\\"bgp_peers\\\":{\"\n\t\t\t\tfinal_json_output+=\"\\\"upstream\\\":$json_upstream_peers\"\n\t\t\t\tfinal_json_output+=\",\\\"downstream\\\":$json_downstream_peers\"\n\t\t\t\tfinal_json_output+=\",\\\"uncertain\\\":$json_uncertain_peers\"\n\t\t\t\tfinal_json_output+=\"}\"\n\t\t\tfi\n\t\t\t# announced prefixes\n\t\t\tfinal_json_output+=\",\\\"announced_prefixes\\\":$json_ripe_prefixes\"\n\t\t\tfinal_json_output+=\",\\\"inetnums\\\":{\"\n\t\t\tfinal_json_output+=\"\\\"v4\\\":$json_ipv4_aggregated_inetnums\"\n\t\t\tfinal_json_output+=\",\\\"v6\\\":$json_ipv6_aggregated_inetnums}\"\n\t\t\tfinal_json_output+=\",\\\"inetnums_announced_by_other_as\\\":{\"\n\t\t\tfinal_json_output+=\"\\\"v4\\\":[$json_ipv4_other_inetnums]\"\n\t\t\tfinal_json_output+=\",\\\"v6\\\":[$json_ipv6_other_inetnums]}\"\n\t\t\tfinal_json_output+=\"}\"\n\n\t\t\tPrintJsonOutput\n\t\telse\n\t\t\t# normal output\n\t\t\techo -en \"\\n${bluebg} AS Number     ──>${default} ${red}${asn}\"\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\tripestat_link=\"<a href=\\\"https://stat.ripe.net/AS$asn\\\" target=\\\"_blank\\\" style=\\\"color: $htmlred; font-style: italic;\\\">RIPEStat</a>\"\n\t\t\t\the_link=\"<a href=\\\"https://bgp.he.net/AS$asn\\\" target=\\\"_blank\\\" style=\\\"color: $htmlred; font-style: italic;\\\">HE.NET</a>\"\n\t\t\t\tbgpview_link=\"<a href=\\\"https://bgpview.io/asn/$asn\\\" target=\\\"_blank\\\" style=\\\"color: $htmlred; font-style: italic;\\\">BGPView</a>\"\n\t\t\t\tbgptools_link=\"<a href=\\\"https://bgp.tools/as/$asn\\\" target=\\\"_blank\\\" style=\\\"color: $htmlred; font-style: italic;\\\">BGPTools</a>\"\n\t\t\t\tpeeringdb_link=\"<a href=\\\"https://www.peeringdb.com/asn/$asn\\\" target=\\\"_blank\\\" style=\\\"color: $htmlred; font-style: italic;\\\">PeeringDB</a>\"\n\t\t\t\techo -en \" <span style=\\\"font-size: 75%; color: $htmlred;\\\">($ripestat_link🔗 • $he_link🔗 • $bgpview_link🔗 • $bgptools_link🔗 • $peeringdb_link🔗)</span>\"\n\t\t\tfi\n\t\t\techo \"\"\n\t\t\techo -en \"${bluebg} AS Name       ──>${default} ${green}${target_asname}\"\n\t\t\tif [ \"$IS_ASN_CHILD\" = true ]; then\n\t\t\t\t# signal to the parent connhandler the correct country flag to display for this ASN\n\t\t\t\tflag_icon_cc=$(echo \"${target_asname##*,}\" | tr -d ' ' | tr '[:upper:]' '[:lower:]')\n\t\t\t\t[[ -n \"$flag_icon_cc\" ]] && echo -n \" #COUNTRYCODE $flag_icon_cc\"\n\t\t\tfi\n\t\t\tprintf \"\\n\"\n\t\t\techo -e \"${bluebg} Organization  ──>${default} ${yellow}${found_holder} (${found_org})\"\n\t\t\techo -e \"${bluebg} CAIDA AS Rank ──>${default} ${caida_asrank_recap}${default}\"\n\t\t\techo -e \"${bluebg} Abuse contact ──>${default} ${blue}${found_abuse_contact}\"\n\t\t\techo -e \"${bluebg} AS Reg. date  ──>${default} ${white}${found_createdate}\"\n\t\t\techo -e \"${bluebg} RIR (Region)  ──>${default} ${white}${caida_rir}\"\n\t\t\techo -en \"${bluebg} Peering @IXPs ──>${default} \"\n\t\t\tGetIXPresence \"$asn\"\n\t\t\techo \"\"\n\t\t\tBoxHeader \"BGP information for AS${asn} (${target_asname})\"\n\t\t\tGetCloudflareHijacksAndLeaks \"$asn\"\n\t\t\techo \"\"\n\t\t\techo -e \"${bluebg} BGP Neighbors           ────>${default} ${green}${caida_degree_total}${default} ${dim}(${default}${caida_degree_provider}${dim} Transits • ${default}${caida_degree_peer}${dim} Peers • ${default}${caida_degree_customer}${dim} Customers)${default}\"\n\t\t\techo -e \"${bluebg} Customer cone           ────>${default} ${green}${caida_customercone} ${default}${dim}(# of ASNs observed in the customer cone for this AS)${default}\"\n\t\t\techo -e \"${bluebg} BGP Hijacks (past 1y)   ────>${default} $cf_hijacks_text\"\n\t\t\techo -e \"${bluebg} BGP Route leaks (past 1y) ──>${default} $cf_leaks_text\"\n\t\t\tradar_href=\"https://radar.cloudflare.com/routing/as$asn?dateRange=52w\"\n\t\t\t[[ \"$IS_ASN_CHILD\" = true ]] && radar_href=\"<a href=\\\"$radar_href\\\" target=\\\"_blank\\\" style=\\\"color: $htmlblue; font-style: italic;\\\">View on Cloudflare Radar</a>🔗\"\n\t\t\techo -e \"${bluebg} In-depth BGP incident info ─>${default} ${dim}${blue}➜ ${radar_href}${default}\"\n\t\t\techo \"\"\n\t\t\tBoxHeader \"Prefix information for AS${asn} (${target_asname})\"\n\t\t\techo \"\"\n\t\t\tQueryRipestat \"${asn}\"\n\t\t\tif [ -n \"$ripestat_routing_data\" ]; then\n\t\t\t\techo -e \"${bluebg} IPv4 Prefixes  ────>${default} ${green}${ripestat_ipv4}\"\n\t\t\t\techo -e \"${bluebg} IPv6 Prefixes  ────>${default} ${yellow}${ripestat_ipv6}\"\n\t\t\tfi\n\t\t\tif [ -n \"$ripestat_neighbours_data\" ]; then\n\t\t\t\t[[ -n \"$upstream_peers\" ]] && upstream_peers=$(echo -e \"$upstream_peers\") || upstream_peers=\"${redbg} NONE ${default}\"\n\t\t\t\t[[ -n \"$downstream_peers\" ]] && downstream_peers=$(echo -e \"$downstream_peers\") || downstream_peers=\"${redbg} NONE ${default}\"\n\t\t\t\t[[ -n \"$uncertain_peers\" ]] && uncertain_peers=$(echo -e \"$uncertain_peers\") || uncertain_peers=\"${redbg} NONE ${default}\"\n\t\t\t\techo \"\"\n\t\t\t\tBoxHeader \"Peering information for AS${asn} (${target_asname})\"\n\t\t\t\techo -e \"\\n${green}──────────────── Upstream Peers ────────────────${default}\\n\\n${upstream_peers}\"\n\t\t\t\techo -e \"\\n${yellow}─────────────── Downstream Peers ───────────────${default}\\n\\n${downstream_peers}\"\n\t\t\t\techo -e \"\\n${white}─────────────── Uncertain  Peers ───────────────${default}\\n\\n${uncertain_peers}\"\n\t\t\tfi\n\t\t\techo \"\"\n\t\t\tBoxHeader \"Aggregated IP resources for AS${asn} (${target_asname})\"\n\t\t\techo -e \"\\n${green}───── IPv4 ─────${default}\"\n\t\t\t[[ -n \"$ipv4_inetnums\" ]] && echo -e \"${green}${ipv4_inetnums}${default}\" || echo -e \"\\n${redbg} NONE ${default}\"\n\t\t\techo -e \"\\n${yellow}───── IPv6 ─────${default}\"\n\t\t\t[[ -n \"$ipv6_inetnums\" ]] && echo -e \"${yellow}${ipv6_inetnums}${default}\" || echo -e \"\\n${redbg} NONE ${default}\"\n\t\t\ttput sgr0\n\t\t\techo \"\"\n\t\tfi\n\t\texit 0\n\tfi\nelse\n\t# Input is an IP address\n\tgrep -q \":\" <<<\"$input\" && json_target_type=\"ipv6\" || json_target_type=\"ipv4\"\n\t# Perform IP lookup\n\tLookupASNAndRouteFromIP \"$input\"\n\t(( longest=${#input}+1 ))\n\tif [ \"$BGP_UPSTREAM_MODE\" = true ]; then\n\t\tBGPUpstreamLookup \"$input\"\n\t\t[[ \"$JSON_OUTPUT\" = true ]] && PrintJsonOutput\n\t\texit 0\n\tfi\n\tWhoisIP \"$input\"\n\tPrintReputationAndShodanData \"$input\"\n\t[[ \"$JSON_OUTPUT\" = true ]] && PrintJsonOutput\n\t# Perform AS path tracing if requested\n\t[[ \"$MTR_TRACING\" = true ]] && TraceASPath \"$input\"\n\tif [ \"$JSON_OUTPUT\" = false ]; then\n\t\ttput sgr0\n\t\techo \"\"\n\tfi\n\texit 0\nfi\n"
        },
        {
          "name": "asn.1",
          "type": "blob",
          "size": 5.2236328125,
          "content": ".TH ASN 1 \"September 2024\" \"0.78.1\" \"User Commands\"\n.SH NAME\nasn \\- ASN / RPKI validity / BGP stats / IPv4v6 / Prefix / ASPath / Organization / IP reputation lookup tool\n.SH SYNOPSIS\n.B asn\n[\\fIOPTIONS\\fR] [\\fITARGET\\fR]\n.br\n.B asn\n[\\fB-v\\fR] \\fB-l\\fR [\\fISERVER OPTIONS\\fR]\n.SH DESCRIPTION\nASN is a tool for performing various lookup operations related to ASN (Autonomous System Number), RPKI validity, BGP statistics, IPv4/v6 addresses, prefixes, ASPaths, organizations, and IP reputations.\n.SH OPTIONS\n.TP\n\\fB-t\\fR\n.B (enable trace)\n.br\nEnable AS path trace to the\n.B TARGET\n(this is the default behavior)\n.TP\n\\fB-n\\fR\n.B (no trace|no additional INETNUM lookups)\n.br\nDisable tracing the AS path to the\n.B TARGET\n(for IP targets) or\n.br\nDisable additional (unannounced / announced by other AS) INETNUM lookups for the\n.B TARGET\n(for AS targets)\n.TP\n\\fB-d\\fR\n.B (detailed)\nOutput detailed hop info during the AS path trace to the\n.B TARGET\n.br\nThis option also enables RPKI validation/BGP hijacking detection for every hop\n.TP\n\\fB-a\\fR\n.B (ASN Suggest)\n.br\nLookup AS names and numbers matching\n.B TARGET\n.TP\n\\fB-u\\fR\n.B (Transit/Upstream lookup)\n.br\nInspect BGP updates and ASPATHs for the\n.B TARGET\naddress/prefix and identify possible transit/upstream autonomous systems\n.TP\n\\fB-c\\fR\n.B (Country CIDR)\n.br\nLookup all IPv4/v6 CIDR blocks allocated to the\n.B TARGET\ncountry\n.TP\n\\fB-g\\fR\n.B (Bulk Geolocate)\n.br\nGeolocate all IPv4/v6 addresses passed as\n.B TARGET\n.br\nThis mode supports multiple targets, stdin input and IP extraction from input, e.g.\n.br\n.B asn -g < /var/log/apache2/error.log\nor\n.B echo 1.1.1.1 2.2.2.2 | asn -g\n.TP\n\\fB-s\\fR\n.B (Shodan scan)\n.br\nQuery Shodan's InternetDB for CVE/CPE/Tags/Ports/Hostnames data about TARGET\n.br\nThis mode supports multiple targets and stdin input, e.g.\n.br\n.B asn -s < iplist\nor\n.B echo 1.1.1.0/24 google.com | asn -s\n.TP\n\\fB-o\\fR\n.B (organization search)\n.br\nForce\n.B TARGET\nto be treated as an Organization Name\n.TP\n\\fB-m\\fR\n.B (monochrome output)\n.br\nDisable colored output\n.TP\n\\fB-v\\fR\n.B (verbose)\n.br\nEnable (and log to $HOME/asndebug.log) debug messages (URLs being queried and variable names being assigned)\n.br\nAPI call response data (i.e. the JSON output) is logged to the logfile.\n.TP\n\\fB-j\\fR\n.B (compact JSON output)\n.br\nSet output to compact JSON mode (ideal for machine parsing)\n.TP\n\\fB-J\\fR\n.B (pretty-printed JSON output)\n.br\nSet output to pretty-printed JSON mode\n.TP\n\\fB-h\\fR\n.B (help)\n.br\nShow this help screen\n.TP\n\\fB-l\\fR\n.B (lookup server)\n.br\nLaunch the script in server mode. See\n.B SERVER OPTIONS\nbelow\n.SH TARGET\n.TP\n\\fB<AS Number>\\fR\nLookup matching ASN and BGP announcements/neighbours data.\n.TP\n\\fB<IPv4/IPv6>\\fR\nLookup matching route(4/6), IP reputation, and ASN data.\n.TP\n\\fB<Prefix>\\fR\nLookup matching ASN data.\n.TP\n\\fB<host.name.tld>\\fR\nLookup matching IP, route, and ASN data. Supports multiple IPs - e.g. DNS RR.\n.TP\n\\fB<URL>\\fR\nExtract hostname/IP from the URL and lookup relative data. Supports any protocol prefix, non-standard ports, and prepended credentials.\n.TP\n\\fB<Organization Name>\\fR\nSearch by company name and lookup network ranges exported by (or related to) the company.\n.SH SERVER OPTIONS\n.TP\n\\fB\\&BIND_ADDRESS\\fR\nIP address (v4/v6) to bind the listening server to (e.g., 'asn -l 0.0.0.0').\n.br\nDefault value:\n.B 127.0.0.1 (IPv4) or ::1 (IPv6).\n.TP\n\\fB\\&BIND_PORT\\fR\nTCP Port to bind the listening server to (e.g., 'asn -l 12345').\n.br\nDefault value:\n.B 49200.\n.TP\n\\fB\\&BIND_ADDRESS BIND_PORT\\fR\nIP address and port to bind the listening server to (e.g., 'asn -l ::1 12345').\n.TP\n.B \\fB-v\\fR\n.B (verbose)\n.br\nEnable verbose output and debug messages in server mode.\n.TP\n.B \\fB--allow\\fR host[,host,...]\nAllow only given hosts to connect to the server.\n.TP\n.B \\fB--allowfile\\fR file\nA file of hosts allowed to connect to the server.\n.TP\n.B \\fB--deny\\fR host[,host,...]\nDeny given hosts from connecting to the server.\n.TP\n.B \\fB--denyfile\\fR file\nA file of hosts denied from connecting to the server.\n.TP\n.B \\fB-m\\fR, \\fB--max-conns\\fR <n>\nThe maximum number of simultaneous connections accepted by the server. 100 is the default.\n.SH NOTES\nEvery option in server mode (after -l) is passed directly to the ncat listener. Refer to\n.B man ncat\nfor more details on the available commands. Unless specified, the default IP:PORT values of 127.0.0.1:49200 (for IPv4) or [::1]:49200 (for IPv6) will be used (e.g., 'asn -l').\n.SH EXAMPLES\nExample server usage:\n.PP\n.B asn -l\n(starts server on default IP(v4/v6):PORT)\n.PP\n.B asn -l 0.0.0.0 --allow 192.168.0.0/24,192.168.1.0/24,192.168.2.245\n(binds to all available IPv4 interfaces on the default port, allowing only connections from the three specified subnets)\n.PP\n.B asn -l :: 2222 --allow 2001:DB8::/32\n(binds to all available IPv6 interfaces on port 2222, allowing only connections from the specified prefix)\n.PP\n.B asn -v -l 0.0.0.0 --allowfile \"~/goodips.txt\" -m 5\n(verbose mode, bind to all IPv4 interfaces, use an allowfile with allowed addresses, accept a maximum of 5 concurrent connections)\n.SH \"SEE ALSO\"\nTo file a bug report or feature request, please open an issue on the project homepage:\n.B https://github.com/nitefood/asn\n.SH \"AUTHOR\"\nProject author: nitefood\n.B <nitefood0@gmail.com>\n.PP\nThis manpage was created by Marcos Rodrigues de Carvalho (aka oday)\n.B <marcosrcarvalho42@gmail.com>\n"
        },
        {
          "name": "cloudshell_bootstrap.sh",
          "type": "blob",
          "size": 2.2060546875,
          "content": "#!/usr/bin/env bash\n\nread -r -d '' banner <<- END_OF_BANNER\n#########################################################################################################\"\n# Helper script to prepare the GCP environment (install prerequisite packages / install the ASN script) #\n# Project homepage: https://github.com/nitefood/asn                                                     #\n#########################################################################################################\nEND_OF_BANNER\n\ngreen=$'\\e[38;5;035m'\nblue=$'\\e[38;5;038m'\nred=$'\\e[38;5;203m'\nblack=$'\\e[38;5;016m'\ngreenbg=$'\\e[48;5;035m'${black}\ndim=$'\\e[2m'\ndefault=$'\\e[0m'\n\nclear\nsudo mkdir -p /etc/asn\necho -e \"${dim}$banner${default}\\n\"\necho -en \"Enter your IPQualityScore API token (or press Enter to skip): \"\nread -sr IQS_TOKEN\necho -en \"\\nEnter your ipinfo.io API token (or press Enter to skip): \"\nread -sr IPINFO_TOKEN\necho -en \"\\nEnter your Cloudflare API token (or press Enter to skip): \"\nread -sr CLOUDFLARE_TOKEN\n\nif [ -n \"$IQS_TOKEN\" ]; then\n\techo -en \"\\n\\n- Enabling IPQualityScore API...\"\n\techo \"$IQS_TOKEN\" | sudo tee /etc/asn/iqs_token &>/dev/null\n\techo \"${green}OK${default}\"\nelse\n\techo -e \"\\n\\n- IPQualityScore API ${red}DISABLED${default}\"\nfi\nif [ -n \"$IPINFO_TOKEN\" ]; then\n\techo -en \"- Enabling ipinfo.io API...\"\n\techo \"$IPINFO_TOKEN\" | sudo tee /etc/asn/ipinfo_token &>/dev/null\n\techo \"${green}OK${default}\"\nelse\n\techo -e \"- ipinfo.io API ${red}DISABLED${default}\"\nfi\nif [ -n \"$CLOUDFLARE_TOKEN\" ]; then\n\techo -en \"- Enabling Cloudflare API...\"\n\techo \"$CLOUDFLARE_TOKEN\" | sudo tee /etc/asn/cloudflare_token &>/dev/null\n\techo \"${green}OK${default}\"\nelse\n\techo -e \"- Cloudflare API ${red}DISABLED${default}\"\nfi\n\necho -en \"- Installing prerequisite packages...\"\nsudo apt update &>/dev/null\nsudo apt -y install curl whois bind9-host mtr-tiny jq ipcalc grepcidr nmap ncat aha &>/dev/null\necho -e \"${green}OK${default}\"\necho -en \"- Installing the asn script...\"\nsudo install -m 755 asn /usr/bin\necho -e \"${green}OK${default}\"\necho -e \"\\n${greenbg} All done ${default}\\n\"\necho -e \"Example usage:\\n\\tServer mode : ${blue}asn -l${default}\\n\\tASPath trace: ${blue}asn 1.1.1.1${default}\\n\\nFor a full feature list visit ${blue}https://github.com/nitefood/asn${default}\\n\\n\"\n"
        }
      ]
    }
  ]
}