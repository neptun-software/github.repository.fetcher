{
  "metadata": {
    "timestamp": 1736568700519,
    "page": 789,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "swoodford/aws",
      "stars": 1236,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0166015625,
          "content": "# OS X\n.DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2822265625,
          "content": "language: bash\n\nbefore_script:\n    - curl -L \"https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/shunit2/shunit2-2.1.6.tgz\" | tar zx\n\nscript:\n    - bash equality_test.sh\n\nnotifications: \n  email: \n    on_failure: \n      - always\n    on_success: \n      - never\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 10.4833984375,
          "content": "   #### Apache License\n   ##### Version 2.0, January 2004\n   ###### http://www.apache.org/licenses/\n\n   #### TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   Copyright 2018 Shawn Woodford\n   https://github.com/swoodford\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "PULL_REQUEST_TEMPLATE.md",
          "type": "blob",
          "size": 1.513671875,
          "content": "<!---\nVerify first that your issue/request is not already reported on GitHub.\nAlso test if the latest release, and master branch are affected too.\n-->\n\n#### Issue Type\n<!--- Pick one below and delete the rest -->\n - Bug Report\n - Feature Request\n - Documentation Issue\n\n\n#### Script Name\nName of the script, file or feature, do not include extra details here\n\n\n#### AWS CLI Version\nPaste verbatim output from `aws --version` between quotes below\n```\n\n```\n\n#### AWS CLI Profile (if any)\nThis will be shown by running `aws configure list` or `cat ~/.aws/config` (do not share access_key or secret_key!)\n```\n\n```\n\n#### AWS Default Region\n```\n\n```\n\n#### AWS Default Output Type\n```\n\n```\n\n#### OS / Environment\n<!---\nMention the OS you are running the script from, and the OS you are\nmanaging, or say \"N/A\" for anything that is not platform-specific.\nAlso mention the specific version of what you are trying to control.\n-->\n```\n\n```\n\n#### Summary\n<!--- Explain the problem briefly -->\n\n\n#### Steps to Reproduce\n<!---\nFor bugs, show exactly how to reproduce the problem, using a minimal test-case.\nFor new features, show how the feature would be used.\n-->\n\n\n<!--- Paste examples or commands between quotes below -->\n```bash\n\n```\n\n<!--- You can also paste gist.github.com links for larger files -->\n\n#### Expected Results\n<!--- What did you expect to happen when running the steps above? -->\n\n\n##### Actual Results\n<!--- What actually happened? If possible run with extra verbosity -->\n\n<!--- Paste verbatim command output between quotes below -->\n```\n\n```\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.314453125,
          "content": "<h1 align=\"center\"><img src=\"/images/aws.png\" alt=\"AWS\" width=130 height=130></h1>\n\n<h2 align=\"center\">A collection of bash shell scripts for automating various tasks with <a href=\"https://aws.amazon.com/\" target=\"_blank\">Amazon Web Services</a> using the <a href=\"https://aws.amazon.com/cli/\" target=\"_blank\">AWS CLI</a> and <a href=\"https://stedolan.github.io/jq/\" target=\"_blank\">jq</a>.</h2>\n\n[![Build Status](https://travis-ci.org/swoodford/aws.svg?branch=master)](https://travis-ci.org/swoodford/aws)\n\n#### [https://github.com/swoodford/aws](https://github.com/swoodford/aws)\n\n## Table of contents\n\n- [Why](#why)\n- [Getting Started](#getting-started)\n- [What's Included](#tools-included-in-this-repo)\n- [Bugs and Feature Requests](#bugs-and-feature-requests)\n- [Creator](#creator)\n- [Copyright and License](#copyright-and-license)\n  \n\n## Why\n\nWhy does this project exist?  \n\nThis repository is intended to make some of the more difficult DevOps tasks commonly required to maintain complex hosting infrastructure in AWS simple, quick and easy.  This is my attempt to automate and expedite difficult, repetitive, tedious and time consuming processes into a simple shell script that gets the job done as cleanly as possible.  These scripts were developed out of frustration in clicking around on the same things over and over again in the web console every day, week, month when they could easly be done in seconds in a script that uses the AWS CLI.  I've tried to keep everything applicable to as many use cases across regions and across as many different AWS accounts as possible.  I run many of these scripts myself, mostly on a Mac or in Linux and do periodic usability and bug checking, making updates for any changes to the CLI.  I hope this collection of tools helps you too, and if you use these please hit the Star/Fork button and if you have any suggestions please open an Issue or PR!  \n\n\n## Getting Started\n\n### What is the AWS Command Line Interface?\n\nThe AWS CLI is an open source tool built on top of the AWS SDK for Python (Boto) that provides commands for interacting with AWS services.\n\n[Installing the AWS Command Line Interface](https://docs.aws.amazon.com/cli/latest/userguide/installing.html)\n\n**Requirements:**\n* Python 2 version 2.6.5+ or Python 3 version 3.3+\n* macOS, Linux, or Unix\n\nIf you already have pip and a supported version of Python, you can install the AWS CLI with the following command:\n\n`$ pip install awscli --upgrade --user`\n\n[Configuring the AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)\n\nFor general use, the aws configure command is the fastest way to set up your AWS CLI installation.\n\n`$ aws configure`\n\nThe AWS CLI will prompt you for four pieces of information. AWS Access Key ID and AWS Secret Access Key are your account credentials.\n\n[Named Profiles](https://docs.aws.amazon.com/cli/latest/userguide/cli-multiple-profiles.html)\n\nThe AWS CLI supports named profiles stored in the config and credentials files. You can configure additional profiles by using `aws configure` with the `--profile option` or by adding entries to the config and credentials files.\n\n`$ aws configure --profile example`\n\n### What is jq?\n\njq is a lightweight and flexible command-line JSON processor.\n\n[Installing jq](https://stedolan.github.io/jq/download/)\n\nOS X: Use [Homebrew](https://brew.sh/) to install jq:\n\n`$ brew install jq`\n\nLinux: jq is in the official [Amazon Linux AMI](https://aws.amazon.com/amazon-linux-ami/2017.03-packages/#j), [Debian](https://packages.debian.org/jq) and [Ubuntu](http://packages.ubuntu.com/jq) repositories.\n\nAmazon Linux AMI, RHEL, CentOS:\n\n`$ sudo yum install jq`\n\nDebian/Ubuntu:\n\n`$ sudo apt-get install jq`\n\n\n## Tools included in this repo:\n\n![cloudfront](/images/cf.png)\n#### CloudFront\n- **[cloudfront-inprogress-status.sh](cloudfront-inprogress-status.sh)** Checks CloudFront Distributions with In-Progress status to complete and become Deployed\n- **[cloudfront-invalidation-status.sh](cloudfront-invalidation-status.sh)** Checks CloudFront Distributions for cache invalidation status to complete\n\n![cloudwatch](/images/cw.png)\n#### CloudWatch\n- **[cloudwatch-create-alarms.sh](cloudwatch-create-alarms.sh)** Create CloudWatch alarms for EC2, RDS, Load Balancer environments\n- **[cloudwatch-create-alarms-statuscheckfailed.sh](cloudwatch-create-alarms-statuscheckfailed.sh)** Create CloudWatch StatusCheckFailed Alarms with Recovery Action for all running EC2 Instances in all regions available\n- **[cloudwatch-create-alarms-unhealthyhost.sh](cloudwatch-create-alarms-unhealthyhost.sh)** Create CloudWatch UnhealthyHost Alarms for all ALB and ELB Elastic Load Balancers in all regions available\n- **[cloudwatch-logs-cleanup.sh](cloudwatch-logs-cleanup.sh)** Delete all CloudWatch Log Groups with a Last Event that is older than the Retention Policy\n- **[cloudwatch-logs-delete-groups.sh](cloudwatch-logs-delete-groups.sh)** Quickly delete all CloudWatch Log Groups with a specified prefix in all regions available\n- **[cloudwatch-logs-search.sh](cloudwatch-logs-search.sh)** Search CloudWatch Logs for any string across all regions and log groups\n- **[cloudwatch-logs-retention-policy.sh](cloudwatch-logs-retention-policy.sh)** Set CloudWatch Logs Retention Policy for all log groups in all regions available\n\n![ec2](/images/ec2.png)\n#### EC2\n- **[ec2-ami-encrypted-ebs-boot-volume.sh](ec2-ami-encrypted-ebs-boot-volume.sh)** Create an AMI with an encrypted EBS boot volume from the latest Amazon Linux AMI\n- **[ec2-associate-elastic-ip.sh](ec2-associate-elastic-ip.sh)** Reassign a previously allocated Elastic IP to the instance which runs this script\n- **[ec2-classic-import-network-acl.sh](ec2-classic-import-network-acl.sh)** Import CIDR IP list to AWS EC2 Classic ACL rules and deny access\n- **[ec2-ebs-create-snapshots.sh](ec2-ebs-create-snapshots.sh)** Create a snapshot of each EC2 EBS volume that is tagged with the backup flag\n- **[ec2-ebs-delete-snapshots.sh](ec2-ebs-delete-snapshots.sh)** Deletes snapshots for each EC2 EBS volume that is tagged with the backup flag and matches the specified date\n- **[ec2-elb-export-template.sh](ec2-elb-export-template.sh)** Export an ELB to a JSON template file for version control, duplication or recreation\n- **[ec2-elb-upload-ssl-cert.sh](ec2-elb-upload-ssl-cert.sh)** Upload an SSL Certificate to AWS for use in setting up an ELB\n\n![elastic beanstalk](/images/eb.png)\n#### Elastic Beanstalk\n- **[elastic-beanstalk-set-hostname-within-instance.sh](elastic-beanstalk-set-hostname-within-instance.sh)** Set the hostname on Elastic Beanstalk servers from within the instance with their EB environment name and public IP address\n- **[elastic-beanstalk-update-hostnames.sh](elastic-beanstalk-update-hostnames.sh)** Updates the hostname on Elastic Beanstalk servers with their environment name and IP address\n\n![iam](/images/iam.png)\n#### IAM\n- **[iam-create-s3-users.sh](iam-create-s3-users.sh)** Create the S3 IAM user, generate IAM keys, add to IAM group, generate user policy\n\n![route53](/images/route53.png)\n#### Route53\n- **[route53-export-zones.sh](route53-export-zones.sh)** Uses [cli53](https://github.com/barnybug/cli53) to export the zone file for each Hosted Zone domain in Route 53\n\n![s3](/images/s3.png)\n#### S3\n- **[s3-buckets-local-backup.sh](s3-buckets-local-backup.sh)** Backup all contents of all S3 buckets in AWS account locally\n- **[s3-buckets-security-audit.sh](s3-buckets-security-audit.sh)** Export S3 bucket ACL, CORS, Policy and Website as JSON for auditing security of all buckets\n- **[s3-buckets-total-file-size.sh](s3-buckets-file-size-s3api.sh)** Count total size of all data stored in all S3 buckets using [s3api](https://docs.aws.amazon.com/cli/latest/reference/s3api/index.html)\n- **[s3-fix-content-type-metadata.sh](s3-fix-content-type-metadata.sh)** Safely fix invalid content-type metadata on AWS S3 bucket website assets for some common filetypes\n- **[s3-open-bucket-policy.sh](s3-open-bucket-policy.sh)** Set an S3 bucket policy to allow GetObject requests from any IP address (publicly accessible website)\n- **[s3-remove-glacier-objects.sh](s3-remove-glacier-objects.sh)** Delete all Glacier storage type objects in a single S3 bucket\n- **[s3-restrict-bucket-policy.sh](s3-restrict-bucket-policy.sh)** Set an S3 bucket policy to only allow GetObject requests from an IP whitelist file named iplist\n- **[s3-set-cache-control-max-age.sh](s3-set-cache-control-max-age.sh)** Set Cache-Control max-age value on AWS S3 bucket website assets for all filetypes\n- **[s3-setup-buckets.sh](s3-setup-buckets.sh)** Create S3 buckets, set CORS config and tag bucket with client name\n\n![vpc](/images/vpc.png)\n#### VPC\n- **[vpc-eni-monitor.sh](vpc-eni-monitor.sh)** Generate an HTML page to monitor the number of AWS VPC Elastic Network Interfaces currently in use and upload it to an S3 bucket website\n- **[vpc-sg-import-rules.sh](vpc-sg-import-rules.sh)** Create an AWS VPC Security Group with rules to allow access to each IP at the port specified\n- **[vpc-sg-import-rules-cloudflare.sh](vpc-sg-import-rules-cloudflare.sh)** Create VPC Security Group with [Cloudflare](https://www.cloudflare.com/) IP ranges\n- **[vpc-sg-import-rules-cloudfront.sh](vpc-sg-import-rules-cloudfront.sh)** Create VPC Security Group with CloudFront IP ranges\n- **[vpc-sg-import-rules-pingdom.sh](vpc-sg-import-rules-pingdom.sh)** Create or Update VPC Security Groups with [Pingdom](https://www.pingdom.com/) probe server IP ranges\n- **[vpc-sg-merge-groups.sh](vpc-sg-merge-groups.sh)** Merge two existing VPC Security Groups together into one single group\n- **[vpc-sg-rename-group.sh](vpc-sg-rename-group.sh)** Rename an existing VPC Security Group by creating an identical new group\n\n![waf](/images/waf.png)\n#### WAF\n- **[waf-export-ip-sets.sh](waf-export-ip-sets.sh)** Export each AWS WAF IP set match condition to a JSON file for backup\n- **[waf-import-ip-set-facebook.sh](waf-import-ip-set-facebook.sh)** Import list of current [Facebook](https://www.facebook.com/) crawl server IPs into AWS WAF IP Set - work in progress, currently not possible to execute\n- **[waf-web-acl-pingdom.sh](waf-web-acl-pingdom.sh)** Manage WAF Web ACL to allow current [Pingdom](https://www.pingdom.com/) probe server IPs by creating or updating AWS WAF IP Addresses Set, Rules and Web ACLs\n\n![other tools](/images/gears.png)\n#### Other Tools\n- **[convert-iplist-cidr-json-array.sh](convert-iplist-cidr-json-array.sh)** Converts an IPv4 iplist to CIDR block notation and JSON array format, sorting and de-duplicating IPs\n- **[install-awscli.sh](install-awscli.sh)** Install and configure AWS CLI\n- **[install-s3cmd.sh](install-s3cmd.sh)** Install and setup [s3cmd](https://github.com/s3tools/s3cmd) from the GitHub Repo\n- **[terraform-redact-iam-secrets.sh](terraform-redact-iam-secrets.sh)** Replaces AWS IAM Secret Keys and IAM SES SMTP Passwords with \"REDACTED\" in [Terraform](https://www.terraform.io/) state files\n\n## Bugs and feature requests\nHave a bug or a feature request? The [issue tracker](https://github.com/swoodford/aws/issues) is the preferred channel for bug reports, feature requests and submitting pull requests.\nIf your problem or idea is not addressed yet, [please open a new issue](https://github.com/swoodford/aws/issues/new).\n\n## Creator\n\n**Shawn Woodford**\n\n- <https://shawnwoodford.com>\n- <https://github.com/swoodford>\n\n## Copyright and License\n\nCode and Documentation Copyright 2012-2018 Shawn Woodford. Code released under the [Apache License 2.0](https://github.com/swoodford/aws/blob/master/LICENSE.md).\n"
        },
        {
          "name": "cloudfront-inprogress-status.sh",
          "type": "blob",
          "size": 3.2958984375,
          "content": "#!/usr/bin/env bash\n\n# This script monitors CloudFront distributions for In-Progress Status and alerts when it has completed and is Deployed\n# Requires the AWS CLI and jq\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check for Distributions\nfunction distributionsCheck(){\n\tdistributions=$(aws cloudfront list-distributions --profile $profile 2>&1 | jq '.DistributionList | .Items | .[] | .ARN')\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"$distributions\"\n\tfi\n\tif echo \"$distributions\" | egrep -iq \"error|not|false\"; then\n\t\techo \"$distributions\"\n\t\tfail \"No CloudFront distributions found.\"\n\tfi\n}\n\n# List In-Progress\nfunction listInProgress(){\n\n\tHorizontalRule\n\techo \"Checking for In-Progress Status...\"\n\tHorizontalRule\n\n\tinprogress=$(aws cloudfront list-distributions --profile $profile 2>&1 | jq '.DistributionList | .Items | .[] | select(.Status == \"InProgress\") | .Id' | cut -d \\\" -f2)\n\tname=$(aws cloudfront list-distributions --profile $profile 2>&1 | jq '.DistributionList | .Items | .[] | select(.Status == \"InProgress\") | .Origins | .Items | .[] | .Id' | cut -d \\\" -f2)\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo inprogress \"$inprogress\"\n\tfi\n\n\tif ! [ -z \"$inprogress\" ]; then\n\t\tHorizontalRule\n\t\techo \"Distributions In-Progress: $inprogress\"\n\t\techo \"$name\"\n\t\tHorizontalRule\n\tfi\n}\n\n# Check the status\nfunction checkStatus(){\n\tif [ -z \"$inprogress\" ]; then\n\t\techo No CloudFront Distributions with In-Progress Status.\n\t\tHorizontalRule\n\t\treturn 1\n\telse\n\t\tstatus=$(aws cloudfront get-distribution --id $inprogress --profile $profile 2>&1 | jq '.Distribution | .Status' | cut -d \\\" -f2)\n\n\t\twhile [ $status = \"InProgress\" ]; do\n\t\t\tHorizontalRule\n\t\t\techo \"Status:\" $status\n\t\t\techo \"Waiting for Deployed Status...\"\n\t\t\tHorizontalRule\n\t\t\tsleep 30\n\t\t\tcheckStatus\n\t\tdone\n\n\t\tif [ \"$(uname)\" == \"Darwin\" ]; then\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo MACOS\n\t\t\tfi\n\t\t\tosascript -e 'tell app \"Terminal\" to display dialog \" CloudFront Distribution ID: '$inprogress' Status: '$status'\"'\n\t\telif [ \"$(expr substr $(uname -s) 1 5)\" == \"Linux\" ]; then\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\tLINUX\n\t\t\tfi\n\t\t\techo \"CloudFront Distribution $status\"\n\t\t\tcompleted\n\t\tfi\n\tfi\n}\n\ncheck_command \"jq\"\n\ndistributionsCheck\nlistInProgress\ncheckStatus\n"
        },
        {
          "name": "cloudfront-invalidation-status.sh",
          "type": "blob",
          "size": 4.5703125,
          "content": "#!/usr/bin/env bash\n\n# This script monitors CloudFront distributions for cache invalidation status and alerts when it has completed\n# Requires the AWS CLI and jq\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check for Distributions\nfunction distributionsCheck(){\n\tdistributions=$(aws cloudfront list-distributions --profile $profile 2>&1 | jq '.DistributionList | .Items | .[] | .ARN')\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"$distributions\"\n\tfi\n\tif echo \"$distributions\" | egrep -iq \"error|not|false\"; then\n\t\techo \"$distributions\"\n\t\tfail \"No CloudFront distributions found.\"\n\tfi\n}\n\n# List Distributions\nfunction listDistributions(){\n\tdistributions=$(aws cloudfront list-distributions --profile $profile 2>&1 | jq '.DistributionList | .Items | .[] | .Id' | cut -d \\\" -f2)\n\tnames=$(aws cloudfront list-distributions --profile $profile 2>&1 | jq '.DistributionList | .Items | .[] | .Origins | .Items | .[] | .Id' | cut -d \\\" -f2)\n\n\tif [ -z \"$distributions\" ]; then\n\t\techo \"$distributions\"\n\t\tfail \"No CloudFront distributions found.\"\n\telse\n\t\tHorizontalRule\n\t\techo Found CloudFront Distributions:\n\t\tHorizontalRule\n\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug distribution IDs:\"\n\t\t\techo \"$distributions\"\n\t\tfi\n\t\techo \"$names\"\n\t\techo\n\tfi\n\tTOTALDISTRIBUTIONS=$(echo \"$distributions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"$TOTALDISTRIBUTIONS\"\n\tfi\n}\n\n# List Invalidations\nfunction listInvalidations(){\n\t# while IFS= read -r distributionid\n\t# do\n\tHorizontalRule\n\techo \"Checking for Invalidations In Progress...\"\n\tHorizontalRule\n\n\tSTART=1\n\tfor (( COUNT=$START; COUNT<=$TOTALDISTRIBUTIONS; COUNT++ ))\n\tdo\n\t\tdistributionid=$(echo \"$distributions\" | nl | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug distribution ID: $distributionid\"\n\t\tfi\n\t\tinvalidations=$(aws cloudfront list-invalidations --distribution-id $distributionid --profile $profile 2>&1 | jq '.InvalidationList | .Items | .[] | select(.Status != \"Completed\") | .Id' | cut -d \\\" -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo invalidations \"$invalidations\"\n\t\tfi\n\n\t\tif ! [ -z \"$invalidations\" ]; then\n\t\t\tHorizontalRule\n\t\t\techo \"Invalidation in progress: $invalidations\"\n\t\t\tHorizontalRule\n\t\tfi\n\tdone\n\n\t# done <<< \"$distributions\"\n}\n\n# Check the Invalidation Status\nfunction checkInvalidationstatus(){\n\tif [ -z \"$invalidations\" ]; then\n\t\techo No CloudFront Invalidations In Progress.\n\t\tHorizontalRule\n\t\treturn 1\n\telse\n\t\twhile IFS= read -r invalidationid\n\t\tdo\n\t\t\techo Invalidation ID: $invalidationid\n\t\t\tinvalidationStatus=$(aws cloudfront get-invalidation --distribution-id $distributionid --id $invalidationid --profile $profile 2>&1 | jq '.Invalidation | .Status' | cut -d \\\" -f2)\n\n\t\t\twhile [ $invalidationStatus = \"InProgress\" ]; do\n\t\t\t\tHorizontalRule\n\t\t\t\techo \"Invalidation Status:\" $invalidationStatus\n\t\t\t\techo \"Waiting for invalidation to complete...\"\n\t\t\t\tHorizontalRule\n\t\t\t\tsleep 30\n\t\t\t\tcheckInvalidationstatus\n\t\t\tdone\n\n\t\t\tif [ \"$(uname)\" == \"Darwin\" ]; then\n\t\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\t\techo MACOS\n\t\t\t\tfi\n\t\t\t\tosascript -e 'tell app \"Terminal\" to display dialog \" CloudFront Invalidation ID: '$invalidationid' Status: '$invalidationStatus'\"'\n\t\t\telif [ \"$(expr substr $(uname -s) 1 5)\" == \"Linux\" ]; then\n\t\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\t\tLINUX\n\t\t\t\tfi\n\t\t\t\techo \"CloudFront Invalidation $invalidationStatus\"\n\t\t\t\tcompleted\n\t\t\tfi\n\t\tdone <<< \"$invalidations\"\n\tfi\n}\n\ncheck_command \"jq\"\ndistributionsCheck\nlistDistributions\nlistInvalidations\ncheckInvalidationstatus\n"
        },
        {
          "name": "cloudwatch-create-alarms-statuscheckfailed.sh",
          "type": "blob",
          "size": 7.3330078125,
          "content": "#!/usr/bin/env bash\n\n# This script will set CloudWatch StatusCheckFailed Alarms with Recovery Action for all running EC2 Instances in all regions available\n# https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html#AddingRecoverActions\n\n# Requires the AWS CLI and jq and you must setup your ALARMACTION\n\n# Set Variables\n\n# ALARMACTION=\"arn:aws:sns:us-east-1:YOURACCOUNTNUMBER:YOURSNSALERTNAME\"\n\n# Optionally limit to a single AWS Region\nRegion=\"x\"\n\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# ToDo: in order to use an SNS Topic it must be within the same region as the instance\n\n# # Verify ALARMACTION is setup with some alert mechanism\n# if [[ -z $ALARMACTION ]] || [[ \"$ALARMACTION\" == \"arn:aws:sns:us-east-1:YOURACCOUNTNUMBER:YOURSNSALERTNAME\" ]]; then\n# \tSNSTopics=$(aws sns list-topics --profile $profile 2>&1)\n# \tif [ ! $? -eq 0 ]; then\n# \t\tfail \"$SNSTopics\"\n# \tfi\n# \tTopicArns=$(echo \"$SNSTopics\" | jq '.Topics | .[] | .TopicArn' | cut -d \\\" -f2)\n# \tif [ ! $? -eq 0 ]; then\n# \t\tfail \"$TopicArns\"\n# \tfi\n# \techo \"Specify Action for CloudWatch Alarm\"\n# \techo \"SNS Topics Found:\"\n# \tHorizontalRule\n# \techo \"$TopicArns\"\n# \tHorizontalRule\n# \techo\n# \tread -r -p \"ARN: \" ALARMACTION\n# \tif [[ -z $ALARMACTION ]]; then\n# \t\tfail \"Alarm Action must be configured.\"\n# \tfi\n# fi\n\nif [[ \"$Region\" == \"x\" ]]; then\n\techo\n\tHorizontalRule\n\tread -r -p \"Enter a single region name or press return for all regions: \" Region\n\tHorizontalRule\n\techo\nfi\n\n\n# Get list of all regions (using EC2)\nfunction GetRegions(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin GetRegions Function\"\n\tfi\n\tAWSregions=$(aws ec2 describe-regions --output=json --profile $profile 2>&1)\n\tif echo \"$AWSregions\" | egrep -iq \"error|not\"; then\n\t\tfail \"$AWSregions\"\n\telse\n\t\tParseRegions=$(echo \"$AWSregions\" | jq '.Regions | .[] | .RegionName'| cut -d \\\" -f2 | sort)\n\tfi\n\tTotalRegions=$(echo \"$ParseRegions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Regions:\"\n\t\t# echo \"$AWSregions\"\n\t\techo \"$ParseRegions\"\n\t\techo \"TotalRegions: $TotalRegions\"\n\t\tpause\n\tfi\n}\n\n# Get list of all EC2 Instance IDs in all regions\nfunction InstancesInRegion(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin InstancesInRegion Function\"\n\tfi\n\tInstancesInRegionStart=1\n\tfor (( InstancesInRegionCount=$InstancesInRegionStart; InstancesInRegionCount<=$TotalRegions; InstancesInRegionCount++ ))\n\tdo\n\t\tRegion=$(echo \"$ParseRegions\" | nl | grep -w [^0-9][[:space:]]$InstancesInRegionCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug Region: $Region\"\n\t\tfi\n\t\tHorizontalRule\n\t\tListInstances\n\t\techo\n\tdone\n}\n\n# Get list of all EC2 Instances in one region\nfunction ListInstances(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListInstances Function\"\n\tfi\n\tInstances=$(aws ec2 describe-instances --filters Name=instance-state-name,Values=running --region $Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$Instances\"\n\telse\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo Instances: \"$Instances\"\n\t\tfi\n\t\tParseInstances=$(echo \"$Instances\" | jq '.Reservations | .[] | .Instances | .[] | .InstanceId' | cut -d \\\" -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ParseInstances: \"$ParseInstances\"\n\t\tfi\n\tfi\n\tif [ -z \"$ParseInstances\" ]; then\n\t\techo \"No Instances found in $Region.\"\n\telse\n\t\tHorizontalRule\n\t\techo \"Setting Alarms for Region: $Region\"\n\t\tSetAlarms\n\tfi\n}\n\nfunction SetAlarms(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin SetAlarms Function\"\n\tfi\n\tTotalInstancess=$(echo \"$ParseInstances\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Region: $Region\"\n\t\techo \"TotalInstancess: $TotalInstancess\"\n\t\tpause\n\tfi\n\tStart=1\n\tfor (( Count=$Start; Count<=$TotalInstancess; Count++ ))\n\tdo\n\t\tInstanceID=$(echo \"$ParseInstances\" | nl | grep -w [^0-9][[:space:]]$Count | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Count: $Count\"\n\t\t\techo \"Instance: $InstanceID\"\n\t\t\tpause\n\t\tfi\n\t\tInstanceNameTag=$(aws ec2 describe-tags --filters Name=key,Values=Name Name=resource-id,Values=\"$InstanceID\" --region $Region --output=json --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$InstanceNameTag\"\n\t\tfi\n\t\tif [ -z \"$InstanceNameTag\" ]; then\n\t\t\techo \"No InstanceName.\"\n\t\tfi\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"InstanceNameTag: $InstanceNameTag\"\n\t\tfi\n\t\tInstanceName=$(echo \"$InstanceNameTag\" | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$InstanceName\"\n\t\tfi\n\t\tif [ -z \"$InstanceName\" ]; then\n\t\t\techo \"No InstanceName.\"\n\t\tfi\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Instance Name: $InstanceName\"\n\t\techo \"Setting CloudWatch Alarm\"\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ALARMACTION=\"arn:aws:automate:$Region:ec2:recover\"\n\t\tfi\n\t\tALARMACTION=\"arn:aws:automate:$Region:ec2:recover\"\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo aws cloudwatch put-metric-alarm --alarm-name \"$InstanceName - Status Check Failed - $InstanceID\" --metric-name StatusCheckFailed --namespace AWS/EC2 --statistic Maximum --dimensions Name=InstanceId,Value=\"$InstanceID\" --unit Count --period 300 --evaluation-periods 1 --threshold 1 --comparison-operator GreaterThanOrEqualToThreshold --alarm-actions \\'\"$ALARMACTION\"\\' --output=json --profile $profile --region $Region 2>&1\n\t\tfi\n\t\tSetAlarm=$(aws cloudwatch put-metric-alarm --alarm-name \"$InstanceName - Status Check Failed - $InstanceID\" --metric-name StatusCheckFailed --namespace AWS/EC2 --statistic Maximum --dimensions Name=InstanceId,Value=\"$InstanceID\" --unit Count --period 300 --evaluation-periods 1 --threshold 1 --comparison-operator GreaterThanOrEqualToThreshold --alarm-actions \"$ALARMACTION\" --output=json --profile $profile --region $Region 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$SetAlarm\"\n\t\tfi\n\t\tVerifyAlarm=$(aws cloudwatch describe-alarms --alarm-names \"$InstanceName - Status Check Failed - $InstanceID\" --output=json --profile $profile --region $Region 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$VerifyAlarm\"\n\t\tfi\n\t\tAlarmName=$(echo \"$VerifyAlarm\" | jq '.MetricAlarms | .[] | .AlarmName')\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$AlarmName\"\n\t\tfi\n\t\techo \"Alarm set: $AlarmName\"\n\tdone\n}\n\n\nif [ -z \"$Region\" ]; then\n\tGetRegions\n\tInstancesInRegion\nelse\n\tListInstances\nfi\n\ncompleted\n"
        },
        {
          "name": "cloudwatch-create-alarms-unhealthyhost.sh",
          "type": "blob",
          "size": 8.703125,
          "content": "#!/usr/bin/env bash\n\n# This script will set CloudWatch UnhealthyHost Alarms for all ELBs in all regions available\n# https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html#AddingRecoverActions\n\n# Requires the AWS CLI and jq and you must setup your ALARMACTION\n\n# Set Variables\n\n# Optionally limit to a single AWS Region\nRegion=\"x\"\n\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\nif [[ \"$Region\" == \"x\" ]]; then\n\techo\n\tHorizontalRule\n\tread -r -p \"Enter a single region name or press return for all regions: \" Region\n\tHorizontalRule\n\techo\nfi\n\n\n# Get list of all regions (using EC2)\nfunction GetRegions(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin GetRegions Function\"\n\tfi\n\tAWSregions=$(aws ec2 describe-regions --output=json --profile $profile 2>&1)\n\tif echo \"$AWSregions\" | egrep -iq \"error|not\"; then\n\t\tfail \"$AWSregions\"\n\telse\n\t\tParseRegions=$(echo \"$AWSregions\" | jq '.Regions | .[] | .RegionName'| cut -d \\\" -f2 | sort)\n\tfi\n\tTotalRegions=$(echo \"$ParseRegions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Regions:\"\n\t\t# echo \"$AWSregions\"\n\t\techo \"$ParseRegions\"\n\t\techo \"TotalRegions: $TotalRegions\"\n\t\tpause\n\tfi\n}\n\n# Get list of all ELB and ALB names in all regions\nfunction LBsInRegion(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin LBsInRegion Function\"\n\tfi\n\tLBsInRegionStart=1\n\tfor (( LBsInRegionCount=$LBsInRegionStart; LBsInRegionCount<=$TotalRegions; LBsInRegionCount++ ))\n\tdo\n\t\tRegion=$(echo \"$ParseRegions\" | nl | grep -w [^0-9][[:space:]]$LBsInRegionCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug Region: $Region\"\n\t\tfi\n\t\tHorizontalRule\n\t\tListELBs\n\t\tListALBs\n\t\tSetAlarms\n\t\techo\n\tdone\n}\n\n# Get list of all Classic EC2 ELBs in one region\nfunction ListELBs(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListELBs Function\"\n\tfi\n\tELBs=$(aws elb describe-load-balancers --region $Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ELBs\"\n\telse\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ELBs: \"$ELBs\"\n\t\tfi\n\t\tParseELBs=$(echo \"$ELBs\" | jq '.LoadBalancerDescriptions | .[] | .LoadBalancerName' | cut -d \\\" -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ParseELBs: \"$ParseELBs\"\n\t\tfi\n\tfi\n\tif [ -z \"$ParseELBs\" ]; then\n\t\techo \"No ELBs found in $Region.\"\n\t\tTotalELBs=\"0\"\n\telse\n\t\tTotalELBs=$(echo \"$ParseELBs\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tfi\n}\n\n# Get list of all ALBs in one region\nfunction ListALBs(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListALBs Function\"\n\tfi\n\tALBs=$(aws elbv2 describe-load-balancers --region $Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ALBs\"\n\telse\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ALBs: \"$ALBs\"\n\t\tfi\n\t\tParseALBs=$(echo \"$ALBs\" | jq '.LoadBalancers | .[] | .LoadBalancerName' | cut -d \\\" -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ParseALBs: \"$ParseALBs\"\n\t\tfi\n\tfi\n\tif [ -z \"$ParseALBs\" ]; then\n\t\techo \"No ALBs found in $Region.\"\n\t\tTotalALBs=\"0\"\n\telse\n\t\tTotalALBs=$(echo \"$ParseALBs\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tfi\n}\n\nfunction ListSNSTopics(){\n\tSNSTopics=$(aws sns list-topics --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SNSTopics\"\n\tfi\n\tTopicArns=$(echo \"$SNSTopics\" | jq '.Topics | .[] | .TopicArn' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TopicArns\"\n\tfi\n\techo \"SNS Topics Found in Region $Region\"\n\techo \"Specify Action for CloudWatch Alarm:\"\n\tHorizontalRule\n\techo \"$TopicArns\"\n\tHorizontalRule\n\techo\n\tread -r -p \"ARN: \" ALARMACTION\n\tif [[ -z $ALARMACTION ]]; then\n\t\tfail \"Alarm Action must be configured.\"\n\tfi\n}\n\nfunction SetAlarms(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin SetAlarms Function\"\n\tfi\n\tif [ \"$TotalELBs\" -gt \"0\" ] || [ \"$TotalALBs\" -gt \"0\" ]; then\n\t\tHorizontalRule\n\t\techo \"Setting Alarms for Region: $Region\"\n\t\tHorizontalRule\n\t\techo\n\t\tListSNSTopics\n\telse\n\t\treturn\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Region: $Region\"\n\t\techo \"TotalELBs: $TotalELBs\"\n\t\techo \"TotalALBs: $TotalALBs\"\n\t\tpause\n\tfi\n\tif [ \"$TotalELBs\" -gt \"0\" ]; then\n\t\tELBStart=1\n\t\tfor (( ELBCount=$ELBStart; ELBCount<=$TotalELBs; ELBCount++ ))\n\t\tdo\n\t\t\tELBName=$(echo \"$ParseELBs\" | nl | grep -w [^0-9][[:space:]]$ELBCount | cut -f2)\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"Count: $ELBCount\"\n\t\t\t\techo \"ELB: $ELBName\"\n\t\t\t\tpause\n\t\t\tfi\n\t\t\techo\n\t\t\tHorizontalRule\n\t\t\techo \"ELB Name: $ELBName\"\n\t\t\techo \"Setting CloudWatch Alarm\"\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"$ALARMACTION\"\n\t\t\t\techo aws cloudwatch put-metric-alarm --alarm-name \"$ELBName - ELB Unhealthy Hosts\" --metric-name UnHealthyHostCount --namespace AWS/ELB --statistic Maximum --dimensions Name=LoadBalancerName,Value=\"$ELBName\" --unit Count --period 300 --evaluation-periods 1 --threshold 0 --comparison-operator GreaterThanThreshold --alarm-actions \\'\"$ALARMACTION\"\\' --output=json --profile $profile --region $Region 2>&1\n\t\t\tfi\n\t\t\tSetAlarm=$(aws cloudwatch put-metric-alarm --alarm-name \"$ELBName - ELB Unhealthy Hosts\" --metric-name UnHealthyHostCount --namespace AWS/ELB --statistic Maximum --dimensions Name=LoadBalancerName,Value=\"$ELBName\" --unit Count --period 300 --evaluation-periods 1 --threshold 0 --comparison-operator GreaterThanThreshold --alarm-actions \"$ALARMACTION\" --output=json --profile $profile --region $Region 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$SetAlarm\"\n\t\t\tfi\n\t\t\tVerifyAlarm=$(aws cloudwatch describe-alarms --alarm-names \"$ELBName - ELB Unhealthy Hosts\" --output=json --profile $profile --region $Region 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VerifyAlarm\"\n\t\t\tfi\n\t\t\tAlarmName=$(echo \"$VerifyAlarm\" | jq '.MetricAlarms | .[] | .AlarmName')\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$AlarmName\"\n\t\t\tfi\n\t\t\techo \"Alarm set: $AlarmName\"\n\t\tdone\n\tfi\n\tif [ \"$TotalALBs\" -gt \"0\" ]; then\n\t\tALBStart=1\n\t\tfor (( ALBCount=$ALBStart; ALBCount<=$TotalALBs; ALBCount++ ))\n\t\tdo\n\t\t\tALBName=$(echo \"$ParseALBs\" | nl | grep -w [^0-9][[:space:]]$ALBCount | cut -f2)\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"Count: $ALBCount\"\n\t\t\t\techo \"ALB: $ALBName\"\n\t\t\t\tpause\n\t\t\tfi\n\t\t\techo\n\t\t\tHorizontalRule\n\t\t\techo \"ALB Name: $ALBName\"\n\t\t\techo \"Setting CloudWatch Alarm\"\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"$ALARMACTION\"\n\t\t\t\techo aws cloudwatch put-metric-alarm --alarm-name \"$ALBName - ALB Unhealthy Hosts\" --metric-name UnHealthyHostCount --namespace AWS/ApplicationELB --statistic Maximum --dimensions Name=LoadBalancerName,Value=\"$ALBName\" --unit Count --period 300 --evaluation-periods 1 --threshold 0 --comparison-operator GreaterThanThreshold --alarm-actions \\'\"$ALARMACTION\"\\' --output=json --profile $profile --region $Region 2>&1\n\t\t\tfi\n\t\t\tSetAlarm=$(aws cloudwatch put-metric-alarm --alarm-name \"$ALBName - ALB Unhealthy Hosts\" --metric-name UnHealthyHostCount --namespace AWS/ApplicationELB --statistic Maximum --dimensions Name=LoadBalancerName,Value=\"$ALBName\" --unit Count --period 300 --evaluation-periods 1 --threshold 0 --comparison-operator GreaterThanThreshold --alarm-actions \"$ALARMACTION\" --output=json --profile $profile --region $Region 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$SetAlarm\"\n\t\t\tfi\n\t\t\tVerifyAlarm=$(aws cloudwatch describe-alarms --alarm-names \"$ALBName - ALB Unhealthy Hosts\" --output=json --profile $profile --region $Region 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VerifyAlarm\"\n\t\t\tfi\n\t\t\tAlarmName=$(echo \"$VerifyAlarm\" | jq '.MetricAlarms | .[] | .AlarmName')\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$AlarmName\"\n\t\t\tfi\n\t\t\techo \"Alarm set: $AlarmName\"\n\t\tdone\n\tfi\n}\n\n\nif [ -z \"$Region\" ]; then\n\tGetRegions\n\tLBsInRegion\nelse\n\tListELBs\n\tListALBs\n\tif [ \"$TotalELBs\" -gt \"0\" ] || [ \"$TotalALBs\" -gt \"0\" ]; then\n\t\tSetAlarms\n\tfi\nfi\n\ncompleted\n"
        },
        {
          "name": "cloudwatch-create-alarms.sh",
          "type": "blob",
          "size": 8.3837890625,
          "content": "#!/usr/bin/env bash\n# This script creates AWS CloudWatch alarms based on standard metrics and user input to setup alarms for each environment\n# Requires AWS CLI Setup and you must setup your ALARMACTION\n\nALARMACTION=\"arn:aws:sns:us-east-1:YOURACCOUNTNUMBER:YOURSNSALERTNAME\"\n\n# Functions\n\n# Check Command\nfunction check_command {\n  type -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n  echo\n  HorizontalRule\n  tput setaf 2; echo \"Completed!\" && tput sgr0\n  HorizontalRule\n  echo\n}\n\n# Fail\nfunction fail(){\n  tput setaf 1; echo \"Failure: $*\" && tput sgr0\n  exit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n  echo \"============================================================\"\n}\n\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    fail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n  fi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n  scriptname=`basename \"$0\"`\n  echo \"Usage: ./$scriptname profile\"\n  echo \"Where profile is the AWS CLI profile name\"\n  echo \"Using default profile\"\n  echo\n  profile=default\nelse\n  profile=$1\nfi\n\n# Verify ALARMACTION is setup with some alert mechanism\nif [[ -z $ALARMACTION ]] || [[ \"$ALARMACTION\" == \"arn:aws:sns:us-east-1:YOURACCOUNTNUMBER:YOURSNSALERTNAME\" ]]; then\n  echo \"Alarm Action SNS Topic ARN?\"\n  echo \"Example: arn:aws:sns:us-east-1:YOURACCOUNTNUMBER:YOURSNSALERTNAME\"\n  read -r ALARMACTION\n  if [[ -z $ALARMACTION ]]; then\n    fail \"Alarm Action must be configured.\"\n  fi\nfi\n\nHorizontalRule\necho \"Create CloudWatch Alarms\"\nHorizontalRule\necho\n\nread -r -p \"Client Name? \" CLIENT\nif [[ -z $CLIENT ]]; then\n  fail \"Invalid Client Name!\"\nfi\nHorizontalRule\nread -r -p \"How Many Servers Total? \" SERVERNUM\nif [[ $SERVERNUM > 0 ]] && echo \"$SERVERNUM\" | egrep -q '^[0-9]+$'; then\n  read -r -p \"Loadbalanced Environment? (y/n) \" LOADBALANCED\n\n  # If Loadbalanced Environment\n  if [[ $LOADBALANCED =~ ^([yY][eE][sS]|[yY])$ ]]; then\n    read -r -p \"Load Balancer ID? \" LBID\n    if [[ -z $LBID ]]; then\n      fail \"Invalid Load Balancer ID!\"\n    fi\n\n    # Load Balancer Unhealthy Host Check\n    aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT Unhealthy Host Check\" --alarm-description \"$CLIENT Load Balancer Unhealthy Host Detected\" --metric-name \"UnHealthyHostCount\" --namespace \"AWS/ELB\" --statistic \"Sum\" --period 60 --threshold 0 --comparison-operator \"GreaterThanThreshold\" --dimensions Name=LoadBalancerName,Value=$LBID --evaluation-periods 3 --alarm-actions \"$ALARMACTION\" --profile $profile\n    HorizontalRule\n    echo \"Load Balancer Unhealthy Host Alarm Set\"\n    HorizontalRule\n    # Load Balancer High Latency Check\n    aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT LB High Latency\" --alarm-description \"$CLIENT Load Balancer High Latency\" --metric-name \"Latency\" --namespace \"AWS/ELB\" --statistic \"Average\" --period 60 --threshold 15 --comparison-operator \"GreaterThanThreshold\" --dimensions Name=LoadBalancerName,Value=$LBID --evaluation-periods 2 --alarm-actions \"$ALARMACTION\" --profile $profile\n    HorizontalRule\n    echo \"Load Balancer High Latency Alarm Set\"\n    HorizontalRule\n  fi\n\n  # Begin loop to create server alarms\n  START=1\n  for (( COUNT=$START; COUNT<=$SERVERNUM; COUNT++ )) do\n    echo \"Server #\"$COUNT\n    read -r -p \"Server Environment? (Dev/Staging/Production) \" ENVIRONMENT\n    if [[ -z $ENVIRONMENT ]]; then\n      fail \"Invalid Server Environment!\"\n    fi\n    read -r -p \"Server Name? (Web01, Web02) \" SERVERNAME\n    # Avoid \"Dev Dev\" situation\n    if [[ \"$ENVIRONMENT\" == \"$SERVERNAME\" ]]; then\n      SERVERNAME=\"\"\n    fi\n    read -r -p \"Instance ID? (i-xxxxxxxx or i-xxxxxxxxxxxxxxxxx) \" INSTANCEID\n    if [[ \"$INSTANCEID\" =~ ^([i]-........)|([i]-.................)$ ]]; then\n\n        # CPU Check\n        aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT $ENVIRONMENT $SERVERNAME CPU Check\" --alarm-description \"$CLIENT $ENVIRONMENT $SERVERNAME CPU usage >90% for 5 minutes\" --namespace \"AWS/EC2\" --dimensions Name=InstanceId,Value=$INSTANCEID --metric-name \"CPUUtilization\" --statistic \"Average\" --comparison-operator \"GreaterThanThreshold\" --unit \"Percent\" --period 60 --threshold 90 --evaluation-periods 5 --alarm-actions \"$ALARMACTION\" --profile $profile\n        HorizontalRule\n        echo $CLIENT $ENVIRONMENT $SERVERNAME \"CPU Check Alarm Set\"\n        HorizontalRule\n\n        # Status Check\n        aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT $ENVIRONMENT $SERVERNAME Status Check\" --alarm-description \"$CLIENT $ENVIRONMENT $SERVERNAME Status Check Failed for 5 minutes\" --namespace \"AWS/EC2\" --dimensions Name=InstanceId,Value=$INSTANCEID --metric-name \"StatusCheckFailed\" --statistic \"Maximum\" --comparison-operator \"GreaterThanThreshold\" --unit \"Count\" --period 60 --threshold 0 --evaluation-periods 5 --alarm-actions \"$ALARMACTION\" --profile $profile\n        HorizontalRule\n        echo $CLIENT $ENVIRONMENT $SERVERNAME \"Status Check Alarm Set\"\n        HorizontalRule\n    else\n      fail \"Invalid Instance ID!\"\n    fi\n  done\nelse\n  if [[ $SERVERNUM == 0 ]]; then\n    echo \"Skipping Server Alarms...\"\n  else\n    tput setaf 1; echo \"Invalid Number of Servers!\" && tput sgr0\n  fi\nfi\n\nread -r -p \"Setup Database Alarms? (y/n) \" SETUPDB\n  # If Database Alarms\n  if [[ $SETUPDB =~ ^([yY][eE][sS]|[yY])$ ]]; then\n    HorizontalRule\n    read -r -p \"How Many Database Hosts Total? \" DBNUM\n    if [[ $DBNUM > 0 ]] && echo \"$DBNUM\" | egrep '^[0-9]+$' >/dev/null 2>&1; then\n\n    # Begin loop to create database alarms\n      START=1\n      for (( COUNT=$START; COUNT<=$DBNUM; COUNT++ )) do\n        echo \"DB #\"$COUNT\n        read -r -p \"Database Environment? (Dev/Staging/Production) \" ENVIRONMENT\n        if [[ -z $ENVIRONMENT ]]; then\n          fail \"Invalid Database Environment!\"\n        fi\n        # # Avoid \"Beta Beta\" situation\n        # if [[ $ENVIRONMENT == \"Beta\" ]]; then\n        #   SERVERNAME=\"\"\n        # else\n        #   echo -n \"DB Name? (Web01, Web02) \"\n        #   read SERVERNAME\n        # fi\n        read -r -p \"DB Instance ID? \" DBID\n        if [[ -z $DBID ]]; then\n          fail \"Invalid Database Instance ID!\"\n        fi\n\n        # Database CPU Check\n        aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT $ENVIRONMENT DB CPU Check\" --alarm-description \"$CLIENT $ENVIRONMENT Database CPU usage >90% for 5 minutes\" --metric-name \"CPUUtilization\" --namespace \"AWS/RDS\" --statistic \"Average\" --unit \"Percent\" --period 60 --threshold 90 --comparison-operator \"GreaterThanThreshold\" --dimensions Name=DBInstanceIdentifier,Value=$DBID --evaluation-periods 5 --alarm-actions \"$ALARMACTION\" --profile $profile\n        HorizontalRule\n        echo $CLIENT $ENVIRONMENT \"Database CPU Check Alarm Set\"\n        HorizontalRule\n\n        # Database Memory Usage Check\n        aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT $ENVIRONMENT DB Mem Check\" --alarm-description \"$CLIENT $ENVIRONMENT Database Freeable Memory < 200 MB for 5 minutes\" --metric-name \"FreeableMemory\" --namespace \"AWS/RDS\" --statistic \"Average\" --unit \"Bytes\" --period 60 --threshold \"200000000\" --comparison-operator \"LessThanThreshold\" --dimensions Name=DBInstanceIdentifier,Value=$DBID --evaluation-periods 5 --alarm-actions \"$ALARMACTION\" --profile $profile\n        HorizontalRule\n        echo $CLIENT $ENVIRONMENT \"Database Memory Usage Alarm Set\"\n        HorizontalRule\n\n        # Database Available Storage Space Check\n        aws cloudwatch put-metric-alarm --alarm-name \"$CLIENT $ENVIRONMENT DB Storage Check\" --alarm-description \"$CLIENT $ENVIRONMENT Database Available Storage Space < 200 MB\" --metric-name \"FreeStorageSpace\" --namespace \"AWS/RDS\" --statistic \"Average\" --unit \"Bytes\" --period 60 --threshold \"200000000\" --comparison-operator \"LessThanThreshold\" --dimensions Name=DBInstanceIdentifier,Value=$DBID --evaluation-periods 1 --alarm-actions \"$ALARMACTION\" --profile $profile\n        HorizontalRule\n        echo $CLIENT $ENVIRONMENT \"Database Available Storage Space Alarm Set\"\n        HorizontalRule\n      done\n    else\n      if [[ $DBNUM == 0 ]]; then\n        echo \"Skipping Database Alarms...\"\n      else\n        tput setaf 1; echo \"Invalid Number of Databases!\" && tput sgr0\n      fi\n    fi\n  else\n    echo \"Exiting\"\n  fi\ncompleted\n"
        },
        {
          "name": "cloudwatch-logs-cleanup.sh",
          "type": "blob",
          "size": 9.025390625,
          "content": "#!/usr/bin/env bash\n\n# This script will delete all CloudWatch Log Groups with a Last Event that is older than the Retention Policy in all regions available\n# Requires the AWS CLI and jq\n\n# Set Variables\n\n# Optionally limit to a single AWS Region\nRegion=\"ALL\"\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Error\nfunction error(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\t# read -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# Warning\nfunction Warning(){\n\ttput setaf 1\n\techo\n\tHorizontalRule\n\techo \"Warning: This script will DELETE all CloudWatch Log Groups with a Last Event Timestamp\"\n\techo \"that is older than the Retention Policy set on the Log Group in all regions available.\"\n\techo\n\tread -r -p \"Are you sure you understand and want to continue? (y/n) \" CONTINUE\n\tHorizontalRule\n\tif ! [[ $CONTINUE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\techo \"Canceled.\"\n\t\ttput sgr0\n\t\texit 1\n\tfi\n\ttput sgr0\n\techo\n}\n\n# Limit region\nif [[ \"$Region\" == \"ALL\" ]]; then\n\tread -r -p \"Enter a single Region name or press return to search all regions: \" Region\nfi\n\n# Get list of all regions (using EC2)\nfunction GetRegions(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin GetRegions Function\"\n\tfi\n\tAWSregions=$(aws ec2 describe-regions --output=json --profile $profile 2>&1)\n\tif echo \"$AWSregions\" | egrep -iq \"error|not\"; then\n\t\tfail \"$AWSregions\"\n\telse\n\t\tParseRegions=$(echo \"$AWSregions\" | jq '.Regions | .[] | .RegionName'| cut -d \\\" -f2 | sort)\n\tfi\n\tTotalRegions=$(echo \"$ParseRegions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Regions:\"\n\t\techo \"$AWSregions\"\n\t\techo \"$ParseRegions\"\n\t\techo \"TotalRegions: $TotalRegions\"\n\t\tpause\n\tfi\n\tLogGroupsInRegion\n}\n\n# Get list of all CloudWatch Log Groups in all regions\nfunction LogGroupsInRegion(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin LogGroupsInRegion Function\"\n\tfi\n\tLogGroupsInRegionStart=1\n\tfor (( LogGroupsInRegionCount=$LogGroupsInRegionStart; LogGroupsInRegionCount<=$TotalRegions; LogGroupsInRegionCount++ ))\n\tdo\n\t\tRegion=$(echo \"$ParseRegions\" | nl | grep -w [^0-9][[:space:]]$LogGroupsInRegionCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug Region: $Region\"\n\t\tfi\n\t\tHorizontalRule\n\t\tListLogGroups\n\t\techo\n\tdone\n}\n\n# Get list of all CloudWatch Log Groups in one region\nfunction ListLogGroups(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListLogGroups Function\"\n\tfi\n\tListLogGroups=$(aws logs describe-log-groups --region=$Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ListLogGroups\"\n\t# if echo \"$ListLogGroups\" | egrep -iq \"error|not\"; then\n\t# \tfail \"$ListLogGroups\"\n\telse\n\t\tParseLogGroups=$(echo \"$ListLogGroups\" | jq '.logGroups | .[] | .logGroupName' | cut -d \\\" -f2)\n\tfi\n\tif [ -z \"$ParseLogGroups\" ]; then\n\t\techo \"No Log Groups found in $Region.\"\n\telse\n\t\ttput setaf 2; echo \"Reviewing Log Groups in Region $Region...\" && tput sgr0\n\t\tHorizontalRule\n\t\t# echo \"$ParseLogGroups\"\n\t\tCheckRetentionPolicy\n\tfi\n}\n\n# Check Retention Policy\nfunction CheckRetentionPolicy(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin CheckRetentionPolicy Function\"\n\tfi\n\tTotalLogGroups=$(echo \"$ParseLogGroups\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"~~~~\"\n\t\techo \"Region: $Region\"\n\t\techo \"TotalLogGroups: $TotalLogGroups\"\n\t\techo \"~~~~\"\n\t\tpause\n\tfi\n\tCheckRetentionPolicyStart=1\n\tfor (( CheckRetentionPolicyCount=$CheckRetentionPolicyStart; CheckRetentionPolicyCount<=$TotalLogGroups; CheckRetentionPolicyCount++ ))\n\tdo\n\t\tLogGroup=$(echo \"$ParseLogGroups\" | nl | grep -w [^0-9][[:space:]]$CheckRetentionPolicyCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"o0o0o0o\"\n\t\t\techo \"Count: $CheckRetentionPolicyCount\"\n\t\t\techo \"LogGroup: $LogGroup\"\n\t\t\techo \"o0o0o0o\"\n\t\t\tpause\n\t\tfi\n\t\tCheckRetentionPolicy=$(aws logs describe-log-groups --region $Region --log-group-name-prefix $LogGroup --output=json --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$CheckRetentionPolicy\"\n\t\tfi\n\t\t# if echo \"$CheckRetentionPolicy\" | egrep -iq \"error|not\"; then\n\t\t# \tfail \"$CheckRetentionPolicy\"\n\t\t# fi\n\t\tcountLogGroups=$(echo \"$CheckRetentionPolicy\" | jq '.logGroups | length')\n\t\tif [ $countLogGroups -gt 1 ]; then\n\t\t\terror \"Multiple Log Groups Match this Prefix: $LogGroup in Region: $Region\"\n\t\telse\n\t\t\tretentionInDays=$(echo \"$CheckRetentionPolicy\" | jq '.logGroups | .[] | .retentionInDays' | cut -d \\\" -f2)\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"start test\"\n\t\t\t\techo \"retentionInDays: $retentionInDays\"\n\t\t\t\techo \"end test\"\n\t\t\t\techo \"$CheckRetentionPolicy\" | jq .\n\t\t\tfi\n\t\t\tif [ -z \"$retentionInDays\" ]; then\n\t\t\t\terror \"Error checking Retention Policy for Log Group $LogGroup in Region: $Region\"\n\t\t\telse\n\t\t\t\tif [[ \"$retentionInDays\" == \"null\" ]]; then\n\t\t\t\t\terror \"No Retention Policy set for Log Group $LogGroup in Region: $Region\"\n\t\t\t\telse\n\t\t\t\t\tCheckLogStream\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tdone\n}\n\n# Check Log Stream\nfunction CheckLogStream(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin CheckLogStream Function\"\n\tfi\n\tCheckLogStream=$(aws logs describe-log-streams --region $Region --log-group-name $LogGroup --max-items 1 --order-by LastEventTime --descending --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CheckLogStream\"\n\tfi\n\t# if echo \"$CheckLogStream\" | egrep -iq \"error|not\"; then\n\t# \tfail \"$CheckLogStream\"\n\t# fi\n\tlastEventTimestamp=$(echo \"$CheckLogStream\" | jq '.logStreams | .[] | .lastEventTimestamp' | cut -d \\\" -f2)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"lastEventTimestamp: $lastEventTimestamp\"\n\tfi\n\tCheckTimestamp\n}\n\n# Convert Retention Days to MS\nfunction convertDaystoMS(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin convertDaystoMS Function\"\n\tfi\n\tif [ $retentionInDays -eq 1 ]; then\n\t\tretentionInDaysToMS=86400000\n\telif [ $retentionInDays -eq 3 ]; then\n\t\tretentionInDaysToMS=259200000\n\telif [ $retentionInDays -eq 5 ]; then\n\t\tretentionInDaysToMS=432000000\n\telif [ $retentionInDays -eq 7 ]; then\n\t\tretentionInDaysToMS=604800000\n\telif [ $retentionInDays -eq 14 ]; then\n\t\tretentionInDaysToMS=1209600000\n\telif [ $retentionInDays -eq 30 ]; then\n\t\tretentionInDaysToMS=2592000000\n\telif [ $retentionInDays -eq 60 ]; then\n\t\tretentionInDaysToMS=5184000000\n\telif [ $retentionInDays -eq 90 ]; then\n\t\tretentionInDaysToMS=7776000000\n\telif [ $retentionInDays -eq 120 ]; then\n\t\tretentionInDaysToMS=10368000000\n\telif [ $retentionInDays -eq 150 ]; then\n\t\tretentionInDaysToMS=12960000000\n\telif [ $retentionInDays -eq 180 ]; then\n\t\tretentionInDaysToMS=15552000000\n\telif [ $retentionInDays -eq 365 ]; then\n\t\tretentionInDaysToMS=31536000000\n\telif [ $retentionInDays -eq 400 ]; then\n\t\tretentionInDaysToMS=34560000000\n\telif [ $retentionInDays -eq 545 ]; then\n\t\tretentionInDaysToMS=47088000000\n\telif [ $retentionInDays -eq 731 ]; then\n\t\tretentionInDaysToMS=63158400000\n\telif [ $retentionInDays -eq 1827 ]; then\n\t\tretentionInDaysToMS=157852800000\n\telif [ $retentionInDays -eq 3653 ]; then\n\t\tretentionInDaysToMS=315619200000\n\tfi\n}\n\n# Milliseconds in a day\nmsInaDay=\"86400000\"\n\n# Check Timestamp\nfunction CheckTimestamp(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin CheckTimestamp Function\"\n\tfi\n\t# retentionInDaysToMS=$(($retentionInDays * $msInaDay))\n\tconvertDaystoMS\n\tnow=$(date +%s000)\n\tdifference=$(($now - $lastEventTimestamp))\n\tdays=$(($difference / $msInaDay))\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"retentionInDaysToMS: $retentionInDaysToMS\"\n\t\techo \"now: $now\"\n\t\techo \"difference: $difference\"\n\tfi\n\n\t# echo \"Region: $Region\"\n\tif [ $difference -gt $retentionInDaysToMS ]; then\n\t\tHorizontalRule\n\t\ttput setaf 1; echo \"PAST RETENTION TIME:\"\n\t\techo \"LogGroup: $LogGroup\"\n\t\techo \"Days Since Last Event: $days\" && tput sgr0\n\t\tDeleteLogGroup\n\t\tHorizontalRule\n\tfi\n}\n\n# Delete Log Group\nfunction DeleteLogGroup(){\n\techo \"Deleting Log Group...\"\n\tDeleteLogGroup=$(aws logs delete-log-group --region $Region --log-group-name $LogGroup --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$DeleteLogGroup\"\n\tfi\n}\n\nWarning\n\nif [ -z \"$Region\" ]; then\n\tGetRegions\nelse\n\tListLogGroups\nfi\n\ncompleted\n"
        },
        {
          "name": "cloudwatch-logs-delete-groups.sh",
          "type": "blob",
          "size": 5.306640625,
          "content": "#!/usr/bin/env bash\n\n# This script will quickly delete all CloudWatch Log Groups with a specified prefix in all regions available\n# Requires the AWS CLI and jq\n\n# Set Variables\n\n# Specify Prefix to DELETE\nPrefix=\"/aws/example/logGroup\"\n\n# Optionally limit to a single AWS Region\nRegion=\"ALL\"\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Error\nfunction error(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\t# read -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# Warning\nfunction Warning(){\n\ttput setaf 1\n\techo\n\tHorizontalRule\n\techo \"Warning: This script will DELETE all CloudWatch Log Groups with a matching specified prefix.\"\n\techo\n\tread -r -p \"Are you sure you understand and want to continue? (y/n) \" CONTINUE\n\tHorizontalRule\n\tif ! [[ $CONTINUE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\techo \"Canceled.\"\n\t\ttput sgr0\n\t\texit 1\n\tfi\n\ttput sgr0\n\techo\n}\n\n# Set Prefix\nif [[ \"$Prefix\" == \"/aws/example/logGroup\" ]]; then\n\tread -r -p \"Specify CloudWatch Log Groups Prefix to DELETE: \" Prefix\n\tif [ -z \"$Prefix\" ]; then\n\t\tfail \"Must specify Prefix.\"\n\tfi\nfi\n\n# Limit region\nif [[ \"$Region\" == \"ALL\" ]]; then\n\tread -r -p \"Enter a single Region name or press return to search all regions: \" Region\nfi\n\n# Get list of all regions (using EC2)\nfunction GetRegions(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin GetRegions Function\"\n\tfi\n\tAWSregions=$(aws ec2 describe-regions --output=json --profile $profile 2>&1)\n\tif echo \"$AWSregions\" | egrep -iq \"error|not\"; then\n\t\tfail \"$AWSregions\"\n\telse\n\t\tParseRegions=$(echo \"$AWSregions\" | jq '.Regions | .[] | .RegionName'| cut -d \\\" -f2 | sort)\n\tfi\n\tTotalRegions=$(echo \"$ParseRegions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Regions:\"\n\t\techo \"$AWSregions\"\n\t\techo \"$ParseRegions\"\n\t\techo \"TotalRegions: $TotalRegions\"\n\t\tpause\n\tfi\n\tLogGroupsInRegion\n}\n\n# Get list of all CloudWatch Log Groups in all regions\nfunction LogGroupsInRegion(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin LogGroupsInRegion Function\"\n\tfi\n\tLogGroupsInRegionStart=1\n\tfor (( LogGroupsInRegionCount=$LogGroupsInRegionStart; LogGroupsInRegionCount<=$TotalRegions; LogGroupsInRegionCount++ ))\n\tdo\n\t\tRegion=$(echo \"$ParseRegions\" | nl | grep -w [^0-9][[:space:]]$LogGroupsInRegionCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug Region: $Region\"\n\t\tfi\n\t\tHorizontalRule\n\t\tListLogGroups\n\t\techo\n\tdone\n}\n\n# Get list of all CloudWatch Log Groups in one region\nfunction ListLogGroups(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListLogGroups Function\"\n\tfi\n\tListLogGroups=$(aws logs describe-log-groups --log-group-name-prefix \"$Prefix\" --region=$Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ListLogGroups\"\n\t# if echo \"$ListLogGroups\" | egrep -iq \"error|not\"; then\n\t# \tfail \"$ListLogGroups\"\n\telse\n\t\tParseLogGroups=$(echo \"$ListLogGroups\" | jq '.logGroups | .[] | .logGroupName' | cut -d \\\" -f2)\n\tfi\n\tif [ -z \"$ParseLogGroups\" ]; then\n\t\techo \"No Log Groups found in $Region.\"\n\telse\n\t\ttput setaf 2; echo \"Found Matching Log Groups in Region $Region...\" && tput sgr0\n\t\tHorizontalRule\n\t\techo \"$ParseLogGroups\"\n\t\tWarning\n\t\tDeleteLogGroup\n\tfi\n}\n\n# Delete Log Group\nfunction DeleteLogGroup(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin DeleteLogGroup Function\"\n\tfi\n\n\n\tTotalLogGroups=$(echo \"$ParseLogGroups\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"~~~~\"\n\t\techo \"Region: $Region\"\n\t\techo \"TotalLogGroups: $TotalLogGroups\"\n\t\techo \"~~~~\"\n\t\tpause\n\tfi\n\tDeleteLogGroupStart=1\n\tfor (( DeleteLogGroupCount=$DeleteLogGroupStart; DeleteLogGroupCount<=$TotalLogGroups; DeleteLogGroupCount++ ))\n\tdo\n\t\tLogGroup=$(echo \"$ParseLogGroups\" | nl | grep -w [^0-9][[:space:]]$DeleteLogGroupCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"o0o0o0o\"\n\t\t\techo \"Count: $DeleteLogGroupCount\"\n\t\t\techo \"LogGroup: $LogGroup\"\n\t\t\techo \"o0o0o0o\"\n\t\t\tpause\n\t\tfi\n\t\techo \"Deleting Log Group: $LogGroup\"\n\t\tDeleteLogGroup=$(aws logs delete-log-group --region $Region --log-group-name $LogGroup --output=json --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$DeleteLogGroup\"\n\t\tfi\n\tdone\n}\n\nWarning\n\nif [ -z \"$Region\" ]; then\n\tGetRegions\nelse\n\tListLogGroups\nfi\n\ncompleted\n"
        },
        {
          "name": "cloudwatch-logs-retention-policy.sh",
          "type": "blob",
          "size": 5.322265625,
          "content": "#!/usr/bin/env bash\n\n# This script will set CloudWatch Logs Retention Policy to x number of days for all log groups in all regions available\n# Requires the AWS CLI and jq\n\n# Set Variables\n\n# The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.\nRetentionInDays=x\n\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# Validate Variable\nif [[ \"$RetentionInDays\" == \"x\" ]]; then\n\techo \"Enter the number of days to retain all CloudWatch Log Groups in all AWS regions. Possible values are:\"\n\techo \"1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.\"\n\tread -r -p \"Retention in days: \" RetentionInDays\nfi\n\nif [ -z \"$RetentionInDays\" ]; then\n\tfail \"Variable RetentionInDays must be set.\"\nfi\n\nif ! [[ \"$RetentionInDays\" =~ ^1$|^3$|^5$|^7$|^14$|^30$|^60$|^90$|^120$|^150$|^180$|^365$|^400$|^545$|^731$|^1827$|^3653$ ]]; then\n\tfail \"Variable RetentionInDays outside of possible range or invalid.\"\nfi\n\n# Get list of all regions (using EC2)\nfunction GetRegions(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin GetRegions Function\"\n\tfi\n\tAWSregions=$(aws ec2 describe-regions --output=json --profile $profile 2>&1)\n\tif echo \"$AWSregions\" | egrep -iq \"error\"; then\n\t\tfail \"$AWSregions\"\n\telse\n\t\tParseRegions=$(echo \"$AWSregions\" | jq '.Regions | .[] | .RegionName'| cut -d \\\" -f2 | sort)\n\tfi\n\tTotalRegions=$(echo \"$ParseRegions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Regions:\"\n\t\techo \"$AWSregions\"\n\t\techo \"$ParseRegions\"\n\t\techo \"TotalRegions: $TotalRegions\"\n\t\tpause\n\tfi\n\tLogGroupsInRegion\n}\n\n# Get list of all CloudWatch Log Groups in all regions\nfunction LogGroupsInRegion(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin LogGroupsInRegion Function\"\n\tfi\n\tLogGroupsInRegionStart=1\n\tfor (( LogGroupsInRegionCount=$LogGroupsInRegionStart; LogGroupsInRegionCount<=$TotalRegions; LogGroupsInRegionCount++ ))\n\tdo\n\t\tRegion=$(echo \"$ParseRegions\" | nl | grep -w [^0-9][[:space:]]$LogGroupsInRegionCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug Region: $Region\"\n\t\tfi\n\t\tHorizontalRule\n\t\tListLogGroups\n\t\techo\n\tdone\n}\n\n# Get list of all CloudWatch Log Groups in one region\nfunction ListLogGroups(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListLogGroups Function\"\n\tfi\n\tListLogGroups=$(aws logs describe-log-groups --region=$Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ListLogGroups\"\n\t# if echo \"$ListLogGroups\" | egrep -iq \"error|not\"; then\n\t# \tfail \"$ListLogGroups\"\n\telse\n\t\tParseLogGroups=$(echo \"$ListLogGroups\" | jq '.logGroups | .[] | .logGroupName' | cut -d \\\" -f2)\n\tfi\n\tif [ -z \"$ParseLogGroups\" ]; then\n\t\techo \"No Log Groups found in $Region.\"\n\telse\n\t\techo \"Log Groups in Region $Region:\"\n\t\techo \"$ParseLogGroups\"\n\t\techo\n\t\techo \"Setting Retention Policy for $Region.\"\n\t\tSetRetentionPolicy\n\tfi\n}\n\n# Set Retention Policy\nfunction SetRetentionPolicy(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin SetRetentionPolicy Function\"\n\tfi\n\tTotalLogGroups=$(echo \"$ParseLogGroups\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"~~~~\"\n\t\techo \"Region: $Region\"\n\t\techo \"TotalLogGroups: $TotalLogGroups\"\n\t\techo \"~~~~\"\n\t\tpause\n\tfi\n\tSetRetentionPolicyStart=1\n\tfor (( SetRetentionPolicyCount=$SetRetentionPolicyStart; SetRetentionPolicyCount<=$TotalLogGroups; SetRetentionPolicyCount++ ))\n\tdo\n\t\tLogGroup=$(echo \"$ParseLogGroups\" | nl | grep -w [^0-9][[:space:]]$SetRetentionPolicyCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"o0o0o0o\"\n\t\t\techo \"Count: $SetRetentionPolicyCount\"\n\t\t\techo \"LogGroup: $LogGroup\"\n\t\t\techo \"o0o0o0o\"\n\t\t\tpause\n\t\tfi\n\t\tSetRetentionPolicy=$(aws logs put-retention-policy --region $Region --log-group-name $LogGroup --retention-in-days $RetentionInDays --output=json --profile $profile 2>&1)\n\t\tif echo \"$SetRetentionPolicy\" | egrep -iq \"error|not\"; then\n\t\t\tfail \"$SetRetentionPolicy\"\n\t\tfi\n\t\tif [ -z \"$SetRetentionPolicy\" ]; then\n\t\t\techo \"Set Retention Policy to $RetentionInDays days for $LogGroup\"\n\t\telse\n\t\t\tfail \"$SetRetentionPolicy\"\n\t\tfi\n\tdone\n}\n\nGetRegions\n\ncompleted\n"
        },
        {
          "name": "cloudwatch-logs-search.sh",
          "type": "blob",
          "size": 6.44921875,
          "content": "#!/usr/bin/env bash\n\n# This script will search all CloudWatch Logs (all log groups in all regions available) for a filter string\n# Requires the AWS CLI and jq\n\n# Set Variables\n\n# Log Group Prefix\nLogGroupName=\"x\"\n\n# The string to filter logs\nFilterPattern=\"x\"\n\n# Optionally limit to a single AWS Region\nRegion=\"x\"\n\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\techo\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# Validate Variables\nif [[ \"$LogGroupName\" == \"x\" ]]; then\n\tread -r -p \"Enter Log Group name or press return to search all groups: \" LogGroupName\nfi\n\nif [[ \"$FilterPattern\" == \"x\" ]]; then\n\tread -r -p \"Enter filter pattern to search logs: \" FilterPattern\nfi\n\nif [ -z \"$FilterPattern\" ]; then\n\tfail \"Filter pattern must be set.\"\nfi\n\nif [[ \"$Region\" == \"x\" ]]; then\n\tread -r -p \"Enter a single Region name or press return to search all regions: \" Region\nfi\n\n# Get list of all regions (using EC2)\nfunction GetRegions(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin GetRegions Function\"\n\tfi\n\tAWSregions=$(aws ec2 describe-regions --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AWSregions\"\n\telse\n\t\tParseRegions=$(echo \"$AWSregions\" | jq '.Regions | .[] | .RegionName'| cut -d \\\" -f2 | sort)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$ParseRegions\"\n\t\tfi\n\tfi\n\tTotalRegions=$(echo \"$ParseRegions\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Regions:\"\n\t\t# echo \"$AWSregions\"\n\t\techo \"$ParseRegions\"\n\t\techo \"TotalRegions: $TotalRegions\"\n\t\tpause\n\tfi\n}\n\n# Get list of all CloudWatch Log Groups in all regions\nfunction LogGroupsInRegion(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin LogGroupsInRegion Function\"\n\tfi\n\tLogGroupsInRegionStart=1\n\tfor (( LogGroupsInRegionCount=$LogGroupsInRegionStart; LogGroupsInRegionCount<=$TotalRegions; LogGroupsInRegionCount++ ))\n\tdo\n\t\tRegion=$(echo \"$ParseRegions\" | nl | grep -w [^0-9][[:space:]]$LogGroupsInRegionCount | cut -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Debug Region: $Region\"\n\t\tfi\n\t\tHorizontalRule\n\t\tListLogGroups\n\t\techo\n\tdone\n}\n\n# Get list of all CloudWatch Log Groups in one region\nfunction ListLogGroups(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin ListLogGroups Function\"\n\tfi\n\tListLogGroups=$(aws logs describe-log-groups --region=$Region --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ListLogGroups\"\n\telse\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ListLogGroups: \"$ListLogGroups\"\n\t\tfi\n\t\tParseLogGroups=$(echo \"$ListLogGroups\" | jq '.logGroups | .[] | .logGroupName' | cut -d \\\" -f2)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ParseLogGroups: \"$ParseLogGroups\"\n\t\tfi\n\tfi\n\tif [ -z \"$ParseLogGroups\" ]; then\n\t\techo \"No Log Groups found in $Region.\"\n\telse\n\t\tif [ -z \"$LogGroupName\" ]; then\n\t\t\techo \"Log Groups in Region $Region:\"\n\t\t\techo \"$ParseLogGroups\"\n\t\tfi\n\t\techo\n\t\tFilterLogEvents\n\tfi\n}\n\n# Filter Log Events\nfunction FilterLogEvents(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Begin FilterLogEvents Function\"\n\tfi\n\tTotalLogGroups=$(echo \"$ParseLogGroups\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Region: $Region\"\n\t\techo \"TotalLogGroups: $TotalLogGroups\"\n\t\techo \"Log Group Name: $LogGroupName\"\n\t\tpause\n\tfi\n\tif ! [ -z \"$LogGroupName\" ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$LogGroupName\"\n\t\t\tpause\n\t\tfi\n\t\tif echo \"$ParseLogGroups\" | egrep -iq \"$LogGroupName\"; then\n\t\t\techo \"Located Matching Log Group in Region $Region.\"\n\t\t\techo \"Searching Log Events... this may take a very long time...\"\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"Searching Single Log Group: $LogGroupName\"\n\t\t\tfi\n\t\t\tFilterLogEvents=$(aws logs filter-log-events --region $Region --log-group-name \"$LogGroupName\" --filter-pattern \\\"\"$FilterPattern\"\\\" --output=json --profile $profile 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FilterLogEvents\"\n\t\t\tfi\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"FilterLogEvents: $FilterLogEvents\"\n\t\t\t\tpause\n\t\t\tfi\n\t\t\tEvents=$(echo \"$FilterLogEvents\" | jq '.events | .[]')\n\t\t\tif [ -z \"$Events\" ]; then\n\t\t\t\techo \"No matching events found for $LogGroupName in region $Region.\"\n\t\t\telse\n\t\t\t\techo \"Found matching events for $LogGroupName in region $Region:\"\n\t\t\t\techo \"$Events\" | jq .\n\t\t\tfi\n\t\telse\n\t\t\techo \"No matching events found for $LogGroupName in region $Region.\"\n\t\tfi\n\telse\n\t\tFilterLogEventsStart=1\n\t\tfor (( FilterLogEventsCount=$FilterLogEventsStart; FilterLogEventsCount<=$TotalLogGroups; FilterLogEventsCount++ ))\n\t\tdo\n\t\t\tLogGroup=$(echo \"$ParseLogGroups\" | nl | grep -w [^0-9][[:space:]]$FilterLogEventsCount | cut -f2)\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"Count: $FilterLogEventsCount\"\n\t\t\t\techo \"LogGroup: $LogGroup\"\n\t\t\t\tpause\n\t\t\tfi\n\t\t\tFilterLogEvents=$(aws logs filter-log-events --region $Region --log-group-name \"$LogGroup\" --filter-pattern \\\"\"$FilterPattern\"\\\" --output=json --profile $profile 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FilterLogEvents\"\n\t\t\tfi\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"FilterLogEvents: $FilterLogEvents\"\n\t\t\t\tpause\n\t\t\tfi\n\t\t\tEvents=$(echo \"$FilterLogEvents\" | jq '.events | .[]')\n\t\t\tif [ -z \"$Events\" ]; then\n\t\t\t\techo \"No matching events found for $LogGroup in region $Region.\"\n\t\t\telse\n\t\t\t\techo \"Found matching events for $LogGroup in region $Region:\"\n\t\t\t\techo \"$Events\" | jq .\n\t\t\tfi\n\t\tdone\n\tfi\n}\n\nif [ -z \"$Region\" ]; then\n\tGetRegions\n\tLogGroupsInRegion\nelse\n\tListLogGroups\nfi\n\ncompleted\n"
        },
        {
          "name": "convert-iplist-cidr-json-array.sh",
          "type": "blob",
          "size": 1.4990234375,
          "content": "#!/usr/bin/env bash\n# This script converts an IPv4 iplist to CIDR block notation and JSON array format, sorting and de-duplicating IPs\n\n# Set Variables\nfilename=\"iplist\"\nDEBUGMODE=\"0\"\n\n\n# Cleanup list\nfunction cleanup {\n\tsort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 $filename | uniq > iplist2\n\tmv iplist2 $filename\n\t# echo \"iplist cleanup completed.\"\n}\n\n\n# Convert the list to CIDR notation if needed\nfunction CIDR {\n\n\t# Remove existing file\n\tif [ -f CIDR-\"$filename\" ]; then\n\t\trm CIDR-\"$filename\"\n\tfi\n\n\twhile read iplist\n\tdo\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"IP: \"$iplist\n\t\tfi\n\n\t\t# Test for CIDR notation\n\t\tif ! echo $iplist | egrep -q '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$'; then\n\t\t\techo $iplist/32 >> CIDR-\"$filename\"\n\t\telse echo $iplist >> CIDR-\"$filename\"\n\t\tfi\n\tdone < \"$filename\"\n}\n\n\n# Convert the list to JSON array\nfunction JSONizeiplist {\n\n\t# Use CIDR file if it exists\n\tif [ -f CIDR-\"$filename\" ]; then\n\t\tfilename=CIDR-\"$filename\"\n\tfi\n\n\techo \"[\">> iplistjson2\n\n\twhile read iplist\n\tdo\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"IP: \"$iplist\n\t\tfi\n\t\techo \\\"$iplist\\\",>> iplistjson2\n\tdone < \"$filename\"\n\n\tcat iplistjson2 | sed '$ s/.$//' >> iplistjson3\n\n\techo \"]\">> iplistjson3\n\n\trm iplistjson2 && mv iplistjson3 JSON-\"$filename\"\n\n\tiplistjson=$(cat \"$filename\")\n\tfilename=JSON-\"$filename\"\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo $iplistjson\n\tfi\n}\n\ncleanup\n\nCIDR\n\nJSONizeiplist\n\necho Completed, converted file name: $filename\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "ec2-ami-encrypted-ebs-boot-volume.sh",
          "type": "blob",
          "size": 7.5498046875,
          "content": "#!/usr/bin/env bash\n\n# This script will create an AMI with an encrypted boot volume from the latest Amazon Linux AMI (amzn-ami-hvm-x86_64-gp2)\n\n# See:\n# https://aws.amazon.com/blogs/aws/new-encrypted-ebs-boot-volumes/\n# https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/CopyingAMIs.html\n# https://aws.amazon.com/blogs/compute/query-for-the-latest-amazon-linux-ami-ids-using-aws-systems-manager-parameter-store/\n\n# Requires the AWS CLI and jq\n\n\n# Set Variables\nAMITYPE=\"amzn-ami-hvm-x86_64-gp2\"\nRegion=\"default\"\n\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n\n# Check Command\nfunction check_command(){\n\tfor command in \"$@\"\n\tdo\n\t    type -P $command &>/dev/null || fail \"Unable to find $command, please install it and run this script again.\"\n\tdone\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n\texit 1\n}\n\n# Error\nfunction error(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n\treturn 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Generate a client token\nfunction ClientToken(){\n\tClientToken=$(echo $(echo $RANDOM; date +%s; date +%s; date +%s; date +%s; echo $RANDOM) | tr -d ' ')\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ClientToken\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"ClientToken: $ClientToken\"\n\tfi\n}\n\n# Determine region\nfunction GetRegion(){\n\tif [ \"$Region\" == \"default\" ]; then\n\t\tRegion=$(aws configure get region --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$Region\"\n\t\tfi\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"Region: $Region\"\n\tfi\n}\n\n# Get the latest Amazon Linux AMI ID\nfunction GetAMI(){\n\tAMI=$(aws ssm get-parameters --names /aws/service/ami-amazon-linux-latest/\"$AMITYPE\" --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AMI\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"AMI: $AMI\"\n\tfi\n\tNAME=$(echo $AMI | jq '.Parameters | .[] | .Name' | cut -d \\/ -f5 | cut -d \\\" -f1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$NAME\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"NAME: $NAME\"\n\tfi\n\tAMIID=$(echo $AMI | jq '.Parameters | .[] | .Value' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AMIID\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"AMIID: $AMIID\"\n\tfi\n\tDESCR=$(aws ec2 describe-images --image-ids \"$AMIID\" --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$DESCR\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"DESCR: $DESCR\"\n\tfi\n\tDESCR=$(echo \"$DESCR\" | jq '.Images | .[] | .Description' | cut -d \\\" -f2)\n\t# DESCR=\"$NAME-$AMIID\"\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$DESCR\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"DESCR: $DESCR\"\n\tfi\n}\n\n# Build encrypted AMI\nfunction EncryptAMI(){\n\tEncrypt=$(aws ec2 copy-image --encrypted --client-token \"$ClientToken\" --description \"Encrypted $DESCR ($AMIID)\" --name \"Encrypted $DESCR ($AMIID)\" --source-image-id \"$AMIID\" --source-region $Region --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$Encrypt\"\n\tfi\n\tEncryptedAMI=$(echo \"$Encrypt\" | jq '.ImageId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$EncryptedAMI\"\n\tfi\n\tHorizontalRule\n\techo \"Creating $AMITYPE AMI with encrypted boot volume:\"\n\tHorizontalRule\n\techo\n\ttput setaf 2; echo \"New AMI ID: $EncryptedAMI\"; echo \"Encrypted $DESCR ($AMIID)\"; tput sgr0\n}\n\n# Tag the AMI\nfunction TagAMI(){\n\t# Short pause to allow resources some time to be created before attempting to tag\n\techo\n\tfor i in {1..10}; do\n\t\tprintf \".\"\n\t\tsleep 1\n\tdone\n\techo\n\techo\n\techo \"Creating Name Tag for AMI ID: $EncryptedAMI\"\n\tTag=$(aws ec2 create-tags --resources \"$EncryptedAMI\" --tags \"Key=Name,Value=Encrypted $DESCR ($AMIID)\" --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$Tag\"\n\tfi\n}\n\n# Tag the Snapshot\nfunction QuicklyTagSnapshot(){\n\tCallerID=$(aws sts get-caller-identity --profile $profile 2>&1)\n\t# if [ ! $? -eq 0 ]; then\n\t# \terror \"$CallerID\"\n\t# fi\n\tAccountID=$(echo \"$CallerID\" | jq '.Account' | cut -d \\\" -f2)\n\t# if [ ! $? -eq 0 ]; then\n\t# \terror \"$AccountID\"\n\t# fi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"AccountID: $AccountID\"\n\tfi\n\tSnapshots=$(aws ec2 describe-snapshots --owner-ids $AccountID --filters Name=status,Values=pending --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\terror \"$Snapshots\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"$Snapshots\" | jq .\n\tfi\n\tNumSnapshots=$(echo \"$Snapshots\" | jq '.Snapshots | length')\n\tif [ ! $? -eq 0 ]; then\n\t\terror \"$NumSnapshots\"\n\tfi\n\tif [ \"$NumSnapshots\" -eq 1 ]; then\n\t\tSnapshotID=$(echo \"$Snapshots\" | jq '.Snapshots | .[] | .SnapshotId' | cut -d \\\" -f2)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\terror \"$SnapshotID\"\n\t\tfi\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"SnapshotID: $SnapshotID\"\n\t\tfi\n\t\tif [ -z \"$SnapshotID\" ]; then\n\t\t\treturn 1\n\t\t\t# fail \"Unable to get Snapshot ID or Tag Snapshot.\"\n\t\tfi\n\t\techo\n\t\techo \"Creating Name Tag for Snapshot ID: $SnapshotID\"\n\t\tSnapshotTag=$(aws ec2 create-tags --resources \"$SnapshotID\" --tags \"Key=Name,Value=Encrypted $DESCR ($AMIID)\" --region $Region --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\terror \"$SnapshotTag\"\n\t\tfi\n\t\techo\n\telse\n\t\treturn 1\n\tfi\n}\n\n# Tag the Snapshot (fallback)\nfunction SlowlyTagSnapshot(){\n\techo\n\techo\n\techo \"Creating Name Tag for Snapshot...\"\n\techo \"Waiting for AMI State to become available, may take around 5 minutes...\"\n\tstarttime=$(date +%s)\n\tCheckState\n\tfinishtime=$(date +%s)\n\tseconds=$(expr $finishtime - $starttime)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo; echo \"This took $(expr $seconds / 60) minutes.\"\n\tfi\n\tSnapshotID=$(echo \"$AMIdescr\" | jq '.Images | .[] | .BlockDeviceMappings | .[] | .Ebs | .SnapshotId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SnapshotID\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"SnapshotID: $SnapshotID\"\n\tfi\n\tif [ -z \"$SnapshotID\" ]; then\n\t\tfail \"Unable to get Snapshot ID or Tag Snapshot.\"\n\tfi\n\tSnapshotTag=$(aws ec2 create-tags --resources \"$SnapshotID\" --tags \"Key=Name,Value=Encrypted $DESCR ($AMIID)\" --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SnapshotTag\"\n\tfi\n\techo; echo \"Tagged Snapshot: $SnapshotID\"\n\techo\n}\n\n# Check AMI State\nfunction CheckState(){\n\tAMIdescr=$(aws ec2 describe-images --image-ids \"$EncryptedAMI\" --region $Region --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AMIdescr\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"AMIdescr: $AMIdescr\"\n\tfi\n\tAMIstate=$(echo \"$AMIdescr\" | jq '.Images | .[] | .State' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AMIstate\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"AMIstate: $AMIstate\"\n\tfi\n\twhile [ $AMIstate != \"available\" ]; do\n\t\tfor i in {1..30}; do\n\t\t\tprintf \".\"\n\t\t\tsleep 1\n\t\tdone\n\t\tCheckState\n\tdone\n}\n\n# Run the script and call functions\n\n# Check for required applications\ncheck_command aws jq\n\nClientToken\nGetRegion\nGetAMI\nEncryptAMI\nTagAMI\nQuicklyTagSnapshot\nif [ ! $? -eq 0 ]; then\n\tSlowlyTagSnapshot\nfi\n\ncompleted\n"
        },
        {
          "name": "ec2-associate-elastic-ip.sh",
          "type": "blob",
          "size": 0.888671875,
          "content": "#!/usr/bin/env bash\n\n# This script is meant to be run as EC2 user-data for an Auto Scaling Group Launch Configuration\n# It will reassign a previously allocated Elastic IP to the instance which runs the script\n# This is useful if a single instance inside an ASG dies and a new instance must spin up with the same EIP\n# The instance must have an IAM role that allows \"ec2 associate-address\"\n\n# Set the allocated Elastic IP here\nELASTIC_IP=\"1.2.3.4\"\n\n# Determine and set region\nEC2_AVAIL_ZONE=`curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone`\nEC2_REGION=\"`echo \\\"$EC2_AVAIL_ZONE\\\" | sed -e 's:\\([0-9][0-9]*\\)[a-z]*\\$:\\\\1:'`\"\naws configure set region $EC2_REGION\n\n# Determine Instance ID\nINSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)\n\n# Associate Elastic IP\naws ec2 associate-address --instance-id $INSTANCE_ID --public-ip $ELASTIC_IP --allow-reassociation\n"
        },
        {
          "name": "ec2-classic-import-network-acl.sh",
          "type": "blob",
          "size": 1.6650390625,
          "content": "#!/usr/bin/env bash\n# This script will read from the list of CIDR IPs in the file ipblacklistmaster\n# Then create an AWS EC2 Classic ACL rule to deny access to each CIDR IP specified\n\n# VERY IMPORTANT to set the correct Network ACL ID for the intended ACL\nNETWORKACLID=\"YOUR-ACL-ID-HERE\"\n\nif [ \"$NETWORKACLID\" = \"YOUR-ACL-ID-HERE\" ]; then\n\ttput setaf 1; echo \"Failed to set Network ACL ID!\" && tput sgr0\n\texit 1\nfi\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\techo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\t\texit 1\n\tfi\nfi\n\n# exec &>> ~/vpcacl.log\necho \"=============================\"\ndate '+%c'\necho \"=============================\"\n\nTOTALCIDR=$(wc -l ipblacklistmaster | cut -d \" \" -f5)\n\necho \" \"\necho \"=====================================================\"\necho \"Adding CIDR records to ACL\"\necho \"Records to be created: \"$TOTALCIDR\necho \"=====================================================\"\necho \" \"\n\nSTART=1\nfor (( COUNT=$START; COUNT<=$TOTALCIDR; COUNT++ ))\ndo\n\techo \"=====================================================\"\n\techo \"Rule \"\\#$COUNT\n\n\tCIDR=$(nl ipblacklistmaster | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\techo \"CIDR=\"$CIDR\n\n\t# echo \"Network ACL ID: \"$NETWORKACLID\n\n\tADDRECORD=$(aws ec2 create-network-acl-entry --network-acl-id $NETWORKACLID --rule-number $COUNT --protocol -1 --rule-action deny --ingress --cidr-block $CIDR)\n\techo \"Record created: \"$ADDRECORD\ndone\n\necho \"=====================================================\"\necho \" \"\necho \"Completed!\"\necho \" \"\n"
        },
        {
          "name": "ec2-ebs-create-snapshots.sh",
          "type": "blob",
          "size": 2.07421875,
          "content": "#!/usr/bin/env bash\n# This script takes a snapshot of each EC2 volume that is tagged with Backup=1\n# TODO: Add error handling and loop breaks\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    echo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n    exit 1\n  fi\nfi\n\nDESCRIBEVOLUMES=$(aws ec2 describe-volumes --filter Name=tag:Backup,Values=\"1\")\n\nTOTALBACKUPVOLUMES=$(echo \"$DESCRIBEVOLUMES\" | grep Name | cut -f 3 | nl | wc -l)\n\necho \" \"\necho \"=====================================================\"\necho \"Creating EC2 Snapshots for Volumes with tag Backup=1\"\necho \"Snapshots to be created:\"$TOTALBACKUPVOLUMES\necho \"=====================================================\"\necho \" \"\n\nSTART=1\nfor (( COUNT=$START; COUNT<=$TOTALBACKUPVOLUMES; COUNT++ ))\ndo\n  echo \"=====================================================\"\n  echo \\#$COUNT\n\n  VOLUME=$(echo \"$DESCRIBEVOLUMES\" | cut -f 9 | nl | grep -w $COUNT | cut -f 2)\n  echo \"Volume ID: \"$VOLUME\n\n  NAME=$(echo \"$DESCRIBEVOLUMES\" | grep Name | cut -f 3 | nl | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n  echo \"Volume Name: \"$NAME\n\n  CLIENT=$(echo \"$DESCRIBEVOLUMES\" | grep Client | cut -f 3 | nl | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n  echo \"Client: \"$CLIENT\n\n  DESCRIPTION=$NAME-$(date +%m-%d-%Y)\n  echo \"Snapshot Description: \"$DESCRIPTION\n\n  SNAPSHOTRESULT=$(aws ec2 create-snapshot --volume-id $VOLUME --description $DESCRIPTION)\n  # echo \"Snapshot result is: \"$SNAPSHOTRESULT\n\n  SNAPSHOTID=$(echo $SNAPSHOTRESULT | cut -d ' ' -f5)\n  echo \"Snapshot ID: \"$SNAPSHOTID\n  # echo $SNAPSHOTID | grep -E \"snap-........\"\n  # sleep 3\n\n  TAGRESULT=$(aws ec2 create-tags --resources $SNAPSHOTID --tags Key=Name,Value=$NAME Key=Client,Value=$CLIENT Key=SnapshotCreation,Value=Automatic Key=SnapshotDate,Value=$(date +%m-%d-%Y))\n  # echo \"Tag Result is: \"$TAGRESULT\ndone\n\necho \"=====================================================\"\necho \" \"\necho \"Completed!\"\necho \" \"\n"
        },
        {
          "name": "ec2-ebs-delete-snapshots.sh",
          "type": "blob",
          "size": 1.9033203125,
          "content": "#!/usr/bin/env bash\n# This script deletes snapshots for each EC2 volume that is tagged with SnapshotCreation=Automatic that matches the specified date\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    echo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n    exit 1\n  fi\nfi\n\nSNAPSHOTDATES=$(aws ec2 describe-snapshots --filters Name=tag:SnapshotCreation,Values=\"Automatic\" --output text | grep SnapshotDate | cut -f 3 | sort -u)\n\necho \"List of Automatic Snapshot Dates:\"\necho \"$SNAPSHOTDATES\"\n\nread -r -p \"Enter Date for Snapshot Deletion: (MM-DD-YYYY) \" DELETEDATE\n\nif [[ -z $DELETEDATE ]]; then\n\techo \"Failed to set Date!\"\n\texit 1\nfi\n\nDESCRIBESNAPSHOTS=$(aws ec2 describe-snapshots --filters Name=tag:SnapshotDate,Values=\"$DELETEDATE\" Name=tag:SnapshotCreation,Values=\"Automatic\" --output text)\n\nTOTALSNAPSHOTS=$(echo \"$DESCRIBESNAPSHOTS\" | grep Name | cut -f 3 | nl | wc -l)\n\necho \" \"\necho \"=====================================================\"\necho \"Deleting EC2 Snapshots for date specified.\"\necho \"Snapshots to be deleted:\"$TOTALSNAPSHOTS\necho \"=====================================================\"\necho \" \"\n\nSTART=1\nfor (( COUNT=$START; COUNT<=$TOTALSNAPSHOTS; COUNT++ ))\ndo\n\techo \"=====================================================\"\n\techo \\#$COUNT\n\n\tDELETESNAPSHOTID=$(echo \"$DESCRIBESNAPSHOTS\" | cut -f 6 | grep -w snap | nl | grep -w $COUNT | cut -f 2)\n\n\tDELETESNAPSHOTDESC=$(echo \"$DESCRIBESNAPSHOTS\" | grep $DELETESNAPSHOTID | cut -f 2 | nl | grep -w 1 | cut -f 2)\n\n\tDELETESNAP=$(aws ec2 delete-snapshot --snapshot-id $DELETESNAPSHOTID --output text)\n\techo \"Successful: \"$DELETESNAP\n\techo \"Deleted: \"$DELETESNAPSHOTDESC\ndone\n\necho \"=====================================================\"\necho \" \"\necho \"Completed!\"\necho \" \"\n"
        },
        {
          "name": "ec2-elb-export-template.sh",
          "type": "blob",
          "size": 17.818359375,
          "content": "#!/usr/bin/env bash\n\n# This script will export an AWS ELB to a JSON Template File for version control\n# The ELB can then be duplicated or renamed or recreated from the JSON Template File\n# An AWS CLI profile can be passed into the script as an argument\n# Requires the AWS CLI and jq\n\n# Step 1: Pull JSON data from AWS for existing ELB and save to Template file\n# Step 2: Read JSON data from Template file and create new ELB\n# Step 3: Register Instances, Configure Healthcheck, Configure Attributes\n\nELBname=\"YOUR-EXISTING-ELB-NAME-HERE\"\nNewELBname=\"YOUR-NEW-ELB-NAME-HERE\"\n\n\n# Options\nCreateTemplateFile=true\nTemplateFileName=$ELBname-template.json\nCreateNewELB=true\nRegisterInstances=true\nConfigureHealthCheck=true\nConfigureAttributes=true\n\n# Debug\nDEBUGMODE=\"0\"\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\ttput setaf 1; echo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\" && tput sgr0\n\t\texit 1\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Functions\n\n# Check for command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction Completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\nfunction HorizontalRule(){\n\techo \"=====================================================\"\n}\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n# Ensure Variables are set\nif [ \"$ELBname\" = \"YOUR-EXISTING-ELB-NAME-HERE\" ] || [ -z \"$ELBname\" ]; then\n\tread -r -p \"Enter name of your existing source EC2 ELB: \" ELBname\n\tTemplateFileName=$ELBname-template.json\n\tif [ -z \"$ELBname\" ]; then\n\t\tfail \"Must specify an existing ELB name!\"\n\tfi\nfi\n\nif [ \"$CreateNewELB\" = \"true\" ]; then\n\tif [ \"$NewELBname\" = \"YOUR-NEW-ELB-NAME-HERE\" ] || [ -z \"$NewELBname\" ]; then\n\t\tread -r -p \"Enter desired name of your new EC2 ELB: \" NewELBname\n\t\tif [ -z \"$NewELBname\" ]; then\n\t\t\tfail \"Must specify a new ELB name!\"\n\t\tfi\n\tfi\nfi\n\n# Create Template File\nif [ \"$CreateTemplateFile\" = \"true\" ]; then\n\n\t# Ensure Variables are set\n\tif [ -z \"$TemplateFileName\" ]; then\n\t\tfail \"Must set variable for template file name!\"\n\tfi\n\n\t# Check for existing Template file\n\tif [ -f $TemplateFileName ]; then\n\t\ttput setaf 1\n\t\techo \"Template File Already Exists!\"\n\t\techo $TemplateFileName\n\t\tread -r -p \"Overwrite? (y/n) \" OVERWRITE\n\t\tif ! [[ $OVERWRITE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\techo \"Canceled.\"\n\t\t\ttput sgr0\n\t\t\texit 1\n\t\tfi\n\t\ttput sgr0\n\tfi\n\n\n\n\tDescribeLB=$(aws elb describe-load-balancers --load-balancer-names $ELBname --profile $profile 2>&1)\n\tif echo $DescribeLB | grep -q \"could not be found\"; then\n\t\tfail \"$DescribeLB\"\n\tfi\n\tif echo $DescribeLB | grep -q \"error\"; then\n\t\tfail \"$DescribeLB\"\n\telse\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Creating Template File\"\n\t\tHorizontalRule\n\t\techo\n\t\techo \"$DescribeLB\" > \"$TemplateFileName\"1\n\tfi\n\n\tDescribeAttributes=$(aws elb describe-load-balancer-attributes --load-balancer-name $ELBname --profile $profile 2>&1)\n\tif echo $DescribeAttributes | grep -q \"error\"; then\n\t\tfail \"$DescribeAttributes\"\n\telse\n\t\techo \"$DescribeAttributes\" > \"$TemplateFileName\"2\n\tfi\n\n\t# Combine output of describe-load-balancers and describe-load-balancer-attributes to a single JSON array\n\tjq -s add \"$TemplateFileName\"1 \"$TemplateFileName\"2 > $TemplateFileName && rm \"$TemplateFileName\"1 \"$TemplateFileName\"2\n\n\t# Verify Template file created\n\tif ! [ -f $TemplateFileName ]; then\n\t\tfail \"Unable to create template file:\" $TemplateFileName\n\telse\n\t\techo $TemplateFileName\n\tfi\n\tCompleted\nfi\n\n\n# Create New ELB\nif [ \"$CreateNewELB\" = \"true\" ]; then\n\t# Ensure Variables are set\n\tif [ \"$NewELBname\" = \"YOUR-NEW-ELB-NAME-HERE\" ] || [ -z \"$NewELBname\" ]; then\n\t\tfail \"Must set variable for new ELB name!\"\n\tfi\n\n\t# Check for an existing ELB with the same name as the new ELB\n\tTestNewELB=$(aws elb describe-load-balancers --load-balancer-names $NewELBname --profile $profile 2>&1)\n\tif echo \"$TestNewELB\" | grep -q \"An error occurred\"; then\n\t\techo\n\telse\n\t\ttput setaf 1\n\t\techo \"An ELB Named $NewELBname Already Exists!\"\n\t\tread -r -p \"Continue and update the existing ELB $NewELBname with configuration from ELB $ELBname? (y/n) \" CONTINUE\n\t\tif ! [[ $CONTINUE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\techo \"Canceled.\"\n\t\t\ttput sgr0\n\t\t\texit 1\n\t\tfi\n\tfi\n\n\t# Verify Template file exists\n\tif ! [ -f $TemplateFileName ]; then\n\t\tfail \"Unable to find template file:\" $TemplateFileName\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Creating New ELB\"\n\tHorizontalRule\n\techo\n\n\t# Read the Template file and store as var\n\tjsoninput=$(cat $TemplateFileName)\n\n\tLoadBalancerName=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .LoadBalancerName' | cut -d \\\" -f2)\n\n\t# Determine number of Listeners\n\tNumListeners=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | length')\n\n\tif [ \"$NumListeners\" -gt \"2\" ]; then\n\t\tfail \"ELB with more than 2 listeners not yet supported.\"\n\tfi\n\n\t# Determine if Listeners include SSL\n\tif echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .Protocol' | grep -qw \"HTTPS\"; then\n\t\tHTTPS=true\n\t\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\t\techo \"Found listener with SSL.\"\n\t\t\techo\n\t\t\techo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol!=\"HTTPS\")'\n\t\t\techo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol==\"HTTPS\")'\n\t\tfi\n\tfi\n\n\tif [ \"$NumListeners\" -eq \"1\" ]; then\n\t\t# One Listener\n\t\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\t\techo \"Found 1 listener.\"\n\t\tfi\n\t\tif [ \"$HTTPS\" = \"true\" ]; then\n\t\t\t# One Listener with SSL\n\t\t\tProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .Protocol' | cut -d \\\" -f2)\n\t\t\tInstanceProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .InstanceProtocol' | cut -d \\\" -f2)\n\t\t\tLoadBalancerPort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .LoadBalancerPort' | cut -d \\\" -f2)\n\t\t\tInstancePort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .InstancePort' | cut -d \\\" -f2)\n\t\t\tSSLCertificateId=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .SSLCertificateId' | cut -d \\\" -f2)\n\t\telse\n\t\t\t# One Listener without SSL\n\t\t\tProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .Protocol' | cut -d \\\" -f2)\n\t\t\tInstanceProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .InstanceProtocol' | cut -d \\\" -f2)\n\t\t\tLoadBalancerPort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .LoadBalancerPort' | cut -d \\\" -f2)\n\t\t\tInstancePort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | .InstancePort' | cut -d \\\" -f2)\n\t\tfi\n\n\tfi\n\n\tif [ \"$NumListeners\" -eq \"2\" ]; then\n\t\t# Two Listeners\n\t\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\t\techo \"Found 2 listeners.\"\n\t\tfi\n\t\t# Two Listeners one with SSL one without\n\t\tif [ \"$HTTPS\" = \"true\" ]; then\n\t\t\tProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol==\"HTTPS\") | .Protocol' | cut -d \\\" -f2)\n\t\t\tInstanceProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol==\"HTTPS\") | .InstanceProtocol' | cut -d \\\" -f2)\n\t\t\tLoadBalancerPort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol==\"HTTPS\") | .LoadBalancerPort' | cut -d \\\" -f2)\n\t\t\tInstancePort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol==\"HTTPS\") | .InstancePort' | cut -d \\\" -f2)\n\t\t\tSSLCertificateId=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol==\"HTTPS\") | .SSLCertificateId' | cut -d \\\" -f2)\n\n\t\t\tProtocol2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol!=\"HTTPS\") | .Protocol' | cut -d \\\" -f2)\n\t\t\tInstanceProtocol2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol!=\"HTTPS\") | .InstanceProtocol' | cut -d \\\" -f2)\n\t\t\tLoadBalancerPort2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol!=\"HTTPS\") | .LoadBalancerPort' | cut -d \\\" -f2)\n\t\t\tInstancePort2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[] | .Listener | select(.Protocol!=\"HTTPS\") | .InstancePort' | cut -d \\\" -f2)\n\t\telse\n\t\t\t# Two Listeners both without SSL\n\t\t\tProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[0] | .Listener | .Protocol' | cut -d \\\" -f2)\n\t\t\tInstanceProtocol=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[0] | .Listener | .InstanceProtocol' | cut -d \\\" -f2)\n\t\t\tLoadBalancerPort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[0] | .Listener | .LoadBalancerPort' | cut -d \\\" -f2)\n\t\t\tInstancePort=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[0] | .Listener | .InstancePort' | cut -d \\\" -f2)\n\n\t\t\tProtocol2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[1] | .Listener | .Protocol' | cut -d \\\" -f2)\n\t\t\tInstanceProtocol2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[1] | .Listener | .InstanceProtocol' | cut -d \\\" -f2)\n\t\t\tLoadBalancerPort2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[1] | .Listener | .LoadBalancerPort' | cut -d \\\" -f2)\n\t\t\tInstancePort2=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .ListenerDescriptions | .[1] | .Listener | .InstancePort' | cut -d \\\" -f2)\n\t\tfi\n\tfi\n\n\tInstances=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .Instances')\n\tAvailabilityZones=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .AvailabilityZones')\n\tSubnets=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .Subnets')\n\tSecurityGroups=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .SecurityGroups')\n\tScheme=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .Scheme' | cut -d \\\" -f2)\n\n\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\techo \"$LoadBalancerName\"\n\t\techo \"$Protocol\"\n\t\techo \"$InstanceProtocol\"\n\t\techo \"$LoadBalancerPort\"\n\t\techo \"$InstancePort\"\n\t\techo \"$Instances\"\n\t\techo \"$AvailabilityZones\"\n\t\techo \"$Subnets\"\n\t\techo \"$SecurityGroups\"\n\t\techo \"$Scheme\"\n\t\techo \"$SSLCertificateId\"\n\tfi\n\n\t# Store ELB as JSON\n\tLoadBalancerName=$NewELBname\n\n\t# Generate JSON based on one listener\n\tif [ \"$NumListeners\" -eq \"1\" ]; then\n\t\tif [ \"$HTTPS\" = \"true\" ]; then\n\t\t\tjson='{\n\t\t\t\t\"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t\t\t\"Listeners\": [\n\t\t\t\t{\n\t\t\t\t\t\"Protocol\": \"'$Protocol'\",\n\t\t\t\t\t\"LoadBalancerPort\": '$LoadBalancerPort',\n\t\t\t\t\t\"InstanceProtocol\": \"'$InstanceProtocol'\",\n\t\t\t\t\t\"InstancePort\": '$InstancePort',\n\t\t\t\t\t\"SSLCertificateId\": \"'$SSLCertificateId'\"\n\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"Subnets\": '$Subnets',\n\t\t\t\t\"SecurityGroups\": '$SecurityGroups',\n\t\t\t\t\"Scheme\": \"'$Scheme'\"\n\t\t\t}' # > output.json\n\t\telse\n\t\t\tjson='{\n\t\t\t\t\"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t\t\t\"Listeners\": [\n\t\t\t\t{\n\t\t\t\t\t\"Protocol\": \"'$Protocol'\",\n\t\t\t\t\t\"LoadBalancerPort\": '$LoadBalancerPort',\n\t\t\t\t\t\"InstanceProtocol\": \"'$InstanceProtocol'\",\n\t\t\t\t\t\"InstancePort\": '$InstancePort'\n\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"Subnets\": '$Subnets',\n\t\t\t\t\"SecurityGroups\": '$SecurityGroups',\n\t\t\t\t\"Scheme\": \"'$Scheme'\"\n\t\t\t}' # > output.json\n\t\tfi\n\tfi\n\n\t# Generate JSON based on two listeners\n\tif [ \"$NumListeners\" -eq \"2\" ]; then\n\t\tif [ \"$HTTPS\" = \"true\" ]; then\n\t\t\tjson='{\n\t\t\t\t\"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t\t\t\"Listeners\": [\n\t\t\t\t{\n\t\t\t\t\t\"Protocol\": \"'$Protocol'\",\n\t\t\t\t\t\"LoadBalancerPort\": '$LoadBalancerPort',\n\t\t\t\t\t\"InstanceProtocol\": \"'$InstanceProtocol'\",\n\t\t\t\t\t\"InstancePort\": '$InstancePort',\n\t\t\t\t\t\"SSLCertificateId\": \"'$SSLCertificateId'\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"Protocol\": \"'$Protocol2'\",\n\t\t\t\t\t\"LoadBalancerPort\": '$LoadBalancerPort2',\n\t\t\t\t\t\"InstanceProtocol\": \"'$InstanceProtocol2'\",\n\t\t\t\t\t\"InstancePort\": '$InstancePort2'\n\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"Subnets\": '$Subnets',\n\t\t\t\t\"SecurityGroups\": '$SecurityGroups',\n\t\t\t\t\"Scheme\": \"'$Scheme'\"\n\t\t\t}' # > output.json\n\t\telse\n\t\t\tjson='{\n\t\t\t\t\"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t\t\t\"Listeners\": [\n\t\t\t\t{\n\t\t\t\t\t\"Protocol\": \"'$Protocol'\",\n\t\t\t\t\t\"LoadBalancerPort\": '$LoadBalancerPort',\n\t\t\t\t\t\"InstanceProtocol\": \"'$InstanceProtocol'\",\n\t\t\t\t\t\"InstancePort\": '$InstancePort'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"Protocol\": \"'$Protocol2'\",\n\t\t\t\t\t\"LoadBalancerPort\": '$LoadBalancerPort2',\n\t\t\t\t\t\"InstanceProtocol\": \"'$InstanceProtocol2'\",\n\t\t\t\t\t\"InstancePort\": '$InstancePort2'\n\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"Subnets\": '$Subnets',\n\t\t\t\t\"SecurityGroups\": '$SecurityGroups',\n\t\t\t\t\"Scheme\": \"'$Scheme'\"\n\t\t\t}' # > output.json\n\t\tfi\n\tfi\n\n\t# json=$(cat output.json)\n\n\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\techo \"Sending request to create new ELB with AWS now...\"\n\tfi\n\n\t# Create new ELB from JSON\n\tCreateLoadBalancer=$(aws elb create-load-balancer --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif ! echo \"$CreateLoadBalancer\" | grep -qw \"DNSName\"; then\n\t\tfail \"$CreateLoadBalancer\"\n\telse\n\t\techo \"$CreateLoadBalancer\" | jq .\n\t\tCompleted\n\tfi\n\n\t# Register Instances with ELB\n\tif [ \"$RegisterInstances\" = \"true\" ]; then\n\n\t\tHorizontalRule\n\t\techo \"Registering Instances with New ELB\"\n\t\tHorizontalRule\n\t\techo\n\n\t\t# Store Instances as JSON\n\t\tjson1='{\n\t\t    \"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t    \"Instances\": '$Instances'\n\t\t}' # > output1.json\n\n\t\t# json1=$(cat output1.json)\n\n\t\t# Register Instances with ELB\n\t\tRegisterInstances=$(aws elb register-instances-with-load-balancer --cli-input-json \"$json1\" --profile $profile 2>&1)\n\t\tif ! echo \"$RegisterInstances\" | grep -qw \"Instances\"; then\n\t\t\tfail \"$RegisterInstances\"\n\t\telse\n\t\t\techo \"$RegisterInstances\" | jq .\n\t\t\tCompleted\n\t\tfi\n\tfi\n\n\t# Healthcheck\n\tif [ \"$ConfigureHealthCheck\" = \"true\" ]; then\n\n\t\tHorizontalRule\n\t\techo \"Configuring ELB Healthcheck\"\n\t\tHorizontalRule\n\t\techo\n\n\t\t# Store Healthcheck as JSON\n\t\tTarget=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .HealthCheck | .Target' | cut -d \\\" -f2)\n\t\tInterval=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .HealthCheck | .Interval' | cut -d \\\" -f2)\n\t\tTimeout=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .HealthCheck | .Timeout' | cut -d \\\" -f2)\n\t\tUnhealthyThreshold=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .HealthCheck | .UnhealthyThreshold' | cut -d \\\" -f2)\n\t\tHealthyThreshold=$(echo $jsoninput | jq '.LoadBalancerDescriptions | .[] | .HealthCheck | .HealthyThreshold' | cut -d \\\" -f2)\n\n\t\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\t\techo \"$Target\"\n\t\t\techo \"$Interval\"\n\t\t\techo \"$Timeout\"\n\t\t\techo \"$UnhealthyThreshold\"\n\t\t\techo \"$HealthyThreshold\"\n\t\tfi\n\n\t\tjson2='{\n\t\t    \"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t    \"HealthCheck\": {\n\t\t        \"Target\": \"'$Target'\",\n\t\t        \"Interval\": '$Interval',\n\t\t        \"Timeout\": '$Timeout',\n\t\t        \"UnhealthyThreshold\": '$UnhealthyThreshold',\n\t\t        \"HealthyThreshold\": '$HealthyThreshold'\n\t\t    }\n\t\t}' # > output2.json\n\n\t\t# json2=$(cat output2.json)\n\n\n\t\t# Configure Healthcheck from JSON\n\t\tConfigureHealthCheck=$(aws elb configure-health-check --cli-input-json \"$json2\" --profile $profile 2>&1)\n\t\tif ! echo \"$ConfigureHealthCheck\" | grep -qw \"HealthCheck\"; then\n\t\t\tfail \"$ConfigureHealthCheck\"\n\t\telse\n\t\t\techo \"$ConfigureHealthCheck\" | jq .\n\t\t\tCompleted\n\t\tfi\n\tfi\n\n\t# Attributes\n\tif [ \"$ConfigureAttributes\" = \"true\" ]; then\n\n\t\tHorizontalRule\n\t\techo \"Configuring ELB Attributes\"\n\t\tHorizontalRule\n\t\techo\n\n\t\t# Store Attributes as JSON\n\t\tConnectionDraining=$(echo $jsoninput | jq '.LoadBalancerAttributes | .ConnectionDraining | .Enabled' | cut -d \\\" -f2)\n\t\tConnectionDrainingTimeout=$(echo $jsoninput | jq '.LoadBalancerAttributes | .ConnectionDraining | .Timeout' | cut -d \\\" -f2)\n\t\tCrossZoneLoadBalancing=$(echo $jsoninput | jq '.LoadBalancerAttributes | .CrossZoneLoadBalancing | .Enabled' | cut -d \\\" -f2)\n\t\tConnectionSettings=$(echo $jsoninput | jq '.LoadBalancerAttributes | .ConnectionSettings | .IdleTimeout' | cut -d \\\" -f2)\n\t\tAccessLog=$(echo $jsoninput | jq '.LoadBalancerAttributes | .AccessLog | .Enabled' | cut -d \\\" -f2)\n\n\t\tif [ \"$DEBUGMODE\" -eq \"1\" ]; then\n\t\t\techo \"$ConnectionDraining\"\n\t\t\techo \"$ConnectionDrainingTimeout\"\n\t\t\techo \"$CrossZoneLoadBalancing\"\n\t\t\techo \"$ConnectionSettings\"\n\t\t\techo \"$AccessLog\"\n\t\tfi\n\n\t\tjson3='{\n\t\t  \"LoadBalancerName\": \"'$LoadBalancerName'\",\n\t\t  \"LoadBalancerAttributes\": {\n\t\t    \"CrossZoneLoadBalancing\": {\n\t\t      \"Enabled\": '$CrossZoneLoadBalancing'\n\t\t    },\n\t\t    \"AccessLog\": {\n\t\t      \"Enabled\": '$AccessLog'\n\t\t    },\n\t\t    \"ConnectionDraining\": {\n\t\t      \"Enabled\": '$ConnectionDraining',\n\t\t      \"Timeout\": '$ConnectionDrainingTimeout'\n\t\t    },\n\t\t    \"ConnectionSettings\": {\n\t\t      \"IdleTimeout\": '$ConnectionSettings'\n\t\t    }\n\t\t  }\n\t\t}' # > output3.json\n\n\t\t# json3=$(cat output3.json)\n\n\n\t\t# Configure Attributes from JSON\n\t\tConfigureAttributes=$(aws elb modify-load-balancer-attributes --cli-input-json \"$json3\" --profile $profile 2>&1)\n\t\tif ! echo \"$ConfigureAttributes\" | grep -qw \"LoadBalancerAttributes\"; then\n\t\t\tfail \"$ConfigureAttributes\"\n\t\telse\n\t\t\techo \"$ConfigureAttributes\" | jq .\n\t\t\tCompleted\n\t\tfi\n\tfi\n\techo\n\tHorizontalRule\n\techo Created new ELB: $NewELBname\n\tHorizontalRule\n\techo\nfi\n"
        },
        {
          "name": "ec2-elb-upload-ssl-cert.sh",
          "type": "blob",
          "size": 3.7734375,
          "content": "#!/usr/bin/env bash\n# This script will upload an SSL Certificate to AWS for use in setting up an ELB\n# Requires AWS CLI Setup and jq\n\nDEBUGMODE=0\n\n\n\n# Functions\n\n# Check required commands\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Prepare to import the SSL Certificate\nfunction prepare(){\n\techo \"=====================================================\"\n\ttput setaf 2; echo \"This script will import an SSL Certificate to AWS for use in setting up an ELB or CloudFront\" && tput sgr0\n\techo \"=====================================================\"\n\techo\n\tread -r -p \"Enter the desired certificate name or website domain: (ex. domain.com): \" DOMAIN\n\t# echo \"Go to your SSL certificate issuing service account and see instructions to download certificates.\"\n\t# echo \"Note you may need to seperate the public key from the certificate bundle chain into seperate files.\"\n\t# read -r -p \"Enter the cert expiration date in MMDDYYYY format: (ex. 01162015) \" EXPDATE\n\techo\n\tread -r -p \"Enter the path and file name of the public key file: (ex. STAR_domain_com_public.pem) \" PUBKEY\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"PUB KEY FILE: $PUBKEY\"\n\tfi\n\tPUBKEY=$(eval cat \"$PUBKEY\")\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"PUB KEY:\"\n\t\techo \"$PUBKEY\"\n\t\tpause\n\tfi\n\techo\n\tread -r -p \"Enter the path and file name of the private key file: (ex. STAR_domain_com.key) \" PRIVATE\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"PRIVATE FILE: \"$PRIVATE\n\tfi\n\tPRIVATE=$(eval cat $PRIVATE)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"PRIVATE KEY:\"\n\t\techo \"$PRIVATE\"\n\tfi\n\techo\n\tread -r -p \"Enter the path and file name of the certificate chain file: (ex. STAR_domain_com.pem) \" CHAIN\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"CHAIN FILE: \"$CHAIN\n\tfi\n\tCHAIN=$(eval cat $CHAIN)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"CHAIN:\"\n\t\techo \"$CHAIN\"\n\tfi\n\techo\n}\n\nfunction import(){\n\tif [ -z \"$profile\" ]; then\n\t\tIMPORT=$(aws iam upload-server-certificate --server-certificate-name \"$DOMAIN\" --certificate-body \"$PUBKEY\" --private-key \"$PRIVATE\" --certificate-chain \"$CHAIN\" 2>&1)\n\telse\n\t\tIMPORT=$(aws iam upload-server-certificate --profile $profile --server-certificate-name \"$DOMAIN\" --certificate-body \"$PUBKEY\" --private-key \"$PRIVATE\" --certificate-chain \"$CHAIN\" 2>&1)\n\tfi\n\t# aws iam upload-server-certificate --server-certificate-name \"$DOMAIN\" --certificate-body file://\"$PUBKEY\" --private-key file://\"$PRIVATE\" --certificate-chain file://\"$CHAIN\"\n\t# aws iam upload-server-certificate --server-certificate-name $DOMAIN-$EXPDATE --certificate-body file://$PUBKEY --private-key file://$PRIVATE --certificate-chain file://$CHAIN\n\tif echo $IMPORT | grep -q error; then\n\t\techo \"=====================================================\"\n\t\tfail \"$IMPORT\"\n\telse\n\t\techo \"=====================================================\"\n\t\ttput setaf 2; echo \"$IMPORT\" | jq . && tput sgr0\n\t\techo \"=====================================================\"\n\t\techo\n\t\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\t\techo\n\tfi\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Test for optional variable passed as argument and set as AWS CLI profile name\nif ! [ -z \"$1\" ]; then\n\tprofile=\"$1\"\nelse\n\techo \"Note: You can pass in an AWS CLI profile name as an argument when running the script.\"\n\techo \"Example: ./ec2-elb-upload-ssl-cert.sh profilename\"\n\tpause\n\techo\nfi\n\ncheck_command \"aws\"\ncheck_command \"jq\"\n\nprepare\nimport\n\n"
        },
        {
          "name": "elastic-beanstalk-set-hostname-within-instance.sh",
          "type": "blob",
          "size": 1.4970703125,
          "content": "#!/usr/bin/env bash\n# This script sets the hostname on Elastic Beanstalk servers from within the instance with their EB environment name and public IP address\n# It also will restart New Relic monitoring if present\n# Requires \"ec2:Describe*\" IAM Policy\n\n\n# Remove any previous scripts\nfunction cleanup(){\n\tif [ -f /home/ec2-user/ebenvironmentname.py ]; then\n\t\trm /home/ec2-user/ebenvironmentname.py\n\tfi\n\tif [ -f /home/ec2-user/sethostname.sh ]; then\n\t\trm /home/ec2-user/sethostname.sh\n\tfi\n}\n\ncleanup\n\n# Create the Python script to detect EB Environment\ncat > /home/ec2-user/ebenvironmentname.py <<- EOF\n\t#!/usr/bin/env python\n\n\timport boto.utils\n\timport boto.ec2\n\n\tiid_doc = boto.utils.get_instance_identity()['document']\n\tregion = iid_doc['region']\n\tinstance_id = iid_doc['instanceId']\n\n\tec2 = boto.ec2.connect_to_region(region)\n\tinstance = ec2.get_only_instances(instance_ids=[instance_id])[0]\n\tenv = instance.tags['elasticbeanstalk:environment-name']\n\n\tprint(env)\nEOF\n\nchmod +x /home/ec2-user/ebenvironmentname.py\n\n# Set Hostname\necho '#!/usr/bin/env bash' >> /home/ec2-user/sethostname.sh\necho ebenvironmentname=\\$\\(./ebenvironmentname.py\\) >> /home/ec2-user/sethostname.sh\necho sudo hostname '\"$ebenvironmentname\"'-\"$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)\" >> /home/ec2-user/sethostname.sh\necho \"chkconfig --list newrelic-sysmond &> /dev/null && sudo service newrelic-sysmond restart\" >> /home/ec2-user/sethostname.sh\nchmod +x /home/ec2-user/sethostname.sh\n\ncd /home/ec2-user/ && ./sethostname.sh\n\ncleanup\n"
        },
        {
          "name": "elastic-beanstalk-update-hostnames.sh",
          "type": "blob",
          "size": 4.3994140625,
          "content": "#!/usr/bin/env bash\n\n# This script updates the hostname on Elastic Beanstalk servers with their environment name and IP address\n# It also will restart New Relic monitoring if present\n# Requires the AWS CLI and jq\n\n\n# Set Variables\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n# Get Elastic Beanstalk Environments\nfunction ebenvironments(){\n\tdescribeenvironments=$(aws elasticbeanstalk describe-environments --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeenvironments\"\n\tfi\n\tebenvironments=$(echo \"$describeenvironments\" | jq '.Environments | .[] | .EnvironmentName' | cut -d \\\" -f2)\n\tif [ -z \"$ebenvironments\" ]; then\n\t\tfail \"No Elastic Beanstalk Environments found.\"\n\tfi\n\techo \"EB Environments Found:\"\n\tHorizontalRule\n\techo \"$ebenvironments\"\n\tHorizontalRule\n}\n\n# Get Elastic Beanstalk Environment Resources\nfunction ebresources(){\n\twhile IFS= read -r ebenvironments\n\tdo\n\t\tdescribeebresources=$(aws elasticbeanstalk describe-environment-resources --environment-name $ebenvironments --output=json --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$describeebresources\"\n\t\tfi\n\t\tebresources=$(echo \"$describeebresources\" | jq '.EnvironmentResources | .Instances | .[] | .Id' | cut -d \\\" -f2)\n\t\tif [ -z \"$ebresources\" ]; then\n\t\t\tfail \"No Elastic Beanstalk Environment Resources found.\"\n\t\tfi\n\t\techo \"EB Server IDs Found for Environment $ebenvironments:\"\n\t\tHorizontalRule\n\t\techo \"$ebresources\"\n\t\tHorizontalRule\n\n\t\tebresourcescount=$(echo \"$ebresources\" | wc -l)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ebresourcescount \"$ebresourcescount\"\n\t\tfi\n\t\tebresourceslist=$(echo \"$ebresources\" | nl)\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo ebresourceslist \"$ebresourceslist\"\n\t\tfi\n\t\t# Get IP Address\n\t\tSTART=1\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Getting IP for $ebresourcescount instance(s).\"\n\t\tfi\n\t\tfor (( COUNT=$START; COUNT<=$ebresourcescount; COUNT++ ))\n\t\tdo\n\t\t\tcurrentinstanceid=$(echo \"$ebresourceslist\" | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"Getting IP for Instance ID: $currentinstanceid\"\n\t\t\tfi\n\t\t\tdescribeinstances=$(aws ec2 describe-instances --instance-ids \"$currentinstanceid\" --query 'Reservations[*].Instances[*].PublicIpAddress' --output=json --profile $profile 2>&1)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$describeinstances\"\n\t\t\tfi\n\t\t\tgetipaddr=$(echo \"$describeinstances\" | jq '.[] | .[]' | cut -d \\\" -f2)\n\t\t\techo \"IP Address: $getipaddr\"\n\t\t\t# Set Hostname\n\t\t\techo '#!/usr/bin/env bash' >> sethostname.sh\n\t\t\techo \"sudo sed -i 's/Defaults    requiretty/#Defaults    requiretty/g' /etc/sudoers\" >> sethostname.sh\n\t\t\techo sudo hostname \"$ebenvironments\"-\"$getipaddr\" >> sethostname.sh\n\t\t\techo \"chkconfig --list newrelic-sysmond &> /dev/null && sudo service newrelic-sysmond restart\" >> sethostname.sh\n\t\t\tchmod +x sethostname.sh\n\t\t\tuploadhostnamescript=$(scp -o StrictHostKeyChecking=no sethostname.sh $getipaddr:~)\n\t\t\tsethostname=$(ssh -n $getipaddr '(./sethostname.sh)')\n\t\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\t\techo \"$sethostname\"\n\t\t\tfi\n\t\t\trm sethostname.sh\n\t\tdone\n\tdone <<< \"$ebenvironments\"\n\tcompleted\n}\n\nebenvironments\n# ebenvironments=\"set one environment here to override the lookup\"\nebresources\n"
        },
        {
          "name": "equality_test.sh",
          "type": "blob",
          "size": 0.0751953125,
          "content": "#!/bin/sh\n\ntestEquality() {\n\tassertEquals 1 1\n}\n\n. shunit2-2.1.6/src/shunit2\n"
        },
        {
          "name": "iam-create-s3-users.sh",
          "type": "blob",
          "size": 2.2734375,
          "content": "#!/usr/bin/env bash\n# This script will create the S3 IAM user, generate IAM keys, add to IAM group, generate user policy\n# You will want to modify for your own naming conventions and IAM user group name\n# Requires awscli and local IAM account with sufficient permissions\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    echo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n    exit 1\n  fi\nfi\n\necho \"This script will create the S3 IAM user, generate IAM keys, add to IAM group, generate user policy.\"\nread -r -p \"Enter the client name: \" CLIENT\n\necho \" \"\necho \"=====================================================\"\necho \"Creating IAM User: \"s3-$CLIENT\naws iam create-user --user-name s3-$CLIENT --output json\necho \"=====================================================\"\necho \" \"\necho \"=====================================================\"\necho \"Generating IAM Access Keys\"\naws iam create-access-key --user-name s3-$CLIENT --output json\necho \"=====================================================\"\necho \" \"\necho \"=====================================================\"\necho \"Adding to IAM Group\"\naws iam add-user-to-group --user-name s3-$CLIENT --group-name s3-users\n\ncat > userpolicy.json << EOL\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:*\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::$CLIENT-dev\",\n                \"arn:aws:s3:::$CLIENT-dev/*\",\n                \"arn:aws:s3:::$CLIENT-production\",\n                \"arn:aws:s3:::$CLIENT-production/*\",\n                \"arn:aws:s3:::$CLIENT-staging\",\n                \"arn:aws:s3:::$CLIENT-staging/*\"\n            ]\n        }\n    ]\n}\nEOL\necho \" \"\necho \"=====================================================\"\necho \"Generating User Policy\"\naws iam put-user-policy --user-name s3-$CLIENT --policy-name $CLIENT-s3-buckets --policy-document file://userpolicy.json\nrm userpolicy.json\necho \" \"\necho \"=====================================================\"\necho \"Completed!  Created user: \"s3-$CLIENT\necho \"=====================================================\"\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "install-awscli.sh",
          "type": "blob",
          "size": 0.7314453125,
          "content": "#!/usr/bin/env bash\n\n# This script will install the AWS CLI\n# Requires Homebrew, Python, pip\n\nread -rp \"Install and Configure AWS CLI? (y/n) \" INSTALL\nif [[ $INSTALL =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\n\t# Test if pip is installed\n\tcommand -v pip >/dev/null 2>&1 || {\n\t\tbrew install python\n\n\t\techo \"Installing Python pip\"\n\t\tsudo easy_install pip && echo; echo \"Installed Python pip.\"\n\t}\n\n\t# Test if AWS CLI is installed\n\tcommand -v aws >/dev/null 2>&1 || {\n\t\techo \"Installing awscli\"\n\t\tpip install awscli --upgrade --user && echo; echo \"Installed awscli.\"\n\n\t\taws configure\n\t\tcomplete -C '/usr/local/bin/aws_completer' aws\n\t} && {\n\t\techo \"Updating awscli\"\n\t\tpip install awscli --upgrade --user && echo; echo \"Updated awscli.\"\n\t}\n\n\techo \"Completed.\"\nfi\n"
        },
        {
          "name": "install-s3cmd.sh",
          "type": "blob",
          "size": 0.533203125,
          "content": "#!/usr/bin/env bash\n\n# This script downloads s3cmd from the git repo, installs and starts setup\n# Requires Python\n\nread -rp \"Install and Configure s3cmd? (y/n) \" INSTALL\nif [[ $INSTALL =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\n\t# Test if already installed\n\tcommand -v s3cmd >/dev/null 2>&1 || {\n\t\tcd ~\n\t\tgit clone https://github.com/s3tools/s3cmd.git\n\t\tcd s3cmd\n\t\tsudo python setup.py install\n\t\tread -rp \"Configure s3cmd? (y/n) \" CONFIGURE\n\t\t\tif [[ $CONFIGURE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\t\ts3cmd --configure\n\t\t\tfi\n\t}\n\techo\n\techo \"Completed.\"\nfi\n"
        },
        {
          "name": "route53-export-zones.sh",
          "type": "blob",
          "size": 3.8408203125,
          "content": "#!/usr/bin/env bash\n# This script will use cli53 to export the zone file for each Hosted Zone domain in Route 53 for git version control\n# Requires Python, pip, awscli, cli53\n# For more info on cli53 see https://github.com/barnybug/cli53\n# Download here: https://github.com/barnybug/cli53/releases/latest\n\n# Functions\n\n# Check required commands\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\ncheck_command \"cli53\"\n\n# # Test if cli53 already installed, else install it\n# command -v cli53 >/dev/null 2>&1 || {\n# \techo \"Installing cli53.\"\n# \tsudo pip install cli53\n# \techo \"cli53 installed.\"\n# }\n\n# Test for ~/.boto file\n# if ! [ -f ~/.boto ]; then\n# \t# read -rp \"Attempt to configure cli53 using AWS CLI credentials? (y/n) \" CONFIGURE\n# \t# if [[ $CONFIGURE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n# \t# Look for AWS CLI credentials\n# \techo \"Attempting to configure cli53 using AWS CLI credentials...\"\n# \tif grep -q aws_access_key_id ~/.aws/config; then\n# \t\texport AWS_ACCESS_KEY_ID=$(grep aws_access_key_id ~/.aws/config | cut -d ' ' -f3)\n# \t\texport AWS_SECRET_ACCESS_KEY=$(grep aws_secret_access_key ~/.aws/config | cut -d ' ' -f3)\n# \telif grep -q aws_access_key_id ~/.aws/credentials; then\n# \t\texport AWS_ACCESS_KEY_ID=$(grep aws_access_key_id ~/.aws/credentials | cut -d ' ' -f3)\n# \t\texport AWS_SECRET_ACCESS_KEY=$(grep aws_secret_access_key ~/.aws/credentials | cut -d ' ' -f3)\n# \telse\n# \t\techo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n# \t\texit 1\n# \tfi\n\n# \techo \"Found AWS_ACCESS_KEY_ID:\" $AWS_ACCESS_KEY_ID\n# \techo \"Found AWS_SECRET_ACCESS_KEY:\" $AWS_SECRET_ACCESS_KEY\n# \techo \"Building ~/.boto config file with these credentials...\"\n\n# \t# Build ~/.boto config file\n# \techo \"[Credentials]\" >> ~/.boto\n# \techo \"aws_access_key_id = \"$AWS_ACCESS_KEY_ID >> ~/.boto\n# \techo \"aws_secret_access_key = \"$AWS_SECRET_ACCESS_KEY >> ~/.boto\n\n# fi\n\n# Get list of Hosted Zones in Route 53\nDOMAINLIST=$(aws route53 list-hosted-zones --output text --profile $profile | cut -f 4 | rev | cut -c 2- | rev | grep -v '^$')\n\nif [ -z \"$DOMAINLIST\" ]; then\n\tfail \"No hosted zones found in Route 53!\"\nfi\n\n# Count domains found\nTOTALDOMAINS=$(echo \"$DOMAINLIST\" | wc -l)\n\necho\nHorizontalRule\necho \"Exporting Zone Files for Route 53 Hosted Zones\"\necho \"Total number of Hosted Zones: \"$TOTALDOMAINS\nHorizontalRule\n\necho \"$DOMAINLIST\"\necho\n\nif ! [ -d route53zones/$profile/ ]; then\n\tmkdir -p route53zones/$profile\nfi\n\n# Export Hosted Zones\nSTART=1\nfor (( COUNT=$START; COUNT<=$TOTALDOMAINS; COUNT++ ))\ndo\n\tHorizontalRule\n\techo \\#$COUNT\n\tDOMAIN_ID=$(echo \"$DOMAINLIST\" | nl | grep -w $COUNT | cut -f 2)\n\tcli53 export --full --profile $profile $DOMAIN_ID > route53zones/$profile/$DOMAIN_ID.zone\n\techo \"Exported: \"$DOMAIN_ID\ndone\n\n# Remove any empty zone file created\nif [ -f route53zones/$profile/.zone ]; then\n\trm route53zones/$profile/.zone\nfi\n\ncompleted\n"
        },
        {
          "name": "route53-record-set.sh",
          "type": "blob",
          "size": 1.302734375,
          "content": "#!/usr/bin/env bash\n\nHOSTEDZONEID=\"id\"\nprofile=\"xyz\"\n\ncat > change-batch.json << EOL\n{\"Comment\":\"test\",\"Changes\":[{\"Action\":\"CREATE\",\"ResourceRecordSet\":{\"Name\":\"mail.shawnwoodford.com\",\"Type\":\"CNAME\",\"Region\":\"us-east-1\",\"TTL\":300,\"ResourceRecords\":[{\"Value\":\"ghs.googlehosted.com\"}]}}]}\nEOL\n\n# aws route53 change-resource-record-sets --hosted-zone-id $HOSTEDZONEID --profile $profile --cli-input-json '\n# {\n#   \"HostedZoneId\": \"$HOSTEDZONEID\",\n#   \"ChangeBatch\": {\n#     \"Comment\": \"test\",\n#     \"Changes\": [{\n#       \"Action\": \"CREATE\",\n#       \"ResourceRecordSet\": {\n#         \"Name\": \"mail.shawnwoodford.com\",\n#         \"Type\": \"CNAME\",\n#         \"Region\": \"us-east-1\",\n#         \"TTL\": 300,\n#         \"ResourceRecords\": [{\n#           \"Value\": \"ghs.googlehosted.com\"\n#         }]\n#       }\n#     }]\n#   }\n# }'\n\n# rm change-batch.json\n\n# aws route53 change-resource-record-sets --hosted-zone-id $HOSTEDZONEID --profile $profile --cli-input-json '{\"HostedZoneId\":\"$HOSTEDZONEID\",\"ChangeBatch\":{\"Comment\":\"test\",\"Changes\":[{\"Action\":\"CREATE\",\"ResourceRecordSet\":{\"Name\":\"mail.shawnwoodford.com\",\"Type\":\"CNAME\",\"Region\":\"us-east-1\",\"TTL\":300,\"ResourceRecords\":[{\"Value\":\"ghs.googlehosted.com\"}]}}]}}'\n\naws route53 change-resource-record-sets --hosted-zone-id $HOSTEDZONEID --profile $profile --change-batch file://change-batch.json\n"
        },
        {
          "name": "s3-buckets-file-size-s3cmd.sh",
          "type": "blob",
          "size": 2.521484375,
          "content": "# #!/usr/bin/env bash\n\n##################################################################\n# Depreciating this script since using the s3api is must faster! #\n##################################################################\n\n# # Script to count total size of all data stored in all s3 buckets (IAM account must have permission to access all buckets)\n# # Requires s3cmd\n\n# # Functions\n\n# # Fail\n# function fail(){\n#   tput setaf 1; echo \"Failure: $*\" && tput sgr0\n#   exit 1\n# }\n\n# # Check for command\n# function check_command {\n#   type -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n# }\n\n# # Completed\n# function completed(){\n#   echo\n#   HorizontalRule\n#   tput setaf 2; echo \"Completed!\" && tput sgr0\n#   HorizontalRule\n#   echo\n# }\n\n# # Horizontal Rule\n# function HorizontalRule(){\n#   echo \"============================================================\"\n# }\n\n# # Convert bytes to human readable\n# function bytestohr(){\n#     SLIST=\"bytes,KB,MB,GB,TB,PB,EB,ZB,YB\"\n\n#     POWER=1\n#     VAL=$( echo \"scale=2; $1 / 1\" | bc)\n#     VINT=$( echo $VAL / 1024 | bc )\n#     while [ $VINT -gt 0 ]\n#     do\n#         let POWER=POWER+1\n#         VAL=$( echo \"scale=2; $VAL / 1024\" | bc)\n#         VINT=$( echo $VAL / 1024 | bc )\n#     done\n\n#     echo $VAL $( echo $SLIST | cut -f$POWER -d, )\n# }\n\n# # Check required commands\n# check_command \"s3cmd\"\n\n# # Verify s3cmd Credentials are setup\n# # http://s3tools.org/s3cmd-howto\n# if ! [ -f ~/.s3cfg ]; then\n#   fail \"Error: s3cmd config not found or not installed.\"\n# fi\n\n# # List buckets\n# S3CMDLS=$(s3cmd ls 2>&1)\n\n# # Count number of buckets\n# TOTALNUMBERS3BUCKETS=$(echo \"$S3CMDLS\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\n# # Get list of all bucket names\n# BUCKETNAMES=$(echo \"$S3CMDLS\" | cut -d ' ' -f 4 | nl)\n\n# echo\n# HorizontalRule\n# echo \"Counting Total Size of Data in $TOTALNUMBERS3BUCKETS S3 Buckets\"\n# echo \"(This may take a very long time depending on number of files)\"\n# HorizontalRule\n# echo\n\n# START=1\n# TOTALBUCKETSIZE=0\n\n# for (( COUNT=$START; COUNT<=$TOTALNUMBERS3BUCKETS; COUNT++ ))\n# do\n#   CURRENTBUCKET=$(echo \"$BUCKETNAMES\" | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n#   HorizontalRule\n#   echo \\#$COUNT $CURRENTBUCKET\n\n#   CURRENTBUCKETSIZE=$(s3cmd du $CURRENTBUCKET | cut -d ' ' -f 1)\n#   TOTALBUCKETSIZE=$(($TOTALBUCKETSIZE + $CURRENTBUCKETSIZE))\n#   echo \"Size: \"\n#   bytestohr $CURRENTBUCKETSIZE\n#   echo \"Subtotal: \"\n#   bytestohr $TOTALBUCKETSIZE\n# done\n\n# completed\n# echo \"Total Size of Data in All $TOTALNUMBERS3BUCKETS S3 Buckets:\"\n# bytestohr $TOTALBUCKETSIZE\n"
        },
        {
          "name": "s3-buckets-local-backup.sh",
          "type": "blob",
          "size": 2.8310546875,
          "content": "#!/usr/bin/env bash\n# Script to backup all S3 bucket contents locally\n# Contents of each S3 bucket will be copied to the local subfolder specified\n# Requires aws cli (AWS CLI profile must have IAM permission to access all buckets)\n\nSUBFOLDER=s3-bucket-local-backup-$(date +%Y-%m-%d)\n\n# Functions\n\n# Fail\nfunction fail(){\n  tput setaf 1; echo \"Failure: $*\" && tput sgr0\n  exit 1\n}\n\n# Check for command\nfunction check_command {\n  type -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n  echo\n  HorizontalRule\n  tput setaf 2; echo \"Completed!\" && tput sgr0\n  HorizontalRule\n  echo\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n  echo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    fail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n  fi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n  scriptname=`basename \"$0\"`\n  echo \"Usage: ./$scriptname profile\"\n  echo \"Where profile is the AWS CLI profile name\"\n  echo \"Using default profile\"\n  echo\n  profile=default\nelse\n  profile=$1\n  SUBFOLDER=$SUBFOLDER-$1\nfi\n\n# List buckets\nLS=$(aws s3 ls --profile $profile 2>&1)\nif [ ! $? -eq 0 ]; then\n  fail \"$LS\"\nfi\nif echo \"$LS\" | egrep -q \"Error|error|not\"; then\n  fail \"$LS\"\nfi\n\n# Get list of all bucket names\nBUCKETNAMES=$(echo \"$LS\" | cut -d ' ' -f3 | nl)\n\n# Count number of buckets\nTOTALNUMBERS3BUCKETS=$(echo \"$BUCKETNAMES\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\necho\nHorizontalRule\necho \"Local backup running for $TOTALNUMBERS3BUCKETS S3 Buckets\"\necho \"Copying files to subfolder: $SUBFOLDER\"\nHorizontalRule\necho\n\n# Make the subfolder directory\nif ! [ -d $SUBFOLDER ]; then\n  mkdir $SUBFOLDER\nfi\n\nSTART=1\n\nfor (( COUNT=$START; COUNT<=$TOTALNUMBERS3BUCKETS; COUNT++ ))\ndo\n  CURRENTBUCKET=$(echo \"$BUCKETNAMES\" | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n  HorizontalRule\n  echo \\#$COUNT $CURRENTBUCKET\n\n  # Determine the bucket region\n  REGION=$(aws s3api get-bucket-location --bucket $CURRENTBUCKET --output text --profile $profile 2>&1)\n  if [ ! $? -eq 0 ]; then\n    fail \"$REGION\"\n  fi\n  if echo $REGION | grep -q \"None\"; then\n    REGION=\"us-east-1\"\n  fi\n\n  # Backup the S3 bucket contents\n  BACKUP=$(aws s3 sync s3://$CURRENTBUCKET $SUBFOLDER/$CURRENTBUCKET/ --region $REGION --profile $profile --quiet 2>&1)\n  if [ ! $? -eq 0 ]; then\n    fail \"$BACKUP\"\n  fi\n  if echo \"$BACKUP\" | egrep -iq \"error|not\"; then\n    fail \"$BACKUP\"\n  fi\ndone\n\ncompleted\necho \"Backup files saved under subfolder: $SUBFOLDER\"\n"
        },
        {
          "name": "s3-buckets-security-audit.sh",
          "type": "blob",
          "size": 4.48828125,
          "content": "#!/usr/bin/env bash\n# Script to export S3 bucket ACL, CORS, Policy and Website JSON for auditing security of all buckets\n# Each S3 bucket will have a JSON file generated in the subfolder specified\n# Requires aws s3api, jq, (AWS CLI profile must have IAM permission to access all buckets)\n\nSUBFOLDER=s3-bucket-audit-$(date +%Y-%m-%d)\n# OUTPUTFILENAME=s3-bucket-audit-$(date +%Y-%m-%d).json\n\n# Functions\n\n# Fail\nfunction fail(){\n  tput setaf 1; echo \"Failure: $*\" && tput sgr0\n  exit 1\n}\n\n# Check for command\nfunction check_command {\n  type -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n  echo\n  HorizontalRule\n  tput setaf 2; echo \"Completed!\" && tput sgr0\n  HorizontalRule\n  echo\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n  echo \"============================================================\"\n}\n\n# Check required commands\ncheck_command \"jq\"\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    fail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n  fi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n  scriptname=`basename \"$0\"`\n  echo \"Usage: ./$scriptname profile\"\n  echo \"Where profile is the AWS CLI profile name\"\n  echo \"Using default profile\"\n  echo\n  profile=default\nelse\n  profile=$1\n  SUBFOLDER=$SUBFOLDER-$1\nfi\n\n# List buckets\nLS=$(aws s3 ls --profile $profile 2>&1)\n\nif echo \"$LS\" | egrep -q \"Error|error|not\"; then\n  fail \"$LS\"\nfi\n\n# Get list of all bucket names\nBUCKETNAMES=$(echo \"$LS\" | cut -d ' ' -f 3 | nl)\n\n# Count number of buckets\nTOTALNUMBERS3BUCKETS=$(echo \"$BUCKETNAMES\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\necho\nHorizontalRule\necho \"Exporting policies for $TOTALNUMBERS3BUCKETS S3 Buckets\"\necho \"Generating JSON files in subfolder: $SUBFOLDER\"\nHorizontalRule\necho\n\n# # Check for existing report file\n# if [ -f $OUTPUTFILENAME ]; then\n#   tput setaf 1\n#   echo \"Report already generated!\"\n#   echo $OUTPUTFILENAME\n#   read -r -p \"Overwrite? (y/n) \" OVERWRITE\n#   if ! [[ $OVERWRITE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n#     fail \"Report already generated.\"\n#   else\n#     rm $OUTPUTFILENAME\n#   fi\n#   tput sgr0\n# fi\n\n# Make the subfolder directory\nif ! [ -d $SUBFOLDER ]; then\n  mkdir $SUBFOLDER\nfi\n\nSTART=1\n\nfor (( COUNT=$START; COUNT<=$TOTALNUMBERS3BUCKETS; COUNT++ ))\ndo\n  CURRENTBUCKET=$(echo \"$BUCKETNAMES\" | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n  HorizontalRule\n  echo \\#$COUNT $CURRENTBUCKET\n\n  OUTPUTFILENAME=$SUBFOLDER/$CURRENTBUCKET.json\n\n  # Overwrite any existing file\n  if [ -f $OUTPUTFILENAME ]; then\n    rm $OUTPUTFILENAME\n  fi\n\n  # Determine the bucket region\n  CURRENTBUCKETREGION=$(aws s3api get-bucket-location --bucket $CURRENTBUCKET --output text --profile $profile 2>&1)\n  if echo $CURRENTBUCKETREGION | grep -q \"None\"; then\n    REGION=\"us-east-1\"\n  else\n    REGION=$CURRENTBUCKETREGION\n  fi\n\n  # Lookup the access control policy\n  ACL=$(aws s3api get-bucket-acl --bucket $CURRENTBUCKET --region $REGION --profile $profile 2>&1)\n  # ACL=$(aws s3api get-bucket-acl --bucket $CURRENTBUCKET --profile $profile 2>&1 | sed 's/\\,/;/g')\n\n  if echo \"$ACL\" | grep -q \"error\"; then\n    ACL='{\n    \"ACL\": [\n    ]\n}'\n  fi\n\n  # Lookup the CORS policy\n  CORS=$(aws s3api get-bucket-cors --bucket $CURRENTBUCKET --region $REGION --profile $profile 2>&1)\n  # CORS=$(aws s3api get-bucket-cors --bucket $CURRENTBUCKET --profile $profile 2>&1 | sed 's/\\,/;/g')\n\n  if echo \"$CORS\" | grep -q \"error\"; then\n    CORS='{\n    \"CORSRules\": [\n    ]\n}'\n  fi\n\n  # Lookup the bucket policy\n  POLICY=$(aws s3api get-bucket-policy --bucket $CURRENTBUCKET --region $REGION --profile $profile --output text 2>&1)\n\n  if echo \"$POLICY\" | grep -q \"error\"; then\n    POLICY='{\n    \"Policy\": [\n    ]\n}'\n  else\n    POLICY=$(echo $POLICY | jq .)\n    # POLICY=$(echo $POLICY | jq . | sed 's/\\,/;/g')\n  fi\n\n  # Lookup the website hosting policy\n  WEBSITE=$(aws s3api get-bucket-website --bucket $CURRENTBUCKET --region $REGION --profile $profile 2>&1)\n\n  if echo \"$WEBSITE\" | grep -q \"error\"; then\n    WEBSITE='{\n    \"Website\": [\n    ]\n}'\n  fi\n\n  # Combine everything into one JSON file\n  OUTPUT=$(echo $ACL $CORS $POLICY $WEBSITE | jq -s add)\n  echo \"$OUTPUT\" >> $OUTPUTFILENAME\n\ndone\n\ncompleted\necho \"JSON files generated under subfolder: $SUBFOLDER\"\n"
        },
        {
          "name": "s3-buckets-total-file-size.sh",
          "type": "blob",
          "size": 4.396484375,
          "content": "#!/usr/bin/env bash\n# Script to count total size of all data stored in a single or in all S3 buckets\n# Requires aws s3api, jq, IAM account must have permission to access all buckets\n\n# Functions\n\n# Fail\nfunction fail(){\n  tput setaf 1; echo \"Failure: $*\" && tput sgr0\n  exit 1\n}\n\n# Check for command\nfunction check_command {\n  type -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n  echo\n  HorizontalRule\n  tput setaf 2; echo \"Completed!\" && tput sgr0\n  HorizontalRule\n  echo\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n  echo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    fail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n  fi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n  scriptname=`basename \"$0\"`\n  echo \"Usage: ./$scriptname profile\"\n  echo \"Where profile is the AWS CLI profile name\"\n  echo \"Using default profile\"\n  echo\n  profile=default\nelse\n  profile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n# Convert bytes to human readable\nfunction bytestohr(){\n    SLIST=\"bytes,KB,MB,GB,TB,PB,EB,ZB,YB\"\n\n    POWER=1\n    VAL=$( echo \"scale=2; $1 / 1\" | bc)\n    VINT=$( echo $VAL / 1024 | bc )\n    while [ $VINT -gt 0 ]\n    do\n        let POWER=POWER+1\n        VAL=$( echo \"scale=2; $VAL / 1024\" | bc)\n        VINT=$( echo $VAL / 1024 | bc )\n    done\n\n    echo $VAL $( echo $SLIST | cut -f$POWER -d, )\n}\n\n# One bucket or all buckets\nfunction choiceMenu(){\n  tput smul; echo \"Single S3 bucket or all buckets?\" && tput sgr0\n  echo 1. Single bucket\n  echo 2. All buckets\n  echo\n  read -r -p \"Menu selection #: \" menuSelection\n\n  case $menuSelection in\n    1)\n      SingleBucket\n    ;;\n    2)\n      AllBuckets\n    ;;\n    *)\n      fail \"Invalid selection!\"\n    ;;\n  esac\n}\n\nfunction SingleBucket(){\n  read -r -p \"Bucket name: s3://\" CURRENTBUCKET\n  echo\n  echo \"Calculating size...\"\n  CURRENTBUCKETREGION=$(aws s3api get-bucket-location --bucket $CURRENTBUCKET --output text --profile $profile 2>&1)\n  if echo $CURRENTBUCKETREGION | grep -q None; then\n    REGION=\"us-east-1\"\n  else\n    REGION=$CURRENTBUCKETREGION\n  fi\n  CURRENTBUCKETSIZE=$(aws s3api list-objects --bucket $CURRENTBUCKET --region $REGION --output json --query \"[sum(Contents[].Size)]\" --profile $profile 2>&1)\n  if echo $CURRENTBUCKETSIZE | grep -q invalid; then\n    CURRENTBUCKETSIZE=\"0\"\n  else\n    CURRENTBUCKETSIZE=$(echo \"$CURRENTBUCKETSIZE\" | jq '.[]')\n  fi\n  echo\n  echo \"Size: \"\n  bytestohr $CURRENTBUCKETSIZE\n  completed\n}\n\nfunction AllBuckets(){\n  # List buckets\n  LS=$(aws s3 ls --profile $profile 2>&1)\n\n  # Count number of buckets\n  TOTALNUMBERS3BUCKETS=$(echo \"$LS\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\n  # Get list of all bucket names\n  BUCKETNAMES=$(echo \"$LS\" | cut -d ' ' -f3 | nl)\n\n  echo\n  HorizontalRule\n  echo \"Counting Total Size of Data in $TOTALNUMBERS3BUCKETS S3 Buckets\"\n  echo \"(This may take a very long time depending on number of files)\"\n  HorizontalRule\n  echo\n\n  START=1\n  TOTALBUCKETSIZE=0\n\n  for (( COUNT=$START; COUNT<=$TOTALNUMBERS3BUCKETS; COUNT++ ))\n  do\n    CURRENTBUCKET=$(echo \"$BUCKETNAMES\" | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n    HorizontalRule\n    echo \\#$COUNT $CURRENTBUCKET\n\n    CURRENTBUCKETREGION=$(aws s3api get-bucket-location --bucket $CURRENTBUCKET --output text --profile $profile 2>&1)\n    if echo $CURRENTBUCKETREGION | grep -q None; then\n      REGION=\"us-east-1\"\n    else\n      REGION=$CURRENTBUCKETREGION\n    fi\n    CURRENTBUCKETSIZE=$(aws s3api list-objects --bucket $CURRENTBUCKET --region $REGION --output json --query \"[sum(Contents[].Size)]\" --profile $profile 2>&1)\n    if echo $CURRENTBUCKETSIZE | grep -q invalid; then\n      CURRENTBUCKETSIZE=\"0\"\n    else\n      CURRENTBUCKETSIZE=$(echo \"$CURRENTBUCKETSIZE\" | jq '.[]')\n    fi\n    TOTALBUCKETSIZE=$(($TOTALBUCKETSIZE + $CURRENTBUCKETSIZE))\n    echo \"Size: \"\n    bytestohr $CURRENTBUCKETSIZE\n    echo \"Subtotal: \"\n    bytestohr $TOTALBUCKETSIZE\n  done\n\n  completed\n  echo \"Total Size of Data in All $TOTALNUMBERS3BUCKETS S3 Buckets:\"\n  bytestohr $TOTALBUCKETSIZE\n}\n\nchoiceMenu\n"
        },
        {
          "name": "s3-fix-content-type-metadata.sh",
          "type": "blob",
          "size": 5.134765625,
          "content": "#!/usr/bin/env bash\n\n# Safely fix invalid content-type metadata on AWS S3 bucket website assets for some common filetypes\n# Inclues CSS, JS, JSON, JPG, JPEG, GIF, PNG, SVG, PDF, XML\n\nBUCKET=\"YOUR-S3-BUCKET-NAME\"\n\n\n# Functions\n\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\nfunction completed(){\n\techo\n\thorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\thorizontalRule\n\techo\n}\n\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\nfunction horizontalRule(){\n\techo \"=====================================================\"\n}\n\nfunction message(){\n\techo\n\thorizontalRule\n\techo \"$*\"\n\thorizontalRule\n\techo\n}\n\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\ncheck_command \"aws\"\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\nmessage \"This script will safely fix invalid content-type metadata on AWS S3 bucket website assets.\"\necho\n# pause\n\n# Ensure Variables are set\nif [ \"$BUCKET\" = \"YOUR-S3-BUCKET-NAME\" ]; then\n\tread -r -p \"Enter the S3 bucket name: \" BUCKET\n\tif [ -z \"$BUCKET\" ]; then\n\t\tfail \"Failed to set variables!\"\n\tfi\nfi\n\n# Determine the bucket region\nREGION=$(aws s3api get-bucket-location --bucket $BUCKET --output text --profile $profile 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$REGION\"\nfi\nif echo $REGION | grep -q \"None\"; then\n\tREGION=\"us-east-1\"\nfi\n\nmessage CSS\ncss=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.css\" --content-type \"text/css\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$css\"\nfi\nif echo $css | egrep -iq \"error|not\"; then\n\tfail \"$css\"\nelse\n\techo \"$css\"\nfi\n\nmessage JS\njs=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.js\" --content-type \"application/javascript\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$js\"\nfi\nif echo $js | egrep -iq \"error|not\"; then\n\tfail \"$js\"\nelse\n\techo \"$js\"\nfi\n\nmessage JSON\njson=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.json\" --content-type \"application/json\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$json\"\nfi\nif echo $json | egrep -iq \"error|not\"; then\n\tfail \"$json\"\nelse\n\techo \"$json\"\nfi\n\nmessage JPG\njpg=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.jpg\" --content-type \"image/jpeg\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$jpg\"\nfi\nif echo $jpg | egrep -iq \"error|not\"; then\n\tfail \"$jpg\"\nelse\n\techo \"$jpg\"\nfi\nmessage JPEG\njpeg=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.jpeg\" --content-type \"image/jpeg\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$jpeg\"\nfi\nif echo $jpeg | egrep -iq \"error|not\"; then\n\tfail \"$jpeg\"\nelse\n\techo \"$jpeg\"\nfi\n\nmessage GIF\ngif=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.gif\" --content-type \"image/gif\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$gif\"\nfi\nif echo $gif | egrep -iq \"error|not\"; then\n\tfail \"$gif\"\nelse\n\techo \"$gif\"\nfi\n\nmessage PNG\npng=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.png\" --content-type \"image/png\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$png\"\nfi\nif echo $png | egrep -iq \"error|not\"; then\n\tfail \"$png\"\nelse\n\techo \"$png\"\nfi\n\nmessage SVG\nsvg=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.svg\" --content-type \"image/svg+xml\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$svg\"\nfi\nif echo $svg | egrep -iq \"error|not\"; then\n\tfail \"$svg\"\nelse\n\techo \"$svg\"\nfi\n\nmessage PDF\npdf=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.pdf\" --content-type \"application/pdf\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$pdf\"\nfi\nif echo $pdf | egrep -iq \"error|not\"; then\n\tfail \"$pdf\"\nelse\n\techo \"$pdf\"\nfi\n\nmessage XML\nxml=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --exclude \"*\" --include \"*.xml\" --content-type \"text/xml\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$xml\"\nfi\nif echo $xml | egrep -iq \"error|not\"; then\n\tfail \"$xml\"\nelse\n\techo \"$xml\"\nfi\n\n\ncompleted\n"
        },
        {
          "name": "s3-open-bucket-policy.sh",
          "type": "blob",
          "size": 3.8515625,
          "content": "#!/usr/bin/env bash\n\n# This script sets an S3 bucket policy to allow GetObject requests from any IP.\n# Requires the AWS CLI and jq\n\n# Set Variables\n\ns3bucketname=\"YOUR-S3-BUCKET-NAME\"\n\n\n# Functions\n\n# Check required commands\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nscriptname=`basename \"$0\"`\nif [ $# -eq 0 ]; then\n\techo \"Usage: ./$scriptname profile environment\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"And environment is the environment name (dev/staging/prod/all)\"\n\techo\n\techo \"Using default profile and no environment name\"\n\techo\n\tprofile=default\nelif [ $# -eq 1 ]; then\n\techo \"Usage: ./$scriptname profile environment\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"And environment is the environment name (dev/staging/prod/all)\"\n\techo\n\techo \"Using profile $1 and no environment name\"\n\techo\n\tprofile=$1\nelif [ $# -eq 2 ]; then\n\techo \"Using profile $1 and environment $2\"\n\tprofile=$1\n\ts3bucketenv=$2\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# Validate Variables\n\nif [ \"$s3bucketname\" = \"YOUR-S3-BUCKET-NAME\" ]; then\n\tread -r -p \"Enter S3 Bucket Name: \" s3bucketname\nfi\nif [ -z \"$s3bucketname\" ]; then\n\tfail \"S3 Bucket Name must be set.\"\nfi\n\n# Create the JSON policy document\nfunction JSONizePolicy {\n\techo '{\"Version\":\"2012-10-17\",\"Id\":\"'\"$s3bucketname\"'\",\"Statement\":[{\"Sid\":\"PublicReadForGetBucketObjects\",\"Effect\":\"Allow\",\"Principal\":\"*\",\"Action\":\"s3:GetObject\",\"Resource\":\"arn:aws:s3:::'\"$s3bucketname\"'/*\"}]}' > policy.json\n}\n\n# Set the S3 bucket policy\nfunction setS3Policy {\n\tsetS3Policy=$(aws s3api put-bucket-policy --bucket $s3bucketname --policy file://policy.json --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$setS3Policy\"\n\tfi\n}\n\n# Validate the new policy\nfunction validateS3Policy {\n\tbucketpolicy=$(aws s3api get-bucket-policy --bucket $s3bucketname --output=text --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$bucketpolicy\"\n\tfi\n\tjsonpolicy=$(cat policy.json | tr -d '\\n')\n\n\t# echo \"$bucketpolicy\" > bucketpolicy\n\t# echo \"$jsonpolicy\" > jsonpolicy\n\n\tif [ \"$bucketpolicy\" = \"$jsonpolicy\" ]; then\n\t\tHorizontalRule\n\t\ttput setaf 2; echo \"S3 Bucket: $s3bucketname Policy Set Successfully!\" && tput sgr0\n\t\tHorizontalRule\n\t\t# Remove the old policy file\n\t\t# rm policy.json\n\telse\n\t\tfail \"Unable to verify bucket policy was set correctly.\"\n\tfi\n}\n\n# Run functions\nfunction run {\n\tJSONizePolicy\n\tsetS3Policy\n\tvalidateS3Policy\n}\n\n# Set S3 bucket name\nfunction setBucketName (){\n\t# # Check for environment argument passed into the script\n\t# if [ $# -eq 0 ]; then\n\t# \tread -rp \"S3 Bucket Environment? (dev/staging/prod/all): \" s3bucketenv\n\t# \tif [ -z \"$s3bucketenv\" ]; then\n\t# \t\tfail \"Invalid environment.\"\n\t# \tfi\n\n\t# \tif [ $s3bucketenv = \"all\" ]; then\n\t# \t\ts3bucketenv=all\n\t# \telse\n\t# \t\ts3bucketname=\"$s3bucketname\"-\"$s3bucketenv\"\n\t# \tfi\n\t# fi\n\n\t# Test for variable passed as argument\n\tif [ -z \"$s3bucketenv\" ]; then\n\t\trun\n\telif [ \"$s3bucketenv\" = \"all\" ]; then\n\t\ts3bucketname=\"$s3bucketname\"-dev\n\t\trun\n\t\ts3bucketname=\"$s3bucketname\"-staging\n\t\trun\n\t\ts3bucketname=\"$s3bucketname\"-prod\n\t\trun\n\telse\n\t\ts3bucketname=\"$s3bucketname\"-\"$s3bucketenv\"\n\t\trun\n\tfi\n}\n\nsetBucketName $s3bucketenv\n"
        },
        {
          "name": "s3-remove-glacier-objects.sh",
          "type": "blob",
          "size": 2.685546875,
          "content": "#!/usr/bin/env bash\n# Script to delete all Glacier storage type objects in a single S3 bucket\n# Requires aws s3api, jq\n\n\n# Set Variables\nS3BUCKET=\"YOUR-S3-BUCKET-NAME\"\n\n\n# Functions\n\n# Fail\nfunction fail(){\n  tput setaf 1; echo \"Failure: $*\" && tput sgr0\n  exit 1\n}\n\n# Check for command\nfunction check_command {\n  type -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n  echo\n  HorizontalRule\n  tput setaf 2; echo \"Completed!\" && tput sgr0\n  HorizontalRule\n  echo\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n  echo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    fail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n  fi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n  scriptname=`basename \"$0\"`\n  echo \"Usage: ./$scriptname profile\"\n  echo \"Where profile is the AWS CLI profile name\"\n  echo \"Using default profile\"\n  echo\n  profile=default\nelse\n  profile=$1\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n# Validate Variable\nif [[ \"$S3BUCKET\" == \"YOUR-S3-BUCKET-NAME\" ]]; then\n\tread -r -p \"Enter S3 Bucket name: \" S3BUCKET\nfi\n\nif [ -z \"$S3BUCKET\" ]; then\n\tfail \"S3 Bucket name must be set.\"\nfi\n\nread -r -p \"Warning: this will delete all objects from the S3 bucket with storage type Glacier!  Proceed? (y/n) \" Proceed\nif ! [[ $Proceed =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\tfail \"Canceled.\"\nfi\n\nS3BUCKETREGION=$(aws s3api get-bucket-location --bucket \"$S3BUCKET\" --output text --profile $profile 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$S3BUCKETREGION\"\nelse\n\tif echo $S3BUCKETREGION | grep -q None; then\n\tREGION=\"us-east-1\"\n\telse\n\tREGION=$S3BUCKETREGION\n\tfi\nfi\n\nLISTGLACIER=$(aws s3api list-objects-v2 --bucket \"$S3BUCKET\" --query \"Contents[?StorageClass=='GLACIER'].Key\" --output json --profile $profile --max-items 9999 --region $REGION 2>&1)\n\nif [ ! $? -eq 0 ]; then\n\tfail \"$LISTGLACIER\"\nelse\n\tif [ -z \"$LISTGLACIER\" ] || [ \"$LISTGLACIER\" == \"[]\" ]; then\n\t\tfail \"No Glacier objects found in this S3 bucket.\"\n\tfi\n\tPARSEGLACIER=$(echo \"$LISTGLACIER\" | jq .[] | cut -d \\\" -f2 > GLACIER.txt)\nfi\n\nwhile read glacier\ndo\n\tRM=$(aws s3 rm s3://\"$S3BUCKET\"/\"$glacier\" --profile $profile --region $REGION 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$RM\"\n\telse\n\t\techo \"Deleted object:\" \"$glacier\"\n\tfi\ndone < GLACIER.txt\n\nrm GLACIER.txt\ncompleted\n"
        },
        {
          "name": "s3-restrict-bucket-policy.sh",
          "type": "blob",
          "size": 5.39453125,
          "content": "#!/usr/bin/env bash\n\n# This script sets an S3 bucket policy to only allow GetObject requests from an IP whitelist file named iplist\n# Requires the AWS CLI and jq\n\n# Set Variables\n\ns3bucketname=\"YOUR-S3-BUCKET-NAME\"\n\n\n# Functions\n\n# Check required commands\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n\n# Validate Variables\n\nif [ \"$s3bucketname\" = \"YOUR-S3-BUCKET-NAME\" ]; then\n\tread -r -p \"Enter S3 Bucket Name: \" s3bucketname\nfi\nif [ -z \"$s3bucketname\" ]; then\n\tfail \"S3 Bucket Name must be set.\"\nfi\n\n\n# Validates CIDR notation\nfunction validateCIDR {\n\twhile read iplist\n\tdo\n\t\t# echo $iplist\n\t\tif ! echo $iplist | egrep -q '/24$'; then\n\t\t\tif ! echo $iplist | egrep -q '/32$'; then\n\t\t\t\techo $iplist/32 >> iplist3\n\t\t\telse echo $iplist >> iplist3\n\t\t\tfi\n\t\telse echo $iplist >> iplist3\n\t\tfi\n\tdone < iplist\n\tmv iplist3 iplist\n\n\t# Remove any empty lines\n\twhile read iplist\n\tdo\n\t\tif echo $iplist | egrep -q '^/32$'; then\n\t\t\techo $iplist | sed -i '/\\/32/d' |  cat -s >> iplist4\n\t\telse echo $iplist >> iplist4\n\t\tfi\n\tdone < iplist\n\tmv iplist4 iplist\n\n\tif grep -qv '/[0-9]' iplist; then\n\t\techo \"One or more lines contain invalid or missing CIDR notation. Please fix line:\"\n\t\tgrep -vn '/[0-9]' iplist\n\t\tfailed\n\tfi\n}\n\n# New Validate CIDR notation\nfunction newValidateCIDR(){\n\twhile read iplist\n\tdo\n\t\tif ! echo $iplist | egrep -q '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$'; then\n\t\t\techo $iplist/32 >> iplist3\n\t\telse echo $iplist >> iplist3\n\t\tfi\n\tdone < iplist\n\tmv iplist3 iplist\n}\n\n# Remove any empty lines\nfunction removeEmptyLines(){\n\twhile read iplist\n\tdo\n\t\tif echo $iplist | egrep -q '^/32$'; then\n\t\t\techo $iplist | sed -i '/\\/32/d' |  cat -s >> iplist4\n\t\telse echo $iplist >> iplist4\n\t\tfi\n\tdone < iplist\n\tmv iplist4 iplist\n\n\tif grep -qv '/[0-9]' iplist; then\n\t\techo \"One or more lines contain invalid or missing CIDR notation. Please fix line:\"\n\t\tgrep -vn '/[0-9]' iplist\n\t\tfailed\n\tfi\n}\n\n# Cleanup list\nfunction cleanup {\n\tsort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 iplist | uniq > iplist2\n\tmv iplist2 iplist\n\t# echo \"iplist cleanup completed.\"\n}\n\n# Output the list in JSON\nfunction JSONizeiplist {\n\twhile read iplist\n\tdo\n\t\techo \\\"$iplist\\\",>> iplistjson2\n\tdone < iplist\n\tcat iplistjson2 | sed '$ s/.$//' >> iplistjson3\n\trm iplistjson2 && mv iplistjson3 iplistjson\n\n\tiplistjson=$(cat iplistjson)\n\n\t# echo \"$iplistjson\"\n}\n\n# Create the JSON policy document\nfunction JSONizePolicy {\n\techo '{\"Version\":\"2012-10-17\",\"Id\":\"'\"$s3bucketname\"'\",\"Statement\":[{\"Sid\":\"'\"$s3bucketname\"'\",\"Effect\":\"Allow\",\"Principal\":\"*\",\"Action\":\"s3:GetObject\",\"Resource\":\"arn:aws:s3:::'\"$s3bucketname\"'/*\",\"Condition\":{\"IpAddress\":{\"aws:SourceIp\":['\"$iplistjson\"']}}}]}' > policy.json\n}\n\n# Set the S3 bucket policy\nfunction setS3Policy {\n\tsetS3Policy=$(aws s3api put-bucket-policy --bucket $s3bucketname --policy file://policy.json 2>&1)\n}\n\n# Validate the new policy\nfunction validateS3Policy {\n\tbucketpolicy=$(aws s3api get-bucket-policy --bucket $s3bucketname --output text | jq '.Statement | .[] | .Condition | .IpAddress | .\"aws:SourceIp\" | .[]' | cut -d \\\" -f2 | sort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4)\n\tjsonpolicy=$(cat policy.json | tr -d '\\n' | jq '.Statement | .[] | .Condition | .IpAddress | .\"aws:SourceIp\" | .[]' | cut -d \\\" -f2)\n\n\t# echo \"$bucketpolicy\" > bucketpolicy\n\t# echo \"$jsonpolicy\" > jsonpolicy\n\n\tif [ \"$bucketpolicy\" = \"$jsonpolicy\" ]; then\n\t\tHorizontalRule\n\t\ttput setaf 2; echo S3 Bucket: $s3bucketname Policy Set Successfully! && tput sgr0\n\t\ttput setaf 2; echo Set Conditional IP Allow List && tput sgr0\n\t\tHorizontalRule\n\t\t# rm policy.json\n\telse\n\t\tfail $(echo \"$setS3Policy\")\n\tfi\n}\n\n# Run functions\nfunction run {\n\tJSONizePolicy\n\tsetS3Policy\n\tvalidateS3Policy\n}\n\n# Set S3 bucket name\nfunction setBucketName (){\n\t# Check for environment argument passed into the script\n\tif [ $# -eq 0 ]; then\n\t\tscriptname=`basename \"$0\"`\n\t\techo \"Usage: ./$scriptname environment\"\n\t\tread -rp \"S3 Bucket Environment? (dev/staging/prod/all): \" s3bucketenv\n\t\tif [ -z \"$s3bucketenv\" ]; then\n\t\t\tfail \"Invalid environment.\"\n\t\tfi\n\n\t\tif [ $s3bucketenv = \"all\" ]; then\n\t\t\ts3bucketenv=all\n\t\telse\n\t\t\ts3bucketname=\"$s3bucketname\"-\"$s3bucketenv\"\n\t\tfi\n\tfi\n\n\t# Test for variable passed as argument\n\tif [ -z \"$1\" ]; then\n\t    if [ $s3bucketenv = \"all\" ]; then\n\t\t\ts3bucketname=\"$s3bucketname\"-dev\n\t\t\trun\n\t\t\ts3bucketname=\"$s3bucketname\"-staging\n\t\t\trun\n\t\t\ts3bucketname=\"$s3bucketname\"-prod\n\t\t\trun\n\t\telse\n\t\t\ts3bucketname=\"$s3bucketname\"-\"$s3bucketenv\"\n\t\t\trun\n\t\tfi\n\telse\n\t\tif [ $1 = \"all\" ]; then\n\t\t\ts3bucketname=\"$s3bucketname\"-dev\n\t\t\trun\n\t\t\ts3bucketname=\"$s3bucketname\"-staging\n\t\t\trun\n\t\t\ts3bucketname=\"$s3bucketname\"-prod\n\t\t\trun\n\t\telse\n\t\t\ts3bucketname=\"$s3bucketname\"-\"$1\"\n\t\t\trun\n\t\tfi\n\tfi\n\t# echo $s3bucketname\n}\n\n# validateCIDR\nnewValidateCIDR\nremoveEmptyLines\ncleanup\nJSONizeiplist\nsetBucketName $1\nrm iplistjson\n"
        },
        {
          "name": "s3-set-cache-control-max-age.sh",
          "type": "blob",
          "size": 2.7412109375,
          "content": "#!/usr/bin/env bash\n\n# Set Cache-Control public with max-age value on AWS S3 bucket website assets for all filetypes\n# https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n\nBUCKET=\"YOUR-S3-BUCKET-NAME\"\nMAXAGE=\"SET-SECONDS-VALUE-HERE\"\n\n# Functions\n\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\nfunction completed(){\n\techo\n\thorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\thorizontalRule\n\techo\n}\n\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\nfunction horizontalRule(){\n\techo \"=====================================================\"\n}\n\nfunction message(){\n\techo\n\thorizontalRule\n\techo \"$*\"\n\thorizontalRule\n\techo\n}\n\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\ncheck_command \"aws\"\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\nmessage \"This script will set Cache-Control public with max-age value on AWS S3 bucket website assets.\"\necho\n# pause\n\n# Ensure Variables are set\nif [ \"$BUCKET\" = \"YOUR-S3-BUCKET-NAME\" ]; then\n\tread -r -p \"Enter the S3 bucket name: \" BUCKET\n\tif [ -z \"$BUCKET\" ]; then\n\t\tfail \"Failed to set variables!\"\n\tfi\nfi\nif [ \"$MAXAGE\" = \"SET-SECONDS-VALUE-HERE\" ]; then\n\tread -r -p \"Enter the new Cache-Control Max-Age value in seconds: \" MAXAGE\n\tif [ -z \"$MAXAGE\" ]; then\n\t\tfail \"Failed to set variables!\"\n\tfi\nfi\n\n# Validate max-age range 0-31536000\nif ! [ \"$MAXAGE\" -ge \"0\" ] || ! [ \"$MAXAGE\" -le \"31536000\" ]; then\n\tfail \"Invalid Cache-Control Max-Age value: $MAXAGE\"\nfi\n\n# Determine the bucket region\nREGION=$(aws s3api get-bucket-location --bucket $BUCKET --output text --profile $profile 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$REGION\"\nfi\nif echo $REGION | grep -q \"None\"; then\n\tREGION=\"us-east-1\"\nfi\n\nmessage \"Setting Cache-Control Max-Age $MAXAGE for all assets in S3 Bucket $BUCKET\"\nset=$(aws s3 cp --recursive --profile $profile --region $REGION s3://$BUCKET/ s3://$BUCKET/ --cache-control \"public, max-age=$MAXAGE\" --metadata-directive \"REPLACE\" 2>&1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$set\"\nfi\nif echo $set | egrep -iq \"error\"; then\n\tfail \"$set\"\nelse\n\techo \"$set\"\nfi\n\ncompleted\n"
        },
        {
          "name": "s3-setup-buckets.sh",
          "type": "blob",
          "size": 1.193359375,
          "content": "#!/usr/bin/env bash\n# This script will create S3 buckets, set CORS config and tag bucket with client name\n# Requires awscli\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n  if ! grep -q aws_access_key_id ~/.aws/credentials; then\n    echo \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n    exit 1\n  fi\nfi\n\nread -r -p \"Enter the client name: \" CLIENT\n\nfunction createbucket(){\n\taws s3api create-bucket --bucket $CLIENT-$ENV\n}\n\nfunction setcors(){\n\taws s3api put-bucket-cors --bucket $CLIENT-$ENV --cli-input-json \\\n\t'{\n\t\t\"CORSConfiguration\": {\n\t\t\t\"CORSRules\": [\n\t\t\t\t{\n\t\t\t\t\t\"AllowedOrigins\": [\"*\"],\n\t\t\t\t\t\"AllowedMethods\": [\"GET\"],\n\t\t\t\t\t\"MaxAgeSeconds\": 3000,\n\t\t\t\t\t\"AllowedHeaders\": [\"*\"]\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}'\n}\n\nfunction tag(){\n\taws s3api put-bucket-tagging --bucket $CLIENT-$ENV --tagging \\\n\t'{\n\t\t\"TagSet\": [\n\t\t\t{\n\t\t\t\t\"Key\": \"Client\",\n\t\t\t\t\"Value\": \"'$CLIENT'\"\n\t\t\t}\n\t\t]\n\t}'\n}\n\necho \"Creating Buckets, setting CORS Configuration, creating Tags...\"\nENV=dev\ncreatebucket\nsetcors\ntag\nENV=production\ncreatebucket\nsetcors\ntag\nENV=staging\ncreatebucket\nsetcors\ntag\necho \"Completed!\"\n"
        },
        {
          "name": "terraform-redact-iam-secrets.sh",
          "type": "blob",
          "size": 5.9970703125,
          "content": "#!/usr/bin/env bash\n\n# This script replaces AWS IAM Secret Keys and IAM SES SMTP Passwords with \"REDACTED\"\n# in Terraform state files so they can be safely committed to git without exposing credentials.\n\n# Update:\n# A better workaround to this problem is to use the S3 backend type in Terraform to avoid\n# committing your state files to git: https://www.terraform.io/docs/backends/types/s3.html\n\n# Usage:\n# Run from dir that contains environment subfolders. Requires Terraform and jq.\n# Assumes three environments exist within subfolders: dev, staging, production.\n# Must have an output.tf file with iam_secret and ses_smtp_password defined.\n\n\n# Set Variables\ndevEnv=\"dev\"\nstagingEnv=\"staging\"\nproductionEnv=\"production\"\n\niamSecret=\"iam_secret\"\nsesPassword=\"ses_smtp_password\"\n\nredaction=\"REDACTED\"\n\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check for command\nfunction check_command {\n\ttype -P $1 &>/dev/null || failExit \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\treturn 1\n\t# exit 1\n}\n\n# Fail and exit\nfunction failExit(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction horizontalRule(){\n\techo \"=====================================================\"\n}\n\n# Completed Message\nfunction completed(){\n\techo\n\thorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\thorizontalRule\n\techo\n}\n\n# Message\nfunction message(){\n\techo\n\thorizontalRule\n\techo \"$*\"\n\thorizontalRule\n\techo\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n\n# Check required commands\ncheck_command \"terraform\"\ncheck_command \"jq\"\n\n\n# Warning\nhorizontalRule\ntput setaf 1; echo \"WARNING: Running this script will remove AWS IAM Secret Keys and IAM SES SMTP Passwords in Terraform state files.\" && tput sgr0\nhorizontalRule\necho\npause\n\n\n# TF State Dev\n\nif [ -f \"$devEnv\"/terraform.tfstate ]; then\n\tmessage Redacting \"$devEnv\"\n\tTerraformOutputDev=$(cd \"$devEnv\" && terraform output -json)\n\n\tDevSecret=$(echo $TerraformOutputDev | jq '[.\"'\"$iamSecret\"'\"|.value]' | cut -d '\"' -f2 -s)\n\tif ! [ -z $DevSecret ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$devEnv\" IAM Secret: $DevSecret\n\t\tfi\n\t\tsed -i '' -e \"s#$DevSecret#$redaction#g\" \"$devEnv\"/terraform.tfstate\n\t\tif [ -f \"$devEnv\"/terraform.tfstate.backup ]; then\n\t\t\tsed -i '' -e \"s#$DevSecret#$redaction#g\" \"$devEnv\"/terraform.tfstate.backup\n\t\tfi\n\tfi\n\n\tDevSmtpSecret=$(echo $TerraformOutputDev | jq '[.\"'\"$sesPassword\"'\"|.value]' | cut -d '\"' -f2 -s)\n\tif ! [ -z $DevSmtpSecret ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$devEnv\" SMTP Secret: $DevSmtpSecret\n\t\tfi\n\t\tsed -i '' -e \"s#$DevSmtpSecret#$redaction#g\" \"$devEnv\"/terraform.tfstate\n\t\tif [ -f \"$devEnv\"/terraform.tfstate.backup ]; then\n\t\t\tsed -i '' -e \"s#$DevSmtpSecret#$redaction#g\" \"$devEnv\"/terraform.tfstate.backup\n\t\tfi\n\tfi\n\tTerraformRedactedDev=$(cd \"$devEnv\" && terraform output -json)\n\techo \"$devEnv\" IAM Secret:\n\techo $TerraformRedactedDev | jq '[.\"'\"$iamSecret\"'\"]'\n\techo\n\techo \"$devEnv\" SMTP Secret:\n\techo $TerraformRedactedDev | jq '[.\"'\"$sesPassword\"'\"]'\nelse\n\techo\n\tfail \"No \"$devEnv\" Environment Found.\"\n\techo\nfi\n\n\n# TF State Staging\n\nif [ -f \"$stagingEnv\"/terraform.tfstate ]; then\n\tmessage Redacting \"$stagingEnv\"\n\tTerraformOutputStaging=$(cd \"$stagingEnv\" && terraform output -json)\n\n\tStagingSecret=$(echo $TerraformOutputStaging | jq '[.\"'\"$iamSecret\"'\"|.value]' | cut -d '\"' -f2 -s)\n\tif ! [ -z $StagingSecret ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$stagingEnv\" IAM Secret: $StagingSecret\n\t\tfi\n\t\tsed -i '' -e \"s#$StagingSecret#$redaction#g\" \"$stagingEnv\"/terraform.tfstate\n\t\tif [ -f \"$stagingEnv\"/terraform.tfstate.backup ]; then\n\t\t\tsed -i '' -e \"s#$StagingSecret#$redaction#g\" \"$stagingEnv\"/terraform.tfstate.backup\n\t\tfi\n\tfi\n\n\tStagingSmtpSecret=$(echo $TerraformOutputStaging | jq '[.\"'\"$sesPassword\"'\"|.value]' | cut -d '\"' -f2 -s)\n\tif ! [ -z $StagingSmtpSecret ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$stagingEnv\" SMTP Secret: $StagingSmtpSecret\n\t\tfi\n\t\tsed -i '' -e \"s#$StagingSmtpSecret#$redaction#g\" \"$stagingEnv\"/terraform.tfstate\n\t\tif [ -f \"$stagingEnv\"/terraform.tfstate.backup ]; then\n\t\t\tsed -i '' -e \"s#$StagingSmtpSecret#$redaction#g\" \"$stagingEnv\"/terraform.tfstate.backup\n\t\tfi\n\tfi\n\tTerraformRedactedStaging=$(cd \"$stagingEnv\" && terraform output -json)\n\techo \"$stagingEnv\" IAM Secret:\n\techo $TerraformRedactedStaging | jq '[.\"'\"$iamSecret\"'\"]'\n\techo\n\techo \"$stagingEnv\" SMTP Secret:\n\techo $TerraformRedactedStaging | jq '[.\"'\"$sesPassword\"'\"]'\nelse\n\techo\n\tfail \"No \"$stagingEnv\" Environment Found.\"\n\techo\nfi\n\n\n# TF State Production\n\nif [ -f \"$productionEnv\"/terraform.tfstate ]; then\n\tmessage Redacting \"$productionEnv\"\n\tTerraformOutputProduction=$(cd \"$productionEnv\" && terraform output -json)\n\n\tProductionSecret=$(echo $TerraformOutputProduction | jq '[.\"'\"$iamSecret\"'\"|.value]' | cut -d '\"' -f2 -s)\n\tif ! [ -z $ProductionSecret ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$productionEnv\" IAM Secret: $ProductionSecret\n\t\tfi\n\t\tsed -i '' -e \"s#$ProductionSecret#$redaction#g\" \"$productionEnv\"/terraform.tfstate\n\t\tif [ -f \"$productionEnv\"/terraform.tfstate.backup ]; then\n\t\t\tsed -i '' -e \"s#$ProductionSecret#$redaction#g\" \"$productionEnv\"/terraform.tfstate.backup\n\t\tfi\n\tfi\n\n\tProductionSmtpSecret=$(echo $TerraformOutputProduction | jq '[.\"'\"$sesPassword\"'\"|.value]' | cut -d '\"' -f2 -s)\n\tif ! [ -z $ProductionSmtpSecret ]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"$productionEnv\" SMTP Secret: $ProductionSmtpSecret\n\t\tfi\n\t\tsed -i '' -e \"s#$ProductionSmtpSecret#$redaction#g\" \"$productionEnv\"/terraform.tfstate\n\t\tif [ -f \"$productionEnv\"/terraform.tfstate.backup ]; then\n\t\t\tsed -i '' -e \"s#$ProductionSmtpSecret#$redaction#g\" \"$productionEnv\"/terraform.tfstate.backup\n\t\tfi\n\tfi\n\tTerraformRedactedProduction=$(cd \"$productionEnv\" && terraform output -json)\n\techo \"$productionEnv\" IAM Secret:\n\techo $TerraformRedactedProduction | jq '[.\"'\"$iamSecret\"'\"]'\n\techo\n\techo \"$productionEnv\" SMTP Secret:\n\techo $TerraformRedactedProduction | jq '[.\"'\"$sesPassword\"'\"]'\nelse\n\techo\n\tfail \"No \"$productionEnv\" Environment Found.\"\n\techo\nfi\n\ncompleted\n"
        },
        {
          "name": "vpc-eni-monitor.sh",
          "type": "blob",
          "size": 4.4404296875,
          "content": "#!/usr/bin/env bash\n\n# This script will generate an HTML page to monitor the number of AWS VPC Elastic Network Interfaces currently in use and upload it to an S3 bucket website\n# Requires the AWS CLI, jq\n\n# Set Variables\nVPCID=\"YOUR-VPC-ID-HERE\"\n# AWS CLI Profile for VPC ID\nPROFILE1=\"CLI-PROFILE-FOR-VPC\"\n# AWS CLI Profile for S3 Bucket\nPROFILE2=\"CLI-PROFILE-FOR-S3-BUCKET\"\nHTMLFILENAME=\"vpc-eni-monitor.html\"\nS3BUCKETPATH=\"s3://YOUR-S3-BUCKET-HERE/\"\n\nminENI=0\nmaxENI=0\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Validate VPC ID\nfunction validateVPCID(){\n\tif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ] || [ -z \"$VPCID\" ]; then\n\t\t# Count number of VPCs\n\t\tDESCRIBEVPCS=$(aws ec2 describe-vpcs --profile $PROFILE1 2>&1)\n\t\tif echo $DESCRIBEVPCS | egrep -q \"Error|error|not\"; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tNUMVPCS=$(echo $DESCRIBEVPCS | jq '.Vpcs | length')\n\t\tif echo $NUMVPCS | egrep -q \"Error|error|not|invalid\"; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\n\t\t# If only one VPC, use that ID\n\t\tif [ \"$NUMVPCS\" -eq \"1\" ]; then\n\t\t\tVPCID=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\telse\n\t\t\tFOUNDVPCS=$(aws ec2 describe-vpcs --profile $PROFILE1 2>&1 | jq '.Vpcs | .[] | .VpcId')\n\t\t\tif echo $FOUNDVPCS | egrep -q \"Error|error|not|invalid\"; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\t\t\techo \"Found VPCs:\" $FOUNDVPCS\n\t\t\techo\n\t\t\tread -r -p \"Please specify VPC ID (ex. vpc-12345678): \" VPCID\n\t\t\tif [ -z \"$VPCID\" ]; then\n\t\t\t\tfail \"Must specify a valid VPC ID.\"\n\t\t\tfi\n\t\tfi\n\tfi\n\tCHECKVPC=$(aws ec2 describe-vpcs --vpc-ids \"$VPCID\" --profile $PROFILE1 2>&1)\n\n\t# Test for error\n\tif ! echo \"$CHECKVPC\" | grep -q \"available\"; then\n\t\tfail $CHECKVPC\n\telse\n\t\tHorizontalRule\n\t\ttput setaf 2; echo \"VPC ID Validated\" && tput sgr0\n\t\tHorizontalRule\n\tfi\n}\n\n# Main function to generate the HTML and upload to S3\nfunction generateHTML(){\n\twhile :\n\tdo\n\t\tENI=$(aws ec2 describe-network-interfaces --filters Name=vpc-id,Values=$VPCID --profile $PROFILE1 2>&1 | jq '.NetworkInterfaces | .[] | .NetworkInterfaceId' | wc -l | rev | cut -d ' ' -f1 | rev)\n\t\tif echo $ENI | grep -q error; then\n\t\t\tfail \"$ENI\"\n\t\tfi\n\t\tdate\n\t\techo ENIs: $ENI\n\t\t(\n\t\tcat << 'EOP'\n<html>\n\t<head>\n\t\t<meta http-equiv=\"refresh\" content=\"5\">\n\t\t<title>Elastic Network Interface Count\n\t\t</title>\n\t</head>\n\t<body>\n\t\t<center><p style=\"font-size:15vmax;font-family:courier,serif\">ENIs:\nEOP\n\t\t) > $HTMLFILENAME\n\n\t\techo '\t\t'$ENI >> $HTMLFILENAME\n\t\t(\n\t\tcat << 'EOP'\n\t\t</p>\n\t\t<center><p style=\"font-size:3vmax;font-family:courier,serif\">Updated:\nEOP\n\t\t) >> $HTMLFILENAME\n\t\techo '\t\t'$(date) >> $HTMLFILENAME\n\n\t\tif [ $minENI -eq \"0\" ]; then\n\t\t\tminENI=$ENI\n\t\t\tmaxENI=$ENI\n\t\tfi\n\t\tif [ $ENI -eq $minENI ] && [ $ENI -eq $maxENI ]; then\n\t\t\ttrend=flat\n\t\tfi\n\t\tif [ $ENI -lt $minENI ]; then\n\t\t\tminENI=$ENI\n\t\t\ttrend=down\n\t\tfi\n\t\tif [ $ENI -gt $maxENI ]; then\n\t\t\tmaxENI=$ENI\n\t\t\ttrend=up\n\t\tfi\n\n\t\techo minENIs: $minENI\n\t\techo maxENIs: $maxENI\n\t\techo trending: $trend\n\n\t\techo '\t\t<br><br>'minENI = $minENI >> $HTMLFILENAME\n\t\techo '\t\t<br>'maxENI = $maxENI >> $HTMLFILENAME\n\t\techo '\t\t<br>' >> $HTMLFILENAME\n\n\t\tif [ \"$trend\" = \"flat\" ]; then\n\t\t\techo '\t\t<p style=\"font-size:4vmax;color:black\">---' >> $HTMLFILENAME\n\t\tfi\n\t\tif [ \"$trend\" = \"up\" ]; then\n\t\t\techo '\t\t<p style=\"font-size:4vmax;color:green\">/\\' >> $HTMLFILENAME\n\t\tfi\n\t\tif [ \"$trend\" = \"down\" ]; then\n\t\t\techo '\t\t<p style=\"font-size:4vmax;color:red\">\\/' >> $HTMLFILENAME\n\t\tfi\n\n\t\t(\n\t\tcat << 'EOP'\n\t\t</p></center>\n\t</body>\n</html>\nEOP\n\t\t) >> $HTMLFILENAME\n\n\t\tUPLOAD=$(aws s3 cp $HTMLFILENAME $S3BUCKETPATH --profile $PROFILE2 2>&1)\n\t\tif echo $UPLOAD | egrep -q \"Error|error|not\"; then\n\t\t\tfail \"$UPLOAD\"\n\t\tfi\n\t\techo $UPLOAD\n\n\t\tif [ $ENI -lt \"100\" ]; then\n\t\t\tsleep=60\n\t\t\techo \"sleeping $sleep seconds...\"\n\t\t\tHorizontalRule\n\t\t\techo\n\t\t\tsleep $sleep\n\t\telse\n\t\t\tsleep=3\n\t\t\techo \"sleeping $sleep seconds...\"\n\t\t\tHorizontalRule\n\t\t\techo\n\t\t\tsleep $sleep\n\t\tfi\n\tdone\n}\n\n\n# Check for required applications\ncheck_command \"aws\"\ncheck_command \"jq\"\n\nvalidateVPCID\ngenerateHTML\n"
        },
        {
          "name": "vpc-sg-import-rules-cloudflare.sh",
          "type": "blob",
          "size": 4.6787109375,
          "content": "#!/usr/bin/env bash\n\n# Create VPC Security Group with CloudFlare IP ranges\n# Requires curl, jq\n\n# Get current list of CloudFlare IP ranges\nIPLIST=$(curl -s https://www.cloudflare.com/ips-v4)\n\n# Set Variables\nGROUPNAME=\"CloudFlare\"\nDESCR=\"CloudFlare IP Ranges\"\nVPCID=\"YOUR-VPC-ID-HERE\"\n# VPCID=$(aws ec2 describe-vpcs --output=json | jq '.Vpcs | .[] | .VpcId' | cut -d '\"' -f2)\nPROTO=\"tcp\"\nPORT=\"443\"\nTOTALIPS=$(echo \"$IPLIST\" | wc -l | tr -d ' ')\n\n# Functions\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Ensure Variables are set\nif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ]; then\n\tfail \"Failed to set variables!\"\nfi\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n\nfunction checkGroups (){\n\t# Check for existing security group or create new one\n\tif ! aws ec2 describe-security-groups --output=json --profile $profile 2>&1 | jq '.SecurityGroups | .[] | .GroupName' | grep -q CloudFlare; then\n\t\techo\n\t\techo \"=====================================================\"\n\t\techo \"Creating Security Group \"$GROUPNAME\n\t\tGROUPID=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$DESCR\" --vpc-id $VPCID --profile $profile 2>&1 | jq '.GroupId' | cut -d '\"' -f2)\n\t\techo $GROUPID\n\t\taws ec2 create-tags --resources $(aws ec2 describe-security-groups --output=json --profile $profile 2>&1 | jq '.SecurityGroups | .[] | select(.GroupName==\"CloudFlare\") | .GroupId' | cut -d '\"' -f2) --tags Key=Name,Value=\"$GROUPNAME\" --profile $profile 2>&1\n\t\techo \"=====================================================\"\n\n\t\taddRules\n\telse\n\t\techo\n\t\techo \"=====================================================\"\n\t\techo \"Group $GROUPNAME Already Exists\"\n\t\tGROUPID=$(aws ec2 describe-security-groups --output=json --profile $profile 2>&1 | jq '.SecurityGroups | .[] | select(.GroupName==\"CloudFlare\") | .GroupId' | cut -d '\"' -f2)\n\t\tread -r -p \"Do you want to delete the group and recreate it? (y/n) \" DELETEGROUP\n\t\tif [[ $DELETEGROUP =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\techo\n\t\t\techo \"=====================================================\"\n\t\t\techo \"Deleting Group Name $GROUPNAME, Security Group ID $GROUPID\"\n\t\t\techo \"=====================================================\"\n\t\t\tDELETEGROUP=$(aws ec2 delete-security-group --group-id \"$GROUPID\" --profile $profile 2>&1)\n\t\t\tif echo $DELETEGROUP | grep -q error; then\n\t\t\t\tfail $DELETEGROUP\n\t\t\telse\n\t\t\t\techo\n\t\t\t\techo \"=====================================================\"\n\t\t\t\techo \"Creating Security Group \"$GROUPNAME\n\t\t\t\tGROUPID=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$DESCR\" --vpc-id $VPCID --profile $profile 2>&1 | jq '.GroupId' | cut -d '\"' -f2)\n\t\t\t\techo $GROUPID\n\t\t\t\taws ec2 create-tags --resources $(aws ec2 describe-security-groups --output=json --profile $profile 2>&1 | jq '.SecurityGroups | .[] | select(.GroupName==\"CloudFlare\") | .GroupId' | cut -d '\"' -f2) --tags Key=Name,Value=\"$GROUPNAME\" --profile $profile 2>&1\n\t\t\t\techo \"=====================================================\"\n\n\t\t\t\taddRules\n\t\t\tfi\n\t\telse\n\t\t\tread -r -p \"Do you want to add additional IPs to the existing group? (y/n) \" ADDGROUP\n\t\t\tif [[ $ADDGROUP =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\t\taddRules\n\t\t\telse\n\t\t\t\techo \"Exiting\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\nfunction addRules (){\n\techo\n\techo \"=====================================================\"\n\techo \"Adding rules to VPC Security Group \"$GROUPNAME\n\techo \"Records to be created: \"$TOTALIPS\n\techo \"=====================================================\"\n\techo\n\tfor ip in $IPLIST\n\tdo\n\t\tRESULT=$(aws ec2 authorize-security-group-ingress --group-id \"$GROUPID\" --protocol $PROTO --port $PORT --cidr \"$ip\" --profile $profile 2>&1)\n\t\t# Check for errors\n\t\tif echo $RESULT | grep -q error; then\n\t\t\tfail $RESULT\n\t\t# else echo $RESULT\n\t\tfi\n\tdone\n\techo \"=====================================================\"\n\techo\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\techo\n}\n\n\n\n# Check required commands\ncheck_command \"curl\"\ncheck_command \"jq\"\n\ncheckGroups\n"
        },
        {
          "name": "vpc-sg-import-rules-cloudfront.sh",
          "type": "blob",
          "size": 7.28125,
          "content": "#!/usr/bin/env bash\n\n# Create VPC Security Group with CloudFront IP ranges\n\n# Get current list of CloudFront IP ranges\nIPLIST=$(curl -s https://ip-ranges.amazonaws.com/ip-ranges.json | jq '.prefixes | .[] | select(.service==\"CLOUDFRONT\") | .ip_prefix' | cut -d \\\" -f2 | sort)\n\n# Set Variables\nGROUPNAME=\"CloudFront\"\nDESCR=\"CloudFront IP Ranges\"\nVPCID=\"YOUR-VPC-ID-HERE\"\nPROTO=\"tcp\"\nPORT=\"443\"\nTOTALIPS=$(echo \"$IPLIST\" | wc -l)\n\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command(){\n\tfor command in \"$@\"\n\tdo\n\t    type -P $command &>/dev/null || fail \"Unable to find $command, please install it and run this script again.\"\n\tdone\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\techo\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Validate VPC ID\nfunction validateVPCID(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function validateVPCID\"\n\tfi\n\tif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ] || [ -z \"$VPCID\" ]; then\n\t\t# Count number of VPCs\n\t\tDESCRIBEVPCS=$(aws ec2 describe-vpcs --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tif echo $DESCRIBEVPCS | egrep -iq \"error|not\"; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tNUMVPCS=$(echo $DESCRIBEVPCS | jq '.Vpcs | length')\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\t\tif echo $NUMVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\n\t\t# If only one VPC, use that ID\n\t\tif [ \"$NUMVPCS\" -eq \"1\" ]; then\n\t\t\tVPCID=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VPCID\"\n\t\t\tfi\n\t\telse\n\t\t\tFOUNDVPCS=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\t\t\tif echo $FOUNDVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\n\t\t\tHorizontalRule\n\t\t\techo \"Found VPCs:\"\n\t\t\tHorizontalRule\n\t\t\t# Get VPC Names\n\t\t\tfor vpcid in $FOUNDVPCS; do\n\t\t\t\techo $vpcid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$vpcid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\t\t\tdone\n\t\t\techo\n\t\t\tread -r -p \"Please specify VPC ID (ex. vpc-abcd1234): \" VPCID\n\t\t\tif [ -z \"$VPCID\" ]; then\n\t\t\t\tfail \"Must specify a valid VPC ID.\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tCHECKVPC=$(aws ec2 describe-vpcs --vpc-ids \"$VPCID\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHECKVPC\"\n\tfi\n\tif ! echo \"$CHECKVPC\" | grep -q \"available\"; then\n\t\tfail $CHECKVPC\n\telse\n\t\ttput setaf 2; echo \"VPC ID Validated\" && tput sgr0\n\tfi\n}\n\n# Check for existing security group or create new one\nfunction checkExisting(){\n\t# Group Name Variations\n\tGROUPNAMELOWER=$(echo \"$GROUPNAME\" | awk '{print tolower($0)}')\n\tGROUPNAMEUPPER=$(echo \"$GROUPNAME\" | awk '{print toupper($0)}')\n\tGROUPNAMETITLE=$(echo \"$GROUPNAMELOWER\" | awk '{for (i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)} 1')\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"GROUPNAME: $GROUPNAME\"\n\t\techo \"GROUPNAMELOWER: $GROUPNAMELOWER\"\n\t\techo \"GROUPNAMEUPPER: $GROUPNAMEUPPER\"\n\t\techo \"GROUPNAMETITLE: $GROUPNAMETITLE\"\n\tfi\n\n\tDESCRIBEGROUPS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=\"$VPCID\" --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$DESCRIBEGROUPS\"\n\tfi\n\n\tif echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAME'\")' | egrep -iq \"$GROUPNAME\"; then\n\t\techo\n\t\tHorizontalRule\n\t\ttput setaf 1; echo \"Group $GROUPNAME Already Exists\" && tput sgr0\n\t\tGROUPID=$(echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAME'\") | .GroupId' | cut -d \\\" -f2)\n\t\tdeleteExisting\n\tfi\n\tif echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAMELOWER'\")' | egrep -iq \"$GROUPNAMELOWER\"; then\n\t\techo\n\t\tHorizontalRule\n\t\ttput setaf 1; echo \"Group $GROUPNAMELOWER Already Exists\" && tput sgr0\n\t\tGROUPID=$(echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAMELOWER'\") | .GroupId' | cut -d \\\" -f2)\n\t\tdeleteExisting\n\tfi\n\tif echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAMEUPPER'\")' | egrep -iq \"$GROUPNAMEUPPER\"; then\n\t\techo\n\t\tHorizontalRule\n\t\ttput setaf 1; echo \"Group $GROUPNAMEUPPER Already Exists\" && tput sgr0\n\t\tGROUPID=$(echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAMEUPPER'\") | .GroupId' | cut -d \\\" -f2)\n\t\tdeleteExisting\n\tfi\n\tif echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAMETITLE'\")' | egrep -iq \"$GROUPNAMETITLE\"; then\n\t\techo\n\t\tHorizontalRule\n\t\ttput setaf 1; echo \"Group $GROUPNAMETITLE Already Exists\" && tput sgr0\n\t\tGROUPID=$(echo \"$DESCRIBEGROUPS\" | jq '.SecurityGroups | .[] | select(.GroupName==\"'$GROUPNAMETITLE'\") | .GroupId' | cut -d \\\" -f2)\n\t\tdeleteExisting\n\tfi\n}\n\n# Delete existing group\nfunction deleteExisting(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo DEBUG EXISTING GROUPID: \"$GROUPID\"\n\tfi\n\tread -r -p \"Do you want to delete the group and recreate it? (y/n) \" DELETEGROUP\n\tif [[ $DELETEGROUP =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Deleting Security Group ID: $GROUPID\"\n\t\tHorizontalRule\n\t\tDELETEGROUP=$(aws ec2 delete-security-group --group-id \"$GROUPID\" --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$GROUPID\"\n\t\tfi\n\t\tif echo $DELETEGROUP | grep -q error; then\n\t\t\tfail $DELETEGROUP\n\t\tfi\n\t\tcompleted\n\telse\n\t\techo \"Canceled.\"\n\t\texit 1\n\tfi\n}\n\n# Create Security Group\nfunction createGroup(){\n\techo\n\tHorizontalRule\n\techo \"Creating Security Group \"$GROUPNAME\n\tGROUPID=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$DESCR\" --vpc-id \"$VPCID\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$GROUPID\"\n\telse\n\t\tGROUPID=$(echo \"$GROUPID\" | jq '.GroupId' | cut -d \\\" -f2)\n\tfi\n\techo \"ID: $GROUPID\"\n\tTAGS=$(aws ec2 create-tags --resources \"$GROUPID\" --tags Key=Name,Value=\"$GROUPNAME\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TAGS\"\n\tfi\n\tHorizontalRule\n}\n\n# Add Rules to Security Group\nfunction addRules(){\n\techo\n\tHorizontalRule\n\techo \"Adding rules to VPC Security Group \"$GROUPNAME\n\techo \"Records to be created: \"$TOTALIPS\n\tHorizontalRule\n\techo\n\tfor ip in $IPLIST\n\tdo\n\t\tRESULT=$(aws ec2 authorize-security-group-ingress --group-id \"$GROUPID\" --protocol $PROTO --port $PORT --cidr \"$ip\" --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$RESULT\"\n\t\tfi\n\tdone\n\tcompleted\n}\n\n\n# Check required commands\ncheck_command curl jq\n\nvalidateVPCID\ncheckExisting\ncreateGroup\naddRules\n"
        },
        {
          "name": "vpc-sg-import-rules-pingdom.sh",
          "type": "blob",
          "size": 19.6923828125,
          "content": "#!/usr/bin/env bash\n\n# This script will save a list of current Pingdom IPv4 probe server IPs in the file pingdom-probe-servers.txt\n# Then create an AWS VPC Security Group with rules to allow access to each IP at the port specified.\n\n# Pingdom currently has 114 IPv4 probe IPs. Due to AWS limits a security group can only have 60 rules,\n# Therefore multiple groups will be needed to contain all IPs for Pingdom probes.\n# (https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html#vpc-limits-security-groups)\n\n# If security groups have already been created for Pingdom, the script will remove all the IP rules and\n# add new rules to the same groups so they are not deleted and groups are still assigned to your resources.\n\n# This script currently supports up to 180 probe IPs (three security groups).\n# Requires the AWS CLI, jq, wget, perl\n\n# Set Variables\nGROUPNAME=\"Pingdom\"\nDESCRIPTION=\"Pingdom Probe Servers\"\nVPCID=\"YOUR-VPC-ID-HERE\"\nPROTOCOL=\"tcp\"\n# If allowing only one port use the same port number for both from and to vars below\nFROMPORT=\"80\"\nTOPORT=\"443\"\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Check Command\nfunction check_command(){\n\tfor command in \"$@\"\n\tdo\n\t    type -P $command &>/dev/null || fail \"Unable to find $command, please install it and run this script again.\"\n\tdone\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Get Pingdom IPv4 IPs\n# https://help.pingdom.com/hc/en-us/articles/203682601-How-to-get-all-Pingdom-probes-public-IP-addresses\nfunction probeIPs(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function probeIPs\"\n\tfi\n\twget --quiet -O- https://www.pingdom.com/rss/probe_servers.xml | \\\n\tperl -nle 'print $1 if /IP: (([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5]));/' | \\\n\tsort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 | \\\n\tuniq > pingdom-probe-servers.txt\n\n\tTOTALIPS=$(cat pingdom-probe-servers.txt | wc -l | tr -d ' ')\n\n\tif ! [ \"$TOTALIPS\" -gt \"0\" ]; then\n\t\tfail \"Unable to lookup Pingdom IPs.\"\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Total Pingdom IPs: \"$TOTALIPS\n\tHorizontalRule\n\techo\n}\n\n# Create Security Groups\nfunction createGroups(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function createGroups\"\n\t\techo var1: \"$1\"\n\t\techo var2: \"$2\"\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Creating Security Group: \"$1\n\tSGID=$(aws ec2 create-security-group --group-name \"$1\" --description \"$2\" --vpc-id $VPCID --profile $profile 2>&1 | jq '.GroupId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SGID\"\n\tfi\n\tif echo $SGID | grep -q \"error\"; then\n\t\tfail \"$SGID\"\n\tfi\n\techo \"Security Group ID:\" $SGID\n\tTAG=$(aws ec2 create-tags --resources $SGID --tags Key=Name,Value=\"$1\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TAG\"\n\tfi\n\tif echo $TAG | grep -q \"error\"; then\n\t\tfail \"$TAG\"\n\tfi\n\tHorizontalRule\n\techo\n}\n\n# Builds the JSON for 61-120 rules\nfunction buildJSON120(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function buildJSON120\"\n\tfi\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID1\",\n    \"IpPermissions\": [\n        {\n            \"IpProtocol\": \"$PROTOCOL\",\n            \"FromPort\": $FROMPORT,\n            \"ToPort\": $TOPORT,\n            \"IpRanges\": [\nEOP\n\t) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\trm -f json2\n\n\tSTART=1\n\tfor (( COUNT=$START; COUNT<=60; COUNT++ ))\n\tdo\n\tiplist=$(nl pingdom-probe-servers.txt | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t# if [[ $DEBUGMODE = \"1\" ]]; then\n\t# \techo iplist:\n\t# \techo\n\t# \techo \"$iplist\"\n\t# \techo\n\t# \t# pause\n\t# fi\n\t(\n\tcat << EOP\n                {\n                    \"CidrIp\": \"$iplist/32\"\n                },\nEOP\n\t) >> json2\n\tdone\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n\t(\n\tcat << 'EOP'\n            ]\n        }\n    ]\n}\nEOP\n\t) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json\n\tfi\n\n\t# GROUP 2\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID2\",\n    \"IpPermissions\": [\n        {\n            \"IpProtocol\": \"$PROTOCOL\",\n            \"FromPort\": $FROMPORT,\n            \"ToPort\": $TOPORT,\n            \"IpRanges\": [\nEOP\n\t) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\trm -f json2\n\n\tSTART=61\n\tfor (( COUNT=$START; COUNT<=$TOTALIPS; COUNT++ ))\n\tdo\n\tiplist=$(nl pingdom-probe-servers.txt | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t(\n\tcat << EOP\n                {\n                    \"CidrIp\": \"$iplist/32\"\n                },\nEOP\n\t) >> json2\n\tdone\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n\t(\n\tcat << 'EOP'\n            ]\n        }\n    ]\n}\nEOP\n\t) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json6\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json6\n\tfi\n\n}\n\n\n# Builds the JSON for 121-180 rules\nfunction buildJSON180(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function buildJSON100\"\n\tfi\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID1\",\n    \"IpPermissions\": [\n        {\n            \"IpProtocol\": \"$PROTOCOL\",\n            \"FromPort\": $FROMPORT,\n            \"ToPort\": $TOPORT,\n            \"IpRanges\": [\nEOP\n\t) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\trm -f json2\n\n\tSTART=1\n\tfor (( COUNT=$START; COUNT<=60; COUNT++ ))\n\tdo\n\tiplist=$(nl pingdom-probe-servers.txt | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t(\n\tcat << EOP\n                {\n                    \"CidrIp\": \"$iplist/32\"\n                },\nEOP\n\t) >> json2\n\tdone\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n\t(\n\tcat << 'EOP'\n            ]\n        }\n    ]\n}\nEOP\n\t) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json\n\tfi\n\n\t# GROUP 2\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID2\",\n    \"IpPermissions\": [\n        {\n            \"IpProtocol\": \"$PROTOCOL\",\n            \"FromPort\": $FROMPORT,\n            \"ToPort\": $TOPORT,\n            \"IpRanges\": [\nEOP\n\t) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\trm -f json2\n\n\tSTART=61\n\tfor (( COUNT=$START; COUNT<=120; COUNT++ ))\n\tdo\n\tiplist=$(nl pingdom-probe-servers.txt | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t(\n\tcat << EOP\n                {\n                    \"CidrIp\": \"$iplist/32\"\n                },\nEOP\n\t) >> json2\n\tdone\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n\t(\n\tcat << 'EOP'\n            ]\n        }\n    ]\n}\nEOP\n\t) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json6\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json6\n\tfi\n\n\t# GROUP 3\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID3\",\n    \"IpPermissions\": [\n        {\n            \"IpProtocol\": \"$PROTOCOL\",\n            \"FromPort\": $FROMPORT,\n            \"ToPort\": $TOPORT,\n            \"IpRanges\": [\nEOP\n\t) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\trm -f json2\n\n\tSTART=121\n\tfor (( COUNT=$START; COUNT<=$TOTALIPS; COUNT++ ))\n\tdo\n\tiplist=$(nl pingdom-probe-servers.txt | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t(\n\tcat << EOP\n                {\n                    \"CidrIp\": \"$iplist/32\"\n                },\nEOP\n\t) >> json2\n\tdone\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n\t(\n\tcat << 'EOP'\n            ]\n        }\n    ]\n}\nEOP\n\t) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json7\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json7\n\tfi\n}\n\n# Request ingress authorization to a security group from JSON file\nfunction AuthorizeSecurityGroupIngress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function AuthorizeSecurityGroupIngress\"\n\tfi\n\tif ! [ -f json ]; then\n\t\tfail \"Error building JSON.\"\n\telse\n\t\tjson=$(cat json)\n\tfi\n\tHorizontalRule\n\techo \"Adding rules to security groups...\"\n\tHorizontalRule\n\techo\n\tAUTHORIZE=$(aws ec2 authorize-security-group-ingress --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n\tif echo $AUTHORIZE | grep -q error; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n}\n\n# Create AWS VPC Security Groups\n\n# Create multiple groups for 61-120 rules\nfunction group120(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function group120\"\n\tfi\n\n\tif ! [[ \"$GroupsAlreadyExist\" -eq \"1\" ]]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Groups Do Not Already Exist...\"\n\t\tfi\n\t\t# Set Variables for Group #1\n\t\tFIRSTGROUPNAME=\"$GROUPNAME 1\"\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"FIRSTGROUPNAME: \"$FIRSTGROUPNAME\n\t\tfi\n\t\tFIRSTDESCR=\"$DESCRIPTION 1-60\"\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"FIRSTDESCR: \"$FIRSTDESCR\n\t\tfi\n\n\t\tcreateGroups \"$FIRSTGROUPNAME\" \"$FIRSTDESCR\"\n\t\tSGID1=\"$SGID\"\n\n\t\t# Set Variables for Group #2\n\t\tSECONDGROUPNAME=\"$GROUPNAME 2\"\n\t\tSECONDDESCR=\"$DESCRIPTION 61-$TOTALIPS\"\n\n\t\tcreateGroups \"$SECONDGROUPNAME\" \"$SECONDDESCR\"\n\t\tSGID2=\"$SGID\"\n\tfi\n\n\tbuildJSON120\n\tAuthorizeSecurityGroupIngress\n\tcp json6 json\n\tAuthorizeSecurityGroupIngress\n\tcompleted\n}\n\n# Create multiple groups for 121-180 rules\nfunction group180(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function group100\"\n\tfi\n\n\tif ! [[ \"$GroupsAlreadyExist\" -eq \"1\" ]]; then\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"Groups Do Not Already Exist...\"\n\t\tfi\n\t\t# Set Variables for Group #1\n\t\tFIRSTGROUPNAME=\"$GROUPNAME 1\"\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"FIRSTGROUPNAME: \"$FIRSTGROUPNAME\n\t\tfi\n\t\tFIRSTDESCR=\"$DESCRIPTION 1-60\"\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"FIRSTDESCR: \"$FIRSTDESCR\n\t\tfi\n\n\t\tcreateGroups \"$FIRSTGROUPNAME\" \"$FIRSTDESCR\"\n\t\tSGID1=\"$SGID\"\n\n\t\t# Set Variables for Group #2\n\t\tSECONDGROUPNAME=\"$GROUPNAME 2\"\n\t\tSECONDDESCR=\"$DESCRIPTION 61-120\"\n\n\t\tcreateGroups \"$SECONDGROUPNAME\" \"$SECONDDESCR\"\n\t\tSGID2=\"$SGID\"\n\n\t\t# Set Variables for Group #3\n\t\tTHIRDGROUPNAME=\"$GROUPNAME 3\"\n\t\tTHIRDDESCR=\"$DESCRIPTION 121-$TOTALIPS\"\n\n\t\tcreateGroups \"$THIRDGROUPNAME\" \"$THIRDDESCR\"\n\t\tSGID3=\"$SGID\"\n\tfi\n\n\tbuildJSON180\n\tAuthorizeSecurityGroupIngress\n\tcp json6 json\n\tAuthorizeSecurityGroupIngress\n\tcp json7 json\n\tAuthorizeSecurityGroupIngress\n\tcompleted\n}\n\n# Validate VPC ID\nfunction validateVPCID(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function validateVPCID\"\n\tfi\n\tif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ] || [ -z \"$VPCID\" ]; then\n\t\t# Count number of VPCs\n\t\tDESCRIBEVPCS=$(aws ec2 describe-vpcs --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tif echo $DESCRIBEVPCS | egrep -iq \"error|not\"; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tNUMVPCS=$(echo $DESCRIBEVPCS | jq '.Vpcs | length')\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\t\tif echo $NUMVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\n\t\t# If only one VPC, use that ID\n\t\tif [ \"$NUMVPCS\" -eq \"1\" ]; then\n\t\t\tVPCID=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VPCID\"\n\t\t\tfi\n\t\telse\n\t\t\tFOUNDVPCS=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\t\t\tif echo $FOUNDVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\n\t\t\tHorizontalRule\n\t\t\techo \"Found VPCs:\"\n\t\t\tHorizontalRule\n\t\t\t# Get VPC Names\n\t\t\tfor vpcid in $FOUNDVPCS; do\n\t\t\t\techo $vpcid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$vpcid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\t\t\tdone\n\t\t\techo\n\t\t\tread -r -p \"Please specify VPC ID (ex. vpc-abcd1234): \" VPCID\n\t\t\tif [ -z \"$VPCID\" ]; then\n\t\t\t\tfail \"Must specify a valid VPC ID.\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tCHECKVPC=$(aws ec2 describe-vpcs --vpc-ids \"$VPCID\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHECKVPC\"\n\tfi\n\tif ! echo \"$CHECKVPC\" | grep -q \"available\"; then\n\t\tfail $CHECKVPC\n\telse\n\t\ttput setaf 2; echo \"VPC ID Validated\" && tput sgr0\n\tfi\n}\n\n# Confirm the group with this name does not already exist in the VPC\nfunction validateGroupName(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function validateGroupName\"\n\t\techo \"GROUPNAME $GROUPNAME\"\n\tfi\n\tvalidateGroupName=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=\"$VPCID\" --output=json --profile $profile 2>&1 | jq '.SecurityGroups | .[] | .GroupName')\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$validateGroupName\"\n\tfi\n\tif echo \"$validateGroupName\" | egrep -iq \"\\b$GROUPNAME\\b|\\b$GROUPNAME 1\\b\"; then\n\t\ttput setaf 1; echo Security Group\\(s\\) $(echo \"$validateGroupName\" | egrep -i \"\\b$GROUPNAME\\b|\\b$GROUPNAME 1\\b\" | sort) already exist in specified VPC. && tput sgr0\n\n\t\t# TODO: This part is too complicated to handle smoothly...\n\t\ttput setaf 1; read -r -p \"Do you want to remove the existing IPs and add new IPs? (y/n) \" deleteIPs && tput sgr0\n\t\tif [[ $deleteIPs =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\tdeleteIPs\n\t\telse\n\t\t\tGroupsAlreadyExist=\"1\"\n\t\t\tfindGroups\n\t\t# \techo \"Exiting\"\n\t\t# \texit 1\n\t\tfi\n\tfi\n}\n\n# Look up the security group IDs\nfunction findGroups(){\n\tFindGroups=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=\"$VPCID\" --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$FindGroups\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"$FindGroups\" | jq .\n\tfi\n\n\t# Assuming there are exactly 2 groups\n\tSGID1=$(echo \"$FindGroups\" | jq -r --arg GROUPNAME \"$GROUPNAME 1\" '.SecurityGroups | .[] | select(.GroupName==$GROUPNAME) | .GroupId' | cut -d \\\" -f2)\n\tSGID2=$(echo \"$FindGroups\" | jq -r --arg GROUPNAME \"$GROUPNAME 2\" '.SecurityGroups | .[] | select(.GroupName==$GROUPNAME) | .GroupId' | cut -d \\\" -f2)\n\t# SGID3=$(echo \"$FindGroups\" | jq -r --arg GROUPNAME \"$GROUPNAME 3\" '.SecurityGroups | .[] | select(.GroupName==$GROUPNAME) | .GroupId' | cut -d \\\" -f2)\n\n\t# if [[ -z $SGID1 ]] || [[ -z $SGID2 ]] || [[ -z $SGID3 ]]; then\n\tif [[ -z $SGID1 ]] || [[ -z $SGID2 ]]; then\n\t\techo \"Unable to lookup $GROUPNAME Security Group IDs.\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo DEBUG SGID1: \"$SGID1\"\n\t\techo DEBUG SGID2: \"$SGID2\"\n\t\t# echo DEBUG SGID3: \"$SGID3\"\n\tfi\n}\n\n# Remove the existing IPs and add new IPs\nfunction deleteIPs(){\n\tFindGroups=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=\"$VPCID\" --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$FindGroups\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"$FindGroups\" | jq .\n\tfi\n\n\t# Assuming there are exactly 2 groups\n\tSGID1=$(echo \"$FindGroups\" | jq -r --arg GROUPNAME \"$GROUPNAME 1\" '.SecurityGroups | .[] | select(.GroupName==$GROUPNAME) | .GroupId' | cut -d \\\" -f2)\n\tSGID2=$(echo \"$FindGroups\" | jq -r --arg GROUPNAME \"$GROUPNAME 2\" '.SecurityGroups | .[] | select(.GroupName==$GROUPNAME) | .GroupId' | cut -d \\\" -f2)\n\t# SGID3=$(echo \"$FindGroups\" | jq -r --arg GROUPNAME \"$GROUPNAME 3\" '.SecurityGroups | .[] | select(.GroupName==$GROUPNAME) | .GroupId' | cut -d \\\" -f2)\n\n\t# if [[ -z $SGID1 ]] || [[ -z $SGID2 ]] || [[ -z $SGID3 ]]; then\n\tif [[ -z $SGID1 ]] || [[ -z $SGID2 ]]; then\n\t\techo \"Unable to lookup $GROUPNAME Security Group IDs.\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo DEBUG SGID1: \"$SGID1\"\n\t\techo DEBUG SGID2: \"$SGID2\"\n\t\t# echo DEBUG SGID3: \"$SGID3\"\n\tfi\n\n\tGroup1IPs=$(aws ec2 describe-security-groups --output=json --group-id \"$SGID1\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$Group1IPs\"\n\tfi\n\tGroup2IPs=$(aws ec2 describe-security-groups --output=json --group-id \"$SGID2\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$Group2IPs\"\n\tfi\n\t# Group3IPs=$(aws ec2 describe-security-groups --output=json --group-id \"$SGID3\" --profile $profile 2>&1)\n\t# if [ ! $? -eq 0 ]; then\n\t# \tfail \"$Group3IPs\"\n\t# fi\n\n\t# if [[ -z $Group1IPs ]] || [[ -z $Group2IPs ]] || [[ -z $Group3IPs ]]; then\n\tif [[ -z $Group1IPs ]] || [[ -z $Group2IPs ]]; then\n\t\tfail \"Unable to parse $GROUPNAME Security Groups.\"\n\tfi\n\n\tGroup1IPs=$(echo \"$Group1IPs\" | jq '.SecurityGroups | .[] | .IpPermissions')\n\tGroup2IPs=$(echo \"$Group2IPs\" | jq '.SecurityGroups | .[] | .IpPermissions')\n\t# Group3IPs=$(echo \"$Group3IPs\" | jq '.SecurityGroups | .[] | .IpPermissions')\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo DEBUG Group1IPs: \"$Group1IPs\"\n\t\techo DEBUG Group2IPs: \"$Group2IPs\"\n\t\t# echo DEBUG Group3IPs: \"$Group3IPs\"\n\tfi\n\n\techo\n\tHorizontalRule\n\techo \"Removing IPs from $GROUPNAME 1, Security Group ID $SGID1\"\n\tRemoveGroup1IPs=$(aws ec2 revoke-security-group-ingress --output=json --group-id \"$SGID1\" --profile $profile --ip-permissions \"$Group1IPs\" 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$RemoveGroup1IPs\"\n\tfi\n\tHorizontalRule\n\n\techo\n\tHorizontalRule\n\techo \"Removing IPs from $GROUPNAME 2, Security Group ID $SGID2\"\n\tRemoveGroup2IPs=$(aws ec2 revoke-security-group-ingress --output=json --group-id \"$SGID2\" --profile $profile --ip-permissions \"$Group2IPs\" 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$RemoveGroup2IPs\"\n\tfi\n\tHorizontalRule\n\n\t# echo\n\t# HorizontalRule\n\t# echo \"Removing IPs from $GROUPNAME 3, Security Group ID $SGID3\"\n\t# RemoveGroup3IPs=$(aws ec2 revoke-security-group-ingress --output=json --group-id \"$SGID3\" --profile $profile --ip-permissions \"$Group3IPs\" 2>&1)\n\t# if [ ! $? -eq 0 ]; then\n\t# \tfail \"$RemoveGroup3IPs\"\n\t# fi\n\t# HorizontalRule\n\n\t# Set flag so there is no attempt to create the groups again\n\tGroupsAlreadyExist=\"1\"\n}\n\n# Run the script and call functions\n\n# Check for required applications\ncheck_command jq wget perl\n\nvalidateVPCID\n\necho\nHorizontalRule\necho \"This script will create or update AWS VPC Security Groups with rules\"\necho \"to allow access to each Pingdom probe IP in the port range specified.\"\nHorizontalRule\necho\ntput setaf 1; echo \"Please review all settings before continuing...\" && tput sgr0\necho\necho \"AWS CLI Profile Name: \"$profile\necho \"Group Name: \"$GROUPNAME\necho \"Group Description: \"$DESCRIPTION\necho \"VPC ID: \"$VPCID\necho \"Protocol: \"$PROTOCOL\nif [ \"$FROMPORT\" -eq \"$TOPORT\" ]; then\n\techo \"Port: \"$FROMPORT\nelse\n\techo \"Port Range: \"$FROMPORT-$TOPORT\nfi\necho\npause\necho\n\nvalidateGroupName\n\nprobeIPs\n\n# Determine number of security groups needed since default AWS limit is 60 rules per group\n# https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html#vpc-limits-security-groups\n\n# Create one group with 60 rules or less\nif [ \"$TOTALIPS\" -gt \"0\" ]; then\n\tif [ \"$TOTALIPS\" -lt \"61\" ]; then\n\t\tfail \"Support for 60 IPs or fewer has been depreciated.\"\n\tfi\nfi\n\n# Create multiple groups for 61-120 rules\nif [ \"$TOTALIPS\" -gt \"60\" ]; then\n\tif [ \"$TOTALIPS\" -lt \"121\" ]; then\n\t\tgroup120\n\tfi\nfi\n\n# Create multiple groups for 121-180 rules\nif [ \"$TOTALIPS\" -gt \"120\" ]; then\n\tif [ \"$TOTALIPS\" -lt \"181\" ]; then\n\t\tgroup180\n\tfi\nfi\n\n# More than 180 rules not yet supported\nif [ \"$TOTALIPS\" -gt \"180\" ]; then\n\tfail \"Greater than 180 IPs not yet supported.\"\nfi\n\n# Cleanup temp JSON files\nrm -f json json1 json2 json3 json4 json5 json6 json7\n"
        },
        {
          "name": "vpc-sg-import-rules.sh",
          "type": "blob",
          "size": 6.044921875,
          "content": "#!/usr/bin/env bash\n\n# This script will read from the list of IPs in the file iplist\n# Then create an AWS VPC Security Group with rules to allow access to each IP at the port specified\n# Due to AWS limits a group can only have 50 rules and will create multiple groups if greater than 50 rules\n# Requires the AWS CLI and jq\n\n# Set Variables\nGROUPNAME=\"YOUR GROUP NAME\"\nDESCR=\"YOUR GROUP DESCRIPTION\"\nVPCID=\"YOUR-VPC-ID-HERE\"\nPROTO=\"YOUR-PROTOCOL\"\nPORT=\"YOUR-PORT\"\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n# Functions\n\n# Check Command\nfunction check_command(){\n\tfor command in \"$@\"\n\tdo\n\t    type -P $command &>/dev/null || fail \"Unable to find $command, please install it and run this script again.\"\n\tdone\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Check required commands\ncheck_command aws jq\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Validate VPC ID\nfunction validateVPCID(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function validateVPCID\"\n\tfi\n\tif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ] || [ -z \"$VPCID\" ]; then\n\t\t# Count number of VPCs\n\t\tDESCRIBEVPCS=$(aws ec2 describe-vpcs --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tif echo $DESCRIBEVPCS | egrep -iq \"error|not\"; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tNUMVPCS=$(echo $DESCRIBEVPCS | jq '.Vpcs | length')\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\t\tif echo $NUMVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\n\t\t# If only one VPC, use that ID\n\t\tif [ \"$NUMVPCS\" -eq \"1\" ]; then\n\t\t\tVPCID=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VPCID\"\n\t\t\tfi\n\t\telse\n\t\t\tFOUNDVPCS=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\t\t\tif echo $FOUNDVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\n\t\t\tHorizontalRule\n\t\t\techo \"Found VPCs:\"\n\t\t\tHorizontalRule\n\t\t\t# Get VPC Names\n\t\t\tfor vpcid in $FOUNDVPCS; do\n\t\t\t\techo $vpcid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$vpcid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\t\t\tdone\n\t\t\techo\n\t\t\tread -r -p \"Please specify VPC ID (ex. vpc-abcd1234): \" VPCID\n\t\t\tif [ -z \"$VPCID\" ]; then\n\t\t\t\tfail \"Must specify a valid VPC ID.\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tCHECKVPC=$(aws ec2 describe-vpcs --vpc-ids \"$VPCID\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHECKVPC\"\n\tfi\n\tif ! echo \"$CHECKVPC\" | grep -q \"available\"; then\n\t\tfail $CHECKVPC\n\telse\n\t\ttput setaf 2; echo \"VPC ID Validated\" && tput sgr0\n\tfi\n}\n\nfunction createGroup(){\n\techo\n\tHorizontalRule\n\techo \"Creating Security Group \"$GROUPNAME\n\tcreategroup=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$DESCR\" --vpc-id $VPCID --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$creategroup\"\n\tfi\n\tSGID=$(echo \"$creategroup\" | jq '.GroupId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SGID\"\n\tfi\n\techo \"Security Group ID: $SGID\"\n\tTAG=$(aws ec2 create-tags --resources $SGID --tags Key=Name,Value=\"$GROUPNAME\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TAG\"\n\tfi\n\tHorizontalRule\n\techo\n}\n\nfunction addRule(){\n\taddrule=$(aws ec2 authorize-security-group-ingress --group-name \"$GROUPNAME\" --protocol $PROTO --port $PORT --cidr \"$iplist/32\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$addrule\"\n\tfi\n}\n\n# Create one group with 50 rules or less\nfunction addRules (){\n\tcreateGroup\n\techo\n\tHorizontalRule\n\techo \"Adding rules to VPC Security Group \"$GROUPNAME\n\techo \"Records to be created: \"$TOTALIPS\n\tHorizontalRule\n\techo\n\twhile read iplist\n\tdo\n\t\taddRule\n\tdone < iplist\n\tHorizontalRule\n\techo\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\techo\n}\n\n# Create multiple groups for more than 50 rules\nfunction addRules50 (){\n\t# Set Variables for Group #1\n\tGROUPNAME=\"YOUR GROUP NAME 1\"\n\tDESCR=\"YOUR GROUP NAME 1-50\"\n\tSTART=1\n\n\tcreateGroup\n\techo\n\tHorizontalRule\n\techo \"Adding rules to VPC Security Group \"$GROUPNAME\n\techo \"Records to be created: 50\" #$TOTALIPS\n\tHorizontalRule\n\techo\n\n\t# Begin loop to create rules 1-50\n\tfor (( COUNT=$START; COUNT<=50; COUNT++ ))\n\tdo\n\t\techo \"Rule \"\\#$COUNT\n\n\t\tiplist=$(nl iplist | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t\techo \"IP=\"$iplist\n\n\t\taddRule\n\tdone\n\n\t# Set Variables for Group #2\n\tGROUPNAME=\"YOUR GROUP NAME 2\"\n\tDESCR=\"YOUR GROUP NAME 51-$TOTALIPS\"\n\tSTART=51\n\n\tcreateGroup\n\techo\n\tHorizontalRule\n\techo \"Adding rules to VPC Security Group \"$GROUPNAME\n\techo \"Records to be created: \"$(expr $TOTALIPS - 50)\n\tHorizontalRule\n\techo\n\n\t# Begin loop to create rules 51-n\n\tfor (( COUNT=$START; COUNT<=$TOTALIPS; COUNT++ ))\n\tdo\n\t\techo \"Rule \"\\#$COUNT\n\n\t\tiplist=$(nl iplist | grep -w [^0-9][[:space:]]$COUNT | cut -f 2)\n\t\techo \"IP=\"$iplist\n\n\t\taddRule\n\tdone\n\tHorizontalRule\n\techo\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\techo\n}\n\nvalidateVPCID\n\nif [ -f \"iplist\" ]; then\n\tTOTALIPS=$(cat iplist | wc -l | tr -d ' ')\nelse\n\tfail \"Missing file: iplist\"\nfi\n\n# Create one group with 50 rules or less\nif [ \"$TOTALIPS\" -lt \"51\" ]; then\n\taddRules\n\tcompleted\nfi\n\n# Create multiple groups for more than 50 rules\nif [ \"$TOTALIPS\" -gt \"50\" ]; then\n\taddRules50\n\tcompleted\nfi\n\n# More than 100 rules\nif [ \"$TOTALIPS\" -gt \"100\" ]; then\n\tfail \"More than 100 IPs not yet supported.\"\nfi\n"
        },
        {
          "name": "vpc-sg-merge-groups.sh",
          "type": "blob",
          "size": 10.4453125,
          "content": "#!/usr/bin/env bash\n\n# This script will merge two existing VPC Security Groups together into one single group\n# Security Groups must exist in the same VPC, total rules must be 50 or less\n# Any duplicate rules in the two groups will cause an error\n# Note: this script is somewhat experimental and you should manually verify all results before applying the new group!!!\n# Requires the AWS CLI and jq\n\n# Set Variables\nVPCID=\"YOUR-VPC-ID-HERE\"\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n\n# Check Command\nfunction check_command(){\n\tfor command in \"$@\"\n\tdo\n\t    type -P $command &>/dev/null || fail \"Unable to find $command, please install it and run this script again.\"\n\tdone\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Validate VPC ID\nfunction validateVPCID(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function validateVPCID\"\n\tfi\n\tif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ] || [ -z \"$VPCID\" ]; then\n\t\t# Count number of VPCs\n\t\tDESCRIBEVPCS=$(aws ec2 describe-vpcs --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tif echo $DESCRIBEVPCS | egrep -iq \"error|not\"; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tNUMVPCS=$(echo $DESCRIBEVPCS | jq '.Vpcs | length')\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\t\tif echo $NUMVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\n\t\t# If only one VPC, use that ID\n\t\tif [ \"$NUMVPCS\" -eq \"1\" ]; then\n\t\t\tVPCID=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VPCID\"\n\t\t\tfi\n\t\telse\n\t\t\tFOUNDVPCS=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\t\t\tif echo $FOUNDVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\n\t\t\tHorizontalRule\n\t\t\techo \"Found VPCs:\"\n\t\t\tHorizontalRule\n\t\t\t# Get VPC Names\n\t\t\tfor vpcid in $FOUNDVPCS; do\n\t\t\t\techo $vpcid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$vpcid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\t\t\tdone\n\t\t\techo\n\t\t\tread -r -p \"Please specify VPC ID (ex. vpc-abcd1234): \" VPCID\n\t\t\tif [ -z \"$VPCID\" ]; then\n\t\t\t\tfail \"Must specify a valid VPC ID.\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tCHECKVPC=$(aws ec2 describe-vpcs --vpc-ids \"$VPCID\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHECKVPC\"\n\tfi\n\tif ! echo \"$CHECKVPC\" | grep -q \"available\"; then\n\t\tfail $CHECKVPC\n\telse\n\t\ttput setaf 2; echo \"VPC ID Validated\" && tput sgr0\n\tfi\n}\n\n# Describe Security Groups\nfunction describeSGS(){\n\tdescribeSGS=$(aws ec2 describe-security-groups --filters \"Name=vpc-id,Values=$VPCID\" --output=json --profile $profile 2>&1) # | jq '.SecurityGroups | .[] | .GroupName')\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeSGS\"\n\tfi\n\tsgIDs=$(echo \"$describeSGS\" | jq '.SecurityGroups | .[] | .GroupId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$sgIDs\"\n\tfi\n\n\tHorizontalRule\n\techo \"Found Security Groups:\"\n\tHorizontalRule\n\t# Get SG Names\n\tfor sgid in $sgIDs; do\n\t\techo $sgid - Group Name: $(aws ec2 describe-security-groups --group-ids $sgid --profile $profile 2>&1 | jq '.SecurityGroups | .[] | .GroupName' | cut -d \\\" -f2)\n\t\t# echo $sgid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$sgid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\tdone\n\techo\n}\n\n# Select Security Groups\nfunction selectSGS(){\n\tHorizontalRule\n\tread -r -p \"Please specify FIRST Security Group ID (ex. sg-abcd1234): \" SGID1\n\tif [ -z \"$SGID1\" ]; then\n\t\tfail \"Must specify a valid Security Group ID.\"\n\tfi\n\tdescribeSGID1=$(aws ec2 describe-security-groups --group-ids $SGID1 --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeSGID1\"\n\tfi\n\tSGNAME1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .GroupName' | cut -d \\\" -f2)\n\tSGDESC1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .Description' | cut -d \\\" -f2)\n\techo\n\tHorizontalRule\n\tread -r -p \"Please specify SECOND Security Group ID (ex. sg-abcd1234): \" SGID2\n\tif [ -z \"$SGID2\" ]; then\n\t\tfail \"Must specify a valid Security Group ID.\"\n\tfi\n\tdescribeSGID2=$(aws ec2 describe-security-groups --group-ids $SGID2 --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeSGID2\"\n\tfi\n\tSGNAME2=$(echo \"$describeSGID2\" | jq '.SecurityGroups | .[] | .GroupName' | cut -d \\\" -f2)\n\tSGDESC2=$(echo \"$describeSGID2\" | jq '.SecurityGroups | .[] | .Description' | cut -d \\\" -f2)\n\tSGNAME3=\"$SGNAME1 & $SGNAME2\"\n}\n\n# Create Security Group\nfunction createGroup(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function createGroup\"\n\t\techo var1: \"$1\"\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Creating Security Group: $1\"\n\tcreateGroup=$(aws ec2 create-security-group --group-name \"$1\" --description \"$1\" --vpc-id $VPCID --profile $profile 2>&1)\n\tif echo $createGroup | grep -q 'InvalidGroup.Duplicate'; then\n\t\ttput setaf 1; echo \"Error: The security group $1 already exists.\" && tput sgr0\n\t\tHorizontalRule\n\t\techo \"Attepting to create group with todays date appended to the name.\"\n\t\tDATE=$(date +%m-%d-%Y)\n\t\tGROUPNAME=\"$1-$DATE\"\n\t\techo \"Creating Security Group: $GROUPNAME\"\n\t\tcreateGroup=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$1\" --vpc-id $VPCID --profile $profile 2>&1)\n\tfi\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$createGroup\"\n\tfi\n\tif echo $createGroup | grep -q \"error\"; then\n\t\tfail \"$createGroup\"\n\tfi\n\tSGID=$(echo \"$createGroup\" | jq '.GroupId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SGID\"\n\tfi\n\tif echo $SGID | grep -q \"error\"; then\n\t\tfail \"$SGID\"\n\tfi\n\techo \"New Security Group ID:\" $SGID\n\tTAG=$(aws ec2 create-tags --resources $SGID --tags Key=Name,Value=\"$1\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TAG\"\n\tfi\n\tif echo $TAG | grep -q \"error\"; then\n\t\tfail \"$TAG\"\n\tfi\n\tHorizontalRule\n\techo\n}\n\n# Request ingress authorization to a security group from JSON file\nfunction AuthorizeSecurityGroupIngress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function AuthorizeSecurityGroupIngress\"\n\tfi\n\tHorizontalRule\n\techo \"Adding ingress rules to security groups...\"\n\tHorizontalRule\n\techo\n\tjson=$(cat \"$1\")\n\tAUTHORIZE=$(aws ec2 authorize-security-group-ingress --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n\tif echo $AUTHORIZE | grep -q error; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n}\n\n# Request egress authorization to a security group from JSON file\nfunction AuthorizeSecurityGroupEgress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function AuthorizeSecurityGroupEgress\"\n\tfi\n\tHorizontalRule\n\techo \"Adding egress rules to security groups...\"\n\tHorizontalRule\n\techo\n\tjson=$(cat \"$1\")\n\tAUTHORIZE=$(aws ec2 authorize-security-group-egress --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n\tif echo $AUTHORIZE | grep -q error; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n}\n\n# Builds the JSON for new security group\nfunction buildJSON(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function buildJSON\"\n\tfi\n\n\tSGINGRESS1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .IpPermissions')\n\tSGINGRESS2=$(echo \"$describeSGID2\" | jq '.SecurityGroups | .[] | .IpPermissions')\n\tSGEGRESS1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .IpPermissionsEgress')\n\tSGEGRESS2=$(echo \"$describeSGID2\" | jq '.SecurityGroups | .[] | .IpPermissionsEgress')\n\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGINGRESS1\n}\nEOP\n\t) > SGINGRESS1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGINGRESS1\n\tfi\n\t# rm -f SGINGRESS1\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGINGRESS2\n}\nEOP\n\t) > SGINGRESS2\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGINGRESS2\n\tfi\n\t# rm -f SGINGRESS2\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGEGRESS1\n}\nEOP\n\t) > SGEGRESS1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGEGRESS1\n\tfi\n\t# rm -f SGEGRESS1\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGEGRESS2\n}\nEOP\n\t) > SGEGRESS2\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGEGRESS2\n\tfi\n\t# rm -f SGEGRESS2\n\tif ! [ -f SGINGRESS1 ] || ! [ -f SGINGRESS2 ] || ! [ -f SGEGRESS1 ] || ! [ -f SGEGRESS2 ]; then\n\t\tfail \"Error building JSON.\"\n\tfi\n}\n\n\n# Run the script and call functions\n\n# Check for required applications\ncheck_command aws jq\n\nHorizontalRule\necho \"This script will merge two existing VPC Security Groups together into one single group.\"\nHorizontalRule\necho\n\nvalidateVPCID\n\ndescribeSGS\n\nselectSGS\n\necho\ntput setaf 1; echo \"Please review before continuing...\" && tput sgr0\necho\necho \"VPC ID:\" $VPCID\necho\necho \"First Security Group ID:\" $SGID1\necho \"First Group Name:\" $SGNAME1\necho \"First Group Description:\" $SGDESC1\necho\necho \"Second Security Group ID:\" $SGID2\necho \"Second Group Name:\" $SGNAME2\necho \"Second Group Description:\" $SGDESC2\necho\necho \"New Group Name:\" $SGNAME3\necho\npause\necho\n\ncreateGroup \"$SGNAME3\"\n\nbuildJSON\n\nAuthorizeSecurityGroupIngress SGINGRESS1\nAuthorizeSecurityGroupIngress SGINGRESS2\n\nSGEGRESSTEST1=$(cat SGEGRESS1 | jq '.IpPermissions' > SGEGRESSTEST1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$SGEGRESSTEST1\"\nfi\nSGEGRESSTEST2=$(aws ec2 describe-security-groups --group-ids \"$SGID\" --profile $profile 2>&1 | jq '.SecurityGroups | .[] | .IpPermissionsEgress' > SGEGRESSTEST2)\nif [ ! $? -eq 0 ]; then\n\tfail \"$SGEGRESSTEST2\"\nfi\nCOMPARE1=$(cmp --silent SGEGRESSTEST1 SGEGRESSTEST2 || AuthorizeSecurityGroupEgress SGEGRESS1)\nif [[ $DEBUGMODE = \"1\" ]]; then\n\techo \"$COMPARE1\"\nfi\n\nCOMPARE2=$(cmp --silent SGEGRESS1 SGEGRESS2 || AuthorizeSecurityGroupEgress SGEGRESS2)\nif [[ $DEBUGMODE = \"1\" ]]; then\n\techo \"$COMPARE2\"\nfi\n\nif ! [[ $DEBUGMODE = \"1\" ]]; then\n\trm -f SGINGRESS1 SGINGRESS2 SGEGRESS1 SGEGRESS2 SGEGRESSTEST1 SGEGRESSTEST2\nfi\n\ncompleted\n"
        },
        {
          "name": "vpc-sg-rename-group.sh",
          "type": "blob",
          "size": 10.6689453125,
          "content": "#!/usr/bin/env bash\n\n# This script will rename an existing VPC Security Group by creating an identical new group\n# Security Groups must exist in the same VPC and region\n# Note: this script is somewhat experimental and you should manually verify all results before applying the new group!!!\n# Requires the AWS CLI and jq\n\n# Set Variables\nVPCID=\"YOUR-VPC-ID-HERE\"\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n\n# Check Command\nfunction check_command(){\n\tfor command in \"$@\"\n\tdo\n\t    type -P $command &>/dev/null || fail \"Unable to find $command, please install it and run this script again.\"\n\tdone\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Error: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n# Pause\nfunction pause(){\n\tread -n 1 -s -p \"Press any key to continue...\"\n\techo\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\tif ! grep -q aws_access_key_id ~/.aws/config; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Validate VPC ID\nfunction validateVPCID(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function validateVPCID\"\n\tfi\n\tif [ \"$VPCID\" = \"YOUR-VPC-ID-HERE\" ] || [ -z \"$VPCID\" ]; then\n\t\t# Count number of VPCs\n\t\tDESCRIBEVPCS=$(aws ec2 describe-vpcs --profile $profile 2>&1)\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tif echo $DESCRIBEVPCS | egrep -iq \"error|not\"; then\n\t\t\tfail \"$DESCRIBEVPCS\"\n\t\tfi\n\t\tNUMVPCS=$(echo $DESCRIBEVPCS | jq '.Vpcs | length')\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\t\tif echo $NUMVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\tfail \"$NUMVPCS\"\n\t\tfi\n\n\t\t# If only one VPC, use that ID\n\t\tif [ \"$NUMVPCS\" -eq \"1\" ]; then\n\t\t\tVPCID=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$VPCID\"\n\t\t\tfi\n\t\telse\n\t\t\tFOUNDVPCS=$(echo \"$DESCRIBEVPCS\" | jq '.Vpcs | .[] | .VpcId' | cut -d \\\" -f2)\n\t\t\tif [ ! $? -eq 0 ]; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\t\t\tif echo $FOUNDVPCS | egrep -iq \"error|not|invalid\"; then\n\t\t\t\tfail \"$FOUNDVPCS\"\n\t\t\tfi\n\n\t\t\tHorizontalRule\n\t\t\techo \"Found VPCs:\"\n\t\t\tHorizontalRule\n\t\t\t# Get VPC Names\n\t\t\tfor vpcid in $FOUNDVPCS; do\n\t\t\t\techo $vpcid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$vpcid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\t\t\tdone\n\t\t\techo\n\t\t\tread -r -p \"Please specify VPC ID (ex. vpc-abcd1234): \" VPCID\n\t\t\tif [ -z \"$VPCID\" ]; then\n\t\t\t\tfail \"Must specify a valid VPC ID.\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tCHECKVPC=$(aws ec2 describe-vpcs --vpc-ids \"$VPCID\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHECKVPC\"\n\tfi\n\tif ! echo \"$CHECKVPC\" | grep -q \"available\"; then\n\t\tfail $CHECKVPC\n\telse\n\t\ttput setaf 2; echo \"VPC ID Validated\" && tput sgr0\n\tfi\n}\n\n# Describe Security Groups\nfunction describeSGS(){\n\tdescribeSGS=$(aws ec2 describe-security-groups --filters \"Name=vpc-id,Values=$VPCID\" --output=json --profile $profile 2>&1) # | jq '.SecurityGroups | .[] | .GroupName')\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeSGS\"\n\tfi\n\tsgIDs=$(echo \"$describeSGS\" | jq '.SecurityGroups | .[] | .GroupId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$sgIDs\"\n\tfi\n\n\tHorizontalRule\n\techo \"Found Security Groups:\"\n\tHorizontalRule\n\t# Get SG Names\n\tfor sgid in $sgIDs; do\n\t\techo $sgid - Group Name: $(aws ec2 describe-security-groups --group-ids $sgid --profile $profile 2>&1 | jq '.SecurityGroups | .[] | .GroupName' | cut -d \\\" -f2)\n\t\t# echo $sgid - Name: $(aws ec2 describe-tags --filters \"Name=resource-id,Values=$sgid\" \"Name=key,Values=Name\" --profile $profile 2>&1 | jq '.Tags | .[] | .Value' | cut -d \\\" -f2)\n\tdone\n\techo\n}\n\n# Select Security Groups\nfunction selectSGS(){\n\tHorizontalRule\n\tread -r -p \"Please specify the Security Group ID that you wish to rename (ex. sg-abcd1234): \" SGID1\n\tif [ -z \"$SGID1\" ]; then\n\t\tfail \"Must specify a valid Security Group ID.\"\n\tfi\n\tdescribeSGID1=$(aws ec2 describe-security-groups --group-ids $SGID1 --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeSGID1\"\n\tfi\n\tSGNAME1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .GroupName' | cut -d \\\" -f2)\n\tSGDESC1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .Description' | cut -d \\\" -f2)\n\techo\n\tHorizontalRule\n\tread -r -p \"Please specify the new name for this group: \" SGNAME2\n\tif [ -z \"$SGNAME2\" ]; then\n\t\tfail \"Must specify a valid Security Group name.\"\n\tfi\n}\n\n# Create Security Group\nfunction createGroup(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function createGroup\"\n\t\techo var1: \"$1\"\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Creating Security Group: $1\"\n\tcreateGroup=$(aws ec2 create-security-group --group-name \"$1\" --description \"$2\" --vpc-id $VPCID --profile $profile 2>&1)\n\tif echo $createGroup | grep -q 'InvalidGroup.Duplicate'; then\n\t\ttput setaf 1; echo \"Error: The security group $1 already exists.\" && tput sgr0\n\t\tHorizontalRule\n\t\techo \"Attepting to create group with todays date appended to the name.\"\n\t\tDATE=$(date +%m-%d-%Y)\n\t\tGROUPNAME=\"$1-$DATE\"\n\t\techo \"Creating Security Group: $GROUPNAME\"\n\t\tcreateGroup=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$2\" --vpc-id $VPCID --profile $profile 2>&1)\n\tfi\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$createGroup\"\n\tfi\n\tif echo $createGroup | grep -q \"error\"; then\n\t\tfail \"$createGroup\"\n\tfi\n\tSGID=$(echo \"$createGroup\" | jq '.GroupId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$SGID\"\n\tfi\n\tif echo $SGID | grep -q \"error\"; then\n\t\tfail \"$SGID\"\n\tfi\n\techo \"New Security Group ID:\" $SGID\n\tTAG=$(aws ec2 create-tags --resources $SGID --tags Key=Name,Value=\"$1\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TAG\"\n\tfi\n\tif echo $TAG | grep -q \"error\"; then\n\t\tfail \"$TAG\"\n\tfi\n\tHorizontalRule\n\techo\n\tdescribeNewSG=$(aws ec2 describe-security-groups --group-ids $SGID --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$describeNewSG\"\n\tfi\n\tbuildJSONRevokeEgress\n\tRevokeSecurityGroupEgress SGEGRESS0\n}\n\n# Request ingress authorization to a security group from JSON file\nfunction AuthorizeSecurityGroupIngress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function AuthorizeSecurityGroupIngress\"\n\tfi\n\tHorizontalRule\n\techo \"Authorizing ingress rules to security group...\"\n\tHorizontalRule\n\techo\n\tjson=$(cat \"$1\")\n\tAUTHORIZE=$(aws ec2 authorize-security-group-ingress --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n\tif echo $AUTHORIZE | egrep -iq error; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n}\n\n# Revoke egress authorization to a security group from JSON file\nfunction RevokeSecurityGroupEgress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function RevokeSecurityGroupEgress\"\n\tfi\n\tHorizontalRule\n\techo \"Revoking all default egress rules to new security group...\"\n\tHorizontalRule\n\techo\n\tjson=$(cat \"$1\")\n\tREVOKE=$(aws ec2 revoke-security-group-egress --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$REVOKE\"\n\tfi\n\tif echo $REVOKE | egrep -iq error; then\n\t\tfail \"$REVOKE\"\n\tfi\n}\n\n# Request egress authorization to a security group from JSON file\nfunction AuthorizeSecurityGroupEgress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function AuthorizeSecurityGroupEgress\"\n\tfi\n\tHorizontalRule\n\techo \"Authorizing egress rules to security group...\"\n\tHorizontalRule\n\techo\n\tjson=$(cat \"$1\")\n\tAUTHORIZE=$(aws ec2 authorize-security-group-egress --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n\tif echo $AUTHORIZE | egrep -iq error; then\n\t\tfail \"$AUTHORIZE\"\n\tfi\n}\n\n# Builds the JSON for new security group\nfunction buildJSON(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function buildJSON\"\n\tfi\n\n\tSGINGRESS1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .IpPermissions')\n\tSGEGRESS1=$(echo \"$describeSGID1\" | jq '.SecurityGroups | .[] | .IpPermissionsEgress')\n\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGINGRESS1\n}\nEOP\n\t) > SGINGRESS1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGINGRESS1\n\tfi\n\t# rm -f SGINGRESS1\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGEGRESS1\n}\nEOP\n\t) > SGEGRESS1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGEGRESS1\n\tfi\n\t# rm -f SGEGRESS1\n\tif ! [ -f SGINGRESS1 ] || ! [ -f SGEGRESS1 ]; then\n\t\tfail \"Error building JSON.\"\n\tfi\n}\n\n# Builds the JSON to clear Egress for new security group\nfunction buildJSONRevokeEgress(){\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"function buildJSONRevokeEgress\"\n\tfi\n\n\tSGEGRESS0=$(echo \"$describeNewSG\" | jq '.SecurityGroups | .[] | .IpPermissionsEgress')\n\n\t(\n\tcat << EOP\n{\n    \"GroupId\": \"$SGID\",\n    \"IpPermissions\":\n        $SGEGRESS0\n}\nEOP\n\t) > SGEGRESS0\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built SGEGRESS0\n\tfi\n\t# rm -f SGEGRESS0\n\tif ! [ -f SGEGRESS0 ]; then\n\t\tfail \"Error building JSON.\"\n\tfi\n}\n\n\n# Run the script and call functions\n\n# Check for required applications\ncheck_command aws jq\n\nHorizontalRule\necho \"This script will rename an existing VPC Security Group by creating an identical new group.\"\nHorizontalRule\necho\n\nvalidateVPCID\n\ndescribeSGS\n\nselectSGS\n\necho\ntput setaf 1; echo \"Please review before continuing...\" && tput sgr0\necho\necho \"VPC ID:\" $VPCID\necho\necho \"Security Group ID:\" $SGID1\necho \"Group Name:\" $SGNAME1\necho \"Group Description:\" $SGDESC1\necho\necho \"New Group Name:\" $SGNAME2\necho\npause\necho\n\ncreateGroup \"$SGNAME2\" \"$SGDESC1\"\n\nbuildJSON\n\nAuthorizeSecurityGroupIngress SGINGRESS1\n\nSGEGRESSTEST1=$(cat SGEGRESS1 | jq '.IpPermissions' > SGEGRESSTEST1)\nif [ ! $? -eq 0 ]; then\n\tfail \"$SGEGRESSTEST1\"\nfi\nif [[ $DEBUGMODE = \"1\" ]]; then\n\techo SGEGRESSTEST1:\n\tcat SGEGRESSTEST1\nfi\nSGEGRESSTEST2=$(aws ec2 describe-security-groups --group-ids \"$SGID\" --profile $profile 2>&1 | jq '.SecurityGroups | .[] | .IpPermissionsEgress' > SGEGRESSTEST2)\nif [ ! $? -eq 0 ]; then\n\tfail \"$SGEGRESSTEST2\"\nfi\nif [[ $DEBUGMODE = \"1\" ]]; then\n\techo SGEGRESSTEST2:\n\tcat SGEGRESSTEST2\nfi\n# COMPARE1=$(cmp --silent SGEGRESSTEST1 SGEGRESSTEST2 || AuthorizeSecurityGroupEgress SGEGRESS1)\nCOMPARE1=$(cmp --silent SGEGRESSTEST1 SGEGRESSTEST2)\nif [ ! $? -eq 0 ]; then\n\tAuthorizeSecurityGroupEgress SGEGRESS1\nfi\nif [[ $DEBUGMODE = \"1\" ]]; then\n\techo COMPARE1:\n\tcmp SGEGRESSTEST1 SGEGRESSTEST2\n\techo \"$COMPARE1\"\nfi\n\nif ! [[ $DEBUGMODE = \"1\" ]]; then\n\trm -f SGEGRESS0 SGINGRESS1 SGEGRESS1 SGEGRESSTEST1 SGEGRESSTEST2\nfi\n\ncompleted\n"
        },
        {
          "name": "waf-export-ip-sets.sh",
          "type": "blob",
          "size": 3.361328125,
          "content": "#!/usr/bin/env bash\n\n# This script will export each AWS WAF IP set match condition to a JSON file for backup\n# Requires the AWS CLI and jq\n\n\n# Set Variables\nSUBFOLDER=waf-export-ip-sets-$(date +%Y-%m-%d)\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\n\tSUBFOLDER=$SUBFOLDER-$1\nfi\n\n# Get list of all IP Sets\nfunction ListIPSets(){\n\tListIPSets=$(aws waf list-ip-sets --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ListIPSets\"\n\tfi\n\tParseIPSets=$(echo \"$ListIPSets\" | jq '.IPSets | .[]')\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ParseIPSets\"\n\tfi\n\tif [ -z \"$ParseIPSets\" ]; then\n\t\tfail \"No WAF IP Sets Found!\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"ParseIPSets: \"$ParseIPSets\n\tfi\n\tIPSETNAMES=$(echo \"$ParseIPSets\" | jq '.Name' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$IPSETNAMES\"\n\tfi\n\tIPSETIDS=$(echo \"$ParseIPSets\" | jq '.IPSetId' | cut -d \\\" -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$IPSETIDS\"\n\tfi\n\tTOTALIPSETS=$(echo \"$IPSETIDS\" | wc -l | rev | cut -d \" \" -f1 | rev)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$TOTALIPSETS\"\n\tfi\n\n\tHorizontalRule\n\techo \"IP Sets Found:\" $TOTALIPSETS\n\tHorizontalRule\n\techo\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"IPSETNAMES: $IPSETNAMES\"\n\t\techo \"IPSETIDS: $IPSETIDS\"\n\tfi\n}\n\n# Get a single IP Set\nfunction GetIPSet(){\n\tGetIPSet=$(aws waf get-ip-set --ip-set-id \"$IPSETID\" --output=json --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$GetIPSet\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"GetIPSet: $GetIPSet\"\n\tfi\n}\n\n# Exports a single IP Set to a JSON file\nfunction ExportExistingIPSet(){\n\tListIPSets\n\n\t# Make the subfolder directory\n\tif ! [ -d \"$SUBFOLDER\" ]; then\n\t\techo\n\t\techo \"Making Subfolder: $SUBFOLDER\"\n\t\techo\n\t\tMKDIR=$(mkdir \"$SUBFOLDER\")\n\t\tif [ ! $? -eq 0 ]; then\n\t\t\tfail \"$MKDIR\"\n\t\tfi\n\tfi\n\n\tSTART=1\n\tfor (( COUNT=$START; COUNT<=$TOTALIPSETS; COUNT++ ))\n\tdo\n\t\tIPSETID=$(echo \"$IPSETIDS\" | nl | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n\t\tIPSETNAME=$(echo \"$IPSETNAMES\" | nl | grep -w [^0-9][[:space:]]$COUNT | cut -f2)\n\t\techo \"Exporting IP Set: $IPSETNAME\"\n\t\tGetIPSet\n\t\tOUTPUTFILENAME=\"$SUBFOLDER\"/\"$IPSETID\".json\n\t\techo \"$GetIPSet\" > \"$OUTPUTFILENAME\"\n\tdone\n\tcompleted\n\techo \"JSON exports generated under subfolder: $SUBFOLDER\"\n}\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\nExportExistingIPSet\n"
        },
        {
          "name": "waf-import-ip-set-facebook.sh",
          "type": "blob",
          "size": 8.8681640625,
          "content": "#!/usr/bin/env bash\n\n### NOTE: This process currently will not work because Facebook uses CIDR blocks outside of the range acceptable to AWS WAF.\n### AWS WAF supports /8, /16, /24, and /32 IP address ranges for IPv4, and /24, /32, /48, /56, /64 and /128 for IPv6.\n### See: https://developers.facebook.com/docs/sharing/webmasters/crawler#access\n### And: https://docs.aws.amazon.com/waf/latest/APIReference/API_IPSet.html\n\n# This script will save a list of current Facebook crawler server IPs in the file iplist\n# Then create an AWS WAF IP Set with rules to allow access to each IP\n# Requires the AWS CLI and jq\n\n\n# Set Variables\nCONDITIONNAME=\"Facebook\"\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n# Check for command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\nfunction HorizontalRule(){\n\techo \"=====================================================\"\n}\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Get Facebook IPv4 IPs\nfunction GetIPs(){\n\twhois -h whois.radb.net -- '-i origin AS32934' | grep ^route: | rev | cut -d ' ' -f1 | rev | \\\n\tsort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 > iplist\n\n\tTOTALIPS=$(cat iplist | wc -l | tr -d ' ')\n\t# TOTALIPS=$(cat iplist | wc -l | cut -d \" \" -f7)\n\n\techo \"Total Facebook IPs: \"$TOTALIPS\n}\n\n# Gets a Change Token\nfunction ChangeToken(){\n\tCHANGETOKEN=$(aws waf get-change-token | jq '.ChangeToken' | cut -d '\"' -f2)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"CHANGETOKEN: \"$CHANGETOKEN\n\tfi\n}\n\n# Inserts a single IP into the IP Set from the var iplist and reports status using the changetoken\nfunction InsertIPSet(){\n\tChangeToken\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"IPSETID: \"$IPSETID\n\t\techo \"IP: \"$iplist\n\tfi\n\tUPDATESET=$(aws waf update-ip-set --ip-set-id $IPSETID --change-token $CHANGETOKEN --updates 'Action=INSERT,IPSetDescriptor={Type=IPV4,Value=\"'\"$iplist\"'\"}' 2>&1) # | jq .)\n\n\tif echo $UPDATESET | grep -q error; then\n\t\tfail \"$UPDATESET\"\n\telse\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"UPDATESET: \"$UPDATESET\n\t\tfi\n\t\techo $CHANGETOKEN >> changetokenlist\n\t\tCHANGETOKENSTATUS=$(aws waf get-change-token-status --change-token $CHANGETOKEN | jq '.ChangeTokenStatus' | cut -d '\"' -f2)\n\t\techo $CHANGETOKENSTATUS: $iplist\n\tfi\n\t# echo \"$UPDATESET\"\n}\n\n# Deletes a single IP from the IP Set using the var iplist and reports status using the changetoken\nfunction DeleteIPSet(){\n\tChangeToken\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"IPSETID: \"$IPSETID\n\t\techo \"IP: \"$iplist\n\tfi\n\tUPDATESET=$(aws waf update-ip-set --ip-set-id $IPSETID --change-token $CHANGETOKEN --updates 'Action=DELETE,IPSetDescriptor={Type=IPV4,Value=\"'\"$iplist\"'\"}' 2>&1) # | jq .)\n\tif echo $UPDATESET | grep -q error; then\n\t\tfail \"$UPDATESET\"\n\telse\n\t\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\t\techo \"UPDATESET: \"$UPDATESET\n\t\tfi\n\t\techo $CHANGETOKEN >> changetokenlist\n\t\tCHANGETOKENSTATUS=$(aws waf get-change-token-status --change-token $CHANGETOKEN | jq '.ChangeTokenStatus' | cut -d '\"' -f2)\n\t\techo $CHANGETOKENSTATUS: $iplist\n\tfi\n\t# echo \"$UPDATESET\"\n}\n\n# Checks the status of a single changetoken in the changetokenlist\nfunction CheckStatus(){\n\techo\n\tHorizontalRule\n\techo \"Checking Status:\"\n\twhile read CHANGETOKEN\n\tdo\n\t\tCHANGETOKENSTATUS=$(aws waf get-change-token-status --change-token $CHANGETOKEN | jq '.ChangeTokenStatus' | cut -d '\"' -f2)\n\t\techo $CHANGETOKENSTATUS\n\tdone < changetokenlist\n\tHorizontalRule\n\techo\n}\n\n# Exports a list of IPs in existing IP Set to the file iplist\nfunction ExportExistingIPSet(){\n\tIPSETID=$(aws waf list-ip-sets --limit 99 --output=json 2>&1 | jq '.IPSets | .[] | select(.Name==\"'\"$CONDITIONNAME\"'\") | .IPSetId' | cut -d '\"' -f2)\n\tGetIPSet=$(aws waf get-ip-set --ip-set-id \"$IPSETID\" 2>&1 | jq '.IPSet | .IPSetDescriptors | .[] | .Value' | cut -d '\"' -f2)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"IPSETID: \"$IPSETID\n\t\techo \"GetIPSet: \"$GetIPSet\n\tfi\n\tif [ -z \"$GetIPSet\" ]; then\n\t\techo \"No IPs in Set!\"\n\tfi\n\t# Delete any existing file iplist-existing\n\tif [ -f iplist-existing ]; then\n\t\trm iplist-existing\n\tfi\n\techo \"$GetIPSet\" >> iplist-existing\n\tCountIPSetIPs=$(echo \"$GetIPSet\" | wc -l)\n\t# echo IPs in set $CONDITIONNAME: $CountIPSetIPs\n}\n\n\n\nfunction WAF(){\n\n\t# Delete any existing changetokenlist\n\tif [ -f changetokenlist ]; then\n\t\trm changetokenlist\n\tfi\n\n\t# Check for existing IP Set with the same name and create the set if none exists\n\tif ! aws waf list-ip-sets --limit 99 --output=json | jq '.IPSets | .[] | .Name' | grep -q \"$CONDITIONNAME\"; then\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Creating IP Set: \"$CONDITIONNAME\n\t\tChangeToken\n\t\tIPSETID=$(aws waf create-ip-set --name \"$CONDITIONNAME\" --change-token $CHANGETOKEN 2>&1 | jq '.IPSet | .IPSetId' | cut -d '\"' -f2)\n\t\techo \"IP Set ID:\" \"$IPSETID\"\n\t\tHorizontalRule\n\t\techo\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Adding IPs to IP Set: \"$CONDITIONNAME\n\t\techo \"IPs to be added: \"$TOTALIPS\n\t\tHorizontalRule\n\t\techo\n\t\twhile read iplist\n\t\tdo\n\t\t\tInsertIPSet\n\t\tdone < iplist\n\t\tcompleted\n\telse\n\t\ttput setaf 1\n\t\techo\n\t\tHorizontalRule\n\t\techo \"IP Set: $CONDITIONNAME Already Exists\"\n\t\tIPSETID=$(aws waf list-ip-sets --limit 99 --output=json 2>&1 | jq '.IPSets | .[] | select(.Name==\"'\"$CONDITIONNAME\"'\") | .IPSetId' | cut -d '\"' -f2)\n\t\techo IPSetID: \"$IPSETID\"\n\t\tHorizontalRule\n\t\ttput sgr0\n\t\techo\n\t\tread -r -p \"Do you want to delete the set and recreate it? (y/n) \" DELETESET\n\t\tif [[ $DELETESET =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\tExportExistingIPSet\n\t\t\techo\n\t\t\tif ! [ -z \"$GetIPSet\" ]; then\n\t\t\t\tHorizontalRule\n\t\t\t\techo \"Deleting IPs from IP Set: \"$CONDITIONNAME\n\t\t\t\techo \"IPs to be deleted: \"$CountIPSetIPs\n\t\t\t\tHorizontalRule\n\t\t\t\techo\n\t\t\t\twhile read iplist\n\t\t\t\tdo\n\t\t\t\t\tDeleteIPSet\n\t\t\t\tdone < iplist-existing\n\t\t\t\t# Verifying list is empty\n\t\t\t\tExportExistingIPSet\n\t\t\t\tif [ \"$CountIPSetIPs\" -eq \"1\" ]; then \n\t\t\t\t\tcompleted\n\t\t\t\telse\n\t\t\t\t\tfail \"Error deleting IPs from IP Set.\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\techo\n\t\t\tHorizontalRule\n\t\t\techo \"Adding IPs to IP Set: \"$CONDITIONNAME\n\t\t\techo \"IPs to be added: \"$TOTALIPS\n\t\t\tHorizontalRule\n\t\t\techo\n\t\t\twhile read iplist\n\t\t\tdo\n\t\t\t\tInsertIPSet\n\t\t\tdone < iplist\n\t\t\t# Verifying all IPs added\n\t\t\tExportExistingIPSet\n\t\t\tif [ \"$CountIPSetIPs\" -eq \"$TOTALIPS\" ]; then \n\t\t\t\tcompleted\n\t\t\telse\n\t\t\t\tfail \"Error adding IPs to IP Set.\"\n\t\t\tfi\n\t\telse\n\t\t\tread -r -p \"Do you want to update the set with new IPs? (y/n) \" UPDATESET\n\t\t\tif [[ $UPDATESET =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\t\techo\n\t\t\t\tHorizontalRule\n\t\t\t\techo \"Adding IPs to IP Set: \"$CONDITIONNAME\n\t\t\t\techo \"IPs to be added: \"$TOTALIPS\n\t\t\t\tHorizontalRule\n\t\t\t\techo\n\t\t\t\twhile read iplist\n\t\t\t\tdo\n\t\t\t\t\tInsertIPSet\n\t\t\t\tdone < iplist\n\t\t\t\tcompleted\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\t\t# You can't delete an IPSet if it's still used in any Rules or if it still includes any IP addresses.\n\t\t# You can't delete a Rule if it's still used in any WebACL objects.\n\n\t\t\t# RULENAME=$(aws waf list-rules --limit 99 --output=json 2>&1 | jq '.Rules | .[] | .Name' | grep \"$CONDITIONNAME\" | cut -d '\"' -f2)\n\t\t\t# RULEID=$(aws waf list-rules --limit 99 --output=json 2>&1 | jq '.Rules | .[] | select(.Name==\"'\"$RULENAME\"'\") | .RuleId' | cut -d '\"' -f2)\n\t\t\t# echo\n\t\t\t# echo \"=====================================================\"\n\t\t\t# echo \"Deleting Rule Name $RULENAME, Rule ID $RULEID\"\n\t\t\t# echo \"=====================================================\"\n\t\t\t# DELETERULE=$(aws waf delete-rule --rule-id \"$RULEID\" 2>&1)\n\t\t\t# if echo $DELETERULE | grep -q error; then\n\t\t\t# \tfail \"$DELETERULE\"\n\t\t\t# else\n\t\t\t# \techo \"$DELETERULE\"\n\t\t\t# fi\n\n\t\t\t# echo\n\t\t\t# echo \"=====================================================\"\n\t\t\t# echo \"Deleting Set $CONDITIONNAME, Set ID $IPSETID\"\n\t\t\t# echo \"=====================================================\"\n\t\t\t# DELETESET=$(aws waf delete-ip-set --ip-set-id \"$IPSETID\" 2>&1)\n\t\t\t# if echo $DELETESET | grep -q error; then\n\t\t\t# \tfail \"$DELETESET\"\n\t\t\t# else\n\t\t\t# \techo \"$DELETESET\"\n\t\t\t# \t# echo\n\t\t\t# \t# echo \"=====================================================\"\n\t\t\t# \t# echo \"Creating Security Group \"$GROUPNAME\n\t\t\t# \t# GROUPID=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$DESCRIPTION\" --vpc-id $VPCID 2>&1)\n\t\t\t# \t# echo $GROUPID\n\t\t\t# \t# aws ec2 create-tags --resources $(aws ec2 describe-security-groups --output=json | jq '.SecurityGroups | .[] | select(.GroupName==\"$GROUPNAME\") | .GroupId' | cut -d '\"' -f2) --tags Key=Name,Value=\"$GROUPNAME\"\n\t\t\t# \t# echo \"=====================================================\"\n\t\t\t# fi\n\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\n\n# Ensure Variables are set\nif [ \"$CONDITIONNAME\" = \"YOUR-CONDITION-NAME-HERE\" ]; then\n\tfail \"Must set variables!\"\n\texit 1\nfi\n\nGetIPs\n\n# TOTALIPS=$(wc -l iplist | cut -d \" \" -f7)\n\nWAF\n\n# CheckStatus\n"
        },
        {
          "name": "waf-web-acl-pingdom.sh",
          "type": "blob",
          "size": 15.16015625,
          "content": "#!/usr/bin/env bash\n\n# This script will Manage WAF Web ACL to allow current Pingdom probe server IPs\n# Allows creating or updating AWS WAF IP Addresses Set, Rules and Web ACLs\n# Saves a list of current Pingdom probe server IPs in the file iplist\n# Creates a WAF IP Address Set with all Pingdom IPs\n# Creates a WAF Rule with the IP Address Set\n# Creates a WAF Web ACL with the WAF Rule to allow Pingdom access\n# Requires the AWS CLI and jq, wget, perl\n\n\n# Set Variables\nCONDITIONNAME=\"Pingdom\"\nDATE=$(date \"+%Y-%m-%d\")\nCONDITIONNAME=$CONDITIONNAME-$DATE\n\n# Debug Mode\nDEBUGMODE=\"0\"\n\n\n# Functions\n\n\n# Check Command\nfunction check_command {\n\ttype -P $1 &>/dev/null || fail \"Unable to find $1, please install it and run this script again.\"\n}\n\n# Completed\nfunction completed(){\n\techo\n\tHorizontalRule\n\ttput setaf 2; echo \"Completed!\" && tput sgr0\n\tHorizontalRule\n\techo\n}\n\n# Fail\nfunction fail(){\n\ttput setaf 1; echo \"Failure: $*\" && tput sgr0\n\texit 1\n}\n\n# Horizontal Rule\nfunction HorizontalRule(){\n\techo \"============================================================\"\n}\n\n\n# Verify AWS CLI Credentials are setup\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html\nif ! grep -q aws_access_key_id ~/.aws/config; then\n\tif ! grep -q aws_access_key_id ~/.aws/credentials; then\n\t\tfail \"AWS config not found or CLI not installed. Please run \\\"aws configure\\\".\"\n\tfi\nfi\n\n# Check for AWS CLI profile argument passed into the script\n# http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-multiple-profiles\nif [ $# -eq 0 ]; then\n\tscriptname=`basename \"$0\"`\n\techo \"Usage: ./$scriptname profile\"\n\techo \"Where profile is the AWS CLI profile name\"\n\techo \"Using default profile\"\n\techo\n\tprofile=default\nelse\n\tprofile=$1\nfi\n\n# Get Pingdom IPv4 IPs\nfunction GetProbeIPs(){\n\twget --quiet -O- https://www.pingdom.com/rss/probe_servers.xml | \\\n\tperl -nle 'print $1 if /IP: (([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5]));/' | \\\n\tsort -n -t . -k 1,1 -k 2,2 -k 3,3 -k 4,4 > iplist\n\n\tTOTALIPS=$(cat iplist | wc -l | tr -d ' ')\n\n\tif ! [ \"$TOTALIPS\" -gt \"0\" ]; then\n\t\tfail \"Error getting Pingdom IPs.\"\n\tfi\n\n\techo\n\ttput setaf 2\n\tHorizontalRule\n\techo \"Total Pingdom IPs: \"$TOTALIPS\n\tHorizontalRule\n\ttput sgr0\n\techo\n}\n\n# Gets a Change Token\nfunction ChangeToken(){\n\tCHANGETOKEN=$(aws waf get-change-token --profile $profile 2>&1 | jq '.ChangeToken' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHANGETOKEN\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"CHANGETOKEN: \"$CHANGETOKEN\n\tfi\n}\n\n# Checks the status of a single changetoken\nfunction ChangeTokenStatus(){\n\tCHANGETOKENSTATUS=$(aws waf get-change-token-status --change-token $CHANGETOKEN --profile $profile 2>&1 | jq '.ChangeTokenStatus' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CHANGETOKENSTATUS\"\n\tfi\n}\n\n# Checks the status of all changetokens in the changetokenlist\nfunction CheckStatus(){\n\techo\n\tHorizontalRule\n\techo \"Checking Status:\"\n\twhile read CHANGETOKEN\n\tdo\n\t\tChangeTokenStatus\n\t\techo $CHANGETOKENSTATUS\n\tdone < changetokenlist\n\tHorizontalRule\n\techo\n}\n\n# Builds the JSON for a single large insert to update IP set\nfunction BuildUpdateSetInsertJSON(){\n\tChangeToken\n(\ncat << EOP\n{\n    \"IPSetId\": \"$IPSETID\",\n    \"ChangeToken\": \"$CHANGETOKEN\",\n    \"Updates\": [\nEOP\n) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\tif [ -f json2 ]; then\n\t\trm json2\n\tfi\n\n\twhile read iplist\n\tdo\n(\ncat << EOP\n        {\n            \"Action\": \"INSERT\",\n            \"IPSetDescriptor\": {\n                \"Type\": \"IPV4\",\n                \"Value\": \"$iplist/32\"\n            }\n        },\nEOP\n) >> json2\n\tdone < iplist\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n(\ncat << 'EOP'\n    ]\n}\nEOP\n) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json5\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json5\n\tfi\n\n\trm json1 json2 json3 json4\n}\n\n# Builds the JSON for a single large delete to update IP set\nfunction BuildUpdateSetDeleteJSON(){\n\tChangeToken\n(\ncat << EOP\n{\n    \"IPSetId\": \"$IPSETID\",\n    \"ChangeToken\": \"$CHANGETOKEN\",\n    \"Updates\": [\nEOP\n) > json1\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json1\n\tfi\n\tif [ -f json2 ]; then\n\t\trm json2\n\tfi\n\n\twhile read iplist\n\tdo\n(\ncat << EOP\n        {\n            \"Action\": \"DELETE\",\n            \"IPSetDescriptor\": {\n                \"Type\": \"IPV4\",\n                \"Value\": \"$iplist\"\n            }\n        },\nEOP\n) >> json2\n\tdone < iplist-existing\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json2\n\tfi\n\n\t# Remove the last comma to close JSON array\n\tcat json2 | sed '$ s/.$//' > json3\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json3\n\tfi\n\n(\ncat << 'EOP'\n    ]\n}\nEOP\n) > json4\n\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json4\n\tfi\n\n\tcat json1 json3 json4 > json5\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo built json5\n\tfi\n\n\trm json1 json2 json3 json4\n}\n\n# Inserts a JSON file into the IP Set\nfunction UpdateSetInsertJSON(){\n\tjson=$(cat json5)\n\tUPDATESET=$(aws waf update-ip-set --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$UPDATESET\"\n\tfi\n}\n\n# Deletes a JSON file from the IP Set\nfunction UpdateSetDeleteJSON(){\n\tjson=$(cat json5)\n\tUPDATESET=$(aws waf update-ip-set --cli-input-json \"$json\" --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$UPDATESET\"\n\tfi\n}\n\n# Inserts a single IP into the IP Set\nfunction UpdateSetInsert(){\n\tUPDATESET=$(aws waf update-ip-set --ip-set-id $IPSETID --change-token $CHANGETOKEN --updates 'Action=INSERT,IPSetDescriptor={Type=IPV4,Value=\"'\"$iplist/32\"'\"}' --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$UPDATESET\"\n\tfi\n}\n\n# Deletes a single IP from the IP Set\nfunction UpdateSetDelete(){\n\tUPDATESET=$(aws waf update-ip-set --ip-set-id $IPSETID --change-token $CHANGETOKEN --updates 'Action=DELETE,IPSetDescriptor={Type=IPV4,Value=\"'\"$iplist\"'\"}' --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$UPDATESET\"\n\tfi\n}\n\n# Create IP Set\nfunction CreateIPSet(){\n\tChangeToken\n\tIPSETID=$(aws waf create-ip-set --name \"$CONDITIONNAME\" --change-token $CHANGETOKEN --profile $profile 2>&1 | jq '.IPSet | .IPSetId' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$IPSETID\"\n\tfi\n\techo \"IP Set ID:\" \"$IPSETID\"\n}\n\n# Get list of all IP Sets\nfunction ListIPSets(){\n\tIPSETID=$(aws waf list-ip-sets --limit 99 --output=json --profile $profile 2>&1 | jq '.IPSets | .[] | select(.Name==\"'\"$CONDITIONNAME\"'\") | .IPSetId' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$IPSETID\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"ListIPSets IPSETID: \"$IPSETID\n\tfi\n}\n\n# Get list of IPs in a single IP Set\nfunction GetIPSet(){\n\tGetIPSet=$(aws waf get-ip-set --ip-set-id \"$IPSETID\" --profile $profile 2>&1 | jq '.IPSet | .IPSetDescriptors | .[] | .Value' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$GetIPSet\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"GetIPSet: \"$GetIPSet\n\tfi\n}\n\n# Creates a WAF Rule\nfunction CreateRule(){\n\tChangeToken\n\tCreateRule=$(aws waf create-rule --metric-name \"$(echo $CONDITIONNAME | sed 's/[\\._-]//g')\" --name \"Allow From $CONDITIONNAME\" --change-token $CHANGETOKEN --profile $profile 2>&1)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$CreateRule\"\n\tfi\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"CreateRule: \"$CreateRule\n\tfi\n\tRULEID=$(echo \"$CreateRule\" | jq '.Rule | .RuleId' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$RULEID\"\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Created WAF Rule ID: \"$RULEID\n\tHorizontalRule\n\techo\n}\n\n# Updates a WAF Rule\nfunction UpdateRule(){\n\tChangeToken\n\tUPDATERULE=$(aws waf update-rule --rule-id \"$RULEID\" --change-token $CHANGETOKEN --updates 'Action=INSERT,Predicate={Negated=false,Type=IPMatch,DataId=\"'\"$IPSETID\"'\"}' --profile $profile 2>&1) # | jq '.Rule | .RuleId' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$UPDATERULE\"\n\tfi\n\tif echo $UPDATERULE | jq '.ChangeToken' | grep -q error; then\n\t\tfail \"$UPDATERULE\"\n\telse\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Attached IP Addresses Set to WAF Rule.\"\n\t\tHorizontalRule\n\t\techo\n\tfi\n}\n\n# Creates a WAF Web ACL\nfunction CreateACL(){\n\tChangeToken\n\tACLID=$(aws waf create-web-acl --metric-name \"$CONDITIONNAME\" --name \"Allow From $CONDITIONNAME\" --default-action 'Type=BLOCK' --change-token $CHANGETOKEN --profile $profile 2>&1 | jq '.WebACL | .WebACLId' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$ACLID\"\n\tfi\n\techo\n\tHorizontalRule\n\techo \"Created WAF Web ACL ID: \"$ACLID\n\tHorizontalRule\n\techo\n}\n\n# Updates a WAF Web ACL\nfunction UpdateACL(){\n\tChangeToken\n\tUPDATEACL=$(aws waf update-web-acl --web-acl-id \"$ACLID\" --change-token $CHANGETOKEN --updates 'Action=INSERT,ActivatedRule={Priority=0,RuleId=\"'\"$RULEID\"'\",Action={Type=ALLOW}}' --profile $profile 2>&1) # | jq '.Rule | .RuleId' | cut -d '\"' -f2)\n\tif [ ! $? -eq 0 ]; then\n\t\tfail \"$UPDATEACL\"\n\tfi\n\tif echo $UPDATEACL | jq '.ChangeToken' | grep -q error; then\n\t\tfail \"$UPDATEACL\"\n\telse\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Attached Rule to WAF Web ACL.\"\n\t\tHorizontalRule\n\t\techo\n\tfi\n}\n\n# Inserts a single IP into the IP Set from the var iplist and reports status using the changetoken\nfunction InsertIPSet(){\n\tChangeToken\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"IPSETID: \"$IPSETID\n\t\techo \"IP: \"$iplist\n\tfi\n\tUpdateSetInsert\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"UPDATESET: \"$UPDATESET\n\tfi\n\techo $CHANGETOKEN >> changetokenlist\n\tChangeTokenStatus\n\techo $CHANGETOKENSTATUS: $iplist/32\n}\n\n# Deletes a single IP from the IP Set using the var iplist and reports status using the changetoken\nfunction DeleteIPSet(){\n\tChangeToken\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"IPSETID: \"$IPSETID\n\t\techo \"IP: \"$iplist\n\tfi\n\tUpdateSetDelete\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo \"UPDATESET: \"$UPDATESET\n\tfi\n\techo $CHANGETOKEN >> changetokenlist\n\tChangeTokenStatus\n\techo $CHANGETOKENSTATUS: $iplist\n}\n\n# Exports a list of IPs in existing IP Set to the file iplist\nfunction ExportExistingIPSet(){\n\tListIPSets\n\tGetIPSet\n\tif [ -z \"$GetIPSet\" ]; then\n\t\techo \"No IPs in Set!\"\n\tfi\n\t# Delete any existing file iplist-existing\n\tif [ -f iplist-existing ]; then\n\t\trm iplist-existing\n\tfi\n\techo \"$GetIPSet\" >> iplist-existing\n\tCountIPSetIPs=$(echo \"$GetIPSet\" | wc -l)\n\tif [[ $DEBUGMODE = \"1\" ]]; then\n\t\techo IPs in set $CONDITIONNAME: $CountIPSetIPs\n\tfi\n}\n\n# Main function to manage WAF IP Set\nfunction WAF(){\n\tGetProbeIPs\n\t# Delete any existing changetokenlist\n\tif [ -f changetokenlist ]; then\n\t\trm changetokenlist\n\tfi\n\t# Check for existing IP Set with the same name and create the set if none exists\n\tif ! aws waf list-ip-sets --limit 99 --output=json --profile $profile 2>&1 | jq '.IPSets | .[] | .Name' | grep -q \"$CONDITIONNAME\"; then\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Creating IP Addresses Set: \"$CONDITIONNAME\n\t\tCreateIPSet\n\t\tHorizontalRule\n\t\techo\n\t\techo\n\t\tHorizontalRule\n\t\techo \"Adding IP match conditions to IP Addresses Set\"\n\t\techo \"IPs to be added: \"$TOTALIPS\n\t\tHorizontalRule\n\t\techo\n\t\tBuildUpdateSetInsertJSON\n\t\tUpdateSetInsertJSON\n\t\t# while read iplist\n\t\t# do\n\t\t# \tInsertIPSet\n\t\t# done < iplist\n\t\tcompleted\n\telse\n\t\ttput setaf 1\n\t\techo\n\t\tHorizontalRule\n\t\techo \"IP Set: $CONDITIONNAME Already Exists\"\n\t\tListIPSets\n\t\techo IPSetID: \"$IPSETID\"\n\t\tHorizontalRule\n\t\ttput sgr0\n\t\techo\n\t\tread -r -p \"Do you want to delete the set and recreate it? (y/n) \" DELETESET\n\t\tif [[ $DELETESET =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\tExportExistingIPSet\n\t\t\techo\n\t\t\tif ! [ -z \"$GetIPSet\" ]; then\n\t\t\t\tHorizontalRule\n\t\t\t\techo \"Deleting IPs from IP Set: \"$CONDITIONNAME\n\t\t\t\techo \"IPs to be deleted: \"$CountIPSetIPs\n\t\t\t\tHorizontalRule\n\t\t\t\techo\n\t\t\t\tBuildUpdateSetDeleteJSON\n\t\t\t\tUpdateSetDeleteJSON\n\t\t\t\t# while read iplist\n\t\t\t\t# do\n\t\t\t\t# \tDeleteIPSet\n\t\t\t\t# done < iplist-existing\n\t\t\t\t# Verifying list is empty\n\t\t\t\tExportExistingIPSet\n\t\t\t\tif [ \"$CountIPSetIPs\" -eq \"1\" ]; then\n\t\t\t\t\tcompleted\n\t\t\t\telse\n\t\t\t\t\tfail \"Error deleting IPs from IP Set.\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\techo\n\t\t\tHorizontalRule\n\t\t\techo \"Adding IPs to IP Set: \"$CONDITIONNAME\n\t\t\techo \"IPs to be added: \"$TOTALIPS\n\t\t\tHorizontalRule\n\t\t\techo\n\t\t\tBuildUpdateSetInsertJSON\n\t\t\tUpdateSetInsertJSON\n\t\t\t# while read iplist\n\t\t\t# do\n\t\t\t# \tInsertIPSet\n\t\t\t# done < iplist\n\t\t\t# Verifying all IPs added\n\t\t\tExportExistingIPSet\n\t\t\tif [ \"$CountIPSetIPs\" -eq \"$TOTALIPS\" ]; then\n\t\t\t\tcompleted\n\t\t\telse\n\t\t\t\tfail \"Error adding IPs to IP Set.\"\n\t\t\tfi\n\t\telse\n\t\t\tread -r -p \"Do you want to update the set with new IPs? (y/n) \" UPDATESET\n\t\t\tif [[ $UPDATESET =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\t\techo\n\t\t\t\tHorizontalRule\n\t\t\t\techo \"Adding IPs to IP Set: \"$CONDITIONNAME\n\t\t\t\techo \"IPs to be added: \"$TOTALIPS\n\t\t\t\tHorizontalRule\n\t\t\t\techo\n\t\t\t\tBuildUpdateSetInsertJSON\n\t\t\t\tUpdateSetInsertJSON\n\t\t\t\t# while read iplist\n\t\t\t\t# do\n\t\t\t\t# \tInsertIPSet\n\t\t\t\t# done < iplist\n\t\t\t\t# Verifying all IPs added\n\t\t\t\tExportExistingIPSet\n\t\t\t\tif [ \"$CountIPSetIPs\" -eq \"$TOTALIPS\" ]; then\n\t\t\t\t\tcompleted\n\t\t\t\telse\n\t\t\t\t\tfail \"Error adding IPs to IP Set.\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\treturn\n\t\t\tfi\n\t\tfi\n\tfi\n\tread -r -p \"Do you want to create a new WAF Rule with the new IP Address Set? (y/n) \" RULE\n\tif [[ $RULE =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\tCreateRule\n\t\tUpdateRule\n\t\tread -r -p \"Do you want to create a new WAF Web ACL and attach the new WAF Rule? (y/n) \" ACL\n\t\tif [[ $ACL =~ ^([yY][eE][sS]|[yY])$ ]]; then\n\t\t\tCreateACL\n\t\t\tUpdateACL\n\t\tfi\n\tfi\n}\n\t\t# You can't delete an IPSet if it's still used in any Rules or if it still includes any IP addresses.\n\t\t# You can't delete a Rule if it's still used in any WebACL objects.\n\n\t\t\t# RULENAME=$(aws waf list-rules --limit 99 --output=json --profile $profile 2>&1 | jq '.Rules | .[] | .Name' | grep \"$CONDITIONNAME\" | cut -d '\"' -f2)\n\t\t\t# RULEID=$(aws waf list-rules --limit 99 --output=json --profile $profile 2>&1 | jq '.Rules | .[] | select(.Name==\"'\"$RULENAME\"'\") | .RuleId' | cut -d '\"' -f2)\n\t\t\t# echo\n\t\t\t# echo \"=====================================================\"\n\t\t\t# echo \"Deleting Rule Name $RULENAME, Rule ID $RULEID\"\n\t\t\t# echo \"=====================================================\"\n\t\t\t# DELETERULE=$(aws waf delete-rule --rule-id \"$RULEID\" --profile $profile 2>&1)\n\t\t\t# if [ ! $? -eq 0 ]; then\n\t\t\t# \tfail \"$DELETERULE\"\n\t\t\t# else\n\t\t\t# \techo \"$DELETERULE\"\n\t\t\t# fi\n\n\t\t\t# echo\n\t\t\t# echo \"=====================================================\"\n\t\t\t# echo \"Deleting Set $CONDITIONNAME, Set ID $IPSETID\"\n\t\t\t# echo \"=====================================================\"\n\t\t\t# DELETESET=$(aws waf delete-ip-set --ip-set-id \"$IPSETID\" --profile $profile 2>&1)\n\t\t\t# if [ ! $? -eq 0 ]; then\n\t\t\t# \tfail \"$DELETESET\"\n\t\t\t# else\n\t\t\t# \techo \"$DELETESET\"\n\t\t\t# \t# echo\n\t\t\t# \t# echo \"=====================================================\"\n\t\t\t# \t# echo \"Creating Security Group \"$GROUPNAME\n\t\t\t# \t# GROUPID=$(aws ec2 create-security-group --group-name \"$GROUPNAME\" --description \"$DESCRIPTION\" --vpc-id $VPCID --profile $profile 2>&1)\n\t\t\t# \t# echo $GROUPID\n\t\t\t# \t# aws ec2 create-tags --resources $(aws ec2 describe-security-groups --output=json | jq '.SecurityGroups | .[] | select(.GroupName==\"$GROUPNAME\") | .GroupId' | cut -d '\"' -f2) --tags Key=Name,Value=\"$GROUPNAME\"\n\t\t\t# \t# echo \"=====================================================\"\n\t\t\t# fi\n\n\n# Check required commands\ncheck_command \"aws\"\ncheck_command \"jq\"\ncheck_command \"wget\"\ncheck_command \"perl\"\n\n# Ensure Variables are set\nif [ \"$CONDITIONNAME\" = \"YOUR-CONDITION-NAME-HERE\" ]; then\n\tfail \"Must set variables!\"\nfi\n\n# TOTALIPS=$(wc -l iplist | cut -d \" \" -f7)\n\nWAF\n\n# CheckStatus\n\n# open https://console.aws.amazon.com/waf/home?region=global#/ipsets/$IPSETID\n"
        }
      ]
    }
  ]
}