{
  "metadata": {
    "timestamp": 1736568707474,
    "page": 803,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ValveSoftware/steam-runtime",
      "stars": 1220,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1982421875,
          "content": "# Stop license files from skewing language-stats on GitHub\ntemplates/common-licenses/* linguist-documentation linguist-language=Text\n\n# Enforce Unix-style line-endings for shell-scripts\n*.sh text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.931640625,
          "content": "p4.ignore\nbuild.log\nbuildroot/amd64/\nbuildroot/i386/\nbuildroot/pbuilder/\ncrosstool/amd64/.build/\ncrosstool/crosstool-ng/\ncrosstool/i386/.build/\ncrosstool/tarballs/\npackages/binary/\npackages/debug/\npackages/source/\n/runtime/\npublish_symbols.sh\ndo-buildbot-build.sh\nmerge_hg_to_runtime.sh\nx-tools\ntmp/\nnewpkg/\n/ubuntu-precise-core-cloudimg-*\n/steam-runtime-*.built-using.txt\n/steam-runtime-*.deb822.gz\n/steam-runtime-*.manifest.txt\n/steam-runtime-*.sources.txt\n/steam-runtime-*.tar.gz\n/steam-runtime-*.tar.xz\n/steam-runtime-sdk-chroot-*.deb822.gz\n/steam-runtime-sdk-chroot-*.tar.gz\n/steam-runtime-sdk-chroot-*.txt\n/unofficial-steam-runtime-*.built-using.txt\n/unofficial-steam-runtime-*.deb822.gz\n/unofficial-steam-runtime-*.manifest.txt\n/unofficial-steam-runtime-*.sources.txt\n/unofficial-steam-runtime-*.tar.xz\n/unofficial-steam-runtime-sdk-chroot-*.deb822.gz\n/unofficial-steam-runtime-sdk-chroot-*.tar.gz\n/unofficial-steam-runtime-sdk-chroot-*.txt\n*.pyc\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.2890625,
          "content": "\nThis is a collection of software packages and scripts to build them.\nThe individual packages each have their own licensing terms included with them.\n\nThe scripts and other documentation contributed by Valve are covered under\nthe following copyright notice:\n\nCopyright (C) 2013 Valve Corporation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of these scripts and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.142578125,
          "content": "all:\n\t@echo \"Nothing to build.\"\n\t@echo \"You probably want to run build-runtime.py instead, see README.md\"\n\ncheck:\n\tprove -v tests/*.py tests/*.sh\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4619140625,
          "content": "steam runtime SDK\n=================\n\nA binary compatible runtime environment for Steam applications on Linux.\n\nIntroduction\n------------\n\nThe Linux version of Steam runs on many Linux distributions, ranging\nfrom the latest rolling-release distributions like Arch Linux to older\nLTS distributions like Ubuntu 14.04.\nTo achieve this, it uses a special library stack, the *Steam Runtime*,\nwhich is installed in `~/.steam/root/ubuntu12_32/steam-runtime`.\nThis is Steam Runtime version 1, codenamed `scout` after the Team\nFortress 2 character class.\n\nThe Steam client itself is run in an environment that adds the shared\nlibraries from Steam Runtime 1 'scout' to the library loading path,\nusing the `LD_LIBRARY_PATH` environment variable.\nThis is referred to as the [`LD_LIBRARY_PATH` runtime][LD_LIBRARY_PATH runtime].\nMost native Linux games available through Steam are also run in this\nenvironment.\n\nA newer approach to cross-distribution compatibility is to use Linux\nnamespace (container) technology, to run games in a more predictable\nenvironment, even when running on an arbitrary Linux distribution which\nmight be old, new or unusually set up.\nThis is implemented as a series of Steam Play compatibility tools, and\nis referred to as the Steam [container runtime][], or as the\n*Steam Linux Runtime*.\n\nThe Steam Runtime is also used by the [Proton][] Steam Play compatibility\ntools, which run Windows games on Linux systems.\nOlder versions of Proton (5.0 or earlier) use the same 'scout'\n[`LD_LIBRARY_PATH` runtime][LD_LIBRARY_PATH runtime] as most native\nLinux games.\nNewer versions of Proton (5.13 or newer) use a [container runtime][]\nwith newer library versions: this is Steam Runtime version 2, codenamed\n'soldier'.\n\nMore information about the\n[`LD_LIBRARY_PATH` runtime][LD_LIBRARY_PATH runtime] and\n[container runtime][] is available as part of the\n[steam-runtime-tools documentation][].\n\n[LD_LIBRARY_PATH runtime]: https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/main/docs/ld-library-path-runtime.md\n[container runtime]: https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/main/docs/container-runtime.md\n[Proton]: https://github.com/ValveSoftware/Proton/\n[steam-runtime-tools documentation]: https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/tree/main/docs\n\nReporting bugs and issues\n-------------------------\n\nPlease report issues to the [steam-runtime issue tracker][].\n\nThe container runtimes have some [known issues][] which do not need to be\nreported again.\n\nThe container runtime is quite complicated, so we will need\n[additional information][reporting bugs] to be able to make progress\non resolving issues.\n\n[steam-runtime issue tracker]: https://github.com/ValveSoftware/steam-runtime\n[known issues]: doc/steamlinuxruntime-known-issues.md\n[reporting bugs]: doc/reporting-steamlinuxruntime-bugs.md\n\nSteam-runtime Repository\n------------------------\n\nThe Steam-runtime SDK relies on an APT repository that Valve has created that holds the packages contained within the steam-runtime. A single package, steamrt-dev, lists all the steam-runtime development packages (i.e. packages that contain headers and files required to build software with those libraries, and whose names end in -dev) as dependencies. Conceptually, a base chroot environment is created in the traditional way using debootstrap, steamrt-dev is then installed into this, and then a set of commonly used compilers and build tools are installed. It is expected that after this script sets the environment up, developers may want to install other packages / tools they may need into the chroot environment.\nIf any of these packages contain runtime dependencies, then you will have to make sure to satisfy these yourself, as only the runtime dependencies of the steamrt-dev packages are included in the steam-runtime. \n\nInstallation\n------------\n\nSteam Runtime version 1, 'scout' is automatically installed as part\nof the [Steam Client for Linux][].\n\nEach version of the Steam [container runtime][] is automatically\ndownloaded to your Steam library if you install a game or a version of\nProton that requires it.\nThey can also be downloaded by opening `steam://` links with Steam:\n\n* Steam Linux Runtime 1.0 (scout): `steam steam://install/1070560`\n* Steam Linux Runtime 2.0 (soldier): `steam steam://install/1391110`\n* Steam Linux Runtime 3.0 (sniper): `steam steam://install/1628350`\n\nAll the software that makes up the Steam Runtime is available in both source and binary form in the Steam Runtime repository [https://repo.steampowered.com/steamrt](https://repo.steampowered.com/steamrt \"\")\n\nIncluded in this repository are scripts for building local copies of the Steam Runtime for testing and scripts for building Linux chroot environments suitable for building applications.\n\n[Steam Client for Linux]: https://github.com/ValveSoftware/steam-for-linux/\n\nBuilding in the runtime\n-----------------------\n\nTo prevent libraries from development and build machines 'leaking'\ninto your applications, you should build within a Steam Runtime container\nor chroot environment.\n\nWe recommend using a\n[Toolbx](https://containertoolbx.org/),\n[rootless Podman](https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md)\nor [Docker](https://docs.docker.com/get-docker/)\ncontainer for this:\n\n    podman pull registry.gitlab.steamos.cloud/steamrt/scout/sdk\n\nor\n\n    sudo docker pull registry.gitlab.steamos.cloud/steamrt/scout/sdk\n\nFor more details, please consult the\n[Steam Runtime SDK](https://gitlab.steamos.cloud/steamrt/scout/sdk/-/blob/steamrt/scout/README.md)\ndocumentation.\n\n### Using a debugger in the build environment\n\nTo get the detached debug symbols that are required for `gdb` and\nsimilar tools, you can download the matching\n`com.valvesoftware.SteamRuntime.Sdk-amd64,i386-scout-debug.tar.gz`,\nunpack it (preserving directory structure), and use its `files/`\ndirectory as the schroot or container's `/usr/lib/debug`.\n\nFor example, with Docker, you might unpack the tarball in\n`/tmp/scout-dbgsym-0.20191024.0` and use something like:\n\n    sudo docker run \\\n    --rm \\\n    --init \\\n    -v /home:/home \\\n    -v /tmp/scout-dbgsym-0.20191024.0/files:/usr/lib/debug \\\n    -e HOME=/home/user \\\n    -u $(id -u):$(id -g) \\\n    -h $(hostname) \\\n    -v /tmp:/tmp \\\n    -it \\\n    steamrt_scout_amd64:latest \\\n    /dev/init -sg -- /bin/bash\n\nor with schroot, you might create\n`/var/chroots/steamrt_scout_amd64/usr/lib/debug/` and move the contents\nof `files/` into it.\n\nUsing detached debug symbols\n----------------------------\n\nPlease see [doc/debug-symbols.md](doc/debug-symbols.md).\n"
        },
        {
          "name": "build-runtime.py",
          "type": "blob",
          "size": 43.8818359375,
          "content": "#!/usr/bin/env python3\n#\n# Script to build and install packages into the Steam runtime\n\nimport calendar\nimport errno\nimport os\nimport re\nimport sys\nimport glob\nimport gzip\nimport hashlib\nimport shutil\nimport subprocess\nimport tarfile\nimport tempfile\nimport time\nfrom pathlib import Path\n\nfrom debian import deb822\nfrom debian.debian_support import Version\nimport argparse\n\ntry:\n\timport typing\nexcept ImportError:\n\tpass\nelse:\n\ttyping\t\t# noqa\n\ntry:\n\tfrom io import BytesIO\nexcept ImportError:\n\tfrom cStringIO import StringIO as BytesIO\t\t# type: ignore\n\ntry:\n\tfrom urllib.request import (urlopen, urlretrieve)\nexcept ImportError:\n\tfrom urllib import (urlopen, urlretrieve)\t\t# type: ignore\n\ndestdir=\"newpkg\"\n\n# The top level directory\ntop = sys.path[0]\n\nONE_MEGABYTE = 1024 * 1024\nSPLIT_MEGABYTES = 50\nMIN_PARTS = 3\n\n# Order is significant: the first architecture is considered primary\nDEFAULT_ARCHITECTURES = ('amd64', 'i386')\n\nARCHITECTURES = {\n\t'amd64': 'x86_64-linux-gnu',\n\t'i386': 'i386-linux-gnu',\n}\n\n\ndef hard_link_or_copy(source, dest):\n\t\"\"\"\n\tCopy source to dest, optimizing by creating a hard-link instead\n\tof a full copy if possible.\n\t\"\"\"\n\ttry:\n\t\tos.remove(dest)\n\texcept OSError as e:\n\t\tif e.errno != errno.ENOENT:\n\t\t\traise\n\n\ttry:\n\t\tos.link(source, dest)\n\texcept OSError:\n\t\tshutil.copyfile(source, dest)\n\n\ndef warn_if_different(\n\tpath1,\t\t# type: str\n\tpath2\t\t# type: str\n):\n\t# type: (...) -> None\n\t# Deliberately ignoring exit status\n\tsubprocess.call([\n\t\t'diff', '--brief', '--', path1, path2,\n\t])\n\n\ndef str2bool (b):\n\treturn b.lower() in (\"yes\", \"true\", \"t\", \"1\")\n\n\ndef check_path_traversal(s):\n\tif '..' in s or s.startswith('/'):\n\t\traise ValueError('Path traversal detected in %r' % s)\n\n\nclass AptSource:\n\tdef __init__(\n\t\tself,\n\t\tkind,\n\t\turl,\n\t\tsuite,\n\t\tcomponents=('main',),\n\t\ttrusted=False\n\t):\n\t\tself.kind = kind\n\t\tself.url = url\n\t\tself.suite = suite\n\t\tself.components = components\n\t\tself.trusted = trusted\n\n\tdef __str__(self):\n\t\tif self.trusted:\n\t\t\tmaybe_options = ' [trusted=yes]'\n\t\telse:\n\t\t\tmaybe_options = ''\n\n\t\treturn '%s%s %s %s %s' % (\n\t\t\tself.kind,\n\t\t\tmaybe_options,\n\t\t\tself.url,\n\t\t\tself.suite,\n\t\t\t' '.join(self.components),\n\t\t)\n\n\t@property\t\t# type: ignore\n\tdef release_url(self):\n\t\t# type: () -> str\n\n\t\tif self.suite.endswith('/') and not self.components:\n\t\t\tsuite = self.suite\n\n\t\t\tif suite == './':\n\t\t\t\tsuite = ''\n\n\t\t\treturn '%s/%sRelease' % (self.url, suite)\n\n\t\treturn '%s/dists/%s/Release' % (self.url, self.suite)\n\n\t@property\t\t# type: ignore\n\tdef sources_urls(self):\n\t\t# type: () -> typing.List[str]\n\t\tif self.kind != 'deb-src':\n\t\t\treturn []\n\n\t\tif self.suite.endswith('/') and not self.components:\n\t\t\tsuite = self.suite\n\n\t\t\tif suite == './':\n\t\t\t\tsuite = ''\n\n\t\t\treturn ['%s/%sSources.gz' % (self.url, suite)]\n\n\t\treturn [\n\t\t\t\"%s/dists/%s/%s/source/Sources.gz\" % (\n\t\t\t\tself.url, self.suite, component)\n\t\t\tfor component in self.components\n\t\t]\n\n\tdef get_packages_urls(self, arch, dbgsym=False):\n\t\t# type: (str, bool) -> typing.List[str]\n\n\t\tif self.kind != 'deb':\n\t\t\treturn []\n\n\t\tif self.suite.endswith('/') and not self.components:\n\t\t\tsuite = self.suite\n\n\t\t\tif suite == './':\n\t\t\t\tsuite = ''\n\n\t\t\treturn ['%s/%sPackages.gz' % (self.url, suite)]\n\n\t\tret = []\t\t# type: typing.List[str]\n\n\t\tfor component in self.components:\n\t\t\tret.append(\n\t\t\t\t\"%s/dists/%s/%s/binary-%s/Packages.gz\" % (\n\t\t\t\t\tself.url, self.suite, component,\n\t\t\t\t\tarch)\n\t\t\t)\n\n\t\t\tif dbgsym:\n\t\t\t\tret.append(\n\t\t\t\t\t\"%s/dists/%s/%s/debug/binary-%s/Packages.gz\" % (\n\t\t\t\t\t\tself.url, self.suite,\n\t\t\t\t\t\tcomponent, arch)\n\t\t\t\t)\n\n\t\treturn ret\n\n\ndef parse_args():\n\tparser = argparse.ArgumentParser()\n\tparser.add_argument(\n\t\t\"--templates\",\n\t\thelp=\"specify template files to include in runtime\",\n\t\tdefault=os.path.join(top, \"templates\"))\n\tparser.add_argument(\n\t\t\"-o\", \"--output\", default=None,\n\t\thelp=\"specify output directory [default: delete after archiving]\")\n\tparser.add_argument(\"--suite\", help=\"specify apt suite\", default='scout')\n\tparser.add_argument(\"-b\", \"--beta\", help=\"build beta runtime\", dest='suite', action=\"store_const\", const='scout_beta')\n\tparser.add_argument(\"-d\", \"--debug\", help=\"build debug runtime\", action=\"store_true\")\n\tparser.add_argument(\"--source\", help=\"include sources\", action=\"store_true\")\n\tparser.add_argument(\"--symbols\", help=\"include debugging symbols\", action=\"store_true\")\n\tparser.add_argument(\n\t\t\"--repo\", help=\"main apt repository URL\",\n\t\tdefault=\"https://repo.steampowered.com/steamrt\",\n\t)\n\tparser.add_argument(\n\t\t\"--upstream-apt-source\", dest='upstream_apt_sources',\n\t\tdefault=[], action='append',\n\t\thelp=(\n\t\t\t\"additional apt sources in the form \"\n\t\t\t\"'deb https://URL SUITE COMPONENT [COMPONENT...]' \"\n\t\t\t\"(may be repeated)\"\n\t\t),\n\t)\n\tparser.add_argument(\n\t\t\"--extra-apt-source\", dest='extra_apt_sources',\n\t\tdefault=[], action='append',\n\t\thelp=(\n\t\t\t\"additional apt sources in the form \"\n\t\t\t\"'deb https://URL SUITE COMPONENT [COMPONENT...]' \"\n\t\t\t\"(may be repeated)\"\n\t\t),\n\t)\n\tparser.add_argument(\"-v\", \"--verbose\", help=\"verbose\", action=\"store_true\")\n\tparser.add_argument(\"--official\", help=\"mark this as an official runtime\", action=\"store_true\")\n\tparser.add_argument(\"--set-name\", help=\"set name for this runtime\", default=None)\n\tparser.add_argument(\"--set-version\", help=\"set version number for this runtime\", default=None)\n\tparser.add_argument(\"--debug-url\", help=\"set URL for debug/source version\", default=None)\n\tparser.add_argument(\"--archive\", help=\"pack Steam Runtime into a tarball\", default=None)\n\tparser.add_argument(\n\t\t\"--compression\", help=\"set compression [xz|gx|bz2|none]\",\n\t\tchoices=('xz', 'gz', 'bz2', 'none'),\n\t\tdefault='xz')\n\tparser.add_argument(\n\t\t'--strict', action=\"store_true\",\n\t\thelp='Exit unsuccessfully when something seems wrong')\n\tparser.add_argument(\n\t\t'--split', default=None,\n\t\thelp='Also generate an archive split into 50M parts')\n\tparser.add_argument(\n\t\t'--architecture', '--arch',\n\t\thelp='include architecture (the first is assumed to be primary)',\n\t\taction='append', dest='architectures', default=[],\n\t)\n\tparser.add_argument(\n\t\t'--metapackage',\n\t\thelp='Include the given package and its dependencies',\n\t\taction='append', dest='metapackages', default=[],\n\t)\n\tparser.add_argument(\n\t\t'--packages-from',\n\t\thelp='Include packages listed in the given file',\n\t\taction='append', default=[],\n\t)\n\tparser.add_argument(\n\t\t'--dump-options', action='store_true',\n\t\thelp=argparse.SUPPRESS,\t\t# deliberately undocumented\n\t)\n\n\targs = parser.parse_args()\n\n\tif args.output is None and args.archive is None:\n\t\tparser.error(\n\t\t\t'At least one of --output and --archive is required')\n\n\tif args.split is not None and args.archive is None:\n\t\tparser.error('--split requires --archive')\n\n\tif not os.path.isdir(args.templates):\n\t\tparser.error(\n\t\t\t'Argument to --templates, %r, must be a directory'\n\t\t\t% args.templates)\n\n\t# os.path.exists is false for dangling symlinks, so check for both\n\tif args.output is not None and (\n\t\tos.path.exists(args.output)\n\t\tor os.path.islink(args.output)\n\t):\n\t\tparser.error(\n\t\t\t'Argument to --output, %r, must not already exist'\n\t\t\t% args.output)\n\n\tif not args.architectures:\n\t\tif args.suite in ('heavy', 'heavy_beta'):\n\t\t\targs.architectures = ['amd64']\n\t\telse:\n\t\t\targs.architectures = list(DEFAULT_ARCHITECTURES)\n\n\tif not args.packages_from and not args.metapackages:\n\t\targs.metapackages = ['steamrt-ld-library-path', 'steamrt-libs']\n\n\t\tif args.suite in ('scout', 'scout_beta'):\n\t\t\targs.metapackages.append('steamrt-legacy')\n\n\t\tif args.debug:\n\t\t\targs.metapackages.append('steamrt-libdevel')\n\t\t\targs.metapackages.append('steamrt-libdevel-non-multiarch')\n\t\t\t# Not really a metapackage, but we want it in the\n\t\t\t# debug tarball only; container/chroot/Docker\n\t\t\t# environments get libgl1-mesa-dev instead\n\t\t\tif args.suite in ('scout', 'scout_beta'):\n\t\t\t\targs.metapackages.append('dummygl-dev')\n\n\treturn args\n\n\ndef download_file(file_url, file_path):\n\ttry:\n\t\tif os.path.getsize(file_path) > 0:\n\t\t\tif args.verbose:\n\t\t\t\tprint(\"Skipping download of existing file: %s\" % file_path)\n\t\t\treturn False\n\texcept OSError:\n\t\tpass\n\n\ttry:\n\t\tif args.verbose:\n\t\t\tprint(\"Downloading %s to %s\" % (file_url, file_path))\n\t\turlretrieve(file_url, file_path)\n\texcept Exception:\n\t\tsys.stderr.write('Error downloading %s:\\n' % file_url)\n\t\traise\n\treturn True\n\n\nclass SourcePackage:\n\tdef __init__(self, apt_source, stanza):\n\t\tself.apt_source = apt_source\n\t\tself.stanza = stanza\n\n\ndef install_sources(apt_sources, sourcelist):\n\t# Load the Sources files so we can find the location of each source package\n\tsource_packages = []\n\n\tfor apt_source in apt_sources:\n\t\tfor url in apt_source.sources_urls:\n\t\t\tprint(\"Downloading sources from %s\" % url)\n\t\t\tsz = urlopen(url)\n\t\t\turl_file_handle=BytesIO(sz.read())\n\t\t\tsources = gzip.GzipFile(fileobj=url_file_handle)\n\t\t\tfor stanza in deb822.Sources.iter_paragraphs(sources):\n\t\t\t\tsource_packages.append(\n\t\t\t\t\tSourcePackage(apt_source, stanza))\n\n\tskipped = 0\n\tfailed = False\n\tincluded = {}\n\tmanifest_lines = set()\n\n\t# Walk through the Sources file and process any requested packages.\n\t# If a particular source package name appears more than once (for\n\t# example in scout and also in an overlay suite), we err on the side\n\t# of completeness and download all of them.\n\tfor sp in source_packages:\n\t\tp = sp.stanza['package']\n\n\t\t# Skip packages with Extra-Source-Only: yes.\n\t\t# These don't necessarily appear in the package pool.\n\t\tif sp.stanza.get('Extra-Source-Only', 'no') == 'yes':\n\t\t\tcontinue\n\n\t\tif p in sourcelist:\n\t\t\tif args.verbose:\n\t\t\t\tprint(\"DOWNLOADING SOURCE: %s\" % p)\n\n\t\t\t#\n\t\t\t# Create the destination directory if necessary\n\t\t\t#\n\t\t\tcache_dir = os.path.join(top, destdir, \"source\", p)\n\t\t\tif not os.access(cache_dir, os.W_OK):\n\t\t\t\tos.makedirs(cache_dir)\n\n\t\t\t#\n\t\t\t# Download each file\n\t\t\t#\n\t\t\tfor file in sp.stanza['files']:\n\t\t\t\tcheck_path_traversal(file['name'])\n\t\t\t\tfile_path = os.path.join(cache_dir, file['name'])\n\t\t\t\tfile_url = \"%s/%s/%s\" % (\n\t\t\t\t\tsp.apt_source.url,\n\t\t\t\t\tsp.stanza['directory'],\n\t\t\t\t\tfile['name']\n\t\t\t\t)\n\t\t\t\tif not download_file(file_url, file_path):\n\t\t\t\t\tskipped += 1\n\n\t\t\tfor file in sp.stanza['files']:\n\t\t\t\tif args.strict:\n\t\t\t\t\thasher = hashlib.md5()\n\n\t\t\t\t\twith open(\n\t\t\t\t\t\tos.path.join(cache_dir, file['name']),\n\t\t\t\t\t\t'rb'\n\t\t\t\t\t) as bin_reader:\n\t\t\t\t\t\tblob = bin_reader.read(4096)\n\n\t\t\t\t\t\twhile blob:\n\t\t\t\t\t\t\thasher.update(blob)\n\t\t\t\t\t\t\tblob = bin_reader.read(4096)\n\n\t\t\t\t\t\tif hasher.hexdigest() != file['md5sum']:\n\t\t\t\t\t\t\tprint('ERROR: %s has unexpected content' % file['name'])\n\t\t\t\t\t\t\tfailed = True\n\n\t\t\t\t# Copy the source package into the output directory\n\t\t\t\t# (optimizing the copy as a hardlink if possible)\n\t\t\t\tos.makedirs(os.path.join(args.output, 'source'), exist_ok=True)\n\t\t\t\thard_link_or_copy(\n\t\t\t\t\tos.path.join(cache_dir, file['name']),\n\t\t\t\t\tos.path.join(\n\t\t\t\t\t\targs.output, 'source', file['name']))\n\n\t\t\tincluded[(p, sp.stanza['Version'])] = sp.stanza\n\t\t\tmanifest_lines.add(\n\t\t\t\t'%s\\t%s\\t%s\\n' % (\n\t\t\t\t\tp, sp.stanza['Version'],\n\t\t\t\t\tsp.stanza['files'][0]['name']))\n\n\tif failed:\n\t\tsys.exit(1)\n\n\t# sources.txt: Tab-separated table of source packages, their\n\t# versions, and the corresponding .dsc file.\n\twith open(os.path.join(args.output, 'source', 'sources.txt'), 'w') as writer:\n\t\twriter.write('#Source\\t#Version\\t#dsc\\n')\n\n\t\tfor line in sorted(manifest_lines):\n\t\t\twriter.write(line)\n\n\t# sources.deb822.gz: The full Sources stanza for each included source\n\t# package, suitable for later analysis.\n\twith open(\n\t\tos.path.join(args.output, 'source', 'sources.deb822.gz'), 'wb'\n\t) as gz_writer:\n\t\twith gzip.GzipFile(\n\t\t\tfilename='', mode='wb', fileobj=gz_writer, mtime=0\n\t\t) as stanza_writer:\n\t\t\tdone_one = False\n\n\t\t\tfor key, stanza in sorted(included.items()):\n\t\t\t\tif done_one:\n\t\t\t\t\tstanza_writer.write(b'\\n')\n\n\t\t\t\tstanza.dump(stanza_writer)\n\t\t\t\tdone_one = True\n\n\tif skipped > 0:\n\t\tprint(\"Skipped downloading %i deb source file(s) that were already present.\" % skipped)\n\n\nclass Binary:\n\tdef __init__(self, apt_source, stanza):\n\t\tself.apt_source = apt_source\n\t\tself.stanza = stanza\n\t\tself.name = stanza['Package']\n\t\tself.arch = stanza['Architecture']\n\t\tself.version = stanza['Version']\n\t\tsource = stanza.get('Source', self.name)\n\n\t\tif ' (' in source:\n\t\t\tself.source, tmp = source.split(' (', 1)\n\t\t\tself.source_version = tmp.rstrip(')')\n\t\telse:\n\t\t\tself.source = source\n\t\t\tself.source_version = self.version\n\n\t\tself.dependency_names = set()\n\n\t\tfor field in ('Depends', 'Pre-Depends'):\n\t\t\tvalue = stanza.get(field, '')\n\t\t\tdeps = value.split(',')\n\n\t\t\tfor d in deps:\n\t\t\t\t# ignore alternatives\n\t\t\t\td = d.split('|')[0]\n\t\t\t\t# ignore version number\n\t\t\t\td = d.split('(')[0]\n\t\t\t\td = d.strip()\n\n\t\t\t\tif d:\n\t\t\t\t\tself.dependency_names.add(d)\n\n\ndef list_binaries(\n\tapt_sources,\t\t# type: typing.List[AptSource]\n\tdbgsym=False\t\t# type: bool\n):\n\t# type: (...) -> typing.Dict[str, typing.Dict[str, typing.List[Binary]]]\n\n\t# {'amd64': {'libc6': [<Binary>, ...]}}\n\tby_arch = {}\t\t# type: typing.Dict[str, typing.Dict[str, typing.List[Binary]]]\n\n\tif dbgsym:\n\t\tdescription = 'debug symbols'\n\telse:\n\t\tdescription = 'binaries'\n\n\tfor arch in args.architectures:\n\t\tby_name = {}\t\t# type: typing.Dict[str, typing.List[Binary]]\n\n\t\t# Load the Packages files so we can find the location of each\n\t\t# binary package\n\t\tfor apt_source in apt_sources:\n\t\t\tfor url in apt_source.get_packages_urls(\n\t\t\t\tarch,\n\t\t\t\tdbgsym=dbgsym,\n\t\t\t):\n\t\t\t\tprint(\"Downloading %s %s from %s\" % (\n\t\t\t\t\tarch, description, url))\n\n\t\t\t\ttry:\n\t\t\t\t\t# Python 2 does not catch a 404 here\n\t\t\t\t\turl_file_handle = gzip.GzipFile(\n\t\t\t\t\t\tfileobj=BytesIO(\n\t\t\t\t\t\t\turlopen(url).read()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tmode='rb',\n\t\t\t\t\t)\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tif dbgsym:\n\t\t\t\t\t\tprint(e)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\telse:\n\t\t\t\t\t\traise\n\n\t\t\t\tfor stanza in deb822.Packages.iter_paragraphs(\n\t\t\t\t\turl_file_handle\n\t\t\t\t):\n\t\t\t\t\tif stanza['Architecture'] not in ('all', arch):\n\t\t\t\t\t\tprint('Found %s package %s in %s Packages file' % (\n\t\t\t\t\t\t\tstanza['Architecture'],\n\t\t\t\t\t\t\tstanza['Package'],\n\t\t\t\t\t\t\tarch,\n\t\t\t\t\t\t))\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tp = stanza['Package']\n\t\t\t\t\tbinary = Binary(apt_source, stanza)\n\t\t\t\t\tby_name.setdefault(p, []).append(\n\t\t\t\t\t\tbinary)\n\n\t\tby_arch[arch] = by_name\n\n\treturn by_arch\n\n\ndef ignore_metapackage_dependency(name):\n\t\"\"\"\n\tReturn True if @name should not be installed in Steam Runtime\n\ttarballs, even if it's depended on by the metapackage.\n\t\"\"\"\n\treturn name in (\n\t\t# Must be provided by host system\n\t\t'libc6',\n\t\t'libegl-mesa0',\n\t\t'libegl1-mesa',\n\t\t'libegl1-mesa-drivers',\n\t\t'libgl1-mesa-dri',\n\t\t'libgl1-mesa-glx',\n\t\t'libgles1-mesa',\n\t\t'libgles2-mesa',\n\t\t'libglx-mesa0',\n\t\t'mesa-opencl-icd',\n\t\t'mesa-va-drivers',\n\t\t'mesa-vdpau-drivers',\n\t\t'mesa-vulkan-drivers',\n\n\t\t# Provided by host system alongside Mesa if needed\n\t\t'libtxc-dxtn-s2tc0',\n\n\t\t# Actually a virtual package\n\t\t'libcggl',\n\n\t\t# Experimental\n\t\t'libcasefold-dev',\n\t)\n\n\ndef accept_transitive_dependency(name):\n\t\"\"\"\n\tReturn True if @name should be included in the Steam Runtime\n\ttarball whenever it is depended on a package depended on by\n\tthe metapackage, but should not be a direct dependency of the\n\tmetapackage.\n\t\"\"\"\n\treturn name in (\n\t\t'gcc-4.6-base',\n\t\t'gcc-4.8-base',\n\t\t'gcc-4.9-base',\n\t\t'gcc-5-base',\n\t\t'libelf1',\n\t\t'libx11-data',\n\t)\n\n\ndef ignore_transitive_dependency(name):\n\t\"\"\"\n\tReturn True if @name should not be included in the Steam Runtime\n\ttarball or directly depended on by the metapackage, even though\n\tpackages in the Steam Runtime might have dependencies on it.\n\t\"\"\"\n\treturn name in (\n\t\t# Must be provided by host system\n\t\t'libc6',\n\t\t'libegl-mesa0',\n\t\t'libegl1-mesa',\n\t\t'libegl1-mesa-drivers',\n\t\t'libgl1-mesa-dri',\n\t\t'libgl1-mesa-glx',\n\t\t'libgles1-mesa',\n\t\t'libgles2-mesa',\n\t\t'libglx-mesa0',\n\t\t'mesa-opencl-icd',\n\t\t'mesa-va-drivers',\n\t\t'mesa-vdpau-drivers',\n\t\t'mesa-vulkan-drivers',\n\n\t\t# Assumed to be provided by host system if needed\n\t\t'ca-certificates',\n\t\t'fontconfig',\n\t\t'fontconfig-config',\n\t\t'gconf2-common',\n\t\t'iso-codes',\n\t\t'libasound2-data',\n\t\t'libatk1.0-data',\n\t\t'libavahi-common-data',\n\t\t'libdb5.1',\n\t\t'libdconf0',\n\t\t'libdrm-intel1',\n\t\t'libdrm-radeon1',\n\t\t'libdrm-nouveau1a',\n\t\t'libdrm2',\n\t\t'libglapi-mesa',\n\t\t'libllvm3.0',\n\t\t'libopenal-data',\n\t\t'libthai-data',\n\t\t'libthai0',\n\t\t'libtxc-dxtn-s2tc0',\n\t\t'passwd',\n\t\t'shared-mime-info',\n\t\t'sound-theme-freedesktop',\n\t\t'x11-common',\n\n\t\t# Non-essential: only contains localizations\n\t\t'libgdk-pixbuf2.0-common',\n\t\t'libjson-glib-1.0-common',\n\n\t\t# Depended on by packages that are present for historical\n\t\t# reasons\n\t\t'libcggl',\n\t\t'libstdc++6-4.6-dev',\n\t\t'zenity-common',\n\n\t\t# Only exists for packaging/dependency purposes\n\t\t'debconf',\n\t\t'libjpeg8',\t\t# transitions to libjpeg-turbo8\n\t\t'multiarch-support',\n\n\t\t# Used for development in Steam Runtime, but not in\n\t\t# chroots/containers that satisfy dependencies\n\t\t'dummygl-dev',\n\t)\n\n\ndef expand_metapackages(architectures, binaries_by_arch, metapackages):\n\tsources_from_apt = set()\n\tbinaries_from_apt = {}\n\terror = False\n\n\tfor arch in architectures:\n\t\tarch_binaries = binaries_by_arch[arch]\n\t\tbinaries_from_apt[arch] = set()\n\n\t\tfor metapackage in metapackages:\n\t\t\tif metapackage not in arch_binaries:\n\t\t\t\tprint('ERROR: Metapackage %s not found in Packages files' % metapackage)\n\t\t\t\terror = True\n\t\t\t\tcontinue\n\n\t\t\tbinary = max(\n\t\t\t\tarch_binaries[metapackage],\n\t\t\t\tkey=lambda b: Version(b.stanza['Version']))\n\t\t\tsources_from_apt.add(binary.source)\n\t\t\tbinaries_from_apt[arch].add(metapackage)\n\n\t\t\tfor d in binary.dependency_names:\n\t\t\t\tif not ignore_metapackage_dependency(d):\n\t\t\t\t\tbinaries_from_apt[arch].add(d)\n\n\tfor arch, arch_binaries in sorted(binaries_by_arch.items()):\n\t\tfor library in sorted(binaries_from_apt[arch]):\n\t\t\tif not _recurse_dependency(\n\t\t\t\tarch_binaries,\n\t\t\t\tlibrary,\n\t\t\t\tbinaries_from_apt[arch],\n\t\t\t\tsources_from_apt,\n\t\t\t):\n\t\t\t\terror = True\n\n\tif error and args.strict:\n\t\tsys.exit(1)\n\n\treturn sources_from_apt, binaries_from_apt\n\n\ndef _recurse_dependency(\n\tarch_binaries,\t\t\t# type: typing.Dict[str, typing.List[Binary]]\n\tlibrary,\t\t\t# type: str\n\tbinaries_from_apt,\t\t# type: typing.Set[str]\n\tsources_from_apt\t\t# type: typing.Set[str]\n):\n\tif library not in arch_binaries:\n\t\tprint('ERROR: Package %s not found in Packages files' % library)\n\t\treturn False\n\n\tbinary = max(\n\t\tarch_binaries[library],\n\t\tkey=lambda b: Version(b.stanza['Version']))\n\tsources_from_apt.add(binary.source)\n\terror = False\n\n\tfor d in binary.dependency_names:\n\t\tif accept_transitive_dependency(d):\n\t\t\tif d not in binaries_from_apt:\n\t\t\t\tbinaries_from_apt.add(d)\n\t\t\t\tif not _recurse_dependency(\n\t\t\t\t\tarch_binaries,\n\t\t\t\t\td,\n\t\t\t\t\tbinaries_from_apt,\n\t\t\t\t\tsources_from_apt,\n\t\t\t\t):\n\t\t\t\t\terror = True\n\t\telif library.endswith(('-dev', '-dbg', '-multidev')):\n\t\t\t# When building a -debug runtime we\n\t\t\t# disregard transitive dependencies of\n\t\t\t# development-only packages\n\t\t\tpass\n\t\telif d in binaries_from_apt:\n\t\t\tpass\n\t\telif ignore_metapackage_dependency(d):\n\t\t\tpass\n\t\telif ignore_transitive_dependency(d):\n\t\t\tpass\n\t\telse:\n\t\t\tprint('ERROR: %s depends on %s but the metapackages do not' % (library, d))\n\t\t\t_recurse_dependency(\n\t\t\t\tarch_binaries,\n\t\t\t\td,\n\t\t\t\tbinaries_from_apt,\n\t\t\t\tsources_from_apt,\n\t\t\t)\n\t\t\terror = True\n\n\treturn not error\n\n\ndef check_consistency(\n\tbinaries_from_apt,\t\t# type: typing.Dict[str, typing.Set[str]]\n\tbinaries_from_lists,\t\t# type: typing.Set[str]\n):\n\tfor arch, binaries in sorted(binaries_from_apt.items()):\n\t\tfor b in sorted(binaries - binaries_from_lists):\n\t\t\tprint('Installing %s only because of --metapackage' % b)\n\t\tfor b in sorted(binaries_from_lists - binaries):\n\t\t\tprint('Installing %s only because of --packages-from' % b)\n\n\tfor arch, binaries in sorted(binaries_from_apt.items()):\n\t\tfor name in sorted(binaries):\n\t\t\tif name in binaries_from_lists:\n\t\t\t\tpass\n\t\t\telif ignore_metapackage_dependency(name):\n\t\t\t\tpass\n\t\t\telif ignore_transitive_dependency(name):\n\t\t\t\tpass\n\t\t\telif name in args.metapackages:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tprint('WARNING: Binary package %s on %s depended on by %s but not in %s' % (name, arch, args.metapackages, args.packages_from))\n\n\t\tfor name in sorted(binaries_from_lists):\n\t\t\tif name in binaries:\n\t\t\t\tpass\n\t\t\telif ignore_transitive_dependency(name):\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tprint('WARNING: Binary package %s in %s but not depended on by %s on %s' % (name, args.packages_from, args.metapackages, arch))\n\n\ndef get_output_dir_for_arch(arch: str) -> Path:\n\t\"\"\"Generates the canonical output directory for the provided architecture\"\"\"\n\treturn Path(args.output) / arch\n\n\ndef keep_only_primary_arch(relative_path: str) -> bool:\n\t# For some paths below /usr/libexec it's unimportant whether we have\n\t# a 32- or 64-bit executable, so silently keep the one from the\n\t# primary architecture, without logging a warning.\n\treturn relative_path.startswith((\t\t# any of these prefixes:\n\t\t'usr/libexec/flatpak-xdg-utils/',\n\t\t'usr/libexec/steam-runtime-tools-0/',\n\t))\n\n\ndef install_binaries(architectures, binaries_by_arch, binarylists, manifest):\n\tskipped = 0\n\n\tfor arch, arch_binaries in sorted(binaries_by_arch.items()):\n\t\tinstallset = binarylists[arch].copy()\n\n\t\t#\n\t\t# Create the destination directory if necessary\n\t\t#\n\t\tdir = os.path.join(top,destdir,\"binary\" if not args.debug else \"debug\", arch)\n\t\tif not os.access(dir, os.W_OK):\n\t\t\tos.makedirs(dir)\n\n\t\tout_dir = get_output_dir_for_arch(arch)\n\n\t\tfor p, binaries in sorted(arch_binaries.items()):\n\t\t\tif p in installset:\n\t\t\t\tif args.verbose:\n\t\t\t\t\tprint(\"DOWNLOADING BINARY: %s\" % p)\n\n\t\t\t\tnewest = max(\n\t\t\t\t\tbinaries,\n\t\t\t\t\tkey=lambda b:\n\t\t\t\t\t\tVersion(b.stanza['Version']))\n\t\t\t\tmanifest[(p, arch)] = newest\n\n\t\t\t\t#\n\t\t\t\t# Download the package and install it\n\t\t\t\t#\n\t\t\t\tcheck_path_traversal(newest.stanza['Filename'])\n\t\t\t\tfile_url = \"%s/%s\" % (\n\t\t\t\t\tnewest.apt_source.url,\n\t\t\t\t\tnewest.stanza['Filename'],\n\t\t\t\t)\n\t\t\t\tdest_deb = os.path.join(\n\t\t\t\t\tdir,\n\t\t\t\t\tos.path.basename(newest.stanza['Filename']),\n\t\t\t\t)\n\t\t\t\tif not download_file(file_url, dest_deb):\n\t\t\t\t\tskipped += 1\n\t\t\t\tinstall_deb(\n\t\t\t\t\tos.path.splitext(\n\t\t\t\t\t\tos.path.basename(\n\t\t\t\t\t\t\tnewest.stanza['Filename']\n\t\t\t\t\t\t)\n\t\t\t\t\t)[0],\n\t\t\t\t\tdest_deb,\n\t\t\t\t\tstr(out_dir)\n\t\t\t\t)\n\t\t\t\tinstallset.remove(p)\n\n\t\tprune_files(out_dir)\n\n\t\tfor p in installset:\n\t\t\t#\n\t\t\t# There was a binary package in the list to be installed that is not in the repo\n\t\t\t#\n\t\t\te = \"ERROR: Package %s not found in Packages files\\n\" % p\n\t\t\tsys.stderr.write(e)\n\n\t\tif installset and args.strict:\n\t\t\traise SystemExit('Not all binary packages were found')\n\n\t\t# Combine basically all directories, except for {usr/,}{s,}bin\n\t\t# which collides (see\n\t\t# templates/scripts/check-runtime-conflicts.sh) and installed\n\t\t# which is only metadata anyway\n\t\tfor pattern in ('*', 'usr/*'):\n\t\t\tfor dir in glob.glob(str(out_dir / pattern)):\n\t\t\t\tif dir.endswith(('/bin', '/sbin', '/usr')):\n\t\t\t\t\t# Don't merge bin, sbin - they\n\t\t\t\t\t# will definitely collide.\n\t\t\t\t\t# Don't merge all of usr - we merge its\n\t\t\t\t\t# subdirectories instead, because we\n\t\t\t\t\t# want to skip usr/bin and usr/sbin.\n\t\t\t\t\tcontinue\n\n\t\t\t\tfor (dirpath, dirnames, filenames) in os.walk(dir):\n\t\t\t\t\trelative_path = os.path.relpath(\n\t\t\t\t\t\tdirpath,\n\t\t\t\t\t\tstr(out_dir),\n\t\t\t\t\t)\n\n\t\t\t\t\tfor member in dirnames:\n\t\t\t\t\t\tmerged = os.path.join(\n\t\t\t\t\t\t\targs.output,\n\t\t\t\t\t\t\trelative_path,\n\t\t\t\t\t\t\tmember,\n\t\t\t\t\t\t)\n\t\t\t\t\t\tos.makedirs(merged, exist_ok=True)\n\n\t\t\t\t\tfor member in filenames:\n\t\t\t\t\t\tsource = os.path.join(\n\t\t\t\t\t\t\tdirpath,\n\t\t\t\t\t\t\tmember,\n\t\t\t\t\t\t)\n\t\t\t\t\t\tmerged = os.path.join(\n\t\t\t\t\t\t\targs.output,\n\t\t\t\t\t\t\trelative_path,\n\t\t\t\t\t\t\tmember,\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif os.path.exists(merged):\n\t\t\t\t\t\t\tif not keep_only_primary_arch(relative_path):\n\t\t\t\t\t\t\t\twarn_if_different(source, merged)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tos.makedirs(os.path.dirname(merged), exist_ok=True)\n\t\t\t\t\t\t\tshutil.move(source, merged)\n\n\t\t\t\t# Replace amd64/usr/lib with a symlink to\n\t\t\t\t# ../usr/lib, etc.\n\t\t\t\trelative_path = os.path.relpath(\n\t\t\t\t\tdir,\n\t\t\t\t\tstr(out_dir),\n\t\t\t\t)\n\t\t\t\tmerged = os.path.join(\n\t\t\t\t\targs.output,\n\t\t\t\t\trelative_path,\n\t\t\t\t)\n\t\t\t\tshutil.rmtree(dir)\n\t\t\t\tos.symlink(\n\t\t\t\t\tos.path.join(\n\t\t\t\t\t\t'../' * (relative_path.count('/') + 1),\n\t\t\t\t\t\trelative_path,\n\t\t\t\t\t),\n\t\t\t\t\tdir,\n\t\t\t\t)\n\n\t\tfor pattern in ('bin/{}-*', 'usr/bin/{}-*'):\n\t\t\tfor exe in glob.glob(str(out_dir / pattern.format(ARCHITECTURES[arch]))):\n\t\t\t\t# Populate OUTPUT/usr/bin with symlinks\n\t\t\t\t# to OUTPUT/amd64/[usr/]bin/x86_64-linux-gnu-*\n\t\t\t\t# and OUTPUT/i386/[usr/]bin/i386-linux-gnu-*\n\t\t\t\tos.makedirs(os.path.join(args.output, 'usr', 'bin'), exist_ok=True)\n\t\t\t\trelative_path = os.path.relpath(exe, args.output)\n\t\t\t\tos.symlink(\n\t\t\t\t\tos.path.join('..', '..', relative_path),\n\t\t\t\t\tos.path.join(\n\t\t\t\t\t\targs.output, 'usr', 'bin',\n\t\t\t\t\t\tos.path.basename(exe),\n\t\t\t\t\t)\n\t\t\t\t)\n\n\tout_dir = Path(args.output)\n\n\t# We want some executables to be in the PATH for apps/games, but not\n\t# for Steam components, to avoid a cyclic dependency.\n\t(out_dir / 'game-bin').mkdir(exist_ok=True, mode=0o755, parents=True)\n\n\tfor exe, name in (\n\t\t('usr/bin/steam-runtime-steam-remote', 'steam'),\n\t\t('usr/bin/steam-runtime-urlopen', 'xdg-open'),\n\t\t# TODO: Maybe consider this too?\n\t\t# ('usr/libexec/flatpak-xdg-utils/xdg-email', 'xdg-email'),\n\t):\n\t\tif (out_dir / exe).exists():\n\t\t\t(out_dir / 'game-bin' / name).symlink_to('../' + exe)\n\t\telif (out_dir / architectures[0] / exe).exists():\n\t\t\t(out_dir / 'game-bin' / name).symlink_to(\n\t\t\t\t'../%s/%s' % (architectures[0], exe)\n\t\t\t)\n\n\tif skipped > 0:\n\t\tprint(\"Skipped downloading %i file(s) that were already present.\" % skipped)\n\n\ndef prune_files(directory: Path) -> None:\n\t\"\"\"Remove files that are considered to be unnecessary\"\"\"\n\n\tusr_share = directory / 'usr' / 'share'\n\tdoc = usr_share / 'doc'\n\tpaths: list[Path] = [\n\t\t# Nvidia cg toolkit manuals, tutorials and documentation\n\t\tdoc / 'nvidia-cg-toolkit' / 'html',\n\t\t*doc.glob('nvidia-cg-toolkit/*.pdf.gz'),\n\t\t# Sample code\n\t\t*doc.glob('**/examples'),\n\t\t# Debian bug reporting scripts\n\t\tusr_share / 'bug',\n\t\t# Debian documentation metadata\n\t\tusr_share / 'doc-base',\n\t\t# Debian QA metadata\n\t\tusr_share / 'lintian',\n\t\t# Programs and utilities manuals\n\t\tusr_share / 'man',\n\t\t# Remove the localized messages that are likely never going to be used.\n\t\t# Keep only \"en\", because that's the default language we are using.\n\t\t*[x for x in usr_share.glob('locale/*') if x.name != 'en'],\n\t]\n\n\tfor path in paths:\n\t\tif path.is_dir():\n\t\t\tshutil.rmtree(path)\n\t\telse:\n\t\t\tpath.unlink(missing_ok=True)\n\n\ndef install_deb (basename, deb, dest_dir):\n\tif args.verbose:\n\t\tprint('Unpacking %s into %s' % (deb, dest_dir))\n\tcheck_path_traversal(basename)\n\tinstalltag_dir=os.path.join(dest_dir, \"installed\")\n\tif not os.access(installtag_dir, os.W_OK):\n\t\tos.makedirs(installtag_dir)\n\n\t#\n\t# Write the tag file and checksum to the 'installed' subdirectory\n\t#\n\twith open(os.path.join(installtag_dir, basename), \"w\") as f:\n\t\tsubprocess.check_call(['dpkg-deb', '-c', deb], stdout=f)\n\twith open(os.path.join(installtag_dir, basename + \".md5\"), \"w\") as f:\n\t\tos.chdir(os.path.dirname(deb))\n\t\tsubprocess.check_call(['md5sum', os.path.basename(deb)], stdout=f)\n\n\t#\n\t# Unpack the package into the dest_dir\n\t#\n\tos.chdir(top)\n\tsubprocess.check_call(['dpkg-deb', '-x', deb, dest_dir])\n\n\ndef install_symbols(dbgsym_by_arch, binarylist, manifest):\n\tskipped = 0\n\tfor arch, arch_binaries in sorted(dbgsym_by_arch.items()):\n\n\t\t#\n\t\t# Create the destination directory if necessary\n\t\t#\n\t\tdir = os.path.join(top,destdir, \"symbols\", arch)\n\t\tif not os.access(dir, os.W_OK):\n\t\t\tos.makedirs(dir)\n\n\t\tout_dir = get_output_dir_for_arch(arch)\n\n\t\tfor p, binaries in sorted(arch_binaries.items()):\n\t\t\tif not p.endswith('-dbgsym'):\n\t\t\t\t# not a detached debug symbol package\n\t\t\t\tcontinue\n\n\t\t\t# If p is libfoo2-dbgsym, then parent_name is libfoo2.\n\t\t\tparent_name = p[:-len('-dbgsym')]\n\t\t\tparent = manifest.get((parent_name, arch))\n\n\t\t\t# We only download detached debug symbols for\n\t\t\t# packages that we already installed for the\n\t\t\t# corresponding architecture\n\t\t\tif parent is not None:\n\t\t\t\t# Find a matching version if we can\n\t\t\t\ttried = []\n\n\t\t\t\tfor b in binaries:\n\t\t\t\t\tif b.version == parent.version:\n\t\t\t\t\t\tdbgsym = b\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\ttried.append(b.version)\n\t\t\t\telse:\n\t\t\t\t\t# There's no point in installing\n\t\t\t\t\t# detached debug symbols if they don't\n\t\t\t\t\t# match\n\t\t\t\t\ttried.sort()\n\t\t\t\t\tsys.stderr.write(\n\t\t\t\t\t\t'WARNING: Debug symbol package '\n\t\t\t\t\t\t'%s not found at version %s '\n\t\t\t\t\t\t'(available: %s)\\n' % (\n\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\tparent.version,\n\t\t\t\t\t\t\t', '.join(tried),\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\tcontinue\n\n\t\t\t\tmanifest[(p, arch)] = dbgsym\n\n\t\t\t\tif args.verbose:\n\t\t\t\t\tprint(\"DOWNLOADING SYMBOLS: %s\" % p)\n\t\t\t\t#\n\t\t\t\t# Download the package and install it\n\t\t\t\t#\n\t\t\t\tcheck_path_traversal(dbgsym.stanza['Filename'])\n\t\t\t\tfile_url = \"%s/%s\" % (\n\t\t\t\t\tdbgsym.apt_source.url,\n\t\t\t\t\tdbgsym.stanza['Filename'],\n\t\t\t\t)\n\t\t\t\tdest_deb = os.path.join(\n\t\t\t\t\tdir,\n\t\t\t\t\tos.path.basename(\n\t\t\t\t\t\tdbgsym.stanza['Filename'])\n\t\t\t\t)\n\t\t\t\tif not download_file(file_url, dest_deb):\n\t\t\t\t\tskipped += 1\n\t\t\t\tinstall_deb(\n\t\t\t\t\tos.path.splitext(\n\t\t\t\t\t\tos.path.basename(\n\t\t\t\t\t\t\tdbgsym.stanza['Filename'])\n\t\t\t\t\t)[0],\n\t\t\t\t\tdest_deb,\n\t\t\t\t\tstr(out_dir)\n\t\t\t\t)\n\n\t\tprune_files(out_dir)\n\n\tif skipped > 0:\n\t\tprint(\"Skipped downloading %i symbol deb(s) that were already present.\" % skipped)\n\n\n# Walks through the files in the output directory and converts any absolute symlinks\n# to their relative equivalent\n#\ndef fix_symlinks ():\n\tfor dir, subdirs, files in os.walk(args.output):\n\t\tfor name in files:\n\t\t\tfilepath=os.path.join(dir,name)\n\t\t\tif os.path.islink(filepath):\n\t\t\t\ttarget = os.readlink(filepath)\n\t\t\t\tif os.path.isabs(target):\n\t\t\t\t\t#\n\t\t\t\t\t# compute the target of the symlink based on the 'root' of the runtime\n\t\t\t\t\t#\n\t\t\t\t\ttarget2 = os.path.join(args.output, target[1:])\n\n\t\t\t\t\t#\n\t\t\t\t\t# Set the new relative target path\n\t\t\t\t\t#\n\t\t\t\t\tos.unlink(filepath)\n\t\t\t\t\tos.symlink(os.path.relpath(target2,dir), filepath)\n\n\n# Creates the usr/lib/debug/.build-id/xx/xxxxxxxxx.debug symlink tree for all the debug\n# symbols\n#\ndef fix_debuglinks ():\n\tfor arch in args.architectures:\n\t\tfor dir, subdirs, files in os.walk(os.path.join(args.output, arch, \"usr/lib/debug\")):\n\t\t\tif \".build-id\" in subdirs:\n\t\t\t\tsubdirs.remove(\".build-id\")\t\t# don't recurse into .build-id directory we are creating\n\n\t\t\tfor file in files:\n\n\t\t\t\t#\n\t\t\t\t# scrape the output of readelf to find the buildid for this binary\n\t\t\t\t#\n\t\t\t\tp = subprocess.Popen([\"readelf\", '-n', os.path.join(dir,file)], stdout=subprocess.PIPE, universal_newlines=True)\n\t\t\t\tfor line in iter(p.stdout.readline, \"\"):\n\t\t\t\t\tm = re.search(r'Build ID: (\\w{2})(\\w+)',line)\n\t\t\t\t\tif m:\n\t\t\t\t\t\tcheck_path_traversal(m.group(1))\n\t\t\t\t\t\tcheck_path_traversal(m.group(2))\n\t\t\t\t\t\tlinkdir = os.path.join(args.output, arch, \"usr/lib/debug/.build-id\", m.group(1))\n\t\t\t\t\t\tif not os.access(linkdir, os.W_OK):\n\t\t\t\t\t\t\tos.makedirs(linkdir)\n\t\t\t\t\t\tlink = os.path.join(linkdir, m.group(2) + '.debug')\n\t\t\t\t\t\tif args.verbose:\n\t\t\t\t\t\t\tprint(\"SYMLINKING symbol file %s to %s\" % (link, os.path.relpath(os.path.join(dir,file),linkdir)))\n\t\t\t\t\t\tif os.path.lexists(link):\n\t\t\t\t\t\t\tos.unlink(link)\n\t\t\t\t\t\tos.symlink(os.path.relpath(os.path.join(dir,file), linkdir),link)\n\n\ndef write_manifests(manifest):\n\tdone = set()\n\n\t# manifest.deb822: The full Packages stanza for each installed package,\n\t# suitable for later analysis.\n\twith open(os.path.join(args.output, 'manifest.deb822.gz'), 'wb') as out:\n\t\twith gzip.GzipFile(\n\t\t\tfilename='',\n\t\t\tfileobj=out,\n\t\t\tmode='wb',\n\t\t\tmtime=0,\n\t\t) as writer:\n\t\t\tfor key, binary in sorted(manifest.items()):\n\t\t\t\tif key in done:\n\t\t\t\t\tcontinue\n\n\t\t\t\tif done:\n\t\t\t\t\twriter.write(b'\\n')\n\n\t\t\t\tbinary.stanza.dump(writer)\n\t\t\t\tdone.add(key)\n\n\t# manifest.txt: A summary of installed binary packages, as\n\t# a table of tab-separated values.\n\tlines = set()\n\n\tfor binary in manifest.values():\n\t\tlines.add('%s:%s\\t%s\\t%s\\t%s\\n' % (binary.name, binary.arch, binary.version, binary.stanza.get('Source', binary.name), binary.stanza.get('Installed-Size', '')))\n\n\twith open(os.path.join(args.output, 'manifest.txt'), 'w') as writer:\n\t\twriter.write('#Package[:Architecture]\\t#Version\\t#Source\\t#Installed-Size\\n')\n\n\t\tfor line in sorted(lines):\n\t\t\twriter.write(line)\n\n\t# built-using.txt: A summary of source packages that were embedded in\n\t# installed binary packages, as a table of tab-separated values.\n\tlines = set()\n\n\tfor binary in manifest.values():\n\t\tbuilt_using = binary.stanza.get('Built-Using', '')\n\n\t\tif not built_using:\n\t\t\tcontinue\n\n\t\trelations = built_using.split(',')\n\n\t\tfor relation in relations:\n\t\t\trelation = relation.replace(' ', '')\n\t\t\tassert '(=' in relation, relation\n\t\t\tp, v = relation.split('(=', 1)\n\t\t\tassert v[-1] == ')', relation\n\t\t\tv = v[:-1]\n\t\t\tlines.add('%s\\t%s\\t%s\\n' % (binary.name, p, v))\n\n\twith open(os.path.join(args.output, 'built-using.txt'), 'w') as writer:\n\t\twriter.write('#Built-Binary\\t#Built-Using-Source\\t#Built-Using-Version\\n')\n\n\t\tfor line in sorted(lines):\n\t\t\twriter.write(line)\n\n\t# non-packages.txt: A summary of files that were included other than\n\t# from a package. Currently this means the repository containing\n\t# this script and the default template scripts.\n\twith open(os.path.join(args.output, 'non-packages.txt'), 'w') as writer:\n\t\twriter.write('#Name\\t#Version\\t#Comment\\n')\n\n\t\ttry:\n\t\t\twith subprocess.Popen(\n\t\t\t\t[\n\t\t\t\t\t'git', 'describe',\n\t\t\t\t\t'--always',\n\t\t\t\t\t'--dirty',\n\t\t\t\t\t'--long',\n\t\t\t\t],\n\t\t\t\tcwd=os.path.dirname(__file__),\n\t\t\t\tstdout=subprocess.PIPE,\n\t\t\t\tuniversal_newlines=True,\n\t\t\t) as describe:\n\t\t\t\tdescription = describe.stdout.read().strip()\n\t\t\t\t# Deliberately ignoring exit status:\n\t\t\t\t# if git is missing or old we'll use 'unknown'\n\t\texcept FileNotFoundError:\n\t\t\tdescription = ''\n\n\t\twriter.write(\n\t\t\t'steam-runtime.git\\t{}\\t{}\\n'.format(\n\t\t\t\tdescription or 'unknown',\n\t\t\t\t'# build-runtime.py, run.sh, setup.sh etc.',\n\t\t\t)\n\t\t)\n\n\ndef normalize_tar_entry(entry):\n\t# type: (tarfile.TarInfo) -> tarfile.TarInfo\n\tif args.verbose:\n\t\tprint(entry.name)\n\n\tentry.uid = 65534\n\tentry.gid = 65534\n\n\tif entry.mtime > reference_timestamp:\n\t\tentry.mtime = reference_timestamp\n\n\tentry.uname = 'nobody'\n\tentry.gname = 'nogroup'\n\n\treturn entry\n\n\n# Create files u=rwX,go=rX by default\nos.umask(0o022)\n\nargs = parse_args()\nif args.verbose:\n\tfor property, value in sorted(vars(args).items()):\n\t\tprint(\"\\t\", property, \": \", value)\n\napt_sources = [\n\tAptSource('deb', args.repo, args.suite, ('main',)),\n\tAptSource('deb-src', args.repo, args.suite, ('main',)),\n]\nseen_apt_lines = set()\t\t# type: typing.Set[str]\n\nif args.suite in ('heavy', 'heavy_beta') and not args.upstream_apt_sources:\n\targs.upstream_apt_sources = [\n\t\t'both https://deb.debian.org/debian jessie main',\n\t\t'both https://deb.debian.org/debian-security jessie/updates main',\n\t]\n\nfor line in list(args.upstream_apt_sources) + list(args.extra_apt_sources):\n\tif line in seen_apt_lines:\n\t\tcontinue\n\n\tseen_apt_lines.add(line)\n\ttrusted=False\n\ttokens = line.split()\n\n\tif len(tokens) < 4:\n\t\traise ValueError(\n\t\t\t'--extra-apt-source argument must be in the form '\n\t\t\t'\"deb https://URL SUITE COMPONENT [COMPONENT...]\"')\n\n\tif tokens[0] not in ('deb', 'deb-src', 'both'):\n\t\traise ValueError(\n\t\t\t'--extra-apt-source argument must start with '\n\t\t\t'\"deb \", \"deb-src \" or \"both \"')\n\n\tif tokens[1] == '[trusted=yes]':\n\t\ttrusted=True\n\t\ttokens = [tokens[0]] + tokens[2:]\n\telif tokens[1].startswith('['):\n\t\traise ValueError(\n\t\t\t'--extra-apt-source does not support [opt=value] '\n\t\t\t'syntax, except for [trusted=yes]')\n\n\tif tokens[0] == 'both':\n\t\tapt_sources.append(\n\t\t\tAptSource(\n\t\t\t\t'deb', tokens[1], tokens[2], tokens[3:],\n\t\t\t\ttrusted=trusted,\n\t\t\t)\n\t\t)\n\t\tapt_sources.append(\n\t\t\tAptSource(\n\t\t\t\t'deb-src', tokens[1], tokens[2], tokens[3:],\n\t\t\t\ttrusted=trusted,\n\t\t\t)\n\t\t)\n\telse:\n\t\tapt_sources.append(\n\t\t\tAptSource(\n\t\t\t\ttokens[0], tokens[1], tokens[2], tokens[3:],\n\t\t\t\ttrusted=trusted,\n\t\t\t)\n\t\t)\n\ntimestamps = {}\n\nfor source in apt_sources:\n\twith urlopen(source.release_url) as release_file:\n\t\trelease_info = deb822.Deb822(release_file)\n\t\ttry:\n\t\t\ttimestamps[source] = calendar.timegm(time.strptime(\n\t\t\t\trelease_info['date'],\n\t\t\t\t'%a, %d %b %Y %H:%M:%S %Z',\n\t\t\t))\n\t\texcept (KeyError, ValueError):\n\t\t\ttimestamps[source] = 0\n\nif 'SOURCE_DATE_EPOCH' in os.environ:\n\treference_timestamp = int(os.environ['SOURCE_DATE_EPOCH'])\nelse:\n\treference_timestamp = max(timestamps.values())\n\nif args.set_name is not None:\n\tname = args.set_name\nelse:\n\tname = 'steam-runtime'\n\n\tif not args.official:\n\t\tname = 'unofficial-' + name\n\n\tif apt_sources[0].suite == 'scout_beta':\n\t\tname = '%s-beta' % name\n\telif apt_sources[0].suite != 'scout':\n\t\tname = '%s-%s' % (name, apt_sources[0].suite)\n\n\tif args.symbols:\n\t\tname += '-sym'\n\n\tif args.source:\n\t\tname += '-src'\n\n\tif args.debug:\n\t\tname += '-debug'\n\telse:\n\t\tname += '-release'\n\nif args.set_version is not None:\n\tversion = args.set_version\nelse:\n\tversion = time.strftime('snapshot-%Y%m%d-%H%M%SZ', time.gmtime())\n\nname_version = '%s_%s' % (name, version)\n\nif args.dump_options:\n\tdump = vars(args)\n\tdump['name'] = name\n\tdump['version'] = version\n\tdump['name_version'] = name_version\n\tdump['reference_timestamp'] = reference_timestamp\n\tdump['apt_sources'] = []\n\tfor source in apt_sources:\n\t\tdump['apt_sources'].append(str(source))\n\timport json\n\tjson.dump(dump, sys.stdout, indent=4, sort_keys=True)\n\tsys.stdout.write('\\n')\n\tsys.exit(0)\n\ntmpdir = tempfile.mkdtemp(prefix='build-runtime-')\n\nif args.output is None:\n\targs.output = os.path.join(tmpdir, 'root')\n\n# Populate runtime from template\nshutil.copytree(args.templates, args.output, symlinks=True)\n\nwith open(os.path.join(args.output, 'version.txt'), 'w') as writer:\n\twriter.write('%s\\n' % name_version)\n\nif args.debug_url is None:\n\tif args.suite in ('scout', 'scout_beta'):\n\t\targs.debug_url = 'https://repo.steampowered.com/steamrt-images-scout/snapshots/'\n\telif args.suite in ('heavy', 'heavy_beta'):\n\t\targs.debug_url = 'https://repo.steampowered.com/steamrt-images-heavy/snapshots/'\n\nif args.debug_url:\n\t# Note where people can get the debug version of this runtime\n\tfor base in ('README.txt', 'COPYING'):\n\t\twith open(\n\t\t\tos.path.join(args.templates, base)\n\t\t) as reader:\n\t\t\twith open(\n\t\t\t\tos.path.join(args.output, base + '.new'), 'w'\n\t\t\t) as writer:\n\t\t\t\tfor line in reader:\n\t\t\t\t\tline = re.sub(\n\t\t\t\t\t\tr'https?://repo\\.steampowered\\.com/PLACEHOLDER.*$',\n\t\t\t\t\t\targs.debug_url, line)\n\t\t\t\t\twriter.write(line)\n\n\t\tos.rename(\n\t\t\tos.path.join(args.output, base + '.new'),\n\t\t\tos.path.join(args.output, base),\n\t\t)\n\n# Process packages.txt to get the list of source and binary packages\nsources_from_lists = set()\t\t# type: typing.Set[str]\nbinaries_from_lists = set()\t\t# type: typing.Set[str]\n\nprint(\"Creating Steam Runtime in %s\" % args.output)\n\nfor packages_from in args.packages_from:\n\twith open(packages_from) as f:\n\t\tfor line in f:\n\t\t\tif line[0] != '#':\n\t\t\t\ttoks = line.split()\n\t\t\t\tif len(toks) > 1:\n\t\t\t\t\tsources_from_lists.add(toks[0])\n\t\t\t\t\tbinaries_from_lists.update(toks[1:])\n\n# remove development packages for end-user runtime\nif not args.debug:\n\tbinaries_from_lists -= {x for x in binaries_from_lists if re.search('-dbg$|-dev$|-multidev$',x)}\n\n# {('libfoo2', 'amd64'): Binary for libfoo2_1.2-3_amd64}\nmanifest = {}\t\t# type: typing.Dict[typing.Tuple[str, str], Binary]\n\nbinaries_by_arch = list_binaries(apt_sources)\n\nsources_from_apt, binaries_from_apt = expand_metapackages(\n\targs.architectures,\n\tbinaries_by_arch,\n\targs.metapackages,\n)\n\nif args.packages_from and args.metapackages:\n\tcheck_consistency(binaries_from_apt, binaries_from_lists)\n\nbinary_pkgs = {}\nsource_pkgs = set(sources_from_lists)\n\nfor arch in binaries_by_arch:\n\tbinary_pkgs[arch] = binaries_from_apt[arch] | binaries_from_lists\n\tsource_pkgs |= sources_from_apt\n\ninstall_binaries(args.architectures, binaries_by_arch, binary_pkgs, manifest)\n\nif args.source:\n\tinstall_sources(apt_sources, source_pkgs)\n\nif args.symbols:\n\tdbgsym_by_arch = list_binaries(apt_sources, dbgsym=True)\n\tinstall_symbols(dbgsym_by_arch, binary_pkgs, manifest)\n\tfix_debuglinks()\n\nfix_symlinks()\n\nwrite_manifests(manifest)\n\nprint(\"Normalizing permissions...\")\nsubprocess.check_call([\n\t'chmod', '--changes', 'u=rwX,go=rX', '--', args.output,\n])\n\nif args.archive is not None:\n\text = '.tar.' + args.compression\n\n\tif args.compression == 'none':\n\t\text = '.tar'\n\t\tcompressor_args = ['cat']\n\telif args.compression == 'xz':\n\t\tcompressor_args = ['xz', '-v']\n\telif args.compression == 'gz':\n\t\tcompressor_args = ['gzip', '-nc']\n\telif args.compression == 'bz2':\n\t\tcompressor_args = ['bzip2', '-c']\n\n\tif os.path.isdir(args.archive) or args.archive.endswith('/'):\n\t\tarchive_basename = name_version\t\t# type: typing.Optional[str]\n\t\tarchive_dir = args.archive\n\t\tarchive = os.path.join(archive_dir, archive_basename + ext)\n\t\tmake_latest_symlink = (version != 'latest')\n\telif args.archive.endswith('.*'):\n\t\tarchive_basename = os.path.basename(args.archive[:-2])\n\t\tarchive_dir = os.path.dirname(args.archive)\n\t\tarchive = os.path.join(archive_dir, archive_basename + ext)\n\t\tmake_latest_symlink = False\n\telse:\n\t\tarchive = args.archive\n\t\tarchive_basename = None\n\t\tarchive_dir = None\n\t\tmake_latest_symlink = False\n\n\ttry:\n\t\tos.makedirs(os.path.dirname(archive) or '.', 0o755)\n\texcept OSError as e:\n\t\tif e.errno != errno.EEXIST:\n\t\t\traise\n\n\tprint(\"Creating archive %s...\" % archive)\n\n\twith open(archive, 'wb') as archive_writer, subprocess.Popen(\n\t\tcompressor_args,\n\t\tstdin=subprocess.PIPE,\n\t\tstdout=archive_writer,\n\t) as compressor, tarfile.open(\n\t\tarchive,\n\t\tmode='w|',\n\t\tformat=tarfile.GNU_FORMAT,\n\t\tfileobj=compressor.stdin,\n\t) as archiver:\n\t\tmembers = []\n\n\t\tfor dir_path, dirs, files in os.walk(\n\t\t\targs.output,\n\t\t\ttopdown=True,\n\t\t\tfollowlinks=False,\n\t\t):\n\t\t\trel_dir_path = os.path.relpath(\n\t\t\t\tdir_path, args.output)\n\n\t\t\tif rel_dir_path != '.' and not rel_dir_path.startswith('./'):\n\t\t\t\trel_dir_path = './' + rel_dir_path\n\n\t\t\tfor member in dirs:\n\t\t\t\tmembers.append(\n\t\t\t\t\tos.path.join(rel_dir_path, member))\n\n\t\t\tfor member in files:\n\t\t\t\tmembers.append(\n\t\t\t\t\tos.path.join(rel_dir_path, member))\n\n\t\tfor member in sorted(members):\n\t\t\tarchiver.add(\n\t\t\t\tos.path.join(args.output, member),\n\t\t\t\tarcname=os.path.normpath(\n\t\t\t\t\tos.path.join(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tmember,\n\t\t\t\t\t)),\n\t\t\t\trecursive=False,\n\t\t\t\tfilter=normalize_tar_entry,\n\t\t\t)\n\n\tprint(\"Creating archive checksum %s.checksum...\" % archive)\n\tarchive_md5 = hashlib.md5()\n\n\twith open(archive, 'rb') as archive_reader:\n\t\twhile True:\n\t\t\tblob = archive_reader.read(ONE_MEGABYTE)\n\n\t\t\tif not blob:\n\t\t\t\tbreak\n\n\t\t\tarchive_md5.update(blob)\n\n\twith open(archive + '.checksum', 'w') as writer:\n\t\twriter.write('%s  %s\\n' % (\n\t\t\tarchive_md5.hexdigest(), os.path.basename(archive)\n\t\t))\n\n\tif archive_dir is not None:\n\t\tassert archive_basename is not None\n\t\tprint(\"Copying manifest files to %s...\" % archive_dir)\n\n\t\twith open(\n\t\t\tos.path.join(\n\t\t\t\tarchive_dir,\n\t\t\t\tarchive_basename + '.sources.list'),\n\t\t\t'w'\n\t\t) as writer:\n\t\t\tfor apt_source in apt_sources:\n\t\t\t\tif timestamps[apt_source] > 0:\n\t\t\t\t\twriter.write(\n\t\t\t\t\t\ttime.strftime(\n\t\t\t\t\t\t\t'# as of %Y-%m-%d %H:%M:%S\\n',\n\t\t\t\t\t\t\ttime.gmtime(\n\t\t\t\t\t\t\t\ttimestamps[apt_source]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\t\t\twriter.write('%s\\n' % apt_source)\n\n\t\tshutil.copy(\n\t\t\tos.path.join(args.output, 'manifest.txt'),\n\t\t\tos.path.join(\n\t\t\t\tarchive_dir, archive_basename + '.manifest.txt'),\n\t\t)\n\t\tshutil.copy(\n\t\t\tos.path.join(args.output, 'built-using.txt'),\n\t\t\tos.path.join(\n\t\t\t\tarchive_dir, archive_basename + '.built-using.txt'),\n\t\t)\n\t\tshutil.copy(\n\t\t\tos.path.join(args.output, 'manifest.deb822.gz'),\n\t\t\tos.path.join(\n\t\t\t\tarchive_dir,\n\t\t\t\tarchive_basename + '.manifest.deb822.gz'),\n\t\t)\n\t\tif args.source:\n\t\t\tshutil.copy(\n\t\t\t\tos.path.join(\n\t\t\t\t\targs.output,\n\t\t\t\t\t'source',\n\t\t\t\t\t'sources.txt'),\n\t\t\t\tos.path.join(\n\t\t\t\t\tarchive_dir,\n\t\t\t\t\tarchive_basename + '.sources.txt'),\n\t\t\t)\n\t\t\tshutil.copy(\n\t\t\t\tos.path.join(\n\t\t\t\t\targs.output,\n\t\t\t\t\t'source',\n\t\t\t\t\t'sources.deb822.gz'),\n\t\t\t\tos.path.join(\n\t\t\t\t\tarchive_dir,\n\t\t\t\t\tarchive_basename + '.sources.deb822.gz'),\n\t\t\t)\n\n\t\tshutil.copy(\n\t\t\tos.path.join(args.output, 'version.txt'),\n\t\t\tos.path.join(\n\t\t\t\tarchive_dir, archive_basename + '.version.txt'),\n\t\t)\n\n\t\tscript = os.path.join(args.output, 'scripts', 'switch-runtime.sh')\n\n\t\tif os.path.exists(script):\n\t\t\tshutil.copy(\n\t\t\t\tscript,\n\t\t\t\tos.path.join(archive_dir, archive_basename + '.sh'),\n\t\t\t)\n\n\tif make_latest_symlink:\n\t\tprint(\"Creating symlink %s_latest%s...\" % (name, ext))\n\t\tsymlink = os.path.join(archive_dir, name + '_latest' + ext)\n\n\t\ttry:\n\t\t\tos.remove(symlink)\n\t\texcept OSError as e:\n\t\t\tif e.errno != errno.ENOENT:\n\t\t\t\traise\n\n\t\ttry:\n\t\t\tos.remove(symlink + '.checksum')\n\t\texcept OSError as e:\n\t\t\tif e.errno != errno.ENOENT:\n\t\t\t\traise\n\n\t\tos.symlink(os.path.basename(archive), symlink)\n\t\tos.symlink(\n\t\t\tos.path.basename(archive) + '.checksum',\n\t\t\tsymlink + '.checksum')\n\n\tif args.split:\n\t\twith open(archive, 'rb') as archive_reader:\n\t\t\tpart = 0\n\t\t\tposition = 0\n\t\t\tpart_writer = open(args.split + ext + '.part0', 'wb')\n\n\t\t\twhile True:\n\t\t\t\tblob = archive_reader.read(ONE_MEGABYTE)\n\n\t\t\t\tif not blob:\n\t\t\t\t\tbreak\n\n\t\t\t\tif position >= SPLIT_MEGABYTES:\n\t\t\t\t\tpart += 1\n\t\t\t\t\tposition -= SPLIT_MEGABYTES\n\t\t\t\t\tpart_writer.close()\n\t\t\t\t\tpart_writer = open(\n\t\t\t\t\t\t'%s%s.part%d' % (\n\t\t\t\t\t\t\targs.split, ext, part\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'wb')\n\n\t\t\t\tpart_writer.write(blob)\n\t\t\t\tposition += 1\n\n\t\t\twhile part < MIN_PARTS - 1:\n\t\t\t\tpart += 1\n\t\t\t\tpart_writer.close()\n\t\t\t\tpart_writer = open(\n\t\t\t\t\t'%s%s.part%d' % (\n\t\t\t\t\t\targs.split, ext, part\n\t\t\t\t\t),\n\t\t\t\t\t'wb')\n\n\t\t\tpart_writer.close()\n\n\t\twith open(args.split + '.checksum', 'w') as writer:\n\t\t\twriter.write('%s  %s%s\\n' % (\n\t\t\t\tarchive_md5.hexdigest(),\n\t\t\t\tos.path.basename(args.split),\n\t\t\t\text,\n\t\t\t))\n\nshutil.rmtree(tmpdir)\n\n# vi: set noexpandtab:\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup_chroot.sh",
          "type": "blob",
          "size": 7.017578125,
          "content": "#!/usr/bin/env bash\n\nSCRIPT=\"$(readlink -f \"$0\")\"\nSCRIPTNAME=\"$(basename \"$SCRIPT\")\"\nSCRIPT_DIR=\"$(dirname \"$SCRIPT\")\"\nLOGFILE=\"\"\nCHROOT_PREFIX=\"steamrt_\"\nCHROOT_DIR=\"/var/chroots\"\nCHROOT_NAME=\"\"\n\n# exit on any script line that fails\nset -o errexit\n# bail on any unitialized variable reads\nset -o nounset\n# bail on failing commands before last pipe\nset -o pipefail\n\n# Output helpers\nCOLOR_OFF=\"\"\nCOLOR_ON=\"\"\nif [[ $(tput colors 2>/dev/null || echo 0) -gt 0 ]]; then\n  COLOR_ON=$'\\e[93;1m'\n  COLOR_OFF=$'\\e[0m'\nfi\n\nFORCE=0\n\nsh_quote ()\n{\n  local quoted\n  if [ $# -gt 0 ]; then\n    quoted=\"$(printf '%q ' \"$@\")\"\n    echo \"${quoted:0:-1}\"\n  fi\n}\n\nprebuild_chroot()\n{\n\tlocal name\n\n\t# install some packages\n\techo -e \"\\\\n${COLOR_ON}Installing schroot...${COLOR_OFF}\"\n\tsudo -E apt-get install -y schroot\n\n\t# Check if there are any active schroot sessions right now and warn if so...\n\tschroot_list=$(schroot --list --all-sessions | head -n 1)\n\tif [ -n \"$schroot_list\" ]; then\n\t\ttput setaf 3\n\t\techo -e \"\\\\nWARNING: Schroot says you have a currently active session!\\\\n\"\n\t\ttput sgr0\n\t\techo \"  ${schroot_list}\"\n\t\techo \"\"\n\t\tif [ ${FORCE} -eq 0 ]; then\n\t\t\tread -r -p \"Are you sure you want to continue (y/n)? \"\n\t\t\tif [[ \"$REPLY\" != [Yy] ]]; then\n\t\t\t\techo -e \"Cancelled...\\\\n\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tSTEAM_RUNTIME_SPEW_WARNING=\n\tfor var in \"$@\"; do\n\t\tif [ -n \"$CHROOT_NAME\" ]; then\n\t\t\tname=\"$CHROOT_NAME\"\n\t\telse\n\t\t\tname=\"${CHROOT_PREFIX}${var/--/}\"\n\t\tfi\n\n\t\tdirname=\"${CHROOT_DIR}/${name}\"\n\t\tif [ -d \"${dirname}\" ]; then\n\t\t\ttput setaf 3\n\t\t\tSTEAM_RUNTIME_SPEW_WARNING=1\n\t\t\techo -e \"About to remove ${dirname} and re-install...\"\n\t\t\ttput sgr0\n\t\tfi\n\tdone\n\n\tif [[ \"$STEAM_RUNTIME_SPEW_WARNING\" == \"1\" ]]; then\n\t\tif [ ${FORCE} -eq 0 ]; then\n\t\t\tread -r -p \"  This ok (y/n)? \"\n\t\t\tif [[ \"$REPLY\" != [Yy] ]]; then\n\t\t\t\techo -e \"Cancelled...\\\\n\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\ncopy_apt_settings ()\n{\n\tlocal sysroot=\"$1\"\n\n\tif [ \"$1/\" -ef / ]; then\n\t\techo \"Internal error: sysroot $1 is the same file as the real root\" >&2\n\t\texit 1\n\tfi\n\n\t# Copy over proxy settings from host machine\n\techo -e \"\\\\n${COLOR_ON}Adding proxy info to chroot (if set)...${COLOR_OFF}\"\n\tset +o pipefail\n\tenv | grep -i \"_proxy=\" | grep -v PERSISTENT_HISTORY_LAST | xargs -i echo export {} | sudo tee \"$sysroot/etc/profile.d/steamrtproj.sh\"\n\tenv | grep -i \"_proxy=\" | grep -v PERSISTENT_HISTORY_LAST | xargs -i echo export {} | sudo tee -a \"$sysroot/etc/environment\"\n\tset -o pipefail\n\tsudo rm -rf \"$sysroot/etc/apt/apt.conf\"\n\tif [ -f /etc/apt/apt.conf ]; then sudo cp \"/etc/apt/apt.conf\" \"$sysroot/etc/apt\"; fi\n}\n\nuntar_chroot ()\n{\n\t# untar_chroot {--amd64 | --i386} TARBALL\n\t# Unpack a sysroot tarball for the specified architecture.\n\n\tcase \"$1\" in\n\t\t\"--i386\" )\n\t\t\tpkg=\"i386\"\n\t\t\tpersonality=\"linux32\"\n\t\t\t;;\n\t\t\"--amd64\" )\n\t\t\tpkg=\"amd64\"\n\t\t\tpersonality=\"linux\"\n\t\t\t;;\n\t\t* )\n\t\t\techo \"Error: Unrecognized argument: $1\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\n\tshift\n\n\tlocal tarball=\"$1\"\n\tlocal name\n\n\tif [ -n \"$CHROOT_NAME\" ]; then\n\t\tname=\"$CHROOT_NAME\"\n\telse\n\t\tname=\"${CHROOT_PREFIX}${pkg}\"\n\tfi\n\n\tlocal sysroot=\"${CHROOT_DIR}/${name}\"\n\n\t# blow away existing directories and recreate empty ones\n\techo -e \"\\\\n${COLOR_ON}Creating $sysroot...\"\n\tsudo rm -rf \"$sysroot\"\n\tsudo mkdir -p \"$sysroot\"\n\n\t# Create our schroot .conf file\n\techo -e \"\\\\n${COLOR_ON}Creating /etc/schroot/chroot.d/${name}.conf...${COLOR_OFF}\"\n\tprintf '[%s]\\ndescription=%s\\ndirectory=%s\\npersonality=%s\\ngroups=sudo\\nroot-groups=sudo\\npreserve-environment=true\\ntype=directory\\n' \"${name}\" \"${tarball##*/}\" \"${sysroot}\" \"${personality}\" | sudo tee \"/etc/schroot/chroot.d/${name}.conf\"\n\n\t# Create our chroot\n\techo -e \"\\\\n${COLOR_ON}Unpacking the chroot...${COLOR_OFF}\"\n\tsudo tar --auto-compress -C \"$sysroot\" -xf \"$tarball\"\n\n\tcopy_apt_settings \"$sysroot\"\n\n\t# Implement --extra-apt-source\n\tif [ -n \"${extra_apt_sources+set}\" ]; then\n\t\tfor line in \"${extra_apt_sources[@]}\"; do\n\t\t\tprintf '%s\\n' \"$line\"\n\t\tdone > \"$sysroot/etc/apt/sources.list.d/steamrt-extra.list\"\n\tfi\n\n\tif [ -n \"$(sudo find \"$sysroot\" -xdev '(' -uid +99 -o -gid +99 ')' -ls)\" ]; then\n\t\techo -e \"\\\\n${COLOR_ON}Warning: these files might have incorrect uid mapping${COLOR_OFF}\" >&2\n\t\tsudo find \"$sysroot\" -xdev '(' -uid +99 -o -gid +99 ')' -ls >&2\n\tfi\n}\n\n# https://stackoverflow.com/questions/64786/error-handling-in-bash\nfunction cleanup()\n{\n\techo -e \"\\\\nenv is:\\\\n$(env)\\\\n\"\n\techo \"ERROR: ${SCRIPTNAME} just hit error handler.\"\n\techo \"  BASH_COMMAND is \\\"${BASH_COMMAND}\\\"\"\n\techo \"  BASH_VERSION is $BASH_VERSION\"\n\techo \"  pwd is \\\"$(pwd)\\\"\"\n\techo \"  PATH is \\\"$PATH\\\"\"\n\techo \"\"\n\n\ttput setaf 3\n\techo \"A command returned error. See the logfile: ${LOGFILE}\"\n\ttput sgr0\n}\n\nusage()\n{\n\tif [ \"$1\" -ne 0 ]; then\n\t\texec >&2\n\tfi\n\n\techo \"Usage: $0 [--beta | --suite SUITE] [--name NAME] [--extra-apt-source 'deb http://MIRROR SUITE COMPONENT...'] [--output-dir <DIRNAME>] [--logfile FILE] --tarball TARBALL --i386|--amd64\"\n\texit \"$1\"\n}\n\nmain()\n{\n\tlocal getopt_temp\n\tgetopt_temp=\"$(getopt -o '' --long \\\n\t'force,amd64,beta,extra-apt-source:,i386,name:,output-dir:,logfile:,suite:,tarball:,help' \\\n\t-n \"$0\" -- \"$@\")\"\n\teval set -- \"$getopt_temp\"\n\tunset getopt_temp\n\n\tlocal arch=\n\tlocal -a setup_arguments=()\n\tlocal suite=scout\n\tlocal suite_suffix=\n\tlocal tarball=\n\n\t# Create a copy of the arguments\n\tlocal args=(\"$@\")\n\n\twhile [ \"$#\" -gt 0 ]; do\n\t\tcase \"$1\" in\n\t\t\t(--force)\n\t\t\t\tFORCE=1\n\t\t\t\tshift\n\t\t\t\t;;\n\n\t\t\t(--amd64|--i386)\n\t\t\t\tif [ -n \"$arch\" ] && [ \"$arch\" != \"$1\" ]; then\n\t\t\t\t\techo \"Error: $1 conflicts with $arch\" >&2\n\t\t\t\t\tusage 2\n\t\t\t\tfi\n\t\t\t\tarch=\"$1\"\n\t\t\t\tshift\n\t\t\t\t;;\n\n\t\t\t(--beta)\n\t\t\t\tsetup_arguments+=(--beta)\n\t\t\t\tsuite_suffix=_beta\n\t\t\t\tshift\n\t\t\t\t;;\n\n\t\t\t(--name)\n\t\t\t\tCHROOT_NAME=\"$2\"\n\t\t\t\tshift 2\n\t\t\t\t;;\n\n\t\t\t(--extra-apt-source)\n\t\t\t\tsetup_arguments+=(\"$1\" \"$2\")\n\t\t\t\tshift 2\n\t\t\t\t;;\n\n\t\t\t(--help)\n\t\t\t\tusage 0\n\t\t\t\t;;\n\n\t\t\t(--logfile)\n\t\t\t\tLOGFILE=\"$2\"\n\t\t\t\tshift 2\n\t\t\t\t;;\n\n\t\t\t(--output-dir)\n\t\t\t\tCHROOT_DIR=\"$2\"\n\t\t\t\tshift 2\n\t\t\t\t;;\n\n\t\t\t(--suite)\n\t\t\t\tsuite=\"$2\"\n\t\t\t\tsetup_arguments+=(--suite \"$2\")\n\t\t\t\tshift 2\n\t\t\t\t;;\n\n\t\t\t(--tarball)\n\t\t\t\ttarball=\"$2\"\n\t\t\t\tshift 2\n\t\t\t\t;;\n\n\t\t\t(--)\n\t\t\t\tshift\n\t\t\t\tbreak\n\t\t\t\t;;\n\n\t\t\t(-*)\n\t\t\t\tusage 2\n\t\t\t\t;;\n\n\t\t\t(*)\n\t\t\t\t# no non-option arguments are currently allowed\n\t\t\t\tusage 2\n\t\t\t\tbreak\n\t\t\t\t;;\n\t\tesac\n\tdone\n\n\t# Launch ourselves with script so we can time this and get a log file\n\tif [[ ! -v SETUP_CHROOT_LOGGING_STARTED ]]; then\n\t\tif command -v script >/dev/null; then\n\t\t\texport SETUP_CHROOT_LOGGING_STARTED=1\n\t\t\texport SHELL=/bin/bash\n\t\t\tif [ -z \"$LOGFILE\" ]; then\n\t\t\t\tLOGFILE=\"$(mktemp --tmpdir steam-runtime-setup-chroot-XXX.log)\"\n\t\t\tfi\n\t\t\tscript --return --command \"time $SCRIPT $(sh_quote \"${args[@]}\")\" \"${LOGFILE}\"\n\t\t\texit $?\n\t\telse\n\t\t\techo >&2 \"!! 'script' command not found, will not auto-generate a log file\"\n\t\t\t# Continue\n\t\tfi\n\tfi\n\n\tCHROOT_PREFIX=\"${CHROOT_PREFIX}${suite}${suite_suffix}_\"\n\n\tif [ -z \"$tarball\" ]; then\n\t\techo \"This script no longer bootstraps chroots from first principles.\" >&2\n\t\techo \"Use --tarball to provide a pre-prepared sysroot.\" >&2\n\t\tusage 2\n\tfi\n\n\tif [ -z \"$arch\" ]; then\n\t\tusage 2\n\tfi\n\n\t# Building root(s)\n\tprebuild_chroot \"$arch\"\n\ttrap cleanup EXIT\n\tuntar_chroot \"$arch\" \"$tarball\"\n\ttrap - EXIT\n\n\techo -e \"\\\\n${COLOR_ON}Done...${COLOR_OFF}\"\n}\n\nmain \"$@\"\n\n# vi: ts=4 sw=4 noexpandtab\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "ubuntu-archive-keyring.gpg",
          "type": "blob",
          "size": 12.0458984375,
          "content": null
        },
        {
          "name": "write-manifest",
          "type": "blob",
          "size": 3.689453125,
          "content": "#!/bin/bash\n\n# Copyright  2016-2017 Simon McVittie\n# Copyright  2017-2018 Collabora Ltd.\n#\n# SPDX-License-Identifier: MIT\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nset -e\nset -u\nset -o pipefail\n\nme=\"$(basename \"$0\")\"\ndebug=\n\nusage () {\n    local status=\"${1-2}\"\n\n    if [ \"$status\" -ne 0 ]; then\n        exec >&2\n    fi\n\n    echo \"$me: Usage\"\n    echo \"    $me SYSROOT\"\n    echo\n    echo \"Run this script as root.\"\n    exit \"$status\"\n}\n\ngetopt_temp=\"$(getopt -o '' --long \\\n    'help,debug' \\\n    -n \"$me\" -- \"$@\")\"\n\neval set -- \"$getopt_temp\"\nunset getopt_temp\n\nwhile [ \"$#\" -gt 0 ]; do\n    case \"$1\" in\n        (--debug)\n            debug=yes\n            shift\n            ;;\n\n        (--help)\n            usage 0\n            # not reached\n            ;;\n\n        (--)\n            shift\n            break\n            ;;\n\n       (-*)\n            echo \"$me: unknown option: $1\" >&2\n            usage 2\n            # not reached\n            ;;\n\n        (*)\n            break\n            ;;\n    esac\ndone\n\nif [ \"x$(id -u)\" != x0 ] || [ \"$#\" -ne 1 ]; then\n    usage 2\n    # not reached\nfi\n\nif [ -n \"$debug\" ]; then\n    set -x\nfi\n\nsysroot=\"$1\"\ncd \"$sysroot\"\n\nin_chroot () {\n    chroot \"$sysroot\" \"$@\"\n}\n\nexport DEBIAN_FRONTEND=noninteractive\n\nexec 3>\"$sysroot/usr/manifest.dpkg\"\n\nprintf '#Package[:Architecture]\\t#Version\\t#Source\\t#Installed-Size\\n' >&3\n\n# ${} escapes here are for dpkg-query, not sh\n# shellcheck disable=SC2016\ndpkg_version=\"$(in_chroot dpkg-query -W -f '${Version}' dpkg)\"\n\nif in_chroot dpkg --compare-versions \"$dpkg_version\" ge 1.16.2; then\n    # shellcheck disable=SC2016\n    in_chroot dpkg-query -W -f \\\n        '${binary:Package}\\t${Version}\\t${Source}\\t${Installed-Size}\\n' \\\n        | LC_ALL=C sort -u >&3\n    # shellcheck disable=SC2016\n    in_chroot dpkg-query -W -f '${binary:Package}\\n' \\\n        | LC_ALL=C sort -u \\\n        | in_chroot xargs -d '\\n' dpkg-query -s \\\n        | gzip -9nc \\\n        > \"$sysroot/usr/manifest.deb822.gz\"\nelse\n    # shellcheck disable=SC2016\n    in_chroot dpkg-query -W -f \\\n        '${Package}:${Architecture}\\t${Version}\\t${Source}\\t${Installed-Size}\\n' \\\n        | LC_ALL=C sort -u >&3\nfi\n\nexec 3>\"$sysroot/usr/manifest.dpkg.built-using\"\n\nprintf '#Built-Binary\\t#Built-Using-Source\\t#Built-Using-Version\\n' >&3\n\n# shellcheck disable=SC2016\nin_chroot dpkg-query -W -f '${Package}\\t${Built-Using}\\n' | perl -ne '\nchomp;\ndie \"Unable to parse dpkg-query output: $_\\n\" unless /^(\\S+)\\t(.*)$/;\nnext unless $2;\nmy $binary = $1;\nmy @using = split /,/, $2;\nnext unless @using;\nforeach my $using (@using) {\n    $using =~ s/ //g;\n    die \"Unable to parse Built-Using: $using\\n\"\n        unless $using =~ /^(\\S+)\\(=(\\S+)\\)$/;\n    print \"$binary\\t$1\\t$2\\n\";\n}\n' | LC_ALL=C sort -u >&3\n\n# vim:set sw=4 sts=4 et:\n"
        }
      ]
    }
  ]
}