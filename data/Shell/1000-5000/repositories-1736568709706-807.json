{
  "metadata": {
    "timestamp": 1736568709706,
    "page": 807,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "denilsonsa/prettyping",
      "stars": 1213,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0673828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Denilson Figueiredo de Sá\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.236328125,
          "content": "prettyping\n==========\n\n[Donation - buy me a coffee](https://denilson.sa.nom.br/donate.html)\n\n`prettyping` is a wrapper around the standard `ping` tool with the objective of\nmaking the output prettier, more colorful, more compact, and easier to read.\n\n`prettyping` runs the standard `ping` in the background and parses its output,\nshowing the ping responses in a *graphical* way at the terminal (by using\ncolors and Unicode characters).\n\n`prettyping` is written in `bash` and `awk`, and is reported to work on many\ndifferent systems (Linux, Mac OS X, BSD…), as well as running on different\nversions of `awk` (`gawk`, `mawk`, `nawk`, `busybox awk`).\n\nRead about the history of this project, as well as detailed information,\nscreenshots, videos at: <http://denilsonsa.github.io/prettyping/>\n\nRequirements\n------------\n\n* `bash` (tested on 4.20, should work on versions as old as 2008)\n* `awk` (either [gawk][], [mawk][], [nawk][] or [busybox awk][]; should work on\n  `gawk` versions as old as 2008; should probably work on any other awk\n  implementation)\n* `ping` (from `iputils`, or any other version that prints essentially the same\n  output, like Mac OS X ping or [oping][])\n* Optional dependency on `stty` or `tput` to auto-detect the terminal size.\n\nInstallation\n------------\n\n1. Download [prettyping][] script and save it anywhere.\n2. Make it executable: `chmod +x prettyping`\n\nThat's all! No root permission is required. You can save and run it from any\ndirectory. As long as your user can run `ping`, `bash` and `awk`, then\n`prettyping` will work.\n\nAlternatively, you can download the latest tarball from GitHub: [![Latest release](https://img.shields.io/github/release/denilsonsa/prettyping.svg)](https://github.com/denilsonsa/prettyping/releases/latest)\n\nFor people building a `prettyping` package (for any Linux distro or for Mac OS\nX), just install the `prettyping` script into `/usr/bin/`, or whatever\ndirectory is appropriate. No other file is necessary.\n\n[gawk]: https://www.gnu.org/software/gawk/\n[mawk]: https://invisible-island.net/mawk/\n[nawk]: https://github.com/onetrueawk/awk\n[busybox awk]: https://www.busybox.net/downloads/BusyBox.html#awk\n[oping]: http://verplant.org/liboping/\n[prettyping]: https://raw.githubusercontent.com/denilsonsa/prettyping/master/prettyping\n"
        },
        {
          "name": "mockping.sh",
          "type": "blob",
          "size": 2.35546875,
          "content": "#!/bin/bash\n#\n# This is just a mock ping program that reproduces the same output all the\n# time. It is used for testing/developing prettyping.\n\nsample_output() {\n\tcat << EOF\nPING registro.br (200.160.2.3) 56(84) bytes of data.\nRequest timeout for icmp_seq 1\n64 bytes from registro.br (200.160.2.3): icmp_seq=2 ttl=56 time=25.5 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=3 ttl=56 time=55.7 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=4 ttl=56 time=75.2 ms\nping: sendto: Network is down\nping: sendto: No route to host\nping: sendto: No route to host\nping: sendto: No route to host\nping: sendto: No route to host\nping: sendto: No route to host\nRequest timeout for icmp_seq 5\nRequest timeout for icmp_seq 6\nRequest timeout for icmp_seq 7\n64 bytes from registro.br (200.160.2.3): icmp_seq=8 ttl=56 time=123 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=9 ttl=56 time=149 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=10 ttl=56 time=183 ms\nRequest timeout for icmp_seq 11\nRequest timeout for icmp_seq 12\nRequest timeout for icmp_seq 13\n64 bytes from registro.br (200.160.2.3): icmp_seq=14 ttl=56 time=123 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=15 ttl=56 time=149 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=16 ttl=56 time=183 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=19 ttl=56 time=183 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=20 ttl=56 time=183 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=21 ttl=56 time=183 ms\nFrom 10.1.1.160 icmp_seq=22 Destination Host Unreachable\nFrom 10.1.1.160 icmp_seq=23 Destination Host Unreachable\nFrom 10.1.1.160 icmp_seq=24 Destination Host Unreachable\nFrom 10.1.1.160 icmp_seq=25 Destination Host Unreachable\nFrom 10.1.1.160 icmp_seq=26 Destination Host Unreachable\nFrom 10.1.1.160 icmp_seq=27 Destination Host Unreachable\nFrom 10.1.1.160 icmp_seq=28 Destination Host Unreachable\n64 bytes from registro.br (200.160.2.3): icmp_seq=29 ttl=56 time=183 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=30 ttl=56 time=183 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=31 ttl=56 time=183 ms\n64 bytes from registro.br (200.160.2.3): icmp_seq=32 ttl=56 time=183 ms\n\n--- registro.br ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2000ms\nrtt min/avg/max/mdev = 36.750/38.535/40.048/1.360 ms\nEOF\n}\n\nsample_output | while read line; do\n\techo -E \"$line\"\n\tsleep 0.25s\ndone\n"
        },
        {
          "name": "prettyping",
          "type": "blob",
          "size": 23.087890625,
          "content": "#!/usr/bin/env bash\n#\n# Written by Denilson Figueiredo de Sá <denilsonsa@gmail.com>\n# MIT license\n#\n# Requirements:\n# * bash (tested on 4.20, should work on older versions too)\n# * awk (works with GNU awk, nawk, busybox awk, mawk)\n# * ping (from iputils)\n#\n# More information:\n# https://denilsonsa.github.io/prettyping/\n# https://github.com/denilsonsa/prettyping\n# https://old.reddit.com/r/linux/comments/1op98a/prettypingsh_a_better_ui_for_watching_ping/\n# Third-party demonstration video: https://www.youtube.com/watch?v=ziEMY1BcikM\n\n# TODO: Test in original-awk:\n#       https://aur.archlinux.org/packages/original-awk\n#       https://sources.debian.org/src/original-awk/\n# TODO: Adjust how many items in the legend are printed based on the terminal width.\n#\n# TODO: Detect the following kinds of message and avoid printing it repeatedly.\n# From 192.168.1.11: icmp_seq=4 Destination Host Unreachable\n# Request timeout for icmp_seq 378\n#\n# TODO: Handle when a single message is spread over multiple lines. Specially,\n# like in this case: https://bitbucket.org/denilsonsa/small_scripts/issue/5\n#\n# TODO: Print the destination (also) at the bottom bar. Useful after leaving\n# the script running for quite some time.\n#\n# TODO: Print the destination as escape codes to xterm title.\n#\n# TODO: Print the current time in the beginning of each line.\n#\n# TODO: Implement audible ping.\n#\n# TODO: Autodetect the width of printf numbers, so they will always line up correctly.\n#\n# TODO: Test the behavior of this script upon receiving out-of-order packets, like these:\n#   https://web.archive.org/web/20130531083142/http://www.blug.linux.no/rfc1149/pinglogg.txt\n#\n# TODO? How will prettyping behave if it receives a duplicate response?\n\nprint_help() {\n\tcat << EOF\nUsage: $MYNAME [prettyping parameters] <standard ping parameters>\n\nThis script is a wrapper around the system's \"ping\" tool. It will substitute\neach ping response line by a colored character, giving a very compact overview\nof the ping responses.\n\nprettyping parameters:\n  --[no]color      Enable/disable color output. (default: enabled)\n  --[no]multicolor Enable/disable multi-color unicode output. Has no effect if\n                     either color or unicode is disabled. (default: enabled)\n  --[no]unicode    Enable/disable unicode characters. (default: enabled)\n  --[no]legend     Enable/disable the latency legend. (default: enabled)\n  --[no]terminal   Force the output designed to a terminal. (default: auto)\n  --last <n>       Use the last \"n\" pings at the statistics line. (default: 60)\n  --columns <n>    Override auto-detection of terminal dimensions.\n  --lines <n>      Override auto-detection of terminal dimensions.\n  --rttmin <n>     Minimum RTT represented in the unicode graph. (default: auto)\n  --rttmax <n>     Maximum RTT represented in the unicode graph. (default: auto)\n  --awkbin <exec>  Override the awk interpreter. (default: awk)\n  --pingbin <exec> Override the ping tool. (default: ping)\n  -6               Shortcut for: --pingbin ping6\n\nping parameters handled by prettyping:\n  -a  Audible ping is not implemented yet.\n  -f  Flood mode is not allowed in prettyping.\n  -q  Quiet output is not allowed in prettyping.\n  -R  Record route mode is not allowed in prettyping.\n  -v  Verbose output seems to be the default mode in ping.\n\nAll other parameters are passed directly to ping.\nEOF\n}\n\n# Thanks to people at #bash who pointed me at\n# https://web.archive.org/web/20100301171512/https://bash-hackers.org/wiki/doku.php/scripting/posparams\nparse_arguments() {\n\tUSE_COLOR=1\n\tUSE_MULTICOLOR=1\n\tUSE_UNICODE=1\n\tUSE_LEGEND=1\n\n\tif [ -t 1 ]; then\n\t\tIS_TERMINAL=1\n\telse\n\t\tIS_TERMINAL=0\n\tfi\n\n\tLAST_N=60\n\tOVERRIDE_COLUMNS=0\n\tOVERRIDE_LINES=0\n\tRTT_MIN=auto\n\tRTT_MAX=auto\n\n\tPING_BIN=\"ping\"\n\t#PING_BIN=\"./mockping.awk\"\n\tPING_PARAMS=( )\n\n\tAWK_BIN=\"awk\"\n\tAWK_PARAMS=( )\n\n\twhile [[ $# != 0 ]] ; do\n\t\tcase \"$1\" in\n\t\t\t-h | -help | --help )\n\t\t\t\tprint_help\n\t\t\t\texit\n\t\t\t\t;;\n\n\t\t\t# Forbidden ping parameters within prettyping:\n\t\t\t-f )\n\t\t\t\techo \"${MYNAME}: You can't use the -f (flood) option.\"\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\t\t-R )\n\t\t\t\t# -R prints extra information at each ping response.\n\t\t\t\techo \"${MYNAME}: You can't use the -R (record route) option.\"\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\t\t-q )\n\t\t\t\techo \"${MYNAME}: You can't use the -q (quiet) option.\"\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\t\t-v )\n\t\t\t\t# -v enables verbose output. However, it seems the output with\n\t\t\t\t# or without this option is the same. Anyway, prettyping will\n\t\t\t\t# strip this parameter.\n\t\t\t\t;;\n\t\t\t# Note:\n\t\t\t#  Small values for -s parameter prevents ping from being able to\n\t\t\t#  calculate RTT.\n\n\t\t\t# New parameters:\n\t\t\t-a )\n\t\t\t\t# TODO: Implement audible ping for responses or for missing packets\n\t\t\t\t;;\n\n\t\t\t-color        | --color        ) USE_COLOR=1 ;;\n\t\t\t-nocolor      | --nocolor      ) USE_COLOR=0 ;;\n\t\t\t-multicolor   | --multicolor   ) USE_MULTICOLOR=1 ;;\n\t\t\t-nomulticolor | --nomulticolor ) USE_MULTICOLOR=0 ;;\n\t\t\t-unicode      | --unicode      ) USE_UNICODE=1 ;;\n\t\t\t-nounicode    | --nounicode    ) USE_UNICODE=0 ;;\n\t\t\t-legend       | --legend       ) USE_LEGEND=1 ;;\n\t\t\t-nolegend     | --nolegend     ) USE_LEGEND=0 ;;\n\t\t\t-terminal     | --terminal     ) IS_TERMINAL=1 ;;\n\t\t\t-noterminal   | --noterminal   ) IS_TERMINAL=0 ;;\n\n\t\t\t-awkbin  | --awkbin  ) AWK_BIN=\"$2\"  ; shift ;;\n\t\t\t-pingbin | --pingbin ) PING_BIN=\"$2\" ; shift ;;\n\t\t\t-6 ) PING_BIN=\"ping6\" ;;\n\n\t\t\t#TODO: Check if these parameters are numbers.\n\t\t\t-last    | --last    ) LAST_N=\"$2\"           ; shift ;;\n\t\t\t-columns | --columns ) OVERRIDE_COLUMNS=\"$2\" ; shift ;;\n\t\t\t-lines   | --lines   ) OVERRIDE_LINES=\"$2\"   ; shift ;;\n\t\t\t-rttmin  | --rttmin  ) RTT_MIN=\"$2\"          ; shift ;;\n\t\t\t-rttmax  | --rttmax  ) RTT_MAX=\"$2\"          ; shift ;;\n\n\t\t\t* )\n\t\t\t\tPING_PARAMS+=(\"$1\")\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tif [[ \"${RTT_MIN}\" -gt 0 && \"${RTT_MAX}\" -gt 0 && \"${RTT_MIN}\" -ge \"${RTT_MAX}\" ]] ; then\n\t\techo \"${MYNAME}: Invalid --rttmin and -rttmax values.\"\n\t\texit 1\n\tfi\n\n\tif [[ \"${#PING_PARAMS[@]}\" = 0 ]] ; then\n\t\techo \"${MYNAME}: Missing parameters, use --help for instructions.\"\n\t\texit 1\n\tfi\n\n\t# Workaround for mawk:\n\t# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=593504\n\tlocal version=\"$(echo | \"${AWK_BIN}\" -W version 2>&1)\"\n\tif [[ \"${version}\" == mawk* ]] ; then\n\t\tAWK_PARAMS+=(-W interactive)\n\tfi\n}\n\nMYNAME=`basename \"$0\"`\nparse_arguments \"$@\"\n\n\nexport LC_ALL=C\n\n# Warning! Ugly code ahead!\n# The code is so ugly that the comments explaining it are\n# bigger than the code itself!\n#\n# Suppose this:\n#\n#   cmd_a | cmd_b &\n#\n# I need the PID of cmd_a. How can I get it?\n# In bash, $! will give me the PID of cmd_b.\n#\n# So, I came up with this ugly solution: open a subshell, like this:\n#\n# (\n# \tcmd_a &\n# \techo \"This is the PID I want $!\"\n# \twait\n# ) | cmd_b\n\n\n# Ignore Ctrl+C here.\n# If I don't do this, this shell script is killed before\n# ping and gawk can finish their work.\ntrap '' 2\n\n# Now the ugly code.\n(\n\t\"${PING_BIN}\" \"${PING_PARAMS[@]}\" &\n\tPING_PID=\"$!\"\n\n\t# Commented out, because it looks like this line is not needed\n\t#trap \"kill -2 $PING_PID ; exit 1\" 2  # Catch Ctrl+C here\n\n\twait\n) 2>&1 | (\n\tif [ \"${IS_TERMINAL}\" = 1 ]; then\n\t\t# Print a message to notify the awk script about terminal size change.\n\t\ttrap \"echo SIGWINCH\" 28\n\tfi\n\n\t# The trap must be in another subshell because otherwise it will interrupt\n\t# the \"wait\" commmand.\n\twhile read line; do\n\t\techo -E \"$line\"\n\tdone\n) 2>&1 | \"${AWK_BIN}\" \"${AWK_PARAMS[@]}\" '\n# Weird that awk does not come with abs(), so I need to implement it.\nfunction abs(x) {\n\treturn ( (x < 0) ? -x : x )\n}\n\n# Ditto for ceiling function.\nfunction ceil(x) {\n\treturn (x == int(x)) ? x : int(x) + 1\n}\n\n# Local variables MUST be declared in argument list, else they are\n# seen as global. Ugly, but that is how awk works.\nfunction get_terminal_size(SIZE, SIZEA, HAS_DETECTED, CMD) {\n\tHAS_DETECTED = 0\n\n\tCMD = \"stty -f /dev/tty size 2> /dev/null\"\n\n\tif ( (CMD | getline SIZE) == 1 ) {\n\t\tsplit(SIZE, SIZEA, \" \")\n\t\tLINES   = int(SIZEA[1])\n\t\tCOLUMNS = int(SIZEA[2])\n\t\tHAS_DETECTED = 1\n\t}\n\tclose(CMD)\n\n\tif ( HAS_DETECTED == 0 ) {\n\t\tCMD = \"tput lines\"\n\t\tif ( (CMD | getline SIZE) == 1 ) {\n\t\t\tLINES = int(SIZE)\n\t\t\tHAS_DETECTED = 1\n\t\t}\n\t\tclose(CMD)\n\n\t\tCMD = \"tput cols\"\n\t\tif ( (CMD | getline SIZE) == 1 ) {\n\t\t\tCOLUMNS = int(SIZE)\n\t\t\tHAS_DETECTED = 1\n\t\t}\n\t\tclose(CMD)\n\t}\n\n\tif ( int('\"${OVERRIDE_COLUMNS}\"') ) { COLUMNS = int('\"${OVERRIDE_COLUMNS}\"') }\n\tif ( int('\"${OVERRIDE_LINES}\"')   ) { LINES   = int('\"${OVERRIDE_LINES}\"')   }\n}\n\n############################################################\n# Functions related to cursor handling\n\n# Function called whenever a non-dotted line is printed.\n#\n# It will move the cursor to the line next to the statistics and\n# restore the default color.\nfunction other_line_is_printed() {\n\tif ( IS_PRINTING_DOTS ) {\n\t\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\t\tprintf( ESC_DEFAULT ESC_NEXTLINE ESC_NEXTLINE \"\\n\" )\n\t\t} else {\n\t\t\tprintf( ESC_DEFAULT \"\\n\" )\n\t\t\tprint_statistics_bar()\n\t\t}\n\t}\n\tIS_PRINTING_DOTS = 0\n\tCURR_COL = 0\n}\n\n# Function called whenever a non-dotted line is repeated.\nfunction other_line_is_repeated() {\n\tif ( other_line_times < 2 ) {\n\t\treturn\n\t}\n\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\tprintf( ESC_DEFAULT ESC_ERASELINE \"\\r\" )\n\t}\n\tprintf( \"Last message repeated %d times.\", other_line_times )\n\tif ( ! '\"${IS_TERMINAL}\"' ) {\n\t\tprintf( \"\\n\" )\n\t}\n}\n\n# Function called whenever the repeating line has changed.\nfunction other_line_finished_repeating() {\n\tif ( other_line_times >= 2 ) {\n\t\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\t\tprintf( \"\\n\" )\n\t\t} else {\n\t\t\tother_line_is_repeated()\n\t\t}\n\t}\n\tother_line = \"\"\n\tother_line_times = 0\n}\n\n# Prints the newlines required for the live statistics.\n#\n# I need to print some newlines and then return the cursor back to its position\n# to make sure the terminal will scroll.\n#\n# If the output is not a terminal, break lines on every LAST_N dots.\nfunction print_newlines_if_needed() {\n\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\t# COLUMNS-1 because I want to avoid bugs with the cursor at the last column\n\t\tif ( CURR_COL >= COLUMNS-1 ) {\n\t\t\tCURR_COL = 0\n\t\t}\n\t\tif ( CURR_COL == 0 ) {\n\t\t\tif ( IS_PRINTING_DOTS ) {\n\t\t\t\tprintf( \"\\n\" )\n\t\t\t}\n\t\t\t#printf( \"\\n\" \"\\n\" ESC_PREVLINE ESC_PREVLINE ESC_ERASELINE )\n\t\t\tprintf( ESC_DEFAULT \"\\n\" \"\\n\" ESC_CURSORUP ESC_CURSORUP ESC_ERASELINE )\n\t\t}\n\t} else {\n\t\tif ( CURR_COL >= LAST_N ) {\n\t\t\tCURR_COL = 0\n\t\t\tprintf( ESC_DEFAULT \"\\n\" )\n\t\t\tprint_statistics_bar()\n\t\t}\n\t}\n\tIS_PRINTING_DOTS = 1\n}\n\n############################################################\n# Functions related to the data structure of \"Last N\" statistics.\n\n# Clears the data structure.\nfunction clear(d) {\n\td[\"index\"] = 0  # The next position to store a value\n\td[\"size\"]  = 0  # The array size, goes up to LAST_N\n}\n\n# This function stores the value to the passed data structure.\n# The data structure holds at most LAST_N values. When it is full,\n# a new value overwrite the oldest one.\nfunction store(d, value) {\n\td[d[\"index\"]] = value\n\td[\"index\"]++\n\tif ( d[\"index\"] >= d[\"size\"] ) {\n\t\tif ( d[\"size\"] < LAST_N ) {\n\t\t\td[\"size\"]++\n\t\t} else {\n\t\t\td[\"index\"] = 0\n\t\t}\n\t}\n}\n\n############################################################\n# Functions related to processing the received response\n\nfunction process_rtt(rtt) {\n\t# Overall statistics\n\tlast_rtt = rtt\n\ttotal_rtt += rtt\n\tif ( last_seq == 0 ) {\n\t\tmin_rtt = max_rtt = rtt\n\t} else {\n\t\tif ( rtt < min_rtt ) min_rtt = rtt\n\t\tif ( rtt > max_rtt ) max_rtt = rtt\n\t}\n\n\t# \"Last N\" statistics\n\tstore(lastn_rtt,rtt)\n}\n\nfunction lost_a_packet() {\n\tprint_newlines_if_needed()\n\tprint_missing_response()\n\n\tlast_seq++\n\tlost++\n\tstore(lastn_lost, 1)\n}\n\n############################################################\n# Functions related to printing the fancy ping response\n\n# block_index, n, w are just local variables.\nfunction print_response_legend(i, n, w) {\n\tif ( ! '\"${USE_LEGEND}\"' ) {\n\t\treturn\n\t}\n\tif ( BLOCK_LEN > 1 ) {\n\t\t# w counts the cursor position in the current line. Because of the\n\t\t# escape codes, I need to jump through some hoops in order to count the\n\t\t# position correctly.\n\t\tw = 0\n\t\tn = \"0 \"\n\t\tw += length(n) + 1\n\n\t\tprintf( n BLOCK[0] ESC_DEFAULT )\n\n\t\tfor ( i=1 ; i<BLOCK_LEN ; i++ ) {\n\t\t\tn = sprintf( \"%d \", BLOCK_RTT_MIN + ceil((i-1) * BLOCK_RTT_RANGE / (BLOCK_LEN - 2)) )\n\t\t\tw += length(n) + 1\n\n\t\t\t# Avoid breaking the legend at the end of the line.\n\t\t\t# Also avoids a background color change right at\n\t\t\t# the edge of the screen. (If it happens, the entire next line\n\t\t\t# will have that background color, which is not desired.)\n\t\t\tif ( '\"${IS_TERMINAL}\"' && w + 1 >= COLUMNS ) {\n\t\t\t\tprintf( \"\\n\" )\n\t\t\t\tw = length(n) + 1\n\t\t\t} else {\n\t\t\t\tprintf( \" \" )\n\t\t\t\tw += 1\n\t\t\t}\n\n\t\t\tprintf( n BLOCK[i] ESC_DEFAULT )\n\t\t}\n\t\tprintf( \" ∞\\n\" )\n\t}\n\n\t# Useful code for debugging.\n\t#for ( i=0 ; i<=BLOCK_RTT_MAX ; i++ ) {\n\t#\tprint_received_response(i)\n\t#\tprintf( ESC_DEFAULT \"%4d\\n\", i )\n\t#}\n}\n\n# block_index is just a local variable.\nfunction print_received_response(rtt, block_index) {\n\tif ( rtt < BLOCK_RTT_MIN ) {\n\t\tblock_index = 0\n\t} else if ( rtt >= BLOCK_RTT_MAX ) {\n\t\tblock_index = BLOCK_LEN - 1\n\t} else {\n\t\tblock_index = 1 + int((rtt - BLOCK_RTT_MIN) * (BLOCK_LEN - 2) / BLOCK_RTT_RANGE)\n\t}\n\tprintf( BLOCK[block_index] )\n\tCURR_COL++\n}\n\nfunction print_missing_response(rtt) {\n\tprintf( ESC_RED \"!\" )\n\tCURR_COL++\n}\n\n############################################################\n# Functions related to printing statistics\n\n# All arguments are just local variables.\nfunction print_overall(percentage_lost, avg_rtt) {\n\t# Handling division by zero.\n\t# Note that mawk does not consider division by zero an error, while all\n\t# other awk implementations abort in such case.\n\t# https://stackoverflow.com/questions/14581966/why-does-awk-produce-different-results-for-division-by-zero\n\n\tavg_rtt = ( received > 0 ) ? (total_rtt/received) : 0\n\tpercentage_lost = ( lost+received > 0 ) ? (lost*100/(lost+received)) : 0\n\n\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\tprintf( \"%2d/%3d (%2d%%) lost; %4.0f/\" ESC_BOLD \"%4.0f\" ESC_DEFAULT \"/%4.0fms; last: \" ESC_BOLD \"%4.0f\" ESC_DEFAULT \"ms\",\n\t\t\tlost,\n\t\t\tlost+received,\n\t\t\tpercentage_lost,\n\t\t\tmin_rtt,\n\t\t\tavg_rtt,\n\t\t\tmax_rtt,\n\t\t\tlast_rtt )\n\t} else {\n\t\tprintf( \"%2d/%3d (%2d%%) lost; %4.0f/\" ESC_BOLD \"%4.0f\" ESC_DEFAULT \"/%4.0fms\",\n\t\t\tlost,\n\t\t\tlost+received,\n\t\t\tpercentage_lost,\n\t\t\tmin_rtt,\n\t\t\tavg_rtt,\n\t\t\tmax_rtt )\n\t}\n}\n\n# All arguments are just local variables.\nfunction print_last_n(i, percentage_lost, sum, min, avg, max, diffs) {\n\t# Calculate and print the lost packets statistics\n\tsum = 0\n\tfor ( i=0 ; i<lastn_lost[\"size\"] ; i++ ) {\n\t\tsum += lastn_lost[i]\n\t}\n\tpercentage_lost = (lastn_lost[\"size\"] > 0) ? (sum*100/lastn_lost[\"size\"]) : 0\n\tprintf( \"%2d/%3d (%2d%%) lost; \",\n\t\tsum,\n\t\tlastn_lost[\"size\"],\n\t\tpercentage_lost )\n\n\t# Calculate the min/avg/max rtt times\n\tsum = diffs = 0\n\tmin = max = lastn_rtt[0]\n\tfor ( i=0 ; i<lastn_rtt[\"size\"] ; i++ ) {\n\t\tsum += lastn_rtt[i]\n\t\tif ( lastn_rtt[i] < min ) min = lastn_rtt[i]\n\t\tif ( lastn_rtt[i] > max ) max = lastn_rtt[i]\n\t}\n\tavg = (lastn_rtt[\"size\"]) ? (sum/lastn_rtt[\"size\"]) : 0\n\n\t# Calculate mdev (mean absolute deviation)\n\tfor ( i=0 ; i<lastn_rtt[\"size\"] ; i++ ) {\n\t\tdiffs += abs(lastn_rtt[i] - avg)\n\t}\n\tif ( lastn_rtt[\"size\"] > 0 ) {\n\t\tdiffs /= lastn_rtt[\"size\"]\n\t}\n\n\t# Print the rtt statistics\n\tprintf( \"%4.0f/\" ESC_BOLD \"%4.0f\" ESC_DEFAULT \"/%4.0f/%4.0fms (last %d)\",\n\t\tmin,\n\t\tavg,\n\t\tmax,\n\t\tdiffs,\n\t\tlastn_rtt[\"size\"] )\n}\n\nfunction print_statistics_bar() {\n\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\tprintf( ESC_SAVEPOS ESC_DEFAULT )\n\n\t\tprintf( ESC_NEXTLINE ESC_ERASELINE )\n\t\tprint_overall()\n\t\tprintf( ESC_NEXTLINE ESC_ERASELINE )\n\t\tprint_last_n()\n\n\t\tprintf( ESC_UNSAVEPOS )\n\t} else {\n\t\tprint_overall()\n\t\tprintf( \"\\n\" )\n\t\tprint_last_n()\n\t\tprintf( \"\\n\" )\n\t}\n}\n\nfunction print_statistics_bar_if_terminal() {\n\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\tprint_statistics_bar()\n\t}\n}\n\n############################################################\n# Initializations\nBEGIN {\n\t# Easy way to get each value from ping output\n\tFS = \"=\"\n\n\t############################################################\n\t# General internal variables\n\n\t# This is needed to keep track of lost packets\n\tlast_seq = 0\n\n\t# The previously printed non-ping-response line\n\tother_line = \"\"\n\tother_line_times = 0\n\n\t# Variables to keep the screen clean\n\tIS_PRINTING_DOTS = 0\n\tCURR_COL = 0\n\n\t############################################################\n\t# Variables related to \"overall\" statistics\n\treceived = 0\n\tlost = 0\n\ttotal_rtt = 0\n\tmin_rtt = 0\n\tmax_rtt = 0\n\tlast_rtt = 0\n\n\t############################################################\n\t# Variables related to \"last N\" statistics\n\tLAST_N = int('\"${LAST_N}\"')\n\n\t# Data structures for the \"last N\" statistics\n\tclear(lastn_lost)\n\tclear(lastn_rtt)\n\n\t############################################################\n\t# Terminal height and width\n\n\t# These are sane defaults, in case we cannot query the actual terminal size\n\tLINES    = 24\n\tCOLUMNS  = 80\n\n\t# Auto-detecting the terminal size\n\tget_terminal_size()\n\tif ( '\"${IS_TERMINAL}\"' && COLUMNS <= 50 ) {\n\t\tprint \"Warning: terminal width is too small.\"\n\t}\n\n\t############################################################\n\t# ANSI escape codes\n\n\t# Color escape codes.\n\t# Fortunately, awk defaults any unassigned variable to an empty string.\n\tif ( '\"${USE_COLOR}\"' ) {\n\t\tESC_DEFAULT = \"\\033[0m\"\n\t\tESC_BOLD    = \"\\033[1m\"\n\t\t#ESC_BLACK   = \"\\033[0;30m\"\n\t\t#ESC_GRAY    = \"\\033[1;30m\"\n\t\tESC_RED     = \"\\033[0;31m\"\n\t\tESC_GREEN   = \"\\033[0;32m\"\n\t\tESC_YELLOW  = \"\\033[0;33m\"\n\t\tESC_BLUE    = \"\\033[0;34m\"\n\t\tESC_MAGENTA = \"\\033[0;35m\"\n\t\tESC_CYAN    = \"\\033[0;36m\"\n\t\tESC_WHITE   = \"\\033[0;37m\"\n\t\tESC_YELLOW_ON_GREEN = \"\\033[42;33m\"\n\t\tESC_RED_ON_YELLOW   = \"\\033[43;31m\"\n\t}\n\t# Other escape codes, see:\n\t# https://en.wikipedia.org/wiki/ANSI_escape_code\n\t# https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n\tESC_NEXTLINE     = \"\\n\"\n\tESC_CURSORUP     = \"\\033[A\"\n\tESC_CURSORDOWN   = \"\\033[B\"\n\tESC_SCROLLUP     = \"\\033[S\"\n\tESC_SCROLLDOWN   = \"\\033[T\"\n\tESC_ERASELINEEND = \"\\033[0K\"\n\tESC_ERASELINE    = \"\\033[2K\"\n\tESC_SAVEPOS      = \"\\0337\"\n\tESC_UNSAVEPOS    = \"\\0338\"\n\n\t# I am avoiding these escapes as they are not listed in:\n\t# https://vt100.net/docs/vt100-ug/chapter3.html\n\t#ESC_PREVLINE   = \"\\033[F\"\n\t#ESC_SAVEPOS    = \"\\033[s\"\n\t#ESC_UNSAVEPOS  = \"\\033[u\"\n\n\t# I am avoiding this to improve compatibility with (older versions of) tmux\n\t#ESC_NEXTLINE   = \"\\033[E\"\n\n\t############################################################\n\t# Unicode characters (based on https://github.com/holman/spark )\n\tif ( '\"${USE_UNICODE}\"' ) {\n\t\tBLOCK[ 0] = ESC_GREEN \"▁\"\n\t\tBLOCK[ 1] = ESC_GREEN \"▂\"\n\t\tBLOCK[ 2] = ESC_GREEN \"▃\"\n\t\tBLOCK[ 3] = ESC_GREEN \"▄\"\n\t\tBLOCK[ 4] = ESC_GREEN \"▅\"\n\t\tBLOCK[ 5] = ESC_GREEN \"▆\"\n\t\tBLOCK[ 6] = ESC_GREEN \"▇\"\n\t\tBLOCK[ 7] = ESC_GREEN \"█\"\n\t\tBLOCK[ 8] = ESC_YELLOW_ON_GREEN \"▁\"\n\t\tBLOCK[ 9] = ESC_YELLOW_ON_GREEN \"▂\"\n\t\tBLOCK[10] = ESC_YELLOW_ON_GREEN \"▃\"\n\t\tBLOCK[11] = ESC_YELLOW_ON_GREEN \"▄\"\n\t\tBLOCK[12] = ESC_YELLOW_ON_GREEN \"▅\"\n\t\tBLOCK[13] = ESC_YELLOW_ON_GREEN \"▆\"\n\t\tBLOCK[14] = ESC_YELLOW_ON_GREEN \"▇\"\n\t\tBLOCK[15] = ESC_YELLOW_ON_GREEN \"█\"\n\t\tBLOCK[16] = ESC_RED_ON_YELLOW \"▁\"\n\t\tBLOCK[17] = ESC_RED_ON_YELLOW \"▂\"\n\t\tBLOCK[18] = ESC_RED_ON_YELLOW \"▃\"\n\t\tBLOCK[19] = ESC_RED_ON_YELLOW \"▄\"\n\t\tBLOCK[20] = ESC_RED_ON_YELLOW \"▅\"\n\t\tBLOCK[21] = ESC_RED_ON_YELLOW \"▆\"\n\t\tBLOCK[22] = ESC_RED_ON_YELLOW \"▇\"\n\t\tBLOCK[23] = ESC_RED_ON_YELLOW \"█\"\n\t\tif ( '\"${USE_MULTICOLOR}\"' && '\"${USE_COLOR}\"' ) {\n\t\t\t# Multi-color version:\n\t\t\tBLOCK_LEN = 24\n\t\t\tBLOCK_RTT_MIN = 10\n\t\t\tBLOCK_RTT_MAX = 230\n\t\t} else {\n\t\t\t# Simple version:\n\t\t\tBLOCK_LEN = 8\n\t\t\tBLOCK_RTT_MIN = 25\n\t\t\tBLOCK_RTT_MAX = 175\n\t\t}\n\t} else {\n\t\tBLOCK[ 0] = ESC_GREEN \"_\"\n\t\tBLOCK[ 1] = ESC_GREEN \".\"\n\t\tBLOCK[ 2] = ESC_GREEN \"o\"\n\t\tBLOCK[ 3] = ESC_GREEN \"O\"\n\t\tBLOCK[ 4] = ESC_YELLOW \"_\"\n\t\tBLOCK[ 5] = ESC_YELLOW \".\"\n\t\tBLOCK[ 6] = ESC_YELLOW \"o\"\n\t\tBLOCK[ 7] = ESC_YELLOW \"O\"\n\t\tBLOCK[ 8] = ESC_RED \"_\"\n\t\tBLOCK[ 9] = ESC_RED \".\"\n\t\tBLOCK[10] = ESC_RED \"o\"\n\t\tBLOCK[11] = ESC_RED \"O\"\n\t\tif ( '\"${USE_MULTICOLOR}\"' && '\"${USE_COLOR}\"' ) {\n\t\t\t# Multi-color version:\n\t\t\tBLOCK_LEN = 12\n\t\t\tBLOCK_RTT_MIN = 20\n\t\t\tBLOCK_RTT_MAX = 220\n\t\t} else {\n\t\t\t# Simple version:\n\t\t\tBLOCK_LEN = 4\n\t\t\tBLOCK_RTT_MIN = 75\n\t\t\tBLOCK_RTT_MAX = 225\n\t\t}\n\t}\n\n\tif ( int('\"${RTT_MIN}\"') > 0 && int('\"${RTT_MAX}\"') > 0 ) {\n\t\tBLOCK_RTT_MIN = int('\"${RTT_MIN}\"')\n\t\tBLOCK_RTT_MAX = int('\"${RTT_MAX}\"')\n\t} else if ( int('\"${RTT_MIN}\"') > 0 ) {\n\t\tBLOCK_RTT_MIN = int('\"${RTT_MIN}\"')\n\t\tBLOCK_RTT_MAX = BLOCK_RTT_MIN * (BLOCK_LEN - 1)\n\t} else if ( int('\"${RTT_MAX}\"') > 0 ) {\n\t\tBLOCK_RTT_MAX = int('\"${RTT_MAX}\"')\n\t\tBLOCK_RTT_MIN = int(BLOCK_RTT_MAX / (BLOCK_LEN - 1))\n\t}\n\n\tBLOCK_RTT_RANGE = BLOCK_RTT_MAX - BLOCK_RTT_MIN\n\tprint_response_legend()\n}\n\n############################################################\n# Main loop\n{\n\tif ( $0 ~ /^[0-9]+ bytes from .*[:,] icmp_[rs]eq=[0-9]+ (ttl|hlim)=[0-9]+ time=[0-9.]+ *ms/ ) {\n\t\t# Sample line from ping:\n\t\t# 64 bytes from 8.8.8.8: icmp_seq=1 ttl=49 time=184 ms\n\t\tif ( other_line_times >= 2 ) {\n\t\t\tother_line_finished_repeating()\n\t\t}\n\n\t\t# $1 = useless prefix string\n\t\t# $2 = icmp_seq\n\t\t# $3 = ttl/hlim\n\t\t# $4 = time\n\n\t\t# This must be called before incrementing the last_seq variable!\n\t\trtt = int($4)\n\t\tprocess_rtt(rtt)\n\n\t\tseq = int($2)\n\n\t\twhile ( last_seq < seq - 1 ) {\n\t\t\tlost_a_packet()\n\t\t}\n\n\t\t# Received a packet\n\t\tprint_newlines_if_needed()\n\t\tprint_received_response(rtt)\n\n\t\t# In case of receiving multiple responses with the same seq number, it\n\t\t# is better to use \"last_seq = seq\" than to increment last_seq.\n\t\tlast_seq = seq\n\n\t\treceived++\n\t\tstore(lastn_lost, 0)\n\n\t\tprint_statistics_bar_if_terminal()\n\t} else if ( $0 ~ /^.*onnected to.*, seq=[0-9]+ time=[0-9.]+ *ms/ ) {\n\t\t# Sample line from httping:\n\t\t# connected to 200.149.119.168:80 (273 bytes), seq=0 time=129.86 ms\n\t\tif ( other_line_times >= 2 ) {\n\t\t\tother_line_finished_repeating()\n\t\t}\n\n\t\tseq = $0\n\t\tsub(/.* seq=/, \"\", seq)\n\t\tseq = int(seq)\n\n\t\trtt = $0\n\t\tsub(/.* time=/, \"\", rtt)\n\t\trtt = int(rtt)\n\n\t\tprocess_rtt(rtt)\n\n\t\twhile ( last_seq < seq - 1 ) {\n\t\t\tlost_a_packet()\n\t\t}\n\n\t\t# Received a packet\n\t\tprint_newlines_if_needed()\n\t\tprint_received_response(rtt)\n\n\t\t# In case of receiving multiple responses with the same seq number, it\n\t\t# is better to use \"last_seq = seq\" than to increment last_seq.\n\t\tlast_seq = seq\n\n\t\treceived++\n\t\tstore(lastn_lost, 0)\n\n\t\tprint_statistics_bar_if_terminal()\n\t} else if ( $0 == \"\" ) {\n\t\t# Do nothing on blank lines.\n\t} else if ( $0 == \"error shutting down ssl\" ) {\n\t\t# Common error message when using httping, ignore it.\n\t} else if ( $0 ~ /^Request timeout for icmp_seq [0-9]+/ ) {\n\t\t# Reply timeout is printed on Mac OS X.\n\n\t\tif ( other_line_times >= 2 ) {\n\t\t\tother_line_finished_repeating()\n\t\t}\n\n\t\tlost_a_packet()\n\n\t\t# Making sure the last_seq number is correct.\n\t\tgsub(/.* icmp_seq /, \"\")\n\t\tseq = int($0)\n\t\tlast_seq = seq\n\n\t\tprint_newlines_if_needed()\n\t\tprint_statistics_bar_if_terminal()\n\t} else if ( $0 ~ /^SIGWINCH$/ ) {\n\t\tget_terminal_size()\n\n\t\tif ( IS_PRINTING_DOTS ) {\n\t\t\tif ( CURR_COL >= COLUMNS-1 ) {\n\t\t\t\t# Not enough space anyway.\n\t\t\t} else {\n\t\t\t\t# Making up room in case the number of lines has changed.\n\t\t\t\tprintf( ESC_NEXTLINE ESC_NEXTLINE ESC_CURSORUP ESC_CURSORUP )\n\t\t\t\t# Moving to the correct column and erasing the rest of the line.\n\t\t\t\tprintf( \"\\033[\" (CURR_COL+1) \"G\" ESC_DEFAULT ESC_ERASELINEEND )\n\t\t\t}\n\n\t\t\tprint_newlines_if_needed()\n\t\t\tprint_statistics_bar_if_terminal()\n\t\t}\n\t} else {\n\t\tother_line_is_printed()\n\t\toriginal_line = $0\n\t\tgsub(/icmp_seq[= ][0-9]+/, \"\")\n\t\tif ( $0 == other_line ) {\n\t\t\tother_line_times++\n\t\t\tif ( '\"${IS_TERMINAL}\"' ) {\n\t\t\t\tother_line_is_repeated()\n\t\t\t}\n\t\t} else {\n\t\t\tother_line_finished_repeating()\n\t\t\tother_line = $0\n\t\t\tother_line_times = 1\n\t\t\tprintf( \"%s\\n\", original_line )\n\t\t}\n\t}\n\n\t# Not needed when the output is a terminal, but does not hurt either.\n\tfflush()\n}'\n"
        }
      ]
    }
  ]
}