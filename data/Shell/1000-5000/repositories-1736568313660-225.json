{
  "metadata": {
    "timestamp": 1736568313660,
    "page": 225,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jamesob/desk",
      "stars": 2545,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.390625,
          "content": "sudo: required\n\nlanguage: bash\n\nservices:\n    - docker\n\nbefore_install:\n    - wget http://ftp.debian.org/debian/pool/main/s/shellcheck/shellcheck_0.4.4-4_amd64.deb\n    - ar x shellcheck_0.4.4-4_amd64.deb \n    - tar xvf data.tar.xz\n    - cp ./usr/bin/shellcheck .\n\nenv:\n    - PATH=$PATH:$(pwd)\n\nscript:\n    - SHELL_CMD='-c ./run_tests.sh' make bash zsh\n    - SHELL_CMD='-c ./run_tests.fish' make fish\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.64453125,
          "content": "FROM ubuntu:14.04\nMAINTAINER desk\n\nENV USERNAME desktester\nRUN adduser --disabled-password --gecos \"\" desktester \nRUN apt-get update && apt-get install -y vim expect zsh fish\n\nWORKDIR /home/$USERNAME/\nADD desk /usr/local/bin/desk\nADD test/zshrc .zshrc\nADD test/bashrc .bashrc\nADD test/run_tests.sh run_tests.sh\nADD test/run_tests.fish run_tests.fish\nADD examples examples\nRUN mkdir -p .config/fish && touch .config/fish/config.fish\n\n# Set up test Deskfile\nRUN mkdir -p example-project && cp examples/hello.sh example-project/Deskfile\n\nRUN chown -R $USERNAME:$USERNAME .zshrc example-project examples run_tests.fish run_tests.sh .bashrc .config\n\nUSER $USERNAME\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.033203125,
          "content": "Copyright (c) 2015 James O'Beirne\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.609375,
          "content": ".PHONY: install\ninstall:\n\tcp ./desk /usr/local/bin/desk\n\n.PHONY: uninstall\nuninstall:\n\trm /usr/local/bin/desk\n\t\n.PHONY: oh-my-zsh\noh-my-zsh: \n\tln -s $(shell pwd)/shell_plugins/zsh $(HOME)/.oh-my-zsh/custom/plugins/desk\n\n\n# Test targets\n# ------------\n\n.PHONY: dockerbuild\ndockerbuild:\n\tdocker build -t desk/desk .\n\nSHELL_CMD?=\n\n.PHONY: bash\nbash: dockerbuild\n\tdocker run -it desk/desk /bin/bash $(SHELL_CMD)\n \n.PHONY: zsh\nzsh: dockerbuild\n\tdocker run -it desk/desk /usr/bin/zsh $(SHELL_CMD)\n \n.PHONY: fish\nfish: dockerbuild\n\tdocker run -it desk/desk /usr/bin/fish $(SHELL_CMD)\n\n.PHONY: lint\nlint:\n\tshellcheck -e SC2155 desk\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.1962890625,
          "content": "\n# ◲  desk\n\n[![build](https://api.travis-ci.org/jamesob/desk.svg?branch=master)](https://travis-ci.org/jamesob/desk) [![Join the chat at https://gitter.im/jamesob/desk](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jamesob/desk?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nLightweight workspace manager for the shell.\n\nDesk makes it easy to flip back and forth between different project contexts in\nyour favorite shell. Change directory, activate a virtualenv or rvm, load\nin domain-specific aliases, environment variables, functions, arbitrary shell files, \nall in a single command.\n\nInstead of relying on `CTRL-R` to execute and recall (\"that command's gotta\nbe here somewhere...\"), desk helps shorten and document those actions with\nshell aliases and functions, which are then namespaced under a particular\ndesk.\n\nBecause Deskfiles are just enriched shell scripts, the possibilities are \nendless. For example, when doing work on AWS I have desk \nsecurely load AWS API keys into environment variables via \n[`pass`](https://www.passwordstore.org/) -- no effort on my part, and no \nrisk of accidentally persisting that sensitive information to a history file.\n\n<img src='screencap.gif' width=700>\n\nI have a hard time calling this a \"workspace manager\" with a straight\nface -- it's basically just a shell script that sources another shell script in a new shell.\nBut I often find myself working in multiple different code trees simultaneously:\nthe quick context switches and namespaced commands that desk facilitates\nhave proven useful.\n\nThere are no dependencies other than `bash`. Desk is explicitly tested with `bash`,\n`zsh`, and `fish`.\n\n```sh\n◲  desk 0.6.0\n\nUsage:\n\n    desk\n        List the current desk and any associated aliases. If no desk\n        is being used, display available desks.\n    desk init\n        Initialize desk configuration.\n    desk (list|ls)\n        List all desks along with a description.\n    desk (.|go) [<desk-name-or-path> [shell-args...]]\n        Activate a desk. Extra arguments are passed onto shell. If called with\n        no arguments, look for a Deskfile in the current directory. If not a\n        recognized desk, try as a path to directory containing a Deskfile.\n    desk run <desk-name> <cmd>\n        Run a command within a desk's environment then exit. Think '$SHELL -c'.\n    desk edit [desk-name]\n        Edit (or create) a deskfile with the name specified, otherwise\n        edit the active deskfile.\n    desk help\n        Show this text.\n    desk version\n        Show version information.\n\nSince desk spawns a shell, to deactivate and \"pop\" out a desk, you\nsimply need to exit or otherwise end the current shell process.\n```\n\nFor example, given this deskfile (`~/.desk/desks/tf.sh`):\n```sh\n# tf.sh\n#\n# Description: desk for doing work on a terraform-based repository\n#\n\ncd ~/terraform-repo\n\n# Set up AWS env variables: <key id> <secret>\nset_aws_env() {\n  export AWS_ACCESS_KEY_ID=\"$1\"\n  export AWS_SECRET_ACCESS_KEY=\"$2\"\n}\n\n# Run `terraform plan` with proper AWS var config\nplan() {\n  terraform plan -module-depth=-1 \\\n    -var \"access_key=${AWS_ACCESS_KEY_ID}\" \\\n    -var \"secret_key=${AWS_SECRET_ACCESS_KEY}\"\n}\n\n# Run `terraform apply` with proper AWS var config\nalias apply='terraform apply'\n```\n\nwe'd get\n\n```sh\n$ desk . tf\n$ desk\n\ntf\ndesk for doing work on a terraform repo\n\n  set_aws_env   Set up AWS env variables: <key id> <secret>\n  plan          Run `terraform plan` with proper AWS var config\n  apply         Run `terraform apply` with proper AWS var config\n```\n\nBasically, desk just associates a shell script (`name.sh`) with a name. When\nyou call `desk . name`, desk drops you into a shell where `name.sh` has been\nexecuted, and then desk extracts out certain comments in `name.sh` for useful\nrendering.\n\n### Installing\n\n#### With homebrew\n\n`brew install desk`\n\n#### With curl\n\nAssuming `~/bin` exists and is on the PATH... otherwise, substitute `/usr/local/bin`\nand add `sudo` as needed.\n\n0. `curl https://raw.githubusercontent.com/jamesob/desk/master/desk > ~/bin/desk`\n0. `chmod +x ~/bin/desk`\n\n#### With git\n\n0. `git clone git@github.com:jamesob/desk.git && cd desk && sudo make install`\n\nAfter that, run `desk init` and start adding deskfiles with either `desk edit [deskfile name]`\nor by manually adding shell scripts into your deskfiles directory (by default `~/.desk/desks/`).\n\n### Enabling shell extensions\n\n**NB**: Shell extensions are automatically enabled if Desk is installed via Homebrew.\n\n#### Using bash\n\n0. Add `source /path/to/desk/repo/shell_plugins/bash/desk` to your `.bashrc`.\n\n#### Using fish\n\n```fish\nmkdir -p ~/.config/fish/completions\ncp /path/to/desk/repo/shell_plugins/fish/desk.fish ~/.config/fish/completions\n```\n\n#### Using zsh\n\n0. Add `fpath=(/path/to/desk/repo/shell_plugins/zsh $fpath)` to your `.zshrc`.\n\n\nOptionally, use one of the zsh plugin frameworks mentioned below.\n\n#### Using [oh-my-zsh](http://ohmyz.sh/)\n\n0. `make oh-my-zsh` from within this repo. This sets up a symlink.\n\nor\n\n0. `cd ~/.oh-my-zsh/custom/plugins`\n0. `git clone git@github.com:jamesob/desk.git /tmp/desk && cp -r /tmp/desk/shell_plugins/zsh desk`\n0. Add desk to your plugin list\n\n#### Using [Antigen](https://github.com/zsh-users/antigen)\n\n0. Add `antigen bundle jamesob/desk shell_plugins/zsh` to your `.zshrc`\n0. Open a new terminal window. Antigen will clone the desk repo and add it to your path.\n\n#### Using [zgen](https://github.com/tarjoilija/zgen)\n\n0. Add `zgen load jamesob/desk shell_plugins/zsh` to your `.zshrc` with your other load commands\n0. `rm ~/.zgen/init.zsh`\n0. Start a new shell; zgen will generate a new `init.zsh` and automatically clone the desk repository for you and add it to your path.\n\n### Deskfile rules\n\nDeskfiles are just shell scripts, nothing more, that live in the desk config directory.\nDesk does pay attention to certain kinds of comments, though.\n\n- *description*: you can describe a deskfile by including `# Description: ...`\n  somewhere in the file.\n\n- *alias and function docs*: if the line above an alias or function is a\n  comment, it will be used as documentation.\n \n### Deskfiles\n\nDeskfiles are just shell scripts at the root of a project directory that \nadhere to the conventions above. These can be put into version control to\nformalize and ease common development tasks like running tests or doing\nlocal builds.\n\nFor example, if we have some directory or repository called `myproject`, if\nwe create `myproject/Deskfile`, we'll be able to do any of the following:\n```sh\n$ desk go /path/to/myproject/\n$ desk go /path/to/myproject/Deskfile\nmyproject/ $ desk go .\nmyproject/ $ desk go\n```\n \n### Sharing deskfiles across computers\n\nOf course, the desk config directory (by default `~/.desks`) can be a symlink\nso that deskfiles can be stored in some centralized place, like Dropbox,\nand so shared across many computers.\n\n### Using a non-default config location\n\nBy default, desk configuration lives in `~/.desk` (`$DESK_DIR`) and deskfiles\nlive in `~/.desk/desks` (`$DESK_DESKS_DIR`). If you want to use some other\nlocation, specify as much in `desk init` and then ensure you set `$DESK_DIR`\nand/or `$DESK_DESKS_DIR` to match in your shell's rc file.\n\n### Shortening invocation\n\nTyping `desk .` frequently can get old; personally, I like to alias this with\n```sh\nalias d.='desk .'\n```\nin my shell rc file.\n\n### Usage with OS X\n\nDesk won't work when used strictly with `~/.bash_profile` on OS X's terminal, since\nthe content of `~/.bash_profile` is only executed on *login*, not shell creation, as\nexplained [here](http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html).\n\nMy recommendation is to use `~/.bashrc` as your general-purpose config file, then simply\nhave `~/.bash_profile` point to it:\n```sh\n# ~/.bash_profile\n\nif [ -f ~/.bashrc ]; then\n   source ~/.bashrc\nfi\n```\n\n### Related projects\n\n- [godesk](https://github.com/hamin/godesk) by @hamin: a desk launcher with fuzzy filtering\n\n\n### Tips accepted\n\n![18ehgMUJBqKc2Eyi6WHiMwHFwA8kobYEhy](http://i.imgur.com/KAfUPA6.png)\n\nBTC: `18ehgMUJBqKc2Eyi6WHiMwHFwA8kobYEhy`\n\nHalf of all tips will be donated to [an organization providing aid to Syrian refugees](http://www.moas.eu/).\n\n#### Donations made on behalf of tippers\n\n| date | amount | organization |\n| ---- | ------ | ------------ |\n| 2015-11-18 | $1.07 | http://moas.eu |\n| 2016-11-14 | $21.00 | http://moas.eu |\n"
        },
        {
          "name": "desk",
          "type": "blob",
          "size": 9.96484375,
          "content": "#!/usr/bin/env bash\n# vim: set filetype=sh:\n\nPREFIX=\"${DESK_DIR:-$HOME/.desk}\"\nDESKS=\"${DESK_DESKS_DIR:-$PREFIX/desks}\"\nDESKFILE_NAME=Deskfile\n\n\n## Commands\n\ncmd_version() {\n    echo \"◲  desk 0.6.0\"\n}\n\n\ncmd_usage() {\n    cmd_version\n    echo\n    cat <<_EOF\nUsage:\n\n    $PROGRAM\n        List the current desk and any associated aliases. If no desk\n        is being used, display available desks.\n    $PROGRAM init\n        Initialize desk configuration.\n    $PROGRAM (list|ls)\n        List all desks along with a description.\n    $PROGRAM (.|go) [<desk-name-or-path> [shell-args...]]\n        Activate a desk. Extra arguments are passed onto shell. If called with\n        no arguments, look for a Deskfile in the current directory. If not a\n        recognized desk, try as a path to directory containing a Deskfile.\n    $PROGRAM run <desk-name> '<cmd>'\n    $PROGRAM run <desk-name> <cmd> <arg>...\n        Run a command within a desk's environment then exit. In the first form\n        shell expansion is performed. In the second form, the argument vector\n        is executed as is.\n    $PROGRAM edit [desk-name]\n        Edit (or create) a deskfile with the name specified, otherwise\n        edit the active deskfile.\n    $PROGRAM help\n        Show this text.\n    $PROGRAM version\n        Show version information.\n\nSince desk spawns a shell, to deactivate and \"pop\" out a desk, you\nsimply need to exit or otherwise end the current shell process.\n_EOF\n}\n\ncmd_init() {\n    if [ -d \"$PREFIX\" ]; then\n        echo \"Desk dir already exists at ${PREFIX}\"\n        exit 1\n    fi\n    read -p \"Where do you want to store your deskfiles? (default: ${PREFIX}): \" \\\n        NEW_PREFIX\n    [ -z \"${NEW_PREFIX}\" ] && NEW_PREFIX=\"$PREFIX\"\n\n    if [ ! -d \"${NEW_PREFIX}\" ]; then\n        echo \"${NEW_PREFIX} doesn't exist, attempting to create.\"\n        mkdir -p \"$NEW_PREFIX/desks\"\n    fi\n\n    local SHELLTYPE=$(get_running_shell)\n\n    case \"${SHELLTYPE}\" in\n        bash)   local SHELLRC=\"${HOME}/.bashrc\" ;;\n        fish)   local SHELLRC=\"${HOME}/.config/fish/config.fish\" ;;\n        zsh)    local SHELLRC=\"${HOME}/.zshrc\" ;;\n    esac\n\n    read -p \"Where's your shell rc file? (default: ${SHELLRC}): \" \\\n        USER_SHELLRC\n    [ -z \"${USER_SHELLRC}\" ] && USER_SHELLRC=\"$SHELLRC\"\n    if [ ! -f \"$USER_SHELLRC\" ]; then\n        echo \"${USER_SHELLRC} doesn't exist\"\n        exit 1\n    fi\n\n    printf \"\\n# Hook for desk activation\\n\" >> \"$USER_SHELLRC\"\n\n    # Since the hook is appended to the rc file, its exit status becomes\n    # the exit status of `source $USER_SHELLRC` which typically\n    # indicates if something went wrong. If $DESK_ENV is void, `test`\n    # sets exit status to 1. That, however, is part of desk's normal\n    # operation, so we clear exit status after that.\n    if [ \"$SHELLTYPE\" == \"fish\" ]; then\n      echo \"test -n \\\"\\$DESK_ENV\\\"; and . \\\"\\$DESK_ENV\\\"; or true\" >> \"$USER_SHELLRC\"\n    else\n      echo \"[ -n \\\"\\$DESK_ENV\\\" ] && source \\\"\\$DESK_ENV\\\" || true\" >> \"$USER_SHELLRC\"\n    fi\n\n    echo \"Done. Start adding desks to ${NEW_PREFIX}/desks!\"\n}\n\n\ncmd_go() {\n    # TODESK ($1) may either be\n    #\n    #   - the name of a desk in $DESKS/\n    #   - a path to a Deskfile\n    #   - a directory containing a Deskfile\n    #   - empty -> `./Deskfile`\n    #\n    local TODESK=\"$1\"\n    local DESKEXT=$(get_deskfile_extension)\n    local DESKPATH=\"$(find \"${DESKS}/\" -name \"${TODESK}${DESKEXT}\" 2>/dev/null)\"\n\n    local POSSIBLE_DESKFILE_DIR=\"${TODESK%$DESKFILE_NAME}\"\n    if [ -z \"$POSSIBLE_DESKFILE_DIR\" ]; then\n      POSSIBLE_DESKFILE_DIR=\".\"\n    fi\n\n    # If nothing could be found in $DESKS/, check to see if this is a path to\n    # a Deskfile.\n    if [[ -z \"$DESKPATH\" && -d \"$POSSIBLE_DESKFILE_DIR\" ]]; then\n      if [ ! -f \"${POSSIBLE_DESKFILE_DIR}/${DESKFILE_NAME}\" ]; then\n        echo \"No Deskfile found in '${POSSIBLE_DESKFILE_DIR}'\"\n        exit 1\n      fi\n\n      local REALPATH=$( cd $POSSIBLE_DESKFILE_DIR && pwd )\n      DESKPATH=\"${REALPATH}/${DESKFILE_NAME}\"\n      TODESK=$(basename \"$REALPATH\")\n    fi\n\n    # Shift desk name so we can forward on all arguments to the shell.\n    shift;\n\n    if [ -z \"$DESKPATH\" ]; then\n        echo \"Desk $TODESK (${TODESK}${DESKEXT}) not found in $DESKS\"\n        exit 1\n    else\n        local SHELL_EXEC=\"$(get_running_shell)\"\n        DESK_NAME=\"${TODESK}\" DESK_ENV=\"${DESKPATH}\" exec \"${SHELL_EXEC}\" \"$@\"\n    fi\n}\n\n\ncmd_run() {\n    local TODESK=\"$1\"\n    shift;\n    if [ $# -eq 1 ]; then\n        cmd_go \"$TODESK\" -ic \"$1\"\n    else\n        cmd_go \"$TODESK\" -ic '\"$@\"' -- \"$@\"\n    fi\n}\n\n\n# Usage:        desk list [options]\n# Description:  List all desks along with a description\n# --only-names: List only the names of the desks\n# --no-format:  Use ' - ' to separate names from descriptions\ncmd_list() {\n    if [ ! -d \"${DESKS}/\" ]; then\n        echo \"No desk dir! Run 'desk init'.\"\n        exit 1\n    fi\n    local SHOW_DESCRIPTIONS DESKEXT AUTO_ALIGN name desc len longest out\n\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            --only-names) SHOW_DESCRIPTIONS=false && AUTO_ALIGN=false ;;\n            --no-format) AUTO_ALIGN=false ;;\n        esac\n        shift\n    done\n\n    DESKEXT=$(get_deskfile_extension)\n    out=\"\"\n    longest=0\n\n    while read -d '' -r f; do\n        name=$(basename \"${f/${DESKEXT}//}\")\n        if [[ \"$SHOW_DESCRIPTIONS\" = false ]]; then\n            out+=\"$name\"$'\\n'\n        else\n            desc=$(echo_description \"$f\")\n            out+=\"$name - $desc\"$'\\n'\n            len=${#name}\n            (( len > longest )) && longest=$len\n        fi\n    done < <(find \"${DESKS}/\" -name \"*${DESKEXT}\" -print0)\n    if [[ \"$AUTO_ALIGN\" != false ]]; then\n        print_aligned \"$out\" \"$longest\"\n    else\n        printf \"%s\" \"$out\"\n    fi\n}\n\n# Usage:\t     desk [options]\n# Description: List the current desk and any associated aliases. If no desk is being used, display available desks\n# --no-format: Use ' - ' to separate alias/export/function names from their descriptions\ncmd_current() {\n    if [ -z \"$DESK_ENV\" ]; then\n        printf \"No desk activated.\\n\\n%s\" \"$(cmd_list)\"\n        exit 1\n    fi\n\n    local DESKPATH=$DESK_ENV\n    local CALLABLES=$(get_callables \"$DESKPATH\")\n    local AUTO_ALIGN len longest out\n\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            --no-format) AUTO_ALIGN=false ;;\n        esac\n        shift\n    done\n    printf \"%s - %s\\n\" \"$DESK_NAME\" \"$(echo_description \"$DESKPATH\")\"\n\n    if [[ -n \"$CALLABLES\" ]]; then\n\n        longest=0\n        out=$'\\n'\n        for NAME in $CALLABLES; do\n            # Last clause in the grep regexp accounts for fish functions.\n            len=$((${#NAME} + 2))\n            (( len > longest )) && longest=$len\n            local DOCLINE=$(\n                grep -B 1 -E \\\n                    \"^(alias ${NAME}=|export ${NAME}=|(function )?${NAME}( )?\\()|function $NAME\" \"$DESKPATH\" \\\n                    | grep \"#\")\n\n            if [ -z \"$DOCLINE\" ]; then\n                out+=\"  ${NAME}\"$'\\n'\n            else\n                out+=\"  ${NAME} - ${DOCLINE##\\# }\"$'\\n'\n            fi\n        done\n\n        if [[ \"$AUTO_ALIGN\" != false ]]; then\n          print_aligned \"$out\" \"$longest\"\n        else\n          printf \"%s\" \"$out\"\n        fi\n    fi\n}\n\ncmd_edit() {\n    if [ $# -eq 0 ]; then\n        if [ \"$DESK_NAME\" == \"\" ]; then\n            echo \"No desk activated.\"\n            exit 3\n        fi\n        local DESKNAME_TO_EDIT=\"$DESK_NAME\"\n    elif [ $# -eq 1 ]; then\n        local DESKNAME_TO_EDIT=\"$1\"\n    else\n        echo \"Usage: ${PROGRAM} edit [desk-name]\"\n        exit 1\n    fi\n\n    local DESKEXT=$(get_deskfile_extension)\n    local EDIT_PATH=\"${DESKS}/${DESKNAME_TO_EDIT}${DESKEXT}\"\n\n    ${EDITOR:-vi} \"$EDIT_PATH\"\n}\n\n## Utilities\n\nFNAME_CHARS='[a-zA-Z0-9_-]'\n\n# Echo the description of a desk. $1 is the deskfile.\necho_description() {\n    local descline=$(grep -E \"#\\s+Description\" \"$1\")\n    echo \"${descline##*Description: }\"\n}\n\n# Echo a list of aliases, exports, and functions for a given desk\nget_callables() {\n    local DESKPATH=$1\n    grep -E \"^(alias |export |(function )?${FNAME_CHARS}+ ?\\()|function $NAME\" \"$DESKPATH\" \\\n        | sed 's/alias \\([^= ]*\\)=.*/\\1/' \\\n        | sed 's/export \\([^= ]*\\)=.*/\\1/' \\\n        | sed -E \"s/(function )?(${FNAME_CHARS}+) ?\\(\\).*/\\2/\" \\\n        | sed -E \"s/function (${FNAME_CHARS}+).*/\\1/\"\n}\n\nget_running_shell() {\n    # Echo the name of the parent shell via procfs, if we have it available.\n    # Otherwise, try to use ps with bash's parent pid.\n    if [ -e /proc ]; then\n        # Get cmdline procfile of the process running this script.\n        local CMDLINE_FILE=\"/proc/$(grep PPid /proc/$$/status | cut -f2)/cmdline\"\n\n        if [ -f \"$CMDLINE_FILE\" ]; then\n            # Strip out any verion that may be attached to the shell executable.\n            # Strip leading dash for login shells.\n            local CMDLINE_SHELL=$(sed -r -e 's/\\x0.*//' -e 's/^-//' \"$CMDLINE_FILE\")\n        fi\n    else\n        # Strip leading dash for login shells.\n        # If the parent process is a login shell, guess bash.\n        local CMDLINE_SHELL=$(ps -o comm= -p $PPID | tail -1 | sed -e 's/login/bash/' -e 's/^-//')\n    fi\n\n    if [ ! -z \"$CMDLINE_SHELL\" ]; then\n        basename \"$CMDLINE_SHELL\"\n        exit\n    fi\n\n    # Fall back to $SHELL otherwise.\n    basename \"$SHELL\"\n    exit\n}\n\n# Echo the extension of recognized deskfiles (.fish for fish)\nget_deskfile_extension() {\n    if [ \"$(get_running_shell)\" == \"fish\" ]; then\n        echo '.fish'\n    else\n        echo '.sh'\n    fi\n}\n\n# Echo first argument as key/value pairs aligned into two columns; second argument is the longest key\nprint_aligned() {\n  local out=$1 longest=$2\n  printf \"%s\" \"$out\" | awk -v padding=\"$longest\" -F' - ' '{\n    printf \"%-*s %s\\n\", padding, $1, substr($0, index($0, \" - \")+2, length($0))\n  }'\n}\n\n\nPROGRAM=\"${0##*/}\"\n\ncase \"$1\" in\n    init) shift;               cmd_init \"$@\" ;;\n    help|--help) shift;        cmd_usage \"$@\" ;;\n    version|--version) shift;  cmd_version \"$@\" ;;\n    ls|list) shift;            cmd_list \"$@\" ;;\n    go|.) shift;               cmd_go \"$@\" ;;\n    run) shift;                cmd_run \"$@\" ;;\n    edit) shift;               cmd_edit \"$@\" ;;\n    *)                         cmd_current \"$@\" ;;\nesac\nexit 0\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "screencap.gif",
          "type": "blob",
          "size": 364.482421875,
          "content": null
        },
        {
          "name": "shell_plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}