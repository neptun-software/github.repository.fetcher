{
  "metadata": {
    "timestamp": 1736568217854,
    "page": 71,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "speed47/spectre-meltdown-checker",
      "stars": 3883,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2314453125,
          "content": "FROM alpine:latest\n\nRUN apk --update --no-cache add kmod binutils grep perl zstd wget sharutils unzip sqlite procps coreutils iucode-tool gzip xz bzip2 lz4\n\nCOPY spectre-meltdown-checker.sh /\n\nENTRYPOINT [\"/spectre-meltdown-checker.sh\"]\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 19.9248046875,
          "content": "# Questions\n\n- [What to expect from this tool?](#what-to-expect-from-this-tool)\n- [Why was this script written in the first place?](#why-was-this-script-written-in-the-first-place)\n- [Why are those vulnerabilities so different than regular CVEs?](#why-are-those-vulnerabilities-so-different-than-regular-cves)\n- [What do \"affected\", \"vulnerable\" and \"mitigated\" mean exactly?](#what-do-affected-vulnerable-and-mitigated-mean-exactly)\n- [What are the main design decisions regarding this script?](#what-are-the-main-design-decisions-regarding-this-script)\n- [Everything is indicated in `sysfs` now, is this script still useful?](#everything-is-indicated-in-sysfs-now-is-this-script-still-useful)\n- [How does this script work?](#how-does-this-script-work)\n- [Which BSD OSes are supported?](#which-bsd-oses-are-supported)\n- [Why is my OS not supported?](#why-is-my-os-not-supported)\n- [The tool says there is an updated microcode for my CPU, but I don't have it!](#the-tool-says-there-is-an-updated-microcode-for-my-cpu-but-i-dont-have-it)\n- [The tool says that I need a more up-to-date microcode, but I have the more recent version!](#the-tool-says-that-i-need-a-more-up-to-date-microcode-but-i-have-the-more-recent-version)\n- [Which rules are governing the support of a CVE in this tool?](#which-rules-are-governing-the-support-of-a-cve-in-this-tool)\n\n# Answers\n\n## What to expect from this tool?\n\nThis tool does its best to determine where your system stands on each of the collectively named [transient execution](https://en.wikipedia.org/wiki/Transient_execution_CPU_vulnerability) vulnerabilities (also sometimes called \"speculative execution\" vulnerabilities) that were made public since early 2018. It doesn't attempt to run any kind of exploit, and can't guarantee that your system is secure, but rather helps you verifying if your system is affected, and if it is, checks whether it has the known mitigations in place to avoid being vulnerable.\nSome mitigations could also exist in your kernel that this script doesn't know (yet) how to detect, or it might falsely detect mitigations that in the end don't work as expected (for example, on backported or modified kernels).\n\nPlease also note that for Spectre vulnerabilities, all software can possibly be exploited, this tool only verifies that the kernel (which is the core of the system) you're using has the proper protections in place. Verifying all the other software is out of the scope of this tool. As a general measure, ensure you always have the most up to date stable versions of all the software you use, especially for those who are exposed to the world, such as network daemons and browsers.\n\nThis tool has been released in the hope that it'll be useful, but don't use it to jump to definitive conclusions about your security: hardware vulnerabilities are [complex beasts](#why-are-those-vulnerabilities-so-different-than-regular-cves), and collective understanding of each vulnerability is evolving with time.\n\n## Why was this script written in the first place?\n\nThe first commit of this script is dated *2018-01-07*, only 4 days after the world first heard about the Meltdown and the Spectre attacks. With those attacks disclosure, a _whole new range of vulnerabilities_ that were previously thought to be mostly theoretical and only possible in very controlled environments (labs) - hence of little interest for most except researchers - suddenly became completely mainstream and apparently trivial to conduct on an immensely large number of systems.\n\nOn the few hours and days after that date, the whole industry went crazy. Proper, verified information about these vulnerabilities was incredibly hard to find, because before this, even the CPU vendors never had to deal with managing security vulnerabilities at scale, as software vendors do since decades. There were a lot of FUD, and the apparent silence of the vendors was enough for most to fear the worst. The whole industry had everything to learn about this new type of vulnerabilities. However, most systems administrators had a few simple questions:\n\n- Am **I** vulnerable? And if yes,\n- What do I have to do to mitigate these vulnerabilities on **my** system?\n\nUnfortunately, answering those questions was very difficult (and still is to some extent), even if the safe answer to the first question was \"you probably are\". This script was written to try to give simple answers to those simple questions, and was made to evolve as the information about these vulnerabilities became available. On the first few days, there was several new versions published **per day**.\n\n## Why are those vulnerabilities so different than regular CVEs?\n\nThose are hardware vulnerabilities, while most of the CVEs we see everyday are software vulnerabilities. A quick comparison would be:\n\nSoftware vulnerability:\n- Can be fixed? Yes.\n- How to fix? Update the software (or uninstall it!)\n\nHardware vulnerability:\n- Can be fixed? No, only mitigated (or buy new hardware!)\n- How to ~~fix~~ mitigate? In the worst case scenario, 5 \"layers\" need to be updated: the microcode/firmware, the host OS kernel, the hypervisor, the VM OS kernel, and possibly all the software running on the machine. Sometimes only a subset of those layers need to be updated. In yet other cases, there can be several possible mitigations for the same vulnerability, implying different layers. Yes, it can get horribly complicated.\n\nA more detailed video explanation is available here: https://youtu.be/2gB9U1EcCss?t=425\n\n## What do \"affected\", \"vulnerable\" and \"mitigated\" mean exactly?\n\n- **Affected** means that your CPU's hardware, as it went out of the factory, is known to be concerned by a specific vulnerability, i.e. the vulnerability applies to your hardware model. Note that it says nothing about whether a given vulnerability can actually be used to exploit your system. However, an unaffected CPU will never be vulnerable, and doesn't need to have mitigations in place.\n- **Vulnerable** implies that you're using an **affected** CPU, and means that a given vulnerability can be exploited on your system, because no (or insufficient) mitigations are in place.\n- **Mitigated** implies that a previously **vulnerable** system has followed all the steps (updated all the required layers) to ensure a given vulnerability cannot be exploited. About what \"layers\" mean, see [the previous question](#why-are-those-vulnerabilities-so-different-than-regular-cves).\n\n## What are the main design decisions regarding this script?\n\nThere are a few rules that govern how this tool is written.\n\n1) It should be okay to run this script in a production environment. This implies, but is not limited to:\n\n   * 1a. Never modify the system it's running on, and if it needs to e.g. load a kernel module it requires, that wasn't loaded before it was launched, it'll take care to unload it on exit\n   * 1b. Never attempt to \"fix\" or \"mitigate\" any vulnerability, or modify any configuration. It just reports what it thinks is the status of your system. It leaves all decisions to the sysadmin.\n   * 1c. Never attempt to run any kind of exploit to tell whether a vulnerability is mitigated, because it would violate 1a), could lead to unpredictable system behavior, and might even lead to wrong conclusions, as some PoC must be compiled with specific options and prerequisites, otherwise giving wrong information (especially for Spectre). If you want to run PoCs, do it yourself, but please read carefully about the PoC and the vulnerability. PoCs about a hardware vulnerability are way more complicated and prone to false conclusions than PoCs for software vulnerabilities.\n\n2) Never look at the kernel version to tell whether it supports mitigation for a given vulnerability. This implies never hardcoding version numbers in the script. This would defeat the purpose: this script should be able to detect mitigations in unknown kernels, with possibly backported or forward-ported patches. Also, don't believe what `sysfs` says, when possible. See the next question about this.\n\n3) Never look at the microcode version to tell whether it has the proper mechanisms in place to support mitigation for a given vulnerability. This implies never hardcoding version numbers in the script. Instead, look for said mechanisms, as the kernel would do.\n\n4) When a CPU is not known to be explicitly unaffected by a vulnerability, make the assumption that it is. This strong design choice has it roots in the early speculative execution vulnerability days (see [this answer](#why-was-this-script-written-in-the-first-place)), and is still a good approach as of today.\n\n## Everything is indicated in `sysfs` now, is this script still useful?\n\nA lot as changed since 2018. Nowadays, the industry adapted and this range of vulnerabilities is almost \"business as usual\", as software vulnerabilities are. However, due to their complexity, it's still not as easy as just checking a version number to ensure a vulnerability is closed.\n\nGranted, we now have a standard way under Linux to check whether our system is affected, vulnerable, mitigated against most of these vulnerabilities. By having a look at the `sysfs` hierarchy, and more precisely the `/sys/devices/system/cpu/vulnerabilities/` folder, one can have a pretty good insight about its system state for each of the listed vulnerabilities. Note that the output can be a little different with some vendors (e.g. Red Hat has some slightly different output than the vanilla kernel for some vulnerabilities), but it's still a gigantic leap forward, given where we were in 2018 when this script was started, and it's very good news. The kernel is the proper place to have this because the kernel knows everything about itself (the mitigations it might have), and the CPU (its model, and microcode features that are exposed). Note however that some vulnerabilities are not reported through this file hierarchy at all, such as Zenbleed.\n\nHowever I see a few reasons why this script might still be useful to you, and that's why its development has not halted when the `sysfs` hierarchy came out:\n\n- A given version of the kernel doesn't have knowledge about the future. To put it in another way: a given version of the kernel only has the understanding of a vulnerability available at the time it was compiled. Let me explain this: when a new vulnerability comes out, new versions of the microcode and kernels are released, with mitigations in place. With such a kernel, a new `sysfs` entry will appear. However, after a few weeks or months, corner cases can be discovered, previously-thought unaffected CPUs can turn out to be affected in the end, and sometimes mitigations can end up being insufficient.  Of course, if you're always running the latest kernel version from kernel.org, this issue might be limited for you. The spectre-meltdown-checker script doesn't depend on a kernel's knowledge and understanding of a vulnerability to compute its output. That is, unless you tell it to (using the `--sysfs-only` option).\n\n- Mitigating a vulnerability completely can sometimes be tricky, and have a lot of complicated prerequisites, depending on your kernel version, CPU vendor, model and even sometimes stepping, CPU microcode, hypervisor support, etc. The script gives a very detailed insight about each of the prerequisites of mitigation for every vulnerability, step by step, hence pointing out what is missing on your system as a whole to completely mitigate an issue.\n\n- The script can be pointed at a kernel image, and will deep dive into it, telling you if this kernel will mitigate vulnerabilities that might be present on your system. This is a good way to verify before booting a new kernel, that it'll mitigate the vulnerabilities you expect it to, especially if you modified a few config options around these topics.\n\n- The script will also work regardless of the custom patches that might be integrated in the kernel you're running (or you're pointing it to, in offline mode), and completely ignores the advertised kernel version, to tell whether a given kernel mitigates vulnerabilities. This is especially useful for non-vanilla kernel, where patches might be backported, sometimes silently (this has already happened, too).\n\n- Educational purposes: the script gives interesting insights about a vulnerability, and how the different parts of the system work together to mitigate it.\n\nThere are probably other reasons, but that are the main ones that come to mind. In the end, of course, only you can tell whether it's useful for your use case ;)\n\n## How does this script work?\n\nOn one hand, the script gathers information about your CPU, and the features exposed by its microcode. To do this, it uses the low-level CPUID instruction (through the `cpuid` kernel module under Linux, and the `cpucontrol` tool under BSD), and queries to the MSR registers of your CPU (through the `msr` kernel module under Linux, and the `cpucontrol` tool under BSD).\n\nOn another hand, the script looks into the kernel image your system is running on, for clues about the mitigations it supports. Of course, this is very specific for each operating system, even if the implemented mitigation is functionally the same, the actual code is completely specific. As you can imagine, the Linux kernel code has a few in common with a BSD kernel code, for example. Under Linux, the script supports looking into the kernel image, and possibly the System.map and kernel config file, if these are available. Under BSD, it looks into the kernel file only.\n\nThen, for each vulnerability it knows about, the script decides whether your system is [affected, vulnerable, and mitigated](#what-do-affected-vulnerable-and-mitigated-mean-exactly) against it, using the information it gathered about your hardware and your kernel.\n\n## Which BSD OSes are supported?\n\nFor the BSD range of operating systems, the script will work as long as the BSD you're using supports `cpuctl` and `linprocfs`. This is not the case for OpenBSD for example. Known BSD flavors having proper support are: FreeBSD, NetBSD, DragonflyBSD. Derivatives of those should also work. To know why other BSDs will likely never be supported, see [why is my OS not supported?](#why-is-my-os-not-supported).\n\n## Why is my OS not supported?\n\nThis tool only supports Linux, and [some flavors of BSD](#which-bsd-oses-are-supported). Other OSes will most likely never be supported, due to [how this script works](#how-does-this-script-work). It would require implementing these OSes specific way of querying the CPU. It would also require to get documentation (if available) about how this OS mitigates each vulnerability, down to this OS kernel code, and if documentation is not available, reverse-engineer the difference between a known old version of a kernel, and a kernel that mitigates a new vulnerability. This means that all the effort has to be duplicated times the number of supported OSes, as everything is specific, by construction. It also implies having a deep understanding of every OS, which takes years to develop. However, if/when other tools appear for other OSes, that share the same goal of this one, they might be listed here as a convenience.\n\n## The tool says there is an updated microcode for my CPU, but I don't have it!\n\nEven if your operating system is fully up to date, the tool might still tell you that there is a more recent microcode version for your CPU. Currently, it uses (and merges) information from 4 sources:\n\n- The official [Intel microcode repository](https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files)\n- The awesome platomav's [MCExtractor database](https://github.com/platomav/MCExtractor) for non-Intel CPUs\n- The official [linux-firmware](https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git) repository for AMD\n- Specific Linux kernel commits that sometimes hardcode microcode versions, such as for [Zenbleed](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=522b1d69219d8f083173819fde04f994aa051a98) or for the bad [Spectre](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/cpu/intel.c#n141) microcodes\n\nGenerally, it means a more recent version of the microcode has been seen in the wild. However, fully public availability of this microcode might be limited yet, or your OS vendor might have chosen not to ship this new version (yet), maybe because it's currently being tested, or for other reasons. This tool can't tell you when or if this will be the case. You should ask your vendor about it. Technically, you can still go and upgrade your microcode yourself, and use this tool to confirm whether you did it successfully. Updating the microcode for you is out of the scope of this tool, as this would violate [rule 1b](#what-are-the-main-design-decisions-regarding-this-script).\n\n## The tool says that I need a more up-to-date microcode, but I have the more recent version!\n\nThis can happen for a few reasons:\n\n- Your CPU is no longer supported by the vendor. In that case, new versions of the microcode will never be published, and vulnerabilities requiring microcode features will never be fixed. On most of these vulnerabilities, you'll have no way to mitigate the issue on a vulnerable system, appart from buying a more recent CPU. Sometimes, you might be able to mitigate the issue by disabling a CPU feature instead (often at the cost of speed). When this is the case, the script will list this as one of the possible mitigations for the vulnerability.\n\n- The vulnerability is recent, and your CPU has not yet received a microcode update for the vendor. Often, these updates come in batches, and it can take several batches to cover all the supported CPUs.\n\nIn both cases, you can contact your vendor to know whether there'll be an update or not, and if yes, when. For Intel, at the time this FAQ entry was written, such guidance was [available here](https://software.intel.com/content/www/us/en/develop/topics/software-security-guidance/processors-affected-consolidated-product-cpu-model.html).\n\n## Which rules are governing the support of a CVE in this tool?\n\nOn the early days, it was easy: just Spectre and Meltdown (hence the tool name), because that's all we had. Now that this range of vulnerability is seeing a bunch of newcomers every year, this question is legitimate.\n\nTo stick with this tool's goal, a good indication as to why a CVE should be supported, is when mitigating it requires either kernel modifications, microcode modifications, or both.\n\nCounter-examples include (non-exhaustive list):\n\n- [CVE-2019-14615](https://github.com/speed47/spectre-meltdown-checker/issues/340), mitigating this issue is done by updating the Intel driver. This is out of the scope of this tool.\n- [CVE-2019-15902](https://github.com/speed47/spectre-meltdown-checker/issues/304), this CVE is due to a bad backport in the stable kernel. If the faulty backport was part of the mitigation of another supported CVE, and this bad backport was detectable (without hardcoding kernel versions, see [rule 2](#why-are-those-vulnerabilities-so-different-than-regular-cves)), it might have been added as a bullet point in the concerned CVE's section in the tool. However, this wasn't the case.\n- The \"[Take A Way](https://github.com/speed47/spectre-meltdown-checker/issues/344)\" vulnerability, AMD said that they believe this is not a new attack, hence there were no microcode and no kernel modification made. As there is nothing to look for, this is out of the scope of this tool.\n- [CVE-2020-0550](https://github.com/speed47/spectre-meltdown-checker/issues/347), the vendor thinks this is hardly exploitable in the wild, and as mitigations would be too performance impacting, as a whole the industry decided to not address it. As there is nothing to check for, this is out of the scope of this tool.\n- [CVE-2020-0551](https://github.com/speed47/spectre-meltdown-checker/issues/348), the industry decided to not address it, as it is believed mitigations for other CVEs render this attack practically hard to make, Intel just released an updated SDK for SGX to help mitigate the issue, but this is out of the scope of this tool.\n\nLook for the [information](https://github.com/speed47/spectre-meltdown-checker/issues?q=is%3Aissue+is%3Aopen+label%3Ainformation) tag in the issues list for more examples.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.5888671875,
          "content": "Spectre & Meltdown Checker\n==========================\n\nA shell script to assess your system's resilience against the several [transient execution](https://en.wikipedia.org/wiki/Transient_execution_CPU_vulnerability) CVEs that were published since early 2018, and give you guidance as to how to mitigate them.\n\nCVE                                                                             | Name                                                | Aliases\n------------------------------------------------------------------------------- | --------------------------------------------------- | ---------------------------------\n[CVE-2017-5753](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5754)   | Bounds Check Bypass                                 | Spectre Variant 1\n[CVE-2017-5715](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5715)   | Branch Target Injection                             | Spectre Variant 2\n[CVE-2017-5754](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5754)   | Rogue Data Cache Load                               | Meltdown, Variant 3\n[CVE-2018-3640](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3640)   | Rogue System Register Read                          | Variant 3a\n[CVE-2018-3639](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3639)   | Speculative Store Bypass                            | Variant 4\n[CVE-2018-3615](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3615)   | L1 Terminal Fault                                   | L1TF, Foreshadow (SGX)\n[CVE-2018-3620](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3620)   | L1 Terminal Fault                                   | L1TF, Foreshadow-NG (OS)\n[CVE-2018-3646](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3646)   | L1 Terminal Fault                                   | L1TF, Foreshadow-NG (VMM)\n[CVE-2018-12126](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12126) | Microarchitectural Store Buffer Data Sampling       | MSBDS, Fallout\n[CVE-2018-12130](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12130) | Microarchitectural Fill Buffer Data Sampling        | MFBDS, ZombieLoad\n[CVE-2018-12127](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12127) | Microarchitectural Load Port Data Sampling          | MLPDS, RIDL\n[CVE-2019-11091](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11091) | Microarchitectural Data Sampling Uncacheable Memory | MDSUM, RIDL\n[CVE-2019-11135](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11135) | TSX asynchronous abort                              | TAA, ZombieLoad V2\n[CVE-2018-12207](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12207) | Machine Check Exception on Page Size Changes        | MCEPSC, No eXcuses, iTLB Multihit\n[CVE-2020-0543](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0543)   | Special Register Buffer Data Sampling               | SRBDS\n[CVE-2022-40982](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-40982) | Gather Data Sampling                                | GDS, Downfall\n[CVE-2023-20569](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-20569) | Return Address Security                             | Inception, RAS, SRSO\n[CVE-2023-20593](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-20593) | Cross-Process Information Leak                      | Zenbleed\n[CVE-2023-23583](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-23583) | Redundant Prefix issue                              | Reptar\n\nSupported operating systems:\n- Linux (all versions, flavors and distros)\n- FreeBSD, NetBSD, DragonFlyBSD and derivatives (others BSDs are [not supported](FAQ.md#which-bsd-oses-are-supported))\n\nFor Linux systems, the tool will detect mitigations, including backported non-vanilla patches, regardless of the advertised kernel version number and the distribution (such as Debian, Ubuntu, CentOS, RHEL, Fedora, openSUSE, Arch, ...), it also works if you've compiled your own kernel. More information [here](FAQ.md#how-does-this-script-work).\n\nOther operating systems such as MacOS, Windows, ESXi, etc. [will most likely never be supported](FAQ.md#why-is-my-os-not-supported).\n\nSupported architectures:\n- `x86` (32 bits)\n- `amd64`/`x86_64` (64 bits)\n- `ARM` and `ARM64`\n- other architectures will work, but mitigations (if they exist) might not always be detected\n\n## Frequently Asked Questions (FAQ)\n\n- What is the purpose of this tool?\n- Why was it written?\n- How can it be useful to me?\n- How does it work?\n- What can I expect from it?\n\nAll these questions (and more) have detailed answers in the [FAQ](FAQ.md), please have a look!\n\n## Easy way to run the script\n\n- Get the latest version of the script using `curl` *or* `wget`\n\n```bash\ncurl -L https://meltdown.ovh -o spectre-meltdown-checker.sh\nwget https://meltdown.ovh -O spectre-meltdown-checker.sh\n```\n\n- Inspect the script. You never blindly run scripts you downloaded from the Internet, do you?\n\n```bash\nvim spectre-meltdown-checker.sh\n```\n\n- When you're ready, run the script as root\n\n```bash\nchmod +x spectre-meltdown-checker.sh\nsudo ./spectre-meltdown-checker.sh\n```\n\n### Run the script in a docker container\n\n#### With docker-compose\n\n```shell\ndocker compose build\ndocker compose run --rm spectre-meltdown-checker\n```\n\nNote that on older versions of docker, `docker-compose` is a separate command, so you might\nneed to replace the two `docker compose` occurences above by `docker-compose`.\n\n#### Without docker-compose\n\n```shell\ndocker build -t spectre-meltdown-checker .\ndocker run --rm --privileged -v /boot:/boot:ro -v /dev/cpu:/dev/cpu:ro -v /lib/modules:/lib/modules:ro spectre-meltdown-checker\n```\n\n## Example of script output\n\n- Intel Haswell CPU running under Ubuntu 16.04 LTS\n\n![haswell](https://user-images.githubusercontent.com/218502/108764885-6dcfc380-7553-11eb-81ac-4d19060a3acf.png)\n\n- AMD Ryzen running under OpenSUSE Tumbleweed\n\n![ryzen](https://user-images.githubusercontent.com/218502/108764896-70321d80-7553-11eb-9dd2-fad2a0a1a737.png)\n\n- Batch mode (JSON flavor)\n\n![batch](https://user-images.githubusercontent.com/218502/108764902-71634a80-7553-11eb-9678-fd304995fa64.png)\n\n## Quick summary of the CVEs\n\n**CVE-2017-5753** bounds check bypass (Spectre Variant 1)\n\n   - Impact: Kernel & all software\n   - Mitigation: recompile software *and* kernel with a modified compiler that introduces the LFENCE opcode at the proper positions in the resulting code\n   - Performance impact of the mitigation: negligible\n\n**CVE-2017-5715** branch target injection (Spectre Variant 2)\n\n   - Impact: Kernel\n   - Mitigation 1: new opcode via microcode update that should be used by up to date compilers to protect the BTB (by flushing indirect branch predictors)\n   - Mitigation 2: introducing \"retpoline\" into compilers, and recompile software/OS with it\n   - Performance impact of the mitigation: high for mitigation 1, medium for mitigation 2, depending on your CPU\n\n**CVE-2017-5754** rogue data cache load (Meltdown)\n\n   - Impact: Kernel\n   - Mitigation: updated kernel (with PTI/KPTI patches), updating the kernel is enough\n   - Performance impact of the mitigation: low to medium\n\n**CVE-2018-3640** rogue system register read (Variant 3a)\n\n   - Impact: TBC\n   - Mitigation: microcode update only\n   - Performance impact of the mitigation: negligible\n\n**CVE-2018-3639** speculative store bypass (Variant 4)\n\n   - Impact: software using JIT (no known exploitation against kernel)\n   - Mitigation: microcode update + kernel update making possible for affected software to protect itself\n   - Performance impact of the mitigation: low to medium\n\n**CVE-2018-3615** l1 terminal fault (Foreshadow-NG SGX)\n\n   - Impact: Kernel & all software (any physical memory address in the system)\n   - Mitigation: microcode update\n   - Performance impact of the mitigation: negligible\n\n**CVE-2018-3620** l1 terminal fault (Foreshadow-NG SMM)\n\n   - Impact: Kernel & System management mode\n   - Mitigation: updated kernel (with PTE inversion)\n   - Performance impact of the mitigation: negligible\n\n**CVE-2018-3646** l1 terminal fault (Foreshadow-NG VMM)\n\n   - Impact: Virtualization software and Virtual Machine Monitors\n   - Mitigation: disable ept (extended page tables), disable hyper-threading (SMT), or updated kernel (with L1d flush)\n   - Performance impact of the mitigation: low to significant\n\n**CVE-2018-12126** [MSBDS] Microarchitectural Store Buffer Data Sampling (Fallout)\n\n**CVE-2018-12130** [MFBDS] Microarchitectural Fill Buffer Data Sampling (ZombieLoad)\n\n**CVE-2018-12127** [MLPDS] Microarchitectural Load Port Data Sampling (RIDL)\n\n**CVE-2019-11091** [MDSUM] Microarchitectural Data Sampling Uncacheable Memory (RIDL)\n\n   - Note: These 4 CVEs are similar and collectively named \"MDS\" vulnerabilities, the mitigation is identical for all\n   - Impact: Kernel\n   - Mitigation: microcode update + kernel update making possible to protect various CPU internal buffers from unprivileged speculative access to data\n   - Performance impact of the mitigation: low to significant\n\n**CVE-2019-11135** TSX Asynchronous Abort (TAA, ZombieLoad V2)\n\n   - Impact: Kernel\n   - Mitigation: microcode update + kernel update making possible to protect various CPU internal buffers from unprivileged speculative access to data\n   - Performance impact of the mitigation: low to significant\n\n**CVE-2018-12207** machine check exception on page size changes (No eXcuses, iTLB Multihit)\n\n   - Impact: Virtualization software and Virtual Machine Monitors\n   - Mitigation: disable hugepages use in hypervisor, or update hypervisor to benefit from mitigation\n   - Performance impact of the mitigation: low to significant\n\n**CVE-2020-0543** Special Register Buffer Data Sampling (SRBDS)\n\n   - Impact: Kernel\n   - Mitigation: microcode update + kernel update helping to protect various CPU internal buffers from unprivileged speculative access to data\n   - Performance impact of the mitigation: low\n\n**CVE-2022-40982** Gather Data Sampling (GDS, Downfall)\n\n   - Impact: Kernel & all software\n   - Mitigation: either microcode update or disabling AVX feature\n   - Performance impact of the mitigation: TBD\n\n**CVE-2023-20569** Return Address Security (Inception)\n\n   - Impact: Kernel & all software\n   - Mitigation: updated kernel & microcode\n   - Performance impact of the mitigation: low to significant depending on the mitigation\n\n**CVE-2023-20593** Cross-Process Information Leak (Zenbleed)\n\n   - Impact: Kernel & all software\n   - Mitigation: either kernel mitigation by disabling a CPU optimization through an MSR bit, or CPU microcode mitigation\n   - Performance impact of the mitigation: TBD\n\n**CVE-2023-23583** Redundant Prefix issue (Reptar)\n\n   - Impact: All software\n   - Mitigation: microcode update for the affected CPU\n   - Performance impact of the mitigation: low\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.32421875,
          "content": "services:\n  spectre-meltdown-checker:\n    build:\n      context: ./\n      dockerfile: ./Dockerfile\n    image: spectre-meltdown-checker:latest\n    container_name: spectre-meltdown-checker\n    privileged: true\n    network_mode: none\n    volumes:\n      - /boot:/boot:ro\n      - /dev/cpu:/dev/cpu:ro\n      - /lib/modules:/lib/modules:ro\n"
        },
        {
          "name": "spectre-meltdown-checker.sh",
          "type": "blob",
          "size": 288.4765625,
          "content": "#! /bin/sh\n# SPDX-License-Identifier: GPL-3.0-only\n# vim: set ts=4 sw=4 sts=4 noet:\n#\n# Spectre & Meltdown checker\n#\n# Check for the latest version at:\n# https://github.com/speed47/spectre-meltdown-checker\n# git clone https://github.com/speed47/spectre-meltdown-checker.git\n# or wget https://meltdown.ovh -O spectre-meltdown-checker.sh\n# or curl -L https://meltdown.ovh -o spectre-meltdown-checker.sh\n#\n# Stephane Lesimple\n#\nVERSION='0.46+'\n\ntrap 'exit_cleanup' EXIT\ntrap '_warn \"interrupted, cleaning up...\"; exit_cleanup; exit 1' INT\nexit_cleanup()\n{\n\tsaved_ret=$?\n\t# cleanup the temp decompressed config & kernel image\n\t[ -n \"${dumped_config:-}\" ] && [ -f \"$dumped_config\" ] && rm -f \"$dumped_config\"\n\t[ -n \"${kerneltmp:-}\"     ] && [ -f \"$kerneltmp\"     ] && rm -f \"$kerneltmp\"\n\t[ -n \"${kerneltmp2:-}\"    ] && [ -f \"$kerneltmp2\"    ] && rm -f \"$kerneltmp2\"\n\t[ -n \"${mcedb_tmp:-}\"     ] && [ -f \"$mcedb_tmp\"     ] && rm -f \"$mcedb_tmp\"\n\t[ -n \"${intel_tmp:-}\"     ] && [ -d \"$intel_tmp\"     ] && rm -rf \"$intel_tmp\"\n\t[ -n \"${linuxfw_tmp:-}\"   ] && [ -f \"$linuxfw_tmp\"   ] && rm -f \"$linuxfw_tmp\"\n\t[ \"${mounted_debugfs:-}\" = 1 ] && umount /sys/kernel/debug 2>/dev/null\n\t[ \"${mounted_procfs:-}\"  = 1 ] && umount \"$procfs\" 2>/dev/null\n\t[ \"${insmod_cpuid:-}\"    = 1 ] && rmmod cpuid 2>/dev/null\n\t[ \"${insmod_msr:-}\"      = 1 ] && rmmod msr 2>/dev/null\n\t[ \"${kldload_cpuctl:-}\"  = 1 ] && kldunload cpuctl 2>/dev/null\n\t[ \"${kldload_vmm:-}\"     = 1 ] && kldunload vmm    2>/dev/null\n\texit $saved_ret\n}\n\n# if we were git clone'd, adjust VERSION\nif [ -d \"$(dirname \"$0\")/.git\" ] && command -v git >/dev/null 2>&1; then\n\tdescribe=$(git -C \"$(dirname \"$0\")\" describe --tags --dirty 2>/dev/null)\n\t[ -n \"$describe\" ] && VERSION=$(echo \"$describe\" | sed -e s/^v//)\nfi\n\nshow_usage()\n{\n\t# shellcheck disable=SC2086\n\tcat <<EOF\n\tUsage:\n\t\tLive mode (auto):   $(basename $0) [options]\n\t\tLive mode (manual): $(basename $0) [options] <[--kernel <kimage>] [--config <kconfig>] [--map <mapfile>]> --live\n\t\tOffline mode:       $(basename $0) [options] <[--kernel <kimage>] [--config <kconfig>] [--map <mapfile>]>\n\n\tModes:\n\t\tTwo modes are available.\n\n\t\tFirst mode is the \"live\" mode (default), it does its best to find information about the currently running kernel.\n\t\tTo run under this mode, just start the script without any option (you can also use --live explicitly)\n\n\t\tSecond mode is the \"offline\" mode, where you can inspect a non-running kernel.\n\t\tThis mode is automatically enabled when you specify the location of the kernel file, config and System.map files:\n\n\t\t--kernel kernel_file\tspecify a (possibly compressed) Linux or BSD kernel file\n\t\t--config kernel_config\tspecify a kernel config file (Linux only)\n\t\t--map kernel_map_file\tspecify a kernel System.map file (Linux only)\n\n\t\tIf you want to use live mode while specifying the location of the kernel, config or map file yourself,\n\t\tyou can add --live to the above options, to tell the script to run in live mode instead of the offline mode,\n\t\twhich is enabled by default when at least one file is specified on the command line.\n\n\tOptions:\n\t\t--no-color\t\tdon't use color codes\n\t\t--verbose, -v\t\tincrease verbosity level, possibly several times\n\t\t--explain\t\tproduce an additional human-readable explanation of actions to take to mitigate a vulnerability\n\t\t--paranoid\t\trequire IBPB to deem Variant 2 as mitigated\n\t\t\t\t\talso require SMT disabled + unconditional L1D flush to deem Foreshadow-NG VMM as mitigated\n\t\t\t\t\talso require SMT disabled to deem MDS vulnerabilities mitigated\n\n\t\t--no-sysfs\t\tdon't use the /sys interface even if present [Linux]\n\t\t--sysfs-only\t\tonly use the /sys interface, don't run our own checks [Linux]\n\t\t--coreos\t\tspecial mode for CoreOS (use an ephemeral toolbox to inspect kernel) [Linux]\n\n\t\t--arch-prefix PREFIX\tspecify a prefix for cross-inspecting a kernel of a different arch, for example \"aarch64-linux-gnu-\",\n\t\t\t\t\tso that invoked tools will be prefixed with this (i.e. aarch64-linux-gnu-objdump)\n\t\t--batch text\t\tproduce machine readable output, this is the default if --batch is specified alone\n\t\t--batch short\t\tproduce only one line with the vulnerabilities separated by spaces\n\t\t--batch json\t\tproduce JSON output formatted for Puppet, Ansible, Chef...\n\t\t--batch nrpe\t\tproduce machine readable output formatted for NRPE\n\t\t--batch prometheus      produce output for consumption by prometheus-node-exporter\n\n\t\t--variant VARIANT\tspecify which variant you'd like to check, by default all variants are checked.\n\t\t\t\t\tcan be used multiple times (e.g. --variant 3a --variant l1tf)\n\t\t\t\t\tfor a list of supported VARIANT parameters, use --variant help\n\t\t--cve CVE\t\tspecify which CVE you'd like to check, by default all supported CVEs are checked\n\t\t\t\t\tcan be used multiple times (e.g. --cve CVE-2017-5753 --cve CVE-2020-0543)\n\t\t--hw-only\t\tonly check for CPU information, don't check for any variant\n\t\t--no-hw\t\t\tskip CPU information and checks, if you're inspecting a kernel not to be run on this host\n\t\t--vmm [auto,yes,no]\toverride the detection of the presence of a hypervisor, default: auto\n\t\t--no-intel-db\t\tdon't use the builtin Intel DB of affected processors\n\t\t--allow-msr-write\tallow probing for write-only MSRs, this might produce kernel logs or be blocked by your system\n\t\t--cpu [#,all]\t\tinteract with CPUID and MSR of CPU core number #, or all (default: CPU core 0)\n\t\t--update-fwdb\t\tupdate our local copy of the CPU microcodes versions database (using the awesome\n\t\t\t\t\tMCExtractor project and the Intel firmwares GitHub repository)\n\t\t--update-builtin-fwdb\tsame as --update-fwdb but update builtin DB inside the script itself\n\t\t--dump-mock-data\tused to mimick a CPU on an other system, mainly used to help debugging this script\n\n\tReturn codes:\n\t\t0 (not vulnerable), 2 (vulnerable), 3 (unknown), 255 (error)\n\n\tIMPORTANT:\n\tA false sense of security is worse than no security at all.\n\tPlease use the --disclaimer option to understand exactly what this script does.\n\nEOF\n}\n\nshow_disclaimer()\n{\n\tcat <<EOF\nDisclaimer:\n\nThis tool does its best to determine whether your system is immune (or has proper mitigations in place) for the\ncollectively named \"transient execution\" (aka \"speculative execution\") vulnerabilities that started to appear\nsince early 2018 with the infamous Spectre & Meltdown.\n\nThis tool does NOT attempt to run any kind of exploit, and can't 100% guarantee that your system is secure,\nbut rather helps you verifying whether your system has the known correct mitigations in place.\nHowever, some mitigations could also exist in your kernel that this script doesn't know (yet) how to detect, or it might\nfalsely detect mitigations that in the end don't work as expected (for example, on backported or modified kernels).\n\nYour system affectability to a given vulnerability depends on your CPU model and CPU microcode version, whereas the\nmitigations in place depend on your CPU (model and microcode), your kernel version, and both the runtime configuration\nof your CPU (through bits set through the MSRs) and your kernel. The script attempts to explain everything for each\nvulnerability, so you know where your system stands. For a given vulnerability, detailed information is sometimes\navailable using the \\`--explain\\` switch.\n\nPlease also note that for the Spectre-like vulnerabilities, all software can possibly be exploited, in which case\nthis tool only verifies that the kernel (which is the core of the system) you're using has the proper protections\nin place. Verifying all the other software is out of the scope of this tool, as it can't be done in a simple way.\nAs a general measure, ensure you always have the most up to date stable versions of all the software you use,\nespecially for those who are exposed to the world, such as network daemons and browsers.\n\nFor more information and answers to related questions, please refer to the FAQ.md file.\n\nThis tool has been released in the hope that it'll be useful, but don't use it to jump to conclusions about your security.\n\nEOF\n}\n\nos=$(uname -s)\n\n# parse options\nopt_kernel=''\nopt_config=''\nopt_map=''\nopt_live=-1\nopt_no_color=0\nopt_batch=0\nopt_batch_format='text'\nopt_verbose=1\nopt_cve_list=''\nopt_cve_all=1\nopt_no_sysfs=0\nopt_sysfs_only=0\nopt_coreos=0\nopt_arch_prefix=''\nopt_hw_only=0\nopt_no_hw=0\nopt_vmm=-1\nopt_allow_msr_write=0\nopt_cpu=0\nopt_explain=0\nopt_paranoid=0\nopt_mock=0\nopt_intel_db=1\n\nglobal_critical=0\nglobal_unknown=0\nnrpe_vuln=''\n\nsupported_cve_list='\nCVE-2017-5753\nCVE-2017-5715\nCVE-2017-5754\nCVE-2018-3640\nCVE-2018-3639\nCVE-2018-3615\nCVE-2018-3620\nCVE-2018-3646\nCVE-2018-12126\nCVE-2018-12130\nCVE-2018-12127\nCVE-2019-11091\nCVE-2019-11135\nCVE-2018-12207\nCVE-2020-0543\nCVE-2023-20593\nCVE-2022-40982\nCVE-2023-20569\nCVE-2023-23583'\n\n# find a sane command to print colored messages, we prefer `printf` over `echo`\n# because `printf` behavior is more standard across Linux/BSD\n# we'll try to avoid using shell builtins that might not take options\necho_cmd_type='echo'\n# ignore SC2230 here because `which` ignores builtins while `command -v` doesn't, and\n# we don't want builtins here. Even if `which` is not installed, we'll fallback to the\n# `echo` builtin anyway, so this is safe.\n# shellcheck disable=SC2230\nif command -v printf >/dev/null 2>&1; then\n\techo_cmd=$(command -v printf)\n\techo_cmd_type='printf'\nelif which echo >/dev/null 2>&1; then\n\techo_cmd=$(which echo)\nelse\n\t# maybe the `which` command is broken?\n\t[ -x /bin/echo        ] && echo_cmd=/bin/echo\n\t# for Android\n\t[ -x /system/bin/echo ] && echo_cmd=/system/bin/echo\nfi\n# still empty? fallback to builtin\n[ -z \"$echo_cmd\" ] && echo_cmd='echo'\n__echo()\n{\n\topt=\"$1\"\n\tshift\n\t_msg=\"$*\"\n\n\tif [ \"$opt_no_color\" = 1 ] ; then\n\t\t# strip ANSI color codes\n\t\t# some sed versions (i.e. toybox) can't seem to handle\n\t\t# \\033 aka \\x1B correctly, so do it for them.\n\t\tif [ \"$echo_cmd_type\" = printf ]; then\n\t\t\t_interpret_chars=''\n\t\telse\n\t\t\t_interpret_chars='-e'\n\t\tfi\n\t\t_ctrlchar=$($echo_cmd $_interpret_chars \"\\033\")\n\t\t_msg=$($echo_cmd $_interpret_chars \"$_msg\" | sed -r \"s/$_ctrlchar\\[([0-9][0-9]?(;[0-9][0-9]?)?)?m//g\")\n\tfi\n\tif [ \"$echo_cmd_type\" = printf ]; then\n\t\tif [ \"$opt\" = \"-n\" ]; then\n\t\t\t$echo_cmd \"$_msg\"\n\t\telse\n\t\t\t$echo_cmd \"$_msg\\n\"\n\t\tfi\n\telse\n\t\t# shellcheck disable=SC2086\n\t\t$echo_cmd $opt -e \"$_msg\"\n\tfi\n}\n\n_echo()\n{\n\tif [ \"$opt_verbose\" -ge \"$1\" ]; then\n\t\tshift\n\t\t__echo '' \"$*\"\n\tfi\n}\n\n_echo_nol()\n{\n\tif [ \"$opt_verbose\" -ge \"$1\" ]; then\n\t\tshift\n\t\t__echo -n \"$*\"\n\tfi\n}\n\n_warn()\n{\n\t_echo 0 \"\\033[31m$*\\033[0m\" >&2\n}\n\n_info()\n{\n\t_echo 1 \"$*\"\n}\n\n_info_nol()\n{\n\t_echo_nol 1 \"$*\"\n}\n\n_verbose()\n{\n\t_echo 2 \"$*\"\n}\n\n_verbose_nol()\n{\n\t_echo_nol 2 \"$*\"\n}\n\n_debug()\n{\n\t_echo 3 \"\\033[34m(debug) $*\\033[0m\"\n}\n\nexplain()\n{\n\tif [ \"$opt_explain\" = 1 ] ; then\n\t\t_info ''\n\t\t_info \"> \\033[41m\\033[30mHow to fix:\\033[0m $*\"\n\tfi\n}\n\ncve2name()\n{\n\tcase \"$1\" in\n\t\tCVE-2017-5753)\techo \"Spectre Variant 1, bounds check bypass\";;\n\t\tCVE-2017-5715)\techo \"Spectre Variant 2, branch target injection\";;\n\t\tCVE-2017-5754)\techo \"Variant 3, Meltdown, rogue data cache load\";;\n\t\tCVE-2018-3640)\techo \"Variant 3a, rogue system register read\";;\n\t\tCVE-2018-3639)\techo \"Variant 4, speculative store bypass\";;\n\t\tCVE-2018-3615)\techo \"Foreshadow (SGX), L1 terminal fault\";;\n\t\tCVE-2018-3620)\techo \"Foreshadow-NG (OS), L1 terminal fault\";;\n\t\tCVE-2018-3646)\techo \"Foreshadow-NG (VMM), L1 terminal fault\";;\n\t\tCVE-2018-12126) echo \"Fallout, microarchitectural store buffer data sampling (MSBDS)\";;\n\t\tCVE-2018-12130) echo \"ZombieLoad, microarchitectural fill buffer data sampling (MFBDS)\";;\n\t\tCVE-2018-12127) echo \"RIDL, microarchitectural load port data sampling (MLPDS)\";;\n\t\tCVE-2019-11091) echo \"RIDL, microarchitectural data sampling uncacheable memory (MDSUM)\";;\n\t\tCVE-2019-11135) echo \"ZombieLoad V2, TSX Asynchronous Abort (TAA)\";;\n\t\tCVE-2018-12207) echo \"No eXcuses, iTLB Multihit, machine check exception on page size changes (MCEPSC)\";;\n\t\tCVE-2020-0543) echo \"Special Register Buffer Data Sampling (SRBDS)\";;\n\t\tCVE-2023-20593) echo \"Zenbleed, cross-process information leak\";;\n\t\tCVE-2022-40982) echo \"Downfall, gather data sampling (GDS)\";;\n\t\tCVE-2023-20569) echo \"Inception, return address security (RAS)\";;\n\t\tCVE-2023-23583) echo \"Reptar, redundant prefix issue\";;\n\t\t*) echo \"$0: error: invalid CVE '$1' passed to cve2name()\" >&2; exit 255;;\n\tesac\n}\n\nis_cpu_affected_cached=0\n_is_cpu_affected_cached()\n{\n\t# shellcheck disable=SC2086\n\tcase \"$1\" in\n\t\tCVE-2017-5753) return $variant1;;\n\t\tCVE-2017-5715) return $variant2;;\n\t\tCVE-2017-5754) return $variant3;;\n\t\tCVE-2018-3640) return $variant3a;;\n\t\tCVE-2018-3639) return $variant4;;\n\t\tCVE-2018-3615) return $variantl1tf_sgx;;\n\t\tCVE-2018-3620) return $variantl1tf;;\n\t\tCVE-2018-3646) return $variantl1tf;;\n\t\tCVE-2018-12126) return $variant_msbds;;\n\t\tCVE-2018-12130) return $variant_mfbds;;\n\t\tCVE-2018-12127) return $variant_mlpds;;\n\t\tCVE-2019-11091) return $variant_mdsum;;\n\t\tCVE-2019-11135) return $variant_taa;;\n\t\tCVE-2018-12207) return $variant_itlbmh;;\n\t\tCVE-2020-0543) return $variant_srbds;;\n\t\tCVE-2023-20593) return $variant_zenbleed;;\n\t\tCVE-2022-40982) return $variant_downfall;;\n\t\tCVE-2023-20569) return $variant_inception;;\n\t\tCVE-2023-23583) return $variant_reptar;;\n\t\t*) echo \"$0: error: invalid variant '$1' passed to is_cpu_affected()\" >&2; exit 255;;\n\tesac\n}\n\nis_cpu_affected()\n{\n\t# param: one of the $supported_cve_list items\n\t# returns 0 if affected, 1 if not affected\n\t# (note that in shell, a return of 0 is success)\n\t# by default, everything is affected, we work in a \"whitelist\" logic here.\n\t# usage: is_cpu_affected CVE-xxxx-yyyy && do something if affected\n\n\t# if CPU is Intel and is in our dump of the Intel official affected CPUs page, use it:\n\tif is_intel; then\n\t\tcpuid_hex=$(printf \"0x%08X\" $(( cpu_cpuid )) )\n\t\tif [ \"${intel_line:-}\" = \"no\" ]; then\n\t\t\t_debug \"is_cpu_affected: $cpuid_hex not in Intel database (cached)\"\n\t\telif [ -z \"$intel_line\" ]; then\n\t\t\tintel_line=$(read_inteldb | grep -F \"$cpuid_hex,\" | head -n1)\n\t\t\tif [ -z \"$intel_line\" ]; then\n\t\t\t\tintel_line=no\n\t\t\t\t_debug \"is_cpu_affected: $cpuid_hex not in Intel database\"\n\t\t\tfi\n\t\tfi\n\t\tif [ \"$intel_line\" != \"no\" ]; then\n\t\t\t_result=$(echo \"$intel_line\" | grep -Eo ,\"$(echo \"$1\" | cut -c5-)\"'=[^,]+' | cut -d= -f2)\n\t\t\t_debug \"is_cpu_affected: inteldb for $1 says '$_result'\"\n\n\t\t\t# handle special case for Foreshadow SGX (CVE-2018-3615):\n\t\t\t# even if we are affected to L1TF (CVE-2018-3620/CVE-2018-3646), if there's no SGX on our CPU,\n\t\t\t# then we're not affected to the original Foreshadow.\n\t\t\tif [ \"$1\" = \"CVE-2018-3615\" ] && [ \"$cpuid_sgx\" = 0 ]; then\n\t\t\t\t# not affected\n\t\t\t\treturn 1\n\t\t\tfi\n\t\t\t# /special case\n\n\t\t\tif [ \"$_result\" = \"N\" ]; then\n\t\t\t\t# not affected\n\t\t\t\treturn 1\n\t\t\telif [ -n \"$_result\" ]; then\n\t\t\t\t# non-empty string != N means affected\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tfi\n\n\t# Otherwise, do it ourselves\n\n\tif [ \"$is_cpu_affected_cached\" = 1 ]; then\n\t\t_is_cpu_affected_cached \"$1\"\n\t\treturn $?\n\tfi\n\n\tvariant1=''\n\tvariant2=''\n\tvariant3=''\n\tvariant3a=''\n\tvariant4=''\n\tvariantl1tf=''\n\tvariant_msbds=''\n\tvariant_mfbds=''\n\tvariant_mlpds=''\n\tvariant_mdsum=''\n\tvariant_taa=''\n\tvariant_itlbmh=''\n\tvariant_srbds=''\n\t# Zenbleed and Inception are both AMD specific, look for \"is_amd\" below:\n\tvariant_zenbleed=immune\n\tvariant_inception=immune\n\t# Downfall & Reptar are Intel specific, look for \"is_intel\" below:\n\tvariant_downfall=immune\n\tvariant_reptar=immune\n\n\tif is_cpu_mds_free; then\n\t\t[ -z \"$variant_msbds\" ] && variant_msbds=immune\n\t\t[ -z \"$variant_mfbds\" ] && variant_mfbds=immune\n\t\t[ -z \"$variant_mlpds\" ] && variant_mlpds=immune\n\t\t[ -z \"$variant_mdsum\" ] && variant_mdsum=immune\n\t\t_debug \"is_cpu_affected: cpu not affected by Microarchitectural Data Sampling\"\n\tfi\n\n\tif is_cpu_taa_free; then\n\t\t[ -z \"$variant_taa\" ] && variant_taa=immune\n\t\t_debug \"is_cpu_affected: cpu not affected by TSX Asynhronous Abort\"\n\tfi\n\n\tif is_cpu_srbds_free; then\n\t\t[ -z \"$variant_srbds\" ] && variant_srbds=immune\n\t\t_debug \"is_cpu_affected: cpu not affected by Special Register Buffer Data Sampling\"\n\tfi\n\n\tif is_cpu_specex_free; then\n\t\tvariant1=immune\n\t\tvariant2=immune\n\t\tvariant3=immune\n\t\tvariant3a=immune\n\t\tvariant4=immune\n\t\tvariantl1tf=immune\n\t\tvariant_msbds=immune\n\t\tvariant_mfbds=immune\n\t\tvariant_mlpds=immune\n\t\tvariant_mdsum=immune\n\t\tvariant_taa=immune\n\t\tvariant_srbds=immune\n\telif is_intel; then\n\t\t# Intel\n\t\t# https://github.com/crozone/SpectrePoC/issues/1 ^F E5200 => spectre 2 not affected\n\t\t# https://github.com/paboldin/meltdown-exploit/issues/19 ^F E5200 => meltdown affected\n\t\t# model name : Pentium(R) Dual-Core  CPU      E5200  @ 2.50GHz\n\t\tif echo \"$cpu_friendly_name\" | grep -qE 'Pentium\\(R\\) Dual-Core[[:space:]]+CPU[[:space:]]+E[0-9]{4}K?'; then\n\t\t\tvariant1=vuln\n\t\t\t[ -z \"$variant2\" ] && variant2=immune\n\t\t\tvariant3=vuln\n\t\tfi\n\t\tif [ \"$capabilities_rdcl_no\" = 1 ]; then\n\t\t\t# capability bit for future Intel processor that will explicitly state\n\t\t\t# that they're not affected to Meltdown\n\t\t\t# this var is set in check_cpu()\n\t\t\t[ -z \"$variant3\" ]    && variant3=immune\n\t\t\t[ -z \"$variantl1tf\" ] && variantl1tf=immune\n\t\t\t_debug \"is_cpu_affected: RDCL_NO is set so not vuln to meltdown nor l1tf\"\n\t\tfi\n\t\tif [ \"$capabilities_ssb_no\" = 1 ]; then\n\t\t\t# capability bit for future Intel processor that will explicitly state\n\t\t\t# that they're not affected to Variant 4\n\t\t\t# this var is set in check_cpu()\n\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t_debug \"is_cpu_affected: SSB_NO is set so not vuln to variant4\"\n\t\tfi\n\t\tif is_cpu_ssb_free; then\n\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t_debug \"is_cpu_affected: cpu not affected by speculative store bypass so not vuln to variant4\"\n\t\tfi\n\t\t# variant 3a\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNL\" ] || [ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNM\" ]; then\n\t\t\t\t_debug \"is_cpu_affected: xeon phi immune to variant 3a\"\n\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\telif [ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_D\" ]; then\n\t\t\t\t\t# https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00115.html\n\t\t\t\t\t# https://github.com/speed47/spectre-meltdown-checker/issues/310\n\t\t\t\t\t# => silvermont CPUs (aka cherry lake for tablets and brawsell for mobile/desktop) don't seem to be affected\n\t\t\t\t\t# => goldmont ARE affected\n\t\t\t\t\t_debug \"is_cpu_affected: silvermont immune to variant 3a\"\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\tfi\n\t\tfi\n\t\t# L1TF (RDCL_NO already checked above)\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL\"          ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL_TABLET\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_BONNELL\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_BONNELL_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_AIRMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_AIRMONT_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_AIRMONT_NP\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT_PLUS\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_TREMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNL\"     ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNM\" ]; then\n\n\t\t\t\t_debug \"is_cpu_affected: intel family 6 but model known to be immune to l1tf\"\n\t\t\t\t[ -z \"$variantl1tf\" ] && variantl1tf=immune\n\t\t\telse\n\t\t\t\t_debug \"is_cpu_affected: intel family 6 is vuln to l1tf\"\n\t\t\t\tvariantl1tf=vuln\n\t\t\tfi\n\t\telif [ \"$cpu_family\" -lt 6 ]; then\n\t\t\t_debug \"is_cpu_affected: intel family < 6 is immune to l1tf\"\n\t\t\t[ -z \"$variantl1tf\" ] && variantl1tf=immune\n\t\tfi\n\t\t# Downfall\n\t\tif [ \"$capabilities_gds_no\" = 1 ]; then\n\t\t\t# capability bit for future Intel processors that will explicitly state\n\t\t\t# that they're unaffected by GDS. Also set by hypervisors on virtual CPUs\n\t\t\t# so that the guest kernel doesn't try to mitigate GDS when it's already mitigated on the host\n\t\t\t_debug \"is_cpu_affected: downfall: not affected (GDS_NO)\"\n\t\telif [ \"$cpu_family\" = 6 ]; then\n\t\t\t# list from https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64094e7e3118aff4b0be8ff713c242303e139834\n\t\t\tset -u\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_SKYLAKE_X\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_KABYLAKE_L\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_KABYLAKE\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ICELAKE_L\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ICELAKE_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ICELAKE_X\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_COMETLAKE\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_COMETLAKE_L\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_TIGERLAKE_L\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_TIGERLAKE\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ROCKETLAKE\" ]; then\n\t\t\t\t_debug \"is_cpu_affected: downfall: affected\"\n\t\t\t\tvariant_downfall=vuln\n\t\t\telif [ \"$has_avx2\" = 0 ] && [ \"$has_avx512\" = 0 ]; then\n\t\t\t\t_debug \"is_cpu_affected: downfall: no avx; immune\"\n\t\t\telse\n\t\t\t\t# old Intel CPU (not in their DB), not listed as being affected by the Linux kernel,\n\t\t\t\t# but with AVX2 or AVX512: unclear for now\n\t\t\t\t_debug \"is_cpu_affected: downfall: unclear, defaulting to non-affected for now\"\n\t\t\tfi\n\t\t\tset +u\n\t\tfi\n\t\t# Reptar\n\t\t# the only way to know whether a CPU is vuln, is to check whether there is a known ucode update for it,\n\t\t# as the mitigation is only ucode-based and there's no flag exposed by the kernel or by an updated ucode.\n\t\t# we have to hardcode the truthtable of affected CPUs vs updated ucodes...\n\t\t# https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/redundant-prefix-issue.html\n\t\t# list taken from:\n\t\t# https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/commit/ece0d294a29a1375397941a4e6f2f7217910bc89#diff-e6fad0f2abbac6c9603b2e8f88fe1d151a83de708aeca1c1d93d881c958ecba4R26\n\t\t# both pages have a lot of inconsistencies, I've tried to fix the errors the best I could, the logic being: if it's not in the\n\t\t# blog page, then the microcode update in the commit is not related to reptar, if microcode versions differ, then the one in github is correct,\n\t\t# if a stepping exists in the blog page but not in the commit, then the blog page is right\n\t\treptar_ucode_list='\n06-97-02/07,00000032\n06-97-05/07,00000032\n06-9a-03/80,00000430\n06-9a-04/80,00000430\n06-6c-01/10,01000268\n06-6a-06/87,0d0003b9\n06-7e-05/80,000000c2\n06-ba-02/e0,0000411c\n06-b7-01/32,0000011d\n06-a7-01/02,0000005d\n06-bf-05/07,00000032\n06-bf-02/07,00000032\n06-ba-03/e0,0000411c\n06-8f-08/87,2b0004d0\n06-8f-07/87,2b0004d0\n06-8f-06/87,2b0004d0\n06-8f-05/87,2b0004d0\n06-8f-04/87,2b0004d0\n06-8f-08/10,2c000290\n06-8c-01/80,000000b4\n06-8c-00/ff,000000b4\n06-8d-01/c2,0000004e\n06-8d-00/c2,0000004e\n06-8c-02/c2,00000034\n'\n\t\tfor tuple in $reptar_ucode_list; do\n\t\t\tfixed_ucode_ver=$(( 0x$(echo \"$tuple\" | cut -d, -f2) ))\n\t\t\taffected_fmspi=$(echo \"$tuple\" | cut -d, -f1)\n\t\t\taffected_fms=$(echo \"$affected_fmspi\" | cut -d/ -f1)\n\t\t\tucode_platformid_mask=0x$(echo \"$affected_fmspi\" | cut -d/ -f2)\n\t\t\taffected_cpuid=$(fms2cpuid \\\n\t\t\t\t0x\"$(echo \"$affected_fms\" | cut -d- -f1)\" \\\n\t\t\t\t0x\"$(echo \"$affected_fms\" | cut -d- -f2)\" \\\n\t\t\t\t0x\"$(echo \"$affected_fms\" | cut -d- -f3)\" \\\n\t\t\t)\n\t\t\tif [ \"$cpu_cpuid\" = \"$affected_cpuid\" ] && [ $((cpu_platformid & ucode_platformid_mask)) -gt 0 ]; then\n\t\t\t\t# this is not perfect as Intel never tells about their EOL CPUs, so more CPUs might be affected but there's no way to tell\n\t\t\t\tvariant_reptar=vuln\n\t\t\t\treptar_fixed_ucode_version=$fixed_ucode_ver\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\n\n\telif is_amd || is_hygon; then\n\t\t# AMD revised their statement about variant2 => affected\n\t\t# https://www.amd.com/en/corporate/speculative-execution\n\t\tvariant1=vuln\n\t\tvariant2=vuln\n\t\t[ -z \"$variant3\"  ] && variant3=immune\n\t\t# https://www.amd.com/en/corporate/security-updates\n\t\t# \"We have not identified any AMD x86 products susceptible to the Variant 3a vulnerability in our analysis to-date.\"\n\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\tif is_cpu_ssb_free; then\n\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t_debug \"is_cpu_affected: cpu not affected by speculative store bypass so not vuln to variant4\"\n\t\tfi\n\t\tvariantl1tf=immune\n\n\t\t# Zenbleed\n\t\tamd_legacy_erratum \"$(amd_model_range 0x17 0x30 0x0 0x4f 0xf)\" && variant_zenbleed=vuln\n\t\tamd_legacy_erratum \"$(amd_model_range 0x17 0x60 0x0 0x7f 0xf)\" && variant_zenbleed=vuln\n\t\tamd_legacy_erratum \"$(amd_model_range 0x17 0xa0 0x0 0xaf 0xf)\" && variant_zenbleed=vuln\n\n\t\t# Inception (according to kernel, zen 1 to 4)\n\t\tif [ \"$cpu_family\" = $(( 0x17 )) ] || [ \"$cpu_family\" = $(( 0x19 )) ]; then\n\t\t\tvariant_inception=vuln\n\t\tfi\n\n\telif [ \"$cpu_vendor\" = CAVIUM ]; then\n\t\tvariant3=immune\n\t\tvariant3a=immune\n\t\tvariantl1tf=immune\n\telif [ \"$cpu_vendor\" = PHYTIUM ]; then\n\t\tvariant3=immune\n\t\tvariant3a=immune\n\t\tvariantl1tf=immune\n\telif [ \"$cpu_vendor\" = ARM ]; then\n\t\t# ARM\n\t\t# reference: https://developer.arm.com/support/security-update\n\t\t# some devices (phones or other) have several ARMs and as such different part numbers,\n\t\t# an example is \"bigLITTLE\". we shouldn't rely on the first CPU only, so we check the whole list\n\t\ti=0\n\t\tfor cpupart in $cpu_part_list\n\t\tdo\n\t\t\ti=$(( i + 1 ))\n\t\t\t# do NOT quote $cpu_arch_list below\n\t\t\t# shellcheck disable=SC2086\n\t\t\tcpuarch=$(echo $cpu_arch_list | awk '{ print $'$i' }')\n\t\t\t_debug \"checking cpu$i: <$cpupart> <$cpuarch>\"\n\t\t\t# some kernels report AArch64 instead of 8\n\t\t\t[ \"$cpuarch\" = \"AArch64\" ] && cpuarch=8\n\t\t\tif [ -n \"$cpupart\" ] && [ -n \"$cpuarch\" ]; then\n\t\t\t\t# Cortex-R7 and Cortex-R8 are real-time and only used in medical devices or such\n\t\t\t\t# I can't find their CPU part number, but it's probably not that useful anyway\n\t\t\t\t# model R7 R8 A8  A9  A12 A15 A17 A57 A72 A73 A75 A76 A77 Neoverse-N1 Neoverse-V1 Neoverse-N1 Neoverse-V2 \n\t\t\t\t# part   ?  ? c08 c09 c0d c0f c0e d07 d08 d09 d0a d0b d0d d0c         d40\t  d49\t      d4f\n\t\t\t\t# arch  7? 7? 7   7   7   7   7   8   8   8   8   8   8   8           8\t\t  8\t      8\n\t\t\t\t#\n\t\t\t\t# Whitelist identified non-affected processors, use vulnerability information from \n\t\t\t\t# https://developer.arm.com/support/arm-security-updates/speculative-processor-vulnerability\n\t\t\t\t# Partnumbers can be found here:\n\t\t\t\t# https://github.com/gcc-mirror/gcc/blob/master/gcc/config/arm/arm-cpus.in\n\t\t\t\t#\n\t\t\t\t# Maintain cumulative check of vulnerabilities -\n\t\t\t\t# if at least one of the cpu is affected, then the system is affected\n\t\t\t\tif [ \"$cpuarch\" = 7 ] && echo \"$cpupart\" | grep -q -w -e 0xc08 -e 0xc09 -e 0xc0d -e 0xc0e; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\tvariant2=vuln\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t\t\t_debug \"checking cpu$i: armv7 A8/A9/A12/A17 non affected to variants 3, 3a & 4\"\n\t\t\t\telif [ \"$cpuarch\" = 7 ] && echo \"$cpupart\" | grep -q -w -e 0xc0f; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\tvariant2=vuln\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\tvariant3a=vuln\n\t\t\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t\t\t_debug \"checking cpu$i: armv7 A15 non affected to variants 3 & 4\"\n\t\t\t\telif [ \"$cpuarch\" = 8 ] && echo \"$cpupart\" | grep -q -w -e 0xd07 -e 0xd08; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\tvariant2=vuln\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\tvariant3a=vuln\n\t\t\t\t\tvariant4=vuln\n\t\t\t\t\t_debug \"checking cpu$i: armv8 A57/A72 non affected to variants 3\"\n\t\t\t\telif [ \"$cpuarch\" = 8 ] && echo \"$cpupart\" | grep -q -w -e 0xd09; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\tvariant2=vuln\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\t\t\tvariant4=vuln\n\t\t\t\t\t_debug \"checking cpu$i: armv8 A73 non affected to variants 3 & 3a\"\n\t\t\t\telif [ \"$cpuarch\" = 8 ] && echo \"$cpupart\" | grep -q -w -e 0xd0a; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\tvariant2=vuln\n\t\t\t\t\tvariant3=vuln\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\t\t\tvariant4=vuln\n\t\t\t\t\t_debug \"checking cpu$i: armv8 A75 non affected to variant 3a\"\n\t\t\t\telif [ \"$cpuarch\" = 8 ] && echo \"$cpupart\" | grep -q -w -e 0xd0b -e 0xd0c -e 0xd0d; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\t[ -z \"$variant2\" ] && variant2=immune\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\t\t\tvariant4=vuln\n\t\t\t\t\t_debug \"checking cpu$i: armv8 A76/A77/NeoverseN1 non affected to variant 2, 3 & 3a\"\n\t\t\t\telif [ \"$cpuarch\" = 8 ] && echo \"$cpupart\" | grep -q -w -e 0xd40 -e 0xd49 -e 0xd4f; then\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\t[ -z \"$variant2\" ] && variant2=immune\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t\t\t_debug \"checking cpu$i: armv8 NeoverseN2/V1/V2 non affected to variant 2, 3, 3a & 4\"\n\t\t\t\telif [ \"$cpuarch\" -le 7 ] || { [ \"$cpuarch\" = 8 ] && [ $(( cpupart )) -lt $(( 0xd07 )) ]; } ; then\n\t\t\t\t\t[ -z \"$variant1\" ] && variant1=immune\n\t\t\t\t\t[ -z \"$variant2\" ] && variant2=immune\n\t\t\t\t\t[ -z \"$variant3\" ] && variant3=immune\n\t\t\t\t\t[ -z \"$variant3a\" ] && variant3a=immune\n\t\t\t\t\t[ -z \"$variant4\" ] && variant4=immune\n\t\t\t\t\t_debug \"checking cpu$i: arm arch$cpuarch, all immune (v7 or v8 and model < 0xd07)\"\n\t\t\t\telse\n\t\t\t\t\tvariant1=vuln\n\t\t\t\t\tvariant2=vuln\n\t\t\t\t\tvariant3=vuln\n\t\t\t\t\tvariant3a=vuln\n\t\t\t\t\tvariant4=vuln\n\t\t\t\t\t_debug \"checking cpu$i: arm unknown arch$cpuarch part$cpupart, considering vuln\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t_debug \"is_cpu_affected: for cpu$i and so far, we have <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4>\"\n\t\tdone\n\t\tvariantl1tf=immune\n\tfi\n\n\t# we handle iTLB Multihit here (not linked to is_specex_free)\n\tif is_intel; then\n\t\t# commit f9aa6b73a407b714c9aac44734eb4045c893c6f7\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL_TABLET\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_BONNELL\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_BONNELL_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_AIRMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNL\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNM\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_AIRMONT_MID\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT_PLUS\" ]; then\n\t\t\t\t_debug \"is_cpu_affected: intel family 6 but model known to be immune to itlbmh\"\n\t\t\t\t[ -z \"$variant_itlbmh\" ] && variant_itlbmh=immune\n\t\t\telse\n\t\t\t\t_debug \"is_cpu_affected: intel family 6 is vuln to itlbmh\"\n\t\t\t\tvariant_itlbmh=vuln\n\t\t\tfi\n\t\telif [ \"$cpu_family\" -lt 6 ]; then\n\t\t\t_debug \"is_cpu_affected: intel family < 6 is immune to itlbmh\"\n\t\t\t[ -z \"$variant_itlbmh\" ] && variant_itlbmh=immune\n\t\tfi\n\telse\n\t\t_debug \"is_cpu_affected: non-intel not affected to itlbmh\"\n\t\t[ -z \"$variant_itlbmh\" ] && variant_itlbmh=immune\n\tfi\n\n\t_debug \"is_cpu_affected: temp results are <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4> <$variantl1tf>\"\n\t[ \"$variant1\"          = \"immune\" ] && variant1=1       || variant1=0\n\t[ \"$variant2\"          = \"immune\" ] && variant2=1       || variant2=0\n\t[ \"$variant3\"          = \"immune\" ] && variant3=1       || variant3=0\n\t[ \"$variant3a\"         = \"immune\" ] && variant3a=1      || variant3a=0\n\t[ \"$variant4\"          = \"immune\" ] && variant4=1       || variant4=0\n\t[ \"$variantl1tf\"       = \"immune\" ] && variantl1tf=1    || variantl1tf=0\n\t[ \"$variant_msbds\"     = \"immune\" ] && variant_msbds=1  || variant_msbds=0\n\t[ \"$variant_mfbds\"     = \"immune\" ] && variant_mfbds=1  || variant_mfbds=0\n\t[ \"$variant_mlpds\"     = \"immune\" ] && variant_mlpds=1  || variant_mlpds=0\n\t[ \"$variant_mdsum\"     = \"immune\" ] && variant_mdsum=1  || variant_mdsum=0\n\t[ \"$variant_taa\"       = \"immune\" ] && variant_taa=1    || variant_taa=0\n\t[ \"$variant_itlbmh\"    = \"immune\" ] && variant_itlbmh=1 || variant_itlbmh=0\n\t[ \"$variant_srbds\"     = \"immune\" ] && variant_srbds=1  || variant_srbds=0\n\t[ \"$variant_zenbleed\"  = \"immune\" ] && variant_zenbleed=1  || variant_zenbleed=0\n\t[ \"$variant_downfall\"  = \"immune\" ] && variant_downfall=1  || variant_downfall=0\n\t[ \"$variant_inception\" = \"immune\" ] && variant_inception=1 || variant_inception=0\n\t[ \"$variant_reptar\"    = \"immune\" ] && variant_reptar=1    || variant_reptar=0\n\tvariantl1tf_sgx=\"$variantl1tf\"\n\t# even if we are affected to L1TF, if there's no SGX, we're not affected to the original foreshadow\n\t[ \"$cpuid_sgx\" = 0 ] && variantl1tf_sgx=1\n\t_debug \"is_cpu_affected: final results are <$variant1> <$variant2> <$variant3> <$variant3a> <$variant4> <$variantl1tf> <$variantl1tf_sgx>\"\n\tis_cpu_affected_cached=1\n\t_is_cpu_affected_cached \"$1\"\n\treturn $?\n}\n\nis_cpu_specex_free()\n{\n\t# return true (0) if the CPU doesn't do speculative execution, false (1) if it does.\n\t# if it's not in the list we know, return false (1).\n\t# source: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/cpu/common.c#n882\n\t# { X86_VENDOR_INTEL,\t6, INTEL_FAM6_ATOM_SALTWELL,\tX86_FEATURE_ANY },\n\t# { X86_VENDOR_INTEL,\t6, INTEL_FAM6_ATOM_SALTWELL_TABLET,\tX86_FEATURE_ANY },\n\t# { X86_VENDOR_INTEL,\t6, INTEL_FAM6_ATOM_BONNELL_MID,\tX86_FEATURE_ANY },\n\t# { X86_VENDOR_INTEL,\t6, INTEL_FAM6_ATOM_SALTWELL_MID,\tX86_FEATURE_ANY },\n\t# { X86_VENDOR_INTEL,\t6, INTEL_FAM6_ATOM_BONNELL,\tX86_FEATURE_ANY },\n\t# { X86_VENDOR_CENTAUR,   5 },\n\t# { X86_VENDOR_INTEL,     5 },\n\t# { X86_VENDOR_NSC,       5 },\n\t# { X86_VENDOR_ANY,       4 },\n\n\tparse_cpu_details\n\tif is_intel; then\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL\"\t] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL_TABLET\"\t] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_BONNELL_MID\"\t\t] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SALTWELL_MID\"\t] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_BONNELL\"\t]; then\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telif [ \"$cpu_family\" = 5 ]; then\n\t\t\treturn 0\n\t\tfi\n\tfi\n\t[ \"$cpu_family\" = 4 ] && return 0\n\treturn 1\n}\n\nis_cpu_mds_free()\n{\n\t# return true (0) if the CPU isn't affected by microarchitectural data sampling, false (1) if it does.\n\t# if it's not in the list we know, return false (1).\n\t# source: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/cpu/common.c\n\t#VULNWL_INTEL(ATOM_GOLDMONT,             NO_MDS | NO_L1TF),\n\t#VULNWL_INTEL(ATOM_GOLDMONT_X,           NO_MDS | NO_L1TF),\n\t#VULNWL_INTEL(ATOM_GOLDMONT_PLUS,        NO_MDS | NO_L1TF),\n\n\t#/* AMD Family 0xf - 0x12 */\n\t#VULNWL_AMD(0x0f,        NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),\n\t#VULNWL_AMD(0x10,        NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),\n\t#VULNWL_AMD(0x11,        NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),\n\t#VULNWL_AMD(0x12,        NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),\n\n\t#/* FAMILY_ANY must be last, otherwise 0x0f - 0x12 matches won't work */\n\t#VULNWL_AMD(X86_FAMILY_ANY,      NO_MELTDOWN | NO_L1TF | NO_MDS),\n\t#VULNWL_HYGON(X86_FAMILY_ANY,    NO_MELTDOWN | NO_L1TF | NO_MDS),\n\tparse_cpu_details\n\tif is_intel; then\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_GOLDMONT_PLUS\" ]; then\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\t\t[ \"$capabilities_mds_no\" = 1 ] && return 0\n\tfi\n\n\t# official statement from AMD says none of their CPUs are affected\n\t# https://www.amd.com/en/corporate/product-security\n\t# https://www.amd.com/system/files/documents/security-whitepaper.pdf\n\tif is_amd; then\n\t\treturn 0\n\telif is_hygon; then\n\t\treturn 0\n\telif [ \"$cpu_vendor\" = CAVIUM ]; then\n\t\treturn 0\n\telif [ \"$cpu_vendor\" = PHYTIUM ]; then\n\t\treturn 0\n\telif [ \"$cpu_vendor\" = ARM ]; then\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\n\nis_cpu_taa_free()\n{\n\t# return true (0) if the CPU isn't affected by tsx asynchronous aborts, false (1) if it does.\n\t# There are three types of processors that do not require additional mitigations.\n\t# 1. CPUs that do not support Intel TSX are not affected.\n\t# 2. CPUs that enumerate IA32_ARCH_CAPABILITIES[TAA_NO] (bit 8)=1 are not affected.\n\t# 3. CPUs that support Intel TSX and do not enumerate IA32_ARCH_CAPABILITIES[MDS_NO] (bit 5)=1\n\t# do not need additional mitigations beyond what is already required to mitigate MDS.\n\n\tif ! is_intel; then\n\t\treturn 0\n\t# is intel\n\telif [ \"$capabilities_taa_no\" = 1 ] || [ \"$cpuid_rtm\" = 0 ]; then\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\nis_cpu_srbds_free()\n{\n\t# return zero (0) if the CPU isn't affected by special register buffer data sampling, one (1) if it is.\n\t# If it's not in the list we know, return one (1).\n\t# source: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/cpu/common.c\n\t#\n\t# A processor is affected by SRBDS if its Family_Model and stepping is in the\n\t# following list, with the exception of the listed processors\n\t# exporting MDS_NO while Intel TSX is available yet not enabled. The\n\t# latter class of processors are only affected when Intel TSX is enabled\n\t# by software using TSX_CTRL_MSR otherwise they are not affected.\n\t#\n\t# =============  ============  ========\n\t# common name    Family_Model  Stepping\n\t# =============  ============  ========\n\t# IvyBridge      06_3AH        All              (INTEL_FAM6_IVYBRIDGE)\n\t#\n\t# Haswell        06_3CH        All              (INTEL_FAM6_HASWELL)\n\t# Haswell_L      06_45H        All              (INTEL_FAM6_HASWELL_L)\n\t# Haswell_G      06_46H        All              (INTEL_FAM6_HASWELL_G)\n\t#\n\t# Broadwell_G    06_47H        All              (INTEL_FAM6_BROADWELL_G)\n\t# Broadwell      06_3DH        All              (INTEL_FAM6_BROADWELL)\n\t#\n\t# Skylake_L      06_4EH        All              (INTEL_FAM6_SKYLAKE_L)\n\t# Skylake        06_5EH        All              (INTEL_FAM6_SKYLAKE)\n\t#\n\t# Kabylake_L     06_8EH        <=0xC (MDS_NO)   (INTEL_FAM6_KABYLAKE_L)\n\t#\n\t# Kabylake       06_9EH        <=0xD (MDS_NO)   (INTEL_FAM6_KABYLAKE)\n\t# =============  ============  ========\n\tparse_cpu_details\n\tif is_intel; then\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_IVYBRIDGE\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_HASWELL\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_HASWELL_L\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_HASWELL_G\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_BROADWELL_G\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_BROADWELL\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_SKYLAKE_L\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_SKYLAKE\" ]; then\n\t\t\t\treturn 1\n\t\t\telif [ \"$cpu_model\" = \"$INTEL_FAM6_KABYLAKE_L\" ] && [ \"$cpu_stepping\" -le 12 ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_KABYLAKE\" ] && [ \"$cpu_stepping\" -le 13 ]; then\n\t\t\t\tif [ \"$capabilities_mds_no\" -eq 1 ] && { [ \"$cpuid_rtm\" -eq 0 ] || [ \"$tsx_ctrl_msr_rtm_disable\" -eq 1 ] ;} ; then\n\t\t\t\t\treturn 0\n\t\t\t\telse\n\t\t\t\t\treturn 1\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tfi\n\n\treturn 0\n\n}\n\nis_cpu_ssb_free()\n{\n\t# return true (0) if the CPU isn't affected by speculative store bypass, false (1) if it does.\n\t# if it's not in the list we know, return false (1).\n\t# source1: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/cpu/common.c#n945\n\t# source2: https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/tree/arch/x86/kernel/cpu/common.c\n\t# Only list CPUs that speculate but are immune, to avoid duplication of cpus listed in is_cpu_specex_free()\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_ATOM_SILVERMONT\t},\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_ATOM_AIRMONT\t\t},\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_ATOM_SILVERMONT_X\t},\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_ATOM_SILVERMONT_MID\t},\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_CORE_YONAH\t\t},\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_XEON_PHI_KNL\t\t},\n\t#{ X86_VENDOR_INTEL,\t6,\tINTEL_FAM6_XEON_PHI_KNM\t\t},\n\t#{ X86_VENDOR_AMD,\t0x12,\t\t\t\t\t},\n\t#{ X86_VENDOR_AMD,\t0x11,\t\t\t\t\t},\n\t#{ X86_VENDOR_AMD,\t0x10,\t\t\t\t\t},\n\t#{ X86_VENDOR_AMD,\t0xf,\t\t\t\t\t},\n\tparse_cpu_details\n\tif is_intel; then\n\t\tif [ \"$cpu_family\" = 6 ]; then\n\t\t\tif [ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_AIRMONT\"          ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_D\" ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_ATOM_SILVERMONT_MID\"  ]; then\n\t\t\t\treturn 0\n\t\t\telif [ \"$cpu_model\" = \"$INTEL_FAM6_CORE_YONAH\"          ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNL\"     ] || \\\n\t\t\t\t[ \"$cpu_model\" = \"$INTEL_FAM6_XEON_PHI_KNM\"     ]; then\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tfi\n\tif is_amd; then\n\t\tif [ \"$cpu_family\" = \"18\" ] || \\\n\t\t\t[ \"$cpu_family\" = \"17\" ] || \\\n\t\t\t[ \"$cpu_family\" = \"16\" ] || \\\n\t\t\t[ \"$cpu_family\" = \"15\" ]; then \n\t\t\treturn 0\n\t\tfi\n\tfi\n\tif is_hygon; then\n\t\treturn 1\n\tfi\n\t[ \"$cpu_family\" = 4 ] && return 0\n\treturn 1\n}\n\nshow_header()\n{\n\t_info \"Spectre and Meltdown mitigation detection tool v$VERSION\"\n\t_info\n}\n\n# Family-Model-Stepping to CPUID\n# prints CPUID in base-10 to stdout\nfms2cpuid()\n{\n\t_family=\"$1\"\n\t_model=\"$2\"\n\t_stepping=\"$3\"\n\n\tif [ \"$(( _family ))\" -le 15 ]; then\n\t\t_extfamily=0\n\t\t_lowfamily=$(( _family ))\n\telse\n\t\t# when we have a family > 0xF, then lowfamily is stuck at 0xF\n\t\t# and extfamily is ADDED to it (as in \"+\"), to ensure old software\n\t\t# never sees a lowfamily < 0xF for newer families\n\t\t_lowfamily=15\n\t\t_extfamily=$(( (_family) - 15 ))\n\tfi\n\t_extmodel=$((  (_model  & 0xF0 ) >> 4 ))\n\t_lowmodel=$((  (_model  & 0x0F ) >> 0 ))\n\techo $(( (_stepping & 0x0F) | (_lowmodel << 4) | (_lowfamily << 8) | (_extmodel << 16) | (_extfamily << 20) ))\n}\n\ndownload_file()\n{\n\t_url=\"$1\"\n\t_file=\"$2\"\n\tif command -v wget >/dev/null 2>&1; then\n\t\twget -q \"$_url\" -O \"$_file\"; ret=$?\n\telif command -v curl >/dev/null 2>&1; then\n\t\tcurl -sL \"$_url\" -o \"$_file\"; ret=$?\n\telif command -v fetch >/dev/null 2>&1; then\n\t\tfetch -q \"$_url\" -o \"$_file\"; ret=$?\n\telse\n\t\techo ERROR \"please install one of \\`wget\\`, \\`curl\\` of \\`fetch\\` programs\"\n\t\tunset _file _url\n\t\treturn 1\n\tfi\n\tunset _file _url\n\tif [ \"$ret\" != 0 ]; then\n\t\techo ERROR \"error $ret\"\n\t\treturn $ret\n\tfi\n\techo DONE\n}\n\n[ -z \"$HOME\" ] && HOME=\"$(getent passwd \"$(whoami)\" | cut -d: -f6)\"\nmcedb_cache=\"$HOME/.mcedb\"\nupdate_fwdb()\n{\n\tshow_header\n\n\tset -e\n\n\tif [ -r \"$mcedb_cache\" ]; then\n\t\tprevious_dbversion=$(awk '/^# %%% MCEDB / { print $4 }' \"$mcedb_cache\")\n\tfi\n\n\t# first, download the MCE.db from the excellent platomav's MCExtractor project\n\tmcedb_tmp=\"$(mktemp -t smc-mcedb-XXXXXX)\"\n\tmcedb_url='https://github.com/platomav/MCExtractor/raw/master/MCE.db'\n\t_info_nol \"Fetching MCE.db from the MCExtractor project... \"\n\tdownload_file \"$mcedb_url\" \"$mcedb_tmp\" || return $?\n\n\t# second, get the Intel firmwares from GitHub\n\tintel_tmp=\"$(mktemp -d -t smc-intelfw-XXXXXX)\"\n\tintel_url=\"https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/archive/main.zip\"\n\t_info_nol \"Fetching Intel firmwares... \"\n\t## https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files.git\n\tdownload_file \"$intel_url\" \"$intel_tmp/fw.zip\" || return $?\n\n\t# now extract MCEdb contents using sqlite\n\t_info_nol \"Extracting MCEdb data... \"\n\tif ! command -v sqlite3 >/dev/null 2>&1; then\n\t\techo ERROR \"please install the \\`sqlite3\\` program\"\n\t\treturn 1\n\tfi\n\tmcedb_revision=$(sqlite3 \"$mcedb_tmp\" \"SELECT \\\"revision\\\" from \\\"MCE\\\"\")\n\tif [ -z \"$mcedb_revision\" ]; then\n\t\techo ERROR \"downloaded file seems invalid\"\n\t\treturn 1\n\tfi\n\tsqlite3 \"$mcedb_tmp\" \"ALTER TABLE \\\"Intel\\\" ADD COLUMN \\\"origin\\\" TEXT\"\n\tsqlite3 \"$mcedb_tmp\" \"ALTER TABLE \\\"Intel\\\" ADD COLUMN \\\"pfmask\\\" TEXT\"\n\tsqlite3 \"$mcedb_tmp\" \"ALTER TABLE \\\"AMD\\\" ADD COLUMN \\\"origin\\\" TEXT\"\n\tsqlite3 \"$mcedb_tmp\" \"ALTER TABLE \\\"AMD\\\" ADD COLUMN \\\"pfmask\\\" TEXT\"\n\tsqlite3 \"$mcedb_tmp\" \"UPDATE \\\"Intel\\\" SET \\\"origin\\\"='mce'\"\n\tsqlite3 \"$mcedb_tmp\" \"UPDATE \\\"Intel\\\" SET \\\"pfmask\\\"='FF'\"\n\tsqlite3 \"$mcedb_tmp\" \"UPDATE \\\"AMD\\\" SET \\\"origin\\\"='mce'\"\n\tsqlite3 \"$mcedb_tmp\" \"UPDATE \\\"AMD\\\" SET \\\"pfmask\\\"='FF'\"\n\n\techo OK \"MCExtractor database revision $mcedb_revision\"\n\n\t# parse Intel firmwares to get their versions\n\t_info_nol \"Integrating Intel firmwares data to db... \"\n\tif ! command -v unzip >/dev/null 2>&1; then\n\t\techo ERROR \"please install the \\`unzip\\` program\"\n\t\treturn 1\n\tfi\n\t( cd \"$intel_tmp\" && unzip fw.zip >/dev/null; )\n\tif ! [ -d \"$intel_tmp/Intel-Linux-Processor-Microcode-Data-Files-main/intel-ucode\" ]; then\n\t\techo ERROR \"expected the 'intel-ucode' folder in the downloaded zip file\"\n\t\treturn 1\n\tfi\n\n\tif ! command -v iucode_tool >/dev/null 2>&1; then\n\t\tif ! command -v iucode-tool >/dev/null 2>&1; then\n\t\t\techo ERROR \"please install the \\`iucode-tool\\` program\"\n\t\t\treturn 1\n\t\telse\n\t\t\tiucode_tool=\"iucode-tool\"\n\t\tfi\n\telse\n\t\tiucode_tool=\"iucode_tool\"\n\tfi\n\t#  079/001: sig 0x000106c2, pf_mask 0x01, 2009-04-10, rev 0x0217, size 5120\n\t#  078/004: sig 0x000106ca, pf_mask 0x10, 2009-08-25, rev 0x0107, size 5120\n\t$iucode_tool -l \"$intel_tmp/Intel-Linux-Processor-Microcode-Data-Files-main/intel-ucode\" | grep -wF sig | while read -r _line\n\tdo\n\t\t_cpuid=$(echo \"$_line\" | grep -Eio 'sig 0x[0-9a-f]+' | awk '{print $2}')\n\t\t_cpuid=$(( _cpuid ))\n\t\t_cpuid=$(printf \"%08X\" \"$_cpuid\")\n\t\t_pfmask=$(echo \"$_line\" | grep -Eio 'pf_mask 0x[0-9a-f]+' | awk '{print $2}')\n\t\t_pfmask=$(( _pfmask ))\n\t\t_pfmask=$(printf \"%02X\" $_pfmask)\n\t\t_date=$(echo \"$_line\" | grep -Eo '(19|20)[0-9][0-9]-[01][0-9]-[0-3][0-9]' | tr -d '-')\n\t\t_version=$(echo \"$_line\" | grep -Eio 'rev 0x[0-9a-f]+' | awk '{print $2}')\n\t\t_version=$(( _version ))\n\t\t_version=$(printf \"%08X\" \"$_version\")\n\t\t# ensure the official Intel DB always has precedence over mcedb, even if mcedb has seen a more recent fw\n\t\tsqlite3 \"$mcedb_tmp\" \"DELETE FROM \\\"Intel\\\" WHERE \\\"origin\\\" != 'intel' AND \\\"cpuid\\\" = '$_cpuid';\"\n\t\t# then insert our version\n\t\tsqlite3 \"$mcedb_tmp\" \"INSERT INTO \\\"Intel\\\" (\\\"origin\\\",\\\"cpuid\\\",\\\"pfmask\\\",\\\"version\\\",\\\"yyyymmdd\\\") VALUES ('intel','$_cpuid','$_pfmask','$_version','$_date');\"\n\tdone\n\t_intel_timestamp=$(stat -c %Y \"$intel_tmp/Intel-Linux-Processor-Microcode-Data-Files-main/license\" 2>/dev/null)\n\tif [ -n \"$_intel_timestamp\" ]; then\n\t\t# use this date, it matches the last commit date\n\t\t_intel_latest_date=$(date +%Y%m%d -d @\"$_intel_timestamp\")\n\telse\n\t\techo \"Falling back to the latest microcode date\"\n\t\t_intel_latest_date=$(sqlite3 \"$mcedb_tmp\" \"SELECT \\\"yyyymmdd\\\" FROM \\\"Intel\\\" WHERE \\\"origin\\\"='intel' ORDER BY \\\"yyyymmdd\\\" DESC LIMIT 1;\")\n\tfi\n\techo DONE \"(version $_intel_latest_date)\"\n\n\t# now parse the most recent linux-firmware amd-ucode README file\n\t_info_nol \"Fetching latest amd-ucode README from linux-firmware project... \"\n\tlinuxfw_url=\"https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/amd-ucode/README\"\n\tlinuxfw_tmp=$(mktemp -t smc-linuxfw-XXXXXX)\n\tdownload_file \"$linuxfw_url\" \"$linuxfw_tmp\" || return $?\n\n\t_info_nol \"Parsing the README... \"\n\tnbfound=0\n\tfor line in $(grep -E 'Family=0x[0-9a-f]+ Model=0x[0-9a-f]+ Stepping=0x[0-9a-f]+: Patch=0x[0-9a-f]+' \"$linuxfw_tmp\" | tr \" \" \",\"); do\n\t\t_debug \"Parsing line $line\"\n\t\t_family=$(  echo \"$line\" | grep -Eoi 'Family=0x[0-9a-f]+'   | cut -d= -f2)\n\t\t_model=$(   echo \"$line\" | grep -Eoi 'Model=0x[0-9a-f]+'    | cut -d= -f2)\n\t\t_stepping=$(echo \"$line\" | grep -Eoi 'Stepping=0x[0-9a-f]+' | cut -d= -f2)\n\t\t_version=$( echo \"$line\" | grep -Eoi 'Patch=0x[0-9a-f]+'    | cut -d= -f2)\n\t\t_version=$(printf \"%08X\" \"$(( _version ))\")\n\t\t_cpuid=$(fms2cpuid \"$_family\" \"$_model\" \"$_stepping\")\n\t\t_cpuid=$(printf \"%08X\" \"$_cpuid\")\n\t\t_sqlstm=\"INSERT INTO \\\"AMD\\\" (\\\"origin\\\",\\\"cpuid\\\",\\\"pfmask\\\",\\\"version\\\",\\\"yyyymmdd\\\") VALUES ('linux-firmware','$_cpuid','FF','$_version','20000101')\"\n\t\t_debug \"family $_family model $_model stepping $_stepping cpuid $_cpuid\"\n\t\t_debug \"$_sqlstm\"\n\t\tsqlite3 \"$mcedb_tmp\" \"$_sqlstm\"\n\t\tnbfound=$((nbfound + 1))\n\t\tunset _family _model _stepping _version _cpuid _date _sqlstm\n\tdone\n\techo \"found $nbfound microcodes\"\n\tunset nbfound\n\n\tdbversion=\"$mcedb_revision+i$_intel_latest_date\"\n\tlinuxfw_hash=$(md5sum \"$linuxfw_tmp\" 2>/dev/null | cut -c1-4)\n\tif [ -n \"$linuxfw_hash\" ]; then\n\t\tdbversion=\"$dbversion+$linuxfw_hash\"\n\tfi\n\n\tif [ \"$1\" != builtin ] && [ -n \"$previous_dbversion\" ] && [ \"$previous_dbversion\" = \"v$dbversion\" ]; then\n\t\techo \"We already have this version locally, no update needed\"\n\t\treturn 0\n\tfi\n\n\t_info_nol \"Building local database... \"\n\t{\n\t\techo \"# Spectre & Meltdown Checker\";\n\t\techo \"# %%% MCEDB v$dbversion\";\n\t\t# we'll use the more recent fw for Intel and AMD\n\t\tsqlite3 \"$mcedb_tmp\" \"SELECT '# I,0x'||\\\"t1\\\".\\\"cpuid\\\"||',0x'||\\\"t1\\\".\\\"pfmask\\\"||',0x'||MAX(\\\"t1\\\".\\\"version\\\")||','||\\\"t1\\\".\\\"yyyymmdd\\\" FROM \\\"Intel\\\" AS \\\"t1\\\" LEFT OUTER JOIN \\\"Intel\\\" AS \\\"t2\\\" ON \\\"t2\\\".\\\"cpuid\\\"=\\\"t1\\\".\\\"cpuid\\\" AND \\\"t2\\\".\\\"pfmask\\\"=\\\"t1\\\".\\\"pfmask\\\" AND \\\"t2\\\".\\\"yyyymmdd\\\" > \\\"t1\\\".\\\"yyyymmdd\\\" WHERE \\\"t2\\\".\\\"yyyymmdd\\\" IS NULL GROUP BY \\\"t1\\\".\\\"cpuid\\\",\\\"t1\\\".\\\"pfmask\\\" ORDER BY \\\"t1\\\".\\\"cpuid\\\",\\\"t1\\\".\\\"pfmask\\\" ASC;\" | grep -v '^# .,0x00000000,';\n\t\tsqlite3 \"$mcedb_tmp\" \"SELECT '# A,0x'||\\\"t1\\\".\\\"cpuid\\\"||',0x'||\\\"t1\\\".\\\"pfmask\\\"||',0x'||MAX(\\\"t1\\\".\\\"version\\\")||','||\\\"t1\\\".\\\"yyyymmdd\\\" FROM \\\"AMD\\\"   AS \\\"t1\\\" LEFT OUTER JOIN \\\"AMD\\\"   AS \\\"t2\\\" ON \\\"t2\\\".\\\"cpuid\\\"=\\\"t1\\\".\\\"cpuid\\\" AND \\\"t2\\\".\\\"pfmask\\\"=\\\"t1\\\".\\\"pfmask\\\" AND \\\"t2\\\".\\\"yyyymmdd\\\" > \\\"t1\\\".\\\"yyyymmdd\\\" WHERE \\\"t2\\\".\\\"yyyymmdd\\\" IS NULL GROUP BY \\\"t1\\\".\\\"cpuid\\\",\\\"t1\\\".\\\"pfmask\\\" ORDER BY \\\"t1\\\".\\\"cpuid\\\",\\\"t1\\\".\\\"pfmask\\\" ASC;\" | grep -v '^# .,0x00000000,';\n\t} > \"$mcedb_cache\"\n\techo DONE \"(version $dbversion)\"\n\n\tif [ \"$1\" = builtin ]; then\n\t\tnewfile=$(mktemp -t smc-builtin-XXXXXX)\n\t\tawk '/^# %%% MCEDB / { exit }; { print }' \"$0\" > \"$newfile\"\n\t\tawk '{ if (NR>1) { print } }' \"$mcedb_cache\" >> \"$newfile\"\n\t\tcat \"$newfile\" > \"$0\"\n\t\trm -f \"$newfile\"\n\tfi\n}\n\nparse_opt_file()\n{\n\t# parse_opt_file option_name option_value\n\toption_name=\"$1\"\n\toption_value=\"$2\"\n\tif [ -z \"$option_value\" ]; then\n\t\tshow_header\n\t\tshow_usage\n\t\techo \"$0: error: --$option_name expects one parameter (a file)\" >&2\n\t\texit 1\n\telif [ ! -e \"$option_value\" ]; then\n\t\tshow_header\n\t\techo \"$0: error: couldn't find file $option_value\" >&2\n\t\texit 1\n\telif [ ! -f \"$option_value\" ]; then\n\t\tshow_header\n\t\techo \"$0: error: $option_value is not a file\" >&2\n\t\texit 1\n\telif [ ! -r \"$option_value\" ]; then\n\t\tshow_header\n\t\techo \"$0: error: couldn't read $option_value (are you root?)\" >&2\n\t\texit 1\n\tfi\n\techo \"$option_value\"\n\texit 0\n}\n\nwhile [ -n \"${1:-}\" ]; do\n\tif [ \"$1\" = \"--kernel\" ]; then\n\t\topt_kernel=$(parse_opt_file kernel \"$2\"); ret=$?\n\t\t[ $ret -ne 0 ] && exit 255\n\t\tshift 2\n\telif [ \"$1\" = \"--config\" ]; then\n\t\topt_config=$(parse_opt_file config \"$2\"); ret=$?\n\t\t[ $ret -ne 0 ] && exit 255\n\t\tshift 2\n\telif [ \"$1\" = \"--map\" ]; then\n\t\topt_map=$(parse_opt_file map \"$2\"); ret=$?\n\t\t[ $ret -ne 0 ] && exit 255\n\t\tshift 2\n\telif [ \"$1\" = \"--arch-prefix\" ]; then\n\t\topt_arch_prefix=\"$2\"\n\t\tshift 2\n\telif [ \"$1\" = \"--live\" ]; then\n\t\topt_live=1\n\t\tshift\n\telif [ \"$1\" = \"--no-color\" ]; then\n\t\topt_no_color=1\n\t\tshift\n\telif [ \"$1\" = \"--no-sysfs\" ]; then\n\t\topt_no_sysfs=1\n\t\tshift\n\telif [ \"$1\" = \"--sysfs-only\" ]; then\n\t\topt_sysfs_only=1\n\t\tshift\n\telif [ \"$1\" = \"--coreos\" ]; then\n\t\topt_coreos=1\n\t\tshift\n\telif [ \"$1\" = \"--coreos-within-toolbox\" ]; then\n\t\t# don't use directly: used internally by --coreos\n\t\topt_coreos=0\n\t\tshift\n\telif [ \"$1\" = \"--paranoid\" ]; then\n\t\topt_paranoid=1\n\t\tshift\n\telif [ \"$1\" = \"--hw-only\" ]; then\n\t\topt_hw_only=1\n\t\tshift\n\telif [ \"$1\" = \"--no-hw\" ]; then\n\t\topt_no_hw=1\n\t\tshift\n\telif [ \"$1\" = \"--allow-msr-write\" ]; then\n\t\topt_allow_msr_write=1\n\t\tshift\n\telif [ \"$1\" = \"--no-intel-db\" ]; then\n\t\topt_intel_db=0\n\t\tshift\n\telif [ \"$1\" = \"--cpu\" ]; then\n\t\topt_cpu=$2\n\t\tif [ \"$opt_cpu\" != all ]; then\n\t\t\tif echo \"$opt_cpu\" | grep -Eq '^[0-9]+'; then\n\t\t\t\topt_cpu=$(( opt_cpu ))\n\t\t\telse\n\t\t\t\techo \"$0: error: --cpu should be an integer or 'all', got '$opt_cpu'\" >&2\n\t\t\t\texit 255\n\t\t\tfi\n\t\tfi\n\t\tshift 2\n\telif [ \"$1\" = \"--no-explain\" ]; then\n\t\t# deprecated, kept for compatibility\n\t\topt_explain=0\n\t\tshift\n\telif [ \"$1\" = \"--update-fwdb\" ] || [ \"$1\" = \"--update-mcedb\" ]; then\n\t\tupdate_fwdb\n\t\texit $?\n\telif [ \"$1\" = \"--update-builtin-fwdb\" ] || [ \"$1\" = \"--update-builtin-mcedb\" ]; then\n\t\tupdate_fwdb builtin\n\t\texit $?\n\telif [ \"$1\" = \"--dump-mock-data\" ]; then\n\t\topt_mock=1\n\t\tshift\n\telif [ \"$1\" = \"--explain\" ]; then\n\t\topt_explain=1\n\t\tshift\n\telif [ \"$1\" = \"--batch\" ]; then\n\t\topt_batch=1\n\t\topt_verbose=0\n\t\topt_no_color=1\n\t\tshift\n\t\tcase \"$1\" in\n\t\t\ttext|short|nrpe|json|prometheus) opt_batch_format=\"$1\"; shift;;\n\t\t\t--*) ;;    # allow subsequent flags\n\t\t\t'') ;;     # allow nothing at all\n\t\t\t*)\n\t\t\t\techo \"$0: error: unknown batch format '$1'\" >&2\n\t\t\t\techo \"$0: error: --batch expects a format from: text, nrpe, json\" >&2\n\t\t\t\texit 255\n\t\t\t\t;;\n\t\tesac\n\telif [ \"$1\" = \"-v\" ] || [ \"$1\" = \"--verbose\" ]; then\n\t\topt_verbose=$(( opt_verbose + 1 ))\n\t\t[ \"$opt_verbose\" -ge 2 ] && opt_mock=1\n\t\tshift\n\telif [ \"$1\" = \"--cve\" ]; then\n\t\tif [ -z \"$2\" ]; then\n\t\t\techo \"$0: error: option --cve expects a parameter, supported CVEs are: $supported_cve_list\" >&2\n\t\t\texit 255\n\t\tfi\n\t\tselected_cve=$(echo \"$supported_cve_list\" | grep -iwo \"$2\")\n\t\tif [ -n \"$selected_cve\" ]; then\n\t\t\topt_cve_list=\"$opt_cve_list $selected_cve\"\n\t\t\topt_cve_all=0\n\t\telse\n\t\t\techo \"$0: error: unsupported CVE specified ('$2'), supported CVEs are: $supported_cve_list\" >&2\n\t\t\texit 255\n\t\tfi\n\t\tshift 2\n\telif [ \"$1\" = \"--vmm\" ]; then\n\t\tif [ -z \"$2\" ]; then\n\t\t\techo \"$0: error: option --vmm (auto, yes, no)\" >&2\n\t\t\texit 255\n\t\tfi\n\t\tcase \"$2\" in\n\t\t\tauto) opt_vmm=-1;;\n\t\t\tyes)  opt_vmm=1;;\n\t\t\tno)   opt_vmm=0;;\n\t\t\t*)    echo \"$0: error: expected one of (auto, yes, no) to option --vmm instead of '$2'\" >&2; exit 255;;\n\t\tesac\n\t\tshift 2\n\telif [ \"$1\" = \"--variant\" ]; then\n\t\tif [ -z \"$2\" ]; then\n\t\t\techo \"$0: error: option --variant expects a parameter (see --variant help)\" >&2\n\t\t\texit 255\n\t\tfi\n\t\tcase \"$2\" in\n\t\t\thelp)\techo \"The following parameters are supported for --variant (can be used multiple times):\";\n\t\t\t\t\techo \"1, 2, 3, 3a, 4, msbds, mfbds, mlpds, mdsum, l1tf, taa, mcepsc, srbds, zenbleed, downfall, inception\";\n\t\t\t\t\texit 0;;\n\t\t\t1)\t\t\topt_cve_list=\"$opt_cve_list CVE-2017-5753\"; opt_cve_all=0;;\n\t\t\t2)\t\t\topt_cve_list=\"$opt_cve_list CVE-2017-5715\"; opt_cve_all=0;;\n\t\t\t3)\t\t\topt_cve_list=\"$opt_cve_list CVE-2017-5754\"; opt_cve_all=0;;\n\t\t\t3a)\t\t\topt_cve_list=\"$opt_cve_list CVE-2018-3640\"; opt_cve_all=0;;\n\t\t\t4)\t\t\topt_cve_list=\"$opt_cve_list CVE-2018-3639\"; opt_cve_all=0;;\n\t\t\tmsbds)\t\topt_cve_list=\"$opt_cve_list CVE-2018-12126\"; opt_cve_all=0;;\n\t\t\tmfbds)\t\topt_cve_list=\"$opt_cve_list CVE-2018-12130\"; opt_cve_all=0;;\n\t\t\tmlpds)\t\topt_cve_list=\"$opt_cve_list CVE-2018-12127\"; opt_cve_all=0;;\n\t\t\tmdsum)\t\topt_cve_list=\"$opt_cve_list CVE-2019-11091\"; opt_cve_all=0;;\n\t\t\tl1tf)\t\topt_cve_list=\"$opt_cve_list CVE-2018-3615 CVE-2018-3620 CVE-2018-3646\"; opt_cve_all=0;;\n\t\t\ttaa)\t\topt_cve_list=\"$opt_cve_list CVE-2019-11135\"; opt_cve_all=0;;\n\t\t\tmcepsc)\t\topt_cve_list=\"$opt_cve_list CVE-2018-12207\"; opt_cve_all=0;;\n\t\t\tsrbds)\t\topt_cve_list=\"$opt_cve_list CVE-2020-0543\"; opt_cve_all=0;;\n\t\t\tzenbleed)\topt_cve_list=\"$opt_cve_list CVE-2023-20593\"; opt_cve_all=0;;\n\t\t\tdownfall)   opt_cve_list=\"$opt_cve_list CVE-2022-40982\"; opt_cve_all=0;;\n\t\t\tinception)  opt_cve_list=\"$opt_cve_list CVE-2023-20569\"; opt_cve_all=0;;\n\t\t\treptar)     opt_cve_list=\"$opt_cve_list CVE-2023-23583\"; opt_cve_all=0;;\n\t\t\t*)\n\t\t\t\techo \"$0: error: invalid parameter '$2' for --variant, see --variant help for a list\" >&2;\n\t\t\t\texit 255\n\t\t\t\t;;\n\t\tesac\n\t\tshift 2\n\telif [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then\n\t\tshow_header\n\t\tshow_usage\n\t\texit 0\n\telif [ \"$1\" = \"--version\" ]; then\n\t\topt_no_color=1\n\t\tshow_header\n\t\texit 0\n\telif [ \"$1\" = \"--disclaimer\" ]; then\n\t\tshow_header\n\t\tshow_disclaimer\n\t\texit 0\n\telse\n\t\tshow_header\n\t\tshow_usage\n\t\techo \"$0: error: unknown option '$1'\"\n\t\texit 255\n\tfi\ndone\n\nshow_header\n\nif [ \"$opt_no_sysfs\" = 1 ] && [ \"$opt_sysfs_only\" = 1 ]; then\n\t_warn \"Incompatible options specified (--no-sysfs and --sysfs-only), aborting\"\n\texit 255\nfi\n\nif [ \"$opt_no_hw\" = 1 ] && [ \"$opt_hw_only\" = 1 ]; then\n\t_warn \"Incompatible options specified (--no-hw and --hw-only), aborting\"\n\texit 255\nfi\n\nif [ \"$opt_live\" = -1 ]; then\n\tif [ -n \"$opt_kernel\" ] || [ -n \"$opt_config\" ] || [ -n \"$opt_map\" ]; then\n\t\t# no --live specified and we have a least one of the kernel/config/map files on the cmdline: offline mode\n\t\topt_live=0\n\telse\n\t\topt_live=1\n\tfi\nfi\n\n# print status function\n# param1: color\n# param2: message to print\n# param3(optional): supplement message to print between ()\npstatus()\n{\n\tif [ \"$opt_no_color\" = 1 ]; then\n\t\t_info_nol \"$2\"\n\telse\n\t\tcase \"$1\" in\n\t\t\tred)    _col=\"\\033[41m\\033[30m\";;\n\t\t\tgreen)  _col=\"\\033[42m\\033[30m\";;\n\t\t\tyellow) _col=\"\\033[43m\\033[30m\";;\n\t\t\tblue)   _col=\"\\033[44m\\033[30m\";;\n\t\t\t*)      _col=\"\";;\n\t\tesac\n\t\t_info_nol \"$_col $2 \\033[0m\"\n\tfi\n\t[ -n \"${3:-}\" ] && _info_nol \" ($3)\"\n\t_info\n\tunset _col\n}\n\n# Print the final status of a vulnerability (incl. batch mode)\n# Arguments are: CVE UNK/OK/VULN description\npvulnstatus()\n{\n\tpvulnstatus_last_cve=\"$1\"\n\tif [ \"$opt_batch\" = 1 ]; then\n\t\tcase \"$1\" in\n\t\t\tCVE-2017-5753) aka=\"SPECTRE VARIANT 1\";;\n\t\t\tCVE-2017-5715) aka=\"SPECTRE VARIANT 2\";;\n\t\t\tCVE-2017-5754) aka=\"MELTDOWN\";;\n\t\t\tCVE-2018-3640) aka=\"VARIANT 3A\";;\n\t\t\tCVE-2018-3639) aka=\"VARIANT 4\";;\n\t\t\tCVE-2018-3615) aka=\"L1TF SGX\";;\n\t\t\tCVE-2018-3620) aka=\"L1TF OS\";;\n\t\t\tCVE-2018-3646) aka=\"L1TF VMM\";;\n\t\t\tCVE-2018-12126) aka=\"MSBDS\";;\n\t\t\tCVE-2018-12130) aka=\"MFBDS\";;\n\t\t\tCVE-2018-12127) aka=\"MLPDS\";;\n\t\t\tCVE-2019-11091) aka=\"MDSUM\";;\n\t\t\tCVE-2019-11135) aka=\"TAA\";;\n\t\t\tCVE-2018-12207) aka=\"ITLBMH\";;\n\t\t\tCVE-2020-0543) aka=\"SRBDS\";;\n\t\t\tCVE-2023-20593) aka=\"ZENBLEED\";;\n\t\t\tCVE-2022-40982) aka=\"DOWNFALL\";;\n\t\t\tCVE-2023-20569) aka=\"INCEPTION\";;\n\t\t\tCVE-2023-23583) aka=\"REPTAR\";;\n\t\t\t*) echo \"$0: error: invalid CVE '$1' passed to pvulnstatus()\" >&2; exit 255;;\n\t\tesac\n\n\t\tcase \"$opt_batch_format\" in\n\t\t\ttext) _echo 0 \"$1: $2 ($3)\";;\n\t\t\tshort) short_output=\"${short_output}$1 \";;\n\t\t\tjson)\n\t\t\t\tcase \"$2\" in\n\t\t\t\t\tUNK)  is_vuln=\"null\";;\n\t\t\t\t\tVULN) is_vuln=\"true\";;\n\t\t\t\t\tOK)   is_vuln=\"false\";;\n\t\t\t\t\t*)    echo \"$0: error: unknown status '$2' passed to pvulnstatus()\" >&2; exit 255;;\n\t\t\t\tesac\n\t\t\t\t[ -z \"$json_output\" ] && json_output='['\n\t\t\t\tjson_output=\"${json_output}{\\\"NAME\\\":\\\"$aka\\\",\\\"CVE\\\":\\\"$1\\\",\\\"VULNERABLE\\\":$is_vuln,\\\"INFOS\\\":\\\"$3\\\"},\"\n\t\t\t\t;;\n\n\t\t\tnrpe)\t[ \"$2\" = VULN ] && nrpe_vuln=\"$nrpe_vuln $1\";;\n\t\t\tprometheus)\n\t\t\t\tprometheus_output=\"${prometheus_output:+$prometheus_output\\n}specex_vuln_status{name=\\\"$aka\\\",cve=\\\"$1\\\",status=\\\"$2\\\",info=\\\"$3\\\"} 1\"\n\t\t\t\t;;\n\t\t\t*) echo \"$0: error: invalid batch format '$opt_batch_format' specified\" >&2; exit 255;;\n\t\tesac\n\tfi\n\n\t# always fill global_* vars because we use that do decide the program exit code\n\tcase \"$2\" in\n\t\tUNK)  global_unknown=\"1\";;\n\t\tVULN) global_critical=\"1\";;\n\t\tOK)   ;;\n\t\t*)    echo \"$0: error: unknown status '$2' passed to pvulnstatus()\" >&2; exit 255;;\n\tesac\n\n\t# display info if we're not in quiet/batch mode\n\tvulnstatus=\"$2\"\n\tshift 2\n\t_info_nol \"> \\033[46m\\033[30mSTATUS:\\033[0m \"\n\t: \"${final_summary:=}\"\n\tcase \"$vulnstatus\" in\n\t\tUNK)  pstatus yellow 'UNKNOWN'        \"$@\"; final_summary=\"$final_summary \\033[43m\\033[30m$pvulnstatus_last_cve:??\\033[0m\";;\n\t\tVULN) pstatus red    'VULNERABLE'     \"$@\"; final_summary=\"$final_summary \\033[41m\\033[30m$pvulnstatus_last_cve:KO\\033[0m\";;\n\t\tOK)   pstatus green  'NOT VULNERABLE' \"$@\"; final_summary=\"$final_summary \\033[42m\\033[30m$pvulnstatus_last_cve:OK\\033[0m\";;\n\t\t*)    echo \"$0: error: unknown status '$vulnstatus' passed to pvulnstatus()\" >&2; exit 255;;\n\tesac\n}\n\n\n# The 3 below functions are taken from the extract-linux script, available here:\n# https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux\n# The functions have been modified for better integration to this script\n# The original header of the file has been retained below\n\n# ----------------------------------------------------------------------\n# extract-vmlinux - Extract uncompressed vmlinux from a kernel image\n#\n# Inspired from extract-ikconfig\n# (c) 2009,2010 Dick Streefland <dick@streefland.net>\n#\n# (c) 2011      Corentin Chary <corentin.chary@gmail.com>\n#\n# Licensed under the GNU General Public License, version 2 (GPLv2).\n# ----------------------------------------------------------------------\n\nkernel=''\nkernel_err=''\ncheck_kernel()\n{\n\t_file=\"$1\"\n\t_mode=\"${2:-normal}\"\n\t# checking the return code of readelf -h is not enough, we could get\n\t# a damaged ELF file and validate it, check for stderr warnings too\n\n\t# the warning \"readelf: Warning: [16]: Link field (0) should index a symtab section./\" can appear on valid kernels, ignore it\n\t_readelf_warnings=$(\"${opt_arch_prefix}readelf\" -S \"$_file\" 2>&1 >/dev/null | grep -v 'should index a symtab section' | tr \"\\n\" \"/\"); ret=$?\n\t_readelf_sections=$(\"${opt_arch_prefix}readelf\" -S \"$_file\" 2>/dev/null | grep -c -e data -e text -e init)\n\t_kernel_size=$(stat -c %s \"$_file\" 2>/dev/null || stat -f %z \"$_file\" 2>/dev/null || echo 10000)\n\t_debug \"check_kernel: ret=$? size=$_kernel_size sections=$_readelf_sections warnings=$_readelf_warnings\"\n\tif [ \"$_mode\" = desperate ]; then\n\t\tif \"${opt_arch_prefix}strings\" \"$_file\" | grep -Eq '^Linux version '; then\n\t\t\t_debug \"check_kernel (desperate): ... matched!\"\n\t\t\tif [ \"$_readelf_sections\" = 0 ] && grep -qF -e armv6 -e armv7 \"$_file\"; then\n\t\t\t\t_debug \"check_kernel (desperate): raw arm binary found, adjusting objdump options\"\n\t\t\t\tobjdump_options=\"-D -b binary -marm\"\n\t\t\telse\n\t\t\t\tobjdump_options=\"-d\"\n\t\t\tfi\n\t\t\treturn 0\n\t\telse\n\t\t\t_debug \"check_kernel (desperate): ... invalid\"\n\t\tfi\n\telse\n\t\tif [ $ret -eq 0 ] && [ -z \"$_readelf_warnings\" ] && [ \"$_readelf_sections\" -gt 0 ]; then\n\t\t\tif [ \"$_kernel_size\" -ge 100000 ]; then\n\t\t\t\t_debug \"check_kernel: ... file is valid\"\n\t\t\t\tobjdump_options=\"-d\"\n\t\t\t\treturn 0\n\t\t\telse\n\t\t\t\t_debug \"check_kernel: ... file seems valid but is too small, ignoring\"\n\t\t\tfi\n\t\telse\n\t\t\t_debug \"check_kernel: ... file is invalid\"\n\t\tfi\n\tfi\n\treturn 1\n}\n\ntry_decompress()\n{\n\t# The obscure use of the \"tr\" filter is to work around older versions of\n\t# \"grep\" that report the byte offset of the line instead of the pattern.\n\n\t# Try to find the header ($1) and decompress from here\n\t_debug \"try_decompress: looking for $3 magic in $6\"\n\tfor     pos in $(tr \"$1\\n$2\" \"\\n$2=\" < \"$6\" | grep -abo \"^$2\")\n\tdo\n\t\t_debug \"try_decompress: magic for $3 found at offset $pos\"\n\t\tif ! command -v \"$3\" >/dev/null 2>&1; then\n\t\t\tif [ \"$8\" = 1 ]; then\n\t\t\t\t# pass1: if the tool is not installed, just bail out silently\n\t\t\t\t# and hope that the next decompression tool will be, and that\n\t\t\t\t# it'll happen to be the proper one for this kernel\n\t\t\t\t_debug \"try_decompress: the '$3' tool is not installed (pass 1), try the next algo\"\n\t\t\telse\n\t\t\t\t# pass2: if the tool is not installed, populate kernel_err this time\n\t\t\t\tkernel_err=\"missing '$3' tool, please install it, usually it's in the '$5' package\"\n\t\t\t\t_debug \"try_decompress: $kernel_err\"\n\t\t\tfi\n\t\t\treturn 1\n\t\tfi\n\t\tpos=${pos%%:*}\n\t\t# shellcheck disable=SC2086\n\t\ttail -c+$pos \"$6\" 2>/dev/null | $3 $4 > \"$kerneltmp\" 2>/dev/null; ret=$?\n\t\tif [ ! -s \"$kerneltmp\" ]; then\n\t\t\t# don't rely on $ret, sometimes it's != 0 but worked\n\t\t\t# (e.g. gunzip ret=2 just means there was trailing garbage)\n\t\t\t_debug \"try_decompress: decompression with $3 failed (err=$ret)\"\n\t\telif check_kernel \"$kerneltmp\" \"$7\"; then\n\t\t\tkernel=\"$kerneltmp\"\n\t\t\t_debug \"try_decompress: decompressed with $3 successfully!\"\n\t\t\treturn 0\n\t\telif [ \"$3\" != \"cat\" ]; then\n\t\t\t_debug \"try_decompress: decompression with $3 worked but result is not a kernel, trying with an offset\"\n\t\t\t[ -z \"$kerneltmp2\" ] && kerneltmp2=$(mktemp -t smc-kernel-XXXXXX)\n\t\t\tcat \"$kerneltmp\" > \"$kerneltmp2\"\n\t\t\ttry_decompress '\\177ELF' xxy 'cat' '' cat \"$kerneltmp2\" && return 0\n\t\telse\n\t\t\t_debug \"try_decompress: decompression with $3 worked but result is not a kernel\"\n\t\tfi\n\tdone\n\treturn 1\n}\n\nextract_kernel()\n{\n\t[ -n \"${1:-}\" ] || return 1\n\t# Prepare temp files:\n\tkerneltmp=\"$(mktemp -t smc-kernel-XXXXXX)\"\n\n\t# Initial attempt for uncompressed images or objects:\n\tif check_kernel \"$1\"; then\n\t\t_debug \"extract_kernel: found kernel is valid, no decompression needed\"\n\t\tcat \"$1\" > \"$kerneltmp\"\n\t\tkernel=$kerneltmp\n\t\treturn 0\n\tfi\n\n\t# That didn't work, so retry after decompression.\n\tfor pass in 1 2; do\n\t\tfor mode in normal desperate; do\n\t\t\t_debug \"extract_kernel: pass $pass $mode mode\"\n\t\t\ttry_decompress '\\037\\213\\010'     xy    gunzip  ''      gunzip      \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress '\\002\\041\\114\\030' xyy   'lz4'   '-d -l' liblz4-tool \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress '\\3757zXZ\\000'     abcde unxz    ''      xz-utils    \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress 'BZh'              xy    bunzip2 ''      bzip2       \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress '\\135\\0\\0\\0'       xxx   unlzma  ''      xz-utils    \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress '\\211\\114\\132'     xy    'lzop'  '-d'    lzop        \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress '\\177ELF'          xxy   'cat'   ''      cat         \"$1\" \"$mode\" \"$pass\" && return 0\n\t\t\ttry_decompress '(\\265/\\375'       xxy   unzstd  ''      zstd        \"$1\" \"$mode\" \"$pass\" && return 0\n\t\tdone\n\tdone\n\t# kernel_err might already have been populated by try_decompress() if we're missing one of the tools\n\tif [ -z \"$kernel_err\" ]; then\n\t\tkernel_err=\"kernel compression format is unknown or image is invalid\"\n\tfi\n\t_verbose \"Couldn't extract the kernel image ($kernel_err), accuracy might be reduced\"\n\treturn 1\n}\n\n# end of extract-vmlinux functions\n\nmount_debugfs()\n{\n\tif [ ! -e /sys/kernel/debug/sched_features ]; then\n\t\t# try to mount the debugfs hierarchy ourselves and remember it to umount afterwards\n\t\tmount -t debugfs debugfs /sys/kernel/debug 2>/dev/null && mounted_debugfs=1\n\tfi\n}\n\nload_msr()\n{\n\t# only attempt to do it once even if called multiple times\n\t[ \"${load_msr_once:-}\" = 1 ] && return\n\tload_msr_once=1\n\n\tif [ \"$os\" = Linux ]; then\n\t\tif ! grep -qw msr \"$procfs/modules\" 2>/dev/null; then\n\t\t\tmodprobe msr 2>/dev/null && insmod_msr=1\n\t\t\t_debug \"attempted to load module msr, insmod_msr=$insmod_msr\"\n\t\telse\n\t\t\t_debug \"msr module already loaded\"\n\t\tfi\t\n\telse\n\t\tif ! kldstat -q -m cpuctl; then\n\t\t\tkldload cpuctl 2>/dev/null && kldload_cpuctl=1\n\t\t\t_debug \"attempted to load module cpuctl, kldload_cpuctl=$kldload_cpuctl\"\n\t\telse\n\t\t\t_debug \"cpuctl module already loaded\"\n\t\tfi\n\tfi\n}\n\nload_cpuid()\n{\n\t# only attempt to do it once even if called multiple times\n\t[ \"${load_cpuid_once:-}\" = 1 ] && return\n\tload_cpuid_once=1\n\n\tif [ \"$os\" = Linux ]; then\n\t\tif ! grep -qw cpuid \"$procfs/modules\" 2>/dev/null; then\n\t\t\tmodprobe cpuid 2>/dev/null && insmod_cpuid=1\n\t\t\t_debug \"attempted to load module cpuid, insmod_cpuid=$insmod_cpuid\"\n\t\telse\n\t\t\t_debug \"cpuid module already loaded\"\n\t\tfi\t\n\telse\n\t\tif ! kldstat -q -m cpuctl; then\n\t\t\tkldload cpuctl 2>/dev/null && kldload_cpuctl=1\n\t\t\t_debug \"attempted to load module cpuctl, kldload_cpuctl=$kldload_cpuctl\"\n\t\telse\n\t\t\t_debug \"cpuctl module already loaded\"\n\t\tfi\n\tfi\n}\n\n# shellcheck disable=SC2034\nEAX=1; EBX=2; ECX=3; EDX=4;\nREAD_CPUID_RET_OK=0\nREAD_CPUID_RET_KO=1\nREAD_CPUID_RET_ERR=2\nread_cpuid()\n{\n\tif [ \"$opt_cpu\" != all ]; then\n\t\t# we only have one core to read, do it and return the result\n\t\tread_cpuid_one_core $opt_cpu \"$@\"\n\t\treturn $?\n\tfi\n\n\t# otherwise we must read all cores\n\tfor _core in $(seq 0 \"$max_core_id\"); do\n\t\tread_cpuid_one_core \"$_core\" \"$@\"; ret=$?\n\t\tif [ \"$_core\" = 0 ]; then\n\t\t\t# save the result of the first core, for comparison with the others\n\t\t\t_first_core_ret=$ret\n\t\t\t_first_core_value=$read_cpuid_value\n\t\telse\n\t\t\t# compare first core with the other ones\n\t\t\tif [ $_first_core_ret != $ret ] || [ \"$_first_core_value\" != \"$read_cpuid_value\" ]; then\n\t\t\t\tread_cpuid_msg=\"result is not homogeneous between all cores, at least core 0 and $_core differ!\"\n\t\t\t\treturn $READ_CPUID_RET_ERR\n\t\t\tfi\n\t\tfi\n\tdone\n\t# if we're here, all cores agree, return the result\n\treturn $ret\n}\n\nread_cpuid_one_core()\n{\n\t# on which core to send the CPUID instruction\n\t_core=\"$1\"\n\t# leaf is the value of the eax register when calling the cpuid instruction:\n\t_leaf=\"$2\"\n\t# subleaf is the value of the ecx register when calling the cpuid instruction:\n\t_subleaf=\"$3\"\n\t# eax=1 ebx=2 ecx=3 edx=4:\n\t_register=\"$4\"\n\t# number of bits to shift the register right to, 0-31:\n\t_shift=\"$5\"\n\t# mask to apply as an AND operand to the shifted register value\n\t_mask=\"$6\"\n\t# wanted value (optional), if present we return 0(true) if the obtained value is equal, 1 otherwise:\n\t_wanted=\"${7:-}\"\n\t# in any case, the read value is globally available in $read_cpuid_value\n\tread_cpuid_value=''\n\tread_cpuid_msg='unknown error'\n\n\tif [ $# -lt 6 ]; then\n\t\tread_cpuid_msg=\"read_cpuid: missing arguments, got only $#, expected at least 6: $*\"\n\t\treturn $READ_CPUID_RET_ERR\n\tfi\n\tif [ \"$_register\" -gt 4 ]; then\n\t\tread_cpuid_msg=\"read_cpuid: register must be 0-4, got $_register\"\n\t\treturn $READ_CPUID_RET_ERR\n\tfi\n\tif [ \"$_shift\" -gt 32 ]; then\n\t\tread_cpuid_msg=\"read_cpuid: shift must be 0-31, got $_shift\"\n\t\treturn $READ_CPUID_RET_ERR\n\tfi\n\n\tif [ ! -e /dev/cpu/0/cpuid ] && [ ! -e /dev/cpuctl0 ]; then\n\t\t# try to load the module ourselves (and remember it so we can rmmod it afterwards)\n\t\tload_cpuid\n\tfi\n\n\tif [ -e /dev/cpu/0/cpuid ]; then\n\t\t# Linux\n\t\tif [ ! -r /dev/cpu/0/cpuid ]; then\n\t\t\tread_cpuid_msg=\"Couldn't load cpuid module\"\n\t\t\treturn $READ_CPUID_RET_ERR\n\t\tfi\n\t\t# on some kernel versions, /dev/cpu/0/cpuid doesn't imply that the cpuid module is loaded, in that case dd returns an error,\n\t\t# we use that fact to load the module if dd returns an error\n\t\tif ! dd if=/dev/cpu/0/cpuid bs=16 count=1 >/dev/null 2>&1; then\n\t\t\tload_cpuid\n\t\tfi\n\t\t# we need _leaf to be converted to decimal for dd\n\t\t_leaf=$(( _leaf ))\n\t\t_subleaf=$(( _subleaf ))\n\t\t_position=$(( _leaf + (_subleaf << 32) ))\n\t\t# to avoid using iflag=skip_bytes, which doesn't exist on old versions of dd, seek to the closer multiple-of-16\n\t\t_ddskip=$(( _position / 16 ))\n\t\t_odskip=$(( _position - _ddskip * 16 ))\n\t\t# now read the value\n\t\t_cpuid=$(dd if=\"/dev/cpu/$_core/cpuid\" bs=16 skip=$_ddskip count=$((_odskip + 1)) 2>/dev/null | od -j $((_odskip * 16)) -A n -t u4)\n\telif [ -e /dev/cpuctl0 ]; then\n\t\t# BSD\n\t\tif [ ! -r /dev/cpuctl0 ]; then\n\t\t\tread_cpuid_msg=\"Couldn't read cpuid info from cpuctl\"\n\t\t\treturn $READ_CPUID_RET_ERR\n\t\tfi\n\t\t_cpuid=$(cpucontrol -i \"$_leaf\",\"$_subleaf\" \"/dev/cpuctl$_core\" 2>/dev/null | cut -d: -f2-)\n\t\t# cpuid level 0x4, level_type 0x2: 0x1c004143 0x01c0003f 0x000001ff 0x00000000\n\telse\n\t\tread_cpuid_msg=\"Found no way to read cpuid info\"\n\t\treturn $READ_CPUID_RET_ERR\n\tfi\n\n\t_debug \"cpuid: leaf$_leaf subleaf$_subleaf on cpu$_core, eax-ebx-ecx-edx: $_cpuid\"\n\t_mockvarname=\"SMC_MOCK_CPUID_${_leaf}_${_subleaf}\"\n\t# shellcheck disable=SC1083\n\tif [ -n \"$(eval echo \\${$_mockvarname:-})\" ]; then\n\t\t_cpuid=\"$(eval echo \\$$_mockvarname)\"\n\t\t_debug \"read_cpuid: MOCKING enabled for leaf $_leaf subleaf $_subleaf, will return $_cpuid\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPUID_${_leaf}_${_subleaf}='$_cpuid'\")\n\tfi\n\tif [ -z \"$_cpuid\" ]; then\n\t\tread_cpuid_msg=\"Failed to get cpuid data\"\n\t\treturn $READ_CPUID_RET_ERR\n\tfi\n\n\t# get the value of the register we want\n\t_reg=$(echo \"$_cpuid\" | awk '{print $'\"$_register\"'}')\n\t# Linux returns it as decimal, BSD as hex, normalize to decimal\n\t_reg=$(( _reg ))\n\t# shellcheck disable=SC2046\n\t_debug \"cpuid: wanted register ($_register) has value $_reg aka \"$(printf \"%08x\" \"$_reg\")\n\t_reg_shifted=$(( _reg >> _shift ))\n\t# shellcheck disable=SC2046\n\t_debug \"cpuid: shifted value by $_shift is $_reg_shifted aka \"$(printf \"%x\" \"$_reg_shifted\")\n\tread_cpuid_value=$(( _reg_shifted & _mask ))\n\t# shellcheck disable=SC2046\n\t_debug \"cpuid: after AND $_mask, final value is $read_cpuid_value aka \"$(printf \"%x\" \"$read_cpuid_value\")\n\tif [ -n \"$_wanted\" ]; then\n\t\t_debug \"cpuid: wanted $_wanted and got $read_cpuid_value\"\n\t\tif [ \"$read_cpuid_value\" = \"$_wanted\" ]; then\n\t\t\treturn $READ_CPUID_RET_OK\n\t\telse\n\t\t\treturn $READ_CPUID_RET_KO\n\t\tfi\n\tfi\n\n\treturn $READ_CPUID_RET_OK\n}\n\ndmesg_grep()\n{\n\t# grep for something in dmesg, ensuring that the dmesg buffer\n\t# has not been truncated\n\tdmesg_grepped=''\n\tif ! dmesg | grep -qE -e '(^|\\] )Linux version [0-9]' -e '^FreeBSD is a registered' ; then\n\t\t# dmesg truncated\n\t\treturn 2\n\tfi\n\tdmesg_grepped=$(dmesg | grep -E \"$1\" | head -1)\n\t# not found:\n\t[ -z \"$dmesg_grepped\" ] && return 1\n\t# found, output is in $dmesg_grepped\n\treturn 0\n}\n\nis_coreos()\n{\n\tcommand -v coreos-install >/dev/null 2>&1 && command -v toolbox >/dev/null 2>&1 && return 0\n\treturn 1\n}\n\n# write_msr\n# param1 (mandatory): MSR, can be in hex or decimal.\n# param2 (optional): value to write, can be in hex or decimal.\n# param3 (optional): CPU index, starting from 0. Default 0.\nWRITE_MSR_RET_OK=0\nWRITE_MSR_RET_KO=1\nWRITE_MSR_RET_ERR=2\nWRITE_MSR_RET_LOCKDOWN=3\nwrite_msr()\n{\n\tif [ \"$opt_cpu\" != all ]; then\n\t\t# we only have one core to write to, do it and return the result\n\t\twrite_msr_one_core $opt_cpu \"$@\"\n\t\treturn $?\n\tfi\n\n\t# otherwise we must write on all cores\n\tfor _core in $(seq 0 \"$max_core_id\"); do\n\t\twrite_msr_one_core \"$_core\" \"$@\"; ret=$?\n\t\tif [ \"$_core\" = 0 ]; then\n\t\t\t# save the result of the first core, for comparison with the others\n\t\t\t_first_core_ret=$ret\n\t\telse\n\t\t\t# compare first core with the other ones\n\t\t\tif [ $_first_core_ret != $ret ]; then\n\t\t\t\twrite_msr_msg=\"result is not homogeneous between all cores, at least core 0 and $_core differ!\"\n\t\t\t\treturn $WRITE_MSR_RET_ERR\n\t\t\tfi\n\t\tfi\n\tdone\n\t# if we're here, all cores agree, return the result\n\treturn $ret\n}\n\nwrite_msr_one_core()\n{\n\t_core=\"$1\"\n\t_msr_dec=$(( $2 ))\n\t_msr=$(printf \"0x%x\" \"$_msr_dec\")\n\t_value_dec=$(( $3 ))\n\t_value=$(printf \"0x%x\" \"$_value_dec\")\n\n\twrite_msr_msg='unknown error'\n\t: \"${msr_locked_down:=0}\"\n\n\t_mockvarname=\"SMC_MOCK_WRMSR_${_msr}_RET\"\n\t# shellcheck disable=SC2086,SC1083\n\tif [ -n \"$(eval echo \\${$_mockvarname:-})\" ]; then\n\t\t_debug \"write_msr: MOCKING enabled for msr $_msr func returns $(eval echo \\$$_mockvarname)\"\n\t\tmocked=1\n\t\t[ \"$(eval echo \\$$_mockvarname)\" = $WRITE_MSR_RET_LOCKDOWN ] && msr_locked_down=1\n\t\treturn \"$(eval echo \\$$_mockvarname)\"\n\tfi\n\n\tif [ ! -e /dev/cpu/0/msr ] && [ ! -e /dev/cpuctl0 ]; then\n\t\t# try to load the module ourselves (and remember it so we can rmmod it afterwards)\n\t\tload_msr\n\tfi\n\tif [ ! -e /dev/cpu/0/msr ] && [ ! -e /dev/cpuctl0 ]; then\n\t\tread_msr_msg=\"is msr kernel module available?\"\n\t\treturn $WRITE_MSR_RET_ERR\n\tfi\n\n\t_write_denied=0\n\tif [ \"$os\" != Linux ]; then\n\t\tcpucontrol -m \"$_msr=$_value\" \"/dev/cpuctl$_core\" >/dev/null 2>&1; ret=$?\n\telse\n\t\t# for Linux\n\t\t# convert to decimal\n\t\tif [ ! -w /dev/cpu/\"$_core\"/msr ]; then\n\t\t\twrite_msr_msg=\"No write permission on /dev/cpu/$_core/msr\"\n\t\t\treturn $WRITE_MSR_RET_ERR\n\t\t# if wrmsr is available, use it\n\t\telif command -v wrmsr >/dev/null 2>&1 && [ \"${SMC_NO_WRMSR:-}\" != 1 ]; then\n\t\t\t_debug \"write_msr: using wrmsr\"\n\t\t\twrmsr $_msr_dec $_value_dec 2>/dev/null; ret=$?\n\t\t\t# ret=4: msr doesn't exist, ret=127: msr.allow_writes=off\n\t\t\t[ \"$ret\" = 127 ] && _write_denied=1\n\t\t# or fallback to dd if it supports seek_bytes, we prefer it over perl because we can tell the difference between EPERM and EIO\n\t\telif dd if=/dev/null of=/dev/null bs=8 count=1 seek=\"$_msr_dec\" oflag=seek_bytes 2>/dev/null && [ \"${SMC_NO_DD:-}\" != 1 ]; then\n\t\t\t_debug \"write_msr: using dd\"\n\t\t\tawk \"BEGIN{printf \\\"%c\\\", $_value_dec}\" | dd of=/dev/cpu/\"$_core\"/msr bs=8 count=1 seek=\"$_msr_dec\" oflag=seek_bytes 2>/dev/null; ret=$?\n\t\t\t# if it failed, inspect stderrto look for EPERM\n\t\t\tif [ \"$ret\" != 0 ]; then\n\t\t\t\tif awk \"BEGIN{printf \\\"%c\\\", $_value_dec}\" | dd of=/dev/cpu/\"$_core\"/msr bs=8 count=1 seek=\"$_msr_dec\" oflag=seek_bytes 2>&1 | grep -qF 'Operation not permitted'; then\n\t\t\t\t\t_write_denied=1\n\t\t\t\tfi\n\t\t\tfi\n\t\t# or if we have perl, use it, any 5.x version will work\n\t\telif command -v perl >/dev/null 2>&1 && [ \"${SMC_NO_PERL:-}\" != 1 ]; then\n\t\t\t_debug \"write_msr: using perl\"\n\t\t\tret=1\n\t\t\tperl -e \"open(M,'>','/dev/cpu/$_core/msr') and seek(M,$_msr_dec,0) and exit(syswrite(M,pack(v4,$_value_dec)))\"; [ $? -eq 8 ] && ret=0\n\t\telse\n\t\t\t_debug \"write_msr: got no wrmsr, perl or recent enough dd!\"\n\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_ERR\")\n\t\t\twrite_msr_msg=\"missing tool, install either msr-tools or perl\"\n\t\t\treturn $WRITE_MSR_RET_ERR\n\t\tfi\n\t\tif [ \"$ret\" != 0 ]; then\n\t\t\t# * Fedora (and probably Red Hat) have a \"kernel lock down\" feature that prevents us to write to MSRs\n\t\t\t# when this mode is enabled and EFI secure boot is enabled (see issue #303)\n\t\t\t# https://src.fedoraproject.org/rpms/kernel/blob/master/f/efi-lockdown.patch\n\t\t\t# when this happens, any write will fail and dmesg will have a msg printed \"msr: Direct access to MSR\"\n\t\t\t# * A version of this patch also made it to vanilla in 5.4+, in that case the message is: 'raw MSR access is restricted'\n\t\t\t# * we don't use dmesg_grep() because we don't care if dmesg is truncated here, as the message has just been printed\n\t\t\t# yet more recent versions of the msr module can be set to msr.allow_writes=off, in which case no dmesg message is printed,\n\t\t\t# but the write fails\n\t\t\tif [ \"$_write_denied\" = 1 ]; then\n\t\t\t\t_debug \"write_msr: writing to msr has been denied\"\n\t\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_LOCKDOWN\")\n\t\t\t\tmsr_locked_down=1\n\t\t\t\twrite_msr_msg=\"your kernel is configured to deny writes to MSRs from user space\"\n\t\t\t\treturn $WRITE_MSR_RET_LOCKDOWN\n\t\t\telif dmesg | grep -qF \"msr: Direct access to MSR\"; then\n\t\t\t\t_debug \"write_msr: locked down kernel detected (Red Hat / Fedora)\"\n\t\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_LOCKDOWN\")\n\t\t\t\tmsr_locked_down=1\n\t\t\t\twrite_msr_msg=\"your kernel is locked down (Fedora/Red Hat), please reboot without secure boot and retry\"\n\t\t\t\treturn $WRITE_MSR_RET_LOCKDOWN\n\t\t\telif dmesg | grep -qF \"raw MSR access is restricted\"; then\n\t\t\t\t_debug \"write_msr: locked down kernel detected (vanilla)\"\n\t\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_WRMSR_${_msr}_RET=$WRITE_MSR_RET_LOCKDOWN\")\n\t\t\t\tmsr_locked_down=1\n\t\t\t\twrite_msr_msg=\"your kernel is locked down, please reboot with lockdown=none in the kernel cmdline and retry\"\n\t\t\t\treturn $WRITE_MSR_RET_LOCKDOWN\n\t\t\tfi\n\t\t\tunset _write_denied\n\t\tfi\n\tfi\n\n\t# normalize ret\n\tif [ \"$ret\" = 0 ]; then\n\t\tret=$WRITE_MSR_RET_OK\n\telse\n\t\tret=$WRITE_MSR_RET_KO\n\tfi\n\t_debug \"write_msr: for cpu $_core on msr $_msr, value=$_value, ret=$ret\"\n\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_WRMSR_${_msr}_RET=$ret\")\n\treturn $ret\n}\n\n# read_msr\n# param1 (mandatory): MSR, can be in hex or decimal.\n# param2 (optional): CPU index, starting from 0. Default 0.\n# returned data is available in $read_msr_value\nREAD_MSR_RET_OK=0\nREAD_MSR_RET_KO=1\nREAD_MSR_RET_ERR=2\nread_msr()\n{\n\tif [ \"$opt_cpu\" != all ]; then\n\t\t# we only have one core to read, do it and return the result\n\t\tread_msr_one_core $opt_cpu \"$@\"\n\t\treturn $?\n\tfi\n\n\t# otherwise we must read all cores\n\tfor _core in $(seq 0 \"$max_core_id\"); do\n\t\tread_msr_one_core \"$_core\" \"$@\"; ret=$?\n\t\tif [ \"$_core\" = 0 ]; then\n\t\t\t# save the result of the first core, for comparison with the others\n\t\t\t_first_core_ret=$ret\n\t\t\t_first_core_value=$read_msr_value\n\t\telse\n\t\t\t# compare first core with the other ones\n\t\t\tif [ $_first_core_ret != $ret ] || [ \"$_first_core_value\" != \"$read_msr_value\" ]; then\n\t\t\t\tread_msr_msg=\"result is not homogeneous between all cores, at least core 0 and $_core differ!\"\n\t\t\t\treturn $READ_MSR_RET_ERR\n\t\t\tfi\n\t\tfi\n\tdone\n\t# if we're here, all cores agree, return the result\n\treturn $ret\n}\n\nread_msr_one_core()\n{\n\t_core=\"$1\"\n\t_msr_dec=$(( $2 ))\n\t_msr=$(printf \"0x%x\" \"$_msr_dec\")\n\n\tread_msr_value=''\n\tread_msr_msg='unknown error'\n\n\t_mockvarname=\"SMC_MOCK_RDMSR_${_msr}\"\n\t# shellcheck disable=SC2086,SC1083\n\tif [ -n \"$(eval echo \\${$_mockvarname:-})\" ]; then\n\t\tread_msr_value=\"$(eval echo \\$$_mockvarname)\"\n\t\t_debug \"read_msr: MOCKING enabled for msr $_msr, returning $read_msr_value\"\n\t\tmocked=1\n\t\treturn $READ_MSR_RET_OK\n\tfi\n\n\t_mockvarname=\"SMC_MOCK_RDMSR_${_msr}_RET\"\n\t# shellcheck disable=SC2086,SC1083\n\tif [ -n \"$(eval echo \\${$_mockvarname:-})\" ] && [ \"$(eval echo \\$$_mockvarname)\" -ne 0 ]; then\n\t\t_debug \"read_msr: MOCKING enabled for msr $_msr func returns $(eval echo \\$$_mockvarname)\"\n\t\tmocked=1\n\t\treturn \"$(eval echo \\$$_mockvarname)\"\n\tfi\n\n\tif [ ! -e /dev/cpu/0/msr ] && [ ! -e /dev/cpuctl0 ]; then\n\t\t# try to load the module ourselves (and remember it so we can rmmod it afterwards)\n\t\tload_msr\n\tfi\n\tif [ ! -e /dev/cpu/0/msr ] && [ ! -e /dev/cpuctl0 ]; then\n\t\tread_msr_msg=\"is msr kernel module available?\"\n\t\treturn $READ_MSR_RET_ERR\n\tfi\n\n\tif [ \"$os\" != Linux ]; then\n\t\t# for BSD\n\t\t_msr=$(cpucontrol -m \"$_msr\" \"/dev/cpuctl$_core\" 2>/dev/null); ret=$?\n\t\tif [ $ret -ne 0 ]; then\n\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_RDMSR_${_msr}_RET=$READ_MSR_RET_KO\")\n\t\t\treturn $READ_MSR_RET_KO\n\t\tfi\n\t\t# MSR 0x10: 0x000003e1 0xb106dded\n\t\t_msr_h=$(echo \"$_msr\" | awk '{print $3}');\n\t\t_msr_l=$(echo \"$_msr\" | awk '{print $4}');\n\t\tread_msr_value=$(( _msr_h << 32 | _msr_l ))\n\telse\n\t\t# for Linux\n\t\tif [ ! -r /dev/cpu/\"$_core\"/msr ]; then\n\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_RDMSR_${_msr}_RET=$READ_MSR_RET_ERR\")\n\t\t\tread_msr_msg=\"No read permission for /dev/cpu/$_core/msr\"\n\t\t\treturn $READ_MSR_RET_ERR\n\t\t# if rdmsr is available, use it\n\t\telif command -v rdmsr >/dev/null 2>&1 && [ \"${SMC_NO_RDMSR:-}\" != 1 ]; then\n\t\t\t_debug \"read_msr: using rdmsr on $_msr\"\n\t\t\tread_msr_value=$(rdmsr -r $_msr_dec 2>/dev/null | od -t u8 -A n)\n\t\t# or if we have perl, use it, any 5.x version will work\n\t\telif command -v perl >/dev/null 2>&1 && [ \"${SMC_NO_PERL:-}\" != 1 ]; then\n\t\t\t_debug \"read_msr: using perl on $_msr\"\n\t\t\tread_msr_value=$(perl -e \"open(M,'<','/dev/cpu/$_core/msr') and seek(M,$_msr_dec,0) and read(M,\\$_,8) and print\" | od -t u8 -A n)\n\t\t# fallback to dd if it supports skip_bytes\n\t\telif dd if=/dev/null of=/dev/null bs=8 count=1 skip=\"$_msr_dec\" iflag=skip_bytes 2>/dev/null; then\n\t\t\t_debug \"read_msr: using dd on $_msr\"\n\t\t\tread_msr_value=$(dd if=/dev/cpu/\"$_core\"/msr bs=8 count=1 skip=\"$_msr_dec\" iflag=skip_bytes 2>/dev/null | od -t u8 -A n)\n\t\telse\n\t\t\t_debug \"read_msr: got no rdmsr, perl or recent enough dd!\"\n\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_RDMSR_${_msr}_RET=$READ_MSR_RET_ERR\")\n\t\t\tread_msr_msg='missing tool, install either msr-tools or perl'\n\t\t\treturn $READ_MSR_RET_ERR\n\t\tfi\n\t\tif [ -z \"$read_msr_value\" ]; then\n\t\t\t# MSR doesn't exist, don't check for $? because some versions of dd still return 0!\n\t\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_RDMSR_${_msr}_RET=$READ_MSR_RET_KO\")\n\t\t\treturn $READ_MSR_RET_KO\n\t\tfi\n\t\t# remove sparse spaces od might give us\n\t\tread_msr_value=$(( read_msr_value ))\n\tfi\n\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_RDMSR_${_msr}='$read_msr_value'\")\n\t_debug \"read_msr: MSR=$_msr value is $read_msr_value\"\n\treturn $READ_MSR_RET_OK\n}\n\n\nparse_cpu_details()\n{\n\t[ \"${parse_cpu_details_done:-}\" = 1 ] && return 0\n\n\tif command -v nproc >/dev/null; then\n\t\tnumber_of_cores=$(nproc)\n\telif echo \"$os\" | grep -q BSD; then\n\t\tnumber_of_cores=$(sysctl -n hw.ncpu 2>/dev/null || echo 1)\n\telif [ -e \"$procfs/cpuinfo\" ]; then\n\t\tnumber_of_cores=$(grep -c ^processor \"$procfs/cpuinfo\" 2>/dev/null || echo 1)\n\telse\n\t\t# if we don't know, default to 1 CPU\n\t\tnumber_of_cores=1\n\tfi\n\tmax_core_id=$(( number_of_cores - 1 ))\n\n\thas_avx2=0\n\thas_avx512=0\n\tif [ -e \"$procfs/cpuinfo\" ]; then\n\t\tif grep -qw avx2 \"$procfs/cpuinfo\" 2>/dev/null; then has_avx2=1; fi\n\t\tif grep -qw avx512 \"$procfs/cpuinfo\" 2>/dev/null; then has_avx512=1; fi\n\t\tcpu_vendor=$(  grep '^vendor_id'  \"$procfs/cpuinfo\" | awk '{print $3}' | head -1)\n\t\tcpu_friendly_name=$(grep '^model name' \"$procfs/cpuinfo\" | cut -d: -f2- | head -1 | sed -e 's/^ *//')\n\t\t# special case for ARM follows\n\t\tif grep -qi 'CPU implementer[[:space:]]*:[[:space:]]*0x41' \"$procfs/cpuinfo\"; then\n\t\t\tcpu_vendor='ARM'\n\t\t\t# some devices (phones or other) have several ARMs and as such different part numbers,\n\t\t\t# an example is \"bigLITTLE\", so we need to store the whole list, this is needed for is_cpu_affected\n\t\t\tcpu_part_list=$(awk '/CPU part/         {print $4}' \"$procfs/cpuinfo\")\n\t\t\tcpu_arch_list=$(awk '/CPU architecture/ {print $3}' \"$procfs/cpuinfo\")\n\t\t\t# take the first one to fill the friendly name, do NOT quote the vars below\n\t\t\t# shellcheck disable=SC2086\n\t\t\tcpu_arch=$(echo $cpu_arch_list | awk '{ print $1 }')\n\t\t\t# shellcheck disable=SC2086\n\t\t\tcpu_part=$(echo $cpu_part_list | awk '{ print $1 }')\n\t\t\t[ \"$cpu_arch\" = \"AArch64\" ] && cpu_arch=8\n\t\t\tcpu_friendly_name=\"ARM\"\n\t\t\t[ -n \"$cpu_arch\" ] && cpu_friendly_name=\"$cpu_friendly_name v$cpu_arch\"\n\t\t\t[ -n \"$cpu_part\" ] && cpu_friendly_name=\"$cpu_friendly_name model $cpu_part\"\n\n\t\telif grep -qi 'CPU implementer[[:space:]]*:[[:space:]]*0x43' \"$procfs/cpuinfo\"; then\n\t\t\tcpu_vendor='CAVIUM'\n\t\telif grep -qi 'CPU implementer[[:space:]]*:[[:space:]]*0x70' \"$procfs/cpuinfo\"; then\n\t\t\tcpu_vendor='PHYTIUM'\n\t\tfi\n\n\t\tcpu_family=$(  grep '^cpu family' \"$procfs/cpuinfo\" | awk '{print $4}' | grep -E '^[0-9]+$' | head -1)\n\t\tcpu_model=$(   grep '^model'      \"$procfs/cpuinfo\" | awk '{print $3}' | grep -E '^[0-9]+$' | head -1)\n\t\tcpu_stepping=$(grep '^stepping'   \"$procfs/cpuinfo\" | awk '{print $3}' | grep -E '^[0-9]+$' | head -1)\n\t\tcpu_ucode=$(   grep '^microcode'  \"$procfs/cpuinfo\" | awk '{print $3}' | head -1)\n\telse\n\t\tcpu_vendor=$( dmesg | grep -i -m1 'Origin=' | cut -f2 -w | cut -f2 -d= | cut -f2 -d\\\" )\n\t\tcpu_family=$( dmesg | grep -i -m1 'Family=' | cut -f4 -w | cut -f2 -d= )\n\t\tcpu_family=$(( cpu_family ))\n\t\tcpu_model=$( dmesg | grep -i -m1 'Model=' | cut -f5 -w | cut -f2 -d= )\n\t\tcpu_model=$(( cpu_model ))\n\t\tcpu_stepping=$( dmesg | grep -i -m1 'Stepping=' | cut -f6 -w | cut -f2 -d= )\n\t\tcpu_friendly_name=$(sysctl -n hw.model 2>/dev/null)\n\tfi\n\n\t# Intel processors have a 3bit Platform ID field in MSR(17H) that specifies the platform type for up to 8 types\n\t# see https://elixir.bootlin.com/linux/v6.0/source/arch/x86/kernel/cpu/microcode/intel.c#L694\n\t# Set it to 8 (impossible value as it is 3 bit long) by default\n\tcpu_platformid=8\n\tif [ \"$cpu_vendor\" = GenuineIntel ] && [ \"$cpu_model\" -ge 5 ]; then\n\t\tread_msr 0x17; ret=$?\n\t\tif [ $ret = $READ_MSR_RET_OK ]; then\n\t\t\tcpu_platformid=$(( 1 << ( (read_msr_value >> 18) & 7) ))\n\t\tfi\n\tfi\n\n\tif [ -n \"${SMC_MOCK_CPU_FRIENDLY_NAME:-}\" ]; then\n\t\tcpu_friendly_name=\"$SMC_MOCK_CPU_FRIENDLY_NAME\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu friendly name to $cpu_friendly_name\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_FRIENDLY_NAME='$cpu_friendly_name'\")\n\tfi\n\tif [ -n \"${SMC_MOCK_CPU_VENDOR:-}\" ]; then\n\t\tcpu_vendor=\"$SMC_MOCK_CPU_VENDOR\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu vendor to $cpu_vendor\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_VENDOR='$cpu_vendor'\")\n\tfi\n\tif [ -n \"${SMC_MOCK_CPU_FAMILY:-}\" ]; then\n\t\tcpu_family=\"$SMC_MOCK_CPU_FAMILY\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu family to $cpu_family\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_FAMILY='$cpu_family'\")\n\tfi\n\tif [ -n \"${SMC_MOCK_CPU_MODEL:-}\" ]; then\n\t\tcpu_model=\"$SMC_MOCK_CPU_MODEL\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu model to $cpu_model\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_MODEL='$cpu_model'\")\n\tfi\n\tif [ -n \"${SMC_MOCK_CPU_STEPPING:-}\" ]; then\n\t\tcpu_stepping=\"$SMC_MOCK_CPU_STEPPING\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu stepping to $cpu_stepping\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_STEPPING='$cpu_stepping'\")\n\tfi\n\tif [ -n \"${SMC_MOCK_CPU_PLATFORMID:-}\" ]; then\n\t\tcpu_platformid=\"$SMC_MOCK_CPU_PLATFORMID\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu platformid name to $cpu_platformid\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_PLATFORMID='$cpu_platformid'\")\n\tfi\n\n\t# get raw cpuid, it's always useful (referenced in the Intel doc for firmware updates for example)\n\tif [ \"$mocked\" != 1 ] && read_cpuid 0x1 0x0 $EAX 0 0xFFFFFFFF; then\n\t\tcpu_cpuid=\"$read_cpuid_value\"\n\telse\n\t\t# try to build it by ourselves\n\t\t_debug \"parse_cpu_details: build the CPUID by ourselves\"\n\t\tcpu_cpuid=$(fms2cpuid \"$cpu_family\" \"$cpu_model\" \"$cpu_stepping\")\n\tfi\n\n\t# under BSD, linprocfs often doesn't export ucode information, so fetch it ourselves the good old way\n\tif [ -z \"$cpu_ucode\" ] && [ \"$os\" != Linux ]; then\n\t\tload_cpuid\n\t\tif [ -e /dev/cpuctl0 ]; then\n\t\t\t# init MSR with NULLs\n\t\t\tcpucontrol -m 0x8b=0 /dev/cpuctl0\n\t\t\t# call CPUID\n\t\t\tcpucontrol -i 1 /dev/cpuctl0 >/dev/null\n\t\t\t# read MSR\n\t\t\tcpu_ucode=$(cpucontrol -m 0x8b /dev/cpuctl0 | awk '{print $3}')\n\t\t\t# convert to decimal\n\t\t\tcpu_ucode=$(( cpu_ucode ))\n\t\t\t# convert back to hex\n\t\t\tcpu_ucode=$(printf \"0x%x\" \"$cpu_ucode\")\n\t\tfi\n\tfi\n\n\t# if we got no cpu_ucode (e.g. we're in a vm), fall back to 0x0\n\t: \"${cpu_ucode:=0x0}\"\n\n\tif [ -n \"${SMC_MOCK_CPU_UCODE:-}\" ]; then\n\t\tcpu_ucode=\"$SMC_MOCK_CPU_UCODE\"\n\t\t_debug \"parse_cpu_details: MOCKING cpu ucode to $cpu_ucode\"\n\t\tmocked=1\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPU_UCODE='$cpu_ucode'\")\n\tfi\n\n\techo \"$cpu_ucode\" | grep -q ^0x && cpu_ucode=$(( cpu_ucode ))\n\tucode_found=$(printf \"family 0x%x model 0x%x stepping 0x%x ucode 0x%x cpuid 0x%x pfid 0x%x\" \\\n\t\t\"$cpu_family\" \"$cpu_model\" \"$cpu_stepping\" \"$cpu_ucode\" \"$cpu_cpuid\" \"$cpu_platformid\")\n\n\t# also define those that we will need in other funcs\n\t# taken from https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/intel-family.h\n\t# curl -s 'https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/arch/x86/include/asm/intel-family.h' | awk '/#define INTEL_FAM6/ {print $2\"=$(( \"$3\" )) # \"$4,$5,$6,$7,$8,$9}' | sed -re 's/ +$//'\n\t# shellcheck disable=SC2034\n\t{\n\tINTEL_FAM6_CORE_YONAH=$(( 0x0E )) #\n\tINTEL_FAM6_CORE2_MEROM=$(( 0x0F )) #\n\tINTEL_FAM6_CORE2_MEROM_L=$(( 0x16 )) #\n\tINTEL_FAM6_CORE2_PENRYN=$(( 0x17 )) #\n\tINTEL_FAM6_CORE2_DUNNINGTON=$(( 0x1D )) #\n\tINTEL_FAM6_NEHALEM=$(( 0x1E )) #\n\tINTEL_FAM6_NEHALEM_G=$(( 0x1F )) # /* Auburndale / Havendale */\n\tINTEL_FAM6_NEHALEM_EP=$(( 0x1A )) #\n\tINTEL_FAM6_NEHALEM_EX=$(( 0x2E )) #\n\tINTEL_FAM6_WESTMERE=$(( 0x25 )) #\n\tINTEL_FAM6_WESTMERE_EP=$(( 0x2C )) #\n\tINTEL_FAM6_WESTMERE_EX=$(( 0x2F )) #\n\tINTEL_FAM6_SANDYBRIDGE=$(( 0x2A )) #\n\tINTEL_FAM6_SANDYBRIDGE_X=$(( 0x2D )) #\n\tINTEL_FAM6_IVYBRIDGE=$(( 0x3A )) #\n\tINTEL_FAM6_IVYBRIDGE_X=$(( 0x3E )) #\n\tINTEL_FAM6_HASWELL=$(( 0x3C )) #\n\tINTEL_FAM6_HASWELL_X=$(( 0x3F )) #\n\tINTEL_FAM6_HASWELL_L=$(( 0x45 )) #\n\tINTEL_FAM6_HASWELL_G=$(( 0x46 )) #\n\tINTEL_FAM6_BROADWELL=$(( 0x3D )) #\n\tINTEL_FAM6_BROADWELL_G=$(( 0x47 )) #\n\tINTEL_FAM6_BROADWELL_X=$(( 0x4F )) #\n\tINTEL_FAM6_BROADWELL_D=$(( 0x56 )) #\n\tINTEL_FAM6_SKYLAKE_L=$(( 0x4E )) # /* Sky Lake */\n\tINTEL_FAM6_SKYLAKE=$(( 0x5E )) # /* Sky Lake */\n\tINTEL_FAM6_SKYLAKE_X=$(( 0x55 )) # /* Sky Lake */\n\tINTEL_FAM6_KABYLAKE_L=$(( 0x8E )) # /* Sky Lake */\n\tINTEL_FAM6_KABYLAKE=$(( 0x9E )) # /* Sky Lake */\n\tINTEL_FAM6_COMETLAKE=$(( 0xA5 )) # /* Sky Lake */\n\tINTEL_FAM6_COMETLAKE_L=$(( 0xA6 )) # /* Sky Lake */\n\tINTEL_FAM6_CANNONLAKE_L=$(( 0x66 )) # /* Palm Cove */\n\tINTEL_FAM6_ICELAKE_X=$(( 0x6A )) # /* Sunny Cove */\n\tINTEL_FAM6_ICELAKE_D=$(( 0x6C )) # /* Sunny Cove */\n\tINTEL_FAM6_ICELAKE=$(( 0x7D )) # /* Sunny Cove */\n\tINTEL_FAM6_ICELAKE_L=$(( 0x7E )) # /* Sunny Cove */\n\tINTEL_FAM6_ICELAKE_NNPI=$(( 0x9D )) # /* Sunny Cove */\n\tINTEL_FAM6_LAKEFIELD=$(( 0x8A )) # /* Sunny Cove / Tremont */\n\tINTEL_FAM6_ROCKETLAKE=$(( 0xA7 )) # /* Cypress Cove */\n\tINTEL_FAM6_TIGERLAKE_L=$(( 0x8C )) # /* Willow Cove */\n\tINTEL_FAM6_TIGERLAKE=$(( 0x8D )) # /* Willow Cove */\n\tINTEL_FAM6_SAPPHIRERAPIDS_X=$(( 0x8F )) # /* Golden Cove */\n\tINTEL_FAM6_ALDERLAKE=$(( 0x97 )) # /* Golden Cove / Gracemont */\n\tINTEL_FAM6_ALDERLAKE_L=$(( 0x9A )) # /* Golden Cove / Gracemont */\n\tINTEL_FAM6_RAPTORLAKE=$(( 0xB7 )) #\n\tINTEL_FAM6_ATOM_BONNELL=$(( 0x1C )) # /* Diamondville, Pineview */\n\tINTEL_FAM6_ATOM_BONNELL_MID=$(( 0x26 )) # /* Silverthorne, Lincroft */\n\tINTEL_FAM6_ATOM_SALTWELL=$(( 0x36 )) # /* Cedarview */\n\tINTEL_FAM6_ATOM_SALTWELL_MID=$(( 0x27 )) # /* Penwell */\n\tINTEL_FAM6_ATOM_SALTWELL_TABLET=$(( 0x35 )) # /* Cloverview */\n\tINTEL_FAM6_ATOM_SILVERMONT=$(( 0x37 )) # /* Bay Trail, Valleyview */\n\tINTEL_FAM6_ATOM_SILVERMONT_D=$(( 0x4D )) # /* Avaton, Rangely */\n\tINTEL_FAM6_ATOM_SILVERMONT_MID=$(( 0x4A )) # /* Merriefield */\n\tINTEL_FAM6_ATOM_AIRMONT=$(( 0x4C )) # /* Cherry Trail, Braswell */\n\tINTEL_FAM6_ATOM_AIRMONT_MID=$(( 0x5A )) # /* Moorefield */\n\tINTEL_FAM6_ATOM_AIRMONT_NP=$(( 0x75 )) # /* Lightning Mountain */\n\tINTEL_FAM6_ATOM_GOLDMONT=$(( 0x5C )) # /* Apollo Lake */\n\tINTEL_FAM6_ATOM_GOLDMONT_D=$(( 0x5F )) # /* Denverton */\n\tINTEL_FAM6_ATOM_GOLDMONT_PLUS=$(( 0x7A )) # /* Gemini Lake */\n\tINTEL_FAM6_ATOM_TREMONT_D=$(( 0x86 )) # /* Jacobsville */\n\tINTEL_FAM6_ATOM_TREMONT=$(( 0x96 )) # /* Elkhart Lake */\n\tINTEL_FAM6_ATOM_TREMONT_L=$(( 0x9C )) # /* Jasper Lake */\n\tINTEL_FAM6_XEON_PHI_KNL=$(( 0x57 )) # /* Knights Landing */\n\tINTEL_FAM6_XEON_PHI_KNM=$(( 0x85 )) # /* Knights Mill */\n\t}\n\tparse_cpu_details_done=1\n}\nis_hygon()\n{\n\tparse_cpu_details\n\t[ \"$cpu_vendor\" = HygonGenuine ] && return 0\n\treturn 1\n}\n\nis_amd()\n{\n\tparse_cpu_details\n\t[ \"$cpu_vendor\" = AuthenticAMD ] && return 0\n\treturn 1\n}\n\nis_intel()\n{\n\tparse_cpu_details\n\t[ \"$cpu_vendor\" = GenuineIntel ] && return 0\n\treturn 1\n}\n\nis_cpu_smt_enabled()\n{\n\t# SMT / HyperThreading is enabled if siblings != cpucores\n\tif [ -e \"$procfs/cpuinfo\" ]; then\n\t\t_siblings=$(awk '/^siblings/  {print $3;exit}' \"$procfs/cpuinfo\")\n\t\t_cpucores=$(awk '/^cpu cores/ {print $4;exit}' \"$procfs/cpuinfo\")\n\t\tif [ -n \"$_siblings\" ] && [ -n \"$_cpucores\" ]; then\n\t\t\tif [ \"$_siblings\" = \"$_cpucores\" ]; then\n\t\t\t\treturn 1\n\t\t\telse\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tfi\n\t# we can't tell\n\treturn 2\n}\n\nis_ucode_blacklisted()\n{\n\tparse_cpu_details\n\t# if it's not an Intel, don't bother: it's not blacklisted\n\tis_intel || return 1\n\t# it also needs to be family=6\n\t[ \"$cpu_family\" = 6 ] || return 1\n\t# now, check each known bad microcode\n\t# source: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/cpu/intel.c#n105\n\t# 2018-02-08 update: https://newsroom.intel.com/wp-content/uploads/sites/11/2018/02/microcode-update-guidance.pdf\n\t# model,stepping,microcode\n\tfor tuple in \\\n\t\t$INTEL_FAM6_KABYLAKE,0x0B,0x80 \\\n\t\t$INTEL_FAM6_KABYLAKE,0x0A,0x80 \\\n\t\t$INTEL_FAM6_KABYLAKE,0x09,0x80 \\\n\t\t$INTEL_FAM6_KABYLAKE_L,0x0A,0x80  \\\n\t\t$INTEL_FAM6_KABYLAKE_L,0x09,0x80  \\\n\t\t$INTEL_FAM6_SKYLAKE_X,0x03,0x0100013e  \\\n\t\t$INTEL_FAM6_SKYLAKE_X,0x04,0x02000036  \\\n\t\t$INTEL_FAM6_SKYLAKE_X,0x04,0x0200003a  \\\n\t\t$INTEL_FAM6_SKYLAKE_X,0x04,0x0200003c  \\\n\t\t$INTEL_FAM6_BROADWELL,0x04,0x28   \\\n\t\t$INTEL_FAM6_BROADWELL_G,0x01,0x1b   \\\n\t\t$INTEL_FAM6_BROADWELL_D,0x02,0x14 \\\n\t\t$INTEL_FAM6_BROADWELL_D,0x03,0x07000011 \\\n\t\t$INTEL_FAM6_BROADWELL_X,0x01,0x0b000025 \\\n\t\t$INTEL_FAM6_HASWELL_L,0x01,0x21        \\\n\t\t$INTEL_FAM6_HASWELL_G,0x01,0x18     \\\n\t\t$INTEL_FAM6_HASWELL,0x03,0x23     \\\n\t\t$INTEL_FAM6_HASWELL_X,0x02,0x3b        \\\n\t\t$INTEL_FAM6_HASWELL_X,0x04,0x10        \\\n\t\t$INTEL_FAM6_IVYBRIDGE_X,0x04,0x42a     \\\n\t\t$INTEL_FAM6_SANDYBRIDGE_X,0x06,0x61b   \\\n\t\t$INTEL_FAM6_SANDYBRIDGE_X,0x07,0x712\n\tdo\n\t\tmodel=$(echo \"$tuple\" | cut -d, -f1)\n\t\tstepping=$(( $(echo \"$tuple\" | cut -d, -f2) ))\n\t\tif [ \"$cpu_model\" = \"$model\" ] && [ \"$cpu_stepping\" = \"$stepping\" ]; then\n\t\t\tucode=$(( $(echo \"$tuple\" | cut -d, -f3) ))\n\t\t\tif [ \"$cpu_ucode\" = \"$ucode\" ]; then\n\t\t\t\t_debug \"is_ucode_blacklisted: we have a match! ($cpu_model/$cpu_stepping/$cpu_ucode)\"\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\n\t# 2024-01-09 update: https://github.com/speed47/spectre-meltdown-checker/issues/475\n\t# this time the tuple is cpuid,microcode\n\tfor tuple in \\\n\t\t0xB0671,0x119  \\\n\t\t0xB06A2,0x4119 \\\n\t\t0xB06A3,0x4119\n\tdo\n\t\tcpuid=$(( $(echo \"$tuple\" | cut -d, -f1) ))\n\t\tucode=$(( $(echo \"$tuple\" | cut -d, -f2) ))\n\t\tif [ \"$cpu_cpuid\" = \"$cpuid\" ] && [ \"$cpu_ucode\" = \"$ucode\" ]; then\n\t\t\t_debug \"is_ucode_blacklisted: we have a match! ($cpuid/$ucode)\"\n\t\t\treturn 0\n\t\tfi\n\tdone\n\n\t_debug \"is_ucode_blacklisted: no ($cpu_model/$cpu_stepping/$cpu_ucode)\"\n\treturn 1\n}\n\nis_skylake_cpu()\n{\n\t# is this a skylake cpu?\n\t# return 0 if yes, 1 otherwise\n\t#if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t#\t\tboot_cpu_data.x86 == 6) {\n\t#\t\tswitch (boot_cpu_data.x86_model) {\n\t#\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t#\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t#\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t#\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t#\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t#\t\t\treturn true;\n\tparse_cpu_details\n\tis_intel || return 1\n\t[ \"$cpu_family\" = 6 ] || return 1\n\tif [ \"$cpu_model\" = $INTEL_FAM6_SKYLAKE_L       ] || \\\n\t\t[ \"$cpu_model\" = $INTEL_FAM6_SKYLAKE    ] || \\\n\t\t[ \"$cpu_model\" = $INTEL_FAM6_SKYLAKE_X  ] || \\\n\t\t[ \"$cpu_model\" = $INTEL_FAM6_KABYLAKE_L ] || \\\n\t\t[ \"$cpu_model\" = $INTEL_FAM6_KABYLAKE   ]; then\n\t\treturn 0\n\tfi\n\treturn 1\n}\n\nis_vulnerable_to_empty_rsb()\n{\n\tif is_intel && [ -z \"$capabilities_rsba\" ]; then\n\t\t_warn \"is_vulnerable_to_empty_rsb() called before ARCH CAPABILITIES MSR was read\"\n\tfi\n\tif is_skylake_cpu || [ \"$capabilities_rsba\" = 1 ]; then\n\t\treturn 0\n\tfi\n\treturn 1\n}\n\nis_zen_cpu()\n{\n\t# is this CPU from the AMD ZEN family ? (ryzen, epyc, ...)\n\tparse_cpu_details\n\tis_amd || return 1\n\t[ \"$cpu_family\" = 23 ] && return 0\n\treturn 1\n}\n\nis_moksha_cpu()\n{\n\tparse_cpu_details\n\tis_hygon || return 1\n\t[ \"$cpu_family\" = 24 ] && return 0\n\treturn 1\n}\n\n# mimick the Linux macro\n##define AMD_MODEL_RANGE(f, m_start, s_start, m_end, s_end) \\\n#\t((f << 24) | (m_start << 16) | (s_start << 12) | (m_end << 4) | (s_end))\namd_model_range()\n{\n\techo $(( ($1 << 24) | ($2 << 16) | ($3 << 12) | ($4 << 4) | ($5) ))\n}\n\n# mimick the Linux func, usage:\n# amd_legacy_erratum $(amd_model_range 0x17 0x30 0x0 0x4f 0xf)\n# return true (0) if the current CPU is affected by this erratum, 1 otherwise\namd_legacy_erratum()\n{\n\t_range=\"$1\"\n\t_ms=$((cpu_model << 4 | cpu_stepping))\n\tif [ \"$cpu_family\" = $(( ( (_range) >> 24) & 0xff )) ] && \\\n\t\t[ $_ms -ge $(( ( (_range) >> 12) & 0xfff )) ] && \\\n\t\t[ $_ms -le $(( (_range) & 0xfff )) ]; then\n\t\treturn 0\n\tfi\n\treturn 1\n}\n\n# returns 0 (true) if yes, 1 otherwise\n# returns 2 if not applicable\nhas_zenbleed_fixed_firmware()\n{\n\t# return cached data\n\t[ -n \"$zenbleed_fw\" ] && return \"$zenbleed_fw\"\n\t# or compute it:\n\tzenbleed_fw=2 # unknown\n\t# only amd\n\tif ! is_amd; then\n\t\tzenbleed_fw=1\n\t\treturn $zenbleed_fw\n\tfi\n\t# list of known fixed firmwares, from commit 522b1d69219d8f083173819fde04f994aa051a98\n\t_tuples=\"\n\t\t0x30,0x3f,0x0830107a\n\t\t0x60,0x67,0x0860010b\n\t\t0x68,0x6f,0x08608105\n\t\t0x70,0x7f,0x08701032\n\t\t0xa0,0xaf,0x08a00008\n\t\"\n\tfor tuple in $_tuples; do\n\t\t_model_low=$( echo \"$tuple\" | cut -d, -f1)\n\t\t_model_high=$(echo \"$tuple\" | cut -d, -f2)\n\t\t_fwver=$(     echo \"$tuple\" | cut -d, -f3)\n\t\tif [ $((cpu_model)) -ge $((_model_low)) ] && [ $((cpu_model)) -le $((_model_high)) ]; then\n\t\t\tif [ $((cpu_ucode)) -ge $((_fwver)) ]; then\n\t\t\t\tzenbleed_fw=0 # true\n\t\t\t\tbreak\n\t\t\telse\n\t\t\t\tzenbleed_fw=1 # false\n\t\t\t\tzenbleed_fw_required=$_fwver\n\t\t\tfi\n\t\tfi\n\tdone\n\tunset _tuples\n\treturn $zenbleed_fw\n}\n\n# Test if the current host is a Xen PV Dom0 / DomU\nis_xen() {\n\tif [ ! -d \"$procfs/xen\" ]; then\n\t\treturn 1\n\tfi\n\n\t# XXX do we have a better way that relying on dmesg?\n\tdmesg_grep 'Booting paravirtualized kernel on Xen$'; ret=$?\n\tif [ $ret -eq 2 ]; then\n\t\t_warn \"dmesg truncated, Xen detection will be unreliable. Please reboot and relaunch this script\"\n\t\treturn 1\n\telif [ $ret -eq 0 ]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\nis_xen_dom0()\n{\n\tif ! is_xen; then\n\t\treturn 1\n\tfi\n\n\tif [ -e \"$procfs/xen/capabilities\" ] && grep -q \"control_d\" \"$procfs/xen/capabilities\"; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\nis_xen_domU()\n{\n\tif ! is_xen; then\n\t\treturn 1\n\tfi\n\n\t# PVHVM guests also print 'Booting paravirtualized kernel', so we need this check.\n\tdmesg_grep 'Xen HVM callback vector for event delivery is enabled$'; ret=$?\n\tif [ $ret -eq 0 ]; then\n\t\treturn 1\n\tfi\n\n\tif ! is_xen_dom0; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\nbuiltin_dbversion=$(awk '/^# %%% MCEDB / { print $4 }' \"$0\")\nif [ -r \"$mcedb_cache\" ]; then\n\t# we have a local cache file, but it might be older than the builtin version we have\n\tlocal_dbversion=$(  awk '/^# %%% MCEDB / { print $4 }' \"$mcedb_cache\")\n\t# sort -V sorts by version number\n\tolder_dbversion=$(printf \"%b\\n%b\" \"$local_dbversion\" \"$builtin_dbversion\" | sort -V | head -n1)\n\tif [ \"$older_dbversion\" = \"$builtin_dbversion\" ]; then\n\t\tmcedb_source=\"$mcedb_cache\"\n\t\tmcedb_info=\"local firmwares DB $local_dbversion\"\n\tfi\nfi\n# if mcedb_source is not set, either we don't have a local cached db, or it is older than the builtin db\nif [ -z \"${mcedb_source:-}\" ]; then\n\tmcedb_source=\"$0\"\n\tmcedb_info=\"builtin firmwares DB $builtin_dbversion\"\nfi\nread_mcedb()\n{\n\tawk '{ if (DELIM==1) { print $2 } } /^# %%% MCEDB / { DELIM=1 }' \"$mcedb_source\"\n}\n\nread_inteldb()\n{\n\tif [ \"$opt_intel_db\" = 1 ]; then\n\t\tawk '/^# %%% ENDOFINTELDB/ { exit } { if (DELIM==1) { print $2 } } /^# %%% INTELDB/ { DELIM=1 }' \"$0\"\n\tfi\n\t# otherwise don't output nothing, it'll be as if the database is empty\n}\n\nis_latest_known_ucode()\n{\n\t# 0: yes, 1: no, 2: unknown\n\tparse_cpu_details\n\tif [ \"$cpu_cpuid\" = 0 ]; then\n\t\tucode_latest=\"couldn't get your cpuid\"\n\t\treturn 2\n\tfi\n\tucode_latest=\"latest microcode version for your CPU model is unknown\"\n\tif is_intel; then\n\t\tcpu_brand_prefix=I\n\telif is_amd; then\n\t\tcpu_brand_prefix=A\n\telse\n\t\treturn 2\n\tfi\n\tfor tuple in $(read_mcedb | grep \"$(printf \"^$cpu_brand_prefix,0x%08X,\" \"$cpu_cpuid\")\")\n\tdo\n\t\t# skip if the pfmask doesn't match our platformid\n\t\tpfmask=$(echo \"$tuple\" | cut -d, -f3)\n\t\tif is_intel && [ $((cpu_platformid & pfmask)) -eq 0 ]; then\n\t\t\tcontinue\n\t\tfi\n\t\tucode=$((  $(echo \"$tuple\" | cut -d, -f4) ))\n\t\tucode_date=$(echo \"$tuple\" | cut -d, -f5 | sed -r 's=(....)(..)(..)=\\1/\\2/\\3=')\n\t\t_debug \"is_latest_known_ucode: with cpuid $cpu_cpuid has ucode $cpu_ucode, last known is $ucode from $ucode_date\"\n\t\tucode_latest=$(printf \"latest version is 0x%x dated $ucode_date according to $mcedb_info\" \"$ucode\")\n\t\tif [ \"$cpu_ucode\" -ge \"$ucode\" ]; then\n\t\t\treturn 0\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\tdone\n\t_debug \"is_latest_known_ucode: this cpuid is not referenced ($cpu_cpuid)\"\n\treturn 2\n}\n\nget_cmdline()\n{\n\tif [ -n \"${kernel_cmdline:-}\" ]; then\n\t\treturn\n\tfi\n\n\tif [ -n \"${SMC_MOCK_CMDLINE:-}\" ]; then\n\t\tmocked=1\n\t\t_debug \"get_cmdline: using mocked cmdline '$SMC_MOCK_CMDLINE'\"\n\t\tkernel_cmdline=\"$SMC_MOCK_CMDLINE\"\n\t\treturn\n\telse\n\t\tkernel_cmdline=$(cat \"$procfs/cmdline\")\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CMDLINE='$kernel_cmdline'\")\n\tfi\n}\n\n# ENTRYPOINT\n\n# we can't do anything useful under WSL\nif uname -a | grep -qE -- '-Microsoft #[0-9]+-Microsoft '; then\n\t_warn \"This script doesn't work under Windows Subsystem for Linux\"\n\t_warn \"You should use the official Microsoft tool instead.\"\n\t_warn \"It can be found under https://aka.ms/SpeculationControlPS\"\n\texit 1\nfi\n\n# or other UNIX-ish OSes non-Linux non-supported-BSDs\nif [ \"$os\" = Darwin ] || [ \"$os\" = VMkernel ]; then\n\t_warn \"You're running under the $os OS, but this script\"\n\t_warn \"only works under Linux and some BSD systems, sorry.\"\n\t_warn \"Please read the README and FAQ for more information.\"\n\texit 1\nfi\n\n# check for mode selection inconsistency\nif [ \"$opt_hw_only\" = 1 ]; then\n\tif [ \"$opt_cve_all\" = 0 ]; then\n\t\tshow_usage\n\t\techo \"$0: error: incompatible modes specified, --hw-only vs --variant\" >&2\n\t\texit 255\n\telse\n\t\topt_cve_all=0\n\t\topt_cve_list=''\n\tfi\nfi\n\n# coreos mode\nif [ \"$opt_coreos\" = 1 ]; then\n\tif ! is_coreos; then\n\t\t_warn \"CoreOS mode asked, but we're not under CoreOS!\"\n\t\texit 255\n\tfi\n\t_warn \"CoreOS mode, starting an ephemeral toolbox to launch the script\"\n\tload_msr\n\tload_cpuid\n\tmount_debugfs\n\ttoolbox --ephemeral --bind-ro /dev/cpu:/dev/cpu -- sh -c \"dnf install -y binutils which && /media/root$PWD/$0 $* --coreos-within-toolbox\"\n\texitcode=$?\n\texit $exitcode\nelse\n\tif is_coreos; then\n\t\t_warn \"You seem to be running CoreOS, you might want to use the --coreos option for better results\"\n\t\t_warn\n\tfi\nfi\n\n# if we're under a BSD, try to mount linprocfs for \"$procfs/cpuinfo\"\nprocfs=/proc\nif echo \"$os\" | grep -q BSD; then\n\t_debug \"We're under BSD, check if we have procfs\"\n\tprocfs=$(mount | awk '/^linprocfs/ { print $3; exit; }')\n\tif [ -z \"$procfs\" ]; then\n\t\t_debug \"we don't, try to mount it\"\n\t\tprocfs=/proc\n\t\t[ -d /compat/linux/proc ] && procfs=/compat/linux/proc\n\t\ttest -d $procfs || mkdir $procfs\n\t\tif mount -t linprocfs linprocfs $procfs 2>/dev/null; then\n\t\t\tmounted_procfs=1\n\t\t\t_debug \"procfs just mounted at $procfs\"\n\t\telse\n\t\t\tprocfs=''\n\t\tfi\n\telse\n\t\t_debug \"We do: $procfs\"\n\tfi\nfi\n\n# define a few vars we might reference later without these being inited\nmockme=''\nmocked=0\nspecex_knob_dir=/dev/no_valid_path\n\n# if /tmp doesn't exist and TMPDIR is not set, try to set it to a sane default for Android\nif [ -z \"${TMPDIR:-}\" ] && ! [ -d \"/tmp\" ] && [ -d \"/data/local/tmp\" ]; then\n\tTMPDIR=/data/local/tmp\n\texport TMPDIR\nfi\n\nparse_cpu_details\nget_cmdline\n\nif [ \"$opt_cpu\" != all ] && [ \"$opt_cpu\" -gt \"$max_core_id\" ]; then\n\techo \"$0: error: --cpu can't be higher than $max_core_id, got $opt_cpu\" >&2\n\texit 255\nfi\n\nif [ \"$opt_live\" = 1 ]; then\n\t_info \"Checking for vulnerabilities on current system\"\n\t_info \"Kernel is \\033[35m$os $(uname -r) $(uname -v) $(uname -m)\\033[0m\"\n\t_info \"CPU is \\033[35m$cpu_friendly_name\\033[0m\"\n\n\t# try to find the image of the current running kernel\n\tif [ -n \"$opt_kernel\" ]; then\n\t\t# specified by user on cmdline, with --live, don't override\n\t\t:\n\t# first, look for the BOOT_IMAGE hint in the kernel cmdline\n\telif echo \"$kernel_cmdline\" | grep -q 'BOOT_IMAGE='; then\n\t\topt_kernel=$(echo \"$kernel_cmdline\" | grep -Eo 'BOOT_IMAGE=[^ ]+' | cut -d= -f2)\n\t\t_debug \"found opt_kernel=$opt_kernel in $procfs/cmdline\"\n\t\t# if the boot partition is within a btrfs subvolume, strip the subvolume name\n\t\t# if /boot is a separate subvolume, the remainder of the code in this section should handle it\n\t\tif echo \"$opt_kernel\" | grep -q \"^/@\"; then opt_kernel=$(echo \"$opt_kernel\" | sed \"s:/@[^/]*::\"); fi\n\t\t# if we have a dedicated /boot partition, our bootloader might have just called it /\n\t\t# so try to prepend /boot and see if we find anything\n\t\t[ -e \"/boot/$opt_kernel\" ] && opt_kernel=\"/boot/$opt_kernel\"\n\t\t# special case for CoreOS if we're inside the toolbox\n\t\t[ -e \"/media/root/boot/$opt_kernel\" ] && opt_kernel=\"/media/root/boot/$opt_kernel\"\n\t\t_debug \"opt_kernel is now $opt_kernel\"\n\t\t# else, the full path is already there (most probably /boot/something)\n\tfi\n\t# if we didn't find a kernel, default to guessing\n\tif [ ! -e \"$opt_kernel\" ]; then\n\t\t# Fedora:\n\t\t[ -e \"/lib/modules/$(uname -r)/vmlinuz\" ] && opt_kernel=\"/lib/modules/$(uname -r)/vmlinuz\"\n\t\t# Slackware:\n\t\t[ -e \"/boot/vmlinuz\"             ] && opt_kernel=\"/boot/vmlinuz\"\n\t\t# Arch aarch64:\n\t\t[ -e \"/boot/Image\"               ] && opt_kernel=\"/boot/Image\"\n\t\t# Arch armv5/armv7:\n\t\t[ -e \"/boot/zImage\"              ] && opt_kernel=\"/boot/zImage\"\n\t\t# Arch arm7:\n\t\t[ -e \"/boot/kernel7.img\"         ] && opt_kernel=\"/boot/kernel7.img\"\n\t\t# Linux-Libre:\n\t\t[ -e \"/boot/vmlinuz-linux-libre\" ] && opt_kernel=\"/boot/vmlinuz-linux-libre\"\n\t\t# pine64\n\t\t[ -e \"/boot/pine64/Image\"        ] && opt_kernel=\"/boot/pine64/Image\"\n\t\t# generic:\n\t\t[ -e \"/boot/vmlinuz-$(uname -r)\" ] && opt_kernel=\"/boot/vmlinuz-$(uname -r)\"\n\t\t[ -e \"/boot/kernel-$( uname -r)\" ] && opt_kernel=\"/boot/kernel-$( uname -r)\"\n\t\t[ -e \"/boot/bzImage-$(uname -r)\" ] && opt_kernel=\"/boot/bzImage-$(uname -r)\"\n\t\t# Gentoo:\n\t\t[ -e \"/boot/kernel-genkernel-$(uname -m)-$(uname -r)\" ] && opt_kernel=\"/boot/kernel-genkernel-$(uname -m)-$(uname -r)\"\n\t\t# NixOS:\n\t\t[ -e \"/run/booted-system/kernel\" ] && opt_kernel=\"/run/booted-system/kernel\"\n\t\t# Guix System:\n\t\t[ -e \"/run/booted-system/kernel/bzImage\" ] && opt_kernel=\"/run/booted-system/kernel/bzImage\"\n\t\t# systemd kernel-install:\n\t\t[ -e \"/etc/machine-id\" ] && [ -e \"/boot/$(cat /etc/machine-id)/$(uname -r)/linux\" ] && opt_kernel=\"/boot/$(cat /etc/machine-id)/$(uname -r)/linux\"\n\t\t# Clear Linux:\n\t\tstr_uname=$(uname -r)\n\t\tclear_linux_kernel=\"/lib/kernel/org.clearlinux.${str_uname##*.}.${str_uname%.*}\"\n\t\t[ -e \"$clear_linux_kernel\" ] && opt_kernel=$clear_linux_kernel\n\t\t# Custom Arch seems to have the kernel path in its cmdline in the form \"\\directory\\kernelimage\",\n\t\t# with actual \\'s instead of /'s:\n\t\tcustom_arch_kernel=$(echo \"$kernel_cmdline\" | grep -Eo \"(^|\\s)\\\\\\\\[\\\\\\\\a-zA-Z0-9_.-]+\" | tr \"\\\\\\\\\" \"/\" | tr -d '[:space:]')\n\t\tif [ -n \"$custom_arch_kernel\" ] && [ -e \"$custom_arch_kernel\" ]; then\n\t\t\topt_kernel=\"$custom_arch_kernel\"\n\t\tfi\n\t\t# FreeBSD:\n\t\t[ -e \"/boot/kernel/kernel\" ] && opt_kernel=\"/boot/kernel/kernel\"\n\tfi\n\n\t# system.map\n\tif [ -n \"$opt_map\" ]; then\n\t\t# specified by user on cmdline, with --live, don't override\n\t\t:\n\telif [ -e \"$procfs/kallsyms\" ] ; then\n\t\topt_map=\"$procfs/kallsyms\"\n\telif [ -e \"/lib/modules/$(uname -r)/System.map\" ] ; then\n\t\topt_map=\"/lib/modules/$(uname -r)/System.map\"\n\telif [ -e \"/boot/System.map-$(uname -r)\" ] ; then\n\t\topt_map=\"/boot/System.map-$(uname -r)\"\n\telif [ -e \"/lib/kernel/System.map-$(uname -r)\" ]; then\n\t\topt_map=\"/lib/kernel/System.map-$(uname -r)\"\n\tfi\n\n\t# config\n\tif [ -n \"$opt_config\" ]; then\n\t\t# specified by user on cmdline, with --live, don't override\n\t\t:\n\telif [ -e \"$procfs/config.gz\" ] ; then\n\t\tdumped_config=\"$(mktemp -t smc-config-XXXXXX)\"\n\t\tgunzip -c \"$procfs/config.gz\" > \"$dumped_config\"\n\t\t# dumped_config will be deleted at the end of the script\n\t\topt_config=\"$dumped_config\"\n\telif [ -e \"/lib/modules/$(uname -r)/config\" ]; then\n\t\topt_config=\"/lib/modules/$(uname -r)/config\"\n\telif [ -e \"/boot/config-$(uname -r)\" ]; then\n\t\topt_config=\"/boot/config-$(uname -r)\"\n\telif [ -e \"/etc/kernels/kernel-config-$(uname -m)-$(uname -r)\" ]; then\n\t\topt_config=\"/etc/kernels/kernel-config-$(uname -m)-$(uname -r)\"\n\telif [ -e \"/lib/kernel/config-$(uname -r)\" ]; then\n\t\topt_config=\"/lib/kernel/config-$(uname -r)\"\n\tfi\nelse\n\t_info \"Checking for vulnerabilities against specified kernel\"\n\t_info \"CPU is \\033[35m$cpu_friendly_name\\033[0m\"\nfi\n\nif [ -n \"$opt_kernel\" ]; then\n\t_verbose \"Will use kernel image \\033[35m$opt_kernel\\033[0m\"\nelse\n\t_verbose \"Will use no kernel image (accuracy might be reduced)\"\n\tbad_accuracy=1\nfi\n\nif [ \"$os\" = Linux ]; then\n\tif [ -n \"$opt_config\" ] && ! grep -q '^CONFIG_' \"$opt_config\"; then\n\t\t# given file is invalid!\n\t\t_warn \"The kernel config file seems invalid, was expecting a plain-text file, ignoring it!\"\n\t\topt_config=''\n\tfi\n\n\tif [ -n \"${dumped_config:-}\" ] && [ -n \"$opt_config\" ]; then\n\t\t_verbose \"Will use kconfig \\033[35m$procfs/config.gz (decompressed)\\033[0m\"\n\telif [ -n \"$opt_config\" ]; then\n\t\t_verbose \"Will use kconfig \\033[35m$opt_config\\033[0m\"\n\telse\n\t\t_verbose \"Will use no kconfig (accuracy might be reduced)\"\n\t\tbad_accuracy=1\n\tfi\n\n\tif [ -n \"$opt_map\" ]; then\n\t\t_verbose \"Will use System.map file \\033[35m$opt_map\\033[0m\"\n\telse\n\t\t_verbose \"Will use no System.map file (accuracy might be reduced)\"\n\t\tbad_accuracy=1\n\tfi\n\n\tif [ \"${bad_accuracy:=0}\" = 1 ]; then\n\t\t_warn \"We're missing some kernel info (see -v), accuracy might be reduced\"\n\tfi\nfi\n\nif [ -e \"$opt_kernel\" ]; then\n\tif ! command -v \"${opt_arch_prefix}readelf\" >/dev/null 2>&1; then\n\t\t_debug \"readelf not found\"\n\t\tkernel_err=\"missing '${opt_arch_prefix}readelf' tool, please install it, usually it's in the 'binutils' package\"\n\telif [ \"$opt_sysfs_only\" = 1 ] || [ \"$opt_hw_only\" = 1 ]; then\n\t\tkernel_err='kernel image decompression skipped'\n\telse\n\t\textract_kernel \"$opt_kernel\"\n\tfi\nelse\n\t_debug \"no opt_kernel defined\"\n\tkernel_err=\"couldn't find your kernel image in /boot, if you used netboot, this is normal\"\nfi\nif [ -z \"$kernel\" ] || [ ! -r \"$kernel\" ]; then\n\t[ -z \"$kernel_err\" ] && kernel_err=\"couldn't extract your kernel from $opt_kernel\"\nelse\n\t# vanilla kernels have with ^Linux version\n\t# also try harder with some kernels (such as Red Hat) that don't have ^Linux version before their version string\n\t# and check for FreeBSD\n\tkernel_version=$(\"${opt_arch_prefix}strings\" \"$kernel\" 2>/dev/null | grep -E \\\n\t\t-e '^Linux version ' \\\n\t\t-e '^[[:alnum:]][^[:space:]]+ \\([^[:space:]]+\\) #[0-9]+ .+ (19|20)[0-9][0-9]$' \\\n\t\t-e '^FreeBSD [0-9]' | grep -v 'ABI compat' | head -1)\n\tif [ -z \"$kernel_version\" ]; then\n\t\t# try even harder with some kernels (such as ARM) that split the release (uname -r) and version (uname -v) in 2 adjacent strings\n\t\tkernel_version=$(\"${opt_arch_prefix}strings\" \"$kernel\" 2>/dev/null | grep -E -B1 '^#[0-9]+ .+ (19|20)[0-9][0-9]$' | tr \"\\n\" \" \")\n\tfi\n\tif [ -n \"$kernel_version\" ]; then\n\t\t# in live mode, check if the img we found is the correct one\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t_verbose \"Kernel image is \\033[35m$kernel_version\"\n\t\t\tif ! echo \"$kernel_version\" | grep -qF \"$(uname -r)\"; then\n\t\t\t\t_warn \"Possible discrepancy between your running kernel '$(uname -r)' and the image '$kernel_version' we found ($opt_kernel), results might be incorrect\"\n\t\t\tfi\n\t\telse\n\t\t\t_info \"Kernel image is \\033[35m$kernel_version\"\n\t\tfi\n\telse\n\t\t_verbose \"Kernel image version is unknown\"\n\tfi\nfi\n\n_info\n\n# end of header stuff\n\n# now we define some util functions and the check_*() funcs, as\n# the user can choose to execute only some of those\n\nsys_interface_check()\n{\n\tfile=\"$1\"\n\tregex=\"${2:-}\"\n\tmode=\"${3:-}\"\n\tmsg=''\n\tfullmsg=''\n\n\tif [ \"$opt_live\" = 1 ] && [ \"$opt_no_sysfs\" = 0 ] && [ -r \"$file\" ]; then\n\t\t:\n\telse\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_SYSFS_$(basename \"$file\")_RET=1\")\n\t\treturn 1\n\tfi\n\n\t_mockvarname=\"SMC_MOCK_SYSFS_$(basename \"$file\")_RET\"\n\t# shellcheck disable=SC2086,SC1083\n\tif [ -n \"$(eval echo \\${$_mockvarname:-})\" ]; then\n\t\t_debug \"sysfs: MOCKING enabled for $file func returns $(eval echo \\$$_mockvarname)\"\n\t\tmocked=1\n\t\treturn \"$(eval echo \\$$_mockvarname)\"\n\tfi\n\n\t[ -n \"$regex\" ] || regex='.*'\n\t_mockvarname=\"SMC_MOCK_SYSFS_$(basename \"$file\")\"\n\t# shellcheck disable=SC2086,SC1083\n\tif [ -n \"$(eval echo \\${$_mockvarname:-})\" ]; then\n\t\tfullmsg=\"$(eval echo \\$$_mockvarname)\"\n\t\tmsg=$(echo \"$fullmsg\" | grep -Eo \"$regex\")\n\t\t_debug \"sysfs: MOCKING enabled for $file, will return $fullmsg\"\n\t\tmocked=1\n\telse\n\t\tfullmsg=$(cat \"$file\")\n\t\tmsg=$(grep -Eo \"$regex\" \"$file\")\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_SYSFS_$(basename \"$file\")='$fullmsg'\")\n\tfi\n\tif [ \"$mode\" = silent ]; then\n\t\treturn 0\n\telif [ \"$mode\" = quiet ]; then\n\t\t_info \"* Information from the /sys interface: $fullmsg\"\n\t\treturn 0\n\tfi\n\t_info_nol \"* Mitigated according to the /sys interface: \"\n\tif echo \"$msg\" | grep -qi '^not affected'; then\n\t\t# Not affected\n\t\tstatus=OK\n\t\tpstatus green YES \"$fullmsg\"\n\telif echo \"$msg\" | grep -qEi '^(kvm: )?mitigation'; then\n\t\t# Mitigation: PTI\n\t\tstatus=OK\n\t\tpstatus green YES \"$fullmsg\"\n\telif echo \"$msg\" | grep -qi '^vulnerable'; then\n\t\t# Vulnerable\n\t\tstatus=VULN\n\t\tpstatus yellow NO \"$fullmsg\"\n\telse\n\t\tstatus=UNK\n\t\tpstatus yellow UNKNOWN \"$fullmsg\"\n\tfi\n\t_debug \"sys_interface_check: $file=$msg (re=$regex)\"\n\treturn 0\n}\n\ncheck_cpu()\n{\n\t_info \"\\033[1;34mHardware check\\033[0m\"\n\n\tif ! uname -m | grep -qwE 'x86_64|i[3-6]86|amd64'; then\n\t\treturn\n\tfi\n\n\t_info     \"* Hardware support (CPU microcode) for mitigation techniques\"\n\t_info     \"  * Indirect Branch Restricted Speculation (IBRS)\"\n\t_info_nol \"    * SPEC_CTRL MSR is available: \"\n\t# the new MSR 'SPEC_CTRL' is at offset 0x48\n\tread_msr 0x48; ret=$?\n\tif [ $ret = $READ_MSR_RET_OK ]; then\n\t\tspec_ctrl_msr=1\n\t\tpstatus green YES\n\telif [ $ret = $READ_MSR_RET_KO ]; then\n\t\tspec_ctrl_msr=0\n\t\tpstatus yellow NO\n\telse\n\t\tspec_ctrl_msr=-1\n\t\tpstatus yellow UNKNOWN \"$read_msr_msg\"\n\tfi\n\n\t_info_nol \"    * CPU indicates IBRS capability: \"\n\t# from kernel src: { X86_FEATURE_SPEC_CTRL,        CPUID_EDX,26, 0x00000007, 0 },\n\t# amd: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf\n\t# amd: 8000_0008 EBX[14]=1\n\tcpuid_ibrs=''\n\tif is_intel; then\n\t\tread_cpuid 0x7 0x0 $EDX 26 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES \"SPEC_CTRL feature bit\"\n\t\t\tcpuid_spec_ctrl=1\n\t\t\tcpuid_ibrs='SPEC_CTRL'\n\t\tfi\n\telif is_amd || is_hygon; then\n\t\tread_cpuid 0x80000008 0x0 $EBX 14 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES \"IBRS_SUPPORT feature bit\"\n\t\t\tcpuid_ibrs='IBRS_SUPPORT'\n\t\tfi\n\telse\n\t\tret=invalid\n\t\tpstatus yellow NO \"unknown CPU\"\n\tfi\n\tif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\tpstatus yellow NO\n\telif [ $ret = $READ_CPUID_RET_ERR ]; then\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tcpuid_spec_ctrl=-1\n\tfi\n\n\tif is_amd || is_hygon; then\n\t\t_info_nol \"    * CPU indicates preferring IBRS always-on: \"\n\t\t# amd or hygon\n\t\tread_cpuid 0x80000008 0x0 $EBX 16 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\n\t\t_info_nol \"    * CPU indicates preferring IBRS over retpoline: \"\n\t\t# amd or hygon\n\t\tread_cpuid 0x80000008 0x0 $EBX 18 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\tfi\n\n\t# IBPB\n\t_info     \"  * Indirect Branch Prediction Barrier (IBPB)\"\n\n\tif [ \"$opt_allow_msr_write\" = 1 ]; then\n\t\t_info_nol \"    * PRED_CMD MSR is available: \"\n\t\t# the new MSR 'PRED_CTRL' is at offset 0x49, write-only\n\t\twrite_msr 0x49; ret=$?\n\t\tif [ $ret = $WRITE_MSR_RET_OK ]; then\n\t\t\tpstatus green YES\n\t\telif [ $ret = $WRITE_MSR_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$write_msr_msg\"\n\t\tfi\n\tfi\n\n\t_info_nol \"    * CPU indicates IBPB capability: \"\n\t# CPUID EAX=0x80000008, ECX=0x00 return EBX[12] indicates support for just IBPB.\n\tif [ \"$cpuid_spec_ctrl\" = 1 ]; then\n\t\t# spec_ctrl implies ibpb\n\t\tcpuid_ibpb='SPEC_CTRL'\n\t\tpstatus green YES \"SPEC_CTRL feature bit\"\n\telif is_intel; then\n\t\tif [ \"$cpuid_spec_ctrl\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN \"is cpuid kernel module available?\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\telif is_amd || is_hygon; then\n\t\tread_cpuid 0x80000008 0x0 $EBX 12 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ibpb='IBPB_SUPPORT'\n\t\t\tpstatus green YES \"IBPB_SUPPORT feature bit\"\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\tfi\n\n\t# STIBP\n\t_info     \"  * Single Thread Indirect Branch Predictors (STIBP)\"\n\t_info_nol \"    * SPEC_CTRL MSR is available: \"\n\tif [ \"$spec_ctrl_msr\" = 1 ]; then\n\t\tpstatus green YES\n\telif [ \"$spec_ctrl_msr\" = 0 ]; then\n\t\tpstatus yellow NO\n\telse\n\t\tpstatus yellow UNKNOWN \"is msr kernel module available?\"\n\tfi\n\n\t_info_nol \"    * CPU indicates STIBP capability: \"\n\t# intel: A processor supports STIBP if it enumerates CPUID (EAX=7H,ECX=0):EDX[27] as 1\n\t# amd: 8000_0008 EBX[15]=1\n\tif is_intel; then\n\t\tread_cpuid 0x7 0x0 $EDX 27 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES \"Intel STIBP feature bit\"\n\t\t\t#cpuid_stibp='Intel STIBP'\n\t\tfi\n\telif is_amd; then\n\t\tread_cpuid 0x80000008 0x0 $EBX 15 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES \"AMD STIBP feature bit\"\n\t\t\t#cpuid_stibp='AMD STIBP'\n\t\tfi\n\telif is_hygon; then\n\t\tread_cpuid 0x80000008 0x0 $EBX 15 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES \"HYGON STIBP feature bit\"\n\t\t\t#cpuid_stibp='HYGON STIBP'\n\t\tfi\n\telse\n\t\tret=invalid\n\t\tpstatus yellow UNKNOWN \"unknown CPU\"\n\tfi\n\tif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\tpstatus yellow NO\n\telif [ $ret = $READ_CPUID_RET_ERR ]; then\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\tfi\n\n\n\tif is_amd || is_hygon; then\n\t\t_info_nol \"    * CPU indicates preferring STIBP always-on: \"\n\t\tread_cpuid 0x80000008 0x0 $EBX 17 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\tfi\n\n\t# variant 4\n\tif is_intel; then\n\t\t_info     \"  * Speculative Store Bypass Disable (SSBD)\"\n\t\t_info_nol \"    * CPU indicates SSBD capability: \"\n\t\tread_cpuid 0x7 0x0 $EDX 31 1 1; ret24=$?; ret25=$ret24\n\t\tif [ $ret24 = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ssbd='Intel SSBD'\n\t\tfi\n\telif is_amd; then\n\t\t_info     \"  * Speculative Store Bypass Disable (SSBD)\"\n\t\t_info_nol \"    * CPU indicates SSBD capability: \"\n\t\tread_cpuid 0x80000008 0x0 $EBX 24 1 1; ret24=$?\n\t\tread_cpuid 0x80000008 0x0 $EBX 25 1 1; ret25=$?\n\t\tif [ $ret24 = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ssbd='AMD SSBD in SPEC_CTRL'\n\t\t\t#cpuid_ssbd_spec_ctrl=1\n\t\telif [ $ret25 = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ssbd='AMD SSBD in VIRT_SPEC_CTRL'\n\t\t\t#cpuid_ssbd_virt_spec_ctrl=1\n\t\telif [ \"$cpu_family\" -ge 21 ] && [ \"$cpu_family\" -le 23 ]; then\n\t\t\tcpuid_ssbd='AMD non-architectural MSR'\n\t\tfi\n\telif is_hygon; then\n\t\t_info     \"  * Speculative Store Bypass Disable (SSBD)\"\n\t\t_info_nol \"    * CPU indicates SSBD capability: \"\n\t\tread_cpuid 0x80000008 0x0 $EBX 24 1 1; ret24=$?\n\t\tread_cpuid 0x80000008 0x0 $EBX 25 1 1; ret25=$?\n\n\t\tif [ $ret24 = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ssbd='HYGON SSBD in SPEC_CTRL'\n\t\t\t#hygon cpuid_ssbd_spec_ctrl=1\n\t\telif [ $ret25 = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ssbd='HYGON SSBD in VIRT_SPEC_CTRL'\n\t\t\t#hygon cpuid_ssbd_virt_spec_ctrl=1\n\t\telif [ \"$cpu_family\" -ge 24 ]; then\n\t\t\tcpuid_ssbd='HYGON non-architectural MSR'\n\t\tfi\n\tfi\n\n\tif [ -n \"${cpuid_ssbd:=}\" ]; then\n\t\tpstatus green YES \"$cpuid_ssbd\"\n\telif [ \"$ret24\" = $READ_CPUID_RET_ERR ] && [ \"$ret25\" = $READ_CPUID_RET_ERR ]; then\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\telse\n\t\tpstatus yellow NO\n\tfi\n\n\tamd_ssb_no=0\n\thygon_ssb_no=0\n\tif is_amd; then\n\t\t# similar to SSB_NO for intel\n\t\tread_cpuid 0x80000008 0x0 $EBX 26 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tamd_ssb_no=1\n\t\telif [ $ret = $READ_CPUID_RET_ERR ]; then\n\t\t\tamd_ssb_no=-1\n\t\tfi\n\telif is_hygon; then\n\t\t# indicate when speculative store bypass disable is no longer needed to prevent speculative loads bypassing older stores\n\t\tread_cpuid 0x80000008 0x0 $EBX 26 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\thygon_ssb_no=1\n\t\telif [ $ret = $READ_CPUID_RET_ERR ]; then\n\t\t\thygon_ssb_no=-1\n\t\tfi\n\tfi\n\n\t_info \"  * L1 data cache invalidation\"\n\n\tif [ \"$opt_allow_msr_write\" = 1 ]; then\n\t\t_info_nol \"    * FLUSH_CMD MSR is available: \"\n\t\t# the new MSR 'FLUSH_CMD' is at offset 0x10b, write-only\n\t\twrite_msr 0x10b; ret=$?\n\t\tif [ $ret = $WRITE_MSR_RET_OK ]; then\n\t\t\tpstatus green YES\n\t\t\tcpu_flush_cmd=1\n\t\telif [ $ret = $WRITE_MSR_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\t\tcpu_flush_cmd=0\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$write_msr_msg\"\n\t\t\tcpu_flush_cmd=-1\n\t\tfi\n\tfi\n\n\t# CPUID of L1D\n\t_info_nol \"    * CPU indicates L1D flush capability: \"\n\tread_cpuid 0x7 0x0 $EDX 28 1 1; ret=$?\n\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\tpstatus green YES \"L1D flush feature bit\"\n\t\tcpuid_l1df=1\n\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\tpstatus yellow NO\n\t\tcpuid_l1df=0\n\telse\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tcpuid_l1df=-1\n\tfi\n\n\t# if we weren't allowed to probe the write-only MSR but the CPUID\n\t# bit says that it shoul be there, make the assumption that it is\n\tif [ \"$opt_allow_msr_write\" != 1 ]; then\n\t\tcpu_flush_cmd=$cpuid_l1df\n\tfi\n\n\tif is_intel; then\n\t\t_info     \"  * Microarchitectural Data Sampling\"\n\t\t_info_nol \"    * VERW instruction is available: \"\n\t\tread_cpuid 0x7 0x0 $EDX 10 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_md_clear=1\n\t\t\tpstatus green YES \"MD_CLEAR feature bit\"\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tcpuid_md_clear=0\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tcpuid_md_clear=-1\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\tfi\n\n\tif is_intel; then\n\t\t_info     \"  * Indirect Branch Predictor Controls\"\n\t\t_info_nol \"    * Indirect Predictor Disable feature is available: \"\n\t\tread_cpuid 0x7 0x2 $EDX 1 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_ipred=1\n\t\t\tpstatus green YES \"IPRED_CTRL feature bit\"\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tcpuid_ipred=0\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tcpuid_ipred=-1\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\n\t\t_info_nol \"    * Bottomless RSB Disable feature is available: \"\n\t\tread_cpuid 0x7 0x2 $EDX 2 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_rrsba=1\n\t\t\tpstatus green YES \"RRSBA_CTRL feature bit\"\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tcpuid_rrsba=0\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tcpuid_rrsba=-1\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\n\t\t_info_nol \"    * BHB-Focused Indirect Predictor Disable feature is available: \"\n\t\tread_cpuid 0x7 0x2 $EDX 2 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpuid_bhi=1\n\t\t\tpstatus green YES \"BHI_CTRL feature bit\"\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tcpuid_bhi=0\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tcpuid_bhi=-1\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\n\t\t# make shellcheck happy while we're not yet using these new cpuid values in our checks\n\t\texport cpuid_ipred cpuid_rrsba cpuid_bhi\n\tfi\n\n\tif is_intel; then\n\t\t_info     \"  * Enhanced IBRS (IBRS_ALL)\"\n\t\t_info_nol \"    * CPU indicates ARCH_CAPABILITIES MSR availability: \"\n\t\tcpuid_arch_capabilities=-1\n\t\t# A processor supports the ARCH_CAPABILITIES MSR if it enumerates CPUID (EAX=7H,ECX=0):EDX[29] as 1\n\t\tread_cpuid 0x7 0x0 $EDX 29 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tpstatus green YES\n\t\t\tcpuid_arch_capabilities=1\n\t\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\t\tpstatus yellow NO\n\t\t\tcpuid_arch_capabilities=0\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tfi\n\n\t\t_info_nol \"    * ARCH_CAPABILITIES MSR advertises IBRS_ALL capability: \"\n\t\tcapabilities_taa_no=-1\n\t\tcapabilities_mds_no=-1\n\t\tcapabilities_rdcl_no=-1\n\t\tcapabilities_ibrs_all=-1\n\t\tcapabilities_rsba=-1\n\t\tcapabilities_l1dflush_no=-1\n\t\tcapabilities_ssb_no=-1\n\t\tcapabilities_pschange_msc_no=-1\n\t\tcapabilities_tsx_ctrl_msr=-1\n\t\tcapabilities_gds_ctrl=-1\n\t\tcapabilities_gds_no=-1\n\t\tif [ \"$cpuid_arch_capabilities\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$cpuid_arch_capabilities\" != 1 ]; then\n\t\t\tcapabilities_rdcl_no=0\n\t\t\tcapabilities_taa_no=0\n\t\t\tcapabilities_mds_no=0\n\t\t\tcapabilities_ibrs_all=0\n\t\t\tcapabilities_rsba=0\n\t\t\tcapabilities_l1dflush_no=0\n\t\t\tcapabilities_ssb_no=0\n\t\t\tcapabilities_pschange_msc_no=0\n\t\t\tcapabilities_tsx_ctrl_msr=0\n\t\t\tcapabilities_gds_ctrl=0\n\t\t\tcapabilities_gds_no=0\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\t# the new MSR 'ARCH_CAPABILITIES' is at offset 0x10a\n\t\t\tread_msr 0x10a; ret=$?\n\t\t\tcapabilities_rdcl_no=0\n\t\t\tcapabilities_taa_no=0\n\t\t\tcapabilities_mds_no=0\n\t\t\tcapabilities_ibrs_all=0\n\t\t\tcapabilities_rsba=0\n\t\t\tcapabilities_l1dflush_no=0\n\t\t\tcapabilities_ssb_no=0\n\t\t\tcapabilities_pschange_msc_no=0\n\t\t\tcapabilities_tsx_ctrl_msr=0\n\t\t\tcapabilities_gds_ctrl=0\n\t\t\tcapabilities_gds_no=0\n\t\t\tif [ $ret = $READ_MSR_RET_OK ]; then\n\t\t\t\tcapabilities=$read_msr_value\n\t\t\t\t# https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/include/asm/msr-index.h#n82\n\t\t\t\t_debug \"capabilities MSR is $capabilities (decimal)\"\n\t\t\t\t[ $(( capabilities >>  0 & 1 )) -eq 1 ] && capabilities_rdcl_no=1\n\t\t\t\t[ $(( capabilities >>  1 & 1 )) -eq 1 ] && capabilities_ibrs_all=1\n\t\t\t\t[ $(( capabilities >>  2 & 1 )) -eq 1 ] && capabilities_rsba=1\n\t\t\t\t[ $(( capabilities >>  3 & 1 )) -eq 1 ] && capabilities_l1dflush_no=1\n\t\t\t\t[ $(( capabilities >>  4 & 1 )) -eq 1 ] && capabilities_ssb_no=1\n\t\t\t\t[ $(( capabilities >>  5 & 1 )) -eq 1 ] && capabilities_mds_no=1\n\t\t\t\t[ $(( capabilities >>  6 & 1 )) -eq 1 ] && capabilities_pschange_msc_no=1\n\t\t\t\t[ $(( capabilities >>  7 & 1 )) -eq 1 ] && capabilities_tsx_ctrl_msr=1\n\t\t\t\t[ $(( capabilities >>  8 & 1 )) -eq 1 ] && capabilities_taa_no=1\n\t\t\t\t[ $(( capabilities >> 25 & 1 )) -eq 1 ] && capabilities_gds_ctrl=1\n\t\t\t\t[ $(( capabilities >> 26 & 1 )) -eq 1 ] && capabilities_gds_no=1\n\t\t\t\t_debug \"capabilities says rdcl_no=$capabilities_rdcl_no ibrs_all=$capabilities_ibrs_all rsba=$capabilities_rsba l1dflush_no=$capabilities_l1dflush_no ssb_no=$capabilities_ssb_no mds_no=$capabilities_mds_no taa_no=$capabilities_taa_no pschange_msc_no=$capabilities_pschange_msc_no\"\n\t\t\t\tif [ \"$capabilities_ibrs_all\" = 1 ]; then\n\t\t\t\t\tpstatus green YES\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\tfi\n\t\t\telif [ $ret = $READ_MSR_RET_KO ]; then\n\t\t\t\tpstatus yellow NO\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN \"$read_msr_msg\"\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates not being affected by Meltdown/L1TF (RDCL_NO): \"\n\t\tif [ \"$capabilities_rdcl_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_rdcl_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates not being affected by Variant 4 (SSB_NO): \"\n\t\tif [ \"$capabilities_ssb_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_ssb_no\" = 1 ] || [ \"$amd_ssb_no\" = 1 ] || [ \"$hygon_ssb_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * CPU/Hypervisor indicates L1D flushing is not necessary on this system: \"\n\t\tif [ \"$capabilities_l1dflush_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_l1dflush_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * Hypervisor indicates host CPU might be affected by RSB underflow (RSBA): \"\n\t\tif [ \"$capabilities_rsba\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_rsba\" = 1 ]; then\n\t\t\tpstatus yellow YES\n\t\telse\n\t\t\tpstatus blue NO\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates not being affected by Microarchitectural Data Sampling (MDS_NO): \"\n\t\tif [ \"$capabilities_mds_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_mds_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates not being affected by TSX Asynchronous Abort (TAA_NO): \"\n\t\tif [ \"$capabilities_taa_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_taa_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates not being affected by iTLB Multihit (PSCHANGE_MSC_NO): \"\n\t\tif [ \"$capabilities_pschange_msc_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_pschange_msc_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates having MSR for TSX control (TSX_CTRL_MSR): \"\n\t\tif [ \"$capabilities_tsx_ctrl_msr\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN\n\t\telif [ \"$capabilities_tsx_ctrl_msr\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\tif [ \"$capabilities_tsx_ctrl_msr\" = 1 ]; then\n\t\t\tread_msr 0x122; ret=$?\n\t\t\tif [ \"$ret\" = $READ_MSR_RET_OK ]; then\n\t\t\t\ttsx_ctrl_msr=$read_msr_value\n\t\t\t\ttsx_ctrl_msr_rtm_disable=$(( tsx_ctrl_msr >> 0 & 1 ))\n\t\t\t\ttsx_ctrl_msr_cpuid_clear=$(( tsx_ctrl_msr >> 1 & 1 ))\n\t\t\tfi\n\n\t\t\t_info_nol \"    * TSX_CTRL MSR indicates TSX RTM is disabled: \"\n\t\t\tif [ \"$tsx_ctrl_msr_rtm_disable\" = 1 ]; then\n\t\t\t\tpstatus blue YES\n\t\t\telif [ \"$tsx_ctrl_msr_rtm_disable\" = 0 ]; then\n\t\t\t\tpstatus blue NO\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN \"couldn't read MSR\"\n\t\t\tfi\n\n\t\t\t_info_nol \"    * TSX_CTRL MSR indicates TSX CPUID bit is cleared: \"\n\t\t\tif [ \"$tsx_ctrl_msr_cpuid_clear\" = 1 ]; then\n\t\t\t\tpstatus blue YES\n\t\t\telif [ \"$tsx_ctrl_msr_cpuid_clear\" = 0 ]; then\n\t\t\t\tpstatus blue NO\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN \"couldn't read MSR\"\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates being affected by GDS and having mitigation control (GDS_CTRL): \"\n\t\tif [ \"$capabilities_gds_ctrl\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN \"couldn't read MSR\"\n\t\telif [ \"$capabilities_gds_ctrl\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus blue NO\n\t\tfi\n\n\t\tmcu_opt_ctrl_gds_mitg_dis=-1\n\t\tmcu_opt_ctrl_gds_mitg_lock=-1\n\t\tif [ \"$capabilities_gds_ctrl\" = 1 ]; then\n\t\t\t# read the IA32_MCU_OPT_CTRL MSR\n\t\t\tread_msr 0x123; ret=$?\n\t\t\tif [ \"$ret\" = $READ_MSR_RET_OK ]; then\n\t\t\t\tmcu_opt_ctrl=$read_msr_value\n\t\t\t\tmcu_opt_ctrl_gds_mitg_dis=$((  mcu_opt_ctrl >> 4 & 1 ))\n\t\t\t\tmcu_opt_ctrl_gds_mitg_lock=$(( mcu_opt_ctrl >> 5 & 1 ))\n\t\t\tfi\n\n\t\t\t_info_nol \"    * GDS microcode mitigation is disabled (GDS_MITG_DIS): \"\n\t\t\tif [ \"$mcu_opt_ctrl_gds_mitg_dis\" = -1 ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"couldn't read MSR\"\n\t\t\telif [ \"$mcu_opt_ctrl_gds_mitg_dis\" = 1 ]; then\n\t\t\t\tpstatus yellow YES\n\t\t\telse\n\t\t\t\tpstatus green NO\n\t\t\tfi\n\n\t\t\t_info_nol \"    * GDS microcode mitigation is locked in enabled state (GDS_MITG_LOCK): \"\n\t\t\tif [ \"$mcu_opt_ctrl_gds_mitg_lock\" = -1 ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"couldn't read MSR\"\n\t\t\telif [ \"$mcu_opt_ctrl_gds_mitg_lock\" = 1 ]; then\n\t\t\t\tpstatus blue YES\n\t\t\telse\n\t\t\t\tpstatus blue NO\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"  * CPU explicitly indicates not being affected by GDS (GDS_NO): \"\n\t\tif [ \"$capabilities_gds_no\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN \"couldn't read MSR\"\n\t\telif [ \"$capabilities_gds_no\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\tfi\n\n\tif is_amd || is_hygon; then\n\t\t_info \"  * Selective Branch Predictor Barrier (SBPB)\"\n\t\t_info_nol \"    * PRED_CMD MSR supports SBPB bit write: \"\n\n\t\tif [ \"$opt_allow_msr_write\" = 1 ]; then\n\t\t\t# the MSR PRED_SBPB is at offset 0x49, BIT(7), write-only\n\t\t\twrite_msr 0x49 128; ret=$?\n\t\t\tif [ $ret = $WRITE_MSR_RET_OK ]; then\n\t\t\t\tpstatus green YES\n\t\t\t\tcpuid_sbpb=1\n\t\t\telif [ $ret = $WRITE_MSR_RET_KO ]; then\n\t\t\t\tpstatus yellow NO\n\t\t\t\tcpuid_sbpb=2\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN \"$write_msr_msg\"\n\t\t\t\tcpuid_sbpb=3\n\t\t\tfi\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"not allowed to write msr\"\n\t\t\tcpuid_sbpb=3\n\t\tfi\n\tfi\n\n\t_info_nol \"  * CPU supports Transactional Synchronization Extensions (TSX): \"\n\tret=$READ_CPUID_RET_KO\n\tcpuid_rtm=0\n\tif is_intel; then\n\t\tread_cpuid 0x7 0x0 $EBX 11 1 1; ret=$?\n\tfi\n\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\tcpuid_rtm=1\n\t\tpstatus green YES \"RTM feature bit\"\n\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\tpstatus yellow NO\n\telse\n\t\tcpuid_rtm=-1\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\tfi\n\n\t_info_nol \"  * CPU supports Software Guard Extensions (SGX): \"\n\tret=$READ_CPUID_RET_KO\n\tcpuid_sgx=0\n\tif is_intel; then\n\t\tread_cpuid 0x7 0x0 $EBX 2 1 1; ret=$?\n\tfi\n\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\tpstatus blue YES\n\t\tcpuid_sgx=1\n\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\tpstatus green NO\n\telse\n\t\tcpuid_sgx=-1\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\tfi\n\n\t_info_nol \"  * CPU supports Special Register Buffer Data Sampling (SRBDS): \"\n\t# A processor supports SRBDS if it enumerates CPUID (EAX=7H,ECX=0):EDX[9] as 1\n\t# That means the mitigation disabling SRBDS exists\n\tret=$READ_CPUID_RET_KO\n\tcpuid_srbds=0\n\tsrbds_on=0\n\tif is_intel; then\n\t\tread_cpuid 0x7 0x0 $EDX 9 1 1; ret=$?\n\tfi\n\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\tpstatus blue YES\n\t\tcpuid_srbds=1\n\t\tread_msr 0x123; ret=$?\n\t\tif [ $ret = $READ_MSR_RET_OK ]; then\n\t\t\tif [ $read_msr_value = 0 ]; then\n\t\t\t\t#SRBDS mitigation control exists and is enabled via microcode\n\t\t\t\tsrbds_on=1\n\t\t\telse\n\t\t\t\t#SRBDS mitigation control exists but is disabled via microcode\n\t\t\t\tsrbds_on=0\n\t\t\tfi\n\t\telse\n\t\t\tsrbds_on=-1\n\t\tfi\n\telif [ $ret = $READ_CPUID_RET_KO ]; then\n\t\tpstatus green NO\n\telse\n\t\tpstatus yellow UNKNOWN \"$read_cpuid_msg\"\n\t\tcpuid_srbds=0\n\tfi\n\n\tif is_amd; then\n\t\t_info_nol \"  * CPU microcode is known to fix Zenbleed: \"\n\t\thas_zenbleed_fixed_firmware; ret=$?\n\t\tif [ $ret -eq 0 ]; then\n\t\t\t# affected CPU, new fw\n\t\t\tpstatus green YES\n\t\telif [ $ret -eq 1 ]; then\n\t\t\t# affected CPU, old fw\n\t\t\tpstatus red NO \"required version: $zenbleed_fw_required\"\n\t\telse\n\t\t\t# unaffected CPU\n\t\t\tpstatus yellow NO\n\t\tfi\n\tfi\n\n\t_info_nol \"  * CPU microcode is known to cause stability problems: \"\n\tif is_ucode_blacklisted; then\n\t\tpstatus red YES \"$ucode_found\"\n\t\t_warn\n\t\t_warn \"The microcode your CPU is running on is known to cause instability problems,\"\n\t\t_warn \"such as intempestive reboots or random crashes.\"\n\t\t_warn \"You are advised to either revert to a previous microcode version (that might not have\"\n\t\t_warn \"the mitigations for recent vulnerabilities), or upgrade to a newer one if available.\"\n\t\t_warn\n\telse\n\t\tpstatus blue NO \"$ucode_found\"\n\tfi\n\n\t_info_nol \"  * CPU microcode is the latest known available version: \"\n\tis_latest_known_ucode; ret=$?\n\tif [ $ret -eq 0 ]; then\n\t\tpstatus green YES \"$ucode_latest\"\n\telif [ $ret -eq 1 ]; then\n\t\tpstatus red NO \"$ucode_latest\"\n\telse\n\t\tpstatus blue UNKNOWN \"$ucode_latest\"\n\tfi\n}\n\ncheck_cpu_vulnerabilities()\n{\n\t_info     \"* CPU vulnerability to the speculative execution attack variants\"\n\tfor cve in $supported_cve_list; do\n\t\t_info_nol \"  * Affected by $cve ($(cve2name \"$cve\")): \"\n\t\tif is_cpu_affected \"$cve\"; then\n\t\t\tpstatus yellow YES\n\t\telse\n\t\t\tpstatus green NO\n\t\tfi\n\tdone\n}\n\ncheck_redhat_canonical_spectre()\n{\n\t# if we were already called, don't do it again\n\t[ -n \"${redhat_canonical_spectre:-}\" ] && return\n\n\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\tredhat_canonical_spectre=-1\n\telif [ -n \"$kernel_err\" ]; then\n\t\tredhat_canonical_spectre=-2\n\telse\n\t\t# Red Hat / Ubuntu specific variant1 patch is difficult to detect,\n\t\t# let's use the two same tricks than the official Red Hat detection script uses:\n\t\tif \"${opt_arch_prefix}strings\" \"$kernel\" | grep -qw noibrs && \"${opt_arch_prefix}strings\" \"$kernel\" | grep -qw noibpb; then\n\t\t\t# 1) detect their specific variant2 patch. If it's present, it means\n\t\t\t# that the variant1 patch is also present (both were merged at the same time)\n\t\t\t_debug \"found redhat/canonical version of the variant2 patch (implies variant1)\"\n\t\t\tredhat_canonical_spectre=1\n\t\telif \"${opt_arch_prefix}strings\" \"$kernel\" | grep -q 'x86/pti:'; then\n\t\t\t# 2) detect their specific variant3 patch. If it's present, but the variant2\n\t\t\t# is not, it means that only variant1 is present in addition to variant3\n\t\t\t_debug \"found redhat/canonical version of the variant3 patch (implies variant1 but not variant2)\"\n\t\t\tredhat_canonical_spectre=2\n\t\telse\n\t\t\tredhat_canonical_spectre=0\n\t\tfi\n\tfi\n}\n\ncheck_has_vmm()\n{\n\t_info_nol \"* This system is a host running a hypervisor: \"\n\thas_vmm=$opt_vmm\n\tif [ \"$has_vmm\" = -1 ] && [ \"$opt_paranoid\" = 1 ]; then\n\t\t# In paranoid mode, if --vmm was not specified on the command-line,\n\t\t# we want to be secure before everything else, so assume we're running\n\t\t# a hypervisor, as this requires more mitigations\n\t\thas_vmm=2\n\telif [ \"$has_vmm\" = -1 ]; then\n\t\t# Here, we want to know if we are hosting a hypervisor, and running some VMs on it.\n\t\t# If we find no evidence that this is the case, assume we're not (to avoid scaring users),\n\t\t# this can always be overridden with --vmm in any case.\n\t\thas_vmm=0\n\t\tif command -v pgrep >/dev/null 2>&1; then\n\t\t\t# remove xenbus and xenwatch, also present inside domU\n\t\t\t# remove libvirtd as it can also be used to manage containers and not VMs\n\t\t\t# for each binary we want to grep, get the pids\n\t\t\tfor _binary in qemu kvm xenstored xenconsoled\n\t\t\tdo\n\t\t\t\tfor _pid in $(pgrep -x $_binary)\n\t\t\t\tdo\n\t\t\t\t\t# resolve the exe symlink, if it doesn't resolve with -m,\n\t\t\t\t\t# which doesn't even need the dest to exist, it means the symlink\n\t\t\t\t\t# is null, which is the case for kernel threads: ignore those to\n\t\t\t\t\t# avoid false positives (such as [kvm-irqfd-clean] under at least RHEL 7.6/7.7)\n\t\t\t\t\tif ! [ \"$(readlink -m \"/proc/$_pid/exe\")\" = \"/proc/$_pid/exe\" ]; then\n\t\t\t\t\t\t_debug \"has_vmm: found PID $_pid\"\n\t\t\t\t\t\thas_vmm=1\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tdone\n\t\t\tunset _binary _pid\n\t\telse\n\t\t\t# ignore SC2009 as `ps ax` is actually used as a fallback if `pgrep` isn't installed\n\t\t\t# shellcheck disable=SC2009\n\t\t\tif command -v ps >/dev/null && ps ax | grep -vw grep | grep -q -e '\\<qemu' -e '/qemu' -e '<\\kvm' -e '/kvm' -e '/xenstored' -e '/xenconsoled'; then\n\t\t\t\thas_vmm=1\n\t\t\tfi\n\t\tfi\n\tfi\n\tif [ \"$has_vmm\" = 0 ]; then\n\t\tif [ \"$opt_vmm\" != -1 ]; then\n\t\t\tpstatus green NO \"forced from command line\"\n\t\telse\n\t\t\tpstatus green NO\n\t\tfi\n\telse\n\t\tif [ \"$opt_vmm\" != -1 ]; then\n\t\t\tpstatus blue YES \"forced from command line\"\n\t\telif [ \"$has_vmm\" = 2 ]; then\n\t\t\tpstatus blue YES \"paranoid mode\"\n\t\telse\n\t\t\tpstatus blue YES\n\t\tfi\n\tfi\n}\n\n###################\n# SPECTRE 1 SECTION\n\n# bounds check bypass aka 'Spectre Variant 1'\ncheck_CVE_2017_5753()\n{\n\tcve='CVE-2017-5753'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2017_5753_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2017_5753_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2017_5753_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/spectre_v1\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\t# v0.33+: don't. some kernels have backported the array_index_mask_nospec() workaround without\n\t\t# modifying the vulnerabilities/spectre_v1 file. that's bad. we can't trust it when it says Vulnerable :(\n\t\t# see \"silent backport\" detection at the bottom of this func\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t# no /sys interface (or offline mode), fallback to our own ways\n\t\t_info_nol \"* Kernel has array_index_mask_nospec: \"\n\t\t# vanilla: look for the Linus' mask aka array_index_mask_nospec()\n\t\t# that is inlined at least in raw_copy_from_user (__get_user_X symbols)\n\t\t#mov PER_CPU_VAR(current_task), %_ASM_DX\n\t\t#cmp TASK_addr_limit(%_ASM_DX),%_ASM_AX\n\t\t#jae bad_get_user\n\t\t# /* array_index_mask_nospec() are the 2 opcodes that follow */\n\t\t#+sbb %_ASM_DX, %_ASM_DX\n\t\t#+and %_ASM_DX, %_ASM_AX\n\t\t#ASM_STAC\n\t\t# x86 64bits: jae(0x0f 0x83 0x?? 0x?? 0x?? 0x??) sbb(0x48 0x19 0xd2) and(0x48 0x21 0xd0)\n\t\t# x86 32bits: cmp(0x3b 0x82 0x?? 0x?? 0x00 0x00) jae(0x73 0x??) sbb(0x19 0xd2) and(0x21 0xd0)\n\t\t#\n\t\t# arm32\n\t\t##ifdef CONFIG_THUMB2_KERNEL\n\t\t##define CSDB\t\".inst.w 0xf3af8014\"\n\t\t##else\n\t\t##define CSDB\t\".inst\t0xe320f014\"     e320f014\n\t\t##endif\n\t\t#asm volatile(\n\t\t#\t\"cmp\t%1, %2\\n\"      e1500003\n\t\t#\"\tsbc\t%0, %1, %1\\n\"  e0c03000\n\t\t#CSDB\n\t\t#: \"=r\" (mask)\n\t\t#: \"r\" (idx), \"Ir\" (sz)\n\t\t#: \"cc\");\n\t\t#\n\t\t# http://git.arm.linux.org.uk/cgit/linux-arm.git/commit/?h=spectre&id=a78d156587931a2c3b354534aa772febf6c9e855\n\t\tv1_mask_nospec=''\n\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\telif ! command -v perl >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing 'perl' binary, please install it\"\n\t\telse\n\t\t\tperl -ne '/\\x0f\\x83....\\x48\\x19\\xd2\\x48\\x21\\xd0/ and $found++; END { exit($found) }' \"$kernel\"; ret=$?\n\t\t\tif [ $ret -gt 0 ]; then\n\t\t\t\tpstatus green YES \"$ret occurrence(s) found of x86 64 bits array_index_mask_nospec()\"\n\t\t\t\tv1_mask_nospec=\"x86 64 bits array_index_mask_nospec\"\n\t\t\telse\n\t\t\t\tperl -ne '/\\x3b\\x82..\\x00\\x00\\x73.\\x19\\xd2\\x21\\xd0/ and $found++; END { exit($found) }' \"$kernel\"; ret=$?\n\t\t\t\tif [ $ret -gt 0 ]; then\n\t\t\t\t\tpstatus green YES \"$ret occurrence(s) found of x86 32 bits array_index_mask_nospec()\"\n\t\t\t\t\tv1_mask_nospec=\"x86 32 bits array_index_mask_nospec\"\n\t\t\t\telse\n\t\t\t\t\tret=$(\"${opt_arch_prefix}objdump\" $objdump_options \"$kernel\" | grep -w -e f3af8014 -e e320f014 -B2 | grep -B1 -w sbc | grep -w -c cmp)\n\t\t\t\t\tif [ \"$ret\" -gt 0 ]; then\n\t\t\t\t\t\tpstatus green YES \"$ret occurrence(s) found of arm 32 bits array_index_mask_nospec()\"\n\t\t\t\t\t\tv1_mask_nospec=\"arm 32 bits array_index_mask_nospec\"\n\t\t\t\t\telse\n\t\t\t\t\t\tpstatus yellow NO\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"* Kernel has the Red Hat/Ubuntu patch: \"\n\t\tcheck_redhat_canonical_spectre\n\t\tif [ \"$redhat_canonical_spectre\" = -1 ]; then\n\t\t\tpstatus yellow UNKNOWN \"missing '${opt_arch_prefix}strings' tool, please install it, usually it's in the binutils package\"\n\t\telif [ \"$redhat_canonical_spectre\" = -2 ]; then\n\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\telif [ \"$redhat_canonical_spectre\" = 1 ]; then\n\t\t\tpstatus green YES\n\t\telif [ \"$redhat_canonical_spectre\" = 2 ]; then\n\t\t\tpstatus green YES \"but without IBRS\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"* Kernel has mask_nospec64 (arm64): \"\n\t\t#.macro\tmask_nospec64, idx, limit, tmp\n\t\t#sub\t\\tmp, \\idx, \\limit\n\t\t#bic\t\\tmp, \\tmp, \\idx\n\t\t#and\t\\idx, \\idx, \\tmp, asr #63\n\t\t#csdb\n\t\t#.endm\n\t\t#$ aarch64-linux-gnu-objdump -d vmlinux | grep -w bic -A1 -B1 | grep -w sub -A2 | grep -w and -B2\n\t\t#ffffff8008082e44:       cb190353        sub     x19, x26, x25\n\t\t#ffffff8008082e48:       8a3a0273        bic     x19, x19, x26\n\t\t#ffffff8008082e4c:       8a93ff5a        and     x26, x26, x19, asr #63\n\t\t#ffffff8008082e50:       d503229f        hint    #0x14\n\t\t# /!\\ can also just be \"csdb\" instead of \"hint #0x14\" for native objdump\n\t\t#\n\t\t# if we have v1_mask_nospec or redhat_canonical_spectre>0, don't bother disassembling the kernel, the answer is no.\n\t\tif [ -n \"$v1_mask_nospec\" ] || [ \"$redhat_canonical_spectre\" -gt 0 ]; then\n\t\t\tpstatus yellow NO\n\t\telif [ -n \"$kernel_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\telif ! command -v perl >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing 'perl' binary, please install it\"\n\t\telif ! command -v \"${opt_arch_prefix}objdump\" >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing '${opt_arch_prefix}objdump' tool, please install it, usually it's in the binutils package\"\n\t\telse\n\t\t\t\"${opt_arch_prefix}objdump\" $objdump_options \"$kernel\" | perl -ne 'push @r, $_; /\\s(hint|csdb)\\s/ && $r[0]=~/\\ssub\\s+(x\\d+)/ && $r[1]=~/\\sbic\\s+$1,\\s+$1,/ && $r[2]=~/\\sand\\s/ && exit(9); shift @r if @r>3'; ret=$?\n\t\t\tif [ \"$ret\" -eq 9 ]; then\n\t\t\t\tpstatus green YES \"mask_nospec64 macro is present and used\"\n\t\t\t\tv1_mask_nospec=\"arm64 mask_nospec64\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"* Kernel has array_index_nospec (arm64): \"\n\t\t# in 4.19+ kernels, the mask_nospec64 asm64 macro is replaced by array_index_nospec, defined in nospec.h, and used in invoke_syscall()\n\t\t# ffffff8008090a4c:       2a0203e2        mov     w2, w2\n\t\t# ffffff8008090a50:       eb0200bf        cmp     x5, x2\n\t\t# ffffff8008090a54:       da1f03e2        ngc     x2, xzr\n\t\t# ffffff8008090a58:       d503229f        hint    #0x14\n\t\t# /!\\ can also just be \"csdb\" instead of \"hint #0x14\" for native objdump\n\t\t#\n\t\t# if we have v1_mask_nospec or redhat_canonical_spectre>0, don't bother disassembling the kernel, the answer is no.\n\t\tif [ -n \"$v1_mask_nospec\" ] || [ \"$redhat_canonical_spectre\" -gt 0 ]; then\n\t\t\tpstatus yellow NO\n\t\telif [ -n \"$kernel_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\telif ! command -v perl >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing 'perl' binary, please install it\"\n\t\telif ! command -v \"${opt_arch_prefix}objdump\" >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing '${opt_arch_prefix}objdump' tool, please install it, usually it's in the binutils package\"\n\t\telse\n\t\t\t\"${opt_arch_prefix}objdump\" -d \"$kernel\" | perl -ne 'push @r, $_; /\\s(hint|csdb)\\s/ && $r[0]=~/\\smov\\s+(w\\d+),\\s+(w\\d+)/ && $r[1]=~/\\scmp\\s+(x\\d+),\\s+(x\\d+)/ && $r[2]=~/\\sngc\\s+$2,/ && exit(9); shift @r if @r>3'; ret=$?\n\t\t\tif [ \"$ret\" -eq 9 ]; then\n\t\t\t\tpstatus green YES \"array_index_nospec macro is present and used\"\n\t\t\t\tv1_mask_nospec=\"arm64 array_index_nospec\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\tfi\n\n\t\tif [ \"$opt_verbose\" -ge 2 ] || { [ -z \"$v1_mask_nospec\" ] && [ \"$redhat_canonical_spectre\" != 1 ] && [ \"$redhat_canonical_spectre\" != 2 ]; }; then\n\t\t\t# this is a slow heuristic and we don't need it if we already know the kernel is patched\n\t\t\t# but still show it in verbose mode\n\t\t\t_info_nol \"* Checking count of LFENCE instructions following a jump in kernel... \"\n\t\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\t\telse\n\t\t\t\tif ! command -v \"${opt_arch_prefix}objdump\" >/dev/null 2>&1; then\n\t\t\t\t\tpstatus yellow UNKNOWN \"missing '${opt_arch_prefix}objdump' tool, please install it, usually it's in the binutils package\"\n\t\t\t\telse\n\t\t\t\t\t# here we disassemble the kernel and count the number of occurrences of the LFENCE opcode\n\t\t\t\t\t# in non-patched kernels, this has been empirically determined as being around 40-50\n\t\t\t\t\t# in patched kernels, this is more around 70-80, sometimes way higher (100+)\n\t\t\t\t\t# v0.13: 68 found in a 3.10.23-xxxx-std-ipv6-64 (with lots of modules compiled-in directly), which doesn't have the LFENCE patches,\n\t\t\t\t\t# so let's push the threshold to 70.\n\t\t\t\t\t# v0.33+: now only count lfence opcodes after a jump, way less error-prone\n\t\t\t\t\t# non patched kernel have between 0 and 20 matches, patched ones have at least 40-45\n\t\t\t\t\tnb_lfence=$(\"${opt_arch_prefix}objdump\" $objdump_options \"$kernel\" 2>/dev/null | grep -w -B1 lfence | grep -Ewc 'jmp|jne|je')\n\t\t\t\t\tif [ \"$nb_lfence\" -lt 30 ]; then\n\t\t\t\t\t\tpstatus yellow NO \"only $nb_lfence jump-then-lfence instructions found, should be >= 30 (heuristic)\"\n\t\t\t\t\telse\n\t\t\t\t\t\tv1_lfence=1\n\t\t\t\t\t\tpstatus green YES \"$nb_lfence jump-then-lfence instructions found, which is >= 30 (heuristic)\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\telse\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\t# report status\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ -n \"$v1_mask_nospec\" ]; then\n\t\t\tpvulnstatus $cve OK \"Kernel source has been patched to mitigate the vulnerability ($v1_mask_nospec)\"\n\t\telif [ \"$redhat_canonical_spectre\" = 1 ] || [ \"$redhat_canonical_spectre\" = 2 ]; then\n\t\t\tpvulnstatus $cve OK \"Kernel source has been patched to mitigate the vulnerability (Red Hat/Ubuntu patch)\"\n\t\telif [ \"$v1_lfence\" = 1 ]; then\n\t\t\tpvulnstatus $cve OK \"Kernel source has PROBABLY been patched to mitigate the vulnerability (jump-then-lfence instructions heuristic)\"\n\t\telif [ -n \"$kernel_err\" ]; then\n\t\t\tpvulnstatus $cve UNK \"Couldn't find kernel image or tools missing to execute the checks\"\n\t\t\texplain \"Re-run this script with root privileges, after installing the missing tools indicated above\"\n\t\telse\n\t\t\tpvulnstatus $cve VULN \"Kernel source needs to be patched to mitigate the vulnerability\"\n\t\t\texplain \"Your kernel is too old to have the mitigation for Variant 1, you should upgrade to a newer kernel. If you're using a Linux distro and didn't compile the kernel yourself, you should upgrade your distro to get a newer kernel.\"\n\t\tfi\n\telse\n\t\tif [ \"$msg\" = \"Vulnerable\" ] && [ -n \"$v1_mask_nospec\" ]; then\n\t\t\tpvulnstatus $cve OK \"Kernel source has been patched to mitigate the vulnerability (silent backport of array_index_mask_nospec)\"\n\t\telse\n\t\t\tif [ \"$msg\" = \"Vulnerable\" ]; then\n\t\t\t\tmsg=\"Kernel source needs to be patched to mitigate the vulnerability\"\n\t\t\t\t_explain=\"Your kernel is too old to have the mitigation for Variant 1, you should upgrade to a newer kernel. If you're using a Linux distro and didn't compile the kernel yourself, you should upgrade your distro to get a newer kernel.\"\n\t\t\tfi\n\t\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\t\t\t[ -n \"${_explain:-}\" ] && explain \"$_explain\"\n\t\t\tunset _explain\n\t\tfi\n\tfi\n}\n\ncheck_CVE_2017_5753_bsd()\n{\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tpvulnstatus $cve VULN \"no mitigation for BSD yet\"\n\tfi\n}\n\n###################\n# SPECTRE 2 SECTION\n\n# branch target injection aka 'Spectre Variant 2'\ncheck_CVE_2017_5715()\n{\n\tcve='CVE-2017-5715'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2017_5715_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2017_5715_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2017_5715_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/spectre_v2\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info \"* Mitigation 1\"\n\n\t\tibrs_can_tell=0\n\t\tibrs_supported=''\n\t\tibrs_enabled=''\n\t\tibpb_can_tell=0\n\t\tibpb_supported=''\n\t\tibpb_enabled=''\n\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t# in live mode, we can check for the ibrs_enabled file in debugfs\n\t\t\t# all versions of the patches have it (NOT the case of IBPB or KPTI)\n\t\t\tibrs_can_tell=1\n\t\t\tmount_debugfs\n\t\t\tfor dir in \\\n\t\t\t\t/sys/kernel/debug \\\n\t\t\t\t/sys/kernel/debug/x86 \\\n\t\t\t\t\"$procfs/sys/kernel\"; do\n\t\t\t\tif [ -e \"$dir/ibrs_enabled\" ]; then\n\t\t\t\t\t# if the file is there, we have IBRS compiled-in\n\t\t\t\t\t# /sys/kernel/debug/ibrs_enabled: vanilla\n\t\t\t\t\t# /sys/kernel/debug/x86/ibrs_enabled: Red Hat (see https://access.redhat.com/articles/3311301)\n\t\t\t\t\t# /proc/sys/kernel/ibrs_enabled: OpenSUSE tumbleweed\n\t\t\t\t\tspecex_knob_dir=$dir\n\t\t\t\t\tibrs_supported=\"$dir/ibrs_enabled exists\"\n\t\t\t\t\tibrs_enabled=$(cat \"$dir/ibrs_enabled\" 2>/dev/null)\n\t\t\t\t\t_debug \"ibrs: found $dir/ibrs_enabled=$ibrs_enabled\"\n\t\t\t\t\t# if ibrs_enabled is there, ibpb_enabled will be in the same dir\n\t\t\t\t\tif [ -e \"$dir/ibpb_enabled\" ]; then\n\t\t\t\t\t\t# if the file is there, we have IBPB compiled-in (see note above for IBRS)\n\t\t\t\t\t\tibpb_supported=\"$dir/ibpb_enabled exists\"\n\t\t\t\t\t\tibpb_enabled=$(cat \"$dir/ibpb_enabled\" 2>/dev/null)\n\t\t\t\t\t\t_debug \"ibpb: found $dir/ibpb_enabled=$ibpb_enabled\"\n\t\t\t\t\telse\n\t\t\t\t\t\t_debug \"ibpb: $dir/ibpb_enabled file doesn't exist\"\n\t\t\t\t\tfi\n\t\t\t\t\tbreak\n\t\t\t\telse\n\t\t\t\t\t_debug \"ibrs: $dir/ibrs_enabled file doesn't exist\"\n\t\t\t\tfi\n\t\t\tdone\n\t\t\t# on some newer kernels, the spec_ctrl_ibrs flag in \"$procfs/cpuinfo\"\n\t\t\t# is set when ibrs has been administratively enabled (usually from cmdline)\n\t\t\t# which in that case means ibrs is supported *and* enabled for kernel & user\n\t\t\t# as per the ibrs patch series v3\n\t\t\tif [ -z \"$ibrs_supported\" ]; then\n\t\t\t\tif grep ^flags \"$procfs/cpuinfo\" | grep -qw spec_ctrl_ibrs; then\n\t\t\t\t\t_debug \"ibrs: found spec_ctrl_ibrs flag in $procfs/cpuinfo\"\n\t\t\t\t\tibrs_supported=\"spec_ctrl_ibrs flag in $procfs/cpuinfo\"\n\t\t\t\t\t# enabled=2 -> kernel & user\n\t\t\t\t\tibrs_enabled=2\n\t\t\t\t\t# XXX and what about ibpb ?\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ -n \"$fullmsg\" ]; then\n\t\t\t\t# when IBPB is enabled on 4.15+, we can see it in sysfs\n\t\t\t\tif echo \"$fullmsg\" | grep -q 'IBPB'; then\n\t\t\t\t\t_debug \"ibpb: found enabled in sysfs\"\n\t\t\t\t\t[ -z \"$ibpb_supported\" ] && ibpb_supported='IBPB found enabled in sysfs'\n\t\t\t\t\t[ -z \"$ibpb_enabled\"   ] && ibpb_enabled=1\n\t\t\t\tfi\n\t\t\t\t# when IBRS_FW is enabled on 4.15+, we can see it in sysfs\n\t\t\t\tif echo \"$fullmsg\" | grep -q ', IBRS_FW'; then\n\t\t\t\t\t_debug \"ibrs: found IBRS_FW in sysfs\"\n\t\t\t\t\t[ -z \"$ibrs_supported\" ] && ibrs_supported='found IBRS_FW in sysfs'\n\t\t\t\t\tibrs_fw_enabled=1\n\t\t\t\tfi\n\t\t\t\t# when IBRS is enabled on 4.15+, we can see it in sysfs\n\t\t\t\t# on a more recent kernel, classic \"IBRS\" is not even longer an option, because of the performance impact.\n\t\t\t\t# only \"Enhanced IBRS\" is available (on CPUs with the IBRS_ALL flag)\n\t\t\t\tif echo \"$fullmsg\" | grep -q -e '\\<IBRS\\>' -e 'Indirect Branch Restricted Speculation'; then\n\t\t\t\t\t_debug \"ibrs: found IBRS in sysfs\"\n\t\t\t\t\t[ -z \"$ibrs_supported\" ] && ibrs_supported='found IBRS in sysfs'\n\t\t\t\t\t[ -z \"$ibrs_enabled\"   ] && ibrs_enabled=3\n\t\t\t\tfi\n\t\t\t\t# checking for 'Enhanced IBRS' in sysfs, enabled on CPUs with IBRS_ALL\n\t\t\t\tif echo \"$fullmsg\" | grep -q -e 'Enhanced IBRS'; then\n\t\t\t\t\t[ -z \"$ibrs_supported\" ] && ibrs_supported='found Enhanced IBRS in sysfs'\n\t\t\t\t\t# 4 isn't actually a valid value of the now extinct \"ibrs_enabled\" flag file,\n\t\t\t\t\t# that only went from 0 to 3, so we use 4 as \"enhanced ibrs is enabled\"\n\t\t\t\t\tibrs_enabled=4\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t# in live mode, if ibrs or ibpb is supported and we didn't find these are enabled, then they are not\n\t\t\t[ -n \"$ibrs_supported\" ] && [ -z \"$ibrs_enabled\" ] && ibrs_enabled=0\n\t\t\t[ -n \"$ibpb_supported\" ] && [ -z \"$ibpb_enabled\" ] && ibpb_enabled=0\n\t\tfi\n\t\tif [ -z \"$ibrs_supported\" ]; then\n\t\t\tcheck_redhat_canonical_spectre\n\t\t\tif [ \"$redhat_canonical_spectre\" = 1 ]; then\n\t\t\t\tibrs_supported=\"Red Hat/Ubuntu variant\"\n\t\t\t\tibpb_supported=\"Red Hat/Ubuntu variant\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$ibrs_supported\" ] && [ -n \"$kernel\" ]; then\n\t\t\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\t\t\t:\n\t\t\telse\n\t\t\t\tibrs_can_tell=1\n\t\t\t\tibrs_supported=$(\"${opt_arch_prefix}strings\" \"$kernel\" | grep -Fw -e ', IBRS_FW' | head -1)\n\t\t\t\tif [ -n \"$ibrs_supported\" ]; then\n\t\t\t\t\t_debug \"ibrs: found ibrs evidence in kernel image ($ibrs_supported)\"\n\t\t\t\t\tibrs_supported=\"found '$ibrs_supported' in kernel image\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$ibrs_supported\" ] && [ -n \"$opt_map\" ]; then\n\t\t\tibrs_can_tell=1\n\t\t\tif grep -q spec_ctrl \"$opt_map\"; then\n\t\t\t\tibrs_supported=\"found spec_ctrl in symbols file\"\n\t\t\t\t_debug \"ibrs: found '*spec_ctrl*' symbol in $opt_map\"\n\t\t\tfi\n\t\tfi\n\t\t# recent (4.15) vanilla kernels have IBPB but not IBRS, and without the debugfs tunables of Red Hat\n\t\t# we can detect it directly in the image\n\t\tif [ -z \"$ibpb_supported\" ] && [ -n \"$kernel\" ]; then\n\t\t\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\t\t\t:\n\t\t\telse\n\t\t\t\tibpb_can_tell=1\n\t\t\t\tibpb_supported=$(\"${opt_arch_prefix}strings\" \"$kernel\" | grep -Fw -e 'ibpb' -e ', IBPB' | head -1)\n\t\t\t\tif [ -n \"$ibpb_supported\" ]; then\n\t\t\t\t\t_debug \"ibpb: found ibpb evidence in kernel image ($ibpb_supported)\"\n\t\t\t\t\tibpb_supported=\"found '$ibpb_supported' in kernel image\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"  * Kernel is compiled with IBRS support: \"\n\t\tif [ -z \"$ibrs_supported\" ]; then\n\t\t\tif [ \"$ibrs_can_tell\" = 1 ]; then\n\t\t\t\tpstatus yellow NO\n\t\t\telse\n\t\t\t\t# problem obtaining/inspecting kernel or strings not installed, but if the later is true,\n\t\t\t\t# then readelf is not installed either (both in binutils) which makes the former true, so\n\t\t\t\t# either way kernel_err should be set\n\t\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$opt_verbose\" -ge 2 ]; then\n\t\t\t\tpstatus green YES \"$ibrs_supported\"\n\t\t\telse\n\t\t\t\tpstatus green YES\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"    * IBRS enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ \"$ibpb_enabled\" = 2 ]; then\n\t\t\t\t# if ibpb=2, ibrs is forcefully=0\n\t\t\t\tpstatus blue NO \"IBPB used instead of IBRS in all kernel entrypoints\"\n\t\t\telse\n\t\t\t\t# 0 means disabled\n\t\t\t\t# 1 is enabled only for kernel space\n\t\t\t\t# 2 is enabled for kernel and user space\n\t\t\t\t# 3 is enabled\n\t\t\t\t# 4 is enhanced ibrs enabled\n\t\t\t\tcase \"$ibrs_enabled\" in\n\t\t\t\t\t0)\n\t\t\t\t\t\tif [ \"$ibrs_fw_enabled\" = 1 ]; then\n\t\t\t\t\t\t\tpstatus blue YES \"for firmware code only\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpstatus yellow NO\n\t\t\t\t\t\tfi\n\t\t\t\t\t\t;;\n\t\t\t\t\t1)\tif [ \"$ibrs_fw_enabled\" = 1 ]; then pstatus green YES \"for kernel space and firmware code\"; else pstatus green YES \"for kernel space\"; fi;;\n\t\t\t\t\t2)\tif [ \"$ibrs_fw_enabled\" = 1 ]; then pstatus green YES \"for kernel, user space, and firmware code\" ; else pstatus green YES \"for both kernel and user space\"; fi;;\n\t\t\t\t\t3)\tif [ \"$ibrs_fw_enabled\" = 1 ]; then pstatus green YES \"for kernel and firmware code\"; else pstatus green YES; fi;;\n\t\t\t\t\t4)\tpstatus green YES \"Enhanced flavor, performance impact will be greatly reduced\";;\n\t\t\t\t\t*)\tif [ \"$cpuid_ibrs\" != 'SPEC_CTRL' ] && [ \"$cpuid_ibrs\" != 'IBRS_SUPPORT' ] && [ \"$cpuid_spec_ctrl\" != -1 ]; \n\t\t\t\t\t\t\tthen pstatus yellow NO; _debug \"ibrs: known cpu not supporting SPEC-CTRL or IBRS\"; \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tpstatus yellow UNKNOWN; fi;;\n\t\t\t\tesac\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\t_info_nol \"  * Kernel is compiled with IBPB support: \"\n\t\tif [ -z \"$ibpb_supported\" ]; then\n\t\t\tif [ \"$ibpb_can_tell\" = 1 ]; then\n\t\t\t\tpstatus yellow NO\n\t\t\telse\n\t\t\t\t# if we're in offline mode without System.map, we can't really know\n\t\t\t\tpstatus yellow UNKNOWN \"in offline mode, we need the kernel image to be able to tell\"\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$opt_verbose\" -ge 2 ]; then\n\t\t\t\tpstatus green YES \"$ibpb_supported\"\n\t\t\telse\n\t\t\t\tpstatus green YES\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"    * IBPB enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tcase \"$ibpb_enabled\" in\n\t\t\t\t\"\")\n\t\t\t\t\tif [ \"$ibrs_supported\" = 1 ]; then\n\t\t\t\t\t\tpstatus yellow UNKNOWN\n\t\t\t\t\telse\n\t\t\t\t\t\tpstatus yellow NO\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t0)\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\t\t;;\n\t\t\t\t1) pstatus green YES;;\n\t\t\t\t2) pstatus green YES \"IBPB used instead of IBRS in all kernel entrypoints\";;\n\t\t\t\t*) pstatus yellow UNKNOWN;;\n\t\t\tesac\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\t_info \"* Mitigation 2\"\n\t\t_info_nol \"  * Kernel has branch predictor hardening (arm): \"\n\t\tbp_harden_can_tell=0\n\t\tbp_harden=''\n\t\tif [ -r \"$opt_config\" ]; then\n\t\t\tbp_harden_can_tell=1\n\t\t\tbp_harden=$(grep -w 'CONFIG_HARDEN_BRANCH_PREDICTOR=y' \"$opt_config\")\n\t\t\tif [ -n \"$bp_harden\" ]; then\n\t\t\t\tpstatus green YES\n\t\t\t\t_debug \"bp_harden: found '$bp_harden' in $opt_config\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$bp_harden\" ] && [ -n \"$opt_map\" ]; then\n\t\t\tbp_harden_can_tell=1\n\t\t\tbp_harden=$(grep -w bp_hardening_data \"$opt_map\")\n\t\t\tif [ -n \"$bp_harden\" ]; then\n\t\t\t\tpstatus green YES\n\t\t\t\t_debug \"bp_harden: found '$bp_harden' in $opt_map\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$bp_harden\" ]; then\n\t\t\tif [ \"$bp_harden_can_tell\" = 1 ]; then\n\t\t\t\tpstatus yellow NO\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"  * Kernel compiled with retpoline option: \"\n\t\t# We check the RETPOLINE kernel options\n\t\tretpoline=0\n\t\tif [ -r \"$opt_config\" ]; then\n\t\t\tif grep -q '^CONFIG_\\(MITIGATION_\\)\\?RETPOLINE=y' \"$opt_config\"; then\n\t\t\t\tpstatus green YES\n\t\t\t\tretpoline=1\n\t\t\t\t# shellcheck disable=SC2046\n\t\t\t\t_debug 'retpoline: found '$(grep '^CONFIG_\\(MITIGATION_\\)\\?RETPOLINE' \"$opt_config\")\" in $opt_config\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"couldn't read your kernel configuration\"\n\t\tfi\n\n\t\tif [ \"$retpoline\" = 1 ]; then\n\t\t\t# Now check if the compiler used to compile the kernel knows how to insert retpolines in generated asm\n\t\t\t# For gcc, this is -mindirect-branch=thunk-extern (detected by the kernel makefiles)\n\t\t\t# See gcc commit https://github.com/hjl-tools/gcc/commit/23b517d4a67c02d3ef80b6109218f2aadad7bd79\n\t\t\t# In latest retpoline LKML patches, the noretpoline_setup symbol exists only if CONFIG_MITIGATION_RETPOLINE is set\n\t\t\t# *AND* if the compiler is retpoline-compliant, so look for that symbol. The name of this kernel config \n\t\t\t# option before version 6.9-rc1 is CONFIG_RETPOLINE.\n\t\t\t#\n\t\t\t# if there is \"retpoline\" in the file and NOT \"minimal\", then it's full retpoline\n\t\t\t# (works for vanilla and Red Hat variants)\n\t\t\t#\n\t\t\t# since 5.15.28, this is now \"Retpolines\" as the implementation was switched to a generic one,\n\t\t\t# so we look for both \"retpoline\" and \"retpolines\"\n\t\t\tif [ \"$opt_live\" = 1 ] && [ -n \"$fullmsg\" ]; then\n\t\t\t\tif echo \"$fullmsg\" | grep -qwi -e retpoline -e retpolines; then\n\t\t\t\t\tif echo \"$fullmsg\" | grep -qwi minimal; then\n\t\t\t\t\t\tretpoline_compiler=0\n\t\t\t\t\t\tretpoline_compiler_reason=\"kernel reports minimal retpoline compilation\"\n\t\t\t\t\telse\n\t\t\t\t\t\tretpoline_compiler=1\n\t\t\t\t\t\tretpoline_compiler_reason=\"kernel reports full retpoline compilation\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telif [ -n \"$opt_map\" ]; then\n\t\t\t\t# look for the symbol\n\t\t\t\tif grep -qw noretpoline_setup \"$opt_map\"; then\n\t\t\t\t\tretpoline_compiler=1\n\t\t\t\t\tretpoline_compiler_reason=\"noretpoline_setup symbol found in System.map\"\n\t\t\t\tfi\n\t\t\telif [ -n \"$kernel\" ]; then\n\t\t\t\t# look for the symbol\n\t\t\t\tif command -v \"${opt_arch_prefix}nm\" >/dev/null 2>&1; then\n\t\t\t\t\t# the proper way: use nm and look for the symbol\n\t\t\t\t\tif \"${opt_arch_prefix}nm\" \"$kernel\" 2>/dev/null | grep -qw 'noretpoline_setup'; then\n\t\t\t\t\t\tretpoline_compiler=1\n\t\t\t\t\t\tretpoline_compiler_reason=\"noretpoline_setup found in kernel symbols\"\n\t\t\t\t\tfi\n\t\t\t\telif grep -q noretpoline_setup \"$kernel\"; then\n\t\t\t\t\t# if we don't have nm, nevermind, the symbol name is long enough to not have\n\t\t\t\t\t# any false positive using good old grep directly on the binary\n\t\t\t\t\tretpoline_compiler=1\n\t\t\t\t\tretpoline_compiler_reason=\"noretpoline_setup found in kernel\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ -n \"$retpoline_compiler\" ]; then\n\t\t\t\t_info_nol \"    * Kernel compiled with a retpoline-aware compiler: \"\n\t\t\t\tif [ \"$retpoline_compiler\" = 1 ]; then\n\t\t\t\t\tif [ -n \"$retpoline_compiler_reason\" ]; then\n\t\t\t\t\t\tpstatus green YES \"$retpoline_compiler_reason\"\n\t\t\t\t\telse\n\t\t\t\t\t\tpstatus green YES\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tif [ -n \"$retpoline_compiler_reason\" ]; then\n\t\t\t\t\t\tpstatus red NO \"$retpoline_compiler_reason\"\n\t\t\t\t\telse\n\t\t\t\t\t\tpstatus red NO\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t# only Red Hat has a tunable to disable it on runtime\n\t\tretp_enabled=-1\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ -e \"$specex_knob_dir/retp_enabled\" ]; then\n\t\t\t\tretp_enabled=$(cat \"$specex_knob_dir/retp_enabled\" 2>/dev/null)\n\t\t\t\t_debug \"retpoline: found $specex_knob_dir/retp_enabled=$retp_enabled\"\n\t\t\t\t_info_nol \"    * Retpoline is enabled: \"\n\t\t\t\tif [ \"$retp_enabled\" = 1 ]; then\n\t\t\t\t\tpstatus green YES\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t# only for information, in verbose mode\n\t\tif [ \"$opt_verbose\" -ge 2 ]; then\n\t\t\t_info_nol \"    * Local gcc is retpoline-aware: \"\n\t\t\tif command -v gcc >/dev/null 2>&1; then\n\t\t\t\tif [ -n \"$(gcc -mindirect-branch=thunk-extern --version 2>&1 >/dev/null)\" ]; then\n\t\t\t\t\tpstatus blue NO\n\t\t\t\telse\n\t\t\t\t\tpstatus green YES\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpstatus blue NO \"gcc is not installed\"\n\t\t\tfi\n\t\tfi\n\n\t\tif is_vulnerable_to_empty_rsb || [ \"$opt_verbose\" -ge 2 ]; then\n\t\t\t_info_nol \"  * Kernel supports RSB filling: \"\n\t\t\trsb_filling=0\n\t\t\tif [ \"$opt_live\" = 1 ] && [ \"$opt_no_sysfs\" != 1 ]; then\n\t\t\t\t# if we're live and we aren't denied looking into /sys, let's do it\n\t\t\t\tif echo \"$msg\" | grep -qw RSB; then\n\t\t\t\t\trsb_filling=1\n\t\t\t\t\tpstatus green YES\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ \"$rsb_filling\" = 0 ]; then\n\t\t\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\t\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\t\t\t\telse\n\t\t\t\t\tif grep -qw -e 'Filling RSB on context switch' \"$kernel\"; then\n\t\t\t\t\t\trsb_filling=1\n\t\t\t\t\t\tpstatus green YES\n\t\t\t\t\telse\n\t\t\t\t\t\trsb_filling=0\n\t\t\t\t\t\tpstatus yellow NO\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$retpoline\" = 1 ] && [ \"$retpoline_compiler\" = 1 ] && [ \"$retp_enabled\" != 0 ] && [ -n \"$ibpb_enabled\" ] && [ \"$ibpb_enabled\" -ge 1 ] && ( ! is_vulnerable_to_empty_rsb || [ \"$rsb_filling\" = 1 ] ); then\n\t\t\tpvulnstatus $cve OK \"Full retpoline + IBPB are mitigating the vulnerability\"\n\t\telif [ \"$retpoline\" = 1 ] && [ \"$retpoline_compiler\" = 1 ] && [ \"$retp_enabled\" != 0 ] && [ \"$opt_paranoid\" = 0 ] && ( ! is_vulnerable_to_empty_rsb || [ \"$rsb_filling\" = 1 ] ); then\n\t\t\tpvulnstatus $cve OK \"Full retpoline is mitigating the vulnerability\"\n\t\t\tif [ -n \"$cpuid_ibpb\" ]; then\n\t\t\t\t_warn \"You should enable IBPB to complete retpoline as a Variant 2 mitigation\"\n\t\t\telse\n\t\t\t\t_warn \"IBPB is considered as a good addition to retpoline for Variant 2 mitigation, but your CPU microcode doesn't support it\"\n\t\t\tfi\n\t\telif [ -n \"$ibrs_enabled\" ] && [ -n \"$ibpb_enabled\" ] && [ \"$ibrs_enabled\" -ge 1 ] && [ \"$ibpb_enabled\" -ge 1 ]; then\n\t\t\tif [ \"$ibrs_enabled\" = 4 ]; then\n\t\t\t\tpvulnstatus $cve OK \"Enhanced IBRS + IBPB are mitigating the vulnerability\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve OK \"IBRS + IBPB are mitigating the vulnerability\"\n\t\t\tfi\n\t\telif [ \"$ibpb_enabled\" = 2 ] && ! is_cpu_smt_enabled; then\n\t\t\tpvulnstatus $cve OK \"Full IBPB is mitigating the vulnerability\"\n\t\telif [ -n \"$bp_harden\" ]; then\n\t\t\tpvulnstatus $cve OK \"Branch predictor hardening mitigates the vulnerability\"\n\t\telif [ -z \"$bp_harden\" ] && [ \"$cpu_vendor\" = ARM ]; then\n\t\t\tpvulnstatus $cve VULN \"Branch predictor hardening is needed to mitigate the vulnerability\"\n\t\t\texplain \"Your kernel has not been compiled with the CONFIG_UNMAP_KERNEL_AT_EL0 option, recompile it with this option enabled.\"\n\t\telif [ \"$opt_live\" != 1 ]; then\n\t\t\tif [ \"$retpoline\" = 1 ] && [ -n \"$ibpb_supported\" ]; then\n\t\t\t\tpvulnstatus $cve OK \"offline mode: kernel supports retpoline + IBPB to mitigate the vulnerability\"\n\t\t\telif [ -n \"$ibrs_supported\" ] && [ -n \"$ibpb_supported\" ]; then\n\t\t\t\tpvulnstatus $cve OK \"offline mode: kernel supports IBRS + IBPB to mitigate the vulnerability\"\n\t\t\telif [ \"$ibrs_can_tell\" != 1 ]; then\n\t\t\t\tpvulnstatus $cve UNK \"offline mode: not enough information\"\n\t\t\t\texplain \"Re-run this script with root privileges, and give it the kernel image (--kernel), the kernel configuration (--config) and the System.map file (--map) corresponding to the kernel you would like to inspect.\"\n\t\t\tfi\n\t\tfi\n\n\t\t# if we arrive here and didn't already call pvulnstatus, then it's VULN, let's explain why\n\t\tif [ \"$pvulnstatus_last_cve\" != \"$cve\" ]; then\n\t\t\t# explain what's needed for this CPU\n\t\t\tif is_vulnerable_to_empty_rsb; then\n\t\t\t\tpvulnstatus $cve VULN \"IBRS+IBPB or retpoline+IBPB+RSB filling, is needed to mitigate the vulnerability\"\n\t\t\t\texplain \"To mitigate this vulnerability, you need either IBRS + IBPB, both requiring hardware support from your CPU microcode in addition to kernel support, or a kernel compiled with retpoline and IBPB, with retpoline requiring a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware) and IBPB requiring hardware support from your CPU microcode. You also need a recent-enough kernel that supports RSB filling if you plan to use retpoline. For Skylake+ CPUs, the IBRS + IBPB approach is generally preferred as it guarantees complete protection, and the performance impact is not as high as with older CPUs in comparison with retpoline. More information about how to enable the missing bits for those two possible mitigations on your system follow. You only need to take one of the two approaches.\"\n\t\t\telif is_zen_cpu || is_moksha_cpu; then\n\t\t\t\tpvulnstatus $cve VULN \"retpoline+IBPB is needed to mitigate the vulnerability\"\n\t\t\t\texplain \"To mitigate this vulnerability, You need a kernel compiled with retpoline + IBPB support, with retpoline requiring a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware) and IBPB requiring hardware support from your CPU microcode.\"\n\t\t\telif is_intel || is_amd || is_hygon; then\n\t\t\t\tpvulnstatus $cve VULN \"IBRS+IBPB or retpoline+IBPB is needed to mitigate the vulnerability\"\n\t\t\t\texplain \"To mitigate this vulnerability, you need either IBRS + IBPB, both requiring hardware support from your CPU microcode in addition to kernel support, or a kernel compiled with retpoline and IBPB, with retpoline requiring a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware) and IBPB requiring hardware support from your CPU microcode. The retpoline + IBPB approach is generally preferred as the performance impact is lower. More information about how to enable the missing bits for those two possible mitigations on your system follow. You only need to take one of the two approaches.\"\n\t\t\telse\n\t\t\t\t# in that case, we might want to trust sysfs if it's there\n\t\t\t\tif [ -n \"$msg\" ]; then\n\t\t\t\t\t[ \"$msg\" = Vulnerable ] && msg=\"no known mitigation exists for your CPU vendor ($cpu_vendor)\"\n\t\t\t\t\tpvulnstatus $cve $status \"$msg\"\n\t\t\t\telse\n\t\t\t\t\tpvulnstatus $cve VULN \"no known mitigation exists for your CPU vendor ($cpu_vendor)\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t# if we are in live mode, we can check for a lot more stuff and explain further\n\t\tif [ \"$opt_live\" = 1 ] && [ \"$vulnstatus\" != \"OK\" ]; then\n\t\t\t_explain_hypervisor=\"An updated CPU microcode will have IBRS/IBPB capabilities indicated in the Hardware Check section above. If you're running under a hypervisor (KVM, Xen, VirtualBox, VMware, ...), the hypervisor needs to be up to date to be able to export the new host CPU flags to the guest. You can run this script on the host to check if the host CPU is IBRS/IBPB. If it is, and it doesn't show up in the guest, upgrade the hypervisor. You may need to reconfigure your VM to use a CPU model that has IBRS capability; in Libvirt, such CPUs are listed with an IBRS suffix.\"\n\t\t\t# IBPB (amd & intel)\n\t\t\tif { [ -z \"$ibpb_enabled\" ] || [ \"$ibpb_enabled\" = 0 ]; } && { is_intel || is_amd || is_hygon; }; then\n\t\t\t\tif [ -z \"$cpuid_ibpb\" ]; then\n\t\t\t\t\texplain \"The microcode of your CPU needs to be upgraded to be able to use IBPB. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). $_explain_hypervisor\"\n\t\t\t\tfi\n\t\t\t\tif [ -z \"$ibpb_supported\" ]; then\n\t\t\t\t\texplain \"Your kernel doesn't have IBPB support, so you need to either upgrade your kernel (if you're using a distro) or recompiling a more recent kernel.\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$cpuid_ibpb\" ] && [ -n \"$ibpb_supported\" ]; then\n\t\t\t\t\tif [ -e \"$specex_knob_dir/ibpb_enabled\" ]; then\n\t\t\t\t\t\t# newer (April 2018) Red Hat kernels have ibpb_enabled as ro, and automatically enables it with retpoline\n\t\t\t\t\t\tif [ ! -w \"$specex_knob_dir/ibpb_enabled\" ] && [ -e \"$specex_knob_dir/retp_enabled\" ]; then\n\t\t\t\t\t\t\texplain \"Both your CPU and your kernel have IBPB support, but it is currently disabled. You kernel should enable IBPB automatically if you enable retpoline. You may enable it with \\`echo 1 > $specex_knob_dir/retp_enabled\\`.\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texplain \"Both your CPU and your kernel have IBPB support, but it is currently disabled. You may enable it with \\`echo 1 > $specex_knob_dir/ibpb_enabled\\`.\"\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\texplain \"Both your CPU and your kernel have IBPB support, but it is currently disabled. You may enable it. Check in your distro's documentation on how to do this.\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telif [ \"$ibpb_enabled\" = 2 ] && is_cpu_smt_enabled; then\n\t\t\t\texplain \"You have ibpb_enabled set to 2, but it only offers sufficient protection when simultaneous multi-threading (aka SMT or HyperThreading) is disabled. You should reboot your system with the kernel parameter \\`nosmt\\`.\"\n\t\t\tfi\n\t\t\t# /IBPB\n\n\t\t\t# IBRS (amd & intel)\n\t\t\tif { [ -z \"$ibrs_enabled\" ] || [ \"$ibrs_enabled\" = 0 ]; } && { is_intel || is_amd || is_hygon; }; then\n\t\t\t\tif [ -z \"$cpuid_ibrs\" ]; then\n\t\t\t\t\texplain \"The microcode of your CPU needs to be upgraded to be able to use IBRS. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). $_explain_hypervisor\"\n\t\t\t\tfi\n\t\t\t\tif [ -z \"$ibrs_supported\" ]; then\n\t\t\t\t\texplain \"Your kernel doesn't have IBRS support, so you need to either upgrade your kernel (if you're using a distro) or recompiling a more recent kernel.\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$cpuid_ibrs\" ] && [ -n \"$ibrs_supported\" ]; then\n\t\t\t\t\tif [ -e \"$specex_knob_dir/ibrs_enabled\" ]; then\n\t\t\t\t\t\texplain \"Both your CPU and your kernel have IBRS support, but it is currently disabled. You may enable it with \\`echo 1 > $specex_knob_dir/ibrs_enabled\\`.\"\n\t\t\t\t\telse\n\t\t\t\t\t\texplain \"Both your CPU and your kernel have IBRS support, but it is currently disabled. You may enable it. Check in your distro's documentation on how to do this.\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t# /IBRS\n\t\t\tunset _explain_hypervisor\n\n\t\t\t# RETPOLINE (amd & intel &hygon )\n\t\t\tif is_amd || is_intel || is_hygon; then\n\t\t\t\tif [ \"$retpoline\" = 0 ]; then\n\t\t\t\t\texplain \"Your kernel is not compiled with retpoline support, so you need to either upgrade your kernel (if you're using a distro) or recompile your kernel with the CONFIG_MITIGATION_RETPOLINE option enabled (was named CONFIG_RETPOLINE before kernel 6.9-rc1). You also need to compile your kernel with a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware).\"\n\t\t\t\telif [ \"$retpoline\" = 1 ] && [ \"$retpoline_compiler\" = 0 ]; then\n\t\t\t\t\texplain \"Your kernel is compiled with retpoline, but without a retpoline-aware compiler (re-run this script with -v to know if your version of gcc is retpoline-aware).\"\n\t\t\t\telif [ \"$retpoline\" = 1 ] && [ \"$retpoline_compiler\" = 1 ] && [ \"$retp_enabled\" = 0 ]; then\n\t\t\t\t\texplain \"Your kernel has retpoline support and has been compiled with a retpoline-aware compiler, but retpoline is disabled. You should enable it with \\`echo 1 > $specex_knob_dir/retp_enabled\\`.\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\t# /RETPOLINE\n\t\tfi\n\tfi\n\t# sysfs msgs:\n\t#1 \"Vulnerable\"\n\t#2 \"Vulnerable: Minimal generic ASM retpoline\"\n\t#2 \"Vulnerable: Minimal AMD ASM retpoline\"\n\t# \"Mitigation: Full generic retpoline\"\n\t# \"Mitigation: Full AMD retpoline\"\n\t# $MITIGATION + \", IBPB\"\n\t# $MITIGATION + \", IBRS_FW\"\n\t#5 $MITIGATION + \" - vulnerable module loaded\"\n\t# Red Hat only:\n\t#2 \"Vulnerable: Minimal ASM retpoline\",\n\t#3 \"Vulnerable: Retpoline without IBPB\",\n\t#4 \"Vulnerable: Retpoline on Skylake+\",\n\t#5 \"Vulnerable: Retpoline with unsafe module(s)\",\n\t# \"Mitigation: Full retpoline\",\n\t# \"Mitigation: Full retpoline and IBRS (user space)\",\n\t# \"Mitigation: IBRS (kernel)\",\n\t# \"Mitigation: IBRS (kernel and user space)\",\n\t# \"Mitigation: IBP disabled\",\n}\n\ncheck_CVE_2017_5715_bsd()\n{\n\t_info     \"* Mitigation 1\"\n\t_info_nol \"  * Kernel supports IBRS: \"\n\tibrs_disabled=$(sysctl -n hw.ibrs_disable 2>/dev/null)\n\tif [ -z \"$ibrs_disabled\" ]; then\n\t\tpstatus yellow NO\n\telse\n\t\tpstatus green YES\n\tfi\n\n\t_info_nol \"  * IBRS enabled and active: \"\n\tibrs_active=$(sysctl -n hw.ibrs_active 2>/dev/null)\n\tif [ \"$ibrs_active\" = 1 ]; then\n\t\tpstatus green YES\n\telse\n\t\tpstatus yellow NO\n\tfi\n\n\t_info     \"* Mitigation 2\"\n\t_info_nol \"  * Kernel compiled with RETPOLINE: \"\n\tretpoline=0\n\tif [ -n \"$kernel_err\" ]; then\n\t\tpstatus yellow UNKNOWN \"couldn't check ($kernel_err)\"\n\telse\n\t\tif ! command -v \"${opt_arch_prefix}readelf\" >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing '${opt_arch_prefix}readelf' tool, please install it, usually it's in the binutils package\"\n\t\telse\n\t\t\tnb_thunks=$(\"${opt_arch_prefix}readelf\" -s \"$kernel\" | grep -c -e __llvm_retpoline_ -e __llvm_external_retpoline_ -e __x86_indirect_thunk_)\n\t\t\tif [ \"$nb_thunks\" -gt 0 ]; then\n\t\t\t\tretpoline=1\n\t\t\t\tpstatus green YES \"found $nb_thunks thunk(s)\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ \"$retpoline\" = 1 ]; then\n\t\tpvulnstatus $cve OK \"Retpoline mitigates the vulnerability\"\n\telif [ \"$ibrs_active\" = 1 ]; then\n\t\tpvulnstatus $cve OK \"IBRS mitigates the vulnerability\"\n\telif [ \"$ibrs_disabled\" = 0 ]; then\n\t\tpvulnstatus $cve VULN \"IBRS is supported by your kernel but your CPU microcode lacks support\"\n\t\texplain \"The microcode of your CPU needs to be upgraded to be able to use IBRS. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). To do a microcode update, you can search the ports for the \\`cpupdate\\` tool. Microcode updates done this way are not reboot-proof, so be sure to do it every time the system boots up.\"\n\telif [ \"$ibrs_disabled\" = 1 ]; then\n\t\tpvulnstatus $cve VULN \"IBRS is supported but administratively disabled on your system\"\n\t\texplain \"To enable IBRS, use \\`sysctl hw.ibrs_disable=0\\`\"\n\telse\n\t\tpvulnstatus $cve VULN \"IBRS is needed to mitigate the vulnerability but your kernel is missing support\"\n\t\texplain \"You need to either upgrade your kernel or recompile yourself a more recent version having IBRS support\"\n\tfi\n}\n\n##################\n# MELTDOWN SECTION\n\n# no security impact but give a hint to the user in verbose mode\n# about PCID/INVPCID cpuid features that must be present to avoid\n# too big a performance impact with PTI\n# refs:\n# https://marc.info/?t=151532047900001&r=1&w=2\n# https://groups.google.com/forum/m/#!topic/mechanical-sympathy/L9mHTbeQLNU\npti_performance_check()\n{\n\t_info_nol \"  * Reduced performance impact of PTI: \"\n\tif [ -e \"$procfs/cpuinfo\" ] && grep ^flags \"$procfs/cpuinfo\" | grep -qw pcid; then\n\t\tcpu_pcid=1\n\telse\n\t\tread_cpuid 0x1 0x0 $ECX 17 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpu_pcid=1\n\t\tfi\n\tfi\n\n\tif [ -e \"$procfs/cpuinfo\" ] && grep ^flags \"$procfs/cpuinfo\" | grep -qw invpcid; then\n\t\tcpu_invpcid=1\n\telse\n\t\tread_cpuid 0x7 0x0 $EBX 10 1 1; ret=$?\n\t\tif [ $ret = $READ_CPUID_RET_OK ]; then\n\t\t\tcpu_invpcid=1\n\t\tfi\n\tfi\n\n\tif [ \"$cpu_invpcid\" = 1 ]; then\n\t\tpstatus green YES 'CPU supports INVPCID, performance impact of PTI will be greatly reduced'\n\telif [ \"$cpu_pcid\" = 1 ]; then\n\t\tpstatus green YES 'CPU supports PCID, performance impact of PTI will be reduced'\n\telse\n\t\tpstatus blue NO 'PCID/INVPCID not supported, performance impact of PTI will be significant'\n\tfi\n}\n\n# rogue data cache load aka 'Meltdown' aka 'Variant 3'\ncheck_CVE_2017_5754()\n{\n\tcve='CVE-2017-5754'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2017_5754_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2017_5754_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2017_5754_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/meltdown\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* Kernel supports Page Table Isolation (PTI): \"\n\t\tkpti_support=''\n\t\tkpti_can_tell=0\n\t\tif [ -n \"$opt_config\" ]; then\n\t\t\tkpti_can_tell=1\n\t\t\tkpti_support=$(grep -E -w -e 'CONFIG_(MITIGATION_)?PAGE_TABLE_ISOLATION=y' -e CONFIG_KAISER=y -e CONFIG_UNMAP_KERNEL_AT_EL0=y \"$opt_config\")\n\t\t\tif [ -n \"$kpti_support\" ]; then\n\t\t\t\t_debug \"kpti_support: found option '$kpti_support' in $opt_config\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$kpti_support\" ] && [ -n \"$opt_map\" ]; then\n\t\t\t# it's not an elif: some backports don't have the PTI config but still include the patch\n\t\t\t# so we try to find an exported symbol that is part of the PTI patch in System.map\n\t\t\t# parse_kpti: arm\n\t\t\tkpti_can_tell=1\n\t\t\tkpti_support=$(grep -w -e kpti_force_enabled -e parse_kpti \"$opt_map\")\n\t\t\tif [ -n \"$kpti_support\" ]; then\n\t\t\t\t_debug \"kpti_support: found '$kpti_support' in $opt_map\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$kpti_support\" ] && [ -n \"$kernel\" ]; then\n\t\t\t# same as above but in case we don't have System.map and only kernel, look for the\n\t\t\t# nopti option that is part of the patch (kernel command line option)\n\t\t\t# 'kpti=': arm\n\t\t\tkpti_can_tell=1\n\t\t\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\t\t\tpstatus yellow UNKNOWN \"missing '${opt_arch_prefix}strings' tool, please install it, usually it's in the binutils package\"\n\t\t\telse\n\t\t\t\tkpti_support=$(\"${opt_arch_prefix}strings\" \"$kernel\" | grep -w -e nopti -e kpti=)\n\t\t\t\tif [ -n \"$kpti_support\" ]; then\n\t\t\t\t\t_debug \"kpti_support: found '$kpti_support' in $kernel\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\tif [ -n \"$kpti_support\" ]; then\n\t\t\tif [ \"$opt_verbose\" -ge 2 ]; then\n\t\t\t\tpstatus green YES \"found '$kpti_support'\"\n\t\t\telse\n\t\t\t\tpstatus green YES\n\t\t\tfi\n\t\telif [ \"$kpti_can_tell\" = 1 ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN \"couldn't read your kernel configuration nor System.map file\"\n\t\tfi\n\n\t\tmount_debugfs\n\t\t_info_nol \"  * PTI enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tdmesg_grep=\"Kernel/User page tables isolation: enabled\"\n\t\t\tdmesg_grep=\"$dmesg_grep|Kernel page table isolation enabled\"\n\t\t\tdmesg_grep=\"$dmesg_grep|x86/pti: Unmapping kernel while in userspace\"\n\t\t\t# aarch64\n\t\t\tdmesg_grep=\"$dmesg_grep|CPU features: detected( feature)?: Kernel page table isolation \\(KPTI\\)\"\n\t\t\tif grep ^flags \"$procfs/cpuinfo\" | grep -qw pti; then\n\t\t\t\t# vanilla PTI patch sets the 'pti' flag in cpuinfo\n\t\t\t\t_debug \"kpti_enabled: found 'pti' flag in $procfs/cpuinfo\"\n\t\t\t\tkpti_enabled=1\n\t\t\telif grep ^flags \"$procfs/cpuinfo\" | grep -qw kaiser; then\n\t\t\t\t# kernel line 4.9 sets the 'kaiser' flag in cpuinfo\n\t\t\t\t_debug \"kpti_enabled: found 'kaiser' flag in $procfs/cpuinfo\"\n\t\t\t\tkpti_enabled=1\n\t\t\telif [ -e /sys/kernel/debug/x86/pti_enabled ]; then\n\t\t\t\t# Red Hat Backport creates a dedicated file, see https://access.redhat.com/articles/3311301\n\t\t\t\tkpti_enabled=$(cat /sys/kernel/debug/x86/pti_enabled 2>/dev/null)\n\t\t\t\t_debug \"kpti_enabled: file /sys/kernel/debug/x86/pti_enabled exists and says: $kpti_enabled\"\n\t\t\telif is_xen_dom0; then\n\t\t\t\tpti_xen_pv_domU=$(xl dmesg | grep 'XPTI' | grep 'DomU enabled' | head -1)\n\n\t\t\t\t[ -n \"$pti_xen_pv_domU\" ] && kpti_enabled=1\n\t\t\tfi\n\t\t\tif [ -z \"$kpti_enabled\" ]; then\n\t\t\t\tdmesg_grep \"$dmesg_grep\"; ret=$?\n\t\t\t\tif [ $ret -eq 0 ]; then\n\t\t\t\t\t_debug \"kpti_enabled: found hint in dmesg: $dmesg_grepped\"\n\t\t\t\t\tkpti_enabled=1\n\t\t\t\telif [ $ret -eq 2 ]; then\n\t\t\t\t\t_debug \"kpti_enabled: dmesg truncated\"\n\t\t\t\t\tkpti_enabled=-1\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ -z \"$kpti_enabled\" ]; then\n\t\t\t\t_debug \"kpti_enabled: couldn't find any hint that PTI is enabled\"\n\t\t\t\tkpti_enabled=0\n\t\t\tfi\n\t\t\tif [ \"$kpti_enabled\" = 1 ]; then\n\t\t\t\tpstatus green YES\n\t\t\telif [ \"$kpti_enabled\" = -1 ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"dmesg truncated, please reboot and relaunch this script\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\tpti_performance_check\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\n\t# Test if the current host is a Xen PV Dom0 / DomU\n\txen_pv_domo=0\n\txen_pv_domu=0\n\tis_xen_dom0 && xen_pv_domo=1\n\tis_xen_domU && xen_pv_domu=1\n\n\tif [ \"$opt_live\" = 1 ]; then\n\t\t# checking whether we're running under Xen PV 64 bits. If yes, we are affected by variant3\n\t\t# (unless we are a Dom0)\n\t\t_info_nol \"* Running as a Xen PV DomU: \"\n\t\tif [ \"$xen_pv_domu\" = 1 ]; then\n\t\t\tpstatus yellow YES\n\t\telse\n\t\t\tpstatus blue NO\n\t\tfi\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ \"$kpti_enabled\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"PTI mitigates the vulnerability\"\n\t\t\telif [ \"$xen_pv_domo\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"Xen Dom0s are safe and do not require PTI\"\n\t\t\telif [ \"$xen_pv_domu\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve VULN \"Xen PV DomUs are vulnerable and need to be run in HVM, PVHVM, PVH mode, or the Xen hypervisor must have the Xen's own PTI patch\"\n\t\t\t\texplain \"Go to https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ for more information\"\n\t\t\telif [ \"$kpti_enabled\" = -1 ]; then\n\t\t\t\tpvulnstatus $cve UNK \"couldn't find any clue of PTI activation due to a truncated dmesg, please reboot and relaunch this script\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"PTI is needed to mitigate the vulnerability\"\n\t\t\t\tif [ -n \"$kpti_support\" ]; then\n\t\t\t\t\tif [ -e \"/sys/kernel/debug/x86/pti_enabled\" ]; then\n\t\t\t\t\t\texplain \"Your kernel supports PTI but it's disabled, you can enable it with \\`echo 1 > /sys/kernel/debug/x86/pti_enabled\\`\"\n\t\t\t\t\telif echo \"$kernel_cmdline\" | grep -q -w -e nopti -e pti=off; then\n\t\t\t\t\t\texplain \"Your kernel supports PTI but it has been disabled on command-line, remove the nopti or pti=off option from your bootloader configuration\"\n\t\t\t\t\telse\n\t\t\t\t\t\texplain \"Your kernel supports PTI but it has been disabled, check \\`dmesg\\` right after boot to find clues why the system disabled it\"\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\texplain \"If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_(MITIGATION_)PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)\"\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tif [ -n \"$kpti_support\" ]; then\n\t\t\t\tpvulnstatus $cve OK \"offline mode: PTI will mitigate the vulnerability if enabled at runtime\"\n\t\t\telif [ \"$kpti_can_tell\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve VULN \"PTI is needed to mitigate the vulnerability\"\n\t\t\t\texplain \"If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_(MITIGATION_)PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve UNK \"offline mode: not enough information\"\n\t\t\t\texplain \"Re-run this script with root privileges, and give it the kernel image (--kernel), the kernel configuration (--config) and the System.map file (--map) corresponding to the kernel you would like to inspect.\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\tif [ \"$xen_pv_domo\" = 1 ]; then\n\t\t\tmsg=\"Xen Dom0s are safe and do not require PTI\"\n\t\t\tstatus=\"OK\"\n\t\telif [ \"$xen_pv_domu\" = 1 ]; then\n\t\t\tmsg=\"Xen PV DomUs are vulnerable and need to be run in HVM, PVHVM, PVH mode, or the Xen hypervisor must have the Xen's own PTI patch\"\n\t\t\tstatus=\"VULN\"\n\t\t\t_explain=\"Go to https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ for more information\"\n\t\telif [ \"$msg\" = \"Vulnerable\" ]; then\n\t\t\tmsg=\"PTI is needed to mitigate the vulnerability\"\n\t\t\t_explain=\"If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_(MITIGATION_)PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)\"\n\t\tfi\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\t\t[ -z \"${_explain:-}\" ] && [ \"$msg\" = \"Vulnerable\" ] && _explain=\"If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel with the CONFIG_(MITIGATION_)PAGE_TABLE_ISOLATION option (named CONFIG_KAISER for some kernels), or the CONFIG_UNMAP_KERNEL_AT_EL0 option (for ARM64)\"\n\t\t[ -n \"${_explain:-}\" ] && explain \"$_explain\"\n\t\tunset _explain\n\tfi\n\n\t# Warn the user about XSA-254 recommended mitigations\n\tif [ \"$xen_pv_domo\" = 1 ]; then\n\t\t_warn\n\t\t_warn \"This host is a Xen Dom0. Please make sure that you are running your DomUs\"\n\t\t_warn \"in HVM, PVHVM or PVH mode to prevent any guest-to-host / host-to-guest attacks.\"\n\t\t_warn\n\t\t_warn \"See https://blog.xenproject.org/2018/01/22/xen-project-spectre-meltdown-faq-jan-22-update/ and XSA-254 for details.\"\n\tfi\n}\n\ncheck_CVE_2017_5754_bsd()\n{\n\t_info_nol \"* Kernel supports Page Table Isolation (PTI): \"\n\tkpti_enabled=$(sysctl -n vm.pmap.pti 2>/dev/null)\n\tif [ -z \"$kpti_enabled\" ]; then\n\t\tpstatus yellow NO\n\telse\n\t\tpstatus green YES\n\tfi\n\n\t_info_nol \"  * PTI enabled and active: \"\n\tif [ \"$kpti_enabled\" = 1 ]; then\n\t\tpstatus green YES\n\telse\n\t\tpstatus yellow NO\n\tfi\n\n\tpti_performance_check\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ \"$kpti_enabled\" = 1 ]; then\n\t\tpvulnstatus $cve OK \"PTI mitigates the vulnerability\"\n\telif [ -n \"$kpti_enabled\" ]; then\n\t\tpvulnstatus $cve VULN \"PTI is supported but disabled on your system\"\n\telse\n\t\tpvulnstatus $cve VULN \"PTI is needed to mitigate the vulnerability\"\n\tfi\n}\n\n####################\n# VARIANT 3A SECTION\n\n# rogue system register read aka 'Variant 3a'\ncheck_CVE_2018_3640()\n{\n\tcve='CVE-2018-3640'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\n\t_info_nol \"* CPU microcode mitigates the vulnerability: \"\n\tif [ -n \"$cpuid_ssbd\" ]; then\n\t\t# microcodes that ship with SSBD are known to also fix variant3a\n\t\t# there is no specific cpuid bit as far as we know\n\t\tpstatus green YES\n\telse\n\t\tpstatus yellow NO\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -n \"$cpuid_ssbd\" ]; then\n\t\tpvulnstatus $cve OK \"your CPU microcode mitigates the vulnerability\"\n\telse\n\t\tpvulnstatus $cve VULN \"an up-to-date CPU microcode is needed to mitigate this vulnerability\"\n\t\texplain \"The microcode of your CPU needs to be upgraded to mitigate this vulnerability. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section). The microcode update is enough, there is no additional OS, kernel or software change needed.\"\n\tfi\n}\n\n###################\n# VARIANT 4 SECTION\n\n# speculative store bypass aka 'Variant 4'\ncheck_CVE_2018_3639()\n{\n\tcve='CVE-2018-3639'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2018_3639_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2018_3639_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2018_3639_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/spec_store_bypass\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* Kernel supports disabling speculative store bypass (SSB): \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif grep -Eq 'Speculation.?Store.?Bypass:' \"$procfs/self/status\" 2>/dev/null; then\n\t\t\t\tkernel_ssb=\"found in $procfs/self/status\"\n\t\t\t\t_debug \"found Speculation.Store.Bypass: in $procfs/self/status\"\n\t\t\tfi\n\t\tfi\n\t\t# arm64 kernels can have cpu_show_spec_store_bypass with ARM64_SSBD, so exclude them\n\t\tif [ -z \"$kernel_ssb\" ] && [ -n \"$kernel\" ] && ! grep -q 'arm64_sys_' \"$kernel\"; then\n\t\t\tkernel_ssb=$(\"${opt_arch_prefix}strings\" \"$kernel\" | grep spec_store_bypass | head -n1);\n\t\t\t[ -n \"$kernel_ssb\" ] && kernel_ssb=\"found $kernel_ssb in kernel\"\n\t\tfi\n\t\t# arm64 kernels can have cpu_show_spec_store_bypass with ARM64_SSBD, so exclude them\n\t\tif [ -z \"$kernel_ssb\" ] && [ -n \"$opt_map\" ] && ! grep -q 'arm64_sys_' \"$opt_map\"; then\n\t\t\tkernel_ssb=$(grep spec_store_bypass \"$opt_map\" | awk '{print $3}' | head -n1)\n\t\t\t[ -n \"$kernel_ssb\" ] && kernel_ssb=\"found $kernel_ssb in System.map\"\n\t\tfi\n\t\t# arm64 only:\n\t\tif [ -z \"$kernel_ssb\" ] && [ -n \"$opt_map\" ]; then\n\t\t\tkernel_ssb=$(grep -w cpu_enable_ssbs \"$opt_map\" | awk '{print $3}' | head -n1)\n\t\t\t[ -n \"$kernel_ssb\" ] && kernel_ssb=\"found $kernel_ssb in System.map\"\n\t\tfi\n\t\tif [ -z \"$kernel_ssb\" ] && [ -n \"$opt_config\" ]; then\n\t\t\tkernel_ssb=$(grep -w 'CONFIG_ARM64_SSBD=y' \"$opt_config\")\n\t\t\t[ -n \"$kernel_ssb\" ] && kernel_ssb=\"CONFIG_ARM64_SSBD enabled in kconfig\"\n\t\tfi\n\t\tif [ -z \"$kernel_ssb\" ] && [ -n \"$kernel\" ]; then\n\t\t\t# this string only appears in kernel if CONFIG_ARM64_SSBD is set\n\t\t\tkernel_ssb=$(grep -w \"Speculative Store Bypassing Safe (SSBS)\" \"$kernel\")\n\t\t\t[ -n \"$kernel_ssb\" ] && kernel_ssb=\"found 'Speculative Store Bypassing Safe (SSBS)' in kernel\"\n\t\tfi\n\t\t# /arm64 only\n\n\t\tif [ -n \"$kernel_ssb\" ]; then\n\t\t\tpstatus green YES \"$kernel_ssb\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\tkernel_ssbd_enabled=-1\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t# https://elixir.bootlin.com/linux/v5.0/source/fs/proc/array.c#L340\n\t\t\t_info_nol \"* SSB mitigation is enabled and active: \"\n\t\t\tif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+thread' \"$procfs/self/status\" 2>/dev/null; then\n\t\t\t\tkernel_ssbd_enabled=1\n\t\t\t\tpstatus green YES \"per-thread through prctl\"\n\t\t\telif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+globally mitigated' \"$procfs/self/status\" 2>/dev/null; then\n\t\t\t\tkernel_ssbd_enabled=2\n\t\t\t\tpstatus green YES \"global\"\n\t\t\telif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+vulnerable' \"$procfs/self/status\" 2>/dev/null; then\n\t\t\t\tkernel_ssbd_enabled=0\n\t\t\t\tpstatus yellow NO\n\t\t\telif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+not vulnerable' \"$procfs/self/status\" 2>/dev/null; then\n\t\t\t\tkernel_ssbd_enabled=-2\n\t\t\t\tpstatus blue NO \"not vulnerable\"\n\t\t\telif grep -Eq 'Speculation.?Store.?Bypass:[[:space:]]+unknown' \"$procfs/self/status\" 2>/dev/null; then\n\t\t\t\tkernel_ssbd_enabled=0\n\t\t\t\tpstatus blue NO\n\t\t\telse\n\t\t\t\tpstatus blue UNKNOWN \"unknown value: $(grep -E 'Speculation.?Store.?Bypass:' \"$procfs/self/status\" 2>/dev/null | cut -d: -f2-)\"\n\t\t\tfi\n\n\t\t\tif [ \"$kernel_ssbd_enabled\" = 1 ]; then\n\t\t\t\t_info_nol \"* SSB mitigation currently active for selected processes: \"\n\t\t\t\t# silence grep's stderr here to avoid ENOENT errors from processes that have exited since the shell's expansion of the *\n\t\t\t\tmitigated_processes=$(find /proc -mindepth 2 -maxdepth 2 -type f -name status -print0 2>/dev/null \\\n\t\t\t\t\t| xargs -r0 grep -El 'Speculation.?Store.?Bypass:[[:space:]]+thread (force )?mitigated' 2>/dev/null \\\n\t\t\t\t\t| sed s/status/exe/ | xargs -r -n1 readlink -f 2>/dev/null | xargs -r -n1 basename | sort -u | tr \"\\n\" \" \" | sed 's/ $//')\n\t\t\t\tif [ -n \"$mitigated_processes\" ]; then\n\t\t\t\t\tpstatus green YES \"$mitigated_processes\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO \"no process found using SSB mitigation through prctl\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ] || [ \"$msg\" = \"Vulnerable\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ -n \"$cpuid_ssbd\" ]; then\n\t\t\tif [ -n \"$kernel_ssb\" ]; then\n\t\t\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t\t\tif [ \"$kernel_ssbd_enabled\" -gt 0 ]; then\n\t\t\t\t\t\tpvulnstatus $cve OK \"your CPU and kernel both support SSBD and mitigation is enabled\"\n\t\t\t\t\telse\n\t\t\t\t\t\tpvulnstatus $cve VULN \"your CPU and kernel both support SSBD but the mitigation is not active\"\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tpvulnstatus $cve OK \"your system provides the necessary tools for software mitigation\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"your kernel needs to be updated\"\n\t\t\t\texplain \"You have a recent-enough CPU microcode but your kernel is too old to use the new features exported by your CPU's microcode. If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel from recent-enough sources.\"\n\t\t\tfi\n\t\telse\n\t\t\tif [ -n \"$kernel_ssb\" ]; then\n\t\t\t\tpvulnstatus $cve VULN \"Your CPU doesn't support SSBD\"\n\t\t\t\texplain \"Your kernel is recent enough to use the CPU microcode features for mitigation, but your CPU microcode doesn't actually provide the necessary features for the kernel to use. The microcode of your CPU hence needs to be upgraded. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section).\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"Neither your CPU nor your kernel support SSBD\"\n\t\t\t\texplain \"Both your CPU microcode and your kernel are lacking support for mitigation. If you're using a distro kernel, upgrade your distro to get the latest kernel available. Otherwise, recompile the kernel from recent-enough sources. The microcode of your CPU also needs to be upgraded. This is usually done at boot time by your kernel (the upgrade is not persistent across reboots which is why it's done at each boot). If you're using a distro, make sure you are up to date, as microcode updates are usually shipped alongside with the distro kernel. Availability of a microcode update for you CPU model depends on your CPU vendor. You can usually find out online if a microcode update is available for your CPU by searching for your CPUID (indicated in the Hardware Check section).\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\tfi\n}\n\ncheck_CVE_2018_3639_bsd()\n{\n\t_info_nol \"* Kernel supports speculation store bypass: \"\n\tif sysctl hw.spec_store_bypass_disable >/dev/null 2>&1; then\n\t\tkernel_ssb=1\n\t\tpstatus green YES\n\telse\n\t\tkernel_ssb=0\n\t\tpstatus yellow NO\n\tfi\n\n\t_info_nol \"* Speculation store bypass is administratively enabled: \"\n\tssb_enabled=$(sysctl -n hw.spec_store_bypass_disable 2>/dev/null)\n\t_debug \"hw.spec_store_bypass_disable=$ssb_enabled\"\n\tcase \"$ssb_enabled\" in\n\t\t0) pstatus yellow NO \"disabled\";;\n\t\t1) pstatus green YES \"enabled\";;\n\t\t2) pstatus green YES \"auto mode\";;\n\t\t*) pstatus yellow NO \"unavailable\";;\n\tesac\n\n\t_info_nol \"* Speculation store bypass is currently active: \"\n\tssb_active=$(sysctl -n hw.spec_store_bypass_disable_active 2>/dev/null)\n\t_debug \"hw.spec_store_bypass_disable_active=$ssb_active\"\n\tcase \"$ssb_active\" in\n\t\t1) pstatus green YES;;\n\t\t*) pstatus yellow NO;;\n\tesac\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$ssb_active\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"SSBD mitigates the vulnerability\"\n\t\telif [ -n \"$cpuid_ssbd\" ]; then\n\t\t\tif [ \"$kernel_ssb\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve VULN \"you need to enable SSBD through sysctl to mitigate the vulnerability\"\n\t\t\t\texplain \"To enable SSBD right now, you can run \\`sysctl hw.spec_store_bypass_disable=2'. To make this change persistent across reboots, you can add 'sysctl hw.spec_store_bypass_disable=2' to /etc/sysctl.conf.\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"your kernel needs to be updated\"\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$kernel_ssb\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve VULN \"Your CPU doesn't support SSBD\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"Neither your CPU nor your kernel support SSBD\"\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\n###########################\n# L1TF / FORESHADOW SECTION\n\n# L1 terminal fault (SGX) aka 'Foreshadow'\ncheck_CVE_2018_3615()\n{\n\tcve='CVE-2018-3615'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\n\t_info_nol \"* CPU microcode mitigates the vulnerability: \"\n\tif { [ \"$cpu_flush_cmd\" = 1 ] || { [ \"$msr_locked_down\" = 1 ] && [ \"$cpuid_l1df\" = 1 ]; }; } && [ \"$cpuid_sgx\" = 1 ]; then\n\t\t# no easy way to detect a fixed SGX but we know that\n\t\t# microcodes that have the FLUSH_CMD MSR also have the\n\t\t# fixed SGX (for CPUs that support it), because Intel\n\t\t# delivered fixed microcodes for both issues at the same time\n\t\t#\n\t\t# if the system we're running on is locked down (no way to write MSRs),\n\t\t# make the assumption that if the L1D flush CPUID bit is set, probably\n\t\t# that FLUSH_CMD MSR is here too\n\t\tpstatus green YES\n\telif [ \"$cpuid_sgx\" = 1 ]; then\n\t\tpstatus red NO\n\telse\n\t\tpstatus blue N/A\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ \"$cpu_flush_cmd\" = 1 ] || { [ \"$msr_locked_down\" = 1 ] && [ \"$cpuid_l1df\" = 1 ]; } ; then\n\t\tpvulnstatus $cve OK \"your CPU microcode mitigates the vulnerability\"\n\telse\n\t\tpvulnstatus $cve VULN \"your CPU supports SGX and the microcode is not up to date\"\n\tfi\n}\n\n# L1 terminal fault (OS) aka 'Foreshadow-NG (OS)'\ncheck_CVE_2018_3620()\n{\n\tcve='CVE-2018-3620'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2018_3620_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2018_3620_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2018_3620_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/l1tf\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* Kernel supports PTE inversion: \"\n\t\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\t\tpstatus yellow UNKNOWN \"missing 'strings' tool, please install it\"\n\t\t\tpteinv_supported=-1\n\t\telif [ -n \"$kernel_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_err\"\n\t\t\tpteinv_supported=-1\n\t\telse\n\t\t\tif \"${opt_arch_prefix}strings\" \"$kernel\" | grep -Fq 'PTE Inversion'; then\n\t\t\t\tpstatus green YES \"found in kernel image\"\n\t\t\t\t_debug \"pteinv: found pte inversion evidence in kernel image\"\n\t\t\t\tpteinv_supported=1\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\t\tpteinv_supported=0\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"* PTE inversion enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ -n \"$fullmsg\" ]; then\n\t\t\t\tif echo \"$fullmsg\" | grep -q 'Mitigation: PTE Inversion'; then\n\t\t\t\t\tpstatus green YES\n\t\t\t\t\tpteinv_active=1\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\t\tpteinv_active=0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN \"sysfs interface not available\"\n\t\t\t\tpteinv_active=-1\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ \"$pteinv_supported\" = 1 ]; then\n\t\t\tif [ \"$pteinv_active\" = 1 ] || [ \"$opt_live\" != 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"PTE inversion mitigates the vulnerability\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"Your kernel supports PTE inversion but it doesn't seem to be enabled\"\n\t\t\tfi\n\t\telse\n\t\t\tpvulnstatus $cve VULN \"Your kernel doesn't support PTE inversion, update it\"\n\t\tfi\n\telse\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\tfi\n}\n\ncheck_CVE_2018_3620_bsd()\n{\n\t_info_nol \"* Kernel reserved the memory page at physical address 0x0: \"\n\tif ! kldstat -q -m vmm; then\n\t\tkldload vmm 2>/dev/null && kldload_vmm=1\n\t\t_debug \"attempted to load module vmm, kldload_vmm=$kldload_vmm\"\n\telse\n\t\t_debug \"vmm module already loaded\"\n\tfi\n\tif sysctl hw.vmm.vmx.l1d_flush >/dev/null 2>&1; then\n\t\t# https://security.FreeBSD.org/patches/SA-18:09/l1tf-11.2.patch\n\t\t# this is very difficult to detect that the kernel reserved the 0 page, but this fix\n\t\t# is part of the exact same patch than the other L1TF CVE, so we detect it\n\t\t# and deem it as OK if the other patch is there\n\t\tpstatus green YES\n\t\tbsd_zero_reserved=1\n\telse\n\t\tpstatus yellow NO\n\t\tbsd_zero_reserved=0\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$bsd_zero_reserved\" = 1 ]; then\n\t\t\tpvulnstatus $cve OK \"kernel mitigates the vulnerability\"\n\t\telse\n\t\t\tpvulnstatus $cve VULN \"your kernel needs to be updated\"\n\t\tfi\n\tfi\n}\n\n# L1TF VMM\ncheck_CVE_2018_3646()\n{\n\tcve='CVE-2018-3646'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2018_3646_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2018_3646_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2018_3646_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/l1tf\" '.*' quiet; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tl1d_mode=-1\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\tcheck_has_vmm\n\n\t\t_info \"* Mitigation 1 (KVM)\"\n\t\t_info_nol \"  * EPT is disabled: \"\n\t\tept_disabled=-1\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif ! [ -r /sys/module/kvm_intel/parameters/ept ]; then\n\t\t\t\tpstatus blue N/A \"the kvm_intel module is not loaded\"\n\t\t\telif [ \"$(cat /sys/module/kvm_intel/parameters/ept)\" = N ]; then\n\t\t\t\tpstatus green YES\n\t\t\t\tept_disabled=1\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\t_info \"* Mitigation 2\"\n\t\t_info_nol \"  * L1D flush is supported by kernel: \"\n\t\tif [ \"$opt_live\" = 1 ] && grep -qw flush_l1d \"$procfs/cpuinfo\"; then\n\t\t\tl1d_kernel=\"found flush_l1d in $procfs/cpuinfo\"\n\t\tfi\n\t\tif [ -z \"$l1d_kernel\" ]; then\n\t\t\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\t\t\tl1d_kernel_err=\"missing '${opt_arch_prefix}strings' tool, please install it, usually it's in the binutils package\"\n\t\t\telif [ -n \"$kernel_err\" ]; then\n\t\t\t\tl1d_kernel_err=\"$kernel_err\"\n\t\t\telif \"${opt_arch_prefix}strings\" \"$kernel\" | grep -qw flush_l1d; then\n\t\t\t\tl1d_kernel='found flush_l1d in kernel image'\n\t\t\tfi\n\t\tfi\n\n\t\tif [ -n \"$l1d_kernel\" ]; then\n\t\t\tpstatus green YES \"$l1d_kernel\"\n\t\telif [ -n \"$l1d_kernel_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$l1d_kernel_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"  * L1D flush enabled: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ -n \"$fullmsg\" ]; then\n\t\t\t\t# vanilla: VMX: $l1dstatus, SMT $smtstatus\n\t\t\t\t# Red Hat: VMX: SMT $smtstatus, L1D $l1dstatus\n\t\t\t\t# $l1dstatus is one of (auto|vulnerable|conditional cache flushes|cache flushes|EPT disabled|flush not necessary)\n\t\t\t\t# $smtstatus is one of (vulnerable|disabled)\n\t\t\t\t# can also just be \"Not affected\"\n\t\t\t\tif echo \"$fullmsg\" | grep -Eq -e 'Not affected' -e '(VMX:|L1D) (EPT disabled|vulnerable|flush not necessary)'; then\n\t\t\t\t\tl1d_mode=0\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\telif echo \"$fullmsg\" | grep -Eq '(VMX:|L1D) conditional cache flushes'; then\n\t\t\t\t\tl1d_mode=1\n\t\t\t\t\tpstatus green YES \"conditional flushes\"\n\t\t\t\telif echo \"$fullmsg\" | grep -Eq '(VMX:|L1D) cache flushes'; then\n\t\t\t\t\tl1d_mode=2\n\t\t\t\t\tpstatus green YES \"unconditional flushes\"\n\t\t\t\telse\n\t\t\t\t\tif is_xen_dom0; then\n\t\t\t\t\t\tl1d_xen_hardware=$(xl dmesg | grep 'Hardware features:' | grep 'L1D_FLUSH' | head -1)\n\t\t\t\t\t\tl1d_xen_hypervisor=$(xl dmesg | grep 'Xen settings:' | grep 'L1D_FLUSH' | head -1)\n\t\t\t\t\t\tl1d_xen_pv_domU=$(xl dmesg | grep 'PV L1TF shadowing:' | grep 'DomU enabled' | head -1)\n\n\t\t\t\t\t\tif [ -n \"$l1d_xen_hardware\" ] && [ -n \"$l1d_xen_hypervisor\" ] && [ -n \"$l1d_xen_pv_domU\" ]; then\n\t\t\t\t\t\t\tl1d_mode=5\n\t\t\t\t\t\t\tpstatus green YES \"for XEN guests\"\n\t\t\t\t\t\telif [ -n \"$l1d_xen_hardware\" ] && [ -n \"$l1d_xen_hypervisor\" ]; then\n\t\t\t\t\t\t\tl1d_mode=4\n\t\t\t\t\t\t\tpstatus yellow YES \"for XEN guests (HVM only)\"\n\t\t\t\t\t\telif [ -n \"$l1d_xen_pv_domU\" ]; then\n\t\t\t\t\t\t\tl1d_mode=3\n\t\t\t\t\t\t\tpstatus yellow YES \"for XEN guests (PV only)\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tl1d_mode=0\n\t\t\t\t\t\t\tpstatus yellow NO \"for XEN guests\"\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\tl1d_mode=-1\n\t\t\t\t\t\tpstatus yellow UNKNOWN \"unrecognized mode\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tl1d_mode=-1\n\t\t\t\tpstatus yellow UNKNOWN \"can't find or read /sys/devices/system/cpu/vulnerabilities/l1tf\"\n\t\t\tfi\n\t\telse\n\t\t\tl1d_mode=-1\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\t_info_nol \"  * Hardware-backed L1D flush supported: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif grep -qw flush_l1d \"$procfs/cpuinfo\" || [ -n \"$l1d_xen_hardware\" ]; then\n\t\t\t\tpstatus green YES \"performance impact of the mitigation will be greatly reduced\"\n\t\t\telse\n\t\t\t\tpstatus blue NO \"flush will be done in software, this is slower\"\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\t_info_nol \"  * Hyper-Threading (SMT) is enabled: \"\n\t\tis_cpu_smt_enabled; smt_enabled=$?\n\t\tif [ \"$smt_enabled\" = 0 ]; then\n\t\t\tpstatus yellow YES\n\t\telif [ \"$smt_enabled\" = 1 ]; then\n\t\t\tpstatus green NO\n\t\telse\n\t\t\tpstatus yellow UNKNOWN\n\t\tfi\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\t\tl1d_mode=-1\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ \"$fullmsg\" = \"Not affected\" ]; then\n\t\t# just in case a very recent kernel knows better than we do\n\t\tpvulnstatus $cve OK \"your kernel reported your CPU model as not affected\"\n\telif [ \"$has_vmm\" = 0 ]; then\n\t\tpvulnstatus $cve OK \"this system is not running a hypervisor\"\n\telse\n\t\tif [ \"$ept_disabled\" = 1 ]; then\n\t\t\tpvulnstatus $cve OK \"EPT is disabled which mitigates the vulnerability\"\n\t\telif [ \"$opt_paranoid\" = 0 ]; then\n\t\t\tif [ \"$l1d_mode\" -ge 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"L1D flushing is enabled and mitigates the vulnerability\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"disable EPT or enable L1D flushing to mitigate the vulnerability\"\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$l1d_mode\" -ge 2 ]; then\n\t\t\t\tif [ \"$smt_enabled\" = 1 ]; then\n\t\t\t\t\tpvulnstatus $cve OK \"L1D unconditional flushing and Hyper-Threading disabled are mitigating the vulnerability\"\n\t\t\t\telse\n\t\t\t\t\tpvulnstatus $cve VULN \"Hyper-Threading must be disabled to fully mitigate the vulnerability\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ \"$smt_enabled\" = 1 ]; then\n\t\t\t\t\tpvulnstatus $cve VULN \"L1D unconditional flushing should be enabled to fully mitigate the vulnerability\"\n\t\t\t\telse\n\t\t\t\t\tpvulnstatus $cve VULN \"enable L1D unconditional flushing and disable Hyper-Threading to fully mitigate the vulnerability\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\tif [ $l1d_mode -gt 3 ]; then\n\t\t\t_warn\n\t\t\t_warn \"This host is a Xen Dom0. Please make sure that you are running your DomUs\"\n\t\t\t_warn \"with a kernel which contains CVE-2018-3646 mitigations.\"\n\t\t\t_warn\n\t\t\t_warn \"See https://www.suse.com/support/kb/doc/?id=7023078 and XSA-273 for details.\"\n\t\tfi\n\tfi\n}\n\ncheck_CVE_2018_3646_bsd()\n{\n\t_info_nol \"* Kernel supports L1D flushing: \"\n\tif sysctl hw.vmm.vmx.l1d_flush >/dev/null 2>&1; then\n\t\tpstatus green YES\n\t\tkernel_l1d_supported=1\n\telse\n\t\tpstatus yellow NO\n\t\tkernel_l1d_supported=0\n\tfi\n\n\t_info_nol \"* L1D flushing is enabled: \"\n\tkernel_l1d_enabled=$(sysctl -n hw.vmm.vmx.l1d_flush 2>/dev/null)\n\tcase \"$kernel_l1d_enabled\" in\n\t\t0) pstatus yellow NO;;\n\t\t1) pstatus green YES;;\n\t\t\"\") pstatus yellow NO;;\n\t\t*) pstatus yellow UNKNOWN;;\n\tesac\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$kernel_l1d_enabled\" = 1 ]; then\n\t\t\tpvulnstatus $cve OK \"L1D flushing mitigates the vulnerability\"\n\t\telif [ \"$kernel_l1d_supported\" = 1 ]; then\n\t\t\tpvulnstatus $cve VULN \"L1D flushing is supported by your kernel but is disabled\"\n\t\telse\n\t\t\tpvulnstatus $cve VULN \"your kernel needs to be updated\"\n\t\tfi\n\tfi\n}\n\n###################\n# MSBDS SECTION\n\n# Microarchitectural Store Buffer Data Sampling\ncheck_CVE_2018_12126()\n{\n\tcve='CVE-2018-12126'\n\tcheck_mds $cve\n}\n\n###################\n# MFBDS SECTION\n\n# Microarchitectural Fill Buffer Data Sampling\ncheck_CVE_2018_12130()\n{\n\tcve='CVE-2018-12130'\n\tcheck_mds $cve\n}\n\n###################\n# MLPDS SECTION\n\n# Microarchitectural Load Port Data Sampling\ncheck_CVE_2018_12127()\n{\n\tcve='CVE-2018-12127'\n\tcheck_mds $cve\n}\n\n###################\n# MDSUM SECTION\n\n# Microarchitectural Data Sampling Uncacheable Memory \ncheck_CVE_2019_11091()\n{\n\tcve='CVE-2019-11091'\n\tcheck_mds $cve\n}\n\n# Microarchitectural Data Sampling\ncheck_mds()\n{\n\tcve=$1\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_mds_linux \"$cve\"\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_mds_bsd \"$cve\"\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_mds_bsd()\n{\n\t_info_nol \"* Kernel supports using MD_CLEAR mitigation: \"\n\tif [ \"$opt_live\" = 1 ]; then\n\t\tif sysctl hw.mds_disable >/dev/null 2>&1; then\n\t\t\tpstatus green YES\n\t\t\tkernel_md_clear=1\n\t\telse\n\t\t\tpstatus yellow NO\n\t\t\tkernel_md_clear=0\n\t\tfi\n\telse\n\t\tif grep -Fq hw.mds_disable $opt_kernel; then\n\t\t\tpstatus green YES\n\t\t\tkernel_md_clear=1\n\t\telse\n\t\t\tkernel_md_clear=0\n\t\t\tpstatus yellow NO\n\t\tfi\n\tfi\n\n\t_info_nol \"* CPU Hyper-Threading (SMT) is disabled: \"\n\tif sysctl machdep.hyperthreading_allowed >/dev/null 2>&1; then\n\t\tkernel_smt_allowed=$(sysctl -n machdep.hyperthreading_allowed 2>/dev/null)\n\t\tif [ \"$kernel_smt_allowed\" = 1 ]; then\n\t\t\tpstatus yellow NO\n\t\telse\n\t\t\tpstatus green YES\n\t\tfi\n\telse\n\t\tpstatus yellow UNKNOWN \"sysctl machdep.hyperthreading_allowed doesn't exist\"\n\tfi\n\n\t_info_nol \"* Kernel mitigation is enabled: \"\n\tif [ \"$kernel_md_clear\" = 1 ]; then\n\t\tkernel_mds_enabled=$(sysctl -n hw.mds_disable 2>/dev/null)\n\telse\n\t\tkernel_mds_enabled=0\n\tfi\n\tcase \"$kernel_mds_enabled\" in\n\t\t0) pstatus yellow NO;;\n\t\t1) pstatus green YES \"with microcode support\";;\n\t\t2) pstatus green YES \"software-only support (SLOW)\";;\n\t\t3) pstatus green YES;;\n\t\t*) pstatus yellow UNKNOWN \"unknown value $kernel_mds_enabled\"\n\tesac\n\n\t_info_nol \"* Kernel mitigation is active: \"\n\tif [ \"$kernel_md_clear\" = 1 ]; then\n\t\tkernel_mds_state=$(sysctl -n hw.mds_disable_state 2>/dev/null)\n\telse\n\t\tkernel_mds_state=inactive\n\tfi\n\t# https://github.com/freebsd/freebsd/blob/master/sys/x86/x86/cpu_machdep.c#L953\n\tcase \"$kernel_mds_state\" in\n\t\tinactive)  pstatus yellow NO;;\n\t\tVERW)      pstatus green YES \"with microcode support\";;\n\t\tsoftware*) pstatus green YES \"software-only support (SLOW)\";;\n\t\t*)         pstatus yellow UNKNOWN\n\tesac\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$cpuid_md_clear\" = 1 ]; then\n\t\t\tif [ \"$kernel_md_clear\" = 1 ]; then\n\t\t\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t\t\t# mitigation must also be enabled\n\t\t\t\t\tif [ \"$kernel_mds_enabled\" -ge 1 ]; then\n\t\t\t\t\t\tif [ \"$opt_paranoid\" != 1 ] || [ \"$kernel_smt_allowed\" = 0 ]; then\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" OK \"Your microcode and kernel are both up to date for this mitigation, and mitigation is enabled\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode and kernel are both up to date for this mitigation, but you must disable SMT (Hyper-Threading) for a complete mitigation\"\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode and kernel are both up to date for this mitigation, but the mitigation is not active\"\n\t\t\t\t\t\texplain \"To enable mitigation, run \\`sysctl hw.mds_disable=1'. To make this change persistent across reboots, you can add 'hw.mds_disable=1' to /etc/sysctl.conf.\"\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tpvulnstatus \"$cve\" OK \"Your microcode and kernel are both up to date for this mitigation\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode supports mitigation, but your kernel doesn't, upgrade it to mitigate the vulnerability\"\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$kernel_md_clear\" = 1 ]; then\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your kernel supports mitigation, but your CPU microcode also needs to be updated to mitigate the vulnerability\"\n\t\t\telse\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Neither your kernel or your microcode support mitigation, upgrade both to mitigate the vulnerability\"\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\ncheck_mds_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/mds\" '^[^;]+'; then\n\t\tsys_interface_available=1\n\tfi\n\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* Kernel supports using MD_CLEAR mitigation: \"\n\t\tkernel_md_clear=''\n\t\tkernel_md_clear_can_tell=1\n\t\tif [ \"$opt_live\" = 1 ] && grep ^flags \"$procfs/cpuinfo\" | grep -qw md_clear; then\n\t\t\tkernel_md_clear=\"md_clear found in $procfs/cpuinfo\"\n\t\t\tpstatus green YES \"$kernel_md_clear\"\n\t\tfi\n\t\tif [ -z \"$kernel_md_clear\" ]; then\n\t\t\tif ! command -v \"${opt_arch_prefix}strings\" >/dev/null 2>&1; then\n\t\t\t\tkernel_md_clear_can_tell=0\n\t\t\telif [ -n \"$kernel_err\" ]; then\n\t\t\t\tkernel_md_clear_can_tell=0\n\t\t\telif \"${opt_arch_prefix}strings\" \"$kernel\" | grep -q 'Clear CPU buffers'; then\n\t\t\t\t_debug \"md_clear: found 'Clear CPU buffers' string in kernel image\"\n\t\t\t\tkernel_md_clear='found md_clear implementation evidence in kernel image'\n\t\t\t\tpstatus green YES \"$kernel_md_clear\"\n\t\t\tfi\n\t\tfi\n\t\tif [ -z \"$kernel_md_clear\" ]; then\n\t\t\tif [ \"$kernel_md_clear_can_tell\" = 1 ]; then\n\t\t\t\tpstatus yellow NO\n\t\t\telse\n\t\t\t\tpstatus yellow UNKNOWN\n\t\t\tfi\n\t\tfi\n\n\t\tif [ \"$opt_live\" = 1 ] && [ \"$sys_interface_available\" = 1 ]; then\n\t\t\t_info_nol \"* Kernel mitigation is enabled and active: \"\n\t\t\tif echo \"$fullmsg\" | grep -qi ^mitigation; then\n\t\t\t\tmds_mitigated=1\n\t\t\t\tpstatus green YES\n\t\t\telse\n\t\t\t\tmds_mitigated=0\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\t\t_info_nol \"* SMT is either mitigated or disabled: \"\n\t\t\tif echo \"$fullmsg\" | grep -Eq 'SMT (disabled|mitigated)'; then\n\t\t\t\tmds_smt_mitigated=1\n\t\t\t\tpstatus green YES\n\t\t\telse\n\t\t\t\tmds_smt_mitigated=0\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\tfi\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t\t# compute mystatus and mymsg from our own logic\n\t\t\tif [ \"$cpuid_md_clear\" = 1 ]; then\n\t\t\t\tif [ -n \"$kernel_md_clear\" ]; then\n\t\t\t\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t\t\t\t# mitigation must also be enabled\n\t\t\t\t\t\tif [ \"$mds_mitigated\" = 1 ]; then\n\t\t\t\t\t\t\tif [ \"$opt_paranoid\" != 1 ] || [ \"$mds_smt_mitigated\" = 1 ]; then\n\t\t\t\t\t\t\t\tmystatus=OK\n\t\t\t\t\t\t\t\tmymsg=\"Your microcode and kernel are both up to date for this mitigation, and mitigation is enabled\"\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmystatus=VULN\n\t\t\t\t\t\t\t\tmymsg=\"Your microcode and kernel are both up to date for this mitigation, but you must disable SMT (Hyper-Threading) for a complete mitigation\"\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmystatus=VULN\n\t\t\t\t\t\t\tmymsg=\"Your microcode and kernel are both up to date for this mitigation, but the mitigation is not active\"\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\tmystatus=OK\n\t\t\t\t\t\tmymsg=\"Your microcode and kernel are both up to date for this mitigation\"\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tmystatus=VULN\n\t\t\t\t\tmymsg=\"Your microcode supports mitigation, but your kernel doesn't, upgrade it to mitigate the vulnerability\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ -n \"$kernel_md_clear\" ]; then\n\t\t\t\t\tmystatus=VULN\n\t\t\t\t\tmymsg=\"Your kernel supports mitigation, but your CPU microcode also needs to be updated to mitigate the vulnerability\"\n\t\t\t\telse\n\t\t\t\t\tmystatus=VULN\n\t\t\t\t\tmymsg=\"Neither your kernel or your microcode support mitigation, upgrade both to mitigate the vulnerability\"\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\t# sysfs only: return the status/msg we got\n\t\t\tpvulnstatus \"$cve\" \"$status\" \"$fullmsg\"\n\t\t\treturn\n\t\tfi\n\n\t\t# if we didn't get a msg+status from sysfs, use ours\n\t\tif [ -z \"$msg\" ]; then\n\t\t\tpvulnstatus \"$cve\" \"$mystatus\" \"$mymsg\"\n\t\telif [ \"$opt_paranoid\" = 1 ]; then\n\t\t\t# if paranoid mode is enabled, we now that we won't agree on status, so take ours\n\t\t\tpvulnstatus \"$cve\" \"$mystatus\" \"$mymsg\"\n\t\telif [ \"$status\" = \"$mystatus\" ]; then\n\t\t\t# if we agree on status, we'll print the common status and our message (more detailed than the sysfs one)\n\t\t\tpvulnstatus \"$cve\" \"$status\" \"$mymsg\"\n\t\telse\n\t\t\t# if we don't agree on status, maybe our logic is flawed due to a new kernel/mitigation? use the one from sysfs\n\t\t\tpvulnstatus \"$cve\" \"$status\" \"$msg\"\n\t\tfi\n\tfi\n}\n\n\n###################\n# TAA SECTION\n\n# Transactional Synchronization Extension (TSX) Asynchronous Abort\ncheck_CVE_2019_11135()\n{\n\tcve='CVE-2019-11135'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2019_11135_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2019_11135_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2019_11135_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/tsx_async_abort\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* TAA mitigation is supported by kernel: \"\n\t\tkernel_taa=''\n\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\tkernel_taa_err=\"$kernel_err\"\n\t\telif grep -q 'tsx_async_abort' \"$kernel\"; then\n\t\t\tkernel_taa=\"found tsx_async_abort in kernel image\"\n\t\tfi\n\t\tif [ -n \"$kernel_taa\" ]; then\n\t\t\tpstatus green YES \"$kernel_taa\"\n\t\telif [ -n \"$kernel_taa_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_taa_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"* TAA mitigation enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ -n \"$fullmsg\" ]; then\n\t\t\t\tif echo \"$fullmsg\" | grep -qE '^Mitigation'; then\n\t\t\t\t\tpstatus green YES \"$fullmsg\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpstatus yellow NO \"tsx_async_abort not found in sysfs hierarchy\"\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old\n\t\t\tpvulnstatus $cve VULN \"Your kernel doesn't support TAA mitigation, update it\"\n\t\telse\n\t\t\tif [ -n \"$kernel_taa\" ]; then\n\t\t\t\tpvulnstatus $cve OK \"Your kernel supports TAA mitigation\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"Your kernel doesn't support TAA mitigation, update it\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\tif [ \"$opt_paranoid\" = 1 ]; then\n\t\t\t# in paranoid mode, TSX or SMT enabled are not OK, even if TAA is mitigated\n\t\t\tif ! echo \"$fullmsg\" | grep -qF 'TSX disabled'; then\n\t\t\t\tpvulnstatus $cve VULN \"TSX must be disabled for full mitigation\"\n\t\t\telif echo \"$fullmsg\" | grep -qF 'SMT vulnerable'; then\n\t\t\t\tpvulnstatus $cve VULN \"SMT (HyperThreading) must be disabled for full mitigation\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\t\t\tfi\n\t\telse\n\t\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\t\tfi\n\tfi\n}\n\ncheck_CVE_2019_11135_bsd()\n{\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tpvulnstatus \"$cve\" UNK \"your CPU is affected, but mitigation detection has not yet been implemented for BSD in this script\"\n\tfi\n}\n\n#######################\n# iTLB Multihit section\n\ncheck_CVE_2018_12207()\n{\n\tcve='CVE-2018-12207'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2018_12207_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2018_12207_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2018_12207_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/itlb_multihit\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\tcheck_has_vmm\n\n\t\t_info_nol \"* iTLB Multihit mitigation is supported by kernel: \"\n\t\tkernel_itlbmh=''\n\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\tkernel_itlbmh_err=\"$kernel_err\"\n\t\t# commit 5219505fcbb640e273a0d51c19c38de0100ec5a9\n\t\telif grep -q 'itlb_multihit' \"$kernel\"; then\n\t\t\tkernel_itlbmh=\"found itlb_multihit in kernel image\"\n\t\tfi\n\t\tif [ -n \"$kernel_itlbmh\" ]; then\n\t\t\tpstatus green YES \"$kernel_itlbmh\"\n\t\telif [ -n \"$kernel_itlbmh_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_itlbmh_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"* iTLB Multihit mitigation enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ -n \"$fullmsg\" ]; then\n\t\t\t\tif echo \"$fullmsg\" | grep -qF 'Mitigation'; then\n\t\t\t\t\tpstatus green YES \"$fullmsg\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpstatus yellow NO \"itlb_multihit not found in sysfs hierarchy\"\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ \"$has_vmm\" = 0 ]; then\n\t\tpvulnstatus \"$cve\" OK \"this system is not running a hypervisor\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old\n\t\t\tpvulnstatus $cve VULN \"Your kernel doesn't support iTLB Multihit mitigation, update it\"\n\t\telse\n\t\t\tif [ -n \"$kernel_itlbmh\" ]; then\n\t\t\t\tpvulnstatus $cve OK \"Your kernel supports iTLB Multihit mitigation\"\n\t\t\telse\n\t\t\t\tpvulnstatus $cve VULN \"Your kernel doesn't support iTLB Multihit mitigation, update it\"\n\t\t\tfi\n\t\tfi\n\telse\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\tfi\n}\n\ncheck_CVE_2018_12207_bsd()\n{\n\t_info_nol \"* Kernel supports disabling superpages for executable mappings under EPT: \"\n\tkernel_2m_x_ept=$(sysctl -n vm.pmap.allow_2m_x_ept 2>/dev/null)\n\tif [ -z \"$kernel_2m_x_ept\" ]; then\n\t\tpstatus yellow NO\n\telse\n\t\tpstatus green YES\n\tfi\n\n\t_info_nol \"* Superpages are disabled for executable mappings under EPT: \"\n\tif [ \"$kernel_2m_x_ept\" = 0 ]; then\n\t\tpstatus green YES\n\telse\n\t\tpstatus yellow NO\n\tfi\n\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$kernel_2m_x_ept\" ]; then\n\t\tpvulnstatus $cve VULN \"Your kernel doesn't support mitigating this CVE, you should update it\"\n\telif [ \"$kernel_2m_x_ept\" != 0 ]; then\n\t\tpvulnstatus $cve VULN \"Your kernel supports mitigating this CVE, but the mitigation is disabled\"\n\t\texplain \"To enable the mitigation, use \\`sysctl vm.pmap.allow_2m_x_ept=0\\`\"\n\telse\n\t\tpvulnstatus $cve OK \"Your kernel has support for mitigation and the mitigation is enabled\"\n\tfi\n}\n\n###################\n# SRBDS SECTION\n\n# Special Register Buffer Data Sampling (SRBDS)\ncheck_CVE_2020_0543()\n{\n\tcve='CVE-2020-0543'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2020_0543_linux\n\telif echo \"$os\" | grep -q BSD; then\n\t\tcheck_CVE_2020_0543_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2020_0543_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/srbds\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* SRBDS mitigation control is supported by the kernel: \"\n\t\tkernel_srbds=''\n\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\tkernel_srbds_err=\"$kernel_err\"\n\t\telif grep -q 'Dependent on hypervisor' \"$kernel\"; then\n\t\t\tkernel_srbds=\"found SRBDS implementation evidence in kernel image. Your kernel is up to date for SRBDS mitigation\"\n\t\tfi\n\t\tif [ -n \"$kernel_srbds\" ]; then\n\t\t\tpstatus green YES \"$kernel_srbds\"\n\t\telif [ -n \"$kernel_srbds_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_srbds_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\t\t_info_nol \"* SRBDS mitigation control is enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ -n \"$fullmsg\" ]; then\n\t\t\t\tif echo \"$fullmsg\" | grep -qE '^Mitigation'; then\n\t\t\t\t\tpstatus green YES \"$fullmsg\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tpstatus yellow NO \"SRBDS not found in sysfs hierarchy\"\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t\tif [ \"$cpuid_srbds\" = 1 ]; then\n\t\t\t\t# SRBDS mitigation control exists\n\t\t\t\tif [ \"$srbds_on\" = 1 ]; then\n\t\t\t\t\t# SRBDS mitigation control is enabled\n\t\t\t\t\tif [ -z \"$msg\" ]; then\n\t\t\t\t\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\t\t\t\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t\t\t\t\t# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" OK \"Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated\"\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\tif [ -n \"$kernel_srbds\" ]; then\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" OK \"Your microcode and kernel are both up to date for SRBDS mitigation control. Mitigation is enabled\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" OK \"Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated\"\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telif [ \"$srbds_on\" = 0 ]; then\n\t\t\t\t\t# SRBDS mitigation control is disabled\n\t\t\t\t\tif [ -z \"$msg\" ]; then\n\t\t\t\t\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t\t\t\t\t# if we're in live mode and $msg is empty, sysfs file is not there so kernel is too old\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated. Mitigation is disabled\"\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\tif [ -n \"$kernel_srbds\" ]; then\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode and kernel are both up to date for SRBDS mitigation control. Mitigation is disabled\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode is up to date for SRBDS mitigation control. The kernel needs to be updated. Mitigation is disabled\"\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t# rdmsr: CPU 0 cannot read MSR 0x00000123\n\t\t\t\t\tpvulnstatus \"$cve\" UNK \"Not able to enumerate MSR for SRBDS mitigation control\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t# [ $cpuid_srbds != 1 ]\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your CPU microcode may need to be updated to mitigate the vulnerability\"\n\t\t\tfi\n\t\telse\n\t\t\t# sysfs only: return the status/msg we got\n\t\t\tpvulnstatus \"$cve\" \"$status\" \"$fullmsg\"\n\t\t\treturn\n\t\tfi\n\tfi\n}\n\ncheck_CVE_2020_0543_bsd()\n{\n\tif ! is_cpu_affected \"$cve\"; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus $cve OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\tpvulnstatus \"$cve\" UNK \"your CPU is affected, but mitigation detection has not yet been implemented for BSD in this script\"\n\tfi\n}\n\n####################\n# Zenbleed section\n\ncheck_CVE_2023_20593()\n{\n\tcve='CVE-2023-20593'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]; then\n\t\tcheck_CVE_2023_20593_linux\n\t#elif echo \"$os\" | grep -q BSD; then\n\t#\tcheck_CVE_2023_20593_bsd\n\telse\n\t\t_warn \"Unsupported OS ($os)\"\n\tfi\n}\n\ncheck_CVE_2023_20593_linux()\n{\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* Zenbleed mitigation is supported by kernel: \"\n\t\tkernel_zenbleed=''\n\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\tkernel_zenbleed_err=\"$kernel_err\"\n\t\t# commit 522b1d69219d8f083173819fde04f994aa051a98\n\t\telif grep -q 'Zenbleed:' \"$kernel\"; then\n\t\t\tkernel_zenbleed=\"found zenbleed message in kernel image\"\n\t\tfi\n\t\tif [ -n \"$kernel_zenbleed\" ]; then\n\t\t\tpstatus green YES \"$kernel_zenbleed\"\n\t\telif [ -n \"$kernel_zenbleed_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_zenbleed_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\t\t_info_nol \"* Zenbleed kernel mitigation enabled and active: \"\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\t# read the DE_CFG MSR, we want to check the 9th bit\n\t\t\t# don't do it on non-Zen2 AMD CPUs or later, aka Family 17h,\n\t\t\t# as the behavior could be unknown on others\n\t\t\tif is_amd && [ \"$cpu_family\" -ge $((0x17)) ]; then\n\t\t\t\tread_msr 0xc0011029; ret=$?\n\t\t\t\tif [ $ret = $READ_MSR_RET_OK ]; then\n\t\t\t\t\tif [ $(( read_msr_value >> 9 & 1 )) -eq 1 ]; then\n\t\t\t\t\t\tpstatus green YES \"FP_BACKUP_FIX bit set in DE_CFG\"\n\t\t\t\t\t\tfp_backup_fix=1\n\t\t\t\t\telse\n\t\t\t\t\t\tpstatus yellow NO \"FP_BACKUP_FIX is cleared in DE_CFG\"\n\t\t\t\t\t\tfp_backup_fix=0\n\t\t\t\t\tfi\n\t\t\t\telif [ $ret = $READ_MSR_RET_KO ]; then\n\t\t\t\t\tpstatus yellow UNKNOWN \"Couldn't read the DE_CFG MSR\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow UNKNOWN \"$read_msr_msg\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tfp_backup_fix=0\n\t\t\t\tpstatus blue N/A \"CPU is incompatible\"\n\t\t\tfi\n\t\telse\n\t\t\tpstatus blue N/A \"not testable in offline mode\"\n\t\tfi\n\n\t\t_info_nol \"* Zenbleed mitigation is supported by CPU microcode: \"\n\t\thas_zenbleed_fixed_firmware; ret=$?\n\t\tif [ $ret -eq 0 ]; then\n\t\t\tpstatus green YES\n\t\t\tcpu_ucode_zenbleed=1\n\t\telif [ $ret -eq 1 ]; then\n\t\t\tpstatus yellow NO\n\t\t\tcpu_ucode_zenbleed=2\n\t\telse\n\t\t\tpstatus yellow UNKNOWN\n\t\t\tcpu_ucode_zenbleed=3\n\t\tfi\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tzenbleed_print_vuln=0\n\t\tif [ \"$opt_live\" = 1 ]; then\n\t\t\tif [ \"$fp_backup_fix\" = 1 ] && [ \"$cpu_ucode_zenbleed\" = 1 ]; then\n\t\t\t\t# this should never happen, but if it does, it's interesting to know\n\t\t\t\tpvulnstatus $cve OK \"Both your CPU microcode and kernel are mitigating Zenbleed\"\n\t\t\telif [ \"$cpu_ucode_zenbleed\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"Your CPU microcode mitigates Zenbleed\"\n\t\t\telif [ \"$fp_backup_fix\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"Your kernel mitigates Zenbleed\"\n\t\t\telse\n\t\t\t\tzenbleed_print_vuln=1\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$cpu_ucode_zenbleed\" = 1 ]; then\n\t\t\t\tpvulnstatus $cve OK \"Your CPU microcode mitigates Zenbleed\"\n\t\t\telif [ -n \"$kernel_zenbleed\" ]; then\n\t\t\t\tpvulnstatus $cve OK \"Your kernel mitigates Zenbleed\"\n\t\t\telse\n\t\t\t\tzenbleed_print_vuln=1\n\t\t\tfi\n\t\tfi\n\t\tif [ \"$zenbleed_print_vuln\" = 1 ]; then\n\t\t\tpvulnstatus $cve VULN \"Your kernel is too old to mitigate Zenbleed and your CPU microcode doesn't mitigate it either\"\n\t\t\texplain \"Your CPU vendor may have a new microcode for your CPU model that mitigates this issue (refer to the hardware section above).\\n \" \\\n\"Otherwise, the Linux kernel is able to mitigate this issue regardless of the microcode version you have, but in this case\\n \" \\\n\"your kernel is too old to support this, your Linux distribution vendor might have a more recent version you should upgrade to.\\n \" \\\n\"Note that either having an up to date microcode OR an up to date kernel is enough to mitigate this issue.\\n \" \\\n\"To manually mitigate the issue right now, you may use the following command: \\`wrmsr -a 0xc0011029 \\$((\\$(rdmsr -c 0xc0011029) | (1<<9)))\\`,\\n \" \\\n\"however note that this manual mitigation will only be active until the next reboot.\"\n\t\tfi\n\t\tunset zenbleed_print_vuln\n\telse\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\tfi\n}\n\n#########################\n# Downfall section\n\ncheck_CVE_2022_40982() {\n\tcve='CVE-2022-40982'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]\n\tthen\n\t\tcheck_CVE_2022_40982_linux\n\telse\n\t\t_warn \"Unsupported OS ($os).\"\n\tfi\n}\n\ncheck_CVE_2022_40982_linux() {\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/gather_data_sampling\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* GDS is mitigated by microcode: \"\n\t\tif [ \"$capabilities_gds_ctrl\" = 1 ] && [ \"$mcu_opt_ctrl_gds_mitg_dis\" = 0 ]; then\n\t\t\tpstatus green OK \"microcode mitigation is supported and enabled\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\t\t_info_nol \"* Kernel supports software mitigation by disabling AVX: \"\n\t\tif [ -n \"$kernel_err\" ]; then\t\n\t\t\tkernel_gds_err=\"$kernel_err\"\n\t\telif grep -q 'gather_data_sampling' \"$kernel\"; then\n\t\t\tkernel_gds=\"found gather_data_sampling in kernel image\"\n\t\tfi\n\t\tif [ -n \"$kernel_gds\" ]; then\n\t\t\tpstatus green YES \"$kernel_gds\"\n\t\telif [ -n \"$kernel_gds_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_gds_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\tif [ -n \"$kernel_gds\" ]; then\n\t\t\t_info_nol \"* Kernel has disabled AVX as a mitigation: \"\n\n\t\t\t# Check dmesg message to see whether AVX has been disabled\n\t\t\tdmesg_grep 'Microcode update needed! Disabling AVX as mitigation'; dmesgret=$?\n\t\t\tif [ $dmesgret -eq 0 ]; then\n\t\t\t\tkernel_avx_disabled=\"AVX disabled by the kernel (dmesg)\"\n\t\t\t\tpstatus green YES \"$kernel_avx_disabled\"\n\t\t\telif [ \"$has_avx2\" = 0 ]; then\n\t\t\t\t# Find out by ourselves\n\t\t\t\t# cpuinfo says we don't have AVX2, query\n\t\t\t\t# the CPU directly about AVX2 support\n\t\t\t\tread_cpuid 0x7 0x0 $EBX 5 1 1; ret=$?\n\t\t\t\tif [ $ret -eq $READ_CPUID_RET_OK ]; then\n\t\t\t\t\tkernel_avx_disabled=\"AVX disabled by the kernel (cpuid)\"\n\t\t\t\t\tpstatus green YES \"$kernel_avx_disabled\"\n\t\t\t\telif [ $ret -eq $READ_CPUID_RET_KO ]; then\n\t\t\t\t\tpstatus yellow NO \"CPU doesn't support AVX\"\n\t\t\t\telif [ $dmesgret -eq 2 ]; then\n\t\t\t\t\tpstatus yellow UNKNOWN \"dmesg truncated, can't tell whether mitigation is active, please reboot and relaunch this script\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow UNKNOWN \"No sign of mitigation in dmesg and couldn't read cpuid info\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t\tpstatus yellow NO \"AVX support is enabled\"\n\t\t\tfi\n\t\tfi\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, rely on our own test\n\t\tif [ \"$capabilities_gds_ctrl\" = 1 ] && [ \"$mcu_opt_ctrl_gds_mitg_dis\" = 0 ]; then\n\t\t\tpvulnstatus $cve OK \"Your microcode is up to date and mitigation is enabled\"\n\t\telif [ \"$capabilities_gds_ctrl\" = 1 ] && [ \"$mcu_opt_ctrl_gds_mitg_dis\" = 1 ]; then\n\t\t\tpvulnstatus $cve VULN \"Your microcode is up to date but mitigation is disabled\"\n\t\telif [ -z \"$kernel_gds\" ]; then\n\t\t\tpvulnstatus $cve VULN \"Your microcode doesn't mitigate the vulnerability, and your kernel doesn't support mitigation\"\n\t\telif [ -z \"$kernel_avx_disabled\" ]; then\n\t\t\tpvulnstatus $cve VULN \"Your microcode doesn't mitigate the vulnerability, your kernel support the mitigation but the script did not detect AVX as disabled by the kernel\"\n\t\telse\n\t\t\tpvulnstatus $cve OK \"Your microcode doesn't mitigate the vulnerability, but your kernel has disabled AVX support\"\n\t\tfi\n\telse\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\tfi\n}\n\n#######################\n# Inception section\n\ncheck_CVE_2023_20569() {\n\tcve='CVE-2023-20569'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]\n\tthen\n\t\tcheck_CVE_2023_20569_linux\n\telse\n\t\t_warn \"Unsupported OS ($os).\"\n\tfi\n}\n\ncheck_CVE_2023_20569_linux() {\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\n\tif sys_interface_check \"/sys/devices/system/cpu/vulnerabilities/spec_rstack_overflow\"; then\n\t\t# this kernel has the /sys interface, trust it over everything\n\t\tsys_interface_available=1\n\tfi\n\n\tif [ \"$opt_sysfs_only\" != 1 ]; then\n\t\t_info_nol \"* Kernel supports mitigation: \"\n\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\tkernel_sro_err=\"$kernel_err\"\n\t\telif grep -q 'spec_rstack_overflow' \"$kernel\"; then\n\t\t\tkernel_sro=\"found spec_rstack_overflow in kernel image\"\n\t\tfi\n\t\tif [ -n \"$kernel_sro\" ]; then\n\t\t\tpstatus green YES \"$kernel_sro\"\n\t\telif [ -n \"$kernel_sro_err\" ]; then\n\t\t\tpstatus yellow UNKNOWN \"$kernel_sro_err\"\n\t\telse\n\t\t\tpstatus yellow NO\n\t\tfi\n\n\t\t_info_nol \"* Kernel compiled with SRSO support: \"\n\t\tif [ -r \"$opt_config\" ]; then\n\t\t\t# CONFIG_CPU_SRSO: Linux < 6.9\n\t\t\t# CONFIG_MITIGATION_SRSO: Linux >= 6.9\n\t\t\tif grep -Eq '^CONFIG_(CPU|MITIGATION)_SRSO=y' \"$opt_config\"; then\n\t\t\t\tpstatus green YES\n\t\t\t\tkernel_srso=\"CONFIG_(CPU|MITIGATION)_SRSO=y found in kernel config\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO \"required for safe RET and ibpb_on_vmexit mitigations\"\n\t\t\tfi\n\t\telse\n\t\t\t# https://github.com/torvalds/linux/commit/138bcddb86d8a4f842e4ed6f0585abc9b1a764ff#diff-17bd24a7a7850613cced545790ac30646097e8d6207348c2bd1845f397acb390R2313\n\t\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"$kernel_err\"\n\t\t\telif grep -Eq 'WARNING: kernel not compiled with (CPU|MITIGATION)_SRSO' \"$kernel\"; then\n\t\t\t\t# this msg is optimized out at compile time if the option is not enabled, see commit referenced above\n\t\t\t\t# if it's present, then SRSO is NOT compiled in\n\t\t\t\tpstatus yellow NO \"kernel not compiled with (CPU|MITIGATION)_SRSO\"\n\t\t\telse\n\t\t\t\t# if it's not present, then SRSO is compiled in IF kernel_sro==1, otherwise we're just\n\t\t\t\t# in front of an old kernel that doesn't have the mitigation logic at all\n\t\t\t\tif [ \"$kernel_sro\" = 1 ]; then\n\t\t\t\t\tkernel_srso=\"SRSO mitigation logic is compiled in the kernel\"\n\t\t\t\t\tpstatus green OK \"$kernel_srso\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO \"your kernel is too old and doesn't have the mitigation logic\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t_info_nol \"* Kernel compiled with IBPB_ENTRY support: \"\n\t\tif [ -r \"$opt_config\" ]; then\n\t\t\t# CONFIG_CPU_IBPB_ENTRY: Linux < 6.9\n\t\t\t# CONFIG_MITIGATION_IBPB_ENTRY: Linux >= 6.9\n\t\t\tif grep -Eq '^CONFIG_(CPU|MITIGATION)_IBPB_ENTRY=y' \"$opt_config\"; then\n\t\t\t\tpstatus green YES\n\t\t\t\tkernel_ibpb_entry=\"CONFIG_(CPU|MITIGATION)_IBPB_ENTRY=y found in kernel config\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\telse\n\t\t\t# https://github.com/torvalds/linux/commit/138bcddb86d8a4f842e4ed6f0585abc9b1a764ff#diff-17bd24a7a7850613cced545790ac30646097e8d6207348c2bd1845f397acb390R2325\n\t\t\tif [ -n \"$kernel_err\" ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"$kernel_err\"\n\t\t\telif grep -Eq 'WARNING: kernel not compiled with (CPU|MITIGATION)_IBPB_ENTRY' \"$kernel\"; then\n\t\t\t\t# this msg is optimized out at compile time if the option is not enabled, see commit referenced above\n\t\t\t\t# if it's present, then IBPB_ENTRY is NOT compiled in\n\t\t\t\tpstatus yellow NO \"kernel not compiled with (CPU|MITIGATION)_IBPB_ENTRY\"\n\t\t\telse\n\t\t\t\t# if it's not present, then IBPB_ENTRY is compiled in IF kernel_sro==1, otherwise we're just\n\t\t\t\t# in front of an old kernel that doesn't have the mitigation logic at all\n\t\t\t\tif [ \"$kernel_sro\" = 1 ]; then\n\t\t\t\t\tkernel_ibpb_entry=\"IBPB_ENTRY mitigation logic is compiled in the kernel\"\n\t\t\t\t\tpstatus green OK \"$kernel_ibpb_entry\"\n\t\t\t\telse\n\t\t\t\t\tpstatus yellow NO \"your kernel is too old and doesn't have the mitigation logic\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\t# Zen & Zen2 : if the right IBPB microcode applied + SMT off --> not vuln\n\t\tif [ \"$cpu_family\" = $(( 0x17 )) ]; then\n\t\t\t_info_nol \"* CPU supports IBPB: \"\n\t\t\tif [ -n \"$cpuid_ibpb\" ]; then\n\t\t\t\tpstatus green YES \"$cpuid_ibpb\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\n\t\t\t_info_nol \"* Hyper-Threading (SMT) is enabled: \"\n\t\t\tis_cpu_smt_enabled; smt_enabled=$?\n\t\t\tif [ \"$smt_enabled\" = 0 ]; then\n\t\t\t\tpstatus yellow YES\n\t\t\telse\n\t\t\t\tpstatus green NO\n\t\t\tfi\n\t\t# Zen 3/4 microcode brings SBPB mitigation\n\t\telif [ \"$cpu_family\" = $(( 0x19 )) ]; then\n\t\t\t_info_nol \"* CPU supports SBPB: \"\n\t\t\tif [ \"$cpuid_sbpb\" = 1 ]; then\n\t\t\t\tpstatus green YES\n\t\t\telif [ \"$cpuid_sbpb\" = 3 ]; then\n\t\t\t\tpstatus yellow UNKNOWN \"cannot write MSR, rerun with --allow-msr-write\"\n\t\t\telse\n\t\t\t\tpstatus yellow NO\n\t\t\tfi\n\t\tfi\n\n\telif [ \"$sys_interface_available\" = 0 ]; then\n\t\t# we have no sysfs but were asked to use it only!\n\t\tmsg=\"/sys vulnerability interface use forced, but it's not available!\"\n\t\tstatus=UNK\n\tfi\n\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\t# override status & msg in case CPU is not vulnerable after all\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telif [ -z \"$msg\" ]; then\n\t\t# if msg is empty, sysfs check didn't fill it, so we rely on our own logic\n\t\t# Zen/Zen2\n\t\tif [ \"$cpu_family\" = $(( 0x17 )) ]; then\n\t\t\tif [ \"$smt_enabled\" = 0 ]; then\n\t\t\t\tpvulnstatus \"$cve\" VULN \"SMT is enabled on your Zen/Zen2 CPU, which makes mitigation ineffective\"\n\t\t\t\texplain \"For Zen/Zen2 CPUs, proper mitigation needs an up to date microcode, and SMT needs to be disabled (this can be done by adding \\`nosmt\\` to your kernel command line)\"\n\t\t\telif [ -z \"$kernel_sro\" ]; then\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your kernel is too old and doesn't have the SRSO mitigation logic\"\n\t\t\telif [ -n \"$cpuid_ibpb\" ]; then\n\t\t\t\tpvulnstatus \"$cve\" OK \"SMT is disabled and both your kernel and microcode support mitigation\"\n\t\t\telse\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode is too old\"\n\t\t\tfi\n\t\t# Zen3/Zen4\n\t\telif [ \"$cpu_family\" = $(( 0x19 )) ]; then\n\t\t\tif [ -z \"$kernel_sro\" ]; then\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your kernel is too old and doesn't have the SRSO mitigation logic\"\n\t\t\telif [ -z \"$kernel_srso\" ] && [ -z \"$kernel_ibpb_entry\" ]; then\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your kernel doesn't have either SRSO or IBPB_ENTRY compiled-in\"\n\t\t\telif [ \"$cpuid_sbpb\" = 3 ]; then\n\t\t\t\tpvulnstatus \"$cve\" UNK \"Couldn't verify if your microcode supports IBPB (rerun with --allow-msr-write)\"\n\t\t\telif [ \"$cpuid_sbpb\" = 2 ]; then\n\t\t\t\tpvulnstatus \"$cve\" VULN \"Your microcode doesn't support SBPB\"\n\t\t\telse\n\t\t\t\tpvulnstatus \"$cve\" OK \"Your kernel and microcode both support mitigation\"\n\t\t\tfi\n\t\telse\n\t\t\t# not supposed to happen, as normally this CPU should not be affected and not run this code\n\t\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\t\tfi\n\telse\n\t\tpvulnstatus $cve \"$status\" \"$msg\"\n\tfi\n}\n\n#######################\n# Reptar section\n\ncheck_CVE_2023_23583() {\n\tcve='CVE-2023-23583'\n\t_info \"\\033[1;34m$cve aka '$(cve2name \"$cve\")'\\033[0m\"\n\tif [ \"$os\" = Linux ]\n\tthen\n\t\tcheck_CVE_2023_23583_linux\n\telse\n\t\t_warn \"Unsupported OS ($os).\"\n\tfi\n}\n\ncheck_CVE_2023_23583_linux() {\n\tstatus=UNK\n\tsys_interface_available=0\n\tmsg=''\n\n\t# there is no sysfs file for this vuln, and no kernel patch,\n\t# the mitigation is only ucode-based and there's no flag exposed,\n\t# so most of the work has already been done by is_cpu_affected()\n\tif ! is_cpu_affected \"$cve\" ; then\n\t\tpvulnstatus \"$cve\" OK \"your CPU vendor reported your CPU model as not affected\"\n\telse\n\t\t_info_nol \"* Reptar is mitigated by microcode: \"\n\t\tif [ \"$cpu_ucode\" -lt \"$reptar_fixed_ucode_version\" ]; then\n\t\t\tpstatus yellow NO \"You have ucode $(printf \"0x%x\" $cpu_ucode) and version $(printf \"0x%x\" $reptar_fixed_ucode_version) minimum is required\"\n\t\t\tpvulnstatus $cve VULN \"Your microcode is too old to mitigate the vulnerability\"\n\t\telse\n\t\t\tpstatus green YES \"You have ucode $(printf \"0x%x\" $cpu_ucode) which is recent enough (>= $(printf \"0x%x\" $reptar_fixed_ucode_version))\"\n\t\t\tpvulnstatus $cve OK \"Your microcode mitigates the vulnerability\"\n\t\tfi\n\tfi\n}\n\n#######################\n# END OF VULNS SECTIONS\n\nif [ \"$opt_no_hw\" = 0 ] && [ -z \"$opt_arch_prefix\" ]; then\n\tcheck_cpu\n\tcheck_cpu_vulnerabilities\n\t_info\nfi\n\n# now run the checks the user asked for\nfor cve in $supported_cve_list\ndo\n\tif [ \"$opt_cve_all\" = 1 ] || echo \"$opt_cve_list\" | grep -qw \"$cve\"; then\n\t\tcheck_\"$(echo \"$cve\" | tr - _)\"\n\t\t_info\n\tfi\ndone\n\nif [ -n \"$final_summary\" ]; then\n\t_info \"> \\033[46m\\033[30mSUMMARY:\\033[0m$final_summary\"\n\t_info \"\"\nfi\n\nif [ \"$bad_accuracy\" = 1 ]; then\n\t_warn \"We're missing some kernel info (see -v), accuracy might be reduced\"\nfi\n\n_vars=$(set | grep -Ev '^[A-Z_[:space:]]' | grep -v -F 'mockme=' | sort | tr \"\\n\" '|')\n_debug \"variables at end of script: $_vars\"\n\nif [ -n \"$mockme\" ] && [ \"$opt_mock\" = 1 ]; then\n\tif command -v \"gzip\" >/dev/null 2>&1; then\n\t\t# not a useless use of cat: gzipping cpuinfo directly doesn't work well\n\t\t# shellcheck disable=SC2002\n\t\tif command -v \"base64\" >/dev/null 2>&1; then\n\t\t\tmock_cpuinfo=\"$(cat /proc/cpuinfo | gzip -c | base64 -w0)\"\n\t\telif command -v \"uuencode\" >/dev/null 2>&1; then\n\t\t\tmock_cpuinfo=\"$(cat /proc/cpuinfo | gzip -c | uuencode -m - | grep -Fv 'begin-base64' | grep -Fxv -- '====' | tr -d \"\\n\")\"\n\t\tfi\n\tfi\n\tif [ -n \"$mock_cpuinfo\" ]; then\n\t\tmockme=$(printf \"%b\\n%b\" \"$mockme\" \"SMC_MOCK_CPUINFO='$mock_cpuinfo'\")\n\t\tunset mock_cpuinfo\n\tfi\n\t_info \"\"\n\t# shellcheck disable=SC2046\n\t_warn \"To mock this CPU, set those vars: \"$(echo \"$mockme\" | sort -u)\nfi\n\n# root check\nif [ \"$(id -u)\" -ne 0 ]; then\n\t_warn \"Note that you should launch this script with root privileges to get completely accurate information.\"\n\t_warn \"To run it as root, you can try the following command: sudo $0\"\n\t_warn\nfi\n\nif [ \"$opt_explain\" = 0 ]; then\n\t_info \"Need more detailed information about mitigation options? Use --explain\"\nfi\n\n_info \"A false sense of security is worse than no security at all, see --disclaimer\"\n\nif [ \"$mocked\" = 1 ]; then\n\t_info \"\"\n\t_warn \"One or several values have been mocked. This should only be done when debugging/testing this script.\"\n\t_warn \"The results do NOT reflect the actual status of the system we're running on.\"\nfi\n\nif [ \"$opt_batch\" = 1 ] && [ \"$opt_batch_format\" = \"nrpe\" ]; then\n\tif [ -n \"$nrpe_vuln\" ]; then\n\t\techo \"Vulnerable:$nrpe_vuln\"\n\telse\n\t\techo \"OK\"\n\tfi\nfi\n\nif [ \"$opt_batch\" = 1 ] && [ \"$opt_batch_format\" = \"short\" ]; then\n\t_echo 0 \"${short_output% }\"\nfi\n\nif [ \"$opt_batch\" = 1 ] && [ \"$opt_batch_format\" = \"json\" ]; then\n\t_echo 0 \"${json_output%?}]\"\nfi\n\nif [ \"$opt_batch\" = 1 ] && [ \"$opt_batch_format\" = \"prometheus\" ]; then\n\techo \"# TYPE specex_vuln_status untyped\"\n\techo \"# HELP specex_vuln_status Exposure of system to speculative execution vulnerabilities\"\n\tprintf \"%b\\n\" \"$prometheus_output\"\nfi\n\n# exit with the proper exit code\n[ \"$global_critical\" = 1 ] && exit 2  # critical\n[ \"$global_unknown\"  = 1 ] && exit 3  # unknown\nexit 0  # ok\n\n# Dump from Intel affected CPU page:\n# - https://www.intel.com/content/www/us/en/developer/topic-technology/software-security-guidance/processors-affected-consolidated-product-cpu-model.html\n# Only currently-supported CPUs are listed, so only rely on it if the current CPU happens to be in the list.\n# We merge it with info from the following file:\n# - https://software.intel.com/content/dam/www/public/us/en/documents/affected-processors-transient-execution-attacks-by-cpu-aug02.xlsx\n# As it contains some information from older processors, however when information is contradictory between the two sources, the HTML takes precedence as\n# it is expected to be updated, whereas the xslx seems to be frozen.\n#\n# N: Not affected\n# S: Affected, software fix\n# H: Affected, hardware fix\n# M: Affected, MCU update needed\n# B: Affected, BIOS update needed\n# X: Affected, no planned mitigation\n# Y: Affected (this is from the xlsx, no details are available)\n#\n# %%% INTELDB\n# 0x000206A7,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=N,\n# 0x000206D6,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=N,\n# 0x000206D7,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=N,\n# 0x00030673,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x00030678,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x00030679,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000306A9,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=Y,\n# 0x000306C3,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=Y,\n# 0x000306D4,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=Y,2020-0543=Y,\n# 0x000306E4,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=N,\n# 0x000306E7,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=N,\n# 0x000306F2,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000306F4,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=N,\n# 0x00040651,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=Y,\n# 0x00040661,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=N,2020-0543=Y,\n# 0x00040671,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=Y,2020-0543=Y,\n# 0x000406A0,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000406C3,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000406C4,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000406D8,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000406E3,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=MS,\n# 0x000406F1,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=N,\n# 0x00050653,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=M,\n# 0x00050654,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=M,\n# 0x00050656,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=MS,2020-0543=N,2022-40982=M,\n# 0x00050657,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=MS,2020-0543=N,2022-40982=M,\n# 0x0005065A,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x0005065B,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x00050662,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=Y,2018-12130=Y,2018-12207=Y,2018-3615=Y,2018-3620=Y,2018-3639=Y,2018-3640=Y,2018-3646=Y,2019-11135=Y,2020-0543=N,\n# 0x00050663,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=N,\n# 0x00050664,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=N,\n# 0x00050665,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=N,2022-40982=N,\n# 0x000506A0,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000506C9,2017-5715=MS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000506CA,2017-5715=MS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000506D0,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000506E3,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=MS,2022-40982=N,\n# 0x000506F1,2017-5715=MS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00060650,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000606A0,2017-5715=Y,2017-5753=Y,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=Y,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000606A4,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000606A5,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000606A6,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000606C1,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000606E1,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x0007065A,2017-5715=Y,2017-5753=Y,2017-5754=Y,2018-12126=Y,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=N,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000706A1,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000706A8,2017-5715=MS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000706E5,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=HM,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x00080660,2017-5715=Y,2017-5753=Y,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=Y,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x00080664,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00080665,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00080667,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000806A0,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=HM,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000806A1,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=HM,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000806C0,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000806C1,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000806C2,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000806D0,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000806D1,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000806E9,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=M,2022-40982=M,\n# 0x000806EA,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000806EB,2017-5715=MS,2017-5753=S,2017-5754=N,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=M,2018-3646=N,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000806EC,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000806F7,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000806F8,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090660,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090661,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090670,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090671,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090672,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090673,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090674,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x00090675,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000906A0,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000906A2,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000906A3,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000906A4,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=MS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000906C0,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000906E9,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000906EA,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000906EB,2017-5715=MS,2017-5753=S,2017-5754=S,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=MS,2018-3620=MS,2018-3639=MS,2018-3640=M,2018-3646=MS,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000906EC,2017-5715=MS,2017-5753=S,2017-5754=N,2018-12126=MS,2018-12127=MS,2018-12130=MS,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000906ED,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=MS,2020-0543=MS,2022-40982=M,\n# 0x000A0650,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0651,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0652,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0653,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0655,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0660,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0661,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=S,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=M,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0670,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0671,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=M,\n# 0x000A0680,2017-5715=Y,2017-5753=Y,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=Y,2018-3615=N,2018-3620=N,2018-3639=Y,2018-3640=Y,2018-3646=N,2019-11135=N,2020-0543=N,\n# 0x000B0671,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000B06A2,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000B06A3,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000B06F2,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# 0x000B06F5,2017-5715=HS,2017-5753=S,2017-5754=N,2018-12126=N,2018-12127=N,2018-12130=N,2018-12207=N,2018-3615=N,2018-3620=N,2018-3639=HS,2018-3640=N,2018-3646=N,2019-11135=N,2020-0543=N,2022-40982=N,\n# %%% ENDOFINTELDB\n\n# We're using MCE.db from the excellent platomav's MCExtractor project\n# The builtin version follows, but the user can download an up-to-date copy (to be stored in their $HOME) by using --update-fwdb\n# To update the builtin version itself (by *modifying* this very file), use --update-builtin-fwdb\n#\n# The format below is:\n# X,CPUID_HEX,MICROCODE_VERSION_HEX,YYYYMMDD\n# with X being either I for Intel, or A for AMD\n# When the date is unknown it defaults to 20000101\n\n# %%% MCEDB v296+i20240514+988c\n# I,0x00000611,0xFF,0x00000B27,19961218\n# I,0x00000612,0xFF,0x000000C6,19961210\n# I,0x00000616,0xFF,0x000000C6,19961210\n# I,0x00000617,0xFF,0x000000C6,19961210\n# I,0x00000619,0xFF,0x000000D2,19980218\n# I,0x00000630,0xFF,0x00000013,19960827\n# I,0x00000632,0xFF,0x00000020,19960903\n# I,0x00000633,0xFF,0x00000036,19980923\n# I,0x00000634,0xFF,0x00000037,19980923\n# I,0x00000650,0x01,0x00000040,19990525\n# I,0x00000650,0x02,0x00000041,19990525\n# I,0x00000650,0x08,0x00000045,19990525\n# I,0x00000651,0x01,0x00000040,19990525\n# I,0x00000652,0x01,0x0000002A,19990512\n# I,0x00000652,0x02,0x0000002C,19990517\n# I,0x00000652,0x04,0x0000002B,19990512\n# I,0x00000653,0x01,0x00000010,19990628\n# I,0x00000653,0x02,0x0000000C,19990518\n# I,0x00000653,0x04,0x0000000B,19990520\n# I,0x00000653,0x08,0x0000000D,19990518\n# I,0x00000660,0x01,0x0000000A,19990505\n# I,0x00000665,0x10,0x00000003,19990505\n# I,0x0000066A,0x02,0x0000000C,19990505\n# I,0x0000066A,0x08,0x0000000D,19990505\n# I,0x0000066A,0x20,0x0000000B,19990505\n# I,0x0000066D,0x02,0x00000005,19990312\n# I,0x0000066D,0x08,0x00000006,19990312\n# I,0x0000066D,0x20,0x00000007,19990505\n# I,0x00000670,0xFF,0x00000007,19980602\n# I,0x00000671,0x04,0x00000014,19980811\n# I,0x00000672,0x04,0x00000038,19990922\n# I,0x00000673,0x04,0x0000002E,19990910\n# I,0x00000680,0xFF,0x00000017,19990610\n# I,0x00000681,0x01,0x0000000D,19990921\n# I,0x00000681,0x04,0x00000010,19990921\n# I,0x00000681,0x08,0x0000000F,19990921\n# I,0x00000681,0x10,0x00000011,19990921\n# I,0x00000681,0x20,0x0000000E,19990921\n# I,0x00000683,0x08,0x00000008,19991015\n# I,0x00000683,0x20,0x00000007,19991015\n# I,0x00000686,0x01,0x00000007,20000505\n# I,0x00000686,0x02,0x0000000A,20000504\n# I,0x00000686,0x04,0x00000002,20000504\n# I,0x00000686,0x10,0x00000008,20000505\n# I,0x00000686,0x80,0x0000000C,20000504\n# I,0x0000068A,0x10,0x00000001,20001102\n# I,0x0000068A,0x20,0x00000004,20001207\n# I,0x0000068A,0x80,0x00000005,20001207\n# I,0x00000690,0xFF,0x00000004,20000206\n# I,0x00000691,0xFF,0x00000001,20020527\n# I,0x00000692,0xFF,0x00000001,20020620\n# I,0x00000694,0xFF,0x00000002,20020926\n# I,0x00000695,0x10,0x00000007,20041109\n# I,0x00000695,0x20,0x00000007,20041109\n# I,0x00000695,0x80,0x00000047,20041109\n# I,0x00000696,0xFF,0x00000001,20000707\n# I,0x000006A0,0x04,0x00000003,20000110\n# I,0x000006A1,0x04,0x00000001,20000306\n# I,0x000006A4,0xFF,0x00000001,20000616\n# I,0x000006B0,0xFF,0x0000001A,20010129\n# I,0x000006B1,0x10,0x0000001C,20010215\n# I,0x000006B1,0x20,0x0000001D,20010220\n# I,0x000006B4,0x10,0x00000001,20020110\n# I,0x000006B4,0x20,0x00000002,20020111\n# I,0x000006D0,0xFF,0x00000006,20030522\n# I,0x000006D1,0xFF,0x00000009,20030709\n# I,0x000006D2,0xFF,0x00000010,20030814\n# I,0x000006D6,0x20,0x00000018,20041017\n# I,0x000006D8,0xFF,0x00000021,20060831\n# I,0x000006E0,0xFF,0x00000008,20050215\n# I,0x000006E1,0xFF,0x0000000C,20050413\n# I,0x000006E4,0xFF,0x00000026,20050816\n# I,0x000006E8,0x20,0x00000039,20051115\n# I,0x000006EC,0x20,0x00000054,20060501\n# I,0x000006EC,0x80,0x00000059,20060912\n# I,0x000006F0,0xFF,0x00000005,20050818\n# I,0x000006F1,0xFF,0x00000012,20051129\n# I,0x000006F2,0x01,0x0000005D,20101002\n# I,0x000006F2,0x20,0x0000005C,20101002\n# I,0x000006F4,0xFF,0x00000028,20060417\n# I,0x000006F5,0xFF,0x00000039,20060727\n# I,0x000006F6,0x01,0x000000D0,20100930\n# I,0x000006F6,0x04,0x000000D2,20101001\n# I,0x000006F6,0x20,0x000000D1,20101001\n# I,0x000006F7,0x10,0x0000006A,20101002\n# I,0x000006F7,0x40,0x0000006B,20101002\n# I,0x000006F9,0xFF,0x00000084,20061012\n# I,0x000006FA,0x80,0x00000095,20101002\n# I,0x000006FB,0x01,0x000000BA,20101003\n# I,0x000006FB,0x04,0x000000BC,20101003\n# I,0x000006FB,0x08,0x000000BB,20101003\n# I,0x000006FB,0x10,0x000000BA,20101003\n# I,0x000006FB,0x20,0x000000BA,20101003\n# I,0x000006FB,0x40,0x000000BC,20101003\n# I,0x000006FB,0x80,0x000000BA,20101003\n# I,0x000006FD,0x01,0x000000A4,20101002\n# I,0x000006FD,0x20,0x000000A4,20101002\n# I,0x000006FD,0x80,0x000000A4,20101002\n# I,0x00000F00,0xFF,0xFFFF0001,20000130\n# I,0x00000F01,0xFF,0xFFFF0007,20000404\n# I,0x00000F02,0xFF,0xFFFF000B,20000518\n# I,0x00000F03,0xFF,0xFFFF0001,20000518\n# I,0x00000F04,0xFF,0xFFFF0010,20000803\n# I,0x00000F05,0xFF,0x0000000C,20000824\n# I,0x00000F06,0xFF,0x00000004,20000911\n# I,0x00000F07,0x01,0x00000012,20020716\n# I,0x00000F07,0x02,0x00000008,20001115\n# I,0x00000F08,0xFF,0x00000008,20001101\n# I,0x00000F09,0xFF,0x00000008,20010104\n# I,0x00000F0A,0x01,0x00000013,20020716\n# I,0x00000F0A,0x02,0x00000015,20020821\n# I,0x00000F0A,0x04,0x00000014,20020716\n# I,0x00000F11,0xFF,0x0000000A,20030729\n# I,0x00000F12,0x04,0x0000002E,20030502\n# I,0x00000F13,0xFF,0x00000005,20030508\n# I,0x00000F20,0xFF,0x00000001,20010423\n# I,0x00000F21,0xFF,0x00000003,20010529\n# I,0x00000F22,0xFF,0x00000005,20030729\n# I,0x00000F23,0xFF,0x0000000D,20010817\n# I,0x00000F24,0x02,0x0000001F,20030605\n# I,0x00000F24,0x04,0x0000001E,20030605\n# I,0x00000F24,0x10,0x00000021,20030610\n# I,0x00000F25,0x01,0x00000029,20040811\n# I,0x00000F25,0x02,0x0000002A,20040811\n# I,0x00000F25,0x04,0x0000002B,20040811\n# I,0x00000F25,0x10,0x0000002C,20040826\n# I,0x00000F26,0x02,0x00000010,20040805\n# I,0x00000F27,0x02,0x00000038,20030604\n# I,0x00000F27,0x04,0x00000037,20030604\n# I,0x00000F27,0x08,0x00000039,20030604\n# I,0x00000F29,0x02,0x0000002D,20040811\n# I,0x00000F29,0x04,0x0000002E,20040811\n# I,0x00000F29,0x08,0x0000002F,20040811\n# I,0x00000F30,0xFF,0x00000013,20030815\n# I,0x00000F31,0xFF,0x0000000B,20031021\n# I,0x00000F32,0x0D,0x0000000A,20040511\n# I,0x00000F33,0x0D,0x0000000C,20050421\n# I,0x00000F34,0x1D,0x00000017,20050421\n# I,0x00000F36,0xFF,0x00000007,20040309\n# I,0x00000F37,0xFF,0x00000003,20031218\n# I,0x00000F40,0xFF,0x00000006,20040318\n# I,0x00000F41,0x02,0x00000016,20050421\n# I,0x00000F41,0xBD,0x00000017,20050422\n# I,0x00000F42,0xFF,0x00000003,20050421\n# I,0x00000F43,0x9D,0x00000005,20050421\n# I,0x00000F44,0x9D,0x00000006,20050421\n# I,0x00000F46,0xFF,0x00000004,20050411\n# I,0x00000F47,0x9D,0x00000003,20050421\n# I,0x00000F48,0x01,0x0000000C,20060508\n# I,0x00000F48,0x02,0x0000000E,20080115\n# I,0x00000F48,0x5F,0x00000007,20050630\n# I,0x00000F49,0xBD,0x00000003,20050421\n# I,0x00000F4A,0x5C,0x00000004,20051214\n# I,0x00000F4A,0x5D,0x00000002,20050610\n# I,0x00000F60,0xFF,0x00000005,20050124\n# I,0x00000F61,0xFF,0x00000008,20050610\n# I,0x00000F62,0x04,0x0000000F,20051215\n# I,0x00000F63,0xFF,0x00000005,20051010\n# I,0x00000F64,0x01,0x00000002,20051215\n# I,0x00000F64,0x34,0x00000004,20051223\n# I,0x00000F65,0x01,0x00000008,20060426\n# I,0x00000F66,0xFF,0x0000001B,20060310\n# I,0x00000F68,0x22,0x00000009,20060714\n# I,0x00001632,0x00,0x00000002,19980610\n# I,0x00010650,0xFF,0x00000002,20060513\n# I,0x00010660,0xFF,0x00000004,20060612\n# I,0x00010661,0x01,0x00000043,20101004\n# I,0x00010661,0x02,0x00000042,20101004\n# I,0x00010661,0x80,0x00000044,20101004\n# I,0x00010670,0xFF,0x00000005,20070209\n# I,0x00010671,0xFF,0x00000106,20070329\n# I,0x00010674,0xFF,0x84050100,20070726\n# I,0x00010676,0x01,0x0000060F,20100929\n# I,0x00010676,0x04,0x0000060F,20100929\n# I,0x00010676,0x10,0x0000060F,20100929\n# I,0x00010676,0x40,0x0000060F,20100929\n# I,0x00010676,0x80,0x0000060F,20100929\n# I,0x00010677,0x10,0x0000070A,20100929\n# I,0x0001067A,0x11,0x00000A0B,20100928\n# I,0x0001067A,0x44,0x00000A0B,20100928\n# I,0x0001067A,0xA0,0x00000A0B,20100928\n# I,0x000106A0,0xFF,0xFFFF001A,20071128\n# I,0x000106A1,0xFF,0xFFFF000B,20080220\n# I,0x000106A2,0xFF,0xFFFF0019,20080714\n# I,0x000106A4,0x03,0x00000012,20130621\n# I,0x000106A5,0x03,0x0000001D,20180511\n# I,0x000106C0,0xFF,0x00000007,20070824\n# I,0x000106C1,0xFF,0x00000109,20071203\n# I,0x000106C2,0x01,0x00000217,20090410\n# I,0x000106C2,0x04,0x00000218,20090410\n# I,0x000106C2,0x08,0x00000219,20090410\n# I,0x000106C9,0xFF,0x00000007,20090213\n# I,0x000106CA,0x01,0x00000107,20090825\n# I,0x000106CA,0x04,0x00000107,20090825\n# I,0x000106CA,0x08,0x00000107,20090825\n# I,0x000106CA,0x10,0x00000107,20090825\n# I,0x000106D0,0xFF,0x00000005,20071204\n# I,0x000106D1,0x08,0x00000029,20100930\n# I,0x000106E0,0xFF,0xFFFF0022,20090116\n# I,0x000106E1,0xFF,0xFFFF000D,20090206\n# I,0x000106E2,0xFF,0xFFFF0011,20090924\n# I,0x000106E3,0xFF,0xFFFF0011,20090512\n# I,0x000106E4,0xFF,0x00000003,20130701\n# I,0x000106E5,0x13,0x0000000A,20180508\n# I,0x000106F0,0xFF,0xFFFF0009,20090210\n# I,0x000106F1,0xFF,0xFFFF0007,20090210\n# I,0x00020650,0xFF,0xFFFF0008,20090218\n# I,0x00020651,0xFF,0xFFFF0018,20090818\n# I,0x00020652,0x12,0x00000011,20180508\n# I,0x00020654,0xFF,0xFFFF0007,20091124\n# I,0x00020655,0x92,0x00000007,20180423\n# I,0x00020661,0x01,0x00000104,20091023\n# I,0x00020661,0x02,0x00000105,20110718\n# I,0x000206A0,0xFF,0x00000029,20091102\n# I,0x000206A1,0xFF,0x00000007,20091223\n# I,0x000206A2,0xFF,0x00000027,20100502\n# I,0x000206A3,0xFF,0x00000009,20100609\n# I,0x000206A4,0xFF,0x00000022,20100414\n# I,0x000206A5,0xFF,0x00000007,20100722\n# I,0x000206A6,0xFF,0x90030028,20100924\n# I,0x000206A7,0x12,0x0000002F,20190217\n# I,0x000206C0,0xFF,0xFFFF001C,20091214\n# I,0x000206C1,0xFF,0x00000006,20091222\n# I,0x000206C2,0x03,0x0000001F,20180508\n# I,0x000206D0,0xFF,0x80000006,20100816\n# I,0x000206D1,0xFF,0x80000106,20101201\n# I,0x000206D2,0xFF,0xAF506958,20110714\n# I,0x000206D3,0xFF,0xAF50696A,20110816\n# I,0x000206D5,0xFF,0xAF5069E5,20120118\n# I,0x000206D6,0x6D,0x00000621,20200304\n# I,0x000206D7,0x6D,0x0000071A,20200324\n# I,0x000206E0,0xFF,0xE3493401,20090108\n# I,0x000206E1,0xFF,0xE3493402,20090224\n# I,0x000206E2,0xFF,0xFFFF0004,20081001\n# I,0x000206E3,0xFF,0xE4486547,20090701\n# I,0x000206E4,0xFF,0xFFFF0008,20090619\n# I,0x000206E5,0xFF,0xFFFF0018,20091215\n# I,0x000206E6,0x04,0x0000000D,20180515\n# I,0x000206F0,0xFF,0x00000005,20100729\n# I,0x000206F1,0xFF,0x00000008,20101013\n# I,0x000206F2,0x05,0x0000003B,20180516\n# I,0x00030650,0xFF,0x00000009,20120118\n# I,0x00030651,0xFF,0x00000110,20131014\n# I,0x00030660,0xFF,0x00000003,20101103\n# I,0x00030661,0xFF,0x0000010F,20150721\n# I,0x00030669,0xFF,0x0000010D,20130515\n# I,0x00030671,0xFF,0x00000117,20130410\n# I,0x00030672,0xFF,0x0000022E,20140401\n# I,0x00030673,0xFF,0x83290100,20190916\n# I,0x00030678,0x02,0x00000838,20190422\n# I,0x00030678,0x0C,0x00000838,20190422\n# I,0x00030679,0x0F,0x0000090D,20190710\n# I,0x000306A0,0xFF,0x00000007,20110407\n# I,0x000306A2,0xFF,0x0000000C,20110725\n# I,0x000306A4,0xFF,0x00000007,20110908\n# I,0x000306A5,0xFF,0x00000009,20111110\n# I,0x000306A6,0xFF,0x00000004,20111114\n# I,0x000306A8,0xFF,0x00000010,20120220\n# I,0x000306A9,0x12,0x00000021,20190213\n# I,0x000306C0,0xFF,0xFFFF0013,20111110\n# I,0x000306C1,0xFF,0xFFFF0014,20120725\n# I,0x000306C2,0xFF,0xFFFF0006,20121017\n# I,0x000306C3,0x32,0x00000028,20191112\n# I,0x000306D1,0xFF,0xFFFF0009,20131015\n# I,0x000306D2,0xFF,0xFFFF0009,20131219\n# I,0x000306D3,0xFF,0xE3121338,20140825\n# I,0x000306D4,0xC0,0x0000002F,20191112\n# I,0x000306E0,0xFF,0xE920080F,20121113\n# I,0x000306E2,0xFF,0xE9220827,20130523\n# I,0x000306E3,0xFF,0x00000308,20130321\n# I,0x000306E4,0xED,0x0000042E,20190314\n# I,0x000306E6,0xED,0x00000600,20130619\n# I,0x000306E7,0xED,0x00000715,20190314\n# I,0x000306F0,0xFF,0xFFFF0017,20130730\n# I,0x000306F1,0xFF,0xD141D629,20140416\n# I,0x000306F2,0x6F,0x00000049,20210811\n# I,0x000306F3,0xFF,0x0000000D,20160211\n# I,0x000306F4,0x80,0x0000001A,20210524\n# I,0x00040650,0xFF,0xFFFF000B,20121206\n# I,0x00040651,0x72,0x00000026,20191112\n# I,0x00040660,0xFF,0xFFFF0011,20121012\n# I,0x00040661,0x32,0x0000001C,20191112\n# I,0x00040670,0xFF,0xFFFF0006,20140304\n# I,0x00040671,0x22,0x00000022,20191112\n# I,0x000406A0,0xFF,0x80124001,20130521\n# I,0x000406A8,0xFF,0x0000081F,20140812\n# I,0x000406A9,0xFF,0x0000081F,20140812\n# I,0x000406C1,0xFF,0x0000010B,20140814\n# I,0x000406C2,0xFF,0x00000221,20150218\n# I,0x000406C3,0x01,0x00000368,20190423\n# I,0x000406C4,0x01,0x00000411,20190423\n# I,0x000406D0,0xFF,0x0000000E,20130612\n# I,0x000406D8,0x01,0x0000012D,20190916\n# I,0x000406E1,0xFF,0x00000020,20141111\n# I,0x000406E2,0xFF,0x0000002C,20150521\n# I,0x000406E3,0xC0,0x000000F0,20211112\n# I,0x000406E8,0xFF,0x00000026,20160414\n# I,0x000406F0,0xFF,0x00000014,20150702\n# I,0x000406F1,0xFF,0x0B000040,20210519\n# I,0x00050650,0xFF,0x8000002B,20160208\n# I,0x00050651,0xFF,0x8000002B,20160208\n# I,0x00050652,0xFF,0x80000037,20170502\n# I,0x00050653,0x97,0x01000191,20230728\n# I,0x00050654,0xB7,0x02007006,20230306\n# I,0x00050655,0xB7,0x03000010,20181116\n# I,0x00050656,0xBF,0x04003605,20230728\n# I,0x00050657,0xBF,0x05003605,20230728\n# I,0x0005065A,0xFF,0x86002302,20210416\n# I,0x0005065B,0xBF,0x07002802,20230803\n# I,0x00050661,0xFF,0xF1000008,20150130\n# I,0x00050662,0x10,0x0000001C,20190617\n# I,0x00050663,0x10,0x0700001C,20210612\n# I,0x00050664,0x10,0x0F00001A,20210612\n# I,0x00050665,0x10,0x0E000015,20230803\n# I,0x00050670,0xFF,0xFFFF0030,20151113\n# I,0x00050671,0xFF,0x000001B6,20180108\n# I,0x000506A0,0xFF,0x00000038,20150112\n# I,0x000506C0,0xFF,0x00000002,20140613\n# I,0x000506C2,0x01,0x00000014,20180511\n# I,0x000506C8,0xFF,0x90011010,20160323\n# I,0x000506C9,0x03,0x00000048,20211116\n# I,0x000506CA,0x03,0x00000028,20211116\n# I,0x000506D1,0xFF,0x00000102,20150605\n# I,0x000506E0,0xFF,0x00000018,20141119\n# I,0x000506E1,0xFF,0x0000002A,20150602\n# I,0x000506E2,0xFF,0x0000002E,20150815\n# I,0x000506E3,0x36,0x000000F0,20211112\n# I,0x000506E8,0xFF,0x00000034,20160710\n# I,0x000506F0,0xFF,0x00000010,20160607\n# I,0x000506F1,0x01,0x0000003E,20231005\n# I,0x00060660,0xFF,0x0000000C,20160821\n# I,0x00060661,0xFF,0x0000000E,20170128\n# I,0x00060662,0xFF,0x00000022,20171129\n# I,0x00060663,0x80,0x0000002A,20180417\n# I,0x000606A0,0xFF,0x80000031,20200308\n# I,0x000606A4,0xFF,0x0B000280,20200817\n# I,0x000606A5,0x87,0x0C0002F0,20210308\n# I,0x000606A6,0x87,0x0D0003D1,20230914\n# I,0x000606C0,0xFF,0xFD000220,20210629\n# I,0x000606C1,0x10,0x01000290,20231205\n# I,0x000606E0,0xFF,0x0000000B,20161104\n# I,0x000606E1,0xFF,0x00000108,20190423\n# I,0x000606E4,0xFF,0x0000000C,20190124\n# I,0x000706A0,0xFF,0x00000026,20170712\n# I,0x000706A1,0x01,0x00000040,20230825\n# I,0x000706A8,0x01,0x00000024,20230825\n# I,0x000706E0,0xFF,0x0000002C,20180614\n# I,0x000706E1,0xFF,0x00000042,20190420\n# I,0x000706E2,0xFF,0x00000042,20190420\n# I,0x000706E3,0xFF,0x81000008,20181002\n# I,0x000706E4,0xFF,0x00000046,20190905\n# I,0x000706E5,0x80,0x000000C4,20230914\n# I,0x00080650,0xFF,0x00000018,20180108\n# I,0x00080664,0xFF,0x4C000025,20230926\n# I,0x00080665,0xFF,0x4C000025,20230926\n# I,0x00080667,0xFF,0x4C000025,20230926\n# I,0x000806A0,0xFF,0x00000010,20190507\n# I,0x000806A1,0x10,0x00000033,20230113\n# I,0x000806C0,0xFF,0x00000068,20200402\n# I,0x000806C1,0x80,0x000000B6,20230913\n# I,0x000806C2,0xC2,0x00000036,20230913\n# I,0x000806D0,0xFF,0x00000054,20210507\n# I,0x000806D1,0xC2,0x00000050,20230913\n# I,0x000806E9,0x10,0x000000F4,20230223\n# I,0x000806E9,0xC0,0x000000F4,20230222\n# I,0x000806EA,0xC0,0x000000F4,20230223\n# I,0x000806EB,0xD0,0x000000F4,20230223\n# I,0x000806EC,0x94,0x000000FA,20230716\n# I,0x000806F1,0xFF,0x800003C0,20220327\n# I,0x000806F2,0xFF,0x8C0004E0,20211112\n# I,0x000806F3,0xFF,0x8D000520,20220812\n# I,0x000806F4,0x10,0x2C000390,20240205\n# I,0x000806F4,0x87,0x2B0005C0,20240205\n# I,0x000806F5,0x10,0x2C000390,20240205\n# I,0x000806F5,0x87,0x2B0005C0,20240205\n# I,0x000806F6,0x10,0x2C000390,20240205\n# I,0x000806F6,0x87,0x2B0005C0,20240205\n# I,0x000806F7,0x87,0x2B0005C0,20240205\n# I,0x000806F8,0x10,0x2C000390,20240205\n# I,0x000806F8,0x87,0x2B0005C0,20240205\n# I,0x00090660,0xFF,0x00000009,20200617\n# I,0x00090661,0x01,0x00000019,20230926\n# I,0x00090670,0xFF,0x00000019,20201111\n# I,0x00090671,0xFF,0x0000001C,20210614\n# I,0x00090672,0x07,0x00000035,20231205\n# I,0x00090674,0xFF,0x00000219,20210425\n# I,0x00090675,0x07,0x00000035,20231205\n# I,0x000906A0,0xFF,0x0000001C,20210614\n# I,0x000906A1,0xFF,0x0000011F,20211104\n# I,0x000906A2,0xFF,0x00000315,20220102\n# I,0x000906A3,0x80,0x00000433,20231205\n# I,0x000906A4,0x40,0x00000007,20231207\n# I,0x000906A4,0x80,0x00000433,20231205\n# I,0x000906C0,0x01,0x24000026,20230926\n# I,0x000906E9,0x2A,0x000000F8,20230928\n# I,0x000906EA,0x22,0x000000F6,20230726\n# I,0x000906EB,0x02,0x000000F4,20230223\n# I,0x000906EC,0x22,0x000000F6,20230726\n# I,0x000906ED,0x22,0x000000FC,20230727\n# I,0x000A0650,0xFF,0x000000BE,20191010\n# I,0x000A0651,0xFF,0x000000C2,20191113\n# I,0x000A0652,0x20,0x000000FA,20230716\n# I,0x000A0653,0x22,0x000000FA,20230716\n# I,0x000A0654,0xFF,0x000000C6,20200123\n# I,0x000A0655,0x22,0x000000FA,20230716\n# I,0x000A0660,0x80,0x000000FA,20230716\n# I,0x000A0661,0x80,0x000000FA,20230716\n# I,0x000A0670,0xFF,0x0000002C,20201124\n# I,0x000A0671,0x02,0x0000005E,20230914\n# I,0x000A0680,0xFF,0x80000002,20200121\n# I,0x000A06A1,0xFF,0x00000017,20230518\n# I,0x000A06A2,0xFF,0x00000011,20230627\n# I,0x000A06A4,0xE6,0x0000001C,20240103\n# I,0x000A06C0,0xFF,0x00000011,20230725\n# I,0x000B0670,0xFF,0x0000000E,20220220\n# I,0x000B0671,0x32,0x00000123,20240125\n# I,0x000B06A2,0xE0,0x00004121,20231207\n# I,0x000B06A3,0xE0,0x00004121,20231207\n# I,0x000B06A8,0xE0,0x00004121,20231207\n# I,0x000B06E0,0x11,0x00000017,20231207\n# I,0x000B06F2,0x07,0x00000035,20231205\n# I,0x000B06F5,0x07,0x00000035,20231205\n# I,0x000C06F1,0x87,0x21000230,20240205\n# I,0x000C06F2,0x87,0x21000230,20240205\n# I,0x00FF0671,0xFF,0x00000104,20220419\n# A,0x00000F00,0xFF,0x02000008,20070614\n# A,0x00000F01,0xFF,0x0000001C,20021031\n# A,0x00000F10,0xFF,0x00000003,20020325\n# A,0x00000F11,0xFF,0x0000001F,20030220\n# A,0x00000F48,0xFF,0x00000046,20040719\n# A,0x00000F4A,0xFF,0x00000047,20040719\n# A,0x00000F50,0xFF,0x00000024,20021212\n# A,0x00000F51,0xFF,0x00000025,20030115\n# A,0x00010F50,0xFF,0x00000041,20040225\n# A,0x00020F10,0xFF,0x0000004D,20050428\n# A,0x00040F01,0xFF,0xC0012102,20050916\n# A,0x00040F0A,0xFF,0x00000068,20060920\n# A,0x00040F13,0xFF,0x0000007A,20080508\n# A,0x00040F14,0xFF,0x00000062,20060127\n# A,0x00040F1B,0xFF,0x0000006D,20060920\n# A,0x00040F33,0xFF,0x0000007B,20080514\n# A,0x00060F80,0xFF,0x00000083,20060929\n# A,0x000C0F1B,0xFF,0x0000006E,20060921\n# A,0x000F0F00,0xFF,0x00000005,20020627\n# A,0x000F0F01,0xFF,0x00000015,20020627\n# A,0x00100F00,0xFF,0x01000020,20070326\n# A,0x00100F20,0xFF,0x010000CA,20100331\n# A,0x00100F22,0xFF,0x010000C9,20100331\n# A,0x00100F2A,0xFF,0x01000084,20000101\n# A,0x00100F40,0xFF,0x01000085,20080501\n# A,0x00100F41,0xFF,0x010000DB,20111024\n# A,0x00100F42,0xFF,0x01000092,20081021\n# A,0x00100F43,0xFF,0x010000C8,20100311\n# A,0x00100F52,0xFF,0x010000DB,20000101\n# A,0x00100F53,0xFF,0x010000C8,20000101\n# A,0x00100F62,0xFF,0x010000C7,20100311\n# A,0x00100F80,0xFF,0x010000DA,20111024\n# A,0x00100F81,0xFF,0x010000D9,20111012\n# A,0x00100F91,0xFF,0x010000D9,20000101\n# A,0x00100FA0,0xFF,0x010000DC,20111024\n# A,0x00120F00,0xFF,0x03000002,20100324\n# A,0x00200F30,0xFF,0x02000018,20070921\n# A,0x00200F31,0xFF,0x02000057,20080502\n# A,0x00200F32,0xFF,0x02000034,20080307\n# A,0x00300F01,0xFF,0x0300000E,20101004\n# A,0x00300F10,0xFF,0x03000027,20111209\n# A,0x00500F00,0xFF,0x0500000B,20100601\n# A,0x00500F01,0xFF,0x0500001A,20100908\n# A,0x00500F10,0xFF,0x05000029,20130121\n# A,0x00500F20,0xFF,0x05000119,20130118\n# A,0x00580F00,0xFF,0x0500000B,20100601\n# A,0x00580F01,0xFF,0x0500001A,20100908\n# A,0x00580F10,0xFF,0x05000028,20101124\n# A,0x00580F20,0xFF,0x05000103,20110526\n# A,0x00600F00,0xFF,0x06000017,20101029\n# A,0x00600F01,0xFF,0x0600011F,20110227\n# A,0x00600F10,0xFF,0x06000425,20110408\n# A,0x00600F11,0xFF,0x0600050D,20110627\n# A,0x00600F12,0xFF,0x0600063E,20180207\n# A,0x00600F20,0xFF,0x06000852,20180206\n# A,0x00610F00,0xFF,0x0600100E,20111102\n# A,0x00610F01,0xFF,0x0600111F,20180305\n# A,0x00630F00,0xFF,0x0600301C,20130817\n# A,0x00630F01,0xFF,0x06003109,20180227\n# A,0x00660F00,0xFF,0x06006108,20150302\n# A,0x00660F01,0xFF,0x0600611A,20180126\n# A,0x00670F00,0xFF,0x06006705,20180220\n# A,0x00680F00,0xFF,0x06000017,20101029\n# A,0x00680F01,0xFF,0x0600011F,20110227\n# A,0x00680F10,0xFF,0x06000410,20110314\n# A,0x00690F00,0xFF,0x06001009,20110613\n# A,0x00700F00,0xFF,0x0700002A,20121218\n# A,0x00700F01,0xFF,0x07000110,20180209\n# A,0x00730F00,0xFF,0x07030009,20131206\n# A,0x00730F01,0xFF,0x07030106,20180209\n# A,0x00800F00,0xFF,0x0800002A,20161006\n# A,0x00800F10,0xFF,0x0800100C,20170131\n# A,0x00800F11,0xFF,0x08001138,20190204\n# A,0x00800F12,0xFF,0x0800126E,20211111\n# A,0x00800F82,0xFF,0x0800820D,20190416\n# A,0x00810F00,0xFF,0x08100004,20161120\n# A,0x00810F10,0xFF,0x08101016,20190430\n# A,0x00810F11,0xFF,0x08101103,20190417\n# A,0x00810F80,0xFF,0x08108002,20180605\n# A,0x00810F81,0xFF,0x08108109,20190417\n# A,0x00820F00,0xFF,0x08200002,20180214\n# A,0x00820F01,0xFF,0x08200103,20190417\n# A,0x00830F00,0xFF,0x08300027,20190401\n# A,0x00830F10,0xFF,0x0830107B,20230816\n# A,0x00850F00,0xFF,0x08500004,20180212\n# A,0x00860F00,0xFF,0x0860000E,20200127\n# A,0x00860F01,0xFF,0x0860010C,20231007\n# A,0x00860F81,0xFF,0x08608104,20220328\n# A,0x00870F00,0xFF,0x08700004,20181206\n# A,0x00870F10,0xFF,0x08701033,20231006\n# A,0x00880F40,0xFF,0x08804005,20210312\n# A,0x00890F00,0xFF,0x08900007,20200921\n# A,0x00890F01,0xFF,0x08900103,20201105\n# A,0x00890F02,0xFF,0x08900203,20230915\n# A,0x00890F10,0xFF,0x08901003,20230919\n# A,0x008A0F00,0xFF,0x08A00009,20230814\n# A,0x00A00F00,0xFF,0x0A000033,20200413\n# A,0x00A00F10,0xFF,0x0A001079,20230609\n# A,0x00A00F11,0xFF,0x0A0011D3,20230823\n# A,0x00A00F12,0xFF,0x0A001236,20230831\n# A,0x00A00F80,0xFF,0x0A008005,20230707\n# A,0x00A00F82,0xFF,0x0A008209,20230707\n# A,0x00A10F00,0xFF,0x0A10004B,20220309\n# A,0x00A10F01,0xFF,0x0A100104,20220207\n# A,0x00A10F0B,0xFF,0x0A100B07,20220610\n# A,0x00A10F10,0xFF,0x0A101020,20220913\n# A,0x00A10F11,0xFF,0x0A101144,20230906\n# A,0x00A10F12,0xFF,0x0A101244,20230911\n# A,0x00A10F80,0xFF,0x0A108005,20230613\n# A,0x00A10F81,0xFF,0x0A108105,20230711\n# A,0x00A20F00,0xFF,0x0A200025,20200121\n# A,0x00A20F10,0xFF,0x0A20102B,20230707\n# A,0x00A20F12,0xFF,0x0A20120E,20230707\n# A,0x00A40F00,0xFF,0x0A400016,20210330\n# A,0x00A40F40,0xFF,0x0A404002,20210408\n# A,0x00A40F41,0xFF,0x0A404105,20230707\n# A,0x00A50F00,0xFF,0x0A50000F,20230707\n# A,0x00A60F00,0xFF,0x0A600005,20211220\n# A,0x00A60F11,0xFF,0x0A601119,20230613\n# A,0x00A60F12,0xFF,0x0A601206,20230613\n# A,0x00A70F00,0xFF,0x0A700003,20220517\n# A,0x00A70F40,0xFF,0x0A704001,20220721\n# A,0x00A70F41,0xFF,0x0A704104,20230713\n# A,0x00A70F42,0xFF,0x0A704202,20230713\n# A,0x00A70F52,0xFF,0x0A705205,20240112\n# A,0x00A70F80,0xFF,0x0A708006,20240112\n# A,0x00A70FC0,0xFF,0x0A70C002,20230713\n# A,0x00AA0F00,0xFF,0x0AA00009,20221006\n# A,0x00AA0F01,0xFF,0x0AA00116,20230619\n# A,0x00AA0F02,0xFF,0x0AA00213,20230911\n# A,0x00B40F00,0xFF,0x0B40002D,20231027\n# A,0x00B40F40,0xFF,0x0B40400C,20240327\n"
        }
      ]
    }
  ]
}