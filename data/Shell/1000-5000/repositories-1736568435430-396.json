{
  "metadata": {
    "timestamp": 1736568435430,
    "page": 396,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nix-community/nix-direnv",
      "stars": 1949,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".envrc",
          "type": "blob",
          "size": 0.0888671875,
          "content": "# shellcheck shell=bash\nstrict_env\nsource ./direnvrc\nwatch_file direnvrc ./*.nix\nuse flake\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1025390625,
          "content": ".direnv/\n/template/flake.lock\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n"
        },
        {
          "name": ".mergify.yml",
          "type": "blob",
          "size": 0.4443359375,
          "content": "queue_rules:\n  - name: default\n    merge_conditions:\n      - check-success=buildbot/nix-build\n      - check-success=tests (ubuntu-latest, stable)\n      - check-success=tests (ubuntu-latest, latest)\n      - check-success=tests (ubuntu-latest, bash4)\n    batch_size: 5\n    merge_method: rebase\npull_request_rules:\n  - name: merge using the merge queue\n    conditions:\n      - base=master\n      - label~=merge-queue|dependencies\n    actions:\n      queue: {}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "MIT License\n\nCopyright (c) 2019 Nix community projects\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.2412109375,
          "content": "# nix-direnv\n\n![Test](https://github.com/nix-community/nix-direnv/workflows/Test/badge.svg)\n\nA faster, persistent implementation of `direnv`'s `use_nix` and `use_flake`, to\nreplace the built-in one.\n\nProminent features:\n\n- significantly faster after the first run by caching the `nix-shell`\n  environment\n- prevents garbage collection of build dependencies by symlinking the resulting\n  shell derivation in the user's `gcroots` (Life is too short to lose your\n  project's build cache if you are on a flight with no internet connection)\n\n## Why not use `lorri` instead?\n\nCompared to [lorri](https://github.com/nix-community/lorri), nix-direnv is\nsimpler (and requires no external daemon) and supports flakes. Additionally,\nlorri can sometimes re-evaluate the entirety of nixpkgs on every change (leading\nto perpetual high CPU load).\n\n## Installation\n\n> **Heads up**: nix-direnv requires a modern Bash. MacOS ships with bash 3.2\n> from 2007. As a work-around we suggest that macOS users install `direnv` via\n> Nix or Homebrew. There are different ways to install nix-direnv, pick your\n> favourite:\n\n<details>\n  <summary> Via home-manager (Recommended)</summary>\n\n### Via home-manager\n\nNote that while the home-manager integration is recommended, some use cases\nrequire the use of features only present in some versions of nix-direnv. It is\nmuch harder to control the version of nix-direnv installed with this method. If\nyou require such specific control, please use another method of installing\nnix-direnv.\n\nIn `$HOME/.config/home-manager/home.nix` add\n\n```Nix\n{\n  # ...other config, other config...\n\n  programs = {\n    direnv = {\n      enable = true;\n      enableBashIntegration = true; # see note on other shells below\n      nix-direnv.enable = true;\n    };\n\n    bash.enable = true; # see note on other shells below\n  };\n}\n```\n\nCheck the current\n[Home Manager Options](https://mipmip.github.io/home-manager-option-search/?query=direnv)\nfor integration with shells other than Bash. Be sure to also allow\n`home-manager` to manage your shell with `programs.<your_shell>.enable = true`.\n\n</details>\n<details>\n  <summary>Direnv's source_url</summary>\n\n### Direnv source_url\n\nPut the following lines in your `.envrc`:\n\n```bash\nif ! has nix_direnv_version || ! nix_direnv_version 3.0.6; then\n  source_url \"https://raw.githubusercontent.com/nix-community/nix-direnv/3.0.6/direnvrc\" \"sha256-RYcUJaRMf8oF5LznDrlCXbkOQrywm0HDv1VjYGaJGdM=\"\nfi\n```\n\n</details>\n\n<details>\n  <summary>Via system configuration on NixOS</summary>\n\n### Via system configuration on NixOS\n\nFor NixOS 23.05+ all that's required is\n\n```Nix\n{\n  programs.direnv.enable = true;\n}\n```\n\nother available options are:\n\n```Nix\n{ pkgs, ... }: {\n  #set to default values\n  programs.direnv = {\n    package = pkgs.direnv;\n    silent = false;\n    loadInNixShell = true;\n    direnvrcExtra = \"\";\n    nix-direnv = {\n      enable = true;\n      package = pkgs.nix-direnv;\n    };\n  }\n```\n\n</details>\n\n<details>\n  <summary>With `nix profile`</summary>\n\n### With `nix profile`\n\nAs **non-root** user do the following:\n\n```shell\nnix profile install nixpkgs#nix-direnv\n```\n\nThen add nix-direnv to `$HOME/.config/direnv/direnvrc`:\n\n```bash\nsource $HOME/.nix-profile/share/nix-direnv/direnvrc\n```\n\n</details>\n\n<details>\n  <summary>From source</summary>\n\n### From source\n\nClone the repository to some directory and then source the direnvrc from this\nrepository in your own `~/.config/direnv/direnvrc`:\n\n```bash\n# put this in ~/.config/direnv/direnvrc\nsource $HOME/nix-direnv/direnvrc\n```\n\n</details>\n\n## Usage example\n\nEither add `shell.nix` or a `default.nix` to the project directory:\n\n```nix\n# save this as shell.nix\n{ pkgs ? import <nixpkgs> {}}:\n\npkgs.mkShell {\n  packages = [ pkgs.hello ];\n}\n```\n\nThen add the line `use nix` to your envrc:\n\n```console\n$ echo \"use nix\" >> .envrc\n$ direnv allow\n```\n\nIf you haven't used direnv before, make sure to\n[hook it into your shell](https://direnv.net/docs/hook.html) first.\n\n### Using a non-standard file name\n\nYou may use a different file name than `shell.nix` or `default.nix` by passing\nthe file name in `.envrc`, e.g.:\n\n```console\n$ echo \"use nix foo.nix\" >> .envrc\n```\n\n## Flakes support\n\nnix-direnv also comes with an alternative `use_flake` implementation. The code\nis tested and does work but the upstream flake api is not finalized, so we\ncannot guarantee stability after a nix upgrade.\n\nLike `use_nix`, our `use_flake` will prevent garbage collection of downloaded\npackages, including flake inputs.\n\n### Creating a new flake-native project\n\nThis repository ships with a\n[flake template](https://github.com/nix-community/nix-direnv/tree/master/templates/flake).\nwhich provides a basic flake with devShell integration and a basic `.envrc`.\n\nTo make use of this template, you may issue the following command:\n\n```console\n$ nix flake new -t github:nix-community/nix-direnv <desired output path>\n```\n\n### Integrating with a existing flake\n\n```console\n$ echo \"use flake\" >> .envrc && direnv allow\n```\n\nThe `use flake` line also takes an additional arbitrary flake parameter, so you\ncan point at external flakes as follows:\n\n```bash\nuse flake ~/myflakes#project\n```\n\n### Advanced usage\n\n#### use flake\n\nUnder the covers, `use_flake` calls `nix print-dev-env`. The first argument to\nthe `use_flake` function is the flake expression to use, and all other arguments\nare proxied along to the call to `print-dev-env`. You may make use of this fact\nfor some more arcane invocations.\n\nFor instance, if you have a flake that needs to be called impurely under some\nconditions, you may wish to pass `--impure` to the `print-dev-env` invocation so\nthat the environment of the calling shell is passed in.\n\nYou can do that as follows:\n\n```console\n$ echo \"use flake . --impure\" > .envrc\n$ direnv allow\n```\n\n#### use nix\n\nLike `use flake`, `use nix` now uses `nix print-dev-env`. Due to historical\nreasons, the argument parsing emulates `nix shell`.\n\nThis leads to some limitations in what we can reasonably parse.\n\nCurrently, all single-word arguments and some well-known double arguments will\nbe interpreted or passed along.\n\n#### Manual reload of the nix environment\n\nTo avoid delays and time consuming rebuilds at unexpected times, you can use\nnix-direnv in the \"manual reload\" mode. nix-direnv will then tell you when the\nnix environment is no longer up to date. You can then decide yourself when you\nwant to reload the nix environment.\n\nTo activate manual mode, use `nix_direnv_manual_reload` in your `.envrc` like\nthis:\n\n```shell\nnix_direnv_manual_reload\nuse nix # or use flake\n```\n\nTo reload your nix environment, use the `nix-direnv-reload` command:\n\n```console\n$ nix-direnv-reload\n```\n\n##### Known arguments\n\n- `-p`: Starts a list of packages to install; consumes all remaining arguments\n- `--include` / `-I`: Add the following path to the list of lookup locations for\n  `<...>` file names\n- `--attr` / `-A`: Specify the output attribute to utilize\n\n`--command`, `--run`, `--exclude`, `--pure`, `-i`, and `--keep` are explicitly\nignored.\n\nAll single word arguments (`-j4`, `--impure` etc) are passed to the underlying\nnix invocation.\n\n#### Tracked files\n\nAs a convenience, `nix-direnv` adds common files to direnv's watched file list\nautomatically.\n\nThe list of additionally tracked files is as follows:\n\n- for `use nix`:\n  - `~/.direnvrc`\n  - `~/.config/direnv/direnvrc`\n  - `.envrc`,\n  - A single nix file. In order of preference:\n    - The file argument to `use nix`\n    - `default.nix` if it exists\n    - `shell.nix` if it exists\n\n- for `use flake`:\n  - `~/.direnvrc`\n  - `~/.config/direnv/direnvrc`\n  - `.envrc`\n  - `flake.nix`\n  - `flake.lock`\n  - `devshell.toml` if it exists\n\nUsers are free to use direnv's builtin `watch_file` function to track additional\nfiles. `watch_file` must be invoked before either `use flake` or `use nix` to\ntake effect.\n\n#### Environment Variables\n\nnix-direnv sets the following environment variables for user consumption. All\nother environment variables are either a product of the underlying nix\ninvocation or are purely incidental and should not be relied upon.\n\n- `NIX_DIRENV_DID_FALLBACK`: Set when the current revision of your nix shell or\n  flake's devShell are invalid and nix-direnv has loaded the last known working\n  shell.\n\nnix-direnv also respects the following environment variables for configuration.\n\n- `NIX_DIRENV_FALLBACK_NIX`: Can be set to a fallback Nix binary location, to be\n  used when a compatible one isn't available in `PATH`. Defaults to\n  `config.nix.package` if installed via the NixOS module, otherwise needs to be\n  set manually. Leave unset or empty to fail immediately when a Nix\n  implementation can't be found on `PATH`.\n\n## General direnv tips\n\n- [Changing where direnv stores its cache][cache_location]\n- [Quickly setting up direnv in a new nix project][new_project]\n- [Disable the diff notice (requires direnv 2.34+)][hide_diff_notice]: Note that\n  this goes into direnv's TOML configuration!\n\n[cache_location]: https://github.com/direnv/direnv/wiki/Customizing-cache-location\n[new_project]: https://github.com/nix-community/nix-direnv/wiki/Shell-integration\n[hide_diff_notice]: https://direnv.net/man/direnv.toml.1.html#codehideenvdiffcode\n\n## Other projects in the field\n\n- [lorri](https://github.com/nix-community/lorri)\n- [sorri](https://github.com/nmattia/sorri)\n- [nixify](https://github.com/kalbasit/nur-packages/blob/master/pkgs/nixify/envrc)\n- [lorelei](https://github.com/shajra/direnv-nix-lorelei)\n"
        },
        {
          "name": "default.nix",
          "type": "blob",
          "size": 1.693359375,
          "content": "{\n  resholve,\n  lib,\n  coreutils,\n  nix,\n  writeText,\n}:\n\n# resholve does not yet support `finalAttrs` call pattern hence `rec`\n# https://github.com/abathur/resholve/issues/107\nresholve.mkDerivation rec {\n  pname = \"nix-direnv\";\n  version = \"3.0.6\";\n\n  src = builtins.path {\n    path = ./.;\n    name = pname;\n  };\n\n  installPhase = ''\n    install -m400 -D direnvrc $out/share/${pname}/direnvrc\n  '';\n\n  solutions = {\n    default = {\n      scripts = [ \"share/${pname}/direnvrc\" ];\n      interpreter = \"none\";\n      inputs = [ coreutils ];\n      fake = {\n        builtin = [\n          \"PATH_add\"\n          \"direnv_layout_dir\"\n          \"has\"\n          \"log_error\"\n          \"log_status\"\n          \"watch_file\"\n        ];\n        function = [\n          # not really a function - this is in an else branch for macOS/homebrew that\n          # cannot be reached when built with nix\n          \"shasum\"\n        ];\n        external = [\n          # We want to reference the ambient Nix when possible, and have custom logic\n          # for the fallback\n          \"nix\"\n        ];\n      };\n      keep = {\n        \"$cmd\" = true;\n        \"$direnv\" = true;\n\n        # Nix fallback implementation\n        \"$_nix_direnv_nix\" = true;\n        \"$ambient_nix\" = true;\n        \"$NIX_DIRENV_FALLBACK_NIX\" = true;\n      };\n      prologue =\n        (writeText \"prologue.sh\" ''\n          NIX_DIRENV_SKIP_VERSION_CHECK=1\n          NIX_DIRENV_FALLBACK_NIX=''${NIX_DIRENV_FALLBACK_NIX:-${lib.getExe nix}}\n        '').outPath;\n    };\n  };\n\n  meta = with lib; {\n    description = \"A fast, persistent use_nix implementation for direnv\";\n    homepage = \"https://github.com/nix-community/nix-direnv\";\n    license = licenses.mit;\n    platforms = platforms.unix;\n  };\n}\n"
        },
        {
          "name": "direnvrc",
          "type": "blob",
          "size": 14.56640625,
          "content": "# -*- mode: sh -*-\n# shellcheck shell=bash\n\nNIX_DIRENV_VERSION=3.0.6\n\n# min required versions\nBASH_MIN_VERSION=4.4\nDIRENV_MIN_VERSION=2.21.3\nNIX_MIN_VERSION=2.4\n\n_NIX_DIRENV_LOG_PREFIX=\"nix-direnv: \"\n\n_nix_direnv_info() {\n  log_status \"${_NIX_DIRENV_LOG_PREFIX}$*\"\n}\n\n_nix_direnv_warning() {\n  if [[ -n $DIRENV_LOG_FORMAT ]]; then\n    local msg=$* color_normal='' color_warning=''\n    if [[ -t 2 ]]; then\n      color_normal=\"\\e[m\"\n      color_warning=\"\\e[33m\"\n    fi\n    # shellcheck disable=SC2059\n    printf \"${color_warning}${DIRENV_LOG_FORMAT}${color_normal}\\n\" \\\n      \"${_NIX_DIRENV_LOG_PREFIX}${msg}\" >&2\n  fi\n}\n\n_nix_direnv_error() { log_error \"${_NIX_DIRENV_LOG_PREFIX}$*\"; }\n\n_nix_direnv_nix=\"\"\n\n_nix() {\n  ${_nix_direnv_nix} --extra-experimental-features \"nix-command flakes\" \"$@\"\n}\n\n_require_version() {\n  local cmd=$1 version=$2 required=$3\n  if ! printf \"%s\\n\" \"$required\" \"$version\" | LC_ALL=C sort -c -V 2>/dev/null; then\n    _nix_direnv_error \\\n      \"minimum required $(basename \"$cmd\") version is $required (installed: $version)\"\n    return 1\n  fi\n}\n\n_require_cmd_version() {\n  local cmd=$1 required=$2 version\n  if ! has \"$cmd\"; then\n    _nix_direnv_error \"command not found: $cmd\"\n    return 1\n  fi\n  version=$($cmd --version)\n  [[ $version =~ ([0-9]+\\.[0-9]+\\.[0-9]+) ]]\n  _require_version \"$cmd\" \"${BASH_REMATCH[1]}\" \"$required\"\n}\n\n_nix_direnv_resolve_nix() {\n  local ambient_nix\n\n  if ambient_nix=$(command -v nix); then\n    if _require_cmd_version \"${ambient_nix}\" \"${NIX_MIN_VERSION}\"; then\n      echo \"${ambient_nix}\"\n      return 0\n    else\n      _nix_direnv_warning \"Nix version in PATH is too old, wanted ${NIX_MIN_VERSION}+, got $(${ambient_nix} --version), will attempt fallback\"\n    fi\n  else\n    _nix_direnv_warning \"Could not find Nix in PATH, will attempt fallback\"\n  fi\n\n  if [ -n \"${NIX_DIRENV_FALLBACK_NIX}\" ]; then\n    if _require_cmd_version \"${NIX_DIRENV_FALLBACK_NIX}\" \"${NIX_MIN_VERSION}\"; then\n      echo \"${NIX_DIRENV_FALLBACK_NIX}\"\n      return 0\n    else\n      _nix_direnv_error \"Fallback Nix version is too old, wanted ${NIX_MIN_VERSION}+, got $(${NIX_DIRENV_FALLBACK_NIX} --version)\"\n      return 1\n    fi\n  else\n    _nix_direnv_error \"Could not find fallback Nix binary, please add Nix to PATH or set NIX_DIRENV_FALLBACK_NIX\"\n    return 1\n  fi\n}\n\n_nix_direnv_preflight() {\n  if [[ -z $direnv ]]; then\n    # shellcheck disable=2016\n    _nix_direnv_error '$direnv environment variable was not defined. Was this script run inside direnv?'\n    return 1\n  fi\n\n  # check command min versions\n  if [[ -z ${NIX_DIRENV_SKIP_VERSION_CHECK:-} ]]; then\n    # bash check uses $BASH_VERSION with _require_version instead of\n    # _require_cmd_version because _require_cmd_version uses =~ operator which would be\n    # a syntax error on bash < 3\n    if ! _require_version bash \"$BASH_VERSION\" \"$BASH_MIN_VERSION\" ||\n      # direnv stdlib defines $direnv\n      ! _require_cmd_version \"$direnv\" \"$DIRENV_MIN_VERSION\"; then\n      return 1\n    fi\n  fi\n\n  if ! _nix_direnv_nix=$(_nix_direnv_resolve_nix); then\n    return 1\n  fi\n\n  local layout_dir\n  layout_dir=$(direnv_layout_dir)\n\n  if [[ ! -d \"$layout_dir/bin\" ]]; then\n    mkdir -p \"$layout_dir/bin\"\n  fi\n  # N.B. This script relies on variable expansion in *this* shell.\n  # (i.e. The written out file will have the variables expanded)\n  # If the source path changes, the script becomes broken.\n  # Because direnv_layout_dir is user controlled,\n  # we can't assume to be able to reverse it to get the source dir\n  # So there's little to be done about this.\n  cat >\"${layout_dir}/bin/nix-direnv-reload\" <<-EOF\n#!/usr/bin/env bash\nset -e\nif [[ ! -d \"$PWD\" ]]; then\n  echo \"Cannot find source directory; Did you move it?\"\n  echo \"(Looking for \"$PWD\")\"\n  echo 'Cannot force reload with this script - use \"direnv reload\" manually and then try again'\n  exit 1\nfi\n\n# rebuild the cache forcefully\n_nix_direnv_force_reload=1 direnv exec \"$PWD\" true\n\n# Update the mtime for .envrc.\n# This will cause direnv to reload again - but without re-building.\ntouch \"$PWD/.envrc\"\n\n# Also update the timestamp of whatever profile_rc we have.\n# This makes sure that we know we are up to date.\ntouch -r \"$PWD/.envrc\" \"${layout_dir}\"/*.rc\nEOF\n\n  chmod +x \"${layout_dir}/bin/nix-direnv-reload\"\n\n  PATH_add \"${layout_dir}/bin\"\n}\n\n# Usage: nix_direnv_version <version_at_least>\n#\n# Checks that the nix-direnv version is at least as old as <version_at_least>.\nnix_direnv_version() {\n  _require_version nix-direnv $NIX_DIRENV_VERSION \"$1\"\n}\n\n_nix_export_or_unset() {\n  local key=$1 value=$2\n  if [[ $value == __UNSET__ ]]; then\n    unset \"$key\"\n  else\n    export \"$key=$value\"\n  fi\n}\n\n_nix_import_env() {\n  local profile_rc=$1\n\n  local -A values_to_restore=(\n    [\"NIX_BUILD_TOP\"]=${NIX_BUILD_TOP:-__UNSET__}\n    [\"TMP\"]=${TMP:-__UNSET__}\n    [\"TMPDIR\"]=${TMPDIR:-__UNSET__}\n    [\"TEMP\"]=${TEMP:-__UNSET__}\n    [\"TEMPDIR\"]=${TEMPDIR:-__UNSET__}\n    [\"terminfo\"]=${terminfo:-__UNSET__}\n  )\n  local old_xdg_data_dirs=${XDG_DATA_DIRS:-}\n\n  # On the first run in manual mode, the profile_rc does not exist.\n  if [[ ! -e $profile_rc ]]; then\n    return\n  fi\n\n  eval \"$(<\"$profile_rc\")\"\n  # `nix print-dev-env` will create a temporary directory and use it as TMPDIR\n  # We cannot rely on this directory being available at all times,\n  # as it may be garbage collected.\n  # Instead - just remove it immediately.\n  # Use recursive & force as it may not be empty.\n  if [[ -n ${NIX_BUILD_TOP+x} && $NIX_BUILD_TOP == */nix-shell.* && -d $NIX_BUILD_TOP ]]; then\n    rm -rf \"$NIX_BUILD_TOP\"\n  fi\n\n  for key in \"${!values_to_restore[@]}\"; do\n    _nix_export_or_unset \"$key\" \"${values_to_restore[${key}]}\"\n  done\n\n  local new_xdg_data_dirs=${XDG_DATA_DIRS:-}\n  export XDG_DATA_DIRS=\n  local IFS=:\n  for dir in $new_xdg_data_dirs${old_xdg_data_dirs:+:}$old_xdg_data_dirs; do\n    dir=\"${dir%/}\" # remove trailing slashes\n    if [[ :$XDG_DATA_DIRS: == *:$dir:* ]]; then\n      continue # already present, skip\n    fi\n    XDG_DATA_DIRS=\"$XDG_DATA_DIRS${XDG_DATA_DIRS:+:}$dir\"\n  done\n}\n\n_nix_add_gcroot() {\n  local storepath=$1\n  local symlink=$2\n  _nix build --out-link \"$symlink\" \"$storepath\"\n}\n\n_nix_clean_old_gcroots() {\n  local layout_dir=$1\n\n  rm -rf \"$layout_dir/flake-inputs/\"\n  rm -f \"$layout_dir\"/{nix,flake}-profile*\n}\n\n_nix_argsum_suffix() {\n  local out checksum\n  if [ -n \"$1\" ]; then\n\n    if has sha1sum; then\n      out=$(sha1sum <<<\"$1\")\n    elif has shasum; then\n      out=$(shasum <<<\"$1\")\n    else\n      # degrade gracefully both tools are not present\n      return\n    fi\n    read -r checksum _ <<<\"$out\"\n    echo \"-$checksum\"\n  fi\n}\n\nnix_direnv_watch_file() {\n  # shellcheck disable=2016\n  log_error '`nix_direnv_watch_file` is deprecated - use `watch_file`'\n  watch_file \"$@\"\n}\n\n_nix_direnv_watches() {\n  local -n _watches=$1\n  if [[ -z ${DIRENV_WATCHES-} ]]; then\n    return\n  fi\n  while IFS= read -r line; do\n    local regex='\"[Pp]ath\": \"(.+)\"$'\n    if [[ $line =~ $regex ]]; then\n      local path=\"${BASH_REMATCH[1]}\"\n      if [[ $path == \"${XDG_DATA_HOME:-${HOME:-/var/empty}/.local/share}/direnv/allow/\"* ]]; then\n        continue\n      fi\n      # expand new lines and other json escapes\n      # shellcheck disable=2059\n      path=$(printf \"$path\")\n      _watches+=(\"$path\")\n    fi\n  done < <($direnv show_dump \"${DIRENV_WATCHES}\")\n}\n\n: \"${_nix_direnv_manual_reload:=0}\"\nnix_direnv_manual_reload() {\n  _nix_direnv_manual_reload=1\n}\n\n_nix_direnv_warn_manual_reload() {\n  if [[ -e $1 ]]; then\n    _nix_direnv_warning 'cache is out of date. use \"nix-direnv-reload\" to reload'\n  else\n    _nix_direnv_warning 'cache does not exist. use \"nix-direnv-reload\" to create it'\n  fi\n}\n\nuse_flake() {\n  if ! _nix_direnv_preflight; then\n    return 1\n  fi\n\n  flake_expr=\"${1:-.}\"\n  flake_uri=\"${flake_expr%#*}\"\n  flake_dir=${flake_uri#\"path:\"}\n\n  if [[ $flake_expr == -* ]]; then\n    local message=\"the first argument must be a flake expression\"\n    if [[ -n ${2:-} ]]; then\n      _nix_direnv_error \"$message\"\n      return 1\n    else\n      _nix_direnv_error \"$message. did you mean 'use flake . $1'?\"\n      return 1\n    fi\n  fi\n\n  local files_to_watch\n  files_to_watch=(\"$HOME/.direnvrc\" \"$HOME/.config/direnv/direnvrc\")\n\n  if [[ -d $flake_dir ]]; then\n    files_to_watch+=(\"$flake_dir/flake.nix\" \"$flake_dir/flake.lock\" \"$flake_dir/devshell.toml\")\n  fi\n\n  watch_file \"${files_to_watch[@]}\"\n\n  local layout_dir profile\n  layout_dir=$(direnv_layout_dir)\n  profile=\"${layout_dir}/flake-profile$(_nix_argsum_suffix \"$flake_expr\")\"\n  local profile_rc=\"${profile}.rc\"\n  local flake_inputs=\"${layout_dir}/flake-inputs/\"\n\n  local need_update=0\n  local watches\n  _nix_direnv_watches watches\n  local file=\n  for file in \"${watches[@]}\"; do\n    if [[ $file -nt $profile_rc ]]; then\n      need_update=1\n      break\n    fi\n  done\n\n  if [[ ! -e $profile ||\n    ! -e $profile_rc ||\n    $need_update -eq 1 ]] \\\n    ; then\n    if [[ $_nix_direnv_manual_reload -eq 1 && -z ${_nix_direnv_force_reload-} ]]; then\n      _nix_direnv_warn_manual_reload \"$profile_rc\"\n\n    else\n      local tmp_profile_rc\n      local tmp_profile=\"${layout_dir}/flake-tmp-profile.$$\"\n      if tmp_profile_rc=$(_nix print-dev-env --profile \"$tmp_profile\" \"$@\"); then\n        # If we've gotten here, the user's current devShell is valid and we should cache it\n        _nix_clean_old_gcroots \"$layout_dir\"\n\n        # We need to update our cache\n        echo \"$tmp_profile_rc\" >\"$profile_rc\"\n        _nix_add_gcroot \"$tmp_profile\" \"$profile\"\n        rm -f \"$tmp_profile\" \"$tmp_profile\"*\n\n        # also add garbage collection root for source\n        local flake_input_paths\n        mkdir -p \"$flake_inputs\"\n        flake_input_paths=$(_nix flake archive \\\n          --json --no-write-lock-file \\\n          -- \"$flake_uri\")\n\n        while [[ $flake_input_paths =~ /nix/store/[^\\\"]+ ]]; do\n          local store_path=\"${BASH_REMATCH[0]}\"\n          _nix_add_gcroot \"${store_path}\" \"${flake_inputs}/${store_path##*/}\"\n          flake_input_paths=\"${flake_input_paths/${store_path}/}\"\n        done\n\n        _nix_direnv_info \"Renewed cache\"\n      else\n        # The user's current flake failed to evaluate,\n        # but there is already a prior profile_rc,\n        # which is probably more useful than nothing.\n        # Fallback to use that (which means just leaving profile_rc alone!)\n        _nix_direnv_warning \"Evaluating current devShell failed. Falling back to previous environment!\"\n        export NIX_DIRENV_DID_FALLBACK=1\n      fi\n    fi\n  else\n    if [[ -e ${profile_rc} ]]; then\n      # Our cache is valid, use that\n      _nix_direnv_info \"Using cached dev shell\"\n    else\n      # We don't have a profile_rc to use!\n      _nix_direnv_error \"use_flake failed - Is your flake's devShell working?\"\n      return 1\n    fi\n  fi\n\n  _nix_import_env \"$profile_rc\"\n}\n\nuse_nix() {\n  if ! _nix_direnv_preflight; then\n    return 1\n  fi\n\n  local layout_dir path version\n  layout_dir=$(direnv_layout_dir)\n  if path=$(_nix eval --impure --expr \"<nixpkgs>\" 2>/dev/null); then\n    if [[ -f \"${path}/.version-suffix\" ]]; then\n      version=$(<\"${path}/.version-suffix\")\n    elif [[ -f \"${path}/.git/HEAD\" ]]; then\n      local head\n      read -r head <\"${path}/.git/HEAD\"\n      local regex=\"ref: (.*)\"\n      if [[ $head =~ $regex ]]; then\n        read -r version <\"${path}/.git/${BASH_REMATCH[1]}\"\n      else\n        version=\"$head\"\n      fi\n    elif [[ -f \"${path}/.version\" && ${path} == \"/nix/store/\"* ]]; then\n      # borrow some bits from the store path\n      local version_prefix\n      read -r version_prefix < <(\n        cat \"${path}/.version\"\n        echo\n      )\n      version=\"${version_prefix}-${path:11:16}\"\n    fi\n  fi\n\n  local profile\n  profile=\"${layout_dir}/nix-profile-${version:-unknown}$(_nix_argsum_suffix \"$*\")\"\n  local profile_rc=\"${profile}.rc\"\n\n  local in_packages=0\n  local attribute=\n  local packages=\"\"\n  local extra_args=()\n\n  local nixfile=\n  if [[ -e \"shell.nix\" ]]; then\n    nixfile=\"./shell.nix\"\n  elif [[ -e \"default.nix\" ]]; then\n    nixfile=\"./default.nix\"\n  fi\n\n  while [[ $# -gt 0 ]]; do\n    i=\"$1\"\n    shift\n\n    case $i in\n    -p | --packages)\n      in_packages=1\n      ;;\n    --command | --run | --exclude)\n      # These commands are unsupported\n      # ignore them\n      shift\n      ;;\n    --pure | -i | --keep)\n      # These commands are unsupported (but take no argument)\n      # ignore them\n      ;;\n    --include | -I)\n      extra_args+=(\"$i\" \"${1:-}\")\n      shift\n      ;;\n    --attr | -A)\n      attribute=\"${1:-}\"\n      shift\n      ;;\n    --option | -o | --arg | --argstr)\n      extra_args+=(\"$i\" \"${1:-}\" \"${2:-}\")\n      shift\n      shift\n      ;;\n    -*)\n      # Other arguments are assumed to be of a single arg form\n      # (--foo=bar or -j4)\n      extra_args+=(\"$i\")\n      ;;\n    *)\n      if [[ $in_packages -eq 1 ]]; then\n        packages+=\" $i\"\n      else\n        nixfile=$i\n      fi\n      ;;\n    esac\n  done\n\n  watch_file \"$HOME/.direnvrc\" \"$HOME/.config/direnv/direnvrc\" \"shell.nix\" \"default.nix\"\n\n  local need_update=0\n  local watches\n  _nix_direnv_watches watches\n  local file=\n  for file in \"${watches[@]}\"; do\n    if [[ $file -nt $profile_rc ]]; then\n      need_update=1\n      break\n    fi\n  done\n\n  if [[ ! -e $profile ||\n    ! -e $profile_rc ||\n    $need_update -eq 1 ]] \\\n    ; then\n    if [[ $_nix_direnv_manual_reload -eq 1 && -z ${_nix_direnv_force_reload-} ]]; then\n      _nix_direnv_warn_manual_reload \"$profile_rc\"\n    else\n      local tmp_profile=\"${layout_dir}/nix-tmp-profile.$$\"\n      local tmp_profile_rc\n      if [[ -n $packages ]]; then\n        extra_args+=(\"--expr\" \"with import <nixpkgs> {}; mkShell { buildInputs = [ $packages ]; }\")\n      else\n        # figure out what attribute we should build\n        if [[ -z $attribute ]]; then\n          extra_args+=(\"--file\" \"$nixfile\")\n        else\n          extra_args+=(\"--expr\" \"(import ${nixfile} {}).${attribute}\")\n        fi\n      fi\n\n      # Some builtin nix tooling depends on this variable being set BEFORE their invocation to change their behavior\n      # (notably haskellPackages.developPackage returns an env if this is set)\n      # This allows us to more closely mimic nix-shell.\n      export IN_NIX_SHELL=\"impure\"\n\n      if tmp_profile_rc=$(_nix \\\n        print-dev-env \\\n        --profile \"$tmp_profile\" \\\n        --impure \\\n        \"${extra_args[@]}\"); then\n        _nix_clean_old_gcroots \"$layout_dir\"\n\n        echo \"$tmp_profile_rc\" >\"$profile_rc\"\n        _nix_add_gcroot \"$tmp_profile\" \"$profile\"\n        rm -f \"$tmp_profile\" \"$tmp_profile\"*\n        _nix_direnv_info \"Renewed cache\"\n      else\n        _nix_direnv_warning \"Evaluating current nix shell failed. Falling back to previous environment!\"\n        export NIX_DIRENV_DID_FALLBACK=1\n      fi\n    fi\n  else\n    if [[ -e ${profile_rc} ]]; then\n      _nix_direnv_info \"Using cached dev shell\"\n    else\n      _nix_direnv_error \"use_nix failed - Is your nix shell working?\"\n      return 1\n    fi\n  fi\n\n  _nix_import_env \"$profile_rc\"\n\n}\n"
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 1.6142578125,
          "content": "{\n  \"nodes\": {\n    \"flake-parts\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": [\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1725234343,\n        \"narHash\": \"sha256-+ebgonl3NbiKD2UD0x4BszCZQ6sTfL4xioaM49o5B3Y=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"567b938d64d4b4112ee253b9274472dc3a346eb6\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1725194671,\n        \"narHash\": \"sha256-tLGCFEFTB5TaOKkpfw3iYT9dnk4awTP/q4w+ROpMfuw=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"b833ff01a0d694b910daca6e2ff4a3f26dee478c\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixpkgs-unstable\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts\",\n        \"nixpkgs\": \"nixpkgs\",\n        \"treefmt-nix\": \"treefmt-nix\"\n      }\n    },\n    \"treefmt-nix\": {\n      \"inputs\": {\n        \"nixpkgs\": [\n          \"nixpkgs\"\n        ]\n      },\n      \"locked\": {\n        \"lastModified\": 1724833132,\n        \"narHash\": \"sha256-F4djBvyNRAXGusJiNYInqR6zIMI3rvlp6WiKwsRISos=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"rev\": \"3ffd842a5f50f435d3e603312eefa4790db46af5\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"treefmt-nix\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 2.1943359375,
          "content": "{\n  description = \"A faster, persistent implementation of `direnv`'s `use_nix`, to replace the built-in one.\";\n\n  nixConfig.extra-substituters = [ \"https://cache.thalheim.io\" ];\n  nixConfig.extra-trusted-public-keys = [\n    \"cache.thalheim.io-1:R7msbosLEZKrxk/lKxf9BTjOOH7Ax3H0Qj0/6wiHOgc=\"\n  ];\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";\n    flake-parts = {\n      url = \"github:hercules-ci/flake-parts\";\n      inputs.nixpkgs-lib.follows = \"nixpkgs\";\n    };\n    treefmt-nix = {\n      url = \"github:numtide/treefmt-nix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs =\n    inputs@{ flake-parts, ... }:\n    flake-parts.lib.mkFlake { inherit inputs; } (\n      { lib, ... }:\n      {\n        imports = [\n          ./treefmt.nix\n          ./pkgs/bash4/flake-module.nix\n        ];\n        systems = [\n          \"aarch64-linux\"\n          \"x86_64-linux\"\n\n          \"x86_64-darwin\"\n          \"aarch64-darwin\"\n        ];\n        perSystem =\n          {\n            config,\n            pkgs,\n            self',\n            ...\n          }:\n          {\n            packages = {\n              nix-direnv = pkgs.callPackage ./default.nix { };\n              default = config.packages.nix-direnv;\n              test-runner-stable = pkgs.callPackage ./test-runner.nix { nixVersion = \"stable\"; };\n              test-runner-latest = pkgs.callPackage ./test-runner.nix { nixVersion = \"latest\"; };\n            };\n\n            devShells.default = pkgs.callPackage ./shell.nix {\n              packages = [\n                config.treefmt.build.wrapper\n                pkgs.shellcheck\n              ];\n            };\n\n            checks =\n              let\n                packages = lib.mapAttrs' (n: lib.nameValuePair \"package-${n}\") self'.packages;\n                devShells = lib.mapAttrs' (n: lib.nameValuePair \"devShell-${n}\") self'.devShells;\n              in\n              packages // devShells;\n          };\n        flake = {\n          overlays.default = final: _prev: { nix-direnv = final.callPackage ./default.nix { }; };\n          templates.default = {\n            path = ./templates/flake;\n            description = \"nix flake new -t github:nix-community/nix-direnv .\";\n          };\n        };\n      }\n    );\n}\n"
        },
        {
          "name": "pkgs",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.1376953125,
          "content": "[tool.ruff]\ntarget-version = \"py311\"\nline-length = 88\nselect = [\"ALL\"]\nignore = [\n  # pydocstyle\n  \"D\",\n  # Missing type annotation for `self` in method\n  \"ANN101\",\n  # Trailing comma missing\n  \"COM812\",\n  # Unnecessary `dict` call (rewrite as a literal)\n  \"C408\",\n  # Boolean-typed positional argument in function definition\n  \"FBT001\",\n  # Logging statement uses f-string\n  \"G004\",\n  # disabled on ruff's recommendation as causes problems with the formatter\n  \"ISC001\",\n  # Use of `assert` detected\n  \"S101\",\n  # `subprocess` call: check for execution of untrusted input\n  \"S603\",\n\n  # FIXME? Maybe we should enable these?\n  \"PLR0913\", # Too many arguments in function definition (7 > 5)\n  \"PLR2004\", # Magic value used in comparison, consider replacing 4 with a constant variable\n  \"FBT002\",  # Boolean default positional argument in function definition\n]\n\n[tool.mypy]\npython_version = \"3.10\"\nwarn_redundant_casts = true\ndisallow_untyped_calls = true\ndisallow_untyped_defs = true\nno_implicit_optional = true\n\n[[tool.mypy.overrides]]\nmodule = \"setuptools.*\"\nignore_missing_imports = true\n\n[[tool.mypy.overrides]]\nmodule = \"pytest.*\"\nignore_missing_imports = true\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "shell.nix",
          "type": "blob",
          "size": 0.171875,
          "content": "{\n  pkgs ? import <nixpkgs> { },\n  packages ? [ ],\n}:\n\nwith pkgs;\nmkShell {\n  packages = packages ++ [\n    python3.pkgs.pytest\n    python3.pkgs.mypy\n    ruff\n    direnv\n  ];\n}\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-runner.nix",
          "type": "blob",
          "size": 0.3564453125,
          "content": "{\n  writeShellScriptBin,\n  direnv,\n  python3,\n  lib,\n  coreutils,\n  gnugrep,\n  nixVersions,\n  nixVersion,\n}:\nwriteShellScriptBin \"test-runner-${nixVersion}\" ''\n  set -e\n  export PATH=${\n    lib.makeBinPath [\n      direnv\n      nixVersions.${nixVersion}\n      coreutils\n      gnugrep\n    ]\n  }\n\n  echo run unittest\n  ${lib.getExe' python3.pkgs.pytest \"pytest\"} .\n''\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "treefmt.nix",
          "type": "blob",
          "size": 0.7392578125,
          "content": "{ inputs, ... }:\n{\n  imports = [ inputs.treefmt-nix.flakeModule ];\n\n  perSystem =\n    { pkgs, ... }:\n    {\n      treefmt = {\n        # Used to find the project root\n        projectRootFile = \".git/config\";\n\n        programs = {\n          deadnix.enable = true;\n          deno.enable = true;\n          mypy.enable = true;\n          ruff.check = true;\n          ruff.format = true;\n          nixfmt.enable = true;\n          nixfmt.package = pkgs.nixfmt-rfc-style;\n          shellcheck.enable = true;\n          shfmt.enable = true;\n          statix.enable = true;\n          yamlfmt.enable = true;\n        };\n\n        settings.formatter = {\n          shellcheck.includes = [ \"direnvrc\" ];\n          shfmt.includes = [ \"direnvrc\" ];\n        };\n      };\n    };\n}\n"
        }
      ]
    }
  ]
}