{
  "metadata": {
    "timestamp": 1736568625920,
    "page": 703,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwOQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "LukeZGD/Legacy-iOS-Kit",
      "stars": 1364,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.08984375,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n*.html linguist-vendored\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2890625,
          "content": "*.bbfw\n*.dfu\n*.dmg\n*.im4p\n*.ipa\n*.ipsw\n*.json\n*.shsh\n*.shsh2\n*.txt\nCydia*\nfirstrun\niP*Custom*/\niP*DFUIPSW/\niP*Restore/\nresources/ch3rryflower/\nresources/ipwndfu/\nresources/jailbreak/g1lbertJB/payload/Cydia.tar\nresources/powdersn0w/\nresources/ramdisk/\nsaved/\nsudoloop\ntmp*/\nversion.xml\n*.DS_Store\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.0595703125,
          "content": "# Legacy iOS Kit\n\n- (formerly iOS-OTA-Downgrader)\n- **An all-in-one tool to [restore/downgrade](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Restore-Downgrade), [save SHSH blobs](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Saving-SHSH-blobs), and [jailbreak](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Jailbreaking) legacy iOS devices**\n- Supported on **Linux and macOS**\n- **Read the [\"How to Use\" wiki page](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/How-to-Use) for instructions**\n- **Read the [\"Troubleshooting\" wiki page](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting) for tips, frequent questions, and troubleshooting**\n\n## Features\n- Legacy iOS Kit supports all 32-bit iOS devices, and some 64-bit (A7/A8/A9/A10/A11) devices\n    - Devices that received iOS 16 and newer will only have limited functionality (such as sideload on Linux etc.)\n    - For S5L8900 devices (iPhone 2G, 3G, touch 1), some features like SSH ramdisk are not available\n- Restore to signed OTA versions (iOS 8.4.1 and/or 6.1.3) on A5/A6 devices\n- Restore to iOS 10.3.3 (signed OTA version) on supported A7 devices\n- Restore supported devices to unsigned versions with SHSH blobs\n- Restore to unsigned iOS versions with iOS 7 blobs (powdersn0w)\n- Restore supported 32-bit devices to unsigned iOS versions \"without\" blobs\n    - Includes downgrading iPhone 2G, 3G, 3GS, iPhone 4 GSM and CDMA, iPod touch 1, 2, 3, iPad 1\n    - \"without\" is in quotes because powdersn0w uses iOS 5/7 blobs for touch 3 and A4 devices, but it is signed for everyone to use\n    - Other devices however are true blobless\n- Tethered downgrades/restores to supported iOS versions for A5(X)/A6(X) and some other 32-bit devices\n- Jailbreak all 32-bit iOS devices on nearly any iOS version\n    - Available on iOS versions 3.0 to 9.3.4 with some small exceptions\n- Hacktivation for iPhone 2G, 3G, 3GS, 4 GSM (activate without valid SIM card)\n- [FourThree Utility](https://github.com/LukeZGD/FourThree-iPad2) - Dualboot iOS 4.3.x for the iPad 2\n- Boot SSH Ramdisk for supported 32-bit and 64-bit devices\n- Save Onboard SHSH blobs for supported 32-bit and 64-bit devices\n- Install IPA files for supported devices with AppSync Unified installed\n- Sideload IPA files for supported devices on Linux\n- Save SHSH blobs from Cydia servers for 32-bit devices\n- Enter pwned iBSS/kDFU mode for supported 32-bit devices\n- Save onboard SHSH blobs for jailbroken 64-bit devices (deverser)\n- Install [TrollStore](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/TrollStore) using SSH Ramdisk for supported 64-bit devices on iOS 14/15\n- Clear NVRAM for 32-bit devices\n- Device activation using ideviceactivation (especially useful for iOS 4 and lower)\n- The latest baseband will be flashed for certain A5/A6 devices (for iPhone 4S, 5, 5C, iPad 4, mini 1)\n    - For more info on baseband, go to [Baseband Update](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Baseband-Update) wiki page\n- Dumping and stitching baseband to IPSW (requires `--disable-bbupdate`)\n- Dumping and stitching activation records to IPSW (requires `--activation-records`)\n- [Data Management](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Data-Management) - Backup and restore, mount device, erase all content and settings\n- [Misc Utilities](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Misc-Utilities) - Pair device, export data and battery info, shutdown/restart device, and more\n\n## Supported devices\n- [Identify your device here](https://ipsw.me/device-finder)\n- **iPhone 5C and iPad mini 3 devices are NOT supported by OTA downgrades**\n    - These devices still support restoring to other iOS versions with SHSH blobs, see below\n- See the table below for OTA downgrading support:\n\n<table>\n    <thead>\n        <tr>\n            <th>Target Version</th>\n            <th>Supported Devices</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td rowspan=4>iOS 10.3.3</td>\n            <td><b>A7 devices:</b></td>\n        </tr>\n        <tr><td>iPhone 5S</td></tr>\n        <tr><td>iPad Air 1</td></tr>\n        <tr><td>iPad mini 2 (except iPad4,6)</td></tr>\n        <tr>\n            <td rowspan=6>iOS 8.4.1</td>\n            <td><b>32-bit devices:</b></td>\n        </tr>\n        <tr><td>iPhone 4S</td></tr>\n        <tr><td>iPhone 5</td></tr>\n        <tr><td>iPad 2, iPad 3, iPad 4</td></tr>\n        <tr><td>iPad mini 1</td></tr>\n        <tr><td>iPod touch 5</td></tr>\n        <tr>\n            <td rowspan=2>iOS 6.1.3</td>\n            <td>iPhone 4S</td>\n        </tr>\n        <tr><td>iPad 2 (except iPad2,4)</td></tr>\n    </tbody>\n</table>\n\n- Restoring with SHSH blobs, jailbreaking, and using SSH ramdisks are supported on the following devices:\n    - iPhone 2G, 3G, iPod touch 1 (SSH ramdisks not supported for these)\n    - iPhone 3GS, 4, 4S, 5, 5C\n    - iPad 1, 2, 3, 4, mini 1\n    - iPod touch 2, 3, 4, 5\n- Restoring with SHSH blobs and using SSH Ramdisks are also supported on some 64-bit devices:\n    - See [SEP/BB Compatibility Chart](https://docs.google.com/spreadsheets/d/1Mb1UNm6g3yvdQD67M413GYSaJ4uoNhLgpkc7YKi3LBs/edit#gid=1191207636) for iOS versions that can be restored to\n    - iPhone 5S, 6, 6S, SE 2016, 7 (including Plus variants)\n    - iPad Air 1, 2\n    - iPad mini 2, 3, 4\n    - iPod touch 6, 7\n- Restoring with iOS 16.6.x SHSH blobs using futurerestore is also supported on these devices (SSH ramdisks not supported):\n    - iPhone 8, X\n    - iPad 5\n    - iPad Pro 9.7/12.9 1st gen\n- Restoring with **powdersn0w** is supported on the following devices and target version range:\n    - iPhone 4 GSM - iOS 4.0 to 7.1.1\n    - iPhone 4 CDMA - iOS 5.0 to 7.1.1 (4.2.x has issues)\n    - iPhone 4S, 5, 5C, iPad 2 Rev A, iPod touch 5 - iOS 5.0 to 9.3.5\n    - iPad 1 - iOS 3.2 to 5.1\n    - iPod touch 3 - iOS 4.0 to 5.1 (3.1.x has issues)\n    - Using powdersn0w requires iOS 7.1.x blobs for your device\n        - No blob requirement for iPhone 4, iPad 1, iPod touch 3 (7.1.2 and 5.1.1 are signed)\n        - For iPhone 5 and 5C, both 7.0.x and 7.1.x blobs can be used\n- Restoring **tethered** to any version is supported on the following devices:\n    - iPhone 4 (3,2 and 3,3), 4S, 5, 5C\n    - iPad 2, 3, 4, mini 1\n    - iPod touch 3, 4, 5\n- Restoring to other unsigned versions without blobs is supported on the following devices and target version range:\n    - iPhone 2G, 3G, 3GS, iPod touch 1, touch 2 - All versions are supported\n    - Lowest downgradable version is 2.0. Going to 1.x does not work\n    - For jailbreaking support, see below\n- Jailbreaking for 32-bit devices and versions support:\n    - iPhone 2G and touch 1 - 3.1.3 only\n    - iPhone 3G and touch 2 - 4.2.1, 4.1, and 3.1.3\n    - iPhone 3GS - All versions are supported (all release versions from 3.0 to 6.1.6)\n    - Other devices - All versions from 3.1.3 to 9.3.4 are supported, with some exceptions\n    - For more details, go to the [\"Jailbreaking\" wiki page](https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Jailbreaking)\n\n\n## Supported OS versions/distros\n\n#### Supported architectures: x86_64, arm64 (armhf deprecated)\n\n- **macOS** 10.11 and newer (10.12 and newer recommended for full support)\n- [**Ubuntu**](https://ubuntu.com/) 22.04 and newer, and Ubuntu-based distros like [Linux Mint](https://www.linuxmint.com/)\n- [**Fedora**](https://getfedora.org/) 37 and newer, Fedora Atomic (Silverblue, Kinoite, etc.) also supported\n- [**Debian**](https://www.debian.org/) 12 Bookworm and newer, Sid, and Debian-based distros\n- [**Arch Linux**](https://www.archlinux.org/) and Arch-based distros like [EndeavourOS](https://endeavouros.com/)\n- Less tested distros: [**openSUSE Tumbleweed**](https://get.opensuse.org/tumbleweed/), [**Gentoo**](https://www.gentoo.org/), [**Void Linux**](https://voidlinux.org/)\n\n## Tools and other stuff used\n- curl\n- bspatch\n- [powdersn0w_pub](https://github.com/dora2-iOS/powdersn0w_pub) - dora2ios; [LukeZGD fork](https://github.com/LukeZGD/powdersn0w_pub)\n    - [Most of the exploit ramdisks used are from kok3shidoll's repo](https://github.com/kok3shidoll/untitled)\n    - [iPhone 5C 7.0.x exploit ramdisk is from m1zole](https://github.com/m1zole/untitled_pub)\n    - [Other iPhone 5/5C ramdisks are from Ralph0045's iloader repo](https://github.com/Ralph0045/iloader)\n    - [iPad 1 exploit ramdisk is from Ralph0045](https://github.com/Ralph0045/iBoot-5-Stuff)\n- [ipwndfu](https://github.com/LukeZGD/ipwndfu) - axi0mX, Linus Henze, synackuk; LukeZGD fork\n- [ipwnder_lite](https://github.com/LukeZGD/ipwnder_lite) - dora2ios (used on macOS); LukeZGD fork\n- [iPwnder32](https://github.com/dora2-iOS/iPwnder32/tree/243ea5c6d1bd15f8bdd0b3a1ff4a7729bc14bac4) - dora2ios (old version with libusb used on Linux)\n- [gaster](https://github.com/verygenericname/gaster) - 0x7ff; verygenericname/Nathan fork\n- [daibutsuCFW](https://github.com/LukeZGD/daibutsuCFW) - dora2ios; LukeZGD fork\n- [daibutsu](https://github.com/kok3shidoll/daibutsu) - dora/kok3shidoll, Clarity\n- [libimobiledevice](https://github.com/LukeeGD/libimobiledevice) - libimobiledevice\n- [libirecovery](https://github.com/LukeeGD/libirecovery) - libimobiledevice\n- [libideviceactivation](https://github.com/LukeeGD/libideviceactivation) - libimobiledevice\n- [ideviceinstaller](https://github.com/LukeeGD/ideviceinstaller) - libimobiledevice\n- [ifuse](https://github.com/LukeeGD/ifuse) - libimobiledevice\n- [static-cross-openssh](https://github.com/binary-manu/static-cross-openssh) - scp and ssh binaries (used on Linux only)\n- [usbmuxd2](https://github.com/LukeZGD/usbmuxd2) - tihmstar; LukeZGD fork (used on Linux only)\n- [anisette-server](https://github.com/Dadoum/Provision) from Provision - Dadoum (used for sideloading on Linux)\n- [AltServer-Linux](https://github.com/NyaMisty/AltServer-Linux) - NyaMisty (used for sideloading on Linux)\n- [Sideloader](https://github.com/Dadoum/Sideloader) - Dadoum (used for sideloading on Linux)\n- [tsschecker](https://github.com/1Conan/tsschecker) - tihmstar; 1Conan fork (v413)\n- [futurerestore](https://github.com/tihmstar/futurerestore) - tihmstar\n    - [LukeZGD fork](https://github.com/LukeZGD/futurerestore) used for restoring 32-bit devices\n    - [LukeeGD fork](https://github.com/LukeeGD/futurerestore) used for restoring A7 devices\n    - [futurerestore nightly](https://github.com/futurerestore/futurerestore/) used for restoring A8/A9/A10/A11 devices\n- [iBoot32Patcher](https://github.com/dora2-iOS/iBoot32Patcher/) - dora2ios fork\n- [idevicerestore](https://github.com/LukeZGD/idevicerestore) - libimobiledevice; LukeZGD fork\n- [kloader from Odysseus](https://www.youtube.com/watch?v=fh0tB6fp0Sc)\n- [kloader from axi0mX](https://github.com/axi0mX/ios-kexec-utils/blob/master/kloader) (used on iOS 4/5 only)\n- [kloader for iOS 5](https://www.pmbonneau.com/cydia/com.pmbonneau.kloader5_1.2_iphoneos-arm.deb)\n- [kloader_hgsp from nyan_satan](https://twitter.com/nyan_satan/status/945203180522045440) (used on h3lix only)\n- [jq](https://github.com/jqlang/jq)\n- [partialZipBrowser](https://github.com/tihmstar/partialZipBrowser)\n- [zenity](https://github.com/GNOME/zenity); [macOS build](https://github.com/ncruces/zenity)\n- 32-bit bundles from [OdysseusOTA](https://www.youtube.com/watch?v=Wo7mGdMcjxw), [OdysseusOTA2](https://www.youtube.com/watch?v=fh0tB6fp0Sc), [alitek12](https://www.mediafire.com/folder/b1z64roy512wd/FirmwareBundles), [gjest](https://www.reddit.com/r/jailbreak/comments/6yrzzj/release_firmware_bundles_for_ios_841_ipad21234567/) (modified bundles for daibutsuCFW)\n- A7 patches from [MatthewPierson](https://github.com/MatthewPierson/iPhone-5s-OTA-Downgrade-Patches)\n- iPad 2 iOS 4.3.x bundles from [selfisht, Ralph0045](https://www.reddit.com/r/LegacyJailbreak/comments/1172ulo/release_ios_4_ipad_2_odysseus_firmware_bundles/)\n- [datautils0](https://github.com/comex/datautils0) - comex (used for iPad 2 4.3.x kernel diffs)\n- [sshpass](https://sourceforge.net/project/sshpass)\n- Bootstrap tar from [SpiritNET](https://invoxiplaygames.uk/projects/spiritnet/)\n- [Cydia HTTPatch](https://cydia.invoxiplaygames.uk/package/cydiahttpatch) for 3.1.3 downgrades/jailbreaks\n- [Pangu](https://www.theapplewiki.com/wiki/Pangu)\n- [p0sixspwn](https://www.theapplewiki.com/wiki/p0sixspwn)\n- [evasi0n](https://www.theapplewiki.com/wiki/Evasi0n)\n- [g1lbertJB](https://github.com/g1lbertJB/g1lbertJB)\n- [UntetherHomeDepot](https://www.theapplewiki.com/wiki/UntetherHomeDepot)\n- [greenpois0n](https://github.com/OpenJailbreak/greenpois0n/tree/0f1eac8e748abb200fc36969e616aaad009f7ebf)\n- Some patches from [PwnageTool](https://www.theapplewiki.com/wiki/PwnageTool), [sn0wbreeze](https://www.theapplewiki.com/wiki/sn0wbreeze), [redsn0w](https://www.theapplewiki.com/wiki/redsn0w)\n- Many patches for the 3GS are made using patchers by Merculous (including [Bundle-Creation](https://github.com/Merculous/Bundle-Creation))\n- SSH Ramdisk tars from Ralph0045's [SSH-Ramdisk-Maker-and-Loader](https://github.com/Ralph0045/SSH-Ramdisk-Maker-and-Loader) and msftguy's [ssh-rd](https://github.com/msftguy/ssh-rd)\n- 64-bit SSH Ramdisk stuff is based on Nathan's [SSHRD_Script](https://github.com/verygenericname/SSHRD_Script) (iOS 12+), and exploit3dguy's iram tar from [iarchive.app](https://web.archive.org/web/20240324134204/https://ios7.iarchive.app/downgrade/making-ramdisk.html) (iOS 8)\n    - [img4lib](https://github.com/xerub/img4lib) - xerub\n    - [img4tool](https://github.com/tihmstar/img4tool) - tihmstar\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "restore.sh",
          "type": "blob",
          "size": 399.3408203125,
          "content": "#!/usr/bin/env bash\n\nipsw_openssh=1 # OpenSSH will be added to jailbreak/custom IPSW if set to 1.\ndevice_rd_build=\"\" # You can change the version of SSH Ramdisk and Pwned iBSS/iBEC here. (default is 10B329 for most devices)\ndevice_bootargs_default=\"pio-error=0 debug=0x2014e serial=3\"\njelbrek=\"../resources/jailbreak\"\nssh_port=6414\n\nbash_test=$(echo -n 0)\n(( bash_test += 1 ))\nif [ \"$bash_test\" != \"1\" ] || [ -z $BASH_VERSION ]; then\n    echo \"[Error] Detected that script is not running with bash on runtime. Please run the script properly using bash.\"\n    exit 1\nfi\nbash_ver=$(/usr/bin/env bash -c 'echo ${BASH_VERSINFO[0]}')\nif (( bash_ver > 3 )); then\n    shopt -s compat32\nfi\n\nprint() {\n    echo \"${color_B}${1}${color_N}\"\n}\n\ninput() {\n    echo \"${color_Y}[Input] ${1}${color_N}\"\n}\n\nlog() {\n    echo \"${color_G}[Log] ${1}${color_N}\"\n}\n\nwarn() {\n    echo \"${color_Y}[WARNING] ${1}${color_N}\"\n}\n\nerror() {\n    echo -e \"${color_R}[Error] ${1}\\n${color_Y}${*:2}${color_N}\"\n    echo\n    print \"* Save the terminal output now if needed. (macOS: Cmd+S, Linux: Ctrl+Shift+S)\"\n    if [[ -n $version_current && -n $git_hash ]]; then\n        print \"* Legacy iOS Kit $version_current ($git_hash)\"\n    else\n        print \"* Legacy iOS Kit\"\n    fi\n    if [[ -n $platform ]]; then\n        print \"* Platform: $platform ($platform_ver - $platform_arch) $live_cdusb_str\"\n    fi\n    exit 1\n}\n\npause() {\n    input \"Press Enter/Return to continue (or press Ctrl+C to cancel)\"\n    read -s\n}\n\nclean() {\n    kill $httpserver_pid $iproxy_pid $anisette_pid 2>/dev/null\n    popd &>/dev/null\n    rm -rf \"$(dirname \"$0\")/tmp$$/\"* \"$(dirname \"$0\")/iP\"*/ \"$(dirname \"$0\")/tmp$$/\" 2>/dev/null\n    if [[ $platform == \"macos\" && $(ls \"$(dirname \"$0\")\" | grep -v tmp$$ | grep -c tmp) == 0 ]]; then\n        # ill disable this for now since finder is annoying, ill just keep them in a stopped state.\n        : killall -CONT AMPDevicesAgent AMPDeviceDiscoveryAgent MobileDeviceUpdater\n    fi\n}\n\nclean_sudo() {\n    clean\n    sudo rm -rf /tmp/futurerestore /tmp/*.json \"$(dirname \"$0\")/tmp$$/\"* \"$(dirname \"$0\")/iP\"*/ \"$(dirname \"$0\")/tmp$$/\"\n    sudo kill $sudoloop_pid\n}\n\nclean_usbmuxd() {\n    clean_sudo\n    if [[ $(ls \"$(dirname \"$0\")\" | grep -v tmp$$ | grep -c tmp) != 0 ]]; then\n        return\n    fi\n    sudo killall -9 usbmuxd usbmuxd2 2>/dev/null\n    sleep 1\n    if [[ $(command -v systemctl) ]]; then\n        sudo systemctl restart usbmuxd\n    elif [[ $(command -v rc-service) ]]; then\n        sudo rc-service usbmuxd start\n    fi\n}\n\ndisplay_help() {\n    echo ' *** Legacy iOS Kit ***\n  - Script by LukeZGD -\n\nUsage: ./restore.sh [Options]\n\nList of options:\n    --debug                   For script debugging (set -x and debug mode)\n    --device=<type>           Specify device type\n    --dfuhelper               Launch to DFU Mode Helper only\n    --disable-sudoloop        Disable running tools as root for Linux\n    --ecid=<ecid>             Specify device ECID\n    --entry-device            Enable manual device type and ECID entry\n    --exit-recovery           Attempt to exit recovery mode\n    --kdfu                    Enter kDFU mode with the connected device\n    --help                    Display this help message\n    --no-color                Disable colors for script output\n    --no-device               Enable no device mode\n    --no-version-check        Disable script version checking\n    --old-menu                Use the old menus with number select and y/n\n    --pwn                     Pwn the connected device\n    --sshrd                   Enter SSH ramdisk mode (requires additional arguments)\n    --sshrd-menu              Re-enter SSH ramdisk menu (device must be in SSH ramdisk mode)\n\nFor 32-bit devices compatible with restores/downgrades (see README):\n    --activation-records      Enable dumping/stitching activation records\n    --dead-bb                 Disable bbupdate completely without dumping/stitching baseband\n    --disable-bbupdate        Disable bbupdate and enable dumping/stitching baseband\n    --gasgauge-patch          Enable multipatch to get past \"gas gauge\" error (aka error 29 in iTunes)\n    --ipsw-hacktivate         Enable hacktivation for creating IPSW (iPhone 2G/3G/3GS only)\n    --ipsw-verbose            Enable verbose boot option (3GS and powdersn0w only)\n    --jailbreak               Enable jailbreak option\n    --just-boot               Tether boot the device (requires additional arguments)\n    --memory                  Enable memory option for creating IPSW\n    --pwned-recovery          Assume that device is in pwned recovery mode (experimental)\n    --skip-first              Skip first restore and flash NOR IPSW only for powdersn0w 4.2.x and lower\n    --skip-ibss               Assume that pwned iBSS has already been sent to the device\n\nFor 64-bit checkm8 devices compatible with pwned restores:\n    --skip-blob               Enable futurerestore skip blob option for OTA/onboard/factory blobs\n    --use-pwndfu              Enable futurerestore pwned restore option\n\n    * Default IPSW path: <script location>/<name of IPSW file>.ipsw\n    * Default SHSH path: <script location>/saved/shsh/<name of SHSH file>.shsh(2)\n    '\n}\n\nunzip2=\"$(command -v unzip)\"\nzip2=\"$(command -v zip)\"\n\nunzip() {\n    $unzip2 \"$@\" || error \"An error occurred with the unzip operation: $*\"\n}\n\nzip() {\n    $zip2 \"$@\" || error \"An error occurred with the zip operation: $*\"\n}\n\n# from https://unix.stackexchange.com/questions/146570/arrow-key-enter-menu#415155\nselect_option() {\n    if [[ $menu_old == 1 ]]; then\n        select opt in \"$@\"; do\n            selected=$((REPLY-1))\n            break\n        done\n        return $selected\n    fi\n\n    # little helpers for terminal print control and key input\n    ESC=$( printf \"\\033\")\n    cursor_blink_on()  { printf \"$ESC[?25h\"; }\n    cursor_blink_off() { printf \"$ESC[?25l\"; }\n    cursor_to()        { printf \"$ESC[$1;${2:-1}H\"; }\n    print_option()     { printf \"   $1  \"; }\n    print_selected()   { printf \" ->$ESC[7m $1 $ESC[27m\"; }\n    get_cursor_row()   { IFS=';' read -sdR -p $'\\E[6n' ROW COL; echo ${ROW#*[}; }\n    key_input()        { read -s -n3 key 2>/dev/null >&2\n                         if [[ $key = $ESC[A ]]; then echo up;    fi\n                         if [[ $key = $ESC[B ]]; then echo down;  fi\n                         if [[ $key = \"\"     ]]; then echo enter; fi; }\n\n    # initially print empty new lines (scroll down if at bottom of screen)\n    for opt; do printf \"\\n\"; done\n\n    # determine current screen position for overwriting the options\n    local lastrow=`get_cursor_row`\n    local startrow=$(($lastrow - $#))\n\n    # ensure cursor and input echoing back on upon a ctrl+c during read -s\n    trap \"cursor_blink_on; stty echo; printf '\\n'; exit\" 2\n    cursor_blink_off\n\n    local selected=0\n    while true; do\n        # print options by overwriting the last lines\n        local idx=0\n        for opt; do\n            cursor_to $(($startrow + $idx))\n            if [ $idx -eq $selected ]; then\n                print_selected \"$opt\"\n            else\n                print_option \"$opt\"\n            fi\n            ((idx++))\n        done\n\n        # user key control\n        case `key_input` in\n            enter) break;;\n            up)    ((selected--));\n                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;\n            down)  ((selected++));\n                   if [ $selected -ge $# ]; then selected=0; fi;;\n        esac\n    done\n\n    # cursor position back to normal\n    cursor_to $lastrow\n    printf \"\\n\"\n    cursor_blink_on\n\n    return $selected\n}\n\nselect_yesno() {\n    local msg=\"Do you want to continue?\"\n    if [[ -n $1 ]]; then\n        msg=\"$1\"\n    fi\n    if [[ $2 == 1 ]]; then\n        msg+=\" (Y/n): \"\n    else\n        msg+=\" (y/N): \"\n    fi\n\n    if [[ $menu_old == 1 ]]; then\n        local opt\n        while true; do\n            read -p \"$(input \"$msg\")\" opt\n            case $opt in\n                [NnYy] ) break;;\n                \"\" )\n                    # select default if no y/n given\n                    if [[ $2 == 1 ]]; then\n                        opt='y'\n                    else\n                        opt='n'\n                    fi\n                    break\n                ;;\n            esac\n        done\n        if [[ $2 == 1 ]]; then # default is \"yes\" if $2 is set to 1\n            [[ $opt == [Nn] ]] && return 0 || return 1\n        else                   # default is \"no\" otherwise\n            [[ $opt == [Yy] ]] && return 1 || return 0\n        fi\n    fi\n\n    local yesno=(\"No\" \"Yes\") # default is \"no\" by default\n    if [[ $2 == 1 ]]; then # default is \"yes\" if $2 is set to 1\n        yesno=(\"Yes\" \"No\")\n    fi\n    input \"$msg\"\n    select_option \"${yesno[@]}\"\n    local res=$?\n    if [[ $2 == 1 ]]; then\n        [[ $res == 0 ]] && return 1 || return 0\n    fi\n    return $res\n}\n\nset_tool_paths() {\n    : '\n    sets variables: platform, platform_ver, dir\n    also checks architecture (linux) and macos version\n    also set distro, debian_ver, ubuntu_ver, fedora_ver variables for linux\n\n    list of tools set here:\n    bspatch, jq, scp, ssh, sha1sum (for macos: shasum -a 1), zenity\n\n    these ones \"need\" sudo for linux arm, not for others:\n    futurerestore, gaster, idevicerestore, ipwnder, irecovery\n\n    tools set here will be executed using:\n    $name_of_tool\n\n    the rest of the tools not listed here will be executed using:\n    \"$dir/$name_of_tool\"\n    '\n\n    if [[ $OSTYPE == \"linux\"* ]]; then\n        source /etc/os-release\n        platform=\"linux\"\n        platform_ver=\"$PRETTY_NAME\"\n        dir=\"../bin/linux/\"\n\n        # architecture check\n        if [[ $(uname -m) == \"a\"* && $(getconf LONG_BIT) == 64 ]]; then\n            platform_arch=\"arm64\"\n        elif [[ $(uname -m) == \"a\"* ]]; then\n            platform_arch=\"armhf\"\n        elif [[ $(uname -m) == \"x86_64\" ]]; then\n            platform_arch=\"x86_64\"\n        else\n            error \"Your architecture ($(uname -m)) is not supported.\"\n        fi\n        dir+=\"$platform_arch\"\n\n        # version check\n        if [[ -n $UBUNTU_CODENAME ]]; then\n            case $UBUNTU_CODENAME in\n                \"jammy\" | \"kinetic\"  ) ubuntu_ver=22;;\n                \"lunar\" | \"mantic\"   ) ubuntu_ver=23;;\n                \"noble\" | \"oracular\" ) ubuntu_ver=24;;\n                \"plucky\"             ) ubuntu_ver=25;;\n            esac\n            if [[ -z $ubuntu_ver ]]; then\n                source /etc/upstream-release/lsb-release 2>/dev/null\n                ubuntu_ver=\"$(echo \"$DISTRIB_RELEASE\" | cut -c -2)\"\n            fi\n            if [[ -z $ubuntu_ver ]]; then\n                ubuntu_ver=\"$(echo \"$VERSION_ID\" | cut -c -2)\"\n            fi\n        elif [[ -e /etc/debian_version ]]; then\n            debian_ver=$(cat /etc/debian_version)\n            case $debian_ver in\n                *\"sid\" | \"kali\"* ) debian_ver=\"sid\";;\n                * ) debian_ver=\"$(echo \"$debian_ver\" | cut -c -2)\";;\n            esac\n        elif [[ $ID == \"fedora\" || $ID_LIKE == \"fedora\" || $ID == \"nobara\" ]]; then\n            fedora_ver=$VERSION_ID\n        fi\n\n        # distro check\n        if [[ $ID == \"arch\" || $ID_LIKE == \"arch\" || $ID == \"artix\" ]]; then\n            distro=\"arch\"\n        elif (( ubuntu_ver >= 22 )) || (( debian_ver >= 12 )) || [[ $debian_ver == \"sid\" ]]; then\n            distro=\"debian\"\n        elif (( fedora_ver >= 37 )); then\n            distro=\"fedora\"\n            if [[ $(command -v rpm-ostree) ]]; then\n                distro=\"fedora-atomic\"\n            fi\n        elif [[ $ID == \"opensuse-tumbleweed\" ]]; then\n            distro=\"opensuse\"\n        elif [[ $ID == \"gentoo\" || $ID_LIKE == \"gentoo\" || $ID == \"pentoo\" ]]; then\n            distro=\"gentoo\"\n        elif [[ $ID == \"void\" ]]; then\n            distro=\"void\"\n        elif [[ -n $ubuntu_ver || -n $debian_ver || -n $fedora_ver ]]; then\n            error \"Your distro version ($platform_ver - $platform_arch) is not supported. See the repo README for supported OS versions/distros\"\n        else\n            warn \"Your distro ($platform_ver - $platform_arch) is not detected/supported. See the repo README for supported OS versions/distros\"\n            print \"* You may still continue, but you will need to install required packages and libraries manually as needed.\"\n            sleep 5\n            pause\n        fi\n        bspatch=\"$dir/bspatch\"\n        if [[ $platform_arch != \"armhf\" ]]; then\n            dir_env=\"env LD_LIBRARY_PATH=$dir/lib \"\n            ideviceactivation=\"$dir_env\"\n            idevicediagnostics=\"$dir_env\"\n            ideviceinstaller=\"$dir_env\"\n        fi\n        PlistBuddy=\"$dir/PlistBuddy\"\n        sha1sum=\"$(command -v sha1sum)\"\n        tsschecker=\"$dir/tsschecker\"\n        zenity=\"$(command -v zenity)\"\n        scp2=\"$dir/scp\"\n        ssh2=\"$dir/ssh\"\n        cp $ssh2 .\n        chmod +x ssh\n\n        # live cd/usb check\n        if [[ $(id -u $USER) == 999 || $USER == \"liveuser\" ]]; then\n            live_cdusb=1\n            live_cdusb_str=\"Live session\"\n            log \"Linux Live session detected.\"\n            if [[ $(pwd) == \"/home\"* ]]; then\n                df . -h\n                if [[ $(lsblk -o label | grep -c \"casper-rw\") == 1 || $(lsblk -o label | grep -c \"persistence\") == 1 ]]; then\n                    log \"Detected Legacy iOS Kit running on persistent storage.\"\n                    live_cdusb_str+=\" - Persistent storage\"\n                else\n                    warn \"Detected Legacy iOS Kit running on temporary storage.\"\n                    print \"* You may run out of space and get errors during the restore process.\"\n                    print \"* Please move Legacy iOS Kit to a drive that is NOT used for the live USB.\"\n                    print \"* This may mean using another external HDD/flash drive to store Legacy iOS Kit on.\"\n                    print \"* To use one USB drive only, create the live USB using Rufus with Persistent Storage enabled.\"\n                    sleep 5\n                    pause\n                    live_cdusb_str+=\" - Temporary storage\"\n                fi\n            fi\n        fi\n\n        # if \"/media\" is detected in pwd, warn user of possible permission issues\n        if [[ $(pwd) == *\"/media\"* ]]; then\n            warn \"You might get permission errors like \\\"Permission denied\\\" on getting device info.\"\n            print \"* If this is the case, try moving Legacy iOS Kit to the Desktop or Documents folder.\"\n        fi\n\n        if [[ -z $device_disable_sudoloop ]]; then\n            device_sudoloop=1 # Run some tools as root for device detection if set to 1. (for Linux)\n            trap \"clean_sudo\" EXIT\n        fi\n        if [[ $(uname -m) == \"a\"* || $device_sudoloop == 1 || $live_cdusb == 1 ]]; then\n            if [[ $live_cdusb != 1 ]]; then\n                print \"* Enter your user password when prompted\"\n            fi\n            sudo -v\n            (while true; do sudo -v; sleep 60; done) &\n            sudoloop_pid=$!\n            futurerestore=\"sudo \"\n            gaster=\"sudo \"\n            idevicerestore=\"sudo \"\n            ipwnder=\"sudo \"\n            irecovery=\"sudo \"\n            irecovery2=\"sudo \"\n            irecovery3=\"sudo \"\n            if [[ ! -d $dir && $(ls ../bin/linux) ]]; then\n                log \"Running on platform: $platform ($platform_ver - $platform_arch)\"\n                error \"Failed to find bin directory for $platform_arch, found $(ls -x ../bin/linux) instead.\" \\\n                \"* Download the \\\"linux_$platform_arch\\\" or \\\"complete\\\" version to continue (or do a git clone)\"\n            fi\n            trap \"clean_usbmuxd\" EXIT\n            if [[ $othertmp == 0 ]]; then\n                if [[ $(command -v systemctl) ]]; then\n                    sudo systemctl stop usbmuxd\n                elif [[ $(command -v rc-service) ]]; then\n                    sudo rc-service usbmuxd zap\n                else\n                    sudo killall -9 usbmuxd\n                fi\n                #sudo killall usbmuxd 2>/dev/null\n                #sleep 1\n                if [[ $platform_arch == \"armhf\" ]]; then\n                    log \"Running usbmuxd\"\n                    sudo -b $dir/usbmuxd -pf &>../saved/usbmuxd.log\n                else\n                    log \"Running usbmuxd2\"\n                    sudo -b $dir/usbmuxd2 &>../saved/usbmuxd2.log\n                fi\n            elif [[ $othertmp != 0 ]]; then\n                log \"Detected existing tmp folder(s), there might be other Legacy iOS Kit instance(s) running\"\n                log \"Not running usbmuxd\"\n            fi\n        fi\n        gaster+=\"$dir/gaster\"\n\n    elif [[ $(uname -m) == \"iP\"* ]]; then\n        error \"Running Legacy iOS Kit on iOS is not supported (yet)\" \"* Supported platforms: Linux, macOS\"\n\n    elif [[ $OSTYPE == \"darwin\"* ]]; then\n        platform=\"macos\"\n        platform_ver=\"${1:-$(sw_vers -productVersion)}\"\n        dir=\"../bin/macos\"\n\n        platform_arch=\"$(uname -m)\"\n        if [[ $platform_arch == \"arm64\" ]]; then\n            dir+=\"/arm64\"\n        fi\n\n        # macos version check\n        mac_majver=\"${platform_ver:0:2}\"\n        if [[ $mac_majver == 10 ]]; then\n            mac_minver=${platform_ver:3}\n            mac_minver=${mac_minver%.*}\n            if (( mac_minver < 11 )); then\n                warn \"Your macOS version ($platform_ver - $platform_arch) is not supported. Expect features to not work properly.\"\n                print \"* Supported versions are macOS 10.11 and newer. (10.13/10.15 and newer recommended)\"\n                pause\n            fi\n            if (( mac_minver <= 11 )); then\n                mac_cocoa=1\n                if [[ -z $(command -v cocoadialog) ]]; then\n                    local error_msg=\"* You need to install cocoadialog from MacPorts.\"\n                    error_msg+=$'\\n* Please read the wiki and install the requirements needed in MacPorts: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/How-to-Use'\n                    error_msg+=$'\\n* Also make sure that /opt/local/bin (or /usr/local/bin) is in your $PATH.'\n                    error_msg+=$'\\n* You may try running this command: export PATH=\"/opt/local/bin:$PATH\"'\n                    error \"Cannot find cocoadialog, cannot continue.\" \"$error_msg\"\n                fi\n            fi\n            if [[ $(command -v curl) == \"/usr/bin/curl\" ]] && (( mac_minver < 15 )); then\n                local error_msg=\"* You need to install curl from MacPorts.\"\n                error_msg+=$'\\n* Please read the wiki and install the requirements needed in MacPorts: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/How-to-Use'\n                error_msg+=$'\\n* Also make sure that /opt/local/bin (or /usr/local/bin) is in your $PATH.'\n                error_msg+=$'\\n* You may try running this command: export PATH=\"/opt/local/bin:$PATH\"'\n                error \"Outdated curl detected, cannot continue.\" \"$error_msg\"\n            fi\n        fi\n\n        bspatch=\"$(command -v bspatch)\"\n        cocoadialog=\"$(command -v cocoadialog)\"\n        gaster+=\"../bin/macos/gaster\"\n        ipwnder32=\"$dir/ipwnder32\"\n        PlistBuddy=\"/usr/libexec/PlistBuddy\"\n        sha1sum=\"$(command -v shasum) -a 1\"\n        tsschecker=\"../bin/macos/tsschecker\"\n        zenity=\"../bin/macos/zenity\"\n        scp2=\"/usr/bin/scp\"\n        ssh2=\"/usr/bin/ssh\"\n\n        # kill macos daemons\n        killall -STOP AMPDevicesAgent AMPDeviceDiscoveryAgent MobileDeviceUpdater\n\n    else\n        error \"Your platform ($OSTYPE) is not supported.\" \"* Supported platforms: Linux, macOS\"\n    fi\n    log \"Running on platform: $platform ($platform_ver - $platform_arch)\"\n    if [[ ! -d $dir ]]; then\n        error \"Failed to find bin directory ($dir), cannot continue.\" \\\n        \"* Re-download Legacy iOS Kit from releases (or do a git clone/reset)\"\n    fi\n    if [[ $device_sudoloop == 1 ]]; then\n        sudo chmod +x $dir/*\n        if [[ $? != 0 ]]; then\n            error \"Failed to set up execute permissions of binaries, cannot continue. Try to move Legacy iOS Kit somewhere else.\"\n        fi\n    else\n        chmod +x $dir/*\n    fi\n\n    futurerestore+=\"$dir/futurerestore\"\n    ideviceactivation+=\"$dir/ideviceactivation\"\n    idevicediagnostics+=\"$dir/idevicediagnostics\"\n    ideviceinfo=\"$dir/ideviceinfo\"\n    ideviceinstaller+=\"$dir/ideviceinstaller\"\n    idevicerestore+=\"$dir/idevicerestore\"\n    ifuse=\"$(command -v ifuse)\"\n    ipwnder+=\"$dir/ipwnder\"\n    irecovery+=\"$dir/irecovery\"\n    irecovery2+=\"$dir/irecovery2\"\n    irecovery3+=\"../$dir/irecovery\"\n    jq=\"$dir/jq\"\n\n    cp ../resources/ssh_config .\n    if [[ $(ssh -V 2>&1 | grep -c SSH_8.8) == 1 || $(ssh -V 2>&1 | grep -c SSH_8.9) == 1 ||\n          $(ssh -V 2>&1 | grep -c SSH_9.) == 1 || $(ssh -V 2>&1 | grep -c SSH_1) == 1 ]]; then\n        echo \"    PubkeyAcceptedAlgorithms +ssh-rsa\" >> ssh_config\n    elif [[ $(ssh -V 2>&1 | grep -c SSH_6) == 1 ]]; then\n        cat ../resources/ssh_config | sed \"s,Add,#Add,g\" | sed \"s,HostKeyA,#HostKeyA,g\" > ssh_config\n    fi\n    scp2+=\" -F ./ssh_config\"\n    ssh2+=\" -F ./ssh_config\"\n}\n\nprepare_udev_rules() {\n    local owner=\"$1\"\n    local group=\"$2\"\n    echo \"ACTION==\\\"add\\\", SUBSYSTEM==\\\"usb\\\", ATTR{idVendor}==\\\"05ac\\\", ATTR{idProduct}==\\\"122[27]|128[0-3]|1338\\\", OWNER=\\\"$owner\\\", GROUP=\\\"$group\\\", MODE=\\\"0660\\\" TAG+=\\\"uaccess\\\"\" > 39-libirecovery.rules\n}\n\ninstall_depends() {\n    log \"Installing dependencies...\"\n    rm -f \"../resources/firstrun\"\n\n    if [[ $platform == \"linux\" ]]; then\n        print \"* Legacy iOS Kit will be installing dependencies from your distribution's package manager\"\n        print \"* Enter your user password when prompted\"\n        if [[ $distro != \"debian\" && $distro != \"fedora-atomic\" ]]; then\n            echo\n            warn \"Before continuing, make sure that your system is fully updated first!\"\n            echo \"${color_Y}* This operation can result in a partial upgrade and may cause breakage if your system is not updated${color_N}\"\n            echo\n        fi\n        pause\n        prepare_udev_rules usbmux plugdev\n    fi\n\n    if [[ $distro == \"arch\" ]]; then\n        sudo pacman -Sy --noconfirm --needed base-devel ca-certificates ca-certificates-mozilla curl git ifuse libimobiledevice libxml2 openssh pyenv python udev unzip usbmuxd usbutils vim zenity zip zstd\n        prepare_udev_rules root storage\n\n    elif [[ $distro == \"debian\" ]]; then\n        if [[ -n $ubuntu_ver ]]; then\n            sudo add-apt-repository -y universe\n        fi\n        sudo apt update\n        sudo apt install -m -y build-essential ca-certificates curl git ifuse libssl3 libssl-dev libxml2 libzstd1 openssh-client patch python3 unzip usbmuxd usbutils xxd zenity zip zlib1g-dev\n        if [[ $(command -v systemctl 2>/dev/null) ]]; then\n            sudo systemctl enable --now udev systemd-udevd usbmuxd 2>/dev/null\n        fi\n\n    elif [[ $distro == \"fedora\" ]]; then\n        sudo dnf install -y ca-certificates git ifuse libimobiledevice libxml2 libzstd openssl openssl-devel patch python3 systemd udev usbmuxd vim-common zenity zip zlib-devel\n        sudo dnf group install -y c-development\n        sudo ln -sf /etc/pki/tls/certs/ca-bundle.crt /etc/pki/tls/certs/ca-certificates.crt\n        prepare_udev_rules root usbmuxd\n\n    elif [[ $distro == \"fedora-atomic\" ]]; then\n        rpm-ostree install patch vim-common zenity\n        print \"* You may need to reboot to apply changes with rpm-ostree. Perform a reboot after this before running the script again.\"\n\n    elif [[ $distro == \"opensuse\" ]]; then\n        sudo zypper -n install ca-certificates curl git ifuse libimobiledevice-1_0-6 libopenssl-3-devel libxml2 libzstd1 openssl-3 patch pyenv python3 usbmuxd unzip vim zenity zip zlib-devel\n        sudo zypper -n install -t pattern devel_basis\n        prepare_udev_rules usbmux usbmux # idk if this is right\n\n    elif [[ $distro == \"gentoo\" ]]; then\n        sudo emerge -av --noreplace app-arch/zstd app-misc/ca-certificates app-pda/ifuse dev-libs/libxml2 libimobiledevice net-misc/curl openssh python udev unzip usbmuxd usbutils vim zenity zip\n\n    elif [[ $distro == \"void\" ]]; then\n        sudo xbps-install curl git patch openssh python3 unzip xxd zenity zip base-devel libffi-devel bzip2-devel openssl openssl-devel readline readline-devel sqlite-devel xz liblzma-devel zlib zlib-devel\n\n    elif [[ $platform == \"macos\" ]]; then\n        print \"* Legacy iOS Kit will be installing dependencies and setting up permissions of tools\"\n        xattr -cr ../bin/macos\n        log \"Installing Xcode Command Line Tools\"\n        xcode-select --install\n        print \"* Make sure to install requirements from Homebrew/MacPorts: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/How-to-Use\"\n        pause\n    fi\n\n    echo \"$platform_ver\" > \"../resources/firstrun\"\n    if [[ $platform == \"linux\" && $distro != \"fedora-atomic\" ]]; then\n        # from linux_fix and libirecovery-rules by Cryptiiiic\n        if [[ $(command -v systemctl) ]]; then\n            sudo systemctl enable --now systemd-udevd usbmuxd 2>/dev/null\n        fi\n        sudo cp 39-libirecovery.rules /etc/udev/rules.d/39-libirecovery.rules\n        sudo chown root:root /etc/udev/rules.d/39-libirecovery.rules\n        sudo chmod 0644 /etc/udev/rules.d/39-libirecovery.rules\n        sudo udevadm control --reload-rules\n        sudo udevadm trigger -s usb\n    fi\n\n    log \"Install script done! Please run the script again to proceed\"\n    log \"If your iOS device is plugged in, unplug and replug your device\"\n    exit\n}\n\nversion_update_check() {\n    pushd \"$(dirname \"$0\")/tmp$$\" >/dev/null\n    if [[ $platform == \"macos\" && ! -e ../resources/firstrun ]]; then\n        xattr -cr ../bin/macos\n    fi\n    log \"Checking for updates...\"\n    github_api=$(curl https://api.github.com/repos/LukeZGD/Legacy-iOS-Kit/releases/latest 2>/dev/null)\n    version_latest=$(echo \"$github_api\" | $jq -r '.assets[] | select(.name|test(\"complete\")) | .name' | cut -c 25- | cut -c -9)\n    git_hash_latest=$(echo \"$github_api\" | $jq -r '.assets[] | select(.name|test(\"git-hash\")) | .name' | cut -c 21- | cut -c -7)\n    popd >/dev/null\n}\n\nversion_update() {\n    local url\n    local req\n    select_yesno \"Do you want to update now?\" 1\n    if [[ $? != 1 ]]; then\n        log \"User selected N, cannot continue. Exiting.\"\n        exit\n    fi\n    if [[ -d .git ]]; then\n        log \"Running git pull...\"\n        print \"* If this fails for some reason, run: git reset --hard\"\n        print \"* To clean more files if needed, run: git clean -df\"\n        git pull\n        pushd \"$(dirname \"$0\")/tmp$$\" >/dev/null\n        log \"Done! Please run the script again\"\n        exit\n    elif (( $(ls bin | wc -l) > 1 )); then\n        req=\".assets[] | select (.name|test(\\\"complete\\\")) | .browser_download_url\"\n    elif [[ $platform == \"linux\" ]]; then\n        req=\".assets[] | select (.name|test(\\\"${platform}_$platform_arch\\\")) | .browser_download_url\"\n    else\n        req=\".assets[] | select (.name|test(\\\"${platform}\\\")) | .browser_download_url\"\n    fi\n    pushd \"$(dirname \"$0\")/tmp$$\" >/dev/null\n    url=\"$(echo \"$github_api\" | $jq -r \"$req\")\"\n    log \"Downloading: $url\"\n    curl -L $url -o latest.zip\n    if [[ ! -s latest.zip ]]; then\n        error \"Download failed. Please run the script again\"\n    fi\n    popd >/dev/null\n    log \"Updating...\"\n    cp resources/firstrun tmp$$ 2>/dev/null\n    rm -r bin/ LICENSE README.md restore.sh\n    if [[ $device_sudoloop == 1 ]]; then\n        sudo rm -rf resources/\n    fi\n    rm -r resources/ saved/ipwndfu/ 2>/dev/null\n    unzip -q tmp$$/latest.zip -d .\n    cp tmp$$/firstrun resources 2>/dev/null\n    pushd \"$(dirname \"$0\")/tmp$$\" >/dev/null\n    log \"Done! Please run the script again\"\n    exit\n}\n\nversion_get() {\n    pushd .. >/dev/null\n    if [[ -d .git ]]; then\n        if [[ -e .git/shallow ]]; then\n            log \"Shallow git repository detected. Unshallowing...\"\n            git fetch --unshallow\n        fi\n        git_hash=$(git rev-parse HEAD | cut -c -7)\n        local dm=$(git log -1 --format=%ci | cut -c 3- | cut -c -5)\n        version_current=v${dm//-/.}.\n        dm=\"20$dm\"\n        if [[ $(uname) == \"Darwin\" ]]; then\n            dm=\"$(date -j -f \"%Y-%m-%d %H:%M:%S\" \"${dm}-01 00:00:00\" +%s)\"\n        else\n            dm=\"$(date --date=\"${dm}-01\" +%s)\"\n        fi\n        dm=$((dm-1))\n        version_current+=$(git rev-list --count HEAD --since=$dm | xargs printf \"%02d\")\n    elif [[ -e ./resources/git_hash ]]; then\n        version_current=\"$(cat ./resources/version)\"\n        git_hash=\"$(cat ./resources/git_hash)\"\n    else\n        log \".git directory and git_hash file not found, cannot determine version.\"\n        if [[ $no_version_check != 1 ]]; then\n            warn \"Your copy of Legacy iOS Kit is downloaded incorrectly. Do not use the \\\"Code\\\" button in GitHub.\"\n            print \"* Please download Legacy iOS Kit using git clone or from GitHub releases: https://github.com/LukeZGD/Legacy-iOS-Kit/releases\"\n        fi\n    fi\n    if [[ -n $version_current ]]; then\n        print \"* Version: $version_current ($git_hash)\"\n    fi\n    popd >/dev/null\n}\n\nversion_check() {\n    if [[ $no_version_check == 1 ]]; then\n        warn \"No version check flag detected, update check is disabled and no support will be provided.\"\n        return\n    fi\n    pushd .. >/dev/null\n    version_update_check\n    if [[ -z $version_latest ]]; then\n        warn \"Failed to check for updates. GitHub may be down or blocked by your network.\"\n    elif [[ $git_hash_latest != \"$git_hash\" ]]; then\n        if [[ -z $version_current ]]; then\n            print \"* Latest version:  $version_latest ($git_hash_latest)\"\n            print \"* Please download/pull the latest version before proceeding.\"\n            version_update\n        elif (( $(echo $version_current | cut -c 2- | sed -e 's/\\.//g') >= $(echo $version_latest | cut -c 2- | sed -e 's/\\.//g') )); then\n            warn \"Current version is newer/different than remote: $version_latest ($git_hash_latest)\"\n        else\n            print \"* A newer version of Legacy iOS Kit is available.\"\n            print \"* Current version: $version_current ($git_hash)\"\n            print \"* Latest version:  $version_latest ($git_hash_latest)\"\n            print \"* Please download/pull the latest version before proceeding.\"\n            version_update\n        fi\n    fi\n    popd >/dev/null\n}\n\ndevice_entry() {\n    # enable manual entry\n    log \"Manual device/ECID entry is enabled.\"\n    until [[ -n $device_type ]]; do\n        read -p \"$(input 'Enter device type (eg. iPad2,1): ')\" device_type\n    done\n    if [[ $main_argmode == \"device_justboot\" || $main_argmode == \"device_enter_ramdisk\"* ]]; then\n        :\n    elif [[ $device_type != \"iPhone1\"* && $device_type != \"iPod1,1\" ]]; then\n        until [[ -n $device_ecid ]] && [ \"$device_ecid\" -eq \"$device_ecid\" ]; do\n            read -p \"$(input 'Enter device ECID (must be decimal): ')\" device_ecid\n        done\n    fi\n}\n\ndevice_get_name() {\n    # all devices that run iOS/iPhoneOS/iPadOS\n    device_name=$device_type\n    case $device_type in\n        \"iPhone1,1\") device_name=\"iPhone 2G\";;\n        \"iPhone1,2\") device_name=\"iPhone 3G\";;\n        \"iPhone2,1\") device_name=\"iPhone 3GS\";;\n        \"iPhone3,1\") device_name=\"iPhone 4 (GSM)\";;\n        \"iPhone3,2\") device_name=\"iPhone 4 (GSM, Rev A)\";;\n        \"iPhone3,3\") device_name=\"iPhone 4 (CDMA)\";;\n        \"iPhone4,1\") device_name=\"iPhone 4S\";;\n        \"iPhone5,1\") device_name=\"iPhone 5 (GSM)\";;\n        \"iPhone5,2\") device_name=\"iPhone 5 (Global)\";;\n        \"iPhone5,3\") device_name=\"iPhone 5C (GSM)\";;\n        \"iPhone5,4\") device_name=\"iPhone 5C (Global)\";;\n        \"iPhone6,1\") device_name=\"iPhone 5S (GSM)\";;\n        \"iPhone6,2\") device_name=\"iPhone 5S (Global)\";;\n        \"iPhone7,1\") device_name=\"iPhone 6 Plus\";;\n        \"iPhone7,2\") device_name=\"iPhone 6\";;\n        \"iPhone8,1\") device_name=\"iPhone 6S\";;\n        \"iPhone8,2\") device_name=\"iPhone 6S Plus\";;\n        \"iPhone8,4\") device_name=\"iPhone SE 2016\";;\n        \"iPhone9,1\") device_name=\"iPhone 7 (Global)\";;\n        \"iPhone9,2\") device_name=\"iPhone 7 Plus (Global)\";;\n        \"iPhone9,3\") device_name=\"iPhone 7 (GSM)\";;\n        \"iPhone9,4\") device_name=\"iPhone 7 Plus (GSM)\";;\n        \"iPhone10,1\") device_name=\"iPhone 8 (Global)\";;\n        \"iPhone10,2\") device_name=\"iPhone 8 Plus (Global)\";;\n        \"iPhone10,3\") device_name=\"iPhone X (Global)\";;\n        \"iPhone10,4\") device_name=\"iPhone 8 (GSM)\";;\n        \"iPhone10,5\") device_name=\"iPhone 8 Plus (GSM)\";;\n        \"iPhone10,6\") device_name=\"iPhone X (GSM)\";;\n        \"iPhone11,2\") device_name=\"iPhone XS\";;\n        \"iPhone11,4\") device_name=\"iPhone XS Max (China)\";;\n        \"iPhone11,6\") device_name=\"iPhone XS Max\";;\n        \"iPhone11,8\") device_name=\"iPhone XR\";;\n        \"iPhone12,1\") device_name=\"iPhone 11\";;\n        \"iPhone12,3\") device_name=\"iPhone 11 Pro\";;\n        \"iPhone12,5\") device_name=\"iPhone 11 Pro Max\";;\n        \"iPhone12,8\") device_name=\"iPhone SE 2020\";;\n        \"iPhone13,1\") device_name=\"iPhone 12 mini\";;\n        \"iPhone13,2\") device_name=\"iPhone 12\";;\n        \"iPhone13,3\") device_name=\"iPhone 12 Pro\";;\n        \"iPhone13,4\") device_name=\"iPhone 12 Pro Max\";;\n        \"iPhone14,2\") device_name=\"iPhone 13 Pro\";;\n        \"iPhone14,3\") device_name=\"iPhone 13 Pro Max\";;\n        \"iPhone14,4\") device_name=\"iPhone 13 mini\";;\n        \"iPhone14,5\") device_name=\"iPhone 13\";;\n        \"iPhone14,6\") device_name=\"iPhone SE 2022\";;\n        \"iPhone14,7\") device_name=\"iPhone 14\";;\n        \"iPhone14,8\") device_name=\"iPhone 14 Plus\";;\n        \"iPhone15,2\") device_name=\"iPhone 14 Pro\";;\n        \"iPhone15,3\") device_name=\"iPhone 14 Pro Max\";;\n        \"iPhone15,4\") device_name=\"iPhone 15\";;\n        \"iPhone15,5\") device_name=\"iPhone 15 Plus\";;\n        \"iPhone16,1\") device_name=\"iPhone 15 Pro\";;\n        \"iPhone16,2\") device_name=\"iPhone 15 Pro Max\";;\n        \"iPhone17,1\") device_name=\"iPhone 16 Pro\";;\n        \"iPhone17,2\") device_name=\"iPhone 16 Pro Max\";;\n        \"iPhone17,3\") device_name=\"iPhone 16\";;\n        \"iPhone17,4\") device_name=\"iPhone 16 Plus\";;\n        \"iPad1,1\") device_name=\"iPad 1\";;\n        \"iPad2,1\") device_name=\"iPad 2 (Wi-Fi)\";;\n        \"iPad2,2\") device_name=\"iPad 2 (GSM)\";;\n        \"iPad2,3\") device_name=\"iPad 2 (CDMA)\";;\n        \"iPad2,4\") device_name=\"iPad 2 (Wi-Fi, Rev A)\";;\n        \"iPad2,5\") device_name=\"iPad mini 1 (Wi-Fi)\";;\n        \"iPad2,6\") device_name=\"iPad mini 1 (GSM)\";;\n        \"iPad2,7\") device_name=\"iPad mini 1 (Global)\";;\n        \"iPad3,1\") device_name=\"iPad 3 (Wi-Fi)\";;\n        \"iPad3,2\") device_name=\"iPad 3 (CDMA)\";;\n        \"iPad3,3\") device_name=\"iPad 3 (GSM)\";;\n        \"iPad3,4\") device_name=\"iPad 4 (Wi-Fi)\";;\n        \"iPad3,5\") device_name=\"iPad 4 (GSM)\";;\n        \"iPad3,6\") device_name=\"iPad 4 (Global)\";;\n        \"iPad4,1\") device_name=\"iPad Air 1 (Wi-Fi)\";;\n        \"iPad4,2\") device_name=\"iPad Air 1 (Cellular)\";;\n        \"iPad4,3\") device_name=\"iPad Air 1 (China)\";;\n        \"iPad4,4\") device_name=\"iPad mini 2 (Wi-Fi)\";;\n        \"iPad4,5\") device_name=\"iPad mini 2 (Cellular)\";;\n        \"iPad4,6\") device_name=\"iPad mini 2 (China)\";;\n        \"iPad4,7\") device_name=\"iPad mini 3 (Wi-Fi)\";;\n        \"iPad4,8\") device_name=\"iPad mini 3 (Cellular)\";;\n        \"iPad4,9\") device_name=\"iPad mini 3 (China)\";;\n        \"iPad5,1\") device_name=\"iPad mini 4 (Wi-Fi)\";;\n        \"iPad5,2\") device_name=\"iPad mini 4 (Cellular)\";;\n        \"iPad5,3\") device_name=\"iPad Air 2 (Wi-Fi)\";;\n        \"iPad5,4\") device_name=\"iPad Air 2 (Cellular)\";;\n        \"iPad6,3\") device_name=\"iPad Pro 9.7\\\" (Wi-Fi)\";;\n        \"iPad6,4\") device_name=\"iPad Pro 9.7\\\" (Cellular)\";;\n        \"iPad6,7\") device_name=\"iPad Pro 12.9\\\" (Wi-Fi)\";;\n        \"iPad6,8\") device_name=\"iPad Pro 12.9\\\" (Cellular)\";;\n        \"iPad6,11\") device_name=\"iPad 5 (Wi-Fi)\";;\n        \"iPad6,12\") device_name=\"iPad 5 (Cellular)\";;\n        \"iPad7,1\") device_name=\"iPad Pro 12.9\\\" (2nd gen, Wi-Fi)\";;\n        \"iPad7,2\") device_name=\"iPad Pro 12.9\\\" (2nd gen, Cellular)\";;\n        \"iPad7,3\") device_name=\"iPad Pro 10.5\\\" (Wi-Fi)\";;\n        \"iPad7,4\") device_name=\"iPad Pro 10.5\\\" (Cellular)\";;\n        \"iPad7,5\") device_name=\"iPad 6 (Wi-Fi)\";;\n        \"iPad7,6\") device_name=\"iPad 6 (Cellular)\";;\n        \"iPad7,11\") device_name=\"iPad 7 (Wi-Fi)\";;\n        \"iPad7,12\") device_name=\"iPad 7 (Cellular)\";;\n        \"iPad8,1\") device_name=\"iPad Pro 11\\\" (Wi-Fi)\";;\n        \"iPad8,2\") device_name=\"iPad Pro 11\\\" (Wi-Fi, 6GB RAM)\";;\n        \"iPad8,3\") device_name=\"iPad Pro 11\\\" (Cellular)\";;\n        \"iPad8,4\") device_name=\"iPad Pro 11\\\" (Cellular, 6GB RAM)\";;\n        \"iPad8,5\") device_name=\"iPad Pro 12.9\\\" (3rd gen, Wi-Fi)\";;\n        \"iPad8,6\") device_name=\"iPad Pro 12.9\\\" (3rd gen, Wi-Fi, 6GB RAM)\";;\n        \"iPad8,7\") device_name=\"iPad Pro 12.9\\\" (3rd gen, Cellular)\";;\n        \"iPad8,8\") device_name=\"iPad Pro 12.9\\\" (3rd gen, Cellular, 6GB RAM)\";;\n        \"iPad8,9\") device_name=\"iPad Pro 11\\\" (2nd gen, Wi-Fi)\";;\n        \"iPad8,10\") device_name=\"iPad Pro 11\\\" (2nd gen, Cellular)\";;\n        \"iPad8,11\") device_name=\"iPad Pro 12.9\\\" (4th gen, Wi-Fi)\";;\n        \"iPad8,12\") device_name=\"iPad Pro 12.9\\\" (4th gen, Cellular)\";;\n        \"iPad11,1\") device_name=\"iPad mini 5 (Wi-Fi)\";;\n        \"iPad11,2\") device_name=\"iPad mini 5 (Cellular)\";;\n        \"iPad11,3\") device_name=\"iPad Air 3 (Wi-Fi)\";;\n        \"iPad11,4\") device_name=\"iPad Air 3 (Cellular)\";;\n        \"iPad11,6\") device_name=\"iPad 8 (Wi-Fi)\";;\n        \"iPad11,7\") device_name=\"iPad 8 (Cellular)\";;\n        \"iPad12,1\") device_name=\"iPad 9 (Wi-Fi)\";;\n        \"iPad12,2\") device_name=\"iPad 9 (Cellular)\";;\n        \"iPad13,1\") device_name=\"iPad Air 4 (Wi-Fi)\";;\n        \"iPad13,2\") device_name=\"iPad Air 4 (Cellular)\";;\n        \"iPad13,4\") device_name=\"iPad Pro 11\\\" (3rd gen, Wi-Fi)\";;\n        \"iPad13,5\") device_name=\"iPad Pro 11\\\" (3rd gen, Wi-Fi, 16GB RAM)\";;\n        \"iPad13,6\") device_name=\"iPad Pro 11\\\" (3rd gen, Cellular)\";;\n        \"iPad13,7\") device_name=\"iPad Pro 11\\\" (3rd gen, Cellular, 16GB RAM)\";;\n        \"iPad13,8\") device_name=\"iPad Pro 12.9\\\" (5th gen, Wi-Fi)\";;\n        \"iPad13,9\") device_name=\"iPad Pro 12.9\\\" (5th gen, Wi-Fi, 16GB RAM)\";;\n        \"iPad13,10\") device_name=\"iPad Pro 12.9\\\" (5th gen, Cellular)\";;\n        \"iPad13,11\") device_name=\"iPad Pro 12.9\\\" (5th gen, Cellular, 16GB RAM)\";;\n        \"iPad13,16\") device_name=\"iPad Air 5 (Wi-Fi)\";;\n        \"iPad13,17\") device_name=\"iPad Air 5 (Cellular)\";;\n        \"iPad13,18\") device_name=\"iPad 10 (Wi-Fi)\";;\n        \"iPad13,19\") device_name=\"iPad 10 (Cellular)\";;\n        \"iPad14,1\") device_name=\"iPad mini 6 (Wi-Fi)\";;\n        \"iPad14,2\") device_name=\"iPad mini 6 (Cellular)\";;\n        \"iPad14,3\") device_name=\"iPad Pro 11\\\" (4th gen, Wi-Fi)\";;\n        \"iPad14,4\") device_name=\"iPad Pro 11\\\" (4th gen, Cellular)\";;\n        \"iPad14,5\") device_name=\"iPad Pro 12.9\\\" (6th gen, Wi-Fi)\";;\n        \"iPad14,6\") device_name=\"iPad Pro 12.9\\\" (6th gen, Cellular)\";;\n        \"iPad14,8\") device_name=\"iPad Air 11\\\" (M2, Wi-Fi)\";;\n        \"iPad14,9\") device_name=\"iPad Air 11\\\" (M2, Cellular)\";;\n        \"iPad14,10\") device_name=\"iPad Air 13\\\" (M2, Wi-Fi)\";;\n        \"iPad14,11\") device_name=\"iPad Air 13\\\" (M2, Cellular)\";;\n        \"iPad16,1\") device_name=\"iPad mini (A17 Pro, Wi-Fi)\";;\n        \"iPad16,2\") device_name=\"iPad mini (A17 Pro, Cellular)\";;\n        \"iPad16,3\") device_name=\"iPad Pro 11\\\" (M4, Wi-Fi)\";;\n        \"iPad16,4\") device_name=\"iPad Pro 11\\\" (M4, Cellular)\";;\n        \"iPad16,5\") device_name=\"iPad Pro 12.9\\\" (M4, Wi-Fi)\";;\n        \"iPad16,6\") device_name=\"iPad Pro 12.9\\\" (M4, Cellular)\";;\n        \"iPod1,1\") device_name=\"iPod touch 1\";;\n        \"iPod2,1\") device_name=\"iPod touch 2\";;\n        \"iPod3,1\") device_name=\"iPod touch 3\";;\n        \"iPod4,1\") device_name=\"iPod touch 4\";;\n        \"iPod5,1\") device_name=\"iPod touch 5\";;\n        \"iPod7,1\") device_name=\"iPod touch 6\";;\n        \"iPod9,1\") device_name=\"iPod touch 7\";;\n    esac\n}\n\ndevice_manufacturing() {\n    if [[ $device_type != \"iPhone2,1\" && $device_type != \"iPod2,1\" ]] || [[ $device_argmode == \"none\" ]]; then\n        return\n    fi\n    if [[ $device_type == \"iPhone2,1\" && $device_mode != \"DFU\" ]]; then\n        local week=$(echo \"$device_serial\" | cut -c 2-)\n        local year=$(echo \"$device_serial\" | cut -c 1)\n        case $year in\n            9 ) year=\"2009\";;\n            0 ) year=\"2010\";;\n            1 ) year=\"2011\";;\n            2 ) year=\"2012\";;\n        esac\n        if [[ $year != \"2009\" ]] || (( week >= 46 )); then\n            device_newbr=1\n        elif [[ $year == \"2009\" ]] && (( week >= 40 )); then\n            device_newbr=2 # gray area\n        else\n            device_newbr=0\n        fi\n    elif [[ $device_type == \"iPod2,1\" && $device_mode == \"Recovery\" ]]; then\n        device_newbr=2\n        return\n    fi\n    case $device_newbr in\n        0 ) print \"* This $device_name is an old bootrom model\";;\n        1 ) print \"* This $device_name is a new bootrom model\";;\n        2 ) print \"* This $device_name bootrom model cannot be determined. Enter DFU mode to get bootrom model\";;\n    esac\n    if [[ $device_type == \"iPhone2,1\" && $device_mode == \"DFU\" ]]; then\n        print \"* Cannot check for manufacturing date in DFU mode\"\n    elif [[ $device_type == \"iPhone2,1\" ]]; then\n        print \"* Manufactured in Week $week $year\"\n    fi\n}\n\ndevice_s5l8900xall() {\n    local wtf_sha=\"cb96954185a91712c47f20adb519db45a318c30f\"\n    local wtf_saved=\"../saved/WTF.s5l8900xall.RELEASE.dfu\"\n    local wtf_patched=\"$wtf_saved.patched\"\n    local wtf_patch=\"../resources/patch/WTF.s5l8900xall.RELEASE.patch\"\n    local wtf_sha_local=\"$($sha1sum \"$wtf_saved\" 2>/dev/null | awk '{print $1}')\"\n    mkdir ../saved 2>/dev/null\n    if [[ $wtf_sha_local != \"$wtf_sha\" ]]; then\n        log \"Downloading WTF.s5l8900xall\"\n        \"$dir/pzb\" -g \"Firmware/dfu/WTF.s5l8900xall.RELEASE.dfu\" -o WTF.s5l8900xall.RELEASE.dfu \"http://appldnld.apple.com/iPhone/061-7481.20100202.4orot/iPhone1,1_3.1.3_7E18_Restore.ipsw\"\n        rm -f \"$wtf_saved\"\n        mv WTF.s5l8900xall.RELEASE.dfu $wtf_saved\n    fi\n    wtf_sha_local=\"$($sha1sum \"$wtf_saved\" | awk '{print $1}')\"\n    if [[ $wtf_sha_local != \"$wtf_sha\" ]]; then\n        error \"SHA1sum mismatch. Expected $wtf_sha, got $wtf_sha_local. Please run the script again\"\n    fi\n    rm -f \"$wtf_patched\"\n    log \"Patching WTF.s5l8900xall\"\n    $bspatch $wtf_saved $wtf_patched $wtf_patch\n    log \"Sending patched WTF.s5l8900xall (Pwnage)\"\n    $irecovery -f \"$wtf_patched\"\n    device_find_mode DFUreal\n    sleep 1\n}\n\ndevice_get_info() {\n    : '\n    usage: device_get_info (no arguments)\n    sets the variables: device_mode, device_type, device_ecid, device_vers, device_udid, device_model, device_fw_dir,\n    device_use_vers, device_use_build, device_use_bb, device_use_bb_sha1, device_latest_vers, device_latest_build,\n    device_latest_bb, device_latest_bb_sha1, device_proc\n    '\n\n    if [[ $device_argmode == \"none\" ]]; then\n        log \"No device mode is enabled.\"\n        device_mode=\"none\"\n        device_vers=\"Unknown\"\n    elif [[ $main_argmode == \"device_enter_ramdisk_menu\" ]]; then\n        log \"sshrd-menu flag detected, assuming device is in SSH ramdisk mode\"\n        device_mode=\"Normal\"\n    else\n        log \"Finding device in Normal mode...\"\n        if [[ $platform == \"linux\" ]]; then\n            print \"* If it gets stuck here, try to restart your PC\"\n            if [[ $othertmp != 0 ]]; then\n                print \"* If it fails to detect devices, try to delete all \\\"tmp\\\" folders in your Legacy iOS Kit folder\"\n            fi\n        fi\n        $ideviceinfo -s >/dev/null\n        if [[ $? == 0 ]]; then\n            device_mode=\"Normal\"\n        else\n            $ideviceinfo >/dev/null\n            if [[ $? == 0 ]]; then\n                device_mode=\"Normal\"\n            fi\n        fi\n    fi\n\n    if [[ -z $device_mode ]]; then\n        log \"Finding device in Recovery/DFU mode...\"\n        device_mode=\"$($irecovery -q | grep -w \"MODE\" | cut -c 7-)\"\n    fi\n\n    if [[ $device_mode == \"Recovery\" && $device_pwnrec == 1 ]]; then\n        device_mode=\"DFU\"\n    fi\n\n    if [[ -z $device_mode ]]; then\n        local error_msg=$'* Make sure to trust this computer by selecting \"Trust\" at the pop-up.'\n        if [[ $platform == \"macos\" ]]; then\n            error_msg+=$'\\n* Make sure to have the initial setup dependencies installed before retrying.'\n            error_msg+=$'\\n* Double-check if the device is being detected by iTunes/Finder.'\n        else\n            error_msg+=$'\\n* If your device in normal mode is not being detected, this is likely a usbmuxd issue.'\n            error_msg+=$'\\n* You may also try again in a live USB.'\n        fi\n        error_msg+=$'\\n* Try restarting your PC/Mac as well as using different USB ports/cables.'\n        error_msg+=$'\\n* For more details, read the \"Troubleshooting\" wiki page in GitHub.\\n* Troubleshooting link: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting'\n        error \"No device found! Please connect the iOS device to proceed.\" \"$error_msg\"\n    fi\n\n    log \"Getting device info...\"\n    if [[ $device_mode == \"WTF\" ]]; then\n        device_proc=1\n        device_wtfexit=1\n        device_s5l8900xall\n    fi\n    case $device_mode in\n        \"DFU\" | \"Recovery\" )\n            if [[ -n $device_argmode ]]; then\n                device_entry\n            else\n                device_type=$($irecovery -q | grep \"PRODUCT\" | cut -c 10-)\n                device_ecid=$(printf \"%d\" $($irecovery -q | grep \"ECID\" | cut -c 7-)) # converts hex ecid to dec\n            fi\n            if [[ $device_type == \"iPhone1,1\" && -z $device_argmode ]]; then\n                print \"* Device Type Option\"\n                print \"* Select Y if the device is an iPhone 2G, or N if it is an iPod touch 1\"\n                select_yesno \"Is this device an iPhone 2G?\" 1\n                if [[ $? != 1 ]]; then\n                    device_type=\"iPod1,1\"\n                fi\n            fi\n            device_model=$($irecovery -q | grep \"MODEL\" | cut -c 8-)\n            device_vers=$(echo \"/exit\" | $irecovery -s | grep -a \"iBoot-\")\n            if [[ -z $device_vers ]]; then\n                device_vers=\"Unknown\"\n                if [[ $device_mode == \"Recovery\" ]]; then\n                    device_vers+=\". Re-enter recovery mode to get iBoot version\"\n                fi\n            fi\n            device_serial=\"$($irecovery -q | grep \"SRNM\" | cut -c 7- | cut -c 3- | cut -c -3)\"\n            device_get_name\n            print \"* Device: $device_name (${device_type} - ${device_model}) in $device_mode mode\"\n            print \"* iOS Version: $device_vers\"\n            print \"* ECID: $device_ecid\"\n            device_manufacturing\n            if [[ $device_type == \"iPod2,1\" && $device_newbr != 2 ]]; then\n                device_newbr=\"$($irecovery -q | grep -c '240.5.1')\"\n            elif [[ $device_type == \"iPhone2,1\" ]]; then\n                device_newbr=\"$($irecovery -q | grep -c '359.3.2')\"\n            fi\n            device_pwnd=\"$($irecovery -q | grep \"PWND\" | cut -c 7-)\"\n        ;;\n\n        \"Normal\" )\n            if [[ -n $device_argmode ]]; then\n                device_entry\n            else\n                device_type=$($ideviceinfo -s -k ProductType)\n                [[ -z $device_type ]] && device_type=$($ideviceinfo -k ProductType)\n                device_ecid=$($ideviceinfo -s -k UniqueChipID)\n            fi\n            if [[ $main_argmode != \"device_enter_ramdisk\"* ]]; then\n                device_model=$($ideviceinfo -s -k HardwareModel)\n                device_vers=$($ideviceinfo -s -k ProductVersion)\n                device_det=$(echo \"$device_vers\" | cut -c 1)\n                device_det2=$(echo \"$device_vers\" | cut -c -2)\n                device_build=$($ideviceinfo -s -k BuildVersion)\n                device_udid=$($ideviceinfo -s -k UniqueDeviceID)\n                [[ -z $device_udid ]] && device_udid=$($ideviceinfo -k UniqueDeviceID)\n                if [[ $device_type == \"iPod2,1\" ]]; then\n                    device_newbr=\"$($ideviceinfo -k ModelNumber | grep -c 'C')\"\n                elif [[ $device_type == \"iPhone2,1\" ]]; then\n                    device_serial=\"$($ideviceinfo -k SerialNumber | cut -c 3- | cut -c -3)\"\n                fi\n                device_unactivated=$($ideviceactivation state | grep -c \"Unactivated\")\n            fi\n        ;;\n    esac\n\n    if [[ $device_argmode == \"none\" ]]; then\n        device_entry\n    fi\n\n    device_model=\"$(echo $device_model | tr '[:upper:]' '[:lower:]')\"\n    device_model=\"${device_model%??}\" # remove \"ap\" from the end\n    if [[ -z $device_type && -n $device_model ]]; then\n        # device_model fallback (this will be up to checkm8 devices only)\n        case $device_model in\n            k48  ) device_type=\"iPad1,1\";;\n            k93  ) device_type=\"iPad2,1\";;\n            k94  ) device_type=\"iPad2,2\";;\n            k95  ) device_type=\"iPad2,3\";;\n            k93a ) device_type=\"iPad2,4\";;\n            p105 ) device_type=\"iPad2,5\";;\n            p106 ) device_type=\"iPad2,6\";;\n            p107 ) device_type=\"iPad2,7\";;\n            j1   ) device_type=\"iPad3,1\";;\n            j2   ) device_type=\"iPad3,2\";;\n            j2a  ) device_type=\"iPad3,3\";;\n            p101 ) device_type=\"iPad3,4\";;\n            p102 ) device_type=\"iPad3,5\";;\n            p103 ) device_type=\"iPad3,6\";;\n            j71  ) device_type=\"iPad4,1\";;\n            j72  ) device_type=\"iPad4,2\";;\n            j73  ) device_type=\"iPad4,3\";;\n            j85  ) device_type=\"iPad4,4\";;\n            j86  ) device_type=\"iPad4,5\";;\n            j87  ) device_type=\"iPad4,6\";;\n            j85m ) device_type=\"iPad4,7\";;\n            j86m ) device_type=\"iPad4,8\";;\n            j87m ) device_type=\"iPad4,9\";;\n            j96  ) device_type=\"iPad5,1\";;\n            j97  ) device_type=\"iPad5,2\";;\n            j81  ) device_type=\"iPad5,3\";;\n            j82  ) device_type=\"iPad5,4\";;\n            j127 ) device_type=\"iPad6,3\";;\n            j128 ) device_type=\"iPad6,4\";;\n            j98a ) device_type=\"iPad6,7\";;\n            j99a ) device_type=\"iPad6,8\";;\n            j71s ) device_type=\"iPad6,11\";;\n            j71t ) device_type=\"iPad6,11\";;\n            j72s ) device_type=\"iPad6,12\";;\n            j72t ) device_type=\"iPad6,12\";;\n            j120 ) device_type=\"iPad7,1\";;\n            j121 ) device_type=\"iPad7,2\";;\n            j207 ) device_type=\"iPad7,3\";;\n            j208 ) device_type=\"iPad7,4\";;\n            j71b ) device_type=\"iPad7,5\";;\n            j72b ) device_type=\"iPad7,6\";;\n            j171 ) device_type=\"iPad7,11\";;\n            j172 ) device_type=\"iPad7,12\";;\n            m68  ) device_type=\"iPhone1,1\";;\n            n82  ) device_type=\"iPhone1,2\";;\n            n88  ) device_type=\"iPhone2,1\";;\n            n90  ) device_type=\"iPhone3,1\";;\n            n90b ) device_type=\"iPhone3,2\";;\n            n92  ) device_type=\"iPhone3,3\";;\n            n94  ) device_type=\"iPhone4,1\";;\n            n41  ) device_type=\"iPhone5,1\";;\n            n42  ) device_type=\"iPhone5,2\";;\n            n48  ) device_type=\"iPhone5,3\";;\n            n49  ) device_type=\"iPhone5,4\";;\n            n51  ) device_type=\"iPhone6,1\";;\n            n53  ) device_type=\"iPhone6,2\";;\n            n56  ) device_type=\"iPhone7,1\";;\n            n61  ) device_type=\"iPhone7,2\";;\n            n71  ) device_type=\"iPhone8,1\";;\n            n71m ) device_type=\"iPhone8,1\";;\n            n66  ) device_type=\"iPhone8,2\";;\n            n66m ) device_type=\"iPhone8,2\";;\n            n69  ) device_type=\"iPhone8,4\";;\n            n69u ) device_type=\"iPhone8,4\";;\n            d10  ) device_type=\"iPhone9,1\";;\n            d11  ) device_type=\"iPhone9,2\";;\n            d101 ) device_type=\"iPhone9,3\";;\n            d111 ) device_type=\"iPhone9,4\";;\n            d20  ) device_type=\"iPhone10,1\";;\n            d21  ) device_type=\"iPhone10,2\";;\n            d22  ) device_type=\"iPhone10,3\";;\n            d201 ) device_type=\"iPhone10,4\";;\n            d211 ) device_type=\"iPhone10,5\";;\n            d221 ) device_type=\"iPhone10,6\";;\n            n45  ) device_type=\"iPod1,1\";;\n            n72  ) device_type=\"iPod2,1\";;\n            n18  ) device_type=\"iPod3,1\";;\n            n81  ) device_type=\"iPod4,1\";;\n            n78  ) device_type=\"iPod5,1\";;\n            n102 ) device_type=\"iPod7,1\";;\n            n112 ) device_type=\"iPod9,1\";;\n        esac\n    fi\n    case $device_type in\n        iPhone3,[13] | iPhone[45]* | iPad1,1 | iPad2,4 | iPod[35],1 ) device_canpowder=1;;\n    esac\n\n    device_fw_dir=\"../resources/firmware/$device_type\"\n    if [[ -s $device_fw_dir/hwmodel ]]; then\n        device_model=\"$(cat $device_fw_dir/hwmodel)\"\n    fi\n    all_flash=\"Firmware/all_flash/all_flash.${device_model}ap.production\"\n    device_use_bb=0\n    device_latest_bb=0\n    # set device_proc (what processor the device has)\n    case $device_type in\n        iPhone1,[12] | iPod1,1 )\n            device_proc=1;; # S5L8900\n        iPhone3,[123] | iPhone2,1 | iPad1,1 | iPod[234],1 )\n            device_proc=4;; # A4/S5L8720/8920/8922\n        iPad2,[1234567] | iPad3,[123] | iPhone4,1 | iPod5,1 )\n            device_proc=5;; # A5\n        iPad3,[456] | iPhone5,[1234] )\n            device_proc=6;; # A6\n        iPad4,[123456789] | iPhone6,[12] )\n            device_proc=7;; # A7\n        iPhone7,[12] | iPad5,[1234] | iPod7,1 )\n            device_proc=8;; # A8\n        iPhone8,[124] )\n            device_proc=9;; # A9\n        iPhone9,[1234] | iPhone10* | iPad[67]* | iPod9,1 )\n            device_proc=10;; # A10 (or A9/A10 iPad/A11 device)\n        iPhone* | iPad* )\n            device_proc=11;; # Newer devices\n    esac\n    case $device_type in\n        iPad7* ) device_checkm8ipad=1;;\n    esac\n    device_get_name\n    if (( device_proc > 10 )); then\n        print \"* Device: $device_name (${device_type} - ${device_model}ap) in $device_mode mode\"\n        print \"* iOS Version: $device_vers\"\n        print \"* ECID: $device_ecid\"\n        echo\n        warn \"This device is mostly not supported by Legacy iOS Kit.\"\n        print \"* You may still continue but options will be limited to sideloading and other basic features.\"\n        pause\n    elif [[ -z $device_proc ]]; then\n        error \"Unrecognized device $device_type. Enter the device type properly.\"\n    fi\n\n    if [[ $device_mode == \"DFU\" && $device_proc == 1 && $device_wtfexit != 1 ]]; then\n        log \"Found an S5L8900 device in $device_mode mode. Your device needs to be in WTF mode to continue.\"\n        print \"* Force restart your device and place it in normal or recovery mode, then re-enter WTF mode.\"\n        print \"* You can enter WTF mode by doing the DFU mode procedure.\"\n        device_dfuhelper norec WTFreal\n        device_find_mode WTFreal 100\n    fi\n\n    # set device_use_vers, device_use_build (where to get the baseband and manifest from for ota/other)\n    # for a7/a8 other restores 11.3+, device_latest_vers and device_latest_build are used\n    case $device_type in\n        iPhone1,1 | iPod1,1 )\n            device_use_vers=\"3.1.3\"\n            device_use_build=\"7E18\"\n        ;;\n        iPhone1,2 | iPod2,1 )\n            device_use_vers=\"4.2.1\"\n            device_use_build=\"8C148\"\n        ;;\n        iPad1,1 | iPod3,1 )\n            device_use_vers=\"5.1.1\"\n            device_use_build=\"9B206\"\n        ;;\n        iPhone2,1 | iPod4,1 )\n            device_use_vers=\"6.1.6\"\n            device_use_build=\"10B500\"\n        ;;\n        iPhone3,[123] )\n            device_use_vers=\"7.1.2\"\n            device_use_build=\"11D257\"\n        ;;\n        iPad2,[1245] | iPad3,1 | iPod5,1 )\n            device_use_vers=\"9.3.5\"\n            device_use_build=\"13G36\"\n        ;;\n        iPad2,[367] | iPad3,[23] | iPhone4,1 )\n            device_use_vers=\"9.3.6\"\n            device_use_build=\"13G37\"\n        ;;\n        iPad3,[56] | iPhone5,[1234] )\n            device_use_vers=\"10.3.4\"\n            device_use_build=\"14G61\"\n        ;;\n        iPad3,4 | iPad4,[12345] | iPhone6,[12] )\n            device_use_vers=\"10.3.3\"\n            device_use_build=\"14G60\"\n        ;;\n    esac\n    case $device_type in\n        iPad4,[123456789] | iPhone6,[12] | iPhone7,[12] | iPod7,1 )\n            device_latest_vers=\"12.5.7\"\n            device_latest_build=\"16H81\"\n        ;;\n        iPad5* | iPhone[89]* | iPod9,1 )\n            device_latest_vers=\"15.8.3\"\n            device_latest_build=\"19H386\"\n        ;;\n        iPad6* | iPhone10* )\n            device_latest_vers=\"16.7.10\"\n            device_latest_build=\"20H350\"\n        ;;\n        iPad7* )\n            log \"Getting latest iOS version for $device_type\"\n            local latestver=\"$(curl \"https://api.ipsw.me/v4/device/$device_type?type=ipsw\" | $jq -j \".firmwares[0]\")\"\n            device_latest_vers=\"$(echo \"$latestver\" | $jq -j \".version\")\"\n            device_latest_build=\"$(echo \"$latestver\" | $jq -j \".buildid\")\"\n        ;;\n    esac\n    # set device_use_bb, device_use_bb_sha1 (what baseband to use for ota/other)\n    # for a7/a8 other restores 11.3+, device_latest_bb and device_latest_bb_sha1 are used instead\n    case $device_type in\n        iPhone4,1 ) # MDM6610\n            device_use_bb=\"Trek-6.7.00.Release.bbfw\"\n            device_use_bb_sha1=\"22a35425a3cdf8fa1458b5116cfb199448eecf49\"\n        ;;\n        iPad2,[67] ) # MDM9615 9.3.6 (32bit)\n            device_use_bb=\"Mav5-11.80.00.Release.bbfw\"\n            device_use_bb_sha1=\"aa52cf75b82fc686f94772e216008345b6a2a750\"\n        ;;\n        iPhone5,[12] | iPad3,[56] ) # MDM9615 10.3.4 (32bit)\n            device_use_bb=\"Mav5-11.80.00.Release.bbfw\"\n            device_use_bb_sha1=\"8951cf09f16029c5c0533e951eb4c06609d0ba7f\"\n        ;;\n        iPad4,[235] | iPhone5,[34] | iPhone6,[12] ) # MDM9615 10.3.3 (5C, 5S, air, mini2)\n            device_use_bb=\"Mav7Mav8-7.60.00.Release.bbfw\"\n            device_use_bb_sha1=\"f397724367f6bed459cf8f3d523553c13e8ae12c\"\n        ;;\n        iPad1,1 | iPhone[123],* ) device_use_bb2=1;;\n        iPad[23],[23] ) device_use_bb2=2;;\n    esac\n    case $device_type in\n        iPad4,[235689] | iPhone6,[12] ) # MDM9615 12.4-latest\n            device_latest_bb=\"Mav7Mav8-10.80.02.Release.bbfw\"\n            device_latest_bb_sha1=\"f5db17f72a78d807a791138cd5ca87d2f5e859f0\"\n        ;;\n    esac\n    # disable baseband update if var is set to 1 (manually disabled w/ --disable-bbupdate arg)\n    if [[ $device_disable_bbupdate == 1 && $device_use_bb != 0 ]] && (( device_proc < 7 )); then\n        device_disable_bbupdate=\"$device_type\"\n    fi\n    # if latest vers is not set, copy use vers to latest\n    if [[ -z $device_latest_vers || -z $device_latest_build ]]; then\n        device_latest_vers=$device_use_vers\n        device_latest_build=$device_use_build\n        device_latest_bb=$device_use_bb\n        device_latest_bb_sha1=$device_use_bb_sha1\n    fi\n\n    if [[ $device_argmode == \"none\" ]]; then\n        device_mode=\"none\"\n        device_vers=\"Unknown\"\n    fi\n}\n\ndevice_find_mode() {\n    # usage: device_find_mode {DFU,Recovery,Restore} {Timeout (default: 24 for linux, 4 for other)}\n    # finds device in given mode, and sets the device_mode variable\n    local usb\n    local timeout=4\n    local i=0\n    local device_in\n    local mode=\"$1\"\n    local wtfreal\n\n    if [[ $mode == \"Restore\" ]]; then\n        :\n    elif [[ $mode == \"Recovery\" ]]; then\n        usb=1281\n    elif [[ $device_proc == 1 ]]; then\n        usb=1222\n        if [[ $mode == \"DFUreal\" ]]; then\n            mode=\"DFU\"\n            usb=1227\n        elif [[ $mode == \"WTFreal\" ]]; then\n            mode=\"WTF\"\n            wtfreal=1\n        elif [[ $mode == \"DFU\" ]]; then\n            mode=\"WTF\"\n        fi\n    else\n        usb=1227\n    fi\n\n    if [[ -n $2 ]]; then\n        timeout=$2\n    elif [[ $platform == \"linux\" ]]; then\n        timeout=24\n    fi\n\n    log \"Finding device in $mode mode...\"\n    while (( i < timeout )); do\n        if [[ $mode == \"Restore\" ]]; then\n            if [[ $platform == \"macos\" ]]; then\n                opt=\"$(system_profiler SPUSBDataType 2> /dev/null | grep -B1 'Vendor ID: 0x05ac' | grep 'Product ID:' | cut -dx -f2 | cut -d' ' -f1 | tail -r | head -n 1)\"\n            elif [[ $platform == \"linux\" ]]; then\n                opt=\"$(lsusb | cut -d' ' -f6 | grep '05ac:' | cut -d: -f2)\"\n            fi\n            case $opt in\n                12[9a][0123456789abcdef] ) device_in=1;; # normal\n            esac\n        elif [[ $platform == \"linux\" ]]; then\n            device_in=$(lsusb | grep -c \"05ac:$usb\")\n        elif [[ $($irecovery -q 2>/dev/null | grep -w \"MODE\" | cut -c 7-) == \"$mode\" ]]; then\n            device_in=1\n        fi\n\n        if [[ $device_in == 1 ]]; then\n            log \"Found device in $mode mode.\"\n            if [[ $mode == \"Restore\" ]]; then\n                log \"Giving the device some time to start up SSH...\"\n                sleep 5\n            fi\n            device_mode=\"$mode\"\n            break\n        fi\n        sleep 1\n        ((i++))\n    done\n\n    if [[ $device_in != 1 ]]; then\n        if [[ $timeout != 1 && $timeout != 20 ]]; then\n            error \"Failed to find device in $mode mode (Timed out). Please run the script again.\"\n        fi\n        return 1\n    elif [[ $mode == \"WTF\" && $wtfreal != 1 ]]; then\n        device_s5l8900xall\n    fi\n}\n\ndevice_sshpass() {\n    # ask for device password and use sshpass for scp and ssh\n    ssh_user=\"root\"\n    if [[ $device_det == 1 ]]; then\n        if (( device_det2 >= 15 )); then\n            log \"iOS 15+ device detected. Connecting to device SSH as mobile...\"\n            ssh_user=\"mobile\"\n        fi\n    fi\n    local pass=$1\n    if [[ -z $pass ]]; then\n        read -s -p \"$(input \"Enter the SSH $ssh_user password of your iOS device: \")\" pass\n        echo\n    fi\n    if [[ -z $pass ]]; then\n        pass=\"alpine\"\n    fi\n    scp=\"$dir/sshpass -p $pass $scp2\"\n    ssh=\"$dir/sshpass -p $pass $ssh2\"\n}\n\ndevice_iproxy() {\n    local port=22\n    log \"Running iproxy for SSH...\"\n    if [[ -n $2 ]]; then\n        port=$2\n    fi\n    if [[ $1 == \"no-logging\" && $debug_mode != 1 ]]; then\n        \"$dir/iproxy\" $ssh_port $port -s 127.0.0.1 >/dev/null &\n        iproxy_pid=$!\n    else\n        \"$dir/iproxy\" $ssh_port $port -s 127.0.0.1 &\n        iproxy_pid=$!\n    fi\n    log \"iproxy PID: $iproxy_pid\"\n    sleep 1\n}\n\ndevice_find_all() {\n    # find device stuff from palera1n legacy\n    local opt\n    if [[ $1 == \"norec\" || $platform == \"macos\" ]]; then\n        return\n    fi\n    if [[ $platform == \"macos\" ]]; then\n        opt=\"$(system_profiler SPUSBDataType 2> /dev/null | grep -B1 'Vendor ID: 0x05ac' | grep 'Product ID:' | cut -dx -f2 | cut -d' ' -f1 | tail -r)\"\n    elif [[ $platform == \"linux\" ]]; then\n        opt=\"$(lsusb | cut -d' ' -f6 | grep '05ac:' | cut -d: -f2)\"\n    fi\n    case $opt in\n        1227 ) return 1;; # dfu\n        1281 ) return 2;; # recovery\n        1222 ) return 3;; # wtf\n        12[9a][0123456789abcdef] ) return 4;; # normal\n    esac\n}\n\ndevice_dfuhelper2() {\n    local top=\"SIDE\"\n    if [[ $device_type == \"iPad\"* ]]; then\n        top=\"TOP\"\n    fi\n    echo\n    print \"* Press the VOL UP button now.\"\n    sleep 1\n    print \"* Press the VOL DOWN button now.\"\n    sleep 1\n    print \"* Press and hold the $top button.\"\n    for i in {10..1}; do\n        echo -n \"$i \"\n        sleep 1\n    done\n    echo -e \"\\n$(print \"* Press and hold VOL DOWN and $top buttons.\")\"\n    for i in {5..1}; do\n        echo -n \"$i \"\n        sleep 1\n    done\n    echo -e \"\\n$(print \"* Release $top button and keep holding VOL DOWN button.\")\"\n    for i in {8..1}; do\n        echo -n \"$i \"\n        device_find_all $1\n        opt=$?\n        if [[ $opt == 1 ]]; then\n            echo -e \"\\n$(log 'Found device in DFU mode.')\"\n            device_mode=\"DFU\"\n            return\n        fi\n        sleep 1\n    done\n    echo\n    device_find_mode DFU\n}\n\ndevice_dfuhelper3() {\n    echo -e \"\\n$(print \"* Hold TOP and HOME buttons.\")\"\n    for i in {10..1}; do\n        echo -n \"$i \"\n        sleep 1\n    done\n    echo -e \"\\n$(print \"* Release TOP button and keep holding HOME button.\")\"\n    for i in {10..1}; do\n        echo -n \"$i \"\n        sleep 1\n    done\n    echo\n    if [[ $1 == \"WTFreal\" ]]; then\n        device_find_mode WTFreal\n    else\n        device_find_mode DFU\n    fi\n}\n\ndevice_dfuhelper() {\n    local opt\n    local rec=\" recovery mode\"\n    if [[ $1 == \"norec\" ]]; then\n        rec=\n    fi\n    if [[ $device_mode == \"DFU\" ]]; then\n        log \"Device is already in DFU mode\"\n        return\n    fi\n    print \"* DFU Mode Helper - Get ready to enter DFU mode.\"\n    print \"* If you already know how to enter DFU mode, you may do so right now before continuing.\"\n    select_yesno \"Select Y to continue, N to exit$rec\" 1\n    if [[ $? != 1 ]]; then\n        if [[ -z $1 ]]; then\n            log \"Attempting to exit Recovery mode.\"\n            $irecovery -n\n        fi\n        exit\n    fi\n    device_find_all $1\n    opt=$?\n    if [[ $opt == 1 ]]; then\n        log \"Found device in DFU mode.\"\n        device_mode=\"DFU\"\n        return\n    fi\n    print \"* Get ready...\"\n    for i in {3..1}; do\n        echo -n \"$i \"\n        sleep 1\n    done\n    case $device_type in\n        iPhone1,* | iPod1,1  ) device_dfuhelper3 $2; return;;\n        iPad1,1 | iPad1[12]* ) :;;\n        iPhone1* | iPad[81]* ) device_dfuhelper2; return;;\n    esac\n    local top=\"TOP\"\n    local home=\"HOME\"\n    case $device_type in\n        iPhone[79]* | iPhone8,[12] ) top=\"SIDE\";;\n    esac\n    if [[ $device_type == \"iPhone9\"* || $device_type == \"iPod9,1\" ]]; then\n        home=\"VOL DOWN\"\n    fi\n    local sec=10\n    if [[ $device_mode == \"Recovery\" ]]; then\n        sec=8\n    fi\n    echo -e \"\\n$(print \"* Hold $top and $home buttons.\")\"\n    while (( sec > 0 )); do\n        echo -n \"$sec \"\n        device_find_all $1\n        opt=$?\n        if [[ $opt == 1 ]]; then\n            echo -e \"\\n$(log 'Found device in DFU mode.')\"\n            device_mode=\"DFU\"\n            return\n        fi\n        sleep 1\n        sec=$((sec-1))\n    done\n    echo -e \"\\n$(print \"* Release $top button and keep holding $home button.\")\"\n    for i in {8..1}; do\n        echo -n \"$i \"\n        device_find_all $1\n        opt=$?\n        if [[ $opt == 1 ]]; then\n            echo -e \"\\n$(log 'Found device in DFU mode.')\"\n            device_mode=\"DFU\"\n            return\n        fi\n        sleep 1\n    done\n    echo\n    device_find_mode DFU\n}\n\ndevice_enter_mode() {\n    # usage: device_enter_mode {Recovery, DFU, kDFU, pwnDFU}\n    # attempt to enter given mode, and device_find_mode function will then set device_mode variable\n    local opt\n    case $1 in\n        \"WTFreal\" )\n            if [[ $device_mode == \"WTF\" ]]; then\n                return\n            elif [[ $device_mode == \"Normal\" ]]; then\n                device_enter_mode Recovery\n            fi\n            if [[ $device_mode == \"Recovery\" ]]; then\n                device_dfuhelper norec WTFreal\n                return\n            fi\n            log \"Found an S5L8900 device in $device_mode mode. Your device needs to be in WTF mode to continue.\"\n            print \"* Force restart your device and place it in normal or recovery mode, then re-enter WTF mode.\"\n            print \"* You can enter WTF mode by doing the DFU mode procedure.\"\n            device_dfuhelper norec WTFreal\n            device_find_mode WTFreal 100\n        ;;\n\n        \"Recovery\" )\n            if [[ $device_mode == \"Normal\" ]]; then\n                if [[ $mode != \"enterrecovery\" ]]; then\n                    print \"* The device needs to be in Recovery/DFU mode before proceeding.\"\n                    select_yesno \"Send device to recovery mode?\" 1\n                    if [[ $? != 1 ]]; then\n                        log \"User selected N, cannot continue. Exiting.\"\n                        exit\n                    fi\n                fi\n                log \"Entering recovery mode...\"\n                print \"* If the device does not enter recovery mode automatically, press Ctrl+C to cancel and try putting the device in DFU/Recovery mode manually\"\n                \"$dir/ideviceenterrecovery\" \"$device_udid\" >/dev/null\n                device_find_mode Recovery 50\n            fi\n        ;;\n\n        \"DFU\" )\n            if [[ $device_mode == \"Normal\" ]]; then\n                device_enter_mode Recovery\n            elif [[ $device_mode == \"WTF\" ]]; then\n                device_s5l8900xall\n                return\n            elif [[ $device_mode == \"DFU\" ]]; then\n                return\n            fi\n            device_dfuhelper\n        ;;\n\n        \"kDFU\" )\n            local sendfiles=()\n            local ip=\"127.0.0.1\"\n\n            if [[ $device_mode != \"Normal\" ]]; then\n                device_enter_mode pwnDFU\n                return\n            fi\n\n            patch_ibss\n            device_iproxy\n\n            log \"Please read the message below:\"\n            print \"* Follow these instructions to enter kDFU mode.\"\n            print \"1. Install \\\"OpenSSH\\\" in Cydia or Zebra.\"\n            if [[ $device_det == 1 ]]; then\n                print \"  - Jailbreak with socket: https://github.com/staturnzz/socket\"\n                print \"  - Also install \\\"Dropbear\\\" from my repo: https://lukezgd.github.io/repo\"\n            fi\n            print \"  - After installing these requirements, lock your device.\"\n            print \"2. You will be prompted to enter the root password of your iOS device.\"\n            print \"  - The default root password is: alpine\"\n            print \"  - Your password input will not be visible, but it is still being entered.\"\n            print \"3. On entering kDFU mode, the device will disconnect.\"\n            print \"  - Proceed to unplug and replug the device when prompted.\"\n            print \"  - Alternatively, press the TOP or HOME button.\"\n            pause\n\n            echo \"chmod +x /tmp/kloader*\" > kloaders\n            if [[ $device_det == 1 ]]; then\n                echo '[[ $(uname -a | grep -c \"MarijuanARM\") == 1 ]] && /tmp/kloader_hgsp /tmp/pwnediBSS || \\\n                /tmp/kloader /tmp/pwnediBSS' >> kloaders\n                sendfiles+=(\"../resources/kloader/kloader_hgsp\" \"../resources/kloader/kloader\")\n            elif (( device_det <= 5 )); then\n                opt=\"kloader_axi0mX\"\n                case $device_type in\n                    iPad2,4 | iPad3* ) opt=\"kloader5\";; # needed for ipad 3 ios 5, unsure for ipad2,4\n                esac\n                log \"Using $opt for $device_type iOS $device_det\"\n                echo \"/tmp/$opt /tmp/pwnediBSS\" >> kloaders\n                sendfiles+=(\"../resources/kloader/$opt\")\n            else\n                echo \"/tmp/kloader /tmp/pwnediBSS\" >> kloaders\n                sendfiles+=(\"../resources/kloader/kloader\")\n            fi\n            sendfiles+=(\"kloaders\" \"pwnediBSS\")\n\n            device_sshpass\n            log \"Entering kDFU mode...\"\n            print \"* This may take a while, but should not take longer than a minute.\"\n            log \"Sending files to device: ${sendfiles[*]}\"\n            if [[ $device_det == 1 ]]; then\n                for file in \"${sendfiles[@]}\"; do\n                    cat $file | $ssh -p $ssh_port root@127.0.0.1 \"cat > /tmp/$(basename $file)\" &>scp.log &\n                done\n                sleep 3\n                cat scp.log\n                check=\"$(cat scp.log | grep -c \"Connection reset\")\"\n            else\n                $scp -P $ssh_port ${sendfiles[@]} root@127.0.0.1:/tmp\n                check=$?\n            fi\n            if [[ $check == 0 ]]; then\n                log \"Running kloader\"\n                $ssh -p $ssh_port root@127.0.0.1 \"bash /tmp/kloaders\" &\n            else\n                warn \"Failed to connect to device via USB SSH.\"\n                if [[ $device_det == 1 ]]; then\n                    print \"* Try to re-install both OpenSSH and Dropbear, reboot, re-jailbreak, and try again.\"\n                    print \"* Alternatively, place your device in DFU mode (see \\\"Troubleshooting\\\" wiki page for details)\"\n                    print \"* Troubleshooting link: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting#dfu-advanced-menu-for-32-bit-devices\"\n                elif [[ $device_det == 5 ]]; then\n                    print \"* Try to re-install OpenSSH, reboot, and try again.\"\n                else\n                    print \"* Try to re-install OpenSSH, reboot, re-jailbreak, and try again.\"\n                    print \"* Alternatively, you may use kDFUApp from my Cydia repo (see \\\"Troubleshooting\\\" wiki page for details)\"\n                    print \"* Troubleshooting link: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting#dfu-advanced-menu-kdfu-mode\"\n                fi\n                input \"Press Enter/Return to try again with Wi-Fi SSH (or press Ctrl+C to cancel and try again)\"\n                read -s\n                log \"Trying again with Wi-Fi SSH...\"\n                print \"* Make sure that your iOS device and PC/Mac are on the same network.\"\n                print \"* To get your iOS device's IP Address, go to: Settings -> Wi-Fi/WLAN -> tap the 'i' or '>' next to your network name\"\n                ip=\n                until [[ -n $ip ]]; do\n                    read -p \"$(input 'Enter the IP Address of your device: ')\" ip\n                done\n                log \"Sending files to device: ${sendfiles[*]}\"\n                $scp ${sendfiles[@]} root@$ip:/tmp\n                if [[ $? != 0 ]]; then\n                    error \"Failed to connect to device via SSH, cannot continue.\"\n                fi\n                log \"Running kloader\"\n                $ssh root@$ip \"bash /tmp/kloaders\" &\n            fi\n\n            local attempt=1\n            local device_in\n            local port\n            if [[ $ip == \"127.0.0.1\" ]]; then\n                port=\"-p $ssh_port\"\n            fi\n            while (( attempt <= 5 )); do\n                log \"Finding device in kDFU mode... (Attempt $attempt of 5)\"\n                if [[ $($irecovery -q 2>/dev/null | grep -w \"MODE\" | cut -c 7-) == \"DFU\" ]]; then\n                    device_in=1\n                fi\n                if [[ $device_in == 1 ]]; then\n                    log \"Found device in kDFU mode.\"\n                    device_mode=\"DFU\"\n                    break\n                fi\n                if [[ $opt == \"kloader_axi0mX\" ]]; then\n                    print \"* Keep the device plugged in\"\n                    $ssh $port root@$ip \"bash /tmp/kloaders\" &\n                else\n                    print \"* Unplug and replug your device now\"\n                fi\n                ((attempt++))\n            done\n            if (( attempt > 5 )); then\n                error \"Failed to find device in kDFU mode. Please run the script again\"\n            fi\n            kill $iproxy_pid\n        ;;\n\n        \"pwnDFU\" )\n            local irec_pwned\n            local tool_pwned\n\n            if [[ $device_skip_ibss == 1 ]]; then\n                warn \"Skip iBSS flag detected, skipping pwned DFU check. Proceed with caution\"\n                return\n            elif [[ $device_pwnrec == 1 ]]; then\n                warn \"Pwned recovery flag detected, skipping pwned DFU check. Proceed with caution\"\n                return\n            elif [[ $device_proc == 1 ]]; then\n                device_enter_mode DFU\n                return\n            fi\n            if [[ $device_mode == \"DFU\" ]]; then\n                device_pwnd=\"$($irecovery -q | grep \"PWND\" | cut -c 7-)\"\n            fi\n            if [[ $device_mode == \"DFU\" && $mode != \"pwned-ibss\" &&\n                  $device_boot4 != 1 && $device_proc == 5 ]]; then\n                print \"* Select Y if your device is in pwned iBSS/kDFU mode.\"\n                print \"* Select N if this is not the case. (pwned using checkm8-a5)\"\n                print \"* Failing to answer correctly will cause \\\"Sending iBEC\\\" to fail.\"\n                select_yesno \"Is your device already in pwned iBSS/kDFU mode?\" 0\n                if [[ $? != 0 ]]; then\n                    log \"Pwned iBSS/kDFU mode specified by user.\"\n                    return\n                fi\n            elif [[ -n $device_pwnd ]]; then\n                log \"Device seems to be already in pwned DFU mode\"\n                print \"* Pwned: $device_pwnd\"\n                case $device_proc in\n                    4 ) return;;\n                    7 )\n                        if [[ $platform != \"macos\" ]]; then\n                            device_ipwndfu rmsigchks\n                        fi\n                        return\n                    ;;\n                    [89] | 10 )\n                        log \"gaster reset\"\n                        $gaster reset\n                        return\n                    ;;\n                esac\n            fi\n\n            if [[ $device_proc == 5 ]]; then\n                local device_todfu\n                if [[ $device_mode != \"DFU\" ]]; then\n                    device_todfu=1\n                    device_enter_mode DFU\n                    log \"Device is now in DFU mode. Now put your device in PWNED DFU mode using checkm8-a5.\"\n                fi\n                echo\n                print \"* DFU mode for A5(X) device - Make sure that your device is in PWNED DFU mode.\"\n                print \"* You need to have an Arduino and USB Host Shield for checkm8-a5.\"\n                print \"* Use my fork of checkm8-a5: https://github.com/LukeZGD/checkm8-a5\"\n                print \"* You may also use checkm8-a5 for the Pi Pico: https://www.reddit.com/r/LegacyJailbreak/comments/1djuprf/working_checkm8a5_on_the_raspberry_pi_pico/\"\n                print \"* Also make sure that you have NOT sent a pwned iBSS yet.\"\n                print \"* If you do not know what you are doing, restart your device in normal mode.\"\n                print \"* For more details, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/checkm8-a5\"\n                echo\n                if [[ $device_todfu == 1 ]]; then\n                    log \"* After putting your device in PWNED DFU, plug it back in your PC/Mac before pressing Enter/Return.\"\n                    pause\n                fi\n                echo\n                log \"Checking for device\"\n                device_pwnd=\"$($irecovery -q | grep \"PWND\" | cut -c 7-)\"\n                if [[ -n $device_pwnd ]]; then\n                    log \"Found device in pwned DFU mode.\"\n                    print \"* Pwned: $device_pwnd\"\n                else\n                    local error_msg=$'\\n* If you have just used checkm8-a5, it may have just failed. Just re-enter DFU, and retry.'\n                    if [[ $mode != \"device_justboot\" && $device_target_tethered != 1 ]]; then\n                        echo\n                        error_msg+=$'\\n* As much as possible, use the jailbroken method instead: restart the device in normal mode and jailbreak it.'\n                        error_msg+=$'\\n* You just need to have OpenSSH installed from Cydia.'\n                        error_msg+=$'\\n    - https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Restore-32-bit-Device'\n                        echo\n                    fi\n                    error_msg+=$'\\n* Exit DFU mode first by holding the TOP and HOME buttons for about 10 seconds.'\n                    error_msg+=$'\\n* For more info about kDFU/pwnDFU, read the \"Troubleshooting\" wiki page in GitHub'\n                    error_msg+=$'\\n* Troubleshooting link: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting#dfu-advanced-menu-a5x-pwndfu-mode-with-arduino-and-usb-host-shield'\n                    error \"32-bit A5 device is NOT in PWNED DFU mode. Already pwned iBSS mode?\" \"$error_msg\"\n                fi\n                device_ipwndfu send_ibss\n                return\n            fi\n\n            device_enter_mode DFU\n\n            if (( device_proc > 7 )); then\n                # A8/A9/A10 uses gaster\n                log \"Placing device to pwnDFU mode using gaster\"\n                print \"* If pwning fails and gets stuck, you can press Ctrl+C to cancel.\"\n                $gaster pwn\n                tool_pwned=$?\n                log \"gaster reset\"\n                $gaster reset\n            elif [[ $device_type == \"iPod2,1\" || $mode == \"device_alloc8\" ]]; then\n                # touch 2 uses ipwndfu\n                # also installing alloc8 requires pwning with ipwndfu\n                device_ipwndfu pwn\n                tool_pwned=$?\n            elif [[ $device_proc == 4 ]] || [[ $device_proc == 6 && $platform == \"macos\" && $platform_arch == \"x86_64\" ]]; then\n                # A6 intel mac/A4/3gs/touch 3 uses ipwndfu/ipwnder\n                local selection=(\"ipwnder\" \"ipwndfu\")\n                if [[ $platform == \"linux\" ]]; then\n                    selection=(\"ipwndfu\" \"ipwnder (limera1n)\")\n                    if [[ $device_type != \"iPhone2,1\" && $device_type != \"iPod3,1\" ]]; then\n                        selection+=(\"ipwnder (SHAtter)\")\n                    fi\n                fi\n                input \"PwnDFU Tool Option\"\n                print \"* Select tool to be used for entering pwned DFU mode.\"\n                print \"* This option is set to ${selection[0]} by default (1). Select this option if unsure.\"\n                print \"* If the first option does not work, try the other option and do multiple attempts.\"\n                print \"* Note: Some Intel Macs may have better success rates with ipwndfu than ipwnder.\"\n                input \"Select your option:\"\n                select_option \"${selection[@]}\"\n                opt2=\"${selection[$?]}\"\n                log \"Placing device to pwnDFU mode using $opt2\"\n                case $opt2 in\n                    \"ipwndfu\" ) device_ipwndfu pwn; tool_pwned=$?;;\n                    \"ipwnder (SHAtter)\"  ) $ipwnder -s; tool_pwned=$?;;\n                    \"ipwnder (limera1n)\" ) $ipwnder -p; tool_pwned=$?;;\n                    \"ipwnder\" )\n                        mkdir image3 ../saved/image3 2>/dev/null\n                        cp ../saved/image3/* image3/ 2>/dev/null\n                        $ipwnder -d\n                        tool_pwned=$?\n                        cp image3/* ../saved/image3/\n                    ;;\n                esac\n            elif [[ $platform == \"linux\" ]]; then\n                # A6/A7 linux uses ipwndfu\n                device_ipwndfu pwn\n                tool_pwned=$?\n            elif [[ $device_proc == 6 ]]; then\n                # A6 asi mac uses ipwnder_lite\n                log \"Placing device to pwnDFU mode using ipwnder_lite\"\n                mkdir image3 ../saved/image3 2>/dev/null\n                cp ../saved/image3/* image3/ 2>/dev/null\n                $ipwnder -d\n                tool_pwned=$?\n                cp image3/* ../saved/image3/\n            elif [[ $platform_arch == \"arm64\" ]]; then\n                # A7 asi mac uses ipwnder_lite\n                log \"Placing device to pwnDFU mode using ipwnder_lite\"\n                ${ipwnder}2 -p\n                tool_pwned=$?\n            else\n                # A7 intel mac uses ipwnder32/ipwnder_lite\n                local selection=(\"ipwnder32\" \"ipwnder_lite\" \"ipwndfu\")\n                input \"PwnDFU Tool Option\"\n                print \"* Select tool to be used for entering pwned DFU mode.\"\n                print \"* This option is set to ${selection[0]} by default (1). Select this option if unsure.\"\n                print \"* If the first option does not work, try many times and/or try the other option(s).\"\n                print \"* Note: Some Intel Macs have very low success rates for A7 checkm8.\"\n                input \"Select your option:\"\n                select_option \"${selection[@]}\"\n                opt2=\"${selection[$?]}\"\n                log \"Placing device to pwnDFU mode using $opt\"\n                case $opt2 in\n                    \"ipwnder32\" ) $ipwnder32 -p; tool_pwned=$?;;\n                    \"ipwndfu\"   ) device_ipwndfu pwn; tool_pwned=$?;;\n                    \"ipwnder\"*  ) ${ipwnder}2 -p; tool_pwned=$?;;\n                esac\n            fi\n            if [[ $tool_pwned == 2 ]]; then\n                return\n            fi\n            log \"Checking for device\"\n            irec_pwned=$($irecovery -q | grep -c \"PWND\")\n            # irec_pwned is instances of \"PWND\" in serial, must be 1\n            # tool_pwned is error code of pwning tool, must be 0\n            if [[ $irec_pwned != 1 && $tool_pwned != 0 ]]; then\n                device_pwnerror\n            fi\n            if [[ $device_proc == 6 && $tool_pwndfu == \"ipwndfu\" ]]; then\n                device_ipwndfu send_ibss\n                return\n            fi\n            if [[ $platform == \"macos\" ]]; then\n                return\n            elif [[ $device_proc == 7 ]]; then\n                device_ipwndfu rmsigchks\n            fi\n        ;;\n    esac\n}\n\ndevice_pwnerror() {\n    local error_msg=$'\\n* Exit DFU mode first by holding the TOP and HOME buttons for about 10 seconds.'\n    if [[ $platform == \"linux\" ]]; then\n        error_msg+=$'\\n* Unfortunately, pwning may have low success rates for PCs with an AMD desktop CPU if you have one.'\n        error_msg+=$'\\n* Also, success rates for A6 and A7 checkm8 are lower on Linux.'\n        error_msg+=$'\\n* Pwning using an Intel PC or another Mac or iOS device may be better options.'\n        if [[ $device_proc == 6 && $mode != \"device_justboot\" && $device_target_tethered != 1 ]]; then\n            echo\n            error_msg+=$'\\n* As much as possible, use the jailbroken method instead: restart the device in normal mode and jailbreak it.'\n            error_msg+=$'\\n* You just need to have OpenSSH (and Dropbear if on iOS 10) installed from Cydia/Zebra.'\n            error_msg+=$'\\n    - https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Restore-32-bit-Device'\n            echo\n        fi\n    elif [[ $platform == \"macos\" && $tool_pwndfu == \"ipwndfu\" ]]; then\n        error_msg+=$'\\n* If you get the error \"No backend available\" in ipwndfu, install libusb in Homebrew/MacPorts'\n    elif [[ $platform == \"macos\" && $platform_arch == \"x86_64\" ]]; then\n        if [[ $device_proc == 4 || $device_proc == 6 ]]; then\n            error_msg+=$'\\n* Try to do attempts with ipwndfu selected if ipwnder does not work.'\n        elif [[ $device_proc == 7 ]]; then\n            error_msg+=$'\\n* Some Intel Macs have very low success rates for A7 checkm8.'\n            error_msg+=$'\\n* Particularly Core 2 Duo Macs, but may include some newer Intel Macs as well.'\n            error_msg+=$'\\n* Pwning using another Mac or iOS device using iPwnder Lite are better options if needed.'\n        fi\n    fi\n    error_msg+=$'\\n* For more details, read the \"Troubleshooting\" wiki page in GitHub'\n    error_msg+=$'\\n* Troubleshooting links:\n    - https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting\n    - https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Pwning-Using-Another-iOS-Device'\n    error \"Failed to enter pwnDFU mode. Please run the script again.\" \"$error_msg\"\n}\n\ndevice_ipwndfu() {\n    local tool_pwned=0\n    local python2=\"$(command -v python2)\"\n    local pyenv=\"$(command -v pyenv)\"\n    local pyenv2=\"$HOME/.pyenv/versions/2.7.18/bin/python2\"\n\n    if [[ -z \"$pyenv\" && -e \"$HOME/.pyenv/bin/pyenv\" ]]; then\n        pyenv=\"$HOME/.pyenv/bin/pyenv\"\n    fi\n    if [[ $platform == \"macos\" ]] && (( mac_majver < 12 )); then\n        python2=\"/usr/bin/python\"\n        log \"Using macOS system python2\"\n        print \"* You may also install python2 from pyenv if something is wrong with system python2\"\n        print \"* Install pyenv by running: curl https://pyenv.run | bash\"\n        print \"* Install python2 from pyenv by running: pyenv install 2.7.18\"\n    elif [[ -n \"$python2\" && $device_sudoloop == 1 ]]; then\n        p2_sudo=\"sudo\"\n    elif [[ -z \"$python2\" && ! -e \"$pyenv2\" ]]; then\n        warn \"python2 is not installed. Attempting to install python2 before continuing\"\n        print \"* Install python2 from pyenv by running: pyenv install 2.7.18\"\n        if [[ -z \"$pyenv\" ]]; then\n            warn \"pyenv is not installed. Attempting to install pyenv before continuing\"\n            print \"* Install pyenv by running: curl https://pyenv.run | bash\"\n            log \"Installing pyenv\"\n            curl https://pyenv.run | bash\n            pyenv=\"$HOME/.pyenv/bin/pyenv\"\n            if [[ ! -e \"$pyenv\" ]]; then\n                error \"Cannot detect pyenv, its installation may have failed.\" \\\n                \"* Try installing pyenv manually before retrying.\"\n            fi\n        fi\n        log \"Installing python2 using pyenv\"\n        print \"* This may take a while, but should not take longer than a few minutes.\"\n        \"$pyenv\" install 2.7.18\n        if [[ ! -e \"$pyenv2\" ]]; then\n            warn \"Cannot detect python2 from pyenv, its installation may have failed.\"\n            print \"* Try installing pyenv and/or python2 manually:\"\n            print \"    pyenv:   > curl https://pyenv.run | bash\"\n            print \"    python2: > \\\"$pyenv\\\" install 2.7.18\"\n            if [[ $distro == \"fedora-atomic\" ]]; then\n                print \"* For Fedora Atomic, you will also need to set up toolbox and build environment.\"\n                print \"* Follow the commands here under Fedora Silverblue: https://github.com/pyenv/pyenv/wiki#suggested-build-environment\"\n                print \"* Run the pyenv install commands while in the toolbox container.\"\n            fi\n            error \"Cannot detect python2 for ipwndfu, cannot continue.\"\n        fi\n    fi\n    if [[ -e \"$pyenv2\" ]]; then\n        log \"python2 from pyenv detected, this will be used\"\n        if [[ $device_sudoloop == 1 ]]; then\n            p2_sudo=\"sudo\"\n        fi\n        python2=\"$pyenv2\"\n    fi\n\n    mkdir ../saved/ipwndfu 2>/dev/null\n    rm -f ../saved/ipwndfu/pwnediBSS\n    if [[ $1 == \"send_ibss\" && $device_boot4 == 1 ]]; then\n        cp iBSS.patched ../saved/ipwndfu/pwnediBSS\n    elif [[ $1 == \"send_ibss\" ]]; then\n        device_rd_build=\n        patch_ibss\n        cp pwnediBSS ../saved/ipwndfu/\n    fi\n\n    device_enter_mode DFU\n    local ipwndfu_comm=\"1d22fd01b0daf52bbcf1ce730022d4212d87f967\"\n    local ipwndfu_sha1=\"30f0802078ab6ff83d6b918e13f09a652a96d6dc\"\n    if [[ ! -s ../saved/ipwndfu/ipwndfu || $(cat ../saved/ipwndfu/sha1check) != \"$ipwndfu_sha1\" ]]; then\n        rm -rf ../saved/ipwndfu-*\n        download_file https://github.com/LukeZGD/ipwndfu/archive/$ipwndfu_comm.zip ipwndfu.zip $ipwndfu_sha1\n        unzip -q ipwndfu.zip -d ../saved\n        rm -rf ../saved/ipwndfu\n        mv ../saved/ipwndfu-* ../saved/ipwndfu\n        echo \"$ipwndfu_sha1\" > ../saved/ipwndfu/sha1check\n        rm -rf ../saved/ipwndfu-*\n    fi\n    # create a lib symlink in the home directory for macos, needed by ipwndfu/pyusb\n    # no need to do this for homebrew x86_64 since /usr/local/lib is being checked along with ~/lib, but lets do the symlink anyway\n    if [[ $platform == \"macos\" ]]; then\n        if [[ -e \"$HOME/lib\" && -e \"$HOME/lib.bak\" ]]; then\n            rm -rf \"$HOME/lib\"\n        elif [[ -e \"$HOME/lib\" ]]; then\n            mv \"$HOME/lib\" \"$HOME/lib.bak\"\n        fi\n        # prioritize macports here since it has longer support\n        if [[ -e /opt/local/lib/libusb-1.0.dylib ]]; then\n            log \"Detected libusb installed via MacPorts\"\n            ln -sf /opt/local/lib \"$HOME/lib\"\n        elif [[ -e /opt/homebrew/lib/libusb-1.0.dylib ]]; then\n            log \"Detected libusb installed via Homebrew (arm64)\"\n            ln -sf /opt/homebrew/lib \"$HOME/lib\"\n        elif [[ -e /usr/local/lib/libusb-1.0.dylib ]]; then\n            log \"Detected libusb installed via Homebrew (x86_64)\"\n            ln -sf /usr/local/lib \"$HOME/lib\"\n        else\n            warn \"No libusb detected. ipwndfu might fail especially on arm64 (Apple Silicon) devices.\"\n        fi\n    fi\n\n    pushd ../saved/ipwndfu/ >/dev/null\n    case $1 in\n        \"send_ibss\" )\n            log \"Sending iBSS using ipwndfu...\"\n            $p2_sudo \"$python2\" ipwndfu -l pwnediBSS\n            tool_pwned=$?\n            rm pwnediBSS\n            if [[ $tool_pwned != 0 ]]; then\n                popd >/dev/null\n                local error_msg\n                if [[ $platform == \"macos\" ]]; then\n                    error_msg+=$'\\n* If you get the error \"No backend available,\" install libusb in Homebrew/MacPorts\\n'\n                fi\n                error_msg+=\"* You might need to exit DFU and (re-)enter PWNED DFU mode before retrying.\"\n                error \"Failed to send iBSS. Your device has likely failed to enter PWNED DFU mode.\" \"$error_msg\"\n            fi\n            print \"* ipwndfu should have \\\"done!\\\" as output. If not, sending iBEC will fail.\"\n        ;;\n\n        \"pwn\" )\n            tool_pwndfu=\"ipwndfu\"\n            log \"Placing device to pwnDFU Mode using ipwndfu\"\n            $p2_sudo \"$python2\" ipwndfu -p\n            tool_pwned=$?\n            if [[ $tool_pwned != 0 && $tool_pwned != 2 ]]; then\n                if (( device_proc >= 6 )) && [[ $tool_pwned != 2 && $platform == \"linux\" ]]; then\n                    log \"You may see the langid error above. This is normal, let's try to make it work\"\n                    print \"* If it is any other error, it may have failed. Just continue, re-enter DFU, and retry\"\n                    log \"Please read the message below:\"\n                    print \"* Unplug and replug the device 2 times\"\n                    print \"* After doing this, continue by pressing Enter/Return\"\n                    pause\n                    log \"Checking for device\"\n                    device_pwnd=\"$($irecovery3 -q | grep \"PWND\" | cut -c 7-)\"\n                    if [[ -n $device_pwnd ]]; then\n                        log \"Success!\"\n                        print \"* Pwned: $device_pwnd\"\n                    else\n                        popd >/dev/null\n                        device_pwnerror\n                    fi\n                else\n                    popd >/dev/null\n                    device_pwnerror\n                fi\n            fi\n        ;;\n\n        \"rmsigchks\" )\n            log \"Running rmsigchks...\"\n            $p2_sudo \"$python2\" rmsigchks.py\n        ;;\n\n        \"alloc8\" )\n            if [[ ! -s n88ap-iBSS-4.3.5.img3 ]]; then\n                log \"Downloading iOS 4.3.5 iBSS\"\n                \"../$dir/pzb\" -g \"Firmware/dfu/iBSS.n88ap.RELEASE.dfu\" -o n88ap-iBSS-4.3.5.img3 http://appldnld.apple.com/iPhone4/041-1965.20110721.gxUB5/iPhone2,1_4.3.5_8L1_Restore.ipsw\n            fi\n            log \"Installing alloc8 to device\"\n            $p2_sudo \"$python2\" ipwndfu -x\n            if [[ $platform == \"macos\" ]]; then\n                print \"* If you get the error \\\"No backend available,\\\" install libusb in Homebrew/MacPorts\"\n            fi\n        ;;\n    esac\n    if [[ $device_sudoloop == 1 ]]; then\n        sudo rm *.pyc libusbfinder/*.pyc usb/*.pyc usb/backend/*.pyc\n    fi\n    popd >/dev/null\n    return $tool_pwned\n}\n\ndownload_file() {\n    # usage: download_file {link} {target location} {sha1}\n    local filename=\"$(basename $2)\"\n    log \"Downloading $filename...\"\n    curl -L $1 -o $2\n    if [[ ! -s $2 ]]; then\n        error \"Downloading $2 failed. Please run the script again\"\n    fi\n    if [[ -z $3 ]]; then\n        return\n    fi\n    local sha1=$($sha1sum $2 | awk '{print $1}')\n    if [[ $sha1 != \"$3\" ]]; then\n        error \"Verifying $filename failed. The downloaded file may be corrupted or incomplete. Please run the script again\" \\\n        \"* SHA1sum mismatch. Expected $3, got $sha1\"\n    fi\n}\n\ndevice_fw_key_check() {\n    # check and download keys for device_target_build, then set the variable device_fw_key (or device_fw_key_base)\n    local key\n    local build=\"$device_target_build\"\n    if [[ $1 == \"base\" ]]; then\n        build=\"$device_base_build\"\n    elif [[ $1 == \"temp\" ]]; then\n        build=\"$2\"\n    fi\n    local keys_path=\"$device_fw_dir/$build\"\n\n    log \"Checking firmware keys in $keys_path\"\n    if [[ -e \"$keys_path/index.html\" ]]; then\n        if [[ $(cat \"$keys_path/index.html\" | grep -c \"$build\") != 1 ]]; then\n            log \"Existing firmware keys are not valid. Deleting\"\n            rm \"$keys_path/index.html\"\n        fi\n        case $build in\n            1[23]* )\n                if [[ $(cat \"$keys_path/index.html\" | sed \"s|DeviceTree.${device_model}ap||g\" | grep -c \"${device_model}ap\") != 0 ]]; then\n                    log \"Existing firmware keys seem to have incorrect filenames. Deleting\"\n                    rm \"$keys_path/index.html\"\n                fi\n            ;;\n        esac\n    fi\n\n    if [[ ! -e \"$keys_path/index.html\" ]]; then\n        log \"Getting firmware keys for $device_type-$build\"\n        mkdir -p \"$keys_path\" 2>/dev/null\n        local try=(\"https://github.com/LukeZGD/Legacy-iOS-Kit-Keys/raw/master/$device_type/$build/index.html\"\n                   \"http://127.0.0.1:8888/firmware/$device_type/$build\"\n                   \"https://api.m1sta.xyz/wikiproxy/$device_type/$build\")\n        for i in \"${try[@]}\"; do\n            curl -L $i -o index.html\n            if [[ $(cat index.html | grep -c \"$build\") == 1 ]]; then\n                break\n            fi\n        done\n        if [[ $(cat index.html | grep -c \"$build\") != 1 ]]; then\n            local error_msg=\"* You may need to run wikiproxy to get firmware keys.\"\n            error_msg+=$'\\n* For more details, go to the \"Troubleshooting\" wiki page in GitHub.'\n            error_msg+=$'\\n* Troubleshooting link: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting#running-wikiproxy'\n            error \"Failed to download firmware keys.\" \"$error_msg\"\n        fi\n        mv index.html \"$keys_path/\"\n    fi\n    if [[ $1 == \"base\" ]]; then\n        device_fw_key_base=\"$(cat $keys_path/index.html)\"\n    elif [[ $1 == \"temp\" ]]; then\n        device_fw_key_temp=\"$(cat $keys_path/index.html)\"\n    else\n        device_fw_key=\"$(cat $keys_path/index.html)\"\n    fi\n}\n\nipsw_get_url() {\n    local build_id=\"$1\"\n    local url=\"$(cat \"$device_fw_dir/$build_id/url\" 2>/dev/null)\"\n    local url_local=\"$url\"\n    ipsw_url=\n    log \"Checking URL in $device_fw_dir/$build_id/url\"\n    if [[ $(echo \"$url\" | grep -c '<') != 0 || $url != *\"$build_id\"* ]]; then\n        rm -f \"$device_fw_dir/$build_id/url\"\n        url=\n    fi\n    if [[ -z $url ]]; then\n        log \"Getting URL for $device_type-$build_id\"\n        url=\"$(curl \"https://api.ipsw.me/v4/ipsw/$device_type/$build_id\" | $jq -j \".url\")\"\n        if [[ $(echo \"$url\" | grep -c '<') != 0 || $url != *\"$build_id\"* ]]; then\n            url=\"$(curl \"https://api.ipsw.me/v4/device/$device_type?type=ipsw\" | $jq -j \".firmwares[] | select(.buildid == \\\"$build_id\\\") | .url\")\"\n        fi\n        if [[ $(echo \"$url\" | grep -c '<') != 0 || $url != *\"$build_id\"* ]]; then\n            if [[ -n $url_local ]]; then\n                url=\"$url_local\"\n                log \"Using saved URL for this IPSW: $url\"\n                echo \"$url\" > $device_fw_dir/$build_id/url\n                ipsw_url=\"$url\"\n                return\n            fi\n            error \"Unable to get URL for $device_type-$build_id\"\n        fi\n        mkdir -p $device_fw_dir/$build_id 2>/dev/null\n        echo \"$url\" > $device_fw_dir/$build_id/url\n    fi\n    ipsw_url=\"$url\"\n}\n\ndownload_comp() {\n    # usage: download_comp [build_id] [comp]\n    local build_id=\"$1\"\n    local comp=\"$2\"\n    ipsw_get_url $build_id\n    download_targetfile=\"$comp.$device_model\"\n    if [[ $build_id != \"12\"* ]]; then\n        download_targetfile+=\"ap\"\n    fi\n    download_targetfile+=\".RELEASE\"\n\n    if [[ -e \"../saved/$device_type/${comp}_$build_id.dfu\" ]]; then\n        cp \"../saved/$device_type/${comp}_$build_id.dfu\" ${comp}\n    else\n        log \"Downloading ${comp}...\"\n        \"$dir/pzb\" -g \"Firmware/dfu/$download_targetfile.dfu\" -o ${comp} \"$ipsw_url\"\n        cp ${comp} \"../saved/$device_type/${comp}_$build_id.dfu\"\n    fi\n}\n\npatch_ibss() {\n    # creates file pwnediBSS to be sent to device\n    local build_id\n    case $device_type in\n        iPad1,1 | iPod3,1 ) build_id=\"9B206\";;\n        iPhone2,1 | iPod4,1 ) build_id=\"10B500\";;\n        iPhone3,[123] ) build_id=\"11D257\";;\n        * ) build_id=\"12H321\";;\n    esac\n    if [[ -n $device_rd_build ]]; then\n        build_id=\"$device_rd_build\"\n    fi\n    download_comp $build_id iBSS\n    device_fw_key_check temp $build_id\n    local iv=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"iBSS\") | .iv')\n    local key=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"iBSS\") | .key')\n    log \"Decrypting iBSS...\"\n    \"$dir/xpwntool\" iBSS iBSS.dec -iv $iv -k $key\n    log \"Patching iBSS...\"\n    \"$dir/iBoot32Patcher\" iBSS.dec pwnediBSS --rsa\n    \"$dir/xpwntool\" pwnediBSS pwnediBSS.dfu -t iBSS\n    cp pwnediBSS pwnediBSS.dfu ../saved/$device_type/\n    log \"Pwned iBSS saved at: saved/$device_type/pwnediBSS\"\n    log \"Pwned iBSS img3 saved at: saved/$device_type/pwnediBSS.dfu\"\n}\n\npatch_ibec() {\n    # creates file pwnediBEC to be sent to device for blob dumping\n    local build_id\n    case $device_type in\n        iPad1,1 | iPod3,1 )\n            build_id=\"9B206\";;\n        iPhone2,1 | iPhone3,[123] | iPod4,1 )\n            build_id=\"10A403\";;\n        iPad2,[367] | iPad3,[25] )\n            build_id=\"12H321\";;\n        iPad3,1 )\n            build_id=\"10B146\";;\n        iPhone5,3 )\n            build_id=\"11B511\";;\n        iPhone5,4 )\n            build_id=\"11B651\";;\n        * )\n            build_id=\"10B329\";;\n    esac\n    if [[ -n $device_rd_build ]]; then\n        build_id=\"$device_rd_build\"\n    fi\n    download_comp $build_id iBEC\n    device_fw_key_check temp $build_id\n    local name=\"iBEC\"\n    local iv=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"iBEC\") | .iv')\n    local key=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"iBEC\") | .key')\n    local address=\"0x80000000\"\n    if [[ $device_proc == 4 ]]; then\n        address=\"0x40000000\"\n    fi\n    mv iBEC $name.orig\n    log \"Decrypting iBEC...\"\n    \"$dir/xpwntool\" $name.orig $name.dec -iv $iv -k $key\n    log \"Patching iBEC...\"\n    if [[ $device_proc == 4 || -n $device_rd_build ]]; then\n        \"$dir/iBoot32Patcher\" $name.dec $name.patched --rsa --ticket -b \"rd=md0 -v amfi=0xff cs_enforcement_disable=1\" -c \"go\" $address\n    else\n        $bspatch $name.dec $name.patched \"../resources/patch/$download_targetfile.patch\"\n    fi\n    \"$dir/xpwntool\" $name.patched pwnediBEC.dfu -t $name.orig\n    rm $name.dec $name.orig $name.patched\n    cp pwnediBEC.dfu ../saved/$device_type/\n    log \"Pwned iBEC img3 saved at: saved/$device_type/pwnediBEC.dfu\"\n}\n\nipsw_nojailbreak_message() {\n    local hac\n    local tohac\n    case $device_type in\n        iPhone[23],1 ) hac=\" (and hacktivate)\"; tohac=1;;\n    esac\n    log \"Jailbreak option is not available for this version. You may jailbreak$hac later after the restore\"\n    print \"* To jailbreak, select \\\"Jailbreak Device\\\" in the main menu\"\n    if [[ $tohac == 1 ]]; then\n        print \"* To hacktivate, go to \\\"Useful Utilities -> Hacktivate Device\\\" after jailbreaking\"\n    fi\n}\n\nipsw_preference_set() {\n    # sets ipsw variables: ipsw_jailbreak, ipsw_memory, ipsw_verbose\n\n    if (( device_proc >= 7 )); then\n        return\n    fi\n\n    case $device_latest_vers in\n        [76543]* ) ipsw_canjailbreak=1;;\n    esac\n    if [[ $device_target_vers == \"$device_latest_vers\" && $ipsw_canjailbreak != 1 && $ipsw_gasgauge_patch != 1 ]]; then\n        return\n    elif [[ $device_target_vers != \"$device_latest_vers\" ]]; then\n        ipsw_canjailbreak=\n    fi\n\n    # jailbreak option: available for versions 3.1.3 to 9.3.4, with some exceptions:\n    # 3.1-4.1: option is disabled due to an issue with putting .launchd_use_gmalloc in the correct partition.\n    # it should be in system, but restore puts it in data instead due to it being in var.\n    # for some reason though, it does it correctly on 4.x for 3gs and touch 2, so its enabled for those.\n    # it also does it correctly on 3.1.3-4.x for s5l8900 devices, so its also enabled there.\n    # for 3.x 3gs, and old br 3.1.3 touch 2, kernel is patched so its also enabled for those.\n    case $device_target_vers in\n        9.3.[4321] | 9.3 | 9.[210]* | [8765]* | 4.[32]* ) ipsw_canjailbreak=1;;\n        3.1.3 )\n            case $device_type in\n                iPhone1* | iPod[12],1 | iPhone2,1 ) ipsw_canjailbreak=1;;\n                * ) ipsw_nojailbreak_message;;\n            esac\n        ;;\n    esac\n\n    if [[ $device_type == \"iPhone1,2\" || $device_type == \"iPhone2,1\" || $device_type == \"iPod2,1\" ]]; then\n        case $device_target_vers in\n            4* ) ipsw_canjailbreak=1;;\n        esac\n        if [[ $device_type == \"iPod2,1\" && $device_newbr != 0 && $device_target_vers == \"3.1.3\" ]]; then\n            warn \"New bootrom detected. Disabling jailbreak option\"\n            ipsw_canjailbreak=\n            ipsw_nojailbreak_message\n        fi\n    else\n        case $device_target_vers in\n            4.[10]* ) ipsw_nojailbreak_message;;\n        esac\n    fi\n\n    # ipsw_nskip being 1 means that it will always create/use a custom ipsw.\n    # useful for disabling baseband update, or in the case of macos arm64, not having to use futurerestore.\n    case $device_type in\n        iPad[23],[23] | \"$device_disable_bbupdate\" ) ipsw_nskip=1;;\n    esac\n    if [[ $device_target_vers == \"4.2\"* || $device_target_vers == \"4.3\"* || $ipsw_gasgauge_patch == 1 ]] ||\n       [[ $platform == \"macos\" && $platform_arch == \"arm64\" ]]; then\n        ipsw_nskip=1\n    fi\n\n    # make jailbreak version available for all of 8.x-9.x if the restore is a powdersn0w one.\n    # meanwhile, exit this function if ipsw_canjailbreak is not set to 1 and/or other options will not be used.\n    if [[ $device_target_powder == 1 ]]; then\n        case $device_target_vers in\n            [98]* ) ipsw_canjailbreak=1;;\n        esac\n    elif [[ $device_target_other == 1 && $ipsw_canjailbreak != 1 && $ipsw_nskip != 1 ]]; then\n        return\n    fi\n\n    # detect certain ios betas now. for ios 8, disable betas 1 and 2 since powdersn0w cant patch the kernels for those.\n    # for betas below ios 6, disable the jailbreak option, its not supported since (currently) no patchfinders used there and stuff.\n    if [[ $ipsw_isbeta == 1 ]]; then\n        case $device_target_vers in\n            8* )\n                if [[ $device_target_build == \"12A4265u\" || $device_target_build == \"12A4297e\" ]]; then\n                    warn \"iOS beta detected. Disabling jailbreak option\"\n                    ipsw_canjailbreak=\n                fi\n            ;;\n            [76]* ) :;;\n            * )\n                warn \"iOS beta detected. Disabling jailbreak option\"\n                ipsw_canjailbreak=\n            ;;\n        esac\n        if [[ $ipsw_canjailbreak == 1 ]]; then\n            warn \"iOS beta detected. Jailbreak option might not work properly\"\n        fi\n    fi\n\n    if [[ $ipsw_fourthree == 1 ]]; then\n        ipsw_jailbreak=1\n    elif [[ $ipsw_jailbreak == 1 ]]; then\n        warn \"Jailbreak flag detected, jailbreak option enabled by user.\"\n    elif [[ $ipsw_canjailbreak == 1 && -z $ipsw_jailbreak ]]; then\n        input \"Jailbreak Option\"\n        print \"* When this option is enabled, your device will be jailbroken on restore.\"\n        print \"* I recommend to enable this option to have the jailbreak and Cydia pre-installed.\"\n        print \"* This option is enabled by default (Y). Select this option if unsure.\"\n        if [[ $device_type == \"iPad2\"* && $device_target_vers == \"4.3\"* && $device_target_tethered != 1 ]]; then\n            warn \"This will be a semi-tethered jailbreak. checkm8-a5 is required to boot to a jailbroken state.\"\n            print \"* To boot jailbroken later, go to: Main Menu -> Just Boot\"\n        elif [[ $device_type == \"iPhone3,3\" ]]; then\n            case $device_target_vers in\n                4.2.9 | 4.2.10 )\n                    warn \"This will be a semi-tethered jailbreak.\"\n                    print \"* To boot jailbroken later, go to: Main Menu -> Just Boot\"\n                ;;\n            esac\n        fi\n        select_yesno \"Enable this option?\" 1\n        if [[ $? != 1 ]]; then\n            ipsw_jailbreak=\n            log \"Jailbreak option disabled by user.\"\n        else\n            ipsw_jailbreak=1\n            log \"Jailbreak option enabled.\"\n        fi\n        echo\n    fi\n\n    if [[ $ipsw_jailbreak == 1 && -z $ipsw_hacktivate && $ipsw_canhacktivate == 1 ]]; then\n        input \"Hacktivate Option\"\n        print \"* When this option is enabled, your device will be activated on restore.\"\n        print \"* Enable this option if you have no valid SIM card to activate the phone.\"\n        print \"* Disable this option if you have a working SIM card and want cellular data.\"\n        print \"* This option is disabled by default (N). Select this option if unsure.\"\n        select_yesno \"Enable this option?\" 0\n        if [[ $? != 0 ]]; then\n            log \"Hacktivate option enabled by user.\"\n            ipsw_hacktivate=1\n        else\n            log \"Hacktivate option disabled.\"\n            ipsw_hacktivate=\n        fi\n        echo\n    fi\n\n    case $device_type in\n        iPhone2,1 | iPod2,1 ) ipsw_canmemory=1;;\n        iPad[23],[23] ) ipsw_canmemory=1;;\n        iPhone3,1 | iPad1,1 | iPad2* | iPod[34],1 )\n            case $device_target_vers in\n                [34]* ) ipsw_canmemory=1;;\n            esac\n        ;;\n    esac\n\n    if [[ $device_proc == 1 && $device_type != \"iPhone1,2\" ]]; then\n        ipsw_canmemory=\n    elif [[ $device_target_powder == 1 || $device_target_tethered == 1 ||\n          $ipsw_jailbreak == 1 || $ipsw_gasgauge_patch == 1 || $ipsw_nskip == 1 ||\n          $device_type == \"$device_disable_bbupdate\" ]]; then\n        ipsw_canmemory=1\n    fi\n\n    if [[ $ipsw_canmemory == 1 && -z $ipsw_memory ]]; then\n        input \"Memory Option for creating custom IPSW\"\n        print \"* When this option is enabled, system RAM will be used for the IPSW creation process.\"\n        print \"* I recommend to enable this option to speed up creating the custom IPSW.\"\n        print \"* However, if your PC/Mac has less than 8 GB of RAM, disable this option.\"\n        print \"* This option is enabled by default (Y). Select this option if unsure.\"\n        select_yesno \"Enable this option?\" 1\n        if [[ $? != 1 ]]; then\n            log \"Memory option disabled by user.\"\n            ipsw_memory=\n        else\n            log \"Memory option enabled.\"\n            ipsw_memory=1\n        fi\n        echo\n    fi\n\n    if [[ $device_target_powder == 1 ]]; then\n        ipsw_canverbose=1\n    elif [[ $device_type == \"iPhone2,1\" && $device_target_other != 1 ]]; then\n        case $device_target_vers in\n            6.1.6 | 4.1 ) log \"3GS verbose boot is not supported on 6.1.6 and 4.1\";;\n            [65]* ) log \"3GS verbose boot is currently supported on iOS 4 and lower only\";;\n            3.0* ) :;;\n            * ) ipsw_canverbose=1;;\n        esac\n    fi\n\n    if [[ $ipsw_canverbose == 1 && -z $ipsw_verbose ]]; then\n        input \"Verbose Boot Option\"\n        print \"* When this option is enabled, the device will have verbose boot on restore.\"\n        print \"* This option is enabled by default (Y). Select this option if unsure.\"\n        select_yesno \"Enable this option?\" 1\n        if [[ $? != 1 ]]; then\n            ipsw_verbose=\n            log \"Verbose boot option disabled by user.\"\n        else\n            ipsw_verbose=1\n            log \"Verbose boot option enabled.\"\n        fi\n        echo\n    fi\n\n    ipsw_custom_set\n}\n\nshsh_save() {\n    # usage: shsh_save {apnonce (optional)}\n    # sets variable shsh_path\n    local version=$device_target_vers\n    local build_id=$device_target_build\n    local apnonce\n    local shsh_check\n    local buildmanifest=\"../resources/manifest/BuildManifest_${device_type}_${version}.plist\"\n    local ExtraArgs=\n\n    if [[ $1 == \"apnonce\" ]]; then\n        apnonce=$2\n    elif [[ $1 == \"version\" ]]; then\n        version=$2\n    fi\n\n    if [[ $version == \"$device_latest_vers\" || $version == \"4.1\" ]]; then\n        if [[ $version != \"4.1\" ]]; then\n            build_id=\"$device_latest_build\"\n        fi\n        buildmanifest=\"../saved/$device_type/$build_id.plist\"\n        if [[ ! -e $buildmanifest ]]; then\n            if [[ -e \"$ipsw_base_path.ipsw\" ]]; then\n                log \"Extracting BuildManifest from $version IPSW...\"\n                unzip -o -j \"$ipsw_base_path.ipsw\" BuildManifest.plist -d .\n            else\n                log \"Downloading BuildManifest for $version...\"\n                \"$dir/pzb\" -g BuildManifest.plist -o BuildManifest.plist \"$(cat \"$device_fw_dir/$build_id/url\")\"\n            fi\n            mv BuildManifest.plist $buildmanifest\n        fi\n    fi\n    shsh_check=${device_ecid}_${device_type}_${device_model}ap_${version}-${build_id}_${apnonce}*.shsh*\n\n    if [[ $(ls ../saved/shsh/$shsh_check 2>/dev/null) && -z $apnonce ]]; then\n        shsh_path=\"$(ls ../saved/shsh/$shsh_check)\"\n        log \"Found existing saved $version blobs: $shsh_path\"\n        return\n    fi\n    rm -f *.shsh*\n\n    ExtraArgs=\"-d $device_type -i $version -e $device_ecid -m $buildmanifest -o -s -B ${device_model}ap -b \"\n    if [[ -n $apnonce ]]; then\n        ExtraArgs+=\"--apnonce $apnonce\"\n    else\n        ExtraArgs+=\"-g 0x1111111111111111\"\n    fi\n    log \"Running tsschecker with command: $tsschecker $ExtraArgs\"\n    $tsschecker $ExtraArgs\n    shsh_path=\"$(ls $shsh_check)\"\n    if [[ -z \"$shsh_path\" ]]; then\n        error \"Saving $version blobs failed. Please run the script again\" \\\n        \"* It is also possible that $version for $device_type is no longer signed\"\n    fi\n    if [[ -z $apnonce ]]; then\n        cp \"$shsh_path\" ../saved/shsh/\n    fi\n    log \"Successfully saved $version blobs: $shsh_path\"\n}\n\nipsw_download() {\n    local version=\"$device_target_vers\"\n    local build_id=\"$device_target_build\"\n    local ipsw_dl=\"$1\"\n    ipsw_get_url $build_id\n    if [[ -z $ipsw_dl ]]; then\n        ipsw_dl=\"../${ipsw_url##*/}\"\n        ipsw_dl=\"${ipsw_dl%?????}\"\n    fi\n    if [[ ! -e \"$ipsw_dl.ipsw\" ]]; then\n        if [[ -n $version ]]; then\n            print \"* The script will now proceed to download iOS $version IPSW.\"\n        fi\n        print \"* If you want to download it yourself, here is the link: $ipsw_url\"\n        log \"Downloading IPSW... (Press Ctrl+C to cancel)\"\n        curl -L \"$ipsw_url\" -o temp.ipsw\n        mv temp.ipsw \"$ipsw_dl.ipsw\"\n    fi\n    ipsw_verify \"$ipsw_dl\" \"$build_id\"\n}\n\nipsw_verify() {\n    local ipsw_dl=\"$1\"\n    local build_id=\"$2\"\n    local cutver\n    local device\n    local type\n    local IPSWSHA1\n    local IPSWSHA1E=$(cat \"$device_fw_dir/$build_id/sha1sum\" 2>/dev/null)\n    log \"Getting SHA1 hash for $ipsw_dl.ipsw...\"\n    local IPSWSHA1L=$($sha1sum \"${ipsw_dl//\\\\//}.ipsw\" | awk '{print $1}')\n    case $build_id in\n        *[bcdefgkmpquv] )\n            log \"Beta IPSW detected, skip verification\"\n            if [[ $build_id == \"$device_base_build\" ]]; then\n                device_base_sha1=\"$IPSWSHA1L\"\n            else\n                ipsw_isbeta=1\n                device_target_sha1=\"$IPSWSHA1L\"\n            fi\n            return\n        ;;\n    esac\n    case $build_id in\n        7*  ) cutver=3;;\n        8*  ) cutver=4;;\n        9*  ) cutver=5;;\n        10* ) cutver=6;;\n        11* ) cutver=7;;\n        12* ) cutver=8;;\n        13* ) cutver=9;;\n    esac\n    if [[ -n $cutver ]]; then\n        type=\"$device_type\"\n    else\n        ipsw_latest_set\n        type=\"$device_type2\"\n    fi\n    case $build_id in\n        14* ) cutver=10;;\n        15* ) cutver=11;;\n        16* ) cutver=12;;\n        17* ) cutver=13;;\n        18* ) cutver=14;;\n        19* ) cutver=15;;\n        20* ) cutver=16;;\n    esac\n    case $device_type in\n        iPad4,[123] | iPad5,[34] ) device=\"iPad_Air\";;\n        iPad2,[567] | iPad[45],* ) device=\"iPad_mini\";;\n        iPad6,[3478] ) device=\"iPad_Pro\";;\n        iPad* ) device=\"iPad\";;\n        iPho* ) device=\"iPhone\";;\n        iPod* ) device=\"iPod_touch\";;\n    esac\n\n    if [[ $(echo \"$IPSWSHA1E\" | grep -c '<') != 0 ]]; then\n        rm \"$device_fw_dir/$build_id/sha1sum\"\n    fi\n\n    log \"Getting SHA1 hash from The Apple Wiki...\"\n    IPSWSHA1=\"$(curl \"https://theapplewiki.com/index.php?title=Firmware/${device}/${cutver}.x\" | grep -A10 \"${type}.*${build_id}\" | sed -ne '/<code>/,/<\\/code>/p' | sed '1!d' | sed -e \"s/<code>//\" | sed \"s/<\\/code>//\" | cut -c 5-)\"\n    mkdir -p $device_fw_dir/$build_id 2>/dev/null\n\n    if [[ -n $IPSWSHA1 && -n $IPSWSHA1E && $IPSWSHA1 == \"$IPSWSHA1E\" ]]; then\n        log \"Using saved SHA1 hash for this IPSW: $IPSWSHA1\"\n    elif [[ -z $IPSWSHA1 && -n $IPSWSHA1E ]]; then\n        warn \"No SHA1 hash from The Apple Wiki, using local hash\"\n        IPSWSHA1=\"$IPSWSHA1E\"\n    elif [[ -z $IPSWSHA1 && -z $IPSWSHA1E ]]; then\n        warn \"No SHA1 hash from either The Apple Wiki or local hash, cannot verify IPSW.\"\n        pause\n        if [[ $build_id == \"$device_base_build\" ]]; then\n            device_base_sha1=\"$IPSWSHA1L\"\n        else\n            device_target_sha1=\"$IPSWSHA1L\"\n        fi\n        return\n    elif [[ -n $IPSWSHA1E ]]; then\n        warn \"Local SHA1 hash mismatch. Overwriting local hash.\"\n        echo \"$IPSWSHA1\" > $device_fw_dir/$build_id/sha1sum\n    elif [[ -z $IPSWSHA1E ]]; then\n        warn \"Local SHA1 hash does not exist. Creating local hash.\"\n        echo \"$IPSWSHA1\" > $device_fw_dir/$build_id/sha1sum\n    fi\n\n    if [[ $IPSWSHA1L != \"$IPSWSHA1\" ]]; then\n        rm \"$device_fw_dir/$build_id/sha1sum\"\n        if [[ $1 != \"nopause\" ]]; then\n            log \"SHA1sum mismatch. Expected $IPSWSHA1, got $IPSWSHA1L\"\n            warn \"Verifying IPSW failed. Your IPSW may be corrupted or incomplete. Make sure to download and select the correct IPSW.\"\n            pause\n        fi\n        if [[ $build_id == \"$device_base_build\" ]]; then\n            ipsw_base_validate=1\n        else\n            ipsw_validate=1\n        fi\n        return 1\n    fi\n    log \"IPSW SHA1sum matches\"\n    if [[ $build_id == \"$device_base_build\" ]]; then\n        device_base_sha1=\"$IPSWSHA1\"\n        ipsw_base_validate=0\n    else\n        ipsw_isbeta=\n        device_target_sha1=\"$IPSWSHA1\"\n        ipsw_validate=0\n    fi\n}\n\nipsw_prepare_1033() {\n    # patch iBSS, iBEC, iBSSb, iBECb and set variables\n    iBSS=\"ipad4\"\n    if [[ $device_type == \"iPhone6\"* ]]; then\n        iBSS=\"iphone6\"\n    fi\n    iBEC=\"iBEC.${iBSS}.RELEASE\"\n    iBSSb=\"iBSS.${iBSS}b.RELEASE\"\n    iBECb=\"iBEC.${iBSS}b.RELEASE\"\n    iBSS=\"iBSS.$iBSS.RELEASE\"\n\n    log \"Patching iBSS and iBEC...\"\n    unzip -o -j \"$ipsw_path.ipsw\" Firmware/dfu/$iBSS.im4p\n    unzip -o -j \"$ipsw_path.ipsw\" Firmware/dfu/$iBEC.im4p\n    mv $iBSS.im4p $iBSS.orig\n    mv $iBEC.im4p $iBEC.orig\n    $bspatch $iBSS.orig $iBSS.im4p ../resources/patch/$iBSS.patch\n    $bspatch $iBEC.orig $iBEC.im4p ../resources/patch/$iBEC.patch\n    if [[ $device_type == \"iPad4\"* ]]; then\n        unzip -o -j \"$ipsw_path.ipsw\" Firmware/dfu/$iBSSb.im4p\n        unzip -o -j \"$ipsw_path.ipsw\" Firmware/dfu/$iBECb.im4p\n        mv $iBSSb.im4p $iBSSb.orig\n        mv $iBECb.im4p $iBECb.orig\n        $bspatch $iBSSb.orig $iBSSb.im4p ../resources/patch/$iBSSb.patch\n        $bspatch $iBECb.orig $iBECb.im4p ../resources/patch/$iBECb.patch\n    fi\n    case $device_type in\n        iPad4,[45] ) cp $iBSSb.im4p $iBECb.im4p ../saved/$device_type;;\n        * ) cp $iBSS.im4p $iBEC.im4p ../saved/$device_type;;\n    esac\n    log \"Pwned iBSS and iBEC saved at: saved/$device_type\"\n}\n\nipsw_prepare_rebootsh() {\n    log \"Generating reboot.sh\"\n    echo '#!/bin/bash' | tee reboot.sh\n    echo \"mount_hfs /dev/disk0s1s1 /mnt1; mount_hfs /dev/disk0s1s2 /mnt2\" | tee -a reboot.sh\n    echo \"nvram -d boot-partition; nvram -d boot-ramdisk\" | tee -a reboot.sh\n    echo \"/usr/bin/haxx_overwrite --${device_type}_${device_target_build}\" | tee -a reboot.sh\n}\n\nipsw_prepare_logos_convert() {\n    local iv\n    local key\n    local name\n    if [[ -n $ipsw_customlogo ]]; then\n        iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"AppleLogo\") | .iv')\n        key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"AppleLogo\") | .key')\n        name=$(echo \"$device_fw_key\" | $jq -j '.keys[] | select(.image == \"AppleLogo\") | .filename')\n        logoname=\"$name\"\n        log \"Converting custom logo\"\n        unzip -o -j \"$ipsw_path.ipsw\" $all_flash/$name\n        \"$dir/xpwntool\" $name logo-orig.img3 -iv $iv -k $key -decrypt\n        \"$dir/imagetool\" inject \"$ipsw_customlogo\" logo.img3 logo-orig.img3\n        if [[ ! -s logo.img3 ]]; then\n            error \"Converting custom logo failed. Check your image\"\n        fi\n        if [[ $device_target_powder == 1 ]]; then\n            if [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]]; then\n                log \"log4\"\n                echo \"0000010: 3467\" | xxd -r - logo.img3\n                echo \"0000020: 3467\" | xxd -r - logo.img3\n            else\n                log \"logb\"\n                echo \"0000010: 6267\" | xxd -r - logo.img3\n                echo \"0000020: 6267\" | xxd -r - logo.img3\n            fi\n        fi\n        mkdir -p $all_flash 2>/dev/null\n        mv logo.img3 $all_flash/$name\n    fi\n    if [[ -n $ipsw_customrecovery ]]; then\n        iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"RecoveryMode\") | .iv')\n        key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"RecoveryMode\") | .key')\n        name=$(echo \"$device_fw_key\" | $jq -j '.keys[] | select(.image == \"RecoveryMode\") | .filename')\n        recmname=\"$name\"\n        log \"Converting custom recovery\"\n        unzip -o -j \"$ipsw_path.ipsw\" $all_flash/$name\n        \"$dir/xpwntool\" $name recovery-orig.img3 -iv $iv -k $key -decrypt\n        \"$dir/imagetool\" inject \"$ipsw_customrecovery\" recovery.img3 recovery-orig.img3\n        if [[ ! -s recovery.img3 ]]; then\n            error \"Converting custom recovery failed. Check your image\"\n        fi\n        mkdir -p $all_flash 2>/dev/null\n        mv recovery.img3 $all_flash/$name\n    fi\n}\n\nipsw_prepare_logos_add() {\n    if [[ -n $ipsw_customlogo ]]; then\n        log \"Adding custom logo to IPSW\"\n        zip -r0 temp.ipsw $all_flash/$logoname\n    fi\n    if [[ -n $ipsw_customrecovery ]]; then\n        log \"Adding custom recovery to IPSW\"\n        zip -r0 temp.ipsw $all_flash/$recmname\n    fi\n}\n\nipsw_prepare_jailbreak() {\n    if [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    fi\n    local ExtraArgs=\n    local JBFiles=()\n    local JBFiles2=()\n    local daibutsu=$1\n\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        if [[ $device_target_vers == \"8.4.1\" ]]; then\n            ipsw_prepare_rebootsh\n            JBFiles+=(\"$jelbrek/fstab8.tar\")\n            JBFiles2=(\"daibutsu/bin.tar\" \"daibutsu/untether.tar\" \"freeze.tar\")\n            for i in {0..2}; do\n                cp $jelbrek/${JBFiles2[$i]} .\n            done\n            ExtraArgs+=\"-daibutsu\" # use daibutsuCFW\n            daibutsu=\"daibutsu\"\n        else\n            JBFiles+=(\"fstab_rw.tar\" \"freeze.tar\")\n            case $device_target_vers in\n                6.1.[3456] ) JBFiles+=(\"p0sixspwn.tar\");;\n                6* ) JBFiles+=(\"evasi0n6-untether.tar\");;\n                4.1 | 4.0* | 3.1.3 ) JBFiles+=(\"greenpois0n/${device_type}_${device_target_build}.tar\");;\n                5* | 4.[32]* ) JBFiles+=(\"g1lbertJB/${device_type}_${device_target_build}.tar\");;\n            esac\n            case $device_target_vers in\n                [43]* ) JBFiles[0]=\"fstab_old.tar\"\n            esac\n            for i in {0..1}; do\n                JBFiles[i]=$jelbrek/${JBFiles[$i]}\n            done\n            case $device_target_vers in\n                4.3* )\n                    JBFiles[2]=$jelbrek/${JBFiles[2]}\n                    if [[ $device_type == \"iPad2\"* ]]; then\n                        JBFiles[2]=\n                    fi\n                ;;\n                4.2.[8761] )\n                    if [[ $device_type == \"iPhone1,2\" ]]; then\n                        JBFiles[2]=\n                    else\n                        ExtraArgs+=\" -punchd\"\n                        JBFiles[2]=$jelbrek/greenpois0n/${device_type}_${device_target_build}.tar\n                    fi\n                ;;\n                3.0* | 3.1 | 3.1.[12] | 4.2* ) :;;\n                * ) JBFiles[2]=$jelbrek/${JBFiles[2]};;\n            esac\n            case $device_target_vers in\n                [543]* ) JBFiles+=(\"$jelbrek/cydiasubstrate.tar\");;\n            esac\n            if [[ $device_target_vers == \"3\"* ]]; then\n                JBFiles+=(\"$jelbrek/cydiahttpatch.tar\")\n            fi\n            if [[ $device_target_vers == \"5\"* ]]; then\n                JBFiles+=(\"$jelbrek/g1lbertJB.tar\")\n            fi\n            if [[ $device_target_tethered == 1 && $device_type != \"iPad2\"* ]]; then\n                case $device_target_vers in\n                    5* | 4.3* ) JBFiles+=(\"$jelbrek/g1lbertJB/install.tar\");;\n                esac\n            fi\n        fi\n        ExtraArgs+=\" -S 30\" # system partition add\n        if [[ $ipsw_openssh == 1 ]]; then\n            JBFiles+=(\"$jelbrek/sshdeb.tar\")\n        fi\n    fi\n\n    ipsw_prepare_bundle $daibutsu\n    ipsw_prepare_logos_convert\n\n    if [[ $ipsw_memory == 1 ]]; then\n        ExtraArgs+=\" -memory\"\n    fi\n    ExtraArgs+=\" -ramdiskgrow 10\"\n    if [[ $device_use_bb != 0 && $device_type != \"$device_disable_bbupdate\" ]]; then\n        ExtraArgs+=\" -bbupdate\"\n    elif [[ $device_type == \"$device_disable_bbupdate\" && $device_deadbb != 1 ]]; then\n        device_dump baseband\n        ExtraArgs+=\" ../saved/$device_type/baseband-$device_ecid.tar\"\n    fi\n    if [[ $device_actrec == 1 ]]; then\n        device_dump activation\n        ExtraArgs+=\" ../saved/$device_type/activation-$device_ecid.tar\"\n    fi\n    if [[ $1 == \"iboot\" ]]; then\n        ExtraArgs+=\" iBoot.tar\"\n    fi\n    if [[ $ipsw_isbeta == 1 ]]; then\n        ipsw_prepare_systemversion\n        ExtraArgs+=\" systemversion.tar\"\n    fi\n\n    log \"Preparing custom IPSW: $dir/ipsw $ipsw_path.ipsw temp.ipsw $ExtraArgs ${JBFiles[*]}\"\n    \"$dir/ipsw\" \"$ipsw_path.ipsw\" temp.ipsw $ExtraArgs ${JBFiles[@]}\n\n    if [[ ! -e temp.ipsw ]]; then\n        error \"Failed to find custom IPSW. Please run the script again\" \\\n        \"* You may try selecting N for memory option\"\n    fi\n\n    ipsw_prepare_logos_add\n    ipsw_prepare_fourthree\n    ipsw_bbreplace\n\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_prepare_fourthree() {\n    local comps=(\"AppleLogo\" \"DeviceTree\" \"iBoot\" \"RecoveryMode\")\n    local saved_path=\"../saved/$device_type/8L1\"\n    local bpatch=\"../resources/patch/fourthree/$device_type/6.1.3\"\n    local name\n    local iv\n    local key\n    if [[ $ipsw_fourthree != 1 ]]; then\n        return\n    fi\n    ipsw_get_url 8L1\n    url=\"$ipsw_url\"\n    device_fw_key_check\n    device_fw_key_check temp 8L1\n    mkdir -p $all_flash Downgrade $saved_path 2>/dev/null\n    log \"Extracting files\"\n    unzip -o -j \"$ipsw_path.ipsw\" $all_flash/manifest -d $all_flash\n    unzip -o -j temp.ipsw Downgrade/RestoreDeviceTree\n    log \"RestoreDeviceTree\"\n    iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"DeviceTree\") | .iv')\n    key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"DeviceTree\") | .key')\n    \"$dir/xpwntool\" RestoreDeviceTree RestoreDeviceTree.dec -iv $iv -k $key -decrypt\n    $bspatch RestoreDeviceTree.dec Downgrade/RestoreDeviceTree $bpatch/RestoreDeviceTree.patch\n    for getcomp in \"${comps[@]}\"; do\n        name=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n        iv=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        key=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        path=\"$all_flash/\"\n        log \"$getcomp\"\n        if [[ $vers == \"$device_base_vers\" ]]; then\n            unzip -o -j \"$ipsw_base_path.ipsw\" ${path}$name\n        elif [[ -e $saved_path/$name ]]; then\n            cp $saved_path/$name .\n        else\n            \"$dir/pzb\" -g \"${path}$name\" -o \"$name\" \"$url\"\n            cp $name $saved_path/\n        fi\n        \"$dir/xpwntool\" $name $getcomp.dec -iv $iv -k $key -decrypt\n        case $getcomp in\n            \"AppleLogo\" )\n                getcomp=\"applelogo\"\n                mv AppleLogo.dec applelogo.dec\n                echo \"0000010: 6267\" | xxd -r - applelogo.dec\n                echo \"0000020: 6267\" | xxd -r - applelogo.dec\n            ;;\n            \"DeviceTree\" )\n                echo \"0000010: 6272\" | xxd -r - DeviceTree.dec\n                echo \"0000020: 6272\" | xxd -r - DeviceTree.dec\n            ;;\n            \"RecoveryMode\" )\n                getcomp=\"recoverymode\"\n                mv RecoveryMode.dec recoverymode.dec\n                echo \"0000010: 6263\" | xxd -r - recoverymode.dec\n                echo \"0000020: 6263\" | xxd -r - recoverymode.dec\n            ;;\n            \"iBoot\" )\n                mv iBoot.dec iBoot.dec0\n                $bspatch iBoot.dec0 iBoot.dec $bpatch/iBoot.${device_model}ap.RELEASE.patch\n                #\"$dir/xpwntool\" iBoot.dec0 iBoot.dec2\n                #\"$dir/iBoot32Patcher\" iBoot.dec2 iBoot.patched --rsa -b \"rd=disk0s3 -v amfi=0xff cs_enforcement_disable=1 pio-error=0\"\n                #\"$dir/xpwntool\" iBoot.patched iBoot.dec -t iBoot.dec0\n                #echo \"0000010: 626F\" | xxd -r - iBoot.dec\n                #echo \"0000020: 626F\" | xxd -r - iBoot.dec\n            ;;\n        esac\n        mv $getcomp.dec $path/${getcomp}B.img3\n        echo \"${getcomp}B.img3\" >> $path/manifest\n    done\n    log \"Add files to IPSW\"\n    zip -r0 temp.ipsw $all_flash/* Downgrade/*\n}\n\nipsw_prepare_fourthree_part2() {\n    device_fw_key_check base\n    local saved_path=\"../saved/$device_type/$device_base_build\"\n    local bpatch=\"../resources/patch/fourthree/$device_type/$device_base_vers\"\n    local iv\n    local key\n    mkdir -p $saved_path 2>/dev/null\n    if [[ ! -s $saved_path/Kernelcache ]]; then\n        log \"Kernelcache\"\n        iv=$(echo $device_fw_key_base | $jq -j '.keys[] | select(.image == \"Kernelcache\") | .iv')\n        key=$(echo $device_fw_key_base | $jq -j '.keys[] | select(.image == \"Kernelcache\") | .key')\n        unzip -o -j \"$ipsw_base_path.ipsw\" kernelcache.release.$device_model\n        \"$dir/xpwntool\" kernelcache.release.$device_model kernelcache.dec -iv $iv -k $key\n        $bspatch kernelcache.dec kernelcache.patched $bpatch/kernelcache.release.patch\n        #$bspatch kernelcache.dec kernelcache.patched ../resources/patch/kernelcache.release.$device_model.$device_base_build.patch\n        \"$dir/xpwntool\" kernelcache.patched kernelcachb -t kernelcache.release.$device_model -iv $iv -k $key\n        \"$dir/xpwntool\" kernelcachb $saved_path/Kernelcache -iv $iv -k $key -decrypt\n    fi\n    if [[ ! -s $saved_path/LLB ]]; then\n        log \"LLB\"\n        iv=$(echo $device_fw_key_base | $jq -j '.keys[] | select(.image == \"LLB\") | .iv')\n        key=$(echo $device_fw_key_base | $jq -j '.keys[] | select(.image == \"LLB\") | .key')\n        unzip -o -j \"$ipsw_base_path.ipsw\" $all_flash/LLB.${device_model}ap.RELEASE.img3\n        \"$dir/xpwntool\" LLB.${device_model}ap.RELEASE.img3 llb.dec -iv $iv -k $key\n        $bspatch llb.dec $saved_path/LLB $bpatch/LLB.${device_model}ap.RELEASE.patch\n    fi\n    if [[ ! -s $saved_path/RootFS.dmg ]]; then\n        log \"RootFS\"\n        name=$(echo $device_fw_key_base | $jq -j '.keys[] | select(.image == \"RootFS\") | .filename')\n        key=$(echo $device_fw_key_base | $jq -j '.keys[] | select(.image == \"RootFS\") | .key')\n        unzip -o -j \"$ipsw_base_path.ipsw\" $name\n        \"$dir/dmg\" extract $name rootfs.dec -k $key\n        rm $name\n        \"$dir/dmg\" build rootfs.dec $saved_path/RootFS.dmg\n    fi\n    echo \"device_base_vers=$device_base_vers\" > ../saved/$device_type/fourthree_$device_ecid\n    echo \"device_base_build=$device_base_build\" >> ../saved/$device_type/fourthree_$device_ecid\n}\n\nipsw_prepare_keys() {\n    local comp=\"$1\"\n    local getcomp=\"$1\"\n    case $comp in\n        \"RestoreLogo\" ) getcomp=\"AppleLogo\";;\n        *\"KernelCache\" ) getcomp=\"Kernelcache\";;\n        \"RestoreDeviceTree\" ) getcomp=\"DeviceTree\";;\n    esac\n    local fw_key=\"$device_fw_key\"\n    if [[ $2 == \"base\" ]]; then\n        fw_key=\"$device_fw_key_base\"\n    fi\n    local name=$(echo $fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n    local iv=$(echo $fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n    local key=$(echo $fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n    if [[ $device_target_build == \"14\"* && $getcomp == \"iBSS\" ]]; then\n        name=\"$(curl \"https://www.theiphonewiki.com/wiki/${ipsw_codename}_${device_target_build}_(${device_type})\" | grep \"iBSS\" -A1 | sed \"s/^.*keypage-ibss\\\">//\" | sed \"s/^.*h2>//\" | sed \"s/<\\/span>//\" | sed \"s/<\\/p>//\" | tr -d '\\n')\"\n    elif [[ $device_target_build == \"14\"* && $getcomp == \"iBEC\" ]]; then\n        name=\"$(curl \"https://www.theiphonewiki.com/wiki/${ipsw_codename}_${device_target_build}_(${device_type})\" | grep \"iBEC\" -A1 | sed \"s/^.*keypage-ibec\\\">//\" | sed \"s/^.*h2>//\" | sed \"s/<\\/span>//\" | sed \"s/<\\/p>//\" | tr -d '\\n')\"\n    fi\n    if [[ -z $name && $device_proc != 1 ]]; then\n        error \"Issue with firmware keys: Failed getting $getcomp. Check The Apple Wiki or your wikiproxy\"\n    fi\n\n    case $comp in\n        \"iBSS\" | \"iBEC\" )\n            if [[ -z $name ]]; then\n                name=\"$getcomp.${device_model}ap.RELEASE.dfu\"\n            fi\n            echo \"<key>$comp</key><dict><key>File</key><string>Firmware/dfu/$name</string><key>IV</key><string>$iv</string><key>Key</key><string>$key</string>\" >> $NewPlist\n            if [[ $ipsw_prepare_usepowder == 1 ]]; then\n                echo \"<key>Patch</key><true/>\" >> $NewPlist\n            elif [[ -s $FirmwareBundle/$comp.${device_model}ap.RELEASE.patch ]]; then\n                echo \"<key>Patch</key><string>$comp.${device_model}ap.RELEASE.patch</string>\" >> $NewPlist\n            elif [[ -s $FirmwareBundle/$comp.${device_model}.RELEASE.patch ]]; then\n                echo \"<key>Patch</key><string>$comp.${device_model}.RELEASE.patch</string>\" >> $NewPlist\n            fi\n        ;;\n\n        \"iBoot\" )\n            echo \"<key>$comp</key><dict><key>File</key><string>$all_flash/$name</string><key>IV</key><string>$iv</string><key>Key</key><string>$key</string>\" >> $NewPlist\n            echo \"<key>Patch</key><string>$comp.${device_model}ap.RELEASE.patch</string>\" >> $NewPlist\n        ;;\n\n        \"RestoreRamdisk\" )\n            echo \"<key>Restore Ramdisk</key><dict><key>File</key><string>$name</string><key>IV</key><string>$iv</string><key>Key</key><string>$key</string>\" >> $NewPlist\n        ;;\n\n        \"RestoreDeviceTree\" | \"RestoreLogo\" )\n            echo \"<key>$comp</key><dict><key>File</key><string>$all_flash/$name</string><key>IV</key><string>$iv</string><key>Key</key><string>$key</string><key>DecryptPath</key><string>Downgrade/$comp</string>\" >> $NewPlist\n        ;;\n\n        \"RestoreKernelCache\" )\n            echo \"<key>$comp</key><dict><key>File</key><string>$name</string><key>IV</key><string>$iv</string><key>Key</key><string>$key</string><key>DecryptPath</key><string>Downgrade/$comp</string>\" >> $NewPlist\n        ;;\n\n        \"KernelCache\" )\n            echo \"<key>$comp</key><dict><key>File</key><string>$name</string><key>IV</key><string>$iv</string><key>Key</key><string>$key</string>\" >> $NewPlist\n            if [[ $ipsw_prepare_usepowder == 1 ]]; then\n                echo \"<key>Patch</key><true/>\" >> $NewPlist\n            elif [[ -e $FirmwareBundle/kernelcache.release.patch ]]; then\n                echo \"<key>Patch</key><string>kernelcache.release.patch</string>\" >> $NewPlist\n            fi\n        ;;\n\n        \"WTF2\" )\n            echo \"<key>WTF 2</key><dict><key>File</key><string>Firmware/dfu/WTF.s5l8900xall.RELEASE.dfu</string><key>Patch</key><string>WTF.s5l8900xall.RELEASE.patch</string>\" >> $NewPlist\n        ;;\n    esac\n    if [[ $2 != \"old\" ]]; then\n        echo \"<key>Decrypt</key><true/>\" >> $NewPlist\n    fi\n    echo \"</dict>\" >> $NewPlist\n}\n\nipsw_prepare_paths() {\n    local comp=\"$1\"\n    local getcomp=\"$1\"\n    case $comp in\n        \"BatteryPlugin\" ) getcomp=\"GlyphPlugin\";;\n        \"NewAppleLogo\" | \"APTicket\" ) getcomp=\"AppleLogo\";;\n        \"NewRecoveryMode\" ) getcomp=\"RecoveryMode\";;\n        \"NewiBoot\" ) getcomp=\"iBoot\";;\n    esac\n    local fw_key=\"$device_fw_key\"\n    if [[ $2 == \"base\" ]]; then\n        fw_key=\"$device_fw_key_base\"\n    fi\n    local name=$(echo $fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n    if [[ -z $name && $getcomp != \"manifest\" ]]; then\n        error \"Issue with firmware keys: Failed getting $getcomp. Check The Apple Wiki or your wikiproxy\"\n    fi\n    local str=\"<key>$comp</key><dict><key>File</key><string>$all_flash/\"\n    local str2\n    local logostuff\n    if [[ $2 == \"target\" ]]; then\n        case $comp in\n            *\"AppleLogo\" )\n                if [[ $device_latest_vers == \"5\"* ]]; then\n                    logostuff=1\n                else\n                    case $device_target_vers in\n                        [789]* ) logostuff=1;;\n                    esac\n                fi\n            ;;\n        esac\n        case $comp in\n            \"AppleLogo\" ) str2=\"${name/applelogo/applelogo7}\";;\n            \"APTicket\" ) str2=\"${name/applelogo/applelogoT}\";;\n            \"RecoveryMode\" ) str2=\"${name/recoverymode/recoverymode7}\";;\n            \"NewiBoot\" ) str2=\"${name/iBoot/iBoot2}\";;\n        esac\n        case $comp in\n            \"AppleLogo\" )\n                str+=\"$str2\"\n                if [[ $logostuff == 1 ]]; then\n                    echo \"$str2\" >> $FirmwareBundle/manifest\n                fi\n            ;;\n            \"APTicket\" | \"RecoveryMode\" )\n                str+=\"$str2\"\n                echo \"$str2\" >> $FirmwareBundle/manifest\n            ;;\n            \"NewiBoot\" )\n                if [[ $device_type != \"iPad1,1\" ]]; then\n                    str+=\"$str2\"\n                    echo \"$str2\" >> $FirmwareBundle/manifest\n                fi\n            ;;\n            \"manifest\" ) str+=\"manifest\";;\n            * ) str+=\"$name\";;\n        esac\n    else\n        str+=\"$name\"\n    fi\n    str+=\"</string>\"\n\n    if [[ $comp == \"NewiBoot\" ]]; then\n        local iv=$(echo $fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        local key=$(echo $fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        str+=\"<key>IV</key><string>$iv</string><key>Key</key><string>$key</string>\"\n    elif [[ $comp == \"manifest\" ]]; then\n        str+=\"<key>manifest</key><string>manifest</string>\"\n    fi\n\n    echo \"$str</dict>\" >> $NewPlist\n}\n\nipsw_prepare_config() {\n    # usage: ipsw_prepare_config [jailbreak (true/false)] [needpref (true/false)]\n    # creates config file to FirmwareBundles/config.plist\n    local verbose=\"false\"\n    if [[ $ipsw_verbose == 1 ]]; then\n        verbose=\"true\"\n    fi\n    log \"Preparing config file\"\n    echo \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n<!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\n<plist version=\\\"1.0\\\">\n<dict>\n    <key>FilesystemJailbreak</key>\n    <$1/>\n    <key>needPref</key>\n    <$2/>\n    <key>iBootPatches</key>\n    <dict>\n        <key>debugEnabled</key>\n        <false/>\n        <key>bootArgsInjection</key>\n        <$verbose/>\n        <key>bootArgsString</key>\n        <string>-v</string>\n    </dict>\n</dict>\n</plist>\" | tee FirmwareBundles/config.plist\n}\n\nipsw_prepare_systemversion() {\n    local sysplist=\"SystemVersion.plist\"\n    log \"Beta iOS detected, preparing modified $sysplist\"\n    echo '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"><plist version=\"1.0\"><dict>' > $sysplist\n    echo \"<key>ProductBuildVersion</key><string>$device_target_build</string>\" >> $sysplist\n    local copyright=\"<key>ProductCopyright</key><string>1983-201\"\n    case $device_target_vers in\n        3* ) copyright+=\"0\";;\n        4* ) copyright+=\"1\";;\n        5* ) copyright+=\"2\";;\n        6* ) copyright+=\"3\";;\n        7* ) copyright+=\"4\";;\n        8* ) copyright+=\"5\";;\n        9* ) copyright+=\"6\";;\n    esac\n    copyright+=\" Apple Inc.</string>\"\n    echo \"$copyright\" >> $sysplist # idk if the copyright key is actually needed but whatever\n    echo \"<key>ProductName</key><string>iPhone OS</string>\" >> $sysplist\n    echo \"<key>ProductVersion</key><string>$device_target_vers</string>\" >> $sysplist\n    echo \"</dict></plist>\" >> $sysplist\n    cat $sysplist\n    mkdir -p System/Library/CoreServices\n    mv SystemVersion.plist System/Library/CoreServices\n    tar -cvf systemversion.tar System\n}\n\nipsw_prepare_bundle() {\n    device_fw_key_check $1\n    local ipsw_p=\"$ipsw_path\"\n    local key=\"$device_fw_key\"\n    local vers=\"$device_target_vers\"\n    local build=\"$device_target_build\"\n    local hw=\"$device_model\"\n    local base_build=\"11D257\"\n    local RootSize\n    local daibutsu\n    FirmwareBundle=\"FirmwareBundles/\"\n    if [[ $1 == \"daibutsu\" ]]; then\n        daibutsu=1\n    fi\n\n    mkdir FirmwareBundles 2>/dev/null\n    if [[ $1 == \"base\" ]]; then\n        ipsw_p=\"$ipsw_base_path\"\n        key=\"$device_fw_key_base\"\n        vers=\"$device_base_vers\"\n        build=\"$device_base_build\"\n        FirmwareBundle+=\"BASE_\"\n    elif [[ $1 == \"target\" ]]; then\n        if [[ $ipsw_jailbreak == 1 ]]; then\n            case $vers in\n                [689]* ) ipsw_prepare_config true true;;\n                * ) ipsw_prepare_config false true;;\n            esac\n        else\n            ipsw_prepare_config false true\n        fi\n    elif [[ $ipsw_jailbreak == 1 ]]; then\n        ipsw_prepare_config false true\n    else\n        ipsw_prepare_config false false\n    fi\n    local FirmwareBundle2=\"../resources/firmware/FirmwareBundles/Down_${device_type}_${vers}_${build}.bundle\"\n    if [[ $ipsw_prepare_usepowder == 1 ]]; then\n        FirmwareBundle2=\n    elif [[ -d $FirmwareBundle2 ]]; then\n        FirmwareBundle+=\"Down_\"\n    fi\n    FirmwareBundle+=\"${device_type}_${vers}_${build}.bundle\"\n    local NewPlist=$FirmwareBundle/Info.plist\n    mkdir -p $FirmwareBundle\n\n    log \"Generating firmware bundle for $device_type-$vers ($build) $1...\"\n    unzip -o -j \"$ipsw_p.ipsw\" $all_flash/manifest\n    mv manifest $FirmwareBundle/\n    local ramdisk_name=$(echo \"$key\" | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .filename')\n    local RamdiskIV=$(echo \"$key\" | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .iv')\n    local RamdiskKey=$(echo \"$key\" | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .key')\n    if [[ $device_target_build == \"14\"* ]]; then\n        case $device_target_build in\n            14A* ) ipsw_codename=\"Whitetail\";;\n            14B* ) ipsw_codename=\"Butler\";;\n            14C* ) ipsw_codename=\"Corry\";;\n            14D* ) ipsw_codename=\"Dubois\";;\n            14E* ) ipsw_codename=\"Erie\";;\n            14F* ) ipsw_codename=\"Franklin\";;\n            14G* ) ipsw_codename=\"Greensburg\";;\n        esac\n        if [[ $ipsw_isbeta == 1 ]]; then\n            ipsw_codename+=\"Seed\"\n        fi\n        ramdisk_name=\"$(curl \"https://www.theiphonewiki.com/wiki/${ipsw_codename}_${device_target_build}_(${device_type})\" | grep \"Restore Ramdisk\" -A1 | sed \"s/^.*keypage-restoreramdisk\\\">//\" | sed \"s/^.*h2>//\" | sed \"s/<\\/span>//\" | tr -d '\\n')\"\n    fi\n    if [[ -z $ramdisk_name ]]; then\n        error \"Issue with firmware keys: Failed getting RestoreRamdisk. Check The Apple Wiki or your wikiproxy\"\n    fi\n    unzip -o -j \"$ipsw_p.ipsw\" $ramdisk_name\n    \"$dir/xpwntool\" $ramdisk_name Ramdisk.raw -iv $RamdiskIV -k $RamdiskKey\n    \"$dir/hfsplus\" Ramdisk.raw extract usr/local/share/restore/options.$device_model.plist\n    if [[ ! -s options.$device_model.plist ]]; then\n        rm options.$device_model.plist\n        \"$dir/hfsplus\" Ramdisk.raw extract usr/local/share/restore/options.plist\n        mv options.plist options.$device_model.plist\n    fi\n    if [[ $device_target_vers == \"3.2\"* ]]; then\n        RootSize=1000\n    elif [[ $device_target_vers == \"3\"* ]]; then\n        case $device_type in\n            iPhone1* | iPod1,1 ) RootSize=420;;\n            iPod2,1 ) RootSize=450;;\n            *       ) RootSize=750;;\n        esac\n    elif [[ $platform == \"macos\" ]]; then\n        plutil -extract 'SystemPartitionSize' xml1 options.$device_model.plist -o size\n        RootSize=$(cat size | sed -ne '/<integer>/,/<\\/integer>/p' | sed -e \"s/<integer>//\" | sed \"s/<\\/integer>//\" | sed '2d')\n    else\n        RootSize=$(cat options.$device_model.plist | grep -i SystemPartitionSize -A 1 | grep -oPm1 \"(?<=<integer>)[^<]+\")\n    fi\n    RootSize=$((RootSize+30))\n    local rootfs_name=\"$(echo \"$key\" | $jq -j '.keys[] | select(.image == \"RootFS\") | .filename')\"\n    local rootfs_key=\"$(echo \"$key\" | $jq -j '.keys[] | select(.image == \"RootFS\") | .key')\"\n    if [[ $device_target_build == \"14\"* ]]; then\n        rootfs_name=\"$(curl \"https://www.theiphonewiki.com/wiki/${ipsw_codename}_${device_target_build}_(${device_type})\" | grep \"Root\" -A1 | sed \"s/^.*keypage-rootfs\\\">//\" | sed \"s/^.*h2>//\" | sed \"s/<\\/span>//\" | tr -d '\\n')\"\n    fi\n    if [[ -z $rootfs_name ]]; then\n        error \"Issue with firmware keys: Failed getting RootFS. Check The Apple Wiki or your wikiproxy\"\n    fi\n    echo '<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"><plist version=\"1.0\"><dict>' > $NewPlist\n    echo \"<key>Filename</key><string>$ipsw_p.ipsw</string>\" >> $NewPlist\n    echo \"<key>RootFilesystem</key><string>$rootfs_name</string>\" >> $NewPlist\n    echo \"<key>RootFilesystemKey</key><string>$rootfs_key</string>\" >> $NewPlist\n    echo \"<key>RootFilesystemSize</key><integer>$RootSize</integer>\" >> $NewPlist\n    printf \"<key>RamdiskOptionsPath</key><string>/usr/local/share/restore/options\" >> $NewPlist\n    if [[ $device_target_vers != \"3\"* && $device_target_vers != \"4\"* ]] ||\n       [[ $device_type == \"iPad1,1\" && $device_target_vers == \"4\"* ]]; then\n        printf \".%s\" \"$device_model\" >> $NewPlist\n    fi\n    echo \".plist</string>\" >> $NewPlist\n    if [[ $1 == \"base\" ]]; then\n        echo \"<key>SHA1</key><string>$device_base_sha1</string>\" >> $NewPlist\n    else\n        echo \"<key>SHA1</key><string>$device_target_sha1</string>\" >> $NewPlist\n    fi\n\n    if [[ $1 == \"base\" ]]; then\n        case $device_type in\n            iPhone5,[12] ) hw=\"iphone5\";;\n            iPhone5,[34] ) hw=\"iphone5b\";;\n            iPad3,[456] )  hw=\"ipad3b\";;\n        esac\n        case $device_base_build in\n            \"11A\"* | \"11B\"* ) base_build=\"11B554a\";;\n            \"9\"* ) base_build=\"9B206\";;\n        esac\n        echo \"<key>RamdiskExploit</key><dict>\" >> $NewPlist\n        echo \"<key>exploit</key><string>src/target/$hw/$base_build/exploit</string>\" >> $NewPlist\n        echo \"<key>inject</key><string>src/target/$hw/$base_build/partition</string></dict>\" >> $NewPlist\n    elif [[ $1 == \"target\" ]]; then\n        echo \"<key>FilesystemPackage</key><dict><key>bootstrap</key><string>freeze.tar</string>\" >> $NewPlist\n        case $vers in\n            8* | 9* ) echo \"<key>package</key><string>src/ios9.tar</string>\" >> $NewPlist;;\n        esac\n        printf \"</dict><key>RamdiskPackage</key><dict><key>package</key><string>src/bin.tar</string><key>ios</key><string>ios\" >> $NewPlist\n        case $vers in\n            3* ) printf \"3\" >> $NewPlist;;\n            4* ) printf \"4\" >> $NewPlist;;\n            5* ) printf \"5\" >> $NewPlist;;\n            6* ) printf \"6\" >> $NewPlist;;\n            7* ) printf \"7\" >> $NewPlist;;\n            8* ) printf \"8\" >> $NewPlist;;\n            9* ) printf \"9\" >> $NewPlist;;\n        esac\n        echo \"</string></dict>\" >> $NewPlist\n    elif [[ $ipsw_prepare_usepowder == 1 ]]; then\n        echo \"<key>FilesystemPackage</key><dict/><key>RamdiskPackage</key><dict/>\" >> $NewPlist\n    elif [[ $ipsw_isbeta == 1 && $ipsw_prepare_usepowder != 1 ]]; then\n        warn \"iOS 4.1 beta or older detected. Attempting workarounds\"\n        cp $FirmwareBundle2/* $FirmwareBundle\n        echo \"<key>RamdiskPatches</key><dict/>\" >> $NewPlist\n        echo \"<key>FilesystemPatches</key><dict/>\" >> $NewPlist\n        ipsw_isbeta_needspatch=1\n    elif [[ -d $FirmwareBundle2 ]]; then\n        cp $FirmwareBundle2/* $FirmwareBundle\n        echo \"<key>RamdiskPatches</key><dict>\" >> $NewPlist\n        echo \"<key>asr</key><dict>\" >> $NewPlist\n        echo \"<key>File</key><string>usr/sbin/asr</string><key>Patch</key><string>asr.patch</string></dict>\" >> $NewPlist\n        if [[ -s $FirmwareBundle/restoredexternal.patch ]]; then\n            echo \"<key>restoredexternal</key><dict>\" >> $NewPlist\n            echo \"<key>File</key><string>usr/local/bin/restored_external</string><key>Patch</key><string>restoredexternal.patch</string></dict>\" >> $NewPlist\n        fi\n        echo \"</dict>\" >> $NewPlist\n        if [[ $ipsw_hacktivate == 1 ]]; then\n            echo \"<key>FilesystemPatches</key><dict>\" >> $NewPlist\n            echo \"<key>Hacktivation</key><array><dict>\" >> $NewPlist\n            echo \"<key>Action</key><string>Patch</string><key>File</key><string>usr/libexec/lockdownd</string>\" >> $NewPlist\n            echo \"<key>Patch</key><string>lockdownd.patch</string></dict></array></dict>\" >> $NewPlist\n        else\n            echo \"<key>FilesystemPatches</key><dict/>\" >> $NewPlist # ipsw segfaults if this is missing lol\n        fi\n    fi\n\n    if [[ $1 == \"base\" ]]; then\n        echo \"<key>Firmware</key><dict/>\" >> $NewPlist\n    elif [[ $1 == \"target\" && $vers == \"4\"* ]]; then\n        echo \"<key>Firmware</key><dict>\" >> $NewPlist\n        ipsw_prepare_keys iBSS $1\n        ipsw_prepare_keys RestoreRamdisk $1\n        echo \"</dict>\" >> $NewPlist\n    elif [[ $ipsw_isbeta_needspatch == 1 ]]; then\n        echo \"<key>FirmwarePatches</key><dict>\" >> $NewPlist\n        ipsw_prepare_keys RestoreDeviceTree $1\n        ipsw_prepare_keys RestoreLogo $1\n        ipsw_prepare_keys RestoreKernelCache $1\n        ipsw_prepare_keys RestoreRamdisk $1\n        echo \"</dict>\" >> $NewPlist\n    elif [[ $device_target_build == \"14\"* ]]; then\n        echo \"<key>Firmware</key><dict>\" >> $NewPlist\n        ipsw_prepare_keys iBSS\n        ipsw_prepare_keys iBEC\n        ipsw_prepare_keys RestoreRamdisk\n    else\n        if [[ $ipsw_prepare_usepowder == 1 ]]; then\n            echo \"<key>Firmware</key><dict>\" >> $NewPlist\n        else\n            echo \"<key>FirmwarePatches</key><dict>\" >> $NewPlist\n        fi\n        ipsw_prepare_keys iBSS $1\n        # ios 4 and lower do not need ibec patches. the exception is the ipad lineup\n        if [[ $vers != \"3\"* && $vers != \"4\"* ]] || [[ $device_type == \"iPad1,1\" || $device_type == \"iPad2\"* ]]; then\n            ipsw_prepare_keys iBEC $1\n        fi\n        if [[ $device_proc == 1 && $device_target_vers != \"4.2.1\" ]]; then\n            :\n        else\n            ipsw_prepare_keys RestoreDeviceTree $1\n            ipsw_prepare_keys RestoreLogo $1\n        fi\n        if [[ $1 == \"target\" ]]; then\n            case $vers in\n                [457]* ) ipsw_prepare_keys RestoreKernelCache $1;;\n                * ) ipsw_prepare_keys KernelCache $1;;\n            esac\n        elif [[ $device_proc == 1 && $device_target_vers == \"4.2.1\" ]]; then\n            ipsw_prepare_keys RestoreKernelCache $1\n        elif [[ $device_proc != 1 && $device_target_vers != \"3.0\"* ]]; then\n            ipsw_prepare_keys RestoreKernelCache $1\n        fi\n        ipsw_prepare_keys RestoreRamdisk $1\n        if [[ $1 == \"old\" ]]; then\n            if [[ $device_type == \"iPod2,1\" && $device_newbr == 0 && $device_target_vers == \"3.1.3\" ]]; then\n                ipsw_prepare_keys iBoot $1\n                ipsw_prepare_keys KernelCache $1\n            elif [[ $device_proc == 1 ]]; then\n                ipsw_prepare_keys KernelCache $1\n                ipsw_prepare_keys WTF2 $1\n            else\n                case $device_target_vers in\n                    6.1.6 | 4.1 ) :;;\n                    3.0* ) ipsw_prepare_keys iBoot $1;;\n                    * )\n                        ipsw_prepare_keys iBoot $1\n                        ipsw_prepare_keys KernelCache $1\n                    ;;\n                esac\n            fi\n        fi\n        echo \"</dict>\" >> $NewPlist\n    fi\n\n    if [[ $1 == \"base\" ]]; then\n        echo \"<key>FirmwarePath</key><dict>\" >> $NewPlist\n        ipsw_prepare_paths AppleLogo $1\n        ipsw_prepare_paths BatteryCharging0 $1\n        ipsw_prepare_paths BatteryCharging1 $1\n        ipsw_prepare_paths BatteryFull $1\n        ipsw_prepare_paths BatteryLow0 $1\n        ipsw_prepare_paths BatteryLow1 $1\n        ipsw_prepare_paths BatteryPlugin $1\n        ipsw_prepare_paths RecoveryMode $1\n        ipsw_prepare_paths LLB $1\n        ipsw_prepare_paths iBoot $1\n        echo \"</dict>\" >> $NewPlist\n    elif [[ $1 == \"target\" ]]; then\n        echo \"<key>FirmwareReplace</key><dict>\" >> $NewPlist\n        if [[ $vers == \"4\"* ]]; then\n            ipsw_prepare_paths APTicket $1\n        fi\n        ipsw_prepare_paths AppleLogo $1\n        ipsw_prepare_paths NewAppleLogo $1\n        ipsw_prepare_paths BatteryCharging0 $1\n        ipsw_prepare_paths BatteryCharging1 $1\n        ipsw_prepare_paths BatteryFull $1\n        ipsw_prepare_paths BatteryLow0 $1\n        ipsw_prepare_paths BatteryLow1 $1\n        ipsw_prepare_paths BatteryPlugin $1\n        ipsw_prepare_paths RecoveryMode $1\n        ipsw_prepare_paths NewRecoveryMode $1\n        ipsw_prepare_paths LLB $1\n        ipsw_prepare_paths iBoot $1\n        ipsw_prepare_paths NewiBoot $1\n        ipsw_prepare_paths manifest $1\n        echo \"</dict>\" >> $NewPlist\n    fi\n\n    if [[ $daibutsu == 1 ]]; then\n        if [[ $ipsw_prepare_usepowder == 1 ]]; then\n            echo \"<key>RamdiskPackage2</key>\" >> $NewPlist\n        else\n            echo \"<key>PackagePath</key><string>./freeze.tar</string>\" >> $NewPlist\n            echo \"<key>RamdiskPackage</key>\" >> $NewPlist\n        fi\n        echo \"<string>./bin.tar</string><key>RamdiskReboot</key><string>./reboot.sh</string><key>UntetherPath</key><string>./untether.tar</string>\" >> $NewPlist\n        local hwmodel=\"$(tr '[:lower:]' '[:upper:]' <<< ${device_model:0:1})${device_model:1}\"\n        echo \"<key>hwmodel</key><string>$hwmodel</string>\" >> $NewPlist\n    fi\n\n    echo \"</dict></plist>\" >> $NewPlist\n    cat $NewPlist\n}\n\nipsw_prepare_32bit() {\n    local ExtraArgs\n    local daibutsu\n    local JBFiles=()\n    # use everuntether instead of daibutsu+dsc haxx for a5(x) 8.0-8.2\n    if [[ $device_proc == 5 && $ipsw_jailbreak == 1 ]]; then\n        case $device_target_vers in\n            8.[012]* )\n                ipsw_everuntether=1\n                JBFiles+=(\"everuntether.tar\")\n            ;;\n        esac\n    fi\n    if [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]] && [[ $ipsw_nskip != 1 ]]; then\n        ipsw_prepare_jailbreak\n        return\n    elif [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    elif [[ $ipsw_jailbreak == 1 && $device_target_vers == \"8\"* && $ipsw_everuntether != 1 ]]; then\n        daibutsu=\"daibutsu\"\n        ExtraArgs+=\" -daibutsu\"\n        cp $jelbrek/daibutsu/bin.tar $jelbrek/daibutsu/untether.tar .\n        ipsw_prepare_rebootsh\n    elif [[ $ipsw_nskip == 1 ]]; then\n        :\n    elif [[ $ipsw_jailbreak != 1 && $device_target_build != \"9A406\" && # 9a406 needs custom ipsw\n            $device_proc != 4 && $device_actrec != 1 && $device_target_tethered != 1 ]]; then\n        log \"No need to create custom IPSW for non-jailbroken restores on $device_type-$device_target_build\"\n        return\n    fi\n    ipsw_prepare_usepowder=1\n\n    ipsw_prepare_bundle $daibutsu\n\n    if [[ $ipsw_memory == 1 ]]; then\n        ExtraArgs+=\" -memory\"\n    fi\n    ExtraArgs+=\" -ramdiskgrow 10\"\n    if [[ $device_use_bb != 0 && $device_type != \"$device_disable_bbupdate\" ]]; then\n        ExtraArgs+=\" -bbupdate\"\n    elif [[ $device_type == \"$device_disable_bbupdate\" && $device_deadbb != 1 ]]; then\n        device_dump baseband\n        ExtraArgs+=\" ../saved/$device_type/baseband-$device_ecid.tar\"\n    fi\n    if [[ $device_actrec == 1 ]]; then\n        device_dump activation\n        ExtraArgs+=\" ../saved/$device_type/activation-$device_ecid.tar\"\n    fi\n\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        case $device_target_vers in\n            9.3.[1234] | 9.3 ) JBFiles+=(\"untetherhomedepot.tar\");;\n            9.2* | 9.1 )       JBFiles+=(\"untetherhomedepot921.tar\");;\n            9.0* )             JBFiles+=(\"everuntether.tar\");;\n            7.1* )\n                case $device_type in\n                    iPod* ) JBFiles+=(\"panguaxe-ipod.tar\");;\n                    *     ) JBFiles+=(\"panguaxe.tar\");;\n                esac\n            ;;\n            7* )           JBFiles+=(\"evasi0n7-untether.tar\");;\n            6.1.[3456] )   JBFiles+=(\"p0sixspwn.tar\");;\n            6* )           JBFiles+=(\"evasi0n6-untether.tar\");;\n            5* | 4.[32]* ) JBFiles+=(\"g1lbertJB/${device_type}_${device_target_build}.tar\");;\n        esac\n        if [[ -n ${JBFiles[0]} ]]; then\n            JBFiles[0]=$jelbrek/${JBFiles[0]}\n        fi\n        case $device_target_vers in\n            [98]* ) JBFiles+=(\"$jelbrek/fstab8.tar\");;\n            7* ) JBFiles+=(\"$jelbrek/fstab7.tar\");;\n            4* ) JBFiles+=(\"$jelbrek/fstab_old.tar\");;\n            * )  JBFiles+=(\"$jelbrek/fstab_rw.tar\");;\n        esac\n        case $device_target_vers in\n            4.3* )\n                if [[ $device_type == \"iPad2\"* ]]; then\n                    JBFiles[0]=\n                fi\n            ;;\n            4.2.9 | 4.2.10 ) JBFiles[0]=;;\n            4.2.1 )\n                if [[ $device_type != \"iPhone1,2\" ]]; then\n                    ExtraArgs+=\" -punchd\"\n                    JBFiles[0]=$jelbrek/greenpois0n/${device_type}_${device_target_build}.tar\n                fi\n            ;;\n        esac\n        JBFiles+=(\"$jelbrek/freeze.tar\")\n        if [[ $device_target_vers == \"9\"* || $ipsw_everuntether == 1 ]]; then\n            JBFiles+=(\"$jelbrek/daemonloader.tar\" \"$jelbrek/launchctl.tar\")\n        elif [[ $device_target_vers == \"5\"* ]]; then\n            JBFiles+=(\"$jelbrek/cydiasubstrate.tar\" \"$jelbrek/g1lbertJB.tar\")\n        fi\n        if [[ $ipsw_openssh == 1 ]]; then\n            JBFiles+=(\"$jelbrek/sshdeb.tar\")\n        fi\n        if [[ $device_target_tethered == 1 ]]; then\n            case $device_target_vers in\n                5* | 4.3* ) JBFiles+=(\"$jelbrek/g1lbertJB/install.tar\");;\n            esac\n        fi\n    fi\n    if [[ $ipsw_isbeta == 1 ]]; then\n        ipsw_prepare_systemversion\n        ExtraArgs+=\" systemversion.tar\"\n    fi\n    if [[ $1 == \"iboot\" ]]; then\n        ExtraArgs+=\" iBoot.tar\"\n    fi\n\n    log \"Preparing custom IPSW: $dir/powdersn0w $ipsw_path.ipsw temp.ipsw $ExtraArgs ${JBFiles[*]}\"\n    \"$dir/powdersn0w\" \"$ipsw_path.ipsw\" temp.ipsw $ExtraArgs ${JBFiles[@]}\n\n    if [[ ! -e temp.ipsw ]]; then\n        error \"Failed to find custom IPSW. Please run the script again\" \\\n        \"* You may try selecting N for memory option\"\n    fi\n\n    ipsw_bbreplace\n    if [[ $device_target_vers == \"4\"* ]]; then\n        ipsw_prepare_ios4patches\n        log \"Add all to custom IPSW\"\n        zip -r0 temp.ipsw Firmware/dfu/*\n    fi\n\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_bbdigest() {\n    local loc=\"BuildIdentities:0:\"\n    if [[ $2 != \"UniqueBuildID\" ]]; then\n        loc+=\"Manifest:BasebandFirmware:\"\n    fi\n    loc+=\"$2\"\n    local out=\"$1\"\n    if [[ $platform == \"macos\" ]]; then\n        echo $out | base64 --decode > t\n        log \"Replacing $2\"\n        $PlistBuddy -c \"Import $loc t\" BuildManifest.plist\n        rm t\n        return\n    fi\n    in=$($PlistBuddy -c \"Print $loc\" BuildManifest.plist | tr -d \"<>\" | xxd -r -p | base64)\n    echo \"${in}<\" > replace\n    #sed -i'' \"s,AAAAAAAAAAAAAAAAAAAAAAA<,==,\" replace\n    #sed -i'' \"s,AAAAAAAAAAAAA<,=,\" replace\n    #sed -i'' \"s,AAAAAAAAA<,=,\" replace\n    cat replace | sed \"s,AAAAAAAAAAAAAAAAAAAAAAA<,==,\" > t\n    cat t  | sed \"s,AAAAAAAAAAAAA<,=,\" > tt\n    cat tt | sed \"s,AAAAAAAAA<,=,\" > replace\n    in=\"$(cat replace)\"\n    rm replace t tt\n    case $2 in\n        *\"PartialDigest\" )\n            in=\"${in%????????????}\"\n            in=$(cat BuildManifest.plist | grep \"$in\" -m1)\n            log \"Replacing $2\"\n            #sed -i'' \"s,$in,replace,\" BuildManifest.plist\n            #sed -i'' \"/replace/{n;d}\" BuildManifest.plist\n            cat BuildManifest.plist | sed \"s,$in,replace,\" > t\n            awk 'f{$0=\"\";f=0}/replace/{f=1}1' t > tt\n            awk '/replace$/{printf(\"%s\",$0);next}1' tt > tmp.plist\n            rm t tt\n            in=\"replace\"\n        ;;\n        * ) log \"Replacing $2\"; mv BuildManifest.plist tmp.plist;;\n    esac\n    #sed -i'' \"s,$in,$out,\" BuildManifest.plist\n    cat tmp.plist | sed \"s,$in,$out,\" > BuildManifest.plist\n    rm tmp.plist\n}\n\nipsw_bbreplace() {\n    local rsb1\n    local sbl1\n    local path\n    local rsb_latest\n    local sbl_latest\n    local bbfw=\"Print BuildIdentities:0:Manifest:BasebandFirmware\"\n    local ubid\n    if [[ $device_use_bb == 0 || $device_target_vers == \"$device_latest_vers\" ]] || (( device_proc < 5 )); then\n        return\n    fi\n\n    log \"Extracting BuildManifest from IPSW\"\n    unzip -o -j temp.ipsw BuildManifest.plist\n    mkdir Firmware 2>/dev/null\n    restore_download_bbsep\n    cp $restore_baseband Firmware/$device_use_bb\n\n    case $device_type in\n        iPhone4,1 ) ubid=\"d9Xbp0xyiFOxDvUcKMsoNjIvhwQ=\";;\n        iPhone5,1 ) ubid=\"IcrFKRzWDvccKDfkfMNPOPYHEV0=\";;\n        iPhone5,2 ) ubid=\"lnU0rtBUK6gCyXhEtHuwbEz/IKY=\";;\n        iPhone5,3 ) ubid=\"dwrol4czV3ijtNHh3w1lWIdsNdA=\";;\n        iPhone5,4 ) ubid=\"Z4ST0TczwAhpfluQFQNBg7Y3BVE=\";;\n        iPad2,6 ) ubid=\"L73HfN42pH7qAzlWmsEuIZZg2oE=\";;\n        iPad2,7 ) ubid=\"z/vJsvnUovZ+RGyXKSFB6DOjt1k=\";;\n        iPad3,5 ) ubid=\"849RPGQ9kNXGMztIQBhVoU/l5lM=\";;\n        iPad3,6 ) ubid=\"cO+N+Eo8ynFf+0rnsIWIQHTo6rg=\";;\n    esac\n    ipsw_bbdigest $ubid UniqueBuildID\n\n    case $device_type in\n        iPhone4,1 )\n            rsb1=$($PlistBuddy -c \"$bbfw:eDBL-Version\" BuildManifest.plist)\n            sbl1=$($PlistBuddy -c \"$bbfw:RestoreDBL-Version\" BuildManifest.plist)\n            path=$($PlistBuddy -c \"$bbfw:Info:Path\" BuildManifest.plist | tr -d '\"')\n            rsb_latest=\"-1577031936\"\n            sbl_latest=\"-1575983360\"\n            ipsw_bbdigest XAAAAADHAQCqerR8d+PvcfusucizfQ4ECBI0TA== RestoreDBL-PartialDigest\n            ipsw_bbdigest Q1TLjk+/PjayCzSJJo68FTtdhyE= AMSS-HashTableDigest\n            ipsw_bbdigest KkJI7ufv5tfNoqHcrU7gqoycmXA= OSBL-DownloadDigest\n            ipsw_bbdigest eAAAAADIAQDxcjzF1q5t+nvLBbvewn/arYVkLw== eDBL-PartialDigest\n            ipsw_bbdigest 3CHVk7EmtGjL14ApDND81cqFqhM= AMSS-DownloadDigest\n        ;;\n        iPhone5,[12] | iPad2,[67] | iPad3,[56] )\n            rsb1=$($PlistBuddy -c \"$bbfw:RestoreSBL1-Version\" BuildManifest.plist)\n            sbl1=$($PlistBuddy -c \"$bbfw:SBL1-Version\" BuildManifest.plist)\n            path=$($PlistBuddy -c \"$bbfw:Info:Path\" BuildManifest.plist | tr -d '\"')\n            rsb_latest=\"-1559114512\"\n            sbl_latest=\"-1560163088\"\n            ipsw_bbdigest 2bmJ7Vd+WAmogV+hjq1a86UlBvA= APPS-DownloadDigest\n            ipsw_bbdigest oNmIZf39zd94CPiiKOpKvhGJbyg= APPS-HashTableDigest\n            ipsw_bbdigest dFi5J+pSSqOfz31fIvmah2GJO+E= DSP1-DownloadDigest\n            ipsw_bbdigest HXUnmGmwIHbVLxkT1rHLm5V6iDM= DSP1-HashTableDigest\n            ipsw_bbdigest oA5eQ8OurrWrFpkUOhD/3sGR3y8= DSP2-DownloadDigest\n            ipsw_bbdigest L7v8ulq1z1Pr7STR47RsNbxmjf0= DSP2-HashTableDigest\n            ipsw_bbdigest MZ1ERfoeFcbe79pFAl/hbWUSYKc= DSP3-DownloadDigest\n            ipsw_bbdigest sKmLhQcjfaOliydm+iwxucr9DGw= DSP3-HashTableDigest\n            ipsw_bbdigest oiW/8qZhN0r9OaLdUHCT+MMGknY= RPM-DownloadDigest\n            ipsw_bbdigest fAAAAEAQAgAH58t5X9KETIPrycULi8dg7b2rSw== RestoreSBL1-PartialDigest\n            ipsw_bbdigest ZAAAAIC9AQAfgUcPMN/lMt+U8s6bxipdy6td6w== SBL1-PartialDigest\n            ipsw_bbdigest kHLoJsT9APu4Xwu/aRjNK10Hx84= SBL2-DownloadDigest\n        ;;\n        iPhone5,[34] )\n            rsb1=$($PlistBuddy -c \"$bbfw:RestoreSBL1-Version\" BuildManifest.plist)\n            sbl1=$($PlistBuddy -c \"$bbfw:SBL1-Version\" BuildManifest.plist)\n            path=$($PlistBuddy -c \"$bbfw:Info:Path\" BuildManifest.plist | tr -d '\"')\n            rsb_latest=\"-1542379296\"\n            sbl_latest=\"-1543427872\"\n            ipsw_bbdigest TSVi7eYY4FiAzXynDVik6TY2S1c= APPS-DownloadDigest\n            ipsw_bbdigest xd/JBOTxYJWmLkTWqLWl8GeINgU= APPS-HashTableDigest\n            ipsw_bbdigest RigCEz69gUymh2UdyJdwZVx74Ic= DSP1-DownloadDigest\n            ipsw_bbdigest a3XhREtzynTWtyQGqi/RXorXSVE= DSP1-HashTableDigest\n            ipsw_bbdigest 3JTgHWvC+XZYWa5U5MPvle+imj4= DSP2-DownloadDigest\n            ipsw_bbdigest Hvppb92/1o/cWQbl8ftoiW5jOLg= DSP2-HashTableDigest\n            ipsw_bbdigest R60ZfsOqZX+Pd/UnEaEhWfNvVlY= DSP3-DownloadDigest\n            ipsw_bbdigest DFQWkktFWNh90G2hOfwO14oEbrI= DSP3-HashTableDigest\n            ipsw_bbdigest Rsn+u2mOpYEmdrw98yA8EDT5LiE= RPM-DownloadDigest\n            ipsw_bbdigest cAAAAIC9AQBLeCHzsjHo8Q7+IzELZTV/ri/Vow== RestoreSBL1-PartialDigest\n            ipsw_bbdigest eAAAAEBsAQB9b44LqXjR3izAYl5gB4j3Iqegkg== SBL1-PartialDigest\n            ipsw_bbdigest iog3IVe+8VqgQzP2QspgFRUNwn8= SBL2-DownloadDigest\n        ;;\n    esac\n\n    log \"Replacing $rsb1 with $rsb_latest\"\n    #sed -i'' \"s,$rsb1,$rsb_latest,\" BuildManifest.plist\n    cat BuildManifest.plist | sed \"s,$rsb1,$rsb_latest,\" > t\n    log \"Replacing $sbl1 with $sbl_latest\"\n    #sed -i'' \"s,$sbl1,$sbl_latest,\" BuildManifest.plist\n    cat t | sed \"s,$sbl1,$sbl_latest,\" > tt\n    log \"Replacing $path with Firmware/$device_use_bb\"\n    #sed -i'' \"s,$path,Firmware/$device_use_bb,\" BuildManifest.plist\n    cat tt | sed \"s,$path,Firmware/$device_use_bb,\" > BuildManifest.plist\n    rm t tt\n\n    zip -r0 temp.ipsw Firmware/$device_use_bb BuildManifest.plist\n}\n\npatch_iboot() {\n    device_fw_key_check\n    local iboot_name=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"iBoot\") | .filename')\n    local iboot_iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"iBoot\") | .iv')\n    local iboot_key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"iBoot\") | .key')\n    if [[ -z $iboot_name ]]; then\n        error \"Issue with firmware keys: Failed getting iBoot. Check The Apple Wiki or your wikiproxy\"\n    fi\n    local rsa=\"--rsa\"\n    log \"Patch iBoot: $*\"\n    if [[ $1 == \"--logo\" ]]; then\n        iboot_name=\"${iboot_name/iBoot/iBoot2}\"\n        rsa=\n        unzip -o -j temp.ipsw $all_flash/$iboot_name\n    else\n        unzip -o -j \"$ipsw_path.ipsw\" $all_flash/$iboot_name\n    fi\n    mv $iboot_name iBoot.orig\n    \"$dir/xpwntool\" iBoot.orig iBoot.dec -iv $iboot_iv -k $iboot_key\n    \"$dir/iBoot32Patcher\" iBoot.dec iBoot.pwned $rsa \"$@\"\n    \"$dir/xpwntool\" iBoot.pwned iBoot -t iBoot.orig\n    if [[ $device_type == \"iPad1,1\" || $device_type == \"iPhone5\"* ]]; then\n        echo \"0000010: 6365\" | xxd -r - iBoot\n        echo \"0000020: 6365\" | xxd -r - iBoot\n        return\n    elif [[ $device_type != \"iPhone2,1\" ]]; then\n        echo \"0000010: 626F\" | xxd -r - iBoot\n        echo \"0000020: 626F\" | xxd -r - iBoot\n    fi\n    \"$dir/xpwntool\" iBoot.pwned $iboot_name -t iBoot -iv $iboot_iv -k $iboot_key\n}\n\nipsw_patch_file() {\n    # usage: ipsw_patch_file <ramdisk/fs> <location> <filename> <patchfile>\n    \"$dir/hfsplus\" \"$1\" extract \"$2\"/\"$3\"\n    \"$dir/hfsplus\" \"$1\" rm \"$2\"/\"$3\"\n    $bspatch \"$3\" \"$3\".patched \"$4\"\n    \"$dir/hfsplus\" \"$1\" add \"$3\".patched \"$2\"/\"$3\"\n    \"$dir/hfsplus\" \"$1\" chmod 755 \"$2\"/\"$3\"\n    \"$dir/hfsplus\" \"$1\" chown 0:0 \"$2\"/\"$3\"\n}\n\nipsw_prepare_ios4multipart() {\n    local JBFiles=()\n    ipsw_custom_part2=\"${device_type}_${device_target_vers}_${device_target_build}_CustomNP-${device_ecid}\"\n    local all_flash2=\"$ipsw_custom_part2/$all_flash\"\n    local iboot\n\n    if [[ -e \"../$ipsw_custom_part2.ipsw\" && -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSWs. Skipping IPSW creation.\"\n        return\n    elif [[ -e \"../$ipsw_custom_part2.ipsw\" || -e \"$ipsw_custom.ipsw\" ]]; then\n        rm \"../$ipsw_custom_part2.ipsw\" \"$ipsw_custom.ipsw\" 2>/dev/null\n    fi\n\n    log \"Preparing NOR flash IPSW...\"\n    mkdir -p $ipsw_custom_part2/Firmware/dfu $ipsw_custom_part2/Downgrade $all_flash2\n\n    local comps=(\"iBSS\" \"iBEC\" \"DeviceTree\" \"Kernelcache\" \"RestoreRamdisk\")\n    local name\n    local iv\n    local key\n    local path\n    local vers=\"5.1.1\"\n    local build=\"9B206\"\n    local saved_path=\"../saved/$device_type/$build\"\n    local url=\"$(cat $device_fw_dir/$build/url)\"\n    device_fw_key_check temp $build\n\n    mkdir -p $saved_path\n    log \"Getting $vers restore components\"\n    for getcomp in \"${comps[@]}\"; do\n        name=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n        iv=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        key=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        case $getcomp in\n            \"iBSS\" | \"iBEC\" ) path=\"Firmware/dfu/\";;\n            \"DeviceTree\" ) path=\"$all_flash/\";;\n            * ) path=\"\";;\n        esac\n        log \"$getcomp\"\n        if [[ $vers == \"$device_base_vers\" ]]; then\n            unzip -o -j \"$ipsw_base_path.ipsw\" ${path}$name\n        elif [[ -e $saved_path/$name ]]; then\n            cp $saved_path/$name .\n        else\n            \"$dir/pzb\" -g \"${path}$name\" -o \"$name\" \"$url\"\n            cp $name $saved_path/\n        fi\n        case $getcomp in\n            \"DeviceTree\" )\n                \"$dir/xpwntool\" $name $ipsw_custom_part2/Downgrade/RestoreDeviceTree -iv $iv -k $key -decrypt\n            ;;\n            \"Kernelcache\" )\n                \"$dir/xpwntool\" $name $ipsw_custom_part2/Downgrade/RestoreKernelCache -iv $iv -k $key -decrypt\n            ;;\n            * )\n                mv $name $getcomp.orig\n                \"$dir/xpwntool\" $getcomp.orig $getcomp.dec -iv $iv -k $key\n            ;;\n        esac\n    done\n\n    log \"Patch iBSS\"\n    \"$dir/iBoot32Patcher\" iBSS.dec iBSS.patched --rsa\n    \"$dir/xpwntool\" iBSS.patched $ipsw_custom_part2/Firmware/dfu/iBSS.${device_model}ap.RELEASE.dfu -t iBSS.orig\n\n    log \"Patch iBEC\"\n    \"$dir/iBoot32Patcher\" iBEC.dec iBEC.patched --rsa --ticket -b \"rd=md0 -v nand-enable-reformat=1 amfi=0xff cs_enforcement_disable=1\"\n    \"$dir/xpwntool\" iBEC.patched $ipsw_custom_part2/Firmware/dfu/iBEC.${device_model}ap.RELEASE.dfu -t iBEC.orig\n\n    log \"Manifest plist\"\n    if [[ $vers == \"$device_base_vers\" ]]; then\n        unzip -o -j \"$ipsw_base_path.ipsw\" BuildManifest.plist\n    elif [[ -e $saved_path/BuildManifest.plist ]]; then\n        cp $saved_path/BuildManifest.plist .\n    else\n        \"$dir/pzb\" -g \"${path}BuildManifest.plist\" -o \"BuildManifest.plist\" \"$url\"\n        cp BuildManifest.plist $saved_path/\n    fi\n    cp ../resources/patch/old/$device_type/$vers/* .\n    $PlistBuddy -c \"Set BuildIdentities:0:Manifest:RestoreDeviceTree:Info:Path Downgrade/RestoreDeviceTree\" BuildManifest.plist\n    $PlistBuddy -c \"Set BuildIdentities:0:Manifest:RestoreKernelCache:Info:Path Downgrade/RestoreKernelCache\" BuildManifest.plist\n    $PlistBuddy -c \"Set BuildIdentities:0:Manifest:RestoreLogo:Info:Path Downgrade/RestoreLogo\" BuildManifest.plist\n    cp BuildManifest.plist $ipsw_custom_part2/\n\n    log \"Restore Ramdisk\"\n    local ramdisk_name=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .filename')\n    mv RestoreRamdisk.dec ramdisk.dec\n    \"$dir/hfsplus\" ramdisk.dec grow 18000000\n\n    local rootfs_name=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"RootFS\") | .filename')\n    touch $ipsw_custom_part2/$rootfs_name\n    log \"Dummy RootFS: $rootfs_name\"\n\n    log \"Modify options.plist\"\n    local options_plist=\"options.$device_model.plist\"\n    echo '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>CreateFilesystemPartitions</key>\n    <false/>\n    <key>UpdateBaseband</key>\n    <false/>\n    <key>SystemImage</key>\n    <false/>\n</dict>\n</plist>' | tee $options_plist\n    \"$dir/hfsplus\" ramdisk.dec rm usr/local/share/restore/$options_plist\n    \"$dir/hfsplus\" ramdisk.dec add $options_plist usr/local/share/restore/$options_plist\n\n    log \"Patch ASR\"\n    ipsw_patch_file ramdisk.dec usr/sbin asr asr.patch\n\n    log \"Repack Restore Ramdisk\"\n    \"$dir/xpwntool\" ramdisk.dec $ipsw_custom_part2/$ramdisk_name -t RestoreRamdisk.orig\n\n    log \"Extract all_flash from $device_base_vers base\"\n    unzip -o -j \"$ipsw_base_path.ipsw\" Firmware/all_flash/\\* -d $all_flash2\n\n    log \"Add $device_target_vers DeviceTree to all_flash\"\n    rm $all_flash2/DeviceTree.${device_model}ap.img3\n    unzip -o -j \"$ipsw_path.ipsw\" $all_flash/DeviceTree.${device_model}ap.img3 -d $all_flash2\n\n    local ExtraArr=(\"--boot-partition\" \"--boot-ramdisk\" \"--logo4\")\n    case $device_target_vers in\n        4.2.9 | 4.2.10 ) :;;\n        * ) ExtraArr+=(\"--433\");;\n    esac\n    local bootargs=\"$device_bootargs_default\"\n    if [[ $ipsw_verbose == 1 ]]; then\n        bootargs=\"pio-error=0 -v\"\n    fi\n    ExtraArr+=(\"-b\" \"$bootargs\")\n    patch_iboot \"${ExtraArr[@]}\"\n\n    if [[ $device_type == \"iPad1,1\" && $device_target_vers == \"3\"* ]]; then\n        cp iBoot ../saved/iPad1,1/iBoot3_$device_ecid\n    elif [[ $device_type == \"iPad1,1\" ]]; then\n        cp iBoot iBEC\n        tar -cvf iBoot.tar iBEC\n        iboot=\"iboot\"\n    else\n        log \"Add $device_target_vers iBoot to all_flash\"\n        cp iBoot $all_flash2/iBoot2.img3\n        echo \"iBoot2.img3\" >> $all_flash2/manifest\n    fi\n\n    log \"Add APTicket to all_flash\"\n    cat \"$shsh_path\" | sed '64,$d' | sed -ne '/<data>/,/<\\/data>/p' | sed -e \"s/<data>//\" | sed \"s/<\\/data>//\" | tr -d '[:space:]' | base64 --decode > apticket.der\n    \"$dir/xpwntool\" apticket.der $all_flash2/applelogoT.img3 -t ../resources/firmware/src/scab_template.img3\n    echo \"applelogoT.img3\" >> $all_flash2/manifest\n\n    log \"AppleLogo\"\n    local logo_name=\"$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"AppleLogo\") | .filename')\"\n    if [[ -n $ipsw_customlogo ]]; then\n        ipsw_prepare_logos_convert\n        mv $all_flash/$logoname $logo_name\n    else\n        unzip -o -j \"$ipsw_path.ipsw\" $all_flash/$logo_name\n        echo \"0000010: 3467\" | xxd -r - $logo_name\n        echo \"0000020: 3467\" | xxd -r - $logo_name\n    fi\n    log \"Add AppleLogo to all_flash\"\n    if [[ $device_latest_vers == \"5\"* ]]; then\n        mv $logo_name $all_flash2/applelogo4.img3\n        echo \"applelogo4.img3\" >> $all_flash2/manifest\n    else\n        sed '/applelogo/d' $all_flash2/manifest > manifest\n        rm $all_flash2/manifest\n        echo \"$logo_name\" >> manifest\n        mv $logo_name manifest $all_flash2/\n    fi\n\n    log \"Creating $ipsw_custom_part2.ipsw...\"\n    pushd $ipsw_custom_part2 >/dev/null\n    zip -r0 ../../$ipsw_custom_part2.ipsw *\n    popd >/dev/null\n\n    if [[ $ipsw_skip_first == 1 ]]; then\n        return\n    fi\n\n    # ------ part 2 (nor flash) ends here. start creating part 1 ipsw ------\n    case $device_target_vers in\n        4.2* ) ipsw_prepare_32bit $iboot;;\n        *    ) ipsw_prepare_jailbreak $iboot;;\n    esac\n\n    ipsw_prepare_ios4multipart_patch=1\n    ipsw_prepare_multipatch\n}\n\nipsw_prepare_multipatch() {\n    local vers\n    local build\n    local options_plist\n    local saved_path\n    local url\n    local ramdisk_name\n    local name\n    local iv\n    local key\n    local comps=(\"iBSS\" \"iBEC\" \"DeviceTree\" \"Kernelcache\" \"RestoreRamdisk\")\n    local use_ticket=1\n\n    log \"Starting multipatch\"\n    mv \"$ipsw_custom.ipsw\" temp.ipsw\n    rm asr* iBSS* iBEC* ramdisk* *.dmg 2>/dev/null\n    options_plist=\"options.$device_model.plist\"\n    if [[ $device_type == \"iPad1,1\" && $device_target_vers == \"4\"* ]]; then\n        use_ticket=\n    elif [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]]; then\n        options_plist=\"options.plist\"\n        use_ticket=\n    fi\n\n    vers=\"4.2.1\"\n    build=\"8C148\"\n    if [[ $ipsw_isbeta == 1 ]]; then\n        :\n    elif [[ $device_type == \"iPad1,1\" || $device_type == \"iPhone3,3\" ]] ||\n         [[ $device_type == \"iPod3,1\" && $device_target_vers == \"3\"* ]]; then\n        vers=\"$device_target_vers\"\n        build=\"$device_target_build\"\n    fi\n    case $device_target_vers in\n        4.3* ) vers=\"4.3.5\"; build=\"8L1\";;\n        5.0* ) vers=\"5.0.1\"; build=\"9A405\";;\n        5.1* ) vers=\"5.1.1\"; build=\"9B206\";;\n        6* ) vers=\"6.1.3\"; build=\"10B329\";;\n    esac\n    if [[ $ipsw_gasgauge_patch == 1 ]]; then\n        local ver2=\"${device_target_vers:0:1}\"\n        if (( ver2 >= 7 )); then\n            vers=\"6.1.3\"\n            build=\"10B329\"\n        fi\n    else\n        case $device_target_vers in\n            7* ) vers=\"7.1.2\"; build=\"11D257\";;\n            8* ) vers=\"8.4.1\"; build=\"12H321\";;\n            9* ) vers=\"9.3.5\"; build=\"13G36\";;\n        esac\n    fi\n    saved_path=\"../saved/$device_type/$build\"\n    ipsw_get_url $build\n    url=\"$ipsw_url\"\n    device_fw_key_check\n    ramdisk_name=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .filename')\n    rootfs_name=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"RootFS\") | .filename')\n    if [[ -z $ramdisk_name ]]; then\n        error \"Issue with firmware keys: Failed getting RestoreRamdisk. Check The Apple Wiki or your wikiproxy\"\n    fi\n\n    mkdir -p $saved_path Downgrade Firmware/dfu 2>/dev/null\n    device_fw_key_check temp $build\n    log \"Getting $vers restore components\"\n    for getcomp in \"${comps[@]}\"; do\n        name=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n        iv=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        key=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        case $getcomp in\n            \"iBSS\" | \"iBEC\" ) path=\"Firmware/dfu/\";;\n            \"DeviceTree\" ) path=\"$all_flash/\";;\n            * ) path=\"\";;\n        esac\n        log \"$getcomp\"\n        if [[ $vers == \"$device_target_vers\" ]]; then\n            unzip -o -j \"$ipsw_path.ipsw\" ${path}$name\n        elif [[ -e $saved_path/$name ]]; then\n            cp $saved_path/$name .\n        else\n            \"$dir/pzb\" -g \"${path}$name\" -o \"$name\" \"$url\"\n            cp $name $saved_path/\n        fi\n        case $getcomp in\n            \"DeviceTree\" )\n                \"$dir/xpwntool\" $name Downgrade/RestoreDeviceTree -iv $iv -k $key -decrypt\n                zip -r0 temp.ipsw Downgrade/RestoreDeviceTree\n            ;;\n            \"Kernelcache\" )\n                \"$dir/xpwntool\" $name Downgrade/RestoreKernelCache -iv $iv -k $key -decrypt\n                zip -r0 temp.ipsw Downgrade/RestoreKernelCache\n            ;;\n            * )\n                mv $name $getcomp.orig\n                \"$dir/xpwntool\" $getcomp.orig $getcomp.dec -iv $iv -k $key\n            ;;\n        esac\n        if [[ $getcomp == \"iB\"* ]]; then\n            local ticket=\n            if [[ $getcomp == \"iBEC\" && $use_ticket == 1 ]]; then\n                ticket=\"--ticket\"\n            fi\n            log \"Patch $getcomp\"\n            \"$dir/iBoot32Patcher\" $getcomp.dec $getcomp.patched --rsa --debug $ticket -b \"rd=md0 -v nand-enable-reformat=1 amfi=0xff amfi_get_out_of_my_way=1 cs_enforcement_disable=1 pio-error=0\"\n            \"$dir/xpwntool\" $getcomp.patched ${path}$name -t $getcomp.orig\n            cp ${path}$name ${path}$getcomp.$device_model.RELEASE.dfu 2>/dev/null\n            zip -r0 temp.ipsw ${path}$name ${path}$getcomp.$device_model.RELEASE.dfu\n        fi\n    done\n\n    log \"Extracting ramdisk from IPSW\"\n    unzip -o -j temp.ipsw $ramdisk_name\n    mv $ramdisk_name ramdisk2.orig\n    \"$dir/xpwntool\" ramdisk2.orig ramdisk2.dec\n\n    log \"Checking\"\n    \"$dir/hfsplus\" ramdisk2.dec extract multipatched\n    if [[ -s multipatched ]]; then\n        log \"Already multipatched\"\n        mv temp.ipsw \"$ipsw_custom.ipsw\"\n        return\n    fi\n\n    log \"Grow ramdisk\"\n    \"$dir/hfsplus\" RestoreRamdisk.dec grow 30000000\n\n    log \"Patch ASR\"\n    if [[ $ipsw_prepare_usepowder == 1 && $ipsw_gasgauge_patch != 1 ]]; then\n        rm -f asr\n        \"$dir/hfsplus\" ramdisk2.dec extract usr/sbin/asr\n        \"$dir/hfsplus\" RestoreRamdisk.dec rm usr/sbin/asr\n        \"$dir/hfsplus\" RestoreRamdisk.dec add asr usr/sbin/asr\n        \"$dir/hfsplus\" RestoreRamdisk.dec chmod 755 usr/sbin/asr\n        \"$dir/hfsplus\" RestoreRamdisk.dec chown 0:0 usr/sbin/asr\n    else\n        cp ../resources/firmware/FirmwareBundles/Down_${device_type}_${vers}_${build}.bundle/asr.patch .\n        ipsw_patch_file RestoreRamdisk.dec usr/sbin asr asr.patch\n    fi\n\n    if [[ $device_target_vers == \"3.2\"* ]]; then\n        log \"3.2 options.plist\"\n        cp ../resources/firmware/src/target/k48/options.plist $options_plist\n    else\n        log \"Extract options.plist from $device_target_vers IPSW\"\n        \"$dir/hfsplus\" ramdisk2.dec extract usr/local/share/restore/$options_plist\n    fi\n\n    log \"Modify options.plist\"\n    \"$dir/hfsplus\" RestoreRamdisk.dec rm usr/local/share/restore/$options_plist\n    if [[ $ipsw_prepare_ios4multipart_patch == 1 || $device_target_tethered == 1 ]]; then\n        cat $options_plist | sed '$d' | sed '$d' > options2.plist\n        printf \"<key>FlashNOR</key><false/></dict>\\n</plist>\\n\" >> options2.plist\n        cat options2.plist\n        \"$dir/hfsplus\" RestoreRamdisk.dec add options2.plist usr/local/share/restore/$options_plist\n    else\n        \"$dir/hfsplus\" RestoreRamdisk.dec add $options_plist usr/local/share/restore/$options_plist\n    fi\n    if [[ $device_target_vers == \"3\"* ]]; then\n        :\n    elif [[ $device_target_powder == 1 && $device_target_vers == \"4\"* ]]; then\n        log \"Adding exploit and partition stuff\"\n        cp -R ../resources/firmware/src .\n        \"$dir/hfsplus\" RestoreRamdisk.dec untar src/bin4.tar\n        \"$dir/hfsplus\" RestoreRamdisk.dec mv sbin/reboot sbin/reboot_\n        \"$dir/hfsplus\" RestoreRamdisk.dec add src/target/$device_model/reboot4 sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec chmod 755 sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec chown 0:0 sbin/reboot\n    elif [[ $device_target_powder == 1 ]]; then\n        local hw=\"$device_model\"\n        local base_build=\"11D257\"\n        case $device_type in\n            iPhone5,[12] ) hw=\"iphone5\";;\n            iPhone5,[34] ) hw=\"iphone5b\";;\n            iPad3,[456] )  hw=\"ipad3b\";;\n        esac\n        case $device_base_build in\n            \"11A\"* | \"11B\"* ) base_build=\"11B554a\";;\n            \"9\"* ) base_build=\"9B206\";;\n        esac\n        local exploit=\"src/target/$hw/$base_build/exploit\"\n        local partition=\"src/target/$hw/$base_build/partition\"\n        log \"Adding exploit and partition stuff\"\n        \"$dir/hfsplus\" RestoreRamdisk.dec untar src/bin.tar\n        \"$dir/hfsplus\" RestoreRamdisk.dec mv sbin/reboot sbin/reboot_\n        \"$dir/hfsplus\" RestoreRamdisk.dec add $partition sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec chmod 755 sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec chown 0:0 sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec add $exploit exploit\n    elif [[ $ipsw_jailbreak == 1 && $device_target_vers == \"8\"* && $ipsw_everuntether != 1 ]]; then\n        # daibutsu haxx overwrite\n        \"$dir/hfsplus\" RestoreRamdisk.dec untar bin.tar\n        \"$dir/hfsplus\" RestoreRamdisk.dec mv sbin/reboot sbin/reboot_\n        \"$dir/hfsplus\" RestoreRamdisk.dec add reboot.sh sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec chmod 755 sbin/reboot\n        \"$dir/hfsplus\" RestoreRamdisk.dec chown 0:0 sbin/reboot\n    fi\n\n    echo \"multipatched\" > multipatched\n    \"$dir/hfsplus\" RestoreRamdisk.dec add multipatched multipatched\n\n    log \"Repack Restore Ramdisk\"\n    \"$dir/xpwntool\" RestoreRamdisk.dec $ramdisk_name -t RestoreRamdisk.orig\n    log \"Add Restore Ramdisk to IPSW\"\n    zip -r0 temp.ipsw $ramdisk_name\n\n    # 3.2 fs workaround\n    if [[ $device_target_vers == \"3.2\"* ]]; then\n        local ipsw_name=\"${device_type}_${device_target_vers}_${device_target_build}_FS\"\n        ipsw_url=\"https://github.com/LukeZGD/Legacy-iOS-Kit-Keys/releases/download/jailbreak/iPad1.1_${device_target_vers}_${device_target_build}_FS.ipsw\"\n        local sha1E=\"123d8717b1accbf43c03d2fbd6e82aa5ca3533c9\"\n        if [[ $device_target_vers == \"3.2.1\" ]]; then\n            sha1E=\"e1b2652aee400115b0b83c97628f90c3953e7eaf\"\n        elif [[ $device_target_vers == \"3.2\" ]]; then\n            sha1E=\"5763a6f9d5ead3675535c6f7037192e8611206bc\"\n        fi\n        if [[ ! -s ../$ipsw_name.ipsw ]]; then\n            log \"Downloading FS IPSW...\"\n            curl -L \"$ipsw_url\" -o temp2.ipsw\n            log \"Getting SHA1 hash for FS IPSW...\"\n            local sha1L=$($sha1sum temp2.ipsw | awk '{print $1}')\n            if [[ $sha1L != \"$sha1E\" ]]; then\n                error \"Verifying IPSW failed. The IPSW may be corrupted or incomplete. Please run the script again\" \\\n                \"* SHA1sum mismatch. Expected $sha1E, got $sha1L\"\n            fi\n            mv temp2.ipsw ../$ipsw_name.ipsw\n        fi\n        log \"Extract RootFS from FS IPSW\"\n        unzip -o -j ../$ipsw_name.ipsw $rootfs_name\n        log \"Add RootFS to IPSW\"\n        zip -r0 temp.ipsw $rootfs_name\n    fi\n\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_prepare_tethered() {\n    local name\n    local iv\n    local key\n    local options_plist=\"options.$device_model.plist\"\n    if [[ $device_type == \"iPad1,1\" && $device_target_vers == \"4\"* ]]; then\n        :\n    elif [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]]; then\n        options_plist=\"options.plist\"\n    fi\n\n    if [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    fi\n\n    ipsw_prepare_32bit\n\n    log \"Extract RestoreRamdisk and options.plist\"\n    device_fw_key_check temp $device_target_build\n    name=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .filename')\n    iv=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .iv')\n    key=$(echo $device_fw_key_temp | $jq -j '.keys[] | select(.image == \"RestoreRamdisk\") | .key')\n    mv \"$ipsw_custom.ipsw\" temp.ipsw\n    unzip -o -j temp.ipsw $name\n    mv $name ramdisk.orig\n    \"$dir/xpwntool\" ramdisk.orig ramdisk.dec -iv $iv -k $key\n    \"$dir/hfsplus\" ramdisk.dec extract usr/local/share/restore/$options_plist\n\n    log \"Modify options.plist\"\n    \"$dir/hfsplus\" ramdisk.dec rm usr/local/share/restore/$options_plist\n    cat $options_plist | sed '$d' | sed '$d' > options2.plist\n    printf \"<key>FlashNOR</key><false/></dict>\\n</plist>\\n\" >> options2.plist\n    cat options2.plist\n    \"$dir/hfsplus\" ramdisk.dec add options2.plist usr/local/share/restore/$options_plist\n\n    log \"Repack Restore Ramdisk\"\n    \"$dir/xpwntool\" ramdisk.dec $name -t ramdisk.orig\n    log \"Add Restore Ramdisk to IPSW\"\n    zip -r0 temp.ipsw $name\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_prepare_ios4patches() {\n    local comps=(\"iBSS\" \"iBEC\")\n    local iv\n    local key\n    local name\n    local path=\"Firmware/dfu/\"\n    log \"Applying iOS 4 patches\"\n    mkdir -p $all_flash $path\n    for getcomp in \"${comps[@]}\"; do\n        iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        name=\"$getcomp.${device_model}ap.RELEASE.dfu\"\n        log \"Patch $getcomp\"\n        unzip -o -j \"$ipsw_path.ipsw\" ${path}$name\n        mv $name $getcomp.orig\n        \"$dir/xpwntool\" $getcomp.orig $getcomp.dec -iv $iv -k $key\n        \"$dir/iBoot32Patcher\" $getcomp.dec $getcomp.patched --rsa --debug -b \"rd=md0 -v amfi=0xff cs_enforcement_disable=1 pio-error=0\"\n        \"$dir/xpwntool\" $getcomp.patched ${path}$name -t $getcomp.orig\n    done\n}\n\nipsw_prepare_ios4powder() {\n    local ExtraArgs=\"-apticket $shsh_path\"\n    local JBFiles=()\n    ipsw_prepare_usepowder=1\n\n    if [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    fi\n\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        JBFiles=(\"g1lbertJB/${device_type}_${device_target_build}.tar\" \"fstab_old.tar\" \"freeze.tar\" \"cydiasubstrate.tar\")\n        for i in {0..3}; do\n            JBFiles[i]=$jelbrek/${JBFiles[$i]}\n        done\n        if [[ $ipsw_openssh == 1 ]]; then\n            JBFiles+=(\"$jelbrek/sshdeb.tar\")\n        fi\n        cp $jelbrek/freeze.tar .\n    fi\n\n    ipsw_prepare_bundle target\n    ipsw_prepare_bundle base\n    ipsw_prepare_logos_convert\n    cp -R ../resources/firmware/src .\n    rm src/target/$device_model/$device_base_build/partition\n    mv src/target/$device_model/reboot4 src/target/$device_model/$device_base_build/partition\n    rm src/bin.tar\n    mv src/bin4.tar src/bin.tar\n    ipsw_prepare_config false true\n    if [[ $ipsw_memory == 1 ]]; then\n        ExtraArgs+=\" -memory\"\n    fi\n    if [[ $device_actrec == 1 ]]; then\n        device_dump activation\n        ExtraArgs+=\" ../saved/$device_type/activation-$device_ecid.tar\"\n    fi\n\n    local ExtraArr=(\"--boot-partition\" \"--boot-ramdisk\" \"--logo4\")\n    case $device_target_vers in\n        4.3.[45] ) :;;\n        * ) ExtraArr+=(\"--433\");;\n    esac\n    local bootargs=\"$device_bootargs_default\"\n    if [[ $ipsw_verbose == 1 ]]; then\n        bootargs=\"pio-error=0 -v\"\n    fi\n    ExtraArr+=(\"-b\" \"$bootargs\")\n    patch_iboot \"${ExtraArr[@]}\"\n\n    tar -rvf src/bin.tar iBoot\n    if [[ $device_type == \"iPad1,1\" ]]; then\n        cp iBoot iBEC\n        tar -cvf iBoot.tar iBEC\n        ExtraArgs+=\" iBoot.tar\"\n    fi\n    if [[ $ipsw_isbeta == 1 ]]; then\n        ipsw_prepare_systemversion\n        ExtraArgs+=\" systemversion.tar\"\n    fi\n\n    log \"Preparing custom IPSW: $dir/powdersn0w $ipsw_path.ipsw temp.ipsw -base $ipsw_base_path.ipsw $ExtraArgs ${JBFiles[*]}\"\n    \"$dir/powdersn0w\" \"$ipsw_path.ipsw\" temp.ipsw -base \"$ipsw_base_path.ipsw\" $ExtraArgs ${JBFiles[@]}\n\n    if [[ ! -e temp.ipsw ]]; then\n        error \"Failed to find custom IPSW. Please run the script again\" \\\n        \"* You may try selecting N for memory option\"\n    fi\n\n    ipsw_prepare_ios4patches\n    if [[ -n $ipsw_customlogo ]]; then\n        ipsw_prepare_logos_add\n    else\n        log \"Patch AppleLogo\"\n        local applelogo_name=$(echo \"$device_fw_key\" | $jq -j '.keys[] | select(.image == \"AppleLogo\") | .filename')\n        unzip -o -j temp.ipsw $all_flash/$applelogo_name\n        echo \"0000010: 3467\" | xxd -r - $applelogo_name\n        echo \"0000020: 3467\" | xxd -r - $applelogo_name\n        mv $applelogo_name $all_flash/$applelogo_name\n    fi\n\n    log \"Add all to custom IPSW\"\n    if [[ $device_type != \"iPad1,1\" ]]; then\n        cp iBoot $all_flash/iBoot2.${device_model}ap.RELEASE.img3\n    fi\n    zip -r0 temp.ipsw $all_flash/* Firmware/dfu/* $ramdisk_name\n\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_prepare_powder() {\n    local ExtraArgs\n    if [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    fi\n    ipsw_prepare_usepowder=1\n\n    ipsw_prepare_bundle target\n    ipsw_prepare_bundle base\n    ipsw_prepare_logos_convert\n    cp -R ../resources/firmware/src .\n    if [[ $ipsw_memory == 1 ]]; then\n        ExtraArgs+=\" -memory\"\n    fi\n    if [[ $device_use_bb != 0 && $device_type != \"$device_disable_bbupdate\" ]]; then\n        ExtraArgs+=\" -bbupdate\"\n    elif [[ $device_type == \"$device_disable_bbupdate\" && $device_deadbb != 1 ]]; then\n        device_dump baseband\n        ExtraArgs+=\" ../saved/$device_type/baseband-$device_ecid.tar\"\n    fi\n    if [[ $device_actrec == 1 ]]; then\n        device_dump activation\n        ExtraArgs+=\" ../saved/$device_type/activation-$device_ecid.tar\"\n    fi\n\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        cp $jelbrek/freeze.tar .\n        case $device_target_vers in\n            5*   ) ExtraArgs+=\" $jelbrek/cydiasubstrate.tar $jelbrek/g1lbertJB.tar $jelbrek/g1lbertJB/${device_type}_${device_target_build}.tar\";;\n            7.0* ) ExtraArgs+=\" $jelbrek/evasi0n7-untether.tar $jelbrek/fstab7.tar\";;\n            7.1* )\n                ExtraArgs+=\" $jelbrek/fstab7.tar\"\n                case $device_type in\n                    iPod* ) ExtraArgs+=\" panguaxe-ipod.tar\";;\n                    *     ) ExtraArgs+=\" panguaxe.tar\";;\n                esac\n            ;;\n        esac\n        case $device_target_vers in\n            [689]* ) :;;\n            * ) ExtraArgs+=\" freeze.tar\";;\n        esac\n        if [[ $ipsw_openssh == 1 ]]; then\n            ExtraArgs+=\" $jelbrek/sshdeb.tar\"\n        fi\n    fi\n\n    local ExtraArr=(\"--boot-partition\" \"--boot-ramdisk\")\n    local bootargs=\"$device_bootargs_default\"\n    if [[ $ipsw_verbose == 1 ]]; then\n        bootargs=\"pio-error=0 -v\"\n    fi\n    case $device_target_vers in\n        [789]* ) :;;\n        * ) ExtraArr+=(\"--logo\");;\n    esac\n    if [[ $device_type == \"iPhone5,3\" || $device_type == \"iPhone5,4\" ]] && [[ $device_base_vers == \"7.0\"* ]]; then\n        ipsw_powder_5c70=1\n    fi\n    if [[ $device_type == \"iPhone5\"* && $ipsw_powder_5c70 != 1 ]]; then\n        # do this stuff because these use ramdiskH (jump to /boot/iBEC) instead of ramdiskI (jump ibot to ibob)\n        if [[ $device_target_vers == \"9\"* ]]; then\n            ExtraArr[0]+=\"9\"\n        fi\n        if [[ $ipsw_jailbreak == 1 && $device_target_vers != \"7\"* ]]; then\n            bootargs+=\" cs_enforcement_disable=1 amfi_get_out_of_my_way=1 amfi=0xff\"\n        fi\n        ExtraArr+=(\"-b\" \"$bootargs\")\n        patch_iboot \"${ExtraArr[@]}\"\n        tar -cvf iBoot.tar iBoot\n        ExtraArgs+=\" iBoot.tar\"\n    elif [[ $device_type == \"iPad1,1\" ]]; then\n        # ipad 1 ramdiskH jumps to /iBEC instead\n        ExtraArr+=(\"-b\" \"$bootargs\")\n        patch_iboot \"${ExtraArr[@]}\"\n        mv iBoot iBEC\n        tar -cvf iBoot.tar iBEC\n        ExtraArgs+=\" iBoot.tar\"\n    fi\n    if [[ $ipsw_isbeta == 1 ]]; then\n        ipsw_prepare_systemversion\n        ExtraArgs+=\" systemversion.tar\"\n    fi\n\n    log \"Preparing custom IPSW: $dir/powdersn0w $ipsw_path.ipsw temp.ipsw -base $ipsw_base_path.ipsw $ExtraArgs\"\n    \"$dir/powdersn0w\" \"$ipsw_path.ipsw\" temp.ipsw -base \"$ipsw_base_path.ipsw\" $ExtraArgs\n\n    if [[ ! -e temp.ipsw ]]; then\n        error \"Failed to find custom IPSW. Please run the script again\" \\\n        \"* You may try selecting N for memory option\"\n    fi\n\n    if [[ $device_type != \"iPhone5\"* && $device_type != \"iPad1,1\" ]] || [[ $ipsw_powder_5c70 == 1 ]]; then\n        case $device_target_vers in\n            [789]* ) :;;\n            * )\n                patch_iboot --logo\n                mkdir -p $all_flash\n                mv iBoot*.img3 $all_flash\n                zip -r0 temp.ipsw $all_flash/iBoot*.img3\n            ;;\n        esac\n    fi\n    ipsw_prepare_logos_add\n    ipsw_bbreplace\n\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_prepare_patchcomp() {\n    local path=\"$all_flash/\"\n    local name=\"LLB.${device_model}ap.RELEASE\"\n    local name41\n    local ext=\"img3\"\n    local patch\n    local iv\n    local key\n\n    if [[ $1 == \"Kernelcache\" ]]; then\n        path=\n        name=\"kernelcache.release\"\n        ext=\"s5l8900x\"\n        patch=\"../resources/patch/$name.$ext.p2\"\n        log \"Patch $1\"\n        unzip -o -j temp.ipsw $name.$ext\n        mv $name.$ext kc.orig\n        $bspatch kc.orig $name.$ext $patch.patch\n        zip -r0 temp.ipsw $name.$ext\n        return\n    fi\n\n    if [[ $1 == \"WTF2\" ]]; then\n        path=\"Firmware/dfu/\"\n        name=\"WTF.s5l8900xall.RELEASE\"\n        ext=\"dfu\"\n    elif [[ $1 == \"iBoot\" ]]; then\n        name=\"iBoot.${device_model}ap.RELEASE\"\n    elif [[ $1 == \"iB\"* ]]; then\n        path=\"Firmware/dfu/\"\n        name=\"$1.${device_model}ap.RELEASE\"\n        ext=\"dfu\"\n    elif [[ $1 == \"RestoreRamdisk\" ]]; then\n        path=\n        name=\"018-6494-014\"\n        ext=\"dmg\"\n        iv=25e713dd5663badebe046d0ffa164fee\n        key=7029389c2dadaaa1d1e51bf579493824\n        if [[ $device_target_vers == \"4\"* ]]; then\n            name=\"018-7079-079\"\n            iv=a0fc6ca4ef7ef305d975e7f881ddcc7f\n            key=18eab1ba646ae018b013bc959001fbde\n            if [[ $device_target_vers == \"4.2.1\" ]]; then\n                name41=\"$name\"\n                name=\"038-0029-002\"\n            fi\n        fi\n    elif [[ $1 == \"RestoreDeviceTree\" ]]; then\n        name=\"DeviceTree.${device_model}ap\"\n    elif [[ $1 == \"RestoreKernelCache\" ]]; then\n        path=\n        name=\"kernelcache.release\"\n        ext=\"$device_model\"\n    fi\n    patch=\"../resources/firmware/FirmwareBundles/Down_${device_type}_${device_target_vers}_${device_target_build}.bundle/$name.patch\"\n    local saved_path=\"../saved/$device_type/8B117\"\n    if [[ $1 == \"RestoreRamdisk\" ]]; then\n        local ivkey\n        if [[ $device_target_vers == \"4\"* || $device_type == *\"1,1\" ]]; then\n            ivkey=\"-iv $iv -k $key\"\n        fi\n        log \"Patch $1\"\n        if [[ $device_target_vers == \"4.2.1\" ]]; then\n            mkdir -p $saved_path 2>/dev/null\n            if [[ -s $saved_path/$name41.$ext ]]; then\n                cp $saved_path/$name41.$ext $name.$ext\n            else\n                ipsw_get_url 8B117\n                \"$dir/pzb\" -g $name41.$ext -o $name.$ext \"$ipsw_url\"\n                cp $name.$ext $saved_path/$name41.$ext\n            fi\n        else\n            unzip -o -j \"$ipsw_path.ipsw\" $name.$ext\n        fi\n        mv $name.$ext rd.orig\n        \"$dir/xpwntool\" rd.orig rd.dec -iv $iv -k $key\n        $bspatch rd.dec rd.patched \"$patch\"\n        \"$dir/xpwntool\" rd.patched $name.$ext -t rd.orig $ivkey\n        zip -r0 temp.ipsw $name.$ext\n        return\n    fi\n    log \"Patch $1\"\n    if [[ $device_target_vers == \"4.2.1\" ]] && [[ $1 == \"RestoreDeviceTree\" || $1 == \"RestoreKernelCache\" ]]; then\n        mkdir -p $saved_path 2>/dev/null\n        if [[ -s $saved_path/$name.$ext ]]; then\n            cp $saved_path/$name.$ext $name.$ext\n        else\n            ipsw_get_url 8B117\n            \"$dir/pzb\" -g ${path}$name.$ext -o $name.$ext \"$ipsw_url\"\n            cp $name.$ext $saved_path/$name.$ext\n        fi\n        mkdir Downgrade 2>/dev/null\n        if [[ $1 == \"RestoreKernelCache\" ]]; then\n            local ivkey=\"-iv 7238dcea75bf213eff209825a03add51 -k 0295d4ef87b9db687b44f54c8585d2b6\"\n            \"$dir/xpwntool\" $name.$ext kernelcache $ivkey\n            $bspatch kernelcache kc.patched ../resources/patch/$name.$ext.patch\n            \"$dir/xpwntool\" kc.patched Downgrade/$1 -t $name.$ext $ivkey\n        else\n            mv $name.$ext Downgrade/$1\n        fi\n        zip -r0 temp.ipsw Downgrade/$1\n        return\n    else\n        unzip -o -j \"$ipsw_path.ipsw\" ${path}$name.$ext\n    fi\n    $bspatch $name.$ext $name.patched $patch\n    mkdir -p $path\n    mv $name.patched ${path}$name.$ext\n    zip -r0 temp.ipsw ${path}$name.$ext\n}\n\nipsw_prepare_s5l8900() {\n    local rname=\"018-6494-014.dmg\"\n    local sha1E=\"4f6539d2032a1c7e1a068c667e393e62d8912700\"\n    local sha1L\n    ipsw_url=\"https://github.com/LukeZGD/Legacy-iOS-Kit-Keys/releases/download/jailbreak/\"\n    if [[ $device_target_vers == \"4.1\" ]]; then\n        rname=\"018-7079-079.dmg\"\n        sha1E=\"9a64eea9949b720f1033d41adc85254e6dbf9525\"\n    elif [[ $device_target_vers == \"4.2.1\" ]]; then\n        rname=\"038-0029-002.dmg\"\n        sha1E=\"9a64eea9949b720f1033d41adc85254e6dbf9525\"\n    elif [[ $device_type == \"iPhone1,1\" && $ipsw_hacktivate == 1 ]]; then\n        ipsw_url+=\"iPhone1.1_3.1.3_7E18_Custom_Hacktivate.ipsw\"\n        sha1E=\"3def867e6e386a044ec3bad58dda05a45f6405b8\"\n    elif [[ $device_type == \"iPhone1,1\" ]]; then\n        ipsw_url+=\"iPhone1.1_3.1.3_7E18_Custom.ipsw\"\n        sha1E=\"617020bbae1579d1ee34267fab85bf8dd29fedda\"\n    elif [[ $device_type == \"iPod1,1\" ]]; then\n        ipsw_url+=\"iPod1.1_3.1.3_7E18_Custom.ipsw\"\n        sha1E=\"bf61225e8da8cc35b03a9ca898f830d3066be2f6\"\n    fi\n\n    if [[ $device_type == \"iPhone1,2\" && -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Checking RestoreRamdisk hash of custom IPSW\"\n        unzip -o -j \"$ipsw_custom.ipsw\" $rname\n        sha1L=\"$($sha1sum $rname | awk '{print $1}')\"\n    elif [[ -e \"$ipsw_custom2.ipsw\" ]]; then\n        log \"Getting SHA1 hash for $ipsw_custom2.ipsw...\"\n        sha1L=$($sha1sum \"$ipsw_custom2.ipsw\" | awk '{print $1}')\n    fi\n    if [[ $sha1L == \"$sha1E\" && $ipsw_customlogo2 == 1 ]]; then\n        log \"Verified existing Custom IPSW. Preparing custom logo images and IPSW\"\n        rm -f \"$ipsw_custom.ipsw\"\n        cp \"$ipsw_custom2.ipsw\" temp.ipsw\n        device_fw_key_check\n        ipsw_prepare_logos_convert\n        ipsw_prepare_logos_add\n        mv temp.ipsw \"$ipsw_custom.ipsw\"\n        return\n    elif [[ $sha1L == \"$sha1E\" ]]; then\n        log \"Verified existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    else\n        log \"Verifying IPSW failed. Expected $sha1E, got $sha1L\"\n    fi\n\n    if [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Deleting existing custom IPSW\"\n        rm \"$ipsw_custom.ipsw\"\n    fi\n\n    if [[ $device_type != \"iPhone1,2\" ]]; then\n        log \"Downloading IPSW: $ipsw_url\"\n        curl -L \"$ipsw_url\" -o temp.ipsw\n        log \"Getting SHA1 hash for IPSW...\"\n        sha1L=$($sha1sum temp.ipsw | awk '{print $1}')\n        if [[ $sha1L != \"$sha1E\" ]]; then\n            error \"Verifying IPSW failed. The IPSW may be corrupted or incomplete. Please run the script again\" \\\n            \"* SHA1sum mismatch. Expected $sha1E, got $sha1L\"\n        fi\n        if [[ $ipsw_customlogo2 == 1 ]]; then\n            cp temp.ipsw \"$ipsw_custom2.ipsw\"\n            device_fw_key_check\n            ipsw_prepare_logos_convert\n            ipsw_prepare_logos_add\n        fi\n        mv temp.ipsw \"$ipsw_custom.ipsw\"\n        return\n    fi\n\n    ipsw_prepare_jailbreak old\n\n    mv \"$ipsw_custom.ipsw\" temp.ipsw\n    ipsw_prepare_patchcomp LLB\n    ipsw_prepare_patchcomp iBoot\n    ipsw_prepare_patchcomp RestoreRamdisk\n    if [[ $device_target_vers == \"4\"* ]]; then\n        ipsw_prepare_patchcomp WTF2\n        ipsw_prepare_patchcomp iBEC\n    fi\n    if [[ $device_target_vers == \"4.2.1\" ]]; then\n        ipsw_prepare_patchcomp iBSS\n        ipsw_prepare_patchcomp RestoreDeviceTree\n        ipsw_prepare_patchcomp RestoreKernelCache\n    elif [[ $device_target_vers == \"3.1.3\" ]]; then\n        ipsw_prepare_patchcomp Kernelcache\n    fi\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_prepare_custom() {\n    if [[ -e \"$ipsw_custom.ipsw\" ]]; then\n        log \"Found existing Custom IPSW. Skipping IPSW creation.\"\n        return\n    elif [[ $device_target_vers == \"4.1\" && $ipsw_jailbreak != 1 ]]; then\n        log \"No need to create custom IPSW for non-jailbroken restores on $device_type-$device_target_build\"\n        return\n    fi\n\n    ipsw_prepare_jailbreak old\n\n    mv \"$ipsw_custom.ipsw\" temp.ipsw\n    if [[ $device_type == \"iPod2,1\" && $device_newbr == 0 && $device_target_vers == \"3.1.3\" ]]; then\n        ipsw_prepare_patchcomp LLB\n        mv temp.ipsw \"$ipsw_custom.ipsw\"\n        return\n    fi\n\n    # 3GS\n    case $device_target_vers in\n        6.1.6 | 4.1 ) :;;\n        3.0* )\n            ipsw_prepare_patchcomp LLB\n            log \"Patch Kernelcache\"\n            unzip -o -j \"$ipsw_path.ipsw\" kernelcache.release.s5l8920x\n            mv kernelcache.release.s5l8920x kernelcache.orig\n            $bspatch kernelcache.orig kernelcache.release.s5l8920x ../resources/firmware/FirmwareBundles/Down_iPhone2,1_${device_target_vers}_${device_target_build}.bundle/kernelcache.release.patch\n            zip -r0 temp.ipsw kernelcache.release.s5l8920x\n        ;;\n        * )\n            ipsw_prepare_patchcomp LLB\n            local ExtraArgs3=\"$device_bootargs_default\"\n            if [[ $ipsw_verbose == 1 ]]; then\n                ExtraArgs3=\"pio-error=0 -v\"\n            fi\n            if [[ $device_target_vers == \"3\"* ]]; then\n                ExtraArgs3+=\" amfi=0xff cs_enforcement_disable=1\"\n            fi\n            local path=\"Firmware/all_flash/all_flash.${device_model}ap.production\"\n            local name=\"iBoot.${device_model}ap.RELEASE.img3\"\n            patch_iboot -b \"$ExtraArgs3\"\n            mkdir -p $path\n            mv $name $path/$name\n            zip -r0 temp.ipsw $path/$name\n        ;;\n    esac\n    mv temp.ipsw \"$ipsw_custom.ipsw\"\n}\n\nipsw_extract() {\n    local ExtraArgs\n    local ipsw=\"$ipsw_path\"\n    if [[ $1 == \"custom\" ]]; then\n        ipsw=\"$ipsw_custom\"\n    fi\n    if [[ ! -d \"$ipsw\" ]]; then\n        mkdir \"$ipsw\"\n        log \"Extracting IPSW: $ipsw.ipsw\"\n        unzip -o \"$ipsw.ipsw\" -d \"$ipsw/\" $ExtraArgs\n    fi\n}\n\nrestore_download_bbsep() {\n    # download and check manifest, baseband, and sep to be used for restoring\n    # sets variables: restore_manifest, restore_baseband, restore_sep\n    local build_id\n    local baseband_sha1\n    local restore_baseband_check\n    if [[ $device_proc == 8 || $device_latest_vers == \"15\"* || $device_latest_vers == \"16\"* || $device_checkm8ipad == 1 ]]; then\n        return\n    elif [[ $device_latest_vers == \"$device_use_vers\" || $device_target_vers == \"10\"* ]]; then\n        build_id=\"$device_use_build\"\n        restore_baseband=\"$device_use_bb\"\n        baseband_sha1=\"$device_use_bb_sha1\"\n    else\n        build_id=\"$device_latest_build\"\n        restore_baseband=\"$device_latest_bb\"\n        baseband_sha1=\"$device_latest_bb_sha1\"\n    fi\n\n    mkdir tmp\n    # BuildManifest\n    if [[ ! -e ../saved/$device_type/$build_id.plist ]]; then\n        if [[ $device_proc == 7 && $device_target_vers == \"10\"* ]]; then\n            cp ../resources/manifest/BuildManifest_${device_type}_10.3.3.plist $build_id.plist\n        else\n            log \"Downloading $build_id BuildManifest\"\n            \"$dir/pzb\" -g BuildManifest.plist -o $build_id.plist \"$(cat $device_fw_dir/$build_id/url)\"\n        fi\n        mv $build_id.plist ../saved/$device_type\n    fi\n    cp ../saved/$device_type/$build_id.plist tmp/BuildManifest.plist\n    if [[ $? != 0 ]]; then\n        rm ../saved/$device_type/$build_id.plist\n        error \"An error occurred copying manifest. Please run the script again\"\n    fi\n    log \"Manifest: ../saved/$device_type/$build_id.plist\"\n    restore_manifest=\"tmp/BuildManifest.plist\"\n\n    # Baseband\n    if [[ $restore_baseband != 0 ]]; then\n        restore_baseband_check=\"../saved/baseband/$restore_baseband\"\n        if [[ -e $restore_baseband_check ]]; then\n            if [[ $baseband_sha1 != \"$($sha1sum $restore_baseband_check | awk '{print $1}')\" ]]; then\n                rm $restore_baseband_check\n            fi\n        fi\n        if [[ ! -e $restore_baseband_check ]]; then\n            log \"Downloading $build_id Baseband\"\n            \"$dir/pzb\" -g Firmware/$restore_baseband -o $restore_baseband \"$(cat $device_fw_dir/$build_id/url)\"\n            if [[ $baseband_sha1 != \"$($sha1sum $restore_baseband | awk '{print $1}')\" ]]; then\n                error \"Downloading/verifying baseband failed. Please run the script again\"\n            fi\n            mv $restore_baseband $restore_baseband_check\n        fi\n        cp $restore_baseband_check tmp/bbfw.tmp\n        if [[ $? != 0 ]]; then\n            rm $restore_baseband_check\n            error \"An error occurred copying baseband. Please run the script again\"\n        fi\n        log \"Baseband: $restore_baseband_check\"\n        restore_baseband=\"tmp/bbfw.tmp\"\n    fi\n\n    # SEP\n    if (( device_proc >= 7 )); then\n        restore_sep=\"sep-firmware.$device_model.RELEASE\"\n        if [[ ! -e ../saved/$device_type/$restore_sep-$build_id.im4p ]]; then\n            log \"Downloading $build_id SEP\"\n            \"$dir/pzb\" -g Firmware/all_flash/$restore_sep.im4p -o $restore_sep.im4p \"$(cat $device_fw_dir/$build_id/url)\"\n            mv $restore_sep.im4p ../saved/$device_type/$restore_sep-$build_id.im4p\n        fi\n        restore_sep=\"$restore_sep-$build_id.im4p\"\n        cp ../saved/$device_type/$restore_sep .\n        if [[ $? != 0 ]]; then\n            rm ../saved/$device_type/$restore_sep\n            error \"An error occurred copying SEP. Please run the script again\"\n        fi\n        log \"SEP: ../saved/$device_type/$restore_sep\"\n    fi\n}\n\nrestore_idevicerestore() {\n    local ExtraArgs=\"-ew\"\n    local idevicerestore2=\"$idevicerestore\"\n    local re\n\n    mkdir shsh 2>/dev/null\n    cp \"$shsh_path\" shsh/$device_ecid-$device_type-$device_target_vers.shsh\n    if [[ $device_use_bb == 0 || $device_type == \"$device_disable_bbupdate\" ]]; then\n        log \"Device $device_type has no baseband/disabled baseband update\"\n    fi\n    ipsw_extract custom\n    if [[ $1 == \"norflash\" ]]; then\n        cp \"$shsh_path\" shsh/$device_ecid-$device_type-5.1.1.shsh\n    fi\n    if [[ $device_type == \"iPad\"* && $device_pwnrec != 1 ]] &&\n       [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]]; then\n        if [[ $device_type == \"iPad1,1\" ]]; then\n            patch_ibss\n            log \"Sending iBSS...\"\n            $irecovery -f pwnediBSS.dfu\n            sleep 1\n        fi\n        log \"Sending iBEC...\"\n        $irecovery -f \"$ipsw_custom/Firmware/dfu/iBEC.${device_model}ap.RELEASE.dfu\"\n        device_find_mode Recovery\n    fi\n    if [[ $debug_mode == 1 ]]; then\n        ExtraArgs+=\"d\"\n    fi\n\n    log \"Running idevicere${re}store with command: $idevicerestore2 $ExtraArgs \\\"$ipsw_custom.ipsw\\\"\"\n    $idevicerestore2 $ExtraArgs \"$ipsw_custom.ipsw\"\n    opt=$?\n    if [[ $1 == \"first\" ]]; then\n        return $opt\n    fi\n    echo\n    log \"Restoring done! Read the message below if any error has occurred:\"\n    case $device_target_vers in\n        [1234]* ) print \"* For device activation, go to: Main Menu -> Attempt Activation\";;\n    esac\n    if [[ $opt != 0 ]]; then\n        print \"* If the restore failed on updating baseband:\"\n        print \" -> Try disabling baseband update: ./restore.sh --disable-bbupdate\"\n        echo\n    fi\n    print \"* Please read the \\\"Troubleshooting\\\" wiki page in GitHub before opening any issue!\"\n    print \"* Your problem may have already been addressed within the wiki page.\"\n    print \"* If opening an issue in GitHub, please provide a FULL log/output. Otherwise, your issue may be dismissed.\"\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        case $device_target_vers in\n            [543]* ) warn \"Do not uninstall Cydia Substrate and Substrate Safe Mode in Cydia!\";;\n        esac\n    fi\n}\n\nrestore_futurerestore() {\n    local ExtraArr=()\n    local futurerestore2=\"$futurerestore\"\n    local port=8888\n    local opt\n\n    if [[ $1 == \"--use-pwndfu\" ]]; then\n        device_fw_key_check\n        pushd ../resources >/dev/null\n        if [[ $platform == \"macos\" ]]; then\n            if (( mac_majver >= 12 )); then\n                opt=\"/usr/bin/python3 -m http.server -b 127.0.0.1 $port\"\n            else\n                opt=\"/usr/bin/python -m SimpleHTTPServer $port\"\n            fi\n        else\n            if [[ -z $(command -v python3) ]]; then\n                error \"Python 3 is not installed, cannot continue. Make sure to have python3 installed.\"\n            fi\n            opt=\"$(command -v python3) -m http.server -b 127.0.0.1 $port\"\n        fi\n        log \"Starting local server for firmware keys: $opt\"\n        $opt &\n        httpserver_pid=$!\n        log \"httpserver PID: $httpserver_pid\"\n        popd >/dev/null\n        log \"Waiting for local server\"\n        until [[ $(curl http://127.0.0.1:$port 2>/dev/null) ]]; do\n            sleep 1\n        done\n    fi\n\n    restore_download_bbsep\n    # baseband args\n    if [[ $restore_baseband == 0 ]]; then\n        ExtraArr+=(\"--no-baseband\")\n    else\n        ExtraArr+=(\"-b\" \"$restore_baseband\" \"-p\" \"$restore_manifest\")\n    fi\n    # sep args for 64bit\n    if [[ -n $restore_sep ]]; then\n        ExtraArr+=(\"-s\" \"$restore_sep\" \"-m\" \"$restore_manifest\")\n    fi\n    if (( device_proc < 7 )); then\n        futurerestore2+=\"_old\"\n    elif [[ $device_proc == 7 && $device_target_other != 1 &&\n            $device_target_vers == \"10.3.3\" && $restore_usepwndfu64 != 1 ]]; then\n        futurerestore2+=\"_new\"\n    else\n        futurerestore2=\"../saved/futurerestore_$platform\"\n        if [[ $device_target_vers == \"10\"* ]]; then\n            export FUTURERESTORE_I_SOLEMNLY_SWEAR_THAT_I_AM_UP_TO_NO_GOOD=1 # required since custom-latest-ota is broken\n        else\n            ExtraArr=(\"--latest-sep\")\n            case $device_type in\n                iPhone* | iPad5,[24] | iPad6,[48] | iPad6,12 | iPad7,[46] | iPad7,12 ) ExtraArr+=(\"--latest-baseband\");;\n                * ) ExtraArr+=(\"--no-baseband\");;\n            esac\n        fi\n        ExtraArr+=(\"--no-rsep\")\n        if [[ $device_target_setnonce == 1 ]]; then\n            ExtraArr+=(\"--set-nonce\")\n        fi\n        log \"futurerestore nightly will be used for this restore: https://github.com/futurerestore/futurerestore\"\n        print \"* Builds from here: https://github.com/LukeeGD/futurerestore\"\n        if [[ $platform == \"linux\" && $platform_arch != \"x86_64\" ]]; then\n            warn \"futurerestore nightly is not supported on Linux $platform_arch, cannot continue. x86_64 only.\"\n            return\n        fi\n        log \"Checking for futurerestore updates...\"\n        #local fr_latest=\"$(curl https://api.github.com/repos/futurerestore/futurerestore/commits | $jq -r '.[0].sha')\"\n        local fr_latest\n        local fr_branch\n        local device_det3=$(echo \"$device_target_vers\" | cut -c -2)\n        if (( device_det3 > 15 )); then\n            fr_latest=\"21990ed74bff49937de8185d1209d8bace51b18f\"\n            fr_branch=\"dev\"\n        else\n            fr_latest=\"cb5376bfd1b5deba512a80578b15daf47257262b\"\n            fr_branch=\"main\"\n        fi\n        local fr_current=\"$(cat ${futurerestore2}-${fr_branch}_version 2>/dev/null)\"\n        log \"futurerestore $fr_branch branch will be used for this restore\"\n        if [[ $fr_latest != \"$fr_current\" ]]; then\n            log \"futurerestore nightly update detected, downloading.\"\n            rm -f ${futurerestore2}-${fr_branch}*\n        fi\n        if [[ ! -e ${futurerestore2}-${fr_branch} ]]; then\n            local url=\"https://github.com/LukeeGD/futurerestore/releases/download/latest/\"\n            local file=\"futurerestore-\"\n            case $platform in\n                \"macos\" ) file+=\"macOS-RELEASE-${fr_branch}.zip\";;\n                \"linux\" ) file+=\"Linux-x86_64-RELEASE-${fr_branch}.zip\";;\n            esac\n            url+=\"$file\"\n            download_file $url $file\n            unzip -q \"$file\" -d .\n            tar -xJvf futurerestore*.xz\n            mv futurerestore ${futurerestore2}-${fr_branch}\n            #perl -pi -e 's/nightly/nightlo/' $futurerestore2 # disable update check for now since it segfaults\n            chmod +x ${futurerestore2}-${fr_branch}\n            if [[ $platform == \"macos\" ]]; then\n                : '\n                ldid=\"../saved/ldid_${platform}_${platform_arch}\"\n                if [[ ! -e $ldid ]]; then\n                    download_file https://github.com/ProcursusTeam/ldid/releases/download/v2.1.5-procursus7/ldid_macosx_$platform_arch ldid\n                    chmod +x ldid\n                    mv ldid $ldid\n                fi\n                $ldid -S $futurerestore2\n                '\n                xattr -cr ${futurerestore2}-${fr_branch}\n            fi\n            echo \"$fr_latest\" > ${futurerestore2}-${fr_branch}_version\n        fi\n        futurerestore2+=\"-${fr_branch}\"\n    fi\n    # custom arg(s), either --use-pwndfu or --skip-blob, or both\n    if [[ -n \"$1\" ]]; then\n        ExtraArr+=(\"$1\")\n    fi\n    if [[ -n \"$2\" ]]; then\n        ExtraArr+=(\"$2\")\n    fi\n    if [[ $debug_mode == 1 ]]; then\n        ExtraArr+=(\"-d\")\n    fi\n    ExtraArr+=(\"-t\" \"$shsh_path\" \"$ipsw_path.ipsw\")\n    ipsw_extract\n\n    log \"Running futurerestore with command: $futurerestore2 ${ExtraArr[*]}\"\n    $futurerestore2 \"${ExtraArr[@]}\"\n    opt=$?\n    log \"Restoring done! Read the message below if any error has occurred:\"\n    if [[ $opt != 0 ]] && (( device_proc < 7 )); then\n        print \"* If you are getting the error: \\\"could not retrieve device serial number\\\",\"\n        print \" -> Try restoring with the jailbreak option enabled\"\n    fi\n    print \"* Please read the \\\"Troubleshooting\\\" wiki page in GitHub before opening any issue!\"\n    print \"* Your problem may have already been addressed within the wiki page.\"\n    print \"* If opening an issue in GitHub, please provide a FULL log/output. Otherwise, your issue may be dismissed.\"\n    kill $httpserver_pid\n}\n\nrestore_latest() {\n    local idevicerestore2=\"$idevicerestore\"\n    local ExtraArgs=\"-e\"\n    if [[ $device_latest_vers == \"12\"* || $device_latest_vers == \"15\"* || $device_latest_vers == \"16\"* || $device_checkm8ipad == 1 ]]; then\n        idevicerestore2+=\"2\"\n        ExtraArgs+=\"y\"\n    fi\n    if [[ $1 == \"custom\" ]]; then\n        ExtraArgs+=\"c\"\n        ipsw_path=\"$ipsw_custom\"\n        ipsw_extract custom\n    else\n        device_enter_mode Recovery\n        ipsw_extract\n    fi\n    if [[ $device_type == \"iPhone1,2\" && $device_target_vers == \"4\"* ]]; then\n        if [[ $1 == \"custom\" ]]; then\n            log \"Sending s5l8900xall...\"\n            $irecovery -f \"$ipsw_custom/Firmware/dfu/WTF.s5l8900xall.RELEASE.dfu\"\n            device_find_mode DFUreal\n            log \"Sending iBSS...\"\n            $irecovery -f \"$ipsw_custom/Firmware/dfu/iBSS.${device_model}ap.RELEASE.dfu\"\n            device_find_mode Recovery\n        else\n            ExtraArgs=\"-e\"\n        fi\n    fi\n    if [[ $debug_mode == 1 ]]; then\n        ExtraArgs+=\"d\"\n    fi\n    log \"Running idevicerestore with command: $idevicerestore2 $ExtraArgs \\\"$ipsw_path.ipsw\\\"\"\n    $idevicerestore2 $ExtraArgs \"$ipsw_path.ipsw\"\n    opt=$?\n    if [[ $2 == \"first\" ]]; then\n        return $opt\n    fi\n    if [[ $1 == \"custom\" ]]; then\n        log \"Restoring done! Read the message below if any error has occurred:\"\n        print \"* Please read the \\\"Troubleshooting\\\" wiki page in GitHub before opening any issue!\"\n        print \"* Your problem may have already been addressed within the wiki page.\"\n        print \"* If opening an issue in GitHub, please provide a FULL log/output. Otherwise, your issue may be dismissed.\"\n    fi\n    case $device_target_vers in\n        [1234]* ) print \"* For device activation, go to: Main Menu -> Attempt Activation\";;\n    esac\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        case $device_target_vers in\n            [543]* ) warn \"Do not uninstall Cydia Substrate and Substrate Safe Mode in Cydia!\";;\n        esac\n    fi\n}\n\nrestore_prepare_pwnrec64() {\n    local attempt=1\n    if [[ $device_pwnrec == 1 ]]; then\n        warn \"Pwned recovery flag detected, skipping pwnREC mode procedure. Proceed with caution\"\n        return\n    fi\n\n    device_enter_mode pwnDFU\n    if [[ $device_proc == 7 ]]; then\n        log \"gaster reset\"\n        $gaster reset\n    fi\n    sleep 1\n    while (( attempt <= 5 )); do\n        log \"Entering pwnREC mode... (Attempt $attempt of 5)\"\n        log \"Sending iBSS...\"\n        $irecovery -f $iBSS.im4p\n        sleep 1\n        log \"Sending iBEC...\"\n        $irecovery -f $iBEC.im4p\n        sleep 3\n        device_find_mode Recovery 1\n        if [[ $? == 0 ]]; then\n            break\n        fi\n        print \"* You may also try to unplug and replug your device\"\n        ((attempt++))\n    done\n    if [[ $device_proc == 10 ]]; then\n        log \"irecovery -c go\"\n        $irecovery -c \"go\"\n        sleep 3\n    fi\n\n    if (( attempt > 5 )); then\n        error \"Failed to enter pwnREC mode. You might have to force restart your device and start over entering pwnDFU mode again\"\n    fi\n}\n\ndevice_buttons() {\n    local selection=(\"pwnDFU\" \"kDFU\")\n    if [[ $device_mode != \"Normal\" ]]; then\n        device_enter_mode pwnDFU\n        return\n    fi\n    input \"pwnDFU/kDFU Mode Option\"\n    print \"* This device needs to be in pwnDFU/kDFU mode before proceeding.\"\n    print \"* Selecting 1 (pwnDFU) is recommended. Both your home and power buttons must be working properly for entering DFU mode.\"\n    print \"* Selecting 2 (kDFU) is for those that prefer the jailbroken method instead (have OpenSSH installed).\"\n    input \"Select your option:\"\n    select_option \"${selection[@]}\"\n    opt2=\"${selection[$?]}\"\n    if [[ $opt2 == *\"DFU\" ]]; then\n        device_enter_mode $opt2\n    fi\n}\n\ndevice_buttons2() {\n    local selection=(\"Jailbroken\" \"pwnDFU\")\n    if [[ $device_mode != \"Normal\" ]]; then\n        device_enter_mode pwnDFU\n        return\n    fi\n    input \"Jailbroken/pwnDFU Mode Option\"\n    print \"* This device needs to be jailbroken/in kDFU mode before proceeding.\"\n    print \"* Selecting 1 (Jailbroken) is recommended. Your device must be jailbroken and have OpenSSH installed for this option.\"\n    print \"* Selecting 2 (pwnDFU) is for those that prefer the ramdisk method instead.\"\n    if [[ $device_proc == 5 ]]; then\n        warn \"Selecting 2 will require usage of checkm8-a5.\"\n        print \"* For more details, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/checkm8-a5\"\n    fi\n    input \"Select your option:\"\n    select_option \"${selection[@]}\"\n    opt2=\"${selection[$?]}\"\n    if [[ $opt2 == *\"DFU\" ]]; then\n        device_enter_mode $opt2\n    fi\n}\n\nrestore_prepare() {\n    case $device_proc in\n        1 )\n            if [[ $device_target_vers == \"4\"* && $ipsw_jailbreak != 1 ]]; then\n                restore_latest\n                return\n            elif [[ $device_target_vers == \"3.1.3\" ]]; then\n                device_enter_mode DFU\n            else\n                device_enter_mode WTFreal\n            fi\n            if [[ $ipsw_jailbreak != 1 ]]; then\n                ipsw_custom=\"$ipsw_path\"\n            fi\n            restore_latest custom\n        ;;\n\n        4 )\n            if [[ $device_target_tethered == 1 ]]; then\n                shsh_save version $device_latest_vers\n                device_enter_mode pwnDFU\n                restore_idevicerestore\n            elif [[ $device_target_vers == \"4.1\" && $ipsw_jailbreak == 1 ]]; then\n                case $device_type in\n                    iPhone2,1 | iPod[23],1 ) shsh_save version 4.1;;\n                esac\n                device_enter_mode pwnDFU\n                restore_idevicerestore\n            elif [[ $device_target_powder == 1 ]]; then\n                shsh_save version $device_latest_vers\n                case $device_target_vers in\n                    [34]* ) device_enter_mode pwnDFU;;\n                    * ) device_buttons;;\n                esac\n                case $device_target_vers in\n                    \"3\"* | \"4.0\"* | \"4.1\" | \"4.2\"* )\n                        if [[ $ipsw_skip_first != 1 ]]; then\n                            restore_idevicerestore first\n                            log \"Do not disconnect your device, not done yet\"\n                            print \"* Please put the device in DFU mode after it reboots!\"\n                            sleep 10\n                            device_mode=\n                            log \"Press Enter/Return when the device reboots and is on black screen, Apple logo, or iTunes logo.\"\n                            device_enter_mode DFU\n                        fi\n                        log \"Finding device in Recovery/DFU mode...\"\n                        until [[ -n $device_mode ]]; do\n                            device_mode=\"$($irecovery -q 2>/dev/null | grep -w \"MODE\" | cut -c 7-)\"\n                        done\n                        ipsw_custom=\"../$ipsw_custom_part2\"\n                        device_enter_mode pwnDFU\n                        restore_idevicerestore norflash\n                    ;;\n                    * ) restore_idevicerestore;;\n                esac\n                if [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]] && [[ $device_target_powder == 1 ]]; then\n                    echo\n                    log \"The device may enter recovery mode after the restore\"\n                    print \"* To fix this, go to: Useful Utilities -> Disable/Enable Exploit -> Enable Exploit\"\n                fi\n            elif [[ $device_target_other == 1 ]]; then\n                case $device_target_vers in\n                    [34]* ) device_enter_mode pwnDFU;;\n                    * ) device_buttons;;\n                esac\n                restore_idevicerestore\n            elif [[ $device_target_vers == \"4.1\" ]]; then\n                shsh_save version 4.1\n                device_enter_mode DFU\n                restore_latest\n                if [[ $device_type == \"iPhone2,1\" ]]; then\n                    log \"Ignore the baseband error and do not disconnect your device yet\"\n                    device_find_mode Recovery 50\n                    log \"Attempting to exit recovery mode\"\n                    $irecovery -n\n                    log \"Done, your device should boot now\"\n                fi\n            elif [[ $device_target_vers == \"$device_latest_vers\" ]]; then\n                if [[ $ipsw_jailbreak == 1 ]]; then\n                    shsh_save version $device_latest_vers\n                    device_buttons\n                    restore_idevicerestore\n                else\n                    restore_latest\n                fi\n            else\n                device_enter_mode pwnDFU\n                if [[ $device_type == \"iPhone2,1\" && $device_newbr != 0 ]]; then\n                    restore_latest custom first\n                    print \"* Proceed to install the alloc8 exploit for the device to boot:\"\n                    print \" -> Go to: Useful Utilities -> Install alloc8 Exploit\"\n                    log \"Do not disconnect your device, not done yet\"\n                    device_find_mode DFU 50\n                    device_alloc8\n                else\n                    restore_latest custom\n                fi\n            fi\n        ;;\n\n        [56] )\n            # 32-bit devices A5/A6\n            if [[ $device_target_tethered == 1 ]]; then\n                shsh_save version $device_latest_vers\n                device_enter_mode pwnDFU\n                restore_idevicerestore\n                return\n            elif [[ $device_target_other != 1 && $device_target_powder != 1 ]]; then\n                shsh_save\n            fi\n            if [[ $device_target_vers == \"$device_latest_vers\" && $ipsw_gasgauge_patch != 1 ]]; then\n                restore_latest\n            else\n                if [[ $device_proc == 6 && $platform == \"macos\" ]]; then\n                    device_buttons\n                else\n                    device_enter_mode kDFU\n                fi\n                if [[ $ipsw_jailbreak == 1 || -e \"$ipsw_custom.ipsw\" ]]; then\n                    restore_idevicerestore\n                else\n                    restore_futurerestore --use-pwndfu\n                fi\n            fi\n        ;;\n\n        7 )\n            if [[ $device_target_other != 1 && $device_target_vers == \"10.3.3\" ]]; then\n                shsh_save\n            fi\n            if [[ $restore_usepwndfu64 == 1 ]]; then\n                restore_pwned64\n            elif [[ $device_target_other != 1 && $device_target_vers == \"10.3.3\" ]]; then\n                if [[ $device_type == \"iPad4,4\" || $device_type == \"iPad4,5\" ]]; then\n                    iBSS=$iBSSb\n                    iBEC=$iBECb\n                fi\n                restore_prepare_pwnrec64\n                shsh_save apnonce $($irecovery -q | grep \"NONC\" | cut -c 7-)\n                restore_futurerestore --skip-blob\n            elif [[ $device_target_vers == \"$device_latest_vers\" ]]; then\n                restore_latest\n            else\n                restore_notpwned64\n            fi\n        ;;\n\n        [89] | 10 )\n            if [[ $restore_usepwndfu64 == 1 ]]; then\n                restore_pwned64\n            elif [[ $device_target_vers == \"$device_latest_vers\" ]]; then\n                restore_latest\n            else\n                restore_notpwned64\n            fi\n        ;;\n    esac\n}\n\nrestore_pwned64() {\n    device_enter_mode pwnDFU\n    if [[ ! -s ../saved/firmwares.json ]]; then\n        download_file https://api.ipsw.me/v2.1/firmwares.json/condensed firmwares.json\n        cp firmwares.json ../saved\n    fi\n    rm -f /tmp/firmwares.json\n    cp ../saved/firmwares.json /tmp\n    if [[ $device_proc == 7 ]]; then\n        log \"gaster reset\"\n        $gaster reset\n    fi\n    local opt\n    if [[ $device_proc == 7 && $device_target_other != 1 &&\n          $device_target_vers == \"10.3.3\" ]] || [[ $restore_useskipblob == 1 ]]; then\n        opt=\"--skip-blob\"\n    fi\n    restore_futurerestore --use-pwndfu $opt\n}\n\nrestore_notpwned64() {\n    log \"The generator for your SHSH blob is: $shsh_generator\"\n    print \"* Before continuing, make sure to set the nonce generator of your device!\"\n    print \"* For iOS 10 and older: https://github.com/tihmstar/futurerestore#how-to-use\"\n    print \"* For iOS 11 and newer: https://github.com/futurerestore/futurerestore/#using-dimentio\"\n    print \"* Using \\\"Set Nonce Only\\\" in the Restore/Downgrade menu is also an option\"\n    pause\n    if [[ $device_mode == \"Normal\" ]]; then\n        device_enter_mode Recovery\n    fi\n    restore_futurerestore\n}\n\nipsw_prepare() {\n    case $device_proc in\n        1 )\n            if [[ $ipsw_jailbreak == 1 ]]; then\n                ipsw_prepare_s5l8900\n            elif [[ $device_target_vers == \"$device_latest_vers\" && ! -s \"../$ipsw_latest_path.ipsw\" ]]; then\n                ipsw_path=\"../$ipsw_latest_path\"\n                ipsw_download \"$ipsw_path\"\n            fi\n        ;;\n\n        4 )\n            if [[ $device_target_tethered == 1 ]]; then\n                ipsw_prepare_tethered\n            elif [[ $device_target_other == 1 ]] || [[ $device_target_vers == \"$device_latest_vers\" && $ipsw_jailbreak == 1 ]]; then\n                case $device_type in\n                    iPhone2,1 ) ipsw_prepare_jailbreak;;\n                    iPod2,1 ) ipsw_prepare_custom;;\n                    * ) ipsw_prepare_32bit;;\n                esac\n            elif [[ $device_target_powder == 1 ]] && [[ $device_target_vers == \"3\"* || $device_target_vers == \"4\"* ]]; then\n                shsh_save version $device_latest_vers\n                case $device_target_vers in\n                    \"4.3\"* ) ipsw_prepare_ios4powder;;\n                    * ) ipsw_prepare_ios4multipart;;\n                esac\n            elif [[ $device_target_powder == 1 ]]; then\n                ipsw_prepare_powder\n            elif [[ $device_target_vers != \"$device_latest_vers\" ]]; then\n                ipsw_prepare_custom\n            fi\n            if [[ $ipsw_isbeta == 1 && $ipsw_prepare_ios4multipart_patch != 1 ]] ||\n               [[ $device_target_vers == \"3.2\"* && $ipsw_prepare_ios4multipart_patch != 1 ]] ||\n               [[ $ipsw_gasgauge_patch == 1 ]]; then\n                ipsw_prepare_multipatch\n            fi\n        ;;\n\n        [56] )\n            # 32-bit devices A5/A6\n            if [[ $device_target_tethered == 1 ]]; then\n                ipsw_prepare_tethered\n            elif [[ $device_target_powder == 1 ]]; then\n                ipsw_prepare_powder\n            elif [[ $ipsw_jailbreak == 1 && $device_target_other != 1 ]]; then\n                ipsw_prepare_jailbreak\n            elif [[ $device_target_vers != \"$device_latest_vers\" || $ipsw_gasgauge_patch == 1 ]]; then\n                ipsw_prepare_32bit\n            fi\n            if [[ $ipsw_fourthree == 1 ]]; then\n                ipsw_prepare_fourthree_part2\n            elif [[ $ipsw_isbeta == 1 || $ipsw_gasgauge_patch == 1 ]]; then\n                case $device_target_vers in\n                    [59] ) :;;\n                    * ) ipsw_prepare_multipatch;;\n                esac\n            fi\n        ;;\n\n        [789] | 10 )\n            restore_usepwndfu64_option\n            if [[ $device_target_other != 1 && $device_target_vers == \"10.3.3\" && $restore_usepwndfu64 != 1 ]]; then\n                 ipsw_prepare_1033\n            fi\n        ;;\n    esac\n}\n\nrestore_usepwndfu64_option() {\n    if [[ $device_target_vers == \"$device_latest_vers\" || $restore_usepwndfu64 == 1 ]]; then\n        return\n    elif [[ $restore_useskipblob == 1 ]]; then\n        log \"skip-blob flag detected, Pwned Restore Option enabled.\"\n        restore_usepwndfu64=1\n        return\n    elif [[ $device_mode == \"DFU\" && $device_target_other == 1 ]]; then\n        log \"Device is in DFU mode, Pwned Restore Option enabled.\"\n        print \"* If you want to disable Pwned Restore Option, place the device in Normal/Recovery mode\"\n        restore_usepwndfu64=1\n        return\n    elif [[ $device_target_vers == \"10.3.3\" && $device_target_other != 1 &&\n            $platform == \"macos\" && $platform_arch == \"arm64\" ]] ||\n         [[ $device_target_setnonce == 1 ]]; then\n        restore_usepwndfu64=1\n        return\n    fi\n    local opt\n    input \"Pwned Restore Option\"\n    print \"* When this option is enabled, use-pwndfu will be enabled for restoring.\"\n    if [[ $device_target_other == 1 ]]; then\n        print \"* When disabled, user must set the device generator manually before the restore.\"\n    fi\n    if [[ $device_proc == 7 ]]; then\n        print \"* This option is disabled by default (N). Select this option if unsure.\"\n        select_yesno \"Enable this option?\" 0\n        if [[ $? != 0 ]]; then\n            log \"Pwned restore option enabled by user.\"\n            restore_usepwndfu64=1\n        else\n            log \"Pwned restore option disabled.\"\n        fi\n    else\n        print \"* This option is enabled by default (Y). Select this option if unsure.\"\n        select_yesno \"Enable this option?\" 1\n        if [[ $? != 1 ]]; then\n            log \"Pwned restore option disabled by user.\"\n        else\n            log \"Pwned restore option enabled.\"\n            restore_usepwndfu64=1\n        fi\n    fi\n}\n\nmenu_remove4() {\n    local menu_items\n    local selected\n    local back\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Disable Exploit\" \"Enable Exploit\" \"Go Back\")\n        menu_print_info\n        print \" > Main Menu > Useful Utilities > Disable/Enable Exploit\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Disable Exploit\" ) rec=0;;\n            \"Enable Exploit\" ) rec=2;;\n        esac\n        case $selected in\n            \"Go Back\" ) back=1;;\n            * ) mode=\"remove4\";;\n        esac\n    done\n}\n\ndevice_send_rdtar() {\n    local target=\"/mnt1\"\n    if [[ $2 == \"data\" ]]; then\n        target+=\"/private/var\"\n    fi\n    log \"Sending $1\"\n    $scp -P $ssh_port $jelbrek/$1 root@127.0.0.1:$target\n    log \"Extracting $1\"\n    $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf $target/$1 -C /mnt1; rm $target/$1\"\n}\n\ndevice_ramdisk64() {\n    local sshtar=\"../saved/ssh64.tar\"\n    local comps=(\"iBSS\" \"iBEC\" \"DeviceTree\" \"Kernelcache\" \"RestoreRamdisk\")\n    local name\n    local iv\n    local key\n    local path\n    local url\n    local decrypt\n    local ios8\n    local opt\n    local build_id=\"16A366\"\n    if (( device_proc >= 9 )) || [[ $device_type == \"iPad5\"* ]]; then\n        build_id=\"18C66\"\n    fi\n\n    if [[ $device_ramdisk_ios8 == 1 ]]; then\n        ios8=1\n    fi\n\n    if [[ $ios8 == 1 ]]; then\n        build_id=\"12B410\"\n        if [[ $device_type == \"iPhone\"* ]]; then\n            build_id=\"12B411\"\n        elif [[ $device_type == \"iPod7,1\" ]]; then\n            build_id=\"12H321\"\n        fi\n        sshtar=\"../saved/iram.tar\"\n        if [[ ! -e $sshtar ]]; then\n            log \"Downloading iram.tar from iarchive.app...\"\n            download_file https://github.com/LukeZGD/Legacy-iOS-Kit/files/14952123/iram.zip iram.zip\n            unzip iram.zip\n            mv iram.tar $sshtar\n        fi\n        cp $sshtar ssh.tar\n    else\n        comps+=(\"Trustcache\")\n        if [[ $($sha1sum $sshtar.gz 2>/dev/null | awk '{print $1}') != \"61975423c096d5f21fd9f8a48042fffd3828708b\" ]]; then\n            rm -f $sshtar $sshtar.gz\n        fi\n        if [[ ! -e $sshtar.gz ]]; then\n            log \"Downloading ssh.tar from SSHRD_Script...\"\n            download_file https://github.com/LukeZGD/sshtars/raw/eed9dcb6aa7562c185eb8b3b66c6035c0b026d47/ssh.tar.gz ssh.tar.gz\n            mv ssh.tar.gz $sshtar.gz\n        fi\n        cp $sshtar.gz ssh.tar.gz\n        gzip -d ssh.tar.gz\n    fi\n\n    local ramdisk_path=\"../saved/$device_type/ramdisk_$build_id\"\n    device_target_build=\"$build_id\"\n    device_fw_key_check\n    ipsw_get_url $build_id\n\n    mkdir $ramdisk_path 2>/dev/null\n    for getcomp in \"${comps[@]}\"; do\n        name=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n        iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        if [[ $device_type == \"iPhone8\"* && $getcomp == \"iB\"* ]]; then\n            name=$(echo $device_fw_key | $jq -j '.keys[] | select(.image | startswith(\"'$getcomp'\")) | select(.filename | startswith(\"'$getcomp'.'$device_model'.\")) | .filename')\n            iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image | startswith(\"'$getcomp'\")) | select(.filename | startswith(\"'$getcomp'.'$device_model'.\")) | .iv')\n            key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image | startswith (\"'$getcomp'\")) | select(.filename | startswith(\"'$getcomp'.'$device_model'.\")) | .key')\n        fi\n        case $getcomp in\n            \"iBSS\" | \"iBEC\" ) path=\"Firmware/dfu/\";;\n            \"DeviceTree\" ) path=\"Firmware/all_flash/\";;\n            \"Trustcache\" ) path=\"Firmware/\";;\n            * ) path=\"\";;\n        esac\n        if [[ $ios8 == 1 && $getcomp == \"DeviceTree\" ]]; then\n            path=\"$all_flash/\"\n        fi\n        if [[ -z $name ]]; then\n            local hwmodel\n            ipsw_hwmodel_set\n            hwmodel=\"$ipsw_hwmodel\"\n            case $getcomp in\n                \"iBSS\" | \"iBEC\"  ) name=\"$getcomp.$hwmodel.RELEASE.im4p\";;\n                \"DeviceTree\"     ) name=\"$getcomp.${device_model}ap.im4p\";;\n                \"Kernelcache\"    ) name=\"kernelcache.release.$hwmodel\";;\n                \"Trustcache\"     ) name=\"048-08497-242.dmg.trustcache\";;\n                \"RestoreRamdisk\" ) name=\"048-08497-242.dmg\";;\n            esac\n            if [[ $device_type == \"iPhone8,1\" || $device_type == \"iPhone8,2\" ]] && [[ $getcomp == \"Kernelcache\" ]]; then\n                name=\"kernelcache.release.${device_model:0:3}\"\n            fi\n            if [[ $build_id == \"18C66\" ]]; then\n                case $getcomp in\n                    \"Trustcache\"     ) name=\"038-83284-083.dmg.trustcache\";;\n                    \"RestoreRamdisk\" ) name=\"038-83284-083.dmg\";;\n                esac\n            fi\n        fi\n\n        log \"$getcomp\"\n        if [[ -e $ramdisk_path/$name ]]; then\n            cp $ramdisk_path/$name .\n        else\n            \"$dir/pzb\" -g \"${path}$name\" -o \"$name\" \"$ipsw_url\"\n            cp $name $ramdisk_path/\n        fi\n        mv $name $getcomp.orig\n        local reco=\"-i $getcomp.orig -o $getcomp.img4 -M ../resources/sshrd/IM4M$device_proc -T \"\n        case $getcomp in\n            \"iBSS\" | \"iBEC\" )\n                reco+=\"$(echo $getcomp | tr '[:upper:]' '[:lower:]') -A\"\n                \"$dir/img4\" -i $getcomp.orig -o $getcomp.dec -k ${iv}${key}\n                mv $getcomp.orig $getcomp.orig0\n                if [[ $ios8 == 1 ]]; then\n                    $bspatch $getcomp.dec $getcomp.orig ../resources/sshrd/ios8/$name.patch\n                else\n                    $bspatch $getcomp.dec $getcomp.orig ../resources/sshrd/$name.patch\n                fi\n            ;;\n            \"Kernelcache\" )\n                reco+=\"rkrn\"\n                if [[ $ios8 == 1 ]]; then\n                    mv $getcomp.orig $getcomp.orig0\n                    \"$dir/img4\" -i $getcomp.orig0 -o $getcomp.orig -k ${iv}${key} -D\n                else\n                    reco+=\" -P ../resources/sshrd/$name.bpatch\"\n                    if [[ $platform == \"linux\" && $build_id == \"18\"* ]] || [[ $device_proc == 10 ]]; then\n                        reco+=\" -J\"\n                    fi\n                fi\n            ;;\n            \"DeviceTree\" )\n                reco+=\"rdtr\"\n                if [[ $ios8 == 1 ]]; then\n                    reco+=\" -A\"\n                    mv $getcomp.orig $getcomp.orig0\n                    \"$dir/img4\" -i $getcomp.orig0 -o $getcomp.orig -k ${iv}${key}\n                fi\n            ;;\n            \"Trustcache\" ) reco+=\"rtsc\";;\n            \"RestoreRamdisk\" )\n                reco+=\"rdsk -A\"\n                mv $getcomp.orig $getcomp.orig0\n                if [[ $ios8 == 1 ]]; then\n                    \"$dir/img4\" -i $getcomp.orig0 -o $getcomp.orig -k ${iv}${key}\n                    \"$dir/hfsplus\" $getcomp.orig grow 50000000\n                else\n                    \"$dir/img4\" -i $getcomp.orig0 -o $getcomp.orig\n                    \"$dir/hfsplus\" $getcomp.orig grow 130000000\n                fi\n                \"$dir/hfsplus\" $getcomp.orig untar ssh.tar\n                \"$dir/hfsplus\" $getcomp.orig untar ../resources/sshrd/sbplist.tar\n            ;;\n        esac\n        \"$dir/img4\" $reco\n        cp $getcomp.img4 $ramdisk_path\n    done\n\n    mv $ramdisk_path/iBSS.img4 $ramdisk_path/iBSS.im4p\n    mv $ramdisk_path/iBEC.img4 $ramdisk_path/iBEC.im4p\n    iBSS=\"$ramdisk_path/iBSS\"\n    iBEC=\"$ramdisk_path/iBEC\"\n    restore_prepare_pwnrec64\n\n    log \"Booting, please wait...\"\n    $irecovery -f $ramdisk_path/RestoreRamdisk.img4\n    $irecovery -c ramdisk\n    $irecovery -f $ramdisk_path/DeviceTree.img4\n    $irecovery -c devicetree\n    if [[ $ios8 != 1 ]]; then\n        $irecovery -f $ramdisk_path/Trustcache.img4\n        $irecovery -c firmware\n    fi\n    $irecovery -f $ramdisk_path/Kernelcache.img4\n    $irecovery -c bootx\n    sleep 10\n\n    if [[ $ios8 == 1 ]]; then\n        device_iproxy no-logging 44\n        print \"* Booted SSH ramdisk is based on: https://ios7.iarchive.app/downgrade/making-ramdisk.html\"\n    else\n        device_iproxy no-logging\n        print \"* Booted SSH ramdisk is based on: https://github.com/verygenericname/SSHRD_Script\"\n    fi\n    device_sshpass alpine\n\n    local found\n    log \"Waiting for device...\"\n    while [[ $found != 1 ]]; do\n        found=$($ssh -p $ssh_port root@127.0.0.1 \"echo 1\")\n        sleep 1\n    done\n\n    print \"* Mount filesystems with this command (for iOS 11.3 and newer):\"\n    print \"    /usr/bin/mount_filesystems\"\n    print \"* Mount filesystems with this command (for iOS 10.3.x):\"\n    print \"    /sbin/mount_apfs /dev/disk0s1s1 /mnt1; /sbin/mount_apfs /dev/disk0s1s2 /mnt2\"\n    print \"* Mount filesystems with this command (for iOS 10.2.1 and older):\"\n    print \"    /sbin/mount_hfs /dev/disk0s1s1 /mnt1; /sbin/mount_hfs /dev/disk0s1s2 /mnt2\"\n    warn \"Mounting and/or modifying data (/mnt2) might not work for 64-bit iOS\"\n\n    menu_ramdisk $build_id\n}\n\ndevice_ramdisk() {\n    local comps=(\"iBSS\" \"iBEC\" \"DeviceTree\" \"Kernelcache\")\n    local name\n    local iv\n    local key\n    local path\n    local url\n    local decrypt\n    local ramdisk_path\n    local build_id\n    local mode=\"$1\"\n    local rec=2\n\n    if [[ $1 == \"setnvram\" ]]; then\n        rec=$2\n    fi\n    if [[ $1 != \"justboot\" ]]; then\n        comps+=(\"RestoreRamdisk\")\n    fi\n    case $device_type in\n        iPhone1,[12] | iPod1,1 ) device_target_build=\"7E18\";;\n        iPod2,1 ) device_target_build=\"8C148\";;\n        iPod3,1 | iPad1,1 ) device_target_build=\"9B206\";;\n        iPhone2,1 | iPod4,1 ) device_target_build=\"10B500\";;\n        iPhone5,[34] ) device_target_build=\"11D257\";;\n        * ) device_target_build=\"10B329\";;\n    esac\n    if [[ -n $device_rd_build ]]; then\n        device_target_build=$device_rd_build\n        device_rd_build=\n    fi\n    build_id=$device_target_build\n    device_fw_key_check\n    ipsw_get_url $build_id\n    ramdisk_path=\"../saved/$device_type/ramdisk_$build_id\"\n    mkdir $ramdisk_path 2>/dev/null\n    for getcomp in \"${comps[@]}\"; do\n        name=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .filename')\n        iv=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .iv')\n        key=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"'$getcomp'\") | .key')\n        case $getcomp in\n            \"iBSS\" | \"iBEC\" ) path=\"Firmware/dfu/\";;\n            \"DeviceTree\" )\n                path=\"Firmware/all_flash/\"\n                case $build_id in\n                    14[EFG]* ) :;;\n                    * ) path=\"$all_flash/\";;\n                esac\n            ;;\n            * ) path=\"\";;\n        esac\n        if [[ -z $name ]]; then\n            local hwmodel=\"$device_model\"\n            case $build_id in\n                14[EFG]* )\n                    case $device_type in\n                        iPhone5,[12] ) hwmodel=\"iphone5\";;\n                        iPhone5,[34] ) hwmodel=\"iphone5b\";;\n                        iPad3,[456] )  hwmodel=\"ipad3b\";;\n                    esac\n                ;;\n                [789]* | 10* | 11* ) hwmodel+=\"ap\";;\n            esac\n            case $getcomp in\n                \"iBSS\" | \"iBEC\" ) name=\"$getcomp.$hwmodel.RELEASE.dfu\";;\n                \"DeviceTree\" )    name=\"$getcomp.${device_model}ap.img3\";;\n                \"Kernelcache\" )   name=\"kernelcache.release.$hwmodel\";;\n            esac\n        fi\n\n        log \"$getcomp\"\n        if [[ -n $ipsw_justboot_path ]]; then\n            unzip -o -j \"$ipsw_justboot_path.ipsw\" \"${path}$name\" -d .\n        elif [[ -e $ramdisk_path/$name ]]; then\n            cp $ramdisk_path/$name .\n        else\n            \"$dir/pzb\" -g \"${path}$name\" -o \"$name\" \"$ipsw_url\"\n            cp $name $ramdisk_path/\n        fi\n        mv $name $getcomp.orig\n        if [[ $getcomp == \"Kernelcache\" || $getcomp == \"iBSS\" ]] && [[ $device_type == \"iPod2,1\" ]]; then\n            decrypt=\"-iv $iv -k $key\"\n            \"$dir/xpwntool\" $getcomp.orig $getcomp.dec $decrypt\n        elif [[ $build_id == \"14\"* ]]; then\n            cp $getcomp.orig $getcomp.dec\n        else\n            \"$dir/xpwntool\" $getcomp.orig $getcomp.dec -iv $iv -k $key -decrypt\n        fi\n    done\n\n    if [[ $1 != \"justboot\" ]]; then\n        log \"Patch RestoreRamdisk\"\n        \"$dir/xpwntool\" RestoreRamdisk.dec Ramdisk.raw\n        \"$dir/hfsplus\" Ramdisk.raw grow 30000000\n        \"$dir/hfsplus\" Ramdisk.raw untar ../resources/sshrd/sbplist.tar\n    fi\n\n    if [[ $device_type == \"iPod2,1\" ]]; then\n        \"$dir/hfsplus\" Ramdisk.raw untar ../resources/sshrd/ssh_old.tar\n        \"$dir/xpwntool\" Ramdisk.raw Ramdisk.dmg -t RestoreRamdisk.dec\n        log \"Patch iBSS\"\n        $bspatch iBSS.dec iBSS.patched ../resources/patch/iBSS.${device_model}ap.RELEASE.patch\n        \"$dir/xpwntool\" iBSS.patched iBSS -t iBSS.orig\n        log \"Patch Kernelcache\"\n        mv Kernelcache.dec Kernelcache0.dec\n        if [[ $device_proc == 1 ]]; then\n            $bspatch Kernelcache0.dec Kernelcache.patched ../resources/patch/kernelcache.release.s5l8900x.patch\n        else\n            $bspatch Kernelcache0.dec Kernelcache.patched ../resources/patch/kernelcache.release.${device_model}.patch\n        fi\n        \"$dir/xpwntool\" Kernelcache.patched Kernelcache.dec -t Kernelcache.orig $decrypt\n        rm DeviceTree.dec\n        mv DeviceTree.orig DeviceTree.dec\n    else\n        if [[ $1 != \"justboot\" ]]; then\n            \"$dir/hfsplus\" Ramdisk.raw untar ../resources/sshrd/ssh.tar\n            if [[ $1 == \"jailbreak\" && $device_vers == \"8\"* ]]; then\n                \"$dir/hfsplus\" Ramdisk.raw untar ../resources/jailbreak/daibutsu/bin.tar\n            fi\n            \"$dir/hfsplus\" Ramdisk.raw mv sbin/reboot sbin/reboot_bak\n            \"$dir/hfsplus\" Ramdisk.raw mv sbin/halt sbin/halt_bak\n            case $build_id in\n                 \"12\"* | \"13\"* | \"14\"* )\n                    echo '#!/bin/bash' > restored_external\n                    echo \"/sbin/sshd; exec /usr/local/bin/restored_external_o\" >> restored_external\n                    \"$dir/hfsplus\" Ramdisk.raw mv usr/local/bin/restored_external usr/local/bin/restored_external_o\n                    \"$dir/hfsplus\" Ramdisk.raw add restored_external usr/local/bin/restored_external\n                    \"$dir/hfsplus\" Ramdisk.raw chmod 755 usr/local/bin/restored_external\n                    \"$dir/hfsplus\" Ramdisk.raw chown 0:0 usr/local/bin/restored_external\n                ;;\n            esac\n            \"$dir/xpwntool\" Ramdisk.raw Ramdisk.dmg -t RestoreRamdisk.dec\n        fi\n        log \"Patch iBSS\"\n        \"$dir/xpwntool\" iBSS.dec iBSS.raw\n        if [[ $device_type == \"iPhone3,3\" ]]; then\n            case $build_id in\n                8E600 | 8E501 ) device_boot4=1;;\n            esac\n        fi\n        if [[ $build_id == \"8\"* && $device_type == \"iPad2\"* ]] || [[ $device_boot4 == 1 ]]; then\n            \"$dir/iBoot32Patcher\" iBSS.raw iBSS.patched --rsa -b \"-v amfi=0xff cs_enforcement_disable=1\"\n            device_boot4=1\n        else\n            \"$dir/iBoot32Patcher\" iBSS.raw iBSS.patched --rsa -b \"$device_bootargs\"\n        fi\n        \"$dir/xpwntool\" iBSS.patched iBSS -t iBSS.dec\n        if [[ $build_id == \"7\"* || $build_id == \"8\"* ]] && [[ $device_type != \"iPad\"* ]]; then\n            :\n        else\n            log \"Patch iBEC\"\n            \"$dir/xpwntool\" iBEC.dec iBEC.raw\n            if [[ $1 == \"justboot\" ]]; then\n                \"$dir/iBoot32Patcher\" iBEC.raw iBEC.patched --rsa -b \"$device_bootargs\"\n            else\n                \"$dir/iBoot32Patcher\" iBEC.raw iBEC.patched --rsa --debug -b \"rd=md0 -v amfi=0xff amfi_get_out_of_my_way=1 cs_enforcement_disable=1 pio-error=0\"\n            fi\n            \"$dir/xpwntool\" iBEC.patched iBEC -t iBEC.dec\n        fi\n    fi\n\n    if [[ $device_boot4 == 1 ]]; then\n        log \"Patch Kernelcache\"\n        mv Kernelcache.dec Kernelcache0.dec\n        \"$dir/xpwntool\" Kernelcache0.dec Kernelcache.raw\n        $bspatch Kernelcache.raw Kernelcache.patched ../resources/patch/kernelcache.release.${device_model}.${build_id}.patch\n        \"$dir/xpwntool\" Kernelcache.patched Kernelcache.dec -t Kernelcache0.dec\n    fi\n\n    mv iBSS iBEC DeviceTree.dec Kernelcache.dec Ramdisk.dmg $ramdisk_path 2>/dev/null\n\n    if [[ $1 == \"jailbreak\" || $1 == \"justboot\" ]]; then\n        device_enter_mode pwnDFU\n    elif [[ $device_proc == 4 ]] || [[ $device_proc == 6 && $platform == \"macos\" ]]; then\n        device_buttons\n    elif [[ $device_proc == 1 ]]; then\n        device_enter_mode DFU\n    else\n        device_enter_mode kDFU\n    fi\n\n    if [[ $device_type == \"iPad1,1\" && $build_id != \"9\"* ]]; then\n        patch_ibss\n        log \"Sending iBSS...\"\n        $irecovery -f pwnediBSS.dfu\n        sleep 2\n        log \"Sending iBEC...\"\n        $irecovery -f $ramdisk_path/iBEC\n    elif (( device_proc < 5 )) && [[ $device_pwnrec != 1 ]]; then\n        log \"Sending iBSS...\"\n        $irecovery -f $ramdisk_path/iBSS\n    fi\n    sleep 2\n    if [[ $build_id != \"7\"* && $build_id != \"8\"* ]]; then\n        log \"Sending iBEC...\"\n        $irecovery -f $ramdisk_path/iBEC\n        if [[ $device_pwnrec == 1 ]]; then\n            $irecovery -c \"go\"\n        fi\n    fi\n    sleep 3\n    device_find_mode Recovery\n    if [[ $1 != \"justboot\" ]]; then\n        log \"Sending ramdisk...\"\n        $irecovery -f $ramdisk_path/Ramdisk.dmg\n        log \"Running ramdisk\"\n        $irecovery -c \"getenv ramdisk-delay\"\n        $irecovery -c ramdisk\n        sleep 2\n    fi\n    log \"Sending DeviceTree...\"\n    $irecovery -f $ramdisk_path/DeviceTree.dec\n    log \"Running devicetree\"\n    $irecovery -c devicetree\n    log \"Sending KernelCache...\"\n    $irecovery -f $ramdisk_path/Kernelcache.dec\n    $irecovery -c bootx\n\n    if [[ $1 == \"justboot\" ]]; then\n        log \"Device should now boot.\"\n        return\n    fi\n    log \"Booting, please wait...\"\n    sleep 10\n\n    if [[ -n $1 ]]; then\n        device_iproxy\n    else\n        device_iproxy no-logging\n    fi\n    device_sshpass alpine\n\n    local found\n    log \"Waiting for device...\"\n    while [[ $found != 1 ]]; do\n        found=$($ssh -p $ssh_port root@127.0.0.1 \"echo 1\")\n        sleep 1\n    done\n\n    case $mode in\n        \"activation\" | \"baseband\" )\n            return\n        ;;\n\n        \"TwistedMind2\" )\n            log \"Sending TwistedMind2\"\n            $scp -P $ssh_port TwistedMind2 root@127.0.0.1:/\n            log \"Waiting for disks...\"\n            $ssh -p $ssh_port root@127.0.0.1 'while [[ ! $(ls /dev/rdisk* 2>/dev/null) ]]; do :; done'\n            log \"Sending dd command for TwistedMind2\"\n            $ssh -p $ssh_port root@127.0.0.1 \"dd if=/TwistedMind2 of=/dev/rdisk0 bs=8192; reboot_bak\"\n            return\n        ;;\n\n        \"getversion\" )\n            device_ramdisk_iosvers\n            log \"Retrieved the current iOS version\"\n            if [[ -n $device_vers ]]; then\n                print \"* iOS Version: $device_vers ($device_build)\"\n            else\n                warn \"Something wrong happened. Failed to get iOS version.\"\n            fi\n            log \"Done. Proceeding to SSH Ramdisk Menu. You may reboot from there or do other stuff if needed.\"\n            pause\n        ;;\n\n        \"jailbreak\" )\n            local vers\n            local build\n            local untether\n            device_ramdisk_iosvers\n            vers=$device_vers\n            build=$device_build\n            case $vers in\n                9.3.[4231] | 9.3 ) untether=\"untetherhomedepot.tar\";;\n                9.2* | 9.1 ) untether=\"untetherhomedepot921.tar\";;\n                9.0* )       untether=\"everuntether.tar\";;\n                8* )         untether=\"daibutsu/untether.tar\";;\n                7.1* )\n                    case $device_type in\n                        iPod* ) untether=\"panguaxe-ipod.tar\";;\n                        *     ) untether=\"panguaxe.tar\";;\n                    esac\n                ;;\n                7* )         untether=\"evasi0n7-untether.tar\";;\n                6.1.[6543] ) untether=\"p0sixspwn.tar\";;\n                6* )         untether=\"evasi0n6-untether.tar\";;\n                4.2.[8761] | 4.[10]* | 3.2* | 3.1.3 ) untether=\"greenpois0n/${device_type}_${build}.tar\";;\n                5* | 4.[32]* ) untether=\"g1lbertJB/${device_type}_${build}.tar\";;\n                '' )\n                    warn \"Something wrong happened. Failed to get iOS version.\"\n                    print \"* Please reboot the device into normal operating mode, then perform a clean \\\"slide to power off\\\", then try again.\"\n                    $ssh -p $ssh_port root@127.0.0.1 \"reboot_bak\"\n                    return\n                ;;\n                * )\n                    warn \"iOS $vers is not supported for jailbreaking with SSHRD.\"\n                    $ssh -p $ssh_port root@127.0.0.1 \"reboot_bak\"\n                    return\n                ;;\n            esac\n            # use everuntether instead of daibutsu+dsc haxx for a5(x) 8.0-8.2\n            if [[ $device_proc == 5 ]]; then\n                case $vers in\n                    8.[012]* )\n                        ipsw_everuntether=1\n                        untether=\"everuntether.tar\"\n                    ;;\n                esac\n            fi\n            log \"Nice, iOS $vers is compatible.\"\n            log \"Sending $untether\"\n            $scp -P $ssh_port $jelbrek/$untether root@127.0.0.1:/mnt1\n            # 3.1.3-4.1 untether needs to be extracted early (before data partition is mounted)\n            case $vers in\n                4.[10]* | 3.[21]* )\n                    untether=\"${device_type}_${build}.tar\"\n                    log \"Extracting $untether\"\n                    $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /mnt1/$untether -C /mnt1; rm /mnt1/$untether\"\n                ;;\n            esac\n            log \"Mounting data partition\"\n            $ssh -p $ssh_port root@127.0.0.1 \"mount.sh pv\"\n            case $vers in\n                [98]* ) device_send_rdtar fstab8.tar;;\n                7* ) device_send_rdtar fstab7.tar;;\n                6* ) device_send_rdtar fstab_rw.tar;;\n                4.2.[8761] ) $ssh -p $ssh_port root@127.0.0.1 \"[[ ! -e /mnt1/sbin/punchd ]] && mv /mnt1/sbin/launchd /mnt1/sbin/punchd\";;\n                5* | 4.[32]* ) untether=\"${device_type}_${build}.tar\";;\n            esac\n            case $vers in\n                5* ) device_send_rdtar g1lbertJB.tar;;\n                4.2.[8761] | 4.[10]* | 3* )\n                    untether=\"${device_type}_${build}.tar\"\n                    log \"fstab\"\n                    if [[ $device_proc == 1 || $device_type == \"iPod2,1\" ]]; then\n                        $scp -P $ssh_port $jelbrek/fstab_old root@127.0.0.1:/mnt1/private/etc/fstab\n                    else\n                        $scp -P $ssh_port $jelbrek/fstab_new root@127.0.0.1:/mnt1/private/etc/fstab\n                    fi\n                    $ssh -p $ssh_port root@127.0.0.1 \"rm /mnt1/private/var/mobile/Library/Caches/com.apple.mobile.installation.plist\"\n                ;;\n            esac\n            case $vers in\n                8* | 4.[10]* | 3* ) :;;\n                * )\n                    log \"Extracting $untether\"\n                    $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /mnt1/$untether -C /mnt1; rm /mnt1/$untether\"\n                ;;\n            esac\n            case $vers in\n                [543]* ) device_send_rdtar cydiasubstrate.tar;;\n            esac\n            case $vers in\n                3* ) device_send_rdtar cydiahttpatch.tar;;\n            esac\n            if [[ $device_type == \"iPhone2,1\" && $vers == \"4.3\"* ]]; then\n                # 4.3.x 3gs'es have little free space in rootfs. workaround: extract an older strap that takes less space\n                device_send_rdtar freeze5.tar data\n            else\n                device_send_rdtar freeze.tar data\n            fi\n            if [[ $ipsw_openssh == 1 ]]; then\n                device_send_rdtar sshdeb.tar\n            fi\n            if [[ $vers == \"9\"* || $ipsw_everuntether == 1 ]]; then\n                device_send_rdtar daemonloader.tar\n                device_send_rdtar launchctl.tar\n            fi\n            if [[ $vers == \"8\"* && $ipsw_everuntether != 1 ]]; then\n                log \"Sending daibutsu/move.sh\"\n                $scp -P $ssh_port $jelbrek/daibutsu/move.sh root@127.0.0.1:/mnt1\n                log \"Moving files\"\n                $ssh -p $ssh_port root@127.0.0.1 \"bash /mnt1/move.sh; rm /mnt1/move.sh\"\n                untether=\"untether.tar\"\n                log \"Extracting $untether\"\n                $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /mnt1/$untether -C /mnt1; rm /mnt1/$untether\"\n                log \"Running haxx_overwrite --${device_type}_${build}\"\n                $ssh -p $ssh_port root@127.0.0.1 \"/usr/bin/haxx_overwrite --${device_type}_${build}\"\n            else\n                log \"Rebooting\"\n                $ssh -p $ssh_port root@127.0.0.1 \"reboot_bak\"\n            fi\n            log \"Cool, done and jailbroken (hopefully)\"\n            case $vers in\n                [543]* ) warn \"Do not uninstall Cydia Substrate and Substrate Safe Mode in Cydia!\";;\n            esac\n            return\n        ;;\n\n        \"clearnvram\" )\n            log \"Sending command for clearing NVRAM...\"\n            $ssh -p $ssh_port root@127.0.0.1 \"nvram -c\"\n            log \"Done. Proceeding to SSH Ramdisk Menu. You may reboot from there or do other stuff if needed.\"\n            pause\n        ;;\n\n        \"setnvram\" )\n            device_ramdisk_setnvram\n            log \"Done. Proceeding to SSH Ramdisk Menu. You may reboot from there or do other stuff if needed.\"\n            pause\n        ;;\n\n        * ) log \"Device should now boot to SSH ramdisk mode.\";;\n    esac\n    echo\n    print \"* Mount filesystems with this command:\"\n    print \"    mount.sh\"\n    menu_ramdisk\n}\n\ndevice_ramdisk_setnvram() {\n    log \"Sending commands for setting NVRAM variables...\"\n    $ssh -p $ssh_port root@127.0.0.1 \"nvram -c; nvram boot-partition=$rec\"\n    if [[ $rec == 2 ]]; then\n        case $device_type in\n            iPhone3,3 ) $ssh -p $ssh_port root@127.0.0.1 \"nvram boot-ramdisk=/a/b/c/d/e/f/g/h/i/disk.dmg\";;\n            iPad2,4   ) $ssh -p $ssh_port root@127.0.0.1 \"nvram boot-ramdisk=/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/disk.dmg\";;\n            iPhone4,1 ) $ssh -p $ssh_port root@127.0.0.1 \"nvram boot-ramdisk=/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/disk.dmg\";;\n            iPod5,1   ) $ssh -p $ssh_port root@127.0.0.1 \"nvram boot-ramdisk=/a/b/c/d/e/f/g/h/i/j/k/l/m/disk.dmg\";;\n            iPhone5*  )\n                local selection=(\"iOS 7.1.x\" \"iOS 7.0.x\")\n                input \"Select this device's base version:\"\n                select_option \"${selection[@]}\"\n                case $? in\n                    1 ) $ssh -p $ssh_port root@127.0.0.1 \"nvram boot-ramdisk=/a/b/c/d/e/f/g/h/i/j/k/l/m/disk.dmg\";;\n                    * ) $ssh -p $ssh_port root@127.0.0.1 \"nvram boot-ramdisk=/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/disk.dmg\";;\n                esac\n            ;;\n            iPad1,1 | iPod3,1 )\n                device_ramdisk_iosvers\n                if [[ $device_vers == \"3\"* ]]; then\n                    device_ramdisk_ios3exploit\n                fi\n            ;;\n        esac\n    fi\n    log \"Done\"\n}\n\ndevice_ramdisk_ios3exploit() {\n    log \"iOS 3.x detected, running exploit commands\"\n    local offset=\"$($ssh -p $ssh_port root@127.0.0.1 \"echo -e 'p\\nq\\n' | fdisk -e /dev/rdisk0\" | grep AF | head -1)\"\n    offset=\"${offset##*-}\"\n    offset=\"$(echo ${offset%]*} | tr -d ' ')\"\n    offset=$((offset+64))\n    log \"Got offset $offset\"\n    $ssh -p $ssh_port root@127.0.0.1 \"echo -e 'e 3\\nAF\\n\\n${offset}\\n8\\nw\\ny\\nq\\n' | fdisk -e /dev/rdisk0\"\n    echo\n    log \"Writing exploit ramdisk\"\n    $scp -P $ssh_port ../resources/firmware/src/target/$device_model/9B206/exploit root@127.0.0.1:/\n    $ssh -p $ssh_port root@127.0.0.1 \"dd of=/dev/rdisk0s3 if=/exploit bs=64k count=1\"\n    if [[ $device_type == \"iPad1,1\" ]]; then\n        $scp -P $ssh_port ../saved/iPad1,1/iBoot3_$device_ecid root@127.0.0.1:/mnt1/iBEC\n    fi\n    log \"fstab\"\n    $scp -P $ssh_port $jelbrek/fstab_new root@127.0.0.1:/mnt1/private/etc/fstab\n    case $device_vers in\n        3.1.3 | 3.2* ) opt='y';;\n    esac\n    if [[ $opt == 'y' ]]; then\n        untether=\"${device_type}_${device_build}.tar\"\n        log \"Sending $untether\"\n        $scp -P $ssh_port $jelbrek/greenpois0n/$untether root@127.0.0.1:/mnt1\n        log \"Extracting $untether\"\n        $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /mnt1/$untether -C /mnt1; rm /mnt1/$untether\"\n        log \"Mounting data partition\"\n        $ssh -p $ssh_port root@127.0.0.1 \"mount.sh pv\"\n        device_send_rdtar cydiasubstrate.tar\n        device_send_rdtar cydiahttpatch.tar\n        if [[ $device_vers == \"3.1.3\" || $device_vers == \"3.2\" ]]; then\n            device_send_rdtar freeze.tar data\n        fi\n        if [[ $ipsw_openssh == 1 ]]; then\n            device_send_rdtar sshdeb.tar\n        fi\n    fi\n}\n\ndevice_datetime_cmd() {\n    log \"Running command to Update DateTime\"\n    $ssh -p $ssh_port root@127.0.0.1 \"date -s @$(date +%s)\"\n    if [[ $1 != \"nopause\" ]]; then\n        log \"Done\"\n        pause\n    fi\n}\n\ndevice_ramdisk_iosvers() {\n    device_vers=\n    device_build=\n    device_datetime_cmd nopause\n    if (( device_proc < 7 )); then\n        log \"Mounting root filesystem\"\n        $ssh -p $ssh_port root@127.0.0.1 \"mount.sh root\"\n        sleep 1\n    fi\n    log \"Getting iOS version\"\n    $scp -P $ssh_port root@127.0.0.1:/mnt1/System/Library/CoreServices/SystemVersion.plist .\n    if [[ $platform == \"macos\" ]]; then\n        rm -f BuildVer Version\n        plutil -extract 'ProductVersion' xml1 SystemVersion.plist -o Version\n        device_vers=$(cat Version | sed -ne '/<string>/,/<\\/string>/p' | sed -e \"s/<string>//\" | sed \"s/<\\/string>//\" | sed '2d')\n        plutil -extract 'ProductBuildVersion' xml1 SystemVersion.plist -o BuildVer\n        device_build=$(cat BuildVer | sed -ne '/<string>/,/<\\/string>/p' | sed -e \"s/<string>//\" | sed \"s/<\\/string>//\" | sed '2d')\n    else\n        device_vers=$(cat SystemVersion.plist | grep -i ProductVersion -A 1 | grep -oPm1 \"(?<=<string>)[^<]+\")\n        device_build=$(cat SystemVersion.plist | grep -i ProductBuildVersion -A 1 | grep -oPm1 \"(?<=<string>)[^<]+\")\n    fi\n}\n\nmenu_ramdisk() {\n    local loop\n    local menu_items=(\"Connect to SSH\" \"Dump Blobs\")\n    local reboot=\"reboot_bak\"\n    if (( device_proc >= 7 )); then\n        menu_items+=(\"Dump SEP Firmware\")\n        reboot=\"/sbin/reboot\"\n    else\n        menu_items+=(\"Dump Baseband/Activation\")\n    fi\n    if [[ $1 == \"18C66\" ]]; then\n        menu_items+=(\"Install TrollStore\")\n    elif [[ $device_proc == 7 && $1 == \"12\"* ]]; then\n        log \"Ramdisk should now boot and fix iOS 7 not booting.\"\n    elif (( device_proc <= 8 )); then\n        menu_items+=(\"Erase All (iOS 7 and 8)\")\n    fi\n    if (( device_proc >= 5 )); then\n        menu_items+=(\"Erase All (iOS 9+)\")\n    fi\n    if [[ $device_canpowder == 1 ]]; then\n        menu_items+=(\"Disable/Enable Exploit\")\n    fi\n    menu_items+=(\"Clear NVRAM\" \"Get iOS Version\" \"Update DateTime\" \"Reboot Device\" \"Exit\")\n\n    print \"* For accessing data, note the following:\"\n    print \"* Host: sftp://127.0.0.1 | User: root | Password: alpine | Port: $ssh_port\"\n    echo\n    print \"* Other Useful SSH Ramdisk commands:\"\n    print \"* Clear NVRAM with this command:\"\n    print \"    nvram -c\"\n    print \"* Erase All Content and Settings with this command (iOS 9+ only):\"\n    print \"    nvram oblit-inprogress=5\"\n    print \"* To reboot, use this command:\"\n    print \"    $reboot\"\n    echo\n\n    while [[ $loop != 1 ]]; do\n        mode=\n        print \"* SSH Ramdisk Menu\"\n        while [[ -z $mode ]]; do\n            input \"Select an option:\"\n            select_option \"${menu_items[@]}\"\n            selected=\"${menu_items[$?]}\"\n            case $selected in\n                \"Connect to SSH\" ) mode=\"ssh\";;\n                \"Reboot Device\" ) mode=\"reboot\";;\n                \"Dump Blobs\" ) mode=\"dump-blobs\";;\n                \"Get iOS Version\" ) mode=\"iosvers\";;\n                \"Dump Baseband/Activation\" ) mode=\"dump-bbactrec\";;\n                \"Install TrollStore\" ) mode=\"trollstore\";;\n                \"Erase All (iOS 7 and 8)\" ) mode=\"erase78\";;\n                \"Erase All (iOS 9+)\" ) mode=\"erase9\";;\n                \"Clear NVRAM\" ) mode=\"clearnvram\";;\n                \"Dump SEP Firmware\" ) mode=\"dump-sep\";;\n                \"Disable/Enable Exploit\" ) menu_remove4;;\n                \"Update DateTime\" ) mode=\"datetime\";;\n                \"Exit\" ) mode=\"exit\";;\n            esac\n        done\n\n        case $mode in\n            \"ssh\" )\n                log \"Use the \\\"exit\\\" command to go back to SSH Ramdisk Menu\"\n                if (( device_proc >= 7 )) && [[ $1 == \"12\"* ]]; then\n                    $ssh -p $ssh_port root@127.0.0.1 &\n                    ssh_pid=$!\n                    sleep 1\n                    kill $ssh_pid\n                fi\n                $ssh -p $ssh_port root@127.0.0.1\n            ;;\n            \"reboot\" ) $ssh -p $ssh_port root@127.0.0.1 \"$reboot\"; loop=1;;\n            \"exit\" ) loop=1;;\n            \"dump-blobs\" )\n                local shsh=\"../saved/shsh/$device_ecid-$device_type-$(date +%Y-%m-%d-%H%M).shsh\"\n                if [[ $1 == \"12\"* ]]; then\n                    warn \"Dumping blobs may fail on iOS 8 ramdisk.\"\n                    print \"* It is recommended to do this on iOS $device_ramdiskver ramdisk instead.\"\n                    select_yesno\n                    if [[ $? != 1 ]]; then\n                        continue\n                    fi\n                elif (( device_proc < 7 )); then\n                    warn \"This is the wrong place to dump onboard blobs for 32-bit devices.\"\n                    print \"* Reboot your device, run the script again and go to Save SHSH Blobs -> Onboard Blobs\"\n                    print \"* For more details, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Saving-onboard-SHSH-blobs-of-current-iOS-version\"\n                    pause\n                    continue\n                fi\n                log \"Attempting to dump blobs\"\n                $ssh -p $ssh_port root@127.0.0.1 \"cat /dev/rdisk1\" | dd of=dump.raw bs=256 count=$((0x4000))\n                if [[ ! -s dump.raw ]]; then\n                    log \"Failed with rdisk1, trying again with rdisk2...\"\n                    $ssh -p $ssh_port root@127.0.0.1 \"cat /dev/rdisk2\" | dd of=dump.raw bs=256 count=$((0x4000))\n                    if [[ ! -s dump.raw ]]; then\n                        warn \"Failed with rdisk2, cannot continue.\"\n                        continue\n                    fi\n                fi\n                \"$dir/img4tool\" --convert -s $shsh dump.raw\n                if [[ -s $shsh ]]; then\n                    log \"Onboard blobs should be dumped to $shsh\"\n                    continue\n                fi\n                warn \"Failed to convert raw dump to SHSH.\"\n                local raw=\"../saved/shsh/rawdump_${device_ecid}-${device_type}_$(date +%Y-%m-%d-%H%M).raw\"\n                mv dump.raw $raw\n                log \"Raw dump saved at: $raw\"\n                warn \"This raw dump is not usable for restoring, you need to convert it first.\"\n                print \"* If unable to be converted, this dump is likely not usable for restoring.\"\n            ;;\n            \"iosvers\" )\n                if (( device_proc >= 7 )); then\n                    print \"* Unfortunately the mount command needs to be done manually for 64-bit devices.\"\n                    print \"* The mount command also changes depending on the iOS version (which is what we're trying to get here in the first place)\"\n                    print \"* You need to mount filesystems using the appropriate command before continuing (scroll up to see the commands)\"\n                    warn \"Make sure that you know what you are doing when using this option on 64-bit devices.\"\n                    select_yesno\n                    if [[ $? != 1 ]]; then\n                        continue\n                    fi\n                fi\n                device_ramdisk_iosvers\n                if [[ -n $device_vers ]]; then\n                    log \"Retrieved the current iOS version\"\n                    print \"* iOS Version: $device_vers ($device_build)\"\n                else\n                    warn \"Something wrong happened. Failed to get iOS version.\"\n                fi\n            ;;\n            \"dump-bbactrec\" ) device_dumprd;;\n            \"trollstore\" )\n                print \"* Make sure that your device is on iOS 14 or 15 before continuing.\"\n                print \"* If your device is on iOS 13 or below, TrollStore will NOT work.\"\n                select_yesno\n                if [[ $? != 1 ]]; then\n                    continue\n                fi\n                log \"Checking for latest TrollStore\"\n                local latest=\"$(curl https://api.github.com/repos/opa334/TrollStore/releases/latest | $jq -r \".tag_name\")\"\n                local current=\"$(cat ../saved/TrollStore_version 2>/dev/null || echo \"none\")\"\n                log \"Latest version: $latest, current version: $current\"\n                if [[ $current != \"$latest\" ]]; then\n                    rm -f ../saved/TrollStore.tar ../saved/PersistenceHelper_Embedded\n                fi\n                if [[ -s ../saved/TrollStore.tar && -s ../saved/PersistenceHelper_Embedded ]]; then\n                    cp ../saved/TrollStore.tar ../saved/PersistenceHelper_Embedded .\n                else\n                    rm -f ../saved/TrollStore.tar ../saved/PersistenceHelper_Embedded\n                    log \"Downloading files for latest TrollStore\"\n                    download_file https://github.com/opa334/TrollStore/releases/download/$latest/PersistenceHelper_Embedded PersistenceHelper_Embedded\n                    download_file https://github.com/opa334/TrollStore/releases/download/$latest/TrollStore.tar TrollStore.tar\n                    cp TrollStore.tar PersistenceHelper_Embedded ../saved\n                    echo \"$latest\" > ../saved/TrollStore_version\n                fi\n                tar -xf TrollStore.tar\n                log \"Installing TrollStore to Tips\"\n                $ssh -p $ssh_port root@127.0.0.1 \"mount_filesystems\"\n                local tips=\"$($ssh -p $ssh_port root@127.0.0.1 \"find /mnt2/containers/Bundle/Application/ -name \\\"Tips.app\\\"\")\"\n                $scp -P $ssh_port PersistenceHelper_Embedded TrollStore.app/trollstorehelper ../resources/sshrd/trollstore.sh root@127.0.0.1:$tips\n                rm -r PersistenceHelper_Embedded TrollStore*\n                $ssh -p $ssh_port root@127.0.0.1 \"bash $tips/trollstore.sh; rm $tips/trollstore.sh\"\n                log \"Done!\"\n            ;;\n            \"erase78\" )\n                log \"Please read the message below:\"\n                warn \"This will do a \\\"Erase All Content and Settings\\\" procedure for iOS 7 and 8 devices.\"\n                warn \"Do NOT do this if your device is jailbroken untethered!!!\"\n                print \"* This procedure will do step 6 of this tutorial: https://reddit.com/r/LegacyJailbreak/comments/13of20g/tutorial_new_restoringerasingwipingrescuing_a/\"\n                print \"* Note that it may also be better to do this process manually instead by following the commands in the tutorial.\"\n                print \"* For iOS 8 devices, also remove this file if you will be doing it manually: /mnt2/mobile/Library/SpringBoard/LockoutStateJournal.plist\"\n                if (( device_proc >= 7 )); then\n                    print \"* If your device is on iOS 7, make sure to boot an iOS 8 ramdisk afterwards to fix booting.\"\n                fi\n                print \"* When the device boots back up, trigger a restore by entering wrong passwords 10 times.\"\n                select_yesno\n                if [[ $? != 1 ]]; then\n                    continue\n                fi\n                $ssh -p $ssh_port root@127.0.0.1 \"/sbin/mount_hfs /dev/disk0s1s1 /mnt1; /sbin/mount_hfs /dev/disk0s1s2 /mnt2; cp /com.apple.springboard.plist /mnt1/\"\n                $ssh -p $ssh_port root@127.0.0.1 \"cd /mnt2/mobile/Library/Preferences; mv com.apple.springboard.plist com.apple.springboard.plist.bak; ln -s /com.apple.springboard.plist ./com.apple.springboard.plist\"\n                $ssh -p $ssh_port root@127.0.0.1 \"rm /mnt2/mobile/Library/SpringBoard/LockoutStateJournal.plist\"\n                $ssh -p $ssh_port root@127.0.0.1 \"sync; cd /; /sbin/umount /mnt2; /sbin/umount /mnt1; sync; /sbin/reboot\"\n                log \"Done, your device should reboot now\"\n                print \"* Proceed to trigger a restore by entering wrong passwords 10 times.\"\n                loop=1\n            ;;\n            \"dump-sep\" )\n                log \"Please read the message below:\"\n                print \"* To dump SEP Firmware, do the following:\"\n                print \"    - Mount filesystems using the appropriate command for your iOS version (scroll up to see the commands)\"\n                print \"    - Grab the file sep-firmware.img4 from /mnt1/usr/standalone or /mnt1/usr/standalone/firmware\"\n                print \"* Better do this process manually since Legacy iOS Kit does not know your iOS version\"\n                pause\n            ;;\n            \"clearnvram\" )\n                log \"Sending command for clearing NVRAM...\"\n                $ssh -p $ssh_port root@127.0.0.1 \"/usr/sbin/nvram -c\"\n                log \"Done\"\n            ;;\n            \"erase9\" )\n                warn \"This will do a \\\"Erase All Content and Settings\\\" procedure for iOS 9+ devices.\"\n                warn \"Do NOT do this if your device is jailbroken untethered!!! (mostly iOS 9.3.4/9.1 and lower)\"\n                select_yesno\n                if [[ $? != 1 ]]; then\n                    continue\n                fi\n                log \"Sending command for erasing all content and settings...\"\n                $ssh -p $ssh_port root@127.0.0.1 \"nvram oblit-inprogress=5\"\n                log \"Done. Reboot to apply changes, or clear NVRAM now to cancel erase\"\n            ;;\n            \"remove4\" ) device_ramdisk_setnvram;;\n            \"datetime\" ) device_datetime_cmd;;\n        esac\n    done\n}\n\nshsh_save_onboard64() {\n    print \"* There are other ways for dumping onboard blobs for 64-bit devices as listed below:\"\n    print \"* It is recommended to use SSH Ramdisk option to dump onboard blobs instead: Useful Utilities -> SSH Ramdisk\"\n    print \"* For A8 and newer, you can also use SSHRD_Script: https://github.com/verygenericname/SSHRD_Script\"\n    echo\n    if [[ $device_mode != \"Normal\" ]]; then\n        warn \"Device must be in normal mode and jailbroken, cannot continue.\"\n        print \"* Use the SSH Ramdisk option instead.\"\n        return\n    fi\n    log \"Proceeding to dump onboard blobs on normal mode\"\n    device_ssh_message\n    device_iproxy\n    device_sshpass\n    local shsh=\"../saved/shsh/$device_ecid-$device_type-$device_vers-$device_build.shsh\"\n    $ssh -p $ssh_port root@127.0.0.1 \"cat /dev/disk1\" | dd of=dump.raw bs=256 count=$((0x4000))\n    \"$dir/img4tool\" --convert -s $shsh dump.raw\n    if [[ ! -s $shsh ]]; then\n        warn \"Failed to convert raw dump to SHSH.\"\n        if [[ -s dump.raw ]]; then\n            local raw=\"../saved/shsh/rawdump_${device_ecid}-${device_type}-${device_vers}-${device_build}_$(date +%Y-%m-%d-%H%M).raw\"\n            mv dump.raw $raw\n            log \"Raw dump saved at: $raw\"\n            warn \"This raw dump is not usable for restoring, you need to convert it first.\"\n            print \"* If unable to be converted, this dump is likely not usable for restoring.\"\n        fi\n        error \"Saving onboard SHSH blobs failed.\" \"It is recommended to dump onboard SHSH blobs on SSH Ramdisk instead.\"\n    fi\n    log \"Successfully saved $device_vers blobs: $shsh\"\n}\n\nshsh_save_onboard() {\n    if (( device_proc >= 7 )); then\n        shsh_save_onboard64\n        return\n    elif [[ $device_proc == 4 ]] || [[ $device_proc == 6 && $platform == \"macos\" ]]; then\n        device_buttons\n    else\n        device_enter_mode kDFU\n    fi\n    if [[ $device_proc == 4 && $device_pwnrec != 1 ]]; then\n        patch_ibss\n        log \"Sending iBSS...\"\n        $irecovery -f pwnediBSS.dfu\n    fi\n    sleep 1\n    patch_ibec\n    log \"Sending iBEC...\"\n    $irecovery -f pwnediBEC.dfu\n    if [[ $device_pwnrec == 1 ]]; then\n        $irecovery -c \"go\"\n    fi\n    sleep 3\n    device_find_mode Recovery\n    log \"Dumping raw dump now\"\n    (echo -e \"/send ../resources/payload\\ngo blobs\\n/exit\") | $irecovery2 -s\n    $irecovery2 -g dump.raw\n    log \"Rebooting device\"\n    $irecovery -n\n    local raw\n    local err\n    shsh_convert_onboard $1\n    err=$?\n    if [[ $1 == \"dump\" ]]; then\n        raw=\"../saved/shsh/rawdump_${device_ecid}-${device_type}_$(date +%Y-%m-%d-%H%M)_${shsh_onboard_iboot}.raw\"\n    else\n        raw=\"../saved/shsh/rawdump_${device_ecid}-${device_type}-${device_target_vers}-${device_target_build}_$(date +%Y-%m-%d-%H%M)_${shsh_onboard_iboot}.raw\"\n    fi\n    if [[ $1 == \"dump\" ]] || [[ $err != 0 && -s dump.raw ]]; then\n        mv dump.raw $raw\n        log \"Raw dump saved at: $raw\"\n        warn \"This raw dump is not usable for restoring, you need to convert it first.\"\n        print \"* If unable to be converted, this dump is likely not usable for restoring.\"\n        print \"* For the IPSW to download and use, see the raw dump iBoot version above\"\n        print \"* Then go here to find the matching iOS version: https://theapplewiki.com/wiki/IBoot_(Bootloader)\"\n    fi\n}\n\nshsh_convert_onboard() {\n    local shsh=\"../saved/shsh/${device_ecid}-${device_type}_$(date +%Y-%m-%d-%H%M).shsh\"\n    if (( device_proc < 7 )); then\n        shsh=\"../saved/shsh/${device_ecid}-${device_type}-${device_target_vers}-${device_target_build}.shsh\"\n        # remove ibob for powdersn0w/dra downgraded devices. fixes unknown magic 69626f62\n        local blob=$(xxd -p dump.raw | tr -d '\\n')\n        local bobi=\"626f6269\"\n        local blli=\"626c6c69\"\n        if [[ $blob == *\"$bobi\"* ]]; then\n            log \"Detected \\\"ibob\\\". Fixing... (This happens on DRA/powdersn0w downgraded devices)\"\n            rm -f dump.raw\n            printf \"%s\" \"${blob%\"$bobi\"*}${blli}${blob##*\"$blli\"}\" | xxd -r -p > dump.raw\n        fi\n        shsh_onboard_iboot=\"$(cat dump.raw | strings | grep iBoot | head -1)\"\n        log \"Raw dump iBoot version: $shsh_onboard_iboot\"\n        if [[ $1 == \"dump\" ]]; then\n            return\n        fi\n        log \"Converting raw dump to SHSH blob\"\n        \"$dir/ticket\" dump.raw dump.shsh \"$ipsw_path.ipsw\" -z\n        log \"Attempting to validate SHSH blob\"\n        \"$dir/validate\" dump.shsh \"$ipsw_path.ipsw\" -z\n        if [[ $? != 0 ]]; then\n            warn \"Saved SHSH blobs might be invalid. Did you select the correct IPSW?\"\n        fi\n    else\n        \"$dir/img4tool\" --convert -s dump.shsh dump.raw\n    fi\n    if [[ ! -s dump.shsh ]]; then\n        warn \"Converting onboard SHSH blobs failed.\"\n        return 1\n    fi\n    mv dump.shsh $shsh\n    log \"Successfully saved $device_target_vers blobs: $shsh\"\n}\n\nshsh_save_cydia() {\n    local json=$(curl \"https://api.ipsw.me/v4/device/${device_type}?type=ipsw\")\n    local len=$(echo \"$json\" | $jq -r \".firmwares | length\")\n    local builds=()\n    local i=0\n    while (( i < len )); do\n        builds+=($(echo \"$json\" | $jq -r \".firmwares[$i].buildid\"))\n        ((i++))\n    done\n    for build in ${builds[@]}; do\n        if [[ $build == \"10\"* && $build != \"10B329\" && $build != \"10B350\" ]]; then\n            continue\n        fi\n        printf \"\\n%s \" \"$build\"\n        $tsschecker -d $device_type -e $device_ecid --server-url \"http://cydia.saurik.com/TSS/controller?action=2/\" -s -g 0x1111111111111111 --buildid $build >/dev/null\n        if [[ $(ls *$build* 2>/dev/null) ]]; then\n            printf \"saved\"\n            mv $(ls *$build*) ../saved/shsh/$device_ecid-$device_type-$build.shsh\n        else\n            printf \"failed\"\n        fi\n    done\n    echo\n}\n\nmenu_print_info() {\n    if [[ $debug_mode != 1 ]]; then\n        clear\n    fi\n    print \" *** Legacy iOS Kit ***\"\n    print \" - Script by LukeZGD -\"\n    echo\n    if [[ -n $version_current ]]; then\n        print \"* Version: $version_current ($git_hash)\"\n    fi\n    if [[ $no_version_check == 1 ]]; then\n        warn \"No version check flag detected, update check is disabled and no support will be provided.\"\n    fi\n    if [[ $git_hash_latest != \"$git_hash\" ]]; then\n        warn \"Current version is newer/different than remote: $version_latest ($git_hash_latest)\"\n    fi\n    print \"* Platform: $platform ($platform_ver - $platform_arch) $live_cdusb_str\"\n    echo\n    if [[ $device_argmode == \"entry\" ]]; then\n        warn \"Device type and/or ECID manually specified\"\n    fi\n    print \"* Device: $device_name (${device_type} - ${device_model}ap) in $device_mode mode\"\n    device_manufacturing\n    if [[ $device_unactivated == 1 ]]; then\n        print \"* Device is not activated, select Attempt Activation to activate.\"\n    fi\n    if [[ $device_type == \"$device_disable_bbupdate\" && $device_use_bb != 0 ]] && (( device_proc < 7 )); then\n        warn \"Disable bbupdate flag detected, baseband update is disabled. Proceed with caution\"\n        if [[ $device_deadbb == 1 ]]; then\n            warn \"dead-bb flag detected, baseband dump/stitching is disabled. Your device will not activate after restore\"\n        else\n            print \"* Current device baseband will be dumped and stitched to custom IPSW\"\n            print \"* Stitching is supported in these restores/downgrades: 8.4.1/6.1.3, Other (tethered or with SHSH), powdersn0w\"\n            warn \"Note that stitching baseband does not always work! There is a chance of non-working baseband after the restore\"\n        fi\n    elif [[ -n $device_disable_bbupdate ]]; then\n        warn \"Disable bbupdate flag detected, but this flag is not supported for this device\"\n    fi\n    if [[ -n $device_disable_bbupdate ]]; then\n        print \"* For more details, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Baseband-Update\"\n    fi\n    if [[ $ipsw_jailbreak == 1 ]] && (( device_proc < 7 )); then\n        warn \"Jailbreak flag detected. Jailbreak option enabled.\"\n    fi\n    if [[ $device_proc != 1 ]] && (( device_proc < 7 )); then\n        if [[ $device_actrec == 1 ]]; then\n            warn \"Activation records flag detected. Proceed with caution\"\n            print \"* Stitching is supported in these restores/downgrades: 8.4.1/6.1.3, Other with SHSH, powdersn0w\"\n        fi\n        if [[ $device_pwnrec == 1 ]]; then\n            warn \"Pwned recovery flag detected. Assuming device is in pwned recovery mode.\"\n        elif [[ $device_skip_ibss == 1 ]]; then\n            warn \"Skip iBSS flag detected. Assuming device is in pwned iBSS mode.\"\n        fi\n        if [[ $ipsw_gasgauge_patch == 1 ]]; then\n            warn \"gasgauge-patch flag detected. multipatch enabled.\"\n        fi\n        if [[ $ipsw_skip_first == 1 ]]; then\n            warn \"skip-first flag detected. Skipping first restore and flashing NOR IPSW only for powdersn0w 4.2.x and lower\"\n        fi\n    elif (( device_proc >= 7 )) && (( device_proc <= 10 )); then\n        if [[ $restore_useskipblob == 1 ]]; then\n            warn \"skip-blob flag detected. futurerestore will have --skip-blob enabled.\"\n        fi\n        if [[ $restore_usepwndfu64 == 1 ]]; then\n            warn \"use-pwndfu flag detected. futurerestore will have --use-pwndfu enabled.\"\n        fi\n    fi\n    if [[ -n $device_build ]]; then\n        print \"* iOS Version: $device_vers ($device_build)\"\n    else\n        print \"* iOS Version: $device_vers\"\n    fi\n    if [[ $device_proc != 1 && $device_mode == \"DFU\" ]] && (( device_proc < 7 )); then\n        print \"* To get iOS version, go to: Misc Utilities -> Get iOS Version\"\n    fi\n    if [[ $device_proc != 1 ]]; then\n        print \"* ECID: $device_ecid\"\n    fi\n    if [[ -n $device_pwnd ]]; then\n        print \"* Pwned: $device_pwnd\"\n    fi\n    echo\n}\n\nmenu_main() {\n    local menu_items\n    local selected\n    local back\n    while [[ -z \"$mode\" ]]; do\n        menu_items=()\n        menu_print_info\n        print \" > Main Menu\"\n        input \"Select an option:\"\n        if [[ $device_mode != \"none\" ]]; then\n            menu_items+=(\"Restore/Downgrade\")\n            if (( device_proc < 7 )); then\n                menu_items+=(\"Jailbreak Device\")\n                if [[ $device_proc != 1 && $device_type != \"iPod2,1\" ]]; then\n                    case $device_mode in\n                        \"Recovery\" | \"DFU\" ) menu_items+=(\"Just Boot\");;\n                    esac\n                fi\n            fi\n            if [[ $device_unactivated == 1 ]]; then\n                menu_items+=(\"Attempt Activation\")\n            elif [[ $device_mode == \"Recovery\" ]]; then\n                menu_items+=(\"Exit Recovery Mode\")\n            fi\n            case $device_type in\n                iPad2,[123] ) menu_items+=(\"FourThree Utility\");;\n            esac\n        fi\n        if [[ $device_proc != 1 && $device_type != \"iPod2,1\" ]]; then\n            menu_items+=(\"Save SHSH Blobs\")\n        fi\n        if [[ $device_mode == \"Normal\" ]]; then\n            case $device_vers in\n                [12].*  ) :;;\n                [1289]* ) [[ $platform == \"linux\" ]] && menu_items+=(\"Sideload IPA\");;\n            esac\n            menu_items+=(\"App Management\" \"Data Management\")\n        fi\n        if [[ $device_mode != \"none\" ]]; then\n            menu_items+=(\"Useful Utilities\")\n        fi\n        menu_items+=(\"Misc Utilities\" \"Exit\")\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Restore/Downgrade\" ) menu_restore;;\n            \"Jailbreak Device\" ) device_jailbreak_confirm;;\n            \"Save SHSH Blobs\" ) menu_shsh;;\n            \"Sideload IPA\" ) menu_ipa \"$selected\";;\n            \"App Management\" ) menu_appmanage;;\n            \"Data Management\" ) menu_datamanage;;\n            \"Misc Utilities\" ) menu_miscutilities;;\n            \"Useful Utilities\" ) menu_usefulutilities;;\n            \"FourThree Utility\" ) menu_fourthree;;\n            \"Attempt Activation\" ) device_activate;;\n            \"Exit Recovery Mode\" ) mode=\"exitrecovery\";;\n            \"Just Boot\" ) menu_justboot;;\n            \"Exit\" ) mode=\"exit\";;\n        esac\n    done\n}\n\nmenu_appmanage() {\n    local menu_items\n    local selected\n    local back\n\n    menu_print_info\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Install IPA (AppSync)\" \"List User Apps\" \"List System Apps\" \"List All Apps\" \"Go Back\")\n        print \" > Main Menu > App Management\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Install IPA (AppSync)\" ) menu_ipa \"$selected\";;\n            \"List User Apps\"   ) $ideviceinstaller list --user;;\n            \"List System Apps\" ) $ideviceinstaller list --system;;\n            \"List All Apps\"    ) $ideviceinstaller list --all;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_datamanage() {\n    local menu_items=()\n    local selected\n    local back\n\n    menu_print_info\n    print \"* Note: For \\\"Raw File System\\\" your device must be jailbroken and have AFC2\"\n    print \"*       For most jailbreaks, install \\\"Apple File Conduit 2\\\" in Cydia/Zebra/Sileo\"\n    print \"* Note 2: The \\\"Erase All Content and Settings\\\" option works on iOS 9+ only\"\n    print \"* Note 3: You may need to select Pair Device first to get some options working.\"\n    print \"* Note 4: Backups do not include apps. Only some app data and settings\"\n    print \"* For dumping apps, go to: https://www.reddit.com/r/LegacyJailbreak/wiki/guides/crackingapps\"\n    if (( device_det < 4 )) && [[ $device_det != 1 ]]; then\n        warn \"Device is on lower than iOS 4. Backup and Restore options are not available.\"\n    else\n        menu_items+=(\"Backup\" \"Restore\")\n    fi\n    if [[ -z $ifuse ]]; then\n        warn \"ifuse not installed. Mount Device options are not available. Install ifuse from your package manager to fix this\"\n    else\n        menu_items+=(\"Mount Device\" \"Mount Device (Raw File System)\" \"Unmount Device\")\n    fi\n    menu_items+=(\"Connect to SSH\" \"Cydia App Install\")\n    case $device_det in\n        [91] ) menu_items+=(\"Erase All Content and Settings\");;\n    esac\n    menu_items+=(\"Pair Device\" \"Go Back\")\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        echo\n        print \" > Main Menu > Data Management\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Go Back\" ) back=1;;\n            \"Backup\"  ) mode=\"device_backup_create\";;\n            \"Restore\" ) menu_backup_restore;;\n            \"Erase All Content and Settings\" ) mode=\"device_erase\";;\n            \"Mount Device\" ) mkdir ../mount 2>/dev/null; $ifuse ../mount; log \"Device (Media) should now be mounted on mount folder\";;\n            \"Mount Device (Raw File System)\" ) mkdir ../mount 2>/dev/null; $ifuse --root ../mount; log \"Device (root) should now be mounted on mount folder\";;\n            \"Unmount Device\" ) log \"Attempting to umount device from mount folder\"; umount ../mount;;\n            \"Connect to SSH\" ) device_ssh;;\n            \"Cydia App Install\" )\n                echo\n                print \"* Cydia App Install: You need to have working AFC2 or SSH for transferring the .deb files to your device.\"\n                print \"* This must be done manually. Place the .deb files you want to install to this path:\"\n                print \"    > /var/root/Media/Cydia/AutoInstall\"\n                print \"* Using the \\\"Mount Device (Raw File System)\\\" or \\\"Connect to SSH\\\" options.\"\n                print \"* Create the folders as needed if they do not exist.\"\n                print \"* Reboot your device after transferring the .deb files to start the installation.\"\n                echo\n            ;;\n            \"Pair Device\" ) device_pair;;\n        esac\n    done\n}\n\nmenu_backup_restore() {\n    local menu_items\n    local selected\n    local back\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_print_info\n        local backupdir=\"../saved/backups/${device_ecid}_${device_type}\"\n        if [[ ! -d $backupdir ]]; then\n            mkdir -p $backupdir\n        fi\n        local backups=($(ls $backupdir 2>/dev/null))\n        if [[ -z \"${backups[*]}\" ]]; then\n            print \"* No backups (saved/backups)\"\n        else\n            print \"* Backups list (saved/backups):\"\n            for b in \"${backups[@]}\"; do\n                menu_items+=(\"$(basename $b)\")\n            done\n        fi\n        menu_items+=(\"Go Back\")\n        echo\n        print \" > Main Menu > Data Management > Restore\"\n        input \"Select option to restore:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Go Back\" ) back=1;;\n            * ) device_backup=\"$selected\"; mode=\"device_backup_restore\";;\n        esac\n    done\n}\n\nmenu_fourthree() {\n    local menu_items\n    local selected\n    local back\n\n    ipa_path=\n    ipsw_fourthree=\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Step 1: Restore\" \"Step 2: Partition\" \"Step 3: OS Install\")\n        if [[ $device_mode == \"Normal\" ]]; then\n            menu_items+=(\"Reinstall App\" \"Boot iOS 4.3.x\")\n        fi\n        menu_items+=(\"Go Back\")\n        menu_print_info\n        print \"* FourThree Utility: Dualboot iPad 2 to iOS 4.3.x\"\n        print \"* This is a 3 step process for the device. Follow through the steps to successfully set up a dualboot.\"\n        print \"* Please read the README here: https://github.com/LukeZGD/FourThree-iPad2\"\n        echo\n        print \" > Main Menu > FourThree Utility\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Step 1: Restore\" ) ipsw_fourthree=1; menu_ipsw \"iOS 6.1.3\" \"fourthree\";;\n            \"Step 2: Partition\" ) mode=\"device_fourthree_step2\";;\n            \"Step 3: OS Install\" ) mode=\"device_fourthree_step3\";;\n            \"Reinstall App\" ) mode=\"device_fourthree_app\";;\n            \"Boot iOS 4.3.x\" ) mode=\"device_fourthree_boot\";;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_ipa() {\n    local menu_items\n    local selected\n    local back\n\n    ipa_path=\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Select IPA\")\n        menu_print_info\n        if [[ $1 == \"Install\"* ]]; then\n            print \"* Make sure that AppSync Unified (iOS 5+) is installed on your device.\"\n            print \"* Install IPA (AppSync) will not work if your device is not activated.\"\n        else\n            print \"* Sideload IPA is for iOS 9 and newer only. Sideloading will require an Apple ID.\"\n            print \"* Your Apple ID and password will only be sent to Apple servers.\"\n            print \"* Make sure that the device is activated and connected to the Internet.\"\n            print \"* There is also the option to use Dadoum Sideloader: https://github.com/Dadoum/Sideloader\"\n            print \"* If you have AppSync installed, go to App Management -> Install IPA (AppSync) instead.\"\n            if [[ $platform == \"macos\" ]]; then\n                echo\n                warn \"\\\"Sideload IPA\\\" is not supported on macOS.\"\n                print \"* Use Sideloadly or AltServer instead for this.\"\n                print \"* You also might be looking for the \\\"Install IPA (AppSync)\\\" option instead.\"\n                print \"* You can find it by going to App Management.\"\n                pause\n                break\n            fi\n        fi\n        echo\n        if [[ -n $ipa_path ]]; then\n            print \"* Selected IPA: $ipa_path\"\n            menu_items+=(\"Install IPA\")\n        elif [[ $1 == \"Install\"* ]]; then\n            print \"* Select IPA file(s) to install (multiple selection)\"\n        else\n            print \"* Select IPA file to install (or select Use Dadoum Sideloader)\"\n            menu_items+=(\"Use Dadoum Sideloader\")\n        fi\n        menu_items+=(\"Go Back\")\n        echo\n        print \" > Main Menu > $1\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Select IPA\" ) menu_ipa_browse;;\n            \"Install IPA\" )\n                if [[ $1 == \"Install\"* ]]; then\n                    mode=\"device_ideviceinstaller\"\n                else\n                    mode=\"device_altserver\"\n                fi\n            ;;\n            \"Use Dadoum Sideloader\" )\n                local arch=\"$platform_arch\"\n                local sideloader=\"sideloader-gtk-\"\n                case $arch in\n                    \"armhf\" )\n                        warn \"Dadoum Sideloader does not support armhf/armv7. arm64 or x86_64 only.\"\n                        pause\n                        continue\n                    ;;\n                    \"arm64\" ) arch=\"aarch64\";;\n                esac\n                sideloader+=\"$arch-linux-gnu\"\n                log \"Checking for latest Sideloader\"\n                local latest=\"$(curl https://api.github.com/repos/Dadoum/Sideloader/releases | $jq -r \".[0].tag_name\")\"\n                local current=\"$(cat ../saved/Sideloader_version 2>/dev/null || echo \"none\")\"\n                log \"Latest version: $latest, current version: $current\"\n                if [[ $current != \"$latest\" ]]; then\n                    rm -f ../saved/$sideloader\n                fi\n                if [[ ! -e ../saved/$sideloader ]]; then\n                    download_file https://github.com/Dadoum/Sideloader/releases/download/$latest/$sideloader.zip $sideloader.zip\n                    unzip -o -j $sideloader.zip $sideloader -d ../saved\n                fi\n                echo \"$latest\" > ../saved/Sideloader_version\n                device_pair\n                log \"Launching Dadoum Sideloader\"\n                chmod +x ../saved/$sideloader\n                ../saved/$sideloader\n            ;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_zenity_check() {\n    if [[ $platform == \"linux\" && ! $(command -v zenity) ]]; then\n        warn \"zenity not found in PATH. Install zenity to have a working file picker.\"\n    fi\n}\n\nmenu_ipa_browse() {\n    local newpath\n    input \"Select your IPA file(s) in the file selection window.\"\n    if [[ $mac_cocoa == 1 ]]; then\n        newpath=\"$($cocoadialog fileselect --with-extensions ipa)\"\n    else\n        menu_zenity_check\n        newpath=\"$($zenity --file-selection --multiple --file-filter='IPA | *.ipa' --title=\"Select IPA file(s)\")\"\n    fi\n    [[ -z \"$newpath\" ]] && read -p \"$(input \"Enter path to IPA file (or press Enter/Return or Ctrl+C to cancel): \")\" newpath\n    ipa_path=\"$newpath\"\n}\n\nmenu_shsh() {\n    local menu_items\n    local selected\n    local back\n\n    device_target_vers=\n    device_target_build=\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=()\n        case $device_type in\n            iPad4,[12345] | iPhone6,[12] )\n                menu_items+=(\"iOS 10.3.3\");;\n            iPad[23]* | iPhone4,1 | iPhone5,[12] | iPod5,1 )\n                menu_items+=(\"iOS 8.4.1\");;\n        esac\n        case $device_type in\n            iPad2,[123] | iPhone4,1 )\n                menu_items+=(\"iOS 6.1.3\");;\n        esac\n        if (( device_proc < 7 )); then\n            menu_items+=(\"Cydia Blobs\")\n        fi\n        if [[ $device_mode != \"none\" ]]; then\n            menu_items+=(\"Onboard Blobs\")\n            if (( device_proc < 7 )); then\n                menu_items+=(\"Onboard Blobs (Raw Dump)\")\n            fi\n        fi\n        menu_items+=(\"Convert Raw Dump\" \"Go Back\")\n        menu_print_info\n        if [[ $device_mode != \"none\" && $device_proc == 4 ]]; then\n            warn \"Dumping onboard blobs might not work for this device, proceed with caution\"\n            print \"* Legacy iOS Kit only fully supports dumping onboard blobs for A5(X) and A6(X) devices and newer\"\n            echo\n        fi\n        print \" > Main Menu > Save SHSH Blobs\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"iOS 10.3.3\" )\n                device_target_vers=\"10.3.3\"\n                device_target_build=\"14G60\"\n            ;;\n            \"iOS 8.4.1\" )\n                device_target_vers=\"8.4.1\"\n                device_target_build=\"12H321\"\n            ;;\n            \"iOS 6.1.3\" )\n                device_target_vers=\"6.1.3\"\n                device_target_build=\"10B329\"\n            ;;\n        esac\n        case $selected in\n            \"iOS\"* ) mode=\"save-ota-blobs\";;\n            \"Onboard Blobs\" ) menu_shsh_onboard;;\n            \"Onboard Blobs (Raw Dump)\" )\n                print \"* This option will save onboard blobs of your device, but only as a raw dump. You will need to convert them to be usable.\"\n                print \"* This option is useful for determining the iBoot version of your device first, to get the correct IPSW for conversion.\"\n                print \"* See the Convert Raw Dump option for converting raw dumps to usable SHSH blobs.\"\n                select_yesno\n                if [[ $? != 1 ]]; then\n                    continue\n                fi\n                mode=\"save-onboard-dump\"\n            ;;\n\n            \"Cydia Blobs\" )\n                print \"* This option will check if this device has saved blobs in Cydia servers, and proceed to save them if there are any.\"\n                select_yesno\n                if [[ $? != 1 ]]; then\n                    continue\n                fi\n                mode=\"save-cydia-blobs\"\n            ;;\n            \"Convert Raw Dump\" ) menu_shsh_convert;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_shsh_onboard() {\n    local menu_items\n    local selected\n    local back\n\n    ipsw_path=\n    if (( device_proc >= 7 )); then\n        mode=\"save-onboard-blobs\"\n    fi\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Select IPSW\")\n        menu_print_info\n        if [[ $device_mode != \"none\" && $device_proc == 4 ]]; then\n            warn \"Dumping onboard blobs might not work for this device, proceed with caution\"\n            print \"* Legacy iOS Kit only fully supports dumping onboard blobs for A5(X) and A6(X) devices and newer\"\n            echo\n        fi\n        if [[ -n $ipsw_path ]]; then\n            print \"* Selected IPSW: $ipsw_path.ipsw\"\n            print \"* IPSW Version: $device_target_vers-$device_target_build\"\n            if [[ $device_mode == \"Normal\" && $device_target_vers != \"$device_vers\" ]]; then\n                warn \"Selected IPSW does not seem to match the current version.\"\n                if (( device_proc < 7 )); then\n                    print \"* Ignore this warning if this is a DRA/powdersn0w downgraded device.\"\n                fi\n            fi\n            menu_items+=(\"Save Onboard Blobs\")\n        else\n            print \"* Select IPSW of your current iOS version to continue\"\n        fi\n        menu_items+=(\"Go Back\")\n        echo\n        print \" > Main Menu > Save SHSH Blobs > Onboard Blobs\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Select IPSW\" ) menu_ipsw_browse;;\n            \"Save Onboard Blobs\" ) mode=\"save-onboard-blobs\";;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_shsh_convert() {\n    local menu_items\n    local selected\n    local back\n\n    ipsw_path=\n    shsh_path=\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Select Raw Dump\")\n        menu_print_info\n        if [[ -n $shsh_path ]]; then\n            print \"* Selected dump: $shsh_path\"\n            if (( device_proc < 7 )); then\n                shsh_onboard_iboot=\"$(cat \"$shsh_path\" | strings | grep iBoot | head -1)\"\n                print \"* Raw dump iBoot version: $shsh_onboard_iboot\"\n                print \"* Go here to find the matching iOS version: https://theapplewiki.com/wiki/IBoot_(Bootloader)\"\n                menu_items+=(\"Select IPSW\")\n            else\n                menu_items+=(\"Convert Raw Dump\")\n            fi\n        else\n            print \"* Select raw dump file to continue\"\n        fi\n        if [[ -n $ipsw_path ]]; then\n            echo\n            print \"* Selected IPSW: $ipsw_path.ipsw\"\n            print \"* IPSW Version: $device_target_vers-$device_target_build\"\n            menu_items+=(\"Convert Raw Dump\")\n        elif (( device_proc < 7 )); then\n            echo\n            print \"* Select IPSW of the raw dump's iOS version to continue\"\n        fi\n        menu_items+=(\"Go Back\")\n        echo\n        print \" > Main Menu > Save SHSH Blobs > Convert Raw Dump\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Select IPSW\" ) menu_ipsw_browse;;\n            \"Select Raw Dump\" ) menu_shshdump_browse;;\n            \"Convert Raw Dump\" ) mode=\"convert-onboard-blobs\";;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_restore() {\n    local menu_items\n    local selected\n    local back\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=()\n        case $device_type in\n            iPad4,[12345] | iPhone6,[12] )\n                menu_items+=(\"iOS 10.3.3\");;\n            iPad2,[1234567] | iPad3,[123456] | iPhone4,1 | iPhone5,[12] | iPod5,1 )\n                menu_items+=(\"iOS 8.4.1\");;\n        esac\n        case $device_type in\n            iPad2,[123] | iPhone4,1 )\n                menu_items+=(\"iOS 6.1.3\");;\n            iPhone2,1 )\n                menu_items+=(\"5.1.1\" \"4.3.3\" \"4.1\" \"3.1.3\" \"More versions\");;\n            iPod3,1 )\n                menu_items+=(\"4.1\");;\n            iPhone1,2 | iPod2,1 )\n                menu_items+=(\"4.1\" \"3.1.3\");;\n        esac\n        case $device_type in\n            iPhone3,[13] | iPad1,1 | iPod3,1 )\n                menu_items+=(\"powdersn0w (any iOS)\");;\n        esac\n        if (( device_proc < 7 )); then\n            menu_items+=(\"Latest iOS ($device_latest_vers)\")\n        elif [[ $platform == \"linux\" ]]; then\n            if (( device_proc > 10 )); then\n                menu_items+=(\"Latest iOS\")\n            else\n                menu_items+=(\"Latest iOS ($device_latest_vers)\")\n            fi\n        fi\n        if [[ $device_canpowder == 1 && $device_proc != 4 ]]; then\n            local text2=\"7.1.x\"\n            case $device_type in\n                iPhone5,[1234] ) text2=\"7.x\";;\n            esac\n            menu_items+=(\"Other (powdersn0w $text2 blobs)\")\n        fi\n        if [[ $1 != \"ipsw\" ]] && (( device_proc < 5 )); then\n            menu_items+=(\"Other (Custom IPSW)\")\n        fi\n        if [[ $device_proc != 1 ]]; then\n            if [[ $device_type != \"iPod2,1\" ]] && (( device_proc <= 10 )); then\n                menu_items+=(\"Other (Use SHSH Blobs)\")\n            fi\n            if (( device_proc >= 7 )) && (( device_proc <= 10 )); then\n                menu_items+=(\"Set Nonce Only\")\n            elif [[ $device_proc == 5 || $device_proc == 6 ]]; then\n                menu_items+=(\"Other (Tethered)\")\n            fi\n            case $device_type in\n                iPhone3,[23] | iPod[34],1 ) menu_items+=(\"Other (Tethered)\");;\n            esac\n            if (( device_proc < 7 )); then\n                menu_items+=(\"DFU IPSW\")\n            fi\n        fi\n        menu_items+=(\"IPSW Downloader\" \"Go Back\")\n        menu_print_info\n        if [[ $1 == \"ipsw\" ]]; then\n            print \" > Main Menu > Misc Utilities > Create Custom IPSW\"\n        else\n            print \" > Main Menu > Restore/Downgrade\"\n            if [[ $device_proc == 1 ]]; then\n                print \"* Select \\\"Other (Custom IPSW)\\\" to restore to other iOS versions (2.0 to 3.1.2)\"\n                echo\n            elif [[ $device_type == \"iPod2,1\" ]]; then\n                print \"* Select \\\"Other (Custom IPSW)\\\" to restore to other iOS versions (2.1.1 to 3.0)\"\n                echo\n            fi\n            if [[ $device_type == \"iPod2,1\" || $device_type == \"iPhone2,1\" ]] && [[ $device_newbr != 0 ]]; then\n                print \"* New bootrom devices might be incompatible with older iOS versions\"\n                echo\n            fi\n        fi\n        case $device_type in\n            iPad2,4      ) print \"* iPad2,4 does not support 6.1.3 downgrades, you need blobs for 6.1.3 or 7.1.x\"; echo;;\n            iPhone5,[34] ) print \"* iPhone 5C does not support 8.4.1 downgrades, you need blobs for 8.4.1 or 7.x\"; echo;;\n            iPhone3,2    ) print \"* iPhone3,2 does not support downgrades with powdersn0w\"; echo;;\n            iPod4,1      ) print \"* iPod touch 4 does not support any untethered downgrades without blobs\"; echo;;\n        esac\n        if [[ $platform == \"macos\" ]] && (( device_proc >= 7 )); then\n            print \"* Note: Restoring to latest iOS for 64-bit devices is not supported on macOS, use iTunes/Finder instead for that\"\n            if [[ $mac_cocoa == 1 ]]; then\n                warn \"Restoring 64-bit devices is broken on OS X 10.11 El Capitan. Use macOS 10.12 Sierra or newer for this.\"\n                pause\n                break\n            fi\n            echo\n        fi\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"\" ) :;;\n            \"Go Back\" ) back=1;;\n            \"Other (Custom IPSW)\" ) restore_customipsw_confirm;;\n            \"DFU IPSW\" )\n                if [[ $1 == \"ipsw\" ]]; then\n                    mode=\"dfuipswipsw\"\n                else\n                    device_dfuipsw_confirm\n                fi\n            ;;\n            \"More versions\" ) menu_restore_more \"$1\";;\n            \"Latest iOS\" ) mode=\"restore-latest\";;\n            \"IPSW Downloader\" ) menu_ipsw_downloader \"$1\";;\n            * ) menu_ipsw \"$selected\" \"$1\";;\n        esac\n    done\n}\n\nmenu_ipsw_downloader() {\n    local menu_items\n    local selected\n    local back\n    local vers\n\n    while [[ -z \"$back\" ]]; do\n        menu_items=(\"Enter Build Version\")\n        if [[ -n $vers ]]; then\n            menu_items+=(\"Start Download\")\n        fi\n        menu_items+=(\"Go Back\")\n        menu_print_info\n        if [[ $1 == \"ipsw\" ]]; then\n            print \" > Main Menu > Misc Utilities > Create Custom IPSW > IPSW Downloader\"\n        else\n            print \" > Main Menu > Restore/Downgrade > IPSW Downloader\"\n        fi\n        print \"* To know more about build version, go here: https://theapplewiki.com/wiki/Firmware\"\n        if [[ -n $vers ]]; then\n            print \"* Build Version entered: $vers\"\n        else\n            print \"* Enter build version to continue\"\n        fi\n        echo\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Enter Build Version\" )\n                print \"* Enter the build version of the IPSW you want to download.\"\n                device_enter_build\n                vers=\"$device_rd_build\"\n            ;;\n            \"Start Download\" )\n                device_target_build=\"$vers\"\n                ipsw_download\n                log \"IPSW downloading is done\"\n                pause\n            ;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_restore_more() {\n    local menu_items\n    local selected\n    local back\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=()\n        case $device_type in\n            iPhone2,1 )\n                menu_items+=(\"6.1.3\" \"6.1.2\" \"6.1\" \"6.0.1\" \"6.0\" \"5.1\" \"5.0.1\" \"5.0\")\n                menu_items+=(\"4.3.5\" \"4.3.4\" \"4.3.2\" \"4.3.1\" \"4.3\" \"4.2.1\")\n                menu_items+=(\"4.0.2\" \"4.0.1\" \"4.0\" \"3.1.2\" \"3.1\" \"3.0.1\" \"3.0\")\n            ;;\n            iPod2,1 ) menu_items+=(\"4.0.2\" \"4.0\" \"3.1.2\" \"3.1.1\");;\n        esac\n        menu_items+=(\"Go Back\")\n        menu_print_info\n        if [[ $1 == \"ipsw\" ]]; then\n            print \" > Main Menu > Misc Utilities > Create Custom IPSW\"\n        else\n            print \" > Main Menu > Restore/Downgrade\"\n        fi\n        if [[ -z $1 && $device_type == \"iPod2,1\" && $device_newbr != 0 ]]; then\n            warn \"These versions are for old bootrom devices only. They may not work on your device\"\n            echo\n        elif [[ $device_type == \"iPod2,1\" ]]; then\n            warn \"These versions might not restore/boot properly\"\n            echo\n        fi\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"\" ) :;;\n            \"Go Back\" ) back=1;;\n            * ) menu_ipsw \"$selected\" \"$1\";;\n        esac\n    done\n}\n\nipsw_latest_set() {\n    local newpath\n    case $device_type in\n        iPad3,[456]    ) newpath=\"iPad_32bit\";;\n        iPad4,[123456] ) newpath=\"iPad_64bit\";;\n        iPad6,[34]     ) newpath=\"iPadPro_9.7\";;\n        iPad6,[78]     ) newpath=\"iPadPro_12.9\";;\n        iPad6,1[12]    ) newpath=\"iPad_64bit_TouchID_ASTC\";;\n        iPhone5,[1234] ) newpath=\"iPhone_4.0_32bit\";;\n        iPhone10,[36]  ) newpath=\"iPhone10,3,iPhone10,6\";;\n        iPod[79],1     ) newpath=\"iPodtouch\";;\n        iPad4,[789] | iPad5*     ) newpath=\"iPad_64bit_TouchID\";;\n        iPhone6,[12] | iPhone8,4 ) newpath=\"iPhone_4.0_64bit\";;\n        iPhone7,1 | iPhone8,2    ) newpath=\"iPhone_5.5\";;\n        iPhone7,2 | iPhone8,1    ) newpath=\"iPhone_4.7\";;\n        iPhone9,[13] | iPhone10,[14] ) newpath=\"iPhone_4.7_P3\";;\n        iPhone9,[24] | iPhone10,[25] ) newpath=\"iPhone_5.5_P3\";;\n        * ) newpath=\"${device_type}\";;\n    esac\n    device_type2=\"$newpath\"\n    newpath+=\"_${device_target_vers}_${device_target_build}\"\n    ipsw_custom_set $newpath\n    ipsw_dfuipsw=\"../${newpath}_DFUIPSW\"\n    newpath+=\"_Restore\"\n    ipsw_latest_path=\"$newpath\"\n}\n\nipsw_hwmodel_set() {\n    local hwmodel\n    case $device_type in\n        iPhone5,[12] ) hwmodel=\"iphone5\";;\n        iPhone5,[34] ) hwmodel=\"iphone5b\";;\n        iPad3,[456] ) hwmodel=\"ipad3b\";;\n        iPhone6*    ) hwmodel=\"iphone6\";;\n        iPhone7*    ) hwmodel=\"iphone7\";;\n        iPhone8,4   ) hwmodel=\"iphone8b\";;\n        iPhone8*    ) hwmodel=\"iphone8\";;\n        iPhone9*    ) hwmodel=\"iphone9\";;\n        iPad4,[123] ) hwmodel=\"ipad4\";;\n        iPad4,[456] ) hwmodel=\"ipad4b\";;\n        iPad4,[789] ) hwmodel=\"ipad4bm\";;\n        iPad5,[12]  ) hwmodel=\"ipad5\";;\n        iPad5,[34]  ) hwmodel=\"ipad5b\";;\n        iPad6,[34]  ) hwmodel=\"ipad6b\";;\n        iPad6,[78]  ) hwmodel=\"ipad6d\";;\n        *           ) hwmodel=\"$device_model\";;\n    esac\n    ipsw_hwmodel=\"$hwmodel\"\n}\n\nmenu_ipsw() {\n    local menu_items\n    local selected\n    local back\n    local newpath\n    local nav\n    local start\n\n    if [[ $2 == \"ipsw\" ]]; then\n        nav=\" > Main Menu > Misc Utilities > Create Custom IPSW > $1\"\n        start=\"Create IPSW\"\n    elif [[ $2 == \"fourthree\" ]]; then\n        nav=\" > Main Menu > FourThree Utility > Step 1: Restore\"\n        start=\"Start Restore\"\n    elif [[ $1 == \"Set Nonce Only\" ]]; then\n        nav=\" > Main Menu > Restore/Downgrade > $1\"\n        start=\"Set Nonce\"\n        device_target_setnonce=1\n    else\n        nav=\" > Main Menu > Restore/Downgrade > $1\"\n        start=\"Start Restore\"\n    fi\n\n    ipsw_cancustomlogo=\n    ipsw_cancustomlogo2=\n    ipsw_customlogo=\n    ipsw_customrecovery=\n    ipsw_path=\n    ipsw_base_path=\n    shsh_path=\n    device_target_vers=\n    device_target_build=\n    device_base_vers=\n    device_base_build=\n    device_target_other=\n    device_target_powder=\n    device_target_tethered=\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        case $1 in\n            \"iOS 10.3.3\" )\n                device_target_vers=\"10.3.3\"\n                device_target_build=\"14G60\"\n            ;;\n            \"iOS 8.4.1\" )\n                device_target_vers=\"8.4.1\"\n                device_target_build=\"12H321\"\n            ;;\n            \"iOS 6.1.3\" )\n                device_target_vers=\"6.1.3\"\n                device_target_build=\"10B329\"\n            ;;\n            \"Latest iOS\"* )\n                device_target_vers=\"$device_latest_vers\"\n                device_target_build=\"$device_latest_build\"\n                case $device_latest_vers in\n                    [643]* ) ipsw_canhacktivate=1;;\n                esac\n            ;;\n            [6543]* )\n                device_target_vers=\"$1\"\n                if [[ $device_target_vers != \"3.0\"* ]]; then\n                    ipsw_canhacktivate=1\n                fi\n                if [[ $device_type == \"iPhone2,1\" && $1 != \"4.1\" ]] ||\n                   [[ $device_type == \"iPod2,1\" && $device_newbr == 0 && $1 == \"3.1.3\" ]]; then\n                    ipsw_cancustomlogo=1\n                fi\n            ;;\n        esac\n        if [[ $device_type != \"iPhone\"* ]]; then\n            ipsw_canhacktivate=\n        fi\n        if [[ $device_proc == 1 ]]; then\n            ipsw_cancustomlogo=1\n        fi\n        case $1 in\n            \"6.1.3\" ) device_target_build=\"10B329\";;\n            \"6.1.2\" ) device_target_build=\"10B146\";;\n            \"6.1\"   ) device_target_build=\"10B141\";;\n            \"6.0.1\" ) device_target_build=\"10A523\";;\n            \"6.0\"   ) device_target_build=\"10A403\";;\n            \"5.1.1\" ) device_target_build=\"9B206\";;\n            \"5.1\"   ) device_target_build=\"9B176\";;\n            \"5.0.1\" ) device_target_build=\"9A405\";;\n            \"5.0\"   ) device_target_build=\"9A334\";;\n            \"4.3.5\" ) device_target_build=\"8L1\";;\n            \"4.3.4\" ) device_target_build=\"8K2\";;\n            \"4.3.3\" ) device_target_build=\"8J2\";;\n            \"4.3.2\" ) device_target_build=\"8H7\";;\n            \"4.3.1\" ) device_target_build=\"8G4\";;\n            \"4.3\"   ) device_target_build=\"8F190\";;\n            \"4.2.1\" )\n                device_target_build=\"8C148\"\n                if [[ $device_type == \"iPhone2,1\" ]]; then\n                    device_target_build+=\"a\"\n                fi\n            ;;\n            \"4.1\"   ) device_target_build=\"8B117\";;\n            \"4.0.2\" ) device_target_build=\"8A400\";;\n            \"4.0.1\" ) device_target_build=\"8A306\";;\n            \"4.0\"   ) device_target_build=\"8A293\";;\n            \"3.1.3\" ) device_target_build=\"7E18\";;\n            \"3.1.2\" ) device_target_build=\"7D11\";;\n            \"3.1.1\" ) device_target_build=\"7C145\";;\n            \"3.1\"   ) device_target_build=\"7C144\";;\n            \"3.0.1\" ) device_target_build=\"7A400\";;\n            \"3.0\"   ) device_target_build=\"7A341\";;\n        esac\n        if [[ $device_target_vers == \"$device_latest_vers\" ]]; then\n            ipsw_latest_set\n            newpath=\"$ipsw_latest_path\"\n        else\n            case $device_type in\n                iPad4,[12345] ) newpath=\"iPad_64bit\";;\n                iPhone6,[12]  ) newpath=\"iPhone_4.0_64bit\";;\n                * ) newpath=\"${device_type}\";;\n            esac\n            newpath+=\"_${device_target_vers}_${device_target_build}\"\n            ipsw_custom_set $newpath\n            newpath+=\"_Restore\"\n        fi\n        if [[ $1 == \"Other (Use SHSH Blobs)\" || $1 == \"Set Nonce Only\" ]]; then\n            device_target_other=1\n            if [[ $device_type == \"iPhone2,1\" ]]; then\n                ipsw_canhacktivate=1\n            fi\n        elif [[ $1 == *\"powdersn0w\"* ]]; then\n            device_target_powder=1\n        elif [[ $1 == *\"Tethered\"* ]]; then\n            device_target_tethered=1\n        elif [[ -n $device_target_vers && -e \"../$newpath.ipsw\" ]]; then\n            ipsw_verify \"../$newpath\" \"$device_target_build\" nopause\n            if [[ $? == 0 ]]; then\n                ipsw_path=\"../$newpath\"\n            fi\n        fi\n\n        menu_items=(\"Select Target IPSW\")\n        menu_print_info\n        print \"* Only select unmodified IPSW for the selection. Do not select custom IPSWs\"\n        echo\n        if [[ $1 == *\"powdersn0w\"* ]]; then\n            menu_items+=(\"Select Base IPSW\")\n            if [[ -n $ipsw_path ]]; then\n                print \"* Selected Target IPSW: $ipsw_path.ipsw\"\n                print \"* Target Version: $device_target_vers-$device_target_build\"\n                ipsw_print_warnings powder\n                ipsw_cancustomlogo2=\n                case $device_target_vers in\n                    [456]* ) ipsw_cancustomlogo2=1;;\n                esac\n            else\n                print \"* Select Target IPSW to continue\"\n                local lo\n                local hi\n                case $device_type in\n                    iPhone3,1 ) lo=4.0; hi=7.1.1;;\n                    iPhone3,3 ) lo=5.0; hi=7.1.1;;\n                    iPhone4,1 | iPad2,[123]    ) lo=5.0; hi=9.3.5;;\n                    iPad2,4 | iPad3,[123]      ) lo=5.1; hi=9.3.5;;\n                    iPhone5,[12] | iPad3,[456] ) lo=6.0; hi=9.3.5;;\n                    iPhone5,[34] ) lo=7.0; hi=9.3.5;;\n                    iPad1,1 ) lo=3.2; hi=5.1;;\n                    iPod3,1 ) lo=4.0; hi=5.1;;\n                esac\n                print \"* Any iOS version from $lo to $hi is supported\"\n            fi\n            echo\n            local text2=\"(iOS 7.1.x)\"\n            case $device_type in\n                iPhone3,[13] ) text2=\"(iOS 7.1.2)\";;\n                iPhone5,[1234] ) text2=\"(iOS 7.x)\";;\n                iPad3,[456] ) text2=\"(iOS 7.0.x)\";;\n                iPad1,1 | iPod3,1 ) text2=\"(iOS 5.1.1)\";;\n            esac\n            if [[ -n $ipsw_base_path ]]; then\n                print \"* Selected Base $text2 IPSW: $ipsw_base_path.ipsw\"\n                print \"* Base Version: $device_base_vers-$device_base_build\"\n                if [[ $ipsw_base_validate == 0 ]]; then\n                    print \"* Selected Base IPSW is validated\"\n                else\n                    warn \"Selected Base IPSW failed validation, proceed with caution\"\n                fi\n                if [[ $device_proc != 4 ]]; then\n                    menu_items+=(\"Select Base SHSH\")\n                fi\n                echo\n            else\n                print \"* Select Base $text2 IPSW to continue\"\n                echo\n            fi\n            if [[ $device_proc == 4 ]]; then\n                shsh_path=1\n            else\n                if [[ -n $shsh_path ]]; then\n                    print \"* Selected Base $text2 SHSH: $shsh_path\"\n                    if [[ $shsh_validate == 0 ]]; then\n                        print \"* Selected SHSH file is validated\"\n                    else\n                        warn \"Selected SHSH file failed validation, proceed with caution\"\n                        if (( device_proc < 5 )); then\n                            warn \"Validation might be a false negative for A4 and older devices.\"\n                        fi\n                        echo\n                    fi\n                elif [[ $2 != \"ipsw\" ]]; then\n                    print \"* Select Base $text2 SHSH to continue\"\n                    echo\n                fi\n            fi\n            if [[ -n $ipsw_path && -n $ipsw_base_path ]] && [[ -n $shsh_path || $2 == \"ipsw\" ]]; then\n                menu_items+=(\"$start\")\n            fi\n\n        elif [[ $2 == \"fourthree\" ]]; then\n            menu_items+=(\"Download Target IPSW\" \"Select Base IPSW\")\n            if [[ -n $ipsw_path ]]; then\n                print \"* Selected Target (iOS 6.1.3) IPSW: $ipsw_path.ipsw\"\n                ipsw_print_warnings\n            else\n                print \"* Select Target (iOS 6.1.3) IPSW to continue\"\n            fi\n            echo\n            if [[ -n $ipsw_base_path ]]; then\n                print \"* Selected Base (iOS 4.3.x) IPSW: $ipsw_base_path.ipsw\"\n                print \"* Base Version: $device_base_vers-$device_base_build\"\n                if [[ $ipsw_base_validate == 0 ]]; then\n                    print \"* Selected Base IPSW is validated\"\n                else\n                    warn \"Selected Base IPSW failed validation, proceed with caution\"\n                fi\n                echo\n            else\n                print \"* Select Base (iOS 4.3.x) IPSW to continue\"\n                echo\n            fi\n            if [[ -n $ipsw_path && -n $ipsw_base_path ]]; then\n                menu_items+=(\"$start\")\n            fi\n\n        elif [[ $1 == *\"Tethered\"* ]]; then\n            if [[ -n $ipsw_path ]]; then\n                print \"* Selected Target IPSW: $ipsw_path.ipsw\"\n                print \"* Target Version: $device_target_vers-$device_target_build\"\n                ipsw_print_warnings\n            else\n                print \"* Select Target IPSW to continue\"\n            fi\n            echo\n            warn \"This is a tethered downgrade. Not recommended unless you know what you are doing.\"\n            print \"* For more info, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Restore-Downgrade and read the \\\"Other (Tethered)\\\" section\"\n            if [[ -n $ipsw_path ]]; then\n                menu_items+=(\"$start\")\n            fi\n            echo\n\n        elif [[ $1 == \"Other\"* || $1 == \"Set Nonce Only\" ]]; then\n            # menu for other (shsh) restores\n            if [[ -n $ipsw_path ]]; then\n                print \"* Selected Target IPSW: $ipsw_path.ipsw\"\n                print \"* Target Version: $device_target_vers-$device_target_build\"\n                ipsw_print_warnings\n                menu_items+=(\"Select Target SHSH\")\n            else\n                print \"* Select Target IPSW to continue\"\n            fi\n            if (( device_proc > 6 )); then\n                print \"* Check the SEP/BB compatibility chart: https://docs.google.com/spreadsheets/d/1Mb1UNm6g3yvdQD67M413GYSaJ4uoNhLgpkc7YKi3LBs\"\n            fi\n            echo\n            if [[ -n $shsh_path ]]; then\n                print \"* Selected Target SHSH: $shsh_path\"\n                if (( device_proc > 6 )); then\n                    shsh_generator=$(cat \"$shsh_path\" | grep \"<string>0x\" | cut -c10-27)\n                    print \"* Generator: $shsh_generator\"\n                fi\n                if [[ $shsh_validate == 0 ]]; then\n                    print \"* Selected SHSH file is validated\"\n                else\n                    warn \"Selected SHSH file failed validation, proceed with caution\"\n                    if (( device_proc >= 7 )); then\n                        print \"* If this is an OTA/onboard/factory blob, it may be fine to use for restoring\"\n                    elif (( device_proc < 5 )); then\n                        warn \"Validation might be a false negative for A4 and older devices.\"\n                    fi\n                    echo\n                fi\n                if (( device_proc >= 7 )); then\n                    print \"* Note: For OTA/onboard/factory blobs, try enabling the skip-blob flag\"\n                    print \"* The skip-blob flag can also help if the restore fails with validated blobs\"\n                fi\n                echo\n\n            elif [[ $2 != \"ipsw\" ]]; then\n                print \"* Select Target SHSH to continue\"\n                echo\n            fi\n            if [[ -n $ipsw_path ]] && [[ -n $shsh_path || $2 == \"ipsw\" ]]; then\n                menu_items+=(\"$start\")\n            fi\n\n        else\n            # menu for ota/latest versions\n            menu_items+=(\"Download Target IPSW\")\n            if [[ -n $ipsw_path ]]; then\n                print \"* Selected Target IPSW: $ipsw_path.ipsw\"\n                ipsw_print_warnings\n                menu_items+=(\"$start\")\n            elif [[ $device_proc == 1 && $device_type != \"iPhone1,2\" ]]; then\n                menu_items+=(\"$start\")\n            else\n                print \"* Select $1 IPSW to continue\"\n            fi\n            if [[ $ipsw_canhacktivate == 1 ]] && [[ $device_type == \"iPhone2,1\" || $device_proc == 1 ]]; then\n                print \"* Hacktivation is supported for this restore\"\n            fi\n            if [[ $device_latest_vers == \"18\"* ]]; then\n                warn \"Restoring to iOS 18 or newer is not supported. Try using pymobiledevice3 instead for that\"\n                pause\n                return\n            fi\n            echo\n        fi\n\n        if [[ $ipsw_cancustomlogo2 == 1 ]]; then\n            print \"* You can select your own custom Apple logo image. This is optional and an experimental option\"\n            print \"* Note: The images must be in PNG format, and up to 320x480 resolution only\"\n            print \"* Note 2: The custom images might not work, current support is spotty\"\n            if [[ -n $ipsw_customlogo ]]; then\n                print \"* Custom Apple logo: $ipsw_customlogo\"\n            else\n                print \"* No custom Apple logo selected\"\n            fi\n            menu_items+=(\"Select Apple Logo\")\n            echo\n        elif [[ $ipsw_cancustomlogo == 1 ]]; then\n            print \"* You can select your own custom logo and recovery image. This is optional and an experimental option\"\n            print \"* Note: The images must be in PNG format, and up to 320x480 resolution only\"\n            print \"* Note 2: The custom images might not work, current support is spotty\"\n            if [[ -n $ipsw_customlogo ]]; then\n                print \"* Custom Apple logo: $ipsw_customlogo\"\n            else\n                print \"* No custom Apple logo selected\"\n            fi\n            if [[ -n $ipsw_customrecovery ]]; then\n                print \"* Custom recovery logo: $ipsw_customrecovery\"\n            else\n                print \"* No custom recovery logo selected\"\n            fi\n            menu_items+=(\"Select Apple Logo\" \"Select Recovery Logo\")\n            echo\n        fi\n        menu_items+=(\"Go Back\")\n\n        if [[ $device_use_bb != 0 && $device_type != \"$device_disable_bbupdate\" ]] &&\n           (( device_proc > 4 )) && (( device_proc < 7 )); then\n            print \"* This restore will use $device_use_vers baseband\"\n            echo\n        elif [[ $device_use_bb2 == 1 ]]; then\n            if [[ $device_target_vers == \"$device_latest_vers\" ]]; then\n                print \"* This restore will use $device_use_vers baseband if the jailbreak option is disabled\"\n                echo\n            elif [[ $device_proc == 1 || $device_target_vers == \"4.1\" ]] && [[ $device_type != \"iPhone3\"* ]]; then\n                print \"* This restore will have baseband update disabled if the jailbreak option is enabled\"\n                echo\n            else\n                print \"* This restore will have baseband update disabled\"\n                echo\n            fi\n        elif [[ $device_use_bb2 == 2 ]]; then\n            if [[ $device_target_vers == \"$device_latest_vers\" ]]; then\n                print \"* This restore will use $device_use_vers baseband\"\n                echo\n            else\n                print \"* This restore will have baseband update disabled\"\n                echo\n            fi\n        fi\n\n        print \"$nav\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Create IPSW\" ) mode=\"custom-ipsw\";;\n            \"$start\" ) mode=\"downgrade\";;\n            \"Select Target IPSW\" ) menu_ipsw_browse \"$1\";;\n            \"Select Base IPSW\" ) menu_ipsw_browse \"base\";;\n            \"Select Target SHSH\" ) menu_shsh_browse \"$1\";;\n            \"Select Base SHSH\" ) menu_shsh_browse \"base\";;\n            \"Download Target IPSW\" ) ipsw_download \"../$newpath\";;\n            \"Select Apple Logo\" ) menu_logo_browse \"boot\";;\n            \"Select Recovery Logo\" ) menu_logo_browse \"recovery\";;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nipsw_print_warnings() {\n    if [[ $ipsw_validate == 0 ]]; then\n        print \"* Selected Target IPSW is validated\"\n    elif [[ $ipsw_isbeta == 1 ]]; then\n        warn \"Selected Target IPSW is a beta version, proceed with caution\"\n    else\n        warn \"Selected Target IPSW failed validation, proceed with caution\"\n    fi\n    if [[ $1 == \"powder\" ]]; then\n        case $device_target_build in\n            8[ABC]* ) warn \"iOS 4.2.1 and lower are hit or miss. It may not restore/boot properly\";;\n            #7[CD]*  ) warn \"Jailbreak option is not supported for this version. It is recommended to select 3.1.3 instead\";;\n            8E* ) warn \"iOS 4.2.x for the CDMA 4 is not supported. It may not restore/boot properly\";;\n            8*  ) warn \"Not all devices support iOS 4 versions. It may not restore/boot properly\";;\n            7B* ) :;;\n            7*  ) warn \"iOS 3.1.x for the touch 3 is not supported. It will get stuck at the activation screen\";;\n        esac\n        return\n    fi\n    case $device_type in\n        \"iPhone3\"* )\n            if [[ $device_target_vers == \"4.2\"* ]]; then\n                warn \"iOS 4.2.x for $device_type might fail to boot after the restore/jailbreak.\"\n                print \"* It is recommended to select another version instead.\"\n            fi\n        ;;\n        \"iPod4,1\" )\n            if [[ $device_target_vers == \"4.2.1\" ]]; then\n                warn \"iOS 4.2.1 for iPod4,1 might fail to boot after the restore/jailbreak.\"\n                print \"* It is recommended to select another version instead.\"\n            elif [[ $device_target_build == \"8B118\" ]]; then\n                warn \"iOS 4.1 (8B118) for iPod4,1 might fail to boot after the restore/jailbreak.\"\n                print \"* It is recommended to select 8B117 or another version instead.\"\n            fi\n        ;;\n        \"iPhone2,1\" )\n            if [[ $device_target_vers == \"3.0\"* && $device_newbr != 0 ]]; then\n                warn \"3.0.x versions are for old bootrom devices only. It will fail to restore/boot if your device is not compatible.\"\n                print \"* It is recommended to select 3.1 or newer instead.\"\n            fi\n        ;;\n    esac\n}\n\nipsw_version_set() {\n    local newpath=\"$1\"\n    local vers\n    local build\n\n    log \"Getting version from IPSW\"\n    unzip -o -j \"$newpath.ipsw\" Restore.plist -d .\n    if [[ $platform == \"macos\" ]]; then\n        rm -f BuildVer Version\n        plutil -extract 'ProductVersion' xml1 Restore.plist -o Version\n        vers=$(cat Version | sed -ne '/<string>/,/<\\/string>/p' | sed -e \"s/<string>//\" | sed \"s/<\\/string>//\" | sed '2d')\n        plutil -extract 'ProductBuildVersion' xml1 Restore.plist -o BuildVer\n        build=$(cat BuildVer | sed -ne '/<string>/,/<\\/string>/p' | sed -e \"s/<string>//\" | sed \"s/<\\/string>//\" | sed '2d')\n    else\n        vers=$(cat Restore.plist | grep -i ProductVersion -A 1 | grep -oPm1 \"(?<=<string>)[^<]+\")\n        build=$(cat Restore.plist | grep -i ProductBuildVersion -A 1 | grep -oPm1 \"(?<=<string>)[^<]+\")\n    fi\n\n    if [[ $2 == \"base\" ]]; then\n        device_base_vers=\"$vers\"\n        device_base_build=\"$build\"\n    else\n        device_target_vers=\"$vers\"\n        device_target_build=\"$build\"\n    fi\n}\n\nipsw_custom_set() {\n    if [[ $ipsw_fourthree == 1 ]]; then\n        ipsw_custom=\"../${device_type}_${device_target_vers}_${device_target_build}_FourThree\"\n        return\n    fi\n\n    ipsw_custom=\"../${device_type}_${device_target_vers}_${device_target_build}_Custom\"\n    if [[ -n $1 ]]; then\n        ipsw_custom=\"../$1_Custom\"\n    fi\n\n    if [[ $device_actrec == 1 ]]; then\n        ipsw_custom+=\"A\"\n    fi\n    if [[ $device_deadbb == 1 ]]; then\n        ipsw_custom+=\"D\"\n    elif [[ $device_type == \"$device_disable_bbupdate\" ]]; then\n        ipsw_custom+=\"B\"\n    fi\n    if [[ $ipsw_gasgauge_patch == 1 ]]; then\n        ipsw_custom+=\"G\"\n    fi\n    if [[ $ipsw_hacktivate == 1 ]]; then\n        ipsw_custom+=\"H\"\n    fi\n    if [[ $ipsw_jailbreak == 1 ]]; then\n        ipsw_custom+=\"J\"\n    fi\n    if [[ $device_proc == 1 && $device_type != \"iPhone1,2\" ]]; then\n        ipsw_custom2=\"$ipsw_custom\"\n    fi\n    if [[ -n $ipsw_customlogo || -n $ipsw_customrecovery ]]; then\n        ipsw_custom+=\"L\"\n        if [[ $device_proc == 1 && $device_type != \"iPhone1,2\" ]]; then\n            ipsw_customlogo2=1\n        fi\n    fi\n    if [[ $device_type == \"iPod2,1\" && $device_newbr == 0 && $device_target_vers == \"3.1.3\" ]]; then\n        ipsw_custom+=\"O\"\n    fi\n    if [[ $device_target_powder == 1 ]]; then\n        ipsw_custom+=\"P\"\n        if [[ $device_base_vers == \"7.0\"* ]]; then\n            ipsw_custom+=\"0\"\n        fi\n    fi\n    if [[ $device_target_tethered == 1 ]]; then\n        ipsw_custom+=\"T\"\n    fi\n    if [[ $ipsw_verbose == 1 ]]; then\n        ipsw_custom+=\"V\"\n    fi\n    if [[ $device_target_powder == 1 && $device_target_vers == \"4.3\"* ]]; then\n        ipsw_custom+=\"-$device_ecid\"\n    fi\n}\n\nmenu_logo_browse() {\n    local newpath\n    input \"Select your $1 image file in the file selection window.\"\n    if [[ $mac_cocoa == 1 ]]; then\n        newpath=\"$($cocoadialog fileselect --with-extensions png)\"\n    else\n        menu_zenity_check\n        newpath=\"$($zenity --file-selection --file-filter='PNG | *.png' --title=\"Select $1 image file\")\"\n    fi\n    [[ ! -s \"$newpath\" ]] && read -p \"$(input \"Enter path to $1 image file (or press Enter/Return or Ctrl+C to cancel): \")\" newpath\n    [[ ! -s \"$newpath\" ]] && return\n    log \"Selected $1 image file: $newpath\"\n    case $1 in\n        \"boot\" ) ipsw_customlogo=\"$newpath\";;\n        \"recovery\" ) ipsw_customrecovery=\"$newpath\";;\n    esac\n}\n\nmenu_ipsw_browse() {\n    local versionc\n    local newpath\n    local text=\"Target\"\n    local picker\n\n    local menu_items=($(ls ../$device_type*Restore.ipsw 2>/dev/null))\n    if [[ $1 == \"base\" ]]; then\n         text=\"Base\"\n         menu_items=()\n         case $device_type in\n            iPhone3,[13] ) menu_items=($(ls ../${device_type}_7.1.2*Restore.ipsw 2>/dev/null));;\n            iPad1,1 | iPod3,1 ) menu_items=($(ls ../${device_type}_5.1.1*Restore.ipsw 2>/dev/null));;\n            iPhone5* ) menu_items=($(ls ../${device_type}_7*Restore.ipsw 2>/dev/null));;\n            * ) menu_items=($(ls ../${device_type}_7.1*Restore.ipsw 2>/dev/null));;\n        esac\n    fi\n    case $1 in\n        \"iOS 10.3.3\" ) versionc=\"10.3.3\";;\n        \"iOS 8.4.1\" ) versionc=\"8.4.1\";;\n        \"iOS 6.1.3\" ) versionc=\"6.1.3\";;\n        \"Latest iOS\"* ) versionc=\"$device_latest_vers\";;\n        [6543]* ) versionc=\"$1\";;\n        \"custom\" ) text=\"Custom\";;\n    esac\n    if [[ $versionc == \"$device_latest_vers\" || $1 == \"custom\" ]]; then\n        menu_items=()\n    elif [[ -n $versionc ]]; then\n        menu_items=($(ls ../${device_type}_${versionc}*Restore.ipsw 2>/dev/null))\n    fi\n    menu_items+=(\"Open File Picker\" \"Enter Path\" \"Go Back\")\n\n    if [[ \"${menu_items[0]}\" == *\".ipsw\" ]]; then\n        print \"* Select $text IPSW Menu\"\n        while true; do\n            input \"Select an option:\"\n            select_option \"${menu_items[@]}\"\n            selected=\"${menu_items[$?]}\"\n            case $selected in\n                \"Open File Picker\" ) picker=1; break;;\n                \"Enter Path\" ) break;;\n                *.ipsw ) newpath=\"$selected\"; break;;\n                \"Go Back\" ) return;;\n            esac\n        done\n    else\n        picker=1\n    fi\n\n    if [[ $picker == 1 ]]; then\n        input \"Select your $text IPSW file in the file selection window.\"\n        if [[ $mac_cocoa == 1 ]]; then\n            newpath=\"$($cocoadialog fileselect --with-extensions ipsw)\"\n        elif [[ $1 == \"custom\" ]]; then\n            menu_zenity_check\n            newpath=\"$($zenity --file-selection --file-filter='IPSW | *.ipsw' --title=\"Select $text IPSW file\")\"\n        else\n            menu_zenity_check\n            newpath=\"$($zenity --file-selection --file-filter='IPSW | *Restore.ipsw' --title=\"Select $text IPSW file\")\"\n        fi\n    fi\n    if [[ ! -s \"$newpath\" ]]; then\n        print \"* Enter the full path to the IPSW file to be used.\"\n        print \"* You may also drag and drop the IPSW file to the Terminal window.\"\n        read -p \"$(input \"Path to $text IPSW file (or press Enter/Return or Ctrl+C to cancel): \")\" newpath\n    fi\n    [[ ! -s \"$newpath\" ]] && return\n    newpath=\"${newpath%?????}\"\n    log \"Selected IPSW file: $newpath.ipsw\"\n    ipsw_version_set \"$newpath\" \"$1\"\n\n    if [[ $(cat Restore.plist | grep -c $device_type) == 0 ]]; then\n        log \"Selected IPSW is not for your device $device_type.\"\n        pause\n        return\n    elif [[ $device_proc == 8 && $device_latest_vers == \"12\"* ]] || [[ $device_type == \"iPad4,6\" ]]; then\n        # SEP/BB check for iPhone 6/6+, iPad mini 2 China, iPod touch 6\n        case $device_target_build in\n            1[1234]* | 15[ABCD]* )\n                log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                print \"* Latest SEP/BB is not compatible.\"\n                pause\n                return\n            ;;\n        esac\n    elif [[ $device_proc == 7 ]]; then\n        # SEP/BB check for iPhone 5S, iPad Air 1/mini 2\n        case $device_target_build in\n            1[123]* | 14A* | 15[ABCD]* )\n                log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                print \"* Latest SEP/BB is not compatible.\"\n                pause\n                return\n            ;;\n        esac\n    elif [[ $device_latest_vers == \"15\"* ]]; then\n        # SEP/BB check for iPhone 6S/6S+/SE 2016/7/7+, iPad Air 2/mini 4, iPod touch 7\n        case $device_target_build in\n            1[234567]* )\n                log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                print \"* Latest SEP/BB is not compatible.\"\n                pause\n                return\n            ;;\n        esac\n    elif [[ $device_latest_vers == \"16\"* ]]; then\n        case $device_target_build in\n            20[GH]* ) :;; # 16.6 and newer only\n            18[CDEFGH]* | 19* )\n                if [[ $device_type == \"iPhone10,3\" || $device_type == \"iPhone10,6\" ]]; then\n                    log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                    print \"* Latest SEP/BB is not compatible.\"\n                    pause\n                    return\n                else\n                    warn \"Please read: You will need to follow a guide regarding activation files before and after the restore.\"\n                    print \"* You will encounter issues activating if you do not follow this.\"\n                    print \"* Link to guide: https://gist.github.com/pixdoet/2b58cce317a3bc7158dfe10c53e3dd32\"\n                    pause\n                fi\n            ;;\n            * )\n                log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                print \"* Latest SEP/BB is not compatible.\"\n                pause\n                return\n            ;;\n        esac\n    elif [[ $device_checkm8ipad == 1 ]]; then\n        case $device_target_build in\n            1[89]* )\n                warn \"Please read: You will need to follow a guide regarding activation files before and after the restore.\"\n                print \"* You will encounter issues activating if you do not follow this.\"\n                print \"* Link to guide: https://gist.github.com/pixdoet/2b58cce317a3bc7158dfe10c53e3dd32\"\n                pause\n            ;;\n            * )\n                log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                print \"* Latest SEP/BB is not compatible.\"\n                pause\n                return\n            ;;\n        esac\n    fi\n\n    case $1 in\n        \"base\" )\n            local check_vers=\"7.1\"\n            local base_vers=\"7.1.x\"\n            case $device_type in\n                iPhone5,[1234] )\n                    check_vers=\"7\"\n                    base_vers=\"7.x\"\n                ;;\n                iPad3* )\n                    check_vers=\"7.0\"\n                    base_vers=\"7.0.x\"\n                ;;\n                iPhone3* )\n                    check_vers=\"7.1.2\"\n                    base_vers=\"$check_vers\"\n                ;;\n                iPad1,1 | iPod3,1 )\n                    check_vers=\"5.1.1\"\n                    base_vers=\"$check_vers\"\n                ;;\n                iPad2,[123] )\n                    # fourthree\n                    check_vers=\"4.3\"\n                    base_vers=\"4.3.x\"\n                ;;\n            esac\n            if [[ $device_base_vers != \"$check_vers\"* ]]; then\n                log \"Selected IPSW is not for iOS $base_vers.\"\n                if [[ $device_proc == 4 ]]; then\n                    print \"* You need to select iOS $base_vers IPSW for the base to use powdersn0w.\"\n                elif [[ $ipsw_fourthree == 1 ]]; then\n                    print \"* You need to select iOS $base_vers IPSW for the base to use FourThree.\"\n                else\n                    print \"* You need iOS $base_vers IPSW and SHSH blobs for your device to use powdersn0w.\"\n                fi\n                pause\n                return\n            elif [[ $device_target_build == \"$device_base_build\" ]]; then\n                log \"The base version and the target version cannot be the same.\"\n                pause\n                return\n            fi\n            ipsw_verify \"$newpath\" \"$device_base_build\"\n            if [[ $? != 0 ]]; then\n                return\n            fi\n            ipsw_base_path=\"$newpath\"\n            return\n        ;;\n        *\"powdersn0w\"* )\n            if [[ $device_target_build == \"14\"* ]]; then\n                log \"Selected IPSW ($device_target_vers) is not supported as target version.\"\n                case $device_type in\n                    iPhone5,[12] ) print \"* If you want untethered iOS 10, use p0insettia plus: https://github.com/LukeZGD/p0insettia-plus\";;\n                esac\n                pause\n                return\n            elif [[ $device_target_build == \"11D257\" && $device_type == \"iPhone3\"* ]] ||\n                 [[ $device_target_build == \"9B206\" && $device_proc == 4 && $device_type != \"iPhone3\"* ]]; then\n                log \"Selected IPSW ($device_target_vers) is not supported as target version. You need to select it as base IPSW.\"\n                pause\n                return\n            elif [[ $device_target_build == \"$device_base_build\" ]]; then\n                log \"The base version and the target version cannot be the same.\"\n                pause\n                return\n            fi\n            versionc=\"powder\"\n        ;;\n    esac\n    if [[ $versionc == \"powder\" ]]; then\n        :\n    elif [[ -n $versionc && $device_target_vers != \"$versionc\" ]]; then\n        log \"Selected IPSW ($device_target_vers) does not match target version ($versionc).\"\n        pause\n        return\n    fi\n    if [[ $1 != \"custom\" ]]; then\n        ipsw_verify \"$newpath\" \"$device_target_build\"\n        if [[ -n $versionc && $? != 0 ]]; then\n            return\n        fi\n    fi\n    ipsw_path=\"$newpath\"\n}\n\nmenu_shsh_browse() {\n    local newpath\n    local text=\"Target\"\n    local val=\"$ipsw_path.ipsw\"\n    [[ $1 == \"base\" ]] && text=\"Base\"\n\n    input \"Select your $text SHSH file in the file selection window.\"\n    if [[ $mac_cocoa == 1 ]]; then\n        newpath=\"$($cocoadialog fileselect)\"\n    else\n        menu_zenity_check\n        newpath=\"$($zenity --file-selection --file-filter='SHSH | *.bshsh2 *.shsh *.shsh2' --title=\"Select $text SHSH file\")\"\n    fi\n    if [[ ! -s \"$newpath\" ]]; then\n        print \"* Enter the full path to the SHSH file to be used.\"\n        print \"* You may also drag and drop the SHSH file to the Terminal window.\"\n        read -p \"$(input \"Path to $text SHSH file (or press Enter/Return or Ctrl+C to cancel): \")\" newpath\n    fi\n    [[ ! -s \"$newpath\" ]] && return\n    log \"Selected SHSH file: $newpath\"\n    log \"Validating...\"\n    if (( device_proc >= 7 )); then\n        unzip -o -j \"$val\" BuildManifest.plist\n        shsh_validate=$(\"$dir/img4tool\" -s \"$newpath\" --verify BuildManifest.plist | tee /dev/tty | grep -c \"APTicket is BAD!\")\n    else\n        if [[ $1 == \"base\" ]]; then\n            val=\"$ipsw_base_path.ipsw\"\n        fi\n        \"$dir/validate\" \"$newpath\" \"$val\" -z\n        shsh_validate=$?\n    fi\n    if [[ $shsh_validate != 0 ]]; then\n        warn \"Validation failed. Did you select the correct IPSW/SHSH?\"\n        if (( device_proc < 5 )); then\n            warn \"Validation might be a false negative for A4 and older devices.\"\n        fi\n        pause\n    fi\n    shsh_path=\"$newpath\"\n}\n\nmenu_shshdump_browse() {\n    local newpath\n    input \"Select your raw dump file in the file selection window.\"\n    if [[ $mac_cocoa == 1 ]]; then\n        newpath=\"$($cocoadialog fileselect --with-extensions raw)\"\n    else\n        menu_zenity_check\n        newpath=\"$($zenity --file-selection --file-filter='Raw Dump | *.dump *.raw' --title=\"Select Raw Dump\")\"\n    fi\n    [[ ! -s \"$newpath\" ]] && read -p \"$(input \"Enter path to raw dump file (or press Enter/Return or Ctrl+C to cancel): \")\" newpath\n    [[ ! -s \"$newpath\" ]] && return\n    log \"Selected raw dump file: $newpath\"\n    shsh_path=\"$newpath\"\n}\n\nmenu_flags() {\n    local menu_items\n    local selected\n    local back\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=()\n        case $device_type in\n            iPhone[45]* | iPad2,[67] | iPad3,[56] ) menu_items+=(\"Enable disable-bbupdate flag\");;\n        esac\n        if (( device_proc >= 7 )); then\n            menu_items+=(\"Enable skip-blob flag\")\n        else\n            menu_items+=(\"Enable activation-records flag\" \"Enable jailbreak flag\")\n            if (( device_proc >= 5 )); then\n                menu_items+=(\"Enable skip-ibss flag\")\n            fi\n        fi\n        case $device_type in\n            iPhone4,1 ) menu_items+=(\"Enable gasgauge-patch flag\");;\n            iPhone3,[13] | iPad1,1 | iPod3,1 ) menu_items+=(\"Enable skip-first flag\");;\n        esac\n        menu_items+=(\"Go Back\")\n        menu_print_info\n        print \" > Main Menu > Misc Utilities > Enable Flags\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Enable disable-bbupdate flag\" )\n                warn \"This will enable the --disable-bbupdate flag.\"\n                print \"* This will disable baseband update for custom IPSWs.\"\n                print \"* This will enable usage of dumped baseband and stitch to IPSW.\"\n                print \"* This applies to the following: iPhone 4S, 5, 5C, iPad 4, mini 1\"\n                print \"* Do not enable this if you do not know what you are doing.\"\n                local opt\n                select_yesno \"Do you want to enable the disable-bbupdate flag?\" 0\n                if [[ $? != 0 ]]; then\n                    device_disable_bbupdate=\"$device_type\"\n                    back=1\n                fi\n            ;;\n            \"Enable activation-records flag\" )\n                warn \"This will enable the --activation-records flag.\"\n                print \"* This will enable usage of dumped activation records and stitch to IPSW.\"\n                print \"* Do not enable this if you do not know what you are doing.\"\n                local opt\n                select_yesno \"Do you want to enable the activation-records flag?\" 0\n                if [[ $? != 0 ]]; then\n                    device_actrec=1\n                    back=1\n                fi\n            ;;\n            \"Enable skip-ibss flag\" )\n                warn \"This will enable the --skip-ibss flag.\"\n                print \"* This will assume that a pwned iBSS has already been sent to the device.\"\n                print \"* Do not enable this if you do not know what you are doing.\"\n                local opt\n                select_yesno \"Do you want to enable the skip-ibss flag?\" 0\n                if [[ $? != 0 ]]; then\n                    device_skip_ibss=1\n                    back=1\n                fi\n            ;;\n            \"Enable jailbreak flag\" )\n                warn \"This will enable the --jailbreak flag.\"\n                print \"* This will enable the jailbreak option for the custom IPSW.\"\n                print \"* This is only useful for 4.1 and lower, where jailbreak option is disabled in most cases.\"\n                print \"* It is disabled for those versions by default because of issues with the custom IPSW jailbreak.\"\n                print \"* The recommended method is to jailbreak after the restore instead.\"\n                print \"* Do not enable this if you do not know what you are doing.\"\n                local opt\n                select_yesno \"Do you want to enable the jailbreak flag?\" 0\n                if [[ $? != 0 ]]; then\n                    ipsw_jailbreak=1\n                    back=1\n                fi\n            ;;\n            \"Enable gasgauge-patch flag\" )\n                warn \"This will enable the --gasgauge-patch flag.\"\n                print \"* This will enable \\\"multipatch\\\" for the custom IPSW.\"\n                print \"* This is especially useful for iPhone 4S devices that have issues restoring due to battery replacement.\"\n                print \"* This issue is called \\\"gas gauge\\\" error, also known as error 29 in iTunes.\"\n                print \"* By enabling this, firmware components for 6.1.3 or lower will be used for restoring to get past the error.\"\n                local opt\n                select_yesno \"Do you want to enable the gasgauge-patch flag?\" 0\n                if [[ $? != 0 ]]; then\n                    ipsw_gasgauge_patch=1\n                    back=1\n                fi\n            ;;\n            \"Enable skip-first flag\" )\n                warn \"This will enable the --skip-first flag.\"\n                print \"* This will skip first restore and flash NOR IPSW only for powdersn0w 4.2.x and lower.\"\n                print \"* Do not enable this if you do not know what you are doing.\"\n                local opt\n                select_yesno \"Do you want to enable the skip-ibss flag?\" 0\n                if [[ $? != 0 ]]; then\n                    ipsw_skip_first=1\n                    back=1\n                fi\n            ;;\n            \"Enable skip-blob flag\" )\n                warn \"This will enable the --skip-blob flag.\"\n                print \"* This will enable the skip blob flag of futurerestore.\"\n                print \"* This can be used to skip blob verification for OTA/onboard/factory SHSH blobs.\"\n                print \"* Do not enable this if you do not know what you are doing.\"\n                local opt\n                select_yesno \"Do you want to enable the skip-blob flag?\" 0\n                if [[ $? != 0 ]]; then\n                    restore_useskipblob=1\n                    back=1\n                fi\n            ;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_miscutilities() {\n    local menu_items\n    local selected\n    local back\n\n    menu_print_info\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=()\n        if [[ $device_mode != \"none\" ]]; then\n            if [[ $device_mode == \"Normal\" ]]; then\n                menu_items+=(\"Pair Device\" \"Export Device Info\")\n                if (( device_det < 5 )) && [[ $device_det != 1 ]]; then\n                    warn \"Device is on lower than iOS 5. Battery info is not available\"\n                else\n                    menu_items+=(\"Export Battery Info\")\n                fi\n                if (( device_det < 4 )) && [[ $device_det != 1 ]]; then\n                    warn \"Device is on lower than iOS 4. Shutdown/Restart device options are not available\"\n                else\n                    menu_items+=(\"Shutdown Device\" \"Restart Device\")\n                fi\n                menu_items+=(\"Enter Recovery Mode\" \"Attempt Activation\" \"Activation Records\")\n            fi\n            if [[ $device_proc != 1 ]] && (( device_proc < 7 )); then\n                if [[ $device_mode != \"Normal\" ]]; then\n                    menu_items+=(\"Get iOS Version\" \"Activation Records\")\n                fi\n                case $device_type in\n                    iPhone[45]* | iPad2,[67] | iPad3,[56] ) menu_items+=(\"Dump Baseband\");;\n                esac\n            fi\n        fi\n        if [[ $device_proc != 1 ]] && (( device_proc < 11 )); then\n            menu_items+=(\"Enable Flags\")\n        fi\n        if (( device_proc < 7 )); then\n            menu_items+=(\"Create Custom IPSW\")\n        fi\n        menu_items+=(\"(Re-)Install Dependencies\" \"Go Back\")\n        print \" > Main Menu > Misc Utilities\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Export Device Info\" )\n                mkdir -p ../saved/info 2>/dev/null\n                log \"Running ideviceinfo\"\n                local info=\"../saved/info/device-$device_ecid-$device_type-$(date +%Y-%m-%d-%H%M).txt\"\n                $ideviceinfo > $info\n                if [[ $? != 0 ]]; then\n                    $ideviceinfo -s > $info\n                fi\n                log \"Device Info exported to: $info\"\n            ;;\n            \"Export Battery Info\" )\n                mkdir -p ../saved/info 2>/dev/null\n                log \"Running idevicediagnostics\"\n                local info=\"../saved/info/battery-$device_ecid-$device_type-$(date +%Y-%m-%d-%H%M).txt\"\n                $idevicediagnostics ioregentry AppleSmartBattery > $info\n                if [[ $? != 0 ]]; then\n                    $idevicediagnostics ioregentry AppleARMPMUCharger > $info\n                fi\n                log \"Battery Info exported to: $info\"\n            ;;\n            \"Pair Device\" ) device_pair;;\n            \"Shutdown Device\" ) mode=\"shutdown\";;\n            \"Restart Device\" ) mode=\"restart\";;\n            \"Enter Recovery Mode\" ) mode=\"enterrecovery\";;\n            \"Attempt Activation\" ) device_activate;;\n            \"Dump Baseband\" ) mode=\"baseband\";;\n            \"Activation Records\" ) mode=\"actrec\";;\n            \"Enable Flags\" ) menu_flags;;\n            \"DFU Mode Helper\" ) mode=\"enterdfu\";;\n            \"(Re-)Install Dependencies\" ) install_depends;;\n            \"Create Custom IPSW\" ) menu_restore ipsw;;\n            \"Get iOS Version\" ) mode=\"getversion\";;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\nmenu_usefulutilities() {\n    local menu_items\n    local selected\n    local back\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=()\n        if [[ $device_proc != 1 ]] && (( device_proc < 7 )); then\n            if [[ $device_mode == \"Normal\" && $device_type != \"iPod2,1\" ]]; then\n                menu_items+=(\"Enter kDFU Mode\")\n            fi\n            case $device_proc in\n                [56] ) menu_items+=(\"Send Pwned iBSS\");;\n                *    ) menu_items+=(\"Enter pwnDFU Mode\");;\n            esac\n            menu_items+=(\"Clear NVRAM\")\n            if [[ $device_canpowder == 1 ]]; then\n                menu_items+=(\"Disable/Enable Exploit\")\n            elif [[ $device_type == \"iPhone2,1\" ]]; then\n                menu_items+=(\"Install alloc8 Exploit\")\n            fi\n            if [[ $device_type != \"iPod2,1\" && $device_mode == \"Normal\" ]]; then\n                menu_items+=(\"Just Boot\")\n            fi\n            if [[ $device_mode == \"Normal\" ]]; then\n                case $device_type in\n                    iPhone1* )\n                        case $device_vers in\n                            3.1.3 | 4.[12]* ) menu_items+=(\"Hacktivate Device\" \"Revert Hacktivation\");;\n                        esac\n                    ;;\n                    iPhone[23],1 )\n                        case $device_vers in\n                            3.1* | [456]* ) menu_items+=(\"Hacktivate Device\" \"Revert Hacktivation\");;\n                        esac\n                    ;;\n                esac\n            fi\n        fi\n        if (( device_proc >= 7 )) && (( device_proc <= 10 )); then\n            menu_items+=(\"Enter pwnDFU Mode\")\n        fi\n        if (( device_proc <= 10 )) && [[ $device_latest_vers != \"16\"* && $device_checkm8ipad != 1 && $device_proc != 1 ]]; then\n            menu_items+=(\"SSH Ramdisk\")\n        fi\n        menu_items+=(\"Update DateTime\")\n        if [[ $device_mode != \"DFU\" ]]; then\n            menu_items+=(\"DFU Mode Helper\")\n        fi\n        menu_items+=(\"Go Back\")\n        menu_print_info\n        # other utilities menu\n        print \" > Main Menu > Useful Utilities\"\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Hacktivate Device\" ) mode=\"device_hacktivate\";;\n            \"Revert Hacktivation\" ) mode=\"device_reverthacktivate\";;\n            \"Enter kDFU Mode\" ) mode=\"kdfu\";;\n            \"Disable/Enable Exploit\" ) menu_remove4;;\n            \"SSH Ramdisk\" ) mode=\"device_enter_ramdisk\";;\n            \"Clear NVRAM\" ) mode=\"ramdisknvram\";;\n            \"Send Pwned iBSS\" | \"Enter pwnDFU Mode\" ) mode=\"pwned-ibss\";;\n            \"Install alloc8 Exploit\" ) mode=\"device_alloc8\";;\n            \"Just Boot\" ) menu_justboot;;\n            \"Update DateTime\" ) device_update_datetime;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\ndevice_update_datetime() {\n    device_buttons2\n    if [[ $device_mode == \"Normal\" ]]; then\n        log \"Proceeding on Normal mode.\"\n        device_ssh_message\n        device_iproxy\n        device_sshpass\n        device_datetime_cmd\n        kill $iproxy_pid\n    else\n        mode=\"getversion\"\n    fi\n}\n\ndevice_pair() {\n    log \"Attempting idevicepair\"\n    \"$dir/idevicepair\" pair\n    if [[ $? != 0 ]]; then\n        log \"Unlock and press \\\"Trust\\\" on the device before pressing Enter/Return.\"\n        pause\n        log \"Attempting idevicepair\"\n    fi\n    \"$dir/idevicepair\" pair\n}\n\ndevice_ssh() {\n    print \"* Note: This is for connecting via SSH to devices that are already jailbroken and have OpenSSH installed.\"\n    print \"* If this is not what you want, you might be looking for the \\\"SSH Ramdisk\\\" option instead.\"\n    echo\n    device_ssh_message\n    device_iproxy no-logging\n    device_sshpass\n    log \"Connecting to device SSH...\"\n    print \"* For accessing data, note the following:\"\n    print \"* Host: sftp://127.0.0.1 | User: $ssh_user | Password: <your password> (default is alpine) | Port: $ssh_port\"\n    $ssh -p $ssh_port ${ssh_user}@127.0.0.1\n    kill $iproxy_pid\n}\n\ndevice_alloc8() {\n    device_enter_mode pwnDFU\n    device_ipwndfu alloc8\n    log \"Done!\"\n    print \"* This may take several tries. It can fail a lot with \\\"Operation timed out\\\" error.\"\n    print \"* If it fails, try to unplug and replug your device then run the script again.\"\n    print \"* You may also need to force restart the device and re-enter DFU mode before retrying.\"\n    print \"* To retry, just go back to: Useful Utilities -> Install alloc8 Exploit\"\n}\n\ndevice_jailbreak_confirm() {\n    if [[ $device_proc == 1 ]]; then\n        print \"* The \\\"Jailbreak Device\\\" option (ramdisk method) is not supported for this device.\"\n        print \"* To jailbreak, go to \\\"Restore/Downgrade\\\" instead, select 4.2.1, 4.1, or 3.1.3, then enable the jailbreak option.\"\n        pause\n        return\n    elif [[ $device_vers == *\"iBoot\"* || $device_vers == \"Unknown\"* ]]; then\n        device_vers=\n        while [[ -z $device_vers ]]; do\n            read -p \"$(input 'Enter current iOS version (eg. 6.1.3): ')\" device_vers\n        done\n    else\n        case $device_vers in\n            5* | 6.0* | 6.1 | 6.1.[12] )\n                print \"* Your device on iOS $device_vers will be jailbroken using g1lbertJB.\"\n                print \"* No data will be lost, but please back up your data just in case.\"\n                print \"* Ignore the \\\"Error Code 1\\\" and \\\"Error Code 102\\\" errors, this is normal and part of the jailbreaking process.\"\n                if [[ $device_proc == 4 ]]; then\n                    print \"* Note: If the process fails somewhere, you can just enter DFU mode and attempt jailbreaking again from there.\"\n                fi\n                select_yesno\n                if [[ $? != 1 ]]; then\n                    return\n                fi\n                mode=\"device_jailbreak_gilbert\"\n                return\n            ;;\n        esac\n    fi\n    log \"Checking if your device and version is supported...\"\n    if [[ $device_type == \"iPad2\"* && $device_vers == \"4\"* ]]; then\n        warn \"For this version, it will be a semi-tethered jailbreak. checkm8-a5 is required to boot to a jailbroken state.\"\n        print \"* To boot jailbroken later, go to: Main Menu -> Just Boot\"\n        pause\n    elif [[ $device_type == \"iPhone3,3\" ]]; then\n        case $device_vers in\n            4.2.9 | 4.2.10 )\n                warn \"For this version, it will be a semi-tethered jailbreak.\"\n                print \"* To boot jailbroken later, go to: Main Menu -> Just Boot\"\n                pause\n            ;;\n        esac\n    elif [[ $device_proc == 5 ]]; then\n        print \"* Note: It would be better to jailbreak using sideload or custom IPSW methods for A5 devices.\"\n        print \"* Especially since this method may require the usage of checkm8-a5.\"\n    elif [[ $device_proc == 6 && $platform == \"linux\" ]]; then\n        print \"* Note: It would be better to jailbreak using sideload or custom IPSW methods for A6 devices on Linux.\"\n    fi\n    if [[ $device_proc == 5 ]] || [[ $device_proc == 6 && $platform == \"linux\" ]]; then\n        case $device_vers in\n            7.1* )\n                print \"* For this version, Pangu on Windows/Mac can also be used instead of this option.\"\n                print \"* https://ios.cfw.guide/installing-pangu7/\"\n            ;;\n            7.0* )\n                print \"* For this version, evasi0n7 on Windows/Mac can also be used instead of this option.\"\n                print \"* https://ios.cfw.guide/installing-evasi0n7/\"\n            ;;\n            6.1.[3456] )\n                print \"* For this version, p0sixspwn on Windows/Mac can also be used instead of this option.\"\n                print \"* https://ios.cfw.guide/installing-p0sixspwn/\"\n            ;;\n            10* | 9* )\n                print \"* Note: If you need to sideload, you can use Legacy iOS Kit's \\\"Sideload IPA\\\" option.\"\n            ;;\n        esac\n    fi\n    print \"* For more details, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Jailbreaking\"\n    case $device_vers in\n        8* | 9.0* )\n            print \"* For this version, you can also use EverPwnage and sideload it to your device.\"\n            print \"* https://github.com/LukeZGD/EverPwnage\"\n            print \"* You may still continue if you really want to do the ramdisk method instead.\"\n        ;;\n        9.3.[56] )\n            print \"* For this version, download kok3shi9 and sideload it to your device.\"\n            print \"* https://kok3shidoll.web.app/kok3shi9_32.html\"\n            pause\n            return\n        ;;\n        9* )\n            print \"* For this version, you can also use JailbreakMe 4.0 to jailbreak your device.\"\n            print \"* https://lukezgd.github.io/jbme4/\"\n            print \"* You may still continue if you really want to do the ramdisk method instead.\"\n        ;;\n        10* )\n            print \"* For this version, download socket and sideload it to your device.\"\n            print \"* https://github.com/staturnzz/socket\"\n            pause\n            return\n        ;;\n        [765]* | 4.3* | 4.2.[8761] | 4.[10]* | 3.2* | 3.1.3 ) :;;\n        3.[10]* )\n            if [[ $device_type != \"iPhone2,1\" ]]; then\n                warn \"This version ($device_vers) is not supported for jailbreaking with ramdisk method.\"\n                print \"* Supported versions are: 3.1.3 to 9.3.4\"\n                pause\n                return\n            fi\n        ;;\n    esac\n    echo\n    if [[ $device_type == \"iPhone2,1\" && $device_vers == \"3\"* ]]; then\n        warn \"For 3.x versions on the 3GS, the \\\"Jailbreak Device\\\" option will only work on devices restored with Legacy iOS Kit.\"\n        print \"* This applies to all 3.x versions on the 3GS only. They require usage of the \\\"Restore/Downgrade\\\" option first.\"\n        echo\n    elif [[ $device_vers == \"7\"* ]]; then\n        warn \"The iOS 7 untethers may cause issues to your device after jailbreaking with this method.\"\n        print \"* You may encounter issues like slowdowns/freezing and losing baseband functionality.\"\n        print \"* It is recommended to instead dump blobs and restore with the jailbreak option enabled.\"\n        print \"* Or use other methods like jailbreaking with evasi0n7/Pangu if your device is not OTA updated.\"\n        echo\n    fi\n    print \"* By selecting Jailbreak Device, your device will be jailbroken using Ramdisk Method.\"\n    print \"* Before continuing, make sure that your device does not have a jailbreak yet.\"\n    print \"* No data will be lost, but please back up your data just in case.\"\n    select_yesno\n    if [[ $? != 1 ]]; then\n        return\n    fi\n    mode=\"device_jailbreak\"\n}\n\ndevice_jailbreak() {\n    device_ramdisk jailbreak\n}\n\ndevice_jailbreak_gilbert() {\n    pushd ../resources/jailbreak/g1lbertJB >/dev/null\n    log \"Copying freeze.tar to Cydia.tar\"\n    cp ../freeze.tar payload/common/Cydia.tar\n    log \"Running g1lbertJB...\"\n    \"../../$dir/gilbertjb\"\n    rm payload/common/Cydia.tar\n    popd >/dev/null\n}\n\ndevice_ssh_message() {\n    print \"* Make sure to have OpenSSH installed on your iOS device.\"\n    if [[ $device_det == 1 ]] && (( device_proc < 7 )); then\n        print \"* Install all updates in Cydia/Zebra.\"\n        print \"* Make sure to also have Dropbear installed from my repo.\"\n        print \"* Repo: https://lukezgd.github.io/repo\"\n    fi\n    print \"* Only proceed if you have these requirements installed using Cydia/Zebra/Sileo.\"\n    print \"* You will be prompted to enter the root/mobile password of your iOS device.\"\n    print \"* The default password is: alpine\"\n}\n\ndevice_dump() {\n    local arg=\"$1\"\n    local dump=\"../saved/$device_type/$arg-$device_ecid.tar\"\n    local dmps\n    local dmp2\n    case $arg in\n        \"baseband\" ) dmps=\"/usr/local/standalone\";;\n        \"activation\" )\n            dmp2=\"private/var/root/Library/Lockdown\"\n            case $device_vers in\n                [34567]* ) dmps=\"/$dmp2\";;\n                8* | 9.[012]* ) dmps=\"/private/var/mobile/Library/mad\";;\n                * )\n                    dmps=\"/private/var/containers/Data/System/*/Library/activation_records\"\n                    dmp2+=\"/activation_records\"\n                ;;\n            esac\n        ;;\n    esac\n\n    log \"Dumping files for $arg: $dmps\"\n    if [[ -s $dump ]]; then\n        log \"Found existing dumped $arg: $dump\"\n        print \"* Select Y to overwrite, or N to use existing dump\"\n        print \"* Make sure to keep a backup of the dump if needed\"\n        select_yesno \"Overwrite this existing dump?\" 0\n        if [[ $? != 1 ]]; then\n            return\n        fi\n        log \"Deleting existing dumped $arg\"\n        rm $dump\n    fi\n    if [[ $device_mode == \"Recovery\" ]]; then\n        device_enter_mode pwnDFU\n    elif [[ $device_mode == \"Normal\" ]]; then\n        device_buttons2\n    fi\n    if [[ $device_mode == \"Normal\" ]]; then\n        device_ssh_message\n        device_iproxy\n        device_sshpass\n        if [[ $arg == \"activation\" ]]; then\n            log \"Creating $arg.tar\"\n            $ssh -p $ssh_port ${ssh_user}@127.0.0.1 \"mkdir -p /tmp/$dmp2; find $dmps; cp -R $dmps/* /tmp/$dmp2\"\n            $ssh -p $ssh_port ${ssh_user}@127.0.0.1 \"cd /tmp; tar -cvf $arg.tar $dmp2\"\n            log \"Copying $arg.tar\"\n            $scp -P $ssh_port ${ssh_user}@127.0.0.1:/tmp/$arg.tar .\n            mv $arg.tar $arg-$device_ecid.tar\n        else\n            device_dumpbb\n        fi\n        cp $arg-$device_ecid.tar $dump\n    else\n        log \"This operation requires an SSH ramdisk, proceeding\"\n        print \"* I recommend dumping baseband/activation on Normal mode instead of Recovery/DFU mode if possible\"\n        device_enter_ramdisk $arg\n        device_dumprd\n        $ssh -p $ssh_port root@127.0.0.1 \"nvram auto-boot=0; reboot_bak\"\n        log \"Done, device should reboot to recovery mode now\"\n        log \"Just exit recovery mode if needed: Main Menu -> Exit Recovery Mode\"\n        if [[ $mode != \"baseband\" && $mode != \"actrec\" ]]; then\n            log \"Put your device back in kDFU/pwnDFU mode to proceed\"\n            device_find_mode Recovery\n            device_enter_mode DFU\n            device_enter_mode pwnDFU\n        fi\n    fi\n    kill $iproxy_pid\n    if [[ ! -e $dump ]]; then\n        error \"Failed to dump $arg from device. Please run the script again\"\n    fi\n    log \"Dumping $arg done: $dump\"\n}\n\ndevice_dumpbb() {\n    local bb2=\"Mav5\"\n    local root=\"/\"\n    local root2=\"/\"\n    local tmp=\"/tmp\"\n    case $device_type in\n        iPhone4,1 ) bb2=\"Trek\";;\n        iPhone5,[34] ) bb2=\"Mav7Mav8\";;\n    esac\n    if [[ $1 == \"rd\" ]]; then\n        root=\"/mnt1/\"\n        root2=\n        tmp=\"/mnt2/tmp\"\n    fi\n    log \"Creating baseband.tar\"\n    case $device_vers in\n        5* ) $scp -P $ssh_port root@127.0.0.1:${root}usr/standalone/firmware/$bb2-personalized.zip .;;\n        6* ) $scp -P $ssh_port root@127.0.0.1:${root}usr/local/standalone/firmware/Baseband/$bb2/$bb2-personalized.zip .;;\n    esac\n    case $device_vers in\n        [56]* )\n            mkdir -p usr/local/standalone/firmware/Baseband/$bb2\n            unzip $bb2-personalized.zip -d usr/local/standalone/firmware/Baseband/$bb2\n            cp $bb2-personalized.zip usr/local/standalone/firmware/Baseband/$bb2\n        ;;\n        * )\n            $ssh -p $ssh_port root@127.0.0.1 \"cd $root; tar -cvf $tmp/baseband.tar ${root2}usr/local/standalone/firmware\"\n            $scp -P $ssh_port root@127.0.0.1:$tmp/baseband.tar .\n            if [[ ! -s baseband.tar ]]; then\n                error \"Dumping baseband tar failed. Please run the script again\" \\\n                \"* If your device is on iOS 9 or newer, make sure to set the version of the SSH ramdisk correctly.\"\n            fi\n            tar -xvf baseband.tar -C .\n            rm baseband.tar\n            pushd usr/local/standalone/firmware/Baseband/$bb2 >/dev/null\n            zip -r0 $bb2-personalized.zip *\n            unzip -o $bb2-personalized.zip -d .\n            popd >/dev/null\n        ;;\n    esac\n    if [[ $device_type == \"iPhone4,1\" ]]; then\n        mkdir -p usr/standalone/firmware\n        cp usr/local/standalone/firmware/Baseband/$bb2/$bb2-personalized.zip usr/standalone/firmware\n    fi\n    tar -cvf baseband-$device_ecid.tar usr\n}\n\ndevice_dumprd() {\n    local dump=\"../saved/$device_type\"\n    local dmps\n    local dmp2\n    local vers\n    local tmp=\"/mnt2/tmp\"\n\n    device_ramdisk_iosvers\n    vers=$device_vers\n    if [[ -z $vers ]]; then\n        warn \"Something wrong happened. Failed to get iOS version.\"\n        print \"* Please reboot the device into normal operating mode, then perform a clean \\\"slide to power off\\\", then try again.\"\n        $ssh -p $ssh_port root@127.0.0.1 \"reboot_bak\"\n        return\n    fi\n    log \"Mounting filesystems\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mount.sh\"\n    sleep 1\n\n    case $device_type in\n        iPhone[45]* | iPad2,[67] | iPad3,[56] )\n            log \"Dumping both baseband and activation tars\"\n            device_dumpbb rd\n            print \"* Reminder to backup dump tars if needed\"\n            if [[ -s $dump/baseband-$device_ecid.tar ]]; then\n                select_yesno \"Baseband dump exists in $dump/baseband-$device_ecid.tar. Overwrite?\" 0\n                if [[ $? == 1 ]]; then\n                    log \"Deleting existing dumped baseband\"\n                    rm $dump/baseband-$device_ecid.tar\n                fi\n            fi\n            cp baseband-$device_ecid.tar $dump\n        ;;\n    esac\n\n    dmp2=\"root/Library/Lockdown\"\n    case $vers in\n        [34567]* ) dmps=\"$dmp2\";;\n        8* | 9.[012]* ) dmps=\"mobile/Library/mad\";;\n        * )\n            dmps=\"containers/Data/System/*/Library/activation_records\"\n            dmp2+=\"/activation_records\"\n        ;;\n    esac\n    log \"Creating activation.tar\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mkdir -p $tmp/private/var/$dmp2; cp -R /mnt2/$dmps/* $tmp/private/var/$dmp2\"\n    $ssh -p $ssh_port root@127.0.0.1 \"cd $tmp; tar -cvf $tmp/activation.tar private/var/$dmp2\"\n    log \"Copying activation.tar\"\n    print \"* Reminder to backup dump tars if needed\"\n    $scp -P $ssh_port root@127.0.0.1:$tmp/activation.tar .\n    if [[ ! -s activation.tar ]]; then\n        error \"Dumping activation record tar failed. Please run the script again\" \\\n        \"If your device is on iOS 9 or newer, make sure to set the version of the SSH ramdisk correctly.\"\n    fi\n    mv activation.tar activation-$device_ecid.tar\n    if [[ -s $dump/activation-$device_ecid.tar ]]; then\n        select_yesno \"Activation records dump exists in $dump/activation-$device_ecid.tar. Overwrite?\" 0\n        if [[ $? == 1 ]]; then\n            log \"Deleting existing dumped activation\"\n            rm $dump/activation-$device_ecid.tar\n        fi\n    fi\n    cp activation-$device_ecid.tar $dump\n    $ssh -p $ssh_port root@127.0.0.1 \"rm -f $tmp/*.tar\"\n}\n\ndevice_activate() {\n    log \"Attempting to activate device with ideviceactivation\"\n    if [[ $device_type == \"iPhone\"* ]] && (( device_proc <= 4 )); then\n        print \"* For iPhone 4 and older devices, make sure to have a valid SIM card.\"\n        case $device_type in\n            iPhone2,1 ) print \"* For hacktivation, go to \\\"Restore/Downgrade\\\" or \\\"Hacktivate Device\\\" instead.\";;\n            iPhone1*  ) print \"* For hacktivation, go to \\\"Restore/Downgrade\\\" instead.\";;\n        esac\n    fi\n    $ideviceactivation activate\n    if [[ $device_type == \"iPod\"* ]] && (( device_det <= 3 )); then\n        $ideviceactivation itunes\n    fi\n    print \"* If it returns an error, just try again.\"\n    device_unactivated=$($ideviceactivation state | grep -c \"Unactivated\")\n    pause\n}\n\ndevice_hacktivate() {\n    local type=\"$device_type\"\n    local build=\"$device_build\"\n    if [[ $device_type == \"iPhone3,1\" ]]; then\n        type=\"iPhone2,1\"\n        case $device_vers in\n            4.2.1 ) build=\"8C148a\";;\n            5.1.1 ) build=\"9B206\";;\n            6.1   ) build=\"10B141\";;\n        esac\n        log \"Checking ideviceactivation status...\"\n        $ideviceactivation activate\n    fi\n    local patch=\"../resources/firmware/FirmwareBundles/Down_${type}_${device_vers}_${build}.bundle/lockdownd.patch\"\n    print \"* Note: This is for hacktivating devices that are already restored, jailbroken, and have OpenSSH installed.\"\n    print \"* If this is not what you want, you might be looking for the \\\"Restore/Downgrade\\\" option instead.\"\n    print \"* From there, enable both \\\"Jailbreak Option\\\" and \\\"Hacktivate Option.\\\"\"\n    echo\n    print \"* Hacktivate Device: This will use SSH to patch lockdownd on your device.\"\n    print \"* Hacktivation is for iOS versions 3.1 to 6.1.6.\"\n    pause\n    device_iproxy\n    device_sshpass\n    log \"Getting lockdownd\"\n    $scp -P $ssh_port root@127.0.0.1:/usr/libexec/lockdownd .\n    log \"Patching lockdownd\"\n    $bspatch lockdownd lockdownd.patched \"$patch\"\n    log \"Renaming original lockdownd\"\n    $ssh -p $ssh_port root@127.0.0.1 \"[[ ! -e /usr/libexec/lockdownd.orig ]] && mv /usr/libexec/lockdownd /usr/libexec/lockdownd.orig\"\n    log \"Copying patched lockdownd to device\"\n    $scp -P $ssh_port lockdownd.patched root@127.0.0.1:/usr/libexec/lockdownd\n    $ssh -p $ssh_port root@127.0.0.1 \"chmod +x /usr/libexec/lockdownd; reboot\"\n    log \"Done. Your device should reboot now\"\n}\n\ndevice_reverthacktivate() {\n    print \"* This will use revert hacktivation for this device.\"\n    print \"* This option can only be used if the hacktivation is done using Legacy iOS Kit's \\\"Hacktivate Device\\\" option.\"\n    pause\n    device_iproxy\n    print \"* The default root password is: alpine\"\n    device_sshpass\n    log \"Reverting lockdownd\"\n    $ssh -p $ssh_port root@127.0.0.1 \"[[ -e /usr/libexec/lockdownd.orig ]] && rm /usr/libexec/lockdownd && mv /usr/libexec/lockdownd.orig /usr/libexec/lockdownd\"\n    $ssh -p $ssh_port root@127.0.0.1 \"chmod +x /usr/libexec/lockdownd; reboot\"\n    log \"Done. Your device should reboot now\"\n}\n\nrestore_customipsw_confirm() {\n    print \"* You are about to restore with a custom IPSW.\"\n    print \"* This option is only for restoring with IPSWs NOT made with Legacy iOS Kit, like whited00r or GeekGrade.\"\n    if [[ $device_newbr == 1 ]]; then\n        warn \"Your device is a new bootrom model and some custom IPSWs might not be compatible.\"\n        print \"* For iPhone 3GS, after restoring you will need to go to Useful Utilities -> Install alloc8 Exploit\"\n    else\n        warn \"Do NOT use this option for powdersn0w or jailbreak IPSWs made with Legacy iOS Kit!\"\n    fi\n    if [[ $platform == \"macos\" ]] && [[ $device_type == \"iPod2,1\" || $device_proc == 1 ]]; then\n        echo\n        warn \"Restoring to 2.x might not work on newer macOS versions.\"\n        print \"* Try installing usbmuxd from MacPorts, and run 'sudo usbmuxd -pf' in another Terminal window\"\n        print \"* Another option is to just do 2.x restores on Linux instead.\"\n        print \"* For more info, go to: https://github.com/LukeZGD/Legacy-iOS-Kit/wiki/Troubleshooting#restoring-to-iphoneosios-2x-on-macos\"\n    fi\n    if [[ $device_proc == 1 ]]; then\n        echo\n        print \"* Note that you might need to restore twice, due to NOR flash.\"\n        print \"* For iPhone 2G/3G, the second restore may fail due to baseband.\"\n        print \"* You can exit recovery mode after by going to: Main Menu -> Exit Recovery Mode\"\n    fi\n    select_yesno\n    if [[ $? != 1 ]]; then\n        return\n    fi\n    mode=\"customipsw\"\n}\n\nrestore_customipsw() {\n    menu_ipsw_browse \"custom\"\n    if [[ -z $ipsw_path ]]; then\n        error \"No IPSW selected, cannot continue.\"\n    fi\n    if [[ $device_proc == 1 ]]; then\n        device_enter_mode WTFreal\n    else\n        device_enter_mode pwnDFU\n    fi\n    ipsw_custom=\"$ipsw_path\"\n    restore_latest custom\n}\n\ndevice_dfuipsw_confirm() {\n    print \"* You are about to restore with a DFU IPSW.\"\n    print \"* This will force the device to enter DFU mode, which is useful for devices with broken buttons.\"\n    print \"* All device data will be wiped! Only proceed if you have backed up your data.\"\n    print \"* Expect the restore to fail and the device to be stuck in DFU mode.\"\n    select_yesno\n    if [[ $? != 1 ]]; then\n        return\n    fi\n    mode=\"device_dfuipsw\"\n}\n\ndevice_dfuipsw() {\n    # the only change done to the \"dfu ipsw\" is just applelogo copied and renamed to llb\n    # replacing llb with an invalid img3/im4p to make the restore fail, the device will then fallback to true dfu mode\n    # https://theapplewiki.com/wiki/DFU_Mode#Enter_True_Hardware_DFU_Mode_Automatically\n    # this function theoretically works on 64-bit devices, but restoring the dfu ipsw requires entering dfu for pwned restore\n    # which defeats the point of doing a dfu ipsw in the first place, so dfu ipsw is available for 32-bit devices only\n    device_target_vers=\"$device_latest_vers\"\n    device_target_build=\"$device_latest_build\"\n    ipsw_latest_set\n    ipsw_path=\"../$ipsw_latest_path\"\n    if [[ -s \"$ipsw_path.ipsw\" && ! -e \"$ipsw_dfuipsw.ipsw\" ]]; then\n        ipsw_verify \"$ipsw_path\" \"$device_target_build\"\n    elif [[ ! -e \"$ipsw_path.ipsw\" ]]; then\n        ipsw_download \"$ipsw_path\"\n    fi\n    if [[ -s \"$ipsw_dfuipsw.ipsw\" ]]; then\n        log \"Found existing DFU IPSW. Skipping IPSW creation.\"\n    else\n        cp $ipsw_path.ipsw temp.ipsw\n        local llb=\"${device_model}ap\"\n        local all=\"Firmware/all_flash\"\n        local applelogo\n        if (( device_proc >= 6 )); then\n            ipsw_hwmodel_set\n            case $device_type in\n                iPhone9,[13] ) llb=\"d10\";;\n                iPhone9,[24] ) llb=\"d11\";;\n                iPhone[78]* | iPad6,1* ) llb=\"$device_model\";;\n                * ) llb=\"$ipsw_hwmodel\"\n            esac\n            case $device_type in\n                iPhone5,[1234] ) applelogo=\"applelogo@2x~iphone.s5l8950x.img3\";;\n                iPad3,[456] ) applelogo=\"applelogo@2x~ipad.s5l8955x.img3\";;\n                iPhone* ) applelogo=\"applelogo@2x~iphone.im4p\";;\n                iPad* ) applelogo=\"applelogo@2x~ipad.im4p\";;\n            esac\n        else\n            all=\"$all_flash\"\n            device_fw_key_check\n            applelogo=$(echo $device_fw_key | $jq -j '.keys[] | select(.image == \"AppleLogo\") | .filename')\n        fi\n        llb=\"LLB.$llb.RELEASE\"\n        if (( device_proc >= 7 )); then\n            llb+=\".im4p\"\n        else\n            llb+=\".img3\"\n        fi\n        mkdir -p $all\n        unzip -o -j temp.ipsw $all/$applelogo -d .\n        mv $applelogo $all/$llb\n        zip -r0 temp.ipsw $all/*\n        mv temp.ipsw $ipsw_dfuipsw.ipsw\n    fi\n    if [[ $1 == \"ipsw\" ]]; then\n        return\n    fi\n    ipsw_path=\"$ipsw_dfuipsw\"\n    device_enter_mode Recovery\n    ipsw_extract\n    log \"Running idevicerestore with command: $idevicerestore -e \\\"$ipsw_path.ipsw\\\"\"\n    $idevicerestore -e \"$ipsw_path.ipsw\"\n    log \"Restoring done! Device should now be in DFU mode\"\n}\n\ndevice_enter_build() {\n    while true; do\n        device_rd_build=\n        read -p \"$(input 'Enter build version (eg. 10B329): ')\" device_rd_build\n        case $device_rd_build in\n            *[A-Z]* )\n                if [[ $device_rd_build != *.* ]]; then\n                    break\n                fi\n            ;;\n            \"\" )\n                if [[ $1 != \"required\" ]]; then\n                    break\n                fi\n            ;;\n        esac\n        log \"Build version input is not valid. Please try again\"\n    done\n}\n\nmenu_justboot() {\n    local menu_items\n    local selected\n    local back\n    local vers\n    local recent=\"../saved/$device_type/justboot_${device_ecid}\"\n\n    while [[ -z \"$mode\" && -z \"$back\" ]]; do\n        menu_items=(\"Enter Build Version\" \"Select IPSW\")\n        if [[ -s $recent ]]; then\n            menu_items+=(\"Recent Build Version\")\n        fi\n        if [[ -n $vers ]]; then\n            menu_items+=(\"Just Boot\")\n        fi\n        menu_items+=(\"Custom Bootargs\" \"Go Back\")\n        menu_print_info\n        print \" > Main Menu > Just Boot\"\n        print \"* You are about to do a tethered boot.\"\n        print \"* To know more about build version, go here: https://theapplewiki.com/wiki/Firmware\"\n        echo\n        if [[ -n $ipsw_justboot_path ]]; then\n            print \"* Selected IPSW: $ipsw_justboot_path.ipsw\"\n            print \"* IPSW Version: $device_target_vers-$device_target_build\"\n        elif [[ -n $vers ]]; then\n            print \"* Build Version entered: $vers\"\n        else\n            print \"* Enter build version or select IPSW to continue\"\n        fi\n        echo\n        if [[ -n $device_bootargs ]]; then\n            print \"* Custom Bootargs: $device_bootargs\"\n        else\n            print \"* You may enter custom bootargs (optional, experimental option)\"\n            print \"* Default Bootargs: pio-error=0 -v\"\n        fi\n        echo\n        input \"Select an option:\"\n        select_option \"${menu_items[@]}\"\n        selected=\"${menu_items[$?]}\"\n        case $selected in\n            \"Enter Build Version\" )\n                print \"* Enter the build version of your device's current iOS version to boot.\"\n                device_enter_build\n                case $device_rd_build in\n                    *[bcdefgkmpquv] )\n                        log \"iOS beta detected. Entering build version is not supported. Select the IPSW instead.\"\n                        pause\n                        continue\n                    ;;\n                esac\n                ipsw_justboot_path=\n                vers=\"$device_rd_build\"\n            ;;\n            \"Select IPSW\" )\n                menu_ipsw_browse\n                ipsw_justboot_path=\"$ipsw_path\"\n                vers=\"$device_target_build\"\n                device_rd_build=\"$vers\"\n            ;;\n            \"Recent Build Version\" )\n                vers=\"$(cat $recent)\"\n                device_rd_build=\"$vers\"\n            ;;\n            \"Just Boot\" )\n                echo \"$vers\" > $recent\n                mode=\"device_justboot\"\n            ;;\n            \"Custom Bootargs\" ) read -p \"$(input 'Enter custom bootargs: ')\" device_bootargs;;\n            \"Go Back\" ) back=1;;\n        esac\n    done\n}\n\ndevice_justboot() {\n    if [[ -z $device_bootargs ]]; then\n        device_bootargs=\"pio-error=0 -v\"\n    fi\n    if [[ $main_argmode == \"device_justboot\" ]]; then\n        cat \"$device_rd_build\" > \"../saved/$device_type/justboot_${device_ecid}\"\n    fi\n    device_ramdisk justboot\n}\n\ndevice_enter_ramdisk() {\n    if (( device_proc >= 7 )); then\n        if (( device_proc <= 8 )) && [[ $device_type != \"iPad5,1\" && $device_type != \"iPad5,2\" ]]; then\n            device_ramdiskver=\"12\"\n            if [[ $device_type == \"iPad5\"* ]]; then\n                device_ramdiskver=\"14\"\n            fi\n            local ver=\"$device_ramdiskver\"\n            input \"Version Select Option\"\n            print \"* The version of the SSH Ramdisk is set to iOS $ver by default. This is the recommended option.\"\n            print \"* There is also an option to use iOS 8 ramdisk. This can be used to fix devices on iOS 7 not booting after using iOS $ver ramdisk.\"\n            print \"* If not sure, just press Enter/Return. This will select the default version.\"\n            select_yesno \"Select Y to use iOS $ver, select N to use iOS 8\" 1\n            if [[ $? != 1 ]]; then\n                device_ramdisk_ios8=1\n            fi\n        fi\n    elif (( device_proc >= 5 )) && [[ $device_vers == \"9\"* || $device_vers == \"10\"* ]]; then\n        device_rd_build=\"13A452\"\n    elif (( device_proc >= 5 )) && (( device_det <= 8 )) && [[ $device_mode == \"Normal\" ]]; then\n        :\n    elif (( device_proc >= 5 )) && [[ -z $device_rd_build ]]; then\n        print \"* To mount /var (/mnt2) for iOS 9-10, I recommend using 9.0.2 (13A452).\"\n        print \"* If not sure, just press Enter/Return. This will select the default version.\"\n        device_enter_build\n    fi\n\n    if [[ $1 == \"menu\" ]]; then\n        clear\n        device_iproxy\n        device_sshpass alpine\n        menu_ramdisk\n        return\n    fi\n\n    if (( device_proc >= 7 )); then\n        device_ramdisk64\n    else\n        device_ramdisk $1\n    fi\n}\n\ndevice_enter_ramdisk_menu() {\n    device_enter_ramdisk menu\n}\n\ndevice_ideviceinstaller() {\n    log \"Installing selected IPA(s) to device using ideviceinstaller...\"\n    IFS='|' read -r -a ipa_files <<< \"$ipa_path\"\n    for i in \"${ipa_files[@]}\"; do\n        log \"Installing: $i\"\n        $ideviceinstaller install \"$i\"\n    done\n}\n\ndevice_altserver() {\n    local altserver=\"../saved/AltServer-$platform\"\n    local sha1=\"4bca48e9cda0517cc965250a797f97d5e8cc2de6\"\n    local anisette=\"../saved/anisette-server-$platform\"\n    local arch=\"$platform_arch\"\n    case $arch in\n        \"armhf\" ) arch=\"armv7\"; sha1=\"20e9ea770dbedb5c3c20f8b966be977efa2fa4cc\";;\n        \"arm64\" ) arch=\"aarch64\"; sha1=\"535926e5a14dc8f59f3f99197ca4122c7af8dfaf\";;\n    esac\n    altserver+=\"_$arch\"\n    anisette+=\"_$arch\"\n    if [[ $($sha1sum $altserver 2>/dev/null | awk '{print $1}') != \"$sha1\" ]]; then\n        rm -f $altserver\n    fi\n    if [[ ! -e $altserver ]]; then\n        download_file https://github.com/NyaMisty/AltServer-Linux/releases/download/v0.0.5/AltServer-$arch AltServer-$arch\n        mv AltServer-$arch $altserver\n    fi\n    log \"Checking for latest anisette-server\"\n    local latest=\"$(curl https://api.github.com/repos/LukeZGD/Provision/releases/latest | $jq -r \".tag_name\")\"\n    local current=\"$(cat ../saved/anisette-server_version 2>/dev/null || echo \"none\")\"\n    log \"Latest version: $latest, current version: $current\"\n    if [[ $current != \"$latest\" ]]; then\n        rm -f $anisette\n    fi\n    if [[ ! -e $anisette ]]; then\n        download_file https://github.com/LukeZGD/Provision/releases/download/$latest/anisette-server-$arch anisette-server-$arch\n        mv anisette-server-$arch $anisette\n        echo \"$latest\" > ../saved/anisette-server_version\n    fi\n    chmod +x $altserver $anisette\n    log \"Running Anisette\"\n    $anisette &\n    anisette_pid=$!\n    log \"Anisette PID: $anisette_pid\"\n    local ready=0\n    log \"Waiting for Anisette\"\n    while [[ $ready != 1 ]]; do\n        [[ $(curl 127.0.0.1:6969 2>/dev/null) ]] && ready=1\n        sleep 1\n    done\n    export ALTSERVER_ANISETTE_SERVER=http://127.0.0.1:6969\n    altserver=\"env ALTSERVER_ANISETTE_SERVER=$ALTSERVER_ANISETTE_SERVER $altserver\"\n    device_pair\n    log \"Enter Apple ID details to continue.\"\n    print \"* Your Apple ID and password will only be sent to Apple servers.\"\n    local apple_id\n    local apple_pass\n    while [[ -z $apple_id ]]; do\n        read -p \"$(input 'Apple ID: ')\" apple_id\n    done\n    print \"* Your password input will not be visible, but it is still being entered.\"\n    while [[ -z $apple_pass ]]; do\n        read -s -p \"$(input 'Password: ')\" apple_pass\n    done\n    echo\n    log \"Running AltServer-Linux with given Apple ID details...\"\n    pushd ../saved >/dev/null\n    $altserver -u $device_udid -a \"$apple_id\" -p \"$apple_pass\" \"$ipa_path\"\n    popd >/dev/null\n}\n\nrestore_latest64() {\n    local idevicerestore2=\"${idevicerestore}2\"\n    local opt=\"-l\"\n    local opt2\n    warn \"Restoring to iOS 18 or newer is not supported. Try using pymobiledevice3 instead for that\"\n    input \"Restore/Update Select Option\"\n    print \"* Restore will do factory reset and update the device, all data will be cleared\"\n    print \"* Update will only update the device to the latest version\"\n    print \"* Or press Ctrl+C to cancel\"\n    local selection=(\"Restore\" \"Update\")\n    input \"Select your option:\"\n    select_option \"${selection[@]}\"\n    case $? in\n        1 ) opt+=\"e\";;\n    esac\n    $idevicerestore2 $opt\n    mv *.ipsw ..\n}\n\ndevice_fourthree_step2() {\n    if [[ $device_mode != \"Normal\" ]]; then\n        error \"Device is not in normal mode. Place the device in normal mode to proceed.\" \\\n        \"The device must also be restored already with Step 1: Restore.\"\n    fi\n    print \"* Make sure that the device is already restored with Step 1: Restore before proceeding.\"\n    pause\n    device_iproxy\n    device_sshpass alpine\n    device_fourthree_check 2\n    if [[ $? == 2 ]]; then\n        warn \"Step 2 has already been completed. Cannot continue.\"\n        return\n    fi\n    print \"* How much GB do you want to allocate/leave to the 6.1.3 data partition?\"\n    print \"* The rest of the space will be allocated to the 4.3.x system.\"\n    print \"* If unsure, set it to 3 (this means 3 GB for 6.1.3, the rest for 4.3.x).\"\n    local size\n    until [[ -n $size ]] && [ \"$size\" -eq \"$size\" ]; do\n        read -p \"$(input 'iOS 6.1.3 Data Partition Size (in GB): ')\" size\n    done\n    log \"iOS 6.1.3 Data Partition Size: $size GB\"\n    size=$((size*1024*1024*1024))\n    log \"Sending package files\"\n    $scp -P $ssh_port $jelbrek/dualbootstuff.tar root@127.0.0.1:/tmp\n    log \"Installing packages\"\n    $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /tmp/dualbootstuff.tar -C /; dpkg -i /tmp/dualbootstuff/*.deb\"\n    log \"Running TwistedMind2\"\n    $ssh -p $ssh_port root@127.0.0.1 \"rm /TwistedMind2*; TwistedMind2 -d1 $size -s2 879124480 -d2 max\"\n    local tm2=\"$($ssh -p $ssh_port root@127.0.0.1 \"ls /TwistedMind2*\")\"\n    $scp -P $ssh_port root@127.0.0.1:$tm2 TwistedMind2\n    kill $iproxy_pid\n    log \"Rebooting to SSH ramdisk for the next procedure\"\n    device_ramdisk TwistedMind2\n    log \"Done, proceed to Step 3 after the device boots\"\n}\n\ndevice_fourthree_step3() {\n    if [[ $device_mode != \"Normal\" ]]; then\n        error \"Device is not in normal mode. Place the device in normal mode to proceed.\" \\\n        \"The device must also be set up already with Step 2: Partition.\"\n    fi\n    print \"* Make sure that the device is set up with Step 2: Partition before proceeding.\"\n    pause\n    source ../saved/$device_type/fourthree_$device_ecid\n    log \"4.3.x version: $device_base_vers-$device_base_build\"\n    local saved_path=\"../saved/$device_type/$device_base_build\"\n    device_iproxy\n    device_sshpass alpine\n    device_fourthree_check 3\n    if [[ $? == 0 ]]; then\n        warn \"Step 3 has already been completed. Cannot continue.\"\n        return\n    fi\n    log \"Creating filesystems\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mkdir /mnt1 /mnt2\"\n    $ssh -p $ssh_port root@127.0.0.1 \"/sbin/newfs_hfs -s -v System -J -b 8192 -n a=8192,c=8192,e=8192 /dev/disk0s3\"\n    $ssh -p $ssh_port root@127.0.0.1 \"/sbin/newfs_hfs -s -v Data -J -b 8192 -n a=8192,c=8192,e=8192 /dev/disk0s4\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mount_hfs /dev/disk0s4 /mnt2\"\n    log \"Sending root filesystem, this will take a while.\"\n    $scp -P $ssh_port $saved_path/RootFS.dmg root@127.0.0.1:/var\n    log \"Restoring root filesystem\"\n    $ssh -p $ssh_port root@127.0.0.1 \"echo 'y' | asr restore --source /var/RootFS.dmg --target /dev/disk0s3 --erase\"\n    log \"Checking root filesystem\"\n    $ssh -p $ssh_port root@127.0.0.1 \"rm /var/RootFS.dmg; fsck_hfs -f /dev/disk0s3\"\n    log \"Restoring data partition\"\n    $ssh -p $ssh_port root@127.0.0.1 \"umount /mnt2; mount_hfs /dev/disk0s3 /mnt1; mount_hfs /dev/disk0s4 /mnt2; mv /mnt1/private/var/* /mnt2\"\n    log \"Fixing fstab\"\n    $ssh -p $ssh_port root@127.0.0.1 \"echo '/dev/disk0s3 / hfs rw 0 1' | tee /mnt1/private/etc/fstab; echo '/dev/disk0s4 /private/var hfs rw 0 2' | tee -a /mnt1/private/etc/fstab\"\n    log \"Getting lockdownd\"\n    $scp -P $ssh_port root@127.0.0.1:/mnt1/usr/libexec/lockdownd .\n    local patch=\"../resources/firmware/FirmwareBundles/Down_iPhone2,1_${device_base_vers}_${device_base_build}.bundle/lockdownd.patch\"\n    log \"Patching lockdownd\"\n    $bspatch lockdownd lockdownd.patched \"$patch\"\n    log \"Renaming original lockdownd\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mv /mnt1/usr/libexec/lockdownd /mnt1/usr/libexec/lockdownd.orig\"\n    log \"Copying patched lockdownd to device\"\n    $scp -P $ssh_port lockdownd.patched root@127.0.0.1:/mnt1/usr/libexec/lockdownd\n    $ssh -p $ssh_port root@127.0.0.1 \"chmod +x /mnt1/usr/libexec/lockdownd\"\n    log \"Fixing system keybag\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mkdir /mnt2/keybags; ttbthingy; fixkeybag -v2; cp /tmp/systembag.kb /mnt2/keybags\"\n    log \"Remounting data partition\"\n    $ssh -p $ssh_port root@127.0.0.1 \"umount /mnt2; mount_hfs /dev/disk0s4 /mnt1/private/var\"\n    # idk if copying activation records actually works, probably not\n    log \"Copying activation records\"\n    local dmp=\"private/var/root/Library/Lockdown\"\n    $ssh -p $ssh_port root@127.0.0.1 \"mkdir -p /mnt1/$dmp; cp -Rv /$dmp/* /mnt1/$dmp\"\n    log \"Installing jailbreak\"\n    $scp -P $ssh_port $jelbrek/freeze.tar root@127.0.0.1:/tmp\n    $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /tmp/freeze.tar -C /mnt1\"\n    if [[ $ipsw_openssh == 1 ]]; then\n        log \"Installing OpenSSH\"\n        $scp -P $ssh_port $jelbrek/sshdeb.tar root@127.0.0.1:/tmp\n        $ssh -p $ssh_port root@127.0.0.1 \"tar -xvf /tmp/sshdeb.tar -C /mnt1\"\n    fi\n    log \"Unmounting filesystems\"\n    $ssh -p $ssh_port root@127.0.0.1 \"umount /mnt1/private/var; umount /mnt1\"\n    log \"Sending Kernelcache and LLB\"\n    $scp -P $ssh_port $saved_path/Kernelcache root@127.0.0.1:/System/Library/Caches/com.apple.kernelcaches/kernelcachb\n    $scp -P $ssh_port $saved_path/LLB root@127.0.0.1:/LLB\n    device_fourthree_app install\n    log \"Done!\"\n}\n\ndevice_fourthree_app() {\n    if [[ $1 != \"install\" ]]; then\n        device_iproxy\n        print \"* The default root password is: alpine\"\n        device_sshpass\n    fi\n    device_fourthree_check\n    log \"Installing FourThree app\"\n    $scp -P $ssh_port $jelbrek/fourthree.tar root@127.0.0.1:/tmp\n    $ssh -p $ssh_port root@127.0.0.1 \"tar -h -xvf /tmp/fourthree.tar -C /; cd /Applications/FourThree.app; chmod 6755 boot.sh FourThree kloader_ios5 /usr/bin/runasroot\"\n    log \"Running uicache\"\n    $ssh -p $ssh_port mobile@127.0.0.1 \"uicache\"\n}\n\ndevice_fourthree_boot() {\n    device_iproxy\n    print \"* The default root password is: alpine\"\n    device_sshpass\n    device_fourthree_check\n    log \"Running FourThree Boot\"\n    $ssh -p $ssh_port root@127.0.0.1 \"/Applications/FourThree.app/FourThree\"\n}\n\ndevice_fourthree_check() {\n    local opt=$1\n    local check\n    log \"Checking if Step 1 is complete\"\n    check=\"$($ssh -p $ssh_port root@127.0.0.1 \"ls /dev/disk0s2s1\")\"\n    if [[ $check != \"/dev/disk0s2s1\" ]]; then\n        error \"Cannot find /dev/disk0s2s1. Something went wrong with Step 1\" \\\n        \"* Redo the FourThree process from Step 1\"\n    fi\n    if [[ $opt == 1 ]]; then\n        return 1\n    fi\n    log \"Checking if Step 2 is complete\"\n    check=\"$($ssh -p $ssh_port root@127.0.0.1 \"ls /dev/disk0s3 2>/dev/null\")\"\n    if [[ $check != \"/dev/disk0s3\" ]]; then\n        if [[ $opt == 2 ]]; then\n            log \"Step 2 is not complete. Proceeding\"\n            return 1\n        fi\n        error \"Cannot find /dev/disk0s3. Something went wrong with Step 2\" \\\n        \"* Redo the FourThree process from Step 2\"\n    fi\n    if [[ $opt == 2 ]]; then\n        return 2\n    fi\n    log \"Checking if Step 3 is complete\"\n    local kcb=\"/System/Library/Caches/com.apple.kernelcaches/kernelcachb\"\n    local kc=\"$($ssh -p $ssh_port root@127.0.0.1 \"ls $kcb 2>/dev/null\")\"\n    local llb=\"$($ssh -p $ssh_port root@127.0.0.1 \"ls /LLB 2>/dev/null\")\"\n    if [[ $kc != \"$kcb\" || $llb != \"/LLB\" ]]; then\n        if [[ $opt == 3 ]]; then\n            log \"Step 3 is not complete. Proceeding\"\n            return 2\n        fi\n        error \"Cannot find Kernelcache/LLB. Something went wrong with Step 3\" \\\n        \"* Redo the FourThree process from Step 3\"\n    fi\n    return 0\n}\n\ndevice_backup_create() {\n    print \"* A backup of your device will be created using idevicebackup2. Please see the notes above.\"\n    pause\n    device_backup=\"../saved/backups/${device_ecid}_${device_type}/$(date +%Y-%m-%d-%H%M)\"\n    mkdir -p $device_backup\n    pushd \"$(dirname $device_backup)\"\n    dir=\"../../$dir\"\n    if [[ -n $dir_env ]]; then\n        dir_env=\"env LD_LIBRARY_PATH=$dir/lib \"\n    fi\n    $dir_env \"$dir/idevicebackup2\" backup --full \"$(basename $device_backup)\"\n    popd\n}\n\ndevice_backup_restore() {\n    print \"* The selected backup $device_backup will be restored to the device.\"\n    pause\n    device_backup=\"../saved/backups/${device_ecid}_${device_type}/$device_backup\"\n    pushd \"$(dirname $device_backup)\"\n    dir=\"../../$dir\"\n    if [[ -n $dir_env ]]; then\n        dir_env=\"env LD_LIBRARY_PATH=$dir/lib \"\n    fi\n    $dir_env \"$dir/idevicebackup2\" restore --system --settings \"$(basename $device_backup)\"\n    popd\n}\n\ndevice_erase() {\n    print \"* You have selected the option to Erase All Content and Settings.\"\n    print \"* As the option says, it will erase all data on the device and reset it to factory settings.\"\n    print \"* By the end of the operation, the device will be back on the setup screen.\"\n    print \"* If you want to proceed, please type the following: Yes, do as I say\"\n    read -p \"$(input 'Do you want to proceed? ')\" opt\n    if [[ $opt != \"Yes, do as I say\" ]]; then\n        error \"Not proceeding.\"\n    fi\n    log \"Proceeding.\"\n    $dir_env \"$dir/idevicebackup2\" erase\n}\n\nmain() {\n    clear\n    print \" *** Legacy iOS Kit ***\"\n    print \" - Script by LukeZGD -\"\n    echo\n    version_get\n\n    if [[ $EUID == 0 ]]; then\n        error \"Running the script as root is not allowed.\"\n    fi\n\n    if [[ ! -d \"../resources\" ]]; then\n        error \"The resources folder cannot be found. Replace resources folder and try again.\" \\\n        \"* If resources folder is present try removing spaces from path/folder name\"\n    fi\n\n    set_tool_paths\n\n    log \"Checking Internet connection...\"\n    local try=(\"google.com\" \"www.apple.com\" \"208.67.222.222\")\n    local check\n    for i in \"${try[@]}\"; do\n        ping -c1 $i >/dev/null\n        check=$?\n        if [[ $check == 0 ]]; then\n            break\n        fi\n    done\n    if [[ $check != 0 ]]; then\n        error \"Please check your Internet connection before proceeding.\"\n    fi\n\n    version_check\n\n    local checks=(curl git patch unzip xxd zip)\n    local check_fail\n    for check in \"${checks[@]}\"; do\n        if [[ $debug_mode == 1 ]]; then\n            log \"Checking for $check in PATH\"\n        fi\n        if [[ ! $(command -v $check) ]]; then\n            warn \"$check not found in PATH\"\n            check_fail=1\n        fi\n    done\n\n    if [[ ! -e \"../resources/firstrun\" || $(cat \"../resources/firstrun\") != \"$platform_ver\" || $check_fail == 1 ]]; then\n        install_depends\n    fi\n\n    device_get_info\n    mkdir -p ../saved/baseband ../saved/$device_type ../saved/shsh\n\n    mode=\n    if [[ -n $main_argmode ]]; then\n        mode=\"$main_argmode\"\n    else\n        menu_main\n    fi\n\n    case $mode in\n        \"custom-ipsw\" )\n            ipsw_preference_set\n            ipsw_prepare\n            log \"Done creating custom IPSW\"\n        ;;\n        \"downgrade\" )\n            ipsw_preference_set\n            ipsw_prepare\n            restore_prepare\n        ;;\n        \"baseband\" )\n            device_dump baseband\n            log \"Baseband dumping is done\"\n            print \"* To stitch baseband to IPSW, run Legacy iOS Kit with --disable-bbupdate argument:\"\n            print \"    > ./restore.sh --disable-bbupdate\"\n        ;;\n        \"actrec\" )\n            if (( device_proc >= 7 )); then\n                warn \"Activation records dumping is experimental for 64-bit devices.\"\n                print \"* It may not work on newer iOS versions and/or have incomplete files.\"\n                print \"* For more info of the files, go here: https://www.reddit.com/r/LegacyJailbreak/wiki/guides/a9ios9activation\"\n                print \"* You may also look into here: https://gist.github.com/pixdoet/2b58cce317a3bc7158dfe10c53e3dd32\"\n                pause\n            fi\n            device_dump activation\n            log \"Activation records dumping is done\"\n            if (( device_proc < 7 )); then\n                print \"* To stitch records to IPSW, run Legacy iOS Kit with --activation-records argument:\"\n                print \"    > ./restore.sh --activation-records\"\n            fi\n        ;;\n        \"save-ota-blobs\" ) shsh_save;;\n        \"kdfu\" ) device_enter_mode kDFU;;\n        \"ramdisknvram\" ) device_ramdisk clearnvram;;\n        \"pwned-ibss\" ) device_enter_mode pwnDFU;;\n        \"save-onboard-blobs\" ) shsh_save_onboard;;\n        \"save-onboard-dump\" ) shsh_save_onboard dump;;\n        \"save-cydia-blobs\" ) shsh_save_cydia;;\n        \"enterrecovery\" ) device_enter_mode Recovery;;\n        \"exitrecovery\" )\n            log \"Attempting to exit Recovery mode.\"\n            $irecovery -n\n            print \"* Note: For tether downgrades, you need to boot your device using the Just Boot option. Exiting recovery mode will not work.\"\n            if [[ $device_canpowder == 1 ]]; then\n                print \"* Note 2: If your device is stuck in recovery mode, it may have been restored with powdersn0w before.\"\n                print \"    - If so, try to clear the device's NVRAM: go to Useful Utilities -> Clear NVRAM\"\n            fi\n        ;;\n        \"enterdfu\" ) device_enter_mode DFU;;\n        \"dfuipswipsw\" ) device_dfuipsw ipsw;;\n        \"customipsw\" ) restore_customipsw;;\n        \"getversion\" ) device_ramdisk getversion;;\n        \"shutdown\" ) $idevicediagnostics shutdown;;\n        \"restart\" ) $idevicediagnostics restart;;\n        \"restore-latest\" ) restore_latest64;;\n        \"convert-onboard-blobs\" ) cp \"$shsh_path\" dump.raw; shsh_convert_onboard;;\n        \"remove4\" ) device_ramdisk setnvram $rec;;\n        \"device\"* ) $mode;;\n        * ) :;;\n    esac\n\n    echo\n    print \"* Save the terminal output now if needed. (macOS: Cmd+S, Linux: Ctrl+Shift+S)\"\n    print \"* Legacy iOS Kit $version_current ($git_hash)\"\n    print \"* Platform: $platform ($platform_ver - $platform_arch) $live_cdusb_str\"\n    echo\n}\n\nfor i in \"$@\"; do\n    case $i in\n        \"--no-color\" ) no_color=1;;\n        \"--no-device\" ) device_argmode=\"none\";;\n        \"--entry-device\" ) device_argmode=\"entry\";;\n        \"--no-version-check\" ) no_version_check=1;;\n        \"--debug\" ) set -x; debug_mode=1; menu_old=1;;\n        \"--help\" ) display_help; exit;;\n        \"--ipsw-verbose\" ) ipsw_verbose=1;;\n        \"--jailbreak\" ) ipsw_jailbreak=1;;\n        \"--memory\" ) ipsw_memory=1;;\n        \"--disable-bbupdate\" ) device_disable_bbupdate=1;;\n        \"--disable-sudoloop\" ) device_disable_sudoloop=1;;\n        \"--activation-records\" ) device_actrec=1;;\n        \"--ipsw-hacktivate\" ) ipsw_hacktivate=1;;\n        \"--skip-ibss\" ) device_skip_ibss=1;;\n        \"--pwned-recovery\" ) device_pwnrec=1;;\n        \"--gasgauge-patch\" ) ipsw_gasgauge_patch=1;;\n        \"--dead-bb\" ) device_deadbb=1; device_disable_bbupdate=1;;\n        \"--skip-first\" ) ipsw_skip_first=1;;\n        \"--skip-blob\" ) restore_useskipblob=1;;\n        \"--use-pwndfu\" ) restore_usepwndfu64=1;;\n        \"--device\"* ) device_type=\"${i#*=}\"; device_argmode=\"entry\";;\n        \"--ecid\"* ) device_ecid=\"${i#*=}\"; device_argmode=\"entry\";;\n        \"--build-id\"* ) device_rd_build=\"${i#*=}\";;\n        \"--bootargs\"* ) device_bootargs=\"${i#*=}\";;\n        \"--old-menu\" ) menu_old=1;;\n    esac\ndone\n\nif [[ $no_color != 1 ]]; then\n    TERM=xterm-256color # fix colors for msys2 terminal\n    color_R=$(tput setaf 9)\n    color_G=$(tput setaf 10)\n    color_B=$(tput setaf 12)\n    color_Y=$(tput setaf 208)\n    color_N=$(tput sgr0)\nfi\n\ncase $1 in\n    \"--dfuhelper\" ) main_argmode=\"device_dfuhelper\";;\n    \"--exit-recovery\" ) main_argmode=\"exitrecovery\";;\n    \"--just-boot\" )\n        print \"* Just Boot usage: --just-boot --build-id=<id>\"\n        print \"* Optional: --device=<type> --bootargs=\\\"<bootargs>\\\"\"\n        print \"* Example: --just-boot --device=iPhone5,2 --build-id=12H321\"\n        if [[ -z $device_rd_build ]]; then\n            error \"Just Boot (--just-boot) requires specifying build ID (--build-id=<id>)\"\n        fi\n        justboot_args=\"Just Boot arguments: --just-boot --device=$device_type --build-id=$device_rd_build\"\n        if [[ -n $device_bootargs ]]; then\n            justboot_args+=\" --bootargs=\\\"$device_bootargs\\\"\"\n        fi\n        log \"Just Boot arguments: $justboot_args\"\n        main_argmode=\"device_justboot\"\n    ;;\n    \"--pwn\" ) main_argmode=\"pwned-ibss\";;\n    \"--sshrd\" ) main_argmode=\"device_enter_ramdisk\";;\n    \"--sshrd-menu\" )\n        device_argmode=\"entry\"\n        main_argmode=\"device_enter_ramdisk_menu\"\n    ;;\n    \"--kdfu\" ) main_argmode=\"kdfu\";;\nesac\n\ntrap \"clean\" EXIT\ntrap \"exit 1\" INT TERM\n\nclean\nothertmp=$(ls \"$(dirname \"$0\")\" | grep -c tmp)\n\nif [[ $othertmp != 0 ]]; then\n    log \"Detected existing tmp folder(s).\"\n    print \"* There might be other Legacy iOS Kit instance(s) running, or residual tmp folder(s) not deleted.\"\n    print \"* Running multiple instances is not fully supported and can cause unexpected behavior.\"\n    print \"* It is recommended to only use a single instance and/or delete all existing \\\"tmp\\\" folders in your Legacy iOS Kit folder before continuing.\"\n    select_yesno \"Select Y to remove all tmp folders, N to run as is\" 1\n    if [[ $? == 1 ]]; then\n        rm -r \"$(dirname \"$0\")/tmp\"*\n    fi\nfi\n\nothertmp=$(ls \"$(dirname \"$0\")\" | grep -c tmp)\nmkdir \"$(dirname \"$0\")/tmp$$\"\npushd \"$(dirname \"$0\")/tmp$$\" >/dev/null\nmkdir ../saved 2>/dev/null\n\nmain\n\npopd >/dev/null\n"
        }
      ]
    }
  ]
}