{
  "metadata": {
    "timestamp": 1736568661969,
    "page": 743,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0OQ==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shayne/wsl2-hacks",
      "stars": 1297,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.5791015625,
          "content": "# wsl2-hacks - Updated for Ubuntu 20.04 / 20.10\nUseful snippets / tools for using WSL2 as a development environment\nUpdated based on issue #7 guidance from '@scotte' and '@JohnTasto'\n---\n\n**Auto-start/services** (`systemd` and `snap` support)\n\nI've done a few methods that have had various levels of success. My goal was to make it feel seamless for my workflow and have commands work as expected. What's below is the current version of the setup I use. It allows me to use the MS Terminal as well as VSCode's Remote WSL plugin.\n\nWith this setup your shells will be able to run `systemctl` commands, have auto-starting services, as well as be able to run [snaps](https://tutorials.ubuntu.com/tutorial/basic-snap-usage).\n\n1. Install deps\n\n    ```shell\n    $ sudo apt update\n    $ sudo apt install dbus policykit-1 daemonize\n    ```\n\n2. Create a fake-`bash`\n\n    This fake shell will intercept calls to `wsl.exe bash ...` and forward them to a real bash running in the right environment for `systemd`. If this sounds like a hack-- well, it is. However, I've tested various workflows and use this daily. That being said, your mileage may vary.\n\n    ```\n    $ sudo touch /usr/local/bin/wsl2hack\n    $ sudo chmod +x /usr/local/bin/wsl2hack\n    $ sudo editor /usr/local/bin/wsl2hack\n    ```\n        \n    Add the following, be sure to replace `<YOURUSER>` with your WSL2 Linux username\n\n    ```sh\n    #!/bin/bash\n    # your WSL2 username\n    UNAME=\"<YOURUSER>\"\n\n    UUID=$(id -u \"${UNAME}\")\n    UGID=$(id -g \"${UNAME}\")\n    UHOME=$(getent passwd \"${UNAME}\" | cut -d: -f6)\n    USHELL=$(getent passwd \"${UNAME}\" | cut -d: -f7)\n\n    if [[ -p /dev/stdin || \"${BASH_ARGC}\" > 0 && \"${BASH_ARGV[1]}\" != \"-c\" ]]; then\n        USHELL=/bin/bash\n    fi\n\n    if [[ \"${PWD}\" = \"/root\" ]]; then\n        cd \"${UHOME}\"\n    fi\n\n    # get pid of systemd\n    SYSTEMD_PID=$(pgrep -xo systemd)\n\n    # if we're already in the systemd environment\n    if [[ \"${SYSTEMD_PID}\" -eq \"1\" ]]; then\n        exec \"${USHELL}\" \"$@\"\n    fi\n\n    if [[ -z ${SYSTEMD_PID} ]]; then\n        # start systemd\n        /usr/bin/daemonize -l \"${HOME}/.systemd.lock\" /usr/bin/unshare -fp --mount-proc /lib/systemd/systemd --system-unit=basic.target\n\n        # wait for systemd to start\n        retries=50\n        while [[ -z ${SYSTEMD_PID} && $retries -ge 0 ]]; do\n            (( retries-- ))\n                sleep .1\n                SYSTEMD_PID=$(pgrep -xo systemd)\n        done\n\n        if [[ $retries -lt 0 ]]; then\n            >&2 echo \"Systemd timed out; aborting.\"\n            exit 1\n        fi\n    fi\n    \n    # export WSL variables\n    export WINPATH=\"$(echo \"$PATH\"|grep -o ':/mnt/c.*$'|sed 's!^:!!')\"\n    RUNOPTS=\"\"\n    RUNOPTS=\"$RUNOPTS -l\"\n    RUNOPTS=\"$RUNOPTS -w WINPATH\"\n    RUNOPTS=\"$RUNOPTS -w WSL_INTEROP\"\n    RUNOPTS=\"$RUNOPTS -w WSL_DISTRO_NAME\"\n    \n    # enter systemd namespace\n    exec /usr/bin/nsenter -t \"${SYSTEMD_PID}\" -m -p --wd=\"${PWD}\" /sbin/runuser $RUNOPTS -s \"${USHELL}\" \"${UNAME}\" -- \"${@}\"\n    ```\n\n3. Set the fake-`bash` as our `root` user's shell\n\n    We need `root` level permission to get `systemd` setup and enter the environment. The way I went about solving this is to\n    have WSL2 default to the `root` user and when `wsl.exe` is executed the fake-`bash` will do the right thing.\n    \n    The next step in getting this working is to change the default shell for our `root` user.\n    \n    Edit the `/etc/passwd` file:\n    \n    `$ vipw`\n    \n    `$ vipw -s`\n    \n    Find the line starting with `root:`, it should be the first line.\n    Add a line:\n    \n    `rootwsl:x:0:0:root:/root:/usr/local/bin/wsl2hack`\n    \n    *Never replace `/usr/bin/bash` as it is an actual binary in Ubuntu 20.04/20.10*\n    \n    Save and close this file.\n    \n    Make sure to update the primary passwd file *and* the shadow passwd file.\n\n4. Exit out of / close the WSL2 shell\n\n    The next step is to shutdown WSL2 and to change the default user to `root`.\n\n    In a PowerShell terminal run:\n    \n    ```\n    > wsl --shutdown\n    > ubuntu config --default-user root\n    ```\n    \n5. Re-open WSL2\n\n    Everything should be in place. Fire up WSL via the MS Terminal or just `wsl.exe`.\n    You should be logged in as your normal user and `systemd` should be running\n    \n    You can test by running the following in WSL2:\n    \n    ```sh\n    $ systemctl is-active dbus\n    active\n    ```\n\n6. Create `/etc/rc.local` (optional)\n\n    If you want to run certain commands when the WSL2 VM starts up, this is a useful file that's automatically ran by systemd.\n    \n    ```shell\n    $ sudo touch /etc/rc.local\n    $ sudo chmod +x /etc/rc.local\n    $ sudo editor /etc/rc.local\n    ```\n    \n    Add the following:\n    ```sh\n    #!/bin/sh -e\n    \n    # your commands here...\n    \n    exit 0\n    ```\n\n`/etc/rc.local` is only run on \"boot\", so only when you first access WSL2 (or it's shutdown due to inactivity/no-processes).\nTo test you can shutdown WSL via PowerShell/CMD `wsl --shutdown` then start it back up with `wsl`.\n\n---\n\n**Access localhost ports from Windows**\n\n**NOTE: No longer needed as of build 18945**\n\nMany development servers default to binding to `127.0.0.1` or `localhost`. It can be cumbersome and frustrating to get it to bind to `0.0.0.0` to make it accessible via Windows using the IP of the WSL2 VM.\n\n> Take a look at https://github.com/shayne/go-wsl2-host to have `wsl.local` automatically resolve to the WSL2 VM\n\nTo make these dev servers / ports accessible you can run the following commands, or add them to the `/etc/rc.local` if you have `systemd` running:\n\n```shell\n# /etc/rc.local runs as root by default\n# if you run these yourself add 'sudo' to the beginning of each command\n\n$ sysctl -w net.ipv4.conf.all.route_localnet=1\n$ iptables -t nat -I PREROUTING -p tcp -j DNAT --to-destination 127.0.0.1 \n```\n\n---\n\n**Increase `max_user_watches`**\n\nIf devtools are watching for file changes, the default is too low.\n\n```\n# /etc/rc.local runs as root by default\n# if you run these yourself add 'sudo' to the beginning of each command\n\nsysctl -w fs.inotify.max_user_watches=524288\n```\n\n---\n\n**Open MS Terminal to home directory by default**\n\nOpen your MS Terminal configuration <kbd>Ctrl+,</kbd>\n\nFind the `\"commandLine\":...` config for the WSL profile.\n\nChange to something like:\n\n```json\n\"commandline\": \"wsl.exe ~ -d Ubuntu-18.04\",\n```\n\n\n**Copy current IP of WSL2 into Windows clipboard** (optionally with port 3000 here):\n\n```\nhostname -I | awk '{print $1}' | awk '{printf \"%s:3000\", $0}' | clip.exe\n```\n\nAlternatively, put it in a file, for example `copy_ip.sh`, make it executable with `chmod +x copy_ip.sh` and you can get the IP any time with `./copy_ip.sh`: \n\n```\n#!/bin/bash\nhostname -I | awk '{print $1}' | awk '{printf \"%s:3000\", $0}' | clip.exe\n```\n"
        },
        {
          "name": "wsl2hack.sh",
          "type": "blob",
          "size": 1.140625,
          "content": "#!/bin/bash\n# your WSL2 username\nUNAME=\"<YOURUSER>\"\n\nUUID=$(id -u \"${UNAME}\")\nUGID=$(id -g \"${UNAME}\")\nUHOME=$(getent passwd \"${UNAME}\" | cut -d: -f6)\nUSHELL=$(getent passwd \"${UNAME}\" | cut -d: -f7)\n\nif [[ -p /dev/stdin || \"${BASH_ARGC}\" > 0 && \"${BASH_ARGV[1]}\" != \"-c\" ]]; then\n    USHELL=/bin/bash\nfi\n\nif [[ \"${PWD}\" = \"/root\" ]]; then\n    cd \"${UHOME}\"\nfi\n\n# get pid of systemd\nSYSTEMD_PID=$(pgrep -xo systemd)\n\n# if we're already in the systemd environment\nif [[ \"${SYSTEMD_PID}\" -eq \"1\" ]]; then\n    exec \"${USHELL}\" \"$@\"\nfi\n\nif [[ -z ${SYSTEMD_PID} ]]; then\n    # start systemd\n    /usr/bin/daemonize -l \"${HOME}/.systemd.lock\" /usr/bin/unshare -fp --mount-proc /lib/systemd/systemd --system-unit=basic.target\n\n    # wait for systemd to start\n    retries=50\n    while [[ -z ${SYSTEMD_PID} && $retries -ge 0 ]]; do\n        (( retries-- ))\n            sleep .1\n            SYSTEMD_PID=$(pgrep -xo systemd)\n    done\n\n    if [[ $retries -lt 0 ]]; then\n        >&2 echo \"Systemd timed out; aborting.\"\n        exit 1\n    fi\nfi\n\n# enter systemd namespace\nexec /usr/bin/nsenter -t \"${SYSTEMD_PID}\" -m -p --wd=\"${PWD}\" /sbin/runuser -s \"${USHELL}\" \"${UNAME}\" -- \"${@}\"\n"
        }
      ]
    }
  ]
}